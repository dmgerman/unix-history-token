begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//==- PrintfFormatStrings.h - Analysis of printf format strings --*- C++ -*-==//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// Handling of format string in printf and friends.  The structure of format
end_comment

begin_comment
comment|// strings for fprintf() are described in C99 7.19.6.1.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LLVM_CLANG_FPRINTF_FORMAT_H
end_ifndef

begin_define
define|#
directive|define
name|LLVM_CLANG_FPRINTF_FORMAT_H
end_define

begin_include
include|#
directive|include
file|"clang/AST/CanonicalType.h"
end_include

begin_decl_stmt
name|namespace
name|clang
block|{
name|class
name|ASTContext
decl_stmt|;
name|namespace
name|analyze_printf
block|{
name|class
name|ArgTypeResult
block|{
name|public
label|:
enum|enum
name|Kind
block|{
name|UnknownTy
block|,
name|InvalidTy
block|,
name|SpecificTy
block|,
name|ObjCPointerTy
block|,
name|CStrTy
block|,
name|WCStrTy
block|}
enum|;
name|private
label|:
specifier|const
name|Kind
name|K
decl_stmt|;
name|QualType
name|T
decl_stmt|;
name|ArgTypeResult
argument_list|(
name|bool
argument_list|)
operator|:
name|K
argument_list|(
argument|InvalidTy
argument_list|)
block|{}
name|public
operator|:
name|ArgTypeResult
argument_list|(
argument|Kind k = UnknownTy
argument_list|)
operator|:
name|K
argument_list|(
argument|k
argument_list|)
block|{}
name|ArgTypeResult
argument_list|(
argument|QualType t
argument_list|)
operator|:
name|K
argument_list|(
name|SpecificTy
argument_list|)
operator|,
name|T
argument_list|(
argument|t
argument_list|)
block|{}
name|ArgTypeResult
argument_list|(
argument|CanQualType t
argument_list|)
operator|:
name|K
argument_list|(
name|SpecificTy
argument_list|)
operator|,
name|T
argument_list|(
argument|t
argument_list|)
block|{}
specifier|static
name|ArgTypeResult
name|Invalid
argument_list|()
block|{
return|return
name|ArgTypeResult
argument_list|(
name|true
argument_list|)
return|;
block|}
name|bool
name|isValid
argument_list|()
specifier|const
block|{
return|return
name|K
operator|!=
name|InvalidTy
return|;
block|}
specifier|const
name|QualType
operator|*
name|getSpecificType
argument_list|()
specifier|const
block|{
return|return
name|K
operator|==
name|SpecificTy
operator|?
operator|&
name|T
operator|:
literal|0
return|;
block|}
name|bool
name|matchesType
argument_list|(
name|ASTContext
operator|&
name|C
argument_list|,
name|QualType
name|argTy
argument_list|)
decl|const
decl_stmt|;
name|bool
name|matchesAnyObjCObjectRef
argument_list|()
specifier|const
block|{
return|return
name|K
operator|==
name|ObjCPointerTy
return|;
block|}
name|QualType
name|getRepresentativeType
argument_list|(
name|ASTContext
operator|&
name|C
argument_list|)
decl|const
decl_stmt|;
block|}
empty_stmt|;
name|class
name|ConversionSpecifier
block|{
name|public
label|:
enum|enum
name|Kind
block|{
name|InvalidSpecifier
init|=
literal|0
block|,
comment|// C99 conversion specifiers.
name|dArg
block|,
comment|// 'd'
name|iArg
block|,
comment|// 'i',
name|oArg
block|,
comment|// 'o',
name|uArg
block|,
comment|// 'u',
name|xArg
block|,
comment|// 'x',
name|XArg
block|,
comment|// 'X',
name|fArg
block|,
comment|// 'f',
name|FArg
block|,
comment|// 'F',
name|eArg
block|,
comment|// 'e',
name|EArg
block|,
comment|// 'E',
name|gArg
block|,
comment|// 'g',
name|GArg
block|,
comment|// 'G',
name|aArg
block|,
comment|// 'a',
name|AArg
block|,
comment|// 'A',
name|IntAsCharArg
block|,
comment|// 'c'
name|CStrArg
block|,
comment|// 's'
name|VoidPtrArg
block|,
comment|// 'p'
name|OutIntPtrArg
block|,
comment|// 'n'
name|PercentArg
block|,
comment|// '%'
comment|// MacOS X unicode extensions.
name|CArg
block|,
comment|// 'C'
name|UnicodeStrArg
block|,
comment|// 'S'
comment|// Objective-C specific specifiers.
name|ObjCObjArg
block|,
comment|// '@'
comment|// GlibC specific specifiers.
name|PrintErrno
block|,
comment|// 'm'
comment|// Specifier ranges.
name|IntArgBeg
init|=
name|dArg
block|,
name|IntArgEnd
init|=
name|iArg
block|,
name|UIntArgBeg
init|=
name|oArg
block|,
name|UIntArgEnd
init|=
name|XArg
block|,
name|DoubleArgBeg
init|=
name|fArg
block|,
name|DoubleArgEnd
init|=
name|AArg
block|,
name|C99Beg
init|=
name|IntArgBeg
block|,
name|C99End
init|=
name|DoubleArgEnd
block|,
name|ObjCBeg
init|=
name|ObjCObjArg
block|,
name|ObjCEnd
init|=
name|ObjCObjArg
block|}
enum|;
name|ConversionSpecifier
argument_list|()
operator|:
name|Position
argument_list|(
literal|0
argument_list|)
operator|,
name|kind
argument_list|(
argument|InvalidSpecifier
argument_list|)
block|{}
name|ConversionSpecifier
argument_list|(
argument|const char *pos
argument_list|,
argument|Kind k
argument_list|)
operator|:
name|Position
argument_list|(
name|pos
argument_list|)
operator|,
name|kind
argument_list|(
argument|k
argument_list|)
block|{}
specifier|const
name|char
operator|*
name|getStart
argument_list|()
specifier|const
block|{
return|return
name|Position
return|;
block|}
name|llvm
operator|::
name|StringRef
name|getCharacters
argument_list|()
specifier|const
block|{
return|return
name|llvm
operator|::
name|StringRef
argument_list|(
name|getStart
argument_list|()
argument_list|,
name|getLength
argument_list|()
argument_list|)
return|;
block|}
name|bool
name|consumesDataArgument
argument_list|()
specifier|const
block|{
switch|switch
condition|(
name|kind
condition|)
block|{
case|case
name|PercentArg
case|:
case|case
name|PrintErrno
case|:
return|return
name|false
return|;
default|default:
return|return
name|true
return|;
block|}
block|}
name|bool
name|isObjCArg
argument_list|()
specifier|const
block|{
return|return
name|kind
operator|>=
name|ObjCBeg
operator|&&
name|kind
operator|<=
name|ObjCEnd
return|;
block|}
name|bool
name|isIntArg
argument_list|()
specifier|const
block|{
return|return
name|kind
operator|>=
name|dArg
operator|&&
name|kind
operator|<=
name|iArg
return|;
block|}
name|bool
name|isUIntArg
argument_list|()
specifier|const
block|{
return|return
name|kind
operator|>=
name|oArg
operator|&&
name|kind
operator|<=
name|XArg
return|;
block|}
name|bool
name|isDoubleArg
argument_list|()
specifier|const
block|{
return|return
name|kind
operator|>=
name|fArg
operator|&&
name|kind
operator|<=
name|AArg
return|;
block|}
name|Kind
name|getKind
argument_list|()
specifier|const
block|{
return|return
name|kind
return|;
block|}
name|unsigned
name|getLength
argument_list|()
specifier|const
block|{
comment|// Conversion specifiers currently only are represented by
comment|// single characters, but we be flexible.
return|return
literal|1
return|;
block|}
name|private
label|:
specifier|const
name|char
modifier|*
name|Position
decl_stmt|;
name|Kind
name|kind
decl_stmt|;
block|}
empty_stmt|;
enum|enum
name|LengthModifier
block|{
name|None
block|,
name|AsChar
block|,
comment|// 'hh'
name|AsShort
block|,
comment|// 'h'
name|AsLong
block|,
comment|// 'l'
name|AsLongLong
block|,
comment|// 'll', 'q' (BSD, deprecated)
name|AsIntMax
block|,
comment|// 'j'
name|AsSizeT
block|,
comment|// 'z'
name|AsPtrDiff
block|,
comment|// 't'
name|AsLongDouble
block|,
comment|// 'L'
name|AsWideChar
init|=
name|AsLong
comment|// for '%ls'
block|}
enum|;
name|class
name|OptionalAmount
block|{
name|public
label|:
enum|enum
name|HowSpecified
block|{
name|NotSpecified
block|,
name|Constant
block|,
name|Arg
block|,
name|Invalid
block|}
enum|;
name|OptionalAmount
argument_list|(
argument|HowSpecified h
argument_list|,
argument|unsigned i
argument_list|,
argument|const char *st
argument_list|)
block|:
name|start
argument_list|(
name|st
argument_list|)
operator|,
name|hs
argument_list|(
name|h
argument_list|)
operator|,
name|amt
argument_list|(
argument|i
argument_list|)
block|{}
name|OptionalAmount
argument_list|(
argument|bool b = true
argument_list|)
operator|:
name|start
argument_list|(
literal|0
argument_list|)
operator|,
name|hs
argument_list|(
name|b
operator|?
name|NotSpecified
operator|:
name|Invalid
argument_list|)
operator|,
name|amt
argument_list|(
literal|0
argument_list|)
block|{}
name|bool
name|isInvalid
argument_list|()
specifier|const
block|{
return|return
name|hs
operator|==
name|Invalid
return|;
block|}
name|HowSpecified
name|getHowSpecified
argument_list|()
specifier|const
block|{
return|return
name|hs
return|;
block|}
name|bool
name|hasDataArgument
argument_list|()
specifier|const
block|{
return|return
name|hs
operator|==
name|Arg
return|;
block|}
name|unsigned
name|getArgIndex
argument_list|()
specifier|const
block|{
name|assert
argument_list|(
name|hasDataArgument
argument_list|()
argument_list|)
block|;
return|return
name|amt
return|;
block|}
name|unsigned
name|getConstantAmount
argument_list|()
specifier|const
block|{
name|assert
argument_list|(
name|hs
operator|==
name|Constant
argument_list|)
block|;
return|return
name|amt
return|;
block|}
specifier|const
name|char
operator|*
name|getStart
argument_list|()
specifier|const
block|{
return|return
name|start
return|;
block|}
name|ArgTypeResult
name|getArgType
argument_list|(
name|ASTContext
operator|&
name|Ctx
argument_list|)
decl|const
decl_stmt|;
name|private
label|:
specifier|const
name|char
modifier|*
name|start
decl_stmt|;
name|HowSpecified
name|hs
decl_stmt|;
name|unsigned
name|amt
decl_stmt|;
block|}
empty_stmt|;
name|class
name|FormatSpecifier
block|{
name|LengthModifier
name|LM
decl_stmt|;
name|unsigned
name|IsLeftJustified
range|:
literal|1
decl_stmt|;
name|unsigned
name|HasPlusPrefix
range|:
literal|1
decl_stmt|;
name|unsigned
name|HasSpacePrefix
range|:
literal|1
decl_stmt|;
name|unsigned
name|HasAlternativeForm
range|:
literal|1
decl_stmt|;
name|unsigned
name|HasLeadingZeroes
range|:
literal|1
decl_stmt|;
comment|/// Positional arguments, an IEEE extension:
comment|///  IEEE Std 1003.1, 2004 Edition
comment|///  http://www.opengroup.org/onlinepubs/009695399/functions/printf.html
name|unsigned
name|UsesPositionalArg
range|:
literal|1
decl_stmt|;
name|unsigned
name|argIndex
decl_stmt|;
name|ConversionSpecifier
name|CS
decl_stmt|;
name|OptionalAmount
name|FieldWidth
decl_stmt|;
name|OptionalAmount
name|Precision
decl_stmt|;
name|public
label|:
name|FormatSpecifier
argument_list|()
operator|:
name|LM
argument_list|(
name|None
argument_list|)
operator|,
name|IsLeftJustified
argument_list|(
literal|0
argument_list|)
operator|,
name|HasPlusPrefix
argument_list|(
literal|0
argument_list|)
operator|,
name|HasSpacePrefix
argument_list|(
literal|0
argument_list|)
operator|,
name|HasAlternativeForm
argument_list|(
literal|0
argument_list|)
operator|,
name|HasLeadingZeroes
argument_list|(
literal|0
argument_list|)
operator|,
name|UsesPositionalArg
argument_list|(
literal|0
argument_list|)
operator|,
name|argIndex
argument_list|(
literal|0
argument_list|)
block|{}
specifier|static
name|FormatSpecifier
name|Parse
argument_list|(
specifier|const
name|char
operator|*
name|beg
argument_list|,
specifier|const
name|char
operator|*
name|end
argument_list|)
expr_stmt|;
comment|// Methods for incrementally constructing the FormatSpecifier.
name|void
name|setConversionSpecifier
parameter_list|(
specifier|const
name|ConversionSpecifier
modifier|&
name|cs
parameter_list|)
block|{
name|CS
operator|=
name|cs
expr_stmt|;
block|}
name|void
name|setLengthModifier
parameter_list|(
name|LengthModifier
name|lm
parameter_list|)
block|{
name|LM
operator|=
name|lm
expr_stmt|;
block|}
name|void
name|setIsLeftJustified
parameter_list|()
block|{
name|IsLeftJustified
operator|=
literal|1
expr_stmt|;
block|}
name|void
name|setHasPlusPrefix
parameter_list|()
block|{
name|HasPlusPrefix
operator|=
literal|1
expr_stmt|;
block|}
name|void
name|setHasSpacePrefix
parameter_list|()
block|{
name|HasSpacePrefix
operator|=
literal|1
expr_stmt|;
block|}
name|void
name|setHasAlternativeForm
parameter_list|()
block|{
name|HasAlternativeForm
operator|=
literal|1
expr_stmt|;
block|}
name|void
name|setHasLeadingZeros
parameter_list|()
block|{
name|HasLeadingZeroes
operator|=
literal|1
expr_stmt|;
block|}
name|void
name|setUsesPositionalArg
parameter_list|()
block|{
name|UsesPositionalArg
operator|=
literal|1
expr_stmt|;
block|}
name|void
name|setArgIndex
parameter_list|(
name|unsigned
name|i
parameter_list|)
block|{
name|assert
argument_list|(
name|CS
operator|.
name|consumesDataArgument
argument_list|()
argument_list|)
expr_stmt|;
name|argIndex
operator|=
name|i
expr_stmt|;
block|}
name|unsigned
name|getArgIndex
argument_list|()
specifier|const
block|{
name|assert
argument_list|(
name|CS
operator|.
name|consumesDataArgument
argument_list|()
argument_list|)
block|;
return|return
name|argIndex
return|;
block|}
comment|// Methods for querying the format specifier.
specifier|const
name|ConversionSpecifier
operator|&
name|getConversionSpecifier
argument_list|()
specifier|const
block|{
return|return
name|CS
return|;
block|}
name|LengthModifier
name|getLengthModifier
argument_list|()
specifier|const
block|{
return|return
name|LM
return|;
block|}
specifier|const
name|OptionalAmount
operator|&
name|getFieldWidth
argument_list|()
specifier|const
block|{
return|return
name|FieldWidth
return|;
block|}
name|void
name|setFieldWidth
parameter_list|(
specifier|const
name|OptionalAmount
modifier|&
name|Amt
parameter_list|)
block|{
name|FieldWidth
operator|=
name|Amt
expr_stmt|;
block|}
name|void
name|setPrecision
parameter_list|(
specifier|const
name|OptionalAmount
modifier|&
name|Amt
parameter_list|)
block|{
name|Precision
operator|=
name|Amt
expr_stmt|;
block|}
specifier|const
name|OptionalAmount
operator|&
name|getPrecision
argument_list|()
specifier|const
block|{
return|return
name|Precision
return|;
block|}
comment|/// \brief Returns the builtin type that a data argument
comment|/// paired with this format specifier should have.  This method
comment|/// will return null if the format specifier does not have
comment|/// a matching data argument or the matching argument matches
comment|/// more than one type.
name|ArgTypeResult
name|getArgType
argument_list|(
name|ASTContext
operator|&
name|Ctx
argument_list|)
decl|const
decl_stmt|;
name|bool
name|isLeftJustified
argument_list|()
specifier|const
block|{
return|return
operator|(
name|bool
operator|)
name|IsLeftJustified
return|;
block|}
name|bool
name|hasPlusPrefix
argument_list|()
specifier|const
block|{
return|return
operator|(
name|bool
operator|)
name|HasPlusPrefix
return|;
block|}
name|bool
name|hasAlternativeForm
argument_list|()
specifier|const
block|{
return|return
operator|(
name|bool
operator|)
name|HasAlternativeForm
return|;
block|}
name|bool
name|hasLeadingZeros
argument_list|()
specifier|const
block|{
return|return
operator|(
name|bool
operator|)
name|HasLeadingZeroes
return|;
block|}
name|bool
name|hasSpacePrefix
argument_list|()
specifier|const
block|{
return|return
operator|(
name|bool
operator|)
name|HasSpacePrefix
return|;
block|}
name|bool
name|usesPositionalArg
argument_list|()
specifier|const
block|{
return|return
operator|(
name|bool
operator|)
name|UsesPositionalArg
return|;
block|}
block|}
empty_stmt|;
enum|enum
name|PositionContext
block|{
name|FieldWidthPos
init|=
literal|0
block|,
name|PrecisionPos
init|=
literal|1
block|}
enum|;
name|class
name|FormatStringHandler
block|{
name|public
label|:
name|FormatStringHandler
argument_list|()
block|{}
name|virtual
operator|~
name|FormatStringHandler
argument_list|()
expr_stmt|;
name|virtual
name|void
name|HandleIncompleteFormatSpecifier
parameter_list|(
specifier|const
name|char
modifier|*
name|startSpecifier
parameter_list|,
name|unsigned
name|specifierLen
parameter_list|)
block|{}
name|virtual
name|void
name|HandleNullChar
parameter_list|(
specifier|const
name|char
modifier|*
name|nullCharacter
parameter_list|)
block|{}
name|virtual
name|void
name|HandleInvalidPosition
parameter_list|(
specifier|const
name|char
modifier|*
name|startPos
parameter_list|,
name|unsigned
name|posLen
parameter_list|,
name|PositionContext
name|p
parameter_list|)
block|{}
name|virtual
name|void
name|HandleZeroPosition
parameter_list|(
specifier|const
name|char
modifier|*
name|startPos
parameter_list|,
name|unsigned
name|posLen
parameter_list|)
block|{}
name|virtual
name|bool
name|HandleInvalidConversionSpecifier
argument_list|(
specifier|const
name|analyze_printf
operator|::
name|FormatSpecifier
operator|&
name|FS
argument_list|,
specifier|const
name|char
operator|*
name|startSpecifier
argument_list|,
name|unsigned
name|specifierLen
argument_list|)
block|{
return|return
name|true
return|;
block|}
name|virtual
name|bool
name|HandleFormatSpecifier
argument_list|(
specifier|const
name|analyze_printf
operator|::
name|FormatSpecifier
operator|&
name|FS
argument_list|,
specifier|const
name|char
operator|*
name|startSpecifier
argument_list|,
name|unsigned
name|specifierLen
argument_list|)
block|{
return|return
name|true
return|;
block|}
block|}
empty_stmt|;
name|bool
name|ParseFormatString
parameter_list|(
name|FormatStringHandler
modifier|&
name|H
parameter_list|,
specifier|const
name|char
modifier|*
name|beg
parameter_list|,
specifier|const
name|char
modifier|*
name|end
parameter_list|)
function_decl|;
block|}
comment|// end printf namespace
block|}
end_decl_stmt

begin_comment
comment|// end clang namespace
end_comment

begin_endif
endif|#
directive|endif
end_endif

end_unit

