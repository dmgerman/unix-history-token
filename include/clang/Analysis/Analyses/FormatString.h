begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//= FormatString.h - Analysis of printf/fprintf format strings --*- C++ -*-===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file defines APIs for analyzing the format strings of printf, fscanf,
end_comment

begin_comment
comment|// and friends.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// The structure of format strings for fprintf are described in C99 7.19.6.1.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// The structure of format strings for fscanf are described in C99 7.19.6.2.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LLVM_CLANG_FORMAT_H
end_ifndef

begin_define
define|#
directive|define
name|LLVM_CLANG_FORMAT_H
end_define

begin_include
include|#
directive|include
file|"clang/AST/CanonicalType.h"
end_include

begin_decl_stmt
name|namespace
name|clang
block|{
comment|//===----------------------------------------------------------------------===//
comment|/// Common components of both fprintf and fscanf format strings.
name|namespace
name|analyze_format_string
block|{
comment|/// Class representing optional flags with location and representation
comment|/// information.
name|class
name|OptionalFlag
block|{
name|public
label|:
name|OptionalFlag
argument_list|(
specifier|const
name|char
operator|*
name|Representation
argument_list|)
operator|:
name|representation
argument_list|(
name|Representation
argument_list|)
operator|,
name|flag
argument_list|(
argument|false
argument_list|)
block|{}
name|bool
name|isSet
argument_list|()
block|{
return|return
name|flag
return|;
block|}
name|void
name|set
parameter_list|()
block|{
name|flag
operator|=
name|true
expr_stmt|;
block|}
name|void
name|clear
parameter_list|()
block|{
name|flag
operator|=
name|false
expr_stmt|;
block|}
name|void
name|setPosition
parameter_list|(
specifier|const
name|char
modifier|*
name|position
parameter_list|)
block|{
name|assert
argument_list|(
name|position
argument_list|)
expr_stmt|;
name|this
operator|->
name|position
operator|=
name|position
expr_stmt|;
block|}
specifier|const
name|char
operator|*
name|getPosition
argument_list|()
specifier|const
block|{
name|assert
argument_list|(
name|position
argument_list|)
block|;
return|return
name|position
return|;
block|}
specifier|const
name|char
operator|*
name|toString
argument_list|()
specifier|const
block|{
return|return
name|representation
return|;
block|}
comment|// Overloaded operators for bool like qualities
name|operator
name|bool
argument_list|()
specifier|const
block|{
return|return
name|flag
return|;
block|}
name|OptionalFlag
modifier|&
name|operator
init|=
operator|(
specifier|const
name|bool
operator|&
name|rhs
operator|)
block|{
name|flag
operator|=
name|rhs
block|;
return|return
operator|*
name|this
return|;
comment|// Return a reference to myself.
block|}
name|private
label|:
specifier|const
name|char
modifier|*
name|representation
decl_stmt|;
specifier|const
name|char
modifier|*
name|position
decl_stmt|;
name|bool
name|flag
decl_stmt|;
block|}
empty_stmt|;
comment|/// Represents the length modifier in a format string in scanf/printf.
name|class
name|LengthModifier
block|{
name|public
label|:
enum|enum
name|Kind
block|{
name|None
block|,
name|AsChar
block|,
comment|// 'hh'
name|AsShort
block|,
comment|// 'h'
name|AsLong
block|,
comment|// 'l'
name|AsLongLong
block|,
comment|// 'll'
name|AsQuad
block|,
comment|// 'q' (BSD, deprecated, for 64-bit integer types)
name|AsIntMax
block|,
comment|// 'j'
name|AsSizeT
block|,
comment|// 'z'
name|AsPtrDiff
block|,
comment|// 't'
name|AsLongDouble
block|,
comment|// 'L'
name|AsAllocate
block|,
comment|// for '%as', GNU extension to C90 scanf
name|AsMAllocate
block|,
comment|// for '%ms', GNU extension to scanf
name|AsWideChar
init|=
name|AsLong
comment|// for '%ls', only makes sense for printf
block|}
enum|;
name|LengthModifier
argument_list|()
operator|:
name|Position
argument_list|(
literal|0
argument_list|)
operator|,
name|kind
argument_list|(
argument|None
argument_list|)
block|{}
name|LengthModifier
argument_list|(
argument|const char *pos
argument_list|,
argument|Kind k
argument_list|)
operator|:
name|Position
argument_list|(
name|pos
argument_list|)
operator|,
name|kind
argument_list|(
argument|k
argument_list|)
block|{}
specifier|const
name|char
operator|*
name|getStart
argument_list|()
specifier|const
block|{
return|return
name|Position
return|;
block|}
name|unsigned
name|getLength
argument_list|()
specifier|const
block|{
switch|switch
condition|(
name|kind
condition|)
block|{
default|default:
return|return
literal|1
return|;
case|case
name|AsLongLong
case|:
case|case
name|AsChar
case|:
return|return
literal|2
return|;
case|case
name|None
case|:
return|return
literal|0
return|;
block|}
block|}
name|Kind
name|getKind
argument_list|()
specifier|const
block|{
return|return
name|kind
return|;
block|}
name|void
name|setKind
parameter_list|(
name|Kind
name|k
parameter_list|)
block|{
name|kind
operator|=
name|k
expr_stmt|;
block|}
specifier|const
name|char
operator|*
name|toString
argument_list|()
specifier|const
expr_stmt|;
name|private
label|:
specifier|const
name|char
modifier|*
name|Position
decl_stmt|;
name|Kind
name|kind
decl_stmt|;
block|}
empty_stmt|;
name|class
name|ConversionSpecifier
block|{
name|public
label|:
enum|enum
name|Kind
block|{
name|InvalidSpecifier
init|=
literal|0
block|,
comment|// C99 conversion specifiers.
name|cArg
block|,
name|dArg
block|,
name|iArg
block|,
name|IntArgBeg
init|=
name|cArg
block|,
name|IntArgEnd
init|=
name|iArg
block|,
name|oArg
block|,
name|uArg
block|,
name|xArg
block|,
name|XArg
block|,
name|UIntArgBeg
init|=
name|oArg
block|,
name|UIntArgEnd
init|=
name|XArg
block|,
name|fArg
block|,
name|FArg
block|,
name|eArg
block|,
name|EArg
block|,
name|gArg
block|,
name|GArg
block|,
name|aArg
block|,
name|AArg
block|,
name|DoubleArgBeg
init|=
name|fArg
block|,
name|DoubleArgEnd
init|=
name|AArg
block|,
name|sArg
block|,
name|pArg
block|,
name|nArg
block|,
name|PercentArg
block|,
name|CArg
block|,
name|SArg
block|,
comment|// ** Printf-specific **
comment|// Objective-C specific specifiers.
name|ObjCObjArg
block|,
comment|// '@'
name|ObjCBeg
init|=
name|ObjCObjArg
block|,
name|ObjCEnd
init|=
name|ObjCObjArg
block|,
comment|// GlibC specific specifiers.
name|PrintErrno
block|,
comment|// 'm'
name|PrintfConvBeg
init|=
name|ObjCObjArg
block|,
name|PrintfConvEnd
init|=
name|PrintErrno
block|,
comment|// ** Scanf-specific **
name|ScanListArg
block|,
comment|// '['
name|ScanfConvBeg
init|=
name|ScanListArg
block|,
name|ScanfConvEnd
init|=
name|ScanListArg
block|}
enum|;
name|ConversionSpecifier
argument_list|(
argument|bool isPrintf
argument_list|)
block|:
name|IsPrintf
argument_list|(
name|isPrintf
argument_list|)
operator|,
name|Position
argument_list|(
literal|0
argument_list|)
operator|,
name|EndScanList
argument_list|(
literal|0
argument_list|)
operator|,
name|kind
argument_list|(
argument|InvalidSpecifier
argument_list|)
block|{}
name|ConversionSpecifier
argument_list|(
argument|bool isPrintf
argument_list|,
argument|const char *pos
argument_list|,
argument|Kind k
argument_list|)
operator|:
name|IsPrintf
argument_list|(
name|isPrintf
argument_list|)
operator|,
name|Position
argument_list|(
name|pos
argument_list|)
operator|,
name|EndScanList
argument_list|(
literal|0
argument_list|)
operator|,
name|kind
argument_list|(
argument|k
argument_list|)
block|{}
specifier|const
name|char
operator|*
name|getStart
argument_list|()
specifier|const
block|{
return|return
name|Position
return|;
block|}
name|StringRef
name|getCharacters
argument_list|()
specifier|const
block|{
return|return
name|StringRef
argument_list|(
name|getStart
argument_list|()
argument_list|,
name|getLength
argument_list|()
argument_list|)
return|;
block|}
name|bool
name|consumesDataArgument
argument_list|()
specifier|const
block|{
switch|switch
condition|(
name|kind
condition|)
block|{
case|case
name|PrintErrno
case|:
name|assert
argument_list|(
name|IsPrintf
argument_list|)
expr_stmt|;
return|return
name|false
return|;
case|case
name|PercentArg
case|:
return|return
name|false
return|;
default|default:
return|return
name|true
return|;
block|}
block|}
name|Kind
name|getKind
argument_list|()
specifier|const
block|{
return|return
name|kind
return|;
block|}
name|void
name|setKind
parameter_list|(
name|Kind
name|k
parameter_list|)
block|{
name|kind
operator|=
name|k
expr_stmt|;
block|}
name|unsigned
name|getLength
argument_list|()
specifier|const
block|{
return|return
name|EndScanList
operator|?
name|EndScanList
operator|-
name|Position
operator|:
literal|1
return|;
block|}
name|bool
name|isUIntArg
argument_list|()
specifier|const
block|{
return|return
name|kind
operator|>=
name|UIntArgBeg
operator|&&
name|kind
operator|<=
name|UIntArgEnd
return|;
block|}
specifier|const
name|char
operator|*
name|toString
argument_list|()
specifier|const
expr_stmt|;
name|bool
name|isPrintfKind
argument_list|()
specifier|const
block|{
return|return
name|IsPrintf
return|;
block|}
name|protected
label|:
name|bool
name|IsPrintf
decl_stmt|;
specifier|const
name|char
modifier|*
name|Position
decl_stmt|;
specifier|const
name|char
modifier|*
name|EndScanList
decl_stmt|;
name|Kind
name|kind
decl_stmt|;
block|}
empty_stmt|;
name|class
name|ArgType
block|{
name|public
label|:
enum|enum
name|Kind
block|{
name|UnknownTy
block|,
name|InvalidTy
block|,
name|SpecificTy
block|,
name|ObjCPointerTy
block|,
name|CPointerTy
block|,
name|AnyCharTy
block|,
name|CStrTy
block|,
name|WCStrTy
block|,
name|WIntTy
block|}
enum|;
name|private
label|:
specifier|const
name|Kind
name|K
decl_stmt|;
name|QualType
name|T
decl_stmt|;
specifier|const
name|char
modifier|*
name|Name
decl_stmt|;
name|bool
name|Ptr
decl_stmt|;
name|public
label|:
name|ArgType
argument_list|(
argument|Kind k = UnknownTy
argument_list|,
argument|const char *n =
literal|0
argument_list|)
block|:
name|K
argument_list|(
name|k
argument_list|)
operator|,
name|Name
argument_list|(
name|n
argument_list|)
operator|,
name|Ptr
argument_list|(
argument|false
argument_list|)
block|{}
name|ArgType
argument_list|(
argument|QualType t
argument_list|,
argument|const char *n =
literal|0
argument_list|)
operator|:
name|K
argument_list|(
name|SpecificTy
argument_list|)
operator|,
name|T
argument_list|(
name|t
argument_list|)
operator|,
name|Name
argument_list|(
name|n
argument_list|)
operator|,
name|Ptr
argument_list|(
argument|false
argument_list|)
block|{}
name|ArgType
argument_list|(
argument|CanQualType t
argument_list|)
operator|:
name|K
argument_list|(
name|SpecificTy
argument_list|)
operator|,
name|T
argument_list|(
name|t
argument_list|)
operator|,
name|Name
argument_list|(
literal|0
argument_list|)
operator|,
name|Ptr
argument_list|(
argument|false
argument_list|)
block|{}
specifier|static
name|ArgType
name|Invalid
argument_list|()
block|{
return|return
name|ArgType
argument_list|(
name|InvalidTy
argument_list|)
return|;
block|}
name|bool
name|isValid
argument_list|()
specifier|const
block|{
return|return
name|K
operator|!=
name|InvalidTy
return|;
block|}
comment|/// Create an ArgType which corresponds to the type pointer to A.
specifier|static
name|ArgType
name|PtrTo
parameter_list|(
specifier|const
name|ArgType
modifier|&
name|A
parameter_list|)
block|{
name|assert
argument_list|(
name|A
operator|.
name|K
operator|>=
name|InvalidTy
operator|&&
literal|"ArgType cannot be pointer to invalid/unknown"
argument_list|)
expr_stmt|;
name|ArgType
name|Res
init|=
name|A
decl_stmt|;
name|Res
operator|.
name|Ptr
operator|=
name|true
expr_stmt|;
return|return
name|Res
return|;
block|}
name|bool
name|matchesType
argument_list|(
name|ASTContext
operator|&
name|C
argument_list|,
name|QualType
name|argTy
argument_list|)
decl|const
decl_stmt|;
name|QualType
name|getRepresentativeType
argument_list|(
name|ASTContext
operator|&
name|C
argument_list|)
decl|const
decl_stmt|;
name|std
operator|::
name|string
name|getRepresentativeTypeName
argument_list|(
argument|ASTContext&C
argument_list|)
specifier|const
expr_stmt|;
block|}
empty_stmt|;
name|class
name|OptionalAmount
block|{
name|public
label|:
enum|enum
name|HowSpecified
block|{
name|NotSpecified
block|,
name|Constant
block|,
name|Arg
block|,
name|Invalid
block|}
enum|;
name|OptionalAmount
argument_list|(
argument|HowSpecified howSpecified
argument_list|,
argument|unsigned amount
argument_list|,
argument|const char *amountStart
argument_list|,
argument|unsigned amountLength
argument_list|,
argument|bool usesPositionalArg
argument_list|)
block|:
name|start
argument_list|(
name|amountStart
argument_list|)
operator|,
name|length
argument_list|(
name|amountLength
argument_list|)
operator|,
name|hs
argument_list|(
name|howSpecified
argument_list|)
operator|,
name|amt
argument_list|(
name|amount
argument_list|)
operator|,
name|UsesPositionalArg
argument_list|(
name|usesPositionalArg
argument_list|)
operator|,
name|UsesDotPrefix
argument_list|(
literal|0
argument_list|)
block|{}
name|OptionalAmount
argument_list|(
argument|bool valid = true
argument_list|)
operator|:
name|start
argument_list|(
literal|0
argument_list|)
operator|,
name|length
argument_list|(
literal|0
argument_list|)
operator|,
name|hs
argument_list|(
name|valid
operator|?
name|NotSpecified
operator|:
name|Invalid
argument_list|)
operator|,
name|amt
argument_list|(
literal|0
argument_list|)
operator|,
name|UsesPositionalArg
argument_list|(
literal|0
argument_list|)
operator|,
name|UsesDotPrefix
argument_list|(
literal|0
argument_list|)
block|{}
name|bool
name|isInvalid
argument_list|()
specifier|const
block|{
return|return
name|hs
operator|==
name|Invalid
return|;
block|}
name|HowSpecified
name|getHowSpecified
argument_list|()
specifier|const
block|{
return|return
name|hs
return|;
block|}
name|void
name|setHowSpecified
parameter_list|(
name|HowSpecified
name|h
parameter_list|)
block|{
name|hs
operator|=
name|h
expr_stmt|;
block|}
name|bool
name|hasDataArgument
argument_list|()
specifier|const
block|{
return|return
name|hs
operator|==
name|Arg
return|;
block|}
name|unsigned
name|getArgIndex
argument_list|()
specifier|const
block|{
name|assert
argument_list|(
name|hasDataArgument
argument_list|()
argument_list|)
block|;
return|return
name|amt
return|;
block|}
name|unsigned
name|getConstantAmount
argument_list|()
specifier|const
block|{
name|assert
argument_list|(
name|hs
operator|==
name|Constant
argument_list|)
block|;
return|return
name|amt
return|;
block|}
specifier|const
name|char
operator|*
name|getStart
argument_list|()
specifier|const
block|{
comment|// We include the . character if it is given.
return|return
name|start
operator|-
name|UsesDotPrefix
return|;
block|}
name|unsigned
name|getConstantLength
argument_list|()
specifier|const
block|{
name|assert
argument_list|(
name|hs
operator|==
name|Constant
argument_list|)
block|;
return|return
name|length
operator|+
name|UsesDotPrefix
return|;
block|}
name|ArgType
name|getArgType
argument_list|(
name|ASTContext
operator|&
name|Ctx
argument_list|)
decl|const
decl_stmt|;
name|void
name|toString
argument_list|(
name|raw_ostream
operator|&
name|os
argument_list|)
decl|const
decl_stmt|;
name|bool
name|usesPositionalArg
argument_list|()
specifier|const
block|{
return|return
operator|(
name|bool
operator|)
name|UsesPositionalArg
return|;
block|}
name|unsigned
name|getPositionalArgIndex
argument_list|()
specifier|const
block|{
name|assert
argument_list|(
name|hasDataArgument
argument_list|()
argument_list|)
block|;
return|return
name|amt
operator|+
literal|1
return|;
block|}
name|bool
name|usesDotPrefix
argument_list|()
specifier|const
block|{
return|return
name|UsesDotPrefix
return|;
block|}
name|void
name|setUsesDotPrefix
parameter_list|()
block|{
name|UsesDotPrefix
operator|=
name|true
expr_stmt|;
block|}
name|private
label|:
specifier|const
name|char
modifier|*
name|start
decl_stmt|;
name|unsigned
name|length
decl_stmt|;
name|HowSpecified
name|hs
decl_stmt|;
name|unsigned
name|amt
decl_stmt|;
name|bool
name|UsesPositionalArg
range|:
literal|1
decl_stmt|;
name|bool
name|UsesDotPrefix
decl_stmt|;
block|}
empty_stmt|;
name|class
name|FormatSpecifier
block|{
name|protected
label|:
name|LengthModifier
name|LM
decl_stmt|;
name|OptionalAmount
name|FieldWidth
decl_stmt|;
name|ConversionSpecifier
name|CS
decl_stmt|;
comment|/// Positional arguments, an IEEE extension:
comment|///  IEEE Std 1003.1, 2004 Edition
comment|///  http://www.opengroup.org/onlinepubs/009695399/functions/printf.html
name|bool
name|UsesPositionalArg
decl_stmt|;
name|unsigned
name|argIndex
decl_stmt|;
name|public
label|:
name|FormatSpecifier
argument_list|(
argument|bool isPrintf
argument_list|)
block|:
name|CS
argument_list|(
name|isPrintf
argument_list|)
operator|,
name|UsesPositionalArg
argument_list|(
name|false
argument_list|)
operator|,
name|argIndex
argument_list|(
literal|0
argument_list|)
block|{}
name|void
name|setLengthModifier
argument_list|(
argument|LengthModifier lm
argument_list|)
block|{
name|LM
operator|=
name|lm
block|;   }
name|void
name|setUsesPositionalArg
argument_list|()
block|{
name|UsesPositionalArg
operator|=
name|true
block|; }
name|void
name|setArgIndex
argument_list|(
argument|unsigned i
argument_list|)
block|{
name|argIndex
operator|=
name|i
block|;   }
name|unsigned
name|getArgIndex
argument_list|()
specifier|const
block|{
return|return
name|argIndex
return|;
block|}
name|unsigned
name|getPositionalArgIndex
argument_list|()
specifier|const
block|{
return|return
name|argIndex
operator|+
literal|1
return|;
block|}
specifier|const
name|LengthModifier
operator|&
name|getLengthModifier
argument_list|()
specifier|const
block|{
return|return
name|LM
return|;
block|}
specifier|const
name|OptionalAmount
operator|&
name|getFieldWidth
argument_list|()
specifier|const
block|{
return|return
name|FieldWidth
return|;
block|}
name|void
name|setFieldWidth
parameter_list|(
specifier|const
name|OptionalAmount
modifier|&
name|Amt
parameter_list|)
block|{
name|FieldWidth
operator|=
name|Amt
expr_stmt|;
block|}
name|bool
name|usesPositionalArg
argument_list|()
specifier|const
block|{
return|return
name|UsesPositionalArg
return|;
block|}
name|bool
name|hasValidLengthModifier
argument_list|()
specifier|const
expr_stmt|;
name|bool
name|hasStandardLengthModifier
argument_list|()
specifier|const
expr_stmt|;
name|bool
name|hasStandardConversionSpecifier
argument_list|(
specifier|const
name|LangOptions
operator|&
name|LangOpt
argument_list|)
decl|const
decl_stmt|;
name|bool
name|hasStandardLengthConversionCombination
argument_list|()
specifier|const
expr_stmt|;
comment|/// For a TypedefType QT, if it is a named integer type such as size_t,
comment|/// assign the appropriate value to LM and return true.
specifier|static
name|bool
name|namedTypeToLengthModifier
parameter_list|(
name|QualType
name|QT
parameter_list|,
name|LengthModifier
modifier|&
name|LM
parameter_list|)
function_decl|;
block|}
empty_stmt|;
block|}
comment|// end analyze_format_string namespace
comment|//===----------------------------------------------------------------------===//
comment|/// Pieces specific to fprintf format strings.
name|namespace
name|analyze_printf
block|{
name|class
name|PrintfConversionSpecifier
range|:
name|public
name|analyze_format_string
operator|::
name|ConversionSpecifier
block|{
name|public
operator|:
name|PrintfConversionSpecifier
argument_list|()
operator|:
name|ConversionSpecifier
argument_list|(
argument|true
argument_list|,
literal|0
argument_list|,
argument|InvalidSpecifier
argument_list|)
block|{}
name|PrintfConversionSpecifier
argument_list|(
argument|const char *pos
argument_list|,
argument|Kind k
argument_list|)
operator|:
name|ConversionSpecifier
argument_list|(
argument|true
argument_list|,
argument|pos
argument_list|,
argument|k
argument_list|)
block|{}
name|bool
name|isObjCArg
argument_list|()
specifier|const
block|{
return|return
name|kind
operator|>=
name|ObjCBeg
operator|&&
name|kind
operator|<=
name|ObjCEnd
return|;
block|}
name|bool
name|isIntArg
argument_list|()
specifier|const
block|{
return|return
name|kind
operator|>=
name|IntArgBeg
operator|&&
name|kind
operator|<=
name|IntArgEnd
return|;
block|}
name|bool
name|isDoubleArg
argument_list|()
specifier|const
block|{
return|return
name|kind
operator|>=
name|DoubleArgBeg
operator|&&
name|kind
operator|<=
name|DoubleArgEnd
return|;
block|}
name|unsigned
name|getLength
argument_list|()
specifier|const
block|{
comment|// Conversion specifiers currently only are represented by
comment|// single characters, but we be flexible.
return|return
literal|1
return|;
block|}
specifier|static
name|bool
name|classof
argument_list|(
argument|const analyze_format_string::ConversionSpecifier *CS
argument_list|)
block|{
return|return
name|CS
operator|->
name|isPrintfKind
argument_list|()
return|;
block|}
expr|}
block|;
name|using
name|analyze_format_string
operator|::
name|ArgType
block|;
name|using
name|analyze_format_string
operator|::
name|LengthModifier
block|;
name|using
name|analyze_format_string
operator|::
name|OptionalAmount
block|;
name|using
name|analyze_format_string
operator|::
name|OptionalFlag
block|;
name|class
name|PrintfSpecifier
operator|:
name|public
name|analyze_format_string
operator|::
name|FormatSpecifier
block|{
name|OptionalFlag
name|HasThousandsGrouping
block|;
comment|// ''', POSIX extension.
name|OptionalFlag
name|IsLeftJustified
block|;
comment|// '-'
name|OptionalFlag
name|HasPlusPrefix
block|;
comment|// '+'
name|OptionalFlag
name|HasSpacePrefix
block|;
comment|// ' '
name|OptionalFlag
name|HasAlternativeForm
block|;
comment|// '#'
name|OptionalFlag
name|HasLeadingZeroes
block|;
comment|// '0'
name|OptionalAmount
name|Precision
block|;
name|public
operator|:
name|PrintfSpecifier
argument_list|()
operator|:
name|FormatSpecifier
argument_list|(
comment|/* isPrintf = */
name|true
argument_list|)
block|,
name|HasThousandsGrouping
argument_list|(
literal|"'"
argument_list|)
block|,
name|IsLeftJustified
argument_list|(
literal|"-"
argument_list|)
block|,
name|HasPlusPrefix
argument_list|(
literal|"+"
argument_list|)
block|,
name|HasSpacePrefix
argument_list|(
literal|" "
argument_list|)
block|,
name|HasAlternativeForm
argument_list|(
literal|"#"
argument_list|)
block|,
name|HasLeadingZeroes
argument_list|(
literal|"0"
argument_list|)
block|{}
specifier|static
name|PrintfSpecifier
name|Parse
argument_list|(
specifier|const
name|char
operator|*
name|beg
argument_list|,
specifier|const
name|char
operator|*
name|end
argument_list|)
block|;
comment|// Methods for incrementally constructing the PrintfSpecifier.
name|void
name|setConversionSpecifier
argument_list|(
argument|const PrintfConversionSpecifier&cs
argument_list|)
block|{
name|CS
operator|=
name|cs
block|;   }
name|void
name|setHasThousandsGrouping
argument_list|(
argument|const char *position
argument_list|)
block|{
name|HasThousandsGrouping
operator|=
name|true
block|;
name|HasThousandsGrouping
operator|.
name|setPosition
argument_list|(
name|position
argument_list|)
block|;   }
name|void
name|setIsLeftJustified
argument_list|(
argument|const char *position
argument_list|)
block|{
name|IsLeftJustified
operator|=
name|true
block|;
name|IsLeftJustified
operator|.
name|setPosition
argument_list|(
name|position
argument_list|)
block|;   }
name|void
name|setHasPlusPrefix
argument_list|(
argument|const char *position
argument_list|)
block|{
name|HasPlusPrefix
operator|=
name|true
block|;
name|HasPlusPrefix
operator|.
name|setPosition
argument_list|(
name|position
argument_list|)
block|;   }
name|void
name|setHasSpacePrefix
argument_list|(
argument|const char *position
argument_list|)
block|{
name|HasSpacePrefix
operator|=
name|true
block|;
name|HasSpacePrefix
operator|.
name|setPosition
argument_list|(
name|position
argument_list|)
block|;   }
name|void
name|setHasAlternativeForm
argument_list|(
argument|const char *position
argument_list|)
block|{
name|HasAlternativeForm
operator|=
name|true
block|;
name|HasAlternativeForm
operator|.
name|setPosition
argument_list|(
name|position
argument_list|)
block|;   }
name|void
name|setHasLeadingZeros
argument_list|(
argument|const char *position
argument_list|)
block|{
name|HasLeadingZeroes
operator|=
name|true
block|;
name|HasLeadingZeroes
operator|.
name|setPosition
argument_list|(
name|position
argument_list|)
block|;   }
name|void
name|setUsesPositionalArg
argument_list|()
block|{
name|UsesPositionalArg
operator|=
name|true
block|; }
comment|// Methods for querying the format specifier.
specifier|const
name|PrintfConversionSpecifier
operator|&
name|getConversionSpecifier
argument_list|()
specifier|const
block|{
return|return
name|cast
operator|<
name|PrintfConversionSpecifier
operator|>
operator|(
name|CS
operator|)
return|;
block|}
name|void
name|setPrecision
argument_list|(
argument|const OptionalAmount&Amt
argument_list|)
block|{
name|Precision
operator|=
name|Amt
block|;
name|Precision
operator|.
name|setUsesDotPrefix
argument_list|()
block|;   }
specifier|const
name|OptionalAmount
operator|&
name|getPrecision
argument_list|()
specifier|const
block|{
return|return
name|Precision
return|;
block|}
name|bool
name|consumesDataArgument
argument_list|()
specifier|const
block|{
return|return
name|getConversionSpecifier
argument_list|()
operator|.
name|consumesDataArgument
argument_list|()
return|;
block|}
comment|/// \brief Returns the builtin type that a data argument
comment|/// paired with this format specifier should have.  This method
comment|/// will return null if the format specifier does not have
comment|/// a matching data argument or the matching argument matches
comment|/// more than one type.
name|ArgType
name|getArgType
argument_list|(
argument|ASTContext&Ctx
argument_list|,
argument|bool IsObjCLiteral
argument_list|)
specifier|const
block|;
specifier|const
name|OptionalFlag
operator|&
name|hasThousandsGrouping
argument_list|()
specifier|const
block|{
return|return
name|HasThousandsGrouping
return|;
block|}
specifier|const
name|OptionalFlag
operator|&
name|isLeftJustified
argument_list|()
specifier|const
block|{
return|return
name|IsLeftJustified
return|;
block|}
specifier|const
name|OptionalFlag
operator|&
name|hasPlusPrefix
argument_list|()
specifier|const
block|{
return|return
name|HasPlusPrefix
return|;
block|}
specifier|const
name|OptionalFlag
operator|&
name|hasAlternativeForm
argument_list|()
specifier|const
block|{
return|return
name|HasAlternativeForm
return|;
block|}
specifier|const
name|OptionalFlag
operator|&
name|hasLeadingZeros
argument_list|()
specifier|const
block|{
return|return
name|HasLeadingZeroes
return|;
block|}
specifier|const
name|OptionalFlag
operator|&
name|hasSpacePrefix
argument_list|()
specifier|const
block|{
return|return
name|HasSpacePrefix
return|;
block|}
name|bool
name|usesPositionalArg
argument_list|()
specifier|const
block|{
return|return
name|UsesPositionalArg
return|;
block|}
comment|/// Changes the specifier and length according to a QualType, retaining any
comment|/// flags or options. Returns true on success, or false when a conversion
comment|/// was not successful.
name|bool
name|fixType
argument_list|(
argument|QualType QT
argument_list|,
argument|const LangOptions&LangOpt
argument_list|,
argument|ASTContext&Ctx
argument_list|,
argument|bool IsObjCLiteral
argument_list|)
block|;
name|void
name|toString
argument_list|(
argument|raw_ostream&os
argument_list|)
specifier|const
block|;
comment|// Validation methods - to check if any element results in undefined behavior
name|bool
name|hasValidPlusPrefix
argument_list|()
specifier|const
block|;
name|bool
name|hasValidAlternativeForm
argument_list|()
specifier|const
block|;
name|bool
name|hasValidLeadingZeros
argument_list|()
specifier|const
block|;
name|bool
name|hasValidSpacePrefix
argument_list|()
specifier|const
block|;
name|bool
name|hasValidLeftJustified
argument_list|()
specifier|const
block|;
name|bool
name|hasValidThousandsGroupingPrefix
argument_list|()
specifier|const
block|;
name|bool
name|hasValidPrecision
argument_list|()
specifier|const
block|;
name|bool
name|hasValidFieldWidth
argument_list|()
specifier|const
block|; }
block|; }
comment|// end analyze_printf namespace
comment|//===----------------------------------------------------------------------===//
comment|/// Pieces specific to fscanf format strings.
name|namespace
name|analyze_scanf
block|{
name|class
name|ScanfConversionSpecifier
operator|:
name|public
name|analyze_format_string
operator|::
name|ConversionSpecifier
block|{
name|public
operator|:
name|ScanfConversionSpecifier
argument_list|()
operator|:
name|ConversionSpecifier
argument_list|(
argument|false
argument_list|,
literal|0
argument_list|,
argument|InvalidSpecifier
argument_list|)
block|{}
name|ScanfConversionSpecifier
argument_list|(
argument|const char *pos
argument_list|,
argument|Kind k
argument_list|)
operator|:
name|ConversionSpecifier
argument_list|(
argument|false
argument_list|,
argument|pos
argument_list|,
argument|k
argument_list|)
block|{}
name|void
name|setEndScanList
argument_list|(
argument|const char *pos
argument_list|)
block|{
name|EndScanList
operator|=
name|pos
block|; }
specifier|static
name|bool
name|classof
argument_list|(
argument|const analyze_format_string::ConversionSpecifier *CS
argument_list|)
block|{
return|return
operator|!
name|CS
operator|->
name|isPrintfKind
argument_list|()
return|;
block|}
expr|}
block|;
name|using
name|analyze_format_string
operator|::
name|ArgType
block|;
name|using
name|analyze_format_string
operator|::
name|LengthModifier
block|;
name|using
name|analyze_format_string
operator|::
name|OptionalAmount
block|;
name|using
name|analyze_format_string
operator|::
name|OptionalFlag
block|;
name|class
name|ScanfSpecifier
operator|:
name|public
name|analyze_format_string
operator|::
name|FormatSpecifier
block|{
name|OptionalFlag
name|SuppressAssignment
block|;
comment|// '*'
name|public
operator|:
name|ScanfSpecifier
argument_list|()
operator|:
name|FormatSpecifier
argument_list|(
comment|/* isPrintf = */
name|false
argument_list|)
block|,
name|SuppressAssignment
argument_list|(
literal|"*"
argument_list|)
block|{}
name|void
name|setSuppressAssignment
argument_list|(
argument|const char *position
argument_list|)
block|{
name|SuppressAssignment
operator|=
name|true
block|;
name|SuppressAssignment
operator|.
name|setPosition
argument_list|(
name|position
argument_list|)
block|;   }
specifier|const
name|OptionalFlag
operator|&
name|getSuppressAssignment
argument_list|()
specifier|const
block|{
return|return
name|SuppressAssignment
return|;
block|}
name|void
name|setConversionSpecifier
argument_list|(
argument|const ScanfConversionSpecifier&cs
argument_list|)
block|{
name|CS
operator|=
name|cs
block|;   }
specifier|const
name|ScanfConversionSpecifier
operator|&
name|getConversionSpecifier
argument_list|()
specifier|const
block|{
return|return
name|cast
operator|<
name|ScanfConversionSpecifier
operator|>
operator|(
name|CS
operator|)
return|;
block|}
name|bool
name|consumesDataArgument
argument_list|()
specifier|const
block|{
return|return
name|CS
operator|.
name|consumesDataArgument
argument_list|()
operator|&&
operator|!
name|SuppressAssignment
return|;
block|}
name|ArgType
name|getArgType
argument_list|(
argument|ASTContext&Ctx
argument_list|)
specifier|const
block|;
name|bool
name|fixType
argument_list|(
argument|QualType QT
argument_list|,
argument|const LangOptions&LangOpt
argument_list|,
argument|ASTContext&Ctx
argument_list|)
block|;
name|void
name|toString
argument_list|(
argument|raw_ostream&os
argument_list|)
specifier|const
block|;
specifier|static
name|ScanfSpecifier
name|Parse
argument_list|(
specifier|const
name|char
operator|*
name|beg
argument_list|,
specifier|const
name|char
operator|*
name|end
argument_list|)
block|; }
block|;  }
comment|// end analyze_scanf namespace
comment|//===----------------------------------------------------------------------===//
comment|// Parsing and processing of format strings (both fprintf and fscanf).
name|namespace
name|analyze_format_string
block|{  enum
name|PositionContext
block|{
name|FieldWidthPos
operator|=
literal|0
block|,
name|PrecisionPos
operator|=
literal|1
block|}
block|;
name|class
name|FormatStringHandler
block|{
name|public
operator|:
name|FormatStringHandler
argument_list|()
block|{}
name|virtual
operator|~
name|FormatStringHandler
argument_list|()
block|;
name|virtual
name|void
name|HandleNullChar
argument_list|(
argument|const char *nullCharacter
argument_list|)
block|{}
name|virtual
name|void
name|HandlePosition
argument_list|(
argument|const char *startPos
argument_list|,
argument|unsigned posLen
argument_list|)
block|{}
name|virtual
name|void
name|HandleInvalidPosition
argument_list|(
argument|const char *startPos
argument_list|,
argument|unsigned posLen
argument_list|,
argument|PositionContext p
argument_list|)
block|{}
name|virtual
name|void
name|HandleZeroPosition
argument_list|(
argument|const char *startPos
argument_list|,
argument|unsigned posLen
argument_list|)
block|{}
name|virtual
name|void
name|HandleIncompleteSpecifier
argument_list|(
argument|const char *startSpecifier
argument_list|,
argument|unsigned specifierLen
argument_list|)
block|{}
comment|// Printf-specific handlers.
name|virtual
name|bool
name|HandleInvalidPrintfConversionSpecifier
argument_list|(
argument|const analyze_printf::PrintfSpecifier&FS
argument_list|,
argument|const char *startSpecifier
argument_list|,
argument|unsigned specifierLen
argument_list|)
block|{
return|return
name|true
return|;
block|}
name|virtual
name|bool
name|HandlePrintfSpecifier
argument_list|(
argument|const analyze_printf::PrintfSpecifier&FS
argument_list|,
argument|const char *startSpecifier
argument_list|,
argument|unsigned specifierLen
argument_list|)
block|{
return|return
name|true
return|;
block|}
comment|// Scanf-specific handlers.
name|virtual
name|bool
name|HandleInvalidScanfConversionSpecifier
argument_list|(
argument|const analyze_scanf::ScanfSpecifier&FS
argument_list|,
argument|const char *startSpecifier
argument_list|,
argument|unsigned specifierLen
argument_list|)
block|{
return|return
name|true
return|;
block|}
name|virtual
name|bool
name|HandleScanfSpecifier
argument_list|(
argument|const analyze_scanf::ScanfSpecifier&FS
argument_list|,
argument|const char *startSpecifier
argument_list|,
argument|unsigned specifierLen
argument_list|)
block|{
return|return
name|true
return|;
block|}
name|virtual
name|void
name|HandleIncompleteScanList
argument_list|(
argument|const char *start
argument_list|,
argument|const char *end
argument_list|)
block|{}
expr|}
block|;
name|bool
name|ParsePrintfString
argument_list|(
name|FormatStringHandler
operator|&
name|H
argument_list|,
specifier|const
name|char
operator|*
name|beg
argument_list|,
specifier|const
name|char
operator|*
name|end
argument_list|,
specifier|const
name|LangOptions
operator|&
name|LO
argument_list|)
block|;
name|bool
name|ParseScanfString
argument_list|(
name|FormatStringHandler
operator|&
name|H
argument_list|,
specifier|const
name|char
operator|*
name|beg
argument_list|,
specifier|const
name|char
operator|*
name|end
argument_list|,
specifier|const
name|LangOptions
operator|&
name|LO
argument_list|)
block|;  }
comment|// end analyze_format_string namespace
block|}
end_decl_stmt

begin_comment
comment|// end clang namespace
end_comment

begin_endif
endif|#
directive|endif
end_endif

end_unit

