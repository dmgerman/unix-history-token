begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//== MemRegion.h - Abstract memory regions for static analysis --*- C++ -*--==//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//  This file defines MemRegion and its subclasses.  MemRegion defines a
end_comment

begin_comment
comment|//  partially-typed abstraction of memory useful for path-sensitive dataflow
end_comment

begin_comment
comment|//  analyses.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LLVM_CLANG_ANALYSIS_MEMREGION_H
end_ifndef

begin_define
define|#
directive|define
name|LLVM_CLANG_ANALYSIS_MEMREGION_H
end_define

begin_include
include|#
directive|include
file|"clang/AST/Decl.h"
end_include

begin_include
include|#
directive|include
file|"clang/AST/DeclObjC.h"
end_include

begin_include
include|#
directive|include
file|"clang/Analysis/PathSensitive/SymbolManager.h"
end_include

begin_include
include|#
directive|include
file|"clang/Analysis/PathSensitive/SVals.h"
end_include

begin_include
include|#
directive|include
file|"clang/AST/ASTContext.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/Casting.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/FoldingSet.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/ImmutableList.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/ImmutableMap.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/Allocator.h"
end_include

begin_include
include|#
directive|include
file|<string>
end_include

begin_decl_stmt
name|namespace
name|llvm
block|{
name|class
name|raw_ostream
decl_stmt|;
block|}
end_decl_stmt

begin_decl_stmt
name|namespace
name|clang
block|{
name|class
name|MemRegionManager
decl_stmt|;
comment|/// MemRegion - The root abstract class for all memory regions.
name|class
name|MemRegion
range|:
name|public
name|llvm
operator|::
name|FoldingSetNode
block|{
name|public
operator|:
expr|enum
name|Kind
block|{
name|MemSpaceRegionKind
block|,
name|SymbolicRegionKind
block|,
name|AllocaRegionKind
block|,
comment|// Typed regions.
name|BEG_TYPED_REGIONS
block|,
name|CodeTextRegionKind
block|,
name|CompoundLiteralRegionKind
block|,
name|StringRegionKind
block|,
name|ElementRegionKind
block|,
name|TypedViewRegionKind
block|,
comment|// Decl Regions.
name|BEG_DECL_REGIONS
block|,
name|VarRegionKind
block|,
name|FieldRegionKind
block|,
name|ObjCIvarRegionKind
block|,
name|ObjCObjectRegionKind
block|,
name|END_DECL_REGIONS
block|,
name|END_TYPED_REGIONS
block|}
block|;
name|private
operator|:
specifier|const
name|Kind
name|kind
block|;
name|protected
operator|:
name|MemRegion
argument_list|(
argument|Kind k
argument_list|)
operator|:
name|kind
argument_list|(
argument|k
argument_list|)
block|{}
name|virtual
operator|~
name|MemRegion
argument_list|()
block|;
name|public
operator|:
comment|// virtual MemExtent getExtent(MemRegionManager& mrm) const = 0;
name|virtual
name|void
name|Profile
argument_list|(
argument|llvm::FoldingSetNodeID& ID
argument_list|)
specifier|const
operator|=
literal|0
block|;
name|std
operator|::
name|string
name|getString
argument_list|()
specifier|const
block|;
name|virtual
name|void
name|print
argument_list|(
argument|llvm::raw_ostream& os
argument_list|)
specifier|const
block|;
name|Kind
name|getKind
argument_list|()
specifier|const
block|{
return|return
name|kind
return|;
block|}
name|template
operator|<
name|typename
name|RegionTy
operator|>
specifier|const
name|RegionTy
operator|*
name|getAs
argument_list|()
specifier|const
block|;
name|virtual
name|bool
name|isBoundable
argument_list|(
argument|ASTContext&
argument_list|)
specifier|const
block|{
return|return
name|true
return|;
block|}
specifier|static
name|bool
name|classof
argument_list|(
argument|const MemRegion*
argument_list|)
block|{
return|return
name|true
return|;
block|}
expr|}
block|;
comment|/// MemSpaceRegion - A memory region that represents and "memory space";
comment|///  for example, the set of global variables, the stack frame, etc.
name|class
name|MemSpaceRegion
operator|:
name|public
name|MemRegion
block|{
name|friend
name|class
name|MemRegionManager
block|;
name|MemSpaceRegion
argument_list|()
operator|:
name|MemRegion
argument_list|(
argument|MemSpaceRegionKind
argument_list|)
block|{}
name|public
operator|:
comment|//RegionExtent getExtent() const { return UndefinedExtent(); }
name|void
name|Profile
argument_list|(
argument|llvm::FoldingSetNodeID& ID
argument_list|)
specifier|const
block|;
name|bool
name|isBoundable
argument_list|(
argument|ASTContext&
argument_list|)
specifier|const
block|{
return|return
name|false
return|;
block|}
specifier|static
name|bool
name|classof
argument_list|(
argument|const MemRegion* R
argument_list|)
block|{
return|return
name|R
operator|->
name|getKind
argument_list|()
operator|==
name|MemSpaceRegionKind
return|;
block|}
expr|}
block|;
comment|/// SubRegion - A region that subsets another larger region.  Most regions
comment|///  are subclasses of SubRegion.
name|class
name|SubRegion
operator|:
name|public
name|MemRegion
block|{
name|protected
operator|:
specifier|const
name|MemRegion
operator|*
name|superRegion
block|;
name|SubRegion
argument_list|(
argument|const MemRegion* sReg
argument_list|,
argument|Kind k
argument_list|)
operator|:
name|MemRegion
argument_list|(
name|k
argument_list|)
block|,
name|superRegion
argument_list|(
argument|sReg
argument_list|)
block|{}
name|public
operator|:
specifier|const
name|MemRegion
operator|*
name|getSuperRegion
argument_list|()
specifier|const
block|{
return|return
name|superRegion
return|;
block|}
name|bool
name|isSubRegionOf
argument_list|(
argument|const MemRegion* R
argument_list|)
specifier|const
block|;
specifier|static
name|bool
name|classof
argument_list|(
argument|const MemRegion* R
argument_list|)
block|{
return|return
name|R
operator|->
name|getKind
argument_list|()
operator|>
name|MemSpaceRegionKind
return|;
block|}
expr|}
block|;
comment|/// AllocaRegion - A region that represents an untyped blob of bytes created
comment|///  by a call to 'alloca'.
name|class
name|AllocaRegion
operator|:
name|public
name|SubRegion
block|{
name|friend
name|class
name|MemRegionManager
block|;
name|protected
operator|:
name|unsigned
name|Cnt
block|;
comment|// Block counter.  Used to distinguish different pieces of
comment|// memory allocated by alloca at the same call site.
specifier|const
name|Expr
operator|*
name|Ex
block|;
name|AllocaRegion
argument_list|(
argument|const Expr* ex
argument_list|,
argument|unsigned cnt
argument_list|,
argument|const MemRegion* superRegion
argument_list|)
operator|:
name|SubRegion
argument_list|(
name|superRegion
argument_list|,
name|AllocaRegionKind
argument_list|)
block|,
name|Cnt
argument_list|(
name|cnt
argument_list|)
block|,
name|Ex
argument_list|(
argument|ex
argument_list|)
block|{}
name|public
operator|:
specifier|const
name|Expr
operator|*
name|getExpr
argument_list|()
specifier|const
block|{
return|return
name|Ex
return|;
block|}
name|void
name|Profile
argument_list|(
argument|llvm::FoldingSetNodeID& ID
argument_list|)
specifier|const
block|;
specifier|static
name|void
name|ProfileRegion
argument_list|(
argument|llvm::FoldingSetNodeID& ID
argument_list|,
argument|const Expr* Ex
argument_list|,
argument|unsigned Cnt
argument_list|)
block|;
name|void
name|print
argument_list|(
argument|llvm::raw_ostream& os
argument_list|)
specifier|const
block|;
specifier|static
name|bool
name|classof
argument_list|(
argument|const MemRegion* R
argument_list|)
block|{
return|return
name|R
operator|->
name|getKind
argument_list|()
operator|==
name|AllocaRegionKind
return|;
block|}
expr|}
block|;
comment|/// TypedRegion - An abstract class representing regions that are typed.
name|class
name|TypedRegion
operator|:
name|public
name|SubRegion
block|{
name|protected
operator|:
name|TypedRegion
argument_list|(
argument|const MemRegion* sReg
argument_list|,
argument|Kind k
argument_list|)
operator|:
name|SubRegion
argument_list|(
argument|sReg
argument_list|,
argument|k
argument_list|)
block|{}
name|public
operator|:
name|virtual
name|QualType
name|getValueType
argument_list|(
argument|ASTContext&C
argument_list|)
specifier|const
operator|=
literal|0
block|;
name|virtual
name|QualType
name|getLocationType
argument_list|(
argument|ASTContext& C
argument_list|)
specifier|const
block|{
comment|// FIXME: We can possibly optimize this later to cache this value.
return|return
name|C
operator|.
name|getPointerType
argument_list|(
name|getValueType
argument_list|(
name|C
argument_list|)
argument_list|)
return|;
block|}
name|QualType
name|getDesugaredValueType
argument_list|(
argument|ASTContext& C
argument_list|)
specifier|const
block|{
name|QualType
name|T
operator|=
name|getValueType
argument_list|(
name|C
argument_list|)
block|;
return|return
name|T
operator|.
name|getTypePtr
argument_list|()
condition|?
name|T
operator|->
name|getDesugaredType
argument_list|()
else|:
name|T
return|;
block|}
name|QualType
name|getDesugaredLocationType
argument_list|(
argument|ASTContext& C
argument_list|)
specifier|const
block|{
return|return
name|getLocationType
argument_list|(
name|C
argument_list|)
operator|->
name|getDesugaredType
argument_list|()
return|;
block|}
name|bool
name|isBoundable
argument_list|(
argument|ASTContext&C
argument_list|)
specifier|const
block|{
return|return
operator|!
name|getValueType
argument_list|(
name|C
argument_list|)
operator|.
name|isNull
argument_list|()
return|;
block|}
specifier|static
name|bool
name|classof
argument_list|(
argument|const MemRegion* R
argument_list|)
block|{
name|unsigned
name|k
operator|=
name|R
operator|->
name|getKind
argument_list|()
block|;
return|return
name|k
operator|>
name|BEG_TYPED_REGIONS
operator|&&
name|k
operator|<
name|END_TYPED_REGIONS
return|;
block|}
expr|}
block|;
comment|/// CodeTextRegion - A region that represents code texts of a function. It wraps
comment|/// two kinds of code texts: real function and symbolic function. Real function
comment|/// is a function declared in the program. Symbolic function is a function
comment|/// pointer that we don't know which function it points to.
name|class
name|CodeTextRegion
operator|:
name|public
name|TypedRegion
block|{
name|public
operator|:
expr|enum
name|CodeKind
block|{
name|Declared
block|,
name|Symbolic
block|}
block|;
name|private
operator|:
comment|// The function pointer kind that this CodeTextRegion represents.
name|CodeKind
name|codekind
block|;
comment|// Data may be a SymbolRef or FunctionDecl*.
specifier|const
name|void
operator|*
name|Data
block|;
comment|// Cached function pointer type.
name|QualType
name|LocationType
block|;
name|public
operator|:
name|CodeTextRegion
argument_list|(
argument|const FunctionDecl* fd
argument_list|,
argument|QualType t
argument_list|,
argument|const MemRegion* sreg
argument_list|)
operator|:
name|TypedRegion
argument_list|(
name|sreg
argument_list|,
name|CodeTextRegionKind
argument_list|)
block|,
name|codekind
argument_list|(
name|Declared
argument_list|)
block|,
name|Data
argument_list|(
name|fd
argument_list|)
block|,
name|LocationType
argument_list|(
argument|t
argument_list|)
block|{}
name|CodeTextRegion
argument_list|(
argument|SymbolRef sym
argument_list|,
argument|QualType t
argument_list|,
argument|const MemRegion* sreg
argument_list|)
operator|:
name|TypedRegion
argument_list|(
name|sreg
argument_list|,
name|CodeTextRegionKind
argument_list|)
block|,
name|codekind
argument_list|(
name|Symbolic
argument_list|)
block|,
name|Data
argument_list|(
name|sym
argument_list|)
block|,
name|LocationType
argument_list|(
argument|t
argument_list|)
block|{}
name|QualType
name|getValueType
argument_list|(
argument|ASTContext&C
argument_list|)
specifier|const
block|{
comment|// Do not get the object type of a CodeTextRegion.
name|assert
argument_list|(
literal|0
argument_list|)
block|;
return|return
name|QualType
argument_list|()
return|;
block|}
name|QualType
name|getLocationType
argument_list|(
argument|ASTContext&C
argument_list|)
specifier|const
block|{
return|return
name|LocationType
return|;
block|}
name|bool
name|isDeclared
argument_list|()
specifier|const
block|{
return|return
name|codekind
operator|==
name|Declared
return|;
block|}
name|bool
name|isSymbolic
argument_list|()
specifier|const
block|{
return|return
name|codekind
operator|==
name|Symbolic
return|;
block|}
specifier|const
name|FunctionDecl
operator|*
name|getDecl
argument_list|()
specifier|const
block|{
name|assert
argument_list|(
name|codekind
operator|==
name|Declared
argument_list|)
block|;
return|return
name|static_cast
operator|<
specifier|const
name|FunctionDecl
operator|*
operator|>
operator|(
name|Data
operator|)
return|;
block|}
name|SymbolRef
name|getSymbol
argument_list|()
specifier|const
block|{
name|assert
argument_list|(
name|codekind
operator|==
name|Symbolic
argument_list|)
block|;
return|return
name|const_cast
operator|<
name|SymbolRef
operator|>
operator|(
name|static_cast
operator|<
specifier|const
name|SymbolRef
operator|>
operator|(
name|Data
operator|)
operator|)
return|;
block|}
name|bool
name|isBoundable
argument_list|(
argument|ASTContext&
argument_list|)
specifier|const
block|{
return|return
name|false
return|;
block|}
name|virtual
name|void
name|print
argument_list|(
argument|llvm::raw_ostream& os
argument_list|)
specifier|const
block|;
name|void
name|Profile
argument_list|(
argument|llvm::FoldingSetNodeID& ID
argument_list|)
specifier|const
block|;
specifier|static
name|void
name|ProfileRegion
argument_list|(
argument|llvm::FoldingSetNodeID& ID
argument_list|,
argument|const void* data
argument_list|,
argument|QualType t
argument_list|)
block|;
specifier|static
name|bool
name|classof
argument_list|(
argument|const MemRegion* R
argument_list|)
block|{
return|return
name|R
operator|->
name|getKind
argument_list|()
operator|==
name|CodeTextRegionKind
return|;
block|}
expr|}
block|;
comment|/// SymbolicRegion - A special, "non-concrete" region. Unlike other region
comment|///  clases, SymbolicRegion represents a region that serves as an alias for
comment|///  either a real region, a NULL pointer, etc.  It essentially is used to
comment|///  map the concept of symbolic values into the domain of regions.  Symbolic
comment|///  regions do not need to be typed.
name|class
name|SymbolicRegion
operator|:
name|public
name|SubRegion
block|{
name|protected
operator|:
specifier|const
name|SymbolRef
name|sym
block|;
name|public
operator|:
name|SymbolicRegion
argument_list|(
argument|const SymbolRef s
argument_list|,
argument|const MemRegion* sreg
argument_list|)
operator|:
name|SubRegion
argument_list|(
name|sreg
argument_list|,
name|SymbolicRegionKind
argument_list|)
block|,
name|sym
argument_list|(
argument|s
argument_list|)
block|{}
name|SymbolRef
name|getSymbol
argument_list|()
specifier|const
block|{
return|return
name|sym
return|;
block|}
name|void
name|Profile
argument_list|(
argument|llvm::FoldingSetNodeID& ID
argument_list|)
specifier|const
block|;
specifier|static
name|void
name|ProfileRegion
argument_list|(
argument|llvm::FoldingSetNodeID& ID
argument_list|,
argument|SymbolRef sym
argument_list|)
block|;
name|void
name|print
argument_list|(
argument|llvm::raw_ostream& os
argument_list|)
specifier|const
block|;
specifier|static
name|bool
name|classof
argument_list|(
argument|const MemRegion* R
argument_list|)
block|{
return|return
name|R
operator|->
name|getKind
argument_list|()
operator|==
name|SymbolicRegionKind
return|;
block|}
expr|}
block|;
comment|/// StringRegion - Region associated with a StringLiteral.
name|class
name|StringRegion
operator|:
name|public
name|TypedRegion
block|{
name|friend
name|class
name|MemRegionManager
block|;
specifier|const
name|StringLiteral
operator|*
name|Str
block|;
name|protected
operator|:
name|StringRegion
argument_list|(
specifier|const
name|StringLiteral
operator|*
name|str
argument_list|,
name|MemRegion
operator|*
name|sreg
argument_list|)
operator|:
name|TypedRegion
argument_list|(
name|sreg
argument_list|,
name|StringRegionKind
argument_list|)
block|,
name|Str
argument_list|(
argument|str
argument_list|)
block|{}
specifier|static
name|void
name|ProfileRegion
argument_list|(
name|llvm
operator|::
name|FoldingSetNodeID
operator|&
name|ID
argument_list|,
specifier|const
name|StringLiteral
operator|*
name|Str
argument_list|,
specifier|const
name|MemRegion
operator|*
name|superRegion
argument_list|)
block|;
name|public
operator|:
specifier|const
name|StringLiteral
operator|*
name|getStringLiteral
argument_list|()
specifier|const
block|{
return|return
name|Str
return|;
block|}
name|QualType
name|getValueType
argument_list|(
argument|ASTContext& C
argument_list|)
specifier|const
block|{
return|return
name|Str
operator|->
name|getType
argument_list|()
return|;
block|}
name|void
name|Profile
argument_list|(
argument|llvm::FoldingSetNodeID& ID
argument_list|)
specifier|const
block|{
name|ProfileRegion
argument_list|(
name|ID
argument_list|,
name|Str
argument_list|,
name|superRegion
argument_list|)
block|;   }
name|void
name|print
argument_list|(
argument|llvm::raw_ostream& os
argument_list|)
specifier|const
block|;
specifier|static
name|bool
name|classof
argument_list|(
argument|const MemRegion* R
argument_list|)
block|{
return|return
name|R
operator|->
name|getKind
argument_list|()
operator|==
name|StringRegionKind
return|;
block|}
expr|}
block|;
name|class
name|TypedViewRegion
operator|:
name|public
name|TypedRegion
block|{
name|friend
name|class
name|MemRegionManager
block|;
name|QualType
name|LValueType
block|;
name|TypedViewRegion
argument_list|(
argument|QualType lvalueType
argument_list|,
argument|const MemRegion* sreg
argument_list|)
operator|:
name|TypedRegion
argument_list|(
name|sreg
argument_list|,
name|TypedViewRegionKind
argument_list|)
block|,
name|LValueType
argument_list|(
argument|lvalueType
argument_list|)
block|{}
specifier|static
name|void
name|ProfileRegion
argument_list|(
argument|llvm::FoldingSetNodeID& ID
argument_list|,
argument|QualType T
argument_list|,
argument|const MemRegion* superRegion
argument_list|)
block|;
name|public
operator|:
name|void
name|print
argument_list|(
argument|llvm::raw_ostream& os
argument_list|)
specifier|const
block|;
name|QualType
name|getLocationType
argument_list|(
argument|ASTContext&
argument_list|)
specifier|const
block|{
return|return
name|LValueType
return|;
block|}
name|QualType
name|getValueType
argument_list|(
argument|ASTContext&
argument_list|)
specifier|const
block|{
specifier|const
name|PointerType
operator|*
name|PTy
operator|=
name|LValueType
operator|->
name|getAsPointerType
argument_list|()
block|;
name|assert
argument_list|(
name|PTy
argument_list|)
block|;
return|return
name|PTy
operator|->
name|getPointeeType
argument_list|()
return|;
block|}
name|bool
name|isBoundable
argument_list|(
argument|ASTContext&C
argument_list|)
specifier|const
block|{
return|return
name|isa
operator|<
name|PointerType
operator|>
operator|(
name|LValueType
operator|)
return|;
block|}
name|void
name|Profile
argument_list|(
argument|llvm::FoldingSetNodeID& ID
argument_list|)
specifier|const
block|{
name|ProfileRegion
argument_list|(
name|ID
argument_list|,
name|LValueType
argument_list|,
name|superRegion
argument_list|)
block|;   }
specifier|static
name|bool
name|classof
argument_list|(
argument|const MemRegion* R
argument_list|)
block|{
return|return
name|R
operator|->
name|getKind
argument_list|()
operator|==
name|TypedViewRegionKind
return|;
block|}
specifier|const
name|MemRegion
operator|*
name|removeViews
argument_list|()
specifier|const
block|; }
block|;
comment|/// CompoundLiteralRegion - A memory region representing a compound literal.
comment|///   Compound literals are essentially temporaries that are stack allocated
comment|///   or in the global constant pool.
name|class
name|CompoundLiteralRegion
operator|:
name|public
name|TypedRegion
block|{
name|private
operator|:
name|friend
name|class
name|MemRegionManager
block|;
specifier|const
name|CompoundLiteralExpr
operator|*
name|CL
block|;
name|CompoundLiteralRegion
argument_list|(
specifier|const
name|CompoundLiteralExpr
operator|*
name|cl
argument_list|,
specifier|const
name|MemRegion
operator|*
name|sReg
argument_list|)
operator|:
name|TypedRegion
argument_list|(
name|sReg
argument_list|,
name|CompoundLiteralRegionKind
argument_list|)
block|,
name|CL
argument_list|(
argument|cl
argument_list|)
block|{}
specifier|static
name|void
name|ProfileRegion
argument_list|(
name|llvm
operator|::
name|FoldingSetNodeID
operator|&
name|ID
argument_list|,
specifier|const
name|CompoundLiteralExpr
operator|*
name|CL
argument_list|,
specifier|const
name|MemRegion
operator|*
name|superRegion
argument_list|)
block|;
name|public
operator|:
name|QualType
name|getValueType
argument_list|(
argument|ASTContext& C
argument_list|)
specifier|const
block|{
return|return
name|C
operator|.
name|getCanonicalType
argument_list|(
name|CL
operator|->
name|getType
argument_list|()
argument_list|)
return|;
block|}
name|void
name|Profile
argument_list|(
argument|llvm::FoldingSetNodeID& ID
argument_list|)
specifier|const
block|;
name|void
name|print
argument_list|(
argument|llvm::raw_ostream& os
argument_list|)
specifier|const
block|;
specifier|const
name|CompoundLiteralExpr
operator|*
name|getLiteralExpr
argument_list|()
specifier|const
block|{
return|return
name|CL
return|;
block|}
specifier|static
name|bool
name|classof
argument_list|(
argument|const MemRegion* R
argument_list|)
block|{
return|return
name|R
operator|->
name|getKind
argument_list|()
operator|==
name|CompoundLiteralRegionKind
return|;
block|}
expr|}
block|;
name|class
name|DeclRegion
operator|:
name|public
name|TypedRegion
block|{
name|protected
operator|:
specifier|const
name|Decl
operator|*
name|D
block|;
name|DeclRegion
argument_list|(
argument|const Decl* d
argument_list|,
argument|const MemRegion* sReg
argument_list|,
argument|Kind k
argument_list|)
operator|:
name|TypedRegion
argument_list|(
name|sReg
argument_list|,
name|k
argument_list|)
block|,
name|D
argument_list|(
argument|d
argument_list|)
block|{}
specifier|static
name|void
name|ProfileRegion
argument_list|(
argument|llvm::FoldingSetNodeID& ID
argument_list|,
argument|const Decl* D
argument_list|,
argument|const MemRegion* superRegion
argument_list|,
argument|Kind k
argument_list|)
block|;
name|public
operator|:
specifier|const
name|Decl
operator|*
name|getDecl
argument_list|()
specifier|const
block|{
return|return
name|D
return|;
block|}
name|void
name|Profile
argument_list|(
argument|llvm::FoldingSetNodeID& ID
argument_list|)
specifier|const
block|;
specifier|static
name|bool
name|classof
argument_list|(
argument|const MemRegion* R
argument_list|)
block|{
name|unsigned
name|k
operator|=
name|R
operator|->
name|getKind
argument_list|()
block|;
return|return
name|k
operator|>
name|BEG_DECL_REGIONS
operator|&&
name|k
operator|<
name|END_DECL_REGIONS
return|;
block|}
expr|}
block|;
name|class
name|VarRegion
operator|:
name|public
name|DeclRegion
block|{
name|friend
name|class
name|MemRegionManager
block|;
name|VarRegion
argument_list|(
specifier|const
name|VarDecl
operator|*
name|vd
argument_list|,
specifier|const
name|MemRegion
operator|*
name|sReg
argument_list|)
operator|:
name|DeclRegion
argument_list|(
argument|vd
argument_list|,
argument|sReg
argument_list|,
argument|VarRegionKind
argument_list|)
block|{}
specifier|static
name|void
name|ProfileRegion
argument_list|(
argument|llvm::FoldingSetNodeID& ID
argument_list|,
argument|VarDecl* VD
argument_list|,
argument|const MemRegion* superRegion
argument_list|)
block|{
name|DeclRegion
operator|::
name|ProfileRegion
argument_list|(
name|ID
argument_list|,
name|VD
argument_list|,
name|superRegion
argument_list|,
name|VarRegionKind
argument_list|)
block|;   }
name|public
operator|:
specifier|const
name|VarDecl
operator|*
name|getDecl
argument_list|()
specifier|const
block|{
return|return
name|cast
operator|<
name|VarDecl
operator|>
operator|(
name|D
operator|)
return|;
block|}
name|QualType
name|getValueType
argument_list|(
argument|ASTContext& C
argument_list|)
specifier|const
block|{
comment|// FIXME: We can cache this if needed.
return|return
name|C
operator|.
name|getCanonicalType
argument_list|(
name|getDecl
argument_list|()
operator|->
name|getType
argument_list|()
argument_list|)
return|;
block|}
name|void
name|print
argument_list|(
argument|llvm::raw_ostream& os
argument_list|)
specifier|const
block|;
specifier|static
name|bool
name|classof
argument_list|(
argument|const MemRegion* R
argument_list|)
block|{
return|return
name|R
operator|->
name|getKind
argument_list|()
operator|==
name|VarRegionKind
return|;
block|}
expr|}
block|;
name|class
name|FieldRegion
operator|:
name|public
name|DeclRegion
block|{
name|friend
name|class
name|MemRegionManager
block|;
name|FieldRegion
argument_list|(
specifier|const
name|FieldDecl
operator|*
name|fd
argument_list|,
specifier|const
name|MemRegion
operator|*
name|sReg
argument_list|)
operator|:
name|DeclRegion
argument_list|(
argument|fd
argument_list|,
argument|sReg
argument_list|,
argument|FieldRegionKind
argument_list|)
block|{}
name|public
operator|:
name|void
name|print
argument_list|(
argument|llvm::raw_ostream& os
argument_list|)
specifier|const
block|;
specifier|const
name|FieldDecl
operator|*
name|getDecl
argument_list|()
specifier|const
block|{
return|return
name|cast
operator|<
name|FieldDecl
operator|>
operator|(
name|D
operator|)
return|;
block|}
name|QualType
name|getValueType
argument_list|(
argument|ASTContext& C
argument_list|)
specifier|const
block|{
comment|// FIXME: We can cache this if needed.
return|return
name|C
operator|.
name|getCanonicalType
argument_list|(
name|getDecl
argument_list|()
operator|->
name|getType
argument_list|()
argument_list|)
return|;
block|}
specifier|static
name|void
name|ProfileRegion
argument_list|(
argument|llvm::FoldingSetNodeID& ID
argument_list|,
argument|FieldDecl* FD
argument_list|,
argument|const MemRegion* superRegion
argument_list|)
block|{
name|DeclRegion
operator|::
name|ProfileRegion
argument_list|(
name|ID
argument_list|,
name|FD
argument_list|,
name|superRegion
argument_list|,
name|FieldRegionKind
argument_list|)
block|;   }
specifier|static
name|bool
name|classof
argument_list|(
argument|const MemRegion* R
argument_list|)
block|{
return|return
name|R
operator|->
name|getKind
argument_list|()
operator|==
name|FieldRegionKind
return|;
block|}
expr|}
block|;
name|class
name|ObjCObjectRegion
operator|:
name|public
name|DeclRegion
block|{
name|friend
name|class
name|MemRegionManager
block|;
name|ObjCObjectRegion
argument_list|(
specifier|const
name|ObjCInterfaceDecl
operator|*
name|ivd
argument_list|,
specifier|const
name|MemRegion
operator|*
name|sReg
argument_list|)
operator|:
name|DeclRegion
argument_list|(
argument|ivd
argument_list|,
argument|sReg
argument_list|,
argument|ObjCObjectRegionKind
argument_list|)
block|{}
specifier|static
name|void
name|ProfileRegion
argument_list|(
argument|llvm::FoldingSetNodeID& ID
argument_list|,
argument|ObjCInterfaceDecl* ivd
argument_list|,
argument|const MemRegion* superRegion
argument_list|)
block|{
name|DeclRegion
operator|::
name|ProfileRegion
argument_list|(
name|ID
argument_list|,
name|ivd
argument_list|,
name|superRegion
argument_list|,
name|ObjCObjectRegionKind
argument_list|)
block|;   }
name|public
operator|:
specifier|const
name|ObjCInterfaceDecl
operator|*
name|getInterface
argument_list|()
specifier|const
block|{
return|return
name|cast
operator|<
name|ObjCInterfaceDecl
operator|>
operator|(
name|D
operator|)
return|;
block|}
name|QualType
name|getValueType
argument_list|(
argument|ASTContext& C
argument_list|)
specifier|const
block|{
return|return
name|C
operator|.
name|getObjCInterfaceType
argument_list|(
name|getInterface
argument_list|()
argument_list|)
return|;
block|}
specifier|static
name|bool
name|classof
argument_list|(
argument|const MemRegion* R
argument_list|)
block|{
return|return
name|R
operator|->
name|getKind
argument_list|()
operator|==
name|ObjCObjectRegionKind
return|;
block|}
expr|}
block|;
name|class
name|ObjCIvarRegion
operator|:
name|public
name|DeclRegion
block|{
name|friend
name|class
name|MemRegionManager
block|;
name|ObjCIvarRegion
argument_list|(
specifier|const
name|ObjCIvarDecl
operator|*
name|ivd
argument_list|,
specifier|const
name|MemRegion
operator|*
name|sReg
argument_list|)
operator|:
name|DeclRegion
argument_list|(
argument|ivd
argument_list|,
argument|sReg
argument_list|,
argument|ObjCIvarRegionKind
argument_list|)
block|{}
specifier|static
name|void
name|ProfileRegion
argument_list|(
argument|llvm::FoldingSetNodeID& ID
argument_list|,
argument|ObjCIvarDecl* ivd
argument_list|,
argument|const MemRegion* superRegion
argument_list|)
block|{
name|DeclRegion
operator|::
name|ProfileRegion
argument_list|(
name|ID
argument_list|,
name|ivd
argument_list|,
name|superRegion
argument_list|,
name|ObjCIvarRegionKind
argument_list|)
block|;   }
name|public
operator|:
specifier|const
name|ObjCIvarDecl
operator|*
name|getDecl
argument_list|()
specifier|const
block|{
return|return
name|cast
operator|<
name|ObjCIvarDecl
operator|>
operator|(
name|D
operator|)
return|;
block|}
name|QualType
name|getValueType
argument_list|(
argument|ASTContext&
argument_list|)
specifier|const
block|{
return|return
name|getDecl
argument_list|()
operator|->
name|getType
argument_list|()
return|;
block|}
specifier|static
name|bool
name|classof
argument_list|(
argument|const MemRegion* R
argument_list|)
block|{
return|return
name|R
operator|->
name|getKind
argument_list|()
operator|==
name|ObjCIvarRegionKind
return|;
block|}
expr|}
block|;
name|class
name|ElementRegion
operator|:
name|public
name|TypedRegion
block|{
name|friend
name|class
name|MemRegionManager
block|;
name|QualType
name|ElementType
block|;
name|SVal
name|Index
block|;
name|ElementRegion
argument_list|(
argument|QualType elementType
argument_list|,
argument|SVal Idx
argument_list|,
argument|const MemRegion* sReg
argument_list|)
operator|:
name|TypedRegion
argument_list|(
name|sReg
argument_list|,
name|ElementRegionKind
argument_list|)
block|,
name|ElementType
argument_list|(
name|elementType
argument_list|)
block|,
name|Index
argument_list|(
argument|Idx
argument_list|)
block|{
name|assert
argument_list|(
operator|(
operator|!
name|isa
operator|<
name|nonloc
operator|::
name|ConcreteInt
operator|>
operator|(
operator|&
name|Idx
operator|)
operator|||
name|cast
operator|<
name|nonloc
operator|::
name|ConcreteInt
operator|>
operator|(
operator|&
name|Idx
operator|)
operator|->
name|getValue
argument_list|()
operator|.
name|isSigned
argument_list|()
operator|)
operator|&&
literal|"The index must be signed"
argument_list|)
block|;   }
specifier|static
name|void
name|ProfileRegion
argument_list|(
argument|llvm::FoldingSetNodeID& ID
argument_list|,
argument|QualType elementType
argument_list|,
argument|SVal Idx
argument_list|,
argument|const MemRegion* superRegion
argument_list|)
block|;
name|public
operator|:
name|SVal
name|getIndex
argument_list|()
specifier|const
block|{
return|return
name|Index
return|;
block|}
name|QualType
name|getValueType
argument_list|(
argument|ASTContext&
argument_list|)
specifier|const
block|{
return|return
name|ElementType
return|;
block|}
name|QualType
name|getElementType
argument_list|()
specifier|const
block|{
return|return
name|ElementType
return|;
block|}
name|void
name|print
argument_list|(
argument|llvm::raw_ostream& os
argument_list|)
specifier|const
block|;
name|void
name|Profile
argument_list|(
argument|llvm::FoldingSetNodeID& ID
argument_list|)
specifier|const
block|;
specifier|static
name|bool
name|classof
argument_list|(
argument|const MemRegion* R
argument_list|)
block|{
return|return
name|R
operator|->
name|getKind
argument_list|()
operator|==
name|ElementRegionKind
return|;
block|}
expr|}
block|;
name|template
operator|<
name|typename
name|RegionTy
operator|>
specifier|const
name|RegionTy
operator|*
name|MemRegion
operator|::
name|getAs
argument_list|()
specifier|const
block|{
specifier|const
name|MemRegion
operator|*
name|R
operator|=
name|this
block|;
do|do
block|{
if|if
condition|(
specifier|const
name|RegionTy
modifier|*
name|RT
init|=
name|dyn_cast
operator|<
name|RegionTy
operator|>
operator|(
name|R
operator|)
condition|)
return|return
name|RT
return|;
if|if
condition|(
specifier|const
name|TypedViewRegion
modifier|*
name|TR
init|=
name|dyn_cast
operator|<
name|TypedViewRegion
operator|>
operator|(
name|R
operator|)
condition|)
block|{
name|R
operator|=
name|TR
operator|->
name|getSuperRegion
argument_list|()
expr_stmt|;
continue|continue;
block|}
break|break;
block|}
while|while
condition|(
name|R
condition|)
empty_stmt|;
do|return 0; }
comment|//===----------------------------------------------------------------------===//
comment|// MemRegionManager - Factory object for creating regions.
comment|//===----------------------------------------------------------------------===//
do|class MemRegionManager
block|{
name|llvm
operator|::
name|BumpPtrAllocator
operator|&
name|A
expr_stmt|;
name|llvm
operator|::
name|FoldingSet
operator|<
name|MemRegion
operator|>
name|Regions
expr_stmt|;
name|MemSpaceRegion
modifier|*
name|globals
decl_stmt|;
name|MemSpaceRegion
modifier|*
name|stack
decl_stmt|;
name|MemSpaceRegion
modifier|*
name|heap
decl_stmt|;
name|MemSpaceRegion
modifier|*
name|unknown
decl_stmt|;
name|MemSpaceRegion
modifier|*
name|code
decl_stmt|;
name|public
label|:
name|MemRegionManager
argument_list|(
name|llvm
operator|::
name|BumpPtrAllocator
operator|&
name|a
argument_list|)
operator|:
name|A
argument_list|(
name|a
argument_list|)
operator|,
name|globals
argument_list|(
literal|0
argument_list|)
operator|,
name|stack
argument_list|(
literal|0
argument_list|)
operator|,
name|heap
argument_list|(
literal|0
argument_list|)
operator|,
name|unknown
argument_list|(
literal|0
argument_list|)
operator|,
name|code
argument_list|(
literal|0
argument_list|)
block|{}
operator|~
name|MemRegionManager
argument_list|()
block|{}
comment|/// getStackRegion - Retrieve the memory region associated with the
comment|///  current stack frame.
name|MemSpaceRegion
operator|*
name|getStackRegion
argument_list|()
expr_stmt|;
comment|/// getGlobalsRegion - Retrieve the memory region associated with
comment|///  all global variables.
name|MemSpaceRegion
modifier|*
name|getGlobalsRegion
parameter_list|()
function_decl|;
comment|/// getHeapRegion - Retrieve the memory region associated with the
comment|///  generic "heap".
name|MemSpaceRegion
modifier|*
name|getHeapRegion
parameter_list|()
function_decl|;
comment|/// getUnknownRegion - Retrieve the memory region associated with unknown
comment|/// memory space.
name|MemSpaceRegion
modifier|*
name|getUnknownRegion
parameter_list|()
function_decl|;
name|MemSpaceRegion
modifier|*
name|getCodeRegion
parameter_list|()
function_decl|;
name|bool
name|isGlobalsRegion
parameter_list|(
specifier|const
name|MemRegion
modifier|*
name|R
parameter_list|)
block|{
name|assert
argument_list|(
name|R
argument_list|)
expr_stmt|;
return|return
name|R
operator|==
name|globals
return|;
block|}
comment|/// onStack - check if the region is allocated on the stack.
function|bool onStack
parameter_list|(
specifier|const
name|MemRegion
modifier|*
name|R
parameter_list|)
function|;
comment|/// onHeap - check if the region is allocated on the heap, usually by malloc.
name|bool
name|onHeap
parameter_list|(
specifier|const
name|MemRegion
modifier|*
name|R
parameter_list|)
function_decl|;
comment|/// getAllocaRegion - Retrieve a region associated with a call to alloca().
name|AllocaRegion
modifier|*
name|getAllocaRegion
parameter_list|(
specifier|const
name|Expr
modifier|*
name|Ex
parameter_list|,
name|unsigned
name|Cnt
parameter_list|)
function_decl|;
comment|/// getCompoundLiteralRegion - Retrieve the region associated with a
comment|///  given CompoundLiteral.
name|CompoundLiteralRegion
modifier|*
name|getCompoundLiteralRegion
parameter_list|(
specifier|const
name|CompoundLiteralExpr
modifier|*
name|CL
parameter_list|)
function_decl|;
comment|/// getSymbolicRegion - Retrieve or create a "symbolic" memory region.
name|SymbolicRegion
modifier|*
name|getSymbolicRegion
parameter_list|(
name|SymbolRef
name|sym
parameter_list|)
function_decl|;
name|StringRegion
modifier|*
name|getStringRegion
parameter_list|(
specifier|const
name|StringLiteral
modifier|*
name|Str
parameter_list|)
function_decl|;
comment|/// getVarRegion - Retrieve or create the memory region associated with
comment|///  a specified VarDecl.
name|VarRegion
modifier|*
name|getVarRegion
parameter_list|(
specifier|const
name|VarDecl
modifier|*
name|vd
parameter_list|)
function_decl|;
comment|/// getElementRegion - Retrieve the memory region associated with the
comment|///  associated element type, index, and super region.
name|ElementRegion
modifier|*
name|getElementRegion
parameter_list|(
name|QualType
name|elementType
parameter_list|,
name|SVal
name|Idx
parameter_list|,
specifier|const
name|MemRegion
modifier|*
name|superRegion
parameter_list|)
function_decl|;
comment|/// getFieldRegion - Retrieve or create the memory region associated with
comment|///  a specified FieldDecl.  'superRegion' corresponds to the containing
comment|///  memory region (which typically represents the memory representing
comment|///  a structure or class).
name|FieldRegion
modifier|*
name|getFieldRegion
parameter_list|(
specifier|const
name|FieldDecl
modifier|*
name|fd
parameter_list|,
specifier|const
name|MemRegion
modifier|*
name|superRegion
parameter_list|)
function_decl|;
comment|/// getObjCObjectRegion - Retrieve or create the memory region associated with
comment|///  the instance of a specified Objective-C class.
name|ObjCObjectRegion
modifier|*
name|getObjCObjectRegion
parameter_list|(
specifier|const
name|ObjCInterfaceDecl
modifier|*
name|ID
parameter_list|,
specifier|const
name|MemRegion
modifier|*
name|superRegion
parameter_list|)
function_decl|;
comment|/// getObjCIvarRegion - Retrieve or create the memory region associated with
comment|///   a specified Objective-c instance variable.  'superRegion' corresponds
comment|///   to the containing region (which typically represents the Objective-C
comment|///   object).
name|ObjCIvarRegion
modifier|*
name|getObjCIvarRegion
parameter_list|(
specifier|const
name|ObjCIvarDecl
modifier|*
name|ivd
parameter_list|,
specifier|const
name|MemRegion
modifier|*
name|superRegion
parameter_list|)
function_decl|;
name|TypedViewRegion
modifier|*
name|getTypedViewRegion
parameter_list|(
name|QualType
name|LValueType
parameter_list|,
specifier|const
name|MemRegion
modifier|*
name|superRegion
parameter_list|)
function_decl|;
name|CodeTextRegion
modifier|*
name|getCodeTextRegion
parameter_list|(
name|SymbolRef
name|sym
parameter_list|,
name|QualType
name|t
parameter_list|)
function_decl|;
name|CodeTextRegion
modifier|*
name|getCodeTextRegion
parameter_list|(
specifier|const
name|FunctionDecl
modifier|*
name|fd
parameter_list|,
name|QualType
name|t
parameter_list|)
function_decl|;
name|bool
name|hasStackStorage
parameter_list|(
specifier|const
name|MemRegion
modifier|*
name|R
parameter_list|)
function_decl|;
name|private
label|:
name|MemSpaceRegion
modifier|*
name|LazyAllocate
parameter_list|(
name|MemSpaceRegion
modifier|*
modifier|&
name|region
parameter_list|)
function_decl|;
block|}
do|; }
comment|// end clang namespace
do|namespace llvm
block|{
specifier|static
specifier|inline
name|raw_ostream
operator|&
name|operator
operator|<<
operator|(
name|raw_ostream
operator|&
name|O
expr|,
specifier|const
name|clang
operator|::
name|MemRegion
operator|*
name|R
operator|)
block|{
name|R
operator|->
name|print
argument_list|(
name|O
argument_list|)
block|;
return|return
name|O
return|;
block|}
expr|}
end_decl_stmt

begin_comment
comment|// end llvm namespace
end_comment

begin_endif
endif|#
directive|endif
end_endif

end_unit

