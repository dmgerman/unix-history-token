begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//== MemRegion.h - Abstract memory regions for static analysis --*- C++ -*--==//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//  This file defines MemRegion and its subclasses.  MemRegion defines a
end_comment

begin_comment
comment|//  partially-typed abstraction of memory useful for path-sensitive dataflow
end_comment

begin_comment
comment|//  analyses.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LLVM_CLANG_ANALYSIS_MEMREGION_H
end_ifndef

begin_define
define|#
directive|define
name|LLVM_CLANG_ANALYSIS_MEMREGION_H
end_define

begin_include
include|#
directive|include
file|"clang/AST/Decl.h"
end_include

begin_include
include|#
directive|include
file|"clang/AST/DeclObjC.h"
end_include

begin_include
include|#
directive|include
file|"clang/Analysis/PathSensitive/SymbolManager.h"
end_include

begin_include
include|#
directive|include
file|"clang/Analysis/PathSensitive/SVals.h"
end_include

begin_include
include|#
directive|include
file|"clang/AST/ASTContext.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/Casting.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/FoldingSet.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/ImmutableList.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/ImmutableMap.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/Allocator.h"
end_include

begin_include
include|#
directive|include
file|<string>
end_include

begin_decl_stmt
name|namespace
name|llvm
block|{
name|class
name|raw_ostream
decl_stmt|;
block|}
end_decl_stmt

begin_decl_stmt
name|namespace
name|clang
block|{
name|class
name|MemRegionManager
decl_stmt|;
name|class
name|MemSpaceRegion
decl_stmt|;
name|class
name|LocationContext
decl_stmt|;
comment|//===----------------------------------------------------------------------===//
comment|// Base region classes.
comment|//===----------------------------------------------------------------------===//
comment|/// MemRegion - The root abstract class for all memory regions.
name|class
name|MemRegion
range|:
name|public
name|llvm
operator|::
name|FoldingSetNode
block|{
name|public
operator|:
expr|enum
name|Kind
block|{
name|MemSpaceRegionKind
block|,
name|SymbolicRegionKind
block|,
name|AllocaRegionKind
block|,
comment|// Typed regions.
name|BEG_TYPED_REGIONS
block|,
name|CodeTextRegionKind
block|,
name|CompoundLiteralRegionKind
block|,
name|StringRegionKind
block|,
name|ElementRegionKind
block|,
comment|// Decl Regions.
name|BEG_DECL_REGIONS
block|,
name|VarRegionKind
block|,
name|FieldRegionKind
block|,
name|ObjCIvarRegionKind
block|,
name|ObjCObjectRegionKind
block|,
name|END_DECL_REGIONS
block|,
name|END_TYPED_REGIONS
block|}
block|;
name|private
operator|:
specifier|const
name|Kind
name|kind
block|;
name|protected
operator|:
name|MemRegion
argument_list|(
argument|Kind k
argument_list|)
operator|:
name|kind
argument_list|(
argument|k
argument_list|)
block|{}
name|virtual
operator|~
name|MemRegion
argument_list|()
block|;
name|public
operator|:
name|ASTContext
operator|&
name|getContext
argument_list|()
specifier|const
block|;
name|virtual
name|void
name|Profile
argument_list|(
argument|llvm::FoldingSetNodeID& ID
argument_list|)
specifier|const
operator|=
literal|0
block|;
name|virtual
name|MemRegionManager
operator|*
name|getMemRegionManager
argument_list|()
specifier|const
operator|=
literal|0
block|;
name|std
operator|::
name|string
name|getString
argument_list|()
specifier|const
block|;
specifier|const
name|MemSpaceRegion
operator|*
name|getMemorySpace
argument_list|()
specifier|const
block|;
specifier|const
name|MemRegion
operator|*
name|getBaseRegion
argument_list|()
specifier|const
block|;
specifier|const
name|MemRegion
operator|*
name|StripCasts
argument_list|()
specifier|const
block|;
name|bool
name|hasStackStorage
argument_list|()
specifier|const
block|;
name|bool
name|hasParametersStorage
argument_list|()
specifier|const
block|;
name|bool
name|hasGlobalsStorage
argument_list|()
specifier|const
block|;
name|bool
name|hasGlobalsOrParametersStorage
argument_list|()
specifier|const
block|;
name|bool
name|hasHeapStorage
argument_list|()
specifier|const
block|;
name|bool
name|hasHeapOrStackStorage
argument_list|()
specifier|const
block|;
name|virtual
name|void
name|dumpToStream
argument_list|(
argument|llvm::raw_ostream& os
argument_list|)
specifier|const
block|;
name|void
name|dump
argument_list|()
specifier|const
block|;
name|Kind
name|getKind
argument_list|()
specifier|const
block|{
return|return
name|kind
return|;
block|}
name|template
operator|<
name|typename
name|RegionTy
operator|>
specifier|const
name|RegionTy
operator|*
name|getAs
argument_list|()
specifier|const
block|;
name|virtual
name|bool
name|isBoundable
argument_list|()
specifier|const
block|{
return|return
name|false
return|;
block|}
specifier|static
name|bool
name|classof
argument_list|(
argument|const MemRegion*
argument_list|)
block|{
return|return
name|true
return|;
block|}
expr|}
block|;
comment|/// MemSpaceRegion - A memory region that represents and "memory space";
comment|///  for example, the set of global variables, the stack frame, etc.
name|class
name|MemSpaceRegion
operator|:
name|public
name|MemRegion
block|{
name|friend
name|class
name|MemRegionManager
block|;
name|protected
operator|:
name|MemRegionManager
operator|*
name|Mgr
block|;
name|MemSpaceRegion
argument_list|(
name|MemRegionManager
operator|*
name|mgr
argument_list|)
operator|:
name|MemRegion
argument_list|(
name|MemSpaceRegionKind
argument_list|)
block|,
name|Mgr
argument_list|(
argument|mgr
argument_list|)
block|{}
name|MemRegionManager
operator|*
name|getMemRegionManager
argument_list|()
specifier|const
block|{
return|return
name|Mgr
return|;
block|}
name|public
operator|:
name|void
name|Profile
argument_list|(
argument|llvm::FoldingSetNodeID& ID
argument_list|)
specifier|const
block|;
name|bool
name|isBoundable
argument_list|()
specifier|const
block|{
return|return
name|false
return|;
block|}
specifier|static
name|bool
name|classof
argument_list|(
argument|const MemRegion* R
argument_list|)
block|{
return|return
name|R
operator|->
name|getKind
argument_list|()
operator|==
name|MemSpaceRegionKind
return|;
block|}
expr|}
block|;
comment|/// SubRegion - A region that subsets another larger region.  Most regions
comment|///  are subclasses of SubRegion.
name|class
name|SubRegion
operator|:
name|public
name|MemRegion
block|{
name|protected
operator|:
specifier|const
name|MemRegion
operator|*
name|superRegion
block|;
name|SubRegion
argument_list|(
argument|const MemRegion* sReg
argument_list|,
argument|Kind k
argument_list|)
operator|:
name|MemRegion
argument_list|(
name|k
argument_list|)
block|,
name|superRegion
argument_list|(
argument|sReg
argument_list|)
block|{}
name|public
operator|:
specifier|const
name|MemRegion
operator|*
name|getSuperRegion
argument_list|()
specifier|const
block|{
return|return
name|superRegion
return|;
block|}
name|MemRegionManager
operator|*
name|getMemRegionManager
argument_list|()
specifier|const
block|;
name|bool
name|isSubRegionOf
argument_list|(
argument|const MemRegion* R
argument_list|)
specifier|const
block|;
specifier|static
name|bool
name|classof
argument_list|(
argument|const MemRegion* R
argument_list|)
block|{
return|return
name|R
operator|->
name|getKind
argument_list|()
operator|>
name|MemSpaceRegionKind
return|;
block|}
expr|}
block|;
comment|//===----------------------------------------------------------------------===//
comment|// Auxillary data classes for use with MemRegions.
comment|//===----------------------------------------------------------------------===//
name|class
name|ElementRegion
block|;
name|class
name|RegionRawOffset
operator|:
name|public
name|std
operator|::
name|pair
operator|<
specifier|const
name|MemRegion
operator|*
block|,
name|int64_t
operator|>
block|{
name|private
operator|:
name|friend
name|class
name|ElementRegion
block|;
name|RegionRawOffset
argument_list|(
argument|const MemRegion* reg
argument_list|,
argument|int64_t offset =
literal|0
argument_list|)
operator|:
name|std
operator|::
name|pair
operator|<
specifier|const
name|MemRegion
operator|*
block|,
name|int64_t
operator|>
operator|(
name|reg
expr|,
name|offset
operator|)
block|{}
name|public
operator|:
comment|// FIXME: Eventually support symbolic offsets.
name|int64_t
name|getByteOffset
argument_list|()
specifier|const
block|{
return|return
name|second
return|;
block|}
specifier|const
name|MemRegion
operator|*
name|getRegion
argument_list|()
specifier|const
block|{
return|return
name|first
return|;
block|}
name|void
name|dumpToStream
argument_list|(
argument|llvm::raw_ostream& os
argument_list|)
specifier|const
block|;
name|void
name|dump
argument_list|()
specifier|const
block|; }
block|;
comment|//===----------------------------------------------------------------------===//
comment|// MemRegion subclasses.
comment|//===----------------------------------------------------------------------===//
comment|/// AllocaRegion - A region that represents an untyped blob of bytes created
comment|///  by a call to 'alloca'.
name|class
name|AllocaRegion
operator|:
name|public
name|SubRegion
block|{
name|friend
name|class
name|MemRegionManager
block|;
name|protected
operator|:
name|unsigned
name|Cnt
block|;
comment|// Block counter.  Used to distinguish different pieces of
comment|// memory allocated by alloca at the same call site.
specifier|const
name|Expr
operator|*
name|Ex
block|;
name|AllocaRegion
argument_list|(
argument|const Expr* ex
argument_list|,
argument|unsigned cnt
argument_list|,
argument|const MemRegion *superRegion
argument_list|)
operator|:
name|SubRegion
argument_list|(
name|superRegion
argument_list|,
name|AllocaRegionKind
argument_list|)
block|,
name|Cnt
argument_list|(
name|cnt
argument_list|)
block|,
name|Ex
argument_list|(
argument|ex
argument_list|)
block|{}
name|public
operator|:
specifier|const
name|Expr
operator|*
name|getExpr
argument_list|()
specifier|const
block|{
return|return
name|Ex
return|;
block|}
name|bool
name|isBoundable
argument_list|()
specifier|const
block|{
return|return
name|true
return|;
block|}
name|void
name|Profile
argument_list|(
argument|llvm::FoldingSetNodeID& ID
argument_list|)
specifier|const
block|;
specifier|static
name|void
name|ProfileRegion
argument_list|(
argument|llvm::FoldingSetNodeID& ID
argument_list|,
argument|const Expr* Ex
argument_list|,
argument|unsigned Cnt
argument_list|,
argument|const MemRegion *superRegion
argument_list|)
block|;
name|void
name|dumpToStream
argument_list|(
argument|llvm::raw_ostream& os
argument_list|)
specifier|const
block|;
specifier|static
name|bool
name|classof
argument_list|(
argument|const MemRegion* R
argument_list|)
block|{
return|return
name|R
operator|->
name|getKind
argument_list|()
operator|==
name|AllocaRegionKind
return|;
block|}
expr|}
block|;
comment|/// TypedRegion - An abstract class representing regions that are typed.
name|class
name|TypedRegion
operator|:
name|public
name|SubRegion
block|{
name|protected
operator|:
name|TypedRegion
argument_list|(
argument|const MemRegion* sReg
argument_list|,
argument|Kind k
argument_list|)
operator|:
name|SubRegion
argument_list|(
argument|sReg
argument_list|,
argument|k
argument_list|)
block|{}
name|public
operator|:
name|virtual
name|QualType
name|getValueType
argument_list|(
argument|ASTContext&C
argument_list|)
specifier|const
operator|=
literal|0
block|;
name|virtual
name|QualType
name|getLocationType
argument_list|(
argument|ASTContext& C
argument_list|)
specifier|const
block|{
comment|// FIXME: We can possibly optimize this later to cache this value.
return|return
name|C
operator|.
name|getPointerType
argument_list|(
name|getValueType
argument_list|(
name|C
argument_list|)
argument_list|)
return|;
block|}
name|QualType
name|getDesugaredValueType
argument_list|(
argument|ASTContext& C
argument_list|)
specifier|const
block|{
name|QualType
name|T
operator|=
name|getValueType
argument_list|(
name|C
argument_list|)
block|;
return|return
name|T
operator|.
name|getTypePtr
argument_list|()
condition|?
name|T
operator|.
name|getDesugaredType
argument_list|()
else|:
name|T
return|;
block|}
name|QualType
name|getDesugaredLocationType
argument_list|(
argument|ASTContext& C
argument_list|)
specifier|const
block|{
return|return
name|getLocationType
argument_list|(
name|C
argument_list|)
operator|.
name|getDesugaredType
argument_list|()
return|;
block|}
name|bool
name|isBoundable
argument_list|()
specifier|const
block|{
return|return
operator|!
name|getValueType
argument_list|(
name|getContext
argument_list|()
argument_list|)
operator|.
name|isNull
argument_list|()
return|;
block|}
specifier|static
name|bool
name|classof
argument_list|(
argument|const MemRegion* R
argument_list|)
block|{
name|unsigned
name|k
operator|=
name|R
operator|->
name|getKind
argument_list|()
block|;
return|return
name|k
operator|>
name|BEG_TYPED_REGIONS
operator|&&
name|k
operator|<
name|END_TYPED_REGIONS
return|;
block|}
expr|}
block|;
comment|/// CodeTextRegion - A region that represents code texts of a function. It wraps
comment|/// two kinds of code texts: real function and symbolic function. Real function
comment|/// is a function declared in the program. Symbolic function is a function
comment|/// pointer that we don't know which function it points to.
name|class
name|CodeTextRegion
operator|:
name|public
name|TypedRegion
block|{
specifier|const
name|FunctionDecl
operator|*
name|FD
block|;
name|public
operator|:
name|CodeTextRegion
argument_list|(
specifier|const
name|FunctionDecl
operator|*
name|fd
argument_list|,
specifier|const
name|MemRegion
operator|*
name|sreg
argument_list|)
operator|:
name|TypedRegion
argument_list|(
name|sreg
argument_list|,
name|CodeTextRegionKind
argument_list|)
block|,
name|FD
argument_list|(
argument|fd
argument_list|)
block|{}
name|QualType
name|getValueType
argument_list|(
argument|ASTContext&C
argument_list|)
specifier|const
block|{
comment|// Do not get the object type of a CodeTextRegion.
name|assert
argument_list|(
literal|0
argument_list|)
block|;
return|return
name|QualType
argument_list|()
return|;
block|}
name|QualType
name|getLocationType
argument_list|(
argument|ASTContext&C
argument_list|)
specifier|const
block|{
return|return
name|C
operator|.
name|getPointerType
argument_list|(
name|FD
operator|->
name|getType
argument_list|()
argument_list|)
return|;
block|}
specifier|const
name|FunctionDecl
operator|*
name|getDecl
argument_list|()
specifier|const
block|{
return|return
name|FD
return|;
block|}
name|bool
name|isBoundable
argument_list|()
specifier|const
block|{
return|return
name|false
return|;
block|}
name|virtual
name|void
name|dumpToStream
argument_list|(
argument|llvm::raw_ostream& os
argument_list|)
specifier|const
block|;
name|void
name|Profile
argument_list|(
argument|llvm::FoldingSetNodeID& ID
argument_list|)
specifier|const
block|;
specifier|static
name|void
name|ProfileRegion
argument_list|(
name|llvm
operator|::
name|FoldingSetNodeID
operator|&
name|ID
argument_list|,
specifier|const
name|FunctionDecl
operator|*
name|FD
argument_list|,
specifier|const
name|MemRegion
operator|*
argument_list|)
block|;
specifier|static
name|bool
name|classof
argument_list|(
argument|const MemRegion* R
argument_list|)
block|{
return|return
name|R
operator|->
name|getKind
argument_list|()
operator|==
name|CodeTextRegionKind
return|;
block|}
expr|}
block|;
comment|/// SymbolicRegion - A special, "non-concrete" region. Unlike other region
comment|///  clases, SymbolicRegion represents a region that serves as an alias for
comment|///  either a real region, a NULL pointer, etc.  It essentially is used to
comment|///  map the concept of symbolic values into the domain of regions.  Symbolic
comment|///  regions do not need to be typed.
name|class
name|SymbolicRegion
operator|:
name|public
name|SubRegion
block|{
name|protected
operator|:
specifier|const
name|SymbolRef
name|sym
block|;
name|public
operator|:
name|SymbolicRegion
argument_list|(
argument|const SymbolRef s
argument_list|,
argument|const MemRegion* sreg
argument_list|)
operator|:
name|SubRegion
argument_list|(
name|sreg
argument_list|,
name|SymbolicRegionKind
argument_list|)
block|,
name|sym
argument_list|(
argument|s
argument_list|)
block|{}
name|SymbolRef
name|getSymbol
argument_list|()
specifier|const
block|{
return|return
name|sym
return|;
block|}
name|bool
name|isBoundable
argument_list|()
specifier|const
block|{
return|return
name|true
return|;
block|}
name|void
name|Profile
argument_list|(
argument|llvm::FoldingSetNodeID& ID
argument_list|)
specifier|const
block|;
specifier|static
name|void
name|ProfileRegion
argument_list|(
argument|llvm::FoldingSetNodeID& ID
argument_list|,
argument|SymbolRef sym
argument_list|,
argument|const MemRegion* superRegion
argument_list|)
block|;
name|void
name|dumpToStream
argument_list|(
argument|llvm::raw_ostream& os
argument_list|)
specifier|const
block|;
specifier|static
name|bool
name|classof
argument_list|(
argument|const MemRegion* R
argument_list|)
block|{
return|return
name|R
operator|->
name|getKind
argument_list|()
operator|==
name|SymbolicRegionKind
return|;
block|}
expr|}
block|;
comment|/// StringRegion - Region associated with a StringLiteral.
name|class
name|StringRegion
operator|:
name|public
name|TypedRegion
block|{
name|friend
name|class
name|MemRegionManager
block|;
specifier|const
name|StringLiteral
operator|*
name|Str
block|;
name|protected
operator|:
name|StringRegion
argument_list|(
specifier|const
name|StringLiteral
operator|*
name|str
argument_list|,
specifier|const
name|MemRegion
operator|*
name|sreg
argument_list|)
operator|:
name|TypedRegion
argument_list|(
name|sreg
argument_list|,
name|StringRegionKind
argument_list|)
block|,
name|Str
argument_list|(
argument|str
argument_list|)
block|{}
specifier|static
name|void
name|ProfileRegion
argument_list|(
name|llvm
operator|::
name|FoldingSetNodeID
operator|&
name|ID
argument_list|,
specifier|const
name|StringLiteral
operator|*
name|Str
argument_list|,
specifier|const
name|MemRegion
operator|*
name|superRegion
argument_list|)
block|;
name|public
operator|:
specifier|const
name|StringLiteral
operator|*
name|getStringLiteral
argument_list|()
specifier|const
block|{
return|return
name|Str
return|;
block|}
name|QualType
name|getValueType
argument_list|(
argument|ASTContext& C
argument_list|)
specifier|const
block|{
return|return
name|Str
operator|->
name|getType
argument_list|()
return|;
block|}
name|bool
name|isBoundable
argument_list|()
specifier|const
block|{
return|return
name|false
return|;
block|}
name|void
name|Profile
argument_list|(
argument|llvm::FoldingSetNodeID& ID
argument_list|)
specifier|const
block|{
name|ProfileRegion
argument_list|(
name|ID
argument_list|,
name|Str
argument_list|,
name|superRegion
argument_list|)
block|;   }
name|void
name|dumpToStream
argument_list|(
argument|llvm::raw_ostream& os
argument_list|)
specifier|const
block|;
specifier|static
name|bool
name|classof
argument_list|(
argument|const MemRegion* R
argument_list|)
block|{
return|return
name|R
operator|->
name|getKind
argument_list|()
operator|==
name|StringRegionKind
return|;
block|}
expr|}
block|;
comment|/// CompoundLiteralRegion - A memory region representing a compound literal.
comment|///   Compound literals are essentially temporaries that are stack allocated
comment|///   or in the global constant pool.
name|class
name|CompoundLiteralRegion
operator|:
name|public
name|TypedRegion
block|{
name|private
operator|:
name|friend
name|class
name|MemRegionManager
block|;
specifier|const
name|CompoundLiteralExpr
operator|*
name|CL
block|;
name|CompoundLiteralRegion
argument_list|(
specifier|const
name|CompoundLiteralExpr
operator|*
name|cl
argument_list|,
specifier|const
name|MemRegion
operator|*
name|sReg
argument_list|)
operator|:
name|TypedRegion
argument_list|(
name|sReg
argument_list|,
name|CompoundLiteralRegionKind
argument_list|)
block|,
name|CL
argument_list|(
argument|cl
argument_list|)
block|{}
specifier|static
name|void
name|ProfileRegion
argument_list|(
name|llvm
operator|::
name|FoldingSetNodeID
operator|&
name|ID
argument_list|,
specifier|const
name|CompoundLiteralExpr
operator|*
name|CL
argument_list|,
specifier|const
name|MemRegion
operator|*
name|superRegion
argument_list|)
block|;
name|public
operator|:
name|QualType
name|getValueType
argument_list|(
argument|ASTContext& C
argument_list|)
specifier|const
block|{
return|return
name|C
operator|.
name|getCanonicalType
argument_list|(
name|CL
operator|->
name|getType
argument_list|()
argument_list|)
return|;
block|}
name|bool
name|isBoundable
argument_list|()
specifier|const
block|{
return|return
operator|!
name|CL
operator|->
name|isFileScope
argument_list|()
return|;
block|}
name|void
name|Profile
argument_list|(
argument|llvm::FoldingSetNodeID& ID
argument_list|)
specifier|const
block|;
name|void
name|dumpToStream
argument_list|(
argument|llvm::raw_ostream& os
argument_list|)
specifier|const
block|;
specifier|const
name|CompoundLiteralExpr
operator|*
name|getLiteralExpr
argument_list|()
specifier|const
block|{
return|return
name|CL
return|;
block|}
specifier|static
name|bool
name|classof
argument_list|(
argument|const MemRegion* R
argument_list|)
block|{
return|return
name|R
operator|->
name|getKind
argument_list|()
operator|==
name|CompoundLiteralRegionKind
return|;
block|}
expr|}
block|;
name|class
name|DeclRegion
operator|:
name|public
name|TypedRegion
block|{
name|protected
operator|:
specifier|const
name|Decl
operator|*
name|D
block|;
name|DeclRegion
argument_list|(
argument|const Decl* d
argument_list|,
argument|const MemRegion* sReg
argument_list|,
argument|Kind k
argument_list|)
operator|:
name|TypedRegion
argument_list|(
name|sReg
argument_list|,
name|k
argument_list|)
block|,
name|D
argument_list|(
argument|d
argument_list|)
block|{}
specifier|static
name|void
name|ProfileRegion
argument_list|(
argument|llvm::FoldingSetNodeID& ID
argument_list|,
argument|const Decl* D
argument_list|,
argument|const MemRegion* superRegion
argument_list|,
argument|Kind k
argument_list|)
block|;
name|public
operator|:
specifier|const
name|Decl
operator|*
name|getDecl
argument_list|()
specifier|const
block|{
return|return
name|D
return|;
block|}
name|void
name|Profile
argument_list|(
argument|llvm::FoldingSetNodeID& ID
argument_list|)
specifier|const
block|;
specifier|static
name|bool
name|classof
argument_list|(
argument|const MemRegion* R
argument_list|)
block|{
name|unsigned
name|k
operator|=
name|R
operator|->
name|getKind
argument_list|()
block|;
return|return
name|k
operator|>
name|BEG_DECL_REGIONS
operator|&&
name|k
operator|<
name|END_DECL_REGIONS
return|;
block|}
expr|}
block|;
name|class
name|VarRegion
operator|:
name|public
name|DeclRegion
block|{
name|friend
name|class
name|MemRegionManager
block|;
comment|// Data.
specifier|const
name|LocationContext
operator|*
name|LC
block|;
comment|// Constructors and private methods.
name|VarRegion
argument_list|(
specifier|const
name|VarDecl
operator|*
name|vd
argument_list|,
specifier|const
name|LocationContext
operator|*
name|lC
argument_list|,
specifier|const
name|MemRegion
operator|*
name|sReg
argument_list|)
operator|:
name|DeclRegion
argument_list|(
name|vd
argument_list|,
name|sReg
argument_list|,
name|VarRegionKind
argument_list|)
block|,
name|LC
argument_list|(
argument|lC
argument_list|)
block|{}
specifier|static
name|void
name|ProfileRegion
argument_list|(
argument|llvm::FoldingSetNodeID& ID
argument_list|,
argument|const VarDecl* VD
argument_list|,
argument|const LocationContext *LC
argument_list|,
argument|const MemRegion *superRegion
argument_list|)
block|{
name|DeclRegion
operator|::
name|ProfileRegion
argument_list|(
name|ID
argument_list|,
name|VD
argument_list|,
name|superRegion
argument_list|,
name|VarRegionKind
argument_list|)
block|;
name|ID
operator|.
name|AddPointer
argument_list|(
name|LC
argument_list|)
block|;   }
name|void
name|Profile
argument_list|(
argument|llvm::FoldingSetNodeID& ID
argument_list|)
specifier|const
block|;
name|public
operator|:
specifier|const
name|VarDecl
operator|*
name|getDecl
argument_list|()
specifier|const
block|{
return|return
name|cast
operator|<
name|VarDecl
operator|>
operator|(
name|D
operator|)
return|;
block|}
specifier|const
name|LocationContext
operator|*
name|getLocationContext
argument_list|()
specifier|const
block|{
return|return
name|LC
return|;
block|}
name|QualType
name|getValueType
argument_list|(
argument|ASTContext& C
argument_list|)
specifier|const
block|{
comment|// FIXME: We can cache this if needed.
return|return
name|C
operator|.
name|getCanonicalType
argument_list|(
name|getDecl
argument_list|()
operator|->
name|getType
argument_list|()
argument_list|)
return|;
block|}
name|void
name|dumpToStream
argument_list|(
argument|llvm::raw_ostream& os
argument_list|)
specifier|const
block|;
specifier|static
name|bool
name|classof
argument_list|(
argument|const MemRegion* R
argument_list|)
block|{
return|return
name|R
operator|->
name|getKind
argument_list|()
operator|==
name|VarRegionKind
return|;
block|}
expr|}
block|;
name|class
name|FieldRegion
operator|:
name|public
name|DeclRegion
block|{
name|friend
name|class
name|MemRegionManager
block|;
name|FieldRegion
argument_list|(
specifier|const
name|FieldDecl
operator|*
name|fd
argument_list|,
specifier|const
name|MemRegion
operator|*
name|sReg
argument_list|)
operator|:
name|DeclRegion
argument_list|(
argument|fd
argument_list|,
argument|sReg
argument_list|,
argument|FieldRegionKind
argument_list|)
block|{}
name|public
operator|:
name|void
name|dumpToStream
argument_list|(
argument|llvm::raw_ostream& os
argument_list|)
specifier|const
block|;
specifier|const
name|FieldDecl
operator|*
name|getDecl
argument_list|()
specifier|const
block|{
return|return
name|cast
operator|<
name|FieldDecl
operator|>
operator|(
name|D
operator|)
return|;
block|}
name|QualType
name|getValueType
argument_list|(
argument|ASTContext& C
argument_list|)
specifier|const
block|{
comment|// FIXME: We can cache this if needed.
return|return
name|C
operator|.
name|getCanonicalType
argument_list|(
name|getDecl
argument_list|()
operator|->
name|getType
argument_list|()
argument_list|)
return|;
block|}
specifier|static
name|void
name|ProfileRegion
argument_list|(
argument|llvm::FoldingSetNodeID& ID
argument_list|,
argument|const FieldDecl* FD
argument_list|,
argument|const MemRegion* superRegion
argument_list|)
block|{
name|DeclRegion
operator|::
name|ProfileRegion
argument_list|(
name|ID
argument_list|,
name|FD
argument_list|,
name|superRegion
argument_list|,
name|FieldRegionKind
argument_list|)
block|;   }
specifier|static
name|bool
name|classof
argument_list|(
argument|const MemRegion* R
argument_list|)
block|{
return|return
name|R
operator|->
name|getKind
argument_list|()
operator|==
name|FieldRegionKind
return|;
block|}
expr|}
block|;
name|class
name|ObjCObjectRegion
operator|:
name|public
name|DeclRegion
block|{
name|friend
name|class
name|MemRegionManager
block|;
name|ObjCObjectRegion
argument_list|(
specifier|const
name|ObjCInterfaceDecl
operator|*
name|ivd
argument_list|,
specifier|const
name|MemRegion
operator|*
name|sReg
argument_list|)
operator|:
name|DeclRegion
argument_list|(
argument|ivd
argument_list|,
argument|sReg
argument_list|,
argument|ObjCObjectRegionKind
argument_list|)
block|{}
specifier|static
name|void
name|ProfileRegion
argument_list|(
argument|llvm::FoldingSetNodeID& ID
argument_list|,
argument|const ObjCInterfaceDecl* ivd
argument_list|,
argument|const MemRegion* superRegion
argument_list|)
block|{
name|DeclRegion
operator|::
name|ProfileRegion
argument_list|(
name|ID
argument_list|,
name|ivd
argument_list|,
name|superRegion
argument_list|,
name|ObjCObjectRegionKind
argument_list|)
block|;   }
name|public
operator|:
specifier|const
name|ObjCInterfaceDecl
operator|*
name|getInterface
argument_list|()
specifier|const
block|{
return|return
name|cast
operator|<
name|ObjCInterfaceDecl
operator|>
operator|(
name|D
operator|)
return|;
block|}
name|QualType
name|getValueType
argument_list|(
argument|ASTContext& C
argument_list|)
specifier|const
block|{
return|return
name|C
operator|.
name|getObjCInterfaceType
argument_list|(
name|getInterface
argument_list|()
argument_list|)
return|;
block|}
specifier|static
name|bool
name|classof
argument_list|(
argument|const MemRegion* R
argument_list|)
block|{
return|return
name|R
operator|->
name|getKind
argument_list|()
operator|==
name|ObjCObjectRegionKind
return|;
block|}
expr|}
block|;
name|class
name|ObjCIvarRegion
operator|:
name|public
name|DeclRegion
block|{
name|friend
name|class
name|MemRegionManager
block|;
name|ObjCIvarRegion
argument_list|(
specifier|const
name|ObjCIvarDecl
operator|*
name|ivd
argument_list|,
specifier|const
name|MemRegion
operator|*
name|sReg
argument_list|)
operator|:
name|DeclRegion
argument_list|(
argument|ivd
argument_list|,
argument|sReg
argument_list|,
argument|ObjCIvarRegionKind
argument_list|)
block|{}
specifier|static
name|void
name|ProfileRegion
argument_list|(
argument|llvm::FoldingSetNodeID& ID
argument_list|,
argument|const ObjCIvarDecl* ivd
argument_list|,
argument|const MemRegion* superRegion
argument_list|)
block|{
name|DeclRegion
operator|::
name|ProfileRegion
argument_list|(
name|ID
argument_list|,
name|ivd
argument_list|,
name|superRegion
argument_list|,
name|ObjCIvarRegionKind
argument_list|)
block|;   }
name|public
operator|:
specifier|const
name|ObjCIvarDecl
operator|*
name|getDecl
argument_list|()
specifier|const
block|{
return|return
name|cast
operator|<
name|ObjCIvarDecl
operator|>
operator|(
name|D
operator|)
return|;
block|}
name|QualType
name|getValueType
argument_list|(
argument|ASTContext&
argument_list|)
specifier|const
block|{
return|return
name|getDecl
argument_list|()
operator|->
name|getType
argument_list|()
return|;
block|}
name|void
name|dumpToStream
argument_list|(
argument|llvm::raw_ostream& os
argument_list|)
specifier|const
block|;
specifier|static
name|bool
name|classof
argument_list|(
argument|const MemRegion* R
argument_list|)
block|{
return|return
name|R
operator|->
name|getKind
argument_list|()
operator|==
name|ObjCIvarRegionKind
return|;
block|}
expr|}
block|;
name|class
name|ElementRegion
operator|:
name|public
name|TypedRegion
block|{
name|friend
name|class
name|MemRegionManager
block|;
name|QualType
name|ElementType
block|;
name|SVal
name|Index
block|;
name|ElementRegion
argument_list|(
argument|QualType elementType
argument_list|,
argument|SVal Idx
argument_list|,
argument|const MemRegion* sReg
argument_list|)
operator|:
name|TypedRegion
argument_list|(
name|sReg
argument_list|,
name|ElementRegionKind
argument_list|)
block|,
name|ElementType
argument_list|(
name|elementType
argument_list|)
block|,
name|Index
argument_list|(
argument|Idx
argument_list|)
block|{
name|assert
argument_list|(
operator|(
operator|!
name|isa
operator|<
name|nonloc
operator|::
name|ConcreteInt
operator|>
operator|(
operator|&
name|Idx
operator|)
operator|||
name|cast
operator|<
name|nonloc
operator|::
name|ConcreteInt
operator|>
operator|(
operator|&
name|Idx
operator|)
operator|->
name|getValue
argument_list|()
operator|.
name|isSigned
argument_list|()
operator|)
operator|&&
literal|"The index must be signed"
argument_list|)
block|;   }
specifier|static
name|void
name|ProfileRegion
argument_list|(
argument|llvm::FoldingSetNodeID& ID
argument_list|,
argument|QualType elementType
argument_list|,
argument|SVal Idx
argument_list|,
argument|const MemRegion* superRegion
argument_list|)
block|;
name|public
operator|:
name|SVal
name|getIndex
argument_list|()
specifier|const
block|{
return|return
name|Index
return|;
block|}
name|QualType
name|getValueType
argument_list|(
argument|ASTContext&
argument_list|)
specifier|const
block|{
return|return
name|ElementType
return|;
block|}
name|QualType
name|getElementType
argument_list|()
specifier|const
block|{
return|return
name|ElementType
return|;
block|}
name|RegionRawOffset
name|getAsRawOffset
argument_list|()
specifier|const
block|;
name|void
name|dumpToStream
argument_list|(
argument|llvm::raw_ostream& os
argument_list|)
specifier|const
block|;
name|void
name|Profile
argument_list|(
argument|llvm::FoldingSetNodeID& ID
argument_list|)
specifier|const
block|;
specifier|static
name|bool
name|classof
argument_list|(
argument|const MemRegion* R
argument_list|)
block|{
return|return
name|R
operator|->
name|getKind
argument_list|()
operator|==
name|ElementRegionKind
return|;
block|}
expr|}
block|;
name|template
operator|<
name|typename
name|RegionTy
operator|>
specifier|const
name|RegionTy
operator|*
name|MemRegion
operator|::
name|getAs
argument_list|()
specifier|const
block|{
if|if
condition|(
specifier|const
name|RegionTy
modifier|*
name|RT
init|=
name|dyn_cast
operator|<
name|RegionTy
operator|>
operator|(
name|this
operator|)
condition|)
return|return
name|RT
return|;
return|return
name|NULL
return|;
block|}
comment|//===----------------------------------------------------------------------===//
comment|// MemRegionManager - Factory object for creating regions.
comment|//===----------------------------------------------------------------------===//
name|class
name|MemRegionManager
block|{
name|ASTContext
operator|&
name|C
block|;
name|llvm
operator|::
name|BumpPtrAllocator
operator|&
name|A
block|;
name|llvm
operator|::
name|FoldingSet
operator|<
name|MemRegion
operator|>
name|Regions
block|;
name|MemSpaceRegion
operator|*
name|globals
block|;
name|MemSpaceRegion
operator|*
name|stack
block|;
name|MemSpaceRegion
operator|*
name|stackArguments
block|;
name|MemSpaceRegion
operator|*
name|heap
block|;
name|MemSpaceRegion
operator|*
name|unknown
block|;
name|MemSpaceRegion
operator|*
name|code
block|;
name|public
operator|:
name|MemRegionManager
argument_list|(
name|ASTContext
operator|&
name|c
argument_list|,
name|llvm
operator|::
name|BumpPtrAllocator
operator|&
name|a
argument_list|)
operator|:
name|C
argument_list|(
name|c
argument_list|)
block|,
name|A
argument_list|(
name|a
argument_list|)
block|,
name|globals
argument_list|(
literal|0
argument_list|)
block|,
name|stack
argument_list|(
literal|0
argument_list|)
block|,
name|stackArguments
argument_list|(
literal|0
argument_list|)
block|,
name|heap
argument_list|(
literal|0
argument_list|)
block|,
name|unknown
argument_list|(
literal|0
argument_list|)
block|,
name|code
argument_list|(
literal|0
argument_list|)
block|{}
operator|~
name|MemRegionManager
argument_list|()
block|{}
name|ASTContext
operator|&
name|getContext
argument_list|()
block|{
return|return
name|C
return|;
block|}
comment|/// getStackRegion - Retrieve the memory region associated with the
comment|///  current stack frame.
name|MemSpaceRegion
operator|*
name|getStackRegion
argument_list|()
block|;
comment|/// getStackArgumentsRegion - Retrieve the memory region associated with
comment|///  function/method arguments of the current stack frame.
name|MemSpaceRegion
operator|*
name|getStackArgumentsRegion
argument_list|()
block|;
comment|/// getGlobalsRegion - Retrieve the memory region associated with
comment|///  all global variables.
name|MemSpaceRegion
operator|*
name|getGlobalsRegion
argument_list|()
block|;
comment|/// getHeapRegion - Retrieve the memory region associated with the
comment|///  generic "heap".
name|MemSpaceRegion
operator|*
name|getHeapRegion
argument_list|()
block|;
comment|/// getUnknownRegion - Retrieve the memory region associated with unknown
comment|/// memory space.
name|MemSpaceRegion
operator|*
name|getUnknownRegion
argument_list|()
block|;
name|MemSpaceRegion
operator|*
name|getCodeRegion
argument_list|()
block|;
comment|/// getAllocaRegion - Retrieve a region associated with a call to alloca().
name|AllocaRegion
operator|*
name|getAllocaRegion
argument_list|(
argument|const Expr* Ex
argument_list|,
argument|unsigned Cnt
argument_list|)
block|;
comment|/// getCompoundLiteralRegion - Retrieve the region associated with a
comment|///  given CompoundLiteral.
name|CompoundLiteralRegion
operator|*
name|getCompoundLiteralRegion
argument_list|(
specifier|const
name|CompoundLiteralExpr
operator|*
name|CL
argument_list|)
block|;
comment|/// getSymbolicRegion - Retrieve or create a "symbolic" memory region.
name|SymbolicRegion
operator|*
name|getSymbolicRegion
argument_list|(
argument|SymbolRef sym
argument_list|)
block|;
name|StringRegion
operator|*
name|getStringRegion
argument_list|(
specifier|const
name|StringLiteral
operator|*
name|Str
argument_list|)
block|;
comment|/// getVarRegion - Retrieve or create the memory region associated with
comment|///  a specified VarDecl and LocationContext.
name|VarRegion
operator|*
name|getVarRegion
argument_list|(
specifier|const
name|VarDecl
operator|*
name|D
argument_list|,
specifier|const
name|LocationContext
operator|*
name|LC
argument_list|)
block|;
comment|/// getElementRegion - Retrieve the memory region associated with the
comment|///  associated element type, index, and super region.
name|ElementRegion
operator|*
name|getElementRegion
argument_list|(
argument|QualType elementType
argument_list|,
argument|SVal Idx
argument_list|,
argument|const MemRegion *superRegion
argument_list|,
argument|ASTContext&Ctx
argument_list|)
block|;
name|ElementRegion
operator|*
name|getElementRegionWithSuper
argument_list|(
argument|const ElementRegion *ER
argument_list|,
argument|const MemRegion *superRegion
argument_list|)
block|{
return|return
name|getElementRegion
argument_list|(
name|ER
operator|->
name|getElementType
argument_list|()
argument_list|,
name|ER
operator|->
name|getIndex
argument_list|()
argument_list|,
name|superRegion
argument_list|,
name|ER
operator|->
name|getContext
argument_list|()
argument_list|)
return|;
block|}
comment|/// getFieldRegion - Retrieve or create the memory region associated with
comment|///  a specified FieldDecl.  'superRegion' corresponds to the containing
comment|///  memory region (which typically represents the memory representing
comment|///  a structure or class).
name|FieldRegion
operator|*
name|getFieldRegion
argument_list|(
specifier|const
name|FieldDecl
operator|*
name|fd
argument_list|,
specifier|const
name|MemRegion
operator|*
name|superRegion
argument_list|)
block|;
name|FieldRegion
operator|*
name|getFieldRegionWithSuper
argument_list|(
argument|const FieldRegion *FR
argument_list|,
argument|const MemRegion *superRegion
argument_list|)
block|{
return|return
name|getFieldRegion
argument_list|(
name|FR
operator|->
name|getDecl
argument_list|()
argument_list|,
name|superRegion
argument_list|)
return|;
block|}
comment|/// getObjCObjectRegion - Retrieve or create the memory region associated with
comment|///  the instance of a specified Objective-C class.
name|ObjCObjectRegion
operator|*
name|getObjCObjectRegion
argument_list|(
specifier|const
name|ObjCInterfaceDecl
operator|*
name|ID
argument_list|,
specifier|const
name|MemRegion
operator|*
name|superRegion
argument_list|)
block|;
comment|/// getObjCIvarRegion - Retrieve or create the memory region associated with
comment|///   a specified Objective-c instance variable.  'superRegion' corresponds
comment|///   to the containing region (which typically represents the Objective-C
comment|///   object).
name|ObjCIvarRegion
operator|*
name|getObjCIvarRegion
argument_list|(
specifier|const
name|ObjCIvarDecl
operator|*
name|ivd
argument_list|,
specifier|const
name|MemRegion
operator|*
name|superRegion
argument_list|)
block|;
name|CodeTextRegion
operator|*
name|getCodeTextRegion
argument_list|(
specifier|const
name|FunctionDecl
operator|*
name|FD
argument_list|)
block|;
name|template
operator|<
name|typename
name|RegionTy
block|,
name|typename
name|A1
operator|>
name|RegionTy
operator|*
name|getRegion
argument_list|(
argument|const A1 a1
argument_list|)
block|;
name|template
operator|<
name|typename
name|RegionTy
block|,
name|typename
name|A1
operator|>
name|RegionTy
operator|*
name|getSubRegion
argument_list|(
argument|const A1 a1
argument_list|,
argument|const MemRegion* superRegion
argument_list|)
block|;
name|template
operator|<
name|typename
name|RegionTy
block|,
name|typename
name|A1
block|,
name|typename
name|A2
operator|>
name|RegionTy
operator|*
name|getRegion
argument_list|(
argument|const A1 a1
argument_list|,
argument|const A2 a2
argument_list|)
block|;
name|bool
name|isGlobalsRegion
argument_list|(
argument|const MemRegion* R
argument_list|)
block|{
name|assert
argument_list|(
name|R
argument_list|)
block|;
return|return
name|R
operator|==
name|globals
return|;
block|}
name|private
operator|:
name|MemSpaceRegion
operator|*
name|LazyAllocate
argument_list|(
name|MemSpaceRegion
operator|*
operator|&
name|region
argument_list|)
block|; }
block|;
comment|//===----------------------------------------------------------------------===//
comment|// Out-of-line member definitions.
comment|//===----------------------------------------------------------------------===//
specifier|inline
name|ASTContext
operator|&
name|MemRegion
operator|::
name|getContext
argument_list|()
specifier|const
block|{
return|return
name|getMemRegionManager
argument_list|()
operator|->
name|getContext
argument_list|()
return|;
block|}
name|template
operator|<
name|typename
name|RegionTy
operator|>
expr|struct
name|MemRegionManagerTrait
block|;
name|template
operator|<
name|typename
name|RegionTy
block|,
name|typename
name|A1
operator|>
name|RegionTy
operator|*
name|MemRegionManager
operator|::
name|getRegion
argument_list|(
argument|const A1 a1
argument_list|)
block|{
specifier|const
name|typename
name|MemRegionManagerTrait
operator|<
name|RegionTy
operator|>
operator|::
name|SuperRegionTy
operator|*
name|superRegion
operator|=
name|MemRegionManagerTrait
operator|<
name|RegionTy
operator|>
operator|::
name|getSuperRegion
argument_list|(
operator|*
name|this
argument_list|,
name|a1
argument_list|)
block|;
name|llvm
operator|::
name|FoldingSetNodeID
name|ID
block|;
name|RegionTy
operator|::
name|ProfileRegion
argument_list|(
name|ID
argument_list|,
name|a1
argument_list|,
name|superRegion
argument_list|)
block|;
name|void
operator|*
name|InsertPos
block|;
name|RegionTy
operator|*
name|R
operator|=
name|cast_or_null
operator|<
name|RegionTy
operator|>
operator|(
name|Regions
operator|.
name|FindNodeOrInsertPos
argument_list|(
name|ID
argument_list|,
name|InsertPos
argument_list|)
operator|)
block|;
if|if
condition|(
operator|!
name|R
condition|)
block|{
name|R
operator|=
operator|(
name|RegionTy
operator|*
operator|)
name|A
operator|.
name|Allocate
operator|<
name|RegionTy
operator|>
operator|(
operator|)
expr_stmt|;
name|new
argument_list|(
argument|R
argument_list|)
name|RegionTy
argument_list|(
name|a1
argument_list|,
name|superRegion
argument_list|)
expr_stmt|;
name|Regions
operator|.
name|InsertNode
argument_list|(
name|R
argument_list|,
name|InsertPos
argument_list|)
expr_stmt|;
block|}
return|return
name|R
return|;
block|}
name|template
operator|<
name|typename
name|RegionTy
block|,
name|typename
name|A1
operator|>
name|RegionTy
operator|*
name|MemRegionManager
operator|::
name|getSubRegion
argument_list|(
argument|const A1 a1
argument_list|,
argument|const MemRegion *superRegion
argument_list|)
block|{
name|llvm
operator|::
name|FoldingSetNodeID
name|ID
block|;
name|RegionTy
operator|::
name|ProfileRegion
argument_list|(
name|ID
argument_list|,
name|a1
argument_list|,
name|superRegion
argument_list|)
block|;
name|void
operator|*
name|InsertPos
block|;
name|RegionTy
operator|*
name|R
operator|=
name|cast_or_null
operator|<
name|RegionTy
operator|>
operator|(
name|Regions
operator|.
name|FindNodeOrInsertPos
argument_list|(
name|ID
argument_list|,
name|InsertPos
argument_list|)
operator|)
block|;
if|if
condition|(
operator|!
name|R
condition|)
block|{
name|R
operator|=
operator|(
name|RegionTy
operator|*
operator|)
name|A
operator|.
name|Allocate
operator|<
name|RegionTy
operator|>
operator|(
operator|)
expr_stmt|;
name|new
argument_list|(
argument|R
argument_list|)
name|RegionTy
argument_list|(
name|a1
argument_list|,
name|superRegion
argument_list|)
expr_stmt|;
name|Regions
operator|.
name|InsertNode
argument_list|(
name|R
argument_list|,
name|InsertPos
argument_list|)
expr_stmt|;
block|}
return|return
name|R
return|;
block|}
name|template
operator|<
name|typename
name|RegionTy
block|,
name|typename
name|A1
block|,
name|typename
name|A2
operator|>
name|RegionTy
operator|*
name|MemRegionManager
operator|::
name|getRegion
argument_list|(
argument|const A1 a1
argument_list|,
argument|const A2 a2
argument_list|)
block|{
specifier|const
name|typename
name|MemRegionManagerTrait
operator|<
name|RegionTy
operator|>
operator|::
name|SuperRegionTy
operator|*
name|superRegion
operator|=
name|MemRegionManagerTrait
operator|<
name|RegionTy
operator|>
operator|::
name|getSuperRegion
argument_list|(
operator|*
name|this
argument_list|,
name|a1
argument_list|,
name|a2
argument_list|)
block|;
name|llvm
operator|::
name|FoldingSetNodeID
name|ID
block|;
name|RegionTy
operator|::
name|ProfileRegion
argument_list|(
name|ID
argument_list|,
name|a1
argument_list|,
name|a2
argument_list|,
name|superRegion
argument_list|)
block|;
name|void
operator|*
name|InsertPos
block|;
name|RegionTy
operator|*
name|R
operator|=
name|cast_or_null
operator|<
name|RegionTy
operator|>
operator|(
name|Regions
operator|.
name|FindNodeOrInsertPos
argument_list|(
name|ID
argument_list|,
name|InsertPos
argument_list|)
operator|)
block|;
if|if
condition|(
operator|!
name|R
condition|)
block|{
name|R
operator|=
operator|(
name|RegionTy
operator|*
operator|)
name|A
operator|.
name|Allocate
operator|<
name|RegionTy
operator|>
operator|(
operator|)
expr_stmt|;
name|new
argument_list|(
argument|R
argument_list|)
name|RegionTy
argument_list|(
name|a1
argument_list|,
name|a2
argument_list|,
name|superRegion
argument_list|)
expr_stmt|;
name|Regions
operator|.
name|InsertNode
argument_list|(
name|R
argument_list|,
name|InsertPos
argument_list|)
expr_stmt|;
block|}
return|return
name|R
return|;
block|}
comment|//===----------------------------------------------------------------------===//
comment|// Traits for constructing regions.
comment|//===----------------------------------------------------------------------===//
name|template
operator|<
operator|>
expr|struct
name|MemRegionManagerTrait
operator|<
name|AllocaRegion
operator|>
block|{
typedef|typedef
name|MemRegion
name|SuperRegionTy
typedef|;
specifier|static
specifier|const
name|SuperRegionTy
operator|*
name|getSuperRegion
argument_list|(
argument|MemRegionManager& MRMgr
argument_list|,
argument|const Expr *
argument_list|,
argument|unsigned
argument_list|)
block|{
return|return
name|MRMgr
operator|.
name|getStackRegion
argument_list|()
return|;
block|}
expr|}
block|;
name|template
operator|<
operator|>
expr|struct
name|MemRegionManagerTrait
operator|<
name|CompoundLiteralRegion
operator|>
block|{
typedef|typedef
name|MemRegion
name|SuperRegionTy
typedef|;
specifier|static
specifier|const
name|SuperRegionTy
operator|*
name|getSuperRegion
argument_list|(
argument|MemRegionManager& MRMgr
argument_list|,
argument|const CompoundLiteralExpr *CL
argument_list|)
block|{
return|return
name|CL
operator|->
name|isFileScope
argument_list|()
operator|?
name|MRMgr
operator|.
name|getGlobalsRegion
argument_list|()
operator|:
name|MRMgr
operator|.
name|getStackRegion
argument_list|()
return|;
block|}
expr|}
block|;
name|template
operator|<
operator|>
expr|struct
name|MemRegionManagerTrait
operator|<
name|StringRegion
operator|>
block|{
typedef|typedef
name|MemSpaceRegion
name|SuperRegionTy
typedef|;
specifier|static
specifier|const
name|SuperRegionTy
operator|*
name|getSuperRegion
argument_list|(
argument|MemRegionManager& MRMgr
argument_list|,
argument|const StringLiteral*
argument_list|)
block|{
return|return
name|MRMgr
operator|.
name|getGlobalsRegion
argument_list|()
return|;
block|}
expr|}
block|;
name|template
operator|<
operator|>
expr|struct
name|MemRegionManagerTrait
operator|<
name|VarRegion
operator|>
block|{
typedef|typedef
name|MemRegion
name|SuperRegionTy
typedef|;
specifier|static
specifier|const
name|SuperRegionTy
operator|*
name|getSuperRegion
argument_list|(
argument|MemRegionManager&MRMgr
argument_list|,
argument|const VarDecl *D
argument_list|,
argument|const LocationContext *LC
argument_list|)
block|{
comment|// FIXME: Make stack regions have a location context?
if|if
condition|(
name|D
operator|->
name|hasLocalStorage
argument_list|()
condition|)
block|{
return|return
name|isa
operator|<
name|ParmVarDecl
operator|>
operator|(
name|D
operator|)
operator|||
name|isa
operator|<
name|ImplicitParamDecl
operator|>
operator|(
name|D
operator|)
condition|?
name|MRMgr
operator|.
name|getStackArgumentsRegion
argument_list|()
else|:
name|MRMgr
operator|.
name|getStackRegion
argument_list|()
return|;
block|}
return|return
name|MRMgr
operator|.
name|getGlobalsRegion
argument_list|()
return|;
block|}
expr|}
block|;
name|template
operator|<
operator|>
expr|struct
name|MemRegionManagerTrait
operator|<
name|SymbolicRegion
operator|>
block|{
typedef|typedef
name|MemRegion
name|SuperRegionTy
typedef|;
specifier|static
specifier|const
name|SuperRegionTy
operator|*
name|getSuperRegion
argument_list|(
argument|MemRegionManager& MRMgr
argument_list|,
argument|SymbolRef
argument_list|)
block|{
return|return
name|MRMgr
operator|.
name|getUnknownRegion
argument_list|()
return|;
block|}
expr|}
block|;
name|template
operator|<
operator|>
expr|struct
name|MemRegionManagerTrait
operator|<
name|CodeTextRegion
operator|>
block|{
typedef|typedef
name|MemSpaceRegion
name|SuperRegionTy
typedef|;
specifier|static
specifier|const
name|SuperRegionTy
operator|*
name|getSuperRegion
argument_list|(
argument|MemRegionManager& MRMgr
argument_list|,
argument|const FunctionDecl*
argument_list|)
block|{
return|return
name|MRMgr
operator|.
name|getCodeRegion
argument_list|()
return|;
block|}
specifier|static
specifier|const
name|SuperRegionTy
operator|*
name|getSuperRegion
argument_list|(
argument|MemRegionManager& MRMgr
argument_list|,
argument|SymbolRef
argument_list|,
argument|QualType
argument_list|)
block|{
return|return
name|MRMgr
operator|.
name|getCodeRegion
argument_list|()
return|;
block|}
expr|}
block|;  }
comment|// end clang namespace
comment|//===----------------------------------------------------------------------===//
comment|// Pretty-printing regions.
comment|//===----------------------------------------------------------------------===//
name|namespace
name|llvm
block|{
specifier|static
specifier|inline
name|raw_ostream
operator|&
name|operator
operator|<<
operator|(
name|raw_ostream
operator|&
name|os
expr|,
specifier|const
name|clang
operator|::
name|MemRegion
operator|*
name|R
operator|)
block|{
name|R
operator|->
name|dumpToStream
argument_list|(
name|os
argument_list|)
block|;
return|return
name|os
return|;
block|}
expr|}
end_decl_stmt

begin_comment
comment|// end llvm namespace
end_comment

begin_endif
endif|#
directive|endif
end_endif

end_unit

