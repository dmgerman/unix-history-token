begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===--- ASTMatchers.h - Structural query framework -------------*- C++ -*-===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//  This file implements matchers to be used together with the MatchFinder to
end_comment

begin_comment
comment|//  match AST nodes.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//  Matchers are created by generator functions, which can be combined in
end_comment

begin_comment
comment|//  a functional in-language DSL to express queries over the C++ AST.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//  For example, to match a class with a certain name, one would call:
end_comment

begin_comment
comment|//    record(hasName("MyClass"))
end_comment

begin_comment
comment|//  which returns a matcher that can be used to find all AST nodes that declare
end_comment

begin_comment
comment|//  a class named 'MyClass'.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//  For more complicated match expressions we're often interested in accessing
end_comment

begin_comment
comment|//  multiple parts of the matched AST nodes once a match is found. In that case,
end_comment

begin_comment
comment|//  use the id(...) matcher around the match expressions that match the nodes
end_comment

begin_comment
comment|//  you want to access.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//  For example, when we're interested in child classes of a certain class, we
end_comment

begin_comment
comment|//  would write:
end_comment

begin_comment
comment|//    record(hasName("MyClass"), hasChild(id("child", record())))
end_comment

begin_comment
comment|//  When the match is found via the MatchFinder, a user provided callback will
end_comment

begin_comment
comment|//  be called with a BoundNodes instance that contains a mapping from the
end_comment

begin_comment
comment|//  strings that we provided for the id(...) calls to the nodes that were
end_comment

begin_comment
comment|//  matched.
end_comment

begin_comment
comment|//  In the given example, each time our matcher finds a match we get a callback
end_comment

begin_comment
comment|//  where "child" is bound to the CXXRecordDecl node of the matching child
end_comment

begin_comment
comment|//  class declaration.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//  See ASTMatchersInternal.h for a more in-depth explanation of the
end_comment

begin_comment
comment|//  implementation details of the matcher framework.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//  See ASTMatchFinder.h for how to use the generated matchers to run over
end_comment

begin_comment
comment|//  an AST.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LLVM_CLANG_AST_MATCHERS_AST_MATCHERS_H
end_ifndef

begin_define
define|#
directive|define
name|LLVM_CLANG_AST_MATCHERS_AST_MATCHERS_H
end_define

begin_include
include|#
directive|include
file|"clang/AST/DeclTemplate.h"
end_include

begin_include
include|#
directive|include
file|"clang/ASTMatchers/ASTMatchersInternal.h"
end_include

begin_include
include|#
directive|include
file|"clang/ASTMatchers/ASTMatchersMacros.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/Twine.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/Regex.h"
end_include

begin_decl_stmt
name|namespace
name|clang
block|{
name|namespace
name|ast_matchers
block|{
comment|/// \brief Maps string IDs to AST nodes matched by parts of a matcher.
comment|///
comment|/// The bound nodes are generated by adding id(...) matchers into the
comment|/// match expression around the matchers for the nodes we want to access later.
comment|///
comment|/// The instances of BoundNodes are created by MatchFinder when the user's
comment|/// callbacks are executed every time a match is found.
name|class
name|BoundNodes
block|{
name|public
label|:
comment|/// \brief Returns the AST node bound to 'ID'.
comment|/// Returns NULL if there was no node bound to 'ID' or if there is a node but
comment|/// it cannot be converted to the specified type.
comment|/// FIXME: We'll need one of those for every base type.
comment|/// @{
name|template
operator|<
name|typename
name|T
operator|>
specifier|const
name|T
operator|*
name|getDeclAs
argument_list|(
argument|StringRef ID
argument_list|)
specifier|const
block|{
return|return
name|getNodeAs
operator|<
name|T
operator|>
operator|(
name|DeclBindings
operator|,
name|ID
operator|)
return|;
block|}
name|template
operator|<
name|typename
name|T
operator|>
specifier|const
name|T
operator|*
name|getStmtAs
argument_list|(
argument|StringRef ID
argument_list|)
specifier|const
block|{
return|return
name|getNodeAs
operator|<
name|T
operator|>
operator|(
name|StmtBindings
operator|,
name|ID
operator|)
return|;
block|}
comment|/// @}
name|private
label|:
comment|/// \brief Create BoundNodes from a pre-filled map of bindings.
name|BoundNodes
argument_list|(
specifier|const
name|std
operator|::
name|map
operator|<
name|std
operator|::
name|string
argument_list|,
specifier|const
name|Decl
operator|*
operator|>
operator|&
name|DeclBindings
argument_list|,
specifier|const
name|std
operator|::
name|map
operator|<
name|std
operator|::
name|string
argument_list|,
specifier|const
name|Stmt
operator|*
operator|>
operator|&
name|StmtBindings
argument_list|)
operator|:
name|DeclBindings
argument_list|(
name|DeclBindings
argument_list|)
operator|,
name|StmtBindings
argument_list|(
argument|StmtBindings
argument_list|)
block|{}
name|template
operator|<
name|typename
name|T
operator|,
name|typename
name|MapT
operator|>
specifier|const
name|T
operator|*
name|getNodeAs
argument_list|(
argument|const MapT&Bindings
argument_list|,
argument|StringRef ID
argument_list|)
specifier|const
block|{
name|typename
name|MapT
operator|::
name|const_iterator
name|It
operator|=
name|Bindings
operator|.
name|find
argument_list|(
name|ID
argument_list|)
block|;
if|if
condition|(
name|It
operator|==
name|Bindings
operator|.
name|end
argument_list|()
condition|)
block|{
return|return
name|NULL
return|;
block|}
return|return
name|llvm
operator|::
name|dyn_cast
operator|<
name|T
operator|>
operator|(
name|It
operator|->
name|second
operator|)
return|;
block|}
name|std
operator|::
name|map
operator|<
name|std
operator|::
name|string
operator|,
specifier|const
name|Decl
operator|*
operator|>
name|DeclBindings
expr_stmt|;
name|std
operator|::
name|map
operator|<
name|std
operator|::
name|string
operator|,
specifier|const
name|Stmt
operator|*
operator|>
name|StmtBindings
expr_stmt|;
name|friend
name|class
name|internal
operator|::
name|BoundNodesTree
expr_stmt|;
block|}
empty_stmt|;
comment|/// \brief If the provided matcher matches a node, binds the node to 'ID'.
comment|///
comment|/// FIXME: Add example for accessing it.
name|template
operator|<
name|typename
name|T
operator|>
name|internal
operator|::
name|Matcher
operator|<
name|T
operator|>
name|id
argument_list|(
argument|const std::string&ID
argument_list|,
argument|const internal::BindableMatcher<T>&InnerMatcher
argument_list|)
block|{
return|return
name|InnerMatcher
operator|.
name|bind
argument_list|(
name|ID
argument_list|)
return|;
block|}
comment|/// \brief Types of matchers for the top-level classes in the AST class
comment|/// hierarchy.
comment|/// @{
typedef|typedef
name|internal
operator|::
name|Matcher
operator|<
name|Decl
operator|>
name|DeclarationMatcher
expr_stmt|;
typedef|typedef
name|internal
operator|::
name|Matcher
operator|<
name|QualType
operator|>
name|TypeMatcher
expr_stmt|;
typedef|typedef
name|internal
operator|::
name|Matcher
operator|<
name|Stmt
operator|>
name|StatementMatcher
expr_stmt|;
comment|/// @}
comment|/// \brief Matches any node.
comment|///
comment|/// Useful when another matcher requires a child matcher, but there's no
comment|/// additional constraint. This will often be used with an explicit conversion
comment|/// to a internal::Matcher<> type such as TypeMatcher.
comment|///
comment|/// Example: DeclarationMatcher(anything()) matches all declarations, e.g.,
comment|/// "int* p" and "void f()" in
comment|///   int* p;
comment|///   void f();
specifier|inline
name|internal
operator|::
name|PolymorphicMatcherWithParam0
operator|<
name|internal
operator|::
name|TrueMatcher
operator|>
name|anything
argument_list|()
block|{
return|return
name|internal
operator|::
name|PolymorphicMatcherWithParam0
operator|<
name|internal
operator|::
name|TrueMatcher
operator|>
operator|(
operator|)
return|;
block|}
comment|/// \brief Matches declarations.
comment|///
comment|/// Examples matches \c X, \c C, and the friend declaration inside \c C;
comment|/// \code
comment|///   void X();
comment|///   class C {
comment|///     friend X;
comment|///   };
comment|/// \endcode
specifier|const
name|internal
operator|::
name|VariadicDynCastAllOfMatcher
operator|<
name|Decl
operator|,
name|Decl
operator|>
name|decl
expr_stmt|;
comment|/// \brief Matches a declaration of anything that could have a name.
comment|///
comment|/// Example matches X, S, the anonymous union type, i, and U;
comment|///   typedef int X;
comment|///   struct S {
comment|///     union {
comment|///       int i;
comment|///     } U;
comment|///   };
specifier|const
name|internal
operator|::
name|VariadicDynCastAllOfMatcher
operator|<
name|Decl
operator|,
name|NamedDecl
operator|>
name|nameableDeclaration
expr_stmt|;
comment|/// \brief Matches C++ class declarations.
comment|///
comment|/// Example matches X, Z
comment|///   class X;
comment|///   template<class T> class Z {};
specifier|const
name|internal
operator|::
name|VariadicDynCastAllOfMatcher
operator|<
name|Decl
operator|,
name|CXXRecordDecl
operator|>
name|record
expr_stmt|;
comment|/// \brief Matches C++ class template specializations.
comment|///
comment|/// Given
comment|///   template<typename T> class A {};
comment|///   template<> class A<double> {};
comment|///   A<int> a;
comment|/// classTemplateSpecialization()
comment|///   matches the specializations \c A<int> and \c A<double>
specifier|const
name|internal
operator|::
name|VariadicDynCastAllOfMatcher
operator|<
name|Decl
operator|,
name|ClassTemplateSpecializationDecl
operator|>
name|classTemplateSpecialization
expr_stmt|;
comment|/// \brief Matches classTemplateSpecializations that have at least one
comment|/// TemplateArgument matching the given Matcher.
comment|///
comment|/// Given
comment|///   template<typename T> class A {};
comment|///   template<> class A<double> {};
comment|///   A<int> a;
comment|/// classTemplateSpecialization(hasAnyTemplateArgument(
comment|///     refersToType(asString("int"))))
comment|///   matches the specialization \c A<int>
name|AST_MATCHER_P
argument_list|(
argument|ClassTemplateSpecializationDecl
argument_list|,
argument|hasAnyTemplateArgument
argument_list|,
argument|internal::Matcher<TemplateArgument>
argument_list|,
argument|Matcher
argument_list|)
block|{
specifier|const
name|TemplateArgumentList
modifier|&
name|List
init|=
name|Node
operator|.
name|getTemplateArgs
argument_list|()
decl_stmt|;
for|for
control|(
name|unsigned
name|i
init|=
literal|0
init|;
name|i
operator|<
name|List
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|Matcher
operator|.
name|matches
argument_list|(
name|List
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|,
name|Finder
argument_list|,
name|Builder
argument_list|)
condition|)
return|return
name|true
return|;
block|}
return|return
name|false
return|;
block|}
comment|/// \brief Matches classTemplateSpecializations where the n'th TemplateArgument
comment|/// matches the given Matcher.
comment|///
comment|/// Given
comment|///   template<typename T, typename U> class A {};
comment|///   A<bool, int> b;
comment|///   A<int, bool> c;
comment|/// classTemplateSpecialization(hasTemplateArgument(
comment|///     1, refersToType(asString("int"))))
comment|///   matches the specialization \c A<bool, int>
name|AST_MATCHER_P2
argument_list|(
argument|ClassTemplateSpecializationDecl
argument_list|,
argument|hasTemplateArgument
argument_list|,
argument|unsigned
argument_list|,
argument|N
argument_list|,
argument|internal::Matcher<TemplateArgument>
argument_list|,
argument|Matcher
argument_list|)
block|{
specifier|const
name|TemplateArgumentList
modifier|&
name|List
init|=
name|Node
operator|.
name|getTemplateArgs
argument_list|()
decl_stmt|;
if|if
condition|(
name|List
operator|.
name|size
argument_list|()
operator|<=
name|N
condition|)
return|return
name|false
return|;
return|return
name|Matcher
operator|.
name|matches
argument_list|(
name|List
operator|.
name|get
argument_list|(
name|N
argument_list|)
argument_list|,
name|Finder
argument_list|,
name|Builder
argument_list|)
return|;
block|}
comment|/// \brief Matches a TemplateArgument that refers to a certain type.
comment|///
comment|/// Given
comment|///   struct X {};
comment|///   template<typename T> struct A {};
comment|///   A<X> a;
comment|/// classTemplateSpecialization(hasAnyTemplateArgument(
comment|///     refersToType(class(hasName("X")))))
comment|///   matches the specialization \c A<X>
name|AST_MATCHER_P
argument_list|(
argument|TemplateArgument
argument_list|,
argument|refersToType
argument_list|,
argument|internal::Matcher<QualType>
argument_list|,
argument|Matcher
argument_list|)
block|{
if|if
condition|(
name|Node
operator|.
name|getKind
argument_list|()
operator|!=
name|TemplateArgument
operator|::
name|Type
condition|)
return|return
name|false
return|;
return|return
name|Matcher
operator|.
name|matches
argument_list|(
name|Node
operator|.
name|getAsType
argument_list|()
argument_list|,
name|Finder
argument_list|,
name|Builder
argument_list|)
return|;
block|}
comment|/// \brief Matches a TemplateArgument that refers to a certain declaration.
comment|///
comment|/// Given
comment|///   template<typename T> struct A {};
comment|///   struct B { B* next; };
comment|///   A<&B::next> a;
comment|/// classTemplateSpecialization(hasAnyTemplateArgument(
comment|///     refersToDeclaration(field(hasName("next"))))
comment|///   matches the specialization \c A<&B::next> with \c field(...) matching
comment|///     \c B::next
name|AST_MATCHER_P
argument_list|(
argument|TemplateArgument
argument_list|,
argument|refersToDeclaration
argument_list|,
argument|internal::Matcher<Decl>
argument_list|,
argument|Matcher
argument_list|)
block|{
if|if
condition|(
specifier|const
name|Decl
modifier|*
name|Declaration
init|=
name|Node
operator|.
name|getAsDecl
argument_list|()
condition|)
return|return
name|Matcher
operator|.
name|matches
argument_list|(
operator|*
name|Declaration
argument_list|,
name|Finder
argument_list|,
name|Builder
argument_list|)
return|;
return|return
name|false
return|;
block|}
comment|/// \brief Matches C++ constructor declarations.
comment|///
comment|/// Example matches Foo::Foo() and Foo::Foo(int)
comment|///   class Foo {
comment|///    public:
comment|///     Foo();
comment|///     Foo(int);
comment|///     int DoSomething();
comment|///   };
specifier|const
name|internal
operator|::
name|VariadicDynCastAllOfMatcher
operator|<
name|Decl
operator|,
name|CXXConstructorDecl
operator|>
name|constructor
expr_stmt|;
comment|/// \brief Matches explicit C++ destructor declarations.
comment|///
comment|/// Example matches Foo::~Foo()
comment|///   class Foo {
comment|///    public:
comment|///     virtual ~Foo();
comment|///   };
specifier|const
name|internal
operator|::
name|VariadicDynCastAllOfMatcher
operator|<
name|Decl
operator|,
name|CXXDestructorDecl
operator|>
name|destructor
expr_stmt|;
comment|/// \brief Matches enum declarations.
comment|///
comment|/// Example matches X
comment|///   enum X {
comment|///     A, B, C
comment|///   };
specifier|const
name|internal
operator|::
name|VariadicDynCastAllOfMatcher
operator|<
name|Decl
operator|,
name|EnumDecl
operator|>
name|enumDecl
expr_stmt|;
comment|/// \brief Matches enum constants.
comment|///
comment|/// Example matches A, B, C
comment|///   enum X {
comment|///     A, B, C
comment|///   };
specifier|const
name|internal
operator|::
name|VariadicDynCastAllOfMatcher
operator|<
name|Decl
operator|,
name|EnumConstantDecl
operator|>
name|enumConstant
expr_stmt|;
comment|/// \brief Matches method declarations.
comment|///
comment|/// Example matches y
comment|///   class X { void y() };
specifier|const
name|internal
operator|::
name|VariadicDynCastAllOfMatcher
operator|<
name|Decl
operator|,
name|CXXMethodDecl
operator|>
name|method
expr_stmt|;
comment|/// \brief Matches variable declarations.
comment|///
comment|/// Note: this does not match declarations of member variables, which are
comment|/// "field" declarations in Clang parlance.
comment|///
comment|/// Example matches a
comment|///   int a;
specifier|const
name|internal
operator|::
name|VariadicDynCastAllOfMatcher
operator|<
name|Decl
operator|,
name|VarDecl
operator|>
name|variable
expr_stmt|;
comment|/// \brief Matches field declarations.
comment|///
comment|/// Given
comment|///   class X { int m; };
comment|/// field()
comment|///   matches 'm'.
specifier|const
name|internal
operator|::
name|VariadicDynCastAllOfMatcher
operator|<
name|Decl
operator|,
name|FieldDecl
operator|>
name|field
expr_stmt|;
comment|/// \brief Matches function declarations.
comment|///
comment|/// Example matches f
comment|///   void f();
specifier|const
name|internal
operator|::
name|VariadicDynCastAllOfMatcher
operator|<
name|Decl
operator|,
name|FunctionDecl
operator|>
name|function
expr_stmt|;
comment|/// \brief Matches statements.
comment|///
comment|/// Given
comment|///   { ++a; }
comment|/// statement()
comment|///   matches both the compound statement '{ ++a; }' and '++a'.
specifier|const
name|internal
operator|::
name|VariadicDynCastAllOfMatcher
operator|<
name|Stmt
operator|,
name|Stmt
operator|>
name|statement
expr_stmt|;
comment|/// \brief Matches declaration statements.
comment|///
comment|/// Given
comment|///   int a;
comment|/// declarationStatement()
comment|///   matches 'int a'.
specifier|const
name|internal
operator|::
name|VariadicDynCastAllOfMatcher
operator|<
name|Stmt
operator|,
name|DeclStmt
operator|>
name|declarationStatement
expr_stmt|;
comment|/// \brief Matches member expressions.
comment|///
comment|/// Given
comment|///   class Y {
comment|///     void x() { this->x(); x(); Y y; y.x(); a; this->b; Y::b; }
comment|///     int a; static int b;
comment|///   };
comment|/// memberExpression()
comment|///   matches this->x, x, y.x, a, this->b
specifier|const
name|internal
operator|::
name|VariadicDynCastAllOfMatcher
operator|<
name|Stmt
operator|,
name|MemberExpr
operator|>
name|memberExpression
expr_stmt|;
comment|/// \brief Matches call expressions.
comment|///
comment|/// Example matches x.y() and y()
comment|///   X x;
comment|///   x.y();
comment|///   y();
specifier|const
name|internal
operator|::
name|VariadicDynCastAllOfMatcher
operator|<
name|Stmt
operator|,
name|CallExpr
operator|>
name|call
expr_stmt|;
comment|/// \brief Matches member call expressions.
comment|///
comment|/// Example matches x.y()
comment|///   X x;
comment|///   x.y();
specifier|const
name|internal
operator|::
name|VariadicDynCastAllOfMatcher
operator|<
name|Stmt
operator|,
name|CXXMemberCallExpr
operator|>
name|memberCall
expr_stmt|;
comment|/// \brief Matches init list expressions.
comment|///
comment|/// Given
comment|///   int a[] = { 1, 2 };
comment|///   struct B { int x, y; };
comment|///   B b = { 5, 6 };
comment|/// initList()
comment|///   matches "{ 1, 2 }" and "{ 5, 6 }"
specifier|const
name|internal
operator|::
name|VariadicDynCastAllOfMatcher
operator|<
name|Stmt
operator|,
name|InitListExpr
operator|>
name|initListExpr
expr_stmt|;
comment|/// \brief Matches using declarations.
comment|///
comment|/// Given
comment|///   namespace X { int x; }
comment|///   using X::x;
comment|/// usingDecl()
comment|///   matches \code using X::x \endcode
specifier|const
name|internal
operator|::
name|VariadicDynCastAllOfMatcher
operator|<
name|Decl
operator|,
name|UsingDecl
operator|>
name|usingDecl
expr_stmt|;
comment|/// \brief Matches constructor call expressions (including implicit ones).
comment|///
comment|/// Example matches string(ptr, n) and ptr within arguments of f
comment|///     (matcher = constructorCall())
comment|///   void f(const string&a, const string&b);
comment|///   char *ptr;
comment|///   int n;
comment|///   f(string(ptr, n), ptr);
specifier|const
name|internal
operator|::
name|VariadicDynCastAllOfMatcher
operator|<
name|Stmt
operator|,
name|CXXConstructExpr
operator|>
name|constructorCall
expr_stmt|;
comment|/// \brief Matches nodes where temporaries are created.
comment|///
comment|/// Example matches FunctionTakesString(GetStringByValue())
comment|///     (matcher = bindTemporaryExpression())
comment|///   FunctionTakesString(GetStringByValue());
comment|///   FunctionTakesStringByPointer(GetStringPointer());
specifier|const
name|internal
operator|::
name|VariadicDynCastAllOfMatcher
operator|<
name|Stmt
operator|,
name|CXXBindTemporaryExpr
operator|>
name|bindTemporaryExpression
expr_stmt|;
comment|/// \brief Matches new expressions.
comment|///
comment|/// Given
comment|///   new X;
comment|/// newExpression()
comment|///   matches 'new X'.
specifier|const
name|internal
operator|::
name|VariadicDynCastAllOfMatcher
operator|<
name|Stmt
operator|,
name|CXXNewExpr
operator|>
name|newExpression
expr_stmt|;
comment|/// \brief Matches delete expressions.
comment|///
comment|/// Given
comment|///   delete X;
comment|/// deleteExpression()
comment|///   matches 'delete X'.
specifier|const
name|internal
operator|::
name|VariadicDynCastAllOfMatcher
operator|<
name|Stmt
operator|,
name|CXXDeleteExpr
operator|>
name|deleteExpression
expr_stmt|;
comment|/// \brief Matches array subscript expressions.
comment|///
comment|/// Given
comment|///   int i = a[1];
comment|/// arraySubscriptExpr()
comment|///   matches "a[1]"
specifier|const
name|internal
operator|::
name|VariadicDynCastAllOfMatcher
operator|<
name|Stmt
operator|,
name|ArraySubscriptExpr
operator|>
name|arraySubscriptExpr
expr_stmt|;
comment|/// \brief Matches the value of a default argument at the call site.
comment|///
comment|/// Example matches the CXXDefaultArgExpr placeholder inserted for the
comment|///     default value of the second parameter in the call expression f(42)
comment|///     (matcher = defaultArgument())
comment|///   void f(int x, int y = 0);
comment|///   f(42);
specifier|const
name|internal
operator|::
name|VariadicDynCastAllOfMatcher
operator|<
name|Stmt
operator|,
name|CXXDefaultArgExpr
operator|>
name|defaultArgument
expr_stmt|;
comment|/// \brief Matches overloaded operator calls.
comment|///
comment|/// Note that if an operator isn't overloaded, it won't match. Instead, use
comment|/// binaryOperator matcher.
comment|/// Currently it does not match operators such as new delete.
comment|/// FIXME: figure out why these do not match?
comment|///
comment|/// Example matches both operator<<((o<< b), c) and operator<<(o, b)
comment|///     (matcher = overloadedOperatorCall())
comment|///   ostream&operator<< (ostream&out, int i) { };
comment|///   ostream&o; int b = 1, c = 1;
comment|///   o<< b<< c;
specifier|const
name|internal
operator|::
name|VariadicDynCastAllOfMatcher
operator|<
name|Stmt
operator|,
name|CXXOperatorCallExpr
operator|>
name|overloadedOperatorCall
expr_stmt|;
comment|/// \brief Matches expressions.
comment|///
comment|/// Example matches x()
comment|///   void f() { x(); }
specifier|const
name|internal
operator|::
name|VariadicDynCastAllOfMatcher
operator|<
name|Stmt
operator|,
name|Expr
operator|>
name|expression
expr_stmt|;
comment|/// \brief Matches expressions that refer to declarations.
comment|///
comment|/// Example matches x in if (x)
comment|///   bool x;
comment|///   if (x) {}
specifier|const
name|internal
operator|::
name|VariadicDynCastAllOfMatcher
operator|<
name|Stmt
operator|,
name|DeclRefExpr
operator|>
name|declarationReference
expr_stmt|;
comment|/// \brief Matches if statements.
comment|///
comment|/// Example matches 'if (x) {}'
comment|///   if (x) {}
specifier|const
name|internal
operator|::
name|VariadicDynCastAllOfMatcher
operator|<
name|Stmt
operator|,
name|IfStmt
operator|>
name|ifStmt
expr_stmt|;
comment|/// \brief Matches for statements.
comment|///
comment|/// Example matches 'for (;;) {}'
comment|///   for (;;) {}
specifier|const
name|internal
operator|::
name|VariadicDynCastAllOfMatcher
operator|<
name|Stmt
operator|,
name|ForStmt
operator|>
name|forStmt
expr_stmt|;
comment|/// \brief Matches the increment statement of a for loop.
comment|///
comment|/// Example:
comment|///     forStmt(hasIncrement(unaryOperator(hasOperatorName("++"))))
comment|/// matches '++x' in
comment|///     for (x; x< N; ++x) { }
name|AST_MATCHER_P
argument_list|(
argument|ForStmt
argument_list|,
argument|hasIncrement
argument_list|,
argument|internal::Matcher<Stmt>
argument_list|,
argument|InnerMatcher
argument_list|)
block|{
specifier|const
name|Stmt
modifier|*
specifier|const
name|Increment
init|=
name|Node
operator|.
name|getInc
argument_list|()
decl_stmt|;
return|return
operator|(
name|Increment
operator|!=
name|NULL
operator|&&
name|InnerMatcher
operator|.
name|matches
argument_list|(
operator|*
name|Increment
argument_list|,
name|Finder
argument_list|,
name|Builder
argument_list|)
operator|)
return|;
block|}
comment|/// \brief Matches the initialization statement of a for loop.
comment|///
comment|/// Example:
comment|///     forStmt(hasLoopInit(declarationStatement()))
comment|/// matches 'int x = 0' in
comment|///     for (int x = 0; x< N; ++x) { }
name|AST_MATCHER_P
argument_list|(
argument|ForStmt
argument_list|,
argument|hasLoopInit
argument_list|,
argument|internal::Matcher<Stmt>
argument_list|,
argument|InnerMatcher
argument_list|)
block|{
specifier|const
name|Stmt
modifier|*
specifier|const
name|Init
init|=
name|Node
operator|.
name|getInit
argument_list|()
decl_stmt|;
return|return
operator|(
name|Init
operator|!=
name|NULL
operator|&&
name|InnerMatcher
operator|.
name|matches
argument_list|(
operator|*
name|Init
argument_list|,
name|Finder
argument_list|,
name|Builder
argument_list|)
operator|)
return|;
block|}
comment|/// \brief Matches while statements.
comment|///
comment|/// Given
comment|///   while (true) {}
comment|/// whileStmt()
comment|///   matches 'while (true) {}'.
specifier|const
name|internal
operator|::
name|VariadicDynCastAllOfMatcher
operator|<
name|Stmt
operator|,
name|WhileStmt
operator|>
name|whileStmt
expr_stmt|;
comment|/// \brief Matches do statements.
comment|///
comment|/// Given
comment|///   do {} while (true);
comment|/// doStmt()
comment|///   matches 'do {} while(true)'
specifier|const
name|internal
operator|::
name|VariadicDynCastAllOfMatcher
operator|<
name|Stmt
operator|,
name|DoStmt
operator|>
name|doStmt
expr_stmt|;
comment|/// \brief Matches case and default statements inside switch statements.
comment|///
comment|/// Given
comment|///   switch(a) { case 42: break; default: break; }
comment|/// switchCase()
comment|///   matches 'case 42: break;' and 'default: break;'.
specifier|const
name|internal
operator|::
name|VariadicDynCastAllOfMatcher
operator|<
name|Stmt
operator|,
name|SwitchCase
operator|>
name|switchCase
expr_stmt|;
comment|/// \brief Matches compound statements.
comment|///
comment|/// Example matches '{}' and '{{}}'in 'for (;;) {{}}'
comment|///   for (;;) {{}}
specifier|const
name|internal
operator|::
name|VariadicDynCastAllOfMatcher
operator|<
name|Stmt
operator|,
name|CompoundStmt
operator|>
name|compoundStatement
expr_stmt|;
comment|/// \brief Matches bool literals.
comment|///
comment|/// Example matches true
comment|///   true
specifier|const
name|internal
operator|::
name|VariadicDynCastAllOfMatcher
operator|<
name|Expr
operator|,
name|CXXBoolLiteralExpr
operator|>
name|boolLiteral
expr_stmt|;
comment|/// \brief Matches string literals (also matches wide string literals).
comment|///
comment|/// Example matches "abcd", L"abcd"
comment|///   char *s = "abcd"; wchar_t *ws = L"abcd"
specifier|const
name|internal
operator|::
name|VariadicDynCastAllOfMatcher
operator|<
name|Expr
operator|,
name|StringLiteral
operator|>
name|stringLiteral
expr_stmt|;
comment|/// \brief Matches character literals (also matches wchar_t).
comment|///
comment|/// Not matching Hex-encoded chars (e.g. 0x1234, which is a IntegerLiteral),
comment|/// though.
comment|///
comment|/// Example matches 'a', L'a'
comment|///   char ch = 'a'; wchar_t chw = L'a';
specifier|const
name|internal
operator|::
name|VariadicDynCastAllOfMatcher
operator|<
name|Expr
operator|,
name|CharacterLiteral
operator|>
name|characterLiteral
expr_stmt|;
comment|/// \brief Matches integer literals of all sizes / encodings.
comment|///
comment|/// Not matching character-encoded integers such as L'a'.
comment|///
comment|/// Example matches 1, 1L, 0x1, 1U
specifier|const
name|internal
operator|::
name|VariadicDynCastAllOfMatcher
operator|<
name|Expr
operator|,
name|IntegerLiteral
operator|>
name|integerLiteral
expr_stmt|;
comment|/// \brief Matches binary operator expressions.
comment|///
comment|/// Example matches a || b
comment|///   !(a || b)
specifier|const
name|internal
operator|::
name|VariadicDynCastAllOfMatcher
operator|<
name|Stmt
operator|,
name|BinaryOperator
operator|>
name|binaryOperator
expr_stmt|;
comment|/// \brief Matches unary operator expressions.
comment|///
comment|/// Example matches !a
comment|///   !a || b
specifier|const
name|internal
operator|::
name|VariadicDynCastAllOfMatcher
operator|<
name|Stmt
operator|,
name|UnaryOperator
operator|>
name|unaryOperator
expr_stmt|;
comment|/// \brief Matches conditional operator expressions.
comment|///
comment|/// Example matches a ? b : c
comment|///   (a ? b : c) + 42
specifier|const
name|internal
operator|::
name|VariadicDynCastAllOfMatcher
operator|<
name|Stmt
operator|,
name|ConditionalOperator
operator|>
name|conditionalOperator
expr_stmt|;
comment|/// \brief Matches a reinterpret_cast expression.
comment|///
comment|/// Either the source expression or the destination type can be matched
comment|/// using has(), but hasDestinationType() is more specific and can be
comment|/// more readable.
comment|///
comment|/// Example matches reinterpret_cast<char*>(&p) in
comment|///   void* p = reinterpret_cast<char*>(&p);
specifier|const
name|internal
operator|::
name|VariadicDynCastAllOfMatcher
operator|<
name|Expr
operator|,
name|CXXReinterpretCastExpr
operator|>
name|reinterpretCast
expr_stmt|;
comment|/// \brief Matches a C++ static_cast expression.
comment|///
comment|/// \see hasDestinationType
comment|/// \see reinterpretCast
comment|///
comment|/// Example:
comment|///   staticCast()
comment|/// matches
comment|///   static_cast<long>(8)
comment|/// in
comment|///   long eight(static_cast<long>(8));
specifier|const
name|internal
operator|::
name|VariadicDynCastAllOfMatcher
operator|<
name|Expr
operator|,
name|CXXStaticCastExpr
operator|>
name|staticCast
expr_stmt|;
comment|/// \brief Matches a dynamic_cast expression.
comment|///
comment|/// Example:
comment|///   dynamicCast()
comment|/// matches
comment|///   dynamic_cast<D*>(&b);
comment|/// in
comment|///   struct B { virtual ~B() {} }; struct D : B {};
comment|///   B b;
comment|///   D* p = dynamic_cast<D*>(&b);
specifier|const
name|internal
operator|::
name|VariadicDynCastAllOfMatcher
operator|<
name|Expr
operator|,
name|CXXDynamicCastExpr
operator|>
name|dynamicCast
expr_stmt|;
comment|/// \brief Matches a const_cast expression.
comment|///
comment|/// Example: Matches const_cast<int*>(&r) in
comment|///   int n = 42;
comment|///   const int& r(n);
comment|///   int* p = const_cast<int*>(&r);
specifier|const
name|internal
operator|::
name|VariadicDynCastAllOfMatcher
operator|<
name|Expr
operator|,
name|CXXConstCastExpr
operator|>
name|constCast
expr_stmt|;
comment|/// \brief Matches explicit cast expressions.
comment|///
comment|/// Matches any cast expression written in user code, whether it be a
comment|/// C-style cast, a functional-style cast, or a keyword cast.
comment|///
comment|/// Does not match implicit conversions.
comment|///
comment|/// Note: the name "explicitCast" is chosen to match Clang's terminology, as
comment|/// Clang uses the term "cast" to apply to implicit conversions as well as to
comment|/// actual cast expressions.
comment|///
comment|/// \see hasDestinationType.
comment|///
comment|/// Example: matches all five of the casts in
comment|///   int((int)(reinterpret_cast<int>(static_cast<int>(const_cast<int>(42)))))
comment|/// but does not match the implicit conversion in
comment|///   long ell = 42;
specifier|const
name|internal
operator|::
name|VariadicDynCastAllOfMatcher
operator|<
name|Expr
operator|,
name|ExplicitCastExpr
operator|>
name|explicitCast
expr_stmt|;
comment|/// \brief Matches the implicit cast nodes of Clang's AST.
comment|///
comment|/// This matches many different places, including function call return value
comment|/// eliding, as well as any type conversions.
specifier|const
name|internal
operator|::
name|VariadicDynCastAllOfMatcher
operator|<
name|Expr
operator|,
name|ImplicitCastExpr
operator|>
name|implicitCast
expr_stmt|;
comment|/// \brief Matches functional cast expressions
comment|///
comment|/// Example: Matches Foo(bar);
comment|///   Foo f = bar;
comment|///   Foo g = (Foo) bar;
comment|///   Foo h = Foo(bar);
specifier|const
name|internal
operator|::
name|VariadicDynCastAllOfMatcher
operator|<
name|Expr
operator|,
name|CXXFunctionalCastExpr
operator|>
name|functionalCast
expr_stmt|;
comment|/// \brief Various overloads for the anyOf matcher.
comment|/// @{
name|template
operator|<
name|typename
name|C1
operator|,
name|typename
name|C2
operator|>
name|internal
operator|::
name|PolymorphicMatcherWithParam2
operator|<
name|internal
operator|::
name|AnyOfMatcher
operator|,
name|C1
operator|,
name|C2
operator|>
name|anyOf
argument_list|(
argument|const C1&P1
argument_list|,
argument|const C2&P2
argument_list|)
block|{
return|return
name|internal
operator|::
name|PolymorphicMatcherWithParam2
operator|<
name|internal
operator|::
name|AnyOfMatcher
operator|,
name|C1
operator|,
name|C2
operator|>
operator|(
name|P1
operator|,
name|P2
operator|)
return|;
block|}
name|template
operator|<
name|typename
name|C1
operator|,
name|typename
name|C2
operator|,
name|typename
name|C3
operator|>
name|internal
operator|::
name|PolymorphicMatcherWithParam2
operator|<
name|internal
operator|::
name|AnyOfMatcher
operator|,
name|C1
operator|,
name|internal
operator|::
name|PolymorphicMatcherWithParam2
operator|<
name|internal
operator|::
name|AnyOfMatcher
operator|,
name|C2
operator|,
name|C3
operator|>
expr|>
name|anyOf
argument_list|(
argument|const C1&P1
argument_list|,
argument|const C2&P2
argument_list|,
argument|const C3&P3
argument_list|)
block|{
return|return
name|anyOf
argument_list|(
name|P1
argument_list|,
name|anyOf
argument_list|(
name|P2
argument_list|,
name|P3
argument_list|)
argument_list|)
return|;
block|}
name|template
operator|<
name|typename
name|C1
operator|,
name|typename
name|C2
operator|,
name|typename
name|C3
operator|,
name|typename
name|C4
operator|>
name|internal
operator|::
name|PolymorphicMatcherWithParam2
operator|<
name|internal
operator|::
name|AnyOfMatcher
operator|,
name|C1
operator|,
name|internal
operator|::
name|PolymorphicMatcherWithParam2
operator|<
name|internal
operator|::
name|AnyOfMatcher
operator|,
name|C2
operator|,
name|internal
operator|::
name|PolymorphicMatcherWithParam2
operator|<
name|internal
operator|::
name|AnyOfMatcher
operator|,
name|C3
operator|,
name|C4
operator|>
expr|>
operator|>
name|anyOf
argument_list|(
argument|const C1&P1
argument_list|,
argument|const C2&P2
argument_list|,
argument|const C3&P3
argument_list|,
argument|const C4&P4
argument_list|)
block|{
return|return
name|anyOf
argument_list|(
name|P1
argument_list|,
name|anyOf
argument_list|(
name|P2
argument_list|,
name|anyOf
argument_list|(
name|P3
argument_list|,
name|P4
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
name|template
operator|<
name|typename
name|C1
operator|,
name|typename
name|C2
operator|,
name|typename
name|C3
operator|,
name|typename
name|C4
operator|,
name|typename
name|C5
operator|>
name|internal
operator|::
name|PolymorphicMatcherWithParam2
operator|<
name|internal
operator|::
name|AnyOfMatcher
operator|,
name|C1
operator|,
name|internal
operator|::
name|PolymorphicMatcherWithParam2
operator|<
name|internal
operator|::
name|AnyOfMatcher
operator|,
name|C2
operator|,
name|internal
operator|::
name|PolymorphicMatcherWithParam2
operator|<
name|internal
operator|::
name|AnyOfMatcher
operator|,
name|C3
operator|,
name|internal
operator|::
name|PolymorphicMatcherWithParam2
operator|<
name|internal
operator|::
name|AnyOfMatcher
operator|,
name|C4
operator|,
name|C5
operator|>
expr|>
operator|>
expr|>
name|anyOf
argument_list|(
argument|const C1& P1
argument_list|,
argument|const C2& P2
argument_list|,
argument|const C3& P3
argument_list|,
argument|const C4& P4
argument_list|,
argument|const C5& P5
argument_list|)
block|{
return|return
name|anyOf
argument_list|(
name|P1
argument_list|,
name|anyOf
argument_list|(
name|P2
argument_list|,
name|anyOf
argument_list|(
name|P3
argument_list|,
name|anyOf
argument_list|(
name|P4
argument_list|,
name|P5
argument_list|)
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
comment|/// @}
comment|/// \brief Various overloads for the allOf matcher.
comment|/// @{
name|template
operator|<
name|typename
name|C1
operator|,
name|typename
name|C2
operator|>
name|internal
operator|::
name|PolymorphicMatcherWithParam2
operator|<
name|internal
operator|::
name|AllOfMatcher
operator|,
name|C1
operator|,
name|C2
operator|>
name|allOf
argument_list|(
argument|const C1&P1
argument_list|,
argument|const C2&P2
argument_list|)
block|{
return|return
name|internal
operator|::
name|PolymorphicMatcherWithParam2
operator|<
name|internal
operator|::
name|AllOfMatcher
operator|,
name|C1
operator|,
name|C2
operator|>
operator|(
name|P1
operator|,
name|P2
operator|)
return|;
block|}
name|template
operator|<
name|typename
name|C1
operator|,
name|typename
name|C2
operator|,
name|typename
name|C3
operator|>
name|internal
operator|::
name|PolymorphicMatcherWithParam2
operator|<
name|internal
operator|::
name|AllOfMatcher
operator|,
name|C1
operator|,
name|internal
operator|::
name|PolymorphicMatcherWithParam2
operator|<
name|internal
operator|::
name|AllOfMatcher
operator|,
name|C2
operator|,
name|C3
operator|>
expr|>
name|allOf
argument_list|(
argument|const C1& P1
argument_list|,
argument|const C2& P2
argument_list|,
argument|const C3& P3
argument_list|)
block|{
return|return
name|allOf
argument_list|(
name|P1
argument_list|,
name|allOf
argument_list|(
name|P2
argument_list|,
name|P3
argument_list|)
argument_list|)
return|;
block|}
comment|/// @}
comment|/// \brief Matches sizeof (C99), alignof (C++11) and vec_step (OpenCL)
comment|///
comment|/// Given
comment|///   Foo x = bar;
comment|///   int y = sizeof(x) + alignof(x);
comment|/// unaryExprOrTypeTraitExpr()
comment|///   matches \c sizeof(x) and \c alignof(x)
specifier|const
name|internal
operator|::
name|VariadicDynCastAllOfMatcher
operator|<
name|Stmt
operator|,
name|UnaryExprOrTypeTraitExpr
operator|>
name|unaryExprOrTypeTraitExpr
expr_stmt|;
comment|/// \brief Matches unary expressions that have a specific type of argument.
comment|///
comment|/// Given
comment|///   int a, c; float b; int s = sizeof(a) + sizeof(b) + alignof(c);
comment|/// unaryExprOrTypeTraitExpr(hasArgumentOfType(asString("int"))
comment|///   matches \c sizeof(a) and \c alignof(c)
name|AST_MATCHER_P
argument_list|(
argument|UnaryExprOrTypeTraitExpr
argument_list|,
argument|hasArgumentOfType
argument_list|,
argument|internal::Matcher<QualType>
argument_list|,
argument|Matcher
argument_list|)
block|{
specifier|const
name|QualType
name|ArgumentType
init|=
name|Node
operator|.
name|getTypeOfArgument
argument_list|()
decl_stmt|;
return|return
name|Matcher
operator|.
name|matches
argument_list|(
name|ArgumentType
argument_list|,
name|Finder
argument_list|,
name|Builder
argument_list|)
return|;
block|}
comment|/// \brief Matches unary expressions of a certain kind.
comment|///
comment|/// Given
comment|///   int x;
comment|///   int s = sizeof(x) + alignof(x)
comment|/// unaryExprOrTypeTraitExpr(ofKind(UETT_SizeOf))
comment|///   matches \c sizeof(x)
name|AST_MATCHER_P
argument_list|(
argument|UnaryExprOrTypeTraitExpr
argument_list|,
argument|ofKind
argument_list|,
argument|UnaryExprOrTypeTrait
argument_list|,
argument|Kind
argument_list|)
block|{
return|return
name|Node
operator|.
name|getKind
argument_list|()
operator|==
name|Kind
return|;
block|}
comment|/// \brief Same as unaryExprOrTypeTraitExpr, but only matching
comment|/// alignof.
specifier|inline
name|internal
operator|::
name|Matcher
operator|<
name|Stmt
operator|>
name|alignOfExpr
argument_list|(
argument|const internal::Matcher<UnaryExprOrTypeTraitExpr>&Matcher
argument_list|)
block|{
return|return
name|internal
operator|::
name|Matcher
operator|<
name|Stmt
operator|>
operator|(
name|unaryExprOrTypeTraitExpr
argument_list|(
name|allOf
argument_list|(
name|ofKind
argument_list|(
name|UETT_AlignOf
argument_list|)
argument_list|,
name|Matcher
argument_list|)
argument_list|)
operator|)
return|;
block|}
comment|/// \brief Same as unaryExprOrTypeTraitExpr, but only matching
comment|/// sizeof.
specifier|inline
name|internal
operator|::
name|Matcher
operator|<
name|Stmt
operator|>
name|sizeOfExpr
argument_list|(
argument|const internal::Matcher<UnaryExprOrTypeTraitExpr>&Matcher
argument_list|)
block|{
return|return
name|internal
operator|::
name|Matcher
operator|<
name|Stmt
operator|>
operator|(
name|unaryExprOrTypeTraitExpr
argument_list|(
name|allOf
argument_list|(
name|ofKind
argument_list|(
name|UETT_SizeOf
argument_list|)
argument_list|,
name|Matcher
argument_list|)
argument_list|)
operator|)
return|;
block|}
comment|/// \brief Matches NamedDecl nodes that have the specified name.
comment|///
comment|/// Supports specifying enclosing namespaces or classes by prefixing the name
comment|/// with '<enclosing>::'.
comment|/// Does not match typedefs of an underlying type with the given name.
comment|///
comment|/// Example matches X (Name == "X")
comment|///   class X;
comment|///
comment|/// Example matches X (Name is one of "::a::b::X", "a::b::X", "b::X", "X")
comment|/// namespace a { namespace b { class X; } }
name|AST_MATCHER_P
argument_list|(
argument|NamedDecl
argument_list|,
argument|hasName
argument_list|,
argument|std::string
argument_list|,
argument|Name
argument_list|)
block|{
name|assert
argument_list|(
operator|!
name|Name
operator|.
name|empty
argument_list|()
argument_list|)
expr_stmt|;
specifier|const
name|std
operator|::
name|string
name|FullNameString
operator|=
literal|"::"
operator|+
name|Node
operator|.
name|getQualifiedNameAsString
argument_list|()
expr_stmt|;
specifier|const
name|llvm
operator|::
name|StringRef
name|FullName
operator|=
name|FullNameString
expr_stmt|;
specifier|const
name|llvm
operator|::
name|StringRef
name|Pattern
operator|=
name|Name
expr_stmt|;
if|if
condition|(
name|Pattern
operator|.
name|startswith
argument_list|(
literal|"::"
argument_list|)
condition|)
block|{
return|return
name|FullName
operator|==
name|Pattern
return|;
block|}
else|else
block|{
return|return
name|FullName
operator|.
name|endswith
argument_list|(
operator|(
literal|"::"
operator|+
name|Pattern
operator|)
operator|.
name|str
argument_list|()
argument_list|)
return|;
block|}
block|}
comment|/// \brief Matches NamedDecl nodes whose full names partially match the
comment|/// given RegExp.
comment|///
comment|/// Supports specifying enclosing namespaces or classes by
comment|/// prefixing the name with '<enclosing>::'.  Does not match typedefs
comment|/// of an underlying type with the given name.
comment|///
comment|/// Example matches X (regexp == "::X")
comment|///   class X;
comment|///
comment|/// Example matches X (regexp is one of "::X", "^foo::.*X", among others)
comment|/// namespace foo { namespace bar { class X; } }
name|AST_MATCHER_P
argument_list|(
argument|NamedDecl
argument_list|,
argument|matchesName
argument_list|,
argument|std::string
argument_list|,
argument|RegExp
argument_list|)
block|{
name|assert
argument_list|(
operator|!
name|RegExp
operator|.
name|empty
argument_list|()
argument_list|)
expr_stmt|;
name|std
operator|::
name|string
name|FullNameString
operator|=
literal|"::"
operator|+
name|Node
operator|.
name|getQualifiedNameAsString
argument_list|()
expr_stmt|;
name|llvm
operator|::
name|Regex
name|RE
argument_list|(
name|RegExp
argument_list|)
expr_stmt|;
return|return
name|RE
operator|.
name|match
argument_list|(
name|FullNameString
argument_list|)
return|;
block|}
comment|/// \brief Matches overloaded operator names.
comment|///
comment|/// Matches overloaded operator names specified in strings without the
comment|/// "operator" prefix, such as "<<", for OverloadedOperatorCall's.
comment|///
comment|/// Example matches a<< b
comment|///     (matcher == overloadedOperatorCall(hasOverloadedOperatorName("<<")))
comment|///   a<< b;
comment|///   c&& d;  // assuming both operator<<
comment|///            // and operator&& are overloaded somewhere.
name|AST_MATCHER_P
argument_list|(
argument|CXXOperatorCallExpr
argument_list|,
argument|hasOverloadedOperatorName
argument_list|,
argument|std::string
argument_list|,
argument|Name
argument_list|)
block|{
return|return
name|getOperatorSpelling
argument_list|(
name|Node
operator|.
name|getOperator
argument_list|()
argument_list|)
operator|==
name|Name
return|;
block|}
comment|/// \brief Matches C++ classes that are directly or indirectly derived from
comment|/// a class matching \c Base.
comment|///
comment|/// Note that a class is considered to be also derived from itself.
comment|///
comment|/// Example matches X, Y, Z, C (Base == hasName("X"))
comment|///   class X;                // A class is considered to be derived from itself
comment|///   class Y : public X {};  // directly derived
comment|///   class Z : public Y {};  // indirectly derived
comment|///   typedef X A;
comment|///   typedef A B;
comment|///   class C : public B {};  // derived from a typedef of X
comment|///
comment|/// In the following example, Bar matches isDerivedFrom(hasName("X")):
comment|///   class Foo;
comment|///   typedef Foo X;
comment|///   class Bar : public Foo {};  // derived from a type that X is a typedef of
name|AST_MATCHER_P
argument_list|(
argument|CXXRecordDecl
argument_list|,
argument|isDerivedFrom
argument_list|,
argument|internal::Matcher<NamedDecl>
argument_list|,
argument|Base
argument_list|)
block|{
return|return
name|Finder
operator|->
name|classIsDerivedFrom
argument_list|(
operator|&
name|Node
argument_list|,
name|Base
argument_list|,
name|Builder
argument_list|)
return|;
block|}
comment|/// \brief Overloaded method as shortcut for \c isDerivedFrom(hasName(...)).
specifier|inline
name|internal
operator|::
name|Matcher
operator|<
name|CXXRecordDecl
operator|>
name|isDerivedFrom
argument_list|(
argument|StringRef BaseName
argument_list|)
block|{
name|assert
argument_list|(
operator|!
name|BaseName
operator|.
name|empty
argument_list|()
argument_list|)
block|;
return|return
name|isDerivedFrom
argument_list|(
name|hasName
argument_list|(
name|BaseName
argument_list|)
argument_list|)
return|;
block|}
comment|/// \brief Matches AST nodes that have child AST nodes that match the
comment|/// provided matcher.
comment|///
comment|/// Example matches X, Y (matcher = record(has(record(hasName("X")))
comment|///   class X {};  // Matches X, because X::X is a class of name X inside X.
comment|///   class Y { class X {}; };
comment|///   class Z { class Y { class X {}; }; };  // Does not match Z.
comment|///
comment|/// ChildT must be an AST base type.
name|template
operator|<
name|typename
name|ChildT
operator|>
name|internal
operator|::
name|ArgumentAdaptingMatcher
operator|<
name|internal
operator|::
name|HasMatcher
operator|,
name|ChildT
operator|>
name|has
argument_list|(
argument|const internal::Matcher<ChildT>&ChildMatcher
argument_list|)
block|{
return|return
name|internal
operator|::
name|ArgumentAdaptingMatcher
operator|<
name|internal
operator|::
name|HasMatcher
operator|,
name|ChildT
operator|>
operator|(
name|ChildMatcher
operator|)
return|;
block|}
comment|/// \brief Matches AST nodes that have descendant AST nodes that match the
comment|/// provided matcher.
comment|///
comment|/// Example matches X, Y, Z
comment|///     (matcher = record(hasDescendant(record(hasName("X")))))
comment|///   class X {};  // Matches X, because X::X is a class of name X inside X.
comment|///   class Y { class X {}; };
comment|///   class Z { class Y { class X {}; }; };
comment|///
comment|/// DescendantT must be an AST base type.
name|template
operator|<
name|typename
name|DescendantT
operator|>
name|internal
operator|::
name|ArgumentAdaptingMatcher
operator|<
name|internal
operator|::
name|HasDescendantMatcher
operator|,
name|DescendantT
operator|>
name|hasDescendant
argument_list|(
argument|const internal::Matcher<DescendantT>&DescendantMatcher
argument_list|)
block|{
return|return
name|internal
operator|::
name|ArgumentAdaptingMatcher
operator|<
name|internal
operator|::
name|HasDescendantMatcher
operator|,
name|DescendantT
operator|>
operator|(
name|DescendantMatcher
operator|)
return|;
block|}
comment|/// \brief Matches AST nodes that have child AST nodes that match the
comment|/// provided matcher.
comment|///
comment|/// Example matches X, Y (matcher = record(forEach(record(hasName("X")))
comment|///   class X {};  // Matches X, because X::X is a class of name X inside X.
comment|///   class Y { class X {}; };
comment|///   class Z { class Y { class X {}; }; };  // Does not match Z.
comment|///
comment|/// ChildT must be an AST base type.
comment|///
comment|/// As opposed to 'has', 'forEach' will cause a match for each result that
comment|/// matches instead of only on the first one.
name|template
operator|<
name|typename
name|ChildT
operator|>
name|internal
operator|::
name|ArgumentAdaptingMatcher
operator|<
name|internal
operator|::
name|ForEachMatcher
operator|,
name|ChildT
operator|>
name|forEach
argument_list|(
argument|const internal::Matcher<ChildT>& ChildMatcher
argument_list|)
block|{
return|return
name|internal
operator|::
name|ArgumentAdaptingMatcher
operator|<
name|internal
operator|::
name|ForEachMatcher
operator|,
name|ChildT
operator|>
operator|(
name|ChildMatcher
operator|)
return|;
block|}
comment|/// \brief Matches AST nodes that have descendant AST nodes that match the
comment|/// provided matcher.
comment|///
comment|/// Example matches X, A, B, C
comment|///     (matcher = record(forEachDescendant(record(hasName("X")))))
comment|///   class X {};  // Matches X, because X::X is a class of name X inside X.
comment|///   class A { class X {}; };
comment|///   class B { class C { class X {}; }; };
comment|///
comment|/// DescendantT must be an AST base type.
comment|///
comment|/// As opposed to 'hasDescendant', 'forEachDescendant' will cause a match for
comment|/// each result that matches instead of only on the first one.
comment|///
comment|/// Note: Recursively combined ForEachDescendant can cause many matches:
comment|///   record(forEachDescendant(record(forEachDescendant(record()))))
comment|/// will match 10 times (plus injected class name matches) on:
comment|///   class A { class B { class C { class D { class E {}; }; }; }; };
name|template
operator|<
name|typename
name|DescendantT
operator|>
name|internal
operator|::
name|ArgumentAdaptingMatcher
operator|<
name|internal
operator|::
name|ForEachDescendantMatcher
operator|,
name|DescendantT
operator|>
name|forEachDescendant
argument_list|(
argument|const internal::Matcher<DescendantT>& DescendantMatcher
argument_list|)
block|{
return|return
name|internal
operator|::
name|ArgumentAdaptingMatcher
operator|<
name|internal
operator|::
name|ForEachDescendantMatcher
operator|,
name|DescendantT
operator|>
operator|(
name|DescendantMatcher
operator|)
return|;
block|}
comment|/// \brief Matches if the provided matcher does not match.
comment|///
comment|/// Example matches Y (matcher = record(unless(hasName("X"))))
comment|///   class X {};
comment|///   class Y {};
name|template
operator|<
name|typename
name|M
operator|>
name|internal
operator|::
name|PolymorphicMatcherWithParam1
operator|<
name|internal
operator|::
name|NotMatcher
operator|,
name|M
operator|>
name|unless
argument_list|(
argument|const M&InnerMatcher
argument_list|)
block|{
return|return
name|internal
operator|::
name|PolymorphicMatcherWithParam1
operator|<
name|internal
operator|::
name|NotMatcher
operator|,
name|M
operator|>
operator|(
name|InnerMatcher
operator|)
return|;
block|}
comment|/// \brief Matches a type if the declaration of the type matches the given
comment|/// matcher.
comment|///
comment|/// Usable as: Matcher<QualType>, Matcher<CallExpr>, Matcher<CXXConstructExpr>
specifier|inline
name|internal
operator|::
name|PolymorphicMatcherWithParam1
operator|<
name|internal
operator|::
name|HasDeclarationMatcher
operator|,
name|internal
operator|::
name|Matcher
operator|<
name|Decl
operator|>
expr|>
name|hasDeclaration
argument_list|(
argument|const internal::Matcher<Decl>&InnerMatcher
argument_list|)
block|{
return|return
name|internal
operator|::
name|PolymorphicMatcherWithParam1
operator|<
name|internal
operator|::
name|HasDeclarationMatcher
operator|,
name|internal
operator|::
name|Matcher
operator|<
name|Decl
operator|>
expr|>
operator|(
name|InnerMatcher
operator|)
return|;
block|}
comment|/// \brief Matches on the implicit object argument of a member call expression.
comment|///
comment|/// Example matches y.x() (matcher = call(on(hasType(record(hasName("Y"))))))
comment|///   class Y { public: void x(); };
comment|///   void z() { Y y; y.x(); }",
comment|///
comment|/// FIXME: Overload to allow directly matching types?
name|AST_MATCHER_P
argument_list|(
argument|CXXMemberCallExpr
argument_list|,
argument|on
argument_list|,
argument|internal::Matcher<Expr>
argument_list|,
argument|InnerMatcher
argument_list|)
block|{
specifier|const
name|Expr
modifier|*
name|ExprNode
init|=
name|const_cast
operator|<
name|CXXMemberCallExpr
operator|&
operator|>
operator|(
name|Node
operator|)
operator|.
name|getImplicitObjectArgument
argument_list|()
operator|->
name|IgnoreParenImpCasts
argument_list|()
decl_stmt|;
return|return
operator|(
name|ExprNode
operator|!=
name|NULL
operator|&&
name|InnerMatcher
operator|.
name|matches
argument_list|(
operator|*
name|ExprNode
argument_list|,
name|Finder
argument_list|,
name|Builder
argument_list|)
operator|)
return|;
block|}
comment|/// \brief Matches if the call expression's callee expression matches.
comment|///
comment|/// Given
comment|///   class Y { void x() { this->x(); x(); Y y; y.x(); } };
comment|///   void f() { f(); }
comment|/// call(callee(expression()))
comment|///   matches this->x(), x(), y.x(), f()
comment|/// with callee(...)
comment|///   matching this->x, x, y.x, f respectively
comment|///
comment|/// Note: Callee cannot take the more general internal::Matcher<Expr>
comment|/// because this introduces ambiguous overloads with calls to Callee taking a
comment|/// internal::Matcher<Decl>, as the matcher hierarchy is purely
comment|/// implemented in terms of implicit casts.
name|AST_MATCHER_P
argument_list|(
argument|CallExpr
argument_list|,
argument|callee
argument_list|,
argument|internal::Matcher<Stmt>
argument_list|,
argument|InnerMatcher
argument_list|)
block|{
specifier|const
name|Expr
modifier|*
name|ExprNode
init|=
name|Node
operator|.
name|getCallee
argument_list|()
decl_stmt|;
return|return
operator|(
name|ExprNode
operator|!=
name|NULL
operator|&&
name|InnerMatcher
operator|.
name|matches
argument_list|(
operator|*
name|ExprNode
argument_list|,
name|Finder
argument_list|,
name|Builder
argument_list|)
operator|)
return|;
block|}
comment|/// \brief Matches if the call expression's callee's declaration matches the
comment|/// given matcher.
comment|///
comment|/// Example matches y.x() (matcher = call(callee(method(hasName("x")))))
comment|///   class Y { public: void x(); };
comment|///   void z() { Y y; y.x();
specifier|inline
name|internal
operator|::
name|Matcher
operator|<
name|CallExpr
operator|>
name|callee
argument_list|(
argument|const internal::Matcher<Decl>&InnerMatcher
argument_list|)
block|{
return|return
name|internal
operator|::
name|Matcher
operator|<
name|CallExpr
operator|>
operator|(
name|hasDeclaration
argument_list|(
name|InnerMatcher
argument_list|)
operator|)
return|;
block|}
comment|/// \brief Matches if the expression's or declaration's type matches a type
comment|/// matcher.
comment|///
comment|/// Example matches x (matcher = expression(hasType(
comment|///                        hasDeclaration(record(hasName("X"))))))
comment|///             and z (matcher = variable(hasType(
comment|///                        hasDeclaration(record(hasName("X"))))))
comment|///  class X {};
comment|///  void y(X&x) { x; X z; }
name|AST_POLYMORPHIC_MATCHER_P
argument_list|(
argument|hasType
argument_list|,
argument|internal::Matcher<QualType>
argument_list|,
argument|InnerMatcher
argument_list|)
block|{
name|TOOLING_COMPILE_ASSERT
argument_list|(
operator|(
name|llvm
operator|::
name|is_base_of
operator|<
name|Expr
operator|,
name|NodeType
operator|>
operator|::
name|value
operator|||
name|llvm
operator|::
name|is_base_of
operator|<
name|ValueDecl
operator|,
name|NodeType
operator|>
operator|::
name|value
operator|)
argument_list|,
name|instantiated_with_wrong_types
argument_list|)
expr_stmt|;
return|return
name|InnerMatcher
operator|.
name|matches
argument_list|(
name|Node
operator|.
name|getType
argument_list|()
argument_list|,
name|Finder
argument_list|,
name|Builder
argument_list|)
return|;
block|}
comment|/// \brief Overloaded to match the declaration of the expression's or value
comment|/// declaration's type.
comment|///
comment|/// In case of a value declaration (for example a variable declaration),
comment|/// this resolves one layer of indirection. For example, in the value
comment|/// declaration "X x;", record(hasName("X")) matches the declaration of X,
comment|/// while variable(hasType(record(hasName("X")))) matches the declaration
comment|/// of x."
comment|///
comment|/// Example matches x (matcher = expression(hasType(record(hasName("X")))))
comment|///             and z (matcher = variable(hasType(record(hasName("X")))))
comment|///  class X {};
comment|///  void y(X&x) { x; X z; }
comment|///
comment|/// Usable as: Matcher<Expr>, Matcher<ValueDecl>
specifier|inline
name|internal
operator|::
name|PolymorphicMatcherWithParam1
operator|<
name|internal
operator|::
name|matcher_hasTypeMatcher
operator|,
name|internal
operator|::
name|Matcher
operator|<
name|QualType
operator|>
expr|>
name|hasType
argument_list|(
argument|const internal::Matcher<Decl>&InnerMatcher
argument_list|)
block|{
return|return
name|hasType
argument_list|(
name|internal
operator|::
name|Matcher
operator|<
name|QualType
operator|>
operator|(
name|hasDeclaration
argument_list|(
name|InnerMatcher
argument_list|)
operator|)
argument_list|)
return|;
block|}
comment|/// \brief Matches if the matched type is represented by the given string.
comment|///
comment|/// Given
comment|///   class Y { public: void x(); };
comment|///   void z() { Y* y; y->x(); }
comment|/// call(on(hasType(asString("class Y *"))))
comment|///   matches y->x()
name|AST_MATCHER_P
argument_list|(
argument|QualType
argument_list|,
argument|asString
argument_list|,
argument|std::string
argument_list|,
argument|Name
argument_list|)
block|{
return|return
name|Name
operator|==
name|Node
operator|.
name|getAsString
argument_list|()
return|;
block|}
comment|/// \brief Matches if the matched type is a pointer type and the pointee type
comment|/// matches the specified matcher.
comment|///
comment|/// Example matches y->x()
comment|///     (matcher = call(on(hasType(pointsTo(record(hasName("Y")))))))
comment|///   class Y { public: void x(); };
comment|///   void z() { Y *y; y->x(); }
name|AST_MATCHER_P
argument_list|(
argument|QualType
argument_list|,
argument|pointsTo
argument_list|,
argument|internal::Matcher<QualType>
argument_list|,
argument|InnerMatcher
argument_list|)
block|{
return|return
operator|(
operator|!
name|Node
operator|.
name|isNull
argument_list|()
operator|&&
name|Node
operator|->
name|isPointerType
argument_list|()
operator|&&
name|InnerMatcher
operator|.
name|matches
argument_list|(
name|Node
operator|->
name|getPointeeType
argument_list|()
argument_list|,
name|Finder
argument_list|,
name|Builder
argument_list|)
operator|)
return|;
block|}
comment|/// \brief Overloaded to match the pointee type's declaration.
specifier|inline
name|internal
operator|::
name|Matcher
operator|<
name|QualType
operator|>
name|pointsTo
argument_list|(
argument|const internal::Matcher<Decl>&InnerMatcher
argument_list|)
block|{
return|return
name|pointsTo
argument_list|(
name|internal
operator|::
name|Matcher
operator|<
name|QualType
operator|>
operator|(
name|hasDeclaration
argument_list|(
name|InnerMatcher
argument_list|)
operator|)
argument_list|)
return|;
block|}
comment|/// \brief Matches if the matched type is a reference type and the referenced
comment|/// type matches the specified matcher.
comment|///
comment|/// Example matches X&x and const X&y
comment|///     (matcher = variable(hasType(references(record(hasName("X"))))))
comment|///   class X {
comment|///     void a(X b) {
comment|///       X&x = b;
comment|///       const X&y = b;
comment|///   };
name|AST_MATCHER_P
argument_list|(
argument|QualType
argument_list|,
argument|references
argument_list|,
argument|internal::Matcher<QualType>
argument_list|,
argument|InnerMatcher
argument_list|)
block|{
return|return
operator|(
operator|!
name|Node
operator|.
name|isNull
argument_list|()
operator|&&
name|Node
operator|->
name|isReferenceType
argument_list|()
operator|&&
name|InnerMatcher
operator|.
name|matches
argument_list|(
name|Node
operator|->
name|getPointeeType
argument_list|()
argument_list|,
name|Finder
argument_list|,
name|Builder
argument_list|)
operator|)
return|;
block|}
comment|/// \brief Overloaded to match the referenced type's declaration.
specifier|inline
name|internal
operator|::
name|Matcher
operator|<
name|QualType
operator|>
name|references
argument_list|(
argument|const internal::Matcher<Decl>&InnerMatcher
argument_list|)
block|{
return|return
name|references
argument_list|(
name|internal
operator|::
name|Matcher
operator|<
name|QualType
operator|>
operator|(
name|hasDeclaration
argument_list|(
name|InnerMatcher
argument_list|)
operator|)
argument_list|)
return|;
block|}
name|AST_MATCHER_P
argument_list|(
argument|CXXMemberCallExpr
argument_list|,
argument|onImplicitObjectArgument
argument_list|,
argument|internal::Matcher<Expr>
argument_list|,
argument|InnerMatcher
argument_list|)
block|{
specifier|const
name|Expr
modifier|*
name|ExprNode
init|=
name|const_cast
operator|<
name|CXXMemberCallExpr
operator|&
operator|>
operator|(
name|Node
operator|)
operator|.
name|getImplicitObjectArgument
argument_list|()
decl_stmt|;
return|return
operator|(
name|ExprNode
operator|!=
name|NULL
operator|&&
name|InnerMatcher
operator|.
name|matches
argument_list|(
operator|*
name|ExprNode
argument_list|,
name|Finder
argument_list|,
name|Builder
argument_list|)
operator|)
return|;
block|}
comment|/// \brief Matches if the expression's type either matches the specified
comment|/// matcher, or is a pointer to a type that matches the InnerMatcher.
specifier|inline
name|internal
operator|::
name|Matcher
operator|<
name|CXXMemberCallExpr
operator|>
name|thisPointerType
argument_list|(
argument|const internal::Matcher<QualType>&InnerMatcher
argument_list|)
block|{
return|return
name|onImplicitObjectArgument
argument_list|(
name|anyOf
argument_list|(
name|hasType
argument_list|(
name|InnerMatcher
argument_list|)
argument_list|,
name|hasType
argument_list|(
name|pointsTo
argument_list|(
name|InnerMatcher
argument_list|)
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
comment|/// \brief Overloaded to match the type's declaration.
specifier|inline
name|internal
operator|::
name|Matcher
operator|<
name|CXXMemberCallExpr
operator|>
name|thisPointerType
argument_list|(
argument|const internal::Matcher<Decl>&InnerMatcher
argument_list|)
block|{
return|return
name|onImplicitObjectArgument
argument_list|(
name|anyOf
argument_list|(
name|hasType
argument_list|(
name|InnerMatcher
argument_list|)
argument_list|,
name|hasType
argument_list|(
name|pointsTo
argument_list|(
name|InnerMatcher
argument_list|)
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
comment|/// \brief Matches a DeclRefExpr that refers to a declaration that matches the
comment|/// specified matcher.
comment|///
comment|/// Example matches x in if(x)
comment|///     (matcher = declarationReference(to(variable(hasName("x")))))
comment|///   bool x;
comment|///   if (x) {}
name|AST_MATCHER_P
argument_list|(
argument|DeclRefExpr
argument_list|,
argument|to
argument_list|,
argument|internal::Matcher<Decl>
argument_list|,
argument|InnerMatcher
argument_list|)
block|{
specifier|const
name|Decl
modifier|*
name|DeclNode
init|=
name|Node
operator|.
name|getDecl
argument_list|()
decl_stmt|;
return|return
operator|(
name|DeclNode
operator|!=
name|NULL
operator|&&
name|InnerMatcher
operator|.
name|matches
argument_list|(
operator|*
name|DeclNode
argument_list|,
name|Finder
argument_list|,
name|Builder
argument_list|)
operator|)
return|;
block|}
comment|/// \brief Matches a \c DeclRefExpr that refers to a declaration through a
comment|/// specific using shadow declaration.
comment|///
comment|/// FIXME: This currently only works for functions. Fix.
comment|///
comment|/// Given
comment|///   namespace a { void f() {} }
comment|///   using a::f;
comment|///   void g() {
comment|///     f();     // Matches this ..
comment|///     a::f();  // .. but not this.
comment|///   }
comment|/// declarationReference(throughUsingDeclaration(anything()))
comment|///   matches \c f()
name|AST_MATCHER_P
argument_list|(
argument|DeclRefExpr
argument_list|,
argument|throughUsingDecl
argument_list|,
argument|internal::Matcher<UsingShadowDecl>
argument_list|,
argument|Matcher
argument_list|)
block|{
specifier|const
name|NamedDecl
modifier|*
name|FoundDecl
init|=
name|Node
operator|.
name|getFoundDecl
argument_list|()
decl_stmt|;
if|if
condition|(
specifier|const
name|UsingShadowDecl
modifier|*
name|UsingDecl
init|=
name|llvm
operator|::
name|dyn_cast
operator|<
name|UsingShadowDecl
operator|>
operator|(
name|FoundDecl
operator|)
condition|)
return|return
name|Matcher
operator|.
name|matches
argument_list|(
operator|*
name|UsingDecl
argument_list|,
name|Finder
argument_list|,
name|Builder
argument_list|)
return|;
return|return
name|false
return|;
block|}
comment|/// \brief Matches a variable declaration that has an initializer expression
comment|/// that matches the given matcher.
comment|///
comment|/// Example matches x (matcher = variable(hasInitializer(call())))
comment|///   bool y() { return true; }
comment|///   bool x = y();
name|AST_MATCHER_P
argument_list|(
argument|VarDecl
argument_list|,
argument|hasInitializer
argument_list|,
argument|internal::Matcher<Expr>
argument_list|,
argument|InnerMatcher
argument_list|)
block|{
specifier|const
name|Expr
modifier|*
name|Initializer
init|=
name|Node
operator|.
name|getAnyInitializer
argument_list|()
decl_stmt|;
return|return
operator|(
name|Initializer
operator|!=
name|NULL
operator|&&
name|InnerMatcher
operator|.
name|matches
argument_list|(
operator|*
name|Initializer
argument_list|,
name|Finder
argument_list|,
name|Builder
argument_list|)
operator|)
return|;
block|}
comment|/// \brief Checks that a call expression or a constructor call expression has
comment|/// a specific number of arguments (including absent default arguments).
comment|///
comment|/// Example matches f(0, 0) (matcher = call(argumentCountIs(2)))
comment|///   void f(int x, int y);
comment|///   f(0, 0);
name|AST_POLYMORPHIC_MATCHER_P
argument_list|(
argument|argumentCountIs
argument_list|,
argument|unsigned
argument_list|,
argument|N
argument_list|)
block|{
name|TOOLING_COMPILE_ASSERT
argument_list|(
operator|(
name|llvm
operator|::
name|is_base_of
operator|<
name|CallExpr
operator|,
name|NodeType
operator|>
operator|::
name|value
operator|||
name|llvm
operator|::
name|is_base_of
operator|<
name|CXXConstructExpr
operator|,
name|NodeType
operator|>
operator|::
name|value
operator|)
argument_list|,
name|instantiated_with_wrong_types
argument_list|)
expr_stmt|;
return|return
name|Node
operator|.
name|getNumArgs
argument_list|()
operator|==
name|N
return|;
block|}
comment|/// \brief Matches the n'th argument of a call expression or a constructor
comment|/// call expression.
comment|///
comment|/// Example matches y in x(y)
comment|///     (matcher = call(hasArgument(0, declarationReference())))
comment|///   void x(int) { int y; x(y); }
name|AST_POLYMORPHIC_MATCHER_P2
argument_list|(
argument|hasArgument
argument_list|,
argument|unsigned
argument_list|,
argument|N
argument_list|,
argument|internal::Matcher<Expr>
argument_list|,
argument|InnerMatcher
argument_list|)
block|{
name|TOOLING_COMPILE_ASSERT
argument_list|(
operator|(
name|llvm
operator|::
name|is_base_of
operator|<
name|CallExpr
operator|,
name|NodeType
operator|>
operator|::
name|value
operator|||
name|llvm
operator|::
name|is_base_of
operator|<
name|CXXConstructExpr
operator|,
name|NodeType
operator|>
operator|::
name|value
operator|)
argument_list|,
name|instantiated_with_wrong_types
argument_list|)
expr_stmt|;
return|return
operator|(
name|N
operator|<
name|Node
operator|.
name|getNumArgs
argument_list|()
operator|&&
name|InnerMatcher
operator|.
name|matches
argument_list|(
operator|*
name|Node
operator|.
name|getArg
argument_list|(
name|N
argument_list|)
operator|->
name|IgnoreParenImpCasts
argument_list|()
argument_list|,
name|Finder
argument_list|,
name|Builder
argument_list|)
operator|)
return|;
block|}
comment|/// \brief Matches a constructor initializer.
comment|///
comment|/// Given
comment|///   struct Foo {
comment|///     Foo() : foo_(1) { }
comment|///     int foo_;
comment|///   };
comment|/// record(has(constructor(hasAnyConstructorInitializer(anything()))))
comment|///   record matches Foo, hasAnyConstructorInitializer matches foo_(1)
name|AST_MATCHER_P
argument_list|(
argument|CXXConstructorDecl
argument_list|,
argument|hasAnyConstructorInitializer
argument_list|,
argument|internal::Matcher<CXXCtorInitializer>
argument_list|,
argument|InnerMatcher
argument_list|)
block|{
for|for
control|(
name|CXXConstructorDecl
operator|::
name|init_const_iterator
name|I
operator|=
name|Node
operator|.
name|init_begin
argument_list|()
init|;
name|I
operator|!=
name|Node
operator|.
name|init_end
argument_list|()
condition|;
operator|++
name|I
control|)
block|{
if|if
condition|(
name|InnerMatcher
operator|.
name|matches
argument_list|(
operator|*
operator|*
name|I
argument_list|,
name|Finder
argument_list|,
name|Builder
argument_list|)
condition|)
block|{
return|return
name|true
return|;
block|}
block|}
return|return
name|false
return|;
block|}
comment|/// \brief Matches the field declaration of a constructor initializer.
comment|///
comment|/// Given
comment|///   struct Foo {
comment|///     Foo() : foo_(1) { }
comment|///     int foo_;
comment|///   };
comment|/// record(has(constructor(hasAnyConstructorInitializer(
comment|///     forField(hasName("foo_"))))))
comment|///   matches Foo
comment|/// with forField matching foo_
name|AST_MATCHER_P
argument_list|(
argument|CXXCtorInitializer
argument_list|,
argument|forField
argument_list|,
argument|internal::Matcher<FieldDecl>
argument_list|,
argument|InnerMatcher
argument_list|)
block|{
specifier|const
name|FieldDecl
modifier|*
name|NodeAsDecl
init|=
name|Node
operator|.
name|getMember
argument_list|()
decl_stmt|;
return|return
operator|(
name|NodeAsDecl
operator|!=
name|NULL
operator|&&
name|InnerMatcher
operator|.
name|matches
argument_list|(
operator|*
name|NodeAsDecl
argument_list|,
name|Finder
argument_list|,
name|Builder
argument_list|)
operator|)
return|;
block|}
comment|/// \brief Matches the initializer expression of a constructor initializer.
comment|///
comment|/// Given
comment|///   struct Foo {
comment|///     Foo() : foo_(1) { }
comment|///     int foo_;
comment|///   };
comment|/// record(has(constructor(hasAnyConstructorInitializer(
comment|///     withInitializer(integerLiteral(equals(1)))))))
comment|///   matches Foo
comment|/// with withInitializer matching (1)
name|AST_MATCHER_P
argument_list|(
argument|CXXCtorInitializer
argument_list|,
argument|withInitializer
argument_list|,
argument|internal::Matcher<Expr>
argument_list|,
argument|InnerMatcher
argument_list|)
block|{
specifier|const
name|Expr
modifier|*
name|NodeAsExpr
init|=
name|Node
operator|.
name|getInit
argument_list|()
decl_stmt|;
return|return
operator|(
name|NodeAsExpr
operator|!=
name|NULL
operator|&&
name|InnerMatcher
operator|.
name|matches
argument_list|(
operator|*
name|NodeAsExpr
argument_list|,
name|Finder
argument_list|,
name|Builder
argument_list|)
operator|)
return|;
block|}
comment|/// \brief Matches a contructor initializer if it is explicitly written in
comment|/// code (as opposed to implicitly added by the compiler).
comment|///
comment|/// Given
comment|///   struct Foo {
comment|///     Foo() { }
comment|///     Foo(int) : foo_("A") { }
comment|///     string foo_;
comment|///   };
comment|/// constructor(hasAnyConstructorInitializer(isWritten()))
comment|///   will match Foo(int), but not Foo()
name|AST_MATCHER
argument_list|(
argument|CXXCtorInitializer
argument_list|,
argument|isWritten
argument_list|)
block|{
return|return
name|Node
operator|.
name|isWritten
argument_list|()
return|;
block|}
comment|/// \brief Matches a constructor declaration that has been implicitly added
comment|/// by the compiler (eg. implicit default/copy constructors).
name|AST_MATCHER
argument_list|(
argument|CXXConstructorDecl
argument_list|,
argument|isImplicit
argument_list|)
block|{
return|return
name|Node
operator|.
name|isImplicit
argument_list|()
return|;
block|}
comment|/// \brief Matches any argument of a call expression or a constructor call
comment|/// expression.
comment|///
comment|/// Given
comment|///   void x(int, int, int) { int y; x(1, y, 42); }
comment|/// call(hasAnyArgument(declarationReference()))
comment|///   matches x(1, y, 42)
comment|/// with hasAnyArgument(...)
comment|///   matching y
name|AST_POLYMORPHIC_MATCHER_P
argument_list|(
argument|hasAnyArgument
argument_list|,
argument|internal::Matcher<Expr>
argument_list|,
argument|InnerMatcher
argument_list|)
block|{
name|TOOLING_COMPILE_ASSERT
argument_list|(
operator|(
name|llvm
operator|::
name|is_base_of
operator|<
name|CallExpr
operator|,
name|NodeType
operator|>
operator|::
name|value
operator|||
name|llvm
operator|::
name|is_base_of
operator|<
name|CXXConstructExpr
operator|,
name|NodeType
operator|>
operator|::
name|value
operator|)
argument_list|,
name|instantiated_with_wrong_types
argument_list|)
expr_stmt|;
for|for
control|(
name|unsigned
name|I
init|=
literal|0
init|;
name|I
operator|<
name|Node
operator|.
name|getNumArgs
argument_list|()
condition|;
operator|++
name|I
control|)
block|{
if|if
condition|(
name|InnerMatcher
operator|.
name|matches
argument_list|(
operator|*
name|Node
operator|.
name|getArg
argument_list|(
name|I
argument_list|)
operator|->
name|IgnoreParenImpCasts
argument_list|()
argument_list|,
name|Finder
argument_list|,
name|Builder
argument_list|)
condition|)
block|{
return|return
name|true
return|;
block|}
block|}
return|return
name|false
return|;
block|}
comment|/// \brief Matches the n'th parameter of a function declaration.
comment|///
comment|/// Given
comment|///   class X { void f(int x) {} };
comment|/// method(hasParameter(0, hasType(variable())))
comment|///   matches f(int x) {}
comment|/// with hasParameter(...)
comment|///   matching int x
name|AST_MATCHER_P2
argument_list|(
argument|FunctionDecl
argument_list|,
argument|hasParameter
argument_list|,
argument|unsigned
argument_list|,
argument|N
argument_list|,
argument|internal::Matcher<ParmVarDecl>
argument_list|,
argument|InnerMatcher
argument_list|)
block|{
return|return
operator|(
name|N
operator|<
name|Node
operator|.
name|getNumParams
argument_list|()
operator|&&
name|InnerMatcher
operator|.
name|matches
argument_list|(
operator|*
name|Node
operator|.
name|getParamDecl
argument_list|(
name|N
argument_list|)
argument_list|,
name|Finder
argument_list|,
name|Builder
argument_list|)
operator|)
return|;
block|}
comment|/// \brief Matches any parameter of a function declaration.
comment|///
comment|/// Does not match the 'this' parameter of a method.
comment|///
comment|/// Given
comment|///   class X { void f(int x, int y, int z) {} };
comment|/// method(hasAnyParameter(hasName("y")))
comment|///   matches f(int x, int y, int z) {}
comment|/// with hasAnyParameter(...)
comment|///   matching int y
name|AST_MATCHER_P
argument_list|(
argument|FunctionDecl
argument_list|,
argument|hasAnyParameter
argument_list|,
argument|internal::Matcher<ParmVarDecl>
argument_list|,
argument|InnerMatcher
argument_list|)
block|{
for|for
control|(
name|unsigned
name|I
init|=
literal|0
init|;
name|I
operator|<
name|Node
operator|.
name|getNumParams
argument_list|()
condition|;
operator|++
name|I
control|)
block|{
if|if
condition|(
name|InnerMatcher
operator|.
name|matches
argument_list|(
operator|*
name|Node
operator|.
name|getParamDecl
argument_list|(
name|I
argument_list|)
argument_list|,
name|Finder
argument_list|,
name|Builder
argument_list|)
condition|)
block|{
return|return
name|true
return|;
block|}
block|}
return|return
name|false
return|;
block|}
comment|/// \brief Matches the return type of a function declaration.
comment|///
comment|/// Given:
comment|///   class X { int f() { return 1; } };
comment|/// method(returns(asString("int")))
comment|///   matches int f() { return 1; }
name|AST_MATCHER_P
argument_list|(
argument|FunctionDecl
argument_list|,
argument|returns
argument_list|,
argument|internal::Matcher<QualType>
argument_list|,
argument|Matcher
argument_list|)
block|{
return|return
name|Matcher
operator|.
name|matches
argument_list|(
name|Node
operator|.
name|getResultType
argument_list|()
argument_list|,
name|Finder
argument_list|,
name|Builder
argument_list|)
return|;
block|}
comment|/// \brief Matches the condition expression of an if statement, for loop,
comment|/// or conditional operator.
comment|///
comment|/// Example matches true (matcher = hasCondition(boolLiteral(equals(true))))
comment|///   if (true) {}
name|AST_POLYMORPHIC_MATCHER_P
argument_list|(
argument|hasCondition
argument_list|,
argument|internal::Matcher<Expr>
argument_list|,
argument|InnerMatcher
argument_list|)
block|{
name|TOOLING_COMPILE_ASSERT
argument_list|(
operator|(
name|llvm
operator|::
name|is_base_of
operator|<
name|IfStmt
operator|,
name|NodeType
operator|>
operator|::
name|value
operator|)
operator|||
operator|(
name|llvm
operator|::
name|is_base_of
operator|<
name|ForStmt
operator|,
name|NodeType
operator|>
operator|::
name|value
operator|)
operator|||
operator|(
name|llvm
operator|::
name|is_base_of
operator|<
name|WhileStmt
operator|,
name|NodeType
operator|>
operator|::
name|value
operator|)
operator|||
operator|(
name|llvm
operator|::
name|is_base_of
operator|<
name|DoStmt
operator|,
name|NodeType
operator|>
operator|::
name|value
operator|)
operator|||
operator|(
name|llvm
operator|::
name|is_base_of
operator|<
name|ConditionalOperator
operator|,
name|NodeType
operator|>
operator|::
name|value
operator|)
argument_list|,
name|has_condition_requires_if_statement_conditional_operator_or_loop
argument_list|)
expr_stmt|;
specifier|const
name|Expr
modifier|*
specifier|const
name|Condition
init|=
name|Node
operator|.
name|getCond
argument_list|()
decl_stmt|;
return|return
operator|(
name|Condition
operator|!=
name|NULL
operator|&&
name|InnerMatcher
operator|.
name|matches
argument_list|(
operator|*
name|Condition
argument_list|,
name|Finder
argument_list|,
name|Builder
argument_list|)
operator|)
return|;
block|}
comment|/// \brief Matches the condition variable statement in an if statement.
comment|///
comment|/// Given
comment|///   if (A* a = GetAPointer()) {}
comment|/// hasConditionVariableStatment(...)
comment|///   matches 'A* a = GetAPointer()'.
name|AST_MATCHER_P
argument_list|(
argument|IfStmt
argument_list|,
argument|hasConditionVariableStatement
argument_list|,
argument|internal::Matcher<DeclStmt>
argument_list|,
argument|InnerMatcher
argument_list|)
block|{
specifier|const
name|DeclStmt
modifier|*
specifier|const
name|DeclarationStatement
init|=
name|Node
operator|.
name|getConditionVariableDeclStmt
argument_list|()
decl_stmt|;
return|return
name|DeclarationStatement
operator|!=
name|NULL
operator|&&
name|InnerMatcher
operator|.
name|matches
argument_list|(
operator|*
name|DeclarationStatement
argument_list|,
name|Finder
argument_list|,
name|Builder
argument_list|)
return|;
block|}
comment|/// \brief Matches the index expression of an array subscript expression.
comment|///
comment|/// Given
comment|///   int i[5];
comment|///   void f() { i[1] = 42; }
comment|/// arraySubscriptExpression(hasIndex(integerLiteral()))
comment|///   matches \c i[1] with the \c integerLiteral() matching \c 1
name|AST_MATCHER_P
argument_list|(
argument|ArraySubscriptExpr
argument_list|,
argument|hasIndex
argument_list|,
argument|internal::Matcher<Expr>
argument_list|,
argument|matcher
argument_list|)
block|{
if|if
condition|(
specifier|const
name|Expr
modifier|*
name|Expression
init|=
name|Node
operator|.
name|getIdx
argument_list|()
condition|)
return|return
name|matcher
operator|.
name|matches
argument_list|(
operator|*
name|Expression
argument_list|,
name|Finder
argument_list|,
name|Builder
argument_list|)
return|;
return|return
name|false
return|;
block|}
comment|/// \brief Matches the base expression of an array subscript expression.
comment|///
comment|/// Given
comment|///   int i[5];
comment|///   void f() { i[1] = 42; }
comment|/// arraySubscriptExpression(hasBase(implicitCast(
comment|///     hasSourceExpression(declarationReference()))))
comment|///   matches \c i[1] with the \c declarationReference() matching \c i
name|AST_MATCHER_P
argument_list|(
argument|ArraySubscriptExpr
argument_list|,
argument|hasBase
argument_list|,
argument|internal::Matcher<Expr>
argument_list|,
argument|matcher
argument_list|)
block|{
if|if
condition|(
specifier|const
name|Expr
modifier|*
name|Expression
init|=
name|Node
operator|.
name|getBase
argument_list|()
condition|)
return|return
name|matcher
operator|.
name|matches
argument_list|(
operator|*
name|Expression
argument_list|,
name|Finder
argument_list|,
name|Builder
argument_list|)
return|;
return|return
name|false
return|;
block|}
comment|/// \brief Matches a 'for', 'while', or 'do while' statement that has
comment|/// a given body.
comment|///
comment|/// Given
comment|///   for (;;) {}
comment|/// hasBody(compoundStatement())
comment|///   matches 'for (;;) {}'
comment|/// with compoundStatement()
comment|///   matching '{}'
name|AST_POLYMORPHIC_MATCHER_P
argument_list|(
argument|hasBody
argument_list|,
argument|internal::Matcher<Stmt>
argument_list|,
argument|InnerMatcher
argument_list|)
block|{
name|TOOLING_COMPILE_ASSERT
argument_list|(
operator|(
name|llvm
operator|::
name|is_base_of
operator|<
name|DoStmt
operator|,
name|NodeType
operator|>
operator|::
name|value
operator|)
operator|||
operator|(
name|llvm
operator|::
name|is_base_of
operator|<
name|ForStmt
operator|,
name|NodeType
operator|>
operator|::
name|value
operator|)
operator|||
operator|(
name|llvm
operator|::
name|is_base_of
operator|<
name|WhileStmt
operator|,
name|NodeType
operator|>
operator|::
name|value
operator|)
argument_list|,
name|has_body_requires_for_while_or_do_statement
argument_list|)
expr_stmt|;
specifier|const
name|Stmt
modifier|*
specifier|const
name|Statement
init|=
name|Node
operator|.
name|getBody
argument_list|()
decl_stmt|;
return|return
operator|(
name|Statement
operator|!=
name|NULL
operator|&&
name|InnerMatcher
operator|.
name|matches
argument_list|(
operator|*
name|Statement
argument_list|,
name|Finder
argument_list|,
name|Builder
argument_list|)
operator|)
return|;
block|}
comment|/// \brief Matches compound statements where at least one substatement matches
comment|/// a given matcher.
comment|///
comment|/// Given
comment|///   { {}; 1+2; }
comment|/// hasAnySubstatement(compoundStatement())
comment|///   matches '{ {}; 1+2; }'
comment|/// with compoundStatement()
comment|///   matching '{}'
name|AST_MATCHER_P
argument_list|(
argument|CompoundStmt
argument_list|,
argument|hasAnySubstatement
argument_list|,
argument|internal::Matcher<Stmt>
argument_list|,
argument|InnerMatcher
argument_list|)
block|{
for|for
control|(
name|CompoundStmt
operator|::
name|const_body_iterator
name|It
operator|=
name|Node
operator|.
name|body_begin
argument_list|()
init|;
name|It
operator|!=
name|Node
operator|.
name|body_end
argument_list|()
condition|;
operator|++
name|It
control|)
block|{
if|if
condition|(
name|InnerMatcher
operator|.
name|matches
argument_list|(
operator|*
operator|*
name|It
argument_list|,
name|Finder
argument_list|,
name|Builder
argument_list|)
condition|)
return|return
name|true
return|;
block|}
return|return
name|false
return|;
block|}
comment|/// \brief Checks that a compound statement contains a specific number of
comment|/// child statements.
comment|///
comment|/// Example: Given
comment|///   { for (;;) {} }
comment|/// compoundStatement(statementCountIs(0)))
comment|///   matches '{}'
comment|///   but does not match the outer compound statement.
name|AST_MATCHER_P
argument_list|(
argument|CompoundStmt
argument_list|,
argument|statementCountIs
argument_list|,
argument|unsigned
argument_list|,
argument|N
argument_list|)
block|{
return|return
name|Node
operator|.
name|size
argument_list|()
operator|==
name|N
return|;
block|}
comment|/// \brief Matches literals that are equal to the given value.
comment|///
comment|/// Example matches true (matcher = boolLiteral(equals(true)))
comment|///   true
comment|///
comment|/// Usable as: Matcher<CharacterLiteral>, Matcher<CXXBoolLiteral>,
comment|///            Matcher<FloatingLiteral>, Matcher<IntegerLiteral>
name|template
operator|<
name|typename
name|ValueT
operator|>
name|internal
operator|::
name|PolymorphicMatcherWithParam1
operator|<
name|internal
operator|::
name|ValueEqualsMatcher
operator|,
name|ValueT
operator|>
name|equals
argument_list|(
argument|const ValueT&Value
argument_list|)
block|{
return|return
name|internal
operator|::
name|PolymorphicMatcherWithParam1
operator|<
name|internal
operator|::
name|ValueEqualsMatcher
operator|,
name|ValueT
operator|>
operator|(
name|Value
operator|)
return|;
block|}
comment|/// \brief Matches the operator Name of operator expressions (binary or
comment|/// unary).
comment|///
comment|/// Example matches a || b (matcher = binaryOperator(hasOperatorName("||")))
comment|///   !(a || b)
name|AST_POLYMORPHIC_MATCHER_P
argument_list|(
argument|hasOperatorName
argument_list|,
argument|std::string
argument_list|,
argument|Name
argument_list|)
block|{
name|TOOLING_COMPILE_ASSERT
argument_list|(
operator|(
name|llvm
operator|::
name|is_base_of
operator|<
name|BinaryOperator
operator|,
name|NodeType
operator|>
operator|::
name|value
operator|)
operator|||
operator|(
name|llvm
operator|::
name|is_base_of
operator|<
name|UnaryOperator
operator|,
name|NodeType
operator|>
operator|::
name|value
operator|)
argument_list|,
name|has_condition_requires_if_statement_or_conditional_operator
argument_list|)
expr_stmt|;
return|return
name|Name
operator|==
name|Node
operator|.
name|getOpcodeStr
argument_list|(
name|Node
operator|.
name|getOpcode
argument_list|()
argument_list|)
return|;
block|}
comment|/// \brief Matches the left hand side of binary operator expressions.
comment|///
comment|/// Example matches a (matcher = binaryOperator(hasLHS()))
comment|///   a || b
name|AST_MATCHER_P
argument_list|(
argument|BinaryOperator
argument_list|,
argument|hasLHS
argument_list|,
argument|internal::Matcher<Expr>
argument_list|,
argument|InnerMatcher
argument_list|)
block|{
name|Expr
modifier|*
name|LeftHandSide
init|=
name|Node
operator|.
name|getLHS
argument_list|()
decl_stmt|;
return|return
operator|(
name|LeftHandSide
operator|!=
name|NULL
operator|&&
name|InnerMatcher
operator|.
name|matches
argument_list|(
operator|*
name|LeftHandSide
argument_list|,
name|Finder
argument_list|,
name|Builder
argument_list|)
operator|)
return|;
block|}
comment|/// \brief Matches the right hand side of binary operator expressions.
comment|///
comment|/// Example matches b (matcher = binaryOperator(hasRHS()))
comment|///   a || b
name|AST_MATCHER_P
argument_list|(
argument|BinaryOperator
argument_list|,
argument|hasRHS
argument_list|,
argument|internal::Matcher<Expr>
argument_list|,
argument|InnerMatcher
argument_list|)
block|{
name|Expr
modifier|*
name|RightHandSide
init|=
name|Node
operator|.
name|getRHS
argument_list|()
decl_stmt|;
return|return
operator|(
name|RightHandSide
operator|!=
name|NULL
operator|&&
name|InnerMatcher
operator|.
name|matches
argument_list|(
operator|*
name|RightHandSide
argument_list|,
name|Finder
argument_list|,
name|Builder
argument_list|)
operator|)
return|;
block|}
comment|/// \brief Matches if either the left hand side or the right hand side of a
comment|/// binary operator matches.
specifier|inline
name|internal
operator|::
name|Matcher
operator|<
name|BinaryOperator
operator|>
name|hasEitherOperand
argument_list|(
argument|const internal::Matcher<Expr>&InnerMatcher
argument_list|)
block|{
return|return
name|anyOf
argument_list|(
name|hasLHS
argument_list|(
name|InnerMatcher
argument_list|)
argument_list|,
name|hasRHS
argument_list|(
name|InnerMatcher
argument_list|)
argument_list|)
return|;
block|}
comment|/// \brief Matches if the operand of a unary operator matches.
comment|///
comment|/// Example matches true (matcher = hasOperand(boolLiteral(equals(true))))
comment|///   !true
name|AST_MATCHER_P
argument_list|(
argument|UnaryOperator
argument_list|,
argument|hasUnaryOperand
argument_list|,
argument|internal::Matcher<Expr>
argument_list|,
argument|InnerMatcher
argument_list|)
block|{
specifier|const
name|Expr
modifier|*
specifier|const
name|Operand
init|=
name|Node
operator|.
name|getSubExpr
argument_list|()
decl_stmt|;
return|return
operator|(
name|Operand
operator|!=
name|NULL
operator|&&
name|InnerMatcher
operator|.
name|matches
argument_list|(
operator|*
name|Operand
argument_list|,
name|Finder
argument_list|,
name|Builder
argument_list|)
operator|)
return|;
block|}
comment|/// \brief Matches if the cast's source expression matches the given matcher.
comment|///
comment|/// Example: matches "a string" (matcher =
comment|///                                  hasSourceExpression(constructorCall()))
comment|///
comment|/// class URL { URL(string); };
comment|/// URL url = "a string";
name|AST_MATCHER_P
argument_list|(
argument|CastExpr
argument_list|,
argument|hasSourceExpression
argument_list|,
argument|internal::Matcher<Expr>
argument_list|,
argument|InnerMatcher
argument_list|)
block|{
specifier|const
name|Expr
modifier|*
specifier|const
name|SubExpression
init|=
name|Node
operator|.
name|getSubExpr
argument_list|()
decl_stmt|;
return|return
operator|(
name|SubExpression
operator|!=
name|NULL
operator|&&
name|InnerMatcher
operator|.
name|matches
argument_list|(
operator|*
name|SubExpression
argument_list|,
name|Finder
argument_list|,
name|Builder
argument_list|)
operator|)
return|;
block|}
comment|/// \brief Matches casts whose destination type matches a given matcher.
comment|///
comment|/// (Note: Clang's AST refers to other conversions as "casts" too, and calls
comment|/// actual casts "explicit" casts.)
name|AST_MATCHER_P
argument_list|(
argument|ExplicitCastExpr
argument_list|,
argument|hasDestinationType
argument_list|,
argument|internal::Matcher<QualType>
argument_list|,
argument|InnerMatcher
argument_list|)
block|{
specifier|const
name|QualType
name|NodeType
init|=
name|Node
operator|.
name|getTypeAsWritten
argument_list|()
decl_stmt|;
return|return
name|InnerMatcher
operator|.
name|matches
argument_list|(
name|NodeType
argument_list|,
name|Finder
argument_list|,
name|Builder
argument_list|)
return|;
block|}
comment|/// \brief Matches implicit casts whose destination type matches a given
comment|/// matcher.
comment|///
comment|/// FIXME: Unit test this matcher
name|AST_MATCHER_P
argument_list|(
argument|ImplicitCastExpr
argument_list|,
argument|hasImplicitDestinationType
argument_list|,
argument|internal::Matcher<QualType>
argument_list|,
argument|InnerMatcher
argument_list|)
block|{
return|return
name|InnerMatcher
operator|.
name|matches
argument_list|(
name|Node
operator|.
name|getType
argument_list|()
argument_list|,
name|Finder
argument_list|,
name|Builder
argument_list|)
return|;
block|}
comment|/// \brief Matches the true branch expression of a conditional operator.
comment|///
comment|/// Example matches a
comment|///   condition ? a : b
name|AST_MATCHER_P
argument_list|(
argument|ConditionalOperator
argument_list|,
argument|hasTrueExpression
argument_list|,
argument|internal::Matcher<Expr>
argument_list|,
argument|InnerMatcher
argument_list|)
block|{
name|Expr
modifier|*
name|Expression
init|=
name|Node
operator|.
name|getTrueExpr
argument_list|()
decl_stmt|;
return|return
operator|(
name|Expression
operator|!=
name|NULL
operator|&&
name|InnerMatcher
operator|.
name|matches
argument_list|(
operator|*
name|Expression
argument_list|,
name|Finder
argument_list|,
name|Builder
argument_list|)
operator|)
return|;
block|}
comment|/// \brief Matches the false branch expression of a conditional operator.
comment|///
comment|/// Example matches b
comment|///   condition ? a : b
name|AST_MATCHER_P
argument_list|(
argument|ConditionalOperator
argument_list|,
argument|hasFalseExpression
argument_list|,
argument|internal::Matcher<Expr>
argument_list|,
argument|InnerMatcher
argument_list|)
block|{
name|Expr
modifier|*
name|Expression
init|=
name|Node
operator|.
name|getFalseExpr
argument_list|()
decl_stmt|;
return|return
operator|(
name|Expression
operator|!=
name|NULL
operator|&&
name|InnerMatcher
operator|.
name|matches
argument_list|(
operator|*
name|Expression
argument_list|,
name|Finder
argument_list|,
name|Builder
argument_list|)
operator|)
return|;
block|}
comment|/// \brief Matches if a declaration has a body attached.
comment|///
comment|/// Example matches A, va, fa
comment|///   class A {};
comment|///   class B;  // Doesn't match, as it has no body.
comment|///   int va;
comment|///   extern int vb;  // Doesn't match, as it doesn't define the variable.
comment|///   void fa() {}
comment|///   void fb();  // Doesn't match, as it has no body.
comment|///
comment|/// Usable as: Matcher<TagDecl>, Matcher<VarDecl>, Matcher<FunctionDecl>
specifier|inline
name|internal
operator|::
name|PolymorphicMatcherWithParam0
operator|<
name|internal
operator|::
name|IsDefinitionMatcher
operator|>
name|isDefinition
argument_list|()
block|{
return|return
name|internal
operator|::
name|PolymorphicMatcherWithParam0
operator|<
name|internal
operator|::
name|IsDefinitionMatcher
operator|>
operator|(
operator|)
return|;
block|}
comment|/// \brief Matches the class declaration that the given method declaration
comment|/// belongs to.
comment|///
comment|/// FIXME: Generalize this for other kinds of declarations.
comment|/// FIXME: What other kind of declarations would we need to generalize
comment|/// this to?
comment|///
comment|/// Example matches A() in the last line
comment|///     (matcher = constructorCall(hasDeclaration(method(
comment|///         ofClass(hasName("A"))))))
comment|///   class A {
comment|///    public:
comment|///     A();
comment|///   };
comment|///   A a = A();
name|AST_MATCHER_P
argument_list|(
argument|CXXMethodDecl
argument_list|,
argument|ofClass
argument_list|,
argument|internal::Matcher<CXXRecordDecl>
argument_list|,
argument|InnerMatcher
argument_list|)
block|{
specifier|const
name|CXXRecordDecl
modifier|*
name|Parent
init|=
name|Node
operator|.
name|getParent
argument_list|()
decl_stmt|;
return|return
operator|(
name|Parent
operator|!=
name|NULL
operator|&&
name|InnerMatcher
operator|.
name|matches
argument_list|(
operator|*
name|Parent
argument_list|,
name|Finder
argument_list|,
name|Builder
argument_list|)
operator|)
return|;
block|}
comment|/// \brief Matches member expressions that are called with '->' as opposed
comment|/// to '.'.
comment|///
comment|/// Member calls on the implicit this pointer match as called with '->'.
comment|///
comment|/// Given
comment|///   class Y {
comment|///     void x() { this->x(); x(); Y y; y.x(); a; this->b; Y::b; }
comment|///     int a;
comment|///     static int b;
comment|///   };
comment|/// memberExpression(isArrow())
comment|///   matches this->x, x, y.x, a, this->b
specifier|inline
name|internal
operator|::
name|Matcher
operator|<
name|MemberExpr
operator|>
name|isArrow
argument_list|()
block|{
return|return
name|makeMatcher
argument_list|(
argument|new internal::IsArrowMatcher()
argument_list|)
return|;
block|}
comment|/// \brief Matches QualType nodes that are of integer type.
comment|///
comment|/// Given
comment|///   void a(int);
comment|///   void b(long);
comment|///   void c(double);
comment|/// function(hasAnyParameter(hasType(isInteger())))
comment|/// matches "a(int)", "b(long)", but not "c(double)".
name|AST_MATCHER
argument_list|(
argument|QualType
argument_list|,
argument|isInteger
argument_list|)
block|{
return|return
name|Node
operator|->
name|isIntegerType
argument_list|()
return|;
block|}
comment|/// \brief Matches QualType nodes that are const-qualified, i.e., that
comment|/// include "top-level" const.
comment|///
comment|/// Given
comment|///   void a(int);
comment|///   void b(int const);
comment|///   void c(const int);
comment|///   void d(const int*);
comment|///   void e(int const) {};
comment|/// function(hasAnyParameter(hasType(isConstQualified())))
comment|///   matches "void b(int const)", "void c(const int)" and
comment|///   "void e(int const) {}". It does not match d as there
comment|///   is no top-level const on the parameter type "const int *".
specifier|inline
name|internal
operator|::
name|Matcher
operator|<
name|QualType
operator|>
name|isConstQualified
argument_list|()
block|{
return|return
name|makeMatcher
argument_list|(
argument|new internal::IsConstQualifiedMatcher()
argument_list|)
return|;
block|}
comment|/// \brief Matches a member expression where the member is matched by a
comment|/// given matcher.
comment|///
comment|/// Given
comment|///   struct { int first, second; } first, second;
comment|///   int i(second.first);
comment|///   int j(first.second);
comment|/// memberExpression(member(hasName("first")))
comment|///   matches second.first
comment|///   but not first.second (because the member name there is "second").
name|AST_MATCHER_P
argument_list|(
argument|MemberExpr
argument_list|,
argument|member
argument_list|,
argument|internal::Matcher<ValueDecl>
argument_list|,
argument|InnerMatcher
argument_list|)
block|{
return|return
name|InnerMatcher
operator|.
name|matches
argument_list|(
operator|*
name|Node
operator|.
name|getMemberDecl
argument_list|()
argument_list|,
name|Finder
argument_list|,
name|Builder
argument_list|)
return|;
block|}
comment|/// \brief Matches a member expression where the object expression is
comment|/// matched by a given matcher.
comment|///
comment|/// Given
comment|///   struct X { int m; };
comment|///   void f(X x) { x.m; m; }
comment|/// memberExpression(hasObjectExpression(hasType(record(hasName("X")))))))
comment|///   matches "x.m" and "m"
comment|/// with hasObjectExpression(...)
comment|///   matching "x" and the implicit object expression of "m" which has type X*.
name|AST_MATCHER_P
argument_list|(
argument|MemberExpr
argument_list|,
argument|hasObjectExpression
argument_list|,
argument|internal::Matcher<Expr>
argument_list|,
argument|InnerMatcher
argument_list|)
block|{
return|return
name|InnerMatcher
operator|.
name|matches
argument_list|(
operator|*
name|Node
operator|.
name|getBase
argument_list|()
argument_list|,
name|Finder
argument_list|,
name|Builder
argument_list|)
return|;
block|}
comment|/// \brief Matches any using shadow declaration.
comment|///
comment|/// Given
comment|///   namespace X { void b(); }
comment|///   using X::b;
comment|/// usingDecl(hasAnyUsingShadowDecl(hasName("b"))))
comment|///   matches \code using X::b \endcode
name|AST_MATCHER_P
argument_list|(
argument|UsingDecl
argument_list|,
argument|hasAnyUsingShadowDecl
argument_list|,
argument|internal::Matcher<UsingShadowDecl>
argument_list|,
argument|Matcher
argument_list|)
block|{
for|for
control|(
name|UsingDecl
operator|::
name|shadow_iterator
name|II
operator|=
name|Node
operator|.
name|shadow_begin
argument_list|()
init|;
name|II
operator|!=
name|Node
operator|.
name|shadow_end
argument_list|()
condition|;
operator|++
name|II
control|)
block|{
if|if
condition|(
name|Matcher
operator|.
name|matches
argument_list|(
operator|*
operator|*
name|II
argument_list|,
name|Finder
argument_list|,
name|Builder
argument_list|)
condition|)
return|return
name|true
return|;
block|}
return|return
name|false
return|;
block|}
comment|/// \brief Matches a using shadow declaration where the target declaration is
comment|/// matched by the given matcher.
comment|///
comment|/// Given
comment|///   namespace X { int a; void b(); }
comment|///   using X::a;
comment|///   using X::b;
comment|/// usingDecl(hasAnyUsingShadowDecl(hasTargetDecl(function())))
comment|///   matches \code using X::b \endcode
comment|///   but not \code using X::a \endcode
name|AST_MATCHER_P
argument_list|(
argument|UsingShadowDecl
argument_list|,
argument|hasTargetDecl
argument_list|,
argument|internal::Matcher<NamedDecl>
argument_list|,
argument|Matcher
argument_list|)
block|{
return|return
name|Matcher
operator|.
name|matches
argument_list|(
operator|*
name|Node
operator|.
name|getTargetDecl
argument_list|()
argument_list|,
name|Finder
argument_list|,
name|Builder
argument_list|)
return|;
block|}
comment|/// \brief Matches template instantiations of function, class, or static
comment|/// member variable template instantiations.
comment|///
comment|/// Given
comment|///   template<typename T> class X {}; class A {}; X<A> x;
comment|/// or
comment|///   template<typename T> class X {}; class A {}; template class X<A>;
comment|/// record(hasName("::X"), isTemplateInstantiation())
comment|///   matches the template instantiation of X<A>.
comment|///
comment|/// But given
comment|///   template<typename T> class X {}; class A {};
comment|///   template<> class X<A> {}; X<A> x;
comment|/// record(hasName("::X"), isTemplateInstantiation())
comment|///   does not match, as X<A> is an explicit template specialization.
comment|///
comment|/// Usable as: Matcher<FunctionDecl>, Matcher<VarDecl>, Matcher<CXXRecordDecl>
specifier|inline
name|internal
operator|::
name|PolymorphicMatcherWithParam0
operator|<
name|internal
operator|::
name|IsTemplateInstantiationMatcher
operator|>
name|isTemplateInstantiation
argument_list|()
block|{
return|return
name|internal
operator|::
name|PolymorphicMatcherWithParam0
operator|<
name|internal
operator|::
name|IsTemplateInstantiationMatcher
operator|>
operator|(
operator|)
return|;
block|}
block|}
comment|// end namespace ast_matchers
block|}
end_decl_stmt

begin_comment
comment|// end namespace clang
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|// LLVM_CLANG_AST_MATCHERS_AST_MATCHERS_H
end_comment

end_unit

