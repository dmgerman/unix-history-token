begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===--- DelayedDiagnostic.h - Delayed declarator diagnostics ---*- C++ -*-===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|/// \file
end_comment

begin_comment
comment|/// \brief Defines the classes clang::DelayedDiagnostic and
end_comment

begin_comment
comment|/// clang::AccessedEntity.
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|/// DelayedDiangostic is used to record diagnostics that are being
end_comment

begin_comment
comment|/// conditionally produced during declarator parsing.  Certain kinds of
end_comment

begin_comment
comment|/// diagnostics -- notably deprecation and access control -- are suppressed
end_comment

begin_comment
comment|/// based on semantic properties of the parsed declaration that aren't known
end_comment

begin_comment
comment|/// until it is fully parsed.
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LLVM_CLANG_SEMA_DELAYEDDIAGNOSTIC_H
end_ifndef

begin_define
define|#
directive|define
name|LLVM_CLANG_SEMA_DELAYEDDIAGNOSTIC_H
end_define

begin_include
include|#
directive|include
file|"clang/Sema/Sema.h"
end_include

begin_decl_stmt
name|namespace
name|clang
block|{
name|namespace
name|sema
block|{
comment|/// A declaration being accessed, together with information about how
comment|/// it was accessed.
name|class
name|AccessedEntity
block|{
name|public
label|:
comment|/// A member declaration found through lookup.  The target is the
comment|/// member.
enum|enum
name|MemberNonce
block|{
name|Member
block|}
enum|;
comment|/// A hierarchy (base-to-derived or derived-to-base) conversion.
comment|/// The target is the base class.
enum|enum
name|BaseNonce
block|{
name|Base
block|}
enum|;
name|bool
name|isMemberAccess
argument_list|()
specifier|const
block|{
return|return
name|IsMember
return|;
block|}
name|AccessedEntity
argument_list|(
argument|PartialDiagnostic::StorageAllocator&Allocator
argument_list|,
argument|MemberNonce _
argument_list|,
argument|CXXRecordDecl *NamingClass
argument_list|,
argument|DeclAccessPair FoundDecl
argument_list|,
argument|QualType BaseObjectType
argument_list|)
block|:
name|Access
argument_list|(
name|FoundDecl
operator|.
name|getAccess
argument_list|()
argument_list|)
operator|,
name|IsMember
argument_list|(
name|true
argument_list|)
operator|,
name|Target
argument_list|(
name|FoundDecl
operator|.
name|getDecl
argument_list|()
argument_list|)
operator|,
name|NamingClass
argument_list|(
name|NamingClass
argument_list|)
operator|,
name|BaseObjectType
argument_list|(
name|BaseObjectType
argument_list|)
operator|,
name|Diag
argument_list|(
literal|0
argument_list|,
argument|Allocator
argument_list|)
block|{   }
name|AccessedEntity
argument_list|(
argument|PartialDiagnostic::StorageAllocator&Allocator
argument_list|,
argument|BaseNonce _
argument_list|,
argument|CXXRecordDecl *BaseClass
argument_list|,
argument|CXXRecordDecl *DerivedClass
argument_list|,
argument|AccessSpecifier Access
argument_list|)
operator|:
name|Access
argument_list|(
name|Access
argument_list|)
operator|,
name|IsMember
argument_list|(
name|false
argument_list|)
operator|,
name|Target
argument_list|(
name|BaseClass
argument_list|)
operator|,
name|NamingClass
argument_list|(
name|DerivedClass
argument_list|)
operator|,
name|Diag
argument_list|(
literal|0
argument_list|,
argument|Allocator
argument_list|)
block|{   }
name|bool
name|isQuiet
argument_list|()
specifier|const
block|{
return|return
name|Diag
operator|.
name|getDiagID
argument_list|()
operator|==
literal|0
return|;
block|}
name|AccessSpecifier
name|getAccess
argument_list|()
specifier|const
block|{
return|return
name|AccessSpecifier
argument_list|(
name|Access
argument_list|)
return|;
block|}
comment|// These apply to member decls...
name|NamedDecl
operator|*
name|getTargetDecl
argument_list|()
specifier|const
block|{
return|return
name|Target
return|;
block|}
name|CXXRecordDecl
operator|*
name|getNamingClass
argument_list|()
specifier|const
block|{
return|return
name|NamingClass
return|;
block|}
comment|// ...and these apply to hierarchy conversions.
name|CXXRecordDecl
operator|*
name|getBaseClass
argument_list|()
specifier|const
block|{
name|assert
argument_list|(
operator|!
name|IsMember
argument_list|)
block|;
return|return
name|cast
operator|<
name|CXXRecordDecl
operator|>
operator|(
name|Target
operator|)
return|;
block|}
name|CXXRecordDecl
operator|*
name|getDerivedClass
argument_list|()
specifier|const
block|{
return|return
name|NamingClass
return|;
block|}
comment|/// Retrieves the base object type, important when accessing
comment|/// an instance member.
name|QualType
name|getBaseObjectType
argument_list|()
specifier|const
block|{
return|return
name|BaseObjectType
return|;
block|}
comment|/// Sets a diagnostic to be performed.  The diagnostic is given
comment|/// four (additional) arguments:
comment|///   %0 - 0 if the entity was private, 1 if protected
comment|///   %1 - the DeclarationName of the entity
comment|///   %2 - the TypeDecl type of the naming class
comment|///   %3 - the TypeDecl type of the declaring class
name|void
name|setDiag
parameter_list|(
specifier|const
name|PartialDiagnostic
modifier|&
name|PDiag
parameter_list|)
block|{
name|assert
argument_list|(
name|isQuiet
argument_list|()
operator|&&
literal|"partial diagnostic already defined"
argument_list|)
expr_stmt|;
name|Diag
operator|=
name|PDiag
expr_stmt|;
block|}
name|PartialDiagnostic
modifier|&
name|setDiag
parameter_list|(
name|unsigned
name|DiagID
parameter_list|)
block|{
name|assert
argument_list|(
name|isQuiet
argument_list|()
operator|&&
literal|"partial diagnostic already defined"
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|DiagID
operator|&&
literal|"creating null diagnostic"
argument_list|)
expr_stmt|;
name|Diag
operator|.
name|Reset
argument_list|(
name|DiagID
argument_list|)
expr_stmt|;
return|return
name|Diag
return|;
block|}
specifier|const
name|PartialDiagnostic
operator|&
name|getDiag
argument_list|()
specifier|const
block|{
return|return
name|Diag
return|;
block|}
name|private
label|:
name|unsigned
name|Access
range|:
literal|2
decl_stmt|;
name|unsigned
name|IsMember
range|:
literal|1
decl_stmt|;
name|NamedDecl
modifier|*
name|Target
decl_stmt|;
name|CXXRecordDecl
modifier|*
name|NamingClass
decl_stmt|;
name|QualType
name|BaseObjectType
decl_stmt|;
name|PartialDiagnostic
name|Diag
decl_stmt|;
block|}
empty_stmt|;
comment|/// A diagnostic message which has been conditionally emitted pending
comment|/// the complete parsing of the current declaration.
name|class
name|DelayedDiagnostic
block|{
name|public
label|:
enum|enum
name|DDKind
enum|:
name|unsigned
name|char
block|{
name|Availability
block|,
name|Access
block|,
name|ForbiddenType
block|}
enum|;
name|DDKind
name|Kind
decl_stmt|;
name|bool
name|Triggered
decl_stmt|;
name|SourceLocation
name|Loc
decl_stmt|;
name|void
name|Destroy
parameter_list|()
function_decl|;
specifier|static
name|DelayedDiagnostic
name|makeAvailability
parameter_list|(
name|AvailabilityResult
name|AR
parameter_list|,
name|SourceLocation
name|Loc
parameter_list|,
specifier|const
name|NamedDecl
modifier|*
name|ReferringDecl
parameter_list|,
specifier|const
name|NamedDecl
modifier|*
name|OffendingDecl
parameter_list|,
specifier|const
name|ObjCInterfaceDecl
modifier|*
name|UnknownObjCClass
parameter_list|,
specifier|const
name|ObjCPropertyDecl
modifier|*
name|ObjCProperty
parameter_list|,
name|StringRef
name|Msg
parameter_list|,
name|bool
name|ObjCPropertyAccess
parameter_list|)
function_decl|;
specifier|static
name|DelayedDiagnostic
name|makeAccess
parameter_list|(
name|SourceLocation
name|Loc
parameter_list|,
specifier|const
name|AccessedEntity
modifier|&
name|Entity
parameter_list|)
block|{
name|DelayedDiagnostic
name|DD
decl_stmt|;
name|DD
operator|.
name|Kind
operator|=
name|Access
expr_stmt|;
name|DD
operator|.
name|Triggered
operator|=
name|false
expr_stmt|;
name|DD
operator|.
name|Loc
operator|=
name|Loc
expr_stmt|;
name|new
argument_list|(
argument|&DD.getAccessData()
argument_list|)
name|AccessedEntity
argument_list|(
name|Entity
argument_list|)
expr_stmt|;
return|return
name|DD
return|;
block|}
specifier|static
name|DelayedDiagnostic
name|makeForbiddenType
parameter_list|(
name|SourceLocation
name|loc
parameter_list|,
name|unsigned
name|diagnostic
parameter_list|,
name|QualType
name|type
parameter_list|,
name|unsigned
name|argument
parameter_list|)
block|{
name|DelayedDiagnostic
name|DD
decl_stmt|;
name|DD
operator|.
name|Kind
operator|=
name|ForbiddenType
expr_stmt|;
name|DD
operator|.
name|Triggered
operator|=
name|false
expr_stmt|;
name|DD
operator|.
name|Loc
operator|=
name|loc
expr_stmt|;
name|DD
operator|.
name|ForbiddenTypeData
operator|.
name|Diagnostic
operator|=
name|diagnostic
expr_stmt|;
name|DD
operator|.
name|ForbiddenTypeData
operator|.
name|OperandType
operator|=
name|type
operator|.
name|getAsOpaquePtr
argument_list|()
expr_stmt|;
name|DD
operator|.
name|ForbiddenTypeData
operator|.
name|Argument
operator|=
name|argument
expr_stmt|;
return|return
name|DD
return|;
block|}
name|AccessedEntity
modifier|&
name|getAccessData
parameter_list|()
block|{
name|assert
argument_list|(
name|Kind
operator|==
name|Access
operator|&&
literal|"Not an access diagnostic."
argument_list|)
expr_stmt|;
return|return
operator|*
name|reinterpret_cast
operator|<
name|AccessedEntity
operator|*
operator|>
operator|(
name|AccessData
operator|)
return|;
block|}
specifier|const
name|AccessedEntity
operator|&
name|getAccessData
argument_list|()
specifier|const
block|{
name|assert
argument_list|(
name|Kind
operator|==
name|Access
operator|&&
literal|"Not an access diagnostic."
argument_list|)
block|;
return|return
operator|*
name|reinterpret_cast
operator|<
specifier|const
name|AccessedEntity
operator|*
operator|>
operator|(
name|AccessData
operator|)
return|;
block|}
specifier|const
name|NamedDecl
operator|*
name|getAvailabilityReferringDecl
argument_list|()
specifier|const
block|{
name|assert
argument_list|(
name|Kind
operator|==
name|Availability
operator|&&
literal|"Not an availability diagnostic."
argument_list|)
block|;
return|return
name|AvailabilityData
operator|.
name|ReferringDecl
return|;
block|}
specifier|const
name|NamedDecl
operator|*
name|getAvailabilityOffendingDecl
argument_list|()
specifier|const
block|{
return|return
name|AvailabilityData
operator|.
name|OffendingDecl
return|;
block|}
name|StringRef
name|getAvailabilityMessage
argument_list|()
specifier|const
block|{
name|assert
argument_list|(
name|Kind
operator|==
name|Availability
operator|&&
literal|"Not an availability diagnostic."
argument_list|)
block|;
return|return
name|StringRef
argument_list|(
name|AvailabilityData
operator|.
name|Message
argument_list|,
name|AvailabilityData
operator|.
name|MessageLen
argument_list|)
return|;
block|}
name|AvailabilityResult
name|getAvailabilityResult
argument_list|()
specifier|const
block|{
name|assert
argument_list|(
name|Kind
operator|==
name|Availability
operator|&&
literal|"Not an availability diagnostic."
argument_list|)
block|;
return|return
name|AvailabilityData
operator|.
name|AR
return|;
block|}
comment|/// The diagnostic ID to emit.  Used like so:
comment|///   Diag(diag.Loc, diag.getForbiddenTypeDiagnostic())
comment|///<< diag.getForbiddenTypeOperand()
comment|///<< diag.getForbiddenTypeArgument();
name|unsigned
name|getForbiddenTypeDiagnostic
argument_list|()
specifier|const
block|{
name|assert
argument_list|(
name|Kind
operator|==
name|ForbiddenType
operator|&&
literal|"not a forbidden-type diagnostic"
argument_list|)
block|;
return|return
name|ForbiddenTypeData
operator|.
name|Diagnostic
return|;
block|}
name|unsigned
name|getForbiddenTypeArgument
argument_list|()
specifier|const
block|{
name|assert
argument_list|(
name|Kind
operator|==
name|ForbiddenType
operator|&&
literal|"not a forbidden-type diagnostic"
argument_list|)
block|;
return|return
name|ForbiddenTypeData
operator|.
name|Argument
return|;
block|}
name|QualType
name|getForbiddenTypeOperand
argument_list|()
specifier|const
block|{
name|assert
argument_list|(
name|Kind
operator|==
name|ForbiddenType
operator|&&
literal|"not a forbidden-type diagnostic"
argument_list|)
block|;
return|return
name|QualType
operator|::
name|getFromOpaquePtr
argument_list|(
name|ForbiddenTypeData
operator|.
name|OperandType
argument_list|)
return|;
block|}
specifier|const
name|ObjCInterfaceDecl
operator|*
name|getUnknownObjCClass
argument_list|()
specifier|const
block|{
return|return
name|AvailabilityData
operator|.
name|UnknownObjCClass
return|;
block|}
specifier|const
name|ObjCPropertyDecl
operator|*
name|getObjCProperty
argument_list|()
specifier|const
block|{
return|return
name|AvailabilityData
operator|.
name|ObjCProperty
return|;
block|}
name|bool
name|getObjCPropertyAccess
argument_list|()
specifier|const
block|{
return|return
name|AvailabilityData
operator|.
name|ObjCPropertyAccess
return|;
block|}
name|private
label|:
struct|struct
name|AD
block|{
specifier|const
name|NamedDecl
modifier|*
name|ReferringDecl
decl_stmt|;
specifier|const
name|NamedDecl
modifier|*
name|OffendingDecl
decl_stmt|;
specifier|const
name|ObjCInterfaceDecl
modifier|*
name|UnknownObjCClass
decl_stmt|;
specifier|const
name|ObjCPropertyDecl
modifier|*
name|ObjCProperty
decl_stmt|;
specifier|const
name|char
modifier|*
name|Message
decl_stmt|;
name|size_t
name|MessageLen
decl_stmt|;
name|AvailabilityResult
name|AR
decl_stmt|;
name|bool
name|ObjCPropertyAccess
decl_stmt|;
block|}
struct|;
struct|struct
name|FTD
block|{
name|unsigned
name|Diagnostic
decl_stmt|;
name|unsigned
name|Argument
decl_stmt|;
name|void
modifier|*
name|OperandType
decl_stmt|;
block|}
struct|;
union|union
block|{
name|struct
name|AD
name|AvailabilityData
decl_stmt|;
name|struct
name|FTD
name|ForbiddenTypeData
decl_stmt|;
comment|/// Access control.
name|char
name|AccessData
index|[
sizeof|sizeof
argument_list|(
name|AccessedEntity
argument_list|)
index|]
decl_stmt|;
block|}
union|;
block|}
empty_stmt|;
comment|/// \brief A collection of diagnostics which were delayed.
name|class
name|DelayedDiagnosticPool
block|{
specifier|const
name|DelayedDiagnosticPool
modifier|*
name|Parent
decl_stmt|;
name|SmallVector
operator|<
name|DelayedDiagnostic
operator|,
literal|4
operator|>
name|Diagnostics
expr_stmt|;
name|DelayedDiagnosticPool
argument_list|(
specifier|const
name|DelayedDiagnosticPool
operator|&
argument_list|)
operator|=
name|delete
expr_stmt|;
name|void
name|operator
init|=
operator|(
specifier|const
name|DelayedDiagnosticPool
operator|&
operator|)
operator|=
name|delete
decl_stmt|;
name|public
label|:
name|DelayedDiagnosticPool
argument_list|(
specifier|const
name|DelayedDiagnosticPool
operator|*
name|parent
argument_list|)
operator|:
name|Parent
argument_list|(
argument|parent
argument_list|)
block|{}
operator|~
name|DelayedDiagnosticPool
argument_list|()
block|{
for|for
control|(
name|SmallVectorImpl
operator|<
name|DelayedDiagnostic
operator|>
operator|::
name|iterator
name|i
operator|=
name|Diagnostics
operator|.
name|begin
argument_list|()
operator|,
name|e
operator|=
name|Diagnostics
operator|.
name|end
argument_list|()
init|;
name|i
operator|!=
name|e
condition|;
operator|++
name|i
control|)
name|i
operator|->
name|Destroy
argument_list|()
expr_stmt|;
block|}
name|DelayedDiagnosticPool
argument_list|(
name|DelayedDiagnosticPool
operator|&&
name|Other
argument_list|)
operator|:
name|Parent
argument_list|(
name|Other
operator|.
name|Parent
argument_list|)
operator|,
name|Diagnostics
argument_list|(
argument|std::move(Other.Diagnostics)
argument_list|)
block|{
name|Other
operator|.
name|Diagnostics
operator|.
name|clear
argument_list|()
block|;   }
name|DelayedDiagnosticPool
operator|&
name|operator
operator|=
operator|(
name|DelayedDiagnosticPool
operator|&&
name|Other
operator|)
block|{
name|Parent
operator|=
name|Other
operator|.
name|Parent
block|;
name|Diagnostics
operator|=
name|std
operator|::
name|move
argument_list|(
name|Other
operator|.
name|Diagnostics
argument_list|)
block|;
name|Other
operator|.
name|Diagnostics
operator|.
name|clear
argument_list|()
block|;
return|return
operator|*
name|this
return|;
block|}
specifier|const
name|DelayedDiagnosticPool
operator|*
name|getParent
argument_list|()
specifier|const
block|{
return|return
name|Parent
return|;
block|}
comment|/// Does this pool, or any of its ancestors, contain any diagnostics?
name|bool
name|empty
argument_list|()
specifier|const
block|{
return|return
operator|(
name|Diagnostics
operator|.
name|empty
argument_list|()
operator|&&
operator|(
operator|!
name|Parent
operator|||
name|Parent
operator|->
name|empty
argument_list|()
operator|)
operator|)
return|;
block|}
comment|/// Add a diagnostic to this pool.
name|void
name|add
parameter_list|(
specifier|const
name|DelayedDiagnostic
modifier|&
name|diag
parameter_list|)
block|{
name|Diagnostics
operator|.
name|push_back
argument_list|(
name|diag
argument_list|)
expr_stmt|;
block|}
comment|/// Steal the diagnostics from the given pool.
name|void
name|steal
parameter_list|(
name|DelayedDiagnosticPool
modifier|&
name|pool
parameter_list|)
block|{
if|if
condition|(
name|pool
operator|.
name|Diagnostics
operator|.
name|empty
argument_list|()
condition|)
return|return;
if|if
condition|(
name|Diagnostics
operator|.
name|empty
argument_list|()
condition|)
block|{
name|Diagnostics
operator|=
name|std
operator|::
name|move
argument_list|(
name|pool
operator|.
name|Diagnostics
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Diagnostics
operator|.
name|append
argument_list|(
name|pool
operator|.
name|pool_begin
argument_list|()
argument_list|,
name|pool
operator|.
name|pool_end
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|pool
operator|.
name|Diagnostics
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
typedef|typedef
name|SmallVectorImpl
operator|<
name|DelayedDiagnostic
operator|>
operator|::
name|const_iterator
name|pool_iterator
expr_stmt|;
name|pool_iterator
name|pool_begin
argument_list|()
specifier|const
block|{
return|return
name|Diagnostics
operator|.
name|begin
argument_list|()
return|;
block|}
name|pool_iterator
name|pool_end
argument_list|()
specifier|const
block|{
return|return
name|Diagnostics
operator|.
name|end
argument_list|()
return|;
block|}
name|bool
name|pool_empty
argument_list|()
specifier|const
block|{
return|return
name|Diagnostics
operator|.
name|empty
argument_list|()
return|;
block|}
block|}
empty_stmt|;
block|}
comment|/// Add a diagnostic to the current delay pool.
specifier|inline
name|void
name|Sema
operator|::
name|DelayedDiagnostics
operator|::
name|add
argument_list|(
argument|const sema::DelayedDiagnostic&diag
argument_list|)
block|{
name|assert
argument_list|(
name|shouldDelayDiagnostics
argument_list|()
operator|&&
literal|"trying to delay without pool"
argument_list|)
block|;
name|CurPool
operator|->
name|add
argument_list|(
name|diag
argument_list|)
block|; }
block|}
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

end_unit

