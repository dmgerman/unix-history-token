begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===--- DeclSpec.h - Parsed declaration specifiers -------------*- C++ -*-===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|/// \file
end_comment

begin_comment
comment|/// \brief This file defines the classes used to store parsed information about
end_comment

begin_comment
comment|/// declaration-specifiers and declarators.
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|/// \verbatim
end_comment

begin_comment
comment|///   static const int volatile x, *y, *(*(*z)[10])(const void *x);
end_comment

begin_comment
comment|///   ------------------------- -  --  ---------------------------
end_comment

begin_comment
comment|///     declaration-specifiers  \  |   /
end_comment

begin_comment
comment|///                            declarators
end_comment

begin_comment
comment|/// \endverbatim
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LLVM_CLANG_SEMA_DECLSPEC_H
end_ifndef

begin_define
define|#
directive|define
name|LLVM_CLANG_SEMA_DECLSPEC_H
end_define

begin_include
include|#
directive|include
file|"clang/AST/NestedNameSpecifier.h"
end_include

begin_include
include|#
directive|include
file|"clang/Basic/ExceptionSpecificationType.h"
end_include

begin_include
include|#
directive|include
file|"clang/Basic/Lambda.h"
end_include

begin_include
include|#
directive|include
file|"clang/Basic/OperatorKinds.h"
end_include

begin_include
include|#
directive|include
file|"clang/Basic/Specifiers.h"
end_include

begin_include
include|#
directive|include
file|"clang/Lex/Token.h"
end_include

begin_include
include|#
directive|include
file|"clang/Sema/AttributeList.h"
end_include

begin_include
include|#
directive|include
file|"clang/Sema/Ownership.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/SmallVector.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/Compiler.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/ErrorHandling.h"
end_include

begin_decl_stmt
name|namespace
name|clang
block|{
name|class
name|ASTContext
decl_stmt|;
name|class
name|CXXRecordDecl
decl_stmt|;
name|class
name|TypeLoc
decl_stmt|;
name|class
name|LangOptions
decl_stmt|;
name|class
name|IdentifierInfo
decl_stmt|;
name|class
name|NamespaceAliasDecl
decl_stmt|;
name|class
name|NamespaceDecl
decl_stmt|;
name|class
name|ObjCDeclSpec
decl_stmt|;
name|class
name|Sema
decl_stmt|;
name|class
name|Declarator
decl_stmt|;
struct_decl|struct
name|TemplateIdAnnotation
struct_decl|;
comment|/// \brief Represents a C++ nested-name-specifier or a global scope specifier.
comment|///
comment|/// These can be in 3 states:
comment|///   1) Not present, identified by isEmpty()
comment|///   2) Present, identified by isNotEmpty()
comment|///      2.a) Valid, identified by isValid()
comment|///      2.b) Invalid, identified by isInvalid().
comment|///
comment|/// isSet() is deprecated because it mostly corresponded to "valid" but was
comment|/// often used as if it meant "present".
comment|///
comment|/// The actual scope is described by getScopeRep().
name|class
name|CXXScopeSpec
block|{
name|SourceRange
name|Range
decl_stmt|;
name|NestedNameSpecifierLocBuilder
name|Builder
decl_stmt|;
name|public
label|:
name|SourceRange
name|getRange
argument_list|()
specifier|const
block|{
return|return
name|Range
return|;
block|}
name|void
name|setRange
parameter_list|(
name|SourceRange
name|R
parameter_list|)
block|{
name|Range
operator|=
name|R
expr_stmt|;
block|}
name|void
name|setBeginLoc
parameter_list|(
name|SourceLocation
name|Loc
parameter_list|)
block|{
name|Range
operator|.
name|setBegin
argument_list|(
name|Loc
argument_list|)
expr_stmt|;
block|}
name|void
name|setEndLoc
parameter_list|(
name|SourceLocation
name|Loc
parameter_list|)
block|{
name|Range
operator|.
name|setEnd
argument_list|(
name|Loc
argument_list|)
expr_stmt|;
block|}
name|SourceLocation
name|getBeginLoc
argument_list|()
specifier|const
block|{
return|return
name|Range
operator|.
name|getBegin
argument_list|()
return|;
block|}
name|SourceLocation
name|getEndLoc
argument_list|()
specifier|const
block|{
return|return
name|Range
operator|.
name|getEnd
argument_list|()
return|;
block|}
comment|/// \brief Retrieve the representation of the nested-name-specifier.
name|NestedNameSpecifier
operator|*
name|getScopeRep
argument_list|()
specifier|const
block|{
return|return
name|Builder
operator|.
name|getRepresentation
argument_list|()
return|;
block|}
comment|/// \brief Extend the current nested-name-specifier by another
comment|/// nested-name-specifier component of the form 'type::'.
comment|///
comment|/// \param Context The AST context in which this nested-name-specifier
comment|/// resides.
comment|///
comment|/// \param TemplateKWLoc The location of the 'template' keyword, if present.
comment|///
comment|/// \param TL The TypeLoc that describes the type preceding the '::'.
comment|///
comment|/// \param ColonColonLoc The location of the trailing '::'.
name|void
name|Extend
parameter_list|(
name|ASTContext
modifier|&
name|Context
parameter_list|,
name|SourceLocation
name|TemplateKWLoc
parameter_list|,
name|TypeLoc
name|TL
parameter_list|,
name|SourceLocation
name|ColonColonLoc
parameter_list|)
function_decl|;
comment|/// \brief Extend the current nested-name-specifier by another
comment|/// nested-name-specifier component of the form 'identifier::'.
comment|///
comment|/// \param Context The AST context in which this nested-name-specifier
comment|/// resides.
comment|///
comment|/// \param Identifier The identifier.
comment|///
comment|/// \param IdentifierLoc The location of the identifier.
comment|///
comment|/// \param ColonColonLoc The location of the trailing '::'.
name|void
name|Extend
parameter_list|(
name|ASTContext
modifier|&
name|Context
parameter_list|,
name|IdentifierInfo
modifier|*
name|Identifier
parameter_list|,
name|SourceLocation
name|IdentifierLoc
parameter_list|,
name|SourceLocation
name|ColonColonLoc
parameter_list|)
function_decl|;
comment|/// \brief Extend the current nested-name-specifier by another
comment|/// nested-name-specifier component of the form 'namespace::'.
comment|///
comment|/// \param Context The AST context in which this nested-name-specifier
comment|/// resides.
comment|///
comment|/// \param Namespace The namespace.
comment|///
comment|/// \param NamespaceLoc The location of the namespace name.
comment|///
comment|/// \param ColonColonLoc The location of the trailing '::'.
name|void
name|Extend
parameter_list|(
name|ASTContext
modifier|&
name|Context
parameter_list|,
name|NamespaceDecl
modifier|*
name|Namespace
parameter_list|,
name|SourceLocation
name|NamespaceLoc
parameter_list|,
name|SourceLocation
name|ColonColonLoc
parameter_list|)
function_decl|;
comment|/// \brief Extend the current nested-name-specifier by another
comment|/// nested-name-specifier component of the form 'namespace-alias::'.
comment|///
comment|/// \param Context The AST context in which this nested-name-specifier
comment|/// resides.
comment|///
comment|/// \param Alias The namespace alias.
comment|///
comment|/// \param AliasLoc The location of the namespace alias
comment|/// name.
comment|///
comment|/// \param ColonColonLoc The location of the trailing '::'.
name|void
name|Extend
parameter_list|(
name|ASTContext
modifier|&
name|Context
parameter_list|,
name|NamespaceAliasDecl
modifier|*
name|Alias
parameter_list|,
name|SourceLocation
name|AliasLoc
parameter_list|,
name|SourceLocation
name|ColonColonLoc
parameter_list|)
function_decl|;
comment|/// \brief Turn this (empty) nested-name-specifier into the global
comment|/// nested-name-specifier '::'.
name|void
name|MakeGlobal
parameter_list|(
name|ASTContext
modifier|&
name|Context
parameter_list|,
name|SourceLocation
name|ColonColonLoc
parameter_list|)
function_decl|;
comment|/// \brief Turns this (empty) nested-name-specifier into '__super'
comment|/// nested-name-specifier.
comment|///
comment|/// \param Context The AST context in which this nested-name-specifier
comment|/// resides.
comment|///
comment|/// \param RD The declaration of the class in which nested-name-specifier
comment|/// appeared.
comment|///
comment|/// \param SuperLoc The location of the '__super' keyword.
comment|/// name.
comment|///
comment|/// \param ColonColonLoc The location of the trailing '::'.
name|void
name|MakeSuper
parameter_list|(
name|ASTContext
modifier|&
name|Context
parameter_list|,
name|CXXRecordDecl
modifier|*
name|RD
parameter_list|,
name|SourceLocation
name|SuperLoc
parameter_list|,
name|SourceLocation
name|ColonColonLoc
parameter_list|)
function_decl|;
comment|/// \brief Make a new nested-name-specifier from incomplete source-location
comment|/// information.
comment|///
comment|/// FIXME: This routine should be used very, very rarely, in cases where we
comment|/// need to synthesize a nested-name-specifier. Most code should instead use
comment|/// \c Adopt() with a proper \c NestedNameSpecifierLoc.
name|void
name|MakeTrivial
parameter_list|(
name|ASTContext
modifier|&
name|Context
parameter_list|,
name|NestedNameSpecifier
modifier|*
name|Qualifier
parameter_list|,
name|SourceRange
name|R
parameter_list|)
function_decl|;
comment|/// \brief Adopt an existing nested-name-specifier (with source-range
comment|/// information).
name|void
name|Adopt
parameter_list|(
name|NestedNameSpecifierLoc
name|Other
parameter_list|)
function_decl|;
comment|/// \brief Retrieve a nested-name-specifier with location information, copied
comment|/// into the given AST context.
comment|///
comment|/// \param Context The context into which this nested-name-specifier will be
comment|/// copied.
name|NestedNameSpecifierLoc
name|getWithLocInContext
argument_list|(
name|ASTContext
operator|&
name|Context
argument_list|)
decl|const
decl_stmt|;
comment|/// \brief Retrieve the location of the name in the last qualifier
comment|/// in this nested name specifier.
comment|///
comment|/// For example, the location of \c bar
comment|/// in
comment|/// \verbatim
comment|///   \::foo::bar<0>::
comment|///           ^~~
comment|/// \endverbatim
name|SourceLocation
name|getLastQualifierNameLoc
argument_list|()
specifier|const
expr_stmt|;
comment|/// No scope specifier.
name|bool
name|isEmpty
argument_list|()
specifier|const
block|{
return|return
operator|!
name|Range
operator|.
name|isValid
argument_list|()
return|;
block|}
comment|/// A scope specifier is present, but may be valid or invalid.
name|bool
name|isNotEmpty
argument_list|()
specifier|const
block|{
return|return
operator|!
name|isEmpty
argument_list|()
return|;
block|}
comment|/// An error occurred during parsing of the scope specifier.
name|bool
name|isInvalid
argument_list|()
specifier|const
block|{
return|return
name|isNotEmpty
argument_list|()
operator|&&
name|getScopeRep
argument_list|()
operator|==
name|nullptr
return|;
block|}
comment|/// A scope specifier is present, and it refers to a real scope.
name|bool
name|isValid
argument_list|()
specifier|const
block|{
return|return
name|isNotEmpty
argument_list|()
operator|&&
name|getScopeRep
argument_list|()
operator|!=
name|nullptr
return|;
block|}
comment|/// \brief Indicate that this nested-name-specifier is invalid.
name|void
name|SetInvalid
parameter_list|(
name|SourceRange
name|R
parameter_list|)
block|{
name|assert
argument_list|(
name|R
operator|.
name|isValid
argument_list|()
operator|&&
literal|"Must have a valid source range"
argument_list|)
expr_stmt|;
if|if
condition|(
name|Range
operator|.
name|getBegin
argument_list|()
operator|.
name|isInvalid
argument_list|()
condition|)
name|Range
operator|.
name|setBegin
argument_list|(
name|R
operator|.
name|getBegin
argument_list|()
argument_list|)
expr_stmt|;
name|Range
operator|.
name|setEnd
argument_list|(
name|R
operator|.
name|getEnd
argument_list|()
argument_list|)
expr_stmt|;
name|Builder
operator|.
name|Clear
argument_list|()
expr_stmt|;
block|}
comment|/// Deprecated.  Some call sites intend isNotEmpty() while others intend
comment|/// isValid().
name|bool
name|isSet
argument_list|()
specifier|const
block|{
return|return
name|getScopeRep
argument_list|()
operator|!=
name|nullptr
return|;
block|}
name|void
name|clear
parameter_list|()
block|{
name|Range
operator|=
name|SourceRange
argument_list|()
expr_stmt|;
name|Builder
operator|.
name|Clear
argument_list|()
expr_stmt|;
block|}
comment|/// \brief Retrieve the data associated with the source-location information.
name|char
operator|*
name|location_data
argument_list|()
specifier|const
block|{
return|return
name|Builder
operator|.
name|getBuffer
argument_list|()
operator|.
name|first
return|;
block|}
comment|/// \brief Retrieve the size of the data associated with source-location
comment|/// information.
name|unsigned
name|location_size
argument_list|()
specifier|const
block|{
return|return
name|Builder
operator|.
name|getBuffer
argument_list|()
operator|.
name|second
return|;
block|}
block|}
empty_stmt|;
comment|/// \brief Captures information about "declaration specifiers".
comment|///
comment|/// "Declaration specifiers" encompasses storage-class-specifiers,
comment|/// type-specifiers, type-qualifiers, and function-specifiers.
name|class
name|DeclSpec
block|{
name|public
label|:
comment|/// \brief storage-class-specifier
comment|/// \note The order of these enumerators is important for diagnostics.
enum|enum
name|SCS
block|{
name|SCS_unspecified
init|=
literal|0
block|,
name|SCS_typedef
block|,
name|SCS_extern
block|,
name|SCS_static
block|,
name|SCS_auto
block|,
name|SCS_register
block|,
name|SCS_private_extern
block|,
name|SCS_mutable
block|}
enum|;
comment|// Import thread storage class specifier enumeration and constants.
comment|// These can be combined with SCS_extern and SCS_static.
typedef|typedef
name|ThreadStorageClassSpecifier
name|TSCS
typedef|;
specifier|static
specifier|const
name|TSCS
name|TSCS_unspecified
init|=
name|clang
operator|::
name|TSCS_unspecified
decl_stmt|;
specifier|static
specifier|const
name|TSCS
name|TSCS___thread
init|=
name|clang
operator|::
name|TSCS___thread
decl_stmt|;
specifier|static
specifier|const
name|TSCS
name|TSCS_thread_local
init|=
name|clang
operator|::
name|TSCS_thread_local
decl_stmt|;
specifier|static
specifier|const
name|TSCS
name|TSCS__Thread_local
init|=
name|clang
operator|::
name|TSCS__Thread_local
decl_stmt|;
comment|// Import type specifier width enumeration and constants.
typedef|typedef
name|TypeSpecifierWidth
name|TSW
typedef|;
specifier|static
specifier|const
name|TSW
name|TSW_unspecified
init|=
name|clang
operator|::
name|TSW_unspecified
decl_stmt|;
specifier|static
specifier|const
name|TSW
name|TSW_short
init|=
name|clang
operator|::
name|TSW_short
decl_stmt|;
specifier|static
specifier|const
name|TSW
name|TSW_long
init|=
name|clang
operator|::
name|TSW_long
decl_stmt|;
specifier|static
specifier|const
name|TSW
name|TSW_longlong
init|=
name|clang
operator|::
name|TSW_longlong
decl_stmt|;
enum|enum
name|TSC
block|{
name|TSC_unspecified
block|,
name|TSC_imaginary
block|,
name|TSC_complex
block|}
enum|;
comment|// Import type specifier sign enumeration and constants.
typedef|typedef
name|TypeSpecifierSign
name|TSS
typedef|;
specifier|static
specifier|const
name|TSS
name|TSS_unspecified
init|=
name|clang
operator|::
name|TSS_unspecified
decl_stmt|;
specifier|static
specifier|const
name|TSS
name|TSS_signed
init|=
name|clang
operator|::
name|TSS_signed
decl_stmt|;
specifier|static
specifier|const
name|TSS
name|TSS_unsigned
init|=
name|clang
operator|::
name|TSS_unsigned
decl_stmt|;
comment|// Import type specifier type enumeration and constants.
typedef|typedef
name|TypeSpecifierType
name|TST
typedef|;
specifier|static
specifier|const
name|TST
name|TST_unspecified
init|=
name|clang
operator|::
name|TST_unspecified
decl_stmt|;
specifier|static
specifier|const
name|TST
name|TST_void
init|=
name|clang
operator|::
name|TST_void
decl_stmt|;
specifier|static
specifier|const
name|TST
name|TST_char
init|=
name|clang
operator|::
name|TST_char
decl_stmt|;
specifier|static
specifier|const
name|TST
name|TST_wchar
init|=
name|clang
operator|::
name|TST_wchar
decl_stmt|;
specifier|static
specifier|const
name|TST
name|TST_char16
init|=
name|clang
operator|::
name|TST_char16
decl_stmt|;
specifier|static
specifier|const
name|TST
name|TST_char32
init|=
name|clang
operator|::
name|TST_char32
decl_stmt|;
specifier|static
specifier|const
name|TST
name|TST_int
init|=
name|clang
operator|::
name|TST_int
decl_stmt|;
specifier|static
specifier|const
name|TST
name|TST_int128
init|=
name|clang
operator|::
name|TST_int128
decl_stmt|;
specifier|static
specifier|const
name|TST
name|TST_half
init|=
name|clang
operator|::
name|TST_half
decl_stmt|;
specifier|static
specifier|const
name|TST
name|TST_float
init|=
name|clang
operator|::
name|TST_float
decl_stmt|;
specifier|static
specifier|const
name|TST
name|TST_double
init|=
name|clang
operator|::
name|TST_double
decl_stmt|;
specifier|static
specifier|const
name|TST
name|TST_bool
init|=
name|clang
operator|::
name|TST_bool
decl_stmt|;
specifier|static
specifier|const
name|TST
name|TST_decimal32
init|=
name|clang
operator|::
name|TST_decimal32
decl_stmt|;
specifier|static
specifier|const
name|TST
name|TST_decimal64
init|=
name|clang
operator|::
name|TST_decimal64
decl_stmt|;
specifier|static
specifier|const
name|TST
name|TST_decimal128
init|=
name|clang
operator|::
name|TST_decimal128
decl_stmt|;
specifier|static
specifier|const
name|TST
name|TST_enum
init|=
name|clang
operator|::
name|TST_enum
decl_stmt|;
specifier|static
specifier|const
name|TST
name|TST_union
init|=
name|clang
operator|::
name|TST_union
decl_stmt|;
specifier|static
specifier|const
name|TST
name|TST_struct
init|=
name|clang
operator|::
name|TST_struct
decl_stmt|;
specifier|static
specifier|const
name|TST
name|TST_interface
init|=
name|clang
operator|::
name|TST_interface
decl_stmt|;
specifier|static
specifier|const
name|TST
name|TST_class
init|=
name|clang
operator|::
name|TST_class
decl_stmt|;
specifier|static
specifier|const
name|TST
name|TST_typename
init|=
name|clang
operator|::
name|TST_typename
decl_stmt|;
specifier|static
specifier|const
name|TST
name|TST_typeofType
init|=
name|clang
operator|::
name|TST_typeofType
decl_stmt|;
specifier|static
specifier|const
name|TST
name|TST_typeofExpr
init|=
name|clang
operator|::
name|TST_typeofExpr
decl_stmt|;
specifier|static
specifier|const
name|TST
name|TST_decltype
init|=
name|clang
operator|::
name|TST_decltype
decl_stmt|;
specifier|static
specifier|const
name|TST
name|TST_decltype_auto
init|=
name|clang
operator|::
name|TST_decltype_auto
decl_stmt|;
specifier|static
specifier|const
name|TST
name|TST_underlyingType
init|=
name|clang
operator|::
name|TST_underlyingType
decl_stmt|;
specifier|static
specifier|const
name|TST
name|TST_auto
init|=
name|clang
operator|::
name|TST_auto
decl_stmt|;
specifier|static
specifier|const
name|TST
name|TST_auto_type
init|=
name|clang
operator|::
name|TST_auto_type
decl_stmt|;
specifier|static
specifier|const
name|TST
name|TST_unknown_anytype
init|=
name|clang
operator|::
name|TST_unknown_anytype
decl_stmt|;
specifier|static
specifier|const
name|TST
name|TST_atomic
init|=
name|clang
operator|::
name|TST_atomic
decl_stmt|;
specifier|static
specifier|const
name|TST
name|TST_error
init|=
name|clang
operator|::
name|TST_error
decl_stmt|;
comment|// type-qualifiers
enum|enum
name|TQ
block|{
comment|// NOTE: These flags must be kept in sync with Qualifiers::TQ.
name|TQ_unspecified
init|=
literal|0
block|,
name|TQ_const
init|=
literal|1
block|,
name|TQ_restrict
init|=
literal|2
block|,
name|TQ_volatile
init|=
literal|4
block|,
comment|// This has no corresponding Qualifiers::TQ value, because it's not treated
comment|// as a qualifier in our type system.
name|TQ_atomic
init|=
literal|8
block|}
enum|;
comment|/// ParsedSpecifiers - Flags to query which specifiers were applied.  This is
comment|/// returned by getParsedSpecifiers.
enum|enum
name|ParsedSpecifiers
block|{
name|PQ_None
init|=
literal|0
block|,
name|PQ_StorageClassSpecifier
init|=
literal|1
block|,
name|PQ_TypeSpecifier
init|=
literal|2
block|,
name|PQ_TypeQualifier
init|=
literal|4
block|,
name|PQ_FunctionSpecifier
init|=
literal|8
block|}
enum|;
name|private
label|:
comment|// storage-class-specifier
comment|/*SCS*/
name|unsigned
name|StorageClassSpec
range|:
literal|3
decl_stmt|;
comment|/*TSCS*/
name|unsigned
name|ThreadStorageClassSpec
range|:
literal|2
decl_stmt|;
name|unsigned
name|SCS_extern_in_linkage_spec
range|:
literal|1
decl_stmt|;
comment|// type-specifier
comment|/*TSW*/
name|unsigned
name|TypeSpecWidth
range|:
literal|2
decl_stmt|;
comment|/*TSC*/
name|unsigned
name|TypeSpecComplex
range|:
literal|2
decl_stmt|;
comment|/*TSS*/
name|unsigned
name|TypeSpecSign
range|:
literal|2
decl_stmt|;
comment|/*TST*/
name|unsigned
name|TypeSpecType
range|:
literal|6
decl_stmt|;
name|unsigned
name|TypeAltiVecVector
range|:
literal|1
decl_stmt|;
name|unsigned
name|TypeAltiVecPixel
range|:
literal|1
decl_stmt|;
name|unsigned
name|TypeAltiVecBool
range|:
literal|1
decl_stmt|;
name|unsigned
name|TypeSpecOwned
range|:
literal|1
decl_stmt|;
comment|// type-qualifiers
name|unsigned
name|TypeQualifiers
range|:
literal|4
decl_stmt|;
comment|// Bitwise OR of TQ.
comment|// function-specifier
name|unsigned
name|FS_inline_specified
range|:
literal|1
decl_stmt|;
name|unsigned
name|FS_forceinline_specified
range|:
literal|1
decl_stmt|;
name|unsigned
name|FS_virtual_specified
range|:
literal|1
decl_stmt|;
name|unsigned
name|FS_explicit_specified
range|:
literal|1
decl_stmt|;
name|unsigned
name|FS_noreturn_specified
range|:
literal|1
decl_stmt|;
comment|// friend-specifier
name|unsigned
name|Friend_specified
range|:
literal|1
decl_stmt|;
comment|// constexpr-specifier
name|unsigned
name|Constexpr_specified
range|:
literal|1
decl_stmt|;
comment|// concept-specifier
name|unsigned
name|Concept_specified
range|:
literal|1
decl_stmt|;
union|union
block|{
name|UnionParsedType
name|TypeRep
decl_stmt|;
name|Decl
modifier|*
name|DeclRep
decl_stmt|;
name|Expr
modifier|*
name|ExprRep
decl_stmt|;
block|}
union|;
comment|// attributes.
name|ParsedAttributes
name|Attrs
decl_stmt|;
comment|// Scope specifier for the type spec, if applicable.
name|CXXScopeSpec
name|TypeScope
decl_stmt|;
comment|// SourceLocation info.  These are null if the item wasn't specified or if
comment|// the setting was synthesized.
name|SourceRange
name|Range
decl_stmt|;
name|SourceLocation
name|StorageClassSpecLoc
decl_stmt|,
name|ThreadStorageClassSpecLoc
decl_stmt|;
name|SourceLocation
name|TSWLoc
decl_stmt|,
name|TSCLoc
decl_stmt|,
name|TSSLoc
decl_stmt|,
name|TSTLoc
decl_stmt|,
name|AltiVecLoc
decl_stmt|;
comment|/// TSTNameLoc - If TypeSpecType is any of class, enum, struct, union,
comment|/// typename, then this is the location of the named type (if present);
comment|/// otherwise, it is the same as TSTLoc. Hence, the pair TSTLoc and
comment|/// TSTNameLoc provides source range info for tag types.
name|SourceLocation
name|TSTNameLoc
decl_stmt|;
name|SourceRange
name|TypeofParensRange
decl_stmt|;
name|SourceLocation
name|TQ_constLoc
decl_stmt|,
name|TQ_restrictLoc
decl_stmt|,
name|TQ_volatileLoc
decl_stmt|,
name|TQ_atomicLoc
decl_stmt|;
name|SourceLocation
name|FS_inlineLoc
decl_stmt|,
name|FS_virtualLoc
decl_stmt|,
name|FS_explicitLoc
decl_stmt|,
name|FS_noreturnLoc
decl_stmt|;
name|SourceLocation
name|FS_forceinlineLoc
decl_stmt|;
name|SourceLocation
name|FriendLoc
decl_stmt|,
name|ModulePrivateLoc
decl_stmt|,
name|ConstexprLoc
decl_stmt|,
name|ConceptLoc
decl_stmt|;
name|WrittenBuiltinSpecs
name|writtenBS
decl_stmt|;
name|void
name|SaveWrittenBuiltinSpecs
parameter_list|()
function_decl|;
name|ObjCDeclSpec
modifier|*
name|ObjCQualifiers
decl_stmt|;
specifier|static
name|bool
name|isTypeRep
parameter_list|(
name|TST
name|T
parameter_list|)
block|{
return|return
operator|(
name|T
operator|==
name|TST_typename
operator|||
name|T
operator|==
name|TST_typeofType
operator|||
name|T
operator|==
name|TST_underlyingType
operator|||
name|T
operator|==
name|TST_atomic
operator|)
return|;
block|}
specifier|static
name|bool
name|isExprRep
parameter_list|(
name|TST
name|T
parameter_list|)
block|{
return|return
operator|(
name|T
operator|==
name|TST_typeofExpr
operator|||
name|T
operator|==
name|TST_decltype
operator|)
return|;
block|}
name|DeclSpec
argument_list|(
specifier|const
name|DeclSpec
operator|&
argument_list|)
operator|=
name|delete
expr_stmt|;
name|void
name|operator
init|=
operator|(
specifier|const
name|DeclSpec
operator|&
operator|)
operator|=
name|delete
decl_stmt|;
name|public
label|:
specifier|static
name|bool
name|isDeclRep
parameter_list|(
name|TST
name|T
parameter_list|)
block|{
return|return
operator|(
name|T
operator|==
name|TST_enum
operator|||
name|T
operator|==
name|TST_struct
operator|||
name|T
operator|==
name|TST_interface
operator|||
name|T
operator|==
name|TST_union
operator|||
name|T
operator|==
name|TST_class
operator|)
return|;
block|}
name|DeclSpec
argument_list|(
name|AttributeFactory
operator|&
name|attrFactory
argument_list|)
operator|:
name|StorageClassSpec
argument_list|(
name|SCS_unspecified
argument_list|)
operator|,
name|ThreadStorageClassSpec
argument_list|(
name|TSCS_unspecified
argument_list|)
operator|,
name|SCS_extern_in_linkage_spec
argument_list|(
name|false
argument_list|)
operator|,
name|TypeSpecWidth
argument_list|(
name|TSW_unspecified
argument_list|)
operator|,
name|TypeSpecComplex
argument_list|(
name|TSC_unspecified
argument_list|)
operator|,
name|TypeSpecSign
argument_list|(
name|TSS_unspecified
argument_list|)
operator|,
name|TypeSpecType
argument_list|(
name|TST_unspecified
argument_list|)
operator|,
name|TypeAltiVecVector
argument_list|(
name|false
argument_list|)
operator|,
name|TypeAltiVecPixel
argument_list|(
name|false
argument_list|)
operator|,
name|TypeAltiVecBool
argument_list|(
name|false
argument_list|)
operator|,
name|TypeSpecOwned
argument_list|(
name|false
argument_list|)
operator|,
name|TypeQualifiers
argument_list|(
name|TQ_unspecified
argument_list|)
operator|,
name|FS_inline_specified
argument_list|(
name|false
argument_list|)
operator|,
name|FS_forceinline_specified
argument_list|(
name|false
argument_list|)
operator|,
name|FS_virtual_specified
argument_list|(
name|false
argument_list|)
operator|,
name|FS_explicit_specified
argument_list|(
name|false
argument_list|)
operator|,
name|FS_noreturn_specified
argument_list|(
name|false
argument_list|)
operator|,
name|Friend_specified
argument_list|(
name|false
argument_list|)
operator|,
name|Constexpr_specified
argument_list|(
name|false
argument_list|)
operator|,
name|Concept_specified
argument_list|(
name|false
argument_list|)
operator|,
name|Attrs
argument_list|(
name|attrFactory
argument_list|)
operator|,
name|writtenBS
argument_list|()
operator|,
name|ObjCQualifiers
argument_list|(
argument|nullptr
argument_list|)
block|{   }
comment|// storage-class-specifier
name|SCS
name|getStorageClassSpec
argument_list|()
specifier|const
block|{
return|return
operator|(
name|SCS
operator|)
name|StorageClassSpec
return|;
block|}
name|TSCS
name|getThreadStorageClassSpec
argument_list|()
specifier|const
block|{
return|return
operator|(
name|TSCS
operator|)
name|ThreadStorageClassSpec
return|;
block|}
name|bool
name|isExternInLinkageSpec
argument_list|()
specifier|const
block|{
return|return
name|SCS_extern_in_linkage_spec
return|;
block|}
name|void
name|setExternInLinkageSpec
parameter_list|(
name|bool
name|Value
parameter_list|)
block|{
name|SCS_extern_in_linkage_spec
operator|=
name|Value
expr_stmt|;
block|}
name|SourceLocation
name|getStorageClassSpecLoc
argument_list|()
specifier|const
block|{
return|return
name|StorageClassSpecLoc
return|;
block|}
name|SourceLocation
name|getThreadStorageClassSpecLoc
argument_list|()
specifier|const
block|{
return|return
name|ThreadStorageClassSpecLoc
return|;
block|}
name|void
name|ClearStorageClassSpecs
parameter_list|()
block|{
name|StorageClassSpec
operator|=
name|DeclSpec
operator|::
name|SCS_unspecified
expr_stmt|;
name|ThreadStorageClassSpec
operator|=
name|DeclSpec
operator|::
name|TSCS_unspecified
expr_stmt|;
name|SCS_extern_in_linkage_spec
operator|=
name|false
expr_stmt|;
name|StorageClassSpecLoc
operator|=
name|SourceLocation
argument_list|()
expr_stmt|;
name|ThreadStorageClassSpecLoc
operator|=
name|SourceLocation
argument_list|()
expr_stmt|;
block|}
name|void
name|ClearTypeSpecType
parameter_list|()
block|{
name|TypeSpecType
operator|=
name|DeclSpec
operator|::
name|TST_unspecified
expr_stmt|;
name|TypeSpecOwned
operator|=
name|false
expr_stmt|;
name|TSTLoc
operator|=
name|SourceLocation
argument_list|()
expr_stmt|;
block|}
comment|// type-specifier
name|TSW
name|getTypeSpecWidth
argument_list|()
specifier|const
block|{
return|return
operator|(
name|TSW
operator|)
name|TypeSpecWidth
return|;
block|}
name|TSC
name|getTypeSpecComplex
argument_list|()
specifier|const
block|{
return|return
operator|(
name|TSC
operator|)
name|TypeSpecComplex
return|;
block|}
name|TSS
name|getTypeSpecSign
argument_list|()
specifier|const
block|{
return|return
operator|(
name|TSS
operator|)
name|TypeSpecSign
return|;
block|}
name|TST
name|getTypeSpecType
argument_list|()
specifier|const
block|{
return|return
operator|(
name|TST
operator|)
name|TypeSpecType
return|;
block|}
name|bool
name|isTypeAltiVecVector
argument_list|()
specifier|const
block|{
return|return
name|TypeAltiVecVector
return|;
block|}
name|bool
name|isTypeAltiVecPixel
argument_list|()
specifier|const
block|{
return|return
name|TypeAltiVecPixel
return|;
block|}
name|bool
name|isTypeAltiVecBool
argument_list|()
specifier|const
block|{
return|return
name|TypeAltiVecBool
return|;
block|}
name|bool
name|isTypeSpecOwned
argument_list|()
specifier|const
block|{
return|return
name|TypeSpecOwned
return|;
block|}
name|bool
name|isTypeRep
argument_list|()
specifier|const
block|{
return|return
name|isTypeRep
argument_list|(
operator|(
name|TST
operator|)
name|TypeSpecType
argument_list|)
return|;
block|}
name|ParsedType
name|getRepAsType
argument_list|()
specifier|const
block|{
name|assert
argument_list|(
name|isTypeRep
argument_list|(
operator|(
name|TST
operator|)
name|TypeSpecType
argument_list|)
operator|&&
literal|"DeclSpec does not store a type"
argument_list|)
block|;
return|return
name|TypeRep
return|;
block|}
name|Decl
operator|*
name|getRepAsDecl
argument_list|()
specifier|const
block|{
name|assert
argument_list|(
name|isDeclRep
argument_list|(
operator|(
name|TST
operator|)
name|TypeSpecType
argument_list|)
operator|&&
literal|"DeclSpec does not store a decl"
argument_list|)
block|;
return|return
name|DeclRep
return|;
block|}
name|Expr
operator|*
name|getRepAsExpr
argument_list|()
specifier|const
block|{
name|assert
argument_list|(
name|isExprRep
argument_list|(
operator|(
name|TST
operator|)
name|TypeSpecType
argument_list|)
operator|&&
literal|"DeclSpec does not store an expr"
argument_list|)
block|;
return|return
name|ExprRep
return|;
block|}
name|CXXScopeSpec
modifier|&
name|getTypeSpecScope
parameter_list|()
block|{
return|return
name|TypeScope
return|;
block|}
specifier|const
name|CXXScopeSpec
operator|&
name|getTypeSpecScope
argument_list|()
specifier|const
block|{
return|return
name|TypeScope
return|;
block|}
name|SourceRange
name|getSourceRange
argument_list|()
specifier|const
name|LLVM_READONLY
block|{
return|return
name|Range
return|;
block|}
name|SourceLocation
name|getLocStart
argument_list|()
specifier|const
name|LLVM_READONLY
block|{
return|return
name|Range
operator|.
name|getBegin
argument_list|()
return|;
block|}
name|SourceLocation
name|getLocEnd
argument_list|()
specifier|const
name|LLVM_READONLY
block|{
return|return
name|Range
operator|.
name|getEnd
argument_list|()
return|;
block|}
name|SourceLocation
name|getTypeSpecWidthLoc
argument_list|()
specifier|const
block|{
return|return
name|TSWLoc
return|;
block|}
name|SourceLocation
name|getTypeSpecComplexLoc
argument_list|()
specifier|const
block|{
return|return
name|TSCLoc
return|;
block|}
name|SourceLocation
name|getTypeSpecSignLoc
argument_list|()
specifier|const
block|{
return|return
name|TSSLoc
return|;
block|}
name|SourceLocation
name|getTypeSpecTypeLoc
argument_list|()
specifier|const
block|{
return|return
name|TSTLoc
return|;
block|}
name|SourceLocation
name|getAltiVecLoc
argument_list|()
specifier|const
block|{
return|return
name|AltiVecLoc
return|;
block|}
name|SourceLocation
name|getTypeSpecTypeNameLoc
argument_list|()
specifier|const
block|{
name|assert
argument_list|(
name|isDeclRep
argument_list|(
operator|(
name|TST
operator|)
name|TypeSpecType
argument_list|)
operator|||
name|TypeSpecType
operator|==
name|TST_typename
argument_list|)
block|;
return|return
name|TSTNameLoc
return|;
block|}
name|SourceRange
name|getTypeofParensRange
argument_list|()
specifier|const
block|{
return|return
name|TypeofParensRange
return|;
block|}
name|void
name|setTypeofParensRange
parameter_list|(
name|SourceRange
name|range
parameter_list|)
block|{
name|TypeofParensRange
operator|=
name|range
expr_stmt|;
block|}
name|bool
name|containsPlaceholderType
argument_list|()
specifier|const
block|{
return|return
operator|(
name|TypeSpecType
operator|==
name|TST_auto
operator|||
name|TypeSpecType
operator|==
name|TST_auto_type
operator|||
name|TypeSpecType
operator|==
name|TST_decltype_auto
operator|)
return|;
block|}
name|bool
name|hasTagDefinition
argument_list|()
specifier|const
expr_stmt|;
comment|/// \brief Turn a type-specifier-type into a string like "_Bool" or "union".
specifier|static
specifier|const
name|char
modifier|*
name|getSpecifierName
argument_list|(
name|DeclSpec
operator|::
name|TST
name|T
argument_list|,
specifier|const
name|PrintingPolicy
operator|&
name|Policy
argument_list|)
decl_stmt|;
specifier|static
specifier|const
name|char
modifier|*
name|getSpecifierName
argument_list|(
name|DeclSpec
operator|::
name|TQ
name|Q
argument_list|)
decl_stmt|;
specifier|static
specifier|const
name|char
modifier|*
name|getSpecifierName
argument_list|(
name|DeclSpec
operator|::
name|TSS
name|S
argument_list|)
decl_stmt|;
specifier|static
specifier|const
name|char
modifier|*
name|getSpecifierName
argument_list|(
name|DeclSpec
operator|::
name|TSC
name|C
argument_list|)
decl_stmt|;
specifier|static
specifier|const
name|char
modifier|*
name|getSpecifierName
argument_list|(
name|DeclSpec
operator|::
name|TSW
name|W
argument_list|)
decl_stmt|;
specifier|static
specifier|const
name|char
modifier|*
name|getSpecifierName
argument_list|(
name|DeclSpec
operator|::
name|SCS
name|S
argument_list|)
decl_stmt|;
specifier|static
specifier|const
name|char
modifier|*
name|getSpecifierName
argument_list|(
name|DeclSpec
operator|::
name|TSCS
name|S
argument_list|)
decl_stmt|;
comment|// type-qualifiers
comment|/// getTypeQualifiers - Return a set of TQs.
name|unsigned
name|getTypeQualifiers
argument_list|()
specifier|const
block|{
return|return
name|TypeQualifiers
return|;
block|}
name|SourceLocation
name|getConstSpecLoc
argument_list|()
specifier|const
block|{
return|return
name|TQ_constLoc
return|;
block|}
name|SourceLocation
name|getRestrictSpecLoc
argument_list|()
specifier|const
block|{
return|return
name|TQ_restrictLoc
return|;
block|}
name|SourceLocation
name|getVolatileSpecLoc
argument_list|()
specifier|const
block|{
return|return
name|TQ_volatileLoc
return|;
block|}
name|SourceLocation
name|getAtomicSpecLoc
argument_list|()
specifier|const
block|{
return|return
name|TQ_atomicLoc
return|;
block|}
comment|/// \brief Clear out all of the type qualifiers.
name|void
name|ClearTypeQualifiers
parameter_list|()
block|{
name|TypeQualifiers
operator|=
literal|0
expr_stmt|;
name|TQ_constLoc
operator|=
name|SourceLocation
argument_list|()
expr_stmt|;
name|TQ_restrictLoc
operator|=
name|SourceLocation
argument_list|()
expr_stmt|;
name|TQ_volatileLoc
operator|=
name|SourceLocation
argument_list|()
expr_stmt|;
name|TQ_atomicLoc
operator|=
name|SourceLocation
argument_list|()
expr_stmt|;
block|}
comment|// function-specifier
name|bool
name|isInlineSpecified
argument_list|()
specifier|const
block|{
return|return
name|FS_inline_specified
operator||
name|FS_forceinline_specified
return|;
block|}
name|SourceLocation
name|getInlineSpecLoc
argument_list|()
specifier|const
block|{
return|return
name|FS_inline_specified
operator|?
name|FS_inlineLoc
operator|:
name|FS_forceinlineLoc
return|;
block|}
name|bool
name|isVirtualSpecified
argument_list|()
specifier|const
block|{
return|return
name|FS_virtual_specified
return|;
block|}
name|SourceLocation
name|getVirtualSpecLoc
argument_list|()
specifier|const
block|{
return|return
name|FS_virtualLoc
return|;
block|}
name|bool
name|isExplicitSpecified
argument_list|()
specifier|const
block|{
return|return
name|FS_explicit_specified
return|;
block|}
name|SourceLocation
name|getExplicitSpecLoc
argument_list|()
specifier|const
block|{
return|return
name|FS_explicitLoc
return|;
block|}
name|bool
name|isNoreturnSpecified
argument_list|()
specifier|const
block|{
return|return
name|FS_noreturn_specified
return|;
block|}
name|SourceLocation
name|getNoreturnSpecLoc
argument_list|()
specifier|const
block|{
return|return
name|FS_noreturnLoc
return|;
block|}
name|void
name|ClearFunctionSpecs
parameter_list|()
block|{
name|FS_inline_specified
operator|=
name|false
expr_stmt|;
name|FS_inlineLoc
operator|=
name|SourceLocation
argument_list|()
expr_stmt|;
name|FS_forceinline_specified
operator|=
name|false
expr_stmt|;
name|FS_forceinlineLoc
operator|=
name|SourceLocation
argument_list|()
expr_stmt|;
name|FS_virtual_specified
operator|=
name|false
expr_stmt|;
name|FS_virtualLoc
operator|=
name|SourceLocation
argument_list|()
expr_stmt|;
name|FS_explicit_specified
operator|=
name|false
expr_stmt|;
name|FS_explicitLoc
operator|=
name|SourceLocation
argument_list|()
expr_stmt|;
name|FS_noreturn_specified
operator|=
name|false
expr_stmt|;
name|FS_noreturnLoc
operator|=
name|SourceLocation
argument_list|()
expr_stmt|;
block|}
comment|/// \brief Return true if any type-specifier has been found.
name|bool
name|hasTypeSpecifier
argument_list|()
specifier|const
block|{
return|return
name|getTypeSpecType
argument_list|()
operator|!=
name|DeclSpec
operator|::
name|TST_unspecified
operator|||
name|getTypeSpecWidth
argument_list|()
operator|!=
name|DeclSpec
operator|::
name|TSW_unspecified
operator|||
name|getTypeSpecComplex
argument_list|()
operator|!=
name|DeclSpec
operator|::
name|TSC_unspecified
operator|||
name|getTypeSpecSign
argument_list|()
operator|!=
name|DeclSpec
operator|::
name|TSS_unspecified
return|;
block|}
comment|/// \brief Return a bitmask of which flavors of specifiers this
comment|/// DeclSpec includes.
name|unsigned
name|getParsedSpecifiers
argument_list|()
specifier|const
expr_stmt|;
comment|/// isEmpty - Return true if this declaration specifier is completely empty:
comment|/// no tokens were parsed in the production of it.
name|bool
name|isEmpty
argument_list|()
specifier|const
block|{
return|return
name|getParsedSpecifiers
argument_list|()
operator|==
name|DeclSpec
operator|::
name|PQ_None
return|;
block|}
name|void
name|SetRangeStart
parameter_list|(
name|SourceLocation
name|Loc
parameter_list|)
block|{
name|Range
operator|.
name|setBegin
argument_list|(
name|Loc
argument_list|)
expr_stmt|;
block|}
name|void
name|SetRangeEnd
parameter_list|(
name|SourceLocation
name|Loc
parameter_list|)
block|{
name|Range
operator|.
name|setEnd
argument_list|(
name|Loc
argument_list|)
expr_stmt|;
block|}
comment|/// These methods set the specified attribute of the DeclSpec and
comment|/// return false if there was no error.  If an error occurs (for
comment|/// example, if we tried to set "auto" on a spec with "extern"
comment|/// already set), they return true and set PrevSpec and DiagID
comment|/// such that
comment|///   Diag(Loc, DiagID)<< PrevSpec;
comment|/// will yield a useful result.
comment|///
comment|/// TODO: use a more general approach that still allows these
comment|/// diagnostics to be ignored when desired.
name|bool
name|SetStorageClassSpec
parameter_list|(
name|Sema
modifier|&
name|S
parameter_list|,
name|SCS
name|SC
parameter_list|,
name|SourceLocation
name|Loc
parameter_list|,
specifier|const
name|char
modifier|*
modifier|&
name|PrevSpec
parameter_list|,
name|unsigned
modifier|&
name|DiagID
parameter_list|,
specifier|const
name|PrintingPolicy
modifier|&
name|Policy
parameter_list|)
function_decl|;
name|bool
name|SetStorageClassSpecThread
parameter_list|(
name|TSCS
name|TSC
parameter_list|,
name|SourceLocation
name|Loc
parameter_list|,
specifier|const
name|char
modifier|*
modifier|&
name|PrevSpec
parameter_list|,
name|unsigned
modifier|&
name|DiagID
parameter_list|)
function_decl|;
name|bool
name|SetTypeSpecWidth
parameter_list|(
name|TSW
name|W
parameter_list|,
name|SourceLocation
name|Loc
parameter_list|,
specifier|const
name|char
modifier|*
modifier|&
name|PrevSpec
parameter_list|,
name|unsigned
modifier|&
name|DiagID
parameter_list|,
specifier|const
name|PrintingPolicy
modifier|&
name|Policy
parameter_list|)
function_decl|;
name|bool
name|SetTypeSpecComplex
parameter_list|(
name|TSC
name|C
parameter_list|,
name|SourceLocation
name|Loc
parameter_list|,
specifier|const
name|char
modifier|*
modifier|&
name|PrevSpec
parameter_list|,
name|unsigned
modifier|&
name|DiagID
parameter_list|)
function_decl|;
name|bool
name|SetTypeSpecSign
parameter_list|(
name|TSS
name|S
parameter_list|,
name|SourceLocation
name|Loc
parameter_list|,
specifier|const
name|char
modifier|*
modifier|&
name|PrevSpec
parameter_list|,
name|unsigned
modifier|&
name|DiagID
parameter_list|)
function_decl|;
name|bool
name|SetTypeSpecType
parameter_list|(
name|TST
name|T
parameter_list|,
name|SourceLocation
name|Loc
parameter_list|,
specifier|const
name|char
modifier|*
modifier|&
name|PrevSpec
parameter_list|,
name|unsigned
modifier|&
name|DiagID
parameter_list|,
specifier|const
name|PrintingPolicy
modifier|&
name|Policy
parameter_list|)
function_decl|;
name|bool
name|SetTypeSpecType
parameter_list|(
name|TST
name|T
parameter_list|,
name|SourceLocation
name|Loc
parameter_list|,
specifier|const
name|char
modifier|*
modifier|&
name|PrevSpec
parameter_list|,
name|unsigned
modifier|&
name|DiagID
parameter_list|,
name|ParsedType
name|Rep
parameter_list|,
specifier|const
name|PrintingPolicy
modifier|&
name|Policy
parameter_list|)
function_decl|;
name|bool
name|SetTypeSpecType
parameter_list|(
name|TST
name|T
parameter_list|,
name|SourceLocation
name|Loc
parameter_list|,
specifier|const
name|char
modifier|*
modifier|&
name|PrevSpec
parameter_list|,
name|unsigned
modifier|&
name|DiagID
parameter_list|,
name|Decl
modifier|*
name|Rep
parameter_list|,
name|bool
name|Owned
parameter_list|,
specifier|const
name|PrintingPolicy
modifier|&
name|Policy
parameter_list|)
function_decl|;
name|bool
name|SetTypeSpecType
parameter_list|(
name|TST
name|T
parameter_list|,
name|SourceLocation
name|TagKwLoc
parameter_list|,
name|SourceLocation
name|TagNameLoc
parameter_list|,
specifier|const
name|char
modifier|*
modifier|&
name|PrevSpec
parameter_list|,
name|unsigned
modifier|&
name|DiagID
parameter_list|,
name|ParsedType
name|Rep
parameter_list|,
specifier|const
name|PrintingPolicy
modifier|&
name|Policy
parameter_list|)
function_decl|;
name|bool
name|SetTypeSpecType
parameter_list|(
name|TST
name|T
parameter_list|,
name|SourceLocation
name|TagKwLoc
parameter_list|,
name|SourceLocation
name|TagNameLoc
parameter_list|,
specifier|const
name|char
modifier|*
modifier|&
name|PrevSpec
parameter_list|,
name|unsigned
modifier|&
name|DiagID
parameter_list|,
name|Decl
modifier|*
name|Rep
parameter_list|,
name|bool
name|Owned
parameter_list|,
specifier|const
name|PrintingPolicy
modifier|&
name|Policy
parameter_list|)
function_decl|;
name|bool
name|SetTypeSpecType
parameter_list|(
name|TST
name|T
parameter_list|,
name|SourceLocation
name|Loc
parameter_list|,
specifier|const
name|char
modifier|*
modifier|&
name|PrevSpec
parameter_list|,
name|unsigned
modifier|&
name|DiagID
parameter_list|,
name|Expr
modifier|*
name|Rep
parameter_list|,
specifier|const
name|PrintingPolicy
modifier|&
name|policy
parameter_list|)
function_decl|;
name|bool
name|SetTypeAltiVecVector
parameter_list|(
name|bool
name|isAltiVecVector
parameter_list|,
name|SourceLocation
name|Loc
parameter_list|,
specifier|const
name|char
modifier|*
modifier|&
name|PrevSpec
parameter_list|,
name|unsigned
modifier|&
name|DiagID
parameter_list|,
specifier|const
name|PrintingPolicy
modifier|&
name|Policy
parameter_list|)
function_decl|;
name|bool
name|SetTypeAltiVecPixel
parameter_list|(
name|bool
name|isAltiVecPixel
parameter_list|,
name|SourceLocation
name|Loc
parameter_list|,
specifier|const
name|char
modifier|*
modifier|&
name|PrevSpec
parameter_list|,
name|unsigned
modifier|&
name|DiagID
parameter_list|,
specifier|const
name|PrintingPolicy
modifier|&
name|Policy
parameter_list|)
function_decl|;
name|bool
name|SetTypeAltiVecBool
parameter_list|(
name|bool
name|isAltiVecBool
parameter_list|,
name|SourceLocation
name|Loc
parameter_list|,
specifier|const
name|char
modifier|*
modifier|&
name|PrevSpec
parameter_list|,
name|unsigned
modifier|&
name|DiagID
parameter_list|,
specifier|const
name|PrintingPolicy
modifier|&
name|Policy
parameter_list|)
function_decl|;
name|bool
name|SetTypeSpecError
parameter_list|()
function_decl|;
name|void
name|UpdateDeclRep
parameter_list|(
name|Decl
modifier|*
name|Rep
parameter_list|)
block|{
name|assert
argument_list|(
name|isDeclRep
argument_list|(
operator|(
name|TST
operator|)
name|TypeSpecType
argument_list|)
argument_list|)
expr_stmt|;
name|DeclRep
operator|=
name|Rep
expr_stmt|;
block|}
name|void
name|UpdateTypeRep
parameter_list|(
name|ParsedType
name|Rep
parameter_list|)
block|{
name|assert
argument_list|(
name|isTypeRep
argument_list|(
operator|(
name|TST
operator|)
name|TypeSpecType
argument_list|)
argument_list|)
expr_stmt|;
name|TypeRep
operator|=
name|Rep
expr_stmt|;
block|}
name|void
name|UpdateExprRep
parameter_list|(
name|Expr
modifier|*
name|Rep
parameter_list|)
block|{
name|assert
argument_list|(
name|isExprRep
argument_list|(
operator|(
name|TST
operator|)
name|TypeSpecType
argument_list|)
argument_list|)
expr_stmt|;
name|ExprRep
operator|=
name|Rep
expr_stmt|;
block|}
name|bool
name|SetTypeQual
parameter_list|(
name|TQ
name|T
parameter_list|,
name|SourceLocation
name|Loc
parameter_list|,
specifier|const
name|char
modifier|*
modifier|&
name|PrevSpec
parameter_list|,
name|unsigned
modifier|&
name|DiagID
parameter_list|,
specifier|const
name|LangOptions
modifier|&
name|Lang
parameter_list|)
function_decl|;
name|bool
name|setFunctionSpecInline
parameter_list|(
name|SourceLocation
name|Loc
parameter_list|,
specifier|const
name|char
modifier|*
modifier|&
name|PrevSpec
parameter_list|,
name|unsigned
modifier|&
name|DiagID
parameter_list|)
function_decl|;
name|bool
name|setFunctionSpecForceInline
parameter_list|(
name|SourceLocation
name|Loc
parameter_list|,
specifier|const
name|char
modifier|*
modifier|&
name|PrevSpec
parameter_list|,
name|unsigned
modifier|&
name|DiagID
parameter_list|)
function_decl|;
name|bool
name|setFunctionSpecVirtual
parameter_list|(
name|SourceLocation
name|Loc
parameter_list|,
specifier|const
name|char
modifier|*
modifier|&
name|PrevSpec
parameter_list|,
name|unsigned
modifier|&
name|DiagID
parameter_list|)
function_decl|;
name|bool
name|setFunctionSpecExplicit
parameter_list|(
name|SourceLocation
name|Loc
parameter_list|,
specifier|const
name|char
modifier|*
modifier|&
name|PrevSpec
parameter_list|,
name|unsigned
modifier|&
name|DiagID
parameter_list|)
function_decl|;
name|bool
name|setFunctionSpecNoreturn
parameter_list|(
name|SourceLocation
name|Loc
parameter_list|,
specifier|const
name|char
modifier|*
modifier|&
name|PrevSpec
parameter_list|,
name|unsigned
modifier|&
name|DiagID
parameter_list|)
function_decl|;
name|bool
name|SetFriendSpec
parameter_list|(
name|SourceLocation
name|Loc
parameter_list|,
specifier|const
name|char
modifier|*
modifier|&
name|PrevSpec
parameter_list|,
name|unsigned
modifier|&
name|DiagID
parameter_list|)
function_decl|;
name|bool
name|setModulePrivateSpec
parameter_list|(
name|SourceLocation
name|Loc
parameter_list|,
specifier|const
name|char
modifier|*
modifier|&
name|PrevSpec
parameter_list|,
name|unsigned
modifier|&
name|DiagID
parameter_list|)
function_decl|;
name|bool
name|SetConstexprSpec
parameter_list|(
name|SourceLocation
name|Loc
parameter_list|,
specifier|const
name|char
modifier|*
modifier|&
name|PrevSpec
parameter_list|,
name|unsigned
modifier|&
name|DiagID
parameter_list|)
function_decl|;
name|bool
name|SetConceptSpec
parameter_list|(
name|SourceLocation
name|Loc
parameter_list|,
specifier|const
name|char
modifier|*
modifier|&
name|PrevSpec
parameter_list|,
name|unsigned
modifier|&
name|DiagID
parameter_list|)
function_decl|;
name|bool
name|isFriendSpecified
argument_list|()
specifier|const
block|{
return|return
name|Friend_specified
return|;
block|}
name|SourceLocation
name|getFriendSpecLoc
argument_list|()
specifier|const
block|{
return|return
name|FriendLoc
return|;
block|}
name|bool
name|isModulePrivateSpecified
argument_list|()
specifier|const
block|{
return|return
name|ModulePrivateLoc
operator|.
name|isValid
argument_list|()
return|;
block|}
name|SourceLocation
name|getModulePrivateSpecLoc
argument_list|()
specifier|const
block|{
return|return
name|ModulePrivateLoc
return|;
block|}
name|bool
name|isConstexprSpecified
argument_list|()
specifier|const
block|{
return|return
name|Constexpr_specified
return|;
block|}
name|SourceLocation
name|getConstexprSpecLoc
argument_list|()
specifier|const
block|{
return|return
name|ConstexprLoc
return|;
block|}
name|bool
name|isConceptSpecified
argument_list|()
specifier|const
block|{
return|return
name|Concept_specified
return|;
block|}
name|SourceLocation
name|getConceptSpecLoc
argument_list|()
specifier|const
block|{
return|return
name|ConceptLoc
return|;
block|}
name|void
name|ClearConstexprSpec
parameter_list|()
block|{
name|Constexpr_specified
operator|=
name|false
expr_stmt|;
name|ConstexprLoc
operator|=
name|SourceLocation
argument_list|()
expr_stmt|;
block|}
name|void
name|ClearConceptSpec
parameter_list|()
block|{
name|Concept_specified
operator|=
name|false
expr_stmt|;
name|ConceptLoc
operator|=
name|SourceLocation
argument_list|()
expr_stmt|;
block|}
name|AttributePool
operator|&
name|getAttributePool
argument_list|()
specifier|const
block|{
return|return
name|Attrs
operator|.
name|getPool
argument_list|()
return|;
block|}
comment|/// \brief Concatenates two attribute lists.
comment|///
comment|/// The GCC attribute syntax allows for the following:
comment|///
comment|/// \code
comment|/// short __attribute__(( unused, deprecated ))
comment|/// int __attribute__(( may_alias, aligned(16) )) var;
comment|/// \endcode
comment|///
comment|/// This declares 4 attributes using 2 lists. The following syntax is
comment|/// also allowed and equivalent to the previous declaration.
comment|///
comment|/// \code
comment|/// short __attribute__((unused)) __attribute__((deprecated))
comment|/// int __attribute__((may_alias)) __attribute__((aligned(16))) var;
comment|/// \endcode
comment|///
name|void
name|addAttributes
parameter_list|(
name|AttributeList
modifier|*
name|AL
parameter_list|)
block|{
name|Attrs
operator|.
name|addAll
argument_list|(
name|AL
argument_list|)
expr_stmt|;
block|}
name|bool
name|hasAttributes
argument_list|()
specifier|const
block|{
return|return
operator|!
name|Attrs
operator|.
name|empty
argument_list|()
return|;
block|}
name|ParsedAttributes
modifier|&
name|getAttributes
parameter_list|()
block|{
return|return
name|Attrs
return|;
block|}
specifier|const
name|ParsedAttributes
operator|&
name|getAttributes
argument_list|()
specifier|const
block|{
return|return
name|Attrs
return|;
block|}
name|void
name|takeAttributesFrom
parameter_list|(
name|ParsedAttributes
modifier|&
name|attrs
parameter_list|)
block|{
name|Attrs
operator|.
name|takeAllFrom
argument_list|(
name|attrs
argument_list|)
expr_stmt|;
block|}
comment|/// Finish - This does final analysis of the declspec, issuing diagnostics for
comment|/// things like "_Imaginary" (lacking an FP type).  After calling this method,
comment|/// DeclSpec is guaranteed self-consistent, even if an error occurred.
name|void
name|Finish
parameter_list|(
name|Sema
modifier|&
name|S
parameter_list|,
specifier|const
name|PrintingPolicy
modifier|&
name|Policy
parameter_list|)
function_decl|;
specifier|const
name|WrittenBuiltinSpecs
operator|&
name|getWrittenBuiltinSpecs
argument_list|()
specifier|const
block|{
return|return
name|writtenBS
return|;
block|}
name|ObjCDeclSpec
operator|*
name|getObjCQualifiers
argument_list|()
specifier|const
block|{
return|return
name|ObjCQualifiers
return|;
block|}
name|void
name|setObjCQualifiers
parameter_list|(
name|ObjCDeclSpec
modifier|*
name|quals
parameter_list|)
block|{
name|ObjCQualifiers
operator|=
name|quals
expr_stmt|;
block|}
comment|/// \brief Checks if this DeclSpec can stand alone, without a Declarator.
comment|///
comment|/// Only tag declspecs can stand alone.
name|bool
name|isMissingDeclaratorOk
parameter_list|()
function_decl|;
block|}
empty_stmt|;
comment|/// \brief Captures information about "declaration specifiers" specific to
comment|/// Objective-C.
name|class
name|ObjCDeclSpec
block|{
name|public
label|:
comment|/// ObjCDeclQualifier - Qualifier used on types in method
comment|/// declarations.  Not all combinations are sensible.  Parameters
comment|/// can be one of { in, out, inout } with one of { bycopy, byref }.
comment|/// Returns can either be { oneway } or not.
comment|///
comment|/// This should be kept in sync with Decl::ObjCDeclQualifier.
enum|enum
name|ObjCDeclQualifier
block|{
name|DQ_None
init|=
literal|0x0
block|,
name|DQ_In
init|=
literal|0x1
block|,
name|DQ_Inout
init|=
literal|0x2
block|,
name|DQ_Out
init|=
literal|0x4
block|,
name|DQ_Bycopy
init|=
literal|0x8
block|,
name|DQ_Byref
init|=
literal|0x10
block|,
name|DQ_Oneway
init|=
literal|0x20
block|,
name|DQ_CSNullability
init|=
literal|0x40
block|}
enum|;
comment|/// PropertyAttributeKind - list of property attributes.
enum|enum
name|ObjCPropertyAttributeKind
block|{
name|DQ_PR_noattr
init|=
literal|0x0
block|,
name|DQ_PR_readonly
init|=
literal|0x01
block|,
name|DQ_PR_getter
init|=
literal|0x02
block|,
name|DQ_PR_assign
init|=
literal|0x04
block|,
name|DQ_PR_readwrite
init|=
literal|0x08
block|,
name|DQ_PR_retain
init|=
literal|0x10
block|,
name|DQ_PR_copy
init|=
literal|0x20
block|,
name|DQ_PR_nonatomic
init|=
literal|0x40
block|,
name|DQ_PR_setter
init|=
literal|0x80
block|,
name|DQ_PR_atomic
init|=
literal|0x100
block|,
name|DQ_PR_weak
init|=
literal|0x200
block|,
name|DQ_PR_strong
init|=
literal|0x400
block|,
name|DQ_PR_unsafe_unretained
init|=
literal|0x800
block|,
name|DQ_PR_nullability
init|=
literal|0x1000
block|,
name|DQ_PR_null_resettable
init|=
literal|0x2000
block|}
enum|;
name|ObjCDeclSpec
argument_list|()
operator|:
name|objcDeclQualifier
argument_list|(
name|DQ_None
argument_list|)
operator|,
name|PropertyAttributes
argument_list|(
name|DQ_PR_noattr
argument_list|)
operator|,
name|Nullability
argument_list|(
literal|0
argument_list|)
operator|,
name|GetterName
argument_list|(
name|nullptr
argument_list|)
operator|,
name|SetterName
argument_list|(
argument|nullptr
argument_list|)
block|{ }
name|ObjCDeclQualifier
name|getObjCDeclQualifier
argument_list|()
specifier|const
block|{
return|return
name|objcDeclQualifier
return|;
block|}
name|void
name|setObjCDeclQualifier
parameter_list|(
name|ObjCDeclQualifier
name|DQVal
parameter_list|)
block|{
name|objcDeclQualifier
operator|=
call|(
name|ObjCDeclQualifier
call|)
argument_list|(
name|objcDeclQualifier
operator||
name|DQVal
argument_list|)
expr_stmt|;
block|}
name|void
name|clearObjCDeclQualifier
parameter_list|(
name|ObjCDeclQualifier
name|DQVal
parameter_list|)
block|{
name|objcDeclQualifier
operator|=
call|(
name|ObjCDeclQualifier
call|)
argument_list|(
name|objcDeclQualifier
operator|&
operator|~
name|DQVal
argument_list|)
expr_stmt|;
block|}
name|ObjCPropertyAttributeKind
name|getPropertyAttributes
argument_list|()
specifier|const
block|{
return|return
name|ObjCPropertyAttributeKind
argument_list|(
name|PropertyAttributes
argument_list|)
return|;
block|}
name|void
name|setPropertyAttributes
parameter_list|(
name|ObjCPropertyAttributeKind
name|PRVal
parameter_list|)
block|{
name|PropertyAttributes
operator|=
call|(
name|ObjCPropertyAttributeKind
call|)
argument_list|(
name|PropertyAttributes
operator||
name|PRVal
argument_list|)
expr_stmt|;
block|}
name|NullabilityKind
name|getNullability
argument_list|()
specifier|const
block|{
name|assert
argument_list|(
operator|(
operator|(
name|getObjCDeclQualifier
argument_list|()
operator|&
name|DQ_CSNullability
operator|)
operator|||
operator|(
name|getPropertyAttributes
argument_list|()
operator|&
name|DQ_PR_nullability
operator|)
operator|)
operator|&&
literal|"Objective-C declspec doesn't have nullability"
argument_list|)
block|;
return|return
name|static_cast
operator|<
name|NullabilityKind
operator|>
operator|(
name|Nullability
operator|)
return|;
block|}
name|SourceLocation
name|getNullabilityLoc
argument_list|()
specifier|const
block|{
name|assert
argument_list|(
operator|(
operator|(
name|getObjCDeclQualifier
argument_list|()
operator|&
name|DQ_CSNullability
operator|)
operator|||
operator|(
name|getPropertyAttributes
argument_list|()
operator|&
name|DQ_PR_nullability
operator|)
operator|)
operator|&&
literal|"Objective-C declspec doesn't have nullability"
argument_list|)
block|;
return|return
name|NullabilityLoc
return|;
block|}
name|void
name|setNullability
parameter_list|(
name|SourceLocation
name|loc
parameter_list|,
name|NullabilityKind
name|kind
parameter_list|)
block|{
name|assert
argument_list|(
operator|(
operator|(
name|getObjCDeclQualifier
argument_list|()
operator|&
name|DQ_CSNullability
operator|)
operator|||
operator|(
name|getPropertyAttributes
argument_list|()
operator|&
name|DQ_PR_nullability
operator|)
operator|)
operator|&&
literal|"Set the nullability declspec or property attribute first"
argument_list|)
expr_stmt|;
name|Nullability
operator|=
name|static_cast
operator|<
name|unsigned
operator|>
operator|(
name|kind
operator|)
expr_stmt|;
name|NullabilityLoc
operator|=
name|loc
expr_stmt|;
block|}
specifier|const
name|IdentifierInfo
operator|*
name|getGetterName
argument_list|()
specifier|const
block|{
return|return
name|GetterName
return|;
block|}
name|IdentifierInfo
modifier|*
name|getGetterName
parameter_list|()
block|{
return|return
name|GetterName
return|;
block|}
name|void
name|setGetterName
parameter_list|(
name|IdentifierInfo
modifier|*
name|name
parameter_list|)
block|{
name|GetterName
operator|=
name|name
expr_stmt|;
block|}
specifier|const
name|IdentifierInfo
operator|*
name|getSetterName
argument_list|()
specifier|const
block|{
return|return
name|SetterName
return|;
block|}
name|IdentifierInfo
modifier|*
name|getSetterName
parameter_list|()
block|{
return|return
name|SetterName
return|;
block|}
name|void
name|setSetterName
parameter_list|(
name|IdentifierInfo
modifier|*
name|name
parameter_list|)
block|{
name|SetterName
operator|=
name|name
expr_stmt|;
block|}
name|private
label|:
comment|// FIXME: These two are unrelated and mutually exclusive. So perhaps
comment|// we can put them in a union to reflect their mutual exclusivity
comment|// (space saving is negligible).
name|ObjCDeclQualifier
name|objcDeclQualifier
range|:
literal|7
decl_stmt|;
comment|// NOTE: VC++ treats enums as signed, avoid using ObjCPropertyAttributeKind
name|unsigned
name|PropertyAttributes
range|:
literal|14
decl_stmt|;
name|unsigned
name|Nullability
range|:
literal|2
decl_stmt|;
name|SourceLocation
name|NullabilityLoc
decl_stmt|;
name|IdentifierInfo
modifier|*
name|GetterName
decl_stmt|;
comment|// getter name or NULL if no getter
name|IdentifierInfo
modifier|*
name|SetterName
decl_stmt|;
comment|// setter name or NULL if no setter
block|}
empty_stmt|;
comment|/// \brief Represents a C++ unqualified-id that has been parsed.
name|class
name|UnqualifiedId
block|{
name|private
label|:
name|UnqualifiedId
argument_list|(
specifier|const
name|UnqualifiedId
operator|&
name|Other
argument_list|)
operator|=
name|delete
expr_stmt|;
specifier|const
name|UnqualifiedId
modifier|&
name|operator
init|=
operator|(
specifier|const
name|UnqualifiedId
operator|&
operator|)
operator|=
name|delete
decl_stmt|;
name|public
label|:
comment|/// \brief Describes the kind of unqualified-id parsed.
enum|enum
name|IdKind
block|{
comment|/// \brief An identifier.
name|IK_Identifier
block|,
comment|/// \brief An overloaded operator name, e.g., operator+.
name|IK_OperatorFunctionId
block|,
comment|/// \brief A conversion function name, e.g., operator int.
name|IK_ConversionFunctionId
block|,
comment|/// \brief A user-defined literal name, e.g., operator "" _i.
name|IK_LiteralOperatorId
block|,
comment|/// \brief A constructor name.
name|IK_ConstructorName
block|,
comment|/// \brief A constructor named via a template-id.
name|IK_ConstructorTemplateId
block|,
comment|/// \brief A destructor name.
name|IK_DestructorName
block|,
comment|/// \brief A template-id, e.g., f<int>.
name|IK_TemplateId
block|,
comment|/// \brief An implicit 'self' parameter
name|IK_ImplicitSelfParam
block|}
name|Kind
enum|;
struct|struct
name|OFI
block|{
comment|/// \brief The kind of overloaded operator.
name|OverloadedOperatorKind
name|Operator
decl_stmt|;
comment|/// \brief The source locations of the individual tokens that name
comment|/// the operator, e.g., the "new", "[", and "]" tokens in
comment|/// operator new [].
comment|///
comment|/// Different operators have different numbers of tokens in their name,
comment|/// up to three. Any remaining source locations in this array will be
comment|/// set to an invalid value for operators with fewer than three tokens.
name|unsigned
name|SymbolLocations
index|[
literal|3
index|]
decl_stmt|;
block|}
struct|;
comment|/// \brief Anonymous union that holds extra data associated with the
comment|/// parsed unqualified-id.
union|union
block|{
comment|/// \brief When Kind == IK_Identifier, the parsed identifier, or when Kind
comment|/// == IK_UserLiteralId, the identifier suffix.
name|IdentifierInfo
modifier|*
name|Identifier
decl_stmt|;
comment|/// \brief When Kind == IK_OperatorFunctionId, the overloaded operator
comment|/// that we parsed.
name|struct
name|OFI
name|OperatorFunctionId
decl_stmt|;
comment|/// \brief When Kind == IK_ConversionFunctionId, the type that the
comment|/// conversion function names.
name|UnionParsedType
name|ConversionFunctionId
decl_stmt|;
comment|/// \brief When Kind == IK_ConstructorName, the class-name of the type
comment|/// whose constructor is being referenced.
name|UnionParsedType
name|ConstructorName
decl_stmt|;
comment|/// \brief When Kind == IK_DestructorName, the type referred to by the
comment|/// class-name.
name|UnionParsedType
name|DestructorName
decl_stmt|;
comment|/// \brief When Kind == IK_TemplateId or IK_ConstructorTemplateId,
comment|/// the template-id annotation that contains the template name and
comment|/// template arguments.
name|TemplateIdAnnotation
modifier|*
name|TemplateId
decl_stmt|;
block|}
union|;
comment|/// \brief The location of the first token that describes this unqualified-id,
comment|/// which will be the location of the identifier, "operator" keyword,
comment|/// tilde (for a destructor), or the template name of a template-id.
name|SourceLocation
name|StartLocation
decl_stmt|;
comment|/// \brief The location of the last token that describes this unqualified-id.
name|SourceLocation
name|EndLocation
decl_stmt|;
name|UnqualifiedId
argument_list|()
operator|:
name|Kind
argument_list|(
name|IK_Identifier
argument_list|)
operator|,
name|Identifier
argument_list|(
argument|nullptr
argument_list|)
block|{ }
comment|/// \brief Clear out this unqualified-id, setting it to default (invalid)
comment|/// state.
name|void
name|clear
argument_list|()
block|{
name|Kind
operator|=
name|IK_Identifier
block|;
name|Identifier
operator|=
name|nullptr
block|;
name|StartLocation
operator|=
name|SourceLocation
argument_list|()
block|;
name|EndLocation
operator|=
name|SourceLocation
argument_list|()
block|;   }
comment|/// \brief Determine whether this unqualified-id refers to a valid name.
name|bool
name|isValid
argument_list|()
specifier|const
block|{
return|return
name|StartLocation
operator|.
name|isValid
argument_list|()
return|;
block|}
comment|/// \brief Determine whether this unqualified-id refers to an invalid name.
name|bool
name|isInvalid
argument_list|()
specifier|const
block|{
return|return
operator|!
name|isValid
argument_list|()
return|;
block|}
comment|/// \brief Determine what kind of name we have.
name|IdKind
name|getKind
argument_list|()
specifier|const
block|{
return|return
name|Kind
return|;
block|}
name|void
name|setKind
parameter_list|(
name|IdKind
name|kind
parameter_list|)
block|{
name|Kind
operator|=
name|kind
expr_stmt|;
block|}
comment|/// \brief Specify that this unqualified-id was parsed as an identifier.
comment|///
comment|/// \param Id the parsed identifier.
comment|/// \param IdLoc the location of the parsed identifier.
name|void
name|setIdentifier
parameter_list|(
specifier|const
name|IdentifierInfo
modifier|*
name|Id
parameter_list|,
name|SourceLocation
name|IdLoc
parameter_list|)
block|{
name|Kind
operator|=
name|IK_Identifier
expr_stmt|;
name|Identifier
operator|=
name|const_cast
operator|<
name|IdentifierInfo
operator|*
operator|>
operator|(
name|Id
operator|)
expr_stmt|;
name|StartLocation
operator|=
name|EndLocation
operator|=
name|IdLoc
expr_stmt|;
block|}
comment|/// \brief Specify that this unqualified-id was parsed as an
comment|/// operator-function-id.
comment|///
comment|/// \param OperatorLoc the location of the 'operator' keyword.
comment|///
comment|/// \param Op the overloaded operator.
comment|///
comment|/// \param SymbolLocations the locations of the individual operator symbols
comment|/// in the operator.
name|void
name|setOperatorFunctionId
parameter_list|(
name|SourceLocation
name|OperatorLoc
parameter_list|,
name|OverloadedOperatorKind
name|Op
parameter_list|,
name|SourceLocation
name|SymbolLocations
index|[
literal|3
index|]
parameter_list|)
function_decl|;
comment|/// \brief Specify that this unqualified-id was parsed as a
comment|/// conversion-function-id.
comment|///
comment|/// \param OperatorLoc the location of the 'operator' keyword.
comment|///
comment|/// \param Ty the type to which this conversion function is converting.
comment|///
comment|/// \param EndLoc the location of the last token that makes up the type name.
name|void
name|setConversionFunctionId
parameter_list|(
name|SourceLocation
name|OperatorLoc
parameter_list|,
name|ParsedType
name|Ty
parameter_list|,
name|SourceLocation
name|EndLoc
parameter_list|)
block|{
name|Kind
operator|=
name|IK_ConversionFunctionId
expr_stmt|;
name|StartLocation
operator|=
name|OperatorLoc
expr_stmt|;
name|EndLocation
operator|=
name|EndLoc
expr_stmt|;
name|ConversionFunctionId
operator|=
name|Ty
expr_stmt|;
block|}
comment|/// \brief Specific that this unqualified-id was parsed as a
comment|/// literal-operator-id.
comment|///
comment|/// \param Id the parsed identifier.
comment|///
comment|/// \param OpLoc the location of the 'operator' keyword.
comment|///
comment|/// \param IdLoc the location of the identifier.
name|void
name|setLiteralOperatorId
parameter_list|(
specifier|const
name|IdentifierInfo
modifier|*
name|Id
parameter_list|,
name|SourceLocation
name|OpLoc
parameter_list|,
name|SourceLocation
name|IdLoc
parameter_list|)
block|{
name|Kind
operator|=
name|IK_LiteralOperatorId
expr_stmt|;
name|Identifier
operator|=
name|const_cast
operator|<
name|IdentifierInfo
operator|*
operator|>
operator|(
name|Id
operator|)
expr_stmt|;
name|StartLocation
operator|=
name|OpLoc
expr_stmt|;
name|EndLocation
operator|=
name|IdLoc
expr_stmt|;
block|}
comment|/// \brief Specify that this unqualified-id was parsed as a constructor name.
comment|///
comment|/// \param ClassType the class type referred to by the constructor name.
comment|///
comment|/// \param ClassNameLoc the location of the class name.
comment|///
comment|/// \param EndLoc the location of the last token that makes up the type name.
name|void
name|setConstructorName
parameter_list|(
name|ParsedType
name|ClassType
parameter_list|,
name|SourceLocation
name|ClassNameLoc
parameter_list|,
name|SourceLocation
name|EndLoc
parameter_list|)
block|{
name|Kind
operator|=
name|IK_ConstructorName
expr_stmt|;
name|StartLocation
operator|=
name|ClassNameLoc
expr_stmt|;
name|EndLocation
operator|=
name|EndLoc
expr_stmt|;
name|ConstructorName
operator|=
name|ClassType
expr_stmt|;
block|}
comment|/// \brief Specify that this unqualified-id was parsed as a
comment|/// template-id that names a constructor.
comment|///
comment|/// \param TemplateId the template-id annotation that describes the parsed
comment|/// template-id. This UnqualifiedId instance will take ownership of the
comment|/// \p TemplateId and will free it on destruction.
name|void
name|setConstructorTemplateId
parameter_list|(
name|TemplateIdAnnotation
modifier|*
name|TemplateId
parameter_list|)
function_decl|;
comment|/// \brief Specify that this unqualified-id was parsed as a destructor name.
comment|///
comment|/// \param TildeLoc the location of the '~' that introduces the destructor
comment|/// name.
comment|///
comment|/// \param ClassType the name of the class referred to by the destructor name.
name|void
name|setDestructorName
parameter_list|(
name|SourceLocation
name|TildeLoc
parameter_list|,
name|ParsedType
name|ClassType
parameter_list|,
name|SourceLocation
name|EndLoc
parameter_list|)
block|{
name|Kind
operator|=
name|IK_DestructorName
expr_stmt|;
name|StartLocation
operator|=
name|TildeLoc
expr_stmt|;
name|EndLocation
operator|=
name|EndLoc
expr_stmt|;
name|DestructorName
operator|=
name|ClassType
expr_stmt|;
block|}
comment|/// \brief Specify that this unqualified-id was parsed as a template-id.
comment|///
comment|/// \param TemplateId the template-id annotation that describes the parsed
comment|/// template-id. This UnqualifiedId instance will take ownership of the
comment|/// \p TemplateId and will free it on destruction.
name|void
name|setTemplateId
parameter_list|(
name|TemplateIdAnnotation
modifier|*
name|TemplateId
parameter_list|)
function_decl|;
comment|/// \brief Return the source range that covers this unqualified-id.
name|SourceRange
name|getSourceRange
argument_list|()
specifier|const
name|LLVM_READONLY
block|{
return|return
name|SourceRange
argument_list|(
name|StartLocation
argument_list|,
name|EndLocation
argument_list|)
return|;
block|}
name|SourceLocation
name|getLocStart
argument_list|()
specifier|const
name|LLVM_READONLY
block|{
return|return
name|StartLocation
return|;
block|}
name|SourceLocation
name|getLocEnd
argument_list|()
specifier|const
name|LLVM_READONLY
block|{
return|return
name|EndLocation
return|;
block|}
block|}
empty_stmt|;
comment|/// \brief A set of tokens that has been cached for later parsing.
typedef|typedef
name|SmallVector
operator|<
name|Token
operator|,
literal|4
operator|>
name|CachedTokens
expr_stmt|;
comment|/// \brief One instance of this struct is used for each type in a
comment|/// declarator that is parsed.
comment|///
comment|/// This is intended to be a small value object.
struct|struct
name|DeclaratorChunk
block|{
enum|enum
block|{
name|Pointer
block|,
name|Reference
block|,
name|Array
block|,
name|Function
block|,
name|BlockPointer
block|,
name|MemberPointer
block|,
name|Paren
block|}
name|Kind
enum|;
comment|/// Loc - The place where this type was defined.
name|SourceLocation
name|Loc
decl_stmt|;
comment|/// EndLoc - If valid, the place where this chunck ends.
name|SourceLocation
name|EndLoc
decl_stmt|;
name|SourceRange
name|getSourceRange
argument_list|()
specifier|const
block|{
if|if
condition|(
name|EndLoc
operator|.
name|isInvalid
argument_list|()
condition|)
return|return
name|SourceRange
argument_list|(
name|Loc
argument_list|,
name|Loc
argument_list|)
return|;
return|return
name|SourceRange
argument_list|(
name|Loc
argument_list|,
name|EndLoc
argument_list|)
return|;
block|}
decl|struct
name|TypeInfoCommon
block|{
name|AttributeList
modifier|*
name|AttrList
decl_stmt|;
block|}
struct|;
name|struct
name|PointerTypeInfo
range|:
name|TypeInfoCommon
block|{
comment|/// The type qualifiers: const/volatile/restrict/atomic.
name|unsigned
name|TypeQuals
operator|:
literal|4
block|;
comment|/// The location of the const-qualifier, if any.
name|unsigned
name|ConstQualLoc
block|;
comment|/// The location of the volatile-qualifier, if any.
name|unsigned
name|VolatileQualLoc
block|;
comment|/// The location of the restrict-qualifier, if any.
name|unsigned
name|RestrictQualLoc
block|;
comment|/// The location of the _Atomic-qualifier, if any.
name|unsigned
name|AtomicQualLoc
block|;
name|void
name|destroy
argument_list|()
block|{     }
block|}
decl_stmt|;
name|struct
name|ReferenceTypeInfo
range|:
name|TypeInfoCommon
block|{
comment|/// The type qualifier: restrict. [GNU] C++ extension
name|bool
name|HasRestrict
operator|:
literal|1
block|;
comment|/// True if this is an lvalue reference, false if it's an rvalue reference.
name|bool
name|LValueRef
operator|:
literal|1
block|;
name|void
name|destroy
argument_list|()
block|{     }
block|}
decl_stmt|;
name|struct
name|ArrayTypeInfo
range|:
name|TypeInfoCommon
block|{
comment|/// The type qualifiers for the array: const/volatile/restrict/_Atomic.
name|unsigned
name|TypeQuals
operator|:
literal|4
block|;
comment|/// True if this dimension included the 'static' keyword.
name|bool
name|hasStatic
operator|:
literal|1
block|;
comment|/// True if this dimension was [*].  In this case, NumElts is null.
name|bool
name|isStar
operator|:
literal|1
block|;
comment|/// This is the size of the array, or null if [] or [*] was specified.
comment|/// Since the parser is multi-purpose, and we don't want to impose a root
comment|/// expression class on all clients, NumElts is untyped.
name|Expr
operator|*
name|NumElts
block|;
name|void
name|destroy
argument_list|()
block|{}
block|}
decl_stmt|;
comment|/// ParamInfo - An array of paraminfo objects is allocated whenever a function
comment|/// declarator is parsed.  There are two interesting styles of parameters
comment|/// here:
comment|/// K&R-style identifier lists and parameter type lists.  K&R-style identifier
comment|/// lists will have information about the identifier, but no type information.
comment|/// Parameter type lists will have type info (if the actions module provides
comment|/// it), but may have null identifier info: e.g. for 'void foo(int X, int)'.
struct|struct
name|ParamInfo
block|{
name|IdentifierInfo
modifier|*
name|Ident
decl_stmt|;
name|SourceLocation
name|IdentLoc
decl_stmt|;
name|Decl
modifier|*
name|Param
decl_stmt|;
comment|/// DefaultArgTokens - When the parameter's default argument
comment|/// cannot be parsed immediately (because it occurs within the
comment|/// declaration of a member function), it will be stored here as a
comment|/// sequence of tokens to be parsed once the class definition is
comment|/// complete. Non-NULL indicates that there is a default argument.
name|CachedTokens
modifier|*
name|DefaultArgTokens
decl_stmt|;
name|ParamInfo
argument_list|()
block|{}
name|ParamInfo
argument_list|(
argument|IdentifierInfo *ident
argument_list|,
argument|SourceLocation iloc
argument_list|,
argument|Decl *param
argument_list|,
argument|CachedTokens *DefArgTokens = nullptr
argument_list|)
block|:
name|Ident
argument_list|(
name|ident
argument_list|)
operator|,
name|IdentLoc
argument_list|(
name|iloc
argument_list|)
operator|,
name|Param
argument_list|(
name|param
argument_list|)
operator|,
name|DefaultArgTokens
argument_list|(
argument|DefArgTokens
argument_list|)
block|{}
block|}
struct|;
struct|struct
name|TypeAndRange
block|{
name|ParsedType
name|Ty
decl_stmt|;
name|SourceRange
name|Range
decl_stmt|;
block|}
struct|;
name|struct
name|FunctionTypeInfo
range|:
name|TypeInfoCommon
block|{
comment|/// hasPrototype - This is true if the function had at least one typed
comment|/// parameter.  If the function is () or (a,b,c), then it has no prototype,
comment|/// and is treated as a K&R-style function.
name|unsigned
name|hasPrototype
operator|:
literal|1
block|;
comment|/// isVariadic - If this function has a prototype, and if that
comment|/// proto ends with ',...)', this is true. When true, EllipsisLoc
comment|/// contains the location of the ellipsis.
name|unsigned
name|isVariadic
operator|:
literal|1
block|;
comment|/// Can this declaration be a constructor-style initializer?
name|unsigned
name|isAmbiguous
operator|:
literal|1
block|;
comment|/// \brief Whether the ref-qualifier (if any) is an lvalue reference.
comment|/// Otherwise, it's an rvalue reference.
name|unsigned
name|RefQualifierIsLValueRef
operator|:
literal|1
block|;
comment|/// The type qualifiers: const/volatile/restrict.
comment|/// The qualifier bitmask values are the same as in QualType.
name|unsigned
name|TypeQuals
operator|:
literal|3
block|;
comment|/// ExceptionSpecType - An ExceptionSpecificationType value.
name|unsigned
name|ExceptionSpecType
operator|:
literal|4
block|;
comment|/// DeleteParams - If this is true, we need to delete[] Params.
name|unsigned
name|DeleteParams
operator|:
literal|1
block|;
comment|/// HasTrailingReturnType - If this is true, a trailing return type was
comment|/// specified.
name|unsigned
name|HasTrailingReturnType
operator|:
literal|1
block|;
comment|/// The location of the left parenthesis in the source.
name|unsigned
name|LParenLoc
block|;
comment|/// When isVariadic is true, the location of the ellipsis in the source.
name|unsigned
name|EllipsisLoc
block|;
comment|/// The location of the right parenthesis in the source.
name|unsigned
name|RParenLoc
block|;
comment|/// NumParams - This is the number of formal parameters specified by the
comment|/// declarator.
name|unsigned
name|NumParams
block|;
comment|/// NumExceptions - This is the number of types in the dynamic-exception-
comment|/// decl, if the function has one.
name|unsigned
name|NumExceptions
block|;
comment|/// \brief The location of the ref-qualifier, if any.
comment|///
comment|/// If this is an invalid location, there is no ref-qualifier.
name|unsigned
name|RefQualifierLoc
block|;
comment|/// \brief The location of the const-qualifier, if any.
comment|///
comment|/// If this is an invalid location, there is no const-qualifier.
name|unsigned
name|ConstQualifierLoc
block|;
comment|/// \brief The location of the volatile-qualifier, if any.
comment|///
comment|/// If this is an invalid location, there is no volatile-qualifier.
name|unsigned
name|VolatileQualifierLoc
block|;
comment|/// \brief The location of the restrict-qualifier, if any.
comment|///
comment|/// If this is an invalid location, there is no restrict-qualifier.
name|unsigned
name|RestrictQualifierLoc
block|;
comment|/// \brief The location of the 'mutable' qualifer in a lambda-declarator, if
comment|/// any.
name|unsigned
name|MutableLoc
block|;
comment|/// \brief The beginning location of the exception specification, if any.
name|unsigned
name|ExceptionSpecLocBeg
block|;
comment|/// \brief The end location of the exception specification, if any.
name|unsigned
name|ExceptionSpecLocEnd
block|;
comment|/// Params - This is a pointer to a new[]'d array of ParamInfo objects that
comment|/// describe the parameters specified by this function declarator.  null if
comment|/// there are no parameters specified.
name|ParamInfo
operator|*
name|Params
block|;
expr|union
block|{
comment|/// \brief Pointer to a new[]'d array of TypeAndRange objects that
comment|/// contain the types in the function's dynamic exception specification
comment|/// and their locations, if there is one.
name|TypeAndRange
operator|*
name|Exceptions
block|;
comment|/// \brief Pointer to the expression in the noexcept-specifier of this
comment|/// function, if it has one.
name|Expr
operator|*
name|NoexceptExpr
block|;
comment|/// \brief Pointer to the cached tokens for an exception-specification
comment|/// that has not yet been parsed.
name|CachedTokens
operator|*
name|ExceptionSpecTokens
block|;     }
block|;
comment|/// \brief If HasTrailingReturnType is true, this is the trailing return
comment|/// type specified.
name|UnionParsedType
name|TrailingReturnType
block|;
comment|/// \brief Reset the parameter list to having zero parameters.
comment|///
comment|/// This is used in various places for error recovery.
name|void
name|freeParams
argument_list|()
block|{
for|for
control|(
name|unsigned
name|I
init|=
literal|0
init|;
name|I
operator|<
name|NumParams
condition|;
operator|++
name|I
control|)
block|{
name|delete
name|Params
index|[
name|I
index|]
operator|.
name|DefaultArgTokens
expr_stmt|;
name|Params
index|[
name|I
index|]
operator|.
name|DefaultArgTokens
operator|=
name|nullptr
expr_stmt|;
block|}
if|if
condition|(
name|DeleteParams
condition|)
block|{
name|delete
index|[]
name|Params
decl_stmt|;
name|DeleteParams
operator|=
name|false
expr_stmt|;
block|}
name|NumParams
operator|=
literal|0
expr_stmt|;
block|}
name|void
name|destroy
argument_list|()
block|{
if|if
condition|(
name|DeleteParams
condition|)
name|delete
index|[]
name|Params
decl_stmt|;
if|if
condition|(
name|getExceptionSpecType
argument_list|()
operator|==
name|EST_Dynamic
condition|)
name|delete
index|[]
name|Exceptions
decl_stmt|;
elseif|else
if|if
condition|(
name|getExceptionSpecType
argument_list|()
operator|==
name|EST_Unparsed
condition|)
name|delete
name|ExceptionSpecTokens
decl_stmt|;
block|}
comment|/// isKNRPrototype - Return true if this is a K&R style identifier list,
comment|/// like "void foo(a,b,c)".  In a function definition, this will be followed
comment|/// by the parameter type definitions.
name|bool
name|isKNRPrototype
argument_list|()
specifier|const
block|{
return|return
operator|!
name|hasPrototype
operator|&&
name|NumParams
operator|!=
literal|0
return|;
block|}
name|SourceLocation
name|getLParenLoc
argument_list|()
specifier|const
block|{
return|return
name|SourceLocation
operator|::
name|getFromRawEncoding
argument_list|(
name|LParenLoc
argument_list|)
return|;
block|}
name|SourceLocation
name|getEllipsisLoc
argument_list|()
specifier|const
block|{
return|return
name|SourceLocation
operator|::
name|getFromRawEncoding
argument_list|(
name|EllipsisLoc
argument_list|)
return|;
block|}
name|SourceLocation
name|getRParenLoc
argument_list|()
specifier|const
block|{
return|return
name|SourceLocation
operator|::
name|getFromRawEncoding
argument_list|(
name|RParenLoc
argument_list|)
return|;
block|}
name|SourceLocation
name|getExceptionSpecLocBeg
argument_list|()
specifier|const
block|{
return|return
name|SourceLocation
operator|::
name|getFromRawEncoding
argument_list|(
name|ExceptionSpecLocBeg
argument_list|)
return|;
block|}
name|SourceLocation
name|getExceptionSpecLocEnd
argument_list|()
specifier|const
block|{
return|return
name|SourceLocation
operator|::
name|getFromRawEncoding
argument_list|(
name|ExceptionSpecLocEnd
argument_list|)
return|;
block|}
name|SourceRange
name|getExceptionSpecRange
argument_list|()
specifier|const
block|{
return|return
name|SourceRange
argument_list|(
name|getExceptionSpecLocBeg
argument_list|()
argument_list|,
name|getExceptionSpecLocEnd
argument_list|()
argument_list|)
return|;
block|}
comment|/// \brief Retrieve the location of the ref-qualifier, if any.
name|SourceLocation
name|getRefQualifierLoc
argument_list|()
specifier|const
block|{
return|return
name|SourceLocation
operator|::
name|getFromRawEncoding
argument_list|(
name|RefQualifierLoc
argument_list|)
return|;
block|}
comment|/// \brief Retrieve the location of the 'const' qualifier, if any.
name|SourceLocation
name|getConstQualifierLoc
argument_list|()
specifier|const
block|{
return|return
name|SourceLocation
operator|::
name|getFromRawEncoding
argument_list|(
name|ConstQualifierLoc
argument_list|)
return|;
block|}
comment|/// \brief Retrieve the location of the 'volatile' qualifier, if any.
name|SourceLocation
name|getVolatileQualifierLoc
argument_list|()
specifier|const
block|{
return|return
name|SourceLocation
operator|::
name|getFromRawEncoding
argument_list|(
name|VolatileQualifierLoc
argument_list|)
return|;
block|}
comment|/// \brief Retrieve the location of the 'restrict' qualifier, if any.
name|SourceLocation
name|getRestrictQualifierLoc
argument_list|()
specifier|const
block|{
return|return
name|SourceLocation
operator|::
name|getFromRawEncoding
argument_list|(
name|RestrictQualifierLoc
argument_list|)
return|;
block|}
comment|/// \brief Retrieve the location of the 'mutable' qualifier, if any.
name|SourceLocation
name|getMutableLoc
argument_list|()
specifier|const
block|{
return|return
name|SourceLocation
operator|::
name|getFromRawEncoding
argument_list|(
name|MutableLoc
argument_list|)
return|;
block|}
comment|/// \brief Determine whether this function declaration contains a
comment|/// ref-qualifier.
name|bool
name|hasRefQualifier
argument_list|()
specifier|const
block|{
return|return
name|getRefQualifierLoc
argument_list|()
operator|.
name|isValid
argument_list|()
return|;
block|}
comment|/// \brief Determine whether this lambda-declarator contains a 'mutable'
comment|/// qualifier.
name|bool
name|hasMutableQualifier
argument_list|()
specifier|const
block|{
return|return
name|getMutableLoc
argument_list|()
operator|.
name|isValid
argument_list|()
return|;
block|}
comment|/// \brief Get the type of exception specification this function has.
name|ExceptionSpecificationType
name|getExceptionSpecType
argument_list|()
specifier|const
block|{
return|return
name|static_cast
operator|<
name|ExceptionSpecificationType
operator|>
operator|(
name|ExceptionSpecType
operator|)
return|;
block|}
comment|/// \brief Determine whether this function declarator had a
comment|/// trailing-return-type.
name|bool
name|hasTrailingReturnType
argument_list|()
specifier|const
block|{
return|return
name|HasTrailingReturnType
return|;
block|}
comment|/// \brief Get the trailing-return-type for this function declarator.
name|ParsedType
name|getTrailingReturnType
argument_list|()
specifier|const
block|{
return|return
name|TrailingReturnType
return|;
block|}
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_decl_stmt
name|struct
name|BlockPointerTypeInfo
range|:
name|TypeInfoCommon
block|{
comment|/// For now, sema will catch these as invalid.
comment|/// The type qualifiers: const/volatile/restrict/_Atomic.
name|unsigned
name|TypeQuals
operator|:
literal|4
block|;
name|void
name|destroy
argument_list|()
block|{     }
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|MemberPointerTypeInfo
range|:
name|TypeInfoCommon
block|{
comment|/// The type qualifiers: const/volatile/restrict/_Atomic.
name|unsigned
name|TypeQuals
operator|:
literal|4
block|;
comment|// CXXScopeSpec has a constructor, so it can't be a direct member.
comment|// So we need some pointer-aligned storage and a bit of trickery.
expr|union
block|{
name|void
operator|*
name|Aligner
block|;
name|char
name|Mem
index|[
sizeof|sizeof
argument_list|(
name|CXXScopeSpec
argument_list|)
index|]
block|;     }
name|ScopeMem
block|;
name|CXXScopeSpec
operator|&
name|Scope
argument_list|()
block|{
return|return
operator|*
name|reinterpret_cast
operator|<
name|CXXScopeSpec
operator|*
operator|>
operator|(
name|ScopeMem
operator|.
name|Mem
operator|)
return|;
block|}
specifier|const
name|CXXScopeSpec
operator|&
name|Scope
argument_list|()
specifier|const
block|{
return|return
operator|*
name|reinterpret_cast
operator|<
specifier|const
name|CXXScopeSpec
operator|*
operator|>
operator|(
name|ScopeMem
operator|.
name|Mem
operator|)
return|;
block|}
name|void
name|destroy
argument_list|()
block|{
name|Scope
argument_list|()
operator|.
operator|~
name|CXXScopeSpec
argument_list|()
block|;     }
expr|}
block|;
expr|union
block|{
name|TypeInfoCommon
name|Common
block|;
name|PointerTypeInfo
name|Ptr
block|;
name|ReferenceTypeInfo
name|Ref
block|;
name|ArrayTypeInfo
name|Arr
block|;
name|FunctionTypeInfo
name|Fun
block|;
name|BlockPointerTypeInfo
name|Cls
block|;
name|MemberPointerTypeInfo
name|Mem
block|;   }
block|;
name|void
name|destroy
argument_list|()
block|{
switch|switch
condition|(
name|Kind
condition|)
block|{
case|case
name|DeclaratorChunk
operator|::
name|Function
case|:
return|return
name|Fun
operator|.
name|destroy
argument_list|()
return|;
case|case
name|DeclaratorChunk
operator|::
name|Pointer
case|:
return|return
name|Ptr
operator|.
name|destroy
argument_list|()
return|;
case|case
name|DeclaratorChunk
operator|::
name|BlockPointer
case|:
return|return
name|Cls
operator|.
name|destroy
argument_list|()
return|;
case|case
name|DeclaratorChunk
operator|::
name|Reference
case|:
return|return
name|Ref
operator|.
name|destroy
argument_list|()
return|;
case|case
name|DeclaratorChunk
operator|::
name|Array
case|:
return|return
name|Arr
operator|.
name|destroy
argument_list|()
return|;
case|case
name|DeclaratorChunk
operator|::
name|MemberPointer
case|:
return|return
name|Mem
operator|.
name|destroy
argument_list|()
return|;
case|case
name|DeclaratorChunk
operator|::
name|Paren
case|:
return|return;
block|}
block|}
comment|/// \brief If there are attributes applied to this declaratorchunk, return
comment|/// them.
specifier|const
name|AttributeList
operator|*
name|getAttrs
argument_list|()
specifier|const
block|{
return|return
name|Common
operator|.
name|AttrList
return|;
block|}
name|AttributeList
operator|*
operator|&
name|getAttrListRef
argument_list|()
block|{
return|return
name|Common
operator|.
name|AttrList
return|;
block|}
comment|/// \brief Return a DeclaratorChunk for a pointer.
specifier|static
name|DeclaratorChunk
name|getPointer
argument_list|(
argument|unsigned TypeQuals
argument_list|,
argument|SourceLocation Loc
argument_list|,
argument|SourceLocation ConstQualLoc
argument_list|,
argument|SourceLocation VolatileQualLoc
argument_list|,
argument|SourceLocation RestrictQualLoc
argument_list|,
argument|SourceLocation AtomicQualLoc
argument_list|)
block|{
name|DeclaratorChunk
name|I
block|;
name|I
operator|.
name|Kind
operator|=
name|Pointer
block|;
name|I
operator|.
name|Loc
operator|=
name|Loc
block|;
name|I
operator|.
name|Ptr
operator|.
name|TypeQuals
operator|=
name|TypeQuals
block|;
name|I
operator|.
name|Ptr
operator|.
name|ConstQualLoc
operator|=
name|ConstQualLoc
operator|.
name|getRawEncoding
argument_list|()
block|;
name|I
operator|.
name|Ptr
operator|.
name|VolatileQualLoc
operator|=
name|VolatileQualLoc
operator|.
name|getRawEncoding
argument_list|()
block|;
name|I
operator|.
name|Ptr
operator|.
name|RestrictQualLoc
operator|=
name|RestrictQualLoc
operator|.
name|getRawEncoding
argument_list|()
block|;
name|I
operator|.
name|Ptr
operator|.
name|AtomicQualLoc
operator|=
name|AtomicQualLoc
operator|.
name|getRawEncoding
argument_list|()
block|;
name|I
operator|.
name|Ptr
operator|.
name|AttrList
operator|=
name|nullptr
block|;
return|return
name|I
return|;
block|}
comment|/// \brief Return a DeclaratorChunk for a reference.
specifier|static
name|DeclaratorChunk
name|getReference
argument_list|(
argument|unsigned TypeQuals
argument_list|,
argument|SourceLocation Loc
argument_list|,
argument|bool lvalue
argument_list|)
block|{
name|DeclaratorChunk
name|I
block|;
name|I
operator|.
name|Kind
operator|=
name|Reference
block|;
name|I
operator|.
name|Loc
operator|=
name|Loc
block|;
name|I
operator|.
name|Ref
operator|.
name|HasRestrict
operator|=
operator|(
name|TypeQuals
operator|&
name|DeclSpec
operator|::
name|TQ_restrict
operator|)
operator|!=
literal|0
block|;
name|I
operator|.
name|Ref
operator|.
name|LValueRef
operator|=
name|lvalue
block|;
name|I
operator|.
name|Ref
operator|.
name|AttrList
operator|=
name|nullptr
block|;
return|return
name|I
return|;
block|}
comment|/// \brief Return a DeclaratorChunk for an array.
specifier|static
name|DeclaratorChunk
name|getArray
argument_list|(
argument|unsigned TypeQuals
argument_list|,
argument|bool isStatic
argument_list|,
argument|bool isStar
argument_list|,
argument|Expr *NumElts
argument_list|,
argument|SourceLocation LBLoc
argument_list|,
argument|SourceLocation RBLoc
argument_list|)
block|{
name|DeclaratorChunk
name|I
block|;
name|I
operator|.
name|Kind
operator|=
name|Array
block|;
name|I
operator|.
name|Loc
operator|=
name|LBLoc
block|;
name|I
operator|.
name|EndLoc
operator|=
name|RBLoc
block|;
name|I
operator|.
name|Arr
operator|.
name|AttrList
operator|=
name|nullptr
block|;
name|I
operator|.
name|Arr
operator|.
name|TypeQuals
operator|=
name|TypeQuals
block|;
name|I
operator|.
name|Arr
operator|.
name|hasStatic
operator|=
name|isStatic
block|;
name|I
operator|.
name|Arr
operator|.
name|isStar
operator|=
name|isStar
block|;
name|I
operator|.
name|Arr
operator|.
name|NumElts
operator|=
name|NumElts
block|;
return|return
name|I
return|;
block|}
comment|/// DeclaratorChunk::getFunction - Return a DeclaratorChunk for a function.
comment|/// "TheDeclarator" is the declarator that this will be added to.
specifier|static
name|DeclaratorChunk
name|getFunction
argument_list|(
argument|bool HasProto
argument_list|,
argument|bool IsAmbiguous
argument_list|,
argument|SourceLocation LParenLoc
argument_list|,
argument|ParamInfo *Params
argument_list|,
argument|unsigned NumParams
argument_list|,
argument|SourceLocation EllipsisLoc
argument_list|,
argument|SourceLocation RParenLoc
argument_list|,
argument|unsigned TypeQuals
argument_list|,
argument|bool RefQualifierIsLvalueRef
argument_list|,
argument|SourceLocation RefQualifierLoc
argument_list|,
argument|SourceLocation ConstQualifierLoc
argument_list|,
argument|SourceLocation VolatileQualifierLoc
argument_list|,
argument|SourceLocation RestrictQualifierLoc
argument_list|,
argument|SourceLocation MutableLoc
argument_list|,
argument|ExceptionSpecificationType ESpecType
argument_list|,
argument|SourceRange ESpecRange
argument_list|,
argument|ParsedType *Exceptions
argument_list|,
argument|SourceRange *ExceptionRanges
argument_list|,
argument|unsigned NumExceptions
argument_list|,
argument|Expr *NoexceptExpr
argument_list|,
argument|CachedTokens *ExceptionSpecTokens
argument_list|,
argument|SourceLocation LocalRangeBegin
argument_list|,
argument|SourceLocation LocalRangeEnd
argument_list|,
argument|Declarator&TheDeclarator
argument_list|,
argument|TypeResult TrailingReturnType =                                                     TypeResult()
argument_list|)
block|;
comment|/// \brief Return a DeclaratorChunk for a block.
specifier|static
name|DeclaratorChunk
name|getBlockPointer
argument_list|(
argument|unsigned TypeQuals
argument_list|,
argument|SourceLocation Loc
argument_list|)
block|{
name|DeclaratorChunk
name|I
block|;
name|I
operator|.
name|Kind
operator|=
name|BlockPointer
block|;
name|I
operator|.
name|Loc
operator|=
name|Loc
block|;
name|I
operator|.
name|Cls
operator|.
name|TypeQuals
operator|=
name|TypeQuals
block|;
name|I
operator|.
name|Cls
operator|.
name|AttrList
operator|=
name|nullptr
block|;
return|return
name|I
return|;
block|}
specifier|static
name|DeclaratorChunk
name|getMemberPointer
argument_list|(
argument|const CXXScopeSpec&SS
argument_list|,
argument|unsigned TypeQuals
argument_list|,
argument|SourceLocation Loc
argument_list|)
block|{
name|DeclaratorChunk
name|I
block|;
name|I
operator|.
name|Kind
operator|=
name|MemberPointer
block|;
name|I
operator|.
name|Loc
operator|=
name|SS
operator|.
name|getBeginLoc
argument_list|()
block|;
name|I
operator|.
name|EndLoc
operator|=
name|Loc
block|;
name|I
operator|.
name|Mem
operator|.
name|TypeQuals
operator|=
name|TypeQuals
block|;
name|I
operator|.
name|Mem
operator|.
name|AttrList
operator|=
name|nullptr
block|;
name|new
argument_list|(
argument|I.Mem.ScopeMem.Mem
argument_list|)
name|CXXScopeSpec
argument_list|(
name|SS
argument_list|)
block|;
return|return
name|I
return|;
block|}
comment|/// \brief Return a DeclaratorChunk for a paren.
specifier|static
name|DeclaratorChunk
name|getParen
argument_list|(
argument|SourceLocation LParenLoc
argument_list|,
argument|SourceLocation RParenLoc
argument_list|)
block|{
name|DeclaratorChunk
name|I
block|;
name|I
operator|.
name|Kind
operator|=
name|Paren
block|;
name|I
operator|.
name|Loc
operator|=
name|LParenLoc
block|;
name|I
operator|.
name|EndLoc
operator|=
name|RParenLoc
block|;
name|I
operator|.
name|Common
operator|.
name|AttrList
operator|=
name|nullptr
block|;
return|return
name|I
return|;
block|}
name|bool
name|isParen
argument_list|()
specifier|const
block|{
return|return
name|Kind
operator|==
name|Paren
return|;
block|}
expr|}
block|;
comment|/// \brief Described the kind of function definition (if any) provided for
comment|/// a function.
block|enum
name|FunctionDefinitionKind
block|{
name|FDK_Declaration
block|,
name|FDK_Definition
block|,
name|FDK_Defaulted
block|,
name|FDK_Deleted
block|}
block|;
comment|/// \brief Information about one declarator, including the parsed type
comment|/// information and the identifier.
comment|///
comment|/// When the declarator is fully formed, this is turned into the appropriate
comment|/// Decl object.
comment|///
comment|/// Declarators come in two types: normal declarators and abstract declarators.
comment|/// Abstract declarators are used when parsing types, and don't have an
comment|/// identifier.  Normal declarators do have ID's.
comment|///
comment|/// Instances of this class should be a transient object that lives on the
comment|/// stack, not objects that are allocated in large quantities on the heap.
name|class
name|Declarator
block|{
name|public
operator|:
expr|enum
name|TheContext
block|{
name|FileContext
block|,
comment|// File scope declaration.
name|PrototypeContext
block|,
comment|// Within a function prototype.
name|ObjCResultContext
block|,
comment|// An ObjC method result type.
name|ObjCParameterContext
block|,
comment|// An ObjC method parameter type.
name|KNRTypeListContext
block|,
comment|// K&R type definition list for formals.
name|TypeNameContext
block|,
comment|// Abstract declarator for types.
name|MemberContext
block|,
comment|// Struct/Union field.
name|BlockContext
block|,
comment|// Declaration within a block in a function.
name|ForContext
block|,
comment|// Declaration within first part of a for loop.
name|ConditionContext
block|,
comment|// Condition declaration in a C++ if/switch/while/for.
name|TemplateParamContext
block|,
comment|// Within a template parameter list.
name|CXXNewContext
block|,
comment|// C++ new-expression.
name|CXXCatchContext
block|,
comment|// C++ catch exception-declaration
name|ObjCCatchContext
block|,
comment|// Objective-C catch exception-declaration
name|BlockLiteralContext
block|,
comment|// Block literal declarator.
name|LambdaExprContext
block|,
comment|// Lambda-expression declarator.
name|LambdaExprParameterContext
block|,
comment|// Lambda-expression parameter declarator.
name|ConversionIdContext
block|,
comment|// C++ conversion-type-id.
name|TrailingReturnContext
block|,
comment|// C++11 trailing-type-specifier.
name|TemplateTypeArgContext
block|,
comment|// Template type argument.
name|AliasDeclContext
block|,
comment|// C++11 alias-declaration.
name|AliasTemplateContext
comment|// C++11 alias-declaration template.
block|}
block|;
name|private
operator|:
specifier|const
name|DeclSpec
operator|&
name|DS
block|;
name|CXXScopeSpec
name|SS
block|;
name|UnqualifiedId
name|Name
block|;
name|SourceRange
name|Range
block|;
comment|/// \brief Where we are parsing this declarator.
name|TheContext
name|Context
block|;
comment|/// DeclTypeInfo - This holds each type that the declarator includes as it is
comment|/// parsed.  This is pushed from the identifier out, which means that element
comment|/// #0 will be the most closely bound to the identifier, and
comment|/// DeclTypeInfo.back() will be the least closely bound.
name|SmallVector
operator|<
name|DeclaratorChunk
block|,
literal|8
operator|>
name|DeclTypeInfo
block|;
comment|/// InvalidType - Set by Sema::GetTypeForDeclarator().
name|bool
name|InvalidType
operator|:
literal|1
block|;
comment|/// GroupingParens - Set by Parser::ParseParenDeclarator().
name|bool
name|GroupingParens
operator|:
literal|1
block|;
comment|/// FunctionDefinition - Is this Declarator for a function or member
comment|/// definition and, if so, what kind?
comment|///
comment|/// Actually a FunctionDefinitionKind.
name|unsigned
name|FunctionDefinition
operator|:
literal|2
block|;
comment|/// \brief Is this Declarator a redeclaration?
name|bool
name|Redeclaration
operator|:
literal|1
block|;
comment|/// Attrs - Attributes.
name|ParsedAttributes
name|Attrs
block|;
comment|/// \brief The asm label, if specified.
name|Expr
operator|*
name|AsmLabel
block|;
comment|/// InlineParams - This is a local array used for the first function decl
comment|/// chunk to avoid going to the heap for the common case when we have one
comment|/// function chunk in the declarator.
name|DeclaratorChunk
operator|::
name|ParamInfo
name|InlineParams
index|[
literal|16
index|]
block|;
name|bool
name|InlineParamsUsed
block|;
comment|/// \brief true if the declaration is preceded by \c __extension__.
name|unsigned
name|Extension
operator|:
literal|1
block|;
comment|/// Indicates whether this is an Objective-C instance variable.
name|unsigned
name|ObjCIvar
operator|:
literal|1
block|;
comment|/// Indicates whether this is an Objective-C 'weak' property.
name|unsigned
name|ObjCWeakProperty
operator|:
literal|1
block|;
comment|/// \brief If this is the second or subsequent declarator in this declaration,
comment|/// the location of the comma before this declarator.
name|SourceLocation
name|CommaLoc
block|;
comment|/// \brief If provided, the source location of the ellipsis used to describe
comment|/// this declarator as a parameter pack.
name|SourceLocation
name|EllipsisLoc
block|;
name|friend
expr|struct
name|DeclaratorChunk
block|;
name|public
operator|:
name|Declarator
argument_list|(
argument|const DeclSpec&ds
argument_list|,
argument|TheContext C
argument_list|)
operator|:
name|DS
argument_list|(
name|ds
argument_list|)
block|,
name|Range
argument_list|(
name|ds
operator|.
name|getSourceRange
argument_list|()
argument_list|)
block|,
name|Context
argument_list|(
name|C
argument_list|)
block|,
name|InvalidType
argument_list|(
name|DS
operator|.
name|getTypeSpecType
argument_list|()
operator|==
name|DeclSpec
operator|::
name|TST_error
argument_list|)
block|,
name|GroupingParens
argument_list|(
name|false
argument_list|)
block|,
name|FunctionDefinition
argument_list|(
name|FDK_Declaration
argument_list|)
block|,
name|Redeclaration
argument_list|(
name|false
argument_list|)
block|,
name|Attrs
argument_list|(
name|ds
operator|.
name|getAttributePool
argument_list|()
operator|.
name|getFactory
argument_list|()
argument_list|)
block|,
name|AsmLabel
argument_list|(
name|nullptr
argument_list|)
block|,
name|InlineParamsUsed
argument_list|(
name|false
argument_list|)
block|,
name|Extension
argument_list|(
name|false
argument_list|)
block|,
name|ObjCIvar
argument_list|(
name|false
argument_list|)
block|,
name|ObjCWeakProperty
argument_list|(
argument|false
argument_list|)
block|{   }
operator|~
name|Declarator
argument_list|()
block|{
name|clear
argument_list|()
block|;   }
comment|/// getDeclSpec - Return the declaration-specifier that this declarator was
comment|/// declared with.
specifier|const
name|DeclSpec
operator|&
name|getDeclSpec
argument_list|()
specifier|const
block|{
return|return
name|DS
return|;
block|}
comment|/// getMutableDeclSpec - Return a non-const version of the DeclSpec.  This
comment|/// should be used with extreme care: declspecs can often be shared between
comment|/// multiple declarators, so mutating the DeclSpec affects all of the
comment|/// Declarators.  This should only be done when the declspec is known to not
comment|/// be shared or when in error recovery etc.
name|DeclSpec
operator|&
name|getMutableDeclSpec
argument_list|()
block|{
return|return
name|const_cast
operator|<
name|DeclSpec
operator|&
operator|>
operator|(
name|DS
operator|)
return|;
block|}
name|AttributePool
operator|&
name|getAttributePool
argument_list|()
specifier|const
block|{
return|return
name|Attrs
operator|.
name|getPool
argument_list|()
return|;
block|}
comment|/// getCXXScopeSpec - Return the C++ scope specifier (global scope or
comment|/// nested-name-specifier) that is part of the declarator-id.
specifier|const
name|CXXScopeSpec
operator|&
name|getCXXScopeSpec
argument_list|()
specifier|const
block|{
return|return
name|SS
return|;
block|}
name|CXXScopeSpec
operator|&
name|getCXXScopeSpec
argument_list|()
block|{
return|return
name|SS
return|;
block|}
comment|/// \brief Retrieve the name specified by this declarator.
name|UnqualifiedId
operator|&
name|getName
argument_list|()
block|{
return|return
name|Name
return|;
block|}
name|TheContext
name|getContext
argument_list|()
specifier|const
block|{
return|return
name|Context
return|;
block|}
name|bool
name|isPrototypeContext
argument_list|()
specifier|const
block|{
return|return
operator|(
name|Context
operator|==
name|PrototypeContext
operator|||
name|Context
operator|==
name|ObjCParameterContext
operator|||
name|Context
operator|==
name|ObjCResultContext
operator|||
name|Context
operator|==
name|LambdaExprParameterContext
operator|)
return|;
block|}
comment|/// \brief Get the source range that spans this declarator.
name|SourceRange
name|getSourceRange
argument_list|()
specifier|const
name|LLVM_READONLY
block|{
return|return
name|Range
return|;
block|}
name|SourceLocation
name|getLocStart
argument_list|()
specifier|const
name|LLVM_READONLY
block|{
return|return
name|Range
operator|.
name|getBegin
argument_list|()
return|;
block|}
name|SourceLocation
name|getLocEnd
argument_list|()
specifier|const
name|LLVM_READONLY
block|{
return|return
name|Range
operator|.
name|getEnd
argument_list|()
return|;
block|}
name|void
name|SetSourceRange
argument_list|(
argument|SourceRange R
argument_list|)
block|{
name|Range
operator|=
name|R
block|; }
comment|/// SetRangeBegin - Set the start of the source range to Loc, unless it's
comment|/// invalid.
name|void
name|SetRangeBegin
argument_list|(
argument|SourceLocation Loc
argument_list|)
block|{
if|if
condition|(
operator|!
name|Loc
operator|.
name|isInvalid
argument_list|()
condition|)
name|Range
operator|.
name|setBegin
argument_list|(
name|Loc
argument_list|)
expr_stmt|;
block|}
comment|/// SetRangeEnd - Set the end of the source range to Loc, unless it's invalid.
name|void
name|SetRangeEnd
argument_list|(
argument|SourceLocation Loc
argument_list|)
block|{
if|if
condition|(
operator|!
name|Loc
operator|.
name|isInvalid
argument_list|()
condition|)
name|Range
operator|.
name|setEnd
argument_list|(
name|Loc
argument_list|)
expr_stmt|;
block|}
comment|/// ExtendWithDeclSpec - Extend the declarator source range to include the
comment|/// given declspec, unless its location is invalid. Adopts the range start if
comment|/// the current range start is invalid.
name|void
name|ExtendWithDeclSpec
argument_list|(
argument|const DeclSpec&DS
argument_list|)
block|{
name|SourceRange
name|SR
operator|=
name|DS
operator|.
name|getSourceRange
argument_list|()
block|;
if|if
condition|(
name|Range
operator|.
name|getBegin
argument_list|()
operator|.
name|isInvalid
argument_list|()
condition|)
name|Range
operator|.
name|setBegin
argument_list|(
name|SR
operator|.
name|getBegin
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|SR
operator|.
name|getEnd
argument_list|()
operator|.
name|isInvalid
argument_list|()
condition|)
name|Range
operator|.
name|setEnd
argument_list|(
name|SR
operator|.
name|getEnd
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/// \brief Reset the contents of this Declarator.
name|void
name|clear
argument_list|()
block|{
name|SS
operator|.
name|clear
argument_list|()
block|;
name|Name
operator|.
name|clear
argument_list|()
block|;
name|Range
operator|=
name|DS
operator|.
name|getSourceRange
argument_list|()
block|;
for|for
control|(
name|unsigned
name|i
init|=
literal|0
init|,
name|e
init|=
name|DeclTypeInfo
operator|.
name|size
argument_list|()
init|;
name|i
operator|!=
name|e
condition|;
operator|++
name|i
control|)
name|DeclTypeInfo
index|[
name|i
index|]
operator|.
name|destroy
argument_list|()
expr_stmt|;
name|DeclTypeInfo
operator|.
name|clear
argument_list|()
block|;
name|Attrs
operator|.
name|clear
argument_list|()
block|;
name|AsmLabel
operator|=
name|nullptr
block|;
name|InlineParamsUsed
operator|=
name|false
block|;
name|ObjCIvar
operator|=
name|false
block|;
name|ObjCWeakProperty
operator|=
name|false
block|;
name|CommaLoc
operator|=
name|SourceLocation
argument_list|()
block|;
name|EllipsisLoc
operator|=
name|SourceLocation
argument_list|()
block|;   }
comment|/// mayOmitIdentifier - Return true if the identifier is either optional or
comment|/// not allowed.  This is true for typenames, prototypes, and template
comment|/// parameter lists.
name|bool
name|mayOmitIdentifier
argument_list|()
specifier|const
block|{
switch|switch
condition|(
name|Context
condition|)
block|{
case|case
name|FileContext
case|:
case|case
name|KNRTypeListContext
case|:
case|case
name|MemberContext
case|:
case|case
name|BlockContext
case|:
case|case
name|ForContext
case|:
case|case
name|ConditionContext
case|:
return|return
name|false
return|;
case|case
name|TypeNameContext
case|:
case|case
name|AliasDeclContext
case|:
case|case
name|AliasTemplateContext
case|:
case|case
name|PrototypeContext
case|:
case|case
name|LambdaExprParameterContext
case|:
case|case
name|ObjCParameterContext
case|:
case|case
name|ObjCResultContext
case|:
case|case
name|TemplateParamContext
case|:
case|case
name|CXXNewContext
case|:
case|case
name|CXXCatchContext
case|:
case|case
name|ObjCCatchContext
case|:
case|case
name|BlockLiteralContext
case|:
case|case
name|LambdaExprContext
case|:
case|case
name|ConversionIdContext
case|:
case|case
name|TemplateTypeArgContext
case|:
case|case
name|TrailingReturnContext
case|:
return|return
name|true
return|;
block|}
name|llvm_unreachable
argument_list|(
literal|"unknown context kind!"
argument_list|)
expr_stmt|;
block|}
comment|/// mayHaveIdentifier - Return true if the identifier is either optional or
comment|/// required.  This is true for normal declarators and prototypes, but not
comment|/// typenames.
name|bool
name|mayHaveIdentifier
argument_list|()
specifier|const
block|{
switch|switch
condition|(
name|Context
condition|)
block|{
case|case
name|FileContext
case|:
case|case
name|KNRTypeListContext
case|:
case|case
name|MemberContext
case|:
case|case
name|BlockContext
case|:
case|case
name|ForContext
case|:
case|case
name|ConditionContext
case|:
case|case
name|PrototypeContext
case|:
case|case
name|LambdaExprParameterContext
case|:
case|case
name|TemplateParamContext
case|:
case|case
name|CXXCatchContext
case|:
case|case
name|ObjCCatchContext
case|:
return|return
name|true
return|;
case|case
name|TypeNameContext
case|:
case|case
name|CXXNewContext
case|:
case|case
name|AliasDeclContext
case|:
case|case
name|AliasTemplateContext
case|:
case|case
name|ObjCParameterContext
case|:
case|case
name|ObjCResultContext
case|:
case|case
name|BlockLiteralContext
case|:
case|case
name|LambdaExprContext
case|:
case|case
name|ConversionIdContext
case|:
case|case
name|TemplateTypeArgContext
case|:
case|case
name|TrailingReturnContext
case|:
return|return
name|false
return|;
block|}
name|llvm_unreachable
argument_list|(
literal|"unknown context kind!"
argument_list|)
expr_stmt|;
block|}
comment|/// diagnoseIdentifier - Return true if the identifier is prohibited and
comment|/// should be diagnosed (because it cannot be anything else).
name|bool
name|diagnoseIdentifier
argument_list|()
specifier|const
block|{
switch|switch
condition|(
name|Context
condition|)
block|{
case|case
name|FileContext
case|:
case|case
name|KNRTypeListContext
case|:
case|case
name|MemberContext
case|:
case|case
name|BlockContext
case|:
case|case
name|ForContext
case|:
case|case
name|ConditionContext
case|:
case|case
name|PrototypeContext
case|:
case|case
name|LambdaExprParameterContext
case|:
case|case
name|TemplateParamContext
case|:
case|case
name|CXXCatchContext
case|:
case|case
name|ObjCCatchContext
case|:
case|case
name|TypeNameContext
case|:
case|case
name|ConversionIdContext
case|:
case|case
name|ObjCParameterContext
case|:
case|case
name|ObjCResultContext
case|:
case|case
name|BlockLiteralContext
case|:
case|case
name|CXXNewContext
case|:
case|case
name|LambdaExprContext
case|:
return|return
name|false
return|;
case|case
name|AliasDeclContext
case|:
case|case
name|AliasTemplateContext
case|:
case|case
name|TemplateTypeArgContext
case|:
case|case
name|TrailingReturnContext
case|:
return|return
name|true
return|;
block|}
name|llvm_unreachable
argument_list|(
literal|"unknown context kind!"
argument_list|)
expr_stmt|;
block|}
comment|/// mayBeFollowedByCXXDirectInit - Return true if the declarator can be
comment|/// followed by a C++ direct initializer, e.g. "int x(1);".
name|bool
name|mayBeFollowedByCXXDirectInit
argument_list|()
specifier|const
block|{
if|if
condition|(
name|hasGroupingParens
argument_list|()
condition|)
return|return
name|false
return|;
end_decl_stmt

begin_if
if|if
condition|(
name|getDeclSpec
argument_list|()
operator|.
name|getStorageClassSpec
argument_list|()
operator|==
name|DeclSpec
operator|::
name|SCS_typedef
condition|)
return|return
name|false
return|;
end_if

begin_if
if|if
condition|(
name|getDeclSpec
argument_list|()
operator|.
name|getStorageClassSpec
argument_list|()
operator|==
name|DeclSpec
operator|::
name|SCS_extern
operator|&&
name|Context
operator|!=
name|FileContext
condition|)
return|return
name|false
return|;
end_if

begin_comment
comment|// Special names can't have direct initializers.
end_comment

begin_if
if|if
condition|(
name|Name
operator|.
name|getKind
argument_list|()
operator|!=
name|UnqualifiedId
operator|::
name|IK_Identifier
condition|)
return|return
name|false
return|;
end_if

begin_switch
switch|switch
condition|(
name|Context
condition|)
block|{
case|case
name|FileContext
case|:
case|case
name|BlockContext
case|:
case|case
name|ForContext
case|:
return|return
name|true
return|;
case|case
name|ConditionContext
case|:
comment|// This may not be followed by a direct initializer, but it can't be a
comment|// function declaration either, and we'd prefer to perform a tentative
comment|// parse in order to produce the right diagnostic.
return|return
name|true
return|;
case|case
name|KNRTypeListContext
case|:
case|case
name|MemberContext
case|:
case|case
name|PrototypeContext
case|:
case|case
name|LambdaExprParameterContext
case|:
case|case
name|ObjCParameterContext
case|:
case|case
name|ObjCResultContext
case|:
case|case
name|TemplateParamContext
case|:
case|case
name|CXXCatchContext
case|:
case|case
name|ObjCCatchContext
case|:
case|case
name|TypeNameContext
case|:
case|case
name|CXXNewContext
case|:
case|case
name|AliasDeclContext
case|:
case|case
name|AliasTemplateContext
case|:
case|case
name|BlockLiteralContext
case|:
case|case
name|LambdaExprContext
case|:
case|case
name|ConversionIdContext
case|:
case|case
name|TemplateTypeArgContext
case|:
case|case
name|TrailingReturnContext
case|:
return|return
name|false
return|;
block|}
end_switch

begin_expr_stmt
name|llvm_unreachable
argument_list|(
literal|"unknown context kind!"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
unit|}
comment|/// isPastIdentifier - Return true if we have parsed beyond the point where
end_comment

begin_comment
comment|/// the
end_comment

begin_macro
unit|bool
name|isPastIdentifier
argument_list|()
end_macro

begin_expr_stmt
specifier|const
block|{
return|return
name|Name
operator|.
name|isValid
argument_list|()
return|;
block|}
end_expr_stmt

begin_comment
comment|/// hasName - Whether this declarator has a name, which might be an
end_comment

begin_comment
comment|/// identifier (accessible via getIdentifier()) or some kind of
end_comment

begin_comment
comment|/// special C++ name (constructor, destructor, etc.).
end_comment

begin_expr_stmt
name|bool
name|hasName
argument_list|()
specifier|const
block|{
return|return
name|Name
operator|.
name|getKind
argument_list|()
operator|!=
name|UnqualifiedId
operator|::
name|IK_Identifier
operator|||
name|Name
operator|.
name|Identifier
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|IdentifierInfo
operator|*
name|getIdentifier
argument_list|()
specifier|const
block|{
if|if
condition|(
name|Name
operator|.
name|getKind
argument_list|()
operator|==
name|UnqualifiedId
operator|::
name|IK_Identifier
condition|)
return|return
name|Name
operator|.
name|Identifier
return|;
end_expr_stmt

begin_return
return|return
name|nullptr
return|;
end_return

begin_macro
unit|}   SourceLocation
name|getIdentifierLoc
argument_list|()
end_macro

begin_expr_stmt
specifier|const
block|{
return|return
name|Name
operator|.
name|StartLocation
return|;
block|}
end_expr_stmt

begin_comment
comment|/// \brief Set the name of this declarator to be the given identifier.
end_comment

begin_function
name|void
name|SetIdentifier
parameter_list|(
name|IdentifierInfo
modifier|*
name|Id
parameter_list|,
name|SourceLocation
name|IdLoc
parameter_list|)
block|{
name|Name
operator|.
name|setIdentifier
argument_list|(
name|Id
argument_list|,
name|IdLoc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/// AddTypeInfo - Add a chunk to this declarator. Also extend the range to
end_comment

begin_comment
comment|/// EndLoc, which should be the last token of the chunk.
end_comment

begin_function
name|void
name|AddTypeInfo
parameter_list|(
specifier|const
name|DeclaratorChunk
modifier|&
name|TI
parameter_list|,
name|ParsedAttributes
modifier|&
name|attrs
parameter_list|,
name|SourceLocation
name|EndLoc
parameter_list|)
block|{
name|DeclTypeInfo
operator|.
name|push_back
argument_list|(
name|TI
argument_list|)
expr_stmt|;
name|DeclTypeInfo
operator|.
name|back
argument_list|()
operator|.
name|getAttrListRef
argument_list|()
operator|=
name|attrs
operator|.
name|getList
argument_list|()
expr_stmt|;
name|getAttributePool
argument_list|()
operator|.
name|takeAllFrom
argument_list|(
name|attrs
operator|.
name|getPool
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|EndLoc
operator|.
name|isInvalid
argument_list|()
condition|)
name|SetRangeEnd
argument_list|(
name|EndLoc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/// \brief Add a new innermost chunk to this declarator.
end_comment

begin_function
name|void
name|AddInnermostTypeInfo
parameter_list|(
specifier|const
name|DeclaratorChunk
modifier|&
name|TI
parameter_list|)
block|{
name|DeclTypeInfo
operator|.
name|insert
argument_list|(
name|DeclTypeInfo
operator|.
name|begin
argument_list|()
argument_list|,
name|TI
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/// \brief Return the number of types applied to this declarator.
end_comment

begin_expr_stmt
name|unsigned
name|getNumTypeObjects
argument_list|()
specifier|const
block|{
return|return
name|DeclTypeInfo
operator|.
name|size
argument_list|()
return|;
block|}
end_expr_stmt

begin_comment
comment|/// Return the specified TypeInfo from this declarator.  TypeInfo #0 is
end_comment

begin_comment
comment|/// closest to the identifier.
end_comment

begin_decl_stmt
specifier|const
name|DeclaratorChunk
modifier|&
name|getTypeObject
argument_list|(
name|unsigned
name|i
argument_list|)
decl|const
block|{
name|assert
argument_list|(
name|i
operator|<
name|DeclTypeInfo
operator|.
name|size
argument_list|()
operator|&&
literal|"Invalid type chunk"
argument_list|)
expr_stmt|;
return|return
name|DeclTypeInfo
index|[
name|i
index|]
return|;
block|}
end_decl_stmt

begin_function
name|DeclaratorChunk
modifier|&
name|getTypeObject
parameter_list|(
name|unsigned
name|i
parameter_list|)
block|{
name|assert
argument_list|(
name|i
operator|<
name|DeclTypeInfo
operator|.
name|size
argument_list|()
operator|&&
literal|"Invalid type chunk"
argument_list|)
expr_stmt|;
return|return
name|DeclTypeInfo
index|[
name|i
index|]
return|;
block|}
end_function

begin_typedef
typedef|typedef
name|SmallVectorImpl
operator|<
name|DeclaratorChunk
operator|>
operator|::
name|const_iterator
name|type_object_iterator
expr_stmt|;
end_typedef

begin_typedef
typedef|typedef
name|llvm
operator|::
name|iterator_range
operator|<
name|type_object_iterator
operator|>
name|type_object_range
expr_stmt|;
end_typedef

begin_comment
comment|/// Returns the range of type objects, from the identifier outwards.
end_comment

begin_expr_stmt
name|type_object_range
name|type_objects
argument_list|()
specifier|const
block|{
return|return
name|type_object_range
argument_list|(
name|DeclTypeInfo
operator|.
name|begin
argument_list|()
argument_list|,
name|DeclTypeInfo
operator|.
name|end
argument_list|()
argument_list|)
return|;
block|}
end_expr_stmt

begin_function
name|void
name|DropFirstTypeObject
parameter_list|()
block|{
name|assert
argument_list|(
operator|!
name|DeclTypeInfo
operator|.
name|empty
argument_list|()
operator|&&
literal|"No type chunks to drop."
argument_list|)
expr_stmt|;
name|DeclTypeInfo
operator|.
name|front
argument_list|()
operator|.
name|destroy
argument_list|()
expr_stmt|;
name|DeclTypeInfo
operator|.
name|erase
argument_list|(
name|DeclTypeInfo
operator|.
name|begin
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/// Return the innermost (closest to the declarator) chunk of this
end_comment

begin_comment
comment|/// declarator that is not a parens chunk, or null if there are no
end_comment

begin_comment
comment|/// non-parens chunks.
end_comment

begin_expr_stmt
specifier|const
name|DeclaratorChunk
operator|*
name|getInnermostNonParenChunk
argument_list|()
specifier|const
block|{
for|for
control|(
name|unsigned
name|i
init|=
literal|0
init|,
name|i_end
init|=
name|DeclTypeInfo
operator|.
name|size
argument_list|()
init|;
name|i
operator|<
name|i_end
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
operator|!
name|DeclTypeInfo
index|[
name|i
index|]
operator|.
name|isParen
argument_list|()
condition|)
return|return
operator|&
name|DeclTypeInfo
index|[
name|i
index|]
return|;
block|}
end_expr_stmt

begin_return
return|return
name|nullptr
return|;
end_return

begin_comment
unit|}
comment|/// Return the outermost (furthest from the declarator) chunk of
end_comment

begin_comment
comment|/// this declarator that is not a parens chunk, or null if there are
end_comment

begin_comment
comment|/// no non-parens chunks.
end_comment

begin_expr_stmt
unit|const
name|DeclaratorChunk
operator|*
name|getOutermostNonParenChunk
argument_list|()
specifier|const
block|{
for|for
control|(
name|unsigned
name|i
init|=
name|DeclTypeInfo
operator|.
name|size
argument_list|()
init|,
name|i_end
init|=
literal|0
init|;
name|i
operator|!=
name|i_end
condition|;
operator|--
name|i
control|)
block|{
if|if
condition|(
operator|!
name|DeclTypeInfo
index|[
name|i
operator|-
literal|1
index|]
operator|.
name|isParen
argument_list|()
condition|)
return|return
operator|&
name|DeclTypeInfo
index|[
name|i
operator|-
literal|1
index|]
return|;
block|}
end_expr_stmt

begin_return
return|return
name|nullptr
return|;
end_return

begin_comment
unit|}
comment|/// isArrayOfUnknownBound - This method returns true if the declarator
end_comment

begin_comment
comment|/// is a declarator for an array of unknown bound (looking through
end_comment

begin_comment
comment|/// parentheses).
end_comment

begin_macro
unit|bool
name|isArrayOfUnknownBound
argument_list|()
end_macro

begin_expr_stmt
specifier|const
block|{
specifier|const
name|DeclaratorChunk
operator|*
name|chunk
operator|=
name|getInnermostNonParenChunk
argument_list|()
block|;
return|return
operator|(
name|chunk
operator|&&
name|chunk
operator|->
name|Kind
operator|==
name|DeclaratorChunk
operator|::
name|Array
operator|&&
operator|!
name|chunk
operator|->
name|Arr
operator|.
name|NumElts
operator|)
return|;
block|}
end_expr_stmt

begin_comment
comment|/// isFunctionDeclarator - This method returns true if the declarator
end_comment

begin_comment
comment|/// is a function declarator (looking through parentheses).
end_comment

begin_comment
comment|/// If true is returned, then the reference type parameter idx is
end_comment

begin_comment
comment|/// assigned with the index of the declaration chunk.
end_comment

begin_decl_stmt
name|bool
name|isFunctionDeclarator
argument_list|(
name|unsigned
operator|&
name|idx
argument_list|)
decl|const
block|{
for|for
control|(
name|unsigned
name|i
init|=
literal|0
init|,
name|i_end
init|=
name|DeclTypeInfo
operator|.
name|size
argument_list|()
init|;
name|i
operator|<
name|i_end
condition|;
operator|++
name|i
control|)
block|{
switch|switch
condition|(
name|DeclTypeInfo
index|[
name|i
index|]
operator|.
name|Kind
condition|)
block|{
case|case
name|DeclaratorChunk
operator|::
name|Function
case|:
name|idx
operator|=
name|i
expr_stmt|;
return|return
name|true
return|;
case|case
name|DeclaratorChunk
operator|::
name|Paren
case|:
continue|continue;
case|case
name|DeclaratorChunk
operator|::
name|Pointer
case|:
case|case
name|DeclaratorChunk
operator|::
name|Reference
case|:
case|case
name|DeclaratorChunk
operator|::
name|Array
case|:
case|case
name|DeclaratorChunk
operator|::
name|BlockPointer
case|:
case|case
name|DeclaratorChunk
operator|::
name|MemberPointer
case|:
return|return
name|false
return|;
block|}
name|llvm_unreachable
argument_list|(
literal|"Invalid type chunk"
argument_list|)
expr_stmt|;
block|}
return|return
name|false
return|;
block|}
end_decl_stmt

begin_comment
comment|/// isFunctionDeclarator - Once this declarator is fully parsed and formed,
end_comment

begin_comment
comment|/// this method returns true if the identifier is a function declarator
end_comment

begin_comment
comment|/// (looking through parentheses).
end_comment

begin_expr_stmt
name|bool
name|isFunctionDeclarator
argument_list|()
specifier|const
block|{
name|unsigned
name|index
block|;
return|return
name|isFunctionDeclarator
argument_list|(
name|index
argument_list|)
return|;
block|}
end_expr_stmt

begin_comment
comment|/// getFunctionTypeInfo - Retrieves the function type info object
end_comment

begin_comment
comment|/// (looking through parentheses).
end_comment

begin_expr_stmt
name|DeclaratorChunk
operator|::
name|FunctionTypeInfo
operator|&
name|getFunctionTypeInfo
argument_list|()
block|{
name|assert
argument_list|(
name|isFunctionDeclarator
argument_list|()
operator|&&
literal|"Not a function declarator!"
argument_list|)
block|;
name|unsigned
name|index
operator|=
literal|0
block|;
name|isFunctionDeclarator
argument_list|(
name|index
argument_list|)
block|;
return|return
name|DeclTypeInfo
index|[
name|index
index|]
operator|.
name|Fun
return|;
block|}
end_expr_stmt

begin_comment
comment|/// getFunctionTypeInfo - Retrieves the function type info object
end_comment

begin_comment
comment|/// (looking through parentheses).
end_comment

begin_expr_stmt
specifier|const
name|DeclaratorChunk
operator|::
name|FunctionTypeInfo
operator|&
name|getFunctionTypeInfo
argument_list|()
specifier|const
block|{
return|return
name|const_cast
operator|<
name|Declarator
operator|*
operator|>
operator|(
name|this
operator|)
operator|->
name|getFunctionTypeInfo
argument_list|()
return|;
block|}
end_expr_stmt

begin_comment
comment|/// \brief Determine whether the declaration that will be produced from
end_comment

begin_comment
comment|/// this declaration will be a function.
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|/// A declaration can declare a function even if the declarator itself
end_comment

begin_comment
comment|/// isn't a function declarator, if the type specifier refers to a function
end_comment

begin_comment
comment|/// type. This routine checks for both cases.
end_comment

begin_expr_stmt
name|bool
name|isDeclarationOfFunction
argument_list|()
specifier|const
expr_stmt|;
end_expr_stmt

begin_comment
comment|/// \brief Return true if this declaration appears in a context where a
end_comment

begin_comment
comment|/// function declarator would be a function declaration.
end_comment

begin_expr_stmt
name|bool
name|isFunctionDeclarationContext
argument_list|()
specifier|const
block|{
if|if
condition|(
name|getDeclSpec
argument_list|()
operator|.
name|getStorageClassSpec
argument_list|()
operator|==
name|DeclSpec
operator|::
name|SCS_typedef
condition|)
return|return
name|false
return|;
end_expr_stmt

begin_switch
switch|switch
condition|(
name|Context
condition|)
block|{
case|case
name|FileContext
case|:
case|case
name|MemberContext
case|:
case|case
name|BlockContext
case|:
return|return
name|true
return|;
case|case
name|ForContext
case|:
case|case
name|ConditionContext
case|:
case|case
name|KNRTypeListContext
case|:
case|case
name|TypeNameContext
case|:
case|case
name|AliasDeclContext
case|:
case|case
name|AliasTemplateContext
case|:
case|case
name|PrototypeContext
case|:
case|case
name|LambdaExprParameterContext
case|:
case|case
name|ObjCParameterContext
case|:
case|case
name|ObjCResultContext
case|:
case|case
name|TemplateParamContext
case|:
case|case
name|CXXNewContext
case|:
case|case
name|CXXCatchContext
case|:
case|case
name|ObjCCatchContext
case|:
case|case
name|BlockLiteralContext
case|:
case|case
name|LambdaExprContext
case|:
case|case
name|ConversionIdContext
case|:
case|case
name|TemplateTypeArgContext
case|:
case|case
name|TrailingReturnContext
case|:
return|return
name|false
return|;
block|}
end_switch

begin_expr_stmt
name|llvm_unreachable
argument_list|(
literal|"unknown context kind!"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
unit|}
comment|/// \brief Return true if a function declarator at this position would be a
end_comment

begin_comment
comment|/// function declaration.
end_comment

begin_macro
unit|bool
name|isFunctionDeclaratorAFunctionDeclaration
argument_list|()
end_macro

begin_expr_stmt
specifier|const
block|{
if|if
condition|(
operator|!
name|isFunctionDeclarationContext
argument_list|()
condition|)
return|return
name|false
return|;
end_expr_stmt

begin_for
for|for
control|(
name|unsigned
name|I
init|=
literal|0
init|,
name|N
init|=
name|getNumTypeObjects
argument_list|()
init|;
name|I
operator|!=
name|N
condition|;
operator|++
name|I
control|)
if|if
condition|(
name|getTypeObject
argument_list|(
name|I
argument_list|)
operator|.
name|Kind
operator|!=
name|DeclaratorChunk
operator|::
name|Paren
condition|)
return|return
name|false
return|;
end_for

begin_return
return|return
name|true
return|;
end_return

begin_comment
unit|}
comment|/// takeAttributes - Takes attributes from the given parsed-attributes
end_comment

begin_comment
comment|/// set and add them to this declarator.
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|/// These examples both add 3 attributes to "var":
end_comment

begin_comment
comment|///  short int var __attribute__((aligned(16),common,deprecated));
end_comment

begin_comment
comment|///  short int x, __attribute__((aligned(16)) var
end_comment

begin_comment
comment|///                                 __attribute__((common,deprecated));
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|/// Also extends the range of the declarator.
end_comment

begin_macro
unit|void
name|takeAttributes
argument_list|(
argument|ParsedAttributes&attrs
argument_list|,
argument|SourceLocation lastLoc
argument_list|)
end_macro

begin_block
block|{
name|Attrs
operator|.
name|takeAllFrom
argument_list|(
name|attrs
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|lastLoc
operator|.
name|isInvalid
argument_list|()
condition|)
name|SetRangeEnd
argument_list|(
name|lastLoc
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
specifier|const
name|AttributeList
operator|*
name|getAttributes
argument_list|()
specifier|const
block|{
return|return
name|Attrs
operator|.
name|getList
argument_list|()
return|;
block|}
end_expr_stmt

begin_function
name|AttributeList
modifier|*
name|getAttributes
parameter_list|()
block|{
return|return
name|Attrs
operator|.
name|getList
argument_list|()
return|;
block|}
end_function

begin_function
name|AttributeList
modifier|*
modifier|&
name|getAttrListRef
parameter_list|()
block|{
return|return
name|Attrs
operator|.
name|getListRef
argument_list|()
return|;
block|}
end_function

begin_comment
comment|/// hasAttributes - do we contain any attributes?
end_comment

begin_expr_stmt
name|bool
name|hasAttributes
argument_list|()
specifier|const
block|{
if|if
condition|(
name|getAttributes
argument_list|()
operator|||
name|getDeclSpec
argument_list|()
operator|.
name|hasAttributes
argument_list|()
condition|)
return|return
name|true
return|;
end_expr_stmt

begin_for
for|for
control|(
name|unsigned
name|i
init|=
literal|0
init|,
name|e
init|=
name|getNumTypeObjects
argument_list|()
init|;
name|i
operator|!=
name|e
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|getTypeObject
argument_list|(
name|i
argument_list|)
operator|.
name|getAttrs
argument_list|()
condition|)
return|return
name|true
return|;
end_for

begin_return
return|return
name|false
return|;
end_return

begin_comment
unit|}
comment|/// \brief Return a source range list of C++11 attributes associated
end_comment

begin_comment
comment|/// with the declarator.
end_comment

begin_macro
unit|void
name|getCXX11AttributeRanges
argument_list|(
argument|SmallVectorImpl<SourceRange>&Ranges
argument_list|)
end_macro

begin_block
block|{
name|AttributeList
modifier|*
name|AttrList
init|=
name|Attrs
operator|.
name|getList
argument_list|()
decl_stmt|;
while|while
condition|(
name|AttrList
condition|)
block|{
if|if
condition|(
name|AttrList
operator|->
name|isCXX11Attribute
argument_list|()
condition|)
name|Ranges
operator|.
name|push_back
argument_list|(
name|AttrList
operator|->
name|getRange
argument_list|()
argument_list|)
expr_stmt|;
name|AttrList
operator|=
name|AttrList
operator|->
name|getNext
argument_list|()
expr_stmt|;
block|}
block|}
end_block

begin_function
name|void
name|setAsmLabel
parameter_list|(
name|Expr
modifier|*
name|E
parameter_list|)
block|{
name|AsmLabel
operator|=
name|E
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|Expr
operator|*
name|getAsmLabel
argument_list|()
specifier|const
block|{
return|return
name|AsmLabel
return|;
block|}
end_expr_stmt

begin_function
name|void
name|setExtension
parameter_list|(
name|bool
name|Val
init|=
name|true
parameter_list|)
block|{
name|Extension
operator|=
name|Val
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|bool
name|getExtension
argument_list|()
specifier|const
block|{
return|return
name|Extension
return|;
block|}
end_expr_stmt

begin_function
name|void
name|setObjCIvar
parameter_list|(
name|bool
name|Val
init|=
name|true
parameter_list|)
block|{
name|ObjCIvar
operator|=
name|Val
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|bool
name|isObjCIvar
argument_list|()
specifier|const
block|{
return|return
name|ObjCIvar
return|;
block|}
end_expr_stmt

begin_function
name|void
name|setObjCWeakProperty
parameter_list|(
name|bool
name|Val
init|=
name|true
parameter_list|)
block|{
name|ObjCWeakProperty
operator|=
name|Val
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|bool
name|isObjCWeakProperty
argument_list|()
specifier|const
block|{
return|return
name|ObjCWeakProperty
return|;
block|}
end_expr_stmt

begin_function
name|void
name|setInvalidType
parameter_list|(
name|bool
name|Val
init|=
name|true
parameter_list|)
block|{
name|InvalidType
operator|=
name|Val
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|bool
name|isInvalidType
argument_list|()
specifier|const
block|{
return|return
name|InvalidType
operator|||
name|DS
operator|.
name|getTypeSpecType
argument_list|()
operator|==
name|DeclSpec
operator|::
name|TST_error
return|;
block|}
end_expr_stmt

begin_function
name|void
name|setGroupingParens
parameter_list|(
name|bool
name|flag
parameter_list|)
block|{
name|GroupingParens
operator|=
name|flag
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|bool
name|hasGroupingParens
argument_list|()
specifier|const
block|{
return|return
name|GroupingParens
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|bool
name|isFirstDeclarator
argument_list|()
specifier|const
block|{
return|return
operator|!
name|CommaLoc
operator|.
name|isValid
argument_list|()
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|SourceLocation
name|getCommaLoc
argument_list|()
specifier|const
block|{
return|return
name|CommaLoc
return|;
block|}
end_expr_stmt

begin_function
name|void
name|setCommaLoc
parameter_list|(
name|SourceLocation
name|CL
parameter_list|)
block|{
name|CommaLoc
operator|=
name|CL
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|bool
name|hasEllipsis
argument_list|()
specifier|const
block|{
return|return
name|EllipsisLoc
operator|.
name|isValid
argument_list|()
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|SourceLocation
name|getEllipsisLoc
argument_list|()
specifier|const
block|{
return|return
name|EllipsisLoc
return|;
block|}
end_expr_stmt

begin_function
name|void
name|setEllipsisLoc
parameter_list|(
name|SourceLocation
name|EL
parameter_list|)
block|{
name|EllipsisLoc
operator|=
name|EL
expr_stmt|;
block|}
end_function

begin_function
name|void
name|setFunctionDefinitionKind
parameter_list|(
name|FunctionDefinitionKind
name|Val
parameter_list|)
block|{
name|FunctionDefinition
operator|=
name|Val
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|bool
name|isFunctionDefinition
argument_list|()
specifier|const
block|{
return|return
name|getFunctionDefinitionKind
argument_list|()
operator|!=
name|FDK_Declaration
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|FunctionDefinitionKind
name|getFunctionDefinitionKind
argument_list|()
specifier|const
block|{
return|return
operator|(
name|FunctionDefinitionKind
operator|)
name|FunctionDefinition
return|;
block|}
end_expr_stmt

begin_comment
comment|/// Returns true if this declares a real member and not a friend.
end_comment

begin_function
name|bool
name|isFirstDeclarationOfMember
parameter_list|()
block|{
return|return
name|getContext
argument_list|()
operator|==
name|MemberContext
operator|&&
operator|!
name|getDeclSpec
argument_list|()
operator|.
name|isFriendSpecified
argument_list|()
return|;
block|}
end_function

begin_comment
comment|/// Returns true if this declares a static member.  This cannot be called on a
end_comment

begin_comment
comment|/// declarator outside of a MemberContext because we won't know until
end_comment

begin_comment
comment|/// redeclaration time if the decl is static.
end_comment

begin_function_decl
name|bool
name|isStaticMember
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/// Returns true if this declares a constructor or a destructor.
end_comment

begin_function_decl
name|bool
name|isCtorOrDtor
parameter_list|()
function_decl|;
end_function_decl

begin_function
name|void
name|setRedeclaration
parameter_list|(
name|bool
name|Val
parameter_list|)
block|{
name|Redeclaration
operator|=
name|Val
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|bool
name|isRedeclaration
argument_list|()
specifier|const
block|{
return|return
name|Redeclaration
return|;
block|}
end_expr_stmt

begin_comment
unit|};
comment|/// \brief This little struct is used to capture information about
end_comment

begin_comment
comment|/// structure field declarators, which is basically just a bitfield size.
end_comment

begin_struct
struct|struct
name|FieldDeclarator
block|{
name|Declarator
name|D
decl_stmt|;
name|Expr
modifier|*
name|BitfieldSize
decl_stmt|;
name|explicit
name|FieldDeclarator
argument_list|(
specifier|const
name|DeclSpec
operator|&
name|DS
argument_list|)
operator|:
name|D
argument_list|(
name|DS
argument_list|,
name|Declarator
operator|::
name|MemberContext
argument_list|)
operator|,
name|BitfieldSize
argument_list|(
argument|nullptr
argument_list|)
block|{ }
block|}
struct|;
end_struct

begin_comment
comment|/// \brief Represents a C++11 virt-specifier-seq.
end_comment

begin_decl_stmt
name|class
name|VirtSpecifiers
block|{
name|public
label|:
enum|enum
name|Specifier
block|{
name|VS_None
init|=
literal|0
block|,
name|VS_Override
init|=
literal|1
block|,
name|VS_Final
init|=
literal|2
block|,
name|VS_Sealed
init|=
literal|4
block|}
enum|;
name|VirtSpecifiers
argument_list|()
operator|:
name|Specifiers
argument_list|(
literal|0
argument_list|)
operator|,
name|LastSpecifier
argument_list|(
argument|VS_None
argument_list|)
block|{ }
name|bool
name|SetSpecifier
argument_list|(
argument|Specifier VS
argument_list|,
argument|SourceLocation Loc
argument_list|,
argument|const char *&PrevSpec
argument_list|)
expr_stmt|;
name|bool
name|isUnset
argument_list|()
specifier|const
block|{
return|return
name|Specifiers
operator|==
literal|0
return|;
block|}
name|bool
name|isOverrideSpecified
argument_list|()
specifier|const
block|{
return|return
name|Specifiers
operator|&
name|VS_Override
return|;
block|}
name|SourceLocation
name|getOverrideLoc
argument_list|()
specifier|const
block|{
return|return
name|VS_overrideLoc
return|;
block|}
name|bool
name|isFinalSpecified
argument_list|()
specifier|const
block|{
return|return
name|Specifiers
operator|&
operator|(
name|VS_Final
operator||
name|VS_Sealed
operator|)
return|;
block|}
name|bool
name|isFinalSpelledSealed
argument_list|()
specifier|const
block|{
return|return
name|Specifiers
operator|&
name|VS_Sealed
return|;
block|}
name|SourceLocation
name|getFinalLoc
argument_list|()
specifier|const
block|{
return|return
name|VS_finalLoc
return|;
block|}
name|void
name|clear
parameter_list|()
block|{
name|Specifiers
operator|=
literal|0
expr_stmt|;
block|}
specifier|static
specifier|const
name|char
modifier|*
name|getSpecifierName
parameter_list|(
name|Specifier
name|VS
parameter_list|)
function_decl|;
name|SourceLocation
name|getFirstLocation
argument_list|()
specifier|const
block|{
return|return
name|FirstLocation
return|;
block|}
name|SourceLocation
name|getLastLocation
argument_list|()
specifier|const
block|{
return|return
name|LastLocation
return|;
block|}
name|Specifier
name|getLastSpecifier
argument_list|()
specifier|const
block|{
return|return
name|LastSpecifier
return|;
block|}
name|private
label|:
name|unsigned
name|Specifiers
decl_stmt|;
name|Specifier
name|LastSpecifier
decl_stmt|;
name|SourceLocation
name|VS_overrideLoc
decl_stmt|,
name|VS_finalLoc
decl_stmt|;
name|SourceLocation
name|FirstLocation
decl_stmt|;
name|SourceLocation
name|LastLocation
decl_stmt|;
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_decl_stmt
name|enum
name|class
name|LambdaCaptureInitKind
block|{
name|NoInit
operator|,
comment|//!< [a]
name|CopyInit
operator|,
comment|//!< [a = b], [a = {b}]
name|DirectInit
operator|,
comment|//!< [a(b)]
name|ListInit
comment|//!< [a{b}]
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_comment
comment|/// \brief Represents a complete lambda introducer.
end_comment

begin_struct
struct|struct
name|LambdaIntroducer
block|{
comment|/// \brief An individual capture in a lambda introducer.
struct|struct
name|LambdaCapture
block|{
name|LambdaCaptureKind
name|Kind
decl_stmt|;
name|SourceLocation
name|Loc
decl_stmt|;
name|IdentifierInfo
modifier|*
name|Id
decl_stmt|;
name|SourceLocation
name|EllipsisLoc
decl_stmt|;
name|LambdaCaptureInitKind
name|InitKind
decl_stmt|;
name|ExprResult
name|Init
decl_stmt|;
name|ParsedType
name|InitCaptureType
decl_stmt|;
name|LambdaCapture
argument_list|(
argument|LambdaCaptureKind Kind
argument_list|,
argument|SourceLocation Loc
argument_list|,
argument|IdentifierInfo *Id
argument_list|,
argument|SourceLocation EllipsisLoc
argument_list|,
argument|LambdaCaptureInitKind InitKind
argument_list|,
argument|ExprResult Init
argument_list|,
argument|ParsedType InitCaptureType
argument_list|)
block|:
name|Kind
argument_list|(
name|Kind
argument_list|)
operator|,
name|Loc
argument_list|(
name|Loc
argument_list|)
operator|,
name|Id
argument_list|(
name|Id
argument_list|)
operator|,
name|EllipsisLoc
argument_list|(
name|EllipsisLoc
argument_list|)
operator|,
name|InitKind
argument_list|(
name|InitKind
argument_list|)
operator|,
name|Init
argument_list|(
name|Init
argument_list|)
operator|,
name|InitCaptureType
argument_list|(
argument|InitCaptureType
argument_list|)
block|{}
block|}
struct|;
name|SourceRange
name|Range
decl_stmt|;
name|SourceLocation
name|DefaultLoc
decl_stmt|;
name|LambdaCaptureDefault
name|Default
decl_stmt|;
name|SmallVector
operator|<
name|LambdaCapture
operator|,
literal|4
operator|>
name|Captures
expr_stmt|;
name|LambdaIntroducer
argument_list|()
operator|:
name|Default
argument_list|(
argument|LCD_None
argument_list|)
block|{}
comment|/// \brief Append a capture in a lambda introducer.
name|void
name|addCapture
argument_list|(
argument|LambdaCaptureKind Kind
argument_list|,
argument|SourceLocation Loc
argument_list|,
argument|IdentifierInfo* Id
argument_list|,
argument|SourceLocation EllipsisLoc
argument_list|,
argument|LambdaCaptureInitKind InitKind
argument_list|,
argument|ExprResult Init
argument_list|,
argument|ParsedType InitCaptureType
argument_list|)
block|{
name|Captures
operator|.
name|push_back
argument_list|(
name|LambdaCapture
argument_list|(
name|Kind
argument_list|,
name|Loc
argument_list|,
name|Id
argument_list|,
name|EllipsisLoc
argument_list|,
name|InitKind
argument_list|,
name|Init
argument_list|,
name|InitCaptureType
argument_list|)
argument_list|)
block|;   }
block|}
struct|;
end_struct

begin_comment
unit|}
comment|// end namespace clang
end_comment

begin_endif
endif|#
directive|endif
end_endif

end_unit

