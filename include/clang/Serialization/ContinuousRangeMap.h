begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===--- ContinuousRangeMap.h - Map with int range as key -------*- C++ -*-===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//  This file defines the ContinuousRangeMap class, which is a highly
end_comment

begin_comment
comment|//  specialized container used by serialization.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LLVM_CLANG_SERIALIZATION_CONTINUOUSRANGEMAP_H
end_ifndef

begin_define
define|#
directive|define
name|LLVM_CLANG_SERIALIZATION_CONTINUOUSRANGEMAP_H
end_define

begin_include
include|#
directive|include
file|"clang/Basic/LLVM.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/SmallVector.h"
end_include

begin_include
include|#
directive|include
file|<algorithm>
end_include

begin_include
include|#
directive|include
file|<utility>
end_include

begin_decl_stmt
name|namespace
name|clang
block|{
comment|/// \brief A map from continuous integer ranges to some value, with a very
comment|/// specialized interface.
comment|///
comment|/// CRM maps from integer ranges to values. The ranges are continuous, i.e.
comment|/// where one ends, the next one begins. So if the map contains the stops I0-3,
comment|/// the first range is from I0 to I1, the second from I1 to I2, the third from
comment|/// I2 to I3 and the last from I3 to infinity.
comment|///
comment|/// Ranges must be inserted in order. Inserting a new stop I4 into the map will
comment|/// shrink the fourth range to I3 to I4 and add the new range I4 to inf.
name|template
operator|<
name|typename
name|Int
operator|,
name|typename
name|V
operator|,
name|unsigned
name|InitialCapacity
operator|>
name|class
name|ContinuousRangeMap
block|{
name|public
operator|:
typedef|typedef
name|std
operator|::
name|pair
operator|<
name|Int
operator|,
name|V
operator|>
name|value_type
expr_stmt|;
typedef|typedef
name|value_type
modifier|&
name|reference
typedef|;
typedef|typedef
specifier|const
name|value_type
modifier|&
name|const_reference
typedef|;
typedef|typedef
name|value_type
modifier|*
name|pointer
typedef|;
typedef|typedef
specifier|const
name|value_type
modifier|*
name|const_pointer
typedef|;
name|private
label|:
typedef|typedef
name|SmallVector
operator|<
name|value_type
operator|,
name|InitialCapacity
operator|>
name|Representation
expr_stmt|;
name|Representation
name|Rep
decl_stmt|;
struct|struct
name|Compare
block|{
name|bool
name|operator
argument_list|()
operator|(
name|const_reference
name|L
operator|,
name|Int
name|R
operator|)
specifier|const
block|{
return|return
name|L
operator|.
name|first
operator|<
name|R
return|;
block|}
name|bool
name|operator
argument_list|()
operator|(
name|Int
name|L
operator|,
name|const_reference
name|R
operator|)
specifier|const
block|{
return|return
name|L
operator|<
name|R
operator|.
name|first
return|;
block|}
name|bool
name|operator
argument_list|()
operator|(
name|Int
name|L
operator|,
name|Int
name|R
operator|)
specifier|const
block|{
return|return
name|L
operator|<
name|R
return|;
block|}
name|bool
name|operator
argument_list|()
operator|(
name|const_reference
name|L
operator|,
name|const_reference
name|R
operator|)
specifier|const
block|{
return|return
name|L
operator|.
name|first
operator|<
name|R
operator|.
name|first
return|;
block|}
block|}
struct|;
name|public
label|:
name|void
name|insert
parameter_list|(
specifier|const
name|value_type
modifier|&
name|Val
parameter_list|)
block|{
if|if
condition|(
operator|!
name|Rep
operator|.
name|empty
argument_list|()
operator|&&
name|Rep
operator|.
name|back
argument_list|()
operator|==
name|Val
condition|)
return|return;
name|assert
argument_list|(
operator|(
name|Rep
operator|.
name|empty
argument_list|()
operator|||
name|Rep
operator|.
name|back
argument_list|()
operator|.
name|first
operator|<
name|Val
operator|.
name|first
operator|)
operator|&&
literal|"Must insert keys in order."
argument_list|)
expr_stmt|;
name|Rep
operator|.
name|push_back
argument_list|(
name|Val
argument_list|)
expr_stmt|;
block|}
name|void
name|insertOrReplace
parameter_list|(
specifier|const
name|value_type
modifier|&
name|Val
parameter_list|)
block|{
name|iterator
name|I
init|=
name|std
operator|::
name|lower_bound
argument_list|(
name|Rep
operator|.
name|begin
argument_list|()
argument_list|,
name|Rep
operator|.
name|end
argument_list|()
argument_list|,
name|Val
argument_list|,
name|Compare
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|I
operator|!=
name|Rep
operator|.
name|end
argument_list|()
operator|&&
name|I
operator|->
name|first
operator|==
name|Val
operator|.
name|first
condition|)
block|{
name|I
operator|->
name|second
operator|=
name|Val
operator|.
name|second
expr_stmt|;
return|return;
block|}
name|Rep
operator|.
name|insert
argument_list|(
name|I
argument_list|,
name|Val
argument_list|)
expr_stmt|;
block|}
typedef|typedef
name|typename
name|Representation
operator|::
name|iterator
name|iterator
expr_stmt|;
typedef|typedef
name|typename
name|Representation
operator|::
name|const_iterator
name|const_iterator
expr_stmt|;
name|iterator
name|begin
parameter_list|()
block|{
return|return
name|Rep
operator|.
name|begin
argument_list|()
return|;
block|}
name|iterator
name|end
parameter_list|()
block|{
return|return
name|Rep
operator|.
name|end
argument_list|()
return|;
block|}
name|const_iterator
name|begin
argument_list|()
specifier|const
block|{
return|return
name|Rep
operator|.
name|begin
argument_list|()
return|;
block|}
name|const_iterator
name|end
argument_list|()
specifier|const
block|{
return|return
name|Rep
operator|.
name|end
argument_list|()
return|;
block|}
name|iterator
name|find
parameter_list|(
name|Int
name|K
parameter_list|)
block|{
name|iterator
name|I
init|=
name|std
operator|::
name|upper_bound
argument_list|(
name|Rep
operator|.
name|begin
argument_list|()
argument_list|,
name|Rep
operator|.
name|end
argument_list|()
argument_list|,
name|K
argument_list|,
name|Compare
argument_list|()
argument_list|)
decl_stmt|;
comment|// I points to the first entry with a key> K, which is the range that
comment|// follows the one containing K.
if|if
condition|(
name|I
operator|==
name|Rep
operator|.
name|begin
argument_list|()
condition|)
return|return
name|Rep
operator|.
name|end
argument_list|()
return|;
operator|--
name|I
expr_stmt|;
return|return
name|I
return|;
block|}
name|const_iterator
name|find
argument_list|(
name|Int
name|K
argument_list|)
decl|const
block|{
return|return
name|const_cast
operator|<
name|ContinuousRangeMap
operator|*
operator|>
operator|(
name|this
operator|)
operator|->
name|find
argument_list|(
name|K
argument_list|)
return|;
block|}
name|reference
name|back
parameter_list|()
block|{
return|return
name|Rep
operator|.
name|back
argument_list|()
return|;
block|}
name|const_reference
name|back
argument_list|()
specifier|const
block|{
return|return
name|Rep
operator|.
name|back
argument_list|()
return|;
block|}
comment|/// \brief An object that helps properly build a continuous range map
comment|/// from a set of values.
name|class
name|Builder
block|{
name|ContinuousRangeMap
modifier|&
name|Self
decl_stmt|;
name|Builder
argument_list|(
argument|const Builder&
argument_list|)
name|LLVM_DELETED_FUNCTION
expr_stmt|;
name|Builder
modifier|&
name|operator
init|=
operator|(
specifier|const
name|Builder
operator|&
operator|)
name|LLVM_DELETED_FUNCTION
decl_stmt|;
name|public
label|:
name|explicit
name|Builder
argument_list|(
name|ContinuousRangeMap
operator|&
name|Self
argument_list|)
operator|:
name|Self
argument_list|(
argument|Self
argument_list|)
block|{ }
operator|~
name|Builder
argument_list|()
block|{
name|std
operator|::
name|sort
argument_list|(
name|Self
operator|.
name|Rep
operator|.
name|begin
argument_list|()
argument_list|,
name|Self
operator|.
name|Rep
operator|.
name|end
argument_list|()
argument_list|,
name|Compare
argument_list|()
argument_list|)
block|;
name|std
operator|::
name|unique
argument_list|(
name|Self
operator|.
name|Rep
operator|.
name|begin
argument_list|()
argument_list|,
name|Self
operator|.
name|Rep
operator|.
name|end
argument_list|()
argument_list|,
index|[]
operator|(
name|const_reference
name|A
operator|,
name|const_reference
name|B
operator|)
block|{
comment|// FIXME: we should not allow any duplicate keys, but there are a lot of
comment|// duplicate 0 -> 0 mappings to remove first.
name|assert
argument_list|(
operator|(
name|A
operator|==
name|B
operator|||
name|A
operator|.
name|first
operator|!=
name|B
operator|.
name|first
operator|)
operator|&&
literal|"ContinuousRangeMap::Builder given non-unique keys"
argument_list|)
block|;
return|return
name|A
operator|==
name|B
return|;
block|}
argument_list|)
block|;     }
name|void
name|insert
argument_list|(
argument|const value_type&Val
argument_list|)
block|{
name|Self
operator|.
name|Rep
operator|.
name|push_back
argument_list|(
name|Val
argument_list|)
block|;     }
block|}
empty_stmt|;
name|friend
name|class
name|Builder
decl_stmt|;
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_endif
unit|}
endif|#
directive|endif
end_endif

end_unit

