begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===-- DeclContextInternals.h - DeclContext Representation -----*- C++ -*-===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//  This file defines the data structures used in the implementation
end_comment

begin_comment
comment|//  of DeclContext.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LLVM_CLANG_AST_DECLCONTEXTINTERNALS_H
end_ifndef

begin_define
define|#
directive|define
name|LLVM_CLANG_AST_DECLCONTEXTINTERNALS_H
end_define

begin_include
include|#
directive|include
file|"clang/AST/Decl.h"
end_include

begin_include
include|#
directive|include
file|"clang/AST/DeclarationName.h"
end_include

begin_include
include|#
directive|include
file|"clang/AST/DeclCXX.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/DenseMap.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/PointerUnion.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/SmallVector.h"
end_include

begin_include
include|#
directive|include
file|<algorithm>
end_include

begin_decl_stmt
name|namespace
name|clang
block|{
name|class
name|DependentDiagnostic
decl_stmt|;
comment|/// StoredDeclsList - This is an array of decls optimized a common case of only
comment|/// containing one entry.
struct|struct
name|StoredDeclsList
block|{
comment|/// The kind of data encoded in this list.
enum|enum
name|DataKind
block|{
comment|/// \brief The data is a NamedDecl*.
name|DK_Decl
init|=
literal|0
block|,
comment|/// \brief The data is a declaration ID (an unsigned value),
comment|/// shifted left by 2 bits.
name|DK_DeclID
init|=
literal|1
block|,
comment|/// \brief The data is a pointer to a vector (of type VectorTy)
comment|/// that contains declarations.
name|DK_Decl_Vector
init|=
literal|2
block|,
comment|/// \brief The data is a pointer to a vector (of type VectorTy)
comment|/// that contains declaration ID.
name|DK_ID_Vector
init|=
literal|3
block|}
enum|;
comment|/// VectorTy - When in vector form, this is what the Data pointer points to.
typedef|typedef
name|llvm
operator|::
name|SmallVector
operator|<
name|uintptr_t
operator|,
literal|4
operator|>
name|VectorTy
expr_stmt|;
comment|/// \brief The stored data, which will be either a declaration ID, a
comment|/// pointer to a NamedDecl, or a pointer to a vector.
name|uintptr_t
name|Data
decl_stmt|;
name|public
label|:
name|StoredDeclsList
argument_list|()
operator|:
name|Data
argument_list|(
literal|0
argument_list|)
block|{}
name|StoredDeclsList
argument_list|(
specifier|const
name|StoredDeclsList
operator|&
name|RHS
argument_list|)
operator|:
name|Data
argument_list|(
argument|RHS.Data
argument_list|)
block|{
if|if
condition|(
name|VectorTy
modifier|*
name|RHSVec
init|=
name|RHS
operator|.
name|getAsVector
argument_list|()
condition|)
block|{
name|VectorTy
modifier|*
name|New
init|=
name|new
name|VectorTy
argument_list|(
operator|*
name|RHSVec
argument_list|)
decl_stmt|;
name|Data
operator|=
name|reinterpret_cast
operator|<
name|uintptr_t
operator|>
operator|(
name|New
operator|)
operator||
operator|(
name|Data
operator|&
literal|0x03
operator|)
expr_stmt|;
block|}
block|}
operator|~
name|StoredDeclsList
argument_list|()
block|{
comment|// If this is a vector-form, free the vector.
if|if
condition|(
name|VectorTy
modifier|*
name|Vector
init|=
name|getAsVector
argument_list|()
condition|)
name|delete
name|Vector
decl_stmt|;
block|}
name|StoredDeclsList
modifier|&
name|operator
init|=
operator|(
specifier|const
name|StoredDeclsList
operator|&
name|RHS
operator|)
block|{
if|if
condition|(
name|VectorTy
modifier|*
name|Vector
init|=
name|getAsVector
argument_list|()
condition|)
name|delete
name|Vector
decl_stmt|;
name|Data
operator|=
name|RHS
operator|.
name|Data
decl_stmt|;
if|if
condition|(
name|VectorTy
modifier|*
name|RHSVec
init|=
name|RHS
operator|.
name|getAsVector
argument_list|()
condition|)
block|{
name|VectorTy
modifier|*
name|New
init|=
name|new
name|VectorTy
argument_list|(
operator|*
name|RHSVec
argument_list|)
decl_stmt|;
name|Data
operator|=
name|reinterpret_cast
operator|<
name|uintptr_t
operator|>
operator|(
name|New
operator|)
operator||
operator|(
name|Data
operator|&
literal|0x03
operator|)
expr_stmt|;
block|}
return|return
operator|*
name|this
return|;
block|}
name|bool
name|isNull
argument_list|()
decl|const
block|{
return|return
operator|(
name|Data
operator|&
operator|~
literal|0x03
operator|)
operator|==
literal|0
return|;
block|}
name|NamedDecl
modifier|*
name|getAsDecl
argument_list|()
decl|const
block|{
if|if
condition|(
operator|(
name|Data
operator|&
literal|0x03
operator|)
operator|!=
name|DK_Decl
condition|)
return|return
literal|0
return|;
return|return
name|reinterpret_cast
operator|<
name|NamedDecl
operator|*
operator|>
operator|(
name|Data
operator|&
operator|~
literal|0x03
operator|)
return|;
block|}
name|VectorTy
modifier|*
name|getAsVector
argument_list|()
decl|const
block|{
if|if
condition|(
operator|(
name|Data
operator|&
literal|0x03
operator|)
operator|!=
name|DK_ID_Vector
operator|&&
operator|(
name|Data
operator|&
literal|0x03
operator|)
operator|!=
name|DK_Decl_Vector
condition|)
return|return
literal|0
return|;
return|return
name|reinterpret_cast
operator|<
name|VectorTy
operator|*
operator|>
operator|(
name|Data
operator|&
operator|~
literal|0x03
operator|)
return|;
block|}
name|void
name|setOnlyValue
argument_list|(
name|NamedDecl
operator|*
name|ND
argument_list|)
block|{
name|assert
argument_list|(
operator|!
name|getAsVector
argument_list|()
operator|&&
literal|"Not inline"
argument_list|)
expr_stmt|;
name|Data
operator|=
name|reinterpret_cast
operator|<
name|uintptr_t
operator|>
operator|(
name|ND
operator|)
expr_stmt|;
block|}
name|void
name|setFromDeclIDs
argument_list|(
specifier|const
name|llvm
operator|::
name|SmallVectorImpl
operator|<
name|unsigned
operator|>
operator|&
name|Vec
argument_list|)
block|{
if|if
condition|(
name|Vec
operator|.
name|size
argument_list|()
operator|>
literal|1
condition|)
block|{
name|VectorTy
modifier|*
name|Vector
init|=
name|getAsVector
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|Vector
condition|)
block|{
name|Vector
operator|=
name|new
name|VectorTy
expr_stmt|;
name|Data
operator|=
name|reinterpret_cast
operator|<
name|uintptr_t
operator|>
operator|(
name|Vector
operator|)
operator||
name|DK_ID_Vector
expr_stmt|;
block|}
name|Vector
operator|->
name|resize
argument_list|(
name|Vec
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|std
operator|::
name|copy
argument_list|(
name|Vec
operator|.
name|begin
argument_list|()
argument_list|,
name|Vec
operator|.
name|end
argument_list|()
argument_list|,
name|Vector
operator|->
name|begin
argument_list|()
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|VectorTy
modifier|*
name|Vector
init|=
name|getAsVector
argument_list|()
condition|)
name|delete
name|Vector
decl_stmt|;
if|if
condition|(
name|Vec
operator|.
name|empty
argument_list|()
condition|)
name|Data
operator|=
literal|0
expr_stmt|;
else|else
name|Data
operator|=
operator|(
name|Vec
index|[
literal|0
index|]
operator|<<
literal|2
operator|)
operator||
name|DK_DeclID
expr_stmt|;
block|}
comment|/// \brief Force the stored declarations list to contain actual
comment|/// declarations.
comment|///
comment|/// This routine will resolve any declaration IDs for declarations
comment|/// that may not yet have been loaded from external storage.
name|void
name|materializeDecls
argument_list|(
name|ASTContext
operator|&
name|Context
argument_list|)
struct|;
name|bool
name|hasDeclarationIDs
argument_list|()
specifier|const
block|{
name|DataKind
name|DK
operator|=
call|(
name|DataKind
call|)
argument_list|(
name|Data
operator|&
literal|0x03
argument_list|)
block|;
return|return
name|DK
operator|==
name|DK_DeclID
operator|||
name|DK
operator|==
name|DK_ID_Vector
return|;
block|}
name|void
name|remove
parameter_list|(
name|NamedDecl
modifier|*
name|D
parameter_list|)
block|{
name|assert
argument_list|(
operator|!
name|isNull
argument_list|()
operator|&&
literal|"removing from empty list"
argument_list|)
expr_stmt|;
if|if
condition|(
name|NamedDecl
modifier|*
name|Singleton
init|=
name|getAsDecl
argument_list|()
condition|)
block|{
name|assert
argument_list|(
name|Singleton
operator|==
name|D
operator|&&
literal|"list is different singleton"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|Singleton
expr_stmt|;
name|Data
operator|=
literal|0
expr_stmt|;
return|return;
block|}
name|VectorTy
modifier|&
name|Vec
init|=
operator|*
name|getAsVector
argument_list|()
decl_stmt|;
name|VectorTy
operator|::
name|iterator
name|I
operator|=
name|std
operator|::
name|find
argument_list|(
name|Vec
operator|.
name|begin
argument_list|()
argument_list|,
name|Vec
operator|.
name|end
argument_list|()
argument_list|,
name|reinterpret_cast
operator|<
name|uintptr_t
operator|>
operator|(
name|D
operator|)
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|I
operator|!=
name|Vec
operator|.
name|end
argument_list|()
operator|&&
literal|"list does not contain decl"
argument_list|)
expr_stmt|;
name|Vec
operator|.
name|erase
argument_list|(
name|I
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|std
operator|::
name|find
argument_list|(
name|Vec
operator|.
name|begin
argument_list|()
argument_list|,
name|Vec
operator|.
name|end
argument_list|()
argument_list|,
name|reinterpret_cast
operator|<
name|uintptr_t
operator|>
operator|(
name|D
operator|)
argument_list|)
operator|==
name|Vec
operator|.
name|end
argument_list|()
operator|&&
literal|"list still contains decl"
argument_list|)
expr_stmt|;
block|}
comment|/// getLookupResult - Return an array of all the decls that this list
comment|/// represents.
name|DeclContext
operator|::
name|lookup_result
name|getLookupResult
argument_list|(
argument|ASTContext&Context
argument_list|)
block|{
if|if
condition|(
name|isNull
argument_list|()
condition|)
return|return
name|DeclContext
operator|::
name|lookup_result
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
return|;
if|if
condition|(
name|hasDeclarationIDs
argument_list|()
condition|)
name|materializeDecls
argument_list|(
name|Context
argument_list|)
expr_stmt|;
comment|// If we have a single NamedDecl, return it.
if|if
condition|(
name|getAsDecl
argument_list|()
condition|)
block|{
name|assert
argument_list|(
operator|!
name|isNull
argument_list|()
operator|&&
literal|"Empty list isn't allowed"
argument_list|)
expr_stmt|;
comment|// Data is a raw pointer to a NamedDecl*, return it.
name|void
modifier|*
name|Ptr
init|=
operator|&
name|Data
decl_stmt|;
return|return
name|DeclContext
operator|::
name|lookup_result
argument_list|(
operator|(
name|NamedDecl
operator|*
operator|*
operator|)
name|Ptr
argument_list|,
operator|(
name|NamedDecl
operator|*
operator|*
operator|)
name|Ptr
operator|+
literal|1
argument_list|)
return|;
block|}
name|assert
argument_list|(
name|getAsVector
argument_list|()
operator|&&
literal|"Must have a vector at this point"
argument_list|)
expr_stmt|;
name|VectorTy
modifier|&
name|Vector
init|=
operator|*
name|getAsVector
argument_list|()
decl_stmt|;
comment|// Otherwise, we have a range result.
return|return
name|DeclContext
operator|::
name|lookup_result
argument_list|(
operator|(
name|NamedDecl
operator|*
operator|*
operator|)
operator|&
name|Vector
index|[
literal|0
index|]
argument_list|,
operator|(
name|NamedDecl
operator|*
operator|*
operator|)
operator|&
name|Vector
index|[
literal|0
index|]
operator|+
name|Vector
operator|.
name|size
argument_list|()
argument_list|)
return|;
block|}
end_decl_stmt

begin_comment
comment|/// HandleRedeclaration - If this is a redeclaration of an existing decl,
end_comment

begin_comment
comment|/// replace the old one with D and return true.  Otherwise return false.
end_comment

begin_function
name|bool
name|HandleRedeclaration
parameter_list|(
name|ASTContext
modifier|&
name|Context
parameter_list|,
name|NamedDecl
modifier|*
name|D
parameter_list|)
block|{
if|if
condition|(
name|hasDeclarationIDs
argument_list|()
condition|)
name|materializeDecls
argument_list|(
name|Context
argument_list|)
expr_stmt|;
comment|// Most decls only have one entry in their list, special case it.
if|if
condition|(
name|NamedDecl
modifier|*
name|OldD
init|=
name|getAsDecl
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
name|D
operator|->
name|declarationReplaces
argument_list|(
name|OldD
argument_list|)
condition|)
return|return
name|false
return|;
name|setOnlyValue
argument_list|(
name|D
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
comment|// Determine if this declaration is actually a redeclaration.
name|VectorTy
modifier|&
name|Vec
init|=
operator|*
name|getAsVector
argument_list|()
decl_stmt|;
for|for
control|(
name|VectorTy
operator|::
name|iterator
name|OD
operator|=
name|Vec
operator|.
name|begin
argument_list|()
operator|,
name|ODEnd
operator|=
name|Vec
operator|.
name|end
argument_list|()
init|;
name|OD
operator|!=
name|ODEnd
condition|;
operator|++
name|OD
control|)
block|{
name|NamedDecl
modifier|*
name|OldD
init|=
name|reinterpret_cast
operator|<
name|NamedDecl
operator|*
operator|>
operator|(
operator|*
name|OD
operator|)
decl_stmt|;
if|if
condition|(
name|D
operator|->
name|declarationReplaces
argument_list|(
name|OldD
argument_list|)
condition|)
block|{
operator|*
name|OD
operator|=
name|reinterpret_cast
operator|<
name|uintptr_t
operator|>
operator|(
name|D
operator|)
expr_stmt|;
return|return
name|true
return|;
block|}
block|}
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/// AddSubsequentDecl - This is called on the second and later decl when it is
end_comment

begin_comment
comment|/// not a redeclaration to merge it into the appropriate place in our list.
end_comment

begin_comment
comment|///
end_comment

begin_function
name|void
name|AddSubsequentDecl
parameter_list|(
name|NamedDecl
modifier|*
name|D
parameter_list|)
block|{
name|assert
argument_list|(
operator|!
name|hasDeclarationIDs
argument_list|()
operator|&&
literal|"Must materialize before adding decls"
argument_list|)
expr_stmt|;
comment|// If this is the second decl added to the list, convert this to vector
comment|// form.
if|if
condition|(
name|NamedDecl
modifier|*
name|OldD
init|=
name|getAsDecl
argument_list|()
condition|)
block|{
name|VectorTy
modifier|*
name|VT
init|=
name|new
name|VectorTy
argument_list|()
decl_stmt|;
name|VT
operator|->
name|push_back
argument_list|(
name|reinterpret_cast
operator|<
name|uintptr_t
operator|>
operator|(
name|OldD
operator|)
argument_list|)
expr_stmt|;
name|Data
operator|=
name|reinterpret_cast
operator|<
name|uintptr_t
operator|>
operator|(
name|VT
operator|)
operator||
name|DK_Decl_Vector
expr_stmt|;
block|}
name|VectorTy
modifier|&
name|Vec
init|=
operator|*
name|getAsVector
argument_list|()
decl_stmt|;
comment|// Using directives end up in a special entry which contains only
comment|// other using directives, so all this logic is wasted for them.
comment|// But avoiding the logic wastes time in the far-more-common case
comment|// that we're *not* adding a new using directive.
comment|// Tag declarations always go at the end of the list so that an
comment|// iterator which points at the first tag will start a span of
comment|// decls that only contains tags.
if|if
condition|(
name|D
operator|->
name|hasTagIdentifierNamespace
argument_list|()
condition|)
name|Vec
operator|.
name|push_back
argument_list|(
name|reinterpret_cast
operator|<
name|uintptr_t
operator|>
operator|(
name|D
operator|)
argument_list|)
expr_stmt|;
comment|// Resolved using declarations go at the front of the list so that
comment|// they won't show up in other lookup results.  Unresolved using
comment|// declarations (which are always in IDNS_Using | IDNS_Ordinary)
comment|// follow that so that the using declarations will be contiguous.
elseif|else
if|if
condition|(
name|D
operator|->
name|getIdentifierNamespace
argument_list|()
operator|&
name|Decl
operator|::
name|IDNS_Using
condition|)
block|{
name|VectorTy
operator|::
name|iterator
name|I
operator|=
name|Vec
operator|.
name|begin
argument_list|()
expr_stmt|;
if|if
condition|(
name|D
operator|->
name|getIdentifierNamespace
argument_list|()
operator|!=
name|Decl
operator|::
name|IDNS_Using
condition|)
block|{
while|while
condition|(
name|I
operator|!=
name|Vec
operator|.
name|end
argument_list|()
operator|&&
name|reinterpret_cast
operator|<
name|NamedDecl
operator|*
operator|>
operator|(
operator|*
name|I
operator|)
operator|->
name|getIdentifierNamespace
argument_list|()
operator|==
name|Decl
operator|::
name|IDNS_Using
condition|)
operator|++
name|I
expr_stmt|;
block|}
name|Vec
operator|.
name|insert
argument_list|(
name|I
argument_list|,
name|reinterpret_cast
operator|<
name|uintptr_t
operator|>
operator|(
name|D
operator|)
argument_list|)
expr_stmt|;
comment|// All other declarations go at the end of the list, but before any
comment|// tag declarations.  But we can be clever about tag declarations
comment|// because there can only ever be one in a scope.
block|}
elseif|else
if|if
condition|(
name|reinterpret_cast
operator|<
name|NamedDecl
operator|*
operator|>
operator|(
name|Vec
operator|.
name|back
argument_list|()
operator|)
operator|->
name|hasTagIdentifierNamespace
argument_list|()
condition|)
block|{
name|uintptr_t
name|TagD
init|=
name|Vec
operator|.
name|back
argument_list|()
decl_stmt|;
name|Vec
operator|.
name|back
argument_list|()
operator|=
name|reinterpret_cast
operator|<
name|uintptr_t
operator|>
operator|(
name|D
operator|)
expr_stmt|;
name|Vec
operator|.
name|push_back
argument_list|(
name|TagD
argument_list|)
expr_stmt|;
block|}
else|else
name|Vec
operator|.
name|push_back
argument_list|(
name|reinterpret_cast
operator|<
name|uintptr_t
operator|>
operator|(
name|D
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
unit|};
name|class
name|StoredDeclsMap
range|:
name|public
name|llvm
operator|::
name|DenseMap
operator|<
name|DeclarationName
decl_stmt|,
name|StoredDeclsList
decl|>
block|{
name|public
label|:
specifier|static
name|void
name|DestroyAll
parameter_list|(
name|StoredDeclsMap
modifier|*
name|Map
parameter_list|,
name|bool
name|Dependent
parameter_list|)
function_decl|;
name|private
label|:
name|friend
name|class
name|ASTContext
decl_stmt|;
comment|// walks the chain deleting these
name|friend
name|class
name|DeclContext
decl_stmt|;
name|llvm
operator|::
name|PointerIntPair
operator|<
name|StoredDeclsMap
operator|*
operator|,
literal|1
operator|>
name|Previous
expr_stmt|;
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_decl_stmt
name|class
name|DependentStoredDeclsMap
range|:
name|public
name|StoredDeclsMap
block|{
name|public
operator|:
name|DependentStoredDeclsMap
argument_list|()
operator|:
name|FirstDiagnostic
argument_list|(
literal|0
argument_list|)
block|{}
name|private
operator|:
name|friend
name|class
name|DependentDiagnostic
block|;
name|friend
name|class
name|DeclContext
block|;
comment|// iterates over diagnostics
name|DependentDiagnostic
operator|*
name|FirstDiagnostic
block|; }
decl_stmt|;
end_decl_stmt

begin_comment
unit|}
comment|// end namespace clang
end_comment

begin_endif
endif|#
directive|endif
end_endif

end_unit

