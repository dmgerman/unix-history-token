begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===--- VTableBuilder.h - C++ vtable layout builder --------------*- C++ -*-=//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This contains code dealing with generation of the layout of virtual tables.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LLVM_CLANG_AST_VTABLEBUILDER_H
end_ifndef

begin_define
define|#
directive|define
name|LLVM_CLANG_AST_VTABLEBUILDER_H
end_define

begin_include
include|#
directive|include
file|"clang/AST/BaseSubobject.h"
end_include

begin_include
include|#
directive|include
file|"clang/AST/CXXInheritance.h"
end_include

begin_include
include|#
directive|include
file|"clang/AST/GlobalDecl.h"
end_include

begin_include
include|#
directive|include
file|"clang/AST/RecordLayout.h"
end_include

begin_include
include|#
directive|include
file|"clang/Basic/ABI.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/SetVector.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/DenseSet.h"
end_include

begin_include
include|#
directive|include
file|<utility>
end_include

begin_decl_stmt
name|namespace
name|clang
block|{
name|class
name|CXXRecordDecl
decl_stmt|;
comment|/// \brief Represents a single component in a vtable.
name|class
name|VTableComponent
block|{
name|public
label|:
enum|enum
name|Kind
block|{
name|CK_VCallOffset
block|,
name|CK_VBaseOffset
block|,
name|CK_OffsetToTop
block|,
name|CK_RTTI
block|,
name|CK_FunctionPointer
block|,
comment|/// \brief A pointer to the complete destructor.
name|CK_CompleteDtorPointer
block|,
comment|/// \brief A pointer to the deleting destructor.
name|CK_DeletingDtorPointer
block|,
comment|/// \brief An entry that is never used.
comment|///
comment|/// In some cases, a vtable function pointer will end up never being
comment|/// called. Such vtable function pointers are represented as a
comment|/// CK_UnusedFunctionPointer.
name|CK_UnusedFunctionPointer
block|}
enum|;
name|VTableComponent
argument_list|()
block|{ }
specifier|static
name|VTableComponent
name|MakeVCallOffset
parameter_list|(
name|CharUnits
name|Offset
parameter_list|)
block|{
return|return
name|VTableComponent
argument_list|(
name|CK_VCallOffset
argument_list|,
name|Offset
argument_list|)
return|;
block|}
specifier|static
name|VTableComponent
name|MakeVBaseOffset
parameter_list|(
name|CharUnits
name|Offset
parameter_list|)
block|{
return|return
name|VTableComponent
argument_list|(
name|CK_VBaseOffset
argument_list|,
name|Offset
argument_list|)
return|;
block|}
specifier|static
name|VTableComponent
name|MakeOffsetToTop
parameter_list|(
name|CharUnits
name|Offset
parameter_list|)
block|{
return|return
name|VTableComponent
argument_list|(
name|CK_OffsetToTop
argument_list|,
name|Offset
argument_list|)
return|;
block|}
specifier|static
name|VTableComponent
name|MakeRTTI
parameter_list|(
specifier|const
name|CXXRecordDecl
modifier|*
name|RD
parameter_list|)
block|{
return|return
name|VTableComponent
argument_list|(
name|CK_RTTI
argument_list|,
name|reinterpret_cast
operator|<
name|uintptr_t
operator|>
operator|(
name|RD
operator|)
argument_list|)
return|;
block|}
specifier|static
name|VTableComponent
name|MakeFunction
parameter_list|(
specifier|const
name|CXXMethodDecl
modifier|*
name|MD
parameter_list|)
block|{
name|assert
argument_list|(
operator|!
name|isa
operator|<
name|CXXDestructorDecl
operator|>
operator|(
name|MD
operator|)
operator|&&
literal|"Don't use MakeFunction with destructors!"
argument_list|)
expr_stmt|;
return|return
name|VTableComponent
argument_list|(
name|CK_FunctionPointer
argument_list|,
name|reinterpret_cast
operator|<
name|uintptr_t
operator|>
operator|(
name|MD
operator|)
argument_list|)
return|;
block|}
specifier|static
name|VTableComponent
name|MakeCompleteDtor
parameter_list|(
specifier|const
name|CXXDestructorDecl
modifier|*
name|DD
parameter_list|)
block|{
return|return
name|VTableComponent
argument_list|(
name|CK_CompleteDtorPointer
argument_list|,
name|reinterpret_cast
operator|<
name|uintptr_t
operator|>
operator|(
name|DD
operator|)
argument_list|)
return|;
block|}
specifier|static
name|VTableComponent
name|MakeDeletingDtor
parameter_list|(
specifier|const
name|CXXDestructorDecl
modifier|*
name|DD
parameter_list|)
block|{
return|return
name|VTableComponent
argument_list|(
name|CK_DeletingDtorPointer
argument_list|,
name|reinterpret_cast
operator|<
name|uintptr_t
operator|>
operator|(
name|DD
operator|)
argument_list|)
return|;
block|}
specifier|static
name|VTableComponent
name|MakeUnusedFunction
parameter_list|(
specifier|const
name|CXXMethodDecl
modifier|*
name|MD
parameter_list|)
block|{
name|assert
argument_list|(
operator|!
name|isa
operator|<
name|CXXDestructorDecl
operator|>
operator|(
name|MD
operator|)
operator|&&
literal|"Don't use MakeUnusedFunction with destructors!"
argument_list|)
expr_stmt|;
return|return
name|VTableComponent
argument_list|(
name|CK_UnusedFunctionPointer
argument_list|,
name|reinterpret_cast
operator|<
name|uintptr_t
operator|>
operator|(
name|MD
operator|)
argument_list|)
return|;
block|}
specifier|static
name|VTableComponent
name|getFromOpaqueInteger
parameter_list|(
name|uint64_t
name|I
parameter_list|)
block|{
return|return
name|VTableComponent
argument_list|(
name|I
argument_list|)
return|;
block|}
comment|/// \brief Get the kind of this vtable component.
name|Kind
name|getKind
argument_list|()
specifier|const
block|{
return|return
call|(
name|Kind
call|)
argument_list|(
name|Value
operator|&
literal|0x7
argument_list|)
return|;
block|}
name|CharUnits
name|getVCallOffset
argument_list|()
specifier|const
block|{
name|assert
argument_list|(
name|getKind
argument_list|()
operator|==
name|CK_VCallOffset
operator|&&
literal|"Invalid component kind!"
argument_list|)
block|;
return|return
name|getOffset
argument_list|()
return|;
block|}
name|CharUnits
name|getVBaseOffset
argument_list|()
specifier|const
block|{
name|assert
argument_list|(
name|getKind
argument_list|()
operator|==
name|CK_VBaseOffset
operator|&&
literal|"Invalid component kind!"
argument_list|)
block|;
return|return
name|getOffset
argument_list|()
return|;
block|}
name|CharUnits
name|getOffsetToTop
argument_list|()
specifier|const
block|{
name|assert
argument_list|(
name|getKind
argument_list|()
operator|==
name|CK_OffsetToTop
operator|&&
literal|"Invalid component kind!"
argument_list|)
block|;
return|return
name|getOffset
argument_list|()
return|;
block|}
specifier|const
name|CXXRecordDecl
operator|*
name|getRTTIDecl
argument_list|()
specifier|const
block|{
name|assert
argument_list|(
name|getKind
argument_list|()
operator|==
name|CK_RTTI
operator|&&
literal|"Invalid component kind!"
argument_list|)
block|;
return|return
name|reinterpret_cast
operator|<
name|CXXRecordDecl
operator|*
operator|>
operator|(
name|getPointer
argument_list|()
operator|)
return|;
block|}
specifier|const
name|CXXMethodDecl
operator|*
name|getFunctionDecl
argument_list|()
specifier|const
block|{
name|assert
argument_list|(
name|getKind
argument_list|()
operator|==
name|CK_FunctionPointer
argument_list|)
block|;
return|return
name|reinterpret_cast
operator|<
name|CXXMethodDecl
operator|*
operator|>
operator|(
name|getPointer
argument_list|()
operator|)
return|;
block|}
specifier|const
name|CXXDestructorDecl
operator|*
name|getDestructorDecl
argument_list|()
specifier|const
block|{
name|assert
argument_list|(
operator|(
name|getKind
argument_list|()
operator|==
name|CK_CompleteDtorPointer
operator|||
name|getKind
argument_list|()
operator|==
name|CK_DeletingDtorPointer
operator|)
operator|&&
literal|"Invalid component kind!"
argument_list|)
block|;
return|return
name|reinterpret_cast
operator|<
name|CXXDestructorDecl
operator|*
operator|>
operator|(
name|getPointer
argument_list|()
operator|)
return|;
block|}
specifier|const
name|CXXMethodDecl
operator|*
name|getUnusedFunctionDecl
argument_list|()
specifier|const
block|{
name|assert
argument_list|(
name|getKind
argument_list|()
operator|==
name|CK_UnusedFunctionPointer
argument_list|)
block|;
return|return
name|reinterpret_cast
operator|<
name|CXXMethodDecl
operator|*
operator|>
operator|(
name|getPointer
argument_list|()
operator|)
return|;
block|}
name|private
label|:
name|VTableComponent
argument_list|(
argument|Kind ComponentKind
argument_list|,
argument|CharUnits Offset
argument_list|)
block|{
name|assert
argument_list|(
operator|(
name|ComponentKind
operator|==
name|CK_VCallOffset
operator|||
name|ComponentKind
operator|==
name|CK_VBaseOffset
operator|||
name|ComponentKind
operator|==
name|CK_OffsetToTop
operator|)
operator|&&
literal|"Invalid component kind!"
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|Offset
operator|.
name|getQuantity
argument_list|()
operator|<
operator|(
literal|1LL
operator|<<
literal|56
operator|)
operator|&&
literal|"Offset is too big!"
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|Offset
operator|.
name|getQuantity
argument_list|()
operator|>=
operator|-
operator|(
literal|1LL
operator|<<
literal|56
operator|)
operator|&&
literal|"Offset is too small!"
argument_list|)
expr_stmt|;
name|Value
operator|=
operator|(
name|uint64_t
argument_list|(
name|Offset
operator|.
name|getQuantity
argument_list|()
argument_list|)
operator|<<
literal|3
operator|)
operator||
name|ComponentKind
expr_stmt|;
block|}
name|VTableComponent
argument_list|(
argument|Kind ComponentKind
argument_list|,
argument|uintptr_t Ptr
argument_list|)
block|{
name|assert
argument_list|(
operator|(
name|ComponentKind
operator|==
name|CK_RTTI
operator|||
name|ComponentKind
operator|==
name|CK_FunctionPointer
operator|||
name|ComponentKind
operator|==
name|CK_CompleteDtorPointer
operator|||
name|ComponentKind
operator|==
name|CK_DeletingDtorPointer
operator|||
name|ComponentKind
operator|==
name|CK_UnusedFunctionPointer
operator|)
operator|&&
literal|"Invalid component kind!"
argument_list|)
expr_stmt|;
name|assert
argument_list|(
operator|(
name|Ptr
operator|&
literal|7
operator|)
operator|==
literal|0
operator|&&
literal|"Pointer not sufficiently aligned!"
argument_list|)
expr_stmt|;
name|Value
operator|=
name|Ptr
operator||
name|ComponentKind
expr_stmt|;
block|}
name|CharUnits
name|getOffset
argument_list|()
specifier|const
block|{
name|assert
argument_list|(
operator|(
name|getKind
argument_list|()
operator|==
name|CK_VCallOffset
operator|||
name|getKind
argument_list|()
operator|==
name|CK_VBaseOffset
operator|||
name|getKind
argument_list|()
operator|==
name|CK_OffsetToTop
operator|)
operator|&&
literal|"Invalid component kind!"
argument_list|)
block|;
return|return
name|CharUnits
operator|::
name|fromQuantity
argument_list|(
name|Value
operator|>>
literal|3
argument_list|)
return|;
block|}
name|uintptr_t
name|getPointer
argument_list|()
specifier|const
block|{
name|assert
argument_list|(
operator|(
name|getKind
argument_list|()
operator|==
name|CK_RTTI
operator|||
name|getKind
argument_list|()
operator|==
name|CK_FunctionPointer
operator|||
name|getKind
argument_list|()
operator|==
name|CK_CompleteDtorPointer
operator|||
name|getKind
argument_list|()
operator|==
name|CK_DeletingDtorPointer
operator|||
name|getKind
argument_list|()
operator|==
name|CK_UnusedFunctionPointer
operator|)
operator|&&
literal|"Invalid component kind!"
argument_list|)
block|;
return|return
name|static_cast
operator|<
name|uintptr_t
operator|>
operator|(
name|Value
operator|&
operator|~
literal|7ULL
operator|)
return|;
block|}
name|explicit
name|VTableComponent
argument_list|(
argument|uint64_t Value
argument_list|)
block|:
name|Value
argument_list|(
argument|Value
argument_list|)
block|{ }
comment|/// The kind is stored in the lower 3 bits of the value. For offsets, we
comment|/// make use of the facts that classes can't be larger than 2^55 bytes,
comment|/// so we store the offset in the lower part of the 61 bits that remain.
comment|/// (The reason that we're not simply using a PointerIntPair here is that we
comment|/// need the offsets to be 64-bit, even when on a 32-bit machine).
name|int64_t
name|Value
decl_stmt|;
block|}
empty_stmt|;
name|class
name|VTableLayout
block|{
name|public
label|:
typedef|typedef
name|std
operator|::
name|pair
operator|<
name|uint64_t
operator|,
name|ThunkInfo
operator|>
name|VTableThunkTy
expr_stmt|;
typedef|typedef
specifier|const
name|VTableComponent
modifier|*
name|vtable_component_iterator
typedef|;
typedef|typedef
specifier|const
name|VTableThunkTy
modifier|*
name|vtable_thunk_iterator
typedef|;
typedef|typedef
name|llvm
operator|::
name|DenseMap
operator|<
name|BaseSubobject
operator|,
name|uint64_t
operator|>
name|AddressPointsMapTy
expr_stmt|;
name|private
label|:
name|uint64_t
name|NumVTableComponents
decl_stmt|;
name|llvm
operator|::
name|OwningArrayPtr
operator|<
name|VTableComponent
operator|>
name|VTableComponents
expr_stmt|;
comment|/// \brief Contains thunks needed by vtables, sorted by indices.
name|uint64_t
name|NumVTableThunks
decl_stmt|;
name|llvm
operator|::
name|OwningArrayPtr
operator|<
name|VTableThunkTy
operator|>
name|VTableThunks
expr_stmt|;
comment|/// \brief Address points for all vtables.
name|AddressPointsMapTy
name|AddressPoints
decl_stmt|;
name|bool
name|IsMicrosoftABI
decl_stmt|;
name|public
label|:
name|VTableLayout
argument_list|(
argument|uint64_t NumVTableComponents
argument_list|,
argument|const VTableComponent *VTableComponents
argument_list|,
argument|uint64_t NumVTableThunks
argument_list|,
argument|const VTableThunkTy *VTableThunks
argument_list|,
argument|const AddressPointsMapTy&AddressPoints
argument_list|,
argument|bool IsMicrosoftABI
argument_list|)
empty_stmt|;
operator|~
name|VTableLayout
argument_list|()
expr_stmt|;
name|uint64_t
name|getNumVTableComponents
argument_list|()
specifier|const
block|{
return|return
name|NumVTableComponents
return|;
block|}
name|vtable_component_iterator
name|vtable_component_begin
argument_list|()
specifier|const
block|{
return|return
name|VTableComponents
operator|.
name|get
argument_list|()
return|;
block|}
name|vtable_component_iterator
name|vtable_component_end
argument_list|()
specifier|const
block|{
return|return
name|VTableComponents
operator|.
name|get
argument_list|()
operator|+
name|NumVTableComponents
return|;
block|}
name|uint64_t
name|getNumVTableThunks
argument_list|()
specifier|const
block|{
return|return
name|NumVTableThunks
return|;
block|}
name|vtable_thunk_iterator
name|vtable_thunk_begin
argument_list|()
specifier|const
block|{
return|return
name|VTableThunks
operator|.
name|get
argument_list|()
return|;
block|}
name|vtable_thunk_iterator
name|vtable_thunk_end
argument_list|()
specifier|const
block|{
return|return
name|VTableThunks
operator|.
name|get
argument_list|()
operator|+
name|NumVTableThunks
return|;
block|}
name|uint64_t
name|getAddressPoint
argument_list|(
name|BaseSubobject
name|Base
argument_list|)
decl|const
block|{
name|assert
argument_list|(
name|AddressPoints
operator|.
name|count
argument_list|(
name|Base
argument_list|)
operator|&&
literal|"Did not find address point!"
argument_list|)
expr_stmt|;
name|uint64_t
name|AddressPoint
init|=
name|AddressPoints
operator|.
name|lookup
argument_list|(
name|Base
argument_list|)
decl_stmt|;
name|assert
argument_list|(
name|AddressPoint
operator|!=
literal|0
operator|||
name|IsMicrosoftABI
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|IsMicrosoftABI
expr_stmt|;
return|return
name|AddressPoint
return|;
block|}
specifier|const
name|AddressPointsMapTy
operator|&
name|getAddressPoints
argument_list|()
specifier|const
block|{
return|return
name|AddressPoints
return|;
block|}
block|}
empty_stmt|;
name|class
name|VTableContextBase
block|{
name|public
label|:
typedef|typedef
name|SmallVector
operator|<
name|ThunkInfo
operator|,
literal|1
operator|>
name|ThunkInfoVectorTy
expr_stmt|;
name|protected
label|:
typedef|typedef
name|llvm
operator|::
name|DenseMap
operator|<
specifier|const
name|CXXMethodDecl
operator|*
operator|,
name|ThunkInfoVectorTy
operator|>
name|ThunksMapTy
expr_stmt|;
comment|/// \brief Contains all thunks that a given method decl will need.
name|ThunksMapTy
name|Thunks
decl_stmt|;
comment|/// Compute and store all vtable related information (vtable layout, vbase
comment|/// offset offsets, thunks etc) for the given record decl.
name|virtual
name|void
name|computeVTableRelatedInformation
parameter_list|(
specifier|const
name|CXXRecordDecl
modifier|*
name|RD
parameter_list|)
init|=
literal|0
function_decl|;
name|virtual
operator|~
name|VTableContextBase
argument_list|()
block|{}
name|public
operator|:
name|virtual
specifier|const
name|ThunkInfoVectorTy
operator|*
name|getThunkInfo
argument_list|(
argument|GlobalDecl GD
argument_list|)
block|{
specifier|const
name|CXXMethodDecl
operator|*
name|MD
operator|=
name|cast
operator|<
name|CXXMethodDecl
operator|>
operator|(
name|GD
operator|.
name|getDecl
argument_list|()
operator|->
name|getCanonicalDecl
argument_list|()
operator|)
block|;
name|computeVTableRelatedInformation
argument_list|(
name|MD
operator|->
name|getParent
argument_list|()
argument_list|)
block|;
comment|// This assumes that all the destructors present in the vtable
comment|// use exactly the same set of thunks.
name|ThunksMapTy
operator|::
name|const_iterator
name|I
operator|=
name|Thunks
operator|.
name|find
argument_list|(
name|MD
argument_list|)
block|;
if|if
condition|(
name|I
operator|==
name|Thunks
operator|.
name|end
argument_list|()
condition|)
block|{
comment|// We did not find a thunk for this method.
return|return
literal|0
return|;
block|}
return|return
operator|&
name|I
operator|->
name|second
return|;
block|}
block|}
empty_stmt|;
name|class
name|ItaniumVTableContext
range|:
name|public
name|VTableContextBase
block|{
name|private
operator|:
name|bool
name|IsMicrosoftABI
block|;
comment|/// \brief Contains the index (relative to the vtable address point)
comment|/// where the function pointer for a virtual function is stored.
typedef|typedef
name|llvm
operator|::
name|DenseMap
operator|<
name|GlobalDecl
operator|,
name|int64_t
operator|>
name|MethodVTableIndicesTy
expr_stmt|;
name|MethodVTableIndicesTy
name|MethodVTableIndices
decl_stmt|;
typedef|typedef
name|llvm
operator|::
name|DenseMap
operator|<
specifier|const
name|CXXRecordDecl
operator|*
operator|,
specifier|const
name|VTableLayout
operator|*
operator|>
name|VTableLayoutMapTy
expr_stmt|;
name|VTableLayoutMapTy
name|VTableLayouts
decl_stmt|;
typedef|typedef
name|std
operator|::
name|pair
operator|<
specifier|const
name|CXXRecordDecl
operator|*
operator|,
specifier|const
name|CXXRecordDecl
operator|*
operator|>
name|ClassPairTy
expr_stmt|;
comment|/// \brief vtable offsets for offsets of virtual bases of a class.
comment|///
comment|/// Contains the vtable offset (relative to the address point) in chars
comment|/// where the offsets for virtual bases of a class are stored.
typedef|typedef
name|llvm
operator|::
name|DenseMap
operator|<
name|ClassPairTy
operator|,
name|CharUnits
operator|>
name|VirtualBaseClassOffsetOffsetsMapTy
expr_stmt|;
name|VirtualBaseClassOffsetOffsetsMapTy
name|VirtualBaseClassOffsetOffsets
decl_stmt|;
name|void
name|computeVTableRelatedInformation
parameter_list|(
specifier|const
name|CXXRecordDecl
modifier|*
name|RD
parameter_list|)
function_decl|;
name|public
label|:
name|ItaniumVTableContext
argument_list|(
name|ASTContext
operator|&
name|Context
argument_list|)
expr_stmt|;
operator|~
name|ItaniumVTableContext
argument_list|()
expr_stmt|;
specifier|const
name|VTableLayout
modifier|&
name|getVTableLayout
parameter_list|(
specifier|const
name|CXXRecordDecl
modifier|*
name|RD
parameter_list|)
block|{
name|computeVTableRelatedInformation
argument_list|(
name|RD
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|VTableLayouts
operator|.
name|count
argument_list|(
name|RD
argument_list|)
operator|&&
literal|"No layout for this record decl!"
argument_list|)
expr_stmt|;
return|return
operator|*
name|VTableLayouts
index|[
name|RD
index|]
return|;
block|}
name|VTableLayout
modifier|*
name|createConstructionVTableLayout
parameter_list|(
specifier|const
name|CXXRecordDecl
modifier|*
name|MostDerivedClass
parameter_list|,
name|CharUnits
name|MostDerivedClassOffset
parameter_list|,
name|bool
name|MostDerivedClassIsVirtual
parameter_list|,
specifier|const
name|CXXRecordDecl
modifier|*
name|LayoutClass
parameter_list|)
function_decl|;
comment|/// \brief Locate a virtual function in the vtable.
comment|///
comment|/// Return the index (relative to the vtable address point) where the
comment|/// function pointer for the given virtual function is stored.
name|uint64_t
name|getMethodVTableIndex
parameter_list|(
name|GlobalDecl
name|GD
parameter_list|)
function_decl|;
comment|/// Return the offset in chars (relative to the vtable address point) where
comment|/// the offset of the virtual base that contains the given base is stored,
comment|/// otherwise, if no virtual base contains the given class, return 0.
comment|///
comment|/// Base must be a virtual base class or an unambiguous base.
name|CharUnits
name|getVirtualBaseOffsetOffset
parameter_list|(
specifier|const
name|CXXRecordDecl
modifier|*
name|RD
parameter_list|,
specifier|const
name|CXXRecordDecl
modifier|*
name|VBase
parameter_list|)
function_decl|;
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_struct
struct|struct
name|VFPtrInfo
block|{
typedef|typedef
name|SmallVector
operator|<
specifier|const
name|CXXRecordDecl
operator|*
operator|,
literal|1
operator|>
name|BasePath
expr_stmt|;
comment|// Don't pass the PathToMangle as it should be calculated later.
name|VFPtrInfo
argument_list|(
argument|CharUnits VFPtrOffset
argument_list|,
argument|const BasePath&PathToBaseWithVFPtr
argument_list|)
block|:
name|VBTableIndex
argument_list|(
literal|0
argument_list|)
operator|,
name|LastVBase
argument_list|(
literal|0
argument_list|)
operator|,
name|VFPtrOffset
argument_list|(
name|VFPtrOffset
argument_list|)
operator|,
name|PathToBaseWithVFPtr
argument_list|(
name|PathToBaseWithVFPtr
argument_list|)
operator|,
name|VFPtrFullOffset
argument_list|(
argument|VFPtrOffset
argument_list|)
block|{   }
comment|// Don't pass the PathToMangle as it should be calculated later.
name|VFPtrInfo
argument_list|(
argument|uint64_t VBTableIndex
argument_list|,
argument|const CXXRecordDecl *LastVBase
argument_list|,
argument|CharUnits VFPtrOffset
argument_list|,
argument|const BasePath&PathToBaseWithVFPtr
argument_list|,
argument|CharUnits VFPtrFullOffset
argument_list|)
operator|:
name|VBTableIndex
argument_list|(
name|VBTableIndex
argument_list|)
operator|,
name|LastVBase
argument_list|(
name|LastVBase
argument_list|)
operator|,
name|VFPtrOffset
argument_list|(
name|VFPtrOffset
argument_list|)
operator|,
name|PathToBaseWithVFPtr
argument_list|(
name|PathToBaseWithVFPtr
argument_list|)
operator|,
name|VFPtrFullOffset
argument_list|(
argument|VFPtrFullOffset
argument_list|)
block|{
name|assert
argument_list|(
name|VBTableIndex
operator|&&
literal|"The full constructor should only be used "
literal|"for vfptrs in virtual bases"
argument_list|)
block|;
name|assert
argument_list|(
name|LastVBase
argument_list|)
block|;   }
comment|/// If nonzero, holds the vbtable index of the virtual base with the vfptr.
name|uint64_t
name|VBTableIndex
expr_stmt|;
comment|/// Stores the last vbase on the path from the complete type to the vfptr.
specifier|const
name|CXXRecordDecl
modifier|*
name|LastVBase
decl_stmt|;
comment|/// This is the offset of the vfptr from the start of the last vbase,
comment|/// or the complete type if there are no virtual bases.
name|CharUnits
name|VFPtrOffset
decl_stmt|;
comment|/// This holds the base classes path from the complete type to the first base
comment|/// with the given vfptr offset, in the base-to-derived order.
name|BasePath
name|PathToBaseWithVFPtr
decl_stmt|;
comment|/// This holds the subset of records that need to be mangled into the vftable
comment|/// symbol name in order to get a unique name, in the derived-to-base order.
name|BasePath
name|PathToMangle
decl_stmt|;
comment|/// This is the full offset of the vfptr from the start of the complete type.
name|CharUnits
name|VFPtrFullOffset
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
name|class
name|MicrosoftVTableContext
range|:
name|public
name|VTableContextBase
block|{
name|public
operator|:
expr|struct
name|MethodVFTableLocation
block|{
comment|/// If nonzero, holds the vbtable index of the virtual base with the vfptr.
name|uint64_t
name|VBTableIndex
block|;
comment|/// If nonnull, holds the last vbase which contains the vfptr that the
comment|/// method definition is adjusted to.
specifier|const
name|CXXRecordDecl
operator|*
name|VBase
block|;
comment|/// This is the offset of the vfptr from the start of the last vbase, or the
comment|/// complete type if there are no virtual bases.
name|CharUnits
name|VFPtrOffset
block|;
comment|/// Method's index in the vftable.
name|uint64_t
name|Index
block|;
name|MethodVFTableLocation
argument_list|()
operator|:
name|VBTableIndex
argument_list|(
literal|0
argument_list|)
block|,
name|VBase
argument_list|(
literal|0
argument_list|)
block|,
name|VFPtrOffset
argument_list|(
name|CharUnits
operator|::
name|Zero
argument_list|()
argument_list|)
block|,
name|Index
argument_list|(
literal|0
argument_list|)
block|{}
name|MethodVFTableLocation
argument_list|(
argument|uint64_t VBTableIndex
argument_list|,
argument|const CXXRecordDecl *VBase
argument_list|,
argument|CharUnits VFPtrOffset
argument_list|,
argument|uint64_t Index
argument_list|)
operator|:
name|VBTableIndex
argument_list|(
name|VBTableIndex
argument_list|)
block|,
name|VBase
argument_list|(
name|VBase
argument_list|)
block|,
name|VFPtrOffset
argument_list|(
name|VFPtrOffset
argument_list|)
block|,
name|Index
argument_list|(
argument|Index
argument_list|)
block|{}
name|bool
name|operator
operator|<
operator|(
specifier|const
name|MethodVFTableLocation
operator|&
name|other
operator|)
specifier|const
block|{
if|if
condition|(
name|VBTableIndex
operator|!=
name|other
operator|.
name|VBTableIndex
condition|)
block|{
name|assert
argument_list|(
name|VBase
operator|!=
name|other
operator|.
name|VBase
argument_list|)
expr_stmt|;
return|return
name|VBTableIndex
operator|<
name|other
operator|.
name|VBTableIndex
return|;
block|}
if|if
condition|(
name|VFPtrOffset
operator|!=
name|other
operator|.
name|VFPtrOffset
condition|)
return|return
name|VFPtrOffset
operator|<
name|other
operator|.
name|VFPtrOffset
return|;
if|if
condition|(
name|Index
operator|!=
name|other
operator|.
name|Index
condition|)
return|return
name|Index
operator|<
name|other
operator|.
name|Index
return|;
return|return
name|false
return|;
block|}
end_decl_stmt

begin_typedef
unit|};
typedef|typedef
name|SmallVector
operator|<
name|VFPtrInfo
operator|,
literal|1
operator|>
name|VFPtrListTy
expr_stmt|;
end_typedef

begin_label
name|private
label|:
end_label

begin_decl_stmt
name|ASTContext
modifier|&
name|Context
decl_stmt|;
end_decl_stmt

begin_typedef
typedef|typedef
name|llvm
operator|::
name|DenseMap
operator|<
name|GlobalDecl
operator|,
name|MethodVFTableLocation
operator|>
name|MethodVFTableLocationsTy
expr_stmt|;
end_typedef

begin_decl_stmt
name|MethodVFTableLocationsTy
name|MethodVFTableLocations
decl_stmt|;
end_decl_stmt

begin_typedef
typedef|typedef
name|llvm
operator|::
name|DenseMap
operator|<
specifier|const
name|CXXRecordDecl
operator|*
operator|,
name|VFPtrListTy
operator|>
name|VFPtrLocationsMapTy
expr_stmt|;
end_typedef

begin_decl_stmt
name|VFPtrLocationsMapTy
name|VFPtrLocations
decl_stmt|;
end_decl_stmt

begin_typedef
typedef|typedef
name|std
operator|::
name|pair
operator|<
specifier|const
name|CXXRecordDecl
operator|*
operator|,
name|CharUnits
operator|>
name|VFTableIdTy
expr_stmt|;
end_typedef

begin_typedef
typedef|typedef
name|llvm
operator|::
name|DenseMap
operator|<
name|VFTableIdTy
operator|,
specifier|const
name|VTableLayout
operator|*
operator|>
name|VFTableLayoutMapTy
expr_stmt|;
end_typedef

begin_decl_stmt
name|VFTableLayoutMapTy
name|VFTableLayouts
decl_stmt|;
end_decl_stmt

begin_typedef
typedef|typedef
name|llvm
operator|::
name|SmallSetVector
operator|<
specifier|const
name|CXXRecordDecl
operator|*
operator|,
literal|8
operator|>
name|BasesSetVectorTy
expr_stmt|;
end_typedef

begin_decl_stmt
name|void
name|enumerateVFPtrs
argument_list|(
specifier|const
name|CXXRecordDecl
operator|*
name|MostDerivedClass
argument_list|,
specifier|const
name|ASTRecordLayout
operator|&
name|MostDerivedClassLayout
argument_list|,
name|BaseSubobject
name|Base
argument_list|,
specifier|const
name|CXXRecordDecl
operator|*
name|LastVBase
argument_list|,
specifier|const
name|VFPtrInfo
operator|::
name|BasePath
operator|&
name|PathFromCompleteClass
argument_list|,
name|BasesSetVectorTy
operator|&
name|VisitedVBases
argument_list|,
name|MicrosoftVTableContext
operator|::
name|VFPtrListTy
operator|&
name|Result
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|enumerateVFPtrs
argument_list|(
specifier|const
name|CXXRecordDecl
operator|*
name|ForClass
argument_list|,
name|MicrosoftVTableContext
operator|::
name|VFPtrListTy
operator|&
name|Result
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function_decl
name|void
name|computeVTableRelatedInformation
parameter_list|(
specifier|const
name|CXXRecordDecl
modifier|*
name|RD
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|dumpMethodLocations
parameter_list|(
specifier|const
name|CXXRecordDecl
modifier|*
name|RD
parameter_list|,
specifier|const
name|MethodVFTableLocationsTy
modifier|&
name|NewMethods
parameter_list|,
name|raw_ostream
modifier|&
parameter_list|)
function_decl|;
end_function_decl

begin_typedef
typedef|typedef
name|std
operator|::
name|pair
operator|<
specifier|const
name|CXXRecordDecl
operator|*
operator|,
specifier|const
name|CXXRecordDecl
operator|*
operator|>
name|ClassPairTy
expr_stmt|;
end_typedef

begin_typedef
typedef|typedef
name|llvm
operator|::
name|DenseMap
operator|<
name|ClassPairTy
operator|,
name|unsigned
operator|>
name|VBTableIndicesTy
expr_stmt|;
end_typedef

begin_decl_stmt
name|VBTableIndicesTy
name|VBTableIndices
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|llvm
operator|::
name|DenseSet
operator|<
specifier|const
name|CXXRecordDecl
operator|*
operator|>
name|ComputedVBTableIndices
expr_stmt|;
end_expr_stmt

begin_function_decl
name|void
name|computeVBTableRelatedInformation
parameter_list|(
specifier|const
name|CXXRecordDecl
modifier|*
name|RD
parameter_list|)
function_decl|;
end_function_decl

begin_label
name|public
label|:
end_label

begin_expr_stmt
name|MicrosoftVTableContext
argument_list|(
name|ASTContext
operator|&
name|Context
argument_list|)
operator|:
name|Context
argument_list|(
argument|Context
argument_list|)
block|{}
operator|~
name|MicrosoftVTableContext
argument_list|()
block|{
name|llvm
operator|::
name|DeleteContainerSeconds
argument_list|(
name|VFTableLayouts
argument_list|)
block|; }
specifier|const
name|VFPtrListTy
operator|&
name|getVFPtrOffsets
argument_list|(
specifier|const
name|CXXRecordDecl
operator|*
name|RD
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function_decl
specifier|const
name|VTableLayout
modifier|&
name|getVFTableLayout
parameter_list|(
specifier|const
name|CXXRecordDecl
modifier|*
name|RD
parameter_list|,
name|CharUnits
name|VFPtrOffset
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|const
name|MethodVFTableLocation
modifier|&
name|getMethodVFTableLocation
parameter_list|(
name|GlobalDecl
name|GD
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|const
name|ThunkInfoVectorTy
modifier|*
name|getThunkInfo
parameter_list|(
name|GlobalDecl
name|GD
parameter_list|)
block|{
comment|// Complete destructors don't have a slot in a vftable, so no thunks needed.
if|if
condition|(
name|isa
operator|<
name|CXXDestructorDecl
operator|>
operator|(
name|GD
operator|.
name|getDecl
argument_list|()
operator|)
operator|&&
name|GD
operator|.
name|getDtorType
argument_list|()
operator|==
name|Dtor_Complete
condition|)
return|return
literal|0
return|;
return|return
name|VTableContextBase
operator|::
name|getThunkInfo
argument_list|(
name|GD
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/// \brief Returns the index of VBase in the vbtable of Derived.
end_comment

begin_comment
comment|/// VBase must be a morally virtual base of Derived.
end_comment

begin_comment
comment|/// The vbtable is an array of i32 offsets.  The first entry is a self entry,
end_comment

begin_comment
comment|/// and the rest are offsets from the vbptr to virtual bases.
end_comment

begin_function
name|unsigned
name|getVBTableIndex
parameter_list|(
specifier|const
name|CXXRecordDecl
modifier|*
name|Derived
parameter_list|,
specifier|const
name|CXXRecordDecl
modifier|*
name|VBase
parameter_list|)
block|{
name|computeVBTableRelatedInformation
argument_list|(
name|Derived
argument_list|)
expr_stmt|;
name|ClassPairTy
name|Pair
argument_list|(
name|Derived
argument_list|,
name|VBase
argument_list|)
decl_stmt|;
name|assert
argument_list|(
name|VBTableIndices
operator|.
name|count
argument_list|(
name|Pair
argument_list|)
operator|==
literal|1
operator|&&
literal|"VBase must be a vbase of Derived"
argument_list|)
expr_stmt|;
return|return
name|VBTableIndices
index|[
name|Pair
index|]
return|;
block|}
end_function

begin_endif
unit|}; }
endif|#
directive|endif
end_endif

end_unit

