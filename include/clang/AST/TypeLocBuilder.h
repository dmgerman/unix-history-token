begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===--- TypeLocBuilder.h - Type Source Info collector ----------*- C++ -*-===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//  This files defines TypeLocBuilder, a class for building TypeLocs
end_comment

begin_comment
comment|//  bottom-up.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LLVM_CLANG_AST_TYPELOCBUILDER_H
end_ifndef

begin_define
define|#
directive|define
name|LLVM_CLANG_AST_TYPELOCBUILDER_H
end_define

begin_include
include|#
directive|include
file|"clang/AST/TypeLoc.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/SmallVector.h"
end_include

begin_decl_stmt
name|namespace
name|clang
block|{
name|class
name|TypeLocBuilder
block|{
enum|enum
block|{
name|InlineCapacity
init|=
literal|8
operator|*
expr|sizeof
operator|(
name|SourceLocation
operator|)
block|}
enum|;
comment|/// The underlying location-data buffer.  Data grows from the end
comment|/// of the buffer backwards.
name|char
modifier|*
name|Buffer
decl_stmt|;
comment|/// The capacity of the current buffer.
name|size_t
name|Capacity
decl_stmt|;
comment|/// The index of the first occupied byte in the buffer.
name|size_t
name|Index
decl_stmt|;
ifndef|#
directive|ifndef
name|NDEBUG
comment|/// The last type pushed on this builder.
name|QualType
name|LastTy
decl_stmt|;
endif|#
directive|endif
comment|/// The inline buffer.
name|char
name|InlineBuffer
index|[
name|InlineCapacity
index|]
decl_stmt|;
name|public
label|:
name|TypeLocBuilder
argument_list|()
operator|:
name|Buffer
argument_list|(
name|InlineBuffer
argument_list|)
operator|,
name|Capacity
argument_list|(
name|InlineCapacity
argument_list|)
operator|,
name|Index
argument_list|(
argument|InlineCapacity
argument_list|)
block|{}
operator|~
name|TypeLocBuilder
argument_list|()
block|{
if|if
condition|(
name|Buffer
operator|!=
name|InlineBuffer
condition|)
name|delete
index|[]
name|Buffer
decl_stmt|;
block|}
comment|/// Ensures that this buffer has at least as much capacity as described.
name|void
name|reserve
parameter_list|(
name|size_t
name|Requested
parameter_list|)
block|{
if|if
condition|(
name|Requested
operator|>
name|Capacity
condition|)
comment|// For now, match the request exactly.
name|grow
argument_list|(
name|Requested
argument_list|)
expr_stmt|;
block|}
comment|/// Pushes space for a new TypeLoc onto the given type.  Invalidates
comment|/// any TypeLocs previously retrieved from this builder.
name|template
operator|<
name|class
name|TyLocType
operator|>
name|TyLocType
name|push
argument_list|(
argument|QualType T
argument_list|)
block|{
ifndef|#
directive|ifndef
name|NDEBUG
name|QualType
name|TLast
operator|=
name|TypeLoc
argument_list|(
name|T
argument_list|,
literal|0
argument_list|)
operator|.
name|getNextTypeLoc
argument_list|()
operator|.
name|getType
argument_list|()
block|;
name|assert
argument_list|(
name|TLast
operator|==
name|LastTy
operator|&&
literal|"mismatch between last type and new type's inner type"
argument_list|)
block|;
name|LastTy
operator|=
name|T
block|;
endif|#
directive|endif
name|size_t
name|LocalSize
operator|=
name|cast
operator|<
name|TyLocType
operator|>
operator|(
name|TypeLoc
argument_list|(
name|T
argument_list|,
literal|0
argument_list|)
operator|)
operator|.
name|getLocalDataSize
argument_list|()
block|;
comment|// If we need to grow, grow by a factor of 2.
if|if
condition|(
name|LocalSize
operator|>
name|Index
condition|)
block|{
name|size_t
name|RequiredCapacity
init|=
name|Capacity
operator|+
operator|(
name|LocalSize
operator|-
name|Index
operator|)
decl_stmt|;
name|size_t
name|NewCapacity
init|=
name|Capacity
operator|*
literal|2
decl_stmt|;
while|while
condition|(
name|RequiredCapacity
operator|>
name|NewCapacity
condition|)
name|NewCapacity
operator|*=
literal|2
expr_stmt|;
name|grow
argument_list|(
name|NewCapacity
argument_list|)
expr_stmt|;
block|}
name|Index
operator|-=
name|LocalSize
expr_stmt|;
return|return
name|cast
operator|<
name|TyLocType
operator|>
operator|(
name|TypeLoc
argument_list|(
name|T
argument_list|,
operator|&
name|Buffer
index|[
name|Index
index|]
argument_list|)
operator|)
return|;
block|}
comment|/// Creates a DeclaratorInfo for the given type.
name|DeclaratorInfo
modifier|*
name|getDeclaratorInfo
parameter_list|(
name|ASTContext
modifier|&
name|Context
parameter_list|,
name|QualType
name|T
parameter_list|)
block|{
ifndef|#
directive|ifndef
name|NDEBUG
name|assert
argument_list|(
name|T
operator|==
name|LastTy
operator|&&
literal|"type doesn't match last type pushed!"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|size_t
name|FullDataSize
init|=
name|Capacity
operator|-
name|Index
decl_stmt|;
name|DeclaratorInfo
modifier|*
name|DI
init|=
name|Context
operator|.
name|CreateDeclaratorInfo
argument_list|(
name|T
argument_list|,
name|FullDataSize
argument_list|)
decl_stmt|;
name|memcpy
argument_list|(
name|DI
operator|->
name|getTypeLoc
argument_list|()
operator|.
name|getOpaqueData
argument_list|()
argument_list|,
operator|&
name|Buffer
index|[
name|Index
index|]
argument_list|,
name|FullDataSize
argument_list|)
expr_stmt|;
return|return
name|DI
return|;
block|}
name|private
label|:
comment|/// Grow to the given capacity.
name|void
name|grow
parameter_list|(
name|size_t
name|NewCapacity
parameter_list|)
block|{
name|assert
argument_list|(
name|NewCapacity
operator|>
name|Capacity
argument_list|)
expr_stmt|;
comment|// Allocate the new buffer and copy the old data into it.
name|char
modifier|*
name|NewBuffer
init|=
name|new
name|char
index|[
name|NewCapacity
index|]
decl_stmt|;
name|unsigned
name|NewIndex
init|=
name|Index
operator|+
name|NewCapacity
operator|-
name|Capacity
decl_stmt|;
name|memcpy
argument_list|(
operator|&
name|NewBuffer
index|[
name|NewIndex
index|]
argument_list|,
operator|&
name|Buffer
index|[
name|Index
index|]
argument_list|,
name|Capacity
operator|-
name|Index
argument_list|)
expr_stmt|;
if|if
condition|(
name|Buffer
operator|!=
name|InlineBuffer
condition|)
name|delete
index|[]
name|Buffer
decl_stmt|;
name|Buffer
operator|=
name|NewBuffer
expr_stmt|;
name|Capacity
operator|=
name|NewCapacity
expr_stmt|;
name|Index
operator|=
name|NewIndex
expr_stmt|;
block|}
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_endif
unit|}
endif|#
directive|endif
end_endif

end_unit

