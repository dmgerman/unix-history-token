begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===--- RecursiveASTVisitor.h - Recursive AST Visitor ----------*- C++ -*-===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//  This file defines the RecursiveASTVisitor interface, which recursively
end_comment

begin_comment
comment|//  traverses the entire AST.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LLVM_CLANG_AST_RECURSIVEASTVISITOR_H
end_ifndef

begin_define
define|#
directive|define
name|LLVM_CLANG_AST_RECURSIVEASTVISITOR_H
end_define

begin_include
include|#
directive|include
file|"clang/AST/Decl.h"
end_include

begin_include
include|#
directive|include
file|"clang/AST/DeclCXX.h"
end_include

begin_include
include|#
directive|include
file|"clang/AST/DeclFriend.h"
end_include

begin_include
include|#
directive|include
file|"clang/AST/DeclObjC.h"
end_include

begin_include
include|#
directive|include
file|"clang/AST/DeclTemplate.h"
end_include

begin_include
include|#
directive|include
file|"clang/AST/Expr.h"
end_include

begin_include
include|#
directive|include
file|"clang/AST/ExprCXX.h"
end_include

begin_include
include|#
directive|include
file|"clang/AST/ExprObjC.h"
end_include

begin_include
include|#
directive|include
file|"clang/AST/NestedNameSpecifier.h"
end_include

begin_include
include|#
directive|include
file|"clang/AST/Stmt.h"
end_include

begin_include
include|#
directive|include
file|"clang/AST/StmtCXX.h"
end_include

begin_include
include|#
directive|include
file|"clang/AST/StmtObjC.h"
end_include

begin_include
include|#
directive|include
file|"clang/AST/TemplateBase.h"
end_include

begin_include
include|#
directive|include
file|"clang/AST/TemplateName.h"
end_include

begin_include
include|#
directive|include
file|"clang/AST/Type.h"
end_include

begin_decl_stmt
name|namespace
name|clang
block|{
define|#
directive|define
name|DISPATCH
parameter_list|(
name|NAME
parameter_list|,
name|CLASS
parameter_list|,
name|Var
parameter_list|)
define|\
value|return getDerived().Visit ## NAME(static_cast<CLASS*>(Var))
comment|// We use preprocessor meta-programming to generate the Visit*()
comment|// methods for all subclasses of Stmt, Decl, and Type.  Some of the
comment|// generated definitions, however, need to be customized.  The
comment|// meta-programming technique we use doesn't let us select which
comment|// methods to generate.  Therefore we have to generate ALL of them in
comment|// a helper class RecursiveASTVisitorImpl, and override the ones we
comment|// don't like in a child class RecursiveASTVisitor (C++ doesn't allow
comment|// overriding a method in the same class).
comment|//
comment|// Do not use this class directly - use RecursiveASTVisitor instead.
name|template
operator|<
name|typename
name|Derived
operator|>
name|class
name|RecursiveASTVisitorImpl
block|{
name|public
operator|:
comment|/// \brief Return a reference to the derived class.
name|Derived
operator|&
name|getDerived
argument_list|()
block|{
return|return
operator|*
name|static_cast
operator|<
name|Derived
operator|*
operator|>
operator|(
name|this
operator|)
return|;
block|}
comment|/// \brief Recursively visit a statement or expression, by
comment|/// dispatching to Visit*() based on the argument's dynamic type.
comment|/// This is NOT meant to be overridden by a subclass.
comment|///
comment|/// \returns true if the visitation was terminated early, false
comment|/// otherwise (including when the argument is NULL).
name|bool
name|Visit
argument_list|(
name|Stmt
operator|*
name|S
argument_list|)
block|;
comment|/// \brief Recursively visit a type, by dispatching to
comment|/// Visit*Type() based on the argument's getTypeClass() property.
comment|/// This is NOT meant to be overridden by a subclass.
comment|///
comment|/// \returns true if the visitation was terminated early, false
comment|/// otherwise (including when the argument is a Null type).
name|bool
name|Visit
argument_list|(
argument|QualType T
argument_list|)
block|;
comment|/// \brief Recursively visit a declaration, by dispatching to
comment|/// Visit*Decl() based on the argument's dynamic type.  This is
comment|/// NOT meant to be overridden by a subclass.
comment|///
comment|/// \returns true if the visitation was terminated early, false
comment|/// otherwise (including when the argument is NULL).
name|bool
name|Visit
argument_list|(
name|Decl
operator|*
name|D
argument_list|)
block|;
comment|/// \brief Recursively visit a C++ nested-name-specifier.
comment|///
comment|/// \returns true if the visitation was terminated early, false otherwise.
name|bool
name|VisitNestedNameSpecifier
argument_list|(
name|NestedNameSpecifier
operator|*
name|NNS
argument_list|)
block|;
comment|/// \brief Recursively visit a template name.
comment|///
comment|/// \returns true if the visitation was terminated early, false otherwise.
name|bool
name|VisitTemplateName
argument_list|(
argument|TemplateName Template
argument_list|)
block|;
comment|/// \brief Recursively visit a template argument.
comment|///
comment|/// \returns true if the visitation was terminated early, false otherwise.
name|bool
name|VisitTemplateArgument
argument_list|(
specifier|const
name|TemplateArgument
operator|&
name|Arg
argument_list|)
block|;
comment|/// \brief Recursively visit a set of template arguments.
comment|///
comment|/// \returns true if the visitation was terminated early, false otherwise.
name|bool
name|VisitTemplateArguments
argument_list|(
argument|const TemplateArgument *Args
argument_list|,
argument|unsigned NumArgs
argument_list|)
block|;
comment|// If the implementation chooses not to implement a certain visit method, fall
comment|// back on VisitExpr or whatever else is the superclass.
define|#
directive|define
name|STMT
parameter_list|(
name|CLASS
parameter_list|,
name|PARENT
parameter_list|)
define|\
value|bool Visit ## CLASS(CLASS *S) { DISPATCH(PARENT, PARENT, S); }
include|#
directive|include
file|"clang/AST/StmtNodes.inc"
comment|// If the implementation doesn't implement binary operator methods, fall back
comment|// on VisitBinaryOperator.
define|#
directive|define
name|BINOP_FALLBACK
parameter_list|(
name|NAME
parameter_list|)
define|\
value|bool VisitBin ## NAME(BinaryOperator *S) {   \ DISPATCH(BinaryOperator, BinaryOperator, S); \ }
name|BINOP_FALLBACK
argument_list|(
argument|PtrMemD
argument_list|)
name|BINOP_FALLBACK
argument_list|(
argument|PtrMemI
argument_list|)
name|BINOP_FALLBACK
argument_list|(
argument|Mul
argument_list|)
name|BINOP_FALLBACK
argument_list|(
argument|Div
argument_list|)
name|BINOP_FALLBACK
argument_list|(
argument|Rem
argument_list|)
name|BINOP_FALLBACK
argument_list|(
argument|Add
argument_list|)
name|BINOP_FALLBACK
argument_list|(
argument|Sub
argument_list|)
name|BINOP_FALLBACK
argument_list|(
argument|Shl
argument_list|)
name|BINOP_FALLBACK
argument_list|(
argument|Shr
argument_list|)
name|BINOP_FALLBACK
argument_list|(
argument|LT
argument_list|)
name|BINOP_FALLBACK
argument_list|(
argument|GT
argument_list|)
name|BINOP_FALLBACK
argument_list|(
argument|LE
argument_list|)
name|BINOP_FALLBACK
argument_list|(
argument|GE
argument_list|)
name|BINOP_FALLBACK
argument_list|(
argument|EQ
argument_list|)
name|BINOP_FALLBACK
argument_list|(
argument|NE
argument_list|)
name|BINOP_FALLBACK
argument_list|(
argument|And
argument_list|)
name|BINOP_FALLBACK
argument_list|(
argument|Xor
argument_list|)
name|BINOP_FALLBACK
argument_list|(
argument|Or
argument_list|)
name|BINOP_FALLBACK
argument_list|(
argument|LAnd
argument_list|)
name|BINOP_FALLBACK
argument_list|(
argument|LOr
argument_list|)
name|BINOP_FALLBACK
argument_list|(
argument|Assign
argument_list|)
name|BINOP_FALLBACK
argument_list|(
argument|Comma
argument_list|)
undef|#
directive|undef
name|BINOP_FALLBACK
comment|// If the implementation doesn't implement compound assignment operator
comment|// methods, fall back on VisitCompoundAssignOperator.
define|#
directive|define
name|CAO_FALLBACK
parameter_list|(
name|NAME
parameter_list|)
define|\
value|bool VisitBin ## NAME(CompoundAssignOperator *S) { \ DISPATCH(CompoundAssignOperator, CompoundAssignOperator, S); \ }
name|CAO_FALLBACK
argument_list|(
argument|MulAssign
argument_list|)
name|CAO_FALLBACK
argument_list|(
argument|DivAssign
argument_list|)
name|CAO_FALLBACK
argument_list|(
argument|RemAssign
argument_list|)
name|CAO_FALLBACK
argument_list|(
argument|AddAssign
argument_list|)
name|CAO_FALLBACK
argument_list|(
argument|SubAssign
argument_list|)
name|CAO_FALLBACK
argument_list|(
argument|ShlAssign
argument_list|)
name|CAO_FALLBACK
argument_list|(
argument|ShrAssign
argument_list|)
name|CAO_FALLBACK
argument_list|(
argument|AndAssign
argument_list|)
name|CAO_FALLBACK
argument_list|(
argument|OrAssign
argument_list|)
name|CAO_FALLBACK
argument_list|(
argument|XorAssign
argument_list|)
undef|#
directive|undef
name|CAO_FALLBACK
comment|// If the implementation doesn't implement unary operator methods, fall back
comment|// on VisitUnaryOperator.
define|#
directive|define
name|UNARYOP_FALLBACK
parameter_list|(
name|NAME
parameter_list|)
define|\
value|bool VisitUnary ## NAME(UnaryOperator *S) { \ DISPATCH(UnaryOperator, UnaryOperator, S);    \ }
name|UNARYOP_FALLBACK
argument_list|(
argument|PostInc
argument_list|)
name|UNARYOP_FALLBACK
argument_list|(
argument|PostDec
argument_list|)
name|UNARYOP_FALLBACK
argument_list|(
argument|PreInc
argument_list|)
name|UNARYOP_FALLBACK
argument_list|(
argument|PreDec
argument_list|)
name|UNARYOP_FALLBACK
argument_list|(
argument|AddrOf
argument_list|)
name|UNARYOP_FALLBACK
argument_list|(
argument|Deref
argument_list|)
name|UNARYOP_FALLBACK
argument_list|(
argument|Plus
argument_list|)
name|UNARYOP_FALLBACK
argument_list|(
argument|Minus
argument_list|)
name|UNARYOP_FALLBACK
argument_list|(
argument|Not
argument_list|)
name|UNARYOP_FALLBACK
argument_list|(
argument|LNot
argument_list|)
name|UNARYOP_FALLBACK
argument_list|(
argument|Real
argument_list|)
name|UNARYOP_FALLBACK
argument_list|(
argument|Imag
argument_list|)
name|UNARYOP_FALLBACK
argument_list|(
argument|Extension
argument_list|)
name|UNARYOP_FALLBACK
argument_list|(
argument|OffsetOf
argument_list|)
undef|#
directive|undef
name|UNARYOP_FALLBACK
comment|/// \brief Basis for statement and expression visitation, which
comment|/// visits all of the substatements and subexpressions.
comment|///
comment|/// The relation between Visit(Stmt *S) and this method is that
comment|/// the former dispatches to Visit*() based on S's dynamic type,
comment|/// which forwards the call up the inheritance chain until
comment|/// reaching VisitStmt(), which then calls Visit() on each
comment|/// substatement/subexpression.
name|bool
name|VisitStmt
argument_list|(
name|Stmt
operator|*
name|S
argument_list|)
block|;
comment|/// \brief Basis for type visitation, which by default does nothing.
comment|///
comment|/// The relation between Visit(QualType T) and this method is
comment|/// that the former dispatches to Visit*Type(), which forwards the
comment|/// call up the inheritance chain until reaching VisitType().
name|bool
name|VisitType
argument_list|(
name|Type
operator|*
name|T
argument_list|)
block|;
define|#
directive|define
name|TYPE
parameter_list|(
name|Class
parameter_list|,
name|Base
parameter_list|)
define|\
value|bool Visit##Class##Type(Class##Type *T);
include|#
directive|include
file|"clang/AST/TypeNodes.def"
comment|/// \brief Basis for declaration and definition visitation, which
comment|/// visits all of the subnodes.
comment|///
comment|/// The relation between Visit(Decl *) and this method is that the
comment|/// former dispatches to Visit*Decl(), which forwards the call up
comment|/// the inheritance chain until reaching VisitDecl().
name|bool
name|VisitDecl
argument_list|(
name|Decl
operator|*
name|D
argument_list|)
block|;
define|#
directive|define
name|DECL
parameter_list|(
name|Class
parameter_list|,
name|Base
parameter_list|)
define|\
value|bool Visit##Class##Decl(Class##Decl *D) {      \     return getDerived().Visit##Base(D);          \   }
define|#
directive|define
name|ABSTRACT_DECL
parameter_list|(
name|Class
parameter_list|,
name|Base
parameter_list|)
value|DECL(Class, Base)
include|#
directive|include
file|"clang/AST/DeclNodes.def"
block|}
expr_stmt|;
name|template
operator|<
name|typename
name|Derived
operator|>
name|bool
name|RecursiveASTVisitorImpl
operator|<
name|Derived
operator|>
operator|::
name|Visit
argument_list|(
argument|Stmt *S
argument_list|)
block|{
if|if
condition|(
operator|!
name|S
condition|)
return|return
name|false
return|;
comment|// If we have a binary expr, dispatch to the subcode of the binop.  A smart
comment|// optimizer (e.g. LLVM) will fold this comparison into the switch stmt
comment|// below.
if|if
condition|(
name|BinaryOperator
modifier|*
name|BinOp
init|=
name|dyn_cast
operator|<
name|BinaryOperator
operator|>
operator|(
name|S
operator|)
condition|)
block|{
switch|switch
condition|(
name|BinOp
operator|->
name|getOpcode
argument_list|()
condition|)
block|{
case|case
name|BinaryOperator
operator|::
name|PtrMemD
case|:
name|DISPATCH
argument_list|(
name|BinPtrMemD
argument_list|,
name|BinaryOperator
argument_list|,
name|S
argument_list|)
expr_stmt|;
case|case
name|BinaryOperator
operator|::
name|PtrMemI
case|:
name|DISPATCH
argument_list|(
name|BinPtrMemI
argument_list|,
name|BinaryOperator
argument_list|,
name|S
argument_list|)
expr_stmt|;
case|case
name|BinaryOperator
operator|::
name|Mul
case|:
name|DISPATCH
argument_list|(
name|BinMul
argument_list|,
name|BinaryOperator
argument_list|,
name|S
argument_list|)
expr_stmt|;
case|case
name|BinaryOperator
operator|::
name|Div
case|:
name|DISPATCH
argument_list|(
name|BinDiv
argument_list|,
name|BinaryOperator
argument_list|,
name|S
argument_list|)
expr_stmt|;
case|case
name|BinaryOperator
operator|::
name|Rem
case|:
name|DISPATCH
argument_list|(
name|BinRem
argument_list|,
name|BinaryOperator
argument_list|,
name|S
argument_list|)
expr_stmt|;
case|case
name|BinaryOperator
operator|::
name|Add
case|:
name|DISPATCH
argument_list|(
name|BinAdd
argument_list|,
name|BinaryOperator
argument_list|,
name|S
argument_list|)
expr_stmt|;
case|case
name|BinaryOperator
operator|::
name|Sub
case|:
name|DISPATCH
argument_list|(
name|BinSub
argument_list|,
name|BinaryOperator
argument_list|,
name|S
argument_list|)
expr_stmt|;
case|case
name|BinaryOperator
operator|::
name|Shl
case|:
name|DISPATCH
argument_list|(
name|BinShl
argument_list|,
name|BinaryOperator
argument_list|,
name|S
argument_list|)
expr_stmt|;
case|case
name|BinaryOperator
operator|::
name|Shr
case|:
name|DISPATCH
argument_list|(
name|BinShr
argument_list|,
name|BinaryOperator
argument_list|,
name|S
argument_list|)
expr_stmt|;
case|case
name|BinaryOperator
operator|::
name|LT
case|:
name|DISPATCH
argument_list|(
name|BinLT
argument_list|,
name|BinaryOperator
argument_list|,
name|S
argument_list|)
expr_stmt|;
case|case
name|BinaryOperator
operator|::
name|GT
case|:
name|DISPATCH
argument_list|(
name|BinGT
argument_list|,
name|BinaryOperator
argument_list|,
name|S
argument_list|)
expr_stmt|;
case|case
name|BinaryOperator
operator|::
name|LE
case|:
name|DISPATCH
argument_list|(
name|BinLE
argument_list|,
name|BinaryOperator
argument_list|,
name|S
argument_list|)
expr_stmt|;
case|case
name|BinaryOperator
operator|::
name|GE
case|:
name|DISPATCH
argument_list|(
name|BinGE
argument_list|,
name|BinaryOperator
argument_list|,
name|S
argument_list|)
expr_stmt|;
case|case
name|BinaryOperator
operator|::
name|EQ
case|:
name|DISPATCH
argument_list|(
name|BinEQ
argument_list|,
name|BinaryOperator
argument_list|,
name|S
argument_list|)
expr_stmt|;
case|case
name|BinaryOperator
operator|::
name|NE
case|:
name|DISPATCH
argument_list|(
name|BinNE
argument_list|,
name|BinaryOperator
argument_list|,
name|S
argument_list|)
expr_stmt|;
case|case
name|BinaryOperator
operator|::
name|And
case|:
name|DISPATCH
argument_list|(
name|BinAnd
argument_list|,
name|BinaryOperator
argument_list|,
name|S
argument_list|)
expr_stmt|;
case|case
name|BinaryOperator
operator|::
name|Xor
case|:
name|DISPATCH
argument_list|(
name|BinXor
argument_list|,
name|BinaryOperator
argument_list|,
name|S
argument_list|)
expr_stmt|;
case|case
name|BinaryOperator
operator|::
name|Or
case|:
name|DISPATCH
argument_list|(
name|BinOr
argument_list|,
name|BinaryOperator
argument_list|,
name|S
argument_list|)
expr_stmt|;
case|case
name|BinaryOperator
operator|::
name|LAnd
case|:
name|DISPATCH
argument_list|(
name|BinLAnd
argument_list|,
name|BinaryOperator
argument_list|,
name|S
argument_list|)
expr_stmt|;
case|case
name|BinaryOperator
operator|::
name|LOr
case|:
name|DISPATCH
argument_list|(
name|BinLOr
argument_list|,
name|BinaryOperator
argument_list|,
name|S
argument_list|)
expr_stmt|;
case|case
name|BinaryOperator
operator|::
name|Assign
case|:
name|DISPATCH
argument_list|(
name|BinAssign
argument_list|,
name|BinaryOperator
argument_list|,
name|S
argument_list|)
expr_stmt|;
case|case
name|BinaryOperator
operator|::
name|MulAssign
case|:
name|DISPATCH
argument_list|(
name|BinMulAssign
argument_list|,
name|CompoundAssignOperator
argument_list|,
name|S
argument_list|)
expr_stmt|;
case|case
name|BinaryOperator
operator|::
name|DivAssign
case|:
name|DISPATCH
argument_list|(
name|BinDivAssign
argument_list|,
name|CompoundAssignOperator
argument_list|,
name|S
argument_list|)
expr_stmt|;
case|case
name|BinaryOperator
operator|::
name|RemAssign
case|:
name|DISPATCH
argument_list|(
name|BinRemAssign
argument_list|,
name|CompoundAssignOperator
argument_list|,
name|S
argument_list|)
expr_stmt|;
case|case
name|BinaryOperator
operator|::
name|AddAssign
case|:
name|DISPATCH
argument_list|(
name|BinAddAssign
argument_list|,
name|CompoundAssignOperator
argument_list|,
name|S
argument_list|)
expr_stmt|;
case|case
name|BinaryOperator
operator|::
name|SubAssign
case|:
name|DISPATCH
argument_list|(
name|BinSubAssign
argument_list|,
name|CompoundAssignOperator
argument_list|,
name|S
argument_list|)
expr_stmt|;
case|case
name|BinaryOperator
operator|::
name|ShlAssign
case|:
name|DISPATCH
argument_list|(
name|BinShlAssign
argument_list|,
name|CompoundAssignOperator
argument_list|,
name|S
argument_list|)
expr_stmt|;
case|case
name|BinaryOperator
operator|::
name|ShrAssign
case|:
name|DISPATCH
argument_list|(
name|BinShrAssign
argument_list|,
name|CompoundAssignOperator
argument_list|,
name|S
argument_list|)
expr_stmt|;
case|case
name|BinaryOperator
operator|::
name|AndAssign
case|:
name|DISPATCH
argument_list|(
name|BinAndAssign
argument_list|,
name|CompoundAssignOperator
argument_list|,
name|S
argument_list|)
expr_stmt|;
case|case
name|BinaryOperator
operator|::
name|OrAssign
case|:
name|DISPATCH
argument_list|(
name|BinOrAssign
argument_list|,
name|CompoundAssignOperator
argument_list|,
name|S
argument_list|)
expr_stmt|;
case|case
name|BinaryOperator
operator|::
name|XorAssign
case|:
name|DISPATCH
argument_list|(
name|BinXorAssign
argument_list|,
name|CompoundAssignOperator
argument_list|,
name|S
argument_list|)
expr_stmt|;
case|case
name|BinaryOperator
operator|::
name|Comma
case|:
name|DISPATCH
argument_list|(
name|BinComma
argument_list|,
name|BinaryOperator
argument_list|,
name|S
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|UnaryOperator
modifier|*
name|UnOp
init|=
name|dyn_cast
operator|<
name|UnaryOperator
operator|>
operator|(
name|S
operator|)
condition|)
block|{
switch|switch
condition|(
name|UnOp
operator|->
name|getOpcode
argument_list|()
condition|)
block|{
case|case
name|UnaryOperator
operator|::
name|PostInc
case|:
name|DISPATCH
argument_list|(
name|UnaryPostInc
argument_list|,
name|UnaryOperator
argument_list|,
name|S
argument_list|)
expr_stmt|;
case|case
name|UnaryOperator
operator|::
name|PostDec
case|:
name|DISPATCH
argument_list|(
name|UnaryPostDec
argument_list|,
name|UnaryOperator
argument_list|,
name|S
argument_list|)
expr_stmt|;
case|case
name|UnaryOperator
operator|::
name|PreInc
case|:
name|DISPATCH
argument_list|(
name|UnaryPreInc
argument_list|,
name|UnaryOperator
argument_list|,
name|S
argument_list|)
expr_stmt|;
case|case
name|UnaryOperator
operator|::
name|PreDec
case|:
name|DISPATCH
argument_list|(
name|UnaryPreDec
argument_list|,
name|UnaryOperator
argument_list|,
name|S
argument_list|)
expr_stmt|;
case|case
name|UnaryOperator
operator|::
name|AddrOf
case|:
name|DISPATCH
argument_list|(
name|UnaryAddrOf
argument_list|,
name|UnaryOperator
argument_list|,
name|S
argument_list|)
expr_stmt|;
case|case
name|UnaryOperator
operator|::
name|Deref
case|:
name|DISPATCH
argument_list|(
name|UnaryDeref
argument_list|,
name|UnaryOperator
argument_list|,
name|S
argument_list|)
expr_stmt|;
case|case
name|UnaryOperator
operator|::
name|Plus
case|:
name|DISPATCH
argument_list|(
name|UnaryPlus
argument_list|,
name|UnaryOperator
argument_list|,
name|S
argument_list|)
expr_stmt|;
case|case
name|UnaryOperator
operator|::
name|Minus
case|:
name|DISPATCH
argument_list|(
name|UnaryMinus
argument_list|,
name|UnaryOperator
argument_list|,
name|S
argument_list|)
expr_stmt|;
case|case
name|UnaryOperator
operator|::
name|Not
case|:
name|DISPATCH
argument_list|(
name|UnaryNot
argument_list|,
name|UnaryOperator
argument_list|,
name|S
argument_list|)
expr_stmt|;
case|case
name|UnaryOperator
operator|::
name|LNot
case|:
name|DISPATCH
argument_list|(
name|UnaryLNot
argument_list|,
name|UnaryOperator
argument_list|,
name|S
argument_list|)
expr_stmt|;
case|case
name|UnaryOperator
operator|::
name|Real
case|:
name|DISPATCH
argument_list|(
name|UnaryReal
argument_list|,
name|UnaryOperator
argument_list|,
name|S
argument_list|)
expr_stmt|;
case|case
name|UnaryOperator
operator|::
name|Imag
case|:
name|DISPATCH
argument_list|(
name|UnaryImag
argument_list|,
name|UnaryOperator
argument_list|,
name|S
argument_list|)
expr_stmt|;
case|case
name|UnaryOperator
operator|::
name|Extension
case|:
name|DISPATCH
argument_list|(
name|UnaryExtension
argument_list|,
name|UnaryOperator
argument_list|,
name|S
argument_list|)
expr_stmt|;
case|case
name|UnaryOperator
operator|::
name|OffsetOf
case|:
name|DISPATCH
argument_list|(
name|UnaryOffsetOf
argument_list|,
name|UnaryOperator
argument_list|,
name|S
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Top switch stmt: dispatch to VisitFooStmt for each FooStmt.
switch|switch
condition|(
name|S
operator|->
name|getStmtClass
argument_list|()
condition|)
block|{
case|case
name|Stmt
operator|::
name|NoStmtClass
case|:
break|break;
define|#
directive|define
name|ABSTRACT_STMT
parameter_list|(
name|STMT
parameter_list|)
define|#
directive|define
name|STMT
parameter_list|(
name|CLASS
parameter_list|,
name|PARENT
parameter_list|)
define|\
value|case Stmt::CLASS ## Class: DISPATCH(CLASS, CLASS, S);
include|#
directive|include
file|"clang/AST/StmtNodes.inc"
block|}
return|return
name|false
return|;
block|}
end_decl_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|Derived
operator|>
name|bool
name|RecursiveASTVisitorImpl
operator|<
name|Derived
operator|>
operator|::
name|Visit
argument_list|(
argument|QualType T
argument_list|)
block|{
if|if
condition|(
name|T
operator|.
name|isNull
argument_list|()
condition|)
return|return
name|false
return|;
end_expr_stmt

begin_switch
switch|switch
condition|(
name|T
operator|->
name|getTypeClass
argument_list|()
condition|)
block|{
define|#
directive|define
name|ABSTRACT_TYPE
parameter_list|(
name|Class
parameter_list|,
name|Base
parameter_list|)
define|#
directive|define
name|TYPE
parameter_list|(
name|Class
parameter_list|,
name|Base
parameter_list|)
define|\
value|case Type::Class: DISPATCH(Class##Type, Class##Type, T.getTypePtr());
include|#
directive|include
file|"clang/AST/TypeNodes.def"
block|}
end_switch

begin_return
return|return
name|false
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|Derived
operator|>
name|bool
name|RecursiveASTVisitorImpl
operator|<
name|Derived
operator|>
operator|::
name|Visit
argument_list|(
argument|Decl *D
argument_list|)
block|{
if|if
condition|(
operator|!
name|D
condition|)
return|return
name|false
return|;
end_expr_stmt

begin_switch
switch|switch
condition|(
name|D
operator|->
name|getKind
argument_list|()
condition|)
block|{
define|#
directive|define
name|ABSTRACT_DECL
parameter_list|(
name|Class
parameter_list|,
name|Base
parameter_list|)
define|#
directive|define
name|DECL
parameter_list|(
name|Class
parameter_list|,
name|Base
parameter_list|)
define|\
value|case Decl::Class: DISPATCH(Class##Decl, Class##Decl, D);
include|#
directive|include
file|"clang/AST/DeclNodes.def"
block|}
end_switch

begin_return
return|return
name|false
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|Derived
operator|>
name|bool
name|RecursiveASTVisitorImpl
operator|<
name|Derived
operator|>
operator|::
name|VisitNestedNameSpecifier
argument_list|(
argument|NestedNameSpecifier *NNS
argument_list|)
block|{
if|if
condition|(
name|NNS
operator|->
name|getPrefix
argument_list|()
operator|&&
name|getDerived
argument_list|()
operator|.
name|VisitNestedNameSpecifier
argument_list|(
name|NNS
operator|->
name|getPrefix
argument_list|()
argument_list|)
condition|)
return|return
name|true
return|;
end_expr_stmt

begin_switch
switch|switch
condition|(
name|NNS
operator|->
name|getKind
argument_list|()
condition|)
block|{
case|case
name|NestedNameSpecifier
operator|::
name|Identifier
case|:
case|case
name|NestedNameSpecifier
operator|::
name|Namespace
case|:
case|case
name|NestedNameSpecifier
operator|::
name|Global
case|:
return|return
name|false
return|;
case|case
name|NestedNameSpecifier
operator|::
name|TypeSpec
case|:
case|case
name|NestedNameSpecifier
operator|::
name|TypeSpecWithTemplate
case|:
return|return
name|Visit
argument_list|(
name|QualType
argument_list|(
name|NNS
operator|->
name|getAsType
argument_list|()
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
block|}
end_switch

begin_return
return|return
name|false
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|Derived
operator|>
name|bool
name|RecursiveASTVisitorImpl
operator|<
name|Derived
operator|>
operator|::
name|VisitTemplateName
argument_list|(
argument|TemplateName Template
argument_list|)
block|{
if|if
condition|(
name|DependentTemplateName
modifier|*
name|DTN
init|=
name|Template
operator|.
name|getAsDependentTemplateName
argument_list|()
condition|)
return|return
name|DTN
operator|->
name|getQualifier
argument_list|()
operator|&&
name|getDerived
argument_list|()
operator|.
name|VisitNestedNameSpecifier
argument_list|(
name|DTN
operator|->
name|getQualifier
argument_list|()
argument_list|)
return|;
end_expr_stmt

begin_if
if|if
condition|(
name|QualifiedTemplateName
modifier|*
name|QTN
init|=
name|Template
operator|.
name|getAsQualifiedTemplateName
argument_list|()
condition|)
return|return
name|getDerived
argument_list|()
operator|.
name|VisitNestedNameSpecifier
argument_list|(
name|QTN
operator|->
name|getQualifier
argument_list|()
argument_list|)
return|;
end_if

begin_return
return|return
name|false
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|Derived
operator|>
name|bool
name|RecursiveASTVisitorImpl
operator|<
name|Derived
operator|>
operator|::
name|VisitTemplateArgument
argument_list|(
argument|const TemplateArgument&Arg
argument_list|)
block|{
switch|switch
condition|(
name|Arg
operator|.
name|getKind
argument_list|()
condition|)
block|{
case|case
name|TemplateArgument
operator|::
name|Null
case|:
case|case
name|TemplateArgument
operator|::
name|Declaration
case|:
case|case
name|TemplateArgument
operator|::
name|Integral
case|:
return|return
name|false
return|;
case|case
name|TemplateArgument
operator|::
name|Type
case|:
return|return
name|Visit
argument_list|(
name|Arg
operator|.
name|getAsType
argument_list|()
argument_list|)
return|;
case|case
name|TemplateArgument
operator|::
name|Template
case|:
return|return
name|getDerived
argument_list|()
operator|.
name|VisitTemplateName
argument_list|(
name|Arg
operator|.
name|getAsTemplate
argument_list|()
argument_list|)
return|;
case|case
name|TemplateArgument
operator|::
name|Expression
case|:
return|return
name|getDerived
argument_list|()
operator|.
name|Visit
argument_list|(
name|Arg
operator|.
name|getAsExpr
argument_list|()
argument_list|)
return|;
case|case
name|TemplateArgument
operator|::
name|Pack
case|:
return|return
name|getDerived
argument_list|()
operator|.
name|VisitTemplateArguments
argument_list|(
name|Arg
operator|.
name|pack_begin
argument_list|()
argument_list|,
name|Arg
operator|.
name|pack_size
argument_list|()
argument_list|)
return|;
block|}
end_expr_stmt

begin_return
return|return
name|false
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|Derived
operator|>
name|bool
name|RecursiveASTVisitorImpl
operator|<
name|Derived
operator|>
operator|::
name|VisitTemplateArguments
argument_list|(
argument|const TemplateArgument *Args
argument_list|,
argument|unsigned NumArgs
argument_list|)
block|{
for|for
control|(
name|unsigned
name|I
init|=
literal|0
init|;
name|I
operator|!=
name|NumArgs
condition|;
operator|++
name|I
control|)
if|if
condition|(
name|getDerived
argument_list|()
operator|.
name|VisitTemplateArgument
argument_list|(
name|Args
index|[
name|I
index|]
argument_list|)
condition|)
return|return
name|true
return|;
end_expr_stmt

begin_return
return|return
name|false
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|Derived
operator|>
name|bool
name|RecursiveASTVisitorImpl
operator|<
name|Derived
operator|>
operator|::
name|VisitStmt
argument_list|(
argument|Stmt *Node
argument_list|)
block|{
for|for
control|(
name|Stmt
operator|::
name|child_iterator
name|C
operator|=
name|Node
operator|->
name|child_begin
argument_list|()
operator|,
name|CEnd
operator|=
name|Node
operator|->
name|child_end
argument_list|()
init|;
name|C
operator|!=
name|CEnd
condition|;
operator|++
name|C
control|)
block|{
if|if
condition|(
name|Visit
argument_list|(
operator|*
name|C
argument_list|)
condition|)
return|return
name|true
return|;
block|}
end_expr_stmt

begin_return
return|return
name|false
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|Derived
operator|>
name|bool
name|RecursiveASTVisitorImpl
operator|<
name|Derived
operator|>
operator|::
name|VisitType
argument_list|(
argument|Type *T
argument_list|)
block|{
return|return
name|false
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|Derived
operator|>
name|bool
name|RecursiveASTVisitorImpl
operator|<
name|Derived
operator|>
operator|::
name|VisitBuiltinType
argument_list|(
argument|BuiltinType *T
argument_list|)
block|{
return|return
name|getDerived
argument_list|()
operator|.
name|VisitType
argument_list|(
name|T
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|Derived
operator|>
name|bool
name|RecursiveASTVisitorImpl
operator|<
name|Derived
operator|>
operator|::
name|VisitComplexType
argument_list|(
argument|ComplexType *T
argument_list|)
block|{
if|if
condition|(
name|Visit
argument_list|(
name|T
operator|->
name|getElementType
argument_list|()
argument_list|)
condition|)
return|return
name|true
return|;
end_expr_stmt

begin_return
return|return
name|getDerived
argument_list|()
operator|.
name|VisitType
argument_list|(
name|T
argument_list|)
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|Derived
operator|>
name|bool
name|RecursiveASTVisitorImpl
operator|<
name|Derived
operator|>
operator|::
name|VisitPointerType
argument_list|(
argument|PointerType *T
argument_list|)
block|{
if|if
condition|(
name|Visit
argument_list|(
name|T
operator|->
name|getPointeeType
argument_list|()
argument_list|)
condition|)
return|return
name|true
return|;
end_expr_stmt

begin_return
return|return
name|getDerived
argument_list|()
operator|.
name|VisitType
argument_list|(
name|T
argument_list|)
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|Derived
operator|>
name|bool
name|RecursiveASTVisitorImpl
operator|<
name|Derived
operator|>
operator|::
name|VisitBlockPointerType
argument_list|(
argument|BlockPointerType *T
argument_list|)
block|{
if|if
condition|(
name|Visit
argument_list|(
name|T
operator|->
name|getPointeeType
argument_list|()
argument_list|)
condition|)
return|return
name|true
return|;
end_expr_stmt

begin_return
return|return
name|getDerived
argument_list|()
operator|.
name|VisitType
argument_list|(
name|T
argument_list|)
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|Derived
operator|>
name|bool
name|RecursiveASTVisitorImpl
operator|<
name|Derived
operator|>
operator|::
name|VisitReferenceType
argument_list|(
argument|ReferenceType *T
argument_list|)
block|{
if|if
condition|(
name|Visit
argument_list|(
name|T
operator|->
name|getPointeeType
argument_list|()
argument_list|)
condition|)
return|return
name|true
return|;
end_expr_stmt

begin_return
return|return
name|getDerived
argument_list|()
operator|.
name|VisitType
argument_list|(
name|T
argument_list|)
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|Derived
operator|>
name|bool
name|RecursiveASTVisitorImpl
operator|<
name|Derived
operator|>
operator|::
name|VisitLValueReferenceType
argument_list|(
argument|LValueReferenceType *T
argument_list|)
block|{
return|return
name|getDerived
argument_list|()
operator|.
name|VisitReferenceType
argument_list|(
name|T
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|Derived
operator|>
name|bool
name|RecursiveASTVisitorImpl
operator|<
name|Derived
operator|>
operator|::
name|VisitRValueReferenceType
argument_list|(
argument|RValueReferenceType *T
argument_list|)
block|{
return|return
name|getDerived
argument_list|()
operator|.
name|VisitReferenceType
argument_list|(
name|T
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|Derived
operator|>
name|bool
name|RecursiveASTVisitorImpl
operator|<
name|Derived
operator|>
operator|::
name|VisitMemberPointerType
argument_list|(
argument|MemberPointerType *T
argument_list|)
block|{
if|if
condition|(
name|Visit
argument_list|(
name|QualType
argument_list|(
name|T
operator|->
name|getClass
argument_list|()
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|||
name|Visit
argument_list|(
name|T
operator|->
name|getPointeeType
argument_list|()
argument_list|)
condition|)
return|return
name|true
return|;
end_expr_stmt

begin_return
return|return
name|getDerived
argument_list|()
operator|.
name|VisitType
argument_list|(
name|T
argument_list|)
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|Derived
operator|>
name|bool
name|RecursiveASTVisitorImpl
operator|<
name|Derived
operator|>
operator|::
name|VisitArrayType
argument_list|(
argument|ArrayType *T
argument_list|)
block|{
if|if
condition|(
name|Visit
argument_list|(
name|T
operator|->
name|getElementType
argument_list|()
argument_list|)
condition|)
return|return
name|true
return|;
end_expr_stmt

begin_return
return|return
name|getDerived
argument_list|()
operator|.
name|VisitType
argument_list|(
name|T
argument_list|)
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|Derived
operator|>
name|bool
name|RecursiveASTVisitorImpl
operator|<
name|Derived
operator|>
operator|::
name|VisitConstantArrayType
argument_list|(
argument|ConstantArrayType *T
argument_list|)
block|{
return|return
name|getDerived
argument_list|()
operator|.
name|VisitArrayType
argument_list|(
name|T
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|Derived
operator|>
name|bool
name|RecursiveASTVisitorImpl
operator|<
name|Derived
operator|>
operator|::
name|VisitIncompleteArrayType
argument_list|(
argument|IncompleteArrayType *T
argument_list|)
block|{
return|return
name|getDerived
argument_list|()
operator|.
name|VisitArrayType
argument_list|(
name|T
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|Derived
operator|>
name|bool
name|RecursiveASTVisitorImpl
operator|<
name|Derived
operator|>
operator|::
name|VisitVariableArrayType
argument_list|(
argument|VariableArrayType *T
argument_list|)
block|{
if|if
condition|(
name|Visit
argument_list|(
name|T
operator|->
name|getSizeExpr
argument_list|()
argument_list|)
condition|)
return|return
name|true
return|;
end_expr_stmt

begin_return
return|return
name|getDerived
argument_list|()
operator|.
name|VisitArrayType
argument_list|(
name|T
argument_list|)
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|Derived
operator|>
name|bool
name|RecursiveASTVisitorImpl
operator|<
name|Derived
operator|>
operator|::
name|VisitDependentSizedArrayType
argument_list|(
argument|DependentSizedArrayType *T
argument_list|)
block|{
if|if
condition|(
name|T
operator|->
name|getSizeExpr
argument_list|()
operator|&&
name|Visit
argument_list|(
name|T
operator|->
name|getSizeExpr
argument_list|()
argument_list|)
condition|)
return|return
name|true
return|;
end_expr_stmt

begin_return
return|return
name|getDerived
argument_list|()
operator|.
name|VisitArrayType
argument_list|(
name|T
argument_list|)
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|Derived
operator|>
name|bool
name|RecursiveASTVisitorImpl
operator|<
name|Derived
operator|>
operator|::
name|VisitDependentSizedExtVectorType
argument_list|(
argument|DependentSizedExtVectorType *T
argument_list|)
block|{
if|if
condition|(
operator|(
name|T
operator|->
name|getSizeExpr
argument_list|()
operator|&&
name|Visit
argument_list|(
name|T
operator|->
name|getSizeExpr
argument_list|()
argument_list|)
operator|)
operator|||
name|Visit
argument_list|(
name|T
operator|->
name|getElementType
argument_list|()
argument_list|)
condition|)
return|return
name|true
return|;
end_expr_stmt

begin_return
return|return
name|getDerived
argument_list|()
operator|.
name|VisitType
argument_list|(
name|T
argument_list|)
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|Derived
operator|>
name|bool
name|RecursiveASTVisitorImpl
operator|<
name|Derived
operator|>
operator|::
name|VisitVectorType
argument_list|(
argument|VectorType *T
argument_list|)
block|{
if|if
condition|(
name|Visit
argument_list|(
name|T
operator|->
name|getElementType
argument_list|()
argument_list|)
condition|)
return|return
name|true
return|;
end_expr_stmt

begin_return
return|return
name|getDerived
argument_list|()
operator|.
name|VisitType
argument_list|(
name|T
argument_list|)
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|Derived
operator|>
name|bool
name|RecursiveASTVisitorImpl
operator|<
name|Derived
operator|>
operator|::
name|VisitExtVectorType
argument_list|(
argument|ExtVectorType *T
argument_list|)
block|{
return|return
name|getDerived
argument_list|()
operator|.
name|VisitVectorType
argument_list|(
name|T
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|Derived
operator|>
name|bool
name|RecursiveASTVisitorImpl
operator|<
name|Derived
operator|>
operator|::
name|VisitFunctionType
argument_list|(
argument|FunctionType *T
argument_list|)
block|{
if|if
condition|(
name|Visit
argument_list|(
name|T
operator|->
name|getResultType
argument_list|()
argument_list|)
condition|)
return|return
name|true
return|;
end_expr_stmt

begin_return
return|return
name|getDerived
argument_list|()
operator|.
name|VisitType
argument_list|(
name|T
argument_list|)
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|Derived
operator|>
name|bool
name|RecursiveASTVisitorImpl
operator|<
name|Derived
operator|>
operator|::
name|VisitFunctionNoProtoType
argument_list|(
argument|FunctionNoProtoType *T
argument_list|)
block|{
return|return
name|getDerived
argument_list|()
operator|.
name|VisitFunctionType
argument_list|(
name|T
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|Derived
operator|>
name|bool
name|RecursiveASTVisitorImpl
operator|<
name|Derived
operator|>
operator|::
name|VisitFunctionProtoType
argument_list|(
argument|FunctionProtoType *T
argument_list|)
block|{
for|for
control|(
name|FunctionProtoType
operator|::
name|arg_type_iterator
name|A
operator|=
name|T
operator|->
name|arg_type_begin
argument_list|()
operator|,
name|AEnd
operator|=
name|T
operator|->
name|arg_type_end
argument_list|()
init|;
name|A
operator|!=
name|AEnd
condition|;
operator|++
name|A
control|)
block|{
if|if
condition|(
name|Visit
argument_list|(
operator|*
name|A
argument_list|)
condition|)
return|return
name|true
return|;
block|}
end_expr_stmt

begin_for
for|for
control|(
name|FunctionProtoType
operator|::
name|exception_iterator
name|E
operator|=
name|T
operator|->
name|exception_begin
argument_list|()
operator|,
name|EEnd
operator|=
name|T
operator|->
name|exception_end
argument_list|()
init|;
name|E
operator|!=
name|EEnd
condition|;
operator|++
name|E
control|)
block|{
if|if
condition|(
name|Visit
argument_list|(
operator|*
name|E
argument_list|)
condition|)
return|return
name|true
return|;
block|}
end_for

begin_return
return|return
name|getDerived
argument_list|()
operator|.
name|VisitFunctionType
argument_list|(
name|T
argument_list|)
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|Derived
operator|>
name|bool
name|RecursiveASTVisitorImpl
operator|<
name|Derived
operator|>
operator|::
name|VisitUnresolvedUsingType
argument_list|(
argument|UnresolvedUsingType *T
argument_list|)
block|{
return|return
name|getDerived
argument_list|()
operator|.
name|VisitType
argument_list|(
name|T
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|Derived
operator|>
name|bool
name|RecursiveASTVisitorImpl
operator|<
name|Derived
operator|>
operator|::
name|VisitTypedefType
argument_list|(
argument|TypedefType *T
argument_list|)
block|{
return|return
name|getDerived
argument_list|()
operator|.
name|VisitType
argument_list|(
name|T
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|Derived
operator|>
name|bool
name|RecursiveASTVisitorImpl
operator|<
name|Derived
operator|>
operator|::
name|VisitTypeOfExprType
argument_list|(
argument|TypeOfExprType *T
argument_list|)
block|{
if|if
condition|(
name|Visit
argument_list|(
name|T
operator|->
name|getUnderlyingExpr
argument_list|()
argument_list|)
condition|)
return|return
name|true
return|;
end_expr_stmt

begin_return
return|return
name|getDerived
argument_list|()
operator|.
name|VisitType
argument_list|(
name|T
argument_list|)
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|Derived
operator|>
name|bool
name|RecursiveASTVisitorImpl
operator|<
name|Derived
operator|>
operator|::
name|VisitTypeOfType
argument_list|(
argument|TypeOfType *T
argument_list|)
block|{
if|if
condition|(
name|Visit
argument_list|(
name|T
operator|->
name|getUnderlyingType
argument_list|()
argument_list|)
condition|)
return|return
name|true
return|;
end_expr_stmt

begin_return
return|return
name|getDerived
argument_list|()
operator|.
name|VisitType
argument_list|(
name|T
argument_list|)
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|Derived
operator|>
name|bool
name|RecursiveASTVisitorImpl
operator|<
name|Derived
operator|>
operator|::
name|VisitDecltypeType
argument_list|(
argument|DecltypeType *T
argument_list|)
block|{
if|if
condition|(
name|Visit
argument_list|(
name|T
operator|->
name|getUnderlyingExpr
argument_list|()
argument_list|)
condition|)
return|return
name|true
return|;
end_expr_stmt

begin_return
return|return
name|getDerived
argument_list|()
operator|.
name|VisitType
argument_list|(
name|T
argument_list|)
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|Derived
operator|>
name|bool
name|RecursiveASTVisitorImpl
operator|<
name|Derived
operator|>
operator|::
name|VisitTagType
argument_list|(
argument|TagType *T
argument_list|)
block|{
return|return
name|getDerived
argument_list|()
operator|.
name|VisitType
argument_list|(
name|T
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|Derived
operator|>
name|bool
name|RecursiveASTVisitorImpl
operator|<
name|Derived
operator|>
operator|::
name|VisitRecordType
argument_list|(
argument|RecordType *T
argument_list|)
block|{
return|return
name|getDerived
argument_list|()
operator|.
name|VisitTagType
argument_list|(
name|T
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|Derived
operator|>
name|bool
name|RecursiveASTVisitorImpl
operator|<
name|Derived
operator|>
operator|::
name|VisitEnumType
argument_list|(
argument|EnumType *T
argument_list|)
block|{
return|return
name|getDerived
argument_list|()
operator|.
name|VisitType
argument_list|(
name|T
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|Derived
operator|>
name|bool
name|RecursiveASTVisitorImpl
operator|<
name|Derived
operator|>
operator|::
name|VisitTemplateTypeParmType
argument_list|(
argument|TemplateTypeParmType *T
argument_list|)
block|{
return|return
name|getDerived
argument_list|()
operator|.
name|VisitType
argument_list|(
name|T
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|Derived
operator|>
name|bool
name|RecursiveASTVisitorImpl
operator|<
name|Derived
operator|>
operator|::
name|VisitSubstTemplateTypeParmType
argument_list|(
argument|SubstTemplateTypeParmType *T
argument_list|)
block|{
return|return
name|getDerived
argument_list|()
operator|.
name|VisitType
argument_list|(
name|T
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|Derived
operator|>
name|bool
name|RecursiveASTVisitorImpl
operator|<
name|Derived
operator|>
operator|::
name|VisitTemplateSpecializationType
argument_list|(
argument|TemplateSpecializationType *T
argument_list|)
block|{
if|if
condition|(
name|getDerived
argument_list|()
operator|.
name|VisitTemplateName
argument_list|(
name|T
operator|->
name|getTemplateName
argument_list|()
argument_list|)
operator|||
name|getDerived
argument_list|()
operator|.
name|VisitTemplateArguments
argument_list|(
name|T
operator|->
name|getArgs
argument_list|()
argument_list|,
name|T
operator|->
name|getNumArgs
argument_list|()
argument_list|)
condition|)
return|return
name|true
return|;
end_expr_stmt

begin_return
return|return
name|getDerived
argument_list|()
operator|.
name|VisitType
argument_list|(
name|T
argument_list|)
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|Derived
operator|>
name|bool
name|RecursiveASTVisitorImpl
operator|<
name|Derived
operator|>
operator|::
name|VisitInjectedClassNameType
argument_list|(
argument|InjectedClassNameType *T
argument_list|)
block|{
return|return
name|getDerived
argument_list|()
operator|.
name|VisitType
argument_list|(
name|T
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|Derived
operator|>
name|bool
name|RecursiveASTVisitorImpl
operator|<
name|Derived
operator|>
operator|::
name|VisitElaboratedType
argument_list|(
argument|ElaboratedType *T
argument_list|)
block|{
if|if
condition|(
name|T
operator|->
name|getQualifier
argument_list|()
operator|&&
name|getDerived
argument_list|()
operator|.
name|VisitNestedNameSpecifier
argument_list|(
name|T
operator|->
name|getQualifier
argument_list|()
argument_list|)
condition|)
return|return
name|true
return|;
end_expr_stmt

begin_if
if|if
condition|(
name|Visit
argument_list|(
name|T
operator|->
name|getNamedType
argument_list|()
argument_list|)
condition|)
return|return
name|true
return|;
end_if

begin_return
return|return
name|getDerived
argument_list|()
operator|.
name|VisitType
argument_list|(
name|T
argument_list|)
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|Derived
operator|>
name|bool
name|RecursiveASTVisitorImpl
operator|<
name|Derived
operator|>
operator|::
name|VisitDependentNameType
argument_list|(
argument|DependentNameType *T
argument_list|)
block|{
if|if
condition|(
name|T
operator|->
name|getQualifier
argument_list|()
operator|&&
name|getDerived
argument_list|()
operator|.
name|VisitNestedNameSpecifier
argument_list|(
name|T
operator|->
name|getQualifier
argument_list|()
argument_list|)
condition|)
return|return
name|true
return|;
end_expr_stmt

begin_if
if|if
condition|(
name|T
operator|->
name|getTemplateId
argument_list|()
operator|&&
name|getDerived
argument_list|()
operator|.
name|VisitTemplateSpecializationType
argument_list|(
name|const_cast
operator|<
name|TemplateSpecializationType
operator|*
operator|>
operator|(
name|T
operator|->
name|getTemplateId
argument_list|()
operator|)
argument_list|)
condition|)
return|return
name|true
return|;
end_if

begin_return
return|return
name|getDerived
argument_list|()
operator|.
name|VisitType
argument_list|(
name|T
argument_list|)
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|Derived
operator|>
name|bool
name|RecursiveASTVisitorImpl
operator|<
name|Derived
operator|>
operator|::
name|VisitObjCInterfaceType
argument_list|(
argument|ObjCInterfaceType *T
argument_list|)
block|{
return|return
name|getDerived
argument_list|()
operator|.
name|VisitObjCObjectType
argument_list|(
name|T
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|Derived
operator|>
name|bool
name|RecursiveASTVisitorImpl
operator|<
name|Derived
operator|>
operator|::
name|VisitObjCObjectType
argument_list|(
argument|ObjCObjectType *T
argument_list|)
block|{
comment|// We have to watch out here because an ObjCInterfaceType's base
comment|// type is itself.
if|if
condition|(
name|T
operator|->
name|getBaseType
argument_list|()
operator|.
name|getTypePtr
argument_list|()
operator|!=
name|T
condition|)
if|if
condition|(
name|Visit
argument_list|(
name|T
operator|->
name|getBaseType
argument_list|()
argument_list|)
condition|)
return|return
name|true
return|;
end_expr_stmt

begin_return
return|return
name|getDerived
argument_list|()
operator|.
name|VisitType
argument_list|(
name|T
argument_list|)
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|Derived
operator|>
name|bool
name|RecursiveASTVisitorImpl
operator|<
name|Derived
operator|>
operator|::
name|VisitObjCObjectPointerType
argument_list|(
argument|ObjCObjectPointerType *T
argument_list|)
block|{
if|if
condition|(
name|Visit
argument_list|(
name|T
operator|->
name|getPointeeType
argument_list|()
argument_list|)
condition|)
return|return
name|true
return|;
end_expr_stmt

begin_return
return|return
name|getDerived
argument_list|()
operator|.
name|VisitType
argument_list|(
name|T
argument_list|)
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|Derived
operator|>
name|bool
name|RecursiveASTVisitorImpl
operator|<
name|Derived
operator|>
operator|::
name|VisitDecl
argument_list|(
argument|Decl *D
argument_list|)
block|{
if|if
condition|(
name|DeclContext
modifier|*
name|DC
init|=
name|dyn_cast
operator|<
name|DeclContext
operator|>
operator|(
name|D
operator|)
condition|)
block|{
for|for
control|(
name|DeclContext
operator|::
name|decl_iterator
name|Child
operator|=
name|DC
operator|->
name|decls_begin
argument_list|()
operator|,
name|ChildEnd
operator|=
name|DC
operator|->
name|decls_end
argument_list|()
init|;
name|Child
operator|!=
name|ChildEnd
condition|;
operator|++
name|Child
control|)
if|if
condition|(
name|Visit
argument_list|(
operator|*
name|Child
argument_list|)
condition|)
return|return
name|true
return|;
return|return
name|false
return|;
block|}
end_expr_stmt

begin_return
return|return
name|false
return|;
end_return

begin_comment
unit|}
comment|/// \brief A visitor that recursively walks the entire Clang AST.
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|/// Clients of this visitor should subclass the visitor (providing
end_comment

begin_comment
comment|/// themselves as the template argument, using the curiously
end_comment

begin_comment
comment|/// recurring template pattern) and override any of the Visit*
end_comment

begin_comment
comment|/// methods (except Visit()) for declaration, type, statement,
end_comment

begin_comment
comment|/// expression, or other AST nodes where the visitor should customize
end_comment

begin_comment
comment|/// behavior. Returning "true" from one of these overridden functions
end_comment

begin_comment
comment|/// will abort the entire traversal.  An overridden Visit* method
end_comment

begin_comment
comment|/// will not descend further into the AST for that node unless
end_comment

begin_comment
comment|/// Base::Visit* is called.
end_comment

begin_expr_stmt
unit|template
operator|<
name|typename
name|Derived
operator|>
name|class
name|RecursiveASTVisitor
operator|:
name|public
name|RecursiveASTVisitorImpl
operator|<
name|Derived
operator|>
block|{
typedef|typedef
name|RecursiveASTVisitorImpl
operator|<
name|Derived
operator|>
name|Impl
expr_stmt|;
name|public
operator|:
end_expr_stmt

begin_typedef
typedef|typedef
name|RecursiveASTVisitor
operator|<
name|Derived
operator|>
name|Base
expr_stmt|;
end_typedef

begin_function_decl
name|bool
name|VisitDeclaratorDecl
parameter_list|(
name|DeclaratorDecl
modifier|*
name|D
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|bool
name|VisitFunctionDecl
parameter_list|(
name|FunctionDecl
modifier|*
name|D
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|bool
name|VisitVarDecl
parameter_list|(
name|VarDecl
modifier|*
name|D
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|bool
name|VisitBlockDecl
parameter_list|(
name|BlockDecl
modifier|*
name|D
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|bool
name|VisitDeclStmt
parameter_list|(
name|DeclStmt
modifier|*
name|S
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|bool
name|VisitFunctionType
parameter_list|(
name|FunctionType
modifier|*
name|F
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|bool
name|VisitFunctionProtoType
parameter_list|(
name|FunctionProtoType
modifier|*
name|F
parameter_list|)
function_decl|;
end_function_decl

begin_define
unit|};
define|#
directive|define
name|DEFINE_VISIT
parameter_list|(
name|Type
parameter_list|,
name|Name
parameter_list|,
name|Statement
parameter_list|)
define|\
value|template<typename Derived>                                      \   bool RecursiveASTVisitor<Derived>::Visit ## Type (Type *Name) { \     if (Impl::Visit ## Type (Name)) return true;                  \     { Statement; }                                                \     return false;                                                 \   }
end_define

begin_macro
name|DEFINE_VISIT
argument_list|(
argument|DeclaratorDecl
argument_list|,
argument|D
argument_list|,
argument|{     if (TypeSourceInfo *TInfo = D->getTypeSourceInfo())       return this->Visit(TInfo->getType());   }
argument_list|)
end_macro

begin_macro
name|DEFINE_VISIT
argument_list|(
argument|FunctionDecl
argument_list|,
argument|D
argument_list|,
argument|{     if (D->isThisDeclarationADefinition())       return this->Visit(D->getBody());   }
argument_list|)
end_macro

begin_macro
name|DEFINE_VISIT
argument_list|(
argument|VarDecl
argument_list|,
argument|D
argument_list|,
argument|return this->Visit(D->getInit())
argument_list|)
end_macro

begin_macro
name|DEFINE_VISIT
argument_list|(
argument|BlockDecl
argument_list|,
argument|D
argument_list|,
argument|return this->Visit(D->getBody())
argument_list|)
end_macro

begin_macro
name|DEFINE_VISIT
argument_list|(
argument|DeclStmt
argument_list|,
argument|S
argument_list|,
argument|{     for (DeclStmt::decl_iterator I = S->decl_begin(), E = S->decl_end();          I != E; ++I) {       if (this->Visit(*I))         return true;     }   }
argument_list|)
end_macro

begin_comment
comment|// FunctionType is the common base class of FunctionNoProtoType (a
end_comment

begin_comment
comment|// K&R-style function declaration that has no information about
end_comment

begin_comment
comment|// its arguments) and FunctionProtoType.
end_comment

begin_macro
name|DEFINE_VISIT
argument_list|(
argument|FunctionType
argument_list|,
argument|F
argument_list|,
argument|return this->Visit(F->getResultType())
argument_list|)
end_macro

begin_macro
name|DEFINE_VISIT
argument_list|(
argument|FunctionProtoType
argument_list|,
argument|F
argument_list|,
argument|{     for (unsigned i =
literal|0
argument|; i != F->getNumArgs(); ++i) {       if (this->Visit(F->getArgType(i)))         return true;     }     for (unsigned i =
literal|0
argument|; i != F->getNumExceptions(); ++i) {       if (this->Visit(F->getExceptionType(i)))         return true;     }   }
argument_list|)
end_macro

begin_undef
undef|#
directive|undef
name|DEFINE_VISIT
end_undef

begin_undef
undef|#
directive|undef
name|DISPATCH
end_undef

begin_comment
unit|}
comment|// end namespace clang
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|// LLVM_CLANG_AST_RECURSIVEASTVISITOR_H
end_comment

end_unit

