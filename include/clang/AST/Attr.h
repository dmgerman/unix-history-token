begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===--- Attr.h - Classes for representing expressions ----------*- C++ -*-===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//  This file defines the Attr interface and subclasses.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LLVM_CLANG_AST_ATTR_H
end_ifndef

begin_define
define|#
directive|define
name|LLVM_CLANG_AST_ATTR_H
end_define

begin_include
include|#
directive|include
file|"llvm/Support/Casting.h"
end_include

begin_expr_stmt
name|using
name|llvm
operator|::
name|dyn_cast
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<cassert>
end_include

begin_include
include|#
directive|include
file|<cstring>
end_include

begin_include
include|#
directive|include
file|<string>
end_include

begin_include
include|#
directive|include
file|<algorithm>
end_include

begin_decl_stmt
name|namespace
name|clang
block|{
name|class
name|ASTContext
decl_stmt|;
block|}
end_decl_stmt

begin_comment
comment|// Defined in ASTContext.h
end_comment

begin_decl_stmt
name|void
modifier|*
name|operator
name|new
argument_list|(
name|size_t
name|Bytes
argument_list|,
name|clang
operator|::
name|ASTContext
operator|&
name|C
argument_list|,
name|size_t
name|Alignment
operator|=
literal|16
argument_list|)
name|throw
argument_list|()
decl_stmt|;
end_decl_stmt

begin_comment
comment|// It is good practice to pair new/delete operators.  Also, MSVC gives many
end_comment

begin_comment
comment|// warnings if a matching delete overload is not declared, even though the
end_comment

begin_comment
comment|// throw() spec guarantees it will not be implicitly called.
end_comment

begin_decl_stmt
name|void
name|operator
name|delete
argument_list|(
name|void
operator|*
name|Ptr
argument_list|,
name|clang
operator|::
name|ASTContext
operator|&
name|C
argument_list|,
name|size_t
argument_list|)
name|throw
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|namespace
name|clang
block|{
comment|/// Attr - This represents one attribute.
name|class
name|Attr
block|{
name|public
label|:
enum|enum
name|Kind
block|{
name|Alias
block|,
name|Aligned
block|,
name|AlwaysInline
block|,
name|AnalyzerNoReturn
block|,
comment|// Clang-specific.
name|Annotate
block|,
name|AsmLabel
block|,
comment|// Represent GCC asm label extension.
name|Blocks
block|,
name|Cleanup
block|,
name|Const
block|,
name|Constructor
block|,
name|DLLExport
block|,
name|DLLImport
block|,
name|Deprecated
block|,
name|Destructor
block|,
name|FastCall
block|,
name|Format
block|,
name|FormatArg
block|,
name|GNUInline
block|,
name|IBOutletKind
block|,
comment|// Clang-specific.  Use "Kind" suffix to not conflict with
name|Malloc
block|,
name|NoDebug
block|,
name|NoInline
block|,
name|NonNull
block|,
name|NoReturn
block|,
name|NoThrow
block|,
name|ObjCException
block|,
name|ObjCNSObject
block|,
name|CFReturnsRetained
block|,
comment|// Clang/Checker-specific.
name|NSReturnsRetained
block|,
comment|// Clang/Checker-specific.
name|Overloadable
block|,
comment|// Clang-specific
name|Packed
block|,
name|PragmaPack
block|,
name|Pure
block|,
name|Regparm
block|,
name|ReqdWorkGroupSize
block|,
comment|// OpenCL-specific
name|Section
block|,
name|Sentinel
block|,
name|StdCall
block|,
name|TransparentUnion
block|,
name|Unavailable
block|,
name|Unused
block|,
name|Used
block|,
name|Visibility
block|,
name|WarnUnusedResult
block|,
name|Weak
block|,
name|WeakImport
block|}
enum|;
name|private
label|:
name|Attr
modifier|*
name|Next
decl_stmt|;
name|Kind
name|AttrKind
decl_stmt|;
name|bool
name|Inherited
range|:
literal|1
decl_stmt|;
name|protected
label|:
name|void
modifier|*
name|operator
name|new
parameter_list|(
name|size_t
name|bytes
parameter_list|)
function|throw
parameter_list|()
block|{
name|assert
argument_list|(
literal|0
operator|&&
literal|"Attrs cannot be allocated with regular 'new'."
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|void
name|operator
name|delete
parameter_list|(
name|void
modifier|*
name|data
parameter_list|)
function|throw
parameter_list|()
block|{
name|assert
argument_list|(
literal|0
operator|&&
literal|"Attrs cannot be released with regular 'delete'."
argument_list|)
expr_stmt|;
block|}
name|protected
label|:
name|Attr
argument_list|(
argument|Kind AK
argument_list|)
block|:
name|Next
argument_list|(
literal|0
argument_list|)
operator|,
name|AttrKind
argument_list|(
name|AK
argument_list|)
operator|,
name|Inherited
argument_list|(
argument|false
argument_list|)
block|{}
name|virtual
operator|~
name|Attr
argument_list|()
block|{
name|assert
argument_list|(
name|Next
operator|==
literal|0
operator|&&
literal|"Destroy didn't work"
argument_list|)
block|;   }
name|public
operator|:
name|void
name|Destroy
argument_list|(
name|ASTContext
operator|&
name|C
argument_list|)
expr_stmt|;
comment|/// \brief Whether this attribute should be merged to new
comment|/// declarations.
name|virtual
name|bool
name|isMerged
argument_list|()
specifier|const
block|{
return|return
name|true
return|;
block|}
name|Kind
name|getKind
argument_list|()
specifier|const
block|{
return|return
name|AttrKind
return|;
block|}
name|Attr
modifier|*
name|getNext
parameter_list|()
block|{
return|return
name|Next
return|;
block|}
specifier|const
name|Attr
operator|*
name|getNext
argument_list|()
specifier|const
block|{
return|return
name|Next
return|;
block|}
name|void
name|setNext
parameter_list|(
name|Attr
modifier|*
name|next
parameter_list|)
block|{
name|Next
operator|=
name|next
expr_stmt|;
block|}
name|template
operator|<
name|typename
name|T
operator|>
specifier|const
name|T
operator|*
name|getNext
argument_list|()
specifier|const
block|{
for|for
control|(
specifier|const
name|Attr
modifier|*
name|attr
init|=
name|getNext
argument_list|()
init|;
name|attr
condition|;
name|attr
operator|=
name|attr
operator|->
name|getNext
argument_list|()
control|)
if|if
condition|(
specifier|const
name|T
modifier|*
name|V
init|=
name|dyn_cast
operator|<
name|T
operator|>
operator|(
name|attr
operator|)
condition|)
return|return
name|V
return|;
return|return
literal|0
return|;
block|}
name|bool
name|isInherited
argument_list|()
specifier|const
block|{
return|return
name|Inherited
return|;
block|}
name|void
name|setInherited
parameter_list|(
name|bool
name|value
parameter_list|)
block|{
name|Inherited
operator|=
name|value
expr_stmt|;
block|}
name|void
name|addAttr
parameter_list|(
name|Attr
modifier|*
name|attr
parameter_list|)
block|{
name|assert
argument_list|(
operator|(
name|attr
operator|!=
literal|0
operator|)
operator|&&
literal|"addAttr(): attr is null"
argument_list|)
expr_stmt|;
comment|// FIXME: This doesn't preserve the order in any way.
name|attr
operator|->
name|Next
operator|=
name|Next
expr_stmt|;
name|Next
operator|=
name|attr
expr_stmt|;
block|}
comment|// Clone this attribute.
name|virtual
name|Attr
modifier|*
name|clone
argument_list|(
name|ASTContext
operator|&
name|C
argument_list|)
decl|const
init|=
literal|0
decl_stmt|;
comment|// Implement isa/cast/dyncast/etc.
specifier|static
name|bool
name|classof
parameter_list|(
specifier|const
name|Attr
modifier|*
parameter_list|)
block|{
return|return
name|true
return|;
block|}
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_define
define|#
directive|define
name|DEF_SIMPLE_ATTR
parameter_list|(
name|ATTR
parameter_list|)
define|\
value|class ATTR##Attr : public Attr {                                        \ public:                                                                 \   ATTR##Attr() : Attr(ATTR) {}                                          \   virtual Attr *clone(ASTContext&C) const { return ::new (C) ATTR##Attr; }\   static bool classof(const Attr *A) { return A->getKind() == ATTR; }   \   static bool classof(const ATTR##Attr *A) { return true; }             \ }
end_define

begin_expr_stmt
name|DEF_SIMPLE_ATTR
argument_list|(
name|Packed
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|class
name|PragmaPackAttr
range|:
name|public
name|Attr
block|{
name|unsigned
name|Alignment
block|;
name|public
operator|:
name|PragmaPackAttr
argument_list|(
argument|unsigned alignment
argument_list|)
operator|:
name|Attr
argument_list|(
name|PragmaPack
argument_list|)
block|,
name|Alignment
argument_list|(
argument|alignment
argument_list|)
block|{}
comment|/// getAlignment - The specified alignment in bits.
name|unsigned
name|getAlignment
argument_list|()
specifier|const
block|{
return|return
name|Alignment
return|;
block|}
name|virtual
name|Attr
operator|*
name|clone
argument_list|(
argument|ASTContext&C
argument_list|)
specifier|const
block|{
return|return
operator|::
name|new
argument_list|(
argument|C
argument_list|)
name|PragmaPackAttr
argument_list|(
name|Alignment
argument_list|)
return|;
block|}
comment|// Implement isa/cast/dyncast/etc.
specifier|static
name|bool
name|classof
argument_list|(
argument|const Attr *A
argument_list|)
block|{
return|return
name|A
operator|->
name|getKind
argument_list|()
operator|==
name|PragmaPack
return|;
block|}
specifier|static
name|bool
name|classof
argument_list|(
argument|const PragmaPackAttr *A
argument_list|)
block|{
return|return
name|true
return|;
block|}
expr|}
block|;
name|class
name|AlignedAttr
operator|:
name|public
name|Attr
block|{
name|unsigned
name|Alignment
block|;
name|public
operator|:
name|AlignedAttr
argument_list|(
argument|unsigned alignment
argument_list|)
operator|:
name|Attr
argument_list|(
name|Aligned
argument_list|)
block|,
name|Alignment
argument_list|(
argument|alignment
argument_list|)
block|{}
comment|/// getAlignment - The specified alignment in bits.
name|unsigned
name|getAlignment
argument_list|()
specifier|const
block|{
return|return
name|Alignment
return|;
block|}
name|virtual
name|Attr
operator|*
name|clone
argument_list|(
argument|ASTContext&C
argument_list|)
specifier|const
block|{
return|return
operator|::
name|new
argument_list|(
argument|C
argument_list|)
name|AlignedAttr
argument_list|(
name|Alignment
argument_list|)
return|;
block|}
comment|// Implement isa/cast/dyncast/etc.
specifier|static
name|bool
name|classof
argument_list|(
argument|const Attr *A
argument_list|)
block|{
return|return
name|A
operator|->
name|getKind
argument_list|()
operator|==
name|Aligned
return|;
block|}
specifier|static
name|bool
name|classof
argument_list|(
argument|const AlignedAttr *A
argument_list|)
block|{
return|return
name|true
return|;
block|}
expr|}
block|;
name|class
name|AnnotateAttr
operator|:
name|public
name|Attr
block|{
name|std
operator|::
name|string
name|Annotation
block|;
name|public
operator|:
name|AnnotateAttr
argument_list|(
specifier|const
name|std
operator|::
name|string
operator|&
name|ann
argument_list|)
operator|:
name|Attr
argument_list|(
name|Annotate
argument_list|)
block|,
name|Annotation
argument_list|(
argument|ann
argument_list|)
block|{}
specifier|const
name|std
operator|::
name|string
operator|&
name|getAnnotation
argument_list|()
specifier|const
block|{
return|return
name|Annotation
return|;
block|}
name|virtual
name|Attr
operator|*
name|clone
argument_list|(
argument|ASTContext&C
argument_list|)
specifier|const
block|{
return|return
operator|::
name|new
argument_list|(
argument|C
argument_list|)
name|AnnotateAttr
argument_list|(
name|Annotation
argument_list|)
return|;
block|}
comment|// Implement isa/cast/dyncast/etc.
specifier|static
name|bool
name|classof
argument_list|(
argument|const Attr *A
argument_list|)
block|{
return|return
name|A
operator|->
name|getKind
argument_list|()
operator|==
name|Annotate
return|;
block|}
specifier|static
name|bool
name|classof
argument_list|(
argument|const AnnotateAttr *A
argument_list|)
block|{
return|return
name|true
return|;
block|}
expr|}
block|;
name|class
name|AsmLabelAttr
operator|:
name|public
name|Attr
block|{
name|std
operator|::
name|string
name|Label
block|;
name|public
operator|:
name|AsmLabelAttr
argument_list|(
specifier|const
name|std
operator|::
name|string
operator|&
name|L
argument_list|)
operator|:
name|Attr
argument_list|(
name|AsmLabel
argument_list|)
block|,
name|Label
argument_list|(
argument|L
argument_list|)
block|{}
specifier|const
name|std
operator|::
name|string
operator|&
name|getLabel
argument_list|()
specifier|const
block|{
return|return
name|Label
return|;
block|}
name|virtual
name|Attr
operator|*
name|clone
argument_list|(
argument|ASTContext&C
argument_list|)
specifier|const
block|{
return|return
operator|::
name|new
argument_list|(
argument|C
argument_list|)
name|AsmLabelAttr
argument_list|(
name|Label
argument_list|)
return|;
block|}
comment|// Implement isa/cast/dyncast/etc.
specifier|static
name|bool
name|classof
argument_list|(
argument|const Attr *A
argument_list|)
block|{
return|return
name|A
operator|->
name|getKind
argument_list|()
operator|==
name|AsmLabel
return|;
block|}
specifier|static
name|bool
name|classof
argument_list|(
argument|const AsmLabelAttr *A
argument_list|)
block|{
return|return
name|true
return|;
block|}
expr|}
block|;
name|DEF_SIMPLE_ATTR
argument_list|(
name|AlwaysInline
argument_list|)
block|;
name|class
name|AliasAttr
operator|:
name|public
name|Attr
block|{
name|std
operator|::
name|string
name|Aliasee
block|;
name|public
operator|:
name|AliasAttr
argument_list|(
specifier|const
name|std
operator|::
name|string
operator|&
name|aliasee
argument_list|)
operator|:
name|Attr
argument_list|(
name|Alias
argument_list|)
block|,
name|Aliasee
argument_list|(
argument|aliasee
argument_list|)
block|{}
specifier|const
name|std
operator|::
name|string
operator|&
name|getAliasee
argument_list|()
specifier|const
block|{
return|return
name|Aliasee
return|;
block|}
name|virtual
name|Attr
operator|*
name|clone
argument_list|(
argument|ASTContext&C
argument_list|)
specifier|const
block|{
return|return
operator|::
name|new
argument_list|(
argument|C
argument_list|)
name|AliasAttr
argument_list|(
name|Aliasee
argument_list|)
return|;
block|}
comment|// Implement isa/cast/dyncast/etc.
specifier|static
name|bool
name|classof
argument_list|(
argument|const Attr *A
argument_list|)
block|{
return|return
name|A
operator|->
name|getKind
argument_list|()
operator|==
name|Alias
return|;
block|}
specifier|static
name|bool
name|classof
argument_list|(
argument|const AliasAttr *A
argument_list|)
block|{
return|return
name|true
return|;
block|}
expr|}
block|;
name|class
name|ConstructorAttr
operator|:
name|public
name|Attr
block|{
name|int
name|priority
block|;
name|public
operator|:
name|ConstructorAttr
argument_list|(
argument|int p
argument_list|)
operator|:
name|Attr
argument_list|(
name|Constructor
argument_list|)
block|,
name|priority
argument_list|(
argument|p
argument_list|)
block|{}
name|int
name|getPriority
argument_list|()
specifier|const
block|{
return|return
name|priority
return|;
block|}
name|virtual
name|Attr
operator|*
name|clone
argument_list|(
argument|ASTContext&C
argument_list|)
specifier|const
block|{
return|return
operator|::
name|new
argument_list|(
argument|C
argument_list|)
name|ConstructorAttr
argument_list|(
name|priority
argument_list|)
return|;
block|}
comment|// Implement isa/cast/dyncast/etc.
specifier|static
name|bool
name|classof
argument_list|(
argument|const Attr *A
argument_list|)
block|{
return|return
name|A
operator|->
name|getKind
argument_list|()
operator|==
name|Constructor
return|;
block|}
specifier|static
name|bool
name|classof
argument_list|(
argument|const ConstructorAttr *A
argument_list|)
block|{
return|return
name|true
return|;
block|}
expr|}
block|;
name|class
name|DestructorAttr
operator|:
name|public
name|Attr
block|{
name|int
name|priority
block|;
name|public
operator|:
name|DestructorAttr
argument_list|(
argument|int p
argument_list|)
operator|:
name|Attr
argument_list|(
name|Destructor
argument_list|)
block|,
name|priority
argument_list|(
argument|p
argument_list|)
block|{}
name|int
name|getPriority
argument_list|()
specifier|const
block|{
return|return
name|priority
return|;
block|}
name|virtual
name|Attr
operator|*
name|clone
argument_list|(
argument|ASTContext&C
argument_list|)
specifier|const
block|{
return|return
operator|::
name|new
argument_list|(
argument|C
argument_list|)
name|DestructorAttr
argument_list|(
name|priority
argument_list|)
return|;
block|}
comment|// Implement isa/cast/dyncast/etc.
specifier|static
name|bool
name|classof
argument_list|(
argument|const Attr *A
argument_list|)
block|{
return|return
name|A
operator|->
name|getKind
argument_list|()
operator|==
name|Destructor
return|;
block|}
specifier|static
name|bool
name|classof
argument_list|(
argument|const DestructorAttr *A
argument_list|)
block|{
return|return
name|true
return|;
block|}
expr|}
block|;
name|class
name|GNUInlineAttr
operator|:
name|public
name|Attr
block|{
name|public
operator|:
name|GNUInlineAttr
argument_list|()
operator|:
name|Attr
argument_list|(
argument|GNUInline
argument_list|)
block|{}
name|virtual
name|Attr
operator|*
name|clone
argument_list|(
argument|ASTContext&C
argument_list|)
specifier|const
block|{
return|return
operator|::
name|new
argument_list|(
argument|C
argument_list|)
name|GNUInlineAttr
return|;
block|}
comment|// Implement isa/cast/dyncast/etc.
specifier|static
name|bool
name|classof
argument_list|(
argument|const Attr *A
argument_list|)
block|{
return|return
name|A
operator|->
name|getKind
argument_list|()
operator|==
name|GNUInline
return|;
block|}
specifier|static
name|bool
name|classof
argument_list|(
argument|const GNUInlineAttr *A
argument_list|)
block|{
return|return
name|true
return|;
block|}
expr|}
block|;
name|class
name|IBOutletAttr
operator|:
name|public
name|Attr
block|{
name|public
operator|:
name|IBOutletAttr
argument_list|()
operator|:
name|Attr
argument_list|(
argument|IBOutletKind
argument_list|)
block|{}
name|virtual
name|Attr
operator|*
name|clone
argument_list|(
argument|ASTContext&C
argument_list|)
specifier|const
block|{
return|return
operator|::
name|new
argument_list|(
argument|C
argument_list|)
name|IBOutletAttr
return|;
block|}
comment|// Implement isa/cast/dyncast/etc.
specifier|static
name|bool
name|classof
argument_list|(
argument|const Attr *A
argument_list|)
block|{
return|return
name|A
operator|->
name|getKind
argument_list|()
operator|==
name|IBOutletKind
return|;
block|}
specifier|static
name|bool
name|classof
argument_list|(
argument|const IBOutletAttr *A
argument_list|)
block|{
return|return
name|true
return|;
block|}
expr|}
block|;
name|DEF_SIMPLE_ATTR
argument_list|(
name|Malloc
argument_list|)
block|;
name|DEF_SIMPLE_ATTR
argument_list|(
name|NoReturn
argument_list|)
block|;
name|DEF_SIMPLE_ATTR
argument_list|(
name|AnalyzerNoReturn
argument_list|)
block|;
name|DEF_SIMPLE_ATTR
argument_list|(
name|Deprecated
argument_list|)
block|;
name|class
name|SectionAttr
operator|:
name|public
name|Attr
block|{
name|std
operator|::
name|string
name|Name
block|;
name|public
operator|:
name|SectionAttr
argument_list|(
specifier|const
name|std
operator|::
name|string
operator|&
name|N
argument_list|)
operator|:
name|Attr
argument_list|(
name|Section
argument_list|)
block|,
name|Name
argument_list|(
argument|N
argument_list|)
block|{}
specifier|const
name|std
operator|::
name|string
operator|&
name|getName
argument_list|()
specifier|const
block|{
return|return
name|Name
return|;
block|}
name|virtual
name|Attr
operator|*
name|clone
argument_list|(
argument|ASTContext&C
argument_list|)
specifier|const
block|{
return|return
operator|::
name|new
argument_list|(
argument|C
argument_list|)
name|SectionAttr
argument_list|(
name|Name
argument_list|)
return|;
block|}
comment|// Implement isa/cast/dyncast/etc.
specifier|static
name|bool
name|classof
argument_list|(
argument|const Attr *A
argument_list|)
block|{
return|return
name|A
operator|->
name|getKind
argument_list|()
operator|==
name|Section
return|;
block|}
specifier|static
name|bool
name|classof
argument_list|(
argument|const SectionAttr *A
argument_list|)
block|{
return|return
name|true
return|;
block|}
expr|}
block|;
name|DEF_SIMPLE_ATTR
argument_list|(
name|Unavailable
argument_list|)
block|;
name|DEF_SIMPLE_ATTR
argument_list|(
name|Unused
argument_list|)
block|;
name|DEF_SIMPLE_ATTR
argument_list|(
name|Used
argument_list|)
block|;
name|DEF_SIMPLE_ATTR
argument_list|(
name|Weak
argument_list|)
block|;
name|DEF_SIMPLE_ATTR
argument_list|(
name|WeakImport
argument_list|)
block|;
name|DEF_SIMPLE_ATTR
argument_list|(
name|NoThrow
argument_list|)
block|;
name|DEF_SIMPLE_ATTR
argument_list|(
name|Const
argument_list|)
block|;
name|DEF_SIMPLE_ATTR
argument_list|(
name|Pure
argument_list|)
block|;
name|class
name|NonNullAttr
operator|:
name|public
name|Attr
block|{
name|unsigned
operator|*
name|ArgNums
block|;
name|unsigned
name|Size
block|;
name|public
operator|:
name|NonNullAttr
argument_list|(
argument|unsigned* arg_nums =
literal|0
argument_list|,
argument|unsigned size =
literal|0
argument_list|)
operator|:
name|Attr
argument_list|(
name|NonNull
argument_list|)
block|,
name|ArgNums
argument_list|(
literal|0
argument_list|)
block|,
name|Size
argument_list|(
literal|0
argument_list|)
block|{
if|if
condition|(
name|size
operator|==
literal|0
condition|)
return|return;
name|assert
argument_list|(
name|arg_nums
argument_list|)
block|;
name|ArgNums
operator|=
name|new
name|unsigned
index|[
name|size
index|]
block|;
name|Size
operator|=
name|size
block|;
name|memcpy
argument_list|(
name|ArgNums
argument_list|,
name|arg_nums
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ArgNums
argument_list|)
operator|*
name|size
argument_list|)
block|;   }
name|virtual
operator|~
name|NonNullAttr
argument_list|()
block|{
name|delete
index|[]
name|ArgNums
block|;   }
typedef|typedef
specifier|const
name|unsigned
modifier|*
name|iterator
typedef|;
name|iterator
name|begin
argument_list|()
specifier|const
block|{
return|return
name|ArgNums
return|;
block|}
name|iterator
name|end
argument_list|()
specifier|const
block|{
return|return
name|ArgNums
operator|+
name|Size
return|;
block|}
name|unsigned
name|size
argument_list|()
specifier|const
block|{
return|return
name|Size
return|;
block|}
name|bool
name|isNonNull
argument_list|(
argument|unsigned arg
argument_list|)
specifier|const
block|{
return|return
name|ArgNums
operator|?
name|std
operator|::
name|binary_search
argument_list|(
name|ArgNums
argument_list|,
name|ArgNums
operator|+
name|Size
argument_list|,
name|arg
argument_list|)
operator|:
name|true
return|;
block|}
name|virtual
name|Attr
operator|*
name|clone
argument_list|(
argument|ASTContext&C
argument_list|)
specifier|const
block|{
return|return
operator|::
name|new
argument_list|(
argument|C
argument_list|)
name|NonNullAttr
argument_list|(
name|ArgNums
argument_list|,
name|Size
argument_list|)
return|;
block|}
specifier|static
name|bool
name|classof
argument_list|(
argument|const Attr *A
argument_list|)
block|{
return|return
name|A
operator|->
name|getKind
argument_list|()
operator|==
name|NonNull
return|;
block|}
specifier|static
name|bool
name|classof
argument_list|(
argument|const NonNullAttr *A
argument_list|)
block|{
return|return
name|true
return|;
block|}
expr|}
block|;
name|class
name|FormatAttr
operator|:
name|public
name|Attr
block|{
name|std
operator|::
name|string
name|Type
block|;
name|int
name|formatIdx
block|,
name|firstArg
block|;
name|public
operator|:
name|FormatAttr
argument_list|(
argument|const std::string&type
argument_list|,
argument|int idx
argument_list|,
argument|int first
argument_list|)
operator|:
name|Attr
argument_list|(
name|Format
argument_list|)
block|,
name|Type
argument_list|(
name|type
argument_list|)
block|,
name|formatIdx
argument_list|(
name|idx
argument_list|)
block|,
name|firstArg
argument_list|(
argument|first
argument_list|)
block|{}
specifier|const
name|std
operator|::
name|string
operator|&
name|getType
argument_list|()
specifier|const
block|{
return|return
name|Type
return|;
block|}
name|void
name|setType
argument_list|(
argument|const std::string&type
argument_list|)
block|{
name|Type
operator|=
name|type
block|; }
name|int
name|getFormatIdx
argument_list|()
specifier|const
block|{
return|return
name|formatIdx
return|;
block|}
name|int
name|getFirstArg
argument_list|()
specifier|const
block|{
return|return
name|firstArg
return|;
block|}
name|virtual
name|Attr
operator|*
name|clone
argument_list|(
argument|ASTContext&C
argument_list|)
specifier|const
block|{
return|return
operator|::
name|new
argument_list|(
argument|C
argument_list|)
name|FormatAttr
argument_list|(
name|Type
argument_list|,
name|formatIdx
argument_list|,
name|firstArg
argument_list|)
return|;
block|}
comment|// Implement isa/cast/dyncast/etc.
specifier|static
name|bool
name|classof
argument_list|(
argument|const Attr *A
argument_list|)
block|{
return|return
name|A
operator|->
name|getKind
argument_list|()
operator|==
name|Format
return|;
block|}
specifier|static
name|bool
name|classof
argument_list|(
argument|const FormatAttr *A
argument_list|)
block|{
return|return
name|true
return|;
block|}
expr|}
block|;
name|class
name|FormatArgAttr
operator|:
name|public
name|Attr
block|{
name|int
name|formatIdx
block|;
name|public
operator|:
name|FormatArgAttr
argument_list|(
argument|int idx
argument_list|)
operator|:
name|Attr
argument_list|(
name|FormatArg
argument_list|)
block|,
name|formatIdx
argument_list|(
argument|idx
argument_list|)
block|{}
name|int
name|getFormatIdx
argument_list|()
specifier|const
block|{
return|return
name|formatIdx
return|;
block|}
name|virtual
name|Attr
operator|*
name|clone
argument_list|(
argument|ASTContext&C
argument_list|)
specifier|const
block|{
return|return
operator|::
name|new
argument_list|(
argument|C
argument_list|)
name|FormatArgAttr
argument_list|(
name|formatIdx
argument_list|)
return|;
block|}
comment|// Implement isa/cast/dyncast/etc.
specifier|static
name|bool
name|classof
argument_list|(
argument|const Attr *A
argument_list|)
block|{
return|return
name|A
operator|->
name|getKind
argument_list|()
operator|==
name|FormatArg
return|;
block|}
specifier|static
name|bool
name|classof
argument_list|(
argument|const FormatArgAttr *A
argument_list|)
block|{
return|return
name|true
return|;
block|}
expr|}
block|;
name|class
name|SentinelAttr
operator|:
name|public
name|Attr
block|{
name|int
name|sentinel
block|,
name|NullPos
block|;
name|public
operator|:
name|SentinelAttr
argument_list|(
argument|int sentinel_val
argument_list|,
argument|int nullPos
argument_list|)
operator|:
name|Attr
argument_list|(
name|Sentinel
argument_list|)
block|,
name|sentinel
argument_list|(
name|sentinel_val
argument_list|)
block|,
name|NullPos
argument_list|(
argument|nullPos
argument_list|)
block|{}
name|int
name|getSentinel
argument_list|()
specifier|const
block|{
return|return
name|sentinel
return|;
block|}
name|int
name|getNullPos
argument_list|()
specifier|const
block|{
return|return
name|NullPos
return|;
block|}
name|virtual
name|Attr
operator|*
name|clone
argument_list|(
argument|ASTContext&C
argument_list|)
specifier|const
block|{
return|return
operator|::
name|new
argument_list|(
argument|C
argument_list|)
name|SentinelAttr
argument_list|(
name|sentinel
argument_list|,
name|NullPos
argument_list|)
return|;
block|}
comment|// Implement isa/cast/dyncast/etc.
specifier|static
name|bool
name|classof
argument_list|(
argument|const Attr *A
argument_list|)
block|{
return|return
name|A
operator|->
name|getKind
argument_list|()
operator|==
name|Sentinel
return|;
block|}
specifier|static
name|bool
name|classof
argument_list|(
argument|const SentinelAttr *A
argument_list|)
block|{
return|return
name|true
return|;
block|}
expr|}
block|;
name|class
name|VisibilityAttr
operator|:
name|public
name|Attr
block|{
name|public
operator|:
comment|/// @brief An enumeration for the kinds of visibility of symbols.
expr|enum
name|VisibilityTypes
block|{
name|DefaultVisibility
operator|=
literal|0
block|,
name|HiddenVisibility
block|,
name|ProtectedVisibility
block|}
block|;
name|private
operator|:
name|VisibilityTypes
name|VisibilityType
block|;
name|public
operator|:
name|VisibilityAttr
argument_list|(
argument|VisibilityTypes v
argument_list|)
operator|:
name|Attr
argument_list|(
name|Visibility
argument_list|)
block|,
name|VisibilityType
argument_list|(
argument|v
argument_list|)
block|{}
name|VisibilityTypes
name|getVisibility
argument_list|()
specifier|const
block|{
return|return
name|VisibilityType
return|;
block|}
name|virtual
name|Attr
operator|*
name|clone
argument_list|(
argument|ASTContext&C
argument_list|)
specifier|const
block|{
return|return
operator|::
name|new
argument_list|(
argument|C
argument_list|)
name|VisibilityAttr
argument_list|(
name|VisibilityType
argument_list|)
return|;
block|}
comment|// Implement isa/cast/dyncast/etc.
specifier|static
name|bool
name|classof
argument_list|(
argument|const Attr *A
argument_list|)
block|{
return|return
name|A
operator|->
name|getKind
argument_list|()
operator|==
name|Visibility
return|;
block|}
specifier|static
name|bool
name|classof
argument_list|(
argument|const VisibilityAttr *A
argument_list|)
block|{
return|return
name|true
return|;
block|}
expr|}
block|;
name|DEF_SIMPLE_ATTR
argument_list|(
name|DLLImport
argument_list|)
block|;
name|DEF_SIMPLE_ATTR
argument_list|(
name|DLLExport
argument_list|)
block|;
name|DEF_SIMPLE_ATTR
argument_list|(
name|FastCall
argument_list|)
block|;
name|DEF_SIMPLE_ATTR
argument_list|(
name|StdCall
argument_list|)
block|;
name|DEF_SIMPLE_ATTR
argument_list|(
name|TransparentUnion
argument_list|)
block|;
name|DEF_SIMPLE_ATTR
argument_list|(
name|ObjCNSObject
argument_list|)
block|;
name|DEF_SIMPLE_ATTR
argument_list|(
name|ObjCException
argument_list|)
block|;
name|class
name|OverloadableAttr
operator|:
name|public
name|Attr
block|{
name|public
operator|:
name|OverloadableAttr
argument_list|()
operator|:
name|Attr
argument_list|(
argument|Overloadable
argument_list|)
block|{ }
name|virtual
name|bool
name|isMerged
argument_list|()
specifier|const
block|{
return|return
name|false
return|;
block|}
name|virtual
name|Attr
operator|*
name|clone
argument_list|(
argument|ASTContext&C
argument_list|)
specifier|const
block|{
return|return
operator|::
name|new
argument_list|(
argument|C
argument_list|)
name|OverloadableAttr
return|;
block|}
specifier|static
name|bool
name|classof
argument_list|(
argument|const Attr *A
argument_list|)
block|{
return|return
name|A
operator|->
name|getKind
argument_list|()
operator|==
name|Overloadable
return|;
block|}
specifier|static
name|bool
name|classof
argument_list|(
argument|const OverloadableAttr *
argument_list|)
block|{
return|return
name|true
return|;
block|}
expr|}
block|;
name|class
name|BlocksAttr
operator|:
name|public
name|Attr
block|{
name|public
operator|:
expr|enum
name|BlocksAttrTypes
block|{
name|ByRef
operator|=
literal|0
block|}
block|;
name|private
operator|:
name|BlocksAttrTypes
name|BlocksAttrType
block|;
name|public
operator|:
name|BlocksAttr
argument_list|(
argument|BlocksAttrTypes t
argument_list|)
operator|:
name|Attr
argument_list|(
name|Blocks
argument_list|)
block|,
name|BlocksAttrType
argument_list|(
argument|t
argument_list|)
block|{}
name|BlocksAttrTypes
name|getType
argument_list|()
specifier|const
block|{
return|return
name|BlocksAttrType
return|;
block|}
name|virtual
name|Attr
operator|*
name|clone
argument_list|(
argument|ASTContext&C
argument_list|)
specifier|const
block|{
return|return
operator|::
name|new
argument_list|(
argument|C
argument_list|)
name|BlocksAttr
argument_list|(
name|BlocksAttrType
argument_list|)
return|;
block|}
comment|// Implement isa/cast/dyncast/etc.
specifier|static
name|bool
name|classof
argument_list|(
argument|const Attr *A
argument_list|)
block|{
return|return
name|A
operator|->
name|getKind
argument_list|()
operator|==
name|Blocks
return|;
block|}
specifier|static
name|bool
name|classof
argument_list|(
argument|const BlocksAttr *A
argument_list|)
block|{
return|return
name|true
return|;
block|}
expr|}
block|;
name|class
name|FunctionDecl
block|;
name|class
name|CleanupAttr
operator|:
name|public
name|Attr
block|{
name|FunctionDecl
operator|*
name|FD
block|;
name|public
operator|:
name|CleanupAttr
argument_list|(
name|FunctionDecl
operator|*
name|fd
argument_list|)
operator|:
name|Attr
argument_list|(
name|Cleanup
argument_list|)
block|,
name|FD
argument_list|(
argument|fd
argument_list|)
block|{}
specifier|const
name|FunctionDecl
operator|*
name|getFunctionDecl
argument_list|()
specifier|const
block|{
return|return
name|FD
return|;
block|}
name|virtual
name|Attr
operator|*
name|clone
argument_list|(
argument|ASTContext&C
argument_list|)
specifier|const
block|{
return|return
operator|::
name|new
argument_list|(
argument|C
argument_list|)
name|CleanupAttr
argument_list|(
name|FD
argument_list|)
return|;
block|}
comment|// Implement isa/cast/dyncast/etc.
specifier|static
name|bool
name|classof
argument_list|(
argument|const Attr *A
argument_list|)
block|{
return|return
name|A
operator|->
name|getKind
argument_list|()
operator|==
name|Cleanup
return|;
block|}
specifier|static
name|bool
name|classof
argument_list|(
argument|const CleanupAttr *A
argument_list|)
block|{
return|return
name|true
return|;
block|}
expr|}
block|;
name|DEF_SIMPLE_ATTR
argument_list|(
name|NoDebug
argument_list|)
block|;
name|DEF_SIMPLE_ATTR
argument_list|(
name|WarnUnusedResult
argument_list|)
block|;
name|DEF_SIMPLE_ATTR
argument_list|(
name|NoInline
argument_list|)
block|;
name|class
name|RegparmAttr
operator|:
name|public
name|Attr
block|{
name|unsigned
name|NumParams
block|;
name|public
operator|:
name|RegparmAttr
argument_list|(
argument|unsigned np
argument_list|)
operator|:
name|Attr
argument_list|(
name|Regparm
argument_list|)
block|,
name|NumParams
argument_list|(
argument|np
argument_list|)
block|{}
name|unsigned
name|getNumParams
argument_list|()
specifier|const
block|{
return|return
name|NumParams
return|;
block|}
name|virtual
name|Attr
operator|*
name|clone
argument_list|(
argument|ASTContext&C
argument_list|)
specifier|const
block|{
return|return
operator|::
name|new
argument_list|(
argument|C
argument_list|)
name|RegparmAttr
argument_list|(
name|NumParams
argument_list|)
return|;
block|}
comment|// Implement isa/cast/dyncast/etc.
specifier|static
name|bool
name|classof
argument_list|(
argument|const Attr *A
argument_list|)
block|{
return|return
name|A
operator|->
name|getKind
argument_list|()
operator|==
name|Regparm
return|;
block|}
specifier|static
name|bool
name|classof
argument_list|(
argument|const RegparmAttr *A
argument_list|)
block|{
return|return
name|true
return|;
block|}
expr|}
block|;
name|class
name|ReqdWorkGroupSizeAttr
operator|:
name|public
name|Attr
block|{
name|unsigned
name|X
block|,
name|Y
block|,
name|Z
block|;
name|public
operator|:
name|ReqdWorkGroupSizeAttr
argument_list|(
argument|unsigned X
argument_list|,
argument|unsigned Y
argument_list|,
argument|unsigned Z
argument_list|)
operator|:
name|Attr
argument_list|(
name|ReqdWorkGroupSize
argument_list|)
block|,
name|X
argument_list|(
name|X
argument_list|)
block|,
name|Y
argument_list|(
name|Y
argument_list|)
block|,
name|Z
argument_list|(
argument|Z
argument_list|)
block|{}
name|unsigned
name|getXDim
argument_list|()
specifier|const
block|{
return|return
name|X
return|;
block|}
name|unsigned
name|getYDim
argument_list|()
specifier|const
block|{
return|return
name|Y
return|;
block|}
name|unsigned
name|getZDim
argument_list|()
specifier|const
block|{
return|return
name|Z
return|;
block|}
name|virtual
name|Attr
operator|*
name|clone
argument_list|(
argument|ASTContext&C
argument_list|)
specifier|const
block|{
return|return
operator|::
name|new
argument_list|(
argument|C
argument_list|)
name|ReqdWorkGroupSizeAttr
argument_list|(
name|X
argument_list|,
name|Y
argument_list|,
name|Z
argument_list|)
return|;
block|}
comment|// Implement isa/cast/dyncast/etc.
specifier|static
name|bool
name|classof
argument_list|(
argument|const Attr *A
argument_list|)
block|{
return|return
name|A
operator|->
name|getKind
argument_list|()
operator|==
name|ReqdWorkGroupSize
return|;
block|}
specifier|static
name|bool
name|classof
argument_list|(
argument|const ReqdWorkGroupSizeAttr *A
argument_list|)
block|{
return|return
name|true
return|;
block|}
expr|}
block|;
comment|// Checker-specific attributes.
name|DEF_SIMPLE_ATTR
argument_list|(
name|CFReturnsRetained
argument_list|)
block|;
name|DEF_SIMPLE_ATTR
argument_list|(
name|NSReturnsRetained
argument_list|)
block|;
undef|#
directive|undef
name|DEF_SIMPLE_ATTR
block|}
end_decl_stmt

begin_comment
comment|// end namespace clang
end_comment

begin_endif
endif|#
directive|endif
end_endif

end_unit

