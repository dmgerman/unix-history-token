begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===--- TypeLoc.h - Type Source Info Wrapper -------------------*- C++ -*-===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//  This file defines the TypeLoc interface and subclasses.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LLVM_CLANG_AST_TYPELOC_H
end_ifndef

begin_define
define|#
directive|define
name|LLVM_CLANG_AST_TYPELOC_H
end_define

begin_include
include|#
directive|include
file|"clang/AST/Type.h"
end_include

begin_include
include|#
directive|include
file|"clang/AST/TemplateBase.h"
end_include

begin_decl_stmt
name|namespace
name|clang
block|{
name|class
name|ParmVarDecl
decl_stmt|;
name|class
name|TypeSourceInfo
decl_stmt|;
name|class
name|UnqualTypeLoc
decl_stmt|;
comment|// Predeclare all the type nodes.
define|#
directive|define
name|ABSTRACT_TYPELOC
parameter_list|(
name|Class
parameter_list|,
name|Base
parameter_list|)
define|#
directive|define
name|TYPELOC
parameter_list|(
name|Class
parameter_list|,
name|Base
parameter_list|)
define|\
value|class Class##TypeLoc;
include|#
directive|include
file|"clang/AST/TypeLocNodes.def"
comment|/// \brief Base wrapper for a particular "section" of type source info.
comment|///
comment|/// A client should use the TypeLoc subclasses through cast/dyn_cast in order to
comment|/// get at the actual information.
name|class
name|TypeLoc
block|{
name|protected
label|:
comment|// The correctness of this relies on the property that, for Type *Ty,
comment|//   QualType(Ty, 0).getAsOpaquePtr() == (void*) Ty
name|void
modifier|*
name|Ty
decl_stmt|;
name|void
modifier|*
name|Data
decl_stmt|;
name|public
label|:
comment|/// The kinds of TypeLocs.  Equivalent to the Type::TypeClass enum,
comment|/// except it also defines a Qualified enum that corresponds to the
comment|/// QualifiedLoc class.
enum|enum
name|TypeLocClass
block|{
define|#
directive|define
name|ABSTRACT_TYPE
parameter_list|(
name|Class
parameter_list|,
name|Base
parameter_list|)
define|#
directive|define
name|TYPE
parameter_list|(
name|Class
parameter_list|,
name|Base
parameter_list|)
define|\
value|Class = Type::Class,
include|#
directive|include
file|"clang/AST/TypeNodes.def"
name|Qualified
block|}
enum|;
name|TypeLoc
argument_list|()
operator|:
name|Ty
argument_list|(
literal|0
argument_list|)
operator|,
name|Data
argument_list|(
literal|0
argument_list|)
block|{ }
name|TypeLoc
argument_list|(
argument|QualType ty
argument_list|,
argument|void *opaqueData
argument_list|)
operator|:
name|Ty
argument_list|(
name|ty
operator|.
name|getAsOpaquePtr
argument_list|()
argument_list|)
operator|,
name|Data
argument_list|(
argument|opaqueData
argument_list|)
block|{ }
name|TypeLoc
argument_list|(
name|Type
operator|*
name|ty
argument_list|,
name|void
operator|*
name|opaqueData
argument_list|)
operator|:
name|Ty
argument_list|(
name|ty
argument_list|)
operator|,
name|Data
argument_list|(
argument|opaqueData
argument_list|)
block|{ }
name|TypeLocClass
name|getTypeLocClass
argument_list|()
specifier|const
block|{
if|if
condition|(
name|getType
argument_list|()
operator|.
name|hasLocalQualifiers
argument_list|()
condition|)
return|return
name|Qualified
return|;
return|return
operator|(
name|TypeLocClass
operator|)
name|getType
argument_list|()
operator|->
name|getTypeClass
argument_list|()
return|;
block|}
name|bool
name|isNull
argument_list|()
specifier|const
block|{
return|return
operator|!
name|Ty
return|;
block|}
name|operator
name|bool
argument_list|()
specifier|const
block|{
return|return
name|Ty
return|;
block|}
comment|/// \brief Returns the size of type source info data block for the given type.
specifier|static
name|unsigned
name|getFullDataSizeForType
parameter_list|(
name|QualType
name|Ty
parameter_list|)
function_decl|;
comment|/// \brief Get the type for which this source info wrapper provides
comment|/// information.
name|QualType
name|getType
argument_list|()
specifier|const
block|{
return|return
name|QualType
operator|::
name|getFromOpaquePtr
argument_list|(
name|Ty
argument_list|)
return|;
block|}
name|Type
operator|*
name|getTypePtr
argument_list|()
specifier|const
block|{
return|return
name|QualType
operator|::
name|getFromOpaquePtr
argument_list|(
name|Ty
argument_list|)
operator|.
name|getTypePtr
argument_list|()
return|;
block|}
comment|/// \brief Get the pointer where source information is stored.
name|void
operator|*
name|getOpaqueData
argument_list|()
specifier|const
block|{
return|return
name|Data
return|;
block|}
comment|/// \brief Get the full source range.
name|SourceRange
name|getFullSourceRange
argument_list|()
specifier|const
block|{
name|SourceLocation
name|End
operator|=
name|getSourceRange
argument_list|()
operator|.
name|getEnd
argument_list|()
block|;
name|TypeLoc
name|Cur
operator|=
operator|*
name|this
block|;
while|while
condition|(
name|true
condition|)
block|{
name|TypeLoc
name|Next
init|=
name|Cur
operator|.
name|getNextTypeLoc
argument_list|()
decl_stmt|;
if|if
condition|(
name|Next
operator|.
name|isNull
argument_list|()
condition|)
break|break;
name|Cur
operator|=
name|Next
expr_stmt|;
block|}
return|return
name|SourceRange
argument_list|(
name|Cur
operator|.
name|getSourceRange
argument_list|()
operator|.
name|getBegin
argument_list|()
argument_list|,
name|End
argument_list|)
return|;
block|}
comment|/// \brief Get the local source range.
name|SourceRange
name|getSourceRange
argument_list|()
specifier|const
block|{
return|return
name|getSourceRangeImpl
argument_list|(
operator|*
name|this
argument_list|)
return|;
block|}
comment|/// \brief Returns the size of the type source info data block.
name|unsigned
name|getFullDataSize
argument_list|()
specifier|const
block|{
return|return
name|getFullDataSizeForType
argument_list|(
name|getType
argument_list|()
argument_list|)
return|;
block|}
comment|/// \brief Get the next TypeLoc pointed by this TypeLoc, e.g for "int*" the
comment|/// TypeLoc is a PointerLoc and next TypeLoc is for "int".
name|TypeLoc
name|getNextTypeLoc
argument_list|()
specifier|const
block|{
return|return
name|getNextTypeLocImpl
argument_list|(
operator|*
name|this
argument_list|)
return|;
block|}
comment|/// \brief Skips past any qualifiers, if this is qualified.
name|UnqualTypeLoc
name|getUnqualifiedLoc
argument_list|()
specifier|const
expr_stmt|;
comment|// implemented in this header
comment|/// \brief Initializes this to state that every location in this
comment|/// type is the given location.
comment|///
comment|/// This method exists to provide a simple transition for code that
comment|/// relies on location-less types.
name|void
name|initialize
argument_list|(
name|SourceLocation
name|Loc
argument_list|)
decl|const
block|{
name|initializeImpl
argument_list|(
operator|*
name|this
argument_list|,
name|Loc
argument_list|)
expr_stmt|;
block|}
name|friend
name|bool
name|operator
operator|==
operator|(
specifier|const
name|TypeLoc
operator|&
name|LHS
operator|,
specifier|const
name|TypeLoc
operator|&
name|RHS
operator|)
block|{
return|return
name|LHS
operator|.
name|Ty
operator|==
name|RHS
operator|.
name|Ty
operator|&&
name|LHS
operator|.
name|Data
operator|==
name|RHS
operator|.
name|Data
return|;
block|}
name|friend
name|bool
name|operator
operator|!=
operator|(
specifier|const
name|TypeLoc
operator|&
name|LHS
operator|,
specifier|const
name|TypeLoc
operator|&
name|RHS
operator|)
block|{
return|return
operator|!
operator|(
name|LHS
operator|==
name|RHS
operator|)
return|;
block|}
specifier|static
name|bool
name|classof
parameter_list|(
specifier|const
name|TypeLoc
modifier|*
name|TL
parameter_list|)
block|{
return|return
name|true
return|;
block|}
name|private
label|:
specifier|static
name|void
name|initializeImpl
parameter_list|(
name|TypeLoc
name|TL
parameter_list|,
name|SourceLocation
name|Loc
parameter_list|)
function_decl|;
specifier|static
name|TypeLoc
name|getNextTypeLocImpl
parameter_list|(
name|TypeLoc
name|TL
parameter_list|)
function_decl|;
specifier|static
name|SourceRange
name|getSourceRangeImpl
parameter_list|(
name|TypeLoc
name|TL
parameter_list|)
function_decl|;
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_comment
comment|/// \brief Wrapper of type source information for a type with
end_comment

begin_comment
comment|/// no direct quqlaifiers.
end_comment

begin_decl_stmt
name|class
name|UnqualTypeLoc
range|:
name|public
name|TypeLoc
block|{
name|public
operator|:
name|UnqualTypeLoc
argument_list|()
block|{}
name|UnqualTypeLoc
argument_list|(
name|Type
operator|*
name|Ty
argument_list|,
name|void
operator|*
name|Data
argument_list|)
operator|:
name|TypeLoc
argument_list|(
argument|Ty
argument_list|,
argument|Data
argument_list|)
block|{}
name|Type
operator|*
name|getTypePtr
argument_list|()
specifier|const
block|{
return|return
name|reinterpret_cast
operator|<
name|Type
operator|*
operator|>
operator|(
name|Ty
operator|)
return|;
block|}
name|TypeLocClass
name|getTypeLocClass
argument_list|()
specifier|const
block|{
return|return
operator|(
name|TypeLocClass
operator|)
name|getTypePtr
argument_list|()
operator|->
name|getTypeClass
argument_list|()
return|;
block|}
specifier|static
name|bool
name|classof
argument_list|(
argument|const TypeLoc *TL
argument_list|)
block|{
return|return
operator|!
name|TL
operator|->
name|getType
argument_list|()
operator|.
name|hasLocalQualifiers
argument_list|()
return|;
block|}
specifier|static
name|bool
name|classof
argument_list|(
argument|const UnqualTypeLoc *TL
argument_list|)
block|{
return|return
name|true
return|;
block|}
expr|}
block|;
comment|/// \brief Wrapper of type source information for a type with
comment|/// non-trivial direct qualifiers.
comment|///
comment|/// Currently, we intentionally do not provide source location for
comment|/// type qualifiers.
name|class
name|QualifiedTypeLoc
operator|:
name|public
name|TypeLoc
block|{
name|public
operator|:
name|SourceRange
name|getSourceRange
argument_list|()
specifier|const
block|{
return|return
name|SourceRange
argument_list|()
return|;
block|}
name|UnqualTypeLoc
name|getUnqualifiedLoc
argument_list|()
specifier|const
block|{
return|return
name|UnqualTypeLoc
argument_list|(
name|getTypePtr
argument_list|()
argument_list|,
name|Data
argument_list|)
return|;
block|}
comment|/// Initializes the local data of this type source info block to
comment|/// provide no information.
name|void
name|initializeLocal
argument_list|(
argument|SourceLocation Loc
argument_list|)
block|{
comment|// do nothing
block|}
name|TypeLoc
name|getNextTypeLoc
argument_list|()
specifier|const
block|{
return|return
name|getUnqualifiedLoc
argument_list|()
return|;
block|}
comment|/// \brief Returns the size of the type source info data block that is
comment|/// specific to this type.
name|unsigned
name|getLocalDataSize
argument_list|()
specifier|const
block|{
comment|// In fact, we don't currently preserve any location information
comment|// for qualifiers.
return|return
literal|0
return|;
block|}
comment|/// \brief Returns the size of the type source info data block.
name|unsigned
name|getFullDataSize
argument_list|()
specifier|const
block|{
return|return
name|getLocalDataSize
argument_list|()
operator|+
name|getFullDataSizeForType
argument_list|(
name|getType
argument_list|()
operator|.
name|getLocalUnqualifiedType
argument_list|()
argument_list|)
return|;
block|}
specifier|static
name|bool
name|classof
argument_list|(
argument|const TypeLoc *TL
argument_list|)
block|{
return|return
name|TL
operator|->
name|getType
argument_list|()
operator|.
name|hasLocalQualifiers
argument_list|()
return|;
block|}
specifier|static
name|bool
name|classof
argument_list|(
argument|const QualifiedTypeLoc *TL
argument_list|)
block|{
return|return
name|true
return|;
block|}
expr|}
block|;
specifier|inline
name|UnqualTypeLoc
name|TypeLoc
operator|::
name|getUnqualifiedLoc
argument_list|()
specifier|const
block|{
if|if
condition|(
name|isa
operator|<
name|QualifiedTypeLoc
operator|>
operator|(
name|this
operator|)
condition|)
return|return
name|cast
operator|<
name|QualifiedTypeLoc
operator|>
operator|(
name|this
operator|)
operator|->
name|getUnqualifiedLoc
argument_list|()
return|;
return|return
name|cast
operator|<
name|UnqualTypeLoc
operator|>
operator|(
operator|*
name|this
operator|)
return|;
block|}
comment|/// A metaprogramming base class for TypeLoc classes which correspond
comment|/// to a particular Type subclass.  It is accepted for a single
comment|/// TypeLoc class to correspond to multiple Type classes.
comment|///
comment|/// \param Base a class from which to derive
comment|/// \param Derived the class deriving from this one
comment|/// \param TypeClass the concrete Type subclass associated with this
comment|///   location type
comment|/// \param LocalData the structure type of local location data for
comment|///   this type
comment|///
comment|/// sizeof(LocalData) needs to be a multiple of sizeof(void*) or
comment|/// else the world will end.
comment|///
comment|/// TypeLocs with non-constant amounts of local data should override
comment|/// getExtraLocalDataSize(); getExtraLocalData() will then point to
comment|/// this extra memory.
comment|///
comment|/// TypeLocs with an inner type should define
comment|///   QualType getInnerType() const
comment|/// and getInnerTypeLoc() will then point to this inner type's
comment|/// location data.
comment|///
comment|/// A word about hierarchies: this template is not designed to be
comment|/// derived from multiple times in a hierarchy.  It is also not
comment|/// designed to be used for classes where subtypes might provide
comment|/// different amounts of source information.  It should be subclassed
comment|/// only at the deepest portion of the hierarchy where all children
comment|/// have identical source information; if that's an abstract type,
comment|/// then further descendents should inherit from
comment|/// InheritingConcreteTypeLoc instead.
name|template
operator|<
name|class
name|Base
block|,
name|class
name|Derived
block|,
name|class
name|TypeClass
block|,
name|class
name|LocalData
operator|>
name|class
name|ConcreteTypeLoc
operator|:
name|public
name|Base
block|{
specifier|const
name|Derived
operator|*
name|asDerived
argument_list|()
specifier|const
block|{
return|return
name|static_cast
operator|<
specifier|const
name|Derived
operator|*
operator|>
operator|(
name|this
operator|)
return|;
block|}
name|public
operator|:
name|unsigned
name|getLocalDataSize
argument_list|()
specifier|const
block|{
return|return
sizeof|sizeof
argument_list|(
name|LocalData
argument_list|)
operator|+
name|asDerived
argument_list|()
operator|->
name|getExtraLocalDataSize
argument_list|()
return|;
block|}
comment|// Give a default implementation that's useful for leaf types.
name|unsigned
name|getFullDataSize
argument_list|()
specifier|const
block|{
return|return
name|asDerived
argument_list|()
operator|->
name|getLocalDataSize
argument_list|()
operator|+
name|getInnerTypeSize
argument_list|()
return|;
block|}
specifier|static
name|bool
name|classofType
argument_list|(
argument|const Type *Ty
argument_list|)
block|{
return|return
name|TypeClass
operator|::
name|classof
argument_list|(
name|Ty
argument_list|)
return|;
block|}
name|TypeLoc
name|getNextTypeLoc
argument_list|()
specifier|const
block|{
return|return
name|getNextTypeLoc
argument_list|(
name|asDerived
argument_list|()
operator|->
name|getInnerType
argument_list|()
argument_list|)
return|;
block|}
name|TypeClass
operator|*
name|getTypePtr
argument_list|()
specifier|const
block|{
return|return
name|cast
operator|<
name|TypeClass
operator|>
operator|(
name|Base
operator|::
name|getTypePtr
argument_list|()
operator|)
return|;
block|}
name|protected
operator|:
name|unsigned
name|getExtraLocalDataSize
argument_list|()
specifier|const
block|{
return|return
literal|0
return|;
block|}
name|LocalData
operator|*
name|getLocalData
argument_list|()
specifier|const
block|{
return|return
name|static_cast
operator|<
name|LocalData
operator|*
operator|>
operator|(
name|Base
operator|::
name|Data
operator|)
return|;
block|}
comment|/// Gets a pointer past the Info structure; useful for classes with
comment|/// local data that can't be captured in the Info (e.g. because it's
comment|/// of variable size).
name|void
operator|*
name|getExtraLocalData
argument_list|()
specifier|const
block|{
return|return
name|getLocalData
argument_list|()
operator|+
literal|1
return|;
block|}
name|void
operator|*
name|getNonLocalData
argument_list|()
specifier|const
block|{
return|return
name|static_cast
operator|<
name|char
operator|*
operator|>
operator|(
name|Base
operator|::
name|Data
operator|)
operator|+
name|asDerived
argument_list|()
operator|->
name|getLocalDataSize
argument_list|()
return|;
block|}
expr|struct
name|HasNoInnerType
block|{}
block|;
name|HasNoInnerType
name|getInnerType
argument_list|()
specifier|const
block|{
return|return
name|HasNoInnerType
argument_list|()
return|;
block|}
name|TypeLoc
name|getInnerTypeLoc
argument_list|()
specifier|const
block|{
return|return
name|TypeLoc
argument_list|(
name|asDerived
argument_list|()
operator|->
name|getInnerType
argument_list|()
argument_list|,
name|getNonLocalData
argument_list|()
argument_list|)
return|;
block|}
name|private
operator|:
name|unsigned
name|getInnerTypeSize
argument_list|()
specifier|const
block|{
return|return
name|getInnerTypeSize
argument_list|(
name|asDerived
argument_list|()
operator|->
name|getInnerType
argument_list|()
argument_list|)
return|;
block|}
name|unsigned
name|getInnerTypeSize
argument_list|(
argument|HasNoInnerType _
argument_list|)
specifier|const
block|{
return|return
literal|0
return|;
block|}
name|unsigned
name|getInnerTypeSize
argument_list|(
argument|QualType _
argument_list|)
specifier|const
block|{
return|return
name|getInnerTypeLoc
argument_list|()
operator|.
name|getFullDataSize
argument_list|()
return|;
block|}
name|TypeLoc
name|getNextTypeLoc
argument_list|(
argument|HasNoInnerType _
argument_list|)
specifier|const
block|{
return|return
name|TypeLoc
argument_list|()
return|;
block|}
name|TypeLoc
name|getNextTypeLoc
argument_list|(
argument|QualType T
argument_list|)
specifier|const
block|{
return|return
name|TypeLoc
argument_list|(
name|T
argument_list|,
name|getNonLocalData
argument_list|()
argument_list|)
return|;
block|}
expr|}
block|;
comment|/// A metaprogramming class designed for concrete subtypes of abstract
comment|/// types where all subtypes share equivalently-structured source
comment|/// information.  See the note on ConcreteTypeLoc.
name|template
operator|<
name|class
name|Base
block|,
name|class
name|Derived
block|,
name|class
name|TypeClass
operator|>
name|class
name|InheritingConcreteTypeLoc
operator|:
name|public
name|Base
block|{
name|public
operator|:
specifier|static
name|bool
name|classof
argument_list|(
argument|const TypeLoc *TL
argument_list|)
block|{
return|return
name|Derived
operator|::
name|classofType
argument_list|(
name|TL
operator|->
name|getTypePtr
argument_list|()
argument_list|)
return|;
block|}
specifier|static
name|bool
name|classof
argument_list|(
argument|const UnqualTypeLoc *TL
argument_list|)
block|{
return|return
name|Derived
operator|::
name|classofType
argument_list|(
name|TL
operator|->
name|getTypePtr
argument_list|()
argument_list|)
return|;
block|}
specifier|static
name|bool
name|classof
argument_list|(
argument|const Derived *TL
argument_list|)
block|{
return|return
name|true
return|;
block|}
name|TypeClass
operator|*
name|getTypePtr
argument_list|()
specifier|const
block|{
return|return
name|cast
operator|<
name|TypeClass
operator|>
operator|(
name|Base
operator|::
name|getTypePtr
argument_list|()
operator|)
return|;
block|}
expr|}
block|;   struct
name|TypeSpecLocInfo
block|{
name|SourceLocation
name|NameLoc
block|; }
block|;
comment|/// \brief A reasonable base class for TypeLocs that correspond to
comment|/// types that are written as a type-specifier.
name|class
name|TypeSpecTypeLoc
operator|:
name|public
name|ConcreteTypeLoc
operator|<
name|UnqualTypeLoc
block|,
name|TypeSpecTypeLoc
block|,
name|Type
block|,
name|TypeSpecLocInfo
operator|>
block|{
name|public
operator|:
expr|enum
block|{
name|LocalDataSize
operator|=
expr|sizeof
operator|(
name|TypeSpecLocInfo
operator|)
block|}
block|;
name|SourceLocation
name|getNameLoc
argument_list|()
specifier|const
block|{
return|return
name|this
operator|->
name|getLocalData
argument_list|()
operator|->
name|NameLoc
return|;
block|}
name|void
name|setNameLoc
argument_list|(
argument|SourceLocation Loc
argument_list|)
block|{
name|this
operator|->
name|getLocalData
argument_list|()
operator|->
name|NameLoc
operator|=
name|Loc
block|;   }
name|SourceRange
name|getSourceRange
argument_list|()
specifier|const
block|{
return|return
name|SourceRange
argument_list|(
name|getNameLoc
argument_list|()
argument_list|,
name|getNameLoc
argument_list|()
argument_list|)
return|;
block|}
name|void
name|initializeLocal
argument_list|(
argument|SourceLocation Loc
argument_list|)
block|{
name|setNameLoc
argument_list|(
name|Loc
argument_list|)
block|;   }
specifier|static
name|bool
name|classof
argument_list|(
specifier|const
name|TypeLoc
operator|*
name|TL
argument_list|)
block|;
specifier|static
name|bool
name|classof
argument_list|(
argument|const TypeSpecTypeLoc *TL
argument_list|)
block|{
return|return
name|true
return|;
block|}
expr|}
block|;
comment|/// \brief Wrapper for source info for typedefs.
name|class
name|TypedefTypeLoc
operator|:
name|public
name|InheritingConcreteTypeLoc
operator|<
name|TypeSpecTypeLoc
block|,
name|TypedefTypeLoc
block|,
name|TypedefType
operator|>
block|{
name|public
operator|:
name|TypedefDecl
operator|*
name|getTypedefDecl
argument_list|()
specifier|const
block|{
return|return
name|getTypePtr
argument_list|()
operator|->
name|getDecl
argument_list|()
return|;
block|}
expr|}
block|;
comment|/// \brief Wrapper for source info for unresolved typename using decls.
name|class
name|UnresolvedUsingTypeLoc
operator|:
name|public
name|InheritingConcreteTypeLoc
operator|<
name|TypeSpecTypeLoc
block|,
name|UnresolvedUsingTypeLoc
block|,
name|UnresolvedUsingType
operator|>
block|{
name|public
operator|:
name|UnresolvedUsingTypenameDecl
operator|*
name|getDecl
argument_list|()
specifier|const
block|{
return|return
name|getTypePtr
argument_list|()
operator|->
name|getDecl
argument_list|()
return|;
block|}
expr|}
block|;
comment|/// \brief Wrapper for source info for tag types.  Note that this only
comment|/// records source info for the name itself; a type written 'struct foo'
comment|/// should be represented as an ElaboratedTypeLoc.  We currently
comment|/// only do that when C++ is enabled because of the expense of
comment|/// creating an ElaboratedType node for so many type references in C.
name|class
name|TagTypeLoc
operator|:
name|public
name|InheritingConcreteTypeLoc
operator|<
name|TypeSpecTypeLoc
block|,
name|TagTypeLoc
block|,
name|TagType
operator|>
block|{
name|public
operator|:
name|TagDecl
operator|*
name|getDecl
argument_list|()
specifier|const
block|{
return|return
name|getTypePtr
argument_list|()
operator|->
name|getDecl
argument_list|()
return|;
block|}
expr|}
block|;
comment|/// \brief Wrapper for source info for record types.
name|class
name|RecordTypeLoc
operator|:
name|public
name|InheritingConcreteTypeLoc
operator|<
name|TagTypeLoc
block|,
name|RecordTypeLoc
block|,
name|RecordType
operator|>
block|{
name|public
operator|:
name|RecordDecl
operator|*
name|getDecl
argument_list|()
specifier|const
block|{
return|return
name|getTypePtr
argument_list|()
operator|->
name|getDecl
argument_list|()
return|;
block|}
expr|}
block|;
comment|/// \brief Wrapper for source info for enum types.
name|class
name|EnumTypeLoc
operator|:
name|public
name|InheritingConcreteTypeLoc
operator|<
name|TagTypeLoc
block|,
name|EnumTypeLoc
block|,
name|EnumType
operator|>
block|{
name|public
operator|:
name|EnumDecl
operator|*
name|getDecl
argument_list|()
specifier|const
block|{
return|return
name|getTypePtr
argument_list|()
operator|->
name|getDecl
argument_list|()
return|;
block|}
expr|}
block|;
comment|/// \brief Wrapper for source info for builtin types.
name|class
name|BuiltinTypeLoc
operator|:
name|public
name|InheritingConcreteTypeLoc
operator|<
name|TypeSpecTypeLoc
block|,
name|BuiltinTypeLoc
block|,
name|BuiltinType
operator|>
block|{ }
block|;
comment|/// \brief Wrapper for template type parameters.
name|class
name|TemplateTypeParmTypeLoc
operator|:
name|public
name|InheritingConcreteTypeLoc
operator|<
name|TypeSpecTypeLoc
block|,
name|TemplateTypeParmTypeLoc
block|,
name|TemplateTypeParmType
operator|>
block|{ }
block|;
comment|/// \brief Wrapper for substituted template type parameters.
name|class
name|SubstTemplateTypeParmTypeLoc
operator|:
name|public
name|InheritingConcreteTypeLoc
operator|<
name|TypeSpecTypeLoc
block|,
name|SubstTemplateTypeParmTypeLoc
block|,
name|SubstTemplateTypeParmType
operator|>
block|{ }
block|;   struct
name|ObjCProtocolListLocInfo
block|{
name|SourceLocation
name|LAngleLoc
block|;
name|SourceLocation
name|RAngleLoc
block|; }
block|;
comment|// A helper class for defining ObjC TypeLocs that can qualified with
comment|// protocols.
comment|//
comment|// TypeClass basically has to be either ObjCInterfaceType or
comment|// ObjCObjectPointerType.
name|template
operator|<
name|class
name|Derived
block|,
name|class
name|TypeClass
block|,
name|class
name|LocalData
operator|>
name|class
name|ObjCProtocolListTypeLoc
operator|:
name|public
name|ConcreteTypeLoc
operator|<
name|UnqualTypeLoc
block|,
name|Derived
block|,
name|TypeClass
block|,
name|LocalData
operator|>
block|{
comment|// SourceLocations are stored after Info, one for each Protocol.
name|SourceLocation
operator|*
name|getProtocolLocArray
argument_list|()
specifier|const
block|{
return|return
operator|(
name|SourceLocation
operator|*
operator|)
name|this
operator|->
name|getExtraLocalData
argument_list|()
return|;
block|}
name|protected
operator|:
name|void
name|initializeLocalBase
argument_list|(
argument|SourceLocation Loc
argument_list|)
block|{
name|setLAngleLoc
argument_list|(
name|Loc
argument_list|)
block|;
name|setRAngleLoc
argument_list|(
name|Loc
argument_list|)
block|;
for|for
control|(
name|unsigned
name|i
init|=
literal|0
init|,
name|e
init|=
name|getNumProtocols
argument_list|()
init|;
name|i
operator|!=
name|e
condition|;
operator|++
name|i
control|)
name|setProtocolLoc
argument_list|(
name|i
argument_list|,
name|Loc
argument_list|)
expr_stmt|;
block|}
name|public
operator|:
name|SourceLocation
name|getLAngleLoc
argument_list|()
specifier|const
block|{
return|return
name|this
operator|->
name|getLocalData
argument_list|()
operator|->
name|LAngleLoc
return|;
block|}
name|void
name|setLAngleLoc
argument_list|(
argument|SourceLocation Loc
argument_list|)
block|{
name|this
operator|->
name|getLocalData
argument_list|()
operator|->
name|LAngleLoc
operator|=
name|Loc
block|;   }
name|SourceLocation
name|getRAngleLoc
argument_list|()
specifier|const
block|{
return|return
name|this
operator|->
name|getLocalData
argument_list|()
operator|->
name|RAngleLoc
return|;
block|}
name|void
name|setRAngleLoc
argument_list|(
argument|SourceLocation Loc
argument_list|)
block|{
name|this
operator|->
name|getLocalData
argument_list|()
operator|->
name|RAngleLoc
operator|=
name|Loc
block|;   }
name|unsigned
name|getNumProtocols
argument_list|()
specifier|const
block|{
return|return
name|this
operator|->
name|getTypePtr
argument_list|()
operator|->
name|getNumProtocols
argument_list|()
return|;
block|}
name|SourceLocation
name|getProtocolLoc
argument_list|(
argument|unsigned i
argument_list|)
specifier|const
block|{
name|assert
argument_list|(
name|i
operator|<
name|getNumProtocols
argument_list|()
operator|&&
literal|"Index is out of bounds!"
argument_list|)
block|;
return|return
name|getProtocolLocArray
argument_list|()
index|[
name|i
index|]
return|;
block|}
name|void
name|setProtocolLoc
argument_list|(
argument|unsigned i
argument_list|,
argument|SourceLocation Loc
argument_list|)
block|{
name|assert
argument_list|(
name|i
operator|<
name|getNumProtocols
argument_list|()
operator|&&
literal|"Index is out of bounds!"
argument_list|)
block|;
name|getProtocolLocArray
argument_list|()
index|[
name|i
index|]
operator|=
name|Loc
block|;   }
name|ObjCProtocolDecl
operator|*
name|getProtocol
argument_list|(
argument|unsigned i
argument_list|)
specifier|const
block|{
name|assert
argument_list|(
name|i
operator|<
name|getNumProtocols
argument_list|()
operator|&&
literal|"Index is out of bounds!"
argument_list|)
block|;
return|return
operator|*
operator|(
name|this
operator|->
name|getTypePtr
argument_list|()
operator|->
name|qual_begin
argument_list|()
operator|+
name|i
operator|)
return|;
block|}
name|SourceRange
name|getSourceRange
argument_list|()
specifier|const
block|{
return|return
name|SourceRange
argument_list|(
name|getLAngleLoc
argument_list|()
argument_list|,
name|getRAngleLoc
argument_list|()
argument_list|)
return|;
block|}
name|void
name|initializeLocal
argument_list|(
argument|SourceLocation Loc
argument_list|)
block|{
name|initializeLocalBase
argument_list|(
name|Loc
argument_list|)
block|;   }
name|unsigned
name|getExtraLocalDataSize
argument_list|()
specifier|const
block|{
return|return
name|this
operator|->
name|getNumProtocols
argument_list|()
operator|*
sizeof|sizeof
argument_list|(
name|SourceLocation
argument_list|)
return|;
block|}
expr|}
block|;   struct
name|ObjCInterfaceLocInfo
operator|:
name|ObjCProtocolListLocInfo
block|{
name|SourceLocation
name|NameLoc
block|; }
block|;
comment|/// \brief Wrapper for source info for ObjC interfaces.
name|class
name|ObjCInterfaceTypeLoc
operator|:
name|public
name|ObjCProtocolListTypeLoc
operator|<
name|ObjCInterfaceTypeLoc
block|,
name|ObjCInterfaceType
block|,
name|ObjCInterfaceLocInfo
operator|>
block|{
name|public
operator|:
name|ObjCInterfaceDecl
operator|*
name|getIFaceDecl
argument_list|()
specifier|const
block|{
return|return
name|getTypePtr
argument_list|()
operator|->
name|getDecl
argument_list|()
return|;
block|}
name|SourceLocation
name|getNameLoc
argument_list|()
specifier|const
block|{
return|return
name|getLocalData
argument_list|()
operator|->
name|NameLoc
return|;
block|}
name|void
name|setNameLoc
argument_list|(
argument|SourceLocation Loc
argument_list|)
block|{
name|getLocalData
argument_list|()
operator|->
name|NameLoc
operator|=
name|Loc
block|;   }
name|SourceRange
name|getSourceRange
argument_list|()
specifier|const
block|{
if|if
condition|(
name|getNumProtocols
argument_list|()
condition|)
return|return
name|SourceRange
argument_list|(
name|getNameLoc
argument_list|()
argument_list|,
name|getRAngleLoc
argument_list|()
argument_list|)
return|;
else|else
return|return
name|SourceRange
argument_list|(
name|getNameLoc
argument_list|()
argument_list|,
name|getNameLoc
argument_list|()
argument_list|)
return|;
block|}
name|void
name|initializeLocal
argument_list|(
argument|SourceLocation Loc
argument_list|)
block|{
name|initializeLocalBase
argument_list|(
name|Loc
argument_list|)
block|;
name|setNameLoc
argument_list|(
name|Loc
argument_list|)
block|;   }
expr|}
block|;   struct
name|ObjCObjectPointerLocInfo
operator|:
name|ObjCProtocolListLocInfo
block|{
name|SourceLocation
name|StarLoc
block|;
name|bool
name|HasProtocols
block|;
name|bool
name|HasBaseType
block|; }
block|;
comment|/// Wraps an ObjCPointerType with source location information.  Note
comment|/// that not all ObjCPointerTypes actually have a star location; nor
comment|/// are protocol locations necessarily written in the source just
comment|/// because they're present on the type.
name|class
name|ObjCObjectPointerTypeLoc
operator|:
name|public
name|ObjCProtocolListTypeLoc
operator|<
name|ObjCObjectPointerTypeLoc
block|,
name|ObjCObjectPointerType
block|,
name|ObjCObjectPointerLocInfo
operator|>
block|{
name|public
operator|:
name|bool
name|hasProtocolsAsWritten
argument_list|()
specifier|const
block|{
return|return
name|getLocalData
argument_list|()
operator|->
name|HasProtocols
return|;
block|}
name|void
name|setHasProtocolsAsWritten
argument_list|(
argument|bool HasProtocols
argument_list|)
block|{
name|getLocalData
argument_list|()
operator|->
name|HasProtocols
operator|=
name|HasProtocols
block|;   }
name|bool
name|hasBaseTypeAsWritten
argument_list|()
specifier|const
block|{
return|return
name|getLocalData
argument_list|()
operator|->
name|HasBaseType
return|;
block|}
name|void
name|setHasBaseTypeAsWritten
argument_list|(
argument|bool HasBaseType
argument_list|)
block|{
name|getLocalData
argument_list|()
operator|->
name|HasBaseType
operator|=
name|HasBaseType
block|;   }
name|SourceLocation
name|getStarLoc
argument_list|()
specifier|const
block|{
return|return
name|getLocalData
argument_list|()
operator|->
name|StarLoc
return|;
block|}
name|void
name|setStarLoc
argument_list|(
argument|SourceLocation Loc
argument_list|)
block|{
name|getLocalData
argument_list|()
operator|->
name|StarLoc
operator|=
name|Loc
block|;   }
name|SourceRange
name|getSourceRange
argument_list|()
specifier|const
block|{
comment|// Being written with protocols is incompatible with being written
comment|// with a star.
if|if
condition|(
name|hasProtocolsAsWritten
argument_list|()
condition|)
return|return
name|SourceRange
argument_list|(
name|getLAngleLoc
argument_list|()
argument_list|,
name|getRAngleLoc
argument_list|()
argument_list|)
return|;
else|else
return|return
name|SourceRange
argument_list|(
name|getStarLoc
argument_list|()
argument_list|,
name|getStarLoc
argument_list|()
argument_list|)
return|;
block|}
name|void
name|initializeLocal
argument_list|(
argument|SourceLocation Loc
argument_list|)
block|{
name|initializeLocalBase
argument_list|(
name|Loc
argument_list|)
block|;
name|setHasProtocolsAsWritten
argument_list|(
name|false
argument_list|)
block|;
name|setHasBaseTypeAsWritten
argument_list|(
name|false
argument_list|)
block|;
name|setStarLoc
argument_list|(
name|Loc
argument_list|)
block|;   }
name|TypeLoc
name|getBaseTypeLoc
argument_list|()
specifier|const
block|{
return|return
name|getInnerTypeLoc
argument_list|()
return|;
block|}
name|QualType
name|getInnerType
argument_list|()
specifier|const
block|{
return|return
name|getTypePtr
argument_list|()
operator|->
name|getPointeeType
argument_list|()
return|;
block|}
expr|}
block|;   struct
name|PointerLikeLocInfo
block|{
name|SourceLocation
name|StarLoc
block|; }
block|;
comment|/// A base class for
name|template
operator|<
name|class
name|Derived
block|,
name|class
name|TypeClass
block|,
name|class
name|LocalData
operator|=
name|PointerLikeLocInfo
operator|>
name|class
name|PointerLikeTypeLoc
operator|:
name|public
name|ConcreteTypeLoc
operator|<
name|UnqualTypeLoc
block|,
name|Derived
block|,
name|TypeClass
block|,
name|LocalData
operator|>
block|{
name|public
operator|:
name|SourceLocation
name|getSigilLoc
argument_list|()
specifier|const
block|{
return|return
name|this
operator|->
name|getLocalData
argument_list|()
operator|->
name|StarLoc
return|;
block|}
name|void
name|setSigilLoc
argument_list|(
argument|SourceLocation Loc
argument_list|)
block|{
name|this
operator|->
name|getLocalData
argument_list|()
operator|->
name|StarLoc
operator|=
name|Loc
block|;   }
name|TypeLoc
name|getPointeeLoc
argument_list|()
specifier|const
block|{
return|return
name|this
operator|->
name|getInnerTypeLoc
argument_list|()
return|;
block|}
name|SourceRange
name|getSourceRange
argument_list|()
specifier|const
block|{
return|return
name|SourceRange
argument_list|(
name|getSigilLoc
argument_list|()
argument_list|,
name|getSigilLoc
argument_list|()
argument_list|)
return|;
block|}
name|void
name|initializeLocal
argument_list|(
argument|SourceLocation Loc
argument_list|)
block|{
name|setSigilLoc
argument_list|(
name|Loc
argument_list|)
block|;   }
name|QualType
name|getInnerType
argument_list|()
specifier|const
block|{
return|return
name|this
operator|->
name|getTypePtr
argument_list|()
operator|->
name|getPointeeType
argument_list|()
return|;
block|}
expr|}
block|;
comment|/// \brief Wrapper for source info for pointers.
name|class
name|PointerTypeLoc
operator|:
name|public
name|PointerLikeTypeLoc
operator|<
name|PointerTypeLoc
block|,
name|PointerType
operator|>
block|{
name|public
operator|:
name|SourceLocation
name|getStarLoc
argument_list|()
specifier|const
block|{
return|return
name|getSigilLoc
argument_list|()
return|;
block|}
name|void
name|setStarLoc
argument_list|(
argument|SourceLocation Loc
argument_list|)
block|{
name|setSigilLoc
argument_list|(
name|Loc
argument_list|)
block|;   }
expr|}
block|;
comment|/// \brief Wrapper for source info for block pointers.
name|class
name|BlockPointerTypeLoc
operator|:
name|public
name|PointerLikeTypeLoc
operator|<
name|BlockPointerTypeLoc
block|,
name|BlockPointerType
operator|>
block|{
name|public
operator|:
name|SourceLocation
name|getCaretLoc
argument_list|()
specifier|const
block|{
return|return
name|getSigilLoc
argument_list|()
return|;
block|}
name|void
name|setCaretLoc
argument_list|(
argument|SourceLocation Loc
argument_list|)
block|{
name|setSigilLoc
argument_list|(
name|Loc
argument_list|)
block|;   }
expr|}
block|;
comment|/// \brief Wrapper for source info for member pointers.
name|class
name|MemberPointerTypeLoc
operator|:
name|public
name|PointerLikeTypeLoc
operator|<
name|MemberPointerTypeLoc
block|,
name|MemberPointerType
operator|>
block|{
name|public
operator|:
name|SourceLocation
name|getStarLoc
argument_list|()
specifier|const
block|{
return|return
name|getSigilLoc
argument_list|()
return|;
block|}
name|void
name|setStarLoc
argument_list|(
argument|SourceLocation Loc
argument_list|)
block|{
name|setSigilLoc
argument_list|(
name|Loc
argument_list|)
block|;   }
expr|}
block|;
name|class
name|ReferenceTypeLoc
operator|:
name|public
name|PointerLikeTypeLoc
operator|<
name|ReferenceTypeLoc
block|,
name|ReferenceType
operator|>
block|{
name|public
operator|:
name|QualType
name|getInnerType
argument_list|()
specifier|const
block|{
return|return
name|getTypePtr
argument_list|()
operator|->
name|getPointeeTypeAsWritten
argument_list|()
return|;
block|}
expr|}
block|;
name|class
name|LValueReferenceTypeLoc
operator|:
name|public
name|InheritingConcreteTypeLoc
operator|<
name|ReferenceTypeLoc
block|,
name|LValueReferenceTypeLoc
block|,
name|LValueReferenceType
operator|>
block|{
name|public
operator|:
name|SourceLocation
name|getAmpLoc
argument_list|()
specifier|const
block|{
return|return
name|getSigilLoc
argument_list|()
return|;
block|}
name|void
name|setAmpLoc
argument_list|(
argument|SourceLocation Loc
argument_list|)
block|{
name|setSigilLoc
argument_list|(
name|Loc
argument_list|)
block|;   }
expr|}
block|;
name|class
name|RValueReferenceTypeLoc
operator|:
name|public
name|InheritingConcreteTypeLoc
operator|<
name|ReferenceTypeLoc
block|,
name|RValueReferenceTypeLoc
block|,
name|RValueReferenceType
operator|>
block|{
name|public
operator|:
name|SourceLocation
name|getAmpAmpLoc
argument_list|()
specifier|const
block|{
return|return
name|getSigilLoc
argument_list|()
return|;
block|}
name|void
name|setAmpAmpLoc
argument_list|(
argument|SourceLocation Loc
argument_list|)
block|{
name|setSigilLoc
argument_list|(
name|Loc
argument_list|)
block|;   }
expr|}
block|;   struct
name|FunctionLocInfo
block|{
name|SourceLocation
name|LParenLoc
block|,
name|RParenLoc
block|; }
block|;
comment|/// \brief Wrapper for source info for functions.
name|class
name|FunctionTypeLoc
operator|:
name|public
name|ConcreteTypeLoc
operator|<
name|UnqualTypeLoc
block|,
name|FunctionTypeLoc
block|,
name|FunctionType
block|,
name|FunctionLocInfo
operator|>
block|{
comment|// ParmVarDecls* are stored after Info, one for each argument.
name|ParmVarDecl
operator|*
operator|*
name|getParmArray
argument_list|()
specifier|const
block|{
return|return
operator|(
name|ParmVarDecl
operator|*
operator|*
operator|)
name|getExtraLocalData
argument_list|()
return|;
block|}
name|public
operator|:
name|SourceLocation
name|getLParenLoc
argument_list|()
specifier|const
block|{
return|return
name|getLocalData
argument_list|()
operator|->
name|LParenLoc
return|;
block|}
name|void
name|setLParenLoc
argument_list|(
argument|SourceLocation Loc
argument_list|)
block|{
name|getLocalData
argument_list|()
operator|->
name|LParenLoc
operator|=
name|Loc
block|;   }
name|SourceLocation
name|getRParenLoc
argument_list|()
specifier|const
block|{
return|return
name|getLocalData
argument_list|()
operator|->
name|RParenLoc
return|;
block|}
name|void
name|setRParenLoc
argument_list|(
argument|SourceLocation Loc
argument_list|)
block|{
name|getLocalData
argument_list|()
operator|->
name|RParenLoc
operator|=
name|Loc
block|;   }
name|unsigned
name|getNumArgs
argument_list|()
specifier|const
block|{
if|if
condition|(
name|isa
operator|<
name|FunctionNoProtoType
operator|>
operator|(
name|getTypePtr
argument_list|()
operator|)
condition|)
return|return
literal|0
return|;
return|return
name|cast
operator|<
name|FunctionProtoType
operator|>
operator|(
name|getTypePtr
argument_list|()
operator|)
operator|->
name|getNumArgs
argument_list|()
return|;
block|}
name|ParmVarDecl
operator|*
name|getArg
argument_list|(
argument|unsigned i
argument_list|)
specifier|const
block|{
return|return
name|getParmArray
argument_list|()
index|[
name|i
index|]
return|;
block|}
name|void
name|setArg
argument_list|(
argument|unsigned i
argument_list|,
argument|ParmVarDecl *VD
argument_list|)
block|{
name|getParmArray
argument_list|()
index|[
name|i
index|]
operator|=
name|VD
block|; }
name|TypeLoc
name|getArgLoc
argument_list|(
argument|unsigned i
argument_list|)
specifier|const
block|;
name|TypeLoc
name|getResultLoc
argument_list|()
specifier|const
block|{
return|return
name|getInnerTypeLoc
argument_list|()
return|;
block|}
name|SourceRange
name|getSourceRange
argument_list|()
specifier|const
block|{
return|return
name|SourceRange
argument_list|(
name|getLParenLoc
argument_list|()
argument_list|,
name|getRParenLoc
argument_list|()
argument_list|)
return|;
block|}
name|void
name|initializeLocal
argument_list|(
argument|SourceLocation Loc
argument_list|)
block|{
name|setLParenLoc
argument_list|(
name|Loc
argument_list|)
block|;
name|setRParenLoc
argument_list|(
name|Loc
argument_list|)
block|;
for|for
control|(
name|unsigned
name|i
init|=
literal|0
init|,
name|e
init|=
name|getNumArgs
argument_list|()
init|;
name|i
operator|!=
name|e
condition|;
operator|++
name|i
control|)
name|setArg
argument_list|(
name|i
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
comment|/// \brief Returns the size of the type source info data block that is
comment|/// specific to this type.
name|unsigned
name|getExtraLocalDataSize
argument_list|()
specifier|const
block|{
return|return
name|getNumArgs
argument_list|()
operator|*
sizeof|sizeof
argument_list|(
name|ParmVarDecl
operator|*
argument_list|)
return|;
block|}
name|QualType
name|getInnerType
argument_list|()
specifier|const
block|{
return|return
name|getTypePtr
argument_list|()
operator|->
name|getResultType
argument_list|()
return|;
block|}
expr|}
block|;
name|class
name|FunctionProtoTypeLoc
operator|:
name|public
name|InheritingConcreteTypeLoc
operator|<
name|FunctionTypeLoc
block|,
name|FunctionProtoTypeLoc
block|,
name|FunctionProtoType
operator|>
block|{ }
block|;
name|class
name|FunctionNoProtoTypeLoc
operator|:
name|public
name|InheritingConcreteTypeLoc
operator|<
name|FunctionTypeLoc
block|,
name|FunctionNoProtoTypeLoc
block|,
name|FunctionNoProtoType
operator|>
block|{ }
block|;   struct
name|ArrayLocInfo
block|{
name|SourceLocation
name|LBracketLoc
block|,
name|RBracketLoc
block|;
name|Expr
operator|*
name|Size
block|; }
block|;
comment|/// \brief Wrapper for source info for arrays.
name|class
name|ArrayTypeLoc
operator|:
name|public
name|ConcreteTypeLoc
operator|<
name|UnqualTypeLoc
block|,
name|ArrayTypeLoc
block|,
name|ArrayType
block|,
name|ArrayLocInfo
operator|>
block|{
name|public
operator|:
name|SourceLocation
name|getLBracketLoc
argument_list|()
specifier|const
block|{
return|return
name|getLocalData
argument_list|()
operator|->
name|LBracketLoc
return|;
block|}
name|void
name|setLBracketLoc
argument_list|(
argument|SourceLocation Loc
argument_list|)
block|{
name|getLocalData
argument_list|()
operator|->
name|LBracketLoc
operator|=
name|Loc
block|;   }
name|SourceLocation
name|getRBracketLoc
argument_list|()
specifier|const
block|{
return|return
name|getLocalData
argument_list|()
operator|->
name|RBracketLoc
return|;
block|}
name|void
name|setRBracketLoc
argument_list|(
argument|SourceLocation Loc
argument_list|)
block|{
name|getLocalData
argument_list|()
operator|->
name|RBracketLoc
operator|=
name|Loc
block|;   }
name|SourceRange
name|getBracketsRange
argument_list|()
specifier|const
block|{
return|return
name|SourceRange
argument_list|(
name|getLBracketLoc
argument_list|()
argument_list|,
name|getRBracketLoc
argument_list|()
argument_list|)
return|;
block|}
name|Expr
operator|*
name|getSizeExpr
argument_list|()
specifier|const
block|{
return|return
name|getLocalData
argument_list|()
operator|->
name|Size
return|;
block|}
name|void
name|setSizeExpr
argument_list|(
argument|Expr *Size
argument_list|)
block|{
name|getLocalData
argument_list|()
operator|->
name|Size
operator|=
name|Size
block|;   }
name|TypeLoc
name|getElementLoc
argument_list|()
specifier|const
block|{
return|return
name|getInnerTypeLoc
argument_list|()
return|;
block|}
name|SourceRange
name|getSourceRange
argument_list|()
specifier|const
block|{
return|return
name|SourceRange
argument_list|(
name|getLBracketLoc
argument_list|()
argument_list|,
name|getRBracketLoc
argument_list|()
argument_list|)
return|;
block|}
name|void
name|initializeLocal
argument_list|(
argument|SourceLocation Loc
argument_list|)
block|{
name|setLBracketLoc
argument_list|(
name|Loc
argument_list|)
block|;
name|setRBracketLoc
argument_list|(
name|Loc
argument_list|)
block|;
name|setSizeExpr
argument_list|(
name|NULL
argument_list|)
block|;   }
name|QualType
name|getInnerType
argument_list|()
specifier|const
block|{
return|return
name|getTypePtr
argument_list|()
operator|->
name|getElementType
argument_list|()
return|;
block|}
expr|}
block|;
name|class
name|ConstantArrayTypeLoc
operator|:
name|public
name|InheritingConcreteTypeLoc
operator|<
name|ArrayTypeLoc
block|,
name|ConstantArrayTypeLoc
block|,
name|ConstantArrayType
operator|>
block|{ }
block|;
name|class
name|IncompleteArrayTypeLoc
operator|:
name|public
name|InheritingConcreteTypeLoc
operator|<
name|ArrayTypeLoc
block|,
name|IncompleteArrayTypeLoc
block|,
name|IncompleteArrayType
operator|>
block|{ }
block|;
name|class
name|DependentSizedArrayTypeLoc
operator|:
name|public
name|InheritingConcreteTypeLoc
operator|<
name|ArrayTypeLoc
block|,
name|DependentSizedArrayTypeLoc
block|,
name|DependentSizedArrayType
operator|>
block|{  }
block|;
name|class
name|VariableArrayTypeLoc
operator|:
name|public
name|InheritingConcreteTypeLoc
operator|<
name|ArrayTypeLoc
block|,
name|VariableArrayTypeLoc
block|,
name|VariableArrayType
operator|>
block|{ }
block|;
comment|// Location information for a TemplateName.  Rudimentary for now.
block|struct
name|TemplateNameLocInfo
block|{
name|SourceLocation
name|NameLoc
block|; }
block|;  struct
name|TemplateSpecializationLocInfo
operator|:
name|TemplateNameLocInfo
block|{
name|SourceLocation
name|LAngleLoc
block|;
name|SourceLocation
name|RAngleLoc
block|; }
block|;
name|class
name|TemplateSpecializationTypeLoc
operator|:
name|public
name|ConcreteTypeLoc
operator|<
name|UnqualTypeLoc
block|,
name|TemplateSpecializationTypeLoc
block|,
name|TemplateSpecializationType
block|,
name|TemplateSpecializationLocInfo
operator|>
block|{
name|public
operator|:
name|SourceLocation
name|getLAngleLoc
argument_list|()
specifier|const
block|{
return|return
name|getLocalData
argument_list|()
operator|->
name|LAngleLoc
return|;
block|}
name|void
name|setLAngleLoc
argument_list|(
argument|SourceLocation Loc
argument_list|)
block|{
name|getLocalData
argument_list|()
operator|->
name|LAngleLoc
operator|=
name|Loc
block|;   }
name|SourceLocation
name|getRAngleLoc
argument_list|()
specifier|const
block|{
return|return
name|getLocalData
argument_list|()
operator|->
name|RAngleLoc
return|;
block|}
name|void
name|setRAngleLoc
argument_list|(
argument|SourceLocation Loc
argument_list|)
block|{
name|getLocalData
argument_list|()
operator|->
name|RAngleLoc
operator|=
name|Loc
block|;   }
name|unsigned
name|getNumArgs
argument_list|()
specifier|const
block|{
return|return
name|getTypePtr
argument_list|()
operator|->
name|getNumArgs
argument_list|()
return|;
block|}
name|void
name|setArgLocInfo
argument_list|(
argument|unsigned i
argument_list|,
argument|TemplateArgumentLocInfo AI
argument_list|)
block|{
ifndef|#
directive|ifndef
name|NDEBUG
name|AI
operator|.
name|validateForArgument
argument_list|(
name|getTypePtr
argument_list|()
operator|->
name|getArg
argument_list|(
name|i
argument_list|)
argument_list|)
block|;
endif|#
directive|endif
name|getArgInfos
argument_list|()
index|[
name|i
index|]
operator|=
name|AI
block|;   }
name|TemplateArgumentLocInfo
name|getArgLocInfo
argument_list|(
argument|unsigned i
argument_list|)
specifier|const
block|{
return|return
name|getArgInfos
argument_list|()
index|[
name|i
index|]
return|;
block|}
name|TemplateArgumentLoc
name|getArgLoc
argument_list|(
argument|unsigned i
argument_list|)
specifier|const
block|{
return|return
name|TemplateArgumentLoc
argument_list|(
name|getTypePtr
argument_list|()
operator|->
name|getArg
argument_list|(
name|i
argument_list|)
argument_list|,
name|getArgLocInfo
argument_list|(
name|i
argument_list|)
argument_list|)
return|;
block|}
name|SourceLocation
name|getTemplateNameLoc
argument_list|()
specifier|const
block|{
return|return
name|getLocalData
argument_list|()
operator|->
name|NameLoc
return|;
block|}
name|void
name|setTemplateNameLoc
argument_list|(
argument|SourceLocation Loc
argument_list|)
block|{
name|getLocalData
argument_list|()
operator|->
name|NameLoc
operator|=
name|Loc
block|;   }
comment|/// \brief - Copy the location information from the given info.
name|void
name|copy
argument_list|(
argument|TemplateSpecializationTypeLoc Loc
argument_list|)
block|{
name|unsigned
name|size
operator|=
name|getFullDataSize
argument_list|()
block|;
name|assert
argument_list|(
name|size
operator|==
name|Loc
operator|.
name|getFullDataSize
argument_list|()
argument_list|)
block|;
comment|// We're potentially copying Expr references here.  We don't
comment|// bother retaining them because TypeSourceInfos live forever, so
comment|// as long as the Expr was retained when originally written into
comment|// the TypeLoc, we're okay.
name|memcpy
argument_list|(
name|Data
argument_list|,
name|Loc
operator|.
name|Data
argument_list|,
name|size
argument_list|)
block|;   }
name|SourceRange
name|getSourceRange
argument_list|()
specifier|const
block|{
return|return
name|SourceRange
argument_list|(
name|getTemplateNameLoc
argument_list|()
argument_list|,
name|getRAngleLoc
argument_list|()
argument_list|)
return|;
block|}
name|void
name|initializeLocal
argument_list|(
argument|SourceLocation Loc
argument_list|)
block|{
name|setLAngleLoc
argument_list|(
name|Loc
argument_list|)
block|;
name|setRAngleLoc
argument_list|(
name|Loc
argument_list|)
block|;
name|setTemplateNameLoc
argument_list|(
name|Loc
argument_list|)
block|;
for|for
control|(
name|unsigned
name|i
init|=
literal|0
init|,
name|e
init|=
name|getNumArgs
argument_list|()
init|;
name|i
operator|!=
name|e
condition|;
operator|++
name|i
control|)
block|{
name|TemplateArgumentLocInfo
name|Info
decl_stmt|;
ifndef|#
directive|ifndef
name|NDEBUG
comment|// If asserts are enabled, be sure to initialize the argument
comment|// loc with the right kind of pointer.
switch|switch
condition|(
name|getTypePtr
argument_list|()
operator|->
name|getArg
argument_list|(
name|i
argument_list|)
operator|.
name|getKind
argument_list|()
condition|)
block|{
case|case
name|TemplateArgument
operator|::
name|Expression
case|:
case|case
name|TemplateArgument
operator|::
name|Declaration
case|:
name|Info
operator|=
name|TemplateArgumentLocInfo
argument_list|(
operator|(
name|Expr
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|TemplateArgument
operator|::
name|Type
case|:
name|Info
operator|=
name|TemplateArgumentLocInfo
argument_list|(
operator|(
name|TypeSourceInfo
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|TemplateArgument
operator|::
name|Template
case|:
name|Info
operator|=
name|TemplateArgumentLocInfo
argument_list|(
name|SourceRange
argument_list|()
argument_list|,
name|SourceLocation
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|TemplateArgument
operator|::
name|Integral
case|:
case|case
name|TemplateArgument
operator|::
name|Pack
case|:
case|case
name|TemplateArgument
operator|::
name|Null
case|:
comment|// K_None is fine.
break|break;
block|}
endif|#
directive|endif
name|getArgInfos
argument_list|()
index|[
name|i
index|]
operator|=
name|Info
expr_stmt|;
block|}
block|}
name|unsigned
name|getExtraLocalDataSize
argument_list|()
specifier|const
block|{
return|return
name|getNumArgs
argument_list|()
operator|*
sizeof|sizeof
argument_list|(
name|TemplateArgumentLocInfo
argument_list|)
return|;
block|}
name|private
operator|:
name|TemplateArgumentLocInfo
operator|*
name|getArgInfos
argument_list|()
specifier|const
block|{
return|return
name|static_cast
operator|<
name|TemplateArgumentLocInfo
operator|*
operator|>
operator|(
name|getExtraLocalData
argument_list|()
operator|)
return|;
block|}
expr|}
block|;
comment|//===----------------------------------------------------------------------===//
comment|//
comment|//  All of these need proper implementations.
comment|//
comment|//===----------------------------------------------------------------------===//
comment|// FIXME: size expression and attribute locations (or keyword if we
comment|// ever fully support altivec syntax).
name|class
name|VectorTypeLoc
operator|:
name|public
name|InheritingConcreteTypeLoc
operator|<
name|TypeSpecTypeLoc
block|,
name|VectorTypeLoc
block|,
name|VectorType
operator|>
block|{ }
block|;
comment|// FIXME: size expression and attribute locations.
name|class
name|ExtVectorTypeLoc
operator|:
name|public
name|InheritingConcreteTypeLoc
operator|<
name|VectorTypeLoc
block|,
name|ExtVectorTypeLoc
block|,
name|ExtVectorType
operator|>
block|{ }
block|;
comment|// FIXME: attribute locations.
comment|// For some reason, this isn't a subtype of VectorType.
name|class
name|DependentSizedExtVectorTypeLoc
operator|:
name|public
name|InheritingConcreteTypeLoc
operator|<
name|TypeSpecTypeLoc
block|,
name|DependentSizedExtVectorTypeLoc
block|,
name|DependentSizedExtVectorType
operator|>
block|{ }
block|;
comment|// FIXME: location of the '_Complex' keyword.
name|class
name|ComplexTypeLoc
operator|:
name|public
name|InheritingConcreteTypeLoc
operator|<
name|TypeSpecTypeLoc
block|,
name|ComplexTypeLoc
block|,
name|ComplexType
operator|>
block|{ }
block|;  struct
name|TypeofLocInfo
block|{
name|SourceLocation
name|TypeofLoc
block|;
name|SourceLocation
name|LParenLoc
block|;
name|SourceLocation
name|RParenLoc
block|; }
block|;  struct
name|TypeOfExprTypeLocInfo
operator|:
name|public
name|TypeofLocInfo
block|{ }
block|;  struct
name|TypeOfTypeLocInfo
operator|:
name|public
name|TypeofLocInfo
block|{
name|TypeSourceInfo
operator|*
name|UnderlyingTInfo
block|; }
block|;
name|template
operator|<
name|class
name|Derived
block|,
name|class
name|TypeClass
block|,
name|class
name|LocalData
operator|=
name|TypeofLocInfo
operator|>
name|class
name|TypeofLikeTypeLoc
operator|:
name|public
name|ConcreteTypeLoc
operator|<
name|UnqualTypeLoc
block|,
name|Derived
block|,
name|TypeClass
block|,
name|LocalData
operator|>
block|{
name|public
operator|:
name|SourceLocation
name|getTypeofLoc
argument_list|()
specifier|const
block|{
return|return
name|this
operator|->
name|getLocalData
argument_list|()
operator|->
name|TypeofLoc
return|;
block|}
name|void
name|setTypeofLoc
argument_list|(
argument|SourceLocation Loc
argument_list|)
block|{
name|this
operator|->
name|getLocalData
argument_list|()
operator|->
name|TypeofLoc
operator|=
name|Loc
block|;   }
name|SourceLocation
name|getLParenLoc
argument_list|()
specifier|const
block|{
return|return
name|this
operator|->
name|getLocalData
argument_list|()
operator|->
name|LParenLoc
return|;
block|}
name|void
name|setLParenLoc
argument_list|(
argument|SourceLocation Loc
argument_list|)
block|{
name|this
operator|->
name|getLocalData
argument_list|()
operator|->
name|LParenLoc
operator|=
name|Loc
block|;   }
name|SourceLocation
name|getRParenLoc
argument_list|()
specifier|const
block|{
return|return
name|this
operator|->
name|getLocalData
argument_list|()
operator|->
name|RParenLoc
return|;
block|}
name|void
name|setRParenLoc
argument_list|(
argument|SourceLocation Loc
argument_list|)
block|{
name|this
operator|->
name|getLocalData
argument_list|()
operator|->
name|RParenLoc
operator|=
name|Loc
block|;   }
name|SourceRange
name|getParensRange
argument_list|()
specifier|const
block|{
return|return
name|SourceRange
argument_list|(
name|getLParenLoc
argument_list|()
argument_list|,
name|getRParenLoc
argument_list|()
argument_list|)
return|;
block|}
name|void
name|setParensRange
argument_list|(
argument|SourceRange range
argument_list|)
block|{
name|setLParenLoc
argument_list|(
name|range
operator|.
name|getBegin
argument_list|()
argument_list|)
block|;
name|setRParenLoc
argument_list|(
name|range
operator|.
name|getEnd
argument_list|()
argument_list|)
block|;   }
name|SourceRange
name|getSourceRange
argument_list|()
specifier|const
block|{
return|return
name|SourceRange
argument_list|(
name|getTypeofLoc
argument_list|()
argument_list|,
name|getRParenLoc
argument_list|()
argument_list|)
return|;
block|}
name|void
name|initializeLocal
argument_list|(
argument|SourceLocation Loc
argument_list|)
block|{
name|setTypeofLoc
argument_list|(
name|Loc
argument_list|)
block|;
name|setLParenLoc
argument_list|(
name|Loc
argument_list|)
block|;
name|setRParenLoc
argument_list|(
name|Loc
argument_list|)
block|;   }
expr|}
block|;
name|class
name|TypeOfExprTypeLoc
operator|:
name|public
name|TypeofLikeTypeLoc
operator|<
name|TypeOfExprTypeLoc
block|,
name|TypeOfExprType
block|,
name|TypeOfExprTypeLocInfo
operator|>
block|{
name|public
operator|:
name|Expr
operator|*
name|getUnderlyingExpr
argument_list|()
specifier|const
block|{
return|return
name|getTypePtr
argument_list|()
operator|->
name|getUnderlyingExpr
argument_list|()
return|;
block|}
comment|// Reimplemented to account for GNU/C++ extension
comment|//     typeof unary-expression
comment|// where there are no parentheses.
name|SourceRange
name|getSourceRange
argument_list|()
specifier|const
block|; }
block|;
name|class
name|TypeOfTypeLoc
operator|:
name|public
name|TypeofLikeTypeLoc
operator|<
name|TypeOfTypeLoc
block|,
name|TypeOfType
block|,
name|TypeOfTypeLocInfo
operator|>
block|{
name|public
operator|:
name|QualType
name|getUnderlyingType
argument_list|()
specifier|const
block|{
return|return
name|this
operator|->
name|getTypePtr
argument_list|()
operator|->
name|getUnderlyingType
argument_list|()
return|;
block|}
name|TypeSourceInfo
operator|*
name|getUnderlyingTInfo
argument_list|()
specifier|const
block|{
return|return
name|this
operator|->
name|getLocalData
argument_list|()
operator|->
name|UnderlyingTInfo
return|;
block|}
name|void
name|setUnderlyingTInfo
argument_list|(
argument|TypeSourceInfo* TI
argument_list|)
specifier|const
block|{
name|this
operator|->
name|getLocalData
argument_list|()
operator|->
name|UnderlyingTInfo
operator|=
name|TI
block|;   }
expr|}
block|;
comment|// FIXME: location of the 'decltype' and parens.
name|class
name|DecltypeTypeLoc
operator|:
name|public
name|InheritingConcreteTypeLoc
operator|<
name|TypeSpecTypeLoc
block|,
name|DecltypeTypeLoc
block|,
name|DecltypeType
operator|>
block|{ }
block|;
comment|// FIXME: location of the tag keyword.
name|class
name|ElaboratedTypeLoc
operator|:
name|public
name|InheritingConcreteTypeLoc
operator|<
name|TypeSpecTypeLoc
block|,
name|ElaboratedTypeLoc
block|,
name|ElaboratedType
operator|>
block|{ }
block|;
comment|// FIXME: locations for the nested name specifier;  at the very least,
comment|// a SourceRange.
name|class
name|QualifiedNameTypeLoc
operator|:
name|public
name|InheritingConcreteTypeLoc
operator|<
name|TypeSpecTypeLoc
block|,
name|QualifiedNameTypeLoc
block|,
name|QualifiedNameType
operator|>
block|{ }
block|;
comment|// FIXME: locations for the typename keyword and nested name specifier.
name|class
name|TypenameTypeLoc
operator|:
name|public
name|InheritingConcreteTypeLoc
operator|<
name|TypeSpecTypeLoc
block|,
name|TypenameTypeLoc
block|,
name|TypenameType
operator|>
block|{ }
block|;  }
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

end_unit

