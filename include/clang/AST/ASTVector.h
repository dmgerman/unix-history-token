begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===- ASTVector.h - Vector that uses ASTContext for allocation  --*- C++ -*-=//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//  This file provides ASTVector, a vector  ADT whose contents are
end_comment

begin_comment
comment|//  allocated using the allocator associated with an ASTContext..
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|// FIXME: Most of this is copy-and-paste from BumpVector.h and SmallVector.h.
end_comment

begin_comment
comment|// We can refactor this core logic into something common.
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LLVM_CLANG_AST_ASTVECTOR_H
end_ifndef

begin_define
define|#
directive|define
name|LLVM_CLANG_AST_ASTVECTOR_H
end_define

begin_include
include|#
directive|include
file|"clang/AST/AttrIterator.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/PointerIntPair.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/type_traits.h"
end_include

begin_include
include|#
directive|include
file|<algorithm>
end_include

begin_include
include|#
directive|include
file|<cstddef>
end_include

begin_include
include|#
directive|include
file|<cstring>
end_include

begin_include
include|#
directive|include
file|<memory>
end_include

begin_decl_stmt
name|namespace
name|clang
block|{
name|class
name|ASTContext
decl_stmt|;
name|template
operator|<
name|typename
name|T
operator|>
name|class
name|ASTVector
block|{
name|private
operator|:
name|T
operator|*
name|Begin
block|,
operator|*
name|End
block|;
name|llvm
operator|::
name|PointerIntPair
operator|<
name|T
operator|*
block|,
literal|1
block|,
name|bool
operator|>
name|Capacity
block|;
name|void
name|setEnd
argument_list|(
argument|T *P
argument_list|)
block|{
name|this
operator|->
name|End
operator|=
name|P
block|; }
name|protected
operator|:
comment|// Make a tag bit available to users of this class.
comment|// FIXME: This is a horrible hack.
name|bool
name|getTag
argument_list|()
specifier|const
block|{
return|return
name|Capacity
operator|.
name|getInt
argument_list|()
return|;
block|}
name|void
name|setTag
argument_list|(
argument|bool B
argument_list|)
block|{
name|Capacity
operator|.
name|setInt
argument_list|(
name|B
argument_list|)
block|; }
name|public
operator|:
comment|// Default ctor - Initialize to empty.
name|ASTVector
argument_list|()
operator|:
name|Begin
argument_list|(
name|nullptr
argument_list|)
block|,
name|End
argument_list|(
name|nullptr
argument_list|)
block|,
name|Capacity
argument_list|(
argument|nullptr
argument_list|,
argument|false
argument_list|)
block|{}
name|ASTVector
argument_list|(
name|ASTVector
operator|&&
name|O
argument_list|)
operator|:
name|Begin
argument_list|(
name|O
operator|.
name|Begin
argument_list|)
block|,
name|End
argument_list|(
name|O
operator|.
name|End
argument_list|)
block|,
name|Capacity
argument_list|(
argument|O.Capacity
argument_list|)
block|{
name|O
operator|.
name|Begin
operator|=
name|O
operator|.
name|End
operator|=
name|nullptr
block|;
name|O
operator|.
name|Capacity
operator|.
name|setPointer
argument_list|(
name|nullptr
argument_list|)
block|;
name|O
operator|.
name|Capacity
operator|.
name|setInt
argument_list|(
name|false
argument_list|)
block|;   }
name|ASTVector
argument_list|(
argument|const ASTContext&C
argument_list|,
argument|unsigned N
argument_list|)
operator|:
name|Begin
argument_list|(
name|nullptr
argument_list|)
block|,
name|End
argument_list|(
name|nullptr
argument_list|)
block|,
name|Capacity
argument_list|(
argument|nullptr
argument_list|,
argument|false
argument_list|)
block|{
name|reserve
argument_list|(
name|C
argument_list|,
name|N
argument_list|)
block|;   }
name|ASTVector
operator|&
name|operator
operator|=
operator|(
name|ASTVector
operator|&&
name|RHS
operator|)
block|{
name|ASTVector
name|O
argument_list|(
name|std
operator|::
name|move
argument_list|(
name|RHS
argument_list|)
argument_list|)
block|;
name|using
name|std
operator|::
name|swap
block|;
name|swap
argument_list|(
name|Begin
argument_list|,
name|O
operator|.
name|Begin
argument_list|)
block|;
name|swap
argument_list|(
name|End
argument_list|,
name|O
operator|.
name|End
argument_list|)
block|;
name|swap
argument_list|(
name|Capacity
argument_list|,
name|O
operator|.
name|Capacity
argument_list|)
block|;
return|return
operator|*
name|this
return|;
block|}
operator|~
name|ASTVector
argument_list|()
block|{
if|if
condition|(
name|std
operator|::
name|is_class
operator|<
name|T
operator|>
operator|::
name|value
condition|)
block|{
comment|// Destroy the constructed elements in the vector.
name|destroy_range
argument_list|(
name|Begin
argument_list|,
name|End
argument_list|)
expr_stmt|;
block|}
block|}
typedef|typedef
name|size_t
name|size_type
typedef|;
typedef|typedef
name|ptrdiff_t
name|difference_type
typedef|;
typedef|typedef
name|T
name|value_type
typedef|;
typedef|typedef
name|T
modifier|*
name|iterator
typedef|;
typedef|typedef
specifier|const
name|T
modifier|*
name|const_iterator
typedef|;
typedef|typedef
name|std
operator|::
name|reverse_iterator
operator|<
name|const_iterator
operator|>
name|const_reverse_iterator
expr_stmt|;
typedef|typedef
name|std
operator|::
name|reverse_iterator
operator|<
name|iterator
operator|>
name|reverse_iterator
expr_stmt|;
typedef|typedef
name|T
modifier|&
name|reference
typedef|;
typedef|typedef
specifier|const
name|T
modifier|&
name|const_reference
typedef|;
typedef|typedef
name|T
modifier|*
name|pointer
typedef|;
typedef|typedef
specifier|const
name|T
modifier|*
name|const_pointer
typedef|;
comment|// forward iterator creation methods.
name|iterator
name|begin
parameter_list|()
block|{
return|return
name|Begin
return|;
block|}
name|const_iterator
name|begin
argument_list|()
specifier|const
block|{
return|return
name|Begin
return|;
block|}
name|iterator
name|end
parameter_list|()
block|{
return|return
name|End
return|;
block|}
name|const_iterator
name|end
argument_list|()
specifier|const
block|{
return|return
name|End
return|;
block|}
comment|// reverse iterator creation methods.
name|reverse_iterator
name|rbegin
parameter_list|()
block|{
return|return
name|reverse_iterator
argument_list|(
name|end
argument_list|()
argument_list|)
return|;
block|}
name|const_reverse_iterator
name|rbegin
argument_list|()
specifier|const
block|{
return|return
name|const_reverse_iterator
argument_list|(
name|end
argument_list|()
argument_list|)
return|;
block|}
name|reverse_iterator
name|rend
parameter_list|()
block|{
return|return
name|reverse_iterator
argument_list|(
name|begin
argument_list|()
argument_list|)
return|;
block|}
name|const_reverse_iterator
name|rend
argument_list|()
specifier|const
block|{
return|return
name|const_reverse_iterator
argument_list|(
name|begin
argument_list|()
argument_list|)
return|;
block|}
name|bool
name|empty
argument_list|()
specifier|const
block|{
return|return
name|Begin
operator|==
name|End
return|;
block|}
name|size_type
name|size
argument_list|()
specifier|const
block|{
return|return
name|End
operator|-
name|Begin
return|;
block|}
name|reference
name|operator
function|[]
parameter_list|(
name|unsigned
name|idx
parameter_list|)
block|{
name|assert
argument_list|(
name|Begin
operator|+
name|idx
operator|<
name|End
argument_list|)
expr_stmt|;
return|return
name|Begin
index|[
name|idx
index|]
return|;
block|}
name|const_reference
name|operator
index|[]
argument_list|(
name|unsigned
name|idx
argument_list|)
decl|const
block|{
name|assert
argument_list|(
name|Begin
operator|+
name|idx
operator|<
name|End
argument_list|)
expr_stmt|;
return|return
name|Begin
index|[
name|idx
index|]
return|;
block|}
name|reference
name|front
parameter_list|()
block|{
return|return
name|begin
argument_list|()
index|[
literal|0
index|]
return|;
block|}
name|const_reference
name|front
argument_list|()
specifier|const
block|{
return|return
name|begin
argument_list|()
index|[
literal|0
index|]
return|;
block|}
name|reference
name|back
parameter_list|()
block|{
return|return
name|end
argument_list|()
index|[
operator|-
literal|1
index|]
return|;
block|}
name|const_reference
name|back
argument_list|()
specifier|const
block|{
return|return
name|end
argument_list|()
index|[
operator|-
literal|1
index|]
return|;
block|}
name|void
name|pop_back
parameter_list|()
block|{
operator|--
name|End
expr_stmt|;
name|End
operator|->
expr|~
name|T
argument_list|()
expr_stmt|;
block|}
name|T
name|pop_back_val
parameter_list|()
block|{
name|T
name|Result
init|=
name|back
argument_list|()
decl_stmt|;
name|pop_back
argument_list|()
expr_stmt|;
return|return
name|Result
return|;
block|}
name|void
name|clear
parameter_list|()
block|{
if|if
condition|(
name|std
operator|::
name|is_class
operator|<
name|T
operator|>
operator|::
name|value
condition|)
block|{
name|destroy_range
argument_list|(
name|Begin
argument_list|,
name|End
argument_list|)
expr_stmt|;
block|}
name|End
operator|=
name|Begin
expr_stmt|;
block|}
comment|/// data - Return a pointer to the vector's buffer, even if empty().
name|pointer
name|data
parameter_list|()
block|{
return|return
name|pointer
argument_list|(
name|Begin
argument_list|)
return|;
block|}
comment|/// data - Return a pointer to the vector's buffer, even if empty().
name|const_pointer
name|data
argument_list|()
specifier|const
block|{
return|return
name|const_pointer
argument_list|(
name|Begin
argument_list|)
return|;
block|}
name|void
name|push_back
parameter_list|(
name|const_reference
name|Elt
parameter_list|,
specifier|const
name|ASTContext
modifier|&
name|C
parameter_list|)
block|{
if|if
condition|(
name|End
operator|<
name|this
operator|->
name|capacity_ptr
argument_list|()
condition|)
block|{
name|Retry
label|:
name|new
argument_list|(
argument|End
argument_list|)
name|T
argument_list|(
name|Elt
argument_list|)
expr_stmt|;
operator|++
name|End
expr_stmt|;
return|return;
block|}
name|grow
argument_list|(
name|C
argument_list|)
expr_stmt|;
goto|goto
name|Retry
goto|;
block|}
name|void
name|reserve
parameter_list|(
specifier|const
name|ASTContext
modifier|&
name|C
parameter_list|,
name|unsigned
name|N
parameter_list|)
block|{
if|if
condition|(
name|unsigned
argument_list|(
name|this
operator|->
name|capacity_ptr
argument_list|()
operator|-
name|Begin
argument_list|)
operator|<
name|N
condition|)
name|grow
argument_list|(
name|C
argument_list|,
name|N
argument_list|)
expr_stmt|;
block|}
comment|/// capacity - Return the total number of elements in the currently allocated
comment|/// buffer.
name|size_t
name|capacity
argument_list|()
specifier|const
block|{
return|return
name|this
operator|->
name|capacity_ptr
argument_list|()
operator|-
name|Begin
return|;
block|}
comment|/// append - Add the specified range to the end of the SmallVector.
comment|///
name|template
operator|<
name|typename
name|in_iter
operator|>
name|void
name|append
argument_list|(
argument|const ASTContext&C
argument_list|,
argument|in_iter in_start
argument_list|,
argument|in_iter in_end
argument_list|)
block|{
name|size_type
name|NumInputs
operator|=
name|std
operator|::
name|distance
argument_list|(
name|in_start
argument_list|,
name|in_end
argument_list|)
block|;
if|if
condition|(
name|NumInputs
operator|==
literal|0
condition|)
return|return;
comment|// Grow allocated space if needed.
if|if
condition|(
name|NumInputs
operator|>
name|size_type
argument_list|(
name|this
operator|->
name|capacity_ptr
argument_list|()
operator|-
name|this
operator|->
name|end
argument_list|()
argument_list|)
condition|)
name|this
operator|->
name|grow
argument_list|(
name|C
argument_list|,
name|this
operator|->
name|size
argument_list|()
operator|+
name|NumInputs
argument_list|)
expr_stmt|;
comment|// Copy the new elements over.
comment|// TODO: NEED To compile time dispatch on whether in_iter is a random access
comment|// iterator to use the fast uninitialized_copy.
name|std
operator|::
name|uninitialized_copy
argument_list|(
name|in_start
argument_list|,
name|in_end
argument_list|,
name|this
operator|->
name|end
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|->
name|setEnd
argument_list|(
name|this
operator|->
name|end
argument_list|()
operator|+
name|NumInputs
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_comment
comment|/// append - Add the specified range to the end of the SmallVector.
end_comment

begin_comment
comment|///
end_comment

begin_function
name|void
name|append
parameter_list|(
specifier|const
name|ASTContext
modifier|&
name|C
parameter_list|,
name|size_type
name|NumInputs
parameter_list|,
specifier|const
name|T
modifier|&
name|Elt
parameter_list|)
block|{
comment|// Grow allocated space if needed.
if|if
condition|(
name|NumInputs
operator|>
name|size_type
argument_list|(
name|this
operator|->
name|capacity_ptr
argument_list|()
operator|-
name|this
operator|->
name|end
argument_list|()
argument_list|)
condition|)
name|this
operator|->
name|grow
argument_list|(
name|C
argument_list|,
name|this
operator|->
name|size
argument_list|()
operator|+
name|NumInputs
argument_list|)
expr_stmt|;
comment|// Copy the new elements over.
name|std
operator|::
name|uninitialized_fill_n
argument_list|(
name|this
operator|->
name|end
argument_list|()
argument_list|,
name|NumInputs
argument_list|,
name|Elt
argument_list|)
expr_stmt|;
name|this
operator|->
name|setEnd
argument_list|(
name|this
operator|->
name|end
argument_list|()
operator|+
name|NumInputs
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/// uninitialized_copy - Copy the range [I, E) onto the uninitialized memory
end_comment

begin_comment
comment|/// starting with "Dest", constructing elements into it as needed.
end_comment

begin_expr_stmt
name|template
operator|<
name|typename
name|It1
operator|,
name|typename
name|It2
operator|>
specifier|static
name|void
name|uninitialized_copy
argument_list|(
argument|It1 I
argument_list|,
argument|It1 E
argument_list|,
argument|It2 Dest
argument_list|)
block|{
name|std
operator|::
name|uninitialized_copy
argument_list|(
name|I
argument_list|,
name|E
argument_list|,
name|Dest
argument_list|)
block|;   }
name|iterator
name|insert
argument_list|(
argument|const ASTContext&C
argument_list|,
argument|iterator I
argument_list|,
argument|const T&Elt
argument_list|)
block|{
if|if
condition|(
name|I
operator|==
name|this
operator|->
name|end
argument_list|()
condition|)
block|{
comment|// Important special case for empty vector.
name|push_back
argument_list|(
name|Elt
argument_list|,
name|C
argument_list|)
expr_stmt|;
return|return
name|this
operator|->
name|end
argument_list|()
operator|-
literal|1
return|;
block|}
end_expr_stmt

begin_if
if|if
condition|(
name|this
operator|->
name|End
operator|<
name|this
operator|->
name|capacity_ptr
argument_list|()
condition|)
block|{
name|Retry
label|:
name|new
argument_list|(
argument|this->end()
argument_list|)
name|T
argument_list|(
name|this
operator|->
name|back
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|->
name|setEnd
argument_list|(
name|this
operator|->
name|end
argument_list|()
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|// Push everything else over.
name|std
operator|::
name|copy_backward
argument_list|(
name|I
argument_list|,
name|this
operator|->
name|end
argument_list|()
operator|-
literal|1
argument_list|,
name|this
operator|->
name|end
argument_list|()
argument_list|)
expr_stmt|;
operator|*
name|I
operator|=
name|Elt
expr_stmt|;
return|return
name|I
return|;
block|}
end_if

begin_decl_stmt
name|size_t
name|EltNo
init|=
name|I
operator|-
name|this
operator|->
name|begin
argument_list|()
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|this
operator|->
name|grow
argument_list|(
name|C
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|I
operator|=
name|this
operator|->
name|begin
argument_list|()
operator|+
name|EltNo
expr_stmt|;
end_expr_stmt

begin_goto
goto|goto
name|Retry
goto|;
end_goto

begin_macro
unit|}    iterator
name|insert
argument_list|(
argument|const ASTContext&C
argument_list|,
argument|iterator I
argument_list|,
argument|size_type NumToInsert
argument_list|,
argument|const T&Elt
argument_list|)
end_macro

begin_block
block|{
comment|// Convert iterator to elt# to avoid invalidating iterator when we reserve()
name|size_t
name|InsertElt
init|=
name|I
operator|-
name|this
operator|->
name|begin
argument_list|()
decl_stmt|;
if|if
condition|(
name|I
operator|==
name|this
operator|->
name|end
argument_list|()
condition|)
block|{
comment|// Important special case for empty vector.
name|append
argument_list|(
name|C
argument_list|,
name|NumToInsert
argument_list|,
name|Elt
argument_list|)
expr_stmt|;
return|return
name|this
operator|->
name|begin
argument_list|()
operator|+
name|InsertElt
return|;
block|}
comment|// Ensure there is enough space.
name|reserve
argument_list|(
name|C
argument_list|,
name|static_cast
operator|<
name|unsigned
operator|>
operator|(
name|this
operator|->
name|size
argument_list|()
operator|+
name|NumToInsert
operator|)
argument_list|)
expr_stmt|;
comment|// Uninvalidate the iterator.
name|I
operator|=
name|this
operator|->
name|begin
argument_list|()
operator|+
name|InsertElt
expr_stmt|;
comment|// If there are more elements between the insertion point and the end of the
comment|// range than there are being inserted, we can use a simple approach to
comment|// insertion.  Since we already reserved space, we know that this won't
comment|// reallocate the vector.
if|if
condition|(
name|size_t
argument_list|(
name|this
operator|->
name|end
argument_list|()
operator|-
name|I
argument_list|)
operator|>=
name|NumToInsert
condition|)
block|{
name|T
modifier|*
name|OldEnd
init|=
name|this
operator|->
name|end
argument_list|()
decl_stmt|;
name|append
argument_list|(
name|C
argument_list|,
name|this
operator|->
name|end
argument_list|()
operator|-
name|NumToInsert
argument_list|,
name|this
operator|->
name|end
argument_list|()
argument_list|)
expr_stmt|;
comment|// Copy the existing elements that get replaced.
name|std
operator|::
name|copy_backward
argument_list|(
name|I
argument_list|,
name|OldEnd
operator|-
name|NumToInsert
argument_list|,
name|OldEnd
argument_list|)
expr_stmt|;
name|std
operator|::
name|fill_n
argument_list|(
name|I
argument_list|,
name|NumToInsert
argument_list|,
name|Elt
argument_list|)
expr_stmt|;
return|return
name|I
return|;
block|}
comment|// Otherwise, we're inserting more elements than exist already, and we're
comment|// not inserting at the end.
comment|// Copy over the elements that we're about to overwrite.
name|T
modifier|*
name|OldEnd
init|=
name|this
operator|->
name|end
argument_list|()
decl_stmt|;
name|this
operator|->
name|setEnd
argument_list|(
name|this
operator|->
name|end
argument_list|()
operator|+
name|NumToInsert
argument_list|)
expr_stmt|;
name|size_t
name|NumOverwritten
init|=
name|OldEnd
operator|-
name|I
decl_stmt|;
name|this
operator|->
name|uninitialized_copy
argument_list|(
name|I
argument_list|,
name|OldEnd
argument_list|,
name|this
operator|->
name|end
argument_list|()
operator|-
name|NumOverwritten
argument_list|)
expr_stmt|;
comment|// Replace the overwritten part.
name|std
operator|::
name|fill_n
argument_list|(
name|I
argument_list|,
name|NumOverwritten
argument_list|,
name|Elt
argument_list|)
expr_stmt|;
comment|// Insert the non-overwritten middle part.
name|std
operator|::
name|uninitialized_fill_n
argument_list|(
name|OldEnd
argument_list|,
name|NumToInsert
operator|-
name|NumOverwritten
argument_list|,
name|Elt
argument_list|)
expr_stmt|;
return|return
name|I
return|;
block|}
end_block

begin_expr_stmt
name|template
operator|<
name|typename
name|ItTy
operator|>
name|iterator
name|insert
argument_list|(
argument|const ASTContext&C
argument_list|,
argument|iterator I
argument_list|,
argument|ItTy From
argument_list|,
argument|ItTy To
argument_list|)
block|{
comment|// Convert iterator to elt# to avoid invalidating iterator when we reserve()
name|size_t
name|InsertElt
operator|=
name|I
operator|-
name|this
operator|->
name|begin
argument_list|()
block|;
if|if
condition|(
name|I
operator|==
name|this
operator|->
name|end
argument_list|()
condition|)
block|{
comment|// Important special case for empty vector.
name|append
argument_list|(
name|C
argument_list|,
name|From
argument_list|,
name|To
argument_list|)
expr_stmt|;
return|return
name|this
operator|->
name|begin
argument_list|()
operator|+
name|InsertElt
return|;
block|}
name|size_t
name|NumToInsert
operator|=
name|std
operator|::
name|distance
argument_list|(
name|From
argument_list|,
name|To
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|// Ensure there is enough space.
end_comment

begin_expr_stmt
name|reserve
argument_list|(
name|C
argument_list|,
name|static_cast
operator|<
name|unsigned
operator|>
operator|(
name|this
operator|->
name|size
argument_list|()
operator|+
name|NumToInsert
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|// Uninvalidate the iterator.
end_comment

begin_expr_stmt
name|I
operator|=
name|this
operator|->
name|begin
argument_list|()
operator|+
name|InsertElt
expr_stmt|;
end_expr_stmt

begin_comment
comment|// If there are more elements between the insertion point and the end of the
end_comment

begin_comment
comment|// range than there are being inserted, we can use a simple approach to
end_comment

begin_comment
comment|// insertion.  Since we already reserved space, we know that this won't
end_comment

begin_comment
comment|// reallocate the vector.
end_comment

begin_if
if|if
condition|(
name|size_t
argument_list|(
name|this
operator|->
name|end
argument_list|()
operator|-
name|I
argument_list|)
operator|>=
name|NumToInsert
condition|)
block|{
name|T
modifier|*
name|OldEnd
init|=
name|this
operator|->
name|end
argument_list|()
decl_stmt|;
name|append
argument_list|(
name|C
argument_list|,
name|this
operator|->
name|end
argument_list|()
operator|-
name|NumToInsert
argument_list|,
name|this
operator|->
name|end
argument_list|()
argument_list|)
expr_stmt|;
comment|// Copy the existing elements that get replaced.
name|std
operator|::
name|copy_backward
argument_list|(
name|I
argument_list|,
name|OldEnd
operator|-
name|NumToInsert
argument_list|,
name|OldEnd
argument_list|)
expr_stmt|;
name|std
operator|::
name|copy
argument_list|(
name|From
argument_list|,
name|To
argument_list|,
name|I
argument_list|)
expr_stmt|;
return|return
name|I
return|;
block|}
end_if

begin_comment
comment|// Otherwise, we're inserting more elements than exist already, and we're
end_comment

begin_comment
comment|// not inserting at the end.
end_comment

begin_comment
comment|// Copy over the elements that we're about to overwrite.
end_comment

begin_decl_stmt
name|T
modifier|*
name|OldEnd
init|=
name|this
operator|->
name|end
argument_list|()
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|this
operator|->
name|setEnd
argument_list|(
name|this
operator|->
name|end
argument_list|()
operator|+
name|NumToInsert
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|size_t
name|NumOverwritten
init|=
name|OldEnd
operator|-
name|I
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|this
operator|->
name|uninitialized_copy
argument_list|(
name|I
argument_list|,
name|OldEnd
argument_list|,
name|this
operator|->
name|end
argument_list|()
operator|-
name|NumOverwritten
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|// Replace the overwritten part.
end_comment

begin_for
for|for
control|(
init|;
name|NumOverwritten
operator|>
literal|0
condition|;
operator|--
name|NumOverwritten
control|)
block|{
operator|*
name|I
operator|=
operator|*
name|From
expr_stmt|;
operator|++
name|I
expr_stmt|;
operator|++
name|From
expr_stmt|;
block|}
end_for

begin_comment
comment|// Insert the non-overwritten middle part.
end_comment

begin_expr_stmt
name|this
operator|->
name|uninitialized_copy
argument_list|(
name|From
argument_list|,
name|To
argument_list|,
name|OldEnd
argument_list|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|I
return|;
end_return

begin_macro
unit|}    void
name|resize
argument_list|(
argument|const ASTContext&C
argument_list|,
argument|unsigned N
argument_list|,
argument|const T&NV
argument_list|)
end_macro

begin_block
block|{
if|if
condition|(
name|N
operator|<
name|this
operator|->
name|size
argument_list|()
condition|)
block|{
name|this
operator|->
name|destroy_range
argument_list|(
name|this
operator|->
name|begin
argument_list|()
operator|+
name|N
argument_list|,
name|this
operator|->
name|end
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|->
name|setEnd
argument_list|(
name|this
operator|->
name|begin
argument_list|()
operator|+
name|N
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|N
operator|>
name|this
operator|->
name|size
argument_list|()
condition|)
block|{
if|if
condition|(
name|this
operator|->
name|capacity
argument_list|()
operator|<
name|N
condition|)
name|this
operator|->
name|grow
argument_list|(
name|C
argument_list|,
name|N
argument_list|)
expr_stmt|;
name|construct_range
argument_list|(
name|this
operator|->
name|end
argument_list|()
argument_list|,
name|this
operator|->
name|begin
argument_list|()
operator|+
name|N
argument_list|,
name|NV
argument_list|)
expr_stmt|;
name|this
operator|->
name|setEnd
argument_list|(
name|this
operator|->
name|begin
argument_list|()
operator|+
name|N
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_label
name|private
label|:
end_label

begin_comment
comment|/// grow - double the size of the allocated memory, guaranteeing space for at
end_comment

begin_comment
comment|/// least one more element or MinSize if specified.
end_comment

begin_function_decl
name|void
name|grow
parameter_list|(
specifier|const
name|ASTContext
modifier|&
name|C
parameter_list|,
name|size_type
name|MinSize
init|=
literal|1
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|void
name|construct_range
parameter_list|(
name|T
modifier|*
name|S
parameter_list|,
name|T
modifier|*
name|E
parameter_list|,
specifier|const
name|T
modifier|&
name|Elt
parameter_list|)
block|{
for|for
control|(
init|;
name|S
operator|!=
name|E
condition|;
operator|++
name|S
control|)
name|new
argument_list|(
argument|S
argument_list|)
name|T
argument_list|(
name|Elt
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|destroy_range
parameter_list|(
name|T
modifier|*
name|S
parameter_list|,
name|T
modifier|*
name|E
parameter_list|)
block|{
while|while
condition|(
name|S
operator|!=
name|E
condition|)
block|{
operator|--
name|E
expr_stmt|;
name|E
operator|->
expr|~
name|T
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_label
name|protected
label|:
end_label

begin_expr_stmt
name|const_iterator
name|capacity_ptr
argument_list|()
specifier|const
block|{
return|return
operator|(
name|iterator
operator|)
name|Capacity
operator|.
name|getPointer
argument_list|()
return|;
block|}
end_expr_stmt

begin_function
name|iterator
name|capacity_ptr
parameter_list|()
block|{
return|return
operator|(
name|iterator
operator|)
name|Capacity
operator|.
name|getPointer
argument_list|()
return|;
block|}
end_function

begin_comment
unit|};
comment|// Define this out-of-line to dissuade the C++ compiler from inlining it.
end_comment

begin_expr_stmt
name|template
operator|<
name|typename
name|T
operator|>
name|void
name|ASTVector
operator|<
name|T
operator|>
operator|::
name|grow
argument_list|(
argument|const ASTContext&C
argument_list|,
argument|size_t MinSize
argument_list|)
block|{
name|size_t
name|CurCapacity
operator|=
name|this
operator|->
name|capacity
argument_list|()
block|;
name|size_t
name|CurSize
operator|=
name|size
argument_list|()
block|;
name|size_t
name|NewCapacity
operator|=
literal|2
operator|*
name|CurCapacity
block|;
if|if
condition|(
name|NewCapacity
operator|<
name|MinSize
condition|)
name|NewCapacity
operator|=
name|MinSize
expr_stmt|;
comment|// Allocate the memory from the ASTContext.
name|T
operator|*
name|NewElts
operator|=
name|new
argument_list|(
argument|C
argument_list|,
argument|alignof(T)
argument_list|)
name|T
index|[
name|NewCapacity
index|]
expr_stmt|;
end_expr_stmt

begin_comment
comment|// Copy the elements over.
end_comment

begin_if
if|if
condition|(
name|Begin
operator|!=
name|End
condition|)
block|{
if|if
condition|(
name|std
operator|::
name|is_class
operator|<
name|T
operator|>
operator|::
name|value
condition|)
block|{
name|std
operator|::
name|uninitialized_copy
argument_list|(
name|Begin
argument_list|,
name|End
argument_list|,
name|NewElts
argument_list|)
expr_stmt|;
comment|// Destroy the original elements.
name|destroy_range
argument_list|(
name|Begin
argument_list|,
name|End
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// Use memcpy for PODs (std::uninitialized_copy optimizes to memmove).
name|memcpy
argument_list|(
name|NewElts
argument_list|,
name|Begin
argument_list|,
name|CurSize
operator|*
sizeof|sizeof
argument_list|(
name|T
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_if

begin_comment
comment|// ASTContext never frees any memory.
end_comment

begin_expr_stmt
name|Begin
operator|=
name|NewElts
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|End
operator|=
name|NewElts
operator|+
name|CurSize
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|Capacity
operator|.
name|setPointer
argument_list|(
name|Begin
operator|+
name|NewCapacity
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
unit|}  }
comment|// end: clang namespace
end_comment

begin_endif
endif|#
directive|endif
end_endif

end_unit

