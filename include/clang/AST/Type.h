begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===--- Type.h - C Language Family Type Representation ---------*- C++ -*-===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//  This file defines the Type interface and subclasses.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LLVM_CLANG_AST_TYPE_H
end_ifndef

begin_define
define|#
directive|define
name|LLVM_CLANG_AST_TYPE_H
end_define

begin_include
include|#
directive|include
file|"clang/Basic/Diagnostic.h"
end_include

begin_include
include|#
directive|include
file|"clang/Basic/IdentifierTable.h"
end_include

begin_include
include|#
directive|include
file|"clang/AST/NestedNameSpecifier.h"
end_include

begin_include
include|#
directive|include
file|"clang/AST/TemplateName.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/Casting.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/type_traits.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/APSInt.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/FoldingSet.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/PointerIntPair.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/PointerUnion.h"
end_include

begin_expr_stmt
name|using
name|llvm
operator|::
name|isa
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|using
name|llvm
operator|::
name|cast
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|using
name|llvm
operator|::
name|cast_or_null
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|using
name|llvm
operator|::
name|dyn_cast
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|using
name|llvm
operator|::
name|dyn_cast_or_null
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|namespace
name|clang
block|{
enum|enum
block|{
name|TypeAlignmentInBits
init|=
literal|3
block|,
name|TypeAlignment
init|=
literal|1
operator|<<
name|TypeAlignmentInBits
block|}
enum|;
name|class
name|Type
decl_stmt|;
name|class
name|ExtQuals
decl_stmt|;
block|}
end_decl_stmt

begin_decl_stmt
name|namespace
name|llvm
block|{
name|template
operator|<
name|typename
name|T
operator|>
name|class
name|PointerLikeTypeTraits
expr_stmt|;
name|template
operator|<
operator|>
name|class
name|PointerLikeTypeTraits
operator|<
operator|::
name|clang
operator|::
name|Type
operator|*
operator|>
block|{
name|public
operator|:
specifier|static
specifier|inline
name|void
operator|*
name|getAsVoidPointer
argument_list|(
argument|::clang::Type *P
argument_list|)
block|{
return|return
name|P
return|;
block|}
specifier|static
specifier|inline
operator|::
name|clang
operator|::
name|Type
operator|*
name|getFromVoidPointer
argument_list|(
argument|void *P
argument_list|)
block|{
return|return
name|static_cast
operator|<
operator|::
name|clang
operator|::
name|Type
operator|*
operator|>
operator|(
name|P
operator|)
return|;
block|}
expr|enum
block|{
name|NumLowBitsAvailable
operator|=
name|clang
operator|::
name|TypeAlignmentInBits
block|}
block|;   }
expr_stmt|;
name|template
operator|<
operator|>
name|class
name|PointerLikeTypeTraits
operator|<
operator|::
name|clang
operator|::
name|ExtQuals
operator|*
operator|>
block|{
name|public
operator|:
specifier|static
specifier|inline
name|void
operator|*
name|getAsVoidPointer
argument_list|(
argument|::clang::ExtQuals *P
argument_list|)
block|{
return|return
name|P
return|;
block|}
specifier|static
specifier|inline
operator|::
name|clang
operator|::
name|ExtQuals
operator|*
name|getFromVoidPointer
argument_list|(
argument|void *P
argument_list|)
block|{
return|return
name|static_cast
operator|<
operator|::
name|clang
operator|::
name|ExtQuals
operator|*
operator|>
operator|(
name|P
operator|)
return|;
block|}
expr|enum
block|{
name|NumLowBitsAvailable
operator|=
name|clang
operator|::
name|TypeAlignmentInBits
block|}
block|;   }
expr_stmt|;
block|}
end_decl_stmt

begin_decl_stmt
name|namespace
name|clang
block|{
name|class
name|ASTContext
decl_stmt|;
name|class
name|TypedefDecl
decl_stmt|;
name|class
name|TemplateDecl
decl_stmt|;
name|class
name|TemplateTypeParmDecl
decl_stmt|;
name|class
name|NonTypeTemplateParmDecl
decl_stmt|;
name|class
name|TemplateTemplateParmDecl
decl_stmt|;
name|class
name|TagDecl
decl_stmt|;
name|class
name|RecordDecl
decl_stmt|;
name|class
name|CXXRecordDecl
decl_stmt|;
name|class
name|EnumDecl
decl_stmt|;
name|class
name|FieldDecl
decl_stmt|;
name|class
name|ObjCInterfaceDecl
decl_stmt|;
name|class
name|ObjCProtocolDecl
decl_stmt|;
name|class
name|ObjCMethodDecl
decl_stmt|;
name|class
name|Expr
decl_stmt|;
name|class
name|Stmt
decl_stmt|;
name|class
name|SourceLocation
decl_stmt|;
name|class
name|StmtIteratorBase
decl_stmt|;
name|class
name|TemplateArgument
decl_stmt|;
name|class
name|QualifiedNameType
decl_stmt|;
struct_decl|struct
name|PrintingPolicy
struct_decl|;
comment|// Provide forward declarations for all of the *Type classes
define|#
directive|define
name|TYPE
parameter_list|(
name|Class
parameter_list|,
name|Base
parameter_list|)
value|class Class##Type;
include|#
directive|include
file|"clang/AST/TypeNodes.def"
comment|/// Qualifiers - The collection of all-type qualifiers we support.
comment|/// Clang supports five independent qualifiers:
comment|/// * C99: const, volatile, and restrict
comment|/// * Embedded C (TR18037): address spaces
comment|/// * Objective C: the GC attributes (none, weak, or strong)
name|class
name|Qualifiers
block|{
name|public
label|:
enum|enum
name|TQ
block|{
comment|// NOTE: These flags must be kept in sync with DeclSpec::TQ.
name|Const
init|=
literal|0x1
block|,
name|Restrict
init|=
literal|0x2
block|,
name|Volatile
init|=
literal|0x4
block|,
name|CVRMask
init|=
name|Const
operator||
name|Volatile
operator||
name|Restrict
block|}
enum|;
enum|enum
name|GC
block|{
name|GCNone
init|=
literal|0
block|,
name|Weak
block|,
name|Strong
block|}
enum|;
enum|enum
block|{
comment|/// The maximum supported address space number.
comment|/// 24 bits should be enough for anyone.
name|MaxAddressSpace
init|=
literal|0xffffffu
block|,
comment|/// The width of the "fast" qualifier mask.
name|FastWidth
init|=
literal|2
block|,
comment|/// The fast qualifier mask.
name|FastMask
init|=
operator|(
literal|1
operator|<<
name|FastWidth
operator|)
operator|-
literal|1
block|}
enum|;
name|Qualifiers
argument_list|()
operator|:
name|Mask
argument_list|(
literal|0
argument_list|)
block|{}
specifier|static
name|Qualifiers
name|fromFastMask
argument_list|(
argument|unsigned Mask
argument_list|)
block|{
name|Qualifiers
name|Qs
block|;
name|Qs
operator|.
name|addFastQualifiers
argument_list|(
name|Mask
argument_list|)
block|;
return|return
name|Qs
return|;
block|}
specifier|static
name|Qualifiers
name|fromCVRMask
parameter_list|(
name|unsigned
name|CVR
parameter_list|)
block|{
name|Qualifiers
name|Qs
decl_stmt|;
name|Qs
operator|.
name|addCVRQualifiers
argument_list|(
name|CVR
argument_list|)
expr_stmt|;
return|return
name|Qs
return|;
block|}
comment|// Deserialize qualifiers from an opaque representation.
specifier|static
name|Qualifiers
name|fromOpaqueValue
parameter_list|(
name|unsigned
name|opaque
parameter_list|)
block|{
name|Qualifiers
name|Qs
decl_stmt|;
name|Qs
operator|.
name|Mask
operator|=
name|opaque
expr_stmt|;
return|return
name|Qs
return|;
block|}
comment|// Serialize these qualifiers into an opaque representation.
name|unsigned
name|getAsOpaqueValue
argument_list|()
specifier|const
block|{
return|return
name|Mask
return|;
block|}
name|bool
name|hasConst
argument_list|()
specifier|const
block|{
return|return
name|Mask
operator|&
name|Const
return|;
block|}
name|void
name|setConst
parameter_list|(
name|bool
name|flag
parameter_list|)
block|{
name|Mask
operator|=
operator|(
name|Mask
operator|&
operator|~
name|Const
operator|)
operator||
operator|(
name|flag
condition|?
name|Const
else|:
literal|0
operator|)
expr_stmt|;
block|}
name|void
name|removeConst
parameter_list|()
block|{
name|Mask
operator|&=
operator|~
name|Const
expr_stmt|;
block|}
name|void
name|addConst
parameter_list|()
block|{
name|Mask
operator||=
name|Const
expr_stmt|;
block|}
name|bool
name|hasVolatile
argument_list|()
specifier|const
block|{
return|return
name|Mask
operator|&
name|Volatile
return|;
block|}
name|void
name|setVolatile
parameter_list|(
name|bool
name|flag
parameter_list|)
block|{
name|Mask
operator|=
operator|(
name|Mask
operator|&
operator|~
name|Volatile
operator|)
operator||
operator|(
name|flag
condition|?
name|Volatile
else|:
literal|0
operator|)
expr_stmt|;
block|}
name|void
name|removeVolatile
parameter_list|()
block|{
name|Mask
operator|&=
operator|~
name|Volatile
expr_stmt|;
block|}
name|void
name|addVolatile
parameter_list|()
block|{
name|Mask
operator||=
name|Volatile
expr_stmt|;
block|}
name|bool
name|hasRestrict
argument_list|()
specifier|const
block|{
return|return
name|Mask
operator|&
name|Restrict
return|;
block|}
name|void
name|setRestrict
parameter_list|(
name|bool
name|flag
parameter_list|)
block|{
name|Mask
operator|=
operator|(
name|Mask
operator|&
operator|~
name|Restrict
operator|)
operator||
operator|(
name|flag
condition|?
name|Restrict
else|:
literal|0
operator|)
expr_stmt|;
block|}
name|void
name|removeRestrict
parameter_list|()
block|{
name|Mask
operator|&=
operator|~
name|Restrict
expr_stmt|;
block|}
name|void
name|addRestrict
parameter_list|()
block|{
name|Mask
operator||=
name|Restrict
expr_stmt|;
block|}
name|bool
name|hasCVRQualifiers
argument_list|()
specifier|const
block|{
return|return
name|getCVRQualifiers
argument_list|()
return|;
block|}
name|unsigned
name|getCVRQualifiers
argument_list|()
specifier|const
block|{
return|return
name|Mask
operator|&
name|CVRMask
return|;
block|}
name|void
name|setCVRQualifiers
parameter_list|(
name|unsigned
name|mask
parameter_list|)
block|{
name|assert
argument_list|(
operator|!
operator|(
name|mask
operator|&
operator|~
name|CVRMask
operator|)
operator|&&
literal|"bitmask contains non-CVR bits"
argument_list|)
expr_stmt|;
name|Mask
operator|=
operator|(
name|Mask
operator|&
operator|~
name|CVRMask
operator|)
operator||
name|mask
expr_stmt|;
block|}
name|void
name|removeCVRQualifiers
parameter_list|(
name|unsigned
name|mask
parameter_list|)
block|{
name|assert
argument_list|(
operator|!
operator|(
name|mask
operator|&
operator|~
name|CVRMask
operator|)
operator|&&
literal|"bitmask contains non-CVR bits"
argument_list|)
expr_stmt|;
name|Mask
operator|&=
operator|~
name|mask
expr_stmt|;
block|}
name|void
name|removeCVRQualifiers
parameter_list|()
block|{
name|removeCVRQualifiers
argument_list|(
name|CVRMask
argument_list|)
expr_stmt|;
block|}
name|void
name|addCVRQualifiers
parameter_list|(
name|unsigned
name|mask
parameter_list|)
block|{
name|assert
argument_list|(
operator|!
operator|(
name|mask
operator|&
operator|~
name|CVRMask
operator|)
operator|&&
literal|"bitmask contains non-CVR bits"
argument_list|)
expr_stmt|;
name|Mask
operator||=
name|mask
expr_stmt|;
block|}
name|bool
name|hasObjCGCAttr
argument_list|()
specifier|const
block|{
return|return
name|Mask
operator|&
name|GCAttrMask
return|;
block|}
name|GC
name|getObjCGCAttr
argument_list|()
specifier|const
block|{
return|return
name|GC
argument_list|(
operator|(
name|Mask
operator|&
name|GCAttrMask
operator|)
operator|>>
name|GCAttrShift
argument_list|)
return|;
block|}
name|void
name|setObjCGCAttr
parameter_list|(
name|GC
name|type
parameter_list|)
block|{
name|Mask
operator|=
operator|(
name|Mask
operator|&
operator|~
name|GCAttrMask
operator|)
operator||
operator|(
name|type
operator|<<
name|GCAttrShift
operator|)
expr_stmt|;
block|}
name|void
name|removeObjCGCAttr
parameter_list|()
block|{
name|setObjCGCAttr
argument_list|(
name|GCNone
argument_list|)
expr_stmt|;
block|}
name|void
name|addObjCGCAttr
parameter_list|(
name|GC
name|type
parameter_list|)
block|{
name|assert
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|setObjCGCAttr
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
name|bool
name|hasAddressSpace
argument_list|()
specifier|const
block|{
return|return
name|Mask
operator|&
name|AddressSpaceMask
return|;
block|}
name|unsigned
name|getAddressSpace
argument_list|()
specifier|const
block|{
return|return
name|Mask
operator|>>
name|AddressSpaceShift
return|;
block|}
name|void
name|setAddressSpace
parameter_list|(
name|unsigned
name|space
parameter_list|)
block|{
name|assert
argument_list|(
name|space
operator|<=
name|MaxAddressSpace
argument_list|)
expr_stmt|;
name|Mask
operator|=
operator|(
name|Mask
operator|&
operator|~
name|AddressSpaceMask
operator|)
operator||
operator|(
operator|(
operator|(
name|uint32_t
operator|)
name|space
operator|)
operator|<<
name|AddressSpaceShift
operator|)
expr_stmt|;
block|}
name|void
name|removeAddressSpace
parameter_list|()
block|{
name|setAddressSpace
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
name|void
name|addAddressSpace
parameter_list|(
name|unsigned
name|space
parameter_list|)
block|{
name|assert
argument_list|(
name|space
argument_list|)
expr_stmt|;
name|setAddressSpace
argument_list|(
name|space
argument_list|)
expr_stmt|;
block|}
comment|// Fast qualifiers are those that can be allocated directly
comment|// on a QualType object.
name|bool
name|hasFastQualifiers
argument_list|()
specifier|const
block|{
return|return
name|getFastQualifiers
argument_list|()
return|;
block|}
name|unsigned
name|getFastQualifiers
argument_list|()
specifier|const
block|{
return|return
name|Mask
operator|&
name|FastMask
return|;
block|}
name|void
name|setFastQualifiers
parameter_list|(
name|unsigned
name|mask
parameter_list|)
block|{
name|assert
argument_list|(
operator|!
operator|(
name|mask
operator|&
operator|~
name|FastMask
operator|)
operator|&&
literal|"bitmask contains non-fast qualifier bits"
argument_list|)
expr_stmt|;
name|Mask
operator|=
operator|(
name|Mask
operator|&
operator|~
name|FastMask
operator|)
operator||
name|mask
expr_stmt|;
block|}
name|void
name|removeFastQualifiers
parameter_list|(
name|unsigned
name|mask
parameter_list|)
block|{
name|assert
argument_list|(
operator|!
operator|(
name|mask
operator|&
operator|~
name|FastMask
operator|)
operator|&&
literal|"bitmask contains non-fast qualifier bits"
argument_list|)
expr_stmt|;
name|Mask
operator|&=
operator|~
name|mask
expr_stmt|;
block|}
name|void
name|removeFastQualifiers
parameter_list|()
block|{
name|removeFastQualifiers
argument_list|(
name|FastMask
argument_list|)
expr_stmt|;
block|}
name|void
name|addFastQualifiers
parameter_list|(
name|unsigned
name|mask
parameter_list|)
block|{
name|assert
argument_list|(
operator|!
operator|(
name|mask
operator|&
operator|~
name|FastMask
operator|)
operator|&&
literal|"bitmask contains non-fast qualifier bits"
argument_list|)
expr_stmt|;
name|Mask
operator||=
name|mask
expr_stmt|;
block|}
comment|/// hasNonFastQualifiers - Return true if the set contains any
comment|/// qualifiers which require an ExtQuals node to be allocated.
name|bool
name|hasNonFastQualifiers
argument_list|()
specifier|const
block|{
return|return
name|Mask
operator|&
operator|~
name|FastMask
return|;
block|}
name|Qualifiers
name|getNonFastQualifiers
argument_list|()
specifier|const
block|{
name|Qualifiers
name|Quals
operator|=
operator|*
name|this
block|;
name|Quals
operator|.
name|setFastQualifiers
argument_list|(
literal|0
argument_list|)
block|;
return|return
name|Quals
return|;
block|}
comment|/// hasQualifiers - Return true if the set contains any qualifiers.
name|bool
name|hasQualifiers
argument_list|()
specifier|const
block|{
return|return
name|Mask
return|;
block|}
name|bool
name|empty
argument_list|()
specifier|const
block|{
return|return
operator|!
name|Mask
return|;
block|}
comment|/// \brief Add the qualifiers from the given set to this set.
name|void
name|addQualifiers
parameter_list|(
name|Qualifiers
name|Q
parameter_list|)
block|{
comment|// If the other set doesn't have any non-boolean qualifiers, just
comment|// bit-or it in.
if|if
condition|(
operator|!
operator|(
name|Q
operator|.
name|Mask
operator|&
operator|~
name|CVRMask
operator|)
condition|)
name|Mask
operator||=
name|Q
operator|.
name|Mask
expr_stmt|;
else|else
block|{
name|Mask
operator||=
operator|(
name|Q
operator|.
name|Mask
operator|&
name|CVRMask
operator|)
expr_stmt|;
if|if
condition|(
name|Q
operator|.
name|hasAddressSpace
argument_list|()
condition|)
name|addAddressSpace
argument_list|(
name|Q
operator|.
name|getAddressSpace
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|Q
operator|.
name|hasObjCGCAttr
argument_list|()
condition|)
name|addObjCGCAttr
argument_list|(
name|Q
operator|.
name|getObjCGCAttr
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
name|bool
name|operator
operator|==
operator|(
name|Qualifiers
name|Other
operator|)
specifier|const
block|{
return|return
name|Mask
operator|==
name|Other
operator|.
name|Mask
return|;
block|}
name|bool
name|operator
operator|!=
operator|(
name|Qualifiers
name|Other
operator|)
specifier|const
block|{
return|return
name|Mask
operator|!=
name|Other
operator|.
name|Mask
return|;
block|}
name|operator
name|bool
argument_list|()
specifier|const
block|{
return|return
name|hasQualifiers
argument_list|()
return|;
block|}
name|Qualifiers
operator|&
name|operator
operator|+=
operator|(
name|Qualifiers
name|R
operator|)
block|{
name|addQualifiers
argument_list|(
name|R
argument_list|)
block|;
return|return
operator|*
name|this
return|;
block|}
comment|// Union two qualifier sets.  If an enumerated qualifier appears
comment|// in both sets, use the one from the right.
name|friend
name|Qualifiers
name|operator
operator|+
operator|(
name|Qualifiers
name|L
operator|,
name|Qualifiers
name|R
operator|)
block|{
name|L
operator|+=
name|R
block|;
return|return
name|L
return|;
block|}
name|std
operator|::
name|string
name|getAsString
argument_list|()
specifier|const
expr_stmt|;
name|std
operator|::
name|string
name|getAsString
argument_list|(
argument|const PrintingPolicy&Policy
argument_list|)
specifier|const
block|{
name|std
operator|::
name|string
name|Buffer
block|;
name|getAsStringInternal
argument_list|(
name|Buffer
argument_list|,
name|Policy
argument_list|)
block|;
return|return
name|Buffer
return|;
block|}
name|void
name|getAsStringInternal
argument_list|(
name|std
operator|::
name|string
operator|&
name|S
argument_list|,
specifier|const
name|PrintingPolicy
operator|&
name|Policy
argument_list|)
decl|const
decl_stmt|;
name|void
name|Profile
argument_list|(
name|llvm
operator|::
name|FoldingSetNodeID
operator|&
name|ID
argument_list|)
decl|const
block|{
name|ID
operator|.
name|AddInteger
argument_list|(
name|Mask
argument_list|)
expr_stmt|;
block|}
name|private
label|:
comment|// bits:     |0 1 2|3 .. 4|5  ..  31|
comment|//           |C R V|GCAttr|AddrSpace|
name|uint32_t
name|Mask
decl_stmt|;
specifier|static
specifier|const
name|uint32_t
name|GCAttrMask
init|=
literal|0x18
decl_stmt|;
specifier|static
specifier|const
name|uint32_t
name|GCAttrShift
init|=
literal|3
decl_stmt|;
specifier|static
specifier|const
name|uint32_t
name|AddressSpaceMask
init|=
operator|~
operator|(
name|CVRMask
operator||
name|GCAttrMask
operator|)
decl_stmt|;
specifier|static
specifier|const
name|uint32_t
name|AddressSpaceShift
init|=
literal|5
decl_stmt|;
block|}
empty_stmt|;
comment|/// ExtQuals - We can encode up to three bits in the low bits of a
comment|/// type pointer, but there are many more type qualifiers that we want
comment|/// to be able to apply to an arbitrary type.  Therefore we have this
comment|/// struct, intended to be heap-allocated and used by QualType to
comment|/// store qualifiers.
comment|///
comment|/// The current design tags the 'const' and 'restrict' qualifiers in
comment|/// two low bits on the QualType pointer; a third bit records whether
comment|/// the pointer is an ExtQuals node.  'const' was chosen because it is
comment|/// orders of magnitude more common than the other two qualifiers, in
comment|/// both library and user code.  It's relatively rare to see
comment|/// 'restrict' in user code, but many standard C headers are saturated
comment|/// with 'restrict' declarations, so that representing them efficiently
comment|/// is a critical goal of this representation.
name|class
name|ExtQuals
range|:
name|public
name|llvm
operator|::
name|FoldingSetNode
block|{
comment|// NOTE: changing the fast qualifiers should be straightforward as
comment|// long as you don't make 'const' non-fast.
comment|// 1. Qualifiers:
comment|//    a) Modify the bitmasks (Qualifiers::TQ and DeclSpec::TQ).
comment|//       Fast qualifiers must occupy the low-order bits.
comment|//    b) Update Qualifiers::FastWidth and FastMask.
comment|// 2. QualType:
comment|//    a) Update is{Volatile,Restrict}Qualified(), defined inline.
comment|//    b) Update remove{Volatile,Restrict}, defined near the end of
comment|//       this header.
comment|// 3. ASTContext:
comment|//    a) Update get{Volatile,Restrict}Type.
comment|/// Context - the context to which this set belongs.  We save this
comment|/// here so that QualifierCollector can use it to reapply extended
comment|/// qualifiers to an arbitrary type without requiring a context to
comment|/// be pushed through every single API dealing with qualifiers.
name|ASTContext
operator|&
name|Context
block|;
comment|/// BaseType - the underlying type that this qualifies
specifier|const
name|Type
operator|*
name|BaseType
block|;
comment|/// Quals - the immutable set of qualifiers applied by this
comment|/// node;  always contains extended qualifiers.
name|Qualifiers
name|Quals
block|;
name|public
operator|:
name|ExtQuals
argument_list|(
argument|ASTContext& Context
argument_list|,
argument|const Type *Base
argument_list|,
argument|Qualifiers Quals
argument_list|)
operator|:
name|Context
argument_list|(
name|Context
argument_list|)
block|,
name|BaseType
argument_list|(
name|Base
argument_list|)
block|,
name|Quals
argument_list|(
argument|Quals
argument_list|)
block|{
name|assert
argument_list|(
name|Quals
operator|.
name|hasNonFastQualifiers
argument_list|()
operator|&&
literal|"ExtQuals created with no fast qualifiers"
argument_list|)
block|;
name|assert
argument_list|(
operator|!
name|Quals
operator|.
name|hasFastQualifiers
argument_list|()
operator|&&
literal|"ExtQuals created with fast qualifiers"
argument_list|)
block|;   }
name|Qualifiers
name|getQualifiers
argument_list|()
specifier|const
block|{
return|return
name|Quals
return|;
block|}
name|bool
name|hasVolatile
argument_list|()
specifier|const
block|{
return|return
name|Quals
operator|.
name|hasVolatile
argument_list|()
return|;
block|}
name|bool
name|hasObjCGCAttr
argument_list|()
specifier|const
block|{
return|return
name|Quals
operator|.
name|hasObjCGCAttr
argument_list|()
return|;
block|}
name|Qualifiers
operator|::
name|GC
name|getObjCGCAttr
argument_list|()
specifier|const
block|{
return|return
name|Quals
operator|.
name|getObjCGCAttr
argument_list|()
return|;
block|}
name|bool
name|hasAddressSpace
argument_list|()
specifier|const
block|{
return|return
name|Quals
operator|.
name|hasAddressSpace
argument_list|()
return|;
block|}
name|unsigned
name|getAddressSpace
argument_list|()
specifier|const
block|{
return|return
name|Quals
operator|.
name|getAddressSpace
argument_list|()
return|;
block|}
specifier|const
name|Type
operator|*
name|getBaseType
argument_list|()
specifier|const
block|{
return|return
name|BaseType
return|;
block|}
name|ASTContext
operator|&
name|getContext
argument_list|()
specifier|const
block|{
return|return
name|Context
return|;
block|}
name|public
operator|:
name|void
name|Profile
argument_list|(
argument|llvm::FoldingSetNodeID&ID
argument_list|)
specifier|const
block|{
name|Profile
argument_list|(
name|ID
argument_list|,
name|getBaseType
argument_list|()
argument_list|,
name|Quals
argument_list|)
block|;   }
specifier|static
name|void
name|Profile
argument_list|(
argument|llvm::FoldingSetNodeID&ID
argument_list|,
argument|const Type *BaseType
argument_list|,
argument|Qualifiers Quals
argument_list|)
block|{
name|assert
argument_list|(
operator|!
name|Quals
operator|.
name|hasFastQualifiers
argument_list|()
operator|&&
literal|"fast qualifiers in ExtQuals hash!"
argument_list|)
block|;
name|ID
operator|.
name|AddPointer
argument_list|(
name|BaseType
argument_list|)
block|;
name|Quals
operator|.
name|Profile
argument_list|(
name|ID
argument_list|)
block|;   }
expr|}
block|;
comment|/// QualType - For efficiency, we don't store CV-qualified types as nodes on
comment|/// their own: instead each reference to a type stores the qualifiers.  This
comment|/// greatly reduces the number of nodes we need to allocate for types (for
comment|/// example we only need one for 'int', 'const int', 'volatile int',
comment|/// 'const volatile int', etc).
comment|///
comment|/// As an added efficiency bonus, instead of making this a pair, we
comment|/// just store the two bits we care about in the low bits of the
comment|/// pointer.  To handle the packing/unpacking, we make QualType be a
comment|/// simple wrapper class that acts like a smart pointer.  A third bit
comment|/// indicates whether there are extended qualifiers present, in which
comment|/// case the pointer points to a special structure.
name|class
name|QualType
block|{
comment|// Thankfully, these are efficiently composable.
name|llvm
operator|::
name|PointerIntPair
operator|<
name|llvm
operator|::
name|PointerUnion
operator|<
specifier|const
name|Type
operator|*
block|,
specifier|const
name|ExtQuals
operator|*
operator|>
block|,
name|Qualifiers
operator|::
name|FastWidth
operator|>
name|Value
block|;
name|bool
name|hasExtQuals
argument_list|()
specifier|const
block|{
return|return
name|Value
operator|.
name|getPointer
argument_list|()
operator|.
name|is
operator|<
specifier|const
name|ExtQuals
operator|*
operator|>
operator|(
operator|)
return|;
block|}
specifier|const
name|ExtQuals
operator|*
name|getExtQualsUnsafe
argument_list|()
specifier|const
block|{
return|return
name|Value
operator|.
name|getPointer
argument_list|()
operator|.
name|get
operator|<
specifier|const
name|ExtQuals
operator|*
operator|>
operator|(
operator|)
return|;
block|}
specifier|const
name|Type
operator|*
name|getTypePtrUnsafe
argument_list|()
specifier|const
block|{
return|return
name|Value
operator|.
name|getPointer
argument_list|()
operator|.
name|get
operator|<
specifier|const
name|Type
operator|*
operator|>
operator|(
operator|)
return|;
block|}
name|friend
name|class
name|QualifierCollector
block|;
name|public
operator|:
name|QualType
argument_list|()
block|{}
name|QualType
argument_list|(
argument|const Type *Ptr
argument_list|,
argument|unsigned Quals
argument_list|)
operator|:
name|Value
argument_list|(
argument|Ptr
argument_list|,
argument|Quals
argument_list|)
block|{}
name|QualType
argument_list|(
argument|const ExtQuals *Ptr
argument_list|,
argument|unsigned Quals
argument_list|)
operator|:
name|Value
argument_list|(
argument|Ptr
argument_list|,
argument|Quals
argument_list|)
block|{}
name|unsigned
name|getFastQualifiers
argument_list|()
specifier|const
block|{
return|return
name|Value
operator|.
name|getInt
argument_list|()
return|;
block|}
name|void
name|setFastQualifiers
argument_list|(
argument|unsigned Quals
argument_list|)
block|{
name|Value
operator|.
name|setInt
argument_list|(
name|Quals
argument_list|)
block|; }
comment|/// Retrieves a pointer to the underlying (unqualified) type.
comment|/// This should really return a const Type, but it's not worth
comment|/// changing all the users right now.
name|Type
operator|*
name|getTypePtr
argument_list|()
specifier|const
block|{
if|if
condition|(
name|hasNonFastQualifiers
argument_list|()
condition|)
return|return
name|const_cast
operator|<
name|Type
operator|*
operator|>
operator|(
name|getExtQualsUnsafe
argument_list|()
operator|->
name|getBaseType
argument_list|()
operator|)
return|;
return|return
name|const_cast
operator|<
name|Type
operator|*
operator|>
operator|(
name|getTypePtrUnsafe
argument_list|()
operator|)
return|;
block|}
name|void
operator|*
name|getAsOpaquePtr
argument_list|()
specifier|const
block|{
return|return
name|Value
operator|.
name|getOpaqueValue
argument_list|()
return|;
block|}
specifier|static
name|QualType
name|getFromOpaquePtr
argument_list|(
argument|void *Ptr
argument_list|)
block|{
name|QualType
name|T
block|;
name|T
operator|.
name|Value
operator|.
name|setFromOpaqueValue
argument_list|(
name|Ptr
argument_list|)
block|;
return|return
name|T
return|;
block|}
name|Type
operator|&
name|operator
operator|*
operator|(
operator|)
specifier|const
block|{
return|return
operator|*
name|getTypePtr
argument_list|()
return|;
block|}
name|Type
operator|*
name|operator
operator|->
expr|(
block|)
specifier|const
block|{
return|return
name|getTypePtr
argument_list|()
return|;
block|}
comment|/// isNull - Return true if this QualType doesn't point to a type yet.
name|bool
name|isNull
argument_list|()
specifier|const
block|{
return|return
name|Value
operator|.
name|getPointer
argument_list|()
operator|.
name|isNull
argument_list|()
return|;
block|}
name|bool
name|isConstQualified
argument_list|()
specifier|const
block|{
return|return
operator|(
name|getFastQualifiers
argument_list|()
operator|&
name|Qualifiers
operator|::
name|Const
operator|)
return|;
block|}
name|bool
name|isRestrictQualified
argument_list|()
specifier|const
block|{
return|return
operator|(
name|getFastQualifiers
argument_list|()
operator|&
name|Qualifiers
operator|::
name|Restrict
operator|)
return|;
block|}
name|bool
name|isVolatileQualified
argument_list|()
specifier|const
block|{
return|return
operator|(
name|hasNonFastQualifiers
argument_list|()
operator|&&
name|getExtQualsUnsafe
argument_list|()
operator|->
name|hasVolatile
argument_list|()
operator|)
return|;
block|}
comment|// Determines whether this type has any direct qualifiers.
name|bool
name|hasQualifiers
argument_list|()
specifier|const
block|{
return|return
name|getFastQualifiers
argument_list|()
operator|||
name|hasNonFastQualifiers
argument_list|()
return|;
block|}
name|bool
name|hasNonFastQualifiers
argument_list|()
specifier|const
block|{
return|return
name|hasExtQuals
argument_list|()
return|;
block|}
comment|// Retrieves the set of qualifiers belonging to this type.
name|Qualifiers
name|getQualifiers
argument_list|()
specifier|const
block|{
name|Qualifiers
name|Quals
block|;
if|if
condition|(
name|hasNonFastQualifiers
argument_list|()
condition|)
name|Quals
operator|=
name|getExtQualsUnsafe
argument_list|()
operator|->
name|getQualifiers
argument_list|()
expr_stmt|;
name|Quals
operator|.
name|addFastQualifiers
argument_list|(
name|getFastQualifiers
argument_list|()
argument_list|)
decl_stmt|;
return|return
name|Quals
return|;
block|}
end_decl_stmt

begin_comment
comment|// Retrieves the CVR qualifiers of this type.
end_comment

begin_expr_stmt
name|unsigned
name|getCVRQualifiers
argument_list|()
specifier|const
block|{
name|unsigned
name|CVR
operator|=
name|getFastQualifiers
argument_list|()
block|;
if|if
condition|(
name|isVolatileQualified
argument_list|()
condition|)
name|CVR
operator||=
name|Qualifiers
operator|::
name|Volatile
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|CVR
return|;
end_return

begin_macro
unit|}    bool
name|isConstant
argument_list|(
argument|ASTContext& Ctx
argument_list|)
end_macro

begin_expr_stmt
specifier|const
block|{
return|return
name|QualType
operator|::
name|isConstant
argument_list|(
operator|*
name|this
argument_list|,
name|Ctx
argument_list|)
return|;
block|}
end_expr_stmt

begin_comment
comment|// Don't promise in the API that anything besides 'const' can be
end_comment

begin_comment
comment|// easily added.
end_comment

begin_comment
comment|/// addConst - add the specified type qualifier to this QualType.
end_comment

begin_function
name|void
name|addConst
parameter_list|()
block|{
name|addFastQualifiers
argument_list|(
name|Qualifiers
operator|::
name|Const
argument_list|)
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|QualType
name|withConst
argument_list|()
specifier|const
block|{
return|return
name|withFastQualifiers
argument_list|(
name|Qualifiers
operator|::
name|Const
argument_list|)
return|;
block|}
end_expr_stmt

begin_function
name|void
name|addFastQualifiers
parameter_list|(
name|unsigned
name|TQs
parameter_list|)
block|{
name|assert
argument_list|(
operator|!
operator|(
name|TQs
operator|&
operator|~
name|Qualifiers
operator|::
name|FastMask
operator|)
operator|&&
literal|"non-fast qualifier bits set in mask!"
argument_list|)
expr_stmt|;
name|Value
operator|.
name|setInt
argument_list|(
name|Value
operator|.
name|getInt
argument_list|()
operator||
name|TQs
argument_list|)
expr_stmt|;
block|}
end_function

begin_function_decl
name|void
name|removeConst
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|removeVolatile
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|removeRestrict
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|removeCVRQualifiers
parameter_list|(
name|unsigned
name|Mask
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|void
name|removeFastQualifiers
parameter_list|()
block|{
name|Value
operator|.
name|setInt
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|removeFastQualifiers
parameter_list|(
name|unsigned
name|Mask
parameter_list|)
block|{
name|assert
argument_list|(
operator|!
operator|(
name|Mask
operator|&
operator|~
name|Qualifiers
operator|::
name|FastMask
operator|)
operator|&&
literal|"mask has non-fast qualifiers"
argument_list|)
expr_stmt|;
name|Value
operator|.
name|setInt
argument_list|(
name|Value
operator|.
name|getInt
argument_list|()
operator|&
operator|~
name|Mask
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|// Creates a type with the given qualifiers in addition to any
end_comment

begin_comment
comment|// qualifiers already on this type.
end_comment

begin_decl_stmt
name|QualType
name|withFastQualifiers
argument_list|(
name|unsigned
name|TQs
argument_list|)
decl|const
block|{
name|QualType
name|T
init|=
operator|*
name|this
decl_stmt|;
name|T
operator|.
name|addFastQualifiers
argument_list|(
name|TQs
argument_list|)
expr_stmt|;
return|return
name|T
return|;
block|}
end_decl_stmt

begin_comment
comment|// Creates a type with exactly the given fast qualifiers, removing
end_comment

begin_comment
comment|// any existing fast qualifiers.
end_comment

begin_decl_stmt
name|QualType
name|withExactFastQualifiers
argument_list|(
name|unsigned
name|TQs
argument_list|)
decl|const
block|{
return|return
name|withoutFastQualifiers
argument_list|()
operator|.
name|withFastQualifiers
argument_list|(
name|TQs
argument_list|)
return|;
block|}
end_decl_stmt

begin_comment
comment|// Removes fast qualifiers, but leaves any extended qualifiers in place.
end_comment

begin_expr_stmt
name|QualType
name|withoutFastQualifiers
argument_list|()
specifier|const
block|{
name|QualType
name|T
operator|=
operator|*
name|this
block|;
name|T
operator|.
name|removeFastQualifiers
argument_list|()
block|;
return|return
name|T
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|QualType
name|getUnqualifiedType
argument_list|()
specifier|const
block|{
return|return
name|QualType
argument_list|(
name|getTypePtr
argument_list|()
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_expr_stmt

begin_decl_stmt
name|bool
name|isMoreQualifiedThan
argument_list|(
name|QualType
name|Other
argument_list|)
decl|const
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|bool
name|isAtLeastAsQualifiedAs
argument_list|(
name|QualType
name|Other
argument_list|)
decl|const
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|QualType
name|getNonReferenceType
argument_list|()
specifier|const
expr_stmt|;
end_expr_stmt

begin_comment
comment|/// getDesugaredType - Return the specified type with any "sugar" removed from
end_comment

begin_comment
comment|/// the type.  This takes off typedefs, typeof's etc.  If the outer level of
end_comment

begin_comment
comment|/// the type is already concrete, it returns it unmodified.  This is similar
end_comment

begin_comment
comment|/// to getting the canonical type, but it doesn't remove *all* typedefs.  For
end_comment

begin_comment
comment|/// example, it returns "T*" as "T*", (not as "int*"), because the pointer is
end_comment

begin_comment
comment|/// concrete.
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|/// Qualifiers are left in place.
end_comment

begin_expr_stmt
name|QualType
name|getDesugaredType
argument_list|()
specifier|const
block|{
return|return
name|QualType
operator|::
name|getDesugaredType
argument_list|(
operator|*
name|this
argument_list|)
return|;
block|}
end_expr_stmt

begin_comment
comment|/// operator==/!= - Indicate whether the specified types and qualifiers are
end_comment

begin_comment
comment|/// identical.
end_comment

begin_expr_stmt
name|friend
name|bool
name|operator
operator|==
operator|(
specifier|const
name|QualType
operator|&
name|LHS
operator|,
specifier|const
name|QualType
operator|&
name|RHS
operator|)
block|{
return|return
name|LHS
operator|.
name|Value
operator|==
name|RHS
operator|.
name|Value
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|friend
name|bool
name|operator
operator|!=
operator|(
specifier|const
name|QualType
operator|&
name|LHS
operator|,
specifier|const
name|QualType
operator|&
name|RHS
operator|)
block|{
return|return
name|LHS
operator|.
name|Value
operator|!=
name|RHS
operator|.
name|Value
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|std
operator|::
name|string
name|getAsString
argument_list|()
specifier|const
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|std
operator|::
name|string
name|getAsString
argument_list|(
argument|const PrintingPolicy&Policy
argument_list|)
specifier|const
block|{
name|std
operator|::
name|string
name|S
block|;
name|getAsStringInternal
argument_list|(
name|S
argument_list|,
name|Policy
argument_list|)
block|;
return|return
name|S
return|;
block|}
end_expr_stmt

begin_decl_stmt
name|void
name|getAsStringInternal
argument_list|(
name|std
operator|::
name|string
operator|&
name|Str
argument_list|,
specifier|const
name|PrintingPolicy
operator|&
name|Policy
argument_list|)
decl|const
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|dump
argument_list|(
specifier|const
name|char
operator|*
name|s
argument_list|)
decl|const
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|void
name|dump
argument_list|()
specifier|const
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|void
name|Profile
argument_list|(
name|llvm
operator|::
name|FoldingSetNodeID
operator|&
name|ID
argument_list|)
decl|const
block|{
name|ID
operator|.
name|AddPointer
argument_list|(
name|getAsOpaquePtr
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_comment
comment|/// getAddressSpace - Return the address space of this type.
end_comment

begin_expr_stmt
specifier|inline
name|unsigned
name|getAddressSpace
argument_list|()
specifier|const
expr_stmt|;
end_expr_stmt

begin_comment
comment|/// GCAttrTypesAttr - Returns gc attribute of this type.
end_comment

begin_expr_stmt
specifier|inline
name|Qualifiers
operator|::
name|GC
name|getObjCGCAttr
argument_list|()
specifier|const
expr_stmt|;
end_expr_stmt

begin_comment
comment|/// isObjCGCWeak true when Type is objc's weak.
end_comment

begin_expr_stmt
name|bool
name|isObjCGCWeak
argument_list|()
specifier|const
block|{
return|return
name|getObjCGCAttr
argument_list|()
operator|==
name|Qualifiers
operator|::
name|Weak
return|;
block|}
end_expr_stmt

begin_comment
comment|/// isObjCGCStrong true when Type is objc's strong.
end_comment

begin_expr_stmt
name|bool
name|isObjCGCStrong
argument_list|()
specifier|const
block|{
return|return
name|getObjCGCAttr
argument_list|()
operator|==
name|Qualifiers
operator|::
name|Strong
return|;
block|}
end_expr_stmt

begin_comment
comment|/// getNoReturnAttr - Returns true if the type has the noreturn attribute,
end_comment

begin_comment
comment|/// false otherwise.
end_comment

begin_expr_stmt
name|bool
name|getNoReturnAttr
argument_list|()
specifier|const
expr_stmt|;
end_expr_stmt

begin_label
name|private
label|:
end_label

begin_comment
comment|// These methods are implemented in a separate translation unit;
end_comment

begin_comment
comment|// "static"-ize them to avoid creating temporary QualTypes in the
end_comment

begin_comment
comment|// caller.
end_comment

begin_function_decl
specifier|static
name|bool
name|isConstant
parameter_list|(
name|QualType
name|T
parameter_list|,
name|ASTContext
modifier|&
name|Ctx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|QualType
name|getDesugaredType
parameter_list|(
name|QualType
name|T
parameter_list|)
function_decl|;
end_function_decl

begin_comment
unit|};  }
comment|// end clang.
end_comment

begin_macro
unit|namespace
name|llvm
end_macro

begin_block
block|{
comment|/// Implement simplify_type for QualType, so that we can dyn_cast from QualType
comment|/// to a specific Type class.
name|template
operator|<
operator|>
expr|struct
name|simplify_type
operator|<
specifier|const
operator|::
name|clang
operator|::
name|QualType
operator|>
block|{
typedef|typedef
operator|::
name|clang
operator|::
name|Type
operator|*
name|SimpleType
expr_stmt|;
specifier|static
name|SimpleType
name|getSimplifiedValue
argument_list|(
argument|const ::clang::QualType&Val
argument_list|)
block|{
return|return
name|Val
operator|.
name|getTypePtr
argument_list|()
return|;
block|}
block|}
empty_stmt|;
name|template
operator|<
operator|>
expr|struct
name|simplify_type
operator|<
operator|::
name|clang
operator|::
name|QualType
operator|>
operator|:
name|public
name|simplify_type
operator|<
specifier|const
operator|::
name|clang
operator|::
name|QualType
operator|>
block|{}
expr_stmt|;
comment|// Teach SmallPtrSet that QualType is "basically a pointer".
name|template
operator|<
operator|>
name|class
name|PointerLikeTypeTraits
operator|<
name|clang
operator|::
name|QualType
operator|>
block|{
name|public
operator|:
specifier|static
specifier|inline
name|void
operator|*
name|getAsVoidPointer
argument_list|(
argument|clang::QualType P
argument_list|)
block|{
return|return
name|P
operator|.
name|getAsOpaquePtr
argument_list|()
return|;
block|}
specifier|static
specifier|inline
name|clang
operator|::
name|QualType
name|getFromVoidPointer
argument_list|(
argument|void *P
argument_list|)
block|{
return|return
name|clang
operator|::
name|QualType
operator|::
name|getFromOpaquePtr
argument_list|(
name|P
argument_list|)
return|;
block|}
comment|// Various qualifiers go in low bits.
enum|enum
block|{
name|NumLowBitsAvailable
init|=
literal|0
block|}
enum|;
block|}
end_block

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_comment
unit|}
comment|// end namespace llvm
end_comment

begin_macro
unit|namespace
name|clang
end_macro

begin_block
block|{
comment|/// Type - This is the base class of the type hierarchy.  A central concept
comment|/// with types is that each type always has a canonical type.  A canonical type
comment|/// is the type with any typedef names stripped out of it or the types it
comment|/// references.  For example, consider:
comment|///
comment|///  typedef int  foo;
comment|///  typedef foo* bar;
comment|///    'int *'    'foo *'    'bar'
comment|///
comment|/// There will be a Type object created for 'int'.  Since int is canonical, its
comment|/// canonicaltype pointer points to itself.  There is also a Type for 'foo' (a
comment|/// TypedefType).  Its CanonicalType pointer points to the 'int' Type.  Next
comment|/// there is a PointerType that represents 'int*', which, like 'int', is
comment|/// canonical.  Finally, there is a PointerType type for 'foo*' whose canonical
comment|/// type is 'int*', and there is a TypedefType for 'bar', whose canonical type
comment|/// is also 'int*'.
comment|///
comment|/// Non-canonical types are useful for emitting diagnostics, without losing
comment|/// information about typedefs being used.  Canonical types are useful for type
comment|/// comparisons (they allow by-pointer equality tests) and useful for reasoning
comment|/// about whether something has a particular form (e.g. is a function type),
comment|/// because they implicitly, recursively, strip all typedefs out of a type.
comment|///
comment|/// Types, once created, are immutable.
comment|///
name|class
name|Type
block|{
name|public
label|:
enum|enum
name|TypeClass
block|{
define|#
directive|define
name|TYPE
parameter_list|(
name|Class
parameter_list|,
name|Base
parameter_list|)
value|Class,
define|#
directive|define
name|ABSTRACT_TYPE
parameter_list|(
name|Class
parameter_list|,
name|Base
parameter_list|)
include|#
directive|include
file|"clang/AST/TypeNodes.def"
name|TagFirst
init|=
name|Record
block|,
name|TagLast
init|=
name|Enum
block|}
enum|;
name|protected
label|:
enum|enum
block|{
name|TypeClassBitSize
init|=
literal|6
block|}
enum|;
name|private
label|:
name|QualType
name|CanonicalType
decl_stmt|;
comment|/// Dependent - Whether this type is a dependent type (C++ [temp.dep.type]).
name|bool
name|Dependent
range|:
literal|1
decl_stmt|;
comment|/// TypeClass bitfield - Enum that specifies what subclass this belongs to.
comment|/// Note that this should stay at the end of the ivars for Type so that
comment|/// subclasses can pack their bitfields into the same word.
name|unsigned
name|TC
range|:
name|TypeClassBitSize
decl_stmt|;
name|Type
argument_list|(
specifier|const
name|Type
operator|&
argument_list|)
expr_stmt|;
comment|// DO NOT IMPLEMENT.
name|void
name|operator
init|=
operator|(
specifier|const
name|Type
operator|&
operator|)
decl_stmt|;
comment|// DO NOT IMPLEMENT.
name|protected
label|:
comment|// silence VC++ warning C4355: 'this' : used in base member initializer list
name|Type
modifier|*
name|this_
parameter_list|()
block|{
return|return
name|this
return|;
block|}
name|Type
argument_list|(
argument|TypeClass tc
argument_list|,
argument|QualType Canonical
argument_list|,
argument|bool dependent
argument_list|)
block|:
name|CanonicalType
argument_list|(
name|Canonical
operator|.
name|isNull
argument_list|()
condition|?
name|QualType
argument_list|(
name|this_
argument_list|()
argument_list|,
literal|0
argument_list|)
else|:
name|Canonical
argument_list|)
operator|,
name|Dependent
argument_list|(
name|dependent
argument_list|)
operator|,
name|TC
argument_list|(
argument|tc
argument_list|)
block|{}
name|virtual
operator|~
name|Type
argument_list|()
block|{}
name|virtual
name|void
name|Destroy
argument_list|(
name|ASTContext
operator|&
name|C
argument_list|)
expr_stmt|;
name|friend
name|class
name|ASTContext
decl_stmt|;
name|public
label|:
name|TypeClass
name|getTypeClass
argument_list|()
specifier|const
block|{
return|return
name|static_cast
operator|<
name|TypeClass
operator|>
operator|(
name|TC
operator|)
return|;
block|}
name|bool
name|isCanonical
argument_list|()
specifier|const
block|{
return|return
name|CanonicalType
operator|.
name|getTypePtr
argument_list|()
operator|==
name|this
return|;
block|}
comment|/// Types are partitioned into 3 broad categories (C99 6.2.5p1):
comment|/// object types, function types, and incomplete types.
comment|/// \brief Determines whether the type describes an object in memory.
comment|///
comment|/// Note that this definition of object type corresponds to the C++
comment|/// definition of object type, which includes incomplete types, as
comment|/// opposed to the C definition (which does not include incomplete
comment|/// types).
name|bool
name|isObjectType
argument_list|()
specifier|const
expr_stmt|;
comment|/// isIncompleteType - Return true if this is an incomplete type.
comment|/// A type that can describe objects, but which lacks information needed to
comment|/// determine its size (e.g. void, or a fwd declared struct). Clients of this
comment|/// routine will need to determine if the size is actually required.
name|bool
name|isIncompleteType
argument_list|()
specifier|const
expr_stmt|;
comment|/// isIncompleteOrObjectType - Return true if this is an incomplete or object
comment|/// type, in other words, not a function type.
name|bool
name|isIncompleteOrObjectType
argument_list|()
specifier|const
block|{
return|return
operator|!
name|isFunctionType
argument_list|()
return|;
block|}
comment|/// isPODType - Return true if this is a plain-old-data type (C++ 3.9p10).
name|bool
name|isPODType
argument_list|()
specifier|const
expr_stmt|;
comment|/// isVariablyModifiedType (C99 6.7.5.2p2) - Return true for variable array
comment|/// types that have a non-constant expression. This does not include "[]".
name|bool
name|isVariablyModifiedType
argument_list|()
specifier|const
expr_stmt|;
comment|/// Helper methods to distinguish type categories. All type predicates
comment|/// operate on the canonical type, ignoring typedefs and qualifiers.
comment|/// isSpecificBuiltinType - Test for a particular builtin type.
name|bool
name|isSpecificBuiltinType
argument_list|(
name|unsigned
name|K
argument_list|)
decl|const
decl_stmt|;
comment|/// isIntegerType() does *not* include complex integers (a GCC extension).
comment|/// isComplexIntegerType() can be used to test for complex integers.
name|bool
name|isIntegerType
argument_list|()
specifier|const
expr_stmt|;
comment|// C99 6.2.5p17 (int, char, bool, enum)
name|bool
name|isEnumeralType
argument_list|()
specifier|const
expr_stmt|;
name|bool
name|isBooleanType
argument_list|()
specifier|const
expr_stmt|;
name|bool
name|isCharType
argument_list|()
specifier|const
expr_stmt|;
name|bool
name|isWideCharType
argument_list|()
specifier|const
expr_stmt|;
name|bool
name|isIntegralType
argument_list|()
specifier|const
expr_stmt|;
comment|/// Floating point categories.
name|bool
name|isRealFloatingType
argument_list|()
specifier|const
expr_stmt|;
comment|// C99 6.2.5p10 (float, double, long double)
comment|/// isComplexType() does *not* include complex integers (a GCC extension).
comment|/// isComplexIntegerType() can be used to test for complex integers.
name|bool
name|isComplexType
argument_list|()
specifier|const
expr_stmt|;
comment|// C99 6.2.5p11 (complex)
name|bool
name|isAnyComplexType
argument_list|()
specifier|const
expr_stmt|;
comment|// C99 6.2.5p11 (complex) + Complex Int.
name|bool
name|isFloatingType
argument_list|()
specifier|const
expr_stmt|;
comment|// C99 6.2.5p11 (real floating + complex)
name|bool
name|isRealType
argument_list|()
specifier|const
expr_stmt|;
comment|// C99 6.2.5p17 (real floating + integer)
name|bool
name|isArithmeticType
argument_list|()
specifier|const
expr_stmt|;
comment|// C99 6.2.5p18 (integer + floating)
name|bool
name|isVoidType
argument_list|()
specifier|const
expr_stmt|;
comment|// C99 6.2.5p19
name|bool
name|isDerivedType
argument_list|()
specifier|const
expr_stmt|;
comment|// C99 6.2.5p20
name|bool
name|isScalarType
argument_list|()
specifier|const
expr_stmt|;
comment|// C99 6.2.5p21 (arithmetic + pointers)
name|bool
name|isAggregateType
argument_list|()
specifier|const
expr_stmt|;
comment|// Type Predicates: Check to see if this type is structurally the specified
comment|// type, ignoring typedefs and qualifiers.
name|bool
name|isFunctionType
argument_list|()
specifier|const
expr_stmt|;
name|bool
name|isFunctionNoProtoType
argument_list|()
specifier|const
block|{
return|return
name|getAs
operator|<
name|FunctionNoProtoType
operator|>
operator|(
operator|)
return|;
block|}
name|bool
name|isFunctionProtoType
argument_list|()
specifier|const
block|{
return|return
name|getAs
operator|<
name|FunctionProtoType
operator|>
operator|(
operator|)
return|;
block|}
name|bool
name|isPointerType
argument_list|()
specifier|const
expr_stmt|;
name|bool
name|isAnyPointerType
argument_list|()
specifier|const
expr_stmt|;
comment|// Any C pointer or ObjC object pointer
name|bool
name|isBlockPointerType
argument_list|()
specifier|const
expr_stmt|;
name|bool
name|isVoidPointerType
argument_list|()
specifier|const
expr_stmt|;
name|bool
name|isReferenceType
argument_list|()
specifier|const
expr_stmt|;
name|bool
name|isLValueReferenceType
argument_list|()
specifier|const
expr_stmt|;
name|bool
name|isRValueReferenceType
argument_list|()
specifier|const
expr_stmt|;
name|bool
name|isFunctionPointerType
argument_list|()
specifier|const
expr_stmt|;
name|bool
name|isMemberPointerType
argument_list|()
specifier|const
expr_stmt|;
name|bool
name|isMemberFunctionPointerType
argument_list|()
specifier|const
expr_stmt|;
name|bool
name|isArrayType
argument_list|()
specifier|const
expr_stmt|;
name|bool
name|isConstantArrayType
argument_list|()
specifier|const
expr_stmt|;
name|bool
name|isIncompleteArrayType
argument_list|()
specifier|const
expr_stmt|;
name|bool
name|isVariableArrayType
argument_list|()
specifier|const
expr_stmt|;
name|bool
name|isDependentSizedArrayType
argument_list|()
specifier|const
expr_stmt|;
name|bool
name|isRecordType
argument_list|()
specifier|const
expr_stmt|;
name|bool
name|isClassType
argument_list|()
specifier|const
expr_stmt|;
name|bool
name|isStructureType
argument_list|()
specifier|const
expr_stmt|;
name|bool
name|isUnionType
argument_list|()
specifier|const
expr_stmt|;
name|bool
name|isComplexIntegerType
argument_list|()
specifier|const
expr_stmt|;
comment|// GCC _Complex integer type.
name|bool
name|isVectorType
argument_list|()
specifier|const
expr_stmt|;
comment|// GCC vector type.
name|bool
name|isExtVectorType
argument_list|()
specifier|const
expr_stmt|;
comment|// Extended vector type.
name|bool
name|isObjCObjectPointerType
argument_list|()
specifier|const
expr_stmt|;
comment|// Pointer to *any* ObjC object.
comment|// FIXME: change this to 'raw' interface type, so we can used 'interface' type
comment|// for the common case.
name|bool
name|isObjCInterfaceType
argument_list|()
specifier|const
expr_stmt|;
comment|// NSString or NSString<foo>
name|bool
name|isObjCQualifiedInterfaceType
argument_list|()
specifier|const
expr_stmt|;
comment|// NSString<foo>
name|bool
name|isObjCQualifiedIdType
argument_list|()
specifier|const
expr_stmt|;
comment|// id<foo>
name|bool
name|isObjCQualifiedClassType
argument_list|()
specifier|const
expr_stmt|;
comment|// Class<foo>
name|bool
name|isObjCIdType
argument_list|()
specifier|const
expr_stmt|;
comment|// id
name|bool
name|isObjCClassType
argument_list|()
specifier|const
expr_stmt|;
comment|// Class
name|bool
name|isObjCBuiltinType
argument_list|()
specifier|const
expr_stmt|;
comment|// 'id' or 'Class'
name|bool
name|isTemplateTypeParmType
argument_list|()
specifier|const
expr_stmt|;
comment|// C++ template type parameter
name|bool
name|isNullPtrType
argument_list|()
specifier|const
expr_stmt|;
comment|// C++0x nullptr_t
comment|/// isDependentType - Whether this type is a dependent type, meaning
comment|/// that its definition somehow depends on a template parameter
comment|/// (C++ [temp.dep.type]).
name|bool
name|isDependentType
argument_list|()
specifier|const
block|{
return|return
name|Dependent
return|;
block|}
name|bool
name|isOverloadableType
argument_list|()
specifier|const
expr_stmt|;
comment|/// hasPointerRepresentation - Whether this type is represented
comment|/// natively as a pointer; this includes pointers, references, block
comment|/// pointers, and Objective-C interface, qualified id, and qualified
comment|/// interface types, as well as nullptr_t.
name|bool
name|hasPointerRepresentation
argument_list|()
specifier|const
expr_stmt|;
comment|/// hasObjCPointerRepresentation - Whether this type can represent
comment|/// an objective pointer type for the purpose of GC'ability
name|bool
name|hasObjCPointerRepresentation
argument_list|()
specifier|const
expr_stmt|;
comment|// Type Checking Functions: Check to see if this type is structurally the
comment|// specified type, ignoring typedefs and qualifiers, and return a pointer to
comment|// the best type we can.
specifier|const
name|RecordType
operator|*
name|getAsStructureType
argument_list|()
specifier|const
expr_stmt|;
comment|/// NOTE: getAs*ArrayType are methods on ASTContext.
specifier|const
name|RecordType
operator|*
name|getAsUnionType
argument_list|()
specifier|const
expr_stmt|;
specifier|const
name|ComplexType
operator|*
name|getAsComplexIntegerType
argument_list|()
specifier|const
expr_stmt|;
comment|// GCC complex int type.
comment|// The following is a convenience method that returns an ObjCObjectPointerType
comment|// for object declared using an interface.
specifier|const
name|ObjCObjectPointerType
operator|*
name|getAsObjCInterfacePointerType
argument_list|()
specifier|const
expr_stmt|;
specifier|const
name|ObjCObjectPointerType
operator|*
name|getAsObjCQualifiedIdType
argument_list|()
specifier|const
expr_stmt|;
specifier|const
name|ObjCInterfaceType
operator|*
name|getAsObjCQualifiedInterfaceType
argument_list|()
specifier|const
expr_stmt|;
specifier|const
name|CXXRecordDecl
operator|*
name|getCXXRecordDeclForPointerType
argument_list|()
specifier|const
expr_stmt|;
comment|// Member-template getAs<specific type>'.  This scheme will eventually
comment|// replace the specific getAsXXXX methods above.
comment|//
comment|// There are some specializations of this member template listed
comment|// immediately following this class.
name|template
operator|<
name|typename
name|T
operator|>
specifier|const
name|T
operator|*
name|getAs
argument_list|()
specifier|const
expr_stmt|;
comment|/// getAsPointerToObjCInterfaceType - If this is a pointer to an ObjC
comment|/// interface, return the interface type, otherwise return null.
specifier|const
name|ObjCInterfaceType
operator|*
name|getAsPointerToObjCInterfaceType
argument_list|()
specifier|const
expr_stmt|;
comment|/// getArrayElementTypeNoTypeQual - If this is an array type, return the
comment|/// element type of the array, potentially with type qualifiers missing.
comment|/// This method should never be used when type qualifiers are meaningful.
specifier|const
name|Type
operator|*
name|getArrayElementTypeNoTypeQual
argument_list|()
specifier|const
expr_stmt|;
comment|/// getPointeeType - If this is a pointer, ObjC object pointer, or block
comment|/// pointer, this returns the respective pointee.
name|QualType
name|getPointeeType
argument_list|()
specifier|const
expr_stmt|;
comment|/// getUnqualifiedDesugaredType() - Return the specified type with
comment|/// any "sugar" removed from the type, removing any typedefs,
comment|/// typeofs, etc., as well as any qualifiers.
specifier|const
name|Type
operator|*
name|getUnqualifiedDesugaredType
argument_list|()
specifier|const
expr_stmt|;
comment|/// More type predicates useful for type checking/promotion
name|bool
name|isPromotableIntegerType
argument_list|()
specifier|const
expr_stmt|;
comment|// C99 6.3.1.1p2
comment|/// isSignedIntegerType - Return true if this is an integer type that is
comment|/// signed, according to C99 6.2.5p4 [char, signed char, short, int, long..],
comment|/// an enum decl which has a signed representation, or a vector of signed
comment|/// integer element type.
name|bool
name|isSignedIntegerType
argument_list|()
specifier|const
expr_stmt|;
comment|/// isUnsignedIntegerType - Return true if this is an integer type that is
comment|/// unsigned, according to C99 6.2.5p6 [which returns true for _Bool], an enum
comment|/// decl which has an unsigned representation, or a vector of unsigned integer
comment|/// element type.
name|bool
name|isUnsignedIntegerType
argument_list|()
specifier|const
expr_stmt|;
comment|/// isConstantSizeType - Return true if this is not a variable sized type,
comment|/// according to the rules of C99 6.7.5p3.  It is not legal to call this on
comment|/// incomplete types.
name|bool
name|isConstantSizeType
argument_list|()
specifier|const
expr_stmt|;
comment|/// isSpecifierType - Returns true if this type can be represented by some
comment|/// set of type specifiers.
name|bool
name|isSpecifierType
argument_list|()
specifier|const
expr_stmt|;
specifier|const
name|char
operator|*
name|getTypeClassName
argument_list|()
specifier|const
expr_stmt|;
name|QualType
name|getCanonicalTypeInternal
argument_list|()
specifier|const
block|{
return|return
name|CanonicalType
return|;
block|}
name|void
name|dump
argument_list|()
specifier|const
expr_stmt|;
name|virtual
name|void
name|getAsStringInternal
argument_list|(
name|std
operator|::
name|string
operator|&
name|InnerString
argument_list|,
specifier|const
name|PrintingPolicy
operator|&
name|Policy
argument_list|)
decl|const
init|=
literal|0
decl_stmt|;
specifier|static
name|bool
name|classof
parameter_list|(
specifier|const
name|Type
modifier|*
parameter_list|)
block|{
return|return
name|true
return|;
block|}
block|}
empty_stmt|;
name|template
operator|<
operator|>
specifier|inline
specifier|const
name|TypedefType
operator|*
name|Type
operator|::
name|getAs
argument_list|()
specifier|const
block|{
return|return
name|dyn_cast
operator|<
name|TypedefType
operator|>
operator|(
name|this
operator|)
return|;
block|}
comment|// We can do canonical leaf types faster, because we don't have to
comment|// worry about preserving child type decoration.
define|#
directive|define
name|TYPE
parameter_list|(
name|Class
parameter_list|,
name|Base
parameter_list|)
define|#
directive|define
name|LEAF_TYPE
parameter_list|(
name|Class
parameter_list|)
define|\
value|template<> inline const Class##Type *Type::getAs() const { \   return dyn_cast<Class##Type>(CanonicalType); \ }
include|#
directive|include
file|"clang/AST/TypeNodes.def"
comment|/// BuiltinType - This class is used for builtin types like 'int'.  Builtin
comment|/// types are always canonical and have a literal name field.
name|class
name|BuiltinType
range|:
name|public
name|Type
block|{
name|public
operator|:
expr|enum
name|Kind
block|{
name|Void
block|,
name|Bool
block|,
comment|// This is bool and/or _Bool.
name|Char_U
block|,
comment|// This is 'char' for targets where char is unsigned.
name|UChar
block|,
comment|// This is explicitly qualified unsigned char.
name|Char16
block|,
comment|// This is 'char16_t' for C++.
name|Char32
block|,
comment|// This is 'char32_t' for C++.
name|UShort
block|,
name|UInt
block|,
name|ULong
block|,
name|ULongLong
block|,
name|UInt128
block|,
comment|// __uint128_t
name|Char_S
block|,
comment|// This is 'char' for targets where char is signed.
name|SChar
block|,
comment|// This is explicitly qualified signed char.
name|WChar
block|,
comment|// This is 'wchar_t' for C++.
name|Short
block|,
name|Int
block|,
name|Long
block|,
name|LongLong
block|,
name|Int128
block|,
comment|// __int128_t
name|Float
block|,
name|Double
block|,
name|LongDouble
block|,
name|NullPtr
block|,
comment|// This is the type of C++0x 'nullptr'.
name|Overload
block|,
comment|// This represents the type of an overloaded function declaration.
name|Dependent
block|,
comment|// This represents the type of a type-dependent expression.
name|UndeducedAuto
block|,
comment|// In C++0x, this represents the type of an auto variable
comment|// that has not been deduced yet.
name|ObjCId
block|,
comment|// This represents the ObjC 'id' type.
name|ObjCClass
comment|// This represents the ObjC 'Class' type.
block|}
block|;
name|private
operator|:
name|Kind
name|TypeKind
block|;
name|public
operator|:
name|BuiltinType
argument_list|(
argument|Kind K
argument_list|)
operator|:
name|Type
argument_list|(
name|Builtin
argument_list|,
name|QualType
argument_list|()
argument_list|,
comment|/*Dependent=*/
operator|(
name|K
operator|==
name|Dependent
operator|)
argument_list|)
block|,
name|TypeKind
argument_list|(
argument|K
argument_list|)
block|{}
name|Kind
name|getKind
argument_list|()
specifier|const
block|{
return|return
name|TypeKind
return|;
block|}
specifier|const
name|char
operator|*
name|getName
argument_list|(
argument|const LangOptions&LO
argument_list|)
specifier|const
block|;
name|bool
name|isSugared
argument_list|()
specifier|const
block|{
return|return
name|false
return|;
block|}
name|QualType
name|desugar
argument_list|()
specifier|const
block|{
return|return
name|QualType
argument_list|(
name|this
argument_list|,
literal|0
argument_list|)
return|;
block|}
name|virtual
name|void
name|getAsStringInternal
argument_list|(
argument|std::string&InnerString
argument_list|,
argument|const PrintingPolicy&Policy
argument_list|)
specifier|const
block|;
specifier|static
name|bool
name|classof
argument_list|(
argument|const Type *T
argument_list|)
block|{
return|return
name|T
operator|->
name|getTypeClass
argument_list|()
operator|==
name|Builtin
return|;
block|}
specifier|static
name|bool
name|classof
argument_list|(
argument|const BuiltinType *
argument_list|)
block|{
return|return
name|true
return|;
block|}
expr|}
block|;
comment|/// FixedWidthIntType - Used for arbitrary width types that we either don't
comment|/// want to or can't map to named integer types.  These always have a lower
comment|/// integer rank than builtin types of the same width.
name|class
name|FixedWidthIntType
operator|:
name|public
name|Type
block|{
name|private
operator|:
name|unsigned
name|Width
block|;
name|bool
name|Signed
block|;
name|public
operator|:
name|FixedWidthIntType
argument_list|(
argument|unsigned W
argument_list|,
argument|bool S
argument_list|)
operator|:
name|Type
argument_list|(
name|FixedWidthInt
argument_list|,
name|QualType
argument_list|()
argument_list|,
name|false
argument_list|)
block|,
name|Width
argument_list|(
name|W
argument_list|)
block|,
name|Signed
argument_list|(
argument|S
argument_list|)
block|{}
name|unsigned
name|getWidth
argument_list|()
specifier|const
block|{
return|return
name|Width
return|;
block|}
name|bool
name|isSigned
argument_list|()
specifier|const
block|{
return|return
name|Signed
return|;
block|}
specifier|const
name|char
operator|*
name|getName
argument_list|()
specifier|const
block|;
name|bool
name|isSugared
argument_list|()
specifier|const
block|{
return|return
name|false
return|;
block|}
name|QualType
name|desugar
argument_list|()
specifier|const
block|{
return|return
name|QualType
argument_list|(
name|this
argument_list|,
literal|0
argument_list|)
return|;
block|}
name|virtual
name|void
name|getAsStringInternal
argument_list|(
argument|std::string&InnerString
argument_list|,
argument|const PrintingPolicy&Policy
argument_list|)
specifier|const
block|;
specifier|static
name|bool
name|classof
argument_list|(
argument|const Type *T
argument_list|)
block|{
return|return
name|T
operator|->
name|getTypeClass
argument_list|()
operator|==
name|FixedWidthInt
return|;
block|}
specifier|static
name|bool
name|classof
argument_list|(
argument|const FixedWidthIntType *
argument_list|)
block|{
return|return
name|true
return|;
block|}
expr|}
block|;
comment|/// ComplexType - C99 6.2.5p11 - Complex values.  This supports the C99 complex
comment|/// types (_Complex float etc) as well as the GCC integer complex extensions.
comment|///
name|class
name|ComplexType
operator|:
name|public
name|Type
block|,
name|public
name|llvm
operator|::
name|FoldingSetNode
block|{
name|QualType
name|ElementType
block|;
name|ComplexType
argument_list|(
argument|QualType Element
argument_list|,
argument|QualType CanonicalPtr
argument_list|)
operator|:
name|Type
argument_list|(
name|Complex
argument_list|,
name|CanonicalPtr
argument_list|,
name|Element
operator|->
name|isDependentType
argument_list|()
argument_list|)
block|,
name|ElementType
argument_list|(
argument|Element
argument_list|)
block|{   }
name|friend
name|class
name|ASTContext
block|;
comment|// ASTContext creates these.
name|public
operator|:
name|QualType
name|getElementType
argument_list|()
specifier|const
block|{
return|return
name|ElementType
return|;
block|}
name|virtual
name|void
name|getAsStringInternal
argument_list|(
argument|std::string&InnerString
argument_list|,
argument|const PrintingPolicy&Policy
argument_list|)
specifier|const
block|;
name|bool
name|isSugared
argument_list|()
specifier|const
block|{
return|return
name|false
return|;
block|}
name|QualType
name|desugar
argument_list|()
specifier|const
block|{
return|return
name|QualType
argument_list|(
name|this
argument_list|,
literal|0
argument_list|)
return|;
block|}
name|void
name|Profile
argument_list|(
argument|llvm::FoldingSetNodeID&ID
argument_list|)
block|{
name|Profile
argument_list|(
name|ID
argument_list|,
name|getElementType
argument_list|()
argument_list|)
block|;   }
specifier|static
name|void
name|Profile
argument_list|(
argument|llvm::FoldingSetNodeID&ID
argument_list|,
argument|QualType Element
argument_list|)
block|{
name|ID
operator|.
name|AddPointer
argument_list|(
name|Element
operator|.
name|getAsOpaquePtr
argument_list|()
argument_list|)
block|;   }
specifier|static
name|bool
name|classof
argument_list|(
argument|const Type *T
argument_list|)
block|{
return|return
name|T
operator|->
name|getTypeClass
argument_list|()
operator|==
name|Complex
return|;
block|}
specifier|static
name|bool
name|classof
argument_list|(
argument|const ComplexType *
argument_list|)
block|{
return|return
name|true
return|;
block|}
expr|}
block|;
comment|/// PointerType - C99 6.7.5.1 - Pointer Declarators.
comment|///
name|class
name|PointerType
operator|:
name|public
name|Type
block|,
name|public
name|llvm
operator|::
name|FoldingSetNode
block|{
name|QualType
name|PointeeType
block|;
name|PointerType
argument_list|(
argument|QualType Pointee
argument_list|,
argument|QualType CanonicalPtr
argument_list|)
operator|:
name|Type
argument_list|(
name|Pointer
argument_list|,
name|CanonicalPtr
argument_list|,
name|Pointee
operator|->
name|isDependentType
argument_list|()
argument_list|)
block|,
name|PointeeType
argument_list|(
argument|Pointee
argument_list|)
block|{   }
name|friend
name|class
name|ASTContext
block|;
comment|// ASTContext creates these.
name|public
operator|:
name|virtual
name|void
name|getAsStringInternal
argument_list|(
argument|std::string&InnerString
argument_list|,
argument|const PrintingPolicy&Policy
argument_list|)
specifier|const
block|;
name|QualType
name|getPointeeType
argument_list|()
specifier|const
block|{
return|return
name|PointeeType
return|;
block|}
name|bool
name|isSugared
argument_list|()
specifier|const
block|{
return|return
name|false
return|;
block|}
name|QualType
name|desugar
argument_list|()
specifier|const
block|{
return|return
name|QualType
argument_list|(
name|this
argument_list|,
literal|0
argument_list|)
return|;
block|}
name|void
name|Profile
argument_list|(
argument|llvm::FoldingSetNodeID&ID
argument_list|)
block|{
name|Profile
argument_list|(
name|ID
argument_list|,
name|getPointeeType
argument_list|()
argument_list|)
block|;   }
specifier|static
name|void
name|Profile
argument_list|(
argument|llvm::FoldingSetNodeID&ID
argument_list|,
argument|QualType Pointee
argument_list|)
block|{
name|ID
operator|.
name|AddPointer
argument_list|(
name|Pointee
operator|.
name|getAsOpaquePtr
argument_list|()
argument_list|)
block|;   }
specifier|static
name|bool
name|classof
argument_list|(
argument|const Type *T
argument_list|)
block|{
return|return
name|T
operator|->
name|getTypeClass
argument_list|()
operator|==
name|Pointer
return|;
block|}
specifier|static
name|bool
name|classof
argument_list|(
argument|const PointerType *
argument_list|)
block|{
return|return
name|true
return|;
block|}
expr|}
block|;
comment|/// BlockPointerType - pointer to a block type.
comment|/// This type is to represent types syntactically represented as
comment|/// "void (^)(int)", etc. Pointee is required to always be a function type.
comment|///
name|class
name|BlockPointerType
operator|:
name|public
name|Type
block|,
name|public
name|llvm
operator|::
name|FoldingSetNode
block|{
name|QualType
name|PointeeType
block|;
comment|// Block is some kind of pointer type
name|BlockPointerType
argument_list|(
argument|QualType Pointee
argument_list|,
argument|QualType CanonicalCls
argument_list|)
operator|:
name|Type
argument_list|(
name|BlockPointer
argument_list|,
name|CanonicalCls
argument_list|,
name|Pointee
operator|->
name|isDependentType
argument_list|()
argument_list|)
block|,
name|PointeeType
argument_list|(
argument|Pointee
argument_list|)
block|{   }
name|friend
name|class
name|ASTContext
block|;
comment|// ASTContext creates these.
name|public
operator|:
comment|// Get the pointee type. Pointee is required to always be a function type.
name|QualType
name|getPointeeType
argument_list|()
specifier|const
block|{
return|return
name|PointeeType
return|;
block|}
name|virtual
name|void
name|getAsStringInternal
argument_list|(
argument|std::string&InnerString
argument_list|,
argument|const PrintingPolicy&Policy
argument_list|)
specifier|const
block|;
name|bool
name|isSugared
argument_list|()
specifier|const
block|{
return|return
name|false
return|;
block|}
name|QualType
name|desugar
argument_list|()
specifier|const
block|{
return|return
name|QualType
argument_list|(
name|this
argument_list|,
literal|0
argument_list|)
return|;
block|}
name|void
name|Profile
argument_list|(
argument|llvm::FoldingSetNodeID&ID
argument_list|)
block|{
name|Profile
argument_list|(
name|ID
argument_list|,
name|getPointeeType
argument_list|()
argument_list|)
block|;   }
specifier|static
name|void
name|Profile
argument_list|(
argument|llvm::FoldingSetNodeID&ID
argument_list|,
argument|QualType Pointee
argument_list|)
block|{
name|ID
operator|.
name|AddPointer
argument_list|(
name|Pointee
operator|.
name|getAsOpaquePtr
argument_list|()
argument_list|)
block|;   }
specifier|static
name|bool
name|classof
argument_list|(
argument|const Type *T
argument_list|)
block|{
return|return
name|T
operator|->
name|getTypeClass
argument_list|()
operator|==
name|BlockPointer
return|;
block|}
specifier|static
name|bool
name|classof
argument_list|(
argument|const BlockPointerType *
argument_list|)
block|{
return|return
name|true
return|;
block|}
expr|}
block|;
comment|/// ReferenceType - Base for LValueReferenceType and RValueReferenceType
comment|///
name|class
name|ReferenceType
operator|:
name|public
name|Type
block|,
name|public
name|llvm
operator|::
name|FoldingSetNode
block|{
name|QualType
name|PointeeType
block|;
name|protected
operator|:
name|ReferenceType
argument_list|(
argument|TypeClass tc
argument_list|,
argument|QualType Referencee
argument_list|,
argument|QualType CanonicalRef
argument_list|)
operator|:
name|Type
argument_list|(
name|tc
argument_list|,
name|CanonicalRef
argument_list|,
name|Referencee
operator|->
name|isDependentType
argument_list|()
argument_list|)
block|,
name|PointeeType
argument_list|(
argument|Referencee
argument_list|)
block|{   }
name|public
operator|:
name|QualType
name|getPointeeType
argument_list|()
specifier|const
block|{
return|return
name|PointeeType
return|;
block|}
name|void
name|Profile
argument_list|(
argument|llvm::FoldingSetNodeID&ID
argument_list|)
block|{
name|Profile
argument_list|(
name|ID
argument_list|,
name|getPointeeType
argument_list|()
argument_list|)
block|;   }
specifier|static
name|void
name|Profile
argument_list|(
argument|llvm::FoldingSetNodeID&ID
argument_list|,
argument|QualType Referencee
argument_list|)
block|{
name|ID
operator|.
name|AddPointer
argument_list|(
name|Referencee
operator|.
name|getAsOpaquePtr
argument_list|()
argument_list|)
block|;   }
specifier|static
name|bool
name|classof
argument_list|(
argument|const Type *T
argument_list|)
block|{
return|return
name|T
operator|->
name|getTypeClass
argument_list|()
operator|==
name|LValueReference
operator|||
name|T
operator|->
name|getTypeClass
argument_list|()
operator|==
name|RValueReference
return|;
block|}
specifier|static
name|bool
name|classof
argument_list|(
argument|const ReferenceType *
argument_list|)
block|{
return|return
name|true
return|;
block|}
expr|}
block|;
comment|/// LValueReferenceType - C++ [dcl.ref] - Lvalue reference
comment|///
name|class
name|LValueReferenceType
operator|:
name|public
name|ReferenceType
block|{
name|LValueReferenceType
argument_list|(
argument|QualType Referencee
argument_list|,
argument|QualType CanonicalRef
argument_list|)
operator|:
name|ReferenceType
argument_list|(
argument|LValueReference
argument_list|,
argument|Referencee
argument_list|,
argument|CanonicalRef
argument_list|)
block|{   }
name|friend
name|class
name|ASTContext
block|;
comment|// ASTContext creates these
name|public
operator|:
name|virtual
name|void
name|getAsStringInternal
argument_list|(
argument|std::string&InnerString
argument_list|,
argument|const PrintingPolicy&Policy
argument_list|)
specifier|const
block|;
name|bool
name|isSugared
argument_list|()
specifier|const
block|{
return|return
name|false
return|;
block|}
name|QualType
name|desugar
argument_list|()
specifier|const
block|{
return|return
name|QualType
argument_list|(
name|this
argument_list|,
literal|0
argument_list|)
return|;
block|}
specifier|static
name|bool
name|classof
argument_list|(
argument|const Type *T
argument_list|)
block|{
return|return
name|T
operator|->
name|getTypeClass
argument_list|()
operator|==
name|LValueReference
return|;
block|}
specifier|static
name|bool
name|classof
argument_list|(
argument|const LValueReferenceType *
argument_list|)
block|{
return|return
name|true
return|;
block|}
expr|}
block|;
comment|/// RValueReferenceType - C++0x [dcl.ref] - Rvalue reference
comment|///
name|class
name|RValueReferenceType
operator|:
name|public
name|ReferenceType
block|{
name|RValueReferenceType
argument_list|(
argument|QualType Referencee
argument_list|,
argument|QualType CanonicalRef
argument_list|)
operator|:
name|ReferenceType
argument_list|(
argument|RValueReference
argument_list|,
argument|Referencee
argument_list|,
argument|CanonicalRef
argument_list|)
block|{   }
name|friend
name|class
name|ASTContext
block|;
comment|// ASTContext creates these
name|public
operator|:
name|virtual
name|void
name|getAsStringInternal
argument_list|(
argument|std::string&InnerString
argument_list|,
argument|const PrintingPolicy&Policy
argument_list|)
specifier|const
block|;
name|bool
name|isSugared
argument_list|()
specifier|const
block|{
return|return
name|false
return|;
block|}
name|QualType
name|desugar
argument_list|()
specifier|const
block|{
return|return
name|QualType
argument_list|(
name|this
argument_list|,
literal|0
argument_list|)
return|;
block|}
specifier|static
name|bool
name|classof
argument_list|(
argument|const Type *T
argument_list|)
block|{
return|return
name|T
operator|->
name|getTypeClass
argument_list|()
operator|==
name|RValueReference
return|;
block|}
specifier|static
name|bool
name|classof
argument_list|(
argument|const RValueReferenceType *
argument_list|)
block|{
return|return
name|true
return|;
block|}
expr|}
block|;
comment|/// MemberPointerType - C++ 8.3.3 - Pointers to members
comment|///
name|class
name|MemberPointerType
operator|:
name|public
name|Type
block|,
name|public
name|llvm
operator|::
name|FoldingSetNode
block|{
name|QualType
name|PointeeType
block|;
comment|/// The class of which the pointee is a member. Must ultimately be a
comment|/// RecordType, but could be a typedef or a template parameter too.
specifier|const
name|Type
operator|*
name|Class
block|;
name|MemberPointerType
argument_list|(
argument|QualType Pointee
argument_list|,
argument|const Type *Cls
argument_list|,
argument|QualType CanonicalPtr
argument_list|)
operator|:
name|Type
argument_list|(
name|MemberPointer
argument_list|,
name|CanonicalPtr
argument_list|,
name|Cls
operator|->
name|isDependentType
argument_list|()
operator|||
name|Pointee
operator|->
name|isDependentType
argument_list|()
argument_list|)
block|,
name|PointeeType
argument_list|(
name|Pointee
argument_list|)
block|,
name|Class
argument_list|(
argument|Cls
argument_list|)
block|{   }
name|friend
name|class
name|ASTContext
block|;
comment|// ASTContext creates these.
name|public
operator|:
name|QualType
name|getPointeeType
argument_list|()
specifier|const
block|{
return|return
name|PointeeType
return|;
block|}
specifier|const
name|Type
operator|*
name|getClass
argument_list|()
specifier|const
block|{
return|return
name|Class
return|;
block|}
name|virtual
name|void
name|getAsStringInternal
argument_list|(
argument|std::string&InnerString
argument_list|,
argument|const PrintingPolicy&Policy
argument_list|)
specifier|const
block|;
name|bool
name|isSugared
argument_list|()
specifier|const
block|{
return|return
name|false
return|;
block|}
name|QualType
name|desugar
argument_list|()
specifier|const
block|{
return|return
name|QualType
argument_list|(
name|this
argument_list|,
literal|0
argument_list|)
return|;
block|}
name|void
name|Profile
argument_list|(
argument|llvm::FoldingSetNodeID&ID
argument_list|)
block|{
name|Profile
argument_list|(
name|ID
argument_list|,
name|getPointeeType
argument_list|()
argument_list|,
name|getClass
argument_list|()
argument_list|)
block|;   }
specifier|static
name|void
name|Profile
argument_list|(
argument|llvm::FoldingSetNodeID&ID
argument_list|,
argument|QualType Pointee
argument_list|,
argument|const Type *Class
argument_list|)
block|{
name|ID
operator|.
name|AddPointer
argument_list|(
name|Pointee
operator|.
name|getAsOpaquePtr
argument_list|()
argument_list|)
block|;
name|ID
operator|.
name|AddPointer
argument_list|(
name|Class
argument_list|)
block|;   }
specifier|static
name|bool
name|classof
argument_list|(
argument|const Type *T
argument_list|)
block|{
return|return
name|T
operator|->
name|getTypeClass
argument_list|()
operator|==
name|MemberPointer
return|;
block|}
specifier|static
name|bool
name|classof
argument_list|(
argument|const MemberPointerType *
argument_list|)
block|{
return|return
name|true
return|;
block|}
expr|}
block|;
comment|/// ArrayType - C99 6.7.5.2 - Array Declarators.
comment|///
name|class
name|ArrayType
operator|:
name|public
name|Type
block|,
name|public
name|llvm
operator|::
name|FoldingSetNode
block|{
name|public
operator|:
comment|/// ArraySizeModifier - Capture whether this is a normal array (e.g. int X[4])
comment|/// an array with a static size (e.g. int X[static 4]), or an array
comment|/// with a star size (e.g. int X[*]).
comment|/// 'static' is only allowed on function parameters.
expr|enum
name|ArraySizeModifier
block|{
name|Normal
block|,
name|Static
block|,
name|Star
block|}
block|;
name|private
operator|:
comment|/// ElementType - The element type of the array.
name|QualType
name|ElementType
block|;
comment|// NOTE: VC++ treats enums as signed, avoid using the ArraySizeModifier enum
comment|/// NOTE: These fields are packed into the bitfields space in the Type class.
name|unsigned
name|SizeModifier
operator|:
literal|2
block|;
comment|/// IndexTypeQuals - Capture qualifiers in declarations like:
comment|/// 'int X[static restrict 4]'. For function parameters only.
name|unsigned
name|IndexTypeQuals
operator|:
literal|3
block|;
name|protected
operator|:
comment|// C++ [temp.dep.type]p1:
comment|//   A type is dependent if it is...
comment|//     - an array type constructed from any dependent type or whose
comment|//       size is specified by a constant expression that is
comment|//       value-dependent,
name|ArrayType
argument_list|(
argument|TypeClass tc
argument_list|,
argument|QualType et
argument_list|,
argument|QualType can
argument_list|,
argument|ArraySizeModifier sm
argument_list|,
argument|unsigned tq
argument_list|)
operator|:
name|Type
argument_list|(
name|tc
argument_list|,
name|can
argument_list|,
name|et
operator|->
name|isDependentType
argument_list|()
operator|||
name|tc
operator|==
name|DependentSizedArray
argument_list|)
block|,
name|ElementType
argument_list|(
name|et
argument_list|)
block|,
name|SizeModifier
argument_list|(
name|sm
argument_list|)
block|,
name|IndexTypeQuals
argument_list|(
argument|tq
argument_list|)
block|{}
name|friend
name|class
name|ASTContext
block|;
comment|// ASTContext creates these.
name|public
operator|:
name|QualType
name|getElementType
argument_list|()
specifier|const
block|{
return|return
name|ElementType
return|;
block|}
name|ArraySizeModifier
name|getSizeModifier
argument_list|()
specifier|const
block|{
return|return
name|ArraySizeModifier
argument_list|(
name|SizeModifier
argument_list|)
return|;
block|}
name|Qualifiers
name|getIndexTypeQualifiers
argument_list|()
specifier|const
block|{
return|return
name|Qualifiers
operator|::
name|fromCVRMask
argument_list|(
name|IndexTypeQuals
argument_list|)
return|;
block|}
name|unsigned
name|getIndexTypeCVRQualifiers
argument_list|()
specifier|const
block|{
return|return
name|IndexTypeQuals
return|;
block|}
specifier|static
name|bool
name|classof
argument_list|(
argument|const Type *T
argument_list|)
block|{
return|return
name|T
operator|->
name|getTypeClass
argument_list|()
operator|==
name|ConstantArray
operator|||
name|T
operator|->
name|getTypeClass
argument_list|()
operator|==
name|ConstantArrayWithExpr
operator|||
name|T
operator|->
name|getTypeClass
argument_list|()
operator|==
name|ConstantArrayWithoutExpr
operator|||
name|T
operator|->
name|getTypeClass
argument_list|()
operator|==
name|VariableArray
operator|||
name|T
operator|->
name|getTypeClass
argument_list|()
operator|==
name|IncompleteArray
operator|||
name|T
operator|->
name|getTypeClass
argument_list|()
operator|==
name|DependentSizedArray
return|;
block|}
specifier|static
name|bool
name|classof
argument_list|(
argument|const ArrayType *
argument_list|)
block|{
return|return
name|true
return|;
block|}
expr|}
block|;
comment|/// ConstantArrayType - This class represents the canonical version of
comment|/// C arrays with a specified constant size.  For example, the canonical
comment|/// type for 'int A[4 + 4*100]' is a ConstantArrayType where the element
comment|/// type is 'int' and the size is 404.
name|class
name|ConstantArrayType
operator|:
name|public
name|ArrayType
block|{
name|llvm
operator|::
name|APInt
name|Size
block|;
comment|// Allows us to unique the type.
name|ConstantArrayType
argument_list|(
argument|QualType et
argument_list|,
argument|QualType can
argument_list|,
argument|const llvm::APInt&size
argument_list|,
argument|ArraySizeModifier sm
argument_list|,
argument|unsigned tq
argument_list|)
operator|:
name|ArrayType
argument_list|(
name|ConstantArray
argument_list|,
name|et
argument_list|,
name|can
argument_list|,
name|sm
argument_list|,
name|tq
argument_list|)
block|,
name|Size
argument_list|(
argument|size
argument_list|)
block|{}
name|protected
operator|:
name|ConstantArrayType
argument_list|(
argument|TypeClass tc
argument_list|,
argument|QualType et
argument_list|,
argument|QualType can
argument_list|,
argument|const llvm::APInt&size
argument_list|,
argument|ArraySizeModifier sm
argument_list|,
argument|unsigned tq
argument_list|)
operator|:
name|ArrayType
argument_list|(
name|tc
argument_list|,
name|et
argument_list|,
name|can
argument_list|,
name|sm
argument_list|,
name|tq
argument_list|)
block|,
name|Size
argument_list|(
argument|size
argument_list|)
block|{}
name|friend
name|class
name|ASTContext
block|;
comment|// ASTContext creates these.
name|public
operator|:
specifier|const
name|llvm
operator|::
name|APInt
operator|&
name|getSize
argument_list|()
specifier|const
block|{
return|return
name|Size
return|;
block|}
name|virtual
name|void
name|getAsStringInternal
argument_list|(
argument|std::string&InnerString
argument_list|,
argument|const PrintingPolicy&Policy
argument_list|)
specifier|const
block|;
name|bool
name|isSugared
argument_list|()
specifier|const
block|{
return|return
name|false
return|;
block|}
name|QualType
name|desugar
argument_list|()
specifier|const
block|{
return|return
name|QualType
argument_list|(
name|this
argument_list|,
literal|0
argument_list|)
return|;
block|}
name|void
name|Profile
argument_list|(
argument|llvm::FoldingSetNodeID&ID
argument_list|)
block|{
name|Profile
argument_list|(
name|ID
argument_list|,
name|getElementType
argument_list|()
argument_list|,
name|getSize
argument_list|()
argument_list|,
name|getSizeModifier
argument_list|()
argument_list|,
name|getIndexTypeCVRQualifiers
argument_list|()
argument_list|)
block|;   }
specifier|static
name|void
name|Profile
argument_list|(
argument|llvm::FoldingSetNodeID&ID
argument_list|,
argument|QualType ET
argument_list|,
argument|const llvm::APInt&ArraySize
argument_list|,
argument|ArraySizeModifier SizeMod
argument_list|,
argument|unsigned TypeQuals
argument_list|)
block|{
name|ID
operator|.
name|AddPointer
argument_list|(
name|ET
operator|.
name|getAsOpaquePtr
argument_list|()
argument_list|)
block|;
name|ID
operator|.
name|AddInteger
argument_list|(
name|ArraySize
operator|.
name|getZExtValue
argument_list|()
argument_list|)
block|;
name|ID
operator|.
name|AddInteger
argument_list|(
name|SizeMod
argument_list|)
block|;
name|ID
operator|.
name|AddInteger
argument_list|(
name|TypeQuals
argument_list|)
block|;   }
specifier|static
name|bool
name|classof
argument_list|(
argument|const Type *T
argument_list|)
block|{
return|return
name|T
operator|->
name|getTypeClass
argument_list|()
operator|==
name|ConstantArray
operator|||
name|T
operator|->
name|getTypeClass
argument_list|()
operator|==
name|ConstantArrayWithExpr
operator|||
name|T
operator|->
name|getTypeClass
argument_list|()
operator|==
name|ConstantArrayWithoutExpr
return|;
block|}
specifier|static
name|bool
name|classof
argument_list|(
argument|const ConstantArrayType *
argument_list|)
block|{
return|return
name|true
return|;
block|}
expr|}
block|;
comment|/// ConstantArrayWithExprType - This class represents C arrays with a
comment|/// constant size specified by means of an integer constant expression.
comment|/// For example 'int A[sizeof(int)]' has ConstantArrayWithExprType where
comment|/// the element type is 'int' and the size expression is 'sizeof(int)'.
comment|/// These types are non-canonical.
name|class
name|ConstantArrayWithExprType
operator|:
name|public
name|ConstantArrayType
block|{
comment|/// SizeExpr - The ICE occurring in the concrete syntax.
name|Expr
operator|*
name|SizeExpr
block|;
comment|/// Brackets - The left and right array brackets.
name|SourceRange
name|Brackets
block|;
name|ConstantArrayWithExprType
argument_list|(
argument|QualType et
argument_list|,
argument|QualType can
argument_list|,
argument|const llvm::APInt&size
argument_list|,
argument|Expr *e
argument_list|,
argument|ArraySizeModifier sm
argument_list|,
argument|unsigned tq
argument_list|,
argument|SourceRange brackets
argument_list|)
operator|:
name|ConstantArrayType
argument_list|(
name|ConstantArrayWithExpr
argument_list|,
name|et
argument_list|,
name|can
argument_list|,
name|size
argument_list|,
name|sm
argument_list|,
name|tq
argument_list|)
block|,
name|SizeExpr
argument_list|(
name|e
argument_list|)
block|,
name|Brackets
argument_list|(
argument|brackets
argument_list|)
block|{}
name|friend
name|class
name|ASTContext
block|;
comment|// ASTContext creates these.
name|virtual
name|void
name|Destroy
argument_list|(
name|ASTContext
operator|&
name|C
argument_list|)
block|;
name|public
operator|:
name|Expr
operator|*
name|getSizeExpr
argument_list|()
specifier|const
block|{
return|return
name|SizeExpr
return|;
block|}
name|SourceRange
name|getBracketsRange
argument_list|()
specifier|const
block|{
return|return
name|Brackets
return|;
block|}
name|SourceLocation
name|getLBracketLoc
argument_list|()
specifier|const
block|{
return|return
name|Brackets
operator|.
name|getBegin
argument_list|()
return|;
block|}
name|SourceLocation
name|getRBracketLoc
argument_list|()
specifier|const
block|{
return|return
name|Brackets
operator|.
name|getEnd
argument_list|()
return|;
block|}
name|virtual
name|void
name|getAsStringInternal
argument_list|(
argument|std::string&InnerString
argument_list|,
argument|const PrintingPolicy&Policy
argument_list|)
specifier|const
block|;
name|bool
name|isSugared
argument_list|()
specifier|const
block|{
return|return
name|false
return|;
block|}
name|QualType
name|desugar
argument_list|()
specifier|const
block|{
return|return
name|QualType
argument_list|(
name|this
argument_list|,
literal|0
argument_list|)
return|;
block|}
specifier|static
name|bool
name|classof
argument_list|(
argument|const Type *T
argument_list|)
block|{
return|return
name|T
operator|->
name|getTypeClass
argument_list|()
operator|==
name|ConstantArrayWithExpr
return|;
block|}
specifier|static
name|bool
name|classof
argument_list|(
argument|const ConstantArrayWithExprType *
argument_list|)
block|{
return|return
name|true
return|;
block|}
name|void
name|Profile
argument_list|(
argument|llvm::FoldingSetNodeID&ID
argument_list|)
block|{
name|assert
argument_list|(
literal|0
operator|&&
literal|"Cannot unique ConstantArrayWithExprTypes."
argument_list|)
block|;   }
expr|}
block|;
comment|/// ConstantArrayWithoutExprType - This class represents C arrays with a
comment|/// constant size that was not specified by an integer constant expression,
comment|/// but inferred by static semantics.
comment|/// For example 'int A[] = { 0, 1, 2 }' has ConstantArrayWithoutExprType.
comment|/// These types are non-canonical: the corresponding canonical type,
comment|/// having the size specified in an APInt object, is a ConstantArrayType.
name|class
name|ConstantArrayWithoutExprType
operator|:
name|public
name|ConstantArrayType
block|{
name|ConstantArrayWithoutExprType
argument_list|(
argument|QualType et
argument_list|,
argument|QualType can
argument_list|,
argument|const llvm::APInt&size
argument_list|,
argument|ArraySizeModifier sm
argument_list|,
argument|unsigned tq
argument_list|)
operator|:
name|ConstantArrayType
argument_list|(
argument|ConstantArrayWithoutExpr
argument_list|,
argument|et
argument_list|,
argument|can
argument_list|,
argument|size
argument_list|,
argument|sm
argument_list|,
argument|tq
argument_list|)
block|{}
name|friend
name|class
name|ASTContext
block|;
comment|// ASTContext creates these.
name|public
operator|:
name|virtual
name|void
name|getAsStringInternal
argument_list|(
argument|std::string&InnerString
argument_list|,
argument|const PrintingPolicy&Policy
argument_list|)
specifier|const
block|;
name|bool
name|isSugared
argument_list|()
specifier|const
block|{
return|return
name|false
return|;
block|}
name|QualType
name|desugar
argument_list|()
specifier|const
block|{
return|return
name|QualType
argument_list|(
name|this
argument_list|,
literal|0
argument_list|)
return|;
block|}
specifier|static
name|bool
name|classof
argument_list|(
argument|const Type *T
argument_list|)
block|{
return|return
name|T
operator|->
name|getTypeClass
argument_list|()
operator|==
name|ConstantArrayWithoutExpr
return|;
block|}
specifier|static
name|bool
name|classof
argument_list|(
argument|const ConstantArrayWithoutExprType *
argument_list|)
block|{
return|return
name|true
return|;
block|}
name|void
name|Profile
argument_list|(
argument|llvm::FoldingSetNodeID&ID
argument_list|)
block|{
name|assert
argument_list|(
literal|0
operator|&&
literal|"Cannot unique ConstantArrayWithoutExprTypes."
argument_list|)
block|;   }
expr|}
block|;
comment|/// IncompleteArrayType - This class represents C arrays with an unspecified
comment|/// size.  For example 'int A[]' has an IncompleteArrayType where the element
comment|/// type is 'int' and the size is unspecified.
name|class
name|IncompleteArrayType
operator|:
name|public
name|ArrayType
block|{
name|IncompleteArrayType
argument_list|(
argument|QualType et
argument_list|,
argument|QualType can
argument_list|,
argument|ArraySizeModifier sm
argument_list|,
argument|unsigned tq
argument_list|)
operator|:
name|ArrayType
argument_list|(
argument|IncompleteArray
argument_list|,
argument|et
argument_list|,
argument|can
argument_list|,
argument|sm
argument_list|,
argument|tq
argument_list|)
block|{}
name|friend
name|class
name|ASTContext
block|;
comment|// ASTContext creates these.
name|public
operator|:
name|virtual
name|void
name|getAsStringInternal
argument_list|(
argument|std::string&InnerString
argument_list|,
argument|const PrintingPolicy&Policy
argument_list|)
specifier|const
block|;
name|bool
name|isSugared
argument_list|()
specifier|const
block|{
return|return
name|false
return|;
block|}
name|QualType
name|desugar
argument_list|()
specifier|const
block|{
return|return
name|QualType
argument_list|(
name|this
argument_list|,
literal|0
argument_list|)
return|;
block|}
specifier|static
name|bool
name|classof
argument_list|(
argument|const Type *T
argument_list|)
block|{
return|return
name|T
operator|->
name|getTypeClass
argument_list|()
operator|==
name|IncompleteArray
return|;
block|}
specifier|static
name|bool
name|classof
argument_list|(
argument|const IncompleteArrayType *
argument_list|)
block|{
return|return
name|true
return|;
block|}
name|friend
name|class
name|StmtIteratorBase
block|;
name|void
name|Profile
argument_list|(
argument|llvm::FoldingSetNodeID&ID
argument_list|)
block|{
name|Profile
argument_list|(
name|ID
argument_list|,
name|getElementType
argument_list|()
argument_list|,
name|getSizeModifier
argument_list|()
argument_list|,
name|getIndexTypeCVRQualifiers
argument_list|()
argument_list|)
block|;   }
specifier|static
name|void
name|Profile
argument_list|(
argument|llvm::FoldingSetNodeID&ID
argument_list|,
argument|QualType ET
argument_list|,
argument|ArraySizeModifier SizeMod
argument_list|,
argument|unsigned TypeQuals
argument_list|)
block|{
name|ID
operator|.
name|AddPointer
argument_list|(
name|ET
operator|.
name|getAsOpaquePtr
argument_list|()
argument_list|)
block|;
name|ID
operator|.
name|AddInteger
argument_list|(
name|SizeMod
argument_list|)
block|;
name|ID
operator|.
name|AddInteger
argument_list|(
name|TypeQuals
argument_list|)
block|;   }
block|}
block|;
comment|/// VariableArrayType - This class represents C arrays with a specified size
comment|/// which is not an integer-constant-expression.  For example, 'int s[x+foo()]'.
comment|/// Since the size expression is an arbitrary expression, we store it as such.
comment|///
comment|/// Note: VariableArrayType's aren't uniqued (since the expressions aren't) and
comment|/// should not be: two lexically equivalent variable array types could mean
comment|/// different things, for example, these variables do not have the same type
comment|/// dynamically:
comment|///
comment|/// void foo(int x) {
comment|///   int Y[x];
comment|///   ++x;
comment|///   int Z[x];
comment|/// }
comment|///
name|class
name|VariableArrayType
operator|:
name|public
name|ArrayType
block|{
comment|/// SizeExpr - An assignment expression. VLA's are only permitted within
comment|/// a function block.
name|Stmt
operator|*
name|SizeExpr
block|;
comment|/// Brackets - The left and right array brackets.
name|SourceRange
name|Brackets
block|;
name|VariableArrayType
argument_list|(
argument|QualType et
argument_list|,
argument|QualType can
argument_list|,
argument|Expr *e
argument_list|,
argument|ArraySizeModifier sm
argument_list|,
argument|unsigned tq
argument_list|,
argument|SourceRange brackets
argument_list|)
operator|:
name|ArrayType
argument_list|(
name|VariableArray
argument_list|,
name|et
argument_list|,
name|can
argument_list|,
name|sm
argument_list|,
name|tq
argument_list|)
block|,
name|SizeExpr
argument_list|(
operator|(
name|Stmt
operator|*
operator|)
name|e
argument_list|)
block|,
name|Brackets
argument_list|(
argument|brackets
argument_list|)
block|{}
name|friend
name|class
name|ASTContext
block|;
comment|// ASTContext creates these.
name|virtual
name|void
name|Destroy
argument_list|(
name|ASTContext
operator|&
name|C
argument_list|)
block|;
name|public
operator|:
name|Expr
operator|*
name|getSizeExpr
argument_list|()
specifier|const
block|{
comment|// We use C-style casts instead of cast<> here because we do not wish
comment|// to have a dependency of Type.h on Stmt.h/Expr.h.
return|return
operator|(
name|Expr
operator|*
operator|)
name|SizeExpr
return|;
block|}
name|SourceRange
name|getBracketsRange
argument_list|()
specifier|const
block|{
return|return
name|Brackets
return|;
block|}
name|SourceLocation
name|getLBracketLoc
argument_list|()
specifier|const
block|{
return|return
name|Brackets
operator|.
name|getBegin
argument_list|()
return|;
block|}
name|SourceLocation
name|getRBracketLoc
argument_list|()
specifier|const
block|{
return|return
name|Brackets
operator|.
name|getEnd
argument_list|()
return|;
block|}
name|virtual
name|void
name|getAsStringInternal
argument_list|(
argument|std::string&InnerString
argument_list|,
argument|const PrintingPolicy&Policy
argument_list|)
specifier|const
block|;
name|bool
name|isSugared
argument_list|()
specifier|const
block|{
return|return
name|false
return|;
block|}
name|QualType
name|desugar
argument_list|()
specifier|const
block|{
return|return
name|QualType
argument_list|(
name|this
argument_list|,
literal|0
argument_list|)
return|;
block|}
specifier|static
name|bool
name|classof
argument_list|(
argument|const Type *T
argument_list|)
block|{
return|return
name|T
operator|->
name|getTypeClass
argument_list|()
operator|==
name|VariableArray
return|;
block|}
specifier|static
name|bool
name|classof
argument_list|(
argument|const VariableArrayType *
argument_list|)
block|{
return|return
name|true
return|;
block|}
name|friend
name|class
name|StmtIteratorBase
block|;
name|void
name|Profile
argument_list|(
argument|llvm::FoldingSetNodeID&ID
argument_list|)
block|{
name|assert
argument_list|(
literal|0
operator|&&
literal|"Cannnot unique VariableArrayTypes."
argument_list|)
block|;   }
block|}
block|;
comment|/// DependentSizedArrayType - This type represents an array type in
comment|/// C++ whose size is a value-dependent expression. For example:
comment|/// @code
comment|/// template<typename T, int Size>
comment|/// class array {
comment|///   T data[Size];
comment|/// };
comment|/// @endcode
comment|/// For these types, we won't actually know what the array bound is
comment|/// until template instantiation occurs, at which point this will
comment|/// become either a ConstantArrayType or a VariableArrayType.
name|class
name|DependentSizedArrayType
operator|:
name|public
name|ArrayType
block|{
name|ASTContext
operator|&
name|Context
block|;
comment|/// SizeExpr - An assignment expression that will instantiate to the
comment|/// size of the array.
name|Stmt
operator|*
name|SizeExpr
block|;
comment|/// Brackets - The left and right array brackets.
name|SourceRange
name|Brackets
block|;
name|DependentSizedArrayType
argument_list|(
argument|ASTContext&Context
argument_list|,
argument|QualType et
argument_list|,
argument|QualType can
argument_list|,
argument|Expr *e
argument_list|,
argument|ArraySizeModifier sm
argument_list|,
argument|unsigned tq
argument_list|,
argument|SourceRange brackets
argument_list|)
operator|:
name|ArrayType
argument_list|(
name|DependentSizedArray
argument_list|,
name|et
argument_list|,
name|can
argument_list|,
name|sm
argument_list|,
name|tq
argument_list|)
block|,
name|Context
argument_list|(
name|Context
argument_list|)
block|,
name|SizeExpr
argument_list|(
operator|(
name|Stmt
operator|*
operator|)
name|e
argument_list|)
block|,
name|Brackets
argument_list|(
argument|brackets
argument_list|)
block|{}
name|friend
name|class
name|ASTContext
block|;
comment|// ASTContext creates these.
name|virtual
name|void
name|Destroy
argument_list|(
name|ASTContext
operator|&
name|C
argument_list|)
block|;
name|public
operator|:
name|Expr
operator|*
name|getSizeExpr
argument_list|()
specifier|const
block|{
comment|// We use C-style casts instead of cast<> here because we do not wish
comment|// to have a dependency of Type.h on Stmt.h/Expr.h.
return|return
operator|(
name|Expr
operator|*
operator|)
name|SizeExpr
return|;
block|}
name|SourceRange
name|getBracketsRange
argument_list|()
specifier|const
block|{
return|return
name|Brackets
return|;
block|}
name|SourceLocation
name|getLBracketLoc
argument_list|()
specifier|const
block|{
return|return
name|Brackets
operator|.
name|getBegin
argument_list|()
return|;
block|}
name|SourceLocation
name|getRBracketLoc
argument_list|()
specifier|const
block|{
return|return
name|Brackets
operator|.
name|getEnd
argument_list|()
return|;
block|}
name|virtual
name|void
name|getAsStringInternal
argument_list|(
argument|std::string&InnerString
argument_list|,
argument|const PrintingPolicy&Policy
argument_list|)
specifier|const
block|;
name|bool
name|isSugared
argument_list|()
specifier|const
block|{
return|return
name|false
return|;
block|}
name|QualType
name|desugar
argument_list|()
specifier|const
block|{
return|return
name|QualType
argument_list|(
name|this
argument_list|,
literal|0
argument_list|)
return|;
block|}
specifier|static
name|bool
name|classof
argument_list|(
argument|const Type *T
argument_list|)
block|{
return|return
name|T
operator|->
name|getTypeClass
argument_list|()
operator|==
name|DependentSizedArray
return|;
block|}
specifier|static
name|bool
name|classof
argument_list|(
argument|const DependentSizedArrayType *
argument_list|)
block|{
return|return
name|true
return|;
block|}
name|friend
name|class
name|StmtIteratorBase
block|;
name|void
name|Profile
argument_list|(
argument|llvm::FoldingSetNodeID&ID
argument_list|)
block|{
name|Profile
argument_list|(
name|ID
argument_list|,
name|Context
argument_list|,
name|getElementType
argument_list|()
argument_list|,
name|getSizeModifier
argument_list|()
argument_list|,
name|getIndexTypeCVRQualifiers
argument_list|()
argument_list|,
name|getSizeExpr
argument_list|()
argument_list|)
block|;   }
specifier|static
name|void
name|Profile
argument_list|(
argument|llvm::FoldingSetNodeID&ID
argument_list|,
argument|ASTContext&Context
argument_list|,
argument|QualType ET
argument_list|,
argument|ArraySizeModifier SizeMod
argument_list|,
argument|unsigned TypeQuals
argument_list|,
argument|Expr *E
argument_list|)
block|; }
block|;
comment|/// DependentSizedExtVectorType - This type represent an extended vector type
comment|/// where either the type or size is dependent. For example:
comment|/// @code
comment|/// template<typename T, int Size>
comment|/// class vector {
comment|///   typedef T __attribute__((ext_vector_type(Size))) type;
comment|/// }
comment|/// @endcode
name|class
name|DependentSizedExtVectorType
operator|:
name|public
name|Type
block|,
name|public
name|llvm
operator|::
name|FoldingSetNode
block|{
name|ASTContext
operator|&
name|Context
block|;
name|Expr
operator|*
name|SizeExpr
block|;
comment|/// ElementType - The element type of the array.
name|QualType
name|ElementType
block|;
name|SourceLocation
name|loc
block|;
name|DependentSizedExtVectorType
argument_list|(
argument|ASTContext&Context
argument_list|,
argument|QualType ElementType
argument_list|,
argument|QualType can
argument_list|,
argument|Expr *SizeExpr
argument_list|,
argument|SourceLocation loc
argument_list|)
operator|:
name|Type
argument_list|(
name|DependentSizedExtVector
argument_list|,
name|can
argument_list|,
name|true
argument_list|)
block|,
name|Context
argument_list|(
name|Context
argument_list|)
block|,
name|SizeExpr
argument_list|(
name|SizeExpr
argument_list|)
block|,
name|ElementType
argument_list|(
name|ElementType
argument_list|)
block|,
name|loc
argument_list|(
argument|loc
argument_list|)
block|{}
name|friend
name|class
name|ASTContext
block|;
name|virtual
name|void
name|Destroy
argument_list|(
name|ASTContext
operator|&
name|C
argument_list|)
block|;
name|public
operator|:
name|Expr
operator|*
name|getSizeExpr
argument_list|()
specifier|const
block|{
return|return
name|SizeExpr
return|;
block|}
name|QualType
name|getElementType
argument_list|()
specifier|const
block|{
return|return
name|ElementType
return|;
block|}
name|SourceLocation
name|getAttributeLoc
argument_list|()
specifier|const
block|{
return|return
name|loc
return|;
block|}
name|virtual
name|void
name|getAsStringInternal
argument_list|(
argument|std::string&InnerString
argument_list|,
argument|const PrintingPolicy&Policy
argument_list|)
specifier|const
block|;
name|bool
name|isSugared
argument_list|()
specifier|const
block|{
return|return
name|false
return|;
block|}
name|QualType
name|desugar
argument_list|()
specifier|const
block|{
return|return
name|QualType
argument_list|(
name|this
argument_list|,
literal|0
argument_list|)
return|;
block|}
specifier|static
name|bool
name|classof
argument_list|(
argument|const Type *T
argument_list|)
block|{
return|return
name|T
operator|->
name|getTypeClass
argument_list|()
operator|==
name|DependentSizedExtVector
return|;
block|}
specifier|static
name|bool
name|classof
argument_list|(
argument|const DependentSizedExtVectorType *
argument_list|)
block|{
return|return
name|true
return|;
block|}
name|void
name|Profile
argument_list|(
argument|llvm::FoldingSetNodeID&ID
argument_list|)
block|{
name|Profile
argument_list|(
name|ID
argument_list|,
name|Context
argument_list|,
name|getElementType
argument_list|()
argument_list|,
name|getSizeExpr
argument_list|()
argument_list|)
block|;   }
specifier|static
name|void
name|Profile
argument_list|(
argument|llvm::FoldingSetNodeID&ID
argument_list|,
argument|ASTContext&Context
argument_list|,
argument|QualType ElementType
argument_list|,
argument|Expr *SizeExpr
argument_list|)
block|; }
block|;
comment|/// VectorType - GCC generic vector type. This type is created using
comment|/// __attribute__((vector_size(n)), where "n" specifies the vector size in
comment|/// bytes. Since the constructor takes the number of vector elements, the
comment|/// client is responsible for converting the size into the number of elements.
name|class
name|VectorType
operator|:
name|public
name|Type
block|,
name|public
name|llvm
operator|::
name|FoldingSetNode
block|{
name|protected
operator|:
comment|/// ElementType - The element type of the vector.
name|QualType
name|ElementType
block|;
comment|/// NumElements - The number of elements in the vector.
name|unsigned
name|NumElements
block|;
name|VectorType
argument_list|(
argument|QualType vecType
argument_list|,
argument|unsigned nElements
argument_list|,
argument|QualType canonType
argument_list|)
operator|:
name|Type
argument_list|(
name|Vector
argument_list|,
name|canonType
argument_list|,
name|vecType
operator|->
name|isDependentType
argument_list|()
argument_list|)
block|,
name|ElementType
argument_list|(
name|vecType
argument_list|)
block|,
name|NumElements
argument_list|(
argument|nElements
argument_list|)
block|{}
name|VectorType
argument_list|(
argument|TypeClass tc
argument_list|,
argument|QualType vecType
argument_list|,
argument|unsigned nElements
argument_list|,
argument|QualType canonType
argument_list|)
operator|:
name|Type
argument_list|(
name|tc
argument_list|,
name|canonType
argument_list|,
name|vecType
operator|->
name|isDependentType
argument_list|()
argument_list|)
block|,
name|ElementType
argument_list|(
name|vecType
argument_list|)
block|,
name|NumElements
argument_list|(
argument|nElements
argument_list|)
block|{}
name|friend
name|class
name|ASTContext
block|;
comment|// ASTContext creates these.
name|public
operator|:
name|QualType
name|getElementType
argument_list|()
specifier|const
block|{
return|return
name|ElementType
return|;
block|}
name|unsigned
name|getNumElements
argument_list|()
specifier|const
block|{
return|return
name|NumElements
return|;
block|}
name|virtual
name|void
name|getAsStringInternal
argument_list|(
argument|std::string&InnerString
argument_list|,
argument|const PrintingPolicy&Policy
argument_list|)
specifier|const
block|;
name|bool
name|isSugared
argument_list|()
specifier|const
block|{
return|return
name|false
return|;
block|}
name|QualType
name|desugar
argument_list|()
specifier|const
block|{
return|return
name|QualType
argument_list|(
name|this
argument_list|,
literal|0
argument_list|)
return|;
block|}
name|void
name|Profile
argument_list|(
argument|llvm::FoldingSetNodeID&ID
argument_list|)
block|{
name|Profile
argument_list|(
name|ID
argument_list|,
name|getElementType
argument_list|()
argument_list|,
name|getNumElements
argument_list|()
argument_list|,
name|getTypeClass
argument_list|()
argument_list|)
block|;   }
specifier|static
name|void
name|Profile
argument_list|(
argument|llvm::FoldingSetNodeID&ID
argument_list|,
argument|QualType ElementType
argument_list|,
argument|unsigned NumElements
argument_list|,
argument|TypeClass TypeClass
argument_list|)
block|{
name|ID
operator|.
name|AddPointer
argument_list|(
name|ElementType
operator|.
name|getAsOpaquePtr
argument_list|()
argument_list|)
block|;
name|ID
operator|.
name|AddInteger
argument_list|(
name|NumElements
argument_list|)
block|;
name|ID
operator|.
name|AddInteger
argument_list|(
name|TypeClass
argument_list|)
block|;   }
specifier|static
name|bool
name|classof
argument_list|(
argument|const Type *T
argument_list|)
block|{
return|return
name|T
operator|->
name|getTypeClass
argument_list|()
operator|==
name|Vector
operator|||
name|T
operator|->
name|getTypeClass
argument_list|()
operator|==
name|ExtVector
return|;
block|}
specifier|static
name|bool
name|classof
argument_list|(
argument|const VectorType *
argument_list|)
block|{
return|return
name|true
return|;
block|}
expr|}
block|;
comment|/// ExtVectorType - Extended vector type. This type is created using
comment|/// __attribute__((ext_vector_type(n)), where "n" is the number of elements.
comment|/// Unlike vector_size, ext_vector_type is only allowed on typedef's. This
comment|/// class enables syntactic extensions, like Vector Components for accessing
comment|/// points, colors, and textures (modeled after OpenGL Shading Language).
name|class
name|ExtVectorType
operator|:
name|public
name|VectorType
block|{
name|ExtVectorType
argument_list|(
argument|QualType vecType
argument_list|,
argument|unsigned nElements
argument_list|,
argument|QualType canonType
argument_list|)
operator|:
name|VectorType
argument_list|(
argument|ExtVector
argument_list|,
argument|vecType
argument_list|,
argument|nElements
argument_list|,
argument|canonType
argument_list|)
block|{}
name|friend
name|class
name|ASTContext
block|;
comment|// ASTContext creates these.
name|public
operator|:
specifier|static
name|int
name|getPointAccessorIdx
argument_list|(
argument|char c
argument_list|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
default|default:
return|return
operator|-
literal|1
return|;
case|case
literal|'x'
case|:
return|return
literal|0
return|;
case|case
literal|'y'
case|:
return|return
literal|1
return|;
case|case
literal|'z'
case|:
return|return
literal|2
return|;
case|case
literal|'w'
case|:
return|return
literal|3
return|;
block|}
block|}
specifier|static
name|int
name|getNumericAccessorIdx
argument_list|(
argument|char c
argument_list|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
default|default:
return|return
operator|-
literal|1
return|;
case|case
literal|'0'
case|:
return|return
literal|0
return|;
case|case
literal|'1'
case|:
return|return
literal|1
return|;
case|case
literal|'2'
case|:
return|return
literal|2
return|;
case|case
literal|'3'
case|:
return|return
literal|3
return|;
case|case
literal|'4'
case|:
return|return
literal|4
return|;
case|case
literal|'5'
case|:
return|return
literal|5
return|;
case|case
literal|'6'
case|:
return|return
literal|6
return|;
case|case
literal|'7'
case|:
return|return
literal|7
return|;
case|case
literal|'8'
case|:
return|return
literal|8
return|;
case|case
literal|'9'
case|:
return|return
literal|9
return|;
case|case
literal|'A'
case|:
case|case
literal|'a'
case|:
return|return
literal|10
return|;
case|case
literal|'B'
case|:
case|case
literal|'b'
case|:
return|return
literal|11
return|;
case|case
literal|'C'
case|:
case|case
literal|'c'
case|:
return|return
literal|12
return|;
case|case
literal|'D'
case|:
case|case
literal|'d'
case|:
return|return
literal|13
return|;
case|case
literal|'E'
case|:
case|case
literal|'e'
case|:
return|return
literal|14
return|;
case|case
literal|'F'
case|:
case|case
literal|'f'
case|:
return|return
literal|15
return|;
block|}
block|}
specifier|static
name|int
name|getAccessorIdx
argument_list|(
argument|char c
argument_list|)
block|{
if|if
condition|(
name|int
name|idx
init|=
name|getPointAccessorIdx
argument_list|(
name|c
argument_list|)
operator|+
literal|1
condition|)
return|return
name|idx
operator|-
literal|1
return|;
return|return
name|getNumericAccessorIdx
argument_list|(
name|c
argument_list|)
return|;
block|}
name|bool
name|isAccessorWithinNumElements
argument_list|(
argument|char c
argument_list|)
specifier|const
block|{
if|if
condition|(
name|int
name|idx
init|=
name|getAccessorIdx
argument_list|(
name|c
argument_list|)
operator|+
literal|1
condition|)
return|return
name|unsigned
argument_list|(
name|idx
operator|-
literal|1
argument_list|)
operator|<
name|NumElements
return|;
return|return
name|false
return|;
block|}
name|virtual
name|void
name|getAsStringInternal
argument_list|(
argument|std::string&InnerString
argument_list|,
argument|const PrintingPolicy&Policy
argument_list|)
specifier|const
block|;
name|bool
name|isSugared
argument_list|()
specifier|const
block|{
return|return
name|false
return|;
block|}
name|QualType
name|desugar
argument_list|()
specifier|const
block|{
return|return
name|QualType
argument_list|(
name|this
argument_list|,
literal|0
argument_list|)
return|;
block|}
specifier|static
name|bool
name|classof
argument_list|(
argument|const Type *T
argument_list|)
block|{
return|return
name|T
operator|->
name|getTypeClass
argument_list|()
operator|==
name|ExtVector
return|;
block|}
specifier|static
name|bool
name|classof
argument_list|(
argument|const ExtVectorType *
argument_list|)
block|{
return|return
name|true
return|;
block|}
expr|}
block|;
comment|/// FunctionType - C99 6.7.5.3 - Function Declarators.  This is the common base
comment|/// class of FunctionNoProtoType and FunctionProtoType.
comment|///
name|class
name|FunctionType
operator|:
name|public
name|Type
block|{
comment|/// SubClassData - This field is owned by the subclass, put here to pack
comment|/// tightly with the ivars in Type.
name|bool
name|SubClassData
operator|:
literal|1
block|;
comment|/// TypeQuals - Used only by FunctionProtoType, put here to pack with the
comment|/// other bitfields.
comment|/// The qualifiers are part of FunctionProtoType because...
comment|///
comment|/// C++ 8.3.5p4: The return type, the parameter type list and the
comment|/// cv-qualifier-seq, [...], are part of the function type.
comment|///
name|unsigned
name|TypeQuals
operator|:
literal|3
block|;
comment|/// NoReturn - Indicates if the function type is attribute noreturn.
name|unsigned
name|NoReturn
operator|:
literal|1
block|;
comment|// The type returned by the function.
name|QualType
name|ResultType
block|;
name|protected
operator|:
name|FunctionType
argument_list|(
argument|TypeClass tc
argument_list|,
argument|QualType res
argument_list|,
argument|bool SubclassInfo
argument_list|,
argument|unsigned typeQuals
argument_list|,
argument|QualType Canonical
argument_list|,
argument|bool Dependent
argument_list|,
argument|bool noReturn = false
argument_list|)
operator|:
name|Type
argument_list|(
name|tc
argument_list|,
name|Canonical
argument_list|,
name|Dependent
argument_list|)
block|,
name|SubClassData
argument_list|(
name|SubclassInfo
argument_list|)
block|,
name|TypeQuals
argument_list|(
name|typeQuals
argument_list|)
block|,
name|NoReturn
argument_list|(
name|noReturn
argument_list|)
block|,
name|ResultType
argument_list|(
argument|res
argument_list|)
block|{}
name|bool
name|getSubClassData
argument_list|()
specifier|const
block|{
return|return
name|SubClassData
return|;
block|}
name|unsigned
name|getTypeQuals
argument_list|()
specifier|const
block|{
return|return
name|TypeQuals
return|;
block|}
name|public
operator|:
name|QualType
name|getResultType
argument_list|()
specifier|const
block|{
return|return
name|ResultType
return|;
block|}
name|bool
name|getNoReturnAttr
argument_list|()
specifier|const
block|{
return|return
name|NoReturn
return|;
block|}
specifier|static
name|bool
name|classof
argument_list|(
argument|const Type *T
argument_list|)
block|{
return|return
name|T
operator|->
name|getTypeClass
argument_list|()
operator|==
name|FunctionNoProto
operator|||
name|T
operator|->
name|getTypeClass
argument_list|()
operator|==
name|FunctionProto
return|;
block|}
specifier|static
name|bool
name|classof
argument_list|(
argument|const FunctionType *
argument_list|)
block|{
return|return
name|true
return|;
block|}
expr|}
block|;
comment|/// FunctionNoProtoType - Represents a K&R-style 'int foo()' function, which has
comment|/// no information available about its arguments.
name|class
name|FunctionNoProtoType
operator|:
name|public
name|FunctionType
block|,
name|public
name|llvm
operator|::
name|FoldingSetNode
block|{
name|FunctionNoProtoType
argument_list|(
argument|QualType Result
argument_list|,
argument|QualType Canonical
argument_list|,
argument|bool NoReturn = false
argument_list|)
operator|:
name|FunctionType
argument_list|(
argument|FunctionNoProto
argument_list|,
argument|Result
argument_list|,
argument|false
argument_list|,
literal|0
argument_list|,
argument|Canonical
argument_list|,
comment|/*Dependent=*/
argument|false
argument_list|,
argument|NoReturn
argument_list|)
block|{}
name|friend
name|class
name|ASTContext
block|;
comment|// ASTContext creates these.
name|public
operator|:
comment|// No additional state past what FunctionType provides.
name|virtual
name|void
name|getAsStringInternal
argument_list|(
argument|std::string&InnerString
argument_list|,
argument|const PrintingPolicy&Policy
argument_list|)
specifier|const
block|;
name|bool
name|isSugared
argument_list|()
specifier|const
block|{
return|return
name|false
return|;
block|}
name|QualType
name|desugar
argument_list|()
specifier|const
block|{
return|return
name|QualType
argument_list|(
name|this
argument_list|,
literal|0
argument_list|)
return|;
block|}
name|void
name|Profile
argument_list|(
argument|llvm::FoldingSetNodeID&ID
argument_list|)
block|{
name|Profile
argument_list|(
name|ID
argument_list|,
name|getResultType
argument_list|()
argument_list|,
name|getNoReturnAttr
argument_list|()
argument_list|)
block|;   }
specifier|static
name|void
name|Profile
argument_list|(
argument|llvm::FoldingSetNodeID&ID
argument_list|,
argument|QualType ResultType
argument_list|,
argument|bool NoReturn
argument_list|)
block|{
name|ID
operator|.
name|AddInteger
argument_list|(
name|NoReturn
argument_list|)
block|;
name|ID
operator|.
name|AddPointer
argument_list|(
name|ResultType
operator|.
name|getAsOpaquePtr
argument_list|()
argument_list|)
block|;   }
specifier|static
name|bool
name|classof
argument_list|(
argument|const Type *T
argument_list|)
block|{
return|return
name|T
operator|->
name|getTypeClass
argument_list|()
operator|==
name|FunctionNoProto
return|;
block|}
specifier|static
name|bool
name|classof
argument_list|(
argument|const FunctionNoProtoType *
argument_list|)
block|{
return|return
name|true
return|;
block|}
expr|}
block|;
comment|/// FunctionProtoType - Represents a prototype with argument type info, e.g.
comment|/// 'int foo(int)' or 'int foo(void)'.  'void' is represented as having no
comment|/// arguments, not as having a single void argument. Such a type can have an
comment|/// exception specification, but this specification is not part of the canonical
comment|/// type.
name|class
name|FunctionProtoType
operator|:
name|public
name|FunctionType
block|,
name|public
name|llvm
operator|::
name|FoldingSetNode
block|{
comment|/// hasAnyDependentType - Determine whether there are any dependent
comment|/// types within the arguments passed in.
specifier|static
name|bool
name|hasAnyDependentType
argument_list|(
argument|const QualType *ArgArray
argument_list|,
argument|unsigned numArgs
argument_list|)
block|{
for|for
control|(
name|unsigned
name|Idx
init|=
literal|0
init|;
name|Idx
operator|<
name|numArgs
condition|;
operator|++
name|Idx
control|)
if|if
condition|(
name|ArgArray
index|[
name|Idx
index|]
operator|->
name|isDependentType
argument_list|()
condition|)
return|return
name|true
return|;
return|return
name|false
return|;
block|}
name|FunctionProtoType
argument_list|(
argument|QualType Result
argument_list|,
argument|const QualType *ArgArray
argument_list|,
argument|unsigned numArgs
argument_list|,
argument|bool isVariadic
argument_list|,
argument|unsigned typeQuals
argument_list|,
argument|bool hasExs
argument_list|,
argument|bool hasAnyExs
argument_list|,
argument|const QualType *ExArray
argument_list|,
argument|unsigned numExs
argument_list|,
argument|QualType Canonical
argument_list|,
argument|bool NoReturn
argument_list|)
operator|:
name|FunctionType
argument_list|(
name|FunctionProto
argument_list|,
name|Result
argument_list|,
name|isVariadic
argument_list|,
name|typeQuals
argument_list|,
name|Canonical
argument_list|,
operator|(
name|Result
operator|->
name|isDependentType
argument_list|()
operator|||
name|hasAnyDependentType
argument_list|(
name|ArgArray
argument_list|,
name|numArgs
argument_list|)
operator|)
argument_list|,
name|NoReturn
argument_list|)
block|,
name|NumArgs
argument_list|(
name|numArgs
argument_list|)
block|,
name|NumExceptions
argument_list|(
name|numExs
argument_list|)
block|,
name|HasExceptionSpec
argument_list|(
name|hasExs
argument_list|)
block|,
name|AnyExceptionSpec
argument_list|(
argument|hasAnyExs
argument_list|)
block|{
comment|// Fill in the trailing argument array.
name|QualType
operator|*
name|ArgInfo
operator|=
name|reinterpret_cast
operator|<
name|QualType
operator|*
operator|>
operator|(
name|this
operator|+
literal|1
operator|)
block|;
for|for
control|(
name|unsigned
name|i
init|=
literal|0
init|;
name|i
operator|!=
name|numArgs
condition|;
operator|++
name|i
control|)
name|ArgInfo
index|[
name|i
index|]
operator|=
name|ArgArray
index|[
name|i
index|]
expr_stmt|;
comment|// Fill in the exception array.
name|QualType
operator|*
name|Ex
operator|=
name|ArgInfo
operator|+
name|numArgs
block|;
for|for
control|(
name|unsigned
name|i
init|=
literal|0
init|;
name|i
operator|!=
name|numExs
condition|;
operator|++
name|i
control|)
name|Ex
index|[
name|i
index|]
operator|=
name|ExArray
index|[
name|i
index|]
expr_stmt|;
block|}
comment|/// NumArgs - The number of arguments this function has, not counting '...'.
name|unsigned
name|NumArgs
operator|:
literal|20
block|;
comment|/// NumExceptions - The number of types in the exception spec, if any.
name|unsigned
name|NumExceptions
operator|:
literal|10
block|;
comment|/// HasExceptionSpec - Whether this function has an exception spec at all.
name|bool
name|HasExceptionSpec
operator|:
literal|1
block|;
comment|/// AnyExceptionSpec - Whether this function has a throw(...) spec.
name|bool
name|AnyExceptionSpec
operator|:
literal|1
block|;
comment|/// ArgInfo - There is an variable size array after the class in memory that
comment|/// holds the argument types.
comment|/// Exceptions - There is another variable size array after ArgInfo that
comment|/// holds the exception types.
name|friend
name|class
name|ASTContext
block|;
comment|// ASTContext creates these.
name|public
operator|:
name|unsigned
name|getNumArgs
argument_list|()
specifier|const
block|{
return|return
name|NumArgs
return|;
block|}
name|QualType
name|getArgType
argument_list|(
argument|unsigned i
argument_list|)
specifier|const
block|{
name|assert
argument_list|(
name|i
operator|<
name|NumArgs
operator|&&
literal|"Invalid argument number!"
argument_list|)
block|;
return|return
name|arg_type_begin
argument_list|()
index|[
name|i
index|]
return|;
block|}
name|bool
name|hasExceptionSpec
argument_list|()
specifier|const
block|{
return|return
name|HasExceptionSpec
return|;
block|}
name|bool
name|hasAnyExceptionSpec
argument_list|()
specifier|const
block|{
return|return
name|AnyExceptionSpec
return|;
block|}
name|unsigned
name|getNumExceptions
argument_list|()
specifier|const
block|{
return|return
name|NumExceptions
return|;
block|}
name|QualType
name|getExceptionType
argument_list|(
argument|unsigned i
argument_list|)
specifier|const
block|{
name|assert
argument_list|(
name|i
operator|<
name|NumExceptions
operator|&&
literal|"Invalid exception number!"
argument_list|)
block|;
return|return
name|exception_begin
argument_list|()
index|[
name|i
index|]
return|;
block|}
name|bool
name|hasEmptyExceptionSpec
argument_list|()
specifier|const
block|{
return|return
name|hasExceptionSpec
argument_list|()
operator|&&
operator|!
name|hasAnyExceptionSpec
argument_list|()
operator|&&
name|getNumExceptions
argument_list|()
operator|==
literal|0
return|;
block|}
name|bool
name|isVariadic
argument_list|()
specifier|const
block|{
return|return
name|getSubClassData
argument_list|()
return|;
block|}
name|unsigned
name|getTypeQuals
argument_list|()
specifier|const
block|{
return|return
name|FunctionType
operator|::
name|getTypeQuals
argument_list|()
return|;
block|}
typedef|typedef
specifier|const
name|QualType
modifier|*
name|arg_type_iterator
typedef|;
name|arg_type_iterator
name|arg_type_begin
argument_list|()
specifier|const
block|{
return|return
name|reinterpret_cast
operator|<
specifier|const
name|QualType
operator|*
operator|>
operator|(
name|this
operator|+
literal|1
operator|)
return|;
block|}
name|arg_type_iterator
name|arg_type_end
argument_list|()
specifier|const
block|{
return|return
name|arg_type_begin
argument_list|()
operator|+
name|NumArgs
return|;
block|}
typedef|typedef
specifier|const
name|QualType
modifier|*
name|exception_iterator
typedef|;
name|exception_iterator
name|exception_begin
argument_list|()
specifier|const
block|{
comment|// exceptions begin where arguments end
return|return
name|arg_type_end
argument_list|()
return|;
block|}
name|exception_iterator
name|exception_end
argument_list|()
specifier|const
block|{
return|return
name|exception_begin
argument_list|()
operator|+
name|NumExceptions
return|;
block|}
name|virtual
name|void
name|getAsStringInternal
argument_list|(
argument|std::string&InnerString
argument_list|,
argument|const PrintingPolicy&Policy
argument_list|)
specifier|const
block|;
name|bool
name|isSugared
argument_list|()
specifier|const
block|{
return|return
name|false
return|;
block|}
name|QualType
name|desugar
argument_list|()
specifier|const
block|{
return|return
name|QualType
argument_list|(
name|this
argument_list|,
literal|0
argument_list|)
return|;
block|}
specifier|static
name|bool
name|classof
argument_list|(
argument|const Type *T
argument_list|)
block|{
return|return
name|T
operator|->
name|getTypeClass
argument_list|()
operator|==
name|FunctionProto
return|;
block|}
specifier|static
name|bool
name|classof
argument_list|(
argument|const FunctionProtoType *
argument_list|)
block|{
return|return
name|true
return|;
block|}
name|void
name|Profile
argument_list|(
name|llvm
operator|::
name|FoldingSetNodeID
operator|&
name|ID
argument_list|)
block|;
specifier|static
name|void
name|Profile
argument_list|(
argument|llvm::FoldingSetNodeID&ID
argument_list|,
argument|QualType Result
argument_list|,
argument|arg_type_iterator ArgTys
argument_list|,
argument|unsigned NumArgs
argument_list|,
argument|bool isVariadic
argument_list|,
argument|unsigned TypeQuals
argument_list|,
argument|bool hasExceptionSpec
argument_list|,
argument|bool anyExceptionSpec
argument_list|,
argument|unsigned NumExceptions
argument_list|,
argument|exception_iterator Exs
argument_list|,
argument|bool NoReturn
argument_list|)
block|; }
block|;
name|class
name|TypedefType
operator|:
name|public
name|Type
block|{
name|TypedefDecl
operator|*
name|Decl
block|;
name|protected
operator|:
name|TypedefType
argument_list|(
argument|TypeClass tc
argument_list|,
argument|TypedefDecl *D
argument_list|,
argument|QualType can
argument_list|)
operator|:
name|Type
argument_list|(
name|tc
argument_list|,
name|can
argument_list|,
name|can
operator|->
name|isDependentType
argument_list|()
argument_list|)
block|,
name|Decl
argument_list|(
argument|D
argument_list|)
block|{
name|assert
argument_list|(
operator|!
name|isa
operator|<
name|TypedefType
operator|>
operator|(
name|can
operator|)
operator|&&
literal|"Invalid canonical type"
argument_list|)
block|;   }
name|friend
name|class
name|ASTContext
block|;
comment|// ASTContext creates these.
name|public
operator|:
name|TypedefDecl
operator|*
name|getDecl
argument_list|()
specifier|const
block|{
return|return
name|Decl
return|;
block|}
comment|/// LookThroughTypedefs - Return the ultimate type this typedef corresponds to
comment|/// potentially looking through *all* consecutive typedefs.  This returns the
comment|/// sum of the type qualifiers, so if you have:
comment|///   typedef const int A;
comment|///   typedef volatile A B;
comment|/// looking through the typedefs for B will give you "const volatile A".
name|QualType
name|LookThroughTypedefs
argument_list|()
specifier|const
block|;
name|bool
name|isSugared
argument_list|()
specifier|const
block|{
return|return
name|true
return|;
block|}
name|QualType
name|desugar
argument_list|()
specifier|const
block|;
name|virtual
name|void
name|getAsStringInternal
argument_list|(
argument|std::string&InnerString
argument_list|,
argument|const PrintingPolicy&Policy
argument_list|)
specifier|const
block|;
specifier|static
name|bool
name|classof
argument_list|(
argument|const Type *T
argument_list|)
block|{
return|return
name|T
operator|->
name|getTypeClass
argument_list|()
operator|==
name|Typedef
return|;
block|}
specifier|static
name|bool
name|classof
argument_list|(
argument|const TypedefType *
argument_list|)
block|{
return|return
name|true
return|;
block|}
expr|}
block|;
comment|/// TypeOfExprType (GCC extension).
name|class
name|TypeOfExprType
operator|:
name|public
name|Type
block|{
name|Expr
operator|*
name|TOExpr
block|;
name|protected
operator|:
name|TypeOfExprType
argument_list|(
argument|Expr *E
argument_list|,
argument|QualType can = QualType()
argument_list|)
block|;
name|friend
name|class
name|ASTContext
block|;
comment|// ASTContext creates these.
name|public
operator|:
name|Expr
operator|*
name|getUnderlyingExpr
argument_list|()
specifier|const
block|{
return|return
name|TOExpr
return|;
block|}
comment|/// \brief Remove a single level of sugar.
name|QualType
name|desugar
argument_list|()
specifier|const
block|;
comment|/// \brief Returns whether this type directly provides sugar.
name|bool
name|isSugared
argument_list|()
specifier|const
block|{
return|return
name|true
return|;
block|}
name|virtual
name|void
name|getAsStringInternal
argument_list|(
argument|std::string&InnerString
argument_list|,
argument|const PrintingPolicy&Policy
argument_list|)
specifier|const
block|;
specifier|static
name|bool
name|classof
argument_list|(
argument|const Type *T
argument_list|)
block|{
return|return
name|T
operator|->
name|getTypeClass
argument_list|()
operator|==
name|TypeOfExpr
return|;
block|}
specifier|static
name|bool
name|classof
argument_list|(
argument|const TypeOfExprType *
argument_list|)
block|{
return|return
name|true
return|;
block|}
expr|}
block|;
comment|/// Subclass of TypeOfExprType that is used for canonical, dependent
comment|/// typeof(expr) types.
name|class
name|DependentTypeOfExprType
operator|:
name|public
name|TypeOfExprType
block|,
name|public
name|llvm
operator|::
name|FoldingSetNode
block|{
name|ASTContext
operator|&
name|Context
block|;
name|public
operator|:
name|DependentTypeOfExprType
argument_list|(
name|ASTContext
operator|&
name|Context
argument_list|,
name|Expr
operator|*
name|E
argument_list|)
operator|:
name|TypeOfExprType
argument_list|(
name|E
argument_list|)
block|,
name|Context
argument_list|(
argument|Context
argument_list|)
block|{ }
name|bool
name|isSugared
argument_list|()
specifier|const
block|{
return|return
name|false
return|;
block|}
name|QualType
name|desugar
argument_list|()
specifier|const
block|{
return|return
name|QualType
argument_list|(
name|this
argument_list|,
literal|0
argument_list|)
return|;
block|}
name|void
name|Profile
argument_list|(
argument|llvm::FoldingSetNodeID&ID
argument_list|)
block|{
name|Profile
argument_list|(
name|ID
argument_list|,
name|Context
argument_list|,
name|getUnderlyingExpr
argument_list|()
argument_list|)
block|;   }
specifier|static
name|void
name|Profile
argument_list|(
name|llvm
operator|::
name|FoldingSetNodeID
operator|&
name|ID
argument_list|,
name|ASTContext
operator|&
name|Context
argument_list|,
name|Expr
operator|*
name|E
argument_list|)
block|; }
block|;
comment|/// TypeOfType (GCC extension).
name|class
name|TypeOfType
operator|:
name|public
name|Type
block|{
name|QualType
name|TOType
block|;
name|TypeOfType
argument_list|(
argument|QualType T
argument_list|,
argument|QualType can
argument_list|)
operator|:
name|Type
argument_list|(
name|TypeOf
argument_list|,
name|can
argument_list|,
name|T
operator|->
name|isDependentType
argument_list|()
argument_list|)
block|,
name|TOType
argument_list|(
argument|T
argument_list|)
block|{
name|assert
argument_list|(
operator|!
name|isa
operator|<
name|TypedefType
operator|>
operator|(
name|can
operator|)
operator|&&
literal|"Invalid canonical type"
argument_list|)
block|;   }
name|friend
name|class
name|ASTContext
block|;
comment|// ASTContext creates these.
name|public
operator|:
name|QualType
name|getUnderlyingType
argument_list|()
specifier|const
block|{
return|return
name|TOType
return|;
block|}
comment|/// \brief Remove a single level of sugar.
name|QualType
name|desugar
argument_list|()
specifier|const
block|{
return|return
name|getUnderlyingType
argument_list|()
return|;
block|}
comment|/// \brief Returns whether this type directly provides sugar.
name|bool
name|isSugared
argument_list|()
specifier|const
block|{
return|return
name|true
return|;
block|}
name|virtual
name|void
name|getAsStringInternal
argument_list|(
argument|std::string&InnerString
argument_list|,
argument|const PrintingPolicy&Policy
argument_list|)
specifier|const
block|;
specifier|static
name|bool
name|classof
argument_list|(
argument|const Type *T
argument_list|)
block|{
return|return
name|T
operator|->
name|getTypeClass
argument_list|()
operator|==
name|TypeOf
return|;
block|}
specifier|static
name|bool
name|classof
argument_list|(
argument|const TypeOfType *
argument_list|)
block|{
return|return
name|true
return|;
block|}
expr|}
block|;
comment|/// DecltypeType (C++0x)
name|class
name|DecltypeType
operator|:
name|public
name|Type
block|{
name|Expr
operator|*
name|E
block|;
comment|// FIXME: We could get rid of UnderlyingType if we wanted to: We would have to
comment|// Move getDesugaredType to ASTContext so that it can call getDecltypeForExpr
comment|// from it.
name|QualType
name|UnderlyingType
block|;
name|protected
operator|:
name|DecltypeType
argument_list|(
argument|Expr *E
argument_list|,
argument|QualType underlyingType
argument_list|,
argument|QualType can = QualType()
argument_list|)
block|;
name|friend
name|class
name|ASTContext
block|;
comment|// ASTContext creates these.
name|public
operator|:
name|Expr
operator|*
name|getUnderlyingExpr
argument_list|()
specifier|const
block|{
return|return
name|E
return|;
block|}
name|QualType
name|getUnderlyingType
argument_list|()
specifier|const
block|{
return|return
name|UnderlyingType
return|;
block|}
comment|/// \brief Remove a single level of sugar.
name|QualType
name|desugar
argument_list|()
specifier|const
block|{
return|return
name|getUnderlyingType
argument_list|()
return|;
block|}
comment|/// \brief Returns whether this type directly provides sugar.
name|bool
name|isSugared
argument_list|()
specifier|const
block|{
return|return
operator|!
name|isDependentType
argument_list|()
return|;
block|}
name|virtual
name|void
name|getAsStringInternal
argument_list|(
argument|std::string&InnerString
argument_list|,
argument|const PrintingPolicy&Policy
argument_list|)
specifier|const
block|;
specifier|static
name|bool
name|classof
argument_list|(
argument|const Type *T
argument_list|)
block|{
return|return
name|T
operator|->
name|getTypeClass
argument_list|()
operator|==
name|Decltype
return|;
block|}
specifier|static
name|bool
name|classof
argument_list|(
argument|const DecltypeType *
argument_list|)
block|{
return|return
name|true
return|;
block|}
expr|}
block|;
comment|/// Subclass of DecltypeType that is used for canonical, dependent
comment|/// C++0x decltype types.
name|class
name|DependentDecltypeType
operator|:
name|public
name|DecltypeType
block|,
name|public
name|llvm
operator|::
name|FoldingSetNode
block|{
name|ASTContext
operator|&
name|Context
block|;
name|public
operator|:
name|DependentDecltypeType
argument_list|(
name|ASTContext
operator|&
name|Context
argument_list|,
name|Expr
operator|*
name|E
argument_list|)
block|;
name|bool
name|isSugared
argument_list|()
specifier|const
block|{
return|return
name|false
return|;
block|}
name|QualType
name|desugar
argument_list|()
specifier|const
block|{
return|return
name|QualType
argument_list|(
name|this
argument_list|,
literal|0
argument_list|)
return|;
block|}
name|void
name|Profile
argument_list|(
argument|llvm::FoldingSetNodeID&ID
argument_list|)
block|{
name|Profile
argument_list|(
name|ID
argument_list|,
name|Context
argument_list|,
name|getUnderlyingExpr
argument_list|()
argument_list|)
block|;   }
specifier|static
name|void
name|Profile
argument_list|(
name|llvm
operator|::
name|FoldingSetNodeID
operator|&
name|ID
argument_list|,
name|ASTContext
operator|&
name|Context
argument_list|,
name|Expr
operator|*
name|E
argument_list|)
block|; }
block|;
name|class
name|TagType
operator|:
name|public
name|Type
block|{
comment|/// Stores the TagDecl associated with this type. The decl will
comment|/// point to the TagDecl that actually defines the entity (or is a
comment|/// definition in progress), if there is such a definition. The
comment|/// single-bit value will be non-zero when this tag is in the
comment|/// process of being defined.
name|mutable
name|llvm
operator|::
name|PointerIntPair
operator|<
name|TagDecl
operator|*
block|,
literal|1
operator|>
name|decl
block|;
name|friend
name|class
name|ASTContext
block|;
name|friend
name|class
name|TagDecl
block|;
name|protected
operator|:
name|TagType
argument_list|(
argument|TypeClass TC
argument_list|,
argument|TagDecl *D
argument_list|,
argument|QualType can
argument_list|)
block|;
name|public
operator|:
name|TagDecl
operator|*
name|getDecl
argument_list|()
specifier|const
block|{
return|return
name|decl
operator|.
name|getPointer
argument_list|()
return|;
block|}
comment|/// @brief Determines whether this type is in the process of being
comment|/// defined.
name|bool
name|isBeingDefined
argument_list|()
specifier|const
block|{
return|return
name|decl
operator|.
name|getInt
argument_list|()
return|;
block|}
name|void
name|setBeingDefined
argument_list|(
argument|bool Def
argument_list|)
specifier|const
block|{
name|decl
operator|.
name|setInt
argument_list|(
name|Def
operator|?
literal|1
operator|:
literal|0
argument_list|)
block|; }
name|virtual
name|void
name|getAsStringInternal
argument_list|(
argument|std::string&InnerString
argument_list|,
argument|const PrintingPolicy&Policy
argument_list|)
specifier|const
block|;
specifier|static
name|bool
name|classof
argument_list|(
argument|const Type *T
argument_list|)
block|{
return|return
name|T
operator|->
name|getTypeClass
argument_list|()
operator|>=
name|TagFirst
operator|&&
name|T
operator|->
name|getTypeClass
argument_list|()
operator|<=
name|TagLast
return|;
block|}
specifier|static
name|bool
name|classof
argument_list|(
argument|const TagType *
argument_list|)
block|{
return|return
name|true
return|;
block|}
specifier|static
name|bool
name|classof
argument_list|(
argument|const RecordType *
argument_list|)
block|{
return|return
name|true
return|;
block|}
specifier|static
name|bool
name|classof
argument_list|(
argument|const EnumType *
argument_list|)
block|{
return|return
name|true
return|;
block|}
expr|}
block|;
comment|/// RecordType - This is a helper class that allows the use of isa/cast/dyncast
comment|/// to detect TagType objects of structs/unions/classes.
name|class
name|RecordType
operator|:
name|public
name|TagType
block|{
name|protected
operator|:
name|explicit
name|RecordType
argument_list|(
name|RecordDecl
operator|*
name|D
argument_list|)
operator|:
name|TagType
argument_list|(
argument|Record
argument_list|,
argument|reinterpret_cast<TagDecl*>(D)
argument_list|,
argument|QualType()
argument_list|)
block|{ }
name|explicit
name|RecordType
argument_list|(
argument|TypeClass TC
argument_list|,
argument|RecordDecl *D
argument_list|)
operator|:
name|TagType
argument_list|(
argument|TC
argument_list|,
argument|reinterpret_cast<TagDecl*>(D)
argument_list|,
argument|QualType()
argument_list|)
block|{ }
name|friend
name|class
name|ASTContext
block|;
comment|// ASTContext creates these.
name|public
operator|:
name|RecordDecl
operator|*
name|getDecl
argument_list|()
specifier|const
block|{
return|return
name|reinterpret_cast
operator|<
name|RecordDecl
operator|*
operator|>
operator|(
name|TagType
operator|::
name|getDecl
argument_list|()
operator|)
return|;
block|}
comment|// FIXME: This predicate is a helper to QualType/Type. It needs to
comment|// recursively check all fields for const-ness. If any field is declared
comment|// const, it needs to return false.
name|bool
name|hasConstFields
argument_list|()
specifier|const
block|{
return|return
name|false
return|;
block|}
comment|// FIXME: RecordType needs to check when it is created that all fields are in
comment|// the same address space, and return that.
name|unsigned
name|getAddressSpace
argument_list|()
specifier|const
block|{
return|return
literal|0
return|;
block|}
name|bool
name|isSugared
argument_list|()
specifier|const
block|{
return|return
name|false
return|;
block|}
name|QualType
name|desugar
argument_list|()
specifier|const
block|{
return|return
name|QualType
argument_list|(
name|this
argument_list|,
literal|0
argument_list|)
return|;
block|}
specifier|static
name|bool
name|classof
argument_list|(
specifier|const
name|TagType
operator|*
name|T
argument_list|)
block|;
specifier|static
name|bool
name|classof
argument_list|(
argument|const Type *T
argument_list|)
block|{
return|return
name|isa
operator|<
name|TagType
operator|>
operator|(
name|T
operator|)
operator|&&
name|classof
argument_list|(
name|cast
operator|<
name|TagType
operator|>
operator|(
name|T
operator|)
argument_list|)
return|;
block|}
specifier|static
name|bool
name|classof
argument_list|(
argument|const RecordType *
argument_list|)
block|{
return|return
name|true
return|;
block|}
expr|}
block|;
comment|/// EnumType - This is a helper class that allows the use of isa/cast/dyncast
comment|/// to detect TagType objects of enums.
name|class
name|EnumType
operator|:
name|public
name|TagType
block|{
name|explicit
name|EnumType
argument_list|(
name|EnumDecl
operator|*
name|D
argument_list|)
operator|:
name|TagType
argument_list|(
argument|Enum
argument_list|,
argument|reinterpret_cast<TagDecl*>(D)
argument_list|,
argument|QualType()
argument_list|)
block|{ }
name|friend
name|class
name|ASTContext
block|;
comment|// ASTContext creates these.
name|public
operator|:
name|EnumDecl
operator|*
name|getDecl
argument_list|()
specifier|const
block|{
return|return
name|reinterpret_cast
operator|<
name|EnumDecl
operator|*
operator|>
operator|(
name|TagType
operator|::
name|getDecl
argument_list|()
operator|)
return|;
block|}
name|bool
name|isSugared
argument_list|()
specifier|const
block|{
return|return
name|false
return|;
block|}
name|QualType
name|desugar
argument_list|()
specifier|const
block|{
return|return
name|QualType
argument_list|(
name|this
argument_list|,
literal|0
argument_list|)
return|;
block|}
specifier|static
name|bool
name|classof
argument_list|(
specifier|const
name|TagType
operator|*
name|T
argument_list|)
block|;
specifier|static
name|bool
name|classof
argument_list|(
argument|const Type *T
argument_list|)
block|{
return|return
name|isa
operator|<
name|TagType
operator|>
operator|(
name|T
operator|)
operator|&&
name|classof
argument_list|(
name|cast
operator|<
name|TagType
operator|>
operator|(
name|T
operator|)
argument_list|)
return|;
block|}
specifier|static
name|bool
name|classof
argument_list|(
argument|const EnumType *
argument_list|)
block|{
return|return
name|true
return|;
block|}
expr|}
block|;
comment|/// ElaboratedType - A non-canonical type used to represents uses of
comment|/// elaborated type specifiers in C++.  For example:
comment|///
comment|///   void foo(union MyUnion);
comment|///            ^^^^^^^^^^^^^
comment|///
comment|/// At the moment, for efficiency we do not create elaborated types in
comment|/// C, since outside of typedefs all references to structs would
comment|/// necessarily be elaborated.
name|class
name|ElaboratedType
operator|:
name|public
name|Type
block|,
name|public
name|llvm
operator|::
name|FoldingSetNode
block|{
name|public
operator|:
expr|enum
name|TagKind
block|{
name|TK_struct
block|,
name|TK_union
block|,
name|TK_class
block|,
name|TK_enum
block|}
block|;
name|private
operator|:
comment|/// The tag that was used in this elaborated type specifier.
name|TagKind
name|Tag
block|;
comment|/// The underlying type.
name|QualType
name|UnderlyingType
block|;
name|explicit
name|ElaboratedType
argument_list|(
argument|QualType Ty
argument_list|,
argument|TagKind Tag
argument_list|,
argument|QualType Canon
argument_list|)
operator|:
name|Type
argument_list|(
name|Elaborated
argument_list|,
name|Canon
argument_list|,
name|Canon
operator|->
name|isDependentType
argument_list|()
argument_list|)
block|,
name|Tag
argument_list|(
name|Tag
argument_list|)
block|,
name|UnderlyingType
argument_list|(
argument|Ty
argument_list|)
block|{ }
name|friend
name|class
name|ASTContext
block|;
comment|// ASTContext creates these.
name|public
operator|:
name|TagKind
name|getTagKind
argument_list|()
specifier|const
block|{
return|return
name|Tag
return|;
block|}
name|QualType
name|getUnderlyingType
argument_list|()
specifier|const
block|{
return|return
name|UnderlyingType
return|;
block|}
comment|/// \brief Remove a single level of sugar.
name|QualType
name|desugar
argument_list|()
specifier|const
block|{
return|return
name|getUnderlyingType
argument_list|()
return|;
block|}
comment|/// \brief Returns whether this type directly provides sugar.
name|bool
name|isSugared
argument_list|()
specifier|const
block|{
return|return
name|true
return|;
block|}
specifier|static
specifier|const
name|char
operator|*
name|getNameForTagKind
argument_list|(
argument|TagKind Kind
argument_list|)
block|{
switch|switch
condition|(
name|Kind
condition|)
block|{
default|default:
name|assert
argument_list|(
literal|0
operator|&&
literal|"Unknown TagKind!"
argument_list|)
expr_stmt|;
case|case
name|TK_struct
case|:
return|return
literal|"struct"
return|;
case|case
name|TK_union
case|:
return|return
literal|"union"
return|;
case|case
name|TK_class
case|:
return|return
literal|"class"
return|;
case|case
name|TK_enum
case|:
return|return
literal|"enum"
return|;
block|}
block|}
name|virtual
name|void
name|getAsStringInternal
argument_list|(
argument|std::string&InnerString
argument_list|,
argument|const PrintingPolicy&Policy
argument_list|)
specifier|const
block|;
name|void
name|Profile
argument_list|(
argument|llvm::FoldingSetNodeID&ID
argument_list|)
block|{
name|Profile
argument_list|(
name|ID
argument_list|,
name|getUnderlyingType
argument_list|()
argument_list|,
name|getTagKind
argument_list|()
argument_list|)
block|;   }
specifier|static
name|void
name|Profile
argument_list|(
argument|llvm::FoldingSetNodeID&ID
argument_list|,
argument|QualType T
argument_list|,
argument|TagKind Tag
argument_list|)
block|{
name|ID
operator|.
name|AddPointer
argument_list|(
name|T
operator|.
name|getAsOpaquePtr
argument_list|()
argument_list|)
block|;
name|ID
operator|.
name|AddInteger
argument_list|(
name|Tag
argument_list|)
block|;   }
specifier|static
name|bool
name|classof
argument_list|(
argument|const ElaboratedType*
argument_list|)
block|{
return|return
name|true
return|;
block|}
specifier|static
name|bool
name|classof
argument_list|(
argument|const Type *T
argument_list|)
block|{
return|return
name|T
operator|->
name|getTypeClass
argument_list|()
operator|==
name|Elaborated
return|;
block|}
expr|}
block|;
name|class
name|TemplateTypeParmType
operator|:
name|public
name|Type
block|,
name|public
name|llvm
operator|::
name|FoldingSetNode
block|{
name|unsigned
name|Depth
operator|:
literal|15
block|;
name|unsigned
name|Index
operator|:
literal|16
block|;
name|unsigned
name|ParameterPack
operator|:
literal|1
block|;
name|IdentifierInfo
operator|*
name|Name
block|;
name|TemplateTypeParmType
argument_list|(
argument|unsigned D
argument_list|,
argument|unsigned I
argument_list|,
argument|bool PP
argument_list|,
argument|IdentifierInfo *N
argument_list|,
argument|QualType Canon
argument_list|)
operator|:
name|Type
argument_list|(
name|TemplateTypeParm
argument_list|,
name|Canon
argument_list|,
comment|/*Dependent=*/
name|true
argument_list|)
block|,
name|Depth
argument_list|(
name|D
argument_list|)
block|,
name|Index
argument_list|(
name|I
argument_list|)
block|,
name|ParameterPack
argument_list|(
name|PP
argument_list|)
block|,
name|Name
argument_list|(
argument|N
argument_list|)
block|{ }
name|TemplateTypeParmType
argument_list|(
argument|unsigned D
argument_list|,
argument|unsigned I
argument_list|,
argument|bool PP
argument_list|)
operator|:
name|Type
argument_list|(
name|TemplateTypeParm
argument_list|,
name|QualType
argument_list|(
name|this
argument_list|,
literal|0
argument_list|)
argument_list|,
comment|/*Dependent=*/
name|true
argument_list|)
block|,
name|Depth
argument_list|(
name|D
argument_list|)
block|,
name|Index
argument_list|(
name|I
argument_list|)
block|,
name|ParameterPack
argument_list|(
name|PP
argument_list|)
block|,
name|Name
argument_list|(
literal|0
argument_list|)
block|{ }
name|friend
name|class
name|ASTContext
block|;
comment|// ASTContext creates these
name|public
operator|:
name|unsigned
name|getDepth
argument_list|()
specifier|const
block|{
return|return
name|Depth
return|;
block|}
name|unsigned
name|getIndex
argument_list|()
specifier|const
block|{
return|return
name|Index
return|;
block|}
name|bool
name|isParameterPack
argument_list|()
specifier|const
block|{
return|return
name|ParameterPack
return|;
block|}
name|IdentifierInfo
operator|*
name|getName
argument_list|()
specifier|const
block|{
return|return
name|Name
return|;
block|}
name|virtual
name|void
name|getAsStringInternal
argument_list|(
argument|std::string&InnerString
argument_list|,
argument|const PrintingPolicy&Policy
argument_list|)
specifier|const
block|;
name|bool
name|isSugared
argument_list|()
specifier|const
block|{
return|return
name|false
return|;
block|}
name|QualType
name|desugar
argument_list|()
specifier|const
block|{
return|return
name|QualType
argument_list|(
name|this
argument_list|,
literal|0
argument_list|)
return|;
block|}
name|void
name|Profile
argument_list|(
argument|llvm::FoldingSetNodeID&ID
argument_list|)
block|{
name|Profile
argument_list|(
name|ID
argument_list|,
name|Depth
argument_list|,
name|Index
argument_list|,
name|ParameterPack
argument_list|,
name|Name
argument_list|)
block|;   }
specifier|static
name|void
name|Profile
argument_list|(
argument|llvm::FoldingSetNodeID&ID
argument_list|,
argument|unsigned Depth
argument_list|,
argument|unsigned Index
argument_list|,
argument|bool ParameterPack
argument_list|,
argument|IdentifierInfo *Name
argument_list|)
block|{
name|ID
operator|.
name|AddInteger
argument_list|(
name|Depth
argument_list|)
block|;
name|ID
operator|.
name|AddInteger
argument_list|(
name|Index
argument_list|)
block|;
name|ID
operator|.
name|AddBoolean
argument_list|(
name|ParameterPack
argument_list|)
block|;
name|ID
operator|.
name|AddPointer
argument_list|(
name|Name
argument_list|)
block|;   }
specifier|static
name|bool
name|classof
argument_list|(
argument|const Type *T
argument_list|)
block|{
return|return
name|T
operator|->
name|getTypeClass
argument_list|()
operator|==
name|TemplateTypeParm
return|;
block|}
specifier|static
name|bool
name|classof
argument_list|(
argument|const TemplateTypeParmType *T
argument_list|)
block|{
return|return
name|true
return|;
block|}
expr|}
block|;
comment|/// \brief Represents the type of a template specialization as written
comment|/// in the source code.
comment|///
comment|/// Template specialization types represent the syntactic form of a
comment|/// template-id that refers to a type, e.g., @c vector<int>. Some
comment|/// template specialization types are syntactic sugar, whose canonical
comment|/// type will point to some other type node that represents the
comment|/// instantiation or class template specialization. For example, a
comment|/// class template specialization type of @c vector<int> will refer to
comment|/// a tag type for the instantiation
comment|/// @c std::vector<int, std::allocator<int>>.
comment|///
comment|/// Other template specialization types, for which the template name
comment|/// is dependent, may be canonical types. These types are always
comment|/// dependent.
name|class
name|TemplateSpecializationType
operator|:
name|public
name|Type
block|,
name|public
name|llvm
operator|::
name|FoldingSetNode
block|{
comment|// FIXME: Currently needed for profiling expressions; can we avoid this?
name|ASTContext
operator|&
name|Context
block|;
comment|/// \brief The name of the template being specialized.
name|TemplateName
name|Template
block|;
comment|/// \brief - The number of template arguments named in this class
comment|/// template specialization.
name|unsigned
name|NumArgs
block|;
name|TemplateSpecializationType
argument_list|(
argument|ASTContext&Context
argument_list|,
argument|TemplateName T
argument_list|,
argument|const TemplateArgument *Args
argument_list|,
argument|unsigned NumArgs
argument_list|,
argument|QualType Canon
argument_list|)
block|;
name|virtual
name|void
name|Destroy
argument_list|(
name|ASTContext
operator|&
name|C
argument_list|)
block|;
name|friend
name|class
name|ASTContext
block|;
comment|// ASTContext creates these
name|public
operator|:
comment|/// \brief Determine whether any of the given template arguments are
comment|/// dependent.
specifier|static
name|bool
name|anyDependentTemplateArguments
argument_list|(
argument|const TemplateArgument *Args
argument_list|,
argument|unsigned NumArgs
argument_list|)
block|;
comment|/// \brief Print a template argument list, including the '<' and '>'
comment|/// enclosing the template arguments.
specifier|static
name|std
operator|::
name|string
name|PrintTemplateArgumentList
argument_list|(
argument|const TemplateArgument *Args
argument_list|,
argument|unsigned NumArgs
argument_list|,
argument|const PrintingPolicy&Policy
argument_list|)
block|;
typedef|typedef
specifier|const
name|TemplateArgument
modifier|*
name|iterator
typedef|;
name|iterator
name|begin
argument_list|()
specifier|const
block|{
return|return
name|getArgs
argument_list|()
return|;
block|}
name|iterator
name|end
argument_list|()
specifier|const
block|;
comment|/// \brief Retrieve the name of the template that we are specializing.
name|TemplateName
name|getTemplateName
argument_list|()
specifier|const
block|{
return|return
name|Template
return|;
block|}
comment|/// \brief Retrieve the template arguments.
specifier|const
name|TemplateArgument
operator|*
name|getArgs
argument_list|()
specifier|const
block|{
return|return
name|reinterpret_cast
operator|<
specifier|const
name|TemplateArgument
operator|*
operator|>
operator|(
name|this
operator|+
literal|1
operator|)
return|;
block|}
comment|/// \brief Retrieve the number of template arguments.
name|unsigned
name|getNumArgs
argument_list|()
specifier|const
block|{
return|return
name|NumArgs
return|;
block|}
comment|/// \brief Retrieve a specific template argument as a type.
comment|/// \precondition @c isArgType(Arg)
specifier|const
name|TemplateArgument
operator|&
name|getArg
argument_list|(
argument|unsigned Idx
argument_list|)
specifier|const
block|;
name|virtual
name|void
name|getAsStringInternal
argument_list|(
argument|std::string&InnerString
argument_list|,
argument|const PrintingPolicy&Policy
argument_list|)
specifier|const
block|;
name|bool
name|isSugared
argument_list|()
specifier|const
block|{
return|return
operator|!
name|isDependentType
argument_list|()
return|;
block|}
name|QualType
name|desugar
argument_list|()
specifier|const
block|{
return|return
name|getCanonicalTypeInternal
argument_list|()
return|;
block|}
name|void
name|Profile
argument_list|(
argument|llvm::FoldingSetNodeID&ID
argument_list|)
block|{
name|Profile
argument_list|(
name|ID
argument_list|,
name|Template
argument_list|,
name|getArgs
argument_list|()
argument_list|,
name|NumArgs
argument_list|,
name|Context
argument_list|)
block|;   }
specifier|static
name|void
name|Profile
argument_list|(
argument|llvm::FoldingSetNodeID&ID
argument_list|,
argument|TemplateName T
argument_list|,
argument|const TemplateArgument *Args
argument_list|,
argument|unsigned NumArgs
argument_list|,
argument|ASTContext&Context
argument_list|)
block|;
specifier|static
name|bool
name|classof
argument_list|(
argument|const Type *T
argument_list|)
block|{
return|return
name|T
operator|->
name|getTypeClass
argument_list|()
operator|==
name|TemplateSpecialization
return|;
block|}
specifier|static
name|bool
name|classof
argument_list|(
argument|const TemplateSpecializationType *T
argument_list|)
block|{
return|return
name|true
return|;
block|}
expr|}
block|;
comment|/// \brief Represents a type that was referred to via a qualified
comment|/// name, e.g., N::M::type.
comment|///
comment|/// This type is used to keep track of a type name as written in the
comment|/// source code, including any nested-name-specifiers. The type itself
comment|/// is always "sugar", used to express what was written in the source
comment|/// code but containing no additional semantic information.
name|class
name|QualifiedNameType
operator|:
name|public
name|Type
block|,
name|public
name|llvm
operator|::
name|FoldingSetNode
block|{
comment|/// \brief The nested name specifier containing the qualifier.
name|NestedNameSpecifier
operator|*
name|NNS
block|;
comment|/// \brief The type that this qualified name refers to.
name|QualType
name|NamedType
block|;
name|QualifiedNameType
argument_list|(
argument|NestedNameSpecifier *NNS
argument_list|,
argument|QualType NamedType
argument_list|,
argument|QualType CanonType
argument_list|)
operator|:
name|Type
argument_list|(
name|QualifiedName
argument_list|,
name|CanonType
argument_list|,
name|NamedType
operator|->
name|isDependentType
argument_list|()
argument_list|)
block|,
name|NNS
argument_list|(
name|NNS
argument_list|)
block|,
name|NamedType
argument_list|(
argument|NamedType
argument_list|)
block|{ }
name|friend
name|class
name|ASTContext
block|;
comment|// ASTContext creates these
name|public
operator|:
comment|/// \brief Retrieve the qualification on this type.
name|NestedNameSpecifier
operator|*
name|getQualifier
argument_list|()
specifier|const
block|{
return|return
name|NNS
return|;
block|}
comment|/// \brief Retrieve the type named by the qualified-id.
name|QualType
name|getNamedType
argument_list|()
specifier|const
block|{
return|return
name|NamedType
return|;
block|}
comment|/// \brief Remove a single level of sugar.
name|QualType
name|desugar
argument_list|()
specifier|const
block|{
return|return
name|getNamedType
argument_list|()
return|;
block|}
comment|/// \brief Returns whether this type directly provides sugar.
name|bool
name|isSugared
argument_list|()
specifier|const
block|{
return|return
name|true
return|;
block|}
name|virtual
name|void
name|getAsStringInternal
argument_list|(
argument|std::string&InnerString
argument_list|,
argument|const PrintingPolicy&Policy
argument_list|)
specifier|const
block|;
name|void
name|Profile
argument_list|(
argument|llvm::FoldingSetNodeID&ID
argument_list|)
block|{
name|Profile
argument_list|(
name|ID
argument_list|,
name|NNS
argument_list|,
name|NamedType
argument_list|)
block|;   }
specifier|static
name|void
name|Profile
argument_list|(
argument|llvm::FoldingSetNodeID&ID
argument_list|,
argument|NestedNameSpecifier *NNS
argument_list|,
argument|QualType NamedType
argument_list|)
block|{
name|ID
operator|.
name|AddPointer
argument_list|(
name|NNS
argument_list|)
block|;
name|NamedType
operator|.
name|Profile
argument_list|(
name|ID
argument_list|)
block|;   }
specifier|static
name|bool
name|classof
argument_list|(
argument|const Type *T
argument_list|)
block|{
return|return
name|T
operator|->
name|getTypeClass
argument_list|()
operator|==
name|QualifiedName
return|;
block|}
specifier|static
name|bool
name|classof
argument_list|(
argument|const QualifiedNameType *T
argument_list|)
block|{
return|return
name|true
return|;
block|}
expr|}
block|;
comment|/// \brief Represents a 'typename' specifier that names a type within
comment|/// a dependent type, e.g., "typename T::type".
comment|///
comment|/// TypenameType has a very similar structure to QualifiedNameType,
comment|/// which also involves a nested-name-specifier following by a type,
comment|/// and (FIXME!) both can even be prefixed by the 'typename'
comment|/// keyword. However, the two types serve very different roles:
comment|/// QualifiedNameType is a non-semantic type that serves only as sugar
comment|/// to show how a particular type was written in the source
comment|/// code. TypenameType, on the other hand, only occurs when the
comment|/// nested-name-specifier is dependent, such that we cannot resolve
comment|/// the actual type until after instantiation.
name|class
name|TypenameType
operator|:
name|public
name|Type
block|,
name|public
name|llvm
operator|::
name|FoldingSetNode
block|{
comment|/// \brief The nested name specifier containing the qualifier.
name|NestedNameSpecifier
operator|*
name|NNS
block|;
typedef|typedef
name|llvm
operator|::
name|PointerUnion
operator|<
specifier|const
name|IdentifierInfo
operator|*
operator|,
specifier|const
name|TemplateSpecializationType
operator|*
operator|>
name|NameType
expr_stmt|;
comment|/// \brief The type that this typename specifier refers to.
name|NameType
name|Name
block|;
name|TypenameType
argument_list|(
argument|NestedNameSpecifier *NNS
argument_list|,
argument|const IdentifierInfo *Name
argument_list|,
argument|QualType CanonType
argument_list|)
operator|:
name|Type
argument_list|(
name|Typename
argument_list|,
name|CanonType
argument_list|,
name|true
argument_list|)
block|,
name|NNS
argument_list|(
name|NNS
argument_list|)
block|,
name|Name
argument_list|(
argument|Name
argument_list|)
block|{
name|assert
argument_list|(
name|NNS
operator|->
name|isDependent
argument_list|()
operator|&&
literal|"TypenameType requires a dependent nested-name-specifier"
argument_list|)
block|;   }
name|TypenameType
argument_list|(
argument|NestedNameSpecifier *NNS
argument_list|,
argument|const TemplateSpecializationType *Ty
argument_list|,
argument|QualType CanonType
argument_list|)
operator|:
name|Type
argument_list|(
name|Typename
argument_list|,
name|CanonType
argument_list|,
name|true
argument_list|)
block|,
name|NNS
argument_list|(
name|NNS
argument_list|)
block|,
name|Name
argument_list|(
argument|Ty
argument_list|)
block|{
name|assert
argument_list|(
name|NNS
operator|->
name|isDependent
argument_list|()
operator|&&
literal|"TypenameType requires a dependent nested-name-specifier"
argument_list|)
block|;   }
name|friend
name|class
name|ASTContext
block|;
comment|// ASTContext creates these
name|public
operator|:
comment|/// \brief Retrieve the qualification on this type.
name|NestedNameSpecifier
operator|*
name|getQualifier
argument_list|()
specifier|const
block|{
return|return
name|NNS
return|;
block|}
comment|/// \brief Retrieve the type named by the typename specifier as an
comment|/// identifier.
comment|///
comment|/// This routine will return a non-NULL identifier pointer when the
comment|/// form of the original typename was terminated by an identifier,
comment|/// e.g., "typename T::type".
specifier|const
name|IdentifierInfo
operator|*
name|getIdentifier
argument_list|()
specifier|const
block|{
return|return
name|Name
operator|.
name|dyn_cast
operator|<
specifier|const
name|IdentifierInfo
operator|*
operator|>
operator|(
operator|)
return|;
block|}
comment|/// \brief Retrieve the type named by the typename specifier as a
comment|/// type specialization.
specifier|const
name|TemplateSpecializationType
operator|*
name|getTemplateId
argument_list|()
specifier|const
block|{
return|return
name|Name
operator|.
name|dyn_cast
operator|<
specifier|const
name|TemplateSpecializationType
operator|*
operator|>
operator|(
operator|)
return|;
block|}
name|virtual
name|void
name|getAsStringInternal
argument_list|(
argument|std::string&InnerString
argument_list|,
argument|const PrintingPolicy&Policy
argument_list|)
specifier|const
block|;
name|bool
name|isSugared
argument_list|()
specifier|const
block|{
return|return
name|false
return|;
block|}
name|QualType
name|desugar
argument_list|()
specifier|const
block|{
return|return
name|QualType
argument_list|(
name|this
argument_list|,
literal|0
argument_list|)
return|;
block|}
name|void
name|Profile
argument_list|(
argument|llvm::FoldingSetNodeID&ID
argument_list|)
block|{
name|Profile
argument_list|(
name|ID
argument_list|,
name|NNS
argument_list|,
name|Name
argument_list|)
block|;   }
specifier|static
name|void
name|Profile
argument_list|(
argument|llvm::FoldingSetNodeID&ID
argument_list|,
argument|NestedNameSpecifier *NNS
argument_list|,
argument|NameType Name
argument_list|)
block|{
name|ID
operator|.
name|AddPointer
argument_list|(
name|NNS
argument_list|)
block|;
name|ID
operator|.
name|AddPointer
argument_list|(
name|Name
operator|.
name|getOpaqueValue
argument_list|()
argument_list|)
block|;   }
specifier|static
name|bool
name|classof
argument_list|(
argument|const Type *T
argument_list|)
block|{
return|return
name|T
operator|->
name|getTypeClass
argument_list|()
operator|==
name|Typename
return|;
block|}
specifier|static
name|bool
name|classof
argument_list|(
argument|const TypenameType *T
argument_list|)
block|{
return|return
name|true
return|;
block|}
expr|}
block|;
comment|/// ObjCInterfaceType - Interfaces are the core concept in Objective-C for
comment|/// object oriented design.  They basically correspond to C++ classes.  There
comment|/// are two kinds of interface types, normal interfaces like "NSString" and
comment|/// qualified interfaces, which are qualified with a protocol list like
comment|/// "NSString<NSCopyable, NSAmazing>".
name|class
name|ObjCInterfaceType
operator|:
name|public
name|Type
block|,
name|public
name|llvm
operator|::
name|FoldingSetNode
block|{
name|ObjCInterfaceDecl
operator|*
name|Decl
block|;
comment|// List of protocols for this protocol conforming object type
comment|// List is sorted on protocol name. No protocol is enterred more than once.
name|llvm
operator|::
name|SmallVector
operator|<
name|ObjCProtocolDecl
operator|*
block|,
literal|4
operator|>
name|Protocols
block|;
name|ObjCInterfaceType
argument_list|(
argument|ObjCInterfaceDecl *D
argument_list|,
argument|ObjCProtocolDecl **Protos
argument_list|,
argument|unsigned NumP
argument_list|)
operator|:
name|Type
argument_list|(
name|ObjCInterface
argument_list|,
name|QualType
argument_list|()
argument_list|,
comment|/*Dependent=*/
name|false
argument_list|)
block|,
name|Decl
argument_list|(
name|D
argument_list|)
block|,
name|Protocols
argument_list|(
argument|Protos
argument_list|,
argument|Protos+NumP
argument_list|)
block|{ }
name|friend
name|class
name|ASTContext
block|;
comment|// ASTContext creates these.
name|public
operator|:
name|ObjCInterfaceDecl
operator|*
name|getDecl
argument_list|()
specifier|const
block|{
return|return
name|Decl
return|;
block|}
comment|/// getNumProtocols - Return the number of qualifying protocols in this
comment|/// interface type, or 0 if there are none.
name|unsigned
name|getNumProtocols
argument_list|()
specifier|const
block|{
return|return
name|Protocols
operator|.
name|size
argument_list|()
return|;
block|}
comment|/// qual_iterator and friends: this provides access to the (potentially empty)
comment|/// list of protocols qualifying this interface.
typedef|typedef
name|llvm
operator|::
name|SmallVector
operator|<
name|ObjCProtocolDecl
operator|*
operator|,
literal|8
operator|>
operator|::
name|const_iterator
name|qual_iterator
expr_stmt|;
name|qual_iterator
name|qual_begin
argument_list|()
specifier|const
block|{
return|return
name|Protocols
operator|.
name|begin
argument_list|()
return|;
block|}
name|qual_iterator
name|qual_end
argument_list|()
specifier|const
block|{
return|return
name|Protocols
operator|.
name|end
argument_list|()
return|;
block|}
name|bool
name|qual_empty
argument_list|()
specifier|const
block|{
return|return
name|Protocols
operator|.
name|size
argument_list|()
operator|==
literal|0
return|;
block|}
name|virtual
name|void
name|getAsStringInternal
argument_list|(
argument|std::string&InnerString
argument_list|,
argument|const PrintingPolicy&Policy
argument_list|)
specifier|const
block|;
name|bool
name|isSugared
argument_list|()
specifier|const
block|{
return|return
name|false
return|;
block|}
name|QualType
name|desugar
argument_list|()
specifier|const
block|{
return|return
name|QualType
argument_list|(
name|this
argument_list|,
literal|0
argument_list|)
return|;
block|}
name|void
name|Profile
argument_list|(
name|llvm
operator|::
name|FoldingSetNodeID
operator|&
name|ID
argument_list|)
block|;
specifier|static
name|void
name|Profile
argument_list|(
argument|llvm::FoldingSetNodeID&ID
argument_list|,
argument|const ObjCInterfaceDecl *Decl
argument_list|,
argument|ObjCProtocolDecl **protocols
argument_list|,
argument|unsigned NumProtocols
argument_list|)
block|;
specifier|static
name|bool
name|classof
argument_list|(
argument|const Type *T
argument_list|)
block|{
return|return
name|T
operator|->
name|getTypeClass
argument_list|()
operator|==
name|ObjCInterface
return|;
block|}
specifier|static
name|bool
name|classof
argument_list|(
argument|const ObjCInterfaceType *
argument_list|)
block|{
return|return
name|true
return|;
block|}
expr|}
block|;
comment|/// ObjCObjectPointerType - Used to represent 'id', 'Interface *', 'id<p>',
comment|/// and 'Interface<p> *'.
comment|///
comment|/// Duplicate protocols are removed and protocol list is canonicalized to be in
comment|/// alphabetical order.
name|class
name|ObjCObjectPointerType
operator|:
name|public
name|Type
block|,
name|public
name|llvm
operator|::
name|FoldingSetNode
block|{
name|QualType
name|PointeeType
block|;
comment|// A builtin or interface type.
comment|// List of protocols for this protocol conforming object type
comment|// List is sorted on protocol name. No protocol is entered more than once.
name|llvm
operator|::
name|SmallVector
operator|<
name|ObjCProtocolDecl
operator|*
block|,
literal|8
operator|>
name|Protocols
block|;
name|ObjCObjectPointerType
argument_list|(
argument|QualType T
argument_list|,
argument|ObjCProtocolDecl **Protos
argument_list|,
argument|unsigned NumP
argument_list|)
operator|:
name|Type
argument_list|(
name|ObjCObjectPointer
argument_list|,
name|QualType
argument_list|()
argument_list|,
comment|/*Dependent=*/
name|false
argument_list|)
block|,
name|PointeeType
argument_list|(
name|T
argument_list|)
block|,
name|Protocols
argument_list|(
argument|Protos
argument_list|,
argument|Protos+NumP
argument_list|)
block|{ }
name|friend
name|class
name|ASTContext
block|;
comment|// ASTContext creates these.
name|public
operator|:
comment|// Get the pointee type. Pointee will either be:
comment|// - a built-in type (for 'id' and 'Class').
comment|// - an interface type (for user-defined types).
comment|// - a TypedefType whose canonical type is an interface (as in 'T' below).
comment|//   For example: typedef NSObject T; T *var;
name|QualType
name|getPointeeType
argument_list|()
specifier|const
block|{
return|return
name|PointeeType
return|;
block|}
specifier|const
name|ObjCInterfaceType
operator|*
name|getInterfaceType
argument_list|()
specifier|const
block|{
return|return
name|PointeeType
operator|->
name|getAs
operator|<
name|ObjCInterfaceType
operator|>
operator|(
operator|)
return|;
block|}
comment|/// getInterfaceDecl - returns an interface decl for user-defined types.
name|ObjCInterfaceDecl
operator|*
name|getInterfaceDecl
argument_list|()
specifier|const
block|{
return|return
name|getInterfaceType
argument_list|()
operator|?
name|getInterfaceType
argument_list|()
operator|->
name|getDecl
argument_list|()
operator|:
literal|0
return|;
block|}
comment|/// isObjCIdType - true for "id".
name|bool
name|isObjCIdType
argument_list|()
specifier|const
block|{
return|return
name|getPointeeType
argument_list|()
operator|->
name|isSpecificBuiltinType
argument_list|(
name|BuiltinType
operator|::
name|ObjCId
argument_list|)
operator|&&
operator|!
name|Protocols
operator|.
name|size
argument_list|()
return|;
block|}
comment|/// isObjCClassType - true for "Class".
name|bool
name|isObjCClassType
argument_list|()
specifier|const
block|{
return|return
name|getPointeeType
argument_list|()
operator|->
name|isSpecificBuiltinType
argument_list|(
name|BuiltinType
operator|::
name|ObjCClass
argument_list|)
operator|&&
operator|!
name|Protocols
operator|.
name|size
argument_list|()
return|;
block|}
comment|/// isObjCQualifiedIdType - true for "id<p>".
name|bool
name|isObjCQualifiedIdType
argument_list|()
specifier|const
block|{
return|return
name|getPointeeType
argument_list|()
operator|->
name|isSpecificBuiltinType
argument_list|(
name|BuiltinType
operator|::
name|ObjCId
argument_list|)
operator|&&
name|Protocols
operator|.
name|size
argument_list|()
return|;
block|}
comment|/// isObjCQualifiedClassType - true for "Class<p>".
name|bool
name|isObjCQualifiedClassType
argument_list|()
specifier|const
block|{
return|return
name|getPointeeType
argument_list|()
operator|->
name|isSpecificBuiltinType
argument_list|(
name|BuiltinType
operator|::
name|ObjCClass
argument_list|)
operator|&&
name|Protocols
operator|.
name|size
argument_list|()
return|;
block|}
comment|/// qual_iterator and friends: this provides access to the (potentially empty)
comment|/// list of protocols qualifying this interface.
typedef|typedef
name|llvm
operator|::
name|SmallVector
operator|<
name|ObjCProtocolDecl
operator|*
operator|,
literal|8
operator|>
operator|::
name|const_iterator
name|qual_iterator
expr_stmt|;
name|qual_iterator
name|qual_begin
argument_list|()
specifier|const
block|{
return|return
name|Protocols
operator|.
name|begin
argument_list|()
return|;
block|}
name|qual_iterator
name|qual_end
argument_list|()
specifier|const
block|{
return|return
name|Protocols
operator|.
name|end
argument_list|()
return|;
block|}
name|bool
name|qual_empty
argument_list|()
specifier|const
block|{
return|return
name|Protocols
operator|.
name|size
argument_list|()
operator|==
literal|0
return|;
block|}
comment|/// getNumProtocols - Return the number of qualifying protocols in this
comment|/// interface type, or 0 if there are none.
name|unsigned
name|getNumProtocols
argument_list|()
specifier|const
block|{
return|return
name|Protocols
operator|.
name|size
argument_list|()
return|;
block|}
name|bool
name|isSugared
argument_list|()
specifier|const
block|{
return|return
name|false
return|;
block|}
name|QualType
name|desugar
argument_list|()
specifier|const
block|{
return|return
name|QualType
argument_list|(
name|this
argument_list|,
literal|0
argument_list|)
return|;
block|}
name|void
name|Profile
argument_list|(
name|llvm
operator|::
name|FoldingSetNodeID
operator|&
name|ID
argument_list|)
block|;
specifier|static
name|void
name|Profile
argument_list|(
argument|llvm::FoldingSetNodeID&ID
argument_list|,
argument|QualType T
argument_list|,
argument|ObjCProtocolDecl **protocols
argument_list|,
argument|unsigned NumProtocols
argument_list|)
block|;
name|virtual
name|void
name|getAsStringInternal
argument_list|(
argument|std::string&InnerString
argument_list|,
argument|const PrintingPolicy&Policy
argument_list|)
specifier|const
block|;
specifier|static
name|bool
name|classof
argument_list|(
argument|const Type *T
argument_list|)
block|{
return|return
name|T
operator|->
name|getTypeClass
argument_list|()
operator|==
name|ObjCObjectPointer
return|;
block|}
specifier|static
name|bool
name|classof
argument_list|(
argument|const ObjCObjectPointerType *
argument_list|)
block|{
return|return
name|true
return|;
block|}
expr|}
block|;
comment|/// \brief An ObjC Protocol list that qualifies a type.
comment|///
comment|/// This is used only for keeping detailed type source information, it should
comment|/// not participate in the semantics of the type system.
comment|/// The protocol list is not canonicalized.
name|class
name|ObjCProtocolListType
operator|:
name|public
name|Type
block|,
name|public
name|llvm
operator|::
name|FoldingSetNode
block|{
name|QualType
name|BaseType
block|;
comment|// List of protocols for this protocol conforming object type.
name|llvm
operator|::
name|SmallVector
operator|<
name|ObjCProtocolDecl
operator|*
block|,
literal|4
operator|>
name|Protocols
block|;
name|ObjCProtocolListType
argument_list|(
argument|QualType T
argument_list|,
argument|ObjCProtocolDecl **Protos
argument_list|,
argument|unsigned NumP
argument_list|)
operator|:
name|Type
argument_list|(
name|ObjCProtocolList
argument_list|,
name|QualType
argument_list|()
argument_list|,
comment|/*Dependent=*/
name|false
argument_list|)
block|,
name|BaseType
argument_list|(
name|T
argument_list|)
block|,
name|Protocols
argument_list|(
argument|Protos
argument_list|,
argument|Protos+NumP
argument_list|)
block|{ }
name|friend
name|class
name|ASTContext
block|;
comment|// ASTContext creates these.
name|public
operator|:
name|QualType
name|getBaseType
argument_list|()
specifier|const
block|{
return|return
name|BaseType
return|;
block|}
comment|/// \brief Provides access to the list of protocols qualifying the base type.
typedef|typedef
name|llvm
operator|::
name|SmallVector
operator|<
name|ObjCProtocolDecl
operator|*
operator|,
literal|4
operator|>
operator|::
name|const_iterator
name|qual_iterator
expr_stmt|;
name|qual_iterator
name|qual_begin
argument_list|()
specifier|const
block|{
return|return
name|Protocols
operator|.
name|begin
argument_list|()
return|;
block|}
name|qual_iterator
name|qual_end
argument_list|()
specifier|const
block|{
return|return
name|Protocols
operator|.
name|end
argument_list|()
return|;
block|}
name|bool
name|qual_empty
argument_list|()
specifier|const
block|{
return|return
name|Protocols
operator|.
name|size
argument_list|()
operator|==
literal|0
return|;
block|}
comment|/// \brief Return the number of qualifying protocols.
name|unsigned
name|getNumProtocols
argument_list|()
specifier|const
block|{
return|return
name|Protocols
operator|.
name|size
argument_list|()
return|;
block|}
name|bool
name|isSugared
argument_list|()
specifier|const
block|{
return|return
name|false
return|;
block|}
name|QualType
name|desugar
argument_list|()
specifier|const
block|{
return|return
name|QualType
argument_list|(
name|this
argument_list|,
literal|0
argument_list|)
return|;
block|}
name|void
name|Profile
argument_list|(
name|llvm
operator|::
name|FoldingSetNodeID
operator|&
name|ID
argument_list|)
block|;
specifier|static
name|void
name|Profile
argument_list|(
argument|llvm::FoldingSetNodeID&ID
argument_list|,
argument|QualType T
argument_list|,
argument|ObjCProtocolDecl **protocols
argument_list|,
argument|unsigned NumProtocols
argument_list|)
block|;
name|virtual
name|void
name|getAsStringInternal
argument_list|(
argument|std::string&InnerString
argument_list|,
argument|const PrintingPolicy&Policy
argument_list|)
specifier|const
block|;
specifier|static
name|bool
name|classof
argument_list|(
argument|const Type *T
argument_list|)
block|{
return|return
name|T
operator|->
name|getTypeClass
argument_list|()
operator|==
name|ObjCProtocolList
return|;
block|}
specifier|static
name|bool
name|classof
argument_list|(
argument|const ObjCProtocolListType *
argument_list|)
block|{
return|return
name|true
return|;
block|}
expr|}
block|;
comment|/// A qualifier set is used to build a set of qualifiers.
name|class
name|QualifierCollector
operator|:
name|public
name|Qualifiers
block|{
name|ASTContext
operator|*
name|Context
block|;
name|public
operator|:
name|QualifierCollector
argument_list|(
argument|Qualifiers Qs = Qualifiers()
argument_list|)
operator|:
name|Qualifiers
argument_list|(
name|Qs
argument_list|)
block|,
name|Context
argument_list|(
literal|0
argument_list|)
block|{}
name|QualifierCollector
argument_list|(
argument|ASTContext&Context
argument_list|,
argument|Qualifiers Qs = Qualifiers()
argument_list|)
operator|:
name|Qualifiers
argument_list|(
name|Qs
argument_list|)
block|,
name|Context
argument_list|(
argument|&Context
argument_list|)
block|{}
name|void
name|setContext
argument_list|(
argument|ASTContext&C
argument_list|)
block|{
name|Context
operator|=
operator|&
name|C
block|; }
comment|/// Collect any qualifiers on the given type and return an
comment|/// unqualified type.
specifier|const
name|Type
operator|*
name|strip
argument_list|(
argument|QualType QT
argument_list|)
block|{
name|addFastQualifiers
argument_list|(
name|QT
operator|.
name|getFastQualifiers
argument_list|()
argument_list|)
block|;
if|if
condition|(
name|QT
operator|.
name|hasNonFastQualifiers
argument_list|()
condition|)
block|{
specifier|const
name|ExtQuals
modifier|*
name|EQ
init|=
name|QT
operator|.
name|getExtQualsUnsafe
argument_list|()
decl_stmt|;
name|Context
operator|=
operator|&
name|EQ
operator|->
name|getContext
argument_list|()
expr_stmt|;
name|addQualifiers
argument_list|(
name|EQ
operator|->
name|getQualifiers
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|EQ
operator|->
name|getBaseType
argument_list|()
return|;
block|}
return|return
name|QT
operator|.
name|getTypePtrUnsafe
argument_list|()
return|;
block|}
comment|/// Apply the collected qualifiers to the given type.
name|QualType
name|apply
argument_list|(
argument|QualType QT
argument_list|)
specifier|const
block|;
comment|/// Apply the collected qualifiers to the given type.
name|QualType
name|apply
argument_list|(
argument|const Type* T
argument_list|)
specifier|const
block|;  }
block|;
comment|// Inline function definitions.
specifier|inline
name|void
name|QualType
operator|::
name|removeConst
argument_list|()
block|{
name|removeFastQualifiers
argument_list|(
name|Qualifiers
operator|::
name|Const
argument_list|)
block|; }
specifier|inline
name|void
name|QualType
operator|::
name|removeRestrict
argument_list|()
block|{
name|removeFastQualifiers
argument_list|(
name|Qualifiers
operator|::
name|Restrict
argument_list|)
block|; }
specifier|inline
name|void
name|QualType
operator|::
name|removeVolatile
argument_list|()
block|{
name|QualifierCollector
name|Qc
block|;
specifier|const
name|Type
operator|*
name|Ty
operator|=
name|Qc
operator|.
name|strip
argument_list|(
operator|*
name|this
argument_list|)
block|;
if|if
condition|(
name|Qc
operator|.
name|hasVolatile
argument_list|()
condition|)
block|{
name|Qc
operator|.
name|removeVolatile
argument_list|()
expr_stmt|;
operator|*
name|this
operator|=
name|Qc
operator|.
name|apply
argument_list|(
name|Ty
argument_list|)
expr_stmt|;
block|}
block|}
specifier|inline
name|void
name|QualType
operator|::
name|removeCVRQualifiers
argument_list|(
argument|unsigned Mask
argument_list|)
block|{
name|assert
argument_list|(
operator|!
operator|(
name|Mask
operator|&
operator|~
name|Qualifiers
operator|::
name|CVRMask
operator|)
operator|&&
literal|"mask has non-CVR bits"
argument_list|)
block|;
comment|// Fast path: we don't need to touch the slow qualifiers.
if|if
condition|(
operator|!
operator|(
name|Mask
operator|&
operator|~
name|Qualifiers
operator|::
name|FastMask
operator|)
condition|)
block|{
name|removeFastQualifiers
argument_list|(
name|Mask
argument_list|)
expr_stmt|;
return|return;
block|}
name|QualifierCollector
name|Qc
decl_stmt|;
specifier|const
name|Type
operator|*
name|Ty
operator|=
name|Qc
operator|.
name|strip
argument_list|(
operator|*
name|this
argument_list|)
block|;
name|Qc
operator|.
name|removeCVRQualifiers
argument_list|(
name|Mask
argument_list|)
block|;
operator|*
name|this
operator|=
name|Qc
operator|.
name|apply
argument_list|(
name|Ty
argument_list|)
block|; }
comment|/// getAddressSpace - Return the address space of this type.
specifier|inline
name|unsigned
name|QualType
operator|::
name|getAddressSpace
argument_list|()
specifier|const
block|{
if|if
condition|(
name|hasNonFastQualifiers
argument_list|()
condition|)
block|{
specifier|const
name|ExtQuals
modifier|*
name|EQ
init|=
name|getExtQualsUnsafe
argument_list|()
decl_stmt|;
if|if
condition|(
name|EQ
operator|->
name|hasAddressSpace
argument_list|()
condition|)
return|return
name|EQ
operator|->
name|getAddressSpace
argument_list|()
return|;
block|}
name|QualType
name|CT
init|=
name|getTypePtr
argument_list|()
operator|->
name|getCanonicalTypeInternal
argument_list|()
decl_stmt|;
if|if
condition|(
name|CT
operator|.
name|hasNonFastQualifiers
argument_list|()
condition|)
block|{
specifier|const
name|ExtQuals
modifier|*
name|EQ
init|=
name|CT
operator|.
name|getExtQualsUnsafe
argument_list|()
decl_stmt|;
if|if
condition|(
name|EQ
operator|->
name|hasAddressSpace
argument_list|()
condition|)
return|return
name|EQ
operator|->
name|getAddressSpace
argument_list|()
return|;
block|}
if|if
condition|(
specifier|const
name|ArrayType
modifier|*
name|AT
init|=
name|dyn_cast
operator|<
name|ArrayType
operator|>
operator|(
name|CT
operator|)
condition|)
return|return
name|AT
operator|->
name|getElementType
argument_list|()
operator|.
name|getAddressSpace
argument_list|()
return|;
if|if
condition|(
specifier|const
name|RecordType
modifier|*
name|RT
init|=
name|dyn_cast
operator|<
name|RecordType
operator|>
operator|(
name|CT
operator|)
condition|)
return|return
name|RT
operator|->
name|getAddressSpace
argument_list|()
return|;
return|return
literal|0
return|;
block|}
comment|/// getObjCGCAttr - Return the gc attribute of this type.
specifier|inline
name|Qualifiers
operator|::
name|GC
name|QualType
operator|::
name|getObjCGCAttr
argument_list|()
specifier|const
block|{
if|if
condition|(
name|hasNonFastQualifiers
argument_list|()
condition|)
block|{
specifier|const
name|ExtQuals
modifier|*
name|EQ
init|=
name|getExtQualsUnsafe
argument_list|()
decl_stmt|;
if|if
condition|(
name|EQ
operator|->
name|hasObjCGCAttr
argument_list|()
condition|)
return|return
name|EQ
operator|->
name|getObjCGCAttr
argument_list|()
return|;
block|}
name|QualType
name|CT
init|=
name|getTypePtr
argument_list|()
operator|->
name|getCanonicalTypeInternal
argument_list|()
decl_stmt|;
if|if
condition|(
name|CT
operator|.
name|hasNonFastQualifiers
argument_list|()
condition|)
block|{
specifier|const
name|ExtQuals
modifier|*
name|EQ
init|=
name|CT
operator|.
name|getExtQualsUnsafe
argument_list|()
decl_stmt|;
if|if
condition|(
name|EQ
operator|->
name|hasObjCGCAttr
argument_list|()
condition|)
return|return
name|EQ
operator|->
name|getObjCGCAttr
argument_list|()
return|;
block|}
if|if
condition|(
specifier|const
name|ArrayType
modifier|*
name|AT
init|=
name|dyn_cast
operator|<
name|ArrayType
operator|>
operator|(
name|CT
operator|)
condition|)
return|return
name|AT
operator|->
name|getElementType
argument_list|()
operator|.
name|getObjCGCAttr
argument_list|()
return|;
if|if
condition|(
specifier|const
name|ObjCObjectPointerType
modifier|*
name|PT
init|=
name|CT
operator|->
name|getAs
operator|<
name|ObjCObjectPointerType
operator|>
operator|(
operator|)
condition|)
return|return
name|PT
operator|->
name|getPointeeType
argument_list|()
operator|.
name|getObjCGCAttr
argument_list|()
return|;
comment|// We most look at all pointer types, not just pointer to interface types.
if|if
condition|(
specifier|const
name|PointerType
modifier|*
name|PT
init|=
name|CT
operator|->
name|getAs
operator|<
name|PointerType
operator|>
operator|(
operator|)
condition|)
return|return
name|PT
operator|->
name|getPointeeType
argument_list|()
operator|.
name|getObjCGCAttr
argument_list|()
return|;
return|return
name|Qualifiers
operator|::
name|GCNone
return|;
block|}
comment|/// getNoReturnAttr - Returns true if the type has the noreturn attribute,
comment|/// false otherwise.
specifier|inline
name|bool
name|QualType
operator|::
name|getNoReturnAttr
argument_list|()
specifier|const
block|{
name|QualType
name|CT
operator|=
name|getTypePtr
argument_list|()
operator|->
name|getCanonicalTypeInternal
argument_list|()
block|;
if|if
condition|(
specifier|const
name|PointerType
modifier|*
name|PT
init|=
name|getTypePtr
argument_list|()
operator|->
name|getAs
operator|<
name|PointerType
operator|>
operator|(
operator|)
condition|)
block|{
if|if
condition|(
specifier|const
name|FunctionType
modifier|*
name|FT
init|=
name|PT
operator|->
name|getPointeeType
argument_list|()
operator|->
name|getAs
operator|<
name|FunctionType
operator|>
operator|(
operator|)
condition|)
return|return
name|FT
operator|->
name|getNoReturnAttr
argument_list|()
return|;
block|}
elseif|else
if|if
condition|(
specifier|const
name|FunctionType
modifier|*
name|FT
init|=
name|getTypePtr
argument_list|()
operator|->
name|getAs
operator|<
name|FunctionType
operator|>
operator|(
operator|)
condition|)
return|return
name|FT
operator|->
name|getNoReturnAttr
argument_list|()
return|;
return|return
name|false
return|;
block|}
comment|/// isMoreQualifiedThan - Determine whether this type is more
comment|/// qualified than the Other type. For example, "const volatile int"
comment|/// is more qualified than "const int", "volatile int", and
comment|/// "int". However, it is not more qualified than "const volatile
comment|/// int".
specifier|inline
name|bool
name|QualType
operator|::
name|isMoreQualifiedThan
argument_list|(
argument|QualType Other
argument_list|)
specifier|const
block|{
comment|// FIXME: work on arbitrary qualifiers
name|unsigned
name|MyQuals
operator|=
name|this
operator|->
name|getCVRQualifiers
argument_list|()
block|;
name|unsigned
name|OtherQuals
operator|=
name|Other
operator|.
name|getCVRQualifiers
argument_list|()
block|;
if|if
condition|(
name|getAddressSpace
argument_list|()
operator|!=
name|Other
operator|.
name|getAddressSpace
argument_list|()
condition|)
return|return
name|false
return|;
return|return
name|MyQuals
operator|!=
name|OtherQuals
operator|&&
operator|(
name|MyQuals
operator||
name|OtherQuals
operator|)
operator|==
name|MyQuals
return|;
block|}
comment|/// isAtLeastAsQualifiedAs - Determine whether this type is at last
comment|/// as qualified as the Other type. For example, "const volatile
comment|/// int" is at least as qualified as "const int", "volatile int",
comment|/// "int", and "const volatile int".
specifier|inline
name|bool
name|QualType
operator|::
name|isAtLeastAsQualifiedAs
argument_list|(
argument|QualType Other
argument_list|)
specifier|const
block|{
comment|// FIXME: work on arbitrary qualifiers
name|unsigned
name|MyQuals
operator|=
name|this
operator|->
name|getCVRQualifiers
argument_list|()
block|;
name|unsigned
name|OtherQuals
operator|=
name|Other
operator|.
name|getCVRQualifiers
argument_list|()
block|;
if|if
condition|(
name|getAddressSpace
argument_list|()
operator|!=
name|Other
operator|.
name|getAddressSpace
argument_list|()
condition|)
return|return
name|false
return|;
return|return
operator|(
name|MyQuals
operator||
name|OtherQuals
operator|)
operator|==
name|MyQuals
return|;
block|}
comment|/// getNonReferenceType - If Type is a reference type (e.g., const
comment|/// int&), returns the type that the reference refers to ("const
comment|/// int"). Otherwise, returns the type itself. This routine is used
comment|/// throughout Sema to implement C++ 5p6:
comment|///
comment|///   If an expression initially has the type "reference to T" (8.3.2,
comment|///   8.5.3), the type is adjusted to "T" prior to any further
comment|///   analysis, the expression designates the object or function
comment|///   denoted by the reference, and the expression is an lvalue.
specifier|inline
name|QualType
name|QualType
operator|::
name|getNonReferenceType
argument_list|()
specifier|const
block|{
if|if
condition|(
specifier|const
name|ReferenceType
modifier|*
name|RefType
init|=
operator|(
operator|*
name|this
operator|)
operator|->
name|getAs
operator|<
name|ReferenceType
operator|>
operator|(
operator|)
condition|)
return|return
name|RefType
operator|->
name|getPointeeType
argument_list|()
return|;
else|else
return|return
operator|*
name|this
return|;
block|}
specifier|inline
specifier|const
name|ObjCInterfaceType
operator|*
name|Type
operator|::
name|getAsPointerToObjCInterfaceType
argument_list|()
specifier|const
block|{
if|if
condition|(
specifier|const
name|PointerType
modifier|*
name|PT
init|=
name|getAs
operator|<
name|PointerType
operator|>
operator|(
operator|)
condition|)
return|return
name|PT
operator|->
name|getPointeeType
argument_list|()
operator|->
name|getAs
operator|<
name|ObjCInterfaceType
operator|>
operator|(
operator|)
return|;
return|return
literal|0
return|;
block|}
comment|// NOTE: All of these methods use "getUnqualifiedType" to strip off address
comment|// space qualifiers if present.
specifier|inline
name|bool
name|Type
operator|::
name|isFunctionType
argument_list|()
specifier|const
block|{
return|return
name|isa
operator|<
name|FunctionType
operator|>
operator|(
name|CanonicalType
operator|.
name|getUnqualifiedType
argument_list|()
operator|)
return|;
block|}
specifier|inline
name|bool
name|Type
operator|::
name|isPointerType
argument_list|()
specifier|const
block|{
return|return
name|isa
operator|<
name|PointerType
operator|>
operator|(
name|CanonicalType
operator|.
name|getUnqualifiedType
argument_list|()
operator|)
return|;
block|}
specifier|inline
name|bool
name|Type
operator|::
name|isAnyPointerType
argument_list|()
specifier|const
block|{
return|return
name|isPointerType
argument_list|()
operator|||
name|isObjCObjectPointerType
argument_list|()
return|;
block|}
specifier|inline
name|bool
name|Type
operator|::
name|isBlockPointerType
argument_list|()
specifier|const
block|{
return|return
name|isa
operator|<
name|BlockPointerType
operator|>
operator|(
name|CanonicalType
operator|.
name|getUnqualifiedType
argument_list|()
operator|)
return|;
block|}
specifier|inline
name|bool
name|Type
operator|::
name|isReferenceType
argument_list|()
specifier|const
block|{
return|return
name|isa
operator|<
name|ReferenceType
operator|>
operator|(
name|CanonicalType
operator|.
name|getUnqualifiedType
argument_list|()
operator|)
return|;
block|}
specifier|inline
name|bool
name|Type
operator|::
name|isLValueReferenceType
argument_list|()
specifier|const
block|{
return|return
name|isa
operator|<
name|LValueReferenceType
operator|>
operator|(
name|CanonicalType
operator|.
name|getUnqualifiedType
argument_list|()
operator|)
return|;
block|}
specifier|inline
name|bool
name|Type
operator|::
name|isRValueReferenceType
argument_list|()
specifier|const
block|{
return|return
name|isa
operator|<
name|RValueReferenceType
operator|>
operator|(
name|CanonicalType
operator|.
name|getUnqualifiedType
argument_list|()
operator|)
return|;
block|}
specifier|inline
name|bool
name|Type
operator|::
name|isFunctionPointerType
argument_list|()
specifier|const
block|{
if|if
condition|(
specifier|const
name|PointerType
modifier|*
name|T
init|=
name|getAs
operator|<
name|PointerType
operator|>
operator|(
operator|)
condition|)
return|return
name|T
operator|->
name|getPointeeType
argument_list|()
operator|->
name|isFunctionType
argument_list|()
return|;
else|else
return|return
name|false
return|;
block|}
specifier|inline
name|bool
name|Type
operator|::
name|isMemberPointerType
argument_list|()
specifier|const
block|{
return|return
name|isa
operator|<
name|MemberPointerType
operator|>
operator|(
name|CanonicalType
operator|.
name|getUnqualifiedType
argument_list|()
operator|)
return|;
block|}
specifier|inline
name|bool
name|Type
operator|::
name|isMemberFunctionPointerType
argument_list|()
specifier|const
block|{
if|if
condition|(
specifier|const
name|MemberPointerType
modifier|*
name|T
init|=
name|getAs
operator|<
name|MemberPointerType
operator|>
operator|(
operator|)
condition|)
return|return
name|T
operator|->
name|getPointeeType
argument_list|()
operator|->
name|isFunctionType
argument_list|()
return|;
else|else
return|return
name|false
return|;
block|}
specifier|inline
name|bool
name|Type
operator|::
name|isArrayType
argument_list|()
specifier|const
block|{
return|return
name|isa
operator|<
name|ArrayType
operator|>
operator|(
name|CanonicalType
operator|.
name|getUnqualifiedType
argument_list|()
operator|)
return|;
block|}
specifier|inline
name|bool
name|Type
operator|::
name|isConstantArrayType
argument_list|()
specifier|const
block|{
return|return
name|isa
operator|<
name|ConstantArrayType
operator|>
operator|(
name|CanonicalType
operator|.
name|getUnqualifiedType
argument_list|()
operator|)
return|;
block|}
specifier|inline
name|bool
name|Type
operator|::
name|isIncompleteArrayType
argument_list|()
specifier|const
block|{
return|return
name|isa
operator|<
name|IncompleteArrayType
operator|>
operator|(
name|CanonicalType
operator|.
name|getUnqualifiedType
argument_list|()
operator|)
return|;
block|}
specifier|inline
name|bool
name|Type
operator|::
name|isVariableArrayType
argument_list|()
specifier|const
block|{
return|return
name|isa
operator|<
name|VariableArrayType
operator|>
operator|(
name|CanonicalType
operator|.
name|getUnqualifiedType
argument_list|()
operator|)
return|;
block|}
specifier|inline
name|bool
name|Type
operator|::
name|isDependentSizedArrayType
argument_list|()
specifier|const
block|{
return|return
name|isa
operator|<
name|DependentSizedArrayType
operator|>
operator|(
name|CanonicalType
operator|.
name|getUnqualifiedType
argument_list|()
operator|)
return|;
block|}
specifier|inline
name|bool
name|Type
operator|::
name|isRecordType
argument_list|()
specifier|const
block|{
return|return
name|isa
operator|<
name|RecordType
operator|>
operator|(
name|CanonicalType
operator|.
name|getUnqualifiedType
argument_list|()
operator|)
return|;
block|}
specifier|inline
name|bool
name|Type
operator|::
name|isAnyComplexType
argument_list|()
specifier|const
block|{
return|return
name|isa
operator|<
name|ComplexType
operator|>
operator|(
name|CanonicalType
operator|.
name|getUnqualifiedType
argument_list|()
operator|)
return|;
block|}
specifier|inline
name|bool
name|Type
operator|::
name|isVectorType
argument_list|()
specifier|const
block|{
return|return
name|isa
operator|<
name|VectorType
operator|>
operator|(
name|CanonicalType
operator|.
name|getUnqualifiedType
argument_list|()
operator|)
return|;
block|}
specifier|inline
name|bool
name|Type
operator|::
name|isExtVectorType
argument_list|()
specifier|const
block|{
return|return
name|isa
operator|<
name|ExtVectorType
operator|>
operator|(
name|CanonicalType
operator|.
name|getUnqualifiedType
argument_list|()
operator|)
return|;
block|}
specifier|inline
name|bool
name|Type
operator|::
name|isObjCObjectPointerType
argument_list|()
specifier|const
block|{
return|return
name|isa
operator|<
name|ObjCObjectPointerType
operator|>
operator|(
name|CanonicalType
operator|.
name|getUnqualifiedType
argument_list|()
operator|)
return|;
block|}
specifier|inline
name|bool
name|Type
operator|::
name|isObjCInterfaceType
argument_list|()
specifier|const
block|{
return|return
name|isa
operator|<
name|ObjCInterfaceType
operator|>
operator|(
name|CanonicalType
operator|.
name|getUnqualifiedType
argument_list|()
operator|)
return|;
block|}
specifier|inline
name|bool
name|Type
operator|::
name|isObjCQualifiedIdType
argument_list|()
specifier|const
block|{
if|if
condition|(
specifier|const
name|ObjCObjectPointerType
modifier|*
name|OPT
init|=
name|getAs
operator|<
name|ObjCObjectPointerType
operator|>
operator|(
operator|)
condition|)
return|return
name|OPT
operator|->
name|isObjCQualifiedIdType
argument_list|()
return|;
return|return
name|false
return|;
block|}
specifier|inline
name|bool
name|Type
operator|::
name|isObjCQualifiedClassType
argument_list|()
specifier|const
block|{
if|if
condition|(
specifier|const
name|ObjCObjectPointerType
modifier|*
name|OPT
init|=
name|getAs
operator|<
name|ObjCObjectPointerType
operator|>
operator|(
operator|)
condition|)
return|return
name|OPT
operator|->
name|isObjCQualifiedClassType
argument_list|()
return|;
return|return
name|false
return|;
block|}
specifier|inline
name|bool
name|Type
operator|::
name|isObjCIdType
argument_list|()
specifier|const
block|{
if|if
condition|(
specifier|const
name|ObjCObjectPointerType
modifier|*
name|OPT
init|=
name|getAs
operator|<
name|ObjCObjectPointerType
operator|>
operator|(
operator|)
condition|)
return|return
name|OPT
operator|->
name|isObjCIdType
argument_list|()
return|;
return|return
name|false
return|;
block|}
specifier|inline
name|bool
name|Type
operator|::
name|isObjCClassType
argument_list|()
specifier|const
block|{
if|if
condition|(
specifier|const
name|ObjCObjectPointerType
modifier|*
name|OPT
init|=
name|getAs
operator|<
name|ObjCObjectPointerType
operator|>
operator|(
operator|)
condition|)
return|return
name|OPT
operator|->
name|isObjCClassType
argument_list|()
return|;
return|return
name|false
return|;
block|}
specifier|inline
name|bool
name|Type
operator|::
name|isObjCBuiltinType
argument_list|()
specifier|const
block|{
return|return
name|isObjCIdType
argument_list|()
operator|||
name|isObjCClassType
argument_list|()
return|;
block|}
specifier|inline
name|bool
name|Type
operator|::
name|isTemplateTypeParmType
argument_list|()
specifier|const
block|{
return|return
name|isa
operator|<
name|TemplateTypeParmType
operator|>
operator|(
name|CanonicalType
operator|.
name|getUnqualifiedType
argument_list|()
operator|)
return|;
block|}
specifier|inline
name|bool
name|Type
operator|::
name|isSpecificBuiltinType
argument_list|(
argument|unsigned K
argument_list|)
specifier|const
block|{
if|if
condition|(
specifier|const
name|BuiltinType
modifier|*
name|BT
init|=
name|getAs
operator|<
name|BuiltinType
operator|>
operator|(
operator|)
condition|)
if|if
condition|(
name|BT
operator|->
name|getKind
argument_list|()
operator|==
operator|(
name|BuiltinType
operator|::
name|Kind
operator|)
name|K
condition|)
return|return
name|true
return|;
return|return
name|false
return|;
block|}
comment|/// \brief Determines whether this is a type for which one can define
comment|/// an overloaded operator.
specifier|inline
name|bool
name|Type
operator|::
name|isOverloadableType
argument_list|()
specifier|const
block|{
return|return
name|isDependentType
argument_list|()
operator|||
name|isRecordType
argument_list|()
operator|||
name|isEnumeralType
argument_list|()
return|;
block|}
specifier|inline
name|bool
name|Type
operator|::
name|hasPointerRepresentation
argument_list|()
specifier|const
block|{
return|return
operator|(
name|isPointerType
argument_list|()
operator|||
name|isReferenceType
argument_list|()
operator|||
name|isBlockPointerType
argument_list|()
operator|||
name|isObjCInterfaceType
argument_list|()
operator|||
name|isObjCObjectPointerType
argument_list|()
operator|||
name|isObjCQualifiedInterfaceType
argument_list|()
operator|||
name|isNullPtrType
argument_list|()
operator|)
return|;
block|}
specifier|inline
name|bool
name|Type
operator|::
name|hasObjCPointerRepresentation
argument_list|()
specifier|const
block|{
return|return
operator|(
name|isObjCInterfaceType
argument_list|()
operator|||
name|isObjCObjectPointerType
argument_list|()
operator|||
name|isObjCQualifiedInterfaceType
argument_list|()
operator|)
return|;
block|}
comment|/// Insertion operator for diagnostics.  This allows sending QualType's into a
comment|/// diagnostic with<<.
specifier|inline
specifier|const
name|DiagnosticBuilder
operator|&
name|operator
operator|<<
operator|(
specifier|const
name|DiagnosticBuilder
operator|&
name|DB
expr|,
name|QualType
name|T
operator|)
block|{
name|DB
operator|.
name|AddTaggedVal
argument_list|(
name|reinterpret_cast
operator|<
name|intptr_t
operator|>
operator|(
name|T
operator|.
name|getAsOpaquePtr
argument_list|()
operator|)
argument_list|,
name|Diagnostic
operator|::
name|ak_qualtype
argument_list|)
block|;
return|return
name|DB
return|;
block|}
comment|/// Member-template getAs<specific type>'.
name|template
operator|<
name|typename
name|T
operator|>
specifier|const
name|T
operator|*
name|Type
operator|::
name|getAs
argument_list|()
specifier|const
block|{
comment|// If this is directly a T type, return it.
if|if
condition|(
specifier|const
name|T
modifier|*
name|Ty
init|=
name|dyn_cast
operator|<
name|T
operator|>
operator|(
name|this
operator|)
condition|)
return|return
name|Ty
return|;
comment|// If the canonical form of this type isn't the right kind, reject it.
if|if
condition|(
operator|!
name|isa
operator|<
name|T
operator|>
operator|(
name|CanonicalType
operator|)
condition|)
return|return
literal|0
return|;
comment|// If this is a typedef for the type, strip the typedef off without
comment|// losing all typedef information.
return|return
name|cast
operator|<
name|T
operator|>
operator|(
name|getUnqualifiedDesugaredType
argument_list|()
operator|)
return|;
block|}
expr|}
end_block

begin_comment
comment|// end namespace clang
end_comment

begin_endif
endif|#
directive|endif
end_endif

end_unit

