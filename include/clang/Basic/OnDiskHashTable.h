begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===--- OnDiskHashTable.h - On-Disk Hash Table Implementation --*- C++ -*-===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//  This file defines facilities for reading and writing on-disk hash
end_comment

begin_comment
comment|//  tables.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LLVM_CLANG_BASIC_ON_DISK_HASH_TABLE_H
end_ifndef

begin_define
define|#
directive|define
name|LLVM_CLANG_BASIC_ON_DISK_HASH_TABLE_H
end_define

begin_include
include|#
directive|include
file|"llvm/Support/Allocator.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/Compiler.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/DataTypes.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/MathExtras.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/raw_ostream.h"
end_include

begin_include
include|#
directive|include
file|"llvm/System/Host.h"
end_include

begin_include
include|#
directive|include
file|<cassert>
end_include

begin_include
include|#
directive|include
file|<cstdlib>
end_include

begin_decl_stmt
name|namespace
name|clang
block|{
name|namespace
name|io
block|{
typedef|typedef
name|uint32_t
name|Offset
typedef|;
specifier|inline
name|void
name|Emit8
argument_list|(
name|llvm
operator|::
name|raw_ostream
operator|&
name|Out
argument_list|,
name|uint32_t
name|V
argument_list|)
block|{
name|Out
operator|<<
call|(
name|unsigned
name|char
call|)
argument_list|(
name|V
argument_list|)
expr_stmt|;
block|}
specifier|inline
name|void
name|Emit16
argument_list|(
name|llvm
operator|::
name|raw_ostream
operator|&
name|Out
argument_list|,
name|uint32_t
name|V
argument_list|)
block|{
name|Out
operator|<<
call|(
name|unsigned
name|char
call|)
argument_list|(
name|V
argument_list|)
expr_stmt|;
name|Out
operator|<<
call|(
name|unsigned
name|char
call|)
argument_list|(
name|V
operator|>>
literal|8
argument_list|)
expr_stmt|;
name|assert
argument_list|(
operator|(
name|V
operator|>>
literal|16
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
specifier|inline
name|void
name|Emit32
argument_list|(
name|llvm
operator|::
name|raw_ostream
operator|&
name|Out
argument_list|,
name|uint32_t
name|V
argument_list|)
block|{
name|Out
operator|<<
call|(
name|unsigned
name|char
call|)
argument_list|(
name|V
argument_list|)
expr_stmt|;
name|Out
operator|<<
call|(
name|unsigned
name|char
call|)
argument_list|(
name|V
operator|>>
literal|8
argument_list|)
expr_stmt|;
name|Out
operator|<<
call|(
name|unsigned
name|char
call|)
argument_list|(
name|V
operator|>>
literal|16
argument_list|)
expr_stmt|;
name|Out
operator|<<
call|(
name|unsigned
name|char
call|)
argument_list|(
name|V
operator|>>
literal|24
argument_list|)
expr_stmt|;
block|}
specifier|inline
name|void
name|Emit64
argument_list|(
name|llvm
operator|::
name|raw_ostream
operator|&
name|Out
argument_list|,
name|uint64_t
name|V
argument_list|)
block|{
name|Out
operator|<<
call|(
name|unsigned
name|char
call|)
argument_list|(
name|V
argument_list|)
expr_stmt|;
name|Out
operator|<<
call|(
name|unsigned
name|char
call|)
argument_list|(
name|V
operator|>>
literal|8
argument_list|)
expr_stmt|;
name|Out
operator|<<
call|(
name|unsigned
name|char
call|)
argument_list|(
name|V
operator|>>
literal|16
argument_list|)
expr_stmt|;
name|Out
operator|<<
call|(
name|unsigned
name|char
call|)
argument_list|(
name|V
operator|>>
literal|24
argument_list|)
expr_stmt|;
name|Out
operator|<<
call|(
name|unsigned
name|char
call|)
argument_list|(
name|V
operator|>>
literal|32
argument_list|)
expr_stmt|;
name|Out
operator|<<
call|(
name|unsigned
name|char
call|)
argument_list|(
name|V
operator|>>
literal|40
argument_list|)
expr_stmt|;
name|Out
operator|<<
call|(
name|unsigned
name|char
call|)
argument_list|(
name|V
operator|>>
literal|48
argument_list|)
expr_stmt|;
name|Out
operator|<<
call|(
name|unsigned
name|char
call|)
argument_list|(
name|V
operator|>>
literal|56
argument_list|)
expr_stmt|;
block|}
specifier|inline
name|void
name|Pad
argument_list|(
name|llvm
operator|::
name|raw_ostream
operator|&
name|Out
argument_list|,
name|unsigned
name|A
argument_list|)
block|{
name|Offset
name|off
init|=
operator|(
name|Offset
operator|)
name|Out
operator|.
name|tell
argument_list|()
decl_stmt|;
name|uint32_t
name|n
init|=
operator|(
call|(
name|uintptr_t
call|)
argument_list|(
name|off
operator|+
name|A
operator|-
literal|1
argument_list|)
operator|&
operator|~
call|(
name|uintptr_t
call|)
argument_list|(
name|A
operator|-
literal|1
argument_list|)
operator|)
operator|-
name|off
decl_stmt|;
for|for
control|(
init|;
name|n
condition|;
operator|--
name|n
control|)
name|Emit8
argument_list|(
name|Out
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
specifier|inline
name|uint16_t
name|ReadUnalignedLE16
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
modifier|&
name|Data
parameter_list|)
block|{
name|uint16_t
name|V
init|=
operator|(
operator|(
name|uint16_t
operator|)
name|Data
index|[
literal|0
index|]
operator|)
operator||
operator|(
operator|(
name|uint16_t
operator|)
name|Data
index|[
literal|1
index|]
operator|<<
literal|8
operator|)
decl_stmt|;
name|Data
operator|+=
literal|2
expr_stmt|;
return|return
name|V
return|;
block|}
specifier|inline
name|uint32_t
name|ReadUnalignedLE32
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
modifier|&
name|Data
parameter_list|)
block|{
name|uint32_t
name|V
init|=
operator|(
operator|(
name|uint32_t
operator|)
name|Data
index|[
literal|0
index|]
operator|)
operator||
operator|(
operator|(
name|uint32_t
operator|)
name|Data
index|[
literal|1
index|]
operator|<<
literal|8
operator|)
operator||
operator|(
operator|(
name|uint32_t
operator|)
name|Data
index|[
literal|2
index|]
operator|<<
literal|16
operator|)
operator||
operator|(
operator|(
name|uint32_t
operator|)
name|Data
index|[
literal|3
index|]
operator|<<
literal|24
operator|)
decl_stmt|;
name|Data
operator|+=
literal|4
expr_stmt|;
return|return
name|V
return|;
block|}
specifier|inline
name|uint64_t
name|ReadUnalignedLE64
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
modifier|&
name|Data
parameter_list|)
block|{
name|uint64_t
name|V
init|=
operator|(
operator|(
name|uint64_t
operator|)
name|Data
index|[
literal|0
index|]
operator|)
operator||
operator|(
operator|(
name|uint64_t
operator|)
name|Data
index|[
literal|1
index|]
operator|<<
literal|8
operator|)
operator||
operator|(
operator|(
name|uint64_t
operator|)
name|Data
index|[
literal|2
index|]
operator|<<
literal|16
operator|)
operator||
operator|(
operator|(
name|uint64_t
operator|)
name|Data
index|[
literal|3
index|]
operator|<<
literal|24
operator|)
operator||
operator|(
operator|(
name|uint64_t
operator|)
name|Data
index|[
literal|4
index|]
operator|<<
literal|32
operator|)
operator||
operator|(
operator|(
name|uint64_t
operator|)
name|Data
index|[
literal|5
index|]
operator|<<
literal|40
operator|)
operator||
operator|(
operator|(
name|uint64_t
operator|)
name|Data
index|[
literal|6
index|]
operator|<<
literal|48
operator|)
operator||
operator|(
operator|(
name|uint64_t
operator|)
name|Data
index|[
literal|7
index|]
operator|<<
literal|56
operator|)
decl_stmt|;
name|Data
operator|+=
literal|8
expr_stmt|;
return|return
name|V
return|;
block|}
specifier|inline
name|uint32_t
name|ReadLE32
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
modifier|&
name|Data
parameter_list|)
block|{
comment|// Hosts that directly support little-endian 32-bit loads can just
comment|// use them.  Big-endian hosts need a bswap.
name|uint32_t
name|V
init|=
operator|*
operator|(
operator|(
name|uint32_t
operator|*
operator|)
name|Data
operator|)
decl_stmt|;
if|if
condition|(
name|llvm
operator|::
name|sys
operator|::
name|isBigEndianHost
argument_list|()
condition|)
name|V
operator|=
name|llvm
operator|::
name|ByteSwap_32
argument_list|(
name|V
argument_list|)
expr_stmt|;
name|Data
operator|+=
literal|4
expr_stmt|;
return|return
name|V
return|;
block|}
block|}
comment|// end namespace io
name|template
operator|<
name|typename
name|Info
operator|>
name|class
name|OnDiskChainedHashTableGenerator
block|{
name|unsigned
name|NumBuckets
block|;
name|unsigned
name|NumEntries
block|;
name|llvm
operator|::
name|BumpPtrAllocator
name|BA
block|;
name|class
name|Item
block|{
name|public
operator|:
name|typename
name|Info
operator|::
name|key_type
name|key
block|;
name|typename
name|Info
operator|::
name|data_type
name|data
block|;
name|Item
operator|*
name|next
block|;
specifier|const
name|uint32_t
name|hash
block|;
name|Item
argument_list|(
argument|typename Info::key_type_ref k
argument_list|,
argument|typename Info::data_type_ref d
argument_list|)
operator|:
name|key
argument_list|(
name|k
argument_list|)
block|,
name|data
argument_list|(
name|d
argument_list|)
block|,
name|next
argument_list|(
literal|0
argument_list|)
block|,
name|hash
argument_list|(
argument|Info::ComputeHash(k)
argument_list|)
block|{}
block|}
block|;
name|class
name|Bucket
block|{
name|public
operator|:
name|io
operator|::
name|Offset
name|off
block|;
name|Item
operator|*
name|head
block|;
name|unsigned
name|length
block|;
name|Bucket
argument_list|()
block|{}
block|}
block|;
name|Bucket
operator|*
name|Buckets
block|;
name|private
operator|:
name|void
name|insert
argument_list|(
argument|Bucket* b
argument_list|,
argument|size_t size
argument_list|,
argument|Item* E
argument_list|)
block|{
name|unsigned
name|idx
operator|=
name|E
operator|->
name|hash
operator|&
operator|(
name|size
operator|-
literal|1
operator|)
block|;
name|Bucket
operator|&
name|B
operator|=
name|b
index|[
name|idx
index|]
block|;
name|E
operator|->
name|next
operator|=
name|B
operator|.
name|head
block|;
operator|++
name|B
operator|.
name|length
block|;
name|B
operator|.
name|head
operator|=
name|E
block|;   }
name|void
name|resize
argument_list|(
argument|size_t newsize
argument_list|)
block|{
name|Bucket
operator|*
name|newBuckets
operator|=
operator|(
name|Bucket
operator|*
operator|)
name|std
operator|::
name|calloc
argument_list|(
name|newsize
argument_list|,
sizeof|sizeof
argument_list|(
name|Bucket
argument_list|)
argument_list|)
block|;
comment|// Populate newBuckets with the old entries.
for|for
control|(
name|unsigned
name|i
init|=
literal|0
init|;
name|i
operator|<
name|NumBuckets
condition|;
operator|++
name|i
control|)
for|for
control|(
name|Item
modifier|*
name|E
init|=
name|Buckets
index|[
name|i
index|]
operator|.
name|head
init|;
name|E
condition|;
control|)
block|{
name|Item
modifier|*
name|N
init|=
name|E
operator|->
name|next
decl_stmt|;
name|E
operator|->
name|next
operator|=
literal|0
expr_stmt|;
name|insert
argument_list|(
name|newBuckets
argument_list|,
name|newsize
argument_list|,
name|E
argument_list|)
expr_stmt|;
name|E
operator|=
name|N
expr_stmt|;
block|}
name|free
argument_list|(
name|Buckets
argument_list|)
expr_stmt|;
name|NumBuckets
operator|=
name|newsize
block|;
name|Buckets
operator|=
name|newBuckets
block|;   }
name|public
operator|:
name|void
name|insert
argument_list|(
argument|typename Info::key_type_ref key
argument_list|,
argument|typename Info::data_type_ref data
argument_list|)
block|{
operator|++
name|NumEntries
block|;
if|if
condition|(
literal|4
operator|*
name|NumEntries
operator|>=
literal|3
operator|*
name|NumBuckets
condition|)
name|resize
argument_list|(
name|NumBuckets
operator|*
literal|2
argument_list|)
expr_stmt|;
name|insert
argument_list|(
name|Buckets
argument_list|,
name|NumBuckets
argument_list|,
name|new
argument_list|(
argument|BA.Allocate<Item>()
argument_list|)
name|Item
argument_list|(
name|key
argument_list|,
name|data
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_expr_stmt
name|io
operator|::
name|Offset
name|Emit
argument_list|(
argument|llvm::raw_ostream&out
argument_list|)
block|{
name|Info
name|InfoObj
block|;
return|return
name|Emit
argument_list|(
name|out
argument_list|,
name|InfoObj
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|io
operator|::
name|Offset
name|Emit
argument_list|(
argument|llvm::raw_ostream&out
argument_list|,
argument|Info&InfoObj
argument_list|)
block|{
name|using
name|namespace
name|clang
operator|::
name|io
block|;
comment|// Emit the payload of the table.
for|for
control|(
name|unsigned
name|i
init|=
literal|0
init|;
name|i
operator|<
name|NumBuckets
condition|;
operator|++
name|i
control|)
block|{
name|Bucket
modifier|&
name|B
init|=
name|Buckets
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|B
operator|.
name|head
condition|)
continue|continue;
comment|// Store the offset for the data of this bucket.
name|B
operator|.
name|off
operator|=
name|out
operator|.
name|tell
argument_list|()
expr_stmt|;
name|assert
argument_list|(
name|B
operator|.
name|off
operator|&&
literal|"Cannot write a bucket at offset 0. Please add padding."
argument_list|)
expr_stmt|;
comment|// Write out the number of items in the bucket.
name|Emit16
argument_list|(
name|out
argument_list|,
name|B
operator|.
name|length
argument_list|)
expr_stmt|;
comment|// Write out the entries in the bucket.
for|for
control|(
name|Item
modifier|*
name|I
init|=
name|B
operator|.
name|head
init|;
name|I
condition|;
name|I
operator|=
name|I
operator|->
name|next
control|)
block|{
name|Emit32
argument_list|(
name|out
argument_list|,
name|I
operator|->
name|hash
argument_list|)
expr_stmt|;
specifier|const
name|std
operator|::
name|pair
operator|<
name|unsigned
operator|,
name|unsigned
operator|>
operator|&
name|Len
operator|=
name|InfoObj
operator|.
name|EmitKeyDataLength
argument_list|(
name|out
argument_list|,
name|I
operator|->
name|key
argument_list|,
name|I
operator|->
name|data
argument_list|)
expr_stmt|;
name|InfoObj
operator|.
name|EmitKey
argument_list|(
name|out
argument_list|,
name|I
operator|->
name|key
argument_list|,
name|Len
operator|.
name|first
argument_list|)
expr_stmt|;
name|InfoObj
operator|.
name|EmitData
argument_list|(
name|out
argument_list|,
name|I
operator|->
name|key
argument_list|,
name|I
operator|->
name|data
argument_list|,
name|Len
operator|.
name|second
argument_list|)
expr_stmt|;
block|}
end_expr_stmt

begin_comment
unit|}
comment|// Emit the hashtable itself.
end_comment

begin_expr_stmt
unit|Pad
operator|(
name|out
operator|,
literal|4
operator|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|io
operator|::
name|Offset
name|TableOff
operator|=
name|out
operator|.
name|tell
argument_list|()
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|Emit32
argument_list|(
name|out
argument_list|,
name|NumBuckets
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|Emit32
argument_list|(
name|out
argument_list|,
name|NumEntries
argument_list|)
expr_stmt|;
end_expr_stmt

begin_for
for|for
control|(
name|unsigned
name|i
init|=
literal|0
init|;
name|i
operator|<
name|NumBuckets
condition|;
operator|++
name|i
control|)
name|Emit32
argument_list|(
name|out
argument_list|,
name|Buckets
index|[
name|i
index|]
operator|.
name|off
argument_list|)
expr_stmt|;
end_for

begin_return
return|return
name|TableOff
return|;
end_return

begin_expr_stmt
unit|}    OnDiskChainedHashTableGenerator
operator|(
operator|)
block|{
name|NumEntries
operator|=
literal|0
block|;
name|NumBuckets
operator|=
literal|64
block|;
comment|// Note that we do not need to run the constructors of the individual
comment|// Bucket objects since 'calloc' returns bytes that are all 0.
name|Buckets
operator|=
operator|(
name|Bucket
operator|*
operator|)
name|std
operator|::
name|calloc
argument_list|(
name|NumBuckets
argument_list|,
sizeof|sizeof
argument_list|(
name|Bucket
argument_list|)
argument_list|)
block|;   }
operator|~
name|OnDiskChainedHashTableGenerator
argument_list|()
block|{
name|std
operator|::
name|free
argument_list|(
name|Buckets
argument_list|)
block|;   }
end_expr_stmt

begin_expr_stmt
unit|};
name|template
operator|<
name|typename
name|Info
operator|>
name|class
name|OnDiskChainedHashTable
block|{
specifier|const
name|unsigned
name|NumBuckets
block|;
specifier|const
name|unsigned
name|NumEntries
block|;
specifier|const
name|unsigned
name|char
operator|*
specifier|const
name|Buckets
block|;
specifier|const
name|unsigned
name|char
operator|*
specifier|const
name|Base
block|;
name|Info
name|InfoObj
block|;
name|public
operator|:
typedef|typedef
name|typename
name|Info
operator|::
name|internal_key_type
name|internal_key_type
expr_stmt|;
end_expr_stmt

begin_typedef
typedef|typedef
name|typename
name|Info
operator|::
name|external_key_type
name|external_key_type
expr_stmt|;
end_typedef

begin_typedef
typedef|typedef
name|typename
name|Info
operator|::
name|data_type
name|data_type
expr_stmt|;
end_typedef

begin_macro
name|OnDiskChainedHashTable
argument_list|(
argument|unsigned numBuckets
argument_list|,
argument|unsigned numEntries
argument_list|,
argument|const unsigned char* buckets
argument_list|,
argument|const unsigned char* base
argument_list|,
argument|const Info&InfoObj = Info()
argument_list|)
end_macro

begin_expr_stmt
unit|:
name|NumBuckets
argument_list|(
name|numBuckets
argument_list|)
operator|,
name|NumEntries
argument_list|(
name|numEntries
argument_list|)
operator|,
name|Buckets
argument_list|(
name|buckets
argument_list|)
operator|,
name|Base
argument_list|(
name|base
argument_list|)
operator|,
name|InfoObj
argument_list|(
argument|InfoObj
argument_list|)
block|{
name|assert
argument_list|(
operator|(
name|reinterpret_cast
operator|<
name|uintptr_t
operator|>
operator|(
name|buckets
operator|)
operator|&
literal|0x3
operator|)
operator|==
literal|0
operator|&&
literal|"'buckets' must have a 4-byte alignment"
argument_list|)
block|;       }
name|unsigned
name|getNumBuckets
argument_list|()
specifier|const
block|{
return|return
name|NumBuckets
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|unsigned
name|getNumEntries
argument_list|()
specifier|const
block|{
return|return
name|NumEntries
return|;
block|}
end_expr_stmt

begin_expr_stmt
specifier|const
name|unsigned
name|char
operator|*
name|getBase
argument_list|()
specifier|const
block|{
return|return
name|Base
return|;
block|}
end_expr_stmt

begin_expr_stmt
specifier|const
name|unsigned
name|char
operator|*
name|getBuckets
argument_list|()
specifier|const
block|{
return|return
name|Buckets
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|bool
name|isEmpty
argument_list|()
specifier|const
block|{
return|return
name|NumEntries
operator|==
literal|0
return|;
block|}
end_expr_stmt

begin_decl_stmt
name|class
name|iterator
block|{
name|internal_key_type
name|key
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
specifier|const
name|data
decl_stmt|;
specifier|const
name|unsigned
name|len
decl_stmt|;
name|Info
modifier|*
name|InfoObj
decl_stmt|;
name|public
label|:
name|iterator
argument_list|()
operator|:
name|data
argument_list|(
literal|0
argument_list|)
operator|,
name|len
argument_list|(
literal|0
argument_list|)
block|{}
name|iterator
argument_list|(
argument|const internal_key_type k
argument_list|,
argument|const unsigned char* d
argument_list|,
argument|unsigned l
argument_list|,
argument|Info *InfoObj
argument_list|)
operator|:
name|key
argument_list|(
name|k
argument_list|)
operator|,
name|data
argument_list|(
name|d
argument_list|)
operator|,
name|len
argument_list|(
name|l
argument_list|)
operator|,
name|InfoObj
argument_list|(
argument|InfoObj
argument_list|)
block|{}
name|data_type
name|operator
operator|*
operator|(
operator|)
specifier|const
block|{
return|return
name|InfoObj
operator|->
name|ReadData
argument_list|(
name|key
argument_list|,
name|data
argument_list|,
name|len
argument_list|)
return|;
block|}
name|bool
name|operator
operator|==
operator|(
specifier|const
name|iterator
operator|&
name|X
operator|)
specifier|const
block|{
return|return
name|X
operator|.
name|data
operator|==
name|data
return|;
block|}
name|bool
name|operator
operator|!=
operator|(
specifier|const
name|iterator
operator|&
name|X
operator|)
specifier|const
block|{
return|return
name|X
operator|.
name|data
operator|!=
name|data
return|;
block|}
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_function
name|iterator
name|find
parameter_list|(
specifier|const
name|external_key_type
modifier|&
name|eKey
parameter_list|,
name|Info
modifier|*
name|InfoPtr
init|=
literal|0
parameter_list|)
block|{
if|if
condition|(
operator|!
name|InfoPtr
condition|)
name|InfoPtr
operator|=
operator|&
name|InfoObj
expr_stmt|;
name|using
name|namespace
name|io
decl_stmt|;
specifier|const
name|internal_key_type
modifier|&
name|iKey
init|=
name|Info
operator|::
name|GetInternalKey
argument_list|(
name|eKey
argument_list|)
decl_stmt|;
name|unsigned
name|key_hash
init|=
name|Info
operator|::
name|ComputeHash
argument_list|(
name|iKey
argument_list|)
decl_stmt|;
comment|// Each bucket is just a 32-bit offset into the hash table file.
name|unsigned
name|idx
init|=
name|key_hash
operator|&
operator|(
name|NumBuckets
operator|-
literal|1
operator|)
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|Bucket
init|=
name|Buckets
operator|+
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|*
name|idx
decl_stmt|;
name|unsigned
name|offset
init|=
name|ReadLE32
argument_list|(
name|Bucket
argument_list|)
decl_stmt|;
if|if
condition|(
name|offset
operator|==
literal|0
condition|)
return|return
name|iterator
argument_list|()
return|;
comment|// Empty bucket.
specifier|const
name|unsigned
name|char
modifier|*
name|Items
init|=
name|Base
operator|+
name|offset
decl_stmt|;
comment|// 'Items' starts with a 16-bit unsigned integer representing the
comment|// number of items in this bucket.
name|unsigned
name|len
init|=
name|ReadUnalignedLE16
argument_list|(
name|Items
argument_list|)
decl_stmt|;
for|for
control|(
name|unsigned
name|i
init|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
operator|++
name|i
control|)
block|{
comment|// Read the hash.
name|uint32_t
name|item_hash
init|=
name|ReadUnalignedLE32
argument_list|(
name|Items
argument_list|)
decl_stmt|;
comment|// Determine the length of the key and the data.
specifier|const
name|std
operator|::
name|pair
operator|<
name|unsigned
operator|,
name|unsigned
operator|>
operator|&
name|L
operator|=
name|Info
operator|::
name|ReadKeyDataLength
argument_list|(
name|Items
argument_list|)
expr_stmt|;
name|unsigned
name|item_len
init|=
name|L
operator|.
name|first
operator|+
name|L
operator|.
name|second
decl_stmt|;
comment|// Compare the hashes.  If they are not the same, skip the entry entirely.
if|if
condition|(
name|item_hash
operator|!=
name|key_hash
condition|)
block|{
name|Items
operator|+=
name|item_len
expr_stmt|;
continue|continue;
block|}
comment|// Read the key.
specifier|const
name|internal_key_type
modifier|&
name|X
init|=
name|InfoPtr
operator|->
name|ReadKey
argument_list|(
operator|(
specifier|const
name|unsigned
name|char
operator|*
specifier|const
operator|)
name|Items
argument_list|,
name|L
operator|.
name|first
argument_list|)
decl_stmt|;
comment|// If the key doesn't match just skip reading the value.
if|if
condition|(
operator|!
name|Info
operator|::
name|EqualKey
argument_list|(
name|X
argument_list|,
name|iKey
argument_list|)
condition|)
block|{
name|Items
operator|+=
name|item_len
expr_stmt|;
continue|continue;
block|}
comment|// The key matches!
return|return
name|iterator
argument_list|(
name|X
argument_list|,
name|Items
operator|+
name|L
operator|.
name|first
argument_list|,
name|L
operator|.
name|second
argument_list|,
name|InfoPtr
argument_list|)
return|;
block|}
return|return
name|iterator
argument_list|()
return|;
block|}
end_function

begin_expr_stmt
name|iterator
name|end
argument_list|()
specifier|const
block|{
return|return
name|iterator
argument_list|()
return|;
block|}
end_expr_stmt

begin_function
specifier|static
name|OnDiskChainedHashTable
modifier|*
name|Create
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|buckets
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
specifier|const
name|base
parameter_list|,
specifier|const
name|Info
modifier|&
name|InfoObj
init|=
name|Info
argument_list|()
parameter_list|)
block|{
name|using
name|namespace
name|io
decl_stmt|;
name|assert
argument_list|(
name|buckets
operator|>
name|base
argument_list|)
expr_stmt|;
name|assert
argument_list|(
operator|(
name|reinterpret_cast
operator|<
name|uintptr_t
operator|>
operator|(
name|buckets
operator|)
operator|&
literal|0x3
operator|)
operator|==
literal|0
operator|&&
literal|"buckets should be 4-byte aligned."
argument_list|)
expr_stmt|;
name|unsigned
name|numBuckets
init|=
name|ReadLE32
argument_list|(
name|buckets
argument_list|)
decl_stmt|;
name|unsigned
name|numEntries
init|=
name|ReadLE32
argument_list|(
name|buckets
argument_list|)
decl_stmt|;
return|return
name|new
name|OnDiskChainedHashTable
operator|<
name|Info
operator|>
operator|(
name|numBuckets
operator|,
name|numEntries
operator|,
name|buckets
operator|,
name|base
operator|,
name|InfoObj
operator|)
return|;
block|}
end_function

begin_comment
unit|};  }
comment|// end namespace clang
end_comment

begin_endif
endif|#
directive|endif
end_endif

end_unit

