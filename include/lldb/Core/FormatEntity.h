begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===-- FormatEntity.h ------------------------------------------*- C++ -*-===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|liblldb_FormatEntity_h_
end_ifndef

begin_define
define|#
directive|define
name|liblldb_FormatEntity_h_
end_define

begin_include
include|#
directive|include
file|"lldb/Utility/Error.h"
end_include

begin_include
include|#
directive|include
file|"lldb/Utility/FileSpec.h"
end_include

begin_comment
comment|// for FileSpec
end_comment

begin_include
include|#
directive|include
file|"lldb/lldb-enumerations.h"
end_include

begin_comment
comment|// for Format::eFormatDefault, Format
end_comment

begin_include
include|#
directive|include
file|"lldb/lldb-types.h"
end_include

begin_comment
comment|// for addr_t
end_comment

begin_include
include|#
directive|include
file|<algorithm>
end_include

begin_comment
comment|// for min
end_comment

begin_include
include|#
directive|include
file|<stddef.h>
end_include

begin_comment
comment|// for size_t
end_comment

begin_include
include|#
directive|include
file|<stdint.h>
end_include

begin_comment
comment|// for uint32_t, uint64_t
end_comment

begin_include
include|#
directive|include
file|<string>
end_include

begin_include
include|#
directive|include
file|<vector>
end_include

begin_decl_stmt
name|namespace
name|lldb_private
block|{
name|class
name|Address
decl_stmt|;
block|}
end_decl_stmt

begin_decl_stmt
name|namespace
name|lldb_private
block|{
name|class
name|ExecutionContext
decl_stmt|;
block|}
end_decl_stmt

begin_decl_stmt
name|namespace
name|lldb_private
block|{
name|class
name|Stream
decl_stmt|;
block|}
end_decl_stmt

begin_decl_stmt
name|namespace
name|lldb_private
block|{
name|class
name|StringList
decl_stmt|;
block|}
end_decl_stmt

begin_decl_stmt
name|namespace
name|lldb_private
block|{
name|class
name|SymbolContext
decl_stmt|;
block|}
end_decl_stmt

begin_decl_stmt
name|namespace
name|lldb_private
block|{
name|class
name|ValueObject
decl_stmt|;
block|}
end_decl_stmt

begin_decl_stmt
name|namespace
name|llvm
block|{
name|class
name|StringRef
decl_stmt|;
block|}
end_decl_stmt

begin_decl_stmt
name|namespace
name|lldb_private
block|{
name|class
name|FormatEntity
block|{
name|public
label|:
struct|struct
name|Entry
block|{
name|enum
name|class
name|Type
block|{
name|Invalid
operator|,
name|ParentNumber
operator|,
name|ParentString
operator|,
name|InsertString
operator|,
name|Root
operator|,
name|String
operator|,
name|Scope
operator|,
name|Variable
operator|,
name|VariableSynthetic
operator|,
name|ScriptVariable
operator|,
name|ScriptVariableSynthetic
operator|,
name|AddressLoad
operator|,
name|AddressFile
operator|,
name|AddressLoadOrFile
operator|,
name|ProcessID
operator|,
name|ProcessFile
operator|,
name|ScriptProcess
operator|,
name|ThreadID
operator|,
name|ThreadProtocolID
operator|,
name|ThreadIndexID
operator|,
name|ThreadName
operator|,
name|ThreadQueue
operator|,
name|ThreadStopReason
operator|,
name|ThreadReturnValue
operator|,
name|ThreadCompletedExpression
operator|,
name|ScriptThread
operator|,
name|ThreadInfo
operator|,
name|TargetArch
operator|,
name|ScriptTarget
operator|,
name|ModuleFile
operator|,
name|File
operator|,
name|Lang
operator|,
name|FrameIndex
operator|,
name|FrameNoDebug
operator|,
name|FrameRegisterPC
operator|,
name|FrameRegisterSP
operator|,
name|FrameRegisterFP
operator|,
name|FrameRegisterFlags
operator|,
name|FrameRegisterByName
operator|,
name|ScriptFrame
operator|,
name|FunctionID
operator|,
name|FunctionDidChange
operator|,
name|FunctionInitialFunction
operator|,
name|FunctionName
operator|,
name|FunctionNameWithArgs
operator|,
name|FunctionNameNoArgs
operator|,
name|FunctionAddrOffset
operator|,
name|FunctionAddrOffsetConcrete
operator|,
name|FunctionLineOffset
operator|,
name|FunctionPCOffset
operator|,
name|FunctionInitial
operator|,
name|FunctionChanged
operator|,
name|FunctionIsOptimized
operator|,
name|LineEntryFile
operator|,
name|LineEntryLineNumber
operator|,
name|LineEntryStartAddress
operator|,
name|LineEntryEndAddress
operator|,
name|CurrentPCArrow
block|}
empty_stmt|;
enum|enum
name|FormatType
block|{
name|None
block|,
name|UInt32
block|,
name|UInt64
block|,
name|CString
block|}
enum|;
struct|struct
name|Definition
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
specifier|const
name|char
modifier|*
name|string
decl_stmt|;
comment|// Insert this exact string into the output
name|Entry
operator|::
name|Type
name|type
expr_stmt|;
name|FormatType
name|format_type
decl_stmt|;
comment|// uint32_t, uint64_t, cstr, or anything that can
comment|// be formatted by printf or lldb::Format
name|uint64_t
name|data
decl_stmt|;
name|uint32_t
name|num_children
decl_stmt|;
name|Definition
modifier|*
name|children
decl_stmt|;
comment|// An array of "num_children" Definition entries,
name|bool
name|keep_separator
decl_stmt|;
block|}
struct|;
name|Entry
argument_list|(
argument|Type t = Type::Invalid
argument_list|,
argument|const char *s = nullptr
argument_list|,
argument|const char *f = nullptr
argument_list|)
block|:
name|string
argument_list|(
name|s
condition|?
name|s
else|:
literal|""
argument_list|)
operator|,
name|printf_format
argument_list|(
name|f
condition|?
name|f
else|:
literal|""
argument_list|)
operator|,
name|children
argument_list|()
operator|,
name|definition
argument_list|(
name|nullptr
argument_list|)
operator|,
name|type
argument_list|(
name|t
argument_list|)
operator|,
name|fmt
argument_list|(
name|lldb
operator|::
name|eFormatDefault
argument_list|)
operator|,
name|number
argument_list|(
literal|0
argument_list|)
operator|,
name|deref
argument_list|(
argument|false
argument_list|)
block|{}
name|Entry
argument_list|(
argument|llvm::StringRef s
argument_list|)
expr_stmt|;
name|Entry
argument_list|(
argument|char ch
argument_list|)
empty_stmt|;
name|void
name|AppendChar
parameter_list|(
name|char
name|ch
parameter_list|)
function_decl|;
name|void
name|AppendText
argument_list|(
specifier|const
name|llvm
operator|::
name|StringRef
operator|&
name|s
argument_list|)
decl_stmt|;
name|void
name|AppendText
parameter_list|(
specifier|const
name|char
modifier|*
name|cstr
parameter_list|)
function_decl|;
name|void
name|AppendEntry
argument_list|(
specifier|const
name|Entry
operator|&&
name|entry
argument_list|)
block|{
name|children
operator|.
name|push_back
argument_list|(
name|entry
argument_list|)
expr_stmt|;
block|}
name|void
name|Clear
parameter_list|()
block|{
name|string
operator|.
name|clear
argument_list|()
expr_stmt|;
name|printf_format
operator|.
name|clear
argument_list|()
expr_stmt|;
name|children
operator|.
name|clear
argument_list|()
expr_stmt|;
name|definition
operator|=
name|nullptr
expr_stmt|;
name|type
operator|=
name|Type
operator|::
name|Invalid
expr_stmt|;
name|fmt
operator|=
name|lldb
operator|::
name|eFormatDefault
expr_stmt|;
name|number
operator|=
literal|0
expr_stmt|;
name|deref
operator|=
name|false
expr_stmt|;
block|}
specifier|static
specifier|const
name|char
modifier|*
name|TypeToCString
parameter_list|(
name|Type
name|t
parameter_list|)
function_decl|;
name|void
name|Dump
argument_list|(
name|Stream
operator|&
name|s
argument_list|,
name|int
name|depth
operator|=
literal|0
argument_list|)
decl|const
decl_stmt|;
name|bool
name|operator
operator|==
operator|(
specifier|const
name|Entry
operator|&
name|rhs
operator|)
specifier|const
block|{
if|if
condition|(
name|string
operator|!=
name|rhs
operator|.
name|string
condition|)
return|return
name|false
return|;
if|if
condition|(
name|printf_format
operator|!=
name|rhs
operator|.
name|printf_format
condition|)
return|return
name|false
return|;
specifier|const
name|size_t
name|n
init|=
name|children
operator|.
name|size
argument_list|()
decl_stmt|;
specifier|const
name|size_t
name|m
init|=
name|rhs
operator|.
name|children
operator|.
name|size
argument_list|()
decl_stmt|;
for|for
control|(
name|size_t
name|i
init|=
literal|0
init|;
name|i
operator|<
name|std
operator|::
name|min
operator|<
name|size_t
operator|>
operator|(
name|n
operator|,
name|m
operator|)
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|children
index|[
name|i
index|]
operator|==
name|rhs
operator|.
name|children
index|[
name|i
index|]
operator|)
condition|)
return|return
name|false
return|;
block|}
if|if
condition|(
name|children
operator|!=
name|rhs
operator|.
name|children
condition|)
return|return
name|false
return|;
if|if
condition|(
name|definition
operator|!=
name|rhs
operator|.
name|definition
condition|)
return|return
name|false
return|;
if|if
condition|(
name|type
operator|!=
name|rhs
operator|.
name|type
condition|)
return|return
name|false
return|;
if|if
condition|(
name|fmt
operator|!=
name|rhs
operator|.
name|fmt
condition|)
return|return
name|false
return|;
if|if
condition|(
name|deref
operator|!=
name|rhs
operator|.
name|deref
condition|)
return|return
name|false
return|;
return|return
name|true
return|;
block|}
name|std
decl|::
name|string
name|string
struct|;
name|std
operator|::
name|string
name|printf_format
expr_stmt|;
name|std
operator|::
name|vector
operator|<
name|Entry
operator|>
name|children
expr_stmt|;
name|Definition
modifier|*
name|definition
decl_stmt|;
name|Type
name|type
decl_stmt|;
name|lldb
operator|::
name|Format
name|fmt
expr_stmt|;
name|lldb
operator|::
name|addr_t
name|number
expr_stmt|;
name|bool
name|deref
decl_stmt|;
block|}
empty_stmt|;
specifier|static
name|bool
name|Format
parameter_list|(
specifier|const
name|Entry
modifier|&
name|entry
parameter_list|,
name|Stream
modifier|&
name|s
parameter_list|,
specifier|const
name|SymbolContext
modifier|*
name|sc
parameter_list|,
specifier|const
name|ExecutionContext
modifier|*
name|exe_ctx
parameter_list|,
specifier|const
name|Address
modifier|*
name|addr
parameter_list|,
name|ValueObject
modifier|*
name|valobj
parameter_list|,
name|bool
name|function_changed
parameter_list|,
name|bool
name|initial_function
parameter_list|)
function_decl|;
specifier|static
name|bool
name|FormatStringRef
argument_list|(
specifier|const
name|llvm
operator|::
name|StringRef
operator|&
name|format
argument_list|,
name|Stream
operator|&
name|s
argument_list|,
specifier|const
name|SymbolContext
operator|*
name|sc
argument_list|,
specifier|const
name|ExecutionContext
operator|*
name|exe_ctx
argument_list|,
specifier|const
name|Address
operator|*
name|addr
argument_list|,
name|ValueObject
operator|*
name|valobj
argument_list|,
name|bool
name|function_changed
argument_list|,
name|bool
name|initial_function
argument_list|)
decl_stmt|;
specifier|static
name|bool
name|FormatCString
parameter_list|(
specifier|const
name|char
modifier|*
name|format
parameter_list|,
name|Stream
modifier|&
name|s
parameter_list|,
specifier|const
name|SymbolContext
modifier|*
name|sc
parameter_list|,
specifier|const
name|ExecutionContext
modifier|*
name|exe_ctx
parameter_list|,
specifier|const
name|Address
modifier|*
name|addr
parameter_list|,
name|ValueObject
modifier|*
name|valobj
parameter_list|,
name|bool
name|function_changed
parameter_list|,
name|bool
name|initial_function
parameter_list|)
function_decl|;
specifier|static
name|Error
name|Parse
argument_list|(
specifier|const
name|llvm
operator|::
name|StringRef
operator|&
name|format
argument_list|,
name|Entry
operator|&
name|entry
argument_list|)
decl_stmt|;
specifier|static
name|Error
name|ExtractVariableInfo
argument_list|(
name|llvm
operator|::
name|StringRef
operator|&
name|format_str
argument_list|,
name|llvm
operator|::
name|StringRef
operator|&
name|variable_name
argument_list|,
name|llvm
operator|::
name|StringRef
operator|&
name|variable_format
argument_list|)
decl_stmt|;
specifier|static
name|size_t
name|AutoComplete
argument_list|(
name|llvm
operator|::
name|StringRef
name|s
argument_list|,
name|int
name|match_start_point
argument_list|,
name|int
name|max_return_elements
argument_list|,
name|bool
operator|&
name|word_complete
argument_list|,
name|StringList
operator|&
name|matches
argument_list|)
decl_stmt|;
comment|//----------------------------------------------------------------------
comment|// Format the current elements into the stream \a s.
comment|//
comment|// The root element will be stripped off and the format str passed in
comment|// will be either an empty string (print a description of this object),
comment|// or contain a . separated series like a domain name that identifies
comment|// further sub elements to display.
comment|//----------------------------------------------------------------------
specifier|static
name|bool
name|FormatFileSpec
argument_list|(
specifier|const
name|FileSpec
operator|&
name|file
argument_list|,
name|Stream
operator|&
name|s
argument_list|,
name|llvm
operator|::
name|StringRef
name|elements
argument_list|,
name|llvm
operator|::
name|StringRef
name|element_format
argument_list|)
decl_stmt|;
name|protected
label|:
specifier|static
name|Error
name|ParseInternal
argument_list|(
name|llvm
operator|::
name|StringRef
operator|&
name|format
argument_list|,
name|Entry
operator|&
name|parent_entry
argument_list|,
name|uint32_t
name|depth
argument_list|)
decl_stmt|;
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_comment
unit|}
comment|// namespace lldb_private
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|// liblldb_FormatEntity_h_
end_comment

end_unit

