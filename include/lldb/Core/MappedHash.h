begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===-- MappedHash.h --------------------------------------------*- C++ -*-===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|liblldb_MappedHash_h_
end_ifndef

begin_define
define|#
directive|define
name|liblldb_MappedHash_h_
end_define

begin_comment
comment|// C Includes
end_comment

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|<stdint.h>
end_include

begin_comment
comment|// C++ Includes
end_comment

begin_include
include|#
directive|include
file|<algorithm>
end_include

begin_include
include|#
directive|include
file|<functional>
end_include

begin_include
include|#
directive|include
file|<map>
end_include

begin_include
include|#
directive|include
file|<vector>
end_include

begin_comment
comment|// Other libraries and framework includes
end_comment

begin_comment
comment|// Project includes
end_comment

begin_include
include|#
directive|include
file|"lldb/Utility/DataExtractor.h"
end_include

begin_include
include|#
directive|include
file|"lldb/Utility/Stream.h"
end_include

begin_decl_stmt
name|class
name|MappedHash
block|{
name|public
label|:
enum|enum
name|HashFunctionType
block|{
name|eHashFunctionDJB
init|=
literal|0u
comment|// Daniel J Bernstein hash function that is also used
comment|// by the ELF GNU_HASH sections
block|}
enum|;
specifier|static
name|uint32_t
name|HashStringUsingDJB
parameter_list|(
specifier|const
name|char
modifier|*
name|s
parameter_list|)
block|{
name|uint32_t
name|h
init|=
literal|5381
decl_stmt|;
for|for
control|(
name|unsigned
name|char
name|c
init|=
operator|*
name|s
init|;
name|c
condition|;
name|c
operator|=
operator|*
operator|++
name|s
control|)
name|h
operator|=
operator|(
operator|(
name|h
operator|<<
literal|5
operator|)
operator|+
name|h
operator|)
operator|+
name|c
expr_stmt|;
return|return
name|h
return|;
block|}
specifier|static
name|uint32_t
name|HashString
parameter_list|(
name|uint32_t
name|hash_function
parameter_list|,
specifier|const
name|char
modifier|*
name|s
parameter_list|)
block|{
if|if
condition|(
operator|!
name|s
condition|)
return|return
literal|0
return|;
switch|switch
condition|(
name|hash_function
condition|)
block|{
case|case
name|MappedHash
operator|::
name|eHashFunctionDJB
case|:
return|return
name|HashStringUsingDJB
argument_list|(
name|s
argument_list|)
return|;
default|default:
break|break;
block|}
name|llvm_unreachable
argument_list|(
literal|"Invalid hash function index"
argument_list|)
expr_stmt|;
block|}
specifier|static
specifier|const
name|uint32_t
name|HASH_MAGIC
init|=
literal|0x48415348u
decl_stmt|;
specifier|static
specifier|const
name|uint32_t
name|HASH_CIGAM
init|=
literal|0x48534148u
decl_stmt|;
name|template
operator|<
name|typename
name|T
operator|>
expr|struct
name|Header
block|{
typedef|typedef
name|T
name|HeaderData
typedef|;
name|uint32_t
name|magic
expr_stmt|;
comment|// HASH_MAGIC or HASH_CIGAM magic value to allow endian detection
name|uint16_t
name|version
decl_stmt|;
comment|// Version number
name|uint16_t
name|hash_function
decl_stmt|;
comment|// The hash function enumeration that was used
name|uint32_t
name|bucket_count
decl_stmt|;
comment|// The number of buckets in this hash table
name|uint32_t
name|hashes_count
decl_stmt|;
comment|// The total number of unique hash values and hash
comment|// data offsets in this table
name|uint32_t
name|header_data_len
decl_stmt|;
comment|// The size in bytes of the "header_data" template
comment|// member below
name|HeaderData
name|header_data
decl_stmt|;
comment|//
name|Header
argument_list|()
operator|:
name|magic
argument_list|(
name|HASH_MAGIC
argument_list|)
operator|,
name|version
argument_list|(
literal|1
argument_list|)
operator|,
name|hash_function
argument_list|(
name|eHashFunctionDJB
argument_list|)
operator|,
name|bucket_count
argument_list|(
literal|0
argument_list|)
operator|,
name|hashes_count
argument_list|(
literal|0
argument_list|)
operator|,
name|header_data_len
argument_list|(
sizeof|sizeof
argument_list|(
name|T
argument_list|)
argument_list|)
operator|,
name|header_data
argument_list|()
block|{}
name|virtual
operator|~
name|Header
argument_list|()
operator|=
expr|default
expr_stmt|;
name|size_t
name|GetByteSize
argument_list|()
specifier|const
block|{
return|return
sizeof|sizeof
argument_list|(
name|magic
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|version
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|hash_function
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|bucket_count
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|hashes_count
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|header_data_len
argument_list|)
operator|+
name|header_data_len
return|;
block|}
name|virtual
name|size_t
name|GetByteSize
parameter_list|(
specifier|const
name|HeaderData
modifier|&
name|header_data
parameter_list|)
init|=
literal|0
function_decl|;
name|void
name|SetHeaderDataByteSize
parameter_list|(
name|uint32_t
name|header_data_byte_size
parameter_list|)
block|{
name|header_data_len
operator|=
name|header_data_byte_size
expr_stmt|;
block|}
name|void
name|Dump
argument_list|(
name|lldb_private
operator|::
name|Stream
operator|&
name|s
argument_list|)
block|{
name|s
operator|.
name|Printf
argument_list|(
literal|"header.magic              = 0x%8.8x\n"
argument_list|,
name|magic
argument_list|)
expr_stmt|;
name|s
operator|.
name|Printf
argument_list|(
literal|"header.version            = 0x%4.4x\n"
argument_list|,
name|version
argument_list|)
expr_stmt|;
name|s
operator|.
name|Printf
argument_list|(
literal|"header.hash_function      = 0x%4.4x\n"
argument_list|,
name|hash_function
argument_list|)
expr_stmt|;
name|s
operator|.
name|Printf
argument_list|(
literal|"header.bucket_count       = 0x%8.8x %u\n"
argument_list|,
name|bucket_count
argument_list|,
name|bucket_count
argument_list|)
expr_stmt|;
name|s
operator|.
name|Printf
argument_list|(
literal|"header.hashes_count       = 0x%8.8x %u\n"
argument_list|,
name|hashes_count
argument_list|,
name|hashes_count
argument_list|)
expr_stmt|;
name|s
operator|.
name|Printf
argument_list|(
literal|"header.header_data_len    = 0x%8.8x %u\n"
argument_list|,
name|header_data_len
argument_list|,
name|header_data_len
argument_list|)
expr_stmt|;
block|}
name|virtual
name|lldb
operator|::
name|offset_t
name|Read
argument_list|(
argument|lldb_private::DataExtractor&data
argument_list|,
argument|lldb::offset_t offset
argument_list|)
block|{
if|if
condition|(
name|data
operator|.
name|ValidOffsetForDataOfSize
argument_list|(
name|offset
argument_list|,
sizeof|sizeof
argument_list|(
name|magic
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|version
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|hash_function
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|bucket_count
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|hashes_count
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|header_data_len
argument_list|)
argument_list|)
condition|)
block|{
name|magic
operator|=
name|data
operator|.
name|GetU32
argument_list|(
operator|&
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|magic
operator|!=
name|HASH_MAGIC
condition|)
block|{
if|if
condition|(
name|magic
operator|==
name|HASH_CIGAM
condition|)
block|{
switch|switch
condition|(
name|data
operator|.
name|GetByteOrder
argument_list|()
condition|)
block|{
case|case
name|lldb
operator|::
name|eByteOrderBig
case|:
name|data
operator|.
name|SetByteOrder
argument_list|(
name|lldb
operator|::
name|eByteOrderLittle
argument_list|)
expr_stmt|;
break|break;
case|case
name|lldb
operator|::
name|eByteOrderLittle
case|:
name|data
operator|.
name|SetByteOrder
argument_list|(
name|lldb
operator|::
name|eByteOrderBig
argument_list|)
expr_stmt|;
break|break;
default|default:
return|return
name|LLDB_INVALID_OFFSET
return|;
block|}
block|}
else|else
block|{
comment|// Magic bytes didn't match
name|version
operator|=
literal|0
expr_stmt|;
return|return
name|LLDB_INVALID_OFFSET
return|;
block|}
block|}
name|version
operator|=
name|data
operator|.
name|GetU16
argument_list|(
operator|&
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|version
operator|!=
literal|1
condition|)
block|{
comment|// Unsupported version
return|return
name|LLDB_INVALID_OFFSET
return|;
block|}
name|hash_function
operator|=
name|data
operator|.
name|GetU16
argument_list|(
operator|&
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|hash_function
operator|==
literal|4
condition|)
name|hash_function
operator|=
literal|0
expr_stmt|;
comment|// Deal with pre-release version of this table...
name|bucket_count
operator|=
name|data
operator|.
name|GetU32
argument_list|(
operator|&
name|offset
argument_list|)
expr_stmt|;
name|hashes_count
operator|=
name|data
operator|.
name|GetU32
argument_list|(
operator|&
name|offset
argument_list|)
expr_stmt|;
name|header_data_len
operator|=
name|data
operator|.
name|GetU32
argument_list|(
operator|&
name|offset
argument_list|)
expr_stmt|;
return|return
name|offset
return|;
block|}
return|return
name|LLDB_INVALID_OFFSET
return|;
block|}
comment|//
comment|//        // Returns a buffer that contains a serialized version of this
comment|//        table
comment|//        // that must be freed with free().
comment|//        virtual void *
comment|//        Write (int fd);
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|__KeyType
operator|,
name|class
name|__HeaderDataType
operator|,
name|class
name|__ValueType
operator|>
name|class
name|ExportTable
block|{
name|public
operator|:
typedef|typedef
name|__HeaderDataType
name|HeaderDataType
typedef|;
end_expr_stmt

begin_typedef
typedef|typedef
name|Header
operator|<
name|HeaderDataType
operator|>
name|HeaderType
expr_stmt|;
end_typedef

begin_typedef
typedef|typedef
name|__KeyType
name|KeyType
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|__ValueType
name|ValueType
typedef|;
end_typedef

begin_struct
struct|struct
name|Entry
block|{
name|uint32_t
name|hash
decl_stmt|;
name|KeyType
name|key
decl_stmt|;
name|ValueType
name|value
decl_stmt|;
block|}
struct|;
end_struct

begin_typedef
typedef|typedef
name|std
operator|::
name|vector
operator|<
name|ValueType
operator|>
name|ValueArrayType
expr_stmt|;
end_typedef

begin_typedef
typedef|typedef
name|std
operator|::
name|map
operator|<
name|KeyType
operator|,
name|ValueArrayType
operator|>
name|HashData
expr_stmt|;
end_typedef

begin_comment
comment|// Map a name hash to one or more name infos
end_comment

begin_typedef
typedef|typedef
name|std
operator|::
name|map
operator|<
name|uint32_t
operator|,
name|HashData
operator|>
name|HashToHashData
expr_stmt|;
end_typedef

begin_decl_stmt
name|virtual
name|KeyType
name|GetKeyForStringType
argument_list|(
specifier|const
name|char
operator|*
name|cstr
argument_list|)
decl|const
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function_decl
name|virtual
name|size_t
name|GetByteSize
parameter_list|(
specifier|const
name|HashData
modifier|&
name|key_to_key_values
parameter_list|)
init|=
literal|0
function_decl|;
end_function_decl

begin_decl_stmt
name|virtual
name|bool
name|WriteHashData
argument_list|(
specifier|const
name|HashData
operator|&
name|hash_data
argument_list|,
name|lldb_private
operator|::
name|Stream
operator|&
name|ostrm
argument_list|)
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|//
end_comment

begin_function
name|void
name|AddEntry
parameter_list|(
specifier|const
name|char
modifier|*
name|cstr
parameter_list|,
specifier|const
name|ValueType
modifier|&
name|value
parameter_list|)
block|{
name|Entry
name|entry
decl_stmt|;
name|entry
operator|.
name|hash
operator|=
name|MappedHash
operator|::
name|HashString
argument_list|(
name|eHashFunctionDJB
argument_list|,
name|cstr
argument_list|)
expr_stmt|;
name|entry
operator|.
name|key
operator|=
name|GetKeyForStringType
argument_list|(
name|cstr
argument_list|)
expr_stmt|;
name|entry
operator|.
name|value
operator|=
name|value
expr_stmt|;
name|m_entries
operator|.
name|push_back
argument_list|(
name|entry
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
name|void
name|Save
argument_list|(
specifier|const
name|HeaderDataType
operator|&
name|header_data
argument_list|,
name|lldb_private
operator|::
name|Stream
operator|&
name|ostrm
argument_list|)
block|{
if|if
condition|(
name|m_entries
operator|.
name|empty
argument_list|()
condition|)
return|return;
specifier|const
name|uint32_t
name|num_entries
init|=
name|m_entries
operator|.
name|size
argument_list|()
decl_stmt|;
name|uint32_t
name|i
init|=
literal|0
decl_stmt|;
name|HeaderType
name|header
decl_stmt|;
name|header
operator|.
name|magic
operator|=
name|HASH_MAGIC
expr_stmt|;
name|header
operator|.
name|version
operator|=
literal|1
expr_stmt|;
name|header
operator|.
name|hash_function
operator|=
name|eHashFunctionDJB
expr_stmt|;
name|header
operator|.
name|bucket_count
operator|=
literal|0
expr_stmt|;
name|header
operator|.
name|hashes_count
operator|=
literal|0
expr_stmt|;
name|header
operator|.
name|prologue_length
operator|=
name|header_data
operator|.
name|GetByteSize
argument_list|()
expr_stmt|;
comment|// We need to figure out the number of unique hashes first before we can
comment|// calculate the number of buckets we want to use.
typedef|typedef
name|std
operator|::
name|vector
operator|<
name|uint32_t
operator|>
name|hash_coll
expr_stmt|;
name|hash_coll
name|unique_hashes
decl_stmt|;
name|unique_hashes
operator|.
name|resize
argument_list|(
name|num_entries
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_entries
condition|;
operator|++
name|i
control|)
name|unique_hashes
index|[
name|i
index|]
operator|=
name|m_entries
index|[
name|i
index|]
operator|.
name|hash
expr_stmt|;
name|std
operator|::
name|sort
argument_list|(
name|unique_hashes
operator|.
name|begin
argument_list|()
argument_list|,
name|unique_hashes
operator|.
name|end
argument_list|()
argument_list|)
expr_stmt|;
name|hash_coll
operator|::
name|iterator
name|pos
operator|=
name|std
operator|::
name|unique
argument_list|(
name|unique_hashes
operator|.
name|begin
argument_list|()
argument_list|,
name|unique_hashes
operator|.
name|end
argument_list|()
argument_list|)
expr_stmt|;
specifier|const
name|size_t
name|num_unique_hashes
init|=
name|std
operator|::
name|distance
argument_list|(
name|unique_hashes
operator|.
name|begin
argument_list|()
argument_list|,
name|pos
argument_list|)
decl_stmt|;
if|if
condition|(
name|num_unique_hashes
operator|>
literal|1024
condition|)
name|header
operator|.
name|bucket_count
operator|=
name|num_unique_hashes
operator|/
literal|4
expr_stmt|;
elseif|else
if|if
condition|(
name|num_unique_hashes
operator|>
literal|16
condition|)
name|header
operator|.
name|bucket_count
operator|=
name|num_unique_hashes
operator|/
literal|2
expr_stmt|;
else|else
name|header
operator|.
name|bucket_count
operator|=
name|num_unique_hashes
expr_stmt|;
if|if
condition|(
name|header
operator|.
name|bucket_count
operator|==
literal|0
condition|)
name|header
operator|.
name|bucket_count
operator|=
literal|1
expr_stmt|;
name|std
operator|::
name|vector
operator|<
name|HashToHashData
operator|>
name|hash_buckets
expr_stmt|;
name|std
operator|::
name|vector
operator|<
name|uint32_t
operator|>
name|hash_indexes
argument_list|(
name|header
operator|.
name|bucket_count
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|std
operator|::
name|vector
operator|<
name|uint32_t
operator|>
name|hash_values
expr_stmt|;
name|std
operator|::
name|vector
operator|<
name|uint32_t
operator|>
name|hash_offsets
expr_stmt|;
name|hash_buckets
operator|.
name|resize
argument_list|(
name|header
operator|.
name|bucket_count
argument_list|)
expr_stmt|;
name|uint32_t
name|bucket_entry_empties
init|=
literal|0
decl_stmt|;
comment|// StreamString hash_file_data(Stream::eBinary,
comment|// dwarf->GetObjectFile()->GetAddressByteSize(),
comment|// dwarf->GetObjectFile()->GetByteSize());
comment|// Push all of the hashes into their buckets and create all bucket
comment|// entries all populated with data.
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_entries
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|uint32_t
name|hash
init|=
name|m_entries
index|[
name|i
index|]
operator|.
name|hash
decl_stmt|;
specifier|const
name|uint32_t
name|bucket_idx
init|=
name|hash
operator|%
name|header
operator|.
name|bucket_count
decl_stmt|;
specifier|const
name|uint32_t
name|strp_offset
init|=
name|m_entries
index|[
name|i
index|]
operator|.
name|str_offset
decl_stmt|;
specifier|const
name|uint32_t
name|die_offset
init|=
name|m_entries
index|[
name|i
index|]
operator|.
name|die_offset
decl_stmt|;
name|hash_buckets
index|[
name|bucket_idx
index|]
index|[
name|hash
index|]
index|[
name|strp_offset
index|]
operator|.
name|push_back
argument_list|(
name|die_offset
argument_list|)
expr_stmt|;
block|}
comment|// Now for each bucket we write the bucket value which is the
comment|// number of hashes and the hash index encoded into a single
comment|// 32 bit unsigned integer.
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|header
operator|.
name|bucket_count
condition|;
operator|++
name|i
control|)
block|{
name|HashToHashData
modifier|&
name|bucket_entry
init|=
name|hash_buckets
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|bucket_entry
operator|.
name|empty
argument_list|()
condition|)
block|{
comment|// Empty bucket
operator|++
name|bucket_entry_empties
expr_stmt|;
name|hash_indexes
index|[
name|i
index|]
operator|=
name|UINT32_MAX
expr_stmt|;
block|}
else|else
block|{
specifier|const
name|uint32_t
name|hash_value_index
init|=
name|hash_values
operator|.
name|size
argument_list|()
decl_stmt|;
name|uint32_t
name|hash_count
init|=
literal|0
decl_stmt|;
name|typename
name|HashToHashData
operator|::
name|const_iterator
name|pos
operator|,
name|end
operator|=
name|bucket_entry
operator|.
name|end
argument_list|()
expr_stmt|;
for|for
control|(
name|pos
operator|=
name|bucket_entry
operator|.
name|begin
argument_list|()
init|;
name|pos
operator|!=
name|end
condition|;
operator|++
name|pos
control|)
block|{
name|hash_values
operator|.
name|push_back
argument_list|(
name|pos
operator|->
name|first
argument_list|)
expr_stmt|;
name|hash_offsets
operator|.
name|push_back
argument_list|(
name|GetByteSize
argument_list|(
name|pos
operator|->
name|second
argument_list|)
argument_list|)
expr_stmt|;
operator|++
name|hash_count
expr_stmt|;
block|}
name|hash_indexes
index|[
name|i
index|]
operator|=
name|hash_value_index
expr_stmt|;
block|}
block|}
name|header
operator|.
name|hashes_count
operator|=
name|hash_values
operator|.
name|size
argument_list|()
expr_stmt|;
comment|// Write the header out now that we have the hash_count
name|header
operator|.
name|Write
argument_list|(
name|ostrm
argument_list|)
expr_stmt|;
comment|// Now for each bucket we write the start index of the hashes
comment|// for the current bucket, or UINT32_MAX if the bucket is empty
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|header
operator|.
name|bucket_count
condition|;
operator|++
name|i
control|)
block|{
name|ostrm
operator|.
name|PutHex32
argument_list|(
name|hash_indexes
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
comment|// Now we need to write out all of the hash values
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|header
operator|.
name|hashes_count
condition|;
operator|++
name|i
control|)
block|{
name|ostrm
operator|.
name|PutHex32
argument_list|(
name|hash_values
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
comment|// Now we need to write out all of the hash data offsets,
comment|// there is an offset for each hash in the hashes array
comment|// that was written out above
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|header
operator|.
name|hashes_count
condition|;
operator|++
name|i
control|)
block|{
name|ostrm
operator|.
name|PutHex32
argument_list|(
name|hash_offsets
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
comment|// Now we write the data for each hash and verify we got the offset
comment|// correct above...
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|header
operator|.
name|bucket_count
condition|;
operator|++
name|i
control|)
block|{
name|HashToHashData
modifier|&
name|bucket_entry
init|=
name|hash_buckets
index|[
name|i
index|]
decl_stmt|;
name|typename
name|HashToHashData
operator|::
name|const_iterator
name|pos
operator|,
name|end
operator|=
name|bucket_entry
operator|.
name|end
argument_list|()
expr_stmt|;
for|for
control|(
name|pos
operator|=
name|bucket_entry
operator|.
name|begin
argument_list|()
init|;
name|pos
operator|!=
name|end
condition|;
operator|++
name|pos
control|)
block|{
if|if
condition|(
operator|!
name|bucket_entry
operator|.
name|empty
argument_list|()
condition|)
block|{
name|WriteHashData
argument_list|(
name|pos
operator|->
name|second
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_decl_stmt

begin_label
name|protected
label|:
end_label

begin_typedef
typedef|typedef
name|std
operator|::
name|vector
operator|<
name|Entry
operator|>
name|collection
expr_stmt|;
end_typedef

begin_decl_stmt
name|collection
name|m_entries
decl_stmt|;
end_decl_stmt

begin_comment
unit|};
comment|// A class for reading and using a saved hash table from a block of data
end_comment

begin_comment
comment|// in memory
end_comment

begin_expr_stmt
name|template
operator|<
name|typename
name|__KeyType
operator|,
name|class
name|__HeaderType
operator|,
name|class
name|__HashData
operator|>
name|class
name|MemoryTable
block|{
name|public
operator|:
typedef|typedef
name|__HeaderType
name|HeaderType
typedef|;
end_expr_stmt

begin_typedef
typedef|typedef
name|__KeyType
name|KeyType
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|__HashData
name|HashData
typedef|;
end_typedef

begin_enum
enum|enum
name|Result
block|{
name|eResultKeyMatch
init|=
literal|0u
block|,
comment|// The entry was found, key matched and "pair" was
comment|// filled in successfully
name|eResultKeyMismatch
init|=
literal|1u
block|,
comment|// Bucket hash data collision, but key didn't match
name|eResultEndOfHashData
init|=
literal|2u
block|,
comment|// The chain of items for this hash data in
comment|// this bucket is terminated, search no more
name|eResultError
init|=
literal|3u
comment|// Error parsing the hash data, abort
block|}
enum|;
end_enum

begin_struct
struct|struct
name|Pair
block|{
name|KeyType
name|key
decl_stmt|;
name|HashData
name|value
decl_stmt|;
block|}
struct|;
end_struct

begin_expr_stmt
name|MemoryTable
argument_list|(
name|lldb_private
operator|::
name|DataExtractor
operator|&
name|data
argument_list|)
operator|:
name|m_header
argument_list|()
operator|,
name|m_hash_indexes
argument_list|(
name|nullptr
argument_list|)
operator|,
name|m_hash_values
argument_list|(
name|nullptr
argument_list|)
operator|,
name|m_hash_offsets
argument_list|(
argument|nullptr
argument_list|)
block|{
name|lldb
operator|::
name|offset_t
name|offset
operator|=
name|m_header
operator|.
name|Read
argument_list|(
name|data
argument_list|,
literal|0
argument_list|)
block|;
if|if
condition|(
name|offset
operator|!=
name|LLDB_INVALID_OFFSET
operator|&&
name|IsValid
argument_list|()
condition|)
block|{
name|m_hash_indexes
operator|=
operator|(
specifier|const
name|uint32_t
operator|*
operator|)
name|data
operator|.
name|GetData
argument_list|(
operator|&
name|offset
argument_list|,
name|m_header
operator|.
name|bucket_count
operator|*
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
argument_list|)
expr_stmt|;
name|m_hash_values
operator|=
operator|(
specifier|const
name|uint32_t
operator|*
operator|)
name|data
operator|.
name|GetData
argument_list|(
operator|&
name|offset
argument_list|,
name|m_header
operator|.
name|hashes_count
operator|*
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
argument_list|)
expr_stmt|;
name|m_hash_offsets
operator|=
operator|(
specifier|const
name|uint32_t
operator|*
operator|)
name|data
operator|.
name|GetData
argument_list|(
operator|&
name|offset
argument_list|,
name|m_header
operator|.
name|hashes_count
operator|*
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_expr_stmt

begin_expr_stmt
unit|}      virtual
operator|~
name|MemoryTable
argument_list|()
operator|=
expr|default
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|bool
name|IsValid
argument_list|()
specifier|const
block|{
return|return
name|m_header
operator|.
name|version
operator|==
literal|1
operator|&&
name|m_header
operator|.
name|hash_function
operator|==
name|eHashFunctionDJB
operator|&&
name|m_header
operator|.
name|bucket_count
operator|>
literal|0
return|;
block|}
end_expr_stmt

begin_decl_stmt
name|uint32_t
name|GetHashIndex
argument_list|(
name|uint32_t
name|bucket_idx
argument_list|)
decl|const
block|{
if|if
condition|(
name|m_hash_indexes
operator|&&
name|bucket_idx
operator|<
name|m_header
operator|.
name|bucket_count
condition|)
return|return
name|m_hash_indexes
index|[
name|bucket_idx
index|]
return|;
return|return
name|UINT32_MAX
return|;
block|}
end_decl_stmt

begin_decl_stmt
name|uint32_t
name|GetHashValue
argument_list|(
name|uint32_t
name|hash_idx
argument_list|)
decl|const
block|{
if|if
condition|(
name|m_hash_values
operator|&&
name|hash_idx
operator|<
name|m_header
operator|.
name|hashes_count
condition|)
return|return
name|m_hash_values
index|[
name|hash_idx
index|]
return|;
return|return
name|UINT32_MAX
return|;
block|}
end_decl_stmt

begin_decl_stmt
name|uint32_t
name|GetHashDataOffset
argument_list|(
name|uint32_t
name|hash_idx
argument_list|)
decl|const
block|{
if|if
condition|(
name|m_hash_offsets
operator|&&
name|hash_idx
operator|<
name|m_header
operator|.
name|hashes_count
condition|)
return|return
name|m_hash_offsets
index|[
name|hash_idx
index|]
return|;
return|return
name|UINT32_MAX
return|;
block|}
end_decl_stmt

begin_decl_stmt
name|bool
name|Find
argument_list|(
specifier|const
name|char
operator|*
name|name
argument_list|,
name|Pair
operator|&
name|pair
argument_list|)
decl|const
block|{
if|if
condition|(
operator|!
name|name
operator|||
operator|!
name|name
index|[
literal|0
index|]
condition|)
return|return
name|false
return|;
if|if
condition|(
name|IsValid
argument_list|()
condition|)
block|{
specifier|const
name|uint32_t
name|bucket_count
init|=
name|m_header
operator|.
name|bucket_count
decl_stmt|;
specifier|const
name|uint32_t
name|hash_count
init|=
name|m_header
operator|.
name|hashes_count
decl_stmt|;
specifier|const
name|uint32_t
name|hash_value
init|=
name|MappedHash
operator|::
name|HashString
argument_list|(
name|m_header
operator|.
name|hash_function
argument_list|,
name|name
argument_list|)
decl_stmt|;
specifier|const
name|uint32_t
name|bucket_idx
init|=
name|hash_value
operator|%
name|bucket_count
decl_stmt|;
name|uint32_t
name|hash_idx
init|=
name|GetHashIndex
argument_list|(
name|bucket_idx
argument_list|)
decl_stmt|;
if|if
condition|(
name|hash_idx
operator|<
name|hash_count
condition|)
block|{
for|for
control|(
init|;
name|hash_idx
operator|<
name|hash_count
condition|;
operator|++
name|hash_idx
control|)
block|{
specifier|const
name|uint32_t
name|curr_hash_value
init|=
name|GetHashValue
argument_list|(
name|hash_idx
argument_list|)
decl_stmt|;
if|if
condition|(
name|curr_hash_value
operator|==
name|hash_value
condition|)
block|{
name|lldb
operator|::
name|offset_t
name|hash_data_offset
operator|=
name|GetHashDataOffset
argument_list|(
name|hash_idx
argument_list|)
expr_stmt|;
while|while
condition|(
name|hash_data_offset
operator|!=
name|UINT32_MAX
condition|)
block|{
specifier|const
name|lldb
operator|::
name|offset_t
name|prev_hash_data_offset
operator|=
name|hash_data_offset
expr_stmt|;
name|Result
name|hash_result
init|=
name|GetHashDataForName
argument_list|(
name|name
argument_list|,
operator|&
name|hash_data_offset
argument_list|,
name|pair
argument_list|)
decl_stmt|;
comment|// Check the result of getting our hash data
switch|switch
condition|(
name|hash_result
condition|)
block|{
case|case
name|eResultKeyMatch
case|:
return|return
name|true
return|;
case|case
name|eResultKeyMismatch
case|:
if|if
condition|(
name|prev_hash_data_offset
operator|==
name|hash_data_offset
condition|)
return|return
name|false
return|;
break|break;
case|case
name|eResultEndOfHashData
case|:
comment|// The last HashData for this key has been reached, stop
comment|// searching
return|return
name|false
return|;
case|case
name|eResultError
case|:
comment|// Error parsing the hash data, abort
return|return
name|false
return|;
block|}
block|}
block|}
if|if
condition|(
operator|(
name|curr_hash_value
operator|%
name|bucket_count
operator|)
operator|!=
name|bucket_idx
condition|)
break|break;
block|}
block|}
block|}
return|return
name|false
return|;
block|}
end_decl_stmt

begin_comment
comment|// This method must be implemented in any subclasses.
end_comment

begin_comment
comment|// The KeyType is user specified and must somehow result in a string
end_comment

begin_comment
comment|// value. For example, the KeyType might be a string offset in a string
end_comment

begin_comment
comment|// table and subclasses can store their string table as a member of the
end_comment

begin_comment
comment|// subclass and return a valie "const char *" given a "key". The value
end_comment

begin_comment
comment|// could also be a C string pointer, in which case just returning "key"
end_comment

begin_comment
comment|// will suffice.
end_comment

begin_decl_stmt
name|virtual
specifier|const
name|char
modifier|*
name|GetStringForKeyType
argument_list|(
name|KeyType
name|key
argument_list|)
decl|const
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|virtual
name|bool
name|ReadHashData
argument_list|(
name|uint32_t
name|hash_data_offset
argument_list|,
name|HashData
operator|&
name|hash_data
argument_list|)
decl|const
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|// This method must be implemented in any subclasses and it must try to
end_comment

begin_comment
comment|// read one "Pair" at the offset pointed to by the "hash_data_offset_ptr"
end_comment

begin_comment
comment|// parameter. This offset should be updated as bytes are consumed and
end_comment

begin_comment
comment|// a value "Result" enum should be returned. If the "name" matches the
end_comment

begin_comment
comment|// full name for the "pair.key" (which must be filled in by this call),
end_comment

begin_comment
comment|// then the HashData in the pair ("pair.value") should be extracted and
end_comment

begin_comment
comment|// filled in and "eResultKeyMatch" should be returned. If "name" doesn't
end_comment

begin_comment
comment|// match this string for the key, then "eResultKeyMismatch" should be
end_comment

begin_comment
comment|// returned and all data for the current HashData must be consumed or
end_comment

begin_comment
comment|// skipped and the "hash_data_offset_ptr" offset needs to be updated to
end_comment

begin_comment
comment|// point to the next HashData. If the end of the HashData objects for
end_comment

begin_comment
comment|// a given hash value have been reached, then "eResultEndOfHashData"
end_comment

begin_comment
comment|// should be returned. If anything else goes wrong during parsing,
end_comment

begin_comment
comment|// return "eResultError" and the corresponding "Find()" function will
end_comment

begin_comment
comment|// be canceled and return false.
end_comment

begin_decl_stmt
name|virtual
name|Result
name|GetHashDataForName
argument_list|(
specifier|const
name|char
operator|*
name|name
argument_list|,
name|lldb
operator|::
name|offset_t
operator|*
name|hash_data_offset_ptr
argument_list|,
name|Pair
operator|&
name|pair
argument_list|)
decl|const
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
specifier|const
name|HeaderType
modifier|&
name|GetHeader
parameter_list|()
block|{
return|return
name|m_header
return|;
block|}
end_function

begin_decl_stmt
name|void
name|ForEach
argument_list|(
name|std
operator|::
name|function
operator|<
name|bool
argument_list|(
specifier|const
name|HashData
operator|&
name|hash_data
argument_list|)
operator|>
specifier|const
operator|&
name|callback
argument_list|)
decl|const
block|{
specifier|const
name|size_t
name|num_hash_offsets
init|=
name|m_header
operator|.
name|hashes_count
decl_stmt|;
for|for
control|(
name|size_t
name|i
init|=
literal|0
init|;
name|i
operator|<
name|num_hash_offsets
condition|;
operator|++
name|i
control|)
block|{
name|uint32_t
name|hash_data_offset
init|=
name|GetHashDataOffset
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|hash_data_offset
operator|!=
name|UINT32_MAX
condition|)
block|{
name|HashData
name|hash_data
decl_stmt|;
if|if
condition|(
name|ReadHashData
argument_list|(
name|hash_data_offset
argument_list|,
name|hash_data
argument_list|)
condition|)
block|{
comment|// If the callback returns false, then we are done and should stop
if|if
condition|(
name|callback
argument_list|(
name|hash_data
argument_list|)
operator|==
name|false
condition|)
return|return;
block|}
block|}
block|}
block|}
end_decl_stmt

begin_label
name|protected
label|:
end_label

begin_comment
comment|// Implementation agnostic information
end_comment

begin_decl_stmt
name|HeaderType
name|m_header
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|uint32_t
modifier|*
name|m_hash_indexes
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|uint32_t
modifier|*
name|m_hash_values
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|uint32_t
modifier|*
name|m_hash_offsets
decl_stmt|;
end_decl_stmt

begin_endif
unit|}; };
endif|#
directive|endif
end_endif

begin_comment
comment|// liblldb_MappedHash_h_
end_comment

end_unit

