begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===-- Disassembler.h ------------------------------------------*- C++ -*-===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|liblldb_Disassembler_h_
end_ifndef

begin_define
define|#
directive|define
name|liblldb_Disassembler_h_
end_define

begin_include
include|#
directive|include
file|"lldb/Core/Address.h"
end_include

begin_include
include|#
directive|include
file|"lldb/Core/ArchSpec.h"
end_include

begin_include
include|#
directive|include
file|"lldb/Core/EmulateInstruction.h"
end_include

begin_include
include|#
directive|include
file|"lldb/Core/FormatEntity.h"
end_include

begin_comment
comment|// for FormatEntity
end_comment

begin_include
include|#
directive|include
file|"lldb/Core/Opcode.h"
end_include

begin_include
include|#
directive|include
file|"lldb/Core/PluginInterface.h"
end_include

begin_include
include|#
directive|include
file|"lldb/Interpreter/OptionValue.h"
end_include

begin_include
include|#
directive|include
file|"lldb/Symbol/LineEntry.h"
end_include

begin_include
include|#
directive|include
file|"lldb/Target/ExecutionContext.h"
end_include

begin_comment
comment|// for ExecutionContext
end_comment

begin_include
include|#
directive|include
file|"lldb/Utility/ConstString.h"
end_include

begin_comment
comment|// for ConstString
end_comment

begin_include
include|#
directive|include
file|"lldb/Utility/FileSpec.h"
end_include

begin_include
include|#
directive|include
file|"lldb/lldb-defines.h"
end_include

begin_comment
comment|// for DISALLOW_COPY_AND_ASSIGN
end_comment

begin_include
include|#
directive|include
file|"lldb/lldb-enumerations.h"
end_include

begin_comment
comment|// for AddressClass, AddressClass...
end_comment

begin_include
include|#
directive|include
file|"lldb/lldb-forward.h"
end_include

begin_comment
comment|// for InstructionSP, DisassemblerSP
end_comment

begin_include
include|#
directive|include
file|"lldb/lldb-types.h"
end_include

begin_comment
comment|// for addr_t, offset_t
end_comment

begin_include
include|#
directive|include
file|"llvm/ADT/StringRef.h"
end_include

begin_comment
comment|// for StringRef
end_comment

begin_include
include|#
directive|include
file|<functional>
end_include

begin_comment
comment|// for function
end_comment

begin_include
include|#
directive|include
file|<map>
end_include

begin_include
include|#
directive|include
file|<memory>
end_include

begin_comment
comment|// for enable_shared_from_this
end_comment

begin_include
include|#
directive|include
file|<set>
end_include

begin_include
include|#
directive|include
file|<string>
end_include

begin_include
include|#
directive|include
file|<vector>
end_include

begin_include
include|#
directive|include
file|<stddef.h>
end_include

begin_comment
comment|// for size_t
end_comment

begin_include
include|#
directive|include
file|<stdint.h>
end_include

begin_comment
comment|// for uint32_t, int64_t
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_comment
comment|// for FILE
end_comment

begin_decl_stmt
name|namespace
name|lldb_private
block|{
name|class
name|AddressRange
decl_stmt|;
block|}
end_decl_stmt

begin_decl_stmt
name|namespace
name|lldb_private
block|{
name|class
name|DataExtractor
decl_stmt|;
block|}
end_decl_stmt

begin_decl_stmt
name|namespace
name|lldb_private
block|{
name|class
name|Debugger
decl_stmt|;
block|}
end_decl_stmt

begin_decl_stmt
name|namespace
name|lldb_private
block|{
name|class
name|Disassembler
decl_stmt|;
block|}
end_decl_stmt

begin_decl_stmt
name|namespace
name|lldb_private
block|{
name|class
name|Module
decl_stmt|;
block|}
end_decl_stmt

begin_decl_stmt
name|namespace
name|lldb_private
block|{
name|class
name|Stream
decl_stmt|;
block|}
end_decl_stmt

begin_decl_stmt
name|namespace
name|lldb_private
block|{
name|class
name|SymbolContext
decl_stmt|;
block|}
end_decl_stmt

begin_decl_stmt
name|namespace
name|lldb_private
block|{
name|class
name|SymbolContextList
decl_stmt|;
block|}
end_decl_stmt

begin_decl_stmt
name|namespace
name|lldb_private
block|{
name|class
name|Target
decl_stmt|;
block|}
end_decl_stmt

begin_decl_stmt
name|namespace
name|lldb_private
block|{
struct_decl|struct
name|RegisterInfo
struct_decl|;
block|}
end_decl_stmt

begin_decl_stmt
name|namespace
name|llvm
block|{
name|template
operator|<
name|typename
name|T
operator|>
name|class
name|SmallVectorImpl
expr_stmt|;
block|}
end_decl_stmt

begin_decl_stmt
name|namespace
name|lldb_private
block|{
name|class
name|Instruction
block|{
name|public
label|:
name|Instruction
argument_list|(
argument|const Address&address
argument_list|,
argument|lldb::AddressClass addr_class = lldb::eAddressClassInvalid
argument_list|)
empty_stmt|;
name|virtual
operator|~
name|Instruction
argument_list|()
expr_stmt|;
specifier|const
name|Address
operator|&
name|GetAddress
argument_list|()
specifier|const
block|{
return|return
name|m_address
return|;
block|}
specifier|const
name|char
modifier|*
name|GetMnemonic
parameter_list|(
specifier|const
name|ExecutionContext
modifier|*
name|exe_ctx
parameter_list|)
block|{
name|CalculateMnemonicOperandsAndCommentIfNeeded
argument_list|(
name|exe_ctx
argument_list|)
expr_stmt|;
return|return
name|m_opcode_name
operator|.
name|c_str
argument_list|()
return|;
block|}
specifier|const
name|char
modifier|*
name|GetOperands
parameter_list|(
specifier|const
name|ExecutionContext
modifier|*
name|exe_ctx
parameter_list|)
block|{
name|CalculateMnemonicOperandsAndCommentIfNeeded
argument_list|(
name|exe_ctx
argument_list|)
expr_stmt|;
return|return
name|m_mnemonics
operator|.
name|c_str
argument_list|()
return|;
block|}
specifier|const
name|char
modifier|*
name|GetComment
parameter_list|(
specifier|const
name|ExecutionContext
modifier|*
name|exe_ctx
parameter_list|)
block|{
name|CalculateMnemonicOperandsAndCommentIfNeeded
argument_list|(
name|exe_ctx
argument_list|)
expr_stmt|;
return|return
name|m_comment
operator|.
name|c_str
argument_list|()
return|;
block|}
name|virtual
name|void
name|CalculateMnemonicOperandsAndComment
parameter_list|(
specifier|const
name|ExecutionContext
modifier|*
name|exe_ctx
parameter_list|)
init|=
literal|0
function_decl|;
name|lldb
operator|::
name|AddressClass
name|GetAddressClass
argument_list|()
expr_stmt|;
name|void
name|SetAddress
parameter_list|(
specifier|const
name|Address
modifier|&
name|addr
parameter_list|)
block|{
comment|// Invalidate the address class to lazily discover
comment|// it if we need to.
name|m_address_class
operator|=
name|lldb
operator|::
name|eAddressClassInvalid
expr_stmt|;
name|m_address
operator|=
name|addr
expr_stmt|;
block|}
comment|//------------------------------------------------------------------
comment|/// Dump the text representation of this Instruction to a Stream
comment|///
comment|/// Print the (optional) address, (optional) bytes, opcode,
comment|/// operands, and instruction comments to a stream.
comment|///
comment|/// @param[in] s
comment|///     The Stream to add the text to.
comment|///
comment|/// @param[in] show_address
comment|///     Whether the address (using disassembly_addr_format_spec formatting)
comment|///     should be printed.
comment|///
comment|/// @param[in] show_bytes
comment|///     Whether the bytes of the assembly instruction should be printed.
comment|///
comment|/// @param[in] max_opcode_byte_size
comment|///     The size (in bytes) of the largest instruction in the list that
comment|///     we are printing (for text justification/alignment purposes)
comment|///     Only needed if show_bytes is true.
comment|///
comment|/// @param[in] exe_ctx
comment|///     The current execution context, if available.  May be used in
comment|///     the assembling of the operands+comments for this instruction.
comment|///     Pass NULL if not applicable.
comment|///
comment|/// @param[in] sym_ctx
comment|///     The SymbolContext for this instruction.
comment|///     Pass NULL if not available/computed.
comment|///     Only needed if show_address is true.
comment|///
comment|/// @param[in] prev_sym_ctx
comment|///     The SymbolContext for the previous instruction.  Depending on
comment|///     the disassembly address format specification, a change in
comment|///     Symbol / Function may mean that a line is printed with the new
comment|///     symbol/function name.
comment|///     Pass NULL if unavailable, or if this is the first instruction of
comment|///     the InstructionList.
comment|///     Only needed if show_address is true.
comment|///
comment|/// @param[in] disassembly_addr_format
comment|///     The format specification for how addresses are printed.
comment|///     Only needed if show_address is true.
comment|///
comment|/// @param[in] max_address_text_size
comment|///     The length of the longest address string at the start of the
comment|///     disassembly line that will be printed (the
comment|///     Debugger::FormatDisassemblerAddress() string)
comment|///     so this method can properly align the instruction opcodes.
comment|///     May be 0 to indicate no indentation/alignment of the opcodes.
comment|//------------------------------------------------------------------
name|virtual
name|void
name|Dump
argument_list|(
name|Stream
operator|*
name|s
argument_list|,
name|uint32_t
name|max_opcode_byte_size
argument_list|,
name|bool
name|show_address
argument_list|,
name|bool
name|show_bytes
argument_list|,
specifier|const
name|ExecutionContext
operator|*
name|exe_ctx
argument_list|,
specifier|const
name|SymbolContext
operator|*
name|sym_ctx
argument_list|,
specifier|const
name|SymbolContext
operator|*
name|prev_sym_ctx
argument_list|,
specifier|const
name|FormatEntity
operator|::
name|Entry
operator|*
name|disassembly_addr_format
argument_list|,
name|size_t
name|max_address_text_size
argument_list|)
decl_stmt|;
name|virtual
name|bool
name|DoesBranch
parameter_list|()
init|=
literal|0
function_decl|;
name|virtual
name|bool
name|HasDelaySlot
parameter_list|()
function_decl|;
name|virtual
name|size_t
name|Decode
argument_list|(
specifier|const
name|Disassembler
operator|&
name|disassembler
argument_list|,
specifier|const
name|DataExtractor
operator|&
name|data
argument_list|,
name|lldb
operator|::
name|offset_t
name|data_offset
argument_list|)
init|=
literal|0
decl_stmt|;
name|virtual
name|void
name|SetDescription
argument_list|(
name|llvm
operator|::
name|StringRef
argument_list|)
block|{   }
comment|// May be overridden in sub-classes that have descriptions.
name|lldb
operator|::
name|OptionValueSP
name|ReadArray
argument_list|(
argument|FILE *in_file
argument_list|,
argument|Stream *out_stream
argument_list|,
argument|OptionValue::Type data_type
argument_list|)
expr_stmt|;
name|lldb
operator|::
name|OptionValueSP
name|ReadDictionary
argument_list|(
name|FILE
operator|*
name|in_file
argument_list|,
name|Stream
operator|*
name|out_stream
argument_list|)
expr_stmt|;
name|bool
name|DumpEmulation
parameter_list|(
specifier|const
name|ArchSpec
modifier|&
name|arch
parameter_list|)
function_decl|;
name|virtual
name|bool
name|TestEmulation
parameter_list|(
name|Stream
modifier|*
name|stream
parameter_list|,
specifier|const
name|char
modifier|*
name|test_file_name
parameter_list|)
function_decl|;
name|bool
name|Emulate
argument_list|(
specifier|const
name|ArchSpec
operator|&
name|arch
argument_list|,
name|uint32_t
name|evaluate_options
argument_list|,
name|void
operator|*
name|baton
argument_list|,
name|EmulateInstruction
operator|::
name|ReadMemoryCallback
name|read_mem_callback
argument_list|,
name|EmulateInstruction
operator|::
name|WriteMemoryCallback
name|write_mem_calback
argument_list|,
name|EmulateInstruction
operator|::
name|ReadRegisterCallback
name|read_reg_callback
argument_list|,
name|EmulateInstruction
operator|::
name|WriteRegisterCallback
name|write_reg_callback
argument_list|)
decl_stmt|;
specifier|const
name|Opcode
operator|&
name|GetOpcode
argument_list|()
specifier|const
block|{
return|return
name|m_opcode
return|;
block|}
name|uint32_t
name|GetData
parameter_list|(
name|DataExtractor
modifier|&
name|data
parameter_list|)
function_decl|;
struct|struct
name|Operand
block|{
name|enum
name|class
name|Type
block|{
name|Invalid
operator|=
literal|0
operator|,
name|Register
operator|,
name|Immediate
operator|,
name|Dereference
operator|,
name|Sum
operator|,
name|Product
block|}
name|m_type
operator|=
name|Type
operator|::
name|Invalid
expr_stmt|;
name|std
operator|::
name|vector
operator|<
name|Operand
operator|>
name|m_children
expr_stmt|;
name|lldb
operator|::
name|addr_t
name|m_immediate
operator|=
literal|0
expr_stmt|;
name|ConstString
name|m_register
decl_stmt|;
name|bool
name|m_negative
init|=
name|false
decl_stmt|;
name|bool
name|m_clobbered
init|=
name|false
decl_stmt|;
name|bool
name|IsValid
parameter_list|()
block|{
return|return
name|m_type
operator|!=
name|Type
operator|::
name|Invalid
return|;
block|}
specifier|static
name|Operand
name|BuildRegister
parameter_list|(
name|ConstString
modifier|&
name|r
parameter_list|)
function_decl|;
specifier|static
name|Operand
name|BuildImmediate
argument_list|(
name|lldb
operator|::
name|addr_t
name|imm
argument_list|,
name|bool
name|neg
argument_list|)
decl_stmt|;
specifier|static
name|Operand
name|BuildImmediate
parameter_list|(
name|int64_t
name|imm
parameter_list|)
function_decl|;
specifier|static
name|Operand
name|BuildDereference
parameter_list|(
specifier|const
name|Operand
modifier|&
name|ref
parameter_list|)
function_decl|;
specifier|static
name|Operand
name|BuildSum
parameter_list|(
specifier|const
name|Operand
modifier|&
name|lhs
parameter_list|,
specifier|const
name|Operand
modifier|&
name|rhs
parameter_list|)
function_decl|;
specifier|static
name|Operand
name|BuildProduct
parameter_list|(
specifier|const
name|Operand
modifier|&
name|lhs
parameter_list|,
specifier|const
name|Operand
modifier|&
name|rhs
parameter_list|)
function_decl|;
block|}
struct|;
name|virtual
name|bool
name|ParseOperands
argument_list|(
name|llvm
operator|::
name|SmallVectorImpl
operator|<
name|Operand
operator|>
operator|&
name|operands
argument_list|)
block|{
return|return
name|false
return|;
block|}
name|virtual
name|bool
name|IsCall
parameter_list|()
block|{
return|return
name|false
return|;
block|}
name|protected
label|:
name|Address
name|m_address
decl_stmt|;
comment|// The section offset address of this instruction
comment|// We include an address class in the Instruction class to
comment|// allow the instruction specify the eAddressClassCodeAlternateISA
comment|// (currently used for thumb), and also to specify data (eAddressClassData).
comment|// The usual value will be eAddressClassCode, but often when
comment|// disassembling memory, you might run into data. This can
comment|// help us to disassemble appropriately.
name|private
label|:
name|lldb
operator|::
name|AddressClass
name|m_address_class
expr_stmt|;
comment|// Use GetAddressClass () accessor function!
name|protected
label|:
name|Opcode
name|m_opcode
decl_stmt|;
comment|// The opcode for this instruction
name|std
operator|::
name|string
name|m_opcode_name
expr_stmt|;
name|std
operator|::
name|string
name|m_mnemonics
expr_stmt|;
name|std
operator|::
name|string
name|m_comment
expr_stmt|;
name|bool
name|m_calculated_strings
decl_stmt|;
name|void
name|CalculateMnemonicOperandsAndCommentIfNeeded
parameter_list|(
specifier|const
name|ExecutionContext
modifier|*
name|exe_ctx
parameter_list|)
block|{
if|if
condition|(
operator|!
name|m_calculated_strings
condition|)
block|{
name|m_calculated_strings
operator|=
name|true
expr_stmt|;
name|CalculateMnemonicOperandsAndComment
argument_list|(
name|exe_ctx
argument_list|)
expr_stmt|;
block|}
block|}
block|}
empty_stmt|;
name|namespace
name|OperandMatchers
block|{
name|std
operator|::
name|function
operator|<
name|bool
argument_list|(
specifier|const
name|Instruction
operator|::
name|Operand
operator|&
argument_list|)
operator|>
name|MatchBinaryOp
argument_list|(
name|std
operator|::
name|function
operator|<
name|bool
argument_list|(
specifier|const
name|Instruction
operator|::
name|Operand
operator|&
argument_list|)
operator|>
name|base
argument_list|,
name|std
operator|::
name|function
operator|<
name|bool
argument_list|(
specifier|const
name|Instruction
operator|::
name|Operand
operator|&
argument_list|)
operator|>
name|left
argument_list|,
name|std
operator|::
name|function
operator|<
name|bool
argument_list|(
specifier|const
name|Instruction
operator|::
name|Operand
operator|&
argument_list|)
operator|>
name|right
argument_list|)
expr_stmt|;
name|std
operator|::
name|function
operator|<
name|bool
argument_list|(
specifier|const
name|Instruction
operator|::
name|Operand
operator|&
argument_list|)
operator|>
name|MatchUnaryOp
argument_list|(
name|std
operator|::
name|function
operator|<
name|bool
argument_list|(
specifier|const
name|Instruction
operator|::
name|Operand
operator|&
argument_list|)
operator|>
name|base
argument_list|,
name|std
operator|::
name|function
operator|<
name|bool
argument_list|(
specifier|const
name|Instruction
operator|::
name|Operand
operator|&
argument_list|)
operator|>
name|child
argument_list|)
expr_stmt|;
name|std
operator|::
name|function
operator|<
name|bool
argument_list|(
specifier|const
name|Instruction
operator|::
name|Operand
operator|&
argument_list|)
operator|>
name|MatchRegOp
argument_list|(
specifier|const
name|RegisterInfo
operator|&
name|info
argument_list|)
expr_stmt|;
name|std
operator|::
name|function
operator|<
name|bool
argument_list|(
specifier|const
name|Instruction
operator|::
name|Operand
operator|&
argument_list|)
operator|>
name|FetchRegOp
argument_list|(
name|ConstString
operator|&
name|reg
argument_list|)
expr_stmt|;
name|std
operator|::
name|function
operator|<
name|bool
argument_list|(
specifier|const
name|Instruction
operator|::
name|Operand
operator|&
argument_list|)
operator|>
name|MatchImmOp
argument_list|(
argument|int64_t imm
argument_list|)
expr_stmt|;
name|std
operator|::
name|function
operator|<
name|bool
argument_list|(
specifier|const
name|Instruction
operator|::
name|Operand
operator|&
argument_list|)
operator|>
name|FetchImmOp
argument_list|(
name|int64_t
operator|&
name|imm
argument_list|)
expr_stmt|;
name|std
operator|::
name|function
operator|<
name|bool
argument_list|(
specifier|const
name|Instruction
operator|::
name|Operand
operator|&
argument_list|)
operator|>
name|MatchOpType
argument_list|(
argument|Instruction::Operand::Type type
argument_list|)
expr_stmt|;
block|}
name|class
name|InstructionList
block|{
name|public
label|:
name|InstructionList
argument_list|()
expr_stmt|;
operator|~
name|InstructionList
argument_list|()
expr_stmt|;
name|size_t
name|GetSize
argument_list|()
specifier|const
expr_stmt|;
name|uint32_t
name|GetMaxOpcocdeByteSize
argument_list|()
specifier|const
expr_stmt|;
name|lldb
operator|::
name|InstructionSP
name|GetInstructionAtIndex
argument_list|(
argument|size_t idx
argument_list|)
specifier|const
expr_stmt|;
name|uint32_t
name|GetIndexOfNextBranchInstruction
argument_list|(
name|uint32_t
name|start
argument_list|,
name|Target
operator|&
name|target
argument_list|)
decl|const
decl_stmt|;
name|uint32_t
name|GetIndexOfInstructionAtLoadAddress
argument_list|(
name|lldb
operator|::
name|addr_t
name|load_addr
argument_list|,
name|Target
operator|&
name|target
argument_list|)
decl_stmt|;
name|uint32_t
name|GetIndexOfInstructionAtAddress
parameter_list|(
specifier|const
name|Address
modifier|&
name|addr
parameter_list|)
function_decl|;
name|void
name|Clear
parameter_list|()
function_decl|;
name|void
name|Append
argument_list|(
name|lldb
operator|::
name|InstructionSP
operator|&
name|inst_sp
argument_list|)
decl_stmt|;
name|void
name|Dump
parameter_list|(
name|Stream
modifier|*
name|s
parameter_list|,
name|bool
name|show_address
parameter_list|,
name|bool
name|show_bytes
parameter_list|,
specifier|const
name|ExecutionContext
modifier|*
name|exe_ctx
parameter_list|)
function_decl|;
name|private
label|:
typedef|typedef
name|std
operator|::
name|vector
operator|<
name|lldb
operator|::
name|InstructionSP
operator|>
name|collection
expr_stmt|;
typedef|typedef
name|collection
operator|::
name|iterator
name|iterator
expr_stmt|;
typedef|typedef
name|collection
operator|::
name|const_iterator
name|const_iterator
expr_stmt|;
name|collection
name|m_instructions
decl_stmt|;
block|}
empty_stmt|;
name|class
name|PseudoInstruction
range|:
name|public
name|Instruction
block|{
name|public
operator|:
name|PseudoInstruction
argument_list|()
block|;
operator|~
name|PseudoInstruction
argument_list|()
name|override
block|;
name|bool
name|DoesBranch
argument_list|()
name|override
block|;
name|bool
name|HasDelaySlot
argument_list|()
name|override
block|;
name|void
name|CalculateMnemonicOperandsAndComment
argument_list|(
argument|const ExecutionContext *exe_ctx
argument_list|)
name|override
block|{
comment|// TODO: fill this in and put opcode name into Instruction::m_opcode_name,
comment|// mnemonic into Instruction::m_mnemonics, and any comment into
comment|// Instruction::m_comment
block|}
name|size_t
name|Decode
argument_list|(
argument|const Disassembler&disassembler
argument_list|,
argument|const DataExtractor&data
argument_list|,
argument|lldb::offset_t data_offset
argument_list|)
name|override
block|;
name|void
name|SetOpcode
argument_list|(
argument|size_t opcode_size
argument_list|,
argument|void *opcode_data
argument_list|)
block|;
name|void
name|SetDescription
argument_list|(
argument|llvm::StringRef description
argument_list|)
name|override
block|;
name|protected
operator|:
name|std
operator|::
name|string
name|m_description
block|;
name|DISALLOW_COPY_AND_ASSIGN
argument_list|(
name|PseudoInstruction
argument_list|)
block|; }
decl_stmt|;
name|class
name|Disassembler
range|:
name|public
name|std
operator|::
name|enable_shared_from_this
operator|<
name|Disassembler
operator|>
decl_stmt|,
name|public
name|PluginInterface
block|{
name|public
label|:
enum|enum
block|{
name|eOptionNone
init|=
literal|0u
block|,
name|eOptionShowBytes
init|=
operator|(
literal|1u
operator|<<
literal|0
operator|)
block|,
name|eOptionRawOuput
init|=
operator|(
literal|1u
operator|<<
literal|1
operator|)
block|,
name|eOptionMarkPCSourceLine
init|=
operator|(
literal|1u
operator|<<
literal|2
operator|)
block|,
comment|// Mark the source line that contains
comment|// the current PC (mixed mode only)
name|eOptionMarkPCAddress
init|=
operator|(
literal|1u
operator|<<
literal|3
operator|)
comment|// Mark the disassembly line the contains the PC
block|}
enum|;
enum|enum
name|HexImmediateStyle
block|{
name|eHexStyleC
block|,
name|eHexStyleAsm
block|,   }
enum|;
comment|// FindPlugin should be lax about the flavor string (it is too annoying to
comment|// have various internal uses of the
comment|// disassembler fail because the global flavor string gets set wrong.
comment|// Instead, if you get a flavor string you
comment|// don't understand, use the default.  Folks who care to check can use the
comment|// FlavorValidForArchSpec method on the
comment|// disassembler they got back.
specifier|static
name|lldb
operator|::
name|DisassemblerSP
name|FindPlugin
argument_list|(
specifier|const
name|ArchSpec
operator|&
name|arch
argument_list|,
specifier|const
name|char
operator|*
name|flavor
argument_list|,
specifier|const
name|char
operator|*
name|plugin_name
argument_list|)
expr_stmt|;
comment|// This version will use the value in the Target settings if flavor is NULL;
specifier|static
name|lldb
operator|::
name|DisassemblerSP
name|FindPluginForTarget
argument_list|(
argument|const lldb::TargetSP target_sp
argument_list|,
argument|const ArchSpec&arch
argument_list|,
argument|const char *flavor
argument_list|,
argument|const char *plugin_name
argument_list|)
expr_stmt|;
specifier|static
name|lldb
operator|::
name|DisassemblerSP
name|DisassembleRange
argument_list|(
argument|const ArchSpec&arch
argument_list|,
argument|const char *plugin_name
argument_list|,
argument|const char *flavor
argument_list|,
argument|const ExecutionContext&exe_ctx
argument_list|,
argument|const AddressRange&disasm_range
argument_list|,
argument|bool prefer_file_cache
argument_list|)
expr_stmt|;
specifier|static
name|lldb
operator|::
name|DisassemblerSP
name|DisassembleBytes
argument_list|(
argument|const ArchSpec&arch
argument_list|,
argument|const char *plugin_name
argument_list|,
argument|const char *flavor
argument_list|,
argument|const Address&start
argument_list|,
argument|const void *bytes
argument_list|,
argument|size_t length
argument_list|,
argument|uint32_t max_num_instructions
argument_list|,
argument|bool data_from_file
argument_list|)
expr_stmt|;
specifier|static
name|bool
name|Disassemble
parameter_list|(
name|Debugger
modifier|&
name|debugger
parameter_list|,
specifier|const
name|ArchSpec
modifier|&
name|arch
parameter_list|,
specifier|const
name|char
modifier|*
name|plugin_name
parameter_list|,
specifier|const
name|char
modifier|*
name|flavor
parameter_list|,
specifier|const
name|ExecutionContext
modifier|&
name|exe_ctx
parameter_list|,
specifier|const
name|AddressRange
modifier|&
name|range
parameter_list|,
name|uint32_t
name|num_instructions
parameter_list|,
name|bool
name|mixed_source_and_assembly
parameter_list|,
name|uint32_t
name|num_mixed_context_lines
parameter_list|,
name|uint32_t
name|options
parameter_list|,
name|Stream
modifier|&
name|strm
parameter_list|)
function_decl|;
specifier|static
name|bool
name|Disassemble
parameter_list|(
name|Debugger
modifier|&
name|debugger
parameter_list|,
specifier|const
name|ArchSpec
modifier|&
name|arch
parameter_list|,
specifier|const
name|char
modifier|*
name|plugin_name
parameter_list|,
specifier|const
name|char
modifier|*
name|flavor
parameter_list|,
specifier|const
name|ExecutionContext
modifier|&
name|exe_ctx
parameter_list|,
specifier|const
name|Address
modifier|&
name|start
parameter_list|,
name|uint32_t
name|num_instructions
parameter_list|,
name|bool
name|mixed_source_and_assembly
parameter_list|,
name|uint32_t
name|num_mixed_context_lines
parameter_list|,
name|uint32_t
name|options
parameter_list|,
name|Stream
modifier|&
name|strm
parameter_list|)
function_decl|;
specifier|static
name|size_t
name|Disassemble
parameter_list|(
name|Debugger
modifier|&
name|debugger
parameter_list|,
specifier|const
name|ArchSpec
modifier|&
name|arch
parameter_list|,
specifier|const
name|char
modifier|*
name|plugin_name
parameter_list|,
specifier|const
name|char
modifier|*
name|flavor
parameter_list|,
specifier|const
name|ExecutionContext
modifier|&
name|exe_ctx
parameter_list|,
name|SymbolContextList
modifier|&
name|sc_list
parameter_list|,
name|uint32_t
name|num_instructions
parameter_list|,
name|bool
name|mixed_source_and_assembly
parameter_list|,
name|uint32_t
name|num_mixed_context_lines
parameter_list|,
name|uint32_t
name|options
parameter_list|,
name|Stream
modifier|&
name|strm
parameter_list|)
function_decl|;
specifier|static
name|bool
name|Disassemble
parameter_list|(
name|Debugger
modifier|&
name|debugger
parameter_list|,
specifier|const
name|ArchSpec
modifier|&
name|arch
parameter_list|,
specifier|const
name|char
modifier|*
name|plugin_name
parameter_list|,
specifier|const
name|char
modifier|*
name|flavor
parameter_list|,
specifier|const
name|ExecutionContext
modifier|&
name|exe_ctx
parameter_list|,
specifier|const
name|ConstString
modifier|&
name|name
parameter_list|,
name|Module
modifier|*
name|module
parameter_list|,
name|uint32_t
name|num_instructions
parameter_list|,
name|bool
name|mixed_source_and_assembly
parameter_list|,
name|uint32_t
name|num_mixed_context_lines
parameter_list|,
name|uint32_t
name|options
parameter_list|,
name|Stream
modifier|&
name|strm
parameter_list|)
function_decl|;
specifier|static
name|bool
name|Disassemble
parameter_list|(
name|Debugger
modifier|&
name|debugger
parameter_list|,
specifier|const
name|ArchSpec
modifier|&
name|arch
parameter_list|,
specifier|const
name|char
modifier|*
name|plugin_name
parameter_list|,
specifier|const
name|char
modifier|*
name|flavor
parameter_list|,
specifier|const
name|ExecutionContext
modifier|&
name|exe_ctx
parameter_list|,
name|uint32_t
name|num_instructions
parameter_list|,
name|bool
name|mixed_source_and_assembly
parameter_list|,
name|uint32_t
name|num_mixed_context_lines
parameter_list|,
name|uint32_t
name|options
parameter_list|,
name|Stream
modifier|&
name|strm
parameter_list|)
function_decl|;
comment|//------------------------------------------------------------------
comment|// Constructors and Destructors
comment|//------------------------------------------------------------------
name|Disassembler
argument_list|(
specifier|const
name|ArchSpec
operator|&
name|arch
argument_list|,
specifier|const
name|char
operator|*
name|flavor
argument_list|)
expr_stmt|;
operator|~
name|Disassembler
argument_list|()
name|override
expr_stmt|;
typedef|typedef
specifier|const
name|char
modifier|*
function_decl|(
modifier|*
name|SummaryCallback
function_decl|)
parameter_list|(
specifier|const
name|Instruction
modifier|&
name|inst
parameter_list|,
name|ExecutionContext
modifier|*
name|exe_context
parameter_list|,
name|void
modifier|*
name|user_data
parameter_list|)
function_decl|;
specifier|static
name|bool
name|PrintInstructions
parameter_list|(
name|Disassembler
modifier|*
name|disasm_ptr
parameter_list|,
name|Debugger
modifier|&
name|debugger
parameter_list|,
specifier|const
name|ArchSpec
modifier|&
name|arch
parameter_list|,
specifier|const
name|ExecutionContext
modifier|&
name|exe_ctx
parameter_list|,
name|uint32_t
name|num_instructions
parameter_list|,
name|bool
name|mixed_source_and_assembly
parameter_list|,
name|uint32_t
name|num_mixed_context_lines
parameter_list|,
name|uint32_t
name|options
parameter_list|,
name|Stream
modifier|&
name|strm
parameter_list|)
function_decl|;
name|size_t
name|ParseInstructions
parameter_list|(
specifier|const
name|ExecutionContext
modifier|*
name|exe_ctx
parameter_list|,
specifier|const
name|AddressRange
modifier|&
name|range
parameter_list|,
name|Stream
modifier|*
name|error_strm_ptr
parameter_list|,
name|bool
name|prefer_file_cache
parameter_list|)
function_decl|;
name|size_t
name|ParseInstructions
parameter_list|(
specifier|const
name|ExecutionContext
modifier|*
name|exe_ctx
parameter_list|,
specifier|const
name|Address
modifier|&
name|range
parameter_list|,
name|uint32_t
name|num_instructions
parameter_list|,
name|bool
name|prefer_file_cache
parameter_list|)
function_decl|;
name|virtual
name|size_t
name|DecodeInstructions
argument_list|(
specifier|const
name|Address
operator|&
name|base_addr
argument_list|,
specifier|const
name|DataExtractor
operator|&
name|data
argument_list|,
name|lldb
operator|::
name|offset_t
name|data_offset
argument_list|,
name|size_t
name|num_instructions
argument_list|,
name|bool
name|append
argument_list|,
name|bool
name|data_from_file
argument_list|)
init|=
literal|0
decl_stmt|;
name|InstructionList
modifier|&
name|GetInstructionList
parameter_list|()
function_decl|;
specifier|const
name|InstructionList
operator|&
name|GetInstructionList
argument_list|()
specifier|const
expr_stmt|;
specifier|const
name|ArchSpec
operator|&
name|GetArchitecture
argument_list|()
specifier|const
block|{
return|return
name|m_arch
return|;
block|}
specifier|const
name|char
operator|*
name|GetFlavor
argument_list|()
specifier|const
block|{
return|return
name|m_flavor
operator|.
name|c_str
argument_list|()
return|;
block|}
name|virtual
name|bool
name|FlavorValidForArchSpec
argument_list|(
specifier|const
name|lldb_private
operator|::
name|ArchSpec
operator|&
name|arch
argument_list|,
specifier|const
name|char
operator|*
name|flavor
argument_list|)
init|=
literal|0
decl_stmt|;
name|protected
label|:
comment|// SourceLine and SourceLinesToDisplay structures are only used in
comment|// the mixed source and assembly display methods internal to this class.
struct|struct
name|SourceLine
block|{
name|FileSpec
name|file
decl_stmt|;
name|uint32_t
name|line
decl_stmt|;
name|uint32_t
name|column
decl_stmt|;
name|SourceLine
argument_list|()
operator|:
name|file
argument_list|()
operator|,
name|line
argument_list|(
name|LLDB_INVALID_LINE_NUMBER
argument_list|)
operator|,
name|column
argument_list|(
literal|0
argument_list|)
block|{}
name|bool
name|operator
operator|==
operator|(
specifier|const
name|SourceLine
operator|&
name|rhs
operator|)
specifier|const
block|{
return|return
name|file
operator|==
name|rhs
operator|.
name|file
operator|&&
name|line
operator|==
name|rhs
operator|.
name|line
operator|&&
name|rhs
operator|.
name|column
operator|==
name|column
return|;
block|}
name|bool
name|operator
operator|!=
operator|(
specifier|const
name|SourceLine
operator|&
name|rhs
operator|)
specifier|const
block|{
return|return
name|file
operator|!=
name|rhs
operator|.
name|file
operator|||
name|line
operator|!=
name|rhs
operator|.
name|line
operator|||
name|column
operator|!=
name|rhs
operator|.
name|column
return|;
block|}
name|bool
name|IsValid
argument_list|()
specifier|const
block|{
return|return
name|line
operator|!=
name|LLDB_INVALID_LINE_NUMBER
return|;
block|}
block|}
struct|;
struct|struct
name|SourceLinesToDisplay
block|{
name|std
operator|::
name|vector
operator|<
name|SourceLine
operator|>
name|lines
expr_stmt|;
comment|// index of the "current" source line, if we want to highlight that
comment|// when displaying the source lines.  (as opposed to the surrounding
comment|// source lines provided to give context)
name|size_t
name|current_source_line
decl_stmt|;
comment|// Whether to print a blank line at the end of the source lines.
name|bool
name|print_source_context_end_eol
decl_stmt|;
name|SourceLinesToDisplay
argument_list|()
operator|:
name|lines
argument_list|()
operator|,
name|current_source_line
argument_list|(
operator|-
literal|1
argument_list|)
operator|,
name|print_source_context_end_eol
argument_list|(
argument|true
argument_list|)
block|{     }
block|}
struct|;
comment|// Get the function's declaration line number, hopefully a line number earlier
comment|// than the opening curly brace at the start of the function body.
specifier|static
name|SourceLine
name|GetFunctionDeclLineEntry
parameter_list|(
specifier|const
name|SymbolContext
modifier|&
name|sc
parameter_list|)
function_decl|;
comment|// Add the provided SourceLine to the map of filenames-to-source-lines-seen.
specifier|static
name|void
name|AddLineToSourceLineTables
argument_list|(
name|SourceLine
operator|&
name|line
argument_list|,
name|std
operator|::
name|map
operator|<
name|FileSpec
argument_list|,
name|std
operator|::
name|set
operator|<
name|uint32_t
operator|>>
operator|&
name|source_lines_seen
argument_list|)
decl_stmt|;
comment|// Given a source line, determine if we should print it when we're doing
comment|// mixed source& assembly output.
comment|// We're currently using the target.process.thread.step-avoid-regexp setting
comment|// (which is used for stepping over inlined STL functions by default) to
comment|// determine what source lines to avoid showing.
comment|//
comment|// Returns true if this source line should be elided (if the source line
comment|// should
comment|// not be displayed).
specifier|static
name|bool
name|ElideMixedSourceAndDisassemblyLine
parameter_list|(
specifier|const
name|ExecutionContext
modifier|&
name|exe_ctx
parameter_list|,
specifier|const
name|SymbolContext
modifier|&
name|sc
parameter_list|,
name|SourceLine
modifier|&
name|line
parameter_list|)
function_decl|;
specifier|static
name|bool
name|ElideMixedSourceAndDisassemblyLine
parameter_list|(
specifier|const
name|ExecutionContext
modifier|&
name|exe_ctx
parameter_list|,
specifier|const
name|SymbolContext
modifier|&
name|sc
parameter_list|,
name|LineEntry
modifier|&
name|line
parameter_list|)
block|{
name|SourceLine
name|sl
decl_stmt|;
name|sl
operator|.
name|file
operator|=
name|line
operator|.
name|file
expr_stmt|;
name|sl
operator|.
name|line
operator|=
name|line
operator|.
name|line
expr_stmt|;
name|sl
operator|.
name|column
operator|=
name|line
operator|.
name|column
expr_stmt|;
return|return
name|ElideMixedSourceAndDisassemblyLine
argument_list|(
name|exe_ctx
argument_list|,
name|sc
argument_list|,
name|sl
argument_list|)
return|;
block|}
empty_stmt|;
comment|//------------------------------------------------------------------
comment|// Classes that inherit from Disassembler can see and modify these
comment|//------------------------------------------------------------------
name|ArchSpec
name|m_arch
decl_stmt|;
name|InstructionList
name|m_instruction_list
decl_stmt|;
name|lldb
operator|::
name|addr_t
name|m_base_addr
expr_stmt|;
name|std
operator|::
name|string
name|m_flavor
expr_stmt|;
name|private
label|:
comment|//------------------------------------------------------------------
comment|// For Disassembler only
comment|//------------------------------------------------------------------
name|DISALLOW_COPY_AND_ASSIGN
argument_list|(
name|Disassembler
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
block|}
end_decl_stmt

begin_comment
comment|// namespace lldb_private
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|// liblldb_Disassembler_h_
end_comment

end_unit

