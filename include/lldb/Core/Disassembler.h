begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===-- Disassembler.h ------------------------------------------*- C++ -*-===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|liblldb_Disassembler_h_
end_ifndef

begin_define
define|#
directive|define
name|liblldb_Disassembler_h_
end_define

begin_comment
comment|// C Includes
end_comment

begin_comment
comment|// C++ Includes
end_comment

begin_include
include|#
directive|include
file|<vector>
end_include

begin_include
include|#
directive|include
file|<string>
end_include

begin_comment
comment|// Other libraries and framework includes
end_comment

begin_comment
comment|// Project includes
end_comment

begin_include
include|#
directive|include
file|"lldb/lldb-private.h"
end_include

begin_include
include|#
directive|include
file|"lldb/Core/Address.h"
end_include

begin_include
include|#
directive|include
file|"lldb/Core/ArchSpec.h"
end_include

begin_include
include|#
directive|include
file|"lldb/Core/EmulateInstruction.h"
end_include

begin_include
include|#
directive|include
file|"lldb/Core/Opcode.h"
end_include

begin_include
include|#
directive|include
file|"lldb/Core/PluginInterface.h"
end_include

begin_include
include|#
directive|include
file|"lldb/Interpreter/OptionValue.h"
end_include

begin_decl_stmt
name|namespace
name|lldb_private
block|{
name|class
name|Instruction
block|{
name|public
label|:
name|Instruction
argument_list|(
argument|const Address&address
argument_list|,
argument|lldb::AddressClass addr_class = lldb::eAddressClassInvalid
argument_list|)
empty_stmt|;
name|virtual
operator|~
name|Instruction
argument_list|()
expr_stmt|;
specifier|const
name|Address
operator|&
name|GetAddress
argument_list|()
specifier|const
block|{
return|return
name|m_address
return|;
block|}
specifier|const
name|char
modifier|*
name|GetMnemonic
parameter_list|(
specifier|const
name|ExecutionContext
modifier|*
name|exe_ctx
parameter_list|)
block|{
name|CalculateMnemonicOperandsAndCommentIfNeeded
argument_list|(
name|exe_ctx
argument_list|)
expr_stmt|;
return|return
name|m_opcode_name
operator|.
name|c_str
argument_list|()
return|;
block|}
specifier|const
name|char
modifier|*
name|GetOperands
parameter_list|(
specifier|const
name|ExecutionContext
modifier|*
name|exe_ctx
parameter_list|)
block|{
name|CalculateMnemonicOperandsAndCommentIfNeeded
argument_list|(
name|exe_ctx
argument_list|)
expr_stmt|;
return|return
name|m_mnemonics
operator|.
name|c_str
argument_list|()
return|;
block|}
specifier|const
name|char
modifier|*
name|GetComment
parameter_list|(
specifier|const
name|ExecutionContext
modifier|*
name|exe_ctx
parameter_list|)
block|{
name|CalculateMnemonicOperandsAndCommentIfNeeded
argument_list|(
name|exe_ctx
argument_list|)
expr_stmt|;
return|return
name|m_comment
operator|.
name|c_str
argument_list|()
return|;
block|}
name|virtual
name|void
name|CalculateMnemonicOperandsAndComment
parameter_list|(
specifier|const
name|ExecutionContext
modifier|*
name|exe_ctx
parameter_list|)
init|=
literal|0
function_decl|;
name|lldb
operator|::
name|AddressClass
name|GetAddressClass
argument_list|()
expr_stmt|;
name|void
name|SetAddress
parameter_list|(
specifier|const
name|Address
modifier|&
name|addr
parameter_list|)
block|{
comment|// Invalidate the address class to lazily discover
comment|// it if we need to.
name|m_address_class
operator|=
name|lldb
operator|::
name|eAddressClassInvalid
expr_stmt|;
name|m_address
operator|=
name|addr
expr_stmt|;
block|}
name|virtual
name|void
name|Dump
parameter_list|(
name|Stream
modifier|*
name|s
parameter_list|,
name|uint32_t
name|max_opcode_byte_size
parameter_list|,
name|bool
name|show_address
parameter_list|,
name|bool
name|show_bytes
parameter_list|,
specifier|const
name|ExecutionContext
modifier|*
name|exe_ctx
parameter_list|)
function_decl|;
name|virtual
name|bool
name|DoesBranch
parameter_list|()
init|=
literal|0
function_decl|;
name|virtual
name|size_t
name|Decode
argument_list|(
specifier|const
name|Disassembler
operator|&
name|disassembler
argument_list|,
specifier|const
name|DataExtractor
operator|&
name|data
argument_list|,
name|lldb
operator|::
name|offset_t
name|data_offset
argument_list|)
init|=
literal|0
decl_stmt|;
name|virtual
name|void
name|SetDescription
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|)
block|{}
comment|// May be overridden in sub-classes that have descriptions.
name|lldb
operator|::
name|OptionValueSP
name|ReadArray
argument_list|(
argument|FILE *in_file
argument_list|,
argument|Stream *out_stream
argument_list|,
argument|OptionValue::Type data_type
argument_list|)
expr_stmt|;
name|lldb
operator|::
name|OptionValueSP
name|ReadDictionary
argument_list|(
name|FILE
operator|*
name|in_file
argument_list|,
name|Stream
operator|*
name|out_stream
argument_list|)
expr_stmt|;
name|bool
name|DumpEmulation
parameter_list|(
specifier|const
name|ArchSpec
modifier|&
name|arch
parameter_list|)
function_decl|;
name|virtual
name|bool
name|TestEmulation
parameter_list|(
name|Stream
modifier|*
name|stream
parameter_list|,
specifier|const
name|char
modifier|*
name|test_file_name
parameter_list|)
function_decl|;
name|bool
name|Emulate
argument_list|(
specifier|const
name|ArchSpec
operator|&
name|arch
argument_list|,
name|uint32_t
name|evaluate_options
argument_list|,
name|void
operator|*
name|baton
argument_list|,
name|EmulateInstruction
operator|::
name|ReadMemoryCallback
name|read_mem_callback
argument_list|,
name|EmulateInstruction
operator|::
name|WriteMemoryCallback
name|write_mem_calback
argument_list|,
name|EmulateInstruction
operator|::
name|ReadRegisterCallback
name|read_reg_callback
argument_list|,
name|EmulateInstruction
operator|::
name|WriteRegisterCallback
name|write_reg_callback
argument_list|)
decl_stmt|;
specifier|const
name|Opcode
operator|&
name|GetOpcode
argument_list|()
specifier|const
block|{
return|return
name|m_opcode
return|;
block|}
name|uint32_t
name|GetData
parameter_list|(
name|DataExtractor
modifier|&
name|data
parameter_list|)
function_decl|;
name|protected
label|:
name|Address
name|m_address
decl_stmt|;
comment|// The section offset address of this instruction
comment|// We include an address class in the Instruction class to
comment|// allow the instruction specify the eAddressClassCodeAlternateISA
comment|// (currently used for thumb), and also to specify data (eAddressClassData).
comment|// The usual value will be eAddressClassCode, but often when
comment|// disassembling memory, you might run into data. This can
comment|// help us to disassemble appropriately.
name|private
label|:
name|lldb
operator|::
name|AddressClass
name|m_address_class
expr_stmt|;
comment|// Use GetAddressClass () accessor function!
name|protected
label|:
name|Opcode
name|m_opcode
decl_stmt|;
comment|// The opcode for this instruction
name|std
operator|::
name|string
name|m_opcode_name
expr_stmt|;
name|std
operator|::
name|string
name|m_mnemonics
expr_stmt|;
name|std
operator|::
name|string
name|m_comment
expr_stmt|;
name|bool
name|m_calculated_strings
decl_stmt|;
name|void
name|CalculateMnemonicOperandsAndCommentIfNeeded
parameter_list|(
specifier|const
name|ExecutionContext
modifier|*
name|exe_ctx
parameter_list|)
block|{
if|if
condition|(
operator|!
name|m_calculated_strings
condition|)
block|{
name|m_calculated_strings
operator|=
name|true
expr_stmt|;
name|CalculateMnemonicOperandsAndComment
argument_list|(
name|exe_ctx
argument_list|)
expr_stmt|;
block|}
block|}
block|}
empty_stmt|;
name|class
name|InstructionList
block|{
name|public
label|:
name|InstructionList
argument_list|()
expr_stmt|;
operator|~
name|InstructionList
argument_list|()
expr_stmt|;
name|size_t
name|GetSize
argument_list|()
specifier|const
expr_stmt|;
name|uint32_t
name|GetMaxOpcocdeByteSize
argument_list|()
specifier|const
expr_stmt|;
name|lldb
operator|::
name|InstructionSP
name|GetInstructionAtIndex
argument_list|(
argument|size_t idx
argument_list|)
specifier|const
expr_stmt|;
name|uint32_t
name|GetIndexOfNextBranchInstruction
argument_list|(
name|uint32_t
name|start
argument_list|)
decl|const
decl_stmt|;
name|uint32_t
name|GetIndexOfInstructionAtLoadAddress
argument_list|(
name|lldb
operator|::
name|addr_t
name|load_addr
argument_list|,
name|Target
operator|&
name|target
argument_list|)
decl_stmt|;
name|void
name|Clear
parameter_list|()
function_decl|;
name|void
name|Append
argument_list|(
name|lldb
operator|::
name|InstructionSP
operator|&
name|inst_sp
argument_list|)
decl_stmt|;
name|void
name|Dump
parameter_list|(
name|Stream
modifier|*
name|s
parameter_list|,
name|bool
name|show_address
parameter_list|,
name|bool
name|show_bytes
parameter_list|,
specifier|const
name|ExecutionContext
modifier|*
name|exe_ctx
parameter_list|)
function_decl|;
name|private
label|:
typedef|typedef
name|std
operator|::
name|vector
operator|<
name|lldb
operator|::
name|InstructionSP
operator|>
name|collection
expr_stmt|;
typedef|typedef
name|collection
operator|::
name|iterator
name|iterator
expr_stmt|;
typedef|typedef
name|collection
operator|::
name|const_iterator
name|const_iterator
expr_stmt|;
name|collection
name|m_instructions
decl_stmt|;
block|}
empty_stmt|;
name|class
name|PseudoInstruction
range|:
name|public
name|Instruction
block|{
name|public
operator|:
name|PseudoInstruction
argument_list|()
block|;
name|virtual
operator|~
name|PseudoInstruction
argument_list|()
block|;
name|virtual
name|bool
name|DoesBranch
argument_list|()
block|;
name|virtual
name|void
name|CalculateMnemonicOperandsAndComment
argument_list|(
argument|const ExecutionContext* exe_ctx
argument_list|)
block|{
comment|// TODO: fill this in and put opcode name into Instruction::m_opcode_name,
comment|// mnemonic into Instruction::m_mnemonics, and any comment into
comment|// Instruction::m_comment
block|}
name|virtual
name|size_t
name|Decode
argument_list|(
argument|const Disassembler&disassembler
argument_list|,
argument|const DataExtractor&data
argument_list|,
argument|lldb::offset_t data_offset
argument_list|)
block|;
name|void
name|SetOpcode
argument_list|(
argument|size_t opcode_size
argument_list|,
argument|void *opcode_data
argument_list|)
block|;
name|virtual
name|void
name|SetDescription
argument_list|(
specifier|const
name|char
operator|*
name|description
argument_list|)
block|;
name|protected
operator|:
name|std
operator|::
name|string
name|m_description
block|;
name|DISALLOW_COPY_AND_ASSIGN
argument_list|(
name|PseudoInstruction
argument_list|)
block|; }
decl_stmt|;
name|class
name|Disassembler
range|:
name|public
name|std
operator|::
name|enable_shared_from_this
operator|<
name|Disassembler
operator|>
decl_stmt|,
name|public
name|PluginInterface
block|{
name|public
label|:
enum|enum
block|{
name|eOptionNone
init|=
literal|0u
block|,
name|eOptionShowBytes
init|=
operator|(
literal|1u
operator|<<
literal|0
operator|)
block|,
name|eOptionRawOuput
init|=
operator|(
literal|1u
operator|<<
literal|1
operator|)
block|,
name|eOptionMarkPCSourceLine
init|=
operator|(
literal|1u
operator|<<
literal|2
operator|)
block|,
comment|// Mark the source line that contains the current PC (mixed mode only)
name|eOptionMarkPCAddress
init|=
operator|(
literal|1u
operator|<<
literal|3
operator|)
comment|// Mark the disassembly line the contains the PC
block|}
enum|;
enum|enum
name|HexImmediateStyle
block|{
name|eHexStyleC
block|,
name|eHexStyleAsm
block|,     }
enum|;
comment|// FindPlugin should be lax about the flavor string (it is too annoying to have various internal uses of the
comment|// disassembler fail because the global flavor string gets set wrong.  Instead, if you get a flavor string you
comment|// don't understand, use the default.  Folks who care to check can use the FlavorValidForArchSpec method on the
comment|// disassembler they got back.
specifier|static
name|lldb
operator|::
name|DisassemblerSP
name|FindPlugin
argument_list|(
specifier|const
name|ArchSpec
operator|&
name|arch
argument_list|,
specifier|const
name|char
operator|*
name|flavor
argument_list|,
specifier|const
name|char
operator|*
name|plugin_name
argument_list|)
expr_stmt|;
comment|// This version will use the value in the Target settings if flavor is NULL;
specifier|static
name|lldb
operator|::
name|DisassemblerSP
name|FindPluginForTarget
argument_list|(
argument|const lldb::TargetSP target_sp
argument_list|,
argument|const ArchSpec&arch
argument_list|,
argument|const char *flavor
argument_list|,
argument|const char *plugin_name
argument_list|)
expr_stmt|;
specifier|static
name|lldb
operator|::
name|DisassemblerSP
name|DisassembleRange
argument_list|(
specifier|const
name|ArchSpec
operator|&
name|arch
argument_list|,
specifier|const
name|char
operator|*
name|plugin_name
argument_list|,
specifier|const
name|char
operator|*
name|flavor
argument_list|,
specifier|const
name|ExecutionContext
operator|&
name|exe_ctx
argument_list|,
specifier|const
name|AddressRange
operator|&
name|disasm_range
argument_list|)
expr_stmt|;
specifier|static
name|lldb
operator|::
name|DisassemblerSP
name|DisassembleBytes
argument_list|(
argument|const ArchSpec&arch
argument_list|,
argument|const char *plugin_name
argument_list|,
argument|const char *flavor
argument_list|,
argument|const Address&start
argument_list|,
argument|const void *bytes
argument_list|,
argument|size_t length
argument_list|,
argument|uint32_t max_num_instructions
argument_list|,
argument|bool data_from_file
argument_list|)
expr_stmt|;
specifier|static
name|bool
name|Disassemble
parameter_list|(
name|Debugger
modifier|&
name|debugger
parameter_list|,
specifier|const
name|ArchSpec
modifier|&
name|arch
parameter_list|,
specifier|const
name|char
modifier|*
name|plugin_name
parameter_list|,
specifier|const
name|char
modifier|*
name|flavor
parameter_list|,
specifier|const
name|ExecutionContext
modifier|&
name|exe_ctx
parameter_list|,
specifier|const
name|AddressRange
modifier|&
name|range
parameter_list|,
name|uint32_t
name|num_instructions
parameter_list|,
name|uint32_t
name|num_mixed_context_lines
parameter_list|,
name|uint32_t
name|options
parameter_list|,
name|Stream
modifier|&
name|strm
parameter_list|)
function_decl|;
specifier|static
name|bool
name|Disassemble
parameter_list|(
name|Debugger
modifier|&
name|debugger
parameter_list|,
specifier|const
name|ArchSpec
modifier|&
name|arch
parameter_list|,
specifier|const
name|char
modifier|*
name|plugin_name
parameter_list|,
specifier|const
name|char
modifier|*
name|flavor
parameter_list|,
specifier|const
name|ExecutionContext
modifier|&
name|exe_ctx
parameter_list|,
specifier|const
name|Address
modifier|&
name|start
parameter_list|,
name|uint32_t
name|num_instructions
parameter_list|,
name|uint32_t
name|num_mixed_context_lines
parameter_list|,
name|uint32_t
name|options
parameter_list|,
name|Stream
modifier|&
name|strm
parameter_list|)
function_decl|;
specifier|static
name|size_t
name|Disassemble
parameter_list|(
name|Debugger
modifier|&
name|debugger
parameter_list|,
specifier|const
name|ArchSpec
modifier|&
name|arch
parameter_list|,
specifier|const
name|char
modifier|*
name|plugin_name
parameter_list|,
specifier|const
name|char
modifier|*
name|flavor
parameter_list|,
specifier|const
name|ExecutionContext
modifier|&
name|exe_ctx
parameter_list|,
name|SymbolContextList
modifier|&
name|sc_list
parameter_list|,
name|uint32_t
name|num_instructions
parameter_list|,
name|uint32_t
name|num_mixed_context_lines
parameter_list|,
name|uint32_t
name|options
parameter_list|,
name|Stream
modifier|&
name|strm
parameter_list|)
function_decl|;
specifier|static
name|bool
name|Disassemble
parameter_list|(
name|Debugger
modifier|&
name|debugger
parameter_list|,
specifier|const
name|ArchSpec
modifier|&
name|arch
parameter_list|,
specifier|const
name|char
modifier|*
name|plugin_name
parameter_list|,
specifier|const
name|char
modifier|*
name|flavor
parameter_list|,
specifier|const
name|ExecutionContext
modifier|&
name|exe_ctx
parameter_list|,
specifier|const
name|ConstString
modifier|&
name|name
parameter_list|,
name|Module
modifier|*
name|module
parameter_list|,
name|uint32_t
name|num_instructions
parameter_list|,
name|uint32_t
name|num_mixed_context_lines
parameter_list|,
name|uint32_t
name|options
parameter_list|,
name|Stream
modifier|&
name|strm
parameter_list|)
function_decl|;
specifier|static
name|bool
name|Disassemble
parameter_list|(
name|Debugger
modifier|&
name|debugger
parameter_list|,
specifier|const
name|ArchSpec
modifier|&
name|arch
parameter_list|,
specifier|const
name|char
modifier|*
name|plugin_name
parameter_list|,
specifier|const
name|char
modifier|*
name|flavor
parameter_list|,
specifier|const
name|ExecutionContext
modifier|&
name|exe_ctx
parameter_list|,
name|uint32_t
name|num_instructions
parameter_list|,
name|uint32_t
name|num_mixed_context_lines
parameter_list|,
name|uint32_t
name|options
parameter_list|,
name|Stream
modifier|&
name|strm
parameter_list|)
function_decl|;
comment|//------------------------------------------------------------------
comment|// Constructors and Destructors
comment|//------------------------------------------------------------------
name|Disassembler
argument_list|(
specifier|const
name|ArchSpec
operator|&
name|arch
argument_list|,
specifier|const
name|char
operator|*
name|flavor
argument_list|)
expr_stmt|;
name|virtual
operator|~
name|Disassembler
argument_list|()
expr_stmt|;
typedef|typedef
specifier|const
name|char
modifier|*
function_decl|(
modifier|*
name|SummaryCallback
function_decl|)
parameter_list|(
specifier|const
name|Instruction
modifier|&
name|inst
parameter_list|,
name|ExecutionContext
modifier|*
name|exe_context
parameter_list|,
name|void
modifier|*
name|user_data
parameter_list|)
function_decl|;
specifier|static
name|bool
name|PrintInstructions
parameter_list|(
name|Disassembler
modifier|*
name|disasm_ptr
parameter_list|,
name|Debugger
modifier|&
name|debugger
parameter_list|,
specifier|const
name|ArchSpec
modifier|&
name|arch
parameter_list|,
specifier|const
name|ExecutionContext
modifier|&
name|exe_ctx
parameter_list|,
name|uint32_t
name|num_instructions
parameter_list|,
name|uint32_t
name|num_mixed_context_lines
parameter_list|,
name|uint32_t
name|options
parameter_list|,
name|Stream
modifier|&
name|strm
parameter_list|)
function_decl|;
name|size_t
name|ParseInstructions
parameter_list|(
specifier|const
name|ExecutionContext
modifier|*
name|exe_ctx
parameter_list|,
specifier|const
name|AddressRange
modifier|&
name|range
parameter_list|,
name|Stream
modifier|*
name|error_strm_ptr
parameter_list|,
name|bool
name|prefer_file_cache
parameter_list|)
function_decl|;
name|size_t
name|ParseInstructions
parameter_list|(
specifier|const
name|ExecutionContext
modifier|*
name|exe_ctx
parameter_list|,
specifier|const
name|Address
modifier|&
name|range
parameter_list|,
name|uint32_t
name|num_instructions
parameter_list|,
name|bool
name|prefer_file_cache
parameter_list|)
function_decl|;
name|virtual
name|size_t
name|DecodeInstructions
argument_list|(
specifier|const
name|Address
operator|&
name|base_addr
argument_list|,
specifier|const
name|DataExtractor
operator|&
name|data
argument_list|,
name|lldb
operator|::
name|offset_t
name|data_offset
argument_list|,
name|size_t
name|num_instructions
argument_list|,
name|bool
name|append
argument_list|,
name|bool
name|data_from_file
argument_list|)
init|=
literal|0
decl_stmt|;
name|InstructionList
modifier|&
name|GetInstructionList
parameter_list|()
function_decl|;
specifier|const
name|InstructionList
operator|&
name|GetInstructionList
argument_list|()
specifier|const
expr_stmt|;
specifier|const
name|ArchSpec
operator|&
name|GetArchitecture
argument_list|()
specifier|const
block|{
return|return
name|m_arch
return|;
block|}
specifier|const
name|char
operator|*
name|GetFlavor
argument_list|()
specifier|const
block|{
return|return
name|m_flavor
operator|.
name|c_str
argument_list|()
return|;
block|}
name|virtual
name|bool
name|FlavorValidForArchSpec
argument_list|(
specifier|const
name|lldb_private
operator|::
name|ArchSpec
operator|&
name|arch
argument_list|,
specifier|const
name|char
operator|*
name|flavor
argument_list|)
init|=
literal|0
decl_stmt|;
name|protected
label|:
comment|//------------------------------------------------------------------
comment|// Classes that inherit from Disassembler can see and modify these
comment|//------------------------------------------------------------------
specifier|const
name|ArchSpec
name|m_arch
decl_stmt|;
name|InstructionList
name|m_instruction_list
decl_stmt|;
name|lldb
operator|::
name|addr_t
name|m_base_addr
expr_stmt|;
name|std
operator|::
name|string
name|m_flavor
expr_stmt|;
name|private
label|:
comment|//------------------------------------------------------------------
comment|// For Disassembler only
comment|//------------------------------------------------------------------
name|DISALLOW_COPY_AND_ASSIGN
argument_list|(
name|Disassembler
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
block|}
end_decl_stmt

begin_comment
comment|// namespace lldb_private
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|// liblldb_Disassembler_h_
end_comment

end_unit

