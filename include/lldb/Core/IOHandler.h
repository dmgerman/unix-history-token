begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===-- IOHandler.h ---------------------------------------------*- C++ -*-===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|liblldb_IOHandler_h_
end_ifndef

begin_define
define|#
directive|define
name|liblldb_IOHandler_h_
end_define

begin_include
include|#
directive|include
file|"lldb/Core/ValueObjectList.h"
end_include

begin_include
include|#
directive|include
file|"lldb/Host/Predicate.h"
end_include

begin_include
include|#
directive|include
file|"lldb/Utility/ConstString.h"
end_include

begin_include
include|#
directive|include
file|"lldb/Utility/Flags.h"
end_include

begin_include
include|#
directive|include
file|"lldb/Utility/Stream.h"
end_include

begin_include
include|#
directive|include
file|"lldb/Utility/StringList.h"
end_include

begin_include
include|#
directive|include
file|"lldb/lldb-defines.h"
end_include

begin_comment
comment|// for DISALLOW_COPY_AND_ASSIGN
end_comment

begin_include
include|#
directive|include
file|"lldb/lldb-forward.h"
end_include

begin_comment
comment|// for IOHandlerSP, StreamFileSP
end_comment

begin_include
include|#
directive|include
file|"llvm/ADT/StringRef.h"
end_include

begin_comment
comment|// for StringRef
end_comment

begin_include
include|#
directive|include
file|<memory>
end_include

begin_include
include|#
directive|include
file|<mutex>
end_include

begin_include
include|#
directive|include
file|<string>
end_include

begin_include
include|#
directive|include
file|<vector>
end_include

begin_include
include|#
directive|include
file|<stdint.h>
end_include

begin_comment
comment|// for uint32_t
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_comment
comment|// for FILE
end_comment

begin_decl_stmt
name|namespace
name|lldb_private
block|{
name|class
name|Debugger
decl_stmt|;
block|}
end_decl_stmt

begin_decl_stmt
name|namespace
name|curses
block|{
name|class
name|Application
decl_stmt|;
typedef|typedef
name|std
operator|::
name|unique_ptr
operator|<
name|Application
operator|>
name|ApplicationAP
expr_stmt|;
block|}
end_decl_stmt

begin_comment
comment|// namespace curses
end_comment

begin_decl_stmt
name|namespace
name|lldb_private
block|{
name|class
name|IOHandler
block|{
name|public
label|:
name|enum
name|class
name|Type
block|{
name|CommandInterpreter
operator|,
name|CommandList
operator|,
name|Confirm
operator|,
name|Curses
operator|,
name|Expression
operator|,
name|REPL
operator|,
name|ProcessIO
operator|,
name|PythonInterpreter
operator|,
name|PythonCode
operator|,
name|Other
block|}
empty_stmt|;
name|IOHandler
argument_list|(
argument|Debugger&debugger
argument_list|,
argument|IOHandler::Type type
argument_list|)
empty_stmt|;
name|IOHandler
argument_list|(
argument|Debugger&debugger
argument_list|,
argument|IOHandler::Type type
argument_list|,
argument|const lldb::StreamFileSP&input_sp
argument_list|,
argument|const lldb::StreamFileSP&output_sp
argument_list|,
argument|const lldb::StreamFileSP&error_sp
argument_list|,
argument|uint32_t flags
argument_list|)
empty_stmt|;
name|virtual
operator|~
name|IOHandler
argument_list|()
expr_stmt|;
comment|// Each IOHandler gets to run until it is done. It should read data
comment|// from the "in" and place output into "out" and "err and return
comment|// when done.
name|virtual
name|void
name|Run
parameter_list|()
init|=
literal|0
function_decl|;
comment|// Called when an input reader should relinquish its control so another
comment|// can be pushed onto the IO handler stack, or so the current IO
comment|// handler can pop itself off the stack
name|virtual
name|void
name|Cancel
parameter_list|()
init|=
literal|0
function_decl|;
comment|// Called when CTRL+C is pressed which usually causes
comment|// Debugger::DispatchInputInterrupt to be called.
name|virtual
name|bool
name|Interrupt
parameter_list|()
init|=
literal|0
function_decl|;
name|virtual
name|void
name|GotEOF
parameter_list|()
init|=
literal|0
function_decl|;
name|virtual
name|bool
name|IsActive
parameter_list|()
block|{
return|return
name|m_active
operator|&&
operator|!
name|m_done
return|;
block|}
name|virtual
name|void
name|SetIsDone
parameter_list|(
name|bool
name|b
parameter_list|)
block|{
name|m_done
operator|=
name|b
expr_stmt|;
block|}
name|virtual
name|bool
name|GetIsDone
parameter_list|()
block|{
return|return
name|m_done
return|;
block|}
name|Type
name|GetType
argument_list|()
specifier|const
block|{
return|return
name|m_type
return|;
block|}
name|virtual
name|void
name|Activate
parameter_list|()
block|{
name|m_active
operator|=
name|true
expr_stmt|;
block|}
name|virtual
name|void
name|Deactivate
parameter_list|()
block|{
name|m_active
operator|=
name|false
expr_stmt|;
block|}
name|virtual
specifier|const
name|char
modifier|*
name|GetPrompt
parameter_list|()
block|{
comment|// Prompt support isn't mandatory
return|return
name|nullptr
return|;
block|}
name|virtual
name|bool
name|SetPrompt
argument_list|(
name|llvm
operator|::
name|StringRef
name|prompt
argument_list|)
block|{
comment|// Prompt support isn't mandatory
return|return
name|false
return|;
block|}
name|bool
name|SetPrompt
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|)
init|=
name|delete
function_decl|;
name|virtual
name|ConstString
name|GetControlSequence
parameter_list|(
name|char
name|ch
parameter_list|)
block|{
return|return
name|ConstString
argument_list|()
return|;
block|}
name|virtual
specifier|const
name|char
modifier|*
name|GetCommandPrefix
parameter_list|()
block|{
return|return
name|nullptr
return|;
block|}
name|virtual
specifier|const
name|char
modifier|*
name|GetHelpPrologue
parameter_list|()
block|{
return|return
name|nullptr
return|;
block|}
name|int
name|GetInputFD
parameter_list|()
function_decl|;
name|int
name|GetOutputFD
parameter_list|()
function_decl|;
name|int
name|GetErrorFD
parameter_list|()
function_decl|;
name|FILE
modifier|*
name|GetInputFILE
parameter_list|()
function_decl|;
name|FILE
modifier|*
name|GetOutputFILE
parameter_list|()
function_decl|;
name|FILE
modifier|*
name|GetErrorFILE
parameter_list|()
function_decl|;
name|lldb
operator|::
name|StreamFileSP
operator|&
name|GetInputStreamFile
argument_list|()
expr_stmt|;
name|lldb
operator|::
name|StreamFileSP
operator|&
name|GetOutputStreamFile
argument_list|()
expr_stmt|;
name|lldb
operator|::
name|StreamFileSP
operator|&
name|GetErrorStreamFile
argument_list|()
expr_stmt|;
name|Debugger
modifier|&
name|GetDebugger
parameter_list|()
block|{
return|return
name|m_debugger
return|;
block|}
name|void
modifier|*
name|GetUserData
parameter_list|()
block|{
return|return
name|m_user_data
return|;
block|}
name|void
name|SetUserData
parameter_list|(
name|void
modifier|*
name|user_data
parameter_list|)
block|{
name|m_user_data
operator|=
name|user_data
expr_stmt|;
block|}
name|Flags
modifier|&
name|GetFlags
parameter_list|()
block|{
return|return
name|m_flags
return|;
block|}
specifier|const
name|Flags
operator|&
name|GetFlags
argument_list|()
specifier|const
block|{
return|return
name|m_flags
return|;
block|}
comment|//------------------------------------------------------------------
comment|/// Check if the input is being supplied interactively by a user
comment|///
comment|/// This will return true if the input stream is a terminal (tty or
comment|/// pty) and can cause IO handlers to do different things (like
comment|/// for a confirmation when deleting all breakpoints).
comment|//------------------------------------------------------------------
name|bool
name|GetIsInteractive
parameter_list|()
function_decl|;
comment|//------------------------------------------------------------------
comment|/// Check if the input is coming from a real terminal.
comment|///
comment|/// A real terminal has a valid size with a certain number of rows
comment|/// and columns. If this function returns true, then terminal escape
comment|/// sequences are expected to work (cursor movement escape sequences,
comment|/// clearing lines, etc).
comment|//------------------------------------------------------------------
name|bool
name|GetIsRealTerminal
parameter_list|()
function_decl|;
name|void
name|SetPopped
parameter_list|(
name|bool
name|b
parameter_list|)
function_decl|;
name|void
name|WaitForPop
parameter_list|()
function_decl|;
name|virtual
name|void
name|PrintAsync
parameter_list|(
name|Stream
modifier|*
name|stream
parameter_list|,
specifier|const
name|char
modifier|*
name|s
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
name|stream
operator|->
name|Write
argument_list|(
name|s
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|stream
operator|->
name|Flush
argument_list|()
expr_stmt|;
block|}
name|protected
label|:
name|Debugger
modifier|&
name|m_debugger
decl_stmt|;
name|lldb
operator|::
name|StreamFileSP
name|m_input_sp
expr_stmt|;
name|lldb
operator|::
name|StreamFileSP
name|m_output_sp
expr_stmt|;
name|lldb
operator|::
name|StreamFileSP
name|m_error_sp
expr_stmt|;
name|Predicate
operator|<
name|bool
operator|>
name|m_popped
expr_stmt|;
name|Flags
name|m_flags
decl_stmt|;
name|Type
name|m_type
decl_stmt|;
name|void
modifier|*
name|m_user_data
decl_stmt|;
name|bool
name|m_done
decl_stmt|;
name|bool
name|m_active
decl_stmt|;
name|private
label|:
name|DISALLOW_COPY_AND_ASSIGN
argument_list|(
name|IOHandler
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
comment|//------------------------------------------------------------------
comment|/// A delegate class for use with IOHandler subclasses.
comment|///
comment|/// The IOHandler delegate is designed to be mixed into classes so
comment|/// they can use an IOHandler subclass to fetch input and notify the
comment|/// object that inherits from this delegate class when a token is
comment|/// received.
comment|//------------------------------------------------------------------
name|class
name|IOHandlerDelegate
block|{
name|public
label|:
name|enum
name|class
name|Completion
block|{
name|None
operator|,
name|LLDBCommand
operator|,
name|Expression
block|}
empty_stmt|;
name|IOHandlerDelegate
argument_list|(
argument|Completion completion = Completion::None
argument_list|)
block|:
name|m_completion
argument_list|(
name|completion
argument_list|)
operator|,
name|m_io_handler_done
argument_list|(
argument|false
argument_list|)
block|{}
name|virtual
operator|~
name|IOHandlerDelegate
argument_list|()
operator|=
expr|default
expr_stmt|;
name|virtual
name|void
name|IOHandlerActivated
parameter_list|(
name|IOHandler
modifier|&
name|io_handler
parameter_list|)
block|{}
name|virtual
name|void
name|IOHandlerDeactivated
parameter_list|(
name|IOHandler
modifier|&
name|io_handler
parameter_list|)
block|{}
name|virtual
name|int
name|IOHandlerComplete
parameter_list|(
name|IOHandler
modifier|&
name|io_handler
parameter_list|,
specifier|const
name|char
modifier|*
name|current_line
parameter_list|,
specifier|const
name|char
modifier|*
name|cursor
parameter_list|,
specifier|const
name|char
modifier|*
name|last_char
parameter_list|,
name|int
name|skip_first_n_matches
parameter_list|,
name|int
name|max_matches
parameter_list|,
name|StringList
modifier|&
name|matches
parameter_list|)
function_decl|;
name|virtual
specifier|const
name|char
modifier|*
name|IOHandlerGetFixIndentationCharacters
parameter_list|()
block|{
return|return
name|nullptr
return|;
block|}
comment|//------------------------------------------------------------------
comment|/// Called when a new line is created or one of an identified set of
comment|/// indentation characters is typed.
comment|///
comment|/// This function determines how much indentation should be added
comment|/// or removed to match the recommended amount for the final line.
comment|///
comment|/// @param[in] io_handler
comment|///     The IOHandler that responsible for input.
comment|///
comment|/// @param[in] lines
comment|///     The current input up to the line to be corrected.  Lines
comment|///     following the line containing the cursor are not included.
comment|///
comment|/// @param[in] cursor_position
comment|///     The number of characters preceding the cursor on the final
comment|///     line at the time.
comment|///
comment|/// @return
comment|///     Returns an integer describing the number of spaces needed
comment|///     to correct the indentation level.  Positive values indicate
comment|///     that spaces should be added, while negative values represent
comment|///     spaces that should be removed.
comment|//------------------------------------------------------------------
name|virtual
name|int
name|IOHandlerFixIndentation
parameter_list|(
name|IOHandler
modifier|&
name|io_handler
parameter_list|,
specifier|const
name|StringList
modifier|&
name|lines
parameter_list|,
name|int
name|cursor_position
parameter_list|)
block|{
return|return
literal|0
return|;
block|}
comment|//------------------------------------------------------------------
comment|/// Called when a line or lines have been retrieved.
comment|///
comment|/// This function can handle the current line and possibly call
comment|/// IOHandler::SetIsDone(true) when the IO handler is done like when
comment|/// "quit" is entered as a command, of when an empty line is
comment|/// received. It is up to the delegate to determine when a line
comment|/// should cause a IOHandler to exit.
comment|//------------------------------------------------------------------
name|virtual
name|void
name|IOHandlerInputComplete
argument_list|(
name|IOHandler
operator|&
name|io_handler
argument_list|,
name|std
operator|::
name|string
operator|&
name|data
argument_list|)
init|=
literal|0
decl_stmt|;
name|virtual
name|void
name|IOHandlerInputInterrupted
argument_list|(
name|IOHandler
operator|&
name|io_handler
argument_list|,
name|std
operator|::
name|string
operator|&
name|data
argument_list|)
block|{}
comment|//------------------------------------------------------------------
comment|/// Called to determine whether typing enter after the last line in
comment|/// \a lines should end input.  This function will not be called on
comment|/// IOHandler objects that are getting single lines.
comment|/// @param[in] io_handler
comment|///     The IOHandler that responsible for updating the lines.
comment|///
comment|/// @param[in] lines
comment|///     The current multi-line content.  May be altered to provide
comment|///     alternative input when complete.
comment|///
comment|/// @return
comment|///     Return an boolean to indicate whether input is complete,
comment|///     true indicates that no additional input is necessary, while
comment|///     false indicates that more input is required.
comment|//------------------------------------------------------------------
name|virtual
name|bool
name|IOHandlerIsInputComplete
parameter_list|(
name|IOHandler
modifier|&
name|io_handler
parameter_list|,
name|StringList
modifier|&
name|lines
parameter_list|)
block|{
comment|// Impose no requirements for input to be considered
comment|// complete.  subclasses should do something more intelligent.
return|return
name|true
return|;
block|}
name|virtual
name|ConstString
name|IOHandlerGetControlSequence
parameter_list|(
name|char
name|ch
parameter_list|)
block|{
return|return
name|ConstString
argument_list|()
return|;
block|}
name|virtual
specifier|const
name|char
modifier|*
name|IOHandlerGetCommandPrefix
parameter_list|()
block|{
return|return
name|nullptr
return|;
block|}
name|virtual
specifier|const
name|char
modifier|*
name|IOHandlerGetHelpPrologue
parameter_list|()
block|{
return|return
name|nullptr
return|;
block|}
comment|//------------------------------------------------------------------
comment|// Intercept the IOHandler::Interrupt() calls and do something.
comment|//
comment|// Return true if the interrupt was handled, false if the IOHandler
comment|// should continue to try handle the interrupt itself.
comment|//------------------------------------------------------------------
name|virtual
name|bool
name|IOHandlerInterrupt
parameter_list|(
name|IOHandler
modifier|&
name|io_handler
parameter_list|)
block|{
return|return
name|false
return|;
block|}
name|protected
label|:
name|Completion
name|m_completion
decl_stmt|;
comment|// Support for common builtin completions
name|bool
name|m_io_handler_done
decl_stmt|;
block|}
empty_stmt|;
comment|//----------------------------------------------------------------------
comment|// IOHandlerDelegateMultiline
comment|//
comment|// A IOHandlerDelegate that handles terminating multi-line input when
comment|// the last line is equal to "end_line" which is specified in the
comment|// constructor.
comment|//----------------------------------------------------------------------
name|class
name|IOHandlerDelegateMultiline
range|:
name|public
name|IOHandlerDelegate
block|{
name|public
operator|:
name|IOHandlerDelegateMultiline
argument_list|(
argument|const char *end_line
argument_list|,
argument|Completion completion = Completion::None
argument_list|)
operator|:
name|IOHandlerDelegate
argument_list|(
name|completion
argument_list|)
block|,
name|m_end_line
argument_list|(
argument|(end_line&& end_line[
literal|0
argument|]) ? end_line :
literal|""
argument_list|)
block|{}
operator|~
name|IOHandlerDelegateMultiline
argument_list|()
name|override
operator|=
expr|default
block|;
name|ConstString
name|IOHandlerGetControlSequence
argument_list|(
argument|char ch
argument_list|)
name|override
block|{
if|if
condition|(
name|ch
operator|==
literal|'d'
condition|)
return|return
name|ConstString
argument_list|(
name|m_end_line
operator|+
literal|"\n"
argument_list|)
return|;
return|return
name|ConstString
argument_list|()
return|;
block|}
name|bool
name|IOHandlerIsInputComplete
parameter_list|(
name|IOHandler
modifier|&
name|io_handler
parameter_list|,
name|StringList
modifier|&
name|lines
parameter_list|)
function|override
block|{
comment|// Determine whether the end of input signal has been entered
specifier|const
name|size_t
name|num_lines
init|=
name|lines
operator|.
name|GetSize
argument_list|()
decl_stmt|;
if|if
condition|(
name|num_lines
operator|>
literal|0
operator|&&
name|lines
index|[
name|num_lines
operator|-
literal|1
index|]
operator|==
name|m_end_line
condition|)
block|{
comment|// Remove the terminal line from "lines" so it doesn't appear in
comment|// the resulting input and return true to indicate we are done
comment|// getting lines
name|lines
operator|.
name|PopBack
argument_list|()
expr_stmt|;
return|return
name|true
return|;
block|}
return|return
name|false
return|;
block|}
name|protected
label|:
specifier|const
name|std
operator|::
name|string
name|m_end_line
expr_stmt|;
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_decl_stmt
name|class
name|IOHandlerEditline
range|:
name|public
name|IOHandler
block|{
name|public
operator|:
name|IOHandlerEditline
argument_list|(
argument|Debugger&debugger
argument_list|,
argument|IOHandler::Type type
argument_list|,
argument|const char *editline_name
argument_list|,
comment|// Used for saving history files
argument|llvm::StringRef prompt
argument_list|,
argument|llvm::StringRef continuation_prompt
argument_list|,
argument|bool multi_line
argument_list|,
argument|bool color_prompts
argument_list|,
argument|uint32_t line_number_start
argument_list|,
comment|// If non-zero show line numbers
comment|// starting at
comment|// 'line_number_start'
argument|IOHandlerDelegate&delegate
argument_list|)
block|;
name|IOHandlerEditline
argument_list|(
argument|Debugger&debugger
argument_list|,
argument|IOHandler::Type type
argument_list|,
argument|const lldb::StreamFileSP&input_sp
argument_list|,
argument|const lldb::StreamFileSP&output_sp
argument_list|,
argument|const lldb::StreamFileSP&error_sp
argument_list|,
argument|uint32_t flags
argument_list|,
argument|const char *editline_name
argument_list|,
comment|// Used for saving history files
argument|llvm::StringRef prompt
argument_list|,
argument|llvm::StringRef continuation_prompt
argument_list|,
argument|bool multi_line
argument_list|,
argument|bool color_prompts
argument_list|,
argument|uint32_t line_number_start
argument_list|,
comment|// If non-zero show line numbers
comment|// starting at
comment|// 'line_number_start'
argument|IOHandlerDelegate&delegate
argument_list|)
block|;
name|IOHandlerEditline
argument_list|(
name|Debugger
operator|&
argument_list|,
name|IOHandler
operator|::
name|Type
argument_list|,
specifier|const
name|char
operator|*
argument_list|,
specifier|const
name|char
operator|*
argument_list|,
specifier|const
name|char
operator|*
argument_list|,
name|bool
argument_list|,
name|bool
argument_list|,
name|uint32_t
argument_list|,
name|IOHandlerDelegate
operator|&
argument_list|)
operator|=
name|delete
block|;
name|IOHandlerEditline
argument_list|(
name|Debugger
operator|&
argument_list|,
name|IOHandler
operator|::
name|Type
argument_list|,
specifier|const
name|lldb
operator|::
name|StreamFileSP
operator|&
argument_list|,
specifier|const
name|lldb
operator|::
name|StreamFileSP
operator|&
argument_list|,
specifier|const
name|lldb
operator|::
name|StreamFileSP
operator|&
argument_list|,
name|uint32_t
argument_list|,
specifier|const
name|char
operator|*
argument_list|,
specifier|const
name|char
operator|*
argument_list|,
specifier|const
name|char
operator|*
argument_list|,
name|bool
argument_list|,
name|bool
argument_list|,
name|uint32_t
argument_list|,
name|IOHandlerDelegate
operator|&
argument_list|)
operator|=
name|delete
block|;
operator|~
name|IOHandlerEditline
argument_list|()
name|override
block|;
name|void
name|Run
argument_list|()
name|override
block|;
name|void
name|Cancel
argument_list|()
name|override
block|;
name|bool
name|Interrupt
argument_list|()
name|override
block|;
name|void
name|GotEOF
argument_list|()
name|override
block|;
name|void
name|Activate
argument_list|()
name|override
block|;
name|void
name|Deactivate
argument_list|()
name|override
block|;
name|ConstString
name|GetControlSequence
argument_list|(
argument|char ch
argument_list|)
name|override
block|{
return|return
name|m_delegate
operator|.
name|IOHandlerGetControlSequence
argument_list|(
name|ch
argument_list|)
return|;
block|}
specifier|const
name|char
operator|*
name|GetCommandPrefix
argument_list|()
name|override
block|{
return|return
name|m_delegate
operator|.
name|IOHandlerGetCommandPrefix
argument_list|()
return|;
block|}
specifier|const
name|char
operator|*
name|GetHelpPrologue
argument_list|()
name|override
block|{
return|return
name|m_delegate
operator|.
name|IOHandlerGetHelpPrologue
argument_list|()
return|;
block|}
specifier|const
name|char
operator|*
name|GetPrompt
argument_list|()
name|override
block|;
name|bool
name|SetPrompt
argument_list|(
argument|llvm::StringRef prompt
argument_list|)
name|override
block|;
name|bool
name|SetPrompt
argument_list|(
specifier|const
name|char
operator|*
name|prompt
argument_list|)
operator|=
name|delete
block|;
specifier|const
name|char
operator|*
name|GetContinuationPrompt
argument_list|()
block|;
name|void
name|SetContinuationPrompt
argument_list|(
argument|llvm::StringRef prompt
argument_list|)
block|;
name|void
name|SetContinuationPrompt
argument_list|(
specifier|const
name|char
operator|*
argument_list|)
operator|=
name|delete
block|;
name|bool
name|GetLine
argument_list|(
name|std
operator|::
name|string
operator|&
name|line
argument_list|,
name|bool
operator|&
name|interrupted
argument_list|)
block|;
name|bool
name|GetLines
argument_list|(
name|StringList
operator|&
name|lines
argument_list|,
name|bool
operator|&
name|interrupted
argument_list|)
block|;
name|void
name|SetBaseLineNumber
argument_list|(
argument|uint32_t line
argument_list|)
block|;
name|bool
name|GetInterruptExits
argument_list|()
block|{
return|return
name|m_interrupt_exits
return|;
block|}
name|void
name|SetInterruptExits
argument_list|(
argument|bool b
argument_list|)
block|{
name|m_interrupt_exits
operator|=
name|b
block|; }
specifier|const
name|StringList
operator|*
name|GetCurrentLines
argument_list|()
specifier|const
block|{
return|return
name|m_current_lines_ptr
return|;
block|}
name|uint32_t
name|GetCurrentLineIndex
argument_list|()
specifier|const
block|;
name|void
name|PrintAsync
argument_list|(
argument|Stream *stream
argument_list|,
argument|const char *s
argument_list|,
argument|size_t len
argument_list|)
name|override
block|;
name|private
operator|:
ifndef|#
directive|ifndef
name|LLDB_DISABLE_LIBEDIT
specifier|static
name|bool
name|IsInputCompleteCallback
argument_list|(
name|Editline
operator|*
name|editline
argument_list|,
name|StringList
operator|&
name|lines
argument_list|,
name|void
operator|*
name|baton
argument_list|)
block|;
specifier|static
name|int
name|FixIndentationCallback
argument_list|(
argument|Editline *editline
argument_list|,
argument|const StringList&lines
argument_list|,
argument|int cursor_position
argument_list|,
argument|void *baton
argument_list|)
block|;
specifier|static
name|int
name|AutoCompleteCallback
argument_list|(
argument|const char *current_line
argument_list|,
argument|const char *cursor
argument_list|,
argument|const char *last_char
argument_list|,
argument|int skip_first_n_matches
argument_list|,
argument|int max_matches
argument_list|,
argument|StringList&matches
argument_list|,
argument|void *baton
argument_list|)
block|;
endif|#
directive|endif
name|protected
operator|:
ifndef|#
directive|ifndef
name|LLDB_DISABLE_LIBEDIT
name|std
operator|::
name|unique_ptr
operator|<
name|Editline
operator|>
name|m_editline_ap
block|;
endif|#
directive|endif
name|IOHandlerDelegate
operator|&
name|m_delegate
block|;
name|std
operator|::
name|string
name|m_prompt
block|;
name|std
operator|::
name|string
name|m_continuation_prompt
block|;
name|StringList
operator|*
name|m_current_lines_ptr
block|;
name|uint32_t
name|m_base_line_number
block|;
comment|// If non-zero, then show line numbers in prompt
name|uint32_t
name|m_curr_line_idx
block|;
name|bool
name|m_multi_line
block|;
name|bool
name|m_color_prompts
block|;
name|bool
name|m_interrupt_exits
block|;
name|bool
name|m_editing
block|;
comment|// Set to true when fetching a line manually (not using
comment|// libedit)
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|// The order of base classes is important. Look at the constructor of
end_comment

begin_comment
comment|// IOHandlerConfirm
end_comment

begin_comment
comment|// to see how.
end_comment

begin_decl_stmt
name|class
name|IOHandlerConfirm
range|:
name|public
name|IOHandlerDelegate
decl_stmt|,
name|public
name|IOHandlerEditline
block|{
name|public
label|:
name|IOHandlerConfirm
argument_list|(
argument|Debugger&debugger
argument_list|,
argument|llvm::StringRef prompt
argument_list|,
argument|bool default_response
argument_list|)
empty_stmt|;
operator|~
name|IOHandlerConfirm
argument_list|()
name|override
expr_stmt|;
name|bool
name|GetResponse
argument_list|()
specifier|const
block|{
return|return
name|m_user_response
return|;
block|}
name|int
name|IOHandlerComplete
argument_list|(
name|IOHandler
operator|&
name|io_handler
argument_list|,
specifier|const
name|char
operator|*
name|current_line
argument_list|,
specifier|const
name|char
operator|*
name|cursor
argument_list|,
specifier|const
name|char
operator|*
name|last_char
argument_list|,
name|int
name|skip_first_n_matches
argument_list|,
name|int
name|max_matches
argument_list|,
name|StringList
operator|&
name|matches
argument_list|)
name|override
decl_stmt|;
name|void
name|IOHandlerInputComplete
argument_list|(
name|IOHandler
operator|&
name|io_handler
argument_list|,
name|std
operator|::
name|string
operator|&
name|data
argument_list|)
name|override
decl_stmt|;
name|protected
label|:
specifier|const
name|bool
name|m_default_response
decl_stmt|;
name|bool
name|m_user_response
decl_stmt|;
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_decl_stmt
name|class
name|IOHandlerCursesGUI
range|:
name|public
name|IOHandler
block|{
name|public
operator|:
name|IOHandlerCursesGUI
argument_list|(
name|Debugger
operator|&
name|debugger
argument_list|)
block|;
operator|~
name|IOHandlerCursesGUI
argument_list|()
name|override
block|;
name|void
name|Run
argument_list|()
name|override
block|;
name|void
name|Cancel
argument_list|()
name|override
block|;
name|bool
name|Interrupt
argument_list|()
name|override
block|;
name|void
name|GotEOF
argument_list|()
name|override
block|;
name|void
name|Activate
argument_list|()
name|override
block|;
name|void
name|Deactivate
argument_list|()
name|override
block|;
name|protected
operator|:
name|curses
operator|::
name|ApplicationAP
name|m_app_ap
block|; }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|class
name|IOHandlerCursesValueObjectList
range|:
name|public
name|IOHandler
block|{
name|public
operator|:
name|IOHandlerCursesValueObjectList
argument_list|(
name|Debugger
operator|&
name|debugger
argument_list|,
name|ValueObjectList
operator|&
name|valobj_list
argument_list|)
block|;
operator|~
name|IOHandlerCursesValueObjectList
argument_list|()
name|override
block|;
name|void
name|Run
argument_list|()
name|override
block|;
name|void
name|GotEOF
argument_list|()
name|override
block|;
name|protected
operator|:
name|ValueObjectList
name|m_valobj_list
block|; }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|class
name|IOHandlerStack
block|{
name|public
label|:
name|IOHandlerStack
argument_list|()
operator|:
name|m_stack
argument_list|()
operator|,
name|m_mutex
argument_list|()
operator|,
name|m_top
argument_list|(
argument|nullptr
argument_list|)
block|{}
operator|~
name|IOHandlerStack
argument_list|()
operator|=
expr|default
expr_stmt|;
name|size_t
name|GetSize
argument_list|()
specifier|const
block|{
name|std
operator|::
name|lock_guard
operator|<
name|std
operator|::
name|recursive_mutex
operator|>
name|guard
argument_list|(
name|m_mutex
argument_list|)
block|;
return|return
name|m_stack
operator|.
name|size
argument_list|()
return|;
block|}
name|void
name|Push
argument_list|(
specifier|const
name|lldb
operator|::
name|IOHandlerSP
operator|&
name|sp
argument_list|)
block|{
if|if
condition|(
name|sp
condition|)
block|{
name|std
operator|::
name|lock_guard
operator|<
name|std
operator|::
name|recursive_mutex
operator|>
name|guard
argument_list|(
name|m_mutex
argument_list|)
expr_stmt|;
name|sp
operator|->
name|SetPopped
argument_list|(
name|false
argument_list|)
expr_stmt|;
name|m_stack
operator|.
name|push_back
argument_list|(
name|sp
argument_list|)
expr_stmt|;
comment|// Set m_top the non-locking IsTop() call
name|m_top
operator|=
name|sp
operator|.
name|get
argument_list|()
expr_stmt|;
block|}
block|}
name|bool
name|IsEmpty
argument_list|()
specifier|const
block|{
name|std
operator|::
name|lock_guard
operator|<
name|std
operator|::
name|recursive_mutex
operator|>
name|guard
argument_list|(
name|m_mutex
argument_list|)
block|;
return|return
name|m_stack
operator|.
name|empty
argument_list|()
return|;
block|}
name|lldb
operator|::
name|IOHandlerSP
name|Top
argument_list|()
block|{
name|lldb
operator|::
name|IOHandlerSP
name|sp
block|;
block|{
name|std
operator|::
name|lock_guard
operator|<
name|std
operator|::
name|recursive_mutex
operator|>
name|guard
argument_list|(
name|m_mutex
argument_list|)
block|;
if|if
condition|(
operator|!
name|m_stack
operator|.
name|empty
argument_list|()
condition|)
name|sp
operator|=
name|m_stack
operator|.
name|back
argument_list|()
expr_stmt|;
block|}
return|return
name|sp
return|;
block|}
name|void
name|Pop
parameter_list|()
block|{
name|std
operator|::
name|lock_guard
operator|<
name|std
operator|::
name|recursive_mutex
operator|>
name|guard
argument_list|(
name|m_mutex
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|m_stack
operator|.
name|empty
argument_list|()
condition|)
block|{
name|lldb
operator|::
name|IOHandlerSP
name|sp
argument_list|(
name|m_stack
operator|.
name|back
argument_list|()
argument_list|)
expr_stmt|;
name|m_stack
operator|.
name|pop_back
argument_list|()
expr_stmt|;
name|sp
operator|->
name|SetPopped
argument_list|(
name|true
argument_list|)
expr_stmt|;
block|}
comment|// Set m_top the non-locking IsTop() call
name|m_top
operator|=
operator|(
name|m_stack
operator|.
name|empty
argument_list|()
condition|?
name|nullptr
else|:
name|m_stack
operator|.
name|back
argument_list|()
operator|.
name|get
argument_list|()
operator|)
expr_stmt|;
block|}
name|std
operator|::
name|recursive_mutex
operator|&
name|GetMutex
argument_list|()
block|{
return|return
name|m_mutex
return|;
block|}
name|bool
name|IsTop
argument_list|(
specifier|const
name|lldb
operator|::
name|IOHandlerSP
operator|&
name|io_handler_sp
argument_list|)
decl|const
block|{
return|return
name|m_top
operator|==
name|io_handler_sp
operator|.
name|get
argument_list|()
return|;
block|}
name|bool
name|CheckTopIOHandlerTypes
argument_list|(
name|IOHandler
operator|::
name|Type
name|top_type
argument_list|,
name|IOHandler
operator|::
name|Type
name|second_top_type
argument_list|)
block|{
name|std
operator|::
name|lock_guard
operator|<
name|std
operator|::
name|recursive_mutex
operator|>
name|guard
argument_list|(
name|m_mutex
argument_list|)
expr_stmt|;
specifier|const
name|size_t
name|num_io_handlers
init|=
name|m_stack
operator|.
name|size
argument_list|()
decl_stmt|;
return|return
operator|(
name|num_io_handlers
operator|>=
literal|2
operator|&&
name|m_stack
index|[
name|num_io_handlers
operator|-
literal|1
index|]
operator|->
name|GetType
argument_list|()
operator|==
name|top_type
operator|&&
name|m_stack
index|[
name|num_io_handlers
operator|-
literal|2
index|]
operator|->
name|GetType
argument_list|()
operator|==
name|second_top_type
operator|)
return|;
block|}
name|ConstString
name|GetTopIOHandlerControlSequence
parameter_list|(
name|char
name|ch
parameter_list|)
block|{
return|return
operator|(
operator|(
name|m_top
operator|!=
name|nullptr
operator|)
condition|?
name|m_top
operator|->
name|GetControlSequence
argument_list|(
name|ch
argument_list|)
else|:
name|ConstString
argument_list|()
operator|)
return|;
block|}
specifier|const
name|char
modifier|*
name|GetTopIOHandlerCommandPrefix
parameter_list|()
block|{
return|return
operator|(
operator|(
name|m_top
operator|!=
name|nullptr
operator|)
condition|?
name|m_top
operator|->
name|GetCommandPrefix
argument_list|()
else|:
name|nullptr
operator|)
return|;
block|}
specifier|const
name|char
modifier|*
name|GetTopIOHandlerHelpPrologue
parameter_list|()
block|{
return|return
operator|(
operator|(
name|m_top
operator|!=
name|nullptr
operator|)
condition|?
name|m_top
operator|->
name|GetHelpPrologue
argument_list|()
else|:
name|nullptr
operator|)
return|;
block|}
name|void
name|PrintAsync
parameter_list|(
name|Stream
modifier|*
name|stream
parameter_list|,
specifier|const
name|char
modifier|*
name|s
parameter_list|,
name|size_t
name|len
parameter_list|)
function_decl|;
name|protected
label|:
typedef|typedef
name|std
operator|::
name|vector
operator|<
name|lldb
operator|::
name|IOHandlerSP
operator|>
name|collection
expr_stmt|;
name|collection
name|m_stack
decl_stmt|;
name|mutable
name|std
operator|::
name|recursive_mutex
name|m_mutex
expr_stmt|;
name|IOHandler
modifier|*
name|m_top
decl_stmt|;
name|private
label|:
name|DISALLOW_COPY_AND_ASSIGN
argument_list|(
name|IOHandlerStack
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_comment
unit|}
comment|// namespace lldb_private
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|// liblldb_IOHandler_h_
end_comment

end_unit

