begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===-- llvm/Support/MathExtras.h - Useful math functions -------*- C++ -*-===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file contains some functions that are useful for math stuff.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LLVM_SUPPORT_MATHEXTRAS_H
end_ifndef

begin_define
define|#
directive|define
name|LLVM_SUPPORT_MATHEXTRAS_H
end_define

begin_include
include|#
directive|include
file|"llvm/Support/SwapByteOrder.h"
end_include

begin_decl_stmt
name|namespace
name|llvm
block|{
comment|// NOTE: The following support functions use the _32/_64 extensions instead of
comment|// type overloading so that signed and unsigned integers can be used without
comment|// ambiguity.
comment|/// Hi_32 - This function returns the high 32 bits of a 64 bit value.
specifier|inline
name|uint32_t
name|Hi_32
parameter_list|(
name|uint64_t
name|Value
parameter_list|)
block|{
return|return
name|static_cast
operator|<
name|uint32_t
operator|>
operator|(
name|Value
operator|>>
literal|32
operator|)
return|;
block|}
comment|/// Lo_32 - This function returns the low 32 bits of a 64 bit value.
specifier|inline
name|uint32_t
name|Lo_32
parameter_list|(
name|uint64_t
name|Value
parameter_list|)
block|{
return|return
name|static_cast
operator|<
name|uint32_t
operator|>
operator|(
name|Value
operator|)
return|;
block|}
comment|/// isInt - Checks if an integer fits into the given bit width.
name|template
operator|<
name|unsigned
name|N
operator|>
specifier|inline
name|bool
name|isInt
argument_list|(
argument|int64_t x
argument_list|)
block|{
return|return
name|N
operator|>=
literal|64
operator|||
operator|(
operator|-
operator|(
name|INT64_C
argument_list|(
literal|1
argument_list|)
operator|<<
operator|(
name|N
operator|-
literal|1
operator|)
operator|)
operator|<=
name|x
operator|&&
name|x
operator|<
operator|(
name|INT64_C
argument_list|(
literal|1
argument_list|)
operator|<<
operator|(
name|N
operator|-
literal|1
operator|)
operator|)
operator|)
return|;
block|}
comment|// Template specializations to get better code for common cases.
name|template
operator|<
operator|>
specifier|inline
name|bool
name|isInt
operator|<
literal|8
operator|>
operator|(
name|int64_t
name|x
operator|)
block|{
return|return
name|static_cast
operator|<
name|int8_t
operator|>
operator|(
name|x
operator|)
operator|==
name|x
return|;
block|}
name|template
operator|<
operator|>
specifier|inline
name|bool
name|isInt
operator|<
literal|16
operator|>
operator|(
name|int64_t
name|x
operator|)
block|{
return|return
name|static_cast
operator|<
name|int16_t
operator|>
operator|(
name|x
operator|)
operator|==
name|x
return|;
block|}
name|template
operator|<
operator|>
specifier|inline
name|bool
name|isInt
operator|<
literal|32
operator|>
operator|(
name|int64_t
name|x
operator|)
block|{
return|return
name|static_cast
operator|<
name|int32_t
operator|>
operator|(
name|x
operator|)
operator|==
name|x
return|;
block|}
comment|/// isShiftedInt<N,S> - Checks if a signed integer is an N bit number shifted
comment|///                     left by S.
name|template
operator|<
name|unsigned
name|N
operator|,
name|unsigned
name|S
operator|>
specifier|inline
name|bool
name|isShiftedInt
argument_list|(
argument|int64_t x
argument_list|)
block|{
return|return
name|isInt
operator|<
name|N
operator|+
name|S
operator|>
operator|(
name|x
operator|)
operator|&&
operator|(
name|x
operator|%
operator|(
literal|1
operator|<<
name|S
operator|)
operator|==
literal|0
operator|)
return|;
block|}
comment|/// isUInt - Checks if an unsigned integer fits into the given bit width.
name|template
operator|<
name|unsigned
name|N
operator|>
specifier|inline
name|bool
name|isUInt
argument_list|(
argument|uint64_t x
argument_list|)
block|{
return|return
name|N
operator|>=
literal|64
operator|||
name|x
operator|<
operator|(
name|UINT64_C
argument_list|(
literal|1
argument_list|)
operator|<<
name|N
operator|)
return|;
block|}
comment|// Template specializations to get better code for common cases.
name|template
operator|<
operator|>
specifier|inline
name|bool
name|isUInt
operator|<
literal|8
operator|>
operator|(
name|uint64_t
name|x
operator|)
block|{
return|return
name|static_cast
operator|<
name|uint8_t
operator|>
operator|(
name|x
operator|)
operator|==
name|x
return|;
block|}
name|template
operator|<
operator|>
specifier|inline
name|bool
name|isUInt
operator|<
literal|16
operator|>
operator|(
name|uint64_t
name|x
operator|)
block|{
return|return
name|static_cast
operator|<
name|uint16_t
operator|>
operator|(
name|x
operator|)
operator|==
name|x
return|;
block|}
name|template
operator|<
operator|>
specifier|inline
name|bool
name|isUInt
operator|<
literal|32
operator|>
operator|(
name|uint64_t
name|x
operator|)
block|{
return|return
name|static_cast
operator|<
name|uint32_t
operator|>
operator|(
name|x
operator|)
operator|==
name|x
return|;
block|}
comment|/// isShiftedUInt<N,S> - Checks if a unsigned integer is an N bit number shifted
comment|///                     left by S.
name|template
operator|<
name|unsigned
name|N
operator|,
name|unsigned
name|S
operator|>
specifier|inline
name|bool
name|isShiftedUInt
argument_list|(
argument|uint64_t x
argument_list|)
block|{
return|return
name|isUInt
operator|<
name|N
operator|+
name|S
operator|>
operator|(
name|x
operator|)
operator|&&
operator|(
name|x
operator|%
operator|(
literal|1
operator|<<
name|S
operator|)
operator|==
literal|0
operator|)
return|;
block|}
comment|/// isUIntN - Checks if an unsigned integer fits into the given (dynamic)
comment|/// bit width.
specifier|inline
name|bool
name|isUIntN
parameter_list|(
name|unsigned
name|N
parameter_list|,
name|uint64_t
name|x
parameter_list|)
block|{
return|return
name|x
operator|==
operator|(
name|x
operator|&
operator|(
operator|~
literal|0ULL
operator|>>
operator|(
literal|64
operator|-
name|N
operator|)
operator|)
operator|)
return|;
block|}
comment|/// isIntN - Checks if an signed integer fits into the given (dynamic)
comment|/// bit width.
specifier|inline
name|bool
name|isIntN
parameter_list|(
name|unsigned
name|N
parameter_list|,
name|int64_t
name|x
parameter_list|)
block|{
return|return
name|N
operator|>=
literal|64
operator|||
operator|(
operator|-
operator|(
name|INT64_C
argument_list|(
literal|1
argument_list|)
operator|<<
operator|(
name|N
operator|-
literal|1
operator|)
operator|)
operator|<=
name|x
operator|&&
name|x
operator|<
operator|(
name|INT64_C
argument_list|(
literal|1
argument_list|)
operator|<<
operator|(
name|N
operator|-
literal|1
operator|)
operator|)
operator|)
return|;
block|}
comment|/// isMask_32 - This function returns true if the argument is a sequence of ones
comment|/// starting at the least significant bit with the remainder zero (32 bit
comment|/// version).   Ex. isMask_32(0x0000FFFFU) == true.
specifier|inline
name|bool
name|isMask_32
parameter_list|(
name|uint32_t
name|Value
parameter_list|)
block|{
return|return
name|Value
operator|&&
operator|(
operator|(
name|Value
operator|+
literal|1
operator|)
operator|&
name|Value
operator|)
operator|==
literal|0
return|;
block|}
comment|/// isMask_64 - This function returns true if the argument is a sequence of ones
comment|/// starting at the least significant bit with the remainder zero (64 bit
comment|/// version).
specifier|inline
name|bool
name|isMask_64
parameter_list|(
name|uint64_t
name|Value
parameter_list|)
block|{
return|return
name|Value
operator|&&
operator|(
operator|(
name|Value
operator|+
literal|1
operator|)
operator|&
name|Value
operator|)
operator|==
literal|0
return|;
block|}
comment|/// isShiftedMask_32 - This function returns true if the argument contains a
comment|/// sequence of ones with the remainder zero (32 bit version.)
comment|/// Ex. isShiftedMask_32(0x0000FF00U) == true.
specifier|inline
name|bool
name|isShiftedMask_32
parameter_list|(
name|uint32_t
name|Value
parameter_list|)
block|{
return|return
name|isMask_32
argument_list|(
operator|(
name|Value
operator|-
literal|1
operator|)
operator||
name|Value
argument_list|)
return|;
block|}
comment|/// isShiftedMask_64 - This function returns true if the argument contains a
comment|/// sequence of ones with the remainder zero (64 bit version.)
specifier|inline
name|bool
name|isShiftedMask_64
parameter_list|(
name|uint64_t
name|Value
parameter_list|)
block|{
return|return
name|isMask_64
argument_list|(
operator|(
name|Value
operator|-
literal|1
operator|)
operator||
name|Value
argument_list|)
return|;
block|}
comment|/// isPowerOf2_32 - This function returns true if the argument is a power of
comment|/// two> 0. Ex. isPowerOf2_32(0x00100000U) == true (32 bit edition.)
specifier|inline
name|bool
name|isPowerOf2_32
parameter_list|(
name|uint32_t
name|Value
parameter_list|)
block|{
return|return
name|Value
operator|&&
operator|!
operator|(
name|Value
operator|&
operator|(
name|Value
operator|-
literal|1
operator|)
operator|)
return|;
block|}
comment|/// isPowerOf2_64 - This function returns true if the argument is a power of two
comment|///> 0 (64 bit edition.)
specifier|inline
name|bool
name|isPowerOf2_64
parameter_list|(
name|uint64_t
name|Value
parameter_list|)
block|{
return|return
name|Value
operator|&&
operator|!
operator|(
name|Value
operator|&
operator|(
name|Value
operator|-
name|int64_t
argument_list|(
literal|1L
argument_list|)
operator|)
operator|)
return|;
block|}
comment|/// ByteSwap_16 - This function returns a byte-swapped representation of the
comment|/// 16-bit argument, Value.
specifier|inline
name|uint16_t
name|ByteSwap_16
parameter_list|(
name|uint16_t
name|Value
parameter_list|)
block|{
return|return
name|sys
operator|::
name|SwapByteOrder_16
argument_list|(
name|Value
argument_list|)
return|;
block|}
comment|/// ByteSwap_32 - This function returns a byte-swapped representation of the
comment|/// 32-bit argument, Value.
specifier|inline
name|uint32_t
name|ByteSwap_32
parameter_list|(
name|uint32_t
name|Value
parameter_list|)
block|{
return|return
name|sys
operator|::
name|SwapByteOrder_32
argument_list|(
name|Value
argument_list|)
return|;
block|}
comment|/// ByteSwap_64 - This function returns a byte-swapped representation of the
comment|/// 64-bit argument, Value.
specifier|inline
name|uint64_t
name|ByteSwap_64
parameter_list|(
name|uint64_t
name|Value
parameter_list|)
block|{
return|return
name|sys
operator|::
name|SwapByteOrder_64
argument_list|(
name|Value
argument_list|)
return|;
block|}
comment|/// CountLeadingZeros_32 - this function performs the platform optimal form of
comment|/// counting the number of zeros from the most significant bit to the first one
comment|/// bit.  Ex. CountLeadingZeros_32(0x00F000FF) == 8.
comment|/// Returns 32 if the word is zero.
specifier|inline
name|unsigned
name|CountLeadingZeros_32
parameter_list|(
name|uint32_t
name|Value
parameter_list|)
block|{
name|unsigned
name|Count
decl_stmt|;
comment|// result
if|#
directive|if
name|__GNUC__
operator|>=
literal|4
comment|// PowerPC is defined for __builtin_clz(0)
if|#
directive|if
operator|!
name|defined
argument_list|(
name|__ppc__
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__ppc64__
argument_list|)
if|if
condition|(
operator|!
name|Value
condition|)
return|return
literal|32
return|;
endif|#
directive|endif
name|Count
operator|=
name|__builtin_clz
argument_list|(
name|Value
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
operator|!
name|Value
condition|)
return|return
literal|32
return|;
name|Count
operator|=
literal|0
expr_stmt|;
comment|// bisection method for count leading zeros
for|for
control|(
name|unsigned
name|Shift
init|=
literal|32
operator|>>
literal|1
init|;
name|Shift
condition|;
name|Shift
operator|>>=
literal|1
control|)
block|{
name|uint32_t
name|Tmp
init|=
name|Value
operator|>>
name|Shift
decl_stmt|;
if|if
condition|(
name|Tmp
condition|)
block|{
name|Value
operator|=
name|Tmp
expr_stmt|;
block|}
else|else
block|{
name|Count
operator||=
name|Shift
expr_stmt|;
block|}
block|}
endif|#
directive|endif
return|return
name|Count
return|;
block|}
comment|/// CountLeadingOnes_32 - this function performs the operation of
comment|/// counting the number of ones from the most significant bit to the first zero
comment|/// bit.  Ex. CountLeadingOnes_32(0xFF0FFF00) == 8.
comment|/// Returns 32 if the word is all ones.
specifier|inline
name|unsigned
name|CountLeadingOnes_32
parameter_list|(
name|uint32_t
name|Value
parameter_list|)
block|{
return|return
name|CountLeadingZeros_32
argument_list|(
operator|~
name|Value
argument_list|)
return|;
block|}
comment|/// CountLeadingZeros_64 - This function performs the platform optimal form
comment|/// of counting the number of zeros from the most significant bit to the first
comment|/// one bit (64 bit edition.)
comment|/// Returns 64 if the word is zero.
specifier|inline
name|unsigned
name|CountLeadingZeros_64
parameter_list|(
name|uint64_t
name|Value
parameter_list|)
block|{
name|unsigned
name|Count
decl_stmt|;
comment|// result
if|#
directive|if
name|__GNUC__
operator|>=
literal|4
comment|// PowerPC is defined for __builtin_clzll(0)
if|#
directive|if
operator|!
name|defined
argument_list|(
name|__ppc__
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__ppc64__
argument_list|)
if|if
condition|(
operator|!
name|Value
condition|)
return|return
literal|64
return|;
endif|#
directive|endif
name|Count
operator|=
name|__builtin_clzll
argument_list|(
name|Value
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
sizeof|sizeof
argument_list|(
name|long
argument_list|)
operator|==
sizeof|sizeof
argument_list|(
name|int64_t
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|Value
condition|)
return|return
literal|64
return|;
name|Count
operator|=
literal|0
expr_stmt|;
comment|// bisection method for count leading zeros
for|for
control|(
name|unsigned
name|Shift
init|=
literal|64
operator|>>
literal|1
init|;
name|Shift
condition|;
name|Shift
operator|>>=
literal|1
control|)
block|{
name|uint64_t
name|Tmp
init|=
name|Value
operator|>>
name|Shift
decl_stmt|;
if|if
condition|(
name|Tmp
condition|)
block|{
name|Value
operator|=
name|Tmp
expr_stmt|;
block|}
else|else
block|{
name|Count
operator||=
name|Shift
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
comment|// get hi portion
name|uint32_t
name|Hi
init|=
name|Hi_32
argument_list|(
name|Value
argument_list|)
decl_stmt|;
comment|// if some bits in hi portion
if|if
condition|(
name|Hi
condition|)
block|{
comment|// leading zeros in hi portion plus all bits in lo portion
name|Count
operator|=
name|CountLeadingZeros_32
argument_list|(
name|Hi
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// get lo portion
name|uint32_t
name|Lo
init|=
name|Lo_32
argument_list|(
name|Value
argument_list|)
decl_stmt|;
comment|// same as 32 bit value
name|Count
operator|=
name|CountLeadingZeros_32
argument_list|(
name|Lo
argument_list|)
operator|+
literal|32
expr_stmt|;
block|}
block|}
endif|#
directive|endif
return|return
name|Count
return|;
block|}
comment|/// CountLeadingOnes_64 - This function performs the operation
comment|/// of counting the number of ones from the most significant bit to the first
comment|/// zero bit (64 bit edition.)
comment|/// Returns 64 if the word is all ones.
specifier|inline
name|unsigned
name|CountLeadingOnes_64
parameter_list|(
name|uint64_t
name|Value
parameter_list|)
block|{
return|return
name|CountLeadingZeros_64
argument_list|(
operator|~
name|Value
argument_list|)
return|;
block|}
comment|/// CountTrailingZeros_32 - this function performs the platform optimal form of
comment|/// counting the number of zeros from the least significant bit to the first one
comment|/// bit.  Ex. CountTrailingZeros_32(0xFF00FF00) == 8.
comment|/// Returns 32 if the word is zero.
specifier|inline
name|unsigned
name|CountTrailingZeros_32
parameter_list|(
name|uint32_t
name|Value
parameter_list|)
block|{
if|#
directive|if
name|__GNUC__
operator|>=
literal|4
return|return
name|Value
condition|?
name|__builtin_ctz
argument_list|(
name|Value
argument_list|)
else|:
literal|32
return|;
else|#
directive|else
specifier|static
specifier|const
name|unsigned
name|Mod37BitPosition
index|[]
init|=
block|{
literal|32
block|,
literal|0
block|,
literal|1
block|,
literal|26
block|,
literal|2
block|,
literal|23
block|,
literal|27
block|,
literal|0
block|,
literal|3
block|,
literal|16
block|,
literal|24
block|,
literal|30
block|,
literal|28
block|,
literal|11
block|,
literal|0
block|,
literal|13
block|,
literal|4
block|,
literal|7
block|,
literal|17
block|,
literal|0
block|,
literal|25
block|,
literal|22
block|,
literal|31
block|,
literal|15
block|,
literal|29
block|,
literal|10
block|,
literal|12
block|,
literal|6
block|,
literal|0
block|,
literal|21
block|,
literal|14
block|,
literal|9
block|,
literal|5
block|,
literal|20
block|,
literal|8
block|,
literal|19
block|,
literal|18
block|}
decl_stmt|;
return|return
name|Mod37BitPosition
index|[
operator|(
operator|-
name|Value
operator|&
name|Value
operator|)
operator|%
literal|37
index|]
return|;
endif|#
directive|endif
block|}
comment|/// CountTrailingOnes_32 - this function performs the operation of
comment|/// counting the number of ones from the least significant bit to the first zero
comment|/// bit.  Ex. CountTrailingOnes_32(0x00FF00FF) == 8.
comment|/// Returns 32 if the word is all ones.
specifier|inline
name|unsigned
name|CountTrailingOnes_32
parameter_list|(
name|uint32_t
name|Value
parameter_list|)
block|{
return|return
name|CountTrailingZeros_32
argument_list|(
operator|~
name|Value
argument_list|)
return|;
block|}
comment|/// CountTrailingZeros_64 - This function performs the platform optimal form
comment|/// of counting the number of zeros from the least significant bit to the first
comment|/// one bit (64 bit edition.)
comment|/// Returns 64 if the word is zero.
specifier|inline
name|unsigned
name|CountTrailingZeros_64
parameter_list|(
name|uint64_t
name|Value
parameter_list|)
block|{
if|#
directive|if
name|__GNUC__
operator|>=
literal|4
return|return
name|Value
condition|?
name|__builtin_ctzll
argument_list|(
name|Value
argument_list|)
else|:
literal|64
return|;
else|#
directive|else
specifier|static
specifier|const
name|unsigned
name|Mod67Position
index|[]
init|=
block|{
literal|64
block|,
literal|0
block|,
literal|1
block|,
literal|39
block|,
literal|2
block|,
literal|15
block|,
literal|40
block|,
literal|23
block|,
literal|3
block|,
literal|12
block|,
literal|16
block|,
literal|59
block|,
literal|41
block|,
literal|19
block|,
literal|24
block|,
literal|54
block|,
literal|4
block|,
literal|64
block|,
literal|13
block|,
literal|10
block|,
literal|17
block|,
literal|62
block|,
literal|60
block|,
literal|28
block|,
literal|42
block|,
literal|30
block|,
literal|20
block|,
literal|51
block|,
literal|25
block|,
literal|44
block|,
literal|55
block|,
literal|47
block|,
literal|5
block|,
literal|32
block|,
literal|65
block|,
literal|38
block|,
literal|14
block|,
literal|22
block|,
literal|11
block|,
literal|58
block|,
literal|18
block|,
literal|53
block|,
literal|63
block|,
literal|9
block|,
literal|61
block|,
literal|27
block|,
literal|29
block|,
literal|50
block|,
literal|43
block|,
literal|46
block|,
literal|31
block|,
literal|37
block|,
literal|21
block|,
literal|57
block|,
literal|52
block|,
literal|8
block|,
literal|26
block|,
literal|49
block|,
literal|45
block|,
literal|36
block|,
literal|56
block|,
literal|7
block|,
literal|48
block|,
literal|35
block|,
literal|6
block|,
literal|34
block|,
literal|33
block|,
literal|0
block|}
decl_stmt|;
return|return
name|Mod67Position
index|[
operator|(
operator|-
name|Value
operator|&
name|Value
operator|)
operator|%
literal|67
index|]
return|;
endif|#
directive|endif
block|}
comment|/// CountTrailingOnes_64 - This function performs the operation
comment|/// of counting the number of ones from the least significant bit to the first
comment|/// zero bit (64 bit edition.)
comment|/// Returns 64 if the word is all ones.
specifier|inline
name|unsigned
name|CountTrailingOnes_64
parameter_list|(
name|uint64_t
name|Value
parameter_list|)
block|{
return|return
name|CountTrailingZeros_64
argument_list|(
operator|~
name|Value
argument_list|)
return|;
block|}
comment|/// CountPopulation_32 - this function counts the number of set bits in a value.
comment|/// Ex. CountPopulation(0xF000F000) = 8
comment|/// Returns 0 if the word is zero.
specifier|inline
name|unsigned
name|CountPopulation_32
parameter_list|(
name|uint32_t
name|Value
parameter_list|)
block|{
if|#
directive|if
name|__GNUC__
operator|>=
literal|4
return|return
name|__builtin_popcount
argument_list|(
name|Value
argument_list|)
return|;
else|#
directive|else
name|uint32_t
name|v
init|=
name|Value
operator|-
operator|(
operator|(
name|Value
operator|>>
literal|1
operator|)
operator|&
literal|0x55555555
operator|)
decl_stmt|;
name|v
operator|=
operator|(
name|v
operator|&
literal|0x33333333
operator|)
operator|+
operator|(
operator|(
name|v
operator|>>
literal|2
operator|)
operator|&
literal|0x33333333
operator|)
expr_stmt|;
return|return
operator|(
operator|(
name|v
operator|+
operator|(
name|v
operator|>>
literal|4
operator|)
operator|&
literal|0xF0F0F0F
operator|)
operator|*
literal|0x1010101
operator|)
operator|>>
literal|24
return|;
endif|#
directive|endif
block|}
comment|/// CountPopulation_64 - this function counts the number of set bits in a value,
comment|/// (64 bit edition.)
specifier|inline
name|unsigned
name|CountPopulation_64
parameter_list|(
name|uint64_t
name|Value
parameter_list|)
block|{
if|#
directive|if
name|__GNUC__
operator|>=
literal|4
return|return
name|__builtin_popcountll
argument_list|(
name|Value
argument_list|)
return|;
else|#
directive|else
name|uint64_t
name|v
init|=
name|Value
operator|-
operator|(
operator|(
name|Value
operator|>>
literal|1
operator|)
operator|&
literal|0x5555555555555555ULL
operator|)
decl_stmt|;
name|v
operator|=
operator|(
name|v
operator|&
literal|0x3333333333333333ULL
operator|)
operator|+
operator|(
operator|(
name|v
operator|>>
literal|2
operator|)
operator|&
literal|0x3333333333333333ULL
operator|)
expr_stmt|;
name|v
operator|=
operator|(
name|v
operator|+
operator|(
name|v
operator|>>
literal|4
operator|)
operator|)
operator|&
literal|0x0F0F0F0F0F0F0F0FULL
expr_stmt|;
return|return
name|unsigned
argument_list|(
call|(
name|uint64_t
call|)
argument_list|(
name|v
operator|*
literal|0x0101010101010101ULL
argument_list|)
operator|>>
literal|56
argument_list|)
return|;
endif|#
directive|endif
block|}
comment|/// Log2_32 - This function returns the floor log base 2 of the specified value,
comment|/// -1 if the value is zero. (32 bit edition.)
comment|/// Ex. Log2_32(32) == 5, Log2_32(1) == 0, Log2_32(0) == -1, Log2_32(6) == 2
specifier|inline
name|unsigned
name|Log2_32
parameter_list|(
name|uint32_t
name|Value
parameter_list|)
block|{
return|return
literal|31
operator|-
name|CountLeadingZeros_32
argument_list|(
name|Value
argument_list|)
return|;
block|}
comment|/// Log2_64 - This function returns the floor log base 2 of the specified value,
comment|/// -1 if the value is zero. (64 bit edition.)
specifier|inline
name|unsigned
name|Log2_64
parameter_list|(
name|uint64_t
name|Value
parameter_list|)
block|{
return|return
literal|63
operator|-
name|CountLeadingZeros_64
argument_list|(
name|Value
argument_list|)
return|;
block|}
comment|/// Log2_32_Ceil - This function returns the ceil log base 2 of the specified
comment|/// value, 32 if the value is zero. (32 bit edition).
comment|/// Ex. Log2_32_Ceil(32) == 5, Log2_32_Ceil(1) == 0, Log2_32_Ceil(6) == 3
specifier|inline
name|unsigned
name|Log2_32_Ceil
parameter_list|(
name|uint32_t
name|Value
parameter_list|)
block|{
return|return
literal|32
operator|-
name|CountLeadingZeros_32
argument_list|(
name|Value
operator|-
literal|1
argument_list|)
return|;
block|}
comment|/// Log2_64_Ceil - This function returns the ceil log base 2 of the specified
comment|/// value, 64 if the value is zero. (64 bit edition.)
specifier|inline
name|unsigned
name|Log2_64_Ceil
parameter_list|(
name|uint64_t
name|Value
parameter_list|)
block|{
return|return
literal|64
operator|-
name|CountLeadingZeros_64
argument_list|(
name|Value
operator|-
literal|1
argument_list|)
return|;
block|}
comment|/// GreatestCommonDivisor64 - Return the greatest common divisor of the two
comment|/// values using Euclid's algorithm.
specifier|inline
name|uint64_t
name|GreatestCommonDivisor64
parameter_list|(
name|uint64_t
name|A
parameter_list|,
name|uint64_t
name|B
parameter_list|)
block|{
while|while
condition|(
name|B
condition|)
block|{
name|uint64_t
name|T
init|=
name|B
decl_stmt|;
name|B
operator|=
name|A
operator|%
name|B
expr_stmt|;
name|A
operator|=
name|T
expr_stmt|;
block|}
return|return
name|A
return|;
block|}
comment|/// BitsToDouble - This function takes a 64-bit integer and returns the bit
comment|/// equivalent double.
specifier|inline
name|double
name|BitsToDouble
parameter_list|(
name|uint64_t
name|Bits
parameter_list|)
block|{
union|union
block|{
name|uint64_t
name|L
decl_stmt|;
name|double
name|D
decl_stmt|;
block|}
name|T
union|;
name|T
operator|.
name|L
operator|=
name|Bits
expr_stmt|;
return|return
name|T
operator|.
name|D
return|;
block|}
comment|/// BitsToFloat - This function takes a 32-bit integer and returns the bit
comment|/// equivalent float.
specifier|inline
name|float
name|BitsToFloat
parameter_list|(
name|uint32_t
name|Bits
parameter_list|)
block|{
union|union
block|{
name|uint32_t
name|I
decl_stmt|;
name|float
name|F
decl_stmt|;
block|}
name|T
union|;
name|T
operator|.
name|I
operator|=
name|Bits
expr_stmt|;
return|return
name|T
operator|.
name|F
return|;
block|}
comment|/// DoubleToBits - This function takes a double and returns the bit
comment|/// equivalent 64-bit integer.  Note that copying doubles around
comment|/// changes the bits of NaNs on some hosts, notably x86, so this
comment|/// routine cannot be used if these bits are needed.
specifier|inline
name|uint64_t
name|DoubleToBits
parameter_list|(
name|double
name|Double
parameter_list|)
block|{
union|union
block|{
name|uint64_t
name|L
decl_stmt|;
name|double
name|D
decl_stmt|;
block|}
name|T
union|;
name|T
operator|.
name|D
operator|=
name|Double
expr_stmt|;
return|return
name|T
operator|.
name|L
return|;
block|}
comment|/// FloatToBits - This function takes a float and returns the bit
comment|/// equivalent 32-bit integer.  Note that copying floats around
comment|/// changes the bits of NaNs on some hosts, notably x86, so this
comment|/// routine cannot be used if these bits are needed.
specifier|inline
name|uint32_t
name|FloatToBits
parameter_list|(
name|float
name|Float
parameter_list|)
block|{
union|union
block|{
name|uint32_t
name|I
decl_stmt|;
name|float
name|F
decl_stmt|;
block|}
name|T
union|;
name|T
operator|.
name|F
operator|=
name|Float
expr_stmt|;
return|return
name|T
operator|.
name|I
return|;
block|}
comment|/// Platform-independent wrappers for the C99 isnan() function.
name|int
name|IsNAN
parameter_list|(
name|float
name|f
parameter_list|)
function_decl|;
name|int
name|IsNAN
parameter_list|(
name|double
name|d
parameter_list|)
function_decl|;
comment|/// Platform-independent wrappers for the C99 isinf() function.
name|int
name|IsInf
parameter_list|(
name|float
name|f
parameter_list|)
function_decl|;
name|int
name|IsInf
parameter_list|(
name|double
name|d
parameter_list|)
function_decl|;
comment|/// MinAlign - A and B are either alignments or offsets.  Return the minimum
comment|/// alignment that may be assumed after adding the two together.
specifier|static
specifier|inline
name|uint64_t
name|MinAlign
parameter_list|(
name|uint64_t
name|A
parameter_list|,
name|uint64_t
name|B
parameter_list|)
block|{
comment|// The largest power of 2 that divides both A and B.
return|return
operator|(
name|A
operator||
name|B
operator|)
operator|&
operator|-
operator|(
name|A
operator||
name|B
operator|)
return|;
block|}
comment|/// NextPowerOf2 - Returns the next power of two (in 64-bits)
comment|/// that is strictly greater than A.  Returns zero on overflow.
specifier|static
specifier|inline
name|uint64_t
name|NextPowerOf2
parameter_list|(
name|uint64_t
name|A
parameter_list|)
block|{
name|A
operator||=
operator|(
name|A
operator|>>
literal|1
operator|)
expr_stmt|;
name|A
operator||=
operator|(
name|A
operator|>>
literal|2
operator|)
expr_stmt|;
name|A
operator||=
operator|(
name|A
operator|>>
literal|4
operator|)
expr_stmt|;
name|A
operator||=
operator|(
name|A
operator|>>
literal|8
operator|)
expr_stmt|;
name|A
operator||=
operator|(
name|A
operator|>>
literal|16
operator|)
expr_stmt|;
name|A
operator||=
operator|(
name|A
operator|>>
literal|32
operator|)
expr_stmt|;
return|return
name|A
operator|+
literal|1
return|;
block|}
comment|/// RoundUpToAlignment - Returns the next integer (mod 2**64) that is
comment|/// greater than or equal to \arg Value and is a multiple of \arg
comment|/// Align. Align must be non-zero.
comment|///
comment|/// Examples:
comment|/// RoundUpToAlignment(5, 8) = 8
comment|/// RoundUpToAlignment(17, 8) = 24
comment|/// RoundUpToAlignment(~0LL, 8) = 0
specifier|inline
name|uint64_t
name|RoundUpToAlignment
parameter_list|(
name|uint64_t
name|Value
parameter_list|,
name|uint64_t
name|Align
parameter_list|)
block|{
return|return
operator|(
operator|(
name|Value
operator|+
name|Align
operator|-
literal|1
operator|)
operator|/
name|Align
operator|)
operator|*
name|Align
return|;
block|}
comment|/// OffsetToAlignment - Return the offset to the next integer (mod 2**64) that
comment|/// is greater than or equal to \arg Value and is a multiple of \arg
comment|/// Align. Align must be non-zero.
specifier|inline
name|uint64_t
name|OffsetToAlignment
parameter_list|(
name|uint64_t
name|Value
parameter_list|,
name|uint64_t
name|Align
parameter_list|)
block|{
return|return
name|RoundUpToAlignment
argument_list|(
name|Value
argument_list|,
name|Align
argument_list|)
operator|-
name|Value
return|;
block|}
comment|/// abs64 - absolute value of a 64-bit int.  Not all environments support
comment|/// "abs" on whatever their name for the 64-bit int type is.  The absolute
comment|/// value of the largest negative number is undefined, as with "abs".
specifier|inline
name|int64_t
name|abs64
parameter_list|(
name|int64_t
name|x
parameter_list|)
block|{
return|return
operator|(
name|x
operator|<
literal|0
operator|)
condition|?
operator|-
name|x
else|:
name|x
return|;
block|}
comment|/// SignExtend32 - Sign extend B-bit number x to 32-bit int.
comment|/// Usage int32_t r = SignExtend32<5>(x);
name|template
operator|<
name|unsigned
name|B
operator|>
specifier|inline
name|int32_t
name|SignExtend32
argument_list|(
argument|uint32_t x
argument_list|)
block|{
return|return
name|int32_t
argument_list|(
name|x
operator|<<
operator|(
literal|32
operator|-
name|B
operator|)
argument_list|)
operator|>>
operator|(
literal|32
operator|-
name|B
operator|)
return|;
block|}
comment|/// SignExtend64 - Sign extend B-bit number x to 64-bit int.
comment|/// Usage int64_t r = SignExtend64<5>(x);
name|template
operator|<
name|unsigned
name|B
operator|>
specifier|inline
name|int64_t
name|SignExtend64
argument_list|(
argument|uint64_t x
argument_list|)
block|{
return|return
name|int64_t
argument_list|(
name|x
operator|<<
operator|(
literal|64
operator|-
name|B
operator|)
argument_list|)
operator|>>
operator|(
literal|64
operator|-
name|B
operator|)
return|;
block|}
block|}
end_decl_stmt

begin_comment
comment|// End llvm namespace
end_comment

begin_endif
endif|#
directive|endif
end_endif

end_unit

