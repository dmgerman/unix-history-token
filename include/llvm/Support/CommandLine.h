begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===- llvm/Support/CommandLine.h - Command line handler --------*- C++ -*-===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This class implements a command line argument processor that is useful when
end_comment

begin_comment
comment|// creating a tool.  It provides a simple, minimalistic interface that is easily
end_comment

begin_comment
comment|// extensible and supports nonlocal (library) command line options.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// Note that rather than trying to figure out what this code does, you should
end_comment

begin_comment
comment|// read the library documentation located in docs/CommandLine.html or looks at
end_comment

begin_comment
comment|// the many example usages in tools/*/*.cpp
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LLVM_SUPPORT_COMMANDLINE_H
end_ifndef

begin_define
define|#
directive|define
name|LLVM_SUPPORT_COMMANDLINE_H
end_define

begin_include
include|#
directive|include
file|"llvm/Support/type_traits.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/Compiler.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/SmallVector.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/Twine.h"
end_include

begin_include
include|#
directive|include
file|<cassert>
end_include

begin_include
include|#
directive|include
file|<climits>
end_include

begin_include
include|#
directive|include
file|<cstdarg>
end_include

begin_include
include|#
directive|include
file|<utility>
end_include

begin_include
include|#
directive|include
file|<vector>
end_include

begin_decl_stmt
name|namespace
name|llvm
block|{
comment|/// cl Namespace - This namespace contains all of the command line option
comment|/// processing machinery.  It is intentionally a short name to make qualified
comment|/// usage concise.
name|namespace
name|cl
block|{
comment|//===----------------------------------------------------------------------===//
comment|// ParseCommandLineOptions - Command line option processing entry point.
comment|//
name|void
name|ParseCommandLineOptions
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|,
specifier|const
name|char
modifier|*
name|Overview
init|=
literal|0
parameter_list|,
name|bool
name|ReadResponseFiles
init|=
name|false
parameter_list|)
function_decl|;
comment|//===----------------------------------------------------------------------===//
comment|// ParseEnvironmentOptions - Environment variable option processing alternate
comment|//                           entry point.
comment|//
name|void
name|ParseEnvironmentOptions
parameter_list|(
specifier|const
name|char
modifier|*
name|progName
parameter_list|,
specifier|const
name|char
modifier|*
name|envvar
parameter_list|,
specifier|const
name|char
modifier|*
name|Overview
init|=
literal|0
parameter_list|,
name|bool
name|ReadResponseFiles
init|=
name|false
parameter_list|)
function_decl|;
comment|///===---------------------------------------------------------------------===//
comment|/// SetVersionPrinter - Override the default (LLVM specific) version printer
comment|///                     used to print out the version when --version is given
comment|///                     on the command line. This allows other systems using the
comment|///                     CommandLine utilities to print their own version string.
name|void
name|SetVersionPrinter
parameter_list|(
name|void
function_decl|(
modifier|*
name|func
function_decl|)
parameter_list|()
parameter_list|)
function_decl|;
comment|// MarkOptionsChanged - Internal helper function.
name|void
name|MarkOptionsChanged
parameter_list|()
function_decl|;
comment|//===----------------------------------------------------------------------===//
comment|// Flags permitted to be passed to command line arguments
comment|//
enum|enum
name|NumOccurrencesFlag
block|{
comment|// Flags for the number of occurrences allowed
name|Optional
init|=
literal|0x01
block|,
comment|// Zero or One occurrence
name|ZeroOrMore
init|=
literal|0x02
block|,
comment|// Zero or more occurrences allowed
name|Required
init|=
literal|0x03
block|,
comment|// One occurrence required
name|OneOrMore
init|=
literal|0x04
block|,
comment|// One or more occurrences required
comment|// ConsumeAfter - Indicates that this option is fed anything that follows the
comment|// last positional argument required by the application (it is an error if
comment|// there are zero positional arguments, and a ConsumeAfter option is used).
comment|// Thus, for example, all arguments to LLI are processed until a filename is
comment|// found.  Once a filename is found, all of the succeeding arguments are
comment|// passed, unprocessed, to the ConsumeAfter option.
comment|//
name|ConsumeAfter
init|=
literal|0x05
block|,
name|OccurrencesMask
init|=
literal|0x07
block|}
enum|;
enum|enum
name|ValueExpected
block|{
comment|// Is a value required for the option?
name|ValueOptional
init|=
literal|0x08
block|,
comment|// The value can appear... or not
name|ValueRequired
init|=
literal|0x10
block|,
comment|// The value is required to appear!
name|ValueDisallowed
init|=
literal|0x18
block|,
comment|// A value may not be specified (for flags)
name|ValueMask
init|=
literal|0x18
block|}
enum|;
enum|enum
name|OptionHidden
block|{
comment|// Control whether -help shows this option
name|NotHidden
init|=
literal|0x20
block|,
comment|// Option included in --help& --help-hidden
name|Hidden
init|=
literal|0x40
block|,
comment|// -help doesn't, but --help-hidden does
name|ReallyHidden
init|=
literal|0x60
block|,
comment|// Neither --help nor --help-hidden show this arg
name|HiddenMask
init|=
literal|0x60
block|}
enum|;
comment|// Formatting flags - This controls special features that the option might have
comment|// that cause it to be parsed differently...
comment|//
comment|// Prefix - This option allows arguments that are otherwise unrecognized to be
comment|// matched by options that are a prefix of the actual value.  This is useful for
comment|// cases like a linker, where options are typically of the form '-lfoo' or
comment|// '-L../../include' where -l or -L are the actual flags.  When prefix is
comment|// enabled, and used, the value for the flag comes from the suffix of the
comment|// argument.
comment|//
comment|// Grouping - With this option enabled, multiple letter options are allowed to
comment|// bunch together with only a single hyphen for the whole group.  This allows
comment|// emulation of the behavior that ls uses for example: ls -la === ls -l -a
comment|//
enum|enum
name|FormattingFlags
block|{
name|NormalFormatting
init|=
literal|0x000
block|,
comment|// Nothing special
name|Positional
init|=
literal|0x080
block|,
comment|// Is a positional argument, no '-' required
name|Prefix
init|=
literal|0x100
block|,
comment|// Can this option directly prefix its value?
name|Grouping
init|=
literal|0x180
block|,
comment|// Can this option group with other options?
name|FormattingMask
init|=
literal|0x180
comment|// Union of the above flags.
block|}
enum|;
enum|enum
name|MiscFlags
block|{
comment|// Miscellaneous flags to adjust argument
name|CommaSeparated
init|=
literal|0x200
block|,
comment|// Should this cl::list split between commas?
name|PositionalEatsArgs
init|=
literal|0x400
block|,
comment|// Should this positional cl::list eat -args?
name|Sink
init|=
literal|0x800
block|,
comment|// Should this cl::list eat all unknown options?
name|MiscMask
init|=
literal|0xE00
comment|// Union of the above flags.
block|}
enum|;
comment|//===----------------------------------------------------------------------===//
comment|// Option Base class
comment|//
name|class
name|alias
decl_stmt|;
name|class
name|Option
block|{
name|friend
name|class
name|alias
decl_stmt|;
comment|// handleOccurrences - Overriden by subclasses to handle the value passed into
comment|// an argument.  Should return true if there was an error processing the
comment|// argument and the program should exit.
comment|//
name|virtual
name|bool
name|handleOccurrence
parameter_list|(
name|unsigned
name|pos
parameter_list|,
name|StringRef
name|ArgName
parameter_list|,
name|StringRef
name|Arg
parameter_list|)
init|=
literal|0
function_decl|;
name|virtual
expr|enum
name|ValueExpected
name|getValueExpectedFlagDefault
argument_list|()
specifier|const
block|{
return|return
name|ValueOptional
return|;
block|}
comment|// Out of line virtual function to provide home for the class.
name|virtual
name|void
name|anchor
parameter_list|()
function_decl|;
name|int
name|NumOccurrences
decl_stmt|;
comment|// The number of times specified
name|int
name|Flags
decl_stmt|;
comment|// Flags for the argument
name|unsigned
name|Position
decl_stmt|;
comment|// Position of last occurrence of the option
name|unsigned
name|AdditionalVals
decl_stmt|;
comment|// Greater than 0 for multi-valued option.
name|Option
modifier|*
name|NextRegistered
decl_stmt|;
comment|// Singly linked list of registered options.
name|public
label|:
specifier|const
name|char
modifier|*
name|ArgStr
decl_stmt|;
comment|// The argument string itself (ex: "help", "o")
specifier|const
name|char
modifier|*
name|HelpStr
decl_stmt|;
comment|// The descriptive text message for --help
specifier|const
name|char
modifier|*
name|ValueStr
decl_stmt|;
comment|// String describing what the value of this option is
specifier|inline
expr|enum
name|NumOccurrencesFlag
name|getNumOccurrencesFlag
argument_list|()
specifier|const
block|{
return|return
name|static_cast
operator|<
expr|enum
name|NumOccurrencesFlag
operator|>
operator|(
name|Flags
operator|&
name|OccurrencesMask
operator|)
return|;
block|}
specifier|inline
expr|enum
name|ValueExpected
name|getValueExpectedFlag
argument_list|()
specifier|const
block|{
name|int
name|VE
operator|=
name|Flags
operator|&
name|ValueMask
block|;
return|return
name|VE
condition|?
name|static_cast
operator|<
expr|enum
name|ValueExpected
operator|>
operator|(
name|VE
operator|)
else|:
name|getValueExpectedFlagDefault
argument_list|()
return|;
block|}
specifier|inline
expr|enum
name|OptionHidden
name|getOptionHiddenFlag
argument_list|()
specifier|const
block|{
return|return
name|static_cast
operator|<
expr|enum
name|OptionHidden
operator|>
operator|(
name|Flags
operator|&
name|HiddenMask
operator|)
return|;
block|}
specifier|inline
expr|enum
name|FormattingFlags
name|getFormattingFlag
argument_list|()
specifier|const
block|{
return|return
name|static_cast
operator|<
expr|enum
name|FormattingFlags
operator|>
operator|(
name|Flags
operator|&
name|FormattingMask
operator|)
return|;
block|}
specifier|inline
name|unsigned
name|getMiscFlags
argument_list|()
specifier|const
block|{
return|return
name|Flags
operator|&
name|MiscMask
return|;
block|}
specifier|inline
name|unsigned
name|getPosition
argument_list|()
specifier|const
block|{
return|return
name|Position
return|;
block|}
specifier|inline
name|unsigned
name|getNumAdditionalVals
argument_list|()
specifier|const
block|{
return|return
name|AdditionalVals
return|;
block|}
comment|// hasArgStr - Return true if the argstr != ""
name|bool
name|hasArgStr
argument_list|()
specifier|const
block|{
return|return
name|ArgStr
index|[
literal|0
index|]
operator|!=
literal|0
return|;
block|}
comment|//-------------------------------------------------------------------------===
comment|// Accessor functions set by OptionModifiers
comment|//
name|void
name|setArgStr
parameter_list|(
specifier|const
name|char
modifier|*
name|S
parameter_list|)
block|{
name|ArgStr
operator|=
name|S
expr_stmt|;
block|}
name|void
name|setDescription
parameter_list|(
specifier|const
name|char
modifier|*
name|S
parameter_list|)
block|{
name|HelpStr
operator|=
name|S
expr_stmt|;
block|}
name|void
name|setValueStr
parameter_list|(
specifier|const
name|char
modifier|*
name|S
parameter_list|)
block|{
name|ValueStr
operator|=
name|S
expr_stmt|;
block|}
name|void
name|setFlag
parameter_list|(
name|unsigned
name|Flag
parameter_list|,
name|unsigned
name|FlagMask
parameter_list|)
block|{
name|Flags
operator|&=
operator|~
name|FlagMask
expr_stmt|;
name|Flags
operator||=
name|Flag
expr_stmt|;
block|}
name|void
name|setNumOccurrencesFlag
parameter_list|(
name|enum
name|NumOccurrencesFlag
name|Val
parameter_list|)
block|{
name|setFlag
argument_list|(
name|Val
argument_list|,
name|OccurrencesMask
argument_list|)
expr_stmt|;
block|}
name|void
name|setValueExpectedFlag
parameter_list|(
name|enum
name|ValueExpected
name|Val
parameter_list|)
block|{
name|setFlag
argument_list|(
name|Val
argument_list|,
name|ValueMask
argument_list|)
expr_stmt|;
block|}
name|void
name|setHiddenFlag
parameter_list|(
name|enum
name|OptionHidden
name|Val
parameter_list|)
block|{
name|setFlag
argument_list|(
name|Val
argument_list|,
name|HiddenMask
argument_list|)
expr_stmt|;
block|}
name|void
name|setFormattingFlag
parameter_list|(
name|enum
name|FormattingFlags
name|V
parameter_list|)
block|{
name|setFlag
argument_list|(
name|V
argument_list|,
name|FormattingMask
argument_list|)
expr_stmt|;
block|}
name|void
name|setMiscFlag
parameter_list|(
name|enum
name|MiscFlags
name|M
parameter_list|)
block|{
name|setFlag
argument_list|(
name|M
argument_list|,
name|M
argument_list|)
expr_stmt|;
block|}
name|void
name|setPosition
parameter_list|(
name|unsigned
name|pos
parameter_list|)
block|{
name|Position
operator|=
name|pos
expr_stmt|;
block|}
name|protected
label|:
name|explicit
name|Option
argument_list|(
argument|unsigned DefaultFlags
argument_list|)
block|:
name|NumOccurrences
argument_list|(
literal|0
argument_list|)
operator|,
name|Flags
argument_list|(
name|DefaultFlags
operator||
name|NormalFormatting
argument_list|)
operator|,
name|Position
argument_list|(
literal|0
argument_list|)
operator|,
name|AdditionalVals
argument_list|(
literal|0
argument_list|)
operator|,
name|NextRegistered
argument_list|(
literal|0
argument_list|)
operator|,
name|ArgStr
argument_list|(
literal|""
argument_list|)
operator|,
name|HelpStr
argument_list|(
literal|""
argument_list|)
operator|,
name|ValueStr
argument_list|(
literal|""
argument_list|)
block|{
name|assert
argument_list|(
name|getNumOccurrencesFlag
argument_list|()
operator|!=
literal|0
operator|&&
name|getOptionHiddenFlag
argument_list|()
operator|!=
literal|0
operator|&&
literal|"Not all default flags specified!"
argument_list|)
block|;   }
specifier|inline
name|void
name|setNumAdditionalVals
argument_list|(
argument|unsigned n
argument_list|)
block|{
name|AdditionalVals
operator|=
name|n
block|; }
name|public
operator|:
comment|// addArgument - Register this argument with the commandline system.
comment|//
name|void
name|addArgument
argument_list|()
expr_stmt|;
name|Option
operator|*
name|getNextRegisteredOption
argument_list|()
specifier|const
block|{
return|return
name|NextRegistered
return|;
block|}
comment|// Return the width of the option tag for printing...
name|virtual
name|size_t
name|getOptionWidth
argument_list|()
specifier|const
operator|=
literal|0
expr_stmt|;
comment|// printOptionInfo - Print out information about this option.  The
comment|// to-be-maintained width is specified.
comment|//
name|virtual
name|void
name|printOptionInfo
argument_list|(
name|size_t
name|GlobalWidth
argument_list|)
decl|const
init|=
literal|0
decl_stmt|;
name|virtual
name|void
name|getExtraOptionNames
argument_list|(
name|SmallVectorImpl
operator|<
specifier|const
name|char
operator|*
operator|>
operator|&
argument_list|)
block|{}
comment|// addOccurrence - Wrapper around handleOccurrence that enforces Flags.
comment|//
name|bool
name|addOccurrence
parameter_list|(
name|unsigned
name|pos
parameter_list|,
name|StringRef
name|ArgName
parameter_list|,
name|StringRef
name|Value
parameter_list|,
name|bool
name|MultiArg
init|=
name|false
parameter_list|)
function_decl|;
comment|// Prints option name followed by message.  Always returns true.
name|bool
name|error
parameter_list|(
specifier|const
name|Twine
modifier|&
name|Message
parameter_list|,
name|StringRef
name|ArgName
init|=
name|StringRef
argument_list|()
parameter_list|)
function_decl|;
name|public
label|:
specifier|inline
name|int
name|getNumOccurrences
argument_list|()
specifier|const
block|{
return|return
name|NumOccurrences
return|;
block|}
name|virtual
operator|~
name|Option
argument_list|()
block|{}
block|}
empty_stmt|;
comment|//===----------------------------------------------------------------------===//
comment|// Command line option modifiers that can be used to modify the behavior of
comment|// command line option parsers...
comment|//
comment|// desc - Modifier to set the description shown in the --help output...
struct|struct
name|desc
block|{
specifier|const
name|char
modifier|*
name|Desc
decl_stmt|;
name|desc
argument_list|(
specifier|const
name|char
operator|*
name|Str
argument_list|)
operator|:
name|Desc
argument_list|(
argument|Str
argument_list|)
block|{}
name|void
name|apply
argument_list|(
argument|Option&O
argument_list|)
specifier|const
block|{
name|O
operator|.
name|setDescription
argument_list|(
name|Desc
argument_list|)
block|; }
block|}
struct|;
comment|// value_desc - Modifier to set the value description shown in the --help
comment|// output...
struct|struct
name|value_desc
block|{
specifier|const
name|char
modifier|*
name|Desc
decl_stmt|;
name|value_desc
argument_list|(
specifier|const
name|char
operator|*
name|Str
argument_list|)
operator|:
name|Desc
argument_list|(
argument|Str
argument_list|)
block|{}
name|void
name|apply
argument_list|(
argument|Option&O
argument_list|)
specifier|const
block|{
name|O
operator|.
name|setValueStr
argument_list|(
name|Desc
argument_list|)
block|; }
block|}
struct|;
comment|// init - Specify a default (initial) value for the command line argument, if
comment|// the default constructor for the argument type does not give you what you
comment|// want.  This is only valid on "opt" arguments, not on "list" arguments.
comment|//
name|template
operator|<
name|class
name|Ty
operator|>
expr|struct
name|initializer
block|{
specifier|const
name|Ty
operator|&
name|Init
block|;
name|initializer
argument_list|(
specifier|const
name|Ty
operator|&
name|Val
argument_list|)
operator|:
name|Init
argument_list|(
argument|Val
argument_list|)
block|{}
name|template
operator|<
name|class
name|Opt
operator|>
name|void
name|apply
argument_list|(
argument|Opt&O
argument_list|)
specifier|const
block|{
name|O
operator|.
name|setInitialValue
argument_list|(
name|Init
argument_list|)
block|; }
block|}
expr_stmt|;
name|template
operator|<
name|class
name|Ty
operator|>
name|initializer
operator|<
name|Ty
operator|>
name|init
argument_list|(
argument|const Ty&Val
argument_list|)
block|{
return|return
name|initializer
operator|<
name|Ty
operator|>
operator|(
name|Val
operator|)
return|;
block|}
comment|// location - Allow the user to specify which external variable they want to
comment|// store the results of the command line argument processing into, if they don't
comment|// want to store it in the option itself.
comment|//
name|template
operator|<
name|class
name|Ty
operator|>
expr|struct
name|LocationClass
block|{
name|Ty
operator|&
name|Loc
block|;
name|LocationClass
argument_list|(
name|Ty
operator|&
name|L
argument_list|)
operator|:
name|Loc
argument_list|(
argument|L
argument_list|)
block|{}
name|template
operator|<
name|class
name|Opt
operator|>
name|void
name|apply
argument_list|(
argument|Opt&O
argument_list|)
specifier|const
block|{
name|O
operator|.
name|setLocation
argument_list|(
name|O
argument_list|,
name|Loc
argument_list|)
block|; }
block|}
expr_stmt|;
name|template
operator|<
name|class
name|Ty
operator|>
name|LocationClass
operator|<
name|Ty
operator|>
name|location
argument_list|(
argument|Ty&L
argument_list|)
block|{
return|return
name|LocationClass
operator|<
name|Ty
operator|>
operator|(
name|L
operator|)
return|;
block|}
comment|//===----------------------------------------------------------------------===//
comment|// Enum valued command line option
comment|//
define|#
directive|define
name|clEnumVal
parameter_list|(
name|ENUMVAL
parameter_list|,
name|DESC
parameter_list|)
value|#ENUMVAL, int(ENUMVAL), DESC
define|#
directive|define
name|clEnumValN
parameter_list|(
name|ENUMVAL
parameter_list|,
name|FLAGNAME
parameter_list|,
name|DESC
parameter_list|)
value|FLAGNAME, int(ENUMVAL), DESC
define|#
directive|define
name|clEnumValEnd
value|(reinterpret_cast<void*>(0))
comment|// values - For custom data types, allow specifying a group of values together
comment|// as the values that go into the mapping that the option handler uses.  Note
comment|// that the values list must always have a 0 at the end of the list to indicate
comment|// that the list has ended.
comment|//
name|template
operator|<
name|class
name|DataType
operator|>
name|class
name|ValuesClass
block|{
comment|// Use a vector instead of a map, because the lists should be short,
comment|// the overhead is less, and most importantly, it keeps them in the order
comment|// inserted so we can print our option out nicely.
name|SmallVector
operator|<
name|std
operator|::
name|pair
operator|<
specifier|const
name|char
operator|*
block|,
name|std
operator|::
name|pair
operator|<
name|int
block|,
specifier|const
name|char
operator|*
operator|>
expr|>
block|,
literal|4
operator|>
name|Values
block|;
name|void
name|processValues
argument_list|(
argument|va_list Vals
argument_list|)
block|;
name|public
operator|:
name|ValuesClass
argument_list|(
argument|const char *EnumName
argument_list|,
argument|DataType Val
argument_list|,
argument|const char *Desc
argument_list|,
argument|va_list ValueArgs
argument_list|)
block|{
comment|// Insert the first value, which is required.
name|Values
operator|.
name|push_back
argument_list|(
name|std
operator|::
name|make_pair
argument_list|(
name|EnumName
argument_list|,
name|std
operator|::
name|make_pair
argument_list|(
name|Val
argument_list|,
name|Desc
argument_list|)
argument_list|)
argument_list|)
block|;
comment|// Process the varargs portion of the values...
while|while
condition|(
specifier|const
name|char
modifier|*
name|enumName
init|=
name|va_arg
argument_list|(
name|ValueArgs
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
condition|)
block|{
name|DataType
name|EnumVal
init|=
name|static_cast
operator|<
name|DataType
operator|>
operator|(
name|va_arg
argument_list|(
name|ValueArgs
argument_list|,
name|int
argument_list|)
operator|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|EnumDesc
init|=
name|va_arg
argument_list|(
name|ValueArgs
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
decl_stmt|;
name|Values
operator|.
name|push_back
argument_list|(
name|std
operator|::
name|make_pair
argument_list|(
name|enumName
argument_list|,
comment|// Add value to value map
name|std
operator|::
name|make_pair
argument_list|(
name|EnumVal
argument_list|,
name|EnumDesc
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|template
operator|<
name|class
name|Opt
operator|>
name|void
name|apply
argument_list|(
argument|Opt&O
argument_list|)
specifier|const
block|{
for|for
control|(
name|unsigned
name|i
init|=
literal|0
init|,
name|e
init|=
name|static_cast
operator|<
name|unsigned
operator|>
operator|(
name|Values
operator|.
name|size
argument_list|()
operator|)
init|;
name|i
operator|!=
name|e
condition|;
operator|++
name|i
control|)
name|O
operator|.
name|getParser
argument_list|()
operator|.
name|addLiteralOption
argument_list|(
name|Values
index|[
name|i
index|]
operator|.
name|first
argument_list|,
name|Values
index|[
name|i
index|]
operator|.
name|second
operator|.
name|first
argument_list|,
name|Values
index|[
name|i
index|]
operator|.
name|second
operator|.
name|second
argument_list|)
expr_stmt|;
block|}
expr|}
block|;
name|template
operator|<
name|class
name|DataType
operator|>
name|ValuesClass
operator|<
name|DataType
operator|>
name|END_WITH_NULL
name|values
argument_list|(
argument|const char *Arg
argument_list|,
argument|DataType Val
argument_list|,
argument|const char *Desc
argument_list|,
argument|...
argument_list|)
block|{
name|va_list
name|ValueArgs
block|;
name|va_start
argument_list|(
name|ValueArgs
argument_list|,
name|Desc
argument_list|)
block|;
name|ValuesClass
operator|<
name|DataType
operator|>
name|Vals
argument_list|(
name|Arg
argument_list|,
name|Val
argument_list|,
name|Desc
argument_list|,
name|ValueArgs
argument_list|)
block|;
name|va_end
argument_list|(
name|ValueArgs
argument_list|)
block|;
return|return
name|Vals
return|;
block|}
comment|//===----------------------------------------------------------------------===//
comment|// parser class - Parameterizable parser for different data types.  By default,
comment|// known data types (string, int, bool) have specialized parsers, that do what
comment|// you would expect.  The default parser, used for data types that are not
comment|// built-in, uses a mapping table to map specific options to values, which is
comment|// used, among other things, to handle enum types.
comment|//--------------------------------------------------
comment|// generic_parser_base - This class holds all the non-generic code that we do
comment|// not need replicated for every instance of the generic parser.  This also
comment|// allows us to put stuff into CommandLine.cpp
comment|//
expr|struct
name|generic_parser_base
block|{
name|virtual
operator|~
name|generic_parser_base
argument_list|()
block|{}
comment|// Base class should have virtual-dtor
comment|// getNumOptions - Virtual function implemented by generic subclass to
comment|// indicate how many entries are in Values.
comment|//
name|virtual
name|unsigned
name|getNumOptions
argument_list|()
specifier|const
operator|=
literal|0
block|;
comment|// getOption - Return option name N.
name|virtual
specifier|const
name|char
operator|*
name|getOption
argument_list|(
argument|unsigned N
argument_list|)
specifier|const
operator|=
literal|0
block|;
comment|// getDescription - Return description N
name|virtual
specifier|const
name|char
operator|*
name|getDescription
argument_list|(
argument|unsigned N
argument_list|)
specifier|const
operator|=
literal|0
block|;
comment|// Return the width of the option tag for printing...
name|virtual
name|size_t
name|getOptionWidth
argument_list|(
argument|const Option&O
argument_list|)
specifier|const
block|;
comment|// printOptionInfo - Print out information about this option.  The
comment|// to-be-maintained width is specified.
comment|//
name|virtual
name|void
name|printOptionInfo
argument_list|(
argument|const Option&O
argument_list|,
argument|size_t GlobalWidth
argument_list|)
specifier|const
block|;
name|void
name|initialize
argument_list|(
argument|Option&O
argument_list|)
block|{
comment|// All of the modifiers for the option have been processed by now, so the
comment|// argstr field should be stable, copy it down now.
comment|//
name|hasArgStr
operator|=
name|O
operator|.
name|hasArgStr
argument_list|()
block|;   }
name|void
name|getExtraOptionNames
argument_list|(
argument|SmallVectorImpl<const char*>&OptionNames
argument_list|)
block|{
comment|// If there has been no argstr specified, that means that we need to add an
comment|// argument for every possible option.  This ensures that our options are
comment|// vectored to us.
if|if
condition|(
operator|!
name|hasArgStr
condition|)
for|for
control|(
name|unsigned
name|i
init|=
literal|0
init|,
name|e
init|=
name|getNumOptions
argument_list|()
init|;
name|i
operator|!=
name|e
condition|;
operator|++
name|i
control|)
name|OptionNames
operator|.
name|push_back
argument_list|(
name|getOption
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
expr|enum
name|ValueExpected
name|getValueExpectedFlagDefault
argument_list|()
specifier|const
block|{
comment|// If there is an ArgStr specified, then we are of the form:
comment|//
comment|//    -opt=O2   or   -opt O2  or  -optO2
comment|//
comment|// In which case, the value is required.  Otherwise if an arg str has not
comment|// been specified, we are of the form:
comment|//
comment|//    -O2 or O2 or -la (where -l and -a are separate options)
comment|//
comment|// If this is the case, we cannot allow a value.
comment|//
if|if
condition|(
name|hasArgStr
condition|)
return|return
name|ValueRequired
return|;
else|else
return|return
name|ValueDisallowed
return|;
block|}
comment|// findOption - Return the option number corresponding to the specified
comment|// argument string.  If the option is not found, getNumOptions() is returned.
comment|//
name|unsigned
name|findOption
argument_list|(
specifier|const
name|char
operator|*
name|Name
argument_list|)
block|;
name|protected
operator|:
name|bool
name|hasArgStr
block|; }
block|;
comment|// Default parser implementation - This implementation depends on having a
comment|// mapping of recognized options to values of some sort.  In addition to this,
comment|// each entry in the mapping also tracks a help message that is printed with the
comment|// command line option for --help.  Because this is a simple mapping parser, the
comment|// data type can be any unsupported type.
comment|//
name|template
operator|<
name|class
name|DataType
operator|>
name|class
name|parser
operator|:
name|public
name|generic_parser_base
block|{
name|protected
operator|:
name|SmallVector
operator|<
name|std
operator|::
name|pair
operator|<
specifier|const
name|char
operator|*
block|,
name|std
operator|::
name|pair
operator|<
name|DataType
block|,
specifier|const
name|char
operator|*
operator|>
expr|>
block|,
literal|8
operator|>
name|Values
block|;
name|public
operator|:
typedef|typedef
name|DataType
name|parser_data_type
typedef|;
comment|// Implement virtual functions needed by generic_parser_base
name|unsigned
name|getNumOptions
argument_list|()
specifier|const
block|{
return|return
name|unsigned
argument_list|(
name|Values
operator|.
name|size
argument_list|()
argument_list|)
return|;
block|}
specifier|const
name|char
operator|*
name|getOption
argument_list|(
argument|unsigned N
argument_list|)
specifier|const
block|{
return|return
name|Values
index|[
name|N
index|]
operator|.
name|first
return|;
block|}
specifier|const
name|char
operator|*
name|getDescription
argument_list|(
argument|unsigned N
argument_list|)
specifier|const
block|{
return|return
name|Values
index|[
name|N
index|]
operator|.
name|second
operator|.
name|second
return|;
block|}
comment|// parse - Return true on error.
name|bool
name|parse
argument_list|(
argument|Option&O
argument_list|,
argument|StringRef ArgName
argument_list|,
argument|StringRef Arg
argument_list|,
argument|DataType&V
argument_list|)
block|{
name|StringRef
name|ArgVal
block|;
if|if
condition|(
name|hasArgStr
condition|)
name|ArgVal
operator|=
name|Arg
expr_stmt|;
else|else
name|ArgVal
operator|=
name|ArgName
expr_stmt|;
for|for
control|(
name|unsigned
name|i
init|=
literal|0
init|,
name|e
init|=
name|static_cast
operator|<
name|unsigned
operator|>
operator|(
name|Values
operator|.
name|size
argument_list|()
operator|)
init|;
name|i
operator|!=
name|e
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|Values
index|[
name|i
index|]
operator|.
name|first
operator|==
name|ArgVal
condition|)
block|{
name|V
operator|=
name|Values
index|[
name|i
index|]
operator|.
name|second
operator|.
name|first
expr_stmt|;
return|return
name|false
return|;
block|}
return|return
name|O
operator|.
name|error
argument_list|(
literal|"Cannot find option named '"
operator|+
name|ArgVal
operator|+
literal|"'!"
argument_list|)
return|;
block|}
comment|/// addLiteralOption - Add an entry to the mapping table.
comment|///
name|template
operator|<
name|class
name|DT
operator|>
name|void
name|addLiteralOption
argument_list|(
argument|const char *Name
argument_list|,
argument|const DT&V
argument_list|,
argument|const char *HelpStr
argument_list|)
block|{
name|assert
argument_list|(
name|findOption
argument_list|(
name|Name
argument_list|)
operator|==
name|Values
operator|.
name|size
argument_list|()
operator|&&
literal|"Option already exists!"
argument_list|)
block|;
name|Values
operator|.
name|push_back
argument_list|(
name|std
operator|::
name|make_pair
argument_list|(
name|Name
argument_list|,
name|std
operator|::
name|make_pair
argument_list|(
name|static_cast
operator|<
name|DataType
operator|>
operator|(
name|V
operator|)
argument_list|,
name|HelpStr
argument_list|)
argument_list|)
argument_list|)
block|;
name|MarkOptionsChanged
argument_list|()
block|;   }
comment|/// removeLiteralOption - Remove the specified option.
comment|///
name|void
name|removeLiteralOption
argument_list|(
argument|const char *Name
argument_list|)
block|{
name|unsigned
name|N
operator|=
name|findOption
argument_list|(
name|Name
argument_list|)
block|;
name|assert
argument_list|(
name|N
operator|!=
name|Values
operator|.
name|size
argument_list|()
operator|&&
literal|"Option not found!"
argument_list|)
block|;
name|Values
operator|.
name|erase
argument_list|(
name|Values
operator|.
name|begin
argument_list|()
operator|+
name|N
argument_list|)
block|;   }
block|}
empty_stmt|;
comment|//--------------------------------------------------
comment|// basic_parser - Super class of parsers to provide boilerplate code
comment|//
struct|struct
name|basic_parser_impl
block|{
comment|// non-template implementation of basic_parser<t>
name|virtual
operator|~
name|basic_parser_impl
argument_list|()
block|{}
expr|enum
name|ValueExpected
name|getValueExpectedFlagDefault
argument_list|()
specifier|const
block|{
return|return
name|ValueRequired
return|;
block|}
name|void
name|getExtraOptionNames
argument_list|(
name|SmallVectorImpl
operator|<
specifier|const
name|char
operator|*
operator|>
operator|&
argument_list|)
block|{}
name|void
name|initialize
parameter_list|(
name|Option
modifier|&
parameter_list|)
block|{}
comment|// Return the width of the option tag for printing...
name|size_t
name|getOptionWidth
argument_list|(
specifier|const
name|Option
operator|&
name|O
argument_list|)
decl|const
decl_stmt|;
comment|// printOptionInfo - Print out information about this option.  The
comment|// to-be-maintained width is specified.
comment|//
name|void
name|printOptionInfo
argument_list|(
specifier|const
name|Option
operator|&
name|O
argument_list|,
name|size_t
name|GlobalWidth
argument_list|)
decl|const
decl_stmt|;
comment|// getValueName - Overload in subclass to provide a better default value.
name|virtual
specifier|const
name|char
operator|*
name|getValueName
argument_list|()
specifier|const
block|{
return|return
literal|"value"
return|;
block|}
comment|// An out-of-line virtual method to provide a 'home' for this class.
name|virtual
name|void
name|anchor
parameter_list|()
function_decl|;
block|}
struct|;
comment|// basic_parser - The real basic parser is just a template wrapper that provides
comment|// a typedef for the provided data type.
comment|//
name|template
operator|<
name|class
name|DataType
operator|>
expr|struct
name|basic_parser
operator|:
name|public
name|basic_parser_impl
block|{
typedef|typedef
name|DataType
name|parser_data_type
typedef|;
block|}
empty_stmt|;
comment|//--------------------------------------------------
comment|// parser<bool>
comment|//
name|template
operator|<
operator|>
name|class
name|parser
operator|<
name|bool
operator|>
operator|:
name|public
name|basic_parser
operator|<
name|bool
operator|>
block|{
specifier|const
name|char
operator|*
name|ArgStr
block|;
name|public
operator|:
comment|// parse - Return true on error.
name|bool
name|parse
argument_list|(
argument|Option&O
argument_list|,
argument|StringRef ArgName
argument_list|,
argument|StringRef Arg
argument_list|,
argument|bool&Val
argument_list|)
block|;
name|template
operator|<
name|class
name|Opt
operator|>
name|void
name|initialize
argument_list|(
argument|Opt&O
argument_list|)
block|{
name|ArgStr
operator|=
name|O
operator|.
name|ArgStr
block|;   }
expr|enum
name|ValueExpected
name|getValueExpectedFlagDefault
argument_list|()
specifier|const
block|{
return|return
name|ValueOptional
return|;
block|}
comment|// getValueName - Do not print =<value> at all.
name|virtual
specifier|const
name|char
operator|*
name|getValueName
argument_list|()
specifier|const
block|{
return|return
literal|0
return|;
block|}
comment|// An out-of-line virtual method to provide a 'home' for this class.
name|virtual
name|void
name|anchor
argument_list|()
block|; }
expr_stmt|;
name|EXTERN_TEMPLATE_INSTANTIATION
argument_list|(
argument|class basic_parser<bool>
argument_list|)
empty_stmt|;
comment|//--------------------------------------------------
comment|// parser<boolOrDefault>
enum|enum
name|boolOrDefault
block|{
name|BOU_UNSET
block|,
name|BOU_TRUE
block|,
name|BOU_FALSE
block|}
enum|;
name|template
operator|<
operator|>
name|class
name|parser
operator|<
name|boolOrDefault
operator|>
operator|:
name|public
name|basic_parser
operator|<
name|boolOrDefault
operator|>
block|{
name|public
operator|:
comment|// parse - Return true on error.
name|bool
name|parse
argument_list|(
argument|Option&O
argument_list|,
argument|StringRef ArgName
argument_list|,
argument|StringRef Arg
argument_list|,
argument|boolOrDefault&Val
argument_list|)
block|;    enum
name|ValueExpected
name|getValueExpectedFlagDefault
argument_list|()
specifier|const
block|{
return|return
name|ValueOptional
return|;
block|}
comment|// getValueName - Do not print =<value> at all.
name|virtual
specifier|const
name|char
operator|*
name|getValueName
argument_list|()
specifier|const
block|{
return|return
literal|0
return|;
block|}
comment|// An out-of-line virtual method to provide a 'home' for this class.
name|virtual
name|void
name|anchor
argument_list|()
block|; }
expr_stmt|;
name|EXTERN_TEMPLATE_INSTANTIATION
argument_list|(
argument|class basic_parser<boolOrDefault>
argument_list|)
empty_stmt|;
comment|//--------------------------------------------------
comment|// parser<int>
comment|//
name|template
operator|<
operator|>
name|class
name|parser
operator|<
name|int
operator|>
operator|:
name|public
name|basic_parser
operator|<
name|int
operator|>
block|{
name|public
operator|:
comment|// parse - Return true on error.
name|bool
name|parse
argument_list|(
argument|Option&O
argument_list|,
argument|StringRef ArgName
argument_list|,
argument|StringRef Arg
argument_list|,
argument|int&Val
argument_list|)
block|;
comment|// getValueName - Overload in subclass to provide a better default value.
name|virtual
specifier|const
name|char
operator|*
name|getValueName
argument_list|()
specifier|const
block|{
return|return
literal|"int"
return|;
block|}
comment|// An out-of-line virtual method to provide a 'home' for this class.
name|virtual
name|void
name|anchor
argument_list|()
block|; }
expr_stmt|;
name|EXTERN_TEMPLATE_INSTANTIATION
argument_list|(
argument|class basic_parser<int>
argument_list|)
empty_stmt|;
comment|//--------------------------------------------------
comment|// parser<unsigned>
comment|//
name|template
operator|<
operator|>
name|class
name|parser
operator|<
name|unsigned
operator|>
operator|:
name|public
name|basic_parser
operator|<
name|unsigned
operator|>
block|{
name|public
operator|:
comment|// parse - Return true on error.
name|bool
name|parse
argument_list|(
argument|Option&O
argument_list|,
argument|StringRef ArgName
argument_list|,
argument|StringRef Arg
argument_list|,
argument|unsigned&Val
argument_list|)
block|;
comment|// getValueName - Overload in subclass to provide a better default value.
name|virtual
specifier|const
name|char
operator|*
name|getValueName
argument_list|()
specifier|const
block|{
return|return
literal|"uint"
return|;
block|}
comment|// An out-of-line virtual method to provide a 'home' for this class.
name|virtual
name|void
name|anchor
argument_list|()
block|; }
expr_stmt|;
name|EXTERN_TEMPLATE_INSTANTIATION
argument_list|(
argument|class basic_parser<unsigned>
argument_list|)
empty_stmt|;
comment|//--------------------------------------------------
comment|// parser<double>
comment|//
name|template
operator|<
operator|>
name|class
name|parser
operator|<
name|double
operator|>
operator|:
name|public
name|basic_parser
operator|<
name|double
operator|>
block|{
name|public
operator|:
comment|// parse - Return true on error.
name|bool
name|parse
argument_list|(
argument|Option&O
argument_list|,
argument|StringRef ArgName
argument_list|,
argument|StringRef Arg
argument_list|,
argument|double&Val
argument_list|)
block|;
comment|// getValueName - Overload in subclass to provide a better default value.
name|virtual
specifier|const
name|char
operator|*
name|getValueName
argument_list|()
specifier|const
block|{
return|return
literal|"number"
return|;
block|}
comment|// An out-of-line virtual method to provide a 'home' for this class.
name|virtual
name|void
name|anchor
argument_list|()
block|; }
expr_stmt|;
name|EXTERN_TEMPLATE_INSTANTIATION
argument_list|(
argument|class basic_parser<double>
argument_list|)
empty_stmt|;
comment|//--------------------------------------------------
comment|// parser<float>
comment|//
name|template
operator|<
operator|>
name|class
name|parser
operator|<
name|float
operator|>
operator|:
name|public
name|basic_parser
operator|<
name|float
operator|>
block|{
name|public
operator|:
comment|// parse - Return true on error.
name|bool
name|parse
argument_list|(
argument|Option&O
argument_list|,
argument|StringRef ArgName
argument_list|,
argument|StringRef Arg
argument_list|,
argument|float&Val
argument_list|)
block|;
comment|// getValueName - Overload in subclass to provide a better default value.
name|virtual
specifier|const
name|char
operator|*
name|getValueName
argument_list|()
specifier|const
block|{
return|return
literal|"number"
return|;
block|}
comment|// An out-of-line virtual method to provide a 'home' for this class.
name|virtual
name|void
name|anchor
argument_list|()
block|; }
expr_stmt|;
name|EXTERN_TEMPLATE_INSTANTIATION
argument_list|(
argument|class basic_parser<float>
argument_list|)
empty_stmt|;
comment|//--------------------------------------------------
comment|// parser<std::string>
comment|//
name|template
operator|<
operator|>
name|class
name|parser
operator|<
name|std
operator|::
name|string
operator|>
operator|:
name|public
name|basic_parser
operator|<
name|std
operator|::
name|string
operator|>
block|{
name|public
operator|:
comment|// parse - Return true on error.
name|bool
name|parse
argument_list|(
argument|Option&
argument_list|,
argument|StringRef ArgName
argument_list|,
argument|StringRef Arg
argument_list|,
argument|std::string&Value
argument_list|)
block|{
name|Value
operator|=
name|Arg
operator|.
name|str
argument_list|()
block|;
return|return
name|false
return|;
block|}
comment|// getValueName - Overload in subclass to provide a better default value.
name|virtual
specifier|const
name|char
operator|*
name|getValueName
argument_list|()
specifier|const
block|{
return|return
literal|"string"
return|;
block|}
comment|// An out-of-line virtual method to provide a 'home' for this class.
name|virtual
name|void
name|anchor
argument_list|()
block|; }
expr_stmt|;
name|EXTERN_TEMPLATE_INSTANTIATION
argument_list|(
argument|class basic_parser<std::string>
argument_list|)
empty_stmt|;
comment|//--------------------------------------------------
comment|// parser<char>
comment|//
name|template
operator|<
operator|>
name|class
name|parser
operator|<
name|char
operator|>
operator|:
name|public
name|basic_parser
operator|<
name|char
operator|>
block|{
name|public
operator|:
comment|// parse - Return true on error.
name|bool
name|parse
argument_list|(
argument|Option&
argument_list|,
argument|StringRef ArgName
argument_list|,
argument|StringRef Arg
argument_list|,
argument|char&Value
argument_list|)
block|{
name|Value
operator|=
name|Arg
index|[
literal|0
index|]
block|;
return|return
name|false
return|;
block|}
comment|// getValueName - Overload in subclass to provide a better default value.
name|virtual
specifier|const
name|char
operator|*
name|getValueName
argument_list|()
specifier|const
block|{
return|return
literal|"char"
return|;
block|}
comment|// An out-of-line virtual method to provide a 'home' for this class.
name|virtual
name|void
name|anchor
argument_list|()
block|; }
expr_stmt|;
name|EXTERN_TEMPLATE_INSTANTIATION
argument_list|(
argument|class basic_parser<char>
argument_list|)
empty_stmt|;
comment|//===----------------------------------------------------------------------===//
comment|// applicator class - This class is used because we must use partial
comment|// specialization to handle literal string arguments specially (const char* does
comment|// not correctly respond to the apply method).  Because the syntax to use this
comment|// is a pain, we have the 'apply' method below to handle the nastiness...
comment|//
name|template
operator|<
name|class
name|Mod
operator|>
expr|struct
name|applicator
block|{
name|template
operator|<
name|class
name|Opt
operator|>
specifier|static
name|void
name|opt
argument_list|(
argument|const Mod&M
argument_list|,
argument|Opt&O
argument_list|)
block|{
name|M
operator|.
name|apply
argument_list|(
name|O
argument_list|)
block|; }
block|}
expr_stmt|;
comment|// Handle const char* as a special case...
name|template
operator|<
name|unsigned
name|n
operator|>
expr|struct
name|applicator
operator|<
name|char
index|[
name|n
index|]
operator|>
block|{
name|template
operator|<
name|class
name|Opt
operator|>
specifier|static
name|void
name|opt
argument_list|(
argument|const char *Str
argument_list|,
argument|Opt&O
argument_list|)
block|{
name|O
operator|.
name|setArgStr
argument_list|(
name|Str
argument_list|)
block|; }
block|}
expr_stmt|;
name|template
operator|<
name|unsigned
name|n
operator|>
expr|struct
name|applicator
operator|<
specifier|const
name|char
index|[
name|n
index|]
operator|>
block|{
name|template
operator|<
name|class
name|Opt
operator|>
specifier|static
name|void
name|opt
argument_list|(
argument|const char *Str
argument_list|,
argument|Opt&O
argument_list|)
block|{
name|O
operator|.
name|setArgStr
argument_list|(
name|Str
argument_list|)
block|; }
block|}
expr_stmt|;
name|template
operator|<
operator|>
expr|struct
name|applicator
operator|<
specifier|const
name|char
operator|*
operator|>
block|{
name|template
operator|<
name|class
name|Opt
operator|>
specifier|static
name|void
name|opt
argument_list|(
argument|const char *Str
argument_list|,
argument|Opt&O
argument_list|)
block|{
name|O
operator|.
name|setArgStr
argument_list|(
name|Str
argument_list|)
block|; }
block|}
expr_stmt|;
name|template
operator|<
operator|>
expr|struct
name|applicator
operator|<
name|NumOccurrencesFlag
operator|>
block|{
specifier|static
name|void
name|opt
argument_list|(
argument|NumOccurrencesFlag NO
argument_list|,
argument|Option&O
argument_list|)
block|{
name|O
operator|.
name|setNumOccurrencesFlag
argument_list|(
name|NO
argument_list|)
block|;   }
block|}
expr_stmt|;
name|template
operator|<
operator|>
expr|struct
name|applicator
operator|<
name|ValueExpected
operator|>
block|{
specifier|static
name|void
name|opt
argument_list|(
argument|ValueExpected VE
argument_list|,
argument|Option&O
argument_list|)
block|{
name|O
operator|.
name|setValueExpectedFlag
argument_list|(
name|VE
argument_list|)
block|; }
block|}
expr_stmt|;
name|template
operator|<
operator|>
expr|struct
name|applicator
operator|<
name|OptionHidden
operator|>
block|{
specifier|static
name|void
name|opt
argument_list|(
argument|OptionHidden OH
argument_list|,
argument|Option&O
argument_list|)
block|{
name|O
operator|.
name|setHiddenFlag
argument_list|(
name|OH
argument_list|)
block|; }
block|}
expr_stmt|;
name|template
operator|<
operator|>
expr|struct
name|applicator
operator|<
name|FormattingFlags
operator|>
block|{
specifier|static
name|void
name|opt
argument_list|(
argument|FormattingFlags FF
argument_list|,
argument|Option&O
argument_list|)
block|{
name|O
operator|.
name|setFormattingFlag
argument_list|(
name|FF
argument_list|)
block|; }
block|}
expr_stmt|;
name|template
operator|<
operator|>
expr|struct
name|applicator
operator|<
name|MiscFlags
operator|>
block|{
specifier|static
name|void
name|opt
argument_list|(
argument|MiscFlags MF
argument_list|,
argument|Option&O
argument_list|)
block|{
name|O
operator|.
name|setMiscFlag
argument_list|(
name|MF
argument_list|)
block|; }
block|}
expr_stmt|;
comment|// apply method - Apply a modifier to an option in a type safe way.
name|template
operator|<
name|class
name|Mod
operator|,
name|class
name|Opt
operator|>
name|void
name|apply
argument_list|(
argument|const Mod&M
argument_list|,
argument|Opt *O
argument_list|)
block|{
name|applicator
operator|<
name|Mod
operator|>
operator|::
name|opt
argument_list|(
name|M
argument_list|,
operator|*
name|O
argument_list|)
block|; }
comment|//===----------------------------------------------------------------------===//
comment|// opt_storage class
comment|// Default storage class definition: external storage.  This implementation
comment|// assumes the user will specify a variable to store the data into with the
comment|// cl::location(x) modifier.
comment|//
name|template
operator|<
name|class
name|DataType
operator|,
name|bool
name|ExternalStorage
operator|,
name|bool
name|isClass
operator|>
name|class
name|opt_storage
block|{
name|DataType
operator|*
name|Location
block|;
comment|// Where to store the object...
name|void
name|check
argument_list|()
specifier|const
block|{
name|assert
argument_list|(
name|Location
operator|!=
literal|0
operator|&&
literal|"cl::location(...) not specified for a command "
literal|"line option with external storage, "
literal|"or cl::init specified before cl::location()!!"
argument_list|)
block|;   }
name|public
operator|:
name|opt_storage
argument_list|()
operator|:
name|Location
argument_list|(
literal|0
argument_list|)
block|{}
name|bool
name|setLocation
argument_list|(
argument|Option&O
argument_list|,
argument|DataType&L
argument_list|)
block|{
if|if
condition|(
name|Location
condition|)
return|return
name|O
operator|.
name|error
argument_list|(
literal|"cl::location(x) specified more than once!"
argument_list|)
return|;
name|Location
operator|=
operator|&
name|L
block|;
return|return
name|false
return|;
block|}
name|template
operator|<
name|class
name|T
operator|>
name|void
name|setValue
argument_list|(
argument|const T&V
argument_list|)
block|{
name|check
argument_list|()
block|;
operator|*
name|Location
operator|=
name|V
block|;   }
name|DataType
operator|&
name|getValue
argument_list|()
block|{
name|check
argument_list|()
block|;
return|return
operator|*
name|Location
return|;
block|}
specifier|const
name|DataType
operator|&
name|getValue
argument_list|()
specifier|const
block|{
name|check
argument_list|()
block|;
return|return
operator|*
name|Location
return|;
block|}
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_comment
comment|// Define how to hold a class type object, such as a string.  Since we can
end_comment

begin_comment
comment|// inherit from a class, we do so.  This makes us exactly compatible with the
end_comment

begin_comment
comment|// object in all cases that it is used.
end_comment

begin_comment
comment|//
end_comment

begin_expr_stmt
name|template
operator|<
name|class
name|DataType
operator|>
name|class
name|opt_storage
operator|<
name|DataType
operator|,
name|false
operator|,
name|true
operator|>
operator|:
name|public
name|DataType
block|{
name|public
operator|:
name|template
operator|<
name|class
name|T
operator|>
name|void
name|setValue
argument_list|(
argument|const T&V
argument_list|)
block|{
name|DataType
operator|::
name|operator
operator|=
operator|(
name|V
operator|)
block|; }
name|DataType
operator|&
name|getValue
argument_list|()
block|{
return|return
operator|*
name|this
return|;
block|}
specifier|const
name|DataType
operator|&
name|getValue
argument_list|()
specifier|const
block|{
return|return
operator|*
name|this
return|;
block|}
end_expr_stmt

begin_comment
unit|};
comment|// Define a partial specialization to handle things we cannot inherit from.  In
end_comment

begin_comment
comment|// this case, we store an instance through containment, and overload operators
end_comment

begin_comment
comment|// to get at the value.
end_comment

begin_comment
comment|//
end_comment

begin_expr_stmt
name|template
operator|<
name|class
name|DataType
operator|>
name|class
name|opt_storage
operator|<
name|DataType
operator|,
name|false
operator|,
name|false
operator|>
block|{
name|public
operator|:
name|DataType
name|Value
block|;
comment|// Make sure we initialize the value with the default constructor for the
comment|// type.
name|opt_storage
argument_list|()
operator|:
name|Value
argument_list|(
argument|DataType()
argument_list|)
block|{}
name|template
operator|<
name|class
name|T
operator|>
name|void
name|setValue
argument_list|(
argument|const T&V
argument_list|)
block|{
name|Value
operator|=
name|V
block|; }
name|DataType
operator|&
name|getValue
argument_list|()
block|{
return|return
name|Value
return|;
block|}
name|DataType
name|getValue
argument_list|()
specifier|const
block|{
return|return
name|Value
return|;
block|}
end_expr_stmt

begin_comment
comment|// If the datatype is a pointer, support -> on it.
end_comment

begin_expr_stmt
name|DataType
name|operator
operator|->
expr|(
end_expr_stmt

begin_expr_stmt
unit|)
specifier|const
block|{
return|return
name|Value
return|;
block|}
end_expr_stmt

begin_comment
unit|};
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|// opt - A scalar command line option.
end_comment

begin_comment
comment|//
end_comment

begin_expr_stmt
name|template
operator|<
name|class
name|DataType
operator|,
name|bool
name|ExternalStorage
operator|=
name|false
operator|,
name|class
name|ParserClass
operator|=
name|parser
operator|<
name|DataType
operator|>
expr|>
name|class
name|opt
operator|:
name|public
name|Option
operator|,
name|public
name|opt_storage
operator|<
name|DataType
operator|,
name|ExternalStorage
operator|,
name|is_class
operator|<
name|DataType
operator|>
operator|::
name|value
operator|>
block|{
name|ParserClass
name|Parser
block|;
name|virtual
name|bool
name|handleOccurrence
argument_list|(
argument|unsigned pos
argument_list|,
argument|StringRef ArgName
argument_list|,
argument|StringRef Arg
argument_list|)
block|{
name|typename
name|ParserClass
operator|::
name|parser_data_type
name|Val
operator|=
name|typename
name|ParserClass
operator|::
name|parser_data_type
argument_list|()
block|;
if|if
condition|(
name|Parser
operator|.
name|parse
argument_list|(
operator|*
name|this
argument_list|,
name|ArgName
argument_list|,
name|Arg
argument_list|,
name|Val
argument_list|)
condition|)
return|return
name|true
return|;
comment|// Parse error!
name|this
operator|->
name|setValue
argument_list|(
name|Val
argument_list|)
block|;
name|this
operator|->
name|setPosition
argument_list|(
name|pos
argument_list|)
block|;
return|return
name|false
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|virtual
expr|enum
name|ValueExpected
name|getValueExpectedFlagDefault
argument_list|()
specifier|const
block|{
return|return
name|Parser
operator|.
name|getValueExpectedFlagDefault
argument_list|()
return|;
block|}
end_expr_stmt

begin_decl_stmt
name|virtual
name|void
name|getExtraOptionNames
argument_list|(
name|SmallVectorImpl
operator|<
specifier|const
name|char
operator|*
operator|>
operator|&
name|OptionNames
argument_list|)
block|{
return|return
name|Parser
operator|.
name|getExtraOptionNames
argument_list|(
name|OptionNames
argument_list|)
return|;
block|}
end_decl_stmt

begin_comment
comment|// Forward printing stuff to the parser...
end_comment

begin_expr_stmt
name|virtual
name|size_t
name|getOptionWidth
argument_list|()
specifier|const
block|{
return|return
name|Parser
operator|.
name|getOptionWidth
argument_list|(
operator|*
name|this
argument_list|)
return|;
block|}
end_expr_stmt

begin_decl_stmt
name|virtual
name|void
name|printOptionInfo
argument_list|(
name|size_t
name|GlobalWidth
argument_list|)
decl|const
block|{
name|Parser
operator|.
name|printOptionInfo
argument_list|(
operator|*
name|this
argument_list|,
name|GlobalWidth
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_function
name|void
name|done
parameter_list|()
block|{
name|addArgument
argument_list|()
expr_stmt|;
name|Parser
operator|.
name|initialize
argument_list|(
operator|*
name|this
argument_list|)
expr_stmt|;
block|}
end_function

begin_label
name|public
label|:
end_label

begin_comment
comment|// setInitialValue - Used by the cl::init modifier...
end_comment

begin_function
name|void
name|setInitialValue
parameter_list|(
specifier|const
name|DataType
modifier|&
name|V
parameter_list|)
block|{
name|this
operator|->
name|setValue
argument_list|(
name|V
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|ParserClass
modifier|&
name|getParser
parameter_list|()
block|{
return|return
name|Parser
return|;
block|}
end_function

begin_expr_stmt
name|operator
name|DataType
argument_list|()
specifier|const
block|{
return|return
name|this
operator|->
name|getValue
argument_list|()
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|T
operator|>
name|DataType
operator|&
name|operator
operator|=
operator|(
specifier|const
name|T
operator|&
name|Val
operator|)
block|{
name|this
operator|->
name|setValue
argument_list|(
name|Val
argument_list|)
block|;
return|return
name|this
operator|->
name|getValue
argument_list|()
return|;
block|}
end_expr_stmt

begin_comment
comment|// One option...
end_comment

begin_expr_stmt
name|template
operator|<
name|class
name|M0t
operator|>
name|explicit
name|opt
argument_list|(
specifier|const
name|M0t
operator|&
name|M0
argument_list|)
operator|:
name|Option
argument_list|(
argument|Optional | NotHidden
argument_list|)
block|{
name|apply
argument_list|(
name|M0
argument_list|,
name|this
argument_list|)
block|;
name|done
argument_list|()
block|;   }
comment|// Two options...
name|template
operator|<
name|class
name|M0t
operator|,
name|class
name|M1t
operator|>
name|opt
argument_list|(
specifier|const
name|M0t
operator|&
name|M0
argument_list|,
specifier|const
name|M1t
operator|&
name|M1
argument_list|)
operator|:
name|Option
argument_list|(
argument|Optional | NotHidden
argument_list|)
block|{
name|apply
argument_list|(
name|M0
argument_list|,
name|this
argument_list|)
block|;
name|apply
argument_list|(
name|M1
argument_list|,
name|this
argument_list|)
block|;
name|done
argument_list|()
block|;   }
comment|// Three options...
name|template
operator|<
name|class
name|M0t
operator|,
name|class
name|M1t
operator|,
name|class
name|M2t
operator|>
name|opt
argument_list|(
specifier|const
name|M0t
operator|&
name|M0
argument_list|,
specifier|const
name|M1t
operator|&
name|M1
argument_list|,
specifier|const
name|M2t
operator|&
name|M2
argument_list|)
operator|:
name|Option
argument_list|(
argument|Optional | NotHidden
argument_list|)
block|{
name|apply
argument_list|(
name|M0
argument_list|,
name|this
argument_list|)
block|;
name|apply
argument_list|(
name|M1
argument_list|,
name|this
argument_list|)
block|;
name|apply
argument_list|(
name|M2
argument_list|,
name|this
argument_list|)
block|;
name|done
argument_list|()
block|;   }
comment|// Four options...
name|template
operator|<
name|class
name|M0t
operator|,
name|class
name|M1t
operator|,
name|class
name|M2t
operator|,
name|class
name|M3t
operator|>
name|opt
argument_list|(
specifier|const
name|M0t
operator|&
name|M0
argument_list|,
specifier|const
name|M1t
operator|&
name|M1
argument_list|,
specifier|const
name|M2t
operator|&
name|M2
argument_list|,
specifier|const
name|M3t
operator|&
name|M3
argument_list|)
operator|:
name|Option
argument_list|(
argument|Optional | NotHidden
argument_list|)
block|{
name|apply
argument_list|(
name|M0
argument_list|,
name|this
argument_list|)
block|;
name|apply
argument_list|(
name|M1
argument_list|,
name|this
argument_list|)
block|;
name|apply
argument_list|(
name|M2
argument_list|,
name|this
argument_list|)
block|;
name|apply
argument_list|(
name|M3
argument_list|,
name|this
argument_list|)
block|;
name|done
argument_list|()
block|;   }
comment|// Five options...
name|template
operator|<
name|class
name|M0t
operator|,
name|class
name|M1t
operator|,
name|class
name|M2t
operator|,
name|class
name|M3t
operator|,
name|class
name|M4t
operator|>
name|opt
argument_list|(
specifier|const
name|M0t
operator|&
name|M0
argument_list|,
specifier|const
name|M1t
operator|&
name|M1
argument_list|,
specifier|const
name|M2t
operator|&
name|M2
argument_list|,
specifier|const
name|M3t
operator|&
name|M3
argument_list|,
specifier|const
name|M4t
operator|&
name|M4
argument_list|)
operator|:
name|Option
argument_list|(
argument|Optional | NotHidden
argument_list|)
block|{
name|apply
argument_list|(
name|M0
argument_list|,
name|this
argument_list|)
block|;
name|apply
argument_list|(
name|M1
argument_list|,
name|this
argument_list|)
block|;
name|apply
argument_list|(
name|M2
argument_list|,
name|this
argument_list|)
block|;
name|apply
argument_list|(
name|M3
argument_list|,
name|this
argument_list|)
block|;
name|apply
argument_list|(
name|M4
argument_list|,
name|this
argument_list|)
block|;
name|done
argument_list|()
block|;   }
comment|// Six options...
name|template
operator|<
name|class
name|M0t
operator|,
name|class
name|M1t
operator|,
name|class
name|M2t
operator|,
name|class
name|M3t
operator|,
name|class
name|M4t
operator|,
name|class
name|M5t
operator|>
name|opt
argument_list|(
specifier|const
name|M0t
operator|&
name|M0
argument_list|,
specifier|const
name|M1t
operator|&
name|M1
argument_list|,
specifier|const
name|M2t
operator|&
name|M2
argument_list|,
specifier|const
name|M3t
operator|&
name|M3
argument_list|,
specifier|const
name|M4t
operator|&
name|M4
argument_list|,
specifier|const
name|M5t
operator|&
name|M5
argument_list|)
operator|:
name|Option
argument_list|(
argument|Optional | NotHidden
argument_list|)
block|{
name|apply
argument_list|(
name|M0
argument_list|,
name|this
argument_list|)
block|;
name|apply
argument_list|(
name|M1
argument_list|,
name|this
argument_list|)
block|;
name|apply
argument_list|(
name|M2
argument_list|,
name|this
argument_list|)
block|;
name|apply
argument_list|(
name|M3
argument_list|,
name|this
argument_list|)
block|;
name|apply
argument_list|(
name|M4
argument_list|,
name|this
argument_list|)
block|;
name|apply
argument_list|(
name|M5
argument_list|,
name|this
argument_list|)
block|;
name|done
argument_list|()
block|;   }
comment|// Seven options...
name|template
operator|<
name|class
name|M0t
operator|,
name|class
name|M1t
operator|,
name|class
name|M2t
operator|,
name|class
name|M3t
operator|,
name|class
name|M4t
operator|,
name|class
name|M5t
operator|,
name|class
name|M6t
operator|>
name|opt
argument_list|(
specifier|const
name|M0t
operator|&
name|M0
argument_list|,
specifier|const
name|M1t
operator|&
name|M1
argument_list|,
specifier|const
name|M2t
operator|&
name|M2
argument_list|,
specifier|const
name|M3t
operator|&
name|M3
argument_list|,
specifier|const
name|M4t
operator|&
name|M4
argument_list|,
specifier|const
name|M5t
operator|&
name|M5
argument_list|,
specifier|const
name|M6t
operator|&
name|M6
argument_list|)
operator|:
name|Option
argument_list|(
argument|Optional | NotHidden
argument_list|)
block|{
name|apply
argument_list|(
name|M0
argument_list|,
name|this
argument_list|)
block|;
name|apply
argument_list|(
name|M1
argument_list|,
name|this
argument_list|)
block|;
name|apply
argument_list|(
name|M2
argument_list|,
name|this
argument_list|)
block|;
name|apply
argument_list|(
name|M3
argument_list|,
name|this
argument_list|)
block|;
name|apply
argument_list|(
name|M4
argument_list|,
name|this
argument_list|)
block|;
name|apply
argument_list|(
name|M5
argument_list|,
name|this
argument_list|)
block|;
name|apply
argument_list|(
name|M6
argument_list|,
name|this
argument_list|)
block|;
name|done
argument_list|()
block|;   }
comment|// Eight options...
name|template
operator|<
name|class
name|M0t
operator|,
name|class
name|M1t
operator|,
name|class
name|M2t
operator|,
name|class
name|M3t
operator|,
name|class
name|M4t
operator|,
name|class
name|M5t
operator|,
name|class
name|M6t
operator|,
name|class
name|M7t
operator|>
name|opt
argument_list|(
specifier|const
name|M0t
operator|&
name|M0
argument_list|,
specifier|const
name|M1t
operator|&
name|M1
argument_list|,
specifier|const
name|M2t
operator|&
name|M2
argument_list|,
specifier|const
name|M3t
operator|&
name|M3
argument_list|,
specifier|const
name|M4t
operator|&
name|M4
argument_list|,
specifier|const
name|M5t
operator|&
name|M5
argument_list|,
specifier|const
name|M6t
operator|&
name|M6
argument_list|,
specifier|const
name|M7t
operator|&
name|M7
argument_list|)
operator|:
name|Option
argument_list|(
argument|Optional | NotHidden
argument_list|)
block|{
name|apply
argument_list|(
name|M0
argument_list|,
name|this
argument_list|)
block|;
name|apply
argument_list|(
name|M1
argument_list|,
name|this
argument_list|)
block|;
name|apply
argument_list|(
name|M2
argument_list|,
name|this
argument_list|)
block|;
name|apply
argument_list|(
name|M3
argument_list|,
name|this
argument_list|)
block|;
name|apply
argument_list|(
name|M4
argument_list|,
name|this
argument_list|)
block|;
name|apply
argument_list|(
name|M5
argument_list|,
name|this
argument_list|)
block|;
name|apply
argument_list|(
name|M6
argument_list|,
name|this
argument_list|)
block|;
name|apply
argument_list|(
name|M7
argument_list|,
name|this
argument_list|)
block|;
name|done
argument_list|()
block|;   }
end_expr_stmt

begin_macro
unit|};
name|EXTERN_TEMPLATE_INSTANTIATION
argument_list|(
argument|class opt<unsigned>
argument_list|)
end_macro

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_macro
name|EXTERN_TEMPLATE_INSTANTIATION
argument_list|(
argument|class opt<int>
argument_list|)
end_macro

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_macro
name|EXTERN_TEMPLATE_INSTANTIATION
argument_list|(
argument|class opt<std::string>
argument_list|)
end_macro

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_macro
name|EXTERN_TEMPLATE_INSTANTIATION
argument_list|(
argument|class opt<char>
argument_list|)
end_macro

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_macro
name|EXTERN_TEMPLATE_INSTANTIATION
argument_list|(
argument|class opt<bool>
argument_list|)
end_macro

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|// list_storage class
end_comment

begin_comment
comment|// Default storage class definition: external storage.  This implementation
end_comment

begin_comment
comment|// assumes the user will specify a variable to store the data into with the
end_comment

begin_comment
comment|// cl::location(x) modifier.
end_comment

begin_comment
comment|//
end_comment

begin_expr_stmt
name|template
operator|<
name|class
name|DataType
operator|,
name|class
name|StorageClass
operator|>
name|class
name|list_storage
block|{
name|StorageClass
operator|*
name|Location
block|;
comment|// Where to store the object...
name|public
operator|:
name|list_storage
argument_list|()
operator|:
name|Location
argument_list|(
literal|0
argument_list|)
block|{}
name|bool
name|setLocation
argument_list|(
argument|Option&O
argument_list|,
argument|StorageClass&L
argument_list|)
block|{
if|if
condition|(
name|Location
condition|)
return|return
name|O
operator|.
name|error
argument_list|(
literal|"cl::location(x) specified more than once!"
argument_list|)
return|;
name|Location
operator|=
operator|&
name|L
block|;
return|return
name|false
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|T
operator|>
name|void
name|addValue
argument_list|(
argument|const T&V
argument_list|)
block|{
name|assert
argument_list|(
name|Location
operator|!=
literal|0
operator|&&
literal|"cl::location(...) not specified for a command "
literal|"line option with external storage!"
argument_list|)
block|;
name|Location
operator|->
name|push_back
argument_list|(
name|V
argument_list|)
block|;   }
end_expr_stmt

begin_comment
unit|};
comment|// Define how to hold a class type object, such as a string.  Since we can
end_comment

begin_comment
comment|// inherit from a class, we do so.  This makes us exactly compatible with the
end_comment

begin_comment
comment|// object in all cases that it is used.
end_comment

begin_comment
comment|//
end_comment

begin_expr_stmt
name|template
operator|<
name|class
name|DataType
operator|>
name|class
name|list_storage
operator|<
name|DataType
operator|,
name|bool
operator|>
operator|:
name|public
name|std
operator|::
name|vector
operator|<
name|DataType
operator|>
block|{
name|public
operator|:
name|template
operator|<
name|class
name|T
operator|>
name|void
name|addValue
argument_list|(
argument|const T&V
argument_list|)
block|{
name|push_back
argument_list|(
name|V
argument_list|)
block|; }
block|}
expr_stmt|;
end_expr_stmt

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|// list - A list of command line options.
end_comment

begin_comment
comment|//
end_comment

begin_expr_stmt
name|template
operator|<
name|class
name|DataType
operator|,
name|class
name|Storage
operator|=
name|bool
operator|,
name|class
name|ParserClass
operator|=
name|parser
operator|<
name|DataType
operator|>
expr|>
name|class
name|list
operator|:
name|public
name|Option
operator|,
name|public
name|list_storage
operator|<
name|DataType
operator|,
name|Storage
operator|>
block|{
name|std
operator|::
name|vector
operator|<
name|unsigned
operator|>
name|Positions
block|;
name|ParserClass
name|Parser
block|;
name|virtual
expr|enum
name|ValueExpected
name|getValueExpectedFlagDefault
argument_list|()
specifier|const
block|{
return|return
name|Parser
operator|.
name|getValueExpectedFlagDefault
argument_list|()
return|;
block|}
name|virtual
name|void
name|getExtraOptionNames
argument_list|(
argument|SmallVectorImpl<const char*>&OptionNames
argument_list|)
block|{
return|return
name|Parser
operator|.
name|getExtraOptionNames
argument_list|(
name|OptionNames
argument_list|)
return|;
block|}
end_expr_stmt

begin_function
name|virtual
name|bool
name|handleOccurrence
parameter_list|(
name|unsigned
name|pos
parameter_list|,
name|StringRef
name|ArgName
parameter_list|,
name|StringRef
name|Arg
parameter_list|)
block|{
name|typename
name|ParserClass
operator|::
name|parser_data_type
name|Val
operator|=
name|typename
name|ParserClass
operator|::
name|parser_data_type
argument_list|()
expr_stmt|;
if|if
condition|(
name|Parser
operator|.
name|parse
argument_list|(
operator|*
name|this
argument_list|,
name|ArgName
argument_list|,
name|Arg
argument_list|,
name|Val
argument_list|)
condition|)
return|return
name|true
return|;
comment|// Parse Error!
name|addValue
argument_list|(
name|Val
argument_list|)
expr_stmt|;
name|setPosition
argument_list|(
name|pos
argument_list|)
expr_stmt|;
name|Positions
operator|.
name|push_back
argument_list|(
name|pos
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|// Forward printing stuff to the parser...
end_comment

begin_expr_stmt
name|virtual
name|size_t
name|getOptionWidth
argument_list|()
specifier|const
block|{
return|return
name|Parser
operator|.
name|getOptionWidth
argument_list|(
operator|*
name|this
argument_list|)
return|;
block|}
end_expr_stmt

begin_decl_stmt
name|virtual
name|void
name|printOptionInfo
argument_list|(
name|size_t
name|GlobalWidth
argument_list|)
decl|const
block|{
name|Parser
operator|.
name|printOptionInfo
argument_list|(
operator|*
name|this
argument_list|,
name|GlobalWidth
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_function
name|void
name|done
parameter_list|()
block|{
name|addArgument
argument_list|()
expr_stmt|;
name|Parser
operator|.
name|initialize
argument_list|(
operator|*
name|this
argument_list|)
expr_stmt|;
block|}
end_function

begin_label
name|public
label|:
end_label

begin_function
name|ParserClass
modifier|&
name|getParser
parameter_list|()
block|{
return|return
name|Parser
return|;
block|}
end_function

begin_decl_stmt
name|unsigned
name|getPosition
argument_list|(
name|unsigned
name|optnum
argument_list|)
decl|const
block|{
name|assert
argument_list|(
name|optnum
operator|<
name|this
operator|->
name|size
argument_list|()
operator|&&
literal|"Invalid option index"
argument_list|)
expr_stmt|;
return|return
name|Positions
index|[
name|optnum
index|]
return|;
block|}
end_decl_stmt

begin_function
name|void
name|setNumAdditionalVals
parameter_list|(
name|unsigned
name|n
parameter_list|)
block|{
name|Option
operator|::
name|setNumAdditionalVals
argument_list|(
name|n
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|// One option...
end_comment

begin_expr_stmt
name|template
operator|<
name|class
name|M0t
operator|>
name|explicit
name|list
argument_list|(
specifier|const
name|M0t
operator|&
name|M0
argument_list|)
operator|:
name|Option
argument_list|(
argument|ZeroOrMore | NotHidden
argument_list|)
block|{
name|apply
argument_list|(
name|M0
argument_list|,
name|this
argument_list|)
block|;
name|done
argument_list|()
block|;   }
comment|// Two options...
name|template
operator|<
name|class
name|M0t
operator|,
name|class
name|M1t
operator|>
name|list
argument_list|(
specifier|const
name|M0t
operator|&
name|M0
argument_list|,
specifier|const
name|M1t
operator|&
name|M1
argument_list|)
operator|:
name|Option
argument_list|(
argument|ZeroOrMore | NotHidden
argument_list|)
block|{
name|apply
argument_list|(
name|M0
argument_list|,
name|this
argument_list|)
block|;
name|apply
argument_list|(
name|M1
argument_list|,
name|this
argument_list|)
block|;
name|done
argument_list|()
block|;   }
comment|// Three options...
name|template
operator|<
name|class
name|M0t
operator|,
name|class
name|M1t
operator|,
name|class
name|M2t
operator|>
name|list
argument_list|(
specifier|const
name|M0t
operator|&
name|M0
argument_list|,
specifier|const
name|M1t
operator|&
name|M1
argument_list|,
specifier|const
name|M2t
operator|&
name|M2
argument_list|)
operator|:
name|Option
argument_list|(
argument|ZeroOrMore | NotHidden
argument_list|)
block|{
name|apply
argument_list|(
name|M0
argument_list|,
name|this
argument_list|)
block|;
name|apply
argument_list|(
name|M1
argument_list|,
name|this
argument_list|)
block|;
name|apply
argument_list|(
name|M2
argument_list|,
name|this
argument_list|)
block|;
name|done
argument_list|()
block|;   }
comment|// Four options...
name|template
operator|<
name|class
name|M0t
operator|,
name|class
name|M1t
operator|,
name|class
name|M2t
operator|,
name|class
name|M3t
operator|>
name|list
argument_list|(
specifier|const
name|M0t
operator|&
name|M0
argument_list|,
specifier|const
name|M1t
operator|&
name|M1
argument_list|,
specifier|const
name|M2t
operator|&
name|M2
argument_list|,
specifier|const
name|M3t
operator|&
name|M3
argument_list|)
operator|:
name|Option
argument_list|(
argument|ZeroOrMore | NotHidden
argument_list|)
block|{
name|apply
argument_list|(
name|M0
argument_list|,
name|this
argument_list|)
block|;
name|apply
argument_list|(
name|M1
argument_list|,
name|this
argument_list|)
block|;
name|apply
argument_list|(
name|M2
argument_list|,
name|this
argument_list|)
block|;
name|apply
argument_list|(
name|M3
argument_list|,
name|this
argument_list|)
block|;
name|done
argument_list|()
block|;   }
comment|// Five options...
name|template
operator|<
name|class
name|M0t
operator|,
name|class
name|M1t
operator|,
name|class
name|M2t
operator|,
name|class
name|M3t
operator|,
name|class
name|M4t
operator|>
name|list
argument_list|(
specifier|const
name|M0t
operator|&
name|M0
argument_list|,
specifier|const
name|M1t
operator|&
name|M1
argument_list|,
specifier|const
name|M2t
operator|&
name|M2
argument_list|,
specifier|const
name|M3t
operator|&
name|M3
argument_list|,
specifier|const
name|M4t
operator|&
name|M4
argument_list|)
operator|:
name|Option
argument_list|(
argument|ZeroOrMore | NotHidden
argument_list|)
block|{
name|apply
argument_list|(
name|M0
argument_list|,
name|this
argument_list|)
block|;
name|apply
argument_list|(
name|M1
argument_list|,
name|this
argument_list|)
block|;
name|apply
argument_list|(
name|M2
argument_list|,
name|this
argument_list|)
block|;
name|apply
argument_list|(
name|M3
argument_list|,
name|this
argument_list|)
block|;
name|apply
argument_list|(
name|M4
argument_list|,
name|this
argument_list|)
block|;
name|done
argument_list|()
block|;   }
comment|// Six options...
name|template
operator|<
name|class
name|M0t
operator|,
name|class
name|M1t
operator|,
name|class
name|M2t
operator|,
name|class
name|M3t
operator|,
name|class
name|M4t
operator|,
name|class
name|M5t
operator|>
name|list
argument_list|(
specifier|const
name|M0t
operator|&
name|M0
argument_list|,
specifier|const
name|M1t
operator|&
name|M1
argument_list|,
specifier|const
name|M2t
operator|&
name|M2
argument_list|,
specifier|const
name|M3t
operator|&
name|M3
argument_list|,
specifier|const
name|M4t
operator|&
name|M4
argument_list|,
specifier|const
name|M5t
operator|&
name|M5
argument_list|)
operator|:
name|Option
argument_list|(
argument|ZeroOrMore | NotHidden
argument_list|)
block|{
name|apply
argument_list|(
name|M0
argument_list|,
name|this
argument_list|)
block|;
name|apply
argument_list|(
name|M1
argument_list|,
name|this
argument_list|)
block|;
name|apply
argument_list|(
name|M2
argument_list|,
name|this
argument_list|)
block|;
name|apply
argument_list|(
name|M3
argument_list|,
name|this
argument_list|)
block|;
name|apply
argument_list|(
name|M4
argument_list|,
name|this
argument_list|)
block|;
name|apply
argument_list|(
name|M5
argument_list|,
name|this
argument_list|)
block|;
name|done
argument_list|()
block|;   }
comment|// Seven options...
name|template
operator|<
name|class
name|M0t
operator|,
name|class
name|M1t
operator|,
name|class
name|M2t
operator|,
name|class
name|M3t
operator|,
name|class
name|M4t
operator|,
name|class
name|M5t
operator|,
name|class
name|M6t
operator|>
name|list
argument_list|(
specifier|const
name|M0t
operator|&
name|M0
argument_list|,
specifier|const
name|M1t
operator|&
name|M1
argument_list|,
specifier|const
name|M2t
operator|&
name|M2
argument_list|,
specifier|const
name|M3t
operator|&
name|M3
argument_list|,
specifier|const
name|M4t
operator|&
name|M4
argument_list|,
specifier|const
name|M5t
operator|&
name|M5
argument_list|,
specifier|const
name|M6t
operator|&
name|M6
argument_list|)
operator|:
name|Option
argument_list|(
argument|ZeroOrMore | NotHidden
argument_list|)
block|{
name|apply
argument_list|(
name|M0
argument_list|,
name|this
argument_list|)
block|;
name|apply
argument_list|(
name|M1
argument_list|,
name|this
argument_list|)
block|;
name|apply
argument_list|(
name|M2
argument_list|,
name|this
argument_list|)
block|;
name|apply
argument_list|(
name|M3
argument_list|,
name|this
argument_list|)
block|;
name|apply
argument_list|(
name|M4
argument_list|,
name|this
argument_list|)
block|;
name|apply
argument_list|(
name|M5
argument_list|,
name|this
argument_list|)
block|;
name|apply
argument_list|(
name|M6
argument_list|,
name|this
argument_list|)
block|;
name|done
argument_list|()
block|;   }
comment|// Eight options...
name|template
operator|<
name|class
name|M0t
operator|,
name|class
name|M1t
operator|,
name|class
name|M2t
operator|,
name|class
name|M3t
operator|,
name|class
name|M4t
operator|,
name|class
name|M5t
operator|,
name|class
name|M6t
operator|,
name|class
name|M7t
operator|>
name|list
argument_list|(
specifier|const
name|M0t
operator|&
name|M0
argument_list|,
specifier|const
name|M1t
operator|&
name|M1
argument_list|,
specifier|const
name|M2t
operator|&
name|M2
argument_list|,
specifier|const
name|M3t
operator|&
name|M3
argument_list|,
specifier|const
name|M4t
operator|&
name|M4
argument_list|,
specifier|const
name|M5t
operator|&
name|M5
argument_list|,
specifier|const
name|M6t
operator|&
name|M6
argument_list|,
specifier|const
name|M7t
operator|&
name|M7
argument_list|)
operator|:
name|Option
argument_list|(
argument|ZeroOrMore | NotHidden
argument_list|)
block|{
name|apply
argument_list|(
name|M0
argument_list|,
name|this
argument_list|)
block|;
name|apply
argument_list|(
name|M1
argument_list|,
name|this
argument_list|)
block|;
name|apply
argument_list|(
name|M2
argument_list|,
name|this
argument_list|)
block|;
name|apply
argument_list|(
name|M3
argument_list|,
name|this
argument_list|)
block|;
name|apply
argument_list|(
name|M4
argument_list|,
name|this
argument_list|)
block|;
name|apply
argument_list|(
name|M5
argument_list|,
name|this
argument_list|)
block|;
name|apply
argument_list|(
name|M6
argument_list|,
name|this
argument_list|)
block|;
name|apply
argument_list|(
name|M7
argument_list|,
name|this
argument_list|)
block|;
name|done
argument_list|()
block|;   }
end_expr_stmt

begin_comment
unit|};
comment|// multi_val - Modifier to set the number of additional values.
end_comment

begin_struct
struct|struct
name|multi_val
block|{
name|unsigned
name|AdditionalVals
decl_stmt|;
name|explicit
name|multi_val
argument_list|(
argument|unsigned N
argument_list|)
block|:
name|AdditionalVals
argument_list|(
argument|N
argument_list|)
block|{}
name|template
operator|<
name|typename
name|D
operator|,
name|typename
name|S
operator|,
name|typename
name|P
operator|>
name|void
name|apply
argument_list|(
argument|list<D
argument_list|,
argument|S
argument_list|,
argument|P>&L
argument_list|)
specifier|const
block|{
name|L
operator|.
name|setNumAdditionalVals
argument_list|(
name|AdditionalVals
argument_list|)
block|; }
block|}
struct|;
end_struct

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|// bits_storage class
end_comment

begin_comment
comment|// Default storage class definition: external storage.  This implementation
end_comment

begin_comment
comment|// assumes the user will specify a variable to store the data into with the
end_comment

begin_comment
comment|// cl::location(x) modifier.
end_comment

begin_comment
comment|//
end_comment

begin_expr_stmt
name|template
operator|<
name|class
name|DataType
operator|,
name|class
name|StorageClass
operator|>
name|class
name|bits_storage
block|{
name|unsigned
operator|*
name|Location
block|;
comment|// Where to store the bits...
name|template
operator|<
name|class
name|T
operator|>
specifier|static
name|unsigned
name|Bit
argument_list|(
argument|const T&V
argument_list|)
block|{
name|unsigned
name|BitPos
operator|=
name|reinterpret_cast
operator|<
name|unsigned
operator|>
operator|(
name|V
operator|)
block|;
name|assert
argument_list|(
name|BitPos
operator|<
sizeof|sizeof
argument_list|(
name|unsigned
argument_list|)
operator|*
name|CHAR_BIT
operator|&&
literal|"enum exceeds width of bit vector!"
argument_list|)
block|;
return|return
literal|1
operator|<<
name|BitPos
return|;
block|}
name|public
operator|:
name|bits_storage
argument_list|()
operator|:
name|Location
argument_list|(
literal|0
argument_list|)
block|{}
name|bool
name|setLocation
argument_list|(
argument|Option&O
argument_list|,
argument|unsigned&L
argument_list|)
block|{
if|if
condition|(
name|Location
condition|)
return|return
name|O
operator|.
name|error
argument_list|(
literal|"cl::location(x) specified more than once!"
argument_list|)
return|;
name|Location
operator|=
operator|&
name|L
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|false
return|;
end_return

begin_expr_stmt
unit|}    template
operator|<
name|class
name|T
operator|>
name|void
name|addValue
argument_list|(
argument|const T&V
argument_list|)
block|{
name|assert
argument_list|(
name|Location
operator|!=
literal|0
operator|&&
literal|"cl::location(...) not specified for a command "
literal|"line option with external storage!"
argument_list|)
block|;
operator|*
name|Location
operator||=
name|Bit
argument_list|(
name|V
argument_list|)
block|;   }
name|unsigned
name|getBits
argument_list|()
block|{
return|return
operator|*
name|Location
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|T
operator|>
name|bool
name|isSet
argument_list|(
argument|const T&V
argument_list|)
block|{
return|return
operator|(
operator|*
name|Location
operator|&
name|Bit
argument_list|(
name|V
argument_list|)
operator|)
operator|!=
literal|0
return|;
block|}
end_expr_stmt

begin_comment
unit|};
comment|// Define how to hold bits.  Since we can inherit from a class, we do so.
end_comment

begin_comment
comment|// This makes us exactly compatible with the bits in all cases that it is used.
end_comment

begin_comment
comment|//
end_comment

begin_expr_stmt
name|template
operator|<
name|class
name|DataType
operator|>
name|class
name|bits_storage
operator|<
name|DataType
operator|,
name|bool
operator|>
block|{
name|unsigned
name|Bits
block|;
comment|// Where to store the bits...
name|template
operator|<
name|class
name|T
operator|>
specifier|static
name|unsigned
name|Bit
argument_list|(
argument|const T&V
argument_list|)
block|{
name|unsigned
name|BitPos
operator|=
name|reinterpret_cast
operator|<
name|unsigned
operator|>
operator|(
name|V
operator|)
block|;
name|assert
argument_list|(
name|BitPos
operator|<
sizeof|sizeof
argument_list|(
name|unsigned
argument_list|)
operator|*
name|CHAR_BIT
operator|&&
literal|"enum exceeds width of bit vector!"
argument_list|)
block|;
return|return
literal|1
operator|<<
name|BitPos
return|;
block|}
name|public
operator|:
name|template
operator|<
name|class
name|T
operator|>
name|void
name|addValue
argument_list|(
argument|const T&V
argument_list|)
block|{
name|Bits
operator||=
name|Bit
argument_list|(
name|V
argument_list|)
block|;   }
name|unsigned
name|getBits
argument_list|()
block|{
return|return
name|Bits
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|T
operator|>
name|bool
name|isSet
argument_list|(
argument|const T&V
argument_list|)
block|{
return|return
operator|(
name|Bits
operator|&
name|Bit
argument_list|(
name|V
argument_list|)
operator|)
operator|!=
literal|0
return|;
block|}
end_expr_stmt

begin_comment
unit|};
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|// bits - A bit vector of command options.
end_comment

begin_comment
comment|//
end_comment

begin_expr_stmt
name|template
operator|<
name|class
name|DataType
operator|,
name|class
name|Storage
operator|=
name|bool
operator|,
name|class
name|ParserClass
operator|=
name|parser
operator|<
name|DataType
operator|>
expr|>
name|class
name|bits
operator|:
name|public
name|Option
operator|,
name|public
name|bits_storage
operator|<
name|DataType
operator|,
name|Storage
operator|>
block|{
name|std
operator|::
name|vector
operator|<
name|unsigned
operator|>
name|Positions
block|;
name|ParserClass
name|Parser
block|;
name|virtual
expr|enum
name|ValueExpected
name|getValueExpectedFlagDefault
argument_list|()
specifier|const
block|{
return|return
name|Parser
operator|.
name|getValueExpectedFlagDefault
argument_list|()
return|;
block|}
name|virtual
name|void
name|getExtraOptionNames
argument_list|(
argument|SmallVectorImpl<const char*>&OptionNames
argument_list|)
block|{
return|return
name|Parser
operator|.
name|getExtraOptionNames
argument_list|(
name|OptionNames
argument_list|)
return|;
block|}
end_expr_stmt

begin_function
name|virtual
name|bool
name|handleOccurrence
parameter_list|(
name|unsigned
name|pos
parameter_list|,
name|StringRef
name|ArgName
parameter_list|,
name|StringRef
name|Arg
parameter_list|)
block|{
name|typename
name|ParserClass
operator|::
name|parser_data_type
name|Val
operator|=
name|typename
name|ParserClass
operator|::
name|parser_data_type
argument_list|()
expr_stmt|;
if|if
condition|(
name|Parser
operator|.
name|parse
argument_list|(
operator|*
name|this
argument_list|,
name|ArgName
argument_list|,
name|Arg
argument_list|,
name|Val
argument_list|)
condition|)
return|return
name|true
return|;
comment|// Parse Error!
name|addValue
argument_list|(
name|Val
argument_list|)
expr_stmt|;
name|setPosition
argument_list|(
name|pos
argument_list|)
expr_stmt|;
name|Positions
operator|.
name|push_back
argument_list|(
name|pos
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|// Forward printing stuff to the parser...
end_comment

begin_expr_stmt
name|virtual
name|size_t
name|getOptionWidth
argument_list|()
specifier|const
block|{
return|return
name|Parser
operator|.
name|getOptionWidth
argument_list|(
operator|*
name|this
argument_list|)
return|;
block|}
end_expr_stmt

begin_decl_stmt
name|virtual
name|void
name|printOptionInfo
argument_list|(
name|size_t
name|GlobalWidth
argument_list|)
decl|const
block|{
name|Parser
operator|.
name|printOptionInfo
argument_list|(
operator|*
name|this
argument_list|,
name|GlobalWidth
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_function
name|void
name|done
parameter_list|()
block|{
name|addArgument
argument_list|()
expr_stmt|;
name|Parser
operator|.
name|initialize
argument_list|(
operator|*
name|this
argument_list|)
expr_stmt|;
block|}
end_function

begin_label
name|public
label|:
end_label

begin_function
name|ParserClass
modifier|&
name|getParser
parameter_list|()
block|{
return|return
name|Parser
return|;
block|}
end_function

begin_decl_stmt
name|unsigned
name|getPosition
argument_list|(
name|unsigned
name|optnum
argument_list|)
decl|const
block|{
name|assert
argument_list|(
name|optnum
operator|<
name|this
operator|->
name|size
argument_list|()
operator|&&
literal|"Invalid option index"
argument_list|)
expr_stmt|;
return|return
name|Positions
index|[
name|optnum
index|]
return|;
block|}
end_decl_stmt

begin_comment
comment|// One option...
end_comment

begin_expr_stmt
name|template
operator|<
name|class
name|M0t
operator|>
name|explicit
name|bits
argument_list|(
specifier|const
name|M0t
operator|&
name|M0
argument_list|)
operator|:
name|Option
argument_list|(
argument|ZeroOrMore | NotHidden
argument_list|)
block|{
name|apply
argument_list|(
name|M0
argument_list|,
name|this
argument_list|)
block|;
name|done
argument_list|()
block|;   }
comment|// Two options...
name|template
operator|<
name|class
name|M0t
operator|,
name|class
name|M1t
operator|>
name|bits
argument_list|(
specifier|const
name|M0t
operator|&
name|M0
argument_list|,
specifier|const
name|M1t
operator|&
name|M1
argument_list|)
operator|:
name|Option
argument_list|(
argument|ZeroOrMore | NotHidden
argument_list|)
block|{
name|apply
argument_list|(
name|M0
argument_list|,
name|this
argument_list|)
block|;
name|apply
argument_list|(
name|M1
argument_list|,
name|this
argument_list|)
block|;
name|done
argument_list|()
block|;   }
comment|// Three options...
name|template
operator|<
name|class
name|M0t
operator|,
name|class
name|M1t
operator|,
name|class
name|M2t
operator|>
name|bits
argument_list|(
specifier|const
name|M0t
operator|&
name|M0
argument_list|,
specifier|const
name|M1t
operator|&
name|M1
argument_list|,
specifier|const
name|M2t
operator|&
name|M2
argument_list|)
operator|:
name|Option
argument_list|(
argument|ZeroOrMore | NotHidden
argument_list|)
block|{
name|apply
argument_list|(
name|M0
argument_list|,
name|this
argument_list|)
block|;
name|apply
argument_list|(
name|M1
argument_list|,
name|this
argument_list|)
block|;
name|apply
argument_list|(
name|M2
argument_list|,
name|this
argument_list|)
block|;
name|done
argument_list|()
block|;   }
comment|// Four options...
name|template
operator|<
name|class
name|M0t
operator|,
name|class
name|M1t
operator|,
name|class
name|M2t
operator|,
name|class
name|M3t
operator|>
name|bits
argument_list|(
specifier|const
name|M0t
operator|&
name|M0
argument_list|,
specifier|const
name|M1t
operator|&
name|M1
argument_list|,
specifier|const
name|M2t
operator|&
name|M2
argument_list|,
specifier|const
name|M3t
operator|&
name|M3
argument_list|)
operator|:
name|Option
argument_list|(
argument|ZeroOrMore | NotHidden
argument_list|)
block|{
name|apply
argument_list|(
name|M0
argument_list|,
name|this
argument_list|)
block|;
name|apply
argument_list|(
name|M1
argument_list|,
name|this
argument_list|)
block|;
name|apply
argument_list|(
name|M2
argument_list|,
name|this
argument_list|)
block|;
name|apply
argument_list|(
name|M3
argument_list|,
name|this
argument_list|)
block|;
name|done
argument_list|()
block|;   }
comment|// Five options...
name|template
operator|<
name|class
name|M0t
operator|,
name|class
name|M1t
operator|,
name|class
name|M2t
operator|,
name|class
name|M3t
operator|,
name|class
name|M4t
operator|>
name|bits
argument_list|(
specifier|const
name|M0t
operator|&
name|M0
argument_list|,
specifier|const
name|M1t
operator|&
name|M1
argument_list|,
specifier|const
name|M2t
operator|&
name|M2
argument_list|,
specifier|const
name|M3t
operator|&
name|M3
argument_list|,
specifier|const
name|M4t
operator|&
name|M4
argument_list|)
operator|:
name|Option
argument_list|(
argument|ZeroOrMore | NotHidden
argument_list|)
block|{
name|apply
argument_list|(
name|M0
argument_list|,
name|this
argument_list|)
block|;
name|apply
argument_list|(
name|M1
argument_list|,
name|this
argument_list|)
block|;
name|apply
argument_list|(
name|M2
argument_list|,
name|this
argument_list|)
block|;
name|apply
argument_list|(
name|M3
argument_list|,
name|this
argument_list|)
block|;
name|apply
argument_list|(
name|M4
argument_list|,
name|this
argument_list|)
block|;
name|done
argument_list|()
block|;   }
comment|// Six options...
name|template
operator|<
name|class
name|M0t
operator|,
name|class
name|M1t
operator|,
name|class
name|M2t
operator|,
name|class
name|M3t
operator|,
name|class
name|M4t
operator|,
name|class
name|M5t
operator|>
name|bits
argument_list|(
specifier|const
name|M0t
operator|&
name|M0
argument_list|,
specifier|const
name|M1t
operator|&
name|M1
argument_list|,
specifier|const
name|M2t
operator|&
name|M2
argument_list|,
specifier|const
name|M3t
operator|&
name|M3
argument_list|,
specifier|const
name|M4t
operator|&
name|M4
argument_list|,
specifier|const
name|M5t
operator|&
name|M5
argument_list|)
operator|:
name|Option
argument_list|(
argument|ZeroOrMore | NotHidden
argument_list|)
block|{
name|apply
argument_list|(
name|M0
argument_list|,
name|this
argument_list|)
block|;
name|apply
argument_list|(
name|M1
argument_list|,
name|this
argument_list|)
block|;
name|apply
argument_list|(
name|M2
argument_list|,
name|this
argument_list|)
block|;
name|apply
argument_list|(
name|M3
argument_list|,
name|this
argument_list|)
block|;
name|apply
argument_list|(
name|M4
argument_list|,
name|this
argument_list|)
block|;
name|apply
argument_list|(
name|M5
argument_list|,
name|this
argument_list|)
block|;
name|done
argument_list|()
block|;   }
comment|// Seven options...
name|template
operator|<
name|class
name|M0t
operator|,
name|class
name|M1t
operator|,
name|class
name|M2t
operator|,
name|class
name|M3t
operator|,
name|class
name|M4t
operator|,
name|class
name|M5t
operator|,
name|class
name|M6t
operator|>
name|bits
argument_list|(
specifier|const
name|M0t
operator|&
name|M0
argument_list|,
specifier|const
name|M1t
operator|&
name|M1
argument_list|,
specifier|const
name|M2t
operator|&
name|M2
argument_list|,
specifier|const
name|M3t
operator|&
name|M3
argument_list|,
specifier|const
name|M4t
operator|&
name|M4
argument_list|,
specifier|const
name|M5t
operator|&
name|M5
argument_list|,
specifier|const
name|M6t
operator|&
name|M6
argument_list|)
operator|:
name|Option
argument_list|(
argument|ZeroOrMore | NotHidden
argument_list|)
block|{
name|apply
argument_list|(
name|M0
argument_list|,
name|this
argument_list|)
block|;
name|apply
argument_list|(
name|M1
argument_list|,
name|this
argument_list|)
block|;
name|apply
argument_list|(
name|M2
argument_list|,
name|this
argument_list|)
block|;
name|apply
argument_list|(
name|M3
argument_list|,
name|this
argument_list|)
block|;
name|apply
argument_list|(
name|M4
argument_list|,
name|this
argument_list|)
block|;
name|apply
argument_list|(
name|M5
argument_list|,
name|this
argument_list|)
block|;
name|apply
argument_list|(
name|M6
argument_list|,
name|this
argument_list|)
block|;
name|done
argument_list|()
block|;   }
comment|// Eight options...
name|template
operator|<
name|class
name|M0t
operator|,
name|class
name|M1t
operator|,
name|class
name|M2t
operator|,
name|class
name|M3t
operator|,
name|class
name|M4t
operator|,
name|class
name|M5t
operator|,
name|class
name|M6t
operator|,
name|class
name|M7t
operator|>
name|bits
argument_list|(
specifier|const
name|M0t
operator|&
name|M0
argument_list|,
specifier|const
name|M1t
operator|&
name|M1
argument_list|,
specifier|const
name|M2t
operator|&
name|M2
argument_list|,
specifier|const
name|M3t
operator|&
name|M3
argument_list|,
specifier|const
name|M4t
operator|&
name|M4
argument_list|,
specifier|const
name|M5t
operator|&
name|M5
argument_list|,
specifier|const
name|M6t
operator|&
name|M6
argument_list|,
specifier|const
name|M7t
operator|&
name|M7
argument_list|)
operator|:
name|Option
argument_list|(
argument|ZeroOrMore | NotHidden
argument_list|)
block|{
name|apply
argument_list|(
name|M0
argument_list|,
name|this
argument_list|)
block|;
name|apply
argument_list|(
name|M1
argument_list|,
name|this
argument_list|)
block|;
name|apply
argument_list|(
name|M2
argument_list|,
name|this
argument_list|)
block|;
name|apply
argument_list|(
name|M3
argument_list|,
name|this
argument_list|)
block|;
name|apply
argument_list|(
name|M4
argument_list|,
name|this
argument_list|)
block|;
name|apply
argument_list|(
name|M5
argument_list|,
name|this
argument_list|)
block|;
name|apply
argument_list|(
name|M6
argument_list|,
name|this
argument_list|)
block|;
name|apply
argument_list|(
name|M7
argument_list|,
name|this
argument_list|)
block|;
name|done
argument_list|()
block|;   }
end_expr_stmt

begin_comment
unit|};
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|// Aliased command line option (alias this name to a preexisting name)
end_comment

begin_comment
comment|//
end_comment

begin_decl_stmt
name|class
name|alias
range|:
name|public
name|Option
block|{
name|Option
operator|*
name|AliasFor
block|;
name|virtual
name|bool
name|handleOccurrence
argument_list|(
argument|unsigned pos
argument_list|,
argument|StringRef
comment|/*ArgName*/
argument_list|,
argument|StringRef Arg
argument_list|)
block|{
return|return
name|AliasFor
operator|->
name|handleOccurrence
argument_list|(
name|pos
argument_list|,
name|AliasFor
operator|->
name|ArgStr
argument_list|,
name|Arg
argument_list|)
return|;
block|}
comment|// Handle printing stuff...
name|virtual
name|size_t
name|getOptionWidth
argument_list|()
specifier|const
block|;
name|virtual
name|void
name|printOptionInfo
argument_list|(
argument|size_t GlobalWidth
argument_list|)
specifier|const
block|;
name|void
name|done
argument_list|()
block|{
if|if
condition|(
operator|!
name|hasArgStr
argument_list|()
condition|)
name|error
argument_list|(
literal|"cl::alias must have argument name specified!"
argument_list|)
expr_stmt|;
if|if
condition|(
name|AliasFor
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"cl::alias must have an cl::aliasopt(option) specified!"
argument_list|)
expr_stmt|;
name|addArgument
argument_list|()
decl_stmt|;
end_decl_stmt

begin_function
unit|} public:
name|void
name|setAliasFor
parameter_list|(
name|Option
modifier|&
name|O
parameter_list|)
block|{
if|if
condition|(
name|AliasFor
condition|)
name|error
argument_list|(
literal|"cl::alias must only have one cl::aliasopt(...) specified!"
argument_list|)
expr_stmt|;
name|AliasFor
operator|=
operator|&
name|O
expr_stmt|;
block|}
end_function

begin_comment
comment|// One option...
end_comment

begin_expr_stmt
name|template
operator|<
name|class
name|M0t
operator|>
name|explicit
name|alias
argument_list|(
specifier|const
name|M0t
operator|&
name|M0
argument_list|)
operator|:
name|Option
argument_list|(
name|Optional
operator||
name|Hidden
argument_list|)
operator|,
name|AliasFor
argument_list|(
literal|0
argument_list|)
block|{
name|apply
argument_list|(
name|M0
argument_list|,
name|this
argument_list|)
block|;
name|done
argument_list|()
block|;   }
comment|// Two options...
name|template
operator|<
name|class
name|M0t
operator|,
name|class
name|M1t
operator|>
name|alias
argument_list|(
specifier|const
name|M0t
operator|&
name|M0
argument_list|,
specifier|const
name|M1t
operator|&
name|M1
argument_list|)
operator|:
name|Option
argument_list|(
name|Optional
operator||
name|Hidden
argument_list|)
operator|,
name|AliasFor
argument_list|(
literal|0
argument_list|)
block|{
name|apply
argument_list|(
name|M0
argument_list|,
name|this
argument_list|)
block|;
name|apply
argument_list|(
name|M1
argument_list|,
name|this
argument_list|)
block|;
name|done
argument_list|()
block|;   }
comment|// Three options...
name|template
operator|<
name|class
name|M0t
operator|,
name|class
name|M1t
operator|,
name|class
name|M2t
operator|>
name|alias
argument_list|(
specifier|const
name|M0t
operator|&
name|M0
argument_list|,
specifier|const
name|M1t
operator|&
name|M1
argument_list|,
specifier|const
name|M2t
operator|&
name|M2
argument_list|)
operator|:
name|Option
argument_list|(
name|Optional
operator||
name|Hidden
argument_list|)
operator|,
name|AliasFor
argument_list|(
literal|0
argument_list|)
block|{
name|apply
argument_list|(
name|M0
argument_list|,
name|this
argument_list|)
block|;
name|apply
argument_list|(
name|M1
argument_list|,
name|this
argument_list|)
block|;
name|apply
argument_list|(
name|M2
argument_list|,
name|this
argument_list|)
block|;
name|done
argument_list|()
block|;   }
comment|// Four options...
name|template
operator|<
name|class
name|M0t
operator|,
name|class
name|M1t
operator|,
name|class
name|M2t
operator|,
name|class
name|M3t
operator|>
name|alias
argument_list|(
specifier|const
name|M0t
operator|&
name|M0
argument_list|,
specifier|const
name|M1t
operator|&
name|M1
argument_list|,
specifier|const
name|M2t
operator|&
name|M2
argument_list|,
specifier|const
name|M3t
operator|&
name|M3
argument_list|)
operator|:
name|Option
argument_list|(
name|Optional
operator||
name|Hidden
argument_list|)
operator|,
name|AliasFor
argument_list|(
literal|0
argument_list|)
block|{
name|apply
argument_list|(
name|M0
argument_list|,
name|this
argument_list|)
block|;
name|apply
argument_list|(
name|M1
argument_list|,
name|this
argument_list|)
block|;
name|apply
argument_list|(
name|M2
argument_list|,
name|this
argument_list|)
block|;
name|apply
argument_list|(
name|M3
argument_list|,
name|this
argument_list|)
block|;
name|done
argument_list|()
block|;   }
end_expr_stmt

begin_comment
unit|};
comment|// aliasfor - Modifier to set the option an alias aliases.
end_comment

begin_struct
struct|struct
name|aliasopt
block|{
name|Option
modifier|&
name|Opt
decl_stmt|;
name|explicit
name|aliasopt
argument_list|(
name|Option
operator|&
name|O
argument_list|)
operator|:
name|Opt
argument_list|(
argument|O
argument_list|)
block|{}
name|void
name|apply
argument_list|(
argument|alias&A
argument_list|)
specifier|const
block|{
name|A
operator|.
name|setAliasFor
argument_list|(
name|Opt
argument_list|)
block|; }
block|}
struct|;
end_struct

begin_comment
comment|// extrahelp - provide additional help at the end of the normal help
end_comment

begin_comment
comment|// output. All occurrences of cl::extrahelp will be accumulated and
end_comment

begin_comment
comment|// printed to stderr at the end of the regular help, just before
end_comment

begin_comment
comment|// exit is called.
end_comment

begin_struct
struct|struct
name|extrahelp
block|{
specifier|const
name|char
modifier|*
name|morehelp
decl_stmt|;
name|explicit
name|extrahelp
parameter_list|(
specifier|const
name|char
modifier|*
name|help
parameter_list|)
function_decl|;
block|}
struct|;
end_struct

begin_function_decl
name|void
name|PrintVersionMessage
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|// This function just prints the help message, exactly the same way as if the
end_comment

begin_comment
comment|// --help option had been given on the command line.
end_comment

begin_comment
comment|// NOTE: THIS FUNCTION TERMINATES THE PROGRAM!
end_comment

begin_function_decl
name|void
name|PrintHelpMessage
parameter_list|()
function_decl|;
end_function_decl

begin_comment
unit|}
comment|// End namespace cl
end_comment

begin_comment
unit|}
comment|// End namespace llvm
end_comment

begin_endif
endif|#
directive|endif
end_endif

end_unit

