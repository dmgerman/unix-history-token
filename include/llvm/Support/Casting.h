begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===- llvm/Support/Casting.h - Allow flexible, checked, casts --*- C++ -*-===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file defines the isa<X>(), cast<X>(), dyn_cast<X>(), cast_or_null<X>(),
end_comment

begin_comment
comment|// and dyn_cast_or_null<X>() templates.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LLVM_SUPPORT_CASTING_H
end_ifndef

begin_define
define|#
directive|define
name|LLVM_SUPPORT_CASTING_H
end_define

begin_include
include|#
directive|include
file|"llvm/Support/Compiler.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/type_traits.h"
end_include

begin_include
include|#
directive|include
file|<cassert>
end_include

begin_include
include|#
directive|include
file|<memory>
end_include

begin_include
include|#
directive|include
file|<type_traits>
end_include

begin_decl_stmt
name|namespace
name|llvm
block|{
comment|//===----------------------------------------------------------------------===//
comment|//                          isa<x> Support Templates
comment|//===----------------------------------------------------------------------===//
comment|// Define a template that can be specialized by smart pointers to reflect the
comment|// fact that they are automatically dereferenced, and are not involved with the
comment|// template selection process...  the default implementation is a noop.
comment|//
name|template
operator|<
name|typename
name|From
operator|>
expr|struct
name|simplify_type
block|{
name|using
name|SimpleType
operator|=
name|From
block|;
comment|// The real type this represents...
comment|// An accessor to get the real value...
specifier|static
name|SimpleType
operator|&
name|getSimplifiedValue
argument_list|(
argument|From&Val
argument_list|)
block|{
return|return
name|Val
return|;
block|}
expr|}
block|;
name|template
operator|<
name|typename
name|From
operator|>
expr|struct
name|simplify_type
operator|<
specifier|const
name|From
operator|>
block|{
name|using
name|NonConstSimpleType
operator|=
name|typename
name|simplify_type
operator|<
name|From
operator|>
operator|::
name|SimpleType
block|;
name|using
name|SimpleType
operator|=
name|typename
name|add_const_past_pointer
operator|<
name|NonConstSimpleType
operator|>
operator|::
name|type
block|;
name|using
name|RetType
operator|=
name|typename
name|add_lvalue_reference_if_not_pointer
operator|<
name|SimpleType
operator|>
operator|::
name|type
block|;
specifier|static
name|RetType
name|getSimplifiedValue
argument_list|(
argument|const From& Val
argument_list|)
block|{
return|return
name|simplify_type
operator|<
name|From
operator|>
operator|::
name|getSimplifiedValue
argument_list|(
name|const_cast
operator|<
name|From
operator|&
operator|>
operator|(
name|Val
operator|)
argument_list|)
return|;
block|}
expr|}
block|;
comment|// The core of the implementation of isa<X> is here; To and From should be
comment|// the names of classes.  This template can be specialized to customize the
comment|// implementation of isa<> without rewriting it from scratch.
name|template
operator|<
name|typename
name|To
block|,
name|typename
name|From
block|,
name|typename
name|Enabler
operator|=
name|void
operator|>
expr|struct
name|isa_impl
block|{
specifier|static
specifier|inline
name|bool
name|doit
argument_list|(
argument|const From&Val
argument_list|)
block|{
return|return
name|To
operator|::
name|classof
argument_list|(
operator|&
name|Val
argument_list|)
return|;
block|}
expr|}
block|;
comment|/// \brief Always allow upcasts, and perform no dynamic check for them.
name|template
operator|<
name|typename
name|To
block|,
name|typename
name|From
operator|>
expr|struct
name|isa_impl
operator|<
name|To
block|,
name|From
block|,
name|typename
name|std
operator|::
name|enable_if
operator|<
name|std
operator|::
name|is_base_of
operator|<
name|To
block|,
name|From
operator|>
operator|::
name|value
operator|>
operator|::
name|type
operator|>
block|{
specifier|static
specifier|inline
name|bool
name|doit
argument_list|(
argument|const From&
argument_list|)
block|{
return|return
name|true
return|;
block|}
expr|}
block|;
name|template
operator|<
name|typename
name|To
block|,
name|typename
name|From
operator|>
expr|struct
name|isa_impl_cl
block|{
specifier|static
specifier|inline
name|bool
name|doit
argument_list|(
argument|const From&Val
argument_list|)
block|{
return|return
name|isa_impl
operator|<
name|To
operator|,
name|From
operator|>
operator|::
name|doit
argument_list|(
name|Val
argument_list|)
return|;
block|}
expr|}
block|;
name|template
operator|<
name|typename
name|To
block|,
name|typename
name|From
operator|>
expr|struct
name|isa_impl_cl
operator|<
name|To
block|,
specifier|const
name|From
operator|>
block|{
specifier|static
specifier|inline
name|bool
name|doit
argument_list|(
argument|const From&Val
argument_list|)
block|{
return|return
name|isa_impl
operator|<
name|To
operator|,
name|From
operator|>
operator|::
name|doit
argument_list|(
name|Val
argument_list|)
return|;
block|}
expr|}
block|;
name|template
operator|<
name|typename
name|To
block|,
name|typename
name|From
operator|>
expr|struct
name|isa_impl_cl
operator|<
name|To
block|,
specifier|const
name|std
operator|::
name|unique_ptr
operator|<
name|From
operator|>>
block|{
specifier|static
specifier|inline
name|bool
name|doit
argument_list|(
argument|const std::unique_ptr<From>&Val
argument_list|)
block|{
name|assert
argument_list|(
name|Val
operator|&&
literal|"isa<> used on a null pointer"
argument_list|)
block|;
return|return
name|isa_impl_cl
operator|<
name|To
operator|,
name|From
operator|>
operator|::
name|doit
argument_list|(
operator|*
name|Val
argument_list|)
return|;
block|}
expr|}
block|;
name|template
operator|<
name|typename
name|To
block|,
name|typename
name|From
operator|>
expr|struct
name|isa_impl_cl
operator|<
name|To
block|,
name|From
operator|*
operator|>
block|{
specifier|static
specifier|inline
name|bool
name|doit
argument_list|(
argument|const From *Val
argument_list|)
block|{
name|assert
argument_list|(
name|Val
operator|&&
literal|"isa<> used on a null pointer"
argument_list|)
block|;
return|return
name|isa_impl
operator|<
name|To
operator|,
name|From
operator|>
operator|::
name|doit
argument_list|(
operator|*
name|Val
argument_list|)
return|;
block|}
expr|}
block|;
name|template
operator|<
name|typename
name|To
block|,
name|typename
name|From
operator|>
expr|struct
name|isa_impl_cl
operator|<
name|To
block|,
name|From
operator|*
specifier|const
operator|>
block|{
specifier|static
specifier|inline
name|bool
name|doit
argument_list|(
argument|const From *Val
argument_list|)
block|{
name|assert
argument_list|(
name|Val
operator|&&
literal|"isa<> used on a null pointer"
argument_list|)
block|;
return|return
name|isa_impl
operator|<
name|To
operator|,
name|From
operator|>
operator|::
name|doit
argument_list|(
operator|*
name|Val
argument_list|)
return|;
block|}
expr|}
block|;
name|template
operator|<
name|typename
name|To
block|,
name|typename
name|From
operator|>
expr|struct
name|isa_impl_cl
operator|<
name|To
block|,
specifier|const
name|From
operator|*
operator|>
block|{
specifier|static
specifier|inline
name|bool
name|doit
argument_list|(
argument|const From *Val
argument_list|)
block|{
name|assert
argument_list|(
name|Val
operator|&&
literal|"isa<> used on a null pointer"
argument_list|)
block|;
return|return
name|isa_impl
operator|<
name|To
operator|,
name|From
operator|>
operator|::
name|doit
argument_list|(
operator|*
name|Val
argument_list|)
return|;
block|}
expr|}
block|;
name|template
operator|<
name|typename
name|To
block|,
name|typename
name|From
operator|>
expr|struct
name|isa_impl_cl
operator|<
name|To
block|,
specifier|const
name|From
operator|*
specifier|const
operator|>
block|{
specifier|static
specifier|inline
name|bool
name|doit
argument_list|(
argument|const From *Val
argument_list|)
block|{
name|assert
argument_list|(
name|Val
operator|&&
literal|"isa<> used on a null pointer"
argument_list|)
block|;
return|return
name|isa_impl
operator|<
name|To
operator|,
name|From
operator|>
operator|::
name|doit
argument_list|(
operator|*
name|Val
argument_list|)
return|;
block|}
expr|}
block|;
name|template
operator|<
name|typename
name|To
block|,
name|typename
name|From
block|,
name|typename
name|SimpleFrom
operator|>
expr|struct
name|isa_impl_wrap
block|{
comment|// When From != SimplifiedType, we can simplify the type some more by using
comment|// the simplify_type template.
specifier|static
name|bool
name|doit
argument_list|(
argument|const From&Val
argument_list|)
block|{
return|return
name|isa_impl_wrap
operator|<
name|To
operator|,
name|SimpleFrom
operator|,
name|typename
name|simplify_type
operator|<
name|SimpleFrom
operator|>
operator|::
name|SimpleType
operator|>
operator|::
name|doit
argument_list|(
name|simplify_type
operator|<
specifier|const
name|From
operator|>
operator|::
name|getSimplifiedValue
argument_list|(
name|Val
argument_list|)
argument_list|)
return|;
block|}
expr|}
block|;
name|template
operator|<
name|typename
name|To
block|,
name|typename
name|FromTy
operator|>
expr|struct
name|isa_impl_wrap
operator|<
name|To
block|,
name|FromTy
block|,
name|FromTy
operator|>
block|{
comment|// When From == SimpleType, we are as simple as we are going to get.
specifier|static
name|bool
name|doit
argument_list|(
argument|const FromTy&Val
argument_list|)
block|{
return|return
name|isa_impl_cl
operator|<
name|To
operator|,
name|FromTy
operator|>
operator|::
name|doit
argument_list|(
name|Val
argument_list|)
return|;
block|}
expr|}
block|;
comment|// isa<X> - Return true if the parameter to the template is an instance of the
comment|// template type argument.  Used like this:
comment|//
comment|//  if (isa<Type>(myVal)) { ... }
comment|//
name|template
operator|<
name|class
name|X
block|,
name|class
name|Y
operator|>
name|LLVM_NODISCARD
specifier|inline
name|bool
name|isa
argument_list|(
argument|const Y&Val
argument_list|)
block|{
return|return
name|isa_impl_wrap
operator|<
name|X
operator|,
specifier|const
name|Y
operator|,
name|typename
name|simplify_type
operator|<
specifier|const
name|Y
operator|>
operator|::
name|SimpleType
operator|>
operator|::
name|doit
argument_list|(
name|Val
argument_list|)
return|;
block|}
comment|//===----------------------------------------------------------------------===//
comment|//                          cast<x> Support Templates
comment|//===----------------------------------------------------------------------===//
name|template
operator|<
name|class
name|To
block|,
name|class
name|From
operator|>
expr|struct
name|cast_retty
block|;
comment|// Calculate what type the 'cast' function should return, based on a requested
comment|// type of To and a source type of From.
name|template
operator|<
name|class
name|To
block|,
name|class
name|From
operator|>
expr|struct
name|cast_retty_impl
block|{
name|using
name|ret_type
operator|=
name|To
operator|&
block|;
comment|// Normal case, return Ty&
block|}
block|;
name|template
operator|<
name|class
name|To
block|,
name|class
name|From
operator|>
expr|struct
name|cast_retty_impl
operator|<
name|To
block|,
specifier|const
name|From
operator|>
block|{
name|using
name|ret_type
operator|=
specifier|const
name|To
operator|&
block|;
comment|// Normal case, return Ty&
block|}
block|;
name|template
operator|<
name|class
name|To
block|,
name|class
name|From
operator|>
expr|struct
name|cast_retty_impl
operator|<
name|To
block|,
name|From
operator|*
operator|>
block|{
name|using
name|ret_type
operator|=
name|To
operator|*
block|;
comment|// Pointer arg case, return Ty*
block|}
block|;
name|template
operator|<
name|class
name|To
block|,
name|class
name|From
operator|>
expr|struct
name|cast_retty_impl
operator|<
name|To
block|,
specifier|const
name|From
operator|*
operator|>
block|{
name|using
name|ret_type
operator|=
specifier|const
name|To
operator|*
block|;
comment|// Constant pointer arg case, return const Ty*
block|}
block|;
name|template
operator|<
name|class
name|To
block|,
name|class
name|From
operator|>
expr|struct
name|cast_retty_impl
operator|<
name|To
block|,
specifier|const
name|From
operator|*
specifier|const
operator|>
block|{
name|using
name|ret_type
operator|=
specifier|const
name|To
operator|*
block|;
comment|// Constant pointer arg case, return const Ty*
block|}
block|;
name|template
operator|<
name|class
name|To
block|,
name|class
name|From
operator|>
expr|struct
name|cast_retty_impl
operator|<
name|To
block|,
name|std
operator|::
name|unique_ptr
operator|<
name|From
operator|>>
block|{
name|private
operator|:
name|using
name|PointerType
operator|=
name|typename
name|cast_retty_impl
operator|<
name|To
block|,
name|From
operator|*
operator|>
operator|::
name|ret_type
block|;
name|using
name|ResultType
operator|=
name|typename
name|std
operator|::
name|remove_pointer
operator|<
name|PointerType
operator|>
operator|::
name|type
block|;
name|public
operator|:
name|using
name|ret_type
operator|=
name|std
operator|::
name|unique_ptr
operator|<
name|ResultType
operator|>
block|; }
block|;
name|template
operator|<
name|class
name|To
block|,
name|class
name|From
block|,
name|class
name|SimpleFrom
operator|>
expr|struct
name|cast_retty_wrap
block|{
comment|// When the simplified type and the from type are not the same, use the type
comment|// simplifier to reduce the type, then reuse cast_retty_impl to get the
comment|// resultant type.
name|using
name|ret_type
operator|=
name|typename
name|cast_retty
operator|<
name|To
block|,
name|SimpleFrom
operator|>
operator|::
name|ret_type
block|; }
block|;
name|template
operator|<
name|class
name|To
block|,
name|class
name|FromTy
operator|>
expr|struct
name|cast_retty_wrap
operator|<
name|To
block|,
name|FromTy
block|,
name|FromTy
operator|>
block|{
comment|// When the simplified type is equal to the from type, use it directly.
name|using
name|ret_type
operator|=
name|typename
name|cast_retty_impl
operator|<
name|To
block|,
name|FromTy
operator|>
operator|::
name|ret_type
block|; }
block|;
name|template
operator|<
name|class
name|To
block|,
name|class
name|From
operator|>
expr|struct
name|cast_retty
block|{
name|using
name|ret_type
operator|=
name|typename
name|cast_retty_wrap
operator|<
name|To
block|,
name|From
block|,
name|typename
name|simplify_type
operator|<
name|From
operator|>
operator|::
name|SimpleType
operator|>
operator|::
name|ret_type
block|; }
block|;
comment|// Ensure the non-simple values are converted using the simplify_type template
comment|// that may be specialized by smart pointers...
comment|//
name|template
operator|<
name|class
name|To
block|,
name|class
name|From
block|,
name|class
name|SimpleFrom
operator|>
expr|struct
name|cast_convert_val
block|{
comment|// This is not a simple type, use the template to simplify it...
specifier|static
name|typename
name|cast_retty
operator|<
name|To
block|,
name|From
operator|>
operator|::
name|ret_type
name|doit
argument_list|(
argument|From&Val
argument_list|)
block|{
return|return
name|cast_convert_val
operator|<
name|To
operator|,
name|SimpleFrom
operator|,
name|typename
name|simplify_type
operator|<
name|SimpleFrom
operator|>
operator|::
name|SimpleType
operator|>
operator|::
name|doit
argument_list|(
name|simplify_type
operator|<
name|From
operator|>
operator|::
name|getSimplifiedValue
argument_list|(
name|Val
argument_list|)
argument_list|)
return|;
block|}
expr|}
block|;
name|template
operator|<
name|class
name|To
block|,
name|class
name|FromTy
operator|>
expr|struct
name|cast_convert_val
operator|<
name|To
block|,
name|FromTy
block|,
name|FromTy
operator|>
block|{
comment|// This _is_ a simple type, just cast it.
specifier|static
name|typename
name|cast_retty
operator|<
name|To
block|,
name|FromTy
operator|>
operator|::
name|ret_type
name|doit
argument_list|(
argument|const FromTy&Val
argument_list|)
block|{
name|typename
name|cast_retty
operator|<
name|To
block|,
name|FromTy
operator|>
operator|::
name|ret_type
name|Res2
operator|=
operator|(
name|typename
name|cast_retty
operator|<
name|To
operator|,
name|FromTy
operator|>
operator|::
name|ret_type
operator|)
name|const_cast
operator|<
name|FromTy
operator|&
operator|>
operator|(
name|Val
operator|)
block|;
return|return
name|Res2
return|;
block|}
expr|}
block|;
name|template
operator|<
name|class
name|X
operator|>
expr|struct
name|is_simple_type
block|{
specifier|static
specifier|const
name|bool
name|value
operator|=
name|std
operator|::
name|is_same
operator|<
name|X
block|,
name|typename
name|simplify_type
operator|<
name|X
operator|>
operator|::
name|SimpleType
operator|>
operator|::
name|value
block|; }
block|;
comment|// cast<X> - Return the argument parameter cast to the specified type.  This
comment|// casting operator asserts that the type is correct, so it does not return null
comment|// on failure.  It does not allow a null argument (use cast_or_null for that).
comment|// It is typically used like this:
comment|//
comment|//  cast<Instruction>(myVal)->getParent()
comment|//
name|template
operator|<
name|class
name|X
block|,
name|class
name|Y
operator|>
specifier|inline
name|typename
name|std
operator|::
name|enable_if
operator|<
operator|!
name|is_simple_type
operator|<
name|Y
operator|>
operator|::
name|value
block|,
name|typename
name|cast_retty
operator|<
name|X
block|,
specifier|const
name|Y
operator|>
operator|::
name|ret_type
operator|>
operator|::
name|type
name|cast
argument_list|(
argument|const Y&Val
argument_list|)
block|{
name|assert
argument_list|(
name|isa
operator|<
name|X
operator|>
operator|(
name|Val
operator|)
operator|&&
literal|"cast<Ty>() argument of incompatible type!"
argument_list|)
block|;
return|return
name|cast_convert_val
operator|<
name|X
operator|,
specifier|const
name|Y
operator|,
name|typename
name|simplify_type
operator|<
specifier|const
name|Y
operator|>
operator|::
name|SimpleType
operator|>
operator|::
name|doit
argument_list|(
name|Val
argument_list|)
return|;
block|}
name|template
operator|<
name|class
name|X
block|,
name|class
name|Y
operator|>
specifier|inline
name|typename
name|cast_retty
operator|<
name|X
block|,
name|Y
operator|>
operator|::
name|ret_type
name|cast
argument_list|(
argument|Y&Val
argument_list|)
block|{
name|assert
argument_list|(
name|isa
operator|<
name|X
operator|>
operator|(
name|Val
operator|)
operator|&&
literal|"cast<Ty>() argument of incompatible type!"
argument_list|)
block|;
return|return
name|cast_convert_val
operator|<
name|X
operator|,
name|Y
operator|,
name|typename
name|simplify_type
operator|<
name|Y
operator|>
operator|::
name|SimpleType
operator|>
operator|::
name|doit
argument_list|(
name|Val
argument_list|)
return|;
block|}
name|template
operator|<
name|class
name|X
block|,
name|class
name|Y
operator|>
specifier|inline
name|typename
name|cast_retty
operator|<
name|X
block|,
name|Y
operator|*
operator|>
operator|::
name|ret_type
name|cast
argument_list|(
argument|Y *Val
argument_list|)
block|{
name|assert
argument_list|(
name|isa
operator|<
name|X
operator|>
operator|(
name|Val
operator|)
operator|&&
literal|"cast<Ty>() argument of incompatible type!"
argument_list|)
block|;
return|return
name|cast_convert_val
operator|<
name|X
operator|,
name|Y
operator|*
operator|,
name|typename
name|simplify_type
operator|<
name|Y
operator|*
operator|>
operator|::
name|SimpleType
operator|>
operator|::
name|doit
argument_list|(
name|Val
argument_list|)
return|;
block|}
name|template
operator|<
name|class
name|X
block|,
name|class
name|Y
operator|>
specifier|inline
name|typename
name|cast_retty
operator|<
name|X
block|,
name|std
operator|::
name|unique_ptr
operator|<
name|Y
operator|>>
operator|::
name|ret_type
name|cast
argument_list|(
argument|std::unique_ptr<Y>&&Val
argument_list|)
block|{
name|assert
argument_list|(
name|isa
operator|<
name|X
operator|>
operator|(
name|Val
operator|.
name|get
argument_list|()
operator|)
operator|&&
literal|"cast<Ty>() argument of incompatible type!"
argument_list|)
block|;
name|using
name|ret_type
operator|=
name|typename
name|cast_retty
operator|<
name|X
block|,
name|std
operator|::
name|unique_ptr
operator|<
name|Y
operator|>>
operator|::
name|ret_type
block|;
return|return
name|ret_type
argument_list|(
argument|cast_convert_val<X
argument_list|,
argument|Y *
argument_list|,
argument|typename simplify_type<Y *>::SimpleType>::doit(           Val.release())
argument_list|)
return|;
block|}
comment|// cast_or_null<X> - Functionally identical to cast, except that a null value is
comment|// accepted.
comment|//
name|template
operator|<
name|class
name|X
block|,
name|class
name|Y
operator|>
name|LLVM_NODISCARD
specifier|inline
name|typename
name|std
operator|::
name|enable_if
operator|<
operator|!
name|is_simple_type
operator|<
name|Y
operator|>
operator|::
name|value
block|,
name|typename
name|cast_retty
operator|<
name|X
block|,
specifier|const
name|Y
operator|>
operator|::
name|ret_type
operator|>
operator|::
name|type
name|cast_or_null
argument_list|(
argument|const Y&Val
argument_list|)
block|{
if|if
condition|(
operator|!
name|Val
condition|)
return|return
name|nullptr
return|;
name|assert
argument_list|(
name|isa
operator|<
name|X
operator|>
operator|(
name|Val
operator|)
operator|&&
literal|"cast_or_null<Ty>() argument of incompatible type!"
argument_list|)
block|;
return|return
name|cast
operator|<
name|X
operator|>
operator|(
name|Val
operator|)
return|;
block|}
name|template
operator|<
name|class
name|X
block|,
name|class
name|Y
operator|>
name|LLVM_NODISCARD
specifier|inline
name|typename
name|std
operator|::
name|enable_if
operator|<
operator|!
name|is_simple_type
operator|<
name|Y
operator|>
operator|::
name|value
block|,
name|typename
name|cast_retty
operator|<
name|X
block|,
name|Y
operator|>
operator|::
name|ret_type
operator|>
operator|::
name|type
name|cast_or_null
argument_list|(
argument|Y&Val
argument_list|)
block|{
if|if
condition|(
operator|!
name|Val
condition|)
return|return
name|nullptr
return|;
name|assert
argument_list|(
name|isa
operator|<
name|X
operator|>
operator|(
name|Val
operator|)
operator|&&
literal|"cast_or_null<Ty>() argument of incompatible type!"
argument_list|)
block|;
return|return
name|cast
operator|<
name|X
operator|>
operator|(
name|Val
operator|)
return|;
block|}
name|template
operator|<
name|class
name|X
block|,
name|class
name|Y
operator|>
name|LLVM_NODISCARD
specifier|inline
name|typename
name|cast_retty
operator|<
name|X
block|,
name|Y
operator|*
operator|>
operator|::
name|ret_type
name|cast_or_null
argument_list|(
argument|Y *Val
argument_list|)
block|{
if|if
condition|(
operator|!
name|Val
condition|)
return|return
name|nullptr
return|;
name|assert
argument_list|(
name|isa
operator|<
name|X
operator|>
operator|(
name|Val
operator|)
operator|&&
literal|"cast_or_null<Ty>() argument of incompatible type!"
argument_list|)
block|;
return|return
name|cast
operator|<
name|X
operator|>
operator|(
name|Val
operator|)
return|;
block|}
name|template
operator|<
name|class
name|X
block|,
name|class
name|Y
operator|>
specifier|inline
name|typename
name|cast_retty
operator|<
name|X
block|,
name|std
operator|::
name|unique_ptr
operator|<
name|Y
operator|>>
operator|::
name|ret_type
name|cast_or_null
argument_list|(
argument|std::unique_ptr<Y>&&Val
argument_list|)
block|{
if|if
condition|(
operator|!
name|Val
condition|)
return|return
name|nullptr
return|;
return|return
name|cast
operator|<
name|X
operator|>
operator|(
name|std
operator|::
name|move
argument_list|(
name|Val
argument_list|)
operator|)
return|;
block|}
comment|// dyn_cast<X> - Return the argument parameter cast to the specified type.  This
comment|// casting operator returns null if the argument is of the wrong type, so it can
comment|// be used to test for a type as well as cast if successful.  This should be
comment|// used in the context of an if statement like this:
comment|//
comment|//  if (const Instruction *I = dyn_cast<Instruction>(myVal)) { ... }
comment|//
name|template
operator|<
name|class
name|X
block|,
name|class
name|Y
operator|>
name|LLVM_NODISCARD
specifier|inline
name|typename
name|std
operator|::
name|enable_if
operator|<
operator|!
name|is_simple_type
operator|<
name|Y
operator|>
operator|::
name|value
block|,
name|typename
name|cast_retty
operator|<
name|X
block|,
specifier|const
name|Y
operator|>
operator|::
name|ret_type
operator|>
operator|::
name|type
name|dyn_cast
argument_list|(
argument|const Y&Val
argument_list|)
block|{
return|return
name|isa
operator|<
name|X
operator|>
operator|(
name|Val
operator|)
operator|?
name|cast
operator|<
name|X
operator|>
operator|(
name|Val
operator|)
operator|:
name|nullptr
return|;
block|}
name|template
operator|<
name|class
name|X
block|,
name|class
name|Y
operator|>
name|LLVM_NODISCARD
specifier|inline
name|typename
name|cast_retty
operator|<
name|X
block|,
name|Y
operator|>
operator|::
name|ret_type
name|dyn_cast
argument_list|(
argument|Y&Val
argument_list|)
block|{
return|return
name|isa
operator|<
name|X
operator|>
operator|(
name|Val
operator|)
condition|?
name|cast
operator|<
name|X
operator|>
operator|(
name|Val
operator|)
else|:
name|nullptr
return|;
block|}
name|template
operator|<
name|class
name|X
block|,
name|class
name|Y
operator|>
name|LLVM_NODISCARD
specifier|inline
name|typename
name|cast_retty
operator|<
name|X
block|,
name|Y
operator|*
operator|>
operator|::
name|ret_type
name|dyn_cast
argument_list|(
argument|Y *Val
argument_list|)
block|{
return|return
name|isa
operator|<
name|X
operator|>
operator|(
name|Val
operator|)
condition|?
name|cast
operator|<
name|X
operator|>
operator|(
name|Val
operator|)
else|:
name|nullptr
return|;
block|}
comment|// dyn_cast_or_null<X> - Functionally identical to dyn_cast, except that a null
comment|// value is accepted.
comment|//
name|template
operator|<
name|class
name|X
block|,
name|class
name|Y
operator|>
name|LLVM_NODISCARD
specifier|inline
name|typename
name|std
operator|::
name|enable_if
operator|<
operator|!
name|is_simple_type
operator|<
name|Y
operator|>
operator|::
name|value
block|,
name|typename
name|cast_retty
operator|<
name|X
block|,
specifier|const
name|Y
operator|>
operator|::
name|ret_type
operator|>
operator|::
name|type
name|dyn_cast_or_null
argument_list|(
argument|const Y&Val
argument_list|)
block|{
return|return
operator|(
name|Val
operator|&&
name|isa
operator|<
name|X
operator|>
operator|(
name|Val
operator|)
operator|)
condition|?
name|cast
operator|<
name|X
operator|>
operator|(
name|Val
operator|)
else|:
name|nullptr
return|;
block|}
name|template
operator|<
name|class
name|X
block|,
name|class
name|Y
operator|>
name|LLVM_NODISCARD
specifier|inline
name|typename
name|std
operator|::
name|enable_if
operator|<
operator|!
name|is_simple_type
operator|<
name|Y
operator|>
operator|::
name|value
block|,
name|typename
name|cast_retty
operator|<
name|X
block|,
name|Y
operator|>
operator|::
name|ret_type
operator|>
operator|::
name|type
name|dyn_cast_or_null
argument_list|(
argument|Y&Val
argument_list|)
block|{
return|return
operator|(
name|Val
operator|&&
name|isa
operator|<
name|X
operator|>
operator|(
name|Val
operator|)
operator|)
condition|?
name|cast
operator|<
name|X
operator|>
operator|(
name|Val
operator|)
else|:
name|nullptr
return|;
block|}
name|template
operator|<
name|class
name|X
block|,
name|class
name|Y
operator|>
name|LLVM_NODISCARD
specifier|inline
name|typename
name|cast_retty
operator|<
name|X
block|,
name|Y
operator|*
operator|>
operator|::
name|ret_type
name|dyn_cast_or_null
argument_list|(
argument|Y *Val
argument_list|)
block|{
return|return
operator|(
name|Val
operator|&&
name|isa
operator|<
name|X
operator|>
operator|(
name|Val
operator|)
operator|)
condition|?
name|cast
operator|<
name|X
operator|>
operator|(
name|Val
operator|)
else|:
name|nullptr
return|;
block|}
comment|// unique_dyn_cast<X> - Given a unique_ptr<Y>, try to return a unique_ptr<X>,
comment|// taking ownership of the input pointer iff isa<X>(Val) is true.  If the
comment|// cast is successful, From refers to nullptr on exit and the casted value
comment|// is returned.  If the cast is unsuccessful, the function returns nullptr
comment|// and From is unchanged.
name|template
operator|<
name|class
name|X
block|,
name|class
name|Y
operator|>
name|LLVM_NODISCARD
specifier|inline
name|auto
name|unique_dyn_cast
argument_list|(
name|std
operator|::
name|unique_ptr
operator|<
name|Y
operator|>
operator|&
name|Val
argument_list|)
operator|->
name|decltype
argument_list|(
argument|cast<X>(Val)
argument_list|)
block|{
if|if
condition|(
operator|!
name|isa
operator|<
name|X
operator|>
operator|(
name|Val
operator|)
condition|)
return|return
name|nullptr
return|;
return|return
name|cast
operator|<
name|X
operator|>
operator|(
name|std
operator|::
name|move
argument_list|(
name|Val
argument_list|)
operator|)
return|;
block|}
name|template
operator|<
name|class
name|X
block|,
name|class
name|Y
operator|>
name|LLVM_NODISCARD
specifier|inline
name|auto
name|unique_dyn_cast
argument_list|(
name|std
operator|::
name|unique_ptr
operator|<
name|Y
operator|>
operator|&&
name|Val
argument_list|)
operator|->
name|decltype
argument_list|(
argument|cast<X>(Val)
argument_list|)
block|{
return|return
name|unique_dyn_cast
operator|<
name|X
operator|,
name|Y
operator|>
operator|(
name|Val
operator|)
return|;
block|}
comment|// dyn_cast_or_null<X> - Functionally identical to unique_dyn_cast, except that
comment|// a null value is accepted.
name|template
operator|<
name|class
name|X
block|,
name|class
name|Y
operator|>
name|LLVM_NODISCARD
specifier|inline
name|auto
name|unique_dyn_cast_or_null
argument_list|(
name|std
operator|::
name|unique_ptr
operator|<
name|Y
operator|>
operator|&
name|Val
argument_list|)
operator|->
name|decltype
argument_list|(
argument|cast<X>(Val)
argument_list|)
block|{
if|if
condition|(
operator|!
name|Val
condition|)
return|return
name|nullptr
return|;
return|return
name|unique_dyn_cast
operator|<
name|X
operator|,
name|Y
operator|>
operator|(
name|Val
operator|)
return|;
block|}
name|template
operator|<
name|class
name|X
block|,
name|class
name|Y
operator|>
name|LLVM_NODISCARD
specifier|inline
name|auto
name|unique_dyn_cast_or_null
argument_list|(
name|std
operator|::
name|unique_ptr
operator|<
name|Y
operator|>
operator|&&
name|Val
argument_list|)
operator|->
name|decltype
argument_list|(
argument|cast<X>(Val)
argument_list|)
block|{
return|return
name|unique_dyn_cast_or_null
operator|<
name|X
operator|,
name|Y
operator|>
operator|(
name|Val
operator|)
return|;
block|}
expr|}
end_decl_stmt

begin_comment
comment|// end namespace llvm
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|// LLVM_SUPPORT_CASTING_H
end_comment

end_unit

