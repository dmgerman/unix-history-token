begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===-- llvm/Support/Casting.h - Allow flexible, checked, casts -*- C++ -*-===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file defines the isa<X>(), cast<X>(), dyn_cast<X>(), cast_or_null<X>(),
end_comment

begin_comment
comment|// and dyn_cast_or_null<X>() templates.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LLVM_SUPPORT_CASTING_H
end_ifndef

begin_define
define|#
directive|define
name|LLVM_SUPPORT_CASTING_H
end_define

begin_include
include|#
directive|include
file|<cassert>
end_include

begin_decl_stmt
name|namespace
name|llvm
block|{
comment|//===----------------------------------------------------------------------===//
comment|//                          isa<x> Support Templates
comment|//===----------------------------------------------------------------------===//
name|template
operator|<
name|typename
name|FromCl
operator|>
expr|struct
name|isa_impl_cl
expr_stmt|;
comment|// Define a template that can be specialized by smart pointers to reflect the
comment|// fact that they are automatically dereferenced, and are not involved with the
comment|// template selection process...  the default implementation is a noop.
comment|//
name|template
operator|<
name|typename
name|From
operator|>
expr|struct
name|simplify_type
block|{
typedef|typedef
name|From
name|SimpleType
typedef|;
comment|// The real type this represents...
comment|// An accessor to get the real value...
specifier|static
name|SimpleType
operator|&
name|getSimplifiedValue
argument_list|(
argument|From&Val
argument_list|)
block|{
return|return
name|Val
return|;
block|}
block|}
empty_stmt|;
name|template
operator|<
name|typename
name|From
operator|>
expr|struct
name|simplify_type
operator|<
specifier|const
name|From
operator|>
block|{
typedef|typedef
specifier|const
name|From
name|SimpleType
typedef|;
specifier|static
name|SimpleType
operator|&
name|getSimplifiedValue
argument_list|(
argument|const From&Val
argument_list|)
block|{
return|return
name|simplify_type
operator|<
name|From
operator|>
operator|::
name|getSimplifiedValue
argument_list|(
name|static_cast
operator|<
name|From
operator|&
operator|>
operator|(
name|Val
operator|)
argument_list|)
return|;
block|}
block|}
empty_stmt|;
comment|// isa<X> - Return true if the parameter to the template is an instance of the
comment|// template type argument.  Used like this:
comment|//
comment|//  if (isa<Type*>(myVal)) { ... }
comment|//
name|template
operator|<
name|typename
name|To
operator|,
name|typename
name|From
operator|>
specifier|inline
name|bool
name|isa_impl
argument_list|(
argument|const From&Val
argument_list|)
block|{
return|return
name|To
operator|::
name|classof
argument_list|(
operator|&
name|Val
argument_list|)
return|;
block|}
name|template
operator|<
name|typename
name|To
operator|,
name|typename
name|From
operator|,
name|typename
name|SimpleType
operator|>
expr|struct
name|isa_impl_wrap
block|{
comment|// When From != SimplifiedType, we can simplify the type some more by using
comment|// the simplify_type template.
specifier|static
name|bool
name|doit
argument_list|(
argument|const From&Val
argument_list|)
block|{
return|return
name|isa_impl_cl
operator|<
specifier|const
name|SimpleType
operator|>
operator|::
name|template
name|isa
operator|<
name|To
operator|>
operator|(
name|simplify_type
operator|<
specifier|const
name|From
operator|>
operator|::
name|getSimplifiedValue
argument_list|(
name|Val
argument_list|)
operator|)
return|;
block|}
expr|}
block|;
name|template
operator|<
name|typename
name|To
block|,
name|typename
name|FromTy
operator|>
expr|struct
name|isa_impl_wrap
operator|<
name|To
block|,
specifier|const
name|FromTy
block|,
specifier|const
name|FromTy
operator|>
block|{
comment|// When From == SimpleType, we are as simple as we are going to get.
specifier|static
name|bool
name|doit
argument_list|(
argument|const FromTy&Val
argument_list|)
block|{
return|return
name|isa_impl
operator|<
name|To
operator|,
name|FromTy
operator|>
operator|(
name|Val
operator|)
return|;
block|}
expr|}
block|;
comment|// isa_impl_cl - Use class partial specialization to transform types to a single
comment|// canonical form for isa_impl.
comment|//
name|template
operator|<
name|typename
name|FromCl
operator|>
expr|struct
name|isa_impl_cl
block|{
name|template
operator|<
name|class
name|ToCl
operator|>
specifier|static
name|bool
name|isa
argument_list|(
argument|const FromCl&Val
argument_list|)
block|{
return|return
name|isa_impl_wrap
operator|<
name|ToCl
operator|,
specifier|const
name|FromCl
operator|,
name|typename
name|simplify_type
operator|<
specifier|const
name|FromCl
operator|>
operator|::
name|SimpleType
operator|>
operator|::
name|doit
argument_list|(
name|Val
argument_list|)
return|;
block|}
expr|}
block|;
comment|// Specialization used to strip const qualifiers off of the FromCl type...
name|template
operator|<
name|typename
name|FromCl
operator|>
expr|struct
name|isa_impl_cl
operator|<
specifier|const
name|FromCl
operator|>
block|{
name|template
operator|<
name|class
name|ToCl
operator|>
specifier|static
name|bool
name|isa
argument_list|(
argument|const FromCl&Val
argument_list|)
block|{
return|return
name|isa_impl_cl
operator|<
name|FromCl
operator|>
operator|::
name|template
name|isa
operator|<
name|ToCl
operator|>
operator|(
name|Val
operator|)
return|;
block|}
expr|}
block|;
comment|// Define pointer traits in terms of base traits...
name|template
operator|<
name|class
name|FromCl
operator|>
expr|struct
name|isa_impl_cl
operator|<
name|FromCl
operator|*
operator|>
block|{
name|template
operator|<
name|class
name|ToCl
operator|>
specifier|static
name|bool
name|isa
argument_list|(
argument|FromCl *Val
argument_list|)
block|{
return|return
name|isa_impl_cl
operator|<
name|FromCl
operator|>
operator|::
name|template
name|isa
operator|<
name|ToCl
operator|>
operator|(
operator|*
name|Val
operator|)
return|;
block|}
expr|}
block|;
comment|// Define reference traits in terms of base traits...
name|template
operator|<
name|class
name|FromCl
operator|>
expr|struct
name|isa_impl_cl
operator|<
name|FromCl
operator|&
operator|>
block|{
name|template
operator|<
name|class
name|ToCl
operator|>
specifier|static
name|bool
name|isa
argument_list|(
argument|FromCl&Val
argument_list|)
block|{
return|return
name|isa_impl_cl
operator|<
name|FromCl
operator|>
operator|::
name|template
name|isa
operator|<
name|ToCl
operator|>
operator|(
operator|&
name|Val
operator|)
return|;
block|}
expr|}
block|;
name|template
operator|<
name|class
name|X
block|,
name|class
name|Y
operator|>
specifier|inline
name|bool
name|isa
argument_list|(
argument|const Y&Val
argument_list|)
block|{
return|return
name|isa_impl_cl
operator|<
name|Y
operator|>
operator|::
name|template
name|isa
operator|<
name|X
operator|>
operator|(
name|Val
operator|)
return|;
block|}
comment|//===----------------------------------------------------------------------===//
comment|//                          cast<x> Support Templates
comment|//===----------------------------------------------------------------------===//
name|template
operator|<
name|class
name|To
block|,
name|class
name|From
operator|>
expr|struct
name|cast_retty
block|;
comment|// Calculate what type the 'cast' function should return, based on a requested
comment|// type of To and a source type of From.
name|template
operator|<
name|class
name|To
block|,
name|class
name|From
operator|>
expr|struct
name|cast_retty_impl
block|{
typedef|typedef
name|To
modifier|&
name|ret_type
typedef|;
comment|// Normal case, return Ty&
block|}
block|;
name|template
operator|<
name|class
name|To
block|,
name|class
name|From
operator|>
expr|struct
name|cast_retty_impl
operator|<
name|To
block|,
specifier|const
name|From
operator|>
block|{
typedef|typedef
specifier|const
name|To
modifier|&
name|ret_type
typedef|;
comment|// Normal case, return Ty&
block|}
block|;
name|template
operator|<
name|class
name|To
block|,
name|class
name|From
operator|>
expr|struct
name|cast_retty_impl
operator|<
name|To
block|,
name|From
operator|*
operator|>
block|{
typedef|typedef
name|To
modifier|*
name|ret_type
typedef|;
comment|// Pointer arg case, return Ty*
block|}
block|;
name|template
operator|<
name|class
name|To
block|,
name|class
name|From
operator|>
expr|struct
name|cast_retty_impl
operator|<
name|To
block|,
specifier|const
name|From
operator|*
operator|>
block|{
typedef|typedef
specifier|const
name|To
modifier|*
name|ret_type
typedef|;
comment|// Constant pointer arg case, return const Ty*
block|}
block|;
name|template
operator|<
name|class
name|To
block|,
name|class
name|From
operator|>
expr|struct
name|cast_retty_impl
operator|<
name|To
block|,
specifier|const
name|From
operator|*
specifier|const
operator|>
block|{
typedef|typedef
specifier|const
name|To
modifier|*
name|ret_type
typedef|;
comment|// Constant pointer arg case, return const Ty*
block|}
block|;
name|template
operator|<
name|class
name|To
block|,
name|class
name|From
block|,
name|class
name|SimpleFrom
operator|>
expr|struct
name|cast_retty_wrap
block|{
comment|// When the simplified type and the from type are not the same, use the type
comment|// simplifier to reduce the type, then reuse cast_retty_impl to get the
comment|// resultant type.
typedef|typedef
name|typename
name|cast_retty
operator|<
name|To
operator|,
name|SimpleFrom
operator|>
operator|::
name|ret_type
name|ret_type
expr_stmt|;
block|}
block|;
name|template
operator|<
name|class
name|To
block|,
name|class
name|FromTy
operator|>
expr|struct
name|cast_retty_wrap
operator|<
name|To
block|,
name|FromTy
block|,
name|FromTy
operator|>
block|{
comment|// When the simplified type is equal to the from type, use it directly.
typedef|typedef
name|typename
name|cast_retty_impl
operator|<
name|To
operator|,
name|FromTy
operator|>
operator|::
name|ret_type
name|ret_type
expr_stmt|;
block|}
block|;
name|template
operator|<
name|class
name|To
block|,
name|class
name|From
operator|>
expr|struct
name|cast_retty
block|{
typedef|typedef
name|typename
name|cast_retty_wrap
operator|<
name|To
operator|,
name|From
operator|,
name|typename
name|simplify_type
operator|<
name|From
operator|>
operator|::
name|SimpleType
operator|>
operator|::
name|ret_type
name|ret_type
expr_stmt|;
block|}
block|;
comment|// Ensure the non-simple values are converted using the simplify_type template
comment|// that may be specialized by smart pointers...
comment|//
name|template
operator|<
name|class
name|To
block|,
name|class
name|From
block|,
name|class
name|SimpleFrom
operator|>
expr|struct
name|cast_convert_val
block|{
comment|// This is not a simple type, use the template to simplify it...
specifier|static
name|typename
name|cast_retty
operator|<
name|To
block|,
name|From
operator|>
operator|::
name|ret_type
name|doit
argument_list|(
argument|const From&Val
argument_list|)
block|{
return|return
name|cast_convert_val
operator|<
name|To
operator|,
name|SimpleFrom
operator|,
name|typename
name|simplify_type
operator|<
name|SimpleFrom
operator|>
operator|::
name|SimpleType
operator|>
operator|::
name|doit
argument_list|(
name|simplify_type
operator|<
name|From
operator|>
operator|::
name|getSimplifiedValue
argument_list|(
name|Val
argument_list|)
argument_list|)
return|;
block|}
expr|}
block|;
name|template
operator|<
name|class
name|To
block|,
name|class
name|FromTy
operator|>
expr|struct
name|cast_convert_val
operator|<
name|To
block|,
name|FromTy
block|,
name|FromTy
operator|>
block|{
comment|// This _is_ a simple type, just cast it.
specifier|static
name|typename
name|cast_retty
operator|<
name|To
block|,
name|FromTy
operator|>
operator|::
name|ret_type
name|doit
argument_list|(
argument|const FromTy&Val
argument_list|)
block|{
return|return
name|reinterpret_cast
operator|<
name|typename
name|cast_retty
operator|<
name|To
operator|,
name|FromTy
operator|>
operator|::
name|ret_type
operator|>
operator|(
name|const_cast
operator|<
name|FromTy
operator|&
operator|>
operator|(
name|Val
operator|)
operator|)
return|;
block|}
expr|}
block|;
comment|// cast<X> - Return the argument parameter cast to the specified type.  This
comment|// casting operator asserts that the type is correct, so it does not return null
comment|// on failure.  But it will correctly return NULL when the input is NULL.
comment|// Used Like this:
comment|//
comment|//  cast<Instruction>(myVal)->getParent()
comment|//
name|template
operator|<
name|class
name|X
block|,
name|class
name|Y
operator|>
specifier|inline
name|typename
name|cast_retty
operator|<
name|X
block|,
name|Y
operator|>
operator|::
name|ret_type
name|cast
argument_list|(
argument|const Y&Val
argument_list|)
block|{
name|assert
argument_list|(
name|isa
operator|<
name|X
operator|>
operator|(
name|Val
operator|)
operator|&&
literal|"cast<Ty>() argument of incompatible type!"
argument_list|)
block|;
return|return
name|cast_convert_val
operator|<
name|X
operator|,
name|Y
operator|,
name|typename
name|simplify_type
operator|<
name|Y
operator|>
operator|::
name|SimpleType
operator|>
operator|::
name|doit
argument_list|(
name|Val
argument_list|)
return|;
block|}
comment|// cast_or_null<X> - Functionally identical to cast, except that a null value is
comment|// accepted.
comment|//
name|template
operator|<
name|class
name|X
block|,
name|class
name|Y
operator|>
specifier|inline
name|typename
name|cast_retty
operator|<
name|X
block|,
name|Y
operator|*
operator|>
operator|::
name|ret_type
name|cast_or_null
argument_list|(
argument|Y *Val
argument_list|)
block|{
if|if
condition|(
name|Val
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|assert
argument_list|(
name|isa
operator|<
name|X
operator|>
operator|(
name|Val
operator|)
operator|&&
literal|"cast_or_null<Ty>() argument of incompatible type!"
argument_list|)
block|;
return|return
name|cast
operator|<
name|X
operator|>
operator|(
name|Val
operator|)
return|;
block|}
comment|// dyn_cast<X> - Return the argument parameter cast to the specified type.  This
comment|// casting operator returns null if the argument is of the wrong type, so it can
comment|// be used to test for a type as well as cast if successful.  This should be
comment|// used in the context of an if statement like this:
comment|//
comment|//  if (const Instruction *I = dyn_cast<Instruction>(myVal)) { ... }
comment|//
name|template
operator|<
name|class
name|X
block|,
name|class
name|Y
operator|>
specifier|inline
name|typename
name|cast_retty
operator|<
name|X
block|,
name|Y
operator|>
operator|::
name|ret_type
name|dyn_cast
argument_list|(
argument|const Y&Val
argument_list|)
block|{
return|return
name|isa
operator|<
name|X
operator|>
operator|(
name|Val
operator|)
operator|?
name|cast
operator|<
name|X
operator|,
name|Y
operator|>
operator|(
name|Val
operator|)
operator|:
literal|0
return|;
block|}
comment|// dyn_cast_or_null<X> - Functionally identical to dyn_cast, except that a null
comment|// value is accepted.
comment|//
name|template
operator|<
name|class
name|X
block|,
name|class
name|Y
operator|>
specifier|inline
name|typename
name|cast_retty
operator|<
name|X
block|,
name|Y
operator|>
operator|::
name|ret_type
name|dyn_cast_or_null
argument_list|(
argument|const Y&Val
argument_list|)
block|{
return|return
operator|(
name|Val
operator|&&
name|isa
operator|<
name|X
operator|>
operator|(
name|Val
operator|)
operator|)
condition|?
name|cast
operator|<
name|X
operator|,
name|Y
operator|>
operator|(
name|Val
operator|)
operator|:
literal|0
return|;
block|}
ifdef|#
directive|ifdef
name|DEBUG_CAST_OPERATORS
include|#
directive|include
file|"llvm/Support/raw_ostream.h"
expr|struct
name|bar
block|{
name|bar
argument_list|()
block|{}
name|private
operator|:
name|bar
argument_list|(
specifier|const
name|bar
operator|&
argument_list|)
block|; }
block|; struct
name|foo
block|{
name|void
name|ext
argument_list|()
specifier|const
block|;
comment|/*  static bool classof(const bar *X) {     cerr<< "Classof: "<< X<< "\n";     return true;     }*/
block|}
block|;
name|template
operator|<
operator|>
specifier|inline
name|bool
name|isa_impl
operator|<
name|foo
block|,
name|bar
operator|>
operator|(
specifier|const
name|bar
operator|&
name|Val
operator|)
block|{
name|errs
argument_list|()
operator|<<
literal|"Classof: "
operator|<<
operator|&
name|Val
operator|<<
literal|"\n"
block|;
return|return
name|true
return|;
block|}
name|bar
operator|*
name|fub
argument_list|()
block|;
name|void
name|test
argument_list|(
argument|bar&B1
argument_list|,
argument|const bar *B2
argument_list|)
block|{
comment|// test various configurations of const
specifier|const
name|bar
operator|&
name|B3
operator|=
name|B1
block|;
specifier|const
name|bar
operator|*
specifier|const
name|B4
operator|=
name|B2
block|;
comment|// test isa
if|if
condition|(
operator|!
name|isa
operator|<
name|foo
operator|>
operator|(
name|B1
operator|)
condition|)
return|return;
if|if
condition|(
operator|!
name|isa
operator|<
name|foo
operator|>
operator|(
name|B2
operator|)
condition|)
return|return;
if|if
condition|(
operator|!
name|isa
operator|<
name|foo
operator|>
operator|(
name|B3
operator|)
condition|)
return|return;
if|if
condition|(
operator|!
name|isa
operator|<
name|foo
operator|>
operator|(
name|B4
operator|)
condition|)
return|return;
comment|// test cast
name|foo
operator|&
name|F1
operator|=
name|cast
operator|<
name|foo
operator|>
operator|(
name|B1
operator|)
block|;
specifier|const
name|foo
operator|*
name|F3
operator|=
name|cast
operator|<
name|foo
operator|>
operator|(
name|B2
operator|)
block|;
specifier|const
name|foo
operator|*
name|F4
operator|=
name|cast
operator|<
name|foo
operator|>
operator|(
name|B2
operator|)
block|;
specifier|const
name|foo
operator|&
name|F8
operator|=
name|cast
operator|<
name|foo
operator|>
operator|(
name|B3
operator|)
block|;
specifier|const
name|foo
operator|*
name|F9
operator|=
name|cast
operator|<
name|foo
operator|>
operator|(
name|B4
operator|)
block|;
name|foo
operator|*
name|F10
operator|=
name|cast
operator|<
name|foo
operator|>
operator|(
name|fub
argument_list|()
operator|)
block|;
comment|// test cast_or_null
specifier|const
name|foo
operator|*
name|F11
operator|=
name|cast_or_null
operator|<
name|foo
operator|>
operator|(
name|B2
operator|)
block|;
specifier|const
name|foo
operator|*
name|F12
operator|=
name|cast_or_null
operator|<
name|foo
operator|>
operator|(
name|B2
operator|)
block|;
specifier|const
name|foo
operator|*
name|F13
operator|=
name|cast_or_null
operator|<
name|foo
operator|>
operator|(
name|B4
operator|)
block|;
specifier|const
name|foo
operator|*
name|F14
operator|=
name|cast_or_null
operator|<
name|foo
operator|>
operator|(
name|fub
argument_list|()
operator|)
block|;
comment|// Shouldn't print.
comment|// These lines are errors...
comment|//foo *F20 = cast<foo>(B2);  // Yields const foo*
comment|//foo&F21 = cast<foo>(B3);  // Yields const foo&
comment|//foo *F22 = cast<foo>(B4);  // Yields const foo*
comment|//foo&F23 = cast_or_null<foo>(B1);
comment|//const foo&F24 = cast_or_null<foo>(B3);
block|}
name|bar
operator|*
name|fub
argument_list|()
block|{
return|return
literal|0
return|;
block|}
name|void
expr|main
operator|(
operator|)
block|{
name|bar
name|B
block|;
name|test
argument_list|(
name|B
argument_list|,
operator|&
name|B
argument_list|)
block|; }
endif|#
directive|endif
expr|}
end_decl_stmt

begin_comment
comment|// End llvm namespace
end_comment

begin_endif
endif|#
directive|endif
end_endif

end_unit

