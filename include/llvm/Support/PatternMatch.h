begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===-- llvm/Support/PatternMatch.h - Match on the LLVM IR ------*- C++ -*-===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file provides a simple and efficient mechanism for performing general
end_comment

begin_comment
comment|// tree-based pattern matches on the LLVM IR.  The power of these routines is
end_comment

begin_comment
comment|// that it allows you to write concise patterns that are expressive and easy to
end_comment

begin_comment
comment|// understand.  The other major advantage of this is that it allows you to
end_comment

begin_comment
comment|// trivially capture/bind elements in the pattern to variables.  For example,
end_comment

begin_comment
comment|// you can do something like this:
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//  Value *Exp = ...
end_comment

begin_comment
comment|//  Value *X, *Y;  ConstantInt *C1, *C2;      // (X& C1) | (Y& C2)
end_comment

begin_comment
comment|//  if (match(Exp, m_Or(m_And(m_Value(X), m_ConstantInt(C1)),
end_comment

begin_comment
comment|//                      m_And(m_Value(Y), m_ConstantInt(C2))))) {
end_comment

begin_comment
comment|//    ... Pattern is matched and variables are bound ...
end_comment

begin_comment
comment|//  }
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This is primarily useful to things like the instruction combiner, but can
end_comment

begin_comment
comment|// also be useful for static analysis tools or code generators.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LLVM_SUPPORT_PATTERNMATCH_H
end_ifndef

begin_define
define|#
directive|define
name|LLVM_SUPPORT_PATTERNMATCH_H
end_define

begin_include
include|#
directive|include
file|"llvm/Constants.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Instructions.h"
end_include

begin_decl_stmt
name|namespace
name|llvm
block|{
name|namespace
name|PatternMatch
block|{
name|template
operator|<
name|typename
name|Val
operator|,
name|typename
name|Pattern
operator|>
name|bool
name|match
argument_list|(
argument|Val *V
argument_list|,
argument|const Pattern&P
argument_list|)
block|{
return|return
name|const_cast
operator|<
name|Pattern
operator|&
operator|>
operator|(
name|P
operator|)
operator|.
name|match
argument_list|(
name|V
argument_list|)
return|;
block|}
name|template
operator|<
name|typename
name|Class
operator|>
expr|struct
name|leaf_ty
block|{
name|template
operator|<
name|typename
name|ITy
operator|>
name|bool
name|match
argument_list|(
argument|ITy *V
argument_list|)
block|{
return|return
name|isa
operator|<
name|Class
operator|>
operator|(
name|V
operator|)
return|;
block|}
expr|}
block|;
comment|/// m_Value() - Match an arbitrary value and ignore it.
specifier|inline
name|leaf_ty
operator|<
name|Value
operator|>
name|m_Value
argument_list|()
block|{
return|return
name|leaf_ty
operator|<
name|Value
operator|>
operator|(
operator|)
return|;
block|}
comment|/// m_ConstantInt() - Match an arbitrary ConstantInt and ignore it.
specifier|inline
name|leaf_ty
operator|<
name|ConstantInt
operator|>
name|m_ConstantInt
argument_list|()
block|{
return|return
name|leaf_ty
operator|<
name|ConstantInt
operator|>
operator|(
operator|)
return|;
block|}
name|template
operator|<
name|int64_t
name|Val
operator|>
expr|struct
name|constantint_ty
block|{
name|template
operator|<
name|typename
name|ITy
operator|>
name|bool
name|match
argument_list|(
argument|ITy *V
argument_list|)
block|{
if|if
condition|(
specifier|const
name|ConstantInt
modifier|*
name|CI
init|=
name|dyn_cast
operator|<
name|ConstantInt
operator|>
operator|(
name|V
operator|)
condition|)
block|{
specifier|const
name|APInt
modifier|&
name|CIV
init|=
name|CI
operator|->
name|getValue
argument_list|()
decl_stmt|;
if|if
condition|(
name|Val
operator|>=
literal|0
condition|)
return|return
name|CIV
operator|==
name|static_cast
operator|<
name|uint64_t
operator|>
operator|(
name|Val
operator|)
return|;
comment|// If Val is negative, and CI is shorter than it, truncate to the right
comment|// number of bits.  If it is larger, then we have to sign extend.  Just
comment|// compare their negated values.
return|return
operator|-
name|CIV
operator|==
operator|-
name|Val
return|;
block|}
return|return
name|false
return|;
block|}
expr|}
block|;
comment|/// m_ConstantInt(int64_t) - Match a ConstantInt with a specific value
comment|/// and ignore it.
name|template
operator|<
name|int64_t
name|Val
operator|>
specifier|inline
name|constantint_ty
operator|<
name|Val
operator|>
name|m_ConstantInt
argument_list|()
block|{
return|return
name|constantint_ty
operator|<
name|Val
operator|>
operator|(
operator|)
return|;
block|}
expr|struct
name|zero_ty
block|{
name|template
operator|<
name|typename
name|ITy
operator|>
name|bool
name|match
argument_list|(
argument|ITy *V
argument_list|)
block|{
if|if
condition|(
specifier|const
name|Constant
modifier|*
name|C
init|=
name|dyn_cast
operator|<
name|Constant
operator|>
operator|(
name|V
operator|)
condition|)
return|return
name|C
operator|->
name|isNullValue
argument_list|()
return|;
return|return
name|false
return|;
block|}
expr|}
block|;
comment|/// m_Zero() - Match an arbitrary zero/null constant.
specifier|inline
name|zero_ty
name|m_Zero
argument_list|()
block|{
return|return
name|zero_ty
argument_list|()
return|;
block|}
expr|struct
name|one_ty
block|{
name|template
operator|<
name|typename
name|ITy
operator|>
name|bool
name|match
argument_list|(
argument|ITy *V
argument_list|)
block|{
if|if
condition|(
specifier|const
name|ConstantInt
modifier|*
name|C
init|=
name|dyn_cast
operator|<
name|ConstantInt
operator|>
operator|(
name|V
operator|)
condition|)
return|return
name|C
operator|->
name|isOne
argument_list|()
return|;
return|return
name|false
return|;
block|}
expr|}
block|;
comment|/// m_One() - Match a an integer 1.
specifier|inline
name|one_ty
name|m_One
argument_list|()
block|{
return|return
name|one_ty
argument_list|()
return|;
block|}
name|template
operator|<
name|typename
name|Class
operator|>
expr|struct
name|bind_ty
block|{
name|Class
operator|*
operator|&
name|VR
block|;
name|bind_ty
argument_list|(
name|Class
operator|*
operator|&
name|V
argument_list|)
operator|:
name|VR
argument_list|(
argument|V
argument_list|)
block|{}
name|template
operator|<
name|typename
name|ITy
operator|>
name|bool
name|match
argument_list|(
argument|ITy *V
argument_list|)
block|{
if|if
condition|(
name|Class
modifier|*
name|CV
init|=
name|dyn_cast
operator|<
name|Class
operator|>
operator|(
name|V
operator|)
condition|)
block|{
name|VR
operator|=
name|CV
expr_stmt|;
return|return
name|true
return|;
block|}
return|return
name|false
return|;
block|}
expr|}
block|;
comment|/// m_Value - Match a value, capturing it if we match.
specifier|inline
name|bind_ty
operator|<
name|Value
operator|>
name|m_Value
argument_list|(
argument|Value *&V
argument_list|)
block|{
return|return
name|V
return|;
block|}
comment|/// m_ConstantInt - Match a ConstantInt, capturing the value if we match.
specifier|inline
name|bind_ty
operator|<
name|ConstantInt
operator|>
name|m_ConstantInt
argument_list|(
argument|ConstantInt *&CI
argument_list|)
block|{
return|return
name|CI
return|;
block|}
comment|/// specificval_ty - Match a specified Value*.
expr|struct
name|specificval_ty
block|{
specifier|const
name|Value
operator|*
name|Val
block|;
name|specificval_ty
argument_list|(
specifier|const
name|Value
operator|*
name|V
argument_list|)
operator|:
name|Val
argument_list|(
argument|V
argument_list|)
block|{}
name|template
operator|<
name|typename
name|ITy
operator|>
name|bool
name|match
argument_list|(
argument|ITy *V
argument_list|)
block|{
return|return
name|V
operator|==
name|Val
return|;
block|}
expr|}
block|;
comment|/// m_Specific - Match if we have a specific specified value.
specifier|inline
name|specificval_ty
name|m_Specific
argument_list|(
argument|const Value *V
argument_list|)
block|{
return|return
name|V
return|;
block|}
comment|//===----------------------------------------------------------------------===//
comment|// Matchers for specific binary operators.
comment|//
name|template
operator|<
name|typename
name|LHS_t
block|,
name|typename
name|RHS_t
block|,
name|unsigned
name|Opcode
block|,
name|typename
name|ConcreteTy
operator|=
name|BinaryOperator
operator|>
expr|struct
name|BinaryOp_match
block|{
name|LHS_t
name|L
block|;
name|RHS_t
name|R
block|;
name|BinaryOp_match
argument_list|(
specifier|const
name|LHS_t
operator|&
name|LHS
argument_list|,
specifier|const
name|RHS_t
operator|&
name|RHS
argument_list|)
operator|:
name|L
argument_list|(
name|LHS
argument_list|)
block|,
name|R
argument_list|(
argument|RHS
argument_list|)
block|{}
name|template
operator|<
name|typename
name|OpTy
operator|>
name|bool
name|match
argument_list|(
argument|OpTy *V
argument_list|)
block|{
if|if
condition|(
name|V
operator|->
name|getValueID
argument_list|()
operator|==
name|Value
operator|::
name|InstructionVal
operator|+
name|Opcode
condition|)
block|{
name|ConcreteTy
modifier|*
name|I
init|=
name|cast
operator|<
name|ConcreteTy
operator|>
operator|(
name|V
operator|)
decl_stmt|;
return|return
name|I
operator|->
name|getOpcode
argument_list|()
operator|==
name|Opcode
operator|&&
name|L
operator|.
name|match
argument_list|(
name|I
operator|->
name|getOperand
argument_list|(
literal|0
argument_list|)
argument_list|)
operator|&&
name|R
operator|.
name|match
argument_list|(
name|I
operator|->
name|getOperand
argument_list|(
literal|1
argument_list|)
argument_list|)
return|;
block|}
if|if
condition|(
name|ConstantExpr
modifier|*
name|CE
init|=
name|dyn_cast
operator|<
name|ConstantExpr
operator|>
operator|(
name|V
operator|)
condition|)
return|return
name|CE
operator|->
name|getOpcode
argument_list|()
operator|==
name|Opcode
operator|&&
name|L
operator|.
name|match
argument_list|(
name|CE
operator|->
name|getOperand
argument_list|(
literal|0
argument_list|)
argument_list|)
operator|&&
name|R
operator|.
name|match
argument_list|(
name|CE
operator|->
name|getOperand
argument_list|(
literal|1
argument_list|)
argument_list|)
return|;
return|return
name|false
return|;
block|}
expr|}
block|;
name|template
operator|<
name|typename
name|LHS
block|,
name|typename
name|RHS
operator|>
specifier|inline
name|BinaryOp_match
operator|<
name|LHS
block|,
name|RHS
block|,
name|Instruction
operator|::
name|Add
operator|>
name|m_Add
argument_list|(
argument|const LHS&L
argument_list|,
argument|const RHS&R
argument_list|)
block|{
return|return
name|BinaryOp_match
operator|<
name|LHS
operator|,
name|RHS
operator|,
name|Instruction
operator|::
name|Add
operator|>
operator|(
name|L
operator|,
name|R
operator|)
return|;
block|}
name|template
operator|<
name|typename
name|LHS
block|,
name|typename
name|RHS
operator|>
specifier|inline
name|BinaryOp_match
operator|<
name|LHS
block|,
name|RHS
block|,
name|Instruction
operator|::
name|FAdd
operator|>
name|m_FAdd
argument_list|(
argument|const LHS&L
argument_list|,
argument|const RHS&R
argument_list|)
block|{
return|return
name|BinaryOp_match
operator|<
name|LHS
operator|,
name|RHS
operator|,
name|Instruction
operator|::
name|FAdd
operator|>
operator|(
name|L
operator|,
name|R
operator|)
return|;
block|}
name|template
operator|<
name|typename
name|LHS
block|,
name|typename
name|RHS
operator|>
specifier|inline
name|BinaryOp_match
operator|<
name|LHS
block|,
name|RHS
block|,
name|Instruction
operator|::
name|Sub
operator|>
name|m_Sub
argument_list|(
argument|const LHS&L
argument_list|,
argument|const RHS&R
argument_list|)
block|{
return|return
name|BinaryOp_match
operator|<
name|LHS
operator|,
name|RHS
operator|,
name|Instruction
operator|::
name|Sub
operator|>
operator|(
name|L
operator|,
name|R
operator|)
return|;
block|}
name|template
operator|<
name|typename
name|LHS
block|,
name|typename
name|RHS
operator|>
specifier|inline
name|BinaryOp_match
operator|<
name|LHS
block|,
name|RHS
block|,
name|Instruction
operator|::
name|FSub
operator|>
name|m_FSub
argument_list|(
argument|const LHS&L
argument_list|,
argument|const RHS&R
argument_list|)
block|{
return|return
name|BinaryOp_match
operator|<
name|LHS
operator|,
name|RHS
operator|,
name|Instruction
operator|::
name|FSub
operator|>
operator|(
name|L
operator|,
name|R
operator|)
return|;
block|}
name|template
operator|<
name|typename
name|LHS
block|,
name|typename
name|RHS
operator|>
specifier|inline
name|BinaryOp_match
operator|<
name|LHS
block|,
name|RHS
block|,
name|Instruction
operator|::
name|Mul
operator|>
name|m_Mul
argument_list|(
argument|const LHS&L
argument_list|,
argument|const RHS&R
argument_list|)
block|{
return|return
name|BinaryOp_match
operator|<
name|LHS
operator|,
name|RHS
operator|,
name|Instruction
operator|::
name|Mul
operator|>
operator|(
name|L
operator|,
name|R
operator|)
return|;
block|}
name|template
operator|<
name|typename
name|LHS
block|,
name|typename
name|RHS
operator|>
specifier|inline
name|BinaryOp_match
operator|<
name|LHS
block|,
name|RHS
block|,
name|Instruction
operator|::
name|FMul
operator|>
name|m_FMul
argument_list|(
argument|const LHS&L
argument_list|,
argument|const RHS&R
argument_list|)
block|{
return|return
name|BinaryOp_match
operator|<
name|LHS
operator|,
name|RHS
operator|,
name|Instruction
operator|::
name|FMul
operator|>
operator|(
name|L
operator|,
name|R
operator|)
return|;
block|}
name|template
operator|<
name|typename
name|LHS
block|,
name|typename
name|RHS
operator|>
specifier|inline
name|BinaryOp_match
operator|<
name|LHS
block|,
name|RHS
block|,
name|Instruction
operator|::
name|UDiv
operator|>
name|m_UDiv
argument_list|(
argument|const LHS&L
argument_list|,
argument|const RHS&R
argument_list|)
block|{
return|return
name|BinaryOp_match
operator|<
name|LHS
operator|,
name|RHS
operator|,
name|Instruction
operator|::
name|UDiv
operator|>
operator|(
name|L
operator|,
name|R
operator|)
return|;
block|}
name|template
operator|<
name|typename
name|LHS
block|,
name|typename
name|RHS
operator|>
specifier|inline
name|BinaryOp_match
operator|<
name|LHS
block|,
name|RHS
block|,
name|Instruction
operator|::
name|SDiv
operator|>
name|m_SDiv
argument_list|(
argument|const LHS&L
argument_list|,
argument|const RHS&R
argument_list|)
block|{
return|return
name|BinaryOp_match
operator|<
name|LHS
operator|,
name|RHS
operator|,
name|Instruction
operator|::
name|SDiv
operator|>
operator|(
name|L
operator|,
name|R
operator|)
return|;
block|}
name|template
operator|<
name|typename
name|LHS
block|,
name|typename
name|RHS
operator|>
specifier|inline
name|BinaryOp_match
operator|<
name|LHS
block|,
name|RHS
block|,
name|Instruction
operator|::
name|FDiv
operator|>
name|m_FDiv
argument_list|(
argument|const LHS&L
argument_list|,
argument|const RHS&R
argument_list|)
block|{
return|return
name|BinaryOp_match
operator|<
name|LHS
operator|,
name|RHS
operator|,
name|Instruction
operator|::
name|FDiv
operator|>
operator|(
name|L
operator|,
name|R
operator|)
return|;
block|}
name|template
operator|<
name|typename
name|LHS
block|,
name|typename
name|RHS
operator|>
specifier|inline
name|BinaryOp_match
operator|<
name|LHS
block|,
name|RHS
block|,
name|Instruction
operator|::
name|URem
operator|>
name|m_URem
argument_list|(
argument|const LHS&L
argument_list|,
argument|const RHS&R
argument_list|)
block|{
return|return
name|BinaryOp_match
operator|<
name|LHS
operator|,
name|RHS
operator|,
name|Instruction
operator|::
name|URem
operator|>
operator|(
name|L
operator|,
name|R
operator|)
return|;
block|}
name|template
operator|<
name|typename
name|LHS
block|,
name|typename
name|RHS
operator|>
specifier|inline
name|BinaryOp_match
operator|<
name|LHS
block|,
name|RHS
block|,
name|Instruction
operator|::
name|SRem
operator|>
name|m_SRem
argument_list|(
argument|const LHS&L
argument_list|,
argument|const RHS&R
argument_list|)
block|{
return|return
name|BinaryOp_match
operator|<
name|LHS
operator|,
name|RHS
operator|,
name|Instruction
operator|::
name|SRem
operator|>
operator|(
name|L
operator|,
name|R
operator|)
return|;
block|}
name|template
operator|<
name|typename
name|LHS
block|,
name|typename
name|RHS
operator|>
specifier|inline
name|BinaryOp_match
operator|<
name|LHS
block|,
name|RHS
block|,
name|Instruction
operator|::
name|FRem
operator|>
name|m_FRem
argument_list|(
argument|const LHS&L
argument_list|,
argument|const RHS&R
argument_list|)
block|{
return|return
name|BinaryOp_match
operator|<
name|LHS
operator|,
name|RHS
operator|,
name|Instruction
operator|::
name|FRem
operator|>
operator|(
name|L
operator|,
name|R
operator|)
return|;
block|}
name|template
operator|<
name|typename
name|LHS
block|,
name|typename
name|RHS
operator|>
specifier|inline
name|BinaryOp_match
operator|<
name|LHS
block|,
name|RHS
block|,
name|Instruction
operator|::
name|And
operator|>
name|m_And
argument_list|(
argument|const LHS&L
argument_list|,
argument|const RHS&R
argument_list|)
block|{
return|return
name|BinaryOp_match
operator|<
name|LHS
operator|,
name|RHS
operator|,
name|Instruction
operator|::
name|And
operator|>
operator|(
name|L
operator|,
name|R
operator|)
return|;
block|}
name|template
operator|<
name|typename
name|LHS
block|,
name|typename
name|RHS
operator|>
specifier|inline
name|BinaryOp_match
operator|<
name|LHS
block|,
name|RHS
block|,
name|Instruction
operator|::
name|Or
operator|>
name|m_Or
argument_list|(
argument|const LHS&L
argument_list|,
argument|const RHS&R
argument_list|)
block|{
return|return
name|BinaryOp_match
operator|<
name|LHS
operator|,
name|RHS
operator|,
name|Instruction
operator|::
name|Or
operator|>
operator|(
name|L
operator|,
name|R
operator|)
return|;
block|}
name|template
operator|<
name|typename
name|LHS
block|,
name|typename
name|RHS
operator|>
specifier|inline
name|BinaryOp_match
operator|<
name|LHS
block|,
name|RHS
block|,
name|Instruction
operator|::
name|Xor
operator|>
name|m_Xor
argument_list|(
argument|const LHS&L
argument_list|,
argument|const RHS&R
argument_list|)
block|{
return|return
name|BinaryOp_match
operator|<
name|LHS
operator|,
name|RHS
operator|,
name|Instruction
operator|::
name|Xor
operator|>
operator|(
name|L
operator|,
name|R
operator|)
return|;
block|}
name|template
operator|<
name|typename
name|LHS
block|,
name|typename
name|RHS
operator|>
specifier|inline
name|BinaryOp_match
operator|<
name|LHS
block|,
name|RHS
block|,
name|Instruction
operator|::
name|Shl
operator|>
name|m_Shl
argument_list|(
argument|const LHS&L
argument_list|,
argument|const RHS&R
argument_list|)
block|{
return|return
name|BinaryOp_match
operator|<
name|LHS
operator|,
name|RHS
operator|,
name|Instruction
operator|::
name|Shl
operator|>
operator|(
name|L
operator|,
name|R
operator|)
return|;
block|}
name|template
operator|<
name|typename
name|LHS
block|,
name|typename
name|RHS
operator|>
specifier|inline
name|BinaryOp_match
operator|<
name|LHS
block|,
name|RHS
block|,
name|Instruction
operator|::
name|LShr
operator|>
name|m_LShr
argument_list|(
argument|const LHS&L
argument_list|,
argument|const RHS&R
argument_list|)
block|{
return|return
name|BinaryOp_match
operator|<
name|LHS
operator|,
name|RHS
operator|,
name|Instruction
operator|::
name|LShr
operator|>
operator|(
name|L
operator|,
name|R
operator|)
return|;
block|}
name|template
operator|<
name|typename
name|LHS
block|,
name|typename
name|RHS
operator|>
specifier|inline
name|BinaryOp_match
operator|<
name|LHS
block|,
name|RHS
block|,
name|Instruction
operator|::
name|AShr
operator|>
name|m_AShr
argument_list|(
argument|const LHS&L
argument_list|,
argument|const RHS&R
argument_list|)
block|{
return|return
name|BinaryOp_match
operator|<
name|LHS
operator|,
name|RHS
operator|,
name|Instruction
operator|::
name|AShr
operator|>
operator|(
name|L
operator|,
name|R
operator|)
return|;
block|}
comment|//===----------------------------------------------------------------------===//
comment|// Matchers for either AShr or LShr .. for convenience
comment|//
name|template
operator|<
name|typename
name|LHS_t
block|,
name|typename
name|RHS_t
block|,
name|typename
name|ConcreteTy
operator|=
name|BinaryOperator
operator|>
expr|struct
name|Shr_match
block|{
name|LHS_t
name|L
block|;
name|RHS_t
name|R
block|;
name|Shr_match
argument_list|(
specifier|const
name|LHS_t
operator|&
name|LHS
argument_list|,
specifier|const
name|RHS_t
operator|&
name|RHS
argument_list|)
operator|:
name|L
argument_list|(
name|LHS
argument_list|)
block|,
name|R
argument_list|(
argument|RHS
argument_list|)
block|{}
name|template
operator|<
name|typename
name|OpTy
operator|>
name|bool
name|match
argument_list|(
argument|OpTy *V
argument_list|)
block|{
if|if
condition|(
name|V
operator|->
name|getValueID
argument_list|()
operator|==
name|Value
operator|::
name|InstructionVal
operator|+
name|Instruction
operator|::
name|LShr
operator|||
name|V
operator|->
name|getValueID
argument_list|()
operator|==
name|Value
operator|::
name|InstructionVal
operator|+
name|Instruction
operator|::
name|AShr
condition|)
block|{
name|ConcreteTy
modifier|*
name|I
init|=
name|cast
operator|<
name|ConcreteTy
operator|>
operator|(
name|V
operator|)
decl_stmt|;
return|return
operator|(
name|I
operator|->
name|getOpcode
argument_list|()
operator|==
name|Instruction
operator|::
name|AShr
operator|||
name|I
operator|->
name|getOpcode
argument_list|()
operator|==
name|Instruction
operator|::
name|LShr
operator|)
operator|&&
name|L
operator|.
name|match
argument_list|(
name|I
operator|->
name|getOperand
argument_list|(
literal|0
argument_list|)
argument_list|)
operator|&&
name|R
operator|.
name|match
argument_list|(
name|I
operator|->
name|getOperand
argument_list|(
literal|1
argument_list|)
argument_list|)
return|;
block|}
if|if
condition|(
name|ConstantExpr
modifier|*
name|CE
init|=
name|dyn_cast
operator|<
name|ConstantExpr
operator|>
operator|(
name|V
operator|)
condition|)
return|return
operator|(
name|CE
operator|->
name|getOpcode
argument_list|()
operator|==
name|Instruction
operator|::
name|LShr
operator|||
name|CE
operator|->
name|getOpcode
argument_list|()
operator|==
name|Instruction
operator|::
name|AShr
operator|)
operator|&&
name|L
operator|.
name|match
argument_list|(
name|CE
operator|->
name|getOperand
argument_list|(
literal|0
argument_list|)
argument_list|)
operator|&&
name|R
operator|.
name|match
argument_list|(
name|CE
operator|->
name|getOperand
argument_list|(
literal|1
argument_list|)
argument_list|)
return|;
return|return
name|false
return|;
block|}
expr|}
block|;
name|template
operator|<
name|typename
name|LHS
block|,
name|typename
name|RHS
operator|>
specifier|inline
name|Shr_match
operator|<
name|LHS
block|,
name|RHS
operator|>
name|m_Shr
argument_list|(
argument|const LHS&L
argument_list|,
argument|const RHS&R
argument_list|)
block|{
return|return
name|Shr_match
operator|<
name|LHS
operator|,
name|RHS
operator|>
operator|(
name|L
operator|,
name|R
operator|)
return|;
block|}
comment|//===----------------------------------------------------------------------===//
comment|// Matchers for binary classes
comment|//
name|template
operator|<
name|typename
name|LHS_t
block|,
name|typename
name|RHS_t
block|,
name|typename
name|Class
block|,
name|typename
name|OpcType
operator|>
expr|struct
name|BinaryOpClass_match
block|{
name|OpcType
operator|*
name|Opcode
block|;
name|LHS_t
name|L
block|;
name|RHS_t
name|R
block|;
name|BinaryOpClass_match
argument_list|(
name|OpcType
operator|&
name|Op
argument_list|,
specifier|const
name|LHS_t
operator|&
name|LHS
argument_list|,
specifier|const
name|RHS_t
operator|&
name|RHS
argument_list|)
operator|:
name|Opcode
argument_list|(
operator|&
name|Op
argument_list|)
block|,
name|L
argument_list|(
name|LHS
argument_list|)
block|,
name|R
argument_list|(
argument|RHS
argument_list|)
block|{}
name|BinaryOpClass_match
argument_list|(
specifier|const
name|LHS_t
operator|&
name|LHS
argument_list|,
specifier|const
name|RHS_t
operator|&
name|RHS
argument_list|)
operator|:
name|Opcode
argument_list|(
literal|0
argument_list|)
block|,
name|L
argument_list|(
name|LHS
argument_list|)
block|,
name|R
argument_list|(
argument|RHS
argument_list|)
block|{}
name|template
operator|<
name|typename
name|OpTy
operator|>
name|bool
name|match
argument_list|(
argument|OpTy *V
argument_list|)
block|{
if|if
condition|(
name|Class
modifier|*
name|I
init|=
name|dyn_cast
operator|<
name|Class
operator|>
operator|(
name|V
operator|)
condition|)
if|if
condition|(
name|L
operator|.
name|match
argument_list|(
name|I
operator|->
name|getOperand
argument_list|(
literal|0
argument_list|)
argument_list|)
operator|&&
name|R
operator|.
name|match
argument_list|(
name|I
operator|->
name|getOperand
argument_list|(
literal|1
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|Opcode
condition|)
operator|*
name|Opcode
operator|=
name|I
operator|->
name|getOpcode
argument_list|()
expr_stmt|;
return|return
name|true
return|;
block|}
if|#
directive|if
literal|0
comment|// Doesn't handle constantexprs yet!
then|if (ConstantExpr *CE = dyn_cast<ConstantExpr>(V))       return CE->getOpcode() == Opcode&& L.match(CE->getOperand(0))&&              R.match(CE->getOperand(1));
endif|#
directive|endif
return|return
name|false
return|;
block|}
expr|}
block|;
name|template
operator|<
name|typename
name|LHS
block|,
name|typename
name|RHS
operator|>
specifier|inline
name|BinaryOpClass_match
operator|<
name|LHS
block|,
name|RHS
block|,
name|BinaryOperator
block|,
name|Instruction
operator|::
name|BinaryOps
operator|>
name|m_Shift
argument_list|(
argument|Instruction::BinaryOps&Op
argument_list|,
argument|const LHS&L
argument_list|,
argument|const RHS&R
argument_list|)
block|{
return|return
name|BinaryOpClass_match
operator|<
name|LHS
operator|,
name|RHS
operator|,
name|BinaryOperator
operator|,
name|Instruction
operator|::
name|BinaryOps
operator|>
operator|(
name|Op
operator|,
name|L
operator|,
name|R
operator|)
return|;
block|}
name|template
operator|<
name|typename
name|LHS
block|,
name|typename
name|RHS
operator|>
specifier|inline
name|BinaryOpClass_match
operator|<
name|LHS
block|,
name|RHS
block|,
name|BinaryOperator
block|,
name|Instruction
operator|::
name|BinaryOps
operator|>
name|m_Shift
argument_list|(
argument|const LHS&L
argument_list|,
argument|const RHS&R
argument_list|)
block|{
return|return
name|BinaryOpClass_match
operator|<
name|LHS
operator|,
name|RHS
operator|,
name|BinaryOperator
operator|,
name|Instruction
operator|::
name|BinaryOps
operator|>
operator|(
name|L
operator|,
name|R
operator|)
return|;
block|}
comment|//===----------------------------------------------------------------------===//
comment|// Matchers for CmpInst classes
comment|//
name|template
operator|<
name|typename
name|LHS_t
block|,
name|typename
name|RHS_t
block|,
name|typename
name|Class
block|,
name|typename
name|PredicateTy
operator|>
expr|struct
name|CmpClass_match
block|{
name|PredicateTy
operator|&
name|Predicate
block|;
name|LHS_t
name|L
block|;
name|RHS_t
name|R
block|;
name|CmpClass_match
argument_list|(
name|PredicateTy
operator|&
name|Pred
argument_list|,
specifier|const
name|LHS_t
operator|&
name|LHS
argument_list|,
specifier|const
name|RHS_t
operator|&
name|RHS
argument_list|)
operator|:
name|Predicate
argument_list|(
name|Pred
argument_list|)
block|,
name|L
argument_list|(
name|LHS
argument_list|)
block|,
name|R
argument_list|(
argument|RHS
argument_list|)
block|{}
name|template
operator|<
name|typename
name|OpTy
operator|>
name|bool
name|match
argument_list|(
argument|OpTy *V
argument_list|)
block|{
if|if
condition|(
name|Class
modifier|*
name|I
init|=
name|dyn_cast
operator|<
name|Class
operator|>
operator|(
name|V
operator|)
condition|)
if|if
condition|(
name|L
operator|.
name|match
argument_list|(
name|I
operator|->
name|getOperand
argument_list|(
literal|0
argument_list|)
argument_list|)
operator|&&
name|R
operator|.
name|match
argument_list|(
name|I
operator|->
name|getOperand
argument_list|(
literal|1
argument_list|)
argument_list|)
condition|)
block|{
name|Predicate
operator|=
name|I
operator|->
name|getPredicate
argument_list|()
expr_stmt|;
return|return
name|true
return|;
block|}
return|return
name|false
return|;
block|}
expr|}
block|;
name|template
operator|<
name|typename
name|LHS
block|,
name|typename
name|RHS
operator|>
specifier|inline
name|CmpClass_match
operator|<
name|LHS
block|,
name|RHS
block|,
name|ICmpInst
block|,
name|ICmpInst
operator|::
name|Predicate
operator|>
name|m_ICmp
argument_list|(
argument|ICmpInst::Predicate&Pred
argument_list|,
argument|const LHS&L
argument_list|,
argument|const RHS&R
argument_list|)
block|{
return|return
name|CmpClass_match
operator|<
name|LHS
operator|,
name|RHS
operator|,
name|ICmpInst
operator|,
name|ICmpInst
operator|::
name|Predicate
operator|>
operator|(
name|Pred
operator|,
name|L
operator|,
name|R
operator|)
return|;
block|}
name|template
operator|<
name|typename
name|LHS
block|,
name|typename
name|RHS
operator|>
specifier|inline
name|CmpClass_match
operator|<
name|LHS
block|,
name|RHS
block|,
name|FCmpInst
block|,
name|FCmpInst
operator|::
name|Predicate
operator|>
name|m_FCmp
argument_list|(
argument|FCmpInst::Predicate&Pred
argument_list|,
argument|const LHS&L
argument_list|,
argument|const RHS&R
argument_list|)
block|{
return|return
name|CmpClass_match
operator|<
name|LHS
operator|,
name|RHS
operator|,
name|FCmpInst
operator|,
name|FCmpInst
operator|::
name|Predicate
operator|>
operator|(
name|Pred
operator|,
name|L
operator|,
name|R
operator|)
return|;
block|}
comment|//===----------------------------------------------------------------------===//
comment|// Matchers for SelectInst classes
comment|//
name|template
operator|<
name|typename
name|Cond_t
block|,
name|typename
name|LHS_t
block|,
name|typename
name|RHS_t
operator|>
expr|struct
name|SelectClass_match
block|{
name|Cond_t
name|C
block|;
name|LHS_t
name|L
block|;
name|RHS_t
name|R
block|;
name|SelectClass_match
argument_list|(
specifier|const
name|Cond_t
operator|&
name|Cond
argument_list|,
specifier|const
name|LHS_t
operator|&
name|LHS
argument_list|,
specifier|const
name|RHS_t
operator|&
name|RHS
argument_list|)
operator|:
name|C
argument_list|(
name|Cond
argument_list|)
block|,
name|L
argument_list|(
name|LHS
argument_list|)
block|,
name|R
argument_list|(
argument|RHS
argument_list|)
block|{}
name|template
operator|<
name|typename
name|OpTy
operator|>
name|bool
name|match
argument_list|(
argument|OpTy *V
argument_list|)
block|{
if|if
condition|(
name|SelectInst
modifier|*
name|I
init|=
name|dyn_cast
operator|<
name|SelectInst
operator|>
operator|(
name|V
operator|)
condition|)
return|return
name|C
operator|.
name|match
argument_list|(
name|I
operator|->
name|getOperand
argument_list|(
literal|0
argument_list|)
argument_list|)
operator|&&
name|L
operator|.
name|match
argument_list|(
name|I
operator|->
name|getOperand
argument_list|(
literal|1
argument_list|)
argument_list|)
operator|&&
name|R
operator|.
name|match
argument_list|(
name|I
operator|->
name|getOperand
argument_list|(
literal|2
argument_list|)
argument_list|)
return|;
return|return
name|false
return|;
block|}
expr|}
block|;
name|template
operator|<
name|typename
name|Cond
block|,
name|typename
name|LHS
block|,
name|typename
name|RHS
operator|>
specifier|inline
name|SelectClass_match
operator|<
name|Cond
block|,
name|LHS
block|,
name|RHS
operator|>
name|m_Select
argument_list|(
argument|const Cond&C
argument_list|,
argument|const LHS&L
argument_list|,
argument|const RHS&R
argument_list|)
block|{
return|return
name|SelectClass_match
operator|<
name|Cond
operator|,
name|LHS
operator|,
name|RHS
operator|>
operator|(
name|C
operator|,
name|L
operator|,
name|R
operator|)
return|;
block|}
comment|/// m_SelectCst - This matches a select of two constants, e.g.:
comment|///    m_SelectCst(m_Value(V), -1, 0)
name|template
operator|<
name|int64_t
name|L
block|,
name|int64_t
name|R
block|,
name|typename
name|Cond
operator|>
specifier|inline
name|SelectClass_match
operator|<
name|Cond
block|,
name|constantint_ty
operator|<
name|L
operator|>
block|,
name|constantint_ty
operator|<
name|R
operator|>
expr|>
name|m_SelectCst
argument_list|(
argument|const Cond&C
argument_list|)
block|{
return|return
name|SelectClass_match
operator|<
name|Cond
operator|,
name|constantint_ty
operator|<
name|L
operator|>
operator|,
name|constantint_ty
operator|<
name|R
operator|>
expr|>
operator|(
name|C
operator|,
name|m_ConstantInt
operator|<
name|L
operator|>
operator|(
operator|)
operator|,
name|m_ConstantInt
operator|<
name|R
operator|>
operator|(
operator|)
operator|)
return|;
block|}
comment|//===----------------------------------------------------------------------===//
comment|// Matchers for CastInst classes
comment|//
name|template
operator|<
name|typename
name|Op_t
block|,
name|typename
name|Class
operator|>
expr|struct
name|CastClass_match
block|{
name|Op_t
name|Op
block|;
name|CastClass_match
argument_list|(
specifier|const
name|Op_t
operator|&
name|OpMatch
argument_list|)
operator|:
name|Op
argument_list|(
argument|OpMatch
argument_list|)
block|{}
name|template
operator|<
name|typename
name|OpTy
operator|>
name|bool
name|match
argument_list|(
argument|OpTy *V
argument_list|)
block|{
if|if
condition|(
name|Class
modifier|*
name|I
init|=
name|dyn_cast
operator|<
name|Class
operator|>
operator|(
name|V
operator|)
condition|)
return|return
name|Op
operator|.
name|match
argument_list|(
name|I
operator|->
name|getOperand
argument_list|(
literal|0
argument_list|)
argument_list|)
return|;
return|return
name|false
return|;
block|}
expr|}
block|;
name|template
operator|<
name|typename
name|Class
block|,
name|typename
name|OpTy
operator|>
specifier|inline
name|CastClass_match
operator|<
name|OpTy
block|,
name|Class
operator|>
name|m_Cast
argument_list|(
argument|const OpTy&Op
argument_list|)
block|{
return|return
name|CastClass_match
operator|<
name|OpTy
operator|,
name|Class
operator|>
operator|(
name|Op
operator|)
return|;
block|}
comment|//===----------------------------------------------------------------------===//
comment|// Matchers for unary operators
comment|//
name|template
operator|<
name|typename
name|LHS_t
operator|>
expr|struct
name|not_match
block|{
name|LHS_t
name|L
block|;
name|not_match
argument_list|(
specifier|const
name|LHS_t
operator|&
name|LHS
argument_list|)
operator|:
name|L
argument_list|(
argument|LHS
argument_list|)
block|{}
name|template
operator|<
name|typename
name|OpTy
operator|>
name|bool
name|match
argument_list|(
argument|OpTy *V
argument_list|)
block|{
if|if
condition|(
name|Instruction
modifier|*
name|I
init|=
name|dyn_cast
operator|<
name|Instruction
operator|>
operator|(
name|V
operator|)
condition|)
if|if
condition|(
name|I
operator|->
name|getOpcode
argument_list|()
operator|==
name|Instruction
operator|::
name|Xor
condition|)
return|return
name|matchIfNot
argument_list|(
name|I
operator|->
name|getOperand
argument_list|(
literal|0
argument_list|)
argument_list|,
name|I
operator|->
name|getOperand
argument_list|(
literal|1
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|ConstantExpr
modifier|*
name|CE
init|=
name|dyn_cast
operator|<
name|ConstantExpr
operator|>
operator|(
name|V
operator|)
condition|)
if|if
condition|(
name|CE
operator|->
name|getOpcode
argument_list|()
operator|==
name|Instruction
operator|::
name|Xor
condition|)
return|return
name|matchIfNot
argument_list|(
name|CE
operator|->
name|getOperand
argument_list|(
literal|0
argument_list|)
argument_list|,
name|CE
operator|->
name|getOperand
argument_list|(
literal|1
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|ConstantInt
modifier|*
name|CI
init|=
name|dyn_cast
operator|<
name|ConstantInt
operator|>
operator|(
name|V
operator|)
condition|)
return|return
name|L
operator|.
name|match
argument_list|(
name|ConstantExpr
operator|::
name|getNot
argument_list|(
name|CI
argument_list|)
argument_list|)
return|;
return|return
name|false
return|;
block|}
name|private
operator|:
name|bool
name|matchIfNot
argument_list|(
argument|Value *LHS
argument_list|,
argument|Value *RHS
argument_list|)
block|{
if|if
condition|(
name|ConstantInt
modifier|*
name|CI
init|=
name|dyn_cast
operator|<
name|ConstantInt
operator|>
operator|(
name|RHS
operator|)
condition|)
return|return
name|CI
operator|->
name|isAllOnesValue
argument_list|()
operator|&&
name|L
operator|.
name|match
argument_list|(
name|LHS
argument_list|)
return|;
if|if
condition|(
name|ConstantInt
modifier|*
name|CI
init|=
name|dyn_cast
operator|<
name|ConstantInt
operator|>
operator|(
name|LHS
operator|)
condition|)
return|return
name|CI
operator|->
name|isAllOnesValue
argument_list|()
operator|&&
name|L
operator|.
name|match
argument_list|(
name|RHS
argument_list|)
return|;
if|if
condition|(
name|ConstantVector
modifier|*
name|CV
init|=
name|dyn_cast
operator|<
name|ConstantVector
operator|>
operator|(
name|RHS
operator|)
condition|)
return|return
name|CV
operator|->
name|isAllOnesValue
argument_list|()
operator|&&
name|L
operator|.
name|match
argument_list|(
name|LHS
argument_list|)
return|;
if|if
condition|(
name|ConstantVector
modifier|*
name|CV
init|=
name|dyn_cast
operator|<
name|ConstantVector
operator|>
operator|(
name|LHS
operator|)
condition|)
return|return
name|CV
operator|->
name|isAllOnesValue
argument_list|()
operator|&&
name|L
operator|.
name|match
argument_list|(
name|RHS
argument_list|)
return|;
return|return
name|false
return|;
block|}
block|}
empty_stmt|;
name|template
operator|<
name|typename
name|LHS
operator|>
specifier|inline
name|not_match
operator|<
name|LHS
operator|>
name|m_Not
argument_list|(
argument|const LHS&L
argument_list|)
block|{
return|return
name|L
return|;
block|}
name|template
operator|<
name|typename
name|LHS_t
operator|>
expr|struct
name|neg_match
block|{
name|LHS_t
name|L
block|;
name|neg_match
argument_list|(
specifier|const
name|LHS_t
operator|&
name|LHS
argument_list|)
operator|:
name|L
argument_list|(
argument|LHS
argument_list|)
block|{}
name|template
operator|<
name|typename
name|OpTy
operator|>
name|bool
name|match
argument_list|(
argument|OpTy *V
argument_list|)
block|{
if|if
condition|(
name|Instruction
modifier|*
name|I
init|=
name|dyn_cast
operator|<
name|Instruction
operator|>
operator|(
name|V
operator|)
condition|)
if|if
condition|(
name|I
operator|->
name|getOpcode
argument_list|()
operator|==
name|Instruction
operator|::
name|Sub
condition|)
return|return
name|matchIfNeg
argument_list|(
name|I
operator|->
name|getOperand
argument_list|(
literal|0
argument_list|)
argument_list|,
name|I
operator|->
name|getOperand
argument_list|(
literal|1
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|ConstantExpr
modifier|*
name|CE
init|=
name|dyn_cast
operator|<
name|ConstantExpr
operator|>
operator|(
name|V
operator|)
condition|)
if|if
condition|(
name|CE
operator|->
name|getOpcode
argument_list|()
operator|==
name|Instruction
operator|::
name|Sub
condition|)
return|return
name|matchIfNeg
argument_list|(
name|CE
operator|->
name|getOperand
argument_list|(
literal|0
argument_list|)
argument_list|,
name|CE
operator|->
name|getOperand
argument_list|(
literal|1
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|ConstantInt
modifier|*
name|CI
init|=
name|dyn_cast
operator|<
name|ConstantInt
operator|>
operator|(
name|V
operator|)
condition|)
return|return
name|L
operator|.
name|match
argument_list|(
name|ConstantExpr
operator|::
name|getNeg
argument_list|(
name|CI
argument_list|)
argument_list|)
return|;
return|return
name|false
return|;
block|}
end_decl_stmt

begin_label
name|private
label|:
end_label

begin_function
name|bool
name|matchIfNeg
parameter_list|(
name|Value
modifier|*
name|LHS
parameter_list|,
name|Value
modifier|*
name|RHS
parameter_list|)
block|{
return|return
name|LHS
operator|==
name|ConstantFP
operator|::
name|getZeroValueForNegation
argument_list|(
name|LHS
operator|->
name|getType
argument_list|()
argument_list|)
operator|&&
name|L
operator|.
name|match
argument_list|(
name|RHS
argument_list|)
return|;
block|}
end_function

begin_expr_stmt
unit|};
name|template
operator|<
name|typename
name|LHS
operator|>
specifier|inline
name|neg_match
operator|<
name|LHS
operator|>
name|m_Neg
argument_list|(
argument|const LHS&L
argument_list|)
block|{
return|return
name|L
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|LHS_t
operator|>
expr|struct
name|fneg_match
block|{
name|LHS_t
name|L
block|;
name|fneg_match
argument_list|(
specifier|const
name|LHS_t
operator|&
name|LHS
argument_list|)
operator|:
name|L
argument_list|(
argument|LHS
argument_list|)
block|{}
name|template
operator|<
name|typename
name|OpTy
operator|>
name|bool
name|match
argument_list|(
argument|OpTy *V
argument_list|)
block|{
if|if
condition|(
name|Instruction
modifier|*
name|I
init|=
name|dyn_cast
operator|<
name|Instruction
operator|>
operator|(
name|V
operator|)
condition|)
if|if
condition|(
name|I
operator|->
name|getOpcode
argument_list|()
operator|==
name|Instruction
operator|::
name|FSub
condition|)
return|return
name|matchIfFNeg
argument_list|(
name|I
operator|->
name|getOperand
argument_list|(
literal|0
argument_list|)
argument_list|,
name|I
operator|->
name|getOperand
argument_list|(
literal|1
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|ConstantExpr
modifier|*
name|CE
init|=
name|dyn_cast
operator|<
name|ConstantExpr
operator|>
operator|(
name|V
operator|)
condition|)
if|if
condition|(
name|CE
operator|->
name|getOpcode
argument_list|()
operator|==
name|Instruction
operator|::
name|FSub
condition|)
return|return
name|matchIfFNeg
argument_list|(
name|CE
operator|->
name|getOperand
argument_list|(
literal|0
argument_list|)
argument_list|,
name|CE
operator|->
name|getOperand
argument_list|(
literal|1
argument_list|)
argument_list|)
return|;
end_expr_stmt

begin_if
if|if
condition|(
name|ConstantFP
modifier|*
name|CF
init|=
name|dyn_cast
operator|<
name|ConstantFP
operator|>
operator|(
name|V
operator|)
condition|)
return|return
name|L
operator|.
name|match
argument_list|(
name|ConstantExpr
operator|::
name|getFNeg
argument_list|(
name|CF
argument_list|)
argument_list|)
return|;
end_if

begin_return
return|return
name|false
return|;
end_return

begin_function
unit|} private:
name|bool
name|matchIfFNeg
parameter_list|(
name|Value
modifier|*
name|LHS
parameter_list|,
name|Value
modifier|*
name|RHS
parameter_list|)
block|{
return|return
name|LHS
operator|==
name|ConstantFP
operator|::
name|getZeroValueForNegation
argument_list|(
name|LHS
operator|->
name|getType
argument_list|()
argument_list|)
operator|&&
name|L
operator|.
name|match
argument_list|(
name|RHS
argument_list|)
return|;
block|}
end_function

begin_expr_stmt
unit|};
name|template
operator|<
name|typename
name|LHS
operator|>
specifier|inline
name|fneg_match
operator|<
name|LHS
operator|>
name|m_FNeg
argument_list|(
argument|const LHS&L
argument_list|)
block|{
return|return
name|L
return|;
block|}
end_expr_stmt

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|// Matchers for control flow
end_comment

begin_comment
comment|//
end_comment

begin_expr_stmt
name|template
operator|<
name|typename
name|Cond_t
operator|>
expr|struct
name|brc_match
block|{
name|Cond_t
name|Cond
block|;
name|BasicBlock
operator|*
operator|&
name|T
block|,
operator|*
operator|&
name|F
block|;
name|brc_match
argument_list|(
specifier|const
name|Cond_t
operator|&
name|C
argument_list|,
name|BasicBlock
operator|*
operator|&
name|t
argument_list|,
name|BasicBlock
operator|*
operator|&
name|f
argument_list|)
operator|:
name|Cond
argument_list|(
name|C
argument_list|)
block|,
name|T
argument_list|(
name|t
argument_list|)
block|,
name|F
argument_list|(
argument|f
argument_list|)
block|{   }
name|template
operator|<
name|typename
name|OpTy
operator|>
name|bool
name|match
argument_list|(
argument|OpTy *V
argument_list|)
block|{
if|if
condition|(
name|BranchInst
modifier|*
name|BI
init|=
name|dyn_cast
operator|<
name|BranchInst
operator|>
operator|(
name|V
operator|)
condition|)
if|if
condition|(
name|BI
operator|->
name|isConditional
argument_list|()
condition|)
block|{
if|if
condition|(
name|Cond
operator|.
name|match
argument_list|(
name|BI
operator|->
name|getCondition
argument_list|()
argument_list|)
condition|)
block|{
name|T
operator|=
name|BI
operator|->
name|getSuccessor
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|F
operator|=
name|BI
operator|->
name|getSuccessor
argument_list|(
literal|1
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
block|}
end_expr_stmt

begin_return
return|return
name|false
return|;
end_return

begin_empty_stmt
unit|} }
empty_stmt|;
end_empty_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|Cond_t
operator|>
specifier|inline
name|brc_match
operator|<
name|Cond_t
operator|>
name|m_Br
argument_list|(
argument|const Cond_t&C
argument_list|,
argument|BasicBlock *&T
argument_list|,
argument|BasicBlock *&F
argument_list|)
block|{
return|return
name|brc_match
operator|<
name|Cond_t
operator|>
operator|(
name|C
operator|,
name|T
operator|,
name|F
operator|)
return|;
block|}
end_expr_stmt

begin_comment
unit|}
comment|// end namespace PatternMatch
end_comment

begin_comment
unit|}
comment|// end namespace llvm
end_comment

begin_endif
endif|#
directive|endif
end_endif

end_unit

