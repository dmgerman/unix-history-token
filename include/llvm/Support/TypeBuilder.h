begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===---- llvm/Support/TypeBuilder.h - Builder for LLVM types ---*- C++ -*-===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file defines the TypeBuilder class, which is used as a convenient way to
end_comment

begin_comment
comment|// create LLVM types with a consistent and simplified interface.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LLVM_SUPPORT_TYPEBUILDER_H
end_ifndef

begin_define
define|#
directive|define
name|LLVM_SUPPORT_TYPEBUILDER_H
end_define

begin_include
include|#
directive|include
file|"llvm/DerivedTypes.h"
end_include

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_decl_stmt
name|namespace
name|llvm
block|{
comment|/// TypeBuilder - This provides a uniform API for looking up types
comment|/// known at compile time.  To support cross-compilation, we define a
comment|/// series of tag types in the llvm::types namespace, like i<N>,
comment|/// ieee_float, ppc_fp128, etc.  TypeBuilder<T, false> allows T to be
comment|/// any of these, a native C type (whose size may depend on the host
comment|/// compiler), or a pointer, function, or struct type built out of
comment|/// these.  TypeBuilder<T, true> removes native C types from this set
comment|/// to guarantee that its result is suitable for cross-compilation.
comment|/// We define the primitive types, pointer types, and functions up to
comment|/// 5 arguments here, but to use this class with your own types,
comment|/// you'll need to specialize it.  For example, say you want to call a
comment|/// function defined externally as:
comment|///
comment|///   struct MyType {
comment|///     int32 a;
comment|///     int32 *b;
comment|///     void *array[1];  // Intended as a flexible array.
comment|///   };
comment|///   int8 AFunction(struct MyType *value);
comment|///
comment|/// You'll want to use
comment|///   Function::Create(TypeBuilder<types::i<8>(MyType*), true>::get(), ...)
comment|/// to declare the function, but when you first try this, your compiler will
comment|/// complain that TypeBuilder<MyType, true>::get() doesn't exist. To fix this,
comment|/// write:
comment|///
comment|///   namespace llvm {
comment|///   template<bool xcompile> class TypeBuilder<MyType, xcompile> {
comment|///   public:
comment|///     static const StructType *get() {
comment|///       // Using the static result variable ensures that the type is
comment|///       // only looked up once.
comment|///       static const StructType *const result = StructType::get(
comment|///         TypeBuilder<types::i<32>, xcompile>::get(),
comment|///         TypeBuilder<types::i<32>*, xcompile>::get(),
comment|///         TypeBuilder<types::i<8>*[], xcompile>::get(),
comment|///         NULL);
comment|///       return result;
comment|///     }
comment|///
comment|///     // You may find this a convenient place to put some constants
comment|///     // to help with getelementptr.  They don't have any effect on
comment|///     // the operation of TypeBuilder.
comment|///     enum Fields {
comment|///       FIELD_A,
comment|///       FIELD_B,
comment|///       FIELD_ARRAY
comment|///     };
comment|///   }
comment|///   }  // namespace llvm
comment|///
comment|/// Using the static result variable ensures that the type is only looked up
comment|/// once.
comment|///
comment|/// TypeBuilder cannot handle recursive types or types you only know at runtime.
comment|/// If you try to give it a recursive type, it will deadlock, infinitely
comment|/// recurse, or throw a recursive_init exception.
name|template
operator|<
name|typename
name|T
operator|,
name|bool
name|cross_compilable
operator|>
name|class
name|TypeBuilder
block|{}
expr_stmt|;
comment|// Types for use with cross-compilable TypeBuilders.  These correspond
comment|// exactly with an LLVM-native type.
name|namespace
name|types
block|{
comment|/// i<N> corresponds to the LLVM IntegerType with N bits.
name|template
operator|<
name|uint32_t
name|num_bits
operator|>
name|class
name|i
block|{}
expr_stmt|;
comment|// The following classes represent the LLVM floating types.
name|class
name|ieee_float
block|{}
empty_stmt|;
name|class
name|ieee_double
block|{}
empty_stmt|;
name|class
name|x86_fp80
block|{}
empty_stmt|;
name|class
name|fp128
block|{}
empty_stmt|;
name|class
name|ppc_fp128
block|{}
empty_stmt|;
block|}
comment|// namespace types
comment|// LLVM doesn't have const or volatile types.
name|template
operator|<
name|typename
name|T
operator|,
name|bool
name|cross
operator|>
name|class
name|TypeBuilder
operator|<
specifier|const
name|T
operator|,
name|cross
operator|>
operator|:
name|public
name|TypeBuilder
operator|<
name|T
operator|,
name|cross
operator|>
block|{}
expr_stmt|;
name|template
operator|<
name|typename
name|T
operator|,
name|bool
name|cross
operator|>
name|class
name|TypeBuilder
operator|<
specifier|volatile
name|T
operator|,
name|cross
operator|>
operator|:
name|public
name|TypeBuilder
operator|<
name|T
operator|,
name|cross
operator|>
block|{}
expr_stmt|;
name|template
operator|<
name|typename
name|T
operator|,
name|bool
name|cross
operator|>
name|class
name|TypeBuilder
operator|<
specifier|const
specifier|volatile
name|T
operator|,
name|cross
operator|>
operator|:
name|public
name|TypeBuilder
operator|<
name|T
operator|,
name|cross
operator|>
block|{}
expr_stmt|;
comment|// Pointers
name|template
operator|<
name|typename
name|T
operator|,
name|bool
name|cross
operator|>
name|class
name|TypeBuilder
operator|<
name|T
operator|*
operator|,
name|cross
operator|>
block|{
name|public
operator|:
specifier|static
specifier|const
name|PointerType
operator|*
name|get
argument_list|()
block|{
specifier|static
specifier|const
name|PointerType
operator|*
specifier|const
name|result
operator|=
name|PointerType
operator|::
name|getUnqual
argument_list|(
name|TypeBuilder
operator|<
name|T
argument_list|,
name|cross
operator|>
operator|::
name|get
argument_list|()
argument_list|)
block|;
return|return
name|result
return|;
block|}
expr|}
block|;
comment|/// There is no support for references
name|template
operator|<
name|typename
name|T
block|,
name|bool
name|cross
operator|>
name|class
name|TypeBuilder
operator|<
name|T
operator|&
block|,
name|cross
operator|>
block|{}
block|;
comment|// Arrays
name|template
operator|<
name|typename
name|T
block|,
name|size_t
name|N
block|,
name|bool
name|cross
operator|>
name|class
name|TypeBuilder
operator|<
name|T
index|[
name|N
index|]
block|,
name|cross
operator|>
block|{
name|public
operator|:
specifier|static
specifier|const
name|ArrayType
operator|*
name|get
argument_list|()
block|{
specifier|static
specifier|const
name|ArrayType
operator|*
specifier|const
name|result
operator|=
name|ArrayType
operator|::
name|get
argument_list|(
name|TypeBuilder
operator|<
name|T
argument_list|,
name|cross
operator|>
operator|::
name|get
argument_list|()
argument_list|,
name|N
argument_list|)
block|;
return|return
name|result
return|;
block|}
expr|}
block|;
comment|/// LLVM uses an array of length 0 to represent an unknown-length array.
name|template
operator|<
name|typename
name|T
block|,
name|bool
name|cross
operator|>
name|class
name|TypeBuilder
operator|<
name|T
index|[]
block|,
name|cross
operator|>
block|{
name|public
operator|:
specifier|static
specifier|const
name|ArrayType
operator|*
name|get
argument_list|()
block|{
specifier|static
specifier|const
name|ArrayType
operator|*
specifier|const
name|result
operator|=
name|ArrayType
operator|::
name|get
argument_list|(
name|TypeBuilder
operator|<
name|T
argument_list|,
name|cross
operator|>
operator|::
name|get
argument_list|()
argument_list|,
literal|0
argument_list|)
block|;
return|return
name|result
return|;
block|}
expr|}
block|;
comment|// Define the C integral types only for TypeBuilder<T, false>.
comment|//
comment|// C integral types do not have a defined size. It would be nice to use the
comment|// stdint.h-defined typedefs that do have defined sizes, but we'd run into the
comment|// following problem:
comment|//
comment|// On an ILP32 machine, stdint.h might define:
comment|//
comment|//   typedef int int32_t;
comment|//   typedef long long int64_t;
comment|//   typedef long size_t;
comment|//
comment|// If we defined TypeBuilder<int32_t> and TypeBuilder<int64_t>, then any use of
comment|// TypeBuilder<size_t> would fail.  We couldn't define TypeBuilder<size_t> in
comment|// addition to the defined-size types because we'd get duplicate definitions on
comment|// platforms where stdint.h instead defines:
comment|//
comment|//   typedef int int32_t;
comment|//   typedef long long int64_t;
comment|//   typedef int size_t;
comment|//
comment|// So we define all the primitive C types and nothing else.
define|#
directive|define
name|DEFINE_INTEGRAL_TYPEBUILDER
parameter_list|(
name|T
parameter_list|)
define|\
value|template<> class TypeBuilder<T, false> { \ public: \   static const IntegerType *get() { \     static const IntegerType *const result = \       IntegerType::get(sizeof(T) * CHAR_BIT); \     return result; \   } \ }; \ template<> class TypeBuilder<T, true> { \
comment|/* We provide a definition here so users don't accidentally */
value|\
comment|/* define these types to work. */
value|\ }
name|DEFINE_INTEGRAL_TYPEBUILDER
argument_list|(
name|char
argument_list|)
block|;
name|DEFINE_INTEGRAL_TYPEBUILDER
argument_list|(
argument|signed char
argument_list|)
block|;
name|DEFINE_INTEGRAL_TYPEBUILDER
argument_list|(
argument|unsigned char
argument_list|)
block|;
name|DEFINE_INTEGRAL_TYPEBUILDER
argument_list|(
name|short
argument_list|)
block|;
name|DEFINE_INTEGRAL_TYPEBUILDER
argument_list|(
argument|unsigned short
argument_list|)
block|;
name|DEFINE_INTEGRAL_TYPEBUILDER
argument_list|(
name|int
argument_list|)
block|;
name|DEFINE_INTEGRAL_TYPEBUILDER
argument_list|(
argument|unsigned int
argument_list|)
block|;
name|DEFINE_INTEGRAL_TYPEBUILDER
argument_list|(
name|long
argument_list|)
block|;
name|DEFINE_INTEGRAL_TYPEBUILDER
argument_list|(
argument|unsigned long
argument_list|)
block|;
ifdef|#
directive|ifdef
name|_MSC_VER
name|DEFINE_INTEGRAL_TYPEBUILDER
argument_list|(
name|__int64
argument_list|)
block|;
name|DEFINE_INTEGRAL_TYPEBUILDER
argument_list|(
argument|unsigned __int64
argument_list|)
block|;
else|#
directive|else
comment|/* _MSC_VER */
name|DEFINE_INTEGRAL_TYPEBUILDER
argument_list|(
argument|long long
argument_list|)
block|;
name|DEFINE_INTEGRAL_TYPEBUILDER
argument_list|(
argument|unsigned long long
argument_list|)
block|;
endif|#
directive|endif
comment|/* _MSC_VER */
undef|#
directive|undef
name|DEFINE_INTEGRAL_TYPEBUILDER
name|template
operator|<
name|uint32_t
name|num_bits
block|,
name|bool
name|cross
operator|>
name|class
name|TypeBuilder
operator|<
name|types
operator|::
name|i
operator|<
name|num_bits
operator|>
block|,
name|cross
operator|>
block|{
name|public
operator|:
specifier|static
specifier|const
name|IntegerType
operator|*
name|get
argument_list|()
block|{
specifier|static
specifier|const
name|IntegerType
operator|*
specifier|const
name|result
operator|=
name|IntegerType
operator|::
name|get
argument_list|(
name|num_bits
argument_list|)
block|;
return|return
name|result
return|;
block|}
expr|}
block|;
name|template
operator|<
operator|>
name|class
name|TypeBuilder
operator|<
name|float
block|,
name|false
operator|>
block|{
name|public
operator|:
specifier|static
specifier|const
name|Type
operator|*
name|get
argument_list|()
block|{
return|return
name|Type
operator|::
name|FloatTy
return|;
block|}
expr|}
block|;
name|template
operator|<
operator|>
name|class
name|TypeBuilder
operator|<
name|float
block|,
name|true
operator|>
block|{}
block|;
name|template
operator|<
operator|>
name|class
name|TypeBuilder
operator|<
name|double
block|,
name|false
operator|>
block|{
name|public
operator|:
specifier|static
specifier|const
name|Type
operator|*
name|get
argument_list|()
block|{
return|return
name|Type
operator|::
name|DoubleTy
return|;
block|}
expr|}
block|;
name|template
operator|<
operator|>
name|class
name|TypeBuilder
operator|<
name|double
block|,
name|true
operator|>
block|{}
block|;
name|template
operator|<
name|bool
name|cross
operator|>
name|class
name|TypeBuilder
operator|<
name|types
operator|::
name|ieee_float
block|,
name|cross
operator|>
block|{
name|public
operator|:
specifier|static
specifier|const
name|Type
operator|*
name|get
argument_list|()
block|{
return|return
name|Type
operator|::
name|FloatTy
return|;
block|}
expr|}
block|;
name|template
operator|<
name|bool
name|cross
operator|>
name|class
name|TypeBuilder
operator|<
name|types
operator|::
name|ieee_double
block|,
name|cross
operator|>
block|{
name|public
operator|:
specifier|static
specifier|const
name|Type
operator|*
name|get
argument_list|()
block|{
return|return
name|Type
operator|::
name|DoubleTy
return|;
block|}
expr|}
block|;
name|template
operator|<
name|bool
name|cross
operator|>
name|class
name|TypeBuilder
operator|<
name|types
operator|::
name|x86_fp80
block|,
name|cross
operator|>
block|{
name|public
operator|:
specifier|static
specifier|const
name|Type
operator|*
name|get
argument_list|()
block|{
return|return
name|Type
operator|::
name|X86_FP80Ty
return|;
block|}
expr|}
block|;
name|template
operator|<
name|bool
name|cross
operator|>
name|class
name|TypeBuilder
operator|<
name|types
operator|::
name|fp128
block|,
name|cross
operator|>
block|{
name|public
operator|:
specifier|static
specifier|const
name|Type
operator|*
name|get
argument_list|()
block|{
return|return
name|Type
operator|::
name|FP128Ty
return|;
block|}
expr|}
block|;
name|template
operator|<
name|bool
name|cross
operator|>
name|class
name|TypeBuilder
operator|<
name|types
operator|::
name|ppc_fp128
block|,
name|cross
operator|>
block|{
name|public
operator|:
specifier|static
specifier|const
name|Type
operator|*
name|get
argument_list|()
block|{
return|return
name|Type
operator|::
name|PPC_FP128Ty
return|;
block|}
expr|}
block|;
name|template
operator|<
name|bool
name|cross
operator|>
name|class
name|TypeBuilder
operator|<
name|void
block|,
name|cross
operator|>
block|{
name|public
operator|:
specifier|static
specifier|const
name|Type
operator|*
name|get
argument_list|()
block|{
return|return
name|Type
operator|::
name|VoidTy
return|;
block|}
expr|}
block|;
comment|/// void* is disallowed in LLVM types, but it occurs often enough in C code that
comment|/// we special case it.
name|template
operator|<
operator|>
name|class
name|TypeBuilder
operator|<
name|void
operator|*
block|,
name|false
operator|>
operator|:
name|public
name|TypeBuilder
operator|<
name|types
operator|::
name|i
operator|<
literal|8
operator|>
operator|*
block|,
name|false
operator|>
block|{}
block|;
name|template
operator|<
name|typename
name|R
block|,
name|bool
name|cross
operator|>
name|class
name|TypeBuilder
operator|<
name|R
argument_list|()
block|,
name|cross
operator|>
block|{
name|public
operator|:
specifier|static
specifier|const
name|FunctionType
operator|*
name|get
argument_list|()
block|{
specifier|static
specifier|const
name|FunctionType
operator|*
specifier|const
name|result
operator|=
name|create
argument_list|()
block|;
return|return
name|result
return|;
block|}
name|private
operator|:
specifier|static
specifier|const
name|FunctionType
operator|*
name|create
argument_list|()
block|{
name|std
operator|::
name|vector
operator|<
specifier|const
name|Type
operator|*
operator|>
name|params
block|;
return|return
name|FunctionType
operator|::
name|get
argument_list|(
name|TypeBuilder
operator|<
name|R
argument_list|,
name|cross
operator|>
operator|::
name|get
argument_list|()
argument_list|,
name|params
argument_list|,
name|false
argument_list|)
return|;
block|}
expr|}
block|;
name|template
operator|<
name|typename
name|R
block|,
name|typename
name|A1
block|,
name|bool
name|cross
operator|>
name|class
name|TypeBuilder
operator|<
name|R
argument_list|(
name|A1
argument_list|)
block|,
name|cross
operator|>
block|{
name|public
operator|:
specifier|static
specifier|const
name|FunctionType
operator|*
name|get
argument_list|()
block|{
specifier|static
specifier|const
name|FunctionType
operator|*
specifier|const
name|result
operator|=
name|create
argument_list|()
block|;
return|return
name|result
return|;
block|}
name|private
operator|:
specifier|static
specifier|const
name|FunctionType
operator|*
name|create
argument_list|()
block|{
name|std
operator|::
name|vector
operator|<
specifier|const
name|Type
operator|*
operator|>
name|params
block|;
name|params
operator|.
name|reserve
argument_list|(
literal|1
argument_list|)
block|;
name|params
operator|.
name|push_back
argument_list|(
name|TypeBuilder
operator|<
name|A1
argument_list|,
name|cross
operator|>
operator|::
name|get
argument_list|()
argument_list|)
block|;
return|return
name|FunctionType
operator|::
name|get
argument_list|(
name|TypeBuilder
operator|<
name|R
argument_list|,
name|cross
operator|>
operator|::
name|get
argument_list|()
argument_list|,
name|params
argument_list|,
name|false
argument_list|)
return|;
block|}
expr|}
block|;
name|template
operator|<
name|typename
name|R
block|,
name|typename
name|A1
block|,
name|typename
name|A2
block|,
name|bool
name|cross
operator|>
name|class
name|TypeBuilder
operator|<
name|R
argument_list|(
name|A1
argument_list|,
name|A2
argument_list|)
block|,
name|cross
operator|>
block|{
name|public
operator|:
specifier|static
specifier|const
name|FunctionType
operator|*
name|get
argument_list|()
block|{
specifier|static
specifier|const
name|FunctionType
operator|*
specifier|const
name|result
operator|=
name|create
argument_list|()
block|;
return|return
name|result
return|;
block|}
name|private
operator|:
specifier|static
specifier|const
name|FunctionType
operator|*
name|create
argument_list|()
block|{
name|std
operator|::
name|vector
operator|<
specifier|const
name|Type
operator|*
operator|>
name|params
block|;
name|params
operator|.
name|reserve
argument_list|(
literal|2
argument_list|)
block|;
name|params
operator|.
name|push_back
argument_list|(
name|TypeBuilder
operator|<
name|A1
argument_list|,
name|cross
operator|>
operator|::
name|get
argument_list|()
argument_list|)
block|;
name|params
operator|.
name|push_back
argument_list|(
name|TypeBuilder
operator|<
name|A2
argument_list|,
name|cross
operator|>
operator|::
name|get
argument_list|()
argument_list|)
block|;
return|return
name|FunctionType
operator|::
name|get
argument_list|(
name|TypeBuilder
operator|<
name|R
argument_list|,
name|cross
operator|>
operator|::
name|get
argument_list|()
argument_list|,
name|params
argument_list|,
name|false
argument_list|)
return|;
block|}
expr|}
block|;
name|template
operator|<
name|typename
name|R
block|,
name|typename
name|A1
block|,
name|typename
name|A2
block|,
name|typename
name|A3
block|,
name|bool
name|cross
operator|>
name|class
name|TypeBuilder
operator|<
name|R
argument_list|(
name|A1
argument_list|,
name|A2
argument_list|,
name|A3
argument_list|)
block|,
name|cross
operator|>
block|{
name|public
operator|:
specifier|static
specifier|const
name|FunctionType
operator|*
name|get
argument_list|()
block|{
specifier|static
specifier|const
name|FunctionType
operator|*
specifier|const
name|result
operator|=
name|create
argument_list|()
block|;
return|return
name|result
return|;
block|}
name|private
operator|:
specifier|static
specifier|const
name|FunctionType
operator|*
name|create
argument_list|()
block|{
name|std
operator|::
name|vector
operator|<
specifier|const
name|Type
operator|*
operator|>
name|params
block|;
name|params
operator|.
name|reserve
argument_list|(
literal|3
argument_list|)
block|;
name|params
operator|.
name|push_back
argument_list|(
name|TypeBuilder
operator|<
name|A1
argument_list|,
name|cross
operator|>
operator|::
name|get
argument_list|()
argument_list|)
block|;
name|params
operator|.
name|push_back
argument_list|(
name|TypeBuilder
operator|<
name|A2
argument_list|,
name|cross
operator|>
operator|::
name|get
argument_list|()
argument_list|)
block|;
name|params
operator|.
name|push_back
argument_list|(
name|TypeBuilder
operator|<
name|A3
argument_list|,
name|cross
operator|>
operator|::
name|get
argument_list|()
argument_list|)
block|;
return|return
name|FunctionType
operator|::
name|get
argument_list|(
name|TypeBuilder
operator|<
name|R
argument_list|,
name|cross
operator|>
operator|::
name|get
argument_list|()
argument_list|,
name|params
argument_list|,
name|false
argument_list|)
return|;
block|}
expr|}
block|;
name|template
operator|<
name|typename
name|R
block|,
name|typename
name|A1
block|,
name|typename
name|A2
block|,
name|typename
name|A3
block|,
name|typename
name|A4
block|,
name|bool
name|cross
operator|>
name|class
name|TypeBuilder
operator|<
name|R
argument_list|(
name|A1
argument_list|,
name|A2
argument_list|,
name|A3
argument_list|,
name|A4
argument_list|)
block|,
name|cross
operator|>
block|{
name|public
operator|:
specifier|static
specifier|const
name|FunctionType
operator|*
name|get
argument_list|()
block|{
specifier|static
specifier|const
name|FunctionType
operator|*
specifier|const
name|result
operator|=
name|create
argument_list|()
block|;
return|return
name|result
return|;
block|}
name|private
operator|:
specifier|static
specifier|const
name|FunctionType
operator|*
name|create
argument_list|()
block|{
name|std
operator|::
name|vector
operator|<
specifier|const
name|Type
operator|*
operator|>
name|params
block|;
name|params
operator|.
name|reserve
argument_list|(
literal|4
argument_list|)
block|;
name|params
operator|.
name|push_back
argument_list|(
name|TypeBuilder
operator|<
name|A1
argument_list|,
name|cross
operator|>
operator|::
name|get
argument_list|()
argument_list|)
block|;
name|params
operator|.
name|push_back
argument_list|(
name|TypeBuilder
operator|<
name|A2
argument_list|,
name|cross
operator|>
operator|::
name|get
argument_list|()
argument_list|)
block|;
name|params
operator|.
name|push_back
argument_list|(
name|TypeBuilder
operator|<
name|A3
argument_list|,
name|cross
operator|>
operator|::
name|get
argument_list|()
argument_list|)
block|;
name|params
operator|.
name|push_back
argument_list|(
name|TypeBuilder
operator|<
name|A4
argument_list|,
name|cross
operator|>
operator|::
name|get
argument_list|()
argument_list|)
block|;
return|return
name|FunctionType
operator|::
name|get
argument_list|(
name|TypeBuilder
operator|<
name|R
argument_list|,
name|cross
operator|>
operator|::
name|get
argument_list|()
argument_list|,
name|params
argument_list|,
name|false
argument_list|)
return|;
block|}
expr|}
block|;
name|template
operator|<
name|typename
name|R
block|,
name|typename
name|A1
block|,
name|typename
name|A2
block|,
name|typename
name|A3
block|,
name|typename
name|A4
block|,
name|typename
name|A5
block|,
name|bool
name|cross
operator|>
name|class
name|TypeBuilder
operator|<
name|R
argument_list|(
name|A1
argument_list|,
name|A2
argument_list|,
name|A3
argument_list|,
name|A4
argument_list|,
name|A5
argument_list|)
block|,
name|cross
operator|>
block|{
name|public
operator|:
specifier|static
specifier|const
name|FunctionType
operator|*
name|get
argument_list|()
block|{
specifier|static
specifier|const
name|FunctionType
operator|*
specifier|const
name|result
operator|=
name|create
argument_list|()
block|;
return|return
name|result
return|;
block|}
name|private
operator|:
specifier|static
specifier|const
name|FunctionType
operator|*
name|create
argument_list|()
block|{
name|std
operator|::
name|vector
operator|<
specifier|const
name|Type
operator|*
operator|>
name|params
block|;
name|params
operator|.
name|reserve
argument_list|(
literal|5
argument_list|)
block|;
name|params
operator|.
name|push_back
argument_list|(
name|TypeBuilder
operator|<
name|A1
argument_list|,
name|cross
operator|>
operator|::
name|get
argument_list|()
argument_list|)
block|;
name|params
operator|.
name|push_back
argument_list|(
name|TypeBuilder
operator|<
name|A2
argument_list|,
name|cross
operator|>
operator|::
name|get
argument_list|()
argument_list|)
block|;
name|params
operator|.
name|push_back
argument_list|(
name|TypeBuilder
operator|<
name|A3
argument_list|,
name|cross
operator|>
operator|::
name|get
argument_list|()
argument_list|)
block|;
name|params
operator|.
name|push_back
argument_list|(
name|TypeBuilder
operator|<
name|A4
argument_list|,
name|cross
operator|>
operator|::
name|get
argument_list|()
argument_list|)
block|;
name|params
operator|.
name|push_back
argument_list|(
name|TypeBuilder
operator|<
name|A5
argument_list|,
name|cross
operator|>
operator|::
name|get
argument_list|()
argument_list|)
block|;
return|return
name|FunctionType
operator|::
name|get
argument_list|(
name|TypeBuilder
operator|<
name|R
argument_list|,
name|cross
operator|>
operator|::
name|get
argument_list|()
argument_list|,
name|params
argument_list|,
name|false
argument_list|)
return|;
block|}
expr|}
block|;
name|template
operator|<
name|typename
name|R
block|,
name|bool
name|cross
operator|>
name|class
name|TypeBuilder
operator|<
name|R
argument_list|(
operator|...
argument_list|)
block|,
name|cross
operator|>
block|{
name|public
operator|:
specifier|static
specifier|const
name|FunctionType
operator|*
name|get
argument_list|()
block|{
specifier|static
specifier|const
name|FunctionType
operator|*
specifier|const
name|result
operator|=
name|create
argument_list|()
block|;
return|return
name|result
return|;
block|}
name|private
operator|:
specifier|static
specifier|const
name|FunctionType
operator|*
name|create
argument_list|()
block|{
name|std
operator|::
name|vector
operator|<
specifier|const
name|Type
operator|*
operator|>
name|params
block|;
return|return
name|FunctionType
operator|::
name|get
argument_list|(
name|TypeBuilder
operator|<
name|R
argument_list|,
name|cross
operator|>
operator|::
name|get
argument_list|()
argument_list|,
name|params
argument_list|,
name|true
argument_list|)
return|;
block|}
expr|}
block|;
name|template
operator|<
name|typename
name|R
block|,
name|typename
name|A1
block|,
name|bool
name|cross
operator|>
name|class
name|TypeBuilder
operator|<
name|R
argument_list|(
name|A1
argument_list|,
operator|...
argument_list|)
block|,
name|cross
operator|>
block|{
name|public
operator|:
specifier|static
specifier|const
name|FunctionType
operator|*
name|get
argument_list|()
block|{
specifier|static
specifier|const
name|FunctionType
operator|*
specifier|const
name|result
operator|=
name|create
argument_list|()
block|;
return|return
name|result
return|;
block|}
name|private
operator|:
specifier|static
specifier|const
name|FunctionType
operator|*
name|create
argument_list|()
block|{
name|std
operator|::
name|vector
operator|<
specifier|const
name|Type
operator|*
operator|>
name|params
block|;
name|params
operator|.
name|reserve
argument_list|(
literal|1
argument_list|)
block|;
name|params
operator|.
name|push_back
argument_list|(
name|TypeBuilder
operator|<
name|A1
argument_list|,
name|cross
operator|>
operator|::
name|get
argument_list|()
argument_list|)
block|;
return|return
name|FunctionType
operator|::
name|get
argument_list|(
name|TypeBuilder
operator|<
name|R
argument_list|,
name|cross
operator|>
operator|::
name|get
argument_list|()
argument_list|,
name|params
argument_list|,
name|true
argument_list|)
return|;
block|}
expr|}
block|;
name|template
operator|<
name|typename
name|R
block|,
name|typename
name|A1
block|,
name|typename
name|A2
block|,
name|bool
name|cross
operator|>
name|class
name|TypeBuilder
operator|<
name|R
argument_list|(
name|A1
argument_list|,
name|A2
argument_list|,
operator|...
argument_list|)
block|,
name|cross
operator|>
block|{
name|public
operator|:
specifier|static
specifier|const
name|FunctionType
operator|*
name|get
argument_list|()
block|{
specifier|static
specifier|const
name|FunctionType
operator|*
specifier|const
name|result
operator|=
name|create
argument_list|()
block|;
return|return
name|result
return|;
block|}
name|private
operator|:
specifier|static
specifier|const
name|FunctionType
operator|*
name|create
argument_list|()
block|{
name|std
operator|::
name|vector
operator|<
specifier|const
name|Type
operator|*
operator|>
name|params
block|;
name|params
operator|.
name|reserve
argument_list|(
literal|2
argument_list|)
block|;
name|params
operator|.
name|push_back
argument_list|(
name|TypeBuilder
operator|<
name|A1
argument_list|,
name|cross
operator|>
operator|::
name|get
argument_list|()
argument_list|)
block|;
name|params
operator|.
name|push_back
argument_list|(
name|TypeBuilder
operator|<
name|A2
argument_list|,
name|cross
operator|>
operator|::
name|get
argument_list|()
argument_list|)
block|;
return|return
name|FunctionType
operator|::
name|get
argument_list|(
name|TypeBuilder
operator|<
name|R
argument_list|,
name|cross
operator|>
operator|::
name|get
argument_list|()
argument_list|,
name|params
argument_list|,
name|true
argument_list|)
return|;
block|}
expr|}
block|;
name|template
operator|<
name|typename
name|R
block|,
name|typename
name|A1
block|,
name|typename
name|A2
block|,
name|typename
name|A3
block|,
name|bool
name|cross
operator|>
name|class
name|TypeBuilder
operator|<
name|R
argument_list|(
name|A1
argument_list|,
name|A2
argument_list|,
name|A3
argument_list|,
operator|...
argument_list|)
block|,
name|cross
operator|>
block|{
name|public
operator|:
specifier|static
specifier|const
name|FunctionType
operator|*
name|get
argument_list|()
block|{
specifier|static
specifier|const
name|FunctionType
operator|*
specifier|const
name|result
operator|=
name|create
argument_list|()
block|;
return|return
name|result
return|;
block|}
name|private
operator|:
specifier|static
specifier|const
name|FunctionType
operator|*
name|create
argument_list|()
block|{
name|std
operator|::
name|vector
operator|<
specifier|const
name|Type
operator|*
operator|>
name|params
block|;
name|params
operator|.
name|reserve
argument_list|(
literal|3
argument_list|)
block|;
name|params
operator|.
name|push_back
argument_list|(
name|TypeBuilder
operator|<
name|A1
argument_list|,
name|cross
operator|>
operator|::
name|get
argument_list|()
argument_list|)
block|;
name|params
operator|.
name|push_back
argument_list|(
name|TypeBuilder
operator|<
name|A2
argument_list|,
name|cross
operator|>
operator|::
name|get
argument_list|()
argument_list|)
block|;
name|params
operator|.
name|push_back
argument_list|(
name|TypeBuilder
operator|<
name|A3
argument_list|,
name|cross
operator|>
operator|::
name|get
argument_list|()
argument_list|)
block|;
return|return
name|FunctionType
operator|::
name|get
argument_list|(
name|TypeBuilder
operator|<
name|R
argument_list|,
name|cross
operator|>
operator|::
name|get
argument_list|()
argument_list|,
name|params
argument_list|,
name|true
argument_list|)
return|;
block|}
expr|}
block|;
name|template
operator|<
name|typename
name|R
block|,
name|typename
name|A1
block|,
name|typename
name|A2
block|,
name|typename
name|A3
block|,
name|typename
name|A4
block|,
name|bool
name|cross
operator|>
name|class
name|TypeBuilder
operator|<
name|R
argument_list|(
name|A1
argument_list|,
name|A2
argument_list|,
name|A3
argument_list|,
name|A4
argument_list|,
operator|...
argument_list|)
block|,
name|cross
operator|>
block|{
name|public
operator|:
specifier|static
specifier|const
name|FunctionType
operator|*
name|get
argument_list|()
block|{
specifier|static
specifier|const
name|FunctionType
operator|*
specifier|const
name|result
operator|=
name|create
argument_list|()
block|;
return|return
name|result
return|;
block|}
name|private
operator|:
specifier|static
specifier|const
name|FunctionType
operator|*
name|create
argument_list|()
block|{
name|std
operator|::
name|vector
operator|<
specifier|const
name|Type
operator|*
operator|>
name|params
block|;
name|params
operator|.
name|reserve
argument_list|(
literal|4
argument_list|)
block|;
name|params
operator|.
name|push_back
argument_list|(
name|TypeBuilder
operator|<
name|A1
argument_list|,
name|cross
operator|>
operator|::
name|get
argument_list|()
argument_list|)
block|;
name|params
operator|.
name|push_back
argument_list|(
name|TypeBuilder
operator|<
name|A2
argument_list|,
name|cross
operator|>
operator|::
name|get
argument_list|()
argument_list|)
block|;
name|params
operator|.
name|push_back
argument_list|(
name|TypeBuilder
operator|<
name|A3
argument_list|,
name|cross
operator|>
operator|::
name|get
argument_list|()
argument_list|)
block|;
name|params
operator|.
name|push_back
argument_list|(
name|TypeBuilder
operator|<
name|A4
argument_list|,
name|cross
operator|>
operator|::
name|get
argument_list|()
argument_list|)
block|;
return|return
name|FunctionType
operator|::
name|get
argument_list|(
name|TypeBuilder
operator|<
name|R
argument_list|,
name|cross
operator|>
operator|::
name|get
argument_list|()
argument_list|,
name|params
argument_list|,
name|true
argument_list|)
return|;
block|}
expr|}
block|;
name|template
operator|<
name|typename
name|R
block|,
name|typename
name|A1
block|,
name|typename
name|A2
block|,
name|typename
name|A3
block|,
name|typename
name|A4
block|,
name|typename
name|A5
block|,
name|bool
name|cross
operator|>
name|class
name|TypeBuilder
operator|<
name|R
argument_list|(
name|A1
argument_list|,
name|A2
argument_list|,
name|A3
argument_list|,
name|A4
argument_list|,
name|A5
argument_list|,
operator|...
argument_list|)
block|,
name|cross
operator|>
block|{
name|public
operator|:
specifier|static
specifier|const
name|FunctionType
operator|*
name|get
argument_list|()
block|{
specifier|static
specifier|const
name|FunctionType
operator|*
specifier|const
name|result
operator|=
name|create
argument_list|()
block|;
return|return
name|result
return|;
block|}
name|private
operator|:
specifier|static
specifier|const
name|FunctionType
operator|*
name|create
argument_list|()
block|{
name|std
operator|::
name|vector
operator|<
specifier|const
name|Type
operator|*
operator|>
name|params
block|;
name|params
operator|.
name|reserve
argument_list|(
literal|5
argument_list|)
block|;
name|params
operator|.
name|push_back
argument_list|(
name|TypeBuilder
operator|<
name|A1
argument_list|,
name|cross
operator|>
operator|::
name|get
argument_list|()
argument_list|)
block|;
name|params
operator|.
name|push_back
argument_list|(
name|TypeBuilder
operator|<
name|A2
argument_list|,
name|cross
operator|>
operator|::
name|get
argument_list|()
argument_list|)
block|;
name|params
operator|.
name|push_back
argument_list|(
name|TypeBuilder
operator|<
name|A3
argument_list|,
name|cross
operator|>
operator|::
name|get
argument_list|()
argument_list|)
block|;
name|params
operator|.
name|push_back
argument_list|(
name|TypeBuilder
operator|<
name|A4
argument_list|,
name|cross
operator|>
operator|::
name|get
argument_list|()
argument_list|)
block|;
name|params
operator|.
name|push_back
argument_list|(
name|TypeBuilder
operator|<
name|A5
argument_list|,
name|cross
operator|>
operator|::
name|get
argument_list|()
argument_list|)
block|;
return|return
name|FunctionType
operator|::
name|get
argument_list|(
name|TypeBuilder
operator|<
name|R
argument_list|,
name|cross
operator|>
operator|::
name|get
argument_list|()
argument_list|,
name|params
argument_list|,
name|true
argument_list|)
return|;
block|}
expr|}
block|;  }
end_decl_stmt

begin_comment
comment|// namespace llvm
end_comment

begin_endif
endif|#
directive|endif
end_endif

end_unit

