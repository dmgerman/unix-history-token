begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===- GCOV.h - LLVM coverage tool ------------------------------*- C++ -*-===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This header provides the interface to read and write coverage files that
end_comment

begin_comment
comment|// use 'gcov' format.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LLVM_SUPPORT_GCOV_H
end_ifndef

begin_define
define|#
directive|define
name|LLVM_SUPPORT_GCOV_H
end_define

begin_include
include|#
directive|include
file|"llvm/ADT/DenseMap.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/iterator.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/iterator_range.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/MapVector.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/SmallVector.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/StringMap.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/StringRef.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/MemoryBuffer.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/raw_ostream.h"
end_include

begin_include
include|#
directive|include
file|<cassert>
end_include

begin_include
include|#
directive|include
file|<cstddef>
end_include

begin_include
include|#
directive|include
file|<cstdint>
end_include

begin_include
include|#
directive|include
file|<memory>
end_include

begin_include
include|#
directive|include
file|<string>
end_include

begin_include
include|#
directive|include
file|<utility>
end_include

begin_decl_stmt
name|namespace
name|llvm
block|{
name|class
name|GCOVFunction
decl_stmt|;
name|class
name|GCOVBlock
decl_stmt|;
name|class
name|FileInfo
decl_stmt|;
name|namespace
name|GCOV
block|{
enum|enum
name|GCOVVersion
block|{
name|V402
block|,
name|V404
block|,
name|V704
block|}
enum|;
comment|/// \brief A struct for passing gcov options between functions.
struct|struct
name|Options
block|{
name|Options
argument_list|(
argument|bool A
argument_list|,
argument|bool B
argument_list|,
argument|bool C
argument_list|,
argument|bool F
argument_list|,
argument|bool P
argument_list|,
argument|bool U
argument_list|,
argument|bool L
argument_list|,
argument|bool N
argument_list|)
block|:
name|AllBlocks
argument_list|(
name|A
argument_list|)
operator|,
name|BranchInfo
argument_list|(
name|B
argument_list|)
operator|,
name|BranchCount
argument_list|(
name|C
argument_list|)
operator|,
name|FuncCoverage
argument_list|(
name|F
argument_list|)
operator|,
name|PreservePaths
argument_list|(
name|P
argument_list|)
operator|,
name|UncondBranch
argument_list|(
name|U
argument_list|)
operator|,
name|LongFileNames
argument_list|(
name|L
argument_list|)
operator|,
name|NoOutput
argument_list|(
argument|N
argument_list|)
block|{}
name|bool
name|AllBlocks
expr_stmt|;
name|bool
name|BranchInfo
decl_stmt|;
name|bool
name|BranchCount
decl_stmt|;
name|bool
name|FuncCoverage
decl_stmt|;
name|bool
name|PreservePaths
decl_stmt|;
name|bool
name|UncondBranch
decl_stmt|;
name|bool
name|LongFileNames
decl_stmt|;
name|bool
name|NoOutput
decl_stmt|;
block|}
struct|;
block|}
comment|// end namespace GCOV
comment|/// GCOVBuffer - A wrapper around MemoryBuffer to provide GCOV specific
comment|/// read operations.
name|class
name|GCOVBuffer
block|{
name|public
label|:
name|GCOVBuffer
argument_list|(
name|MemoryBuffer
operator|*
name|B
argument_list|)
operator|:
name|Buffer
argument_list|(
argument|B
argument_list|)
block|{}
comment|/// readGCNOFormat - Check GCNO signature is valid at the beginning of buffer.
name|bool
name|readGCNOFormat
argument_list|()
block|{
name|StringRef
name|File
operator|=
name|Buffer
operator|->
name|getBuffer
argument_list|()
operator|.
name|slice
argument_list|(
literal|0
argument_list|,
literal|4
argument_list|)
block|;
if|if
condition|(
name|File
operator|!=
literal|"oncg"
condition|)
block|{
name|errs
argument_list|()
operator|<<
literal|"Unexpected file type: "
operator|<<
name|File
operator|<<
literal|".\n"
expr_stmt|;
return|return
name|false
return|;
block|}
name|Cursor
operator|=
literal|4
expr_stmt|;
return|return
name|true
return|;
block|}
comment|/// readGCDAFormat - Check GCDA signature is valid at the beginning of buffer.
name|bool
name|readGCDAFormat
parameter_list|()
block|{
name|StringRef
name|File
init|=
name|Buffer
operator|->
name|getBuffer
argument_list|()
operator|.
name|slice
argument_list|(
literal|0
argument_list|,
literal|4
argument_list|)
decl_stmt|;
if|if
condition|(
name|File
operator|!=
literal|"adcg"
condition|)
block|{
name|errs
argument_list|()
operator|<<
literal|"Unexpected file type: "
operator|<<
name|File
operator|<<
literal|".\n"
expr_stmt|;
return|return
name|false
return|;
block|}
name|Cursor
operator|=
literal|4
expr_stmt|;
return|return
name|true
return|;
block|}
comment|/// readGCOVVersion - Read GCOV version.
name|bool
name|readGCOVVersion
argument_list|(
name|GCOV
operator|::
name|GCOVVersion
operator|&
name|Version
argument_list|)
block|{
name|StringRef
name|VersionStr
init|=
name|Buffer
operator|->
name|getBuffer
argument_list|()
operator|.
name|slice
argument_list|(
name|Cursor
argument_list|,
name|Cursor
operator|+
literal|4
argument_list|)
decl_stmt|;
if|if
condition|(
name|VersionStr
operator|==
literal|"*204"
condition|)
block|{
name|Cursor
operator|+=
literal|4
expr_stmt|;
name|Version
operator|=
name|GCOV
operator|::
name|V402
expr_stmt|;
return|return
name|true
return|;
block|}
if|if
condition|(
name|VersionStr
operator|==
literal|"*404"
condition|)
block|{
name|Cursor
operator|+=
literal|4
expr_stmt|;
name|Version
operator|=
name|GCOV
operator|::
name|V404
expr_stmt|;
return|return
name|true
return|;
block|}
if|if
condition|(
name|VersionStr
operator|==
literal|"*704"
condition|)
block|{
name|Cursor
operator|+=
literal|4
expr_stmt|;
name|Version
operator|=
name|GCOV
operator|::
name|V704
expr_stmt|;
return|return
name|true
return|;
block|}
name|errs
argument_list|()
operator|<<
literal|"Unexpected version: "
operator|<<
name|VersionStr
operator|<<
literal|".\n"
expr_stmt|;
return|return
name|false
return|;
block|}
comment|/// readFunctionTag - If cursor points to a function tag then increment the
comment|/// cursor and return true otherwise return false.
name|bool
name|readFunctionTag
parameter_list|()
block|{
name|StringRef
name|Tag
init|=
name|Buffer
operator|->
name|getBuffer
argument_list|()
operator|.
name|slice
argument_list|(
name|Cursor
argument_list|,
name|Cursor
operator|+
literal|4
argument_list|)
decl_stmt|;
if|if
condition|(
name|Tag
operator|.
name|empty
argument_list|()
operator|||
name|Tag
index|[
literal|0
index|]
operator|!=
literal|'\0'
operator|||
name|Tag
index|[
literal|1
index|]
operator|!=
literal|'\0'
operator|||
name|Tag
index|[
literal|2
index|]
operator|!=
literal|'\0'
operator|||
name|Tag
index|[
literal|3
index|]
operator|!=
literal|'\1'
condition|)
block|{
return|return
name|false
return|;
block|}
name|Cursor
operator|+=
literal|4
expr_stmt|;
return|return
name|true
return|;
block|}
comment|/// readBlockTag - If cursor points to a block tag then increment the
comment|/// cursor and return true otherwise return false.
name|bool
name|readBlockTag
parameter_list|()
block|{
name|StringRef
name|Tag
init|=
name|Buffer
operator|->
name|getBuffer
argument_list|()
operator|.
name|slice
argument_list|(
name|Cursor
argument_list|,
name|Cursor
operator|+
literal|4
argument_list|)
decl_stmt|;
if|if
condition|(
name|Tag
operator|.
name|empty
argument_list|()
operator|||
name|Tag
index|[
literal|0
index|]
operator|!=
literal|'\0'
operator|||
name|Tag
index|[
literal|1
index|]
operator|!=
literal|'\0'
operator|||
name|Tag
index|[
literal|2
index|]
operator|!=
literal|'\x41'
operator|||
name|Tag
index|[
literal|3
index|]
operator|!=
literal|'\x01'
condition|)
block|{
return|return
name|false
return|;
block|}
name|Cursor
operator|+=
literal|4
expr_stmt|;
return|return
name|true
return|;
block|}
comment|/// readEdgeTag - If cursor points to an edge tag then increment the
comment|/// cursor and return true otherwise return false.
name|bool
name|readEdgeTag
parameter_list|()
block|{
name|StringRef
name|Tag
init|=
name|Buffer
operator|->
name|getBuffer
argument_list|()
operator|.
name|slice
argument_list|(
name|Cursor
argument_list|,
name|Cursor
operator|+
literal|4
argument_list|)
decl_stmt|;
if|if
condition|(
name|Tag
operator|.
name|empty
argument_list|()
operator|||
name|Tag
index|[
literal|0
index|]
operator|!=
literal|'\0'
operator|||
name|Tag
index|[
literal|1
index|]
operator|!=
literal|'\0'
operator|||
name|Tag
index|[
literal|2
index|]
operator|!=
literal|'\x43'
operator|||
name|Tag
index|[
literal|3
index|]
operator|!=
literal|'\x01'
condition|)
block|{
return|return
name|false
return|;
block|}
name|Cursor
operator|+=
literal|4
expr_stmt|;
return|return
name|true
return|;
block|}
comment|/// readLineTag - If cursor points to a line tag then increment the
comment|/// cursor and return true otherwise return false.
name|bool
name|readLineTag
parameter_list|()
block|{
name|StringRef
name|Tag
init|=
name|Buffer
operator|->
name|getBuffer
argument_list|()
operator|.
name|slice
argument_list|(
name|Cursor
argument_list|,
name|Cursor
operator|+
literal|4
argument_list|)
decl_stmt|;
if|if
condition|(
name|Tag
operator|.
name|empty
argument_list|()
operator|||
name|Tag
index|[
literal|0
index|]
operator|!=
literal|'\0'
operator|||
name|Tag
index|[
literal|1
index|]
operator|!=
literal|'\0'
operator|||
name|Tag
index|[
literal|2
index|]
operator|!=
literal|'\x45'
operator|||
name|Tag
index|[
literal|3
index|]
operator|!=
literal|'\x01'
condition|)
block|{
return|return
name|false
return|;
block|}
name|Cursor
operator|+=
literal|4
expr_stmt|;
return|return
name|true
return|;
block|}
comment|/// readArcTag - If cursor points to an gcda arc tag then increment the
comment|/// cursor and return true otherwise return false.
name|bool
name|readArcTag
parameter_list|()
block|{
name|StringRef
name|Tag
init|=
name|Buffer
operator|->
name|getBuffer
argument_list|()
operator|.
name|slice
argument_list|(
name|Cursor
argument_list|,
name|Cursor
operator|+
literal|4
argument_list|)
decl_stmt|;
if|if
condition|(
name|Tag
operator|.
name|empty
argument_list|()
operator|||
name|Tag
index|[
literal|0
index|]
operator|!=
literal|'\0'
operator|||
name|Tag
index|[
literal|1
index|]
operator|!=
literal|'\0'
operator|||
name|Tag
index|[
literal|2
index|]
operator|!=
literal|'\xa1'
operator|||
name|Tag
index|[
literal|3
index|]
operator|!=
literal|'\1'
condition|)
block|{
return|return
name|false
return|;
block|}
name|Cursor
operator|+=
literal|4
expr_stmt|;
return|return
name|true
return|;
block|}
comment|/// readObjectTag - If cursor points to an object summary tag then increment
comment|/// the cursor and return true otherwise return false.
name|bool
name|readObjectTag
parameter_list|()
block|{
name|StringRef
name|Tag
init|=
name|Buffer
operator|->
name|getBuffer
argument_list|()
operator|.
name|slice
argument_list|(
name|Cursor
argument_list|,
name|Cursor
operator|+
literal|4
argument_list|)
decl_stmt|;
if|if
condition|(
name|Tag
operator|.
name|empty
argument_list|()
operator|||
name|Tag
index|[
literal|0
index|]
operator|!=
literal|'\0'
operator|||
name|Tag
index|[
literal|1
index|]
operator|!=
literal|'\0'
operator|||
name|Tag
index|[
literal|2
index|]
operator|!=
literal|'\0'
operator|||
name|Tag
index|[
literal|3
index|]
operator|!=
literal|'\xa1'
condition|)
block|{
return|return
name|false
return|;
block|}
name|Cursor
operator|+=
literal|4
expr_stmt|;
return|return
name|true
return|;
block|}
comment|/// readProgramTag - If cursor points to a program summary tag then increment
comment|/// the cursor and return true otherwise return false.
name|bool
name|readProgramTag
parameter_list|()
block|{
name|StringRef
name|Tag
init|=
name|Buffer
operator|->
name|getBuffer
argument_list|()
operator|.
name|slice
argument_list|(
name|Cursor
argument_list|,
name|Cursor
operator|+
literal|4
argument_list|)
decl_stmt|;
if|if
condition|(
name|Tag
operator|.
name|empty
argument_list|()
operator|||
name|Tag
index|[
literal|0
index|]
operator|!=
literal|'\0'
operator|||
name|Tag
index|[
literal|1
index|]
operator|!=
literal|'\0'
operator|||
name|Tag
index|[
literal|2
index|]
operator|!=
literal|'\0'
operator|||
name|Tag
index|[
literal|3
index|]
operator|!=
literal|'\xa3'
condition|)
block|{
return|return
name|false
return|;
block|}
name|Cursor
operator|+=
literal|4
expr_stmt|;
return|return
name|true
return|;
block|}
name|bool
name|readInt
parameter_list|(
name|uint32_t
modifier|&
name|Val
parameter_list|)
block|{
if|if
condition|(
name|Buffer
operator|->
name|getBuffer
argument_list|()
operator|.
name|size
argument_list|()
operator|<
name|Cursor
operator|+
literal|4
condition|)
block|{
name|errs
argument_list|()
operator|<<
literal|"Unexpected end of memory buffer: "
operator|<<
name|Cursor
operator|+
literal|4
operator|<<
literal|".\n"
expr_stmt|;
return|return
name|false
return|;
block|}
name|StringRef
name|Str
init|=
name|Buffer
operator|->
name|getBuffer
argument_list|()
operator|.
name|slice
argument_list|(
name|Cursor
argument_list|,
name|Cursor
operator|+
literal|4
argument_list|)
decl_stmt|;
name|Cursor
operator|+=
literal|4
expr_stmt|;
name|Val
operator|=
operator|*
operator|(
specifier|const
name|uint32_t
operator|*
operator|)
operator|(
name|Str
operator|.
name|data
argument_list|()
operator|)
expr_stmt|;
return|return
name|true
return|;
block|}
name|bool
name|readInt64
parameter_list|(
name|uint64_t
modifier|&
name|Val
parameter_list|)
block|{
name|uint32_t
name|Lo
decl_stmt|,
name|Hi
decl_stmt|;
if|if
condition|(
operator|!
name|readInt
argument_list|(
name|Lo
argument_list|)
operator|||
operator|!
name|readInt
argument_list|(
name|Hi
argument_list|)
condition|)
return|return
name|false
return|;
name|Val
operator|=
operator|(
operator|(
name|uint64_t
operator|)
name|Hi
operator|<<
literal|32
operator|)
operator||
name|Lo
expr_stmt|;
return|return
name|true
return|;
block|}
name|bool
name|readString
parameter_list|(
name|StringRef
modifier|&
name|Str
parameter_list|)
block|{
name|uint32_t
name|Len
init|=
literal|0
decl_stmt|;
comment|// Keep reading until we find a non-zero length. This emulates gcov's
comment|// behaviour, which appears to do the same.
while|while
condition|(
name|Len
operator|==
literal|0
condition|)
if|if
condition|(
operator|!
name|readInt
argument_list|(
name|Len
argument_list|)
condition|)
return|return
name|false
return|;
name|Len
operator|*=
literal|4
expr_stmt|;
if|if
condition|(
name|Buffer
operator|->
name|getBuffer
argument_list|()
operator|.
name|size
argument_list|()
operator|<
name|Cursor
operator|+
name|Len
condition|)
block|{
name|errs
argument_list|()
operator|<<
literal|"Unexpected end of memory buffer: "
operator|<<
name|Cursor
operator|+
name|Len
operator|<<
literal|".\n"
expr_stmt|;
return|return
name|false
return|;
block|}
name|Str
operator|=
name|Buffer
operator|->
name|getBuffer
argument_list|()
operator|.
name|slice
argument_list|(
name|Cursor
argument_list|,
name|Cursor
operator|+
name|Len
argument_list|)
operator|.
name|split
argument_list|(
literal|'\0'
argument_list|)
operator|.
name|first
expr_stmt|;
name|Cursor
operator|+=
name|Len
expr_stmt|;
return|return
name|true
return|;
block|}
name|uint64_t
name|getCursor
argument_list|()
specifier|const
block|{
return|return
name|Cursor
return|;
block|}
name|void
name|advanceCursor
parameter_list|(
name|uint32_t
name|n
parameter_list|)
block|{
name|Cursor
operator|+=
name|n
operator|*
literal|4
expr_stmt|;
block|}
name|private
label|:
name|MemoryBuffer
modifier|*
name|Buffer
decl_stmt|;
name|uint64_t
name|Cursor
init|=
literal|0
decl_stmt|;
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_comment
comment|/// GCOVFile - Collects coverage information for one pair of coverage file
end_comment

begin_comment
comment|/// (.gcno and .gcda).
end_comment

begin_decl_stmt
name|class
name|GCOVFile
block|{
name|public
label|:
name|GCOVFile
argument_list|()
operator|=
expr|default
expr_stmt|;
name|bool
name|readGCNO
parameter_list|(
name|GCOVBuffer
modifier|&
name|Buffer
parameter_list|)
function_decl|;
name|bool
name|readGCDA
parameter_list|(
name|GCOVBuffer
modifier|&
name|Buffer
parameter_list|)
function_decl|;
name|uint32_t
name|getChecksum
argument_list|()
specifier|const
block|{
return|return
name|Checksum
return|;
block|}
name|void
name|print
argument_list|(
name|raw_ostream
operator|&
name|OS
argument_list|)
decl|const
decl_stmt|;
name|void
name|dump
argument_list|()
specifier|const
expr_stmt|;
name|void
name|collectLineCounts
parameter_list|(
name|FileInfo
modifier|&
name|FI
parameter_list|)
function_decl|;
name|private
label|:
name|bool
name|GCNOInitialized
init|=
name|false
decl_stmt|;
name|GCOV
operator|::
name|GCOVVersion
name|Version
expr_stmt|;
name|uint32_t
name|Checksum
init|=
literal|0
decl_stmt|;
name|SmallVector
operator|<
name|std
operator|::
name|unique_ptr
operator|<
name|GCOVFunction
operator|>
operator|,
literal|16
operator|>
name|Functions
expr_stmt|;
name|uint32_t
name|RunCount
init|=
literal|0
decl_stmt|;
name|uint32_t
name|ProgramCount
init|=
literal|0
decl_stmt|;
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_comment
comment|/// GCOVEdge - Collects edge information.
end_comment

begin_struct
struct|struct
name|GCOVEdge
block|{
name|GCOVEdge
argument_list|(
name|GCOVBlock
operator|&
name|S
argument_list|,
name|GCOVBlock
operator|&
name|D
argument_list|)
operator|:
name|Src
argument_list|(
name|S
argument_list|)
operator|,
name|Dst
argument_list|(
argument|D
argument_list|)
block|{}
name|GCOVBlock
operator|&
name|Src
expr_stmt|;
name|GCOVBlock
modifier|&
name|Dst
decl_stmt|;
name|uint64_t
name|Count
init|=
literal|0
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/// GCOVFunction - Collects function information.
end_comment

begin_decl_stmt
name|class
name|GCOVFunction
block|{
name|public
label|:
typedef|typedef
name|pointee_iterator
operator|<
name|SmallVectorImpl
operator|<
name|std
operator|::
name|unique_ptr
operator|<
name|GCOVBlock
operator|>>
operator|::
name|const_iterator
operator|>
name|BlockIterator
expr_stmt|;
name|GCOVFunction
argument_list|(
name|GCOVFile
operator|&
name|P
argument_list|)
operator|:
name|Parent
argument_list|(
argument|P
argument_list|)
block|{}
name|bool
name|readGCNO
argument_list|(
argument|GCOVBuffer&Buffer
argument_list|,
argument|GCOV::GCOVVersion Version
argument_list|)
expr_stmt|;
name|bool
name|readGCDA
argument_list|(
name|GCOVBuffer
operator|&
name|Buffer
argument_list|,
name|GCOV
operator|::
name|GCOVVersion
name|Version
argument_list|)
decl_stmt|;
name|StringRef
name|getName
argument_list|()
specifier|const
block|{
return|return
name|Name
return|;
block|}
name|StringRef
name|getFilename
argument_list|()
specifier|const
block|{
return|return
name|Filename
return|;
block|}
name|size_t
name|getNumBlocks
argument_list|()
specifier|const
block|{
return|return
name|Blocks
operator|.
name|size
argument_list|()
return|;
block|}
name|uint64_t
name|getEntryCount
argument_list|()
specifier|const
expr_stmt|;
name|uint64_t
name|getExitCount
argument_list|()
specifier|const
expr_stmt|;
name|BlockIterator
name|block_begin
argument_list|()
specifier|const
block|{
return|return
name|Blocks
operator|.
name|begin
argument_list|()
return|;
block|}
name|BlockIterator
name|block_end
argument_list|()
specifier|const
block|{
return|return
name|Blocks
operator|.
name|end
argument_list|()
return|;
block|}
name|iterator_range
operator|<
name|BlockIterator
operator|>
name|blocks
argument_list|()
specifier|const
block|{
return|return
name|make_range
argument_list|(
name|block_begin
argument_list|()
argument_list|,
name|block_end
argument_list|()
argument_list|)
return|;
block|}
name|void
name|print
argument_list|(
name|raw_ostream
operator|&
name|OS
argument_list|)
decl|const
decl_stmt|;
name|void
name|dump
argument_list|()
specifier|const
expr_stmt|;
name|void
name|collectLineCounts
parameter_list|(
name|FileInfo
modifier|&
name|FI
parameter_list|)
function_decl|;
name|private
label|:
name|GCOVFile
modifier|&
name|Parent
decl_stmt|;
name|uint32_t
name|Ident
init|=
literal|0
decl_stmt|;
name|uint32_t
name|Checksum
decl_stmt|;
name|uint32_t
name|LineNumber
init|=
literal|0
decl_stmt|;
name|StringRef
name|Name
decl_stmt|;
name|StringRef
name|Filename
decl_stmt|;
name|SmallVector
operator|<
name|std
operator|::
name|unique_ptr
operator|<
name|GCOVBlock
operator|>
operator|,
literal|16
operator|>
name|Blocks
expr_stmt|;
name|SmallVector
operator|<
name|std
operator|::
name|unique_ptr
operator|<
name|GCOVEdge
operator|>
operator|,
literal|16
operator|>
name|Edges
expr_stmt|;
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_comment
comment|/// GCOVBlock - Collects block information.
end_comment

begin_decl_stmt
name|class
name|GCOVBlock
block|{
struct|struct
name|EdgeWeight
block|{
name|EdgeWeight
argument_list|(
name|GCOVBlock
operator|*
name|D
argument_list|)
operator|:
name|Dst
argument_list|(
argument|D
argument_list|)
block|{}
name|GCOVBlock
operator|*
name|Dst
expr_stmt|;
name|uint64_t
name|Count
init|=
literal|0
decl_stmt|;
block|}
struct|;
struct|struct
name|SortDstEdgesFunctor
block|{
name|bool
name|operator
argument_list|()
operator|(
specifier|const
name|GCOVEdge
operator|*
name|E1
operator|,
specifier|const
name|GCOVEdge
operator|*
name|E2
operator|)
block|{
return|return
name|E1
operator|->
name|Dst
operator|.
name|Number
operator|<
name|E2
operator|->
name|Dst
operator|.
name|Number
return|;
block|}
block|}
struct|;
name|public
label|:
typedef|typedef
name|SmallVectorImpl
operator|<
name|GCOVEdge
operator|*
operator|>
operator|::
name|const_iterator
name|EdgeIterator
expr_stmt|;
name|GCOVBlock
argument_list|(
argument|GCOVFunction&P
argument_list|,
argument|uint32_t N
argument_list|)
block|:
name|Parent
argument_list|(
name|P
argument_list|)
operator|,
name|Number
argument_list|(
argument|N
argument_list|)
block|{}
operator|~
name|GCOVBlock
argument_list|()
expr_stmt|;
specifier|const
name|GCOVFunction
operator|&
name|getParent
argument_list|()
specifier|const
block|{
return|return
name|Parent
return|;
block|}
name|void
name|addLine
parameter_list|(
name|uint32_t
name|N
parameter_list|)
block|{
name|Lines
operator|.
name|push_back
argument_list|(
name|N
argument_list|)
expr_stmt|;
block|}
name|uint32_t
name|getLastLine
argument_list|()
specifier|const
block|{
return|return
name|Lines
operator|.
name|back
argument_list|()
return|;
block|}
name|void
name|addCount
parameter_list|(
name|size_t
name|DstEdgeNo
parameter_list|,
name|uint64_t
name|N
parameter_list|)
function_decl|;
name|uint64_t
name|getCount
argument_list|()
specifier|const
block|{
return|return
name|Counter
return|;
block|}
name|void
name|addSrcEdge
parameter_list|(
name|GCOVEdge
modifier|*
name|Edge
parameter_list|)
block|{
name|assert
argument_list|(
operator|&
name|Edge
operator|->
name|Dst
operator|==
name|this
argument_list|)
expr_stmt|;
comment|// up to caller to ensure edge is valid
name|SrcEdges
operator|.
name|push_back
argument_list|(
name|Edge
argument_list|)
expr_stmt|;
block|}
name|void
name|addDstEdge
parameter_list|(
name|GCOVEdge
modifier|*
name|Edge
parameter_list|)
block|{
name|assert
argument_list|(
operator|&
name|Edge
operator|->
name|Src
operator|==
name|this
argument_list|)
expr_stmt|;
comment|// up to caller to ensure edge is valid
comment|// Check if adding this edge causes list to become unsorted.
if|if
condition|(
name|DstEdges
operator|.
name|size
argument_list|()
operator|&&
name|DstEdges
operator|.
name|back
argument_list|()
operator|->
name|Dst
operator|.
name|Number
operator|>
name|Edge
operator|->
name|Dst
operator|.
name|Number
condition|)
name|DstEdgesAreSorted
operator|=
name|false
expr_stmt|;
name|DstEdges
operator|.
name|push_back
argument_list|(
name|Edge
argument_list|)
expr_stmt|;
block|}
name|size_t
name|getNumSrcEdges
argument_list|()
specifier|const
block|{
return|return
name|SrcEdges
operator|.
name|size
argument_list|()
return|;
block|}
name|size_t
name|getNumDstEdges
argument_list|()
specifier|const
block|{
return|return
name|DstEdges
operator|.
name|size
argument_list|()
return|;
block|}
name|void
name|sortDstEdges
parameter_list|()
function_decl|;
name|EdgeIterator
name|src_begin
argument_list|()
specifier|const
block|{
return|return
name|SrcEdges
operator|.
name|begin
argument_list|()
return|;
block|}
name|EdgeIterator
name|src_end
argument_list|()
specifier|const
block|{
return|return
name|SrcEdges
operator|.
name|end
argument_list|()
return|;
block|}
name|iterator_range
operator|<
name|EdgeIterator
operator|>
name|srcs
argument_list|()
specifier|const
block|{
return|return
name|make_range
argument_list|(
name|src_begin
argument_list|()
argument_list|,
name|src_end
argument_list|()
argument_list|)
return|;
block|}
name|EdgeIterator
name|dst_begin
argument_list|()
specifier|const
block|{
return|return
name|DstEdges
operator|.
name|begin
argument_list|()
return|;
block|}
name|EdgeIterator
name|dst_end
argument_list|()
specifier|const
block|{
return|return
name|DstEdges
operator|.
name|end
argument_list|()
return|;
block|}
name|iterator_range
operator|<
name|EdgeIterator
operator|>
name|dsts
argument_list|()
specifier|const
block|{
return|return
name|make_range
argument_list|(
name|dst_begin
argument_list|()
argument_list|,
name|dst_end
argument_list|()
argument_list|)
return|;
block|}
name|void
name|print
argument_list|(
name|raw_ostream
operator|&
name|OS
argument_list|)
decl|const
decl_stmt|;
name|void
name|dump
argument_list|()
specifier|const
expr_stmt|;
name|void
name|collectLineCounts
parameter_list|(
name|FileInfo
modifier|&
name|FI
parameter_list|)
function_decl|;
name|private
label|:
name|GCOVFunction
modifier|&
name|Parent
decl_stmt|;
name|uint32_t
name|Number
decl_stmt|;
name|uint64_t
name|Counter
init|=
literal|0
decl_stmt|;
name|bool
name|DstEdgesAreSorted
init|=
name|true
decl_stmt|;
name|SmallVector
operator|<
name|GCOVEdge
operator|*
operator|,
literal|16
operator|>
name|SrcEdges
expr_stmt|;
name|SmallVector
operator|<
name|GCOVEdge
operator|*
operator|,
literal|16
operator|>
name|DstEdges
expr_stmt|;
name|SmallVector
operator|<
name|uint32_t
operator|,
literal|16
operator|>
name|Lines
expr_stmt|;
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_decl_stmt
name|class
name|FileInfo
block|{
comment|// It is unlikely--but possible--for multiple functions to be on the same
comment|// line.
comment|// Therefore this typedef allows LineData.Functions to store multiple
comment|// functions
comment|// per instance. This is rare, however, so optimize for the common case.
typedef|typedef
name|SmallVector
operator|<
specifier|const
name|GCOVFunction
operator|*
operator|,
literal|1
operator|>
name|FunctionVector
expr_stmt|;
typedef|typedef
name|DenseMap
operator|<
name|uint32_t
operator|,
name|FunctionVector
operator|>
name|FunctionLines
expr_stmt|;
typedef|typedef
name|SmallVector
operator|<
specifier|const
name|GCOVBlock
operator|*
operator|,
literal|4
operator|>
name|BlockVector
expr_stmt|;
typedef|typedef
name|DenseMap
operator|<
name|uint32_t
operator|,
name|BlockVector
operator|>
name|BlockLines
expr_stmt|;
struct|struct
name|LineData
block|{
name|LineData
argument_list|()
operator|=
expr|default
expr_stmt|;
name|BlockLines
name|Blocks
decl_stmt|;
name|FunctionLines
name|Functions
decl_stmt|;
name|uint32_t
name|LastLine
init|=
literal|0
decl_stmt|;
block|}
struct|;
struct|struct
name|GCOVCoverage
block|{
name|GCOVCoverage
argument_list|(
argument|StringRef Name
argument_list|)
block|:
name|Name
argument_list|(
argument|Name
argument_list|)
block|{}
name|StringRef
name|Name
decl_stmt|;
name|uint32_t
name|LogicalLines
init|=
literal|0
decl_stmt|;
name|uint32_t
name|LinesExec
init|=
literal|0
decl_stmt|;
name|uint32_t
name|Branches
init|=
literal|0
decl_stmt|;
name|uint32_t
name|BranchesExec
init|=
literal|0
decl_stmt|;
name|uint32_t
name|BranchesTaken
init|=
literal|0
decl_stmt|;
block|}
struct|;
name|public
label|:
name|FileInfo
argument_list|(
specifier|const
name|GCOV
operator|::
name|Options
operator|&
name|Options
argument_list|)
operator|:
name|Options
argument_list|(
argument|Options
argument_list|)
block|{}
name|void
name|addBlockLine
argument_list|(
argument|StringRef Filename
argument_list|,
argument|uint32_t Line
argument_list|,
argument|const GCOVBlock *Block
argument_list|)
block|{
if|if
condition|(
name|Line
operator|>
name|LineInfo
index|[
name|Filename
index|]
operator|.
name|LastLine
condition|)
name|LineInfo
index|[
name|Filename
index|]
operator|.
name|LastLine
operator|=
name|Line
expr_stmt|;
name|LineInfo
index|[
name|Filename
index|]
operator|.
name|Blocks
index|[
name|Line
operator|-
literal|1
index|]
operator|.
name|push_back
argument_list|(
name|Block
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_function
name|void
name|addFunctionLine
parameter_list|(
name|StringRef
name|Filename
parameter_list|,
name|uint32_t
name|Line
parameter_list|,
specifier|const
name|GCOVFunction
modifier|*
name|Function
parameter_list|)
block|{
if|if
condition|(
name|Line
operator|>
name|LineInfo
index|[
name|Filename
index|]
operator|.
name|LastLine
condition|)
name|LineInfo
index|[
name|Filename
index|]
operator|.
name|LastLine
operator|=
name|Line
expr_stmt|;
name|LineInfo
index|[
name|Filename
index|]
operator|.
name|Functions
index|[
name|Line
operator|-
literal|1
index|]
operator|.
name|push_back
argument_list|(
name|Function
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|setRunCount
parameter_list|(
name|uint32_t
name|Runs
parameter_list|)
block|{
name|RunCount
operator|=
name|Runs
expr_stmt|;
block|}
end_function

begin_function
name|void
name|setProgramCount
parameter_list|(
name|uint32_t
name|Programs
parameter_list|)
block|{
name|ProgramCount
operator|=
name|Programs
expr_stmt|;
block|}
end_function

begin_function_decl
name|void
name|print
parameter_list|(
name|raw_ostream
modifier|&
name|OS
parameter_list|,
name|StringRef
name|MainFilename
parameter_list|,
name|StringRef
name|GCNOFile
parameter_list|,
name|StringRef
name|GCDAFile
parameter_list|)
function_decl|;
end_function_decl

begin_label
name|private
label|:
end_label

begin_expr_stmt
name|std
operator|::
name|string
name|getCoveragePath
argument_list|(
argument|StringRef Filename
argument_list|,
argument|StringRef MainFilename
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|std
operator|::
name|unique_ptr
operator|<
name|raw_ostream
operator|>
name|openCoveragePath
argument_list|(
argument|StringRef CoveragePath
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|void
name|printFunctionSummary
argument_list|(
name|raw_ostream
operator|&
name|OS
argument_list|,
specifier|const
name|FunctionVector
operator|&
name|Funcs
argument_list|)
decl|const
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|printBlockInfo
argument_list|(
name|raw_ostream
operator|&
name|OS
argument_list|,
specifier|const
name|GCOVBlock
operator|&
name|Block
argument_list|,
name|uint32_t
name|LineIndex
argument_list|,
name|uint32_t
operator|&
name|BlockNo
argument_list|)
decl|const
decl_stmt|;
end_decl_stmt

begin_function_decl
name|void
name|printBranchInfo
parameter_list|(
name|raw_ostream
modifier|&
name|OS
parameter_list|,
specifier|const
name|GCOVBlock
modifier|&
name|Block
parameter_list|,
name|GCOVCoverage
modifier|&
name|Coverage
parameter_list|,
name|uint32_t
modifier|&
name|EdgeNo
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
name|void
name|printUncondBranchInfo
argument_list|(
name|raw_ostream
operator|&
name|OS
argument_list|,
name|uint32_t
operator|&
name|EdgeNo
argument_list|,
name|uint64_t
name|Count
argument_list|)
decl|const
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|printCoverage
argument_list|(
name|raw_ostream
operator|&
name|OS
argument_list|,
specifier|const
name|GCOVCoverage
operator|&
name|Coverage
argument_list|)
decl|const
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|printFuncCoverage
argument_list|(
name|raw_ostream
operator|&
name|OS
argument_list|)
decl|const
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|printFileCoverage
argument_list|(
name|raw_ostream
operator|&
name|OS
argument_list|)
decl|const
decl_stmt|;
end_decl_stmt

begin_expr_stmt
specifier|const
name|GCOV
operator|::
name|Options
operator|&
name|Options
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|StringMap
operator|<
name|LineData
operator|>
name|LineInfo
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|uint32_t
name|RunCount
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|uint32_t
name|ProgramCount
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_typedef
typedef|typedef
name|SmallVector
operator|<
name|std
operator|::
name|pair
operator|<
name|std
operator|::
name|string
operator|,
name|GCOVCoverage
operator|>
operator|,
literal|4
operator|>
name|FileCoverageList
expr_stmt|;
end_typedef

begin_typedef
typedef|typedef
name|MapVector
operator|<
specifier|const
name|GCOVFunction
operator|*
operator|,
name|GCOVCoverage
operator|>
name|FuncCoverageMap
expr_stmt|;
end_typedef

begin_decl_stmt
name|FileCoverageList
name|FileCoverages
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FuncCoverageMap
name|FuncCoverages
decl_stmt|;
end_decl_stmt

begin_comment
unit|};  }
comment|// end namespace llvm
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|// LLVM_SUPPORT_GCOV_H
end_comment

end_unit

