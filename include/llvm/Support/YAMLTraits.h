begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===- llvm/Support/YAMLTraits.h --------------------------------*- C++ -*-===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                             The LLVM Linker
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LLVM_SUPPORT_YAMLTRAITS_H
end_ifndef

begin_define
define|#
directive|define
name|LLVM_SUPPORT_YAMLTRAITS_H
end_define

begin_include
include|#
directive|include
file|"llvm/ADT/Optional.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/SmallVector.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/StringMap.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/StringRef.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/Twine.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/AlignOf.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/Allocator.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/Endian.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/Regex.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/SourceMgr.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/YAMLParser.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/raw_ostream.h"
end_include

begin_include
include|#
directive|include
file|<cassert>
end_include

begin_include
include|#
directive|include
file|<cctype>
end_include

begin_include
include|#
directive|include
file|<cstddef>
end_include

begin_include
include|#
directive|include
file|<cstdint>
end_include

begin_include
include|#
directive|include
file|<memory>
end_include

begin_include
include|#
directive|include
file|<new>
end_include

begin_include
include|#
directive|include
file|<string>
end_include

begin_include
include|#
directive|include
file|<system_error>
end_include

begin_include
include|#
directive|include
file|<type_traits>
end_include

begin_include
include|#
directive|include
file|<vector>
end_include

begin_decl_stmt
name|namespace
name|llvm
block|{
name|namespace
name|yaml
block|{
struct|struct
name|EmptyContext
block|{}
struct|;
comment|/// This class should be specialized by any type that needs to be converted
comment|/// to/from a YAML mapping.  For example:
comment|///
comment|///     struct MappingTraits<MyStruct> {
comment|///       static void mapping(IO&io, MyStruct&s) {
comment|///         io.mapRequired("name", s.name);
comment|///         io.mapRequired("size", s.size);
comment|///         io.mapOptional("age",  s.age);
comment|///       }
comment|///     };
name|template
operator|<
name|class
name|T
operator|>
expr|struct
name|MappingTraits
block|{
comment|// Must provide:
comment|// static void mapping(IO&io, T&fields);
comment|// Optionally may provide:
comment|// static StringRef validate(IO&io, T&fields);
comment|//
comment|// The optional flow flag will cause generated YAML to use a flow mapping
comment|// (e.g. { a: 0, b: 1 }):
comment|// static const bool flow = true;
block|}
expr_stmt|;
comment|/// This class is similar to MappingTraits<T> but allows you to pass in
comment|/// additional context for each map operation.  For example:
comment|///
comment|///     struct MappingContextTraits<MyStruct, MyContext> {
comment|///       static void mapping(IO&io, MyStruct&s, MyContext&c) {
comment|///         io.mapRequired("name", s.name);
comment|///         io.mapRequired("size", s.size);
comment|///         io.mapOptional("age",  s.age);
comment|///         ++c.TimesMapped;
comment|///       }
comment|///     };
name|template
operator|<
name|class
name|T
operator|,
name|class
name|Context
operator|>
expr|struct
name|MappingContextTraits
block|{
comment|// Must provide:
comment|// static void mapping(IO&io, T&fields, Context&Ctx);
comment|// Optionally may provide:
comment|// static StringRef validate(IO&io, T&fields, Context&Ctx);
comment|//
comment|// The optional flow flag will cause generated YAML to use a flow mapping
comment|// (e.g. { a: 0, b: 1 }):
comment|// static const bool flow = true;
block|}
expr_stmt|;
comment|/// This class should be specialized by any integral type that converts
comment|/// to/from a YAML scalar where there is a one-to-one mapping between
comment|/// in-memory values and a string in YAML.  For example:
comment|///
comment|///     struct ScalarEnumerationTraits<Colors> {
comment|///         static void enumeration(IO&io, Colors&value) {
comment|///           io.enumCase(value, "red",   cRed);
comment|///           io.enumCase(value, "blue",  cBlue);
comment|///           io.enumCase(value, "green", cGreen);
comment|///         }
comment|///       };
name|template
operator|<
name|typename
name|T
operator|>
expr|struct
name|ScalarEnumerationTraits
block|{
comment|// Must provide:
comment|// static void enumeration(IO&io, T&value);
block|}
expr_stmt|;
comment|/// This class should be specialized by any integer type that is a union
comment|/// of bit values and the YAML representation is a flow sequence of
comment|/// strings.  For example:
comment|///
comment|///      struct ScalarBitSetTraits<MyFlags> {
comment|///        static void bitset(IO&io, MyFlags&value) {
comment|///          io.bitSetCase(value, "big",   flagBig);
comment|///          io.bitSetCase(value, "flat",  flagFlat);
comment|///          io.bitSetCase(value, "round", flagRound);
comment|///        }
comment|///      };
name|template
operator|<
name|typename
name|T
operator|>
expr|struct
name|ScalarBitSetTraits
block|{
comment|// Must provide:
comment|// static void bitset(IO&io, T&value);
block|}
expr_stmt|;
comment|/// This class should be specialized by type that requires custom conversion
comment|/// to/from a yaml scalar.  For example:
comment|///
comment|///    template<>
comment|///    struct ScalarTraits<MyType> {
comment|///      static void output(const MyType&val, void*, llvm::raw_ostream&out) {
comment|///        // stream out custom formatting
comment|///        out<< llvm::format("%x", val);
comment|///      }
comment|///      static StringRef input(StringRef scalar, void*, MyType&value) {
comment|///        // parse scalar and set `value`
comment|///        // return empty string on success, or error string
comment|///        return StringRef();
comment|///      }
comment|///      static bool mustQuote(StringRef) { return true; }
comment|///    };
name|template
operator|<
name|typename
name|T
operator|>
expr|struct
name|ScalarTraits
block|{
comment|// Must provide:
comment|//
comment|// Function to write the value as a string:
comment|//static void output(const T&value, void *ctxt, llvm::raw_ostream&out);
comment|//
comment|// Function to convert a string to a value.  Returns the empty
comment|// StringRef on success or an error string if string is malformed:
comment|//static StringRef input(StringRef scalar, void *ctxt, T&value);
comment|//
comment|// Function to determine if the value should be quoted.
comment|//static bool mustQuote(StringRef);
block|}
expr_stmt|;
comment|/// This class should be specialized by type that requires custom conversion
comment|/// to/from a YAML literal block scalar. For example:
comment|///
comment|///    template<>
comment|///    struct BlockScalarTraits<MyType> {
comment|///      static void output(const MyType&Value, void*, llvm::raw_ostream&Out)
comment|///      {
comment|///        // stream out custom formatting
comment|///        Out<< Val;
comment|///      }
comment|///      static StringRef input(StringRef Scalar, void*, MyType&Value) {
comment|///        // parse scalar and set `value`
comment|///        // return empty string on success, or error string
comment|///        return StringRef();
comment|///      }
comment|///    };
name|template
operator|<
name|typename
name|T
operator|>
expr|struct
name|BlockScalarTraits
block|{
comment|// Must provide:
comment|//
comment|// Function to write the value as a string:
comment|// static void output(const T&Value, void *ctx, llvm::raw_ostream&Out);
comment|//
comment|// Function to convert a string to a value.  Returns the empty
comment|// StringRef on success or an error string if string is malformed:
comment|// static StringRef input(StringRef Scalar, void *ctxt, T&Value);
block|}
expr_stmt|;
comment|/// This class should be specialized by any type that needs to be converted
comment|/// to/from a YAML sequence.  For example:
comment|///
comment|///    template<>
comment|///    struct SequenceTraits< std::vector<MyType>> {
comment|///      static size_t size(IO&io, std::vector<MyType>&seq) {
comment|///        return seq.size();
comment|///      }
comment|///      static MyType& element(IO&, std::vector<MyType>&seq, size_t index) {
comment|///        if ( index>= seq.size() )
comment|///          seq.resize(index+1);
comment|///        return seq[index];
comment|///      }
comment|///    };
name|template
operator|<
name|typename
name|T
operator|>
expr|struct
name|SequenceTraits
block|{
comment|// Must provide:
comment|// static size_t size(IO&io, T&seq);
comment|// static T::value_type& element(IO&io, T&seq, size_t index);
comment|//
comment|// The following is option and will cause generated YAML to use
comment|// a flow sequence (e.g. [a,b,c]).
comment|// static const bool flow = true;
block|}
expr_stmt|;
comment|/// This class should be specialized by any type that needs to be converted
comment|/// to/from a list of YAML documents.
name|template
operator|<
name|typename
name|T
operator|>
expr|struct
name|DocumentListTraits
block|{
comment|// Must provide:
comment|// static size_t size(IO&io, T&seq);
comment|// static T::value_type& element(IO&io, T&seq, size_t index);
block|}
expr_stmt|;
comment|/// This class should be specialized by any type that needs to be converted
comment|/// to/from a YAML mapping in the case where the names of the keys are not known
comment|/// in advance, e.g. a string map.
name|template
operator|<
name|typename
name|T
operator|>
expr|struct
name|CustomMappingTraits
block|{
comment|// static void inputOne(IO&io, StringRef key, T&elem);
comment|// static void output(IO&io, T&elem);
block|}
expr_stmt|;
comment|// Only used for better diagnostics of missing traits
name|template
operator|<
name|typename
name|T
operator|>
expr|struct
name|MissingTrait
expr_stmt|;
comment|// Test if ScalarEnumerationTraits<T> is defined on type T.
name|template
operator|<
name|class
name|T
operator|>
expr|struct
name|has_ScalarEnumerationTraits
block|{
typedef|typedef
name|void
function_decl|(
modifier|*
name|Signature_enumeration
function_decl|)
parameter_list|(
name|class
name|IO
modifier|&
parameter_list|,
name|T
modifier|&
parameter_list|)
function_decl|;
name|template
operator|<
name|typename
name|U
operator|>
specifier|static
name|char
name|test
argument_list|(
name|SameType
operator|<
name|Signature_enumeration
argument_list|,
operator|&
name|U
operator|::
name|enumeration
operator|>
operator|*
argument_list|)
expr_stmt|;
name|template
operator|<
name|typename
name|U
operator|>
specifier|static
name|double
name|test
argument_list|(
operator|...
argument_list|)
expr_stmt|;
name|public
label|:
specifier|static
name|bool
specifier|const
name|value
init|=
operator|(
sizeof|sizeof
argument_list|(
name|test
operator|<
name|ScalarEnumerationTraits
operator|<
name|T
operator|>>
operator|(
name|nullptr
operator|)
argument_list|)
operator|==
literal|1
operator|)
decl_stmt|;
block|}
empty_stmt|;
comment|// Test if ScalarBitSetTraits<T> is defined on type T.
name|template
operator|<
name|class
name|T
operator|>
expr|struct
name|has_ScalarBitSetTraits
block|{
typedef|typedef
name|void
function_decl|(
modifier|*
name|Signature_bitset
function_decl|)
parameter_list|(
name|class
name|IO
modifier|&
parameter_list|,
name|T
modifier|&
parameter_list|)
function_decl|;
name|template
operator|<
name|typename
name|U
operator|>
specifier|static
name|char
name|test
argument_list|(
name|SameType
operator|<
name|Signature_bitset
argument_list|,
operator|&
name|U
operator|::
name|bitset
operator|>
operator|*
argument_list|)
expr_stmt|;
name|template
operator|<
name|typename
name|U
operator|>
specifier|static
name|double
name|test
argument_list|(
operator|...
argument_list|)
expr_stmt|;
name|public
label|:
specifier|static
name|bool
specifier|const
name|value
init|=
operator|(
sizeof|sizeof
argument_list|(
name|test
operator|<
name|ScalarBitSetTraits
operator|<
name|T
operator|>>
operator|(
name|nullptr
operator|)
argument_list|)
operator|==
literal|1
operator|)
decl_stmt|;
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_comment
comment|// Test if ScalarTraits<T> is defined on type T.
end_comment

begin_expr_stmt
name|template
operator|<
name|class
name|T
operator|>
expr|struct
name|has_ScalarTraits
block|{
typedef|typedef
name|StringRef
function_decl|(
modifier|*
name|Signature_input
function_decl|)
parameter_list|(
name|StringRef
parameter_list|,
name|void
modifier|*
parameter_list|,
name|T
modifier|&
parameter_list|)
function_decl|;
end_expr_stmt

begin_typedef
typedef|typedef
name|void
argument_list|(
operator|*
name|Signature_output
argument_list|)
argument_list|(
specifier|const
name|T
operator|&
argument_list|,
name|void
operator|*
argument_list|,
name|llvm
operator|::
name|raw_ostream
operator|&
argument_list|)
expr_stmt|;
end_typedef

begin_typedef
typedef|typedef
name|bool
function_decl|(
modifier|*
name|Signature_mustQuote
function_decl|)
parameter_list|(
name|StringRef
parameter_list|)
function_decl|;
end_typedef

begin_expr_stmt
name|template
operator|<
name|typename
name|U
operator|>
specifier|static
name|char
name|test
argument_list|(
name|SameType
operator|<
name|Signature_input
argument_list|,
operator|&
name|U
operator|::
name|input
operator|>
operator|*
argument_list|,
name|SameType
operator|<
name|Signature_output
argument_list|,
operator|&
name|U
operator|::
name|output
operator|>
operator|*
argument_list|,
name|SameType
operator|<
name|Signature_mustQuote
argument_list|,
operator|&
name|U
operator|::
name|mustQuote
operator|>
operator|*
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|U
operator|>
specifier|static
name|double
name|test
argument_list|(
operator|...
argument_list|)
expr_stmt|;
end_expr_stmt

begin_label
name|public
label|:
end_label

begin_decl_stmt
specifier|static
name|bool
specifier|const
name|value
init|=
operator|(
sizeof|sizeof
argument_list|(
name|test
operator|<
name|ScalarTraits
operator|<
name|T
operator|>>
operator|(
name|nullptr
expr|,
name|nullptr
expr|,
name|nullptr
operator|)
argument_list|)
operator|==
literal|1
operator|)
decl_stmt|;
end_decl_stmt

begin_comment
unit|};
comment|// Test if BlockScalarTraits<T> is defined on type T.
end_comment

begin_expr_stmt
name|template
operator|<
name|class
name|T
operator|>
expr|struct
name|has_BlockScalarTraits
block|{
typedef|typedef
name|StringRef
function_decl|(
modifier|*
name|Signature_input
function_decl|)
parameter_list|(
name|StringRef
parameter_list|,
name|void
modifier|*
parameter_list|,
name|T
modifier|&
parameter_list|)
function_decl|;
end_expr_stmt

begin_typedef
typedef|typedef
name|void
argument_list|(
operator|*
name|Signature_output
argument_list|)
argument_list|(
specifier|const
name|T
operator|&
argument_list|,
name|void
operator|*
argument_list|,
name|llvm
operator|::
name|raw_ostream
operator|&
argument_list|)
expr_stmt|;
end_typedef

begin_expr_stmt
name|template
operator|<
name|typename
name|U
operator|>
specifier|static
name|char
name|test
argument_list|(
name|SameType
operator|<
name|Signature_input
argument_list|,
operator|&
name|U
operator|::
name|input
operator|>
operator|*
argument_list|,
name|SameType
operator|<
name|Signature_output
argument_list|,
operator|&
name|U
operator|::
name|output
operator|>
operator|*
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|U
operator|>
specifier|static
name|double
name|test
argument_list|(
operator|...
argument_list|)
expr_stmt|;
end_expr_stmt

begin_label
name|public
label|:
end_label

begin_decl_stmt
specifier|static
name|bool
specifier|const
name|value
init|=
operator|(
sizeof|sizeof
argument_list|(
name|test
operator|<
name|BlockScalarTraits
operator|<
name|T
operator|>>
operator|(
name|nullptr
expr|,
name|nullptr
operator|)
argument_list|)
operator|==
literal|1
operator|)
decl_stmt|;
end_decl_stmt

begin_comment
unit|};
comment|// Test if MappingContextTraits<T> is defined on type T.
end_comment

begin_expr_stmt
name|template
operator|<
name|class
name|T
operator|,
name|class
name|Context
operator|>
expr|struct
name|has_MappingTraits
block|{
typedef|typedef
name|void
function_decl|(
modifier|*
name|Signature_mapping
function_decl|)
parameter_list|(
name|class
name|IO
modifier|&
parameter_list|,
name|T
modifier|&
parameter_list|,
name|Context
modifier|&
parameter_list|)
function_decl|;
name|template
operator|<
name|typename
name|U
operator|>
specifier|static
name|char
name|test
argument_list|(
name|SameType
operator|<
name|Signature_mapping
argument_list|,
operator|&
name|U
operator|::
name|mapping
operator|>
operator|*
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|U
operator|>
specifier|static
name|double
name|test
argument_list|(
operator|...
argument_list|)
expr_stmt|;
end_expr_stmt

begin_label
name|public
label|:
end_label

begin_decl_stmt
specifier|static
name|bool
specifier|const
name|value
init|=
operator|(
sizeof|sizeof
argument_list|(
name|test
operator|<
name|MappingContextTraits
operator|<
name|T
argument_list|,
name|Context
operator|>>
operator|(
name|nullptr
operator|)
argument_list|)
operator|==
literal|1
operator|)
decl_stmt|;
end_decl_stmt

begin_comment
unit|};
comment|// Test if MappingTraits<T> is defined on type T.
end_comment

begin_expr_stmt
name|template
operator|<
name|class
name|T
operator|>
expr|struct
name|has_MappingTraits
operator|<
name|T
operator|,
name|EmptyContext
operator|>
block|{
typedef|typedef
name|void
function_decl|(
modifier|*
name|Signature_mapping
function_decl|)
parameter_list|(
name|class
name|IO
modifier|&
parameter_list|,
name|T
modifier|&
parameter_list|)
function_decl|;
name|template
operator|<
name|typename
name|U
operator|>
specifier|static
name|char
name|test
argument_list|(
name|SameType
operator|<
name|Signature_mapping
argument_list|,
operator|&
name|U
operator|::
name|mapping
operator|>
operator|*
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|U
operator|>
specifier|static
name|double
name|test
argument_list|(
operator|...
argument_list|)
expr_stmt|;
end_expr_stmt

begin_label
name|public
label|:
end_label

begin_decl_stmt
specifier|static
name|bool
specifier|const
name|value
init|=
operator|(
sizeof|sizeof
argument_list|(
name|test
operator|<
name|MappingTraits
operator|<
name|T
operator|>>
operator|(
name|nullptr
operator|)
argument_list|)
operator|==
literal|1
operator|)
decl_stmt|;
end_decl_stmt

begin_comment
unit|};
comment|// Test if MappingContextTraits<T>::validate() is defined on type T.
end_comment

begin_expr_stmt
name|template
operator|<
name|class
name|T
operator|,
name|class
name|Context
operator|>
expr|struct
name|has_MappingValidateTraits
block|{
typedef|typedef
name|StringRef
function_decl|(
modifier|*
name|Signature_validate
function_decl|)
parameter_list|(
name|class
name|IO
modifier|&
parameter_list|,
name|T
modifier|&
parameter_list|,
name|Context
modifier|&
parameter_list|)
function_decl|;
name|template
operator|<
name|typename
name|U
operator|>
specifier|static
name|char
name|test
argument_list|(
name|SameType
operator|<
name|Signature_validate
argument_list|,
operator|&
name|U
operator|::
name|validate
operator|>
operator|*
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|U
operator|>
specifier|static
name|double
name|test
argument_list|(
operator|...
argument_list|)
expr_stmt|;
end_expr_stmt

begin_label
name|public
label|:
end_label

begin_decl_stmt
specifier|static
name|bool
specifier|const
name|value
init|=
operator|(
sizeof|sizeof
argument_list|(
name|test
operator|<
name|MappingContextTraits
operator|<
name|T
argument_list|,
name|Context
operator|>>
operator|(
name|nullptr
operator|)
argument_list|)
operator|==
literal|1
operator|)
decl_stmt|;
end_decl_stmt

begin_comment
unit|};
comment|// Test if MappingTraits<T>::validate() is defined on type T.
end_comment

begin_expr_stmt
name|template
operator|<
name|class
name|T
operator|>
expr|struct
name|has_MappingValidateTraits
operator|<
name|T
operator|,
name|EmptyContext
operator|>
block|{
typedef|typedef
name|StringRef
function_decl|(
modifier|*
name|Signature_validate
function_decl|)
parameter_list|(
name|class
name|IO
modifier|&
parameter_list|,
name|T
modifier|&
parameter_list|)
function_decl|;
name|template
operator|<
name|typename
name|U
operator|>
specifier|static
name|char
name|test
argument_list|(
name|SameType
operator|<
name|Signature_validate
argument_list|,
operator|&
name|U
operator|::
name|validate
operator|>
operator|*
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|U
operator|>
specifier|static
name|double
name|test
argument_list|(
operator|...
argument_list|)
expr_stmt|;
end_expr_stmt

begin_label
name|public
label|:
end_label

begin_decl_stmt
specifier|static
name|bool
specifier|const
name|value
init|=
operator|(
sizeof|sizeof
argument_list|(
name|test
operator|<
name|MappingTraits
operator|<
name|T
operator|>>
operator|(
name|nullptr
operator|)
argument_list|)
operator|==
literal|1
operator|)
decl_stmt|;
end_decl_stmt

begin_comment
unit|};
comment|// Test if SequenceTraits<T> is defined on type T.
end_comment

begin_expr_stmt
name|template
operator|<
name|class
name|T
operator|>
expr|struct
name|has_SequenceMethodTraits
block|{
typedef|typedef
name|size_t
function_decl|(
modifier|*
name|Signature_size
function_decl|)
parameter_list|(
name|class
name|IO
modifier|&
parameter_list|,
name|T
modifier|&
parameter_list|)
function_decl|;
name|template
operator|<
name|typename
name|U
operator|>
specifier|static
name|char
name|test
argument_list|(
name|SameType
operator|<
name|Signature_size
argument_list|,
operator|&
name|U
operator|::
name|size
operator|>
operator|*
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|U
operator|>
specifier|static
name|double
name|test
argument_list|(
operator|...
argument_list|)
expr_stmt|;
end_expr_stmt

begin_label
name|public
label|:
end_label

begin_decl_stmt
specifier|static
name|bool
specifier|const
name|value
init|=
operator|(
sizeof|sizeof
argument_list|(
name|test
operator|<
name|SequenceTraits
operator|<
name|T
operator|>>
operator|(
name|nullptr
operator|)
argument_list|)
operator|==
literal|1
operator|)
decl_stmt|;
end_decl_stmt

begin_comment
unit|};
comment|// Test if CustomMappingTraits<T> is defined on type T.
end_comment

begin_expr_stmt
name|template
operator|<
name|class
name|T
operator|>
expr|struct
name|has_CustomMappingTraits
block|{
typedef|typedef
name|void
function_decl|(
modifier|*
name|Signature_input
function_decl|)
parameter_list|(
name|IO
modifier|&
name|io
parameter_list|,
name|StringRef
name|key
parameter_list|,
name|T
modifier|&
name|v
parameter_list|)
function_decl|;
name|template
operator|<
name|typename
name|U
operator|>
specifier|static
name|char
name|test
argument_list|(
name|SameType
operator|<
name|Signature_input
argument_list|,
operator|&
name|U
operator|::
name|inputOne
operator|>
operator|*
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|U
operator|>
specifier|static
name|double
name|test
argument_list|(
operator|...
argument_list|)
expr_stmt|;
end_expr_stmt

begin_label
name|public
label|:
end_label

begin_decl_stmt
specifier|static
name|bool
specifier|const
name|value
init|=
operator|(
sizeof|sizeof
argument_list|(
name|test
operator|<
name|CustomMappingTraits
operator|<
name|T
operator|>>
operator|(
name|nullptr
operator|)
argument_list|)
operator|==
literal|1
operator|)
decl_stmt|;
end_decl_stmt

begin_comment
unit|};
comment|// has_FlowTraits<int> will cause an error with some compilers because
end_comment

begin_comment
comment|// it subclasses int.  Using this wrapper only instantiates the
end_comment

begin_comment
comment|// real has_FlowTraits only if the template type is a class.
end_comment

begin_expr_stmt
name|template
operator|<
name|typename
name|T
operator|,
name|bool
name|Enabled
operator|=
name|std
operator|::
name|is_class
operator|<
name|T
operator|>
operator|::
name|value
operator|>
name|class
name|has_FlowTraits
block|{
name|public
operator|:
specifier|static
specifier|const
name|bool
name|value
operator|=
name|false
block|; }
expr_stmt|;
end_expr_stmt

begin_comment
comment|// Some older gcc compilers don't support straight forward tests
end_comment

begin_comment
comment|// for members, so test for ambiguity cause by the base and derived
end_comment

begin_comment
comment|// classes both defining the member.
end_comment

begin_expr_stmt
name|template
operator|<
name|class
name|T
operator|>
expr|struct
name|has_FlowTraits
operator|<
name|T
operator|,
name|true
operator|>
block|{   struct
name|Fallback
block|{
name|bool
name|flow
block|; }
block|;   struct
name|Derived
operator|:
name|T
block|,
name|Fallback
block|{ }
block|;
name|template
operator|<
name|typename
name|C
operator|>
specifier|static
name|char
argument_list|(
operator|&
name|f
argument_list|(
argument|SameType<bool Fallback::*
argument_list|,
argument|&C::flow>*
argument_list|)
argument_list|)
index|[
literal|1
index|]
block|;
name|template
operator|<
name|typename
name|C
operator|>
specifier|static
name|char
argument_list|(
operator|&
name|f
argument_list|(
operator|...
argument_list|)
argument_list|)
index|[
literal|2
index|]
block|;
name|public
operator|:
specifier|static
name|bool
specifier|const
name|value
operator|=
sizeof|sizeof
argument_list|(
name|f
operator|<
name|Derived
operator|>
operator|(
name|nullptr
operator|)
argument_list|)
operator|==
literal|2
block|; }
expr_stmt|;
end_expr_stmt

begin_comment
comment|// Test if SequenceTraits<T> is defined on type T
end_comment

begin_expr_stmt
name|template
operator|<
name|typename
name|T
operator|>
expr|struct
name|has_SequenceTraits
operator|:
name|public
name|std
operator|::
name|integral_constant
operator|<
name|bool
operator|,
name|has_SequenceMethodTraits
operator|<
name|T
operator|>
operator|::
name|value
operator|>
block|{ }
expr_stmt|;
end_expr_stmt

begin_comment
comment|// Test if DocumentListTraits<T> is defined on type T
end_comment

begin_expr_stmt
name|template
operator|<
name|class
name|T
operator|>
expr|struct
name|has_DocumentListTraits
block|{
typedef|typedef
name|size_t
function_decl|(
modifier|*
name|Signature_size
function_decl|)
parameter_list|(
name|class
name|IO
modifier|&
parameter_list|,
name|T
modifier|&
parameter_list|)
function_decl|;
name|template
operator|<
name|typename
name|U
operator|>
specifier|static
name|char
name|test
argument_list|(
name|SameType
operator|<
name|Signature_size
argument_list|,
operator|&
name|U
operator|::
name|size
operator|>
operator|*
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|U
operator|>
specifier|static
name|double
name|test
argument_list|(
operator|...
argument_list|)
expr_stmt|;
end_expr_stmt

begin_label
name|public
label|:
end_label

begin_decl_stmt
specifier|static
name|bool
specifier|const
name|value
init|=
operator|(
sizeof|sizeof
argument_list|(
name|test
operator|<
name|DocumentListTraits
operator|<
name|T
operator|>>
operator|(
name|nullptr
operator|)
argument_list|)
operator|==
literal|1
operator|)
decl_stmt|;
end_decl_stmt

begin_function
unit|};
specifier|inline
name|bool
name|isNumber
parameter_list|(
name|StringRef
name|S
parameter_list|)
block|{
specifier|static
specifier|const
name|char
name|OctalChars
index|[]
init|=
literal|"01234567"
decl_stmt|;
if|if
condition|(
name|S
operator|.
name|startswith
argument_list|(
literal|"0"
argument_list|)
operator|&&
name|S
operator|.
name|drop_front
argument_list|()
operator|.
name|find_first_not_of
argument_list|(
name|OctalChars
argument_list|)
operator|==
name|StringRef
operator|::
name|npos
condition|)
return|return
name|true
return|;
if|if
condition|(
name|S
operator|.
name|startswith
argument_list|(
literal|"0o"
argument_list|)
operator|&&
name|S
operator|.
name|drop_front
argument_list|(
literal|2
argument_list|)
operator|.
name|find_first_not_of
argument_list|(
name|OctalChars
argument_list|)
operator|==
name|StringRef
operator|::
name|npos
condition|)
return|return
name|true
return|;
specifier|static
specifier|const
name|char
name|HexChars
index|[]
init|=
literal|"0123456789abcdefABCDEF"
decl_stmt|;
if|if
condition|(
name|S
operator|.
name|startswith
argument_list|(
literal|"0x"
argument_list|)
operator|&&
name|S
operator|.
name|drop_front
argument_list|(
literal|2
argument_list|)
operator|.
name|find_first_not_of
argument_list|(
name|HexChars
argument_list|)
operator|==
name|StringRef
operator|::
name|npos
condition|)
return|return
name|true
return|;
specifier|static
specifier|const
name|char
name|DecChars
index|[]
init|=
literal|"0123456789"
decl_stmt|;
if|if
condition|(
name|S
operator|.
name|find_first_not_of
argument_list|(
name|DecChars
argument_list|)
operator|==
name|StringRef
operator|::
name|npos
condition|)
return|return
name|true
return|;
if|if
condition|(
name|S
operator|.
name|equals
argument_list|(
literal|".inf"
argument_list|)
operator|||
name|S
operator|.
name|equals
argument_list|(
literal|".Inf"
argument_list|)
operator|||
name|S
operator|.
name|equals
argument_list|(
literal|".INF"
argument_list|)
condition|)
return|return
name|true
return|;
name|Regex
name|FloatMatcher
argument_list|(
literal|"^(\\.[0-9]+|[0-9]+(\\.[0-9]*)?)([eE][-+]?[0-9]+)?$"
argument_list|)
decl_stmt|;
if|if
condition|(
name|FloatMatcher
operator|.
name|match
argument_list|(
name|S
argument_list|)
condition|)
return|return
name|true
return|;
return|return
name|false
return|;
block|}
end_function

begin_function
specifier|inline
name|bool
name|isNumeric
parameter_list|(
name|StringRef
name|S
parameter_list|)
block|{
if|if
condition|(
operator|(
name|S
operator|.
name|front
argument_list|()
operator|==
literal|'-'
operator|||
name|S
operator|.
name|front
argument_list|()
operator|==
literal|'+'
operator|)
operator|&&
name|isNumber
argument_list|(
name|S
operator|.
name|drop_front
argument_list|()
argument_list|)
condition|)
return|return
name|true
return|;
if|if
condition|(
name|isNumber
argument_list|(
name|S
argument_list|)
condition|)
return|return
name|true
return|;
if|if
condition|(
name|S
operator|.
name|equals
argument_list|(
literal|".nan"
argument_list|)
operator|||
name|S
operator|.
name|equals
argument_list|(
literal|".NaN"
argument_list|)
operator|||
name|S
operator|.
name|equals
argument_list|(
literal|".NAN"
argument_list|)
condition|)
return|return
name|true
return|;
return|return
name|false
return|;
block|}
end_function

begin_function
specifier|inline
name|bool
name|isNull
parameter_list|(
name|StringRef
name|S
parameter_list|)
block|{
return|return
name|S
operator|.
name|equals
argument_list|(
literal|"null"
argument_list|)
operator|||
name|S
operator|.
name|equals
argument_list|(
literal|"Null"
argument_list|)
operator|||
name|S
operator|.
name|equals
argument_list|(
literal|"NULL"
argument_list|)
operator|||
name|S
operator|.
name|equals
argument_list|(
literal|"~"
argument_list|)
return|;
block|}
end_function

begin_function
specifier|inline
name|bool
name|isBool
parameter_list|(
name|StringRef
name|S
parameter_list|)
block|{
return|return
name|S
operator|.
name|equals
argument_list|(
literal|"true"
argument_list|)
operator|||
name|S
operator|.
name|equals
argument_list|(
literal|"True"
argument_list|)
operator|||
name|S
operator|.
name|equals
argument_list|(
literal|"TRUE"
argument_list|)
operator|||
name|S
operator|.
name|equals
argument_list|(
literal|"false"
argument_list|)
operator|||
name|S
operator|.
name|equals
argument_list|(
literal|"False"
argument_list|)
operator|||
name|S
operator|.
name|equals
argument_list|(
literal|"FALSE"
argument_list|)
return|;
block|}
end_function

begin_function
specifier|inline
name|bool
name|needsQuotes
parameter_list|(
name|StringRef
name|S
parameter_list|)
block|{
if|if
condition|(
name|S
operator|.
name|empty
argument_list|()
condition|)
return|return
name|true
return|;
if|if
condition|(
name|isspace
argument_list|(
name|S
operator|.
name|front
argument_list|()
argument_list|)
operator|||
name|isspace
argument_list|(
name|S
operator|.
name|back
argument_list|()
argument_list|)
condition|)
return|return
name|true
return|;
if|if
condition|(
name|S
operator|.
name|front
argument_list|()
operator|==
literal|','
condition|)
return|return
name|true
return|;
specifier|static
specifier|const
name|char
name|ScalarSafeChars
index|[]
init|=
literal|"abcdefghijklmnopqrstuvwxyz"
literal|"ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_-/^., \t"
decl_stmt|;
if|if
condition|(
name|S
operator|.
name|find_first_not_of
argument_list|(
name|ScalarSafeChars
argument_list|)
operator|!=
name|StringRef
operator|::
name|npos
condition|)
return|return
name|true
return|;
if|if
condition|(
name|isNull
argument_list|(
name|S
argument_list|)
condition|)
return|return
name|true
return|;
if|if
condition|(
name|isBool
argument_list|(
name|S
argument_list|)
condition|)
return|return
name|true
return|;
if|if
condition|(
name|isNumeric
argument_list|(
name|S
argument_list|)
condition|)
return|return
name|true
return|;
return|return
name|false
return|;
block|}
end_function

begin_expr_stmt
name|template
operator|<
name|typename
name|T
operator|,
name|typename
name|Context
operator|>
expr|struct
name|missingTraits
operator|:
name|public
name|std
operator|::
name|integral_constant
operator|<
name|bool
operator|,
operator|!
name|has_ScalarEnumerationTraits
operator|<
name|T
operator|>
operator|::
name|value
operator|&&
operator|!
name|has_ScalarBitSetTraits
operator|<
name|T
operator|>
operator|::
name|value
operator|&&
operator|!
name|has_ScalarTraits
operator|<
name|T
operator|>
operator|::
name|value
operator|&&
operator|!
name|has_BlockScalarTraits
operator|<
name|T
operator|>
operator|::
name|value
operator|&&
operator|!
name|has_MappingTraits
operator|<
name|T
operator|,
name|Context
operator|>
operator|::
name|value
operator|&&
operator|!
name|has_SequenceTraits
operator|<
name|T
operator|>
operator|::
name|value
operator|&&
operator|!
name|has_CustomMappingTraits
operator|<
name|T
operator|>
operator|::
name|value
operator|&&
operator|!
name|has_DocumentListTraits
operator|<
name|T
operator|>
operator|::
name|value
operator|>
block|{}
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|T
operator|,
name|typename
name|Context
operator|>
expr|struct
name|validatedMappingTraits
operator|:
name|public
name|std
operator|::
name|integral_constant
operator|<
name|bool
operator|,
name|has_MappingTraits
operator|<
name|T
operator|,
name|Context
operator|>
operator|::
name|value
operator|&&
name|has_MappingValidateTraits
operator|<
name|T
operator|,
name|Context
operator|>
operator|::
name|value
operator|>
block|{}
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|T
operator|,
name|typename
name|Context
operator|>
expr|struct
name|unvalidatedMappingTraits
operator|:
name|public
name|std
operator|::
name|integral_constant
operator|<
name|bool
operator|,
name|has_MappingTraits
operator|<
name|T
operator|,
name|Context
operator|>
operator|::
name|value
operator|&&
operator|!
name|has_MappingValidateTraits
operator|<
name|T
operator|,
name|Context
operator|>
operator|::
name|value
operator|>
block|{}
expr_stmt|;
end_expr_stmt

begin_comment
comment|// Base class for Input and Output.
end_comment

begin_decl_stmt
name|class
name|IO
block|{
name|public
label|:
name|IO
argument_list|(
name|void
operator|*
name|Ctxt
operator|=
name|nullptr
argument_list|)
expr_stmt|;
name|virtual
operator|~
name|IO
argument_list|()
expr_stmt|;
name|virtual
name|bool
name|outputting
parameter_list|()
init|=
literal|0
function_decl|;
name|virtual
name|unsigned
name|beginSequence
parameter_list|()
init|=
literal|0
function_decl|;
name|virtual
name|bool
name|preflightElement
parameter_list|(
name|unsigned
parameter_list|,
name|void
modifier|*
modifier|&
parameter_list|)
init|=
literal|0
function_decl|;
name|virtual
name|void
name|postflightElement
parameter_list|(
name|void
modifier|*
parameter_list|)
init|=
literal|0
function_decl|;
name|virtual
name|void
name|endSequence
parameter_list|()
init|=
literal|0
function_decl|;
name|virtual
name|bool
name|canElideEmptySequence
parameter_list|()
init|=
literal|0
function_decl|;
name|virtual
name|unsigned
name|beginFlowSequence
parameter_list|()
init|=
literal|0
function_decl|;
name|virtual
name|bool
name|preflightFlowElement
parameter_list|(
name|unsigned
parameter_list|,
name|void
modifier|*
modifier|&
parameter_list|)
init|=
literal|0
function_decl|;
name|virtual
name|void
name|postflightFlowElement
parameter_list|(
name|void
modifier|*
parameter_list|)
init|=
literal|0
function_decl|;
name|virtual
name|void
name|endFlowSequence
parameter_list|()
init|=
literal|0
function_decl|;
name|virtual
name|bool
name|mapTag
parameter_list|(
name|StringRef
name|Tag
parameter_list|,
name|bool
name|Default
init|=
name|false
parameter_list|)
init|=
literal|0
function_decl|;
name|virtual
name|void
name|beginMapping
parameter_list|()
init|=
literal|0
function_decl|;
name|virtual
name|void
name|endMapping
parameter_list|()
init|=
literal|0
function_decl|;
name|virtual
name|bool
name|preflightKey
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|bool
parameter_list|,
name|bool
parameter_list|,
name|bool
modifier|&
parameter_list|,
name|void
modifier|*
modifier|&
parameter_list|)
init|=
literal|0
function_decl|;
name|virtual
name|void
name|postflightKey
parameter_list|(
name|void
modifier|*
parameter_list|)
init|=
literal|0
function_decl|;
name|virtual
name|std
operator|::
name|vector
operator|<
name|StringRef
operator|>
name|keys
argument_list|()
operator|=
literal|0
expr_stmt|;
name|virtual
name|void
name|beginFlowMapping
parameter_list|()
init|=
literal|0
function_decl|;
name|virtual
name|void
name|endFlowMapping
parameter_list|()
init|=
literal|0
function_decl|;
name|virtual
name|void
name|beginEnumScalar
parameter_list|()
init|=
literal|0
function_decl|;
name|virtual
name|bool
name|matchEnumScalar
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|bool
parameter_list|)
init|=
literal|0
function_decl|;
name|virtual
name|bool
name|matchEnumFallback
parameter_list|()
init|=
literal|0
function_decl|;
name|virtual
name|void
name|endEnumScalar
parameter_list|()
init|=
literal|0
function_decl|;
name|virtual
name|bool
name|beginBitSetScalar
parameter_list|(
name|bool
modifier|&
parameter_list|)
init|=
literal|0
function_decl|;
name|virtual
name|bool
name|bitSetMatch
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|bool
parameter_list|)
init|=
literal|0
function_decl|;
name|virtual
name|void
name|endBitSetScalar
parameter_list|()
init|=
literal|0
function_decl|;
name|virtual
name|void
name|scalarString
parameter_list|(
name|StringRef
modifier|&
parameter_list|,
name|bool
parameter_list|)
init|=
literal|0
function_decl|;
name|virtual
name|void
name|blockScalarString
parameter_list|(
name|StringRef
modifier|&
parameter_list|)
init|=
literal|0
function_decl|;
name|virtual
name|void
name|setError
parameter_list|(
specifier|const
name|Twine
modifier|&
parameter_list|)
init|=
literal|0
function_decl|;
name|template
operator|<
name|typename
name|T
operator|>
name|void
name|enumCase
argument_list|(
argument|T&Val
argument_list|,
argument|const char* Str
argument_list|,
argument|const T ConstVal
argument_list|)
block|{
if|if
condition|(
name|matchEnumScalar
argument_list|(
name|Str
argument_list|,
name|outputting
argument_list|()
operator|&&
name|Val
operator|==
name|ConstVal
argument_list|)
condition|)
block|{
name|Val
operator|=
name|ConstVal
expr_stmt|;
block|}
block|}
comment|// allow anonymous enum values to be used with LLVM_YAML_STRONG_TYPEDEF
name|template
operator|<
name|typename
name|T
operator|>
name|void
name|enumCase
argument_list|(
argument|T&Val
argument_list|,
argument|const char* Str
argument_list|,
argument|const uint32_t ConstVal
argument_list|)
block|{
if|if
condition|(
name|matchEnumScalar
argument_list|(
name|Str
argument_list|,
name|outputting
argument_list|()
operator|&&
name|Val
operator|==
name|static_cast
operator|<
name|T
operator|>
operator|(
name|ConstVal
operator|)
argument_list|)
condition|)
block|{
name|Val
operator|=
name|ConstVal
expr_stmt|;
block|}
block|}
name|template
operator|<
name|typename
name|FBT
operator|,
name|typename
name|T
operator|>
name|void
name|enumFallback
argument_list|(
argument|T&Val
argument_list|)
block|{
if|if
condition|(
name|matchEnumFallback
argument_list|()
condition|)
block|{
name|EmptyContext
name|Context
decl_stmt|;
comment|// FIXME: Force integral conversion to allow strong typedefs to convert.
name|FBT
name|Res
init|=
name|static_cast
operator|<
name|typename
name|FBT
operator|::
name|BaseType
operator|>
operator|(
name|Val
operator|)
decl_stmt|;
name|yamlize
argument_list|(
operator|*
name|this
argument_list|,
name|Res
argument_list|,
name|true
argument_list|,
name|Context
argument_list|)
expr_stmt|;
name|Val
operator|=
name|static_cast
operator|<
name|T
operator|>
operator|(
name|static_cast
operator|<
name|typename
name|FBT
operator|::
name|BaseType
operator|>
operator|(
name|Res
operator|)
operator|)
expr_stmt|;
block|}
block|}
name|template
operator|<
name|typename
name|T
operator|>
name|void
name|bitSetCase
argument_list|(
argument|T&Val
argument_list|,
argument|const char* Str
argument_list|,
argument|const T ConstVal
argument_list|)
block|{
if|if
condition|(
name|bitSetMatch
argument_list|(
name|Str
argument_list|,
name|outputting
argument_list|()
operator|&&
operator|(
name|Val
operator|&
name|ConstVal
operator|)
operator|==
name|ConstVal
argument_list|)
condition|)
block|{
name|Val
operator|=
name|static_cast
operator|<
name|T
operator|>
operator|(
name|Val
operator||
name|ConstVal
operator|)
expr_stmt|;
block|}
block|}
comment|// allow anonymous enum values to be used with LLVM_YAML_STRONG_TYPEDEF
name|template
operator|<
name|typename
name|T
operator|>
name|void
name|bitSetCase
argument_list|(
argument|T&Val
argument_list|,
argument|const char* Str
argument_list|,
argument|const uint32_t ConstVal
argument_list|)
block|{
if|if
condition|(
name|bitSetMatch
argument_list|(
name|Str
argument_list|,
name|outputting
argument_list|()
operator|&&
operator|(
name|Val
operator|&
name|ConstVal
operator|)
operator|==
name|ConstVal
argument_list|)
condition|)
block|{
name|Val
operator|=
name|static_cast
operator|<
name|T
operator|>
operator|(
name|Val
operator||
name|ConstVal
operator|)
expr_stmt|;
block|}
block|}
name|template
operator|<
name|typename
name|T
operator|>
name|void
name|maskedBitSetCase
argument_list|(
argument|T&Val
argument_list|,
argument|const char *Str
argument_list|,
argument|T ConstVal
argument_list|,
argument|T Mask
argument_list|)
block|{
if|if
condition|(
name|bitSetMatch
argument_list|(
name|Str
argument_list|,
name|outputting
argument_list|()
operator|&&
operator|(
name|Val
operator|&
name|Mask
operator|)
operator|==
name|ConstVal
argument_list|)
condition|)
name|Val
operator|=
name|Val
operator||
name|ConstVal
expr_stmt|;
block|}
name|template
operator|<
name|typename
name|T
operator|>
name|void
name|maskedBitSetCase
argument_list|(
argument|T&Val
argument_list|,
argument|const char *Str
argument_list|,
argument|uint32_t ConstVal
argument_list|,
argument|uint32_t Mask
argument_list|)
block|{
if|if
condition|(
name|bitSetMatch
argument_list|(
name|Str
argument_list|,
name|outputting
argument_list|()
operator|&&
operator|(
name|Val
operator|&
name|Mask
operator|)
operator|==
name|ConstVal
argument_list|)
condition|)
name|Val
operator|=
name|Val
operator||
name|ConstVal
expr_stmt|;
block|}
name|void
modifier|*
name|getContext
parameter_list|()
function_decl|;
name|void
name|setContext
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
name|template
operator|<
name|typename
name|T
operator|>
name|void
name|mapRequired
argument_list|(
argument|const char *Key
argument_list|,
argument|T&Val
argument_list|)
block|{
name|EmptyContext
name|Ctx
block|;
name|this
operator|->
name|processKey
argument_list|(
name|Key
argument_list|,
name|Val
argument_list|,
name|true
argument_list|,
name|Ctx
argument_list|)
block|;   }
name|template
operator|<
name|typename
name|T
operator|,
name|typename
name|Context
operator|>
name|void
name|mapRequired
argument_list|(
argument|const char *Key
argument_list|,
argument|T&Val
argument_list|,
argument|Context&Ctx
argument_list|)
block|{
name|this
operator|->
name|processKey
argument_list|(
name|Key
argument_list|,
name|Val
argument_list|,
name|true
argument_list|,
name|Ctx
argument_list|)
block|;   }
name|template
operator|<
name|typename
name|T
operator|>
name|void
name|mapOptional
argument_list|(
argument|const char *Key
argument_list|,
argument|T&Val
argument_list|)
block|{
name|EmptyContext
name|Ctx
block|;
name|mapOptionalWithContext
argument_list|(
name|Key
argument_list|,
name|Val
argument_list|,
name|Ctx
argument_list|)
block|;   }
name|template
operator|<
name|typename
name|T
operator|>
name|void
name|mapOptional
argument_list|(
argument|const char *Key
argument_list|,
argument|T&Val
argument_list|,
argument|const T&Default
argument_list|)
block|{
name|EmptyContext
name|Ctx
block|;
name|mapOptionalWithContext
argument_list|(
name|Key
argument_list|,
name|Val
argument_list|,
name|Default
argument_list|,
name|Ctx
argument_list|)
block|;   }
name|template
operator|<
name|typename
name|T
operator|,
name|typename
name|Context
operator|>
name|typename
name|std
operator|::
name|enable_if
operator|<
name|has_SequenceTraits
operator|<
name|T
operator|>
operator|::
name|value
operator|,
name|void
operator|>
operator|::
name|type
name|mapOptionalWithContext
argument_list|(
argument|const char *Key
argument_list|,
argument|T&Val
argument_list|,
argument|Context&Ctx
argument_list|)
block|{
comment|// omit key/value instead of outputting empty sequence
if|if
condition|(
name|this
operator|->
name|canElideEmptySequence
argument_list|()
operator|&&
operator|!
operator|(
name|Val
operator|.
name|begin
argument_list|()
operator|!=
name|Val
operator|.
name|end
argument_list|()
operator|)
condition|)
return|return;
name|this
operator|->
name|processKey
argument_list|(
name|Key
argument_list|,
name|Val
argument_list|,
name|false
argument_list|,
name|Ctx
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|T
operator|,
name|typename
name|Context
operator|>
name|void
name|mapOptionalWithContext
argument_list|(
argument|const char *Key
argument_list|,
argument|Optional<T>&Val
argument_list|,
argument|Context&Ctx
argument_list|)
block|{
name|this
operator|->
name|processKeyWithDefault
argument_list|(
name|Key
argument_list|,
name|Val
argument_list|,
name|Optional
operator|<
name|T
operator|>
operator|(
operator|)
argument_list|,
comment|/*Required=*/
name|false
argument_list|,
name|Ctx
argument_list|)
block|;   }
name|template
operator|<
name|typename
name|T
operator|,
name|typename
name|Context
operator|>
name|typename
name|std
operator|::
name|enable_if
operator|<
operator|!
name|has_SequenceTraits
operator|<
name|T
operator|>
operator|::
name|value
operator|,
name|void
operator|>
operator|::
name|type
name|mapOptionalWithContext
argument_list|(
argument|const char *Key
argument_list|,
argument|T&Val
argument_list|,
argument|Context&Ctx
argument_list|)
block|{
name|this
operator|->
name|processKey
argument_list|(
name|Key
argument_list|,
name|Val
argument_list|,
name|false
argument_list|,
name|Ctx
argument_list|)
block|;   }
name|template
operator|<
name|typename
name|T
operator|,
name|typename
name|Context
operator|>
name|void
name|mapOptionalWithContext
argument_list|(
argument|const char *Key
argument_list|,
argument|T&Val
argument_list|,
argument|const T&Default
argument_list|,
argument|Context&Ctx
argument_list|)
block|{
name|this
operator|->
name|processKeyWithDefault
argument_list|(
name|Key
argument_list|,
name|Val
argument_list|,
name|Default
argument_list|,
name|false
argument_list|,
name|Ctx
argument_list|)
block|;   }
name|private
operator|:
name|template
operator|<
name|typename
name|T
operator|,
name|typename
name|Context
operator|>
name|void
name|processKeyWithDefault
argument_list|(
argument|const char *Key
argument_list|,
argument|Optional<T>&Val
argument_list|,
argument|const Optional<T>&DefaultValue
argument_list|,
argument|bool Required
argument_list|,
argument|Context&Ctx
argument_list|)
block|{
name|assert
argument_list|(
name|DefaultValue
operator|.
name|hasValue
argument_list|()
operator|==
name|false
operator|&&
literal|"Optional<T> shouldn't have a value!"
argument_list|)
block|;
name|void
operator|*
name|SaveInfo
block|;
name|bool
name|UseDefault
operator|=
name|true
block|;
specifier|const
name|bool
name|sameAsDefault
operator|=
name|outputting
argument_list|()
operator|&&
operator|!
name|Val
operator|.
name|hasValue
argument_list|()
block|;
if|if
condition|(
operator|!
name|outputting
argument_list|()
operator|&&
operator|!
name|Val
operator|.
name|hasValue
argument_list|()
condition|)
name|Val
operator|=
name|T
argument_list|()
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|Val
operator|.
name|hasValue
argument_list|()
operator|&&
name|this
operator|->
name|preflightKey
argument_list|(
name|Key
argument_list|,
name|Required
argument_list|,
name|sameAsDefault
argument_list|,
name|UseDefault
argument_list|,
name|SaveInfo
argument_list|)
condition|)
block|{
name|yamlize
argument_list|(
operator|*
name|this
argument_list|,
name|Val
operator|.
name|getValue
argument_list|()
argument_list|,
name|Required
argument_list|,
name|Ctx
argument_list|)
expr_stmt|;
name|this
operator|->
name|postflightKey
argument_list|(
name|SaveInfo
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|UseDefault
condition|)
name|Val
operator|=
name|DefaultValue
expr_stmt|;
block|}
end_if

begin_expr_stmt
unit|}    template
operator|<
name|typename
name|T
operator|,
name|typename
name|Context
operator|>
name|void
name|processKeyWithDefault
argument_list|(
argument|const char *Key
argument_list|,
argument|T&Val
argument_list|,
argument|const T&DefaultValue
argument_list|,
argument|bool Required
argument_list|,
argument|Context&Ctx
argument_list|)
block|{
name|void
operator|*
name|SaveInfo
block|;
name|bool
name|UseDefault
block|;
specifier|const
name|bool
name|sameAsDefault
operator|=
name|outputting
argument_list|()
operator|&&
name|Val
operator|==
name|DefaultValue
block|;
if|if
condition|(
name|this
operator|->
name|preflightKey
argument_list|(
name|Key
argument_list|,
name|Required
argument_list|,
name|sameAsDefault
argument_list|,
name|UseDefault
argument_list|,
name|SaveInfo
argument_list|)
condition|)
block|{
name|yamlize
argument_list|(
operator|*
name|this
argument_list|,
name|Val
argument_list|,
name|Required
argument_list|,
name|Ctx
argument_list|)
expr_stmt|;
name|this
operator|->
name|postflightKey
argument_list|(
name|SaveInfo
argument_list|)
expr_stmt|;
block|}
end_expr_stmt

begin_else
else|else
block|{
if|if
condition|(
name|UseDefault
condition|)
name|Val
operator|=
name|DefaultValue
expr_stmt|;
block|}
end_else

begin_expr_stmt
unit|}    template
operator|<
name|typename
name|T
operator|,
name|typename
name|Context
operator|>
name|void
name|processKey
argument_list|(
argument|const char *Key
argument_list|,
argument|T&Val
argument_list|,
argument|bool Required
argument_list|,
argument|Context&Ctx
argument_list|)
block|{
name|void
operator|*
name|SaveInfo
block|;
name|bool
name|UseDefault
block|;
if|if
condition|(
name|this
operator|->
name|preflightKey
argument_list|(
name|Key
argument_list|,
name|Required
argument_list|,
name|false
argument_list|,
name|UseDefault
argument_list|,
name|SaveInfo
argument_list|)
condition|)
block|{
name|yamlize
argument_list|(
operator|*
name|this
argument_list|,
name|Val
argument_list|,
name|Required
argument_list|,
name|Ctx
argument_list|)
expr_stmt|;
name|this
operator|->
name|postflightKey
argument_list|(
name|SaveInfo
argument_list|)
expr_stmt|;
block|}
end_expr_stmt

begin_decl_stmt
unit|}  private:
name|void
modifier|*
name|Ctxt
decl_stmt|;
end_decl_stmt

begin_decl_stmt
unit|};
name|namespace
name|detail
block|{
name|template
operator|<
name|typename
name|T
operator|,
name|typename
name|Context
operator|>
name|void
name|doMapping
argument_list|(
argument|IO&io
argument_list|,
argument|T&Val
argument_list|,
argument|Context&Ctx
argument_list|)
block|{
name|MappingContextTraits
operator|<
name|T
block|,
name|Context
operator|>
operator|::
name|mapping
argument_list|(
name|io
argument_list|,
name|Val
argument_list|,
name|Ctx
argument_list|)
block|; }
name|template
operator|<
name|typename
name|T
operator|>
name|void
name|doMapping
argument_list|(
argument|IO&io
argument_list|,
argument|T&Val
argument_list|,
argument|EmptyContext&Ctx
argument_list|)
block|{
name|MappingTraits
operator|<
name|T
operator|>
operator|::
name|mapping
argument_list|(
name|io
argument_list|,
name|Val
argument_list|)
block|; }
block|}
end_decl_stmt

begin_comment
comment|// end namespace detail
end_comment

begin_expr_stmt
name|template
operator|<
name|typename
name|T
operator|>
name|typename
name|std
operator|::
name|enable_if
operator|<
name|has_ScalarEnumerationTraits
operator|<
name|T
operator|>
operator|::
name|value
operator|,
name|void
operator|>
operator|::
name|type
name|yamlize
argument_list|(
argument|IO&io
argument_list|,
argument|T&Val
argument_list|,
argument|bool
argument_list|,
argument|EmptyContext&Ctx
argument_list|)
block|{
name|io
operator|.
name|beginEnumScalar
argument_list|()
block|;
name|ScalarEnumerationTraits
operator|<
name|T
operator|>
operator|::
name|enumeration
argument_list|(
name|io
argument_list|,
name|Val
argument_list|)
block|;
name|io
operator|.
name|endEnumScalar
argument_list|()
block|; }
name|template
operator|<
name|typename
name|T
operator|>
name|typename
name|std
operator|::
name|enable_if
operator|<
name|has_ScalarBitSetTraits
operator|<
name|T
operator|>
operator|::
name|value
operator|,
name|void
operator|>
operator|::
name|type
name|yamlize
argument_list|(
argument|IO&io
argument_list|,
argument|T&Val
argument_list|,
argument|bool
argument_list|,
argument|EmptyContext&Ctx
argument_list|)
block|{
name|bool
name|DoClear
block|;
if|if
condition|(
name|io
operator|.
name|beginBitSetScalar
argument_list|(
name|DoClear
argument_list|)
condition|)
block|{
if|if
condition|(
name|DoClear
condition|)
name|Val
operator|=
name|static_cast
operator|<
name|T
operator|>
operator|(
literal|0
operator|)
expr_stmt|;
name|ScalarBitSetTraits
operator|<
name|T
operator|>
operator|::
name|bitset
argument_list|(
name|io
argument_list|,
name|Val
argument_list|)
expr_stmt|;
name|io
operator|.
name|endBitSetScalar
argument_list|()
expr_stmt|;
block|}
end_expr_stmt

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|T
operator|>
name|typename
name|std
operator|::
name|enable_if
operator|<
name|has_ScalarTraits
operator|<
name|T
operator|>
operator|::
name|value
operator|,
name|void
operator|>
operator|::
name|type
name|yamlize
argument_list|(
argument|IO&io
argument_list|,
argument|T&Val
argument_list|,
argument|bool
argument_list|,
argument|EmptyContext&Ctx
argument_list|)
block|{
if|if
condition|(
name|io
operator|.
name|outputting
argument_list|()
condition|)
block|{
name|std
operator|::
name|string
name|Storage
expr_stmt|;
name|llvm
operator|::
name|raw_string_ostream
name|Buffer
argument_list|(
name|Storage
argument_list|)
expr_stmt|;
name|ScalarTraits
operator|<
name|T
operator|>
operator|::
name|output
argument_list|(
name|Val
argument_list|,
name|io
operator|.
name|getContext
argument_list|()
argument_list|,
name|Buffer
argument_list|)
expr_stmt|;
name|StringRef
name|Str
init|=
name|Buffer
operator|.
name|str
argument_list|()
decl_stmt|;
name|io
operator|.
name|scalarString
argument_list|(
name|Str
argument_list|,
name|ScalarTraits
operator|<
name|T
operator|>
operator|::
name|mustQuote
argument_list|(
name|Str
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_expr_stmt

begin_else
else|else
block|{
name|StringRef
name|Str
decl_stmt|;
name|io
operator|.
name|scalarString
argument_list|(
name|Str
argument_list|,
name|ScalarTraits
operator|<
name|T
operator|>
operator|::
name|mustQuote
argument_list|(
name|Str
argument_list|)
argument_list|)
expr_stmt|;
name|StringRef
name|Result
init|=
name|ScalarTraits
operator|<
name|T
operator|>
operator|::
name|input
argument_list|(
name|Str
argument_list|,
name|io
operator|.
name|getContext
argument_list|()
argument_list|,
name|Val
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|Result
operator|.
name|empty
argument_list|()
condition|)
block|{
name|io
operator|.
name|setError
argument_list|(
name|llvm
operator|::
name|Twine
argument_list|(
name|Result
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_else

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|T
operator|>
name|typename
name|std
operator|::
name|enable_if
operator|<
name|has_BlockScalarTraits
operator|<
name|T
operator|>
operator|::
name|value
operator|,
name|void
operator|>
operator|::
name|type
name|yamlize
argument_list|(
argument|IO&YamlIO
argument_list|,
argument|T&Val
argument_list|,
argument|bool
argument_list|,
argument|EmptyContext&Ctx
argument_list|)
block|{
if|if
condition|(
name|YamlIO
operator|.
name|outputting
argument_list|()
condition|)
block|{
name|std
operator|::
name|string
name|Storage
expr_stmt|;
name|llvm
operator|::
name|raw_string_ostream
name|Buffer
argument_list|(
name|Storage
argument_list|)
expr_stmt|;
name|BlockScalarTraits
operator|<
name|T
operator|>
operator|::
name|output
argument_list|(
name|Val
argument_list|,
name|YamlIO
operator|.
name|getContext
argument_list|()
argument_list|,
name|Buffer
argument_list|)
expr_stmt|;
name|StringRef
name|Str
init|=
name|Buffer
operator|.
name|str
argument_list|()
decl_stmt|;
name|YamlIO
operator|.
name|blockScalarString
argument_list|(
name|Str
argument_list|)
expr_stmt|;
block|}
end_expr_stmt

begin_else
else|else
block|{
name|StringRef
name|Str
decl_stmt|;
name|YamlIO
operator|.
name|blockScalarString
argument_list|(
name|Str
argument_list|)
expr_stmt|;
name|StringRef
name|Result
init|=
name|BlockScalarTraits
operator|<
name|T
operator|>
operator|::
name|input
argument_list|(
name|Str
argument_list|,
name|YamlIO
operator|.
name|getContext
argument_list|()
argument_list|,
name|Val
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|Result
operator|.
name|empty
argument_list|()
condition|)
name|YamlIO
operator|.
name|setError
argument_list|(
name|llvm
operator|::
name|Twine
argument_list|(
name|Result
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_else

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|T
operator|,
name|typename
name|Context
operator|>
name|typename
name|std
operator|::
name|enable_if
operator|<
name|validatedMappingTraits
operator|<
name|T
operator|,
name|Context
operator|>
operator|::
name|value
operator|,
name|void
operator|>
operator|::
name|type
name|yamlize
argument_list|(
argument|IO&io
argument_list|,
argument|T&Val
argument_list|,
argument|bool
argument_list|,
argument|Context&Ctx
argument_list|)
block|{
if|if
condition|(
name|has_FlowTraits
operator|<
name|MappingTraits
operator|<
name|T
operator|>>
operator|::
name|value
condition|)
name|io
operator|.
name|beginFlowMapping
argument_list|()
expr_stmt|;
else|else
name|io
operator|.
name|beginMapping
argument_list|()
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|io
operator|.
name|outputting
argument_list|()
condition|)
block|{
name|StringRef
name|Err
init|=
name|MappingTraits
operator|<
name|T
operator|>
operator|::
name|validate
argument_list|(
name|io
argument_list|,
name|Val
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|Err
operator|.
name|empty
argument_list|()
condition|)
block|{
name|llvm
operator|::
name|errs
argument_list|()
operator|<<
name|Err
operator|<<
literal|"\n"
expr_stmt|;
name|assert
argument_list|(
name|Err
operator|.
name|empty
argument_list|()
operator|&&
literal|"invalid struct trying to be written as yaml"
argument_list|)
expr_stmt|;
block|}
block|}
end_if

begin_expr_stmt
name|detail
operator|::
name|doMapping
argument_list|(
name|io
argument_list|,
name|Val
argument_list|,
name|Ctx
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
operator|!
name|io
operator|.
name|outputting
argument_list|()
condition|)
block|{
name|StringRef
name|Err
init|=
name|MappingTraits
operator|<
name|T
operator|>
operator|::
name|validate
argument_list|(
name|io
argument_list|,
name|Val
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|Err
operator|.
name|empty
argument_list|()
condition|)
name|io
operator|.
name|setError
argument_list|(
name|Err
argument_list|)
expr_stmt|;
block|}
end_if

begin_if
if|if
condition|(
name|has_FlowTraits
operator|<
name|MappingTraits
operator|<
name|T
operator|>>
operator|::
name|value
condition|)
name|io
operator|.
name|endFlowMapping
argument_list|()
expr_stmt|;
else|else
name|io
operator|.
name|endMapping
argument_list|()
expr_stmt|;
end_if

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|T
operator|,
name|typename
name|Context
operator|>
name|typename
name|std
operator|::
name|enable_if
operator|<
name|unvalidatedMappingTraits
operator|<
name|T
operator|,
name|Context
operator|>
operator|::
name|value
operator|,
name|void
operator|>
operator|::
name|type
name|yamlize
argument_list|(
argument|IO&io
argument_list|,
argument|T&Val
argument_list|,
argument|bool
argument_list|,
argument|Context&Ctx
argument_list|)
block|{
if|if
condition|(
name|has_FlowTraits
operator|<
name|MappingTraits
operator|<
name|T
operator|>>
operator|::
name|value
condition|)
block|{
name|io
operator|.
name|beginFlowMapping
argument_list|()
expr_stmt|;
name|detail
operator|::
name|doMapping
argument_list|(
name|io
argument_list|,
name|Val
argument_list|,
name|Ctx
argument_list|)
expr_stmt|;
name|io
operator|.
name|endFlowMapping
argument_list|()
expr_stmt|;
block|}
end_expr_stmt

begin_else
else|else
block|{
name|io
operator|.
name|beginMapping
argument_list|()
expr_stmt|;
name|detail
operator|::
name|doMapping
argument_list|(
name|io
argument_list|,
name|Val
argument_list|,
name|Ctx
argument_list|)
expr_stmt|;
name|io
operator|.
name|endMapping
argument_list|()
expr_stmt|;
block|}
end_else

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|T
operator|>
name|typename
name|std
operator|::
name|enable_if
operator|<
name|has_CustomMappingTraits
operator|<
name|T
operator|>
operator|::
name|value
operator|,
name|void
operator|>
operator|::
name|type
name|yamlize
argument_list|(
argument|IO&io
argument_list|,
argument|T&Val
argument_list|,
argument|bool
argument_list|,
argument|EmptyContext&Ctx
argument_list|)
block|{
if|if
condition|(
name|io
operator|.
name|outputting
argument_list|()
condition|)
block|{
name|io
operator|.
name|beginMapping
argument_list|()
expr_stmt|;
name|CustomMappingTraits
operator|<
name|T
operator|>
operator|::
name|output
argument_list|(
name|io
argument_list|,
name|Val
argument_list|)
expr_stmt|;
name|io
operator|.
name|endMapping
argument_list|()
expr_stmt|;
block|}
end_expr_stmt

begin_else
else|else
block|{
name|io
operator|.
name|beginMapping
argument_list|()
expr_stmt|;
for|for
control|(
name|StringRef
name|key
range|:
name|io
operator|.
name|keys
argument_list|()
control|)
name|CustomMappingTraits
operator|<
name|T
operator|>
operator|::
name|inputOne
argument_list|(
name|io
argument_list|,
name|key
argument_list|,
name|Val
argument_list|)
expr_stmt|;
name|io
operator|.
name|endMapping
argument_list|()
expr_stmt|;
block|}
end_else

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|T
operator|>
name|typename
name|std
operator|::
name|enable_if
operator|<
name|missingTraits
operator|<
name|T
operator|,
name|EmptyContext
operator|>
operator|::
name|value
operator|,
name|void
operator|>
operator|::
name|type
name|yamlize
argument_list|(
argument|IO&io
argument_list|,
argument|T&Val
argument_list|,
argument|bool
argument_list|,
argument|EmptyContext&Ctx
argument_list|)
block|{
name|char
name|missing_yaml_trait_for_type
index|[
sizeof|sizeof
argument_list|(
name|MissingTrait
operator|<
name|T
operator|>
argument_list|)
index|]
block|; }
name|template
operator|<
name|typename
name|T
operator|,
name|typename
name|Context
operator|>
name|typename
name|std
operator|::
name|enable_if
operator|<
name|has_SequenceTraits
operator|<
name|T
operator|>
operator|::
name|value
operator|,
name|void
operator|>
operator|::
name|type
name|yamlize
argument_list|(
argument|IO&io
argument_list|,
argument|T&Seq
argument_list|,
argument|bool
argument_list|,
argument|Context&Ctx
argument_list|)
block|{
if|if
condition|(
name|has_FlowTraits
operator|<
name|SequenceTraits
operator|<
name|T
operator|>
expr|>
operator|::
name|value
condition|)
block|{
name|unsigned
name|incnt
init|=
name|io
operator|.
name|beginFlowSequence
argument_list|()
decl_stmt|;
name|unsigned
name|count
init|=
name|io
operator|.
name|outputting
argument_list|()
condition|?
name|SequenceTraits
operator|<
name|T
operator|>
operator|::
name|size
argument_list|(
name|io
argument_list|,
name|Seq
argument_list|)
else|:
name|incnt
decl_stmt|;
for|for
control|(
name|unsigned
name|i
init|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
operator|++
name|i
control|)
block|{
name|void
modifier|*
name|SaveInfo
decl_stmt|;
if|if
condition|(
name|io
operator|.
name|preflightFlowElement
argument_list|(
name|i
argument_list|,
name|SaveInfo
argument_list|)
condition|)
block|{
name|yamlize
argument_list|(
name|io
argument_list|,
name|SequenceTraits
operator|<
name|T
operator|>
operator|::
name|element
argument_list|(
name|io
argument_list|,
name|Seq
argument_list|,
name|i
argument_list|)
argument_list|,
name|true
argument_list|,
name|Ctx
argument_list|)
expr_stmt|;
name|io
operator|.
name|postflightFlowElement
argument_list|(
name|SaveInfo
argument_list|)
expr_stmt|;
block|}
end_expr_stmt

begin_expr_stmt
unit|}     io
operator|.
name|endFlowSequence
argument_list|()
expr_stmt|;
end_expr_stmt

begin_block
unit|}   else
block|{
name|unsigned
name|incnt
init|=
name|io
operator|.
name|beginSequence
argument_list|()
decl_stmt|;
name|unsigned
name|count
init|=
name|io
operator|.
name|outputting
argument_list|()
condition|?
name|SequenceTraits
operator|<
name|T
operator|>
operator|::
name|size
argument_list|(
name|io
argument_list|,
name|Seq
argument_list|)
else|:
name|incnt
decl_stmt|;
for|for
control|(
name|unsigned
name|i
init|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
operator|++
name|i
control|)
block|{
name|void
modifier|*
name|SaveInfo
decl_stmt|;
if|if
condition|(
name|io
operator|.
name|preflightElement
argument_list|(
name|i
argument_list|,
name|SaveInfo
argument_list|)
condition|)
block|{
name|yamlize
argument_list|(
name|io
argument_list|,
name|SequenceTraits
operator|<
name|T
operator|>
operator|::
name|element
argument_list|(
name|io
argument_list|,
name|Seq
argument_list|,
name|i
argument_list|)
argument_list|,
name|true
argument_list|,
name|Ctx
argument_list|)
expr_stmt|;
name|io
operator|.
name|postflightElement
argument_list|(
name|SaveInfo
argument_list|)
expr_stmt|;
block|}
block|}
name|io
operator|.
name|endSequence
argument_list|()
expr_stmt|;
block|}
end_block

begin_expr_stmt
unit|}  template
operator|<
operator|>
expr|struct
name|ScalarTraits
operator|<
name|bool
operator|>
block|{
specifier|static
name|void
name|output
argument_list|(
specifier|const
name|bool
operator|&
argument_list|,
name|void
operator|*
argument_list|,
name|llvm
operator|::
name|raw_ostream
operator|&
argument_list|)
block|;
specifier|static
name|StringRef
name|input
argument_list|(
name|StringRef
argument_list|,
name|void
operator|*
argument_list|,
name|bool
operator|&
argument_list|)
block|;
specifier|static
name|bool
name|mustQuote
argument_list|(
argument|StringRef
argument_list|)
block|{
return|return
name|false
return|;
block|}
end_expr_stmt

begin_expr_stmt
unit|};
name|template
operator|<
operator|>
expr|struct
name|ScalarTraits
operator|<
name|StringRef
operator|>
block|{
specifier|static
name|void
name|output
argument_list|(
specifier|const
name|StringRef
operator|&
argument_list|,
name|void
operator|*
argument_list|,
name|llvm
operator|::
name|raw_ostream
operator|&
argument_list|)
block|;
specifier|static
name|StringRef
name|input
argument_list|(
name|StringRef
argument_list|,
name|void
operator|*
argument_list|,
name|StringRef
operator|&
argument_list|)
block|;
specifier|static
name|bool
name|mustQuote
argument_list|(
argument|StringRef S
argument_list|)
block|{
return|return
name|needsQuotes
argument_list|(
name|S
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
unit|};
name|template
operator|<
operator|>
expr|struct
name|ScalarTraits
operator|<
name|std
operator|::
name|string
operator|>
block|{
specifier|static
name|void
name|output
argument_list|(
specifier|const
name|std
operator|::
name|string
operator|&
argument_list|,
name|void
operator|*
argument_list|,
name|llvm
operator|::
name|raw_ostream
operator|&
argument_list|)
block|;
specifier|static
name|StringRef
name|input
argument_list|(
name|StringRef
argument_list|,
name|void
operator|*
argument_list|,
name|std
operator|::
name|string
operator|&
argument_list|)
block|;
specifier|static
name|bool
name|mustQuote
argument_list|(
argument|StringRef S
argument_list|)
block|{
return|return
name|needsQuotes
argument_list|(
name|S
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
unit|};
name|template
operator|<
operator|>
expr|struct
name|ScalarTraits
operator|<
name|uint8_t
operator|>
block|{
specifier|static
name|void
name|output
argument_list|(
specifier|const
name|uint8_t
operator|&
argument_list|,
name|void
operator|*
argument_list|,
name|llvm
operator|::
name|raw_ostream
operator|&
argument_list|)
block|;
specifier|static
name|StringRef
name|input
argument_list|(
name|StringRef
argument_list|,
name|void
operator|*
argument_list|,
name|uint8_t
operator|&
argument_list|)
block|;
specifier|static
name|bool
name|mustQuote
argument_list|(
argument|StringRef
argument_list|)
block|{
return|return
name|false
return|;
block|}
end_expr_stmt

begin_expr_stmt
unit|};
name|template
operator|<
operator|>
expr|struct
name|ScalarTraits
operator|<
name|uint16_t
operator|>
block|{
specifier|static
name|void
name|output
argument_list|(
specifier|const
name|uint16_t
operator|&
argument_list|,
name|void
operator|*
argument_list|,
name|llvm
operator|::
name|raw_ostream
operator|&
argument_list|)
block|;
specifier|static
name|StringRef
name|input
argument_list|(
name|StringRef
argument_list|,
name|void
operator|*
argument_list|,
name|uint16_t
operator|&
argument_list|)
block|;
specifier|static
name|bool
name|mustQuote
argument_list|(
argument|StringRef
argument_list|)
block|{
return|return
name|false
return|;
block|}
end_expr_stmt

begin_expr_stmt
unit|};
name|template
operator|<
operator|>
expr|struct
name|ScalarTraits
operator|<
name|uint32_t
operator|>
block|{
specifier|static
name|void
name|output
argument_list|(
specifier|const
name|uint32_t
operator|&
argument_list|,
name|void
operator|*
argument_list|,
name|llvm
operator|::
name|raw_ostream
operator|&
argument_list|)
block|;
specifier|static
name|StringRef
name|input
argument_list|(
name|StringRef
argument_list|,
name|void
operator|*
argument_list|,
name|uint32_t
operator|&
argument_list|)
block|;
specifier|static
name|bool
name|mustQuote
argument_list|(
argument|StringRef
argument_list|)
block|{
return|return
name|false
return|;
block|}
end_expr_stmt

begin_expr_stmt
unit|};
name|template
operator|<
operator|>
expr|struct
name|ScalarTraits
operator|<
name|uint64_t
operator|>
block|{
specifier|static
name|void
name|output
argument_list|(
specifier|const
name|uint64_t
operator|&
argument_list|,
name|void
operator|*
argument_list|,
name|llvm
operator|::
name|raw_ostream
operator|&
argument_list|)
block|;
specifier|static
name|StringRef
name|input
argument_list|(
name|StringRef
argument_list|,
name|void
operator|*
argument_list|,
name|uint64_t
operator|&
argument_list|)
block|;
specifier|static
name|bool
name|mustQuote
argument_list|(
argument|StringRef
argument_list|)
block|{
return|return
name|false
return|;
block|}
end_expr_stmt

begin_expr_stmt
unit|};
name|template
operator|<
operator|>
expr|struct
name|ScalarTraits
operator|<
name|int8_t
operator|>
block|{
specifier|static
name|void
name|output
argument_list|(
specifier|const
name|int8_t
operator|&
argument_list|,
name|void
operator|*
argument_list|,
name|llvm
operator|::
name|raw_ostream
operator|&
argument_list|)
block|;
specifier|static
name|StringRef
name|input
argument_list|(
name|StringRef
argument_list|,
name|void
operator|*
argument_list|,
name|int8_t
operator|&
argument_list|)
block|;
specifier|static
name|bool
name|mustQuote
argument_list|(
argument|StringRef
argument_list|)
block|{
return|return
name|false
return|;
block|}
end_expr_stmt

begin_expr_stmt
unit|};
name|template
operator|<
operator|>
expr|struct
name|ScalarTraits
operator|<
name|int16_t
operator|>
block|{
specifier|static
name|void
name|output
argument_list|(
specifier|const
name|int16_t
operator|&
argument_list|,
name|void
operator|*
argument_list|,
name|llvm
operator|::
name|raw_ostream
operator|&
argument_list|)
block|;
specifier|static
name|StringRef
name|input
argument_list|(
name|StringRef
argument_list|,
name|void
operator|*
argument_list|,
name|int16_t
operator|&
argument_list|)
block|;
specifier|static
name|bool
name|mustQuote
argument_list|(
argument|StringRef
argument_list|)
block|{
return|return
name|false
return|;
block|}
end_expr_stmt

begin_expr_stmt
unit|};
name|template
operator|<
operator|>
expr|struct
name|ScalarTraits
operator|<
name|int32_t
operator|>
block|{
specifier|static
name|void
name|output
argument_list|(
specifier|const
name|int32_t
operator|&
argument_list|,
name|void
operator|*
argument_list|,
name|llvm
operator|::
name|raw_ostream
operator|&
argument_list|)
block|;
specifier|static
name|StringRef
name|input
argument_list|(
name|StringRef
argument_list|,
name|void
operator|*
argument_list|,
name|int32_t
operator|&
argument_list|)
block|;
specifier|static
name|bool
name|mustQuote
argument_list|(
argument|StringRef
argument_list|)
block|{
return|return
name|false
return|;
block|}
end_expr_stmt

begin_expr_stmt
unit|};
name|template
operator|<
operator|>
expr|struct
name|ScalarTraits
operator|<
name|int64_t
operator|>
block|{
specifier|static
name|void
name|output
argument_list|(
specifier|const
name|int64_t
operator|&
argument_list|,
name|void
operator|*
argument_list|,
name|llvm
operator|::
name|raw_ostream
operator|&
argument_list|)
block|;
specifier|static
name|StringRef
name|input
argument_list|(
name|StringRef
argument_list|,
name|void
operator|*
argument_list|,
name|int64_t
operator|&
argument_list|)
block|;
specifier|static
name|bool
name|mustQuote
argument_list|(
argument|StringRef
argument_list|)
block|{
return|return
name|false
return|;
block|}
end_expr_stmt

begin_expr_stmt
unit|};
name|template
operator|<
operator|>
expr|struct
name|ScalarTraits
operator|<
name|float
operator|>
block|{
specifier|static
name|void
name|output
argument_list|(
specifier|const
name|float
operator|&
argument_list|,
name|void
operator|*
argument_list|,
name|llvm
operator|::
name|raw_ostream
operator|&
argument_list|)
block|;
specifier|static
name|StringRef
name|input
argument_list|(
name|StringRef
argument_list|,
name|void
operator|*
argument_list|,
name|float
operator|&
argument_list|)
block|;
specifier|static
name|bool
name|mustQuote
argument_list|(
argument|StringRef
argument_list|)
block|{
return|return
name|false
return|;
block|}
end_expr_stmt

begin_expr_stmt
unit|};
name|template
operator|<
operator|>
expr|struct
name|ScalarTraits
operator|<
name|double
operator|>
block|{
specifier|static
name|void
name|output
argument_list|(
specifier|const
name|double
operator|&
argument_list|,
name|void
operator|*
argument_list|,
name|llvm
operator|::
name|raw_ostream
operator|&
argument_list|)
block|;
specifier|static
name|StringRef
name|input
argument_list|(
name|StringRef
argument_list|,
name|void
operator|*
argument_list|,
name|double
operator|&
argument_list|)
block|;
specifier|static
name|bool
name|mustQuote
argument_list|(
argument|StringRef
argument_list|)
block|{
return|return
name|false
return|;
block|}
end_expr_stmt

begin_comment
unit|};
comment|// For endian types, we just use the existing ScalarTraits for the underlying
end_comment

begin_comment
comment|// type.  This way endian aware types are supported whenever a ScalarTraits
end_comment

begin_comment
comment|// is defined for the underlying type.
end_comment

begin_expr_stmt
name|template
operator|<
name|typename
name|value_type
operator|,
name|support
operator|::
name|endianness
name|endian
operator|,
name|size_t
name|alignment
operator|>
expr|struct
name|ScalarTraits
operator|<
name|support
operator|::
name|detail
operator|::
name|packed_endian_specific_integral
operator|<
name|value_type
operator|,
name|endian
operator|,
name|alignment
operator|>>
block|{
typedef|typedef
name|support
operator|::
name|detail
operator|::
name|packed_endian_specific_integral
operator|<
name|value_type
operator|,
name|endian
operator|,
name|alignment
operator|>
name|endian_type
expr_stmt|;
specifier|static
name|void
name|output
argument_list|(
argument|const endian_type&E
argument_list|,
argument|void *Ctx
argument_list|,
argument|llvm::raw_ostream&Stream
argument_list|)
block|{
name|ScalarTraits
operator|<
name|value_type
operator|>
operator|::
name|output
argument_list|(
name|static_cast
operator|<
name|value_type
operator|>
operator|(
name|E
operator|)
argument_list|,
name|Ctx
argument_list|,
name|Stream
argument_list|)
block|;   }
specifier|static
name|StringRef
name|input
argument_list|(
argument|StringRef Str
argument_list|,
argument|void *Ctx
argument_list|,
argument|endian_type&E
argument_list|)
block|{
name|value_type
name|V
block|;
name|auto
name|R
operator|=
name|ScalarTraits
operator|<
name|value_type
operator|>
operator|::
name|input
argument_list|(
name|Str
argument_list|,
name|Ctx
argument_list|,
name|V
argument_list|)
block|;
name|E
operator|=
name|static_cast
operator|<
name|endian_type
operator|>
operator|(
name|V
operator|)
block|;
return|return
name|R
return|;
block|}
end_expr_stmt

begin_function
specifier|static
name|bool
name|mustQuote
parameter_list|(
name|StringRef
name|Str
parameter_list|)
block|{
return|return
name|ScalarTraits
operator|<
name|value_type
operator|>
operator|::
name|mustQuote
argument_list|(
name|Str
argument_list|)
return|;
block|}
end_function

begin_comment
unit|};
comment|// Utility for use within MappingTraits<>::mapping() method
end_comment

begin_comment
comment|// to [de]normalize an object for use with YAML conversion.
end_comment

begin_expr_stmt
name|template
operator|<
name|typename
name|TNorm
operator|,
name|typename
name|TFinal
operator|>
expr|struct
name|MappingNormalization
block|{
name|MappingNormalization
argument_list|(
name|IO
operator|&
name|i_o
argument_list|,
name|TFinal
operator|&
name|Obj
argument_list|)
operator|:
name|io
argument_list|(
name|i_o
argument_list|)
block|,
name|BufPtr
argument_list|(
name|nullptr
argument_list|)
block|,
name|Result
argument_list|(
argument|Obj
argument_list|)
block|{
if|if
condition|(
name|io
operator|.
name|outputting
argument_list|()
condition|)
block|{
name|BufPtr
operator|=
name|new
argument_list|(
argument|&Buffer
argument_list|)
name|TNorm
argument_list|(
name|io
argument_list|,
name|Obj
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|BufPtr
operator|=
name|new
argument_list|(
argument|&Buffer
argument_list|)
name|TNorm
argument_list|(
name|io
argument_list|)
expr_stmt|;
block|}
end_expr_stmt

begin_macro
unit|}    ~
name|MappingNormalization
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
operator|!
name|io
operator|.
name|outputting
argument_list|()
condition|)
block|{
name|Result
operator|=
name|BufPtr
operator|->
name|denormalize
argument_list|(
name|io
argument_list|)
expr_stmt|;
block|}
name|BufPtr
operator|->
expr|~
name|TNorm
argument_list|()
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|TNorm
operator|*
name|operator
operator|->
expr|(
end_expr_stmt

begin_block
unit|)
block|{
return|return
name|BufPtr
return|;
block|}
end_block

begin_label
name|private
label|:
end_label

begin_typedef
typedef|typedef
name|llvm
operator|::
name|AlignedCharArrayUnion
operator|<
name|TNorm
operator|>
name|Storage
expr_stmt|;
end_typedef

begin_decl_stmt
name|Storage
name|Buffer
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|IO
modifier|&
name|io
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|TNorm
modifier|*
name|BufPtr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|TFinal
modifier|&
name|Result
decl_stmt|;
end_decl_stmt

begin_comment
unit|};
comment|// Utility for use within MappingTraits<>::mapping() method
end_comment

begin_comment
comment|// to [de]normalize an object for use with YAML conversion.
end_comment

begin_expr_stmt
name|template
operator|<
name|typename
name|TNorm
operator|,
name|typename
name|TFinal
operator|>
expr|struct
name|MappingNormalizationHeap
block|{
name|MappingNormalizationHeap
argument_list|(
name|IO
operator|&
name|i_o
argument_list|,
name|TFinal
operator|&
name|Obj
argument_list|,
name|llvm
operator|::
name|BumpPtrAllocator
operator|*
name|allocator
argument_list|)
operator|:
name|io
argument_list|(
name|i_o
argument_list|)
block|,
name|BufPtr
argument_list|(
name|nullptr
argument_list|)
block|,
name|Result
argument_list|(
argument|Obj
argument_list|)
block|{
if|if
condition|(
name|io
operator|.
name|outputting
argument_list|()
condition|)
block|{
name|BufPtr
operator|=
name|new
argument_list|(
argument|&Buffer
argument_list|)
name|TNorm
argument_list|(
name|io
argument_list|,
name|Obj
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|allocator
condition|)
block|{
name|BufPtr
operator|=
name|allocator
operator|->
name|Allocate
operator|<
name|TNorm
operator|>
operator|(
operator|)
expr_stmt|;
name|new
argument_list|(
argument|BufPtr
argument_list|)
name|TNorm
argument_list|(
name|io
argument_list|)
expr_stmt|;
block|}
end_expr_stmt

begin_else
else|else
block|{
name|BufPtr
operator|=
name|new
name|TNorm
argument_list|(
name|io
argument_list|)
expr_stmt|;
block|}
end_else

begin_macro
unit|}    ~
name|MappingNormalizationHeap
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|io
operator|.
name|outputting
argument_list|()
condition|)
block|{
name|BufPtr
operator|->
expr|~
name|TNorm
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|Result
operator|=
name|BufPtr
operator|->
name|denormalize
argument_list|(
name|io
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_expr_stmt
name|TNorm
operator|*
name|operator
operator|->
expr|(
end_expr_stmt

begin_block
unit|)
block|{
return|return
name|BufPtr
return|;
block|}
end_block

begin_label
name|private
label|:
end_label

begin_typedef
typedef|typedef
name|llvm
operator|::
name|AlignedCharArrayUnion
operator|<
name|TNorm
operator|>
name|Storage
expr_stmt|;
end_typedef

begin_decl_stmt
name|Storage
name|Buffer
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|IO
modifier|&
name|io
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|TNorm
modifier|*
name|BufPtr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|TFinal
modifier|&
name|Result
decl_stmt|;
end_decl_stmt

begin_comment
unit|};
comment|///
end_comment

begin_comment
comment|/// The Input class is used to parse a yaml document into in-memory structs
end_comment

begin_comment
comment|/// and vectors.
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|/// It works by using YAMLParser to do a syntax parse of the entire yaml
end_comment

begin_comment
comment|/// document, then the Input class builds a graph of HNodes which wraps
end_comment

begin_comment
comment|/// each yaml Node.  The extra layer is buffering.  The low level yaml
end_comment

begin_comment
comment|/// parser only lets you look at each node once.  The buffering layer lets
end_comment

begin_comment
comment|/// you search and interate multiple times.  This is necessary because
end_comment

begin_comment
comment|/// the mapRequired() method calls may not be in the same order
end_comment

begin_comment
comment|/// as the keys in the document.
end_comment

begin_comment
comment|///
end_comment

begin_decl_stmt
name|class
name|Input
range|:
name|public
name|IO
block|{
name|public
operator|:
comment|// Construct a yaml Input object from a StringRef and optional
comment|// user-data. The DiagHandler can be specified to provide
comment|// alternative error reporting.
name|Input
argument_list|(
argument|StringRef InputContent
argument_list|,
argument|void *Ctxt = nullptr
argument_list|,
argument|SourceMgr::DiagHandlerTy DiagHandler = nullptr
argument_list|,
argument|void *DiagHandlerCtxt = nullptr
argument_list|)
block|;
operator|~
name|Input
argument_list|()
name|override
block|;
comment|// Check if there was an syntax or semantic error during parsing.
name|std
operator|::
name|error_code
name|error
argument_list|()
block|;
name|private
operator|:
name|bool
name|outputting
argument_list|()
name|override
block|;
name|bool
name|mapTag
argument_list|(
argument|StringRef
argument_list|,
argument|bool
argument_list|)
name|override
block|;
name|void
name|beginMapping
argument_list|()
name|override
block|;
name|void
name|endMapping
argument_list|()
name|override
block|;
name|bool
name|preflightKey
argument_list|(
argument|const char *
argument_list|,
argument|bool
argument_list|,
argument|bool
argument_list|,
argument|bool&
argument_list|,
argument|void *&
argument_list|)
name|override
block|;
name|void
name|postflightKey
argument_list|(
argument|void *
argument_list|)
name|override
block|;
name|std
operator|::
name|vector
operator|<
name|StringRef
operator|>
name|keys
argument_list|()
name|override
block|;
name|void
name|beginFlowMapping
argument_list|()
name|override
block|;
name|void
name|endFlowMapping
argument_list|()
name|override
block|;
name|unsigned
name|beginSequence
argument_list|()
name|override
block|;
name|void
name|endSequence
argument_list|()
name|override
block|;
name|bool
name|preflightElement
argument_list|(
argument|unsigned index
argument_list|,
argument|void *&
argument_list|)
name|override
block|;
name|void
name|postflightElement
argument_list|(
argument|void *
argument_list|)
name|override
block|;
name|unsigned
name|beginFlowSequence
argument_list|()
name|override
block|;
name|bool
name|preflightFlowElement
argument_list|(
argument|unsigned
argument_list|,
argument|void *&
argument_list|)
name|override
block|;
name|void
name|postflightFlowElement
argument_list|(
argument|void *
argument_list|)
name|override
block|;
name|void
name|endFlowSequence
argument_list|()
name|override
block|;
name|void
name|beginEnumScalar
argument_list|()
name|override
block|;
name|bool
name|matchEnumScalar
argument_list|(
argument|const char*
argument_list|,
argument|bool
argument_list|)
name|override
block|;
name|bool
name|matchEnumFallback
argument_list|()
name|override
block|;
name|void
name|endEnumScalar
argument_list|()
name|override
block|;
name|bool
name|beginBitSetScalar
argument_list|(
argument|bool&
argument_list|)
name|override
block|;
name|bool
name|bitSetMatch
argument_list|(
argument|const char *
argument_list|,
argument|bool
argument_list|)
name|override
block|;
name|void
name|endBitSetScalar
argument_list|()
name|override
block|;
name|void
name|scalarString
argument_list|(
argument|StringRef&
argument_list|,
argument|bool
argument_list|)
name|override
block|;
name|void
name|blockScalarString
argument_list|(
argument|StringRef&
argument_list|)
name|override
block|;
name|void
name|setError
argument_list|(
argument|const Twine&message
argument_list|)
name|override
block|;
name|bool
name|canElideEmptySequence
argument_list|()
name|override
block|;
name|class
name|HNode
block|{
name|virtual
name|void
name|anchor
argument_list|()
block|;
name|public
operator|:
name|HNode
argument_list|(
name|Node
operator|*
name|n
argument_list|)
operator|:
name|_node
argument_list|(
argument|n
argument_list|)
block|{ }
name|virtual
operator|~
name|HNode
argument_list|()
operator|=
expr|default
block|;
specifier|static
specifier|inline
name|bool
name|classof
argument_list|(
argument|const HNode *
argument_list|)
block|{
return|return
name|true
return|;
block|}
name|Node
operator|*
name|_node
block|;   }
block|;
name|class
name|EmptyHNode
operator|:
name|public
name|HNode
block|{
name|void
name|anchor
argument_list|()
name|override
block|;
name|public
operator|:
name|EmptyHNode
argument_list|(
name|Node
operator|*
name|n
argument_list|)
operator|:
name|HNode
argument_list|(
argument|n
argument_list|)
block|{ }
specifier|static
specifier|inline
name|bool
name|classof
argument_list|(
argument|const HNode *n
argument_list|)
block|{
return|return
name|NullNode
operator|::
name|classof
argument_list|(
name|n
operator|->
name|_node
argument_list|)
return|;
block|}
specifier|static
specifier|inline
name|bool
name|classof
argument_list|(
argument|const EmptyHNode *
argument_list|)
block|{
return|return
name|true
return|;
block|}
expr|}
block|;
name|class
name|ScalarHNode
operator|:
name|public
name|HNode
block|{
name|void
name|anchor
argument_list|()
name|override
block|;
name|public
operator|:
name|ScalarHNode
argument_list|(
argument|Node *n
argument_list|,
argument|StringRef s
argument_list|)
operator|:
name|HNode
argument_list|(
name|n
argument_list|)
block|,
name|_value
argument_list|(
argument|s
argument_list|)
block|{ }
name|StringRef
name|value
argument_list|()
specifier|const
block|{
return|return
name|_value
return|;
block|}
specifier|static
specifier|inline
name|bool
name|classof
argument_list|(
argument|const HNode *n
argument_list|)
block|{
return|return
name|ScalarNode
operator|::
name|classof
argument_list|(
name|n
operator|->
name|_node
argument_list|)
operator|||
name|BlockScalarNode
operator|::
name|classof
argument_list|(
name|n
operator|->
name|_node
argument_list|)
return|;
block|}
specifier|static
specifier|inline
name|bool
name|classof
argument_list|(
argument|const ScalarHNode *
argument_list|)
block|{
return|return
name|true
return|;
block|}
name|protected
operator|:
name|StringRef
name|_value
block|;   }
block|;
name|class
name|MapHNode
operator|:
name|public
name|HNode
block|{
name|void
name|anchor
argument_list|()
name|override
block|;
name|public
operator|:
name|MapHNode
argument_list|(
name|Node
operator|*
name|n
argument_list|)
operator|:
name|HNode
argument_list|(
argument|n
argument_list|)
block|{ }
specifier|static
specifier|inline
name|bool
name|classof
argument_list|(
argument|const HNode *n
argument_list|)
block|{
return|return
name|MappingNode
operator|::
name|classof
argument_list|(
name|n
operator|->
name|_node
argument_list|)
return|;
block|}
specifier|static
specifier|inline
name|bool
name|classof
argument_list|(
argument|const MapHNode *
argument_list|)
block|{
return|return
name|true
return|;
block|}
typedef|typedef
name|llvm
operator|::
name|StringMap
operator|<
name|std
operator|::
name|unique_ptr
operator|<
name|HNode
operator|>>
name|NameToNode
expr_stmt|;
name|NameToNode
name|Mapping
block|;
name|llvm
operator|::
name|SmallVector
operator|<
name|std
operator|::
name|string
block|,
literal|6
operator|>
name|ValidKeys
block|;   }
block|;
name|class
name|SequenceHNode
operator|:
name|public
name|HNode
block|{
name|void
name|anchor
argument_list|()
name|override
block|;
name|public
operator|:
name|SequenceHNode
argument_list|(
name|Node
operator|*
name|n
argument_list|)
operator|:
name|HNode
argument_list|(
argument|n
argument_list|)
block|{ }
specifier|static
specifier|inline
name|bool
name|classof
argument_list|(
argument|const HNode *n
argument_list|)
block|{
return|return
name|SequenceNode
operator|::
name|classof
argument_list|(
name|n
operator|->
name|_node
argument_list|)
return|;
block|}
specifier|static
specifier|inline
name|bool
name|classof
argument_list|(
argument|const SequenceHNode *
argument_list|)
block|{
return|return
name|true
return|;
block|}
name|std
operator|::
name|vector
operator|<
name|std
operator|::
name|unique_ptr
operator|<
name|HNode
operator|>>
name|Entries
block|;   }
block|;
name|std
operator|::
name|unique_ptr
operator|<
name|Input
operator|::
name|HNode
operator|>
name|createHNodes
argument_list|(
name|Node
operator|*
name|node
argument_list|)
block|;
name|void
name|setError
argument_list|(
name|HNode
operator|*
name|hnode
argument_list|,
specifier|const
name|Twine
operator|&
name|message
argument_list|)
block|;
name|void
name|setError
argument_list|(
name|Node
operator|*
name|node
argument_list|,
specifier|const
name|Twine
operator|&
name|message
argument_list|)
block|;
name|public
operator|:
comment|// These are only used by operator>>. They could be private
comment|// if those templated things could be made friends.
name|bool
name|setCurrentDocument
argument_list|()
block|;
name|bool
name|nextDocument
argument_list|()
block|;
comment|/// Returns the current node that's being parsed by the YAML Parser.
specifier|const
name|Node
operator|*
name|getCurrentNode
argument_list|()
specifier|const
block|;
name|private
operator|:
name|llvm
operator|::
name|SourceMgr
name|SrcMgr
block|;
comment|// must be before Strm
name|std
operator|::
name|unique_ptr
operator|<
name|llvm
operator|::
name|yaml
operator|::
name|Stream
operator|>
name|Strm
block|;
name|std
operator|::
name|unique_ptr
operator|<
name|HNode
operator|>
name|TopNode
block|;
name|std
operator|::
name|error_code
name|EC
block|;
name|llvm
operator|::
name|BumpPtrAllocator
name|StringAllocator
block|;
name|llvm
operator|::
name|yaml
operator|::
name|document_iterator
name|DocIterator
block|;
name|std
operator|::
name|vector
operator|<
name|bool
operator|>
name|BitValuesUsed
block|;
name|HNode
operator|*
name|CurrentNode
block|;
name|bool
name|ScalarMatchFound
block|; }
decl_stmt|;
end_decl_stmt

begin_comment
comment|///
end_comment

begin_comment
comment|/// The Output class is used to generate a yaml document from in-memory structs
end_comment

begin_comment
comment|/// and vectors.
end_comment

begin_comment
comment|///
end_comment

begin_decl_stmt
name|class
name|Output
range|:
name|public
name|IO
block|{
name|public
operator|:
name|Output
argument_list|(
argument|llvm::raw_ostream&
argument_list|,
argument|void *Ctxt = nullptr
argument_list|,
argument|int WrapColumn =
literal|70
argument_list|)
block|;
operator|~
name|Output
argument_list|()
name|override
block|;
comment|/// \brief Set whether or not to output optional values which are equal
comment|/// to the default value.  By default, when outputting if you attempt
comment|/// to write a value that is equal to the default, the value gets ignored.
comment|/// Sometimes, it is useful to be able to see these in the resulting YAML
comment|/// anyway.
name|void
name|setWriteDefaultValues
argument_list|(
argument|bool Write
argument_list|)
block|{
name|WriteDefaultValues
operator|=
name|Write
block|; }
name|bool
name|outputting
argument_list|()
name|override
block|;
name|bool
name|mapTag
argument_list|(
argument|StringRef
argument_list|,
argument|bool
argument_list|)
name|override
block|;
name|void
name|beginMapping
argument_list|()
name|override
block|;
name|void
name|endMapping
argument_list|()
name|override
block|;
name|bool
name|preflightKey
argument_list|(
argument|const char *key
argument_list|,
argument|bool
argument_list|,
argument|bool
argument_list|,
argument|bool&
argument_list|,
argument|void *&
argument_list|)
name|override
block|;
name|void
name|postflightKey
argument_list|(
argument|void *
argument_list|)
name|override
block|;
name|std
operator|::
name|vector
operator|<
name|StringRef
operator|>
name|keys
argument_list|()
name|override
block|;
name|void
name|beginFlowMapping
argument_list|()
name|override
block|;
name|void
name|endFlowMapping
argument_list|()
name|override
block|;
name|unsigned
name|beginSequence
argument_list|()
name|override
block|;
name|void
name|endSequence
argument_list|()
name|override
block|;
name|bool
name|preflightElement
argument_list|(
argument|unsigned
argument_list|,
argument|void *&
argument_list|)
name|override
block|;
name|void
name|postflightElement
argument_list|(
argument|void *
argument_list|)
name|override
block|;
name|unsigned
name|beginFlowSequence
argument_list|()
name|override
block|;
name|bool
name|preflightFlowElement
argument_list|(
argument|unsigned
argument_list|,
argument|void *&
argument_list|)
name|override
block|;
name|void
name|postflightFlowElement
argument_list|(
argument|void *
argument_list|)
name|override
block|;
name|void
name|endFlowSequence
argument_list|()
name|override
block|;
name|void
name|beginEnumScalar
argument_list|()
name|override
block|;
name|bool
name|matchEnumScalar
argument_list|(
argument|const char*
argument_list|,
argument|bool
argument_list|)
name|override
block|;
name|bool
name|matchEnumFallback
argument_list|()
name|override
block|;
name|void
name|endEnumScalar
argument_list|()
name|override
block|;
name|bool
name|beginBitSetScalar
argument_list|(
argument|bool&
argument_list|)
name|override
block|;
name|bool
name|bitSetMatch
argument_list|(
argument|const char *
argument_list|,
argument|bool
argument_list|)
name|override
block|;
name|void
name|endBitSetScalar
argument_list|()
name|override
block|;
name|void
name|scalarString
argument_list|(
argument|StringRef&
argument_list|,
argument|bool
argument_list|)
name|override
block|;
name|void
name|blockScalarString
argument_list|(
argument|StringRef&
argument_list|)
name|override
block|;
name|void
name|setError
argument_list|(
argument|const Twine&message
argument_list|)
name|override
block|;
name|bool
name|canElideEmptySequence
argument_list|()
name|override
block|;
comment|// These are only used by operator<<. They could be private
comment|// if that templated operator could be made a friend.
name|void
name|beginDocuments
argument_list|()
block|;
name|bool
name|preflightDocument
argument_list|(
name|unsigned
argument_list|)
block|;
name|void
name|postflightDocument
argument_list|()
block|;
name|void
name|endDocuments
argument_list|()
block|;
name|private
operator|:
name|void
name|output
argument_list|(
argument|StringRef s
argument_list|)
block|;
name|void
name|outputUpToEndOfLine
argument_list|(
argument|StringRef s
argument_list|)
block|;
name|void
name|newLineCheck
argument_list|()
block|;
name|void
name|outputNewLine
argument_list|()
block|;
name|void
name|paddedKey
argument_list|(
argument|StringRef key
argument_list|)
block|;
name|void
name|flowKey
argument_list|(
argument|StringRef Key
argument_list|)
block|;    enum
name|InState
block|{
name|inSeq
block|,
name|inFlowSeq
block|,
name|inMapFirstKey
block|,
name|inMapOtherKey
block|,
name|inFlowMapFirstKey
block|,
name|inFlowMapOtherKey
block|}
block|;
name|llvm
operator|::
name|raw_ostream
operator|&
name|Out
block|;
name|int
name|WrapColumn
block|;
name|SmallVector
operator|<
name|InState
block|,
literal|8
operator|>
name|StateStack
block|;
name|int
name|Column
block|;
name|int
name|ColumnAtFlowStart
block|;
name|int
name|ColumnAtMapFlowStart
block|;
name|bool
name|NeedBitValueComma
block|;
name|bool
name|NeedFlowSequenceComma
block|;
name|bool
name|EnumerationMatchFound
block|;
name|bool
name|NeedsNewLine
block|;
name|bool
name|WriteDefaultValues
block|; }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/// YAML I/O does conversion based on types. But often native data types
end_comment

begin_comment
comment|/// are just a typedef of built in intergral types (e.g. int).  But the C++
end_comment

begin_comment
comment|/// type matching system sees through the typedef and all the typedefed types
end_comment

begin_comment
comment|/// look like a built in type. This will cause the generic YAML I/O conversion
end_comment

begin_comment
comment|/// to be used. To provide better control over the YAML conversion, you can
end_comment

begin_comment
comment|/// use this macro instead of typedef.  It will create a class with one field
end_comment

begin_comment
comment|/// and automatic conversion operators to and from the base type.
end_comment

begin_comment
comment|/// Based on BOOST_STRONG_TYPEDEF
end_comment

begin_define
define|#
directive|define
name|LLVM_YAML_STRONG_TYPEDEF
parameter_list|(
name|_base
parameter_list|,
name|_type
parameter_list|)
define|\
value|struct _type {                                                             \         _type() = default;                                                     \         _type(const _base v) : value(v) {}                                     \         _type(const _type&v) = default;                                       \         _type&operator=(const _type&rhs) = default;                          \         _type&operator=(const _base&rhs) { value = rhs; return *this; }      \         operator const _base& () const { return value; }                      \         bool operator==(const _type&rhs) const { return value == rhs.value; } \         bool operator==(const _base&rhs) const { return value == rhs; }       \         bool operator<(const _type&rhs) const { return value< rhs.value; }   \         _base value;                                                           \         typedef _base BaseType;                                                \     };
end_define

begin_comment
comment|///
end_comment

begin_comment
comment|/// Use these types instead of uintXX_t in any mapping to have
end_comment

begin_comment
comment|/// its yaml output formatted as hexadecimal.
end_comment

begin_comment
comment|///
end_comment

begin_macro
name|LLVM_YAML_STRONG_TYPEDEF
argument_list|(
argument|uint8_t
argument_list|,
argument|Hex8
argument_list|)
end_macro

begin_macro
name|LLVM_YAML_STRONG_TYPEDEF
argument_list|(
argument|uint16_t
argument_list|,
argument|Hex16
argument_list|)
end_macro

begin_macro
name|LLVM_YAML_STRONG_TYPEDEF
argument_list|(
argument|uint32_t
argument_list|,
argument|Hex32
argument_list|)
end_macro

begin_macro
name|LLVM_YAML_STRONG_TYPEDEF
argument_list|(
argument|uint64_t
argument_list|,
argument|Hex64
argument_list|)
end_macro

begin_expr_stmt
name|template
operator|<
operator|>
expr|struct
name|ScalarTraits
operator|<
name|Hex8
operator|>
block|{
specifier|static
name|void
name|output
argument_list|(
specifier|const
name|Hex8
operator|&
argument_list|,
name|void
operator|*
argument_list|,
name|llvm
operator|::
name|raw_ostream
operator|&
argument_list|)
block|;
specifier|static
name|StringRef
name|input
argument_list|(
name|StringRef
argument_list|,
name|void
operator|*
argument_list|,
name|Hex8
operator|&
argument_list|)
block|;
specifier|static
name|bool
name|mustQuote
argument_list|(
argument|StringRef
argument_list|)
block|{
return|return
name|false
return|;
block|}
end_expr_stmt

begin_expr_stmt
unit|};
name|template
operator|<
operator|>
expr|struct
name|ScalarTraits
operator|<
name|Hex16
operator|>
block|{
specifier|static
name|void
name|output
argument_list|(
specifier|const
name|Hex16
operator|&
argument_list|,
name|void
operator|*
argument_list|,
name|llvm
operator|::
name|raw_ostream
operator|&
argument_list|)
block|;
specifier|static
name|StringRef
name|input
argument_list|(
name|StringRef
argument_list|,
name|void
operator|*
argument_list|,
name|Hex16
operator|&
argument_list|)
block|;
specifier|static
name|bool
name|mustQuote
argument_list|(
argument|StringRef
argument_list|)
block|{
return|return
name|false
return|;
block|}
end_expr_stmt

begin_expr_stmt
unit|};
name|template
operator|<
operator|>
expr|struct
name|ScalarTraits
operator|<
name|Hex32
operator|>
block|{
specifier|static
name|void
name|output
argument_list|(
specifier|const
name|Hex32
operator|&
argument_list|,
name|void
operator|*
argument_list|,
name|llvm
operator|::
name|raw_ostream
operator|&
argument_list|)
block|;
specifier|static
name|StringRef
name|input
argument_list|(
name|StringRef
argument_list|,
name|void
operator|*
argument_list|,
name|Hex32
operator|&
argument_list|)
block|;
specifier|static
name|bool
name|mustQuote
argument_list|(
argument|StringRef
argument_list|)
block|{
return|return
name|false
return|;
block|}
end_expr_stmt

begin_expr_stmt
unit|};
name|template
operator|<
operator|>
expr|struct
name|ScalarTraits
operator|<
name|Hex64
operator|>
block|{
specifier|static
name|void
name|output
argument_list|(
specifier|const
name|Hex64
operator|&
argument_list|,
name|void
operator|*
argument_list|,
name|llvm
operator|::
name|raw_ostream
operator|&
argument_list|)
block|;
specifier|static
name|StringRef
name|input
argument_list|(
name|StringRef
argument_list|,
name|void
operator|*
argument_list|,
name|Hex64
operator|&
argument_list|)
block|;
specifier|static
name|bool
name|mustQuote
argument_list|(
argument|StringRef
argument_list|)
block|{
return|return
name|false
return|;
block|}
end_expr_stmt

begin_comment
unit|};
comment|// Define non-member operator>> so that Input can stream in a document list.
end_comment

begin_expr_stmt
name|template
operator|<
name|typename
name|T
operator|>
specifier|inline
name|typename
name|std
operator|::
name|enable_if
operator|<
name|has_DocumentListTraits
operator|<
name|T
operator|>
operator|::
name|value
operator|,
name|Input
operator|&
operator|>
operator|::
name|type
name|operator
operator|>>
operator|(
name|Input
operator|&
name|yin
operator|,
name|T
operator|&
name|docList
operator|)
block|{
name|int
name|i
operator|=
literal|0
block|;
name|EmptyContext
name|Ctx
block|;
while|while
condition|(
name|yin
operator|.
name|setCurrentDocument
argument_list|()
condition|)
block|{
name|yamlize
argument_list|(
name|yin
argument_list|,
name|DocumentListTraits
operator|<
name|T
operator|>
operator|::
name|element
argument_list|(
name|yin
argument_list|,
name|docList
argument_list|,
name|i
argument_list|)
argument_list|,
name|true
argument_list|,
name|Ctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|yin
operator|.
name|error
argument_list|()
condition|)
return|return
name|yin
return|;
name|yin
operator|.
name|nextDocument
argument_list|()
expr_stmt|;
operator|++
name|i
expr_stmt|;
block|}
end_expr_stmt

begin_return
return|return
name|yin
return|;
end_return

begin_comment
unit|}
comment|// Define non-member operator>> so that Input can stream in a map as a document.
end_comment

begin_expr_stmt
unit|template
operator|<
name|typename
name|T
operator|>
specifier|inline
name|typename
name|std
operator|::
name|enable_if
operator|<
name|has_MappingTraits
operator|<
name|T
operator|,
name|EmptyContext
operator|>
operator|::
name|value
operator|,
name|Input
operator|&
operator|>
operator|::
name|type
name|operator
operator|>>
operator|(
name|Input
operator|&
name|yin
operator|,
name|T
operator|&
name|docMap
operator|)
block|{
name|EmptyContext
name|Ctx
block|;
name|yin
operator|.
name|setCurrentDocument
argument_list|()
block|;
name|yamlize
argument_list|(
name|yin
argument_list|,
name|docMap
argument_list|,
name|true
argument_list|,
name|Ctx
argument_list|)
block|;
return|return
name|yin
return|;
block|}
end_expr_stmt

begin_comment
comment|// Define non-member operator>> so that Input can stream in a sequence as
end_comment

begin_comment
comment|// a document.
end_comment

begin_expr_stmt
name|template
operator|<
name|typename
name|T
operator|>
specifier|inline
name|typename
name|std
operator|::
name|enable_if
operator|<
name|has_SequenceTraits
operator|<
name|T
operator|>
operator|::
name|value
operator|,
name|Input
operator|&
operator|>
operator|::
name|type
name|operator
operator|>>
operator|(
name|Input
operator|&
name|yin
operator|,
name|T
operator|&
name|docSeq
operator|)
block|{
name|EmptyContext
name|Ctx
block|;
if|if
condition|(
name|yin
operator|.
name|setCurrentDocument
argument_list|()
condition|)
name|yamlize
argument_list|(
name|yin
argument_list|,
name|docSeq
argument_list|,
name|true
argument_list|,
name|Ctx
argument_list|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|yin
return|;
end_return

begin_comment
unit|}
comment|// Define non-member operator>> so that Input can stream in a block scalar.
end_comment

begin_expr_stmt
unit|template
operator|<
name|typename
name|T
operator|>
specifier|inline
name|typename
name|std
operator|::
name|enable_if
operator|<
name|has_BlockScalarTraits
operator|<
name|T
operator|>
operator|::
name|value
operator|,
name|Input
operator|&
operator|>
operator|::
name|type
name|operator
operator|>>
operator|(
name|Input
operator|&
name|In
operator|,
name|T
operator|&
name|Val
operator|)
block|{
name|EmptyContext
name|Ctx
block|;
if|if
condition|(
name|In
operator|.
name|setCurrentDocument
argument_list|()
condition|)
name|yamlize
argument_list|(
name|In
argument_list|,
name|Val
argument_list|,
name|true
argument_list|,
name|Ctx
argument_list|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|In
return|;
end_return

begin_comment
unit|}
comment|// Define non-member operator>> so that Input can stream in a string map.
end_comment

begin_expr_stmt
unit|template
operator|<
name|typename
name|T
operator|>
specifier|inline
name|typename
name|std
operator|::
name|enable_if
operator|<
name|has_CustomMappingTraits
operator|<
name|T
operator|>
operator|::
name|value
operator|,
name|Input
operator|&
operator|>
operator|::
name|type
name|operator
operator|>>
operator|(
name|Input
operator|&
name|In
operator|,
name|T
operator|&
name|Val
operator|)
block|{
name|EmptyContext
name|Ctx
block|;
if|if
condition|(
name|In
operator|.
name|setCurrentDocument
argument_list|()
condition|)
name|yamlize
argument_list|(
name|In
argument_list|,
name|Val
argument_list|,
name|true
argument_list|,
name|Ctx
argument_list|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|In
return|;
end_return

begin_comment
unit|}
comment|// Provide better error message about types missing a trait specialization
end_comment

begin_expr_stmt
unit|template
operator|<
name|typename
name|T
operator|>
specifier|inline
name|typename
name|std
operator|::
name|enable_if
operator|<
name|missingTraits
operator|<
name|T
operator|,
name|EmptyContext
operator|>
operator|::
name|value
operator|,
name|Input
operator|&
operator|>
operator|::
name|type
name|operator
operator|>>
operator|(
name|Input
operator|&
name|yin
operator|,
name|T
operator|&
name|docSeq
operator|)
block|{
name|char
name|missing_yaml_trait_for_type
index|[
sizeof|sizeof
argument_list|(
name|MissingTrait
operator|<
name|T
operator|>
argument_list|)
index|]
block|;
return|return
name|yin
return|;
block|}
end_expr_stmt

begin_comment
comment|// Define non-member operator<< so that Output can stream out document list.
end_comment

begin_expr_stmt
name|template
operator|<
name|typename
name|T
operator|>
specifier|inline
name|typename
name|std
operator|::
name|enable_if
operator|<
name|has_DocumentListTraits
operator|<
name|T
operator|>
operator|::
name|value
operator|,
name|Output
operator|&
operator|>
operator|::
name|type
name|operator
operator|<<
operator|(
name|Output
operator|&
name|yout
operator|,
name|T
operator|&
name|docList
operator|)
block|{
name|EmptyContext
name|Ctx
block|;
name|yout
operator|.
name|beginDocuments
argument_list|()
block|;
specifier|const
name|size_t
name|count
operator|=
name|DocumentListTraits
operator|<
name|T
operator|>
operator|::
name|size
argument_list|(
name|yout
argument_list|,
name|docList
argument_list|)
block|;
for|for
control|(
name|size_t
name|i
init|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|yout
operator|.
name|preflightDocument
argument_list|(
name|i
argument_list|)
condition|)
block|{
name|yamlize
argument_list|(
name|yout
argument_list|,
name|DocumentListTraits
operator|<
name|T
operator|>
operator|::
name|element
argument_list|(
name|yout
argument_list|,
name|docList
argument_list|,
name|i
argument_list|)
argument_list|,
name|true
argument_list|,
name|Ctx
argument_list|)
expr_stmt|;
name|yout
operator|.
name|postflightDocument
argument_list|()
expr_stmt|;
block|}
end_expr_stmt

begin_expr_stmt
unit|}   yout
operator|.
name|endDocuments
argument_list|()
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|yout
return|;
end_return

begin_comment
unit|}
comment|// Define non-member operator<< so that Output can stream out a map.
end_comment

begin_expr_stmt
unit|template
operator|<
name|typename
name|T
operator|>
specifier|inline
name|typename
name|std
operator|::
name|enable_if
operator|<
name|has_MappingTraits
operator|<
name|T
operator|,
name|EmptyContext
operator|>
operator|::
name|value
operator|,
name|Output
operator|&
operator|>
operator|::
name|type
name|operator
operator|<<
operator|(
name|Output
operator|&
name|yout
operator|,
name|T
operator|&
name|map
operator|)
block|{
name|EmptyContext
name|Ctx
block|;
name|yout
operator|.
name|beginDocuments
argument_list|()
block|;
if|if
condition|(
name|yout
operator|.
name|preflightDocument
argument_list|(
literal|0
argument_list|)
condition|)
block|{
name|yamlize
argument_list|(
name|yout
argument_list|,
name|map
argument_list|,
name|true
argument_list|,
name|Ctx
argument_list|)
expr_stmt|;
name|yout
operator|.
name|postflightDocument
argument_list|()
expr_stmt|;
block|}
name|yout
operator|.
name|endDocuments
argument_list|()
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|yout
return|;
end_return

begin_comment
unit|}
comment|// Define non-member operator<< so that Output can stream out a sequence.
end_comment

begin_expr_stmt
unit|template
operator|<
name|typename
name|T
operator|>
specifier|inline
name|typename
name|std
operator|::
name|enable_if
operator|<
name|has_SequenceTraits
operator|<
name|T
operator|>
operator|::
name|value
operator|,
name|Output
operator|&
operator|>
operator|::
name|type
name|operator
operator|<<
operator|(
name|Output
operator|&
name|yout
operator|,
name|T
operator|&
name|seq
operator|)
block|{
name|EmptyContext
name|Ctx
block|;
name|yout
operator|.
name|beginDocuments
argument_list|()
block|;
if|if
condition|(
name|yout
operator|.
name|preflightDocument
argument_list|(
literal|0
argument_list|)
condition|)
block|{
name|yamlize
argument_list|(
name|yout
argument_list|,
name|seq
argument_list|,
name|true
argument_list|,
name|Ctx
argument_list|)
expr_stmt|;
name|yout
operator|.
name|postflightDocument
argument_list|()
expr_stmt|;
block|}
name|yout
operator|.
name|endDocuments
argument_list|()
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|yout
return|;
end_return

begin_comment
unit|}
comment|// Define non-member operator<< so that Output can stream out a block scalar.
end_comment

begin_expr_stmt
unit|template
operator|<
name|typename
name|T
operator|>
specifier|inline
name|typename
name|std
operator|::
name|enable_if
operator|<
name|has_BlockScalarTraits
operator|<
name|T
operator|>
operator|::
name|value
operator|,
name|Output
operator|&
operator|>
operator|::
name|type
name|operator
operator|<<
operator|(
name|Output
operator|&
name|Out
operator|,
name|T
operator|&
name|Val
operator|)
block|{
name|EmptyContext
name|Ctx
block|;
name|Out
operator|.
name|beginDocuments
argument_list|()
block|;
if|if
condition|(
name|Out
operator|.
name|preflightDocument
argument_list|(
literal|0
argument_list|)
condition|)
block|{
name|yamlize
argument_list|(
name|Out
argument_list|,
name|Val
argument_list|,
name|true
argument_list|,
name|Ctx
argument_list|)
expr_stmt|;
name|Out
operator|.
name|postflightDocument
argument_list|()
expr_stmt|;
block|}
name|Out
operator|.
name|endDocuments
argument_list|()
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|Out
return|;
end_return

begin_comment
unit|}
comment|// Define non-member operator<< so that Output can stream out a string map.
end_comment

begin_expr_stmt
unit|template
operator|<
name|typename
name|T
operator|>
specifier|inline
name|typename
name|std
operator|::
name|enable_if
operator|<
name|has_CustomMappingTraits
operator|<
name|T
operator|>
operator|::
name|value
operator|,
name|Output
operator|&
operator|>
operator|::
name|type
name|operator
operator|<<
operator|(
name|Output
operator|&
name|Out
operator|,
name|T
operator|&
name|Val
operator|)
block|{
name|EmptyContext
name|Ctx
block|;
name|Out
operator|.
name|beginDocuments
argument_list|()
block|;
if|if
condition|(
name|Out
operator|.
name|preflightDocument
argument_list|(
literal|0
argument_list|)
condition|)
block|{
name|yamlize
argument_list|(
name|Out
argument_list|,
name|Val
argument_list|,
name|true
argument_list|,
name|Ctx
argument_list|)
expr_stmt|;
name|Out
operator|.
name|postflightDocument
argument_list|()
expr_stmt|;
block|}
name|Out
operator|.
name|endDocuments
argument_list|()
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|Out
return|;
end_return

begin_comment
unit|}
comment|// Provide better error message about types missing a trait specialization
end_comment

begin_expr_stmt
unit|template
operator|<
name|typename
name|T
operator|>
specifier|inline
name|typename
name|std
operator|::
name|enable_if
operator|<
name|missingTraits
operator|<
name|T
operator|,
name|EmptyContext
operator|>
operator|::
name|value
operator|,
name|Output
operator|&
operator|>
operator|::
name|type
name|operator
operator|<<
operator|(
name|Output
operator|&
name|yout
operator|,
name|T
operator|&
name|seq
operator|)
block|{
name|char
name|missing_yaml_trait_for_type
index|[
sizeof|sizeof
argument_list|(
name|MissingTrait
operator|<
name|T
operator|>
argument_list|)
index|]
block|;
return|return
name|yout
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|T
operator|>
expr|struct
name|SequenceTraitsImpl
block|{
typedef|typedef
name|typename
name|T
operator|::
name|value_type
name|_type
expr_stmt|;
specifier|static
name|size_t
name|size
argument_list|(
argument|IO&io
argument_list|,
argument|T&seq
argument_list|)
block|{
return|return
name|seq
operator|.
name|size
argument_list|()
return|;
block|}
specifier|static
name|_type
operator|&
name|element
argument_list|(
argument|IO&io
argument_list|,
argument|T&seq
argument_list|,
argument|size_t index
argument_list|)
block|{
if|if
condition|(
name|index
operator|>=
name|seq
operator|.
name|size
argument_list|()
condition|)
name|seq
operator|.
name|resize
argument_list|(
name|index
operator|+
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|seq
index|[
name|index
index|]
return|;
end_return

begin_empty_stmt
unit|} }
empty_stmt|;
end_empty_stmt

begin_comment
comment|/// Implementation of CustomMappingTraits for std::map<std::string, T>.
end_comment

begin_expr_stmt
name|template
operator|<
name|typename
name|T
operator|>
expr|struct
name|StdMapStringCustomMappingTraitsImpl
block|{
typedef|typedef
name|std
operator|::
name|map
operator|<
name|std
operator|::
name|string
operator|,
name|T
operator|>
name|map_type
expr_stmt|;
specifier|static
name|void
name|inputOne
argument_list|(
argument|IO&io
argument_list|,
argument|StringRef key
argument_list|,
argument|map_type&v
argument_list|)
block|{
name|io
operator|.
name|mapRequired
argument_list|(
name|key
operator|.
name|str
argument_list|()
operator|.
name|c_str
argument_list|()
argument_list|,
name|v
index|[
name|key
index|]
argument_list|)
block|;   }
specifier|static
name|void
name|output
argument_list|(
argument|IO&io
argument_list|,
argument|map_type&v
argument_list|)
block|{
for|for
control|(
name|auto
operator|&
name|p
operator|:
name|v
control|)
name|io
operator|.
name|mapRequired
argument_list|(
name|p
operator|.
name|first
operator|.
name|c_str
argument_list|()
argument_list|,
name|p
operator|.
name|second
argument_list|)
expr_stmt|;
block|}
end_expr_stmt

begin_comment
unit|};  }
comment|// end namespace yaml
end_comment

begin_comment
unit|}
comment|// end namespace llvm
end_comment

begin_comment
comment|/// Utility for declaring that a std::vector of a particular type
end_comment

begin_comment
comment|/// should be considered a YAML sequence.
end_comment

begin_define
define|#
directive|define
name|LLVM_YAML_IS_SEQUENCE_VECTOR
parameter_list|(
name|_type
parameter_list|)
define|\
value|namespace llvm {                                                             \   namespace yaml {                                                             \   template<>                                                                  \   struct SequenceTraits<std::vector<_type>>                                    \       : public SequenceTraitsImpl<std::vector<_type>> {};                      \   template<unsigned N>                                                        \   struct SequenceTraits<SmallVector<_type, N>>                                 \       : public SequenceTraitsImpl<SmallVector<_type, N>> {};                   \   }                                                                            \   }
end_define

begin_comment
comment|/// Utility for declaring that a std::vector of a particular type
end_comment

begin_comment
comment|/// should be considered a YAML flow sequence.
end_comment

begin_comment
comment|/// We need to do a partial specialization on the vector version, not a full.
end_comment

begin_comment
comment|/// If this is a full specialization, the compiler is a bit too "smart" and
end_comment

begin_comment
comment|/// decides to warn on -Wunused-const-variable.  This workaround can be
end_comment

begin_comment
comment|/// removed and we can do a full specialization on std::vector<T> once
end_comment

begin_comment
comment|/// PR28878 is fixed.
end_comment

begin_define
define|#
directive|define
name|LLVM_YAML_IS_FLOW_SEQUENCE_VECTOR
parameter_list|(
name|_type
parameter_list|)
define|\
value|namespace llvm {                                                             \   namespace yaml {                                                             \   template<unsigned N>                                                        \   struct SequenceTraits<SmallVector<_type, N>>                                 \       : public SequenceTraitsImpl<SmallVector<_type, N>> {                     \     static const bool flow = true;                                             \   };                                                                           \   template<typename Allocator>                                                \   struct SequenceTraits<std::vector<_type, Allocator>>                         \       : public SequenceTraitsImpl<std::vector<_type, Allocator>> {             \     static const bool flow = true;                                             \   };                                                                           \   }                                                                            \   }
end_define

begin_comment
comment|/// Utility for declaring that a std::vector of a particular type
end_comment

begin_comment
comment|/// should be considered a YAML document list.
end_comment

begin_define
define|#
directive|define
name|LLVM_YAML_IS_DOCUMENT_LIST_VECTOR
parameter_list|(
name|_type
parameter_list|)
define|\
value|namespace llvm {                                                             \   namespace yaml {                                                             \   template<unsigned N>                                                        \   struct DocumentListTraits<SmallVector<_type, N>>                             \       : public SequenceTraitsImpl<SmallVector<_type, N>> {};                   \   template<>                                                                  \   struct DocumentListTraits<std::vector<_type>>                                \       : public SequenceTraitsImpl<std::vector<_type>> {};                      \   }                                                                            \   }
end_define

begin_comment
comment|/// Utility for declaring that std::map<std::string, _type> should be considered
end_comment

begin_comment
comment|/// a YAML map.
end_comment

begin_define
define|#
directive|define
name|LLVM_YAML_IS_STRING_MAP
parameter_list|(
name|_type
parameter_list|)
define|\
value|namespace llvm {                                                             \   namespace yaml {                                                             \   template<>                                                                  \   struct CustomMappingTraits<std::map<std::string, _type>>                     \       : public StdMapStringCustomMappingTraitsImpl<_type> {};                  \   }                                                                            \   }
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|// LLVM_SUPPORT_YAMLTRAITS_H
end_comment

end_unit

