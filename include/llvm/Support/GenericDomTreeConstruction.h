begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===- GenericDomTreeConstruction.h - Dominator Calculation ------*- C++ -*-==//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|/// \file
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|/// Generic dominator tree construction - This file provides routines to
end_comment

begin_comment
comment|/// construct immediate dominator information for a flow-graph based on the
end_comment

begin_comment
comment|/// Semi-NCA algorithm described in this dissertation:
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|///   Linear-Time Algorithms for Dominators and Related Problems
end_comment

begin_comment
comment|///   Loukas Georgiadis, Princeton University, November 2005, pp. 21-23:
end_comment

begin_comment
comment|///   ftp://ftp.cs.princeton.edu/reports/2005/737.pdf
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|/// This implements the O(n*log(n)) versions of EVAL and LINK, because it turns
end_comment

begin_comment
comment|/// out that the theoretically slower O(n*log(n)) implementation is actually
end_comment

begin_comment
comment|/// faster than the almost-linear O(n*alpha(n)) version, even for large CFGs.
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LLVM_SUPPORT_GENERICDOMTREECONSTRUCTION_H
end_ifndef

begin_define
define|#
directive|define
name|LLVM_SUPPORT_GENERICDOMTREECONSTRUCTION_H
end_define

begin_include
include|#
directive|include
file|"llvm/ADT/DepthFirstIterator.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/SmallPtrSet.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/GenericDomTree.h"
end_include

begin_decl_stmt
name|namespace
name|llvm
block|{
name|namespace
name|DomTreeBuilder
block|{
name|template
operator|<
name|typename
name|NodePtr
operator|,
name|bool
name|Inverse
operator|>
expr|struct
name|ChildrenGetter
block|{
specifier|static
name|auto
name|Get
argument_list|(
argument|NodePtr N
argument_list|)
operator|->
name|decltype
argument_list|(
argument|reverse(children<NodePtr>(N))
argument_list|)
block|{
return|return
name|reverse
argument_list|(
name|children
operator|<
name|NodePtr
operator|>
operator|(
name|N
operator|)
argument_list|)
return|;
block|}
expr|}
block|;
name|template
operator|<
name|typename
name|NodePtr
operator|>
expr|struct
name|ChildrenGetter
operator|<
name|NodePtr
block|,
name|true
operator|>
block|{
specifier|static
name|auto
name|Get
argument_list|(
argument|NodePtr N
argument_list|)
operator|->
name|decltype
argument_list|(
argument|inverse_children<NodePtr>(N)
argument_list|)
block|{
return|return
name|inverse_children
operator|<
name|NodePtr
operator|>
operator|(
name|N
operator|)
return|;
block|}
expr|}
block|;
comment|// Information record used by Semi-NCA during tree construction.
name|template
operator|<
name|typename
name|NodeT
operator|>
expr|struct
name|SemiNCAInfo
block|{
name|using
name|NodePtr
operator|=
name|NodeT
operator|*
block|;
name|using
name|DomTreeT
operator|=
name|DominatorTreeBase
operator|<
name|NodeT
operator|>
block|;
name|using
name|TreeNodePtr
operator|=
name|DomTreeNodeBase
operator|<
name|NodeT
operator|>
operator|*
block|;    struct
name|InfoRec
block|{
name|unsigned
name|DFSNum
operator|=
literal|0
block|;
name|unsigned
name|Parent
operator|=
literal|0
block|;
name|unsigned
name|Semi
operator|=
literal|0
block|;
name|NodePtr
name|Label
operator|=
name|nullptr
block|;
name|NodePtr
name|IDom
operator|=
name|nullptr
block|;
name|SmallVector
operator|<
name|NodePtr
block|,
literal|2
operator|>
name|ReverseChildren
block|;   }
block|;
name|std
operator|::
name|vector
operator|<
name|NodePtr
operator|>
name|NumToNode
block|;
name|DenseMap
operator|<
name|NodePtr
block|,
name|InfoRec
operator|>
name|NodeToInfo
block|;
name|void
name|clear
argument_list|()
block|{
name|NumToNode
operator|.
name|clear
argument_list|()
block|;
name|NodeToInfo
operator|.
name|clear
argument_list|()
block|;   }
name|NodePtr
name|getIDom
argument_list|(
argument|NodePtr BB
argument_list|)
specifier|const
block|{
name|auto
name|InfoIt
operator|=
name|NodeToInfo
operator|.
name|find
argument_list|(
name|BB
argument_list|)
block|;
if|if
condition|(
name|InfoIt
operator|==
name|NodeToInfo
operator|.
name|end
argument_list|()
condition|)
return|return
name|nullptr
return|;
return|return
name|InfoIt
operator|->
name|second
operator|.
name|IDom
return|;
block|}
name|TreeNodePtr
name|getNodeForBlock
argument_list|(
argument|NodePtr BB
argument_list|,
argument|DomTreeT&DT
argument_list|)
block|{
if|if
condition|(
name|TreeNodePtr
name|Node
init|=
name|DT
operator|.
name|getNode
argument_list|(
name|BB
argument_list|)
condition|)
return|return
name|Node
return|;
comment|// Haven't calculated this node yet?  Get or calculate the node for the
comment|// immediate dominator.
name|NodePtr
name|IDom
operator|=
name|getIDom
argument_list|(
name|BB
argument_list|)
block|;
name|assert
argument_list|(
name|IDom
operator|||
name|DT
operator|.
name|DomTreeNodes
index|[
name|nullptr
index|]
argument_list|)
block|;
name|TreeNodePtr
name|IDomNode
operator|=
name|getNodeForBlock
argument_list|(
name|IDom
argument_list|,
name|DT
argument_list|)
block|;
comment|// Add a new tree node for this NodeT, and link it as a child of
comment|// IDomNode
return|return
operator|(
name|DT
operator|.
name|DomTreeNodes
index|[
name|BB
index|]
operator|=
name|IDomNode
operator|->
name|addChild
argument_list|(
name|llvm
operator|::
name|make_unique
operator|<
name|DomTreeNodeBase
operator|<
name|NodeT
operator|>>
operator|(
name|BB
operator|,
name|IDomNode
operator|)
argument_list|)
operator|)
operator|.
name|get
argument_list|()
return|;
block|}
specifier|static
name|bool
name|AlwaysDescend
argument_list|(
argument|NodePtr
argument_list|,
argument|NodePtr
argument_list|)
block|{
return|return
name|true
return|;
block|}
comment|// Custom DFS implementation which can skip nodes based on a provided
comment|// predicate. It also collects ReverseChildren so that we don't have to spend
comment|// time getting predecessors in SemiNCA.
name|template
operator|<
name|bool
name|Inverse
block|,
name|typename
name|DescendCondition
operator|>
name|unsigned
name|runDFS
argument_list|(
argument|NodePtr V
argument_list|,
argument|unsigned LastNum
argument_list|,
argument|DescendCondition Condition
argument_list|,
argument|unsigned AttachToNum
argument_list|)
block|{
name|assert
argument_list|(
name|V
argument_list|)
block|;
name|SmallVector
operator|<
name|NodePtr
block|,
literal|64
operator|>
name|WorkList
operator|=
block|{
name|V
block|}
block|;
if|if
condition|(
name|NodeToInfo
operator|.
name|count
argument_list|(
name|V
argument_list|)
operator|!=
literal|0
condition|)
name|NodeToInfo
index|[
name|V
index|]
operator|.
name|Parent
operator|=
name|AttachToNum
expr_stmt|;
while|while
condition|(
operator|!
name|WorkList
operator|.
name|empty
argument_list|()
condition|)
block|{
specifier|const
name|NodePtr
name|BB
init|=
name|WorkList
operator|.
name|pop_back_val
argument_list|()
decl_stmt|;
name|auto
operator|&
name|BBInfo
operator|=
name|NodeToInfo
index|[
name|BB
index|]
expr_stmt|;
comment|// Visited nodes always have positive DFS numbers.
if|if
condition|(
name|BBInfo
operator|.
name|DFSNum
operator|!=
literal|0
condition|)
continue|continue;
name|BBInfo
operator|.
name|DFSNum
operator|=
name|BBInfo
operator|.
name|Semi
operator|=
operator|++
name|LastNum
expr_stmt|;
name|BBInfo
operator|.
name|Label
operator|=
name|BB
expr_stmt|;
name|NumToNode
operator|.
name|push_back
argument_list|(
name|BB
argument_list|)
expr_stmt|;
for|for
control|(
specifier|const
name|NodePtr
name|Succ
range|:
name|ChildrenGetter
operator|<
name|NodePtr
init|,
name|Inverse
decl|>::
name|Get
argument_list|(
name|BB
argument_list|)
control|)
block|{
specifier|const
specifier|auto
name|SIT
init|=
name|NodeToInfo
operator|.
name|find
argument_list|(
name|Succ
argument_list|)
decl_stmt|;
comment|// Don't visit nodes more than once but remember to collect
comment|// RerverseChildren.
if|if
condition|(
name|SIT
operator|!=
name|NodeToInfo
operator|.
name|end
argument_list|()
operator|&&
name|SIT
operator|->
name|second
operator|.
name|DFSNum
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|Succ
operator|!=
name|BB
condition|)
name|SIT
operator|->
name|second
operator|.
name|ReverseChildren
operator|.
name|push_back
argument_list|(
name|BB
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|!
name|Condition
argument_list|(
name|BB
argument_list|,
name|Succ
argument_list|)
condition|)
continue|continue;
comment|// It's fine to add Succ to the map, because we know that it will be
comment|// visited later.
name|auto
operator|&
name|SuccInfo
operator|=
name|NodeToInfo
index|[
name|Succ
index|]
expr_stmt|;
name|WorkList
operator|.
name|push_back
argument_list|(
name|Succ
argument_list|)
expr_stmt|;
name|SuccInfo
operator|.
name|Parent
operator|=
name|LastNum
expr_stmt|;
name|SuccInfo
operator|.
name|ReverseChildren
operator|.
name|push_back
argument_list|(
name|BB
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|LastNum
return|;
block|}
name|NodePtr
name|eval
parameter_list|(
name|NodePtr
name|VIn
parameter_list|,
name|unsigned
name|LastLinked
parameter_list|)
block|{
name|auto
operator|&
name|VInInfo
operator|=
name|NodeToInfo
index|[
name|VIn
index|]
expr_stmt|;
if|if
condition|(
name|VInInfo
operator|.
name|DFSNum
operator|<
name|LastLinked
condition|)
return|return
name|VIn
return|;
name|SmallVector
operator|<
name|NodePtr
operator|,
literal|32
operator|>
name|Work
expr_stmt|;
name|SmallPtrSet
operator|<
name|NodePtr
operator|,
literal|32
operator|>
name|Visited
expr_stmt|;
if|if
condition|(
name|VInInfo
operator|.
name|Parent
operator|>=
name|LastLinked
condition|)
name|Work
operator|.
name|push_back
argument_list|(
name|VIn
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|Work
operator|.
name|empty
argument_list|()
condition|)
block|{
name|NodePtr
name|V
init|=
name|Work
operator|.
name|back
argument_list|()
decl_stmt|;
name|auto
operator|&
name|VInfo
operator|=
name|NodeToInfo
index|[
name|V
index|]
expr_stmt|;
name|NodePtr
name|VAncestor
init|=
name|NumToNode
index|[
name|VInfo
operator|.
name|Parent
index|]
decl_stmt|;
comment|// Process Ancestor first
if|if
condition|(
name|Visited
operator|.
name|insert
argument_list|(
name|VAncestor
argument_list|)
operator|.
name|second
operator|&&
name|VInfo
operator|.
name|Parent
operator|>=
name|LastLinked
condition|)
block|{
name|Work
operator|.
name|push_back
argument_list|(
name|VAncestor
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|Work
operator|.
name|pop_back
argument_list|()
expr_stmt|;
comment|// Update VInfo based on Ancestor info
if|if
condition|(
name|VInfo
operator|.
name|Parent
operator|<
name|LastLinked
condition|)
continue|continue;
name|auto
operator|&
name|VAInfo
operator|=
name|NodeToInfo
index|[
name|VAncestor
index|]
expr_stmt|;
name|NodePtr
name|VAncestorLabel
init|=
name|VAInfo
operator|.
name|Label
decl_stmt|;
name|NodePtr
name|VLabel
init|=
name|VInfo
operator|.
name|Label
decl_stmt|;
if|if
condition|(
name|NodeToInfo
index|[
name|VAncestorLabel
index|]
operator|.
name|Semi
operator|<
name|NodeToInfo
index|[
name|VLabel
index|]
operator|.
name|Semi
condition|)
name|VInfo
operator|.
name|Label
operator|=
name|VAncestorLabel
expr_stmt|;
name|VInfo
operator|.
name|Parent
operator|=
name|VAInfo
operator|.
name|Parent
expr_stmt|;
block|}
return|return
name|VInInfo
operator|.
name|Label
return|;
block|}
name|template
operator|<
name|typename
name|NodeType
operator|>
name|void
name|runSemiNCA
argument_list|(
argument|DomTreeT&DT
argument_list|,
argument|unsigned NumBlocks
argument_list|)
block|{
comment|// Step #1: Number blocks in depth-first order and initialize variables used
comment|// in later stages of the algorithm.
specifier|const
name|unsigned
name|N
operator|=
name|doFullDFSWalk
argument_list|(
name|DT
argument_list|,
name|AlwaysDescend
argument_list|)
block|;
comment|// It might be that some blocks did not get a DFS number (e.g., blocks of
comment|// infinite loops). In these cases an artificial exit node is required.
specifier|const
name|bool
name|MultipleRoots
operator|=
name|DT
operator|.
name|Roots
operator|.
name|size
argument_list|()
operator|>
literal|1
operator|||
operator|(
name|DT
operator|.
name|isPostDominator
argument_list|()
operator|&&
name|N
operator|!=
name|NumBlocks
operator|)
block|;
comment|// Initialize IDoms to spanning tree parents.
for|for
control|(
name|unsigned
name|i
init|=
literal|1
init|;
name|i
operator|<=
name|N
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|NodePtr
name|V
init|=
name|NumToNode
index|[
name|i
index|]
decl_stmt|;
name|auto
operator|&
name|VInfo
operator|=
name|NodeToInfo
index|[
name|V
index|]
expr_stmt|;
name|VInfo
operator|.
name|IDom
operator|=
name|NumToNode
index|[
name|VInfo
operator|.
name|Parent
index|]
expr_stmt|;
block|}
comment|// Step #2: Calculate the semidominators of all vertices.
for|for
control|(
name|unsigned
name|i
init|=
name|N
init|;
name|i
operator|>=
literal|2
condition|;
operator|--
name|i
control|)
block|{
name|NodePtr
name|W
init|=
name|NumToNode
index|[
name|i
index|]
decl_stmt|;
name|auto
operator|&
name|WInfo
operator|=
name|NodeToInfo
index|[
name|W
index|]
expr_stmt|;
comment|// Initialize the semi dominator to point to the parent node.
name|WInfo
operator|.
name|Semi
operator|=
name|WInfo
operator|.
name|Parent
expr_stmt|;
for|for
control|(
specifier|const
specifier|auto
modifier|&
name|N
range|:
name|WInfo
operator|.
name|ReverseChildren
control|)
if|if
condition|(
name|NodeToInfo
operator|.
name|count
argument_list|(
name|N
argument_list|)
condition|)
block|{
comment|// Only if this predecessor is reachable!
name|unsigned
name|SemiU
init|=
name|NodeToInfo
index|[
name|eval
argument_list|(
name|N
argument_list|,
name|i
operator|+
literal|1
argument_list|)
index|]
operator|.
name|Semi
decl_stmt|;
if|if
condition|(
name|SemiU
operator|<
name|WInfo
operator|.
name|Semi
condition|)
name|WInfo
operator|.
name|Semi
operator|=
name|SemiU
expr_stmt|;
block|}
block|}
comment|// Step #3: Explicitly define the immediate dominator of each vertex.
comment|//          IDom[i] = NCA(SDom[i], SpanningTreeParent(i)).
comment|// Note that the parents were stored in IDoms and later got invalidated
comment|// during path compression in Eval.
for|for
control|(
name|unsigned
name|i
init|=
literal|2
init|;
name|i
operator|<=
name|N
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|NodePtr
name|W
init|=
name|NumToNode
index|[
name|i
index|]
decl_stmt|;
name|auto
operator|&
name|WInfo
operator|=
name|NodeToInfo
index|[
name|W
index|]
expr_stmt|;
specifier|const
name|unsigned
name|SDomNum
init|=
name|NodeToInfo
index|[
name|NumToNode
index|[
name|WInfo
operator|.
name|Semi
index|]
index|]
operator|.
name|DFSNum
decl_stmt|;
name|NodePtr
name|WIDomCandidate
init|=
name|WInfo
operator|.
name|IDom
decl_stmt|;
while|while
condition|(
name|NodeToInfo
index|[
name|WIDomCandidate
index|]
operator|.
name|DFSNum
operator|>
name|SDomNum
condition|)
name|WIDomCandidate
operator|=
name|NodeToInfo
index|[
name|WIDomCandidate
index|]
operator|.
name|IDom
expr_stmt|;
name|WInfo
operator|.
name|IDom
operator|=
name|WIDomCandidate
expr_stmt|;
block|}
if|if
condition|(
name|DT
operator|.
name|Roots
operator|.
name|empty
argument_list|()
condition|)
return|return;
comment|// Add a node for the root.  This node might be the actual root, if there is
comment|// one exit block, or it may be the virtual exit (denoted by
comment|// (BasicBlock *)0) which postdominates all real exits if there are multiple
comment|// exit blocks, or an infinite loop.
name|NodePtr
name|Root
operator|=
operator|!
name|MultipleRoots
condition|?
name|DT
operator|.
name|Roots
index|[
literal|0
index|]
else|:
name|nullptr
expr_stmt|;
name|DT
operator|.
name|RootNode
operator|=
operator|(
name|DT
operator|.
name|DomTreeNodes
index|[
name|Root
index|]
operator|=
name|llvm
operator|::
name|make_unique
operator|<
name|DomTreeNodeBase
operator|<
name|NodeT
operator|>>
operator|(
name|Root
operator|,
name|nullptr
operator|)
operator|)
operator|.
name|get
argument_list|()
expr_stmt|;
comment|// Loop over all of the reachable blocks in the function...
for|for
control|(
name|unsigned
name|i
init|=
literal|2
init|;
name|i
operator|<=
name|N
condition|;
operator|++
name|i
control|)
block|{
name|NodePtr
name|W
init|=
name|NumToNode
index|[
name|i
index|]
decl_stmt|;
comment|// Don't replace this with 'count', the insertion side effect is important
if|if
condition|(
name|DT
operator|.
name|DomTreeNodes
index|[
name|W
index|]
condition|)
continue|continue;
comment|// Haven't calculated this node yet?
name|NodePtr
name|ImmDom
init|=
name|getIDom
argument_list|(
name|W
argument_list|)
decl_stmt|;
name|assert
argument_list|(
name|ImmDom
operator|||
name|DT
operator|.
name|DomTreeNodes
index|[
name|nullptr
index|]
argument_list|)
expr_stmt|;
comment|// Get or calculate the node for the immediate dominator
name|TreeNodePtr
name|IDomNode
init|=
name|getNodeForBlock
argument_list|(
name|ImmDom
argument_list|,
name|DT
argument_list|)
decl_stmt|;
comment|// Add a new tree node for this BasicBlock, and link it as a child of
comment|// IDomNode
name|DT
operator|.
name|DomTreeNodes
index|[
name|W
index|]
operator|=
name|IDomNode
operator|->
name|addChild
argument_list|(
name|llvm
operator|::
name|make_unique
operator|<
name|DomTreeNodeBase
operator|<
name|NodeT
operator|>>
operator|(
name|W
operator|,
name|IDomNode
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
name|template
operator|<
name|typename
name|DescendCondition
operator|>
name|unsigned
name|doFullDFSWalk
argument_list|(
argument|const DomTreeT&DT
argument_list|,
argument|DescendCondition DC
argument_list|)
block|{
name|unsigned
name|Num
operator|=
literal|0
block|;
name|NumToNode
operator|.
name|push_back
argument_list|(
name|nullptr
argument_list|)
block|;
if|if
condition|(
name|DT
operator|.
name|Roots
operator|.
name|size
argument_list|()
operator|>
literal|1
condition|)
block|{
name|auto
operator|&
name|BBInfo
operator|=
name|NodeToInfo
index|[
name|nullptr
index|]
expr_stmt|;
name|BBInfo
operator|.
name|DFSNum
operator|=
name|BBInfo
operator|.
name|Semi
operator|=
operator|++
name|Num
expr_stmt|;
name|BBInfo
operator|.
name|Label
operator|=
name|nullptr
expr_stmt|;
name|NumToNode
operator|.
name|push_back
argument_list|(
name|nullptr
argument_list|)
expr_stmt|;
comment|// NumToNode[n] = V;
block|}
if|if
condition|(
name|DT
operator|.
name|isPostDominator
argument_list|()
condition|)
block|{
for|for
control|(
name|auto
operator|*
name|Root
operator|:
name|DT
operator|.
name|Roots
control|)
name|Num
operator|=
name|runDFS
operator|<
name|true
operator|>
operator|(
name|Root
operator|,
name|Num
operator|,
name|DC
operator|,
literal|1
operator|)
expr_stmt|;
block|}
else|else
block|{
name|assert
argument_list|(
name|DT
operator|.
name|Roots
operator|.
name|size
argument_list|()
operator|==
literal|1
argument_list|)
expr_stmt|;
name|Num
operator|=
name|runDFS
operator|<
name|false
operator|>
operator|(
name|DT
operator|.
name|Roots
index|[
literal|0
index|]
operator|,
name|Num
operator|,
name|DC
operator|,
name|Num
operator|)
expr_stmt|;
block|}
return|return
name|Num
return|;
block|}
specifier|static
name|void
name|PrintBlockOrNullptr
parameter_list|(
name|raw_ostream
modifier|&
name|O
parameter_list|,
name|NodePtr
name|Obj
parameter_list|)
block|{
if|if
condition|(
operator|!
name|Obj
condition|)
name|O
operator|<<
literal|"nullptr"
expr_stmt|;
else|else
name|Obj
operator|->
name|printAsOperand
argument_list|(
name|O
argument_list|,
name|false
argument_list|)
expr_stmt|;
block|}
comment|// Checks if the tree contains all reachable nodes in the input graph.
name|bool
name|verifyReachability
parameter_list|(
specifier|const
name|DomTreeT
modifier|&
name|DT
parameter_list|)
block|{
name|clear
argument_list|()
expr_stmt|;
name|doFullDFSWalk
argument_list|(
name|DT
argument_list|,
name|AlwaysDescend
argument_list|)
expr_stmt|;
for|for
control|(
name|auto
operator|&
name|NodeToTN
operator|:
name|DT
operator|.
name|DomTreeNodes
control|)
block|{
specifier|const
name|TreeNodePtr
name|TN
init|=
name|NodeToTN
operator|.
name|second
operator|.
name|get
argument_list|()
decl_stmt|;
specifier|const
name|NodePtr
name|BB
init|=
name|TN
operator|->
name|getBlock
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|BB
condition|)
continue|continue;
if|if
condition|(
name|NodeToInfo
operator|.
name|count
argument_list|(
name|BB
argument_list|)
operator|==
literal|0
condition|)
block|{
name|errs
argument_list|()
operator|<<
literal|"DomTree node "
expr_stmt|;
name|PrintBlockOrNullptr
argument_list|(
name|errs
argument_list|()
argument_list|,
name|BB
argument_list|)
expr_stmt|;
name|errs
argument_list|()
operator|<<
literal|" not found by DFS walk!\n"
expr_stmt|;
name|errs
argument_list|()
operator|.
name|flush
argument_list|()
expr_stmt|;
return|return
name|false
return|;
block|}
block|}
return|return
name|true
return|;
block|}
comment|// Check if for every parent with a level L in the tree all of its children
comment|// have level L + 1.
specifier|static
name|bool
name|VerifyLevels
parameter_list|(
specifier|const
name|DomTreeT
modifier|&
name|DT
parameter_list|)
block|{
for|for
control|(
name|auto
operator|&
name|NodeToTN
operator|:
name|DT
operator|.
name|DomTreeNodes
control|)
block|{
specifier|const
name|TreeNodePtr
name|TN
init|=
name|NodeToTN
operator|.
name|second
operator|.
name|get
argument_list|()
decl_stmt|;
specifier|const
name|NodePtr
name|BB
init|=
name|TN
operator|->
name|getBlock
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|BB
condition|)
continue|continue;
specifier|const
name|TreeNodePtr
name|IDom
init|=
name|TN
operator|->
name|getIDom
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|IDom
operator|&&
name|TN
operator|->
name|getLevel
argument_list|()
operator|!=
literal|0
condition|)
block|{
name|errs
argument_list|()
operator|<<
literal|"Node without an IDom "
expr_stmt|;
name|PrintBlockOrNullptr
argument_list|(
name|errs
argument_list|()
argument_list|,
name|BB
argument_list|)
expr_stmt|;
name|errs
argument_list|()
operator|<<
literal|" has a nonzero level "
operator|<<
name|TN
operator|->
name|getLevel
argument_list|()
operator|<<
literal|"!\n"
expr_stmt|;
name|errs
argument_list|()
operator|.
name|flush
argument_list|()
expr_stmt|;
return|return
name|false
return|;
block|}
if|if
condition|(
name|IDom
operator|&&
name|TN
operator|->
name|getLevel
argument_list|()
operator|!=
name|IDom
operator|->
name|getLevel
argument_list|()
operator|+
literal|1
condition|)
block|{
name|errs
argument_list|()
operator|<<
literal|"Node "
expr_stmt|;
name|PrintBlockOrNullptr
argument_list|(
name|errs
argument_list|()
argument_list|,
name|BB
argument_list|)
expr_stmt|;
name|errs
argument_list|()
operator|<<
literal|" has level "
operator|<<
name|TN
operator|->
name|getLevel
argument_list|()
operator|<<
literal|" while it's IDom "
expr_stmt|;
name|PrintBlockOrNullptr
argument_list|(
name|errs
argument_list|()
argument_list|,
name|IDom
operator|->
name|getBlock
argument_list|()
argument_list|)
expr_stmt|;
name|errs
argument_list|()
operator|<<
literal|" has level "
operator|<<
name|IDom
operator|->
name|getLevel
argument_list|()
operator|<<
literal|"!\n"
expr_stmt|;
name|errs
argument_list|()
operator|.
name|flush
argument_list|()
expr_stmt|;
return|return
name|false
return|;
block|}
block|}
return|return
name|true
return|;
block|}
comment|// Checks if for every edge From -> To in the graph
comment|//     NCD(From, To) == IDom(To) or To.
name|bool
name|verifyNCD
parameter_list|(
specifier|const
name|DomTreeT
modifier|&
name|DT
parameter_list|)
block|{
name|clear
argument_list|()
expr_stmt|;
name|doFullDFSWalk
argument_list|(
name|DT
argument_list|,
name|AlwaysDescend
argument_list|)
expr_stmt|;
for|for
control|(
name|auto
operator|&
name|BlockToInfo
operator|:
name|NodeToInfo
control|)
block|{
name|auto
operator|&
name|Info
operator|=
name|BlockToInfo
operator|.
name|second
expr_stmt|;
specifier|const
name|NodePtr
name|From
init|=
name|NumToNode
index|[
name|Info
operator|.
name|Parent
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|From
condition|)
continue|continue;
specifier|const
name|NodePtr
name|To
init|=
name|BlockToInfo
operator|.
name|first
decl_stmt|;
specifier|const
name|TreeNodePtr
name|ToTN
init|=
name|DT
operator|.
name|getNode
argument_list|(
name|To
argument_list|)
decl_stmt|;
name|assert
argument_list|(
name|ToTN
argument_list|)
expr_stmt|;
specifier|const
name|NodePtr
name|NCD
init|=
name|DT
operator|.
name|findNearestCommonDominator
argument_list|(
name|From
argument_list|,
name|To
argument_list|)
decl_stmt|;
specifier|const
name|TreeNodePtr
name|NCDTN
init|=
name|NCD
condition|?
name|DT
operator|.
name|getNode
argument_list|(
name|NCD
argument_list|)
else|:
name|nullptr
decl_stmt|;
specifier|const
name|TreeNodePtr
name|ToIDom
init|=
name|ToTN
operator|->
name|getIDom
argument_list|()
decl_stmt|;
if|if
condition|(
name|NCDTN
operator|!=
name|ToTN
operator|&&
name|NCDTN
operator|!=
name|ToIDom
condition|)
block|{
name|errs
argument_list|()
operator|<<
literal|"NearestCommonDominator verification failed:\n\tNCD(From:"
expr_stmt|;
name|PrintBlockOrNullptr
argument_list|(
name|errs
argument_list|()
argument_list|,
name|From
argument_list|)
expr_stmt|;
name|errs
argument_list|()
operator|<<
literal|", To:"
expr_stmt|;
name|PrintBlockOrNullptr
argument_list|(
name|errs
argument_list|()
argument_list|,
name|To
argument_list|)
expr_stmt|;
name|errs
argument_list|()
operator|<<
literal|") = "
expr_stmt|;
name|PrintBlockOrNullptr
argument_list|(
name|errs
argument_list|()
argument_list|,
name|NCD
argument_list|)
expr_stmt|;
name|errs
argument_list|()
operator|<<
literal|",\t (should be To or IDom[To]: "
expr_stmt|;
name|PrintBlockOrNullptr
argument_list|(
name|errs
argument_list|()
argument_list|,
name|ToIDom
condition|?
name|ToIDom
operator|->
name|getBlock
argument_list|()
else|:
name|nullptr
argument_list|)
expr_stmt|;
name|errs
argument_list|()
operator|<<
literal|")\n"
expr_stmt|;
name|errs
argument_list|()
operator|.
name|flush
argument_list|()
expr_stmt|;
return|return
name|false
return|;
block|}
block|}
return|return
name|true
return|;
block|}
comment|// The below routines verify the correctness of the dominator tree relative to
comment|// the CFG it's coming from.  A tree is a dominator tree iff it has two
comment|// properties, called the parent property and the sibling property.  Tarjan
comment|// and Lengauer prove (but don't explicitly name) the properties as part of
comment|// the proofs in their 1972 paper, but the proofs are mostly part of proving
comment|// things about semidominators and idoms, and some of them are simply asserted
comment|// based on even earlier papers (see, e.g., lemma 2).  Some papers refer to
comment|// these properties as "valid" and "co-valid".  See, e.g., "Dominators,
comment|// directed bipolar orders, and independent spanning trees" by Loukas
comment|// Georgiadis and Robert E. Tarjan, as well as "Dominator Tree Verification
comment|// and Vertex-Disjoint Paths " by the same authors.
comment|// A very simple and direct explanation of these properties can be found in
comment|// "An Experimental Study of Dynamic Dominators", found at
comment|// https://arxiv.org/abs/1604.02711
comment|// The easiest way to think of the parent property is that it's a requirement
comment|// of being a dominator.  Let's just take immediate dominators.  For PARENT to
comment|// be an immediate dominator of CHILD, all paths in the CFG must go through
comment|// PARENT before they hit CHILD.  This implies that if you were to cut PARENT
comment|// out of the CFG, there should be no paths to CHILD that are reachable.  If
comment|// there are, then you now have a path from PARENT to CHILD that goes around
comment|// PARENT and still reaches CHILD, which by definition, means PARENT can't be
comment|// a dominator of CHILD (let alone an immediate one).
comment|// The sibling property is similar.  It says that for each pair of sibling
comment|// nodes in the dominator tree (LEFT and RIGHT) , they must not dominate each
comment|// other.  If sibling LEFT dominated sibling RIGHT, it means there are no
comment|// paths in the CFG from sibling LEFT to sibling RIGHT that do not go through
comment|// LEFT, and thus, LEFT is really an ancestor (in the dominator tree) of
comment|// RIGHT, not a sibling.
comment|// It is possible to verify the parent and sibling properties in
comment|// linear time, but the algorithms are complex. Instead, we do it in a
comment|// straightforward N^2 and N^3 way below, using direct path reachability.
comment|// Checks if the tree has the parent property: if for all edges from V to W in
comment|// the input graph, such that V is reachable, the parent of W in the tree is
comment|// an ancestor of V in the tree.
comment|//
comment|// This means that if a node gets disconnected from the graph, then all of
comment|// the nodes it dominated previously will now become unreachable.
name|bool
name|verifyParentProperty
parameter_list|(
specifier|const
name|DomTreeT
modifier|&
name|DT
parameter_list|)
block|{
for|for
control|(
name|auto
operator|&
name|NodeToTN
operator|:
name|DT
operator|.
name|DomTreeNodes
control|)
block|{
specifier|const
name|TreeNodePtr
name|TN
init|=
name|NodeToTN
operator|.
name|second
operator|.
name|get
argument_list|()
decl_stmt|;
specifier|const
name|NodePtr
name|BB
init|=
name|TN
operator|->
name|getBlock
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|BB
operator|||
name|TN
operator|->
name|getChildren
argument_list|()
operator|.
name|empty
argument_list|()
condition|)
continue|continue;
name|clear
argument_list|()
expr_stmt|;
name|doFullDFSWalk
argument_list|(
name|DT
argument_list|,
index|[
name|BB
index|]
operator|(
name|NodePtr
name|From
operator|,
name|NodePtr
name|To
operator|)
block|{
return|return
name|From
operator|!=
name|BB
operator|&&
name|To
operator|!=
name|BB
return|;
block|}
block|)
empty_stmt|;
for|for
control|(
name|TreeNodePtr
name|Child
range|:
name|TN
operator|->
name|getChildren
argument_list|()
control|)
if|if
condition|(
name|NodeToInfo
operator|.
name|count
argument_list|(
name|Child
operator|->
name|getBlock
argument_list|()
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|errs
argument_list|()
operator|<<
literal|"Child "
expr_stmt|;
name|PrintBlockOrNullptr
argument_list|(
name|errs
argument_list|()
argument_list|,
name|Child
operator|->
name|getBlock
argument_list|()
argument_list|)
expr_stmt|;
name|errs
argument_list|()
operator|<<
literal|" reachable after its parent "
expr_stmt|;
name|PrintBlockOrNullptr
argument_list|(
name|errs
argument_list|()
argument_list|,
name|BB
argument_list|)
expr_stmt|;
name|errs
argument_list|()
operator|<<
literal|" is removed!\n"
expr_stmt|;
name|errs
argument_list|()
operator|.
name|flush
argument_list|()
expr_stmt|;
return|return
name|false
return|;
block|}
block|}
return|return
name|true
return|;
block|}
end_decl_stmt

begin_comment
comment|// Check if the tree has sibling property: if a node V does not dominate a
end_comment

begin_comment
comment|// node W for all siblings V and W in the tree.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This means that if a node gets disconnected from the graph, then all of its
end_comment

begin_comment
comment|// siblings will now still be reachable.
end_comment

begin_function
name|bool
name|verifySiblingProperty
parameter_list|(
specifier|const
name|DomTreeT
modifier|&
name|DT
parameter_list|)
block|{
for|for
control|(
name|auto
operator|&
name|NodeToTN
operator|:
name|DT
operator|.
name|DomTreeNodes
control|)
block|{
specifier|const
name|TreeNodePtr
name|TN
init|=
name|NodeToTN
operator|.
name|second
operator|.
name|get
argument_list|()
decl_stmt|;
specifier|const
name|NodePtr
name|BB
init|=
name|TN
operator|->
name|getBlock
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|BB
operator|||
name|TN
operator|->
name|getChildren
argument_list|()
operator|.
name|empty
argument_list|()
condition|)
continue|continue;
specifier|const
specifier|auto
modifier|&
name|Siblings
init|=
name|TN
operator|->
name|getChildren
argument_list|()
decl_stmt|;
for|for
control|(
specifier|const
name|TreeNodePtr
name|N
range|:
name|Siblings
control|)
block|{
name|clear
argument_list|()
expr_stmt|;
name|NodePtr
name|BBN
init|=
name|N
operator|->
name|getBlock
argument_list|()
decl_stmt|;
name|doFullDFSWalk
argument_list|(
name|DT
argument_list|,
index|[
name|BBN
index|]
operator|(
name|NodePtr
name|From
operator|,
name|NodePtr
name|To
operator|)
block|{
return|return
name|From
operator|!=
name|BBN
operator|&&
name|To
operator|!=
name|BBN
return|;
block|}
block|)
empty_stmt|;
for|for
control|(
specifier|const
name|TreeNodePtr
name|S
range|:
name|Siblings
control|)
block|{
if|if
condition|(
name|S
operator|==
name|N
condition|)
continue|continue;
if|if
condition|(
name|NodeToInfo
operator|.
name|count
argument_list|(
name|S
operator|->
name|getBlock
argument_list|()
argument_list|)
operator|==
literal|0
condition|)
block|{
name|errs
argument_list|()
operator|<<
literal|"Node "
expr_stmt|;
name|PrintBlockOrNullptr
argument_list|(
name|errs
argument_list|()
argument_list|,
name|S
operator|->
name|getBlock
argument_list|()
argument_list|)
expr_stmt|;
name|errs
argument_list|()
operator|<<
literal|" not reachable when its sibling "
expr_stmt|;
name|PrintBlockOrNullptr
argument_list|(
name|errs
argument_list|()
argument_list|,
name|N
operator|->
name|getBlock
argument_list|()
argument_list|)
expr_stmt|;
name|errs
argument_list|()
operator|<<
literal|" is removed!\n"
expr_stmt|;
name|errs
argument_list|()
operator|.
name|flush
argument_list|()
expr_stmt|;
return|return
name|false
return|;
block|}
block|}
block|}
block|}
end_function

begin_return
return|return
name|true
return|;
end_return

begin_empty_stmt
unit|} }
empty_stmt|;
end_empty_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|FuncT
operator|,
name|class
name|NodeT
operator|>
name|void
name|Calculate
argument_list|(
argument|DominatorTreeBaseByGraphTraits<GraphTraits<NodeT>>&DT
argument_list|,
argument|FuncT&F
argument_list|)
block|{
name|using
name|NodePtr
operator|=
name|typename
name|GraphTraits
operator|<
name|NodeT
operator|>
operator|::
name|NodeRef
block|;
name|static_assert
argument_list|(
name|std
operator|::
name|is_pointer
operator|<
name|NodePtr
operator|>
operator|::
name|value
argument_list|,
literal|"NodePtr should be a pointer type"
argument_list|)
block|;
name|SemiNCAInfo
operator|<
name|typename
name|std
operator|::
name|remove_pointer
operator|<
name|NodePtr
operator|>
operator|::
name|type
operator|>
name|SNCA
block|;
name|SNCA
operator|.
name|template
name|runSemiNCA
operator|<
name|NodeT
operator|>
operator|(
name|DT
operator|,
name|GraphTraits
operator|<
name|FuncT
operator|*
operator|>
operator|::
name|size
argument_list|(
operator|&
name|F
argument_list|)
operator|)
block|; }
name|template
operator|<
name|class
name|NodeT
operator|>
name|bool
name|Verify
argument_list|(
argument|const DominatorTreeBaseByGraphTraits<GraphTraits<NodeT>>&DT
argument_list|)
block|{
name|using
name|NodePtr
operator|=
name|typename
name|GraphTraits
operator|<
name|NodeT
operator|>
operator|::
name|NodeRef
block|;
name|static_assert
argument_list|(
name|std
operator|::
name|is_pointer
operator|<
name|NodePtr
operator|>
operator|::
name|value
argument_list|,
literal|"NodePtr should be a pointer type"
argument_list|)
block|;
name|SemiNCAInfo
operator|<
name|typename
name|std
operator|::
name|remove_pointer
operator|<
name|NodePtr
operator|>
operator|::
name|type
operator|>
name|SNCA
block|;
return|return
name|SNCA
operator|.
name|verifyReachability
argument_list|(
name|DT
argument_list|)
operator|&&
name|SNCA
operator|.
name|VerifyLevels
argument_list|(
name|DT
argument_list|)
operator|&&
name|SNCA
operator|.
name|verifyNCD
argument_list|(
name|DT
argument_list|)
operator|&&
name|SNCA
operator|.
name|verifyParentProperty
argument_list|(
name|DT
argument_list|)
operator|&&
name|SNCA
operator|.
name|verifySiblingProperty
argument_list|(
name|DT
argument_list|)
return|;
block|}
end_expr_stmt

begin_comment
unit|}
comment|// namespace DomTreeBuilder
end_comment

begin_comment
unit|}
comment|// namespace llvm
end_comment

begin_endif
endif|#
directive|endif
end_endif

end_unit

