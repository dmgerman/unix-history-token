begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===- GenericDomTreeConstruction.h - Dominator Calculation ------*- C++ -*-==//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|/// \file
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|/// Generic dominator tree construction - This file provides routines to
end_comment

begin_comment
comment|/// construct immediate dominator information for a flow-graph based on the
end_comment

begin_comment
comment|/// algorithm described in this document:
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|///   A Fast Algorithm for Finding Dominators in a Flowgraph
end_comment

begin_comment
comment|///   T. Lengauer& R. Tarjan, ACM TOPLAS July 1979, pgs 121-141.
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|/// This implements the O(n*log(n)) versions of EVAL and LINK, because it turns
end_comment

begin_comment
comment|/// out that the theoretically slower O(n*log(n)) implementation is actually
end_comment

begin_comment
comment|/// faster than the almost-linear O(n*alpha(n)) version, even for large CFGs.
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LLVM_SUPPORT_GENERICDOMTREECONSTRUCTION_H
end_ifndef

begin_define
define|#
directive|define
name|LLVM_SUPPORT_GENERICDOMTREECONSTRUCTION_H
end_define

begin_include
include|#
directive|include
file|"llvm/ADT/DepthFirstIterator.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/SmallPtrSet.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/GenericDomTree.h"
end_include

begin_decl_stmt
name|namespace
name|llvm
block|{
comment|// External storage for depth first iterator that reuses the info lookup map
comment|// domtree already has.  We don't have a set, but a map instead, so we are
comment|// converting the one argument insert calls.
name|template
operator|<
name|class
name|NodeRef
operator|,
name|class
name|InfoType
operator|>
expr|struct
name|df_iterator_dom_storage
block|{
name|public
operator|:
typedef|typedef
name|DenseMap
operator|<
name|NodeRef
operator|,
name|InfoType
operator|>
name|BaseSet
expr_stmt|;
name|df_iterator_dom_storage
argument_list|(
name|BaseSet
operator|&
name|Storage
argument_list|)
operator|:
name|Storage
argument_list|(
argument|Storage
argument_list|)
block|{}
typedef|typedef
name|typename
name|BaseSet
operator|::
name|iterator
name|iterator
expr_stmt|;
name|std
operator|::
name|pair
operator|<
name|iterator
operator|,
name|bool
operator|>
name|insert
argument_list|(
argument|NodeRef N
argument_list|)
block|{
return|return
name|Storage
operator|.
name|insert
argument_list|(
block|{
name|N
block|,
name|InfoType
argument_list|()
block|}
argument_list|)
return|;
block|}
name|void
name|completed
parameter_list|(
name|NodeRef
parameter_list|)
block|{}
name|private
label|:
name|BaseSet
modifier|&
name|Storage
decl_stmt|;
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|GraphT
operator|>
name|unsigned
name|ReverseDFSPass
argument_list|(
argument|DominatorTreeBaseByGraphTraits<GraphT>&DT
argument_list|,
argument|typename GraphT::NodeRef V
argument_list|,
argument|unsigned N
argument_list|)
block|{
name|df_iterator_dom_storage
operator|<
name|typename
name|GraphT
operator|::
name|NodeRef
block|,
name|typename
name|DominatorTreeBaseByGraphTraits
operator|<
name|GraphT
operator|>
operator|::
name|InfoRec
operator|>
name|DFStorage
argument_list|(
name|DT
operator|.
name|Info
argument_list|)
block|;
name|bool
name|IsChildOfArtificialExit
operator|=
operator|(
name|N
operator|!=
literal|0
operator|)
block|;
for|for
control|(
name|auto
name|I
init|=
name|idf_ext_begin
argument_list|(
name|V
argument_list|,
name|DFStorage
argument_list|)
init|,
name|E
init|=
name|idf_ext_end
argument_list|(
name|V
argument_list|,
name|DFStorage
argument_list|)
init|;
name|I
operator|!=
name|E
condition|;
operator|++
name|I
control|)
block|{
name|typename
name|GraphT
operator|::
name|NodeRef
name|BB
operator|=
operator|*
name|I
expr_stmt|;
name|auto
operator|&
name|BBInfo
operator|=
name|DT
operator|.
name|Info
index|[
name|BB
index|]
expr_stmt|;
name|BBInfo
operator|.
name|DFSNum
operator|=
name|BBInfo
operator|.
name|Semi
operator|=
operator|++
name|N
expr_stmt|;
name|BBInfo
operator|.
name|Label
operator|=
name|BB
expr_stmt|;
comment|// Set the parent to the top of the visited stack.  The stack includes us,
comment|// and is 1 based, so we subtract to account for both of these.
if|if
condition|(
name|I
operator|.
name|getPathLength
argument_list|()
operator|>
literal|1
condition|)
name|BBInfo
operator|.
name|Parent
operator|=
name|DT
operator|.
name|Info
index|[
name|I
operator|.
name|getPath
argument_list|(
name|I
operator|.
name|getPathLength
argument_list|()
operator|-
literal|2
argument_list|)
index|]
operator|.
name|DFSNum
expr_stmt|;
name|DT
operator|.
name|Vertex
operator|.
name|push_back
argument_list|(
name|BB
argument_list|)
expr_stmt|;
comment|// Vertex[n] = V;
if|if
condition|(
name|IsChildOfArtificialExit
condition|)
name|BBInfo
operator|.
name|Parent
operator|=
literal|1
expr_stmt|;
name|IsChildOfArtificialExit
operator|=
name|false
expr_stmt|;
block|}
end_expr_stmt

begin_return
return|return
name|N
return|;
end_return

begin_expr_stmt
unit|} template
operator|<
name|class
name|GraphT
operator|>
name|unsigned
name|DFSPass
argument_list|(
argument|DominatorTreeBaseByGraphTraits<GraphT>&DT
argument_list|,
argument|typename GraphT::NodeRef V
argument_list|,
argument|unsigned N
argument_list|)
block|{
name|df_iterator_dom_storage
operator|<
name|typename
name|GraphT
operator|::
name|NodeRef
block|,
name|typename
name|DominatorTreeBaseByGraphTraits
operator|<
name|GraphT
operator|>
operator|::
name|InfoRec
operator|>
name|DFStorage
argument_list|(
name|DT
operator|.
name|Info
argument_list|)
block|;
for|for
control|(
name|auto
name|I
init|=
name|df_ext_begin
argument_list|(
name|V
argument_list|,
name|DFStorage
argument_list|)
init|,
name|E
init|=
name|df_ext_end
argument_list|(
name|V
argument_list|,
name|DFStorage
argument_list|)
init|;
name|I
operator|!=
name|E
condition|;
operator|++
name|I
control|)
block|{
name|typename
name|GraphT
operator|::
name|NodeRef
name|BB
operator|=
operator|*
name|I
expr_stmt|;
name|auto
operator|&
name|BBInfo
operator|=
name|DT
operator|.
name|Info
index|[
name|BB
index|]
expr_stmt|;
name|BBInfo
operator|.
name|DFSNum
operator|=
name|BBInfo
operator|.
name|Semi
operator|=
operator|++
name|N
expr_stmt|;
name|BBInfo
operator|.
name|Label
operator|=
name|BB
expr_stmt|;
comment|// Set the parent to the top of the visited stack.  The stack includes us,
comment|// and is 1 based, so we subtract to account for both of these.
if|if
condition|(
name|I
operator|.
name|getPathLength
argument_list|()
operator|>
literal|1
condition|)
name|BBInfo
operator|.
name|Parent
operator|=
name|DT
operator|.
name|Info
index|[
name|I
operator|.
name|getPath
argument_list|(
name|I
operator|.
name|getPathLength
argument_list|()
operator|-
literal|2
argument_list|)
index|]
operator|.
name|DFSNum
expr_stmt|;
name|DT
operator|.
name|Vertex
operator|.
name|push_back
argument_list|(
name|BB
argument_list|)
expr_stmt|;
comment|// Vertex[n] = V;
block|}
end_expr_stmt

begin_return
return|return
name|N
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|class
name|GraphT
operator|>
name|typename
name|GraphT
operator|::
name|NodeRef
name|Eval
argument_list|(
argument|DominatorTreeBaseByGraphTraits<GraphT>&DT
argument_list|,
argument|typename GraphT::NodeRef VIn
argument_list|,
argument|unsigned LastLinked
argument_list|)
block|{
name|auto
operator|&
name|VInInfo
operator|=
name|DT
operator|.
name|Info
index|[
name|VIn
index|]
block|;
if|if
condition|(
name|VInInfo
operator|.
name|DFSNum
operator|<
name|LastLinked
condition|)
return|return
name|VIn
return|;
name|SmallVector
operator|<
name|typename
name|GraphT
operator|::
name|NodeRef
operator|,
literal|32
operator|>
name|Work
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SmallPtrSet
operator|<
name|typename
name|GraphT
operator|::
name|NodeRef
operator|,
literal|32
operator|>
name|Visited
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|VInInfo
operator|.
name|Parent
operator|>=
name|LastLinked
condition|)
name|Work
operator|.
name|push_back
argument_list|(
name|VIn
argument_list|)
expr_stmt|;
end_if

begin_while
while|while
condition|(
operator|!
name|Work
operator|.
name|empty
argument_list|()
condition|)
block|{
name|typename
name|GraphT
operator|::
name|NodeRef
name|V
operator|=
name|Work
operator|.
name|back
argument_list|()
expr_stmt|;
name|auto
operator|&
name|VInfo
operator|=
name|DT
operator|.
name|Info
index|[
name|V
index|]
expr_stmt|;
name|typename
name|GraphT
operator|::
name|NodeRef
name|VAncestor
operator|=
name|DT
operator|.
name|Vertex
index|[
name|VInfo
operator|.
name|Parent
index|]
expr_stmt|;
comment|// Process Ancestor first
if|if
condition|(
name|Visited
operator|.
name|insert
argument_list|(
name|VAncestor
argument_list|)
operator|.
name|second
operator|&&
name|VInfo
operator|.
name|Parent
operator|>=
name|LastLinked
condition|)
block|{
name|Work
operator|.
name|push_back
argument_list|(
name|VAncestor
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|Work
operator|.
name|pop_back
argument_list|()
expr_stmt|;
comment|// Update VInfo based on Ancestor info
if|if
condition|(
name|VInfo
operator|.
name|Parent
operator|<
name|LastLinked
condition|)
continue|continue;
name|auto
operator|&
name|VAInfo
operator|=
name|DT
operator|.
name|Info
index|[
name|VAncestor
index|]
expr_stmt|;
name|typename
name|GraphT
operator|::
name|NodeRef
name|VAncestorLabel
operator|=
name|VAInfo
operator|.
name|Label
expr_stmt|;
name|typename
name|GraphT
operator|::
name|NodeRef
name|VLabel
operator|=
name|VInfo
operator|.
name|Label
expr_stmt|;
if|if
condition|(
name|DT
operator|.
name|Info
index|[
name|VAncestorLabel
index|]
operator|.
name|Semi
operator|<
name|DT
operator|.
name|Info
index|[
name|VLabel
index|]
operator|.
name|Semi
condition|)
name|VInfo
operator|.
name|Label
operator|=
name|VAncestorLabel
expr_stmt|;
name|VInfo
operator|.
name|Parent
operator|=
name|VAInfo
operator|.
name|Parent
expr_stmt|;
block|}
end_while

begin_return
return|return
name|VInInfo
operator|.
name|Label
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|class
name|FuncT
operator|,
name|class
name|NodeT
operator|>
name|void
name|Calculate
argument_list|(
argument|DominatorTreeBaseByGraphTraits<GraphTraits<NodeT>>&DT
argument_list|,
argument|FuncT&F
argument_list|)
block|{
typedef|typedef
name|GraphTraits
operator|<
name|NodeT
operator|>
name|GraphT
expr_stmt|;
name|static_assert
argument_list|(
argument|std::is_pointer<typename GraphT::NodeRef>::value
argument_list|,
literal|"NodeRef should be pointer type"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_typedef
typedef|typedef
name|typename
name|std
operator|::
name|remove_pointer
operator|<
name|typename
name|GraphT
operator|::
name|NodeRef
operator|>
operator|::
name|type
name|NodeType
expr_stmt|;
end_typedef

begin_decl_stmt
name|unsigned
name|N
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|bool
name|MultipleRoots
init|=
operator|(
name|DT
operator|.
name|Roots
operator|.
name|size
argument_list|()
operator|>
literal|1
operator|)
decl_stmt|;
end_decl_stmt

begin_if
if|if
condition|(
name|MultipleRoots
condition|)
block|{
name|auto
operator|&
name|BBInfo
operator|=
name|DT
operator|.
name|Info
index|[
name|nullptr
index|]
expr_stmt|;
name|BBInfo
operator|.
name|DFSNum
operator|=
name|BBInfo
operator|.
name|Semi
operator|=
operator|++
name|N
expr_stmt|;
name|BBInfo
operator|.
name|Label
operator|=
name|nullptr
expr_stmt|;
name|DT
operator|.
name|Vertex
operator|.
name|push_back
argument_list|(
name|nullptr
argument_list|)
expr_stmt|;
comment|// Vertex[n] = V;
block|}
end_if

begin_comment
comment|// Step #1: Number blocks in depth-first order and initialize variables used
end_comment

begin_comment
comment|// in later stages of the algorithm.
end_comment

begin_if
if|if
condition|(
name|DT
operator|.
name|isPostDominator
argument_list|()
condition|)
block|{
for|for
control|(
name|unsigned
name|i
init|=
literal|0
init|,
name|e
init|=
name|static_cast
operator|<
name|unsigned
operator|>
operator|(
name|DT
operator|.
name|Roots
operator|.
name|size
argument_list|()
operator|)
init|;
name|i
operator|!=
name|e
condition|;
operator|++
name|i
control|)
name|N
operator|=
name|ReverseDFSPass
operator|<
name|GraphT
operator|>
operator|(
name|DT
operator|,
name|DT
operator|.
name|Roots
index|[
name|i
index|]
operator|,
name|N
operator|)
expr_stmt|;
block|}
else|else
block|{
name|N
operator|=
name|DFSPass
operator|<
name|GraphT
operator|>
operator|(
name|DT
operator|,
name|DT
operator|.
name|Roots
index|[
literal|0
index|]
operator|,
name|N
operator|)
expr_stmt|;
block|}
end_if

begin_comment
comment|// it might be that some blocks did not get a DFS number (e.g., blocks of
end_comment

begin_comment
comment|// infinite loops). In these cases an artificial exit node is required.
end_comment

begin_expr_stmt
name|MultipleRoots
operator||=
operator|(
name|DT
operator|.
name|isPostDominator
argument_list|()
operator|&&
name|N
operator|!=
name|GraphTraits
operator|<
name|FuncT
operator|*
operator|>
operator|::
name|size
argument_list|(
operator|&
name|F
argument_list|)
operator|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|// When naively implemented, the Lengauer-Tarjan algorithm requires a separate
end_comment

begin_comment
comment|// bucket for each vertex. However, this is unnecessary, because each vertex
end_comment

begin_comment
comment|// is only placed into a single bucket (that of its semidominator), and each
end_comment

begin_comment
comment|// vertex's bucket is processed before it is added to any bucket itself.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// Instead of using a bucket per vertex, we use a single array Buckets that
end_comment

begin_comment
comment|// has two purposes. Before the vertex V with preorder number i is processed,
end_comment

begin_comment
comment|// Buckets[i] stores the index of the first element in V's bucket. After V's
end_comment

begin_comment
comment|// bucket is processed, Buckets[i] stores the index of the next element in the
end_comment

begin_comment
comment|// bucket containing V, if any.
end_comment

begin_expr_stmt
name|SmallVector
operator|<
name|unsigned
operator|,
literal|32
operator|>
name|Buckets
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|Buckets
operator|.
name|resize
argument_list|(
name|N
operator|+
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_for
for|for
control|(
name|unsigned
name|i
init|=
literal|1
init|;
name|i
operator|<=
name|N
condition|;
operator|++
name|i
control|)
name|Buckets
index|[
name|i
index|]
operator|=
name|i
expr_stmt|;
end_for

begin_for
for|for
control|(
name|unsigned
name|i
init|=
name|N
init|;
name|i
operator|>=
literal|2
condition|;
operator|--
name|i
control|)
block|{
name|typename
name|GraphT
operator|::
name|NodeRef
name|W
operator|=
name|DT
operator|.
name|Vertex
index|[
name|i
index|]
expr_stmt|;
name|auto
operator|&
name|WInfo
operator|=
name|DT
operator|.
name|Info
index|[
name|W
index|]
expr_stmt|;
comment|// Step #2: Implicitly define the immediate dominator of vertices
for|for
control|(
name|unsigned
name|j
init|=
name|i
init|;
name|Buckets
index|[
name|j
index|]
operator|!=
name|i
condition|;
name|j
operator|=
name|Buckets
index|[
name|j
index|]
control|)
block|{
name|typename
name|GraphT
operator|::
name|NodeRef
name|V
operator|=
name|DT
operator|.
name|Vertex
index|[
name|Buckets
index|[
name|j
index|]
index|]
expr_stmt|;
name|typename
name|GraphT
operator|::
name|NodeRef
name|U
operator|=
name|Eval
operator|<
name|GraphT
operator|>
operator|(
name|DT
operator|,
name|V
operator|,
name|i
operator|+
literal|1
operator|)
expr_stmt|;
name|DT
operator|.
name|IDoms
index|[
name|V
index|]
operator|=
name|DT
operator|.
name|Info
index|[
name|U
index|]
operator|.
name|Semi
operator|<
name|i
condition|?
name|U
else|:
name|W
expr_stmt|;
block|}
comment|// Step #3: Calculate the semidominators of all vertices
comment|// initialize the semi dominator to point to the parent node
name|WInfo
operator|.
name|Semi
operator|=
name|WInfo
operator|.
name|Parent
expr_stmt|;
for|for
control|(
specifier|const
specifier|auto
modifier|&
name|N
range|:
name|inverse_children
operator|<
name|NodeT
operator|>
operator|(
name|W
operator|)
control|)
if|if
condition|(
name|DT
operator|.
name|Info
operator|.
name|count
argument_list|(
name|N
argument_list|)
condition|)
block|{
comment|// Only if this predecessor is reachable!
name|unsigned
name|SemiU
init|=
name|DT
operator|.
name|Info
index|[
name|Eval
operator|<
name|GraphT
operator|>
operator|(
name|DT
expr|,
name|N
expr|,
name|i
operator|+
literal|1
operator|)
index|]
operator|.
name|Semi
decl_stmt|;
if|if
condition|(
name|SemiU
operator|<
name|WInfo
operator|.
name|Semi
condition|)
name|WInfo
operator|.
name|Semi
operator|=
name|SemiU
expr_stmt|;
block|}
comment|// If V is a non-root vertex and sdom(V) = parent(V), then idom(V) is
comment|// necessarily parent(V). In this case, set idom(V) here and avoid placing
comment|// V into a bucket.
if|if
condition|(
name|WInfo
operator|.
name|Semi
operator|==
name|WInfo
operator|.
name|Parent
condition|)
block|{
name|DT
operator|.
name|IDoms
index|[
name|W
index|]
operator|=
name|DT
operator|.
name|Vertex
index|[
name|WInfo
operator|.
name|Parent
index|]
expr_stmt|;
block|}
else|else
block|{
name|Buckets
index|[
name|i
index|]
operator|=
name|Buckets
index|[
name|WInfo
operator|.
name|Semi
index|]
expr_stmt|;
name|Buckets
index|[
name|WInfo
operator|.
name|Semi
index|]
operator|=
name|i
expr_stmt|;
block|}
block|}
end_for

begin_if
if|if
condition|(
name|N
operator|>=
literal|1
condition|)
block|{
name|typename
name|GraphT
operator|::
name|NodeRef
name|Root
operator|=
name|DT
operator|.
name|Vertex
index|[
literal|1
index|]
expr_stmt|;
for|for
control|(
name|unsigned
name|j
init|=
literal|1
init|;
name|Buckets
index|[
name|j
index|]
operator|!=
literal|1
condition|;
name|j
operator|=
name|Buckets
index|[
name|j
index|]
control|)
block|{
name|typename
name|GraphT
operator|::
name|NodeRef
name|V
operator|=
name|DT
operator|.
name|Vertex
index|[
name|Buckets
index|[
name|j
index|]
index|]
expr_stmt|;
name|DT
operator|.
name|IDoms
index|[
name|V
index|]
operator|=
name|Root
expr_stmt|;
block|}
block|}
end_if

begin_comment
comment|// Step #4: Explicitly define the immediate dominator of each vertex
end_comment

begin_for
for|for
control|(
name|unsigned
name|i
init|=
literal|2
init|;
name|i
operator|<=
name|N
condition|;
operator|++
name|i
control|)
block|{
name|typename
name|GraphT
operator|::
name|NodeRef
name|W
operator|=
name|DT
operator|.
name|Vertex
index|[
name|i
index|]
expr_stmt|;
name|typename
name|GraphT
operator|::
name|NodeRef
operator|&
name|WIDom
operator|=
name|DT
operator|.
name|IDoms
index|[
name|W
index|]
expr_stmt|;
if|if
condition|(
name|WIDom
operator|!=
name|DT
operator|.
name|Vertex
index|[
name|DT
operator|.
name|Info
index|[
name|W
index|]
operator|.
name|Semi
index|]
condition|)
name|WIDom
operator|=
name|DT
operator|.
name|IDoms
index|[
name|WIDom
index|]
expr_stmt|;
block|}
end_for

begin_if
if|if
condition|(
name|DT
operator|.
name|Roots
operator|.
name|empty
argument_list|()
condition|)
return|return;
end_if

begin_comment
comment|// Add a node for the root.  This node might be the actual root, if there is
end_comment

begin_comment
comment|// one exit block, or it may be the virtual exit (denoted by (BasicBlock *)0)
end_comment

begin_comment
comment|// which postdominates all real exits if there are multiple exit blocks, or
end_comment

begin_comment
comment|// an infinite loop.
end_comment

begin_expr_stmt
name|typename
name|GraphT
operator|::
name|NodeRef
name|Root
operator|=
operator|!
name|MultipleRoots
condition|?
name|DT
operator|.
name|Roots
index|[
literal|0
index|]
else|:
name|nullptr
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|DT
operator|.
name|RootNode
operator|=
operator|(
name|DT
operator|.
name|DomTreeNodes
index|[
name|Root
index|]
operator|=
name|llvm
operator|::
name|make_unique
operator|<
name|DomTreeNodeBase
operator|<
name|NodeType
operator|>>
operator|(
name|Root
operator|,
name|nullptr
operator|)
operator|)
operator|.
name|get
argument_list|()
expr_stmt|;
end_expr_stmt

begin_comment
comment|// Loop over all of the reachable blocks in the function...
end_comment

begin_for
for|for
control|(
name|unsigned
name|i
init|=
literal|2
init|;
name|i
operator|<=
name|N
condition|;
operator|++
name|i
control|)
block|{
name|typename
name|GraphT
operator|::
name|NodeRef
name|W
operator|=
name|DT
operator|.
name|Vertex
index|[
name|i
index|]
expr_stmt|;
comment|// Don't replace this with 'count', the insertion side effect is important
if|if
condition|(
name|DT
operator|.
name|DomTreeNodes
index|[
name|W
index|]
condition|)
continue|continue;
comment|// Haven't calculated this node yet?
name|typename
name|GraphT
operator|::
name|NodeRef
name|ImmDom
operator|=
name|DT
operator|.
name|getIDom
argument_list|(
name|W
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|ImmDom
operator|||
name|DT
operator|.
name|DomTreeNodes
index|[
name|nullptr
index|]
argument_list|)
expr_stmt|;
comment|// Get or calculate the node for the immediate dominator
name|DomTreeNodeBase
operator|<
name|NodeType
operator|>
operator|*
name|IDomNode
operator|=
name|DT
operator|.
name|getNodeForBlock
argument_list|(
name|ImmDom
argument_list|)
expr_stmt|;
comment|// Add a new tree node for this BasicBlock, and link it as a child of
comment|// IDomNode
name|DT
operator|.
name|DomTreeNodes
index|[
name|W
index|]
operator|=
name|IDomNode
operator|->
name|addChild
argument_list|(
name|llvm
operator|::
name|make_unique
operator|<
name|DomTreeNodeBase
operator|<
name|NodeType
operator|>>
operator|(
name|W
operator|,
name|IDomNode
operator|)
argument_list|)
expr_stmt|;
block|}
end_for

begin_comment
comment|// Free temporary memory used to construct idom's
end_comment

begin_expr_stmt
name|DT
operator|.
name|IDoms
operator|.
name|clear
argument_list|()
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|DT
operator|.
name|Info
operator|.
name|clear
argument_list|()
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|DT
operator|.
name|Vertex
operator|.
name|clear
argument_list|()
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|DT
operator|.
name|Vertex
operator|.
name|shrink_to_fit
argument_list|()
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|DT
operator|.
name|updateDFSNumbers
argument_list|()
expr_stmt|;
end_expr_stmt

begin_endif
unit|} }
endif|#
directive|endif
end_endif

end_unit

