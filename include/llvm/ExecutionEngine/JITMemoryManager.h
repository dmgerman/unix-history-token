begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===-- JITMemoryManager.h - Interface JIT uses to Allocate Mem -*- C++ -*-===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file defines the JITMemoryManagerInterface
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LLVM_EXECUTION_ENGINE_JIT_MEMMANAGER_H
end_ifndef

begin_define
define|#
directive|define
name|LLVM_EXECUTION_ENGINE_JIT_MEMMANAGER_H
end_define

begin_include
include|#
directive|include
file|"llvm/Support/DataTypes.h"
end_include

begin_include
include|#
directive|include
file|<string>
end_include

begin_decl_stmt
name|namespace
name|llvm
block|{
name|class
name|Function
decl_stmt|;
name|class
name|GlobalValue
decl_stmt|;
comment|/// JITMemoryManager - This interface is used by the JIT to allocate and manage
comment|/// memory for the code generated by the JIT.  This can be reimplemented by
comment|/// clients that have a strong desire to control how the layout of JIT'd memory
comment|/// works.
name|class
name|JITMemoryManager
block|{
name|protected
label|:
name|bool
name|HasGOT
decl_stmt|;
name|bool
name|SizeRequired
decl_stmt|;
name|public
label|:
name|JITMemoryManager
argument_list|()
operator|:
name|HasGOT
argument_list|(
name|false
argument_list|)
operator|,
name|SizeRequired
argument_list|(
argument|false
argument_list|)
block|{}
name|virtual
operator|~
name|JITMemoryManager
argument_list|()
expr_stmt|;
comment|/// CreateDefaultMemManager - This is used to create the default
comment|/// JIT Memory Manager if the client does not provide one to the JIT.
specifier|static
name|JITMemoryManager
modifier|*
name|CreateDefaultMemManager
parameter_list|()
function_decl|;
comment|/// setMemoryWritable - When code generation is in progress,
comment|/// the code pages may need permissions changed.
name|virtual
name|void
name|setMemoryWritable
parameter_list|()
init|=
literal|0
function_decl|;
comment|/// setMemoryExecutable - When code generation is done and we're ready to
comment|/// start execution, the code pages may need permissions changed.
name|virtual
name|void
name|setMemoryExecutable
parameter_list|()
init|=
literal|0
function_decl|;
comment|/// setPoisonMemory - Setting this flag to true makes the memory manager
comment|/// garbage values over freed memory.  This is useful for testing and
comment|/// debugging, and is be turned on by default in debug mode.
name|virtual
name|void
name|setPoisonMemory
parameter_list|(
name|bool
name|poison
parameter_list|)
init|=
literal|0
function_decl|;
comment|//===--------------------------------------------------------------------===//
comment|// Global Offset Table Management
comment|//===--------------------------------------------------------------------===//
comment|/// AllocateGOT - If the current table requires a Global Offset Table, this
comment|/// method is invoked to allocate it.  This method is required to set HasGOT
comment|/// to true.
name|virtual
name|void
name|AllocateGOT
parameter_list|()
init|=
literal|0
function_decl|;
comment|/// isManagingGOT - Return true if the AllocateGOT method is called.
comment|///
name|bool
name|isManagingGOT
argument_list|()
specifier|const
block|{
return|return
name|HasGOT
return|;
block|}
comment|/// getGOTBase - If this is managing a Global Offset Table, this method should
comment|/// return a pointer to its base.
name|virtual
name|uint8_t
operator|*
name|getGOTBase
argument_list|()
specifier|const
operator|=
literal|0
expr_stmt|;
comment|/// SetDlsymTable - If the JIT must be able to relocate stubs after they have
comment|/// been emitted, potentially because they are being copied to a process
comment|/// where external symbols live at different addresses than in the JITing
comment|///  process, allocate a table with sufficient information to do so.
name|virtual
name|void
name|SetDlsymTable
parameter_list|(
name|void
modifier|*
name|ptr
parameter_list|)
init|=
literal|0
function_decl|;
comment|/// getDlsymTable - If this is managing a table of entries so that stubs to
comment|/// external symbols can be later relocated, this method should return a
comment|/// pointer to it.
name|virtual
name|void
operator|*
name|getDlsymTable
argument_list|()
specifier|const
operator|=
literal|0
expr_stmt|;
comment|/// NeedsExactSize - If the memory manager requires to know the size of the
comment|/// objects to be emitted
name|bool
name|NeedsExactSize
argument_list|()
specifier|const
block|{
return|return
name|SizeRequired
return|;
block|}
comment|//===--------------------------------------------------------------------===//
comment|// Main Allocation Functions
comment|//===--------------------------------------------------------------------===//
comment|/// startFunctionBody - When we start JITing a function, the JIT calls this
comment|/// method to allocate a block of free RWX memory, which returns a pointer to
comment|/// it.  If the JIT wants to request a block of memory of at least a certain
comment|/// size, it passes that value as ActualSize, and this method returns a block
comment|/// with at least that much space.  If the JIT doesn't know ahead of time how
comment|/// much space it will need to emit the function, it passes 0 for the
comment|/// ActualSize.  In either case, this method is required to pass back the size
comment|/// of the allocated block through ActualSize.  The JIT will be careful to
comment|/// not write more than the returned ActualSize bytes of memory.
name|virtual
name|uint8_t
modifier|*
name|startFunctionBody
parameter_list|(
specifier|const
name|Function
modifier|*
name|F
parameter_list|,
name|uintptr_t
modifier|&
name|ActualSize
parameter_list|)
init|=
literal|0
function_decl|;
comment|/// allocateStub - This method is called by the JIT to allocate space for a
comment|/// function stub (used to handle limited branch displacements) while it is
comment|/// JIT compiling a function.  For example, if foo calls bar, and if bar
comment|/// either needs to be lazily compiled or is a native function that exists too
comment|/// far away from the call site to work, this method will be used to make a
comment|/// thunk for it.  The stub should be "close" to the current function body,
comment|/// but should not be included in the 'actualsize' returned by
comment|/// startFunctionBody.
name|virtual
name|uint8_t
modifier|*
name|allocateStub
parameter_list|(
specifier|const
name|GlobalValue
modifier|*
name|F
parameter_list|,
name|unsigned
name|StubSize
parameter_list|,
name|unsigned
name|Alignment
parameter_list|)
init|=
literal|0
function_decl|;
comment|/// endFunctionBody - This method is called when the JIT is done codegen'ing
comment|/// the specified function.  At this point we know the size of the JIT
comment|/// compiled function.  This passes in FunctionStart (which was returned by
comment|/// the startFunctionBody method) and FunctionEnd which is a pointer to the
comment|/// actual end of the function.  This method should mark the space allocated
comment|/// and remember where it is in case the client wants to deallocate it.
name|virtual
name|void
name|endFunctionBody
parameter_list|(
specifier|const
name|Function
modifier|*
name|F
parameter_list|,
name|uint8_t
modifier|*
name|FunctionStart
parameter_list|,
name|uint8_t
modifier|*
name|FunctionEnd
parameter_list|)
init|=
literal|0
function_decl|;
comment|/// allocateSpace - Allocate a memory block of the given size.  This method
comment|/// cannot be called between calls to startFunctionBody and endFunctionBody.
name|virtual
name|uint8_t
modifier|*
name|allocateSpace
parameter_list|(
name|intptr_t
name|Size
parameter_list|,
name|unsigned
name|Alignment
parameter_list|)
init|=
literal|0
function_decl|;
comment|/// allocateGlobal - Allocate memory for a global.
comment|///
name|virtual
name|uint8_t
modifier|*
name|allocateGlobal
parameter_list|(
name|uintptr_t
name|Size
parameter_list|,
name|unsigned
name|Alignment
parameter_list|)
init|=
literal|0
function_decl|;
comment|/// deallocateFunctionBody - Free the specified function body.  The argument
comment|/// must be the return value from a call to startFunctionBody() that hasn't
comment|/// been deallocated yet.  This is never called when the JIT is currently
comment|/// emitting a function.
name|virtual
name|void
name|deallocateFunctionBody
parameter_list|(
name|void
modifier|*
name|Body
parameter_list|)
init|=
literal|0
function_decl|;
comment|/// startExceptionTable - When we finished JITing the function, if exception
comment|/// handling is set, we emit the exception table.
name|virtual
name|uint8_t
modifier|*
name|startExceptionTable
parameter_list|(
specifier|const
name|Function
modifier|*
name|F
parameter_list|,
name|uintptr_t
modifier|&
name|ActualSize
parameter_list|)
init|=
literal|0
function_decl|;
comment|/// endExceptionTable - This method is called when the JIT is done emitting
comment|/// the exception table.
name|virtual
name|void
name|endExceptionTable
parameter_list|(
specifier|const
name|Function
modifier|*
name|F
parameter_list|,
name|uint8_t
modifier|*
name|TableStart
parameter_list|,
name|uint8_t
modifier|*
name|TableEnd
parameter_list|,
name|uint8_t
modifier|*
name|FrameRegister
parameter_list|)
init|=
literal|0
function_decl|;
comment|/// deallocateExceptionTable - Free the specified exception table's memory.
comment|/// The argument must be the return value from a call to startExceptionTable()
comment|/// that hasn't been deallocated yet.  This is never called when the JIT is
comment|/// currently emitting an exception table.
name|virtual
name|void
name|deallocateExceptionTable
parameter_list|(
name|void
modifier|*
name|ET
parameter_list|)
init|=
literal|0
function_decl|;
comment|/// CheckInvariants - For testing only.  Return true if all internal
comment|/// invariants are preserved, or return false and set ErrorStr to a helpful
comment|/// error message.
name|virtual
name|bool
name|CheckInvariants
argument_list|(
name|std
operator|::
name|string
operator|&
argument_list|)
block|{
return|return
name|true
return|;
block|}
comment|/// GetDefaultCodeSlabSize - For testing only.  Returns DefaultCodeSlabSize
comment|/// from DefaultJITMemoryManager.
name|virtual
name|size_t
name|GetDefaultCodeSlabSize
parameter_list|()
block|{
return|return
literal|0
return|;
block|}
comment|/// GetDefaultDataSlabSize - For testing only.  Returns DefaultCodeSlabSize
comment|/// from DefaultJITMemoryManager.
name|virtual
name|size_t
name|GetDefaultDataSlabSize
parameter_list|()
block|{
return|return
literal|0
return|;
block|}
comment|/// GetDefaultStubSlabSize - For testing only.  Returns DefaultCodeSlabSize
comment|/// from DefaultJITMemoryManager.
name|virtual
name|size_t
name|GetDefaultStubSlabSize
parameter_list|()
block|{
return|return
literal|0
return|;
block|}
comment|/// GetNumCodeSlabs - For testing only.  Returns the number of MemoryBlocks
comment|/// allocated for code.
name|virtual
name|unsigned
name|GetNumCodeSlabs
parameter_list|()
block|{
return|return
literal|0
return|;
block|}
comment|/// GetNumDataSlabs - For testing only.  Returns the number of MemoryBlocks
comment|/// allocated for data.
name|virtual
name|unsigned
name|GetNumDataSlabs
parameter_list|()
block|{
return|return
literal|0
return|;
block|}
comment|/// GetNumStubSlabs - For testing only.  Returns the number of MemoryBlocks
comment|/// allocated for function stubs.
name|virtual
name|unsigned
name|GetNumStubSlabs
parameter_list|()
block|{
return|return
literal|0
return|;
block|}
block|}
empty_stmt|;
block|}
end_decl_stmt

begin_comment
comment|// end namespace llvm.
end_comment

begin_endif
endif|#
directive|endif
end_endif

end_unit

