begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===- InstrProf.h - Instrumented profiling format support ------*- C++ -*-===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// Instrumentation-based profiling data is generated by instrumented
end_comment

begin_comment
comment|// binaries through library functions in compiler-rt, and read by the clang
end_comment

begin_comment
comment|// frontend to feed PGO.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LLVM_PROFILEDATA_INSTRPROF_H
end_ifndef

begin_define
define|#
directive|define
name|LLVM_PROFILEDATA_INSTRPROF_H
end_define

begin_include
include|#
directive|include
file|"llvm/ADT/ArrayRef.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/STLExtras.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/StringRef.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/StringSet.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/Triple.h"
end_include

begin_include
include|#
directive|include
file|"llvm/IR/GlobalValue.h"
end_include

begin_include
include|#
directive|include
file|"llvm/IR/ProfileSummary.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ProfileData/InstrProfData.inc"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/Compiler.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/Endian.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/Error.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/ErrorHandling.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/Host.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/MD5.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/MathExtras.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/raw_ostream.h"
end_include

begin_include
include|#
directive|include
file|<algorithm>
end_include

begin_include
include|#
directive|include
file|<cassert>
end_include

begin_include
include|#
directive|include
file|<cstddef>
end_include

begin_include
include|#
directive|include
file|<cstdint>
end_include

begin_include
include|#
directive|include
file|<cstring>
end_include

begin_include
include|#
directive|include
file|<list>
end_include

begin_include
include|#
directive|include
file|<memory>
end_include

begin_include
include|#
directive|include
file|<string>
end_include

begin_include
include|#
directive|include
file|<system_error>
end_include

begin_include
include|#
directive|include
file|<utility>
end_include

begin_include
include|#
directive|include
file|<vector>
end_include

begin_decl_stmt
name|namespace
name|llvm
block|{
name|class
name|Function
decl_stmt|;
name|class
name|GlobalVariable
decl_stmt|;
struct_decl|struct
name|InstrProfRecord
struct_decl|;
name|class
name|InstrProfSymtab
decl_stmt|;
name|class
name|Instruction
decl_stmt|;
name|class
name|MDNode
decl_stmt|;
name|class
name|Module
decl_stmt|;
enum|enum
name|InstrProfSectKind
block|{
define|#
directive|define
name|INSTR_PROF_SECT_ENTRY
parameter_list|(
name|Kind
parameter_list|,
name|SectNameCommon
parameter_list|,
name|SectNameCoff
parameter_list|,
name|Prefix
parameter_list|)
value|Kind,
include|#
directive|include
file|"llvm/ProfileData/InstrProfData.inc"
block|}
enum|;
comment|/// Return the name of the profile section corresponding to \p IPSK.
comment|///
comment|/// The name of the section depends on the object format type \p OF. If
comment|/// \p AddSegmentInfo is true, a segment prefix and additional linker hints may
comment|/// be added to the section name (this is the default).
name|std
operator|::
name|string
name|getInstrProfSectionName
argument_list|(
argument|InstrProfSectKind IPSK
argument_list|,
argument|Triple::ObjectFormatType OF
argument_list|,
argument|bool AddSegmentInfo = true
argument_list|)
expr_stmt|;
comment|/// Return the name profile runtime entry point to do value profiling
comment|/// for a given site.
specifier|inline
name|StringRef
name|getInstrProfValueProfFuncName
parameter_list|()
block|{
return|return
name|INSTR_PROF_VALUE_PROF_FUNC_STR
return|;
block|}
comment|/// Return the name profile runtime entry point to do value range profiling.
specifier|inline
name|StringRef
name|getInstrProfValueRangeProfFuncName
parameter_list|()
block|{
return|return
name|INSTR_PROF_VALUE_RANGE_PROF_FUNC_STR
return|;
block|}
comment|/// Return the name prefix of variables containing instrumented function names.
specifier|inline
name|StringRef
name|getInstrProfNameVarPrefix
parameter_list|()
block|{
return|return
literal|"__profn_"
return|;
block|}
comment|/// Return the name prefix of variables containing per-function control data.
specifier|inline
name|StringRef
name|getInstrProfDataVarPrefix
parameter_list|()
block|{
return|return
literal|"__profd_"
return|;
block|}
comment|/// Return the name prefix of profile counter variables.
specifier|inline
name|StringRef
name|getInstrProfCountersVarPrefix
parameter_list|()
block|{
return|return
literal|"__profc_"
return|;
block|}
comment|/// Return the name prefix of value profile variables.
specifier|inline
name|StringRef
name|getInstrProfValuesVarPrefix
parameter_list|()
block|{
return|return
literal|"__profvp_"
return|;
block|}
comment|/// Return the name of value profile node array variables:
specifier|inline
name|StringRef
name|getInstrProfVNodesVarName
parameter_list|()
block|{
return|return
literal|"__llvm_prf_vnodes"
return|;
block|}
comment|/// Return the name prefix of the COMDAT group for instrumentation variables
comment|/// associated with a COMDAT function.
specifier|inline
name|StringRef
name|getInstrProfComdatPrefix
parameter_list|()
block|{
return|return
literal|"__profv_"
return|;
block|}
comment|/// Return the name of the variable holding the strings (possibly compressed)
comment|/// of all function's PGO names.
specifier|inline
name|StringRef
name|getInstrProfNamesVarName
parameter_list|()
block|{
return|return
literal|"__llvm_prf_nm"
return|;
block|}
comment|/// Return the name of a covarage mapping variable (internal linkage)
comment|/// for each instrumented source module. Such variables are allocated
comment|/// in the __llvm_covmap section.
specifier|inline
name|StringRef
name|getCoverageMappingVarName
parameter_list|()
block|{
return|return
literal|"__llvm_coverage_mapping"
return|;
block|}
comment|/// Return the name of the internal variable recording the array
comment|/// of PGO name vars referenced by the coverage mapping. The owning
comment|/// functions of those names are not emitted by FE (e.g, unused inline
comment|/// functions.)
specifier|inline
name|StringRef
name|getCoverageUnusedNamesVarName
parameter_list|()
block|{
return|return
literal|"__llvm_coverage_names"
return|;
block|}
comment|/// Return the name of function that registers all the per-function control
comment|/// data at program startup time by calling __llvm_register_function. This
comment|/// function has internal linkage and is called by  __llvm_profile_init
comment|/// runtime method. This function is not generated for these platforms:
comment|/// Darwin, Linux, and FreeBSD.
specifier|inline
name|StringRef
name|getInstrProfRegFuncsName
parameter_list|()
block|{
return|return
literal|"__llvm_profile_register_functions"
return|;
block|}
comment|/// Return the name of the runtime interface that registers per-function control
comment|/// data for one instrumented function.
specifier|inline
name|StringRef
name|getInstrProfRegFuncName
parameter_list|()
block|{
return|return
literal|"__llvm_profile_register_function"
return|;
block|}
comment|/// Return the name of the runtime interface that registers the PGO name strings.
specifier|inline
name|StringRef
name|getInstrProfNamesRegFuncName
parameter_list|()
block|{
return|return
literal|"__llvm_profile_register_names_function"
return|;
block|}
comment|/// Return the name of the runtime initialization method that is generated by
comment|/// the compiler. The function calls __llvm_profile_register_functions and
comment|/// __llvm_profile_override_default_filename functions if needed. This function
comment|/// has internal linkage and invoked at startup time via init_array.
specifier|inline
name|StringRef
name|getInstrProfInitFuncName
parameter_list|()
block|{
return|return
literal|"__llvm_profile_init"
return|;
block|}
comment|/// Return the name of the hook variable defined in profile runtime library.
comment|/// A reference to the variable causes the linker to link in the runtime
comment|/// initialization module (which defines the hook variable).
specifier|inline
name|StringRef
name|getInstrProfRuntimeHookVarName
parameter_list|()
block|{
return|return
name|INSTR_PROF_QUOTE
argument_list|(
name|INSTR_PROF_PROFILE_RUNTIME_VAR
argument_list|)
return|;
block|}
comment|/// Return the name of the compiler generated function that references the
comment|/// runtime hook variable. The function is a weak global.
specifier|inline
name|StringRef
name|getInstrProfRuntimeHookVarUseFuncName
parameter_list|()
block|{
return|return
literal|"__llvm_profile_runtime_user"
return|;
block|}
comment|/// Return the marker used to separate PGO names during serialization.
specifier|inline
name|StringRef
name|getInstrProfNameSeparator
parameter_list|()
block|{
return|return
literal|"\01"
return|;
block|}
comment|/// Return the modified name for function \c F suitable to be
comment|/// used the key for profile lookup. Variable \c InLTO indicates if this
comment|/// is called in LTO optimization passes.
name|std
operator|::
name|string
name|getPGOFuncName
argument_list|(
argument|const Function&F
argument_list|,
argument|bool InLTO = false
argument_list|,
argument|uint64_t Version = INSTR_PROF_INDEX_VERSION
argument_list|)
expr_stmt|;
comment|/// Return the modified name for a function suitable to be
comment|/// used the key for profile lookup. The function's original
comment|/// name is \c RawFuncName and has linkage of type \c Linkage.
comment|/// The function is defined in module \c FileName.
name|std
operator|::
name|string
name|getPGOFuncName
argument_list|(
argument|StringRef RawFuncName
argument_list|,
argument|GlobalValue::LinkageTypes Linkage
argument_list|,
argument|StringRef FileName
argument_list|,
argument|uint64_t Version = INSTR_PROF_INDEX_VERSION
argument_list|)
expr_stmt|;
comment|/// Return the name of the global variable used to store a function
comment|/// name in PGO instrumentation. \c FuncName is the name of the function
comment|/// returned by the \c getPGOFuncName call.
name|std
operator|::
name|string
name|getPGOFuncNameVarName
argument_list|(
argument|StringRef FuncName
argument_list|,
argument|GlobalValue::LinkageTypes Linkage
argument_list|)
expr_stmt|;
comment|/// Create and return the global variable for function name used in PGO
comment|/// instrumentation. \c FuncName is the name of the function returned
comment|/// by \c getPGOFuncName call.
name|GlobalVariable
modifier|*
name|createPGOFuncNameVar
parameter_list|(
name|Function
modifier|&
name|F
parameter_list|,
name|StringRef
name|PGOFuncName
parameter_list|)
function_decl|;
comment|/// Create and return the global variable for function name used in PGO
comment|/// instrumentation.  /// \c FuncName is the name of the function
comment|/// returned by \c getPGOFuncName call, \c M is the owning module,
comment|/// and \c Linkage is the linkage of the instrumented function.
name|GlobalVariable
modifier|*
name|createPGOFuncNameVar
argument_list|(
name|Module
operator|&
name|M
argument_list|,
name|GlobalValue
operator|::
name|LinkageTypes
name|Linkage
argument_list|,
name|StringRef
name|PGOFuncName
argument_list|)
decl_stmt|;
comment|/// Return the initializer in string of the PGO name var \c NameVar.
name|StringRef
name|getPGOFuncNameVarInitializer
parameter_list|(
name|GlobalVariable
modifier|*
name|NameVar
parameter_list|)
function_decl|;
comment|/// Given a PGO function name, remove the filename prefix and return
comment|/// the original (static) function name.
name|StringRef
name|getFuncNameWithoutPrefix
parameter_list|(
name|StringRef
name|PGOFuncName
parameter_list|,
name|StringRef
name|FileName
init|=
literal|"<unknown>"
parameter_list|)
function_decl|;
comment|/// Given a vector of strings (function PGO names) \c NameStrs, the
comment|/// method generates a combined string \c Result thatis ready to be
comment|/// serialized.  The \c Result string is comprised of three fields:
comment|/// The first field is the legnth of the uncompressed strings, and the
comment|/// the second field is the length of the zlib-compressed string.
comment|/// Both fields are encoded in ULEB128.  If \c doCompress is false, the
comment|///  third field is the uncompressed strings; otherwise it is the
comment|/// compressed string. When the string compression is off, the
comment|/// second field will have value zero.
name|Error
name|collectPGOFuncNameStrings
argument_list|(
specifier|const
name|std
operator|::
name|vector
operator|<
name|std
operator|::
name|string
operator|>
operator|&
name|NameStrs
argument_list|,
name|bool
name|doCompression
argument_list|,
name|std
operator|::
name|string
operator|&
name|Result
argument_list|)
decl_stmt|;
comment|/// Produce \c Result string with the same format described above. The input
comment|/// is vector of PGO function name variables that are referenced.
name|Error
name|collectPGOFuncNameStrings
argument_list|(
specifier|const
name|std
operator|::
name|vector
operator|<
name|GlobalVariable
operator|*
operator|>
operator|&
name|NameVars
argument_list|,
name|std
operator|::
name|string
operator|&
name|Result
argument_list|,
name|bool
name|doCompression
operator|=
name|true
argument_list|)
decl_stmt|;
comment|/// \c NameStrings is a string composed of one of more sub-strings encoded in
comment|/// the format described above. The substrings are separated by 0 or more zero
comment|/// bytes. This method decodes the string and populates the \c Symtab.
name|Error
name|readPGOFuncNameStrings
parameter_list|(
name|StringRef
name|NameStrings
parameter_list|,
name|InstrProfSymtab
modifier|&
name|Symtab
parameter_list|)
function_decl|;
comment|/// Check if INSTR_PROF_RAW_VERSION_VAR is defined. This global is only being
comment|/// set in IR PGO compilation.
name|bool
name|isIRPGOFlagSet
parameter_list|(
specifier|const
name|Module
modifier|*
name|M
parameter_list|)
function_decl|;
comment|/// Check if we can safely rename this Comdat function. Instances of the same
comment|/// comdat function may have different control flows thus can not share the
comment|/// same counter variable.
name|bool
name|canRenameComdatFunc
parameter_list|(
specifier|const
name|Function
modifier|&
name|F
parameter_list|,
name|bool
name|CheckAddressTaken
init|=
name|false
parameter_list|)
function_decl|;
enum|enum
name|InstrProfValueKind
enum|:
name|uint32_t
block|{
define|#
directive|define
name|VALUE_PROF_KIND
parameter_list|(
name|Enumerator
parameter_list|,
name|Value
parameter_list|)
value|Enumerator = Value,
include|#
directive|include
file|"llvm/ProfileData/InstrProfData.inc"
block|}
enum|;
comment|/// Get the value profile data for value site \p SiteIdx from \p InstrProfR
comment|/// and annotate the instruction \p Inst with the value profile meta data.
comment|/// Annotate up to \p MaxMDCount (default 3) number of records per value site.
name|void
name|annotateValueSite
parameter_list|(
name|Module
modifier|&
name|M
parameter_list|,
name|Instruction
modifier|&
name|Inst
parameter_list|,
specifier|const
name|InstrProfRecord
modifier|&
name|InstrProfR
parameter_list|,
name|InstrProfValueKind
name|ValueKind
parameter_list|,
name|uint32_t
name|SiteIndx
parameter_list|,
name|uint32_t
name|MaxMDCount
init|=
literal|3
parameter_list|)
function_decl|;
comment|/// Same as the above interface but using an ArrayRef, as well as \p Sum.
name|void
name|annotateValueSite
argument_list|(
name|Module
operator|&
name|M
argument_list|,
name|Instruction
operator|&
name|Inst
argument_list|,
name|ArrayRef
operator|<
name|InstrProfValueData
operator|>
name|VDs
argument_list|,
name|uint64_t
name|Sum
argument_list|,
name|InstrProfValueKind
name|ValueKind
argument_list|,
name|uint32_t
name|MaxMDCount
argument_list|)
decl_stmt|;
comment|/// Extract the value profile data from \p Inst which is annotated with
comment|/// value profile meta data. Return false if there is no value data annotated,
comment|/// otherwise  return true.
name|bool
name|getValueProfDataFromInst
parameter_list|(
specifier|const
name|Instruction
modifier|&
name|Inst
parameter_list|,
name|InstrProfValueKind
name|ValueKind
parameter_list|,
name|uint32_t
name|MaxNumValueData
parameter_list|,
name|InstrProfValueData
name|ValueData
index|[]
parameter_list|,
name|uint32_t
modifier|&
name|ActualNumValueData
parameter_list|,
name|uint64_t
modifier|&
name|TotalC
parameter_list|)
function_decl|;
specifier|inline
name|StringRef
name|getPGOFuncNameMetadataName
parameter_list|()
block|{
return|return
literal|"PGOFuncName"
return|;
block|}
comment|/// Return the PGOFuncName meta data associated with a function.
name|MDNode
modifier|*
name|getPGOFuncNameMetadata
parameter_list|(
specifier|const
name|Function
modifier|&
name|F
parameter_list|)
function_decl|;
comment|/// Create the PGOFuncName meta data if PGOFuncName is different from
comment|/// function's raw name. This should only apply to internal linkage functions
comment|/// declared by users only.
name|void
name|createPGOFuncNameMetadata
parameter_list|(
name|Function
modifier|&
name|F
parameter_list|,
name|StringRef
name|PGOFuncName
parameter_list|)
function_decl|;
comment|/// Check if we can use Comdat for profile variables. This will eliminate
comment|/// the duplicated profile variables for Comdat functions.
name|bool
name|needsComdatForCounter
parameter_list|(
specifier|const
name|Function
modifier|&
name|F
parameter_list|,
specifier|const
name|Module
modifier|&
name|M
parameter_list|)
function_decl|;
specifier|const
name|std
operator|::
name|error_category
operator|&
name|instrprof_category
argument_list|()
expr_stmt|;
name|enum
name|class
name|instrprof_error
block|{
name|success
operator|=
literal|0
operator|,
name|eof
operator|,
name|unrecognized_format
operator|,
name|bad_magic
operator|,
name|bad_header
operator|,
name|unsupported_version
operator|,
name|unsupported_hash_type
operator|,
name|too_large
operator|,
name|truncated
operator|,
name|malformed
operator|,
name|unknown_function
operator|,
name|hash_mismatch
operator|,
name|count_mismatch
operator|,
name|counter_overflow
operator|,
name|value_site_count_mismatch
operator|,
name|compress_failed
operator|,
name|uncompress_failed
operator|,
name|empty_raw_profile
block|}
empty_stmt|;
specifier|inline
name|std
operator|::
name|error_code
name|make_error_code
argument_list|(
argument|instrprof_error E
argument_list|)
block|{
return|return
name|std
operator|::
name|error_code
argument_list|(
name|static_cast
operator|<
name|int
operator|>
operator|(
name|E
operator|)
argument_list|,
name|instrprof_category
argument_list|()
argument_list|)
return|;
block|}
name|class
name|InstrProfError
range|:
name|public
name|ErrorInfo
operator|<
name|InstrProfError
operator|>
block|{
name|public
operator|:
name|InstrProfError
argument_list|(
argument|instrprof_error Err
argument_list|)
operator|:
name|Err
argument_list|(
argument|Err
argument_list|)
block|{
name|assert
argument_list|(
name|Err
operator|!=
name|instrprof_error
operator|::
name|success
operator|&&
literal|"Not an error"
argument_list|)
block|;   }
name|std
operator|::
name|string
name|message
argument_list|()
specifier|const
name|override
block|;
name|void
name|log
argument_list|(
argument|raw_ostream&OS
argument_list|)
specifier|const
name|override
block|{
name|OS
operator|<<
name|message
argument_list|()
block|; }
name|std
operator|::
name|error_code
name|convertToErrorCode
argument_list|()
specifier|const
name|override
block|{
return|return
name|make_error_code
argument_list|(
name|Err
argument_list|)
return|;
block|}
name|instrprof_error
name|get
argument_list|()
specifier|const
block|{
return|return
name|Err
return|;
block|}
comment|/// Consume an Error and return the raw enum value contained within it. The
comment|/// Error must either be a success value, or contain a single InstrProfError.
specifier|static
name|instrprof_error
name|take
argument_list|(
argument|Error E
argument_list|)
block|{
name|auto
name|Err
operator|=
name|instrprof_error
operator|::
name|success
block|;
name|handleAllErrors
argument_list|(
name|std
operator|::
name|move
argument_list|(
name|E
argument_list|)
argument_list|,
index|[
operator|&
name|Err
index|]
operator|(
specifier|const
name|InstrProfError
operator|&
name|IPE
operator|)
block|{
name|assert
argument_list|(
name|Err
operator|==
name|instrprof_error
operator|::
name|success
operator|&&
literal|"Multiple errors encountered"
argument_list|)
block|;
name|Err
operator|=
name|IPE
operator|.
name|get
argument_list|()
block|;     }
argument_list|)
block|;
return|return
name|Err
return|;
block|}
specifier|static
name|char
name|ID
block|;
name|private
operator|:
name|instrprof_error
name|Err
block|; }
decl_stmt|;
name|class
name|SoftInstrProfErrors
block|{
comment|/// Count the number of soft instrprof_errors encountered and keep track of
comment|/// the first such error for reporting purposes.
comment|/// The first soft error encountered.
name|instrprof_error
name|FirstError
init|=
name|instrprof_error
operator|::
name|success
decl_stmt|;
comment|/// The number of hash mismatches.
name|unsigned
name|NumHashMismatches
init|=
literal|0
decl_stmt|;
comment|/// The number of count mismatches.
name|unsigned
name|NumCountMismatches
init|=
literal|0
decl_stmt|;
comment|/// The number of counter overflows.
name|unsigned
name|NumCounterOverflows
init|=
literal|0
decl_stmt|;
comment|/// The number of value site count mismatches.
name|unsigned
name|NumValueSiteCountMismatches
init|=
literal|0
decl_stmt|;
name|public
label|:
name|SoftInstrProfErrors
argument_list|()
operator|=
expr|default
expr_stmt|;
operator|~
name|SoftInstrProfErrors
argument_list|()
block|{
name|assert
argument_list|(
name|FirstError
operator|==
name|instrprof_error
operator|::
name|success
operator|&&
literal|"Unchecked soft error encountered"
argument_list|)
block|;   }
comment|/// Track a soft error (\p IE) and increment its associated counter.
name|void
name|addError
argument_list|(
argument|instrprof_error IE
argument_list|)
expr_stmt|;
comment|/// Get the number of hash mismatches.
name|unsigned
name|getNumHashMismatches
argument_list|()
specifier|const
block|{
return|return
name|NumHashMismatches
return|;
block|}
comment|/// Get the number of count mismatches.
name|unsigned
name|getNumCountMismatches
argument_list|()
specifier|const
block|{
return|return
name|NumCountMismatches
return|;
block|}
comment|/// Get the number of counter overflows.
name|unsigned
name|getNumCounterOverflows
argument_list|()
specifier|const
block|{
return|return
name|NumCounterOverflows
return|;
block|}
comment|/// Get the number of value site count mismatches.
name|unsigned
name|getNumValueSiteCountMismatches
argument_list|()
specifier|const
block|{
return|return
name|NumValueSiteCountMismatches
return|;
block|}
comment|/// Return the first encountered error and reset FirstError to a success
comment|/// value.
name|Error
name|takeError
parameter_list|()
block|{
if|if
condition|(
name|FirstError
operator|==
name|instrprof_error
operator|::
name|success
condition|)
return|return
name|Error
operator|::
name|success
argument_list|()
return|;
name|auto
name|E
init|=
name|make_error
operator|<
name|InstrProfError
operator|>
operator|(
name|FirstError
operator|)
decl_stmt|;
name|FirstError
operator|=
name|instrprof_error
operator|::
name|success
expr_stmt|;
return|return
name|E
return|;
block|}
block|}
empty_stmt|;
name|namespace
name|object
block|{
name|class
name|SectionRef
decl_stmt|;
block|}
comment|// end namespace object
name|namespace
name|IndexedInstrProf
block|{
name|uint64_t
name|ComputeHash
parameter_list|(
name|StringRef
name|K
parameter_list|)
function_decl|;
block|}
comment|// end namespace IndexedInstrProf
comment|/// A symbol table used for function PGO name look-up with keys
comment|/// (such as pointers, md5hash values) to the function. A function's
comment|/// PGO name or name's md5hash are used in retrieving the profile
comment|/// data of the function. See \c getPGOFuncName() method for details
comment|/// on how PGO name is formed.
name|class
name|InstrProfSymtab
block|{
name|public
label|:
typedef|typedef
name|std
operator|::
name|vector
operator|<
name|std
operator|::
name|pair
operator|<
name|uint64_t
operator|,
name|uint64_t
operator|>>
name|AddrHashMap
expr_stmt|;
name|private
label|:
name|StringRef
name|Data
decl_stmt|;
name|uint64_t
name|Address
init|=
literal|0
decl_stmt|;
comment|// Unique name strings.
name|StringSet
operator|<
operator|>
name|NameTab
expr_stmt|;
comment|// A map from MD5 keys to function name strings.
name|std
operator|::
name|vector
operator|<
name|std
operator|::
name|pair
operator|<
name|uint64_t
operator|,
name|StringRef
operator|>>
name|MD5NameMap
expr_stmt|;
comment|// A map from MD5 keys to function define. We only populate this map
comment|// when build the Symtab from a Module.
name|std
operator|::
name|vector
operator|<
name|std
operator|::
name|pair
operator|<
name|uint64_t
operator|,
name|Function
operator|*
operator|>>
name|MD5FuncMap
expr_stmt|;
comment|// A map from function runtime address to function name MD5 hash.
comment|// This map is only populated and used by raw instr profile reader.
name|AddrHashMap
name|AddrToMD5Map
decl_stmt|;
name|public
label|:
name|InstrProfSymtab
argument_list|()
operator|=
expr|default
expr_stmt|;
comment|/// Create InstrProfSymtab from an object file section which
comment|/// contains function PGO names. When section may contain raw
comment|/// string data or string data in compressed form. This method
comment|/// only initialize the symtab with reference to the data and
comment|/// the section base address. The decompression will be delayed
comment|/// until before it is used. See also \c create(StringRef) method.
name|Error
name|create
argument_list|(
name|object
operator|::
name|SectionRef
operator|&
name|Section
argument_list|)
decl_stmt|;
comment|/// This interface is used by reader of CoverageMapping test
comment|/// format.
specifier|inline
name|Error
name|create
parameter_list|(
name|StringRef
name|D
parameter_list|,
name|uint64_t
name|BaseAddr
parameter_list|)
function_decl|;
comment|/// \c NameStrings is a string composed of one of more sub-strings
comment|///  encoded in the format described in \c collectPGOFuncNameStrings.
comment|/// This method is a wrapper to \c readPGOFuncNameStrings method.
specifier|inline
name|Error
name|create
parameter_list|(
name|StringRef
name|NameStrings
parameter_list|)
function_decl|;
comment|/// A wrapper interface to populate the PGO symtab with functions
comment|/// decls from module \c M. This interface is used by transformation
comment|/// passes such as indirect function call promotion. Variable \c InLTO
comment|/// indicates if this is called from LTO optimization passes.
name|void
name|create
parameter_list|(
name|Module
modifier|&
name|M
parameter_list|,
name|bool
name|InLTO
init|=
name|false
parameter_list|)
function_decl|;
comment|/// Create InstrProfSymtab from a set of names iteratable from
comment|/// \p IterRange. This interface is used by IndexedProfReader.
name|template
operator|<
name|typename
name|NameIterRange
operator|>
name|void
name|create
argument_list|(
specifier|const
name|NameIterRange
operator|&
name|IterRange
argument_list|)
expr_stmt|;
comment|// If the symtab is created by a series of calls to \c addFuncName, \c
comment|// finalizeSymtab needs to be called before looking up function names.
comment|// This is required because the underlying map is a vector (for space
comment|// efficiency) which needs to be sorted.
specifier|inline
name|void
name|finalizeSymtab
parameter_list|()
function_decl|;
comment|/// Update the symtab by adding \p FuncName to the table. This interface
comment|/// is used by the raw and text profile readers.
name|void
name|addFuncName
parameter_list|(
name|StringRef
name|FuncName
parameter_list|)
block|{
name|auto
name|Ins
init|=
name|NameTab
operator|.
name|insert
argument_list|(
name|FuncName
argument_list|)
decl_stmt|;
if|if
condition|(
name|Ins
operator|.
name|second
condition|)
name|MD5NameMap
operator|.
name|push_back
argument_list|(
name|std
operator|::
name|make_pair
argument_list|(
name|IndexedInstrProf
operator|::
name|ComputeHash
argument_list|(
name|FuncName
argument_list|)
argument_list|,
name|Ins
operator|.
name|first
operator|->
name|getKey
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/// Map a function address to its name's MD5 hash. This interface
comment|/// is only used by the raw profiler reader.
name|void
name|mapAddress
parameter_list|(
name|uint64_t
name|Addr
parameter_list|,
name|uint64_t
name|MD5Val
parameter_list|)
block|{
name|AddrToMD5Map
operator|.
name|push_back
argument_list|(
name|std
operator|::
name|make_pair
argument_list|(
name|Addr
argument_list|,
name|MD5Val
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|AddrHashMap
modifier|&
name|getAddrHashMap
parameter_list|()
block|{
return|return
name|AddrToMD5Map
return|;
block|}
comment|/// Return function's PGO name from the function name's symbol
comment|/// address in the object file. If an error occurs, return
comment|/// an empty string.
name|StringRef
name|getFuncName
parameter_list|(
name|uint64_t
name|FuncNameAddress
parameter_list|,
name|size_t
name|NameSize
parameter_list|)
function_decl|;
comment|/// Return function's PGO name from the name's md5 hash value.
comment|/// If not found, return an empty string.
specifier|inline
name|StringRef
name|getFuncName
parameter_list|(
name|uint64_t
name|FuncMD5Hash
parameter_list|)
function_decl|;
comment|/// Return function from the name's md5 hash. Return nullptr if not found.
specifier|inline
name|Function
modifier|*
name|getFunction
parameter_list|(
name|uint64_t
name|FuncMD5Hash
parameter_list|)
function_decl|;
comment|/// Return the function's original assembly name by stripping off
comment|/// the prefix attached (to symbols with priviate linkage). For
comment|/// global functions, it returns the same string as getFuncName.
specifier|inline
name|StringRef
name|getOrigFuncName
parameter_list|(
name|uint64_t
name|FuncMD5Hash
parameter_list|)
function_decl|;
comment|/// Return the name section data.
specifier|inline
name|StringRef
name|getNameData
argument_list|()
specifier|const
block|{
return|return
name|Data
return|;
block|}
block|}
empty_stmt|;
name|Error
name|InstrProfSymtab
operator|::
name|create
argument_list|(
argument|StringRef D
argument_list|,
argument|uint64_t BaseAddr
argument_list|)
block|{
name|Data
operator|=
name|D
block|;
name|Address
operator|=
name|BaseAddr
block|;
return|return
name|Error
operator|::
name|success
argument_list|()
return|;
block|}
name|Error
name|InstrProfSymtab
operator|::
name|create
argument_list|(
argument|StringRef NameStrings
argument_list|)
block|{
return|return
name|readPGOFuncNameStrings
argument_list|(
name|NameStrings
argument_list|,
operator|*
name|this
argument_list|)
return|;
block|}
name|template
operator|<
name|typename
name|NameIterRange
operator|>
name|void
name|InstrProfSymtab
operator|::
name|create
argument_list|(
argument|const NameIterRange&IterRange
argument_list|)
block|{
for|for
control|(
name|auto
name|Name
range|:
name|IterRange
control|)
name|addFuncName
argument_list|(
name|Name
argument_list|)
expr_stmt|;
name|finalizeSymtab
argument_list|()
expr_stmt|;
block|}
end_decl_stmt

begin_expr_stmt
name|void
name|InstrProfSymtab
operator|::
name|finalizeSymtab
argument_list|()
block|{
name|std
operator|::
name|sort
argument_list|(
name|MD5NameMap
operator|.
name|begin
argument_list|()
argument_list|,
name|MD5NameMap
operator|.
name|end
argument_list|()
argument_list|,
name|less_first
argument_list|()
argument_list|)
block|;
name|std
operator|::
name|sort
argument_list|(
name|MD5FuncMap
operator|.
name|begin
argument_list|()
argument_list|,
name|MD5FuncMap
operator|.
name|end
argument_list|()
argument_list|,
name|less_first
argument_list|()
argument_list|)
block|;
name|std
operator|::
name|sort
argument_list|(
name|AddrToMD5Map
operator|.
name|begin
argument_list|()
argument_list|,
name|AddrToMD5Map
operator|.
name|end
argument_list|()
argument_list|,
name|less_first
argument_list|()
argument_list|)
block|;
name|AddrToMD5Map
operator|.
name|erase
argument_list|(
name|std
operator|::
name|unique
argument_list|(
name|AddrToMD5Map
operator|.
name|begin
argument_list|()
argument_list|,
name|AddrToMD5Map
operator|.
name|end
argument_list|()
argument_list|)
argument_list|,
name|AddrToMD5Map
operator|.
name|end
argument_list|()
argument_list|)
block|; }
name|StringRef
name|InstrProfSymtab
operator|::
name|getFuncName
argument_list|(
argument|uint64_t FuncMD5Hash
argument_list|)
block|{
name|auto
name|Result
operator|=
name|std
operator|::
name|lower_bound
argument_list|(
name|MD5NameMap
operator|.
name|begin
argument_list|()
argument_list|,
name|MD5NameMap
operator|.
name|end
argument_list|()
argument_list|,
name|FuncMD5Hash
argument_list|,
index|[]
operator|(
specifier|const
name|std
operator|::
name|pair
operator|<
name|uint64_t
operator|,
name|std
operator|::
name|string
operator|>
operator|&
name|LHS
operator|,
name|uint64_t
name|RHS
operator|)
block|{
return|return
name|LHS
operator|.
name|first
operator|<
name|RHS
return|;
block|}
end_expr_stmt

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_if
if|if
condition|(
name|Result
operator|!=
name|MD5NameMap
operator|.
name|end
argument_list|()
operator|&&
name|Result
operator|->
name|first
operator|==
name|FuncMD5Hash
condition|)
return|return
name|Result
operator|->
name|second
return|;
end_if

begin_return
return|return
name|StringRef
argument_list|()
return|;
end_return

begin_expr_stmt
unit|}  Function
operator|*
name|InstrProfSymtab
operator|::
name|getFunction
argument_list|(
argument|uint64_t FuncMD5Hash
argument_list|)
block|{
name|auto
name|Result
operator|=
name|std
operator|::
name|lower_bound
argument_list|(
name|MD5FuncMap
operator|.
name|begin
argument_list|()
argument_list|,
name|MD5FuncMap
operator|.
name|end
argument_list|()
argument_list|,
name|FuncMD5Hash
argument_list|,
index|[]
operator|(
specifier|const
name|std
operator|::
name|pair
operator|<
name|uint64_t
operator|,
name|Function
operator|*
operator|>
operator|&
name|LHS
operator|,
name|uint64_t
name|RHS
operator|)
block|{
return|return
name|LHS
operator|.
name|first
operator|<
name|RHS
return|;
block|}
end_expr_stmt

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_if
if|if
condition|(
name|Result
operator|!=
name|MD5FuncMap
operator|.
name|end
argument_list|()
operator|&&
name|Result
operator|->
name|first
operator|==
name|FuncMD5Hash
condition|)
return|return
name|Result
operator|->
name|second
return|;
end_if

begin_return
return|return
name|nullptr
return|;
end_return

begin_comment
unit|}
comment|// See also getPGOFuncName implementation. These two need to be
end_comment

begin_comment
comment|// matched.
end_comment

begin_expr_stmt
unit|StringRef
name|InstrProfSymtab
operator|::
name|getOrigFuncName
argument_list|(
argument|uint64_t FuncMD5Hash
argument_list|)
block|{
name|StringRef
name|PGOName
operator|=
name|getFuncName
argument_list|(
name|FuncMD5Hash
argument_list|)
block|;
name|size_t
name|S
operator|=
name|PGOName
operator|.
name|find_first_of
argument_list|(
literal|':'
argument_list|)
block|;
if|if
condition|(
name|S
operator|==
name|StringRef
operator|::
name|npos
condition|)
return|return
name|PGOName
return|;
end_expr_stmt

begin_return
return|return
name|PGOName
operator|.
name|drop_front
argument_list|(
name|S
operator|+
literal|1
argument_list|)
return|;
end_return

begin_macro
unit|}  struct
name|InstrProfValueSiteRecord
end_macro

begin_block
block|{
comment|/// Value profiling data pairs at a given value site.
name|std
operator|::
name|list
operator|<
name|InstrProfValueData
operator|>
name|ValueData
expr_stmt|;
name|InstrProfValueSiteRecord
argument_list|()
block|{
name|ValueData
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
name|template
operator|<
name|class
name|InputIterator
operator|>
name|InstrProfValueSiteRecord
argument_list|(
argument|InputIterator F
argument_list|,
argument|InputIterator L
argument_list|)
operator|:
name|ValueData
argument_list|(
argument|F
argument_list|,
argument|L
argument_list|)
block|{}
comment|/// Sort ValueData ascending by Value
name|void
name|sortByTargetValues
argument_list|()
block|{
name|ValueData
operator|.
name|sort
argument_list|(
index|[]
operator|(
specifier|const
name|InstrProfValueData
operator|&
name|left
operator|,
specifier|const
name|InstrProfValueData
operator|&
name|right
operator|)
block|{
return|return
name|left
operator|.
name|Value
operator|<
name|right
operator|.
name|Value
return|;
block|}
block|)
end_block

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_comment
unit|}
comment|/// Sort ValueData Descending by Count
end_comment

begin_function_decl
unit|inline
name|void
name|sortByCount
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/// Merge data from another InstrProfValueSiteRecord
end_comment

begin_comment
comment|/// Optionally scale merged counts by \p Weight.
end_comment

begin_function_decl
name|void
name|merge
parameter_list|(
name|SoftInstrProfErrors
modifier|&
name|SIPE
parameter_list|,
name|InstrProfValueSiteRecord
modifier|&
name|Input
parameter_list|,
name|uint64_t
name|Weight
init|=
literal|1
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/// Scale up value profile data counts.
end_comment

begin_function_decl
name|void
name|scale
parameter_list|(
name|SoftInstrProfErrors
modifier|&
name|SIPE
parameter_list|,
name|uint64_t
name|Weight
parameter_list|)
function_decl|;
end_function_decl

begin_comment
unit|};
comment|/// Profiling information for a single function.
end_comment

begin_struct
struct|struct
name|InstrProfRecord
block|{
name|StringRef
name|Name
decl_stmt|;
name|uint64_t
name|Hash
decl_stmt|;
name|std
operator|::
name|vector
operator|<
name|uint64_t
operator|>
name|Counts
expr_stmt|;
name|SoftInstrProfErrors
name|SIPE
decl_stmt|;
name|InstrProfRecord
argument_list|()
operator|=
expr|default
expr_stmt|;
name|InstrProfRecord
argument_list|(
argument|StringRef Name
argument_list|,
argument|uint64_t Hash
argument_list|,
argument|std::vector<uint64_t> Counts
argument_list|)
block|:
name|Name
argument_list|(
name|Name
argument_list|)
operator|,
name|Hash
argument_list|(
name|Hash
argument_list|)
operator|,
name|Counts
argument_list|(
argument|std::move(Counts)
argument_list|)
block|{}
typedef|typedef
name|std
operator|::
name|vector
operator|<
name|std
operator|::
name|pair
operator|<
name|uint64_t
operator|,
name|uint64_t
operator|>>
name|ValueMapType
expr_stmt|;
comment|/// Return the number of value profile kinds with non-zero number
comment|/// of profile sites.
specifier|inline
name|uint32_t
name|getNumValueKinds
argument_list|()
specifier|const
expr_stmt|;
comment|/// Return the number of instrumented sites for ValueKind.
specifier|inline
name|uint32_t
name|getNumValueSites
argument_list|(
name|uint32_t
name|ValueKind
argument_list|)
decl|const
decl_stmt|;
comment|/// Return the total number of ValueData for ValueKind.
specifier|inline
name|uint32_t
name|getNumValueData
argument_list|(
name|uint32_t
name|ValueKind
argument_list|)
decl|const
decl_stmt|;
comment|/// Return the number of value data collected for ValueKind at profiling
comment|/// site: Site.
specifier|inline
name|uint32_t
name|getNumValueDataForSite
argument_list|(
name|uint32_t
name|ValueKind
argument_list|,
name|uint32_t
name|Site
argument_list|)
decl|const
decl_stmt|;
comment|/// Return the array of profiled values at \p Site. If \p TotalC
comment|/// is not null, the total count of all target values at this site
comment|/// will be stored in \c *TotalC.
specifier|inline
name|std
operator|::
name|unique_ptr
operator|<
name|InstrProfValueData
index|[]
operator|>
name|getValueForSite
argument_list|(
argument|uint32_t ValueKind
argument_list|,
argument|uint32_t Site
argument_list|,
argument|uint64_t *TotalC = nullptr
argument_list|)
specifier|const
expr_stmt|;
comment|/// Get the target value/counts of kind \p ValueKind collected at site
comment|/// \p Site and store the result in array \p Dest. Return the total
comment|/// counts of all target values at this site.
specifier|inline
name|uint64_t
name|getValueForSite
argument_list|(
name|InstrProfValueData
name|Dest
index|[]
argument_list|,
name|uint32_t
name|ValueKind
argument_list|,
name|uint32_t
name|Site
argument_list|)
decl|const
decl_stmt|;
comment|/// Reserve space for NumValueSites sites.
specifier|inline
name|void
name|reserveSites
parameter_list|(
name|uint32_t
name|ValueKind
parameter_list|,
name|uint32_t
name|NumValueSites
parameter_list|)
function_decl|;
comment|/// Add ValueData for ValueKind at value Site.
name|void
name|addValueData
parameter_list|(
name|uint32_t
name|ValueKind
parameter_list|,
name|uint32_t
name|Site
parameter_list|,
name|InstrProfValueData
modifier|*
name|VData
parameter_list|,
name|uint32_t
name|N
parameter_list|,
name|ValueMapType
modifier|*
name|ValueMap
parameter_list|)
function_decl|;
comment|/// Merge the counts in \p Other into this one.
comment|/// Optionally scale merged counts by \p Weight.
name|void
name|merge
parameter_list|(
name|InstrProfRecord
modifier|&
name|Other
parameter_list|,
name|uint64_t
name|Weight
init|=
literal|1
parameter_list|)
function_decl|;
comment|/// Scale up profile counts (including value profile data) by
comment|/// \p Weight.
name|void
name|scale
parameter_list|(
name|uint64_t
name|Weight
parameter_list|)
function_decl|;
comment|/// Sort value profile data (per site) by count.
name|void
name|sortValueData
parameter_list|()
block|{
for|for
control|(
name|uint32_t
name|Kind
init|=
name|IPVK_First
init|;
name|Kind
operator|<=
name|IPVK_Last
condition|;
operator|++
name|Kind
control|)
block|{
name|std
operator|::
name|vector
operator|<
name|InstrProfValueSiteRecord
operator|>
operator|&
name|SiteRecords
operator|=
name|getValueSitesForKind
argument_list|(
name|Kind
argument_list|)
expr_stmt|;
for|for
control|(
name|auto
operator|&
name|SR
operator|:
name|SiteRecords
control|)
name|SR
operator|.
name|sortByCount
argument_list|()
expr_stmt|;
block|}
block|}
comment|/// Clear value data entries and edge counters.
name|void
name|Clear
parameter_list|()
block|{
name|Counts
operator|.
name|clear
argument_list|()
expr_stmt|;
name|clearValueData
argument_list|()
expr_stmt|;
block|}
comment|/// Clear value data entries
name|void
name|clearValueData
parameter_list|()
block|{
for|for
control|(
name|uint32_t
name|Kind
init|=
name|IPVK_First
init|;
name|Kind
operator|<=
name|IPVK_Last
condition|;
operator|++
name|Kind
control|)
name|getValueSitesForKind
argument_list|(
name|Kind
argument_list|)
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
comment|/// Get the error contained within the record's soft error counter.
name|Error
name|takeError
parameter_list|()
block|{
return|return
name|SIPE
operator|.
name|takeError
argument_list|()
return|;
block|}
name|private
label|:
name|std
operator|::
name|vector
operator|<
name|InstrProfValueSiteRecord
operator|>
name|IndirectCallSites
expr_stmt|;
name|std
operator|::
name|vector
operator|<
name|InstrProfValueSiteRecord
operator|>
name|MemOPSizes
expr_stmt|;
specifier|const
name|std
operator|::
name|vector
operator|<
name|InstrProfValueSiteRecord
operator|>
operator|&
name|getValueSitesForKind
argument_list|(
argument|uint32_t ValueKind
argument_list|)
specifier|const
block|{
switch|switch
condition|(
name|ValueKind
condition|)
block|{
case|case
name|IPVK_IndirectCallTarget
case|:
return|return
name|IndirectCallSites
return|;
case|case
name|IPVK_MemOPSize
case|:
return|return
name|MemOPSizes
return|;
default|default:
name|llvm_unreachable
argument_list|(
literal|"Unknown value kind!"
argument_list|)
expr_stmt|;
block|}
return|return
name|IndirectCallSites
return|;
block|}
name|std
decl|::
name|vector
decl|<
name|InstrProfValueSiteRecord
decl|>
modifier|&
name|getValueSitesForKind
argument_list|(
name|uint32_t
name|ValueKind
argument_list|)
block|{
return|return
name|const_cast
operator|<
name|std
operator|::
name|vector
operator|<
name|InstrProfValueSiteRecord
operator|>
operator|&
operator|>
operator|(
name|const_cast
operator|<
specifier|const
name|InstrProfRecord
operator|*
operator|>
operator|(
name|this
operator|)
operator|->
name|getValueSitesForKind
argument_list|(
name|ValueKind
argument_list|)
operator|)
return|;
block|}
comment|// Map indirect call target name hash to name string.
name|uint64_t
name|remapValue
argument_list|(
name|uint64_t
name|Value
argument_list|,
name|uint32_t
name|ValueKind
argument_list|,
name|ValueMapType
operator|*
name|HashKeys
argument_list|)
struct|;
end_struct

begin_comment
comment|// Merge Value Profile data from Src record to this record for ValueKind.
end_comment

begin_comment
comment|// Scale merged value counts by \p Weight.
end_comment

begin_function_decl
name|void
name|mergeValueProfData
parameter_list|(
name|uint32_t
name|ValueKind
parameter_list|,
name|InstrProfRecord
modifier|&
name|Src
parameter_list|,
name|uint64_t
name|Weight
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|// Scale up value profile data count.
end_comment

begin_function_decl
name|void
name|scaleValueProfData
parameter_list|(
name|uint32_t
name|ValueKind
parameter_list|,
name|uint64_t
name|Weight
parameter_list|)
function_decl|;
end_function_decl

begin_expr_stmt
unit|};
name|uint32_t
name|InstrProfRecord
operator|::
name|getNumValueKinds
argument_list|()
specifier|const
block|{
name|uint32_t
name|NumValueKinds
operator|=
literal|0
block|;
for|for
control|(
name|uint32_t
name|Kind
init|=
name|IPVK_First
init|;
name|Kind
operator|<=
name|IPVK_Last
condition|;
operator|++
name|Kind
control|)
name|NumValueKinds
operator|+=
operator|!
operator|(
name|getValueSitesForKind
argument_list|(
name|Kind
argument_list|)
operator|.
name|empty
argument_list|()
operator|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|NumValueKinds
return|;
end_return

begin_expr_stmt
unit|}  uint32_t
name|InstrProfRecord
operator|::
name|getNumValueData
argument_list|(
argument|uint32_t ValueKind
argument_list|)
specifier|const
block|{
name|uint32_t
name|N
operator|=
literal|0
block|;
specifier|const
name|std
operator|::
name|vector
operator|<
name|InstrProfValueSiteRecord
operator|>
operator|&
name|SiteRecords
operator|=
name|getValueSitesForKind
argument_list|(
name|ValueKind
argument_list|)
block|;
for|for
control|(
name|auto
operator|&
name|SR
operator|:
name|SiteRecords
control|)
block|{
name|N
operator|+=
name|SR
operator|.
name|ValueData
operator|.
name|size
argument_list|()
expr_stmt|;
block|}
end_expr_stmt

begin_return
return|return
name|N
return|;
end_return

begin_expr_stmt
unit|}  uint32_t
name|InstrProfRecord
operator|::
name|getNumValueSites
argument_list|(
argument|uint32_t ValueKind
argument_list|)
specifier|const
block|{
return|return
name|getValueSitesForKind
argument_list|(
name|ValueKind
argument_list|)
operator|.
name|size
argument_list|()
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|uint32_t
name|InstrProfRecord
operator|::
name|getNumValueDataForSite
argument_list|(
argument|uint32_t ValueKind
argument_list|,
argument|uint32_t Site
argument_list|)
specifier|const
block|{
return|return
name|getValueSitesForKind
argument_list|(
name|ValueKind
argument_list|)
index|[
name|Site
index|]
operator|.
name|ValueData
operator|.
name|size
argument_list|()
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|std
operator|::
name|unique_ptr
operator|<
name|InstrProfValueData
index|[]
operator|>
name|InstrProfRecord
operator|::
name|getValueForSite
argument_list|(
argument|uint32_t ValueKind
argument_list|,
argument|uint32_t Site
argument_list|,
argument|uint64_t *TotalC
argument_list|)
specifier|const
block|{
name|uint64_t
name|Dummy
block|;
name|uint64_t
operator|&
name|TotalCount
operator|=
operator|(
name|TotalC
operator|==
name|nullptr
condition|?
name|Dummy
else|:
operator|*
name|TotalC
operator|)
block|;
name|uint32_t
name|N
operator|=
name|getNumValueDataForSite
argument_list|(
name|ValueKind
argument_list|,
name|Site
argument_list|)
block|;
if|if
condition|(
name|N
operator|==
literal|0
condition|)
block|{
name|TotalCount
operator|=
literal|0
expr_stmt|;
return|return
name|std
operator|::
name|unique_ptr
operator|<
name|InstrProfValueData
index|[]
operator|>
operator|(
name|nullptr
operator|)
return|;
block|}
name|auto
name|VD
operator|=
name|llvm
operator|::
name|make_unique
operator|<
name|InstrProfValueData
index|[]
operator|>
operator|(
name|N
operator|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|TotalCount
operator|=
name|getValueForSite
argument_list|(
name|VD
operator|.
name|get
argument_list|()
argument_list|,
name|ValueKind
argument_list|,
name|Site
argument_list|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|VD
return|;
end_return

begin_expr_stmt
unit|}  uint64_t
name|InstrProfRecord
operator|::
name|getValueForSite
argument_list|(
argument|InstrProfValueData Dest[]
argument_list|,
argument|uint32_t ValueKind
argument_list|,
argument|uint32_t Site
argument_list|)
specifier|const
block|{
name|uint32_t
name|I
operator|=
literal|0
block|;
name|uint64_t
name|TotalCount
operator|=
literal|0
block|;
for|for
control|(
name|auto
name|V
range|:
name|getValueSitesForKind
argument_list|(
name|ValueKind
argument_list|)
index|[
name|Site
index|]
operator|.
name|ValueData
control|)
block|{
name|Dest
index|[
name|I
index|]
operator|.
name|Value
operator|=
name|V
operator|.
name|Value
expr_stmt|;
name|Dest
index|[
name|I
index|]
operator|.
name|Count
operator|=
name|V
operator|.
name|Count
expr_stmt|;
name|TotalCount
operator|=
name|SaturatingAdd
argument_list|(
name|TotalCount
argument_list|,
name|V
operator|.
name|Count
argument_list|)
expr_stmt|;
name|I
operator|++
expr_stmt|;
block|}
end_expr_stmt

begin_return
return|return
name|TotalCount
return|;
end_return

begin_expr_stmt
unit|}  void
name|InstrProfRecord
operator|::
name|reserveSites
argument_list|(
argument|uint32_t ValueKind
argument_list|,
argument|uint32_t NumValueSites
argument_list|)
block|{
name|std
operator|::
name|vector
operator|<
name|InstrProfValueSiteRecord
operator|>
operator|&
name|ValueSites
operator|=
name|getValueSitesForKind
argument_list|(
name|ValueKind
argument_list|)
block|;
name|ValueSites
operator|.
name|reserve
argument_list|(
name|NumValueSites
argument_list|)
block|; }
specifier|inline
name|support
operator|::
name|endianness
name|getHostEndianness
argument_list|()
block|{
return|return
name|sys
operator|::
name|IsLittleEndianHost
operator|?
name|support
operator|::
name|little
operator|:
name|support
operator|::
name|big
return|;
block|}
end_expr_stmt

begin_comment
comment|// Include definitions for value profile data
end_comment

begin_define
define|#
directive|define
name|INSTR_PROF_VALUE_PROF_DATA
end_define

begin_include
include|#
directive|include
file|"llvm/ProfileData/InstrProfData.inc"
end_include

begin_expr_stmt
name|void
name|InstrProfValueSiteRecord
operator|::
name|sortByCount
argument_list|()
block|{
name|ValueData
operator|.
name|sort
argument_list|(
index|[]
operator|(
specifier|const
name|InstrProfValueData
operator|&
name|left
operator|,
specifier|const
name|InstrProfValueData
operator|&
name|right
operator|)
block|{
return|return
name|left
operator|.
name|Count
operator|>
name|right
operator|.
name|Count
return|;
block|}
end_expr_stmt

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_comment
comment|// Now truncate
end_comment

begin_decl_stmt
name|size_t
name|max_s
init|=
name|INSTR_PROF_MAX_NUM_VAL_PER_SITE
decl_stmt|;
end_decl_stmt

begin_if
if|if
condition|(
name|ValueData
operator|.
name|size
argument_list|()
operator|>
name|max_s
condition|)
name|ValueData
operator|.
name|resize
argument_list|(
name|max_s
argument_list|)
expr_stmt|;
end_if

begin_macro
unit|}  namespace
name|IndexedInstrProf
end_macro

begin_block
block|{
name|enum
name|class
name|HashT
range|:
name|uint32_t
block|{
name|MD5
block|,
name|Last
operator|=
name|MD5
block|}
decl_stmt|;
specifier|inline
name|uint64_t
name|ComputeHash
parameter_list|(
name|HashT
name|Type
parameter_list|,
name|StringRef
name|K
parameter_list|)
block|{
switch|switch
condition|(
name|Type
condition|)
block|{
case|case
name|HashT
operator|::
name|MD5
case|:
return|return
name|MD5Hash
argument_list|(
name|K
argument_list|)
return|;
block|}
name|llvm_unreachable
argument_list|(
literal|"Unhandled hash type"
argument_list|)
expr_stmt|;
block|}
specifier|const
name|uint64_t
name|Magic
init|=
literal|0x8169666f72706cff
decl_stmt|;
comment|// "\xfflprofi\x81"
enum|enum
name|ProfVersion
block|{
comment|// Version 1 is the first version. In this version, the value of
comment|// a key/value pair can only include profile data of a single function.
comment|// Due to this restriction, the number of block counters for a given
comment|// function is not recorded but derived from the length of the value.
name|Version1
init|=
literal|1
block|,
comment|// The version 2 format supports recording profile data of multiple
comment|// functions which share the same key in one value field. To support this,
comment|// the number block counters is recorded as an uint64_t field right after the
comment|// function structural hash.
name|Version2
init|=
literal|2
block|,
comment|// Version 3 supports value profile data. The value profile data is expected
comment|// to follow the block counter profile data.
name|Version3
init|=
literal|3
block|,
comment|// In this version, profile summary data \c IndexedInstrProf::Summary is
comment|// stored after the profile header.
name|Version4
init|=
literal|4
block|,
comment|// The current version is 4.
name|CurrentVersion
init|=
name|INSTR_PROF_INDEX_VERSION
block|}
enum|;
specifier|const
name|uint64_t
name|Version
init|=
name|ProfVersion
operator|::
name|CurrentVersion
decl_stmt|;
specifier|const
name|HashT
name|HashType
init|=
name|HashT
operator|::
name|MD5
decl_stmt|;
specifier|inline
name|uint64_t
name|ComputeHash
parameter_list|(
name|StringRef
name|K
parameter_list|)
block|{
return|return
name|ComputeHash
argument_list|(
name|HashType
argument_list|,
name|K
argument_list|)
return|;
block|}
comment|// This structure defines the file header of the LLVM profile
comment|// data file in indexed-format.
struct|struct
name|Header
block|{
name|uint64_t
name|Magic
decl_stmt|;
name|uint64_t
name|Version
decl_stmt|;
name|uint64_t
name|Unused
decl_stmt|;
comment|// Becomes unused since version 4
name|uint64_t
name|HashType
decl_stmt|;
name|uint64_t
name|HashOffset
decl_stmt|;
block|}
struct|;
comment|// Profile summary data recorded in the profile data file in indexed
comment|// format. It is introduced in version 4. The summary data follows
comment|// right after the profile file header.
struct|struct
name|Summary
block|{
struct|struct
name|Entry
block|{
name|uint64_t
name|Cutoff
decl_stmt|;
comment|///< The required percentile of total execution count.
name|uint64_t
name|MinBlockCount
decl_stmt|;
comment|///< The minimum execution count for this percentile.
name|uint64_t
name|NumBlocks
decl_stmt|;
comment|///< Number of blocks>= the minumum execution count.
block|}
struct|;
comment|// The field kind enumerator to assigned value mapping should remain
comment|// unchanged  when a new kind is added or an old kind gets deleted in
comment|// the future.
enum|enum
name|SummaryFieldKind
block|{
comment|/// The total number of functions instrumented.
name|TotalNumFunctions
init|=
literal|0
block|,
comment|/// Total number of instrumented blocks/edges.
name|TotalNumBlocks
init|=
literal|1
block|,
comment|/// The maximal execution count among all functions.
comment|/// This field does not exist for profile data from IR based
comment|/// instrumentation.
name|MaxFunctionCount
init|=
literal|2
block|,
comment|/// Max block count of the program.
name|MaxBlockCount
init|=
literal|3
block|,
comment|/// Max internal block count of the program (excluding entry blocks).
name|MaxInternalBlockCount
init|=
literal|4
block|,
comment|/// The sum of all instrumented block counts.
name|TotalBlockCount
init|=
literal|5
block|,
name|NumKinds
init|=
name|TotalBlockCount
operator|+
literal|1
block|}
enum|;
comment|// The number of summmary fields following the summary header.
name|uint64_t
name|NumSummaryFields
decl_stmt|;
comment|// The number of Cutoff Entries (Summary::Entry) following summary fields.
name|uint64_t
name|NumCutoffEntries
decl_stmt|;
specifier|static
name|uint32_t
name|getSize
parameter_list|(
name|uint32_t
name|NumSumFields
parameter_list|,
name|uint32_t
name|NumCutoffEntries
parameter_list|)
block|{
return|return
sizeof|sizeof
argument_list|(
name|Summary
argument_list|)
operator|+
name|NumCutoffEntries
operator|*
sizeof|sizeof
argument_list|(
name|Entry
argument_list|)
operator|+
name|NumSumFields
operator|*
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
return|;
block|}
specifier|const
name|uint64_t
operator|*
name|getSummaryDataBase
argument_list|()
specifier|const
block|{
return|return
name|reinterpret_cast
operator|<
specifier|const
name|uint64_t
operator|*
operator|>
operator|(
name|this
operator|+
literal|1
operator|)
return|;
block|}
name|uint64_t
modifier|*
name|getSummaryDataBase
parameter_list|()
block|{
return|return
name|reinterpret_cast
operator|<
name|uint64_t
operator|*
operator|>
operator|(
name|this
operator|+
literal|1
operator|)
return|;
block|}
specifier|const
name|Entry
operator|*
name|getCutoffEntryBase
argument_list|()
specifier|const
block|{
return|return
name|reinterpret_cast
operator|<
specifier|const
name|Entry
operator|*
operator|>
operator|(
operator|&
name|getSummaryDataBase
argument_list|()
index|[
name|NumSummaryFields
index|]
operator|)
return|;
block|}
name|Entry
modifier|*
name|getCutoffEntryBase
parameter_list|()
block|{
return|return
name|reinterpret_cast
operator|<
name|Entry
operator|*
operator|>
operator|(
operator|&
name|getSummaryDataBase
argument_list|()
index|[
name|NumSummaryFields
index|]
operator|)
return|;
block|}
name|uint64_t
name|get
argument_list|(
name|SummaryFieldKind
name|K
argument_list|)
decl|const
block|{
return|return
name|getSummaryDataBase
argument_list|()
index|[
name|K
index|]
return|;
block|}
name|void
name|set
parameter_list|(
name|SummaryFieldKind
name|K
parameter_list|,
name|uint64_t
name|V
parameter_list|)
block|{
name|getSummaryDataBase
argument_list|()
index|[
name|K
index|]
operator|=
name|V
expr_stmt|;
block|}
specifier|const
name|Entry
modifier|&
name|getEntry
argument_list|(
name|uint32_t
name|I
argument_list|)
decl|const
block|{
return|return
name|getCutoffEntryBase
argument_list|()
index|[
name|I
index|]
return|;
block|}
name|void
name|setEntry
parameter_list|(
name|uint32_t
name|I
parameter_list|,
specifier|const
name|ProfileSummaryEntry
modifier|&
name|E
parameter_list|)
block|{
name|Entry
modifier|&
name|ER
init|=
name|getCutoffEntryBase
argument_list|()
index|[
name|I
index|]
decl_stmt|;
name|ER
operator|.
name|Cutoff
operator|=
name|E
operator|.
name|Cutoff
expr_stmt|;
name|ER
operator|.
name|MinBlockCount
operator|=
name|E
operator|.
name|MinCount
expr_stmt|;
name|ER
operator|.
name|NumBlocks
operator|=
name|E
operator|.
name|NumCounts
expr_stmt|;
block|}
name|Summary
argument_list|(
argument|uint32_t Size
argument_list|)
block|{
name|memset
argument_list|(
name|this
argument_list|,
literal|0
argument_list|,
name|Size
argument_list|)
expr_stmt|;
block|}
name|void
name|operator
name|delete
parameter_list|(
name|void
modifier|*
name|ptr
parameter_list|)
block|{
operator|::
name|operator
name|delete
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
block|}
name|Summary
argument_list|()
operator|=
name|delete
expr_stmt|;
block|}
struct|;
specifier|inline
name|std
operator|::
name|unique_ptr
operator|<
name|Summary
operator|>
name|allocSummary
argument_list|(
argument|uint32_t TotalSize
argument_list|)
block|{
return|return
name|std
operator|::
name|unique_ptr
operator|<
name|Summary
operator|>
operator|(
name|new
argument_list|(
argument|::operator new(TotalSize)
argument_list|)
name|Summary
argument_list|(
name|TotalSize
argument_list|)
operator|)
return|;
block|}
block|}
end_block

begin_comment
comment|// end namespace IndexedInstrProf
end_comment

begin_decl_stmt
name|namespace
name|RawInstrProf
block|{
comment|// Version 1: First version
comment|// Version 2: Added value profile data section. Per-function control data
comment|// struct has more fields to describe value profile information.
comment|// Version 3: Compressed name section support. Function PGO name reference
comment|// from control data struct is changed from raw pointer to Name's MD5 value.
comment|// Version 4: ValueDataBegin and ValueDataSizes fields are removed from the
comment|// raw header.
specifier|const
name|uint64_t
name|Version
init|=
name|INSTR_PROF_RAW_VERSION
decl_stmt|;
name|template
operator|<
name|class
name|IntPtrT
operator|>
specifier|inline
name|uint64_t
name|getMagic
argument_list|()
expr_stmt|;
name|template
operator|<
operator|>
specifier|inline
name|uint64_t
name|getMagic
operator|<
name|uint64_t
operator|>
operator|(
operator|)
block|{
return|return
name|INSTR_PROF_RAW_MAGIC_64
return|;
block|}
name|template
operator|<
operator|>
specifier|inline
name|uint64_t
name|getMagic
operator|<
name|uint32_t
operator|>
operator|(
operator|)
block|{
return|return
name|INSTR_PROF_RAW_MAGIC_32
return|;
block|}
comment|// Per-function profile data header/control structure.
comment|// The definition should match the structure defined in
comment|// compiler-rt/lib/profile/InstrProfiling.h.
comment|// It should also match the synthesized type in
comment|// Transforms/Instrumentation/InstrProfiling.cpp:getOrCreateRegionCounters.
name|template
operator|<
name|class
name|IntPtrT
operator|>
expr|struct
name|LLVM_ALIGNAS
argument_list|(
literal|8
argument_list|)
name|ProfileData
block|{
define|#
directive|define
name|INSTR_PROF_DATA
parameter_list|(
name|Type
parameter_list|,
name|LLVMType
parameter_list|,
name|Name
parameter_list|,
name|Init
parameter_list|)
value|Type Name;
include|#
directive|include
file|"llvm/ProfileData/InstrProfData.inc"
block|}
expr_stmt|;
comment|// File header structure of the LLVM profile data in raw format.
comment|// The definition should match the header referenced in
comment|// compiler-rt/lib/profile/InstrProfilingFile.c  and
comment|// InstrProfilingBuffer.c.
struct|struct
name|Header
block|{
define|#
directive|define
name|INSTR_PROF_RAW_HEADER
parameter_list|(
name|Type
parameter_list|,
name|Name
parameter_list|,
name|Init
parameter_list|)
value|const Type Name;
include|#
directive|include
file|"llvm/ProfileData/InstrProfData.inc"
block|}
struct|;
block|}
end_decl_stmt

begin_comment
comment|// end namespace RawInstrProf
end_comment

begin_comment
comment|// Parse MemOP Size range option.
end_comment

begin_decl_stmt
name|void
name|getMemOPSizeRangeFromOption
argument_list|(
name|std
operator|::
name|string
name|Str
argument_list|,
name|int64_t
operator|&
name|RangeStart
argument_list|,
name|int64_t
operator|&
name|RangeLast
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
unit|}
comment|// end namespace llvm
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|// LLVM_PROFILEDATA_INSTRPROF_H
end_comment

end_unit

