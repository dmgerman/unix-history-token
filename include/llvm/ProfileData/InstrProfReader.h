begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//=-- InstrProfReader.h - Instrumented profiling readers ----------*- C++ -*-=//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file contains support for reading profiling data for instrumentation
end_comment

begin_comment
comment|// based PGO and coverage.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LLVM_PROFILEDATA_INSTRPROFREADER_H
end_ifndef

begin_define
define|#
directive|define
name|LLVM_PROFILEDATA_INSTRPROFREADER_H
end_define

begin_include
include|#
directive|include
file|"llvm/ADT/ArrayRef.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/StringExtras.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ProfileData/InstrProf.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/EndianStream.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/ErrorOr.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/LineIterator.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/MemoryBuffer.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/OnDiskHashTable.h"
end_include

begin_include
include|#
directive|include
file|<iterator>
end_include

begin_decl_stmt
name|namespace
name|llvm
block|{
name|class
name|InstrProfReader
decl_stmt|;
comment|/// Profiling information for a single function.
struct|struct
name|InstrProfRecord
block|{
name|InstrProfRecord
argument_list|()
block|{}
name|InstrProfRecord
argument_list|(
argument|StringRef Name
argument_list|,
argument|uint64_t Hash
argument_list|,
argument|ArrayRef<uint64_t> Counts
argument_list|)
block|:
name|Name
argument_list|(
name|Name
argument_list|)
operator|,
name|Hash
argument_list|(
name|Hash
argument_list|)
operator|,
name|Counts
argument_list|(
argument|Counts
argument_list|)
block|{}
name|StringRef
name|Name
expr_stmt|;
name|uint64_t
name|Hash
decl_stmt|;
name|ArrayRef
operator|<
name|uint64_t
operator|>
name|Counts
expr_stmt|;
block|}
struct|;
comment|/// A file format agnostic iterator over profiling data.
name|class
name|InstrProfIterator
range|:
name|public
name|std
operator|::
name|iterator
operator|<
name|std
operator|::
name|input_iterator_tag
decl_stmt|,
name|InstrProfRecord
decl|>
block|{
name|InstrProfReader
modifier|*
name|Reader
decl_stmt|;
name|InstrProfRecord
name|Record
decl_stmt|;
name|void
name|Increment
parameter_list|()
function_decl|;
name|public
label|:
name|InstrProfIterator
argument_list|()
operator|:
name|Reader
argument_list|(
argument|nullptr
argument_list|)
block|{}
name|InstrProfIterator
argument_list|(
name|InstrProfReader
operator|*
name|Reader
argument_list|)
operator|:
name|Reader
argument_list|(
argument|Reader
argument_list|)
block|{
name|Increment
argument_list|()
block|; }
name|InstrProfIterator
operator|&
name|operator
operator|++
operator|(
operator|)
block|{
name|Increment
argument_list|()
block|;
return|return
operator|*
name|this
return|;
block|}
name|bool
name|operator
operator|==
operator|(
specifier|const
name|InstrProfIterator
operator|&
name|RHS
operator|)
block|{
return|return
name|Reader
operator|==
name|RHS
operator|.
name|Reader
return|;
block|}
name|bool
name|operator
operator|!=
operator|(
specifier|const
name|InstrProfIterator
operator|&
name|RHS
operator|)
block|{
return|return
name|Reader
operator|!=
name|RHS
operator|.
name|Reader
return|;
block|}
name|InstrProfRecord
modifier|&
name|operator
modifier|*
parameter_list|()
block|{
return|return
name|Record
return|;
block|}
name|InstrProfRecord
operator|*
name|operator
operator|->
expr|(
block|)
block|{
return|return
operator|&
name|Record
return|;
block|}
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_comment
comment|/// Base class and interface for reading profiling data of any known instrprof
end_comment

begin_comment
comment|/// format. Provides an iterator over InstrProfRecords.
end_comment

begin_decl_stmt
name|class
name|InstrProfReader
block|{
name|std
operator|::
name|error_code
name|LastError
expr_stmt|;
name|public
label|:
name|InstrProfReader
argument_list|()
operator|:
name|LastError
argument_list|(
argument|instrprof_error::success
argument_list|)
block|{}
name|virtual
operator|~
name|InstrProfReader
argument_list|()
block|{}
comment|/// Read the header.  Required before reading first record.
name|virtual
name|std
operator|::
name|error_code
name|readHeader
argument_list|()
operator|=
literal|0
expr_stmt|;
comment|/// Read a single record.
name|virtual
name|std
operator|::
name|error_code
name|readNextRecord
argument_list|(
name|InstrProfRecord
operator|&
name|Record
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/// Iterator over profile data.
name|InstrProfIterator
name|begin
parameter_list|()
block|{
return|return
name|InstrProfIterator
argument_list|(
name|this
argument_list|)
return|;
block|}
name|InstrProfIterator
name|end
parameter_list|()
block|{
return|return
name|InstrProfIterator
argument_list|()
return|;
block|}
name|protected
label|:
comment|/// Set the current std::error_code and return same.
name|std
operator|::
name|error_code
name|error
argument_list|(
argument|std::error_code EC
argument_list|)
block|{
name|LastError
operator|=
name|EC
block|;
return|return
name|EC
return|;
block|}
comment|/// Clear the current error code and return a successful one.
name|std
operator|::
name|error_code
name|success
argument_list|()
block|{
return|return
name|error
argument_list|(
name|instrprof_error
operator|::
name|success
argument_list|)
return|;
block|}
name|public
label|:
comment|/// Return true if the reader has finished reading the profile data.
name|bool
name|isEOF
parameter_list|()
block|{
return|return
name|LastError
operator|==
name|instrprof_error
operator|::
name|eof
return|;
block|}
comment|/// Return true if the reader encountered an error reading profiling data.
name|bool
name|hasError
parameter_list|()
block|{
return|return
name|LastError
operator|&&
operator|!
name|isEOF
argument_list|()
return|;
block|}
comment|/// Get the current error code.
name|std
operator|::
name|error_code
name|getError
argument_list|()
block|{
return|return
name|LastError
return|;
block|}
comment|/// Factory method to create an appropriately typed reader for the given
comment|/// instrprof file.
specifier|static
name|ErrorOr
operator|<
name|std
operator|::
name|unique_ptr
operator|<
name|InstrProfReader
operator|>>
name|create
argument_list|(
argument|std::string Path
argument_list|)
expr_stmt|;
specifier|static
name|ErrorOr
operator|<
name|std
operator|::
name|unique_ptr
operator|<
name|InstrProfReader
operator|>>
name|create
argument_list|(
name|std
operator|::
name|unique_ptr
operator|<
name|MemoryBuffer
operator|>
name|Buffer
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_comment
comment|/// Reader for the simple text based instrprof format.
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|/// This format is a simple text format that's suitable for test data. Records
end_comment

begin_comment
comment|/// are separated by one or more blank lines, and record fields are separated by
end_comment

begin_comment
comment|/// new lines.
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|/// Each record consists of a function name, a function hash, a number of
end_comment

begin_comment
comment|/// counters, and then each counter value, in that order.
end_comment

begin_decl_stmt
name|class
name|TextInstrProfReader
range|:
name|public
name|InstrProfReader
block|{
name|private
operator|:
comment|/// The profile data file contents.
name|std
operator|::
name|unique_ptr
operator|<
name|MemoryBuffer
operator|>
name|DataBuffer
block|;
comment|/// Iterator over the profile data.
name|line_iterator
name|Line
block|;
comment|/// The current set of counter values.
name|std
operator|::
name|vector
operator|<
name|uint64_t
operator|>
name|Counts
block|;
name|TextInstrProfReader
argument_list|(
specifier|const
name|TextInstrProfReader
operator|&
argument_list|)
operator|=
name|delete
block|;
name|TextInstrProfReader
operator|&
name|operator
operator|=
operator|(
specifier|const
name|TextInstrProfReader
operator|&
operator|)
operator|=
name|delete
block|;
name|public
operator|:
name|TextInstrProfReader
argument_list|(
name|std
operator|::
name|unique_ptr
operator|<
name|MemoryBuffer
operator|>
name|DataBuffer_
argument_list|)
operator|:
name|DataBuffer
argument_list|(
name|std
operator|::
name|move
argument_list|(
name|DataBuffer_
argument_list|)
argument_list|)
block|,
name|Line
argument_list|(
argument|*DataBuffer
argument_list|,
argument|true
argument_list|,
literal|'#'
argument_list|)
block|{}
comment|/// Read the header.
name|std
operator|::
name|error_code
name|readHeader
argument_list|()
name|override
block|{
return|return
name|success
argument_list|()
return|;
block|}
comment|/// Read a single record.
name|std
operator|::
name|error_code
name|readNextRecord
argument_list|(
argument|InstrProfRecord&Record
argument_list|)
name|override
block|; }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/// Reader for the raw instrprof binary format from runtime.
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|/// This format is a raw memory dump of the instrumentation-baed profiling data
end_comment

begin_comment
comment|/// from the runtime.  It has no index.
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|/// Templated on the unsigned type whose size matches pointers on the platform
end_comment

begin_comment
comment|/// that wrote the profile.
end_comment

begin_expr_stmt
name|template
operator|<
name|class
name|IntPtrT
operator|>
name|class
name|RawInstrProfReader
operator|:
name|public
name|InstrProfReader
block|{
name|private
operator|:
comment|/// The profile data file contents.
name|std
operator|::
name|unique_ptr
operator|<
name|MemoryBuffer
operator|>
name|DataBuffer
block|;
comment|/// The current set of counter values.
name|std
operator|::
name|vector
operator|<
name|uint64_t
operator|>
name|Counts
block|;   struct
name|ProfileData
block|{
specifier|const
name|uint32_t
name|NameSize
block|;
specifier|const
name|uint32_t
name|NumCounters
block|;
specifier|const
name|uint64_t
name|FuncHash
block|;
specifier|const
name|IntPtrT
name|NamePtr
block|;
specifier|const
name|IntPtrT
name|CounterPtr
block|;   }
block|;   struct
name|RawHeader
block|{
specifier|const
name|uint64_t
name|Magic
block|;
specifier|const
name|uint64_t
name|Version
block|;
specifier|const
name|uint64_t
name|DataSize
block|;
specifier|const
name|uint64_t
name|CountersSize
block|;
specifier|const
name|uint64_t
name|NamesSize
block|;
specifier|const
name|uint64_t
name|CountersDelta
block|;
specifier|const
name|uint64_t
name|NamesDelta
block|;   }
block|;
name|bool
name|ShouldSwapBytes
block|;
name|uint64_t
name|CountersDelta
block|;
name|uint64_t
name|NamesDelta
block|;
specifier|const
name|ProfileData
operator|*
name|Data
block|;
specifier|const
name|ProfileData
operator|*
name|DataEnd
block|;
specifier|const
name|uint64_t
operator|*
name|CountersStart
block|;
specifier|const
name|char
operator|*
name|NamesStart
block|;
specifier|const
name|char
operator|*
name|ProfileEnd
block|;
name|RawInstrProfReader
argument_list|(
specifier|const
name|RawInstrProfReader
operator|&
argument_list|)
operator|=
name|delete
block|;
name|RawInstrProfReader
operator|&
name|operator
operator|=
operator|(
specifier|const
name|RawInstrProfReader
operator|&
operator|)
operator|=
name|delete
block|;
name|public
operator|:
name|RawInstrProfReader
argument_list|(
name|std
operator|::
name|unique_ptr
operator|<
name|MemoryBuffer
operator|>
name|DataBuffer
argument_list|)
operator|:
name|DataBuffer
argument_list|(
argument|std::move(DataBuffer)
argument_list|)
block|{ }
specifier|static
name|bool
name|hasFormat
argument_list|(
specifier|const
name|MemoryBuffer
operator|&
name|DataBuffer
argument_list|)
block|;
name|std
operator|::
name|error_code
name|readHeader
argument_list|()
name|override
block|;
name|std
operator|::
name|error_code
name|readNextRecord
argument_list|(
argument|InstrProfRecord&Record
argument_list|)
name|override
block|;
name|private
operator|:
name|std
operator|::
name|error_code
name|readNextHeader
argument_list|(
specifier|const
name|char
operator|*
name|CurrentPos
argument_list|)
block|;
name|std
operator|::
name|error_code
name|readHeader
argument_list|(
specifier|const
name|RawHeader
operator|&
name|Header
argument_list|)
block|;
name|template
operator|<
name|class
name|IntT
operator|>
name|IntT
name|swap
argument_list|(
argument|IntT Int
argument_list|)
specifier|const
block|{
return|return
name|ShouldSwapBytes
operator|?
name|sys
operator|::
name|getSwappedBytes
argument_list|(
name|Int
argument_list|)
operator|:
name|Int
return|;
block|}
specifier|const
name|uint64_t
operator|*
name|getCounter
argument_list|(
argument|IntPtrT CounterPtr
argument_list|)
specifier|const
block|{
name|ptrdiff_t
name|Offset
operator|=
operator|(
name|swap
argument_list|(
name|CounterPtr
argument_list|)
operator|-
name|CountersDelta
operator|)
operator|/
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
block|;
return|return
name|CountersStart
operator|+
name|Offset
return|;
block|}
end_expr_stmt

begin_decl_stmt
specifier|const
name|char
modifier|*
name|getName
argument_list|(
name|IntPtrT
name|NamePtr
argument_list|)
decl|const
block|{
name|ptrdiff_t
name|Offset
init|=
operator|(
name|swap
argument_list|(
name|NamePtr
argument_list|)
operator|-
name|NamesDelta
operator|)
operator|/
sizeof|sizeof
argument_list|(
name|char
argument_list|)
decl_stmt|;
return|return
name|NamesStart
operator|+
name|Offset
return|;
block|}
end_decl_stmt

begin_typedef
unit|};
typedef|typedef
name|RawInstrProfReader
operator|<
name|uint32_t
operator|>
name|RawInstrProfReader32
expr_stmt|;
end_typedef

begin_typedef
typedef|typedef
name|RawInstrProfReader
operator|<
name|uint64_t
operator|>
name|RawInstrProfReader64
expr_stmt|;
end_typedef

begin_decl_stmt
name|namespace
name|IndexedInstrProf
block|{
name|enum
name|class
name|HashT
range|:
name|uint32_t
decl_stmt|;
block|}
end_decl_stmt

begin_comment
comment|/// Trait for lookups into the on-disk hash table for the binary instrprof
end_comment

begin_comment
comment|/// format.
end_comment

begin_decl_stmt
name|class
name|InstrProfLookupTrait
block|{
name|std
operator|::
name|vector
operator|<
name|uint64_t
operator|>
name|DataBuffer
expr_stmt|;
name|IndexedInstrProf
operator|::
name|HashT
name|HashType
expr_stmt|;
name|public
label|:
name|InstrProfLookupTrait
argument_list|(
argument|IndexedInstrProf::HashT HashType
argument_list|)
block|:
name|HashType
argument_list|(
argument|HashType
argument_list|)
block|{}
struct|struct
name|data_type
block|{
name|data_type
argument_list|(
argument|StringRef Name
argument_list|,
argument|ArrayRef<uint64_t> Data
argument_list|)
block|:
name|Name
argument_list|(
name|Name
argument_list|)
operator|,
name|Data
argument_list|(
argument|Data
argument_list|)
block|{}
name|StringRef
name|Name
expr_stmt|;
name|ArrayRef
operator|<
name|uint64_t
operator|>
name|Data
expr_stmt|;
block|}
struct|;
typedef|typedef
name|StringRef
name|internal_key_type
typedef|;
typedef|typedef
name|StringRef
name|external_key_type
typedef|;
typedef|typedef
name|uint64_t
name|hash_value_type
typedef|;
typedef|typedef
name|uint64_t
name|offset_type
typedef|;
specifier|static
name|bool
name|EqualKey
parameter_list|(
name|StringRef
name|A
parameter_list|,
name|StringRef
name|B
parameter_list|)
block|{
return|return
name|A
operator|==
name|B
return|;
block|}
specifier|static
name|StringRef
name|GetInternalKey
parameter_list|(
name|StringRef
name|K
parameter_list|)
block|{
return|return
name|K
return|;
block|}
name|hash_value_type
name|ComputeHash
parameter_list|(
name|StringRef
name|K
parameter_list|)
function_decl|;
specifier|static
name|std
operator|::
name|pair
operator|<
name|offset_type
operator|,
name|offset_type
operator|>
name|ReadKeyDataLength
argument_list|(
argument|const unsigned char *&D
argument_list|)
block|{
name|using
name|namespace
name|support
block|;
name|offset_type
name|KeyLen
operator|=
name|endian
operator|::
name|readNext
operator|<
name|offset_type
block|,
name|little
block|,
name|unaligned
operator|>
operator|(
name|D
operator|)
block|;
name|offset_type
name|DataLen
operator|=
name|endian
operator|::
name|readNext
operator|<
name|offset_type
block|,
name|little
block|,
name|unaligned
operator|>
operator|(
name|D
operator|)
block|;
return|return
name|std
operator|::
name|make_pair
argument_list|(
name|KeyLen
argument_list|,
name|DataLen
argument_list|)
return|;
block|}
name|StringRef
name|ReadKey
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|D
parameter_list|,
name|offset_type
name|N
parameter_list|)
block|{
return|return
name|StringRef
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
name|D
argument_list|,
name|N
argument_list|)
return|;
block|}
name|data_type
name|ReadData
parameter_list|(
name|StringRef
name|K
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|D
parameter_list|,
name|offset_type
name|N
parameter_list|)
block|{
name|DataBuffer
operator|.
name|clear
argument_list|()
expr_stmt|;
if|if
condition|(
name|N
operator|%
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
condition|)
comment|// The data is corrupt, don't try to read it.
return|return
name|data_type
argument_list|(
literal|""
argument_list|,
name|DataBuffer
argument_list|)
return|;
name|using
name|namespace
name|support
decl_stmt|;
comment|// We just treat the data as opaque here. It's simpler to handle in
comment|// IndexedInstrProfReader.
name|unsigned
name|NumEntries
init|=
name|N
operator|/
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
decl_stmt|;
name|DataBuffer
operator|.
name|reserve
argument_list|(
name|NumEntries
argument_list|)
expr_stmt|;
for|for
control|(
name|unsigned
name|I
init|=
literal|0
init|;
name|I
operator|<
name|NumEntries
condition|;
operator|++
name|I
control|)
name|DataBuffer
operator|.
name|push_back
argument_list|(
name|endian
operator|::
name|readNext
operator|<
name|uint64_t
argument_list|,
name|little
argument_list|,
name|unaligned
operator|>
operator|(
name|D
operator|)
argument_list|)
expr_stmt|;
return|return
name|data_type
argument_list|(
name|K
argument_list|,
name|DataBuffer
argument_list|)
return|;
block|}
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_typedef
typedef|typedef
name|OnDiskIterableChainedHashTable
operator|<
name|InstrProfLookupTrait
operator|>
name|InstrProfReaderIndex
expr_stmt|;
end_typedef

begin_comment
comment|/// Reader for the indexed binary instrprof format.
end_comment

begin_decl_stmt
name|class
name|IndexedInstrProfReader
range|:
name|public
name|InstrProfReader
block|{
name|private
operator|:
comment|/// The profile data file contents.
name|std
operator|::
name|unique_ptr
operator|<
name|MemoryBuffer
operator|>
name|DataBuffer
block|;
comment|/// The index into the profile data.
name|std
operator|::
name|unique_ptr
operator|<
name|InstrProfReaderIndex
operator|>
name|Index
block|;
comment|/// Iterator over the profile data.
name|InstrProfReaderIndex
operator|::
name|data_iterator
name|RecordIterator
block|;
comment|/// Offset into our current data set.
name|size_t
name|CurrentOffset
block|;
comment|/// The file format version of the profile data.
name|uint64_t
name|FormatVersion
block|;
comment|/// The maximal execution count among all functions.
name|uint64_t
name|MaxFunctionCount
block|;
name|IndexedInstrProfReader
argument_list|(
specifier|const
name|IndexedInstrProfReader
operator|&
argument_list|)
operator|=
name|delete
block|;
name|IndexedInstrProfReader
operator|&
name|operator
operator|=
operator|(
specifier|const
name|IndexedInstrProfReader
operator|&
operator|)
operator|=
name|delete
block|;
name|public
operator|:
name|IndexedInstrProfReader
argument_list|(
name|std
operator|::
name|unique_ptr
operator|<
name|MemoryBuffer
operator|>
name|DataBuffer
argument_list|)
operator|:
name|DataBuffer
argument_list|(
name|std
operator|::
name|move
argument_list|(
name|DataBuffer
argument_list|)
argument_list|)
block|,
name|Index
argument_list|(
name|nullptr
argument_list|)
block|,
name|CurrentOffset
argument_list|(
literal|0
argument_list|)
block|{}
comment|/// Return true if the given buffer is in an indexed instrprof format.
specifier|static
name|bool
name|hasFormat
argument_list|(
specifier|const
name|MemoryBuffer
operator|&
name|DataBuffer
argument_list|)
block|;
comment|/// Read the file header.
name|std
operator|::
name|error_code
name|readHeader
argument_list|()
name|override
block|;
comment|/// Read a single record.
name|std
operator|::
name|error_code
name|readNextRecord
argument_list|(
argument|InstrProfRecord&Record
argument_list|)
name|override
block|;
comment|/// Fill Counts with the profile data for the given function name.
name|std
operator|::
name|error_code
name|getFunctionCounts
argument_list|(
argument|StringRef FuncName
argument_list|,
argument|uint64_t FuncHash
argument_list|,
argument|std::vector<uint64_t>&Counts
argument_list|)
block|;
comment|/// Return the maximum of all known function counts.
name|uint64_t
name|getMaximumFunctionCount
argument_list|()
block|{
return|return
name|MaxFunctionCount
return|;
block|}
comment|/// Factory method to create an indexed reader.
specifier|static
name|ErrorOr
operator|<
name|std
operator|::
name|unique_ptr
operator|<
name|IndexedInstrProfReader
operator|>>
name|create
argument_list|(
argument|std::string Path
argument_list|)
block|;
specifier|static
name|ErrorOr
operator|<
name|std
operator|::
name|unique_ptr
operator|<
name|IndexedInstrProfReader
operator|>>
name|create
argument_list|(
name|std
operator|::
name|unique_ptr
operator|<
name|MemoryBuffer
operator|>
name|Buffer
argument_list|)
block|; }
decl_stmt|;
end_decl_stmt

begin_comment
unit|}
comment|// end namespace llvm
end_comment

begin_endif
endif|#
directive|endif
end_endif

end_unit

