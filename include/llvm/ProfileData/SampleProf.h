begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===- SampleProf.h - Sampling profiling format support ---------*- C++ -*-===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file contains common definitions used in the reading and writing of
end_comment

begin_comment
comment|// sample profile data.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LLVM_PROFILEDATA_SAMPLEPROF_H
end_ifndef

begin_define
define|#
directive|define
name|LLVM_PROFILEDATA_SAMPLEPROF_H
end_define

begin_include
include|#
directive|include
file|"llvm/ADT/DenseSet.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/SmallVector.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/StringMap.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/StringRef.h"
end_include

begin_include
include|#
directive|include
file|"llvm/IR/Function.h"
end_include

begin_include
include|#
directive|include
file|"llvm/IR/GlobalValue.h"
end_include

begin_include
include|#
directive|include
file|"llvm/IR/Module.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/Debug.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/ErrorOr.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/MathExtras.h"
end_include

begin_include
include|#
directive|include
file|<algorithm>
end_include

begin_include
include|#
directive|include
file|<cstdint>
end_include

begin_include
include|#
directive|include
file|<map>
end_include

begin_include
include|#
directive|include
file|<string>
end_include

begin_include
include|#
directive|include
file|<system_error>
end_include

begin_include
include|#
directive|include
file|<utility>
end_include

begin_decl_stmt
name|namespace
name|llvm
block|{
name|class
name|raw_ostream
decl_stmt|;
specifier|const
name|std
operator|::
name|error_category
operator|&
name|sampleprof_category
argument_list|()
expr_stmt|;
name|enum
name|class
name|sampleprof_error
block|{
name|success
operator|=
literal|0
operator|,
name|bad_magic
operator|,
name|unsupported_version
operator|,
name|too_large
operator|,
name|truncated
operator|,
name|malformed
operator|,
name|unrecognized_format
operator|,
name|unsupported_writing_format
operator|,
name|truncated_name_table
operator|,
name|not_implemented
operator|,
name|counter_overflow
block|}
empty_stmt|;
specifier|inline
name|std
operator|::
name|error_code
name|make_error_code
argument_list|(
argument|sampleprof_error E
argument_list|)
block|{
return|return
name|std
operator|::
name|error_code
argument_list|(
name|static_cast
operator|<
name|int
operator|>
operator|(
name|E
operator|)
argument_list|,
name|sampleprof_category
argument_list|()
argument_list|)
return|;
block|}
specifier|inline
name|sampleprof_error
name|MergeResult
parameter_list|(
name|sampleprof_error
modifier|&
name|Accumulator
parameter_list|,
name|sampleprof_error
name|Result
parameter_list|)
block|{
comment|// Prefer first error encountered as later errors may be secondary effects of
comment|// the initial problem.
if|if
condition|(
name|Accumulator
operator|==
name|sampleprof_error
operator|::
name|success
operator|&&
name|Result
operator|!=
name|sampleprof_error
operator|::
name|success
condition|)
name|Accumulator
operator|=
name|Result
expr_stmt|;
return|return
name|Accumulator
return|;
block|}
block|}
end_decl_stmt

begin_comment
comment|// end namespace llvm
end_comment

begin_decl_stmt
name|namespace
name|std
block|{
name|template
operator|<
operator|>
expr|struct
name|is_error_code_enum
operator|<
name|llvm
operator|::
name|sampleprof_error
operator|>
operator|:
name|std
operator|::
name|true_type
block|{}
expr_stmt|;
block|}
end_decl_stmt

begin_comment
comment|// end namespace std
end_comment

begin_decl_stmt
name|namespace
name|llvm
block|{
name|namespace
name|sampleprof
block|{
specifier|static
specifier|inline
name|uint64_t
name|SPMagic
parameter_list|()
block|{
return|return
name|uint64_t
argument_list|(
literal|'S'
argument_list|)
operator|<<
operator|(
literal|64
operator|-
literal|8
operator|)
operator||
name|uint64_t
argument_list|(
literal|'P'
argument_list|)
operator|<<
operator|(
literal|64
operator|-
literal|16
operator|)
operator||
name|uint64_t
argument_list|(
literal|'R'
argument_list|)
operator|<<
operator|(
literal|64
operator|-
literal|24
operator|)
operator||
name|uint64_t
argument_list|(
literal|'O'
argument_list|)
operator|<<
operator|(
literal|64
operator|-
literal|32
operator|)
operator||
name|uint64_t
argument_list|(
literal|'F'
argument_list|)
operator|<<
operator|(
literal|64
operator|-
literal|40
operator|)
operator||
name|uint64_t
argument_list|(
literal|'4'
argument_list|)
operator|<<
operator|(
literal|64
operator|-
literal|48
operator|)
operator||
name|uint64_t
argument_list|(
literal|'2'
argument_list|)
operator|<<
operator|(
literal|64
operator|-
literal|56
operator|)
operator||
name|uint64_t
argument_list|(
literal|0xff
argument_list|)
return|;
block|}
specifier|static
specifier|inline
name|uint64_t
name|SPVersion
parameter_list|()
block|{
return|return
literal|103
return|;
block|}
comment|/// Represents the relative location of an instruction.
comment|///
comment|/// Instruction locations are specified by the line offset from the
comment|/// beginning of the function (marked by the line where the function
comment|/// header is) and the discriminator value within that line.
comment|///
comment|/// The discriminator value is useful to distinguish instructions
comment|/// that are on the same line but belong to different basic blocks
comment|/// (e.g., the two post-increment instructions in "if (p) x++; else y++;").
struct|struct
name|LineLocation
block|{
name|LineLocation
argument_list|(
argument|uint32_t L
argument_list|,
argument|uint32_t D
argument_list|)
block|:
name|LineOffset
argument_list|(
name|L
argument_list|)
operator|,
name|Discriminator
argument_list|(
argument|D
argument_list|)
block|{}
name|void
name|print
argument_list|(
argument|raw_ostream&OS
argument_list|)
specifier|const
expr_stmt|;
name|void
name|dump
argument_list|()
specifier|const
expr_stmt|;
name|bool
name|operator
operator|<
operator|(
specifier|const
name|LineLocation
operator|&
name|O
operator|)
specifier|const
block|{
return|return
name|LineOffset
operator|<
name|O
operator|.
name|LineOffset
operator|||
operator|(
name|LineOffset
operator|==
name|O
operator|.
name|LineOffset
operator|&&
name|Discriminator
operator|<
name|O
operator|.
name|Discriminator
operator|)
return|;
block|}
name|uint32_t
name|LineOffset
decl_stmt|;
name|uint32_t
name|Discriminator
decl_stmt|;
block|}
struct|;
name|raw_ostream
operator|&
name|operator
operator|<<
operator|(
name|raw_ostream
operator|&
name|OS
operator|,
specifier|const
name|LineLocation
operator|&
name|Loc
operator|)
expr_stmt|;
comment|/// Representation of a single sample record.
comment|///
comment|/// A sample record is represented by a positive integer value, which
comment|/// indicates how frequently was the associated line location executed.
comment|///
comment|/// Additionally, if the associated location contains a function call,
comment|/// the record will hold a list of all the possible called targets. For
comment|/// direct calls, this will be the exact function being invoked. For
comment|/// indirect calls (function pointers, virtual table dispatch), this
comment|/// will be a list of one or more functions.
name|class
name|SampleRecord
block|{
name|public
label|:
name|using
name|CallTargetMap
init|=
name|StringMap
operator|<
name|uint64_t
operator|>
decl_stmt|;
name|SampleRecord
argument_list|()
operator|=
expr|default
expr_stmt|;
comment|/// Increment the number of samples for this record by \p S.
comment|/// Optionally scale sample count \p S by \p Weight.
comment|///
comment|/// Sample counts accumulate using saturating arithmetic, to avoid wrapping
comment|/// around unsigned integers.
name|sampleprof_error
name|addSamples
parameter_list|(
name|uint64_t
name|S
parameter_list|,
name|uint64_t
name|Weight
init|=
literal|1
parameter_list|)
block|{
name|bool
name|Overflowed
decl_stmt|;
name|NumSamples
operator|=
name|SaturatingMultiplyAdd
argument_list|(
name|S
argument_list|,
name|Weight
argument_list|,
name|NumSamples
argument_list|,
operator|&
name|Overflowed
argument_list|)
expr_stmt|;
return|return
name|Overflowed
condition|?
name|sampleprof_error
operator|::
name|counter_overflow
else|:
name|sampleprof_error
operator|::
name|success
return|;
block|}
comment|/// Add called function \p F with samples \p S.
comment|/// Optionally scale sample count \p S by \p Weight.
comment|///
comment|/// Sample counts accumulate using saturating arithmetic, to avoid wrapping
comment|/// around unsigned integers.
name|sampleprof_error
name|addCalledTarget
parameter_list|(
name|StringRef
name|F
parameter_list|,
name|uint64_t
name|S
parameter_list|,
name|uint64_t
name|Weight
init|=
literal|1
parameter_list|)
block|{
name|uint64_t
modifier|&
name|TargetSamples
init|=
name|CallTargets
index|[
name|F
index|]
decl_stmt|;
name|bool
name|Overflowed
decl_stmt|;
name|TargetSamples
operator|=
name|SaturatingMultiplyAdd
argument_list|(
name|S
argument_list|,
name|Weight
argument_list|,
name|TargetSamples
argument_list|,
operator|&
name|Overflowed
argument_list|)
expr_stmt|;
return|return
name|Overflowed
condition|?
name|sampleprof_error
operator|::
name|counter_overflow
else|:
name|sampleprof_error
operator|::
name|success
return|;
block|}
comment|/// Return true if this sample record contains function calls.
name|bool
name|hasCalls
argument_list|()
specifier|const
block|{
return|return
operator|!
name|CallTargets
operator|.
name|empty
argument_list|()
return|;
block|}
name|uint64_t
name|getSamples
argument_list|()
specifier|const
block|{
return|return
name|NumSamples
return|;
block|}
specifier|const
name|CallTargetMap
operator|&
name|getCallTargets
argument_list|()
specifier|const
block|{
return|return
name|CallTargets
return|;
block|}
comment|/// Merge the samples in \p Other into this record.
comment|/// Optionally scale sample counts by \p Weight.
name|sampleprof_error
name|merge
parameter_list|(
specifier|const
name|SampleRecord
modifier|&
name|Other
parameter_list|,
name|uint64_t
name|Weight
init|=
literal|1
parameter_list|)
block|{
name|sampleprof_error
name|Result
init|=
name|addSamples
argument_list|(
name|Other
operator|.
name|getSamples
argument_list|()
argument_list|,
name|Weight
argument_list|)
decl_stmt|;
for|for
control|(
specifier|const
specifier|auto
modifier|&
name|I
range|:
name|Other
operator|.
name|getCallTargets
argument_list|()
control|)
block|{
name|MergeResult
argument_list|(
name|Result
argument_list|,
name|addCalledTarget
argument_list|(
name|I
operator|.
name|first
argument_list|()
argument_list|,
name|I
operator|.
name|second
argument_list|,
name|Weight
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|Result
return|;
block|}
name|void
name|print
argument_list|(
name|raw_ostream
operator|&
name|OS
argument_list|,
name|unsigned
name|Indent
argument_list|)
decl|const
decl_stmt|;
name|void
name|dump
argument_list|()
specifier|const
expr_stmt|;
name|private
label|:
name|uint64_t
name|NumSamples
init|=
literal|0
decl_stmt|;
name|CallTargetMap
name|CallTargets
decl_stmt|;
block|}
empty_stmt|;
name|raw_ostream
operator|&
name|operator
operator|<<
operator|(
name|raw_ostream
operator|&
name|OS
operator|,
specifier|const
name|SampleRecord
operator|&
name|Sample
operator|)
expr_stmt|;
name|class
name|FunctionSamples
decl_stmt|;
name|using
name|BodySampleMap
init|=
name|std
operator|::
name|map
operator|<
name|LineLocation
decl_stmt|,
name|SampleRecord
decl|>
decl_stmt|;
name|using
name|FunctionSamplesMap
init|=
name|StringMap
operator|<
name|FunctionSamples
operator|>
decl_stmt|;
name|using
name|CallsiteSampleMap
init|=
name|std
operator|::
name|map
operator|<
name|LineLocation
decl_stmt|,
name|FunctionSamplesMap
decl|>
decl_stmt|;
comment|/// Representation of the samples collected for a function.
comment|///
comment|/// This data structure contains all the collected samples for the body
comment|/// of a function. Each sample corresponds to a LineLocation instance
comment|/// within the body of the function.
name|class
name|FunctionSamples
block|{
name|public
label|:
name|FunctionSamples
argument_list|()
operator|=
expr|default
expr_stmt|;
name|void
name|print
argument_list|(
name|raw_ostream
operator|&
name|OS
operator|=
name|dbgs
argument_list|()
argument_list|,
name|unsigned
name|Indent
operator|=
literal|0
argument_list|)
decl|const
decl_stmt|;
name|void
name|dump
argument_list|()
specifier|const
expr_stmt|;
name|sampleprof_error
name|addTotalSamples
parameter_list|(
name|uint64_t
name|Num
parameter_list|,
name|uint64_t
name|Weight
init|=
literal|1
parameter_list|)
block|{
name|bool
name|Overflowed
decl_stmt|;
name|TotalSamples
operator|=
name|SaturatingMultiplyAdd
argument_list|(
name|Num
argument_list|,
name|Weight
argument_list|,
name|TotalSamples
argument_list|,
operator|&
name|Overflowed
argument_list|)
expr_stmt|;
return|return
name|Overflowed
condition|?
name|sampleprof_error
operator|::
name|counter_overflow
else|:
name|sampleprof_error
operator|::
name|success
return|;
block|}
name|sampleprof_error
name|addHeadSamples
parameter_list|(
name|uint64_t
name|Num
parameter_list|,
name|uint64_t
name|Weight
init|=
literal|1
parameter_list|)
block|{
name|bool
name|Overflowed
decl_stmt|;
name|TotalHeadSamples
operator|=
name|SaturatingMultiplyAdd
argument_list|(
name|Num
argument_list|,
name|Weight
argument_list|,
name|TotalHeadSamples
argument_list|,
operator|&
name|Overflowed
argument_list|)
expr_stmt|;
return|return
name|Overflowed
condition|?
name|sampleprof_error
operator|::
name|counter_overflow
else|:
name|sampleprof_error
operator|::
name|success
return|;
block|}
name|sampleprof_error
name|addBodySamples
parameter_list|(
name|uint32_t
name|LineOffset
parameter_list|,
name|uint32_t
name|Discriminator
parameter_list|,
name|uint64_t
name|Num
parameter_list|,
name|uint64_t
name|Weight
init|=
literal|1
parameter_list|)
block|{
return|return
name|BodySamples
index|[
name|LineLocation
argument_list|(
name|LineOffset
argument_list|,
name|Discriminator
argument_list|)
index|]
operator|.
name|addSamples
argument_list|(
name|Num
argument_list|,
name|Weight
argument_list|)
return|;
block|}
name|sampleprof_error
name|addCalledTargetSamples
argument_list|(
name|uint32_t
name|LineOffset
argument_list|,
name|uint32_t
name|Discriminator
argument_list|,
specifier|const
name|std
operator|::
name|string
operator|&
name|FName
argument_list|,
name|uint64_t
name|Num
argument_list|,
name|uint64_t
name|Weight
operator|=
literal|1
argument_list|)
block|{
return|return
name|BodySamples
index|[
name|LineLocation
argument_list|(
name|LineOffset
argument_list|,
name|Discriminator
argument_list|)
index|]
operator|.
name|addCalledTarget
argument_list|(
name|FName
argument_list|,
name|Num
argument_list|,
name|Weight
argument_list|)
return|;
block|}
comment|/// Return the number of samples collected at the given location.
comment|/// Each location is specified by \p LineOffset and \p Discriminator.
comment|/// If the location is not found in profile, return error.
name|ErrorOr
operator|<
name|uint64_t
operator|>
name|findSamplesAt
argument_list|(
argument|uint32_t LineOffset
argument_list|,
argument|uint32_t Discriminator
argument_list|)
specifier|const
block|{
specifier|const
name|auto
operator|&
name|ret
operator|=
name|BodySamples
operator|.
name|find
argument_list|(
name|LineLocation
argument_list|(
name|LineOffset
argument_list|,
name|Discriminator
argument_list|)
argument_list|)
block|;
if|if
condition|(
name|ret
operator|==
name|BodySamples
operator|.
name|end
argument_list|()
condition|)
return|return
name|std
operator|::
name|error_code
argument_list|()
return|;
else|else
return|return
name|ret
operator|->
name|second
operator|.
name|getSamples
argument_list|()
return|;
block|}
comment|/// Returns the call target map collected at a given location.
comment|/// Each location is specified by \p LineOffset and \p Discriminator.
comment|/// If the location is not found in profile, return error.
name|ErrorOr
operator|<
name|SampleRecord
operator|::
name|CallTargetMap
operator|>
name|findCallTargetMapAt
argument_list|(
argument|uint32_t LineOffset
argument_list|,
argument|uint32_t Discriminator
argument_list|)
specifier|const
block|{
specifier|const
name|auto
operator|&
name|ret
operator|=
name|BodySamples
operator|.
name|find
argument_list|(
name|LineLocation
argument_list|(
name|LineOffset
argument_list|,
name|Discriminator
argument_list|)
argument_list|)
block|;
if|if
condition|(
name|ret
operator|==
name|BodySamples
operator|.
name|end
argument_list|()
condition|)
return|return
name|std
operator|::
name|error_code
argument_list|()
return|;
return|return
name|ret
operator|->
name|second
operator|.
name|getCallTargets
argument_list|()
return|;
block|}
comment|/// Return the function samples at the given callsite location.
name|FunctionSamplesMap
modifier|&
name|functionSamplesAt
parameter_list|(
specifier|const
name|LineLocation
modifier|&
name|Loc
parameter_list|)
block|{
return|return
name|CallsiteSamples
index|[
name|Loc
index|]
return|;
block|}
comment|/// Returns the FunctionSamplesMap at the given \p Loc.
specifier|const
name|FunctionSamplesMap
modifier|*
name|findFunctionSamplesMapAt
argument_list|(
specifier|const
name|LineLocation
operator|&
name|Loc
argument_list|)
decl|const
block|{
name|auto
name|iter
init|=
name|CallsiteSamples
operator|.
name|find
argument_list|(
name|Loc
argument_list|)
decl_stmt|;
if|if
condition|(
name|iter
operator|==
name|CallsiteSamples
operator|.
name|end
argument_list|()
condition|)
return|return
name|nullptr
return|;
return|return
operator|&
name|iter
operator|->
name|second
return|;
block|}
comment|/// Returns a pointer to FunctionSamples at the given callsite location \p Loc
comment|/// with callee \p CalleeName. If no callsite can be found, relax the
comment|/// restriction to return the FunctionSamples at callsite location \p Loc
comment|/// with the maximum total sample count.
specifier|const
name|FunctionSamples
modifier|*
name|findFunctionSamplesAt
argument_list|(
specifier|const
name|LineLocation
operator|&
name|Loc
argument_list|,
name|StringRef
name|CalleeName
argument_list|)
decl|const
block|{
name|auto
name|iter
init|=
name|CallsiteSamples
operator|.
name|find
argument_list|(
name|Loc
argument_list|)
decl_stmt|;
if|if
condition|(
name|iter
operator|==
name|CallsiteSamples
operator|.
name|end
argument_list|()
condition|)
return|return
name|nullptr
return|;
name|auto
name|FS
init|=
name|iter
operator|->
name|second
operator|.
name|find
argument_list|(
name|CalleeName
argument_list|)
decl_stmt|;
if|if
condition|(
name|FS
operator|!=
name|iter
operator|->
name|second
operator|.
name|end
argument_list|()
condition|)
return|return
operator|&
name|FS
operator|->
name|getValue
argument_list|()
return|;
comment|// If we cannot find exact match of the callee name, return the FS with
comment|// the max total count.
name|uint64_t
name|MaxTotalSamples
init|=
literal|0
decl_stmt|;
specifier|const
name|FunctionSamples
modifier|*
name|R
init|=
name|nullptr
decl_stmt|;
for|for
control|(
specifier|const
specifier|auto
modifier|&
name|NameFS
range|:
name|iter
operator|->
name|second
control|)
if|if
condition|(
name|NameFS
operator|.
name|second
operator|.
name|getTotalSamples
argument_list|()
operator|>=
name|MaxTotalSamples
condition|)
block|{
name|MaxTotalSamples
operator|=
name|NameFS
operator|.
name|second
operator|.
name|getTotalSamples
argument_list|()
expr_stmt|;
name|R
operator|=
operator|&
name|NameFS
operator|.
name|second
expr_stmt|;
block|}
return|return
name|R
return|;
block|}
name|bool
name|empty
argument_list|()
specifier|const
block|{
return|return
name|TotalSamples
operator|==
literal|0
return|;
block|}
comment|/// Return the total number of samples collected inside the function.
name|uint64_t
name|getTotalSamples
argument_list|()
specifier|const
block|{
return|return
name|TotalSamples
return|;
block|}
comment|/// Return the total number of samples collected at the head of the
comment|/// function.
name|uint64_t
name|getHeadSamples
argument_list|()
specifier|const
block|{
return|return
name|TotalHeadSamples
return|;
block|}
comment|/// Return all the samples collected in the body of the function.
specifier|const
name|BodySampleMap
operator|&
name|getBodySamples
argument_list|()
specifier|const
block|{
return|return
name|BodySamples
return|;
block|}
comment|/// Return all the callsite samples collected in the body of the function.
specifier|const
name|CallsiteSampleMap
operator|&
name|getCallsiteSamples
argument_list|()
specifier|const
block|{
return|return
name|CallsiteSamples
return|;
block|}
comment|/// Merge the samples in \p Other into this one.
comment|/// Optionally scale samples by \p Weight.
name|sampleprof_error
name|merge
parameter_list|(
specifier|const
name|FunctionSamples
modifier|&
name|Other
parameter_list|,
name|uint64_t
name|Weight
init|=
literal|1
parameter_list|)
block|{
name|sampleprof_error
name|Result
init|=
name|sampleprof_error
operator|::
name|success
decl_stmt|;
name|Name
operator|=
name|Other
operator|.
name|getName
argument_list|()
expr_stmt|;
name|MergeResult
argument_list|(
name|Result
argument_list|,
name|addTotalSamples
argument_list|(
name|Other
operator|.
name|getTotalSamples
argument_list|()
argument_list|,
name|Weight
argument_list|)
argument_list|)
expr_stmt|;
name|MergeResult
argument_list|(
name|Result
argument_list|,
name|addHeadSamples
argument_list|(
name|Other
operator|.
name|getHeadSamples
argument_list|()
argument_list|,
name|Weight
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
specifier|const
specifier|auto
modifier|&
name|I
range|:
name|Other
operator|.
name|getBodySamples
argument_list|()
control|)
block|{
specifier|const
name|LineLocation
modifier|&
name|Loc
init|=
name|I
operator|.
name|first
decl_stmt|;
specifier|const
name|SampleRecord
modifier|&
name|Rec
init|=
name|I
operator|.
name|second
decl_stmt|;
name|MergeResult
argument_list|(
name|Result
argument_list|,
name|BodySamples
index|[
name|Loc
index|]
operator|.
name|merge
argument_list|(
name|Rec
argument_list|,
name|Weight
argument_list|)
argument_list|)
expr_stmt|;
block|}
for|for
control|(
specifier|const
specifier|auto
modifier|&
name|I
range|:
name|Other
operator|.
name|getCallsiteSamples
argument_list|()
control|)
block|{
specifier|const
name|LineLocation
modifier|&
name|Loc
init|=
name|I
operator|.
name|first
decl_stmt|;
name|FunctionSamplesMap
modifier|&
name|FSMap
init|=
name|functionSamplesAt
argument_list|(
name|Loc
argument_list|)
decl_stmt|;
for|for
control|(
specifier|const
specifier|auto
modifier|&
name|Rec
range|:
name|I
operator|.
name|second
control|)
name|MergeResult
argument_list|(
name|Result
argument_list|,
name|FSMap
index|[
name|Rec
operator|.
name|first
argument_list|()
index|]
operator|.
name|merge
argument_list|(
name|Rec
operator|.
name|second
argument_list|,
name|Weight
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|Result
return|;
block|}
comment|/// Recursively traverses all children, if the corresponding function is
comment|/// not defined in module \p M, and its total sample is no less than
comment|/// \p Threshold, add its corresponding GUID to \p S.
name|void
name|findImportedFunctions
argument_list|(
name|DenseSet
operator|<
name|GlobalValue
operator|::
name|GUID
operator|>
operator|&
name|S
argument_list|,
specifier|const
name|Module
operator|*
name|M
argument_list|,
name|uint64_t
name|Threshold
argument_list|)
decl|const
block|{
if|if
condition|(
name|TotalSamples
operator|<=
name|Threshold
condition|)
return|return;
name|Function
modifier|*
name|F
init|=
name|M
operator|->
name|getFunction
argument_list|(
name|Name
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|F
operator|||
operator|!
name|F
operator|->
name|getSubprogram
argument_list|()
condition|)
name|S
operator|.
name|insert
argument_list|(
name|Function
operator|::
name|getGUID
argument_list|(
name|Name
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|auto
name|CS
range|:
name|CallsiteSamples
control|)
for|for
control|(
specifier|const
specifier|auto
modifier|&
name|NameFS
range|:
name|CS
operator|.
name|second
control|)
name|NameFS
operator|.
name|second
operator|.
name|findImportedFunctions
argument_list|(
name|S
argument_list|,
name|M
argument_list|,
name|Threshold
argument_list|)
expr_stmt|;
block|}
comment|/// Set the name of the function.
name|void
name|setName
parameter_list|(
name|StringRef
name|FunctionName
parameter_list|)
block|{
name|Name
operator|=
name|FunctionName
expr_stmt|;
block|}
comment|/// Return the function name.
specifier|const
name|StringRef
operator|&
name|getName
argument_list|()
specifier|const
block|{
return|return
name|Name
return|;
block|}
name|private
label|:
comment|/// Mangled name of the function.
name|StringRef
name|Name
decl_stmt|;
comment|/// Total number of samples collected inside this function.
comment|///
comment|/// Samples are cumulative, they include all the samples collected
comment|/// inside this function and all its inlined callees.
name|uint64_t
name|TotalSamples
init|=
literal|0
decl_stmt|;
comment|/// Total number of samples collected at the head of the function.
comment|/// This is an approximation of the number of calls made to this function
comment|/// at runtime.
name|uint64_t
name|TotalHeadSamples
init|=
literal|0
decl_stmt|;
comment|/// Map instruction locations to collected samples.
comment|///
comment|/// Each entry in this map contains the number of samples
comment|/// collected at the corresponding line offset. All line locations
comment|/// are an offset from the start of the function.
name|BodySampleMap
name|BodySamples
decl_stmt|;
comment|/// Map call sites to collected samples for the called function.
comment|///
comment|/// Each entry in this map corresponds to all the samples
comment|/// collected for the inlined function call at the given
comment|/// location. For example, given:
comment|///
comment|///     void foo() {
comment|///  1    bar();
comment|///  ...
comment|///  8    baz();
comment|///     }
comment|///
comment|/// If the bar() and baz() calls were inlined inside foo(), this
comment|/// map will contain two entries.  One for all the samples collected
comment|/// in the call to bar() at line offset 1, the other for all the samples
comment|/// collected in the call to baz() at line offset 8.
name|CallsiteSampleMap
name|CallsiteSamples
decl_stmt|;
block|}
empty_stmt|;
name|raw_ostream
operator|&
name|operator
operator|<<
operator|(
name|raw_ostream
operator|&
name|OS
operator|,
specifier|const
name|FunctionSamples
operator|&
name|FS
operator|)
expr_stmt|;
comment|/// Sort a LocationT->SampleT map by LocationT.
comment|///
comment|/// It produces a sorted list of<LocationT, SampleT> records by ascending
comment|/// order of LocationT.
name|template
operator|<
name|class
name|LocationT
operator|,
name|class
name|SampleT
operator|>
name|class
name|SampleSorter
block|{
name|public
operator|:
name|using
name|SamplesWithLoc
operator|=
name|std
operator|::
name|pair
operator|<
specifier|const
name|LocationT
block|,
name|SampleT
operator|>
block|;
name|using
name|SamplesWithLocList
operator|=
name|SmallVector
operator|<
specifier|const
name|SamplesWithLoc
operator|*
block|,
literal|20
operator|>
block|;
name|SampleSorter
argument_list|(
argument|const std::map<LocationT
argument_list|,
argument|SampleT>&Samples
argument_list|)
block|{
for|for
control|(
specifier|const
specifier|auto
modifier|&
name|I
range|:
name|Samples
control|)
name|V
operator|.
name|push_back
argument_list|(
operator|&
name|I
argument_list|)
expr_stmt|;
name|std
operator|::
name|stable_sort
argument_list|(
name|V
operator|.
name|begin
argument_list|()
argument_list|,
name|V
operator|.
name|end
argument_list|()
argument_list|,
index|[]
operator|(
specifier|const
name|SamplesWithLoc
operator|*
name|A
operator|,
specifier|const
name|SamplesWithLoc
operator|*
name|B
operator|)
block|{
return|return
name|A
operator|->
name|first
operator|<
name|B
operator|->
name|first
return|;
block|}
argument_list|)
block|;   }
specifier|const
name|SamplesWithLocList
operator|&
name|get
argument_list|()
specifier|const
block|{
return|return
name|V
return|;
block|}
name|private
label|:
name|SamplesWithLocList
name|V
decl_stmt|;
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_comment
unit|}
comment|// end namespace sampleprof
end_comment

begin_comment
unit|}
comment|// end namespace llvm
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|// LLVM_PROFILEDATA_SAMPLEPROF_H
end_comment

end_unit

