begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===-- llvm/Function.h - Class to represent a single function --*- C++ -*-===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file contains the declaration of the Function class, which represents a
end_comment

begin_comment
comment|// single function/procedure in LLVM.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// A function basically consists of a list of basic blocks, a list of arguments,
end_comment

begin_comment
comment|// and a symbol table.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LLVM_FUNCTION_H
end_ifndef

begin_define
define|#
directive|define
name|LLVM_FUNCTION_H
end_define

begin_include
include|#
directive|include
file|"llvm/GlobalValue.h"
end_include

begin_include
include|#
directive|include
file|"llvm/BasicBlock.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Argument.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/Annotation.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Attributes.h"
end_include

begin_decl_stmt
name|namespace
name|llvm
block|{
name|class
name|FunctionType
decl_stmt|;
comment|// Traits for intrusive list of basic blocks...
name|template
operator|<
operator|>
expr|struct
name|ilist_traits
operator|<
name|BasicBlock
operator|>
operator|:
name|public
name|SymbolTableListTraits
operator|<
name|BasicBlock
operator|,
name|Function
operator|>
block|{
comment|// createSentinel is used to get hold of the node that marks the end of the
comment|// list... (same trick used here as in ilist_traits<Instruction>)
name|BasicBlock
operator|*
name|createSentinel
argument_list|()
specifier|const
block|{
return|return
name|static_cast
operator|<
name|BasicBlock
operator|*
operator|>
operator|(
operator|&
name|Sentinel
operator|)
return|;
block|}
specifier|static
name|void
name|destroySentinel
argument_list|(
argument|BasicBlock*
argument_list|)
block|{}
name|BasicBlock
operator|*
name|provideInitialHead
argument_list|()
specifier|const
block|{
return|return
name|createSentinel
argument_list|()
return|;
block|}
name|BasicBlock
operator|*
name|ensureHead
argument_list|(
argument|BasicBlock*
argument_list|)
specifier|const
block|{
return|return
name|createSentinel
argument_list|()
return|;
block|}
specifier|static
name|void
name|noteHead
argument_list|(
argument|BasicBlock*
argument_list|,
argument|BasicBlock*
argument_list|)
block|{}
specifier|static
name|ValueSymbolTable
operator|*
name|getSymTab
argument_list|(
name|Function
operator|*
name|ItemParent
argument_list|)
block|;
name|private
operator|:
name|mutable
name|ilist_node
operator|<
name|BasicBlock
operator|>
name|Sentinel
block|; }
expr_stmt|;
name|template
operator|<
operator|>
expr|struct
name|ilist_traits
operator|<
name|Argument
operator|>
operator|:
name|public
name|SymbolTableListTraits
operator|<
name|Argument
operator|,
name|Function
operator|>
block|{
name|Argument
operator|*
name|createSentinel
argument_list|()
specifier|const
block|{
return|return
name|static_cast
operator|<
name|Argument
operator|*
operator|>
operator|(
operator|&
name|Sentinel
operator|)
return|;
block|}
specifier|static
name|void
name|destroySentinel
argument_list|(
argument|Argument*
argument_list|)
block|{}
name|Argument
operator|*
name|provideInitialHead
argument_list|()
specifier|const
block|{
return|return
name|createSentinel
argument_list|()
return|;
block|}
name|Argument
operator|*
name|ensureHead
argument_list|(
argument|Argument*
argument_list|)
specifier|const
block|{
return|return
name|createSentinel
argument_list|()
return|;
block|}
specifier|static
name|void
name|noteHead
argument_list|(
argument|Argument*
argument_list|,
argument|Argument*
argument_list|)
block|{}
specifier|static
name|ValueSymbolTable
operator|*
name|getSymTab
argument_list|(
name|Function
operator|*
name|ItemParent
argument_list|)
block|;
name|private
operator|:
name|mutable
name|ilist_node
operator|<
name|Argument
operator|>
name|Sentinel
block|; }
expr_stmt|;
name|class
name|Function
range|:
name|public
name|GlobalValue
decl_stmt|,
name|public
name|Annotable
decl_stmt|,
name|public
name|ilist_node
decl|<
name|Function
decl|>
block|{
name|public
label|:
typedef|typedef
name|iplist
operator|<
name|Argument
operator|>
name|ArgumentListType
expr_stmt|;
typedef|typedef
name|iplist
operator|<
name|BasicBlock
operator|>
name|BasicBlockListType
expr_stmt|;
comment|// BasicBlock iterators...
typedef|typedef
name|BasicBlockListType
operator|::
name|iterator
name|iterator
expr_stmt|;
typedef|typedef
name|BasicBlockListType
operator|::
name|const_iterator
name|const_iterator
expr_stmt|;
typedef|typedef
name|ArgumentListType
operator|::
name|iterator
name|arg_iterator
expr_stmt|;
typedef|typedef
name|ArgumentListType
operator|::
name|const_iterator
name|const_arg_iterator
expr_stmt|;
name|private
label|:
comment|// Important things that make up a function!
name|BasicBlockListType
name|BasicBlocks
decl_stmt|;
comment|///< The basic blocks
name|mutable
name|ArgumentListType
name|ArgumentList
decl_stmt|;
comment|///< The formal arguments
name|ValueSymbolTable
modifier|*
name|SymTab
decl_stmt|;
comment|///< Symbol table of args/instructions
name|AttrListPtr
name|AttributeList
decl_stmt|;
comment|///< Parameter attributes
comment|// The Calling Convention is stored in Value::SubclassData.
comment|/*unsigned CallingConvention;*/
name|friend
name|class
name|SymbolTableListTraits
operator|<
name|Function
operator|,
name|Module
operator|>
expr_stmt|;
name|void
name|setParent
parameter_list|(
name|Module
modifier|*
name|parent
parameter_list|)
function_decl|;
comment|/// hasLazyArguments/CheckLazyArguments - The argument list of a function is
comment|/// built on demand, so that the list isn't allocated until the first client
comment|/// needs it.  The hasLazyArguments predicate returns true if the arg list
comment|/// hasn't been set up yet.
name|bool
name|hasLazyArguments
argument_list|()
specifier|const
block|{
return|return
name|SubclassData
operator|&
literal|1
return|;
block|}
name|void
name|CheckLazyArguments
argument_list|()
specifier|const
block|{
if|if
condition|(
name|hasLazyArguments
argument_list|()
condition|)
name|BuildLazyArguments
argument_list|()
expr_stmt|;
block|}
name|void
name|BuildLazyArguments
parameter_list|()
function_decl|const;
name|Function
argument_list|(
specifier|const
name|Function
operator|&
argument_list|)
expr_stmt|;
comment|// DO NOT IMPLEMENT
name|void
name|operator
init|=
operator|(
specifier|const
name|Function
operator|&
operator|)
decl_stmt|;
comment|// DO NOT IMPLEMENT
comment|/// Function ctor - If the (optional) Module argument is specified, the
comment|/// function is automatically inserted into the end of the function list for
comment|/// the module.
comment|///
name|Function
argument_list|(
argument|const FunctionType *Ty
argument_list|,
argument|LinkageTypes Linkage
argument_list|,
argument|const std::string&N =
literal|""
argument_list|,
argument|Module *M =
literal|0
argument_list|)
empty_stmt|;
name|public
label|:
specifier|static
name|Function
modifier|*
name|Create
argument_list|(
specifier|const
name|FunctionType
operator|*
name|Ty
argument_list|,
name|LinkageTypes
name|Linkage
argument_list|,
specifier|const
name|std
operator|::
name|string
operator|&
name|N
operator|=
literal|""
argument_list|,
name|Module
operator|*
name|M
operator|=
literal|0
argument_list|)
block|{
return|return
name|new
argument_list|(
literal|0
argument_list|)
name|Function
argument_list|(
name|Ty
argument_list|,
name|Linkage
argument_list|,
name|N
argument_list|,
name|M
argument_list|)
return|;
block|}
operator|~
name|Function
argument_list|()
expr_stmt|;
specifier|const
name|Type
operator|*
name|getReturnType
argument_list|()
specifier|const
expr_stmt|;
comment|// Return the type of the ret val
specifier|const
name|FunctionType
operator|*
name|getFunctionType
argument_list|()
specifier|const
expr_stmt|;
comment|// Return the FunctionType for me
comment|/// isVarArg - Return true if this function takes a variable number of
comment|/// arguments.
name|bool
name|isVarArg
argument_list|()
specifier|const
expr_stmt|;
comment|/// isDeclaration - Is the body of this function unknown? (The basic block
comment|/// list is empty if so.) This is true for function declarations, but not
comment|/// true for function definitions.
comment|///
name|virtual
name|bool
name|isDeclaration
argument_list|()
specifier|const
block|{
return|return
name|BasicBlocks
operator|.
name|empty
argument_list|()
return|;
block|}
comment|/// getIntrinsicID - This method returns the ID number of the specified
comment|/// function, or Intrinsic::not_intrinsic if the function is not an
comment|/// instrinsic, or if the pointer is null.  This value is always defined to be
comment|/// zero to allow easy checking for whether a function is intrinsic or not.
comment|/// The particular intrinsic functions which correspond to this value are
comment|/// defined in llvm/Intrinsics.h.
comment|///
name|unsigned
name|getIntrinsicID
argument_list|()
specifier|const
expr_stmt|;
name|bool
name|isIntrinsic
argument_list|()
specifier|const
block|{
return|return
name|getIntrinsicID
argument_list|()
operator|!=
literal|0
return|;
block|}
comment|/// getCallingConv()/setCallingConv(uint) - These method get and set the
comment|/// calling convention of this function.  The enum values for the known
comment|/// calling conventions are defined in CallingConv.h.
name|unsigned
name|getCallingConv
argument_list|()
specifier|const
block|{
return|return
name|SubclassData
operator|>>
literal|1
return|;
block|}
name|void
name|setCallingConv
parameter_list|(
name|unsigned
name|CC
parameter_list|)
block|{
name|SubclassData
operator|=
operator|(
name|SubclassData
operator|&
literal|1
operator|)
operator||
operator|(
name|CC
operator|<<
literal|1
operator|)
expr_stmt|;
block|}
comment|/// getAttributes - Return the attribute list for this Function.
comment|///
specifier|const
name|AttrListPtr
operator|&
name|getAttributes
argument_list|()
specifier|const
block|{
return|return
name|AttributeList
return|;
block|}
comment|/// setAttributes - Set the attribute list for this Function.
comment|///
name|void
name|setAttributes
parameter_list|(
specifier|const
name|AttrListPtr
modifier|&
name|attrs
parameter_list|)
block|{
name|AttributeList
operator|=
name|attrs
expr_stmt|;
block|}
comment|/// hasFnAttr - Return true if this function has the given attribute.
name|bool
name|hasFnAttr
argument_list|(
name|Attributes
name|N
argument_list|)
decl|const
block|{
comment|// Function Attributes are stored at ~0 index
return|return
name|AttributeList
operator|.
name|paramHasAttr
argument_list|(
operator|~
literal|0U
argument_list|,
name|N
argument_list|)
return|;
block|}
comment|/// addFnAttr - Add function attributes to this function.
comment|///
name|void
name|addFnAttr
parameter_list|(
name|Attributes
name|N
parameter_list|)
block|{
comment|// Function Attributes are stored at ~0 index
name|addAttribute
argument_list|(
operator|~
literal|0U
argument_list|,
name|N
argument_list|)
expr_stmt|;
block|}
comment|/// removeFnAttr - Remove function attributes from this function.
comment|///
name|void
name|removeFnAttr
parameter_list|(
name|Attributes
name|N
parameter_list|)
block|{
comment|// Function Attributes are stored at ~0 index
name|removeAttribute
argument_list|(
operator|~
literal|0U
argument_list|,
name|N
argument_list|)
expr_stmt|;
block|}
comment|/// hasGC/getGC/setGC/clearGC - The name of the garbage collection algorithm
comment|///                             to use during code generation.
name|bool
name|hasGC
argument_list|()
specifier|const
expr_stmt|;
specifier|const
name|char
operator|*
name|getGC
argument_list|()
specifier|const
expr_stmt|;
name|void
name|setGC
parameter_list|(
specifier|const
name|char
modifier|*
name|Str
parameter_list|)
function_decl|;
name|void
name|clearGC
parameter_list|()
function_decl|;
comment|/// @brief Determine whether the function has the given attribute.
name|bool
name|paramHasAttr
argument_list|(
name|unsigned
name|i
argument_list|,
name|Attributes
name|attr
argument_list|)
decl|const
block|{
return|return
name|AttributeList
operator|.
name|paramHasAttr
argument_list|(
name|i
argument_list|,
name|attr
argument_list|)
return|;
block|}
comment|/// addAttribute - adds the attribute to the list of attributes.
name|void
name|addAttribute
parameter_list|(
name|unsigned
name|i
parameter_list|,
name|Attributes
name|attr
parameter_list|)
function_decl|;
comment|/// removeAttribute - removes the attribute from the list of attributes.
name|void
name|removeAttribute
parameter_list|(
name|unsigned
name|i
parameter_list|,
name|Attributes
name|attr
parameter_list|)
function_decl|;
comment|/// @brief Extract the alignment for a call or parameter (0=unknown).
name|unsigned
name|getParamAlignment
argument_list|(
name|unsigned
name|i
argument_list|)
decl|const
block|{
return|return
name|AttributeList
operator|.
name|getParamAlignment
argument_list|(
name|i
argument_list|)
return|;
block|}
comment|/// @brief Determine if the function does not access memory.
name|bool
name|doesNotAccessMemory
argument_list|()
specifier|const
block|{
return|return
name|hasFnAttr
argument_list|(
name|Attribute
operator|::
name|ReadNone
argument_list|)
return|;
block|}
name|void
name|setDoesNotAccessMemory
parameter_list|(
name|bool
name|DoesNotAccessMemory
init|=
name|true
parameter_list|)
block|{
if|if
condition|(
name|DoesNotAccessMemory
condition|)
name|addFnAttr
argument_list|(
name|Attribute
operator|::
name|ReadNone
argument_list|)
expr_stmt|;
else|else
name|removeFnAttr
argument_list|(
name|Attribute
operator|::
name|ReadNone
argument_list|)
expr_stmt|;
block|}
comment|/// @brief Determine if the function does not access or only reads memory.
name|bool
name|onlyReadsMemory
argument_list|()
specifier|const
block|{
return|return
name|doesNotAccessMemory
argument_list|()
operator|||
name|hasFnAttr
argument_list|(
name|Attribute
operator|::
name|ReadOnly
argument_list|)
return|;
block|}
name|void
name|setOnlyReadsMemory
parameter_list|(
name|bool
name|OnlyReadsMemory
init|=
name|true
parameter_list|)
block|{
if|if
condition|(
name|OnlyReadsMemory
condition|)
name|addFnAttr
argument_list|(
name|Attribute
operator|::
name|ReadOnly
argument_list|)
expr_stmt|;
else|else
name|removeFnAttr
argument_list|(
name|Attribute
operator|::
name|ReadOnly
operator||
name|Attribute
operator|::
name|ReadNone
argument_list|)
expr_stmt|;
block|}
comment|/// @brief Determine if the function cannot return.
name|bool
name|doesNotReturn
argument_list|()
specifier|const
block|{
return|return
name|hasFnAttr
argument_list|(
name|Attribute
operator|::
name|NoReturn
argument_list|)
return|;
block|}
name|void
name|setDoesNotReturn
parameter_list|(
name|bool
name|DoesNotReturn
init|=
name|true
parameter_list|)
block|{
if|if
condition|(
name|DoesNotReturn
condition|)
name|addFnAttr
argument_list|(
name|Attribute
operator|::
name|NoReturn
argument_list|)
expr_stmt|;
else|else
name|removeFnAttr
argument_list|(
name|Attribute
operator|::
name|NoReturn
argument_list|)
expr_stmt|;
block|}
comment|/// @brief Determine if the function cannot unwind.
name|bool
name|doesNotThrow
argument_list|()
specifier|const
block|{
return|return
name|hasFnAttr
argument_list|(
name|Attribute
operator|::
name|NoUnwind
argument_list|)
return|;
block|}
name|void
name|setDoesNotThrow
parameter_list|(
name|bool
name|DoesNotThrow
init|=
name|true
parameter_list|)
block|{
if|if
condition|(
name|DoesNotThrow
condition|)
name|addFnAttr
argument_list|(
name|Attribute
operator|::
name|NoUnwind
argument_list|)
expr_stmt|;
else|else
name|removeFnAttr
argument_list|(
name|Attribute
operator|::
name|NoUnwind
argument_list|)
expr_stmt|;
block|}
comment|/// @brief Determine if the function returns a structure through first
comment|/// pointer argument.
name|bool
name|hasStructRetAttr
argument_list|()
specifier|const
block|{
return|return
name|paramHasAttr
argument_list|(
literal|1
argument_list|,
name|Attribute
operator|::
name|StructRet
argument_list|)
return|;
block|}
comment|/// @brief Determine if the parameter does not alias other parameters.
comment|/// @param n The parameter to check. 1 is the first parameter, 0 is the return
name|bool
name|doesNotAlias
argument_list|(
name|unsigned
name|n
argument_list|)
decl|const
block|{
return|return
name|paramHasAttr
argument_list|(
name|n
argument_list|,
name|Attribute
operator|::
name|NoAlias
argument_list|)
return|;
block|}
name|void
name|setDoesNotAlias
parameter_list|(
name|unsigned
name|n
parameter_list|,
name|bool
name|DoesNotAlias
init|=
name|true
parameter_list|)
block|{
if|if
condition|(
name|DoesNotAlias
condition|)
name|addAttribute
argument_list|(
name|n
argument_list|,
name|Attribute
operator|::
name|NoAlias
argument_list|)
expr_stmt|;
else|else
name|removeAttribute
argument_list|(
name|n
argument_list|,
name|Attribute
operator|::
name|NoAlias
argument_list|)
expr_stmt|;
block|}
comment|/// @brief Determine if the parameter can be captured.
comment|/// @param n The parameter to check. 1 is the first parameter, 0 is the return
name|bool
name|doesNotCapture
argument_list|(
name|unsigned
name|n
argument_list|)
decl|const
block|{
return|return
name|paramHasAttr
argument_list|(
name|n
argument_list|,
name|Attribute
operator|::
name|NoCapture
argument_list|)
return|;
block|}
name|void
name|setDoesNotCapture
parameter_list|(
name|unsigned
name|n
parameter_list|,
name|bool
name|DoesNotCapture
init|=
name|true
parameter_list|)
block|{
if|if
condition|(
name|DoesNotCapture
condition|)
name|addAttribute
argument_list|(
name|n
argument_list|,
name|Attribute
operator|::
name|NoCapture
argument_list|)
expr_stmt|;
else|else
name|removeAttribute
argument_list|(
name|n
argument_list|,
name|Attribute
operator|::
name|NoCapture
argument_list|)
expr_stmt|;
block|}
comment|/// copyAttributesFrom - copy all additional attributes (those not needed to
comment|/// create a Function) from the Function Src to this one.
name|void
name|copyAttributesFrom
parameter_list|(
specifier|const
name|GlobalValue
modifier|*
name|Src
parameter_list|)
function_decl|;
comment|/// deleteBody - This method deletes the body of the function, and converts
comment|/// the linkage to external.
comment|///
name|void
name|deleteBody
parameter_list|()
block|{
name|dropAllReferences
argument_list|()
expr_stmt|;
name|setLinkage
argument_list|(
name|ExternalLinkage
argument_list|)
expr_stmt|;
block|}
comment|/// removeFromParent - This method unlinks 'this' from the containing module,
comment|/// but does not delete it.
comment|///
name|virtual
name|void
name|removeFromParent
parameter_list|()
function_decl|;
comment|/// eraseFromParent - This method unlinks 'this' from the containing module
comment|/// and deletes it.
comment|///
name|virtual
name|void
name|eraseFromParent
parameter_list|()
function_decl|;
comment|/// Get the underlying elements of the Function... the basic block list is
comment|/// empty for external functions.
comment|///
specifier|const
name|ArgumentListType
operator|&
name|getArgumentList
argument_list|()
specifier|const
block|{
name|CheckLazyArguments
argument_list|()
block|;
return|return
name|ArgumentList
return|;
block|}
name|ArgumentListType
modifier|&
name|getArgumentList
parameter_list|()
block|{
name|CheckLazyArguments
argument_list|()
expr_stmt|;
return|return
name|ArgumentList
return|;
block|}
specifier|static
name|iplist
operator|<
name|Argument
operator|>
name|Function
operator|::
operator|*
name|getSublistAccess
argument_list|(
argument|Argument*
argument_list|)
block|{
return|return
operator|&
name|Function
operator|::
name|ArgumentList
return|;
block|}
specifier|const
name|BasicBlockListType
operator|&
name|getBasicBlockList
argument_list|()
specifier|const
block|{
return|return
name|BasicBlocks
return|;
block|}
name|BasicBlockListType
modifier|&
name|getBasicBlockList
parameter_list|()
block|{
return|return
name|BasicBlocks
return|;
block|}
specifier|static
name|iplist
operator|<
name|BasicBlock
operator|>
name|Function
operator|::
operator|*
name|getSublistAccess
argument_list|(
argument|BasicBlock*
argument_list|)
block|{
return|return
operator|&
name|Function
operator|::
name|BasicBlocks
return|;
block|}
specifier|const
name|BasicBlock
operator|&
name|getEntryBlock
argument_list|()
specifier|const
block|{
return|return
name|front
argument_list|()
return|;
block|}
name|BasicBlock
modifier|&
name|getEntryBlock
parameter_list|()
block|{
return|return
name|front
argument_list|()
return|;
block|}
comment|//===--------------------------------------------------------------------===//
comment|// Symbol Table Accessing functions...
comment|/// getSymbolTable() - Return the symbol table...
comment|///
specifier|inline
name|ValueSymbolTable
modifier|&
name|getValueSymbolTable
parameter_list|()
block|{
return|return
operator|*
name|SymTab
return|;
block|}
specifier|inline
specifier|const
name|ValueSymbolTable
operator|&
name|getValueSymbolTable
argument_list|()
specifier|const
block|{
return|return
operator|*
name|SymTab
return|;
block|}
comment|//===--------------------------------------------------------------------===//
comment|// BasicBlock iterator forwarding functions
comment|//
name|iterator
name|begin
parameter_list|()
block|{
return|return
name|BasicBlocks
operator|.
name|begin
argument_list|()
return|;
block|}
name|const_iterator
name|begin
argument_list|()
specifier|const
block|{
return|return
name|BasicBlocks
operator|.
name|begin
argument_list|()
return|;
block|}
name|iterator
name|end
parameter_list|()
block|{
return|return
name|BasicBlocks
operator|.
name|end
argument_list|()
return|;
block|}
name|const_iterator
name|end
argument_list|()
specifier|const
block|{
return|return
name|BasicBlocks
operator|.
name|end
argument_list|()
return|;
block|}
name|size_t
name|size
argument_list|()
specifier|const
block|{
return|return
name|BasicBlocks
operator|.
name|size
argument_list|()
return|;
block|}
name|bool
name|empty
argument_list|()
specifier|const
block|{
return|return
name|BasicBlocks
operator|.
name|empty
argument_list|()
return|;
block|}
specifier|const
name|BasicBlock
operator|&
name|front
argument_list|()
specifier|const
block|{
return|return
name|BasicBlocks
operator|.
name|front
argument_list|()
return|;
block|}
name|BasicBlock
modifier|&
name|front
parameter_list|()
block|{
return|return
name|BasicBlocks
operator|.
name|front
argument_list|()
return|;
block|}
specifier|const
name|BasicBlock
operator|&
name|back
argument_list|()
specifier|const
block|{
return|return
name|BasicBlocks
operator|.
name|back
argument_list|()
return|;
block|}
name|BasicBlock
modifier|&
name|back
parameter_list|()
block|{
return|return
name|BasicBlocks
operator|.
name|back
argument_list|()
return|;
block|}
comment|//===--------------------------------------------------------------------===//
comment|// Argument iterator forwarding functions
comment|//
name|arg_iterator
name|arg_begin
parameter_list|()
block|{
name|CheckLazyArguments
argument_list|()
expr_stmt|;
return|return
name|ArgumentList
operator|.
name|begin
argument_list|()
return|;
block|}
name|const_arg_iterator
name|arg_begin
argument_list|()
specifier|const
block|{
name|CheckLazyArguments
argument_list|()
block|;
return|return
name|ArgumentList
operator|.
name|begin
argument_list|()
return|;
block|}
name|arg_iterator
name|arg_end
parameter_list|()
block|{
name|CheckLazyArguments
argument_list|()
expr_stmt|;
return|return
name|ArgumentList
operator|.
name|end
argument_list|()
return|;
block|}
name|const_arg_iterator
name|arg_end
argument_list|()
specifier|const
block|{
name|CheckLazyArguments
argument_list|()
block|;
return|return
name|ArgumentList
operator|.
name|end
argument_list|()
return|;
block|}
name|size_t
name|arg_size
argument_list|()
specifier|const
expr_stmt|;
name|bool
name|arg_empty
argument_list|()
specifier|const
expr_stmt|;
comment|/// viewCFG - This function is meant for use from the debugger.  You can just
comment|/// say 'call F->viewCFG()' and a ghostview window should pop up from the
comment|/// program, displaying the CFG of the current function with the code for each
comment|/// basic block inside.  This depends on there being a 'dot' and 'gv' program
comment|/// in your path.
comment|///
name|void
name|viewCFG
argument_list|()
specifier|const
expr_stmt|;
comment|/// viewCFGOnly - This function is meant for use from the debugger.  It works
comment|/// just like viewCFG, but it does not include the contents of basic blocks
comment|/// into the nodes, just the label.  If you are only interested in the CFG
comment|/// this can make the graph smaller.
comment|///
name|void
name|viewCFGOnly
argument_list|()
specifier|const
expr_stmt|;
comment|/// Methods for support type inquiry through isa, cast, and dyn_cast:
specifier|static
specifier|inline
name|bool
name|classof
parameter_list|(
specifier|const
name|Function
modifier|*
parameter_list|)
block|{
return|return
name|true
return|;
block|}
specifier|static
specifier|inline
name|bool
name|classof
parameter_list|(
specifier|const
name|Value
modifier|*
name|V
parameter_list|)
block|{
return|return
name|V
operator|->
name|getValueID
argument_list|()
operator|==
name|Value
operator|::
name|FunctionVal
return|;
block|}
comment|/// dropAllReferences() - This method causes all the subinstructions to "let
comment|/// go" of all references that they are maintaining.  This allows one to
comment|/// 'delete' a whole module at a time, even though there may be circular
comment|/// references... first all references are dropped, and all use counts go to
comment|/// zero.  Then everything is deleted for real.  Note that no operations are
comment|/// valid on an object that has "dropped all references", except operator
comment|/// delete.
comment|///
comment|/// Since no other object in the module can have references into the body of a
comment|/// function, dropping all references deletes the entire body of the function,
comment|/// including any contained basic blocks.
comment|///
name|void
name|dropAllReferences
parameter_list|()
function_decl|;
comment|/// hasAddressTaken - returns true if there are any uses of this function
comment|/// other than direct calls or invokes to it.
name|bool
name|hasAddressTaken
argument_list|()
specifier|const
expr_stmt|;
block|}
empty_stmt|;
specifier|inline
name|ValueSymbolTable
operator|*
name|ilist_traits
operator|<
name|BasicBlock
operator|>
operator|::
name|getSymTab
argument_list|(
argument|Function *F
argument_list|)
block|{
return|return
name|F
operator|?
operator|&
name|F
operator|->
name|getValueSymbolTable
argument_list|()
operator|:
literal|0
return|;
block|}
specifier|inline
name|ValueSymbolTable
operator|*
name|ilist_traits
operator|<
name|Argument
operator|>
operator|::
name|getSymTab
argument_list|(
argument|Function *F
argument_list|)
block|{
return|return
name|F
operator|?
operator|&
name|F
operator|->
name|getValueSymbolTable
argument_list|()
operator|:
literal|0
return|;
block|}
block|}
end_decl_stmt

begin_comment
comment|// End llvm namespace
end_comment

begin_endif
endif|#
directive|endif
end_endif

end_unit

