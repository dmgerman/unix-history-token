begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===- llvm/MC/MCAsmLexer.h - Abstract Asm Lexer Interface ------*- C++ -*-===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LLVM_MC_MCPARSER_MCASMLEXER_H
end_ifndef

begin_define
define|#
directive|define
name|LLVM_MC_MCPARSER_MCASMLEXER_H
end_define

begin_include
include|#
directive|include
file|"llvm/ADT/APInt.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/ArrayRef.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/SmallVector.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/StringRef.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/SMLoc.h"
end_include

begin_include
include|#
directive|include
file|<algorithm>
end_include

begin_include
include|#
directive|include
file|<cassert>
end_include

begin_include
include|#
directive|include
file|<cstddef>
end_include

begin_include
include|#
directive|include
file|<cstdint>
end_include

begin_include
include|#
directive|include
file|<string>
end_include

begin_decl_stmt
name|namespace
name|llvm
block|{
comment|/// Target independent representation for an assembler token.
name|class
name|AsmToken
block|{
name|public
label|:
enum|enum
name|TokenKind
block|{
comment|// Markers
name|Eof
block|,
name|Error
block|,
comment|// String values.
name|Identifier
block|,
name|String
block|,
comment|// Integer values.
name|Integer
block|,
name|BigNum
block|,
comment|// larger than 64 bits
comment|// Real values.
name|Real
block|,
comment|// Comments
name|Comment
block|,
name|HashDirective
block|,
comment|// No-value.
name|EndOfStatement
block|,
name|Colon
block|,
name|Space
block|,
name|Plus
block|,
name|Minus
block|,
name|Tilde
block|,
name|Slash
block|,
comment|// '/'
name|BackSlash
block|,
comment|// '\'
name|LParen
block|,
name|RParen
block|,
name|LBrac
block|,
name|RBrac
block|,
name|LCurly
block|,
name|RCurly
block|,
name|Star
block|,
name|Dot
block|,
name|Comma
block|,
name|Dollar
block|,
name|Equal
block|,
name|EqualEqual
block|,
name|Pipe
block|,
name|PipePipe
block|,
name|Caret
block|,
name|Amp
block|,
name|AmpAmp
block|,
name|Exclaim
block|,
name|ExclaimEqual
block|,
name|Percent
block|,
name|Hash
block|,
name|Less
block|,
name|LessEqual
block|,
name|LessLess
block|,
name|LessGreater
block|,
name|Greater
block|,
name|GreaterEqual
block|,
name|GreaterGreater
block|,
name|At
block|,
comment|// MIPS unary expression operators such as %neg.
name|PercentCall16
block|,
name|PercentCall_Hi
block|,
name|PercentCall_Lo
block|,
name|PercentDtprel_Hi
block|,
name|PercentDtprel_Lo
block|,
name|PercentGot
block|,
name|PercentGot_Disp
block|,
name|PercentGot_Hi
block|,
name|PercentGot_Lo
block|,
name|PercentGot_Ofst
block|,
name|PercentGot_Page
block|,
name|PercentGottprel
block|,
name|PercentGp_Rel
block|,
name|PercentHi
block|,
name|PercentHigher
block|,
name|PercentHighest
block|,
name|PercentLo
block|,
name|PercentNeg
block|,
name|PercentPcrel_Hi
block|,
name|PercentPcrel_Lo
block|,
name|PercentTlsgd
block|,
name|PercentTlsldm
block|,
name|PercentTprel_Hi
block|,
name|PercentTprel_Lo
block|}
enum|;
name|private
label|:
name|TokenKind
name|Kind
decl_stmt|;
comment|/// A reference to the entire token contents; this is always a pointer into
comment|/// a memory buffer owned by the source manager.
name|StringRef
name|Str
decl_stmt|;
name|APInt
name|IntVal
decl_stmt|;
name|public
label|:
name|AsmToken
argument_list|()
operator|=
expr|default
expr_stmt|;
name|AsmToken
argument_list|(
argument|TokenKind Kind
argument_list|,
argument|StringRef Str
argument_list|,
argument|APInt IntVal
argument_list|)
block|:
name|Kind
argument_list|(
name|Kind
argument_list|)
operator|,
name|Str
argument_list|(
name|Str
argument_list|)
operator|,
name|IntVal
argument_list|(
argument|std::move(IntVal)
argument_list|)
block|{}
name|AsmToken
argument_list|(
argument|TokenKind Kind
argument_list|,
argument|StringRef Str
argument_list|,
argument|int64_t IntVal =
literal|0
argument_list|)
operator|:
name|Kind
argument_list|(
name|Kind
argument_list|)
operator|,
name|Str
argument_list|(
name|Str
argument_list|)
operator|,
name|IntVal
argument_list|(
literal|64
argument_list|,
argument|IntVal
argument_list|,
argument|true
argument_list|)
block|{}
name|TokenKind
name|getKind
argument_list|()
specifier|const
block|{
return|return
name|Kind
return|;
block|}
name|bool
name|is
argument_list|(
name|TokenKind
name|K
argument_list|)
decl|const
block|{
return|return
name|Kind
operator|==
name|K
return|;
block|}
name|bool
name|isNot
argument_list|(
name|TokenKind
name|K
argument_list|)
decl|const
block|{
return|return
name|Kind
operator|!=
name|K
return|;
block|}
name|SMLoc
name|getLoc
argument_list|()
specifier|const
expr_stmt|;
name|SMLoc
name|getEndLoc
argument_list|()
specifier|const
expr_stmt|;
name|SMRange
name|getLocRange
argument_list|()
specifier|const
expr_stmt|;
comment|/// Get the contents of a string token (without quotes).
name|StringRef
name|getStringContents
argument_list|()
specifier|const
block|{
name|assert
argument_list|(
name|Kind
operator|==
name|String
operator|&&
literal|"This token isn't a string!"
argument_list|)
block|;
return|return
name|Str
operator|.
name|slice
argument_list|(
literal|1
argument_list|,
name|Str
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
return|;
block|}
comment|/// Get the identifier string for the current token, which should be an
comment|/// identifier or a string. This gets the portion of the string which should
comment|/// be used as the identifier, e.g., it does not include the quotes on
comment|/// strings.
name|StringRef
name|getIdentifier
argument_list|()
specifier|const
block|{
if|if
condition|(
name|Kind
operator|==
name|Identifier
condition|)
return|return
name|getString
argument_list|()
return|;
return|return
name|getStringContents
argument_list|()
return|;
block|}
comment|/// Get the string for the current token, this includes all characters (for
comment|/// example, the quotes on strings) in the token.
comment|///
comment|/// The returned StringRef points into the source manager's memory buffer, and
comment|/// is safe to store across calls to Lex().
name|StringRef
name|getString
argument_list|()
specifier|const
block|{
return|return
name|Str
return|;
block|}
comment|// FIXME: Don't compute this in advance, it makes every token larger, and is
comment|// also not generally what we want (it is nicer for recovery etc. to lex 123br
comment|// as a single token, then diagnose as an invalid number).
name|int64_t
name|getIntVal
argument_list|()
specifier|const
block|{
name|assert
argument_list|(
name|Kind
operator|==
name|Integer
operator|&&
literal|"This token isn't an integer!"
argument_list|)
block|;
return|return
name|IntVal
operator|.
name|getZExtValue
argument_list|()
return|;
block|}
name|APInt
name|getAPIntVal
argument_list|()
specifier|const
block|{
name|assert
argument_list|(
operator|(
name|Kind
operator|==
name|Integer
operator|||
name|Kind
operator|==
name|BigNum
operator|)
operator|&&
literal|"This token isn't an integer!"
argument_list|)
block|;
return|return
name|IntVal
return|;
block|}
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_comment
comment|/// A callback class which is notified of each comment in an assembly file as
end_comment

begin_comment
comment|/// it is lexed.
end_comment

begin_decl_stmt
name|class
name|AsmCommentConsumer
block|{
name|public
label|:
name|virtual
operator|~
name|AsmCommentConsumer
argument_list|()
operator|=
expr|default
expr_stmt|;
comment|/// Callback function for when a comment is lexed. Loc is the start of the
comment|/// comment text (excluding the comment-start marker). CommentText is the text
comment|/// of the comment, excluding the comment start and end markers, and the
comment|/// newline for single-line comments.
name|virtual
name|void
name|HandleComment
parameter_list|(
name|SMLoc
name|Loc
parameter_list|,
name|StringRef
name|CommentText
parameter_list|)
init|=
literal|0
function_decl|;
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_comment
comment|/// Generic assembler lexer interface, for use by target specific assembly
end_comment

begin_comment
comment|/// lexers.
end_comment

begin_decl_stmt
name|class
name|MCAsmLexer
block|{
comment|/// The current token, stored in the base class for faster access.
name|SmallVector
operator|<
name|AsmToken
operator|,
literal|1
operator|>
name|CurTok
expr_stmt|;
comment|/// The location and description of the current error
name|SMLoc
name|ErrLoc
decl_stmt|;
name|std
operator|::
name|string
name|Err
expr_stmt|;
name|protected
label|:
comment|// Can only create subclasses.
specifier|const
name|char
modifier|*
name|TokStart
init|=
name|nullptr
decl_stmt|;
name|bool
name|SkipSpace
init|=
name|true
decl_stmt|;
name|bool
name|AllowAtInIdentifier
decl_stmt|;
name|bool
name|IsAtStartOfStatement
init|=
name|true
decl_stmt|;
name|AsmCommentConsumer
modifier|*
name|CommentConsumer
init|=
name|nullptr
decl_stmt|;
name|bool
name|AltMacroMode
decl_stmt|;
name|MCAsmLexer
argument_list|()
expr_stmt|;
name|virtual
name|AsmToken
name|LexToken
parameter_list|()
init|=
literal|0
function_decl|;
name|void
name|SetError
argument_list|(
name|SMLoc
name|errLoc
argument_list|,
specifier|const
name|std
operator|::
name|string
operator|&
name|err
argument_list|)
block|{
name|ErrLoc
operator|=
name|errLoc
expr_stmt|;
name|Err
operator|=
name|err
expr_stmt|;
block|}
name|public
label|:
name|MCAsmLexer
argument_list|(
specifier|const
name|MCAsmLexer
operator|&
argument_list|)
operator|=
name|delete
expr_stmt|;
name|MCAsmLexer
modifier|&
name|operator
init|=
operator|(
specifier|const
name|MCAsmLexer
operator|&
operator|)
operator|=
name|delete
decl_stmt|;
name|virtual
operator|~
name|MCAsmLexer
argument_list|()
expr_stmt|;
name|bool
name|IsaAltMacroMode
parameter_list|()
block|{
return|return
name|AltMacroMode
return|;
block|}
name|void
name|SetAltMacroMode
parameter_list|(
name|bool
name|AltMacroSet
parameter_list|)
block|{
name|AltMacroMode
operator|=
name|AltMacroSet
expr_stmt|;
block|}
comment|/// Consume the next token from the input stream and return it.
comment|///
comment|/// The lexer will continuosly return the end-of-file token once the end of
comment|/// the main input file has been reached.
specifier|const
name|AsmToken
modifier|&
name|Lex
parameter_list|()
block|{
name|assert
argument_list|(
operator|!
name|CurTok
operator|.
name|empty
argument_list|()
argument_list|)
expr_stmt|;
comment|// Mark if we parsing out a EndOfStatement.
name|IsAtStartOfStatement
operator|=
name|CurTok
operator|.
name|front
argument_list|()
operator|.
name|getKind
argument_list|()
operator|==
name|AsmToken
operator|::
name|EndOfStatement
expr_stmt|;
name|CurTok
operator|.
name|erase
argument_list|(
name|CurTok
operator|.
name|begin
argument_list|()
argument_list|)
expr_stmt|;
comment|// LexToken may generate multiple tokens via UnLex but will always return
comment|// the first one. Place returned value at head of CurTok vector.
if|if
condition|(
name|CurTok
operator|.
name|empty
argument_list|()
condition|)
block|{
name|AsmToken
name|T
init|=
name|LexToken
argument_list|()
decl_stmt|;
name|CurTok
operator|.
name|insert
argument_list|(
name|CurTok
operator|.
name|begin
argument_list|()
argument_list|,
name|T
argument_list|)
expr_stmt|;
block|}
return|return
name|CurTok
operator|.
name|front
argument_list|()
return|;
block|}
name|void
name|UnLex
parameter_list|(
name|AsmToken
specifier|const
modifier|&
name|Token
parameter_list|)
block|{
name|IsAtStartOfStatement
operator|=
name|false
expr_stmt|;
name|CurTok
operator|.
name|insert
argument_list|(
name|CurTok
operator|.
name|begin
argument_list|()
argument_list|,
name|Token
argument_list|)
expr_stmt|;
block|}
name|bool
name|isAtStartOfStatement
parameter_list|()
block|{
return|return
name|IsAtStartOfStatement
return|;
block|}
name|virtual
name|StringRef
name|LexUntilEndOfStatement
parameter_list|()
init|=
literal|0
function_decl|;
comment|/// Get the current source location.
name|SMLoc
name|getLoc
argument_list|()
specifier|const
expr_stmt|;
comment|/// Get the current (last) lexed token.
specifier|const
name|AsmToken
operator|&
name|getTok
argument_list|()
specifier|const
block|{
return|return
name|CurTok
index|[
literal|0
index|]
return|;
block|}
comment|/// Look ahead at the next token to be lexed.
specifier|const
name|AsmToken
name|peekTok
parameter_list|(
name|bool
name|ShouldSkipSpace
init|=
name|true
parameter_list|)
block|{
name|AsmToken
name|Tok
decl_stmt|;
name|MutableArrayRef
operator|<
name|AsmToken
operator|>
name|Buf
argument_list|(
name|Tok
argument_list|)
expr_stmt|;
name|size_t
name|ReadCount
init|=
name|peekTokens
argument_list|(
name|Buf
argument_list|,
name|ShouldSkipSpace
argument_list|)
decl_stmt|;
name|assert
argument_list|(
name|ReadCount
operator|==
literal|1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|ReadCount
expr_stmt|;
return|return
name|Tok
return|;
block|}
comment|/// Look ahead an arbitrary number of tokens.
name|virtual
name|size_t
name|peekTokens
argument_list|(
name|MutableArrayRef
operator|<
name|AsmToken
operator|>
name|Buf
argument_list|,
name|bool
name|ShouldSkipSpace
operator|=
name|true
argument_list|)
init|=
literal|0
decl_stmt|;
comment|/// Get the current error location
name|SMLoc
name|getErrLoc
parameter_list|()
block|{
return|return
name|ErrLoc
return|;
block|}
comment|/// Get the current error string
specifier|const
name|std
operator|::
name|string
operator|&
name|getErr
argument_list|()
block|{
return|return
name|Err
return|;
block|}
comment|/// Get the kind of current token.
name|AsmToken
operator|::
name|TokenKind
name|getKind
argument_list|()
specifier|const
block|{
return|return
name|getTok
argument_list|()
operator|.
name|getKind
argument_list|()
return|;
block|}
comment|/// Check if the current token has kind \p K.
name|bool
name|is
argument_list|(
name|AsmToken
operator|::
name|TokenKind
name|K
argument_list|)
decl|const
block|{
return|return
name|getTok
argument_list|()
operator|.
name|is
argument_list|(
name|K
argument_list|)
return|;
block|}
comment|/// Check if the current token has kind \p K.
name|bool
name|isNot
argument_list|(
name|AsmToken
operator|::
name|TokenKind
name|K
argument_list|)
decl|const
block|{
return|return
name|getTok
argument_list|()
operator|.
name|isNot
argument_list|(
name|K
argument_list|)
return|;
block|}
comment|/// Set whether spaces should be ignored by the lexer
name|void
name|setSkipSpace
parameter_list|(
name|bool
name|val
parameter_list|)
block|{
name|SkipSpace
operator|=
name|val
expr_stmt|;
block|}
name|bool
name|getAllowAtInIdentifier
parameter_list|()
block|{
return|return
name|AllowAtInIdentifier
return|;
block|}
name|void
name|setAllowAtInIdentifier
parameter_list|(
name|bool
name|v
parameter_list|)
block|{
name|AllowAtInIdentifier
operator|=
name|v
expr_stmt|;
block|}
name|void
name|setCommentConsumer
parameter_list|(
name|AsmCommentConsumer
modifier|*
name|CommentConsumer
parameter_list|)
block|{
name|this
operator|->
name|CommentConsumer
operator|=
name|CommentConsumer
expr_stmt|;
block|}
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_comment
unit|}
comment|// end namespace llvm
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|// LLVM_MC_MCPARSER_MCASMLEXER_H
end_comment

end_unit

