begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===- llvm/TableGen/Record.h - Classes for Table Records -------*- C++ -*-===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file defines the main TableGen data structures, including the TableGen
end_comment

begin_comment
comment|// types, values, and high-level data structures.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LLVM_TABLEGEN_RECORD_H
end_ifndef

begin_define
define|#
directive|define
name|LLVM_TABLEGEN_RECORD_H
end_define

begin_include
include|#
directive|include
file|"llvm/ADT/ArrayRef.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/FoldingSet.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/PointerIntPair.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/SmallVector.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/StringRef.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/Casting.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/ErrorHandling.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/SMLoc.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/TrailingObjects.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/raw_ostream.h"
end_include

begin_include
include|#
directive|include
file|<algorithm>
end_include

begin_include
include|#
directive|include
file|<cassert>
end_include

begin_include
include|#
directive|include
file|<cstddef>
end_include

begin_include
include|#
directive|include
file|<cstdint>
end_include

begin_include
include|#
directive|include
file|<map>
end_include

begin_include
include|#
directive|include
file|<memory>
end_include

begin_include
include|#
directive|include
file|<string>
end_include

begin_include
include|#
directive|include
file|<utility>
end_include

begin_include
include|#
directive|include
file|<vector>
end_include

begin_decl_stmt
name|namespace
name|llvm
block|{
name|class
name|ListRecTy
decl_stmt|;
name|class
name|Record
decl_stmt|;
name|class
name|RecordKeeper
decl_stmt|;
name|class
name|RecordVal
decl_stmt|;
name|class
name|StringInit
decl_stmt|;
struct_decl|struct
name|MultiClass
struct_decl|;
comment|//===----------------------------------------------------------------------===//
comment|//  Type Classes
comment|//===----------------------------------------------------------------------===//
name|class
name|RecTy
block|{
name|public
label|:
comment|/// \brief Subclass discriminator (for dyn_cast<> et al.)
enum|enum
name|RecTyKind
block|{
name|BitRecTyKind
block|,
name|BitsRecTyKind
block|,
name|CodeRecTyKind
block|,
name|IntRecTyKind
block|,
name|StringRecTyKind
block|,
name|ListRecTyKind
block|,
name|DagRecTyKind
block|,
name|RecordRecTyKind
block|}
enum|;
name|private
label|:
name|RecTyKind
name|Kind
decl_stmt|;
name|ListRecTy
modifier|*
name|ListTy
init|=
name|nullptr
decl_stmt|;
name|public
label|:
name|RecTy
argument_list|(
argument|RecTyKind K
argument_list|)
block|:
name|Kind
argument_list|(
argument|K
argument_list|)
block|{}
name|virtual
operator|~
name|RecTy
argument_list|()
operator|=
expr|default
expr_stmt|;
name|RecTyKind
name|getRecTyKind
argument_list|()
specifier|const
block|{
return|return
name|Kind
return|;
block|}
name|virtual
name|std
operator|::
name|string
name|getAsString
argument_list|()
specifier|const
operator|=
literal|0
expr_stmt|;
name|void
name|print
argument_list|(
name|raw_ostream
operator|&
name|OS
argument_list|)
decl|const
block|{
name|OS
operator|<<
name|getAsString
argument_list|()
expr_stmt|;
block|}
name|void
name|dump
argument_list|()
specifier|const
expr_stmt|;
comment|/// Return true if all values of 'this' type can be converted to the specified
comment|/// type.
name|virtual
name|bool
name|typeIsConvertibleTo
argument_list|(
specifier|const
name|RecTy
operator|*
name|RHS
argument_list|)
decl|const
decl_stmt|;
comment|/// Returns the type representing list<this>.
name|ListRecTy
modifier|*
name|getListTy
parameter_list|()
function_decl|;
block|}
empty_stmt|;
specifier|inline
name|raw_ostream
operator|&
name|operator
operator|<<
operator|(
name|raw_ostream
operator|&
name|OS
operator|,
specifier|const
name|RecTy
operator|&
name|Ty
operator|)
block|{
name|Ty
operator|.
name|print
argument_list|(
name|OS
argument_list|)
block|;
return|return
name|OS
return|;
block|}
comment|/// 'bit' - Represent a single bit
comment|///
name|class
name|BitRecTy
range|:
name|public
name|RecTy
block|{
specifier|static
name|BitRecTy
name|Shared
block|;
name|BitRecTy
argument_list|()
operator|:
name|RecTy
argument_list|(
argument|BitRecTyKind
argument_list|)
block|{}
name|public
operator|:
specifier|static
name|bool
name|classof
argument_list|(
argument|const RecTy *RT
argument_list|)
block|{
return|return
name|RT
operator|->
name|getRecTyKind
argument_list|()
operator|==
name|BitRecTyKind
return|;
block|}
specifier|static
name|BitRecTy
operator|*
name|get
argument_list|()
block|{
return|return
operator|&
name|Shared
return|;
block|}
name|std
operator|::
name|string
name|getAsString
argument_list|()
specifier|const
name|override
block|{
return|return
literal|"bit"
return|;
block|}
name|bool
name|typeIsConvertibleTo
argument_list|(
argument|const RecTy *RHS
argument_list|)
specifier|const
name|override
block|; }
decl_stmt|;
comment|/// 'bits<n>' - Represent a fixed number of bits
comment|///
name|class
name|BitsRecTy
range|:
name|public
name|RecTy
block|{
name|unsigned
name|Size
block|;
name|explicit
name|BitsRecTy
argument_list|(
argument|unsigned Sz
argument_list|)
operator|:
name|RecTy
argument_list|(
name|BitsRecTyKind
argument_list|)
block|,
name|Size
argument_list|(
argument|Sz
argument_list|)
block|{}
name|public
operator|:
specifier|static
name|bool
name|classof
argument_list|(
argument|const RecTy *RT
argument_list|)
block|{
return|return
name|RT
operator|->
name|getRecTyKind
argument_list|()
operator|==
name|BitsRecTyKind
return|;
block|}
specifier|static
name|BitsRecTy
operator|*
name|get
argument_list|(
argument|unsigned Sz
argument_list|)
block|;
name|unsigned
name|getNumBits
argument_list|()
specifier|const
block|{
return|return
name|Size
return|;
block|}
name|std
operator|::
name|string
name|getAsString
argument_list|()
specifier|const
name|override
block|;
name|bool
name|typeIsConvertibleTo
argument_list|(
argument|const RecTy *RHS
argument_list|)
specifier|const
name|override
block|; }
decl_stmt|;
comment|/// 'code' - Represent a code fragment
comment|///
name|class
name|CodeRecTy
range|:
name|public
name|RecTy
block|{
specifier|static
name|CodeRecTy
name|Shared
block|;
name|CodeRecTy
argument_list|()
operator|:
name|RecTy
argument_list|(
argument|CodeRecTyKind
argument_list|)
block|{}
name|public
operator|:
specifier|static
name|bool
name|classof
argument_list|(
argument|const RecTy *RT
argument_list|)
block|{
return|return
name|RT
operator|->
name|getRecTyKind
argument_list|()
operator|==
name|CodeRecTyKind
return|;
block|}
specifier|static
name|CodeRecTy
operator|*
name|get
argument_list|()
block|{
return|return
operator|&
name|Shared
return|;
block|}
name|std
operator|::
name|string
name|getAsString
argument_list|()
specifier|const
name|override
block|{
return|return
literal|"code"
return|;
block|}
expr|}
block|;
comment|/// 'int' - Represent an integer value of no particular size
comment|///
name|class
name|IntRecTy
operator|:
name|public
name|RecTy
block|{
specifier|static
name|IntRecTy
name|Shared
block|;
name|IntRecTy
argument_list|()
operator|:
name|RecTy
argument_list|(
argument|IntRecTyKind
argument_list|)
block|{}
name|public
operator|:
specifier|static
name|bool
name|classof
argument_list|(
argument|const RecTy *RT
argument_list|)
block|{
return|return
name|RT
operator|->
name|getRecTyKind
argument_list|()
operator|==
name|IntRecTyKind
return|;
block|}
specifier|static
name|IntRecTy
operator|*
name|get
argument_list|()
block|{
return|return
operator|&
name|Shared
return|;
block|}
name|std
operator|::
name|string
name|getAsString
argument_list|()
specifier|const
name|override
block|{
return|return
literal|"int"
return|;
block|}
name|bool
name|typeIsConvertibleTo
argument_list|(
argument|const RecTy *RHS
argument_list|)
specifier|const
name|override
block|; }
block|;
comment|/// 'string' - Represent an string value
comment|///
name|class
name|StringRecTy
operator|:
name|public
name|RecTy
block|{
specifier|static
name|StringRecTy
name|Shared
block|;
name|StringRecTy
argument_list|()
operator|:
name|RecTy
argument_list|(
argument|StringRecTyKind
argument_list|)
block|{}
name|public
operator|:
specifier|static
name|bool
name|classof
argument_list|(
argument|const RecTy *RT
argument_list|)
block|{
return|return
name|RT
operator|->
name|getRecTyKind
argument_list|()
operator|==
name|StringRecTyKind
operator|||
name|RT
operator|->
name|getRecTyKind
argument_list|()
operator|==
name|CodeRecTyKind
return|;
block|}
specifier|static
name|StringRecTy
operator|*
name|get
argument_list|()
block|{
return|return
operator|&
name|Shared
return|;
block|}
name|std
operator|::
name|string
name|getAsString
argument_list|()
specifier|const
name|override
block|; }
block|;
comment|/// 'list<Ty>' - Represent a list of values, all of which must be of
comment|/// the specified type.
comment|///
name|class
name|ListRecTy
operator|:
name|public
name|RecTy
block|{
name|RecTy
operator|*
name|Ty
block|;
name|explicit
name|ListRecTy
argument_list|(
name|RecTy
operator|*
name|T
argument_list|)
operator|:
name|RecTy
argument_list|(
name|ListRecTyKind
argument_list|)
block|,
name|Ty
argument_list|(
argument|T
argument_list|)
block|{}
name|friend
name|ListRecTy
operator|*
name|RecTy
operator|::
name|getListTy
argument_list|()
block|;
name|public
operator|:
specifier|static
name|bool
name|classof
argument_list|(
argument|const RecTy *RT
argument_list|)
block|{
return|return
name|RT
operator|->
name|getRecTyKind
argument_list|()
operator|==
name|ListRecTyKind
return|;
block|}
specifier|static
name|ListRecTy
operator|*
name|get
argument_list|(
argument|RecTy *T
argument_list|)
block|{
return|return
name|T
operator|->
name|getListTy
argument_list|()
return|;
block|}
name|RecTy
operator|*
name|getElementType
argument_list|()
specifier|const
block|{
return|return
name|Ty
return|;
block|}
name|std
operator|::
name|string
name|getAsString
argument_list|()
specifier|const
name|override
block|;
name|bool
name|typeIsConvertibleTo
argument_list|(
argument|const RecTy *RHS
argument_list|)
specifier|const
name|override
block|; }
block|;
comment|/// 'dag' - Represent a dag fragment
comment|///
name|class
name|DagRecTy
operator|:
name|public
name|RecTy
block|{
specifier|static
name|DagRecTy
name|Shared
block|;
name|DagRecTy
argument_list|()
operator|:
name|RecTy
argument_list|(
argument|DagRecTyKind
argument_list|)
block|{}
name|public
operator|:
specifier|static
name|bool
name|classof
argument_list|(
argument|const RecTy *RT
argument_list|)
block|{
return|return
name|RT
operator|->
name|getRecTyKind
argument_list|()
operator|==
name|DagRecTyKind
return|;
block|}
specifier|static
name|DagRecTy
operator|*
name|get
argument_list|()
block|{
return|return
operator|&
name|Shared
return|;
block|}
name|std
operator|::
name|string
name|getAsString
argument_list|()
specifier|const
name|override
block|; }
block|;
comment|/// '[classname]' - Represent an instance of a class, such as:
comment|/// (R32 X = EAX).
comment|///
name|class
name|RecordRecTy
operator|:
name|public
name|RecTy
block|{
name|Record
operator|*
name|Rec
block|;
name|explicit
name|RecordRecTy
argument_list|(
name|Record
operator|*
name|R
argument_list|)
operator|:
name|RecTy
argument_list|(
name|RecordRecTyKind
argument_list|)
block|,
name|Rec
argument_list|(
argument|R
argument_list|)
block|{}
name|friend
name|class
name|Record
block|;
name|public
operator|:
specifier|static
name|bool
name|classof
argument_list|(
argument|const RecTy *RT
argument_list|)
block|{
return|return
name|RT
operator|->
name|getRecTyKind
argument_list|()
operator|==
name|RecordRecTyKind
return|;
block|}
specifier|static
name|RecordRecTy
operator|*
name|get
argument_list|(
name|Record
operator|*
name|R
argument_list|)
block|;
name|Record
operator|*
name|getRecord
argument_list|()
specifier|const
block|{
return|return
name|Rec
return|;
block|}
name|std
operator|::
name|string
name|getAsString
argument_list|()
specifier|const
name|override
block|;
name|bool
name|typeIsConvertibleTo
argument_list|(
argument|const RecTy *RHS
argument_list|)
specifier|const
name|override
block|; }
block|;
comment|/// Find a common type that T1 and T2 convert to.
comment|/// Return 0 if no such type exists.
comment|///
name|RecTy
operator|*
name|resolveTypes
argument_list|(
name|RecTy
operator|*
name|T1
argument_list|,
name|RecTy
operator|*
name|T2
argument_list|)
block|;
comment|//===----------------------------------------------------------------------===//
comment|//  Initializer Classes
comment|//===----------------------------------------------------------------------===//
name|class
name|Init
block|{
name|protected
operator|:
comment|/// \brief Discriminator enum (for isa<>, dyn_cast<>, et al.)
comment|///
comment|/// This enum is laid out by a preorder traversal of the inheritance
comment|/// hierarchy, and does not contain an entry for abstract classes, as per
comment|/// the recommendation in docs/HowToSetUpLLVMStyleRTTI.rst.
comment|///
comment|/// We also explicitly include "first" and "last" values for each
comment|/// interior node of the inheritance tree, to make it easier to read the
comment|/// corresponding classof().
comment|///
comment|/// We could pack these a bit tighter by not having the IK_FirstXXXInit
comment|/// and IK_LastXXXInit be their own values, but that would degrade
comment|/// readability for really no benefit.
expr|enum
name|InitKind
operator|:
name|uint8_t
block|{
name|IK_BitInit
block|,
name|IK_FirstTypedInit
block|,
name|IK_BitsInit
block|,
name|IK_CodeInit
block|,
name|IK_DagInit
block|,
name|IK_DefInit
block|,
name|IK_FieldInit
block|,
name|IK_IntInit
block|,
name|IK_ListInit
block|,
name|IK_FirstOpInit
block|,
name|IK_BinOpInit
block|,
name|IK_TernOpInit
block|,
name|IK_UnOpInit
block|,
name|IK_LastOpInit
block|,
name|IK_StringInit
block|,
name|IK_VarInit
block|,
name|IK_VarListElementInit
block|,
name|IK_LastTypedInit
block|,
name|IK_UnsetInit
block|,
name|IK_VarBitInit
block|}
block|;
name|private
operator|:
specifier|const
name|InitKind
name|Kind
block|;
name|protected
operator|:
name|uint8_t
name|Opc
block|;
comment|// Used by UnOpInit, BinOpInit, and TernOpInit
name|private
operator|:
name|virtual
name|void
name|anchor
argument_list|()
block|;
name|public
operator|:
name|InitKind
name|getKind
argument_list|()
specifier|const
block|{
return|return
name|Kind
return|;
block|}
name|protected
operator|:
name|explicit
name|Init
argument_list|(
argument|InitKind K
argument_list|,
argument|uint8_t Opc =
literal|0
argument_list|)
operator|:
name|Kind
argument_list|(
name|K
argument_list|)
block|,
name|Opc
argument_list|(
argument|Opc
argument_list|)
block|{}
name|public
operator|:
name|Init
argument_list|(
specifier|const
name|Init
operator|&
argument_list|)
operator|=
name|delete
block|;
name|Init
operator|&
name|operator
operator|=
operator|(
specifier|const
name|Init
operator|&
operator|)
operator|=
name|delete
block|;
name|virtual
operator|~
name|Init
argument_list|()
operator|=
expr|default
block|;
comment|/// This virtual method should be overridden by values that may
comment|/// not be completely specified yet.
name|virtual
name|bool
name|isComplete
argument_list|()
specifier|const
block|{
return|return
name|true
return|;
block|}
comment|/// Print out this value.
name|void
name|print
argument_list|(
argument|raw_ostream&OS
argument_list|)
specifier|const
block|{
name|OS
operator|<<
name|getAsString
argument_list|()
block|; }
comment|/// Convert this value to a string form.
name|virtual
name|std
operator|::
name|string
name|getAsString
argument_list|()
specifier|const
operator|=
literal|0
block|;
comment|/// Convert this value to a string form,
comment|/// without adding quote markers.  This primaruly affects
comment|/// StringInits where we will not surround the string value with
comment|/// quotes.
name|virtual
name|std
operator|::
name|string
name|getAsUnquotedString
argument_list|()
specifier|const
block|{
return|return
name|getAsString
argument_list|()
return|;
block|}
comment|/// Debugging method that may be called through a debugger, just
comment|/// invokes print on stderr.
name|void
name|dump
argument_list|()
specifier|const
block|;
comment|/// This virtual function converts to the appropriate
comment|/// Init based on the passed in type.
name|virtual
name|Init
operator|*
name|convertInitializerTo
argument_list|(
argument|RecTy *Ty
argument_list|)
specifier|const
operator|=
literal|0
block|;
comment|/// This method is used to implement the bitrange
comment|/// selection operator.  Given an initializer, it selects the specified bits
comment|/// out, returning them as a new init of bits type.  If it is not legal to use
comment|/// the bit subscript operator on this initializer, return null.
comment|///
name|virtual
name|Init
operator|*
name|convertInitializerBitRange
argument_list|(
argument|ArrayRef<unsigned> Bits
argument_list|)
specifier|const
block|{
return|return
name|nullptr
return|;
block|}
comment|/// This method is used to implement the list slice
comment|/// selection operator.  Given an initializer, it selects the specified list
comment|/// elements, returning them as a new init of list type.  If it is not legal
comment|/// to take a slice of this, return null.
comment|///
name|virtual
name|Init
operator|*
name|convertInitListSlice
argument_list|(
argument|ArrayRef<unsigned> Elements
argument_list|)
specifier|const
block|{
return|return
name|nullptr
return|;
block|}
comment|/// This method is used to implement the FieldInit class.
comment|/// Implementors of this method should return the type of the named field if
comment|/// they are of record type.
comment|///
name|virtual
name|RecTy
operator|*
name|getFieldType
argument_list|(
argument|StringInit *FieldName
argument_list|)
specifier|const
block|{
return|return
name|nullptr
return|;
block|}
comment|/// This method complements getFieldType to return the
comment|/// initializer for the specified field.  If getFieldType returns non-null
comment|/// this method should return non-null, otherwise it returns null.
comment|///
name|virtual
name|Init
operator|*
name|getFieldInit
argument_list|(
argument|Record&R
argument_list|,
argument|const RecordVal *RV
argument_list|,
argument|StringInit *FieldName
argument_list|)
specifier|const
block|{
return|return
name|nullptr
return|;
block|}
comment|/// This method is used by classes that refer to other
comment|/// variables which may not be defined at the time the expression is formed.
comment|/// If a value is set for the variable later, this method will be called on
comment|/// users of the value to allow the value to propagate out.
comment|///
name|virtual
name|Init
operator|*
name|resolveReferences
argument_list|(
argument|Record&R
argument_list|,
argument|const RecordVal *RV
argument_list|)
specifier|const
block|{
return|return
name|const_cast
operator|<
name|Init
operator|*
operator|>
operator|(
name|this
operator|)
return|;
block|}
comment|/// This method is used to return the initializer for the specified
comment|/// bit.
name|virtual
name|Init
operator|*
name|getBit
argument_list|(
argument|unsigned Bit
argument_list|)
specifier|const
operator|=
literal|0
block|;
comment|/// This method is used to retrieve the initializer for bit
comment|/// reference. For non-VarBitInit, it simply returns itself.
name|virtual
name|Init
operator|*
name|getBitVar
argument_list|()
specifier|const
block|{
return|return
name|const_cast
operator|<
name|Init
operator|*
operator|>
operator|(
name|this
operator|)
return|;
block|}
comment|/// This method is used to retrieve the bit number of a bit
comment|/// reference. For non-VarBitInit, it simply returns 0.
name|virtual
name|unsigned
name|getBitNum
argument_list|()
specifier|const
block|{
return|return
literal|0
return|;
block|}
expr|}
block|;
specifier|inline
name|raw_ostream
operator|&
name|operator
operator|<<
operator|(
name|raw_ostream
operator|&
name|OS
expr|,
specifier|const
name|Init
operator|&
name|I
operator|)
block|{
name|I
operator|.
name|print
argument_list|(
name|OS
argument_list|)
block|;
return|return
name|OS
return|;
block|}
comment|/// This is the common super-class of types that have a specific,
comment|/// explicit, type.
comment|///
name|class
name|TypedInit
operator|:
name|public
name|Init
block|{
name|RecTy
operator|*
name|Ty
block|;
name|protected
operator|:
name|explicit
name|TypedInit
argument_list|(
argument|InitKind K
argument_list|,
argument|RecTy *T
argument_list|,
argument|uint8_t Opc =
literal|0
argument_list|)
operator|:
name|Init
argument_list|(
name|K
argument_list|,
name|Opc
argument_list|)
block|,
name|Ty
argument_list|(
argument|T
argument_list|)
block|{}
name|public
operator|:
name|TypedInit
argument_list|(
specifier|const
name|TypedInit
operator|&
name|Other
argument_list|)
operator|=
name|delete
block|;
name|TypedInit
operator|&
name|operator
operator|=
operator|(
specifier|const
name|TypedInit
operator|&
name|Other
operator|)
operator|=
name|delete
block|;
specifier|static
name|bool
name|classof
argument_list|(
argument|const Init *I
argument_list|)
block|{
return|return
name|I
operator|->
name|getKind
argument_list|()
operator|>=
name|IK_FirstTypedInit
operator|&&
name|I
operator|->
name|getKind
argument_list|()
operator|<=
name|IK_LastTypedInit
return|;
block|}
name|RecTy
operator|*
name|getType
argument_list|()
specifier|const
block|{
return|return
name|Ty
return|;
block|}
name|Init
operator|*
name|convertInitializerTo
argument_list|(
argument|RecTy *Ty
argument_list|)
specifier|const
name|override
block|;
name|Init
operator|*
name|convertInitializerBitRange
argument_list|(
argument|ArrayRef<unsigned> Bits
argument_list|)
specifier|const
name|override
block|;
name|Init
operator|*
name|convertInitListSlice
argument_list|(
argument|ArrayRef<unsigned> Elements
argument_list|)
specifier|const
name|override
block|;
comment|/// This method is used to implement the FieldInit class.
comment|/// Implementors of this method should return the type of the named field if
comment|/// they are of record type.
comment|///
name|RecTy
operator|*
name|getFieldType
argument_list|(
argument|StringInit *FieldName
argument_list|)
specifier|const
name|override
block|;
comment|/// This method is used to implement
comment|/// VarListElementInit::resolveReferences.  If the list element is resolvable
comment|/// now, we return the resolved value, otherwise we return null.
name|virtual
name|Init
operator|*
name|resolveListElementReference
argument_list|(
argument|Record&R
argument_list|,
argument|const RecordVal *RV
argument_list|,
argument|unsigned Elt
argument_list|)
specifier|const
operator|=
literal|0
block|; }
block|;
comment|/// '?' - Represents an uninitialized value
comment|///
name|class
name|UnsetInit
operator|:
name|public
name|Init
block|{
name|UnsetInit
argument_list|()
operator|:
name|Init
argument_list|(
argument|IK_UnsetInit
argument_list|)
block|{}
name|public
operator|:
name|UnsetInit
argument_list|(
specifier|const
name|UnsetInit
operator|&
argument_list|)
operator|=
name|delete
block|;
name|UnsetInit
operator|&
name|operator
operator|=
operator|(
specifier|const
name|UnsetInit
operator|&
name|Other
operator|)
operator|=
name|delete
block|;
specifier|static
name|bool
name|classof
argument_list|(
argument|const Init *I
argument_list|)
block|{
return|return
name|I
operator|->
name|getKind
argument_list|()
operator|==
name|IK_UnsetInit
return|;
block|}
specifier|static
name|UnsetInit
operator|*
name|get
argument_list|()
block|;
name|Init
operator|*
name|convertInitializerTo
argument_list|(
argument|RecTy *Ty
argument_list|)
specifier|const
name|override
block|;
name|Init
operator|*
name|getBit
argument_list|(
argument|unsigned Bit
argument_list|)
specifier|const
name|override
block|{
return|return
name|const_cast
operator|<
name|UnsetInit
operator|*
operator|>
operator|(
name|this
operator|)
return|;
block|}
name|bool
name|isComplete
argument_list|()
specifier|const
name|override
block|{
return|return
name|false
return|;
block|}
name|std
operator|::
name|string
name|getAsString
argument_list|()
specifier|const
name|override
block|{
return|return
literal|"?"
return|;
block|}
expr|}
block|;
comment|/// 'true'/'false' - Represent a concrete initializer for a bit.
comment|///
name|class
name|BitInit
operator|:
name|public
name|Init
block|{
name|bool
name|Value
block|;
name|explicit
name|BitInit
argument_list|(
argument|bool V
argument_list|)
operator|:
name|Init
argument_list|(
name|IK_BitInit
argument_list|)
block|,
name|Value
argument_list|(
argument|V
argument_list|)
block|{}
name|public
operator|:
name|BitInit
argument_list|(
specifier|const
name|BitInit
operator|&
name|Other
argument_list|)
operator|=
name|delete
block|;
name|BitInit
operator|&
name|operator
operator|=
operator|(
name|BitInit
operator|&
name|Other
operator|)
operator|=
name|delete
block|;
specifier|static
name|bool
name|classof
argument_list|(
argument|const Init *I
argument_list|)
block|{
return|return
name|I
operator|->
name|getKind
argument_list|()
operator|==
name|IK_BitInit
return|;
block|}
specifier|static
name|BitInit
operator|*
name|get
argument_list|(
argument|bool V
argument_list|)
block|;
name|bool
name|getValue
argument_list|()
specifier|const
block|{
return|return
name|Value
return|;
block|}
name|Init
operator|*
name|convertInitializerTo
argument_list|(
argument|RecTy *Ty
argument_list|)
specifier|const
name|override
block|;
name|Init
operator|*
name|getBit
argument_list|(
argument|unsigned Bit
argument_list|)
specifier|const
name|override
block|{
name|assert
argument_list|(
name|Bit
operator|<
literal|1
operator|&&
literal|"Bit index out of range!"
argument_list|)
block|;
return|return
name|const_cast
operator|<
name|BitInit
operator|*
operator|>
operator|(
name|this
operator|)
return|;
block|}
name|std
operator|::
name|string
name|getAsString
argument_list|()
specifier|const
name|override
block|{
return|return
name|Value
operator|?
literal|"1"
operator|:
literal|"0"
return|;
block|}
expr|}
block|;
comment|/// '{ a, b, c }' - Represents an initializer for a BitsRecTy value.
comment|/// It contains a vector of bits, whose size is determined by the type.
comment|///
name|class
name|BitsInit
name|final
operator|:
name|public
name|TypedInit
block|,
name|public
name|FoldingSetNode
block|,
name|public
name|TrailingObjects
operator|<
name|BitsInit
block|,
name|Init
operator|*
operator|>
block|{
name|unsigned
name|NumBits
block|;
name|BitsInit
argument_list|(
argument|unsigned N
argument_list|)
operator|:
name|TypedInit
argument_list|(
name|IK_BitsInit
argument_list|,
name|BitsRecTy
operator|::
name|get
argument_list|(
name|N
argument_list|)
argument_list|)
block|,
name|NumBits
argument_list|(
argument|N
argument_list|)
block|{}
name|public
operator|:
name|BitsInit
argument_list|(
specifier|const
name|BitsInit
operator|&
name|Other
argument_list|)
operator|=
name|delete
block|;
name|BitsInit
operator|&
name|operator
operator|=
operator|(
specifier|const
name|BitsInit
operator|&
name|Other
operator|)
operator|=
name|delete
block|;
comment|// Do not use sized deallocation due to trailing objects.
name|void
name|operator
name|delete
argument_list|(
argument|void *p
argument_list|)
block|{
operator|::
name|operator
name|delete
argument_list|(
name|p
argument_list|)
block|; }
specifier|static
name|bool
name|classof
argument_list|(
argument|const Init *I
argument_list|)
block|{
return|return
name|I
operator|->
name|getKind
argument_list|()
operator|==
name|IK_BitsInit
return|;
block|}
specifier|static
name|BitsInit
operator|*
name|get
argument_list|(
name|ArrayRef
operator|<
name|Init
operator|*
operator|>
name|Range
argument_list|)
block|;
name|void
name|Profile
argument_list|(
argument|FoldingSetNodeID&ID
argument_list|)
specifier|const
block|;
name|unsigned
name|getNumBits
argument_list|()
specifier|const
block|{
return|return
name|NumBits
return|;
block|}
name|Init
operator|*
name|convertInitializerTo
argument_list|(
argument|RecTy *Ty
argument_list|)
specifier|const
name|override
block|;
name|Init
operator|*
name|convertInitializerBitRange
argument_list|(
argument|ArrayRef<unsigned> Bits
argument_list|)
specifier|const
name|override
block|;
name|bool
name|isComplete
argument_list|()
specifier|const
name|override
block|{
for|for
control|(
name|unsigned
name|i
init|=
literal|0
init|;
name|i
operator|!=
name|getNumBits
argument_list|()
condition|;
operator|++
name|i
control|)
if|if
condition|(
operator|!
name|getBit
argument_list|(
name|i
argument_list|)
operator|->
name|isComplete
argument_list|()
condition|)
return|return
name|false
return|;
return|return
name|true
return|;
block|}
name|bool
name|allInComplete
argument_list|()
specifier|const
block|{
for|for
control|(
name|unsigned
name|i
init|=
literal|0
init|;
name|i
operator|!=
name|getNumBits
argument_list|()
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|getBit
argument_list|(
name|i
argument_list|)
operator|->
name|isComplete
argument_list|()
condition|)
return|return
name|false
return|;
return|return
name|true
return|;
block|}
name|std
operator|::
name|string
name|getAsString
argument_list|()
specifier|const
name|override
block|;
comment|/// This method is used to implement
comment|/// VarListElementInit::resolveReferences.  If the list element is resolvable
comment|/// now, we return the resolved value, otherwise we return null.
name|Init
operator|*
name|resolveListElementReference
argument_list|(
argument|Record&R
argument_list|,
argument|const RecordVal *RV
argument_list|,
argument|unsigned Elt
argument_list|)
specifier|const
name|override
block|{
name|llvm_unreachable
argument_list|(
literal|"Illegal element reference off bits<n>"
argument_list|)
block|;   }
name|Init
operator|*
name|resolveReferences
argument_list|(
argument|Record&R
argument_list|,
argument|const RecordVal *RV
argument_list|)
specifier|const
name|override
block|;
name|Init
operator|*
name|getBit
argument_list|(
argument|unsigned Bit
argument_list|)
specifier|const
name|override
block|{
name|assert
argument_list|(
name|Bit
operator|<
name|NumBits
operator|&&
literal|"Bit index out of range!"
argument_list|)
block|;
return|return
name|getTrailingObjects
operator|<
name|Init
operator|*
operator|>
operator|(
operator|)
index|[
name|Bit
index|]
return|;
block|}
expr|}
block|;
comment|/// '7' - Represent an initialization by a literal integer value.
comment|///
name|class
name|IntInit
operator|:
name|public
name|TypedInit
block|{
name|int64_t
name|Value
block|;
name|explicit
name|IntInit
argument_list|(
argument|int64_t V
argument_list|)
operator|:
name|TypedInit
argument_list|(
name|IK_IntInit
argument_list|,
name|IntRecTy
operator|::
name|get
argument_list|()
argument_list|)
block|,
name|Value
argument_list|(
argument|V
argument_list|)
block|{}
name|public
operator|:
name|IntInit
argument_list|(
specifier|const
name|IntInit
operator|&
name|Other
argument_list|)
operator|=
name|delete
block|;
name|IntInit
operator|&
name|operator
operator|=
operator|(
specifier|const
name|IntInit
operator|&
name|Other
operator|)
operator|=
name|delete
block|;
specifier|static
name|bool
name|classof
argument_list|(
argument|const Init *I
argument_list|)
block|{
return|return
name|I
operator|->
name|getKind
argument_list|()
operator|==
name|IK_IntInit
return|;
block|}
specifier|static
name|IntInit
operator|*
name|get
argument_list|(
argument|int64_t V
argument_list|)
block|;
name|int64_t
name|getValue
argument_list|()
specifier|const
block|{
return|return
name|Value
return|;
block|}
name|Init
operator|*
name|convertInitializerTo
argument_list|(
argument|RecTy *Ty
argument_list|)
specifier|const
name|override
block|;
name|Init
operator|*
name|convertInitializerBitRange
argument_list|(
argument|ArrayRef<unsigned> Bits
argument_list|)
specifier|const
name|override
block|;
name|std
operator|::
name|string
name|getAsString
argument_list|()
specifier|const
name|override
block|;
comment|/// This method is used to implement
comment|/// VarListElementInit::resolveReferences.  If the list element is resolvable
comment|/// now, we return the resolved value, otherwise we return null.
name|Init
operator|*
name|resolveListElementReference
argument_list|(
argument|Record&R
argument_list|,
argument|const RecordVal *RV
argument_list|,
argument|unsigned Elt
argument_list|)
specifier|const
name|override
block|{
name|llvm_unreachable
argument_list|(
literal|"Illegal element reference off int"
argument_list|)
block|;   }
name|Init
operator|*
name|getBit
argument_list|(
argument|unsigned Bit
argument_list|)
specifier|const
name|override
block|{
return|return
name|BitInit
operator|::
name|get
argument_list|(
operator|(
name|Value
operator|&
operator|(
literal|1ULL
operator|<<
name|Bit
operator|)
operator|)
operator|!=
literal|0
argument_list|)
return|;
block|}
expr|}
block|;
comment|/// "foo" - Represent an initialization by a string value.
comment|///
name|class
name|StringInit
operator|:
name|public
name|TypedInit
block|{
name|StringRef
name|Value
block|;
name|explicit
name|StringInit
argument_list|(
argument|StringRef V
argument_list|)
operator|:
name|TypedInit
argument_list|(
name|IK_StringInit
argument_list|,
name|StringRecTy
operator|::
name|get
argument_list|()
argument_list|)
block|,
name|Value
argument_list|(
argument|V
argument_list|)
block|{}
name|public
operator|:
name|StringInit
argument_list|(
specifier|const
name|StringInit
operator|&
name|Other
argument_list|)
operator|=
name|delete
block|;
name|StringInit
operator|&
name|operator
operator|=
operator|(
specifier|const
name|StringInit
operator|&
name|Other
operator|)
operator|=
name|delete
block|;
specifier|static
name|bool
name|classof
argument_list|(
argument|const Init *I
argument_list|)
block|{
return|return
name|I
operator|->
name|getKind
argument_list|()
operator|==
name|IK_StringInit
return|;
block|}
specifier|static
name|StringInit
operator|*
name|get
argument_list|(
name|StringRef
argument_list|)
block|;
name|StringRef
name|getValue
argument_list|()
specifier|const
block|{
return|return
name|Value
return|;
block|}
name|Init
operator|*
name|convertInitializerTo
argument_list|(
argument|RecTy *Ty
argument_list|)
specifier|const
name|override
block|;
name|std
operator|::
name|string
name|getAsString
argument_list|()
specifier|const
name|override
block|{
return|return
literal|"\""
operator|+
name|Value
operator|.
name|str
argument_list|()
operator|+
literal|"\""
return|;
block|}
name|std
operator|::
name|string
name|getAsUnquotedString
argument_list|()
specifier|const
name|override
block|{
return|return
name|Value
return|;
block|}
comment|/// resolveListElementReference - This method is used to implement
comment|/// VarListElementInit::resolveReferences.  If the list element is resolvable
comment|/// now, we return the resolved value, otherwise we return null.
name|Init
operator|*
name|resolveListElementReference
argument_list|(
argument|Record&R
argument_list|,
argument|const RecordVal *RV
argument_list|,
argument|unsigned Elt
argument_list|)
specifier|const
name|override
block|{
name|llvm_unreachable
argument_list|(
literal|"Illegal element reference off string"
argument_list|)
block|;   }
name|Init
operator|*
name|getBit
argument_list|(
argument|unsigned Bit
argument_list|)
specifier|const
name|override
block|{
name|llvm_unreachable
argument_list|(
literal|"Illegal bit reference off string"
argument_list|)
block|;   }
expr|}
block|;
name|class
name|CodeInit
operator|:
name|public
name|TypedInit
block|{
name|StringRef
name|Value
block|;
name|explicit
name|CodeInit
argument_list|(
argument|StringRef V
argument_list|)
operator|:
name|TypedInit
argument_list|(
name|IK_CodeInit
argument_list|,
name|static_cast
operator|<
name|RecTy
operator|*
operator|>
operator|(
name|CodeRecTy
operator|::
name|get
argument_list|()
operator|)
argument_list|)
block|,
name|Value
argument_list|(
argument|V
argument_list|)
block|{}
name|public
operator|:
name|CodeInit
argument_list|(
specifier|const
name|StringInit
operator|&
name|Other
argument_list|)
operator|=
name|delete
block|;
name|CodeInit
operator|&
name|operator
operator|=
operator|(
specifier|const
name|StringInit
operator|&
name|Other
operator|)
operator|=
name|delete
block|;
specifier|static
name|bool
name|classof
argument_list|(
argument|const Init *I
argument_list|)
block|{
return|return
name|I
operator|->
name|getKind
argument_list|()
operator|==
name|IK_CodeInit
return|;
block|}
specifier|static
name|CodeInit
operator|*
name|get
argument_list|(
name|StringRef
argument_list|)
block|;
name|StringRef
name|getValue
argument_list|()
specifier|const
block|{
return|return
name|Value
return|;
block|}
name|Init
operator|*
name|convertInitializerTo
argument_list|(
argument|RecTy *Ty
argument_list|)
specifier|const
name|override
block|;
name|std
operator|::
name|string
name|getAsString
argument_list|()
specifier|const
name|override
block|{
return|return
literal|"[{"
operator|+
name|Value
operator|.
name|str
argument_list|()
operator|+
literal|"}]"
return|;
block|}
name|std
operator|::
name|string
name|getAsUnquotedString
argument_list|()
specifier|const
name|override
block|{
return|return
name|Value
return|;
block|}
comment|/// This method is used to implement
comment|/// VarListElementInit::resolveReferences.  If the list element is resolvable
comment|/// now, we return the resolved value, otherwise we return null.
name|Init
operator|*
name|resolveListElementReference
argument_list|(
argument|Record&R
argument_list|,
argument|const RecordVal *RV
argument_list|,
argument|unsigned Elt
argument_list|)
specifier|const
name|override
block|{
name|llvm_unreachable
argument_list|(
literal|"Illegal element reference off string"
argument_list|)
block|;   }
name|Init
operator|*
name|getBit
argument_list|(
argument|unsigned Bit
argument_list|)
specifier|const
name|override
block|{
name|llvm_unreachable
argument_list|(
literal|"Illegal bit reference off string"
argument_list|)
block|;   }
expr|}
block|;
comment|/// [AL, AH, CL] - Represent a list of defs
comment|///
name|class
name|ListInit
name|final
operator|:
name|public
name|TypedInit
block|,
name|public
name|FoldingSetNode
block|,
name|public
name|TrailingObjects
operator|<
name|ListInit
block|,
name|Init
operator|*
operator|>
block|{
name|unsigned
name|NumValues
block|;
name|public
operator|:
typedef|typedef
name|Init
modifier|*
specifier|const
modifier|*
name|const_iterator
typedef|;
name|private
operator|:
name|explicit
name|ListInit
argument_list|(
argument|unsigned N
argument_list|,
argument|RecTy *EltTy
argument_list|)
operator|:
name|TypedInit
argument_list|(
name|IK_ListInit
argument_list|,
name|ListRecTy
operator|::
name|get
argument_list|(
name|EltTy
argument_list|)
argument_list|)
block|,
name|NumValues
argument_list|(
argument|N
argument_list|)
block|{}
name|public
operator|:
name|ListInit
argument_list|(
specifier|const
name|ListInit
operator|&
name|Other
argument_list|)
operator|=
name|delete
block|;
name|ListInit
operator|&
name|operator
operator|=
operator|(
specifier|const
name|ListInit
operator|&
name|Other
operator|)
operator|=
name|delete
block|;
comment|// Do not use sized deallocation due to trailing objects.
name|void
name|operator
name|delete
argument_list|(
argument|void *p
argument_list|)
block|{
operator|::
name|operator
name|delete
argument_list|(
name|p
argument_list|)
block|; }
specifier|static
name|bool
name|classof
argument_list|(
argument|const Init *I
argument_list|)
block|{
return|return
name|I
operator|->
name|getKind
argument_list|()
operator|==
name|IK_ListInit
return|;
block|}
specifier|static
name|ListInit
operator|*
name|get
argument_list|(
name|ArrayRef
operator|<
name|Init
operator|*
operator|>
name|Range
argument_list|,
name|RecTy
operator|*
name|EltTy
argument_list|)
block|;
name|void
name|Profile
argument_list|(
argument|FoldingSetNodeID&ID
argument_list|)
specifier|const
block|;
name|Init
operator|*
name|getElement
argument_list|(
argument|unsigned i
argument_list|)
specifier|const
block|{
name|assert
argument_list|(
name|i
operator|<
name|NumValues
operator|&&
literal|"List element index out of range!"
argument_list|)
block|;
return|return
name|getTrailingObjects
operator|<
name|Init
operator|*
operator|>
operator|(
operator|)
index|[
name|i
index|]
return|;
block|}
name|Record
operator|*
name|getElementAsRecord
argument_list|(
argument|unsigned i
argument_list|)
specifier|const
block|;
name|Init
operator|*
name|convertInitListSlice
argument_list|(
argument|ArrayRef<unsigned> Elements
argument_list|)
specifier|const
name|override
block|;
name|Init
operator|*
name|convertInitializerTo
argument_list|(
argument|RecTy *Ty
argument_list|)
specifier|const
name|override
block|;
comment|/// This method is used by classes that refer to other
comment|/// variables which may not be defined at the time they expression is formed.
comment|/// If a value is set for the variable later, this method will be called on
comment|/// users of the value to allow the value to propagate out.
comment|///
name|Init
operator|*
name|resolveReferences
argument_list|(
argument|Record&R
argument_list|,
argument|const RecordVal *RV
argument_list|)
specifier|const
name|override
block|;
name|std
operator|::
name|string
name|getAsString
argument_list|()
specifier|const
name|override
block|;
name|ArrayRef
operator|<
name|Init
operator|*
operator|>
name|getValues
argument_list|()
specifier|const
block|{
return|return
name|makeArrayRef
argument_list|(
name|getTrailingObjects
operator|<
name|Init
operator|*
operator|>
operator|(
operator|)
argument_list|,
name|NumValues
argument_list|)
return|;
block|}
name|const_iterator
name|begin
argument_list|()
specifier|const
block|{
return|return
name|getTrailingObjects
operator|<
name|Init
operator|*
operator|>
operator|(
operator|)
return|;
block|}
name|const_iterator
name|end
argument_list|()
specifier|const
block|{
return|return
name|begin
argument_list|()
operator|+
name|NumValues
return|;
block|}
name|size_t
name|size
argument_list|()
specifier|const
block|{
return|return
name|NumValues
return|;
block|}
name|bool
name|empty
argument_list|()
specifier|const
block|{
return|return
name|NumValues
operator|==
literal|0
return|;
block|}
comment|/// This method is used to implement
comment|/// VarListElementInit::resolveReferences.  If the list element is resolvable
comment|/// now, we return the resolved value, otherwise we return null.
name|Init
operator|*
name|resolveListElementReference
argument_list|(
argument|Record&R
argument_list|,
argument|const RecordVal *RV
argument_list|,
argument|unsigned Elt
argument_list|)
specifier|const
name|override
block|;
name|Init
operator|*
name|getBit
argument_list|(
argument|unsigned Bit
argument_list|)
specifier|const
name|override
block|{
name|llvm_unreachable
argument_list|(
literal|"Illegal bit reference off list"
argument_list|)
block|;   }
block|}
block|;
comment|/// Base class for operators
comment|///
name|class
name|OpInit
operator|:
name|public
name|TypedInit
block|{
name|protected
operator|:
name|explicit
name|OpInit
argument_list|(
argument|InitKind K
argument_list|,
argument|RecTy *Type
argument_list|,
argument|uint8_t Opc
argument_list|)
operator|:
name|TypedInit
argument_list|(
argument|K
argument_list|,
argument|Type
argument_list|,
argument|Opc
argument_list|)
block|{}
name|public
operator|:
name|OpInit
argument_list|(
specifier|const
name|OpInit
operator|&
name|Other
argument_list|)
operator|=
name|delete
block|;
name|OpInit
operator|&
name|operator
operator|=
operator|(
name|OpInit
operator|&
name|Other
operator|)
operator|=
name|delete
block|;
specifier|static
name|bool
name|classof
argument_list|(
argument|const Init *I
argument_list|)
block|{
return|return
name|I
operator|->
name|getKind
argument_list|()
operator|>=
name|IK_FirstOpInit
operator|&&
name|I
operator|->
name|getKind
argument_list|()
operator|<=
name|IK_LastOpInit
return|;
block|}
comment|// Clone - Clone this operator, replacing arguments with the new list
name|virtual
name|OpInit
operator|*
name|clone
argument_list|(
argument|ArrayRef<Init *> Operands
argument_list|)
specifier|const
operator|=
literal|0
block|;
name|virtual
name|unsigned
name|getNumOperands
argument_list|()
specifier|const
operator|=
literal|0
block|;
name|virtual
name|Init
operator|*
name|getOperand
argument_list|(
argument|unsigned i
argument_list|)
specifier|const
operator|=
literal|0
block|;
comment|// Fold - If possible, fold this to a simpler init.  Return this if not
comment|// possible to fold.
name|virtual
name|Init
operator|*
name|Fold
argument_list|(
argument|Record *CurRec
argument_list|,
argument|MultiClass *CurMultiClass
argument_list|)
specifier|const
operator|=
literal|0
block|;
name|Init
operator|*
name|resolveListElementReference
argument_list|(
argument|Record&R
argument_list|,
argument|const RecordVal *RV
argument_list|,
argument|unsigned Elt
argument_list|)
specifier|const
name|override
block|;
name|Init
operator|*
name|getBit
argument_list|(
argument|unsigned Bit
argument_list|)
specifier|const
name|override
block|; }
block|;
comment|/// !op (X) - Transform an init.
comment|///
name|class
name|UnOpInit
operator|:
name|public
name|OpInit
block|,
name|public
name|FoldingSetNode
block|{
name|public
operator|:
expr|enum
name|UnaryOp
operator|:
name|uint8_t
block|{
name|CAST
block|,
name|HEAD
block|,
name|TAIL
block|,
name|EMPTY
block|}
block|;
name|private
operator|:
name|Init
operator|*
name|LHS
block|;
name|UnOpInit
argument_list|(
argument|UnaryOp opc
argument_list|,
argument|Init *lhs
argument_list|,
argument|RecTy *Type
argument_list|)
operator|:
name|OpInit
argument_list|(
name|IK_UnOpInit
argument_list|,
name|Type
argument_list|,
name|opc
argument_list|)
block|,
name|LHS
argument_list|(
argument|lhs
argument_list|)
block|{}
name|public
operator|:
name|UnOpInit
argument_list|(
specifier|const
name|UnOpInit
operator|&
name|Other
argument_list|)
operator|=
name|delete
block|;
name|UnOpInit
operator|&
name|operator
operator|=
operator|(
specifier|const
name|UnOpInit
operator|&
name|Other
operator|)
operator|=
name|delete
block|;
specifier|static
name|bool
name|classof
argument_list|(
argument|const Init *I
argument_list|)
block|{
return|return
name|I
operator|->
name|getKind
argument_list|()
operator|==
name|IK_UnOpInit
return|;
block|}
specifier|static
name|UnOpInit
operator|*
name|get
argument_list|(
argument|UnaryOp opc
argument_list|,
argument|Init *lhs
argument_list|,
argument|RecTy *Type
argument_list|)
block|;
name|void
name|Profile
argument_list|(
argument|FoldingSetNodeID&ID
argument_list|)
specifier|const
block|;
comment|// Clone - Clone this operator, replacing arguments with the new list
name|OpInit
operator|*
name|clone
argument_list|(
argument|ArrayRef<Init *> Operands
argument_list|)
specifier|const
name|override
block|{
name|assert
argument_list|(
name|Operands
operator|.
name|size
argument_list|()
operator|==
literal|1
operator|&&
literal|"Wrong number of operands for unary operation"
argument_list|)
block|;
return|return
name|UnOpInit
operator|::
name|get
argument_list|(
name|getOpcode
argument_list|()
argument_list|,
operator|*
name|Operands
operator|.
name|begin
argument_list|()
argument_list|,
name|getType
argument_list|()
argument_list|)
return|;
block|}
name|unsigned
name|getNumOperands
argument_list|()
specifier|const
name|override
block|{
return|return
literal|1
return|;
block|}
name|Init
operator|*
name|getOperand
argument_list|(
argument|unsigned i
argument_list|)
specifier|const
name|override
block|{
name|assert
argument_list|(
name|i
operator|==
literal|0
operator|&&
literal|"Invalid operand id for unary operator"
argument_list|)
block|;
return|return
name|getOperand
argument_list|()
return|;
block|}
name|UnaryOp
name|getOpcode
argument_list|()
specifier|const
block|{
return|return
operator|(
name|UnaryOp
operator|)
name|Opc
return|;
block|}
name|Init
operator|*
name|getOperand
argument_list|()
specifier|const
block|{
return|return
name|LHS
return|;
block|}
comment|// Fold - If possible, fold this to a simpler init.  Return this if not
comment|// possible to fold.
name|Init
operator|*
name|Fold
argument_list|(
argument|Record *CurRec
argument_list|,
argument|MultiClass *CurMultiClass
argument_list|)
specifier|const
name|override
block|;
name|Init
operator|*
name|resolveReferences
argument_list|(
argument|Record&R
argument_list|,
argument|const RecordVal *RV
argument_list|)
specifier|const
name|override
block|;
name|std
operator|::
name|string
name|getAsString
argument_list|()
specifier|const
name|override
block|; }
block|;
comment|/// !op (X, Y) - Combine two inits.
comment|///
name|class
name|BinOpInit
operator|:
name|public
name|OpInit
block|,
name|public
name|FoldingSetNode
block|{
name|public
operator|:
expr|enum
name|BinaryOp
operator|:
name|uint8_t
block|{
name|ADD
block|,
name|AND
block|,
name|OR
block|,
name|SHL
block|,
name|SRA
block|,
name|SRL
block|,
name|LISTCONCAT
block|,
name|STRCONCAT
block|,
name|CONCAT
block|,
name|EQ
block|}
block|;
name|private
operator|:
name|Init
operator|*
name|LHS
block|,
operator|*
name|RHS
block|;
name|BinOpInit
argument_list|(
argument|BinaryOp opc
argument_list|,
argument|Init *lhs
argument_list|,
argument|Init *rhs
argument_list|,
argument|RecTy *Type
argument_list|)
operator|:
name|OpInit
argument_list|(
name|IK_BinOpInit
argument_list|,
name|Type
argument_list|,
name|opc
argument_list|)
block|,
name|LHS
argument_list|(
name|lhs
argument_list|)
block|,
name|RHS
argument_list|(
argument|rhs
argument_list|)
block|{}
name|public
operator|:
name|BinOpInit
argument_list|(
specifier|const
name|BinOpInit
operator|&
name|Other
argument_list|)
operator|=
name|delete
block|;
name|BinOpInit
operator|&
name|operator
operator|=
operator|(
specifier|const
name|BinOpInit
operator|&
name|Other
operator|)
operator|=
name|delete
block|;
specifier|static
name|bool
name|classof
argument_list|(
argument|const Init *I
argument_list|)
block|{
return|return
name|I
operator|->
name|getKind
argument_list|()
operator|==
name|IK_BinOpInit
return|;
block|}
specifier|static
name|BinOpInit
operator|*
name|get
argument_list|(
argument|BinaryOp opc
argument_list|,
argument|Init *lhs
argument_list|,
argument|Init *rhs
argument_list|,
argument|RecTy *Type
argument_list|)
block|;
name|void
name|Profile
argument_list|(
argument|FoldingSetNodeID&ID
argument_list|)
specifier|const
block|;
comment|// Clone - Clone this operator, replacing arguments with the new list
name|OpInit
operator|*
name|clone
argument_list|(
argument|ArrayRef<Init *> Operands
argument_list|)
specifier|const
name|override
block|{
name|assert
argument_list|(
name|Operands
operator|.
name|size
argument_list|()
operator|==
literal|2
operator|&&
literal|"Wrong number of operands for binary operation"
argument_list|)
block|;
return|return
name|BinOpInit
operator|::
name|get
argument_list|(
name|getOpcode
argument_list|()
argument_list|,
name|Operands
index|[
literal|0
index|]
argument_list|,
name|Operands
index|[
literal|1
index|]
argument_list|,
name|getType
argument_list|()
argument_list|)
return|;
block|}
name|unsigned
name|getNumOperands
argument_list|()
specifier|const
name|override
block|{
return|return
literal|2
return|;
block|}
name|Init
operator|*
name|getOperand
argument_list|(
argument|unsigned i
argument_list|)
specifier|const
name|override
block|{
switch|switch
condition|(
name|i
condition|)
block|{
default|default:
name|llvm_unreachable
argument_list|(
literal|"Invalid operand id for binary operator"
argument_list|)
expr_stmt|;
case|case
literal|0
case|:
return|return
name|getLHS
argument_list|()
return|;
case|case
literal|1
case|:
return|return
name|getRHS
argument_list|()
return|;
block|}
block|}
name|BinaryOp
name|getOpcode
argument_list|()
specifier|const
block|{
return|return
operator|(
name|BinaryOp
operator|)
name|Opc
return|;
block|}
name|Init
operator|*
name|getLHS
argument_list|()
specifier|const
block|{
return|return
name|LHS
return|;
block|}
name|Init
operator|*
name|getRHS
argument_list|()
specifier|const
block|{
return|return
name|RHS
return|;
block|}
comment|// Fold - If possible, fold this to a simpler init.  Return this if not
comment|// possible to fold.
name|Init
operator|*
name|Fold
argument_list|(
argument|Record *CurRec
argument_list|,
argument|MultiClass *CurMultiClass
argument_list|)
specifier|const
name|override
block|;
name|Init
operator|*
name|resolveReferences
argument_list|(
argument|Record&R
argument_list|,
argument|const RecordVal *RV
argument_list|)
specifier|const
name|override
block|;
name|std
operator|::
name|string
name|getAsString
argument_list|()
specifier|const
name|override
block|; }
block|;
comment|/// !op (X, Y, Z) - Combine two inits.
comment|///
name|class
name|TernOpInit
operator|:
name|public
name|OpInit
block|,
name|public
name|FoldingSetNode
block|{
name|public
operator|:
expr|enum
name|TernaryOp
operator|:
name|uint8_t
block|{
name|SUBST
block|,
name|FOREACH
block|,
name|IF
block|}
block|;
name|private
operator|:
name|Init
operator|*
name|LHS
block|,
operator|*
name|MHS
block|,
operator|*
name|RHS
block|;
name|TernOpInit
argument_list|(
argument|TernaryOp opc
argument_list|,
argument|Init *lhs
argument_list|,
argument|Init *mhs
argument_list|,
argument|Init *rhs
argument_list|,
argument|RecTy *Type
argument_list|)
operator|:
name|OpInit
argument_list|(
name|IK_TernOpInit
argument_list|,
name|Type
argument_list|,
name|opc
argument_list|)
block|,
name|LHS
argument_list|(
name|lhs
argument_list|)
block|,
name|MHS
argument_list|(
name|mhs
argument_list|)
block|,
name|RHS
argument_list|(
argument|rhs
argument_list|)
block|{}
name|public
operator|:
name|TernOpInit
argument_list|(
specifier|const
name|TernOpInit
operator|&
name|Other
argument_list|)
operator|=
name|delete
block|;
name|TernOpInit
operator|&
name|operator
operator|=
operator|(
specifier|const
name|TernOpInit
operator|&
name|Other
operator|)
operator|=
name|delete
block|;
specifier|static
name|bool
name|classof
argument_list|(
argument|const Init *I
argument_list|)
block|{
return|return
name|I
operator|->
name|getKind
argument_list|()
operator|==
name|IK_TernOpInit
return|;
block|}
specifier|static
name|TernOpInit
operator|*
name|get
argument_list|(
argument|TernaryOp opc
argument_list|,
argument|Init *lhs
argument_list|,
argument|Init *mhs
argument_list|,
argument|Init *rhs
argument_list|,
argument|RecTy *Type
argument_list|)
block|;
name|void
name|Profile
argument_list|(
argument|FoldingSetNodeID&ID
argument_list|)
specifier|const
block|;
comment|// Clone - Clone this operator, replacing arguments with the new list
name|OpInit
operator|*
name|clone
argument_list|(
argument|ArrayRef<Init *> Operands
argument_list|)
specifier|const
name|override
block|{
name|assert
argument_list|(
name|Operands
operator|.
name|size
argument_list|()
operator|==
literal|3
operator|&&
literal|"Wrong number of operands for ternary operation"
argument_list|)
block|;
return|return
name|TernOpInit
operator|::
name|get
argument_list|(
name|getOpcode
argument_list|()
argument_list|,
name|Operands
index|[
literal|0
index|]
argument_list|,
name|Operands
index|[
literal|1
index|]
argument_list|,
name|Operands
index|[
literal|2
index|]
argument_list|,
name|getType
argument_list|()
argument_list|)
return|;
block|}
name|unsigned
name|getNumOperands
argument_list|()
specifier|const
name|override
block|{
return|return
literal|3
return|;
block|}
name|Init
operator|*
name|getOperand
argument_list|(
argument|unsigned i
argument_list|)
specifier|const
name|override
block|{
switch|switch
condition|(
name|i
condition|)
block|{
default|default:
name|llvm_unreachable
argument_list|(
literal|"Invalid operand id for ternary operator"
argument_list|)
expr_stmt|;
case|case
literal|0
case|:
return|return
name|getLHS
argument_list|()
return|;
case|case
literal|1
case|:
return|return
name|getMHS
argument_list|()
return|;
case|case
literal|2
case|:
return|return
name|getRHS
argument_list|()
return|;
block|}
block|}
name|TernaryOp
name|getOpcode
argument_list|()
specifier|const
block|{
return|return
operator|(
name|TernaryOp
operator|)
name|Opc
return|;
block|}
name|Init
operator|*
name|getLHS
argument_list|()
specifier|const
block|{
return|return
name|LHS
return|;
block|}
name|Init
operator|*
name|getMHS
argument_list|()
specifier|const
block|{
return|return
name|MHS
return|;
block|}
name|Init
operator|*
name|getRHS
argument_list|()
specifier|const
block|{
return|return
name|RHS
return|;
block|}
comment|// Fold - If possible, fold this to a simpler init.  Return this if not
comment|// possible to fold.
name|Init
operator|*
name|Fold
argument_list|(
argument|Record *CurRec
argument_list|,
argument|MultiClass *CurMultiClass
argument_list|)
specifier|const
name|override
block|;
name|bool
name|isComplete
argument_list|()
specifier|const
name|override
block|{
return|return
name|false
return|;
block|}
name|Init
operator|*
name|resolveReferences
argument_list|(
argument|Record&R
argument_list|,
argument|const RecordVal *RV
argument_list|)
specifier|const
name|override
block|;
name|std
operator|::
name|string
name|getAsString
argument_list|()
specifier|const
name|override
block|; }
block|;
comment|/// 'Opcode' - Represent a reference to an entire variable object.
comment|///
name|class
name|VarInit
operator|:
name|public
name|TypedInit
block|{
name|Init
operator|*
name|VarName
block|;
name|explicit
name|VarInit
argument_list|(
name|Init
operator|*
name|VN
argument_list|,
name|RecTy
operator|*
name|T
argument_list|)
operator|:
name|TypedInit
argument_list|(
name|IK_VarInit
argument_list|,
name|T
argument_list|)
block|,
name|VarName
argument_list|(
argument|VN
argument_list|)
block|{}
name|public
operator|:
name|VarInit
argument_list|(
specifier|const
name|VarInit
operator|&
name|Other
argument_list|)
operator|=
name|delete
block|;
name|VarInit
operator|&
name|operator
operator|=
operator|(
specifier|const
name|VarInit
operator|&
name|Other
operator|)
operator|=
name|delete
block|;
specifier|static
name|bool
name|classof
argument_list|(
argument|const Init *I
argument_list|)
block|{
return|return
name|I
operator|->
name|getKind
argument_list|()
operator|==
name|IK_VarInit
return|;
block|}
specifier|static
name|VarInit
operator|*
name|get
argument_list|(
argument|StringRef VN
argument_list|,
argument|RecTy *T
argument_list|)
block|;
specifier|static
name|VarInit
operator|*
name|get
argument_list|(
name|Init
operator|*
name|VN
argument_list|,
name|RecTy
operator|*
name|T
argument_list|)
block|;
name|StringRef
name|getName
argument_list|()
specifier|const
block|;
name|Init
operator|*
name|getNameInit
argument_list|()
specifier|const
block|{
return|return
name|VarName
return|;
block|}
name|std
operator|::
name|string
name|getNameInitAsString
argument_list|()
specifier|const
block|{
return|return
name|getNameInit
argument_list|()
operator|->
name|getAsUnquotedString
argument_list|()
return|;
block|}
name|Init
operator|*
name|resolveListElementReference
argument_list|(
argument|Record&R
argument_list|,
argument|const RecordVal *RV
argument_list|,
argument|unsigned Elt
argument_list|)
specifier|const
name|override
block|;
name|RecTy
operator|*
name|getFieldType
argument_list|(
argument|StringInit *FieldName
argument_list|)
specifier|const
name|override
block|;
name|Init
operator|*
name|getFieldInit
argument_list|(
argument|Record&R
argument_list|,
argument|const RecordVal *RV
argument_list|,
argument|StringInit *FieldName
argument_list|)
specifier|const
name|override
block|;
comment|/// This method is used by classes that refer to other
comment|/// variables which may not be defined at the time they expression is formed.
comment|/// If a value is set for the variable later, this method will be called on
comment|/// users of the value to allow the value to propagate out.
comment|///
name|Init
operator|*
name|resolveReferences
argument_list|(
argument|Record&R
argument_list|,
argument|const RecordVal *RV
argument_list|)
specifier|const
name|override
block|;
name|Init
operator|*
name|getBit
argument_list|(
argument|unsigned Bit
argument_list|)
specifier|const
name|override
block|;
name|std
operator|::
name|string
name|getAsString
argument_list|()
specifier|const
name|override
block|{
return|return
name|getName
argument_list|()
return|;
block|}
expr|}
block|;
comment|/// Opcode{0} - Represent access to one bit of a variable or field.
comment|///
name|class
name|VarBitInit
operator|:
name|public
name|Init
block|{
name|TypedInit
operator|*
name|TI
block|;
name|unsigned
name|Bit
block|;
name|VarBitInit
argument_list|(
argument|TypedInit *T
argument_list|,
argument|unsigned B
argument_list|)
operator|:
name|Init
argument_list|(
name|IK_VarBitInit
argument_list|)
block|,
name|TI
argument_list|(
name|T
argument_list|)
block|,
name|Bit
argument_list|(
argument|B
argument_list|)
block|{
name|assert
argument_list|(
name|T
operator|->
name|getType
argument_list|()
operator|&&
operator|(
name|isa
operator|<
name|IntRecTy
operator|>
operator|(
name|T
operator|->
name|getType
argument_list|()
operator|)
operator|||
operator|(
name|isa
operator|<
name|BitsRecTy
operator|>
operator|(
name|T
operator|->
name|getType
argument_list|()
operator|)
operator|&&
name|cast
operator|<
name|BitsRecTy
operator|>
operator|(
name|T
operator|->
name|getType
argument_list|()
operator|)
operator|->
name|getNumBits
argument_list|()
operator|>
name|B
operator|)
operator|)
operator|&&
literal|"Illegal VarBitInit expression!"
argument_list|)
block|;   }
name|public
operator|:
name|VarBitInit
argument_list|(
specifier|const
name|VarBitInit
operator|&
name|Other
argument_list|)
operator|=
name|delete
block|;
name|VarBitInit
operator|&
name|operator
operator|=
operator|(
specifier|const
name|VarBitInit
operator|&
name|Other
operator|)
operator|=
name|delete
block|;
specifier|static
name|bool
name|classof
argument_list|(
argument|const Init *I
argument_list|)
block|{
return|return
name|I
operator|->
name|getKind
argument_list|()
operator|==
name|IK_VarBitInit
return|;
block|}
specifier|static
name|VarBitInit
operator|*
name|get
argument_list|(
argument|TypedInit *T
argument_list|,
argument|unsigned B
argument_list|)
block|;
name|Init
operator|*
name|convertInitializerTo
argument_list|(
argument|RecTy *Ty
argument_list|)
specifier|const
name|override
block|;
name|Init
operator|*
name|getBitVar
argument_list|()
specifier|const
name|override
block|{
return|return
name|TI
return|;
block|}
name|unsigned
name|getBitNum
argument_list|()
specifier|const
name|override
block|{
return|return
name|Bit
return|;
block|}
name|std
operator|::
name|string
name|getAsString
argument_list|()
specifier|const
name|override
block|;
name|Init
operator|*
name|resolveReferences
argument_list|(
argument|Record&R
argument_list|,
argument|const RecordVal *RV
argument_list|)
specifier|const
name|override
block|;
name|Init
operator|*
name|getBit
argument_list|(
argument|unsigned B
argument_list|)
specifier|const
name|override
block|{
name|assert
argument_list|(
name|B
operator|<
literal|1
operator|&&
literal|"Bit index out of range!"
argument_list|)
block|;
return|return
name|const_cast
operator|<
name|VarBitInit
operator|*
operator|>
operator|(
name|this
operator|)
return|;
block|}
expr|}
block|;
comment|/// List[4] - Represent access to one element of a var or
comment|/// field.
name|class
name|VarListElementInit
operator|:
name|public
name|TypedInit
block|{
name|TypedInit
operator|*
name|TI
block|;
name|unsigned
name|Element
block|;
name|VarListElementInit
argument_list|(
argument|TypedInit *T
argument_list|,
argument|unsigned E
argument_list|)
operator|:
name|TypedInit
argument_list|(
name|IK_VarListElementInit
argument_list|,
name|cast
operator|<
name|ListRecTy
operator|>
operator|(
name|T
operator|->
name|getType
argument_list|()
operator|)
operator|->
name|getElementType
argument_list|()
argument_list|)
block|,
name|TI
argument_list|(
name|T
argument_list|)
block|,
name|Element
argument_list|(
argument|E
argument_list|)
block|{
name|assert
argument_list|(
name|T
operator|->
name|getType
argument_list|()
operator|&&
name|isa
operator|<
name|ListRecTy
operator|>
operator|(
name|T
operator|->
name|getType
argument_list|()
operator|)
operator|&&
literal|"Illegal VarBitInit expression!"
argument_list|)
block|;   }
name|public
operator|:
name|VarListElementInit
argument_list|(
specifier|const
name|VarListElementInit
operator|&
name|Other
argument_list|)
operator|=
name|delete
block|;
name|void
name|operator
operator|=
operator|(
specifier|const
name|VarListElementInit
operator|&
name|Other
operator|)
operator|=
name|delete
block|;
specifier|static
name|bool
name|classof
argument_list|(
argument|const Init *I
argument_list|)
block|{
return|return
name|I
operator|->
name|getKind
argument_list|()
operator|==
name|IK_VarListElementInit
return|;
block|}
specifier|static
name|VarListElementInit
operator|*
name|get
argument_list|(
argument|TypedInit *T
argument_list|,
argument|unsigned E
argument_list|)
block|;
name|TypedInit
operator|*
name|getVariable
argument_list|()
specifier|const
block|{
return|return
name|TI
return|;
block|}
name|unsigned
name|getElementNum
argument_list|()
specifier|const
block|{
return|return
name|Element
return|;
block|}
comment|/// This method is used to implement
comment|/// VarListElementInit::resolveReferences.  If the list element is resolvable
comment|/// now, we return the resolved value, otherwise we return null.
name|Init
operator|*
name|resolveListElementReference
argument_list|(
argument|Record&R
argument_list|,
argument|const RecordVal *RV
argument_list|,
argument|unsigned Elt
argument_list|)
specifier|const
name|override
block|;
name|std
operator|::
name|string
name|getAsString
argument_list|()
specifier|const
name|override
block|;
name|Init
operator|*
name|resolveReferences
argument_list|(
argument|Record&R
argument_list|,
argument|const RecordVal *RV
argument_list|)
specifier|const
name|override
block|;
name|Init
operator|*
name|getBit
argument_list|(
argument|unsigned Bit
argument_list|)
specifier|const
name|override
block|; }
block|;
comment|/// AL - Represent a reference to a 'def' in the description
comment|///
name|class
name|DefInit
operator|:
name|public
name|TypedInit
block|{
name|Record
operator|*
name|Def
block|;
name|DefInit
argument_list|(
name|Record
operator|*
name|D
argument_list|,
name|RecordRecTy
operator|*
name|T
argument_list|)
operator|:
name|TypedInit
argument_list|(
name|IK_DefInit
argument_list|,
name|T
argument_list|)
block|,
name|Def
argument_list|(
argument|D
argument_list|)
block|{}
name|friend
name|class
name|Record
block|;
name|public
operator|:
name|DefInit
argument_list|(
specifier|const
name|DefInit
operator|&
name|Other
argument_list|)
operator|=
name|delete
block|;
name|DefInit
operator|&
name|operator
operator|=
operator|(
specifier|const
name|DefInit
operator|&
name|Other
operator|)
operator|=
name|delete
block|;
specifier|static
name|bool
name|classof
argument_list|(
argument|const Init *I
argument_list|)
block|{
return|return
name|I
operator|->
name|getKind
argument_list|()
operator|==
name|IK_DefInit
return|;
block|}
specifier|static
name|DefInit
operator|*
name|get
argument_list|(
name|Record
operator|*
argument_list|)
block|;
name|Init
operator|*
name|convertInitializerTo
argument_list|(
argument|RecTy *Ty
argument_list|)
specifier|const
name|override
block|;
name|Record
operator|*
name|getDef
argument_list|()
specifier|const
block|{
return|return
name|Def
return|;
block|}
comment|//virtual Init *convertInitializerBitRange(ArrayRef<unsigned> Bits);
name|RecTy
operator|*
name|getFieldType
argument_list|(
argument|StringInit *FieldName
argument_list|)
specifier|const
name|override
block|;
name|Init
operator|*
name|getFieldInit
argument_list|(
argument|Record&R
argument_list|,
argument|const RecordVal *RV
argument_list|,
argument|StringInit *FieldName
argument_list|)
specifier|const
name|override
block|;
name|std
operator|::
name|string
name|getAsString
argument_list|()
specifier|const
name|override
block|;
name|Init
operator|*
name|getBit
argument_list|(
argument|unsigned Bit
argument_list|)
specifier|const
name|override
block|{
name|llvm_unreachable
argument_list|(
literal|"Illegal bit reference off def"
argument_list|)
block|;   }
comment|/// This method is used to implement
comment|/// VarListElementInit::resolveReferences.  If the list element is resolvable
comment|/// now, we return the resolved value, otherwise we return null.
name|Init
operator|*
name|resolveListElementReference
argument_list|(
argument|Record&R
argument_list|,
argument|const RecordVal *RV
argument_list|,
argument|unsigned Elt
argument_list|)
specifier|const
name|override
block|{
name|llvm_unreachable
argument_list|(
literal|"Illegal element reference off def"
argument_list|)
block|;   }
block|}
block|;
comment|/// X.Y - Represent a reference to a subfield of a variable
comment|///
name|class
name|FieldInit
operator|:
name|public
name|TypedInit
block|{
name|Init
operator|*
name|Rec
block|;
comment|// Record we are referring to
name|StringInit
operator|*
name|FieldName
block|;
comment|// Field we are accessing
name|FieldInit
argument_list|(
name|Init
operator|*
name|R
argument_list|,
name|StringInit
operator|*
name|FN
argument_list|)
operator|:
name|TypedInit
argument_list|(
name|IK_FieldInit
argument_list|,
name|R
operator|->
name|getFieldType
argument_list|(
name|FN
argument_list|)
argument_list|)
block|,
name|Rec
argument_list|(
name|R
argument_list|)
block|,
name|FieldName
argument_list|(
argument|FN
argument_list|)
block|{
name|assert
argument_list|(
name|getType
argument_list|()
operator|&&
literal|"FieldInit with non-record type!"
argument_list|)
block|;   }
name|public
operator|:
name|FieldInit
argument_list|(
specifier|const
name|FieldInit
operator|&
name|Other
argument_list|)
operator|=
name|delete
block|;
name|FieldInit
operator|&
name|operator
operator|=
operator|(
specifier|const
name|FieldInit
operator|&
name|Other
operator|)
operator|=
name|delete
block|;
specifier|static
name|bool
name|classof
argument_list|(
argument|const Init *I
argument_list|)
block|{
return|return
name|I
operator|->
name|getKind
argument_list|()
operator|==
name|IK_FieldInit
return|;
block|}
specifier|static
name|FieldInit
operator|*
name|get
argument_list|(
name|Init
operator|*
name|R
argument_list|,
name|StringInit
operator|*
name|FN
argument_list|)
block|;
name|Init
operator|*
name|getBit
argument_list|(
argument|unsigned Bit
argument_list|)
specifier|const
name|override
block|;
name|Init
operator|*
name|resolveListElementReference
argument_list|(
argument|Record&R
argument_list|,
argument|const RecordVal *RV
argument_list|,
argument|unsigned Elt
argument_list|)
specifier|const
name|override
block|;
name|Init
operator|*
name|resolveReferences
argument_list|(
argument|Record&R
argument_list|,
argument|const RecordVal *RV
argument_list|)
specifier|const
name|override
block|;
name|std
operator|::
name|string
name|getAsString
argument_list|()
specifier|const
name|override
block|{
return|return
name|Rec
operator|->
name|getAsString
argument_list|()
operator|+
literal|"."
operator|+
name|FieldName
operator|->
name|getValue
argument_list|()
operator|.
name|str
argument_list|()
return|;
block|}
expr|}
block|;
comment|/// (v a, b) - Represent a DAG tree value.  DAG inits are required
comment|/// to have at least one value then a (possibly empty) list of arguments.  Each
comment|/// argument can have a name associated with it.
comment|///
name|class
name|DagInit
name|final
operator|:
name|public
name|TypedInit
block|,
name|public
name|FoldingSetNode
block|,
name|public
name|TrailingObjects
operator|<
name|DagInit
block|,
name|Init
operator|*
block|,
name|StringInit
operator|*
operator|>
block|{
name|Init
operator|*
name|Val
block|;
name|StringInit
operator|*
name|ValName
block|;
name|unsigned
name|NumArgs
block|;
name|unsigned
name|NumArgNames
block|;
name|DagInit
argument_list|(
argument|Init *V
argument_list|,
argument|StringInit *VN
argument_list|,
argument|unsigned NumArgs
argument_list|,
argument|unsigned NumArgNames
argument_list|)
operator|:
name|TypedInit
argument_list|(
name|IK_DagInit
argument_list|,
name|DagRecTy
operator|::
name|get
argument_list|()
argument_list|)
block|,
name|Val
argument_list|(
name|V
argument_list|)
block|,
name|ValName
argument_list|(
name|VN
argument_list|)
block|,
name|NumArgs
argument_list|(
name|NumArgs
argument_list|)
block|,
name|NumArgNames
argument_list|(
argument|NumArgNames
argument_list|)
block|{}
name|friend
name|TrailingObjects
block|;
name|size_t
name|numTrailingObjects
argument_list|(
argument|OverloadToken<Init *>
argument_list|)
specifier|const
block|{
return|return
name|NumArgs
return|;
block|}
name|public
operator|:
name|DagInit
argument_list|(
specifier|const
name|DagInit
operator|&
name|Other
argument_list|)
operator|=
name|delete
block|;
name|DagInit
operator|&
name|operator
operator|=
operator|(
specifier|const
name|DagInit
operator|&
name|Other
operator|)
operator|=
name|delete
block|;
specifier|static
name|bool
name|classof
argument_list|(
argument|const Init *I
argument_list|)
block|{
return|return
name|I
operator|->
name|getKind
argument_list|()
operator|==
name|IK_DagInit
return|;
block|}
specifier|static
name|DagInit
operator|*
name|get
argument_list|(
name|Init
operator|*
name|V
argument_list|,
name|StringInit
operator|*
name|VN
argument_list|,
name|ArrayRef
operator|<
name|Init
operator|*
operator|>
name|ArgRange
argument_list|,
name|ArrayRef
operator|<
name|StringInit
operator|*
operator|>
name|NameRange
argument_list|)
block|;
specifier|static
name|DagInit
operator|*
name|get
argument_list|(
name|Init
operator|*
name|V
argument_list|,
name|StringInit
operator|*
name|VN
argument_list|,
name|ArrayRef
operator|<
name|std
operator|::
name|pair
operator|<
name|Init
operator|*
argument_list|,
name|StringInit
operator|*
operator|>>
name|Args
argument_list|)
block|;
name|void
name|Profile
argument_list|(
argument|FoldingSetNodeID&ID
argument_list|)
specifier|const
block|;
name|Init
operator|*
name|convertInitializerTo
argument_list|(
argument|RecTy *Ty
argument_list|)
specifier|const
name|override
block|;
name|Init
operator|*
name|getOperator
argument_list|()
specifier|const
block|{
return|return
name|Val
return|;
block|}
name|StringInit
operator|*
name|getName
argument_list|()
specifier|const
block|{
return|return
name|ValName
return|;
block|}
name|StringRef
name|getNameStr
argument_list|()
specifier|const
block|{
return|return
name|ValName
operator|?
name|ValName
operator|->
name|getValue
argument_list|()
operator|:
name|StringRef
argument_list|()
return|;
block|}
name|unsigned
name|getNumArgs
argument_list|()
specifier|const
block|{
return|return
name|NumArgs
return|;
block|}
name|Init
operator|*
name|getArg
argument_list|(
argument|unsigned Num
argument_list|)
specifier|const
block|{
name|assert
argument_list|(
name|Num
operator|<
name|NumArgs
operator|&&
literal|"Arg number out of range!"
argument_list|)
block|;
return|return
name|getTrailingObjects
operator|<
name|Init
operator|*
operator|>
operator|(
operator|)
index|[
name|Num
index|]
return|;
block|}
name|StringInit
operator|*
name|getArgName
argument_list|(
argument|unsigned Num
argument_list|)
specifier|const
block|{
name|assert
argument_list|(
name|Num
operator|<
name|NumArgNames
operator|&&
literal|"Arg number out of range!"
argument_list|)
block|;
return|return
name|getTrailingObjects
operator|<
name|StringInit
operator|*
operator|>
operator|(
operator|)
index|[
name|Num
index|]
return|;
block|}
name|StringRef
name|getArgNameStr
argument_list|(
argument|unsigned Num
argument_list|)
specifier|const
block|{
name|StringInit
operator|*
name|Init
operator|=
name|getArgName
argument_list|(
name|Num
argument_list|)
block|;
return|return
name|Init
condition|?
name|Init
operator|->
name|getValue
argument_list|()
else|:
name|StringRef
argument_list|()
return|;
block|}
name|ArrayRef
operator|<
name|Init
operator|*
operator|>
name|getArgs
argument_list|()
specifier|const
block|{
return|return
name|makeArrayRef
argument_list|(
name|getTrailingObjects
operator|<
name|Init
operator|*
operator|>
operator|(
operator|)
argument_list|,
name|NumArgs
argument_list|)
return|;
block|}
name|ArrayRef
operator|<
name|StringInit
operator|*
operator|>
name|getArgNames
argument_list|()
specifier|const
block|{
return|return
name|makeArrayRef
argument_list|(
name|getTrailingObjects
operator|<
name|StringInit
operator|*
operator|>
operator|(
operator|)
argument_list|,
name|NumArgNames
argument_list|)
return|;
block|}
name|Init
operator|*
name|resolveReferences
argument_list|(
argument|Record&R
argument_list|,
argument|const RecordVal *RV
argument_list|)
specifier|const
name|override
block|;
name|std
operator|::
name|string
name|getAsString
argument_list|()
specifier|const
name|override
block|;
typedef|typedef
name|SmallVectorImpl
operator|<
name|Init
operator|*
operator|>
operator|::
name|const_iterator
name|const_arg_iterator
expr_stmt|;
typedef|typedef
name|SmallVectorImpl
operator|<
name|StringInit
operator|*
operator|>
operator|::
name|const_iterator
name|const_name_iterator
expr_stmt|;
specifier|inline
name|const_arg_iterator
name|arg_begin
argument_list|()
specifier|const
block|{
return|return
name|getArgs
argument_list|()
operator|.
name|begin
argument_list|()
return|;
block|}
specifier|inline
name|const_arg_iterator
name|arg_end
argument_list|()
specifier|const
block|{
return|return
name|getArgs
argument_list|()
operator|.
name|end
argument_list|()
return|;
block|}
specifier|inline
name|size_t
name|arg_size
argument_list|()
specifier|const
block|{
return|return
name|NumArgs
return|;
block|}
specifier|inline
name|bool
name|arg_empty
argument_list|()
specifier|const
block|{
return|return
name|NumArgs
operator|==
literal|0
return|;
block|}
specifier|inline
name|const_name_iterator
name|name_begin
argument_list|()
specifier|const
block|{
return|return
name|getArgNames
argument_list|()
operator|.
name|begin
argument_list|()
return|;
block|}
specifier|inline
name|const_name_iterator
name|name_end
argument_list|()
specifier|const
block|{
return|return
name|getArgNames
argument_list|()
operator|.
name|end
argument_list|()
return|;
block|}
specifier|inline
name|size_t
name|name_size
argument_list|()
specifier|const
block|{
return|return
name|NumArgNames
return|;
block|}
specifier|inline
name|bool
name|name_empty
argument_list|()
specifier|const
block|{
return|return
name|NumArgNames
operator|==
literal|0
return|;
block|}
name|Init
operator|*
name|getBit
argument_list|(
argument|unsigned Bit
argument_list|)
specifier|const
name|override
block|{
name|llvm_unreachable
argument_list|(
literal|"Illegal bit reference off dag"
argument_list|)
block|;   }
name|Init
operator|*
name|resolveListElementReference
argument_list|(
argument|Record&R
argument_list|,
argument|const RecordVal *RV
argument_list|,
argument|unsigned Elt
argument_list|)
specifier|const
name|override
block|{
name|llvm_unreachable
argument_list|(
literal|"Illegal element reference off dag"
argument_list|)
block|;   }
expr|}
block|;
comment|//===----------------------------------------------------------------------===//
comment|//  High-Level Classes
comment|//===----------------------------------------------------------------------===//
name|class
name|RecordVal
block|{
name|friend
name|class
name|Record
block|;
name|Init
operator|*
name|Name
block|;
name|PointerIntPair
operator|<
name|RecTy
operator|*
block|,
literal|1
block|,
name|bool
operator|>
name|TyAndPrefix
block|;
name|Init
operator|*
name|Value
block|;
name|public
operator|:
name|RecordVal
argument_list|(
argument|Init *N
argument_list|,
argument|RecTy *T
argument_list|,
argument|bool P
argument_list|)
block|;
name|StringRef
name|getName
argument_list|()
specifier|const
block|;
name|Init
operator|*
name|getNameInit
argument_list|()
specifier|const
block|{
return|return
name|Name
return|;
block|}
name|std
operator|::
name|string
name|getNameInitAsString
argument_list|()
specifier|const
block|{
return|return
name|getNameInit
argument_list|()
operator|->
name|getAsUnquotedString
argument_list|()
return|;
block|}
name|bool
name|getPrefix
argument_list|()
specifier|const
block|{
return|return
name|TyAndPrefix
operator|.
name|getInt
argument_list|()
return|;
block|}
name|RecTy
operator|*
name|getType
argument_list|()
specifier|const
block|{
return|return
name|TyAndPrefix
operator|.
name|getPointer
argument_list|()
return|;
block|}
name|Init
operator|*
name|getValue
argument_list|()
specifier|const
block|{
return|return
name|Value
return|;
block|}
name|bool
name|setValue
argument_list|(
argument|Init *V
argument_list|)
block|{
if|if
condition|(
name|V
condition|)
block|{
name|Value
operator|=
name|V
operator|->
name|convertInitializerTo
argument_list|(
name|getType
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|Value
operator|==
name|nullptr
return|;
block|}
name|Value
operator|=
name|nullptr
expr_stmt|;
return|return
name|false
return|;
block|}
name|void
name|dump
argument_list|()
specifier|const
block|;
name|void
name|print
argument_list|(
argument|raw_ostream&OS
argument_list|,
argument|bool PrintSem = true
argument_list|)
specifier|const
block|; }
block|;
specifier|inline
name|raw_ostream
operator|&
name|operator
operator|<<
operator|(
name|raw_ostream
operator|&
name|OS
expr|,
specifier|const
name|RecordVal
operator|&
name|RV
operator|)
block|{
name|RV
operator|.
name|print
argument_list|(
name|OS
operator|<<
literal|"  "
argument_list|)
block|;
return|return
name|OS
return|;
block|}
name|class
name|Record
block|{
specifier|static
name|unsigned
name|LastID
block|;
name|Init
operator|*
name|Name
block|;
comment|// Location where record was instantiated, followed by the location of
comment|// multiclass prototypes used.
name|SmallVector
operator|<
name|SMLoc
block|,
literal|4
operator|>
name|Locs
block|;
name|SmallVector
operator|<
name|Init
operator|*
block|,
literal|0
operator|>
name|TemplateArgs
block|;
name|SmallVector
operator|<
name|RecordVal
block|,
literal|0
operator|>
name|Values
block|;
name|SmallVector
operator|<
name|std
operator|::
name|pair
operator|<
name|Record
operator|*
block|,
name|SMRange
operator|>
block|,
literal|0
operator|>
name|SuperClasses
block|;
comment|// Tracks Record instances. Not owned by Record.
name|RecordKeeper
operator|&
name|TrackedRecords
block|;
name|DefInit
operator|*
name|TheInit
operator|=
name|nullptr
block|;
comment|// Unique record ID.
name|unsigned
name|ID
block|;
name|bool
name|IsAnonymous
block|;
comment|// Class-instance values can be used by other defs.  For example, Struct<i>
comment|// is used here as a template argument to another class:
comment|//
comment|//   multiclass MultiClass<int i> {
comment|//     def Def : Class<Struct<i>>;
comment|//
comment|// These need to get fully resolved before instantiating any other
comment|// definitions that use them (e.g. Def).  However, inside a multiclass they
comment|// can't be immediately resolved so we mark them ResolveFirst to fully
comment|// resolve them later as soon as the multiclass is instantiated.
name|bool
name|ResolveFirst
block|;
name|void
name|init
argument_list|()
block|;
name|void
name|checkName
argument_list|()
block|;
name|public
operator|:
comment|// Constructs a record.
name|explicit
name|Record
argument_list|(
argument|Init *N
argument_list|,
argument|ArrayRef<SMLoc> locs
argument_list|,
argument|RecordKeeper&records
argument_list|,
argument|bool Anonymous = false
argument_list|)
operator|:
name|Name
argument_list|(
name|N
argument_list|)
block|,
name|Locs
argument_list|(
name|locs
operator|.
name|begin
argument_list|()
argument_list|,
name|locs
operator|.
name|end
argument_list|()
argument_list|)
block|,
name|TrackedRecords
argument_list|(
name|records
argument_list|)
block|,
name|ID
argument_list|(
name|LastID
operator|++
argument_list|)
block|,
name|IsAnonymous
argument_list|(
name|Anonymous
argument_list|)
block|,
name|ResolveFirst
argument_list|(
argument|false
argument_list|)
block|{
name|init
argument_list|()
block|;   }
name|explicit
name|Record
argument_list|(
argument|StringRef N
argument_list|,
argument|ArrayRef<SMLoc> locs
argument_list|,
argument|RecordKeeper&records
argument_list|,
argument|bool Anonymous = false
argument_list|)
operator|:
name|Record
argument_list|(
argument|StringInit::get(N)
argument_list|,
argument|locs
argument_list|,
argument|records
argument_list|,
argument|Anonymous
argument_list|)
block|{}
comment|// When copy-constructing a Record, we must still guarantee a globally unique
comment|// ID number.  Don't copy TheInit either since it's owned by the original
comment|// record. All other fields can be copied normally.
name|Record
argument_list|(
specifier|const
name|Record
operator|&
name|O
argument_list|)
operator|:
name|Name
argument_list|(
name|O
operator|.
name|Name
argument_list|)
block|,
name|Locs
argument_list|(
name|O
operator|.
name|Locs
argument_list|)
block|,
name|TemplateArgs
argument_list|(
name|O
operator|.
name|TemplateArgs
argument_list|)
block|,
name|Values
argument_list|(
name|O
operator|.
name|Values
argument_list|)
block|,
name|SuperClasses
argument_list|(
name|O
operator|.
name|SuperClasses
argument_list|)
block|,
name|TrackedRecords
argument_list|(
name|O
operator|.
name|TrackedRecords
argument_list|)
block|,
name|ID
argument_list|(
name|LastID
operator|++
argument_list|)
block|,
name|IsAnonymous
argument_list|(
name|O
operator|.
name|IsAnonymous
argument_list|)
block|,
name|ResolveFirst
argument_list|(
argument|O.ResolveFirst
argument_list|)
block|{ }
specifier|static
name|unsigned
name|getNewUID
argument_list|()
block|{
return|return
name|LastID
operator|++
return|;
block|}
name|unsigned
name|getID
argument_list|()
specifier|const
block|{
return|return
name|ID
return|;
block|}
name|StringRef
name|getName
argument_list|()
specifier|const
block|;
name|Init
operator|*
name|getNameInit
argument_list|()
specifier|const
block|{
return|return
name|Name
return|;
block|}
specifier|const
name|std
operator|::
name|string
name|getNameInitAsString
argument_list|()
specifier|const
block|{
return|return
name|getNameInit
argument_list|()
operator|->
name|getAsUnquotedString
argument_list|()
return|;
block|}
name|void
name|setName
argument_list|(
name|Init
operator|*
name|Name
argument_list|)
block|;
comment|// Also updates RecordKeeper.
name|ArrayRef
operator|<
name|SMLoc
operator|>
name|getLoc
argument_list|()
specifier|const
block|{
return|return
name|Locs
return|;
block|}
comment|/// get the corresponding DefInit.
name|DefInit
operator|*
name|getDefInit
argument_list|()
block|;
name|ArrayRef
operator|<
name|Init
operator|*
operator|>
name|getTemplateArgs
argument_list|()
specifier|const
block|{
return|return
name|TemplateArgs
return|;
block|}
name|ArrayRef
operator|<
name|RecordVal
operator|>
name|getValues
argument_list|()
specifier|const
block|{
return|return
name|Values
return|;
block|}
name|ArrayRef
operator|<
name|std
operator|::
name|pair
operator|<
name|Record
operator|*
block|,
name|SMRange
operator|>>
name|getSuperClasses
argument_list|()
specifier|const
block|{
return|return
name|SuperClasses
return|;
block|}
name|bool
name|isTemplateArg
argument_list|(
argument|Init *Name
argument_list|)
specifier|const
block|{
for|for
control|(
name|Init
modifier|*
name|TA
range|:
name|TemplateArgs
control|)
if|if
condition|(
name|TA
operator|==
name|Name
condition|)
return|return
name|true
return|;
return|return
name|false
return|;
block|}
specifier|const
name|RecordVal
operator|*
name|getValue
argument_list|(
argument|const Init *Name
argument_list|)
specifier|const
block|{
for|for
control|(
specifier|const
name|RecordVal
modifier|&
name|Val
range|:
name|Values
control|)
if|if
condition|(
name|Val
operator|.
name|Name
operator|==
name|Name
condition|)
return|return
operator|&
name|Val
return|;
return|return
name|nullptr
return|;
block|}
specifier|const
name|RecordVal
operator|*
name|getValue
argument_list|(
argument|StringRef Name
argument_list|)
specifier|const
block|{
return|return
name|getValue
argument_list|(
name|StringInit
operator|::
name|get
argument_list|(
name|Name
argument_list|)
argument_list|)
return|;
block|}
name|RecordVal
operator|*
name|getValue
argument_list|(
argument|const Init *Name
argument_list|)
block|{
return|return
name|const_cast
operator|<
name|RecordVal
operator|*
operator|>
operator|(
name|static_cast
operator|<
specifier|const
name|Record
operator|*
operator|>
operator|(
name|this
operator|)
operator|->
name|getValue
argument_list|(
name|Name
argument_list|)
operator|)
return|;
block|}
name|RecordVal
operator|*
name|getValue
argument_list|(
argument|StringRef Name
argument_list|)
block|{
return|return
name|const_cast
operator|<
name|RecordVal
operator|*
operator|>
operator|(
name|static_cast
operator|<
specifier|const
name|Record
operator|*
operator|>
operator|(
name|this
operator|)
operator|->
name|getValue
argument_list|(
name|Name
argument_list|)
operator|)
return|;
block|}
name|void
name|addTemplateArg
argument_list|(
argument|Init *Name
argument_list|)
block|{
name|assert
argument_list|(
operator|!
name|isTemplateArg
argument_list|(
name|Name
argument_list|)
operator|&&
literal|"Template arg already defined!"
argument_list|)
block|;
name|TemplateArgs
operator|.
name|push_back
argument_list|(
name|Name
argument_list|)
block|;   }
name|void
name|addValue
argument_list|(
argument|const RecordVal&RV
argument_list|)
block|{
name|assert
argument_list|(
name|getValue
argument_list|(
name|RV
operator|.
name|getNameInit
argument_list|()
argument_list|)
operator|==
name|nullptr
operator|&&
literal|"Value already added!"
argument_list|)
block|;
name|Values
operator|.
name|push_back
argument_list|(
name|RV
argument_list|)
block|;
if|if
condition|(
name|Values
operator|.
name|size
argument_list|()
operator|>
literal|1
condition|)
comment|// Keep NAME at the end of the list.  It makes record dumps a
comment|// bit prettier and allows TableGen tests to be written more
comment|// naturally.  Tests can use CHECK-NEXT to look for Record
comment|// fields they expect to see after a def.  They can't do that if
comment|// NAME is the first Record field.
name|std
operator|::
name|swap
argument_list|(
name|Values
index|[
name|Values
operator|.
name|size
argument_list|()
operator|-
literal|2
index|]
argument_list|,
name|Values
index|[
name|Values
operator|.
name|size
argument_list|()
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
name|void
name|removeValue
argument_list|(
argument|Init *Name
argument_list|)
block|{
for|for
control|(
name|unsigned
name|i
init|=
literal|0
init|,
name|e
init|=
name|Values
operator|.
name|size
argument_list|()
init|;
name|i
operator|!=
name|e
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|Values
index|[
name|i
index|]
operator|.
name|getNameInit
argument_list|()
operator|==
name|Name
condition|)
block|{
name|Values
operator|.
name|erase
argument_list|(
name|Values
operator|.
name|begin
argument_list|()
operator|+
name|i
argument_list|)
expr_stmt|;
return|return;
block|}
name|llvm_unreachable
argument_list|(
literal|"Cannot remove an entry that does not exist!"
argument_list|)
expr_stmt|;
block|}
name|void
name|removeValue
argument_list|(
argument|StringRef Name
argument_list|)
block|{
name|removeValue
argument_list|(
name|StringInit
operator|::
name|get
argument_list|(
name|Name
argument_list|)
argument_list|)
block|;   }
name|bool
name|isSubClassOf
argument_list|(
argument|const Record *R
argument_list|)
specifier|const
block|{
for|for
control|(
specifier|const
specifier|auto
modifier|&
name|SCPair
range|:
name|SuperClasses
control|)
if|if
condition|(
name|SCPair
operator|.
name|first
operator|==
name|R
condition|)
return|return
name|true
return|;
return|return
name|false
return|;
block|}
name|bool
name|isSubClassOf
argument_list|(
argument|StringRef Name
argument_list|)
specifier|const
block|{
for|for
control|(
specifier|const
specifier|auto
modifier|&
name|SCPair
range|:
name|SuperClasses
control|)
block|{
if|if
condition|(
specifier|const
specifier|auto
modifier|*
name|SI
init|=
name|dyn_cast
operator|<
name|StringInit
operator|>
operator|(
name|SCPair
operator|.
name|first
operator|->
name|getNameInit
argument_list|()
operator|)
condition|)
block|{
if|if
condition|(
name|SI
operator|->
name|getValue
argument_list|()
operator|==
name|Name
condition|)
return|return
name|true
return|;
block|}
elseif|else
if|if
condition|(
name|SCPair
operator|.
name|first
operator|->
name|getNameInitAsString
argument_list|()
operator|==
name|Name
condition|)
block|{
return|return
name|true
return|;
block|}
block|}
return|return
name|false
return|;
block|}
name|void
name|addSuperClass
argument_list|(
argument|Record *R
argument_list|,
argument|SMRange Range
argument_list|)
block|{
name|assert
argument_list|(
operator|!
name|isSubClassOf
argument_list|(
name|R
argument_list|)
operator|&&
literal|"Already subclassing record!"
argument_list|)
block|;
name|SuperClasses
operator|.
name|push_back
argument_list|(
name|std
operator|::
name|make_pair
argument_list|(
name|R
argument_list|,
name|Range
argument_list|)
argument_list|)
block|;   }
comment|/// If there are any field references that refer to fields
comment|/// that have been filled in, we can propagate the values now.
comment|///
name|void
name|resolveReferences
argument_list|()
block|{
name|resolveReferencesTo
argument_list|(
name|nullptr
argument_list|)
block|; }
comment|/// If anything in this record refers to RV, replace the
comment|/// reference to RV with the RHS of RV.  If RV is null, we resolve all
comment|/// possible references.
name|void
name|resolveReferencesTo
argument_list|(
specifier|const
name|RecordVal
operator|*
name|RV
argument_list|)
block|;
name|RecordKeeper
operator|&
name|getRecords
argument_list|()
specifier|const
block|{
return|return
name|TrackedRecords
return|;
block|}
name|bool
name|isAnonymous
argument_list|()
specifier|const
block|{
return|return
name|IsAnonymous
return|;
block|}
name|bool
name|isResolveFirst
argument_list|()
specifier|const
block|{
return|return
name|ResolveFirst
return|;
block|}
name|void
name|setResolveFirst
argument_list|(
argument|bool b
argument_list|)
block|{
name|ResolveFirst
operator|=
name|b
block|;   }
name|void
name|print
argument_list|(
argument|raw_ostream&OS
argument_list|)
specifier|const
block|;
name|void
name|dump
argument_list|()
specifier|const
block|;
comment|//===--------------------------------------------------------------------===//
comment|// High-level methods useful to tablegen back-ends
comment|//
comment|/// Return the initializer for a value with the specified name,
comment|/// or throw an exception if the field does not exist.
comment|///
name|Init
operator|*
name|getValueInit
argument_list|(
argument|StringRef FieldName
argument_list|)
specifier|const
block|;
comment|/// Return true if the named field is unset.
name|bool
name|isValueUnset
argument_list|(
argument|StringRef FieldName
argument_list|)
specifier|const
block|{
return|return
name|isa
operator|<
name|UnsetInit
operator|>
operator|(
name|getValueInit
argument_list|(
name|FieldName
argument_list|)
operator|)
return|;
block|}
comment|/// This method looks up the specified field and returns
comment|/// its value as a string, throwing an exception if the field does not exist
comment|/// or if the value is not a string.
comment|///
name|StringRef
name|getValueAsString
argument_list|(
argument|StringRef FieldName
argument_list|)
specifier|const
block|;
comment|/// This method looks up the specified field and returns
comment|/// its value as a BitsInit, throwing an exception if the field does not exist
comment|/// or if the value is not the right type.
comment|///
name|BitsInit
operator|*
name|getValueAsBitsInit
argument_list|(
argument|StringRef FieldName
argument_list|)
specifier|const
block|;
comment|/// This method looks up the specified field and returns
comment|/// its value as a ListInit, throwing an exception if the field does not exist
comment|/// or if the value is not the right type.
comment|///
name|ListInit
operator|*
name|getValueAsListInit
argument_list|(
argument|StringRef FieldName
argument_list|)
specifier|const
block|;
comment|/// This method looks up the specified field and
comment|/// returns its value as a vector of records, throwing an exception if the
comment|/// field does not exist or if the value is not the right type.
comment|///
name|std
operator|::
name|vector
operator|<
name|Record
operator|*
operator|>
name|getValueAsListOfDefs
argument_list|(
argument|StringRef FieldName
argument_list|)
specifier|const
block|;
comment|/// This method looks up the specified field and
comment|/// returns its value as a vector of integers, throwing an exception if the
comment|/// field does not exist or if the value is not the right type.
comment|///
name|std
operator|::
name|vector
operator|<
name|int64_t
operator|>
name|getValueAsListOfInts
argument_list|(
argument|StringRef FieldName
argument_list|)
specifier|const
block|;
comment|/// This method looks up the specified field and
comment|/// returns its value as a vector of strings, throwing an exception if the
comment|/// field does not exist or if the value is not the right type.
comment|///
name|std
operator|::
name|vector
operator|<
name|StringRef
operator|>
name|getValueAsListOfStrings
argument_list|(
argument|StringRef FieldName
argument_list|)
specifier|const
block|;
comment|/// This method looks up the specified field and returns its
comment|/// value as a Record, throwing an exception if the field does not exist or if
comment|/// the value is not the right type.
comment|///
name|Record
operator|*
name|getValueAsDef
argument_list|(
argument|StringRef FieldName
argument_list|)
specifier|const
block|;
comment|/// This method looks up the specified field and returns its
comment|/// value as a bit, throwing an exception if the field does not exist or if
comment|/// the value is not the right type.
comment|///
name|bool
name|getValueAsBit
argument_list|(
argument|StringRef FieldName
argument_list|)
specifier|const
block|;
comment|/// This method looks up the specified field and
comment|/// returns its value as a bit. If the field is unset, sets Unset to true and
comment|/// returns false.
comment|///
name|bool
name|getValueAsBitOrUnset
argument_list|(
argument|StringRef FieldName
argument_list|,
argument|bool&Unset
argument_list|)
specifier|const
block|;
comment|/// This method looks up the specified field and returns its
comment|/// value as an int64_t, throwing an exception if the field does not exist or
comment|/// if the value is not the right type.
comment|///
name|int64_t
name|getValueAsInt
argument_list|(
argument|StringRef FieldName
argument_list|)
specifier|const
block|;
comment|/// This method looks up the specified field and returns its
comment|/// value as an Dag, throwing an exception if the field does not exist or if
comment|/// the value is not the right type.
comment|///
name|DagInit
operator|*
name|getValueAsDag
argument_list|(
argument|StringRef FieldName
argument_list|)
specifier|const
block|; }
block|;
name|raw_ostream
operator|&
name|operator
operator|<<
operator|(
name|raw_ostream
operator|&
name|OS
expr|,
specifier|const
name|Record
operator|&
name|R
operator|)
block|;  struct
name|MultiClass
block|{
name|Record
name|Rec
block|;
comment|// Placeholder for template args and Name.
typedef|typedef
name|std
operator|::
name|vector
operator|<
name|std
operator|::
name|unique_ptr
operator|<
name|Record
operator|>>
name|RecordVector
expr_stmt|;
name|RecordVector
name|DefPrototypes
block|;
name|void
name|dump
argument_list|()
specifier|const
block|;
name|MultiClass
argument_list|(
argument|StringRef Name
argument_list|,
argument|SMLoc Loc
argument_list|,
argument|RecordKeeper&Records
argument_list|)
operator|:
name|Rec
argument_list|(
argument|Name
argument_list|,
argument|Loc
argument_list|,
argument|Records
argument_list|)
block|{}
block|}
block|;
name|class
name|RecordKeeper
block|{
typedef|typedef
name|std
operator|::
name|map
operator|<
name|std
operator|::
name|string
operator|,
name|std
operator|::
name|unique_ptr
operator|<
name|Record
operator|>>
name|RecordMap
expr_stmt|;
name|RecordMap
name|Classes
block|,
name|Defs
block|;
name|public
operator|:
specifier|const
name|RecordMap
operator|&
name|getClasses
argument_list|()
specifier|const
block|{
return|return
name|Classes
return|;
block|}
specifier|const
name|RecordMap
operator|&
name|getDefs
argument_list|()
specifier|const
block|{
return|return
name|Defs
return|;
block|}
name|Record
operator|*
name|getClass
argument_list|(
argument|StringRef Name
argument_list|)
specifier|const
block|{
name|auto
name|I
operator|=
name|Classes
operator|.
name|find
argument_list|(
name|Name
argument_list|)
block|;
return|return
name|I
operator|==
name|Classes
operator|.
name|end
argument_list|()
condition|?
name|nullptr
else|:
name|I
operator|->
name|second
operator|.
name|get
argument_list|()
return|;
block|}
name|Record
operator|*
name|getDef
argument_list|(
argument|StringRef Name
argument_list|)
specifier|const
block|{
name|auto
name|I
operator|=
name|Defs
operator|.
name|find
argument_list|(
name|Name
argument_list|)
block|;
return|return
name|I
operator|==
name|Defs
operator|.
name|end
argument_list|()
condition|?
name|nullptr
else|:
name|I
operator|->
name|second
operator|.
name|get
argument_list|()
return|;
block|}
name|void
name|addClass
argument_list|(
argument|std::unique_ptr<Record> R
argument_list|)
block|{
name|bool
name|Ins
operator|=
name|Classes
operator|.
name|insert
argument_list|(
name|std
operator|::
name|make_pair
argument_list|(
name|R
operator|->
name|getName
argument_list|()
argument_list|,
name|std
operator|::
name|move
argument_list|(
name|R
argument_list|)
argument_list|)
argument_list|)
operator|.
name|second
block|;
operator|(
name|void
operator|)
name|Ins
block|;
name|assert
argument_list|(
name|Ins
operator|&&
literal|"Class already exists"
argument_list|)
block|;   }
name|void
name|addDef
argument_list|(
argument|std::unique_ptr<Record> R
argument_list|)
block|{
name|bool
name|Ins
operator|=
name|Defs
operator|.
name|insert
argument_list|(
name|std
operator|::
name|make_pair
argument_list|(
name|R
operator|->
name|getName
argument_list|()
argument_list|,
name|std
operator|::
name|move
argument_list|(
name|R
argument_list|)
argument_list|)
argument_list|)
operator|.
name|second
block|;
operator|(
name|void
operator|)
name|Ins
block|;
name|assert
argument_list|(
name|Ins
operator|&&
literal|"Record already exists"
argument_list|)
block|;   }
comment|//===--------------------------------------------------------------------===//
comment|// High-level helper methods, useful for tablegen backends...
comment|/// This method returns all concrete definitions
comment|/// that derive from the specified class name.  A class with the specified
comment|/// name must exist.
name|std
operator|::
name|vector
operator|<
name|Record
operator|*
operator|>
name|getAllDerivedDefinitions
argument_list|(
argument|StringRef ClassName
argument_list|)
specifier|const
block|;
name|void
name|dump
argument_list|()
specifier|const
block|; }
block|;
comment|/// Sorting predicate to sort record pointers by name.
comment|///
block|struct
name|LessRecord
block|{
name|bool
name|operator
argument_list|()
operator|(
specifier|const
name|Record
operator|*
name|Rec1
expr|,
specifier|const
name|Record
operator|*
name|Rec2
operator|)
specifier|const
block|{
return|return
name|StringRef
argument_list|(
name|Rec1
operator|->
name|getName
argument_list|()
argument_list|)
operator|.
name|compare_numeric
argument_list|(
name|Rec2
operator|->
name|getName
argument_list|()
argument_list|)
operator|<
literal|0
return|;
block|}
expr|}
block|;
comment|/// Sorting predicate to sort record pointers by their
comment|/// unique ID. If you just need a deterministic order, use this, since it
comment|/// just compares two `unsigned`; the other sorting predicates require
comment|/// string manipulation.
block|struct
name|LessRecordByID
block|{
name|bool
name|operator
argument_list|()
operator|(
specifier|const
name|Record
operator|*
name|LHS
expr|,
specifier|const
name|Record
operator|*
name|RHS
operator|)
specifier|const
block|{
return|return
name|LHS
operator|->
name|getID
argument_list|()
operator|<
name|RHS
operator|->
name|getID
argument_list|()
return|;
block|}
expr|}
block|;
comment|/// Sorting predicate to sort record pointers by their
comment|/// name field.
comment|///
block|struct
name|LessRecordFieldName
block|{
name|bool
name|operator
argument_list|()
operator|(
specifier|const
name|Record
operator|*
name|Rec1
expr|,
specifier|const
name|Record
operator|*
name|Rec2
operator|)
specifier|const
block|{
return|return
name|Rec1
operator|->
name|getValueAsString
argument_list|(
literal|"Name"
argument_list|)
operator|<
name|Rec2
operator|->
name|getValueAsString
argument_list|(
literal|"Name"
argument_list|)
return|;
block|}
expr|}
block|;  struct
name|LessRecordRegister
block|{
specifier|static
name|bool
name|ascii_isdigit
argument_list|(
argument|char x
argument_list|)
block|{
return|return
name|x
operator|>=
literal|'0'
operator|&&
name|x
operator|<=
literal|'9'
return|;
block|}
expr|struct
name|RecordParts
block|{
name|SmallVector
operator|<
name|std
operator|::
name|pair
operator|<
name|bool
block|,
name|StringRef
operator|>
block|,
literal|4
operator|>
name|Parts
block|;
name|RecordParts
argument_list|(
argument|StringRef Rec
argument_list|)
block|{
if|if
condition|(
name|Rec
operator|.
name|empty
argument_list|()
condition|)
return|return;
name|size_t
name|Len
operator|=
literal|0
block|;
specifier|const
name|char
operator|*
name|Start
operator|=
name|Rec
operator|.
name|data
argument_list|()
block|;
specifier|const
name|char
operator|*
name|Curr
operator|=
name|Start
block|;
name|bool
name|isDigitPart
operator|=
name|ascii_isdigit
argument_list|(
name|Curr
index|[
literal|0
index|]
argument_list|)
block|;
for|for
control|(
name|size_t
name|I
init|=
literal|0
init|,
name|E
init|=
name|Rec
operator|.
name|size
argument_list|()
init|;
name|I
operator|!=
name|E
condition|;
operator|++
name|I
incr|,
operator|++
name|Len
control|)
block|{
name|bool
name|isDigit
init|=
name|ascii_isdigit
argument_list|(
name|Curr
index|[
name|I
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|isDigit
operator|!=
name|isDigitPart
condition|)
block|{
name|Parts
operator|.
name|push_back
argument_list|(
name|std
operator|::
name|make_pair
argument_list|(
name|isDigitPart
argument_list|,
name|StringRef
argument_list|(
name|Start
argument_list|,
name|Len
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|Len
operator|=
literal|0
expr_stmt|;
name|Start
operator|=
operator|&
name|Curr
index|[
name|I
index|]
expr_stmt|;
name|isDigitPart
operator|=
name|ascii_isdigit
argument_list|(
name|Curr
index|[
name|I
index|]
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Push the last part.
name|Parts
operator|.
name|push_back
argument_list|(
name|std
operator|::
name|make_pair
argument_list|(
name|isDigitPart
argument_list|,
name|StringRef
argument_list|(
name|Start
argument_list|,
name|Len
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|size_t
name|size
argument_list|()
block|{
return|return
name|Parts
operator|.
name|size
argument_list|()
return|;
block|}
name|std
operator|::
name|pair
operator|<
name|bool
block|,
name|StringRef
operator|>
name|getPart
argument_list|(
argument|size_t i
argument_list|)
block|{
name|assert
argument_list|(
name|i
operator|<
name|Parts
operator|.
name|size
argument_list|()
operator|&&
literal|"Invalid idx!"
argument_list|)
block|;
return|return
name|Parts
index|[
name|i
index|]
return|;
block|}
expr|}
block|;
name|bool
name|operator
argument_list|()
operator|(
specifier|const
name|Record
operator|*
name|Rec1
expr|,
specifier|const
name|Record
operator|*
name|Rec2
operator|)
specifier|const
block|{
name|RecordParts
name|LHSParts
argument_list|(
name|StringRef
argument_list|(
name|Rec1
operator|->
name|getName
argument_list|()
argument_list|)
argument_list|)
block|;
name|RecordParts
name|RHSParts
argument_list|(
name|StringRef
argument_list|(
name|Rec2
operator|->
name|getName
argument_list|()
argument_list|)
argument_list|)
block|;
name|size_t
name|LHSNumParts
operator|=
name|LHSParts
operator|.
name|size
argument_list|()
block|;
name|size_t
name|RHSNumParts
operator|=
name|RHSParts
operator|.
name|size
argument_list|()
block|;
name|assert
argument_list|(
name|LHSNumParts
operator|&&
name|RHSNumParts
operator|&&
literal|"Expected at least one part!"
argument_list|)
block|;
if|if
condition|(
name|LHSNumParts
operator|!=
name|RHSNumParts
condition|)
return|return
name|LHSNumParts
operator|<
name|RHSNumParts
return|;
comment|// We expect the registers to be of the form [_a-zA-z]+([0-9]*[_a-zA-Z]*)*.
for|for
control|(
name|size_t
name|I
init|=
literal|0
init|,
name|E
init|=
name|LHSNumParts
init|;
name|I
operator|<
name|E
condition|;
name|I
operator|+=
literal|2
control|)
block|{
name|std
operator|::
name|pair
operator|<
name|bool
operator|,
name|StringRef
operator|>
name|LHSPart
operator|=
name|LHSParts
operator|.
name|getPart
argument_list|(
name|I
argument_list|)
expr_stmt|;
name|std
operator|::
name|pair
operator|<
name|bool
operator|,
name|StringRef
operator|>
name|RHSPart
operator|=
name|RHSParts
operator|.
name|getPart
argument_list|(
name|I
argument_list|)
expr_stmt|;
comment|// Expect even part to always be alpha.
name|assert
argument_list|(
name|LHSPart
operator|.
name|first
operator|==
name|false
operator|&&
name|RHSPart
operator|.
name|first
operator|==
name|false
operator|&&
literal|"Expected both parts to be alpha."
argument_list|)
expr_stmt|;
if|if
condition|(
name|int
name|Res
init|=
name|LHSPart
operator|.
name|second
operator|.
name|compare
argument_list|(
name|RHSPart
operator|.
name|second
argument_list|)
condition|)
return|return
name|Res
operator|<
literal|0
return|;
block|}
for|for
control|(
name|size_t
name|I
init|=
literal|1
init|,
name|E
init|=
name|LHSNumParts
init|;
name|I
operator|<
name|E
condition|;
name|I
operator|+=
literal|2
control|)
block|{
name|std
operator|::
name|pair
operator|<
name|bool
operator|,
name|StringRef
operator|>
name|LHSPart
operator|=
name|LHSParts
operator|.
name|getPart
argument_list|(
name|I
argument_list|)
expr_stmt|;
name|std
operator|::
name|pair
operator|<
name|bool
operator|,
name|StringRef
operator|>
name|RHSPart
operator|=
name|RHSParts
operator|.
name|getPart
argument_list|(
name|I
argument_list|)
expr_stmt|;
comment|// Expect odd part to always be numeric.
name|assert
argument_list|(
name|LHSPart
operator|.
name|first
operator|==
name|true
operator|&&
name|RHSPart
operator|.
name|first
operator|==
name|true
operator|&&
literal|"Expected both parts to be numeric."
argument_list|)
expr_stmt|;
if|if
condition|(
name|LHSPart
operator|.
name|second
operator|.
name|size
argument_list|()
operator|!=
name|RHSPart
operator|.
name|second
operator|.
name|size
argument_list|()
condition|)
return|return
name|LHSPart
operator|.
name|second
operator|.
name|size
argument_list|()
operator|<
name|RHSPart
operator|.
name|second
operator|.
name|size
argument_list|()
return|;
name|unsigned
name|LHSVal
decl_stmt|,
name|RHSVal
decl_stmt|;
name|bool
name|LHSFailed
init|=
name|LHSPart
operator|.
name|second
operator|.
name|getAsInteger
argument_list|(
literal|10
argument_list|,
name|LHSVal
argument_list|)
decl_stmt|;
operator|(
name|void
operator|)
name|LHSFailed
expr_stmt|;
name|assert
argument_list|(
operator|!
name|LHSFailed
operator|&&
literal|"Unable to convert LHS to integer."
argument_list|)
expr_stmt|;
name|bool
name|RHSFailed
init|=
name|RHSPart
operator|.
name|second
operator|.
name|getAsInteger
argument_list|(
literal|10
argument_list|,
name|RHSVal
argument_list|)
decl_stmt|;
operator|(
name|void
operator|)
name|RHSFailed
expr_stmt|;
name|assert
argument_list|(
operator|!
name|RHSFailed
operator|&&
literal|"Unable to convert RHS to integer."
argument_list|)
expr_stmt|;
if|if
condition|(
name|LHSVal
operator|!=
name|RHSVal
condition|)
return|return
name|LHSVal
operator|<
name|RHSVal
return|;
block|}
return|return
name|LHSNumParts
operator|<
name|RHSNumParts
return|;
block|}
expr|}
block|;
name|raw_ostream
operator|&
name|operator
operator|<<
operator|(
name|raw_ostream
operator|&
name|OS
expr|,
specifier|const
name|RecordKeeper
operator|&
name|RK
operator|)
block|;
comment|/// Return an Init with a qualifier prefix referring
comment|/// to CurRec's name.
name|Init
operator|*
name|QualifyName
argument_list|(
argument|Record&CurRec
argument_list|,
argument|MultiClass *CurMultiClass
argument_list|,
argument|Init *Name
argument_list|,
argument|StringRef Scoper
argument_list|)
block|;  }
end_decl_stmt

begin_comment
comment|// end namespace llvm
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|// LLVM_TABLEGEN_RECORD_H
end_comment

end_unit

