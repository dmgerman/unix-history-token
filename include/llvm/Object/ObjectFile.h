begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===- ObjectFile.h - File format independent object file -------*- C++ -*-===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file declares a file format independent ObjectFile class.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LLVM_OBJECT_OBJECTFILE_H
end_ifndef

begin_define
define|#
directive|define
name|LLVM_OBJECT_OBJECTFILE_H
end_define

begin_include
include|#
directive|include
file|"llvm/ADT/StringRef.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Object/SymbolicFile.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/DataTypes.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/ErrorHandling.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/FileSystem.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/MemoryBuffer.h"
end_include

begin_include
include|#
directive|include
file|<cstring>
end_include

begin_include
include|#
directive|include
file|<vector>
end_include

begin_decl_stmt
name|namespace
name|llvm
block|{
name|namespace
name|object
block|{
name|class
name|ObjectFile
decl_stmt|;
name|class
name|COFFObjectFile
decl_stmt|;
name|class
name|MachOObjectFile
decl_stmt|;
name|class
name|SymbolRef
decl_stmt|;
name|class
name|symbol_iterator
decl_stmt|;
name|class
name|SectionRef
decl_stmt|;
typedef|typedef
name|content_iterator
operator|<
name|SectionRef
operator|>
name|section_iterator
expr_stmt|;
comment|/// This is a value type class that represents a single relocation in the list
comment|/// of relocations in the object file.
name|class
name|RelocationRef
block|{
name|DataRefImpl
name|RelocationPimpl
decl_stmt|;
specifier|const
name|ObjectFile
modifier|*
name|OwningObject
decl_stmt|;
name|public
label|:
name|RelocationRef
argument_list|()
operator|:
name|OwningObject
argument_list|(
argument|nullptr
argument_list|)
block|{ }
name|RelocationRef
argument_list|(
argument|DataRefImpl RelocationP
argument_list|,
argument|const ObjectFile *Owner
argument_list|)
expr_stmt|;
name|bool
name|operator
operator|==
operator|(
specifier|const
name|RelocationRef
operator|&
name|Other
operator|)
specifier|const
expr_stmt|;
name|void
name|moveNext
parameter_list|()
function_decl|;
name|uint64_t
name|getOffset
argument_list|()
specifier|const
expr_stmt|;
name|symbol_iterator
name|getSymbol
argument_list|()
specifier|const
expr_stmt|;
name|uint64_t
name|getType
argument_list|()
specifier|const
expr_stmt|;
comment|/// @brief Get a string that represents the type of this relocation.
comment|///
comment|/// This is for display purposes only.
name|void
name|getTypeName
argument_list|(
name|SmallVectorImpl
operator|<
name|char
operator|>
operator|&
name|Result
argument_list|)
decl|const
decl_stmt|;
name|DataRefImpl
name|getRawDataRefImpl
argument_list|()
specifier|const
expr_stmt|;
specifier|const
name|ObjectFile
operator|*
name|getObject
argument_list|()
specifier|const
expr_stmt|;
block|}
empty_stmt|;
typedef|typedef
name|content_iterator
operator|<
name|RelocationRef
operator|>
name|relocation_iterator
expr_stmt|;
comment|/// This is a value type class that represents a single section in the list of
comment|/// sections in the object file.
name|class
name|SectionRef
block|{
name|friend
name|class
name|SymbolRef
decl_stmt|;
name|DataRefImpl
name|SectionPimpl
decl_stmt|;
specifier|const
name|ObjectFile
modifier|*
name|OwningObject
decl_stmt|;
name|public
label|:
name|SectionRef
argument_list|()
operator|:
name|OwningObject
argument_list|(
argument|nullptr
argument_list|)
block|{ }
name|SectionRef
argument_list|(
argument|DataRefImpl SectionP
argument_list|,
argument|const ObjectFile *Owner
argument_list|)
expr_stmt|;
name|bool
name|operator
operator|==
operator|(
specifier|const
name|SectionRef
operator|&
name|Other
operator|)
specifier|const
expr_stmt|;
name|bool
name|operator
operator|!=
operator|(
specifier|const
name|SectionRef
operator|&
name|Other
operator|)
specifier|const
expr_stmt|;
name|bool
name|operator
operator|<
operator|(
specifier|const
name|SectionRef
operator|&
name|Other
operator|)
specifier|const
expr_stmt|;
name|void
name|moveNext
parameter_list|()
function_decl|;
name|std
operator|::
name|error_code
name|getName
argument_list|(
argument|StringRef&Result
argument_list|)
specifier|const
expr_stmt|;
name|uint64_t
name|getAddress
argument_list|()
specifier|const
expr_stmt|;
name|uint64_t
name|getSize
argument_list|()
specifier|const
expr_stmt|;
name|std
operator|::
name|error_code
name|getContents
argument_list|(
argument|StringRef&Result
argument_list|)
specifier|const
expr_stmt|;
comment|/// @brief Get the alignment of this section as the actual value (not log 2).
name|uint64_t
name|getAlignment
argument_list|()
specifier|const
expr_stmt|;
name|bool
name|isText
argument_list|()
specifier|const
expr_stmt|;
name|bool
name|isData
argument_list|()
specifier|const
expr_stmt|;
name|bool
name|isBSS
argument_list|()
specifier|const
expr_stmt|;
name|bool
name|isVirtual
argument_list|()
specifier|const
expr_stmt|;
name|bool
name|containsSymbol
argument_list|(
name|SymbolRef
name|S
argument_list|)
decl|const
decl_stmt|;
name|relocation_iterator
name|relocation_begin
argument_list|()
specifier|const
expr_stmt|;
name|relocation_iterator
name|relocation_end
argument_list|()
specifier|const
expr_stmt|;
name|iterator_range
operator|<
name|relocation_iterator
operator|>
name|relocations
argument_list|()
specifier|const
block|{
return|return
name|make_range
argument_list|(
name|relocation_begin
argument_list|()
argument_list|,
name|relocation_end
argument_list|()
argument_list|)
return|;
block|}
name|section_iterator
name|getRelocatedSection
argument_list|()
specifier|const
expr_stmt|;
name|DataRefImpl
name|getRawDataRefImpl
argument_list|()
specifier|const
expr_stmt|;
specifier|const
name|ObjectFile
operator|*
name|getObject
argument_list|()
specifier|const
expr_stmt|;
block|}
empty_stmt|;
comment|/// This is a value type class that represents a single symbol in the list of
comment|/// symbols in the object file.
name|class
name|SymbolRef
range|:
name|public
name|BasicSymbolRef
block|{
name|friend
name|class
name|SectionRef
block|;
name|public
operator|:
name|SymbolRef
argument_list|()
operator|:
name|BasicSymbolRef
argument_list|()
block|{}
expr|enum
name|Type
block|{
name|ST_Unknown
block|,
comment|// Type not specified
name|ST_Data
block|,
name|ST_Debug
block|,
name|ST_File
block|,
name|ST_Function
block|,
name|ST_Other
block|}
block|;
name|SymbolRef
argument_list|(
argument|DataRefImpl SymbolP
argument_list|,
argument|const ObjectFile *Owner
argument_list|)
block|;
name|SymbolRef
argument_list|(
specifier|const
name|BasicSymbolRef
operator|&
name|B
argument_list|)
operator|:
name|BasicSymbolRef
argument_list|(
argument|B
argument_list|)
block|{
name|assert
argument_list|(
name|isa
operator|<
name|ObjectFile
operator|>
operator|(
name|BasicSymbolRef
operator|::
name|getObject
argument_list|()
operator|)
argument_list|)
block|;   }
name|ErrorOr
operator|<
name|StringRef
operator|>
name|getName
argument_list|()
specifier|const
block|;
comment|/// Returns the symbol virtual address (i.e. address at which it will be
comment|/// mapped).
name|ErrorOr
operator|<
name|uint64_t
operator|>
name|getAddress
argument_list|()
specifier|const
block|;
comment|/// Return the value of the symbol depending on the object this can be an
comment|/// offset or a virtual address.
name|uint64_t
name|getValue
argument_list|()
specifier|const
block|;
comment|/// @brief Get the alignment of this symbol as the actual value (not log 2).
name|uint32_t
name|getAlignment
argument_list|()
specifier|const
block|;
name|uint64_t
name|getCommonSize
argument_list|()
specifier|const
block|;
name|SymbolRef
operator|::
name|Type
name|getType
argument_list|()
specifier|const
block|;
comment|/// @brief Get section this symbol is defined in reference to. Result is
comment|/// end_sections() if it is undefined or is an absolute symbol.
name|ErrorOr
operator|<
name|section_iterator
operator|>
name|getSection
argument_list|()
specifier|const
block|;
specifier|const
name|ObjectFile
operator|*
name|getObject
argument_list|()
specifier|const
block|; }
decl_stmt|;
name|class
name|symbol_iterator
range|:
name|public
name|basic_symbol_iterator
block|{
name|public
operator|:
name|symbol_iterator
argument_list|(
argument|SymbolRef Sym
argument_list|)
operator|:
name|basic_symbol_iterator
argument_list|(
argument|Sym
argument_list|)
block|{}
name|symbol_iterator
argument_list|(
specifier|const
name|basic_symbol_iterator
operator|&
name|B
argument_list|)
operator|:
name|basic_symbol_iterator
argument_list|(
argument|SymbolRef(B->getRawDataRefImpl(),                                         cast<ObjectFile>(B->getObject()))
argument_list|)
block|{}
specifier|const
name|SymbolRef
operator|*
name|operator
operator|->
expr|(
block|)
specifier|const
block|{
specifier|const
name|BasicSymbolRef
operator|&
name|P
operator|=
name|basic_symbol_iterator
operator|::
name|operator
operator|*
operator|(
operator|)
block|;
return|return
name|static_cast
operator|<
specifier|const
name|SymbolRef
operator|*
operator|>
operator|(
operator|&
name|P
operator|)
return|;
block|}
specifier|const
name|SymbolRef
operator|&
name|operator
operator|*
operator|(
operator|)
specifier|const
block|{
specifier|const
name|BasicSymbolRef
operator|&
name|P
operator|=
name|basic_symbol_iterator
operator|::
name|operator
operator|*
operator|(
operator|)
block|;
return|return
name|static_cast
operator|<
specifier|const
name|SymbolRef
operator|&
operator|>
operator|(
name|P
operator|)
return|;
block|}
block|}
empty_stmt|;
comment|/// This class is the base class for all object file types. Concrete instances
comment|/// of this object are created by createObjectFile, which figures out which type
comment|/// to create.
name|class
name|ObjectFile
range|:
name|public
name|SymbolicFile
block|{
name|virtual
name|void
name|anchor
argument_list|()
block|;
name|ObjectFile
argument_list|()
operator|=
name|delete
block|;
name|ObjectFile
argument_list|(
specifier|const
name|ObjectFile
operator|&
name|other
argument_list|)
operator|=
name|delete
block|;
name|protected
operator|:
name|ObjectFile
argument_list|(
argument|unsigned int Type
argument_list|,
argument|MemoryBufferRef Source
argument_list|)
block|;
specifier|const
name|uint8_t
operator|*
name|base
argument_list|()
specifier|const
block|{
return|return
name|reinterpret_cast
operator|<
specifier|const
name|uint8_t
operator|*
operator|>
operator|(
name|Data
operator|.
name|getBufferStart
argument_list|()
operator|)
return|;
block|}
comment|// These functions are for SymbolRef to call internally. The main goal of
comment|// this is to allow SymbolRef::SymbolPimpl to point directly to the symbol
comment|// entry in the memory mapped object file. SymbolPimpl cannot contain any
comment|// virtual functions because then it could not point into the memory mapped
comment|// file.
comment|//
comment|// Implementations assume that the DataRefImpl is valid and has not been
comment|// modified externally. It's UB otherwise.
name|friend
name|class
name|SymbolRef
block|;
name|virtual
name|ErrorOr
operator|<
name|StringRef
operator|>
name|getSymbolName
argument_list|(
argument|DataRefImpl Symb
argument_list|)
specifier|const
operator|=
literal|0
block|;
name|std
operator|::
name|error_code
name|printSymbolName
argument_list|(
argument|raw_ostream&OS
argument_list|,
argument|DataRefImpl Symb
argument_list|)
specifier|const
name|override
block|;
name|virtual
name|ErrorOr
operator|<
name|uint64_t
operator|>
name|getSymbolAddress
argument_list|(
argument|DataRefImpl Symb
argument_list|)
specifier|const
operator|=
literal|0
block|;
name|virtual
name|uint64_t
name|getSymbolValueImpl
argument_list|(
argument|DataRefImpl Symb
argument_list|)
specifier|const
operator|=
literal|0
block|;
name|virtual
name|uint32_t
name|getSymbolAlignment
argument_list|(
argument|DataRefImpl Symb
argument_list|)
specifier|const
block|;
name|virtual
name|uint64_t
name|getCommonSymbolSizeImpl
argument_list|(
argument|DataRefImpl Symb
argument_list|)
specifier|const
operator|=
literal|0
block|;
name|virtual
name|SymbolRef
operator|::
name|Type
name|getSymbolType
argument_list|(
argument|DataRefImpl Symb
argument_list|)
specifier|const
operator|=
literal|0
block|;
name|virtual
name|ErrorOr
operator|<
name|section_iterator
operator|>
name|getSymbolSection
argument_list|(
argument|DataRefImpl Symb
argument_list|)
specifier|const
operator|=
literal|0
block|;
comment|// Same as above for SectionRef.
name|friend
name|class
name|SectionRef
block|;
name|virtual
name|void
name|moveSectionNext
argument_list|(
argument|DataRefImpl&Sec
argument_list|)
specifier|const
operator|=
literal|0
block|;
name|virtual
name|std
operator|::
name|error_code
name|getSectionName
argument_list|(
argument|DataRefImpl Sec
argument_list|,
argument|StringRef&Res
argument_list|)
specifier|const
operator|=
literal|0
block|;
name|virtual
name|uint64_t
name|getSectionAddress
argument_list|(
argument|DataRefImpl Sec
argument_list|)
specifier|const
operator|=
literal|0
block|;
name|virtual
name|uint64_t
name|getSectionSize
argument_list|(
argument|DataRefImpl Sec
argument_list|)
specifier|const
operator|=
literal|0
block|;
name|virtual
name|std
operator|::
name|error_code
name|getSectionContents
argument_list|(
argument|DataRefImpl Sec
argument_list|,
argument|StringRef&Res
argument_list|)
specifier|const
operator|=
literal|0
block|;
name|virtual
name|uint64_t
name|getSectionAlignment
argument_list|(
argument|DataRefImpl Sec
argument_list|)
specifier|const
operator|=
literal|0
block|;
name|virtual
name|bool
name|isSectionText
argument_list|(
argument|DataRefImpl Sec
argument_list|)
specifier|const
operator|=
literal|0
block|;
name|virtual
name|bool
name|isSectionData
argument_list|(
argument|DataRefImpl Sec
argument_list|)
specifier|const
operator|=
literal|0
block|;
name|virtual
name|bool
name|isSectionBSS
argument_list|(
argument|DataRefImpl Sec
argument_list|)
specifier|const
operator|=
literal|0
block|;
comment|// A section is 'virtual' if its contents aren't present in the object image.
name|virtual
name|bool
name|isSectionVirtual
argument_list|(
argument|DataRefImpl Sec
argument_list|)
specifier|const
operator|=
literal|0
block|;
name|virtual
name|relocation_iterator
name|section_rel_begin
argument_list|(
argument|DataRefImpl Sec
argument_list|)
specifier|const
operator|=
literal|0
block|;
name|virtual
name|relocation_iterator
name|section_rel_end
argument_list|(
argument|DataRefImpl Sec
argument_list|)
specifier|const
operator|=
literal|0
block|;
name|virtual
name|section_iterator
name|getRelocatedSection
argument_list|(
argument|DataRefImpl Sec
argument_list|)
specifier|const
block|;
comment|// Same as above for RelocationRef.
name|friend
name|class
name|RelocationRef
block|;
name|virtual
name|void
name|moveRelocationNext
argument_list|(
argument|DataRefImpl&Rel
argument_list|)
specifier|const
operator|=
literal|0
block|;
name|virtual
name|uint64_t
name|getRelocationOffset
argument_list|(
argument|DataRefImpl Rel
argument_list|)
specifier|const
operator|=
literal|0
block|;
name|virtual
name|symbol_iterator
name|getRelocationSymbol
argument_list|(
argument|DataRefImpl Rel
argument_list|)
specifier|const
operator|=
literal|0
block|;
name|virtual
name|uint64_t
name|getRelocationType
argument_list|(
argument|DataRefImpl Rel
argument_list|)
specifier|const
operator|=
literal|0
block|;
name|virtual
name|void
name|getRelocationTypeName
argument_list|(
argument|DataRefImpl Rel
argument_list|,
argument|SmallVectorImpl<char>&Result
argument_list|)
specifier|const
operator|=
literal|0
block|;
name|uint64_t
name|getSymbolValue
argument_list|(
argument|DataRefImpl Symb
argument_list|)
specifier|const
block|;
name|public
operator|:
name|uint64_t
name|getCommonSymbolSize
argument_list|(
argument|DataRefImpl Symb
argument_list|)
specifier|const
block|{
name|assert
argument_list|(
name|getSymbolFlags
argument_list|(
name|Symb
argument_list|)
operator|&
name|SymbolRef
operator|::
name|SF_Common
argument_list|)
block|;
return|return
name|getCommonSymbolSizeImpl
argument_list|(
name|Symb
argument_list|)
return|;
block|}
typedef|typedef
name|iterator_range
operator|<
name|symbol_iterator
operator|>
name|symbol_iterator_range
expr_stmt|;
name|symbol_iterator_range
name|symbols
argument_list|()
specifier|const
block|{
return|return
name|symbol_iterator_range
argument_list|(
name|symbol_begin
argument_list|()
argument_list|,
name|symbol_end
argument_list|()
argument_list|)
return|;
block|}
name|virtual
name|section_iterator
name|section_begin
argument_list|()
specifier|const
operator|=
literal|0
decl_stmt|;
name|virtual
name|section_iterator
name|section_end
argument_list|()
specifier|const
operator|=
literal|0
expr_stmt|;
typedef|typedef
name|iterator_range
operator|<
name|section_iterator
operator|>
name|section_iterator_range
expr_stmt|;
name|section_iterator_range
name|sections
argument_list|()
specifier|const
block|{
return|return
name|section_iterator_range
argument_list|(
name|section_begin
argument_list|()
argument_list|,
name|section_end
argument_list|()
argument_list|)
return|;
block|}
comment|/// @brief The number of bytes used to represent an address in this object
comment|///        file format.
name|virtual
name|uint8_t
name|getBytesInAddress
argument_list|()
specifier|const
operator|=
literal|0
expr_stmt|;
name|virtual
name|StringRef
name|getFileFormatName
argument_list|()
specifier|const
operator|=
literal|0
expr_stmt|;
name|virtual
comment|/* Triple::ArchType */
name|unsigned
name|getArch
argument_list|()
specifier|const
operator|=
literal|0
expr_stmt|;
comment|/// Returns platform-specific object flags, if any.
name|virtual
name|std
operator|::
name|error_code
name|getPlatformFlags
argument_list|(
argument|unsigned&Result
argument_list|)
specifier|const
block|{
name|Result
operator|=
literal|0
block|;
return|return
name|object_error
operator|::
name|invalid_file_type
return|;
block|}
comment|/// True if this is a relocatable object (.o/.obj).
name|virtual
name|bool
name|isRelocatableObject
argument_list|()
specifier|const
operator|=
literal|0
expr_stmt|;
comment|/// @returns Pointer to ObjectFile subclass to handle this type of object.
comment|/// @param ObjectPath The path to the object file. ObjectPath.isObject must
comment|///        return true.
comment|/// @brief Create ObjectFile from path.
specifier|static
name|ErrorOr
operator|<
name|OwningBinary
operator|<
name|ObjectFile
operator|>>
name|createObjectFile
argument_list|(
argument|StringRef ObjectPath
argument_list|)
expr_stmt|;
specifier|static
name|ErrorOr
operator|<
name|std
operator|::
name|unique_ptr
operator|<
name|ObjectFile
operator|>>
name|createObjectFile
argument_list|(
argument|MemoryBufferRef Object
argument_list|,
argument|sys::fs::file_magic Type
argument_list|)
expr_stmt|;
specifier|static
name|ErrorOr
operator|<
name|std
operator|::
name|unique_ptr
operator|<
name|ObjectFile
operator|>>
name|createObjectFile
argument_list|(
argument|MemoryBufferRef Object
argument_list|)
block|{
return|return
name|createObjectFile
argument_list|(
name|Object
argument_list|,
name|sys
operator|::
name|fs
operator|::
name|file_magic
operator|::
name|unknown
argument_list|)
return|;
block|}
specifier|static
specifier|inline
name|bool
name|classof
parameter_list|(
specifier|const
name|Binary
modifier|*
name|v
parameter_list|)
block|{
return|return
name|v
operator|->
name|isObject
argument_list|()
return|;
block|}
specifier|static
name|ErrorOr
operator|<
name|std
operator|::
name|unique_ptr
operator|<
name|COFFObjectFile
operator|>>
name|createCOFFObjectFile
argument_list|(
argument|MemoryBufferRef Object
argument_list|)
expr_stmt|;
specifier|static
name|ErrorOr
operator|<
name|std
operator|::
name|unique_ptr
operator|<
name|ObjectFile
operator|>>
name|createELFObjectFile
argument_list|(
argument|MemoryBufferRef Object
argument_list|)
expr_stmt|;
specifier|static
name|ErrorOr
operator|<
name|std
operator|::
name|unique_ptr
operator|<
name|MachOObjectFile
operator|>>
name|createMachOObjectFile
argument_list|(
argument|MemoryBufferRef Object
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
comment|// Inline function definitions.
specifier|inline
name|SymbolRef
operator|::
name|SymbolRef
argument_list|(
argument|DataRefImpl SymbolP
argument_list|,
argument|const ObjectFile *Owner
argument_list|)
operator|:
name|BasicSymbolRef
argument_list|(
argument|SymbolP
argument_list|,
argument|Owner
argument_list|)
block|{}
specifier|inline
name|ErrorOr
operator|<
name|StringRef
operator|>
name|SymbolRef
operator|::
name|getName
argument_list|()
specifier|const
block|{
return|return
name|getObject
argument_list|()
operator|->
name|getSymbolName
argument_list|(
name|getRawDataRefImpl
argument_list|()
argument_list|)
return|;
block|}
specifier|inline
name|ErrorOr
operator|<
name|uint64_t
operator|>
name|SymbolRef
operator|::
name|getAddress
argument_list|()
specifier|const
block|{
return|return
name|getObject
argument_list|()
operator|->
name|getSymbolAddress
argument_list|(
name|getRawDataRefImpl
argument_list|()
argument_list|)
return|;
block|}
specifier|inline
name|uint64_t
name|SymbolRef
operator|::
name|getValue
argument_list|()
specifier|const
block|{
return|return
name|getObject
argument_list|()
operator|->
name|getSymbolValue
argument_list|(
name|getRawDataRefImpl
argument_list|()
argument_list|)
return|;
block|}
specifier|inline
name|uint32_t
name|SymbolRef
operator|::
name|getAlignment
argument_list|()
specifier|const
block|{
return|return
name|getObject
argument_list|()
operator|->
name|getSymbolAlignment
argument_list|(
name|getRawDataRefImpl
argument_list|()
argument_list|)
return|;
block|}
specifier|inline
name|uint64_t
name|SymbolRef
operator|::
name|getCommonSize
argument_list|()
specifier|const
block|{
return|return
name|getObject
argument_list|()
operator|->
name|getCommonSymbolSize
argument_list|(
name|getRawDataRefImpl
argument_list|()
argument_list|)
return|;
block|}
specifier|inline
name|ErrorOr
operator|<
name|section_iterator
operator|>
name|SymbolRef
operator|::
name|getSection
argument_list|()
specifier|const
block|{
return|return
name|getObject
argument_list|()
operator|->
name|getSymbolSection
argument_list|(
name|getRawDataRefImpl
argument_list|()
argument_list|)
return|;
block|}
specifier|inline
name|SymbolRef
operator|::
name|Type
name|SymbolRef
operator|::
name|getType
argument_list|()
specifier|const
block|{
return|return
name|getObject
argument_list|()
operator|->
name|getSymbolType
argument_list|(
name|getRawDataRefImpl
argument_list|()
argument_list|)
return|;
block|}
specifier|inline
specifier|const
name|ObjectFile
operator|*
name|SymbolRef
operator|::
name|getObject
argument_list|()
specifier|const
block|{
specifier|const
name|SymbolicFile
operator|*
name|O
operator|=
name|BasicSymbolRef
operator|::
name|getObject
argument_list|()
block|;
return|return
name|cast
operator|<
name|ObjectFile
operator|>
operator|(
name|O
operator|)
return|;
block|}
comment|/// SectionRef
specifier|inline
name|SectionRef
operator|::
name|SectionRef
argument_list|(
argument|DataRefImpl SectionP
argument_list|,
argument|const ObjectFile *Owner
argument_list|)
operator|:
name|SectionPimpl
argument_list|(
name|SectionP
argument_list|)
operator|,
name|OwningObject
argument_list|(
argument|Owner
argument_list|)
block|{}
specifier|inline
name|bool
name|SectionRef
operator|::
name|operator
operator|==
operator|(
specifier|const
name|SectionRef
operator|&
name|Other
operator|)
specifier|const
block|{
return|return
name|SectionPimpl
operator|==
name|Other
operator|.
name|SectionPimpl
return|;
block|}
specifier|inline
name|bool
name|SectionRef
operator|::
name|operator
operator|!=
operator|(
specifier|const
name|SectionRef
operator|&
name|Other
operator|)
specifier|const
block|{
return|return
name|SectionPimpl
operator|!=
name|Other
operator|.
name|SectionPimpl
return|;
block|}
specifier|inline
name|bool
name|SectionRef
operator|::
name|operator
operator|<
operator|(
specifier|const
name|SectionRef
operator|&
name|Other
operator|)
specifier|const
block|{
return|return
name|SectionPimpl
operator|<
name|Other
operator|.
name|SectionPimpl
return|;
block|}
specifier|inline
name|void
name|SectionRef
operator|::
name|moveNext
argument_list|()
block|{
return|return
name|OwningObject
operator|->
name|moveSectionNext
argument_list|(
name|SectionPimpl
argument_list|)
return|;
block|}
specifier|inline
name|std
operator|::
name|error_code
name|SectionRef
operator|::
name|getName
argument_list|(
argument|StringRef&Result
argument_list|)
specifier|const
block|{
return|return
name|OwningObject
operator|->
name|getSectionName
argument_list|(
name|SectionPimpl
argument_list|,
name|Result
argument_list|)
return|;
block|}
specifier|inline
name|uint64_t
name|SectionRef
operator|::
name|getAddress
argument_list|()
specifier|const
block|{
return|return
name|OwningObject
operator|->
name|getSectionAddress
argument_list|(
name|SectionPimpl
argument_list|)
return|;
block|}
specifier|inline
name|uint64_t
name|SectionRef
operator|::
name|getSize
argument_list|()
specifier|const
block|{
return|return
name|OwningObject
operator|->
name|getSectionSize
argument_list|(
name|SectionPimpl
argument_list|)
return|;
block|}
specifier|inline
name|std
operator|::
name|error_code
name|SectionRef
operator|::
name|getContents
argument_list|(
argument|StringRef&Result
argument_list|)
specifier|const
block|{
return|return
name|OwningObject
operator|->
name|getSectionContents
argument_list|(
name|SectionPimpl
argument_list|,
name|Result
argument_list|)
return|;
block|}
specifier|inline
name|uint64_t
name|SectionRef
operator|::
name|getAlignment
argument_list|()
specifier|const
block|{
return|return
name|OwningObject
operator|->
name|getSectionAlignment
argument_list|(
name|SectionPimpl
argument_list|)
return|;
block|}
specifier|inline
name|bool
name|SectionRef
operator|::
name|isText
argument_list|()
specifier|const
block|{
return|return
name|OwningObject
operator|->
name|isSectionText
argument_list|(
name|SectionPimpl
argument_list|)
return|;
block|}
specifier|inline
name|bool
name|SectionRef
operator|::
name|isData
argument_list|()
specifier|const
block|{
return|return
name|OwningObject
operator|->
name|isSectionData
argument_list|(
name|SectionPimpl
argument_list|)
return|;
block|}
specifier|inline
name|bool
name|SectionRef
operator|::
name|isBSS
argument_list|()
specifier|const
block|{
return|return
name|OwningObject
operator|->
name|isSectionBSS
argument_list|(
name|SectionPimpl
argument_list|)
return|;
block|}
specifier|inline
name|bool
name|SectionRef
operator|::
name|isVirtual
argument_list|()
specifier|const
block|{
return|return
name|OwningObject
operator|->
name|isSectionVirtual
argument_list|(
name|SectionPimpl
argument_list|)
return|;
block|}
specifier|inline
name|relocation_iterator
name|SectionRef
operator|::
name|relocation_begin
argument_list|()
specifier|const
block|{
return|return
name|OwningObject
operator|->
name|section_rel_begin
argument_list|(
name|SectionPimpl
argument_list|)
return|;
block|}
specifier|inline
name|relocation_iterator
name|SectionRef
operator|::
name|relocation_end
argument_list|()
specifier|const
block|{
return|return
name|OwningObject
operator|->
name|section_rel_end
argument_list|(
name|SectionPimpl
argument_list|)
return|;
block|}
specifier|inline
name|section_iterator
name|SectionRef
operator|::
name|getRelocatedSection
argument_list|()
specifier|const
block|{
return|return
name|OwningObject
operator|->
name|getRelocatedSection
argument_list|(
name|SectionPimpl
argument_list|)
return|;
block|}
specifier|inline
name|DataRefImpl
name|SectionRef
operator|::
name|getRawDataRefImpl
argument_list|()
specifier|const
block|{
return|return
name|SectionPimpl
return|;
block|}
specifier|inline
specifier|const
name|ObjectFile
operator|*
name|SectionRef
operator|::
name|getObject
argument_list|()
specifier|const
block|{
return|return
name|OwningObject
return|;
block|}
comment|/// RelocationRef
specifier|inline
name|RelocationRef
operator|::
name|RelocationRef
argument_list|(
argument|DataRefImpl RelocationP
argument_list|,
argument|const ObjectFile *Owner
argument_list|)
operator|:
name|RelocationPimpl
argument_list|(
name|RelocationP
argument_list|)
operator|,
name|OwningObject
argument_list|(
argument|Owner
argument_list|)
block|{}
specifier|inline
name|bool
name|RelocationRef
operator|::
name|operator
operator|==
operator|(
specifier|const
name|RelocationRef
operator|&
name|Other
operator|)
specifier|const
block|{
return|return
name|RelocationPimpl
operator|==
name|Other
operator|.
name|RelocationPimpl
return|;
block|}
specifier|inline
name|void
name|RelocationRef
operator|::
name|moveNext
argument_list|()
block|{
return|return
name|OwningObject
operator|->
name|moveRelocationNext
argument_list|(
name|RelocationPimpl
argument_list|)
return|;
block|}
specifier|inline
name|uint64_t
name|RelocationRef
operator|::
name|getOffset
argument_list|()
specifier|const
block|{
return|return
name|OwningObject
operator|->
name|getRelocationOffset
argument_list|(
name|RelocationPimpl
argument_list|)
return|;
block|}
specifier|inline
name|symbol_iterator
name|RelocationRef
operator|::
name|getSymbol
argument_list|()
specifier|const
block|{
return|return
name|OwningObject
operator|->
name|getRelocationSymbol
argument_list|(
name|RelocationPimpl
argument_list|)
return|;
block|}
specifier|inline
name|uint64_t
name|RelocationRef
operator|::
name|getType
argument_list|()
specifier|const
block|{
return|return
name|OwningObject
operator|->
name|getRelocationType
argument_list|(
name|RelocationPimpl
argument_list|)
return|;
block|}
specifier|inline
name|void
name|RelocationRef
operator|::
name|getTypeName
argument_list|(
argument|SmallVectorImpl<char>&Result
argument_list|)
specifier|const
block|{
return|return
name|OwningObject
operator|->
name|getRelocationTypeName
argument_list|(
name|RelocationPimpl
argument_list|,
name|Result
argument_list|)
return|;
block|}
specifier|inline
name|DataRefImpl
name|RelocationRef
operator|::
name|getRawDataRefImpl
argument_list|()
specifier|const
block|{
return|return
name|RelocationPimpl
return|;
block|}
specifier|inline
specifier|const
name|ObjectFile
operator|*
name|RelocationRef
operator|::
name|getObject
argument_list|()
specifier|const
block|{
return|return
name|OwningObject
return|;
block|}
block|}
end_decl_stmt

begin_comment
comment|// end namespace object
end_comment

begin_comment
unit|}
comment|// end namespace llvm
end_comment

begin_endif
endif|#
directive|endif
end_endif

end_unit

