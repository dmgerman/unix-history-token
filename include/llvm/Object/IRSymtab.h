begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===- IRSymtab.h - data definitions for IR symbol tables -------*- C++ -*-===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file contains data definitions and a reader and builder for a symbol
end_comment

begin_comment
comment|// table for LLVM IR. Its purpose is to allow linkers and other consumers of
end_comment

begin_comment
comment|// bitcode files to efficiently read the symbol table for symbol resolution
end_comment

begin_comment
comment|// purposes without needing to construct a module in memory.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// As with most object files the symbol table has two parts: the symbol table
end_comment

begin_comment
comment|// itself and a string table which is referenced by the symbol table.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// A symbol table corresponds to a single bitcode file, which may consist of
end_comment

begin_comment
comment|// multiple modules, so symbol tables may likewise contain symbols for multiple
end_comment

begin_comment
comment|// modules.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LLVM_OBJECT_IRSYMTAB_H
end_ifndef

begin_define
define|#
directive|define
name|LLVM_OBJECT_IRSYMTAB_H
end_define

begin_include
include|#
directive|include
file|"llvm/ADT/ArrayRef.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/iterator_range.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/StringRef.h"
end_include

begin_include
include|#
directive|include
file|"llvm/IR/GlobalValue.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Object/SymbolicFile.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/Endian.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/Error.h"
end_include

begin_include
include|#
directive|include
file|<cassert>
end_include

begin_include
include|#
directive|include
file|<cstdint>
end_include

begin_include
include|#
directive|include
file|<vector>
end_include

begin_decl_stmt
name|namespace
name|llvm
block|{
name|namespace
name|irsymtab
block|{
name|namespace
name|storage
block|{
comment|// The data structures in this namespace define the low-level serialization
comment|// format. Clients that just want to read a symbol table should use the
comment|// irsymtab::Reader class.
name|using
name|Word
init|=
name|support
operator|::
name|ulittle32_t
decl_stmt|;
comment|/// A reference to a string in the string table.
struct|struct
name|Str
block|{
name|Word
name|Offset
decl_stmt|,
name|Size
decl_stmt|;
name|StringRef
name|get
argument_list|(
name|StringRef
name|Strtab
argument_list|)
decl|const
block|{
return|return
block|{
name|Strtab
operator|.
name|data
argument_list|()
operator|+
name|Offset
block|,
name|Size
block|}
return|;
block|}
block|}
struct|;
comment|/// A reference to a range of objects in the symbol table.
name|template
operator|<
name|typename
name|T
operator|>
expr|struct
name|Range
block|{
name|Word
name|Offset
block|,
name|Size
block|;
name|ArrayRef
operator|<
name|T
operator|>
name|get
argument_list|(
argument|StringRef Symtab
argument_list|)
specifier|const
block|{
return|return
block|{
name|reinterpret_cast
operator|<
specifier|const
name|T
operator|*
operator|>
operator|(
name|Symtab
operator|.
name|data
argument_list|()
operator|+
name|Offset
operator|)
block|,
name|Size
block|}
return|;
block|}
expr|}
block|;
comment|/// Describes the range of a particular module's symbols within the symbol
comment|/// table.
block|struct
name|Module
block|{
name|Word
name|Begin
block|,
name|End
block|;
comment|/// The index of the first Uncommon for this Module.
name|Word
name|UncBegin
block|; }
block|;
comment|/// This is equivalent to an IR comdat.
block|struct
name|Comdat
block|{
name|Str
name|Name
block|; }
block|;
comment|/// Contains the information needed by linkers for symbol resolution, as well as
comment|/// by the LTO implementation itself.
block|struct
name|Symbol
block|{
comment|/// The mangled symbol name.
name|Str
name|Name
block|;
comment|/// The unmangled symbol name, or the empty string if this is not an IR
comment|/// symbol.
name|Str
name|IRName
block|;
comment|/// The index into Header::Comdats, or -1 if not a comdat member.
name|Word
name|ComdatIndex
block|;
name|Word
name|Flags
block|;   enum
name|FlagBits
block|{
name|FB_visibility
block|,
comment|// 2 bits
name|FB_has_uncommon
operator|=
name|FB_visibility
operator|+
literal|2
block|,
name|FB_undefined
block|,
name|FB_weak
block|,
name|FB_common
block|,
name|FB_indirect
block|,
name|FB_used
block|,
name|FB_tls
block|,
name|FB_may_omit
block|,
name|FB_global
block|,
name|FB_format_specific
block|,
name|FB_unnamed_addr
block|,
name|FB_executable
block|,   }
block|; }
block|;
comment|/// This data structure contains rarely used symbol fields and is optionally
comment|/// referenced by a Symbol.
block|struct
name|Uncommon
block|{
name|Word
name|CommonSize
block|,
name|CommonAlign
block|;
comment|/// COFF-specific: the name of the symbol that a weak external resolves to
comment|/// if not defined.
name|Str
name|COFFWeakExternFallbackName
block|; }
block|;  struct
name|Header
block|{
name|Range
operator|<
name|Module
operator|>
name|Modules
block|;
name|Range
operator|<
name|Comdat
operator|>
name|Comdats
block|;
name|Range
operator|<
name|Symbol
operator|>
name|Symbols
block|;
name|Range
operator|<
name|Uncommon
operator|>
name|Uncommons
block|;
name|Str
name|TargetTriple
block|,
name|SourceFileName
block|;
comment|/// COFF-specific: linker directives.
name|Str
name|COFFLinkerOpts
block|; }
block|;  }
comment|// end namespace storage
comment|/// Fills in Symtab and Strtab with a valid symbol and string table for Mods.
name|Error
name|build
argument_list|(
name|ArrayRef
operator|<
name|Module
operator|*
operator|>
name|Mods
argument_list|,
name|SmallVector
operator|<
name|char
argument_list|,
literal|0
operator|>
operator|&
name|Symtab
argument_list|,
name|SmallVector
operator|<
name|char
argument_list|,
literal|0
operator|>
operator|&
name|Strtab
argument_list|)
expr_stmt|;
comment|/// This represents a symbol that has been read from a storage::Symbol and
comment|/// possibly a storage::Uncommon.
struct|struct
name|Symbol
block|{
comment|// Copied from storage::Symbol.
name|StringRef
name|Name
decl_stmt|,
name|IRName
decl_stmt|;
name|int
name|ComdatIndex
decl_stmt|;
name|uint32_t
name|Flags
decl_stmt|;
comment|// Copied from storage::Uncommon.
name|uint32_t
name|CommonSize
decl_stmt|,
name|CommonAlign
decl_stmt|;
name|StringRef
name|COFFWeakExternFallbackName
decl_stmt|;
comment|/// Returns the mangled symbol name.
name|StringRef
name|getName
argument_list|()
specifier|const
block|{
return|return
name|Name
return|;
block|}
comment|/// Returns the unmangled symbol name, or the empty string if this is not an
comment|/// IR symbol.
name|StringRef
name|getIRName
argument_list|()
specifier|const
block|{
return|return
name|IRName
return|;
block|}
comment|/// Returns the index into the comdat table (see Reader::getComdatTable()), or
comment|/// -1 if not a comdat member.
name|int
name|getComdatIndex
argument_list|()
specifier|const
block|{
return|return
name|ComdatIndex
return|;
block|}
name|using
name|S
init|=
name|storage
operator|::
name|Symbol
decl_stmt|;
name|GlobalValue
operator|::
name|VisibilityTypes
name|getVisibility
argument_list|()
specifier|const
block|{
return|return
name|GlobalValue
operator|::
name|VisibilityTypes
argument_list|(
operator|(
name|Flags
operator|>>
name|S
operator|::
name|FB_visibility
operator|)
operator|&
literal|3
argument_list|)
return|;
block|}
name|bool
name|isUndefined
argument_list|()
specifier|const
block|{
return|return
operator|(
name|Flags
operator|>>
name|S
operator|::
name|FB_undefined
operator|)
operator|&
literal|1
return|;
block|}
name|bool
name|isWeak
argument_list|()
specifier|const
block|{
return|return
operator|(
name|Flags
operator|>>
name|S
operator|::
name|FB_weak
operator|)
operator|&
literal|1
return|;
block|}
name|bool
name|isCommon
argument_list|()
specifier|const
block|{
return|return
operator|(
name|Flags
operator|>>
name|S
operator|::
name|FB_common
operator|)
operator|&
literal|1
return|;
block|}
name|bool
name|isIndirect
argument_list|()
specifier|const
block|{
return|return
operator|(
name|Flags
operator|>>
name|S
operator|::
name|FB_indirect
operator|)
operator|&
literal|1
return|;
block|}
name|bool
name|isUsed
argument_list|()
specifier|const
block|{
return|return
operator|(
name|Flags
operator|>>
name|S
operator|::
name|FB_used
operator|)
operator|&
literal|1
return|;
block|}
name|bool
name|isTLS
argument_list|()
specifier|const
block|{
return|return
operator|(
name|Flags
operator|>>
name|S
operator|::
name|FB_tls
operator|)
operator|&
literal|1
return|;
block|}
name|bool
name|canBeOmittedFromSymbolTable
argument_list|()
specifier|const
block|{
return|return
operator|(
name|Flags
operator|>>
name|S
operator|::
name|FB_may_omit
operator|)
operator|&
literal|1
return|;
block|}
name|bool
name|isGlobal
argument_list|()
specifier|const
block|{
return|return
operator|(
name|Flags
operator|>>
name|S
operator|::
name|FB_global
operator|)
operator|&
literal|1
return|;
block|}
name|bool
name|isFormatSpecific
argument_list|()
specifier|const
block|{
return|return
operator|(
name|Flags
operator|>>
name|S
operator|::
name|FB_format_specific
operator|)
operator|&
literal|1
return|;
block|}
name|bool
name|isUnnamedAddr
argument_list|()
specifier|const
block|{
return|return
operator|(
name|Flags
operator|>>
name|S
operator|::
name|FB_unnamed_addr
operator|)
operator|&
literal|1
return|;
block|}
name|bool
name|isExecutable
argument_list|()
specifier|const
block|{
return|return
operator|(
name|Flags
operator|>>
name|S
operator|::
name|FB_executable
operator|)
operator|&
literal|1
return|;
block|}
name|uint64_t
name|getCommonSize
argument_list|()
specifier|const
block|{
name|assert
argument_list|(
name|isCommon
argument_list|()
argument_list|)
block|;
return|return
name|CommonSize
return|;
block|}
name|uint32_t
name|getCommonAlignment
argument_list|()
specifier|const
block|{
name|assert
argument_list|(
name|isCommon
argument_list|()
argument_list|)
block|;
return|return
name|CommonAlign
return|;
block|}
comment|/// COFF-specific: for weak externals, returns the name of the symbol that is
comment|/// used as a fallback if the weak external remains undefined.
name|StringRef
name|getCOFFWeakExternalFallback
argument_list|()
specifier|const
block|{
name|assert
argument_list|(
name|isWeak
argument_list|()
operator|&&
name|isIndirect
argument_list|()
argument_list|)
block|;
return|return
name|COFFWeakExternFallbackName
return|;
block|}
block|}
struct|;
comment|/// This class can be used to read a Symtab and Strtab produced by
comment|/// irsymtab::build.
name|class
name|Reader
block|{
name|StringRef
name|Symtab
decl_stmt|,
name|Strtab
decl_stmt|;
name|ArrayRef
operator|<
name|storage
operator|::
name|Module
operator|>
name|Modules
expr_stmt|;
name|ArrayRef
operator|<
name|storage
operator|::
name|Comdat
operator|>
name|Comdats
expr_stmt|;
name|ArrayRef
operator|<
name|storage
operator|::
name|Symbol
operator|>
name|Symbols
expr_stmt|;
name|ArrayRef
operator|<
name|storage
operator|::
name|Uncommon
operator|>
name|Uncommons
expr_stmt|;
name|StringRef
name|str
argument_list|(
name|storage
operator|::
name|Str
name|S
argument_list|)
decl|const
block|{
return|return
name|S
operator|.
name|get
argument_list|(
name|Strtab
argument_list|)
return|;
block|}
name|template
operator|<
name|typename
name|T
operator|>
name|ArrayRef
operator|<
name|T
operator|>
name|range
argument_list|(
argument|storage::Range<T> R
argument_list|)
specifier|const
block|{
return|return
name|R
operator|.
name|get
argument_list|(
name|Symtab
argument_list|)
return|;
block|}
specifier|const
name|storage
operator|::
name|Header
operator|&
name|header
argument_list|()
specifier|const
block|{
return|return
operator|*
name|reinterpret_cast
operator|<
specifier|const
name|storage
operator|::
name|Header
operator|*
operator|>
operator|(
name|Symtab
operator|.
name|data
argument_list|()
operator|)
return|;
block|}
name|public
label|:
name|class
name|SymbolRef
decl_stmt|;
name|Reader
argument_list|()
operator|=
expr|default
expr_stmt|;
name|Reader
argument_list|(
argument|StringRef Symtab
argument_list|,
argument|StringRef Strtab
argument_list|)
block|:
name|Symtab
argument_list|(
name|Symtab
argument_list|)
operator|,
name|Strtab
argument_list|(
argument|Strtab
argument_list|)
block|{
name|Modules
operator|=
name|range
argument_list|(
name|header
argument_list|()
operator|.
name|Modules
argument_list|)
block|;
name|Comdats
operator|=
name|range
argument_list|(
name|header
argument_list|()
operator|.
name|Comdats
argument_list|)
block|;
name|Symbols
operator|=
name|range
argument_list|(
name|header
argument_list|()
operator|.
name|Symbols
argument_list|)
block|;
name|Uncommons
operator|=
name|range
argument_list|(
name|header
argument_list|()
operator|.
name|Uncommons
argument_list|)
block|;   }
name|using
name|symbol_range
operator|=
name|iterator_range
operator|<
name|object
operator|::
name|content_iterator
operator|<
name|SymbolRef
operator|>>
expr_stmt|;
comment|/// Returns the symbol table for the entire bitcode file.
comment|/// The symbols enumerated by this method are ephemeral, but they can be
comment|/// copied into an irsymtab::Symbol object.
name|symbol_range
name|symbols
argument_list|()
specifier|const
expr_stmt|;
comment|/// Returns a slice of the symbol table for the I'th module in the file.
comment|/// The symbols enumerated by this method are ephemeral, but they can be
comment|/// copied into an irsymtab::Symbol object.
name|symbol_range
name|module_symbols
argument_list|(
name|unsigned
name|I
argument_list|)
decl|const
decl_stmt|;
name|StringRef
name|getTargetTriple
argument_list|()
specifier|const
block|{
return|return
name|str
argument_list|(
name|header
argument_list|()
operator|.
name|TargetTriple
argument_list|)
return|;
block|}
comment|/// Returns the source file path specified at compile time.
name|StringRef
name|getSourceFileName
argument_list|()
specifier|const
block|{
return|return
name|str
argument_list|(
name|header
argument_list|()
operator|.
name|SourceFileName
argument_list|)
return|;
block|}
comment|/// Returns a table with all the comdats used by this file.
name|std
operator|::
name|vector
operator|<
name|StringRef
operator|>
name|getComdatTable
argument_list|()
specifier|const
block|{
name|std
operator|::
name|vector
operator|<
name|StringRef
operator|>
name|ComdatTable
block|;
name|ComdatTable
operator|.
name|reserve
argument_list|(
name|Comdats
operator|.
name|size
argument_list|()
argument_list|)
block|;
for|for
control|(
name|auto
name|C
range|:
name|Comdats
control|)
name|ComdatTable
operator|.
name|push_back
argument_list|(
name|str
argument_list|(
name|C
operator|.
name|Name
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|ComdatTable
return|;
block|}
comment|/// COFF-specific: returns linker options specified in the input file.
name|StringRef
name|getCOFFLinkerOpts
argument_list|()
specifier|const
block|{
return|return
name|str
argument_list|(
name|header
argument_list|()
operator|.
name|COFFLinkerOpts
argument_list|)
return|;
block|}
block|}
empty_stmt|;
comment|/// Ephemeral symbols produced by Reader::symbols() and
comment|/// Reader::module_symbols().
name|class
name|Reader
operator|::
name|SymbolRef
operator|:
name|public
name|Symbol
block|{
specifier|const
name|storage
operator|::
name|Symbol
operator|*
name|SymI
block|,
operator|*
name|SymE
block|;
specifier|const
name|storage
operator|::
name|Uncommon
operator|*
name|UncI
block|;
specifier|const
name|Reader
operator|*
name|R
block|;
name|void
name|read
argument_list|()
block|{
if|if
condition|(
name|SymI
operator|==
name|SymE
condition|)
return|return;
name|Name
operator|=
name|R
operator|->
name|str
argument_list|(
name|SymI
operator|->
name|Name
argument_list|)
block|;
name|IRName
operator|=
name|R
operator|->
name|str
argument_list|(
name|SymI
operator|->
name|IRName
argument_list|)
block|;
name|ComdatIndex
operator|=
name|SymI
operator|->
name|ComdatIndex
block|;
name|Flags
operator|=
name|SymI
operator|->
name|Flags
block|;
if|if
condition|(
name|Flags
operator|&
operator|(
literal|1
operator|<<
name|storage
operator|::
name|Symbol
operator|::
name|FB_has_uncommon
operator|)
condition|)
block|{
name|CommonSize
operator|=
name|UncI
operator|->
name|CommonSize
expr_stmt|;
name|CommonAlign
operator|=
name|UncI
operator|->
name|CommonAlign
expr_stmt|;
name|COFFWeakExternFallbackName
operator|=
name|R
operator|->
name|str
argument_list|(
name|UncI
operator|->
name|COFFWeakExternFallbackName
argument_list|)
expr_stmt|;
block|}
block|}
name|public
operator|:
name|SymbolRef
argument_list|(
specifier|const
name|storage
operator|::
name|Symbol
operator|*
name|SymI
argument_list|,
specifier|const
name|storage
operator|::
name|Symbol
operator|*
name|SymE
argument_list|,
specifier|const
name|storage
operator|::
name|Uncommon
operator|*
name|UncI
argument_list|,
specifier|const
name|Reader
operator|*
name|R
argument_list|)
operator|:
name|SymI
argument_list|(
name|SymI
argument_list|)
operator|,
name|SymE
argument_list|(
name|SymE
argument_list|)
operator|,
name|UncI
argument_list|(
name|UncI
argument_list|)
operator|,
name|R
argument_list|(
argument|R
argument_list|)
block|{
name|read
argument_list|()
block|;   }
name|void
name|moveNext
argument_list|()
block|{
operator|++
name|SymI
block|;
if|if
condition|(
name|Flags
operator|&
operator|(
literal|1
operator|<<
name|storage
operator|::
name|Symbol
operator|::
name|FB_has_uncommon
operator|)
condition|)
operator|++
name|UncI
expr_stmt|;
name|read
argument_list|()
expr_stmt|;
block|}
name|bool
name|operator
operator|==
operator|(
specifier|const
name|SymbolRef
operator|&
name|Other
operator|)
specifier|const
block|{
return|return
name|SymI
operator|==
name|Other
operator|.
name|SymI
return|;
block|}
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_expr_stmt
specifier|inline
name|Reader
operator|::
name|symbol_range
name|Reader
operator|::
name|symbols
argument_list|()
specifier|const
block|{
return|return
block|{
name|SymbolRef
argument_list|(
name|Symbols
operator|.
name|begin
argument_list|()
argument_list|,
name|Symbols
operator|.
name|end
argument_list|()
argument_list|,
name|Uncommons
operator|.
name|begin
argument_list|()
argument_list|,
name|this
argument_list|)
block|,
name|SymbolRef
argument_list|(
argument|Symbols.end()
argument_list|,
argument|Symbols.end()
argument_list|,
argument|nullptr
argument_list|,
argument|this
argument_list|)
block|}
return|;
block|}
end_expr_stmt

begin_expr_stmt
specifier|inline
name|Reader
operator|::
name|symbol_range
name|Reader
operator|::
name|module_symbols
argument_list|(
argument|unsigned I
argument_list|)
specifier|const
block|{
specifier|const
name|storage
operator|::
name|Module
operator|&
name|M
operator|=
name|Modules
index|[
name|I
index|]
block|;
specifier|const
name|storage
operator|::
name|Symbol
operator|*
name|MBegin
operator|=
name|Symbols
operator|.
name|begin
argument_list|()
operator|+
name|M
operator|.
name|Begin
block|,
operator|*
name|MEnd
operator|=
name|Symbols
operator|.
name|begin
argument_list|()
operator|+
name|M
operator|.
name|End
block|;
return|return
block|{
name|SymbolRef
argument_list|(
name|MBegin
argument_list|,
name|MEnd
argument_list|,
name|Uncommons
operator|.
name|begin
argument_list|()
operator|+
name|M
operator|.
name|UncBegin
argument_list|,
name|this
argument_list|)
block|,
name|SymbolRef
argument_list|(
argument|MEnd
argument_list|,
argument|MEnd
argument_list|,
argument|nullptr
argument_list|,
argument|this
argument_list|)
block|}
return|;
block|}
end_expr_stmt

begin_comment
unit|}
comment|// end namespace irsymtab
end_comment

begin_comment
unit|}
comment|// end namespace llvm
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|// LLVM_OBJECT_IRSYMTAB_H
end_comment

end_unit

