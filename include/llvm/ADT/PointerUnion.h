begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===- llvm/ADT/PointerUnion.h - Discriminated Union of 2 Ptrs --*- C++ -*-===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file defines the PointerUnion class, which is a discriminated union of
end_comment

begin_comment
comment|// pointer types.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LLVM_ADT_POINTERUNION_H
end_ifndef

begin_define
define|#
directive|define
name|LLVM_ADT_POINTERUNION_H
end_define

begin_include
include|#
directive|include
file|"llvm/ADT/DenseMapInfo.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/PointerIntPair.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/PointerLikeTypeTraits.h"
end_include

begin_include
include|#
directive|include
file|<cassert>
end_include

begin_include
include|#
directive|include
file|<cstdint>
end_include

begin_include
include|#
directive|include
file|<cstddef>
end_include

begin_decl_stmt
name|namespace
name|llvm
block|{
name|template
operator|<
name|typename
name|T
operator|>
expr|struct
name|PointerUnionTypeSelectorReturn
block|{
typedef|typedef
name|T
name|Return
typedef|;
block|}
empty_stmt|;
comment|/// Get a type based on whether two types are the same or not.
comment|///
comment|/// For:
comment|///
comment|/// \code
comment|///   typedef typename PointerUnionTypeSelector<T1, T2, EQ, NE>::Return Ret;
comment|/// \endcode
comment|///
comment|/// Ret will be EQ type if T1 is same as T2 or NE type otherwise.
name|template
operator|<
name|typename
name|T1
operator|,
name|typename
name|T2
operator|,
name|typename
name|RET_EQ
operator|,
name|typename
name|RET_NE
operator|>
expr|struct
name|PointerUnionTypeSelector
block|{
typedef|typedef
name|typename
name|PointerUnionTypeSelectorReturn
operator|<
name|RET_NE
operator|>
operator|::
name|Return
name|Return
expr_stmt|;
block|}
empty_stmt|;
name|template
operator|<
name|typename
name|T
operator|,
name|typename
name|RET_EQ
operator|,
name|typename
name|RET_NE
operator|>
expr|struct
name|PointerUnionTypeSelector
operator|<
name|T
operator|,
name|T
operator|,
name|RET_EQ
operator|,
name|RET_NE
operator|>
block|{
typedef|typedef
name|typename
name|PointerUnionTypeSelectorReturn
operator|<
name|RET_EQ
operator|>
operator|::
name|Return
name|Return
expr_stmt|;
block|}
empty_stmt|;
name|template
operator|<
name|typename
name|T1
operator|,
name|typename
name|T2
operator|,
name|typename
name|RET_EQ
operator|,
name|typename
name|RET_NE
operator|>
expr|struct
name|PointerUnionTypeSelectorReturn
operator|<
name|PointerUnionTypeSelector
operator|<
name|T1
operator|,
name|T2
operator|,
name|RET_EQ
operator|,
name|RET_NE
operator|>>
block|{
typedef|typedef
name|typename
name|PointerUnionTypeSelector
operator|<
name|T1
operator|,
name|T2
operator|,
name|RET_EQ
operator|,
name|RET_NE
operator|>
operator|::
name|Return
name|Return
expr_stmt|;
block|}
empty_stmt|;
comment|/// Provide PointerLikeTypeTraits for void* that is used by PointerUnion
comment|/// for the two template arguments.
name|template
operator|<
name|typename
name|PT1
operator|,
name|typename
name|PT2
operator|>
name|class
name|PointerUnionUIntTraits
block|{
name|public
operator|:
specifier|static
specifier|inline
name|void
operator|*
name|getAsVoidPointer
argument_list|(
argument|void *P
argument_list|)
block|{
return|return
name|P
return|;
block|}
specifier|static
specifier|inline
name|void
operator|*
name|getFromVoidPointer
argument_list|(
argument|void *P
argument_list|)
block|{
return|return
name|P
return|;
block|}
expr|enum
block|{
name|PT1BitsAv
operator|=
call|(
name|int
call|)
argument_list|(
name|PointerLikeTypeTraits
operator|<
name|PT1
operator|>
operator|::
name|NumLowBitsAvailable
argument_list|)
block|,
name|PT2BitsAv
operator|=
call|(
name|int
call|)
argument_list|(
name|PointerLikeTypeTraits
operator|<
name|PT2
operator|>
operator|::
name|NumLowBitsAvailable
argument_list|)
block|,
name|NumLowBitsAvailable
operator|=
name|PT1BitsAv
operator|<
name|PT2BitsAv
operator|?
name|PT1BitsAv
operator|:
name|PT2BitsAv
block|}
block|; }
expr_stmt|;
comment|/// A discriminated union of two pointer types, with the discriminator in the
comment|/// low bit of the pointer.
comment|///
comment|/// This implementation is extremely efficient in space due to leveraging the
comment|/// low bits of the pointer, while exposing a natural and type-safe API.
comment|///
comment|/// Common use patterns would be something like this:
comment|///    PointerUnion<int*, float*> P;
comment|///    P = (int*)0;
comment|///    printf("%d %d", P.is<int*>(), P.is<float*>());  // prints "1 0"
comment|///    X = P.get<int*>();     // ok.
comment|///    Y = P.get<float*>();   // runtime assertion failure.
comment|///    Z = P.get<double*>();  // compile time failure.
comment|///    P = (float*)0;
comment|///    Y = P.get<float*>();   // ok.
comment|///    X = P.get<int*>();     // runtime assertion failure.
name|template
operator|<
name|typename
name|PT1
operator|,
name|typename
name|PT2
operator|>
name|class
name|PointerUnion
block|{
name|public
operator|:
typedef|typedef
name|PointerIntPair
operator|<
name|void
operator|*
operator|,
literal|1
operator|,
name|bool
operator|,
name|PointerUnionUIntTraits
operator|<
name|PT1
operator|,
name|PT2
operator|>>
name|ValTy
expr_stmt|;
name|private
operator|:
name|ValTy
name|Val
expr_stmt|;
struct|struct
name|IsPT1
block|{
specifier|static
specifier|const
name|int
name|Num
init|=
literal|0
decl_stmt|;
block|}
struct|;
struct|struct
name|IsPT2
block|{
specifier|static
specifier|const
name|int
name|Num
init|=
literal|1
decl_stmt|;
block|}
struct|;
name|template
operator|<
name|typename
name|T
operator|>
expr|struct
name|UNION_DOESNT_CONTAIN_TYPE
block|{}
expr_stmt|;
name|public
label|:
name|PointerUnion
argument_list|()
operator|=
expr|default
expr_stmt|;
name|PointerUnion
argument_list|(
argument|PT1 V
argument_list|)
block|:
name|Val
argument_list|(
argument|const_cast<void *>(             PointerLikeTypeTraits<PT1>::getAsVoidPointer(V))
argument_list|)
block|{}
name|PointerUnion
argument_list|(
argument|PT2 V
argument_list|)
block|:
name|Val
argument_list|(
argument|const_cast<void *>(PointerLikeTypeTraits<PT2>::getAsVoidPointer(V))
argument_list|,
literal|1
argument_list|)
block|{}
comment|/// Test if the pointer held in the union is null, regardless of
comment|/// which type it is.
name|bool
name|isNull
argument_list|()
specifier|const
block|{
comment|// Convert from the void* to one of the pointer types, to make sure that
comment|// we recursively strip off low bits if we have a nested PointerUnion.
return|return
operator|!
name|PointerLikeTypeTraits
operator|<
name|PT1
operator|>
operator|::
name|getFromVoidPointer
argument_list|(
name|Val
operator|.
name|getPointer
argument_list|()
argument_list|)
return|;
block|}
name|explicit
name|operator
name|bool
argument_list|()
specifier|const
block|{
return|return
operator|!
name|isNull
argument_list|()
return|;
block|}
comment|/// Test if the Union currently holds the type matching T.
name|template
operator|<
name|typename
name|T
operator|>
name|int
name|is
argument_list|()
specifier|const
block|{
typedef|typedef
name|typename
operator|::
name|llvm
operator|::
name|PointerUnionTypeSelector
operator|<
name|PT1
operator|,
name|T
operator|,
name|IsPT1
operator|,
operator|::
name|llvm
operator|::
name|PointerUnionTypeSelector
operator|<
name|PT2
operator|,
name|T
operator|,
name|IsPT2
operator|,
name|UNION_DOESNT_CONTAIN_TYPE
operator|<
name|T
operator|>>>
operator|::
name|Return
name|Ty
expr_stmt|;
name|int
name|TyNo
operator|=
name|Ty
operator|::
name|Num
expr_stmt|;
return|return
name|static_cast
operator|<
name|int
operator|>
operator|(
name|Val
operator|.
name|getInt
argument_list|()
operator|)
operator|==
name|TyNo
return|;
block|}
end_decl_stmt

begin_comment
comment|/// Returns the value of the specified pointer type.
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|/// If the specified pointer type is incorrect, assert.
end_comment

begin_expr_stmt
name|template
operator|<
name|typename
name|T
operator|>
name|T
name|get
argument_list|()
specifier|const
block|{
name|assert
argument_list|(
name|is
operator|<
name|T
operator|>
operator|(
operator|)
operator|&&
literal|"Invalid accessor called"
argument_list|)
block|;
return|return
name|PointerLikeTypeTraits
operator|<
name|T
operator|>
operator|::
name|getFromVoidPointer
argument_list|(
name|Val
operator|.
name|getPointer
argument_list|()
argument_list|)
return|;
block|}
end_expr_stmt

begin_comment
comment|/// Returns the current pointer if it is of the specified pointer type,
end_comment

begin_comment
comment|/// otherwises returns null.
end_comment

begin_expr_stmt
name|template
operator|<
name|typename
name|T
operator|>
name|T
name|dyn_cast
argument_list|()
specifier|const
block|{
if|if
condition|(
name|is
operator|<
name|T
operator|>
operator|(
operator|)
condition|)
return|return
name|get
operator|<
name|T
operator|>
operator|(
operator|)
return|;
end_expr_stmt

begin_return
return|return
name|T
argument_list|()
return|;
end_return

begin_comment
unit|}
comment|/// If the union is set to the first pointer type get an address pointing to
end_comment

begin_comment
comment|/// it.
end_comment

begin_expr_stmt
unit|PT1
specifier|const
operator|*
name|getAddrOfPtr1
argument_list|()
specifier|const
block|{
return|return
name|const_cast
operator|<
name|PointerUnion
operator|*
operator|>
operator|(
name|this
operator|)
operator|->
name|getAddrOfPtr1
argument_list|()
return|;
block|}
end_expr_stmt

begin_comment
comment|/// If the union is set to the first pointer type get an address pointing to
end_comment

begin_comment
comment|/// it.
end_comment

begin_function
name|PT1
modifier|*
name|getAddrOfPtr1
parameter_list|()
block|{
name|assert
argument_list|(
name|is
operator|<
name|PT1
operator|>
operator|(
operator|)
operator|&&
literal|"Val is not the first pointer"
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|get
operator|<
name|PT1
operator|>
operator|(
operator|)
operator|==
name|Val
operator|.
name|getPointer
argument_list|()
operator|&&
literal|"Can't get the address because PointerLikeTypeTraits changes the ptr"
argument_list|)
expr_stmt|;
return|return
operator|(
name|PT1
operator|*
operator|)
name|Val
operator|.
name|getAddrOfPointer
argument_list|()
return|;
block|}
end_function

begin_comment
comment|/// Assignment from nullptr which just clears the union.
end_comment

begin_decl_stmt
specifier|const
name|PointerUnion
modifier|&
name|operator
init|=
operator|(
name|std
operator|::
name|nullptr_t
operator|)
block|{
name|Val
operator|.
name|initWithPointer
argument_list|(
name|nullptr
argument_list|)
block|;
return|return
operator|*
name|this
return|;
block|}
end_decl_stmt

begin_comment
comment|/// Assignment operators - Allow assigning into this union from either
end_comment

begin_comment
comment|/// pointer type, setting the discriminator to remember what it came from.
end_comment

begin_decl_stmt
specifier|const
name|PointerUnion
modifier|&
name|operator
init|=
operator|(
specifier|const
name|PT1
operator|&
name|RHS
operator|)
block|{
name|Val
operator|.
name|initWithPointer
argument_list|(
name|const_cast
operator|<
name|void
operator|*
operator|>
operator|(
name|PointerLikeTypeTraits
operator|<
name|PT1
operator|>
operator|::
name|getAsVoidPointer
argument_list|(
name|RHS
argument_list|)
operator|)
argument_list|)
block|;
return|return
operator|*
name|this
return|;
block|}
end_decl_stmt

begin_decl_stmt
specifier|const
name|PointerUnion
modifier|&
name|operator
init|=
operator|(
specifier|const
name|PT2
operator|&
name|RHS
operator|)
block|{
name|Val
operator|.
name|setPointerAndInt
argument_list|(
name|const_cast
operator|<
name|void
operator|*
operator|>
operator|(
name|PointerLikeTypeTraits
operator|<
name|PT2
operator|>
operator|::
name|getAsVoidPointer
argument_list|(
name|RHS
argument_list|)
operator|)
argument_list|,
literal|1
argument_list|)
block|;
return|return
operator|*
name|this
return|;
block|}
end_decl_stmt

begin_expr_stmt
name|void
operator|*
name|getOpaqueValue
argument_list|()
specifier|const
block|{
return|return
name|Val
operator|.
name|getOpaqueValue
argument_list|()
return|;
block|}
end_expr_stmt

begin_function
specifier|static
specifier|inline
name|PointerUnion
name|getFromOpaqueValue
parameter_list|(
name|void
modifier|*
name|VP
parameter_list|)
block|{
name|PointerUnion
name|V
decl_stmt|;
name|V
operator|.
name|Val
operator|=
name|ValTy
operator|::
name|getFromOpaqueValue
argument_list|(
name|VP
argument_list|)
expr_stmt|;
return|return
name|V
return|;
block|}
end_function

begin_expr_stmt
unit|};
name|template
operator|<
name|typename
name|PT1
operator|,
name|typename
name|PT2
operator|>
name|bool
name|operator
operator|==
operator|(
name|PointerUnion
operator|<
name|PT1
operator|,
name|PT2
operator|>
name|lhs
operator|,
name|PointerUnion
operator|<
name|PT1
operator|,
name|PT2
operator|>
name|rhs
operator|)
block|{
return|return
name|lhs
operator|.
name|getOpaqueValue
argument_list|()
operator|==
name|rhs
operator|.
name|getOpaqueValue
argument_list|()
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|PT1
operator|,
name|typename
name|PT2
operator|>
name|bool
name|operator
operator|!=
operator|(
name|PointerUnion
operator|<
name|PT1
operator|,
name|PT2
operator|>
name|lhs
operator|,
name|PointerUnion
operator|<
name|PT1
operator|,
name|PT2
operator|>
name|rhs
operator|)
block|{
return|return
name|lhs
operator|.
name|getOpaqueValue
argument_list|()
operator|!=
name|rhs
operator|.
name|getOpaqueValue
argument_list|()
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|PT1
operator|,
name|typename
name|PT2
operator|>
name|bool
name|operator
operator|<
operator|(
name|PointerUnion
operator|<
name|PT1
operator|,
name|PT2
operator|>
name|lhs
operator|,
name|PointerUnion
operator|<
name|PT1
operator|,
name|PT2
operator|>
name|rhs
operator|)
block|{
return|return
name|lhs
operator|.
name|getOpaqueValue
argument_list|()
operator|<
name|rhs
operator|.
name|getOpaqueValue
argument_list|()
return|;
block|}
end_expr_stmt

begin_comment
comment|// Teach SmallPtrSet that PointerUnion is "basically a pointer", that has
end_comment

begin_comment
comment|// # low bits available = min(PT1bits,PT2bits)-1.
end_comment

begin_expr_stmt
name|template
operator|<
name|typename
name|PT1
operator|,
name|typename
name|PT2
operator|>
name|class
name|PointerLikeTypeTraits
operator|<
name|PointerUnion
operator|<
name|PT1
operator|,
name|PT2
operator|>>
block|{
name|public
operator|:
specifier|static
specifier|inline
name|void
operator|*
name|getAsVoidPointer
argument_list|(
argument|const PointerUnion<PT1
argument_list|,
argument|PT2>&P
argument_list|)
block|{
return|return
name|P
operator|.
name|getOpaqueValue
argument_list|()
return|;
block|}
specifier|static
specifier|inline
name|PointerUnion
operator|<
name|PT1
operator|,
name|PT2
operator|>
name|getFromVoidPointer
argument_list|(
argument|void *P
argument_list|)
block|{
return|return
name|PointerUnion
operator|<
name|PT1
operator|,
name|PT2
operator|>
operator|::
name|getFromOpaqueValue
argument_list|(
name|P
argument_list|)
return|;
block|}
end_expr_stmt

begin_comment
comment|// The number of bits available are the min of the two pointer types.
end_comment

begin_enum
enum|enum
block|{
name|NumLowBitsAvailable
init|=
name|PointerLikeTypeTraits
operator|<
name|typename
name|PointerUnion
operator|<
name|PT1
block|,
name|PT2
decl|>::
name|ValTy
decl|>::
name|NumLowBitsAvailable
block|}
enum|;
end_enum

begin_comment
unit|};
comment|/// A pointer union of three pointer types. See documentation for PointerUnion
end_comment

begin_comment
comment|/// for usage.
end_comment

begin_expr_stmt
name|template
operator|<
name|typename
name|PT1
operator|,
name|typename
name|PT2
operator|,
name|typename
name|PT3
operator|>
name|class
name|PointerUnion3
block|{
name|public
operator|:
typedef|typedef
name|PointerUnion
operator|<
name|PT1
operator|,
name|PT2
operator|>
name|InnerUnion
expr_stmt|;
end_expr_stmt

begin_typedef
typedef|typedef
name|PointerUnion
operator|<
name|InnerUnion
operator|,
name|PT3
operator|>
name|ValTy
expr_stmt|;
end_typedef

begin_label
name|private
label|:
end_label

begin_decl_stmt
name|ValTy
name|Val
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|IsInnerUnion
block|{
name|ValTy
name|Val
decl_stmt|;
name|IsInnerUnion
argument_list|(
argument|ValTy val
argument_list|)
block|:
name|Val
argument_list|(
argument|val
argument_list|)
block|{}
name|template
operator|<
name|typename
name|T
operator|>
name|int
name|is
argument_list|()
specifier|const
block|{
return|return
name|Val
operator|.
name|template
name|is
operator|<
name|InnerUnion
operator|>
operator|(
operator|)
operator|&&
name|Val
operator|.
name|template
name|get
operator|<
name|InnerUnion
operator|>
operator|(
operator|)
operator|.
name|template
name|is
operator|<
name|T
operator|>
operator|(
operator|)
return|;
block|}
name|template
operator|<
name|typename
name|T
operator|>
name|T
name|get
argument_list|()
specifier|const
block|{
return|return
name|Val
operator|.
name|template
name|get
operator|<
name|InnerUnion
operator|>
operator|(
operator|)
operator|.
name|template
name|get
operator|<
name|T
operator|>
operator|(
operator|)
return|;
block|}
block|}
struct|;
end_struct

begin_struct
struct|struct
name|IsPT3
block|{
name|ValTy
name|Val
decl_stmt|;
name|IsPT3
argument_list|(
argument|ValTy val
argument_list|)
block|:
name|Val
argument_list|(
argument|val
argument_list|)
block|{}
name|template
operator|<
name|typename
name|T
operator|>
name|int
name|is
argument_list|()
specifier|const
block|{
return|return
name|Val
operator|.
name|template
name|is
operator|<
name|T
operator|>
operator|(
operator|)
return|;
block|}
name|template
operator|<
name|typename
name|T
operator|>
name|T
name|get
argument_list|()
specifier|const
block|{
return|return
name|Val
operator|.
name|template
name|get
operator|<
name|T
operator|>
operator|(
operator|)
return|;
block|}
block|}
struct|;
end_struct

begin_label
name|public
label|:
end_label

begin_expr_stmt
name|PointerUnion3
argument_list|()
operator|=
expr|default
expr_stmt|;
end_expr_stmt

begin_macro
name|PointerUnion3
argument_list|(
argument|PT1 V
argument_list|)
end_macro

begin_block
block|{
name|Val
operator|=
name|InnerUnion
argument_list|(
name|V
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|PointerUnion3
argument_list|(
argument|PT2 V
argument_list|)
end_macro

begin_block
block|{
name|Val
operator|=
name|InnerUnion
argument_list|(
name|V
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|PointerUnion3
argument_list|(
argument|PT3 V
argument_list|)
end_macro

begin_block
block|{
name|Val
operator|=
name|V
expr_stmt|;
block|}
end_block

begin_comment
comment|/// Test if the pointer held in the union is null, regardless of
end_comment

begin_comment
comment|/// which type it is.
end_comment

begin_expr_stmt
name|bool
name|isNull
argument_list|()
specifier|const
block|{
return|return
name|Val
operator|.
name|isNull
argument_list|()
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|explicit
name|operator
name|bool
argument_list|()
specifier|const
block|{
return|return
operator|!
name|isNull
argument_list|()
return|;
block|}
end_expr_stmt

begin_comment
comment|/// Test if the Union currently holds the type matching T.
end_comment

begin_expr_stmt
name|template
operator|<
name|typename
name|T
operator|>
name|int
name|is
argument_list|()
specifier|const
block|{
comment|// If T is PT1/PT2 choose IsInnerUnion otherwise choose IsPT3.
typedef|typedef
name|typename
operator|::
name|llvm
operator|::
name|PointerUnionTypeSelector
operator|<
name|PT1
operator|,
name|T
operator|,
name|IsInnerUnion
operator|,
operator|::
name|llvm
operator|::
name|PointerUnionTypeSelector
operator|<
name|PT2
operator|,
name|T
operator|,
name|IsInnerUnion
operator|,
name|IsPT3
operator|>>
operator|::
name|Return
name|Ty
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|Ty
argument_list|(
name|Val
argument_list|)
operator|.
name|template
name|is
operator|<
name|T
operator|>
operator|(
operator|)
return|;
end_return

begin_comment
unit|}
comment|/// Returns the value of the specified pointer type.
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|/// If the specified pointer type is incorrect, assert.
end_comment

begin_expr_stmt
unit|template
operator|<
name|typename
name|T
operator|>
name|T
name|get
argument_list|()
specifier|const
block|{
name|assert
argument_list|(
name|is
operator|<
name|T
operator|>
operator|(
operator|)
operator|&&
literal|"Invalid accessor called"
argument_list|)
block|;
comment|// If T is PT1/PT2 choose IsInnerUnion otherwise choose IsPT3.
typedef|typedef
name|typename
operator|::
name|llvm
operator|::
name|PointerUnionTypeSelector
operator|<
name|PT1
operator|,
name|T
operator|,
name|IsInnerUnion
operator|,
operator|::
name|llvm
operator|::
name|PointerUnionTypeSelector
operator|<
name|PT2
operator|,
name|T
operator|,
name|IsInnerUnion
operator|,
name|IsPT3
operator|>>
operator|::
name|Return
name|Ty
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|Ty
argument_list|(
name|Val
argument_list|)
operator|.
name|template
name|get
operator|<
name|T
operator|>
operator|(
operator|)
return|;
end_return

begin_comment
unit|}
comment|/// Returns the current pointer if it is of the specified pointer type,
end_comment

begin_comment
comment|/// otherwises returns null.
end_comment

begin_expr_stmt
unit|template
operator|<
name|typename
name|T
operator|>
name|T
name|dyn_cast
argument_list|()
specifier|const
block|{
if|if
condition|(
name|is
operator|<
name|T
operator|>
operator|(
operator|)
condition|)
return|return
name|get
operator|<
name|T
operator|>
operator|(
operator|)
return|;
end_expr_stmt

begin_return
return|return
name|T
argument_list|()
return|;
end_return

begin_comment
unit|}
comment|/// Assignment from nullptr which just clears the union.
end_comment

begin_decl_stmt
unit|const
name|PointerUnion3
modifier|&
name|operator
init|=
operator|(
name|std
operator|::
name|nullptr_t
operator|)
block|{
name|Val
operator|=
name|nullptr
block|;
return|return
operator|*
name|this
return|;
block|}
end_decl_stmt

begin_comment
comment|/// Assignment operators - Allow assigning into this union from either
end_comment

begin_comment
comment|/// pointer type, setting the discriminator to remember what it came from.
end_comment

begin_decl_stmt
specifier|const
name|PointerUnion3
modifier|&
name|operator
init|=
operator|(
specifier|const
name|PT1
operator|&
name|RHS
operator|)
block|{
name|Val
operator|=
name|InnerUnion
argument_list|(
name|RHS
argument_list|)
block|;
return|return
operator|*
name|this
return|;
block|}
end_decl_stmt

begin_decl_stmt
specifier|const
name|PointerUnion3
modifier|&
name|operator
init|=
operator|(
specifier|const
name|PT2
operator|&
name|RHS
operator|)
block|{
name|Val
operator|=
name|InnerUnion
argument_list|(
name|RHS
argument_list|)
block|;
return|return
operator|*
name|this
return|;
block|}
end_decl_stmt

begin_decl_stmt
specifier|const
name|PointerUnion3
modifier|&
name|operator
init|=
operator|(
specifier|const
name|PT3
operator|&
name|RHS
operator|)
block|{
name|Val
operator|=
name|RHS
block|;
return|return
operator|*
name|this
return|;
block|}
end_decl_stmt

begin_expr_stmt
name|void
operator|*
name|getOpaqueValue
argument_list|()
specifier|const
block|{
return|return
name|Val
operator|.
name|getOpaqueValue
argument_list|()
return|;
block|}
end_expr_stmt

begin_function
specifier|static
specifier|inline
name|PointerUnion3
name|getFromOpaqueValue
parameter_list|(
name|void
modifier|*
name|VP
parameter_list|)
block|{
name|PointerUnion3
name|V
decl_stmt|;
name|V
operator|.
name|Val
operator|=
name|ValTy
operator|::
name|getFromOpaqueValue
argument_list|(
name|VP
argument_list|)
expr_stmt|;
return|return
name|V
return|;
block|}
end_function

begin_comment
unit|};
comment|// Teach SmallPtrSet that PointerUnion3 is "basically a pointer", that has
end_comment

begin_comment
comment|// # low bits available = min(PT1bits,PT2bits,PT2bits)-2.
end_comment

begin_expr_stmt
name|template
operator|<
name|typename
name|PT1
operator|,
name|typename
name|PT2
operator|,
name|typename
name|PT3
operator|>
name|class
name|PointerLikeTypeTraits
operator|<
name|PointerUnion3
operator|<
name|PT1
operator|,
name|PT2
operator|,
name|PT3
operator|>>
block|{
name|public
operator|:
specifier|static
specifier|inline
name|void
operator|*
name|getAsVoidPointer
argument_list|(
argument|const PointerUnion3<PT1
argument_list|,
argument|PT2
argument_list|,
argument|PT3>&P
argument_list|)
block|{
return|return
name|P
operator|.
name|getOpaqueValue
argument_list|()
return|;
block|}
specifier|static
specifier|inline
name|PointerUnion3
operator|<
name|PT1
operator|,
name|PT2
operator|,
name|PT3
operator|>
name|getFromVoidPointer
argument_list|(
argument|void *P
argument_list|)
block|{
return|return
name|PointerUnion3
operator|<
name|PT1
operator|,
name|PT2
operator|,
name|PT3
operator|>
operator|::
name|getFromOpaqueValue
argument_list|(
name|P
argument_list|)
return|;
block|}
end_expr_stmt

begin_comment
comment|// The number of bits available are the min of the two pointer types.
end_comment

begin_enum
enum|enum
block|{
name|NumLowBitsAvailable
init|=
name|PointerLikeTypeTraits
operator|<
name|typename
name|PointerUnion3
operator|<
name|PT1
block|,
name|PT2
block|,
name|PT3
decl|>::
name|ValTy
decl|>::
name|NumLowBitsAvailable
block|}
enum|;
end_enum

begin_comment
unit|};
comment|/// A pointer union of four pointer types. See documentation for PointerUnion
end_comment

begin_comment
comment|/// for usage.
end_comment

begin_expr_stmt
name|template
operator|<
name|typename
name|PT1
operator|,
name|typename
name|PT2
operator|,
name|typename
name|PT3
operator|,
name|typename
name|PT4
operator|>
name|class
name|PointerUnion4
block|{
name|public
operator|:
typedef|typedef
name|PointerUnion
operator|<
name|PT1
operator|,
name|PT2
operator|>
name|InnerUnion1
expr_stmt|;
end_expr_stmt

begin_typedef
typedef|typedef
name|PointerUnion
operator|<
name|PT3
operator|,
name|PT4
operator|>
name|InnerUnion2
expr_stmt|;
end_typedef

begin_typedef
typedef|typedef
name|PointerUnion
operator|<
name|InnerUnion1
operator|,
name|InnerUnion2
operator|>
name|ValTy
expr_stmt|;
end_typedef

begin_label
name|private
label|:
end_label

begin_decl_stmt
name|ValTy
name|Val
decl_stmt|;
end_decl_stmt

begin_label
name|public
label|:
end_label

begin_expr_stmt
name|PointerUnion4
argument_list|()
operator|=
expr|default
expr_stmt|;
end_expr_stmt

begin_macro
name|PointerUnion4
argument_list|(
argument|PT1 V
argument_list|)
end_macro

begin_block
block|{
name|Val
operator|=
name|InnerUnion1
argument_list|(
name|V
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|PointerUnion4
argument_list|(
argument|PT2 V
argument_list|)
end_macro

begin_block
block|{
name|Val
operator|=
name|InnerUnion1
argument_list|(
name|V
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|PointerUnion4
argument_list|(
argument|PT3 V
argument_list|)
end_macro

begin_block
block|{
name|Val
operator|=
name|InnerUnion2
argument_list|(
name|V
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|PointerUnion4
argument_list|(
argument|PT4 V
argument_list|)
end_macro

begin_block
block|{
name|Val
operator|=
name|InnerUnion2
argument_list|(
name|V
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/// Test if the pointer held in the union is null, regardless of
end_comment

begin_comment
comment|/// which type it is.
end_comment

begin_expr_stmt
name|bool
name|isNull
argument_list|()
specifier|const
block|{
return|return
name|Val
operator|.
name|isNull
argument_list|()
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|explicit
name|operator
name|bool
argument_list|()
specifier|const
block|{
return|return
operator|!
name|isNull
argument_list|()
return|;
block|}
end_expr_stmt

begin_comment
comment|/// Test if the Union currently holds the type matching T.
end_comment

begin_expr_stmt
name|template
operator|<
name|typename
name|T
operator|>
name|int
name|is
argument_list|()
specifier|const
block|{
comment|// If T is PT1/PT2 choose InnerUnion1 otherwise choose InnerUnion2.
typedef|typedef
name|typename
operator|::
name|llvm
operator|::
name|PointerUnionTypeSelector
operator|<
name|PT1
operator|,
name|T
operator|,
name|InnerUnion1
operator|,
operator|::
name|llvm
operator|::
name|PointerUnionTypeSelector
operator|<
name|PT2
operator|,
name|T
operator|,
name|InnerUnion1
operator|,
name|InnerUnion2
operator|>>
operator|::
name|Return
name|Ty
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|Val
operator|.
name|template
name|is
operator|<
name|Ty
operator|>
operator|(
operator|)
operator|&&
name|Val
operator|.
name|template
name|get
operator|<
name|Ty
operator|>
operator|(
operator|)
operator|.
name|template
name|is
operator|<
name|T
operator|>
operator|(
operator|)
return|;
end_return

begin_comment
unit|}
comment|/// Returns the value of the specified pointer type.
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|/// If the specified pointer type is incorrect, assert.
end_comment

begin_expr_stmt
unit|template
operator|<
name|typename
name|T
operator|>
name|T
name|get
argument_list|()
specifier|const
block|{
name|assert
argument_list|(
name|is
operator|<
name|T
operator|>
operator|(
operator|)
operator|&&
literal|"Invalid accessor called"
argument_list|)
block|;
comment|// If T is PT1/PT2 choose InnerUnion1 otherwise choose InnerUnion2.
typedef|typedef
name|typename
operator|::
name|llvm
operator|::
name|PointerUnionTypeSelector
operator|<
name|PT1
operator|,
name|T
operator|,
name|InnerUnion1
operator|,
operator|::
name|llvm
operator|::
name|PointerUnionTypeSelector
operator|<
name|PT2
operator|,
name|T
operator|,
name|InnerUnion1
operator|,
name|InnerUnion2
operator|>>
operator|::
name|Return
name|Ty
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|Val
operator|.
name|template
name|get
operator|<
name|Ty
operator|>
operator|(
operator|)
operator|.
name|template
name|get
operator|<
name|T
operator|>
operator|(
operator|)
return|;
end_return

begin_comment
unit|}
comment|/// Returns the current pointer if it is of the specified pointer type,
end_comment

begin_comment
comment|/// otherwises returns null.
end_comment

begin_expr_stmt
unit|template
operator|<
name|typename
name|T
operator|>
name|T
name|dyn_cast
argument_list|()
specifier|const
block|{
if|if
condition|(
name|is
operator|<
name|T
operator|>
operator|(
operator|)
condition|)
return|return
name|get
operator|<
name|T
operator|>
operator|(
operator|)
return|;
end_expr_stmt

begin_return
return|return
name|T
argument_list|()
return|;
end_return

begin_comment
unit|}
comment|/// Assignment from nullptr which just clears the union.
end_comment

begin_decl_stmt
unit|const
name|PointerUnion4
modifier|&
name|operator
init|=
operator|(
name|std
operator|::
name|nullptr_t
operator|)
block|{
name|Val
operator|=
name|nullptr
block|;
return|return
operator|*
name|this
return|;
block|}
end_decl_stmt

begin_comment
comment|/// Assignment operators - Allow assigning into this union from either
end_comment

begin_comment
comment|/// pointer type, setting the discriminator to remember what it came from.
end_comment

begin_decl_stmt
specifier|const
name|PointerUnion4
modifier|&
name|operator
init|=
operator|(
specifier|const
name|PT1
operator|&
name|RHS
operator|)
block|{
name|Val
operator|=
name|InnerUnion1
argument_list|(
name|RHS
argument_list|)
block|;
return|return
operator|*
name|this
return|;
block|}
end_decl_stmt

begin_decl_stmt
specifier|const
name|PointerUnion4
modifier|&
name|operator
init|=
operator|(
specifier|const
name|PT2
operator|&
name|RHS
operator|)
block|{
name|Val
operator|=
name|InnerUnion1
argument_list|(
name|RHS
argument_list|)
block|;
return|return
operator|*
name|this
return|;
block|}
end_decl_stmt

begin_decl_stmt
specifier|const
name|PointerUnion4
modifier|&
name|operator
init|=
operator|(
specifier|const
name|PT3
operator|&
name|RHS
operator|)
block|{
name|Val
operator|=
name|InnerUnion2
argument_list|(
name|RHS
argument_list|)
block|;
return|return
operator|*
name|this
return|;
block|}
end_decl_stmt

begin_decl_stmt
specifier|const
name|PointerUnion4
modifier|&
name|operator
init|=
operator|(
specifier|const
name|PT4
operator|&
name|RHS
operator|)
block|{
name|Val
operator|=
name|InnerUnion2
argument_list|(
name|RHS
argument_list|)
block|;
return|return
operator|*
name|this
return|;
block|}
end_decl_stmt

begin_expr_stmt
name|void
operator|*
name|getOpaqueValue
argument_list|()
specifier|const
block|{
return|return
name|Val
operator|.
name|getOpaqueValue
argument_list|()
return|;
block|}
end_expr_stmt

begin_function
specifier|static
specifier|inline
name|PointerUnion4
name|getFromOpaqueValue
parameter_list|(
name|void
modifier|*
name|VP
parameter_list|)
block|{
name|PointerUnion4
name|V
decl_stmt|;
name|V
operator|.
name|Val
operator|=
name|ValTy
operator|::
name|getFromOpaqueValue
argument_list|(
name|VP
argument_list|)
expr_stmt|;
return|return
name|V
return|;
block|}
end_function

begin_comment
unit|};
comment|// Teach SmallPtrSet that PointerUnion4 is "basically a pointer", that has
end_comment

begin_comment
comment|// # low bits available = min(PT1bits,PT2bits,PT2bits)-2.
end_comment

begin_expr_stmt
name|template
operator|<
name|typename
name|PT1
operator|,
name|typename
name|PT2
operator|,
name|typename
name|PT3
operator|,
name|typename
name|PT4
operator|>
name|class
name|PointerLikeTypeTraits
operator|<
name|PointerUnion4
operator|<
name|PT1
operator|,
name|PT2
operator|,
name|PT3
operator|,
name|PT4
operator|>>
block|{
name|public
operator|:
specifier|static
specifier|inline
name|void
operator|*
name|getAsVoidPointer
argument_list|(
argument|const PointerUnion4<PT1
argument_list|,
argument|PT2
argument_list|,
argument|PT3
argument_list|,
argument|PT4>&P
argument_list|)
block|{
return|return
name|P
operator|.
name|getOpaqueValue
argument_list|()
return|;
block|}
specifier|static
specifier|inline
name|PointerUnion4
operator|<
name|PT1
operator|,
name|PT2
operator|,
name|PT3
operator|,
name|PT4
operator|>
name|getFromVoidPointer
argument_list|(
argument|void *P
argument_list|)
block|{
return|return
name|PointerUnion4
operator|<
name|PT1
operator|,
name|PT2
operator|,
name|PT3
operator|,
name|PT4
operator|>
operator|::
name|getFromOpaqueValue
argument_list|(
name|P
argument_list|)
return|;
block|}
end_expr_stmt

begin_comment
comment|// The number of bits available are the min of the two pointer types.
end_comment

begin_enum
enum|enum
block|{
name|NumLowBitsAvailable
init|=
name|PointerLikeTypeTraits
operator|<
name|typename
name|PointerUnion4
operator|<
name|PT1
block|,
name|PT2
block|,
name|PT3
block|,
name|PT4
decl|>::
name|ValTy
decl|>::
name|NumLowBitsAvailable
block|}
enum|;
end_enum

begin_comment
unit|};
comment|// Teach DenseMap how to use PointerUnions as keys.
end_comment

begin_expr_stmt
name|template
operator|<
name|typename
name|T
operator|,
name|typename
name|U
operator|>
expr|struct
name|DenseMapInfo
operator|<
name|PointerUnion
operator|<
name|T
operator|,
name|U
operator|>>
block|{
typedef|typedef
name|PointerUnion
operator|<
name|T
operator|,
name|U
operator|>
name|Pair
expr_stmt|;
end_expr_stmt

begin_typedef
typedef|typedef
name|DenseMapInfo
operator|<
name|T
operator|>
name|FirstInfo
expr_stmt|;
end_typedef

begin_typedef
typedef|typedef
name|DenseMapInfo
operator|<
name|U
operator|>
name|SecondInfo
expr_stmt|;
end_typedef

begin_function
specifier|static
specifier|inline
name|Pair
name|getEmptyKey
parameter_list|()
block|{
return|return
name|Pair
argument_list|(
name|FirstInfo
operator|::
name|getEmptyKey
argument_list|()
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|Pair
name|getTombstoneKey
parameter_list|()
block|{
return|return
name|Pair
argument_list|(
name|FirstInfo
operator|::
name|getTombstoneKey
argument_list|()
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|unsigned
name|getHashValue
parameter_list|(
specifier|const
name|Pair
modifier|&
name|PairVal
parameter_list|)
block|{
name|intptr_t
name|key
init|=
operator|(
name|intptr_t
operator|)
name|PairVal
operator|.
name|getOpaqueValue
argument_list|()
decl_stmt|;
return|return
name|DenseMapInfo
operator|<
name|intptr_t
operator|>
operator|::
name|getHashValue
argument_list|(
name|key
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|isEqual
parameter_list|(
specifier|const
name|Pair
modifier|&
name|LHS
parameter_list|,
specifier|const
name|Pair
modifier|&
name|RHS
parameter_list|)
block|{
return|return
name|LHS
operator|.
name|template
name|is
operator|<
name|T
operator|>
operator|(
operator|)
operator|==
name|RHS
operator|.
name|template
name|is
operator|<
name|T
operator|>
operator|(
operator|)
operator|&&
operator|(
name|LHS
operator|.
name|template
name|is
operator|<
name|T
operator|>
operator|(
operator|)
condition|?
name|FirstInfo
operator|::
name|isEqual
argument_list|(
argument|LHS.template get<T>()
argument_list|,
argument|RHS.template get<T>()
argument_list|)
else|:
name|SecondInfo
operator|::
name|isEqual
argument_list|(
argument|LHS.template get<U>()
argument_list|,
argument|RHS.template get<U>()
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
unit|};  }
comment|// end namespace llvm
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|// LLVM_ADT_POINTERUNION_H
end_comment

end_unit

