begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===- llvm/ADT/STLExtras.h - Useful STL related functions ------*- C++ -*-===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file contains some templates that are useful if you are working with the
end_comment

begin_comment
comment|// STL at all.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// No library is required when using these functions.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LLVM_ADT_STLEXTRAS_H
end_ifndef

begin_define
define|#
directive|define
name|LLVM_ADT_STLEXTRAS_H
end_define

begin_include
include|#
directive|include
file|"llvm/Support/Compiler.h"
end_include

begin_include
include|#
directive|include
file|<cstddef>
end_include

begin_comment
comment|// for std::size_t
end_comment

begin_include
include|#
directive|include
file|<cstdlib>
end_include

begin_comment
comment|// for qsort
end_comment

begin_include
include|#
directive|include
file|<functional>
end_include

begin_include
include|#
directive|include
file|<iterator>
end_include

begin_include
include|#
directive|include
file|<memory>
end_include

begin_include
include|#
directive|include
file|<utility>
end_include

begin_comment
comment|// for std::pair
end_comment

begin_decl_stmt
name|namespace
name|llvm
block|{
comment|//===----------------------------------------------------------------------===//
comment|//     Extra additions to<functional>
comment|//===----------------------------------------------------------------------===//
name|template
operator|<
name|class
name|Ty
operator|>
expr|struct
name|identity
operator|:
name|public
name|std
operator|::
name|unary_function
operator|<
name|Ty
operator|,
name|Ty
operator|>
block|{
name|Ty
operator|&
name|operator
argument_list|()
operator|(
name|Ty
operator|&
name|self
operator|)
specifier|const
block|{
return|return
name|self
return|;
block|}
specifier|const
name|Ty
operator|&
name|operator
argument_list|()
operator|(
specifier|const
name|Ty
operator|&
name|self
operator|)
specifier|const
block|{
return|return
name|self
return|;
block|}
expr|}
block|;
name|template
operator|<
name|class
name|Ty
operator|>
expr|struct
name|less_ptr
operator|:
name|public
name|std
operator|::
name|binary_function
operator|<
name|Ty
block|,
name|Ty
block|,
name|bool
operator|>
block|{
name|bool
name|operator
argument_list|()
operator|(
specifier|const
name|Ty
operator|*
name|left
operator|,
specifier|const
name|Ty
operator|*
name|right
operator|)
specifier|const
block|{
return|return
operator|*
name|left
operator|<
operator|*
name|right
return|;
block|}
expr|}
block|;
name|template
operator|<
name|class
name|Ty
operator|>
expr|struct
name|greater_ptr
operator|:
name|public
name|std
operator|::
name|binary_function
operator|<
name|Ty
block|,
name|Ty
block|,
name|bool
operator|>
block|{
name|bool
name|operator
argument_list|()
operator|(
specifier|const
name|Ty
operator|*
name|left
operator|,
specifier|const
name|Ty
operator|*
name|right
operator|)
specifier|const
block|{
return|return
operator|*
name|right
operator|<
operator|*
name|left
return|;
block|}
expr|}
block|;
comment|/// An efficient, type-erasing, non-owning reference to a callable. This is
comment|/// intended for use as the type of a function parameter that is not used
comment|/// after the function in question returns.
comment|///
comment|/// This class does not own the callable, so it is not in general safe to store
comment|/// a function_ref.
name|template
operator|<
name|typename
name|Fn
operator|>
name|class
name|function_ref
block|;
if|#
directive|if
name|LLVM_HAS_VARIADIC_TEMPLATES
name|template
operator|<
name|typename
name|Ret
block|,
name|typename
operator|...
name|Params
operator|>
name|class
name|function_ref
operator|<
name|Ret
argument_list|(
name|Params
operator|...
argument_list|)
operator|>
block|{
name|Ret
argument_list|(
argument|*callback
argument_list|)
operator|(
name|intptr_t
name|callable
operator|,
name|Params
operator|...
name|params
operator|)
block|;
name|intptr_t
name|callable
block|;
name|template
operator|<
name|typename
name|Callable
operator|>
specifier|static
name|Ret
name|callback_fn
argument_list|(
argument|intptr_t callable
argument_list|,
argument|Params ...params
argument_list|)
block|{
return|return
operator|(
operator|*
name|reinterpret_cast
operator|<
name|Callable
operator|*
operator|>
operator|(
name|callable
operator|)
operator|)
operator|(
name|std
operator|::
name|forward
operator|<
name|Params
operator|>
operator|(
name|params
operator|)
operator|...
operator|)
return|;
block|}
name|public
operator|:
name|template
operator|<
name|typename
name|Callable
operator|>
name|function_ref
argument_list|(
name|Callable
operator|&&
name|callable
argument_list|)
operator|:
name|callback
argument_list|(
argument|callback_fn<typename std::remove_reference<Callable>::type>
argument_list|)
block|,
name|callable
argument_list|(
argument|reinterpret_cast<intptr_t>(&callable)
argument_list|)
block|{}
name|Ret
name|operator
argument_list|()
operator|(
name|Params
operator|...
name|params
operator|)
specifier|const
block|{
return|return
name|callback
argument_list|(
name|callable
argument_list|,
name|std
operator|::
name|forward
operator|<
name|Params
operator|>
operator|(
name|params
operator|)
operator|...
argument_list|)
return|;
block|}
expr|}
block|;
else|#
directive|else
name|template
operator|<
name|typename
name|Ret
operator|>
name|class
name|function_ref
operator|<
name|Ret
argument_list|()
operator|>
block|{
name|Ret
argument_list|(
argument|*callback
argument_list|)
operator|(
name|intptr_t
name|callable
operator|)
block|;
name|intptr_t
name|callable
block|;
name|template
operator|<
name|typename
name|Callable
operator|>
specifier|static
name|Ret
name|callback_fn
argument_list|(
argument|intptr_t callable
argument_list|)
block|{
return|return
operator|(
operator|*
name|reinterpret_cast
operator|<
name|Callable
operator|*
operator|>
operator|(
name|callable
operator|)
operator|)
operator|(
operator|)
return|;
block|}
name|public
operator|:
name|template
operator|<
name|typename
name|Callable
operator|>
name|function_ref
argument_list|(
name|Callable
operator|&&
name|callable
argument_list|)
operator|:
name|callback
argument_list|(
argument|callback_fn<typename std::remove_reference<Callable>::type>
argument_list|)
block|,
name|callable
argument_list|(
argument|reinterpret_cast<intptr_t>(&callable)
argument_list|)
block|{}
name|Ret
name|operator
argument_list|()
operator|(
operator|)
specifier|const
block|{
return|return
name|callback
argument_list|(
name|callable
argument_list|)
return|;
block|}
expr|}
block|;
name|template
operator|<
name|typename
name|Ret
block|,
name|typename
name|Param1
operator|>
name|class
name|function_ref
operator|<
name|Ret
argument_list|(
name|Param1
argument_list|)
operator|>
block|{
name|Ret
argument_list|(
argument|*callback
argument_list|)
operator|(
name|intptr_t
name|callable
operator|,
name|Param1
name|param1
operator|)
block|;
name|intptr_t
name|callable
block|;
name|template
operator|<
name|typename
name|Callable
operator|>
specifier|static
name|Ret
name|callback_fn
argument_list|(
argument|intptr_t callable
argument_list|,
argument|Param1 param1
argument_list|)
block|{
return|return
operator|(
operator|*
name|reinterpret_cast
operator|<
name|Callable
operator|*
operator|>
operator|(
name|callable
operator|)
operator|)
operator|(
name|std
operator|::
name|forward
operator|<
name|Param1
operator|>
operator|(
name|param1
operator|)
operator|)
return|;
block|}
name|public
operator|:
name|template
operator|<
name|typename
name|Callable
operator|>
name|function_ref
argument_list|(
name|Callable
operator|&&
name|callable
argument_list|)
operator|:
name|callback
argument_list|(
argument|callback_fn<typename std::remove_reference<Callable>::type>
argument_list|)
block|,
name|callable
argument_list|(
argument|reinterpret_cast<intptr_t>(&callable)
argument_list|)
block|{}
name|Ret
name|operator
argument_list|()
operator|(
name|Param1
name|param1
operator|)
block|{
return|return
name|callback
argument_list|(
name|callable
argument_list|,
name|std
operator|::
name|forward
operator|<
name|Param1
operator|>
operator|(
name|param1
operator|)
argument_list|)
return|;
block|}
expr|}
block|;
name|template
operator|<
name|typename
name|Ret
block|,
name|typename
name|Param1
block|,
name|typename
name|Param2
operator|>
name|class
name|function_ref
operator|<
name|Ret
argument_list|(
name|Param1
argument_list|,
name|Param2
argument_list|)
operator|>
block|{
name|Ret
argument_list|(
argument|*callback
argument_list|)
operator|(
name|intptr_t
name|callable
operator|,
name|Param1
name|param1
operator|,
name|Param2
name|param2
operator|)
block|;
name|intptr_t
name|callable
block|;
name|template
operator|<
name|typename
name|Callable
operator|>
specifier|static
name|Ret
name|callback_fn
argument_list|(
argument|intptr_t callable
argument_list|,
argument|Param1 param1
argument_list|,
argument|Param2 param2
argument_list|)
block|{
return|return
operator|(
operator|*
name|reinterpret_cast
operator|<
name|Callable
operator|*
operator|>
operator|(
name|callable
operator|)
operator|)
operator|(
name|std
operator|::
name|forward
operator|<
name|Param1
operator|>
operator|(
name|param1
operator|)
operator|,
name|std
operator|::
name|forward
operator|<
name|Param2
operator|>
operator|(
name|param2
operator|)
operator|)
return|;
block|}
name|public
operator|:
name|template
operator|<
name|typename
name|Callable
operator|>
name|function_ref
argument_list|(
name|Callable
operator|&&
name|callable
argument_list|)
operator|:
name|callback
argument_list|(
argument|callback_fn<typename std::remove_reference<Callable>::type>
argument_list|)
block|,
name|callable
argument_list|(
argument|reinterpret_cast<intptr_t>(&callable)
argument_list|)
block|{}
name|Ret
name|operator
argument_list|()
operator|(
name|Param1
name|param1
operator|,
name|Param2
name|param2
operator|)
block|{
return|return
name|callback
argument_list|(
name|callable
argument_list|,
name|std
operator|::
name|forward
operator|<
name|Param1
operator|>
operator|(
name|param1
operator|)
argument_list|,
name|std
operator|::
name|forward
operator|<
name|Param2
operator|>
operator|(
name|param2
operator|)
argument_list|)
return|;
block|}
expr|}
block|;
name|template
operator|<
name|typename
name|Ret
block|,
name|typename
name|Param1
block|,
name|typename
name|Param2
block|,
name|typename
name|Param3
operator|>
name|class
name|function_ref
operator|<
name|Ret
argument_list|(
name|Param1
argument_list|,
name|Param2
argument_list|,
name|Param3
argument_list|)
operator|>
block|{
name|Ret
argument_list|(
argument|*callback
argument_list|)
operator|(
name|intptr_t
name|callable
operator|,
name|Param1
name|param1
operator|,
name|Param2
name|param2
operator|,
name|Param3
name|param3
operator|)
block|;
name|intptr_t
name|callable
block|;
name|template
operator|<
name|typename
name|Callable
operator|>
specifier|static
name|Ret
name|callback_fn
argument_list|(
argument|intptr_t callable
argument_list|,
argument|Param1 param1
argument_list|,
argument|Param2 param2
argument_list|,
argument|Param3 param3
argument_list|)
block|{
return|return
operator|(
operator|*
name|reinterpret_cast
operator|<
name|Callable
operator|*
operator|>
operator|(
name|callable
operator|)
operator|)
operator|(
name|std
operator|::
name|forward
operator|<
name|Param1
operator|>
operator|(
name|param1
operator|)
operator|,
name|std
operator|::
name|forward
operator|<
name|Param2
operator|>
operator|(
name|param2
operator|)
operator|,
name|std
operator|::
name|forward
operator|<
name|Param3
operator|>
operator|(
name|param3
operator|)
operator|)
return|;
block|}
name|public
operator|:
name|template
operator|<
name|typename
name|Callable
operator|>
name|function_ref
argument_list|(
name|Callable
operator|&&
name|callable
argument_list|)
operator|:
name|callback
argument_list|(
argument|callback_fn<typename std::remove_reference<Callable>::type>
argument_list|)
block|,
name|callable
argument_list|(
argument|reinterpret_cast<intptr_t>(&callable)
argument_list|)
block|{}
name|Ret
name|operator
argument_list|()
operator|(
name|Param1
name|param1
operator|,
name|Param2
name|param2
operator|,
name|Param3
name|param3
operator|)
block|{
return|return
name|callback
argument_list|(
name|callable
argument_list|,
name|std
operator|::
name|forward
operator|<
name|Param1
operator|>
operator|(
name|param1
operator|)
argument_list|,
name|std
operator|::
name|forward
operator|<
name|Param2
operator|>
operator|(
name|param2
operator|)
argument_list|,
name|std
operator|::
name|forward
operator|<
name|Param3
operator|>
operator|(
name|param3
operator|)
argument_list|)
return|;
block|}
expr|}
block|;
endif|#
directive|endif
comment|// deleter - Very very very simple method that is used to invoke operator
comment|// delete on something.  It is used like this:
comment|//
comment|//   for_each(V.begin(), B.end(), deleter<Interval>);
comment|//
name|template
operator|<
name|class
name|T
operator|>
specifier|inline
name|void
name|deleter
argument_list|(
argument|T *Ptr
argument_list|)
block|{
name|delete
name|Ptr
block|; }
comment|//===----------------------------------------------------------------------===//
comment|//     Extra additions to<iterator>
comment|//===----------------------------------------------------------------------===//
comment|// mapped_iterator - This is a simple iterator adapter that causes a function to
comment|// be dereferenced whenever operator* is invoked on the iterator.
comment|//
name|template
operator|<
name|class
name|RootIt
block|,
name|class
name|UnaryFunc
operator|>
name|class
name|mapped_iterator
block|{
name|RootIt
name|current
block|;
name|UnaryFunc
name|Fn
block|;
name|public
operator|:
typedef|typedef
name|typename
name|std
operator|::
name|iterator_traits
operator|<
name|RootIt
operator|>
operator|::
name|iterator_category
name|iterator_category
expr_stmt|;
typedef|typedef
name|typename
name|std
operator|::
name|iterator_traits
operator|<
name|RootIt
operator|>
operator|::
name|difference_type
name|difference_type
expr_stmt|;
typedef|typedef
name|typename
name|UnaryFunc
operator|::
name|result_type
name|value_type
expr_stmt|;
typedef|typedef
name|void
name|pointer
typedef|;
comment|//typedef typename UnaryFunc::result_type *pointer;
typedef|typedef
name|void
name|reference
typedef|;
comment|// Can't modify value returned by fn
typedef|typedef
name|RootIt
name|iterator_type
typedef|;
typedef|typedef
name|mapped_iterator
operator|<
name|RootIt
operator|,
name|UnaryFunc
operator|>
name|_Self
expr_stmt|;
specifier|inline
specifier|const
name|RootIt
operator|&
name|getCurrent
argument_list|()
specifier|const
block|{
return|return
name|current
return|;
block|}
specifier|inline
specifier|const
name|UnaryFunc
operator|&
name|getFunc
argument_list|()
specifier|const
block|{
return|return
name|Fn
return|;
block|}
specifier|inline
name|explicit
name|mapped_iterator
argument_list|(
argument|const RootIt&I
argument_list|,
argument|UnaryFunc F
argument_list|)
operator|:
name|current
argument_list|(
name|I
argument_list|)
block|,
name|Fn
argument_list|(
argument|F
argument_list|)
block|{}
specifier|inline
name|value_type
name|operator
operator|*
operator|(
operator|)
specifier|const
block|{
comment|// All this work to do this
return|return
name|Fn
argument_list|(
operator|*
name|current
argument_list|)
return|;
comment|// little change
block|}
name|_Self
operator|&
name|operator
operator|++
operator|(
operator|)
block|{
operator|++
name|current
block|;
return|return
operator|*
name|this
return|;
block|}
name|_Self
operator|&
name|operator
operator|--
operator|(
operator|)
block|{
operator|--
name|current
block|;
return|return
operator|*
name|this
return|;
block|}
name|_Self
name|operator
operator|++
operator|(
name|int
operator|)
block|{
name|_Self
name|__tmp
operator|=
operator|*
name|this
block|;
operator|++
name|current
block|;
return|return
name|__tmp
return|;
block|}
name|_Self
name|operator
operator|--
operator|(
name|int
operator|)
block|{
name|_Self
name|__tmp
operator|=
operator|*
name|this
block|;
operator|--
name|current
block|;
return|return
name|__tmp
return|;
block|}
name|_Self
name|operator
operator|+
operator|(
name|difference_type
name|n
operator|)
specifier|const
block|{
return|return
name|_Self
argument_list|(
name|current
operator|+
name|n
argument_list|,
name|Fn
argument_list|)
return|;
block|}
name|_Self
operator|&
name|operator
operator|+=
operator|(
name|difference_type
name|n
operator|)
block|{
name|current
operator|+=
name|n
block|;
return|return
operator|*
name|this
return|;
block|}
name|_Self
name|operator
operator|-
operator|(
name|difference_type
name|n
operator|)
specifier|const
block|{
return|return
name|_Self
argument_list|(
name|current
operator|-
name|n
argument_list|,
name|Fn
argument_list|)
return|;
block|}
name|_Self
operator|&
name|operator
operator|-=
operator|(
name|difference_type
name|n
operator|)
block|{
name|current
operator|-=
name|n
block|;
return|return
operator|*
name|this
return|;
block|}
name|reference
name|operator
index|[]
operator|(
name|difference_type
name|n
operator|)
specifier|const
block|{
return|return
operator|*
operator|(
operator|*
name|this
operator|+
name|n
operator|)
return|;
block|}
specifier|inline
name|bool
name|operator
operator|!=
operator|(
specifier|const
name|_Self
operator|&
name|X
operator|)
specifier|const
block|{
return|return
operator|!
name|operator
operator|==
operator|(
name|X
operator|)
return|;
block|}
specifier|inline
name|bool
name|operator
operator|==
operator|(
specifier|const
name|_Self
operator|&
name|X
operator|)
specifier|const
block|{
return|return
name|current
operator|==
name|X
operator|.
name|current
return|;
block|}
specifier|inline
name|bool
name|operator
operator|<
operator|(
specifier|const
name|_Self
operator|&
name|X
operator|)
specifier|const
block|{
return|return
name|current
operator|<
name|X
operator|.
name|current
return|;
block|}
specifier|inline
name|difference_type
name|operator
operator|-
operator|(
specifier|const
name|_Self
operator|&
name|X
operator|)
specifier|const
block|{
return|return
name|current
operator|-
name|X
operator|.
name|current
return|;
block|}
expr|}
block|;
name|template
operator|<
name|class
name|_Iterator
block|,
name|class
name|Func
operator|>
specifier|inline
name|mapped_iterator
operator|<
name|_Iterator
block|,
name|Func
operator|>
name|operator
operator|+
operator|(
name|typename
name|mapped_iterator
operator|<
name|_Iterator
operator|,
name|Func
operator|>
operator|::
name|difference_type
name|N
operator|,
specifier|const
name|mapped_iterator
operator|<
name|_Iterator
operator|,
name|Func
operator|>
operator|&
name|X
operator|)
block|{
return|return
name|mapped_iterator
operator|<
name|_Iterator
operator|,
name|Func
operator|>
operator|(
name|X
operator|.
name|getCurrent
argument_list|()
operator|-
name|N
operator|,
name|X
operator|.
name|getFunc
argument_list|()
operator|)
return|;
block|}
comment|// map_iterator - Provide a convenient way to create mapped_iterators, just like
comment|// make_pair is useful for creating pairs...
comment|//
name|template
operator|<
name|class
name|ItTy
block|,
name|class
name|FuncTy
operator|>
specifier|inline
name|mapped_iterator
operator|<
name|ItTy
block|,
name|FuncTy
operator|>
name|map_iterator
argument_list|(
argument|const ItTy&I
argument_list|,
argument|FuncTy F
argument_list|)
block|{
return|return
name|mapped_iterator
operator|<
name|ItTy
operator|,
name|FuncTy
operator|>
operator|(
name|I
operator|,
name|F
operator|)
return|;
block|}
comment|//===----------------------------------------------------------------------===//
comment|//     Extra additions to<utility>
comment|//===----------------------------------------------------------------------===//
comment|/// \brief Function object to check whether the first component of a std::pair
comment|/// compares less than the first component of another std::pair.
expr|struct
name|less_first
block|{
name|template
operator|<
name|typename
name|T
operator|>
name|bool
name|operator
argument_list|()
operator|(
specifier|const
name|T
operator|&
name|lhs
operator|,
specifier|const
name|T
operator|&
name|rhs
operator|)
specifier|const
block|{
return|return
name|lhs
operator|.
name|first
operator|<
name|rhs
operator|.
name|first
return|;
block|}
expr|}
block|;
comment|/// \brief Function object to check whether the second component of a std::pair
comment|/// compares less than the second component of another std::pair.
block|struct
name|less_second
block|{
name|template
operator|<
name|typename
name|T
operator|>
name|bool
name|operator
argument_list|()
operator|(
specifier|const
name|T
operator|&
name|lhs
operator|,
specifier|const
name|T
operator|&
name|rhs
operator|)
specifier|const
block|{
return|return
name|lhs
operator|.
name|second
operator|<
name|rhs
operator|.
name|second
return|;
block|}
expr|}
block|;
comment|//===----------------------------------------------------------------------===//
comment|//     Extra additions for arrays
comment|//===----------------------------------------------------------------------===//
comment|/// Find the length of an array.
name|template
operator|<
name|class
name|T
block|,
name|std
operator|::
name|size_t
name|N
operator|>
name|LLVM_CONSTEXPR
specifier|inline
name|size_t
name|array_lengthof
argument_list|(
argument|T (&)[N]
argument_list|)
block|{
return|return
name|N
return|;
block|}
comment|/// Adapt std::less<T> for array_pod_sort.
name|template
operator|<
name|typename
name|T
operator|>
specifier|inline
name|int
name|array_pod_sort_comparator
argument_list|(
argument|const void *P1
argument_list|,
argument|const void *P2
argument_list|)
block|{
if|if
condition|(
name|std
operator|::
name|less
operator|<
name|T
operator|>
operator|(
operator|)
operator|(
operator|*
name|reinterpret_cast
operator|<
specifier|const
name|T
operator|*
operator|>
operator|(
name|P1
operator|)
operator|,
operator|*
name|reinterpret_cast
operator|<
specifier|const
name|T
operator|*
operator|>
operator|(
name|P2
operator|)
operator|)
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|std
operator|::
name|less
operator|<
name|T
operator|>
operator|(
operator|)
operator|(
operator|*
name|reinterpret_cast
operator|<
specifier|const
name|T
operator|*
operator|>
operator|(
name|P2
operator|)
operator|,
operator|*
name|reinterpret_cast
operator|<
specifier|const
name|T
operator|*
operator|>
operator|(
name|P1
operator|)
operator|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
comment|/// get_array_pod_sort_comparator - This is an internal helper function used to
comment|/// get type deduction of T right.
name|template
operator|<
name|typename
name|T
operator|>
specifier|inline
name|int
argument_list|(
argument|*get_array_pod_sort_comparator(const T&)
argument_list|)
operator|(
specifier|const
name|void
operator|*
operator|,
specifier|const
name|void
operator|*
operator|)
block|{
return|return
name|array_pod_sort_comparator
operator|<
name|T
operator|>
return|;
block|}
comment|/// array_pod_sort - This sorts an array with the specified start and end
comment|/// extent.  This is just like std::sort, except that it calls qsort instead of
comment|/// using an inlined template.  qsort is slightly slower than std::sort, but
comment|/// most sorts are not performance critical in LLVM and std::sort has to be
comment|/// template instantiated for each type, leading to significant measured code
comment|/// bloat.  This function should generally be used instead of std::sort where
comment|/// possible.
comment|///
comment|/// This function assumes that you have simple POD-like types that can be
comment|/// compared with std::less and can be moved with memcpy.  If this isn't true,
comment|/// you should use std::sort.
comment|///
comment|/// NOTE: If qsort_r were portable, we could allow a custom comparator and
comment|/// default to std::less.
name|template
operator|<
name|class
name|IteratorTy
operator|>
specifier|inline
name|void
name|array_pod_sort
argument_list|(
argument|IteratorTy Start
argument_list|,
argument|IteratorTy End
argument_list|)
block|{
comment|// Don't dereference start iterator of empty sequence.
if|if
condition|(
name|Start
operator|==
name|End
condition|)
return|return;
name|qsort
argument_list|(
operator|&
operator|*
name|Start
argument_list|,
name|End
operator|-
name|Start
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|Start
argument_list|)
argument_list|,
name|get_array_pod_sort_comparator
argument_list|(
operator|*
name|Start
argument_list|)
argument_list|)
block|; }
name|template
operator|<
name|class
name|IteratorTy
operator|>
specifier|inline
name|void
name|array_pod_sort
argument_list|(
argument|IteratorTy Start
argument_list|,
argument|IteratorTy End
argument_list|,
argument|int (*Compare)(         const typename std::iterator_traits<IteratorTy>::value_type *,         const typename std::iterator_traits<IteratorTy>::value_type *)
argument_list|)
block|{
comment|// Don't dereference start iterator of empty sequence.
if|if
condition|(
name|Start
operator|==
name|End
condition|)
return|return;
name|qsort
argument_list|(
operator|&
operator|*
name|Start
argument_list|,
name|End
operator|-
name|Start
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|Start
argument_list|)
argument_list|,
name|reinterpret_cast
operator|<
name|int
argument_list|(
operator|*
argument_list|)
argument_list|(
specifier|const
name|void
operator|*
argument_list|,
specifier|const
name|void
operator|*
argument_list|)
operator|>
operator|(
name|Compare
operator|)
argument_list|)
block|; }
comment|//===----------------------------------------------------------------------===//
comment|//     Extra additions to<algorithm>
comment|//===----------------------------------------------------------------------===//
comment|/// For a container of pointers, deletes the pointers and then clears the
comment|/// container.
name|template
operator|<
name|typename
name|Container
operator|>
name|void
name|DeleteContainerPointers
argument_list|(
argument|Container&C
argument_list|)
block|{
for|for
control|(
name|typename
name|Container
operator|::
name|iterator
name|I
operator|=
name|C
operator|.
name|begin
argument_list|()
operator|,
name|E
operator|=
name|C
operator|.
name|end
argument_list|()
init|;
name|I
operator|!=
name|E
condition|;
operator|++
name|I
control|)
name|delete
modifier|*
name|I
decl_stmt|;
name|C
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
end_decl_stmt

begin_comment
comment|/// In a container of pairs (usually a map) whose second element is a pointer,
end_comment

begin_comment
comment|/// deletes the second elements and then clears the container.
end_comment

begin_expr_stmt
name|template
operator|<
name|typename
name|Container
operator|>
name|void
name|DeleteContainerSeconds
argument_list|(
argument|Container&C
argument_list|)
block|{
for|for
control|(
name|typename
name|Container
operator|::
name|iterator
name|I
operator|=
name|C
operator|.
name|begin
argument_list|()
operator|,
name|E
operator|=
name|C
operator|.
name|end
argument_list|()
init|;
name|I
operator|!=
name|E
condition|;
operator|++
name|I
control|)
name|delete
name|I
operator|->
name|second
decl_stmt|;
name|C
operator|.
name|clear
argument_list|()
expr_stmt|;
end_expr_stmt

begin_comment
unit|}
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|//     Extra additions to<memory>
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_if
if|#
directive|if
name|LLVM_HAS_VARIADIC_TEMPLATES
end_if

begin_comment
comment|// Implement make_unique according to N3656.
end_comment

begin_comment
comment|/// \brief Constructs a `new T()` with the given args and returns a
end_comment

begin_comment
comment|///        `unique_ptr<T>` which owns the object.
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|/// Example:
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|///     auto p = make_unique<int>();
end_comment

begin_comment
comment|///     auto p = make_unique<std::tuple<int, int>>(0, 1);
end_comment

begin_expr_stmt
unit|template
operator|<
name|class
name|T
operator|,
name|class
operator|...
name|Args
operator|>
name|typename
name|std
operator|::
name|enable_if
operator|<
operator|!
name|std
operator|::
name|is_array
operator|<
name|T
operator|>
operator|::
name|value
operator|,
name|std
operator|::
name|unique_ptr
operator|<
name|T
operator|>>
operator|::
name|type
name|make_unique
argument_list|(
argument|Args&&... args
argument_list|)
block|{
return|return
name|std
operator|::
name|unique_ptr
operator|<
name|T
operator|>
operator|(
name|new
name|T
argument_list|(
name|std
operator|::
name|forward
operator|<
name|Args
operator|>
operator|(
name|args
operator|)
operator|...
argument_list|)
operator|)
return|;
block|}
end_expr_stmt

begin_comment
comment|/// \brief Constructs a `new T[n]` with the given args and returns a
end_comment

begin_comment
comment|///        `unique_ptr<T[]>` which owns the object.
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|/// \param n size of the new array.
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|/// Example:
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|///     auto p = make_unique<int[]>(2); // value-initializes the array with 0's.
end_comment

begin_expr_stmt
name|template
operator|<
name|class
name|T
operator|>
name|typename
name|std
operator|::
name|enable_if
operator|<
name|std
operator|::
name|is_array
operator|<
name|T
operator|>
operator|::
name|value
operator|&&
name|std
operator|::
name|extent
operator|<
name|T
operator|>
operator|::
name|value
operator|==
literal|0
operator|,
name|std
operator|::
name|unique_ptr
operator|<
name|T
operator|>>
operator|::
name|type
name|make_unique
argument_list|(
argument|size_t n
argument_list|)
block|{
return|return
name|std
operator|::
name|unique_ptr
operator|<
name|T
operator|>
operator|(
name|new
name|typename
name|std
operator|::
name|remove_extent
operator|<
name|T
operator|>
operator|::
name|type
index|[
name|n
index|]
operator|(
operator|)
operator|)
return|;
block|}
end_expr_stmt

begin_comment
comment|/// This function isn't used and is only here to provide better compile errors.
end_comment

begin_expr_stmt
name|template
operator|<
name|class
name|T
operator|,
name|class
operator|...
name|Args
operator|>
name|typename
name|std
operator|::
name|enable_if
operator|<
name|std
operator|::
name|extent
operator|<
name|T
operator|>
operator|::
name|value
operator|!=
literal|0
operator|>
operator|::
name|type
name|make_unique
argument_list|(
argument|Args&&...
argument_list|)
name|LLVM_DELETED_FUNCTION
expr_stmt|;
end_expr_stmt

begin_else
else|#
directive|else
end_else

begin_expr_stmt
name|template
operator|<
name|class
name|T
operator|>
name|typename
name|std
operator|::
name|enable_if
operator|<
operator|!
name|std
operator|::
name|is_array
operator|<
name|T
operator|>
operator|::
name|value
operator|,
name|std
operator|::
name|unique_ptr
operator|<
name|T
operator|>>
operator|::
name|type
name|make_unique
argument_list|()
block|{
return|return
name|std
operator|::
name|unique_ptr
operator|<
name|T
operator|>
operator|(
name|new
name|T
argument_list|()
operator|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|T
operator|,
name|class
name|Arg1
operator|>
name|typename
name|std
operator|::
name|enable_if
operator|<
operator|!
name|std
operator|::
name|is_array
operator|<
name|T
operator|>
operator|::
name|value
operator|,
name|std
operator|::
name|unique_ptr
operator|<
name|T
operator|>>
operator|::
name|type
name|make_unique
argument_list|(
argument|Arg1&&arg1
argument_list|)
block|{
return|return
name|std
operator|::
name|unique_ptr
operator|<
name|T
operator|>
operator|(
name|new
name|T
argument_list|(
name|std
operator|::
name|forward
operator|<
name|Arg1
operator|>
operator|(
name|arg1
operator|)
argument_list|)
operator|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|T
operator|,
name|class
name|Arg1
operator|,
name|class
name|Arg2
operator|>
name|typename
name|std
operator|::
name|enable_if
operator|<
operator|!
name|std
operator|::
name|is_array
operator|<
name|T
operator|>
operator|::
name|value
operator|,
name|std
operator|::
name|unique_ptr
operator|<
name|T
operator|>>
operator|::
name|type
name|make_unique
argument_list|(
argument|Arg1&&arg1
argument_list|,
argument|Arg2&&arg2
argument_list|)
block|{
return|return
name|std
operator|::
name|unique_ptr
operator|<
name|T
operator|>
operator|(
name|new
name|T
argument_list|(
name|std
operator|::
name|forward
operator|<
name|Arg1
operator|>
operator|(
name|arg1
operator|)
argument_list|,
name|std
operator|::
name|forward
operator|<
name|Arg2
operator|>
operator|(
name|arg2
operator|)
argument_list|)
operator|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|T
operator|,
name|class
name|Arg1
operator|,
name|class
name|Arg2
operator|,
name|class
name|Arg3
operator|>
name|typename
name|std
operator|::
name|enable_if
operator|<
operator|!
name|std
operator|::
name|is_array
operator|<
name|T
operator|>
operator|::
name|value
operator|,
name|std
operator|::
name|unique_ptr
operator|<
name|T
operator|>>
operator|::
name|type
name|make_unique
argument_list|(
argument|Arg1&&arg1
argument_list|,
argument|Arg2&&arg2
argument_list|,
argument|Arg3&&arg3
argument_list|)
block|{
return|return
name|std
operator|::
name|unique_ptr
operator|<
name|T
operator|>
operator|(
name|new
name|T
argument_list|(
name|std
operator|::
name|forward
operator|<
name|Arg1
operator|>
operator|(
name|arg1
operator|)
argument_list|,
name|std
operator|::
name|forward
operator|<
name|Arg2
operator|>
operator|(
name|arg2
operator|)
argument_list|,
name|std
operator|::
name|forward
operator|<
name|Arg3
operator|>
operator|(
name|arg3
operator|)
argument_list|)
operator|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|T
operator|,
name|class
name|Arg1
operator|,
name|class
name|Arg2
operator|,
name|class
name|Arg3
operator|,
name|class
name|Arg4
operator|>
name|typename
name|std
operator|::
name|enable_if
operator|<
operator|!
name|std
operator|::
name|is_array
operator|<
name|T
operator|>
operator|::
name|value
operator|,
name|std
operator|::
name|unique_ptr
operator|<
name|T
operator|>>
operator|::
name|type
name|make_unique
argument_list|(
argument|Arg1&&arg1
argument_list|,
argument|Arg2&&arg2
argument_list|,
argument|Arg3&&arg3
argument_list|,
argument|Arg4&&arg4
argument_list|)
block|{
return|return
name|std
operator|::
name|unique_ptr
operator|<
name|T
operator|>
operator|(
name|new
name|T
argument_list|(
name|std
operator|::
name|forward
operator|<
name|Arg1
operator|>
operator|(
name|arg1
operator|)
argument_list|,
name|std
operator|::
name|forward
operator|<
name|Arg2
operator|>
operator|(
name|arg2
operator|)
argument_list|,
name|std
operator|::
name|forward
operator|<
name|Arg3
operator|>
operator|(
name|arg3
operator|)
argument_list|,
name|std
operator|::
name|forward
operator|<
name|Arg4
operator|>
operator|(
name|arg4
operator|)
argument_list|)
operator|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|T
operator|,
name|class
name|Arg1
operator|,
name|class
name|Arg2
operator|,
name|class
name|Arg3
operator|,
name|class
name|Arg4
operator|,
name|class
name|Arg5
operator|>
name|typename
name|std
operator|::
name|enable_if
operator|<
operator|!
name|std
operator|::
name|is_array
operator|<
name|T
operator|>
operator|::
name|value
operator|,
name|std
operator|::
name|unique_ptr
operator|<
name|T
operator|>>
operator|::
name|type
name|make_unique
argument_list|(
argument|Arg1&&arg1
argument_list|,
argument|Arg2&&arg2
argument_list|,
argument|Arg3&&arg3
argument_list|,
argument|Arg4&&arg4
argument_list|,
argument|Arg5&&arg5
argument_list|)
block|{
return|return
name|std
operator|::
name|unique_ptr
operator|<
name|T
operator|>
operator|(
name|new
name|T
argument_list|(
name|std
operator|::
name|forward
operator|<
name|Arg1
operator|>
operator|(
name|arg1
operator|)
argument_list|,
name|std
operator|::
name|forward
operator|<
name|Arg2
operator|>
operator|(
name|arg2
operator|)
argument_list|,
name|std
operator|::
name|forward
operator|<
name|Arg3
operator|>
operator|(
name|arg3
operator|)
argument_list|,
name|std
operator|::
name|forward
operator|<
name|Arg4
operator|>
operator|(
name|arg4
operator|)
argument_list|,
name|std
operator|::
name|forward
operator|<
name|Arg5
operator|>
operator|(
name|arg5
operator|)
argument_list|)
operator|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|T
operator|,
name|class
name|Arg1
operator|,
name|class
name|Arg2
operator|,
name|class
name|Arg3
operator|,
name|class
name|Arg4
operator|,
name|class
name|Arg5
operator|,
name|class
name|Arg6
operator|>
name|typename
name|std
operator|::
name|enable_if
operator|<
operator|!
name|std
operator|::
name|is_array
operator|<
name|T
operator|>
operator|::
name|value
operator|,
name|std
operator|::
name|unique_ptr
operator|<
name|T
operator|>>
operator|::
name|type
name|make_unique
argument_list|(
argument|Arg1&&arg1
argument_list|,
argument|Arg2&&arg2
argument_list|,
argument|Arg3&&arg3
argument_list|,
argument|Arg4&&arg4
argument_list|,
argument|Arg5&&arg5
argument_list|,
argument|Arg6&&arg6
argument_list|)
block|{
return|return
name|std
operator|::
name|unique_ptr
operator|<
name|T
operator|>
operator|(
name|new
name|T
argument_list|(
name|std
operator|::
name|forward
operator|<
name|Arg1
operator|>
operator|(
name|arg1
operator|)
argument_list|,
name|std
operator|::
name|forward
operator|<
name|Arg2
operator|>
operator|(
name|arg2
operator|)
argument_list|,
name|std
operator|::
name|forward
operator|<
name|Arg3
operator|>
operator|(
name|arg3
operator|)
argument_list|,
name|std
operator|::
name|forward
operator|<
name|Arg4
operator|>
operator|(
name|arg4
operator|)
argument_list|,
name|std
operator|::
name|forward
operator|<
name|Arg5
operator|>
operator|(
name|arg5
operator|)
argument_list|,
name|std
operator|::
name|forward
operator|<
name|Arg6
operator|>
operator|(
name|arg6
operator|)
argument_list|)
operator|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|T
operator|,
name|class
name|Arg1
operator|,
name|class
name|Arg2
operator|,
name|class
name|Arg3
operator|,
name|class
name|Arg4
operator|,
name|class
name|Arg5
operator|,
name|class
name|Arg6
operator|,
name|class
name|Arg7
operator|>
name|typename
name|std
operator|::
name|enable_if
operator|<
operator|!
name|std
operator|::
name|is_array
operator|<
name|T
operator|>
operator|::
name|value
operator|,
name|std
operator|::
name|unique_ptr
operator|<
name|T
operator|>>
operator|::
name|type
name|make_unique
argument_list|(
argument|Arg1&&arg1
argument_list|,
argument|Arg2&&arg2
argument_list|,
argument|Arg3&&arg3
argument_list|,
argument|Arg4&&arg4
argument_list|,
argument|Arg5&&arg5
argument_list|,
argument|Arg6&&arg6
argument_list|,
argument|Arg7&&arg7
argument_list|)
block|{
return|return
name|std
operator|::
name|unique_ptr
operator|<
name|T
operator|>
operator|(
name|new
name|T
argument_list|(
name|std
operator|::
name|forward
operator|<
name|Arg1
operator|>
operator|(
name|arg1
operator|)
argument_list|,
name|std
operator|::
name|forward
operator|<
name|Arg2
operator|>
operator|(
name|arg2
operator|)
argument_list|,
name|std
operator|::
name|forward
operator|<
name|Arg3
operator|>
operator|(
name|arg3
operator|)
argument_list|,
name|std
operator|::
name|forward
operator|<
name|Arg4
operator|>
operator|(
name|arg4
operator|)
argument_list|,
name|std
operator|::
name|forward
operator|<
name|Arg5
operator|>
operator|(
name|arg5
operator|)
argument_list|,
name|std
operator|::
name|forward
operator|<
name|Arg6
operator|>
operator|(
name|arg6
operator|)
argument_list|,
name|std
operator|::
name|forward
operator|<
name|Arg7
operator|>
operator|(
name|arg7
operator|)
argument_list|)
operator|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|T
operator|,
name|class
name|Arg1
operator|,
name|class
name|Arg2
operator|,
name|class
name|Arg3
operator|,
name|class
name|Arg4
operator|,
name|class
name|Arg5
operator|,
name|class
name|Arg6
operator|,
name|class
name|Arg7
operator|,
name|class
name|Arg8
operator|>
name|typename
name|std
operator|::
name|enable_if
operator|<
operator|!
name|std
operator|::
name|is_array
operator|<
name|T
operator|>
operator|::
name|value
operator|,
name|std
operator|::
name|unique_ptr
operator|<
name|T
operator|>>
operator|::
name|type
name|make_unique
argument_list|(
argument|Arg1&&arg1
argument_list|,
argument|Arg2&&arg2
argument_list|,
argument|Arg3&&arg3
argument_list|,
argument|Arg4&&arg4
argument_list|,
argument|Arg5&&arg5
argument_list|,
argument|Arg6&&arg6
argument_list|,
argument|Arg7&&arg7
argument_list|,
argument|Arg8&&arg8
argument_list|)
block|{
return|return
name|std
operator|::
name|unique_ptr
operator|<
name|T
operator|>
operator|(
name|new
name|T
argument_list|(
name|std
operator|::
name|forward
operator|<
name|Arg1
operator|>
operator|(
name|arg1
operator|)
argument_list|,
name|std
operator|::
name|forward
operator|<
name|Arg2
operator|>
operator|(
name|arg2
operator|)
argument_list|,
name|std
operator|::
name|forward
operator|<
name|Arg3
operator|>
operator|(
name|arg3
operator|)
argument_list|,
name|std
operator|::
name|forward
operator|<
name|Arg4
operator|>
operator|(
name|arg4
operator|)
argument_list|,
name|std
operator|::
name|forward
operator|<
name|Arg5
operator|>
operator|(
name|arg5
operator|)
argument_list|,
name|std
operator|::
name|forward
operator|<
name|Arg6
operator|>
operator|(
name|arg6
operator|)
argument_list|,
name|std
operator|::
name|forward
operator|<
name|Arg7
operator|>
operator|(
name|arg7
operator|)
argument_list|,
name|std
operator|::
name|forward
operator|<
name|Arg8
operator|>
operator|(
name|arg8
operator|)
argument_list|)
operator|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|T
operator|,
name|class
name|Arg1
operator|,
name|class
name|Arg2
operator|,
name|class
name|Arg3
operator|,
name|class
name|Arg4
operator|,
name|class
name|Arg5
operator|,
name|class
name|Arg6
operator|,
name|class
name|Arg7
operator|,
name|class
name|Arg8
operator|,
name|class
name|Arg9
operator|>
name|typename
name|std
operator|::
name|enable_if
operator|<
operator|!
name|std
operator|::
name|is_array
operator|<
name|T
operator|>
operator|::
name|value
operator|,
name|std
operator|::
name|unique_ptr
operator|<
name|T
operator|>>
operator|::
name|type
name|make_unique
argument_list|(
argument|Arg1&&arg1
argument_list|,
argument|Arg2&&arg2
argument_list|,
argument|Arg3&&arg3
argument_list|,
argument|Arg4&&arg4
argument_list|,
argument|Arg5&&arg5
argument_list|,
argument|Arg6&&arg6
argument_list|,
argument|Arg7&&arg7
argument_list|,
argument|Arg8&&arg8
argument_list|,
argument|Arg9&&arg9
argument_list|)
block|{
return|return
name|std
operator|::
name|unique_ptr
operator|<
name|T
operator|>
operator|(
name|new
name|T
argument_list|(
name|std
operator|::
name|forward
operator|<
name|Arg1
operator|>
operator|(
name|arg1
operator|)
argument_list|,
name|std
operator|::
name|forward
operator|<
name|Arg2
operator|>
operator|(
name|arg2
operator|)
argument_list|,
name|std
operator|::
name|forward
operator|<
name|Arg3
operator|>
operator|(
name|arg3
operator|)
argument_list|,
name|std
operator|::
name|forward
operator|<
name|Arg4
operator|>
operator|(
name|arg4
operator|)
argument_list|,
name|std
operator|::
name|forward
operator|<
name|Arg5
operator|>
operator|(
name|arg5
operator|)
argument_list|,
name|std
operator|::
name|forward
operator|<
name|Arg6
operator|>
operator|(
name|arg6
operator|)
argument_list|,
name|std
operator|::
name|forward
operator|<
name|Arg7
operator|>
operator|(
name|arg7
operator|)
argument_list|,
name|std
operator|::
name|forward
operator|<
name|Arg8
operator|>
operator|(
name|arg8
operator|)
argument_list|,
name|std
operator|::
name|forward
operator|<
name|Arg9
operator|>
operator|(
name|arg9
operator|)
argument_list|)
operator|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|T
operator|,
name|class
name|Arg1
operator|,
name|class
name|Arg2
operator|,
name|class
name|Arg3
operator|,
name|class
name|Arg4
operator|,
name|class
name|Arg5
operator|,
name|class
name|Arg6
operator|,
name|class
name|Arg7
operator|,
name|class
name|Arg8
operator|,
name|class
name|Arg9
operator|,
name|class
name|Arg10
operator|>
name|typename
name|std
operator|::
name|enable_if
operator|<
operator|!
name|std
operator|::
name|is_array
operator|<
name|T
operator|>
operator|::
name|value
operator|,
name|std
operator|::
name|unique_ptr
operator|<
name|T
operator|>>
operator|::
name|type
name|make_unique
argument_list|(
argument|Arg1&&arg1
argument_list|,
argument|Arg2&&arg2
argument_list|,
argument|Arg3&&arg3
argument_list|,
argument|Arg4&&arg4
argument_list|,
argument|Arg5&&arg5
argument_list|,
argument|Arg6&&arg6
argument_list|,
argument|Arg7&&arg7
argument_list|,
argument|Arg8&&arg8
argument_list|,
argument|Arg9&&arg9
argument_list|,
argument|Arg10&&arg10
argument_list|)
block|{
return|return
name|std
operator|::
name|unique_ptr
operator|<
name|T
operator|>
operator|(
name|new
name|T
argument_list|(
name|std
operator|::
name|forward
operator|<
name|Arg1
operator|>
operator|(
name|arg1
operator|)
argument_list|,
name|std
operator|::
name|forward
operator|<
name|Arg2
operator|>
operator|(
name|arg2
operator|)
argument_list|,
name|std
operator|::
name|forward
operator|<
name|Arg3
operator|>
operator|(
name|arg3
operator|)
argument_list|,
name|std
operator|::
name|forward
operator|<
name|Arg4
operator|>
operator|(
name|arg4
operator|)
argument_list|,
name|std
operator|::
name|forward
operator|<
name|Arg5
operator|>
operator|(
name|arg5
operator|)
argument_list|,
name|std
operator|::
name|forward
operator|<
name|Arg6
operator|>
operator|(
name|arg6
operator|)
argument_list|,
name|std
operator|::
name|forward
operator|<
name|Arg7
operator|>
operator|(
name|arg7
operator|)
argument_list|,
name|std
operator|::
name|forward
operator|<
name|Arg8
operator|>
operator|(
name|arg8
operator|)
argument_list|,
name|std
operator|::
name|forward
operator|<
name|Arg9
operator|>
operator|(
name|arg9
operator|)
argument_list|,
name|std
operator|::
name|forward
operator|<
name|Arg10
operator|>
operator|(
name|arg10
operator|)
argument_list|)
operator|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|T
operator|>
name|typename
name|std
operator|::
name|enable_if
operator|<
name|std
operator|::
name|is_array
operator|<
name|T
operator|>
operator|::
name|value
operator|&&
name|std
operator|::
name|extent
operator|<
name|T
operator|>
operator|::
name|value
operator|==
literal|0
operator|,
name|std
operator|::
name|unique_ptr
operator|<
name|T
operator|>>
operator|::
name|type
name|make_unique
argument_list|(
argument|size_t n
argument_list|)
block|{
return|return
name|std
operator|::
name|unique_ptr
operator|<
name|T
operator|>
operator|(
name|new
name|typename
name|std
operator|::
name|remove_extent
operator|<
name|T
operator|>
operator|::
name|type
index|[
name|n
index|]
operator|(
operator|)
operator|)
return|;
block|}
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_expr_stmt
name|template
operator|<
name|typename
name|First
operator|,
name|typename
name|Second
operator|>
expr|struct
name|pair_hash
block|{
name|size_t
name|operator
argument_list|()
operator|(
specifier|const
name|std
operator|::
name|pair
operator|<
name|First
operator|,
name|Second
operator|>
operator|&
name|P
operator|)
specifier|const
block|{
return|return
name|std
operator|::
name|hash
operator|<
name|First
operator|>
operator|(
operator|)
operator|(
name|P
operator|.
name|first
operator|)
operator|*
literal|31
operator|+
name|std
operator|::
name|hash
operator|<
name|Second
operator|>
operator|(
operator|)
operator|(
name|P
operator|.
name|second
operator|)
return|;
block|}
end_expr_stmt

begin_comment
unit|};  }
comment|// End llvm namespace
end_comment

begin_endif
endif|#
directive|endif
end_endif

end_unit

