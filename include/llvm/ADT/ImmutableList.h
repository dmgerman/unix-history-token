begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//==--- ImmutableList.h - Immutable (functional) list interface --*- C++ -*-==//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file defines the ImmutableList class.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LLVM_ADT_IMMUTABLELIST_H
end_ifndef

begin_define
define|#
directive|define
name|LLVM_ADT_IMMUTABLELIST_H
end_define

begin_include
include|#
directive|include
file|"llvm/ADT/FoldingSet.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/Allocator.h"
end_include

begin_include
include|#
directive|include
file|<cassert>
end_include

begin_include
include|#
directive|include
file|<cstdint>
end_include

begin_include
include|#
directive|include
file|<new>
end_include

begin_decl_stmt
name|namespace
name|llvm
block|{
name|template
operator|<
name|typename
name|T
operator|>
name|class
name|ImmutableListFactory
expr_stmt|;
name|template
operator|<
name|typename
name|T
operator|>
name|class
name|ImmutableListImpl
operator|:
name|public
name|FoldingSetNode
block|{
name|friend
name|class
name|ImmutableListFactory
operator|<
name|T
operator|>
block|;
name|T
name|Head
block|;
specifier|const
name|ImmutableListImpl
operator|*
name|Tail
block|;
name|ImmutableListImpl
argument_list|(
specifier|const
name|T
operator|&
name|head
argument_list|,
specifier|const
name|ImmutableListImpl
operator|*
name|tail
operator|=
name|nullptr
argument_list|)
operator|:
name|Head
argument_list|(
name|head
argument_list|)
block|,
name|Tail
argument_list|(
argument|tail
argument_list|)
block|{}
name|public
operator|:
name|ImmutableListImpl
argument_list|(
specifier|const
name|ImmutableListImpl
operator|&
argument_list|)
operator|=
name|delete
block|;
name|ImmutableListImpl
operator|&
name|operator
operator|=
operator|(
specifier|const
name|ImmutableListImpl
operator|&
operator|)
operator|=
name|delete
block|;
specifier|const
name|T
operator|&
name|getHead
argument_list|()
specifier|const
block|{
return|return
name|Head
return|;
block|}
specifier|const
name|ImmutableListImpl
operator|*
name|getTail
argument_list|()
specifier|const
block|{
return|return
name|Tail
return|;
block|}
specifier|static
specifier|inline
name|void
name|Profile
argument_list|(
argument|FoldingSetNodeID& ID
argument_list|,
argument|const T& H
argument_list|,
argument|const ImmutableListImpl* L
argument_list|)
block|{
name|ID
operator|.
name|AddPointer
argument_list|(
name|L
argument_list|)
block|;
name|ID
operator|.
name|Add
argument_list|(
name|H
argument_list|)
block|;   }
name|void
name|Profile
argument_list|(
argument|FoldingSetNodeID& ID
argument_list|)
block|{
name|Profile
argument_list|(
name|ID
argument_list|,
name|Head
argument_list|,
name|Tail
argument_list|)
block|;   }
expr|}
block|;
comment|/// ImmutableList - This class represents an immutable (functional) list.
comment|///  It is implemented as a smart pointer (wraps ImmutableListImpl), so it
comment|///  it is intended to always be copied by value as if it were a pointer.
comment|///  This interface matches ImmutableSet and ImmutableMap.  ImmutableList
comment|///  objects should almost never be created directly, and instead should
comment|///  be created by ImmutableListFactory objects that manage the lifetime
comment|///  of a group of lists.  When the factory object is reclaimed, all lists
comment|///  created by that factory are released as well.
name|template
operator|<
name|typename
name|T
operator|>
name|class
name|ImmutableList
block|{
name|public
operator|:
typedef|typedef
name|T
name|value_type
typedef|;
typedef|typedef
name|ImmutableListFactory
operator|<
name|T
operator|>
name|Factory
expr_stmt|;
name|private
operator|:
specifier|const
name|ImmutableListImpl
operator|<
name|T
operator|>
operator|*
name|X
expr_stmt|;
name|public
label|:
comment|// This constructor should normally only be called by ImmutableListFactory<T>.
comment|// There may be cases, however, when one needs to extract the internal pointer
comment|// and reconstruct a list object from that pointer.
name|ImmutableList
argument_list|(
specifier|const
name|ImmutableListImpl
operator|<
name|T
operator|>
operator|*
name|x
operator|=
name|nullptr
argument_list|)
operator|:
name|X
argument_list|(
argument|x
argument_list|)
block|{}
specifier|const
name|ImmutableListImpl
operator|<
name|T
operator|>
operator|*
name|getInternalPointer
argument_list|()
specifier|const
block|{
return|return
name|X
return|;
block|}
name|class
name|iterator
block|{
specifier|const
name|ImmutableListImpl
operator|<
name|T
operator|>
operator|*
name|L
operator|=
name|nullptr
expr_stmt|;
name|public
label|:
name|iterator
argument_list|()
operator|=
expr|default
expr_stmt|;
name|iterator
argument_list|(
argument|ImmutableList l
argument_list|)
block|:
name|L
argument_list|(
argument|l.getInternalPointer()
argument_list|)
block|{}
name|iterator
operator|&
name|operator
operator|++
operator|(
operator|)
block|{
name|L
operator|=
name|L
operator|->
name|getTail
argument_list|()
block|;
return|return
operator|*
name|this
return|;
block|}
name|bool
name|operator
operator|==
operator|(
specifier|const
name|iterator
operator|&
name|I
operator|)
specifier|const
block|{
return|return
name|L
operator|==
name|I
operator|.
name|L
return|;
block|}
name|bool
name|operator
operator|!=
operator|(
specifier|const
name|iterator
operator|&
name|I
operator|)
specifier|const
block|{
return|return
name|L
operator|!=
name|I
operator|.
name|L
return|;
block|}
specifier|const
name|value_type
operator|&
name|operator
operator|*
operator|(
operator|)
specifier|const
block|{
return|return
name|L
operator|->
name|getHead
argument_list|()
return|;
block|}
name|ImmutableList
name|getList
argument_list|()
specifier|const
block|{
return|return
name|L
return|;
block|}
block|}
empty_stmt|;
comment|/// begin - Returns an iterator referring to the head of the list, or
comment|///  an iterator denoting the end of the list if the list is empty.
name|iterator
name|begin
argument_list|()
specifier|const
block|{
return|return
name|iterator
argument_list|(
name|X
argument_list|)
return|;
block|}
comment|/// end - Returns an iterator denoting the end of the list.  This iterator
comment|///  does not refer to a valid list element.
name|iterator
name|end
argument_list|()
specifier|const
block|{
return|return
name|iterator
argument_list|()
return|;
block|}
comment|/// isEmpty - Returns true if the list is empty.
name|bool
name|isEmpty
argument_list|()
specifier|const
block|{
return|return
operator|!
name|X
return|;
block|}
name|bool
name|contains
argument_list|(
specifier|const
name|T
operator|&
name|V
argument_list|)
decl|const
block|{
for|for
control|(
name|iterator
name|I
init|=
name|begin
argument_list|()
init|,
name|E
init|=
name|end
argument_list|()
init|;
name|I
operator|!=
name|E
condition|;
operator|++
name|I
control|)
block|{
if|if
condition|(
operator|*
name|I
operator|==
name|V
condition|)
return|return
name|true
return|;
block|}
return|return
name|false
return|;
block|}
comment|/// isEqual - Returns true if two lists are equal.  Because all lists created
comment|///  from the same ImmutableListFactory are uniqued, this has O(1) complexity
comment|///  because it the contents of the list do not need to be compared.  Note
comment|///  that you should only compare two lists created from the same
comment|///  ImmutableListFactory.
name|bool
name|isEqual
argument_list|(
specifier|const
name|ImmutableList
operator|&
name|L
argument_list|)
decl|const
block|{
return|return
name|X
operator|==
name|L
operator|.
name|X
return|;
block|}
name|bool
name|operator
operator|==
operator|(
specifier|const
name|ImmutableList
operator|&
name|L
operator|)
specifier|const
block|{
return|return
name|isEqual
argument_list|(
name|L
argument_list|)
return|;
block|}
comment|/// getHead - Returns the head of the list.
specifier|const
name|T
modifier|&
name|getHead
parameter_list|()
block|{
name|assert
argument_list|(
operator|!
name|isEmpty
argument_list|()
operator|&&
literal|"Cannot get the head of an empty list."
argument_list|)
expr_stmt|;
return|return
name|X
operator|->
name|getHead
argument_list|()
return|;
block|}
comment|/// getTail - Returns the tail of the list, which is another (possibly empty)
comment|///  ImmutableList.
name|ImmutableList
name|getTail
parameter_list|()
block|{
return|return
name|X
condition|?
name|X
operator|->
name|getTail
argument_list|()
else|:
name|nullptr
return|;
block|}
name|void
name|Profile
argument_list|(
name|FoldingSetNodeID
operator|&
name|ID
argument_list|)
decl|const
block|{
name|ID
operator|.
name|AddPointer
argument_list|(
name|X
argument_list|)
expr_stmt|;
block|}
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|T
operator|>
name|class
name|ImmutableListFactory
block|{
typedef|typedef
name|ImmutableListImpl
operator|<
name|T
operator|>
name|ListTy
expr_stmt|;
end_expr_stmt

begin_typedef
typedef|typedef
name|FoldingSet
operator|<
name|ListTy
operator|>
name|CacheTy
expr_stmt|;
end_typedef

begin_decl_stmt
name|CacheTy
name|Cache
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|uintptr_t
name|Allocator
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|bool
name|ownsAllocator
argument_list|()
specifier|const
block|{
return|return
operator|(
name|Allocator
operator|&
literal|0x1
operator|)
operator|==
literal|0
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|BumpPtrAllocator
operator|&
name|getAllocator
argument_list|()
specifier|const
block|{
return|return
operator|*
name|reinterpret_cast
operator|<
name|BumpPtrAllocator
operator|*
operator|>
operator|(
name|Allocator
operator|&
operator|~
literal|0x1
operator|)
return|;
block|}
end_expr_stmt

begin_label
name|public
label|:
end_label

begin_expr_stmt
name|ImmutableListFactory
argument_list|()
operator|:
name|Allocator
argument_list|(
argument|reinterpret_cast<uintptr_t>(new BumpPtrAllocator())
argument_list|)
block|{}
name|ImmutableListFactory
argument_list|(
name|BumpPtrAllocator
operator|&
name|Alloc
argument_list|)
operator|:
name|Allocator
argument_list|(
argument|reinterpret_cast<uintptr_t>(&Alloc) |
literal|0x1
argument_list|)
block|{}
operator|~
name|ImmutableListFactory
argument_list|()
block|{
if|if
condition|(
name|ownsAllocator
argument_list|()
condition|)
name|delete
modifier|&
name|getAllocator
parameter_list|()
function_decl|;
block|}
end_expr_stmt

begin_expr_stmt
name|ImmutableList
operator|<
name|T
operator|>
name|concat
argument_list|(
argument|const T& Head
argument_list|,
argument|ImmutableList<T> Tail
argument_list|)
block|{
comment|// Profile the new list to see if it already exists in our cache.
name|FoldingSetNodeID
name|ID
block|;
name|void
operator|*
name|InsertPos
block|;
specifier|const
name|ListTy
operator|*
name|TailImpl
operator|=
name|Tail
operator|.
name|getInternalPointer
argument_list|()
block|;
name|ListTy
operator|::
name|Profile
argument_list|(
name|ID
argument_list|,
name|Head
argument_list|,
name|TailImpl
argument_list|)
block|;
name|ListTy
operator|*
name|L
operator|=
name|Cache
operator|.
name|FindNodeOrInsertPos
argument_list|(
name|ID
argument_list|,
name|InsertPos
argument_list|)
block|;
if|if
condition|(
operator|!
name|L
condition|)
block|{
comment|// The list does not exist in our cache.  Create it.
name|BumpPtrAllocator
modifier|&
name|A
init|=
name|getAllocator
argument_list|()
decl_stmt|;
name|L
operator|=
operator|(
name|ListTy
operator|*
operator|)
name|A
operator|.
name|Allocate
operator|<
name|ListTy
operator|>
operator|(
operator|)
expr_stmt|;
name|new
argument_list|(
argument|L
argument_list|)
name|ListTy
argument_list|(
name|Head
argument_list|,
name|TailImpl
argument_list|)
expr_stmt|;
comment|// Insert the new list into the cache.
name|Cache
operator|.
name|InsertNode
argument_list|(
name|L
argument_list|,
name|InsertPos
argument_list|)
expr_stmt|;
block|}
end_expr_stmt

begin_return
return|return
name|L
return|;
end_return

begin_expr_stmt
unit|}    ImmutableList
operator|<
name|T
operator|>
name|add
argument_list|(
argument|const T& D
argument_list|,
argument|ImmutableList<T> L
argument_list|)
block|{
return|return
name|concat
argument_list|(
name|D
argument_list|,
name|L
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|ImmutableList
operator|<
name|T
operator|>
name|getEmptyList
argument_list|()
specifier|const
block|{
return|return
name|ImmutableList
operator|<
name|T
operator|>
operator|(
name|nullptr
operator|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|ImmutableList
operator|<
name|T
operator|>
name|create
argument_list|(
argument|const T& X
argument_list|)
block|{
return|return
name|Concat
argument_list|(
name|X
argument_list|,
name|getEmptyList
argument_list|()
argument_list|)
return|;
block|}
end_expr_stmt

begin_comment
unit|};
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|// Partially-specialized Traits.
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_expr_stmt
name|template
operator|<
name|typename
name|T
operator|>
expr|struct
name|DenseMapInfo
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|T
operator|>
expr|struct
name|DenseMapInfo
operator|<
name|ImmutableList
operator|<
name|T
operator|>>
block|{
specifier|static
specifier|inline
name|ImmutableList
operator|<
name|T
operator|>
name|getEmptyKey
argument_list|()
block|{
return|return
name|reinterpret_cast
operator|<
name|ImmutableListImpl
operator|<
name|T
operator|>
operator|*
operator|>
operator|(
operator|-
literal|1
operator|)
return|;
block|}
specifier|static
specifier|inline
name|ImmutableList
operator|<
name|T
operator|>
name|getTombstoneKey
argument_list|()
block|{
return|return
name|reinterpret_cast
operator|<
name|ImmutableListImpl
operator|<
name|T
operator|>
operator|*
operator|>
operator|(
operator|-
literal|2
operator|)
return|;
block|}
end_expr_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|getHashValue
argument_list|(
name|ImmutableList
operator|<
name|T
operator|>
name|X
argument_list|)
block|{
name|uintptr_t
name|PtrVal
init|=
name|reinterpret_cast
operator|<
name|uintptr_t
operator|>
operator|(
name|X
operator|.
name|getInternalPointer
argument_list|()
operator|)
decl_stmt|;
return|return
operator|(
name|unsigned
argument_list|(
operator|(
name|uintptr_t
operator|)
name|PtrVal
argument_list|)
operator|>>
literal|4
operator|)
operator|^
operator|(
name|unsigned
argument_list|(
operator|(
name|uintptr_t
operator|)
name|PtrVal
argument_list|)
operator|>>
literal|9
operator|)
return|;
block|}
end_decl_stmt

begin_decl_stmt
specifier|static
name|bool
name|isEqual
argument_list|(
name|ImmutableList
operator|<
name|T
operator|>
name|X1
argument_list|,
name|ImmutableList
operator|<
name|T
operator|>
name|X2
argument_list|)
block|{
return|return
name|X1
operator|==
name|X2
return|;
block|}
end_decl_stmt

begin_expr_stmt
unit|};
name|template
operator|<
name|typename
name|T
operator|>
expr|struct
name|isPodLike
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|T
operator|>
expr|struct
name|isPodLike
operator|<
name|ImmutableList
operator|<
name|T
operator|>>
block|{
specifier|static
specifier|const
name|bool
name|value
operator|=
name|true
block|; }
expr_stmt|;
end_expr_stmt

begin_comment
unit|}
comment|// end namespace llvm
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|// LLVM_ADT_IMMUTABLELIST_H
end_comment

end_unit

