begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===- llvm/ADT/DenseMap.h - Dense probed hash table ------------*- C++ -*-===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file defines the DenseMap class.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LLVM_ADT_DENSEMAP_H
end_ifndef

begin_define
define|#
directive|define
name|LLVM_ADT_DENSEMAP_H
end_define

begin_include
include|#
directive|include
file|"llvm/Support/MathExtras.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/PointerLikeTypeTraits.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/type_traits.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/DenseMapInfo.h"
end_include

begin_include
include|#
directive|include
file|<iterator>
end_include

begin_include
include|#
directive|include
file|<new>
end_include

begin_include
include|#
directive|include
file|<utility>
end_include

begin_include
include|#
directive|include
file|<cassert>
end_include

begin_include
include|#
directive|include
file|<cstring>
end_include

begin_decl_stmt
name|namespace
name|llvm
block|{
name|template
operator|<
name|typename
name|KeyT
operator|,
name|typename
name|ValueT
operator|,
name|typename
name|KeyInfoT
operator|=
name|DenseMapInfo
operator|<
name|KeyT
operator|>
operator|,
name|typename
name|ValueInfoT
operator|=
name|DenseMapInfo
operator|<
name|ValueT
operator|>
operator|,
name|bool
name|IsConst
operator|=
name|false
operator|>
name|class
name|DenseMapIterator
expr_stmt|;
name|template
operator|<
name|typename
name|KeyT
operator|,
name|typename
name|ValueT
operator|,
name|typename
name|KeyInfoT
operator|=
name|DenseMapInfo
operator|<
name|KeyT
operator|>
operator|,
name|typename
name|ValueInfoT
operator|=
name|DenseMapInfo
operator|<
name|ValueT
operator|>
expr|>
name|class
name|DenseMap
block|{
typedef|typedef
name|std
operator|::
name|pair
operator|<
name|KeyT
operator|,
name|ValueT
operator|>
name|BucketT
expr_stmt|;
name|unsigned
name|NumBuckets
expr_stmt|;
name|BucketT
modifier|*
name|Buckets
decl_stmt|;
name|unsigned
name|NumEntries
decl_stmt|;
name|unsigned
name|NumTombstones
decl_stmt|;
name|public
label|:
typedef|typedef
name|KeyT
name|key_type
typedef|;
typedef|typedef
name|ValueT
name|mapped_type
typedef|;
typedef|typedef
name|BucketT
name|value_type
typedef|;
name|DenseMap
argument_list|(
argument|const DenseMap& other
argument_list|)
block|{
name|NumBuckets
operator|=
literal|0
expr_stmt|;
name|CopyFrom
argument_list|(
name|other
argument_list|)
expr_stmt|;
block|}
name|explicit
name|DenseMap
parameter_list|(
name|unsigned
name|NumInitBuckets
init|=
literal|64
parameter_list|)
block|{
name|init
argument_list|(
name|NumInitBuckets
argument_list|)
expr_stmt|;
block|}
operator|~
name|DenseMap
argument_list|()
block|{
specifier|const
name|KeyT
name|EmptyKey
operator|=
name|getEmptyKey
argument_list|()
block|,
name|TombstoneKey
operator|=
name|getTombstoneKey
argument_list|()
block|;
for|for
control|(
name|BucketT
modifier|*
name|P
init|=
name|Buckets
init|,
modifier|*
name|E
init|=
name|Buckets
operator|+
name|NumBuckets
init|;
name|P
operator|!=
name|E
condition|;
operator|++
name|P
control|)
block|{
if|if
condition|(
operator|!
name|KeyInfoT
operator|::
name|isEqual
argument_list|(
name|P
operator|->
name|first
argument_list|,
name|EmptyKey
argument_list|)
operator|&&
operator|!
name|KeyInfoT
operator|::
name|isEqual
argument_list|(
name|P
operator|->
name|first
argument_list|,
name|TombstoneKey
argument_list|)
condition|)
name|P
operator|->
name|second
operator|.
expr|~
name|ValueT
argument_list|()
expr_stmt|;
name|P
operator|->
name|first
operator|.
expr|~
name|KeyT
argument_list|()
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|NDEBUG
name|memset
argument_list|(
name|Buckets
argument_list|,
literal|0x5a
argument_list|,
sizeof|sizeof
argument_list|(
name|BucketT
argument_list|)
operator|*
name|NumBuckets
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|operator
name|delete
argument_list|(
name|Buckets
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_typedef
typedef|typedef
name|DenseMapIterator
operator|<
name|KeyT
operator|,
name|ValueT
operator|,
name|KeyInfoT
operator|>
name|iterator
expr_stmt|;
end_typedef

begin_typedef
typedef|typedef
name|DenseMapIterator
operator|<
name|KeyT
operator|,
name|ValueT
operator|,
name|KeyInfoT
operator|,
name|ValueInfoT
operator|,
name|true
operator|>
name|const_iterator
expr_stmt|;
end_typedef

begin_function
specifier|inline
name|iterator
name|begin
parameter_list|()
block|{
return|return
name|iterator
argument_list|(
name|Buckets
argument_list|,
name|Buckets
operator|+
name|NumBuckets
argument_list|)
return|;
block|}
end_function

begin_function
specifier|inline
name|iterator
name|end
parameter_list|()
block|{
return|return
name|iterator
argument_list|(
name|Buckets
operator|+
name|NumBuckets
argument_list|,
name|Buckets
operator|+
name|NumBuckets
argument_list|)
return|;
block|}
end_function

begin_expr_stmt
specifier|inline
name|const_iterator
name|begin
argument_list|()
specifier|const
block|{
return|return
name|const_iterator
argument_list|(
name|Buckets
argument_list|,
name|Buckets
operator|+
name|NumBuckets
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
specifier|inline
name|const_iterator
name|end
argument_list|()
specifier|const
block|{
return|return
name|const_iterator
argument_list|(
name|Buckets
operator|+
name|NumBuckets
argument_list|,
name|Buckets
operator|+
name|NumBuckets
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|bool
name|empty
argument_list|()
specifier|const
block|{
return|return
name|NumEntries
operator|==
literal|0
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|unsigned
name|size
argument_list|()
specifier|const
block|{
return|return
name|NumEntries
return|;
block|}
end_expr_stmt

begin_comment
comment|/// Grow the densemap so that it has at least Size buckets. Does not shrink
end_comment

begin_function
name|void
name|resize
parameter_list|(
name|size_t
name|Size
parameter_list|)
block|{
name|grow
argument_list|(
name|Size
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|clear
parameter_list|()
block|{
if|if
condition|(
name|NumEntries
operator|==
literal|0
operator|&&
name|NumTombstones
operator|==
literal|0
condition|)
return|return;
comment|// If the capacity of the array is huge, and the # elements used is small,
comment|// shrink the array.
if|if
condition|(
name|NumEntries
operator|*
literal|4
operator|<
name|NumBuckets
operator|&&
name|NumBuckets
operator|>
literal|64
condition|)
block|{
name|shrink_and_clear
argument_list|()
expr_stmt|;
return|return;
block|}
specifier|const
name|KeyT
name|EmptyKey
init|=
name|getEmptyKey
argument_list|()
decl_stmt|,
name|TombstoneKey
init|=
name|getTombstoneKey
argument_list|()
decl_stmt|;
for|for
control|(
name|BucketT
modifier|*
name|P
init|=
name|Buckets
init|,
modifier|*
name|E
init|=
name|Buckets
operator|+
name|NumBuckets
init|;
name|P
operator|!=
name|E
condition|;
operator|++
name|P
control|)
block|{
if|if
condition|(
operator|!
name|KeyInfoT
operator|::
name|isEqual
argument_list|(
name|P
operator|->
name|first
argument_list|,
name|EmptyKey
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|KeyInfoT
operator|::
name|isEqual
argument_list|(
name|P
operator|->
name|first
argument_list|,
name|TombstoneKey
argument_list|)
condition|)
block|{
name|P
operator|->
name|second
operator|.
expr|~
name|ValueT
argument_list|()
expr_stmt|;
operator|--
name|NumEntries
expr_stmt|;
block|}
name|P
operator|->
name|first
operator|=
name|EmptyKey
expr_stmt|;
block|}
block|}
name|assert
argument_list|(
name|NumEntries
operator|==
literal|0
operator|&&
literal|"Node count imbalance!"
argument_list|)
expr_stmt|;
name|NumTombstones
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/// count - Return true if the specified key is in the map.
end_comment

begin_decl_stmt
name|bool
name|count
argument_list|(
specifier|const
name|KeyT
operator|&
name|Val
argument_list|)
decl|const
block|{
name|BucketT
modifier|*
name|TheBucket
decl_stmt|;
return|return
name|LookupBucketFor
argument_list|(
name|Val
argument_list|,
name|TheBucket
argument_list|)
return|;
block|}
end_decl_stmt

begin_function
name|iterator
name|find
parameter_list|(
specifier|const
name|KeyT
modifier|&
name|Val
parameter_list|)
block|{
name|BucketT
modifier|*
name|TheBucket
decl_stmt|;
if|if
condition|(
name|LookupBucketFor
argument_list|(
name|Val
argument_list|,
name|TheBucket
argument_list|)
condition|)
return|return
name|iterator
argument_list|(
name|TheBucket
argument_list|,
name|Buckets
operator|+
name|NumBuckets
argument_list|)
return|;
return|return
name|end
argument_list|()
return|;
block|}
end_function

begin_decl_stmt
name|const_iterator
name|find
argument_list|(
specifier|const
name|KeyT
operator|&
name|Val
argument_list|)
decl|const
block|{
name|BucketT
modifier|*
name|TheBucket
decl_stmt|;
if|if
condition|(
name|LookupBucketFor
argument_list|(
name|Val
argument_list|,
name|TheBucket
argument_list|)
condition|)
return|return
name|const_iterator
argument_list|(
name|TheBucket
argument_list|,
name|Buckets
operator|+
name|NumBuckets
argument_list|)
return|;
return|return
name|end
argument_list|()
return|;
block|}
end_decl_stmt

begin_comment
comment|/// lookup - Return the entry for the specified key, or a default
end_comment

begin_comment
comment|/// constructed value if no such entry exists.
end_comment

begin_decl_stmt
name|ValueT
name|lookup
argument_list|(
specifier|const
name|KeyT
operator|&
name|Val
argument_list|)
decl|const
block|{
name|BucketT
modifier|*
name|TheBucket
decl_stmt|;
if|if
condition|(
name|LookupBucketFor
argument_list|(
name|Val
argument_list|,
name|TheBucket
argument_list|)
condition|)
return|return
name|TheBucket
operator|->
name|second
return|;
return|return
name|ValueT
argument_list|()
return|;
block|}
end_decl_stmt

begin_comment
comment|// Inserts key,value pair into the map if the key isn't already in the map.
end_comment

begin_comment
comment|// If the key is already in the map, it returns false and doesn't update the
end_comment

begin_comment
comment|// value.
end_comment

begin_expr_stmt
name|std
operator|::
name|pair
operator|<
name|iterator
operator|,
name|bool
operator|>
name|insert
argument_list|(
argument|const std::pair<KeyT
argument_list|,
argument|ValueT>&KV
argument_list|)
block|{
name|BucketT
operator|*
name|TheBucket
block|;
if|if
condition|(
name|LookupBucketFor
argument_list|(
name|KV
operator|.
name|first
argument_list|,
name|TheBucket
argument_list|)
condition|)
return|return
name|std
operator|::
name|make_pair
argument_list|(
name|iterator
argument_list|(
name|TheBucket
argument_list|,
name|Buckets
operator|+
name|NumBuckets
argument_list|)
argument_list|,
name|false
argument_list|)
return|;
comment|// Already in map.
comment|// Otherwise, insert the new element.
name|TheBucket
operator|=
name|InsertIntoBucket
argument_list|(
name|KV
operator|.
name|first
argument_list|,
name|KV
operator|.
name|second
argument_list|,
name|TheBucket
argument_list|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|std
operator|::
name|make_pair
argument_list|(
name|iterator
argument_list|(
name|TheBucket
argument_list|,
name|Buckets
operator|+
name|NumBuckets
argument_list|)
argument_list|,
name|true
argument_list|)
return|;
end_return

begin_comment
unit|}
comment|/// insert - Range insertion of pairs.
end_comment

begin_expr_stmt
unit|template
operator|<
name|typename
name|InputIt
operator|>
name|void
name|insert
argument_list|(
argument|InputIt I
argument_list|,
argument|InputIt E
argument_list|)
block|{
for|for
control|(
init|;
name|I
operator|!=
name|E
condition|;
operator|++
name|I
control|)
name|insert
argument_list|(
operator|*
name|I
argument_list|)
expr_stmt|;
block|}
end_expr_stmt

begin_function
name|bool
name|erase
parameter_list|(
specifier|const
name|KeyT
modifier|&
name|Val
parameter_list|)
block|{
name|BucketT
modifier|*
name|TheBucket
decl_stmt|;
if|if
condition|(
operator|!
name|LookupBucketFor
argument_list|(
name|Val
argument_list|,
name|TheBucket
argument_list|)
condition|)
return|return
name|false
return|;
comment|// not in map.
name|TheBucket
operator|->
name|second
operator|.
expr|~
name|ValueT
argument_list|()
expr_stmt|;
name|TheBucket
operator|->
name|first
operator|=
name|getTombstoneKey
argument_list|()
expr_stmt|;
operator|--
name|NumEntries
expr_stmt|;
operator|++
name|NumTombstones
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_function
name|bool
name|erase
parameter_list|(
name|iterator
name|I
parameter_list|)
block|{
name|BucketT
modifier|*
name|TheBucket
init|=
operator|&
operator|*
name|I
decl_stmt|;
name|TheBucket
operator|->
name|second
operator|.
expr|~
name|ValueT
argument_list|()
expr_stmt|;
name|TheBucket
operator|->
name|first
operator|=
name|getTombstoneKey
argument_list|()
expr_stmt|;
operator|--
name|NumEntries
expr_stmt|;
operator|++
name|NumTombstones
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_function
name|value_type
modifier|&
name|FindAndConstruct
parameter_list|(
specifier|const
name|KeyT
modifier|&
name|Key
parameter_list|)
block|{
name|BucketT
modifier|*
name|TheBucket
decl_stmt|;
if|if
condition|(
name|LookupBucketFor
argument_list|(
name|Key
argument_list|,
name|TheBucket
argument_list|)
condition|)
return|return
operator|*
name|TheBucket
return|;
return|return
operator|*
name|InsertIntoBucket
argument_list|(
name|Key
argument_list|,
name|ValueT
argument_list|()
argument_list|,
name|TheBucket
argument_list|)
return|;
block|}
end_function

begin_function
name|ValueT
modifier|&
name|operator
function|[]
parameter_list|(
specifier|const
name|KeyT
modifier|&
name|Key
parameter_list|)
block|{
return|return
name|FindAndConstruct
argument_list|(
name|Key
argument_list|)
operator|.
name|second
return|;
block|}
end_function

begin_decl_stmt
name|DenseMap
modifier|&
name|operator
init|=
operator|(
specifier|const
name|DenseMap
operator|&
name|other
operator|)
block|{
name|CopyFrom
argument_list|(
name|other
argument_list|)
block|;
return|return
operator|*
name|this
return|;
block|}
end_decl_stmt

begin_comment
comment|/// isPointerIntoBucketsArray - Return true if the specified pointer points
end_comment

begin_comment
comment|/// somewhere into the DenseMap's array of buckets (i.e. either to a key or
end_comment

begin_comment
comment|/// value in the DenseMap).
end_comment

begin_decl_stmt
name|bool
name|isPointerIntoBucketsArray
argument_list|(
specifier|const
name|void
operator|*
name|Ptr
argument_list|)
decl|const
block|{
return|return
name|Ptr
operator|>=
name|Buckets
operator|&&
name|Ptr
operator|<
name|Buckets
operator|+
name|NumBuckets
return|;
block|}
end_decl_stmt

begin_comment
comment|/// getPointerIntoBucketsArray() - Return an opaque pointer into the buckets
end_comment

begin_comment
comment|/// array.  In conjunction with the previous method, this can be used to
end_comment

begin_comment
comment|/// determine whether an insertion caused the DenseMap to reallocate.
end_comment

begin_expr_stmt
specifier|const
name|void
operator|*
name|getPointerIntoBucketsArray
argument_list|()
specifier|const
block|{
return|return
name|Buckets
return|;
block|}
end_expr_stmt

begin_label
name|private
label|:
end_label

begin_function
name|void
name|CopyFrom
parameter_list|(
specifier|const
name|DenseMap
modifier|&
name|other
parameter_list|)
block|{
if|if
condition|(
name|NumBuckets
operator|!=
literal|0
operator|&&
operator|(
operator|!
name|KeyInfoT
operator|::
name|isPod
argument_list|()
operator|||
operator|!
name|ValueInfoT
operator|::
name|isPod
argument_list|()
operator|)
condition|)
block|{
specifier|const
name|KeyT
name|EmptyKey
init|=
name|getEmptyKey
argument_list|()
decl_stmt|,
name|TombstoneKey
init|=
name|getTombstoneKey
argument_list|()
decl_stmt|;
for|for
control|(
name|BucketT
modifier|*
name|P
init|=
name|Buckets
init|,
modifier|*
name|E
init|=
name|Buckets
operator|+
name|NumBuckets
init|;
name|P
operator|!=
name|E
condition|;
operator|++
name|P
control|)
block|{
if|if
condition|(
operator|!
name|KeyInfoT
operator|::
name|isEqual
argument_list|(
name|P
operator|->
name|first
argument_list|,
name|EmptyKey
argument_list|)
operator|&&
operator|!
name|KeyInfoT
operator|::
name|isEqual
argument_list|(
name|P
operator|->
name|first
argument_list|,
name|TombstoneKey
argument_list|)
condition|)
name|P
operator|->
name|second
operator|.
expr|~
name|ValueT
argument_list|()
expr_stmt|;
name|P
operator|->
name|first
operator|.
expr|~
name|KeyT
argument_list|()
expr_stmt|;
block|}
block|}
name|NumEntries
operator|=
name|other
operator|.
name|NumEntries
expr_stmt|;
name|NumTombstones
operator|=
name|other
operator|.
name|NumTombstones
expr_stmt|;
if|if
condition|(
name|NumBuckets
condition|)
block|{
ifndef|#
directive|ifndef
name|NDEBUG
name|memset
argument_list|(
name|Buckets
argument_list|,
literal|0x5a
argument_list|,
sizeof|sizeof
argument_list|(
name|BucketT
argument_list|)
operator|*
name|NumBuckets
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|operator
name|delete
argument_list|(
name|Buckets
argument_list|)
decl_stmt|;
block|}
name|Buckets
operator|=
name|static_cast
operator|<
name|BucketT
operator|*
operator|>
operator|(
name|operator
name|new
argument_list|(
sizeof|sizeof
argument_list|(
name|BucketT
argument_list|)
operator|*
name|other
operator|.
name|NumBuckets
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|KeyInfoT
operator|::
name|isPod
argument_list|()
operator|&&
name|ValueInfoT
operator|::
name|isPod
argument_list|()
condition|)
name|memcpy
argument_list|(
name|Buckets
argument_list|,
name|other
operator|.
name|Buckets
argument_list|,
name|other
operator|.
name|NumBuckets
operator|*
sizeof|sizeof
argument_list|(
name|BucketT
argument_list|)
argument_list|)
expr_stmt|;
else|else
for|for
control|(
name|size_t
name|i
init|=
literal|0
init|;
name|i
operator|<
name|other
operator|.
name|NumBuckets
condition|;
operator|++
name|i
control|)
block|{
name|new
argument_list|(
argument|&Buckets[i].first
argument_list|)
name|KeyT
argument_list|(
name|other
operator|.
name|Buckets
index|[
name|i
index|]
operator|.
name|first
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|KeyInfoT
operator|::
name|isEqual
argument_list|(
name|Buckets
index|[
name|i
index|]
operator|.
name|first
argument_list|,
name|getEmptyKey
argument_list|()
argument_list|)
operator|&&
operator|!
name|KeyInfoT
operator|::
name|isEqual
argument_list|(
name|Buckets
index|[
name|i
index|]
operator|.
name|first
argument_list|,
name|getTombstoneKey
argument_list|()
argument_list|)
condition|)
name|new
argument_list|(
argument|&Buckets[i].second
argument_list|)
name|ValueT
argument_list|(
name|other
operator|.
name|Buckets
index|[
name|i
index|]
operator|.
name|second
argument_list|)
expr_stmt|;
block|}
name|NumBuckets
operator|=
name|other
operator|.
name|NumBuckets
expr_stmt|;
block|}
end_function

begin_function
name|BucketT
modifier|*
name|InsertIntoBucket
parameter_list|(
specifier|const
name|KeyT
modifier|&
name|Key
parameter_list|,
specifier|const
name|ValueT
modifier|&
name|Value
parameter_list|,
name|BucketT
modifier|*
name|TheBucket
parameter_list|)
block|{
comment|// If the load of the hash table is more than 3/4, or if fewer than 1/8 of
comment|// the buckets are empty (meaning that many are filled with tombstones),
comment|// grow the table.
comment|//
comment|// The later case is tricky.  For example, if we had one empty bucket with
comment|// tons of tombstones, failing lookups (e.g. for insertion) would have to
comment|// probe almost the entire table until it found the empty bucket.  If the
comment|// table completely filled with tombstones, no lookup would ever succeed,
comment|// causing infinite loops in lookup.
operator|++
name|NumEntries
expr_stmt|;
if|if
condition|(
name|NumEntries
operator|*
literal|4
operator|>=
name|NumBuckets
operator|*
literal|3
operator|||
name|NumBuckets
operator|-
operator|(
name|NumEntries
operator|+
name|NumTombstones
operator|)
operator|<
name|NumBuckets
operator|/
literal|8
condition|)
block|{
name|this
operator|->
name|grow
argument_list|(
name|NumBuckets
operator|*
literal|2
argument_list|)
expr_stmt|;
name|LookupBucketFor
argument_list|(
name|Key
argument_list|,
name|TheBucket
argument_list|)
expr_stmt|;
block|}
comment|// If we are writing over a tombstone, remember this.
if|if
condition|(
operator|!
name|KeyInfoT
operator|::
name|isEqual
argument_list|(
name|TheBucket
operator|->
name|first
argument_list|,
name|getEmptyKey
argument_list|()
argument_list|)
condition|)
operator|--
name|NumTombstones
expr_stmt|;
name|TheBucket
operator|->
name|first
operator|=
name|Key
expr_stmt|;
name|new
argument_list|(
argument|&TheBucket->second
argument_list|)
name|ValueT
argument_list|(
name|Value
argument_list|)
expr_stmt|;
return|return
name|TheBucket
return|;
block|}
end_function

begin_function
specifier|static
name|unsigned
name|getHashValue
parameter_list|(
specifier|const
name|KeyT
modifier|&
name|Val
parameter_list|)
block|{
return|return
name|KeyInfoT
operator|::
name|getHashValue
argument_list|(
name|Val
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|KeyT
name|getEmptyKey
parameter_list|()
block|{
return|return
name|KeyInfoT
operator|::
name|getEmptyKey
argument_list|()
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|KeyT
name|getTombstoneKey
parameter_list|()
block|{
return|return
name|KeyInfoT
operator|::
name|getTombstoneKey
argument_list|()
return|;
block|}
end_function

begin_comment
comment|/// LookupBucketFor - Lookup the appropriate bucket for Val, returning it in
end_comment

begin_comment
comment|/// FoundBucket.  If the bucket contains the key and a value, this returns
end_comment

begin_comment
comment|/// true, otherwise it returns a bucket with an empty marker or tombstone and
end_comment

begin_comment
comment|/// returns false.
end_comment

begin_decl_stmt
name|bool
name|LookupBucketFor
argument_list|(
specifier|const
name|KeyT
operator|&
name|Val
argument_list|,
name|BucketT
operator|*
operator|&
name|FoundBucket
argument_list|)
decl|const
block|{
name|unsigned
name|BucketNo
init|=
name|getHashValue
argument_list|(
name|Val
argument_list|)
decl_stmt|;
name|unsigned
name|ProbeAmt
init|=
literal|1
decl_stmt|;
name|BucketT
modifier|*
name|BucketsPtr
init|=
name|Buckets
decl_stmt|;
comment|// FoundTombstone - Keep track of whether we find a tombstone while probing.
name|BucketT
modifier|*
name|FoundTombstone
init|=
literal|0
decl_stmt|;
specifier|const
name|KeyT
name|EmptyKey
init|=
name|getEmptyKey
argument_list|()
decl_stmt|;
specifier|const
name|KeyT
name|TombstoneKey
init|=
name|getTombstoneKey
argument_list|()
decl_stmt|;
name|assert
argument_list|(
operator|!
name|KeyInfoT
operator|::
name|isEqual
argument_list|(
name|Val
argument_list|,
name|EmptyKey
argument_list|)
operator|&&
operator|!
name|KeyInfoT
operator|::
name|isEqual
argument_list|(
name|Val
argument_list|,
name|TombstoneKey
argument_list|)
operator|&&
literal|"Empty/Tombstone value shouldn't be inserted into map!"
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|BucketT
modifier|*
name|ThisBucket
init|=
name|BucketsPtr
operator|+
operator|(
name|BucketNo
operator|&
operator|(
name|NumBuckets
operator|-
literal|1
operator|)
operator|)
decl_stmt|;
comment|// Found Val's bucket?  If so, return it.
if|if
condition|(
name|KeyInfoT
operator|::
name|isEqual
argument_list|(
name|ThisBucket
operator|->
name|first
argument_list|,
name|Val
argument_list|)
condition|)
block|{
name|FoundBucket
operator|=
name|ThisBucket
expr_stmt|;
return|return
name|true
return|;
block|}
comment|// If we found an empty bucket, the key doesn't exist in the set.
comment|// Insert it and return the default value.
if|if
condition|(
name|KeyInfoT
operator|::
name|isEqual
argument_list|(
name|ThisBucket
operator|->
name|first
argument_list|,
name|EmptyKey
argument_list|)
condition|)
block|{
comment|// If we've already seen a tombstone while probing, fill it in instead
comment|// of the empty bucket we eventually probed to.
if|if
condition|(
name|FoundTombstone
condition|)
name|ThisBucket
operator|=
name|FoundTombstone
expr_stmt|;
name|FoundBucket
operator|=
name|FoundTombstone
condition|?
name|FoundTombstone
else|:
name|ThisBucket
expr_stmt|;
return|return
name|false
return|;
block|}
comment|// If this is a tombstone, remember it.  If Val ends up not in the map, we
comment|// prefer to return it than something that would require more probing.
if|if
condition|(
name|KeyInfoT
operator|::
name|isEqual
argument_list|(
name|ThisBucket
operator|->
name|first
argument_list|,
name|TombstoneKey
argument_list|)
operator|&&
operator|!
name|FoundTombstone
condition|)
name|FoundTombstone
operator|=
name|ThisBucket
expr_stmt|;
comment|// Remember the first tombstone found.
comment|// Otherwise, it's a hash collision or a tombstone, continue quadratic
comment|// probing.
name|BucketNo
operator|+=
name|ProbeAmt
operator|++
expr_stmt|;
block|}
block|}
end_decl_stmt

begin_function
name|void
name|init
parameter_list|(
name|unsigned
name|InitBuckets
parameter_list|)
block|{
name|NumEntries
operator|=
literal|0
expr_stmt|;
name|NumTombstones
operator|=
literal|0
expr_stmt|;
name|NumBuckets
operator|=
name|InitBuckets
expr_stmt|;
name|assert
argument_list|(
name|InitBuckets
operator|&&
operator|(
name|InitBuckets
operator|&
operator|(
name|InitBuckets
operator|-
literal|1
operator|)
operator|)
operator|==
literal|0
operator|&&
literal|"# initial buckets must be a power of two!"
argument_list|)
expr_stmt|;
name|Buckets
operator|=
name|static_cast
operator|<
name|BucketT
operator|*
operator|>
operator|(
name|operator
name|new
argument_list|(
sizeof|sizeof
argument_list|(
name|BucketT
argument_list|)
operator|*
name|InitBuckets
argument_list|)
operator|)
expr_stmt|;
comment|// Initialize all the keys to EmptyKey.
specifier|const
name|KeyT
name|EmptyKey
init|=
name|getEmptyKey
argument_list|()
decl_stmt|;
for|for
control|(
name|unsigned
name|i
init|=
literal|0
init|;
name|i
operator|!=
name|InitBuckets
condition|;
operator|++
name|i
control|)
name|new
argument_list|(
argument|&Buckets[i].first
argument_list|)
name|KeyT
argument_list|(
name|EmptyKey
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|grow
parameter_list|(
name|unsigned
name|AtLeast
parameter_list|)
block|{
name|unsigned
name|OldNumBuckets
init|=
name|NumBuckets
decl_stmt|;
name|BucketT
modifier|*
name|OldBuckets
init|=
name|Buckets
decl_stmt|;
comment|// Double the number of buckets.
while|while
condition|(
name|NumBuckets
operator|<=
name|AtLeast
condition|)
name|NumBuckets
operator|<<=
literal|1
expr_stmt|;
name|NumTombstones
operator|=
literal|0
expr_stmt|;
name|Buckets
operator|=
name|static_cast
operator|<
name|BucketT
operator|*
operator|>
operator|(
name|operator
name|new
argument_list|(
sizeof|sizeof
argument_list|(
name|BucketT
argument_list|)
operator|*
name|NumBuckets
argument_list|)
operator|)
expr_stmt|;
comment|// Initialize all the keys to EmptyKey.
specifier|const
name|KeyT
name|EmptyKey
init|=
name|getEmptyKey
argument_list|()
decl_stmt|;
for|for
control|(
name|unsigned
name|i
init|=
literal|0
init|,
name|e
init|=
name|NumBuckets
init|;
name|i
operator|!=
name|e
condition|;
operator|++
name|i
control|)
name|new
argument_list|(
argument|&Buckets[i].first
argument_list|)
name|KeyT
argument_list|(
name|EmptyKey
argument_list|)
expr_stmt|;
comment|// Insert all the old elements.
specifier|const
name|KeyT
name|TombstoneKey
init|=
name|getTombstoneKey
argument_list|()
decl_stmt|;
for|for
control|(
name|BucketT
modifier|*
name|B
init|=
name|OldBuckets
init|,
modifier|*
name|E
init|=
name|OldBuckets
operator|+
name|OldNumBuckets
init|;
name|B
operator|!=
name|E
condition|;
operator|++
name|B
control|)
block|{
if|if
condition|(
operator|!
name|KeyInfoT
operator|::
name|isEqual
argument_list|(
name|B
operator|->
name|first
argument_list|,
name|EmptyKey
argument_list|)
operator|&&
operator|!
name|KeyInfoT
operator|::
name|isEqual
argument_list|(
name|B
operator|->
name|first
argument_list|,
name|TombstoneKey
argument_list|)
condition|)
block|{
comment|// Insert the key/value into the new table.
name|BucketT
modifier|*
name|DestBucket
decl_stmt|;
name|bool
name|FoundVal
init|=
name|LookupBucketFor
argument_list|(
name|B
operator|->
name|first
argument_list|,
name|DestBucket
argument_list|)
decl_stmt|;
name|FoundVal
operator|=
name|FoundVal
expr_stmt|;
comment|// silence warning.
name|assert
argument_list|(
operator|!
name|FoundVal
operator|&&
literal|"Key already in new map?"
argument_list|)
expr_stmt|;
name|DestBucket
operator|->
name|first
operator|=
name|B
operator|->
name|first
expr_stmt|;
name|new
argument_list|(
argument|&DestBucket->second
argument_list|)
name|ValueT
argument_list|(
name|B
operator|->
name|second
argument_list|)
expr_stmt|;
comment|// Free the value.
name|B
operator|->
name|second
operator|.
expr|~
name|ValueT
argument_list|()
expr_stmt|;
block|}
name|B
operator|->
name|first
operator|.
expr|~
name|KeyT
argument_list|()
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|NDEBUG
name|memset
argument_list|(
name|OldBuckets
argument_list|,
literal|0x5a
argument_list|,
sizeof|sizeof
argument_list|(
name|BucketT
argument_list|)
operator|*
name|OldNumBuckets
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|// Free the old table.
name|operator
name|delete
argument_list|(
name|OldBuckets
argument_list|)
decl_stmt|;
block|}
end_function

begin_function
name|void
name|shrink_and_clear
parameter_list|()
block|{
name|unsigned
name|OldNumBuckets
init|=
name|NumBuckets
decl_stmt|;
name|BucketT
modifier|*
name|OldBuckets
init|=
name|Buckets
decl_stmt|;
comment|// Reduce the number of buckets.
name|NumBuckets
operator|=
name|NumEntries
operator|>
literal|32
condition|?
literal|1
operator|<<
operator|(
name|Log2_32_Ceil
argument_list|(
name|NumEntries
argument_list|)
operator|+
literal|1
operator|)
else|:
literal|64
expr_stmt|;
name|NumTombstones
operator|=
literal|0
expr_stmt|;
name|Buckets
operator|=
name|static_cast
operator|<
name|BucketT
operator|*
operator|>
operator|(
name|operator
name|new
argument_list|(
sizeof|sizeof
argument_list|(
name|BucketT
argument_list|)
operator|*
name|NumBuckets
argument_list|)
operator|)
expr_stmt|;
comment|// Initialize all the keys to EmptyKey.
specifier|const
name|KeyT
name|EmptyKey
init|=
name|getEmptyKey
argument_list|()
decl_stmt|;
for|for
control|(
name|unsigned
name|i
init|=
literal|0
init|,
name|e
init|=
name|NumBuckets
init|;
name|i
operator|!=
name|e
condition|;
operator|++
name|i
control|)
name|new
argument_list|(
argument|&Buckets[i].first
argument_list|)
name|KeyT
argument_list|(
name|EmptyKey
argument_list|)
expr_stmt|;
comment|// Free the old buckets.
specifier|const
name|KeyT
name|TombstoneKey
init|=
name|getTombstoneKey
argument_list|()
decl_stmt|;
for|for
control|(
name|BucketT
modifier|*
name|B
init|=
name|OldBuckets
init|,
modifier|*
name|E
init|=
name|OldBuckets
operator|+
name|OldNumBuckets
init|;
name|B
operator|!=
name|E
condition|;
operator|++
name|B
control|)
block|{
if|if
condition|(
operator|!
name|KeyInfoT
operator|::
name|isEqual
argument_list|(
name|B
operator|->
name|first
argument_list|,
name|EmptyKey
argument_list|)
operator|&&
operator|!
name|KeyInfoT
operator|::
name|isEqual
argument_list|(
name|B
operator|->
name|first
argument_list|,
name|TombstoneKey
argument_list|)
condition|)
block|{
comment|// Free the value.
name|B
operator|->
name|second
operator|.
expr|~
name|ValueT
argument_list|()
expr_stmt|;
block|}
name|B
operator|->
name|first
operator|.
expr|~
name|KeyT
argument_list|()
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|NDEBUG
name|memset
argument_list|(
name|OldBuckets
argument_list|,
literal|0x5a
argument_list|,
sizeof|sizeof
argument_list|(
name|BucketT
argument_list|)
operator|*
name|OldNumBuckets
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|// Free the old table.
name|operator
name|delete
argument_list|(
name|OldBuckets
argument_list|)
decl_stmt|;
name|NumEntries
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_expr_stmt
unit|};
name|template
operator|<
name|typename
name|KeyT
operator|,
name|typename
name|ValueT
operator|,
name|typename
name|KeyInfoT
operator|,
name|typename
name|ValueInfoT
operator|,
name|bool
name|IsConst
operator|>
name|class
name|DenseMapIterator
block|{
typedef|typedef
name|std
operator|::
name|pair
operator|<
name|KeyT
operator|,
name|ValueT
operator|>
name|Bucket
expr_stmt|;
end_expr_stmt

begin_typedef
typedef|typedef
name|DenseMapIterator
operator|<
name|KeyT
operator|,
name|ValueT
operator|,
name|KeyInfoT
operator|,
name|ValueInfoT
operator|,
name|true
operator|>
name|ConstIterator
expr_stmt|;
end_typedef

begin_expr_stmt
name|friend
name|class
name|DenseMapIterator
operator|<
name|KeyT
operator|,
name|ValueT
operator|,
name|KeyInfoT
operator|,
name|ValueInfoT
operator|,
name|true
operator|>
expr_stmt|;
end_expr_stmt

begin_label
name|public
label|:
end_label

begin_typedef
typedef|typedef
name|ptrdiff_t
name|difference_type
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|typename
name|conditional
operator|<
name|IsConst
operator|,
specifier|const
name|Bucket
operator|,
name|Bucket
operator|>
operator|::
name|type
name|value_type
expr_stmt|;
end_typedef

begin_typedef
typedef|typedef
name|value_type
modifier|*
name|pointer
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|value_type
modifier|&
name|reference
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|std
operator|::
name|forward_iterator_tag
name|iterator_category
expr_stmt|;
end_typedef

begin_label
name|private
label|:
end_label

begin_decl_stmt
name|pointer
name|Ptr
decl_stmt|,
name|End
decl_stmt|;
end_decl_stmt

begin_label
name|public
label|:
end_label

begin_expr_stmt
name|DenseMapIterator
argument_list|()
operator|:
name|Ptr
argument_list|(
literal|0
argument_list|)
operator|,
name|End
argument_list|(
literal|0
argument_list|)
block|{}
name|DenseMapIterator
argument_list|(
argument|pointer Pos
argument_list|,
argument|pointer E
argument_list|)
operator|:
name|Ptr
argument_list|(
name|Pos
argument_list|)
operator|,
name|End
argument_list|(
argument|E
argument_list|)
block|{
name|AdvancePastEmptyBuckets
argument_list|()
block|;   }
comment|// If IsConst is true this is a converting constructor from iterator to
comment|// const_iterator and the default copy constructor is used.
comment|// Otherwise this is a copy constructor for iterator.
name|DenseMapIterator
argument_list|(
specifier|const
name|DenseMapIterator
operator|<
name|KeyT
argument_list|,
name|ValueT
argument_list|,
name|KeyInfoT
argument_list|,
name|ValueInfoT
argument_list|,
name|false
operator|>
operator|&
name|I
argument_list|)
operator|:
name|Ptr
argument_list|(
name|I
operator|.
name|Ptr
argument_list|)
operator|,
name|End
argument_list|(
argument|I.End
argument_list|)
block|{}
name|reference
name|operator
operator|*
operator|(
operator|)
specifier|const
block|{
return|return
operator|*
name|Ptr
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|pointer
name|operator
operator|->
expr|(
end_expr_stmt

begin_expr_stmt
unit|)
specifier|const
block|{
return|return
name|Ptr
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|bool
name|operator
operator|==
operator|(
specifier|const
name|ConstIterator
operator|&
name|RHS
operator|)
specifier|const
block|{
return|return
name|Ptr
operator|==
name|RHS
operator|.
name|operator
operator|->
expr|(
block|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
unit|}   bool
name|operator
operator|!=
operator|(
specifier|const
name|ConstIterator
operator|&
name|RHS
operator|)
specifier|const
block|{
return|return
name|Ptr
operator|!=
name|RHS
operator|.
name|operator
operator|->
expr|(
block|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
unit|}    inline
name|DenseMapIterator
operator|&
name|operator
operator|++
operator|(
operator|)
block|{
comment|// Preincrement
operator|++
name|Ptr
block|;
name|AdvancePastEmptyBuckets
argument_list|()
block|;
return|return
operator|*
name|this
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|DenseMapIterator
name|operator
operator|++
operator|(
name|int
operator|)
block|{
comment|// Postincrement
name|DenseMapIterator
name|tmp
operator|=
operator|*
name|this
block|;
operator|++
operator|*
name|this
block|;
return|return
name|tmp
return|;
block|}
end_expr_stmt

begin_label
name|private
label|:
end_label

begin_function
name|void
name|AdvancePastEmptyBuckets
parameter_list|()
block|{
specifier|const
name|KeyT
name|Empty
init|=
name|KeyInfoT
operator|::
name|getEmptyKey
argument_list|()
decl_stmt|;
specifier|const
name|KeyT
name|Tombstone
init|=
name|KeyInfoT
operator|::
name|getTombstoneKey
argument_list|()
decl_stmt|;
while|while
condition|(
name|Ptr
operator|!=
name|End
operator|&&
operator|(
name|KeyInfoT
operator|::
name|isEqual
argument_list|(
name|Ptr
operator|->
name|first
argument_list|,
name|Empty
argument_list|)
operator|||
name|KeyInfoT
operator|::
name|isEqual
argument_list|(
name|Ptr
operator|->
name|first
argument_list|,
name|Tombstone
argument_list|)
operator|)
condition|)
operator|++
name|Ptr
expr_stmt|;
block|}
end_function

begin_comment
unit|};  }
comment|// end namespace llvm
end_comment

begin_endif
endif|#
directive|endif
end_endif

end_unit

