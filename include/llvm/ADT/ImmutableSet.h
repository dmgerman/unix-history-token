begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===--- ImmutableSet.h - Immutable (functional) set interface --*- C++ -*-===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file defines the ImutAVLTree and ImmutableSet classes.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LLVM_ADT_IMMUTABLESET_H
end_ifndef

begin_define
define|#
directive|define
name|LLVM_ADT_IMMUTABLESET_H
end_define

begin_include
include|#
directive|include
file|"llvm/ADT/DenseMap.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/FoldingSet.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/SmallVector.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/iterator.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/Allocator.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/ErrorHandling.h"
end_include

begin_include
include|#
directive|include
file|<cassert>
end_include

begin_include
include|#
directive|include
file|<cstdint>
end_include

begin_include
include|#
directive|include
file|<functional>
end_include

begin_include
include|#
directive|include
file|<iterator>
end_include

begin_include
include|#
directive|include
file|<new>
end_include

begin_include
include|#
directive|include
file|<vector>
end_include

begin_decl_stmt
name|namespace
name|llvm
block|{
comment|//===----------------------------------------------------------------------===//
comment|// Immutable AVL-Tree Definition.
comment|//===----------------------------------------------------------------------===//
name|template
operator|<
name|typename
name|ImutInfo
operator|>
name|class
name|ImutAVLFactory
expr_stmt|;
name|template
operator|<
name|typename
name|ImutInfo
operator|>
name|class
name|ImutIntervalAVLFactory
expr_stmt|;
name|template
operator|<
name|typename
name|ImutInfo
operator|>
name|class
name|ImutAVLTreeInOrderIterator
expr_stmt|;
name|template
operator|<
name|typename
name|ImutInfo
operator|>
name|class
name|ImutAVLTreeGenericIterator
expr_stmt|;
name|template
operator|<
name|typename
name|ImutInfo
operator|>
name|class
name|ImutAVLTree
block|{
name|public
operator|:
typedef|typedef
name|typename
name|ImutInfo
operator|::
name|key_type_ref
name|key_type_ref
expr_stmt|;
typedef|typedef
name|typename
name|ImutInfo
operator|::
name|value_type
name|value_type
expr_stmt|;
typedef|typedef
name|typename
name|ImutInfo
operator|::
name|value_type_ref
name|value_type_ref
expr_stmt|;
typedef|typedef
name|ImutAVLFactory
operator|<
name|ImutInfo
operator|>
name|Factory
expr_stmt|;
name|friend
name|class
name|ImutAVLFactory
operator|<
name|ImutInfo
operator|>
expr_stmt|;
name|friend
name|class
name|ImutIntervalAVLFactory
operator|<
name|ImutInfo
operator|>
expr_stmt|;
name|friend
name|class
name|ImutAVLTreeGenericIterator
operator|<
name|ImutInfo
operator|>
expr_stmt|;
typedef|typedef
name|ImutAVLTreeInOrderIterator
operator|<
name|ImutInfo
operator|>
name|iterator
expr_stmt|;
comment|//===----------------------------------------------------===//
comment|// Public Interface.
comment|//===----------------------------------------------------===//
comment|/// Return a pointer to the left subtree.  This value
comment|///  is NULL if there is no left subtree.
name|ImutAVLTree
operator|*
name|getLeft
argument_list|()
specifier|const
block|{
return|return
name|left
return|;
block|}
comment|/// Return a pointer to the right subtree.  This value is
comment|///  NULL if there is no right subtree.
name|ImutAVLTree
operator|*
name|getRight
argument_list|()
specifier|const
block|{
return|return
name|right
return|;
block|}
comment|/// getHeight - Returns the height of the tree.  A tree with no subtrees
comment|///  has a height of 1.
name|unsigned
name|getHeight
argument_list|()
specifier|const
block|{
return|return
name|height
return|;
block|}
comment|/// getValue - Returns the data value associated with the tree node.
specifier|const
name|value_type
operator|&
name|getValue
argument_list|()
specifier|const
block|{
return|return
name|value
return|;
block|}
comment|/// find - Finds the subtree associated with the specified key value.
comment|///  This method returns NULL if no matching subtree is found.
name|ImutAVLTree
modifier|*
name|find
parameter_list|(
name|key_type_ref
name|K
parameter_list|)
block|{
name|ImutAVLTree
modifier|*
name|T
init|=
name|this
decl_stmt|;
while|while
condition|(
name|T
condition|)
block|{
name|key_type_ref
name|CurrentKey
init|=
name|ImutInfo
operator|::
name|KeyOfValue
argument_list|(
name|T
operator|->
name|getValue
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|ImutInfo
operator|::
name|isEqual
argument_list|(
name|K
argument_list|,
name|CurrentKey
argument_list|)
condition|)
return|return
name|T
return|;
elseif|else
if|if
condition|(
name|ImutInfo
operator|::
name|isLess
argument_list|(
name|K
argument_list|,
name|CurrentKey
argument_list|)
condition|)
name|T
operator|=
name|T
operator|->
name|getLeft
argument_list|()
expr_stmt|;
else|else
name|T
operator|=
name|T
operator|->
name|getRight
argument_list|()
expr_stmt|;
block|}
return|return
name|nullptr
return|;
block|}
comment|/// getMaxElement - Find the subtree associated with the highest ranged
comment|///  key value.
name|ImutAVLTree
modifier|*
name|getMaxElement
parameter_list|()
block|{
name|ImutAVLTree
modifier|*
name|T
init|=
name|this
decl_stmt|;
name|ImutAVLTree
modifier|*
name|Right
init|=
name|T
operator|->
name|getRight
argument_list|()
decl_stmt|;
while|while
condition|(
name|Right
condition|)
block|{
name|T
operator|=
name|Right
expr_stmt|;
name|Right
operator|=
name|T
operator|->
name|getRight
argument_list|()
expr_stmt|;
block|}
return|return
name|T
return|;
block|}
comment|/// size - Returns the number of nodes in the tree, which includes
comment|///  both leaves and non-leaf nodes.
name|unsigned
name|size
argument_list|()
specifier|const
block|{
name|unsigned
name|n
operator|=
literal|1
block|;
if|if
condition|(
specifier|const
name|ImutAVLTree
modifier|*
name|L
init|=
name|getLeft
argument_list|()
condition|)
name|n
operator|+=
name|L
operator|->
name|size
argument_list|()
expr_stmt|;
if|if
condition|(
specifier|const
name|ImutAVLTree
modifier|*
name|R
init|=
name|getRight
argument_list|()
condition|)
name|n
operator|+=
name|R
operator|->
name|size
argument_list|()
expr_stmt|;
return|return
name|n
return|;
block|}
end_decl_stmt

begin_comment
comment|/// begin - Returns an iterator that iterates over the nodes of the tree
end_comment

begin_comment
comment|///  in an inorder traversal.  The returned iterator thus refers to the
end_comment

begin_comment
comment|///  the tree node with the minimum data element.
end_comment

begin_expr_stmt
name|iterator
name|begin
argument_list|()
specifier|const
block|{
return|return
name|iterator
argument_list|(
name|this
argument_list|)
return|;
block|}
end_expr_stmt

begin_comment
comment|/// end - Returns an iterator for the tree that denotes the end of an
end_comment

begin_comment
comment|///  inorder traversal.
end_comment

begin_expr_stmt
name|iterator
name|end
argument_list|()
specifier|const
block|{
return|return
name|iterator
argument_list|()
return|;
block|}
end_expr_stmt

begin_decl_stmt
name|bool
name|isElementEqual
argument_list|(
name|value_type_ref
name|V
argument_list|)
decl|const
block|{
comment|// Compare the keys.
if|if
condition|(
operator|!
name|ImutInfo
operator|::
name|isEqual
argument_list|(
name|ImutInfo
operator|::
name|KeyOfValue
argument_list|(
name|getValue
argument_list|()
argument_list|)
argument_list|,
name|ImutInfo
operator|::
name|KeyOfValue
argument_list|(
name|V
argument_list|)
argument_list|)
condition|)
return|return
name|false
return|;
comment|// Also compare the data values.
if|if
condition|(
operator|!
name|ImutInfo
operator|::
name|isDataEqual
argument_list|(
name|ImutInfo
operator|::
name|DataOfValue
argument_list|(
name|getValue
argument_list|()
argument_list|)
argument_list|,
name|ImutInfo
operator|::
name|DataOfValue
argument_list|(
name|V
argument_list|)
argument_list|)
condition|)
return|return
name|false
return|;
return|return
name|true
return|;
block|}
end_decl_stmt

begin_decl_stmt
name|bool
name|isElementEqual
argument_list|(
specifier|const
name|ImutAVLTree
operator|*
name|RHS
argument_list|)
decl|const
block|{
return|return
name|isElementEqual
argument_list|(
name|RHS
operator|->
name|getValue
argument_list|()
argument_list|)
return|;
block|}
end_decl_stmt

begin_comment
comment|/// isEqual - Compares two trees for structural equality and returns true
end_comment

begin_comment
comment|///   if they are equal.  This worst case performance of this operation is
end_comment

begin_comment
comment|//    linear in the sizes of the trees.
end_comment

begin_decl_stmt
name|bool
name|isEqual
argument_list|(
specifier|const
name|ImutAVLTree
operator|&
name|RHS
argument_list|)
decl|const
block|{
if|if
condition|(
operator|&
name|RHS
operator|==
name|this
condition|)
return|return
name|true
return|;
name|iterator
name|LItr
init|=
name|begin
argument_list|()
decl_stmt|,
name|LEnd
init|=
name|end
argument_list|()
decl_stmt|;
name|iterator
name|RItr
init|=
name|RHS
operator|.
name|begin
argument_list|()
decl_stmt|,
name|REnd
init|=
name|RHS
operator|.
name|end
argument_list|()
decl_stmt|;
while|while
condition|(
name|LItr
operator|!=
name|LEnd
operator|&&
name|RItr
operator|!=
name|REnd
condition|)
block|{
if|if
condition|(
operator|&
operator|*
name|LItr
operator|==
operator|&
operator|*
name|RItr
condition|)
block|{
name|LItr
operator|.
name|skipSubTree
argument_list|()
expr_stmt|;
name|RItr
operator|.
name|skipSubTree
argument_list|()
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|!
name|LItr
operator|->
name|isElementEqual
argument_list|(
operator|&
operator|*
name|RItr
argument_list|)
condition|)
return|return
name|false
return|;
operator|++
name|LItr
expr_stmt|;
operator|++
name|RItr
expr_stmt|;
block|}
return|return
name|LItr
operator|==
name|LEnd
operator|&&
name|RItr
operator|==
name|REnd
return|;
block|}
end_decl_stmt

begin_comment
comment|/// isNotEqual - Compares two trees for structural inequality.  Performance
end_comment

begin_comment
comment|///  is the same is isEqual.
end_comment

begin_decl_stmt
name|bool
name|isNotEqual
argument_list|(
specifier|const
name|ImutAVLTree
operator|&
name|RHS
argument_list|)
decl|const
block|{
return|return
operator|!
name|isEqual
argument_list|(
name|RHS
argument_list|)
return|;
block|}
end_decl_stmt

begin_comment
comment|/// contains - Returns true if this tree contains a subtree (node) that
end_comment

begin_comment
comment|///  has an data element that matches the specified key.  Complexity
end_comment

begin_comment
comment|///  is logarithmic in the size of the tree.
end_comment

begin_function
name|bool
name|contains
parameter_list|(
name|key_type_ref
name|K
parameter_list|)
block|{
return|return
operator|(
name|bool
operator|)
name|find
argument_list|(
name|K
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/// foreach - A member template the accepts invokes operator() on a functor
end_comment

begin_comment
comment|///  object (specifed by Callback) for every node/subtree in the tree.
end_comment

begin_comment
comment|///  Nodes are visited using an inorder traversal.
end_comment

begin_expr_stmt
name|template
operator|<
name|typename
name|Callback
operator|>
name|void
name|foreach
argument_list|(
argument|Callback& C
argument_list|)
block|{
if|if
condition|(
name|ImutAVLTree
modifier|*
name|L
init|=
name|getLeft
argument_list|()
condition|)
name|L
operator|->
name|foreach
argument_list|(
name|C
argument_list|)
expr_stmt|;
name|C
argument_list|(
name|value
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|ImutAVLTree
modifier|*
name|R
init|=
name|getRight
argument_list|()
condition|)
name|R
operator|->
name|foreach
argument_list|(
name|C
argument_list|)
expr_stmt|;
end_if

begin_comment
unit|}
comment|/// validateTree - A utility method that checks that the balancing and
end_comment

begin_comment
comment|///  ordering invariants of the tree are satisifed.  It is a recursive
end_comment

begin_comment
comment|///  method that returns the height of the tree, which is then consumed
end_comment

begin_comment
comment|///  by the enclosing validateTree call.  External callers should ignore the
end_comment

begin_comment
comment|///  return value.  An invalid tree will cause an assertion to fire in
end_comment

begin_comment
comment|///  a debug build.
end_comment

begin_macro
unit|unsigned
name|validateTree
argument_list|()
end_macro

begin_expr_stmt
specifier|const
block|{
name|unsigned
name|HL
operator|=
name|getLeft
argument_list|()
operator|?
name|getLeft
argument_list|()
operator|->
name|validateTree
argument_list|()
operator|:
literal|0
block|;
name|unsigned
name|HR
operator|=
name|getRight
argument_list|()
condition|?
name|getRight
argument_list|()
operator|->
name|validateTree
argument_list|()
else|:
literal|0
block|;
operator|(
name|void
operator|)
name|HL
block|;
operator|(
name|void
operator|)
name|HR
block|;
name|assert
argument_list|(
name|getHeight
argument_list|()
operator|==
operator|(
name|HL
operator|>
name|HR
condition|?
name|HL
else|:
name|HR
operator|)
operator|+
literal|1
operator|&&
literal|"Height calculation wrong"
argument_list|)
block|;
name|assert
argument_list|(
operator|(
name|HL
operator|>
name|HR
condition|?
name|HL
operator|-
name|HR
else|:
name|HR
operator|-
name|HL
operator|)
operator|<=
literal|2
operator|&&
literal|"Balancing invariant violated"
argument_list|)
block|;
name|assert
argument_list|(
operator|(
operator|!
name|getLeft
argument_list|()
operator|||
name|ImutInfo
operator|::
name|isLess
argument_list|(
name|ImutInfo
operator|::
name|KeyOfValue
argument_list|(
name|getLeft
argument_list|()
operator|->
name|getValue
argument_list|()
argument_list|)
argument_list|,
name|ImutInfo
operator|::
name|KeyOfValue
argument_list|(
name|getValue
argument_list|()
argument_list|)
argument_list|)
operator|)
operator|&&
literal|"Value in left child is not less that current value"
argument_list|)
block|;
name|assert
argument_list|(
operator|!
operator|(
name|getRight
argument_list|()
operator|||
name|ImutInfo
operator|::
name|isLess
argument_list|(
name|ImutInfo
operator|::
name|KeyOfValue
argument_list|(
name|getValue
argument_list|()
argument_list|)
argument_list|,
name|ImutInfo
operator|::
name|KeyOfValue
argument_list|(
name|getRight
argument_list|()
operator|->
name|getValue
argument_list|()
argument_list|)
argument_list|)
operator|)
operator|&&
literal|"Current value is not less that value of right child"
argument_list|)
block|;
return|return
name|getHeight
argument_list|()
return|;
block|}
end_expr_stmt

begin_comment
comment|//===----------------------------------------------------===//
end_comment

begin_comment
comment|// Internal values.
end_comment

begin_comment
comment|//===----------------------------------------------------===//
end_comment

begin_label
name|private
label|:
end_label

begin_decl_stmt
name|Factory
modifier|*
name|factory
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|ImutAVLTree
modifier|*
name|left
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|ImutAVLTree
modifier|*
name|right
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|ImutAVLTree
modifier|*
name|prev
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|ImutAVLTree
modifier|*
name|next
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|height
range|:
literal|28
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|IsMutable
range|:
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|IsDigestCached
range|:
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|IsCanonicalized
range|:
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|value_type
name|value
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|uint32_t
name|digest
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|uint32_t
name|refCount
decl_stmt|;
end_decl_stmt

begin_comment
comment|//===----------------------------------------------------===//
end_comment

begin_comment
comment|// Internal methods (node manipulation; used by Factory).
end_comment

begin_comment
comment|//===----------------------------------------------------===//
end_comment

begin_label
name|private
label|:
end_label

begin_comment
comment|/// ImutAVLTree - Internal constructor that is only called by
end_comment

begin_comment
comment|///   ImutAVLFactory.
end_comment

begin_macro
name|ImutAVLTree
argument_list|(
argument|Factory *f
argument_list|,
argument|ImutAVLTree* l
argument_list|,
argument|ImutAVLTree* r
argument_list|,
argument|value_type_ref v
argument_list|,
argument|unsigned height
argument_list|)
end_macro

begin_expr_stmt
unit|:
name|factory
argument_list|(
name|f
argument_list|)
operator|,
name|left
argument_list|(
name|l
argument_list|)
operator|,
name|right
argument_list|(
name|r
argument_list|)
operator|,
name|prev
argument_list|(
name|nullptr
argument_list|)
operator|,
name|next
argument_list|(
name|nullptr
argument_list|)
operator|,
name|height
argument_list|(
name|height
argument_list|)
operator|,
name|IsMutable
argument_list|(
name|true
argument_list|)
operator|,
name|IsDigestCached
argument_list|(
name|false
argument_list|)
operator|,
name|IsCanonicalized
argument_list|(
literal|0
argument_list|)
operator|,
name|value
argument_list|(
name|v
argument_list|)
operator|,
name|digest
argument_list|(
literal|0
argument_list|)
operator|,
name|refCount
argument_list|(
literal|0
argument_list|)
block|{
if|if
condition|(
name|left
condition|)
name|left
operator|->
name|retain
argument_list|()
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|right
condition|)
name|right
operator|->
name|retain
argument_list|()
expr_stmt|;
end_if

begin_comment
unit|}
comment|/// isMutable - Returns true if the left and right subtree references
end_comment

begin_comment
comment|///  (as well as height) can be changed.  If this method returns false,
end_comment

begin_comment
comment|///  the tree is truly immutable.  Trees returned from an ImutAVLFactory
end_comment

begin_comment
comment|///  object should always have this method return true.  Further, if this
end_comment

begin_comment
comment|///  method returns false for an instance of ImutAVLTree, all subtrees
end_comment

begin_comment
comment|///  will also have this method return false.  The converse is not true.
end_comment

begin_macro
unit|bool
name|isMutable
argument_list|()
end_macro

begin_expr_stmt
specifier|const
block|{
return|return
name|IsMutable
return|;
block|}
end_expr_stmt

begin_comment
comment|/// hasCachedDigest - Returns true if the digest for this tree is cached.
end_comment

begin_comment
comment|///  This can only be true if the tree is immutable.
end_comment

begin_expr_stmt
name|bool
name|hasCachedDigest
argument_list|()
specifier|const
block|{
return|return
name|IsDigestCached
return|;
block|}
end_expr_stmt

begin_comment
comment|//===----------------------------------------------------===//
end_comment

begin_comment
comment|// Mutating operations.  A tree root can be manipulated as
end_comment

begin_comment
comment|// long as its reference has not "escaped" from internal
end_comment

begin_comment
comment|// methods of a factory object (see below).  When a tree
end_comment

begin_comment
comment|// pointer is externally viewable by client code, the
end_comment

begin_comment
comment|// internal "mutable bit" is cleared to mark the tree
end_comment

begin_comment
comment|// immutable.  Note that a tree that still has its mutable
end_comment

begin_comment
comment|// bit set may have children (subtrees) that are themselves
end_comment

begin_comment
comment|// immutable.
end_comment

begin_comment
comment|//===----------------------------------------------------===//
end_comment

begin_comment
comment|/// markImmutable - Clears the mutable flag for a tree.  After this happens,
end_comment

begin_comment
comment|///   it is an error to call setLeft(), setRight(), and setHeight().
end_comment

begin_function
name|void
name|markImmutable
parameter_list|()
block|{
name|assert
argument_list|(
name|isMutable
argument_list|()
operator|&&
literal|"Mutable flag already removed."
argument_list|)
expr_stmt|;
name|IsMutable
operator|=
name|false
expr_stmt|;
block|}
end_function

begin_comment
comment|/// markedCachedDigest - Clears the NoCachedDigest flag for a tree.
end_comment

begin_function
name|void
name|markedCachedDigest
parameter_list|()
block|{
name|assert
argument_list|(
operator|!
name|hasCachedDigest
argument_list|()
operator|&&
literal|"NoCachedDigest flag already removed."
argument_list|)
expr_stmt|;
name|IsDigestCached
operator|=
name|true
expr_stmt|;
block|}
end_function

begin_comment
comment|/// setHeight - Changes the height of the tree.  Used internally by
end_comment

begin_comment
comment|///  ImutAVLFactory.
end_comment

begin_function
name|void
name|setHeight
parameter_list|(
name|unsigned
name|h
parameter_list|)
block|{
name|assert
argument_list|(
name|isMutable
argument_list|()
operator|&&
literal|"Only a mutable tree can have its height changed."
argument_list|)
expr_stmt|;
name|height
operator|=
name|h
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|uint32_t
name|computeDigest
parameter_list|(
name|ImutAVLTree
modifier|*
name|L
parameter_list|,
name|ImutAVLTree
modifier|*
name|R
parameter_list|,
name|value_type_ref
name|V
parameter_list|)
block|{
name|uint32_t
name|digest
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|L
condition|)
name|digest
operator|+=
name|L
operator|->
name|computeDigest
argument_list|()
expr_stmt|;
comment|// Compute digest of stored data.
name|FoldingSetNodeID
name|ID
decl_stmt|;
name|ImutInfo
operator|::
name|Profile
argument_list|(
name|ID
argument_list|,
name|V
argument_list|)
expr_stmt|;
name|digest
operator|+=
name|ID
operator|.
name|ComputeHash
argument_list|()
expr_stmt|;
if|if
condition|(
name|R
condition|)
name|digest
operator|+=
name|R
operator|->
name|computeDigest
argument_list|()
expr_stmt|;
return|return
name|digest
return|;
block|}
end_function

begin_function
name|uint32_t
name|computeDigest
parameter_list|()
block|{
comment|// Check the lowest bit to determine if digest has actually been
comment|// pre-computed.
if|if
condition|(
name|hasCachedDigest
argument_list|()
condition|)
return|return
name|digest
return|;
name|uint32_t
name|X
init|=
name|computeDigest
argument_list|(
name|getLeft
argument_list|()
argument_list|,
name|getRight
argument_list|()
argument_list|,
name|getValue
argument_list|()
argument_list|)
decl_stmt|;
name|digest
operator|=
name|X
expr_stmt|;
name|markedCachedDigest
argument_list|()
expr_stmt|;
return|return
name|X
return|;
block|}
end_function

begin_comment
comment|//===----------------------------------------------------===//
end_comment

begin_comment
comment|// Reference count operations.
end_comment

begin_comment
comment|//===----------------------------------------------------===//
end_comment

begin_label
name|public
label|:
end_label

begin_function
name|void
name|retain
parameter_list|()
block|{
operator|++
name|refCount
expr_stmt|;
block|}
end_function

begin_function
name|void
name|release
parameter_list|()
block|{
name|assert
argument_list|(
name|refCount
operator|>
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|--
name|refCount
operator|==
literal|0
condition|)
name|destroy
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|destroy
parameter_list|()
block|{
if|if
condition|(
name|left
condition|)
name|left
operator|->
name|release
argument_list|()
expr_stmt|;
if|if
condition|(
name|right
condition|)
name|right
operator|->
name|release
argument_list|()
expr_stmt|;
if|if
condition|(
name|IsCanonicalized
condition|)
block|{
if|if
condition|(
name|next
condition|)
name|next
operator|->
name|prev
operator|=
name|prev
expr_stmt|;
if|if
condition|(
name|prev
condition|)
name|prev
operator|->
name|next
operator|=
name|next
expr_stmt|;
else|else
name|factory
operator|->
name|Cache
index|[
name|factory
operator|->
name|maskCacheIndex
argument_list|(
name|computeDigest
argument_list|()
argument_list|)
index|]
operator|=
name|next
expr_stmt|;
block|}
comment|// We need to clear the mutability bit in case we are
comment|// destroying the node as part of a sweep in ImutAVLFactory::recoverNodes().
name|IsMutable
operator|=
name|false
expr_stmt|;
name|factory
operator|->
name|freeNodes
operator|.
name|push_back
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
unit|};
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|// Immutable AVL-Tree Factory class.
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_expr_stmt
name|template
operator|<
name|typename
name|ImutInfo
operator|>
name|class
name|ImutAVLFactory
block|{
name|friend
name|class
name|ImutAVLTree
operator|<
name|ImutInfo
operator|>
block|;
typedef|typedef
name|ImutAVLTree
operator|<
name|ImutInfo
operator|>
name|TreeTy
expr_stmt|;
end_expr_stmt

begin_typedef
typedef|typedef
name|typename
name|TreeTy
operator|::
name|value_type_ref
name|value_type_ref
expr_stmt|;
end_typedef

begin_typedef
typedef|typedef
name|typename
name|TreeTy
operator|::
name|key_type_ref
name|key_type_ref
expr_stmt|;
end_typedef

begin_typedef
typedef|typedef
name|DenseMap
operator|<
name|unsigned
operator|,
name|TreeTy
operator|*
operator|>
name|CacheTy
expr_stmt|;
end_typedef

begin_decl_stmt
name|CacheTy
name|Cache
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|uintptr_t
name|Allocator
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|std
operator|::
name|vector
operator|<
name|TreeTy
operator|*
operator|>
name|createdNodes
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|std
operator|::
name|vector
operator|<
name|TreeTy
operator|*
operator|>
name|freeNodes
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|bool
name|ownsAllocator
argument_list|()
specifier|const
block|{
return|return
operator|(
name|Allocator
operator|&
literal|0x1
operator|)
operator|==
literal|0
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|BumpPtrAllocator
operator|&
name|getAllocator
argument_list|()
specifier|const
block|{
return|return
operator|*
name|reinterpret_cast
operator|<
name|BumpPtrAllocator
operator|*
operator|>
operator|(
name|Allocator
operator|&
operator|~
literal|0x1
operator|)
return|;
block|}
end_expr_stmt

begin_comment
comment|//===--------------------------------------------------===//
end_comment

begin_comment
comment|// Public interface.
end_comment

begin_comment
comment|//===--------------------------------------------------===//
end_comment

begin_label
name|public
label|:
end_label

begin_expr_stmt
name|ImutAVLFactory
argument_list|()
operator|:
name|Allocator
argument_list|(
argument|reinterpret_cast<uintptr_t>(new BumpPtrAllocator())
argument_list|)
block|{}
name|ImutAVLFactory
argument_list|(
name|BumpPtrAllocator
operator|&
name|Alloc
argument_list|)
operator|:
name|Allocator
argument_list|(
argument|reinterpret_cast<uintptr_t>(&Alloc) |
literal|0x1
argument_list|)
block|{}
operator|~
name|ImutAVLFactory
argument_list|()
block|{
if|if
condition|(
name|ownsAllocator
argument_list|()
condition|)
name|delete
modifier|&
name|getAllocator
parameter_list|()
function_decl|;
block|}
end_expr_stmt

begin_function
name|TreeTy
modifier|*
name|add
parameter_list|(
name|TreeTy
modifier|*
name|T
parameter_list|,
name|value_type_ref
name|V
parameter_list|)
block|{
name|T
operator|=
name|add_internal
argument_list|(
name|V
argument_list|,
name|T
argument_list|)
expr_stmt|;
name|markImmutable
argument_list|(
name|T
argument_list|)
expr_stmt|;
name|recoverNodes
argument_list|()
expr_stmt|;
return|return
name|T
return|;
block|}
end_function

begin_function
name|TreeTy
modifier|*
name|remove
parameter_list|(
name|TreeTy
modifier|*
name|T
parameter_list|,
name|key_type_ref
name|V
parameter_list|)
block|{
name|T
operator|=
name|remove_internal
argument_list|(
name|V
argument_list|,
name|T
argument_list|)
expr_stmt|;
name|markImmutable
argument_list|(
name|T
argument_list|)
expr_stmt|;
name|recoverNodes
argument_list|()
expr_stmt|;
return|return
name|T
return|;
block|}
end_function

begin_expr_stmt
name|TreeTy
operator|*
name|getEmptyTree
argument_list|()
specifier|const
block|{
return|return
name|nullptr
return|;
block|}
end_expr_stmt

begin_label
name|protected
label|:
end_label

begin_comment
comment|//===--------------------------------------------------===//
end_comment

begin_comment
comment|// A bunch of quick helper functions used for reasoning
end_comment

begin_comment
comment|// about the properties of trees and their children.
end_comment

begin_comment
comment|// These have succinct names so that the balancing code
end_comment

begin_comment
comment|// is as terse (and readable) as possible.
end_comment

begin_comment
comment|//===--------------------------------------------------===//
end_comment

begin_decl_stmt
name|bool
name|isEmpty
argument_list|(
name|TreeTy
operator|*
name|T
argument_list|)
decl|const
block|{
return|return
operator|!
name|T
return|;
block|}
end_decl_stmt

begin_decl_stmt
name|unsigned
name|getHeight
argument_list|(
name|TreeTy
operator|*
name|T
argument_list|)
decl|const
block|{
return|return
name|T
condition|?
name|T
operator|->
name|getHeight
argument_list|()
else|:
literal|0
return|;
block|}
end_decl_stmt

begin_decl_stmt
name|TreeTy
modifier|*
name|getLeft
argument_list|(
name|TreeTy
operator|*
name|T
argument_list|)
decl|const
block|{
return|return
name|T
operator|->
name|getLeft
argument_list|()
return|;
block|}
end_decl_stmt

begin_decl_stmt
name|TreeTy
modifier|*
name|getRight
argument_list|(
name|TreeTy
operator|*
name|T
argument_list|)
decl|const
block|{
return|return
name|T
operator|->
name|getRight
argument_list|()
return|;
block|}
end_decl_stmt

begin_decl_stmt
name|value_type_ref
name|getValue
argument_list|(
name|TreeTy
operator|*
name|T
argument_list|)
decl|const
block|{
return|return
name|T
operator|->
name|value
return|;
block|}
end_decl_stmt

begin_comment
comment|// Make sure the index is not the Tombstone or Entry key of the DenseMap.
end_comment

begin_function
specifier|static
name|unsigned
name|maskCacheIndex
parameter_list|(
name|unsigned
name|I
parameter_list|)
block|{
return|return
operator|(
name|I
operator|&
operator|~
literal|0x02
operator|)
return|;
block|}
end_function

begin_decl_stmt
name|unsigned
name|incrementHeight
argument_list|(
name|TreeTy
operator|*
name|L
argument_list|,
name|TreeTy
operator|*
name|R
argument_list|)
decl|const
block|{
name|unsigned
name|hl
init|=
name|getHeight
argument_list|(
name|L
argument_list|)
decl_stmt|;
name|unsigned
name|hr
init|=
name|getHeight
argument_list|(
name|R
argument_list|)
decl_stmt|;
return|return
operator|(
name|hl
operator|>
name|hr
condition|?
name|hl
else|:
name|hr
operator|)
operator|+
literal|1
return|;
block|}
end_decl_stmt

begin_decl_stmt
specifier|static
name|bool
name|compareTreeWithSection
argument_list|(
name|TreeTy
operator|*
name|T
argument_list|,
name|typename
name|TreeTy
operator|::
name|iterator
operator|&
name|TI
argument_list|,
name|typename
name|TreeTy
operator|::
name|iterator
operator|&
name|TE
argument_list|)
block|{
name|typename
name|TreeTy
operator|::
name|iterator
name|I
operator|=
name|T
operator|->
name|begin
argument_list|()
operator|,
name|E
operator|=
name|T
operator|->
name|end
argument_list|()
expr_stmt|;
for|for
control|(
init|;
name|I
operator|!=
name|E
condition|;
operator|++
name|I
operator|,
operator|++
name|TI
control|)
block|{
if|if
condition|(
name|TI
operator|==
name|TE
operator|||
operator|!
name|I
operator|->
name|isElementEqual
argument_list|(
operator|&
operator|*
name|TI
argument_list|)
condition|)
return|return
name|false
return|;
block|}
return|return
name|true
return|;
block|}
end_decl_stmt

begin_comment
comment|//===--------------------------------------------------===//
end_comment

begin_comment
comment|// "createNode" is used to generate new tree roots that link
end_comment

begin_comment
comment|// to other trees.  The functon may also simply move links
end_comment

begin_comment
comment|// in an existing root if that root is still marked mutable.
end_comment

begin_comment
comment|// This is necessary because otherwise our balancing code
end_comment

begin_comment
comment|// would leak memory as it would create nodes that are
end_comment

begin_comment
comment|// then discarded later before the finished tree is
end_comment

begin_comment
comment|// returned to the caller.
end_comment

begin_comment
comment|//===--------------------------------------------------===//
end_comment

begin_function
name|TreeTy
modifier|*
name|createNode
parameter_list|(
name|TreeTy
modifier|*
name|L
parameter_list|,
name|value_type_ref
name|V
parameter_list|,
name|TreeTy
modifier|*
name|R
parameter_list|)
block|{
name|BumpPtrAllocator
modifier|&
name|A
init|=
name|getAllocator
argument_list|()
decl_stmt|;
name|TreeTy
modifier|*
name|T
decl_stmt|;
if|if
condition|(
operator|!
name|freeNodes
operator|.
name|empty
argument_list|()
condition|)
block|{
name|T
operator|=
name|freeNodes
operator|.
name|back
argument_list|()
expr_stmt|;
name|freeNodes
operator|.
name|pop_back
argument_list|()
expr_stmt|;
name|assert
argument_list|(
name|T
operator|!=
name|L
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|T
operator|!=
name|R
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|T
operator|=
operator|(
name|TreeTy
operator|*
operator|)
name|A
operator|.
name|Allocate
operator|<
name|TreeTy
operator|>
operator|(
operator|)
expr_stmt|;
block|}
name|new
argument_list|(
argument|T
argument_list|)
name|TreeTy
argument_list|(
name|this
argument_list|,
name|L
argument_list|,
name|R
argument_list|,
name|V
argument_list|,
name|incrementHeight
argument_list|(
name|L
argument_list|,
name|R
argument_list|)
argument_list|)
expr_stmt|;
name|createdNodes
operator|.
name|push_back
argument_list|(
name|T
argument_list|)
expr_stmt|;
return|return
name|T
return|;
block|}
end_function

begin_function
name|TreeTy
modifier|*
name|createNode
parameter_list|(
name|TreeTy
modifier|*
name|newLeft
parameter_list|,
name|TreeTy
modifier|*
name|oldTree
parameter_list|,
name|TreeTy
modifier|*
name|newRight
parameter_list|)
block|{
return|return
name|createNode
argument_list|(
name|newLeft
argument_list|,
name|getValue
argument_list|(
name|oldTree
argument_list|)
argument_list|,
name|newRight
argument_list|)
return|;
block|}
end_function

begin_function
name|void
name|recoverNodes
parameter_list|()
block|{
for|for
control|(
name|unsigned
name|i
init|=
literal|0
init|,
name|n
init|=
name|createdNodes
operator|.
name|size
argument_list|()
init|;
name|i
operator|<
name|n
condition|;
operator|++
name|i
control|)
block|{
name|TreeTy
modifier|*
name|N
init|=
name|createdNodes
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|N
operator|->
name|isMutable
argument_list|()
operator|&&
name|N
operator|->
name|refCount
operator|==
literal|0
condition|)
name|N
operator|->
name|destroy
argument_list|()
expr_stmt|;
block|}
name|createdNodes
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/// balanceTree - Used by add_internal and remove_internal to
end_comment

begin_comment
comment|///  balance a newly created tree.
end_comment

begin_function
name|TreeTy
modifier|*
name|balanceTree
parameter_list|(
name|TreeTy
modifier|*
name|L
parameter_list|,
name|value_type_ref
name|V
parameter_list|,
name|TreeTy
modifier|*
name|R
parameter_list|)
block|{
name|unsigned
name|hl
init|=
name|getHeight
argument_list|(
name|L
argument_list|)
decl_stmt|;
name|unsigned
name|hr
init|=
name|getHeight
argument_list|(
name|R
argument_list|)
decl_stmt|;
if|if
condition|(
name|hl
operator|>
name|hr
operator|+
literal|2
condition|)
block|{
name|assert
argument_list|(
operator|!
name|isEmpty
argument_list|(
name|L
argument_list|)
operator|&&
literal|"Left tree cannot be empty to have a height>= 2"
argument_list|)
expr_stmt|;
name|TreeTy
modifier|*
name|LL
init|=
name|getLeft
argument_list|(
name|L
argument_list|)
decl_stmt|;
name|TreeTy
modifier|*
name|LR
init|=
name|getRight
argument_list|(
name|L
argument_list|)
decl_stmt|;
if|if
condition|(
name|getHeight
argument_list|(
name|LL
argument_list|)
operator|>=
name|getHeight
argument_list|(
name|LR
argument_list|)
condition|)
return|return
name|createNode
argument_list|(
name|LL
argument_list|,
name|L
argument_list|,
name|createNode
argument_list|(
name|LR
argument_list|,
name|V
argument_list|,
name|R
argument_list|)
argument_list|)
return|;
name|assert
argument_list|(
operator|!
name|isEmpty
argument_list|(
name|LR
argument_list|)
operator|&&
literal|"LR cannot be empty because it has a height>= 1"
argument_list|)
expr_stmt|;
name|TreeTy
modifier|*
name|LRL
init|=
name|getLeft
argument_list|(
name|LR
argument_list|)
decl_stmt|;
name|TreeTy
modifier|*
name|LRR
init|=
name|getRight
argument_list|(
name|LR
argument_list|)
decl_stmt|;
return|return
name|createNode
argument_list|(
name|createNode
argument_list|(
name|LL
argument_list|,
name|L
argument_list|,
name|LRL
argument_list|)
argument_list|,
name|LR
argument_list|,
name|createNode
argument_list|(
name|LRR
argument_list|,
name|V
argument_list|,
name|R
argument_list|)
argument_list|)
return|;
block|}
if|if
condition|(
name|hr
operator|>
name|hl
operator|+
literal|2
condition|)
block|{
name|assert
argument_list|(
operator|!
name|isEmpty
argument_list|(
name|R
argument_list|)
operator|&&
literal|"Right tree cannot be empty to have a height>= 2"
argument_list|)
expr_stmt|;
name|TreeTy
modifier|*
name|RL
init|=
name|getLeft
argument_list|(
name|R
argument_list|)
decl_stmt|;
name|TreeTy
modifier|*
name|RR
init|=
name|getRight
argument_list|(
name|R
argument_list|)
decl_stmt|;
if|if
condition|(
name|getHeight
argument_list|(
name|RR
argument_list|)
operator|>=
name|getHeight
argument_list|(
name|RL
argument_list|)
condition|)
return|return
name|createNode
argument_list|(
name|createNode
argument_list|(
name|L
argument_list|,
name|V
argument_list|,
name|RL
argument_list|)
argument_list|,
name|R
argument_list|,
name|RR
argument_list|)
return|;
name|assert
argument_list|(
operator|!
name|isEmpty
argument_list|(
name|RL
argument_list|)
operator|&&
literal|"RL cannot be empty because it has a height>= 1"
argument_list|)
expr_stmt|;
name|TreeTy
modifier|*
name|RLL
init|=
name|getLeft
argument_list|(
name|RL
argument_list|)
decl_stmt|;
name|TreeTy
modifier|*
name|RLR
init|=
name|getRight
argument_list|(
name|RL
argument_list|)
decl_stmt|;
return|return
name|createNode
argument_list|(
name|createNode
argument_list|(
name|L
argument_list|,
name|V
argument_list|,
name|RLL
argument_list|)
argument_list|,
name|RL
argument_list|,
name|createNode
argument_list|(
name|RLR
argument_list|,
name|R
argument_list|,
name|RR
argument_list|)
argument_list|)
return|;
block|}
return|return
name|createNode
argument_list|(
name|L
argument_list|,
name|V
argument_list|,
name|R
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/// add_internal - Creates a new tree that includes the specified
end_comment

begin_comment
comment|///  data and the data from the original tree.  If the original tree
end_comment

begin_comment
comment|///  already contained the data item, the original tree is returned.
end_comment

begin_function
name|TreeTy
modifier|*
name|add_internal
parameter_list|(
name|value_type_ref
name|V
parameter_list|,
name|TreeTy
modifier|*
name|T
parameter_list|)
block|{
if|if
condition|(
name|isEmpty
argument_list|(
name|T
argument_list|)
condition|)
return|return
name|createNode
argument_list|(
name|T
argument_list|,
name|V
argument_list|,
name|T
argument_list|)
return|;
name|assert
argument_list|(
operator|!
name|T
operator|->
name|isMutable
argument_list|()
argument_list|)
expr_stmt|;
name|key_type_ref
name|K
init|=
name|ImutInfo
operator|::
name|KeyOfValue
argument_list|(
name|V
argument_list|)
decl_stmt|;
name|key_type_ref
name|KCurrent
init|=
name|ImutInfo
operator|::
name|KeyOfValue
argument_list|(
name|getValue
argument_list|(
name|T
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|ImutInfo
operator|::
name|isEqual
argument_list|(
name|K
argument_list|,
name|KCurrent
argument_list|)
condition|)
return|return
name|createNode
argument_list|(
name|getLeft
argument_list|(
name|T
argument_list|)
argument_list|,
name|V
argument_list|,
name|getRight
argument_list|(
name|T
argument_list|)
argument_list|)
return|;
elseif|else
if|if
condition|(
name|ImutInfo
operator|::
name|isLess
argument_list|(
name|K
argument_list|,
name|KCurrent
argument_list|)
condition|)
return|return
name|balanceTree
argument_list|(
name|add_internal
argument_list|(
name|V
argument_list|,
name|getLeft
argument_list|(
name|T
argument_list|)
argument_list|)
argument_list|,
name|getValue
argument_list|(
name|T
argument_list|)
argument_list|,
name|getRight
argument_list|(
name|T
argument_list|)
argument_list|)
return|;
else|else
return|return
name|balanceTree
argument_list|(
name|getLeft
argument_list|(
name|T
argument_list|)
argument_list|,
name|getValue
argument_list|(
name|T
argument_list|)
argument_list|,
name|add_internal
argument_list|(
name|V
argument_list|,
name|getRight
argument_list|(
name|T
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/// remove_internal - Creates a new tree that includes all the data
end_comment

begin_comment
comment|///  from the original tree except the specified data.  If the
end_comment

begin_comment
comment|///  specified data did not exist in the original tree, the original
end_comment

begin_comment
comment|///  tree is returned.
end_comment

begin_function
name|TreeTy
modifier|*
name|remove_internal
parameter_list|(
name|key_type_ref
name|K
parameter_list|,
name|TreeTy
modifier|*
name|T
parameter_list|)
block|{
if|if
condition|(
name|isEmpty
argument_list|(
name|T
argument_list|)
condition|)
return|return
name|T
return|;
name|assert
argument_list|(
operator|!
name|T
operator|->
name|isMutable
argument_list|()
argument_list|)
expr_stmt|;
name|key_type_ref
name|KCurrent
init|=
name|ImutInfo
operator|::
name|KeyOfValue
argument_list|(
name|getValue
argument_list|(
name|T
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|ImutInfo
operator|::
name|isEqual
argument_list|(
name|K
argument_list|,
name|KCurrent
argument_list|)
condition|)
block|{
return|return
name|combineTrees
argument_list|(
name|getLeft
argument_list|(
name|T
argument_list|)
argument_list|,
name|getRight
argument_list|(
name|T
argument_list|)
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|ImutInfo
operator|::
name|isLess
argument_list|(
name|K
argument_list|,
name|KCurrent
argument_list|)
condition|)
block|{
return|return
name|balanceTree
argument_list|(
name|remove_internal
argument_list|(
name|K
argument_list|,
name|getLeft
argument_list|(
name|T
argument_list|)
argument_list|)
argument_list|,
name|getValue
argument_list|(
name|T
argument_list|)
argument_list|,
name|getRight
argument_list|(
name|T
argument_list|)
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|balanceTree
argument_list|(
name|getLeft
argument_list|(
name|T
argument_list|)
argument_list|,
name|getValue
argument_list|(
name|T
argument_list|)
argument_list|,
name|remove_internal
argument_list|(
name|K
argument_list|,
name|getRight
argument_list|(
name|T
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
block|}
end_function

begin_function
name|TreeTy
modifier|*
name|combineTrees
parameter_list|(
name|TreeTy
modifier|*
name|L
parameter_list|,
name|TreeTy
modifier|*
name|R
parameter_list|)
block|{
if|if
condition|(
name|isEmpty
argument_list|(
name|L
argument_list|)
condition|)
return|return
name|R
return|;
if|if
condition|(
name|isEmpty
argument_list|(
name|R
argument_list|)
condition|)
return|return
name|L
return|;
name|TreeTy
modifier|*
name|OldNode
decl_stmt|;
name|TreeTy
modifier|*
name|newRight
init|=
name|removeMinBinding
argument_list|(
name|R
argument_list|,
name|OldNode
argument_list|)
decl_stmt|;
return|return
name|balanceTree
argument_list|(
name|L
argument_list|,
name|getValue
argument_list|(
name|OldNode
argument_list|)
argument_list|,
name|newRight
argument_list|)
return|;
block|}
end_function

begin_function
name|TreeTy
modifier|*
name|removeMinBinding
parameter_list|(
name|TreeTy
modifier|*
name|T
parameter_list|,
name|TreeTy
modifier|*
modifier|&
name|Noderemoved
parameter_list|)
block|{
name|assert
argument_list|(
operator|!
name|isEmpty
argument_list|(
name|T
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|isEmpty
argument_list|(
name|getLeft
argument_list|(
name|T
argument_list|)
argument_list|)
condition|)
block|{
name|Noderemoved
operator|=
name|T
expr_stmt|;
return|return
name|getRight
argument_list|(
name|T
argument_list|)
return|;
block|}
return|return
name|balanceTree
argument_list|(
name|removeMinBinding
argument_list|(
name|getLeft
argument_list|(
name|T
argument_list|)
argument_list|,
name|Noderemoved
argument_list|)
argument_list|,
name|getValue
argument_list|(
name|T
argument_list|)
argument_list|,
name|getRight
argument_list|(
name|T
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/// markImmutable - Clears the mutable bits of a root and all of its
end_comment

begin_comment
comment|///  descendants.
end_comment

begin_function
name|void
name|markImmutable
parameter_list|(
name|TreeTy
modifier|*
name|T
parameter_list|)
block|{
if|if
condition|(
operator|!
name|T
operator|||
operator|!
name|T
operator|->
name|isMutable
argument_list|()
condition|)
return|return;
name|T
operator|->
name|markImmutable
argument_list|()
expr_stmt|;
name|markImmutable
argument_list|(
name|getLeft
argument_list|(
name|T
argument_list|)
argument_list|)
expr_stmt|;
name|markImmutable
argument_list|(
name|getRight
argument_list|(
name|T
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_label
name|public
label|:
end_label

begin_function
name|TreeTy
modifier|*
name|getCanonicalTree
parameter_list|(
name|TreeTy
modifier|*
name|TNew
parameter_list|)
block|{
if|if
condition|(
operator|!
name|TNew
condition|)
return|return
name|nullptr
return|;
if|if
condition|(
name|TNew
operator|->
name|IsCanonicalized
condition|)
return|return
name|TNew
return|;
comment|// Search the hashtable for another tree with the same digest, and
comment|// if find a collision compare those trees by their contents.
name|unsigned
name|digest
init|=
name|TNew
operator|->
name|computeDigest
argument_list|()
decl_stmt|;
name|TreeTy
modifier|*
modifier|&
name|entry
init|=
name|Cache
index|[
name|maskCacheIndex
argument_list|(
name|digest
argument_list|)
index|]
decl_stmt|;
do|do
block|{
if|if
condition|(
operator|!
name|entry
condition|)
break|break;
for|for
control|(
name|TreeTy
modifier|*
name|T
init|=
name|entry
init|;
name|T
operator|!=
name|nullptr
condition|;
name|T
operator|=
name|T
operator|->
name|next
control|)
block|{
comment|// Compare the Contents('T') with Contents('TNew')
name|typename
name|TreeTy
operator|::
name|iterator
name|TI
operator|=
name|T
operator|->
name|begin
argument_list|()
operator|,
name|TE
operator|=
name|T
operator|->
name|end
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|compareTreeWithSection
argument_list|(
name|TNew
argument_list|,
name|TI
argument_list|,
name|TE
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|TI
operator|!=
name|TE
condition|)
continue|continue;
comment|// T has more contents than TNew.
comment|// Trees did match!  Return 'T'.
if|if
condition|(
name|TNew
operator|->
name|refCount
operator|==
literal|0
condition|)
name|TNew
operator|->
name|destroy
argument_list|()
expr_stmt|;
return|return
name|T
return|;
block|}
name|entry
operator|->
name|prev
operator|=
name|TNew
expr_stmt|;
name|TNew
operator|->
name|next
operator|=
name|entry
expr_stmt|;
block|}
do|while
condition|(
name|false
condition|)
do|;
name|entry
operator|=
name|TNew
expr_stmt|;
name|TNew
operator|->
name|IsCanonicalized
operator|=
name|true
expr_stmt|;
return|return
name|TNew
return|;
block|}
end_function

begin_comment
unit|};
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|// Immutable AVL-Tree Iterators.
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_expr_stmt
name|template
operator|<
name|typename
name|ImutInfo
operator|>
name|class
name|ImutAVLTreeGenericIterator
operator|:
name|public
name|std
operator|::
name|iterator
operator|<
name|std
operator|::
name|bidirectional_iterator_tag
operator|,
name|ImutAVLTree
operator|<
name|ImutInfo
operator|>>
block|{
name|SmallVector
operator|<
name|uintptr_t
block|,
literal|20
operator|>
name|stack
block|;
name|public
operator|:
expr|enum
name|VisitFlag
block|{
name|VisitedNone
operator|=
literal|0x0
block|,
name|VisitedLeft
operator|=
literal|0x1
block|,
name|VisitedRight
operator|=
literal|0x3
block|,
name|Flags
operator|=
literal|0x3
block|}
block|;
typedef|typedef
name|ImutAVLTree
operator|<
name|ImutInfo
operator|>
name|TreeTy
expr_stmt|;
name|ImutAVLTreeGenericIterator
argument_list|()
operator|=
block|default
expr_stmt|;
end_expr_stmt

begin_macro
name|ImutAVLTreeGenericIterator
argument_list|(
argument|const TreeTy *Root
argument_list|)
end_macro

begin_block
block|{
if|if
condition|(
name|Root
condition|)
name|stack
operator|.
name|push_back
argument_list|(
name|reinterpret_cast
operator|<
name|uintptr_t
operator|>
operator|(
name|Root
operator|)
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|TreeTy
operator|&
name|operator
operator|*
operator|(
operator|)
specifier|const
block|{
name|assert
argument_list|(
operator|!
name|stack
operator|.
name|empty
argument_list|()
argument_list|)
block|;
return|return
operator|*
name|reinterpret_cast
operator|<
name|TreeTy
operator|*
operator|>
operator|(
name|stack
operator|.
name|back
argument_list|()
operator|&
operator|~
name|Flags
operator|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|TreeTy
operator|*
name|operator
operator|->
expr|(
end_expr_stmt

begin_expr_stmt
unit|)
specifier|const
block|{
return|return
operator|&
operator|*
name|this
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|uintptr_t
name|getVisitState
argument_list|()
specifier|const
block|{
name|assert
argument_list|(
operator|!
name|stack
operator|.
name|empty
argument_list|()
argument_list|)
block|;
return|return
name|stack
operator|.
name|back
argument_list|()
operator|&
name|Flags
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|bool
name|atEnd
argument_list|()
specifier|const
block|{
return|return
name|stack
operator|.
name|empty
argument_list|()
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|bool
name|atBeginning
argument_list|()
specifier|const
block|{
return|return
name|stack
operator|.
name|size
argument_list|()
operator|==
literal|1
operator|&&
name|getVisitState
argument_list|()
operator|==
name|VisitedNone
return|;
block|}
end_expr_stmt

begin_function
name|void
name|skipToParent
parameter_list|()
block|{
name|assert
argument_list|(
operator|!
name|stack
operator|.
name|empty
argument_list|()
argument_list|)
expr_stmt|;
name|stack
operator|.
name|pop_back
argument_list|()
expr_stmt|;
if|if
condition|(
name|stack
operator|.
name|empty
argument_list|()
condition|)
return|return;
switch|switch
condition|(
name|getVisitState
argument_list|()
condition|)
block|{
case|case
name|VisitedNone
case|:
name|stack
operator|.
name|back
argument_list|()
operator||=
name|VisitedLeft
expr_stmt|;
break|break;
case|case
name|VisitedLeft
case|:
name|stack
operator|.
name|back
argument_list|()
operator||=
name|VisitedRight
expr_stmt|;
break|break;
default|default:
name|llvm_unreachable
argument_list|(
literal|"Unreachable."
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_expr_stmt
name|bool
name|operator
operator|==
operator|(
specifier|const
name|ImutAVLTreeGenericIterator
operator|&
name|x
operator|)
specifier|const
block|{
return|return
name|stack
operator|==
name|x
operator|.
name|stack
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|bool
name|operator
operator|!=
operator|(
specifier|const
name|ImutAVLTreeGenericIterator
operator|&
name|x
operator|)
specifier|const
block|{
return|return
operator|!
operator|(
operator|*
name|this
operator|==
name|x
operator|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|ImutAVLTreeGenericIterator
operator|&
name|operator
operator|++
operator|(
operator|)
block|{
name|assert
argument_list|(
operator|!
name|stack
operator|.
name|empty
argument_list|()
argument_list|)
block|;
name|TreeTy
operator|*
name|Current
operator|=
name|reinterpret_cast
operator|<
name|TreeTy
operator|*
operator|>
operator|(
name|stack
operator|.
name|back
argument_list|()
operator|&
operator|~
name|Flags
operator|)
block|;
name|assert
argument_list|(
name|Current
argument_list|)
block|;
switch|switch
condition|(
name|getVisitState
argument_list|()
condition|)
block|{
case|case
name|VisitedNone
case|:
if|if
condition|(
name|TreeTy
modifier|*
name|L
init|=
name|Current
operator|->
name|getLeft
argument_list|()
condition|)
name|stack
operator|.
name|push_back
argument_list|(
name|reinterpret_cast
operator|<
name|uintptr_t
operator|>
operator|(
name|L
operator|)
argument_list|)
expr_stmt|;
else|else
name|stack
operator|.
name|back
argument_list|()
operator||=
name|VisitedLeft
expr_stmt|;
break|break;
case|case
name|VisitedLeft
case|:
if|if
condition|(
name|TreeTy
modifier|*
name|R
init|=
name|Current
operator|->
name|getRight
argument_list|()
condition|)
name|stack
operator|.
name|push_back
argument_list|(
name|reinterpret_cast
operator|<
name|uintptr_t
operator|>
operator|(
name|R
operator|)
argument_list|)
expr_stmt|;
else|else
name|stack
operator|.
name|back
argument_list|()
operator||=
name|VisitedRight
expr_stmt|;
break|break;
case|case
name|VisitedRight
case|:
name|skipToParent
argument_list|()
expr_stmt|;
break|break;
default|default:
name|llvm_unreachable
argument_list|(
literal|"Unreachable."
argument_list|)
expr_stmt|;
block|}
end_expr_stmt

begin_return
return|return
operator|*
name|this
return|;
end_return

begin_expr_stmt
unit|}    ImutAVLTreeGenericIterator
operator|&
name|operator
operator|--
operator|(
operator|)
block|{
name|assert
argument_list|(
operator|!
name|stack
operator|.
name|empty
argument_list|()
argument_list|)
block|;
name|TreeTy
operator|*
name|Current
operator|=
name|reinterpret_cast
operator|<
name|TreeTy
operator|*
operator|>
operator|(
name|stack
operator|.
name|back
argument_list|()
operator|&
operator|~
name|Flags
operator|)
block|;
name|assert
argument_list|(
name|Current
argument_list|)
block|;
switch|switch
condition|(
name|getVisitState
argument_list|()
condition|)
block|{
case|case
name|VisitedNone
case|:
name|stack
operator|.
name|pop_back
argument_list|()
expr_stmt|;
break|break;
case|case
name|VisitedLeft
case|:
name|stack
operator|.
name|back
argument_list|()
operator|&=
operator|~
name|Flags
expr_stmt|;
comment|// Set state to "VisitedNone."
if|if
condition|(
name|TreeTy
modifier|*
name|L
init|=
name|Current
operator|->
name|getLeft
argument_list|()
condition|)
name|stack
operator|.
name|push_back
argument_list|(
name|reinterpret_cast
operator|<
name|uintptr_t
operator|>
operator|(
name|L
operator|)
operator||
name|VisitedRight
argument_list|)
expr_stmt|;
break|break;
case|case
name|VisitedRight
case|:
name|stack
operator|.
name|back
argument_list|()
operator|&=
operator|~
name|Flags
expr_stmt|;
name|stack
operator|.
name|back
argument_list|()
operator||=
name|VisitedLeft
expr_stmt|;
if|if
condition|(
name|TreeTy
modifier|*
name|R
init|=
name|Current
operator|->
name|getRight
argument_list|()
condition|)
name|stack
operator|.
name|push_back
argument_list|(
name|reinterpret_cast
operator|<
name|uintptr_t
operator|>
operator|(
name|R
operator|)
operator||
name|VisitedRight
argument_list|)
expr_stmt|;
break|break;
default|default:
name|llvm_unreachable
argument_list|(
literal|"Unreachable."
argument_list|)
expr_stmt|;
block|}
end_expr_stmt

begin_return
return|return
operator|*
name|this
return|;
end_return

begin_empty_stmt
unit|} }
empty_stmt|;
end_empty_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|ImutInfo
operator|>
name|class
name|ImutAVLTreeInOrderIterator
operator|:
name|public
name|std
operator|::
name|iterator
operator|<
name|std
operator|::
name|bidirectional_iterator_tag
operator|,
name|ImutAVLTree
operator|<
name|ImutInfo
operator|>>
block|{
typedef|typedef
name|ImutAVLTreeGenericIterator
operator|<
name|ImutInfo
operator|>
name|InternalIteratorTy
expr_stmt|;
name|InternalIteratorTy
name|InternalItr
expr_stmt|;
end_expr_stmt

begin_label
name|public
label|:
end_label

begin_typedef
typedef|typedef
name|ImutAVLTree
operator|<
name|ImutInfo
operator|>
name|TreeTy
expr_stmt|;
end_typedef

begin_expr_stmt
name|ImutAVLTreeInOrderIterator
argument_list|(
specifier|const
name|TreeTy
operator|*
name|Root
argument_list|)
operator|:
name|InternalItr
argument_list|(
argument|Root
argument_list|)
block|{
if|if
condition|(
name|Root
condition|)
operator|++
operator|*
name|this
expr_stmt|;
comment|// Advance to first element.
block|}
end_expr_stmt

begin_expr_stmt
name|ImutAVLTreeInOrderIterator
argument_list|()
operator|:
name|InternalItr
argument_list|()
block|{}
name|bool
name|operator
operator|==
operator|(
specifier|const
name|ImutAVLTreeInOrderIterator
operator|&
name|x
operator|)
specifier|const
block|{
return|return
name|InternalItr
operator|==
name|x
operator|.
name|InternalItr
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|bool
name|operator
operator|!=
operator|(
specifier|const
name|ImutAVLTreeInOrderIterator
operator|&
name|x
operator|)
specifier|const
block|{
return|return
operator|!
operator|(
operator|*
name|this
operator|==
name|x
operator|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|TreeTy
operator|&
name|operator
operator|*
operator|(
operator|)
specifier|const
block|{
return|return
operator|*
name|InternalItr
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|TreeTy
operator|*
name|operator
operator|->
expr|(
end_expr_stmt

begin_expr_stmt
unit|)
specifier|const
block|{
return|return
operator|&
operator|*
name|InternalItr
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|ImutAVLTreeInOrderIterator
operator|&
name|operator
operator|++
operator|(
operator|)
block|{
do|do
operator|++
name|InternalItr
expr_stmt|;
do|while
condition|(
operator|!
name|InternalItr
operator|.
name|atEnd
argument_list|()
operator|&&
name|InternalItr
operator|.
name|getVisitState
argument_list|()
operator|!=
name|InternalIteratorTy
operator|::
name|VisitedLeft
condition|)
do|;
end_expr_stmt

begin_return
return|return
operator|*
name|this
return|;
end_return

begin_expr_stmt
unit|}    ImutAVLTreeInOrderIterator
operator|&
name|operator
operator|--
operator|(
operator|)
block|{
do|do
operator|--
name|InternalItr
expr_stmt|;
do|while
condition|(
operator|!
name|InternalItr
operator|.
name|atBeginning
argument_list|()
operator|&&
name|InternalItr
operator|.
name|getVisitState
argument_list|()
operator|!=
name|InternalIteratorTy
operator|::
name|VisitedLeft
condition|)
do|;
end_expr_stmt

begin_return
return|return
operator|*
name|this
return|;
end_return

begin_macro
unit|}    void
name|skipSubTree
argument_list|()
end_macro

begin_block
block|{
name|InternalItr
operator|.
name|skipToParent
argument_list|()
expr_stmt|;
while|while
condition|(
operator|!
name|InternalItr
operator|.
name|atEnd
argument_list|()
operator|&&
name|InternalItr
operator|.
name|getVisitState
argument_list|()
operator|!=
name|InternalIteratorTy
operator|::
name|VisitedLeft
condition|)
operator|++
name|InternalItr
expr_stmt|;
block|}
end_block

begin_comment
unit|};
comment|/// Generic iterator that wraps a T::TreeTy::iterator and exposes
end_comment

begin_comment
comment|/// iterator::getValue() on dereference.
end_comment

begin_expr_stmt
name|template
operator|<
name|typename
name|T
operator|>
expr|struct
name|ImutAVLValueIterator
operator|:
name|iterator_adaptor_base
operator|<
name|ImutAVLValueIterator
operator|<
name|T
operator|>
operator|,
name|typename
name|T
operator|::
name|TreeTy
operator|::
name|iterator
operator|,
name|typename
name|std
operator|::
name|iterator_traits
operator|<
name|typename
name|T
operator|::
name|TreeTy
operator|::
name|iterator
operator|>
operator|::
name|iterator_category
operator|,
specifier|const
name|typename
name|T
operator|::
name|value_type
operator|>
block|{
name|ImutAVLValueIterator
argument_list|()
operator|=
expr|default
block|;
name|explicit
name|ImutAVLValueIterator
argument_list|(
argument|typename T::TreeTy *Tree
argument_list|)
operator|:
name|ImutAVLValueIterator
operator|::
name|iterator_adaptor_base
argument_list|(
argument|Tree
argument_list|)
block|{}
name|typename
name|ImutAVLValueIterator
operator|::
name|reference
name|operator
operator|*
operator|(
operator|)
specifier|const
block|{
return|return
name|this
operator|->
name|I
operator|->
name|getValue
argument_list|()
return|;
block|}
end_expr_stmt

begin_comment
unit|};
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|// Trait classes for Profile information.
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|/// Generic profile template.  The default behavior is to invoke the
end_comment

begin_comment
comment|/// profile method of an object.  Specializations for primitive integers
end_comment

begin_comment
comment|/// and generic handling of pointers is done below.
end_comment

begin_expr_stmt
name|template
operator|<
name|typename
name|T
operator|>
expr|struct
name|ImutProfileInfo
block|{
typedef|typedef
specifier|const
name|T
name|value_type
typedef|;
end_expr_stmt

begin_typedef
typedef|typedef
specifier|const
name|T
modifier|&
name|value_type_ref
typedef|;
end_typedef

begin_function
specifier|static
name|void
name|Profile
parameter_list|(
name|FoldingSetNodeID
modifier|&
name|ID
parameter_list|,
name|value_type_ref
name|X
parameter_list|)
block|{
name|FoldingSetTrait
operator|<
name|T
operator|>
operator|::
name|Profile
argument_list|(
name|X
argument_list|,
name|ID
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
unit|};
comment|/// Profile traits for integers.
end_comment

begin_expr_stmt
name|template
operator|<
name|typename
name|T
operator|>
expr|struct
name|ImutProfileInteger
block|{
typedef|typedef
specifier|const
name|T
name|value_type
typedef|;
end_expr_stmt

begin_typedef
typedef|typedef
specifier|const
name|T
modifier|&
name|value_type_ref
typedef|;
end_typedef

begin_function
specifier|static
name|void
name|Profile
parameter_list|(
name|FoldingSetNodeID
modifier|&
name|ID
parameter_list|,
name|value_type_ref
name|X
parameter_list|)
block|{
name|ID
operator|.
name|AddInteger
argument_list|(
name|X
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
unit|};
define|#
directive|define
name|PROFILE_INTEGER_INFO
parameter_list|(
name|X
parameter_list|)
define|\
value|template<> struct ImutProfileInfo<X> : ImutProfileInteger<X> {};
end_define

begin_macro
name|PROFILE_INTEGER_INFO
argument_list|(
argument|char
argument_list|)
end_macro

begin_macro
name|PROFILE_INTEGER_INFO
argument_list|(
argument|unsigned char
argument_list|)
end_macro

begin_macro
name|PROFILE_INTEGER_INFO
argument_list|(
argument|short
argument_list|)
end_macro

begin_macro
name|PROFILE_INTEGER_INFO
argument_list|(
argument|unsigned short
argument_list|)
end_macro

begin_macro
name|PROFILE_INTEGER_INFO
argument_list|(
argument|unsigned
argument_list|)
end_macro

begin_macro
name|PROFILE_INTEGER_INFO
argument_list|(
argument|signed
argument_list|)
end_macro

begin_macro
name|PROFILE_INTEGER_INFO
argument_list|(
argument|long
argument_list|)
end_macro

begin_macro
name|PROFILE_INTEGER_INFO
argument_list|(
argument|unsigned long
argument_list|)
end_macro

begin_macro
name|PROFILE_INTEGER_INFO
argument_list|(
argument|long long
argument_list|)
end_macro

begin_macro
name|PROFILE_INTEGER_INFO
argument_list|(
argument|unsigned long long
argument_list|)
end_macro

begin_undef
undef|#
directive|undef
name|PROFILE_INTEGER_INFO
end_undef

begin_comment
comment|/// Profile traits for booleans.
end_comment

begin_expr_stmt
name|template
operator|<
operator|>
expr|struct
name|ImutProfileInfo
operator|<
name|bool
operator|>
block|{
typedef|typedef
specifier|const
name|bool
name|value_type
typedef|;
end_expr_stmt

begin_typedef
typedef|typedef
specifier|const
name|bool
modifier|&
name|value_type_ref
typedef|;
end_typedef

begin_function
specifier|static
name|void
name|Profile
parameter_list|(
name|FoldingSetNodeID
modifier|&
name|ID
parameter_list|,
name|value_type_ref
name|X
parameter_list|)
block|{
name|ID
operator|.
name|AddBoolean
argument_list|(
name|X
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
unit|};
comment|/// Generic profile trait for pointer types.  We treat pointers as
end_comment

begin_comment
comment|/// references to unique objects.
end_comment

begin_expr_stmt
name|template
operator|<
name|typename
name|T
operator|>
expr|struct
name|ImutProfileInfo
operator|<
name|T
operator|*
operator|>
block|{
typedef|typedef
specifier|const
name|T
modifier|*
name|value_type
typedef|;
end_expr_stmt

begin_typedef
typedef|typedef
name|value_type
name|value_type_ref
typedef|;
end_typedef

begin_function
specifier|static
name|void
name|Profile
parameter_list|(
name|FoldingSetNodeID
modifier|&
name|ID
parameter_list|,
name|value_type_ref
name|X
parameter_list|)
block|{
name|ID
operator|.
name|AddPointer
argument_list|(
name|X
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
unit|};
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|// Trait classes that contain element comparison operators and type
end_comment

begin_comment
comment|//  definitions used by ImutAVLTree, ImmutableSet, and ImmutableMap.  These
end_comment

begin_comment
comment|//  inherit from the profile traits (ImutProfileInfo) to include operations
end_comment

begin_comment
comment|//  for element profiling.
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|/// ImutContainerInfo - Generic definition of comparison operations for
end_comment

begin_comment
comment|///   elements of immutable containers that defaults to using
end_comment

begin_comment
comment|///   std::equal_to<> and std::less<> to perform comparison of elements.
end_comment

begin_expr_stmt
name|template
operator|<
name|typename
name|T
operator|>
expr|struct
name|ImutContainerInfo
operator|:
name|public
name|ImutProfileInfo
operator|<
name|T
operator|>
block|{
typedef|typedef
name|typename
name|ImutProfileInfo
operator|<
name|T
operator|>
operator|::
name|value_type
name|value_type
expr_stmt|;
end_expr_stmt

begin_typedef
typedef|typedef
name|typename
name|ImutProfileInfo
operator|<
name|T
operator|>
operator|::
name|value_type_ref
name|value_type_ref
expr_stmt|;
end_typedef

begin_typedef
typedef|typedef
name|value_type
name|key_type
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|value_type_ref
name|key_type_ref
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|bool
name|data_type
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|bool
name|data_type_ref
typedef|;
end_typedef

begin_function
specifier|static
name|key_type_ref
name|KeyOfValue
parameter_list|(
name|value_type_ref
name|D
parameter_list|)
block|{
return|return
name|D
return|;
block|}
end_function

begin_function
specifier|static
name|data_type_ref
name|DataOfValue
parameter_list|(
name|value_type_ref
parameter_list|)
block|{
return|return
name|true
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|isEqual
parameter_list|(
name|key_type_ref
name|LHS
parameter_list|,
name|key_type_ref
name|RHS
parameter_list|)
block|{
return|return
name|std
operator|::
name|equal_to
operator|<
name|key_type
operator|>
operator|(
operator|)
operator|(
name|LHS
operator|,
name|RHS
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|isLess
parameter_list|(
name|key_type_ref
name|LHS
parameter_list|,
name|key_type_ref
name|RHS
parameter_list|)
block|{
return|return
name|std
operator|::
name|less
operator|<
name|key_type
operator|>
operator|(
operator|)
operator|(
name|LHS
operator|,
name|RHS
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|isDataEqual
parameter_list|(
name|data_type_ref
parameter_list|,
name|data_type_ref
parameter_list|)
block|{
return|return
name|true
return|;
block|}
end_function

begin_comment
unit|};
comment|/// ImutContainerInfo - Specialization for pointer values to treat pointers
end_comment

begin_comment
comment|///  as references to unique objects.  Pointers are thus compared by
end_comment

begin_comment
comment|///  their addresses.
end_comment

begin_expr_stmt
name|template
operator|<
name|typename
name|T
operator|>
expr|struct
name|ImutContainerInfo
operator|<
name|T
operator|*
operator|>
operator|:
name|public
name|ImutProfileInfo
operator|<
name|T
operator|*
operator|>
block|{
typedef|typedef
name|typename
name|ImutProfileInfo
operator|<
name|T
operator|*
operator|>
operator|::
name|value_type
name|value_type
expr_stmt|;
end_expr_stmt

begin_typedef
typedef|typedef
name|typename
name|ImutProfileInfo
operator|<
name|T
operator|*
operator|>
operator|::
name|value_type_ref
name|value_type_ref
expr_stmt|;
end_typedef

begin_typedef
typedef|typedef
name|value_type
name|key_type
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|value_type_ref
name|key_type_ref
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|bool
name|data_type
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|bool
name|data_type_ref
typedef|;
end_typedef

begin_function
specifier|static
name|key_type_ref
name|KeyOfValue
parameter_list|(
name|value_type_ref
name|D
parameter_list|)
block|{
return|return
name|D
return|;
block|}
end_function

begin_function
specifier|static
name|data_type_ref
name|DataOfValue
parameter_list|(
name|value_type_ref
parameter_list|)
block|{
return|return
name|true
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|isEqual
parameter_list|(
name|key_type_ref
name|LHS
parameter_list|,
name|key_type_ref
name|RHS
parameter_list|)
block|{
return|return
name|LHS
operator|==
name|RHS
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|isLess
parameter_list|(
name|key_type_ref
name|LHS
parameter_list|,
name|key_type_ref
name|RHS
parameter_list|)
block|{
return|return
name|LHS
operator|<
name|RHS
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|isDataEqual
parameter_list|(
name|data_type_ref
parameter_list|,
name|data_type_ref
parameter_list|)
block|{
return|return
name|true
return|;
block|}
end_function

begin_comment
unit|};
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|// Immutable Set
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_expr_stmt
name|template
operator|<
name|typename
name|ValT
operator|,
name|typename
name|ValInfo
operator|=
name|ImutContainerInfo
operator|<
name|ValT
operator|>>
name|class
name|ImmutableSet
block|{
name|public
operator|:
typedef|typedef
name|typename
name|ValInfo
operator|::
name|value_type
name|value_type
expr_stmt|;
end_expr_stmt

begin_typedef
typedef|typedef
name|typename
name|ValInfo
operator|::
name|value_type_ref
name|value_type_ref
expr_stmt|;
end_typedef

begin_typedef
typedef|typedef
name|ImutAVLTree
operator|<
name|ValInfo
operator|>
name|TreeTy
expr_stmt|;
end_typedef

begin_label
name|private
label|:
end_label

begin_decl_stmt
name|TreeTy
modifier|*
name|Root
decl_stmt|;
end_decl_stmt

begin_label
name|public
label|:
end_label

begin_comment
comment|/// Constructs a set from a pointer to a tree root.  In general one
end_comment

begin_comment
comment|/// should use a Factory object to create sets instead of directly
end_comment

begin_comment
comment|/// invoking the constructor, but there are cases where make this
end_comment

begin_comment
comment|/// constructor public is useful.
end_comment

begin_macro
name|explicit
end_macro

begin_expr_stmt
name|ImmutableSet
argument_list|(
name|TreeTy
operator|*
name|R
argument_list|)
operator|:
name|Root
argument_list|(
argument|R
argument_list|)
block|{
if|if
condition|(
name|Root
condition|)
block|{
name|Root
operator|->
name|retain
argument_list|()
expr_stmt|;
block|}
end_expr_stmt

begin_expr_stmt
unit|}    ImmutableSet
operator|(
specifier|const
name|ImmutableSet
operator|&
name|X
operator|)
operator|:
name|Root
argument_list|(
argument|X.Root
argument_list|)
block|{
if|if
condition|(
name|Root
condition|)
block|{
name|Root
operator|->
name|retain
argument_list|()
expr_stmt|;
block|}
end_expr_stmt

begin_expr_stmt
unit|}    ImmutableSet
operator|&
name|operator
operator|=
operator|(
specifier|const
name|ImmutableSet
operator|&
name|X
operator|)
block|{
if|if
condition|(
name|Root
operator|!=
name|X
operator|.
name|Root
condition|)
block|{
if|if
condition|(
name|X
operator|.
name|Root
condition|)
block|{
name|X
operator|.
name|Root
operator|->
name|retain
argument_list|()
expr_stmt|;
block|}
end_expr_stmt

begin_if
if|if
condition|(
name|Root
condition|)
block|{
name|Root
operator|->
name|release
argument_list|()
expr_stmt|;
block|}
end_if

begin_expr_stmt
name|Root
operator|=
name|X
operator|.
name|Root
expr_stmt|;
end_expr_stmt

begin_expr_stmt
unit|}     return
operator|*
name|this
expr_stmt|;
end_expr_stmt

begin_macro
unit|}    ~
name|ImmutableSet
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|Root
condition|)
block|{
name|Root
operator|->
name|release
argument_list|()
expr_stmt|;
block|}
block|}
end_block

begin_decl_stmt
name|class
name|Factory
block|{
name|typename
name|TreeTy
operator|::
name|Factory
name|F
expr_stmt|;
specifier|const
name|bool
name|Canonicalize
decl_stmt|;
name|public
label|:
name|Factory
argument_list|(
argument|bool canonicalize = true
argument_list|)
block|:
name|Canonicalize
argument_list|(
argument|canonicalize
argument_list|)
block|{}
name|Factory
argument_list|(
argument|BumpPtrAllocator& Alloc
argument_list|,
argument|bool canonicalize = true
argument_list|)
block|:
name|F
argument_list|(
name|Alloc
argument_list|)
operator|,
name|Canonicalize
argument_list|(
argument|canonicalize
argument_list|)
block|{}
name|Factory
argument_list|(
specifier|const
name|Factory
operator|&
name|RHS
argument_list|)
operator|=
name|delete
expr_stmt|;
name|void
name|operator
init|=
operator|(
specifier|const
name|Factory
operator|&
name|RHS
operator|)
operator|=
name|delete
decl_stmt|;
comment|/// getEmptySet - Returns an immutable set that contains no elements.
name|ImmutableSet
name|getEmptySet
parameter_list|()
block|{
return|return
name|ImmutableSet
argument_list|(
name|F
operator|.
name|getEmptyTree
argument_list|()
argument_list|)
return|;
block|}
comment|/// add - Creates a new immutable set that contains all of the values
comment|///  of the original set with the addition of the specified value.  If
comment|///  the original set already included the value, then the original set is
comment|///  returned and no memory is allocated.  The time and space complexity
comment|///  of this operation is logarithmic in the size of the original set.
comment|///  The memory allocated to represent the set is released when the
comment|///  factory object that created the set is destroyed.
name|ImmutableSet
name|add
parameter_list|(
name|ImmutableSet
name|Old
parameter_list|,
name|value_type_ref
name|V
parameter_list|)
block|{
name|TreeTy
modifier|*
name|NewT
init|=
name|F
operator|.
name|add
argument_list|(
name|Old
operator|.
name|Root
argument_list|,
name|V
argument_list|)
decl_stmt|;
return|return
name|ImmutableSet
argument_list|(
name|Canonicalize
condition|?
name|F
operator|.
name|getCanonicalTree
argument_list|(
name|NewT
argument_list|)
else|:
name|NewT
argument_list|)
return|;
block|}
comment|/// remove - Creates a new immutable set that contains all of the values
comment|///  of the original set with the exception of the specified value.  If
comment|///  the original set did not contain the value, the original set is
comment|///  returned and no memory is allocated.  The time and space complexity
comment|///  of this operation is logarithmic in the size of the original set.
comment|///  The memory allocated to represent the set is released when the
comment|///  factory object that created the set is destroyed.
name|ImmutableSet
name|remove
parameter_list|(
name|ImmutableSet
name|Old
parameter_list|,
name|value_type_ref
name|V
parameter_list|)
block|{
name|TreeTy
modifier|*
name|NewT
init|=
name|F
operator|.
name|remove
argument_list|(
name|Old
operator|.
name|Root
argument_list|,
name|V
argument_list|)
decl_stmt|;
return|return
name|ImmutableSet
argument_list|(
name|Canonicalize
condition|?
name|F
operator|.
name|getCanonicalTree
argument_list|(
name|NewT
argument_list|)
else|:
name|NewT
argument_list|)
return|;
block|}
name|BumpPtrAllocator
modifier|&
name|getAllocator
parameter_list|()
block|{
return|return
name|F
operator|.
name|getAllocator
argument_list|()
return|;
block|}
name|typename
name|TreeTy
operator|::
name|Factory
operator|*
name|getTreeFactory
argument_list|()
specifier|const
block|{
return|return
name|const_cast
operator|<
name|typename
name|TreeTy
operator|::
name|Factory
operator|*
operator|>
operator|(
operator|&
name|F
operator|)
return|;
block|}
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_decl_stmt
name|friend
name|class
name|Factory
decl_stmt|;
end_decl_stmt

begin_comment
comment|/// Returns true if the set contains the specified value.
end_comment

begin_decl_stmt
name|bool
name|contains
argument_list|(
name|value_type_ref
name|V
argument_list|)
decl|const
block|{
return|return
name|Root
condition|?
name|Root
operator|->
name|contains
argument_list|(
name|V
argument_list|)
else|:
name|false
return|;
block|}
end_decl_stmt

begin_expr_stmt
name|bool
name|operator
operator|==
operator|(
specifier|const
name|ImmutableSet
operator|&
name|RHS
operator|)
specifier|const
block|{
return|return
name|Root
operator|&&
name|RHS
operator|.
name|Root
operator|?
name|Root
operator|->
name|isEqual
argument_list|(
operator|*
name|RHS
operator|.
name|Root
argument_list|)
operator|:
name|Root
operator|==
name|RHS
operator|.
name|Root
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|bool
name|operator
operator|!=
operator|(
specifier|const
name|ImmutableSet
operator|&
name|RHS
operator|)
specifier|const
block|{
return|return
name|Root
operator|&&
name|RHS
operator|.
name|Root
operator|?
name|Root
operator|->
name|isNotEqual
argument_list|(
operator|*
name|RHS
operator|.
name|Root
argument_list|)
operator|:
name|Root
operator|!=
name|RHS
operator|.
name|Root
return|;
block|}
end_expr_stmt

begin_function
name|TreeTy
modifier|*
name|getRoot
parameter_list|()
block|{
if|if
condition|(
name|Root
condition|)
block|{
name|Root
operator|->
name|retain
argument_list|()
expr_stmt|;
block|}
return|return
name|Root
return|;
block|}
end_function

begin_expr_stmt
name|TreeTy
operator|*
name|getRootWithoutRetain
argument_list|()
specifier|const
block|{
return|return
name|Root
return|;
block|}
end_expr_stmt

begin_comment
comment|/// isEmpty - Return true if the set contains no elements.
end_comment

begin_expr_stmt
name|bool
name|isEmpty
argument_list|()
specifier|const
block|{
return|return
operator|!
name|Root
return|;
block|}
end_expr_stmt

begin_comment
comment|/// isSingleton - Return true if the set contains exactly one element.
end_comment

begin_comment
comment|///   This method runs in constant time.
end_comment

begin_expr_stmt
name|bool
name|isSingleton
argument_list|()
specifier|const
block|{
return|return
name|getHeight
argument_list|()
operator|==
literal|1
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|Callback
operator|>
name|void
name|foreach
argument_list|(
argument|Callback& C
argument_list|)
block|{
if|if
condition|(
name|Root
condition|)
name|Root
operator|->
name|foreach
argument_list|(
name|C
argument_list|)
expr_stmt|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|Callback
operator|>
name|void
name|foreach
argument_list|()
block|{
if|if
condition|(
name|Root
condition|)
block|{
name|Callback
name|C
decl_stmt|;
name|Root
operator|->
name|foreach
argument_list|(
name|C
argument_list|)
expr_stmt|;
block|}
end_expr_stmt

begin_comment
unit|}
comment|//===--------------------------------------------------===//
end_comment

begin_comment
comment|// Iterators.
end_comment

begin_comment
comment|//===--------------------------------------------------===//
end_comment

begin_expr_stmt
unit|typedef
name|ImutAVLValueIterator
operator|<
name|ImmutableSet
operator|>
name|iterator
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|iterator
name|begin
argument_list|()
specifier|const
block|{
return|return
name|iterator
argument_list|(
name|Root
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|iterator
name|end
argument_list|()
specifier|const
block|{
return|return
name|iterator
argument_list|()
return|;
block|}
end_expr_stmt

begin_comment
comment|//===--------------------------------------------------===//
end_comment

begin_comment
comment|// Utility methods.
end_comment

begin_comment
comment|//===--------------------------------------------------===//
end_comment

begin_expr_stmt
name|unsigned
name|getHeight
argument_list|()
specifier|const
block|{
return|return
name|Root
operator|?
name|Root
operator|->
name|getHeight
argument_list|()
operator|:
literal|0
return|;
block|}
end_expr_stmt

begin_function
specifier|static
name|void
name|Profile
parameter_list|(
name|FoldingSetNodeID
modifier|&
name|ID
parameter_list|,
specifier|const
name|ImmutableSet
modifier|&
name|S
parameter_list|)
block|{
name|ID
operator|.
name|AddPointer
argument_list|(
name|S
operator|.
name|Root
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
name|void
name|Profile
argument_list|(
name|FoldingSetNodeID
operator|&
name|ID
argument_list|)
decl|const
block|{
return|return
name|Profile
argument_list|(
name|ID
argument_list|,
operator|*
name|this
argument_list|)
return|;
block|}
end_decl_stmt

begin_comment
comment|//===--------------------------------------------------===//
end_comment

begin_comment
comment|// For testing.
end_comment

begin_comment
comment|//===--------------------------------------------------===//
end_comment

begin_expr_stmt
name|void
name|validateTree
argument_list|()
specifier|const
block|{
if|if
condition|(
name|Root
condition|)
name|Root
operator|->
name|validateTree
argument_list|()
expr_stmt|;
block|}
end_expr_stmt

begin_comment
unit|};
comment|// NOTE: This may some day replace the current ImmutableSet.
end_comment

begin_expr_stmt
name|template
operator|<
name|typename
name|ValT
operator|,
name|typename
name|ValInfo
operator|=
name|ImutContainerInfo
operator|<
name|ValT
operator|>>
name|class
name|ImmutableSetRef
block|{
name|public
operator|:
typedef|typedef
name|typename
name|ValInfo
operator|::
name|value_type
name|value_type
expr_stmt|;
end_expr_stmt

begin_typedef
typedef|typedef
name|typename
name|ValInfo
operator|::
name|value_type_ref
name|value_type_ref
expr_stmt|;
end_typedef

begin_typedef
typedef|typedef
name|ImutAVLTree
operator|<
name|ValInfo
operator|>
name|TreeTy
expr_stmt|;
end_typedef

begin_typedef
typedef|typedef
name|typename
name|TreeTy
operator|::
name|Factory
name|FactoryTy
expr_stmt|;
end_typedef

begin_label
name|private
label|:
end_label

begin_decl_stmt
name|TreeTy
modifier|*
name|Root
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FactoryTy
modifier|*
name|Factory
decl_stmt|;
end_decl_stmt

begin_label
name|public
label|:
end_label

begin_comment
comment|/// Constructs a set from a pointer to a tree root.  In general one
end_comment

begin_comment
comment|/// should use a Factory object to create sets instead of directly
end_comment

begin_comment
comment|/// invoking the constructor, but there are cases where make this
end_comment

begin_comment
comment|/// constructor public is useful.
end_comment

begin_macro
name|explicit
end_macro

begin_expr_stmt
name|ImmutableSetRef
argument_list|(
name|TreeTy
operator|*
name|R
argument_list|,
name|FactoryTy
operator|*
name|F
argument_list|)
operator|:
name|Root
argument_list|(
name|R
argument_list|)
operator|,
name|Factory
argument_list|(
argument|F
argument_list|)
block|{
if|if
condition|(
name|Root
condition|)
block|{
name|Root
operator|->
name|retain
argument_list|()
expr_stmt|;
block|}
end_expr_stmt

begin_expr_stmt
unit|}    ImmutableSetRef
operator|(
specifier|const
name|ImmutableSetRef
operator|&
name|X
operator|)
operator|:
name|Root
argument_list|(
name|X
operator|.
name|Root
argument_list|)
operator|,
name|Factory
argument_list|(
argument|X.Factory
argument_list|)
block|{
if|if
condition|(
name|Root
condition|)
block|{
name|Root
operator|->
name|retain
argument_list|()
expr_stmt|;
block|}
end_expr_stmt

begin_expr_stmt
unit|}    ImmutableSetRef
operator|&
name|operator
operator|=
operator|(
specifier|const
name|ImmutableSetRef
operator|&
name|X
operator|)
block|{
if|if
condition|(
name|Root
operator|!=
name|X
operator|.
name|Root
condition|)
block|{
if|if
condition|(
name|X
operator|.
name|Root
condition|)
block|{
name|X
operator|.
name|Root
operator|->
name|retain
argument_list|()
expr_stmt|;
block|}
end_expr_stmt

begin_if
if|if
condition|(
name|Root
condition|)
block|{
name|Root
operator|->
name|release
argument_list|()
expr_stmt|;
block|}
end_if

begin_expr_stmt
name|Root
operator|=
name|X
operator|.
name|Root
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|Factory
operator|=
name|X
operator|.
name|Factory
expr_stmt|;
end_expr_stmt

begin_expr_stmt
unit|}     return
operator|*
name|this
expr_stmt|;
end_expr_stmt

begin_macro
unit|}   ~
name|ImmutableSetRef
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|Root
condition|)
block|{
name|Root
operator|->
name|release
argument_list|()
expr_stmt|;
block|}
block|}
end_block

begin_function
specifier|static
name|ImmutableSetRef
name|getEmptySet
parameter_list|(
name|FactoryTy
modifier|*
name|F
parameter_list|)
block|{
return|return
name|ImmutableSetRef
argument_list|(
literal|0
argument_list|,
name|F
argument_list|)
return|;
block|}
end_function

begin_function
name|ImmutableSetRef
name|add
parameter_list|(
name|value_type_ref
name|V
parameter_list|)
block|{
return|return
name|ImmutableSetRef
argument_list|(
name|Factory
operator|->
name|add
argument_list|(
name|Root
argument_list|,
name|V
argument_list|)
argument_list|,
name|Factory
argument_list|)
return|;
block|}
end_function

begin_function
name|ImmutableSetRef
name|remove
parameter_list|(
name|value_type_ref
name|V
parameter_list|)
block|{
return|return
name|ImmutableSetRef
argument_list|(
name|Factory
operator|->
name|remove
argument_list|(
name|Root
argument_list|,
name|V
argument_list|)
argument_list|,
name|Factory
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/// Returns true if the set contains the specified value.
end_comment

begin_decl_stmt
name|bool
name|contains
argument_list|(
name|value_type_ref
name|V
argument_list|)
decl|const
block|{
return|return
name|Root
condition|?
name|Root
operator|->
name|contains
argument_list|(
name|V
argument_list|)
else|:
name|false
return|;
block|}
end_decl_stmt

begin_expr_stmt
name|ImmutableSet
operator|<
name|ValT
operator|>
name|asImmutableSet
argument_list|(
argument|bool canonicalize = true
argument_list|)
specifier|const
block|{
return|return
name|ImmutableSet
operator|<
name|ValT
operator|>
operator|(
name|canonicalize
operator|?
name|Factory
operator|->
name|getCanonicalTree
argument_list|(
name|Root
argument_list|)
operator|:
name|Root
operator|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|TreeTy
operator|*
name|getRootWithoutRetain
argument_list|()
specifier|const
block|{
return|return
name|Root
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|bool
name|operator
operator|==
operator|(
specifier|const
name|ImmutableSetRef
operator|&
name|RHS
operator|)
specifier|const
block|{
return|return
name|Root
operator|&&
name|RHS
operator|.
name|Root
operator|?
name|Root
operator|->
name|isEqual
argument_list|(
operator|*
name|RHS
operator|.
name|Root
argument_list|)
operator|:
name|Root
operator|==
name|RHS
operator|.
name|Root
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|bool
name|operator
operator|!=
operator|(
specifier|const
name|ImmutableSetRef
operator|&
name|RHS
operator|)
specifier|const
block|{
return|return
name|Root
operator|&&
name|RHS
operator|.
name|Root
operator|?
name|Root
operator|->
name|isNotEqual
argument_list|(
operator|*
name|RHS
operator|.
name|Root
argument_list|)
operator|:
name|Root
operator|!=
name|RHS
operator|.
name|Root
return|;
block|}
end_expr_stmt

begin_comment
comment|/// isEmpty - Return true if the set contains no elements.
end_comment

begin_expr_stmt
name|bool
name|isEmpty
argument_list|()
specifier|const
block|{
return|return
operator|!
name|Root
return|;
block|}
end_expr_stmt

begin_comment
comment|/// isSingleton - Return true if the set contains exactly one element.
end_comment

begin_comment
comment|///   This method runs in constant time.
end_comment

begin_expr_stmt
name|bool
name|isSingleton
argument_list|()
specifier|const
block|{
return|return
name|getHeight
argument_list|()
operator|==
literal|1
return|;
block|}
end_expr_stmt

begin_comment
comment|//===--------------------------------------------------===//
end_comment

begin_comment
comment|// Iterators.
end_comment

begin_comment
comment|//===--------------------------------------------------===//
end_comment

begin_typedef
typedef|typedef
name|ImutAVLValueIterator
operator|<
name|ImmutableSetRef
operator|>
name|iterator
expr_stmt|;
end_typedef

begin_expr_stmt
name|iterator
name|begin
argument_list|()
specifier|const
block|{
return|return
name|iterator
argument_list|(
name|Root
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|iterator
name|end
argument_list|()
specifier|const
block|{
return|return
name|iterator
argument_list|()
return|;
block|}
end_expr_stmt

begin_comment
comment|//===--------------------------------------------------===//
end_comment

begin_comment
comment|// Utility methods.
end_comment

begin_comment
comment|//===--------------------------------------------------===//
end_comment

begin_expr_stmt
name|unsigned
name|getHeight
argument_list|()
specifier|const
block|{
return|return
name|Root
operator|?
name|Root
operator|->
name|getHeight
argument_list|()
operator|:
literal|0
return|;
block|}
end_expr_stmt

begin_function
specifier|static
name|void
name|Profile
parameter_list|(
name|FoldingSetNodeID
modifier|&
name|ID
parameter_list|,
specifier|const
name|ImmutableSetRef
modifier|&
name|S
parameter_list|)
block|{
name|ID
operator|.
name|AddPointer
argument_list|(
name|S
operator|.
name|Root
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
name|void
name|Profile
argument_list|(
name|FoldingSetNodeID
operator|&
name|ID
argument_list|)
decl|const
block|{
return|return
name|Profile
argument_list|(
name|ID
argument_list|,
operator|*
name|this
argument_list|)
return|;
block|}
end_decl_stmt

begin_comment
comment|//===--------------------------------------------------===//
end_comment

begin_comment
comment|// For testing.
end_comment

begin_comment
comment|//===--------------------------------------------------===//
end_comment

begin_expr_stmt
name|void
name|validateTree
argument_list|()
specifier|const
block|{
if|if
condition|(
name|Root
condition|)
name|Root
operator|->
name|validateTree
argument_list|()
expr_stmt|;
block|}
end_expr_stmt

begin_comment
unit|};  }
comment|// end namespace llvm
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|// LLVM_ADT_IMMUTABLESET_H
end_comment

end_unit

