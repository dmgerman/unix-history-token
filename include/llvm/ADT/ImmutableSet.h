begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===--- ImmutableSet.h - Immutable (functional) set interface --*- C++ -*-===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file defines the ImutAVLTree and ImmutableSet classes.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LLVM_ADT_IMSET_H
end_ifndef

begin_define
define|#
directive|define
name|LLVM_ADT_IMSET_H
end_define

begin_include
include|#
directive|include
file|"llvm/Support/Allocator.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/FoldingSet.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/DataTypes.h"
end_include

begin_include
include|#
directive|include
file|<cassert>
end_include

begin_include
include|#
directive|include
file|<functional>
end_include

begin_decl_stmt
name|namespace
name|llvm
block|{
comment|//===----------------------------------------------------------------------===//
comment|// Immutable AVL-Tree Definition.
comment|//===----------------------------------------------------------------------===//
name|template
operator|<
name|typename
name|ImutInfo
operator|>
name|class
name|ImutAVLFactory
expr_stmt|;
name|template
operator|<
name|typename
name|ImutInfo
operator|>
name|class
name|ImutAVLTreeInOrderIterator
expr_stmt|;
name|template
operator|<
name|typename
name|ImutInfo
operator|>
name|class
name|ImutAVLTreeGenericIterator
expr_stmt|;
name|template
operator|<
name|typename
name|ImutInfo
operator|>
name|class
name|ImutAVLTree
operator|:
name|public
name|FoldingSetNode
block|{
name|public
operator|:
typedef|typedef
name|typename
name|ImutInfo
operator|::
name|key_type_ref
name|key_type_ref
expr_stmt|;
typedef|typedef
name|typename
name|ImutInfo
operator|::
name|value_type
name|value_type
expr_stmt|;
typedef|typedef
name|typename
name|ImutInfo
operator|::
name|value_type_ref
name|value_type_ref
expr_stmt|;
typedef|typedef
name|ImutAVLFactory
operator|<
name|ImutInfo
operator|>
name|Factory
expr_stmt|;
name|friend
name|class
name|ImutAVLFactory
operator|<
name|ImutInfo
operator|>
expr_stmt|;
name|friend
name|class
name|ImutAVLTreeGenericIterator
operator|<
name|ImutInfo
operator|>
expr_stmt|;
name|friend
name|class
name|FoldingSet
operator|<
name|ImutAVLTree
operator|>
expr_stmt|;
typedef|typedef
name|ImutAVLTreeInOrderIterator
operator|<
name|ImutInfo
operator|>
name|iterator
expr_stmt|;
comment|//===----------------------------------------------------===//
comment|// Public Interface.
comment|//===----------------------------------------------------===//
comment|/// getLeft - Returns a pointer to the left subtree.  This value
comment|///  is NULL if there is no left subtree.
name|ImutAVLTree
operator|*
name|getLeft
argument_list|()
specifier|const
block|{
return|return
name|reinterpret_cast
operator|<
name|ImutAVLTree
operator|*
operator|>
operator|(
name|Left
operator|&
operator|~
name|LeftFlags
operator|)
return|;
block|}
comment|/// getRight - Returns a pointer to the right subtree.  This value is
comment|///  NULL if there is no right subtree.
name|ImutAVLTree
operator|*
name|getRight
argument_list|()
specifier|const
block|{
return|return
name|Right
return|;
block|}
comment|/// getHeight - Returns the height of the tree.  A tree with no subtrees
comment|///  has a height of 1.
name|unsigned
name|getHeight
argument_list|()
specifier|const
block|{
return|return
name|Height
return|;
block|}
comment|/// getValue - Returns the data value associated with the tree node.
specifier|const
name|value_type
operator|&
name|getValue
argument_list|()
specifier|const
block|{
return|return
name|Value
return|;
block|}
comment|/// find - Finds the subtree associated with the specified key value.
comment|///  This method returns NULL if no matching subtree is found.
name|ImutAVLTree
modifier|*
name|find
parameter_list|(
name|key_type_ref
name|K
parameter_list|)
block|{
name|ImutAVLTree
modifier|*
name|T
init|=
name|this
decl_stmt|;
while|while
condition|(
name|T
condition|)
block|{
name|key_type_ref
name|CurrentKey
init|=
name|ImutInfo
operator|::
name|KeyOfValue
argument_list|(
name|T
operator|->
name|getValue
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|ImutInfo
operator|::
name|isEqual
argument_list|(
name|K
argument_list|,
name|CurrentKey
argument_list|)
condition|)
return|return
name|T
return|;
elseif|else
if|if
condition|(
name|ImutInfo
operator|::
name|isLess
argument_list|(
name|K
argument_list|,
name|CurrentKey
argument_list|)
condition|)
name|T
operator|=
name|T
operator|->
name|getLeft
argument_list|()
expr_stmt|;
else|else
name|T
operator|=
name|T
operator|->
name|getRight
argument_list|()
expr_stmt|;
block|}
return|return
name|NULL
return|;
block|}
comment|/// getMaxElement - Find the subtree associated with the highest ranged
comment|///  key value.
name|ImutAVLTree
modifier|*
name|getMaxElement
parameter_list|()
block|{
name|ImutAVLTree
modifier|*
name|T
init|=
name|this
decl_stmt|;
name|ImutAVLTree
modifier|*
name|Right
init|=
name|T
operator|->
name|getRight
argument_list|()
decl_stmt|;
while|while
condition|(
name|Right
condition|)
block|{
name|T
operator|=
name|Right
expr_stmt|;
name|Right
operator|=
name|T
operator|->
name|getRight
argument_list|()
expr_stmt|;
block|}
return|return
name|T
return|;
block|}
comment|/// size - Returns the number of nodes in the tree, which includes
comment|///  both leaves and non-leaf nodes.
name|unsigned
name|size
argument_list|()
specifier|const
block|{
name|unsigned
name|n
operator|=
literal|1
block|;
if|if
condition|(
specifier|const
name|ImutAVLTree
modifier|*
name|L
init|=
name|getLeft
argument_list|()
condition|)
name|n
operator|+=
name|L
operator|->
name|size
argument_list|()
expr_stmt|;
if|if
condition|(
specifier|const
name|ImutAVLTree
modifier|*
name|R
init|=
name|getRight
argument_list|()
condition|)
name|n
operator|+=
name|R
operator|->
name|size
argument_list|()
expr_stmt|;
return|return
name|n
return|;
block|}
end_decl_stmt

begin_comment
comment|/// begin - Returns an iterator that iterates over the nodes of the tree
end_comment

begin_comment
comment|///  in an inorder traversal.  The returned iterator thus refers to the
end_comment

begin_comment
comment|///  the tree node with the minimum data element.
end_comment

begin_expr_stmt
name|iterator
name|begin
argument_list|()
specifier|const
block|{
return|return
name|iterator
argument_list|(
name|this
argument_list|)
return|;
block|}
end_expr_stmt

begin_comment
comment|/// end - Returns an iterator for the tree that denotes the end of an
end_comment

begin_comment
comment|///  inorder traversal.
end_comment

begin_expr_stmt
name|iterator
name|end
argument_list|()
specifier|const
block|{
return|return
name|iterator
argument_list|()
return|;
block|}
end_expr_stmt

begin_decl_stmt
name|bool
name|ElementEqual
argument_list|(
name|value_type_ref
name|V
argument_list|)
decl|const
block|{
comment|// Compare the keys.
if|if
condition|(
operator|!
name|ImutInfo
operator|::
name|isEqual
argument_list|(
name|ImutInfo
operator|::
name|KeyOfValue
argument_list|(
name|getValue
argument_list|()
argument_list|)
argument_list|,
name|ImutInfo
operator|::
name|KeyOfValue
argument_list|(
name|V
argument_list|)
argument_list|)
condition|)
return|return
name|false
return|;
comment|// Also compare the data values.
if|if
condition|(
operator|!
name|ImutInfo
operator|::
name|isDataEqual
argument_list|(
name|ImutInfo
operator|::
name|DataOfValue
argument_list|(
name|getValue
argument_list|()
argument_list|)
argument_list|,
name|ImutInfo
operator|::
name|DataOfValue
argument_list|(
name|V
argument_list|)
argument_list|)
condition|)
return|return
name|false
return|;
return|return
name|true
return|;
block|}
end_decl_stmt

begin_decl_stmt
name|bool
name|ElementEqual
argument_list|(
specifier|const
name|ImutAVLTree
operator|*
name|RHS
argument_list|)
decl|const
block|{
return|return
name|ElementEqual
argument_list|(
name|RHS
operator|->
name|getValue
argument_list|()
argument_list|)
return|;
block|}
end_decl_stmt

begin_comment
comment|/// isEqual - Compares two trees for structural equality and returns true
end_comment

begin_comment
comment|///   if they are equal.  This worst case performance of this operation is
end_comment

begin_comment
comment|//    linear in the sizes of the trees.
end_comment

begin_decl_stmt
name|bool
name|isEqual
argument_list|(
specifier|const
name|ImutAVLTree
operator|&
name|RHS
argument_list|)
decl|const
block|{
if|if
condition|(
operator|&
name|RHS
operator|==
name|this
condition|)
return|return
name|true
return|;
name|iterator
name|LItr
init|=
name|begin
argument_list|()
decl_stmt|,
name|LEnd
init|=
name|end
argument_list|()
decl_stmt|;
name|iterator
name|RItr
init|=
name|RHS
operator|.
name|begin
argument_list|()
decl_stmt|,
name|REnd
init|=
name|RHS
operator|.
name|end
argument_list|()
decl_stmt|;
while|while
condition|(
name|LItr
operator|!=
name|LEnd
operator|&&
name|RItr
operator|!=
name|REnd
condition|)
block|{
if|if
condition|(
operator|*
name|LItr
operator|==
operator|*
name|RItr
condition|)
block|{
name|LItr
operator|.
name|SkipSubTree
argument_list|()
expr_stmt|;
name|RItr
operator|.
name|SkipSubTree
argument_list|()
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|!
name|LItr
operator|->
name|ElementEqual
argument_list|(
operator|*
name|RItr
argument_list|)
condition|)
return|return
name|false
return|;
operator|++
name|LItr
expr_stmt|;
operator|++
name|RItr
expr_stmt|;
block|}
return|return
name|LItr
operator|==
name|LEnd
operator|&&
name|RItr
operator|==
name|REnd
return|;
block|}
end_decl_stmt

begin_comment
comment|/// isNotEqual - Compares two trees for structural inequality.  Performance
end_comment

begin_comment
comment|///  is the same is isEqual.
end_comment

begin_decl_stmt
name|bool
name|isNotEqual
argument_list|(
specifier|const
name|ImutAVLTree
operator|&
name|RHS
argument_list|)
decl|const
block|{
return|return
operator|!
name|isEqual
argument_list|(
name|RHS
argument_list|)
return|;
block|}
end_decl_stmt

begin_comment
comment|/// contains - Returns true if this tree contains a subtree (node) that
end_comment

begin_comment
comment|///  has an data element that matches the specified key.  Complexity
end_comment

begin_comment
comment|///  is logarithmic in the size of the tree.
end_comment

begin_function
name|bool
name|contains
parameter_list|(
name|key_type_ref
name|K
parameter_list|)
block|{
return|return
operator|(
name|bool
operator|)
name|find
argument_list|(
name|K
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/// foreach - A member template the accepts invokes operator() on a functor
end_comment

begin_comment
comment|///  object (specifed by Callback) for every node/subtree in the tree.
end_comment

begin_comment
comment|///  Nodes are visited using an inorder traversal.
end_comment

begin_expr_stmt
name|template
operator|<
name|typename
name|Callback
operator|>
name|void
name|foreach
argument_list|(
argument|Callback& C
argument_list|)
block|{
if|if
condition|(
name|ImutAVLTree
modifier|*
name|L
init|=
name|getLeft
argument_list|()
condition|)
name|L
operator|->
name|foreach
argument_list|(
name|C
argument_list|)
expr_stmt|;
name|C
argument_list|(
name|Value
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|ImutAVLTree
modifier|*
name|R
init|=
name|getRight
argument_list|()
condition|)
name|R
operator|->
name|foreach
argument_list|(
name|C
argument_list|)
expr_stmt|;
end_if

begin_comment
unit|}
comment|/// verify - A utility method that checks that the balancing and
end_comment

begin_comment
comment|///  ordering invariants of the tree are satisifed.  It is a recursive
end_comment

begin_comment
comment|///  method that returns the height of the tree, which is then consumed
end_comment

begin_comment
comment|///  by the enclosing verify call.  External callers should ignore the
end_comment

begin_comment
comment|///  return value.  An invalid tree will cause an assertion to fire in
end_comment

begin_comment
comment|///  a debug build.
end_comment

begin_macro
unit|unsigned
name|verify
argument_list|()
end_macro

begin_expr_stmt
specifier|const
block|{
name|unsigned
name|HL
operator|=
name|getLeft
argument_list|()
operator|?
name|getLeft
argument_list|()
operator|->
name|verify
argument_list|()
operator|:
literal|0
block|;
name|unsigned
name|HR
operator|=
name|getRight
argument_list|()
condition|?
name|getRight
argument_list|()
operator|->
name|verify
argument_list|()
else|:
literal|0
block|;
name|assert
argument_list|(
name|getHeight
argument_list|()
operator|==
operator|(
name|HL
operator|>
name|HR
condition|?
name|HL
else|:
name|HR
operator|)
operator|+
literal|1
operator|&&
literal|"Height calculation wrong."
argument_list|)
block|;
name|assert
argument_list|(
operator|(
name|HL
operator|>
name|HR
condition|?
name|HL
operator|-
name|HR
else|:
name|HR
operator|-
name|HL
operator|)
operator|<=
literal|2
operator|&&
literal|"Balancing invariant violated."
argument_list|)
block|;
name|assert
argument_list|(
operator|!
name|getLeft
argument_list|()
operator|||
name|ImutInfo
operator|::
name|isLess
argument_list|(
name|ImutInfo
operator|::
name|KeyOfValue
argument_list|(
name|getLeft
argument_list|()
operator|->
name|getValue
argument_list|()
argument_list|)
argument_list|,
name|ImutInfo
operator|::
name|KeyOfValue
argument_list|(
name|getValue
argument_list|()
argument_list|)
argument_list|)
operator|&&
literal|"Value in left child is not less that current value."
argument_list|)
block|;
name|assert
argument_list|(
operator|!
name|getRight
argument_list|()
operator|||
name|ImutInfo
operator|::
name|isLess
argument_list|(
name|ImutInfo
operator|::
name|KeyOfValue
argument_list|(
name|getValue
argument_list|()
argument_list|)
argument_list|,
name|ImutInfo
operator|::
name|KeyOfValue
argument_list|(
name|getRight
argument_list|()
operator|->
name|getValue
argument_list|()
argument_list|)
argument_list|)
operator|&&
literal|"Current value is not less that value of right child."
argument_list|)
block|;
return|return
name|getHeight
argument_list|()
return|;
block|}
end_expr_stmt

begin_comment
comment|/// Profile - Profiling for ImutAVLTree.
end_comment

begin_decl_stmt
name|void
name|Profile
argument_list|(
name|llvm
operator|::
name|FoldingSetNodeID
operator|&
name|ID
argument_list|)
block|{
name|ID
operator|.
name|AddInteger
argument_list|(
name|ComputeDigest
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_comment
comment|//===----------------------------------------------------===//
end_comment

begin_comment
comment|// Internal Values.
end_comment

begin_comment
comment|//===----------------------------------------------------===//
end_comment

begin_label
name|private
label|:
end_label

begin_decl_stmt
name|uintptr_t
name|Left
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|ImutAVLTree
modifier|*
name|Right
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|Height
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|value_type
name|Value
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|uint32_t
name|Digest
decl_stmt|;
end_decl_stmt

begin_comment
comment|//===----------------------------------------------------===//
end_comment

begin_comment
comment|// Internal methods (node manipulation; used by Factory).
end_comment

begin_comment
comment|//===----------------------------------------------------===//
end_comment

begin_label
name|private
label|:
end_label

begin_enum
enum|enum
block|{
name|Mutable
init|=
literal|0x1
block|,
name|NoCachedDigest
init|=
literal|0x2
block|,
name|LeftFlags
init|=
literal|0x3
block|}
enum|;
end_enum

begin_comment
comment|/// ImutAVLTree - Internal constructor that is only called by
end_comment

begin_comment
comment|///   ImutAVLFactory.
end_comment

begin_macro
name|ImutAVLTree
argument_list|(
argument|ImutAVLTree* l
argument_list|,
argument|ImutAVLTree* r
argument_list|,
argument|value_type_ref v
argument_list|,
argument|unsigned height
argument_list|)
end_macro

begin_expr_stmt
unit|:
name|Left
argument_list|(
name|reinterpret_cast
operator|<
name|uintptr_t
operator|>
operator|(
name|l
operator|)
operator||
operator|(
name|Mutable
operator||
name|NoCachedDigest
operator|)
argument_list|)
operator|,
name|Right
argument_list|(
name|r
argument_list|)
operator|,
name|Height
argument_list|(
name|height
argument_list|)
operator|,
name|Value
argument_list|(
name|v
argument_list|)
operator|,
name|Digest
argument_list|(
literal|0
argument_list|)
block|{}
comment|/// isMutable - Returns true if the left and right subtree references
comment|///  (as well as height) can be changed.  If this method returns false,
comment|///  the tree is truly immutable.  Trees returned from an ImutAVLFactory
comment|///  object should always have this method return true.  Further, if this
comment|///  method returns false for an instance of ImutAVLTree, all subtrees
comment|///  will also have this method return false.  The converse is not true.
name|bool
name|isMutable
argument_list|()
specifier|const
block|{
return|return
name|Left
operator|&
name|Mutable
return|;
block|}
end_expr_stmt

begin_comment
comment|/// hasCachedDigest - Returns true if the digest for this tree is cached.
end_comment

begin_comment
comment|///  This can only be true if the tree is immutable.
end_comment

begin_expr_stmt
name|bool
name|hasCachedDigest
argument_list|()
specifier|const
block|{
return|return
operator|!
operator|(
name|Left
operator|&
name|NoCachedDigest
operator|)
return|;
block|}
end_expr_stmt

begin_comment
comment|//===----------------------------------------------------===//
end_comment

begin_comment
comment|// Mutating operations.  A tree root can be manipulated as
end_comment

begin_comment
comment|// long as its reference has not "escaped" from internal
end_comment

begin_comment
comment|// methods of a factory object (see below).  When a tree
end_comment

begin_comment
comment|// pointer is externally viewable by client code, the
end_comment

begin_comment
comment|// internal "mutable bit" is cleared to mark the tree
end_comment

begin_comment
comment|// immutable.  Note that a tree that still has its mutable
end_comment

begin_comment
comment|// bit set may have children (subtrees) that are themselves
end_comment

begin_comment
comment|// immutable.
end_comment

begin_comment
comment|//===----------------------------------------------------===//
end_comment

begin_comment
comment|/// MarkImmutable - Clears the mutable flag for a tree.  After this happens,
end_comment

begin_comment
comment|///   it is an error to call setLeft(), setRight(), and setHeight().
end_comment

begin_function
name|void
name|MarkImmutable
parameter_list|()
block|{
name|assert
argument_list|(
name|isMutable
argument_list|()
operator|&&
literal|"Mutable flag already removed."
argument_list|)
expr_stmt|;
name|Left
operator|&=
operator|~
name|Mutable
expr_stmt|;
block|}
end_function

begin_comment
comment|/// MarkedCachedDigest - Clears the NoCachedDigest flag for a tree.
end_comment

begin_function
name|void
name|MarkedCachedDigest
parameter_list|()
block|{
name|assert
argument_list|(
operator|!
name|hasCachedDigest
argument_list|()
operator|&&
literal|"NoCachedDigest flag already removed."
argument_list|)
expr_stmt|;
name|Left
operator|&=
operator|~
name|NoCachedDigest
expr_stmt|;
block|}
end_function

begin_comment
comment|/// setLeft - Changes the reference of the left subtree.  Used internally
end_comment

begin_comment
comment|///   by ImutAVLFactory.
end_comment

begin_function
name|void
name|setLeft
parameter_list|(
name|ImutAVLTree
modifier|*
name|NewLeft
parameter_list|)
block|{
name|assert
argument_list|(
name|isMutable
argument_list|()
operator|&&
literal|"Only a mutable tree can have its left subtree changed."
argument_list|)
expr_stmt|;
name|Left
operator|=
name|reinterpret_cast
operator|<
name|uintptr_t
operator|>
operator|(
name|NewLeft
operator|)
operator||
name|LeftFlags
expr_stmt|;
block|}
end_function

begin_comment
comment|/// setRight - Changes the reference of the right subtree.  Used internally
end_comment

begin_comment
comment|///  by ImutAVLFactory.
end_comment

begin_function
name|void
name|setRight
parameter_list|(
name|ImutAVLTree
modifier|*
name|NewRight
parameter_list|)
block|{
name|assert
argument_list|(
name|isMutable
argument_list|()
operator|&&
literal|"Only a mutable tree can have its right subtree changed."
argument_list|)
expr_stmt|;
name|Right
operator|=
name|NewRight
expr_stmt|;
comment|// Set the NoCachedDigest flag.
name|Left
operator|=
name|Left
operator||
name|NoCachedDigest
expr_stmt|;
block|}
end_function

begin_comment
comment|/// setHeight - Changes the height of the tree.  Used internally by
end_comment

begin_comment
comment|///  ImutAVLFactory.
end_comment

begin_function
name|void
name|setHeight
parameter_list|(
name|unsigned
name|h
parameter_list|)
block|{
name|assert
argument_list|(
name|isMutable
argument_list|()
operator|&&
literal|"Only a mutable tree can have its height changed."
argument_list|)
expr_stmt|;
name|Height
operator|=
name|h
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|uint32_t
name|ComputeDigest
parameter_list|(
name|ImutAVLTree
modifier|*
name|L
parameter_list|,
name|ImutAVLTree
modifier|*
name|R
parameter_list|,
name|value_type_ref
name|V
parameter_list|)
block|{
name|uint32_t
name|digest
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|L
condition|)
name|digest
operator|+=
name|L
operator|->
name|ComputeDigest
argument_list|()
expr_stmt|;
comment|// Compute digest of stored data.
name|FoldingSetNodeID
name|ID
decl_stmt|;
name|ImutInfo
operator|::
name|Profile
argument_list|(
name|ID
argument_list|,
name|V
argument_list|)
expr_stmt|;
name|digest
operator|+=
name|ID
operator|.
name|ComputeHash
argument_list|()
expr_stmt|;
if|if
condition|(
name|R
condition|)
name|digest
operator|+=
name|R
operator|->
name|ComputeDigest
argument_list|()
expr_stmt|;
return|return
name|digest
return|;
block|}
end_function

begin_function
specifier|inline
name|uint32_t
name|ComputeDigest
parameter_list|()
block|{
comment|// Check the lowest bit to determine if digest has actually been
comment|// pre-computed.
if|if
condition|(
name|hasCachedDigest
argument_list|()
condition|)
return|return
name|Digest
return|;
name|uint32_t
name|X
init|=
name|ComputeDigest
argument_list|(
name|getLeft
argument_list|()
argument_list|,
name|getRight
argument_list|()
argument_list|,
name|getValue
argument_list|()
argument_list|)
decl_stmt|;
name|Digest
operator|=
name|X
expr_stmt|;
name|MarkedCachedDigest
argument_list|()
expr_stmt|;
return|return
name|X
return|;
block|}
end_function

begin_comment
unit|};
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|// Immutable AVL-Tree Factory class.
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_expr_stmt
name|template
operator|<
name|typename
name|ImutInfo
operator|>
name|class
name|ImutAVLFactory
block|{
typedef|typedef
name|ImutAVLTree
operator|<
name|ImutInfo
operator|>
name|TreeTy
expr_stmt|;
end_expr_stmt

begin_typedef
typedef|typedef
name|typename
name|TreeTy
operator|::
name|value_type_ref
name|value_type_ref
expr_stmt|;
end_typedef

begin_typedef
typedef|typedef
name|typename
name|TreeTy
operator|::
name|key_type_ref
name|key_type_ref
expr_stmt|;
end_typedef

begin_typedef
typedef|typedef
name|FoldingSet
operator|<
name|TreeTy
operator|>
name|CacheTy
expr_stmt|;
end_typedef

begin_decl_stmt
name|CacheTy
name|Cache
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|uintptr_t
name|Allocator
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|bool
name|ownsAllocator
argument_list|()
specifier|const
block|{
return|return
name|Allocator
operator|&
literal|0x1
operator|?
name|false
operator|:
name|true
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|BumpPtrAllocator
operator|&
name|getAllocator
argument_list|()
specifier|const
block|{
return|return
operator|*
name|reinterpret_cast
operator|<
name|BumpPtrAllocator
operator|*
operator|>
operator|(
name|Allocator
operator|&
operator|~
literal|0x1
operator|)
return|;
block|}
end_expr_stmt

begin_comment
comment|//===--------------------------------------------------===//
end_comment

begin_comment
comment|// Public interface.
end_comment

begin_comment
comment|//===--------------------------------------------------===//
end_comment

begin_label
name|public
label|:
end_label

begin_expr_stmt
name|ImutAVLFactory
argument_list|()
operator|:
name|Allocator
argument_list|(
argument|reinterpret_cast<uintptr_t>(new BumpPtrAllocator())
argument_list|)
block|{}
name|ImutAVLFactory
argument_list|(
name|BumpPtrAllocator
operator|&
name|Alloc
argument_list|)
operator|:
name|Allocator
argument_list|(
argument|reinterpret_cast<uintptr_t>(&Alloc) |
literal|0x1
argument_list|)
block|{}
operator|~
name|ImutAVLFactory
argument_list|()
block|{
if|if
condition|(
name|ownsAllocator
argument_list|()
condition|)
name|delete
modifier|&
name|getAllocator
parameter_list|()
function_decl|;
block|}
end_expr_stmt

begin_function
name|TreeTy
modifier|*
name|Add
parameter_list|(
name|TreeTy
modifier|*
name|T
parameter_list|,
name|value_type_ref
name|V
parameter_list|)
block|{
name|T
operator|=
name|Add_internal
argument_list|(
name|V
argument_list|,
name|T
argument_list|)
expr_stmt|;
name|MarkImmutable
argument_list|(
name|T
argument_list|)
expr_stmt|;
return|return
name|T
return|;
block|}
end_function

begin_function
name|TreeTy
modifier|*
name|Remove
parameter_list|(
name|TreeTy
modifier|*
name|T
parameter_list|,
name|key_type_ref
name|V
parameter_list|)
block|{
name|T
operator|=
name|Remove_internal
argument_list|(
name|V
argument_list|,
name|T
argument_list|)
expr_stmt|;
name|MarkImmutable
argument_list|(
name|T
argument_list|)
expr_stmt|;
return|return
name|T
return|;
block|}
end_function

begin_expr_stmt
name|TreeTy
operator|*
name|GetEmptyTree
argument_list|()
specifier|const
block|{
return|return
name|NULL
return|;
block|}
end_expr_stmt

begin_comment
comment|//===--------------------------------------------------===//
end_comment

begin_comment
comment|// A bunch of quick helper functions used for reasoning
end_comment

begin_comment
comment|// about the properties of trees and their children.
end_comment

begin_comment
comment|// These have succinct names so that the balancing code
end_comment

begin_comment
comment|// is as terse (and readable) as possible.
end_comment

begin_comment
comment|//===--------------------------------------------------===//
end_comment

begin_label
name|private
label|:
end_label

begin_decl_stmt
name|bool
name|isEmpty
argument_list|(
name|TreeTy
operator|*
name|T
argument_list|)
decl|const
block|{
return|return
operator|!
name|T
return|;
block|}
end_decl_stmt

begin_decl_stmt
name|unsigned
name|Height
argument_list|(
name|TreeTy
operator|*
name|T
argument_list|)
decl|const
block|{
return|return
name|T
condition|?
name|T
operator|->
name|getHeight
argument_list|()
else|:
literal|0
return|;
block|}
end_decl_stmt

begin_decl_stmt
name|TreeTy
modifier|*
name|Left
argument_list|(
name|TreeTy
operator|*
name|T
argument_list|)
decl|const
block|{
return|return
name|T
operator|->
name|getLeft
argument_list|()
return|;
block|}
end_decl_stmt

begin_decl_stmt
name|TreeTy
modifier|*
name|Right
argument_list|(
name|TreeTy
operator|*
name|T
argument_list|)
decl|const
block|{
return|return
name|T
operator|->
name|getRight
argument_list|()
return|;
block|}
end_decl_stmt

begin_decl_stmt
name|value_type_ref
name|Value
argument_list|(
name|TreeTy
operator|*
name|T
argument_list|)
decl|const
block|{
return|return
name|T
operator|->
name|Value
return|;
block|}
end_decl_stmt

begin_decl_stmt
name|unsigned
name|IncrementHeight
argument_list|(
name|TreeTy
operator|*
name|L
argument_list|,
name|TreeTy
operator|*
name|R
argument_list|)
decl|const
block|{
name|unsigned
name|hl
init|=
name|Height
argument_list|(
name|L
argument_list|)
decl_stmt|;
name|unsigned
name|hr
init|=
name|Height
argument_list|(
name|R
argument_list|)
decl_stmt|;
return|return
operator|(
name|hl
operator|>
name|hr
condition|?
name|hl
else|:
name|hr
operator|)
operator|+
literal|1
return|;
block|}
end_decl_stmt

begin_decl_stmt
specifier|static
name|bool
name|CompareTreeWithSection
argument_list|(
name|TreeTy
operator|*
name|T
argument_list|,
name|typename
name|TreeTy
operator|::
name|iterator
operator|&
name|TI
argument_list|,
name|typename
name|TreeTy
operator|::
name|iterator
operator|&
name|TE
argument_list|)
block|{
name|typename
name|TreeTy
operator|::
name|iterator
name|I
operator|=
name|T
operator|->
name|begin
argument_list|()
operator|,
name|E
operator|=
name|T
operator|->
name|end
argument_list|()
expr_stmt|;
for|for
control|(
init|;
name|I
operator|!=
name|E
condition|;
operator|++
name|I
operator|,
operator|++
name|TI
control|)
if|if
condition|(
name|TI
operator|==
name|TE
operator|||
operator|!
name|I
operator|->
name|ElementEqual
argument_list|(
operator|*
name|TI
argument_list|)
condition|)
return|return
name|false
return|;
return|return
name|true
return|;
block|}
end_decl_stmt

begin_comment
comment|//===--------------------------------------------------===//
end_comment

begin_comment
comment|// "CreateNode" is used to generate new tree roots that link
end_comment

begin_comment
comment|// to other trees.  The functon may also simply move links
end_comment

begin_comment
comment|// in an existing root if that root is still marked mutable.
end_comment

begin_comment
comment|// This is necessary because otherwise our balancing code
end_comment

begin_comment
comment|// would leak memory as it would create nodes that are
end_comment

begin_comment
comment|// then discarded later before the finished tree is
end_comment

begin_comment
comment|// returned to the caller.
end_comment

begin_comment
comment|//===--------------------------------------------------===//
end_comment

begin_function
name|TreeTy
modifier|*
name|CreateNode
parameter_list|(
name|TreeTy
modifier|*
name|L
parameter_list|,
name|value_type_ref
name|V
parameter_list|,
name|TreeTy
modifier|*
name|R
parameter_list|)
block|{
name|BumpPtrAllocator
modifier|&
name|A
init|=
name|getAllocator
argument_list|()
decl_stmt|;
name|TreeTy
modifier|*
name|T
init|=
operator|(
name|TreeTy
operator|*
operator|)
name|A
operator|.
name|Allocate
operator|<
name|TreeTy
operator|>
operator|(
operator|)
decl_stmt|;
name|new
argument_list|(
argument|T
argument_list|)
name|TreeTy
argument_list|(
name|L
argument_list|,
name|R
argument_list|,
name|V
argument_list|,
name|IncrementHeight
argument_list|(
name|L
argument_list|,
name|R
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|T
return|;
block|}
end_function

begin_function
name|TreeTy
modifier|*
name|CreateNode
parameter_list|(
name|TreeTy
modifier|*
name|L
parameter_list|,
name|TreeTy
modifier|*
name|OldTree
parameter_list|,
name|TreeTy
modifier|*
name|R
parameter_list|)
block|{
name|assert
argument_list|(
operator|!
name|isEmpty
argument_list|(
name|OldTree
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|OldTree
operator|->
name|isMutable
argument_list|()
condition|)
block|{
name|OldTree
operator|->
name|setLeft
argument_list|(
name|L
argument_list|)
expr_stmt|;
name|OldTree
operator|->
name|setRight
argument_list|(
name|R
argument_list|)
expr_stmt|;
name|OldTree
operator|->
name|setHeight
argument_list|(
name|IncrementHeight
argument_list|(
name|L
argument_list|,
name|R
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|OldTree
return|;
block|}
else|else
return|return
name|CreateNode
argument_list|(
name|L
argument_list|,
name|Value
argument_list|(
name|OldTree
argument_list|)
argument_list|,
name|R
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/// Balance - Used by Add_internal and Remove_internal to
end_comment

begin_comment
comment|///  balance a newly created tree.
end_comment

begin_function
name|TreeTy
modifier|*
name|Balance
parameter_list|(
name|TreeTy
modifier|*
name|L
parameter_list|,
name|value_type_ref
name|V
parameter_list|,
name|TreeTy
modifier|*
name|R
parameter_list|)
block|{
name|unsigned
name|hl
init|=
name|Height
argument_list|(
name|L
argument_list|)
decl_stmt|;
name|unsigned
name|hr
init|=
name|Height
argument_list|(
name|R
argument_list|)
decl_stmt|;
if|if
condition|(
name|hl
operator|>
name|hr
operator|+
literal|2
condition|)
block|{
name|assert
argument_list|(
operator|!
name|isEmpty
argument_list|(
name|L
argument_list|)
operator|&&
literal|"Left tree cannot be empty to have a height>= 2."
argument_list|)
expr_stmt|;
name|TreeTy
modifier|*
name|LL
init|=
name|Left
argument_list|(
name|L
argument_list|)
decl_stmt|;
name|TreeTy
modifier|*
name|LR
init|=
name|Right
argument_list|(
name|L
argument_list|)
decl_stmt|;
if|if
condition|(
name|Height
argument_list|(
name|LL
argument_list|)
operator|>=
name|Height
argument_list|(
name|LR
argument_list|)
condition|)
return|return
name|CreateNode
argument_list|(
name|LL
argument_list|,
name|L
argument_list|,
name|CreateNode
argument_list|(
name|LR
argument_list|,
name|V
argument_list|,
name|R
argument_list|)
argument_list|)
return|;
name|assert
argument_list|(
operator|!
name|isEmpty
argument_list|(
name|LR
argument_list|)
operator|&&
literal|"LR cannot be empty because it has a height>= 1."
argument_list|)
expr_stmt|;
name|TreeTy
modifier|*
name|LRL
init|=
name|Left
argument_list|(
name|LR
argument_list|)
decl_stmt|;
name|TreeTy
modifier|*
name|LRR
init|=
name|Right
argument_list|(
name|LR
argument_list|)
decl_stmt|;
return|return
name|CreateNode
argument_list|(
name|CreateNode
argument_list|(
name|LL
argument_list|,
name|L
argument_list|,
name|LRL
argument_list|)
argument_list|,
name|LR
argument_list|,
name|CreateNode
argument_list|(
name|LRR
argument_list|,
name|V
argument_list|,
name|R
argument_list|)
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|hr
operator|>
name|hl
operator|+
literal|2
condition|)
block|{
name|assert
argument_list|(
operator|!
name|isEmpty
argument_list|(
name|R
argument_list|)
operator|&&
literal|"Right tree cannot be empty to have a height>= 2."
argument_list|)
expr_stmt|;
name|TreeTy
modifier|*
name|RL
init|=
name|Left
argument_list|(
name|R
argument_list|)
decl_stmt|;
name|TreeTy
modifier|*
name|RR
init|=
name|Right
argument_list|(
name|R
argument_list|)
decl_stmt|;
if|if
condition|(
name|Height
argument_list|(
name|RR
argument_list|)
operator|>=
name|Height
argument_list|(
name|RL
argument_list|)
condition|)
return|return
name|CreateNode
argument_list|(
name|CreateNode
argument_list|(
name|L
argument_list|,
name|V
argument_list|,
name|RL
argument_list|)
argument_list|,
name|R
argument_list|,
name|RR
argument_list|)
return|;
name|assert
argument_list|(
operator|!
name|isEmpty
argument_list|(
name|RL
argument_list|)
operator|&&
literal|"RL cannot be empty because it has a height>= 1."
argument_list|)
expr_stmt|;
name|TreeTy
modifier|*
name|RLL
init|=
name|Left
argument_list|(
name|RL
argument_list|)
decl_stmt|;
name|TreeTy
modifier|*
name|RLR
init|=
name|Right
argument_list|(
name|RL
argument_list|)
decl_stmt|;
return|return
name|CreateNode
argument_list|(
name|CreateNode
argument_list|(
name|L
argument_list|,
name|V
argument_list|,
name|RLL
argument_list|)
argument_list|,
name|RL
argument_list|,
name|CreateNode
argument_list|(
name|RLR
argument_list|,
name|R
argument_list|,
name|RR
argument_list|)
argument_list|)
return|;
block|}
else|else
return|return
name|CreateNode
argument_list|(
name|L
argument_list|,
name|V
argument_list|,
name|R
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/// Add_internal - Creates a new tree that includes the specified
end_comment

begin_comment
comment|///  data and the data from the original tree.  If the original tree
end_comment

begin_comment
comment|///  already contained the data item, the original tree is returned.
end_comment

begin_function
name|TreeTy
modifier|*
name|Add_internal
parameter_list|(
name|value_type_ref
name|V
parameter_list|,
name|TreeTy
modifier|*
name|T
parameter_list|)
block|{
if|if
condition|(
name|isEmpty
argument_list|(
name|T
argument_list|)
condition|)
return|return
name|CreateNode
argument_list|(
name|T
argument_list|,
name|V
argument_list|,
name|T
argument_list|)
return|;
name|assert
argument_list|(
operator|!
name|T
operator|->
name|isMutable
argument_list|()
argument_list|)
expr_stmt|;
name|key_type_ref
name|K
init|=
name|ImutInfo
operator|::
name|KeyOfValue
argument_list|(
name|V
argument_list|)
decl_stmt|;
name|key_type_ref
name|KCurrent
init|=
name|ImutInfo
operator|::
name|KeyOfValue
argument_list|(
name|Value
argument_list|(
name|T
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|ImutInfo
operator|::
name|isEqual
argument_list|(
name|K
argument_list|,
name|KCurrent
argument_list|)
condition|)
return|return
name|CreateNode
argument_list|(
name|Left
argument_list|(
name|T
argument_list|)
argument_list|,
name|V
argument_list|,
name|Right
argument_list|(
name|T
argument_list|)
argument_list|)
return|;
elseif|else
if|if
condition|(
name|ImutInfo
operator|::
name|isLess
argument_list|(
name|K
argument_list|,
name|KCurrent
argument_list|)
condition|)
return|return
name|Balance
argument_list|(
name|Add_internal
argument_list|(
name|V
argument_list|,
name|Left
argument_list|(
name|T
argument_list|)
argument_list|)
argument_list|,
name|Value
argument_list|(
name|T
argument_list|)
argument_list|,
name|Right
argument_list|(
name|T
argument_list|)
argument_list|)
return|;
else|else
return|return
name|Balance
argument_list|(
name|Left
argument_list|(
name|T
argument_list|)
argument_list|,
name|Value
argument_list|(
name|T
argument_list|)
argument_list|,
name|Add_internal
argument_list|(
name|V
argument_list|,
name|Right
argument_list|(
name|T
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/// Remove_internal - Creates a new tree that includes all the data
end_comment

begin_comment
comment|///  from the original tree except the specified data.  If the
end_comment

begin_comment
comment|///  specified data did not exist in the original tree, the original
end_comment

begin_comment
comment|///  tree is returned.
end_comment

begin_function
name|TreeTy
modifier|*
name|Remove_internal
parameter_list|(
name|key_type_ref
name|K
parameter_list|,
name|TreeTy
modifier|*
name|T
parameter_list|)
block|{
if|if
condition|(
name|isEmpty
argument_list|(
name|T
argument_list|)
condition|)
return|return
name|T
return|;
name|assert
argument_list|(
operator|!
name|T
operator|->
name|isMutable
argument_list|()
argument_list|)
expr_stmt|;
name|key_type_ref
name|KCurrent
init|=
name|ImutInfo
operator|::
name|KeyOfValue
argument_list|(
name|Value
argument_list|(
name|T
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|ImutInfo
operator|::
name|isEqual
argument_list|(
name|K
argument_list|,
name|KCurrent
argument_list|)
condition|)
return|return
name|CombineLeftRightTrees
argument_list|(
name|Left
argument_list|(
name|T
argument_list|)
argument_list|,
name|Right
argument_list|(
name|T
argument_list|)
argument_list|)
return|;
elseif|else
if|if
condition|(
name|ImutInfo
operator|::
name|isLess
argument_list|(
name|K
argument_list|,
name|KCurrent
argument_list|)
condition|)
return|return
name|Balance
argument_list|(
name|Remove_internal
argument_list|(
name|K
argument_list|,
name|Left
argument_list|(
name|T
argument_list|)
argument_list|)
argument_list|,
name|Value
argument_list|(
name|T
argument_list|)
argument_list|,
name|Right
argument_list|(
name|T
argument_list|)
argument_list|)
return|;
else|else
return|return
name|Balance
argument_list|(
name|Left
argument_list|(
name|T
argument_list|)
argument_list|,
name|Value
argument_list|(
name|T
argument_list|)
argument_list|,
name|Remove_internal
argument_list|(
name|K
argument_list|,
name|Right
argument_list|(
name|T
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|TreeTy
modifier|*
name|CombineLeftRightTrees
parameter_list|(
name|TreeTy
modifier|*
name|L
parameter_list|,
name|TreeTy
modifier|*
name|R
parameter_list|)
block|{
if|if
condition|(
name|isEmpty
argument_list|(
name|L
argument_list|)
condition|)
return|return
name|R
return|;
if|if
condition|(
name|isEmpty
argument_list|(
name|R
argument_list|)
condition|)
return|return
name|L
return|;
name|TreeTy
modifier|*
name|OldNode
decl_stmt|;
name|TreeTy
modifier|*
name|NewRight
init|=
name|RemoveMinBinding
argument_list|(
name|R
argument_list|,
name|OldNode
argument_list|)
decl_stmt|;
return|return
name|Balance
argument_list|(
name|L
argument_list|,
name|Value
argument_list|(
name|OldNode
argument_list|)
argument_list|,
name|NewRight
argument_list|)
return|;
block|}
end_function

begin_function
name|TreeTy
modifier|*
name|RemoveMinBinding
parameter_list|(
name|TreeTy
modifier|*
name|T
parameter_list|,
name|TreeTy
modifier|*
modifier|&
name|NodeRemoved
parameter_list|)
block|{
name|assert
argument_list|(
operator|!
name|isEmpty
argument_list|(
name|T
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|isEmpty
argument_list|(
name|Left
argument_list|(
name|T
argument_list|)
argument_list|)
condition|)
block|{
name|NodeRemoved
operator|=
name|T
expr_stmt|;
return|return
name|Right
argument_list|(
name|T
argument_list|)
return|;
block|}
return|return
name|Balance
argument_list|(
name|RemoveMinBinding
argument_list|(
name|Left
argument_list|(
name|T
argument_list|)
argument_list|,
name|NodeRemoved
argument_list|)
argument_list|,
name|Value
argument_list|(
name|T
argument_list|)
argument_list|,
name|Right
argument_list|(
name|T
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/// MarkImmutable - Clears the mutable bits of a root and all of its
end_comment

begin_comment
comment|///  descendants.
end_comment

begin_function
name|void
name|MarkImmutable
parameter_list|(
name|TreeTy
modifier|*
name|T
parameter_list|)
block|{
if|if
condition|(
operator|!
name|T
operator|||
operator|!
name|T
operator|->
name|isMutable
argument_list|()
condition|)
return|return;
name|T
operator|->
name|MarkImmutable
argument_list|()
expr_stmt|;
name|MarkImmutable
argument_list|(
name|Left
argument_list|(
name|T
argument_list|)
argument_list|)
expr_stmt|;
name|MarkImmutable
argument_list|(
name|Right
argument_list|(
name|T
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_label
name|public
label|:
end_label

begin_function
name|TreeTy
modifier|*
name|GetCanonicalTree
parameter_list|(
name|TreeTy
modifier|*
name|TNew
parameter_list|)
block|{
if|if
condition|(
operator|!
name|TNew
condition|)
return|return
name|NULL
return|;
comment|// Search the FoldingSet bucket for a Tree with the same digest.
name|FoldingSetNodeID
name|ID
decl_stmt|;
name|unsigned
name|digest
init|=
name|TNew
operator|->
name|ComputeDigest
argument_list|()
decl_stmt|;
name|ID
operator|.
name|AddInteger
argument_list|(
name|digest
argument_list|)
expr_stmt|;
name|unsigned
name|hash
init|=
name|ID
operator|.
name|ComputeHash
argument_list|()
decl_stmt|;
name|typename
name|CacheTy
operator|::
name|bucket_iterator
name|I
operator|=
name|Cache
operator|.
name|bucket_begin
argument_list|(
name|hash
argument_list|)
expr_stmt|;
name|typename
name|CacheTy
operator|::
name|bucket_iterator
name|E
operator|=
name|Cache
operator|.
name|bucket_end
argument_list|(
name|hash
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|I
operator|!=
name|E
condition|;
operator|++
name|I
control|)
block|{
name|TreeTy
modifier|*
name|T
init|=
operator|&
operator|*
name|I
decl_stmt|;
if|if
condition|(
name|T
operator|->
name|ComputeDigest
argument_list|()
operator|!=
name|digest
condition|)
continue|continue;
comment|// We found a collision.  Perform a comparison of Contents('T')
comment|// with Contents('L')+'V'+Contents('R').
name|typename
name|TreeTy
operator|::
name|iterator
name|TI
operator|=
name|T
operator|->
name|begin
argument_list|()
operator|,
name|TE
operator|=
name|T
operator|->
name|end
argument_list|()
expr_stmt|;
comment|// First compare Contents('L') with the (initial) contents of T.
if|if
condition|(
operator|!
name|CompareTreeWithSection
argument_list|(
name|TNew
operator|->
name|getLeft
argument_list|()
argument_list|,
name|TI
argument_list|,
name|TE
argument_list|)
condition|)
continue|continue;
comment|// Now compare the new data element.
if|if
condition|(
name|TI
operator|==
name|TE
operator|||
operator|!
name|TI
operator|->
name|ElementEqual
argument_list|(
name|TNew
operator|->
name|getValue
argument_list|()
argument_list|)
condition|)
continue|continue;
operator|++
name|TI
expr_stmt|;
comment|// Now compare the remainder of 'T' with 'R'.
if|if
condition|(
operator|!
name|CompareTreeWithSection
argument_list|(
name|TNew
operator|->
name|getRight
argument_list|()
argument_list|,
name|TI
argument_list|,
name|TE
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|TI
operator|!=
name|TE
condition|)
continue|continue;
comment|// Contents('R') did not match suffix of 'T'.
comment|// Trees did match!  Return 'T'.
return|return
name|T
return|;
block|}
comment|// 'TNew' is the only tree of its kind.  Return it.
name|Cache
operator|.
name|InsertNode
argument_list|(
name|TNew
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
operator|*
name|Cache
operator|.
name|bucket_end
argument_list|(
name|hash
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|TNew
return|;
block|}
end_function

begin_comment
unit|};
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|// Immutable AVL-Tree Iterators.
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_expr_stmt
name|template
operator|<
name|typename
name|ImutInfo
operator|>
name|class
name|ImutAVLTreeGenericIterator
block|{
name|SmallVector
operator|<
name|uintptr_t
block|,
literal|20
operator|>
name|stack
block|;
name|public
operator|:
expr|enum
name|VisitFlag
block|{
name|VisitedNone
operator|=
literal|0x0
block|,
name|VisitedLeft
operator|=
literal|0x1
block|,
name|VisitedRight
operator|=
literal|0x3
block|,
name|Flags
operator|=
literal|0x3
block|}
block|;
typedef|typedef
name|ImutAVLTree
operator|<
name|ImutInfo
operator|>
name|TreeTy
expr_stmt|;
end_expr_stmt

begin_typedef
typedef|typedef
name|ImutAVLTreeGenericIterator
operator|<
name|ImutInfo
operator|>
name|_Self
expr_stmt|;
end_typedef

begin_expr_stmt
specifier|inline
name|ImutAVLTreeGenericIterator
argument_list|()
block|{}
specifier|inline
name|ImutAVLTreeGenericIterator
argument_list|(
argument|const TreeTy* Root
argument_list|)
block|{
if|if
condition|(
name|Root
condition|)
name|stack
operator|.
name|push_back
argument_list|(
name|reinterpret_cast
operator|<
name|uintptr_t
operator|>
operator|(
name|Root
operator|)
argument_list|)
expr_stmt|;
block|}
end_expr_stmt

begin_expr_stmt
name|TreeTy
operator|*
name|operator
operator|*
operator|(
operator|)
specifier|const
block|{
name|assert
argument_list|(
operator|!
name|stack
operator|.
name|empty
argument_list|()
argument_list|)
block|;
return|return
name|reinterpret_cast
operator|<
name|TreeTy
operator|*
operator|>
operator|(
name|stack
operator|.
name|back
argument_list|()
operator|&
operator|~
name|Flags
operator|)
return|;
block|}
end_expr_stmt

begin_function
name|uintptr_t
name|getVisitState
parameter_list|()
block|{
name|assert
argument_list|(
operator|!
name|stack
operator|.
name|empty
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|stack
operator|.
name|back
argument_list|()
operator|&
name|Flags
return|;
block|}
end_function

begin_expr_stmt
name|bool
name|AtEnd
argument_list|()
specifier|const
block|{
return|return
name|stack
operator|.
name|empty
argument_list|()
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|bool
name|AtBeginning
argument_list|()
specifier|const
block|{
return|return
name|stack
operator|.
name|size
argument_list|()
operator|==
literal|1
operator|&&
name|getVisitState
argument_list|()
operator|==
name|VisitedNone
return|;
block|}
end_expr_stmt

begin_function
name|void
name|SkipToParent
parameter_list|()
block|{
name|assert
argument_list|(
operator|!
name|stack
operator|.
name|empty
argument_list|()
argument_list|)
expr_stmt|;
name|stack
operator|.
name|pop_back
argument_list|()
expr_stmt|;
if|if
condition|(
name|stack
operator|.
name|empty
argument_list|()
condition|)
return|return;
switch|switch
condition|(
name|getVisitState
argument_list|()
condition|)
block|{
case|case
name|VisitedNone
case|:
name|stack
operator|.
name|back
argument_list|()
operator||=
name|VisitedLeft
expr_stmt|;
break|break;
case|case
name|VisitedLeft
case|:
name|stack
operator|.
name|back
argument_list|()
operator||=
name|VisitedRight
expr_stmt|;
break|break;
default|default:
name|assert
argument_list|(
name|false
operator|&&
literal|"Unreachable."
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_expr_stmt
specifier|inline
name|bool
name|operator
operator|==
operator|(
specifier|const
name|_Self
operator|&
name|x
operator|)
specifier|const
block|{
if|if
condition|(
name|stack
operator|.
name|size
argument_list|()
operator|!=
name|x
operator|.
name|stack
operator|.
name|size
argument_list|()
condition|)
return|return
name|false
return|;
end_expr_stmt

begin_for
for|for
control|(
name|unsigned
name|i
init|=
literal|0
init|;
name|i
operator|<
name|stack
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|stack
index|[
name|i
index|]
operator|!=
name|x
operator|.
name|stack
index|[
name|i
index|]
condition|)
return|return
name|false
return|;
end_for

begin_return
return|return
name|true
return|;
end_return

begin_expr_stmt
unit|}    inline
name|bool
name|operator
operator|!=
operator|(
specifier|const
name|_Self
operator|&
name|x
operator|)
specifier|const
block|{
return|return
operator|!
name|operator
operator|==
operator|(
name|x
operator|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|_Self
operator|&
name|operator
operator|++
operator|(
operator|)
block|{
name|assert
argument_list|(
operator|!
name|stack
operator|.
name|empty
argument_list|()
argument_list|)
block|;
name|TreeTy
operator|*
name|Current
operator|=
name|reinterpret_cast
operator|<
name|TreeTy
operator|*
operator|>
operator|(
name|stack
operator|.
name|back
argument_list|()
operator|&
operator|~
name|Flags
operator|)
block|;
name|assert
argument_list|(
name|Current
argument_list|)
block|;
switch|switch
condition|(
name|getVisitState
argument_list|()
condition|)
block|{
case|case
name|VisitedNone
case|:
if|if
condition|(
name|TreeTy
modifier|*
name|L
init|=
name|Current
operator|->
name|getLeft
argument_list|()
condition|)
name|stack
operator|.
name|push_back
argument_list|(
name|reinterpret_cast
operator|<
name|uintptr_t
operator|>
operator|(
name|L
operator|)
argument_list|)
expr_stmt|;
else|else
name|stack
operator|.
name|back
argument_list|()
operator||=
name|VisitedLeft
expr_stmt|;
break|break;
case|case
name|VisitedLeft
case|:
if|if
condition|(
name|TreeTy
modifier|*
name|R
init|=
name|Current
operator|->
name|getRight
argument_list|()
condition|)
name|stack
operator|.
name|push_back
argument_list|(
name|reinterpret_cast
operator|<
name|uintptr_t
operator|>
operator|(
name|R
operator|)
argument_list|)
expr_stmt|;
else|else
name|stack
operator|.
name|back
argument_list|()
operator||=
name|VisitedRight
expr_stmt|;
break|break;
case|case
name|VisitedRight
case|:
name|SkipToParent
argument_list|()
expr_stmt|;
break|break;
default|default:
name|assert
argument_list|(
name|false
operator|&&
literal|"Unreachable."
argument_list|)
expr_stmt|;
block|}
end_expr_stmt

begin_return
return|return
operator|*
name|this
return|;
end_return

begin_expr_stmt
unit|}    _Self
operator|&
name|operator
operator|--
operator|(
operator|)
block|{
name|assert
argument_list|(
operator|!
name|stack
operator|.
name|empty
argument_list|()
argument_list|)
block|;
name|TreeTy
operator|*
name|Current
operator|=
name|reinterpret_cast
operator|<
name|TreeTy
operator|*
operator|>
operator|(
name|stack
operator|.
name|back
argument_list|()
operator|&
operator|~
name|Flags
operator|)
block|;
name|assert
argument_list|(
name|Current
argument_list|)
block|;
switch|switch
condition|(
name|getVisitState
argument_list|()
condition|)
block|{
case|case
name|VisitedNone
case|:
name|stack
operator|.
name|pop_back
argument_list|()
expr_stmt|;
break|break;
case|case
name|VisitedLeft
case|:
name|stack
operator|.
name|back
argument_list|()
operator|&=
operator|~
name|Flags
expr_stmt|;
comment|// Set state to "VisitedNone."
if|if
condition|(
name|TreeTy
modifier|*
name|L
init|=
name|Current
operator|->
name|getLeft
argument_list|()
condition|)
name|stack
operator|.
name|push_back
argument_list|(
name|reinterpret_cast
operator|<
name|uintptr_t
operator|>
operator|(
name|L
operator|)
operator||
name|VisitedRight
argument_list|)
expr_stmt|;
break|break;
case|case
name|VisitedRight
case|:
name|stack
operator|.
name|back
argument_list|()
operator|&=
operator|~
name|Flags
expr_stmt|;
name|stack
operator|.
name|back
argument_list|()
operator||=
name|VisitedLeft
expr_stmt|;
if|if
condition|(
name|TreeTy
modifier|*
name|R
init|=
name|Current
operator|->
name|getRight
argument_list|()
condition|)
name|stack
operator|.
name|push_back
argument_list|(
name|reinterpret_cast
operator|<
name|uintptr_t
operator|>
operator|(
name|R
operator|)
operator||
name|VisitedRight
argument_list|)
expr_stmt|;
break|break;
default|default:
name|assert
argument_list|(
name|false
operator|&&
literal|"Unreachable."
argument_list|)
expr_stmt|;
block|}
end_expr_stmt

begin_return
return|return
operator|*
name|this
return|;
end_return

begin_empty_stmt
unit|} }
empty_stmt|;
end_empty_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|ImutInfo
operator|>
name|class
name|ImutAVLTreeInOrderIterator
block|{
typedef|typedef
name|ImutAVLTreeGenericIterator
operator|<
name|ImutInfo
operator|>
name|InternalIteratorTy
expr_stmt|;
name|InternalIteratorTy
name|InternalItr
expr_stmt|;
end_expr_stmt

begin_label
name|public
label|:
end_label

begin_typedef
typedef|typedef
name|ImutAVLTree
operator|<
name|ImutInfo
operator|>
name|TreeTy
expr_stmt|;
end_typedef

begin_typedef
typedef|typedef
name|ImutAVLTreeInOrderIterator
operator|<
name|ImutInfo
operator|>
name|_Self
expr_stmt|;
end_typedef

begin_expr_stmt
name|ImutAVLTreeInOrderIterator
argument_list|(
specifier|const
name|TreeTy
operator|*
name|Root
argument_list|)
operator|:
name|InternalItr
argument_list|(
argument|Root
argument_list|)
block|{
if|if
condition|(
name|Root
condition|)
name|operator
operator|++
operator|(
operator|)
expr_stmt|;
comment|// Advance to first element.
block|}
end_expr_stmt

begin_expr_stmt
name|ImutAVLTreeInOrderIterator
argument_list|()
operator|:
name|InternalItr
argument_list|()
block|{}
specifier|inline
name|bool
name|operator
operator|==
operator|(
specifier|const
name|_Self
operator|&
name|x
operator|)
specifier|const
block|{
return|return
name|InternalItr
operator|==
name|x
operator|.
name|InternalItr
return|;
block|}
end_expr_stmt

begin_expr_stmt
specifier|inline
name|bool
name|operator
operator|!=
operator|(
specifier|const
name|_Self
operator|&
name|x
operator|)
specifier|const
block|{
return|return
operator|!
name|operator
operator|==
operator|(
name|x
operator|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
specifier|inline
name|TreeTy
operator|*
name|operator
operator|*
operator|(
operator|)
specifier|const
block|{
return|return
operator|*
name|InternalItr
return|;
block|}
end_expr_stmt

begin_expr_stmt
specifier|inline
name|TreeTy
operator|*
name|operator
operator|->
expr|(
end_expr_stmt

begin_expr_stmt
unit|)
specifier|const
block|{
return|return
operator|*
name|InternalItr
return|;
block|}
end_expr_stmt

begin_expr_stmt
specifier|inline
name|_Self
operator|&
name|operator
operator|++
operator|(
operator|)
block|{
do|do
operator|++
name|InternalItr
expr_stmt|;
do|while
condition|(
operator|!
name|InternalItr
operator|.
name|AtEnd
argument_list|()
operator|&&
name|InternalItr
operator|.
name|getVisitState
argument_list|()
operator|!=
name|InternalIteratorTy
operator|::
name|VisitedLeft
condition|)
do|;
end_expr_stmt

begin_return
return|return
operator|*
name|this
return|;
end_return

begin_expr_stmt
unit|}    inline
name|_Self
operator|&
name|operator
operator|--
operator|(
operator|)
block|{
do|do
operator|--
name|InternalItr
expr_stmt|;
do|while
condition|(
operator|!
name|InternalItr
operator|.
name|AtBeginning
argument_list|()
operator|&&
name|InternalItr
operator|.
name|getVisitState
argument_list|()
operator|!=
name|InternalIteratorTy
operator|::
name|VisitedLeft
condition|)
do|;
end_expr_stmt

begin_return
return|return
operator|*
name|this
return|;
end_return

begin_function
unit|}    inline
name|void
name|SkipSubTree
parameter_list|()
block|{
name|InternalItr
operator|.
name|SkipToParent
argument_list|()
expr_stmt|;
while|while
condition|(
operator|!
name|InternalItr
operator|.
name|AtEnd
argument_list|()
operator|&&
name|InternalItr
operator|.
name|getVisitState
argument_list|()
operator|!=
name|InternalIteratorTy
operator|::
name|VisitedLeft
condition|)
operator|++
name|InternalItr
expr_stmt|;
block|}
end_function

begin_comment
unit|};
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|// Trait classes for Profile information.
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|/// Generic profile template.  The default behavior is to invoke the
end_comment

begin_comment
comment|/// profile method of an object.  Specializations for primitive integers
end_comment

begin_comment
comment|/// and generic handling of pointers is done below.
end_comment

begin_expr_stmt
name|template
operator|<
name|typename
name|T
operator|>
expr|struct
name|ImutProfileInfo
block|{
typedef|typedef
specifier|const
name|T
name|value_type
typedef|;
end_expr_stmt

begin_typedef
typedef|typedef
specifier|const
name|T
modifier|&
name|value_type_ref
typedef|;
end_typedef

begin_function
specifier|static
specifier|inline
name|void
name|Profile
parameter_list|(
name|FoldingSetNodeID
modifier|&
name|ID
parameter_list|,
name|value_type_ref
name|X
parameter_list|)
block|{
name|FoldingSetTrait
operator|<
name|T
operator|>
operator|::
name|Profile
argument_list|(
name|X
argument_list|,
name|ID
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
unit|};
comment|/// Profile traits for integers.
end_comment

begin_expr_stmt
name|template
operator|<
name|typename
name|T
operator|>
expr|struct
name|ImutProfileInteger
block|{
typedef|typedef
specifier|const
name|T
name|value_type
typedef|;
end_expr_stmt

begin_typedef
typedef|typedef
specifier|const
name|T
modifier|&
name|value_type_ref
typedef|;
end_typedef

begin_function
specifier|static
specifier|inline
name|void
name|Profile
parameter_list|(
name|FoldingSetNodeID
modifier|&
name|ID
parameter_list|,
name|value_type_ref
name|X
parameter_list|)
block|{
name|ID
operator|.
name|AddInteger
argument_list|(
name|X
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
unit|};
define|#
directive|define
name|PROFILE_INTEGER_INFO
parameter_list|(
name|X
parameter_list|)
define|\
value|template<> struct ImutProfileInfo<X> : ImutProfileInteger<X> {};
end_define

begin_macro
name|PROFILE_INTEGER_INFO
argument_list|(
argument|char
argument_list|)
end_macro

begin_macro
name|PROFILE_INTEGER_INFO
argument_list|(
argument|unsigned char
argument_list|)
end_macro

begin_macro
name|PROFILE_INTEGER_INFO
argument_list|(
argument|short
argument_list|)
end_macro

begin_macro
name|PROFILE_INTEGER_INFO
argument_list|(
argument|unsigned short
argument_list|)
end_macro

begin_macro
name|PROFILE_INTEGER_INFO
argument_list|(
argument|unsigned
argument_list|)
end_macro

begin_macro
name|PROFILE_INTEGER_INFO
argument_list|(
argument|signed
argument_list|)
end_macro

begin_macro
name|PROFILE_INTEGER_INFO
argument_list|(
argument|long
argument_list|)
end_macro

begin_macro
name|PROFILE_INTEGER_INFO
argument_list|(
argument|unsigned long
argument_list|)
end_macro

begin_macro
name|PROFILE_INTEGER_INFO
argument_list|(
argument|long long
argument_list|)
end_macro

begin_macro
name|PROFILE_INTEGER_INFO
argument_list|(
argument|unsigned long long
argument_list|)
end_macro

begin_undef
undef|#
directive|undef
name|PROFILE_INTEGER_INFO
end_undef

begin_comment
comment|/// Generic profile trait for pointer types.  We treat pointers as
end_comment

begin_comment
comment|/// references to unique objects.
end_comment

begin_expr_stmt
name|template
operator|<
name|typename
name|T
operator|>
expr|struct
name|ImutProfileInfo
operator|<
name|T
operator|*
operator|>
block|{
typedef|typedef
specifier|const
name|T
modifier|*
name|value_type
typedef|;
end_expr_stmt

begin_typedef
typedef|typedef
name|value_type
name|value_type_ref
typedef|;
end_typedef

begin_function
specifier|static
specifier|inline
name|void
name|Profile
parameter_list|(
name|FoldingSetNodeID
modifier|&
name|ID
parameter_list|,
name|value_type_ref
name|X
parameter_list|)
block|{
name|ID
operator|.
name|AddPointer
argument_list|(
name|X
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
unit|};
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|// Trait classes that contain element comparison operators and type
end_comment

begin_comment
comment|//  definitions used by ImutAVLTree, ImmutableSet, and ImmutableMap.  These
end_comment

begin_comment
comment|//  inherit from the profile traits (ImutProfileInfo) to include operations
end_comment

begin_comment
comment|//  for element profiling.
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|/// ImutContainerInfo - Generic definition of comparison operations for
end_comment

begin_comment
comment|///   elements of immutable containers that defaults to using
end_comment

begin_comment
comment|///   std::equal_to<> and std::less<> to perform comparison of elements.
end_comment

begin_expr_stmt
name|template
operator|<
name|typename
name|T
operator|>
expr|struct
name|ImutContainerInfo
operator|:
name|public
name|ImutProfileInfo
operator|<
name|T
operator|>
block|{
typedef|typedef
name|typename
name|ImutProfileInfo
operator|<
name|T
operator|>
operator|::
name|value_type
name|value_type
expr_stmt|;
end_expr_stmt

begin_typedef
typedef|typedef
name|typename
name|ImutProfileInfo
operator|<
name|T
operator|>
operator|::
name|value_type_ref
name|value_type_ref
expr_stmt|;
end_typedef

begin_typedef
typedef|typedef
name|value_type
name|key_type
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|value_type_ref
name|key_type_ref
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|bool
name|data_type
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|bool
name|data_type_ref
typedef|;
end_typedef

begin_function
specifier|static
specifier|inline
name|key_type_ref
name|KeyOfValue
parameter_list|(
name|value_type_ref
name|D
parameter_list|)
block|{
return|return
name|D
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|data_type_ref
name|DataOfValue
parameter_list|(
name|value_type_ref
parameter_list|)
block|{
return|return
name|true
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|bool
name|isEqual
parameter_list|(
name|key_type_ref
name|LHS
parameter_list|,
name|key_type_ref
name|RHS
parameter_list|)
block|{
return|return
name|std
operator|::
name|equal_to
operator|<
name|key_type
operator|>
operator|(
operator|)
operator|(
name|LHS
operator|,
name|RHS
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|bool
name|isLess
parameter_list|(
name|key_type_ref
name|LHS
parameter_list|,
name|key_type_ref
name|RHS
parameter_list|)
block|{
return|return
name|std
operator|::
name|less
operator|<
name|key_type
operator|>
operator|(
operator|)
operator|(
name|LHS
operator|,
name|RHS
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|bool
name|isDataEqual
parameter_list|(
name|data_type_ref
parameter_list|,
name|data_type_ref
parameter_list|)
block|{
return|return
name|true
return|;
block|}
end_function

begin_comment
unit|};
comment|/// ImutContainerInfo - Specialization for pointer values to treat pointers
end_comment

begin_comment
comment|///  as references to unique objects.  Pointers are thus compared by
end_comment

begin_comment
comment|///  their addresses.
end_comment

begin_expr_stmt
name|template
operator|<
name|typename
name|T
operator|>
expr|struct
name|ImutContainerInfo
operator|<
name|T
operator|*
operator|>
operator|:
name|public
name|ImutProfileInfo
operator|<
name|T
operator|*
operator|>
block|{
typedef|typedef
name|typename
name|ImutProfileInfo
operator|<
name|T
operator|*
operator|>
operator|::
name|value_type
name|value_type
expr_stmt|;
end_expr_stmt

begin_typedef
typedef|typedef
name|typename
name|ImutProfileInfo
operator|<
name|T
operator|*
operator|>
operator|::
name|value_type_ref
name|value_type_ref
expr_stmt|;
end_typedef

begin_typedef
typedef|typedef
name|value_type
name|key_type
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|value_type_ref
name|key_type_ref
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|bool
name|data_type
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|bool
name|data_type_ref
typedef|;
end_typedef

begin_function
specifier|static
specifier|inline
name|key_type_ref
name|KeyOfValue
parameter_list|(
name|value_type_ref
name|D
parameter_list|)
block|{
return|return
name|D
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|data_type_ref
name|DataOfValue
parameter_list|(
name|value_type_ref
parameter_list|)
block|{
return|return
name|true
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|bool
name|isEqual
parameter_list|(
name|key_type_ref
name|LHS
parameter_list|,
name|key_type_ref
name|RHS
parameter_list|)
block|{
return|return
name|LHS
operator|==
name|RHS
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|bool
name|isLess
parameter_list|(
name|key_type_ref
name|LHS
parameter_list|,
name|key_type_ref
name|RHS
parameter_list|)
block|{
return|return
name|LHS
operator|<
name|RHS
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|bool
name|isDataEqual
parameter_list|(
name|data_type_ref
parameter_list|,
name|data_type_ref
parameter_list|)
block|{
return|return
name|true
return|;
block|}
end_function

begin_comment
unit|};
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|// Immutable Set
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_expr_stmt
name|template
operator|<
name|typename
name|ValT
operator|,
name|typename
name|ValInfo
operator|=
name|ImutContainerInfo
operator|<
name|ValT
operator|>
expr|>
name|class
name|ImmutableSet
block|{
name|public
operator|:
typedef|typedef
name|typename
name|ValInfo
operator|::
name|value_type
name|value_type
expr_stmt|;
end_expr_stmt

begin_typedef
typedef|typedef
name|typename
name|ValInfo
operator|::
name|value_type_ref
name|value_type_ref
expr_stmt|;
end_typedef

begin_typedef
typedef|typedef
name|ImutAVLTree
operator|<
name|ValInfo
operator|>
name|TreeTy
expr_stmt|;
end_typedef

begin_label
name|private
label|:
end_label

begin_decl_stmt
name|TreeTy
modifier|*
name|Root
decl_stmt|;
end_decl_stmt

begin_label
name|public
label|:
end_label

begin_comment
comment|/// Constructs a set from a pointer to a tree root.  In general one
end_comment

begin_comment
comment|/// should use a Factory object to create sets instead of directly
end_comment

begin_comment
comment|/// invoking the constructor, but there are cases where make this
end_comment

begin_comment
comment|/// constructor public is useful.
end_comment

begin_macro
name|explicit
end_macro

begin_expr_stmt
name|ImmutableSet
argument_list|(
name|TreeTy
operator|*
name|R
argument_list|)
operator|:
name|Root
argument_list|(
argument|R
argument_list|)
block|{}
name|class
name|Factory
block|{
name|typename
name|TreeTy
operator|::
name|Factory
name|F
block|;
specifier|const
name|bool
name|Canonicalize
block|;
name|public
operator|:
name|Factory
argument_list|(
argument|bool canonicalize = true
argument_list|)
operator|:
name|Canonicalize
argument_list|(
argument|canonicalize
argument_list|)
block|{}
name|Factory
argument_list|(
argument|BumpPtrAllocator& Alloc
argument_list|,
argument|bool canonicalize = true
argument_list|)
operator|:
name|F
argument_list|(
name|Alloc
argument_list|)
block|,
name|Canonicalize
argument_list|(
argument|canonicalize
argument_list|)
block|{}
comment|/// GetEmptySet - Returns an immutable set that contains no elements.
name|ImmutableSet
name|GetEmptySet
argument_list|()
block|{
return|return
name|ImmutableSet
argument_list|(
name|F
operator|.
name|GetEmptyTree
argument_list|()
argument_list|)
return|;
block|}
comment|/// Add - Creates a new immutable set that contains all of the values
comment|///  of the original set with the addition of the specified value.  If
comment|///  the original set already included the value, then the original set is
comment|///  returned and no memory is allocated.  The time and space complexity
comment|///  of this operation is logarithmic in the size of the original set.
comment|///  The memory allocated to represent the set is released when the
comment|///  factory object that created the set is destroyed.
name|ImmutableSet
name|Add
argument_list|(
argument|ImmutableSet Old
argument_list|,
argument|value_type_ref V
argument_list|)
block|{
name|TreeTy
operator|*
name|NewT
operator|=
name|F
operator|.
name|Add
argument_list|(
name|Old
operator|.
name|Root
argument_list|,
name|V
argument_list|)
block|;
return|return
name|ImmutableSet
argument_list|(
name|Canonicalize
condition|?
name|F
operator|.
name|GetCanonicalTree
argument_list|(
name|NewT
argument_list|)
else|:
name|NewT
argument_list|)
return|;
block|}
end_expr_stmt

begin_comment
comment|/// Remove - Creates a new immutable set that contains all of the values
end_comment

begin_comment
comment|///  of the original set with the exception of the specified value.  If
end_comment

begin_comment
comment|///  the original set did not contain the value, the original set is
end_comment

begin_comment
comment|///  returned and no memory is allocated.  The time and space complexity
end_comment

begin_comment
comment|///  of this operation is logarithmic in the size of the original set.
end_comment

begin_comment
comment|///  The memory allocated to represent the set is released when the
end_comment

begin_comment
comment|///  factory object that created the set is destroyed.
end_comment

begin_function
name|ImmutableSet
name|Remove
parameter_list|(
name|ImmutableSet
name|Old
parameter_list|,
name|value_type_ref
name|V
parameter_list|)
block|{
name|TreeTy
modifier|*
name|NewT
init|=
name|F
operator|.
name|Remove
argument_list|(
name|Old
operator|.
name|Root
argument_list|,
name|V
argument_list|)
decl_stmt|;
return|return
name|ImmutableSet
argument_list|(
name|Canonicalize
condition|?
name|F
operator|.
name|GetCanonicalTree
argument_list|(
name|NewT
argument_list|)
else|:
name|NewT
argument_list|)
return|;
block|}
end_function

begin_function
name|BumpPtrAllocator
modifier|&
name|getAllocator
parameter_list|()
block|{
return|return
name|F
operator|.
name|getAllocator
argument_list|()
return|;
block|}
end_function

begin_label
name|private
label|:
end_label

begin_macro
name|Factory
argument_list|(
argument|const Factory& RHS
argument_list|)
end_macro

begin_block
block|{}
end_block

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_decl_stmt
name|void
name|operator
init|=
operator|(
specifier|const
name|Factory
operator|&
name|RHS
operator|)
block|{}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
unit|};
name|friend
name|class
name|Factory
decl_stmt|;
end_decl_stmt

begin_comment
comment|/// contains - Returns true if the set contains the specified value.
end_comment

begin_decl_stmt
name|bool
name|contains
argument_list|(
name|value_type_ref
name|V
argument_list|)
decl|const
block|{
return|return
name|Root
condition|?
name|Root
operator|->
name|contains
argument_list|(
name|V
argument_list|)
else|:
name|false
return|;
block|}
end_decl_stmt

begin_expr_stmt
name|bool
name|operator
operator|==
operator|(
name|ImmutableSet
name|RHS
operator|)
specifier|const
block|{
return|return
name|Root
operator|&&
name|RHS
operator|.
name|Root
operator|?
name|Root
operator|->
name|isEqual
argument_list|(
operator|*
name|RHS
operator|.
name|Root
argument_list|)
operator|:
name|Root
operator|==
name|RHS
operator|.
name|Root
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|bool
name|operator
operator|!=
operator|(
name|ImmutableSet
name|RHS
operator|)
specifier|const
block|{
return|return
name|Root
operator|&&
name|RHS
operator|.
name|Root
operator|?
name|Root
operator|->
name|isNotEqual
argument_list|(
operator|*
name|RHS
operator|.
name|Root
argument_list|)
operator|:
name|Root
operator|!=
name|RHS
operator|.
name|Root
return|;
block|}
end_expr_stmt

begin_function
name|TreeTy
modifier|*
name|getRoot
parameter_list|()
block|{
return|return
name|Root
return|;
block|}
end_function

begin_comment
comment|/// isEmpty - Return true if the set contains no elements.
end_comment

begin_expr_stmt
name|bool
name|isEmpty
argument_list|()
specifier|const
block|{
return|return
operator|!
name|Root
return|;
block|}
end_expr_stmt

begin_comment
comment|/// isSingleton - Return true if the set contains exactly one element.
end_comment

begin_comment
comment|///   This method runs in constant time.
end_comment

begin_expr_stmt
name|bool
name|isSingleton
argument_list|()
specifier|const
block|{
return|return
name|getHeight
argument_list|()
operator|==
literal|1
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|Callback
operator|>
name|void
name|foreach
argument_list|(
argument|Callback& C
argument_list|)
block|{
if|if
condition|(
name|Root
condition|)
name|Root
operator|->
name|foreach
argument_list|(
name|C
argument_list|)
expr_stmt|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|Callback
operator|>
name|void
name|foreach
argument_list|()
block|{
if|if
condition|(
name|Root
condition|)
block|{
name|Callback
name|C
decl_stmt|;
name|Root
operator|->
name|foreach
argument_list|(
name|C
argument_list|)
expr_stmt|;
block|}
end_expr_stmt

begin_comment
unit|}
comment|//===--------------------------------------------------===//
end_comment

begin_comment
comment|// Iterators.
end_comment

begin_comment
comment|//===--------------------------------------------------===//
end_comment

begin_macro
unit|class
name|iterator
end_macro

begin_block
block|{
name|typename
name|TreeTy
operator|::
name|iterator
name|itr
expr_stmt|;
name|iterator
argument_list|(
name|TreeTy
operator|*
name|t
argument_list|)
operator|:
name|itr
argument_list|(
argument|t
argument_list|)
block|{}
name|friend
name|class
name|ImmutableSet
operator|<
name|ValT
operator|,
name|ValInfo
operator|>
expr_stmt|;
name|public
label|:
name|iterator
argument_list|()
block|{}
specifier|inline
name|value_type_ref
name|operator
operator|*
operator|(
operator|)
specifier|const
block|{
return|return
name|itr
operator|->
name|getValue
argument_list|()
return|;
block|}
specifier|inline
name|iterator
operator|&
name|operator
operator|++
operator|(
operator|)
block|{
operator|++
name|itr
block|;
return|return
operator|*
name|this
return|;
block|}
specifier|inline
name|iterator
name|operator
operator|++
operator|(
name|int
operator|)
block|{
name|iterator
name|tmp
argument_list|(
operator|*
name|this
argument_list|)
block|;
operator|++
name|itr
block|;
return|return
name|tmp
return|;
block|}
specifier|inline
name|iterator
operator|&
name|operator
operator|--
operator|(
operator|)
block|{
operator|--
name|itr
block|;
return|return
operator|*
name|this
return|;
block|}
specifier|inline
name|iterator
name|operator
operator|--
operator|(
name|int
operator|)
block|{
name|iterator
name|tmp
argument_list|(
operator|*
name|this
argument_list|)
block|;
operator|--
name|itr
block|;
return|return
name|tmp
return|;
block|}
specifier|inline
name|bool
name|operator
operator|==
operator|(
specifier|const
name|iterator
operator|&
name|RHS
operator|)
specifier|const
block|{
return|return
name|RHS
operator|.
name|itr
operator|==
name|itr
return|;
block|}
specifier|inline
name|bool
name|operator
operator|!=
operator|(
specifier|const
name|iterator
operator|&
name|RHS
operator|)
specifier|const
block|{
return|return
name|RHS
operator|.
name|itr
operator|!=
name|itr
return|;
block|}
specifier|inline
name|value_type
operator|*
name|operator
operator|->
expr|(
block|)
end_block

begin_expr_stmt
specifier|const
block|{
return|return
operator|&
operator|(
name|operator
operator|*
operator|(
operator|)
operator|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
unit|};
name|iterator
name|begin
argument_list|()
specifier|const
block|{
return|return
name|iterator
argument_list|(
name|Root
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|iterator
name|end
argument_list|()
specifier|const
block|{
return|return
name|iterator
argument_list|()
return|;
block|}
end_expr_stmt

begin_comment
comment|//===--------------------------------------------------===//
end_comment

begin_comment
comment|// Utility methods.
end_comment

begin_comment
comment|//===--------------------------------------------------===//
end_comment

begin_expr_stmt
specifier|inline
name|unsigned
name|getHeight
argument_list|()
specifier|const
block|{
return|return
name|Root
operator|?
name|Root
operator|->
name|getHeight
argument_list|()
operator|:
literal|0
return|;
block|}
end_expr_stmt

begin_function
specifier|static
specifier|inline
name|void
name|Profile
parameter_list|(
name|FoldingSetNodeID
modifier|&
name|ID
parameter_list|,
specifier|const
name|ImmutableSet
modifier|&
name|S
parameter_list|)
block|{
name|ID
operator|.
name|AddPointer
argument_list|(
name|S
operator|.
name|Root
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|inline
name|void
name|Profile
argument_list|(
name|FoldingSetNodeID
operator|&
name|ID
argument_list|)
decl|const
block|{
return|return
name|Profile
argument_list|(
name|ID
argument_list|,
operator|*
name|this
argument_list|)
return|;
block|}
end_decl_stmt

begin_comment
comment|//===--------------------------------------------------===//
end_comment

begin_comment
comment|// For testing.
end_comment

begin_comment
comment|//===--------------------------------------------------===//
end_comment

begin_expr_stmt
name|void
name|verify
argument_list|()
specifier|const
block|{
if|if
condition|(
name|Root
condition|)
name|Root
operator|->
name|verify
argument_list|()
expr_stmt|;
block|}
end_expr_stmt

begin_comment
unit|};  }
comment|// end namespace llvm
end_comment

begin_endif
endif|#
directive|endif
end_endif

end_unit

