begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===- llvm/ADT/SmallVector.h - 'Normally small' vectors --------*- C++ -*-===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file defines the SmallVector class.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LLVM_ADT_SMALLVECTOR_H
end_ifndef

begin_define
define|#
directive|define
name|LLVM_ADT_SMALLVECTOR_H
end_define

begin_include
include|#
directive|include
file|"llvm/Support/type_traits.h"
end_include

begin_include
include|#
directive|include
file|<algorithm>
end_include

begin_include
include|#
directive|include
file|<cassert>
end_include

begin_include
include|#
directive|include
file|<cstring>
end_include

begin_include
include|#
directive|include
file|<memory>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|_MSC_VER
end_ifdef

begin_decl_stmt
name|namespace
name|std
block|{
if|#
directive|if
name|_MSC_VER
operator|<=
literal|1310
comment|// Work around flawed VC++ implementation of std::uninitialized_copy.  Define
comment|// additional overloads so that elements with pointer types are recognized as
comment|// scalars and not objects, causing bizarre type conversion errors.
name|template
operator|<
name|class
name|T1
operator|,
name|class
name|T2
operator|>
specifier|inline
name|_Scalar_ptr_iterator_tag
name|_Ptr_cat
argument_list|(
argument|T1 **
argument_list|,
argument|T2 **
argument_list|)
block|{
name|_Scalar_ptr_iterator_tag
name|_Cat
block|;
return|return
name|_Cat
return|;
block|}
name|template
operator|<
name|class
name|T1
operator|,
name|class
name|T2
operator|>
specifier|inline
name|_Scalar_ptr_iterator_tag
name|_Ptr_cat
argument_list|(
argument|T1* const *
argument_list|,
argument|T2 **
argument_list|)
block|{
name|_Scalar_ptr_iterator_tag
name|_Cat
block|;
return|return
name|_Cat
return|;
block|}
else|#
directive|else
comment|// FIXME: It is not clear if the problem is fixed in VS 2005.  What is clear
comment|// is that the above hack won't work if it wasn't fixed.
endif|#
directive|endif
block|}
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|namespace
name|llvm
block|{
comment|/// SmallVectorImpl - This class consists of common code factored out of the
comment|/// SmallVector class to reduce code duplication based on the SmallVector 'N'
comment|/// template parameter.
name|template
operator|<
name|typename
name|T
operator|>
name|class
name|SmallVectorImpl
block|{
name|protected
operator|:
name|T
operator|*
name|Begin
block|,
operator|*
name|End
block|,
operator|*
name|Capacity
block|;
comment|// Allocate raw space for N elements of type T.  If T has a ctor or dtor, we
comment|// don't want it to be automatically run, so we need to represent the space as
comment|// something else.  An array of char would work great, but might not be
comment|// aligned sufficiently.  Instead, we either use GCC extensions, or some
comment|// number of union instances for the space, which guarantee maximal alignment.
name|protected
operator|:
ifdef|#
directive|ifdef
name|__GNUC__
typedef|typedef
name|char
name|U
typedef|;
name|U
name|FirstEl
name|__attribute__
argument_list|(
operator|(
name|aligned
operator|)
argument_list|)
expr_stmt|;
else|#
directive|else
union|union
name|U
block|{
name|double
name|D
decl_stmt|;
name|long
name|double
name|LD
decl_stmt|;
name|long
name|long
name|L
decl_stmt|;
name|void
modifier|*
name|P
decl_stmt|;
block|}
name|FirstEl
union|;
endif|#
directive|endif
comment|// Space after 'FirstEl' is clobbered, do not add any instance vars after it.
name|public
label|:
comment|// Default ctor - Initialize to empty.
name|explicit
name|SmallVectorImpl
argument_list|(
argument|unsigned N
argument_list|)
block|:
name|Begin
argument_list|(
name|reinterpret_cast
operator|<
name|T
operator|*
operator|>
operator|(
operator|&
name|FirstEl
operator|)
argument_list|)
operator|,
name|End
argument_list|(
name|reinterpret_cast
operator|<
name|T
operator|*
operator|>
operator|(
operator|&
name|FirstEl
operator|)
argument_list|)
operator|,
name|Capacity
argument_list|(
argument|reinterpret_cast<T*>(&FirstEl)+N
argument_list|)
block|{   }
operator|~
name|SmallVectorImpl
argument_list|()
block|{
comment|// Destroy the constructed elements in the vector.
name|destroy_range
argument_list|(
name|Begin
argument_list|,
name|End
argument_list|)
block|;
comment|// If this wasn't grown from the inline copy, deallocate the old space.
if|if
condition|(
operator|!
name|isSmall
argument_list|()
condition|)
name|operator
name|delete
parameter_list|(
name|Begin
parameter_list|)
function_decl|;
block|}
typedef|typedef
name|size_t
name|size_type
typedef|;
typedef|typedef
name|ptrdiff_t
name|difference_type
typedef|;
typedef|typedef
name|T
name|value_type
typedef|;
typedef|typedef
name|T
modifier|*
name|iterator
typedef|;
typedef|typedef
specifier|const
name|T
modifier|*
name|const_iterator
typedef|;
typedef|typedef
name|std
operator|::
name|reverse_iterator
operator|<
name|const_iterator
operator|>
name|const_reverse_iterator
expr_stmt|;
typedef|typedef
name|std
operator|::
name|reverse_iterator
operator|<
name|iterator
operator|>
name|reverse_iterator
expr_stmt|;
typedef|typedef
name|T
modifier|&
name|reference
typedef|;
typedef|typedef
specifier|const
name|T
modifier|&
name|const_reference
typedef|;
typedef|typedef
name|T
modifier|*
name|pointer
typedef|;
typedef|typedef
specifier|const
name|T
modifier|*
name|const_pointer
typedef|;
name|bool
name|empty
argument_list|()
specifier|const
block|{
return|return
name|Begin
operator|==
name|End
return|;
block|}
name|size_type
name|size
argument_list|()
specifier|const
block|{
return|return
name|End
operator|-
name|Begin
return|;
block|}
name|size_type
name|max_size
argument_list|()
specifier|const
block|{
return|return
name|size_type
argument_list|(
operator|-
literal|1
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|T
argument_list|)
return|;
block|}
comment|// forward iterator creation methods.
name|iterator
name|begin
parameter_list|()
block|{
return|return
name|Begin
return|;
block|}
name|const_iterator
name|begin
argument_list|()
specifier|const
block|{
return|return
name|Begin
return|;
block|}
name|iterator
name|end
parameter_list|()
block|{
return|return
name|End
return|;
block|}
name|const_iterator
name|end
argument_list|()
specifier|const
block|{
return|return
name|End
return|;
block|}
comment|// reverse iterator creation methods.
name|reverse_iterator
name|rbegin
parameter_list|()
block|{
return|return
name|reverse_iterator
argument_list|(
name|end
argument_list|()
argument_list|)
return|;
block|}
name|const_reverse_iterator
name|rbegin
argument_list|()
specifier|const
block|{
return|return
name|const_reverse_iterator
argument_list|(
name|end
argument_list|()
argument_list|)
return|;
block|}
name|reverse_iterator
name|rend
parameter_list|()
block|{
return|return
name|reverse_iterator
argument_list|(
name|begin
argument_list|()
argument_list|)
return|;
block|}
name|const_reverse_iterator
name|rend
argument_list|()
specifier|const
block|{
return|return
name|const_reverse_iterator
argument_list|(
name|begin
argument_list|()
argument_list|)
return|;
block|}
name|reference
name|operator
function|[]
parameter_list|(
name|unsigned
name|idx
parameter_list|)
block|{
name|assert
argument_list|(
name|Begin
operator|+
name|idx
operator|<
name|End
argument_list|)
expr_stmt|;
return|return
name|Begin
index|[
name|idx
index|]
return|;
block|}
name|const_reference
name|operator
index|[]
argument_list|(
name|unsigned
name|idx
argument_list|)
decl|const
block|{
name|assert
argument_list|(
name|Begin
operator|+
name|idx
operator|<
name|End
argument_list|)
expr_stmt|;
return|return
name|Begin
index|[
name|idx
index|]
return|;
block|}
name|reference
name|front
parameter_list|()
block|{
return|return
name|begin
argument_list|()
index|[
literal|0
index|]
return|;
block|}
name|const_reference
name|front
argument_list|()
specifier|const
block|{
return|return
name|begin
argument_list|()
index|[
literal|0
index|]
return|;
block|}
name|reference
name|back
parameter_list|()
block|{
return|return
name|end
argument_list|()
index|[
operator|-
literal|1
index|]
return|;
block|}
name|const_reference
name|back
argument_list|()
specifier|const
block|{
return|return
name|end
argument_list|()
index|[
operator|-
literal|1
index|]
return|;
block|}
name|void
name|push_back
parameter_list|(
name|const_reference
name|Elt
parameter_list|)
block|{
if|if
condition|(
name|End
operator|<
name|Capacity
condition|)
block|{
name|Retry
label|:
name|new
argument_list|(
argument|End
argument_list|)
name|T
argument_list|(
name|Elt
argument_list|)
expr_stmt|;
operator|++
name|End
expr_stmt|;
return|return;
block|}
name|grow
argument_list|()
expr_stmt|;
goto|goto
name|Retry
goto|;
block|}
name|void
name|pop_back
parameter_list|()
block|{
operator|--
name|End
expr_stmt|;
name|End
operator|->
expr|~
name|T
argument_list|()
expr_stmt|;
block|}
name|T
name|pop_back_val
parameter_list|()
block|{
name|T
name|Result
init|=
name|back
argument_list|()
decl_stmt|;
name|pop_back
argument_list|()
expr_stmt|;
return|return
name|Result
return|;
block|}
name|void
name|clear
parameter_list|()
block|{
name|destroy_range
argument_list|(
name|Begin
argument_list|,
name|End
argument_list|)
expr_stmt|;
name|End
operator|=
name|Begin
expr_stmt|;
block|}
name|void
name|resize
parameter_list|(
name|unsigned
name|N
parameter_list|)
block|{
if|if
condition|(
name|N
operator|<
name|size
argument_list|()
condition|)
block|{
name|destroy_range
argument_list|(
name|Begin
operator|+
name|N
argument_list|,
name|End
argument_list|)
expr_stmt|;
name|End
operator|=
name|Begin
operator|+
name|N
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|N
operator|>
name|size
argument_list|()
condition|)
block|{
if|if
condition|(
name|unsigned
argument_list|(
name|Capacity
operator|-
name|Begin
argument_list|)
operator|<
name|N
condition|)
name|grow
argument_list|(
name|N
argument_list|)
expr_stmt|;
name|construct_range
argument_list|(
name|End
argument_list|,
name|Begin
operator|+
name|N
argument_list|,
name|T
argument_list|()
argument_list|)
expr_stmt|;
name|End
operator|=
name|Begin
operator|+
name|N
expr_stmt|;
block|}
block|}
name|void
name|resize
parameter_list|(
name|unsigned
name|N
parameter_list|,
specifier|const
name|T
modifier|&
name|NV
parameter_list|)
block|{
if|if
condition|(
name|N
operator|<
name|size
argument_list|()
condition|)
block|{
name|destroy_range
argument_list|(
name|Begin
operator|+
name|N
argument_list|,
name|End
argument_list|)
expr_stmt|;
name|End
operator|=
name|Begin
operator|+
name|N
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|N
operator|>
name|size
argument_list|()
condition|)
block|{
if|if
condition|(
name|unsigned
argument_list|(
name|Capacity
operator|-
name|Begin
argument_list|)
operator|<
name|N
condition|)
name|grow
argument_list|(
name|N
argument_list|)
expr_stmt|;
name|construct_range
argument_list|(
name|End
argument_list|,
name|Begin
operator|+
name|N
argument_list|,
name|NV
argument_list|)
expr_stmt|;
name|End
operator|=
name|Begin
operator|+
name|N
expr_stmt|;
block|}
block|}
name|void
name|reserve
parameter_list|(
name|unsigned
name|N
parameter_list|)
block|{
if|if
condition|(
name|unsigned
argument_list|(
name|Capacity
operator|-
name|Begin
argument_list|)
operator|<
name|N
condition|)
name|grow
argument_list|(
name|N
argument_list|)
expr_stmt|;
block|}
name|void
name|swap
parameter_list|(
name|SmallVectorImpl
modifier|&
name|RHS
parameter_list|)
function_decl|;
comment|/// append - Add the specified range to the end of the SmallVector.
comment|///
name|template
operator|<
name|typename
name|in_iter
operator|>
name|void
name|append
argument_list|(
argument|in_iter in_start
argument_list|,
argument|in_iter in_end
argument_list|)
block|{
name|size_type
name|NumInputs
operator|=
name|std
operator|::
name|distance
argument_list|(
name|in_start
argument_list|,
name|in_end
argument_list|)
block|;
comment|// Grow allocated space if needed.
if|if
condition|(
name|NumInputs
operator|>
name|size_type
argument_list|(
name|Capacity
operator|-
name|End
argument_list|)
condition|)
name|grow
argument_list|(
name|size
argument_list|()
operator|+
name|NumInputs
argument_list|)
expr_stmt|;
comment|// Copy the new elements over.
name|std
operator|::
name|uninitialized_copy
argument_list|(
name|in_start
argument_list|,
name|in_end
argument_list|,
name|End
argument_list|)
expr_stmt|;
name|End
operator|+=
name|NumInputs
expr_stmt|;
block|}
end_decl_stmt

begin_comment
comment|/// append - Add the specified range to the end of the SmallVector.
end_comment

begin_comment
comment|///
end_comment

begin_function
name|void
name|append
parameter_list|(
name|size_type
name|NumInputs
parameter_list|,
specifier|const
name|T
modifier|&
name|Elt
parameter_list|)
block|{
comment|// Grow allocated space if needed.
if|if
condition|(
name|NumInputs
operator|>
name|size_type
argument_list|(
name|Capacity
operator|-
name|End
argument_list|)
condition|)
name|grow
argument_list|(
name|size
argument_list|()
operator|+
name|NumInputs
argument_list|)
expr_stmt|;
comment|// Copy the new elements over.
name|std
operator|::
name|uninitialized_fill_n
argument_list|(
name|End
argument_list|,
name|NumInputs
argument_list|,
name|Elt
argument_list|)
expr_stmt|;
name|End
operator|+=
name|NumInputs
expr_stmt|;
block|}
end_function

begin_function
name|void
name|assign
parameter_list|(
name|unsigned
name|NumElts
parameter_list|,
specifier|const
name|T
modifier|&
name|Elt
parameter_list|)
block|{
name|clear
argument_list|()
expr_stmt|;
if|if
condition|(
name|unsigned
argument_list|(
name|Capacity
operator|-
name|Begin
argument_list|)
operator|<
name|NumElts
condition|)
name|grow
argument_list|(
name|NumElts
argument_list|)
expr_stmt|;
name|End
operator|=
name|Begin
operator|+
name|NumElts
expr_stmt|;
name|construct_range
argument_list|(
name|Begin
argument_list|,
name|End
argument_list|,
name|Elt
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|iterator
name|erase
parameter_list|(
name|iterator
name|I
parameter_list|)
block|{
name|iterator
name|N
init|=
name|I
decl_stmt|;
comment|// Shift all elts down one.
name|std
operator|::
name|copy
argument_list|(
name|I
operator|+
literal|1
argument_list|,
name|End
argument_list|,
name|I
argument_list|)
expr_stmt|;
comment|// Drop the last elt.
name|pop_back
argument_list|()
expr_stmt|;
return|return
operator|(
name|N
operator|)
return|;
block|}
end_function

begin_function
name|iterator
name|erase
parameter_list|(
name|iterator
name|S
parameter_list|,
name|iterator
name|E
parameter_list|)
block|{
name|iterator
name|N
init|=
name|S
decl_stmt|;
comment|// Shift all elts down.
name|iterator
name|I
init|=
name|std
operator|::
name|copy
argument_list|(
name|E
argument_list|,
name|End
argument_list|,
name|S
argument_list|)
decl_stmt|;
comment|// Drop the last elts.
name|destroy_range
argument_list|(
name|I
argument_list|,
name|End
argument_list|)
expr_stmt|;
name|End
operator|=
name|I
expr_stmt|;
return|return
operator|(
name|N
operator|)
return|;
block|}
end_function

begin_function
name|iterator
name|insert
parameter_list|(
name|iterator
name|I
parameter_list|,
specifier|const
name|T
modifier|&
name|Elt
parameter_list|)
block|{
if|if
condition|(
name|I
operator|==
name|End
condition|)
block|{
comment|// Important special case for empty vector.
name|push_back
argument_list|(
name|Elt
argument_list|)
expr_stmt|;
return|return
name|end
argument_list|()
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|End
operator|<
name|Capacity
condition|)
block|{
name|Retry
label|:
name|new
argument_list|(
argument|End
argument_list|)
name|T
argument_list|(
name|back
argument_list|()
argument_list|)
expr_stmt|;
operator|++
name|End
expr_stmt|;
comment|// Push everything else over.
name|std
operator|::
name|copy_backward
argument_list|(
name|I
argument_list|,
name|End
operator|-
literal|1
argument_list|,
name|End
argument_list|)
expr_stmt|;
operator|*
name|I
operator|=
name|Elt
expr_stmt|;
return|return
name|I
return|;
block|}
name|size_t
name|EltNo
init|=
name|I
operator|-
name|Begin
decl_stmt|;
name|grow
argument_list|()
expr_stmt|;
name|I
operator|=
name|Begin
operator|+
name|EltNo
expr_stmt|;
goto|goto
name|Retry
goto|;
block|}
end_function

begin_function
name|iterator
name|insert
parameter_list|(
name|iterator
name|I
parameter_list|,
name|size_type
name|NumToInsert
parameter_list|,
specifier|const
name|T
modifier|&
name|Elt
parameter_list|)
block|{
if|if
condition|(
name|I
operator|==
name|End
condition|)
block|{
comment|// Important special case for empty vector.
name|append
argument_list|(
name|NumToInsert
argument_list|,
name|Elt
argument_list|)
expr_stmt|;
return|return
name|end
argument_list|()
operator|-
literal|1
return|;
block|}
comment|// Convert iterator to elt# to avoid invalidating iterator when we reserve()
name|size_t
name|InsertElt
init|=
name|I
operator|-
name|begin
argument_list|()
decl_stmt|;
comment|// Ensure there is enough space.
name|reserve
argument_list|(
name|static_cast
operator|<
name|unsigned
operator|>
operator|(
name|size
argument_list|()
operator|+
name|NumToInsert
operator|)
argument_list|)
expr_stmt|;
comment|// Uninvalidate the iterator.
name|I
operator|=
name|begin
argument_list|()
operator|+
name|InsertElt
expr_stmt|;
comment|// If there are more elements between the insertion point and the end of the
comment|// range than there are being inserted, we can use a simple approach to
comment|// insertion.  Since we already reserved space, we know that this won't
comment|// reallocate the vector.
if|if
condition|(
name|size_t
argument_list|(
name|end
argument_list|()
operator|-
name|I
argument_list|)
operator|>=
name|NumToInsert
condition|)
block|{
name|T
modifier|*
name|OldEnd
init|=
name|End
decl_stmt|;
name|append
argument_list|(
name|End
operator|-
name|NumToInsert
argument_list|,
name|End
argument_list|)
expr_stmt|;
comment|// Copy the existing elements that get replaced.
name|std
operator|::
name|copy_backward
argument_list|(
name|I
argument_list|,
name|OldEnd
operator|-
name|NumToInsert
argument_list|,
name|OldEnd
argument_list|)
expr_stmt|;
name|std
operator|::
name|fill_n
argument_list|(
name|I
argument_list|,
name|NumToInsert
argument_list|,
name|Elt
argument_list|)
expr_stmt|;
return|return
name|I
return|;
block|}
comment|// Otherwise, we're inserting more elements than exist already, and we're
comment|// not inserting at the end.
comment|// Copy over the elements that we're about to overwrite.
name|T
modifier|*
name|OldEnd
init|=
name|End
decl_stmt|;
name|End
operator|+=
name|NumToInsert
expr_stmt|;
name|size_t
name|NumOverwritten
init|=
name|OldEnd
operator|-
name|I
decl_stmt|;
name|std
operator|::
name|uninitialized_copy
argument_list|(
name|I
argument_list|,
name|OldEnd
argument_list|,
name|End
operator|-
name|NumOverwritten
argument_list|)
expr_stmt|;
comment|// Replace the overwritten part.
name|std
operator|::
name|fill_n
argument_list|(
name|I
argument_list|,
name|NumOverwritten
argument_list|,
name|Elt
argument_list|)
expr_stmt|;
comment|// Insert the non-overwritten middle part.
name|std
operator|::
name|uninitialized_fill_n
argument_list|(
name|OldEnd
argument_list|,
name|NumToInsert
operator|-
name|NumOverwritten
argument_list|,
name|Elt
argument_list|)
expr_stmt|;
return|return
name|I
return|;
block|}
end_function

begin_expr_stmt
name|template
operator|<
name|typename
name|ItTy
operator|>
name|iterator
name|insert
argument_list|(
argument|iterator I
argument_list|,
argument|ItTy From
argument_list|,
argument|ItTy To
argument_list|)
block|{
if|if
condition|(
name|I
operator|==
name|End
condition|)
block|{
comment|// Important special case for empty vector.
name|append
argument_list|(
name|From
argument_list|,
name|To
argument_list|)
expr_stmt|;
return|return
name|end
argument_list|()
operator|-
literal|1
return|;
block|}
name|size_t
name|NumToInsert
operator|=
name|std
operator|::
name|distance
argument_list|(
name|From
argument_list|,
name|To
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|// Convert iterator to elt# to avoid invalidating iterator when we reserve()
end_comment

begin_decl_stmt
name|size_t
name|InsertElt
init|=
name|I
operator|-
name|begin
argument_list|()
decl_stmt|;
end_decl_stmt

begin_comment
comment|// Ensure there is enough space.
end_comment

begin_expr_stmt
name|reserve
argument_list|(
name|static_cast
operator|<
name|unsigned
operator|>
operator|(
name|size
argument_list|()
operator|+
name|NumToInsert
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|// Uninvalidate the iterator.
end_comment

begin_expr_stmt
name|I
operator|=
name|begin
argument_list|()
operator|+
name|InsertElt
expr_stmt|;
end_expr_stmt

begin_comment
comment|// If there are more elements between the insertion point and the end of the
end_comment

begin_comment
comment|// range than there are being inserted, we can use a simple approach to
end_comment

begin_comment
comment|// insertion.  Since we already reserved space, we know that this won't
end_comment

begin_comment
comment|// reallocate the vector.
end_comment

begin_if
if|if
condition|(
name|size_t
argument_list|(
name|end
argument_list|()
operator|-
name|I
argument_list|)
operator|>=
name|NumToInsert
condition|)
block|{
name|T
modifier|*
name|OldEnd
init|=
name|End
decl_stmt|;
name|append
argument_list|(
name|End
operator|-
name|NumToInsert
argument_list|,
name|End
argument_list|)
expr_stmt|;
comment|// Copy the existing elements that get replaced.
name|std
operator|::
name|copy_backward
argument_list|(
name|I
argument_list|,
name|OldEnd
operator|-
name|NumToInsert
argument_list|,
name|OldEnd
argument_list|)
expr_stmt|;
name|std
operator|::
name|copy
argument_list|(
name|From
argument_list|,
name|To
argument_list|,
name|I
argument_list|)
expr_stmt|;
return|return
name|I
return|;
block|}
end_if

begin_comment
comment|// Otherwise, we're inserting more elements than exist already, and we're
end_comment

begin_comment
comment|// not inserting at the end.
end_comment

begin_comment
comment|// Copy over the elements that we're about to overwrite.
end_comment

begin_decl_stmt
name|T
modifier|*
name|OldEnd
init|=
name|End
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|End
operator|+=
name|NumToInsert
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|size_t
name|NumOverwritten
init|=
name|OldEnd
operator|-
name|I
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|std
operator|::
name|uninitialized_copy
argument_list|(
name|I
argument_list|,
name|OldEnd
argument_list|,
name|End
operator|-
name|NumOverwritten
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|// Replace the overwritten part.
end_comment

begin_expr_stmt
name|std
operator|::
name|copy
argument_list|(
name|From
argument_list|,
name|From
operator|+
name|NumOverwritten
argument_list|,
name|I
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|// Insert the non-overwritten middle part.
end_comment

begin_expr_stmt
name|std
operator|::
name|uninitialized_copy
argument_list|(
name|From
operator|+
name|NumOverwritten
argument_list|,
name|To
argument_list|,
name|OldEnd
argument_list|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|I
return|;
end_return

begin_comment
unit|}
comment|/// data - Return a pointer to the vector's buffer, even if empty().
end_comment

begin_macro
unit|pointer
name|data
argument_list|()
end_macro

begin_block
block|{
return|return
name|pointer
argument_list|(
name|Begin
argument_list|)
return|;
block|}
end_block

begin_comment
comment|/// data - Return a pointer to the vector's buffer, even if empty().
end_comment

begin_expr_stmt
name|const_pointer
name|data
argument_list|()
specifier|const
block|{
return|return
name|const_pointer
argument_list|(
name|Begin
argument_list|)
return|;
block|}
end_expr_stmt

begin_decl_stmt
specifier|const
name|SmallVectorImpl
modifier|&
name|operator
init|=
operator|(
specifier|const
name|SmallVectorImpl
operator|&
name|RHS
operator|)
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|bool
name|operator
operator|==
operator|(
specifier|const
name|SmallVectorImpl
operator|&
name|RHS
operator|)
specifier|const
block|{
if|if
condition|(
name|size
argument_list|()
operator|!=
name|RHS
operator|.
name|size
argument_list|()
condition|)
return|return
name|false
return|;
end_expr_stmt

begin_for
for|for
control|(
name|T
modifier|*
name|This
init|=
name|Begin
init|,
modifier|*
name|That
init|=
name|RHS
operator|.
name|Begin
init|,
modifier|*
name|E
init|=
name|Begin
operator|+
name|size
argument_list|()
init|;
name|This
operator|!=
name|E
condition|;
operator|++
name|This
operator|,
operator|++
name|That
control|)
if|if
condition|(
operator|*
name|This
operator|!=
operator|*
name|That
condition|)
return|return
name|false
return|;
end_for

begin_return
return|return
name|true
return|;
end_return

begin_expr_stmt
unit|}   bool
name|operator
operator|!=
operator|(
specifier|const
name|SmallVectorImpl
operator|&
name|RHS
operator|)
specifier|const
block|{
return|return
operator|!
operator|(
operator|*
name|this
operator|==
name|RHS
operator|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|bool
name|operator
operator|<
operator|(
specifier|const
name|SmallVectorImpl
operator|&
name|RHS
operator|)
specifier|const
block|{
return|return
name|std
operator|::
name|lexicographical_compare
argument_list|(
name|begin
argument_list|()
argument_list|,
name|end
argument_list|()
argument_list|,
name|RHS
operator|.
name|begin
argument_list|()
argument_list|,
name|RHS
operator|.
name|end
argument_list|()
argument_list|)
return|;
block|}
end_expr_stmt

begin_comment
comment|/// capacity - Return the total number of elements in the currently allocated
end_comment

begin_comment
comment|/// buffer.
end_comment

begin_expr_stmt
name|size_t
name|capacity
argument_list|()
specifier|const
block|{
return|return
name|Capacity
operator|-
name|Begin
return|;
block|}
end_expr_stmt

begin_comment
comment|/// set_size - Set the array size to \arg N, which the current array must have
end_comment

begin_comment
comment|/// enough capacity for.
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|/// This does not construct or destroy any elements in the vector.
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|/// Clients can use this in conjunction with capacity() to write past the end
end_comment

begin_comment
comment|/// of the buffer when they know that more elements are available, and only
end_comment

begin_comment
comment|/// update the size later. This avoids the cost of value initializing elements
end_comment

begin_comment
comment|/// which will only be overwritten.
end_comment

begin_function
name|void
name|set_size
parameter_list|(
name|unsigned
name|N
parameter_list|)
block|{
name|assert
argument_list|(
name|N
operator|<=
name|capacity
argument_list|()
argument_list|)
expr_stmt|;
name|End
operator|=
name|Begin
operator|+
name|N
expr_stmt|;
block|}
end_function

begin_label
name|private
label|:
end_label

begin_comment
comment|/// isSmall - Return true if this is a smallvector which has not had dynamic
end_comment

begin_comment
comment|/// memory allocated for it.
end_comment

begin_expr_stmt
name|bool
name|isSmall
argument_list|()
specifier|const
block|{
return|return
name|static_cast
operator|<
specifier|const
name|void
operator|*
operator|>
operator|(
name|Begin
operator|)
operator|==
name|static_cast
operator|<
specifier|const
name|void
operator|*
operator|>
operator|(
operator|&
name|FirstEl
operator|)
return|;
block|}
end_expr_stmt

begin_comment
comment|/// grow - double the size of the allocated memory, guaranteeing space for at
end_comment

begin_comment
comment|/// least one more element or MinSize if specified.
end_comment

begin_function_decl
name|void
name|grow
parameter_list|(
name|size_type
name|MinSize
init|=
literal|0
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|void
name|construct_range
parameter_list|(
name|T
modifier|*
name|S
parameter_list|,
name|T
modifier|*
name|E
parameter_list|,
specifier|const
name|T
modifier|&
name|Elt
parameter_list|)
block|{
for|for
control|(
init|;
name|S
operator|!=
name|E
condition|;
operator|++
name|S
control|)
name|new
argument_list|(
argument|S
argument_list|)
name|T
argument_list|(
name|Elt
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|destroy_range
parameter_list|(
name|T
modifier|*
name|S
parameter_list|,
name|T
modifier|*
name|E
parameter_list|)
block|{
while|while
condition|(
name|S
operator|!=
name|E
condition|)
block|{
operator|--
name|E
expr_stmt|;
name|E
operator|->
expr|~
name|T
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
unit|};
comment|// Define this out-of-line to dissuade the C++ compiler from inlining it.
end_comment

begin_expr_stmt
name|template
operator|<
name|typename
name|T
operator|>
name|void
name|SmallVectorImpl
operator|<
name|T
operator|>
operator|::
name|grow
argument_list|(
argument|size_t MinSize
argument_list|)
block|{
name|size_t
name|CurCapacity
operator|=
name|Capacity
operator|-
name|Begin
block|;
name|size_t
name|CurSize
operator|=
name|size
argument_list|()
block|;
name|size_t
name|NewCapacity
operator|=
literal|2
operator|*
name|CurCapacity
block|;
if|if
condition|(
name|NewCapacity
operator|<
name|MinSize
condition|)
name|NewCapacity
operator|=
name|MinSize
expr_stmt|;
name|T
operator|*
name|NewElts
operator|=
name|static_cast
operator|<
name|T
operator|*
operator|>
operator|(
name|operator
name|new
argument_list|(
name|NewCapacity
operator|*
sizeof|sizeof
argument_list|(
name|T
argument_list|)
argument_list|)
operator|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|// Copy the elements over.
end_comment

begin_if
if|if
condition|(
name|is_class
operator|<
name|T
operator|>
operator|::
name|value
condition|)
name|std
operator|::
name|uninitialized_copy
argument_list|(
name|Begin
argument_list|,
name|End
argument_list|,
name|NewElts
argument_list|)
expr_stmt|;
else|else
comment|// Use memcpy for PODs (std::uninitialized_copy optimizes to memmove).
name|memcpy
argument_list|(
name|NewElts
argument_list|,
name|Begin
argument_list|,
name|CurSize
operator|*
sizeof|sizeof
argument_list|(
name|T
argument_list|)
argument_list|)
expr_stmt|;
end_if

begin_comment
comment|// Destroy the original elements.
end_comment

begin_expr_stmt
name|destroy_range
argument_list|(
name|Begin
argument_list|,
name|End
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|// If this wasn't grown from the inline copy, deallocate the old space.
end_comment

begin_if
if|if
condition|(
operator|!
name|isSmall
argument_list|()
condition|)
name|operator
name|delete
parameter_list|(
name|Begin
parameter_list|)
function_decl|;
end_if

begin_expr_stmt
name|Begin
operator|=
name|NewElts
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|End
operator|=
name|NewElts
operator|+
name|CurSize
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|Capacity
operator|=
name|Begin
operator|+
name|NewCapacity
expr_stmt|;
end_expr_stmt

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|T
operator|>
name|void
name|SmallVectorImpl
operator|<
name|T
operator|>
operator|::
name|swap
argument_list|(
argument|SmallVectorImpl<T>&RHS
argument_list|)
block|{
if|if
condition|(
name|this
operator|==
operator|&
name|RHS
condition|)
return|return;
end_expr_stmt

begin_comment
comment|// We can only avoid copying elements if neither vector is small.
end_comment

begin_if
if|if
condition|(
operator|!
name|isSmall
argument_list|()
operator|&&
operator|!
name|RHS
operator|.
name|isSmall
argument_list|()
condition|)
block|{
name|std
operator|::
name|swap
argument_list|(
name|Begin
argument_list|,
name|RHS
operator|.
name|Begin
argument_list|)
expr_stmt|;
name|std
operator|::
name|swap
argument_list|(
name|End
argument_list|,
name|RHS
operator|.
name|End
argument_list|)
expr_stmt|;
name|std
operator|::
name|swap
argument_list|(
name|Capacity
argument_list|,
name|RHS
operator|.
name|Capacity
argument_list|)
expr_stmt|;
return|return;
block|}
end_if

begin_if
if|if
condition|(
name|RHS
operator|.
name|size
argument_list|()
operator|>
name|size_type
argument_list|(
name|Capacity
operator|-
name|Begin
argument_list|)
condition|)
name|grow
argument_list|(
name|RHS
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
end_if

begin_if
if|if
condition|(
name|size
argument_list|()
operator|>
name|size_type
argument_list|(
name|RHS
operator|.
name|Capacity
operator|-
name|RHS
operator|.
name|begin
argument_list|()
argument_list|)
condition|)
name|RHS
operator|.
name|grow
argument_list|(
name|size
argument_list|()
argument_list|)
expr_stmt|;
end_if

begin_comment
comment|// Swap the shared elements.
end_comment

begin_decl_stmt
name|size_t
name|NumShared
init|=
name|size
argument_list|()
decl_stmt|;
end_decl_stmt

begin_if
if|if
condition|(
name|NumShared
operator|>
name|RHS
operator|.
name|size
argument_list|()
condition|)
name|NumShared
operator|=
name|RHS
operator|.
name|size
argument_list|()
expr_stmt|;
end_if

begin_for
for|for
control|(
name|unsigned
name|i
init|=
literal|0
init|;
name|i
operator|!=
name|static_cast
operator|<
name|unsigned
operator|>
operator|(
name|NumShared
operator|)
condition|;
operator|++
name|i
control|)
name|std
operator|::
name|swap
argument_list|(
name|Begin
index|[
name|i
index|]
argument_list|,
name|RHS
index|[
name|i
index|]
argument_list|)
expr_stmt|;
end_for

begin_comment
comment|// Copy over the extra elts.
end_comment

begin_if
if|if
condition|(
name|size
argument_list|()
operator|>
name|RHS
operator|.
name|size
argument_list|()
condition|)
block|{
name|size_t
name|EltDiff
init|=
name|size
argument_list|()
operator|-
name|RHS
operator|.
name|size
argument_list|()
decl_stmt|;
name|std
operator|::
name|uninitialized_copy
argument_list|(
name|Begin
operator|+
name|NumShared
argument_list|,
name|End
argument_list|,
name|RHS
operator|.
name|End
argument_list|)
expr_stmt|;
name|RHS
operator|.
name|End
operator|+=
name|EltDiff
expr_stmt|;
name|destroy_range
argument_list|(
name|Begin
operator|+
name|NumShared
argument_list|,
name|End
argument_list|)
expr_stmt|;
name|End
operator|=
name|Begin
operator|+
name|NumShared
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|RHS
operator|.
name|size
argument_list|()
operator|>
name|size
argument_list|()
condition|)
block|{
name|size_t
name|EltDiff
init|=
name|RHS
operator|.
name|size
argument_list|()
operator|-
name|size
argument_list|()
decl_stmt|;
name|std
operator|::
name|uninitialized_copy
argument_list|(
name|RHS
operator|.
name|Begin
operator|+
name|NumShared
argument_list|,
name|RHS
operator|.
name|End
argument_list|,
name|End
argument_list|)
expr_stmt|;
name|End
operator|+=
name|EltDiff
expr_stmt|;
name|destroy_range
argument_list|(
name|RHS
operator|.
name|Begin
operator|+
name|NumShared
argument_list|,
name|RHS
operator|.
name|End
argument_list|)
expr_stmt|;
name|RHS
operator|.
name|End
operator|=
name|RHS
operator|.
name|Begin
operator|+
name|NumShared
expr_stmt|;
block|}
end_if

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|T
operator|>
specifier|const
name|SmallVectorImpl
operator|<
name|T
operator|>
operator|&
name|SmallVectorImpl
operator|<
name|T
operator|>
operator|::
name|operator
operator|=
operator|(
specifier|const
name|SmallVectorImpl
operator|<
name|T
operator|>
operator|&
name|RHS
operator|)
block|{
comment|// Avoid self-assignment.
if|if
condition|(
name|this
operator|==
operator|&
name|RHS
condition|)
return|return
operator|*
name|this
return|;
comment|// If we already have sufficient space, assign the common elements, then
comment|// destroy any excess.
name|unsigned
name|RHSSize
operator|=
name|unsigned
argument_list|(
name|RHS
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|unsigned
name|CurSize
init|=
name|unsigned
argument_list|(
name|size
argument_list|()
argument_list|)
decl_stmt|;
end_decl_stmt

begin_if
if|if
condition|(
name|CurSize
operator|>=
name|RHSSize
condition|)
block|{
comment|// Assign common elements.
name|iterator
name|NewEnd
decl_stmt|;
if|if
condition|(
name|RHSSize
condition|)
name|NewEnd
operator|=
name|std
operator|::
name|copy
argument_list|(
name|RHS
operator|.
name|Begin
argument_list|,
name|RHS
operator|.
name|Begin
operator|+
name|RHSSize
argument_list|,
name|Begin
argument_list|)
expr_stmt|;
else|else
name|NewEnd
operator|=
name|Begin
expr_stmt|;
comment|// Destroy excess elements.
name|destroy_range
argument_list|(
name|NewEnd
argument_list|,
name|End
argument_list|)
expr_stmt|;
comment|// Trim.
name|End
operator|=
name|NewEnd
expr_stmt|;
return|return
operator|*
name|this
return|;
block|}
end_if

begin_comment
comment|// If we have to grow to have enough elements, destroy the current elements.
end_comment

begin_comment
comment|// This allows us to avoid copying them during the grow.
end_comment

begin_if
if|if
condition|(
name|unsigned
argument_list|(
name|Capacity
operator|-
name|Begin
argument_list|)
operator|<
name|RHSSize
condition|)
block|{
comment|// Destroy current elements.
name|destroy_range
argument_list|(
name|Begin
argument_list|,
name|End
argument_list|)
expr_stmt|;
name|End
operator|=
name|Begin
expr_stmt|;
name|CurSize
operator|=
literal|0
expr_stmt|;
name|grow
argument_list|(
name|RHSSize
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|CurSize
condition|)
block|{
comment|// Otherwise, use assignment for the already-constructed elements.
name|std
operator|::
name|copy
argument_list|(
name|RHS
operator|.
name|Begin
argument_list|,
name|RHS
operator|.
name|Begin
operator|+
name|CurSize
argument_list|,
name|Begin
argument_list|)
expr_stmt|;
block|}
end_if

begin_comment
comment|// Copy construct the new elements in place.
end_comment

begin_expr_stmt
name|std
operator|::
name|uninitialized_copy
argument_list|(
name|RHS
operator|.
name|Begin
operator|+
name|CurSize
argument_list|,
name|RHS
operator|.
name|End
argument_list|,
name|Begin
operator|+
name|CurSize
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|// Set end.
end_comment

begin_expr_stmt
name|End
operator|=
name|Begin
operator|+
name|RHSSize
expr_stmt|;
end_expr_stmt

begin_return
return|return
operator|*
name|this
return|;
end_return

begin_comment
unit|}
comment|/// SmallVector - This is a 'vector' (really, a variable-sized array), optimized
end_comment

begin_comment
comment|/// for the case when the array is small.  It contains some number of elements
end_comment

begin_comment
comment|/// in-place, which allows it to avoid heap allocation when the actual number of
end_comment

begin_comment
comment|/// elements is below that threshold.  This allows normal "small" cases to be
end_comment

begin_comment
comment|/// fast without losing generality for large inputs.
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|/// Note that this does not attempt to be exception safe.
end_comment

begin_comment
comment|///
end_comment

begin_expr_stmt
unit|template
operator|<
name|typename
name|T
operator|,
name|unsigned
name|N
operator|>
name|class
name|SmallVector
operator|:
name|public
name|SmallVectorImpl
operator|<
name|T
operator|>
block|{
comment|/// InlineElts - These are 'N-1' elements that are stored inline in the body
comment|/// of the vector.  The extra '1' element is stored in SmallVectorImpl.
typedef|typedef
name|typename
name|SmallVectorImpl
operator|<
name|T
operator|>
operator|::
name|U
name|U
expr_stmt|;
block|enum
block|{
comment|// MinUs - The number of U's require to cover N T's.
name|MinUs
operator|=
operator|(
name|static_cast
operator|<
name|unsigned
name|int
operator|>
operator|(
sizeof|sizeof
argument_list|(
name|T
argument_list|)
operator|)
operator|*
name|N
operator|+
name|static_cast
operator|<
name|unsigned
name|int
operator|>
operator|(
sizeof|sizeof
argument_list|(
name|U
argument_list|)
operator|)
operator|-
literal|1
operator|)
operator|/
name|static_cast
operator|<
name|unsigned
name|int
operator|>
operator|(
sizeof|sizeof
argument_list|(
name|U
argument_list|)
operator|)
block|,
comment|// NumInlineEltsElts - The number of elements actually in this array.  There
comment|// is already one in the parent class, and we have to round up to avoid
comment|// having a zero-element array.
name|NumInlineEltsElts
operator|=
name|MinUs
operator|>
literal|1
operator|?
operator|(
name|MinUs
operator|-
literal|1
operator|)
operator|:
literal|1
block|,
comment|// NumTsAvailable - The number of T's we actually have space for, which may
comment|// be more than N due to rounding.
name|NumTsAvailable
operator|=
operator|(
name|NumInlineEltsElts
operator|+
literal|1
operator|)
operator|*
name|static_cast
operator|<
name|unsigned
name|int
operator|>
operator|(
sizeof|sizeof
argument_list|(
name|U
argument_list|)
operator|)
operator|/
name|static_cast
operator|<
name|unsigned
name|int
operator|>
operator|(
sizeof|sizeof
argument_list|(
name|T
argument_list|)
operator|)
block|}
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|U
name|InlineElts
index|[
name|NumInlineEltsElts
index|]
decl_stmt|;
end_decl_stmt

begin_label
name|public
label|:
end_label

begin_expr_stmt
name|SmallVector
argument_list|()
operator|:
name|SmallVectorImpl
operator|<
name|T
operator|>
operator|(
name|NumTsAvailable
operator|)
block|{   }
name|explicit
name|SmallVector
argument_list|(
argument|unsigned Size
argument_list|,
argument|const T&Value = T()
argument_list|)
operator|:
name|SmallVectorImpl
operator|<
name|T
operator|>
operator|(
name|NumTsAvailable
operator|)
block|{
name|this
operator|->
name|reserve
argument_list|(
name|Size
argument_list|)
block|;
while|while
condition|(
name|Size
operator|--
condition|)
name|this
operator|->
name|push_back
argument_list|(
name|Value
argument_list|)
expr_stmt|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|ItTy
operator|>
name|SmallVector
argument_list|(
argument|ItTy S
argument_list|,
argument|ItTy E
argument_list|)
operator|:
name|SmallVectorImpl
operator|<
name|T
operator|>
operator|(
name|NumTsAvailable
operator|)
block|{
name|this
operator|->
name|append
argument_list|(
name|S
argument_list|,
name|E
argument_list|)
block|;   }
name|SmallVector
argument_list|(
specifier|const
name|SmallVector
operator|&
name|RHS
argument_list|)
operator|:
name|SmallVectorImpl
operator|<
name|T
operator|>
operator|(
name|NumTsAvailable
operator|)
block|{
if|if
condition|(
operator|!
name|RHS
operator|.
name|empty
argument_list|()
condition|)
name|SmallVectorImpl
operator|<
name|T
operator|>
operator|::
name|operator
operator|=
operator|(
name|RHS
operator|)
expr_stmt|;
block|}
end_expr_stmt

begin_decl_stmt
specifier|const
name|SmallVector
modifier|&
name|operator
init|=
operator|(
specifier|const
name|SmallVector
operator|&
name|RHS
operator|)
block|{
name|SmallVectorImpl
operator|<
name|T
operator|>
operator|::
name|operator
operator|=
operator|(
name|RHS
operator|)
block|;
return|return
operator|*
name|this
return|;
block|}
end_decl_stmt

begin_comment
unit|};  }
comment|// End llvm namespace
end_comment

begin_macro
unit|namespace
name|std
end_macro

begin_block
block|{
comment|/// Implement std::swap in terms of SmallVector swap.
name|template
operator|<
name|typename
name|T
operator|>
specifier|inline
name|void
name|swap
argument_list|(
argument|llvm::SmallVectorImpl<T>&LHS
argument_list|,
argument|llvm::SmallVectorImpl<T>&RHS
argument_list|)
block|{
name|LHS
operator|.
name|swap
argument_list|(
name|RHS
argument_list|)
block|;   }
comment|/// Implement std::swap in terms of SmallVector swap.
name|template
operator|<
name|typename
name|T
operator|,
name|unsigned
name|N
operator|>
specifier|inline
name|void
name|swap
argument_list|(
argument|llvm::SmallVector<T
argument_list|,
argument|N>&LHS
argument_list|,
argument|llvm::SmallVector<T
argument_list|,
argument|N>&RHS
argument_list|)
block|{
name|LHS
operator|.
name|swap
argument_list|(
name|RHS
argument_list|)
block|;   }
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

end_unit

