begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===- llvm/ADT/SmallVector.h - 'Normally small' vectors --------*- C++ -*-===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file defines the SmallVector class.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LLVM_ADT_SMALLVECTOR_H
end_ifndef

begin_define
define|#
directive|define
name|LLVM_ADT_SMALLVECTOR_H
end_define

begin_include
include|#
directive|include
file|"llvm/Support/type_traits.h"
end_include

begin_include
include|#
directive|include
file|<algorithm>
end_include

begin_include
include|#
directive|include
file|<cassert>
end_include

begin_include
include|#
directive|include
file|<cstring>
end_include

begin_include
include|#
directive|include
file|<memory>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|_MSC_VER
end_ifdef

begin_decl_stmt
name|namespace
name|std
block|{
if|#
directive|if
name|_MSC_VER
operator|<=
literal|1310
comment|// Work around flawed VC++ implementation of std::uninitialized_copy.  Define
comment|// additional overloads so that elements with pointer types are recognized as
comment|// scalars and not objects, causing bizarre type conversion errors.
name|template
operator|<
name|class
name|T1
operator|,
name|class
name|T2
operator|>
specifier|inline
name|_Scalar_ptr_iterator_tag
name|_Ptr_cat
argument_list|(
argument|T1 **
argument_list|,
argument|T2 **
argument_list|)
block|{
name|_Scalar_ptr_iterator_tag
name|_Cat
block|;
return|return
name|_Cat
return|;
block|}
name|template
operator|<
name|class
name|T1
operator|,
name|class
name|T2
operator|>
specifier|inline
name|_Scalar_ptr_iterator_tag
name|_Ptr_cat
argument_list|(
argument|T1* const *
argument_list|,
argument|T2 **
argument_list|)
block|{
name|_Scalar_ptr_iterator_tag
name|_Cat
block|;
return|return
name|_Cat
return|;
block|}
else|#
directive|else
comment|// FIXME: It is not clear if the problem is fixed in VS 2005.  What is clear
comment|// is that the above hack won't work if it wasn't fixed.
endif|#
directive|endif
block|}
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|namespace
name|llvm
block|{
comment|/// SmallVectorBase - This is all the non-templated stuff common to all
comment|/// SmallVectors.
name|class
name|SmallVectorBase
block|{
name|protected
label|:
name|void
modifier|*
name|BeginX
decl_stmt|,
modifier|*
name|EndX
decl_stmt|,
modifier|*
name|CapacityX
decl_stmt|;
comment|// Allocate raw space for N elements of type T.  If T has a ctor or dtor, we
comment|// don't want it to be automatically run, so we need to represent the space as
comment|// something else.  An array of char would work great, but might not be
comment|// aligned sufficiently.  Instead, we either use GCC extensions, or some
comment|// number of union instances for the space, which guarantee maximal alignment.
struct|struct
name|U
block|{
ifdef|#
directive|ifdef
name|__GNUC__
name|char
name|X
name|__attribute__
argument_list|(
operator|(
name|aligned
argument_list|(
literal|8
argument_list|)
operator|)
argument_list|)
decl_stmt|;
else|#
directive|else
union|union
block|{
name|double
name|D
decl_stmt|;
name|long
name|double
name|LD
decl_stmt|;
name|long
name|long
name|L
decl_stmt|;
name|void
modifier|*
name|P
decl_stmt|;
block|}
name|X
union|;
endif|#
directive|endif
block|}
name|FirstEl
struct|;
comment|// Space after 'FirstEl' is clobbered, do not add any instance vars after it.
name|protected
label|:
name|SmallVectorBase
argument_list|(
argument|size_t Size
argument_list|)
block|:
name|BeginX
argument_list|(
operator|&
name|FirstEl
argument_list|)
operator|,
name|EndX
argument_list|(
operator|&
name|FirstEl
argument_list|)
operator|,
name|CapacityX
argument_list|(
argument|(char*)&FirstEl+Size
argument_list|)
block|{}
comment|/// isSmall - Return true if this is a smallvector which has not had dynamic
comment|/// memory allocated for it.
name|bool
name|isSmall
argument_list|()
specifier|const
block|{
return|return
name|BeginX
operator|==
name|static_cast
operator|<
specifier|const
name|void
operator|*
operator|>
operator|(
operator|&
name|FirstEl
operator|)
return|;
block|}
comment|/// size_in_bytes - This returns size()*sizeof(T).
name|size_t
name|size_in_bytes
argument_list|()
specifier|const
block|{
return|return
name|size_t
argument_list|(
operator|(
name|char
operator|*
operator|)
name|EndX
operator|-
operator|(
name|char
operator|*
operator|)
name|BeginX
argument_list|)
return|;
block|}
comment|/// capacity_in_bytes - This returns capacity()*sizeof(T).
name|size_t
name|capacity_in_bytes
argument_list|()
specifier|const
block|{
return|return
name|size_t
argument_list|(
operator|(
name|char
operator|*
operator|)
name|CapacityX
operator|-
operator|(
name|char
operator|*
operator|)
name|BeginX
argument_list|)
return|;
block|}
comment|/// grow_pod - This is an implementation of the grow() method which only works
comment|/// on POD-like datatypes and is out of line to reduce code duplication.
name|void
name|grow_pod
parameter_list|(
name|size_t
name|MinSizeInBytes
parameter_list|,
name|size_t
name|TSize
parameter_list|)
function_decl|;
name|public
label|:
name|bool
name|empty
argument_list|()
specifier|const
block|{
return|return
name|BeginX
operator|==
name|EndX
return|;
block|}
block|}
empty_stmt|;
name|template
operator|<
name|typename
name|T
operator|>
name|class
name|SmallVectorTemplateCommon
operator|:
name|public
name|SmallVectorBase
block|{
name|protected
operator|:
name|void
name|setEnd
argument_list|(
argument|T *P
argument_list|)
block|{
name|this
operator|->
name|EndX
operator|=
name|P
block|; }
name|public
operator|:
name|SmallVectorTemplateCommon
argument_list|(
argument|size_t Size
argument_list|)
operator|:
name|SmallVectorBase
argument_list|(
argument|Size
argument_list|)
block|{}
typedef|typedef
name|size_t
name|size_type
typedef|;
typedef|typedef
name|ptrdiff_t
name|difference_type
typedef|;
typedef|typedef
name|T
name|value_type
typedef|;
typedef|typedef
name|T
modifier|*
name|iterator
typedef|;
typedef|typedef
specifier|const
name|T
modifier|*
name|const_iterator
typedef|;
typedef|typedef
name|std
operator|::
name|reverse_iterator
operator|<
name|const_iterator
operator|>
name|const_reverse_iterator
expr_stmt|;
typedef|typedef
name|std
operator|::
name|reverse_iterator
operator|<
name|iterator
operator|>
name|reverse_iterator
expr_stmt|;
typedef|typedef
name|T
modifier|&
name|reference
typedef|;
typedef|typedef
specifier|const
name|T
modifier|&
name|const_reference
typedef|;
typedef|typedef
name|T
modifier|*
name|pointer
typedef|;
typedef|typedef
specifier|const
name|T
modifier|*
name|const_pointer
typedef|;
comment|// forward iterator creation methods.
name|iterator
name|begin
parameter_list|()
block|{
return|return
operator|(
name|iterator
operator|)
name|this
operator|->
name|BeginX
return|;
block|}
name|const_iterator
name|begin
argument_list|()
specifier|const
block|{
return|return
operator|(
name|const_iterator
operator|)
name|this
operator|->
name|BeginX
return|;
block|}
name|iterator
name|end
parameter_list|()
block|{
return|return
operator|(
name|iterator
operator|)
name|this
operator|->
name|EndX
return|;
block|}
name|const_iterator
name|end
argument_list|()
specifier|const
block|{
return|return
operator|(
name|const_iterator
operator|)
name|this
operator|->
name|EndX
return|;
block|}
name|protected
label|:
name|iterator
name|capacity_ptr
parameter_list|()
block|{
return|return
operator|(
name|iterator
operator|)
name|this
operator|->
name|CapacityX
return|;
block|}
name|const_iterator
name|capacity_ptr
argument_list|()
specifier|const
block|{
return|return
operator|(
name|const_iterator
operator|)
name|this
operator|->
name|CapacityX
return|;
block|}
name|public
label|:
comment|// reverse iterator creation methods.
name|reverse_iterator
name|rbegin
parameter_list|()
block|{
return|return
name|reverse_iterator
argument_list|(
name|end
argument_list|()
argument_list|)
return|;
block|}
name|const_reverse_iterator
name|rbegin
argument_list|()
specifier|const
block|{
return|return
name|const_reverse_iterator
argument_list|(
name|end
argument_list|()
argument_list|)
return|;
block|}
name|reverse_iterator
name|rend
parameter_list|()
block|{
return|return
name|reverse_iterator
argument_list|(
name|begin
argument_list|()
argument_list|)
return|;
block|}
name|const_reverse_iterator
name|rend
argument_list|()
specifier|const
block|{
return|return
name|const_reverse_iterator
argument_list|(
name|begin
argument_list|()
argument_list|)
return|;
block|}
name|size_type
name|size
argument_list|()
specifier|const
block|{
return|return
name|end
argument_list|()
operator|-
name|begin
argument_list|()
return|;
block|}
name|size_type
name|max_size
argument_list|()
specifier|const
block|{
return|return
name|size_type
argument_list|(
operator|-
literal|1
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|T
argument_list|)
return|;
block|}
comment|/// capacity - Return the total number of elements in the currently allocated
comment|/// buffer.
name|size_t
name|capacity
argument_list|()
specifier|const
block|{
return|return
name|capacity_ptr
argument_list|()
operator|-
name|begin
argument_list|()
return|;
block|}
comment|/// data - Return a pointer to the vector's buffer, even if empty().
name|pointer
name|data
parameter_list|()
block|{
return|return
name|pointer
argument_list|(
name|begin
argument_list|()
argument_list|)
return|;
block|}
comment|/// data - Return a pointer to the vector's buffer, even if empty().
name|const_pointer
name|data
argument_list|()
specifier|const
block|{
return|return
name|const_pointer
argument_list|(
name|begin
argument_list|()
argument_list|)
return|;
block|}
name|reference
name|operator
function|[]
parameter_list|(
name|unsigned
name|idx
parameter_list|)
block|{
name|assert
argument_list|(
name|begin
argument_list|()
operator|+
name|idx
operator|<
name|end
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|begin
argument_list|()
index|[
name|idx
index|]
return|;
block|}
name|const_reference
name|operator
index|[]
argument_list|(
name|unsigned
name|idx
argument_list|)
decl|const
block|{
name|assert
argument_list|(
name|begin
argument_list|()
operator|+
name|idx
operator|<
name|end
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|begin
argument_list|()
index|[
name|idx
index|]
return|;
block|}
name|reference
name|front
parameter_list|()
block|{
return|return
name|begin
argument_list|()
index|[
literal|0
index|]
return|;
block|}
name|const_reference
name|front
argument_list|()
specifier|const
block|{
return|return
name|begin
argument_list|()
index|[
literal|0
index|]
return|;
block|}
name|reference
name|back
parameter_list|()
block|{
return|return
name|end
argument_list|()
index|[
operator|-
literal|1
index|]
return|;
block|}
name|const_reference
name|back
argument_list|()
specifier|const
block|{
return|return
name|end
argument_list|()
index|[
operator|-
literal|1
index|]
return|;
block|}
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_comment
comment|/// SmallVectorTemplateBase<isPodLike = false> - This is where we put method
end_comment

begin_comment
comment|/// implementations that are designed to work with non-POD-like T's.
end_comment

begin_expr_stmt
name|template
operator|<
name|typename
name|T
operator|,
name|bool
name|isPodLike
operator|>
name|class
name|SmallVectorTemplateBase
operator|:
name|public
name|SmallVectorTemplateCommon
operator|<
name|T
operator|>
block|{
name|public
operator|:
name|SmallVectorTemplateBase
argument_list|(
argument|size_t Size
argument_list|)
operator|:
name|SmallVectorTemplateCommon
operator|<
name|T
operator|>
operator|(
name|Size
operator|)
block|{}
specifier|static
name|void
name|destroy_range
argument_list|(
argument|T *S
argument_list|,
argument|T *E
argument_list|)
block|{
while|while
condition|(
name|S
operator|!=
name|E
condition|)
block|{
operator|--
name|E
expr_stmt|;
name|E
operator|->
expr|~
name|T
argument_list|()
expr_stmt|;
block|}
block|}
comment|/// uninitialized_copy - Copy the range [I, E) onto the uninitialized memory
comment|/// starting with "Dest", constructing elements into it as needed.
name|template
operator|<
name|typename
name|It1
operator|,
name|typename
name|It2
operator|>
specifier|static
name|void
name|uninitialized_copy
argument_list|(
argument|It1 I
argument_list|,
argument|It1 E
argument_list|,
argument|It2 Dest
argument_list|)
block|{
name|std
operator|::
name|uninitialized_copy
argument_list|(
name|I
argument_list|,
name|E
argument_list|,
name|Dest
argument_list|)
block|;   }
comment|/// grow - double the size of the allocated memory, guaranteeing space for at
comment|/// least one more element or MinSize if specified.
name|void
name|grow
argument_list|(
argument|size_t MinSize =
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
unit|};
comment|// Define this out-of-line to dissuade the C++ compiler from inlining it.
end_comment

begin_expr_stmt
name|template
operator|<
name|typename
name|T
operator|,
name|bool
name|isPodLike
operator|>
name|void
name|SmallVectorTemplateBase
operator|<
name|T
operator|,
name|isPodLike
operator|>
operator|::
name|grow
argument_list|(
argument|size_t MinSize
argument_list|)
block|{
name|size_t
name|CurCapacity
operator|=
name|this
operator|->
name|capacity
argument_list|()
block|;
name|size_t
name|CurSize
operator|=
name|this
operator|->
name|size
argument_list|()
block|;
name|size_t
name|NewCapacity
operator|=
literal|2
operator|*
name|CurCapacity
block|;
if|if
condition|(
name|NewCapacity
operator|<
name|MinSize
condition|)
name|NewCapacity
operator|=
name|MinSize
expr_stmt|;
name|T
operator|*
name|NewElts
operator|=
name|static_cast
operator|<
name|T
operator|*
operator|>
operator|(
name|operator
name|new
argument_list|(
name|NewCapacity
operator|*
sizeof|sizeof
argument_list|(
name|T
argument_list|)
argument_list|)
operator|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|// Copy the elements over.
end_comment

begin_expr_stmt
name|this
operator|->
name|uninitialized_copy
argument_list|(
name|this
operator|->
name|begin
argument_list|()
argument_list|,
name|this
operator|->
name|end
argument_list|()
argument_list|,
name|NewElts
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|// Destroy the original elements.
end_comment

begin_expr_stmt
name|destroy_range
argument_list|(
name|this
operator|->
name|begin
argument_list|()
argument_list|,
name|this
operator|->
name|end
argument_list|()
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|// If this wasn't grown from the inline copy, deallocate the old space.
end_comment

begin_if
if|if
condition|(
operator|!
name|this
operator|->
name|isSmall
argument_list|()
condition|)
name|operator
name|delete
argument_list|(
name|this
operator|->
name|begin
argument_list|()
argument_list|)
decl_stmt|;
end_if

begin_expr_stmt
name|this
operator|->
name|setEnd
argument_list|(
name|NewElts
operator|+
name|CurSize
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|this
operator|->
name|BeginX
operator|=
name|NewElts
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|this
operator|->
name|CapacityX
operator|=
name|this
operator|->
name|begin
argument_list|()
operator|+
name|NewCapacity
expr_stmt|;
end_expr_stmt

begin_comment
unit|}
comment|/// SmallVectorTemplateBase<isPodLike = true> - This is where we put method
end_comment

begin_comment
comment|/// implementations that are designed to work with POD-like T's.
end_comment

begin_expr_stmt
unit|template
operator|<
name|typename
name|T
operator|>
name|class
name|SmallVectorTemplateBase
operator|<
name|T
operator|,
name|true
operator|>
operator|:
name|public
name|SmallVectorTemplateCommon
operator|<
name|T
operator|>
block|{
name|public
operator|:
name|SmallVectorTemplateBase
argument_list|(
argument|size_t Size
argument_list|)
operator|:
name|SmallVectorTemplateCommon
operator|<
name|T
operator|>
operator|(
name|Size
operator|)
block|{}
comment|// No need to do a destroy loop for POD's.
specifier|static
name|void
name|destroy_range
argument_list|(
argument|T *
argument_list|,
argument|T *
argument_list|)
block|{}
comment|/// uninitialized_copy - Copy the range [I, E) onto the uninitialized memory
comment|/// starting with "Dest", constructing elements into it as needed.
name|template
operator|<
name|typename
name|It1
block|,
name|typename
name|It2
operator|>
specifier|static
name|void
name|uninitialized_copy
argument_list|(
argument|It1 I
argument_list|,
argument|It1 E
argument_list|,
argument|It2 Dest
argument_list|)
block|{
comment|// Arbitrary iterator types; just use the basic implementation.
name|std
operator|::
name|uninitialized_copy
argument_list|(
name|I
argument_list|,
name|E
argument_list|,
name|Dest
argument_list|)
block|;   }
comment|/// uninitialized_copy - Copy the range [I, E) onto the uninitialized memory
comment|/// starting with "Dest", constructing elements into it as needed.
name|template
operator|<
name|typename
name|T1
block|,
name|typename
name|T2
operator|>
specifier|static
name|void
name|uninitialized_copy
argument_list|(
argument|T1 *I
argument_list|,
argument|T1 *E
argument_list|,
argument|T2 *Dest
argument_list|)
block|{
comment|// Use memcpy for PODs iterated by pointers (which includes SmallVector
comment|// iterators): std::uninitialized_copy optimizes to memmove, but we can
comment|// use memcpy here.
name|memcpy
argument_list|(
name|Dest
argument_list|,
name|I
argument_list|,
operator|(
name|E
operator|-
name|I
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|T
argument_list|)
argument_list|)
block|;   }
comment|/// grow - double the size of the allocated memory, guaranteeing space for at
comment|/// least one more element or MinSize if specified.
name|void
name|grow
argument_list|(
argument|size_t MinSize =
literal|0
argument_list|)
block|{
name|this
operator|->
name|grow_pod
argument_list|(
name|MinSize
operator|*
sizeof|sizeof
argument_list|(
name|T
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|T
argument_list|)
argument_list|)
block|;   }
block|}
expr_stmt|;
end_expr_stmt

begin_comment
comment|/// SmallVectorImpl - This class consists of common code factored out of the
end_comment

begin_comment
comment|/// SmallVector class to reduce code duplication based on the SmallVector 'N'
end_comment

begin_comment
comment|/// template parameter.
end_comment

begin_expr_stmt
name|template
operator|<
name|typename
name|T
operator|>
name|class
name|SmallVectorImpl
operator|:
name|public
name|SmallVectorTemplateBase
operator|<
name|T
operator|,
name|isPodLike
operator|<
name|T
operator|>
operator|::
name|value
operator|>
block|{
typedef|typedef
name|SmallVectorTemplateBase
operator|<
name|T
operator|,
name|isPodLike
operator|<
name|T
operator|>
operator|::
name|value
operator|>
name|SuperClass
expr_stmt|;
name|public
operator|:
end_expr_stmt

begin_typedef
typedef|typedef
name|typename
name|SuperClass
operator|::
name|iterator
name|iterator
expr_stmt|;
end_typedef

begin_typedef
typedef|typedef
name|typename
name|SuperClass
operator|::
name|size_type
name|size_type
expr_stmt|;
end_typedef

begin_comment
comment|// Default ctor - Initialize to empty.
end_comment

begin_macro
name|explicit
end_macro

begin_macro
name|SmallVectorImpl
argument_list|(
argument|unsigned N
argument_list|)
end_macro

begin_expr_stmt
unit|:
name|SmallVectorTemplateBase
operator|<
name|T
operator|,
name|isPodLike
operator|<
name|T
operator|>
operator|::
name|value
operator|>
operator|(
name|N
operator|*
sizeof|sizeof
argument_list|(
name|T
argument_list|)
operator|)
block|{   }
operator|~
name|SmallVectorImpl
argument_list|()
block|{
comment|// Destroy the constructed elements in the vector.
name|this
operator|->
name|destroy_range
argument_list|(
name|this
operator|->
name|begin
argument_list|()
argument_list|,
name|this
operator|->
name|end
argument_list|()
argument_list|)
block|;
comment|// If this wasn't grown from the inline copy, deallocate the old space.
if|if
condition|(
operator|!
name|this
operator|->
name|isSmall
argument_list|()
condition|)
name|operator
name|delete
argument_list|(
name|this
operator|->
name|begin
argument_list|()
argument_list|)
decl_stmt|;
block|}
end_expr_stmt

begin_function
name|void
name|clear
parameter_list|()
block|{
name|this
operator|->
name|destroy_range
argument_list|(
name|this
operator|->
name|begin
argument_list|()
argument_list|,
name|this
operator|->
name|end
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|->
name|EndX
operator|=
name|this
operator|->
name|BeginX
expr_stmt|;
block|}
end_function

begin_function
name|void
name|resize
parameter_list|(
name|unsigned
name|N
parameter_list|)
block|{
if|if
condition|(
name|N
operator|<
name|this
operator|->
name|size
argument_list|()
condition|)
block|{
name|this
operator|->
name|destroy_range
argument_list|(
name|this
operator|->
name|begin
argument_list|()
operator|+
name|N
argument_list|,
name|this
operator|->
name|end
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|->
name|setEnd
argument_list|(
name|this
operator|->
name|begin
argument_list|()
operator|+
name|N
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|N
operator|>
name|this
operator|->
name|size
argument_list|()
condition|)
block|{
if|if
condition|(
name|this
operator|->
name|capacity
argument_list|()
operator|<
name|N
condition|)
name|this
operator|->
name|grow
argument_list|(
name|N
argument_list|)
expr_stmt|;
name|this
operator|->
name|construct_range
argument_list|(
name|this
operator|->
name|end
argument_list|()
argument_list|,
name|this
operator|->
name|begin
argument_list|()
operator|+
name|N
argument_list|,
name|T
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|->
name|setEnd
argument_list|(
name|this
operator|->
name|begin
argument_list|()
operator|+
name|N
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|resize
parameter_list|(
name|unsigned
name|N
parameter_list|,
specifier|const
name|T
modifier|&
name|NV
parameter_list|)
block|{
if|if
condition|(
name|N
operator|<
name|this
operator|->
name|size
argument_list|()
condition|)
block|{
name|this
operator|->
name|destroy_range
argument_list|(
name|this
operator|->
name|begin
argument_list|()
operator|+
name|N
argument_list|,
name|this
operator|->
name|end
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|->
name|setEnd
argument_list|(
name|this
operator|->
name|begin
argument_list|()
operator|+
name|N
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|N
operator|>
name|this
operator|->
name|size
argument_list|()
condition|)
block|{
if|if
condition|(
name|this
operator|->
name|capacity
argument_list|()
operator|<
name|N
condition|)
name|this
operator|->
name|grow
argument_list|(
name|N
argument_list|)
expr_stmt|;
name|construct_range
argument_list|(
name|this
operator|->
name|end
argument_list|()
argument_list|,
name|this
operator|->
name|begin
argument_list|()
operator|+
name|N
argument_list|,
name|NV
argument_list|)
expr_stmt|;
name|this
operator|->
name|setEnd
argument_list|(
name|this
operator|->
name|begin
argument_list|()
operator|+
name|N
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|reserve
parameter_list|(
name|unsigned
name|N
parameter_list|)
block|{
if|if
condition|(
name|this
operator|->
name|capacity
argument_list|()
operator|<
name|N
condition|)
name|this
operator|->
name|grow
argument_list|(
name|N
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|push_back
parameter_list|(
specifier|const
name|T
modifier|&
name|Elt
parameter_list|)
block|{
if|if
condition|(
name|this
operator|->
name|EndX
operator|<
name|this
operator|->
name|CapacityX
condition|)
block|{
name|Retry
label|:
name|new
argument_list|(
argument|this->end()
argument_list|)
name|T
argument_list|(
name|Elt
argument_list|)
expr_stmt|;
name|this
operator|->
name|setEnd
argument_list|(
name|this
operator|->
name|end
argument_list|()
operator|+
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
name|this
operator|->
name|grow
argument_list|()
expr_stmt|;
goto|goto
name|Retry
goto|;
block|}
end_function

begin_function
name|void
name|pop_back
parameter_list|()
block|{
name|this
operator|->
name|setEnd
argument_list|(
name|this
operator|->
name|end
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
name|this
operator|->
name|end
argument_list|()
operator|->
operator|~
name|T
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|T
name|pop_back_val
parameter_list|()
block|{
name|T
name|Result
init|=
name|this
operator|->
name|back
argument_list|()
decl_stmt|;
name|pop_back
argument_list|()
expr_stmt|;
return|return
name|Result
return|;
block|}
end_function

begin_function_decl
name|void
name|swap
parameter_list|(
name|SmallVectorImpl
modifier|&
name|RHS
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/// append - Add the specified range to the end of the SmallVector.
end_comment

begin_comment
comment|///
end_comment

begin_expr_stmt
name|template
operator|<
name|typename
name|in_iter
operator|>
name|void
name|append
argument_list|(
argument|in_iter in_start
argument_list|,
argument|in_iter in_end
argument_list|)
block|{
name|size_type
name|NumInputs
operator|=
name|std
operator|::
name|distance
argument_list|(
name|in_start
argument_list|,
name|in_end
argument_list|)
block|;
comment|// Grow allocated space if needed.
if|if
condition|(
name|NumInputs
operator|>
name|size_type
argument_list|(
name|this
operator|->
name|capacity_ptr
argument_list|()
operator|-
name|this
operator|->
name|end
argument_list|()
argument_list|)
condition|)
name|this
operator|->
name|grow
argument_list|(
name|this
operator|->
name|size
argument_list|()
operator|+
name|NumInputs
argument_list|)
expr_stmt|;
comment|// Copy the new elements over.
comment|// TODO: NEED To compile time dispatch on whether in_iter is a random access
comment|// iterator to use the fast uninitialized_copy.
name|std
operator|::
name|uninitialized_copy
argument_list|(
name|in_start
argument_list|,
name|in_end
argument_list|,
name|this
operator|->
name|end
argument_list|()
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|this
operator|->
name|setEnd
argument_list|(
name|this
operator|->
name|end
argument_list|()
operator|+
name|NumInputs
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
unit|}
comment|/// append - Add the specified range to the end of the SmallVector.
end_comment

begin_comment
comment|///
end_comment

begin_macro
unit|void
name|append
argument_list|(
argument|size_type NumInputs
argument_list|,
argument|const T&Elt
argument_list|)
end_macro

begin_block
block|{
comment|// Grow allocated space if needed.
if|if
condition|(
name|NumInputs
operator|>
name|size_type
argument_list|(
name|this
operator|->
name|capacity_ptr
argument_list|()
operator|-
name|this
operator|->
name|end
argument_list|()
argument_list|)
condition|)
name|this
operator|->
name|grow
argument_list|(
name|this
operator|->
name|size
argument_list|()
operator|+
name|NumInputs
argument_list|)
expr_stmt|;
comment|// Copy the new elements over.
name|std
operator|::
name|uninitialized_fill_n
argument_list|(
name|this
operator|->
name|end
argument_list|()
argument_list|,
name|NumInputs
argument_list|,
name|Elt
argument_list|)
expr_stmt|;
name|this
operator|->
name|setEnd
argument_list|(
name|this
operator|->
name|end
argument_list|()
operator|+
name|NumInputs
argument_list|)
expr_stmt|;
block|}
end_block

begin_function
name|void
name|assign
parameter_list|(
name|unsigned
name|NumElts
parameter_list|,
specifier|const
name|T
modifier|&
name|Elt
parameter_list|)
block|{
name|clear
argument_list|()
expr_stmt|;
if|if
condition|(
name|this
operator|->
name|capacity
argument_list|()
operator|<
name|NumElts
condition|)
name|this
operator|->
name|grow
argument_list|(
name|NumElts
argument_list|)
expr_stmt|;
name|this
operator|->
name|setEnd
argument_list|(
name|this
operator|->
name|begin
argument_list|()
operator|+
name|NumElts
argument_list|)
expr_stmt|;
name|construct_range
argument_list|(
name|this
operator|->
name|begin
argument_list|()
argument_list|,
name|this
operator|->
name|end
argument_list|()
argument_list|,
name|Elt
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|iterator
name|erase
parameter_list|(
name|iterator
name|I
parameter_list|)
block|{
name|iterator
name|N
init|=
name|I
decl_stmt|;
comment|// Shift all elts down one.
name|std
operator|::
name|copy
argument_list|(
name|I
operator|+
literal|1
argument_list|,
name|this
operator|->
name|end
argument_list|()
argument_list|,
name|I
argument_list|)
expr_stmt|;
comment|// Drop the last elt.
name|pop_back
argument_list|()
expr_stmt|;
return|return
operator|(
name|N
operator|)
return|;
block|}
end_function

begin_function
name|iterator
name|erase
parameter_list|(
name|iterator
name|S
parameter_list|,
name|iterator
name|E
parameter_list|)
block|{
name|iterator
name|N
init|=
name|S
decl_stmt|;
comment|// Shift all elts down.
name|iterator
name|I
init|=
name|std
operator|::
name|copy
argument_list|(
name|E
argument_list|,
name|this
operator|->
name|end
argument_list|()
argument_list|,
name|S
argument_list|)
decl_stmt|;
comment|// Drop the last elts.
name|this
operator|->
name|destroy_range
argument_list|(
name|I
argument_list|,
name|this
operator|->
name|end
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|->
name|setEnd
argument_list|(
name|I
argument_list|)
expr_stmt|;
return|return
operator|(
name|N
operator|)
return|;
block|}
end_function

begin_function
name|iterator
name|insert
parameter_list|(
name|iterator
name|I
parameter_list|,
specifier|const
name|T
modifier|&
name|Elt
parameter_list|)
block|{
if|if
condition|(
name|I
operator|==
name|this
operator|->
name|end
argument_list|()
condition|)
block|{
comment|// Important special case for empty vector.
name|push_back
argument_list|(
name|Elt
argument_list|)
expr_stmt|;
return|return
name|this
operator|->
name|end
argument_list|()
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|this
operator|->
name|EndX
operator|<
name|this
operator|->
name|CapacityX
condition|)
block|{
name|Retry
label|:
name|new
argument_list|(
argument|this->end()
argument_list|)
name|T
argument_list|(
name|this
operator|->
name|back
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|->
name|setEnd
argument_list|(
name|this
operator|->
name|end
argument_list|()
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|// Push everything else over.
name|std
operator|::
name|copy_backward
argument_list|(
name|I
argument_list|,
name|this
operator|->
name|end
argument_list|()
operator|-
literal|1
argument_list|,
name|this
operator|->
name|end
argument_list|()
argument_list|)
expr_stmt|;
operator|*
name|I
operator|=
name|Elt
expr_stmt|;
return|return
name|I
return|;
block|}
name|size_t
name|EltNo
init|=
name|I
operator|-
name|this
operator|->
name|begin
argument_list|()
decl_stmt|;
name|this
operator|->
name|grow
argument_list|()
expr_stmt|;
name|I
operator|=
name|this
operator|->
name|begin
argument_list|()
operator|+
name|EltNo
expr_stmt|;
goto|goto
name|Retry
goto|;
block|}
end_function

begin_function
name|iterator
name|insert
parameter_list|(
name|iterator
name|I
parameter_list|,
name|size_type
name|NumToInsert
parameter_list|,
specifier|const
name|T
modifier|&
name|Elt
parameter_list|)
block|{
if|if
condition|(
name|I
operator|==
name|this
operator|->
name|end
argument_list|()
condition|)
block|{
comment|// Important special case for empty vector.
name|append
argument_list|(
name|NumToInsert
argument_list|,
name|Elt
argument_list|)
expr_stmt|;
return|return
name|this
operator|->
name|end
argument_list|()
operator|-
literal|1
return|;
block|}
comment|// Convert iterator to elt# to avoid invalidating iterator when we reserve()
name|size_t
name|InsertElt
init|=
name|I
operator|-
name|this
operator|->
name|begin
argument_list|()
decl_stmt|;
comment|// Ensure there is enough space.
name|reserve
argument_list|(
name|static_cast
operator|<
name|unsigned
operator|>
operator|(
name|this
operator|->
name|size
argument_list|()
operator|+
name|NumToInsert
operator|)
argument_list|)
expr_stmt|;
comment|// Uninvalidate the iterator.
name|I
operator|=
name|this
operator|->
name|begin
argument_list|()
operator|+
name|InsertElt
expr_stmt|;
comment|// If there are more elements between the insertion point and the end of the
comment|// range than there are being inserted, we can use a simple approach to
comment|// insertion.  Since we already reserved space, we know that this won't
comment|// reallocate the vector.
if|if
condition|(
name|size_t
argument_list|(
name|this
operator|->
name|end
argument_list|()
operator|-
name|I
argument_list|)
operator|>=
name|NumToInsert
condition|)
block|{
name|T
modifier|*
name|OldEnd
init|=
name|this
operator|->
name|end
argument_list|()
decl_stmt|;
name|append
argument_list|(
name|this
operator|->
name|end
argument_list|()
operator|-
name|NumToInsert
argument_list|,
name|this
operator|->
name|end
argument_list|()
argument_list|)
expr_stmt|;
comment|// Copy the existing elements that get replaced.
name|std
operator|::
name|copy_backward
argument_list|(
name|I
argument_list|,
name|OldEnd
operator|-
name|NumToInsert
argument_list|,
name|OldEnd
argument_list|)
expr_stmt|;
name|std
operator|::
name|fill_n
argument_list|(
name|I
argument_list|,
name|NumToInsert
argument_list|,
name|Elt
argument_list|)
expr_stmt|;
return|return
name|I
return|;
block|}
comment|// Otherwise, we're inserting more elements than exist already, and we're
comment|// not inserting at the end.
comment|// Copy over the elements that we're about to overwrite.
name|T
modifier|*
name|OldEnd
init|=
name|this
operator|->
name|end
argument_list|()
decl_stmt|;
name|this
operator|->
name|setEnd
argument_list|(
name|this
operator|->
name|end
argument_list|()
operator|+
name|NumToInsert
argument_list|)
expr_stmt|;
name|size_t
name|NumOverwritten
init|=
name|OldEnd
operator|-
name|I
decl_stmt|;
name|this
operator|->
name|uninitialized_copy
argument_list|(
name|I
argument_list|,
name|OldEnd
argument_list|,
name|this
operator|->
name|end
argument_list|()
operator|-
name|NumOverwritten
argument_list|)
expr_stmt|;
comment|// Replace the overwritten part.
name|std
operator|::
name|fill_n
argument_list|(
name|I
argument_list|,
name|NumOverwritten
argument_list|,
name|Elt
argument_list|)
expr_stmt|;
comment|// Insert the non-overwritten middle part.
name|std
operator|::
name|uninitialized_fill_n
argument_list|(
name|OldEnd
argument_list|,
name|NumToInsert
operator|-
name|NumOverwritten
argument_list|,
name|Elt
argument_list|)
expr_stmt|;
return|return
name|I
return|;
block|}
end_function

begin_expr_stmt
name|template
operator|<
name|typename
name|ItTy
operator|>
name|iterator
name|insert
argument_list|(
argument|iterator I
argument_list|,
argument|ItTy From
argument_list|,
argument|ItTy To
argument_list|)
block|{
if|if
condition|(
name|I
operator|==
name|this
operator|->
name|end
argument_list|()
condition|)
block|{
comment|// Important special case for empty vector.
name|append
argument_list|(
name|From
argument_list|,
name|To
argument_list|)
expr_stmt|;
return|return
name|this
operator|->
name|end
argument_list|()
operator|-
literal|1
return|;
block|}
name|size_t
name|NumToInsert
operator|=
name|std
operator|::
name|distance
argument_list|(
name|From
argument_list|,
name|To
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|// Convert iterator to elt# to avoid invalidating iterator when we reserve()
end_comment

begin_decl_stmt
name|size_t
name|InsertElt
init|=
name|I
operator|-
name|this
operator|->
name|begin
argument_list|()
decl_stmt|;
end_decl_stmt

begin_comment
comment|// Ensure there is enough space.
end_comment

begin_expr_stmt
name|reserve
argument_list|(
name|static_cast
operator|<
name|unsigned
operator|>
operator|(
name|this
operator|->
name|size
argument_list|()
operator|+
name|NumToInsert
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|// Uninvalidate the iterator.
end_comment

begin_expr_stmt
name|I
operator|=
name|this
operator|->
name|begin
argument_list|()
operator|+
name|InsertElt
expr_stmt|;
end_expr_stmt

begin_comment
comment|// If there are more elements between the insertion point and the end of the
end_comment

begin_comment
comment|// range than there are being inserted, we can use a simple approach to
end_comment

begin_comment
comment|// insertion.  Since we already reserved space, we know that this won't
end_comment

begin_comment
comment|// reallocate the vector.
end_comment

begin_if
if|if
condition|(
name|size_t
argument_list|(
name|this
operator|->
name|end
argument_list|()
operator|-
name|I
argument_list|)
operator|>=
name|NumToInsert
condition|)
block|{
name|T
modifier|*
name|OldEnd
init|=
name|this
operator|->
name|end
argument_list|()
decl_stmt|;
name|append
argument_list|(
name|this
operator|->
name|end
argument_list|()
operator|-
name|NumToInsert
argument_list|,
name|this
operator|->
name|end
argument_list|()
argument_list|)
expr_stmt|;
comment|// Copy the existing elements that get replaced.
name|std
operator|::
name|copy_backward
argument_list|(
name|I
argument_list|,
name|OldEnd
operator|-
name|NumToInsert
argument_list|,
name|OldEnd
argument_list|)
expr_stmt|;
name|std
operator|::
name|copy
argument_list|(
name|From
argument_list|,
name|To
argument_list|,
name|I
argument_list|)
expr_stmt|;
return|return
name|I
return|;
block|}
end_if

begin_comment
comment|// Otherwise, we're inserting more elements than exist already, and we're
end_comment

begin_comment
comment|// not inserting at the end.
end_comment

begin_comment
comment|// Copy over the elements that we're about to overwrite.
end_comment

begin_decl_stmt
name|T
modifier|*
name|OldEnd
init|=
name|this
operator|->
name|end
argument_list|()
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|this
operator|->
name|setEnd
argument_list|(
name|this
operator|->
name|end
argument_list|()
operator|+
name|NumToInsert
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|size_t
name|NumOverwritten
init|=
name|OldEnd
operator|-
name|I
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|this
operator|->
name|uninitialized_copy
argument_list|(
name|I
argument_list|,
name|OldEnd
argument_list|,
name|this
operator|->
name|end
argument_list|()
operator|-
name|NumOverwritten
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|// Replace the overwritten part.
end_comment

begin_for
for|for
control|(
init|;
name|NumOverwritten
operator|>
literal|0
condition|;
operator|--
name|NumOverwritten
control|)
block|{
operator|*
name|I
operator|=
operator|*
name|From
expr_stmt|;
operator|++
name|I
expr_stmt|;
operator|++
name|From
expr_stmt|;
block|}
end_for

begin_comment
comment|// Insert the non-overwritten middle part.
end_comment

begin_expr_stmt
name|this
operator|->
name|uninitialized_copy
argument_list|(
name|From
argument_list|,
name|To
argument_list|,
name|OldEnd
argument_list|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|I
return|;
end_return

begin_decl_stmt
unit|}      const
name|SmallVectorImpl
modifier|&
name|operator
init|=
operator|(
specifier|const
name|SmallVectorImpl
operator|&
name|RHS
operator|)
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|bool
name|operator
operator|==
operator|(
specifier|const
name|SmallVectorImpl
operator|&
name|RHS
operator|)
specifier|const
block|{
if|if
condition|(
name|this
operator|->
name|size
argument_list|()
operator|!=
name|RHS
operator|.
name|size
argument_list|()
condition|)
return|return
name|false
return|;
end_expr_stmt

begin_return
return|return
name|std
operator|::
name|equal
argument_list|(
name|this
operator|->
name|begin
argument_list|()
argument_list|,
name|this
operator|->
name|end
argument_list|()
argument_list|,
name|RHS
operator|.
name|begin
argument_list|()
argument_list|)
return|;
end_return

begin_expr_stmt
unit|}   bool
name|operator
operator|!=
operator|(
specifier|const
name|SmallVectorImpl
operator|&
name|RHS
operator|)
specifier|const
block|{
return|return
operator|!
operator|(
operator|*
name|this
operator|==
name|RHS
operator|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|bool
name|operator
operator|<
operator|(
specifier|const
name|SmallVectorImpl
operator|&
name|RHS
operator|)
specifier|const
block|{
return|return
name|std
operator|::
name|lexicographical_compare
argument_list|(
name|this
operator|->
name|begin
argument_list|()
argument_list|,
name|this
operator|->
name|end
argument_list|()
argument_list|,
name|RHS
operator|.
name|begin
argument_list|()
argument_list|,
name|RHS
operator|.
name|end
argument_list|()
argument_list|)
return|;
block|}
end_expr_stmt

begin_comment
comment|/// set_size - Set the array size to \arg N, which the current array must have
end_comment

begin_comment
comment|/// enough capacity for.
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|/// This does not construct or destroy any elements in the vector.
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|/// Clients can use this in conjunction with capacity() to write past the end
end_comment

begin_comment
comment|/// of the buffer when they know that more elements are available, and only
end_comment

begin_comment
comment|/// update the size later. This avoids the cost of value initializing elements
end_comment

begin_comment
comment|/// which will only be overwritten.
end_comment

begin_function
name|void
name|set_size
parameter_list|(
name|unsigned
name|N
parameter_list|)
block|{
name|assert
argument_list|(
name|N
operator|<=
name|this
operator|->
name|capacity
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|->
name|setEnd
argument_list|(
name|this
operator|->
name|begin
argument_list|()
operator|+
name|N
argument_list|)
expr_stmt|;
block|}
end_function

begin_label
name|private
label|:
end_label

begin_function
specifier|static
name|void
name|construct_range
parameter_list|(
name|T
modifier|*
name|S
parameter_list|,
name|T
modifier|*
name|E
parameter_list|,
specifier|const
name|T
modifier|&
name|Elt
parameter_list|)
block|{
for|for
control|(
init|;
name|S
operator|!=
name|E
condition|;
operator|++
name|S
control|)
name|new
argument_list|(
argument|S
argument_list|)
name|T
argument_list|(
name|Elt
argument_list|)
expr_stmt|;
block|}
end_function

begin_expr_stmt
unit|};
name|template
operator|<
name|typename
name|T
operator|>
name|void
name|SmallVectorImpl
operator|<
name|T
operator|>
operator|::
name|swap
argument_list|(
argument|SmallVectorImpl<T>&RHS
argument_list|)
block|{
if|if
condition|(
name|this
operator|==
operator|&
name|RHS
condition|)
return|return;
end_expr_stmt

begin_comment
comment|// We can only avoid copying elements if neither vector is small.
end_comment

begin_if
if|if
condition|(
operator|!
name|this
operator|->
name|isSmall
argument_list|()
operator|&&
operator|!
name|RHS
operator|.
name|isSmall
argument_list|()
condition|)
block|{
name|std
operator|::
name|swap
argument_list|(
name|this
operator|->
name|BeginX
argument_list|,
name|RHS
operator|.
name|BeginX
argument_list|)
expr_stmt|;
name|std
operator|::
name|swap
argument_list|(
name|this
operator|->
name|EndX
argument_list|,
name|RHS
operator|.
name|EndX
argument_list|)
expr_stmt|;
name|std
operator|::
name|swap
argument_list|(
name|this
operator|->
name|CapacityX
argument_list|,
name|RHS
operator|.
name|CapacityX
argument_list|)
expr_stmt|;
return|return;
block|}
end_if

begin_if
if|if
condition|(
name|RHS
operator|.
name|size
argument_list|()
operator|>
name|this
operator|->
name|capacity
argument_list|()
condition|)
name|this
operator|->
name|grow
argument_list|(
name|RHS
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
end_if

begin_if
if|if
condition|(
name|this
operator|->
name|size
argument_list|()
operator|>
name|RHS
operator|.
name|capacity
argument_list|()
condition|)
name|RHS
operator|.
name|grow
argument_list|(
name|this
operator|->
name|size
argument_list|()
argument_list|)
expr_stmt|;
end_if

begin_comment
comment|// Swap the shared elements.
end_comment

begin_decl_stmt
name|size_t
name|NumShared
init|=
name|this
operator|->
name|size
argument_list|()
decl_stmt|;
end_decl_stmt

begin_if
if|if
condition|(
name|NumShared
operator|>
name|RHS
operator|.
name|size
argument_list|()
condition|)
name|NumShared
operator|=
name|RHS
operator|.
name|size
argument_list|()
expr_stmt|;
end_if

begin_for
for|for
control|(
name|unsigned
name|i
init|=
literal|0
init|;
name|i
operator|!=
name|static_cast
operator|<
name|unsigned
operator|>
operator|(
name|NumShared
operator|)
condition|;
operator|++
name|i
control|)
name|std
operator|::
name|swap
argument_list|(
operator|(
operator|*
name|this
operator|)
index|[
name|i
index|]
argument_list|,
name|RHS
index|[
name|i
index|]
argument_list|)
expr_stmt|;
end_for

begin_comment
comment|// Copy over the extra elts.
end_comment

begin_if
if|if
condition|(
name|this
operator|->
name|size
argument_list|()
operator|>
name|RHS
operator|.
name|size
argument_list|()
condition|)
block|{
name|size_t
name|EltDiff
init|=
name|this
operator|->
name|size
argument_list|()
operator|-
name|RHS
operator|.
name|size
argument_list|()
decl_stmt|;
name|this
operator|->
name|uninitialized_copy
argument_list|(
name|this
operator|->
name|begin
argument_list|()
operator|+
name|NumShared
argument_list|,
name|this
operator|->
name|end
argument_list|()
argument_list|,
name|RHS
operator|.
name|end
argument_list|()
argument_list|)
expr_stmt|;
name|RHS
operator|.
name|setEnd
argument_list|(
name|RHS
operator|.
name|end
argument_list|()
operator|+
name|EltDiff
argument_list|)
expr_stmt|;
name|this
operator|->
name|destroy_range
argument_list|(
name|this
operator|->
name|begin
argument_list|()
operator|+
name|NumShared
argument_list|,
name|this
operator|->
name|end
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|->
name|setEnd
argument_list|(
name|this
operator|->
name|begin
argument_list|()
operator|+
name|NumShared
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|RHS
operator|.
name|size
argument_list|()
operator|>
name|this
operator|->
name|size
argument_list|()
condition|)
block|{
name|size_t
name|EltDiff
init|=
name|RHS
operator|.
name|size
argument_list|()
operator|-
name|this
operator|->
name|size
argument_list|()
decl_stmt|;
name|this
operator|->
name|uninitialized_copy
argument_list|(
name|RHS
operator|.
name|begin
argument_list|()
operator|+
name|NumShared
argument_list|,
name|RHS
operator|.
name|end
argument_list|()
argument_list|,
name|this
operator|->
name|end
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|->
name|setEnd
argument_list|(
name|this
operator|->
name|end
argument_list|()
operator|+
name|EltDiff
argument_list|)
expr_stmt|;
name|this
operator|->
name|destroy_range
argument_list|(
name|RHS
operator|.
name|begin
argument_list|()
operator|+
name|NumShared
argument_list|,
name|RHS
operator|.
name|end
argument_list|()
argument_list|)
expr_stmt|;
name|RHS
operator|.
name|setEnd
argument_list|(
name|RHS
operator|.
name|begin
argument_list|()
operator|+
name|NumShared
argument_list|)
expr_stmt|;
block|}
end_if

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|T
operator|>
specifier|const
name|SmallVectorImpl
operator|<
name|T
operator|>
operator|&
name|SmallVectorImpl
operator|<
name|T
operator|>
operator|::
name|operator
operator|=
operator|(
specifier|const
name|SmallVectorImpl
operator|<
name|T
operator|>
operator|&
name|RHS
operator|)
block|{
comment|// Avoid self-assignment.
if|if
condition|(
name|this
operator|==
operator|&
name|RHS
condition|)
return|return
operator|*
name|this
return|;
comment|// If we already have sufficient space, assign the common elements, then
comment|// destroy any excess.
name|size_t
name|RHSSize
operator|=
name|RHS
operator|.
name|size
argument_list|()
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|size_t
name|CurSize
init|=
name|this
operator|->
name|size
argument_list|()
decl_stmt|;
end_decl_stmt

begin_if
if|if
condition|(
name|CurSize
operator|>=
name|RHSSize
condition|)
block|{
comment|// Assign common elements.
name|iterator
name|NewEnd
decl_stmt|;
if|if
condition|(
name|RHSSize
condition|)
name|NewEnd
operator|=
name|std
operator|::
name|copy
argument_list|(
name|RHS
operator|.
name|begin
argument_list|()
argument_list|,
name|RHS
operator|.
name|begin
argument_list|()
operator|+
name|RHSSize
argument_list|,
name|this
operator|->
name|begin
argument_list|()
argument_list|)
expr_stmt|;
else|else
name|NewEnd
operator|=
name|this
operator|->
name|begin
argument_list|()
expr_stmt|;
comment|// Destroy excess elements.
name|this
operator|->
name|destroy_range
argument_list|(
name|NewEnd
argument_list|,
name|this
operator|->
name|end
argument_list|()
argument_list|)
expr_stmt|;
comment|// Trim.
name|this
operator|->
name|setEnd
argument_list|(
name|NewEnd
argument_list|)
expr_stmt|;
return|return
operator|*
name|this
return|;
block|}
end_if

begin_comment
comment|// If we have to grow to have enough elements, destroy the current elements.
end_comment

begin_comment
comment|// This allows us to avoid copying them during the grow.
end_comment

begin_if
if|if
condition|(
name|this
operator|->
name|capacity
argument_list|()
operator|<
name|RHSSize
condition|)
block|{
comment|// Destroy current elements.
name|this
operator|->
name|destroy_range
argument_list|(
name|this
operator|->
name|begin
argument_list|()
argument_list|,
name|this
operator|->
name|end
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|->
name|setEnd
argument_list|(
name|this
operator|->
name|begin
argument_list|()
argument_list|)
expr_stmt|;
name|CurSize
operator|=
literal|0
expr_stmt|;
name|this
operator|->
name|grow
argument_list|(
name|RHSSize
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|CurSize
condition|)
block|{
comment|// Otherwise, use assignment for the already-constructed elements.
name|std
operator|::
name|copy
argument_list|(
name|RHS
operator|.
name|begin
argument_list|()
argument_list|,
name|RHS
operator|.
name|begin
argument_list|()
operator|+
name|CurSize
argument_list|,
name|this
operator|->
name|begin
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_if

begin_comment
comment|// Copy construct the new elements in place.
end_comment

begin_expr_stmt
name|this
operator|->
name|uninitialized_copy
argument_list|(
name|RHS
operator|.
name|begin
argument_list|()
operator|+
name|CurSize
argument_list|,
name|RHS
operator|.
name|end
argument_list|()
argument_list|,
name|this
operator|->
name|begin
argument_list|()
operator|+
name|CurSize
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|// Set end.
end_comment

begin_expr_stmt
name|this
operator|->
name|setEnd
argument_list|(
name|this
operator|->
name|begin
argument_list|()
operator|+
name|RHSSize
argument_list|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
operator|*
name|this
return|;
end_return

begin_comment
unit|}
comment|/// SmallVector - This is a 'vector' (really, a variable-sized array), optimized
end_comment

begin_comment
comment|/// for the case when the array is small.  It contains some number of elements
end_comment

begin_comment
comment|/// in-place, which allows it to avoid heap allocation when the actual number of
end_comment

begin_comment
comment|/// elements is below that threshold.  This allows normal "small" cases to be
end_comment

begin_comment
comment|/// fast without losing generality for large inputs.
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|/// Note that this does not attempt to be exception safe.
end_comment

begin_comment
comment|///
end_comment

begin_expr_stmt
unit|template
operator|<
name|typename
name|T
operator|,
name|unsigned
name|N
operator|>
name|class
name|SmallVector
operator|:
name|public
name|SmallVectorImpl
operator|<
name|T
operator|>
block|{
comment|/// InlineElts - These are 'N-1' elements that are stored inline in the body
comment|/// of the vector.  The extra '1' element is stored in SmallVectorImpl.
typedef|typedef
name|typename
name|SmallVectorImpl
operator|<
name|T
operator|>
operator|::
name|U
name|U
expr_stmt|;
block|enum
block|{
comment|// MinUs - The number of U's require to cover N T's.
name|MinUs
operator|=
operator|(
name|static_cast
operator|<
name|unsigned
name|int
operator|>
operator|(
sizeof|sizeof
argument_list|(
name|T
argument_list|)
operator|)
operator|*
name|N
operator|+
name|static_cast
operator|<
name|unsigned
name|int
operator|>
operator|(
sizeof|sizeof
argument_list|(
name|U
argument_list|)
operator|)
operator|-
literal|1
operator|)
operator|/
name|static_cast
operator|<
name|unsigned
name|int
operator|>
operator|(
sizeof|sizeof
argument_list|(
name|U
argument_list|)
operator|)
block|,
comment|// NumInlineEltsElts - The number of elements actually in this array.  There
comment|// is already one in the parent class, and we have to round up to avoid
comment|// having a zero-element array.
name|NumInlineEltsElts
operator|=
name|MinUs
operator|>
literal|1
operator|?
operator|(
name|MinUs
operator|-
literal|1
operator|)
operator|:
literal|1
block|,
comment|// NumTsAvailable - The number of T's we actually have space for, which may
comment|// be more than N due to rounding.
name|NumTsAvailable
operator|=
operator|(
name|NumInlineEltsElts
operator|+
literal|1
operator|)
operator|*
name|static_cast
operator|<
name|unsigned
name|int
operator|>
operator|(
sizeof|sizeof
argument_list|(
name|U
argument_list|)
operator|)
operator|/
name|static_cast
operator|<
name|unsigned
name|int
operator|>
operator|(
sizeof|sizeof
argument_list|(
name|T
argument_list|)
operator|)
block|}
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|U
name|InlineElts
index|[
name|NumInlineEltsElts
index|]
decl_stmt|;
end_decl_stmt

begin_label
name|public
label|:
end_label

begin_expr_stmt
name|SmallVector
argument_list|()
operator|:
name|SmallVectorImpl
operator|<
name|T
operator|>
operator|(
name|NumTsAvailable
operator|)
block|{   }
name|explicit
name|SmallVector
argument_list|(
argument|unsigned Size
argument_list|,
argument|const T&Value = T()
argument_list|)
operator|:
name|SmallVectorImpl
operator|<
name|T
operator|>
operator|(
name|NumTsAvailable
operator|)
block|{
name|this
operator|->
name|reserve
argument_list|(
name|Size
argument_list|)
block|;
while|while
condition|(
name|Size
operator|--
condition|)
name|this
operator|->
name|push_back
argument_list|(
name|Value
argument_list|)
expr_stmt|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|ItTy
operator|>
name|SmallVector
argument_list|(
argument|ItTy S
argument_list|,
argument|ItTy E
argument_list|)
operator|:
name|SmallVectorImpl
operator|<
name|T
operator|>
operator|(
name|NumTsAvailable
operator|)
block|{
name|this
operator|->
name|append
argument_list|(
name|S
argument_list|,
name|E
argument_list|)
block|;   }
name|SmallVector
argument_list|(
specifier|const
name|SmallVector
operator|&
name|RHS
argument_list|)
operator|:
name|SmallVectorImpl
operator|<
name|T
operator|>
operator|(
name|NumTsAvailable
operator|)
block|{
if|if
condition|(
operator|!
name|RHS
operator|.
name|empty
argument_list|()
condition|)
name|SmallVectorImpl
operator|<
name|T
operator|>
operator|::
name|operator
operator|=
operator|(
name|RHS
operator|)
expr_stmt|;
block|}
end_expr_stmt

begin_decl_stmt
specifier|const
name|SmallVector
modifier|&
name|operator
init|=
operator|(
specifier|const
name|SmallVector
operator|&
name|RHS
operator|)
block|{
name|SmallVectorImpl
operator|<
name|T
operator|>
operator|::
name|operator
operator|=
operator|(
name|RHS
operator|)
block|;
return|return
operator|*
name|this
return|;
block|}
end_decl_stmt

begin_comment
unit|};  }
comment|// End llvm namespace
end_comment

begin_macro
unit|namespace
name|std
end_macro

begin_block
block|{
comment|/// Implement std::swap in terms of SmallVector swap.
name|template
operator|<
name|typename
name|T
operator|>
specifier|inline
name|void
name|swap
argument_list|(
argument|llvm::SmallVectorImpl<T>&LHS
argument_list|,
argument|llvm::SmallVectorImpl<T>&RHS
argument_list|)
block|{
name|LHS
operator|.
name|swap
argument_list|(
name|RHS
argument_list|)
block|;   }
comment|/// Implement std::swap in terms of SmallVector swap.
name|template
operator|<
name|typename
name|T
operator|,
name|unsigned
name|N
operator|>
specifier|inline
name|void
name|swap
argument_list|(
argument|llvm::SmallVector<T
argument_list|,
argument|N>&LHS
argument_list|,
argument|llvm::SmallVector<T
argument_list|,
argument|N>&RHS
argument_list|)
block|{
name|LHS
operator|.
name|swap
argument_list|(
name|RHS
argument_list|)
block|;   }
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

end_unit

