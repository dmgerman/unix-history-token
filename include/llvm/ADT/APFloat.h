begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//== llvm/Support/APFloat.h - Arbitrary Precision Floating Point -*- C++ -*-==//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file declares a class to represent arbitrary precision floating
end_comment

begin_comment
comment|// point values and provide a variety of arithmetic operations on them.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|/*  A self-contained host- and target-independent arbitrary-precision     floating-point software implementation.  It uses bignum integer     arithmetic as provided by static functions in the APInt class.     The library will work with bignum integers whose parts are any     unsigned type at least 16 bits wide, but 64 bits is recommended.      Written for clarity rather than speed, in particular with a view     to use in the front-end of a cross compiler so that target     arithmetic can be correctly performed on the host.  Performance     should nonetheless be reasonable, particularly for its intended     use.  It may be useful as a base implementation for a run-time     library during development of a faster target-specific one.      All 5 rounding modes in the IEEE-754R draft are handled correctly     for all implemented operations.  Currently implemented operations     are add, subtract, multiply, divide, fused-multiply-add,     conversion-to-float, conversion-to-integer and     conversion-from-integer.  New rounding modes (e.g. away from zero)     can be added with three or four lines of code.      Four formats are built-in: IEEE single precision, double     precision, quadruple precision, and x87 80-bit extended double     (when operating with full extended precision).  Adding a new     format that obeys IEEE semantics only requires adding two lines of     code: a declaration and definition of the format.      All operations return the status of that operation as an exception     bit-mask, so multiple operations can be done consecutively with     their results or-ed together.  The returned status can be useful     for compiler diagnostics; e.g., inexact, underflow and overflow     can be easily diagnosed on constant folding, and compiler     optimizers can determine what exceptions would be raised by     folding operations and optimize, or perhaps not optimize,     accordingly.      At present, underflow tininess is detected after rounding; it     should be straight forward to add support for the before-rounding     case too.      The library reads hexadecimal floating point numbers as per C99,     and correctly rounds if necessary according to the specified     rounding mode.  Syntax is required to have been validated by the     caller.  It also converts floating point numbers to hexadecimal     text as per the C99 %a and %A conversions.  The output precision     (or alternatively the natural minimal precision) can be specified;     if the requested precision is less than the natural precision the     output is correctly rounded for the specified rounding mode.      It also reads decimal floating point numbers and correctly rounds     according to the specified rounding mode.      Conversion to decimal text is not currently implemented.      Non-zero finite numbers are represented internally as a sign bit,     a 16-bit signed exponent, and the significand as an array of     integer parts.  After normalization of a number of precision P the     exponent is within the range of the format, and if the number is     not denormal the P-th bit of the significand is set as an explicit     integer bit.  For denormals the most significant bit is shifted     right so that the exponent is maintained at the format's minimum,     so that the smallest denormal has just the least significant bit     of the significand set.  The sign of zeroes and infinities is     significant; the exponent and significand of such numbers is not     stored, but has a known implicit (deterministic) value: 0 for the     significands, 0 for zero exponent, all 1 bits for infinity     exponent.  For NaNs the sign and significand are deterministic,     although not really meaningful, and preserved in non-conversion     operations.  The exponent is implicitly all 1 bits.      TODO     ====      Some features that may or may not be worth adding:      Binary to decimal conversion (hard).      Optional ability to detect underflow tininess before rounding.      New formats: x87 in single and double precision mode (IEEE apart     from extended exponent range) (hard).      New operations: sqrt, IEEE remainder, C90 fmod, nextafter,     nexttoward. */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LLVM_FLOAT_H
end_ifndef

begin_define
define|#
directive|define
name|LLVM_FLOAT_H
end_define

begin_comment
comment|// APInt contains static functions implementing bignum arithmetic.
end_comment

begin_include
include|#
directive|include
file|"llvm/ADT/APInt.h"
end_include

begin_decl_stmt
name|namespace
name|llvm
block|{
comment|/* Exponents are stored as signed numbers.  */
typedef|typedef
name|signed
name|short
name|exponent_t
typedef|;
struct_decl|struct
name|fltSemantics
struct_decl|;
name|class
name|StringRef
decl_stmt|;
comment|/* When bits of a floating point number are truncated, this enum is      used to indicate what fraction of the LSB those bits represented.      It essentially combines the roles of guard and sticky bits.  */
enum|enum
name|lostFraction
block|{
comment|// Example of truncated bits:
name|lfExactlyZero
block|,
comment|// 000000
name|lfLessThanHalf
block|,
comment|// 0xxxxx  x's not all zero
name|lfExactlyHalf
block|,
comment|// 100000
name|lfMoreThanHalf
comment|// 1xxxxx  x's not all zero
block|}
enum|;
name|class
name|APFloat
block|{
name|public
label|:
comment|/* We support the following floating point semantics.  */
specifier|static
specifier|const
name|fltSemantics
name|IEEEhalf
decl_stmt|;
specifier|static
specifier|const
name|fltSemantics
name|IEEEsingle
decl_stmt|;
specifier|static
specifier|const
name|fltSemantics
name|IEEEdouble
decl_stmt|;
specifier|static
specifier|const
name|fltSemantics
name|IEEEquad
decl_stmt|;
specifier|static
specifier|const
name|fltSemantics
name|PPCDoubleDouble
decl_stmt|;
specifier|static
specifier|const
name|fltSemantics
name|x87DoubleExtended
decl_stmt|;
comment|/* And this pseudo, used to construct APFloats that cannot        conflict with anything real. */
specifier|static
specifier|const
name|fltSemantics
name|Bogus
decl_stmt|;
specifier|static
name|unsigned
name|int
name|semanticsPrecision
parameter_list|(
specifier|const
name|fltSemantics
modifier|&
parameter_list|)
function_decl|;
comment|/* Floating point numbers have a four-state comparison relation.  */
enum|enum
name|cmpResult
block|{
name|cmpLessThan
block|,
name|cmpEqual
block|,
name|cmpGreaterThan
block|,
name|cmpUnordered
block|}
enum|;
comment|/* IEEE-754R gives five rounding modes.  */
enum|enum
name|roundingMode
block|{
name|rmNearestTiesToEven
block|,
name|rmTowardPositive
block|,
name|rmTowardNegative
block|,
name|rmTowardZero
block|,
name|rmNearestTiesToAway
block|}
enum|;
comment|// Operation status.  opUnderflow or opOverflow are always returned
comment|// or-ed with opInexact.
enum|enum
name|opStatus
block|{
name|opOK
init|=
literal|0x00
block|,
name|opInvalidOp
init|=
literal|0x01
block|,
name|opDivByZero
init|=
literal|0x02
block|,
name|opOverflow
init|=
literal|0x04
block|,
name|opUnderflow
init|=
literal|0x08
block|,
name|opInexact
init|=
literal|0x10
block|}
enum|;
comment|// Category of internally-represented number.
enum|enum
name|fltCategory
block|{
name|fcInfinity
block|,
name|fcNaN
block|,
name|fcNormal
block|,
name|fcZero
block|}
enum|;
comment|// Constructors.
name|APFloat
argument_list|(
specifier|const
name|fltSemantics
operator|&
argument_list|)
expr_stmt|;
comment|// Default construct to 0.0
name|APFloat
argument_list|(
specifier|const
name|fltSemantics
operator|&
argument_list|,
specifier|const
name|StringRef
operator|&
argument_list|)
expr_stmt|;
name|APFloat
argument_list|(
specifier|const
name|fltSemantics
operator|&
argument_list|,
name|integerPart
argument_list|)
expr_stmt|;
name|APFloat
argument_list|(
argument|const fltSemantics&
argument_list|,
argument|fltCategory
argument_list|,
argument|bool negative
argument_list|,
argument|unsigned type=
literal|0
argument_list|)
empty_stmt|;
name|explicit
name|APFloat
parameter_list|(
name|double
name|d
parameter_list|)
function_decl|;
name|explicit
name|APFloat
parameter_list|(
name|float
name|f
parameter_list|)
function_decl|;
name|explicit
name|APFloat
parameter_list|(
specifier|const
name|APInt
modifier|&
parameter_list|,
name|bool
name|isIEEE
init|=
name|false
parameter_list|)
function_decl|;
name|APFloat
argument_list|(
specifier|const
name|APFloat
operator|&
argument_list|)
expr_stmt|;
operator|~
name|APFloat
argument_list|()
expr_stmt|;
comment|// Convenience "constructors"
specifier|static
name|APFloat
name|getZero
parameter_list|(
specifier|const
name|fltSemantics
modifier|&
name|Sem
parameter_list|,
name|bool
name|Negative
init|=
name|false
parameter_list|)
block|{
return|return
name|APFloat
argument_list|(
name|Sem
argument_list|,
name|fcZero
argument_list|,
name|Negative
argument_list|)
return|;
block|}
specifier|static
name|APFloat
name|getInf
parameter_list|(
specifier|const
name|fltSemantics
modifier|&
name|Sem
parameter_list|,
name|bool
name|Negative
init|=
name|false
parameter_list|)
block|{
return|return
name|APFloat
argument_list|(
name|Sem
argument_list|,
name|fcInfinity
argument_list|,
name|Negative
argument_list|)
return|;
block|}
comment|/// getNaN - Factory for QNaN values.
comment|///
comment|/// \param Negative - True iff the NaN generated should be negative.
comment|/// \param type - The unspecified fill bits for creating the NaN, 0 by
comment|/// default.  The value is truncated as necessary.
specifier|static
name|APFloat
name|getNaN
parameter_list|(
specifier|const
name|fltSemantics
modifier|&
name|Sem
parameter_list|,
name|bool
name|Negative
init|=
name|false
parameter_list|,
name|unsigned
name|type
init|=
literal|0
parameter_list|)
block|{
return|return
name|APFloat
argument_list|(
name|Sem
argument_list|,
name|fcNaN
argument_list|,
name|Negative
argument_list|,
name|type
argument_list|)
return|;
block|}
comment|/// Profile - Used to insert APFloat objects, or objects that contain
comment|///  APFloat objects, into FoldingSets.
name|void
name|Profile
argument_list|(
name|FoldingSetNodeID
operator|&
name|NID
argument_list|)
decl|const
decl_stmt|;
comment|/// @brief Used by the Bitcode serializer to emit APInts to Bitcode.
name|void
name|Emit
argument_list|(
name|Serializer
operator|&
name|S
argument_list|)
decl|const
decl_stmt|;
comment|/// @brief Used by the Bitcode deserializer to deserialize APInts.
specifier|static
name|APFloat
name|ReadVal
parameter_list|(
name|Deserializer
modifier|&
name|D
parameter_list|)
function_decl|;
comment|/* Arithmetic.  */
name|opStatus
name|add
parameter_list|(
specifier|const
name|APFloat
modifier|&
parameter_list|,
name|roundingMode
parameter_list|)
function_decl|;
name|opStatus
name|subtract
parameter_list|(
specifier|const
name|APFloat
modifier|&
parameter_list|,
name|roundingMode
parameter_list|)
function_decl|;
name|opStatus
name|multiply
parameter_list|(
specifier|const
name|APFloat
modifier|&
parameter_list|,
name|roundingMode
parameter_list|)
function_decl|;
name|opStatus
name|divide
parameter_list|(
specifier|const
name|APFloat
modifier|&
parameter_list|,
name|roundingMode
parameter_list|)
function_decl|;
comment|/* IEEE remainder. */
name|opStatus
name|remainder
parameter_list|(
specifier|const
name|APFloat
modifier|&
parameter_list|)
function_decl|;
comment|/* C fmod, or llvm frem. */
name|opStatus
name|mod
parameter_list|(
specifier|const
name|APFloat
modifier|&
parameter_list|,
name|roundingMode
parameter_list|)
function_decl|;
name|opStatus
name|fusedMultiplyAdd
parameter_list|(
specifier|const
name|APFloat
modifier|&
parameter_list|,
specifier|const
name|APFloat
modifier|&
parameter_list|,
name|roundingMode
parameter_list|)
function_decl|;
comment|/* Sign operations.  */
name|void
name|changeSign
parameter_list|()
function_decl|;
name|void
name|clearSign
parameter_list|()
function_decl|;
name|void
name|copySign
parameter_list|(
specifier|const
name|APFloat
modifier|&
parameter_list|)
function_decl|;
comment|/* Conversions.  */
name|opStatus
name|convert
parameter_list|(
specifier|const
name|fltSemantics
modifier|&
parameter_list|,
name|roundingMode
parameter_list|,
name|bool
modifier|*
parameter_list|)
function_decl|;
name|opStatus
name|convertToInteger
argument_list|(
name|integerPart
operator|*
argument_list|,
name|unsigned
name|int
argument_list|,
name|bool
argument_list|,
name|roundingMode
argument_list|,
name|bool
operator|*
argument_list|)
decl|const
decl_stmt|;
name|opStatus
name|convertFromAPInt
parameter_list|(
specifier|const
name|APInt
modifier|&
parameter_list|,
name|bool
parameter_list|,
name|roundingMode
parameter_list|)
function_decl|;
name|opStatus
name|convertFromSignExtendedInteger
parameter_list|(
specifier|const
name|integerPart
modifier|*
parameter_list|,
name|unsigned
name|int
parameter_list|,
name|bool
parameter_list|,
name|roundingMode
parameter_list|)
function_decl|;
name|opStatus
name|convertFromZeroExtendedInteger
parameter_list|(
specifier|const
name|integerPart
modifier|*
parameter_list|,
name|unsigned
name|int
parameter_list|,
name|bool
parameter_list|,
name|roundingMode
parameter_list|)
function_decl|;
name|opStatus
name|convertFromString
parameter_list|(
specifier|const
name|StringRef
modifier|&
parameter_list|,
name|roundingMode
parameter_list|)
function_decl|;
name|APInt
name|bitcastToAPInt
argument_list|()
specifier|const
expr_stmt|;
name|double
name|convertToDouble
argument_list|()
specifier|const
expr_stmt|;
name|float
name|convertToFloat
argument_list|()
specifier|const
expr_stmt|;
comment|/* The definition of equality is not straightforward for floating point,        so we won't use operator==.  Use one of the following, or write        whatever it is you really mean. */
comment|// bool operator==(const APFloat&) const;     // DO NOT IMPLEMENT
comment|/* IEEE comparison with another floating point number (NaNs        compare unordered, 0==-0). */
name|cmpResult
name|compare
argument_list|(
specifier|const
name|APFloat
operator|&
argument_list|)
decl|const
decl_stmt|;
comment|/* Bitwise comparison for equality (QNaNs compare equal, 0!=-0). */
name|bool
name|bitwiseIsEqual
argument_list|(
specifier|const
name|APFloat
operator|&
argument_list|)
decl|const
decl_stmt|;
comment|/* Write out a hexadecimal representation of the floating point        value to DST, which must be of sufficient size, in the C99 form        [-]0xh.hhhhp[+-]d.  Return the number of characters written,        excluding the terminating NUL.  */
name|unsigned
name|int
name|convertToHexString
argument_list|(
name|char
operator|*
name|dst
argument_list|,
name|unsigned
name|int
name|hexDigits
argument_list|,
name|bool
name|upperCase
argument_list|,
name|roundingMode
argument_list|)
decl|const
decl_stmt|;
comment|/* Simple queries.  */
name|fltCategory
name|getCategory
argument_list|()
specifier|const
block|{
return|return
name|category
return|;
block|}
specifier|const
name|fltSemantics
operator|&
name|getSemantics
argument_list|()
specifier|const
block|{
return|return
operator|*
name|semantics
return|;
block|}
name|bool
name|isZero
argument_list|()
specifier|const
block|{
return|return
name|category
operator|==
name|fcZero
return|;
block|}
name|bool
name|isNonZero
argument_list|()
specifier|const
block|{
return|return
name|category
operator|!=
name|fcZero
return|;
block|}
name|bool
name|isNaN
argument_list|()
specifier|const
block|{
return|return
name|category
operator|==
name|fcNaN
return|;
block|}
name|bool
name|isInfinity
argument_list|()
specifier|const
block|{
return|return
name|category
operator|==
name|fcInfinity
return|;
block|}
name|bool
name|isNegative
argument_list|()
specifier|const
block|{
return|return
name|sign
return|;
block|}
name|bool
name|isPosZero
argument_list|()
specifier|const
block|{
return|return
name|isZero
argument_list|()
operator|&&
operator|!
name|isNegative
argument_list|()
return|;
block|}
name|bool
name|isNegZero
argument_list|()
specifier|const
block|{
return|return
name|isZero
argument_list|()
operator|&&
name|isNegative
argument_list|()
return|;
block|}
name|APFloat
modifier|&
name|operator
init|=
operator|(
specifier|const
name|APFloat
operator|&
operator|)
decl_stmt|;
comment|/* Return an arbitrary integer value usable for hashing. */
name|uint32_t
name|getHashValue
argument_list|()
specifier|const
expr_stmt|;
name|private
label|:
comment|/* Trivial queries.  */
name|integerPart
modifier|*
name|significandParts
parameter_list|()
function_decl|;
specifier|const
name|integerPart
operator|*
name|significandParts
argument_list|()
specifier|const
expr_stmt|;
name|unsigned
name|int
name|partCount
argument_list|()
specifier|const
expr_stmt|;
comment|/* Significand operations.  */
name|integerPart
name|addSignificand
parameter_list|(
specifier|const
name|APFloat
modifier|&
parameter_list|)
function_decl|;
name|integerPart
name|subtractSignificand
parameter_list|(
specifier|const
name|APFloat
modifier|&
parameter_list|,
name|integerPart
parameter_list|)
function_decl|;
name|lostFraction
name|addOrSubtractSignificand
parameter_list|(
specifier|const
name|APFloat
modifier|&
parameter_list|,
name|bool
name|subtract
parameter_list|)
function_decl|;
name|lostFraction
name|multiplySignificand
parameter_list|(
specifier|const
name|APFloat
modifier|&
parameter_list|,
specifier|const
name|APFloat
modifier|*
parameter_list|)
function_decl|;
name|lostFraction
name|divideSignificand
parameter_list|(
specifier|const
name|APFloat
modifier|&
parameter_list|)
function_decl|;
name|void
name|incrementSignificand
parameter_list|()
function_decl|;
name|void
name|initialize
parameter_list|(
specifier|const
name|fltSemantics
modifier|*
parameter_list|)
function_decl|;
name|void
name|shiftSignificandLeft
parameter_list|(
name|unsigned
name|int
parameter_list|)
function_decl|;
name|lostFraction
name|shiftSignificandRight
parameter_list|(
name|unsigned
name|int
parameter_list|)
function_decl|;
name|unsigned
name|int
name|significandLSB
argument_list|()
specifier|const
expr_stmt|;
name|unsigned
name|int
name|significandMSB
argument_list|()
specifier|const
expr_stmt|;
name|void
name|zeroSignificand
parameter_list|()
function_decl|;
comment|/* Arithmetic on special values.  */
name|opStatus
name|addOrSubtractSpecials
parameter_list|(
specifier|const
name|APFloat
modifier|&
parameter_list|,
name|bool
name|subtract
parameter_list|)
function_decl|;
name|opStatus
name|divideSpecials
parameter_list|(
specifier|const
name|APFloat
modifier|&
parameter_list|)
function_decl|;
name|opStatus
name|multiplySpecials
parameter_list|(
specifier|const
name|APFloat
modifier|&
parameter_list|)
function_decl|;
name|opStatus
name|modSpecials
parameter_list|(
specifier|const
name|APFloat
modifier|&
parameter_list|)
function_decl|;
comment|/* Miscellany.  */
name|void
name|makeNaN
parameter_list|(
name|unsigned
init|=
literal|0
parameter_list|)
function_decl|;
name|opStatus
name|normalize
parameter_list|(
name|roundingMode
parameter_list|,
name|lostFraction
parameter_list|)
function_decl|;
name|opStatus
name|addOrSubtract
parameter_list|(
specifier|const
name|APFloat
modifier|&
parameter_list|,
name|roundingMode
parameter_list|,
name|bool
name|subtract
parameter_list|)
function_decl|;
name|cmpResult
name|compareAbsoluteValue
argument_list|(
specifier|const
name|APFloat
operator|&
argument_list|)
decl|const
decl_stmt|;
name|opStatus
name|handleOverflow
parameter_list|(
name|roundingMode
parameter_list|)
function_decl|;
name|bool
name|roundAwayFromZero
argument_list|(
name|roundingMode
argument_list|,
name|lostFraction
argument_list|,
name|unsigned
name|int
argument_list|)
decl|const
decl_stmt|;
name|opStatus
name|convertToSignExtendedInteger
argument_list|(
name|integerPart
operator|*
argument_list|,
name|unsigned
name|int
argument_list|,
name|bool
argument_list|,
name|roundingMode
argument_list|,
name|bool
operator|*
argument_list|)
decl|const
decl_stmt|;
name|opStatus
name|convertFromUnsignedParts
parameter_list|(
specifier|const
name|integerPart
modifier|*
parameter_list|,
name|unsigned
name|int
parameter_list|,
name|roundingMode
parameter_list|)
function_decl|;
name|opStatus
name|convertFromHexadecimalString
parameter_list|(
specifier|const
name|StringRef
modifier|&
parameter_list|,
name|roundingMode
parameter_list|)
function_decl|;
name|opStatus
name|convertFromDecimalString
parameter_list|(
specifier|const
name|StringRef
modifier|&
parameter_list|,
name|roundingMode
parameter_list|)
function_decl|;
name|char
modifier|*
name|convertNormalToHexString
argument_list|(
name|char
operator|*
argument_list|,
name|unsigned
name|int
argument_list|,
name|bool
argument_list|,
name|roundingMode
argument_list|)
decl|const
decl_stmt|;
name|opStatus
name|roundSignificandWithExponent
parameter_list|(
specifier|const
name|integerPart
modifier|*
parameter_list|,
name|unsigned
name|int
parameter_list|,
name|int
parameter_list|,
name|roundingMode
parameter_list|)
function_decl|;
name|APInt
name|convertHalfAPFloatToAPInt
argument_list|()
specifier|const
expr_stmt|;
name|APInt
name|convertFloatAPFloatToAPInt
argument_list|()
specifier|const
expr_stmt|;
name|APInt
name|convertDoubleAPFloatToAPInt
argument_list|()
specifier|const
expr_stmt|;
name|APInt
name|convertQuadrupleAPFloatToAPInt
argument_list|()
specifier|const
expr_stmt|;
name|APInt
name|convertF80LongDoubleAPFloatToAPInt
argument_list|()
specifier|const
expr_stmt|;
name|APInt
name|convertPPCDoubleDoubleAPFloatToAPInt
argument_list|()
specifier|const
decl_stmt|;
name|void
name|initFromAPInt
parameter_list|(
specifier|const
name|APInt
modifier|&
name|api
parameter_list|,
name|bool
name|isIEEE
init|=
name|false
parameter_list|)
function_decl|;
name|void
name|initFromHalfAPInt
parameter_list|(
specifier|const
name|APInt
modifier|&
name|api
parameter_list|)
function_decl|;
name|void
name|initFromFloatAPInt
parameter_list|(
specifier|const
name|APInt
modifier|&
name|api
parameter_list|)
function_decl|;
name|void
name|initFromDoubleAPInt
parameter_list|(
specifier|const
name|APInt
modifier|&
name|api
parameter_list|)
function_decl|;
name|void
name|initFromQuadrupleAPInt
parameter_list|(
specifier|const
name|APInt
modifier|&
name|api
parameter_list|)
function_decl|;
name|void
name|initFromF80LongDoubleAPInt
parameter_list|(
specifier|const
name|APInt
modifier|&
name|api
parameter_list|)
function_decl|;
name|void
name|initFromPPCDoubleDoubleAPInt
parameter_list|(
specifier|const
name|APInt
modifier|&
name|api
parameter_list|)
function_decl|;
name|void
name|assign
parameter_list|(
specifier|const
name|APFloat
modifier|&
parameter_list|)
function_decl|;
name|void
name|copySignificand
parameter_list|(
specifier|const
name|APFloat
modifier|&
parameter_list|)
function_decl|;
name|void
name|freeSignificand
parameter_list|()
function_decl|;
comment|/* What kind of semantics does this value obey?  */
specifier|const
name|fltSemantics
modifier|*
name|semantics
decl_stmt|;
comment|/* Significand - the fraction with an explicit integer bit.  Must be        at least one bit wider than the target precision.  */
union|union
name|Significand
block|{
name|integerPart
name|part
decl_stmt|;
name|integerPart
modifier|*
name|parts
decl_stmt|;
block|}
name|significand
union|;
comment|/* The exponent - a signed number.  */
name|exponent_t
name|exponent
decl_stmt|;
comment|/* What kind of floating point number this is.  */
comment|/* Only 2 bits are required, but VisualStudio incorrectly sign extends        it.  Using the extra bit keeps it from failing under VisualStudio */
name|fltCategory
name|category
range|:
literal|3
decl_stmt|;
comment|/* The sign bit of this number.  */
name|unsigned
name|int
name|sign
range|:
literal|1
decl_stmt|;
comment|/* For PPCDoubleDouble, we have a second exponent and sign (the second        significand is appended to the first one, although it would be wrong to        regard these as a single number for arithmetic purposes).  These fields        are not meaningful for any other type. */
name|exponent_t
name|exponent2
range|:
literal|11
decl_stmt|;
name|unsigned
name|int
name|sign2
range|:
literal|1
decl_stmt|;
block|}
empty_stmt|;
block|}
end_decl_stmt

begin_comment
comment|/* namespace llvm */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* LLVM_FLOAT_H */
end_comment

end_unit

