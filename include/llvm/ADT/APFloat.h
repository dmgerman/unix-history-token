begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===- llvm/ADT/APFloat.h - Arbitrary Precision Floating Point ---*- C++ -*-==//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|/// \file
end_comment

begin_comment
comment|/// \brief
end_comment

begin_comment
comment|/// This file declares a class to represent arbitrary precision floating point
end_comment

begin_comment
comment|/// values and provide a variety of arithmetic operations on them.
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LLVM_ADT_APFLOAT_H
end_ifndef

begin_define
define|#
directive|define
name|LLVM_ADT_APFLOAT_H
end_define

begin_include
include|#
directive|include
file|"llvm/ADT/APInt.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/ArrayRef.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/ErrorHandling.h"
end_include

begin_include
include|#
directive|include
file|<memory>
end_include

begin_define
define|#
directive|define
name|APFLOAT_DISPATCH_ON_SEMANTICS
parameter_list|(
name|METHOD_CALL
parameter_list|)
define|\
value|do {                                                                         \     if (usesLayout<IEEEFloat>(getSemantics()))                                 \       return U.IEEE.METHOD_CALL;                                               \     if (usesLayout<DoubleAPFloat>(getSemantics()))                             \       return U.Double.METHOD_CALL;                                             \     llvm_unreachable("Unexpected semantics");                                  \   } while (false)
end_define

begin_decl_stmt
name|namespace
name|llvm
block|{
struct_decl|struct
name|fltSemantics
struct_decl|;
name|class
name|APSInt
decl_stmt|;
name|class
name|StringRef
decl_stmt|;
name|class
name|APFloat
decl_stmt|;
name|class
name|raw_ostream
decl_stmt|;
name|template
operator|<
name|typename
name|T
operator|>
name|class
name|SmallVectorImpl
expr_stmt|;
comment|/// Enum that represents what fraction of the LSB truncated bits of an fp number
comment|/// represent.
comment|///
comment|/// This essentially combines the roles of guard and sticky bits.
enum|enum
name|lostFraction
block|{
comment|// Example of truncated bits:
name|lfExactlyZero
block|,
comment|// 000000
name|lfLessThanHalf
block|,
comment|// 0xxxxx  x's not all zero
name|lfExactlyHalf
block|,
comment|// 100000
name|lfMoreThanHalf
comment|// 1xxxxx  x's not all zero
block|}
enum|;
comment|/// A self-contained host- and target-independent arbitrary-precision
comment|/// floating-point software implementation.
comment|///
comment|/// APFloat uses bignum integer arithmetic as provided by static functions in
comment|/// the APInt class.  The library will work with bignum integers whose parts are
comment|/// any unsigned type at least 16 bits wide, but 64 bits is recommended.
comment|///
comment|/// Written for clarity rather than speed, in particular with a view to use in
comment|/// the front-end of a cross compiler so that target arithmetic can be correctly
comment|/// performed on the host.  Performance should nonetheless be reasonable,
comment|/// particularly for its intended use.  It may be useful as a base
comment|/// implementation for a run-time library during development of a faster
comment|/// target-specific one.
comment|///
comment|/// All 5 rounding modes in the IEEE-754R draft are handled correctly for all
comment|/// implemented operations.  Currently implemented operations are add, subtract,
comment|/// multiply, divide, fused-multiply-add, conversion-to-float,
comment|/// conversion-to-integer and conversion-from-integer.  New rounding modes
comment|/// (e.g. away from zero) can be added with three or four lines of code.
comment|///
comment|/// Four formats are built-in: IEEE single precision, double precision,
comment|/// quadruple precision, and x87 80-bit extended double (when operating with
comment|/// full extended precision).  Adding a new format that obeys IEEE semantics
comment|/// only requires adding two lines of code: a declaration and definition of the
comment|/// format.
comment|///
comment|/// All operations return the status of that operation as an exception bit-mask,
comment|/// so multiple operations can be done consecutively with their results or-ed
comment|/// together.  The returned status can be useful for compiler diagnostics; e.g.,
comment|/// inexact, underflow and overflow can be easily diagnosed on constant folding,
comment|/// and compiler optimizers can determine what exceptions would be raised by
comment|/// folding operations and optimize, or perhaps not optimize, accordingly.
comment|///
comment|/// At present, underflow tininess is detected after rounding; it should be
comment|/// straight forward to add support for the before-rounding case too.
comment|///
comment|/// The library reads hexadecimal floating point numbers as per C99, and
comment|/// correctly rounds if necessary according to the specified rounding mode.
comment|/// Syntax is required to have been validated by the caller.  It also converts
comment|/// floating point numbers to hexadecimal text as per the C99 %a and %A
comment|/// conversions.  The output precision (or alternatively the natural minimal
comment|/// precision) can be specified; if the requested precision is less than the
comment|/// natural precision the output is correctly rounded for the specified rounding
comment|/// mode.
comment|///
comment|/// It also reads decimal floating point numbers and correctly rounds according
comment|/// to the specified rounding mode.
comment|///
comment|/// Conversion to decimal text is not currently implemented.
comment|///
comment|/// Non-zero finite numbers are represented internally as a sign bit, a 16-bit
comment|/// signed exponent, and the significand as an array of integer parts.  After
comment|/// normalization of a number of precision P the exponent is within the range of
comment|/// the format, and if the number is not denormal the P-th bit of the
comment|/// significand is set as an explicit integer bit.  For denormals the most
comment|/// significant bit is shifted right so that the exponent is maintained at the
comment|/// format's minimum, so that the smallest denormal has just the least
comment|/// significant bit of the significand set.  The sign of zeroes and infinities
comment|/// is significant; the exponent and significand of such numbers is not stored,
comment|/// but has a known implicit (deterministic) value: 0 for the significands, 0
comment|/// for zero exponent, all 1 bits for infinity exponent.  For NaNs the sign and
comment|/// significand are deterministic, although not really meaningful, and preserved
comment|/// in non-conversion operations.  The exponent is implicitly all 1 bits.
comment|///
comment|/// APFloat does not provide any exception handling beyond default exception
comment|/// handling. We represent Signaling NaNs via IEEE-754R 2008 6.2.1 should clause
comment|/// by encoding Signaling NaNs with the first bit of its trailing significand as
comment|/// 0.
comment|///
comment|/// TODO
comment|/// ====
comment|///
comment|/// Some features that may or may not be worth adding:
comment|///
comment|/// Binary to decimal conversion (hard).
comment|///
comment|/// Optional ability to detect underflow tininess before rounding.
comment|///
comment|/// New formats: x87 in single and double precision mode (IEEE apart from
comment|/// extended exponent range) (hard).
comment|///
comment|/// New operations: sqrt, IEEE remainder, C90 fmod, nexttoward.
comment|///
comment|// This is the common type definitions shared by APFloat and its internal
comment|// implementation classes. This struct should not define any non-static data
comment|// members.
struct|struct
name|APFloatBase
block|{
comment|// TODO remove this and use APInt typedef directly.
typedef|typedef
name|APInt
operator|::
name|WordType
name|integerPart
expr_stmt|;
comment|/// A signed type to represent a floating point numbers unbiased exponent.
typedef|typedef
name|signed
name|short
name|ExponentType
typedef|;
comment|/// \name Floating Point Semantics.
comment|/// @{
specifier|static
specifier|const
name|fltSemantics
operator|&
name|IEEEhalf
argument_list|()
name|LLVM_READNONE
expr_stmt|;
specifier|static
specifier|const
name|fltSemantics
operator|&
name|IEEEsingle
argument_list|()
name|LLVM_READNONE
expr_stmt|;
specifier|static
specifier|const
name|fltSemantics
operator|&
name|IEEEdouble
argument_list|()
name|LLVM_READNONE
expr_stmt|;
specifier|static
specifier|const
name|fltSemantics
operator|&
name|IEEEquad
argument_list|()
name|LLVM_READNONE
expr_stmt|;
specifier|static
specifier|const
name|fltSemantics
operator|&
name|PPCDoubleDouble
argument_list|()
name|LLVM_READNONE
expr_stmt|;
specifier|static
specifier|const
name|fltSemantics
operator|&
name|x87DoubleExtended
argument_list|()
name|LLVM_READNONE
expr_stmt|;
comment|/// A Pseudo fltsemantic used to construct APFloats that cannot conflict with
comment|/// anything real.
specifier|static
specifier|const
name|fltSemantics
operator|&
name|Bogus
argument_list|()
name|LLVM_READNONE
expr_stmt|;
comment|/// @}
comment|/// IEEE-754R 5.11: Floating Point Comparison Relations.
enum|enum
name|cmpResult
block|{
name|cmpLessThan
block|,
name|cmpEqual
block|,
name|cmpGreaterThan
block|,
name|cmpUnordered
block|}
enum|;
comment|/// IEEE-754R 4.3: Rounding-direction attributes.
enum|enum
name|roundingMode
block|{
name|rmNearestTiesToEven
block|,
name|rmTowardPositive
block|,
name|rmTowardNegative
block|,
name|rmTowardZero
block|,
name|rmNearestTiesToAway
block|}
enum|;
comment|/// IEEE-754R 7: Default exception handling.
comment|///
comment|/// opUnderflow or opOverflow are always returned or-ed with opInexact.
enum|enum
name|opStatus
block|{
name|opOK
init|=
literal|0x00
block|,
name|opInvalidOp
init|=
literal|0x01
block|,
name|opDivByZero
init|=
literal|0x02
block|,
name|opOverflow
init|=
literal|0x04
block|,
name|opUnderflow
init|=
literal|0x08
block|,
name|opInexact
init|=
literal|0x10
block|}
enum|;
comment|/// Category of internally-represented number.
enum|enum
name|fltCategory
block|{
name|fcInfinity
block|,
name|fcNaN
block|,
name|fcNormal
block|,
name|fcZero
block|}
enum|;
comment|/// Convenience enum used to construct an uninitialized APFloat.
enum|enum
name|uninitializedTag
block|{
name|uninitialized
block|}
enum|;
comment|/// Enumeration of \c ilogb error results.
enum|enum
name|IlogbErrorKinds
block|{
name|IEK_Zero
init|=
name|INT_MIN
operator|+
literal|1
block|,
name|IEK_NaN
init|=
name|INT_MIN
block|,
name|IEK_Inf
init|=
name|INT_MAX
block|}
enum|;
specifier|static
name|unsigned
name|int
name|semanticsPrecision
parameter_list|(
specifier|const
name|fltSemantics
modifier|&
parameter_list|)
function_decl|;
specifier|static
name|ExponentType
name|semanticsMinExponent
parameter_list|(
specifier|const
name|fltSemantics
modifier|&
parameter_list|)
function_decl|;
specifier|static
name|ExponentType
name|semanticsMaxExponent
parameter_list|(
specifier|const
name|fltSemantics
modifier|&
parameter_list|)
function_decl|;
specifier|static
name|unsigned
name|int
name|semanticsSizeInBits
parameter_list|(
specifier|const
name|fltSemantics
modifier|&
parameter_list|)
function_decl|;
comment|/// Returns the size of the floating point number (in bits) in the given
comment|/// semantics.
specifier|static
name|unsigned
name|getSizeInBits
parameter_list|(
specifier|const
name|fltSemantics
modifier|&
name|Sem
parameter_list|)
function_decl|;
block|}
struct|;
name|namespace
name|detail
block|{
name|class
name|IEEEFloat
name|final
range|:
name|public
name|APFloatBase
block|{
name|public
operator|:
comment|/// \name Constructors
comment|/// @{
name|IEEEFloat
argument_list|(
specifier|const
name|fltSemantics
operator|&
argument_list|)
block|;
comment|// Default construct to 0.0
name|IEEEFloat
argument_list|(
specifier|const
name|fltSemantics
operator|&
argument_list|,
name|integerPart
argument_list|)
block|;
name|IEEEFloat
argument_list|(
specifier|const
name|fltSemantics
operator|&
argument_list|,
name|uninitializedTag
argument_list|)
block|;
name|IEEEFloat
argument_list|(
specifier|const
name|fltSemantics
operator|&
argument_list|,
specifier|const
name|APInt
operator|&
argument_list|)
block|;
name|explicit
name|IEEEFloat
argument_list|(
argument|double d
argument_list|)
block|;
name|explicit
name|IEEEFloat
argument_list|(
argument|float f
argument_list|)
block|;
name|IEEEFloat
argument_list|(
specifier|const
name|IEEEFloat
operator|&
argument_list|)
block|;
name|IEEEFloat
argument_list|(
name|IEEEFloat
operator|&&
argument_list|)
block|;
operator|~
name|IEEEFloat
argument_list|()
block|;
comment|/// @}
comment|/// Returns whether this instance allocated memory.
name|bool
name|needsCleanup
argument_list|()
specifier|const
block|{
return|return
name|partCount
argument_list|()
operator|>
literal|1
return|;
block|}
comment|/// \name Convenience "constructors"
comment|/// @{
comment|/// @}
comment|/// \name Arithmetic
comment|/// @{
name|opStatus
name|add
argument_list|(
specifier|const
name|IEEEFloat
operator|&
argument_list|,
name|roundingMode
argument_list|)
block|;
name|opStatus
name|subtract
argument_list|(
specifier|const
name|IEEEFloat
operator|&
argument_list|,
name|roundingMode
argument_list|)
block|;
name|opStatus
name|multiply
argument_list|(
specifier|const
name|IEEEFloat
operator|&
argument_list|,
name|roundingMode
argument_list|)
block|;
name|opStatus
name|divide
argument_list|(
specifier|const
name|IEEEFloat
operator|&
argument_list|,
name|roundingMode
argument_list|)
block|;
comment|/// IEEE remainder.
name|opStatus
name|remainder
argument_list|(
specifier|const
name|IEEEFloat
operator|&
argument_list|)
block|;
comment|/// C fmod, or llvm frem.
name|opStatus
name|mod
argument_list|(
specifier|const
name|IEEEFloat
operator|&
argument_list|)
block|;
name|opStatus
name|fusedMultiplyAdd
argument_list|(
specifier|const
name|IEEEFloat
operator|&
argument_list|,
specifier|const
name|IEEEFloat
operator|&
argument_list|,
name|roundingMode
argument_list|)
block|;
name|opStatus
name|roundToIntegral
argument_list|(
name|roundingMode
argument_list|)
block|;
comment|/// IEEE-754R 5.3.1: nextUp/nextDown.
name|opStatus
name|next
argument_list|(
argument|bool nextDown
argument_list|)
block|;
comment|/// @}
comment|/// \name Sign operations.
comment|/// @{
name|void
name|changeSign
argument_list|()
block|;
comment|/// @}
comment|/// \name Conversions
comment|/// @{
name|opStatus
name|convert
argument_list|(
specifier|const
name|fltSemantics
operator|&
argument_list|,
name|roundingMode
argument_list|,
name|bool
operator|*
argument_list|)
block|;
name|opStatus
name|convertToInteger
argument_list|(
argument|MutableArrayRef<integerPart>
argument_list|,
argument|unsigned int
argument_list|,
argument|bool
argument_list|,
argument|roundingMode
argument_list|,
argument|bool *
argument_list|)
specifier|const
block|;
name|opStatus
name|convertFromAPInt
argument_list|(
specifier|const
name|APInt
operator|&
argument_list|,
name|bool
argument_list|,
name|roundingMode
argument_list|)
block|;
name|opStatus
name|convertFromSignExtendedInteger
argument_list|(
argument|const integerPart *
argument_list|,
argument|unsigned int
argument_list|,
argument|bool
argument_list|,
argument|roundingMode
argument_list|)
block|;
name|opStatus
name|convertFromZeroExtendedInteger
argument_list|(
argument|const integerPart *
argument_list|,
argument|unsigned int
argument_list|,
argument|bool
argument_list|,
argument|roundingMode
argument_list|)
block|;
name|opStatus
name|convertFromString
argument_list|(
name|StringRef
argument_list|,
name|roundingMode
argument_list|)
block|;
name|APInt
name|bitcastToAPInt
argument_list|()
specifier|const
block|;
name|double
name|convertToDouble
argument_list|()
specifier|const
block|;
name|float
name|convertToFloat
argument_list|()
specifier|const
block|;
comment|/// @}
comment|/// The definition of equality is not straightforward for floating point, so
comment|/// we won't use operator==.  Use one of the following, or write whatever it
comment|/// is you really mean.
name|bool
name|operator
operator|==
operator|(
specifier|const
name|IEEEFloat
operator|&
operator|)
specifier|const
operator|=
name|delete
block|;
comment|/// IEEE comparison with another floating point number (NaNs compare
comment|/// unordered, 0==-0).
name|cmpResult
name|compare
argument_list|(
argument|const IEEEFloat&
argument_list|)
specifier|const
block|;
comment|/// Bitwise comparison for equality (QNaNs compare equal, 0!=-0).
name|bool
name|bitwiseIsEqual
argument_list|(
argument|const IEEEFloat&
argument_list|)
specifier|const
block|;
comment|/// Write out a hexadecimal representation of the floating point value to DST,
comment|/// which must be of sufficient size, in the C99 form [-]0xh.hhhhp[+-]d.
comment|/// Return the number of characters written, excluding the terminating NUL.
name|unsigned
name|int
name|convertToHexString
argument_list|(
argument|char *dst
argument_list|,
argument|unsigned int hexDigits
argument_list|,
argument|bool upperCase
argument_list|,
argument|roundingMode
argument_list|)
specifier|const
block|;
comment|/// \name IEEE-754R 5.7.2 General operations.
comment|/// @{
comment|/// IEEE-754R isSignMinus: Returns true if and only if the current value is
comment|/// negative.
comment|///
comment|/// This applies to zeros and NaNs as well.
name|bool
name|isNegative
argument_list|()
specifier|const
block|{
return|return
name|sign
return|;
block|}
comment|/// IEEE-754R isNormal: Returns true if and only if the current value is normal.
comment|///
comment|/// This implies that the current value of the float is not zero, subnormal,
comment|/// infinite, or NaN following the definition of normality from IEEE-754R.
name|bool
name|isNormal
argument_list|()
specifier|const
block|{
return|return
operator|!
name|isDenormal
argument_list|()
operator|&&
name|isFiniteNonZero
argument_list|()
return|;
block|}
comment|/// Returns true if and only if the current value is zero, subnormal, or
comment|/// normal.
comment|///
comment|/// This means that the value is not infinite or NaN.
name|bool
name|isFinite
argument_list|()
specifier|const
block|{
return|return
operator|!
name|isNaN
argument_list|()
operator|&&
operator|!
name|isInfinity
argument_list|()
return|;
block|}
comment|/// Returns true if and only if the float is plus or minus zero.
name|bool
name|isZero
argument_list|()
specifier|const
block|{
return|return
name|category
operator|==
name|fcZero
return|;
block|}
comment|/// IEEE-754R isSubnormal(): Returns true if and only if the float is a
comment|/// denormal.
name|bool
name|isDenormal
argument_list|()
specifier|const
block|;
comment|/// IEEE-754R isInfinite(): Returns true if and only if the float is infinity.
name|bool
name|isInfinity
argument_list|()
specifier|const
block|{
return|return
name|category
operator|==
name|fcInfinity
return|;
block|}
comment|/// Returns true if and only if the float is a quiet or signaling NaN.
name|bool
name|isNaN
argument_list|()
specifier|const
block|{
return|return
name|category
operator|==
name|fcNaN
return|;
block|}
comment|/// Returns true if and only if the float is a signaling NaN.
name|bool
name|isSignaling
argument_list|()
specifier|const
block|;
comment|/// @}
comment|/// \name Simple Queries
comment|/// @{
name|fltCategory
name|getCategory
argument_list|()
specifier|const
block|{
return|return
name|category
return|;
block|}
specifier|const
name|fltSemantics
operator|&
name|getSemantics
argument_list|()
specifier|const
block|{
return|return
operator|*
name|semantics
return|;
block|}
name|bool
name|isNonZero
argument_list|()
specifier|const
block|{
return|return
name|category
operator|!=
name|fcZero
return|;
block|}
name|bool
name|isFiniteNonZero
argument_list|()
specifier|const
block|{
return|return
name|isFinite
argument_list|()
operator|&&
operator|!
name|isZero
argument_list|()
return|;
block|}
name|bool
name|isPosZero
argument_list|()
specifier|const
block|{
return|return
name|isZero
argument_list|()
operator|&&
operator|!
name|isNegative
argument_list|()
return|;
block|}
name|bool
name|isNegZero
argument_list|()
specifier|const
block|{
return|return
name|isZero
argument_list|()
operator|&&
name|isNegative
argument_list|()
return|;
block|}
comment|/// Returns true if and only if the number has the smallest possible non-zero
comment|/// magnitude in the current semantics.
name|bool
name|isSmallest
argument_list|()
specifier|const
block|;
comment|/// Returns true if and only if the number has the largest possible finite
comment|/// magnitude in the current semantics.
name|bool
name|isLargest
argument_list|()
specifier|const
block|;
comment|/// Returns true if and only if the number is an exact integer.
name|bool
name|isInteger
argument_list|()
specifier|const
block|;
comment|/// @}
name|IEEEFloat
operator|&
name|operator
operator|=
operator|(
specifier|const
name|IEEEFloat
operator|&
operator|)
block|;
name|IEEEFloat
operator|&
name|operator
operator|=
operator|(
name|IEEEFloat
operator|&&
operator|)
block|;
comment|/// Overload to compute a hash code for an APFloat value.
comment|///
comment|/// Note that the use of hash codes for floating point values is in general
comment|/// frought with peril. Equality is hard to define for these values. For
comment|/// example, should negative and positive zero hash to different codes? Are
comment|/// they equal or not? This hash value implementation specifically
comment|/// emphasizes producing different codes for different inputs in order to
comment|/// be used in canonicalization and memoization. As such, equality is
comment|/// bitwiseIsEqual, and 0 != -0.
name|friend
name|hash_code
name|hash_value
argument_list|(
specifier|const
name|IEEEFloat
operator|&
name|Arg
argument_list|)
block|;
comment|/// Converts this value into a decimal string.
comment|///
comment|/// \param FormatPrecision The maximum number of digits of
comment|///   precision to output.  If there are fewer digits available,
comment|///   zero padding will not be used unless the value is
comment|///   integral and small enough to be expressed in
comment|///   FormatPrecision digits.  0 means to use the natural
comment|///   precision of the number.
comment|/// \param FormatMaxPadding The maximum number of zeros to
comment|///   consider inserting before falling back to scientific
comment|///   notation.  0 means to always use scientific notation.
comment|///
comment|/// Number       Precision    MaxPadding      Result
comment|/// ------       ---------    ----------      ------
comment|/// 1.01E+4              5             2       10100
comment|/// 1.01E+4              4             2       1.01E+4
comment|/// 1.01E+4              5             1       1.01E+4
comment|/// 1.01E-2              5             2       0.0101
comment|/// 1.01E-2              4             2       0.0101
comment|/// 1.01E-2              4             1       1.01E-2
name|void
name|toString
argument_list|(
argument|SmallVectorImpl<char>&Str
argument_list|,
argument|unsigned FormatPrecision =
literal|0
argument_list|,
argument|unsigned FormatMaxPadding =
literal|3
argument_list|)
specifier|const
block|;
comment|/// If this value has an exact multiplicative inverse, store it in inv and
comment|/// return true.
name|bool
name|getExactInverse
argument_list|(
argument|APFloat *inv
argument_list|)
specifier|const
block|;
comment|/// Returns the exponent of the internal representation of the APFloat.
comment|///
comment|/// Because the radix of APFloat is 2, this is equivalent to floor(log2(x)).
comment|/// For special APFloat values, this returns special error codes:
comment|///
comment|///   NaN -> \c IEK_NaN
comment|///   0   -> \c IEK_Zero
comment|///   Inf -> \c IEK_Inf
comment|///
name|friend
name|int
name|ilogb
argument_list|(
specifier|const
name|IEEEFloat
operator|&
name|Arg
argument_list|)
block|;
comment|/// Returns: X * 2^Exp for integral exponents.
name|friend
name|IEEEFloat
name|scalbn
argument_list|(
argument|IEEEFloat X
argument_list|,
argument|int Exp
argument_list|,
argument|roundingMode
argument_list|)
block|;
name|friend
name|IEEEFloat
name|frexp
argument_list|(
specifier|const
name|IEEEFloat
operator|&
name|X
argument_list|,
name|int
operator|&
name|Exp
argument_list|,
name|roundingMode
argument_list|)
block|;
comment|/// \name Special value setters.
comment|/// @{
name|void
name|makeLargest
argument_list|(
argument|bool Neg = false
argument_list|)
block|;
name|void
name|makeSmallest
argument_list|(
argument|bool Neg = false
argument_list|)
block|;
name|void
name|makeNaN
argument_list|(
argument|bool SNaN = false
argument_list|,
argument|bool Neg = false
argument_list|,
argument|const APInt *fill = nullptr
argument_list|)
block|;
name|void
name|makeInf
argument_list|(
argument|bool Neg = false
argument_list|)
block|;
name|void
name|makeZero
argument_list|(
argument|bool Neg = false
argument_list|)
block|;
name|void
name|makeQuiet
argument_list|()
block|;
comment|/// Returns the smallest (by magnitude) normalized finite number in the given
comment|/// semantics.
comment|///
comment|/// \param Negative - True iff the number should be negative
name|void
name|makeSmallestNormalized
argument_list|(
argument|bool Negative = false
argument_list|)
block|;
comment|/// @}
name|cmpResult
name|compareAbsoluteValue
argument_list|(
argument|const IEEEFloat&
argument_list|)
specifier|const
block|;
name|private
operator|:
comment|/// \name Simple Queries
comment|/// @{
name|integerPart
operator|*
name|significandParts
argument_list|()
block|;
specifier|const
name|integerPart
operator|*
name|significandParts
argument_list|()
specifier|const
block|;
name|unsigned
name|int
name|partCount
argument_list|()
specifier|const
block|;
comment|/// @}
comment|/// \name Significand operations.
comment|/// @{
name|integerPart
name|addSignificand
argument_list|(
specifier|const
name|IEEEFloat
operator|&
argument_list|)
block|;
name|integerPart
name|subtractSignificand
argument_list|(
specifier|const
name|IEEEFloat
operator|&
argument_list|,
name|integerPart
argument_list|)
block|;
name|lostFraction
name|addOrSubtractSignificand
argument_list|(
argument|const IEEEFloat&
argument_list|,
argument|bool subtract
argument_list|)
block|;
name|lostFraction
name|multiplySignificand
argument_list|(
specifier|const
name|IEEEFloat
operator|&
argument_list|,
specifier|const
name|IEEEFloat
operator|*
argument_list|)
block|;
name|lostFraction
name|divideSignificand
argument_list|(
specifier|const
name|IEEEFloat
operator|&
argument_list|)
block|;
name|void
name|incrementSignificand
argument_list|()
block|;
name|void
name|initialize
argument_list|(
specifier|const
name|fltSemantics
operator|*
argument_list|)
block|;
name|void
name|shiftSignificandLeft
argument_list|(
argument|unsigned int
argument_list|)
block|;
name|lostFraction
name|shiftSignificandRight
argument_list|(
argument|unsigned int
argument_list|)
block|;
name|unsigned
name|int
name|significandLSB
argument_list|()
specifier|const
block|;
name|unsigned
name|int
name|significandMSB
argument_list|()
specifier|const
block|;
name|void
name|zeroSignificand
argument_list|()
block|;
comment|/// Return true if the significand excluding the integral bit is all ones.
name|bool
name|isSignificandAllOnes
argument_list|()
specifier|const
block|;
comment|/// Return true if the significand excluding the integral bit is all zeros.
name|bool
name|isSignificandAllZeros
argument_list|()
specifier|const
block|;
comment|/// @}
comment|/// \name Arithmetic on special values.
comment|/// @{
name|opStatus
name|addOrSubtractSpecials
argument_list|(
argument|const IEEEFloat&
argument_list|,
argument|bool subtract
argument_list|)
block|;
name|opStatus
name|divideSpecials
argument_list|(
specifier|const
name|IEEEFloat
operator|&
argument_list|)
block|;
name|opStatus
name|multiplySpecials
argument_list|(
specifier|const
name|IEEEFloat
operator|&
argument_list|)
block|;
name|opStatus
name|modSpecials
argument_list|(
specifier|const
name|IEEEFloat
operator|&
argument_list|)
block|;
comment|/// @}
comment|/// \name Miscellany
comment|/// @{
name|bool
name|convertFromStringSpecials
argument_list|(
argument|StringRef str
argument_list|)
block|;
name|opStatus
name|normalize
argument_list|(
name|roundingMode
argument_list|,
name|lostFraction
argument_list|)
block|;
name|opStatus
name|addOrSubtract
argument_list|(
argument|const IEEEFloat&
argument_list|,
argument|roundingMode
argument_list|,
argument|bool subtract
argument_list|)
block|;
name|opStatus
name|handleOverflow
argument_list|(
name|roundingMode
argument_list|)
block|;
name|bool
name|roundAwayFromZero
argument_list|(
argument|roundingMode
argument_list|,
argument|lostFraction
argument_list|,
argument|unsigned int
argument_list|)
specifier|const
block|;
name|opStatus
name|convertToSignExtendedInteger
argument_list|(
argument|MutableArrayRef<integerPart>
argument_list|,
argument|unsigned int
argument_list|,
argument|bool
argument_list|,
argument|roundingMode
argument_list|,
argument|bool *
argument_list|)
specifier|const
block|;
name|opStatus
name|convertFromUnsignedParts
argument_list|(
argument|const integerPart *
argument_list|,
argument|unsigned int
argument_list|,
argument|roundingMode
argument_list|)
block|;
name|opStatus
name|convertFromHexadecimalString
argument_list|(
name|StringRef
argument_list|,
name|roundingMode
argument_list|)
block|;
name|opStatus
name|convertFromDecimalString
argument_list|(
name|StringRef
argument_list|,
name|roundingMode
argument_list|)
block|;
name|char
operator|*
name|convertNormalToHexString
argument_list|(
argument|char *
argument_list|,
argument|unsigned int
argument_list|,
argument|bool
argument_list|,
argument|roundingMode
argument_list|)
specifier|const
block|;
name|opStatus
name|roundSignificandWithExponent
argument_list|(
argument|const integerPart *
argument_list|,
argument|unsigned int
argument_list|,
argument|int
argument_list|,
argument|roundingMode
argument_list|)
block|;
comment|/// @}
name|APInt
name|convertHalfAPFloatToAPInt
argument_list|()
specifier|const
block|;
name|APInt
name|convertFloatAPFloatToAPInt
argument_list|()
specifier|const
block|;
name|APInt
name|convertDoubleAPFloatToAPInt
argument_list|()
specifier|const
block|;
name|APInt
name|convertQuadrupleAPFloatToAPInt
argument_list|()
specifier|const
block|;
name|APInt
name|convertF80LongDoubleAPFloatToAPInt
argument_list|()
specifier|const
block|;
name|APInt
name|convertPPCDoubleDoubleAPFloatToAPInt
argument_list|()
specifier|const
block|;
name|void
name|initFromAPInt
argument_list|(
specifier|const
name|fltSemantics
operator|*
name|Sem
argument_list|,
specifier|const
name|APInt
operator|&
name|api
argument_list|)
block|;
name|void
name|initFromHalfAPInt
argument_list|(
specifier|const
name|APInt
operator|&
name|api
argument_list|)
block|;
name|void
name|initFromFloatAPInt
argument_list|(
specifier|const
name|APInt
operator|&
name|api
argument_list|)
block|;
name|void
name|initFromDoubleAPInt
argument_list|(
specifier|const
name|APInt
operator|&
name|api
argument_list|)
block|;
name|void
name|initFromQuadrupleAPInt
argument_list|(
specifier|const
name|APInt
operator|&
name|api
argument_list|)
block|;
name|void
name|initFromF80LongDoubleAPInt
argument_list|(
specifier|const
name|APInt
operator|&
name|api
argument_list|)
block|;
name|void
name|initFromPPCDoubleDoubleAPInt
argument_list|(
specifier|const
name|APInt
operator|&
name|api
argument_list|)
block|;
name|void
name|assign
argument_list|(
specifier|const
name|IEEEFloat
operator|&
argument_list|)
block|;
name|void
name|copySignificand
argument_list|(
specifier|const
name|IEEEFloat
operator|&
argument_list|)
block|;
name|void
name|freeSignificand
argument_list|()
block|;
comment|/// Note: this must be the first data member.
comment|/// The semantics that this value obeys.
specifier|const
name|fltSemantics
operator|*
name|semantics
block|;
comment|/// A binary fraction with an explicit integer bit.
comment|///
comment|/// The significand must be at least one bit wider than the target precision.
expr|union
name|Significand
block|{
name|integerPart
name|part
block|;
name|integerPart
operator|*
name|parts
block|;   }
name|significand
block|;
comment|/// The signed unbiased exponent of the value.
name|ExponentType
name|exponent
block|;
comment|/// What kind of floating point number this is.
comment|///
comment|/// Only 2 bits are required, but VisualStudio incorrectly sign extends it.
comment|/// Using the extra bit keeps it from failing under VisualStudio.
name|fltCategory
name|category
operator|:
literal|3
block|;
comment|/// Sign bit of the number.
name|unsigned
name|int
name|sign
operator|:
literal|1
block|; }
decl_stmt|;
name|hash_code
name|hash_value
parameter_list|(
specifier|const
name|IEEEFloat
modifier|&
name|Arg
parameter_list|)
function_decl|;
name|int
name|ilogb
parameter_list|(
specifier|const
name|IEEEFloat
modifier|&
name|Arg
parameter_list|)
function_decl|;
name|IEEEFloat
name|scalbn
argument_list|(
name|IEEEFloat
name|X
argument_list|,
name|int
name|Exp
argument_list|,
name|IEEEFloat
operator|::
name|roundingMode
argument_list|)
decl_stmt|;
name|IEEEFloat
name|frexp
argument_list|(
specifier|const
name|IEEEFloat
operator|&
name|Val
argument_list|,
name|int
operator|&
name|Exp
argument_list|,
name|IEEEFloat
operator|::
name|roundingMode
name|RM
argument_list|)
decl_stmt|;
comment|// This mode implements more precise float in terms of two APFloats.
comment|// The interface and layout is designed for arbitray underlying semantics,
comment|// though currently only PPCDoubleDouble semantics are supported, whose
comment|// corresponding underlying semantics are IEEEdouble.
name|class
name|DoubleAPFloat
name|final
range|:
name|public
name|APFloatBase
block|{
comment|// Note: this must be the first data member.
specifier|const
name|fltSemantics
operator|*
name|Semantics
block|;
name|std
operator|::
name|unique_ptr
operator|<
name|APFloat
index|[]
operator|>
name|Floats
block|;
name|opStatus
name|addImpl
argument_list|(
argument|const APFloat&a
argument_list|,
argument|const APFloat&aa
argument_list|,
argument|const APFloat&c
argument_list|,
argument|const APFloat&cc
argument_list|,
argument|roundingMode RM
argument_list|)
block|;
name|opStatus
name|addWithSpecial
argument_list|(
argument|const DoubleAPFloat&LHS
argument_list|,
argument|const DoubleAPFloat&RHS
argument_list|,
argument|DoubleAPFloat&Out
argument_list|,
argument|roundingMode RM
argument_list|)
block|;
name|public
operator|:
name|DoubleAPFloat
argument_list|(
specifier|const
name|fltSemantics
operator|&
name|S
argument_list|)
block|;
name|DoubleAPFloat
argument_list|(
specifier|const
name|fltSemantics
operator|&
name|S
argument_list|,
name|uninitializedTag
argument_list|)
block|;
name|DoubleAPFloat
argument_list|(
specifier|const
name|fltSemantics
operator|&
name|S
argument_list|,
name|integerPart
argument_list|)
block|;
name|DoubleAPFloat
argument_list|(
specifier|const
name|fltSemantics
operator|&
name|S
argument_list|,
specifier|const
name|APInt
operator|&
name|I
argument_list|)
block|;
name|DoubleAPFloat
argument_list|(
specifier|const
name|fltSemantics
operator|&
name|S
argument_list|,
name|APFloat
operator|&&
name|First
argument_list|,
name|APFloat
operator|&&
name|Second
argument_list|)
block|;
name|DoubleAPFloat
argument_list|(
specifier|const
name|DoubleAPFloat
operator|&
name|RHS
argument_list|)
block|;
name|DoubleAPFloat
argument_list|(
name|DoubleAPFloat
operator|&&
name|RHS
argument_list|)
block|;
name|DoubleAPFloat
operator|&
name|operator
operator|=
operator|(
specifier|const
name|DoubleAPFloat
operator|&
name|RHS
operator|)
block|;
name|DoubleAPFloat
operator|&
name|operator
operator|=
operator|(
name|DoubleAPFloat
operator|&&
name|RHS
operator|)
block|{
if|if
condition|(
name|this
operator|!=
operator|&
name|RHS
condition|)
block|{
name|this
operator|->
expr|~
name|DoubleAPFloat
argument_list|()
expr_stmt|;
name|new
argument_list|(
argument|this
argument_list|)
name|DoubleAPFloat
argument_list|(
name|std
operator|::
name|move
argument_list|(
name|RHS
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|*
name|this
return|;
block|}
name|bool
name|needsCleanup
argument_list|()
specifier|const
block|{
return|return
name|Floats
operator|!=
name|nullptr
return|;
block|}
name|APFloat
operator|&
name|getFirst
argument_list|()
block|{
return|return
name|Floats
index|[
literal|0
index|]
return|;
block|}
specifier|const
name|APFloat
operator|&
name|getFirst
argument_list|()
specifier|const
block|{
return|return
name|Floats
index|[
literal|0
index|]
return|;
block|}
name|APFloat
operator|&
name|getSecond
argument_list|()
block|{
return|return
name|Floats
index|[
literal|1
index|]
return|;
block|}
specifier|const
name|APFloat
operator|&
name|getSecond
argument_list|()
specifier|const
block|{
return|return
name|Floats
index|[
literal|1
index|]
return|;
block|}
name|opStatus
name|add
argument_list|(
argument|const DoubleAPFloat&RHS
argument_list|,
argument|roundingMode RM
argument_list|)
block|;
name|opStatus
name|subtract
argument_list|(
argument|const DoubleAPFloat&RHS
argument_list|,
argument|roundingMode RM
argument_list|)
block|;
name|opStatus
name|multiply
argument_list|(
argument|const DoubleAPFloat&RHS
argument_list|,
argument|roundingMode RM
argument_list|)
block|;
name|opStatus
name|divide
argument_list|(
argument|const DoubleAPFloat&RHS
argument_list|,
argument|roundingMode RM
argument_list|)
block|;
name|opStatus
name|remainder
argument_list|(
specifier|const
name|DoubleAPFloat
operator|&
name|RHS
argument_list|)
block|;
name|opStatus
name|mod
argument_list|(
specifier|const
name|DoubleAPFloat
operator|&
name|RHS
argument_list|)
block|;
name|opStatus
name|fusedMultiplyAdd
argument_list|(
argument|const DoubleAPFloat&Multiplicand
argument_list|,
argument|const DoubleAPFloat&Addend
argument_list|,
argument|roundingMode RM
argument_list|)
block|;
name|opStatus
name|roundToIntegral
argument_list|(
argument|roundingMode RM
argument_list|)
block|;
name|void
name|changeSign
argument_list|()
block|;
name|cmpResult
name|compareAbsoluteValue
argument_list|(
argument|const DoubleAPFloat&RHS
argument_list|)
specifier|const
block|;
name|fltCategory
name|getCategory
argument_list|()
specifier|const
block|;
name|bool
name|isNegative
argument_list|()
specifier|const
block|;
name|void
name|makeInf
argument_list|(
argument|bool Neg
argument_list|)
block|;
name|void
name|makeZero
argument_list|(
argument|bool Neg
argument_list|)
block|;
name|void
name|makeLargest
argument_list|(
argument|bool Neg
argument_list|)
block|;
name|void
name|makeSmallest
argument_list|(
argument|bool Neg
argument_list|)
block|;
name|void
name|makeSmallestNormalized
argument_list|(
argument|bool Neg
argument_list|)
block|;
name|void
name|makeNaN
argument_list|(
argument|bool SNaN
argument_list|,
argument|bool Neg
argument_list|,
argument|const APInt *fill
argument_list|)
block|;
name|cmpResult
name|compare
argument_list|(
argument|const DoubleAPFloat&RHS
argument_list|)
specifier|const
block|;
name|bool
name|bitwiseIsEqual
argument_list|(
argument|const DoubleAPFloat&RHS
argument_list|)
specifier|const
block|;
name|APInt
name|bitcastToAPInt
argument_list|()
specifier|const
block|;
name|opStatus
name|convertFromString
argument_list|(
name|StringRef
argument_list|,
name|roundingMode
argument_list|)
block|;
name|opStatus
name|next
argument_list|(
argument|bool nextDown
argument_list|)
block|;
name|opStatus
name|convertToInteger
argument_list|(
argument|MutableArrayRef<integerPart> Input
argument_list|,
argument|unsigned int Width
argument_list|,
argument|bool IsSigned
argument_list|,
argument|roundingMode RM
argument_list|,
argument|bool *IsExact
argument_list|)
specifier|const
block|;
name|opStatus
name|convertFromAPInt
argument_list|(
argument|const APInt&Input
argument_list|,
argument|bool IsSigned
argument_list|,
argument|roundingMode RM
argument_list|)
block|;
name|opStatus
name|convertFromSignExtendedInteger
argument_list|(
argument|const integerPart *Input
argument_list|,
argument|unsigned int InputSize
argument_list|,
argument|bool IsSigned
argument_list|,
argument|roundingMode RM
argument_list|)
block|;
name|opStatus
name|convertFromZeroExtendedInteger
argument_list|(
argument|const integerPart *Input
argument_list|,
argument|unsigned int InputSize
argument_list|,
argument|bool IsSigned
argument_list|,
argument|roundingMode RM
argument_list|)
block|;
name|unsigned
name|int
name|convertToHexString
argument_list|(
argument|char *DST
argument_list|,
argument|unsigned int HexDigits
argument_list|,
argument|bool UpperCase
argument_list|,
argument|roundingMode RM
argument_list|)
specifier|const
block|;
name|bool
name|isDenormal
argument_list|()
specifier|const
block|;
name|bool
name|isSmallest
argument_list|()
specifier|const
block|;
name|bool
name|isLargest
argument_list|()
specifier|const
block|;
name|bool
name|isInteger
argument_list|()
specifier|const
block|;
name|void
name|toString
argument_list|(
argument|SmallVectorImpl<char>&Str
argument_list|,
argument|unsigned FormatPrecision
argument_list|,
argument|unsigned FormatMaxPadding
argument_list|)
specifier|const
block|;
name|bool
name|getExactInverse
argument_list|(
argument|APFloat *inv
argument_list|)
specifier|const
block|;
name|friend
name|int
name|ilogb
argument_list|(
specifier|const
name|DoubleAPFloat
operator|&
name|Arg
argument_list|)
block|;
name|friend
name|DoubleAPFloat
name|scalbn
argument_list|(
argument|DoubleAPFloat X
argument_list|,
argument|int Exp
argument_list|,
argument|roundingMode
argument_list|)
block|;
name|friend
name|DoubleAPFloat
name|frexp
argument_list|(
specifier|const
name|DoubleAPFloat
operator|&
name|X
argument_list|,
name|int
operator|&
name|Exp
argument_list|,
name|roundingMode
argument_list|)
block|;
name|friend
name|hash_code
name|hash_value
argument_list|(
specifier|const
name|DoubleAPFloat
operator|&
name|Arg
argument_list|)
block|; }
decl_stmt|;
name|hash_code
name|hash_value
parameter_list|(
specifier|const
name|DoubleAPFloat
modifier|&
name|Arg
parameter_list|)
function_decl|;
block|}
comment|// End detail namespace
comment|// This is a interface class that is currently forwarding functionalities from
comment|// detail::IEEEFloat.
name|class
name|APFloat
range|:
name|public
name|APFloatBase
block|{
typedef|typedef
name|detail
operator|::
name|IEEEFloat
name|IEEEFloat
expr_stmt|;
typedef|typedef
name|detail
operator|::
name|DoubleAPFloat
name|DoubleAPFloat
expr_stmt|;
name|static_assert
argument_list|(
name|std
operator|::
name|is_standard_layout
operator|<
name|IEEEFloat
operator|>
operator|::
name|value
argument_list|,
literal|""
argument_list|)
expr_stmt|;
union|union
name|Storage
block|{
specifier|const
name|fltSemantics
modifier|*
name|semantics
decl_stmt|;
name|IEEEFloat
name|IEEE
decl_stmt|;
name|DoubleAPFloat
name|Double
decl_stmt|;
name|explicit
name|Storage
parameter_list|(
name|IEEEFloat
name|F
parameter_list|,
specifier|const
name|fltSemantics
modifier|&
name|S
parameter_list|)
function_decl|;
name|explicit
name|Storage
argument_list|(
argument|DoubleAPFloat F
argument_list|,
argument|const fltSemantics&S
argument_list|)
block|:
name|Double
argument_list|(
argument|std::move(F)
argument_list|)
block|{
name|assert
argument_list|(
operator|&
name|S
operator|==
operator|&
name|PPCDoubleDouble
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|template
operator|<
name|typename
operator|...
name|ArgTypes
operator|>
name|Storage
argument_list|(
argument|const fltSemantics&Semantics
argument_list|,
argument|ArgTypes&&... Args
argument_list|)
block|{
if|if
condition|(
name|usesLayout
operator|<
name|IEEEFloat
operator|>
operator|(
name|Semantics
operator|)
condition|)
block|{
name|new
argument_list|(
argument|&IEEE
argument_list|)
name|IEEEFloat
argument_list|(
name|Semantics
argument_list|,
name|std
operator|::
name|forward
operator|<
name|ArgTypes
operator|>
operator|(
name|Args
operator|)
operator|...
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|usesLayout
operator|<
name|DoubleAPFloat
operator|>
operator|(
name|Semantics
operator|)
condition|)
block|{
name|new
argument_list|(
argument|&Double
argument_list|)
name|DoubleAPFloat
argument_list|(
name|Semantics
argument_list|,
name|std
operator|::
name|forward
operator|<
name|ArgTypes
operator|>
operator|(
name|Args
operator|)
operator|...
argument_list|)
expr_stmt|;
return|return;
block|}
name|llvm_unreachable
argument_list|(
literal|"Unexpected semantics"
argument_list|)
expr_stmt|;
block|}
operator|~
name|Storage
argument_list|()
block|{
if|if
condition|(
name|usesLayout
operator|<
name|IEEEFloat
operator|>
operator|(
operator|*
name|semantics
operator|)
condition|)
block|{
name|IEEE
operator|.
expr|~
name|IEEEFloat
argument_list|()
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|usesLayout
operator|<
name|DoubleAPFloat
operator|>
operator|(
operator|*
name|semantics
operator|)
condition|)
block|{
name|Double
operator|.
expr|~
name|DoubleAPFloat
argument_list|()
expr_stmt|;
return|return;
block|}
name|llvm_unreachable
argument_list|(
literal|"Unexpected semantics"
argument_list|)
expr_stmt|;
block|}
name|Storage
argument_list|(
argument|const Storage&RHS
argument_list|)
block|{
if|if
condition|(
name|usesLayout
operator|<
name|IEEEFloat
operator|>
operator|(
operator|*
name|RHS
operator|.
name|semantics
operator|)
condition|)
block|{
name|new
argument_list|(
argument|this
argument_list|)
name|IEEEFloat
argument_list|(
name|RHS
operator|.
name|IEEE
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|usesLayout
operator|<
name|DoubleAPFloat
operator|>
operator|(
operator|*
name|RHS
operator|.
name|semantics
operator|)
condition|)
block|{
name|new
argument_list|(
argument|this
argument_list|)
name|DoubleAPFloat
argument_list|(
name|RHS
operator|.
name|Double
argument_list|)
expr_stmt|;
return|return;
block|}
name|llvm_unreachable
argument_list|(
literal|"Unexpected semantics"
argument_list|)
expr_stmt|;
block|}
name|Storage
argument_list|(
argument|Storage&&RHS
argument_list|)
block|{
if|if
condition|(
name|usesLayout
operator|<
name|IEEEFloat
operator|>
operator|(
operator|*
name|RHS
operator|.
name|semantics
operator|)
condition|)
block|{
name|new
argument_list|(
argument|this
argument_list|)
name|IEEEFloat
argument_list|(
name|std
operator|::
name|move
argument_list|(
name|RHS
operator|.
name|IEEE
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|usesLayout
operator|<
name|DoubleAPFloat
operator|>
operator|(
operator|*
name|RHS
operator|.
name|semantics
operator|)
condition|)
block|{
name|new
argument_list|(
argument|this
argument_list|)
name|DoubleAPFloat
argument_list|(
name|std
operator|::
name|move
argument_list|(
name|RHS
operator|.
name|Double
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|llvm_unreachable
argument_list|(
literal|"Unexpected semantics"
argument_list|)
expr_stmt|;
block|}
name|Storage
modifier|&
name|operator
init|=
operator|(
specifier|const
name|Storage
operator|&
name|RHS
operator|)
block|{
if|if
condition|(
name|usesLayout
operator|<
name|IEEEFloat
operator|>
operator|(
operator|*
name|semantics
operator|)
operator|&&
name|usesLayout
operator|<
name|IEEEFloat
operator|>
operator|(
operator|*
name|RHS
operator|.
name|semantics
operator|)
condition|)
block|{
name|IEEE
operator|=
name|RHS
operator|.
name|IEEE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|usesLayout
operator|<
name|DoubleAPFloat
operator|>
operator|(
operator|*
name|semantics
operator|)
operator|&&
name|usesLayout
operator|<
name|DoubleAPFloat
operator|>
operator|(
operator|*
name|RHS
operator|.
name|semantics
operator|)
condition|)
block|{
name|Double
operator|=
name|RHS
operator|.
name|Double
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|this
operator|!=
operator|&
name|RHS
condition|)
block|{
name|this
operator|->
expr|~
name|Storage
argument_list|()
expr_stmt|;
name|new
argument_list|(
argument|this
argument_list|)
name|Storage
argument_list|(
name|RHS
argument_list|)
expr_stmt|;
block|}
return|return
operator|*
name|this
return|;
block|}
name|Storage
modifier|&
name|operator
init|=
operator|(
name|Storage
operator|&&
name|RHS
operator|)
block|{
if|if
condition|(
name|usesLayout
operator|<
name|IEEEFloat
operator|>
operator|(
operator|*
name|semantics
operator|)
operator|&&
name|usesLayout
operator|<
name|IEEEFloat
operator|>
operator|(
operator|*
name|RHS
operator|.
name|semantics
operator|)
condition|)
block|{
name|IEEE
operator|=
name|std
operator|::
name|move
argument_list|(
name|RHS
operator|.
name|IEEE
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|usesLayout
operator|<
name|DoubleAPFloat
operator|>
operator|(
operator|*
name|semantics
operator|)
operator|&&
name|usesLayout
operator|<
name|DoubleAPFloat
operator|>
operator|(
operator|*
name|RHS
operator|.
name|semantics
operator|)
condition|)
block|{
name|Double
operator|=
name|std
operator|::
name|move
argument_list|(
name|RHS
operator|.
name|Double
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|this
operator|!=
operator|&
name|RHS
condition|)
block|{
name|this
operator|->
expr|~
name|Storage
argument_list|()
expr_stmt|;
name|new
argument_list|(
argument|this
argument_list|)
name|Storage
argument_list|(
name|std
operator|::
name|move
argument_list|(
name|RHS
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|*
name|this
return|;
block|}
block|}
name|U
union|;
name|template
operator|<
name|typename
name|T
operator|>
specifier|static
name|bool
name|usesLayout
argument_list|(
argument|const fltSemantics&Semantics
argument_list|)
block|{
name|static_assert
argument_list|(
name|std
operator|::
name|is_same
operator|<
name|T
argument_list|,
name|IEEEFloat
operator|>
operator|::
name|value
operator|||
name|std
operator|::
name|is_same
operator|<
name|T
argument_list|,
name|DoubleAPFloat
operator|>
operator|::
name|value
argument_list|,
literal|""
argument_list|)
block|;
if|if
condition|(
name|std
operator|::
name|is_same
operator|<
name|T
operator|,
name|DoubleAPFloat
operator|>
operator|::
name|value
condition|)
block|{
return|return
operator|&
name|Semantics
operator|==
operator|&
name|PPCDoubleDouble
argument_list|()
return|;
block|}
return|return
operator|&
name|Semantics
operator|!=
operator|&
name|PPCDoubleDouble
argument_list|()
return|;
block|}
name|IEEEFloat
modifier|&
name|getIEEE
parameter_list|()
block|{
if|if
condition|(
name|usesLayout
operator|<
name|IEEEFloat
operator|>
operator|(
operator|*
name|U
operator|.
name|semantics
operator|)
condition|)
return|return
name|U
operator|.
name|IEEE
return|;
if|if
condition|(
name|usesLayout
operator|<
name|DoubleAPFloat
operator|>
operator|(
operator|*
name|U
operator|.
name|semantics
operator|)
condition|)
return|return
name|U
operator|.
name|Double
operator|.
name|getFirst
argument_list|()
operator|.
name|U
operator|.
name|IEEE
return|;
name|llvm_unreachable
argument_list|(
literal|"Unexpected semantics"
argument_list|)
expr_stmt|;
block|}
specifier|const
name|IEEEFloat
operator|&
name|getIEEE
argument_list|()
specifier|const
block|{
if|if
condition|(
name|usesLayout
operator|<
name|IEEEFloat
operator|>
operator|(
operator|*
name|U
operator|.
name|semantics
operator|)
condition|)
return|return
name|U
operator|.
name|IEEE
return|;
if|if
condition|(
name|usesLayout
operator|<
name|DoubleAPFloat
operator|>
operator|(
operator|*
name|U
operator|.
name|semantics
operator|)
condition|)
return|return
name|U
operator|.
name|Double
operator|.
name|getFirst
argument_list|()
operator|.
name|U
operator|.
name|IEEE
return|;
name|llvm_unreachable
argument_list|(
literal|"Unexpected semantics"
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_function
name|void
name|makeZero
parameter_list|(
name|bool
name|Neg
parameter_list|)
block|{
name|APFLOAT_DISPATCH_ON_SEMANTICS
argument_list|(
name|makeZero
argument_list|(
name|Neg
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|makeInf
parameter_list|(
name|bool
name|Neg
parameter_list|)
block|{
name|APFLOAT_DISPATCH_ON_SEMANTICS
argument_list|(
name|makeInf
argument_list|(
name|Neg
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|makeNaN
parameter_list|(
name|bool
name|SNaN
parameter_list|,
name|bool
name|Neg
parameter_list|,
specifier|const
name|APInt
modifier|*
name|fill
parameter_list|)
block|{
name|APFLOAT_DISPATCH_ON_SEMANTICS
argument_list|(
name|makeNaN
argument_list|(
name|SNaN
argument_list|,
name|Neg
argument_list|,
name|fill
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|makeLargest
parameter_list|(
name|bool
name|Neg
parameter_list|)
block|{
name|APFLOAT_DISPATCH_ON_SEMANTICS
argument_list|(
name|makeLargest
argument_list|(
name|Neg
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|makeSmallest
parameter_list|(
name|bool
name|Neg
parameter_list|)
block|{
name|APFLOAT_DISPATCH_ON_SEMANTICS
argument_list|(
name|makeSmallest
argument_list|(
name|Neg
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|makeSmallestNormalized
parameter_list|(
name|bool
name|Neg
parameter_list|)
block|{
name|APFLOAT_DISPATCH_ON_SEMANTICS
argument_list|(
name|makeSmallestNormalized
argument_list|(
name|Neg
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|// FIXME: This is due to clang 3.3 (or older version) always checks for the
end_comment

begin_comment
comment|// default constructor in an array aggregate initialization, even if no
end_comment

begin_comment
comment|// elements in the array is default initialized.
end_comment

begin_expr_stmt
name|APFloat
argument_list|()
operator|:
name|U
argument_list|(
argument|IEEEdouble()
argument_list|)
block|{
name|llvm_unreachable
argument_list|(
literal|"This is a workaround for old clang."
argument_list|)
block|;   }
name|explicit
name|APFloat
argument_list|(
argument|IEEEFloat F
argument_list|,
argument|const fltSemantics&S
argument_list|)
operator|:
name|U
argument_list|(
argument|std::move(F)
argument_list|,
argument|S
argument_list|)
block|{}
name|explicit
name|APFloat
argument_list|(
argument|DoubleAPFloat F
argument_list|,
argument|const fltSemantics&S
argument_list|)
operator|:
name|U
argument_list|(
argument|std::move(F)
argument_list|,
argument|S
argument_list|)
block|{}
name|cmpResult
name|compareAbsoluteValue
argument_list|(
argument|const APFloat&RHS
argument_list|)
specifier|const
block|{
name|assert
argument_list|(
operator|&
name|getSemantics
argument_list|()
operator|==
operator|&
name|RHS
operator|.
name|getSemantics
argument_list|()
operator|&&
literal|"Should only compare APFloats with the same semantics"
argument_list|)
block|;
if|if
condition|(
name|usesLayout
operator|<
name|IEEEFloat
operator|>
operator|(
name|getSemantics
argument_list|()
operator|)
condition|)
return|return
name|U
operator|.
name|IEEE
operator|.
name|compareAbsoluteValue
argument_list|(
name|RHS
operator|.
name|U
operator|.
name|IEEE
argument_list|)
return|;
end_expr_stmt

begin_if
if|if
condition|(
name|usesLayout
operator|<
name|DoubleAPFloat
operator|>
operator|(
name|getSemantics
argument_list|()
operator|)
condition|)
return|return
name|U
operator|.
name|Double
operator|.
name|compareAbsoluteValue
argument_list|(
name|RHS
operator|.
name|U
operator|.
name|Double
argument_list|)
return|;
end_if

begin_expr_stmt
name|llvm_unreachable
argument_list|(
literal|"Unexpected semantics"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
unit|}  public:
name|APFloat
argument_list|(
specifier|const
name|fltSemantics
operator|&
name|Semantics
argument_list|)
operator|:
name|U
argument_list|(
argument|Semantics
argument_list|)
block|{}
name|APFloat
argument_list|(
argument|const fltSemantics&Semantics
argument_list|,
argument|StringRef S
argument_list|)
expr_stmt|;
end_expr_stmt

begin_macro
name|APFloat
argument_list|(
argument|const fltSemantics&Semantics
argument_list|,
argument|integerPart I
argument_list|)
end_macro

begin_macro
unit|:
name|U
argument_list|(
argument|Semantics
argument_list|,
argument|I
argument_list|)
end_macro

begin_block
block|{}
end_block

begin_comment
comment|// TODO: Remove this constructor. This isn't faster than the first one.
end_comment

begin_expr_stmt
name|APFloat
argument_list|(
specifier|const
name|fltSemantics
operator|&
name|Semantics
argument_list|,
name|uninitializedTag
argument_list|)
operator|:
name|U
argument_list|(
argument|Semantics
argument_list|,
argument|uninitialized
argument_list|)
block|{}
name|APFloat
argument_list|(
specifier|const
name|fltSemantics
operator|&
name|Semantics
argument_list|,
specifier|const
name|APInt
operator|&
name|I
argument_list|)
operator|:
name|U
argument_list|(
argument|Semantics
argument_list|,
argument|I
argument_list|)
block|{}
name|explicit
name|APFloat
argument_list|(
argument|double d
argument_list|)
operator|:
name|U
argument_list|(
argument|IEEEFloat(d)
argument_list|,
argument|IEEEdouble()
argument_list|)
block|{}
name|explicit
name|APFloat
argument_list|(
argument|float f
argument_list|)
operator|:
name|U
argument_list|(
argument|IEEEFloat(f)
argument_list|,
argument|IEEEsingle()
argument_list|)
block|{}
name|APFloat
argument_list|(
specifier|const
name|APFloat
operator|&
name|RHS
argument_list|)
operator|=
expr|default
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|APFloat
argument_list|(
name|APFloat
operator|&&
name|RHS
argument_list|)
operator|=
expr|default
expr_stmt|;
end_expr_stmt

begin_expr_stmt
operator|~
name|APFloat
argument_list|()
operator|=
expr|default
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|bool
name|needsCleanup
argument_list|()
specifier|const
block|{
name|APFLOAT_DISPATCH_ON_SEMANTICS
argument_list|(
name|needsCleanup
argument_list|()
argument_list|)
block|; }
comment|/// Factory for Positive and Negative Zero.
comment|///
comment|/// \param Negative True iff the number should be negative.
specifier|static
name|APFloat
name|getZero
argument_list|(
argument|const fltSemantics&Sem
argument_list|,
argument|bool Negative = false
argument_list|)
block|{
name|APFloat
name|Val
argument_list|(
name|Sem
argument_list|,
name|uninitialized
argument_list|)
block|;
name|Val
operator|.
name|makeZero
argument_list|(
name|Negative
argument_list|)
block|;
return|return
name|Val
return|;
block|}
end_expr_stmt

begin_comment
comment|/// Factory for Positive and Negative Infinity.
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|/// \param Negative True iff the number should be negative.
end_comment

begin_function
specifier|static
name|APFloat
name|getInf
parameter_list|(
specifier|const
name|fltSemantics
modifier|&
name|Sem
parameter_list|,
name|bool
name|Negative
init|=
name|false
parameter_list|)
block|{
name|APFloat
name|Val
argument_list|(
name|Sem
argument_list|,
name|uninitialized
argument_list|)
decl_stmt|;
name|Val
operator|.
name|makeInf
argument_list|(
name|Negative
argument_list|)
expr_stmt|;
return|return
name|Val
return|;
block|}
end_function

begin_comment
comment|/// Factory for NaN values.
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|/// \param Negative - True iff the NaN generated should be negative.
end_comment

begin_comment
comment|/// \param type - The unspecified fill bits for creating the NaN, 0 by
end_comment

begin_comment
comment|/// default.  The value is truncated as necessary.
end_comment

begin_function
specifier|static
name|APFloat
name|getNaN
parameter_list|(
specifier|const
name|fltSemantics
modifier|&
name|Sem
parameter_list|,
name|bool
name|Negative
init|=
name|false
parameter_list|,
name|unsigned
name|type
init|=
literal|0
parameter_list|)
block|{
if|if
condition|(
name|type
condition|)
block|{
name|APInt
name|fill
argument_list|(
literal|64
argument_list|,
name|type
argument_list|)
decl_stmt|;
return|return
name|getQNaN
argument_list|(
name|Sem
argument_list|,
name|Negative
argument_list|,
operator|&
name|fill
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|getQNaN
argument_list|(
name|Sem
argument_list|,
name|Negative
argument_list|,
name|nullptr
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|/// Factory for QNaN values.
end_comment

begin_function
specifier|static
name|APFloat
name|getQNaN
parameter_list|(
specifier|const
name|fltSemantics
modifier|&
name|Sem
parameter_list|,
name|bool
name|Negative
init|=
name|false
parameter_list|,
specifier|const
name|APInt
modifier|*
name|payload
init|=
name|nullptr
parameter_list|)
block|{
name|APFloat
name|Val
argument_list|(
name|Sem
argument_list|,
name|uninitialized
argument_list|)
decl_stmt|;
name|Val
operator|.
name|makeNaN
argument_list|(
name|false
argument_list|,
name|Negative
argument_list|,
name|payload
argument_list|)
expr_stmt|;
return|return
name|Val
return|;
block|}
end_function

begin_comment
comment|/// Factory for SNaN values.
end_comment

begin_function
specifier|static
name|APFloat
name|getSNaN
parameter_list|(
specifier|const
name|fltSemantics
modifier|&
name|Sem
parameter_list|,
name|bool
name|Negative
init|=
name|false
parameter_list|,
specifier|const
name|APInt
modifier|*
name|payload
init|=
name|nullptr
parameter_list|)
block|{
name|APFloat
name|Val
argument_list|(
name|Sem
argument_list|,
name|uninitialized
argument_list|)
decl_stmt|;
name|Val
operator|.
name|makeNaN
argument_list|(
name|true
argument_list|,
name|Negative
argument_list|,
name|payload
argument_list|)
expr_stmt|;
return|return
name|Val
return|;
block|}
end_function

begin_comment
comment|/// Returns the largest finite number in the given semantics.
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|/// \param Negative - True iff the number should be negative
end_comment

begin_function
specifier|static
name|APFloat
name|getLargest
parameter_list|(
specifier|const
name|fltSemantics
modifier|&
name|Sem
parameter_list|,
name|bool
name|Negative
init|=
name|false
parameter_list|)
block|{
name|APFloat
name|Val
argument_list|(
name|Sem
argument_list|,
name|uninitialized
argument_list|)
decl_stmt|;
name|Val
operator|.
name|makeLargest
argument_list|(
name|Negative
argument_list|)
expr_stmt|;
return|return
name|Val
return|;
block|}
end_function

begin_comment
comment|/// Returns the smallest (by magnitude) finite number in the given semantics.
end_comment

begin_comment
comment|/// Might be denormalized, which implies a relative loss of precision.
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|/// \param Negative - True iff the number should be negative
end_comment

begin_function
specifier|static
name|APFloat
name|getSmallest
parameter_list|(
specifier|const
name|fltSemantics
modifier|&
name|Sem
parameter_list|,
name|bool
name|Negative
init|=
name|false
parameter_list|)
block|{
name|APFloat
name|Val
argument_list|(
name|Sem
argument_list|,
name|uninitialized
argument_list|)
decl_stmt|;
name|Val
operator|.
name|makeSmallest
argument_list|(
name|Negative
argument_list|)
expr_stmt|;
return|return
name|Val
return|;
block|}
end_function

begin_comment
comment|/// Returns the smallest (by magnitude) normalized finite number in the given
end_comment

begin_comment
comment|/// semantics.
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|/// \param Negative - True iff the number should be negative
end_comment

begin_function
specifier|static
name|APFloat
name|getSmallestNormalized
parameter_list|(
specifier|const
name|fltSemantics
modifier|&
name|Sem
parameter_list|,
name|bool
name|Negative
init|=
name|false
parameter_list|)
block|{
name|APFloat
name|Val
argument_list|(
name|Sem
argument_list|,
name|uninitialized
argument_list|)
decl_stmt|;
name|Val
operator|.
name|makeSmallestNormalized
argument_list|(
name|Negative
argument_list|)
expr_stmt|;
return|return
name|Val
return|;
block|}
end_function

begin_comment
comment|/// Returns a float which is bitcasted from an all one value int.
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|/// \param BitWidth - Select float type
end_comment

begin_comment
comment|/// \param isIEEE   - If 128 bit number, select between PPC and IEEE
end_comment

begin_function_decl
specifier|static
name|APFloat
name|getAllOnesValue
parameter_list|(
name|unsigned
name|BitWidth
parameter_list|,
name|bool
name|isIEEE
init|=
name|false
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/// Used to insert APFloat objects, or objects that contain APFloat objects,
end_comment

begin_comment
comment|/// into FoldingSets.
end_comment

begin_decl_stmt
name|void
name|Profile
argument_list|(
name|FoldingSetNodeID
operator|&
name|NID
argument_list|)
decl|const
decl_stmt|;
end_decl_stmt

begin_function
name|opStatus
name|add
parameter_list|(
specifier|const
name|APFloat
modifier|&
name|RHS
parameter_list|,
name|roundingMode
name|RM
parameter_list|)
block|{
name|assert
argument_list|(
operator|&
name|getSemantics
argument_list|()
operator|==
operator|&
name|RHS
operator|.
name|getSemantics
argument_list|()
operator|&&
literal|"Should only call on two APFloats with the same semantics"
argument_list|)
expr_stmt|;
if|if
condition|(
name|usesLayout
operator|<
name|IEEEFloat
operator|>
operator|(
name|getSemantics
argument_list|()
operator|)
condition|)
return|return
name|U
operator|.
name|IEEE
operator|.
name|add
argument_list|(
name|RHS
operator|.
name|U
operator|.
name|IEEE
argument_list|,
name|RM
argument_list|)
return|;
if|if
condition|(
name|usesLayout
operator|<
name|DoubleAPFloat
operator|>
operator|(
name|getSemantics
argument_list|()
operator|)
condition|)
return|return
name|U
operator|.
name|Double
operator|.
name|add
argument_list|(
name|RHS
operator|.
name|U
operator|.
name|Double
argument_list|,
name|RM
argument_list|)
return|;
name|llvm_unreachable
argument_list|(
literal|"Unexpected semantics"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|opStatus
name|subtract
parameter_list|(
specifier|const
name|APFloat
modifier|&
name|RHS
parameter_list|,
name|roundingMode
name|RM
parameter_list|)
block|{
name|assert
argument_list|(
operator|&
name|getSemantics
argument_list|()
operator|==
operator|&
name|RHS
operator|.
name|getSemantics
argument_list|()
operator|&&
literal|"Should only call on two APFloats with the same semantics"
argument_list|)
expr_stmt|;
if|if
condition|(
name|usesLayout
operator|<
name|IEEEFloat
operator|>
operator|(
name|getSemantics
argument_list|()
operator|)
condition|)
return|return
name|U
operator|.
name|IEEE
operator|.
name|subtract
argument_list|(
name|RHS
operator|.
name|U
operator|.
name|IEEE
argument_list|,
name|RM
argument_list|)
return|;
if|if
condition|(
name|usesLayout
operator|<
name|DoubleAPFloat
operator|>
operator|(
name|getSemantics
argument_list|()
operator|)
condition|)
return|return
name|U
operator|.
name|Double
operator|.
name|subtract
argument_list|(
name|RHS
operator|.
name|U
operator|.
name|Double
argument_list|,
name|RM
argument_list|)
return|;
name|llvm_unreachable
argument_list|(
literal|"Unexpected semantics"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|opStatus
name|multiply
parameter_list|(
specifier|const
name|APFloat
modifier|&
name|RHS
parameter_list|,
name|roundingMode
name|RM
parameter_list|)
block|{
name|assert
argument_list|(
operator|&
name|getSemantics
argument_list|()
operator|==
operator|&
name|RHS
operator|.
name|getSemantics
argument_list|()
operator|&&
literal|"Should only call on two APFloats with the same semantics"
argument_list|)
expr_stmt|;
if|if
condition|(
name|usesLayout
operator|<
name|IEEEFloat
operator|>
operator|(
name|getSemantics
argument_list|()
operator|)
condition|)
return|return
name|U
operator|.
name|IEEE
operator|.
name|multiply
argument_list|(
name|RHS
operator|.
name|U
operator|.
name|IEEE
argument_list|,
name|RM
argument_list|)
return|;
if|if
condition|(
name|usesLayout
operator|<
name|DoubleAPFloat
operator|>
operator|(
name|getSemantics
argument_list|()
operator|)
condition|)
return|return
name|U
operator|.
name|Double
operator|.
name|multiply
argument_list|(
name|RHS
operator|.
name|U
operator|.
name|Double
argument_list|,
name|RM
argument_list|)
return|;
name|llvm_unreachable
argument_list|(
literal|"Unexpected semantics"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|opStatus
name|divide
parameter_list|(
specifier|const
name|APFloat
modifier|&
name|RHS
parameter_list|,
name|roundingMode
name|RM
parameter_list|)
block|{
name|assert
argument_list|(
operator|&
name|getSemantics
argument_list|()
operator|==
operator|&
name|RHS
operator|.
name|getSemantics
argument_list|()
operator|&&
literal|"Should only call on two APFloats with the same semantics"
argument_list|)
expr_stmt|;
if|if
condition|(
name|usesLayout
operator|<
name|IEEEFloat
operator|>
operator|(
name|getSemantics
argument_list|()
operator|)
condition|)
return|return
name|U
operator|.
name|IEEE
operator|.
name|divide
argument_list|(
name|RHS
operator|.
name|U
operator|.
name|IEEE
argument_list|,
name|RM
argument_list|)
return|;
if|if
condition|(
name|usesLayout
operator|<
name|DoubleAPFloat
operator|>
operator|(
name|getSemantics
argument_list|()
operator|)
condition|)
return|return
name|U
operator|.
name|Double
operator|.
name|divide
argument_list|(
name|RHS
operator|.
name|U
operator|.
name|Double
argument_list|,
name|RM
argument_list|)
return|;
name|llvm_unreachable
argument_list|(
literal|"Unexpected semantics"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|opStatus
name|remainder
parameter_list|(
specifier|const
name|APFloat
modifier|&
name|RHS
parameter_list|)
block|{
name|assert
argument_list|(
operator|&
name|getSemantics
argument_list|()
operator|==
operator|&
name|RHS
operator|.
name|getSemantics
argument_list|()
operator|&&
literal|"Should only call on two APFloats with the same semantics"
argument_list|)
expr_stmt|;
if|if
condition|(
name|usesLayout
operator|<
name|IEEEFloat
operator|>
operator|(
name|getSemantics
argument_list|()
operator|)
condition|)
return|return
name|U
operator|.
name|IEEE
operator|.
name|remainder
argument_list|(
name|RHS
operator|.
name|U
operator|.
name|IEEE
argument_list|)
return|;
if|if
condition|(
name|usesLayout
operator|<
name|DoubleAPFloat
operator|>
operator|(
name|getSemantics
argument_list|()
operator|)
condition|)
return|return
name|U
operator|.
name|Double
operator|.
name|remainder
argument_list|(
name|RHS
operator|.
name|U
operator|.
name|Double
argument_list|)
return|;
name|llvm_unreachable
argument_list|(
literal|"Unexpected semantics"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|opStatus
name|mod
parameter_list|(
specifier|const
name|APFloat
modifier|&
name|RHS
parameter_list|)
block|{
name|assert
argument_list|(
operator|&
name|getSemantics
argument_list|()
operator|==
operator|&
name|RHS
operator|.
name|getSemantics
argument_list|()
operator|&&
literal|"Should only call on two APFloats with the same semantics"
argument_list|)
expr_stmt|;
if|if
condition|(
name|usesLayout
operator|<
name|IEEEFloat
operator|>
operator|(
name|getSemantics
argument_list|()
operator|)
condition|)
return|return
name|U
operator|.
name|IEEE
operator|.
name|mod
argument_list|(
name|RHS
operator|.
name|U
operator|.
name|IEEE
argument_list|)
return|;
if|if
condition|(
name|usesLayout
operator|<
name|DoubleAPFloat
operator|>
operator|(
name|getSemantics
argument_list|()
operator|)
condition|)
return|return
name|U
operator|.
name|Double
operator|.
name|mod
argument_list|(
name|RHS
operator|.
name|U
operator|.
name|Double
argument_list|)
return|;
name|llvm_unreachable
argument_list|(
literal|"Unexpected semantics"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|opStatus
name|fusedMultiplyAdd
parameter_list|(
specifier|const
name|APFloat
modifier|&
name|Multiplicand
parameter_list|,
specifier|const
name|APFloat
modifier|&
name|Addend
parameter_list|,
name|roundingMode
name|RM
parameter_list|)
block|{
name|assert
argument_list|(
operator|&
name|getSemantics
argument_list|()
operator|==
operator|&
name|Multiplicand
operator|.
name|getSemantics
argument_list|()
operator|&&
literal|"Should only call on APFloats with the same semantics"
argument_list|)
expr_stmt|;
name|assert
argument_list|(
operator|&
name|getSemantics
argument_list|()
operator|==
operator|&
name|Addend
operator|.
name|getSemantics
argument_list|()
operator|&&
literal|"Should only call on APFloats with the same semantics"
argument_list|)
expr_stmt|;
if|if
condition|(
name|usesLayout
operator|<
name|IEEEFloat
operator|>
operator|(
name|getSemantics
argument_list|()
operator|)
condition|)
return|return
name|U
operator|.
name|IEEE
operator|.
name|fusedMultiplyAdd
argument_list|(
name|Multiplicand
operator|.
name|U
operator|.
name|IEEE
argument_list|,
name|Addend
operator|.
name|U
operator|.
name|IEEE
argument_list|,
name|RM
argument_list|)
return|;
if|if
condition|(
name|usesLayout
operator|<
name|DoubleAPFloat
operator|>
operator|(
name|getSemantics
argument_list|()
operator|)
condition|)
return|return
name|U
operator|.
name|Double
operator|.
name|fusedMultiplyAdd
argument_list|(
name|Multiplicand
operator|.
name|U
operator|.
name|Double
argument_list|,
name|Addend
operator|.
name|U
operator|.
name|Double
argument_list|,
name|RM
argument_list|)
return|;
name|llvm_unreachable
argument_list|(
literal|"Unexpected semantics"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|opStatus
name|roundToIntegral
parameter_list|(
name|roundingMode
name|RM
parameter_list|)
block|{
name|APFLOAT_DISPATCH_ON_SEMANTICS
argument_list|(
name|roundToIntegral
argument_list|(
name|RM
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|// TODO: bool parameters are not readable and a source of bugs.
end_comment

begin_comment
comment|// Do something.
end_comment

begin_function
name|opStatus
name|next
parameter_list|(
name|bool
name|nextDown
parameter_list|)
block|{
name|APFLOAT_DISPATCH_ON_SEMANTICS
argument_list|(
name|next
argument_list|(
name|nextDown
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/// Add two APFloats, rounding ties to the nearest even.
end_comment

begin_comment
comment|/// No error checking.
end_comment

begin_expr_stmt
name|APFloat
name|operator
operator|+
operator|(
specifier|const
name|APFloat
operator|&
name|RHS
operator|)
specifier|const
block|{
name|APFloat
name|Result
argument_list|(
operator|*
name|this
argument_list|)
block|;
operator|(
name|void
operator|)
name|Result
operator|.
name|add
argument_list|(
name|RHS
argument_list|,
name|rmNearestTiesToEven
argument_list|)
block|;
return|return
name|Result
return|;
block|}
end_expr_stmt

begin_comment
comment|/// Subtract two APFloats, rounding ties to the nearest even.
end_comment

begin_comment
comment|/// No error checking.
end_comment

begin_expr_stmt
name|APFloat
name|operator
operator|-
operator|(
specifier|const
name|APFloat
operator|&
name|RHS
operator|)
specifier|const
block|{
name|APFloat
name|Result
argument_list|(
operator|*
name|this
argument_list|)
block|;
operator|(
name|void
operator|)
name|Result
operator|.
name|subtract
argument_list|(
name|RHS
argument_list|,
name|rmNearestTiesToEven
argument_list|)
block|;
return|return
name|Result
return|;
block|}
end_expr_stmt

begin_comment
comment|/// Multiply two APFloats, rounding ties to the nearest even.
end_comment

begin_comment
comment|/// No error checking.
end_comment

begin_decl_stmt
name|APFloat
name|operator
modifier|*
argument_list|(
specifier|const
name|APFloat
operator|&
name|RHS
argument_list|)
decl|const
block|{
name|APFloat
name|Result
argument_list|(
operator|*
name|this
argument_list|)
decl_stmt|;
operator|(
name|void
operator|)
name|Result
operator|.
name|multiply
argument_list|(
name|RHS
argument_list|,
name|rmNearestTiesToEven
argument_list|)
expr_stmt|;
return|return
name|Result
return|;
block|}
end_decl_stmt

begin_comment
comment|/// Divide the first APFloat by the second, rounding ties to the nearest even.
end_comment

begin_comment
comment|/// No error checking.
end_comment

begin_expr_stmt
name|APFloat
name|operator
operator|/
operator|(
specifier|const
name|APFloat
operator|&
name|RHS
operator|)
specifier|const
block|{
name|APFloat
name|Result
argument_list|(
operator|*
name|this
argument_list|)
block|;
operator|(
name|void
operator|)
name|Result
operator|.
name|divide
argument_list|(
name|RHS
argument_list|,
name|rmNearestTiesToEven
argument_list|)
block|;
return|return
name|Result
return|;
block|}
end_expr_stmt

begin_function
name|void
name|changeSign
parameter_list|()
block|{
name|APFLOAT_DISPATCH_ON_SEMANTICS
argument_list|(
name|changeSign
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|clearSign
parameter_list|()
block|{
if|if
condition|(
name|isNegative
argument_list|()
condition|)
name|changeSign
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|copySign
parameter_list|(
specifier|const
name|APFloat
modifier|&
name|RHS
parameter_list|)
block|{
if|if
condition|(
name|isNegative
argument_list|()
operator|!=
name|RHS
operator|.
name|isNegative
argument_list|()
condition|)
name|changeSign
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/// A static helper to produce a copy of an APFloat value with its sign
end_comment

begin_comment
comment|/// copied from some other APFloat.
end_comment

begin_function
specifier|static
name|APFloat
name|copySign
parameter_list|(
name|APFloat
name|Value
parameter_list|,
specifier|const
name|APFloat
modifier|&
name|Sign
parameter_list|)
block|{
name|Value
operator|.
name|copySign
argument_list|(
name|Sign
argument_list|)
expr_stmt|;
return|return
name|Value
return|;
block|}
end_function

begin_function_decl
name|opStatus
name|convert
parameter_list|(
specifier|const
name|fltSemantics
modifier|&
name|ToSemantics
parameter_list|,
name|roundingMode
name|RM
parameter_list|,
name|bool
modifier|*
name|losesInfo
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
name|opStatus
name|convertToInteger
argument_list|(
name|MutableArrayRef
operator|<
name|integerPart
operator|>
name|Input
argument_list|,
name|unsigned
name|int
name|Width
argument_list|,
name|bool
name|IsSigned
argument_list|,
name|roundingMode
name|RM
argument_list|,
name|bool
operator|*
name|IsExact
argument_list|)
decl|const
block|{
name|APFLOAT_DISPATCH_ON_SEMANTICS
argument_list|(
name|convertToInteger
argument_list|(
name|Input
argument_list|,
name|Width
argument_list|,
name|IsSigned
argument_list|,
name|RM
argument_list|,
name|IsExact
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_decl_stmt
name|opStatus
name|convertToInteger
argument_list|(
name|APSInt
operator|&
name|Result
argument_list|,
name|roundingMode
name|RM
argument_list|,
name|bool
operator|*
name|IsExact
argument_list|)
decl|const
decl_stmt|;
end_decl_stmt

begin_function
name|opStatus
name|convertFromAPInt
parameter_list|(
specifier|const
name|APInt
modifier|&
name|Input
parameter_list|,
name|bool
name|IsSigned
parameter_list|,
name|roundingMode
name|RM
parameter_list|)
block|{
name|APFLOAT_DISPATCH_ON_SEMANTICS
argument_list|(
name|convertFromAPInt
argument_list|(
name|Input
argument_list|,
name|IsSigned
argument_list|,
name|RM
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|opStatus
name|convertFromSignExtendedInteger
parameter_list|(
specifier|const
name|integerPart
modifier|*
name|Input
parameter_list|,
name|unsigned
name|int
name|InputSize
parameter_list|,
name|bool
name|IsSigned
parameter_list|,
name|roundingMode
name|RM
parameter_list|)
block|{
name|APFLOAT_DISPATCH_ON_SEMANTICS
argument_list|(
name|convertFromSignExtendedInteger
argument_list|(
name|Input
argument_list|,
name|InputSize
argument_list|,
name|IsSigned
argument_list|,
name|RM
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|opStatus
name|convertFromZeroExtendedInteger
parameter_list|(
specifier|const
name|integerPart
modifier|*
name|Input
parameter_list|,
name|unsigned
name|int
name|InputSize
parameter_list|,
name|bool
name|IsSigned
parameter_list|,
name|roundingMode
name|RM
parameter_list|)
block|{
name|APFLOAT_DISPATCH_ON_SEMANTICS
argument_list|(
name|convertFromZeroExtendedInteger
argument_list|(
name|Input
argument_list|,
name|InputSize
argument_list|,
name|IsSigned
argument_list|,
name|RM
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function_decl
name|opStatus
name|convertFromString
parameter_list|(
name|StringRef
parameter_list|,
name|roundingMode
parameter_list|)
function_decl|;
end_function_decl

begin_expr_stmt
name|APInt
name|bitcastToAPInt
argument_list|()
specifier|const
block|{
name|APFLOAT_DISPATCH_ON_SEMANTICS
argument_list|(
name|bitcastToAPInt
argument_list|()
argument_list|)
block|;   }
name|double
name|convertToDouble
argument_list|()
specifier|const
block|{
return|return
name|getIEEE
argument_list|()
operator|.
name|convertToDouble
argument_list|()
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|float
name|convertToFloat
argument_list|()
specifier|const
block|{
return|return
name|getIEEE
argument_list|()
operator|.
name|convertToFloat
argument_list|()
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|bool
name|operator
operator|==
operator|(
specifier|const
name|APFloat
operator|&
operator|)
specifier|const
operator|=
name|delete
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|cmpResult
name|compare
argument_list|(
specifier|const
name|APFloat
operator|&
name|RHS
argument_list|)
decl|const
block|{
name|assert
argument_list|(
operator|&
name|getSemantics
argument_list|()
operator|==
operator|&
name|RHS
operator|.
name|getSemantics
argument_list|()
operator|&&
literal|"Should only compare APFloats with the same semantics"
argument_list|)
expr_stmt|;
if|if
condition|(
name|usesLayout
operator|<
name|IEEEFloat
operator|>
operator|(
name|getSemantics
argument_list|()
operator|)
condition|)
return|return
name|U
operator|.
name|IEEE
operator|.
name|compare
argument_list|(
name|RHS
operator|.
name|U
operator|.
name|IEEE
argument_list|)
return|;
if|if
condition|(
name|usesLayout
operator|<
name|DoubleAPFloat
operator|>
operator|(
name|getSemantics
argument_list|()
operator|)
condition|)
return|return
name|U
operator|.
name|Double
operator|.
name|compare
argument_list|(
name|RHS
operator|.
name|U
operator|.
name|Double
argument_list|)
return|;
name|llvm_unreachable
argument_list|(
literal|"Unexpected semantics"
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_decl_stmt
name|bool
name|bitwiseIsEqual
argument_list|(
specifier|const
name|APFloat
operator|&
name|RHS
argument_list|)
decl|const
block|{
if|if
condition|(
operator|&
name|getSemantics
argument_list|()
operator|!=
operator|&
name|RHS
operator|.
name|getSemantics
argument_list|()
condition|)
return|return
name|false
return|;
if|if
condition|(
name|usesLayout
operator|<
name|IEEEFloat
operator|>
operator|(
name|getSemantics
argument_list|()
operator|)
condition|)
return|return
name|U
operator|.
name|IEEE
operator|.
name|bitwiseIsEqual
argument_list|(
name|RHS
operator|.
name|U
operator|.
name|IEEE
argument_list|)
return|;
if|if
condition|(
name|usesLayout
operator|<
name|DoubleAPFloat
operator|>
operator|(
name|getSemantics
argument_list|()
operator|)
condition|)
return|return
name|U
operator|.
name|Double
operator|.
name|bitwiseIsEqual
argument_list|(
name|RHS
operator|.
name|U
operator|.
name|Double
argument_list|)
return|;
name|llvm_unreachable
argument_list|(
literal|"Unexpected semantics"
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_decl_stmt
name|unsigned
name|int
name|convertToHexString
argument_list|(
name|char
operator|*
name|DST
argument_list|,
name|unsigned
name|int
name|HexDigits
argument_list|,
name|bool
name|UpperCase
argument_list|,
name|roundingMode
name|RM
argument_list|)
decl|const
block|{
name|APFLOAT_DISPATCH_ON_SEMANTICS
argument_list|(
name|convertToHexString
argument_list|(
name|DST
argument_list|,
name|HexDigits
argument_list|,
name|UpperCase
argument_list|,
name|RM
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_expr_stmt
name|bool
name|isZero
argument_list|()
specifier|const
block|{
return|return
name|getCategory
argument_list|()
operator|==
name|fcZero
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|bool
name|isInfinity
argument_list|()
specifier|const
block|{
return|return
name|getCategory
argument_list|()
operator|==
name|fcInfinity
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|bool
name|isNaN
argument_list|()
specifier|const
block|{
return|return
name|getCategory
argument_list|()
operator|==
name|fcNaN
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|bool
name|isNegative
argument_list|()
specifier|const
block|{
return|return
name|getIEEE
argument_list|()
operator|.
name|isNegative
argument_list|()
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|bool
name|isDenormal
argument_list|()
specifier|const
block|{
name|APFLOAT_DISPATCH_ON_SEMANTICS
argument_list|(
name|isDenormal
argument_list|()
argument_list|)
block|; }
name|bool
name|isSignaling
argument_list|()
specifier|const
block|{
return|return
name|getIEEE
argument_list|()
operator|.
name|isSignaling
argument_list|()
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|bool
name|isNormal
argument_list|()
specifier|const
block|{
return|return
operator|!
name|isDenormal
argument_list|()
operator|&&
name|isFiniteNonZero
argument_list|()
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|bool
name|isFinite
argument_list|()
specifier|const
block|{
return|return
operator|!
name|isNaN
argument_list|()
operator|&&
operator|!
name|isInfinity
argument_list|()
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|fltCategory
name|getCategory
argument_list|()
specifier|const
block|{
return|return
name|getIEEE
argument_list|()
operator|.
name|getCategory
argument_list|()
return|;
block|}
end_expr_stmt

begin_expr_stmt
specifier|const
name|fltSemantics
operator|&
name|getSemantics
argument_list|()
specifier|const
block|{
return|return
operator|*
name|U
operator|.
name|semantics
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|bool
name|isNonZero
argument_list|()
specifier|const
block|{
return|return
operator|!
name|isZero
argument_list|()
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|bool
name|isFiniteNonZero
argument_list|()
specifier|const
block|{
return|return
name|isFinite
argument_list|()
operator|&&
operator|!
name|isZero
argument_list|()
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|bool
name|isPosZero
argument_list|()
specifier|const
block|{
return|return
name|isZero
argument_list|()
operator|&&
operator|!
name|isNegative
argument_list|()
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|bool
name|isNegZero
argument_list|()
specifier|const
block|{
return|return
name|isZero
argument_list|()
operator|&&
name|isNegative
argument_list|()
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|bool
name|isSmallest
argument_list|()
specifier|const
block|{
name|APFLOAT_DISPATCH_ON_SEMANTICS
argument_list|(
name|isSmallest
argument_list|()
argument_list|)
block|; }
name|bool
name|isLargest
argument_list|()
specifier|const
block|{
name|APFLOAT_DISPATCH_ON_SEMANTICS
argument_list|(
name|isLargest
argument_list|()
argument_list|)
block|; }
name|bool
name|isInteger
argument_list|()
specifier|const
block|{
name|APFLOAT_DISPATCH_ON_SEMANTICS
argument_list|(
name|isInteger
argument_list|()
argument_list|)
block|; }
name|APFloat
operator|&
name|operator
operator|=
operator|(
specifier|const
name|APFloat
operator|&
name|RHS
operator|)
operator|=
expr|default
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|APFloat
modifier|&
name|operator
init|=
operator|(
name|APFloat
operator|&&
name|RHS
operator|)
operator|=
expr|default
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|toString
argument_list|(
name|SmallVectorImpl
operator|<
name|char
operator|>
operator|&
name|Str
argument_list|,
name|unsigned
name|FormatPrecision
operator|=
literal|0
argument_list|,
name|unsigned
name|FormatMaxPadding
operator|=
literal|3
argument_list|)
decl|const
block|{
name|APFLOAT_DISPATCH_ON_SEMANTICS
argument_list|(
name|toString
argument_list|(
name|Str
argument_list|,
name|FormatPrecision
argument_list|,
name|FormatMaxPadding
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_decl_stmt
name|void
name|print
argument_list|(
name|raw_ostream
operator|&
argument_list|)
decl|const
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|void
name|dump
argument_list|()
specifier|const
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|bool
name|getExactInverse
argument_list|(
name|APFloat
operator|*
name|inv
argument_list|)
decl|const
block|{
name|APFLOAT_DISPATCH_ON_SEMANTICS
argument_list|(
name|getExactInverse
argument_list|(
name|inv
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_function_decl
name|friend
name|hash_code
name|hash_value
parameter_list|(
specifier|const
name|APFloat
modifier|&
name|Arg
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|friend
name|int
name|ilogb
parameter_list|(
specifier|const
name|APFloat
modifier|&
name|Arg
parameter_list|)
block|{
return|return
name|ilogb
argument_list|(
name|Arg
operator|.
name|getIEEE
argument_list|()
argument_list|)
return|;
block|}
end_function

begin_function_decl
name|friend
name|APFloat
name|scalbn
parameter_list|(
name|APFloat
name|X
parameter_list|,
name|int
name|Exp
parameter_list|,
name|roundingMode
name|RM
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|friend
name|APFloat
name|frexp
parameter_list|(
specifier|const
name|APFloat
modifier|&
name|X
parameter_list|,
name|int
modifier|&
name|Exp
parameter_list|,
name|roundingMode
name|RM
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
name|friend
name|IEEEFloat
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|friend
name|DoubleAPFloat
decl_stmt|;
end_decl_stmt

begin_comment
unit|};
comment|/// See friend declarations above.
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|/// These additional declarations are required in order to compile LLVM with IBM
end_comment

begin_comment
comment|/// xlC compiler.
end_comment

begin_function_decl
name|hash_code
name|hash_value
parameter_list|(
specifier|const
name|APFloat
modifier|&
name|Arg
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|inline
name|APFloat
name|scalbn
argument_list|(
name|APFloat
name|X
argument_list|,
name|int
name|Exp
argument_list|,
name|APFloat
operator|::
name|roundingMode
name|RM
argument_list|)
block|{
if|if
condition|(
name|APFloat
operator|::
name|usesLayout
operator|<
name|detail
operator|::
name|IEEEFloat
operator|>
operator|(
name|X
operator|.
name|getSemantics
argument_list|()
operator|)
condition|)
return|return
name|APFloat
argument_list|(
name|scalbn
argument_list|(
name|X
operator|.
name|U
operator|.
name|IEEE
argument_list|,
name|Exp
argument_list|,
name|RM
argument_list|)
argument_list|,
name|X
operator|.
name|getSemantics
argument_list|()
argument_list|)
return|;
if|if
condition|(
name|APFloat
operator|::
name|usesLayout
operator|<
name|detail
operator|::
name|DoubleAPFloat
operator|>
operator|(
name|X
operator|.
name|getSemantics
argument_list|()
operator|)
condition|)
return|return
name|APFloat
argument_list|(
name|scalbn
argument_list|(
name|X
operator|.
name|U
operator|.
name|Double
argument_list|,
name|Exp
argument_list|,
name|RM
argument_list|)
argument_list|,
name|X
operator|.
name|getSemantics
argument_list|()
argument_list|)
return|;
name|llvm_unreachable
argument_list|(
literal|"Unexpected semantics"
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_comment
comment|/// Equivalent of C standard library function.
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|/// While the C standard says Exp is an unspecified value for infinity and nan,
end_comment

begin_comment
comment|/// this returns INT_MAX for infinities, and INT_MIN for NaNs.
end_comment

begin_decl_stmt
specifier|inline
name|APFloat
name|frexp
argument_list|(
specifier|const
name|APFloat
operator|&
name|X
argument_list|,
name|int
operator|&
name|Exp
argument_list|,
name|APFloat
operator|::
name|roundingMode
name|RM
argument_list|)
block|{
if|if
condition|(
name|APFloat
operator|::
name|usesLayout
operator|<
name|detail
operator|::
name|IEEEFloat
operator|>
operator|(
name|X
operator|.
name|getSemantics
argument_list|()
operator|)
condition|)
return|return
name|APFloat
argument_list|(
name|frexp
argument_list|(
name|X
operator|.
name|U
operator|.
name|IEEE
argument_list|,
name|Exp
argument_list|,
name|RM
argument_list|)
argument_list|,
name|X
operator|.
name|getSemantics
argument_list|()
argument_list|)
return|;
if|if
condition|(
name|APFloat
operator|::
name|usesLayout
operator|<
name|detail
operator|::
name|DoubleAPFloat
operator|>
operator|(
name|X
operator|.
name|getSemantics
argument_list|()
operator|)
condition|)
return|return
name|APFloat
argument_list|(
name|frexp
argument_list|(
name|X
operator|.
name|U
operator|.
name|Double
argument_list|,
name|Exp
argument_list|,
name|RM
argument_list|)
argument_list|,
name|X
operator|.
name|getSemantics
argument_list|()
argument_list|)
return|;
name|llvm_unreachable
argument_list|(
literal|"Unexpected semantics"
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_comment
comment|/// Returns the absolute value of the argument.
end_comment

begin_function
specifier|inline
name|APFloat
name|abs
parameter_list|(
name|APFloat
name|X
parameter_list|)
block|{
name|X
operator|.
name|clearSign
argument_list|()
expr_stmt|;
return|return
name|X
return|;
block|}
end_function

begin_comment
comment|/// \brief Returns the negated value of the argument.
end_comment

begin_function
specifier|inline
name|APFloat
name|neg
parameter_list|(
name|APFloat
name|X
parameter_list|)
block|{
name|X
operator|.
name|changeSign
argument_list|()
expr_stmt|;
return|return
name|X
return|;
block|}
end_function

begin_comment
comment|/// Implements IEEE minNum semantics. Returns the smaller of the 2 arguments if
end_comment

begin_comment
comment|/// both are not NaN. If either argument is a NaN, returns the other argument.
end_comment

begin_function
name|LLVM_READONLY
specifier|inline
name|APFloat
name|minnum
parameter_list|(
specifier|const
name|APFloat
modifier|&
name|A
parameter_list|,
specifier|const
name|APFloat
modifier|&
name|B
parameter_list|)
block|{
if|if
condition|(
name|A
operator|.
name|isNaN
argument_list|()
condition|)
return|return
name|B
return|;
if|if
condition|(
name|B
operator|.
name|isNaN
argument_list|()
condition|)
return|return
name|A
return|;
return|return
operator|(
name|B
operator|.
name|compare
argument_list|(
name|A
argument_list|)
operator|==
name|APFloat
operator|::
name|cmpLessThan
operator|)
condition|?
name|B
else|:
name|A
return|;
block|}
end_function

begin_comment
comment|/// Implements IEEE maxNum semantics. Returns the larger of the 2 arguments if
end_comment

begin_comment
comment|/// both are not NaN. If either argument is a NaN, returns the other argument.
end_comment

begin_function
name|LLVM_READONLY
specifier|inline
name|APFloat
name|maxnum
parameter_list|(
specifier|const
name|APFloat
modifier|&
name|A
parameter_list|,
specifier|const
name|APFloat
modifier|&
name|B
parameter_list|)
block|{
if|if
condition|(
name|A
operator|.
name|isNaN
argument_list|()
condition|)
return|return
name|B
return|;
if|if
condition|(
name|B
operator|.
name|isNaN
argument_list|()
condition|)
return|return
name|A
return|;
return|return
operator|(
name|A
operator|.
name|compare
argument_list|(
name|B
argument_list|)
operator|==
name|APFloat
operator|::
name|cmpLessThan
operator|)
condition|?
name|B
else|:
name|A
return|;
block|}
end_function

begin_comment
unit|}
comment|// namespace llvm
end_comment

begin_undef
undef|#
directive|undef
name|APFLOAT_DISPATCH_ON_SEMANTICS
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|// LLVM_ADT_APFLOAT_H
end_comment

end_unit

