begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===- BitstreamWriter.h - Low-level bitstream writer interface -*- C++ -*-===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This header defines the BitstreamWriter class.  This class can be used to
end_comment

begin_comment
comment|// write an arbitrary bitstream, regardless of its contents.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|BITSTREAM_WRITER_H
end_ifndef

begin_define
define|#
directive|define
name|BITSTREAM_WRITER_H
end_define

begin_include
include|#
directive|include
file|"llvm/ADT/StringRef.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Bitcode/BitCodes.h"
end_include

begin_include
include|#
directive|include
file|<vector>
end_include

begin_decl_stmt
name|namespace
name|llvm
block|{
name|class
name|BitstreamWriter
block|{
name|std
operator|::
name|vector
operator|<
name|unsigned
name|char
operator|>
operator|&
name|Out
expr_stmt|;
comment|/// CurBit - Always between 0 and 31 inclusive, specifies the next bit to use.
name|unsigned
name|CurBit
decl_stmt|;
comment|/// CurValue - The current value.  Only bits< CurBit are valid.
name|uint32_t
name|CurValue
decl_stmt|;
comment|/// CurCodeSize - This is the declared size of code values used for the
comment|/// current block, in bits.
name|unsigned
name|CurCodeSize
decl_stmt|;
comment|/// BlockInfoCurBID - When emitting a BLOCKINFO_BLOCK, this is the currently
comment|/// selected BLOCK ID.
name|unsigned
name|BlockInfoCurBID
decl_stmt|;
comment|/// CurAbbrevs - Abbrevs installed at in this block.
name|std
operator|::
name|vector
operator|<
name|BitCodeAbbrev
operator|*
operator|>
name|CurAbbrevs
expr_stmt|;
struct|struct
name|Block
block|{
name|unsigned
name|PrevCodeSize
decl_stmt|;
name|unsigned
name|StartSizeWord
decl_stmt|;
name|std
operator|::
name|vector
operator|<
name|BitCodeAbbrev
operator|*
operator|>
name|PrevAbbrevs
expr_stmt|;
name|Block
argument_list|(
argument|unsigned PCS
argument_list|,
argument|unsigned SSW
argument_list|)
block|:
name|PrevCodeSize
argument_list|(
name|PCS
argument_list|)
operator|,
name|StartSizeWord
argument_list|(
argument|SSW
argument_list|)
block|{}
block|}
struct|;
comment|/// BlockScope - This tracks the current blocks that we have entered.
name|std
operator|::
name|vector
operator|<
name|Block
operator|>
name|BlockScope
expr_stmt|;
comment|/// BlockInfo - This contains information emitted to BLOCKINFO_BLOCK blocks.
comment|/// These describe abbreviations that all blocks of the specified ID inherit.
struct|struct
name|BlockInfo
block|{
name|unsigned
name|BlockID
decl_stmt|;
name|std
operator|::
name|vector
operator|<
name|BitCodeAbbrev
operator|*
operator|>
name|Abbrevs
expr_stmt|;
block|}
struct|;
name|std
operator|::
name|vector
operator|<
name|BlockInfo
operator|>
name|BlockInfoRecords
expr_stmt|;
name|public
label|:
name|explicit
name|BitstreamWriter
argument_list|(
name|std
operator|::
name|vector
operator|<
name|unsigned
name|char
operator|>
operator|&
name|O
argument_list|)
range|:
name|Out
argument_list|(
name|O
argument_list|)
decl_stmt|,
name|CurBit
argument_list|(
literal|0
argument_list|)
decl_stmt|,
name|CurValue
argument_list|(
literal|0
argument_list|)
decl_stmt|,
name|CurCodeSize
argument_list|(
literal|2
argument_list|)
block|{}
operator|~
name|BitstreamWriter
argument_list|()
block|{
name|assert
argument_list|(
name|CurBit
operator|==
literal|0
operator|&&
literal|"Unflused data remaining"
argument_list|)
block|;
name|assert
argument_list|(
name|BlockScope
operator|.
name|empty
argument_list|()
operator|&&
name|CurAbbrevs
operator|.
name|empty
argument_list|()
operator|&&
literal|"Block imbalance"
argument_list|)
block|;
comment|// Free the BlockInfoRecords.
while|while
condition|(
operator|!
name|BlockInfoRecords
operator|.
name|empty
argument_list|()
condition|)
block|{
name|BlockInfo
modifier|&
name|Info
init|=
name|BlockInfoRecords
operator|.
name|back
argument_list|()
decl_stmt|;
comment|// Free blockinfo abbrev info.
for|for
control|(
name|unsigned
name|i
init|=
literal|0
init|,
name|e
init|=
name|static_cast
operator|<
name|unsigned
operator|>
operator|(
name|Info
operator|.
name|Abbrevs
operator|.
name|size
argument_list|()
operator|)
init|;
name|i
operator|!=
name|e
condition|;
operator|++
name|i
control|)
name|Info
operator|.
name|Abbrevs
index|[
name|i
index|]
operator|->
name|dropRef
argument_list|()
expr_stmt|;
name|BlockInfoRecords
operator|.
name|pop_back
argument_list|()
expr_stmt|;
block|}
block|}
name|std
operator|::
name|vector
operator|<
name|unsigned
name|char
operator|>
operator|&
name|getBuffer
argument_list|()
block|{
return|return
name|Out
return|;
block|}
comment|/// \brief Retrieve the current position in the stream, in bits.
name|uint64_t
name|GetCurrentBitNo
argument_list|()
specifier|const
block|{
return|return
name|Out
operator|.
name|size
argument_list|()
operator|*
literal|8
operator|+
name|CurBit
return|;
block|}
comment|//===--------------------------------------------------------------------===//
comment|// Basic Primitives for emitting bits to the stream.
comment|//===--------------------------------------------------------------------===//
name|void
name|Emit
parameter_list|(
name|uint32_t
name|Val
parameter_list|,
name|unsigned
name|NumBits
parameter_list|)
block|{
name|assert
argument_list|(
name|NumBits
operator|<=
literal|32
operator|&&
literal|"Invalid value size!"
argument_list|)
expr_stmt|;
name|assert
argument_list|(
operator|(
name|Val
operator|&
operator|~
operator|(
operator|~
literal|0U
operator|>>
operator|(
literal|32
operator|-
name|NumBits
operator|)
operator|)
operator|)
operator|==
literal|0
operator|&&
literal|"High bits set!"
argument_list|)
expr_stmt|;
name|CurValue
operator||=
name|Val
operator|<<
name|CurBit
expr_stmt|;
if|if
condition|(
name|CurBit
operator|+
name|NumBits
operator|<
literal|32
condition|)
block|{
name|CurBit
operator|+=
name|NumBits
expr_stmt|;
return|return;
block|}
comment|// Add the current word.
name|unsigned
name|V
init|=
name|CurValue
decl_stmt|;
name|Out
operator|.
name|push_back
argument_list|(
call|(
name|unsigned
name|char
call|)
argument_list|(
name|V
operator|>>
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|Out
operator|.
name|push_back
argument_list|(
call|(
name|unsigned
name|char
call|)
argument_list|(
name|V
operator|>>
literal|8
argument_list|)
argument_list|)
expr_stmt|;
name|Out
operator|.
name|push_back
argument_list|(
call|(
name|unsigned
name|char
call|)
argument_list|(
name|V
operator|>>
literal|16
argument_list|)
argument_list|)
expr_stmt|;
name|Out
operator|.
name|push_back
argument_list|(
call|(
name|unsigned
name|char
call|)
argument_list|(
name|V
operator|>>
literal|24
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|CurBit
condition|)
name|CurValue
operator|=
name|Val
operator|>>
operator|(
literal|32
operator|-
name|CurBit
operator|)
expr_stmt|;
else|else
name|CurValue
operator|=
literal|0
expr_stmt|;
name|CurBit
operator|=
operator|(
name|CurBit
operator|+
name|NumBits
operator|)
operator|&
literal|31
expr_stmt|;
block|}
name|void
name|Emit64
parameter_list|(
name|uint64_t
name|Val
parameter_list|,
name|unsigned
name|NumBits
parameter_list|)
block|{
if|if
condition|(
name|NumBits
operator|<=
literal|32
condition|)
name|Emit
argument_list|(
operator|(
name|uint32_t
operator|)
name|Val
argument_list|,
name|NumBits
argument_list|)
expr_stmt|;
else|else
block|{
name|Emit
argument_list|(
operator|(
name|uint32_t
operator|)
name|Val
argument_list|,
literal|32
argument_list|)
expr_stmt|;
name|Emit
argument_list|(
call|(
name|uint32_t
call|)
argument_list|(
name|Val
operator|>>
literal|32
argument_list|)
argument_list|,
name|NumBits
operator|-
literal|32
argument_list|)
expr_stmt|;
block|}
block|}
name|void
name|FlushToWord
parameter_list|()
block|{
if|if
condition|(
name|CurBit
condition|)
block|{
name|unsigned
name|V
init|=
name|CurValue
decl_stmt|;
name|Out
operator|.
name|push_back
argument_list|(
call|(
name|unsigned
name|char
call|)
argument_list|(
name|V
operator|>>
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|Out
operator|.
name|push_back
argument_list|(
call|(
name|unsigned
name|char
call|)
argument_list|(
name|V
operator|>>
literal|8
argument_list|)
argument_list|)
expr_stmt|;
name|Out
operator|.
name|push_back
argument_list|(
call|(
name|unsigned
name|char
call|)
argument_list|(
name|V
operator|>>
literal|16
argument_list|)
argument_list|)
expr_stmt|;
name|Out
operator|.
name|push_back
argument_list|(
call|(
name|unsigned
name|char
call|)
argument_list|(
name|V
operator|>>
literal|24
argument_list|)
argument_list|)
expr_stmt|;
name|CurBit
operator|=
literal|0
expr_stmt|;
name|CurValue
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|void
name|EmitVBR
parameter_list|(
name|uint32_t
name|Val
parameter_list|,
name|unsigned
name|NumBits
parameter_list|)
block|{
name|uint32_t
name|Threshold
init|=
literal|1U
operator|<<
operator|(
name|NumBits
operator|-
literal|1
operator|)
decl_stmt|;
comment|// Emit the bits with VBR encoding, NumBits-1 bits at a time.
while|while
condition|(
name|Val
operator|>=
name|Threshold
condition|)
block|{
name|Emit
argument_list|(
operator|(
name|Val
operator|&
operator|(
operator|(
literal|1
operator|<<
operator|(
name|NumBits
operator|-
literal|1
operator|)
operator|)
operator|-
literal|1
operator|)
operator|)
operator||
operator|(
literal|1
operator|<<
operator|(
name|NumBits
operator|-
literal|1
operator|)
operator|)
argument_list|,
name|NumBits
argument_list|)
expr_stmt|;
name|Val
operator|>>=
name|NumBits
operator|-
literal|1
expr_stmt|;
block|}
name|Emit
argument_list|(
name|Val
argument_list|,
name|NumBits
argument_list|)
expr_stmt|;
block|}
name|void
name|EmitVBR64
parameter_list|(
name|uint64_t
name|Val
parameter_list|,
name|unsigned
name|NumBits
parameter_list|)
block|{
if|if
condition|(
operator|(
name|uint32_t
operator|)
name|Val
operator|==
name|Val
condition|)
return|return
name|EmitVBR
argument_list|(
operator|(
name|uint32_t
operator|)
name|Val
argument_list|,
name|NumBits
argument_list|)
return|;
name|uint64_t
name|Threshold
init|=
literal|1U
operator|<<
operator|(
name|NumBits
operator|-
literal|1
operator|)
decl_stmt|;
comment|// Emit the bits with VBR encoding, NumBits-1 bits at a time.
while|while
condition|(
name|Val
operator|>=
name|Threshold
condition|)
block|{
name|Emit
argument_list|(
operator|(
operator|(
name|uint32_t
operator|)
name|Val
operator|&
operator|(
operator|(
literal|1
operator|<<
operator|(
name|NumBits
operator|-
literal|1
operator|)
operator|)
operator|-
literal|1
operator|)
operator|)
operator||
operator|(
literal|1
operator|<<
operator|(
name|NumBits
operator|-
literal|1
operator|)
operator|)
argument_list|,
name|NumBits
argument_list|)
expr_stmt|;
name|Val
operator|>>=
name|NumBits
operator|-
literal|1
expr_stmt|;
block|}
name|Emit
argument_list|(
operator|(
name|uint32_t
operator|)
name|Val
argument_list|,
name|NumBits
argument_list|)
expr_stmt|;
block|}
comment|/// EmitCode - Emit the specified code.
name|void
name|EmitCode
parameter_list|(
name|unsigned
name|Val
parameter_list|)
block|{
name|Emit
argument_list|(
name|Val
argument_list|,
name|CurCodeSize
argument_list|)
expr_stmt|;
block|}
comment|// BackpatchWord - Backpatch a 32-bit word in the output with the specified
comment|// value.
name|void
name|BackpatchWord
parameter_list|(
name|unsigned
name|ByteNo
parameter_list|,
name|unsigned
name|NewWord
parameter_list|)
block|{
name|Out
index|[
name|ByteNo
operator|++
index|]
operator|=
call|(
name|unsigned
name|char
call|)
argument_list|(
name|NewWord
operator|>>
literal|0
argument_list|)
expr_stmt|;
name|Out
index|[
name|ByteNo
operator|++
index|]
operator|=
call|(
name|unsigned
name|char
call|)
argument_list|(
name|NewWord
operator|>>
literal|8
argument_list|)
expr_stmt|;
name|Out
index|[
name|ByteNo
operator|++
index|]
operator|=
call|(
name|unsigned
name|char
call|)
argument_list|(
name|NewWord
operator|>>
literal|16
argument_list|)
expr_stmt|;
name|Out
index|[
name|ByteNo
index|]
operator|=
call|(
name|unsigned
name|char
call|)
argument_list|(
name|NewWord
operator|>>
literal|24
argument_list|)
expr_stmt|;
block|}
comment|//===--------------------------------------------------------------------===//
comment|// Block Manipulation
comment|//===--------------------------------------------------------------------===//
comment|/// getBlockInfo - If there is block info for the specified ID, return it,
comment|/// otherwise return null.
name|BlockInfo
modifier|*
name|getBlockInfo
parameter_list|(
name|unsigned
name|BlockID
parameter_list|)
block|{
comment|// Common case, the most recent entry matches BlockID.
if|if
condition|(
operator|!
name|BlockInfoRecords
operator|.
name|empty
argument_list|()
operator|&&
name|BlockInfoRecords
operator|.
name|back
argument_list|()
operator|.
name|BlockID
operator|==
name|BlockID
condition|)
return|return
operator|&
name|BlockInfoRecords
operator|.
name|back
argument_list|()
return|;
for|for
control|(
name|unsigned
name|i
init|=
literal|0
init|,
name|e
init|=
name|static_cast
operator|<
name|unsigned
operator|>
operator|(
name|BlockInfoRecords
operator|.
name|size
argument_list|()
operator|)
init|;
name|i
operator|!=
name|e
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|BlockInfoRecords
index|[
name|i
index|]
operator|.
name|BlockID
operator|==
name|BlockID
condition|)
return|return
operator|&
name|BlockInfoRecords
index|[
name|i
index|]
return|;
return|return
literal|0
return|;
block|}
name|void
name|EnterSubblock
parameter_list|(
name|unsigned
name|BlockID
parameter_list|,
name|unsigned
name|CodeLen
parameter_list|)
block|{
comment|// Block header:
comment|//    [ENTER_SUBBLOCK, blockid, newcodelen,<align4bytes>, blocklen]
name|EmitCode
argument_list|(
name|bitc
operator|::
name|ENTER_SUBBLOCK
argument_list|)
expr_stmt|;
name|EmitVBR
argument_list|(
name|BlockID
argument_list|,
name|bitc
operator|::
name|BlockIDWidth
argument_list|)
expr_stmt|;
name|EmitVBR
argument_list|(
name|CodeLen
argument_list|,
name|bitc
operator|::
name|CodeLenWidth
argument_list|)
expr_stmt|;
name|FlushToWord
argument_list|()
expr_stmt|;
name|unsigned
name|BlockSizeWordLoc
init|=
name|static_cast
operator|<
name|unsigned
operator|>
operator|(
name|Out
operator|.
name|size
argument_list|()
operator|)
decl_stmt|;
name|unsigned
name|OldCodeSize
init|=
name|CurCodeSize
decl_stmt|;
comment|// Emit a placeholder, which will be replaced when the block is popped.
name|Emit
argument_list|(
literal|0
argument_list|,
name|bitc
operator|::
name|BlockSizeWidth
argument_list|)
expr_stmt|;
name|CurCodeSize
operator|=
name|CodeLen
expr_stmt|;
comment|// Push the outer block's abbrev set onto the stack, start out with an
comment|// empty abbrev set.
name|BlockScope
operator|.
name|push_back
argument_list|(
name|Block
argument_list|(
name|OldCodeSize
argument_list|,
name|BlockSizeWordLoc
operator|/
literal|4
argument_list|)
argument_list|)
expr_stmt|;
name|BlockScope
operator|.
name|back
argument_list|()
operator|.
name|PrevAbbrevs
operator|.
name|swap
argument_list|(
name|CurAbbrevs
argument_list|)
expr_stmt|;
comment|// If there is a blockinfo for this BlockID, add all the predefined abbrevs
comment|// to the abbrev list.
if|if
condition|(
name|BlockInfo
modifier|*
name|Info
init|=
name|getBlockInfo
argument_list|(
name|BlockID
argument_list|)
condition|)
block|{
for|for
control|(
name|unsigned
name|i
init|=
literal|0
init|,
name|e
init|=
name|static_cast
operator|<
name|unsigned
operator|>
operator|(
name|Info
operator|->
name|Abbrevs
operator|.
name|size
argument_list|()
operator|)
init|;
name|i
operator|!=
name|e
condition|;
operator|++
name|i
control|)
block|{
name|CurAbbrevs
operator|.
name|push_back
argument_list|(
name|Info
operator|->
name|Abbrevs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|Info
operator|->
name|Abbrevs
index|[
name|i
index|]
operator|->
name|addRef
argument_list|()
expr_stmt|;
block|}
block|}
block|}
name|void
name|ExitBlock
parameter_list|()
block|{
name|assert
argument_list|(
operator|!
name|BlockScope
operator|.
name|empty
argument_list|()
operator|&&
literal|"Block scope imbalance!"
argument_list|)
expr_stmt|;
comment|// Delete all abbrevs.
for|for
control|(
name|unsigned
name|i
init|=
literal|0
init|,
name|e
init|=
name|static_cast
operator|<
name|unsigned
operator|>
operator|(
name|CurAbbrevs
operator|.
name|size
argument_list|()
operator|)
init|;
name|i
operator|!=
name|e
condition|;
operator|++
name|i
control|)
name|CurAbbrevs
index|[
name|i
index|]
operator|->
name|dropRef
argument_list|()
expr_stmt|;
specifier|const
name|Block
modifier|&
name|B
init|=
name|BlockScope
operator|.
name|back
argument_list|()
decl_stmt|;
comment|// Block tail:
comment|//    [END_BLOCK,<align4bytes>]
name|EmitCode
argument_list|(
name|bitc
operator|::
name|END_BLOCK
argument_list|)
expr_stmt|;
name|FlushToWord
argument_list|()
expr_stmt|;
comment|// Compute the size of the block, in words, not counting the size field.
name|unsigned
name|SizeInWords
init|=
name|static_cast
operator|<
name|unsigned
operator|>
operator|(
name|Out
operator|.
name|size
argument_list|()
operator|)
operator|/
literal|4
operator|-
name|B
operator|.
name|StartSizeWord
operator|-
literal|1
decl_stmt|;
name|unsigned
name|ByteNo
init|=
name|B
operator|.
name|StartSizeWord
operator|*
literal|4
decl_stmt|;
comment|// Update the block size field in the header of this sub-block.
name|BackpatchWord
argument_list|(
name|ByteNo
argument_list|,
name|SizeInWords
argument_list|)
expr_stmt|;
comment|// Restore the inner block's code size and abbrev table.
name|CurCodeSize
operator|=
name|B
operator|.
name|PrevCodeSize
expr_stmt|;
name|BlockScope
operator|.
name|back
argument_list|()
operator|.
name|PrevAbbrevs
operator|.
name|swap
argument_list|(
name|CurAbbrevs
argument_list|)
expr_stmt|;
name|BlockScope
operator|.
name|pop_back
argument_list|()
expr_stmt|;
block|}
comment|//===--------------------------------------------------------------------===//
comment|// Record Emission
comment|//===--------------------------------------------------------------------===//
name|private
label|:
comment|/// EmitAbbreviatedLiteral - Emit a literal value according to its abbrev
comment|/// record.  This is a no-op, since the abbrev specifies the literal to use.
name|template
operator|<
name|typename
name|uintty
operator|>
name|void
name|EmitAbbreviatedLiteral
argument_list|(
argument|const BitCodeAbbrevOp&Op
argument_list|,
argument|uintty V
argument_list|)
block|{
name|assert
argument_list|(
name|Op
operator|.
name|isLiteral
argument_list|()
operator|&&
literal|"Not a literal"
argument_list|)
block|;
comment|// If the abbrev specifies the literal value to use, don't emit
comment|// anything.
name|assert
argument_list|(
name|V
operator|==
name|Op
operator|.
name|getLiteralValue
argument_list|()
operator|&&
literal|"Invalid abbrev for record!"
argument_list|)
block|;   }
comment|/// EmitAbbreviatedField - Emit a single scalar field value with the specified
comment|/// encoding.
name|template
operator|<
name|typename
name|uintty
operator|>
name|void
name|EmitAbbreviatedField
argument_list|(
argument|const BitCodeAbbrevOp&Op
argument_list|,
argument|uintty V
argument_list|)
block|{
name|assert
argument_list|(
operator|!
name|Op
operator|.
name|isLiteral
argument_list|()
operator|&&
literal|"Literals should use EmitAbbreviatedLiteral!"
argument_list|)
block|;
comment|// Encode the value as we are commanded.
switch|switch
condition|(
name|Op
operator|.
name|getEncoding
argument_list|()
condition|)
block|{
default|default:
name|assert
argument_list|(
literal|0
operator|&&
literal|"Unknown encoding!"
argument_list|)
expr_stmt|;
case|case
name|BitCodeAbbrevOp
operator|::
name|Fixed
case|:
name|Emit
argument_list|(
operator|(
name|unsigned
operator|)
name|V
argument_list|,
operator|(
name|unsigned
operator|)
name|Op
operator|.
name|getEncodingData
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|BitCodeAbbrevOp
operator|::
name|VBR
case|:
name|EmitVBR64
argument_list|(
name|V
argument_list|,
operator|(
name|unsigned
operator|)
name|Op
operator|.
name|getEncodingData
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|BitCodeAbbrevOp
operator|::
name|Char6
case|:
name|Emit
argument_list|(
name|BitCodeAbbrevOp
operator|::
name|EncodeChar6
argument_list|(
operator|(
name|char
operator|)
name|V
argument_list|)
argument_list|,
literal|6
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
comment|/// EmitRecordWithAbbrevImpl - This is the core implementation of the record
comment|/// emission code.  If BlobData is non-null, then it specifies an array of
comment|/// data that should be emitted as part of the Blob or Array operand that is
comment|/// known to exist at the end of the the record.
name|template
operator|<
name|typename
name|uintty
operator|>
name|void
name|EmitRecordWithAbbrevImpl
argument_list|(
argument|unsigned Abbrev
argument_list|,
argument|SmallVectorImpl<uintty>&Vals
argument_list|,
argument|const StringRef&Blob
argument_list|)
block|{
specifier|const
name|char
operator|*
name|BlobData
operator|=
name|Blob
operator|.
name|data
argument_list|()
block|;
name|unsigned
name|BlobLen
operator|=
operator|(
name|unsigned
operator|)
name|Blob
operator|.
name|size
argument_list|()
block|;
name|unsigned
name|AbbrevNo
operator|=
name|Abbrev
operator|-
name|bitc
operator|::
name|FIRST_APPLICATION_ABBREV
block|;
name|assert
argument_list|(
name|AbbrevNo
operator|<
name|CurAbbrevs
operator|.
name|size
argument_list|()
operator|&&
literal|"Invalid abbrev #!"
argument_list|)
block|;
name|BitCodeAbbrev
operator|*
name|Abbv
operator|=
name|CurAbbrevs
index|[
name|AbbrevNo
index|]
block|;
name|EmitCode
argument_list|(
name|Abbrev
argument_list|)
block|;
name|unsigned
name|RecordIdx
operator|=
literal|0
block|;
for|for
control|(
name|unsigned
name|i
init|=
literal|0
init|,
name|e
init|=
name|static_cast
operator|<
name|unsigned
operator|>
operator|(
name|Abbv
operator|->
name|getNumOperandInfos
argument_list|()
operator|)
init|;
name|i
operator|!=
name|e
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|BitCodeAbbrevOp
modifier|&
name|Op
init|=
name|Abbv
operator|->
name|getOperandInfo
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|Op
operator|.
name|isLiteral
argument_list|()
condition|)
block|{
name|assert
argument_list|(
name|RecordIdx
operator|<
name|Vals
operator|.
name|size
argument_list|()
operator|&&
literal|"Invalid abbrev/record"
argument_list|)
expr_stmt|;
name|EmitAbbreviatedLiteral
argument_list|(
name|Op
argument_list|,
name|Vals
index|[
name|RecordIdx
index|]
argument_list|)
expr_stmt|;
operator|++
name|RecordIdx
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|Op
operator|.
name|getEncoding
argument_list|()
operator|==
name|BitCodeAbbrevOp
operator|::
name|Array
condition|)
block|{
comment|// Array case.
name|assert
argument_list|(
name|i
operator|+
literal|2
operator|==
name|e
operator|&&
literal|"array op not second to last?"
argument_list|)
expr_stmt|;
specifier|const
name|BitCodeAbbrevOp
modifier|&
name|EltEnc
init|=
name|Abbv
operator|->
name|getOperandInfo
argument_list|(
operator|++
name|i
argument_list|)
decl_stmt|;
comment|// If this record has blob data, emit it, otherwise we must have record
comment|// entries to encode this way.
if|if
condition|(
name|BlobData
condition|)
block|{
name|assert
argument_list|(
name|RecordIdx
operator|==
name|Vals
operator|.
name|size
argument_list|()
operator|&&
literal|"Blob data and record entries specified for array!"
argument_list|)
expr_stmt|;
comment|// Emit a vbr6 to indicate the number of elements present.
name|EmitVBR
argument_list|(
name|static_cast
operator|<
name|uint32_t
operator|>
operator|(
name|BlobLen
operator|)
argument_list|,
literal|6
argument_list|)
expr_stmt|;
comment|// Emit each field.
for|for
control|(
name|unsigned
name|i
init|=
literal|0
init|;
name|i
operator|!=
name|BlobLen
condition|;
operator|++
name|i
control|)
name|EmitAbbreviatedField
argument_list|(
name|EltEnc
argument_list|,
operator|(
name|unsigned
name|char
operator|)
name|BlobData
index|[
name|i
index|]
argument_list|)
expr_stmt|;
comment|// Know that blob data is consumed for assertion below.
name|BlobData
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|// Emit a vbr6 to indicate the number of elements present.
name|EmitVBR
argument_list|(
name|static_cast
operator|<
name|uint32_t
operator|>
operator|(
name|Vals
operator|.
name|size
argument_list|()
operator|-
name|RecordIdx
operator|)
argument_list|,
literal|6
argument_list|)
expr_stmt|;
comment|// Emit each field.
for|for
control|(
name|unsigned
name|e
init|=
name|Vals
operator|.
name|size
argument_list|()
init|;
name|RecordIdx
operator|!=
name|e
condition|;
operator|++
name|RecordIdx
control|)
name|EmitAbbreviatedField
argument_list|(
name|EltEnc
argument_list|,
name|Vals
index|[
name|RecordIdx
index|]
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|Op
operator|.
name|getEncoding
argument_list|()
operator|==
name|BitCodeAbbrevOp
operator|::
name|Blob
condition|)
block|{
comment|// If this record has blob data, emit it, otherwise we must have record
comment|// entries to encode this way.
comment|// Emit a vbr6 to indicate the number of elements present.
if|if
condition|(
name|BlobData
condition|)
block|{
name|EmitVBR
argument_list|(
name|static_cast
operator|<
name|uint32_t
operator|>
operator|(
name|BlobLen
operator|)
argument_list|,
literal|6
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|RecordIdx
operator|==
name|Vals
operator|.
name|size
argument_list|()
operator|&&
literal|"Blob data and record entries specified for blob operand!"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|EmitVBR
argument_list|(
name|static_cast
operator|<
name|uint32_t
operator|>
operator|(
name|Vals
operator|.
name|size
argument_list|()
operator|-
name|RecordIdx
operator|)
argument_list|,
literal|6
argument_list|)
expr_stmt|;
block|}
comment|// Flush to a 32-bit alignment boundary.
name|FlushToWord
argument_list|()
expr_stmt|;
name|assert
argument_list|(
operator|(
name|Out
operator|.
name|size
argument_list|()
operator|&
literal|3
operator|)
operator|==
literal|0
operator|&&
literal|"Not 32-bit aligned"
argument_list|)
expr_stmt|;
comment|// Emit each field as a literal byte.
if|if
condition|(
name|BlobData
condition|)
block|{
for|for
control|(
name|unsigned
name|i
init|=
literal|0
init|;
name|i
operator|!=
name|BlobLen
condition|;
operator|++
name|i
control|)
name|Out
operator|.
name|push_back
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|BlobData
index|[
name|i
index|]
argument_list|)
expr_stmt|;
comment|// Know that blob data is consumed for assertion below.
name|BlobData
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|unsigned
name|e
init|=
name|Vals
operator|.
name|size
argument_list|()
init|;
name|RecordIdx
operator|!=
name|e
condition|;
operator|++
name|RecordIdx
control|)
block|{
name|assert
argument_list|(
name|Vals
index|[
name|RecordIdx
index|]
operator|<
literal|256
operator|&&
literal|"Value too large to emit as blob"
argument_list|)
expr_stmt|;
name|Out
operator|.
name|push_back
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|Vals
index|[
name|RecordIdx
index|]
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Align end to 32-bits.
while|while
condition|(
name|Out
operator|.
name|size
argument_list|()
operator|&
literal|3
condition|)
name|Out
operator|.
name|push_back
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// Single scalar field.
name|assert
argument_list|(
name|RecordIdx
operator|<
name|Vals
operator|.
name|size
argument_list|()
operator|&&
literal|"Invalid abbrev/record"
argument_list|)
expr_stmt|;
name|EmitAbbreviatedField
argument_list|(
name|Op
argument_list|,
name|Vals
index|[
name|RecordIdx
index|]
argument_list|)
expr_stmt|;
operator|++
name|RecordIdx
expr_stmt|;
block|}
block|}
name|assert
argument_list|(
name|RecordIdx
operator|==
name|Vals
operator|.
name|size
argument_list|()
operator|&&
literal|"Not all record operands emitted!"
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|BlobData
operator|==
literal|0
operator|&&
literal|"Blob data specified for record that doesn't use it!"
argument_list|)
expr_stmt|;
block|}
name|public
label|:
comment|/// EmitRecord - Emit the specified record to the stream, using an abbrev if
comment|/// we have one to compress the output.
name|template
operator|<
name|typename
name|uintty
operator|>
name|void
name|EmitRecord
argument_list|(
argument|unsigned Code
argument_list|,
argument|SmallVectorImpl<uintty>&Vals
argument_list|,
argument|unsigned Abbrev =
literal|0
argument_list|)
block|{
if|if
condition|(
operator|!
name|Abbrev
condition|)
block|{
comment|// If we don't have an abbrev to use, emit this in its fully unabbreviated
comment|// form.
name|EmitCode
argument_list|(
name|bitc
operator|::
name|UNABBREV_RECORD
argument_list|)
expr_stmt|;
name|EmitVBR
argument_list|(
name|Code
argument_list|,
literal|6
argument_list|)
expr_stmt|;
name|EmitVBR
argument_list|(
name|static_cast
operator|<
name|uint32_t
operator|>
operator|(
name|Vals
operator|.
name|size
argument_list|()
operator|)
argument_list|,
literal|6
argument_list|)
expr_stmt|;
for|for
control|(
name|unsigned
name|i
init|=
literal|0
init|,
name|e
init|=
name|static_cast
operator|<
name|unsigned
operator|>
operator|(
name|Vals
operator|.
name|size
argument_list|()
operator|)
init|;
name|i
operator|!=
name|e
condition|;
operator|++
name|i
control|)
name|EmitVBR64
argument_list|(
name|Vals
index|[
name|i
index|]
argument_list|,
literal|6
argument_list|)
expr_stmt|;
return|return;
block|}
comment|// Insert the code into Vals to treat it uniformly.
name|Vals
operator|.
name|insert
argument_list|(
name|Vals
operator|.
name|begin
argument_list|()
argument_list|,
name|Code
argument_list|)
expr_stmt|;
name|EmitRecordWithAbbrev
argument_list|(
name|Abbrev
argument_list|,
name|Vals
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_comment
comment|/// EmitRecordWithAbbrev - Emit a record with the specified abbreviation.
end_comment

begin_comment
comment|/// Unlike EmitRecord, the code for the record should be included in Vals as
end_comment

begin_comment
comment|/// the first entry.
end_comment

begin_expr_stmt
name|template
operator|<
name|typename
name|uintty
operator|>
name|void
name|EmitRecordWithAbbrev
argument_list|(
argument|unsigned Abbrev
argument_list|,
argument|SmallVectorImpl<uintty>&Vals
argument_list|)
block|{
name|EmitRecordWithAbbrevImpl
argument_list|(
name|Abbrev
argument_list|,
name|Vals
argument_list|,
name|StringRef
argument_list|()
argument_list|)
block|;   }
comment|/// EmitRecordWithBlob - Emit the specified record to the stream, using an
comment|/// abbrev that includes a blob at the end.  The blob data to emit is
comment|/// specified by the pointer and length specified at the end.  In contrast to
comment|/// EmitRecord, this routine expects that the first entry in Vals is the code
comment|/// of the record.
name|template
operator|<
name|typename
name|uintty
operator|>
name|void
name|EmitRecordWithBlob
argument_list|(
argument|unsigned Abbrev
argument_list|,
argument|SmallVectorImpl<uintty>&Vals
argument_list|,
argument|const StringRef&Blob
argument_list|)
block|{
name|EmitRecordWithAbbrevImpl
argument_list|(
name|Abbrev
argument_list|,
name|Vals
argument_list|,
name|Blob
argument_list|)
block|;   }
name|template
operator|<
name|typename
name|uintty
operator|>
name|void
name|EmitRecordWithBlob
argument_list|(
argument|unsigned Abbrev
argument_list|,
argument|SmallVectorImpl<uintty>&Vals
argument_list|,
argument|const char *BlobData
argument_list|,
argument|unsigned BlobLen
argument_list|)
block|{
return|return
name|EmitRecordWithAbbrevImpl
argument_list|(
name|Abbrev
argument_list|,
name|Vals
argument_list|,
name|StringRef
argument_list|(
name|BlobData
argument_list|,
name|BlobLen
argument_list|)
argument_list|)
return|;
block|}
end_expr_stmt

begin_comment
comment|/// EmitRecordWithArray - Just like EmitRecordWithBlob, works with records
end_comment

begin_comment
comment|/// that end with an array.
end_comment

begin_expr_stmt
name|template
operator|<
name|typename
name|uintty
operator|>
name|void
name|EmitRecordWithArray
argument_list|(
argument|unsigned Abbrev
argument_list|,
argument|SmallVectorImpl<uintty>&Vals
argument_list|,
argument|const StringRef&Array
argument_list|)
block|{
name|EmitRecordWithAbbrevImpl
argument_list|(
name|Abbrev
argument_list|,
name|Vals
argument_list|,
name|Array
argument_list|)
block|;   }
name|template
operator|<
name|typename
name|uintty
operator|>
name|void
name|EmitRecordWithArray
argument_list|(
argument|unsigned Abbrev
argument_list|,
argument|SmallVectorImpl<uintty>&Vals
argument_list|,
argument|const char *ArrayData
argument_list|,
argument|unsigned ArrayLen
argument_list|)
block|{
return|return
name|EmitRecordWithAbbrevImpl
argument_list|(
name|Abbrev
argument_list|,
name|Vals
argument_list|,
name|StringRef
argument_list|(
name|ArrayData
argument_list|,
name|ArrayLen
argument_list|)
argument_list|)
return|;
block|}
end_expr_stmt

begin_comment
comment|//===--------------------------------------------------------------------===//
end_comment

begin_comment
comment|// Abbrev Emission
end_comment

begin_comment
comment|//===--------------------------------------------------------------------===//
end_comment

begin_label
name|private
label|:
end_label

begin_comment
comment|// Emit the abbreviation as a DEFINE_ABBREV record.
end_comment

begin_function
name|void
name|EncodeAbbrev
parameter_list|(
name|BitCodeAbbrev
modifier|*
name|Abbv
parameter_list|)
block|{
name|EmitCode
argument_list|(
name|bitc
operator|::
name|DEFINE_ABBREV
argument_list|)
expr_stmt|;
name|EmitVBR
argument_list|(
name|Abbv
operator|->
name|getNumOperandInfos
argument_list|()
argument_list|,
literal|5
argument_list|)
expr_stmt|;
for|for
control|(
name|unsigned
name|i
init|=
literal|0
init|,
name|e
init|=
name|static_cast
operator|<
name|unsigned
operator|>
operator|(
name|Abbv
operator|->
name|getNumOperandInfos
argument_list|()
operator|)
init|;
name|i
operator|!=
name|e
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|BitCodeAbbrevOp
modifier|&
name|Op
init|=
name|Abbv
operator|->
name|getOperandInfo
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|Emit
argument_list|(
name|Op
operator|.
name|isLiteral
argument_list|()
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|Op
operator|.
name|isLiteral
argument_list|()
condition|)
block|{
name|EmitVBR64
argument_list|(
name|Op
operator|.
name|getLiteralValue
argument_list|()
argument_list|,
literal|8
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Emit
argument_list|(
name|Op
operator|.
name|getEncoding
argument_list|()
argument_list|,
literal|3
argument_list|)
expr_stmt|;
if|if
condition|(
name|Op
operator|.
name|hasEncodingData
argument_list|()
condition|)
name|EmitVBR64
argument_list|(
name|Op
operator|.
name|getEncodingData
argument_list|()
argument_list|,
literal|5
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_label
name|public
label|:
end_label

begin_comment
comment|/// EmitAbbrev - This emits an abbreviation to the stream.  Note that this
end_comment

begin_comment
comment|/// method takes ownership of the specified abbrev.
end_comment

begin_function
name|unsigned
name|EmitAbbrev
parameter_list|(
name|BitCodeAbbrev
modifier|*
name|Abbv
parameter_list|)
block|{
comment|// Emit the abbreviation as a record.
name|EncodeAbbrev
argument_list|(
name|Abbv
argument_list|)
expr_stmt|;
name|CurAbbrevs
operator|.
name|push_back
argument_list|(
name|Abbv
argument_list|)
expr_stmt|;
return|return
name|static_cast
operator|<
name|unsigned
operator|>
operator|(
name|CurAbbrevs
operator|.
name|size
argument_list|()
operator|)
operator|-
literal|1
operator|+
name|bitc
operator|::
name|FIRST_APPLICATION_ABBREV
return|;
block|}
end_function

begin_comment
comment|//===--------------------------------------------------------------------===//
end_comment

begin_comment
comment|// BlockInfo Block Emission
end_comment

begin_comment
comment|//===--------------------------------------------------------------------===//
end_comment

begin_comment
comment|/// EnterBlockInfoBlock - Start emitting the BLOCKINFO_BLOCK.
end_comment

begin_function
name|void
name|EnterBlockInfoBlock
parameter_list|(
name|unsigned
name|CodeWidth
parameter_list|)
block|{
name|EnterSubblock
argument_list|(
name|bitc
operator|::
name|BLOCKINFO_BLOCK_ID
argument_list|,
name|CodeWidth
argument_list|)
expr_stmt|;
name|BlockInfoCurBID
operator|=
operator|-
literal|1U
expr_stmt|;
block|}
end_function

begin_label
name|private
label|:
end_label

begin_comment
comment|/// SwitchToBlockID - If we aren't already talking about the specified block
end_comment

begin_comment
comment|/// ID, emit a BLOCKINFO_CODE_SETBID record.
end_comment

begin_function
name|void
name|SwitchToBlockID
parameter_list|(
name|unsigned
name|BlockID
parameter_list|)
block|{
if|if
condition|(
name|BlockInfoCurBID
operator|==
name|BlockID
condition|)
return|return;
name|SmallVector
operator|<
name|unsigned
operator|,
literal|2
operator|>
name|V
expr_stmt|;
name|V
operator|.
name|push_back
argument_list|(
name|BlockID
argument_list|)
expr_stmt|;
name|EmitRecord
argument_list|(
name|bitc
operator|::
name|BLOCKINFO_CODE_SETBID
argument_list|,
name|V
argument_list|)
expr_stmt|;
name|BlockInfoCurBID
operator|=
name|BlockID
expr_stmt|;
block|}
end_function

begin_function
name|BlockInfo
modifier|&
name|getOrCreateBlockInfo
parameter_list|(
name|unsigned
name|BlockID
parameter_list|)
block|{
if|if
condition|(
name|BlockInfo
modifier|*
name|BI
init|=
name|getBlockInfo
argument_list|(
name|BlockID
argument_list|)
condition|)
return|return
operator|*
name|BI
return|;
comment|// Otherwise, add a new record.
name|BlockInfoRecords
operator|.
name|push_back
argument_list|(
name|BlockInfo
argument_list|()
argument_list|)
expr_stmt|;
name|BlockInfoRecords
operator|.
name|back
argument_list|()
operator|.
name|BlockID
operator|=
name|BlockID
expr_stmt|;
return|return
name|BlockInfoRecords
operator|.
name|back
argument_list|()
return|;
block|}
end_function

begin_label
name|public
label|:
end_label

begin_comment
comment|/// EmitBlockInfoAbbrev - Emit a DEFINE_ABBREV record for the specified
end_comment

begin_comment
comment|/// BlockID.
end_comment

begin_function
name|unsigned
name|EmitBlockInfoAbbrev
parameter_list|(
name|unsigned
name|BlockID
parameter_list|,
name|BitCodeAbbrev
modifier|*
name|Abbv
parameter_list|)
block|{
name|SwitchToBlockID
argument_list|(
name|BlockID
argument_list|)
expr_stmt|;
name|EncodeAbbrev
argument_list|(
name|Abbv
argument_list|)
expr_stmt|;
comment|// Add the abbrev to the specified block record.
name|BlockInfo
modifier|&
name|Info
init|=
name|getOrCreateBlockInfo
argument_list|(
name|BlockID
argument_list|)
decl_stmt|;
name|Info
operator|.
name|Abbrevs
operator|.
name|push_back
argument_list|(
name|Abbv
argument_list|)
expr_stmt|;
return|return
name|Info
operator|.
name|Abbrevs
operator|.
name|size
argument_list|()
operator|-
literal|1
operator|+
name|bitc
operator|::
name|FIRST_APPLICATION_ABBREV
return|;
block|}
end_function

begin_comment
unit|};   }
comment|// End llvm namespace
end_comment

begin_endif
endif|#
directive|endif
end_endif

end_unit

