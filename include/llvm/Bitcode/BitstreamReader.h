begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===- BitstreamReader.h - Low-level bitstream reader interface -*- C++ -*-===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This header defines the BitstreamReader class.  This class can be used to
end_comment

begin_comment
comment|// read an arbitrary bitstream, regardless of its contents.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LLVM_BITCODE_BITSTREAMREADER_H
end_ifndef

begin_define
define|#
directive|define
name|LLVM_BITCODE_BITSTREAMREADER_H
end_define

begin_include
include|#
directive|include
file|"llvm/ADT/ArrayRef.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/IntrusiveRefCntPtr.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/SmallVector.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Bitcode/BitCodes.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/Endian.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/ErrorHandling.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/MathExtras.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/MemoryBuffer.h"
end_include

begin_include
include|#
directive|include
file|<algorithm>
end_include

begin_include
include|#
directive|include
file|<cassert>
end_include

begin_include
include|#
directive|include
file|<climits>
end_include

begin_include
include|#
directive|include
file|<cstddef>
end_include

begin_include
include|#
directive|include
file|<cstdint>
end_include

begin_include
include|#
directive|include
file|<memory>
end_include

begin_include
include|#
directive|include
file|<string>
end_include

begin_include
include|#
directive|include
file|<utility>
end_include

begin_include
include|#
directive|include
file|<vector>
end_include

begin_decl_stmt
name|namespace
name|llvm
block|{
comment|/// This class maintains the abbreviations read from a block info block.
name|class
name|BitstreamBlockInfo
block|{
name|public
label|:
comment|/// This contains information emitted to BLOCKINFO_BLOCK blocks. These
comment|/// describe abbreviations that all blocks of the specified ID inherit.
struct|struct
name|BlockInfo
block|{
name|unsigned
name|BlockID
decl_stmt|;
name|std
operator|::
name|vector
operator|<
name|IntrusiveRefCntPtr
operator|<
name|BitCodeAbbrev
operator|>>
name|Abbrevs
expr_stmt|;
name|std
operator|::
name|string
name|Name
expr_stmt|;
name|std
operator|::
name|vector
operator|<
name|std
operator|::
name|pair
operator|<
name|unsigned
operator|,
name|std
operator|::
name|string
operator|>
expr|>
name|RecordNames
expr_stmt|;
block|}
struct|;
name|private
label|:
name|std
operator|::
name|vector
operator|<
name|BlockInfo
operator|>
name|BlockInfoRecords
expr_stmt|;
name|public
label|:
comment|/// If there is block info for the specified ID, return it, otherwise return
comment|/// null.
specifier|const
name|BlockInfo
modifier|*
name|getBlockInfo
argument_list|(
name|unsigned
name|BlockID
argument_list|)
decl|const
block|{
comment|// Common case, the most recent entry matches BlockID.
if|if
condition|(
operator|!
name|BlockInfoRecords
operator|.
name|empty
argument_list|()
operator|&&
name|BlockInfoRecords
operator|.
name|back
argument_list|()
operator|.
name|BlockID
operator|==
name|BlockID
condition|)
return|return
operator|&
name|BlockInfoRecords
operator|.
name|back
argument_list|()
return|;
for|for
control|(
name|unsigned
name|i
init|=
literal|0
init|,
name|e
init|=
name|static_cast
operator|<
name|unsigned
operator|>
operator|(
name|BlockInfoRecords
operator|.
name|size
argument_list|()
operator|)
init|;
name|i
operator|!=
name|e
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|BlockInfoRecords
index|[
name|i
index|]
operator|.
name|BlockID
operator|==
name|BlockID
condition|)
return|return
operator|&
name|BlockInfoRecords
index|[
name|i
index|]
return|;
return|return
name|nullptr
return|;
block|}
name|BlockInfo
modifier|&
name|getOrCreateBlockInfo
parameter_list|(
name|unsigned
name|BlockID
parameter_list|)
block|{
if|if
condition|(
specifier|const
name|BlockInfo
modifier|*
name|BI
init|=
name|getBlockInfo
argument_list|(
name|BlockID
argument_list|)
condition|)
return|return
operator|*
name|const_cast
operator|<
name|BlockInfo
operator|*
operator|>
operator|(
name|BI
operator|)
return|;
comment|// Otherwise, add a new record.
name|BlockInfoRecords
operator|.
name|emplace_back
argument_list|()
expr_stmt|;
name|BlockInfoRecords
operator|.
name|back
argument_list|()
operator|.
name|BlockID
operator|=
name|BlockID
expr_stmt|;
return|return
name|BlockInfoRecords
operator|.
name|back
argument_list|()
return|;
block|}
block|}
empty_stmt|;
comment|/// This represents a position within a bitstream. There may be multiple
comment|/// independent cursors reading within one bitstream, each maintaining their
comment|/// own local state.
name|class
name|SimpleBitstreamCursor
block|{
name|ArrayRef
operator|<
name|uint8_t
operator|>
name|BitcodeBytes
expr_stmt|;
name|size_t
name|NextChar
init|=
literal|0
decl_stmt|;
name|public
label|:
comment|/// This is the current data we have pulled from the stream but have not
comment|/// returned to the client. This is specifically and intentionally defined to
comment|/// follow the word size of the host machine for efficiency. We use word_t in
comment|/// places that are aware of this to make it perfectly explicit what is going
comment|/// on.
typedef|typedef
name|size_t
name|word_t
typedef|;
name|private
label|:
name|word_t
name|CurWord
init|=
literal|0
decl_stmt|;
comment|/// This is the number of bits in CurWord that are valid. This is always from
comment|/// [0...bits_of(size_t)-1] inclusive.
name|unsigned
name|BitsInCurWord
init|=
literal|0
decl_stmt|;
name|public
label|:
specifier|static
specifier|const
name|size_t
name|MaxChunkSize
init|=
sizeof|sizeof
argument_list|(
name|word_t
argument_list|)
operator|*
literal|8
decl_stmt|;
name|SimpleBitstreamCursor
argument_list|()
operator|=
expr|default
expr_stmt|;
name|explicit
name|SimpleBitstreamCursor
argument_list|(
name|ArrayRef
operator|<
name|uint8_t
operator|>
name|BitcodeBytes
argument_list|)
range|:
name|BitcodeBytes
argument_list|(
argument|BitcodeBytes
argument_list|)
block|{}
name|explicit
name|SimpleBitstreamCursor
argument_list|(
argument|StringRef BitcodeBytes
argument_list|)
operator|:
name|BitcodeBytes
argument_list|(
argument|reinterpret_cast<const uint8_t *>(BitcodeBytes.data())
argument_list|,
argument|BitcodeBytes.size()
argument_list|)
block|{}
name|explicit
name|SimpleBitstreamCursor
argument_list|(
argument|MemoryBufferRef BitcodeBytes
argument_list|)
operator|:
name|SimpleBitstreamCursor
argument_list|(
argument|BitcodeBytes.getBuffer()
argument_list|)
block|{}
name|bool
name|canSkipToPos
argument_list|(
argument|size_t pos
argument_list|)
specifier|const
block|{
comment|// pos can be skipped to if it is a valid address or one byte past the end.
return|return
name|pos
operator|<=
name|BitcodeBytes
operator|.
name|size
argument_list|()
return|;
block|}
name|bool
name|AtEndOfStream
parameter_list|()
block|{
return|return
name|BitsInCurWord
operator|==
literal|0
operator|&&
name|BitcodeBytes
operator|.
name|size
argument_list|()
operator|<=
name|NextChar
return|;
block|}
comment|/// Return the bit # of the bit we are reading.
name|uint64_t
name|GetCurrentBitNo
argument_list|()
specifier|const
block|{
return|return
name|NextChar
operator|*
name|CHAR_BIT
operator|-
name|BitsInCurWord
return|;
block|}
comment|// Return the byte # of the current bit.
name|uint64_t
name|getCurrentByteNo
argument_list|()
specifier|const
block|{
return|return
name|GetCurrentBitNo
argument_list|()
operator|/
literal|8
return|;
block|}
name|ArrayRef
operator|<
name|uint8_t
operator|>
name|getBitcodeBytes
argument_list|()
specifier|const
block|{
return|return
name|BitcodeBytes
return|;
block|}
comment|/// Reset the stream to the specified bit number.
name|void
name|JumpToBit
parameter_list|(
name|uint64_t
name|BitNo
parameter_list|)
block|{
name|size_t
name|ByteNo
init|=
name|size_t
argument_list|(
name|BitNo
operator|/
literal|8
argument_list|)
operator|&
operator|~
operator|(
sizeof|sizeof
argument_list|(
name|word_t
argument_list|)
operator|-
literal|1
operator|)
decl_stmt|;
name|unsigned
name|WordBitNo
init|=
name|unsigned
argument_list|(
name|BitNo
operator|&
operator|(
sizeof|sizeof
argument_list|(
name|word_t
argument_list|)
operator|*
literal|8
operator|-
literal|1
operator|)
argument_list|)
decl_stmt|;
name|assert
argument_list|(
name|canSkipToPos
argument_list|(
name|ByteNo
argument_list|)
operator|&&
literal|"Invalid location"
argument_list|)
expr_stmt|;
comment|// Move the cursor to the right word.
name|NextChar
operator|=
name|ByteNo
expr_stmt|;
name|BitsInCurWord
operator|=
literal|0
expr_stmt|;
comment|// Skip over any bits that are already consumed.
if|if
condition|(
name|WordBitNo
condition|)
name|Read
argument_list|(
name|WordBitNo
argument_list|)
expr_stmt|;
block|}
comment|/// Get a pointer into the bitstream at the specified byte offset.
specifier|const
name|uint8_t
modifier|*
name|getPointerToByte
parameter_list|(
name|uint64_t
name|ByteNo
parameter_list|,
name|uint64_t
name|NumBytes
parameter_list|)
block|{
return|return
name|BitcodeBytes
operator|.
name|data
argument_list|()
operator|+
name|ByteNo
return|;
block|}
comment|/// Get a pointer into the bitstream at the specified bit offset.
comment|///
comment|/// The bit offset must be on a byte boundary.
specifier|const
name|uint8_t
modifier|*
name|getPointerToBit
parameter_list|(
name|uint64_t
name|BitNo
parameter_list|,
name|uint64_t
name|NumBytes
parameter_list|)
block|{
name|assert
argument_list|(
operator|!
operator|(
name|BitNo
operator|%
literal|8
operator|)
operator|&&
literal|"Expected bit on byte boundary"
argument_list|)
expr_stmt|;
return|return
name|getPointerToByte
argument_list|(
name|BitNo
operator|/
literal|8
argument_list|,
name|NumBytes
argument_list|)
return|;
block|}
name|void
name|fillCurWord
parameter_list|()
block|{
if|if
condition|(
name|NextChar
operator|>=
name|BitcodeBytes
operator|.
name|size
argument_list|()
condition|)
name|report_fatal_error
argument_list|(
literal|"Unexpected end of file"
argument_list|)
expr_stmt|;
comment|// Read the next word from the stream.
specifier|const
name|uint8_t
modifier|*
name|NextCharPtr
init|=
name|BitcodeBytes
operator|.
name|data
argument_list|()
operator|+
name|NextChar
decl_stmt|;
name|unsigned
name|BytesRead
decl_stmt|;
if|if
condition|(
name|BitcodeBytes
operator|.
name|size
argument_list|()
operator|>=
name|NextChar
operator|+
sizeof|sizeof
argument_list|(
name|word_t
argument_list|)
condition|)
block|{
name|BytesRead
operator|=
sizeof|sizeof
argument_list|(
name|word_t
argument_list|)
expr_stmt|;
name|CurWord
operator|=
name|support
operator|::
name|endian
operator|::
name|read
operator|<
name|word_t
operator|,
name|support
operator|::
name|little
operator|,
name|support
operator|::
name|unaligned
operator|>
operator|(
name|NextCharPtr
operator|)
expr_stmt|;
block|}
else|else
block|{
comment|// Short read.
name|BytesRead
operator|=
name|BitcodeBytes
operator|.
name|size
argument_list|()
operator|-
name|NextChar
expr_stmt|;
name|CurWord
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|unsigned
name|B
init|=
literal|0
init|;
name|B
operator|!=
name|BytesRead
condition|;
operator|++
name|B
control|)
name|CurWord
operator||=
name|uint64_t
argument_list|(
name|NextCharPtr
index|[
name|B
index|]
argument_list|)
operator|<<
operator|(
name|B
operator|*
literal|8
operator|)
expr_stmt|;
block|}
name|NextChar
operator|+=
name|BytesRead
expr_stmt|;
name|BitsInCurWord
operator|=
name|BytesRead
operator|*
literal|8
expr_stmt|;
block|}
name|word_t
name|Read
parameter_list|(
name|unsigned
name|NumBits
parameter_list|)
block|{
specifier|static
specifier|const
name|unsigned
name|BitsInWord
init|=
name|MaxChunkSize
decl_stmt|;
name|assert
argument_list|(
name|NumBits
operator|&&
name|NumBits
operator|<=
name|BitsInWord
operator|&&
literal|"Cannot return zero or more than BitsInWord bits!"
argument_list|)
expr_stmt|;
specifier|static
specifier|const
name|unsigned
name|Mask
init|=
sizeof|sizeof
argument_list|(
name|word_t
argument_list|)
operator|>
literal|4
condition|?
literal|0x3f
else|:
literal|0x1f
decl_stmt|;
comment|// If the field is fully contained by CurWord, return it quickly.
if|if
condition|(
name|BitsInCurWord
operator|>=
name|NumBits
condition|)
block|{
name|word_t
name|R
init|=
name|CurWord
operator|&
operator|(
operator|~
name|word_t
argument_list|(
literal|0
argument_list|)
operator|>>
operator|(
name|BitsInWord
operator|-
name|NumBits
operator|)
operator|)
decl_stmt|;
comment|// Use a mask to avoid undefined behavior.
name|CurWord
operator|>>=
operator|(
name|NumBits
operator|&
name|Mask
operator|)
expr_stmt|;
name|BitsInCurWord
operator|-=
name|NumBits
expr_stmt|;
return|return
name|R
return|;
block|}
name|word_t
name|R
init|=
name|BitsInCurWord
condition|?
name|CurWord
else|:
literal|0
decl_stmt|;
name|unsigned
name|BitsLeft
init|=
name|NumBits
operator|-
name|BitsInCurWord
decl_stmt|;
name|fillCurWord
argument_list|()
expr_stmt|;
comment|// If we run out of data, abort.
if|if
condition|(
name|BitsLeft
operator|>
name|BitsInCurWord
condition|)
name|report_fatal_error
argument_list|(
literal|"Unexpected end of file"
argument_list|)
expr_stmt|;
name|word_t
name|R2
init|=
name|CurWord
operator|&
operator|(
operator|~
name|word_t
argument_list|(
literal|0
argument_list|)
operator|>>
operator|(
name|BitsInWord
operator|-
name|BitsLeft
operator|)
operator|)
decl_stmt|;
comment|// Use a mask to avoid undefined behavior.
name|CurWord
operator|>>=
operator|(
name|BitsLeft
operator|&
name|Mask
operator|)
expr_stmt|;
name|BitsInCurWord
operator|-=
name|BitsLeft
expr_stmt|;
name|R
operator||=
name|R2
operator|<<
operator|(
name|NumBits
operator|-
name|BitsLeft
operator|)
expr_stmt|;
return|return
name|R
return|;
block|}
name|uint32_t
name|ReadVBR
parameter_list|(
name|unsigned
name|NumBits
parameter_list|)
block|{
name|uint32_t
name|Piece
init|=
name|Read
argument_list|(
name|NumBits
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|Piece
operator|&
operator|(
literal|1U
operator|<<
operator|(
name|NumBits
operator|-
literal|1
operator|)
operator|)
operator|)
operator|==
literal|0
condition|)
return|return
name|Piece
return|;
name|uint32_t
name|Result
init|=
literal|0
decl_stmt|;
name|unsigned
name|NextBit
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|true
condition|)
block|{
name|Result
operator||=
operator|(
name|Piece
operator|&
operator|(
operator|(
literal|1U
operator|<<
operator|(
name|NumBits
operator|-
literal|1
operator|)
operator|)
operator|-
literal|1
operator|)
operator|)
operator|<<
name|NextBit
expr_stmt|;
if|if
condition|(
operator|(
name|Piece
operator|&
operator|(
literal|1U
operator|<<
operator|(
name|NumBits
operator|-
literal|1
operator|)
operator|)
operator|)
operator|==
literal|0
condition|)
return|return
name|Result
return|;
name|NextBit
operator|+=
name|NumBits
operator|-
literal|1
expr_stmt|;
name|Piece
operator|=
name|Read
argument_list|(
name|NumBits
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Read a VBR that may have a value up to 64-bits in size. The chunk size of
comment|// the VBR must still be<= 32 bits though.
name|uint64_t
name|ReadVBR64
parameter_list|(
name|unsigned
name|NumBits
parameter_list|)
block|{
name|uint32_t
name|Piece
init|=
name|Read
argument_list|(
name|NumBits
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|Piece
operator|&
operator|(
literal|1U
operator|<<
operator|(
name|NumBits
operator|-
literal|1
operator|)
operator|)
operator|)
operator|==
literal|0
condition|)
return|return
name|uint64_t
argument_list|(
name|Piece
argument_list|)
return|;
name|uint64_t
name|Result
init|=
literal|0
decl_stmt|;
name|unsigned
name|NextBit
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|true
condition|)
block|{
name|Result
operator||=
name|uint64_t
argument_list|(
name|Piece
operator|&
operator|(
operator|(
literal|1U
operator|<<
operator|(
name|NumBits
operator|-
literal|1
operator|)
operator|)
operator|-
literal|1
operator|)
argument_list|)
operator|<<
name|NextBit
expr_stmt|;
if|if
condition|(
operator|(
name|Piece
operator|&
operator|(
literal|1U
operator|<<
operator|(
name|NumBits
operator|-
literal|1
operator|)
operator|)
operator|)
operator|==
literal|0
condition|)
return|return
name|Result
return|;
name|NextBit
operator|+=
name|NumBits
operator|-
literal|1
expr_stmt|;
name|Piece
operator|=
name|Read
argument_list|(
name|NumBits
argument_list|)
expr_stmt|;
block|}
block|}
name|void
name|SkipToFourByteBoundary
parameter_list|()
block|{
comment|// If word_t is 64-bits and if we've read less than 32 bits, just dump
comment|// the bits we have up to the next 32-bit boundary.
if|if
condition|(
sizeof|sizeof
argument_list|(
name|word_t
argument_list|)
operator|>
literal|4
operator|&&
name|BitsInCurWord
operator|>=
literal|32
condition|)
block|{
name|CurWord
operator|>>=
name|BitsInCurWord
operator|-
literal|32
expr_stmt|;
name|BitsInCurWord
operator|=
literal|32
expr_stmt|;
return|return;
block|}
name|BitsInCurWord
operator|=
literal|0
expr_stmt|;
block|}
comment|/// Skip to the end of the file.
name|void
name|skipToEnd
parameter_list|()
block|{
name|NextChar
operator|=
name|BitcodeBytes
operator|.
name|size
argument_list|()
expr_stmt|;
block|}
block|}
empty_stmt|;
comment|/// When advancing through a bitstream cursor, each advance can discover a few
comment|/// different kinds of entries:
struct|struct
name|BitstreamEntry
block|{
enum|enum
block|{
name|Error
block|,
comment|// Malformed bitcode was found.
name|EndBlock
block|,
comment|// We've reached the end of the current block, (or the end of the
comment|// file, which is treated like a series of EndBlock records.
name|SubBlock
block|,
comment|// This is the start of a new subblock of a specific ID.
name|Record
comment|// This is a record with a specific AbbrevID.
block|}
name|Kind
enum|;
name|unsigned
name|ID
decl_stmt|;
specifier|static
name|BitstreamEntry
name|getError
parameter_list|()
block|{
name|BitstreamEntry
name|E
decl_stmt|;
name|E
operator|.
name|Kind
operator|=
name|Error
expr_stmt|;
return|return
name|E
return|;
block|}
specifier|static
name|BitstreamEntry
name|getEndBlock
parameter_list|()
block|{
name|BitstreamEntry
name|E
decl_stmt|;
name|E
operator|.
name|Kind
operator|=
name|EndBlock
expr_stmt|;
return|return
name|E
return|;
block|}
specifier|static
name|BitstreamEntry
name|getSubBlock
parameter_list|(
name|unsigned
name|ID
parameter_list|)
block|{
name|BitstreamEntry
name|E
decl_stmt|;
name|E
operator|.
name|Kind
operator|=
name|SubBlock
expr_stmt|;
name|E
operator|.
name|ID
operator|=
name|ID
expr_stmt|;
return|return
name|E
return|;
block|}
specifier|static
name|BitstreamEntry
name|getRecord
parameter_list|(
name|unsigned
name|AbbrevID
parameter_list|)
block|{
name|BitstreamEntry
name|E
decl_stmt|;
name|E
operator|.
name|Kind
operator|=
name|Record
expr_stmt|;
name|E
operator|.
name|ID
operator|=
name|AbbrevID
expr_stmt|;
return|return
name|E
return|;
block|}
block|}
struct|;
comment|/// This represents a position within a bitcode file, implemented on top of a
comment|/// SimpleBitstreamCursor.
comment|///
comment|/// Unlike iterators, BitstreamCursors are heavy-weight objects that should not
comment|/// be passed by value.
name|class
name|BitstreamCursor
range|:
name|SimpleBitstreamCursor
block|{
comment|// This is the declared size of code values used for the current block, in
comment|// bits.
name|unsigned
name|CurCodeSize
operator|=
literal|2
block|;
comment|/// Abbrevs installed at in this block.
name|std
operator|::
name|vector
operator|<
name|IntrusiveRefCntPtr
operator|<
name|BitCodeAbbrev
operator|>>
name|CurAbbrevs
block|;    struct
name|Block
block|{
name|unsigned
name|PrevCodeSize
block|;
name|std
operator|::
name|vector
operator|<
name|IntrusiveRefCntPtr
operator|<
name|BitCodeAbbrev
operator|>>
name|PrevAbbrevs
block|;
name|explicit
name|Block
argument_list|(
argument|unsigned PCS
argument_list|)
operator|:
name|PrevCodeSize
argument_list|(
argument|PCS
argument_list|)
block|{}
block|}
block|;
comment|/// This tracks the codesize of parent blocks.
name|SmallVector
operator|<
name|Block
block|,
literal|8
operator|>
name|BlockScope
block|;
name|BitstreamBlockInfo
operator|*
name|BlockInfo
operator|=
name|nullptr
block|;
name|public
operator|:
specifier|static
specifier|const
name|size_t
name|MaxChunkSize
operator|=
sizeof|sizeof
argument_list|(
name|word_t
argument_list|)
operator|*
literal|8
block|;
name|BitstreamCursor
argument_list|()
operator|=
expr|default
block|;
name|explicit
name|BitstreamCursor
argument_list|(
name|ArrayRef
operator|<
name|uint8_t
operator|>
name|BitcodeBytes
argument_list|)
operator|:
name|SimpleBitstreamCursor
argument_list|(
argument|BitcodeBytes
argument_list|)
block|{}
name|explicit
name|BitstreamCursor
argument_list|(
argument|StringRef BitcodeBytes
argument_list|)
operator|:
name|SimpleBitstreamCursor
argument_list|(
argument|BitcodeBytes
argument_list|)
block|{}
name|explicit
name|BitstreamCursor
argument_list|(
argument|MemoryBufferRef BitcodeBytes
argument_list|)
operator|:
name|SimpleBitstreamCursor
argument_list|(
argument|BitcodeBytes
argument_list|)
block|{}
name|using
name|SimpleBitstreamCursor
operator|::
name|canSkipToPos
block|;
name|using
name|SimpleBitstreamCursor
operator|::
name|AtEndOfStream
block|;
name|using
name|SimpleBitstreamCursor
operator|::
name|getBitcodeBytes
block|;
name|using
name|SimpleBitstreamCursor
operator|::
name|GetCurrentBitNo
block|;
name|using
name|SimpleBitstreamCursor
operator|::
name|getCurrentByteNo
block|;
name|using
name|SimpleBitstreamCursor
operator|::
name|getPointerToByte
block|;
name|using
name|SimpleBitstreamCursor
operator|::
name|JumpToBit
block|;
name|using
name|SimpleBitstreamCursor
operator|::
name|fillCurWord
block|;
name|using
name|SimpleBitstreamCursor
operator|::
name|Read
block|;
name|using
name|SimpleBitstreamCursor
operator|::
name|ReadVBR
block|;
name|using
name|SimpleBitstreamCursor
operator|::
name|ReadVBR64
block|;
comment|/// Return the number of bits used to encode an abbrev #.
name|unsigned
name|getAbbrevIDWidth
argument_list|()
specifier|const
block|{
return|return
name|CurCodeSize
return|;
block|}
comment|/// Flags that modify the behavior of advance().
expr|enum
block|{
comment|/// If this flag is used, the advance() method does not automatically pop
comment|/// the block scope when the end of a block is reached.
name|AF_DontPopBlockAtEnd
operator|=
literal|1
block|,
comment|/// If this flag is used, abbrev entries are returned just like normal
comment|/// records.
name|AF_DontAutoprocessAbbrevs
operator|=
literal|2
block|}
block|;
comment|/// Advance the current bitstream, returning the next entry in the stream.
name|BitstreamEntry
name|advance
argument_list|(
argument|unsigned Flags =
literal|0
argument_list|)
block|{
while|while
condition|(
name|true
condition|)
block|{
if|if
condition|(
name|AtEndOfStream
argument_list|()
condition|)
return|return
name|BitstreamEntry
operator|::
name|getError
argument_list|()
return|;
name|unsigned
name|Code
init|=
name|ReadCode
argument_list|()
decl_stmt|;
if|if
condition|(
name|Code
operator|==
name|bitc
operator|::
name|END_BLOCK
condition|)
block|{
comment|// Pop the end of the block unless Flags tells us not to.
if|if
condition|(
operator|!
operator|(
name|Flags
operator|&
name|AF_DontPopBlockAtEnd
operator|)
operator|&&
name|ReadBlockEnd
argument_list|()
condition|)
return|return
name|BitstreamEntry
operator|::
name|getError
argument_list|()
return|;
return|return
name|BitstreamEntry
operator|::
name|getEndBlock
argument_list|()
return|;
block|}
if|if
condition|(
name|Code
operator|==
name|bitc
operator|::
name|ENTER_SUBBLOCK
condition|)
return|return
name|BitstreamEntry
operator|::
name|getSubBlock
argument_list|(
name|ReadSubBlockID
argument_list|()
argument_list|)
return|;
if|if
condition|(
name|Code
operator|==
name|bitc
operator|::
name|DEFINE_ABBREV
operator|&&
operator|!
operator|(
name|Flags
operator|&
name|AF_DontAutoprocessAbbrevs
operator|)
condition|)
block|{
comment|// We read and accumulate abbrev's, the client can't do anything with
comment|// them anyway.
name|ReadAbbrevRecord
argument_list|()
expr_stmt|;
continue|continue;
block|}
return|return
name|BitstreamEntry
operator|::
name|getRecord
argument_list|(
name|Code
argument_list|)
return|;
block|}
block|}
comment|/// This is a convenience function for clients that don't expect any
comment|/// subblocks. This just skips over them automatically.
name|BitstreamEntry
name|advanceSkippingSubblocks
argument_list|(
argument|unsigned Flags =
literal|0
argument_list|)
block|{
while|while
condition|(
name|true
condition|)
block|{
comment|// If we found a normal entry, return it.
name|BitstreamEntry
name|Entry
init|=
name|advance
argument_list|(
name|Flags
argument_list|)
decl_stmt|;
if|if
condition|(
name|Entry
operator|.
name|Kind
operator|!=
name|BitstreamEntry
operator|::
name|SubBlock
condition|)
return|return
name|Entry
return|;
comment|// If we found a sub-block, just skip over it and check the next entry.
if|if
condition|(
name|SkipBlock
argument_list|()
condition|)
return|return
name|BitstreamEntry
operator|::
name|getError
argument_list|()
return|;
block|}
block|}
name|unsigned
name|ReadCode
argument_list|()
block|{
return|return
name|Read
argument_list|(
name|CurCodeSize
argument_list|)
return|;
block|}
comment|// Block header:
comment|//    [ENTER_SUBBLOCK, blockid, newcodelen,<align4bytes>, blocklen]
comment|/// Having read the ENTER_SUBBLOCK code, read the BlockID for the block.
name|unsigned
name|ReadSubBlockID
argument_list|()
block|{
return|return
name|ReadVBR
argument_list|(
name|bitc
operator|::
name|BlockIDWidth
argument_list|)
return|;
block|}
comment|/// Having read the ENTER_SUBBLOCK abbrevid and a BlockID, skip over the body
comment|/// of this block. If the block record is malformed, return true.
name|bool
name|SkipBlock
argument_list|()
block|{
comment|// Read and ignore the codelen value.  Since we are skipping this block, we
comment|// don't care what code widths are used inside of it.
name|ReadVBR
argument_list|(
name|bitc
operator|::
name|CodeLenWidth
argument_list|)
block|;
name|SkipToFourByteBoundary
argument_list|()
block|;
name|unsigned
name|NumFourBytes
operator|=
name|Read
argument_list|(
name|bitc
operator|::
name|BlockSizeWidth
argument_list|)
block|;
comment|// Check that the block wasn't partially defined, and that the offset isn't
comment|// bogus.
name|size_t
name|SkipTo
operator|=
name|GetCurrentBitNo
argument_list|()
operator|+
name|NumFourBytes
operator|*
literal|4
operator|*
literal|8
block|;
if|if
condition|(
name|AtEndOfStream
argument_list|()
operator|||
operator|!
name|canSkipToPos
argument_list|(
name|SkipTo
operator|/
literal|8
argument_list|)
condition|)
return|return
name|true
return|;
name|JumpToBit
argument_list|(
name|SkipTo
argument_list|)
block|;
return|return
name|false
return|;
block|}
comment|/// Having read the ENTER_SUBBLOCK abbrevid, enter the block, and return true
comment|/// if the block has an error.
name|bool
name|EnterSubBlock
parameter_list|(
name|unsigned
name|BlockID
parameter_list|,
name|unsigned
modifier|*
name|NumWordsP
init|=
name|nullptr
parameter_list|)
function_decl|;
name|bool
name|ReadBlockEnd
parameter_list|()
block|{
if|if
condition|(
name|BlockScope
operator|.
name|empty
argument_list|()
condition|)
return|return
name|true
return|;
comment|// Block tail:
comment|//    [END_BLOCK,<align4bytes>]
name|SkipToFourByteBoundary
argument_list|()
expr_stmt|;
name|popBlockScope
argument_list|()
expr_stmt|;
return|return
name|false
return|;
block|}
name|private
label|:
name|void
name|popBlockScope
parameter_list|()
block|{
name|CurCodeSize
operator|=
name|BlockScope
operator|.
name|back
argument_list|()
operator|.
name|PrevCodeSize
expr_stmt|;
name|CurAbbrevs
operator|=
name|std
operator|::
name|move
argument_list|(
name|BlockScope
operator|.
name|back
argument_list|()
operator|.
name|PrevAbbrevs
argument_list|)
expr_stmt|;
name|BlockScope
operator|.
name|pop_back
argument_list|()
expr_stmt|;
block|}
comment|//===--------------------------------------------------------------------===//
comment|// Record Processing
comment|//===--------------------------------------------------------------------===//
name|public
label|:
comment|/// Return the abbreviation for the specified AbbrevId.
specifier|const
name|BitCodeAbbrev
modifier|*
name|getAbbrev
parameter_list|(
name|unsigned
name|AbbrevID
parameter_list|)
block|{
name|unsigned
name|AbbrevNo
init|=
name|AbbrevID
operator|-
name|bitc
operator|::
name|FIRST_APPLICATION_ABBREV
decl_stmt|;
if|if
condition|(
name|AbbrevNo
operator|>=
name|CurAbbrevs
operator|.
name|size
argument_list|()
condition|)
name|report_fatal_error
argument_list|(
literal|"Invalid abbrev number"
argument_list|)
expr_stmt|;
return|return
name|CurAbbrevs
index|[
name|AbbrevNo
index|]
operator|.
name|get
argument_list|()
return|;
block|}
comment|/// Read the current record and discard it.
name|void
name|skipRecord
parameter_list|(
name|unsigned
name|AbbrevID
parameter_list|)
function_decl|;
name|unsigned
name|readRecord
argument_list|(
name|unsigned
name|AbbrevID
argument_list|,
name|SmallVectorImpl
operator|<
name|uint64_t
operator|>
operator|&
name|Vals
argument_list|,
name|StringRef
operator|*
name|Blob
operator|=
name|nullptr
argument_list|)
decl_stmt|;
comment|//===--------------------------------------------------------------------===//
comment|// Abbrev Processing
comment|//===--------------------------------------------------------------------===//
name|void
name|ReadAbbrevRecord
parameter_list|()
function_decl|;
comment|/// Read and return a block info block from the bitstream. If an error was
comment|/// encountered, return None.
comment|///
comment|/// \param ReadBlockInfoNames Whether to read block/record name information in
comment|/// the BlockInfo block. Only llvm-bcanalyzer uses this.
name|Optional
operator|<
name|BitstreamBlockInfo
operator|>
name|ReadBlockInfoBlock
argument_list|(
argument|bool ReadBlockInfoNames = false
argument_list|)
expr_stmt|;
comment|/// Set the block info to be used by this BitstreamCursor to interpret
comment|/// abbreviated records.
name|void
name|setBlockInfo
parameter_list|(
name|BitstreamBlockInfo
modifier|*
name|BI
parameter_list|)
block|{
name|BlockInfo
operator|=
name|BI
expr_stmt|;
block|}
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_comment
unit|}
comment|// end llvm namespace
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|// LLVM_BITCODE_BITSTREAMREADER_H
end_comment

end_unit

