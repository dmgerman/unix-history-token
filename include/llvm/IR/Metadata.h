begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===-- llvm/Metadata.h - Metadata definitions ------------------*- C++ -*-===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|/// @file
end_comment

begin_comment
comment|/// This file contains the declarations for metadata subclasses.
end_comment

begin_comment
comment|/// They represent the different flavors of metadata that live in LLVM.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LLVM_IR_METADATA_H
end_ifndef

begin_define
define|#
directive|define
name|LLVM_IR_METADATA_H
end_define

begin_include
include|#
directive|include
file|"llvm/ADT/ArrayRef.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/DenseMap.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/ilist_node.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/iterator_range.h"
end_include

begin_include
include|#
directive|include
file|"llvm/IR/Constant.h"
end_include

begin_include
include|#
directive|include
file|"llvm/IR/MetadataTracking.h"
end_include

begin_include
include|#
directive|include
file|"llvm/IR/Value.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/ErrorHandling.h"
end_include

begin_include
include|#
directive|include
file|<type_traits>
end_include

begin_decl_stmt
name|namespace
name|llvm
block|{
name|class
name|LLVMContext
decl_stmt|;
name|class
name|Module
decl_stmt|;
name|template
operator|<
name|typename
name|ValueSubClass
operator|,
name|typename
name|ItemParentClass
operator|>
name|class
name|SymbolTableListTraits
expr_stmt|;
enum|enum
name|LLVMConstants
enum|:
name|uint32_t
block|{
name|DEBUG_METADATA_VERSION
init|=
literal|2
comment|// Current debug info version number.
block|}
enum|;
comment|/// \brief Root of the metadata hierarchy.
comment|///
comment|/// This is a root class for typeless data in the IR.
name|class
name|Metadata
block|{
name|friend
name|class
name|ReplaceableMetadataImpl
decl_stmt|;
comment|/// \brief RTTI.
specifier|const
name|unsigned
name|char
name|SubclassID
decl_stmt|;
name|protected
label|:
comment|/// \brief Storage flag for non-uniqued, otherwise unowned, metadata.
name|bool
name|IsDistinctInContext
range|:
literal|1
decl_stmt|;
comment|// TODO: expose remaining bits to subclasses.
name|unsigned
name|short
name|SubclassData16
decl_stmt|;
name|unsigned
name|SubclassData32
decl_stmt|;
name|public
label|:
enum|enum
name|MetadataKind
block|{
name|MDTupleKind
block|,
name|MDLocationKind
block|,
name|MDNodeFwdDeclKind
block|,
name|ConstantAsMetadataKind
block|,
name|LocalAsMetadataKind
block|,
name|MDStringKind
block|}
enum|;
name|protected
label|:
name|Metadata
argument_list|(
argument|unsigned ID
argument_list|)
block|:
name|SubclassID
argument_list|(
name|ID
argument_list|)
operator|,
name|IsDistinctInContext
argument_list|(
name|false
argument_list|)
operator|,
name|SubclassData16
argument_list|(
literal|0
argument_list|)
operator|,
name|SubclassData32
argument_list|(
literal|0
argument_list|)
block|{}
operator|~
name|Metadata
argument_list|()
block|{}
comment|/// \brief Store this in a big non-uniqued untyped bucket.
name|bool
name|isStoredDistinctInContext
argument_list|()
specifier|const
block|{
return|return
name|IsDistinctInContext
return|;
block|}
comment|/// \brief Default handling of a changed operand, which asserts.
comment|///
comment|/// If subclasses pass themselves in as owners to a tracking node reference,
comment|/// they must provide an implementation of this method.
name|void
name|handleChangedOperand
parameter_list|(
name|void
modifier|*
parameter_list|,
name|Metadata
modifier|*
parameter_list|)
block|{
name|llvm_unreachable
argument_list|(
literal|"Unimplemented in Metadata subclass"
argument_list|)
expr_stmt|;
block|}
name|public
label|:
name|unsigned
name|getMetadataID
argument_list|()
specifier|const
block|{
return|return
name|SubclassID
return|;
block|}
comment|/// \brief User-friendly dump.
name|void
name|dump
argument_list|()
specifier|const
expr_stmt|;
name|void
name|print
argument_list|(
name|raw_ostream
operator|&
name|OS
argument_list|)
decl|const
decl_stmt|;
name|void
name|printAsOperand
argument_list|(
name|raw_ostream
operator|&
name|OS
argument_list|,
name|bool
name|PrintType
operator|=
name|true
argument_list|,
specifier|const
name|Module
operator|*
name|M
operator|=
name|nullptr
argument_list|)
decl|const
decl_stmt|;
block|}
empty_stmt|;
define|#
directive|define
name|HANDLE_METADATA
parameter_list|(
name|CLASS
parameter_list|)
value|class CLASS;
include|#
directive|include
file|"llvm/IR/Metadata.def"
specifier|inline
name|raw_ostream
operator|&
name|operator
operator|<<
operator|(
name|raw_ostream
operator|&
name|OS
operator|,
specifier|const
name|Metadata
operator|&
name|MD
operator|)
block|{
name|MD
operator|.
name|print
argument_list|(
name|OS
argument_list|)
block|;
return|return
name|OS
return|;
block|}
comment|/// \brief Metadata wrapper in the Value hierarchy.
comment|///
comment|/// A member of the \a Value hierarchy to represent a reference to metadata.
comment|/// This allows, e.g., instrinsics to have metadata as operands.
comment|///
comment|/// Notably, this is the only thing in either hierarchy that is allowed to
comment|/// reference \a LocalAsMetadata.
name|class
name|MetadataAsValue
range|:
name|public
name|Value
block|{
name|friend
name|class
name|ReplaceableMetadataImpl
block|;
name|friend
name|class
name|LLVMContextImpl
block|;
name|Metadata
operator|*
name|MD
block|;
name|MetadataAsValue
argument_list|(
name|Type
operator|*
name|Ty
argument_list|,
name|Metadata
operator|*
name|MD
argument_list|)
block|;
operator|~
name|MetadataAsValue
argument_list|()
block|;
comment|/// \brief Drop use of metadata (during teardown).
name|void
name|dropUse
argument_list|()
block|{
name|MD
operator|=
name|nullptr
block|; }
name|public
operator|:
specifier|static
name|MetadataAsValue
operator|*
name|get
argument_list|(
name|LLVMContext
operator|&
name|Context
argument_list|,
name|Metadata
operator|*
name|MD
argument_list|)
block|;
specifier|static
name|MetadataAsValue
operator|*
name|getIfExists
argument_list|(
name|LLVMContext
operator|&
name|Context
argument_list|,
name|Metadata
operator|*
name|MD
argument_list|)
block|;
name|Metadata
operator|*
name|getMetadata
argument_list|()
specifier|const
block|{
return|return
name|MD
return|;
block|}
specifier|static
name|bool
name|classof
argument_list|(
argument|const Value *V
argument_list|)
block|{
return|return
name|V
operator|->
name|getValueID
argument_list|()
operator|==
name|MetadataAsValueVal
return|;
block|}
name|private
operator|:
name|void
name|handleChangedMetadata
argument_list|(
name|Metadata
operator|*
name|MD
argument_list|)
block|;
name|void
name|track
argument_list|()
block|;
name|void
name|untrack
argument_list|()
block|; }
decl_stmt|;
comment|/// \brief Shared implementation of use-lists for replaceable metadata.
comment|///
comment|/// Most metadata cannot be RAUW'ed.  This is a shared implementation of
comment|/// use-lists and associated API for the two that support it (\a ValueAsMetadata
comment|/// and \a TempMDNode).
name|class
name|ReplaceableMetadataImpl
block|{
name|friend
name|class
name|MetadataTracking
decl_stmt|;
name|public
label|:
typedef|typedef
name|MetadataTracking
operator|::
name|OwnerTy
name|OwnerTy
expr_stmt|;
name|private
label|:
name|uint64_t
name|NextIndex
decl_stmt|;
name|SmallDenseMap
operator|<
name|void
operator|*
operator|,
name|std
operator|::
name|pair
operator|<
name|OwnerTy
operator|,
name|uint64_t
operator|>
operator|,
literal|4
operator|>
name|UseMap
expr_stmt|;
name|public
label|:
name|ReplaceableMetadataImpl
argument_list|()
operator|:
name|NextIndex
argument_list|(
literal|0
argument_list|)
block|{}
operator|~
name|ReplaceableMetadataImpl
argument_list|()
block|{
name|assert
argument_list|(
name|UseMap
operator|.
name|empty
argument_list|()
operator|&&
literal|"Cannot destroy in-use replaceable metadata"
argument_list|)
block|;   }
comment|/// \brief Replace all uses of this with MD.
comment|///
comment|/// Replace all uses of this with \c MD, which is allowed to be null.
name|void
name|replaceAllUsesWith
argument_list|(
name|Metadata
operator|*
name|MD
argument_list|)
expr_stmt|;
comment|/// \brief Resolve all uses of this.
comment|///
comment|/// Resolve all uses of this, turning off RAUW permanently.  If \c
comment|/// ResolveUsers, call \a UniquableMDNode::resolve() on any users whose last
comment|/// operand is resolved.
name|void
name|resolveAllUses
parameter_list|(
name|bool
name|ResolveUsers
init|=
name|true
parameter_list|)
function_decl|;
name|private
label|:
name|void
name|addRef
parameter_list|(
name|void
modifier|*
name|Ref
parameter_list|,
name|OwnerTy
name|Owner
parameter_list|)
function_decl|;
name|void
name|dropRef
parameter_list|(
name|void
modifier|*
name|Ref
parameter_list|)
function_decl|;
name|void
name|moveRef
parameter_list|(
name|void
modifier|*
name|Ref
parameter_list|,
name|void
modifier|*
name|New
parameter_list|,
specifier|const
name|Metadata
modifier|&
name|MD
parameter_list|)
function_decl|;
specifier|static
name|ReplaceableMetadataImpl
modifier|*
name|get
parameter_list|(
name|Metadata
modifier|&
name|MD
parameter_list|)
function_decl|;
block|}
empty_stmt|;
comment|/// \brief Value wrapper in the Metadata hierarchy.
comment|///
comment|/// This is a custom value handle that allows other metadata to refer to
comment|/// classes in the Value hierarchy.
comment|///
comment|/// Because of full uniquing support, each value is only wrapped by a single \a
comment|/// ValueAsMetadata object, so the lookup maps are far more efficient than
comment|/// those using ValueHandleBase.
name|class
name|ValueAsMetadata
range|:
name|public
name|Metadata
decl_stmt|,
name|ReplaceableMetadataImpl
block|{
name|friend
name|class
name|ReplaceableMetadataImpl
decl_stmt|;
name|friend
name|class
name|LLVMContextImpl
decl_stmt|;
name|Value
modifier|*
name|V
decl_stmt|;
comment|/// \brief Drop users without RAUW (during teardown).
name|void
name|dropUsers
parameter_list|()
block|{
name|ReplaceableMetadataImpl
operator|::
name|resolveAllUses
argument_list|(
comment|/* ResolveUsers */
name|false
argument_list|)
expr_stmt|;
block|}
name|protected
label|:
name|ValueAsMetadata
argument_list|(
argument|unsigned ID
argument_list|,
argument|Value *V
argument_list|)
block|:
name|Metadata
argument_list|(
name|ID
argument_list|)
operator|,
name|V
argument_list|(
argument|V
argument_list|)
block|{
name|assert
argument_list|(
name|V
operator|&&
literal|"Expected valid value"
argument_list|)
block|;   }
operator|~
name|ValueAsMetadata
argument_list|()
block|{}
name|public
operator|:
specifier|static
name|ValueAsMetadata
operator|*
name|get
argument_list|(
name|Value
operator|*
name|V
argument_list|)
expr_stmt|;
specifier|static
name|ConstantAsMetadata
modifier|*
name|getConstant
parameter_list|(
name|Value
modifier|*
name|C
parameter_list|)
block|{
return|return
name|cast
operator|<
name|ConstantAsMetadata
operator|>
operator|(
name|get
argument_list|(
name|C
argument_list|)
operator|)
return|;
block|}
specifier|static
name|LocalAsMetadata
modifier|*
name|getLocal
parameter_list|(
name|Value
modifier|*
name|Local
parameter_list|)
block|{
return|return
name|cast
operator|<
name|LocalAsMetadata
operator|>
operator|(
name|get
argument_list|(
name|Local
argument_list|)
operator|)
return|;
block|}
specifier|static
name|ValueAsMetadata
modifier|*
name|getIfExists
parameter_list|(
name|Value
modifier|*
name|V
parameter_list|)
function_decl|;
specifier|static
name|ConstantAsMetadata
modifier|*
name|getConstantIfExists
parameter_list|(
name|Value
modifier|*
name|C
parameter_list|)
block|{
return|return
name|cast_or_null
operator|<
name|ConstantAsMetadata
operator|>
operator|(
name|getIfExists
argument_list|(
name|C
argument_list|)
operator|)
return|;
block|}
specifier|static
name|LocalAsMetadata
modifier|*
name|getLocalIfExists
parameter_list|(
name|Value
modifier|*
name|Local
parameter_list|)
block|{
return|return
name|cast_or_null
operator|<
name|LocalAsMetadata
operator|>
operator|(
name|getIfExists
argument_list|(
name|Local
argument_list|)
operator|)
return|;
block|}
name|Value
operator|*
name|getValue
argument_list|()
specifier|const
block|{
return|return
name|V
return|;
block|}
name|Type
operator|*
name|getType
argument_list|()
specifier|const
block|{
return|return
name|V
operator|->
name|getType
argument_list|()
return|;
block|}
name|LLVMContext
operator|&
name|getContext
argument_list|()
specifier|const
block|{
return|return
name|V
operator|->
name|getContext
argument_list|()
return|;
block|}
specifier|static
name|void
name|handleDeletion
parameter_list|(
name|Value
modifier|*
name|V
parameter_list|)
function_decl|;
specifier|static
name|void
name|handleRAUW
parameter_list|(
name|Value
modifier|*
name|From
parameter_list|,
name|Value
modifier|*
name|To
parameter_list|)
function_decl|;
name|protected
label|:
comment|/// \brief Handle collisions after \a Value::replaceAllUsesWith().
comment|///
comment|/// RAUW isn't supported directly for \a ValueAsMetadata, but if the wrapped
comment|/// \a Value gets RAUW'ed and the target already exists, this is used to
comment|/// merge the two metadata nodes.
name|void
name|replaceAllUsesWith
parameter_list|(
name|Metadata
modifier|*
name|MD
parameter_list|)
block|{
name|ReplaceableMetadataImpl
operator|::
name|replaceAllUsesWith
argument_list|(
name|MD
argument_list|)
expr_stmt|;
block|}
name|public
label|:
specifier|static
name|bool
name|classof
parameter_list|(
specifier|const
name|Metadata
modifier|*
name|MD
parameter_list|)
block|{
return|return
name|MD
operator|->
name|getMetadataID
argument_list|()
operator|==
name|LocalAsMetadataKind
operator|||
name|MD
operator|->
name|getMetadataID
argument_list|()
operator|==
name|ConstantAsMetadataKind
return|;
block|}
block|}
empty_stmt|;
name|class
name|ConstantAsMetadata
range|:
name|public
name|ValueAsMetadata
block|{
name|friend
name|class
name|ValueAsMetadata
block|;
name|ConstantAsMetadata
argument_list|(
name|Constant
operator|*
name|C
argument_list|)
operator|:
name|ValueAsMetadata
argument_list|(
argument|ConstantAsMetadataKind
argument_list|,
argument|C
argument_list|)
block|{}
name|public
operator|:
specifier|static
name|ConstantAsMetadata
operator|*
name|get
argument_list|(
argument|Constant *C
argument_list|)
block|{
return|return
name|ValueAsMetadata
operator|::
name|getConstant
argument_list|(
name|C
argument_list|)
return|;
block|}
specifier|static
name|ConstantAsMetadata
operator|*
name|getIfExists
argument_list|(
argument|Constant *C
argument_list|)
block|{
return|return
name|ValueAsMetadata
operator|::
name|getConstantIfExists
argument_list|(
name|C
argument_list|)
return|;
block|}
name|Constant
operator|*
name|getValue
argument_list|()
specifier|const
block|{
return|return
name|cast
operator|<
name|Constant
operator|>
operator|(
name|ValueAsMetadata
operator|::
name|getValue
argument_list|()
operator|)
return|;
block|}
specifier|static
name|bool
name|classof
argument_list|(
argument|const Metadata *MD
argument_list|)
block|{
return|return
name|MD
operator|->
name|getMetadataID
argument_list|()
operator|==
name|ConstantAsMetadataKind
return|;
block|}
expr|}
block|;
name|class
name|LocalAsMetadata
operator|:
name|public
name|ValueAsMetadata
block|{
name|friend
name|class
name|ValueAsMetadata
block|;
name|LocalAsMetadata
argument_list|(
name|Value
operator|*
name|Local
argument_list|)
operator|:
name|ValueAsMetadata
argument_list|(
argument|LocalAsMetadataKind
argument_list|,
argument|Local
argument_list|)
block|{
name|assert
argument_list|(
operator|!
name|isa
operator|<
name|Constant
operator|>
operator|(
name|Local
operator|)
operator|&&
literal|"Expected local value"
argument_list|)
block|;   }
name|public
operator|:
specifier|static
name|LocalAsMetadata
operator|*
name|get
argument_list|(
argument|Value *Local
argument_list|)
block|{
return|return
name|ValueAsMetadata
operator|::
name|getLocal
argument_list|(
name|Local
argument_list|)
return|;
block|}
specifier|static
name|LocalAsMetadata
operator|*
name|getIfExists
argument_list|(
argument|Value *Local
argument_list|)
block|{
return|return
name|ValueAsMetadata
operator|::
name|getLocalIfExists
argument_list|(
name|Local
argument_list|)
return|;
block|}
specifier|static
name|bool
name|classof
argument_list|(
argument|const Metadata *MD
argument_list|)
block|{
return|return
name|MD
operator|->
name|getMetadataID
argument_list|()
operator|==
name|LocalAsMetadataKind
return|;
block|}
expr|}
block|;
comment|/// \brief Transitional API for extracting constants from Metadata.
comment|///
comment|/// This namespace contains transitional functions for metadata that points to
comment|/// \a Constants.
comment|///
comment|/// In prehistory -- when metadata was a subclass of \a Value -- \a MDNode
comment|/// operands could refer to any \a Value.  There's was a lot of code like this:
comment|///
comment|/// \code
comment|///     MDNode *N = ...;
comment|///     auto *CI = dyn_cast<ConstantInt>(N->getOperand(2));
comment|/// \endcode
comment|///
comment|/// Now that \a Value and \a Metadata are in separate hierarchies, maintaining
comment|/// the semantics for \a isa(), \a cast(), \a dyn_cast() (etc.) requires three
comment|/// steps: cast in the \a Metadata hierarchy, extraction of the \a Value, and
comment|/// cast in the \a Value hierarchy.  Besides creating boiler-plate, this
comment|/// requires subtle control flow changes.
comment|///
comment|/// The end-goal is to create a new type of metadata, called (e.g.) \a MDInt,
comment|/// so that metadata can refer to numbers without traversing a bridge to the \a
comment|/// Value hierarchy.  In this final state, the code above would look like this:
comment|///
comment|/// \code
comment|///     MDNode *N = ...;
comment|///     auto *MI = dyn_cast<MDInt>(N->getOperand(2));
comment|/// \endcode
comment|///
comment|/// The API in this namespace supports the transition.  \a MDInt doesn't exist
comment|/// yet, and even once it does, changing each metadata schema to use it is its
comment|/// own mini-project.  In the meantime this API prevents us from introducing
comment|/// complex and bug-prone control flow that will disappear in the end.  In
comment|/// particular, the above code looks like this:
comment|///
comment|/// \code
comment|///     MDNode *N = ...;
comment|///     auto *CI = mdconst::dyn_extract<ConstantInt>(N->getOperand(2));
comment|/// \endcode
comment|///
comment|/// The full set of provided functions includes:
comment|///
comment|///   mdconst::hasa<=> isa
comment|///   mdconst::extract<=> cast
comment|///   mdconst::extract_or_null<=> cast_or_null
comment|///   mdconst::dyn_extract<=> dyn_cast
comment|///   mdconst::dyn_extract_or_null<=> dyn_cast_or_null
comment|///
comment|/// The target of the cast must be a subclass of \a Constant.
name|namespace
name|mdconst
block|{
name|namespace
name|detail
block|{
name|template
operator|<
name|class
name|T
operator|>
name|T
operator|&
name|make
argument_list|()
block|;
name|template
operator|<
name|class
name|T
block|,
name|class
name|Result
operator|>
expr|struct
name|HasDereference
block|{
typedef|typedef
name|char
name|Yes
index|[
literal|1
index|]
typedef|;
typedef|typedef
name|char
name|No
index|[
literal|2
index|]
typedef|;
name|template
operator|<
name|size_t
name|N
operator|>
block|struct
name|SFINAE
block|{}
block|;
name|template
operator|<
name|class
name|U
block|,
name|class
name|V
operator|>
specifier|static
name|Yes
operator|&
name|hasDereference
argument_list|(
name|SFINAE
operator|<
sizeof|sizeof
argument_list|(
name|static_cast
operator|<
name|V
operator|>
operator|(
operator|*
name|make
operator|<
name|U
operator|>
operator|(
operator|)
operator|)
argument_list|)
operator|>
operator|*
operator|=
literal|0
argument_list|)
block|;
name|template
operator|<
name|class
name|U
block|,
name|class
name|V
operator|>
specifier|static
name|No
operator|&
name|hasDereference
argument_list|(
operator|...
argument_list|)
block|;
specifier|static
specifier|const
name|bool
name|value
operator|=
sizeof|sizeof
argument_list|(
name|hasDereference
operator|<
name|T
argument_list|,
name|Result
operator|>
operator|(
name|nullptr
operator|)
argument_list|)
operator|==
sizeof|sizeof
argument_list|(
name|Yes
argument_list|)
block|; }
block|;
name|template
operator|<
name|class
name|V
block|,
name|class
name|M
operator|>
expr|struct
name|IsValidPointer
block|{
specifier|static
specifier|const
name|bool
name|value
operator|=
name|std
operator|::
name|is_base_of
operator|<
name|Constant
block|,
name|V
operator|>
operator|::
name|value
operator|&&
name|HasDereference
operator|<
name|M
block|,
specifier|const
name|Metadata
operator|&
operator|>
operator|::
name|value
block|; }
block|;
name|template
operator|<
name|class
name|V
block|,
name|class
name|M
operator|>
expr|struct
name|IsValidReference
block|{
specifier|static
specifier|const
name|bool
name|value
operator|=
name|std
operator|::
name|is_base_of
operator|<
name|Constant
block|,
name|V
operator|>
operator|::
name|value
operator|&&
name|std
operator|::
name|is_convertible
operator|<
name|M
block|,
specifier|const
name|Metadata
operator|&
operator|>
operator|::
name|value
block|; }
block|; }
comment|// end namespace detail
comment|/// \brief Check whether Metadata has a Value.
comment|///
comment|/// As an analogue to \a isa(), check whether \c MD has an \a Value inside of
comment|/// type \c X.
name|template
operator|<
name|class
name|X
block|,
name|class
name|Y
operator|>
specifier|inline
name|typename
name|std
operator|::
name|enable_if
operator|<
name|detail
operator|::
name|IsValidPointer
operator|<
name|X
block|,
name|Y
operator|>
operator|::
name|value
block|,
name|bool
operator|>
operator|::
name|type
name|hasa
argument_list|(
argument|Y&&MD
argument_list|)
block|{
name|assert
argument_list|(
name|MD
operator|&&
literal|"Null pointer sent into hasa"
argument_list|)
block|;
if|if
condition|(
name|auto
operator|*
name|V
operator|=
name|dyn_cast
operator|<
name|ConstantAsMetadata
operator|>
operator|(
name|MD
operator|)
condition|)
return|return
name|isa
operator|<
name|X
operator|>
operator|(
name|V
operator|->
name|getValue
argument_list|()
operator|)
return|;
return|return
name|false
return|;
block|}
name|template
operator|<
name|class
name|X
operator|,
name|class
name|Y
operator|>
specifier|inline
name|typename
name|std
operator|::
name|enable_if
operator|<
name|detail
operator|::
name|IsValidReference
operator|<
name|X
operator|,
name|Y
operator|&
operator|>
operator|::
name|value
operator|,
name|bool
operator|>
operator|::
name|type
name|hasa
argument_list|(
argument|Y&MD
argument_list|)
block|{
return|return
name|hasa
argument_list|(
operator|&
name|MD
argument_list|)
return|;
block|}
comment|/// \brief Extract a Value from Metadata.
comment|///
comment|/// As an analogue to \a cast(), extract the \a Value subclass \c X from \c MD.
name|template
operator|<
name|class
name|X
operator|,
name|class
name|Y
operator|>
specifier|inline
name|typename
name|std
operator|::
name|enable_if
operator|<
name|detail
operator|::
name|IsValidPointer
operator|<
name|X
operator|,
name|Y
operator|>
operator|::
name|value
operator|,
name|X
operator|*
operator|>
operator|::
name|type
name|extract
argument_list|(
argument|Y&&MD
argument_list|)
block|{
return|return
name|cast
operator|<
name|X
operator|>
operator|(
name|cast
operator|<
name|ConstantAsMetadata
operator|>
operator|(
name|MD
operator|)
operator|->
name|getValue
argument_list|()
operator|)
return|;
block|}
name|template
operator|<
name|class
name|X
operator|,
name|class
name|Y
operator|>
specifier|inline
name|typename
name|std
operator|::
name|enable_if
operator|<
name|detail
operator|::
name|IsValidReference
operator|<
name|X
operator|,
name|Y
operator|&
operator|>
operator|::
name|value
operator|,
name|X
operator|*
operator|>
operator|::
name|type
name|extract
argument_list|(
argument|Y&MD
argument_list|)
block|{
return|return
name|extract
argument_list|(
operator|&
name|MD
argument_list|)
return|;
block|}
comment|/// \brief Extract a Value from Metadata, allowing null.
comment|///
comment|/// As an analogue to \a cast_or_null(), extract the \a Value subclass \c X
comment|/// from \c MD, allowing \c MD to be null.
name|template
operator|<
name|class
name|X
operator|,
name|class
name|Y
operator|>
specifier|inline
name|typename
name|std
operator|::
name|enable_if
operator|<
name|detail
operator|::
name|IsValidPointer
operator|<
name|X
operator|,
name|Y
operator|>
operator|::
name|value
operator|,
name|X
operator|*
operator|>
operator|::
name|type
name|extract_or_null
argument_list|(
argument|Y&&MD
argument_list|)
block|{
if|if
condition|(
name|auto
operator|*
name|V
operator|=
name|cast_or_null
operator|<
name|ConstantAsMetadata
operator|>
operator|(
name|MD
operator|)
condition|)
return|return
name|cast
operator|<
name|X
operator|>
operator|(
name|V
operator|->
name|getValue
argument_list|()
operator|)
return|;
return|return
name|nullptr
return|;
block|}
end_decl_stmt

begin_comment
comment|/// \brief Extract a Value from Metadata, if any.
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|/// As an analogue to \a dyn_cast_or_null(), extract the \a Value subclass \c X
end_comment

begin_comment
comment|/// from \c MD, return null if \c MD doesn't contain a \a Value or if the \a
end_comment

begin_comment
comment|/// Value it does contain is of the wrong subclass.
end_comment

begin_expr_stmt
name|template
operator|<
name|class
name|X
operator|,
name|class
name|Y
operator|>
specifier|inline
name|typename
name|std
operator|::
name|enable_if
operator|<
name|detail
operator|::
name|IsValidPointer
operator|<
name|X
operator|,
name|Y
operator|>
operator|::
name|value
operator|,
name|X
operator|*
operator|>
operator|::
name|type
name|dyn_extract
argument_list|(
argument|Y&&MD
argument_list|)
block|{
if|if
condition|(
name|auto
operator|*
name|V
operator|=
name|dyn_cast
operator|<
name|ConstantAsMetadata
operator|>
operator|(
name|MD
operator|)
condition|)
return|return
name|dyn_cast
operator|<
name|X
operator|>
operator|(
name|V
operator|->
name|getValue
argument_list|()
operator|)
return|;
end_expr_stmt

begin_return
return|return
name|nullptr
return|;
end_return

begin_comment
unit|}
comment|/// \brief Extract a Value from Metadata, if any, allowing null.
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|/// As an analogue to \a dyn_cast_or_null(), extract the \a Value subclass \c X
end_comment

begin_comment
comment|/// from \c MD, return null if \c MD doesn't contain a \a Value or if the \a
end_comment

begin_comment
comment|/// Value it does contain is of the wrong subclass, allowing \c MD to be null.
end_comment

begin_expr_stmt
unit|template
operator|<
name|class
name|X
operator|,
name|class
name|Y
operator|>
specifier|inline
name|typename
name|std
operator|::
name|enable_if
operator|<
name|detail
operator|::
name|IsValidPointer
operator|<
name|X
operator|,
name|Y
operator|>
operator|::
name|value
operator|,
name|X
operator|*
operator|>
operator|::
name|type
name|dyn_extract_or_null
argument_list|(
argument|Y&&MD
argument_list|)
block|{
if|if
condition|(
name|auto
operator|*
name|V
operator|=
name|dyn_cast_or_null
operator|<
name|ConstantAsMetadata
operator|>
operator|(
name|MD
operator|)
condition|)
return|return
name|dyn_cast
operator|<
name|X
operator|>
operator|(
name|V
operator|->
name|getValue
argument_list|()
operator|)
return|;
end_expr_stmt

begin_return
return|return
name|nullptr
return|;
end_return

begin_comment
unit|}  }
comment|// end namespace mdconst
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|/// \brief A single uniqued string.
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|/// These are used to efficiently contain a byte sequence for metadata.
end_comment

begin_comment
comment|/// MDString is always unnamed.
end_comment

begin_decl_stmt
name|class
name|MDString
range|:
name|public
name|Metadata
block|{
name|friend
name|class
name|StringMapEntry
operator|<
name|MDString
operator|>
block|;
name|MDString
argument_list|(
argument|const MDString&
argument_list|)
name|LLVM_DELETED_FUNCTION
block|;
name|MDString
operator|&
name|operator
operator|=
operator|(
name|MDString
operator|&&
operator|)
name|LLVM_DELETED_FUNCTION
block|;
name|MDString
operator|&
name|operator
operator|=
operator|(
specifier|const
name|MDString
operator|&
operator|)
name|LLVM_DELETED_FUNCTION
block|;
name|StringMapEntry
operator|<
name|MDString
operator|>
operator|*
name|Entry
block|;
name|MDString
argument_list|()
operator|:
name|Metadata
argument_list|(
name|MDStringKind
argument_list|)
block|,
name|Entry
argument_list|(
argument|nullptr
argument_list|)
block|{}
name|MDString
argument_list|(
name|MDString
operator|&&
argument_list|)
operator|:
name|Metadata
argument_list|(
argument|MDStringKind
argument_list|)
block|{}
name|public
operator|:
specifier|static
name|MDString
operator|*
name|get
argument_list|(
argument|LLVMContext&Context
argument_list|,
argument|StringRef Str
argument_list|)
block|;
specifier|static
name|MDString
operator|*
name|get
argument_list|(
argument|LLVMContext&Context
argument_list|,
argument|const char *Str
argument_list|)
block|{
return|return
name|get
argument_list|(
name|Context
argument_list|,
name|Str
operator|?
name|StringRef
argument_list|(
name|Str
argument_list|)
operator|:
name|StringRef
argument_list|()
argument_list|)
return|;
block|}
name|StringRef
name|getString
argument_list|()
specifier|const
block|;
name|unsigned
name|getLength
argument_list|()
specifier|const
block|{
return|return
operator|(
name|unsigned
operator|)
name|getString
argument_list|()
operator|.
name|size
argument_list|()
return|;
block|}
typedef|typedef
name|StringRef
operator|::
name|iterator
name|iterator
expr_stmt|;
comment|/// \brief Pointer to the first byte of the string.
name|iterator
name|begin
argument_list|()
specifier|const
block|{
return|return
name|getString
argument_list|()
operator|.
name|begin
argument_list|()
return|;
block|}
comment|/// \brief Pointer to one byte past the end of the string.
name|iterator
name|end
argument_list|()
specifier|const
block|{
return|return
name|getString
argument_list|()
operator|.
name|end
argument_list|()
return|;
block|}
specifier|const
name|unsigned
name|char
operator|*
name|bytes_begin
argument_list|()
specifier|const
block|{
return|return
name|getString
argument_list|()
operator|.
name|bytes_begin
argument_list|()
return|;
block|}
specifier|const
name|unsigned
name|char
operator|*
name|bytes_end
argument_list|()
specifier|const
block|{
return|return
name|getString
argument_list|()
operator|.
name|bytes_end
argument_list|()
return|;
block|}
comment|/// \brief Methods for support type inquiry through isa, cast, and dyn_cast.
specifier|static
name|bool
name|classof
argument_list|(
argument|const Metadata *MD
argument_list|)
block|{
return|return
name|MD
operator|->
name|getMetadataID
argument_list|()
operator|==
name|MDStringKind
return|;
block|}
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_comment
comment|/// \brief A collection of metadata nodes that might be associated with a
end_comment

begin_comment
comment|/// memory access used by the alias-analysis infrastructure.
end_comment

begin_struct
struct|struct
name|AAMDNodes
block|{
name|explicit
name|AAMDNodes
argument_list|(
name|MDNode
operator|*
name|T
operator|=
name|nullptr
argument_list|,
name|MDNode
operator|*
name|S
operator|=
name|nullptr
argument_list|,
name|MDNode
operator|*
name|N
operator|=
name|nullptr
argument_list|)
operator|:
name|TBAA
argument_list|(
name|T
argument_list|)
operator|,
name|Scope
argument_list|(
name|S
argument_list|)
operator|,
name|NoAlias
argument_list|(
argument|N
argument_list|)
block|{}
name|bool
name|operator
operator|==
operator|(
specifier|const
name|AAMDNodes
operator|&
name|A
operator|)
specifier|const
block|{
return|return
name|TBAA
operator|==
name|A
operator|.
name|TBAA
operator|&&
name|Scope
operator|==
name|A
operator|.
name|Scope
operator|&&
name|NoAlias
operator|==
name|A
operator|.
name|NoAlias
return|;
block|}
name|bool
name|operator
operator|!=
operator|(
specifier|const
name|AAMDNodes
operator|&
name|A
operator|)
specifier|const
block|{
return|return
operator|!
operator|(
operator|*
name|this
operator|==
name|A
operator|)
return|;
block|}
name|LLVM_EXPLICIT
name|operator
name|bool
argument_list|()
specifier|const
block|{
return|return
name|TBAA
operator|||
name|Scope
operator|||
name|NoAlias
return|;
block|}
comment|/// \brief The tag for type-based alias analysis.
name|MDNode
modifier|*
name|TBAA
decl_stmt|;
comment|/// \brief The tag for alias scope specification (used with noalias).
name|MDNode
modifier|*
name|Scope
decl_stmt|;
comment|/// \brief The tag specifying the noalias scope.
name|MDNode
modifier|*
name|NoAlias
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|// Specialize DenseMapInfo for AAMDNodes.
end_comment

begin_expr_stmt
name|template
operator|<
operator|>
expr|struct
name|DenseMapInfo
operator|<
name|AAMDNodes
operator|>
block|{
specifier|static
specifier|inline
name|AAMDNodes
name|getEmptyKey
argument_list|()
block|{
return|return
name|AAMDNodes
argument_list|(
name|DenseMapInfo
operator|<
name|MDNode
operator|*
operator|>
operator|::
name|getEmptyKey
argument_list|()
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
return|;
block|}
specifier|static
specifier|inline
name|AAMDNodes
name|getTombstoneKey
argument_list|()
block|{
return|return
name|AAMDNodes
argument_list|(
name|DenseMapInfo
operator|<
name|MDNode
operator|*
operator|>
operator|::
name|getTombstoneKey
argument_list|()
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_expr_stmt

begin_function
specifier|static
name|unsigned
name|getHashValue
parameter_list|(
specifier|const
name|AAMDNodes
modifier|&
name|Val
parameter_list|)
block|{
return|return
name|DenseMapInfo
operator|<
name|MDNode
operator|*
operator|>
operator|::
name|getHashValue
argument_list|(
name|Val
operator|.
name|TBAA
argument_list|)
operator|^
name|DenseMapInfo
operator|<
name|MDNode
operator|*
operator|>
operator|::
name|getHashValue
argument_list|(
name|Val
operator|.
name|Scope
argument_list|)
operator|^
name|DenseMapInfo
operator|<
name|MDNode
operator|*
operator|>
operator|::
name|getHashValue
argument_list|(
name|Val
operator|.
name|NoAlias
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|isEqual
parameter_list|(
specifier|const
name|AAMDNodes
modifier|&
name|LHS
parameter_list|,
specifier|const
name|AAMDNodes
modifier|&
name|RHS
parameter_list|)
block|{
return|return
name|LHS
operator|==
name|RHS
return|;
block|}
end_function

begin_comment
unit|};
comment|/// \brief Tracking metadata reference owned by Metadata.
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|/// Similar to \a TrackingMDRef, but it's expected to be owned by an instance
end_comment

begin_comment
comment|/// of \a Metadata, which has the option of registering itself for callbacks to
end_comment

begin_comment
comment|/// re-unique itself.
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|/// In particular, this is used by \a MDNode.
end_comment

begin_decl_stmt
name|class
name|MDOperand
block|{
name|MDOperand
argument_list|(
argument|MDOperand&&
argument_list|)
name|LLVM_DELETED_FUNCTION
expr_stmt|;
name|MDOperand
argument_list|(
argument|const MDOperand&
argument_list|)
name|LLVM_DELETED_FUNCTION
expr_stmt|;
name|MDOperand
modifier|&
name|operator
init|=
operator|(
name|MDOperand
operator|&&
operator|)
name|LLVM_DELETED_FUNCTION
decl_stmt|;
name|MDOperand
modifier|&
name|operator
init|=
operator|(
specifier|const
name|MDOperand
operator|&
operator|)
name|LLVM_DELETED_FUNCTION
decl_stmt|;
name|Metadata
modifier|*
name|MD
decl_stmt|;
name|public
label|:
name|MDOperand
argument_list|()
operator|:
name|MD
argument_list|(
argument|nullptr
argument_list|)
block|{}
operator|~
name|MDOperand
argument_list|()
block|{
name|untrack
argument_list|()
block|; }
name|Metadata
operator|*
name|get
argument_list|()
specifier|const
block|{
return|return
name|MD
return|;
block|}
name|operator
name|Metadata
operator|*
operator|(
operator|)
specifier|const
block|{
return|return
name|get
argument_list|()
return|;
block|}
name|Metadata
operator|*
name|operator
operator|->
expr|(
block|)
decl|const
block|{
return|return
name|get
argument_list|()
return|;
block|}
end_decl_stmt

begin_expr_stmt
name|Metadata
operator|&
name|operator
operator|*
operator|(
operator|)
specifier|const
block|{
return|return
operator|*
name|get
argument_list|()
return|;
block|}
end_expr_stmt

begin_function
name|void
name|reset
parameter_list|()
block|{
name|untrack
argument_list|()
expr_stmt|;
name|MD
operator|=
name|nullptr
expr_stmt|;
block|}
end_function

begin_function
name|void
name|reset
parameter_list|(
name|Metadata
modifier|*
name|MD
parameter_list|,
name|Metadata
modifier|*
name|Owner
parameter_list|)
block|{
name|untrack
argument_list|()
expr_stmt|;
name|this
operator|->
name|MD
operator|=
name|MD
expr_stmt|;
name|track
argument_list|(
name|Owner
argument_list|)
expr_stmt|;
block|}
end_function

begin_label
name|private
label|:
end_label

begin_function
name|void
name|track
parameter_list|(
name|Metadata
modifier|*
name|Owner
parameter_list|)
block|{
if|if
condition|(
name|MD
condition|)
block|{
if|if
condition|(
name|Owner
condition|)
name|MetadataTracking
operator|::
name|track
argument_list|(
name|this
argument_list|,
operator|*
name|MD
argument_list|,
operator|*
name|Owner
argument_list|)
expr_stmt|;
else|else
name|MetadataTracking
operator|::
name|track
argument_list|(
name|MD
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|untrack
parameter_list|()
block|{
name|assert
argument_list|(
name|static_cast
operator|<
name|void
operator|*
operator|>
operator|(
name|this
operator|)
operator|==
operator|&
name|MD
operator|&&
literal|"Expected same address"
argument_list|)
expr_stmt|;
if|if
condition|(
name|MD
condition|)
name|MetadataTracking
operator|::
name|untrack
argument_list|(
name|MD
argument_list|)
expr_stmt|;
block|}
end_function

begin_expr_stmt
unit|};
name|template
operator|<
operator|>
expr|struct
name|simplify_type
operator|<
name|MDOperand
operator|>
block|{
typedef|typedef
name|Metadata
modifier|*
name|SimpleType
typedef|;
specifier|static
name|SimpleType
name|getSimplifiedValue
argument_list|(
argument|MDOperand&MD
argument_list|)
block|{
return|return
name|MD
operator|.
name|get
argument_list|()
return|;
block|}
block|}
end_expr_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_expr_stmt
name|template
operator|<
operator|>
expr|struct
name|simplify_type
operator|<
specifier|const
name|MDOperand
operator|>
block|{
typedef|typedef
name|Metadata
modifier|*
name|SimpleType
typedef|;
specifier|static
name|SimpleType
name|getSimplifiedValue
argument_list|(
argument|const MDOperand&MD
argument_list|)
block|{
return|return
name|MD
operator|.
name|get
argument_list|()
return|;
block|}
block|}
end_expr_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|/// \brief Tuple of metadata.
end_comment

begin_decl_stmt
name|class
name|MDNode
range|:
name|public
name|Metadata
block|{
name|MDNode
argument_list|(
argument|const MDNode&
argument_list|)
name|LLVM_DELETED_FUNCTION
block|;
name|void
name|operator
operator|=
operator|(
specifier|const
name|MDNode
operator|&
operator|)
name|LLVM_DELETED_FUNCTION
block|;
name|void
operator|*
name|operator
name|new
argument_list|(
argument|size_t
argument_list|)
name|LLVM_DELETED_FUNCTION
block|;
name|LLVMContext
operator|&
name|Context
block|;
name|unsigned
name|NumOperands
block|;
name|protected
operator|:
name|unsigned
name|MDNodeSubclassData
block|;
name|void
operator|*
name|operator
name|new
argument_list|(
argument|size_t Size
argument_list|,
argument|unsigned NumOps
argument_list|)
block|;
name|void
name|operator
name|delete
argument_list|(
name|void
operator|*
name|Mem
argument_list|)
block|;
comment|/// \brief Required by std, but never called.
name|void
name|operator
name|delete
argument_list|(
argument|void *
argument_list|,
argument|unsigned
argument_list|)
block|{
name|llvm_unreachable
argument_list|(
literal|"Constructor throws?"
argument_list|)
block|;   }
comment|/// \brief Required by std, but never called.
name|void
name|operator
name|delete
argument_list|(
argument|void *
argument_list|,
argument|unsigned
argument_list|,
argument|bool
argument_list|)
block|{
name|llvm_unreachable
argument_list|(
literal|"Constructor throws?"
argument_list|)
block|;   }
name|MDNode
argument_list|(
argument|LLVMContext&Context
argument_list|,
argument|unsigned ID
argument_list|,
argument|ArrayRef<Metadata *> MDs
argument_list|)
block|;
operator|~
name|MDNode
argument_list|()
block|{}
name|void
name|dropAllReferences
argument_list|()
block|;
name|MDOperand
operator|*
name|mutable_begin
argument_list|()
block|{
return|return
name|mutable_end
argument_list|()
operator|-
name|NumOperands
return|;
block|}
name|MDOperand
operator|*
name|mutable_end
argument_list|()
block|{
return|return
name|reinterpret_cast
operator|<
name|MDOperand
operator|*
operator|>
operator|(
name|this
operator|)
return|;
block|}
name|public
operator|:
specifier|static
specifier|inline
name|MDNode
operator|*
name|get
argument_list|(
name|LLVMContext
operator|&
name|Context
argument_list|,
name|ArrayRef
operator|<
name|Metadata
operator|*
operator|>
name|MDs
argument_list|)
block|;
specifier|static
specifier|inline
name|MDNode
operator|*
name|getIfExists
argument_list|(
name|LLVMContext
operator|&
name|Context
argument_list|,
name|ArrayRef
operator|<
name|Metadata
operator|*
operator|>
name|MDs
argument_list|)
block|;
specifier|static
specifier|inline
name|MDNode
operator|*
name|getDistinct
argument_list|(
name|LLVMContext
operator|&
name|Context
argument_list|,
name|ArrayRef
operator|<
name|Metadata
operator|*
operator|>
name|MDs
argument_list|)
block|;
comment|/// \brief Return a temporary MDNode
comment|///
comment|/// For use in constructing cyclic MDNode structures. A temporary MDNode is
comment|/// not uniqued, may be RAUW'd, and must be manually deleted with
comment|/// deleteTemporary.
specifier|static
name|MDNodeFwdDecl
operator|*
name|getTemporary
argument_list|(
name|LLVMContext
operator|&
name|Context
argument_list|,
name|ArrayRef
operator|<
name|Metadata
operator|*
operator|>
name|MDs
argument_list|)
block|;
comment|/// \brief Deallocate a node created by getTemporary.
comment|///
comment|/// The node must not have any users.
specifier|static
name|void
name|deleteTemporary
argument_list|(
name|MDNode
operator|*
name|N
argument_list|)
block|;
name|LLVMContext
operator|&
name|getContext
argument_list|()
specifier|const
block|{
return|return
name|Context
return|;
block|}
comment|/// \brief Replace a specific operand.
name|void
name|replaceOperandWith
argument_list|(
argument|unsigned I
argument_list|,
argument|Metadata *New
argument_list|)
block|;
comment|/// \brief Check if node is fully resolved.
name|bool
name|isResolved
argument_list|()
specifier|const
block|;
comment|/// \brief Check if node is distinct.
comment|///
comment|/// Distinct nodes are not uniqued, and will not be returned by \a
comment|/// MDNode::get().
name|bool
name|isDistinct
argument_list|()
specifier|const
block|{
return|return
name|isStoredDistinctInContext
argument_list|()
operator|||
name|isa
operator|<
name|MDNodeFwdDecl
operator|>
operator|(
name|this
operator|)
return|;
block|}
name|protected
operator|:
comment|/// \brief Set an operand.
comment|///
comment|/// Sets the operand directly, without worrying about uniquing.
name|void
name|setOperand
argument_list|(
argument|unsigned I
argument_list|,
argument|Metadata *New
argument_list|)
block|;
name|public
operator|:
typedef|typedef
specifier|const
name|MDOperand
modifier|*
name|op_iterator
typedef|;
end_decl_stmt

begin_typedef
typedef|typedef
name|iterator_range
operator|<
name|op_iterator
operator|>
name|op_range
expr_stmt|;
end_typedef

begin_expr_stmt
name|op_iterator
name|op_begin
argument_list|()
specifier|const
block|{
return|return
name|const_cast
operator|<
name|MDNode
operator|*
operator|>
operator|(
name|this
operator|)
operator|->
name|mutable_begin
argument_list|()
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|op_iterator
name|op_end
argument_list|()
specifier|const
block|{
return|return
name|const_cast
operator|<
name|MDNode
operator|*
operator|>
operator|(
name|this
operator|)
operator|->
name|mutable_end
argument_list|()
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|op_range
name|operands
argument_list|()
specifier|const
block|{
return|return
name|op_range
argument_list|(
name|op_begin
argument_list|()
argument_list|,
name|op_end
argument_list|()
argument_list|)
return|;
block|}
end_expr_stmt

begin_decl_stmt
specifier|const
name|MDOperand
modifier|&
name|getOperand
argument_list|(
name|unsigned
name|I
argument_list|)
decl|const
block|{
name|assert
argument_list|(
name|I
operator|<
name|NumOperands
operator|&&
literal|"Out of range"
argument_list|)
expr_stmt|;
return|return
name|op_begin
argument_list|()
index|[
name|I
index|]
return|;
block|}
end_decl_stmt

begin_comment
comment|/// \brief Return number of MDNode operands.
end_comment

begin_expr_stmt
name|unsigned
name|getNumOperands
argument_list|()
specifier|const
block|{
return|return
name|NumOperands
return|;
block|}
end_expr_stmt

begin_comment
comment|/// \brief Methods for support type inquiry through isa, cast, and dyn_cast:
end_comment

begin_function
specifier|static
name|bool
name|classof
parameter_list|(
specifier|const
name|Metadata
modifier|*
name|MD
parameter_list|)
block|{
return|return
name|MD
operator|->
name|getMetadataID
argument_list|()
operator|==
name|MDTupleKind
operator|||
name|MD
operator|->
name|getMetadataID
argument_list|()
operator|==
name|MDLocationKind
operator|||
name|MD
operator|->
name|getMetadataID
argument_list|()
operator|==
name|MDNodeFwdDeclKind
return|;
block|}
end_function

begin_comment
comment|/// \brief Check whether MDNode is a vtable access.
end_comment

begin_expr_stmt
name|bool
name|isTBAAVtableAccess
argument_list|()
specifier|const
expr_stmt|;
end_expr_stmt

begin_comment
comment|/// \brief Methods for metadata merging.
end_comment

begin_function_decl
specifier|static
name|MDNode
modifier|*
name|concatenate
parameter_list|(
name|MDNode
modifier|*
name|A
parameter_list|,
name|MDNode
modifier|*
name|B
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|MDNode
modifier|*
name|intersect
parameter_list|(
name|MDNode
modifier|*
name|A
parameter_list|,
name|MDNode
modifier|*
name|B
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|MDNode
modifier|*
name|getMostGenericTBAA
parameter_list|(
name|MDNode
modifier|*
name|A
parameter_list|,
name|MDNode
modifier|*
name|B
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|AAMDNodes
name|getMostGenericAA
parameter_list|(
specifier|const
name|AAMDNodes
modifier|&
name|A
parameter_list|,
specifier|const
name|AAMDNodes
modifier|&
name|B
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|MDNode
modifier|*
name|getMostGenericFPMath
parameter_list|(
name|MDNode
modifier|*
name|A
parameter_list|,
name|MDNode
modifier|*
name|B
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|MDNode
modifier|*
name|getMostGenericRange
parameter_list|(
name|MDNode
modifier|*
name|A
parameter_list|,
name|MDNode
modifier|*
name|B
parameter_list|)
function_decl|;
end_function_decl

begin_comment
unit|};
comment|/// \brief Uniquable metadata node.
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|/// A uniquable metadata node.  This contains the basic functionality
end_comment

begin_comment
comment|/// for implementing sub-types of \a MDNode that can be uniqued like
end_comment

begin_comment
comment|/// constants.
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|/// There is limited support for RAUW at construction time.  At
end_comment

begin_comment
comment|/// construction time, if any operands are an instance of \a
end_comment

begin_comment
comment|/// MDNodeFwdDecl (or another unresolved \a UniquableMDNode, which
end_comment

begin_comment
comment|/// indicates an \a MDNodeFwdDecl in its path), the node itself will be
end_comment

begin_comment
comment|/// unresolved.  As soon as all operands become resolved, it will drop
end_comment

begin_comment
comment|/// RAUW support permanently.
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|/// If an unresolved node is part of a cycle, \a resolveCycles() needs
end_comment

begin_comment
comment|/// to be called on some member of the cycle when each \a MDNodeFwdDecl
end_comment

begin_comment
comment|/// has been removed.
end_comment

begin_decl_stmt
name|class
name|UniquableMDNode
range|:
name|public
name|MDNode
block|{
name|friend
name|class
name|ReplaceableMetadataImpl
block|;
name|friend
name|class
name|MDNode
block|;
name|friend
name|class
name|LLVMContextImpl
block|;
comment|/// \brief Support RAUW as long as one of its arguments is replaceable.
comment|///
comment|/// FIXME: Save memory by storing this in a pointer union with the
comment|/// LLVMContext, and adding an LLVMContext reference to RMI.
name|std
operator|::
name|unique_ptr
operator|<
name|ReplaceableMetadataImpl
operator|>
name|ReplaceableUses
block|;
name|protected
operator|:
comment|/// \brief Create a new node.
comment|///
comment|/// If \c AllowRAUW, then if any operands are unresolved support RAUW.  RAUW
comment|/// will be dropped once all operands have been resolved (or if \a
comment|/// resolveCycles() is called).
name|UniquableMDNode
argument_list|(
argument|LLVMContext&C
argument_list|,
argument|unsigned ID
argument_list|,
argument|ArrayRef<Metadata *> Vals
argument_list|,
argument|bool AllowRAUW
argument_list|)
block|;
operator|~
name|UniquableMDNode
argument_list|()
block|{}
name|void
name|storeDistinctInContext
argument_list|()
block|;
name|public
operator|:
specifier|static
name|bool
name|classof
argument_list|(
argument|const Metadata *MD
argument_list|)
block|{
return|return
name|MD
operator|->
name|getMetadataID
argument_list|()
operator|==
name|MDTupleKind
operator|||
name|MD
operator|->
name|getMetadataID
argument_list|()
operator|==
name|MDLocationKind
return|;
block|}
comment|/// \brief Check whether any operands are forward declarations.
comment|///
comment|/// Returns \c true as long as any operands (or their operands, etc.) are \a
comment|/// MDNodeFwdDecl.
comment|///
comment|/// As forward declarations are resolved, their containers should get
comment|/// resolved automatically.  However, if this (or one of its operands) is
comment|/// involved in a cycle, \a resolveCycles() needs to be called explicitly.
name|bool
name|isResolved
argument_list|()
specifier|const
block|{
return|return
operator|!
name|ReplaceableUses
return|;
block|}
comment|/// \brief Resolve cycles.
comment|///
comment|/// Once all forward declarations have been resolved, force cycles to be
comment|/// resolved.
comment|///
comment|/// \pre No operands (or operands' operands, etc.) are \a MDNodeFwdDecl.
name|void
name|resolveCycles
argument_list|()
block|;
name|private
operator|:
name|void
name|handleChangedOperand
argument_list|(
name|void
operator|*
name|Ref
argument_list|,
name|Metadata
operator|*
name|New
argument_list|)
block|;
name|void
name|resolve
argument_list|()
block|;
name|void
name|resolveAfterOperandChange
argument_list|(
name|Metadata
operator|*
name|Old
argument_list|,
name|Metadata
operator|*
name|New
argument_list|)
block|;
name|void
name|decrementUnresolvedOperandCount
argument_list|()
block|;
name|void
name|deleteAsSubclass
argument_list|()
block|;
name|UniquableMDNode
operator|*
name|uniquify
argument_list|()
block|;
name|void
name|eraseFromStore
argument_list|()
block|; }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/// \brief Tuple of metadata.
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|/// This is the simple \a MDNode arbitrary tuple.  Nodes are uniqued by
end_comment

begin_comment
comment|/// default based on their operands.
end_comment

begin_decl_stmt
name|class
name|MDTuple
range|:
name|public
name|UniquableMDNode
block|{
name|friend
name|class
name|LLVMContextImpl
block|;
name|friend
name|class
name|UniquableMDNode
block|;
name|MDTuple
argument_list|(
argument|LLVMContext&C
argument_list|,
argument|ArrayRef<Metadata *> Vals
argument_list|,
argument|bool AllowRAUW
argument_list|)
operator|:
name|UniquableMDNode
argument_list|(
argument|C
argument_list|,
argument|MDTupleKind
argument_list|,
argument|Vals
argument_list|,
argument|AllowRAUW
argument_list|)
block|{}
operator|~
name|MDTuple
argument_list|()
block|{
name|dropAllReferences
argument_list|()
block|; }
name|void
name|setHash
argument_list|(
argument|unsigned Hash
argument_list|)
block|{
name|MDNodeSubclassData
operator|=
name|Hash
block|; }
name|void
name|recalculateHash
argument_list|()
block|;
specifier|static
name|MDTuple
operator|*
name|getImpl
argument_list|(
argument|LLVMContext&Context
argument_list|,
argument|ArrayRef<Metadata *> MDs
argument_list|,
argument|bool ShouldCreate
argument_list|)
block|;
name|public
operator|:
comment|/// \brief Get the hash, if any.
name|unsigned
name|getHash
argument_list|()
specifier|const
block|{
return|return
name|MDNodeSubclassData
return|;
block|}
specifier|static
name|MDTuple
operator|*
name|get
argument_list|(
argument|LLVMContext&Context
argument_list|,
argument|ArrayRef<Metadata *> MDs
argument_list|)
block|{
return|return
name|getImpl
argument_list|(
name|Context
argument_list|,
name|MDs
argument_list|,
comment|/* ShouldCreate */
name|true
argument_list|)
return|;
block|}
specifier|static
name|MDTuple
operator|*
name|getIfExists
argument_list|(
argument|LLVMContext&Context
argument_list|,
argument|ArrayRef<Metadata *> MDs
argument_list|)
block|{
return|return
name|getImpl
argument_list|(
name|Context
argument_list|,
name|MDs
argument_list|,
comment|/* ShouldCreate */
name|false
argument_list|)
return|;
block|}
comment|/// \brief Return a distinct node.
comment|///
comment|/// Return a distinct node -- i.e., a node that is not uniqued.
specifier|static
name|MDTuple
operator|*
name|getDistinct
argument_list|(
name|LLVMContext
operator|&
name|Context
argument_list|,
name|ArrayRef
operator|<
name|Metadata
operator|*
operator|>
name|MDs
argument_list|)
block|;
specifier|static
name|bool
name|classof
argument_list|(
argument|const Metadata *MD
argument_list|)
block|{
return|return
name|MD
operator|->
name|getMetadataID
argument_list|()
operator|==
name|MDTupleKind
return|;
block|}
name|private
operator|:
name|MDTuple
operator|*
name|uniquifyImpl
argument_list|()
block|;
name|void
name|eraseFromStoreImpl
argument_list|()
block|; }
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|MDNode
operator|*
name|MDNode
operator|::
name|get
argument_list|(
argument|LLVMContext&Context
argument_list|,
argument|ArrayRef<Metadata *> MDs
argument_list|)
block|{
return|return
name|MDTuple
operator|::
name|get
argument_list|(
name|Context
argument_list|,
name|MDs
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|MDNode
operator|*
name|MDNode
operator|::
name|getIfExists
argument_list|(
argument|LLVMContext&Context
argument_list|,
argument|ArrayRef<Metadata *> MDs
argument_list|)
block|{
return|return
name|MDTuple
operator|::
name|getIfExists
argument_list|(
name|Context
argument_list|,
name|MDs
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|MDNode
operator|*
name|MDNode
operator|::
name|getDistinct
argument_list|(
argument|LLVMContext&Context
argument_list|,
argument|ArrayRef<Metadata *> MDs
argument_list|)
block|{
return|return
name|MDTuple
operator|::
name|getDistinct
argument_list|(
name|Context
argument_list|,
name|MDs
argument_list|)
return|;
block|}
end_expr_stmt

begin_comment
comment|/// \brief Debug location.
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|/// A debug location in source code, used for debug info and otherwise.
end_comment

begin_decl_stmt
name|class
name|MDLocation
range|:
name|public
name|UniquableMDNode
block|{
name|friend
name|class
name|LLVMContextImpl
block|;
name|friend
name|class
name|UniquableMDNode
block|;
name|MDLocation
argument_list|(
argument|LLVMContext&C
argument_list|,
argument|unsigned Line
argument_list|,
argument|unsigned Column
argument_list|,
argument|ArrayRef<Metadata *> MDs
argument_list|,
argument|bool AllowRAUW
argument_list|)
block|;
operator|~
name|MDLocation
argument_list|()
block|{
name|dropAllReferences
argument_list|()
block|; }
specifier|static
name|MDLocation
operator|*
name|constructHelper
argument_list|(
argument|LLVMContext&Context
argument_list|,
argument|unsigned Line
argument_list|,
argument|unsigned Column
argument_list|,
argument|Metadata *Scope
argument_list|,
argument|Metadata *InlinedAt
argument_list|,
argument|bool AllowRAUW
argument_list|)
block|;
specifier|static
name|MDLocation
operator|*
name|getImpl
argument_list|(
argument|LLVMContext&Context
argument_list|,
argument|unsigned Line
argument_list|,
argument|unsigned Column
argument_list|,
argument|Metadata *Scope
argument_list|,
argument|Metadata *InlinedAt
argument_list|,
argument|bool ShouldCreate
argument_list|)
block|;
comment|// Disallow replacing operands.
name|void
name|replaceOperandWith
argument_list|(
argument|unsigned I
argument_list|,
argument|Metadata *New
argument_list|)
name|LLVM_DELETED_FUNCTION
block|;
name|public
operator|:
specifier|static
name|MDLocation
operator|*
name|get
argument_list|(
argument|LLVMContext&Context
argument_list|,
argument|unsigned Line
argument_list|,
argument|unsigned Column
argument_list|,
argument|Metadata *Scope
argument_list|,
argument|Metadata *InlinedAt = nullptr
argument_list|)
block|{
return|return
name|getImpl
argument_list|(
name|Context
argument_list|,
name|Line
argument_list|,
name|Column
argument_list|,
name|Scope
argument_list|,
name|InlinedAt
argument_list|,
comment|/* ShouldCreate */
name|true
argument_list|)
return|;
block|}
specifier|static
name|MDLocation
operator|*
name|getIfExists
argument_list|(
argument|LLVMContext&Context
argument_list|,
argument|unsigned Line
argument_list|,
argument|unsigned Column
argument_list|,
argument|Metadata *Scope
argument_list|,
argument|Metadata *InlinedAt = nullptr
argument_list|)
block|{
return|return
name|getImpl
argument_list|(
name|Context
argument_list|,
name|Line
argument_list|,
name|Column
argument_list|,
name|Scope
argument_list|,
name|InlinedAt
argument_list|,
comment|/* ShouldCreate */
name|false
argument_list|)
return|;
block|}
specifier|static
name|MDLocation
operator|*
name|getDistinct
argument_list|(
argument|LLVMContext&Context
argument_list|,
argument|unsigned Line
argument_list|,
argument|unsigned Column
argument_list|,
argument|Metadata *Scope
argument_list|,
argument|Metadata *InlinedAt = nullptr
argument_list|)
block|;
name|unsigned
name|getLine
argument_list|()
specifier|const
block|{
return|return
name|MDNodeSubclassData
return|;
block|}
name|unsigned
name|getColumn
argument_list|()
specifier|const
block|{
return|return
name|SubclassData16
return|;
block|}
name|Metadata
operator|*
name|getScope
argument_list|()
specifier|const
block|{
return|return
name|getOperand
argument_list|(
literal|0
argument_list|)
return|;
block|}
name|Metadata
operator|*
name|getInlinedAt
argument_list|()
specifier|const
block|{
if|if
condition|(
name|getNumOperands
argument_list|()
operator|==
literal|2
condition|)
return|return
name|getOperand
argument_list|(
literal|1
argument_list|)
return|;
return|return
name|nullptr
return|;
block|}
end_decl_stmt

begin_function
specifier|static
name|bool
name|classof
parameter_list|(
specifier|const
name|Metadata
modifier|*
name|MD
parameter_list|)
block|{
return|return
name|MD
operator|->
name|getMetadataID
argument_list|()
operator|==
name|MDLocationKind
return|;
block|}
end_function

begin_label
name|private
label|:
end_label

begin_function_decl
name|MDLocation
modifier|*
name|uniquifyImpl
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|eraseFromStoreImpl
parameter_list|()
function_decl|;
end_function_decl

begin_comment
unit|};
comment|/// \brief Forward declaration of metadata.
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|/// Forward declaration of metadata, in the form of a basic tuple.  Unlike \a
end_comment

begin_comment
comment|/// MDTuple, this class has full support for RAUW, is not owned, is not
end_comment

begin_comment
comment|/// uniqued, and is suitable for forward references.
end_comment

begin_decl_stmt
name|class
name|MDNodeFwdDecl
range|:
name|public
name|MDNode
decl_stmt|,
name|ReplaceableMetadataImpl
block|{
name|friend
name|class
name|Metadata
decl_stmt|;
name|friend
name|class
name|ReplaceableMetadataImpl
decl_stmt|;
name|MDNodeFwdDecl
argument_list|(
name|LLVMContext
operator|&
name|C
argument_list|,
name|ArrayRef
operator|<
name|Metadata
operator|*
operator|>
name|Vals
argument_list|)
operator|:
name|MDNode
argument_list|(
argument|C
argument_list|,
argument|MDNodeFwdDeclKind
argument_list|,
argument|Vals
argument_list|)
block|{}
name|public
operator|:
operator|~
name|MDNodeFwdDecl
argument_list|()
block|{
name|dropAllReferences
argument_list|()
block|; }
comment|// MSVC doesn't see the alternative: "using MDNode::operator delete".
name|void
name|operator
name|delete
argument_list|(
argument|void *Mem
argument_list|)
block|{
name|MDNode
operator|::
name|operator
name|delete
argument_list|(
name|Mem
argument_list|)
block|; }
specifier|static
name|MDNodeFwdDecl
operator|*
name|get
argument_list|(
argument|LLVMContext&Context
argument_list|,
argument|ArrayRef<Metadata *> MDs
argument_list|)
block|{
return|return
name|new
argument_list|(
argument|MDs.size()
argument_list|)
name|MDNodeFwdDecl
argument_list|(
name|Context
argument_list|,
name|MDs
argument_list|)
return|;
block|}
specifier|static
name|bool
name|classof
parameter_list|(
specifier|const
name|Metadata
modifier|*
name|MD
parameter_list|)
block|{
return|return
name|MD
operator|->
name|getMetadataID
argument_list|()
operator|==
name|MDNodeFwdDeclKind
return|;
block|}
name|using
name|ReplaceableMetadataImpl
operator|::
name|replaceAllUsesWith
expr_stmt|;
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|/// \brief A tuple of MDNodes.
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|/// Despite its name, a NamedMDNode isn't itself an MDNode. NamedMDNodes belong
end_comment

begin_comment
comment|/// to modules, have names, and contain lists of MDNodes.
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|/// TODO: Inherit from Metadata.
end_comment

begin_decl_stmt
name|class
name|NamedMDNode
range|:
name|public
name|ilist_node
operator|<
name|NamedMDNode
operator|>
block|{
name|friend
name|class
name|SymbolTableListTraits
operator|<
name|NamedMDNode
block|,
name|Module
operator|>
block|;
name|friend
expr|struct
name|ilist_traits
operator|<
name|NamedMDNode
operator|>
block|;
name|friend
name|class
name|LLVMContextImpl
block|;
name|friend
name|class
name|Module
block|;
name|NamedMDNode
argument_list|(
argument|const NamedMDNode&
argument_list|)
name|LLVM_DELETED_FUNCTION
block|;
name|std
operator|::
name|string
name|Name
block|;
name|Module
operator|*
name|Parent
block|;
name|void
operator|*
name|Operands
block|;
comment|// SmallVector<TrackingMDRef, 4>
name|void
name|setParent
argument_list|(
argument|Module *M
argument_list|)
block|{
name|Parent
operator|=
name|M
block|; }
name|explicit
name|NamedMDNode
argument_list|(
specifier|const
name|Twine
operator|&
name|N
argument_list|)
block|;
name|template
operator|<
name|class
name|T1
block|,
name|class
name|T2
operator|>
name|class
name|op_iterator_impl
operator|:
name|public
name|std
operator|::
name|iterator
operator|<
name|std
operator|::
name|bidirectional_iterator_tag
block|,
name|T2
operator|>
block|{
specifier|const
name|NamedMDNode
operator|*
name|Node
block|;
name|unsigned
name|Idx
block|;
name|op_iterator_impl
argument_list|(
argument|const NamedMDNode *N
argument_list|,
argument|unsigned i
argument_list|)
operator|:
name|Node
argument_list|(
name|N
argument_list|)
block|,
name|Idx
argument_list|(
argument|i
argument_list|)
block|{ }
name|friend
name|class
name|NamedMDNode
block|;
name|public
operator|:
name|op_iterator_impl
argument_list|()
operator|:
name|Node
argument_list|(
name|nullptr
argument_list|)
block|,
name|Idx
argument_list|(
literal|0
argument_list|)
block|{ }
name|bool
name|operator
operator|==
operator|(
specifier|const
name|op_iterator_impl
operator|&
name|o
operator|)
specifier|const
block|{
return|return
name|Idx
operator|==
name|o
operator|.
name|Idx
return|;
block|}
name|bool
name|operator
operator|!=
operator|(
specifier|const
name|op_iterator_impl
operator|&
name|o
operator|)
specifier|const
block|{
return|return
name|Idx
operator|!=
name|o
operator|.
name|Idx
return|;
block|}
name|op_iterator_impl
operator|&
name|operator
operator|++
operator|(
operator|)
block|{
operator|++
name|Idx
block|;
return|return
operator|*
name|this
return|;
block|}
name|op_iterator_impl
name|operator
operator|++
operator|(
name|int
operator|)
block|{
name|op_iterator_impl
name|tmp
argument_list|(
operator|*
name|this
argument_list|)
block|;
name|operator
operator|++
operator|(
operator|)
block|;
return|return
name|tmp
return|;
block|}
name|op_iterator_impl
operator|&
name|operator
operator|--
operator|(
operator|)
block|{
operator|--
name|Idx
block|;
return|return
operator|*
name|this
return|;
block|}
name|op_iterator_impl
name|operator
operator|--
operator|(
name|int
operator|)
block|{
name|op_iterator_impl
name|tmp
argument_list|(
operator|*
name|this
argument_list|)
block|;
name|operator
operator|--
operator|(
operator|)
block|;
return|return
name|tmp
return|;
block|}
name|T1
name|operator
operator|*
operator|(
operator|)
specifier|const
block|{
return|return
name|Node
operator|->
name|getOperand
argument_list|(
name|Idx
argument_list|)
return|;
block|}
expr|}
block|;
name|public
operator|:
comment|/// \brief Drop all references and remove the node from parent module.
name|void
name|eraseFromParent
argument_list|()
block|;
comment|/// \brief Remove all uses and clear node vector.
name|void
name|dropAllReferences
argument_list|()
block|;
operator|~
name|NamedMDNode
argument_list|()
block|;
comment|/// \brief Get the module that holds this named metadata collection.
specifier|inline
name|Module
operator|*
name|getParent
argument_list|()
block|{
return|return
name|Parent
return|;
block|}
specifier|inline
specifier|const
name|Module
operator|*
name|getParent
argument_list|()
specifier|const
block|{
return|return
name|Parent
return|;
block|}
name|MDNode
operator|*
name|getOperand
argument_list|(
argument|unsigned i
argument_list|)
specifier|const
block|;
name|unsigned
name|getNumOperands
argument_list|()
specifier|const
block|;
name|void
name|addOperand
argument_list|(
name|MDNode
operator|*
name|M
argument_list|)
block|;
name|void
name|setOperand
argument_list|(
argument|unsigned I
argument_list|,
argument|MDNode *New
argument_list|)
block|;
name|StringRef
name|getName
argument_list|()
specifier|const
block|;
name|void
name|print
argument_list|(
argument|raw_ostream&ROS
argument_list|)
specifier|const
block|;
name|void
name|dump
argument_list|()
specifier|const
block|;
comment|// ---------------------------------------------------------------------------
comment|// Operand Iterator interface...
comment|//
typedef|typedef
name|op_iterator_impl
operator|<
name|MDNode
operator|*
operator|,
name|MDNode
operator|>
name|op_iterator
expr_stmt|;
name|op_iterator
name|op_begin
argument_list|()
block|{
return|return
name|op_iterator
argument_list|(
name|this
argument_list|,
literal|0
argument_list|)
return|;
block|}
name|op_iterator
name|op_end
argument_list|()
block|{
return|return
name|op_iterator
argument_list|(
name|this
argument_list|,
name|getNumOperands
argument_list|()
argument_list|)
return|;
block|}
typedef|typedef
name|op_iterator_impl
operator|<
specifier|const
name|MDNode
operator|*
operator|,
name|MDNode
operator|>
name|const_op_iterator
expr_stmt|;
name|const_op_iterator
name|op_begin
argument_list|()
specifier|const
block|{
return|return
name|const_op_iterator
argument_list|(
name|this
argument_list|,
literal|0
argument_list|)
return|;
block|}
name|const_op_iterator
name|op_end
argument_list|()
specifier|const
block|{
return|return
name|const_op_iterator
argument_list|(
name|this
argument_list|,
name|getNumOperands
argument_list|()
argument_list|)
return|;
block|}
specifier|inline
name|iterator_range
operator|<
name|op_iterator
operator|>
name|operands
argument_list|()
block|{
return|return
name|iterator_range
operator|<
name|op_iterator
operator|>
operator|(
name|op_begin
argument_list|()
expr|,
name|op_end
argument_list|()
operator|)
return|;
block|}
specifier|inline
name|iterator_range
operator|<
name|const_op_iterator
operator|>
name|operands
argument_list|()
specifier|const
block|{
return|return
name|iterator_range
operator|<
name|const_op_iterator
operator|>
operator|(
name|op_begin
argument_list|()
expr|,
name|op_end
argument_list|()
operator|)
return|;
block|}
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_comment
unit|}
comment|// end llvm namespace
end_comment

begin_endif
endif|#
directive|endif
end_endif

end_unit

