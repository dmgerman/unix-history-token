begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===- llvm/IR/Metadata.h - Metadata definitions ----------------*- C++ -*-===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|/// @file
end_comment

begin_comment
comment|/// This file contains the declarations for metadata subclasses.
end_comment

begin_comment
comment|/// They represent the different flavors of metadata that live in LLVM.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LLVM_IR_METADATA_H
end_ifndef

begin_define
define|#
directive|define
name|LLVM_IR_METADATA_H
end_define

begin_include
include|#
directive|include
file|"llvm/ADT/ArrayRef.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/DenseMap.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/DenseMapInfo.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/None.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/PointerUnion.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/STLExtras.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/SmallVector.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/StringRef.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/ilist_node.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/iterator_range.h"
end_include

begin_include
include|#
directive|include
file|"llvm/IR/Constant.h"
end_include

begin_include
include|#
directive|include
file|"llvm/IR/LLVMContext.h"
end_include

begin_include
include|#
directive|include
file|"llvm/IR/Value.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/CBindingWrapping.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/Casting.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/ErrorHandling.h"
end_include

begin_include
include|#
directive|include
file|<cassert>
end_include

begin_include
include|#
directive|include
file|<cstddef>
end_include

begin_include
include|#
directive|include
file|<cstdint>
end_include

begin_include
include|#
directive|include
file|<iterator>
end_include

begin_include
include|#
directive|include
file|<memory>
end_include

begin_include
include|#
directive|include
file|<string>
end_include

begin_include
include|#
directive|include
file|<type_traits>
end_include

begin_include
include|#
directive|include
file|<utility>
end_include

begin_decl_stmt
name|namespace
name|llvm
block|{
name|class
name|Module
decl_stmt|;
name|class
name|ModuleSlotTracker
decl_stmt|;
name|class
name|raw_ostream
decl_stmt|;
name|class
name|Type
decl_stmt|;
enum|enum
name|LLVMConstants
enum|:
name|uint32_t
block|{
name|DEBUG_METADATA_VERSION
init|=
literal|3
comment|// Current debug info version number.
block|}
enum|;
comment|/// \brief Root of the metadata hierarchy.
comment|///
comment|/// This is a root class for typeless data in the IR.
name|class
name|Metadata
block|{
name|friend
name|class
name|ReplaceableMetadataImpl
decl_stmt|;
comment|/// \brief RTTI.
specifier|const
name|unsigned
name|char
name|SubclassID
decl_stmt|;
name|protected
label|:
comment|/// \brief Active type of storage.
enum|enum
name|StorageType
block|{
name|Uniqued
block|,
name|Distinct
block|,
name|Temporary
block|}
enum|;
comment|/// \brief Storage flag for non-uniqued, otherwise unowned, metadata.
name|unsigned
name|char
name|Storage
decl_stmt|;
comment|// TODO: expose remaining bits to subclasses.
name|unsigned
name|short
name|SubclassData16
init|=
literal|0
decl_stmt|;
name|unsigned
name|SubclassData32
init|=
literal|0
decl_stmt|;
name|public
label|:
enum|enum
name|MetadataKind
block|{
define|#
directive|define
name|HANDLE_METADATA_LEAF
parameter_list|(
name|CLASS
parameter_list|)
value|CLASS##Kind,
include|#
directive|include
file|"llvm/IR/Metadata.def"
block|}
enum|;
name|protected
label|:
name|Metadata
argument_list|(
argument|unsigned ID
argument_list|,
argument|StorageType Storage
argument_list|)
block|:
name|SubclassID
argument_list|(
name|ID
argument_list|)
operator|,
name|Storage
argument_list|(
argument|Storage
argument_list|)
block|{
name|static_assert
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|this
argument_list|)
operator|==
literal|8
argument_list|,
literal|"Metadata fields poorly packed"
argument_list|)
block|;   }
operator|~
name|Metadata
argument_list|()
operator|=
expr|default
expr_stmt|;
comment|/// \brief Default handling of a changed operand, which asserts.
comment|///
comment|/// If subclasses pass themselves in as owners to a tracking node reference,
comment|/// they must provide an implementation of this method.
name|void
name|handleChangedOperand
parameter_list|(
name|void
modifier|*
parameter_list|,
name|Metadata
modifier|*
parameter_list|)
block|{
name|llvm_unreachable
argument_list|(
literal|"Unimplemented in Metadata subclass"
argument_list|)
expr_stmt|;
block|}
name|public
label|:
name|unsigned
name|getMetadataID
argument_list|()
specifier|const
block|{
return|return
name|SubclassID
return|;
block|}
comment|/// \brief User-friendly dump.
comment|///
comment|/// If \c M is provided, metadata nodes will be numbered canonically;
comment|/// otherwise, pointer addresses are substituted.
comment|///
comment|/// Note: this uses an explicit overload instead of default arguments so that
comment|/// the nullptr version is easy to call from a debugger.
comment|///
comment|/// @{
name|void
name|dump
argument_list|()
specifier|const
expr_stmt|;
name|void
name|dump
argument_list|(
specifier|const
name|Module
operator|*
name|M
argument_list|)
decl|const
decl_stmt|;
comment|/// @}
comment|/// \brief Print.
comment|///
comment|/// Prints definition of \c this.
comment|///
comment|/// If \c M is provided, metadata nodes will be numbered canonically;
comment|/// otherwise, pointer addresses are substituted.
comment|/// @{
name|void
name|print
argument_list|(
name|raw_ostream
operator|&
name|OS
argument_list|,
specifier|const
name|Module
operator|*
name|M
operator|=
name|nullptr
argument_list|,
name|bool
name|IsForDebug
operator|=
name|false
argument_list|)
decl|const
decl_stmt|;
name|void
name|print
argument_list|(
name|raw_ostream
operator|&
name|OS
argument_list|,
name|ModuleSlotTracker
operator|&
name|MST
argument_list|,
specifier|const
name|Module
operator|*
name|M
operator|=
name|nullptr
argument_list|,
name|bool
name|IsForDebug
operator|=
name|false
argument_list|)
decl|const
decl_stmt|;
comment|/// @}
comment|/// \brief Print as operand.
comment|///
comment|/// Prints reference of \c this.
comment|///
comment|/// If \c M is provided, metadata nodes will be numbered canonically;
comment|/// otherwise, pointer addresses are substituted.
comment|/// @{
name|void
name|printAsOperand
argument_list|(
name|raw_ostream
operator|&
name|OS
argument_list|,
specifier|const
name|Module
operator|*
name|M
operator|=
name|nullptr
argument_list|)
decl|const
decl_stmt|;
name|void
name|printAsOperand
argument_list|(
name|raw_ostream
operator|&
name|OS
argument_list|,
name|ModuleSlotTracker
operator|&
name|MST
argument_list|,
specifier|const
name|Module
operator|*
name|M
operator|=
name|nullptr
argument_list|)
decl|const
decl_stmt|;
comment|/// @}
block|}
empty_stmt|;
comment|// Create wrappers for C Binding types (see CBindingWrapping.h).
name|DEFINE_ISA_CONVERSION_FUNCTIONS
argument_list|(
argument|Metadata
argument_list|,
argument|LLVMMetadataRef
argument_list|)
comment|// Specialized opaque metadata conversions.
specifier|inline
name|Metadata
modifier|*
modifier|*
name|unwrap
parameter_list|(
name|LLVMMetadataRef
modifier|*
name|MDs
parameter_list|)
block|{
return|return
name|reinterpret_cast
operator|<
name|Metadata
operator|*
operator|*
operator|>
operator|(
name|MDs
operator|)
return|;
block|}
define|#
directive|define
name|HANDLE_METADATA
parameter_list|(
name|CLASS
parameter_list|)
value|class CLASS;
include|#
directive|include
file|"llvm/IR/Metadata.def"
comment|// Provide specializations of isa so that we don't need definitions of
comment|// subclasses to see if the metadata is a subclass.
define|#
directive|define
name|HANDLE_METADATA_LEAF
parameter_list|(
name|CLASS
parameter_list|)
define|\
value|template<> struct isa_impl<CLASS, Metadata> {                               \     static inline bool doit(const Metadata&MD) {                              \       return MD.getMetadataID() == Metadata::CLASS##Kind;                      \     }                                                                          \   };
include|#
directive|include
file|"llvm/IR/Metadata.def"
specifier|inline
name|raw_ostream
operator|&
name|operator
operator|<<
operator|(
name|raw_ostream
operator|&
name|OS
operator|,
specifier|const
name|Metadata
operator|&
name|MD
operator|)
block|{
name|MD
operator|.
name|print
argument_list|(
name|OS
argument_list|)
block|;
return|return
name|OS
return|;
block|}
comment|/// \brief Metadata wrapper in the Value hierarchy.
comment|///
comment|/// A member of the \a Value hierarchy to represent a reference to metadata.
comment|/// This allows, e.g., instrinsics to have metadata as operands.
comment|///
comment|/// Notably, this is the only thing in either hierarchy that is allowed to
comment|/// reference \a LocalAsMetadata.
name|class
name|MetadataAsValue
range|:
name|public
name|Value
block|{
name|friend
name|class
name|ReplaceableMetadataImpl
block|;
name|friend
name|class
name|LLVMContextImpl
block|;
name|Metadata
operator|*
name|MD
block|;
name|MetadataAsValue
argument_list|(
name|Type
operator|*
name|Ty
argument_list|,
name|Metadata
operator|*
name|MD
argument_list|)
block|;
comment|/// \brief Drop use of metadata (during teardown).
name|void
name|dropUse
argument_list|()
block|{
name|MD
operator|=
name|nullptr
block|; }
name|public
operator|:
operator|~
name|MetadataAsValue
argument_list|()
block|;
specifier|static
name|MetadataAsValue
operator|*
name|get
argument_list|(
name|LLVMContext
operator|&
name|Context
argument_list|,
name|Metadata
operator|*
name|MD
argument_list|)
block|;
specifier|static
name|MetadataAsValue
operator|*
name|getIfExists
argument_list|(
name|LLVMContext
operator|&
name|Context
argument_list|,
name|Metadata
operator|*
name|MD
argument_list|)
block|;
name|Metadata
operator|*
name|getMetadata
argument_list|()
specifier|const
block|{
return|return
name|MD
return|;
block|}
specifier|static
name|bool
name|classof
argument_list|(
argument|const Value *V
argument_list|)
block|{
return|return
name|V
operator|->
name|getValueID
argument_list|()
operator|==
name|MetadataAsValueVal
return|;
block|}
name|private
operator|:
name|void
name|handleChangedMetadata
argument_list|(
name|Metadata
operator|*
name|MD
argument_list|)
block|;
name|void
name|track
argument_list|()
block|;
name|void
name|untrack
argument_list|()
block|; }
decl_stmt|;
comment|/// \brief API for tracking metadata references through RAUW and deletion.
comment|///
comment|/// Shared API for updating \a Metadata pointers in subclasses that support
comment|/// RAUW.
comment|///
comment|/// This API is not meant to be used directly.  See \a TrackingMDRef for a
comment|/// user-friendly tracking reference.
name|class
name|MetadataTracking
block|{
name|public
label|:
comment|/// \brief Track the reference to metadata.
comment|///
comment|/// Register \c MD with \c *MD, if the subclass supports tracking.  If \c *MD
comment|/// gets RAUW'ed, \c MD will be updated to the new address.  If \c *MD gets
comment|/// deleted, \c MD will be set to \c nullptr.
comment|///
comment|/// If tracking isn't supported, \c *MD will not change.
comment|///
comment|/// \return true iff tracking is supported by \c MD.
specifier|static
name|bool
name|track
parameter_list|(
name|Metadata
modifier|*
modifier|&
name|MD
parameter_list|)
block|{
return|return
name|track
argument_list|(
operator|&
name|MD
argument_list|,
operator|*
name|MD
argument_list|,
name|static_cast
operator|<
name|Metadata
operator|*
operator|>
operator|(
name|nullptr
operator|)
argument_list|)
return|;
block|}
comment|/// \brief Track the reference to metadata for \a Metadata.
comment|///
comment|/// As \a track(Metadata*&), but with support for calling back to \c Owner to
comment|/// tell it that its operand changed.  This could trigger \c Owner being
comment|/// re-uniqued.
specifier|static
name|bool
name|track
parameter_list|(
name|void
modifier|*
name|Ref
parameter_list|,
name|Metadata
modifier|&
name|MD
parameter_list|,
name|Metadata
modifier|&
name|Owner
parameter_list|)
block|{
return|return
name|track
argument_list|(
name|Ref
argument_list|,
name|MD
argument_list|,
operator|&
name|Owner
argument_list|)
return|;
block|}
comment|/// \brief Track the reference to metadata for \a MetadataAsValue.
comment|///
comment|/// As \a track(Metadata*&), but with support for calling back to \c Owner to
comment|/// tell it that its operand changed.  This could trigger \c Owner being
comment|/// re-uniqued.
specifier|static
name|bool
name|track
parameter_list|(
name|void
modifier|*
name|Ref
parameter_list|,
name|Metadata
modifier|&
name|MD
parameter_list|,
name|MetadataAsValue
modifier|&
name|Owner
parameter_list|)
block|{
return|return
name|track
argument_list|(
name|Ref
argument_list|,
name|MD
argument_list|,
operator|&
name|Owner
argument_list|)
return|;
block|}
comment|/// \brief Stop tracking a reference to metadata.
comment|///
comment|/// Stops \c *MD from tracking \c MD.
specifier|static
name|void
name|untrack
parameter_list|(
name|Metadata
modifier|*
modifier|&
name|MD
parameter_list|)
block|{
name|untrack
argument_list|(
operator|&
name|MD
argument_list|,
operator|*
name|MD
argument_list|)
expr_stmt|;
block|}
specifier|static
name|void
name|untrack
parameter_list|(
name|void
modifier|*
name|Ref
parameter_list|,
name|Metadata
modifier|&
name|MD
parameter_list|)
function_decl|;
comment|/// \brief Move tracking from one reference to another.
comment|///
comment|/// Semantically equivalent to \c untrack(MD) followed by \c track(New),
comment|/// except that ownership callbacks are maintained.
comment|///
comment|/// Note: it is an error if \c *MD does not equal \c New.
comment|///
comment|/// \return true iff tracking is supported by \c MD.
specifier|static
name|bool
name|retrack
parameter_list|(
name|Metadata
modifier|*
modifier|&
name|MD
parameter_list|,
name|Metadata
modifier|*
modifier|&
name|New
parameter_list|)
block|{
return|return
name|retrack
argument_list|(
operator|&
name|MD
argument_list|,
operator|*
name|MD
argument_list|,
operator|&
name|New
argument_list|)
return|;
block|}
specifier|static
name|bool
name|retrack
parameter_list|(
name|void
modifier|*
name|Ref
parameter_list|,
name|Metadata
modifier|&
name|MD
parameter_list|,
name|void
modifier|*
name|New
parameter_list|)
function_decl|;
comment|/// \brief Check whether metadata is replaceable.
specifier|static
name|bool
name|isReplaceable
parameter_list|(
specifier|const
name|Metadata
modifier|&
name|MD
parameter_list|)
function_decl|;
name|using
name|OwnerTy
init|=
name|PointerUnion
operator|<
name|MetadataAsValue
operator|*
decl_stmt|,
name|Metadata
modifier|*
decl|>
decl_stmt|;
name|private
label|:
comment|/// \brief Track a reference to metadata for an owner.
comment|///
comment|/// Generalized version of tracking.
specifier|static
name|bool
name|track
parameter_list|(
name|void
modifier|*
name|Ref
parameter_list|,
name|Metadata
modifier|&
name|MD
parameter_list|,
name|OwnerTy
name|Owner
parameter_list|)
function_decl|;
block|}
empty_stmt|;
comment|/// \brief Shared implementation of use-lists for replaceable metadata.
comment|///
comment|/// Most metadata cannot be RAUW'ed.  This is a shared implementation of
comment|/// use-lists and associated API for the two that support it (\a ValueAsMetadata
comment|/// and \a TempMDNode).
name|class
name|ReplaceableMetadataImpl
block|{
name|friend
name|class
name|MetadataTracking
decl_stmt|;
name|public
label|:
name|using
name|OwnerTy
init|=
name|MetadataTracking
operator|::
name|OwnerTy
decl_stmt|;
name|private
label|:
name|LLVMContext
modifier|&
name|Context
decl_stmt|;
name|uint64_t
name|NextIndex
init|=
literal|0
decl_stmt|;
name|SmallDenseMap
operator|<
name|void
operator|*
operator|,
name|std
operator|::
name|pair
operator|<
name|OwnerTy
operator|,
name|uint64_t
operator|>
operator|,
literal|4
operator|>
name|UseMap
expr_stmt|;
name|public
label|:
name|ReplaceableMetadataImpl
argument_list|(
name|LLVMContext
operator|&
name|Context
argument_list|)
operator|:
name|Context
argument_list|(
argument|Context
argument_list|)
block|{}
operator|~
name|ReplaceableMetadataImpl
argument_list|()
block|{
name|assert
argument_list|(
name|UseMap
operator|.
name|empty
argument_list|()
operator|&&
literal|"Cannot destroy in-use replaceable metadata"
argument_list|)
block|;   }
name|LLVMContext
operator|&
name|getContext
argument_list|()
specifier|const
block|{
return|return
name|Context
return|;
block|}
comment|/// \brief Replace all uses of this with MD.
comment|///
comment|/// Replace all uses of this with \c MD, which is allowed to be null.
name|void
name|replaceAllUsesWith
parameter_list|(
name|Metadata
modifier|*
name|MD
parameter_list|)
function_decl|;
comment|/// \brief Resolve all uses of this.
comment|///
comment|/// Resolve all uses of this, turning off RAUW permanently.  If \c
comment|/// ResolveUsers, call \a MDNode::resolve() on any users whose last operand
comment|/// is resolved.
name|void
name|resolveAllUses
parameter_list|(
name|bool
name|ResolveUsers
init|=
name|true
parameter_list|)
function_decl|;
name|private
label|:
name|void
name|addRef
parameter_list|(
name|void
modifier|*
name|Ref
parameter_list|,
name|OwnerTy
name|Owner
parameter_list|)
function_decl|;
name|void
name|dropRef
parameter_list|(
name|void
modifier|*
name|Ref
parameter_list|)
function_decl|;
name|void
name|moveRef
parameter_list|(
name|void
modifier|*
name|Ref
parameter_list|,
name|void
modifier|*
name|New
parameter_list|,
specifier|const
name|Metadata
modifier|&
name|MD
parameter_list|)
function_decl|;
comment|/// Lazily construct RAUW support on MD.
comment|///
comment|/// If this is an unresolved MDNode, RAUW support will be created on-demand.
comment|/// ValueAsMetadata always has RAUW support.
specifier|static
name|ReplaceableMetadataImpl
modifier|*
name|getOrCreate
parameter_list|(
name|Metadata
modifier|&
name|MD
parameter_list|)
function_decl|;
comment|/// Get RAUW support on MD, if it exists.
specifier|static
name|ReplaceableMetadataImpl
modifier|*
name|getIfExists
parameter_list|(
name|Metadata
modifier|&
name|MD
parameter_list|)
function_decl|;
comment|/// Check whether this node will support RAUW.
comment|///
comment|/// Returns \c true unless getOrCreate() would return null.
specifier|static
name|bool
name|isReplaceable
parameter_list|(
specifier|const
name|Metadata
modifier|&
name|MD
parameter_list|)
function_decl|;
block|}
empty_stmt|;
comment|/// \brief Value wrapper in the Metadata hierarchy.
comment|///
comment|/// This is a custom value handle that allows other metadata to refer to
comment|/// classes in the Value hierarchy.
comment|///
comment|/// Because of full uniquing support, each value is only wrapped by a single \a
comment|/// ValueAsMetadata object, so the lookup maps are far more efficient than
comment|/// those using ValueHandleBase.
name|class
name|ValueAsMetadata
range|:
name|public
name|Metadata
decl_stmt|,
name|ReplaceableMetadataImpl
block|{
name|friend
name|class
name|ReplaceableMetadataImpl
decl_stmt|;
name|friend
name|class
name|LLVMContextImpl
decl_stmt|;
name|Value
modifier|*
name|V
decl_stmt|;
comment|/// \brief Drop users without RAUW (during teardown).
name|void
name|dropUsers
parameter_list|()
block|{
name|ReplaceableMetadataImpl
operator|::
name|resolveAllUses
argument_list|(
comment|/* ResolveUsers */
name|false
argument_list|)
expr_stmt|;
block|}
name|protected
label|:
name|ValueAsMetadata
argument_list|(
argument|unsigned ID
argument_list|,
argument|Value *V
argument_list|)
block|:
name|Metadata
argument_list|(
name|ID
argument_list|,
name|Uniqued
argument_list|)
operator|,
name|ReplaceableMetadataImpl
argument_list|(
name|V
operator|->
name|getContext
argument_list|()
argument_list|)
operator|,
name|V
argument_list|(
argument|V
argument_list|)
block|{
name|assert
argument_list|(
name|V
operator|&&
literal|"Expected valid value"
argument_list|)
block|;   }
operator|~
name|ValueAsMetadata
argument_list|()
operator|=
expr|default
expr_stmt|;
name|public
label|:
specifier|static
name|ValueAsMetadata
modifier|*
name|get
parameter_list|(
name|Value
modifier|*
name|V
parameter_list|)
function_decl|;
specifier|static
name|ConstantAsMetadata
modifier|*
name|getConstant
parameter_list|(
name|Value
modifier|*
name|C
parameter_list|)
block|{
return|return
name|cast
operator|<
name|ConstantAsMetadata
operator|>
operator|(
name|get
argument_list|(
name|C
argument_list|)
operator|)
return|;
block|}
specifier|static
name|LocalAsMetadata
modifier|*
name|getLocal
parameter_list|(
name|Value
modifier|*
name|Local
parameter_list|)
block|{
return|return
name|cast
operator|<
name|LocalAsMetadata
operator|>
operator|(
name|get
argument_list|(
name|Local
argument_list|)
operator|)
return|;
block|}
specifier|static
name|ValueAsMetadata
modifier|*
name|getIfExists
parameter_list|(
name|Value
modifier|*
name|V
parameter_list|)
function_decl|;
specifier|static
name|ConstantAsMetadata
modifier|*
name|getConstantIfExists
parameter_list|(
name|Value
modifier|*
name|C
parameter_list|)
block|{
return|return
name|cast_or_null
operator|<
name|ConstantAsMetadata
operator|>
operator|(
name|getIfExists
argument_list|(
name|C
argument_list|)
operator|)
return|;
block|}
specifier|static
name|LocalAsMetadata
modifier|*
name|getLocalIfExists
parameter_list|(
name|Value
modifier|*
name|Local
parameter_list|)
block|{
return|return
name|cast_or_null
operator|<
name|LocalAsMetadata
operator|>
operator|(
name|getIfExists
argument_list|(
name|Local
argument_list|)
operator|)
return|;
block|}
name|Value
operator|*
name|getValue
argument_list|()
specifier|const
block|{
return|return
name|V
return|;
block|}
name|Type
operator|*
name|getType
argument_list|()
specifier|const
block|{
return|return
name|V
operator|->
name|getType
argument_list|()
return|;
block|}
name|LLVMContext
operator|&
name|getContext
argument_list|()
specifier|const
block|{
return|return
name|V
operator|->
name|getContext
argument_list|()
return|;
block|}
specifier|static
name|void
name|handleDeletion
parameter_list|(
name|Value
modifier|*
name|V
parameter_list|)
function_decl|;
specifier|static
name|void
name|handleRAUW
parameter_list|(
name|Value
modifier|*
name|From
parameter_list|,
name|Value
modifier|*
name|To
parameter_list|)
function_decl|;
name|protected
label|:
comment|/// \brief Handle collisions after \a Value::replaceAllUsesWith().
comment|///
comment|/// RAUW isn't supported directly for \a ValueAsMetadata, but if the wrapped
comment|/// \a Value gets RAUW'ed and the target already exists, this is used to
comment|/// merge the two metadata nodes.
name|void
name|replaceAllUsesWith
parameter_list|(
name|Metadata
modifier|*
name|MD
parameter_list|)
block|{
name|ReplaceableMetadataImpl
operator|::
name|replaceAllUsesWith
argument_list|(
name|MD
argument_list|)
expr_stmt|;
block|}
name|public
label|:
specifier|static
name|bool
name|classof
parameter_list|(
specifier|const
name|Metadata
modifier|*
name|MD
parameter_list|)
block|{
return|return
name|MD
operator|->
name|getMetadataID
argument_list|()
operator|==
name|LocalAsMetadataKind
operator|||
name|MD
operator|->
name|getMetadataID
argument_list|()
operator|==
name|ConstantAsMetadataKind
return|;
block|}
block|}
empty_stmt|;
name|class
name|ConstantAsMetadata
range|:
name|public
name|ValueAsMetadata
block|{
name|friend
name|class
name|ValueAsMetadata
block|;
name|ConstantAsMetadata
argument_list|(
name|Constant
operator|*
name|C
argument_list|)
operator|:
name|ValueAsMetadata
argument_list|(
argument|ConstantAsMetadataKind
argument_list|,
argument|C
argument_list|)
block|{}
name|public
operator|:
specifier|static
name|ConstantAsMetadata
operator|*
name|get
argument_list|(
argument|Constant *C
argument_list|)
block|{
return|return
name|ValueAsMetadata
operator|::
name|getConstant
argument_list|(
name|C
argument_list|)
return|;
block|}
specifier|static
name|ConstantAsMetadata
operator|*
name|getIfExists
argument_list|(
argument|Constant *C
argument_list|)
block|{
return|return
name|ValueAsMetadata
operator|::
name|getConstantIfExists
argument_list|(
name|C
argument_list|)
return|;
block|}
name|Constant
operator|*
name|getValue
argument_list|()
specifier|const
block|{
return|return
name|cast
operator|<
name|Constant
operator|>
operator|(
name|ValueAsMetadata
operator|::
name|getValue
argument_list|()
operator|)
return|;
block|}
specifier|static
name|bool
name|classof
argument_list|(
argument|const Metadata *MD
argument_list|)
block|{
return|return
name|MD
operator|->
name|getMetadataID
argument_list|()
operator|==
name|ConstantAsMetadataKind
return|;
block|}
expr|}
block|;
name|class
name|LocalAsMetadata
operator|:
name|public
name|ValueAsMetadata
block|{
name|friend
name|class
name|ValueAsMetadata
block|;
name|LocalAsMetadata
argument_list|(
name|Value
operator|*
name|Local
argument_list|)
operator|:
name|ValueAsMetadata
argument_list|(
argument|LocalAsMetadataKind
argument_list|,
argument|Local
argument_list|)
block|{
name|assert
argument_list|(
operator|!
name|isa
operator|<
name|Constant
operator|>
operator|(
name|Local
operator|)
operator|&&
literal|"Expected local value"
argument_list|)
block|;   }
name|public
operator|:
specifier|static
name|LocalAsMetadata
operator|*
name|get
argument_list|(
argument|Value *Local
argument_list|)
block|{
return|return
name|ValueAsMetadata
operator|::
name|getLocal
argument_list|(
name|Local
argument_list|)
return|;
block|}
specifier|static
name|LocalAsMetadata
operator|*
name|getIfExists
argument_list|(
argument|Value *Local
argument_list|)
block|{
return|return
name|ValueAsMetadata
operator|::
name|getLocalIfExists
argument_list|(
name|Local
argument_list|)
return|;
block|}
specifier|static
name|bool
name|classof
argument_list|(
argument|const Metadata *MD
argument_list|)
block|{
return|return
name|MD
operator|->
name|getMetadataID
argument_list|()
operator|==
name|LocalAsMetadataKind
return|;
block|}
expr|}
block|;
comment|/// \brief Transitional API for extracting constants from Metadata.
comment|///
comment|/// This namespace contains transitional functions for metadata that points to
comment|/// \a Constants.
comment|///
comment|/// In prehistory -- when metadata was a subclass of \a Value -- \a MDNode
comment|/// operands could refer to any \a Value.  There's was a lot of code like this:
comment|///
comment|/// \code
comment|///     MDNode *N = ...;
comment|///     auto *CI = dyn_cast<ConstantInt>(N->getOperand(2));
comment|/// \endcode
comment|///
comment|/// Now that \a Value and \a Metadata are in separate hierarchies, maintaining
comment|/// the semantics for \a isa(), \a cast(), \a dyn_cast() (etc.) requires three
comment|/// steps: cast in the \a Metadata hierarchy, extraction of the \a Value, and
comment|/// cast in the \a Value hierarchy.  Besides creating boiler-plate, this
comment|/// requires subtle control flow changes.
comment|///
comment|/// The end-goal is to create a new type of metadata, called (e.g.) \a MDInt,
comment|/// so that metadata can refer to numbers without traversing a bridge to the \a
comment|/// Value hierarchy.  In this final state, the code above would look like this:
comment|///
comment|/// \code
comment|///     MDNode *N = ...;
comment|///     auto *MI = dyn_cast<MDInt>(N->getOperand(2));
comment|/// \endcode
comment|///
comment|/// The API in this namespace supports the transition.  \a MDInt doesn't exist
comment|/// yet, and even once it does, changing each metadata schema to use it is its
comment|/// own mini-project.  In the meantime this API prevents us from introducing
comment|/// complex and bug-prone control flow that will disappear in the end.  In
comment|/// particular, the above code looks like this:
comment|///
comment|/// \code
comment|///     MDNode *N = ...;
comment|///     auto *CI = mdconst::dyn_extract<ConstantInt>(N->getOperand(2));
comment|/// \endcode
comment|///
comment|/// The full set of provided functions includes:
comment|///
comment|///   mdconst::hasa<=> isa
comment|///   mdconst::extract<=> cast
comment|///   mdconst::extract_or_null<=> cast_or_null
comment|///   mdconst::dyn_extract<=> dyn_cast
comment|///   mdconst::dyn_extract_or_null<=> dyn_cast_or_null
comment|///
comment|/// The target of the cast must be a subclass of \a Constant.
name|namespace
name|mdconst
block|{
name|namespace
name|detail
block|{
name|template
operator|<
name|class
name|T
operator|>
name|T
operator|&
name|make
argument_list|()
block|;
name|template
operator|<
name|class
name|T
block|,
name|class
name|Result
operator|>
expr|struct
name|HasDereference
block|{
name|using
name|Yes
operator|=
name|char
index|[
literal|1
index|]
block|;
name|using
name|No
operator|=
name|char
index|[
literal|2
index|]
block|;
name|template
operator|<
name|size_t
name|N
operator|>
expr|struct
name|SFINAE
block|{}
block|;
name|template
operator|<
name|class
name|U
block|,
name|class
name|V
operator|>
specifier|static
name|Yes
operator|&
name|hasDereference
argument_list|(
name|SFINAE
operator|<
sizeof|sizeof
argument_list|(
name|static_cast
operator|<
name|V
operator|>
operator|(
operator|*
name|make
operator|<
name|U
operator|>
operator|(
operator|)
operator|)
argument_list|)
operator|>
operator|*
operator|=
literal|0
argument_list|)
block|;
name|template
operator|<
name|class
name|U
block|,
name|class
name|V
operator|>
specifier|static
name|No
operator|&
name|hasDereference
argument_list|(
operator|...
argument_list|)
block|;
specifier|static
specifier|const
name|bool
name|value
operator|=
sizeof|sizeof
argument_list|(
name|hasDereference
operator|<
name|T
argument_list|,
name|Result
operator|>
operator|(
name|nullptr
operator|)
argument_list|)
operator|==
sizeof|sizeof
argument_list|(
name|Yes
argument_list|)
block|; }
block|;
name|template
operator|<
name|class
name|V
block|,
name|class
name|M
operator|>
expr|struct
name|IsValidPointer
block|{
specifier|static
specifier|const
name|bool
name|value
operator|=
name|std
operator|::
name|is_base_of
operator|<
name|Constant
block|,
name|V
operator|>
operator|::
name|value
operator|&&
name|HasDereference
operator|<
name|M
block|,
specifier|const
name|Metadata
operator|&
operator|>
operator|::
name|value
block|; }
block|;
name|template
operator|<
name|class
name|V
block|,
name|class
name|M
operator|>
expr|struct
name|IsValidReference
block|{
specifier|static
specifier|const
name|bool
name|value
operator|=
name|std
operator|::
name|is_base_of
operator|<
name|Constant
block|,
name|V
operator|>
operator|::
name|value
operator|&&
name|std
operator|::
name|is_convertible
operator|<
name|M
block|,
specifier|const
name|Metadata
operator|&
operator|>
operator|::
name|value
block|; }
block|;  }
comment|// end namespace detail
comment|/// \brief Check whether Metadata has a Value.
comment|///
comment|/// As an analogue to \a isa(), check whether \c MD has an \a Value inside of
comment|/// type \c X.
name|template
operator|<
name|class
name|X
block|,
name|class
name|Y
operator|>
specifier|inline
name|typename
name|std
operator|::
name|enable_if
operator|<
name|detail
operator|::
name|IsValidPointer
operator|<
name|X
block|,
name|Y
operator|>
operator|::
name|value
block|,
name|bool
operator|>
operator|::
name|type
name|hasa
argument_list|(
argument|Y&&MD
argument_list|)
block|{
name|assert
argument_list|(
name|MD
operator|&&
literal|"Null pointer sent into hasa"
argument_list|)
block|;
if|if
condition|(
name|auto
operator|*
name|V
operator|=
name|dyn_cast
operator|<
name|ConstantAsMetadata
operator|>
operator|(
name|MD
operator|)
condition|)
return|return
name|isa
operator|<
name|X
operator|>
operator|(
name|V
operator|->
name|getValue
argument_list|()
operator|)
return|;
return|return
name|false
return|;
block|}
name|template
operator|<
name|class
name|X
block|,
name|class
name|Y
operator|>
specifier|inline
name|typename
name|std
operator|::
name|enable_if
operator|<
name|detail
operator|::
name|IsValidReference
operator|<
name|X
block|,
name|Y
operator|&
operator|>
operator|::
name|value
block|,
name|bool
operator|>
operator|::
name|type
name|hasa
argument_list|(
argument|Y&MD
argument_list|)
block|{
return|return
name|hasa
argument_list|(
operator|&
name|MD
argument_list|)
return|;
block|}
comment|/// \brief Extract a Value from Metadata.
comment|///
comment|/// As an analogue to \a cast(), extract the \a Value subclass \c X from \c MD.
name|template
operator|<
name|class
name|X
block|,
name|class
name|Y
operator|>
specifier|inline
name|typename
name|std
operator|::
name|enable_if
operator|<
name|detail
operator|::
name|IsValidPointer
operator|<
name|X
block|,
name|Y
operator|>
operator|::
name|value
block|,
name|X
operator|*
operator|>
operator|::
name|type
name|extract
argument_list|(
argument|Y&&MD
argument_list|)
block|{
return|return
name|cast
operator|<
name|X
operator|>
operator|(
name|cast
operator|<
name|ConstantAsMetadata
operator|>
operator|(
name|MD
operator|)
operator|->
name|getValue
argument_list|()
operator|)
return|;
block|}
name|template
operator|<
name|class
name|X
block|,
name|class
name|Y
operator|>
specifier|inline
name|typename
name|std
operator|::
name|enable_if
operator|<
name|detail
operator|::
name|IsValidReference
operator|<
name|X
block|,
name|Y
operator|&
operator|>
operator|::
name|value
block|,
name|X
operator|*
operator|>
operator|::
name|type
name|extract
argument_list|(
argument|Y&MD
argument_list|)
block|{
return|return
name|extract
argument_list|(
operator|&
name|MD
argument_list|)
return|;
block|}
comment|/// \brief Extract a Value from Metadata, allowing null.
comment|///
comment|/// As an analogue to \a cast_or_null(), extract the \a Value subclass \c X
comment|/// from \c MD, allowing \c MD to be null.
name|template
operator|<
name|class
name|X
block|,
name|class
name|Y
operator|>
specifier|inline
name|typename
name|std
operator|::
name|enable_if
operator|<
name|detail
operator|::
name|IsValidPointer
operator|<
name|X
block|,
name|Y
operator|>
operator|::
name|value
block|,
name|X
operator|*
operator|>
operator|::
name|type
name|extract_or_null
argument_list|(
argument|Y&&MD
argument_list|)
block|{
if|if
condition|(
name|auto
operator|*
name|V
operator|=
name|cast_or_null
operator|<
name|ConstantAsMetadata
operator|>
operator|(
name|MD
operator|)
condition|)
return|return
name|cast
operator|<
name|X
operator|>
operator|(
name|V
operator|->
name|getValue
argument_list|()
operator|)
return|;
return|return
name|nullptr
return|;
block|}
comment|/// \brief Extract a Value from Metadata, if any.
comment|///
comment|/// As an analogue to \a dyn_cast_or_null(), extract the \a Value subclass \c X
comment|/// from \c MD, return null if \c MD doesn't contain a \a Value or if the \a
comment|/// Value it does contain is of the wrong subclass.
name|template
operator|<
name|class
name|X
block|,
name|class
name|Y
operator|>
specifier|inline
name|typename
name|std
operator|::
name|enable_if
operator|<
name|detail
operator|::
name|IsValidPointer
operator|<
name|X
block|,
name|Y
operator|>
operator|::
name|value
block|,
name|X
operator|*
operator|>
operator|::
name|type
name|dyn_extract
argument_list|(
argument|Y&&MD
argument_list|)
block|{
if|if
condition|(
name|auto
operator|*
name|V
operator|=
name|dyn_cast
operator|<
name|ConstantAsMetadata
operator|>
operator|(
name|MD
operator|)
condition|)
return|return
name|dyn_cast
operator|<
name|X
operator|>
operator|(
name|V
operator|->
name|getValue
argument_list|()
operator|)
return|;
return|return
name|nullptr
return|;
block|}
comment|/// \brief Extract a Value from Metadata, if any, allowing null.
comment|///
comment|/// As an analogue to \a dyn_cast_or_null(), extract the \a Value subclass \c X
comment|/// from \c MD, return null if \c MD doesn't contain a \a Value or if the \a
comment|/// Value it does contain is of the wrong subclass, allowing \c MD to be null.
name|template
operator|<
name|class
name|X
operator|,
name|class
name|Y
operator|>
specifier|inline
name|typename
name|std
operator|::
name|enable_if
operator|<
name|detail
operator|::
name|IsValidPointer
operator|<
name|X
operator|,
name|Y
operator|>
operator|::
name|value
operator|,
name|X
operator|*
operator|>
operator|::
name|type
name|dyn_extract_or_null
argument_list|(
argument|Y&&MD
argument_list|)
block|{
if|if
condition|(
name|auto
operator|*
name|V
operator|=
name|dyn_cast_or_null
operator|<
name|ConstantAsMetadata
operator|>
operator|(
name|MD
operator|)
condition|)
return|return
name|dyn_cast
operator|<
name|X
operator|>
operator|(
name|V
operator|->
name|getValue
argument_list|()
operator|)
return|;
return|return
name|nullptr
return|;
block|}
end_decl_stmt

begin_comment
unit|}
comment|// end namespace mdconst
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|/// \brief A single uniqued string.
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|/// These are used to efficiently contain a byte sequence for metadata.
end_comment

begin_comment
comment|/// MDString is always unnamed.
end_comment

begin_label
unit|class
name|MDString
label|:
end_label

begin_decl_stmt
name|public
name|Metadata
block|{
name|friend
name|class
name|StringMapEntry
operator|<
name|MDString
operator|>
expr_stmt|;
name|StringMapEntry
operator|<
name|MDString
operator|>
operator|*
name|Entry
operator|=
name|nullptr
expr_stmt|;
name|MDString
argument_list|()
operator|:
name|Metadata
argument_list|(
argument|MDStringKind
argument_list|,
argument|Uniqued
argument_list|)
block|{}
name|public
operator|:
name|MDString
argument_list|(
specifier|const
name|MDString
operator|&
argument_list|)
operator|=
name|delete
expr_stmt|;
name|MDString
modifier|&
name|operator
init|=
operator|(
name|MDString
operator|&&
operator|)
operator|=
name|delete
decl_stmt|;
name|MDString
modifier|&
name|operator
init|=
operator|(
specifier|const
name|MDString
operator|&
operator|)
operator|=
name|delete
decl_stmt|;
specifier|static
name|MDString
modifier|*
name|get
parameter_list|(
name|LLVMContext
modifier|&
name|Context
parameter_list|,
name|StringRef
name|Str
parameter_list|)
function_decl|;
specifier|static
name|MDString
modifier|*
name|get
parameter_list|(
name|LLVMContext
modifier|&
name|Context
parameter_list|,
specifier|const
name|char
modifier|*
name|Str
parameter_list|)
block|{
return|return
name|get
argument_list|(
name|Context
argument_list|,
name|Str
condition|?
name|StringRef
argument_list|(
name|Str
argument_list|)
else|:
name|StringRef
argument_list|()
argument_list|)
return|;
block|}
name|StringRef
name|getString
argument_list|()
specifier|const
expr_stmt|;
name|unsigned
name|getLength
argument_list|()
specifier|const
block|{
return|return
operator|(
name|unsigned
operator|)
name|getString
argument_list|()
operator|.
name|size
argument_list|()
return|;
block|}
name|using
name|iterator
init|=
name|StringRef
operator|::
name|iterator
decl_stmt|;
comment|/// \brief Pointer to the first byte of the string.
name|iterator
name|begin
argument_list|()
specifier|const
block|{
return|return
name|getString
argument_list|()
operator|.
name|begin
argument_list|()
return|;
block|}
comment|/// \brief Pointer to one byte past the end of the string.
name|iterator
name|end
argument_list|()
specifier|const
block|{
return|return
name|getString
argument_list|()
operator|.
name|end
argument_list|()
return|;
block|}
specifier|const
name|unsigned
name|char
operator|*
name|bytes_begin
argument_list|()
specifier|const
block|{
return|return
name|getString
argument_list|()
operator|.
name|bytes_begin
argument_list|()
return|;
block|}
specifier|const
name|unsigned
name|char
operator|*
name|bytes_end
argument_list|()
specifier|const
block|{
return|return
name|getString
argument_list|()
operator|.
name|bytes_end
argument_list|()
return|;
block|}
comment|/// \brief Methods for support type inquiry through isa, cast, and dyn_cast.
specifier|static
name|bool
name|classof
parameter_list|(
specifier|const
name|Metadata
modifier|*
name|MD
parameter_list|)
block|{
return|return
name|MD
operator|->
name|getMetadataID
argument_list|()
operator|==
name|MDStringKind
return|;
block|}
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_comment
comment|/// \brief A collection of metadata nodes that might be associated with a
end_comment

begin_comment
comment|/// memory access used by the alias-analysis infrastructure.
end_comment

begin_struct
struct|struct
name|AAMDNodes
block|{
name|explicit
name|AAMDNodes
argument_list|(
name|MDNode
operator|*
name|T
operator|=
name|nullptr
argument_list|,
name|MDNode
operator|*
name|S
operator|=
name|nullptr
argument_list|,
name|MDNode
operator|*
name|N
operator|=
name|nullptr
argument_list|)
operator|:
name|TBAA
argument_list|(
name|T
argument_list|)
operator|,
name|Scope
argument_list|(
name|S
argument_list|)
operator|,
name|NoAlias
argument_list|(
argument|N
argument_list|)
block|{}
name|bool
name|operator
operator|==
operator|(
specifier|const
name|AAMDNodes
operator|&
name|A
operator|)
specifier|const
block|{
return|return
name|TBAA
operator|==
name|A
operator|.
name|TBAA
operator|&&
name|Scope
operator|==
name|A
operator|.
name|Scope
operator|&&
name|NoAlias
operator|==
name|A
operator|.
name|NoAlias
return|;
block|}
name|bool
name|operator
operator|!=
operator|(
specifier|const
name|AAMDNodes
operator|&
name|A
operator|)
specifier|const
block|{
return|return
operator|!
operator|(
operator|*
name|this
operator|==
name|A
operator|)
return|;
block|}
name|explicit
name|operator
name|bool
argument_list|()
specifier|const
block|{
return|return
name|TBAA
operator|||
name|Scope
operator|||
name|NoAlias
return|;
block|}
comment|/// \brief The tag for type-based alias analysis.
name|MDNode
modifier|*
name|TBAA
decl_stmt|;
comment|/// \brief The tag for alias scope specification (used with noalias).
name|MDNode
modifier|*
name|Scope
decl_stmt|;
comment|/// \brief The tag specifying the noalias scope.
name|MDNode
modifier|*
name|NoAlias
decl_stmt|;
comment|/// \brief Given two sets of AAMDNodes that apply to the same pointer,
comment|/// give the best AAMDNodes that are compatible with both (i.e. a set of
comment|/// nodes whose allowable aliasing conclusions are a subset of those
comment|/// allowable by both of the inputs). However, for efficiency
comment|/// reasons, do not create any new MDNodes.
name|AAMDNodes
name|intersect
parameter_list|(
specifier|const
name|AAMDNodes
modifier|&
name|Other
parameter_list|)
block|{
name|AAMDNodes
name|Result
decl_stmt|;
name|Result
operator|.
name|TBAA
operator|=
name|Other
operator|.
name|TBAA
operator|==
name|TBAA
condition|?
name|TBAA
else|:
name|nullptr
expr_stmt|;
name|Result
operator|.
name|Scope
operator|=
name|Other
operator|.
name|Scope
operator|==
name|Scope
condition|?
name|Scope
else|:
name|nullptr
expr_stmt|;
name|Result
operator|.
name|NoAlias
operator|=
name|Other
operator|.
name|NoAlias
operator|==
name|NoAlias
condition|?
name|NoAlias
else|:
name|nullptr
expr_stmt|;
return|return
name|Result
return|;
block|}
block|}
struct|;
end_struct

begin_comment
comment|// Specialize DenseMapInfo for AAMDNodes.
end_comment

begin_expr_stmt
name|template
operator|<
operator|>
expr|struct
name|DenseMapInfo
operator|<
name|AAMDNodes
operator|>
block|{
specifier|static
specifier|inline
name|AAMDNodes
name|getEmptyKey
argument_list|()
block|{
return|return
name|AAMDNodes
argument_list|(
name|DenseMapInfo
operator|<
name|MDNode
operator|*
operator|>
operator|::
name|getEmptyKey
argument_list|()
argument_list|,
name|nullptr
argument_list|,
name|nullptr
argument_list|)
return|;
block|}
specifier|static
specifier|inline
name|AAMDNodes
name|getTombstoneKey
argument_list|()
block|{
return|return
name|AAMDNodes
argument_list|(
name|DenseMapInfo
operator|<
name|MDNode
operator|*
operator|>
operator|::
name|getTombstoneKey
argument_list|()
argument_list|,
name|nullptr
argument_list|,
name|nullptr
argument_list|)
return|;
block|}
end_expr_stmt

begin_function
specifier|static
name|unsigned
name|getHashValue
parameter_list|(
specifier|const
name|AAMDNodes
modifier|&
name|Val
parameter_list|)
block|{
return|return
name|DenseMapInfo
operator|<
name|MDNode
operator|*
operator|>
operator|::
name|getHashValue
argument_list|(
name|Val
operator|.
name|TBAA
argument_list|)
operator|^
name|DenseMapInfo
operator|<
name|MDNode
operator|*
operator|>
operator|::
name|getHashValue
argument_list|(
name|Val
operator|.
name|Scope
argument_list|)
operator|^
name|DenseMapInfo
operator|<
name|MDNode
operator|*
operator|>
operator|::
name|getHashValue
argument_list|(
name|Val
operator|.
name|NoAlias
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|isEqual
parameter_list|(
specifier|const
name|AAMDNodes
modifier|&
name|LHS
parameter_list|,
specifier|const
name|AAMDNodes
modifier|&
name|RHS
parameter_list|)
block|{
return|return
name|LHS
operator|==
name|RHS
return|;
block|}
end_function

begin_comment
unit|};
comment|/// \brief Tracking metadata reference owned by Metadata.
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|/// Similar to \a TrackingMDRef, but it's expected to be owned by an instance
end_comment

begin_comment
comment|/// of \a Metadata, which has the option of registering itself for callbacks to
end_comment

begin_comment
comment|/// re-unique itself.
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|/// In particular, this is used by \a MDNode.
end_comment

begin_decl_stmt
name|class
name|MDOperand
block|{
name|Metadata
modifier|*
name|MD
init|=
name|nullptr
decl_stmt|;
name|public
label|:
name|MDOperand
argument_list|()
operator|=
expr|default
expr_stmt|;
name|MDOperand
argument_list|(
name|MDOperand
operator|&&
argument_list|)
operator|=
name|delete
expr_stmt|;
name|MDOperand
argument_list|(
specifier|const
name|MDOperand
operator|&
argument_list|)
operator|=
name|delete
expr_stmt|;
name|MDOperand
modifier|&
name|operator
init|=
operator|(
name|MDOperand
operator|&&
operator|)
operator|=
name|delete
decl_stmt|;
name|MDOperand
modifier|&
name|operator
init|=
operator|(
specifier|const
name|MDOperand
operator|&
operator|)
operator|=
name|delete
decl_stmt|;
operator|~
name|MDOperand
argument_list|()
block|{
name|untrack
argument_list|()
block|; }
name|Metadata
operator|*
name|get
argument_list|()
specifier|const
block|{
return|return
name|MD
return|;
block|}
name|operator
name|Metadata
operator|*
operator|(
operator|)
specifier|const
block|{
return|return
name|get
argument_list|()
return|;
block|}
name|Metadata
operator|*
name|operator
operator|->
expr|(
block|)
decl|const
block|{
return|return
name|get
argument_list|()
return|;
block|}
end_decl_stmt

begin_expr_stmt
name|Metadata
operator|&
name|operator
operator|*
operator|(
operator|)
specifier|const
block|{
return|return
operator|*
name|get
argument_list|()
return|;
block|}
end_expr_stmt

begin_function
name|void
name|reset
parameter_list|()
block|{
name|untrack
argument_list|()
expr_stmt|;
name|MD
operator|=
name|nullptr
expr_stmt|;
block|}
end_function

begin_function
name|void
name|reset
parameter_list|(
name|Metadata
modifier|*
name|MD
parameter_list|,
name|Metadata
modifier|*
name|Owner
parameter_list|)
block|{
name|untrack
argument_list|()
expr_stmt|;
name|this
operator|->
name|MD
operator|=
name|MD
expr_stmt|;
name|track
argument_list|(
name|Owner
argument_list|)
expr_stmt|;
block|}
end_function

begin_label
name|private
label|:
end_label

begin_function
name|void
name|track
parameter_list|(
name|Metadata
modifier|*
name|Owner
parameter_list|)
block|{
if|if
condition|(
name|MD
condition|)
block|{
if|if
condition|(
name|Owner
condition|)
name|MetadataTracking
operator|::
name|track
argument_list|(
name|this
argument_list|,
operator|*
name|MD
argument_list|,
operator|*
name|Owner
argument_list|)
expr_stmt|;
else|else
name|MetadataTracking
operator|::
name|track
argument_list|(
name|MD
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|untrack
parameter_list|()
block|{
name|assert
argument_list|(
name|static_cast
operator|<
name|void
operator|*
operator|>
operator|(
name|this
operator|)
operator|==
operator|&
name|MD
operator|&&
literal|"Expected same address"
argument_list|)
expr_stmt|;
if|if
condition|(
name|MD
condition|)
name|MetadataTracking
operator|::
name|untrack
argument_list|(
name|MD
argument_list|)
expr_stmt|;
block|}
end_function

begin_expr_stmt
unit|};
name|template
operator|<
operator|>
expr|struct
name|simplify_type
operator|<
name|MDOperand
operator|>
block|{
name|using
name|SimpleType
operator|=
name|Metadata
operator|*
block|;
specifier|static
name|SimpleType
name|getSimplifiedValue
argument_list|(
argument|MDOperand&MD
argument_list|)
block|{
return|return
name|MD
operator|.
name|get
argument_list|()
return|;
block|}
end_expr_stmt

begin_expr_stmt
unit|};
name|template
operator|<
operator|>
expr|struct
name|simplify_type
operator|<
specifier|const
name|MDOperand
operator|>
block|{
name|using
name|SimpleType
operator|=
name|Metadata
operator|*
block|;
specifier|static
name|SimpleType
name|getSimplifiedValue
argument_list|(
argument|const MDOperand&MD
argument_list|)
block|{
return|return
name|MD
operator|.
name|get
argument_list|()
return|;
block|}
end_expr_stmt

begin_comment
unit|};
comment|/// \brief Pointer to the context, with optional RAUW support.
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|/// Either a raw (non-null) pointer to the \a LLVMContext, or an owned pointer
end_comment

begin_comment
comment|/// to \a ReplaceableMetadataImpl (which has a reference to \a LLVMContext).
end_comment

begin_decl_stmt
name|class
name|ContextAndReplaceableUses
block|{
name|PointerUnion
operator|<
name|LLVMContext
operator|*
operator|,
name|ReplaceableMetadataImpl
operator|*
operator|>
name|Ptr
expr_stmt|;
name|public
label|:
name|ContextAndReplaceableUses
argument_list|(
name|LLVMContext
operator|&
name|Context
argument_list|)
operator|:
name|Ptr
argument_list|(
argument|&Context
argument_list|)
block|{}
name|ContextAndReplaceableUses
argument_list|(
name|std
operator|::
name|unique_ptr
operator|<
name|ReplaceableMetadataImpl
operator|>
name|ReplaceableUses
argument_list|)
operator|:
name|Ptr
argument_list|(
argument|ReplaceableUses.release()
argument_list|)
block|{
name|assert
argument_list|(
name|getReplaceableUses
argument_list|()
operator|&&
literal|"Expected non-null replaceable uses"
argument_list|)
block|;   }
name|ContextAndReplaceableUses
argument_list|()
operator|=
name|delete
expr_stmt|;
name|ContextAndReplaceableUses
argument_list|(
name|ContextAndReplaceableUses
operator|&&
argument_list|)
operator|=
name|delete
expr_stmt|;
name|ContextAndReplaceableUses
argument_list|(
specifier|const
name|ContextAndReplaceableUses
operator|&
argument_list|)
operator|=
name|delete
expr_stmt|;
name|ContextAndReplaceableUses
modifier|&
name|operator
init|=
operator|(
name|ContextAndReplaceableUses
operator|&&
operator|)
operator|=
name|delete
decl_stmt|;
name|ContextAndReplaceableUses
modifier|&
name|operator
init|=
operator|(
specifier|const
name|ContextAndReplaceableUses
operator|&
operator|)
operator|=
name|delete
decl_stmt|;
operator|~
name|ContextAndReplaceableUses
argument_list|()
block|{
name|delete
name|getReplaceableUses
argument_list|()
block|; }
name|operator
name|LLVMContext
operator|&
operator|(
operator|)
block|{
return|return
name|getContext
argument_list|()
return|;
block|}
comment|/// \brief Whether this contains RAUW support.
name|bool
name|hasReplaceableUses
argument_list|()
specifier|const
block|{
return|return
name|Ptr
operator|.
name|is
operator|<
name|ReplaceableMetadataImpl
operator|*
operator|>
operator|(
operator|)
return|;
block|}
name|LLVMContext
operator|&
name|getContext
argument_list|()
specifier|const
block|{
if|if
condition|(
name|hasReplaceableUses
argument_list|()
condition|)
return|return
name|getReplaceableUses
argument_list|()
operator|->
name|getContext
argument_list|()
return|;
return|return
operator|*
name|Ptr
operator|.
name|get
operator|<
name|LLVMContext
operator|*
operator|>
operator|(
operator|)
return|;
block|}
end_decl_stmt

begin_expr_stmt
name|ReplaceableMetadataImpl
operator|*
name|getReplaceableUses
argument_list|()
specifier|const
block|{
if|if
condition|(
name|hasReplaceableUses
argument_list|()
condition|)
return|return
name|Ptr
operator|.
name|get
operator|<
name|ReplaceableMetadataImpl
operator|*
operator|>
operator|(
operator|)
return|;
end_expr_stmt

begin_return
return|return
name|nullptr
return|;
end_return

begin_comment
unit|}
comment|/// Ensure that this has RAUW support, and then return it.
end_comment

begin_expr_stmt
unit|ReplaceableMetadataImpl
operator|*
name|getOrCreateReplaceableUses
argument_list|()
block|{
if|if
condition|(
operator|!
name|hasReplaceableUses
argument_list|()
condition|)
name|makeReplaceable
argument_list|(
name|llvm
operator|::
name|make_unique
operator|<
name|ReplaceableMetadataImpl
operator|>
operator|(
name|getContext
argument_list|()
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|getReplaceableUses
argument_list|()
return|;
end_return

begin_comment
unit|}
comment|/// \brief Assign RAUW support to this.
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|/// Make this replaceable, taking ownership of \c ReplaceableUses (which must
end_comment

begin_comment
comment|/// not be null).
end_comment

begin_macro
unit|void
name|makeReplaceable
argument_list|(
argument|std::unique_ptr<ReplaceableMetadataImpl> ReplaceableUses
argument_list|)
end_macro

begin_block
block|{
name|assert
argument_list|(
name|ReplaceableUses
operator|&&
literal|"Expected non-null replaceable uses"
argument_list|)
expr_stmt|;
name|assert
argument_list|(
operator|&
name|ReplaceableUses
operator|->
name|getContext
argument_list|()
operator|==
operator|&
name|getContext
argument_list|()
operator|&&
literal|"Expected same context"
argument_list|)
expr_stmt|;
name|delete
name|getReplaceableUses
parameter_list|()
function_decl|;
name|Ptr
operator|=
name|ReplaceableUses
operator|.
name|release
argument_list|()
expr_stmt|;
block|}
end_block

begin_comment
comment|/// \brief Drop RAUW support.
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|/// Cede ownership of RAUW support, returning it.
end_comment

begin_expr_stmt
name|std
operator|::
name|unique_ptr
operator|<
name|ReplaceableMetadataImpl
operator|>
name|takeReplaceableUses
argument_list|()
block|{
name|assert
argument_list|(
name|hasReplaceableUses
argument_list|()
operator|&&
literal|"Expected to own replaceable uses"
argument_list|)
block|;
name|std
operator|::
name|unique_ptr
operator|<
name|ReplaceableMetadataImpl
operator|>
name|ReplaceableUses
argument_list|(
name|getReplaceableUses
argument_list|()
argument_list|)
block|;
name|Ptr
operator|=
operator|&
name|ReplaceableUses
operator|->
name|getContext
argument_list|()
block|;
return|return
name|ReplaceableUses
return|;
block|}
end_expr_stmt

begin_struct
unit|};
struct|struct
name|TempMDNodeDeleter
block|{
specifier|inline
name|void
name|operator
argument_list|()
operator|(
name|MDNode
operator|*
name|Node
operator|)
specifier|const
expr_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|HANDLE_MDNODE_LEAF
parameter_list|(
name|CLASS
parameter_list|)
define|\
value|using Temp##CLASS = std::unique_ptr<CLASS, TempMDNodeDeleter>;
end_define

begin_define
define|#
directive|define
name|HANDLE_MDNODE_BRANCH
parameter_list|(
name|CLASS
parameter_list|)
value|HANDLE_MDNODE_LEAF(CLASS)
end_define

begin_include
include|#
directive|include
file|"llvm/IR/Metadata.def"
end_include

begin_comment
comment|/// \brief Metadata node.
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|/// Metadata nodes can be uniqued, like constants, or distinct.  Temporary
end_comment

begin_comment
comment|/// metadata nodes (with full support for RAUW) can be used to delay uniquing
end_comment

begin_comment
comment|/// until forward references are known.  The basic metadata node is an \a
end_comment

begin_comment
comment|/// MDTuple.
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|/// There is limited support for RAUW at construction time.  At construction
end_comment

begin_comment
comment|/// time, if any operand is a temporary node (or an unresolved uniqued node,
end_comment

begin_comment
comment|/// which indicates a transitive temporary operand), the node itself will be
end_comment

begin_comment
comment|/// unresolved.  As soon as all operands become resolved, it will drop RAUW
end_comment

begin_comment
comment|/// support permanently.
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|/// If an unresolved node is part of a cycle, \a resolveCycles() needs
end_comment

begin_comment
comment|/// to be called on some member of the cycle once all temporary nodes have been
end_comment

begin_comment
comment|/// replaced.
end_comment

begin_decl_stmt
name|class
name|MDNode
range|:
name|public
name|Metadata
block|{
name|friend
name|class
name|ReplaceableMetadataImpl
block|;
name|friend
name|class
name|LLVMContextImpl
block|;
name|unsigned
name|NumOperands
block|;
name|unsigned
name|NumUnresolved
block|;
name|ContextAndReplaceableUses
name|Context
block|;
name|protected
operator|:
name|MDNode
argument_list|(
argument|LLVMContext&Context
argument_list|,
argument|unsigned ID
argument_list|,
argument|StorageType Storage
argument_list|,
argument|ArrayRef<Metadata *> Ops1
argument_list|,
argument|ArrayRef<Metadata *> Ops2 = None
argument_list|)
block|;
operator|~
name|MDNode
argument_list|()
operator|=
expr|default
block|;
name|void
operator|*
name|operator
name|new
argument_list|(
argument|size_t Size
argument_list|,
argument|unsigned NumOps
argument_list|)
block|;
name|void
name|operator
name|delete
argument_list|(
name|void
operator|*
name|Mem
argument_list|)
block|;
comment|/// \brief Required by std, but never called.
name|void
name|operator
name|delete
argument_list|(
argument|void *
argument_list|,
argument|unsigned
argument_list|)
block|{
name|llvm_unreachable
argument_list|(
literal|"Constructor throws?"
argument_list|)
block|;   }
comment|/// \brief Required by std, but never called.
name|void
name|operator
name|delete
argument_list|(
argument|void *
argument_list|,
argument|unsigned
argument_list|,
argument|bool
argument_list|)
block|{
name|llvm_unreachable
argument_list|(
literal|"Constructor throws?"
argument_list|)
block|;   }
name|void
name|dropAllReferences
argument_list|()
block|;
name|MDOperand
operator|*
name|mutable_begin
argument_list|()
block|{
return|return
name|mutable_end
argument_list|()
operator|-
name|NumOperands
return|;
block|}
name|MDOperand
operator|*
name|mutable_end
argument_list|()
block|{
return|return
name|reinterpret_cast
operator|<
name|MDOperand
operator|*
operator|>
operator|(
name|this
operator|)
return|;
block|}
name|using
name|mutable_op_range
operator|=
name|iterator_range
operator|<
name|MDOperand
operator|*
operator|>
block|;
name|mutable_op_range
name|mutable_operands
argument_list|()
block|{
return|return
name|mutable_op_range
argument_list|(
name|mutable_begin
argument_list|()
argument_list|,
name|mutable_end
argument_list|()
argument_list|)
return|;
block|}
name|public
operator|:
name|MDNode
argument_list|(
specifier|const
name|MDNode
operator|&
argument_list|)
operator|=
name|delete
block|;
name|void
name|operator
operator|=
operator|(
specifier|const
name|MDNode
operator|&
operator|)
operator|=
name|delete
block|;
name|void
operator|*
name|operator
name|new
argument_list|(
name|size_t
argument_list|)
operator|=
name|delete
block|;
specifier|static
specifier|inline
name|MDTuple
operator|*
name|get
argument_list|(
name|LLVMContext
operator|&
name|Context
argument_list|,
name|ArrayRef
operator|<
name|Metadata
operator|*
operator|>
name|MDs
argument_list|)
block|;
specifier|static
specifier|inline
name|MDTuple
operator|*
name|getIfExists
argument_list|(
name|LLVMContext
operator|&
name|Context
argument_list|,
name|ArrayRef
operator|<
name|Metadata
operator|*
operator|>
name|MDs
argument_list|)
block|;
specifier|static
specifier|inline
name|MDTuple
operator|*
name|getDistinct
argument_list|(
name|LLVMContext
operator|&
name|Context
argument_list|,
name|ArrayRef
operator|<
name|Metadata
operator|*
operator|>
name|MDs
argument_list|)
block|;
specifier|static
specifier|inline
name|TempMDTuple
name|getTemporary
argument_list|(
name|LLVMContext
operator|&
name|Context
argument_list|,
name|ArrayRef
operator|<
name|Metadata
operator|*
operator|>
name|MDs
argument_list|)
block|;
comment|/// \brief Create a (temporary) clone of this.
name|TempMDNode
name|clone
argument_list|()
specifier|const
block|;
comment|/// \brief Deallocate a node created by getTemporary.
comment|///
comment|/// Calls \c replaceAllUsesWith(nullptr) before deleting, so any remaining
comment|/// references will be reset.
specifier|static
name|void
name|deleteTemporary
argument_list|(
name|MDNode
operator|*
name|N
argument_list|)
block|;
name|LLVMContext
operator|&
name|getContext
argument_list|()
specifier|const
block|{
return|return
name|Context
operator|.
name|getContext
argument_list|()
return|;
block|}
comment|/// \brief Replace a specific operand.
name|void
name|replaceOperandWith
argument_list|(
argument|unsigned I
argument_list|,
argument|Metadata *New
argument_list|)
block|;
comment|/// \brief Check if node is fully resolved.
comment|///
comment|/// If \a isTemporary(), this always returns \c false; if \a isDistinct(),
comment|/// this always returns \c true.
comment|///
comment|/// If \a isUniqued(), returns \c true if this has already dropped RAUW
comment|/// support (because all operands are resolved).
comment|///
comment|/// As forward declarations are resolved, their containers should get
comment|/// resolved automatically.  However, if this (or one of its operands) is
comment|/// involved in a cycle, \a resolveCycles() needs to be called explicitly.
name|bool
name|isResolved
argument_list|()
specifier|const
block|{
return|return
operator|!
name|isTemporary
argument_list|()
operator|&&
operator|!
name|NumUnresolved
return|;
block|}
name|bool
name|isUniqued
argument_list|()
specifier|const
block|{
return|return
name|Storage
operator|==
name|Uniqued
return|;
block|}
name|bool
name|isDistinct
argument_list|()
specifier|const
block|{
return|return
name|Storage
operator|==
name|Distinct
return|;
block|}
name|bool
name|isTemporary
argument_list|()
specifier|const
block|{
return|return
name|Storage
operator|==
name|Temporary
return|;
block|}
comment|/// \brief RAUW a temporary.
comment|///
comment|/// \pre \a isTemporary() must be \c true.
name|void
name|replaceAllUsesWith
argument_list|(
argument|Metadata *MD
argument_list|)
block|{
name|assert
argument_list|(
name|isTemporary
argument_list|()
operator|&&
literal|"Expected temporary node"
argument_list|)
block|;
if|if
condition|(
name|Context
operator|.
name|hasReplaceableUses
argument_list|()
condition|)
name|Context
operator|.
name|getReplaceableUses
argument_list|()
operator|->
name|replaceAllUsesWith
argument_list|(
name|MD
argument_list|)
expr_stmt|;
block|}
comment|/// \brief Resolve cycles.
comment|///
comment|/// Once all forward declarations have been resolved, force cycles to be
comment|/// resolved.
comment|///
comment|/// \pre No operands (or operands' operands, etc.) have \a isTemporary().
name|void
name|resolveCycles
argument_list|()
block|;
comment|/// \brief Replace a temporary node with a permanent one.
comment|///
comment|/// Try to create a uniqued version of \c N -- in place, if possible -- and
comment|/// return it.  If \c N cannot be uniqued, return a distinct node instead.
name|template
operator|<
name|class
name|T
operator|>
specifier|static
name|typename
name|std
operator|::
name|enable_if
operator|<
name|std
operator|::
name|is_base_of
operator|<
name|MDNode
block|,
name|T
operator|>
operator|::
name|value
block|,
name|T
operator|*
operator|>
operator|::
name|type
name|replaceWithPermanent
argument_list|(
argument|std::unique_ptr<T
argument_list|,
argument|TempMDNodeDeleter> N
argument_list|)
block|{
return|return
name|cast
operator|<
name|T
operator|>
operator|(
name|N
operator|.
name|release
argument_list|()
operator|->
name|replaceWithPermanentImpl
argument_list|()
operator|)
return|;
block|}
comment|/// \brief Replace a temporary node with a uniqued one.
comment|///
comment|/// Create a uniqued version of \c N -- in place, if possible -- and return
comment|/// it.  Takes ownership of the temporary node.
comment|///
comment|/// \pre N does not self-reference.
name|template
operator|<
name|class
name|T
operator|>
specifier|static
name|typename
name|std
operator|::
name|enable_if
operator|<
name|std
operator|::
name|is_base_of
operator|<
name|MDNode
block|,
name|T
operator|>
operator|::
name|value
block|,
name|T
operator|*
operator|>
operator|::
name|type
name|replaceWithUniqued
argument_list|(
argument|std::unique_ptr<T
argument_list|,
argument|TempMDNodeDeleter> N
argument_list|)
block|{
return|return
name|cast
operator|<
name|T
operator|>
operator|(
name|N
operator|.
name|release
argument_list|()
operator|->
name|replaceWithUniquedImpl
argument_list|()
operator|)
return|;
block|}
comment|/// \brief Replace a temporary node with a distinct one.
comment|///
comment|/// Create a distinct version of \c N -- in place, if possible -- and return
comment|/// it.  Takes ownership of the temporary node.
name|template
operator|<
name|class
name|T
operator|>
specifier|static
name|typename
name|std
operator|::
name|enable_if
operator|<
name|std
operator|::
name|is_base_of
operator|<
name|MDNode
block|,
name|T
operator|>
operator|::
name|value
block|,
name|T
operator|*
operator|>
operator|::
name|type
name|replaceWithDistinct
argument_list|(
argument|std::unique_ptr<T
argument_list|,
argument|TempMDNodeDeleter> N
argument_list|)
block|{
return|return
name|cast
operator|<
name|T
operator|>
operator|(
name|N
operator|.
name|release
argument_list|()
operator|->
name|replaceWithDistinctImpl
argument_list|()
operator|)
return|;
block|}
name|private
operator|:
name|MDNode
operator|*
name|replaceWithPermanentImpl
argument_list|()
block|;
name|MDNode
operator|*
name|replaceWithUniquedImpl
argument_list|()
block|;
name|MDNode
operator|*
name|replaceWithDistinctImpl
argument_list|()
block|;
name|protected
operator|:
comment|/// \brief Set an operand.
comment|///
comment|/// Sets the operand directly, without worrying about uniquing.
name|void
name|setOperand
argument_list|(
argument|unsigned I
argument_list|,
argument|Metadata *New
argument_list|)
block|;
name|void
name|storeDistinctInContext
argument_list|()
block|;
name|template
operator|<
name|class
name|T
block|,
name|class
name|StoreT
operator|>
specifier|static
name|T
operator|*
name|storeImpl
argument_list|(
argument|T *N
argument_list|,
argument|StorageType Storage
argument_list|,
argument|StoreT&Store
argument_list|)
block|;
name|template
operator|<
name|class
name|T
operator|>
specifier|static
name|T
operator|*
name|storeImpl
argument_list|(
argument|T *N
argument_list|,
argument|StorageType Storage
argument_list|)
block|;
name|private
operator|:
name|void
name|handleChangedOperand
argument_list|(
name|void
operator|*
name|Ref
argument_list|,
name|Metadata
operator|*
name|New
argument_list|)
block|;
comment|/// Resolve a unique, unresolved node.
name|void
name|resolve
argument_list|()
block|;
comment|/// Drop RAUW support, if any.
name|void
name|dropReplaceableUses
argument_list|()
block|;
name|void
name|resolveAfterOperandChange
argument_list|(
name|Metadata
operator|*
name|Old
argument_list|,
name|Metadata
operator|*
name|New
argument_list|)
block|;
name|void
name|decrementUnresolvedOperandCount
argument_list|()
block|;
name|void
name|countUnresolvedOperands
argument_list|()
block|;
comment|/// \brief Mutate this to be "uniqued".
comment|///
comment|/// Mutate this so that \a isUniqued().
comment|/// \pre \a isTemporary().
comment|/// \pre already added to uniquing set.
name|void
name|makeUniqued
argument_list|()
block|;
comment|/// \brief Mutate this to be "distinct".
comment|///
comment|/// Mutate this so that \a isDistinct().
comment|/// \pre \a isTemporary().
name|void
name|makeDistinct
argument_list|()
block|;
name|void
name|deleteAsSubclass
argument_list|()
block|;
name|MDNode
operator|*
name|uniquify
argument_list|()
block|;
name|void
name|eraseFromStore
argument_list|()
block|;
name|template
operator|<
name|class
name|NodeTy
operator|>
expr|struct
name|HasCachedHash
block|;
name|template
operator|<
name|class
name|NodeTy
operator|>
specifier|static
name|void
name|dispatchRecalculateHash
argument_list|(
argument|NodeTy *N
argument_list|,
argument|std::true_type
argument_list|)
block|{
name|N
operator|->
name|recalculateHash
argument_list|()
block|;   }
name|template
operator|<
name|class
name|NodeTy
operator|>
specifier|static
name|void
name|dispatchRecalculateHash
argument_list|(
argument|NodeTy *
argument_list|,
argument|std::false_type
argument_list|)
block|{}
name|template
operator|<
name|class
name|NodeTy
operator|>
specifier|static
name|void
name|dispatchResetHash
argument_list|(
argument|NodeTy *N
argument_list|,
argument|std::true_type
argument_list|)
block|{
name|N
operator|->
name|setHash
argument_list|(
literal|0
argument_list|)
block|;   }
name|template
operator|<
name|class
name|NodeTy
operator|>
specifier|static
name|void
name|dispatchResetHash
argument_list|(
argument|NodeTy *
argument_list|,
argument|std::false_type
argument_list|)
block|{}
name|public
operator|:
name|using
name|op_iterator
operator|=
specifier|const
name|MDOperand
operator|*
block|;
name|using
name|op_range
operator|=
name|iterator_range
operator|<
name|op_iterator
operator|>
block|;
name|op_iterator
name|op_begin
argument_list|()
specifier|const
block|{
return|return
name|const_cast
operator|<
name|MDNode
operator|*
operator|>
operator|(
name|this
operator|)
operator|->
name|mutable_begin
argument_list|()
return|;
block|}
name|op_iterator
name|op_end
argument_list|()
specifier|const
block|{
return|return
name|const_cast
operator|<
name|MDNode
operator|*
operator|>
operator|(
name|this
operator|)
operator|->
name|mutable_end
argument_list|()
return|;
block|}
name|op_range
name|operands
argument_list|()
specifier|const
block|{
return|return
name|op_range
argument_list|(
name|op_begin
argument_list|()
argument_list|,
name|op_end
argument_list|()
argument_list|)
return|;
block|}
specifier|const
name|MDOperand
operator|&
name|getOperand
argument_list|(
argument|unsigned I
argument_list|)
specifier|const
block|{
name|assert
argument_list|(
name|I
operator|<
name|NumOperands
operator|&&
literal|"Out of range"
argument_list|)
block|;
return|return
name|op_begin
argument_list|()
index|[
name|I
index|]
return|;
block|}
comment|/// \brief Return number of MDNode operands.
name|unsigned
name|getNumOperands
argument_list|()
specifier|const
block|{
return|return
name|NumOperands
return|;
block|}
comment|/// \brief Methods for support type inquiry through isa, cast, and dyn_cast:
specifier|static
name|bool
name|classof
argument_list|(
argument|const Metadata *MD
argument_list|)
block|{
switch|switch
condition|(
name|MD
operator|->
name|getMetadataID
argument_list|()
condition|)
block|{
default|default:
return|return
name|false
return|;
define|#
directive|define
name|HANDLE_MDNODE_LEAF
parameter_list|(
name|CLASS
parameter_list|)
define|\
value|case CLASS##Kind:                                                            \     return true;
include|#
directive|include
file|"llvm/IR/Metadata.def"
block|}
block|}
comment|/// \brief Check whether MDNode is a vtable access.
name|bool
name|isTBAAVtableAccess
argument_list|()
specifier|const
block|;
comment|/// \brief Methods for metadata merging.
specifier|static
name|MDNode
operator|*
name|concatenate
argument_list|(
name|MDNode
operator|*
name|A
argument_list|,
name|MDNode
operator|*
name|B
argument_list|)
block|;
specifier|static
name|MDNode
operator|*
name|intersect
argument_list|(
name|MDNode
operator|*
name|A
argument_list|,
name|MDNode
operator|*
name|B
argument_list|)
block|;
specifier|static
name|MDNode
operator|*
name|getMostGenericTBAA
argument_list|(
name|MDNode
operator|*
name|A
argument_list|,
name|MDNode
operator|*
name|B
argument_list|)
block|;
specifier|static
name|MDNode
operator|*
name|getMostGenericFPMath
argument_list|(
name|MDNode
operator|*
name|A
argument_list|,
name|MDNode
operator|*
name|B
argument_list|)
block|;
specifier|static
name|MDNode
operator|*
name|getMostGenericRange
argument_list|(
name|MDNode
operator|*
name|A
argument_list|,
name|MDNode
operator|*
name|B
argument_list|)
block|;
specifier|static
name|MDNode
operator|*
name|getMostGenericAliasScope
argument_list|(
name|MDNode
operator|*
name|A
argument_list|,
name|MDNode
operator|*
name|B
argument_list|)
block|;
specifier|static
name|MDNode
operator|*
name|getMostGenericAlignmentOrDereferenceable
argument_list|(
name|MDNode
operator|*
name|A
argument_list|,
name|MDNode
operator|*
name|B
argument_list|)
block|; }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/// \brief Tuple of metadata.
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|/// This is the simple \a MDNode arbitrary tuple.  Nodes are uniqued by
end_comment

begin_comment
comment|/// default based on their operands.
end_comment

begin_decl_stmt
name|class
name|MDTuple
range|:
name|public
name|MDNode
block|{
name|friend
name|class
name|LLVMContextImpl
block|;
name|friend
name|class
name|MDNode
block|;
name|MDTuple
argument_list|(
argument|LLVMContext&C
argument_list|,
argument|StorageType Storage
argument_list|,
argument|unsigned Hash
argument_list|,
argument|ArrayRef<Metadata *> Vals
argument_list|)
operator|:
name|MDNode
argument_list|(
argument|C
argument_list|,
argument|MDTupleKind
argument_list|,
argument|Storage
argument_list|,
argument|Vals
argument_list|)
block|{
name|setHash
argument_list|(
name|Hash
argument_list|)
block|;   }
operator|~
name|MDTuple
argument_list|()
block|{
name|dropAllReferences
argument_list|()
block|; }
name|void
name|setHash
argument_list|(
argument|unsigned Hash
argument_list|)
block|{
name|SubclassData32
operator|=
name|Hash
block|; }
name|void
name|recalculateHash
argument_list|()
block|;
specifier|static
name|MDTuple
operator|*
name|getImpl
argument_list|(
argument|LLVMContext&Context
argument_list|,
argument|ArrayRef<Metadata *> MDs
argument_list|,
argument|StorageType Storage
argument_list|,
argument|bool ShouldCreate = true
argument_list|)
block|;
name|TempMDTuple
name|cloneImpl
argument_list|()
specifier|const
block|{
return|return
name|getTemporary
argument_list|(
name|getContext
argument_list|()
argument_list|,
name|SmallVector
operator|<
name|Metadata
operator|*
argument_list|,
literal|4
operator|>
operator|(
name|op_begin
argument_list|()
expr|,
name|op_end
argument_list|()
operator|)
argument_list|)
return|;
block|}
name|public
operator|:
comment|/// \brief Get the hash, if any.
name|unsigned
name|getHash
argument_list|()
specifier|const
block|{
return|return
name|SubclassData32
return|;
block|}
specifier|static
name|MDTuple
operator|*
name|get
argument_list|(
argument|LLVMContext&Context
argument_list|,
argument|ArrayRef<Metadata *> MDs
argument_list|)
block|{
return|return
name|getImpl
argument_list|(
name|Context
argument_list|,
name|MDs
argument_list|,
name|Uniqued
argument_list|)
return|;
block|}
specifier|static
name|MDTuple
operator|*
name|getIfExists
argument_list|(
argument|LLVMContext&Context
argument_list|,
argument|ArrayRef<Metadata *> MDs
argument_list|)
block|{
return|return
name|getImpl
argument_list|(
name|Context
argument_list|,
name|MDs
argument_list|,
name|Uniqued
argument_list|,
comment|/* ShouldCreate */
name|false
argument_list|)
return|;
block|}
comment|/// \brief Return a distinct node.
comment|///
comment|/// Return a distinct node -- i.e., a node that is not uniqued.
specifier|static
name|MDTuple
operator|*
name|getDistinct
argument_list|(
argument|LLVMContext&Context
argument_list|,
argument|ArrayRef<Metadata *> MDs
argument_list|)
block|{
return|return
name|getImpl
argument_list|(
name|Context
argument_list|,
name|MDs
argument_list|,
name|Distinct
argument_list|)
return|;
block|}
comment|/// \brief Return a temporary node.
comment|///
comment|/// For use in constructing cyclic MDNode structures. A temporary MDNode is
comment|/// not uniqued, may be RAUW'd, and must be manually deleted with
comment|/// deleteTemporary.
specifier|static
name|TempMDTuple
name|getTemporary
argument_list|(
argument|LLVMContext&Context
argument_list|,
argument|ArrayRef<Metadata *> MDs
argument_list|)
block|{
return|return
name|TempMDTuple
argument_list|(
name|getImpl
argument_list|(
name|Context
argument_list|,
name|MDs
argument_list|,
name|Temporary
argument_list|)
argument_list|)
return|;
block|}
comment|/// \brief Return a (temporary) clone of this.
name|TempMDTuple
name|clone
argument_list|()
specifier|const
block|{
return|return
name|cloneImpl
argument_list|()
return|;
block|}
specifier|static
name|bool
name|classof
argument_list|(
argument|const Metadata *MD
argument_list|)
block|{
return|return
name|MD
operator|->
name|getMetadataID
argument_list|()
operator|==
name|MDTupleKind
return|;
block|}
expr|}
block|;
name|MDTuple
operator|*
name|MDNode
operator|::
name|get
argument_list|(
argument|LLVMContext&Context
argument_list|,
argument|ArrayRef<Metadata *> MDs
argument_list|)
block|{
return|return
name|MDTuple
operator|::
name|get
argument_list|(
name|Context
argument_list|,
name|MDs
argument_list|)
return|;
block|}
name|MDTuple
operator|*
name|MDNode
operator|::
name|getIfExists
argument_list|(
argument|LLVMContext&Context
argument_list|,
argument|ArrayRef<Metadata *> MDs
argument_list|)
block|{
return|return
name|MDTuple
operator|::
name|getIfExists
argument_list|(
name|Context
argument_list|,
name|MDs
argument_list|)
return|;
block|}
name|MDTuple
operator|*
name|MDNode
operator|::
name|getDistinct
argument_list|(
argument|LLVMContext&Context
argument_list|,
argument|ArrayRef<Metadata *> MDs
argument_list|)
block|{
return|return
name|MDTuple
operator|::
name|getDistinct
argument_list|(
name|Context
argument_list|,
name|MDs
argument_list|)
return|;
block|}
name|TempMDTuple
name|MDNode
operator|::
name|getTemporary
argument_list|(
argument|LLVMContext&Context
argument_list|,
argument|ArrayRef<Metadata *> MDs
argument_list|)
block|{
return|return
name|MDTuple
operator|::
name|getTemporary
argument_list|(
name|Context
argument_list|,
name|MDs
argument_list|)
return|;
block|}
name|void
name|TempMDNodeDeleter
operator|::
name|operator
argument_list|()
operator|(
name|MDNode
operator|*
name|Node
operator|)
specifier|const
block|{
name|MDNode
operator|::
name|deleteTemporary
argument_list|(
name|Node
argument_list|)
block|; }
comment|/// \brief Typed iterator through MDNode operands.
comment|///
comment|/// An iterator that transforms an \a MDNode::iterator into an iterator over a
comment|/// particular Metadata subclass.
name|template
operator|<
name|class
name|T
operator|>
name|class
name|TypedMDOperandIterator
operator|:
name|std
operator|::
name|iterator
operator|<
name|std
operator|::
name|input_iterator_tag
block|,
name|T
operator|*
block|,
name|std
operator|::
name|ptrdiff_t
block|,
name|void
block|,
name|T
operator|*
operator|>
block|{
name|MDNode
operator|::
name|op_iterator
name|I
operator|=
name|nullptr
block|;
name|public
operator|:
name|TypedMDOperandIterator
argument_list|()
operator|=
expr|default
block|;
name|explicit
name|TypedMDOperandIterator
argument_list|(
argument|MDNode::op_iterator I
argument_list|)
operator|:
name|I
argument_list|(
argument|I
argument_list|)
block|{}
name|T
operator|*
name|operator
operator|*
operator|(
operator|)
specifier|const
block|{
return|return
name|cast_or_null
operator|<
name|T
operator|>
operator|(
operator|*
name|I
operator|)
return|;
block|}
name|TypedMDOperandIterator
operator|&
name|operator
operator|++
operator|(
operator|)
block|{
operator|++
name|I
block|;
return|return
operator|*
name|this
return|;
block|}
name|TypedMDOperandIterator
name|operator
operator|++
operator|(
name|int
operator|)
block|{
name|TypedMDOperandIterator
name|Temp
argument_list|(
operator|*
name|this
argument_list|)
block|;
operator|++
name|I
block|;
return|return
name|Temp
return|;
block|}
name|bool
name|operator
operator|==
operator|(
specifier|const
name|TypedMDOperandIterator
operator|&
name|X
operator|)
specifier|const
block|{
return|return
name|I
operator|==
name|X
operator|.
name|I
return|;
block|}
name|bool
name|operator
operator|!=
operator|(
specifier|const
name|TypedMDOperandIterator
operator|&
name|X
operator|)
specifier|const
block|{
return|return
name|I
operator|!=
name|X
operator|.
name|I
return|;
block|}
expr|}
block|;
comment|/// \brief Typed, array-like tuple of metadata.
comment|///
comment|/// This is a wrapper for \a MDTuple that makes it act like an array holding a
comment|/// particular type of metadata.
name|template
operator|<
name|class
name|T
operator|>
name|class
name|MDTupleTypedArrayWrapper
block|{
specifier|const
name|MDTuple
operator|*
name|N
operator|=
name|nullptr
block|;
name|public
operator|:
name|MDTupleTypedArrayWrapper
argument_list|()
operator|=
expr|default
block|;
name|MDTupleTypedArrayWrapper
argument_list|(
specifier|const
name|MDTuple
operator|*
name|N
argument_list|)
operator|:
name|N
argument_list|(
argument|N
argument_list|)
block|{}
name|template
operator|<
name|class
name|U
operator|>
name|MDTupleTypedArrayWrapper
argument_list|(
argument|const MDTupleTypedArrayWrapper<U>&Other
argument_list|,
argument|typename std::enable_if<std::is_convertible<U *
argument_list|,
argument|T *>::value>::type * =           nullptr
argument_list|)
operator|:
name|N
argument_list|(
argument|Other.get()
argument_list|)
block|{}
name|template
operator|<
name|class
name|U
operator|>
name|explicit
name|MDTupleTypedArrayWrapper
argument_list|(
argument|const MDTupleTypedArrayWrapper<U>&Other
argument_list|,
argument|typename std::enable_if<!std::is_convertible<U *
argument_list|,
argument|T *>::value>::type * =           nullptr
argument_list|)
operator|:
name|N
argument_list|(
argument|Other.get()
argument_list|)
block|{}
name|explicit
name|operator
name|bool
argument_list|()
specifier|const
block|{
return|return
name|get
argument_list|()
return|;
block|}
name|explicit
name|operator
name|MDTuple
operator|*
operator|(
operator|)
specifier|const
block|{
return|return
name|get
argument_list|()
return|;
block|}
name|MDTuple
operator|*
name|get
argument_list|()
specifier|const
block|{
return|return
name|const_cast
operator|<
name|MDTuple
operator|*
operator|>
operator|(
name|N
operator|)
return|;
block|}
name|MDTuple
operator|*
name|operator
operator|->
expr|(
block|)
specifier|const
block|{
return|return
name|get
argument_list|()
return|;
block|}
name|MDTuple
operator|&
name|operator
operator|*
operator|(
operator|)
specifier|const
block|{
return|return
operator|*
name|get
argument_list|()
return|;
block|}
comment|// FIXME: Fix callers and remove condition on N.
name|unsigned
name|size
argument_list|()
specifier|const
block|{
return|return
name|N
operator|?
name|N
operator|->
name|getNumOperands
argument_list|()
operator|:
literal|0u
return|;
block|}
name|bool
name|empty
argument_list|()
specifier|const
block|{
return|return
name|N
condition|?
name|N
operator|->
name|getNumOperands
argument_list|()
operator|==
literal|0
else|:
name|true
return|;
block|}
name|T
operator|*
name|operator
index|[]
operator|(
name|unsigned
name|I
operator|)
specifier|const
block|{
return|return
name|cast_or_null
operator|<
name|T
operator|>
operator|(
name|N
operator|->
name|getOperand
argument_list|(
name|I
argument_list|)
operator|)
return|;
block|}
comment|// FIXME: Fix callers and remove condition on N.
name|using
name|iterator
operator|=
name|TypedMDOperandIterator
operator|<
name|T
operator|>
block|;
name|iterator
name|begin
argument_list|()
specifier|const
block|{
return|return
name|N
condition|?
name|iterator
argument_list|(
name|N
operator|->
name|op_begin
argument_list|()
argument_list|)
else|:
name|iterator
argument_list|()
return|;
block|}
name|iterator
name|end
argument_list|()
specifier|const
block|{
return|return
name|N
condition|?
name|iterator
argument_list|(
name|N
operator|->
name|op_end
argument_list|()
argument_list|)
else|:
name|iterator
argument_list|()
return|;
block|}
expr|}
block|;
define|#
directive|define
name|HANDLE_METADATA
parameter_list|(
name|CLASS
parameter_list|)
define|\
value|using CLASS##Array = MDTupleTypedArrayWrapper<CLASS>;
include|#
directive|include
file|"llvm/IR/Metadata.def"
comment|/// Placeholder metadata for operands of distinct MDNodes.
comment|///
comment|/// This is a lightweight placeholder for an operand of a distinct node.  It's
comment|/// purpose is to help track forward references when creating a distinct node.
comment|/// This allows distinct nodes involved in a cycle to be constructed before
comment|/// their operands without requiring a heavyweight temporary node with
comment|/// full-blown RAUW support.
comment|///
comment|/// Each placeholder supports only a single MDNode user.  Clients should pass
comment|/// an ID, retrieved via \a getID(), to indicate the "real" operand that this
comment|/// should be replaced with.
comment|///
comment|/// While it would be possible to implement move operators, they would be
comment|/// fairly expensive.  Leave them unimplemented to discourage their use
comment|/// (clients can use std::deque, std::list, BumpPtrAllocator, etc.).
name|class
name|DistinctMDOperandPlaceholder
operator|:
name|public
name|Metadata
block|{
name|friend
name|class
name|MetadataTracking
block|;
name|Metadata
operator|*
operator|*
name|Use
operator|=
name|nullptr
block|;
name|public
operator|:
name|explicit
name|DistinctMDOperandPlaceholder
argument_list|(
argument|unsigned ID
argument_list|)
operator|:
name|Metadata
argument_list|(
argument|DistinctMDOperandPlaceholderKind
argument_list|,
argument|Distinct
argument_list|)
block|{
name|SubclassData32
operator|=
name|ID
block|;   }
name|DistinctMDOperandPlaceholder
argument_list|()
operator|=
name|delete
block|;
name|DistinctMDOperandPlaceholder
argument_list|(
name|DistinctMDOperandPlaceholder
operator|&&
argument_list|)
operator|=
name|delete
block|;
name|DistinctMDOperandPlaceholder
argument_list|(
specifier|const
name|DistinctMDOperandPlaceholder
operator|&
argument_list|)
operator|=
name|delete
block|;
operator|~
name|DistinctMDOperandPlaceholder
argument_list|()
block|{
if|if
condition|(
name|Use
condition|)
operator|*
name|Use
operator|=
name|nullptr
expr_stmt|;
block|}
name|unsigned
name|getID
argument_list|()
specifier|const
block|{
return|return
name|SubclassData32
return|;
block|}
comment|/// Replace the use of this with MD.
name|void
name|replaceUseWith
argument_list|(
argument|Metadata *MD
argument_list|)
block|{
if|if
condition|(
operator|!
name|Use
condition|)
return|return;
operator|*
name|Use
operator|=
name|MD
block|;
name|Use
operator|=
name|nullptr
block|;   }
block|}
block|;
comment|//===----------------------------------------------------------------------===//
comment|/// \brief A tuple of MDNodes.
comment|///
comment|/// Despite its name, a NamedMDNode isn't itself an MDNode. NamedMDNodes belong
comment|/// to modules, have names, and contain lists of MDNodes.
comment|///
comment|/// TODO: Inherit from Metadata.
name|class
name|NamedMDNode
operator|:
name|public
name|ilist_node
operator|<
name|NamedMDNode
operator|>
block|{
name|friend
name|class
name|LLVMContextImpl
block|;
name|friend
name|class
name|Module
block|;
name|std
operator|::
name|string
name|Name
block|;
name|Module
operator|*
name|Parent
operator|=
name|nullptr
block|;
name|void
operator|*
name|Operands
block|;
comment|// SmallVector<TrackingMDRef, 4>
name|void
name|setParent
argument_list|(
argument|Module *M
argument_list|)
block|{
name|Parent
operator|=
name|M
block|; }
name|explicit
name|NamedMDNode
argument_list|(
specifier|const
name|Twine
operator|&
name|N
argument_list|)
block|;
name|template
operator|<
name|class
name|T1
block|,
name|class
name|T2
operator|>
name|class
name|op_iterator_impl
operator|:
name|public
name|std
operator|::
name|iterator
operator|<
name|std
operator|::
name|bidirectional_iterator_tag
block|,
name|T2
operator|>
block|{
name|friend
name|class
name|NamedMDNode
block|;
specifier|const
name|NamedMDNode
operator|*
name|Node
operator|=
name|nullptr
block|;
name|unsigned
name|Idx
operator|=
literal|0
block|;
name|op_iterator_impl
argument_list|(
argument|const NamedMDNode *N
argument_list|,
argument|unsigned i
argument_list|)
operator|:
name|Node
argument_list|(
name|N
argument_list|)
block|,
name|Idx
argument_list|(
argument|i
argument_list|)
block|{}
name|public
operator|:
name|op_iterator_impl
argument_list|()
operator|=
expr|default
block|;
name|bool
name|operator
operator|==
operator|(
specifier|const
name|op_iterator_impl
operator|&
name|o
operator|)
specifier|const
block|{
return|return
name|Idx
operator|==
name|o
operator|.
name|Idx
return|;
block|}
name|bool
name|operator
operator|!=
operator|(
specifier|const
name|op_iterator_impl
operator|&
name|o
operator|)
specifier|const
block|{
return|return
name|Idx
operator|!=
name|o
operator|.
name|Idx
return|;
block|}
name|op_iterator_impl
operator|&
name|operator
operator|++
operator|(
operator|)
block|{
operator|++
name|Idx
block|;
return|return
operator|*
name|this
return|;
block|}
name|op_iterator_impl
name|operator
operator|++
operator|(
name|int
operator|)
block|{
name|op_iterator_impl
name|tmp
argument_list|(
operator|*
name|this
argument_list|)
block|;
name|operator
operator|++
operator|(
operator|)
block|;
return|return
name|tmp
return|;
block|}
name|op_iterator_impl
operator|&
name|operator
operator|--
operator|(
operator|)
block|{
operator|--
name|Idx
block|;
return|return
operator|*
name|this
return|;
block|}
name|op_iterator_impl
name|operator
operator|--
operator|(
name|int
operator|)
block|{
name|op_iterator_impl
name|tmp
argument_list|(
operator|*
name|this
argument_list|)
block|;
name|operator
operator|--
operator|(
operator|)
block|;
return|return
name|tmp
return|;
block|}
name|T1
name|operator
operator|*
operator|(
operator|)
specifier|const
block|{
return|return
name|Node
operator|->
name|getOperand
argument_list|(
name|Idx
argument_list|)
return|;
block|}
expr|}
block|;
name|public
operator|:
name|NamedMDNode
argument_list|(
specifier|const
name|NamedMDNode
operator|&
argument_list|)
operator|=
name|delete
block|;
operator|~
name|NamedMDNode
argument_list|()
block|;
comment|/// \brief Drop all references and remove the node from parent module.
name|void
name|eraseFromParent
argument_list|()
block|;
comment|/// Remove all uses and clear node vector.
name|void
name|dropAllReferences
argument_list|()
block|{
name|clearOperands
argument_list|()
block|; }
comment|/// Drop all references to this node's operands.
name|void
name|clearOperands
argument_list|()
block|;
comment|/// \brief Get the module that holds this named metadata collection.
specifier|inline
name|Module
operator|*
name|getParent
argument_list|()
block|{
return|return
name|Parent
return|;
block|}
specifier|inline
specifier|const
name|Module
operator|*
name|getParent
argument_list|()
specifier|const
block|{
return|return
name|Parent
return|;
block|}
name|MDNode
operator|*
name|getOperand
argument_list|(
argument|unsigned i
argument_list|)
specifier|const
block|;
name|unsigned
name|getNumOperands
argument_list|()
specifier|const
block|;
name|void
name|addOperand
argument_list|(
name|MDNode
operator|*
name|M
argument_list|)
block|;
name|void
name|setOperand
argument_list|(
argument|unsigned I
argument_list|,
argument|MDNode *New
argument_list|)
block|;
name|StringRef
name|getName
argument_list|()
specifier|const
block|;
name|void
name|print
argument_list|(
argument|raw_ostream&ROS
argument_list|,
argument|bool IsForDebug = false
argument_list|)
specifier|const
block|;
name|void
name|print
argument_list|(
argument|raw_ostream&ROS
argument_list|,
argument|ModuleSlotTracker&MST
argument_list|,
argument|bool IsForDebug = false
argument_list|)
specifier|const
block|;
name|void
name|dump
argument_list|()
specifier|const
block|;
comment|// ---------------------------------------------------------------------------
comment|// Operand Iterator interface...
comment|//
name|using
name|op_iterator
operator|=
name|op_iterator_impl
operator|<
name|MDNode
operator|*
block|,
name|MDNode
operator|>
block|;
name|op_iterator
name|op_begin
argument_list|()
block|{
return|return
name|op_iterator
argument_list|(
name|this
argument_list|,
literal|0
argument_list|)
return|;
block|}
name|op_iterator
name|op_end
argument_list|()
block|{
return|return
name|op_iterator
argument_list|(
name|this
argument_list|,
name|getNumOperands
argument_list|()
argument_list|)
return|;
block|}
name|using
name|const_op_iterator
operator|=
name|op_iterator_impl
operator|<
specifier|const
name|MDNode
operator|*
block|,
name|MDNode
operator|>
block|;
name|const_op_iterator
name|op_begin
argument_list|()
specifier|const
block|{
return|return
name|const_op_iterator
argument_list|(
name|this
argument_list|,
literal|0
argument_list|)
return|;
block|}
name|const_op_iterator
name|op_end
argument_list|()
specifier|const
block|{
return|return
name|const_op_iterator
argument_list|(
name|this
argument_list|,
name|getNumOperands
argument_list|()
argument_list|)
return|;
block|}
specifier|inline
name|iterator_range
operator|<
name|op_iterator
operator|>
name|operands
argument_list|()
block|{
return|return
name|make_range
argument_list|(
name|op_begin
argument_list|()
argument_list|,
name|op_end
argument_list|()
argument_list|)
return|;
block|}
specifier|inline
name|iterator_range
operator|<
name|const_op_iterator
operator|>
name|operands
argument_list|()
specifier|const
block|{
return|return
name|make_range
argument_list|(
name|op_begin
argument_list|()
argument_list|,
name|op_end
argument_list|()
argument_list|)
return|;
block|}
expr|}
block|;  }
end_decl_stmt

begin_comment
comment|// end namespace llvm
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|// LLVM_IR_METADATA_H
end_comment

end_unit

