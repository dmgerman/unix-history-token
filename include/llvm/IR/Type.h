begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===- llvm/Type.h - Classes for handling data types ------------*- C++ -*-===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file contains the declaration of the Type class.  For more "Type"
end_comment

begin_comment
comment|// stuff, look in DerivedTypes.h.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LLVM_IR_TYPE_H
end_ifndef

begin_define
define|#
directive|define
name|LLVM_IR_TYPE_H
end_define

begin_include
include|#
directive|include
file|"llvm/ADT/APFloat.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/ArrayRef.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/SmallPtrSet.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/CBindingWrapping.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/Casting.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/Compiler.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/ErrorHandling.h"
end_include

begin_include
include|#
directive|include
file|<cassert>
end_include

begin_include
include|#
directive|include
file|<cstdint>
end_include

begin_include
include|#
directive|include
file|<iterator>
end_include

begin_decl_stmt
name|namespace
name|llvm
block|{
name|template
operator|<
name|class
name|GraphType
operator|>
expr|struct
name|GraphTraits
expr_stmt|;
name|class
name|IntegerType
decl_stmt|;
name|class
name|LLVMContext
decl_stmt|;
name|class
name|PointerType
decl_stmt|;
name|class
name|raw_ostream
decl_stmt|;
name|class
name|StringRef
decl_stmt|;
comment|/// The instances of the Type class are immutable: once they are created,
comment|/// they are never changed.  Also note that only one instance of a particular
comment|/// type is ever created.  Thus seeing if two types are equal is a matter of
comment|/// doing a trivial pointer comparison. To enforce that no two equal instances
comment|/// are created, Type instances can only be created via static factory methods
comment|/// in class Type and in derived classes.  Once allocated, Types are never
comment|/// free'd.
comment|///
name|class
name|Type
block|{
name|public
label|:
comment|//===--------------------------------------------------------------------===//
comment|/// Definitions of all of the base types for the Type system.  Based on this
comment|/// value, you can cast to a class defined in DerivedTypes.h.
comment|/// Note: If you add an element to this, you need to add an element to the
comment|/// Type::getPrimitiveType function, or else things will break!
comment|/// Also update LLVMTypeKind and LLVMGetTypeKind () in the C binding.
comment|///
enum|enum
name|TypeID
block|{
comment|// PrimitiveTypes - make sure LastPrimitiveTyID stays up to date.
name|VoidTyID
init|=
literal|0
block|,
comment|///<  0: type with no size
name|HalfTyID
block|,
comment|///<  1: 16-bit floating point type
name|FloatTyID
block|,
comment|///<  2: 32-bit floating point type
name|DoubleTyID
block|,
comment|///<  3: 64-bit floating point type
name|X86_FP80TyID
block|,
comment|///<  4: 80-bit floating point type (X87)
name|FP128TyID
block|,
comment|///<  5: 128-bit floating point type (112-bit mantissa)
name|PPC_FP128TyID
block|,
comment|///<  6: 128-bit floating point type (two 64-bits, PowerPC)
name|LabelTyID
block|,
comment|///<  7: Labels
name|MetadataTyID
block|,
comment|///<  8: Metadata
name|X86_MMXTyID
block|,
comment|///<  9: MMX vectors (64 bits, X86 specific)
name|TokenTyID
block|,
comment|///< 10: Tokens
comment|// Derived types... see DerivedTypes.h file.
comment|// Make sure FirstDerivedTyID stays up to date!
name|IntegerTyID
block|,
comment|///< 11: Arbitrary bit width integers
name|FunctionTyID
block|,
comment|///< 12: Functions
name|StructTyID
block|,
comment|///< 13: Structures
name|ArrayTyID
block|,
comment|///< 14: Arrays
name|PointerTyID
block|,
comment|///< 15: Pointers
name|VectorTyID
comment|///< 16: SIMD 'packed' format, or other vector type
block|}
enum|;
name|private
label|:
comment|/// This refers to the LLVMContext in which this type was uniqued.
name|LLVMContext
modifier|&
name|Context
decl_stmt|;
name|TypeID
name|ID
range|:
literal|8
decl_stmt|;
comment|// The current base type of this type.
name|unsigned
name|SubclassData
range|:
literal|24
decl_stmt|;
comment|// Space for subclasses to store data.
comment|// Note that this should be synchronized with
comment|// MAX_INT_BITS value in IntegerType class.
name|protected
label|:
name|friend
name|class
name|LLVMContextImpl
decl_stmt|;
name|explicit
name|Type
argument_list|(
argument|LLVMContext&C
argument_list|,
argument|TypeID tid
argument_list|)
block|:
name|Context
argument_list|(
name|C
argument_list|)
operator|,
name|ID
argument_list|(
name|tid
argument_list|)
operator|,
name|SubclassData
argument_list|(
literal|0
argument_list|)
block|{}
operator|~
name|Type
argument_list|()
operator|=
expr|default
expr_stmt|;
name|unsigned
name|getSubclassData
argument_list|()
specifier|const
block|{
return|return
name|SubclassData
return|;
block|}
name|void
name|setSubclassData
parameter_list|(
name|unsigned
name|val
parameter_list|)
block|{
name|SubclassData
operator|=
name|val
expr_stmt|;
comment|// Ensure we don't have any accidental truncation.
name|assert
argument_list|(
name|getSubclassData
argument_list|()
operator|==
name|val
operator|&&
literal|"Subclass data too large for field"
argument_list|)
expr_stmt|;
block|}
comment|/// Keeps track of how many Type*'s there are in the ContainedTys list.
name|unsigned
name|NumContainedTys
init|=
literal|0
decl_stmt|;
comment|/// A pointer to the array of Types contained by this Type. For example, this
comment|/// includes the arguments of a function type, the elements of a structure,
comment|/// the pointee of a pointer, the element type of an array, etc. This pointer
comment|/// may be 0 for types that don't contain other types (Integer, Double,
comment|/// Float).
name|Type
modifier|*
specifier|const
modifier|*
name|ContainedTys
init|=
name|nullptr
decl_stmt|;
specifier|static
name|bool
name|isSequentialType
parameter_list|(
name|TypeID
name|TyID
parameter_list|)
block|{
return|return
name|TyID
operator|==
name|ArrayTyID
operator|||
name|TyID
operator|==
name|VectorTyID
return|;
block|}
name|public
label|:
comment|/// Print the current type.
comment|/// Omit the type details if \p NoDetails == true.
comment|/// E.g., let %st = type { i32, i16 }
comment|/// When \p NoDetails is true, we only print %st.
comment|/// Put differently, \p NoDetails prints the type as if
comment|/// inlined with the operands when printing an instruction.
name|void
name|print
argument_list|(
name|raw_ostream
operator|&
name|O
argument_list|,
name|bool
name|IsForDebug
operator|=
name|false
argument_list|,
name|bool
name|NoDetails
operator|=
name|false
argument_list|)
decl|const
decl_stmt|;
name|void
name|dump
argument_list|()
specifier|const
expr_stmt|;
comment|/// Return the LLVMContext in which this type was uniqued.
name|LLVMContext
operator|&
name|getContext
argument_list|()
specifier|const
block|{
return|return
name|Context
return|;
block|}
comment|//===--------------------------------------------------------------------===//
comment|// Accessors for working with types.
comment|//
comment|/// Return the type id for the type. This will return one of the TypeID enum
comment|/// elements defined above.
name|TypeID
name|getTypeID
argument_list|()
specifier|const
block|{
return|return
name|ID
return|;
block|}
comment|/// Return true if this is 'void'.
name|bool
name|isVoidTy
argument_list|()
specifier|const
block|{
return|return
name|getTypeID
argument_list|()
operator|==
name|VoidTyID
return|;
block|}
comment|/// Return true if this is 'half', a 16-bit IEEE fp type.
name|bool
name|isHalfTy
argument_list|()
specifier|const
block|{
return|return
name|getTypeID
argument_list|()
operator|==
name|HalfTyID
return|;
block|}
comment|/// Return true if this is 'float', a 32-bit IEEE fp type.
name|bool
name|isFloatTy
argument_list|()
specifier|const
block|{
return|return
name|getTypeID
argument_list|()
operator|==
name|FloatTyID
return|;
block|}
comment|/// Return true if this is 'double', a 64-bit IEEE fp type.
name|bool
name|isDoubleTy
argument_list|()
specifier|const
block|{
return|return
name|getTypeID
argument_list|()
operator|==
name|DoubleTyID
return|;
block|}
comment|/// Return true if this is x86 long double.
name|bool
name|isX86_FP80Ty
argument_list|()
specifier|const
block|{
return|return
name|getTypeID
argument_list|()
operator|==
name|X86_FP80TyID
return|;
block|}
comment|/// Return true if this is 'fp128'.
name|bool
name|isFP128Ty
argument_list|()
specifier|const
block|{
return|return
name|getTypeID
argument_list|()
operator|==
name|FP128TyID
return|;
block|}
comment|/// Return true if this is powerpc long double.
name|bool
name|isPPC_FP128Ty
argument_list|()
specifier|const
block|{
return|return
name|getTypeID
argument_list|()
operator|==
name|PPC_FP128TyID
return|;
block|}
comment|/// Return true if this is one of the six floating-point types
name|bool
name|isFloatingPointTy
argument_list|()
specifier|const
block|{
return|return
name|getTypeID
argument_list|()
operator|==
name|HalfTyID
operator|||
name|getTypeID
argument_list|()
operator|==
name|FloatTyID
operator|||
name|getTypeID
argument_list|()
operator|==
name|DoubleTyID
operator|||
name|getTypeID
argument_list|()
operator|==
name|X86_FP80TyID
operator|||
name|getTypeID
argument_list|()
operator|==
name|FP128TyID
operator|||
name|getTypeID
argument_list|()
operator|==
name|PPC_FP128TyID
return|;
block|}
specifier|const
name|fltSemantics
operator|&
name|getFltSemantics
argument_list|()
specifier|const
block|{
switch|switch
condition|(
name|getTypeID
argument_list|()
condition|)
block|{
case|case
name|HalfTyID
case|:
return|return
name|APFloat
operator|::
name|IEEEhalf
argument_list|()
return|;
case|case
name|FloatTyID
case|:
return|return
name|APFloat
operator|::
name|IEEEsingle
argument_list|()
return|;
case|case
name|DoubleTyID
case|:
return|return
name|APFloat
operator|::
name|IEEEdouble
argument_list|()
return|;
case|case
name|X86_FP80TyID
case|:
return|return
name|APFloat
operator|::
name|x87DoubleExtended
argument_list|()
return|;
case|case
name|FP128TyID
case|:
return|return
name|APFloat
operator|::
name|IEEEquad
argument_list|()
return|;
case|case
name|PPC_FP128TyID
case|:
return|return
name|APFloat
operator|::
name|PPCDoubleDouble
argument_list|()
return|;
default|default:
name|llvm_unreachable
argument_list|(
literal|"Invalid floating type"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/// Return true if this is X86 MMX.
name|bool
name|isX86_MMXTy
argument_list|()
specifier|const
block|{
return|return
name|getTypeID
argument_list|()
operator|==
name|X86_MMXTyID
return|;
block|}
comment|/// Return true if this is a FP type or a vector of FP.
name|bool
name|isFPOrFPVectorTy
argument_list|()
specifier|const
block|{
return|return
name|getScalarType
argument_list|()
operator|->
name|isFloatingPointTy
argument_list|()
return|;
block|}
comment|/// Return true if this is 'label'.
name|bool
name|isLabelTy
argument_list|()
specifier|const
block|{
return|return
name|getTypeID
argument_list|()
operator|==
name|LabelTyID
return|;
block|}
comment|/// Return true if this is 'metadata'.
name|bool
name|isMetadataTy
argument_list|()
specifier|const
block|{
return|return
name|getTypeID
argument_list|()
operator|==
name|MetadataTyID
return|;
block|}
comment|/// Return true if this is 'token'.
name|bool
name|isTokenTy
argument_list|()
specifier|const
block|{
return|return
name|getTypeID
argument_list|()
operator|==
name|TokenTyID
return|;
block|}
comment|/// True if this is an instance of IntegerType.
name|bool
name|isIntegerTy
argument_list|()
specifier|const
block|{
return|return
name|getTypeID
argument_list|()
operator|==
name|IntegerTyID
return|;
block|}
comment|/// Return true if this is an IntegerType of the given width.
name|bool
name|isIntegerTy
argument_list|(
name|unsigned
name|Bitwidth
argument_list|)
decl|const
decl_stmt|;
comment|/// Return true if this is an integer type or a vector of integer types.
name|bool
name|isIntOrIntVectorTy
argument_list|()
specifier|const
block|{
return|return
name|getScalarType
argument_list|()
operator|->
name|isIntegerTy
argument_list|()
return|;
block|}
comment|/// True if this is an instance of FunctionType.
name|bool
name|isFunctionTy
argument_list|()
specifier|const
block|{
return|return
name|getTypeID
argument_list|()
operator|==
name|FunctionTyID
return|;
block|}
comment|/// True if this is an instance of StructType.
name|bool
name|isStructTy
argument_list|()
specifier|const
block|{
return|return
name|getTypeID
argument_list|()
operator|==
name|StructTyID
return|;
block|}
comment|/// True if this is an instance of ArrayType.
name|bool
name|isArrayTy
argument_list|()
specifier|const
block|{
return|return
name|getTypeID
argument_list|()
operator|==
name|ArrayTyID
return|;
block|}
comment|/// True if this is an instance of PointerType.
name|bool
name|isPointerTy
argument_list|()
specifier|const
block|{
return|return
name|getTypeID
argument_list|()
operator|==
name|PointerTyID
return|;
block|}
comment|/// Return true if this is a pointer type or a vector of pointer types.
name|bool
name|isPtrOrPtrVectorTy
argument_list|()
specifier|const
block|{
return|return
name|getScalarType
argument_list|()
operator|->
name|isPointerTy
argument_list|()
return|;
block|}
comment|/// True if this is an instance of VectorType.
name|bool
name|isVectorTy
argument_list|()
specifier|const
block|{
return|return
name|getTypeID
argument_list|()
operator|==
name|VectorTyID
return|;
block|}
comment|/// Return true if this type could be converted with a lossless BitCast to
comment|/// type 'Ty'. For example, i8* to i32*. BitCasts are valid for types of the
comment|/// same size only where no re-interpretation of the bits is done.
comment|/// @brief Determine if this type could be losslessly bitcast to Ty
name|bool
name|canLosslesslyBitCastTo
argument_list|(
name|Type
operator|*
name|Ty
argument_list|)
decl|const
decl_stmt|;
comment|/// Return true if this type is empty, that is, it has no elements or all of
comment|/// its elements are empty.
name|bool
name|isEmptyTy
argument_list|()
specifier|const
expr_stmt|;
comment|/// Return true if the type is "first class", meaning it is a valid type for a
comment|/// Value.
name|bool
name|isFirstClassType
argument_list|()
specifier|const
block|{
return|return
name|getTypeID
argument_list|()
operator|!=
name|FunctionTyID
operator|&&
name|getTypeID
argument_list|()
operator|!=
name|VoidTyID
return|;
block|}
comment|/// Return true if the type is a valid type for a register in codegen. This
comment|/// includes all first-class types except struct and array types.
name|bool
name|isSingleValueType
argument_list|()
specifier|const
block|{
return|return
name|isFloatingPointTy
argument_list|()
operator|||
name|isX86_MMXTy
argument_list|()
operator|||
name|isIntegerTy
argument_list|()
operator|||
name|isPointerTy
argument_list|()
operator|||
name|isVectorTy
argument_list|()
return|;
block|}
comment|/// Return true if the type is an aggregate type. This means it is valid as
comment|/// the first operand of an insertvalue or extractvalue instruction. This
comment|/// includes struct and array types, but does not include vector types.
name|bool
name|isAggregateType
argument_list|()
specifier|const
block|{
return|return
name|getTypeID
argument_list|()
operator|==
name|StructTyID
operator|||
name|getTypeID
argument_list|()
operator|==
name|ArrayTyID
return|;
block|}
comment|/// Return true if it makes sense to take the size of this type. To get the
comment|/// actual size for a particular target, it is reasonable to use the
comment|/// DataLayout subsystem to do this.
name|bool
name|isSized
argument_list|(
name|SmallPtrSetImpl
operator|<
name|Type
operator|*
operator|>
operator|*
name|Visited
operator|=
name|nullptr
argument_list|)
decl|const
block|{
comment|// If it's a primitive, it is always sized.
if|if
condition|(
name|getTypeID
argument_list|()
operator|==
name|IntegerTyID
operator|||
name|isFloatingPointTy
argument_list|()
operator|||
name|getTypeID
argument_list|()
operator|==
name|PointerTyID
operator|||
name|getTypeID
argument_list|()
operator|==
name|X86_MMXTyID
condition|)
return|return
name|true
return|;
comment|// If it is not something that can have a size (e.g. a function or label),
comment|// it doesn't have a size.
if|if
condition|(
name|getTypeID
argument_list|()
operator|!=
name|StructTyID
operator|&&
name|getTypeID
argument_list|()
operator|!=
name|ArrayTyID
operator|&&
name|getTypeID
argument_list|()
operator|!=
name|VectorTyID
condition|)
return|return
name|false
return|;
comment|// Otherwise we have to try harder to decide.
return|return
name|isSizedDerivedType
argument_list|(
name|Visited
argument_list|)
return|;
block|}
comment|/// Return the basic size of this type if it is a primitive type. These are
comment|/// fixed by LLVM and are not target-dependent.
comment|/// This will return zero if the type does not have a size or is not a
comment|/// primitive type.
comment|///
comment|/// Note that this may not reflect the size of memory allocated for an
comment|/// instance of the type or the number of bytes that are written when an
comment|/// instance of the type is stored to memory. The DataLayout class provides
comment|/// additional query functions to provide this information.
comment|///
name|unsigned
name|getPrimitiveSizeInBits
argument_list|()
specifier|const
name|LLVM_READONLY
expr_stmt|;
comment|/// If this is a vector type, return the getPrimitiveSizeInBits value for the
comment|/// element type. Otherwise return the getPrimitiveSizeInBits value for this
comment|/// type.
name|unsigned
name|getScalarSizeInBits
argument_list|()
specifier|const
name|LLVM_READONLY
expr_stmt|;
comment|/// Return the width of the mantissa of this type. This is only valid on
comment|/// floating-point types. If the FP type does not have a stable mantissa (e.g.
comment|/// ppc long double), this method returns -1.
name|int
name|getFPMantissaWidth
argument_list|()
specifier|const
expr_stmt|;
comment|/// If this is a vector type, return the element type, otherwise return
comment|/// 'this'.
name|Type
operator|*
name|getScalarType
argument_list|()
specifier|const
block|{
if|if
condition|(
name|isVectorTy
argument_list|()
condition|)
return|return
name|getVectorElementType
argument_list|()
return|;
return|return
name|const_cast
operator|<
name|Type
operator|*
operator|>
operator|(
name|this
operator|)
return|;
block|}
comment|//===--------------------------------------------------------------------===//
comment|// Type Iteration support.
comment|//
name|using
name|subtype_iterator
init|=
name|Type
operator|*
specifier|const
operator|*
decl_stmt|;
name|subtype_iterator
name|subtype_begin
argument_list|()
specifier|const
block|{
return|return
name|ContainedTys
return|;
block|}
name|subtype_iterator
name|subtype_end
argument_list|()
specifier|const
block|{
return|return
operator|&
name|ContainedTys
index|[
name|NumContainedTys
index|]
return|;
block|}
name|ArrayRef
operator|<
name|Type
operator|*
operator|>
name|subtypes
argument_list|()
specifier|const
block|{
return|return
name|makeArrayRef
argument_list|(
name|subtype_begin
argument_list|()
argument_list|,
name|subtype_end
argument_list|()
argument_list|)
return|;
block|}
name|using
name|subtype_reverse_iterator
init|=
name|std
operator|::
name|reverse_iterator
operator|<
name|subtype_iterator
operator|>
decl_stmt|;
name|subtype_reverse_iterator
name|subtype_rbegin
argument_list|()
specifier|const
block|{
return|return
name|subtype_reverse_iterator
argument_list|(
name|subtype_end
argument_list|()
argument_list|)
return|;
block|}
name|subtype_reverse_iterator
name|subtype_rend
argument_list|()
specifier|const
block|{
return|return
name|subtype_reverse_iterator
argument_list|(
name|subtype_begin
argument_list|()
argument_list|)
return|;
block|}
comment|/// This method is used to implement the type iterator (defined at the end of
comment|/// the file). For derived types, this returns the types 'contained' in the
comment|/// derived type.
name|Type
modifier|*
name|getContainedType
argument_list|(
name|unsigned
name|i
argument_list|)
decl|const
block|{
name|assert
argument_list|(
name|i
operator|<
name|NumContainedTys
operator|&&
literal|"Index out of range!"
argument_list|)
expr_stmt|;
return|return
name|ContainedTys
index|[
name|i
index|]
return|;
block|}
comment|/// Return the number of types in the derived type.
name|unsigned
name|getNumContainedTypes
argument_list|()
specifier|const
block|{
return|return
name|NumContainedTys
return|;
block|}
comment|//===--------------------------------------------------------------------===//
comment|// Helper methods corresponding to subclass methods.  This forces a cast to
comment|// the specified subclass and calls its accessor.  "getVectorNumElements" (for
comment|// example) is shorthand for cast<VectorType>(Ty)->getNumElements().  This is
comment|// only intended to cover the core methods that are frequently used, helper
comment|// methods should not be added here.
specifier|inline
name|unsigned
name|getIntegerBitWidth
argument_list|()
specifier|const
expr_stmt|;
specifier|inline
name|Type
modifier|*
name|getFunctionParamType
argument_list|(
name|unsigned
name|i
argument_list|)
decl|const
decl_stmt|;
specifier|inline
name|unsigned
name|getFunctionNumParams
argument_list|()
specifier|const
expr_stmt|;
specifier|inline
name|bool
name|isFunctionVarArg
argument_list|()
specifier|const
expr_stmt|;
specifier|inline
name|StringRef
name|getStructName
argument_list|()
specifier|const
expr_stmt|;
specifier|inline
name|unsigned
name|getStructNumElements
argument_list|()
specifier|const
expr_stmt|;
specifier|inline
name|Type
modifier|*
name|getStructElementType
argument_list|(
name|unsigned
name|N
argument_list|)
decl|const
decl_stmt|;
specifier|inline
name|Type
operator|*
name|getSequentialElementType
argument_list|()
specifier|const
block|{
name|assert
argument_list|(
name|isSequentialType
argument_list|(
name|getTypeID
argument_list|()
argument_list|)
operator|&&
literal|"Not a sequential type!"
argument_list|)
block|;
return|return
name|ContainedTys
index|[
literal|0
index|]
return|;
block|}
specifier|inline
name|uint64_t
name|getArrayNumElements
argument_list|()
specifier|const
expr_stmt|;
name|Type
operator|*
name|getArrayElementType
argument_list|()
specifier|const
block|{
name|assert
argument_list|(
name|getTypeID
argument_list|()
operator|==
name|ArrayTyID
argument_list|)
block|;
return|return
name|ContainedTys
index|[
literal|0
index|]
return|;
block|}
specifier|inline
name|unsigned
name|getVectorNumElements
argument_list|()
specifier|const
expr_stmt|;
name|Type
operator|*
name|getVectorElementType
argument_list|()
specifier|const
block|{
name|assert
argument_list|(
name|getTypeID
argument_list|()
operator|==
name|VectorTyID
argument_list|)
block|;
return|return
name|ContainedTys
index|[
literal|0
index|]
return|;
block|}
name|Type
operator|*
name|getPointerElementType
argument_list|()
specifier|const
block|{
name|assert
argument_list|(
name|getTypeID
argument_list|()
operator|==
name|PointerTyID
argument_list|)
block|;
return|return
name|ContainedTys
index|[
literal|0
index|]
return|;
block|}
comment|/// Get the address space of this pointer or pointer vector type.
specifier|inline
name|unsigned
name|getPointerAddressSpace
argument_list|()
specifier|const
expr_stmt|;
comment|//===--------------------------------------------------------------------===//
comment|// Static members exported by the Type class itself.  Useful for getting
comment|// instances of Type.
comment|//
comment|/// Return a type based on an identifier.
specifier|static
name|Type
modifier|*
name|getPrimitiveType
parameter_list|(
name|LLVMContext
modifier|&
name|C
parameter_list|,
name|TypeID
name|IDNumber
parameter_list|)
function_decl|;
comment|//===--------------------------------------------------------------------===//
comment|// These are the builtin types that are always available.
comment|//
specifier|static
name|Type
modifier|*
name|getVoidTy
parameter_list|(
name|LLVMContext
modifier|&
name|C
parameter_list|)
function_decl|;
specifier|static
name|Type
modifier|*
name|getLabelTy
parameter_list|(
name|LLVMContext
modifier|&
name|C
parameter_list|)
function_decl|;
specifier|static
name|Type
modifier|*
name|getHalfTy
parameter_list|(
name|LLVMContext
modifier|&
name|C
parameter_list|)
function_decl|;
specifier|static
name|Type
modifier|*
name|getFloatTy
parameter_list|(
name|LLVMContext
modifier|&
name|C
parameter_list|)
function_decl|;
specifier|static
name|Type
modifier|*
name|getDoubleTy
parameter_list|(
name|LLVMContext
modifier|&
name|C
parameter_list|)
function_decl|;
specifier|static
name|Type
modifier|*
name|getMetadataTy
parameter_list|(
name|LLVMContext
modifier|&
name|C
parameter_list|)
function_decl|;
specifier|static
name|Type
modifier|*
name|getX86_FP80Ty
parameter_list|(
name|LLVMContext
modifier|&
name|C
parameter_list|)
function_decl|;
specifier|static
name|Type
modifier|*
name|getFP128Ty
parameter_list|(
name|LLVMContext
modifier|&
name|C
parameter_list|)
function_decl|;
specifier|static
name|Type
modifier|*
name|getPPC_FP128Ty
parameter_list|(
name|LLVMContext
modifier|&
name|C
parameter_list|)
function_decl|;
specifier|static
name|Type
modifier|*
name|getX86_MMXTy
parameter_list|(
name|LLVMContext
modifier|&
name|C
parameter_list|)
function_decl|;
specifier|static
name|Type
modifier|*
name|getTokenTy
parameter_list|(
name|LLVMContext
modifier|&
name|C
parameter_list|)
function_decl|;
specifier|static
name|IntegerType
modifier|*
name|getIntNTy
parameter_list|(
name|LLVMContext
modifier|&
name|C
parameter_list|,
name|unsigned
name|N
parameter_list|)
function_decl|;
specifier|static
name|IntegerType
modifier|*
name|getInt1Ty
parameter_list|(
name|LLVMContext
modifier|&
name|C
parameter_list|)
function_decl|;
specifier|static
name|IntegerType
modifier|*
name|getInt8Ty
parameter_list|(
name|LLVMContext
modifier|&
name|C
parameter_list|)
function_decl|;
specifier|static
name|IntegerType
modifier|*
name|getInt16Ty
parameter_list|(
name|LLVMContext
modifier|&
name|C
parameter_list|)
function_decl|;
specifier|static
name|IntegerType
modifier|*
name|getInt32Ty
parameter_list|(
name|LLVMContext
modifier|&
name|C
parameter_list|)
function_decl|;
specifier|static
name|IntegerType
modifier|*
name|getInt64Ty
parameter_list|(
name|LLVMContext
modifier|&
name|C
parameter_list|)
function_decl|;
specifier|static
name|IntegerType
modifier|*
name|getInt128Ty
parameter_list|(
name|LLVMContext
modifier|&
name|C
parameter_list|)
function_decl|;
comment|//===--------------------------------------------------------------------===//
comment|// Convenience methods for getting pointer types with one of the above builtin
comment|// types as pointee.
comment|//
specifier|static
name|PointerType
modifier|*
name|getHalfPtrTy
parameter_list|(
name|LLVMContext
modifier|&
name|C
parameter_list|,
name|unsigned
name|AS
init|=
literal|0
parameter_list|)
function_decl|;
specifier|static
name|PointerType
modifier|*
name|getFloatPtrTy
parameter_list|(
name|LLVMContext
modifier|&
name|C
parameter_list|,
name|unsigned
name|AS
init|=
literal|0
parameter_list|)
function_decl|;
specifier|static
name|PointerType
modifier|*
name|getDoublePtrTy
parameter_list|(
name|LLVMContext
modifier|&
name|C
parameter_list|,
name|unsigned
name|AS
init|=
literal|0
parameter_list|)
function_decl|;
specifier|static
name|PointerType
modifier|*
name|getX86_FP80PtrTy
parameter_list|(
name|LLVMContext
modifier|&
name|C
parameter_list|,
name|unsigned
name|AS
init|=
literal|0
parameter_list|)
function_decl|;
specifier|static
name|PointerType
modifier|*
name|getFP128PtrTy
parameter_list|(
name|LLVMContext
modifier|&
name|C
parameter_list|,
name|unsigned
name|AS
init|=
literal|0
parameter_list|)
function_decl|;
specifier|static
name|PointerType
modifier|*
name|getPPC_FP128PtrTy
parameter_list|(
name|LLVMContext
modifier|&
name|C
parameter_list|,
name|unsigned
name|AS
init|=
literal|0
parameter_list|)
function_decl|;
specifier|static
name|PointerType
modifier|*
name|getX86_MMXPtrTy
parameter_list|(
name|LLVMContext
modifier|&
name|C
parameter_list|,
name|unsigned
name|AS
init|=
literal|0
parameter_list|)
function_decl|;
specifier|static
name|PointerType
modifier|*
name|getIntNPtrTy
parameter_list|(
name|LLVMContext
modifier|&
name|C
parameter_list|,
name|unsigned
name|N
parameter_list|,
name|unsigned
name|AS
init|=
literal|0
parameter_list|)
function_decl|;
specifier|static
name|PointerType
modifier|*
name|getInt1PtrTy
parameter_list|(
name|LLVMContext
modifier|&
name|C
parameter_list|,
name|unsigned
name|AS
init|=
literal|0
parameter_list|)
function_decl|;
specifier|static
name|PointerType
modifier|*
name|getInt8PtrTy
parameter_list|(
name|LLVMContext
modifier|&
name|C
parameter_list|,
name|unsigned
name|AS
init|=
literal|0
parameter_list|)
function_decl|;
specifier|static
name|PointerType
modifier|*
name|getInt16PtrTy
parameter_list|(
name|LLVMContext
modifier|&
name|C
parameter_list|,
name|unsigned
name|AS
init|=
literal|0
parameter_list|)
function_decl|;
specifier|static
name|PointerType
modifier|*
name|getInt32PtrTy
parameter_list|(
name|LLVMContext
modifier|&
name|C
parameter_list|,
name|unsigned
name|AS
init|=
literal|0
parameter_list|)
function_decl|;
specifier|static
name|PointerType
modifier|*
name|getInt64PtrTy
parameter_list|(
name|LLVMContext
modifier|&
name|C
parameter_list|,
name|unsigned
name|AS
init|=
literal|0
parameter_list|)
function_decl|;
comment|/// Return a pointer to the current type. This is equivalent to
comment|/// PointerType::get(Foo, AddrSpace).
name|PointerType
modifier|*
name|getPointerTo
argument_list|(
name|unsigned
name|AddrSpace
operator|=
literal|0
argument_list|)
decl|const
decl_stmt|;
name|private
label|:
comment|/// Derived types like structures and arrays are sized iff all of the members
comment|/// of the type are sized as well. Since asking for their size is relatively
comment|/// uncommon, move this operation out-of-line.
name|bool
name|isSizedDerivedType
argument_list|(
name|SmallPtrSetImpl
operator|<
name|Type
operator|*
operator|>
operator|*
name|Visited
operator|=
name|nullptr
argument_list|)
decl|const
decl_stmt|;
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_comment
comment|// Printing of types.
end_comment

begin_expr_stmt
specifier|static
specifier|inline
name|raw_ostream
operator|&
name|operator
operator|<<
operator|(
name|raw_ostream
operator|&
name|OS
operator|,
specifier|const
name|Type
operator|&
name|T
operator|)
block|{
name|T
operator|.
name|print
argument_list|(
name|OS
argument_list|)
block|;
return|return
name|OS
return|;
block|}
end_expr_stmt

begin_comment
comment|// allow isa<PointerType>(x) to work without DerivedTypes.h included.
end_comment

begin_expr_stmt
name|template
operator|<
operator|>
expr|struct
name|isa_impl
operator|<
name|PointerType
operator|,
name|Type
operator|>
block|{
specifier|static
specifier|inline
name|bool
name|doit
argument_list|(
argument|const Type&Ty
argument_list|)
block|{
return|return
name|Ty
operator|.
name|getTypeID
argument_list|()
operator|==
name|Type
operator|::
name|PointerTyID
return|;
block|}
end_expr_stmt

begin_comment
unit|};
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|// Provide specializations of GraphTraits to be able to treat a type as a
end_comment

begin_comment
comment|// graph of sub types.
end_comment

begin_expr_stmt
name|template
operator|<
operator|>
expr|struct
name|GraphTraits
operator|<
name|Type
operator|*
operator|>
block|{
name|using
name|NodeRef
operator|=
name|Type
operator|*
block|;
name|using
name|ChildIteratorType
operator|=
name|Type
operator|::
name|subtype_iterator
block|;
specifier|static
name|NodeRef
name|getEntryNode
argument_list|(
argument|Type *T
argument_list|)
block|{
return|return
name|T
return|;
block|}
specifier|static
name|ChildIteratorType
name|child_begin
argument_list|(
argument|NodeRef N
argument_list|)
block|{
return|return
name|N
operator|->
name|subtype_begin
argument_list|()
return|;
block|}
end_expr_stmt

begin_function
specifier|static
name|ChildIteratorType
name|child_end
parameter_list|(
name|NodeRef
name|N
parameter_list|)
block|{
return|return
name|N
operator|->
name|subtype_end
argument_list|()
return|;
block|}
end_function

begin_expr_stmt
unit|};
name|template
operator|<
operator|>
expr|struct
name|GraphTraits
operator|<
specifier|const
name|Type
operator|*
operator|>
block|{
name|using
name|NodeRef
operator|=
specifier|const
name|Type
operator|*
block|;
name|using
name|ChildIteratorType
operator|=
name|Type
operator|::
name|subtype_iterator
block|;
specifier|static
name|NodeRef
name|getEntryNode
argument_list|(
argument|NodeRef T
argument_list|)
block|{
return|return
name|T
return|;
block|}
specifier|static
name|ChildIteratorType
name|child_begin
argument_list|(
argument|NodeRef N
argument_list|)
block|{
return|return
name|N
operator|->
name|subtype_begin
argument_list|()
return|;
block|}
end_expr_stmt

begin_function
specifier|static
name|ChildIteratorType
name|child_end
parameter_list|(
name|NodeRef
name|N
parameter_list|)
block|{
return|return
name|N
operator|->
name|subtype_end
argument_list|()
return|;
block|}
end_function

begin_comment
unit|};
comment|// Create wrappers for C Binding types (see CBindingWrapping.h).
end_comment

begin_macro
name|DEFINE_ISA_CONVERSION_FUNCTIONS
argument_list|(
argument|Type
argument_list|,
argument|LLVMTypeRef
argument_list|)
end_macro

begin_comment
comment|/* Specialized opaque type conversions.  */
end_comment

begin_function
specifier|inline
name|Type
modifier|*
modifier|*
name|unwrap
parameter_list|(
name|LLVMTypeRef
modifier|*
name|Tys
parameter_list|)
block|{
return|return
name|reinterpret_cast
operator|<
name|Type
operator|*
operator|*
operator|>
operator|(
name|Tys
operator|)
return|;
block|}
end_function

begin_function
specifier|inline
name|LLVMTypeRef
modifier|*
name|wrap
parameter_list|(
name|Type
modifier|*
modifier|*
name|Tys
parameter_list|)
block|{
return|return
name|reinterpret_cast
operator|<
name|LLVMTypeRef
operator|*
operator|>
operator|(
name|const_cast
operator|<
name|Type
operator|*
operator|*
operator|>
operator|(
name|Tys
operator|)
operator|)
return|;
block|}
end_function

begin_comment
unit|}
comment|// end namespace llvm
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|// LLVM_IR_TYPE_H
end_comment

end_unit

