begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===- llvm/IR/DebugInfoMetadata.h - Debug info metadata --------*- C++ -*-===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// Declarations for metadata specific to debug info.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LLVM_IR_DEBUGINFOMETADATA_H
end_ifndef

begin_define
define|#
directive|define
name|LLVM_IR_DEBUGINFOMETADATA_H
end_define

begin_include
include|#
directive|include
file|"llvm/ADT/ArrayRef.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/BitmaskEnum.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/iterator_range.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/None.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/Optional.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/SmallVector.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/STLExtras.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/StringRef.h"
end_include

begin_include
include|#
directive|include
file|"llvm/IR/Metadata.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/Casting.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/Dwarf.h"
end_include

begin_include
include|#
directive|include
file|<cassert>
end_include

begin_include
include|#
directive|include
file|<climits>
end_include

begin_include
include|#
directive|include
file|<cstddef>
end_include

begin_include
include|#
directive|include
file|<cstdint>
end_include

begin_include
include|#
directive|include
file|<iterator>
end_include

begin_include
include|#
directive|include
file|<type_traits>
end_include

begin_include
include|#
directive|include
file|<vector>
end_include

begin_comment
comment|// Helper macros for defining get() overrides.
end_comment

begin_define
define|#
directive|define
name|DEFINE_MDNODE_GET_UNPACK_IMPL
parameter_list|(
modifier|...
parameter_list|)
value|__VA_ARGS__
end_define

begin_define
define|#
directive|define
name|DEFINE_MDNODE_GET_UNPACK
parameter_list|(
name|ARGS
parameter_list|)
value|DEFINE_MDNODE_GET_UNPACK_IMPL ARGS
end_define

begin_define
define|#
directive|define
name|DEFINE_MDNODE_GET_DISTINCT_TEMPORARY
parameter_list|(
name|CLASS
parameter_list|,
name|FORMAL
parameter_list|,
name|ARGS
parameter_list|)
define|\
value|static CLASS *getDistinct(LLVMContext&Context,                              \                             DEFINE_MDNODE_GET_UNPACK(FORMAL)) {                \     return getImpl(Context, DEFINE_MDNODE_GET_UNPACK(ARGS), Distinct);         \   }                                                                            \   static Temp##CLASS getTemporary(LLVMContext&Context,                        \                                   DEFINE_MDNODE_GET_UNPACK(FORMAL)) {          \     return Temp##CLASS(                                                        \         getImpl(Context, DEFINE_MDNODE_GET_UNPACK(ARGS), Temporary));          \   }
end_define

begin_define
define|#
directive|define
name|DEFINE_MDNODE_GET
parameter_list|(
name|CLASS
parameter_list|,
name|FORMAL
parameter_list|,
name|ARGS
parameter_list|)
define|\
value|static CLASS *get(LLVMContext&Context, DEFINE_MDNODE_GET_UNPACK(FORMAL)) {  \     return getImpl(Context, DEFINE_MDNODE_GET_UNPACK(ARGS), Uniqued);          \   }                                                                            \   static CLASS *getIfExists(LLVMContext&Context,                              \                             DEFINE_MDNODE_GET_UNPACK(FORMAL)) {                \     return getImpl(Context, DEFINE_MDNODE_GET_UNPACK(ARGS), Uniqued,           \
comment|/* ShouldCreate */
value|false);                                  \   }                                                                            \   DEFINE_MDNODE_GET_DISTINCT_TEMPORARY(CLASS, FORMAL, ARGS)
end_define

begin_decl_stmt
name|namespace
name|llvm
block|{
comment|/// Holds a subclass of DINode.
comment|///
comment|/// FIXME: This class doesn't currently make much sense.  Previously it was a
comment|/// union beteen MDString (for ODR-uniqued types) and things like DIType.  To
comment|/// support CodeView work, it wasn't deleted outright when MDString-based type
comment|/// references were deleted; we'll soon need a similar concept for CodeView
comment|/// DITypeIndex.
name|template
operator|<
name|class
name|T
operator|>
name|class
name|TypedDINodeRef
block|{
specifier|const
name|Metadata
operator|*
name|MD
operator|=
name|nullptr
block|;
name|public
operator|:
name|TypedDINodeRef
argument_list|()
operator|=
expr|default
block|;
name|TypedDINodeRef
argument_list|(
argument|std::nullptr_t
argument_list|)
block|{}
name|TypedDINodeRef
argument_list|(
specifier|const
name|T
operator|*
name|MD
argument_list|)
operator|:
name|MD
argument_list|(
argument|MD
argument_list|)
block|{}
name|explicit
name|TypedDINodeRef
argument_list|(
specifier|const
name|Metadata
operator|*
name|MD
argument_list|)
operator|:
name|MD
argument_list|(
argument|MD
argument_list|)
block|{
name|assert
argument_list|(
operator|(
operator|!
name|MD
operator|||
name|isa
operator|<
name|T
operator|>
operator|(
name|MD
operator|)
operator|)
operator|&&
literal|"Expected valid type ref"
argument_list|)
block|;   }
name|template
operator|<
name|class
name|U
operator|>
name|TypedDINodeRef
argument_list|(
argument|const TypedDINodeRef<U>&X
argument_list|,
argument|typename std::enable_if<std::is_convertible<U *
argument_list|,
argument|T *>::value>::type * =           nullptr
argument_list|)
operator|:
name|MD
argument_list|(
argument|X
argument_list|)
block|{}
name|operator
name|Metadata
operator|*
operator|(
operator|)
specifier|const
block|{
return|return
name|const_cast
operator|<
name|Metadata
operator|*
operator|>
operator|(
name|MD
operator|)
return|;
block|}
name|T
operator|*
name|resolve
argument_list|()
specifier|const
block|{
return|return
name|const_cast
operator|<
name|T
operator|*
operator|>
operator|(
name|cast_or_null
operator|<
name|T
operator|>
operator|(
name|MD
operator|)
operator|)
return|;
block|}
name|bool
name|operator
operator|==
operator|(
specifier|const
name|TypedDINodeRef
operator|<
name|T
operator|>
operator|&
name|X
operator|)
specifier|const
block|{
return|return
name|MD
operator|==
name|X
operator|.
name|MD
return|;
block|}
name|bool
name|operator
operator|!=
operator|(
specifier|const
name|TypedDINodeRef
operator|<
name|T
operator|>
operator|&
name|X
operator|)
specifier|const
block|{
return|return
name|MD
operator|!=
name|X
operator|.
name|MD
return|;
block|}
expr|}
block|;
name|using
name|DINodeRef
operator|=
name|TypedDINodeRef
operator|<
name|DINode
operator|>
block|;
name|using
name|DIScopeRef
operator|=
name|TypedDINodeRef
operator|<
name|DIScope
operator|>
block|;
name|using
name|DITypeRef
operator|=
name|TypedDINodeRef
operator|<
name|DIType
operator|>
block|;
name|class
name|DITypeRefArray
block|{
specifier|const
name|MDTuple
operator|*
name|N
operator|=
name|nullptr
block|;
name|public
operator|:
name|DITypeRefArray
argument_list|()
operator|=
expr|default
block|;
name|DITypeRefArray
argument_list|(
specifier|const
name|MDTuple
operator|*
name|N
argument_list|)
operator|:
name|N
argument_list|(
argument|N
argument_list|)
block|{}
name|explicit
name|operator
name|bool
argument_list|()
specifier|const
block|{
return|return
name|get
argument_list|()
return|;
block|}
name|explicit
name|operator
name|MDTuple
operator|*
operator|(
operator|)
specifier|const
block|{
return|return
name|get
argument_list|()
return|;
block|}
name|MDTuple
operator|*
name|get
argument_list|()
specifier|const
block|{
return|return
name|const_cast
operator|<
name|MDTuple
operator|*
operator|>
operator|(
name|N
operator|)
return|;
block|}
name|MDTuple
operator|*
name|operator
operator|->
expr|(
block|)
specifier|const
block|{
return|return
name|get
argument_list|()
return|;
block|}
name|MDTuple
operator|&
name|operator
operator|*
operator|(
operator|)
specifier|const
block|{
return|return
operator|*
name|get
argument_list|()
return|;
block|}
comment|// FIXME: Fix callers and remove condition on N.
name|unsigned
name|size
argument_list|()
specifier|const
block|{
return|return
name|N
operator|?
name|N
operator|->
name|getNumOperands
argument_list|()
operator|:
literal|0u
return|;
block|}
name|DITypeRef
name|operator
index|[]
operator|(
name|unsigned
name|I
operator|)
specifier|const
block|{
return|return
name|DITypeRef
argument_list|(
name|N
operator|->
name|getOperand
argument_list|(
name|I
argument_list|)
argument_list|)
return|;
block|}
name|class
name|iterator
operator|:
name|std
operator|::
name|iterator
operator|<
name|std
operator|::
name|input_iterator_tag
block|,
name|DITypeRef
block|,
name|std
operator|::
name|ptrdiff_t
block|,
name|void
block|,
name|DITypeRef
operator|>
block|{
name|MDNode
operator|::
name|op_iterator
name|I
operator|=
name|nullptr
block|;
name|public
operator|:
name|iterator
argument_list|()
operator|=
expr|default
block|;
name|explicit
name|iterator
argument_list|(
argument|MDNode::op_iterator I
argument_list|)
operator|:
name|I
argument_list|(
argument|I
argument_list|)
block|{}
name|DITypeRef
name|operator
operator|*
operator|(
operator|)
specifier|const
block|{
return|return
name|DITypeRef
argument_list|(
operator|*
name|I
argument_list|)
return|;
block|}
name|iterator
operator|&
name|operator
operator|++
operator|(
operator|)
block|{
operator|++
name|I
block|;
return|return
operator|*
name|this
return|;
block|}
name|iterator
name|operator
operator|++
operator|(
name|int
operator|)
block|{
name|iterator
name|Temp
argument_list|(
operator|*
name|this
argument_list|)
block|;
operator|++
name|I
block|;
return|return
name|Temp
return|;
block|}
name|bool
name|operator
operator|==
operator|(
specifier|const
name|iterator
operator|&
name|X
operator|)
specifier|const
block|{
return|return
name|I
operator|==
name|X
operator|.
name|I
return|;
block|}
name|bool
name|operator
operator|!=
operator|(
specifier|const
name|iterator
operator|&
name|X
operator|)
specifier|const
block|{
return|return
name|I
operator|!=
name|X
operator|.
name|I
return|;
block|}
expr|}
block|;
comment|// FIXME: Fix callers and remove condition on N.
name|iterator
name|begin
argument_list|()
specifier|const
block|{
return|return
name|N
condition|?
name|iterator
argument_list|(
name|N
operator|->
name|op_begin
argument_list|()
argument_list|)
else|:
name|iterator
argument_list|()
return|;
block|}
name|iterator
name|end
argument_list|()
specifier|const
block|{
return|return
name|N
condition|?
name|iterator
argument_list|(
name|N
operator|->
name|op_end
argument_list|()
argument_list|)
else|:
name|iterator
argument_list|()
return|;
block|}
expr|}
block|;
comment|/// Tagged DWARF-like metadata node.
comment|///
comment|/// A metadata node with a DWARF tag (i.e., a constant named \c DW_TAG_*,
comment|/// defined in llvm/Support/Dwarf.h).  Called \a DINode because it's
comment|/// potentially used for non-DWARF output.
name|class
name|DINode
operator|:
name|public
name|MDNode
block|{
name|friend
name|class
name|LLVMContextImpl
block|;
name|friend
name|class
name|MDNode
block|;
name|protected
operator|:
name|DINode
argument_list|(
argument|LLVMContext&C
argument_list|,
argument|unsigned ID
argument_list|,
argument|StorageType Storage
argument_list|,
argument|unsigned Tag
argument_list|,
argument|ArrayRef<Metadata *> Ops1
argument_list|,
argument|ArrayRef<Metadata *> Ops2 = None
argument_list|)
operator|:
name|MDNode
argument_list|(
argument|C
argument_list|,
argument|ID
argument_list|,
argument|Storage
argument_list|,
argument|Ops1
argument_list|,
argument|Ops2
argument_list|)
block|{
name|assert
argument_list|(
name|Tag
operator|<
literal|1u
operator|<<
literal|16
argument_list|)
block|;
name|SubclassData16
operator|=
name|Tag
block|;   }
operator|~
name|DINode
argument_list|()
operator|=
expr|default
block|;
name|template
operator|<
name|class
name|Ty
operator|>
name|Ty
operator|*
name|getOperandAs
argument_list|(
argument|unsigned I
argument_list|)
specifier|const
block|{
return|return
name|cast_or_null
operator|<
name|Ty
operator|>
operator|(
name|getOperand
argument_list|(
name|I
argument_list|)
operator|)
return|;
block|}
name|StringRef
name|getStringOperand
argument_list|(
argument|unsigned I
argument_list|)
specifier|const
block|{
if|if
condition|(
name|auto
operator|*
name|S
operator|=
name|getOperandAs
operator|<
name|MDString
operator|>
operator|(
name|I
operator|)
condition|)
return|return
name|S
operator|->
name|getString
argument_list|()
return|;
return|return
name|StringRef
argument_list|()
return|;
block|}
specifier|static
name|MDString
operator|*
name|getCanonicalMDString
argument_list|(
argument|LLVMContext&Context
argument_list|,
argument|StringRef S
argument_list|)
block|{
if|if
condition|(
name|S
operator|.
name|empty
argument_list|()
condition|)
return|return
name|nullptr
return|;
return|return
name|MDString
operator|::
name|get
argument_list|(
name|Context
argument_list|,
name|S
argument_list|)
return|;
block|}
comment|/// Allow subclasses to mutate the tag.
name|void
name|setTag
argument_list|(
argument|unsigned Tag
argument_list|)
block|{
name|SubclassData16
operator|=
name|Tag
block|; }
name|public
operator|:
name|unsigned
name|getTag
argument_list|()
specifier|const
block|{
return|return
name|SubclassData16
return|;
block|}
comment|/// Debug info flags.
comment|///
comment|/// The three accessibility flags are mutually exclusive and rolled together
comment|/// in the first two bits.
expr|enum
name|DIFlags
operator|:
name|uint32_t
block|{
define|#
directive|define
name|HANDLE_DI_FLAG
parameter_list|(
name|ID
parameter_list|,
name|NAME
parameter_list|)
value|Flag##NAME = ID,
define|#
directive|define
name|DI_FLAG_LARGEST_NEEDED
include|#
directive|include
file|"llvm/IR/DebugInfoFlags.def"
name|FlagAccessibility
operator|=
name|FlagPrivate
operator||
name|FlagProtected
operator||
name|FlagPublic
block|,
name|FlagPtrToMemberRep
operator|=
name|FlagSingleInheritance
operator||
name|FlagMultipleInheritance
operator||
name|FlagVirtualInheritance
block|,
name|LLVM_MARK_AS_BITMASK_ENUM
argument_list|(
argument|FlagLargest
argument_list|)
block|}
block|;
specifier|static
name|DIFlags
name|getFlag
argument_list|(
argument|StringRef Flag
argument_list|)
block|;
specifier|static
name|StringRef
name|getFlagString
argument_list|(
argument|DIFlags Flag
argument_list|)
block|;
comment|/// Split up a flags bitfield.
comment|///
comment|/// Split \c Flags into \c SplitFlags, a vector of its components.  Returns
comment|/// any remaining (unrecognized) bits.
specifier|static
name|DIFlags
name|splitFlags
argument_list|(
argument|DIFlags Flags
argument_list|,
argument|SmallVectorImpl<DIFlags>&SplitFlags
argument_list|)
block|;
specifier|static
name|bool
name|classof
argument_list|(
argument|const Metadata *MD
argument_list|)
block|{
switch|switch
condition|(
name|MD
operator|->
name|getMetadataID
argument_list|()
condition|)
block|{
default|default:
return|return
name|false
return|;
case|case
name|GenericDINodeKind
case|:
case|case
name|DISubrangeKind
case|:
case|case
name|DIEnumeratorKind
case|:
case|case
name|DIBasicTypeKind
case|:
case|case
name|DIDerivedTypeKind
case|:
case|case
name|DICompositeTypeKind
case|:
case|case
name|DISubroutineTypeKind
case|:
case|case
name|DIFileKind
case|:
case|case
name|DICompileUnitKind
case|:
case|case
name|DISubprogramKind
case|:
case|case
name|DILexicalBlockKind
case|:
case|case
name|DILexicalBlockFileKind
case|:
case|case
name|DINamespaceKind
case|:
case|case
name|DITemplateTypeParameterKind
case|:
case|case
name|DITemplateValueParameterKind
case|:
case|case
name|DIGlobalVariableKind
case|:
case|case
name|DILocalVariableKind
case|:
case|case
name|DIObjCPropertyKind
case|:
case|case
name|DIImportedEntityKind
case|:
case|case
name|DIModuleKind
case|:
return|return
name|true
return|;
block|}
block|}
block|}
expr_stmt|;
name|template
operator|<
name|class
name|T
operator|>
expr|struct
name|simplify_type
operator|<
specifier|const
name|TypedDINodeRef
operator|<
name|T
operator|>>
block|{
name|using
name|SimpleType
operator|=
name|Metadata
operator|*
block|;
specifier|static
name|SimpleType
name|getSimplifiedValue
argument_list|(
argument|const TypedDINodeRef<T>&MD
argument_list|)
block|{
return|return
name|MD
return|;
block|}
expr|}
block|;
name|template
operator|<
name|class
name|T
operator|>
expr|struct
name|simplify_type
operator|<
name|TypedDINodeRef
operator|<
name|T
operator|>>
operator|:
name|simplify_type
operator|<
specifier|const
name|TypedDINodeRef
operator|<
name|T
operator|>>
block|{}
block|;
comment|/// Generic tagged DWARF-like metadata node.
comment|///
comment|/// An un-specialized DWARF-like metadata node.  The first operand is a
comment|/// (possibly empty) null-separated \a MDString header that contains arbitrary
comment|/// fields.  The remaining operands are \a dwarf_operands(), and are pointers
comment|/// to other metadata.
name|class
name|GenericDINode
operator|:
name|public
name|DINode
block|{
name|friend
name|class
name|LLVMContextImpl
block|;
name|friend
name|class
name|MDNode
block|;
name|GenericDINode
argument_list|(
argument|LLVMContext&C
argument_list|,
argument|StorageType Storage
argument_list|,
argument|unsigned Hash
argument_list|,
argument|unsigned Tag
argument_list|,
argument|ArrayRef<Metadata *> Ops1
argument_list|,
argument|ArrayRef<Metadata *> Ops2
argument_list|)
operator|:
name|DINode
argument_list|(
argument|C
argument_list|,
argument|GenericDINodeKind
argument_list|,
argument|Storage
argument_list|,
argument|Tag
argument_list|,
argument|Ops1
argument_list|,
argument|Ops2
argument_list|)
block|{
name|setHash
argument_list|(
name|Hash
argument_list|)
block|;   }
operator|~
name|GenericDINode
argument_list|()
block|{
name|dropAllReferences
argument_list|()
block|; }
name|void
name|setHash
argument_list|(
argument|unsigned Hash
argument_list|)
block|{
name|SubclassData32
operator|=
name|Hash
block|; }
name|void
name|recalculateHash
argument_list|()
block|;
specifier|static
name|GenericDINode
operator|*
name|getImpl
argument_list|(
argument|LLVMContext&Context
argument_list|,
argument|unsigned Tag
argument_list|,
argument|StringRef Header
argument_list|,
argument|ArrayRef<Metadata *> DwarfOps
argument_list|,
argument|StorageType Storage
argument_list|,
argument|bool ShouldCreate = true
argument_list|)
block|{
return|return
name|getImpl
argument_list|(
name|Context
argument_list|,
name|Tag
argument_list|,
name|getCanonicalMDString
argument_list|(
name|Context
argument_list|,
name|Header
argument_list|)
argument_list|,
name|DwarfOps
argument_list|,
name|Storage
argument_list|,
name|ShouldCreate
argument_list|)
return|;
block|}
specifier|static
name|GenericDINode
operator|*
name|getImpl
argument_list|(
argument|LLVMContext&Context
argument_list|,
argument|unsigned Tag
argument_list|,
argument|MDString *Header
argument_list|,
argument|ArrayRef<Metadata *> DwarfOps
argument_list|,
argument|StorageType Storage
argument_list|,
argument|bool ShouldCreate = true
argument_list|)
block|;
name|TempGenericDINode
name|cloneImpl
argument_list|()
specifier|const
block|{
return|return
name|getTemporary
argument_list|(
name|getContext
argument_list|()
argument_list|,
name|getTag
argument_list|()
argument_list|,
name|getHeader
argument_list|()
argument_list|,
name|SmallVector
operator|<
name|Metadata
operator|*
argument_list|,
literal|4
operator|>
operator|(
name|dwarf_op_begin
argument_list|()
operator|,
name|dwarf_op_end
argument_list|()
operator|)
argument_list|)
return|;
block|}
name|public
operator|:
name|unsigned
name|getHash
argument_list|()
specifier|const
block|{
return|return
name|SubclassData32
return|;
block|}
name|DEFINE_MDNODE_GET
argument_list|(
argument|GenericDINode
argument_list|,
argument|(unsigned Tag, StringRef Header,                                     ArrayRef<Metadata *> DwarfOps)
argument_list|,
argument|(Tag, Header, DwarfOps)
argument_list|)
name|DEFINE_MDNODE_GET
argument_list|(
argument|GenericDINode
argument_list|,
argument|(unsigned Tag, MDString *Header,                                     ArrayRef<Metadata *> DwarfOps)
argument_list|,
argument|(Tag, Header, DwarfOps)
argument_list|)
comment|/// Return a (temporary) clone of this.
name|TempGenericDINode
name|clone
argument_list|()
specifier|const
block|{
return|return
name|cloneImpl
argument_list|()
return|;
block|}
name|unsigned
name|getTag
argument_list|()
specifier|const
block|{
return|return
name|SubclassData16
return|;
block|}
name|StringRef
name|getHeader
argument_list|()
specifier|const
block|{
return|return
name|getStringOperand
argument_list|(
literal|0
argument_list|)
return|;
block|}
name|MDString
operator|*
name|getRawHeader
argument_list|()
specifier|const
block|{
return|return
name|getOperandAs
operator|<
name|MDString
operator|>
operator|(
literal|0
operator|)
return|;
block|}
name|op_iterator
name|dwarf_op_begin
argument_list|()
specifier|const
block|{
return|return
name|op_begin
argument_list|()
operator|+
literal|1
return|;
block|}
name|op_iterator
name|dwarf_op_end
argument_list|()
specifier|const
block|{
return|return
name|op_end
argument_list|()
return|;
block|}
name|op_range
name|dwarf_operands
argument_list|()
specifier|const
block|{
return|return
name|op_range
argument_list|(
name|dwarf_op_begin
argument_list|()
argument_list|,
name|dwarf_op_end
argument_list|()
argument_list|)
return|;
block|}
name|unsigned
name|getNumDwarfOperands
argument_list|()
specifier|const
block|{
return|return
name|getNumOperands
argument_list|()
operator|-
literal|1
return|;
block|}
specifier|const
name|MDOperand
operator|&
name|getDwarfOperand
argument_list|(
argument|unsigned I
argument_list|)
specifier|const
block|{
return|return
name|getOperand
argument_list|(
name|I
operator|+
literal|1
argument_list|)
return|;
block|}
name|void
name|replaceDwarfOperandWith
argument_list|(
argument|unsigned I
argument_list|,
argument|Metadata *New
argument_list|)
block|{
name|replaceOperandWith
argument_list|(
name|I
operator|+
literal|1
argument_list|,
name|New
argument_list|)
block|;   }
specifier|static
name|bool
name|classof
argument_list|(
argument|const Metadata *MD
argument_list|)
block|{
return|return
name|MD
operator|->
name|getMetadataID
argument_list|()
operator|==
name|GenericDINodeKind
return|;
block|}
expr|}
block|;
comment|/// Array subrange.
comment|///
comment|/// TODO: Merge into node for DW_TAG_array_type, which should have a custom
comment|/// type.
name|class
name|DISubrange
operator|:
name|public
name|DINode
block|{
name|friend
name|class
name|LLVMContextImpl
block|;
name|friend
name|class
name|MDNode
block|;
name|int64_t
name|Count
block|;
name|int64_t
name|LowerBound
block|;
name|DISubrange
argument_list|(
argument|LLVMContext&C
argument_list|,
argument|StorageType Storage
argument_list|,
argument|int64_t Count
argument_list|,
argument|int64_t LowerBound
argument_list|)
operator|:
name|DINode
argument_list|(
name|C
argument_list|,
name|DISubrangeKind
argument_list|,
name|Storage
argument_list|,
name|dwarf
operator|::
name|DW_TAG_subrange_type
argument_list|,
name|None
argument_list|)
block|,
name|Count
argument_list|(
name|Count
argument_list|)
block|,
name|LowerBound
argument_list|(
argument|LowerBound
argument_list|)
block|{}
operator|~
name|DISubrange
argument_list|()
operator|=
expr|default
block|;
specifier|static
name|DISubrange
operator|*
name|getImpl
argument_list|(
argument|LLVMContext&Context
argument_list|,
argument|int64_t Count
argument_list|,
argument|int64_t LowerBound
argument_list|,
argument|StorageType Storage
argument_list|,
argument|bool ShouldCreate = true
argument_list|)
block|;
name|TempDISubrange
name|cloneImpl
argument_list|()
specifier|const
block|{
return|return
name|getTemporary
argument_list|(
name|getContext
argument_list|()
argument_list|,
name|getCount
argument_list|()
argument_list|,
name|getLowerBound
argument_list|()
argument_list|)
return|;
block|}
name|public
operator|:
name|DEFINE_MDNODE_GET
argument_list|(
argument|DISubrange
argument_list|,
argument|(int64_t Count, int64_t LowerBound =
literal|0
argument|)
argument_list|,
argument|(Count, LowerBound)
argument_list|)
name|TempDISubrange
name|clone
argument_list|()
specifier|const
block|{
return|return
name|cloneImpl
argument_list|()
return|;
block|}
name|int64_t
name|getLowerBound
argument_list|()
specifier|const
block|{
return|return
name|LowerBound
return|;
block|}
name|int64_t
name|getCount
argument_list|()
specifier|const
block|{
return|return
name|Count
return|;
block|}
specifier|static
name|bool
name|classof
argument_list|(
argument|const Metadata *MD
argument_list|)
block|{
return|return
name|MD
operator|->
name|getMetadataID
argument_list|()
operator|==
name|DISubrangeKind
return|;
block|}
expr|}
block|;
comment|/// Enumeration value.
comment|///
comment|/// TODO: Add a pointer to the context (DW_TAG_enumeration_type) once that no
comment|/// longer creates a type cycle.
name|class
name|DIEnumerator
operator|:
name|public
name|DINode
block|{
name|friend
name|class
name|LLVMContextImpl
block|;
name|friend
name|class
name|MDNode
block|;
name|int64_t
name|Value
block|;
name|DIEnumerator
argument_list|(
argument|LLVMContext&C
argument_list|,
argument|StorageType Storage
argument_list|,
argument|int64_t Value
argument_list|,
argument|ArrayRef<Metadata *> Ops
argument_list|)
operator|:
name|DINode
argument_list|(
name|C
argument_list|,
name|DIEnumeratorKind
argument_list|,
name|Storage
argument_list|,
name|dwarf
operator|::
name|DW_TAG_enumerator
argument_list|,
name|Ops
argument_list|)
block|,
name|Value
argument_list|(
argument|Value
argument_list|)
block|{}
operator|~
name|DIEnumerator
argument_list|()
operator|=
expr|default
block|;
specifier|static
name|DIEnumerator
operator|*
name|getImpl
argument_list|(
argument|LLVMContext&Context
argument_list|,
argument|int64_t Value
argument_list|,
argument|StringRef Name
argument_list|,
argument|StorageType Storage
argument_list|,
argument|bool ShouldCreate = true
argument_list|)
block|{
return|return
name|getImpl
argument_list|(
name|Context
argument_list|,
name|Value
argument_list|,
name|getCanonicalMDString
argument_list|(
name|Context
argument_list|,
name|Name
argument_list|)
argument_list|,
name|Storage
argument_list|,
name|ShouldCreate
argument_list|)
return|;
block|}
specifier|static
name|DIEnumerator
operator|*
name|getImpl
argument_list|(
argument|LLVMContext&Context
argument_list|,
argument|int64_t Value
argument_list|,
argument|MDString *Name
argument_list|,
argument|StorageType Storage
argument_list|,
argument|bool ShouldCreate = true
argument_list|)
block|;
name|TempDIEnumerator
name|cloneImpl
argument_list|()
specifier|const
block|{
return|return
name|getTemporary
argument_list|(
name|getContext
argument_list|()
argument_list|,
name|getValue
argument_list|()
argument_list|,
name|getName
argument_list|()
argument_list|)
return|;
block|}
name|public
operator|:
name|DEFINE_MDNODE_GET
argument_list|(
argument|DIEnumerator
argument_list|,
argument|(int64_t Value, StringRef Name)
argument_list|,
argument|(Value, Name)
argument_list|)
name|DEFINE_MDNODE_GET
argument_list|(
argument|DIEnumerator
argument_list|,
argument|(int64_t Value, MDString *Name)
argument_list|,
argument|(Value, Name)
argument_list|)
name|TempDIEnumerator
name|clone
argument_list|()
specifier|const
block|{
return|return
name|cloneImpl
argument_list|()
return|;
block|}
name|int64_t
name|getValue
argument_list|()
specifier|const
block|{
return|return
name|Value
return|;
block|}
name|StringRef
name|getName
argument_list|()
specifier|const
block|{
return|return
name|getStringOperand
argument_list|(
literal|0
argument_list|)
return|;
block|}
name|MDString
operator|*
name|getRawName
argument_list|()
specifier|const
block|{
return|return
name|getOperandAs
operator|<
name|MDString
operator|>
operator|(
literal|0
operator|)
return|;
block|}
specifier|static
name|bool
name|classof
argument_list|(
argument|const Metadata *MD
argument_list|)
block|{
return|return
name|MD
operator|->
name|getMetadataID
argument_list|()
operator|==
name|DIEnumeratorKind
return|;
block|}
expr|}
block|;
comment|/// Base class for scope-like contexts.
comment|///
comment|/// Base class for lexical scopes and types (which are also declaration
comment|/// contexts).
comment|///
comment|/// TODO: Separate the concepts of declaration contexts and lexical scopes.
name|class
name|DIScope
operator|:
name|public
name|DINode
block|{
name|protected
operator|:
name|DIScope
argument_list|(
argument|LLVMContext&C
argument_list|,
argument|unsigned ID
argument_list|,
argument|StorageType Storage
argument_list|,
argument|unsigned Tag
argument_list|,
argument|ArrayRef<Metadata *> Ops
argument_list|)
operator|:
name|DINode
argument_list|(
argument|C
argument_list|,
argument|ID
argument_list|,
argument|Storage
argument_list|,
argument|Tag
argument_list|,
argument|Ops
argument_list|)
block|{}
operator|~
name|DIScope
argument_list|()
operator|=
expr|default
block|;
name|public
operator|:
name|DIFile
operator|*
name|getFile
argument_list|()
specifier|const
block|{
return|return
name|cast_or_null
operator|<
name|DIFile
operator|>
operator|(
name|getRawFile
argument_list|()
operator|)
return|;
block|}
specifier|inline
name|StringRef
name|getFilename
argument_list|()
specifier|const
block|;
specifier|inline
name|StringRef
name|getDirectory
argument_list|()
specifier|const
block|;
name|StringRef
name|getName
argument_list|()
specifier|const
block|;
name|DIScopeRef
name|getScope
argument_list|()
specifier|const
block|;
comment|/// Return the raw underlying file.
comment|///
comment|/// A \a DIFile is a \a DIScope, but it doesn't point at a separate file
comment|/// (it\em is the file).  If \c this is an \a DIFile, we need to return \c
comment|/// this.  Otherwise, return the first operand, which is where all other
comment|/// subclasses store their file pointer.
name|Metadata
operator|*
name|getRawFile
argument_list|()
specifier|const
block|{
return|return
name|isa
operator|<
name|DIFile
operator|>
operator|(
name|this
operator|)
operator|?
name|const_cast
operator|<
name|DIScope
operator|*
operator|>
operator|(
name|this
operator|)
operator|:
name|static_cast
operator|<
name|Metadata
operator|*
operator|>
operator|(
name|getOperand
argument_list|(
literal|0
argument_list|)
operator|)
return|;
block|}
specifier|static
name|bool
name|classof
argument_list|(
argument|const Metadata *MD
argument_list|)
block|{
switch|switch
condition|(
name|MD
operator|->
name|getMetadataID
argument_list|()
condition|)
block|{
default|default:
return|return
name|false
return|;
case|case
name|DIBasicTypeKind
case|:
case|case
name|DIDerivedTypeKind
case|:
case|case
name|DICompositeTypeKind
case|:
case|case
name|DISubroutineTypeKind
case|:
case|case
name|DIFileKind
case|:
case|case
name|DICompileUnitKind
case|:
case|case
name|DISubprogramKind
case|:
case|case
name|DILexicalBlockKind
case|:
case|case
name|DILexicalBlockFileKind
case|:
case|case
name|DINamespaceKind
case|:
case|case
name|DIModuleKind
case|:
return|return
name|true
return|;
block|}
block|}
expr|}
block|;
comment|/// File.
comment|///
comment|/// TODO: Merge with directory/file node (including users).
comment|/// TODO: Canonicalize paths on creation.
name|class
name|DIFile
operator|:
name|public
name|DIScope
block|{
name|friend
name|class
name|LLVMContextImpl
block|;
name|friend
name|class
name|MDNode
block|;
name|public
operator|:
expr|enum
name|ChecksumKind
block|{
name|CSK_None
block|,
name|CSK_MD5
block|,
name|CSK_SHA1
block|,
name|CSK_Last
operator|=
name|CSK_SHA1
comment|// Should be last enumeration.
block|}
block|;
name|private
operator|:
name|ChecksumKind
name|CSKind
block|;
name|DIFile
argument_list|(
argument|LLVMContext&C
argument_list|,
argument|StorageType Storage
argument_list|,
argument|ChecksumKind CSK
argument_list|,
argument|ArrayRef<Metadata *> Ops
argument_list|)
operator|:
name|DIScope
argument_list|(
name|C
argument_list|,
name|DIFileKind
argument_list|,
name|Storage
argument_list|,
name|dwarf
operator|::
name|DW_TAG_file_type
argument_list|,
name|Ops
argument_list|)
block|,
name|CSKind
argument_list|(
argument|CSK
argument_list|)
block|{}
operator|~
name|DIFile
argument_list|()
operator|=
expr|default
block|;
specifier|static
name|DIFile
operator|*
name|getImpl
argument_list|(
argument|LLVMContext&Context
argument_list|,
argument|StringRef Filename
argument_list|,
argument|StringRef Directory
argument_list|,
argument|ChecksumKind CSK
argument_list|,
argument|StringRef CS
argument_list|,
argument|StorageType Storage
argument_list|,
argument|bool ShouldCreate = true
argument_list|)
block|{
return|return
name|getImpl
argument_list|(
name|Context
argument_list|,
name|getCanonicalMDString
argument_list|(
name|Context
argument_list|,
name|Filename
argument_list|)
argument_list|,
name|getCanonicalMDString
argument_list|(
name|Context
argument_list|,
name|Directory
argument_list|)
argument_list|,
name|CSK
argument_list|,
name|getCanonicalMDString
argument_list|(
name|Context
argument_list|,
name|CS
argument_list|)
argument_list|,
name|Storage
argument_list|,
name|ShouldCreate
argument_list|)
return|;
block|}
specifier|static
name|DIFile
operator|*
name|getImpl
argument_list|(
argument|LLVMContext&Context
argument_list|,
argument|MDString *Filename
argument_list|,
argument|MDString *Directory
argument_list|,
argument|ChecksumKind CSK
argument_list|,
argument|MDString *CS
argument_list|,
argument|StorageType Storage
argument_list|,
argument|bool ShouldCreate = true
argument_list|)
block|;
name|TempDIFile
name|cloneImpl
argument_list|()
specifier|const
block|{
return|return
name|getTemporary
argument_list|(
name|getContext
argument_list|()
argument_list|,
name|getFilename
argument_list|()
argument_list|,
name|getDirectory
argument_list|()
argument_list|,
name|getChecksumKind
argument_list|()
argument_list|,
name|getChecksum
argument_list|()
argument_list|)
return|;
block|}
name|public
operator|:
name|DEFINE_MDNODE_GET
argument_list|(
argument|DIFile
argument_list|,
argument|(StringRef Filename, StringRef Directory,                              ChecksumKind CSK = CSK_None,                              StringRef CS = StringRef())
argument_list|,
argument|(Filename, Directory, CSK, CS)
argument_list|)
name|DEFINE_MDNODE_GET
argument_list|(
argument|DIFile
argument_list|,
argument|(MDString *Filename, MDString *Directory,                              ChecksumKind CSK = CSK_None,                              MDString *CS = nullptr)
argument_list|,
argument|(Filename, Directory, CSK, CS)
argument_list|)
name|TempDIFile
name|clone
argument_list|()
specifier|const
block|{
return|return
name|cloneImpl
argument_list|()
return|;
block|}
name|StringRef
name|getFilename
argument_list|()
specifier|const
block|{
return|return
name|getStringOperand
argument_list|(
literal|0
argument_list|)
return|;
block|}
name|StringRef
name|getDirectory
argument_list|()
specifier|const
block|{
return|return
name|getStringOperand
argument_list|(
literal|1
argument_list|)
return|;
block|}
name|StringRef
name|getChecksum
argument_list|()
specifier|const
block|{
return|return
name|getStringOperand
argument_list|(
literal|2
argument_list|)
return|;
block|}
name|ChecksumKind
name|getChecksumKind
argument_list|()
specifier|const
block|{
return|return
name|CSKind
return|;
block|}
name|StringRef
name|getChecksumKindAsString
argument_list|()
specifier|const
block|;
name|MDString
operator|*
name|getRawFilename
argument_list|()
specifier|const
block|{
return|return
name|getOperandAs
operator|<
name|MDString
operator|>
operator|(
literal|0
operator|)
return|;
block|}
name|MDString
operator|*
name|getRawDirectory
argument_list|()
specifier|const
block|{
return|return
name|getOperandAs
operator|<
name|MDString
operator|>
operator|(
literal|1
operator|)
return|;
block|}
name|MDString
operator|*
name|getRawChecksum
argument_list|()
specifier|const
block|{
return|return
name|getOperandAs
operator|<
name|MDString
operator|>
operator|(
literal|2
operator|)
return|;
block|}
specifier|static
name|ChecksumKind
name|getChecksumKind
argument_list|(
argument|StringRef CSKindStr
argument_list|)
block|;
specifier|static
name|bool
name|classof
argument_list|(
argument|const Metadata *MD
argument_list|)
block|{
return|return
name|MD
operator|->
name|getMetadataID
argument_list|()
operator|==
name|DIFileKind
return|;
block|}
expr|}
block|;
name|StringRef
name|DIScope
operator|::
name|getFilename
argument_list|()
specifier|const
block|{
if|if
condition|(
name|auto
operator|*
name|F
operator|=
name|getFile
argument_list|()
condition|)
return|return
name|F
operator|->
name|getFilename
argument_list|()
return|;
return|return
literal|""
return|;
block|}
name|StringRef
name|DIScope
operator|::
name|getDirectory
argument_list|()
specifier|const
block|{
if|if
condition|(
name|auto
operator|*
name|F
operator|=
name|getFile
argument_list|()
condition|)
return|return
name|F
operator|->
name|getDirectory
argument_list|()
return|;
return|return
literal|""
return|;
block|}
comment|/// Base class for types.
comment|///
comment|/// TODO: Remove the hardcoded name and context, since many types don't use
comment|/// them.
comment|/// TODO: Split up flags.
name|class
name|DIType
operator|:
name|public
name|DIScope
block|{
name|unsigned
name|Line
block|;
name|DIFlags
name|Flags
block|;
name|uint64_t
name|SizeInBits
block|;
name|uint64_t
name|OffsetInBits
block|;
name|uint32_t
name|AlignInBits
block|;
name|protected
operator|:
name|DIType
argument_list|(
argument|LLVMContext&C
argument_list|,
argument|unsigned ID
argument_list|,
argument|StorageType Storage
argument_list|,
argument|unsigned Tag
argument_list|,
argument|unsigned Line
argument_list|,
argument|uint64_t SizeInBits
argument_list|,
argument|uint32_t AlignInBits
argument_list|,
argument|uint64_t OffsetInBits
argument_list|,
argument|DIFlags Flags
argument_list|,
argument|ArrayRef<Metadata *> Ops
argument_list|)
operator|:
name|DIScope
argument_list|(
argument|C
argument_list|,
argument|ID
argument_list|,
argument|Storage
argument_list|,
argument|Tag
argument_list|,
argument|Ops
argument_list|)
block|{
name|init
argument_list|(
name|Line
argument_list|,
name|SizeInBits
argument_list|,
name|AlignInBits
argument_list|,
name|OffsetInBits
argument_list|,
name|Flags
argument_list|)
block|;   }
operator|~
name|DIType
argument_list|()
operator|=
expr|default
block|;
name|void
name|init
argument_list|(
argument|unsigned Line
argument_list|,
argument|uint64_t SizeInBits
argument_list|,
argument|uint32_t AlignInBits
argument_list|,
argument|uint64_t OffsetInBits
argument_list|,
argument|DIFlags Flags
argument_list|)
block|{
name|this
operator|->
name|Line
operator|=
name|Line
block|;
name|this
operator|->
name|Flags
operator|=
name|Flags
block|;
name|this
operator|->
name|SizeInBits
operator|=
name|SizeInBits
block|;
name|this
operator|->
name|AlignInBits
operator|=
name|AlignInBits
block|;
name|this
operator|->
name|OffsetInBits
operator|=
name|OffsetInBits
block|;   }
comment|/// Change fields in place.
name|void
name|mutate
argument_list|(
argument|unsigned Tag
argument_list|,
argument|unsigned Line
argument_list|,
argument|uint64_t SizeInBits
argument_list|,
argument|uint32_t AlignInBits
argument_list|,
argument|uint64_t OffsetInBits
argument_list|,
argument|DIFlags Flags
argument_list|)
block|{
name|assert
argument_list|(
name|isDistinct
argument_list|()
operator|&&
literal|"Only distinct nodes can mutate"
argument_list|)
block|;
name|setTag
argument_list|(
name|Tag
argument_list|)
block|;
name|init
argument_list|(
name|Line
argument_list|,
name|SizeInBits
argument_list|,
name|AlignInBits
argument_list|,
name|OffsetInBits
argument_list|,
name|Flags
argument_list|)
block|;   }
name|public
operator|:
name|TempDIType
name|clone
argument_list|()
specifier|const
block|{
return|return
name|TempDIType
argument_list|(
name|cast
operator|<
name|DIType
operator|>
operator|(
name|MDNode
operator|::
name|clone
argument_list|()
operator|.
name|release
argument_list|()
operator|)
argument_list|)
return|;
block|}
name|unsigned
name|getLine
argument_list|()
specifier|const
block|{
return|return
name|Line
return|;
block|}
name|uint64_t
name|getSizeInBits
argument_list|()
specifier|const
block|{
return|return
name|SizeInBits
return|;
block|}
name|uint32_t
name|getAlignInBits
argument_list|()
specifier|const
block|{
return|return
name|AlignInBits
return|;
block|}
name|uint32_t
name|getAlignInBytes
argument_list|()
specifier|const
block|{
return|return
name|getAlignInBits
argument_list|()
operator|/
name|CHAR_BIT
return|;
block|}
name|uint64_t
name|getOffsetInBits
argument_list|()
specifier|const
block|{
return|return
name|OffsetInBits
return|;
block|}
name|DIFlags
name|getFlags
argument_list|()
specifier|const
block|{
return|return
name|Flags
return|;
block|}
name|DIScopeRef
name|getScope
argument_list|()
specifier|const
block|{
return|return
name|DIScopeRef
argument_list|(
name|getRawScope
argument_list|()
argument_list|)
return|;
block|}
name|StringRef
name|getName
argument_list|()
specifier|const
block|{
return|return
name|getStringOperand
argument_list|(
literal|2
argument_list|)
return|;
block|}
name|Metadata
operator|*
name|getRawScope
argument_list|()
specifier|const
block|{
return|return
name|getOperand
argument_list|(
literal|1
argument_list|)
return|;
block|}
name|MDString
operator|*
name|getRawName
argument_list|()
specifier|const
block|{
return|return
name|getOperandAs
operator|<
name|MDString
operator|>
operator|(
literal|2
operator|)
return|;
block|}
name|void
name|setFlags
argument_list|(
argument|DIFlags NewFlags
argument_list|)
block|{
name|assert
argument_list|(
operator|!
name|isUniqued
argument_list|()
operator|&&
literal|"Cannot set flags on uniqued nodes"
argument_list|)
block|;
name|Flags
operator|=
name|NewFlags
block|;   }
name|bool
name|isPrivate
argument_list|()
specifier|const
block|{
return|return
operator|(
name|getFlags
argument_list|()
operator|&
name|FlagAccessibility
operator|)
operator|==
name|FlagPrivate
return|;
block|}
name|bool
name|isProtected
argument_list|()
specifier|const
block|{
return|return
operator|(
name|getFlags
argument_list|()
operator|&
name|FlagAccessibility
operator|)
operator|==
name|FlagProtected
return|;
block|}
name|bool
name|isPublic
argument_list|()
specifier|const
block|{
return|return
operator|(
name|getFlags
argument_list|()
operator|&
name|FlagAccessibility
operator|)
operator|==
name|FlagPublic
return|;
block|}
name|bool
name|isForwardDecl
argument_list|()
specifier|const
block|{
return|return
name|getFlags
argument_list|()
operator|&
name|FlagFwdDecl
return|;
block|}
name|bool
name|isAppleBlockExtension
argument_list|()
specifier|const
block|{
return|return
name|getFlags
argument_list|()
operator|&
name|FlagAppleBlock
return|;
block|}
name|bool
name|isBlockByrefStruct
argument_list|()
specifier|const
block|{
return|return
name|getFlags
argument_list|()
operator|&
name|FlagBlockByrefStruct
return|;
block|}
name|bool
name|isVirtual
argument_list|()
specifier|const
block|{
return|return
name|getFlags
argument_list|()
operator|&
name|FlagVirtual
return|;
block|}
name|bool
name|isArtificial
argument_list|()
specifier|const
block|{
return|return
name|getFlags
argument_list|()
operator|&
name|FlagArtificial
return|;
block|}
name|bool
name|isObjectPointer
argument_list|()
specifier|const
block|{
return|return
name|getFlags
argument_list|()
operator|&
name|FlagObjectPointer
return|;
block|}
name|bool
name|isObjcClassComplete
argument_list|()
specifier|const
block|{
return|return
name|getFlags
argument_list|()
operator|&
name|FlagObjcClassComplete
return|;
block|}
name|bool
name|isVector
argument_list|()
specifier|const
block|{
return|return
name|getFlags
argument_list|()
operator|&
name|FlagVector
return|;
block|}
name|bool
name|isBitField
argument_list|()
specifier|const
block|{
return|return
name|getFlags
argument_list|()
operator|&
name|FlagBitField
return|;
block|}
name|bool
name|isStaticMember
argument_list|()
specifier|const
block|{
return|return
name|getFlags
argument_list|()
operator|&
name|FlagStaticMember
return|;
block|}
name|bool
name|isLValueReference
argument_list|()
specifier|const
block|{
return|return
name|getFlags
argument_list|()
operator|&
name|FlagLValueReference
return|;
block|}
name|bool
name|isRValueReference
argument_list|()
specifier|const
block|{
return|return
name|getFlags
argument_list|()
operator|&
name|FlagRValueReference
return|;
block|}
specifier|static
name|bool
name|classof
argument_list|(
argument|const Metadata *MD
argument_list|)
block|{
switch|switch
condition|(
name|MD
operator|->
name|getMetadataID
argument_list|()
condition|)
block|{
default|default:
return|return
name|false
return|;
case|case
name|DIBasicTypeKind
case|:
case|case
name|DIDerivedTypeKind
case|:
case|case
name|DICompositeTypeKind
case|:
case|case
name|DISubroutineTypeKind
case|:
return|return
name|true
return|;
block|}
block|}
expr|}
block|;
comment|/// Basic type, like 'int' or 'float'.
comment|///
comment|/// TODO: Split out DW_TAG_unspecified_type.
comment|/// TODO: Drop unused accessors.
name|class
name|DIBasicType
operator|:
name|public
name|DIType
block|{
name|friend
name|class
name|LLVMContextImpl
block|;
name|friend
name|class
name|MDNode
block|;
name|unsigned
name|Encoding
block|;
name|DIBasicType
argument_list|(
argument|LLVMContext&C
argument_list|,
argument|StorageType Storage
argument_list|,
argument|unsigned Tag
argument_list|,
argument|uint64_t SizeInBits
argument_list|,
argument|uint32_t AlignInBits
argument_list|,
argument|unsigned Encoding
argument_list|,
argument|ArrayRef<Metadata *> Ops
argument_list|)
operator|:
name|DIType
argument_list|(
name|C
argument_list|,
name|DIBasicTypeKind
argument_list|,
name|Storage
argument_list|,
name|Tag
argument_list|,
literal|0
argument_list|,
name|SizeInBits
argument_list|,
name|AlignInBits
argument_list|,
literal|0
argument_list|,
name|FlagZero
argument_list|,
name|Ops
argument_list|)
block|,
name|Encoding
argument_list|(
argument|Encoding
argument_list|)
block|{}
operator|~
name|DIBasicType
argument_list|()
operator|=
expr|default
block|;
specifier|static
name|DIBasicType
operator|*
name|getImpl
argument_list|(
argument|LLVMContext&Context
argument_list|,
argument|unsigned Tag
argument_list|,
argument|StringRef Name
argument_list|,
argument|uint64_t SizeInBits
argument_list|,
argument|uint32_t AlignInBits
argument_list|,
argument|unsigned Encoding
argument_list|,
argument|StorageType Storage
argument_list|,
argument|bool ShouldCreate = true
argument_list|)
block|{
return|return
name|getImpl
argument_list|(
name|Context
argument_list|,
name|Tag
argument_list|,
name|getCanonicalMDString
argument_list|(
name|Context
argument_list|,
name|Name
argument_list|)
argument_list|,
name|SizeInBits
argument_list|,
name|AlignInBits
argument_list|,
name|Encoding
argument_list|,
name|Storage
argument_list|,
name|ShouldCreate
argument_list|)
return|;
block|}
specifier|static
name|DIBasicType
operator|*
name|getImpl
argument_list|(
argument|LLVMContext&Context
argument_list|,
argument|unsigned Tag
argument_list|,
argument|MDString *Name
argument_list|,
argument|uint64_t SizeInBits
argument_list|,
argument|uint32_t AlignInBits
argument_list|,
argument|unsigned Encoding
argument_list|,
argument|StorageType Storage
argument_list|,
argument|bool ShouldCreate = true
argument_list|)
block|;
name|TempDIBasicType
name|cloneImpl
argument_list|()
specifier|const
block|{
return|return
name|getTemporary
argument_list|(
name|getContext
argument_list|()
argument_list|,
name|getTag
argument_list|()
argument_list|,
name|getName
argument_list|()
argument_list|,
name|getSizeInBits
argument_list|()
argument_list|,
name|getAlignInBits
argument_list|()
argument_list|,
name|getEncoding
argument_list|()
argument_list|)
return|;
block|}
name|public
operator|:
name|DEFINE_MDNODE_GET
argument_list|(
argument|DIBasicType
argument_list|,
argument|(unsigned Tag, StringRef Name)
argument_list|,
argument|(Tag, Name,
literal|0
argument|,
literal|0
argument|,
literal|0
argument|)
argument_list|)
name|DEFINE_MDNODE_GET
argument_list|(
argument|DIBasicType
argument_list|,
argument|(unsigned Tag, StringRef Name, uint64_t SizeInBits,                      uint32_t AlignInBits, unsigned Encoding)
argument_list|,
argument|(Tag, Name, SizeInBits, AlignInBits, Encoding)
argument_list|)
name|DEFINE_MDNODE_GET
argument_list|(
argument|DIBasicType
argument_list|,
argument|(unsigned Tag, MDString *Name, uint64_t SizeInBits,                      uint32_t AlignInBits, unsigned Encoding)
argument_list|,
argument|(Tag, Name, SizeInBits, AlignInBits, Encoding)
argument_list|)
name|TempDIBasicType
name|clone
argument_list|()
specifier|const
block|{
return|return
name|cloneImpl
argument_list|()
return|;
block|}
name|unsigned
name|getEncoding
argument_list|()
specifier|const
block|{
return|return
name|Encoding
return|;
block|}
specifier|static
name|bool
name|classof
argument_list|(
argument|const Metadata *MD
argument_list|)
block|{
return|return
name|MD
operator|->
name|getMetadataID
argument_list|()
operator|==
name|DIBasicTypeKind
return|;
block|}
expr|}
block|;
comment|/// Derived types.
comment|///
comment|/// This includes qualified types, pointers, references, friends, typedefs, and
comment|/// class members.
comment|///
comment|/// TODO: Split out members (inheritance, fields, methods, etc.).
name|class
name|DIDerivedType
operator|:
name|public
name|DIType
block|{
name|friend
name|class
name|LLVMContextImpl
block|;
name|friend
name|class
name|MDNode
block|;
comment|/// \brief The DWARF address space of the memory pointed to or referenced by a
comment|/// pointer or reference type respectively.
name|Optional
operator|<
name|unsigned
operator|>
name|DWARFAddressSpace
block|;
name|DIDerivedType
argument_list|(
argument|LLVMContext&C
argument_list|,
argument|StorageType Storage
argument_list|,
argument|unsigned Tag
argument_list|,
argument|unsigned Line
argument_list|,
argument|uint64_t SizeInBits
argument_list|,
argument|uint32_t AlignInBits
argument_list|,
argument|uint64_t OffsetInBits
argument_list|,
argument|Optional<unsigned> DWARFAddressSpace
argument_list|,
argument|DIFlags Flags
argument_list|,
argument|ArrayRef<Metadata *> Ops
argument_list|)
operator|:
name|DIType
argument_list|(
name|C
argument_list|,
name|DIDerivedTypeKind
argument_list|,
name|Storage
argument_list|,
name|Tag
argument_list|,
name|Line
argument_list|,
name|SizeInBits
argument_list|,
name|AlignInBits
argument_list|,
name|OffsetInBits
argument_list|,
name|Flags
argument_list|,
name|Ops
argument_list|)
block|,
name|DWARFAddressSpace
argument_list|(
argument|DWARFAddressSpace
argument_list|)
block|{}
operator|~
name|DIDerivedType
argument_list|()
operator|=
expr|default
block|;
specifier|static
name|DIDerivedType
operator|*
name|getImpl
argument_list|(
argument|LLVMContext&Context
argument_list|,
argument|unsigned Tag
argument_list|,
argument|StringRef Name
argument_list|,
argument|DIFile *File
argument_list|,
argument|unsigned Line
argument_list|,
argument|DIScopeRef Scope
argument_list|,
argument|DITypeRef BaseType
argument_list|,
argument|uint64_t SizeInBits
argument_list|,
argument|uint32_t AlignInBits
argument_list|,
argument|uint64_t OffsetInBits
argument_list|,
argument|Optional<unsigned> DWARFAddressSpace
argument_list|,
argument|DIFlags Flags
argument_list|,
argument|Metadata *ExtraData
argument_list|,
argument|StorageType Storage
argument_list|,
argument|bool ShouldCreate = true
argument_list|)
block|{
return|return
name|getImpl
argument_list|(
name|Context
argument_list|,
name|Tag
argument_list|,
name|getCanonicalMDString
argument_list|(
name|Context
argument_list|,
name|Name
argument_list|)
argument_list|,
name|File
argument_list|,
name|Line
argument_list|,
name|Scope
argument_list|,
name|BaseType
argument_list|,
name|SizeInBits
argument_list|,
name|AlignInBits
argument_list|,
name|OffsetInBits
argument_list|,
name|DWARFAddressSpace
argument_list|,
name|Flags
argument_list|,
name|ExtraData
argument_list|,
name|Storage
argument_list|,
name|ShouldCreate
argument_list|)
return|;
block|}
specifier|static
name|DIDerivedType
operator|*
name|getImpl
argument_list|(
argument|LLVMContext&Context
argument_list|,
argument|unsigned Tag
argument_list|,
argument|MDString *Name
argument_list|,
argument|Metadata *File
argument_list|,
argument|unsigned Line
argument_list|,
argument|Metadata *Scope
argument_list|,
argument|Metadata *BaseType
argument_list|,
argument|uint64_t SizeInBits
argument_list|,
argument|uint32_t AlignInBits
argument_list|,
argument|uint64_t OffsetInBits
argument_list|,
argument|Optional<unsigned> DWARFAddressSpace
argument_list|,
argument|DIFlags Flags
argument_list|,
argument|Metadata *ExtraData
argument_list|,
argument|StorageType Storage
argument_list|,
argument|bool ShouldCreate = true
argument_list|)
block|;
name|TempDIDerivedType
name|cloneImpl
argument_list|()
specifier|const
block|{
return|return
name|getTemporary
argument_list|(
name|getContext
argument_list|()
argument_list|,
name|getTag
argument_list|()
argument_list|,
name|getName
argument_list|()
argument_list|,
name|getFile
argument_list|()
argument_list|,
name|getLine
argument_list|()
argument_list|,
name|getScope
argument_list|()
argument_list|,
name|getBaseType
argument_list|()
argument_list|,
name|getSizeInBits
argument_list|()
argument_list|,
name|getAlignInBits
argument_list|()
argument_list|,
name|getOffsetInBits
argument_list|()
argument_list|,
name|getDWARFAddressSpace
argument_list|()
argument_list|,
name|getFlags
argument_list|()
argument_list|,
name|getExtraData
argument_list|()
argument_list|)
return|;
block|}
name|public
operator|:
name|DEFINE_MDNODE_GET
argument_list|(
argument|DIDerivedType
argument_list|,
argument|(unsigned Tag, MDString *Name, Metadata *File,                      unsigned Line, Metadata *Scope, Metadata *BaseType,                      uint64_t SizeInBits, uint32_t AlignInBits,                      uint64_t OffsetInBits,                      Optional<unsigned> DWARFAddressSpace, DIFlags Flags,                      Metadata *ExtraData = nullptr)
argument_list|,
argument|(Tag, Name, File, Line, Scope, BaseType, SizeInBits,                      AlignInBits, OffsetInBits, DWARFAddressSpace, Flags,                      ExtraData)
argument_list|)
name|DEFINE_MDNODE_GET
argument_list|(
argument|DIDerivedType
argument_list|,
argument|(unsigned Tag, StringRef Name, DIFile *File, unsigned Line,                      DIScopeRef Scope, DITypeRef BaseType, uint64_t SizeInBits,                      uint32_t AlignInBits, uint64_t OffsetInBits,                      Optional<unsigned> DWARFAddressSpace, DIFlags Flags,                      Metadata *ExtraData = nullptr)
argument_list|,
argument|(Tag, Name, File, Line, Scope, BaseType, SizeInBits,                      AlignInBits, OffsetInBits, DWARFAddressSpace, Flags,                      ExtraData)
argument_list|)
name|TempDIDerivedType
name|clone
argument_list|()
specifier|const
block|{
return|return
name|cloneImpl
argument_list|()
return|;
block|}
comment|/// Get the base type this is derived from.
name|DITypeRef
name|getBaseType
argument_list|()
specifier|const
block|{
return|return
name|DITypeRef
argument_list|(
name|getRawBaseType
argument_list|()
argument_list|)
return|;
block|}
name|Metadata
operator|*
name|getRawBaseType
argument_list|()
specifier|const
block|{
return|return
name|getOperand
argument_list|(
literal|3
argument_list|)
return|;
block|}
comment|/// \returns The DWARF address space of the memory pointed to or referenced by
comment|/// a pointer or reference type respectively.
name|Optional
operator|<
name|unsigned
operator|>
name|getDWARFAddressSpace
argument_list|()
specifier|const
block|{
return|return
name|DWARFAddressSpace
return|;
block|}
comment|/// Get extra data associated with this derived type.
comment|///
comment|/// Class type for pointer-to-members, objective-c property node for ivars,
comment|/// or global constant wrapper for static members.
comment|///
comment|/// TODO: Separate out types that need this extra operand: pointer-to-member
comment|/// types and member fields (static members and ivars).
name|Metadata
operator|*
name|getExtraData
argument_list|()
specifier|const
block|{
return|return
name|getRawExtraData
argument_list|()
return|;
block|}
name|Metadata
operator|*
name|getRawExtraData
argument_list|()
specifier|const
block|{
return|return
name|getOperand
argument_list|(
literal|4
argument_list|)
return|;
block|}
comment|/// Get casted version of extra data.
comment|/// @{
name|DITypeRef
name|getClassType
argument_list|()
specifier|const
block|{
name|assert
argument_list|(
name|getTag
argument_list|()
operator|==
name|dwarf
operator|::
name|DW_TAG_ptr_to_member_type
argument_list|)
block|;
return|return
name|DITypeRef
argument_list|(
name|getExtraData
argument_list|()
argument_list|)
return|;
block|}
name|DIObjCProperty
operator|*
name|getObjCProperty
argument_list|()
specifier|const
block|{
return|return
name|dyn_cast_or_null
operator|<
name|DIObjCProperty
operator|>
operator|(
name|getExtraData
argument_list|()
operator|)
return|;
block|}
name|Constant
operator|*
name|getStorageOffsetInBits
argument_list|()
specifier|const
block|{
name|assert
argument_list|(
name|getTag
argument_list|()
operator|==
name|dwarf
operator|::
name|DW_TAG_member
operator|&&
name|isBitField
argument_list|()
argument_list|)
block|;
if|if
condition|(
name|auto
operator|*
name|C
operator|=
name|cast_or_null
operator|<
name|ConstantAsMetadata
operator|>
operator|(
name|getExtraData
argument_list|()
operator|)
condition|)
return|return
name|C
operator|->
name|getValue
argument_list|()
return|;
return|return
name|nullptr
return|;
block|}
name|Constant
operator|*
name|getConstant
argument_list|()
specifier|const
block|{
name|assert
argument_list|(
name|getTag
argument_list|()
operator|==
name|dwarf
operator|::
name|DW_TAG_member
operator|&&
name|isStaticMember
argument_list|()
argument_list|)
block|;
if|if
condition|(
name|auto
operator|*
name|C
operator|=
name|cast_or_null
operator|<
name|ConstantAsMetadata
operator|>
operator|(
name|getExtraData
argument_list|()
operator|)
condition|)
return|return
name|C
operator|->
name|getValue
argument_list|()
return|;
return|return
name|nullptr
return|;
block|}
comment|/// @}
specifier|static
name|bool
name|classof
argument_list|(
argument|const Metadata *MD
argument_list|)
block|{
return|return
name|MD
operator|->
name|getMetadataID
argument_list|()
operator|==
name|DIDerivedTypeKind
return|;
block|}
expr|}
block|;
comment|/// Composite types.
comment|///
comment|/// TODO: Detach from DerivedTypeBase (split out MDEnumType?).
comment|/// TODO: Create a custom, unrelated node for DW_TAG_array_type.
name|class
name|DICompositeType
operator|:
name|public
name|DIType
block|{
name|friend
name|class
name|LLVMContextImpl
block|;
name|friend
name|class
name|MDNode
block|;
name|unsigned
name|RuntimeLang
block|;
name|DICompositeType
argument_list|(
argument|LLVMContext&C
argument_list|,
argument|StorageType Storage
argument_list|,
argument|unsigned Tag
argument_list|,
argument|unsigned Line
argument_list|,
argument|unsigned RuntimeLang
argument_list|,
argument|uint64_t SizeInBits
argument_list|,
argument|uint32_t AlignInBits
argument_list|,
argument|uint64_t OffsetInBits
argument_list|,
argument|DIFlags Flags
argument_list|,
argument|ArrayRef<Metadata *> Ops
argument_list|)
operator|:
name|DIType
argument_list|(
name|C
argument_list|,
name|DICompositeTypeKind
argument_list|,
name|Storage
argument_list|,
name|Tag
argument_list|,
name|Line
argument_list|,
name|SizeInBits
argument_list|,
name|AlignInBits
argument_list|,
name|OffsetInBits
argument_list|,
name|Flags
argument_list|,
name|Ops
argument_list|)
block|,
name|RuntimeLang
argument_list|(
argument|RuntimeLang
argument_list|)
block|{}
operator|~
name|DICompositeType
argument_list|()
operator|=
expr|default
block|;
comment|/// Change fields in place.
name|void
name|mutate
argument_list|(
argument|unsigned Tag
argument_list|,
argument|unsigned Line
argument_list|,
argument|unsigned RuntimeLang
argument_list|,
argument|uint64_t SizeInBits
argument_list|,
argument|uint32_t AlignInBits
argument_list|,
argument|uint64_t OffsetInBits
argument_list|,
argument|DIFlags Flags
argument_list|)
block|{
name|assert
argument_list|(
name|isDistinct
argument_list|()
operator|&&
literal|"Only distinct nodes can mutate"
argument_list|)
block|;
name|assert
argument_list|(
name|getRawIdentifier
argument_list|()
operator|&&
literal|"Only ODR-uniqued nodes should mutate"
argument_list|)
block|;
name|this
operator|->
name|RuntimeLang
operator|=
name|RuntimeLang
block|;
name|DIType
operator|::
name|mutate
argument_list|(
name|Tag
argument_list|,
name|Line
argument_list|,
name|SizeInBits
argument_list|,
name|AlignInBits
argument_list|,
name|OffsetInBits
argument_list|,
name|Flags
argument_list|)
block|;   }
specifier|static
name|DICompositeType
operator|*
name|getImpl
argument_list|(
argument|LLVMContext&Context
argument_list|,
argument|unsigned Tag
argument_list|,
argument|StringRef Name
argument_list|,
argument|Metadata *File
argument_list|,
argument|unsigned Line
argument_list|,
argument|DIScopeRef Scope
argument_list|,
argument|DITypeRef BaseType
argument_list|,
argument|uint64_t SizeInBits
argument_list|,
argument|uint32_t AlignInBits
argument_list|,
argument|uint64_t OffsetInBits
argument_list|,
argument|DIFlags Flags
argument_list|,
argument|DINodeArray Elements
argument_list|,
argument|unsigned RuntimeLang
argument_list|,
argument|DITypeRef VTableHolder
argument_list|,
argument|DITemplateParameterArray TemplateParams
argument_list|,
argument|StringRef Identifier
argument_list|,
argument|StorageType Storage
argument_list|,
argument|bool ShouldCreate = true
argument_list|)
block|{
return|return
name|getImpl
argument_list|(
name|Context
argument_list|,
name|Tag
argument_list|,
name|getCanonicalMDString
argument_list|(
name|Context
argument_list|,
name|Name
argument_list|)
argument_list|,
name|File
argument_list|,
name|Line
argument_list|,
name|Scope
argument_list|,
name|BaseType
argument_list|,
name|SizeInBits
argument_list|,
name|AlignInBits
argument_list|,
name|OffsetInBits
argument_list|,
name|Flags
argument_list|,
name|Elements
operator|.
name|get
argument_list|()
argument_list|,
name|RuntimeLang
argument_list|,
name|VTableHolder
argument_list|,
name|TemplateParams
operator|.
name|get
argument_list|()
argument_list|,
name|getCanonicalMDString
argument_list|(
name|Context
argument_list|,
name|Identifier
argument_list|)
argument_list|,
name|Storage
argument_list|,
name|ShouldCreate
argument_list|)
return|;
block|}
specifier|static
name|DICompositeType
operator|*
name|getImpl
argument_list|(
argument|LLVMContext&Context
argument_list|,
argument|unsigned Tag
argument_list|,
argument|MDString *Name
argument_list|,
argument|Metadata *File
argument_list|,
argument|unsigned Line
argument_list|,
argument|Metadata *Scope
argument_list|,
argument|Metadata *BaseType
argument_list|,
argument|uint64_t SizeInBits
argument_list|,
argument|uint32_t AlignInBits
argument_list|,
argument|uint64_t OffsetInBits
argument_list|,
argument|DIFlags Flags
argument_list|,
argument|Metadata *Elements
argument_list|,
argument|unsigned RuntimeLang
argument_list|,
argument|Metadata *VTableHolder
argument_list|,
argument|Metadata *TemplateParams
argument_list|,
argument|MDString *Identifier
argument_list|,
argument|StorageType Storage
argument_list|,
argument|bool ShouldCreate = true
argument_list|)
block|;
name|TempDICompositeType
name|cloneImpl
argument_list|()
specifier|const
block|{
return|return
name|getTemporary
argument_list|(
name|getContext
argument_list|()
argument_list|,
name|getTag
argument_list|()
argument_list|,
name|getName
argument_list|()
argument_list|,
name|getFile
argument_list|()
argument_list|,
name|getLine
argument_list|()
argument_list|,
name|getScope
argument_list|()
argument_list|,
name|getBaseType
argument_list|()
argument_list|,
name|getSizeInBits
argument_list|()
argument_list|,
name|getAlignInBits
argument_list|()
argument_list|,
name|getOffsetInBits
argument_list|()
argument_list|,
name|getFlags
argument_list|()
argument_list|,
name|getElements
argument_list|()
argument_list|,
name|getRuntimeLang
argument_list|()
argument_list|,
name|getVTableHolder
argument_list|()
argument_list|,
name|getTemplateParams
argument_list|()
argument_list|,
name|getIdentifier
argument_list|()
argument_list|)
return|;
block|}
name|public
operator|:
name|DEFINE_MDNODE_GET
argument_list|(
argument|DICompositeType
argument_list|,
argument|(unsigned Tag, StringRef Name, DIFile *File, unsigned Line,                      DIScopeRef Scope, DITypeRef BaseType, uint64_t SizeInBits,                      uint32_t AlignInBits, uint64_t OffsetInBits,                      DIFlags Flags, DINodeArray Elements, unsigned RuntimeLang,                      DITypeRef VTableHolder,                      DITemplateParameterArray TemplateParams = nullptr,                      StringRef Identifier =
literal|""
argument|)
argument_list|,
argument|(Tag, Name, File, Line, Scope, BaseType, SizeInBits,                      AlignInBits, OffsetInBits, Flags, Elements, RuntimeLang,                      VTableHolder, TemplateParams, Identifier)
argument_list|)
name|DEFINE_MDNODE_GET
argument_list|(
argument|DICompositeType
argument_list|,
argument|(unsigned Tag, MDString *Name, Metadata *File,                      unsigned Line, Metadata *Scope, Metadata *BaseType,                      uint64_t SizeInBits, uint32_t AlignInBits,                      uint64_t OffsetInBits, DIFlags Flags, Metadata *Elements,                      unsigned RuntimeLang, Metadata *VTableHolder,                      Metadata *TemplateParams = nullptr,                      MDString *Identifier = nullptr)
argument_list|,
argument|(Tag, Name, File, Line, Scope, BaseType, SizeInBits,                      AlignInBits, OffsetInBits, Flags, Elements, RuntimeLang,                      VTableHolder, TemplateParams, Identifier)
argument_list|)
name|TempDICompositeType
name|clone
argument_list|()
specifier|const
block|{
return|return
name|cloneImpl
argument_list|()
return|;
block|}
comment|/// Get a DICompositeType with the given ODR identifier.
comment|///
comment|/// If \a LLVMContext::isODRUniquingDebugTypes(), gets the mapped
comment|/// DICompositeType for the given ODR \c Identifier.  If none exists, creates
comment|/// a new node.
comment|///
comment|/// Else, returns \c nullptr.
specifier|static
name|DICompositeType
operator|*
name|getODRType
argument_list|(
argument|LLVMContext&Context
argument_list|,
argument|MDString&Identifier
argument_list|,
argument|unsigned Tag
argument_list|,
argument|MDString *Name
argument_list|,
argument|Metadata *File
argument_list|,
argument|unsigned Line
argument_list|,
argument|Metadata *Scope
argument_list|,
argument|Metadata *BaseType
argument_list|,
argument|uint64_t SizeInBits
argument_list|,
argument|uint32_t AlignInBits
argument_list|,
argument|uint64_t OffsetInBits
argument_list|,
argument|DIFlags Flags
argument_list|,
argument|Metadata *Elements
argument_list|,
argument|unsigned RuntimeLang
argument_list|,
argument|Metadata *VTableHolder
argument_list|,
argument|Metadata *TemplateParams
argument_list|)
block|;
specifier|static
name|DICompositeType
operator|*
name|getODRTypeIfExists
argument_list|(
name|LLVMContext
operator|&
name|Context
argument_list|,
name|MDString
operator|&
name|Identifier
argument_list|)
block|;
comment|/// Build a DICompositeType with the given ODR identifier.
comment|///
comment|/// Looks up the mapped DICompositeType for the given ODR \c Identifier.  If
comment|/// it doesn't exist, creates a new one.  If it does exist and \a
comment|/// isForwardDecl(), and the new arguments would be a definition, mutates the
comment|/// the type in place.  In either case, returns the type.
comment|///
comment|/// If not \a LLVMContext::isODRUniquingDebugTypes(), this function returns
comment|/// nullptr.
specifier|static
name|DICompositeType
operator|*
name|buildODRType
argument_list|(
argument|LLVMContext&Context
argument_list|,
argument|MDString&Identifier
argument_list|,
argument|unsigned Tag
argument_list|,
argument|MDString *Name
argument_list|,
argument|Metadata *File
argument_list|,
argument|unsigned Line
argument_list|,
argument|Metadata *Scope
argument_list|,
argument|Metadata *BaseType
argument_list|,
argument|uint64_t SizeInBits
argument_list|,
argument|uint32_t AlignInBits
argument_list|,
argument|uint64_t OffsetInBits
argument_list|,
argument|DIFlags Flags
argument_list|,
argument|Metadata *Elements
argument_list|,
argument|unsigned RuntimeLang
argument_list|,
argument|Metadata *VTableHolder
argument_list|,
argument|Metadata *TemplateParams
argument_list|)
block|;
name|DITypeRef
name|getBaseType
argument_list|()
specifier|const
block|{
return|return
name|DITypeRef
argument_list|(
name|getRawBaseType
argument_list|()
argument_list|)
return|;
block|}
name|DINodeArray
name|getElements
argument_list|()
specifier|const
block|{
return|return
name|cast_or_null
operator|<
name|MDTuple
operator|>
operator|(
name|getRawElements
argument_list|()
operator|)
return|;
block|}
name|DITypeRef
name|getVTableHolder
argument_list|()
specifier|const
block|{
return|return
name|DITypeRef
argument_list|(
name|getRawVTableHolder
argument_list|()
argument_list|)
return|;
block|}
name|DITemplateParameterArray
name|getTemplateParams
argument_list|()
specifier|const
block|{
return|return
name|cast_or_null
operator|<
name|MDTuple
operator|>
operator|(
name|getRawTemplateParams
argument_list|()
operator|)
return|;
block|}
name|StringRef
name|getIdentifier
argument_list|()
specifier|const
block|{
return|return
name|getStringOperand
argument_list|(
literal|7
argument_list|)
return|;
block|}
name|unsigned
name|getRuntimeLang
argument_list|()
specifier|const
block|{
return|return
name|RuntimeLang
return|;
block|}
name|Metadata
operator|*
name|getRawBaseType
argument_list|()
specifier|const
block|{
return|return
name|getOperand
argument_list|(
literal|3
argument_list|)
return|;
block|}
name|Metadata
operator|*
name|getRawElements
argument_list|()
specifier|const
block|{
return|return
name|getOperand
argument_list|(
literal|4
argument_list|)
return|;
block|}
name|Metadata
operator|*
name|getRawVTableHolder
argument_list|()
specifier|const
block|{
return|return
name|getOperand
argument_list|(
literal|5
argument_list|)
return|;
block|}
name|Metadata
operator|*
name|getRawTemplateParams
argument_list|()
specifier|const
block|{
return|return
name|getOperand
argument_list|(
literal|6
argument_list|)
return|;
block|}
name|MDString
operator|*
name|getRawIdentifier
argument_list|()
specifier|const
block|{
return|return
name|getOperandAs
operator|<
name|MDString
operator|>
operator|(
literal|7
operator|)
return|;
block|}
comment|/// Replace operands.
comment|///
comment|/// If this \a isUniqued() and not \a isResolved(), on a uniquing collision
comment|/// this will be RAUW'ed and deleted.  Use a \a TrackingMDRef to keep track
comment|/// of its movement if necessary.
comment|/// @{
name|void
name|replaceElements
argument_list|(
argument|DINodeArray Elements
argument_list|)
block|{
ifndef|#
directive|ifndef
name|NDEBUG
for|for
control|(
name|DINode
modifier|*
name|Op
range|:
name|getElements
argument_list|()
control|)
name|assert
argument_list|(
name|is_contained
argument_list|(
name|Elements
operator|->
name|operands
argument_list|()
argument_list|,
name|Op
argument_list|)
operator|&&
literal|"Lost a member during member list replacement"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|replaceOperandWith
argument_list|(
literal|4
argument_list|,
name|Elements
operator|.
name|get
argument_list|()
argument_list|)
block|;   }
name|void
name|replaceVTableHolder
argument_list|(
argument|DITypeRef VTableHolder
argument_list|)
block|{
name|replaceOperandWith
argument_list|(
literal|5
argument_list|,
name|VTableHolder
argument_list|)
block|;   }
name|void
name|replaceTemplateParams
argument_list|(
argument|DITemplateParameterArray TemplateParams
argument_list|)
block|{
name|replaceOperandWith
argument_list|(
literal|6
argument_list|,
name|TemplateParams
operator|.
name|get
argument_list|()
argument_list|)
block|;   }
comment|/// @}
specifier|static
name|bool
name|classof
argument_list|(
argument|const Metadata *MD
argument_list|)
block|{
return|return
name|MD
operator|->
name|getMetadataID
argument_list|()
operator|==
name|DICompositeTypeKind
return|;
block|}
expr|}
block|;
comment|/// Type array for a subprogram.
comment|///
comment|/// TODO: Fold the array of types in directly as operands.
name|class
name|DISubroutineType
operator|:
name|public
name|DIType
block|{
name|friend
name|class
name|LLVMContextImpl
block|;
name|friend
name|class
name|MDNode
block|;
comment|/// The calling convention used with DW_AT_calling_convention. Actually of
comment|/// type dwarf::CallingConvention.
name|uint8_t
name|CC
block|;
name|DISubroutineType
argument_list|(
argument|LLVMContext&C
argument_list|,
argument|StorageType Storage
argument_list|,
argument|DIFlags Flags
argument_list|,
argument|uint8_t CC
argument_list|,
argument|ArrayRef<Metadata *> Ops
argument_list|)
operator|:
name|DIType
argument_list|(
name|C
argument_list|,
name|DISubroutineTypeKind
argument_list|,
name|Storage
argument_list|,
name|dwarf
operator|::
name|DW_TAG_subroutine_type
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|Flags
argument_list|,
name|Ops
argument_list|)
block|,
name|CC
argument_list|(
argument|CC
argument_list|)
block|{}
operator|~
name|DISubroutineType
argument_list|()
operator|=
expr|default
block|;
specifier|static
name|DISubroutineType
operator|*
name|getImpl
argument_list|(
argument|LLVMContext&Context
argument_list|,
argument|DIFlags Flags
argument_list|,
argument|uint8_t CC
argument_list|,
argument|DITypeRefArray TypeArray
argument_list|,
argument|StorageType Storage
argument_list|,
argument|bool ShouldCreate = true
argument_list|)
block|{
return|return
name|getImpl
argument_list|(
name|Context
argument_list|,
name|Flags
argument_list|,
name|CC
argument_list|,
name|TypeArray
operator|.
name|get
argument_list|()
argument_list|,
name|Storage
argument_list|,
name|ShouldCreate
argument_list|)
return|;
block|}
specifier|static
name|DISubroutineType
operator|*
name|getImpl
argument_list|(
argument|LLVMContext&Context
argument_list|,
argument|DIFlags Flags
argument_list|,
argument|uint8_t CC
argument_list|,
argument|Metadata *TypeArray
argument_list|,
argument|StorageType Storage
argument_list|,
argument|bool ShouldCreate = true
argument_list|)
block|;
name|TempDISubroutineType
name|cloneImpl
argument_list|()
specifier|const
block|{
return|return
name|getTemporary
argument_list|(
name|getContext
argument_list|()
argument_list|,
name|getFlags
argument_list|()
argument_list|,
name|getCC
argument_list|()
argument_list|,
name|getTypeArray
argument_list|()
argument_list|)
return|;
block|}
name|public
operator|:
name|DEFINE_MDNODE_GET
argument_list|(
argument|DISubroutineType
argument_list|,
argument|(DIFlags Flags, uint8_t CC, DITypeRefArray TypeArray)
argument_list|,
argument|(Flags, CC, TypeArray)
argument_list|)
name|DEFINE_MDNODE_GET
argument_list|(
argument|DISubroutineType
argument_list|,
argument|(DIFlags Flags, uint8_t CC, Metadata *TypeArray)
argument_list|,
argument|(Flags, CC, TypeArray)
argument_list|)
name|TempDISubroutineType
name|clone
argument_list|()
specifier|const
block|{
return|return
name|cloneImpl
argument_list|()
return|;
block|}
name|uint8_t
name|getCC
argument_list|()
specifier|const
block|{
return|return
name|CC
return|;
block|}
name|DITypeRefArray
name|getTypeArray
argument_list|()
specifier|const
block|{
return|return
name|cast_or_null
operator|<
name|MDTuple
operator|>
operator|(
name|getRawTypeArray
argument_list|()
operator|)
return|;
block|}
name|Metadata
operator|*
name|getRawTypeArray
argument_list|()
specifier|const
block|{
return|return
name|getOperand
argument_list|(
literal|3
argument_list|)
return|;
block|}
specifier|static
name|bool
name|classof
argument_list|(
argument|const Metadata *MD
argument_list|)
block|{
return|return
name|MD
operator|->
name|getMetadataID
argument_list|()
operator|==
name|DISubroutineTypeKind
return|;
block|}
expr|}
block|;
comment|/// Compile unit.
name|class
name|DICompileUnit
operator|:
name|public
name|DIScope
block|{
name|friend
name|class
name|LLVMContextImpl
block|;
name|friend
name|class
name|MDNode
block|;
name|public
operator|:
expr|enum
name|DebugEmissionKind
operator|:
name|unsigned
block|{
name|NoDebug
operator|=
literal|0
block|,
name|FullDebug
block|,
name|LineTablesOnly
block|,
name|LastEmissionKind
operator|=
name|LineTablesOnly
block|}
block|;
specifier|static
name|Optional
operator|<
name|DebugEmissionKind
operator|>
name|getEmissionKind
argument_list|(
argument|StringRef Str
argument_list|)
block|;
specifier|static
specifier|const
name|char
operator|*
name|EmissionKindString
argument_list|(
argument|DebugEmissionKind EK
argument_list|)
block|;
name|private
operator|:
name|unsigned
name|SourceLanguage
block|;
name|bool
name|IsOptimized
block|;
name|unsigned
name|RuntimeVersion
block|;
name|unsigned
name|EmissionKind
block|;
name|uint64_t
name|DWOId
block|;
name|bool
name|SplitDebugInlining
block|;
name|bool
name|DebugInfoForProfiling
block|;
name|DICompileUnit
argument_list|(
argument|LLVMContext&C
argument_list|,
argument|StorageType Storage
argument_list|,
argument|unsigned SourceLanguage
argument_list|,
argument|bool IsOptimized
argument_list|,
argument|unsigned RuntimeVersion
argument_list|,
argument|unsigned EmissionKind
argument_list|,
argument|uint64_t DWOId
argument_list|,
argument|bool SplitDebugInlining
argument_list|,
argument|bool DebugInfoForProfiling
argument_list|,
argument|ArrayRef<Metadata *> Ops
argument_list|)
operator|:
name|DIScope
argument_list|(
name|C
argument_list|,
name|DICompileUnitKind
argument_list|,
name|Storage
argument_list|,
name|dwarf
operator|::
name|DW_TAG_compile_unit
argument_list|,
name|Ops
argument_list|)
block|,
name|SourceLanguage
argument_list|(
name|SourceLanguage
argument_list|)
block|,
name|IsOptimized
argument_list|(
name|IsOptimized
argument_list|)
block|,
name|RuntimeVersion
argument_list|(
name|RuntimeVersion
argument_list|)
block|,
name|EmissionKind
argument_list|(
name|EmissionKind
argument_list|)
block|,
name|DWOId
argument_list|(
name|DWOId
argument_list|)
block|,
name|SplitDebugInlining
argument_list|(
name|SplitDebugInlining
argument_list|)
block|,
name|DebugInfoForProfiling
argument_list|(
argument|DebugInfoForProfiling
argument_list|)
block|{
name|assert
argument_list|(
name|Storage
operator|!=
name|Uniqued
argument_list|)
block|;   }
operator|~
name|DICompileUnit
argument_list|()
operator|=
expr|default
block|;
specifier|static
name|DICompileUnit
operator|*
name|getImpl
argument_list|(
argument|LLVMContext&Context
argument_list|,
argument|unsigned SourceLanguage
argument_list|,
argument|DIFile *File
argument_list|,
argument|StringRef Producer
argument_list|,
argument|bool IsOptimized
argument_list|,
argument|StringRef Flags
argument_list|,
argument|unsigned RuntimeVersion
argument_list|,
argument|StringRef SplitDebugFilename
argument_list|,
argument|unsigned EmissionKind
argument_list|,
argument|DICompositeTypeArray EnumTypes
argument_list|,
argument|DIScopeArray RetainedTypes
argument_list|,
argument|DIGlobalVariableExpressionArray GlobalVariables
argument_list|,
argument|DIImportedEntityArray ImportedEntities
argument_list|,
argument|DIMacroNodeArray Macros
argument_list|,
argument|uint64_t DWOId
argument_list|,
argument|bool SplitDebugInlining
argument_list|,
argument|bool DebugInfoForProfiling
argument_list|,
argument|StorageType Storage
argument_list|,
argument|bool ShouldCreate = true
argument_list|)
block|{
return|return
name|getImpl
argument_list|(
name|Context
argument_list|,
name|SourceLanguage
argument_list|,
name|File
argument_list|,
name|getCanonicalMDString
argument_list|(
name|Context
argument_list|,
name|Producer
argument_list|)
argument_list|,
name|IsOptimized
argument_list|,
name|getCanonicalMDString
argument_list|(
name|Context
argument_list|,
name|Flags
argument_list|)
argument_list|,
name|RuntimeVersion
argument_list|,
name|getCanonicalMDString
argument_list|(
name|Context
argument_list|,
name|SplitDebugFilename
argument_list|)
argument_list|,
name|EmissionKind
argument_list|,
name|EnumTypes
operator|.
name|get
argument_list|()
argument_list|,
name|RetainedTypes
operator|.
name|get
argument_list|()
argument_list|,
name|GlobalVariables
operator|.
name|get
argument_list|()
argument_list|,
name|ImportedEntities
operator|.
name|get
argument_list|()
argument_list|,
name|Macros
operator|.
name|get
argument_list|()
argument_list|,
name|DWOId
argument_list|,
name|SplitDebugInlining
argument_list|,
name|DebugInfoForProfiling
argument_list|,
name|Storage
argument_list|,
name|ShouldCreate
argument_list|)
return|;
block|}
specifier|static
name|DICompileUnit
operator|*
name|getImpl
argument_list|(
argument|LLVMContext&Context
argument_list|,
argument|unsigned SourceLanguage
argument_list|,
argument|Metadata *File
argument_list|,
argument|MDString *Producer
argument_list|,
argument|bool IsOptimized
argument_list|,
argument|MDString *Flags
argument_list|,
argument|unsigned RuntimeVersion
argument_list|,
argument|MDString *SplitDebugFilename
argument_list|,
argument|unsigned EmissionKind
argument_list|,
argument|Metadata *EnumTypes
argument_list|,
argument|Metadata *RetainedTypes
argument_list|,
argument|Metadata *GlobalVariables
argument_list|,
argument|Metadata *ImportedEntities
argument_list|,
argument|Metadata *Macros
argument_list|,
argument|uint64_t DWOId
argument_list|,
argument|bool SplitDebugInlining
argument_list|,
argument|bool DebugInfoForProfiling
argument_list|,
argument|StorageType Storage
argument_list|,
argument|bool ShouldCreate = true
argument_list|)
block|;
name|TempDICompileUnit
name|cloneImpl
argument_list|()
specifier|const
block|{
return|return
name|getTemporary
argument_list|(
name|getContext
argument_list|()
argument_list|,
name|getSourceLanguage
argument_list|()
argument_list|,
name|getFile
argument_list|()
argument_list|,
name|getProducer
argument_list|()
argument_list|,
name|isOptimized
argument_list|()
argument_list|,
name|getFlags
argument_list|()
argument_list|,
name|getRuntimeVersion
argument_list|()
argument_list|,
name|getSplitDebugFilename
argument_list|()
argument_list|,
name|getEmissionKind
argument_list|()
argument_list|,
name|getEnumTypes
argument_list|()
argument_list|,
name|getRetainedTypes
argument_list|()
argument_list|,
name|getGlobalVariables
argument_list|()
argument_list|,
name|getImportedEntities
argument_list|()
argument_list|,
name|getMacros
argument_list|()
argument_list|,
name|DWOId
argument_list|,
name|getSplitDebugInlining
argument_list|()
argument_list|,
name|getDebugInfoForProfiling
argument_list|()
argument_list|)
return|;
block|}
name|public
operator|:
specifier|static
name|void
name|get
argument_list|()
operator|=
name|delete
block|;
specifier|static
name|void
name|getIfExists
argument_list|()
operator|=
name|delete
block|;
name|DEFINE_MDNODE_GET_DISTINCT_TEMPORARY
argument_list|(
argument|DICompileUnit
argument_list|,
argument|(unsigned SourceLanguage, DIFile *File, StringRef Producer,        bool IsOptimized, StringRef Flags, unsigned RuntimeVersion,        StringRef SplitDebugFilename, DebugEmissionKind EmissionKind,        DICompositeTypeArray EnumTypes, DIScopeArray RetainedTypes,        DIGlobalVariableExpressionArray GlobalVariables,        DIImportedEntityArray ImportedEntities, DIMacroNodeArray Macros,        uint64_t DWOId, bool SplitDebugInlining, bool DebugInfoForProfiling)
argument_list|,
argument|(SourceLanguage, File, Producer, IsOptimized, Flags, RuntimeVersion,        SplitDebugFilename, EmissionKind, EnumTypes, RetainedTypes,        GlobalVariables, ImportedEntities, Macros, DWOId, SplitDebugInlining,        DebugInfoForProfiling)
argument_list|)
name|DEFINE_MDNODE_GET_DISTINCT_TEMPORARY
argument_list|(
argument|DICompileUnit
argument_list|,
argument|(unsigned SourceLanguage, Metadata *File, MDString *Producer,        bool IsOptimized, MDString *Flags, unsigned RuntimeVersion,        MDString *SplitDebugFilename, unsigned EmissionKind, Metadata *EnumTypes,        Metadata *RetainedTypes, Metadata *GlobalVariables,        Metadata *ImportedEntities, Metadata *Macros, uint64_t DWOId,        bool SplitDebugInlining, bool DebugInfoForProfiling)
argument_list|,
argument|(SourceLanguage, File, Producer, IsOptimized, Flags, RuntimeVersion,        SplitDebugFilename, EmissionKind, EnumTypes, RetainedTypes,        GlobalVariables, ImportedEntities, Macros, DWOId, SplitDebugInlining,        DebugInfoForProfiling)
argument_list|)
name|TempDICompileUnit
name|clone
argument_list|()
specifier|const
block|{
return|return
name|cloneImpl
argument_list|()
return|;
block|}
name|unsigned
name|getSourceLanguage
argument_list|()
specifier|const
block|{
return|return
name|SourceLanguage
return|;
block|}
name|bool
name|isOptimized
argument_list|()
specifier|const
block|{
return|return
name|IsOptimized
return|;
block|}
name|unsigned
name|getRuntimeVersion
argument_list|()
specifier|const
block|{
return|return
name|RuntimeVersion
return|;
block|}
name|DebugEmissionKind
name|getEmissionKind
argument_list|()
specifier|const
block|{
return|return
operator|(
name|DebugEmissionKind
operator|)
name|EmissionKind
return|;
block|}
name|bool
name|getDebugInfoForProfiling
argument_list|()
specifier|const
block|{
return|return
name|DebugInfoForProfiling
return|;
block|}
name|StringRef
name|getProducer
argument_list|()
specifier|const
block|{
return|return
name|getStringOperand
argument_list|(
literal|1
argument_list|)
return|;
block|}
name|StringRef
name|getFlags
argument_list|()
specifier|const
block|{
return|return
name|getStringOperand
argument_list|(
literal|2
argument_list|)
return|;
block|}
name|StringRef
name|getSplitDebugFilename
argument_list|()
specifier|const
block|{
return|return
name|getStringOperand
argument_list|(
literal|3
argument_list|)
return|;
block|}
name|DICompositeTypeArray
name|getEnumTypes
argument_list|()
specifier|const
block|{
return|return
name|cast_or_null
operator|<
name|MDTuple
operator|>
operator|(
name|getRawEnumTypes
argument_list|()
operator|)
return|;
block|}
name|DIScopeArray
name|getRetainedTypes
argument_list|()
specifier|const
block|{
return|return
name|cast_or_null
operator|<
name|MDTuple
operator|>
operator|(
name|getRawRetainedTypes
argument_list|()
operator|)
return|;
block|}
name|DIGlobalVariableExpressionArray
name|getGlobalVariables
argument_list|()
specifier|const
block|{
return|return
name|cast_or_null
operator|<
name|MDTuple
operator|>
operator|(
name|getRawGlobalVariables
argument_list|()
operator|)
return|;
block|}
name|DIImportedEntityArray
name|getImportedEntities
argument_list|()
specifier|const
block|{
return|return
name|cast_or_null
operator|<
name|MDTuple
operator|>
operator|(
name|getRawImportedEntities
argument_list|()
operator|)
return|;
block|}
name|DIMacroNodeArray
name|getMacros
argument_list|()
specifier|const
block|{
return|return
name|cast_or_null
operator|<
name|MDTuple
operator|>
operator|(
name|getRawMacros
argument_list|()
operator|)
return|;
block|}
name|uint64_t
name|getDWOId
argument_list|()
specifier|const
block|{
return|return
name|DWOId
return|;
block|}
name|void
name|setDWOId
argument_list|(
argument|uint64_t DwoId
argument_list|)
block|{
name|DWOId
operator|=
name|DwoId
block|; }
name|bool
name|getSplitDebugInlining
argument_list|()
specifier|const
block|{
return|return
name|SplitDebugInlining
return|;
block|}
name|void
name|setSplitDebugInlining
argument_list|(
argument|bool SplitDebugInlining
argument_list|)
block|{
name|this
operator|->
name|SplitDebugInlining
operator|=
name|SplitDebugInlining
block|;   }
name|MDString
operator|*
name|getRawProducer
argument_list|()
specifier|const
block|{
return|return
name|getOperandAs
operator|<
name|MDString
operator|>
operator|(
literal|1
operator|)
return|;
block|}
name|MDString
operator|*
name|getRawFlags
argument_list|()
specifier|const
block|{
return|return
name|getOperandAs
operator|<
name|MDString
operator|>
operator|(
literal|2
operator|)
return|;
block|}
name|MDString
operator|*
name|getRawSplitDebugFilename
argument_list|()
specifier|const
block|{
return|return
name|getOperandAs
operator|<
name|MDString
operator|>
operator|(
literal|3
operator|)
return|;
block|}
name|Metadata
operator|*
name|getRawEnumTypes
argument_list|()
specifier|const
block|{
return|return
name|getOperand
argument_list|(
literal|4
argument_list|)
return|;
block|}
name|Metadata
operator|*
name|getRawRetainedTypes
argument_list|()
specifier|const
block|{
return|return
name|getOperand
argument_list|(
literal|5
argument_list|)
return|;
block|}
name|Metadata
operator|*
name|getRawGlobalVariables
argument_list|()
specifier|const
block|{
return|return
name|getOperand
argument_list|(
literal|6
argument_list|)
return|;
block|}
name|Metadata
operator|*
name|getRawImportedEntities
argument_list|()
specifier|const
block|{
return|return
name|getOperand
argument_list|(
literal|7
argument_list|)
return|;
block|}
name|Metadata
operator|*
name|getRawMacros
argument_list|()
specifier|const
block|{
return|return
name|getOperand
argument_list|(
literal|8
argument_list|)
return|;
block|}
comment|/// Replace arrays.
comment|///
comment|/// If this \a isUniqued() and not \a isResolved(), it will be RAUW'ed and
comment|/// deleted on a uniquing collision.  In practice, uniquing collisions on \a
comment|/// DICompileUnit should be fairly rare.
comment|/// @{
name|void
name|replaceEnumTypes
argument_list|(
argument|DICompositeTypeArray N
argument_list|)
block|{
name|replaceOperandWith
argument_list|(
literal|4
argument_list|,
name|N
operator|.
name|get
argument_list|()
argument_list|)
block|;   }
name|void
name|replaceRetainedTypes
argument_list|(
argument|DITypeArray N
argument_list|)
block|{
name|replaceOperandWith
argument_list|(
literal|5
argument_list|,
name|N
operator|.
name|get
argument_list|()
argument_list|)
block|;   }
name|void
name|replaceGlobalVariables
argument_list|(
argument|DIGlobalVariableExpressionArray N
argument_list|)
block|{
name|replaceOperandWith
argument_list|(
literal|6
argument_list|,
name|N
operator|.
name|get
argument_list|()
argument_list|)
block|;   }
name|void
name|replaceImportedEntities
argument_list|(
argument|DIImportedEntityArray N
argument_list|)
block|{
name|replaceOperandWith
argument_list|(
literal|7
argument_list|,
name|N
operator|.
name|get
argument_list|()
argument_list|)
block|;   }
name|void
name|replaceMacros
argument_list|(
argument|DIMacroNodeArray N
argument_list|)
block|{
name|replaceOperandWith
argument_list|(
literal|8
argument_list|,
name|N
operator|.
name|get
argument_list|()
argument_list|)
block|; }
comment|/// @}
specifier|static
name|bool
name|classof
argument_list|(
argument|const Metadata *MD
argument_list|)
block|{
return|return
name|MD
operator|->
name|getMetadataID
argument_list|()
operator|==
name|DICompileUnitKind
return|;
block|}
expr|}
block|;
comment|/// A scope for locals.
comment|///
comment|/// A legal scope for lexical blocks, local variables, and debug info
comment|/// locations.  Subclasses are \a DISubprogram, \a DILexicalBlock, and \a
comment|/// DILexicalBlockFile.
name|class
name|DILocalScope
operator|:
name|public
name|DIScope
block|{
name|protected
operator|:
name|DILocalScope
argument_list|(
argument|LLVMContext&C
argument_list|,
argument|unsigned ID
argument_list|,
argument|StorageType Storage
argument_list|,
argument|unsigned Tag
argument_list|,
argument|ArrayRef<Metadata *> Ops
argument_list|)
operator|:
name|DIScope
argument_list|(
argument|C
argument_list|,
argument|ID
argument_list|,
argument|Storage
argument_list|,
argument|Tag
argument_list|,
argument|Ops
argument_list|)
block|{}
operator|~
name|DILocalScope
argument_list|()
operator|=
expr|default
block|;
name|public
operator|:
comment|/// Get the subprogram for this scope.
comment|///
comment|/// Return this if it's an \a DISubprogram; otherwise, look up the scope
comment|/// chain.
name|DISubprogram
operator|*
name|getSubprogram
argument_list|()
specifier|const
block|;
comment|/// Get the first non DILexicalBlockFile scope of this scope.
comment|///
comment|/// Return this if it's not a \a DILexicalBlockFIle; otherwise, look up the
comment|/// scope chain.
name|DILocalScope
operator|*
name|getNonLexicalBlockFileScope
argument_list|()
specifier|const
block|;
specifier|static
name|bool
name|classof
argument_list|(
argument|const Metadata *MD
argument_list|)
block|{
return|return
name|MD
operator|->
name|getMetadataID
argument_list|()
operator|==
name|DISubprogramKind
operator|||
name|MD
operator|->
name|getMetadataID
argument_list|()
operator|==
name|DILexicalBlockKind
operator|||
name|MD
operator|->
name|getMetadataID
argument_list|()
operator|==
name|DILexicalBlockFileKind
return|;
block|}
expr|}
block|;
comment|/// Debug location.
comment|///
comment|/// A debug location in source code, used for debug info and otherwise.
name|class
name|DILocation
operator|:
name|public
name|MDNode
block|{
name|friend
name|class
name|LLVMContextImpl
block|;
name|friend
name|class
name|MDNode
block|;
name|DILocation
argument_list|(
argument|LLVMContext&C
argument_list|,
argument|StorageType Storage
argument_list|,
argument|unsigned Line
argument_list|,
argument|unsigned Column
argument_list|,
argument|ArrayRef<Metadata *> MDs
argument_list|)
block|;
operator|~
name|DILocation
argument_list|()
block|{
name|dropAllReferences
argument_list|()
block|; }
specifier|static
name|DILocation
operator|*
name|getImpl
argument_list|(
argument|LLVMContext&Context
argument_list|,
argument|unsigned Line
argument_list|,
argument|unsigned Column
argument_list|,
argument|Metadata *Scope
argument_list|,
argument|Metadata *InlinedAt
argument_list|,
argument|StorageType Storage
argument_list|,
argument|bool ShouldCreate = true
argument_list|)
block|;
specifier|static
name|DILocation
operator|*
name|getImpl
argument_list|(
argument|LLVMContext&Context
argument_list|,
argument|unsigned Line
argument_list|,
argument|unsigned Column
argument_list|,
argument|DILocalScope *Scope
argument_list|,
argument|DILocation *InlinedAt
argument_list|,
argument|StorageType Storage
argument_list|,
argument|bool ShouldCreate = true
argument_list|)
block|{
return|return
name|getImpl
argument_list|(
name|Context
argument_list|,
name|Line
argument_list|,
name|Column
argument_list|,
name|static_cast
operator|<
name|Metadata
operator|*
operator|>
operator|(
name|Scope
operator|)
argument_list|,
name|static_cast
operator|<
name|Metadata
operator|*
operator|>
operator|(
name|InlinedAt
operator|)
argument_list|,
name|Storage
argument_list|,
name|ShouldCreate
argument_list|)
return|;
block|}
comment|/// With a given unsigned int \p U, use up to 13 bits to represent it.
comment|/// old_bit 1~5  --> new_bit 1~5
comment|/// old_bit 6~12 --> new_bit 7~13
comment|/// new_bit_6 is 0 if higher bits (7~13) are all 0
specifier|static
name|unsigned
name|getPrefixEncodingFromUnsigned
argument_list|(
argument|unsigned U
argument_list|)
block|{
name|U
operator|&=
literal|0xfff
block|;
return|return
name|U
operator|>
literal|0x1f
condition|?
operator|(
operator|(
operator|(
name|U
operator|&
literal|0xfe0
operator|)
operator|<<
literal|1
operator|)
operator||
operator|(
name|U
operator|&
literal|0x1f
operator|)
operator||
literal|0x20
operator|)
else|:
name|U
return|;
block|}
comment|/// Reverse transformation as getPrefixEncodingFromUnsigned.
specifier|static
name|unsigned
name|getUnsignedFromPrefixEncoding
argument_list|(
argument|unsigned U
argument_list|)
block|{
return|return
operator|(
name|U
operator|&
literal|0x20
operator|)
condition|?
operator|(
operator|(
operator|(
name|U
operator|>>
literal|1
operator|)
operator|&
literal|0xfe0
operator|)
operator||
operator|(
name|U
operator|&
literal|0x1f
operator|)
operator|)
else|:
operator|(
name|U
operator|&
literal|0x1f
operator|)
return|;
block|}
comment|/// Returns the next component stored in discriminator.
specifier|static
name|unsigned
name|getNextComponentInDiscriminator
argument_list|(
argument|unsigned D
argument_list|)
block|{
if|if
condition|(
operator|(
name|D
operator|&
literal|1
operator|)
operator|==
literal|0
condition|)
return|return
name|D
operator|>>
operator|(
operator|(
name|D
operator|&
literal|0x40
operator|)
condition|?
literal|14
else|:
literal|7
operator|)
return|;
else|else
return|return
name|D
operator|>>
literal|1
return|;
block|}
name|TempDILocation
name|cloneImpl
argument_list|()
specifier|const
block|{
comment|// Get the raw scope/inlinedAt since it is possible to invoke this on
comment|// a DILocation containing temporary metadata.
return|return
name|getTemporary
argument_list|(
name|getContext
argument_list|()
argument_list|,
name|getLine
argument_list|()
argument_list|,
name|getColumn
argument_list|()
argument_list|,
name|getRawScope
argument_list|()
argument_list|,
name|getRawInlinedAt
argument_list|()
argument_list|)
return|;
block|}
name|public
operator|:
comment|// Disallow replacing operands.
name|void
name|replaceOperandWith
argument_list|(
argument|unsigned I
argument_list|,
argument|Metadata *New
argument_list|)
operator|=
name|delete
block|;
name|DEFINE_MDNODE_GET
argument_list|(
argument|DILocation
argument_list|,
argument|(unsigned Line, unsigned Column, Metadata *Scope,                      Metadata *InlinedAt = nullptr)
argument_list|,
argument|(Line, Column, Scope, InlinedAt)
argument_list|)
name|DEFINE_MDNODE_GET
argument_list|(
argument|DILocation
argument_list|,
argument|(unsigned Line, unsigned Column, DILocalScope *Scope,                      DILocation *InlinedAt = nullptr)
argument_list|,
argument|(Line, Column, Scope, InlinedAt)
argument_list|)
comment|/// Return a (temporary) clone of this.
name|TempDILocation
name|clone
argument_list|()
specifier|const
block|{
return|return
name|cloneImpl
argument_list|()
return|;
block|}
name|unsigned
name|getLine
argument_list|()
specifier|const
block|{
return|return
name|SubclassData32
return|;
block|}
name|unsigned
name|getColumn
argument_list|()
specifier|const
block|{
return|return
name|SubclassData16
return|;
block|}
name|DILocalScope
operator|*
name|getScope
argument_list|()
specifier|const
block|{
return|return
name|cast
operator|<
name|DILocalScope
operator|>
operator|(
name|getRawScope
argument_list|()
operator|)
return|;
block|}
name|DILocation
operator|*
name|getInlinedAt
argument_list|()
specifier|const
block|{
return|return
name|cast_or_null
operator|<
name|DILocation
operator|>
operator|(
name|getRawInlinedAt
argument_list|()
operator|)
return|;
block|}
name|DIFile
operator|*
name|getFile
argument_list|()
specifier|const
block|{
return|return
name|getScope
argument_list|()
operator|->
name|getFile
argument_list|()
return|;
block|}
name|StringRef
name|getFilename
argument_list|()
specifier|const
block|{
return|return
name|getScope
argument_list|()
operator|->
name|getFilename
argument_list|()
return|;
block|}
name|StringRef
name|getDirectory
argument_list|()
specifier|const
block|{
return|return
name|getScope
argument_list|()
operator|->
name|getDirectory
argument_list|()
return|;
block|}
comment|/// Get the scope where this is inlined.
comment|///
comment|/// Walk through \a getInlinedAt() and return \a getScope() from the deepest
comment|/// location.
name|DILocalScope
operator|*
name|getInlinedAtScope
argument_list|()
specifier|const
block|{
if|if
condition|(
name|auto
operator|*
name|IA
operator|=
name|getInlinedAt
argument_list|()
condition|)
return|return
name|IA
operator|->
name|getInlinedAtScope
argument_list|()
return|;
return|return
name|getScope
argument_list|()
return|;
block|}
comment|/// Check whether this can be discriminated from another location.
comment|///
comment|/// Check \c this can be discriminated from \c RHS in a linetable entry.
comment|/// Scope and inlined-at chains are not recorded in the linetable, so they
comment|/// cannot be used to distinguish basic blocks.
name|bool
name|canDiscriminate
argument_list|(
argument|const DILocation&RHS
argument_list|)
specifier|const
block|{
return|return
name|getLine
argument_list|()
operator|!=
name|RHS
operator|.
name|getLine
argument_list|()
operator|||
name|getColumn
argument_list|()
operator|!=
name|RHS
operator|.
name|getColumn
argument_list|()
operator|||
name|getDiscriminator
argument_list|()
operator|!=
name|RHS
operator|.
name|getDiscriminator
argument_list|()
operator|||
name|getFilename
argument_list|()
operator|!=
name|RHS
operator|.
name|getFilename
argument_list|()
operator|||
name|getDirectory
argument_list|()
operator|!=
name|RHS
operator|.
name|getDirectory
argument_list|()
return|;
block|}
comment|/// Get the DWARF discriminator.
comment|///
comment|/// DWARF discriminators distinguish identical file locations between
comment|/// instructions that are on different basic blocks.
comment|///
comment|/// There are 3 components stored in discriminator, from lower bits:
comment|///
comment|/// Base discriminator: assigned by AddDiscriminators pass to identify IRs
comment|///                     that are defined by the same source line, but
comment|///                     different basic blocks.
comment|/// Duplication factor: assigned by optimizations that will scale down
comment|///                     the execution frequency of the original IR.
comment|/// Copy Identifier: assigned by optimizations that clones the IR.
comment|///                  Each copy of the IR will be assigned an identifier.
comment|///
comment|/// Encoding:
comment|///
comment|/// The above 3 components are encoded into a 32bit unsigned integer in
comment|/// order. If the lowest bit is 1, the current component is empty, and the
comment|/// next component will start in the next bit. Otherwise, the the current
comment|/// component is non-empty, and its content starts in the next bit. The
comment|/// length of each components is either 5 bit or 12 bit: if the 7th bit
comment|/// is 0, the bit 2~6 (5 bits) are used to represent the component; if the
comment|/// 7th bit is 1, the bit 2~6 (5 bits) and 8~14 (7 bits) are combined to
comment|/// represent the component.
specifier|inline
name|unsigned
name|getDiscriminator
argument_list|()
specifier|const
block|;
comment|/// Returns a new DILocation with updated \p Discriminator.
specifier|inline
specifier|const
name|DILocation
operator|*
name|cloneWithDiscriminator
argument_list|(
argument|unsigned Discriminator
argument_list|)
specifier|const
block|;
comment|/// Returns a new DILocation with updated base discriminator \p BD.
specifier|inline
specifier|const
name|DILocation
operator|*
name|setBaseDiscriminator
argument_list|(
argument|unsigned BD
argument_list|)
specifier|const
block|;
comment|/// Returns the duplication factor stored in the discriminator.
specifier|inline
name|unsigned
name|getDuplicationFactor
argument_list|()
specifier|const
block|;
comment|/// Returns the copy identifier stored in the discriminator.
specifier|inline
name|unsigned
name|getCopyIdentifier
argument_list|()
specifier|const
block|;
comment|/// Returns the base discriminator stored in the discriminator.
specifier|inline
name|unsigned
name|getBaseDiscriminator
argument_list|()
specifier|const
block|;
comment|/// Returns a new DILocation with duplication factor \p DF encoded in the
comment|/// discriminator.
specifier|inline
specifier|const
name|DILocation
operator|*
name|cloneWithDuplicationFactor
argument_list|(
argument|unsigned DF
argument_list|)
specifier|const
block|;
comment|/// When two instructions are combined into a single instruction we also
comment|/// need to combine the original locations into a single location.
comment|///
comment|/// When the locations are the same we can use either location. When they
comment|/// differ, we need a third location which is distinct from either. If
comment|/// they have the same file/line but have a different discriminator we
comment|/// could create a location with a new discriminator. If they are from
comment|/// different files/lines the location is ambiguous and can't be
comment|/// represented in a single line entry.  In this case, no location
comment|/// should be set.
comment|///
comment|/// Currently the function does not create a new location. If the locations
comment|/// are the same, or cannot be discriminated, the first location is returned.
comment|/// Otherwise an empty location will be used.
specifier|static
specifier|const
name|DILocation
operator|*
name|getMergedLocation
argument_list|(
argument|const DILocation *LocA
argument_list|,
argument|const DILocation *LocB
argument_list|)
block|{
if|if
condition|(
name|LocA
operator|&&
name|LocB
operator|&&
operator|(
name|LocA
operator|==
name|LocB
operator|||
operator|!
name|LocA
operator|->
name|canDiscriminate
argument_list|(
operator|*
name|LocB
argument_list|)
operator|)
condition|)
return|return
name|LocA
return|;
return|return
name|nullptr
return|;
block|}
comment|/// Returns the base discriminator for a given encoded discriminator \p D.
specifier|static
name|unsigned
name|getBaseDiscriminatorFromDiscriminator
argument_list|(
argument|unsigned D
argument_list|)
block|{
if|if
condition|(
operator|(
name|D
operator|&
literal|1
operator|)
operator|==
literal|0
condition|)
return|return
name|getUnsignedFromPrefixEncoding
argument_list|(
name|D
operator|>>
literal|1
argument_list|)
return|;
else|else
return|return
literal|0
return|;
block|}
comment|/// Returns the duplication factor for a given encoded discriminator \p D.
specifier|static
name|unsigned
name|getDuplicationFactorFromDiscriminator
argument_list|(
argument|unsigned D
argument_list|)
block|{
name|D
operator|=
name|getNextComponentInDiscriminator
argument_list|(
name|D
argument_list|)
block|;
if|if
condition|(
name|D
operator|==
literal|0
operator|||
operator|(
name|D
operator|&
literal|1
operator|)
condition|)
return|return
literal|1
return|;
else|else
return|return
name|getUnsignedFromPrefixEncoding
argument_list|(
name|D
operator|>>
literal|1
argument_list|)
return|;
block|}
comment|/// Returns the copy identifier for a given encoded discriminator \p D.
specifier|static
name|unsigned
name|getCopyIdentifierFromDiscriminator
argument_list|(
argument|unsigned D
argument_list|)
block|{
return|return
name|getUnsignedFromPrefixEncoding
argument_list|(
name|getNextComponentInDiscriminator
argument_list|(
name|getNextComponentInDiscriminator
argument_list|(
name|D
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
name|Metadata
operator|*
name|getRawScope
argument_list|()
specifier|const
block|{
return|return
name|getOperand
argument_list|(
literal|0
argument_list|)
return|;
block|}
name|Metadata
operator|*
name|getRawInlinedAt
argument_list|()
specifier|const
block|{
if|if
condition|(
name|getNumOperands
argument_list|()
operator|==
literal|2
condition|)
return|return
name|getOperand
argument_list|(
literal|1
argument_list|)
return|;
return|return
name|nullptr
return|;
block|}
specifier|static
name|bool
name|classof
argument_list|(
argument|const Metadata *MD
argument_list|)
block|{
return|return
name|MD
operator|->
name|getMetadataID
argument_list|()
operator|==
name|DILocationKind
return|;
block|}
expr|}
block|;
comment|/// Subprogram description.
comment|///
comment|/// TODO: Remove DisplayName.  It's always equal to Name.
comment|/// TODO: Split up flags.
name|class
name|DISubprogram
operator|:
name|public
name|DILocalScope
block|{
name|friend
name|class
name|LLVMContextImpl
block|;
name|friend
name|class
name|MDNode
block|;
name|unsigned
name|Line
block|;
name|unsigned
name|ScopeLine
block|;
name|unsigned
name|VirtualIndex
block|;
comment|/// In the MS ABI, the implicit 'this' parameter is adjusted in the prologue
comment|/// of method overrides from secondary bases by this amount. It may be
comment|/// negative.
name|int
name|ThisAdjustment
block|;
comment|// Virtuality can only assume three values, so we can pack
comment|// in 2 bits (none/pure/pure_virtual).
name|unsigned
name|Virtuality
operator|:
literal|2
block|;
comment|// These are boolean flags so one bit is enough.
comment|// MSVC starts a new container field every time the base
comment|// type changes so we can't use 'bool' to ensure these bits
comment|// are packed.
name|unsigned
name|IsLocalToUnit
operator|:
literal|1
block|;
name|unsigned
name|IsDefinition
operator|:
literal|1
block|;
name|unsigned
name|IsOptimized
operator|:
literal|1
block|;
name|unsigned
name|Padding
operator|:
literal|3
block|;
name|DIFlags
name|Flags
block|;
name|DISubprogram
argument_list|(
argument|LLVMContext&C
argument_list|,
argument|StorageType Storage
argument_list|,
argument|unsigned Line
argument_list|,
argument|unsigned ScopeLine
argument_list|,
argument|unsigned Virtuality
argument_list|,
argument|unsigned VirtualIndex
argument_list|,
argument|int ThisAdjustment
argument_list|,
argument|DIFlags Flags
argument_list|,
argument|bool IsLocalToUnit
argument_list|,
argument|bool IsDefinition
argument_list|,
argument|bool IsOptimized
argument_list|,
argument|ArrayRef<Metadata *> Ops
argument_list|)
operator|:
name|DILocalScope
argument_list|(
name|C
argument_list|,
name|DISubprogramKind
argument_list|,
name|Storage
argument_list|,
name|dwarf
operator|::
name|DW_TAG_subprogram
argument_list|,
name|Ops
argument_list|)
block|,
name|Line
argument_list|(
name|Line
argument_list|)
block|,
name|ScopeLine
argument_list|(
name|ScopeLine
argument_list|)
block|,
name|VirtualIndex
argument_list|(
name|VirtualIndex
argument_list|)
block|,
name|ThisAdjustment
argument_list|(
name|ThisAdjustment
argument_list|)
block|,
name|Virtuality
argument_list|(
name|Virtuality
argument_list|)
block|,
name|IsLocalToUnit
argument_list|(
name|IsLocalToUnit
argument_list|)
block|,
name|IsDefinition
argument_list|(
name|IsDefinition
argument_list|)
block|,
name|IsOptimized
argument_list|(
name|IsOptimized
argument_list|)
block|,
name|Flags
argument_list|(
argument|Flags
argument_list|)
block|{
name|static_assert
argument_list|(
name|dwarf
operator|::
name|DW_VIRTUALITY_max
operator|<
literal|4
argument_list|,
literal|"Virtuality out of range"
argument_list|)
block|;
name|assert
argument_list|(
name|Virtuality
operator|<
literal|4
operator|&&
literal|"Virtuality out of range"
argument_list|)
block|;   }
operator|~
name|DISubprogram
argument_list|()
operator|=
expr|default
block|;
specifier|static
name|DISubprogram
operator|*
name|getImpl
argument_list|(
argument|LLVMContext&Context
argument_list|,
argument|DIScopeRef Scope
argument_list|,
argument|StringRef Name
argument_list|,
argument|StringRef LinkageName
argument_list|,
argument|DIFile *File
argument_list|,
argument|unsigned Line
argument_list|,
argument|DISubroutineType *Type
argument_list|,
argument|bool IsLocalToUnit
argument_list|,
argument|bool IsDefinition
argument_list|,
argument|unsigned ScopeLine
argument_list|,
argument|DITypeRef ContainingType
argument_list|,
argument|unsigned Virtuality
argument_list|,
argument|unsigned VirtualIndex
argument_list|,
argument|int ThisAdjustment
argument_list|,
argument|DIFlags Flags
argument_list|,
argument|bool IsOptimized
argument_list|,
argument|DICompileUnit *Unit
argument_list|,
argument|DITemplateParameterArray TemplateParams
argument_list|,
argument|DISubprogram *Declaration
argument_list|,
argument|DILocalVariableArray Variables
argument_list|,
argument|DITypeArray ThrownTypes
argument_list|,
argument|StorageType Storage
argument_list|,
argument|bool ShouldCreate = true
argument_list|)
block|{
return|return
name|getImpl
argument_list|(
name|Context
argument_list|,
name|Scope
argument_list|,
name|getCanonicalMDString
argument_list|(
name|Context
argument_list|,
name|Name
argument_list|)
argument_list|,
name|getCanonicalMDString
argument_list|(
name|Context
argument_list|,
name|LinkageName
argument_list|)
argument_list|,
name|File
argument_list|,
name|Line
argument_list|,
name|Type
argument_list|,
name|IsLocalToUnit
argument_list|,
name|IsDefinition
argument_list|,
name|ScopeLine
argument_list|,
name|ContainingType
argument_list|,
name|Virtuality
argument_list|,
name|VirtualIndex
argument_list|,
name|ThisAdjustment
argument_list|,
name|Flags
argument_list|,
name|IsOptimized
argument_list|,
name|Unit
argument_list|,
name|TemplateParams
operator|.
name|get
argument_list|()
argument_list|,
name|Declaration
argument_list|,
name|Variables
operator|.
name|get
argument_list|()
argument_list|,
name|ThrownTypes
operator|.
name|get
argument_list|()
argument_list|,
name|Storage
argument_list|,
name|ShouldCreate
argument_list|)
return|;
block|}
specifier|static
name|DISubprogram
operator|*
name|getImpl
argument_list|(
argument|LLVMContext&Context
argument_list|,
argument|Metadata *Scope
argument_list|,
argument|MDString *Name
argument_list|,
argument|MDString *LinkageName
argument_list|,
argument|Metadata *File
argument_list|,
argument|unsigned Line
argument_list|,
argument|Metadata *Type
argument_list|,
argument|bool IsLocalToUnit
argument_list|,
argument|bool IsDefinition
argument_list|,
argument|unsigned ScopeLine
argument_list|,
argument|Metadata *ContainingType
argument_list|,
argument|unsigned Virtuality
argument_list|,
argument|unsigned VirtualIndex
argument_list|,
argument|int ThisAdjustment
argument_list|,
argument|DIFlags Flags
argument_list|,
argument|bool IsOptimized
argument_list|,
argument|Metadata *Unit
argument_list|,
argument|Metadata *TemplateParams
argument_list|,
argument|Metadata *Declaration
argument_list|,
argument|Metadata *Variables
argument_list|,
argument|Metadata *ThrownTypes
argument_list|,
argument|StorageType Storage
argument_list|,
argument|bool ShouldCreate = true
argument_list|)
block|;
name|TempDISubprogram
name|cloneImpl
argument_list|()
specifier|const
block|{
return|return
name|getTemporary
argument_list|(
name|getContext
argument_list|()
argument_list|,
name|getScope
argument_list|()
argument_list|,
name|getName
argument_list|()
argument_list|,
name|getLinkageName
argument_list|()
argument_list|,
name|getFile
argument_list|()
argument_list|,
name|getLine
argument_list|()
argument_list|,
name|getType
argument_list|()
argument_list|,
name|isLocalToUnit
argument_list|()
argument_list|,
name|isDefinition
argument_list|()
argument_list|,
name|getScopeLine
argument_list|()
argument_list|,
name|getContainingType
argument_list|()
argument_list|,
name|getVirtuality
argument_list|()
argument_list|,
name|getVirtualIndex
argument_list|()
argument_list|,
name|getThisAdjustment
argument_list|()
argument_list|,
name|getFlags
argument_list|()
argument_list|,
name|isOptimized
argument_list|()
argument_list|,
name|getUnit
argument_list|()
argument_list|,
name|getTemplateParams
argument_list|()
argument_list|,
name|getDeclaration
argument_list|()
argument_list|,
name|getVariables
argument_list|()
argument_list|,
name|getThrownTypes
argument_list|()
argument_list|)
return|;
block|}
name|public
operator|:
name|DEFINE_MDNODE_GET
argument_list|(
argument|DISubprogram
argument_list|,
argument|(DIScopeRef Scope, StringRef Name, StringRef LinkageName,                      DIFile *File, unsigned Line, DISubroutineType *Type,                      bool IsLocalToUnit, bool IsDefinition, unsigned ScopeLine,                      DITypeRef ContainingType, unsigned Virtuality,                      unsigned VirtualIndex, int ThisAdjustment, DIFlags Flags,                      bool IsOptimized, DICompileUnit *Unit,                      DITemplateParameterArray TemplateParams = nullptr,                      DISubprogram *Declaration = nullptr,                      DILocalVariableArray Variables = nullptr,                      DITypeArray ThrownTypes = nullptr)
argument_list|,
argument|(Scope, Name, LinkageName, File, Line, Type, IsLocalToUnit,                      IsDefinition, ScopeLine, ContainingType, Virtuality,                      VirtualIndex, ThisAdjustment, Flags, IsOptimized, Unit,                      TemplateParams, Declaration, Variables, ThrownTypes)
argument_list|)
name|DEFINE_MDNODE_GET
argument_list|(
argument|DISubprogram
argument_list|,
argument|(Metadata * Scope, MDString *Name, MDString *LinkageName, Metadata *File,        unsigned Line, Metadata *Type, bool IsLocalToUnit, bool IsDefinition,        unsigned ScopeLine, Metadata *ContainingType, unsigned Virtuality,        unsigned VirtualIndex, int ThisAdjustment, DIFlags Flags,        bool IsOptimized, Metadata *Unit, Metadata *TemplateParams = nullptr,        Metadata *Declaration = nullptr, Metadata *Variables = nullptr,        Metadata *ThrownTypes = nullptr)
argument_list|,
argument|(Scope, Name, LinkageName, File, Line, Type, IsLocalToUnit, IsDefinition,        ScopeLine, ContainingType, Virtuality, VirtualIndex, ThisAdjustment,        Flags, IsOptimized, Unit, TemplateParams, Declaration, Variables,        ThrownTypes)
argument_list|)
name|TempDISubprogram
name|clone
argument_list|()
specifier|const
block|{
return|return
name|cloneImpl
argument_list|()
return|;
block|}
name|public
operator|:
name|unsigned
name|getLine
argument_list|()
specifier|const
block|{
return|return
name|Line
return|;
block|}
name|unsigned
name|getVirtuality
argument_list|()
specifier|const
block|{
return|return
name|Virtuality
return|;
block|}
name|unsigned
name|getVirtualIndex
argument_list|()
specifier|const
block|{
return|return
name|VirtualIndex
return|;
block|}
name|int
name|getThisAdjustment
argument_list|()
specifier|const
block|{
return|return
name|ThisAdjustment
return|;
block|}
name|unsigned
name|getScopeLine
argument_list|()
specifier|const
block|{
return|return
name|ScopeLine
return|;
block|}
name|DIFlags
name|getFlags
argument_list|()
specifier|const
block|{
return|return
name|Flags
return|;
block|}
name|bool
name|isLocalToUnit
argument_list|()
specifier|const
block|{
return|return
name|IsLocalToUnit
return|;
block|}
name|bool
name|isDefinition
argument_list|()
specifier|const
block|{
return|return
name|IsDefinition
return|;
block|}
name|bool
name|isOptimized
argument_list|()
specifier|const
block|{
return|return
name|IsOptimized
return|;
block|}
name|bool
name|isArtificial
argument_list|()
specifier|const
block|{
return|return
name|getFlags
argument_list|()
operator|&
name|FlagArtificial
return|;
block|}
name|bool
name|isPrivate
argument_list|()
specifier|const
block|{
return|return
operator|(
name|getFlags
argument_list|()
operator|&
name|FlagAccessibility
operator|)
operator|==
name|FlagPrivate
return|;
block|}
name|bool
name|isProtected
argument_list|()
specifier|const
block|{
return|return
operator|(
name|getFlags
argument_list|()
operator|&
name|FlagAccessibility
operator|)
operator|==
name|FlagProtected
return|;
block|}
name|bool
name|isPublic
argument_list|()
specifier|const
block|{
return|return
operator|(
name|getFlags
argument_list|()
operator|&
name|FlagAccessibility
operator|)
operator|==
name|FlagPublic
return|;
block|}
name|bool
name|isExplicit
argument_list|()
specifier|const
block|{
return|return
name|getFlags
argument_list|()
operator|&
name|FlagExplicit
return|;
block|}
name|bool
name|isPrototyped
argument_list|()
specifier|const
block|{
return|return
name|getFlags
argument_list|()
operator|&
name|FlagPrototyped
return|;
block|}
name|bool
name|isMainSubprogram
argument_list|()
specifier|const
block|{
return|return
name|getFlags
argument_list|()
operator|&
name|FlagMainSubprogram
return|;
block|}
comment|/// Check if this is reference-qualified.
comment|///
comment|/// Return true if this subprogram is a C++11 reference-qualified non-static
comment|/// member function (void foo()&).
name|bool
name|isLValueReference
argument_list|()
specifier|const
block|{
return|return
name|getFlags
argument_list|()
operator|&
name|FlagLValueReference
return|;
block|}
comment|/// Check if this is rvalue-reference-qualified.
comment|///
comment|/// Return true if this subprogram is a C++11 rvalue-reference-qualified
comment|/// non-static member function (void foo()&&).
name|bool
name|isRValueReference
argument_list|()
specifier|const
block|{
return|return
name|getFlags
argument_list|()
operator|&
name|FlagRValueReference
return|;
block|}
comment|/// Check if this is marked as noreturn.
comment|///
comment|/// Return true if this subprogram is C++11 noreturn or C11 _Noreturn
name|bool
name|isNoReturn
argument_list|()
specifier|const
block|{
return|return
name|getFlags
argument_list|()
operator|&
name|FlagNoReturn
return|;
block|}
name|DIScopeRef
name|getScope
argument_list|()
specifier|const
block|{
return|return
name|DIScopeRef
argument_list|(
name|getRawScope
argument_list|()
argument_list|)
return|;
block|}
name|StringRef
name|getName
argument_list|()
specifier|const
block|{
return|return
name|getStringOperand
argument_list|(
literal|2
argument_list|)
return|;
block|}
name|StringRef
name|getLinkageName
argument_list|()
specifier|const
block|{
return|return
name|getStringOperand
argument_list|(
literal|3
argument_list|)
return|;
block|}
name|DISubroutineType
operator|*
name|getType
argument_list|()
specifier|const
block|{
return|return
name|cast_or_null
operator|<
name|DISubroutineType
operator|>
operator|(
name|getRawType
argument_list|()
operator|)
return|;
block|}
name|DITypeRef
name|getContainingType
argument_list|()
specifier|const
block|{
return|return
name|DITypeRef
argument_list|(
name|getRawContainingType
argument_list|()
argument_list|)
return|;
block|}
name|DICompileUnit
operator|*
name|getUnit
argument_list|()
specifier|const
block|{
return|return
name|cast_or_null
operator|<
name|DICompileUnit
operator|>
operator|(
name|getRawUnit
argument_list|()
operator|)
return|;
block|}
name|void
name|replaceUnit
argument_list|(
argument|DICompileUnit *CU
argument_list|)
block|{
name|replaceOperandWith
argument_list|(
literal|5
argument_list|,
name|CU
argument_list|)
block|; }
name|DITemplateParameterArray
name|getTemplateParams
argument_list|()
specifier|const
block|{
return|return
name|cast_or_null
operator|<
name|MDTuple
operator|>
operator|(
name|getRawTemplateParams
argument_list|()
operator|)
return|;
block|}
name|DISubprogram
operator|*
name|getDeclaration
argument_list|()
specifier|const
block|{
return|return
name|cast_or_null
operator|<
name|DISubprogram
operator|>
operator|(
name|getRawDeclaration
argument_list|()
operator|)
return|;
block|}
name|DILocalVariableArray
name|getVariables
argument_list|()
specifier|const
block|{
return|return
name|cast_or_null
operator|<
name|MDTuple
operator|>
operator|(
name|getRawVariables
argument_list|()
operator|)
return|;
block|}
name|DITypeArray
name|getThrownTypes
argument_list|()
specifier|const
block|{
return|return
name|cast_or_null
operator|<
name|MDTuple
operator|>
operator|(
name|getRawThrownTypes
argument_list|()
operator|)
return|;
block|}
name|Metadata
operator|*
name|getRawScope
argument_list|()
specifier|const
block|{
return|return
name|getOperand
argument_list|(
literal|1
argument_list|)
return|;
block|}
name|MDString
operator|*
name|getRawName
argument_list|()
specifier|const
block|{
return|return
name|getOperandAs
operator|<
name|MDString
operator|>
operator|(
literal|2
operator|)
return|;
block|}
name|MDString
operator|*
name|getRawLinkageName
argument_list|()
specifier|const
block|{
return|return
name|getOperandAs
operator|<
name|MDString
operator|>
operator|(
literal|3
operator|)
return|;
block|}
name|Metadata
operator|*
name|getRawType
argument_list|()
specifier|const
block|{
return|return
name|getOperand
argument_list|(
literal|4
argument_list|)
return|;
block|}
name|Metadata
operator|*
name|getRawUnit
argument_list|()
specifier|const
block|{
return|return
name|getOperand
argument_list|(
literal|5
argument_list|)
return|;
block|}
name|Metadata
operator|*
name|getRawDeclaration
argument_list|()
specifier|const
block|{
return|return
name|getOperand
argument_list|(
literal|6
argument_list|)
return|;
block|}
name|Metadata
operator|*
name|getRawVariables
argument_list|()
specifier|const
block|{
return|return
name|getOperand
argument_list|(
literal|7
argument_list|)
return|;
block|}
name|Metadata
operator|*
name|getRawContainingType
argument_list|()
specifier|const
block|{
return|return
name|getNumOperands
argument_list|()
operator|>
literal|8
operator|?
name|getOperandAs
operator|<
name|Metadata
operator|>
operator|(
literal|8
operator|)
operator|:
name|nullptr
return|;
block|}
name|Metadata
operator|*
name|getRawTemplateParams
argument_list|()
specifier|const
block|{
return|return
name|getNumOperands
argument_list|()
operator|>
literal|9
condition|?
name|getOperandAs
operator|<
name|Metadata
operator|>
operator|(
literal|9
operator|)
else|:
name|nullptr
return|;
block|}
name|Metadata
operator|*
name|getRawThrownTypes
argument_list|()
specifier|const
block|{
return|return
name|getNumOperands
argument_list|()
operator|>
literal|10
condition|?
name|getOperandAs
operator|<
name|Metadata
operator|>
operator|(
literal|10
operator|)
else|:
name|nullptr
return|;
block|}
comment|/// Check if this subprogram describes the given function.
comment|///
comment|/// FIXME: Should this be looking through bitcasts?
name|bool
name|describes
argument_list|(
argument|const Function *F
argument_list|)
specifier|const
block|;
specifier|static
name|bool
name|classof
argument_list|(
argument|const Metadata *MD
argument_list|)
block|{
return|return
name|MD
operator|->
name|getMetadataID
argument_list|()
operator|==
name|DISubprogramKind
return|;
block|}
expr|}
block|;
name|class
name|DILexicalBlockBase
operator|:
name|public
name|DILocalScope
block|{
name|protected
operator|:
name|DILexicalBlockBase
argument_list|(
argument|LLVMContext&C
argument_list|,
argument|unsigned ID
argument_list|,
argument|StorageType Storage
argument_list|,
argument|ArrayRef<Metadata *> Ops
argument_list|)
operator|:
name|DILocalScope
argument_list|(
argument|C
argument_list|,
argument|ID
argument_list|,
argument|Storage
argument_list|,
argument|dwarf::DW_TAG_lexical_block
argument_list|,
argument|Ops
argument_list|)
block|{}
operator|~
name|DILexicalBlockBase
argument_list|()
operator|=
expr|default
block|;
name|public
operator|:
name|DILocalScope
operator|*
name|getScope
argument_list|()
specifier|const
block|{
return|return
name|cast
operator|<
name|DILocalScope
operator|>
operator|(
name|getRawScope
argument_list|()
operator|)
return|;
block|}
name|Metadata
operator|*
name|getRawScope
argument_list|()
specifier|const
block|{
return|return
name|getOperand
argument_list|(
literal|1
argument_list|)
return|;
block|}
specifier|static
name|bool
name|classof
argument_list|(
argument|const Metadata *MD
argument_list|)
block|{
return|return
name|MD
operator|->
name|getMetadataID
argument_list|()
operator|==
name|DILexicalBlockKind
operator|||
name|MD
operator|->
name|getMetadataID
argument_list|()
operator|==
name|DILexicalBlockFileKind
return|;
block|}
expr|}
block|;
name|class
name|DILexicalBlock
operator|:
name|public
name|DILexicalBlockBase
block|{
name|friend
name|class
name|LLVMContextImpl
block|;
name|friend
name|class
name|MDNode
block|;
name|unsigned
name|Line
block|;
name|uint16_t
name|Column
block|;
name|DILexicalBlock
argument_list|(
argument|LLVMContext&C
argument_list|,
argument|StorageType Storage
argument_list|,
argument|unsigned Line
argument_list|,
argument|unsigned Column
argument_list|,
argument|ArrayRef<Metadata *> Ops
argument_list|)
operator|:
name|DILexicalBlockBase
argument_list|(
name|C
argument_list|,
name|DILexicalBlockKind
argument_list|,
name|Storage
argument_list|,
name|Ops
argument_list|)
block|,
name|Line
argument_list|(
name|Line
argument_list|)
block|,
name|Column
argument_list|(
argument|Column
argument_list|)
block|{
name|assert
argument_list|(
name|Column
operator|<
operator|(
literal|1u
operator|<<
literal|16
operator|)
operator|&&
literal|"Expected 16-bit column"
argument_list|)
block|;   }
operator|~
name|DILexicalBlock
argument_list|()
operator|=
expr|default
block|;
specifier|static
name|DILexicalBlock
operator|*
name|getImpl
argument_list|(
argument|LLVMContext&Context
argument_list|,
argument|DILocalScope *Scope
argument_list|,
argument|DIFile *File
argument_list|,
argument|unsigned Line
argument_list|,
argument|unsigned Column
argument_list|,
argument|StorageType Storage
argument_list|,
argument|bool ShouldCreate = true
argument_list|)
block|{
return|return
name|getImpl
argument_list|(
name|Context
argument_list|,
name|static_cast
operator|<
name|Metadata
operator|*
operator|>
operator|(
name|Scope
operator|)
argument_list|,
name|static_cast
operator|<
name|Metadata
operator|*
operator|>
operator|(
name|File
operator|)
argument_list|,
name|Line
argument_list|,
name|Column
argument_list|,
name|Storage
argument_list|,
name|ShouldCreate
argument_list|)
return|;
block|}
specifier|static
name|DILexicalBlock
operator|*
name|getImpl
argument_list|(
argument|LLVMContext&Context
argument_list|,
argument|Metadata *Scope
argument_list|,
argument|Metadata *File
argument_list|,
argument|unsigned Line
argument_list|,
argument|unsigned Column
argument_list|,
argument|StorageType Storage
argument_list|,
argument|bool ShouldCreate = true
argument_list|)
block|;
name|TempDILexicalBlock
name|cloneImpl
argument_list|()
specifier|const
block|{
return|return
name|getTemporary
argument_list|(
name|getContext
argument_list|()
argument_list|,
name|getScope
argument_list|()
argument_list|,
name|getFile
argument_list|()
argument_list|,
name|getLine
argument_list|()
argument_list|,
name|getColumn
argument_list|()
argument_list|)
return|;
block|}
name|public
operator|:
name|DEFINE_MDNODE_GET
argument_list|(
argument|DILexicalBlock
argument_list|,
argument|(DILocalScope * Scope, DIFile *File,                                      unsigned Line, unsigned Column)
argument_list|,
argument|(Scope, File, Line, Column)
argument_list|)
name|DEFINE_MDNODE_GET
argument_list|(
argument|DILexicalBlock
argument_list|,
argument|(Metadata * Scope, Metadata *File,                                      unsigned Line, unsigned Column)
argument_list|,
argument|(Scope, File, Line, Column)
argument_list|)
name|TempDILexicalBlock
name|clone
argument_list|()
specifier|const
block|{
return|return
name|cloneImpl
argument_list|()
return|;
block|}
name|unsigned
name|getLine
argument_list|()
specifier|const
block|{
return|return
name|Line
return|;
block|}
name|unsigned
name|getColumn
argument_list|()
specifier|const
block|{
return|return
name|Column
return|;
block|}
specifier|static
name|bool
name|classof
argument_list|(
argument|const Metadata *MD
argument_list|)
block|{
return|return
name|MD
operator|->
name|getMetadataID
argument_list|()
operator|==
name|DILexicalBlockKind
return|;
block|}
expr|}
block|;
name|class
name|DILexicalBlockFile
operator|:
name|public
name|DILexicalBlockBase
block|{
name|friend
name|class
name|LLVMContextImpl
block|;
name|friend
name|class
name|MDNode
block|;
name|unsigned
name|Discriminator
block|;
name|DILexicalBlockFile
argument_list|(
argument|LLVMContext&C
argument_list|,
argument|StorageType Storage
argument_list|,
argument|unsigned Discriminator
argument_list|,
argument|ArrayRef<Metadata *> Ops
argument_list|)
operator|:
name|DILexicalBlockBase
argument_list|(
name|C
argument_list|,
name|DILexicalBlockFileKind
argument_list|,
name|Storage
argument_list|,
name|Ops
argument_list|)
block|,
name|Discriminator
argument_list|(
argument|Discriminator
argument_list|)
block|{}
operator|~
name|DILexicalBlockFile
argument_list|()
operator|=
expr|default
block|;
specifier|static
name|DILexicalBlockFile
operator|*
name|getImpl
argument_list|(
argument|LLVMContext&Context
argument_list|,
argument|DILocalScope *Scope
argument_list|,
argument|DIFile *File
argument_list|,
argument|unsigned Discriminator
argument_list|,
argument|StorageType Storage
argument_list|,
argument|bool ShouldCreate = true
argument_list|)
block|{
return|return
name|getImpl
argument_list|(
name|Context
argument_list|,
name|static_cast
operator|<
name|Metadata
operator|*
operator|>
operator|(
name|Scope
operator|)
argument_list|,
name|static_cast
operator|<
name|Metadata
operator|*
operator|>
operator|(
name|File
operator|)
argument_list|,
name|Discriminator
argument_list|,
name|Storage
argument_list|,
name|ShouldCreate
argument_list|)
return|;
block|}
specifier|static
name|DILexicalBlockFile
operator|*
name|getImpl
argument_list|(
argument|LLVMContext&Context
argument_list|,
argument|Metadata *Scope
argument_list|,
argument|Metadata *File
argument_list|,
argument|unsigned Discriminator
argument_list|,
argument|StorageType Storage
argument_list|,
argument|bool ShouldCreate = true
argument_list|)
block|;
name|TempDILexicalBlockFile
name|cloneImpl
argument_list|()
specifier|const
block|{
return|return
name|getTemporary
argument_list|(
name|getContext
argument_list|()
argument_list|,
name|getScope
argument_list|()
argument_list|,
name|getFile
argument_list|()
argument_list|,
name|getDiscriminator
argument_list|()
argument_list|)
return|;
block|}
name|public
operator|:
name|DEFINE_MDNODE_GET
argument_list|(
argument|DILexicalBlockFile
argument_list|,
argument|(DILocalScope * Scope, DIFile *File,                                          unsigned Discriminator)
argument_list|,
argument|(Scope, File, Discriminator)
argument_list|)
name|DEFINE_MDNODE_GET
argument_list|(
argument|DILexicalBlockFile
argument_list|,
argument|(Metadata * Scope, Metadata *File, unsigned Discriminator)
argument_list|,
argument|(Scope, File, Discriminator)
argument_list|)
name|TempDILexicalBlockFile
name|clone
argument_list|()
specifier|const
block|{
return|return
name|cloneImpl
argument_list|()
return|;
block|}
comment|// TODO: Remove these once they're gone from DILexicalBlockBase.
name|unsigned
name|getLine
argument_list|()
specifier|const
operator|=
name|delete
block|;
name|unsigned
name|getColumn
argument_list|()
specifier|const
operator|=
name|delete
block|;
name|unsigned
name|getDiscriminator
argument_list|()
specifier|const
block|{
return|return
name|Discriminator
return|;
block|}
specifier|static
name|bool
name|classof
argument_list|(
argument|const Metadata *MD
argument_list|)
block|{
return|return
name|MD
operator|->
name|getMetadataID
argument_list|()
operator|==
name|DILexicalBlockFileKind
return|;
block|}
expr|}
block|;
name|unsigned
name|DILocation
operator|::
name|getDiscriminator
argument_list|()
specifier|const
block|{
if|if
condition|(
name|auto
operator|*
name|F
operator|=
name|dyn_cast
operator|<
name|DILexicalBlockFile
operator|>
operator|(
name|getScope
argument_list|()
operator|)
condition|)
return|return
name|F
operator|->
name|getDiscriminator
argument_list|()
return|;
return|return
literal|0
return|;
block|}
specifier|const
name|DILocation
operator|*
name|DILocation
operator|::
name|cloneWithDiscriminator
argument_list|(
argument|unsigned Discriminator
argument_list|)
specifier|const
block|{
name|DIScope
operator|*
name|Scope
operator|=
name|getScope
argument_list|()
block|;
comment|// Skip all parent DILexicalBlockFile that already have a discriminator
comment|// assigned. We do not want to have nested DILexicalBlockFiles that have
comment|// mutliple discriminators because only the leaf DILexicalBlockFile's
comment|// dominator will be used.
for|for
control|(
name|auto
operator|*
name|LBF
operator|=
name|dyn_cast
operator|<
name|DILexicalBlockFile
operator|>
operator|(
name|Scope
operator|)
init|;
name|LBF
operator|&&
name|LBF
operator|->
name|getDiscriminator
argument_list|()
operator|!=
literal|0
condition|;
name|LBF
operator|=
name|dyn_cast
operator|<
name|DILexicalBlockFile
operator|>
operator|(
name|Scope
operator|)
control|)
name|Scope
operator|=
name|LBF
operator|->
name|getScope
argument_list|()
expr_stmt|;
name|DILexicalBlockFile
operator|*
name|NewScope
operator|=
name|DILexicalBlockFile
operator|::
name|get
argument_list|(
name|getContext
argument_list|()
argument_list|,
name|Scope
argument_list|,
name|getFile
argument_list|()
argument_list|,
name|Discriminator
argument_list|)
block|;
return|return
name|DILocation
operator|::
name|get
argument_list|(
name|getContext
argument_list|()
argument_list|,
name|getLine
argument_list|()
argument_list|,
name|getColumn
argument_list|()
argument_list|,
name|NewScope
argument_list|,
name|getInlinedAt
argument_list|()
argument_list|)
return|;
block|}
name|unsigned
name|DILocation
operator|::
name|getBaseDiscriminator
argument_list|()
specifier|const
block|{
return|return
name|getBaseDiscriminatorFromDiscriminator
argument_list|(
name|getDiscriminator
argument_list|()
argument_list|)
return|;
block|}
name|unsigned
name|DILocation
operator|::
name|getDuplicationFactor
argument_list|()
specifier|const
block|{
return|return
name|getDuplicationFactorFromDiscriminator
argument_list|(
name|getDiscriminator
argument_list|()
argument_list|)
return|;
block|}
name|unsigned
name|DILocation
operator|::
name|getCopyIdentifier
argument_list|()
specifier|const
block|{
return|return
name|getCopyIdentifierFromDiscriminator
argument_list|(
name|getDiscriminator
argument_list|()
argument_list|)
return|;
block|}
specifier|const
name|DILocation
operator|*
name|DILocation
operator|::
name|setBaseDiscriminator
argument_list|(
argument|unsigned D
argument_list|)
specifier|const
block|{
if|if
condition|(
name|D
operator|==
literal|0
condition|)
return|return
name|this
return|;
else|else
return|return
name|cloneWithDiscriminator
argument_list|(
name|getPrefixEncodingFromUnsigned
argument_list|(
name|D
argument_list|)
operator|<<
literal|1
argument_list|)
return|;
block|}
specifier|const
name|DILocation
operator|*
name|DILocation
operator|::
name|cloneWithDuplicationFactor
argument_list|(
argument|unsigned DF
argument_list|)
specifier|const
block|{
name|DF
operator|*=
name|getDuplicationFactor
argument_list|()
block|;
if|if
condition|(
name|DF
operator|<=
literal|1
condition|)
return|return
name|this
return|;
name|unsigned
name|BD
operator|=
name|getBaseDiscriminator
argument_list|()
block|;
name|unsigned
name|CI
operator|=
name|getCopyIdentifier
argument_list|()
operator|<<
operator|(
name|DF
operator|>
literal|0x1f
condition|?
literal|14
else|:
literal|7
operator|)
block|;
name|unsigned
name|D
operator|=
name|CI
operator||
operator|(
name|getPrefixEncodingFromUnsigned
argument_list|(
name|DF
argument_list|)
operator|<<
literal|1
operator|)
block|;
if|if
condition|(
name|BD
operator|==
literal|0
condition|)
name|D
operator|=
operator|(
name|D
operator|<<
literal|1
operator|)
operator||
literal|1
expr_stmt|;
else|else
name|D
operator|=
operator|(
name|D
operator|<<
operator|(
name|BD
operator|>
literal|0x1f
condition|?
literal|14
else|:
literal|7
operator|)
operator|)
operator||
operator|(
name|getPrefixEncodingFromUnsigned
argument_list|(
name|BD
argument_list|)
operator|<<
literal|1
operator|)
expr_stmt|;
return|return
name|cloneWithDiscriminator
argument_list|(
name|D
argument_list|)
return|;
block|}
name|class
name|DINamespace
operator|:
name|public
name|DIScope
block|{
name|friend
name|class
name|LLVMContextImpl
block|;
name|friend
name|class
name|MDNode
block|;
name|unsigned
name|ExportSymbols
operator|:
literal|1
block|;
name|DINamespace
argument_list|(
argument|LLVMContext&Context
argument_list|,
argument|StorageType Storage
argument_list|,
argument|bool ExportSymbols
argument_list|,
argument|ArrayRef<Metadata *> Ops
argument_list|)
operator|:
name|DIScope
argument_list|(
name|Context
argument_list|,
name|DINamespaceKind
argument_list|,
name|Storage
argument_list|,
name|dwarf
operator|::
name|DW_TAG_namespace
argument_list|,
name|Ops
argument_list|)
block|,
name|ExportSymbols
argument_list|(
argument|ExportSymbols
argument_list|)
block|{}
operator|~
name|DINamespace
argument_list|()
operator|=
expr|default
block|;
specifier|static
name|DINamespace
operator|*
name|getImpl
argument_list|(
argument|LLVMContext&Context
argument_list|,
argument|DIScope *Scope
argument_list|,
argument|StringRef Name
argument_list|,
argument|bool ExportSymbols
argument_list|,
argument|StorageType Storage
argument_list|,
argument|bool ShouldCreate = true
argument_list|)
block|{
return|return
name|getImpl
argument_list|(
name|Context
argument_list|,
name|Scope
argument_list|,
name|getCanonicalMDString
argument_list|(
name|Context
argument_list|,
name|Name
argument_list|)
argument_list|,
name|ExportSymbols
argument_list|,
name|Storage
argument_list|,
name|ShouldCreate
argument_list|)
return|;
block|}
specifier|static
name|DINamespace
operator|*
name|getImpl
argument_list|(
argument|LLVMContext&Context
argument_list|,
argument|Metadata *Scope
argument_list|,
argument|MDString *Name
argument_list|,
argument|bool ExportSymbols
argument_list|,
argument|StorageType Storage
argument_list|,
argument|bool ShouldCreate = true
argument_list|)
block|;
name|TempDINamespace
name|cloneImpl
argument_list|()
specifier|const
block|{
return|return
name|getTemporary
argument_list|(
name|getContext
argument_list|()
argument_list|,
name|getScope
argument_list|()
argument_list|,
name|getName
argument_list|()
argument_list|,
name|getExportSymbols
argument_list|()
argument_list|)
return|;
block|}
name|public
operator|:
name|DEFINE_MDNODE_GET
argument_list|(
argument|DINamespace
argument_list|,
argument|(DIScope *Scope, StringRef Name, bool ExportSymbols)
argument_list|,
argument|(Scope, Name, ExportSymbols)
argument_list|)
name|DEFINE_MDNODE_GET
argument_list|(
argument|DINamespace
argument_list|,
argument|(Metadata *Scope, MDString *Name, bool ExportSymbols)
argument_list|,
argument|(Scope, Name, ExportSymbols)
argument_list|)
name|TempDINamespace
name|clone
argument_list|()
specifier|const
block|{
return|return
name|cloneImpl
argument_list|()
return|;
block|}
name|bool
name|getExportSymbols
argument_list|()
specifier|const
block|{
return|return
name|ExportSymbols
return|;
block|}
name|DIScope
operator|*
name|getScope
argument_list|()
specifier|const
block|{
return|return
name|cast_or_null
operator|<
name|DIScope
operator|>
operator|(
name|getRawScope
argument_list|()
operator|)
return|;
block|}
name|StringRef
name|getName
argument_list|()
specifier|const
block|{
return|return
name|getStringOperand
argument_list|(
literal|2
argument_list|)
return|;
block|}
name|Metadata
operator|*
name|getRawScope
argument_list|()
specifier|const
block|{
return|return
name|getOperand
argument_list|(
literal|1
argument_list|)
return|;
block|}
name|MDString
operator|*
name|getRawName
argument_list|()
specifier|const
block|{
return|return
name|getOperandAs
operator|<
name|MDString
operator|>
operator|(
literal|2
operator|)
return|;
block|}
specifier|static
name|bool
name|classof
argument_list|(
argument|const Metadata *MD
argument_list|)
block|{
return|return
name|MD
operator|->
name|getMetadataID
argument_list|()
operator|==
name|DINamespaceKind
return|;
block|}
expr|}
block|;
comment|/// A (clang) module that has been imported by the compile unit.
comment|///
name|class
name|DIModule
operator|:
name|public
name|DIScope
block|{
name|friend
name|class
name|LLVMContextImpl
block|;
name|friend
name|class
name|MDNode
block|;
name|DIModule
argument_list|(
argument|LLVMContext&Context
argument_list|,
argument|StorageType Storage
argument_list|,
argument|ArrayRef<Metadata *> Ops
argument_list|)
operator|:
name|DIScope
argument_list|(
argument|Context
argument_list|,
argument|DIModuleKind
argument_list|,
argument|Storage
argument_list|,
argument|dwarf::DW_TAG_module
argument_list|,
argument|Ops
argument_list|)
block|{}
operator|~
name|DIModule
argument_list|()
operator|=
expr|default
block|;
specifier|static
name|DIModule
operator|*
name|getImpl
argument_list|(
argument|LLVMContext&Context
argument_list|,
argument|DIScope *Scope
argument_list|,
argument|StringRef Name
argument_list|,
argument|StringRef ConfigurationMacros
argument_list|,
argument|StringRef IncludePath
argument_list|,
argument|StringRef ISysRoot
argument_list|,
argument|StorageType Storage
argument_list|,
argument|bool ShouldCreate = true
argument_list|)
block|{
return|return
name|getImpl
argument_list|(
name|Context
argument_list|,
name|Scope
argument_list|,
name|getCanonicalMDString
argument_list|(
name|Context
argument_list|,
name|Name
argument_list|)
argument_list|,
name|getCanonicalMDString
argument_list|(
name|Context
argument_list|,
name|ConfigurationMacros
argument_list|)
argument_list|,
name|getCanonicalMDString
argument_list|(
name|Context
argument_list|,
name|IncludePath
argument_list|)
argument_list|,
name|getCanonicalMDString
argument_list|(
name|Context
argument_list|,
name|ISysRoot
argument_list|)
argument_list|,
name|Storage
argument_list|,
name|ShouldCreate
argument_list|)
return|;
block|}
specifier|static
name|DIModule
operator|*
name|getImpl
argument_list|(
argument|LLVMContext&Context
argument_list|,
argument|Metadata *Scope
argument_list|,
argument|MDString *Name
argument_list|,
argument|MDString *ConfigurationMacros
argument_list|,
argument|MDString *IncludePath
argument_list|,
argument|MDString *ISysRoot
argument_list|,
argument|StorageType Storage
argument_list|,
argument|bool ShouldCreate = true
argument_list|)
block|;
name|TempDIModule
name|cloneImpl
argument_list|()
specifier|const
block|{
return|return
name|getTemporary
argument_list|(
name|getContext
argument_list|()
argument_list|,
name|getScope
argument_list|()
argument_list|,
name|getName
argument_list|()
argument_list|,
name|getConfigurationMacros
argument_list|()
argument_list|,
name|getIncludePath
argument_list|()
argument_list|,
name|getISysRoot
argument_list|()
argument_list|)
return|;
block|}
name|public
operator|:
name|DEFINE_MDNODE_GET
argument_list|(
argument|DIModule
argument_list|,
argument|(DIScope *Scope, StringRef Name,                                StringRef ConfigurationMacros, StringRef IncludePath,                                StringRef ISysRoot)
argument_list|,
argument|(Scope, Name, ConfigurationMacros, IncludePath, ISysRoot)
argument_list|)
name|DEFINE_MDNODE_GET
argument_list|(
argument|DIModule
argument_list|,
argument|(Metadata *Scope, MDString *Name, MDString *ConfigurationMacros,                      MDString *IncludePath, MDString *ISysRoot)
argument_list|,
argument|(Scope, Name, ConfigurationMacros, IncludePath, ISysRoot)
argument_list|)
name|TempDIModule
name|clone
argument_list|()
specifier|const
block|{
return|return
name|cloneImpl
argument_list|()
return|;
block|}
name|DIScope
operator|*
name|getScope
argument_list|()
specifier|const
block|{
return|return
name|cast_or_null
operator|<
name|DIScope
operator|>
operator|(
name|getRawScope
argument_list|()
operator|)
return|;
block|}
name|StringRef
name|getName
argument_list|()
specifier|const
block|{
return|return
name|getStringOperand
argument_list|(
literal|1
argument_list|)
return|;
block|}
name|StringRef
name|getConfigurationMacros
argument_list|()
specifier|const
block|{
return|return
name|getStringOperand
argument_list|(
literal|2
argument_list|)
return|;
block|}
name|StringRef
name|getIncludePath
argument_list|()
specifier|const
block|{
return|return
name|getStringOperand
argument_list|(
literal|3
argument_list|)
return|;
block|}
name|StringRef
name|getISysRoot
argument_list|()
specifier|const
block|{
return|return
name|getStringOperand
argument_list|(
literal|4
argument_list|)
return|;
block|}
name|Metadata
operator|*
name|getRawScope
argument_list|()
specifier|const
block|{
return|return
name|getOperand
argument_list|(
literal|0
argument_list|)
return|;
block|}
name|MDString
operator|*
name|getRawName
argument_list|()
specifier|const
block|{
return|return
name|getOperandAs
operator|<
name|MDString
operator|>
operator|(
literal|1
operator|)
return|;
block|}
name|MDString
operator|*
name|getRawConfigurationMacros
argument_list|()
specifier|const
block|{
return|return
name|getOperandAs
operator|<
name|MDString
operator|>
operator|(
literal|2
operator|)
return|;
block|}
name|MDString
operator|*
name|getRawIncludePath
argument_list|()
specifier|const
block|{
return|return
name|getOperandAs
operator|<
name|MDString
operator|>
operator|(
literal|3
operator|)
return|;
block|}
name|MDString
operator|*
name|getRawISysRoot
argument_list|()
specifier|const
block|{
return|return
name|getOperandAs
operator|<
name|MDString
operator|>
operator|(
literal|4
operator|)
return|;
block|}
specifier|static
name|bool
name|classof
argument_list|(
argument|const Metadata *MD
argument_list|)
block|{
return|return
name|MD
operator|->
name|getMetadataID
argument_list|()
operator|==
name|DIModuleKind
return|;
block|}
expr|}
block|;
comment|/// Base class for template parameters.
name|class
name|DITemplateParameter
operator|:
name|public
name|DINode
block|{
name|protected
operator|:
name|DITemplateParameter
argument_list|(
argument|LLVMContext&Context
argument_list|,
argument|unsigned ID
argument_list|,
argument|StorageType Storage
argument_list|,
argument|unsigned Tag
argument_list|,
argument|ArrayRef<Metadata *> Ops
argument_list|)
operator|:
name|DINode
argument_list|(
argument|Context
argument_list|,
argument|ID
argument_list|,
argument|Storage
argument_list|,
argument|Tag
argument_list|,
argument|Ops
argument_list|)
block|{}
operator|~
name|DITemplateParameter
argument_list|()
operator|=
expr|default
block|;
name|public
operator|:
name|StringRef
name|getName
argument_list|()
specifier|const
block|{
return|return
name|getStringOperand
argument_list|(
literal|0
argument_list|)
return|;
block|}
name|DITypeRef
name|getType
argument_list|()
specifier|const
block|{
return|return
name|DITypeRef
argument_list|(
name|getRawType
argument_list|()
argument_list|)
return|;
block|}
name|MDString
operator|*
name|getRawName
argument_list|()
specifier|const
block|{
return|return
name|getOperandAs
operator|<
name|MDString
operator|>
operator|(
literal|0
operator|)
return|;
block|}
name|Metadata
operator|*
name|getRawType
argument_list|()
specifier|const
block|{
return|return
name|getOperand
argument_list|(
literal|1
argument_list|)
return|;
block|}
specifier|static
name|bool
name|classof
argument_list|(
argument|const Metadata *MD
argument_list|)
block|{
return|return
name|MD
operator|->
name|getMetadataID
argument_list|()
operator|==
name|DITemplateTypeParameterKind
operator|||
name|MD
operator|->
name|getMetadataID
argument_list|()
operator|==
name|DITemplateValueParameterKind
return|;
block|}
expr|}
block|;
name|class
name|DITemplateTypeParameter
operator|:
name|public
name|DITemplateParameter
block|{
name|friend
name|class
name|LLVMContextImpl
block|;
name|friend
name|class
name|MDNode
block|;
name|DITemplateTypeParameter
argument_list|(
argument|LLVMContext&Context
argument_list|,
argument|StorageType Storage
argument_list|,
argument|ArrayRef<Metadata *> Ops
argument_list|)
operator|:
name|DITemplateParameter
argument_list|(
argument|Context
argument_list|,
argument|DITemplateTypeParameterKind
argument_list|,
argument|Storage
argument_list|,
argument|dwarf::DW_TAG_template_type_parameter
argument_list|,
argument|Ops
argument_list|)
block|{}
operator|~
name|DITemplateTypeParameter
argument_list|()
operator|=
expr|default
block|;
specifier|static
name|DITemplateTypeParameter
operator|*
name|getImpl
argument_list|(
argument|LLVMContext&Context
argument_list|,
argument|StringRef Name
argument_list|,
argument|DITypeRef Type
argument_list|,
argument|StorageType Storage
argument_list|,
argument|bool ShouldCreate = true
argument_list|)
block|{
return|return
name|getImpl
argument_list|(
name|Context
argument_list|,
name|getCanonicalMDString
argument_list|(
name|Context
argument_list|,
name|Name
argument_list|)
argument_list|,
name|Type
argument_list|,
name|Storage
argument_list|,
name|ShouldCreate
argument_list|)
return|;
block|}
specifier|static
name|DITemplateTypeParameter
operator|*
name|getImpl
argument_list|(
argument|LLVMContext&Context
argument_list|,
argument|MDString *Name
argument_list|,
argument|Metadata *Type
argument_list|,
argument|StorageType Storage
argument_list|,
argument|bool ShouldCreate = true
argument_list|)
block|;
name|TempDITemplateTypeParameter
name|cloneImpl
argument_list|()
specifier|const
block|{
return|return
name|getTemporary
argument_list|(
name|getContext
argument_list|()
argument_list|,
name|getName
argument_list|()
argument_list|,
name|getType
argument_list|()
argument_list|)
return|;
block|}
name|public
operator|:
name|DEFINE_MDNODE_GET
argument_list|(
argument|DITemplateTypeParameter
argument_list|,
argument|(StringRef Name, DITypeRef Type)
argument_list|,
argument|(Name, Type)
argument_list|)
name|DEFINE_MDNODE_GET
argument_list|(
argument|DITemplateTypeParameter
argument_list|,
argument|(MDString * Name, Metadata *Type)
argument_list|,
argument|(Name, Type)
argument_list|)
name|TempDITemplateTypeParameter
name|clone
argument_list|()
specifier|const
block|{
return|return
name|cloneImpl
argument_list|()
return|;
block|}
specifier|static
name|bool
name|classof
argument_list|(
argument|const Metadata *MD
argument_list|)
block|{
return|return
name|MD
operator|->
name|getMetadataID
argument_list|()
operator|==
name|DITemplateTypeParameterKind
return|;
block|}
expr|}
block|;
name|class
name|DITemplateValueParameter
operator|:
name|public
name|DITemplateParameter
block|{
name|friend
name|class
name|LLVMContextImpl
block|;
name|friend
name|class
name|MDNode
block|;
name|DITemplateValueParameter
argument_list|(
argument|LLVMContext&Context
argument_list|,
argument|StorageType Storage
argument_list|,
argument|unsigned Tag
argument_list|,
argument|ArrayRef<Metadata *> Ops
argument_list|)
operator|:
name|DITemplateParameter
argument_list|(
argument|Context
argument_list|,
argument|DITemplateValueParameterKind
argument_list|,
argument|Storage
argument_list|,
argument|Tag
argument_list|,
argument|Ops
argument_list|)
block|{}
operator|~
name|DITemplateValueParameter
argument_list|()
operator|=
expr|default
block|;
specifier|static
name|DITemplateValueParameter
operator|*
name|getImpl
argument_list|(
argument|LLVMContext&Context
argument_list|,
argument|unsigned Tag
argument_list|,
argument|StringRef Name
argument_list|,
argument|DITypeRef Type
argument_list|,
argument|Metadata *Value
argument_list|,
argument|StorageType Storage
argument_list|,
argument|bool ShouldCreate = true
argument_list|)
block|{
return|return
name|getImpl
argument_list|(
name|Context
argument_list|,
name|Tag
argument_list|,
name|getCanonicalMDString
argument_list|(
name|Context
argument_list|,
name|Name
argument_list|)
argument_list|,
name|Type
argument_list|,
name|Value
argument_list|,
name|Storage
argument_list|,
name|ShouldCreate
argument_list|)
return|;
block|}
specifier|static
name|DITemplateValueParameter
operator|*
name|getImpl
argument_list|(
argument|LLVMContext&Context
argument_list|,
argument|unsigned Tag
argument_list|,
argument|MDString *Name
argument_list|,
argument|Metadata *Type
argument_list|,
argument|Metadata *Value
argument_list|,
argument|StorageType Storage
argument_list|,
argument|bool ShouldCreate = true
argument_list|)
block|;
name|TempDITemplateValueParameter
name|cloneImpl
argument_list|()
specifier|const
block|{
return|return
name|getTemporary
argument_list|(
name|getContext
argument_list|()
argument_list|,
name|getTag
argument_list|()
argument_list|,
name|getName
argument_list|()
argument_list|,
name|getType
argument_list|()
argument_list|,
name|getValue
argument_list|()
argument_list|)
return|;
block|}
name|public
operator|:
name|DEFINE_MDNODE_GET
argument_list|(
argument|DITemplateValueParameter
argument_list|,
argument|(unsigned Tag, StringRef Name,                                                DITypeRef Type, Metadata *Value)
argument_list|,
argument|(Tag, Name, Type, Value)
argument_list|)
name|DEFINE_MDNODE_GET
argument_list|(
argument|DITemplateValueParameter
argument_list|,
argument|(unsigned Tag, MDString *Name,                                                Metadata *Type, Metadata *Value)
argument_list|,
argument|(Tag, Name, Type, Value)
argument_list|)
name|TempDITemplateValueParameter
name|clone
argument_list|()
specifier|const
block|{
return|return
name|cloneImpl
argument_list|()
return|;
block|}
name|Metadata
operator|*
name|getValue
argument_list|()
specifier|const
block|{
return|return
name|getOperand
argument_list|(
literal|2
argument_list|)
return|;
block|}
specifier|static
name|bool
name|classof
argument_list|(
argument|const Metadata *MD
argument_list|)
block|{
return|return
name|MD
operator|->
name|getMetadataID
argument_list|()
operator|==
name|DITemplateValueParameterKind
return|;
block|}
expr|}
block|;
comment|/// Base class for variables.
name|class
name|DIVariable
operator|:
name|public
name|DINode
block|{
name|unsigned
name|Line
block|;
name|uint32_t
name|AlignInBits
block|;
name|protected
operator|:
name|DIVariable
argument_list|(
argument|LLVMContext&C
argument_list|,
argument|unsigned ID
argument_list|,
argument|StorageType Storage
argument_list|,
argument|unsigned Line
argument_list|,
argument|ArrayRef<Metadata *> Ops
argument_list|,
argument|uint32_t AlignInBits =
literal|0
argument_list|)
operator|:
name|DINode
argument_list|(
name|C
argument_list|,
name|ID
argument_list|,
name|Storage
argument_list|,
name|dwarf
operator|::
name|DW_TAG_variable
argument_list|,
name|Ops
argument_list|)
block|,
name|Line
argument_list|(
name|Line
argument_list|)
block|,
name|AlignInBits
argument_list|(
argument|AlignInBits
argument_list|)
block|{}
operator|~
name|DIVariable
argument_list|()
operator|=
expr|default
block|;
name|public
operator|:
name|unsigned
name|getLine
argument_list|()
specifier|const
block|{
return|return
name|Line
return|;
block|}
name|DIScope
operator|*
name|getScope
argument_list|()
specifier|const
block|{
return|return
name|cast_or_null
operator|<
name|DIScope
operator|>
operator|(
name|getRawScope
argument_list|()
operator|)
return|;
block|}
name|StringRef
name|getName
argument_list|()
specifier|const
block|{
return|return
name|getStringOperand
argument_list|(
literal|1
argument_list|)
return|;
block|}
name|DIFile
operator|*
name|getFile
argument_list|()
specifier|const
block|{
return|return
name|cast_or_null
operator|<
name|DIFile
operator|>
operator|(
name|getRawFile
argument_list|()
operator|)
return|;
block|}
name|DITypeRef
name|getType
argument_list|()
specifier|const
block|{
return|return
name|DITypeRef
argument_list|(
name|getRawType
argument_list|()
argument_list|)
return|;
block|}
name|uint32_t
name|getAlignInBits
argument_list|()
specifier|const
block|{
return|return
name|AlignInBits
return|;
block|}
name|uint32_t
name|getAlignInBytes
argument_list|()
specifier|const
block|{
return|return
name|getAlignInBits
argument_list|()
operator|/
name|CHAR_BIT
return|;
block|}
name|StringRef
name|getFilename
argument_list|()
specifier|const
block|{
if|if
condition|(
name|auto
operator|*
name|F
operator|=
name|getFile
argument_list|()
condition|)
return|return
name|F
operator|->
name|getFilename
argument_list|()
return|;
return|return
literal|""
return|;
block|}
name|StringRef
name|getDirectory
argument_list|()
specifier|const
block|{
if|if
condition|(
name|auto
operator|*
name|F
operator|=
name|getFile
argument_list|()
condition|)
return|return
name|F
operator|->
name|getDirectory
argument_list|()
return|;
return|return
literal|""
return|;
block|}
name|Metadata
operator|*
name|getRawScope
argument_list|()
specifier|const
block|{
return|return
name|getOperand
argument_list|(
literal|0
argument_list|)
return|;
block|}
name|MDString
operator|*
name|getRawName
argument_list|()
specifier|const
block|{
return|return
name|getOperandAs
operator|<
name|MDString
operator|>
operator|(
literal|1
operator|)
return|;
block|}
name|Metadata
operator|*
name|getRawFile
argument_list|()
specifier|const
block|{
return|return
name|getOperand
argument_list|(
literal|2
argument_list|)
return|;
block|}
name|Metadata
operator|*
name|getRawType
argument_list|()
specifier|const
block|{
return|return
name|getOperand
argument_list|(
literal|3
argument_list|)
return|;
block|}
specifier|static
name|bool
name|classof
argument_list|(
argument|const Metadata *MD
argument_list|)
block|{
return|return
name|MD
operator|->
name|getMetadataID
argument_list|()
operator|==
name|DILocalVariableKind
operator|||
name|MD
operator|->
name|getMetadataID
argument_list|()
operator|==
name|DIGlobalVariableKind
return|;
block|}
expr|}
block|;
comment|/// DWARF expression.
comment|///
comment|/// This is (almost) a DWARF expression that modifies the location of a
comment|/// variable, or the location of a single piece of a variable, or (when using
comment|/// DW_OP_stack_value) is the constant variable value.
comment|///
comment|/// FIXME: Instead of DW_OP_plus taking an argument, this should use DW_OP_const
comment|/// and have DW_OP_plus consume the topmost elements on the stack.
comment|///
comment|/// TODO: Co-allocate the expression elements.
comment|/// TODO: Separate from MDNode, or otherwise drop Distinct and Temporary
comment|/// storage types.
name|class
name|DIExpression
operator|:
name|public
name|MDNode
block|{
name|friend
name|class
name|LLVMContextImpl
block|;
name|friend
name|class
name|MDNode
block|;
name|std
operator|::
name|vector
operator|<
name|uint64_t
operator|>
name|Elements
block|;
name|DIExpression
argument_list|(
argument|LLVMContext&C
argument_list|,
argument|StorageType Storage
argument_list|,
argument|ArrayRef<uint64_t> Elements
argument_list|)
operator|:
name|MDNode
argument_list|(
name|C
argument_list|,
name|DIExpressionKind
argument_list|,
name|Storage
argument_list|,
name|None
argument_list|)
block|,
name|Elements
argument_list|(
argument|Elements.begin()
argument_list|,
argument|Elements.end()
argument_list|)
block|{}
operator|~
name|DIExpression
argument_list|()
operator|=
expr|default
block|;
specifier|static
name|DIExpression
operator|*
name|getImpl
argument_list|(
argument|LLVMContext&Context
argument_list|,
argument|ArrayRef<uint64_t> Elements
argument_list|,
argument|StorageType Storage
argument_list|,
argument|bool ShouldCreate = true
argument_list|)
block|;
name|TempDIExpression
name|cloneImpl
argument_list|()
specifier|const
block|{
return|return
name|getTemporary
argument_list|(
name|getContext
argument_list|()
argument_list|,
name|getElements
argument_list|()
argument_list|)
return|;
block|}
name|public
operator|:
name|DEFINE_MDNODE_GET
argument_list|(
argument|DIExpression
argument_list|,
argument|(ArrayRef<uint64_t> Elements)
argument_list|,
argument|(Elements)
argument_list|)
name|TempDIExpression
name|clone
argument_list|()
specifier|const
block|{
return|return
name|cloneImpl
argument_list|()
return|;
block|}
name|ArrayRef
operator|<
name|uint64_t
operator|>
name|getElements
argument_list|()
specifier|const
block|{
return|return
name|Elements
return|;
block|}
name|unsigned
name|getNumElements
argument_list|()
specifier|const
block|{
return|return
name|Elements
operator|.
name|size
argument_list|()
return|;
block|}
name|uint64_t
name|getElement
argument_list|(
argument|unsigned I
argument_list|)
specifier|const
block|{
name|assert
argument_list|(
name|I
operator|<
name|Elements
operator|.
name|size
argument_list|()
operator|&&
literal|"Index out of range"
argument_list|)
block|;
return|return
name|Elements
index|[
name|I
index|]
return|;
block|}
comment|/// Determine whether this represents a standalone constant value.
name|bool
name|isConstant
argument_list|()
specifier|const
block|;
name|using
name|element_iterator
operator|=
name|ArrayRef
operator|<
name|uint64_t
operator|>
operator|::
name|iterator
block|;
name|element_iterator
name|elements_begin
argument_list|()
specifier|const
block|{
return|return
name|getElements
argument_list|()
operator|.
name|begin
argument_list|()
return|;
block|}
name|element_iterator
name|elements_end
argument_list|()
specifier|const
block|{
return|return
name|getElements
argument_list|()
operator|.
name|end
argument_list|()
return|;
block|}
comment|/// A lightweight wrapper around an expression operand.
comment|///
comment|/// TODO: Store arguments directly and change \a DIExpression to store a
comment|/// range of these.
name|class
name|ExprOperand
block|{
specifier|const
name|uint64_t
operator|*
name|Op
operator|=
name|nullptr
block|;
name|public
operator|:
name|ExprOperand
argument_list|()
operator|=
expr|default
block|;
name|explicit
name|ExprOperand
argument_list|(
specifier|const
name|uint64_t
operator|*
name|Op
argument_list|)
operator|:
name|Op
argument_list|(
argument|Op
argument_list|)
block|{}
specifier|const
name|uint64_t
operator|*
name|get
argument_list|()
specifier|const
block|{
return|return
name|Op
return|;
block|}
comment|/// Get the operand code.
name|uint64_t
name|getOp
argument_list|()
specifier|const
block|{
return|return
operator|*
name|Op
return|;
block|}
comment|/// Get an argument to the operand.
comment|///
comment|/// Never returns the operand itself.
name|uint64_t
name|getArg
argument_list|(
argument|unsigned I
argument_list|)
specifier|const
block|{
return|return
name|Op
index|[
name|I
operator|+
literal|1
index|]
return|;
block|}
name|unsigned
name|getNumArgs
argument_list|()
specifier|const
block|{
return|return
name|getSize
argument_list|()
operator|-
literal|1
return|;
block|}
comment|/// Return the size of the operand.
comment|///
comment|/// Return the number of elements in the operand (1 + args).
name|unsigned
name|getSize
argument_list|()
specifier|const
block|;   }
block|;
comment|/// An iterator for expression operands.
name|class
name|expr_op_iterator
operator|:
name|public
name|std
operator|::
name|iterator
operator|<
name|std
operator|::
name|input_iterator_tag
block|,
name|ExprOperand
operator|>
block|{
name|ExprOperand
name|Op
block|;
name|public
operator|:
name|expr_op_iterator
argument_list|()
operator|=
expr|default
block|;
name|explicit
name|expr_op_iterator
argument_list|(
argument|element_iterator I
argument_list|)
operator|:
name|Op
argument_list|(
argument|I
argument_list|)
block|{}
name|element_iterator
name|getBase
argument_list|()
specifier|const
block|{
return|return
name|Op
operator|.
name|get
argument_list|()
return|;
block|}
specifier|const
name|ExprOperand
operator|&
name|operator
operator|*
operator|(
operator|)
specifier|const
block|{
return|return
name|Op
return|;
block|}
specifier|const
name|ExprOperand
operator|*
name|operator
operator|->
expr|(
block|)
specifier|const
block|{
return|return
operator|&
name|Op
return|;
block|}
name|expr_op_iterator
operator|&
name|operator
operator|++
operator|(
operator|)
block|{
name|increment
argument_list|()
block|;
return|return
operator|*
name|this
return|;
block|}
name|expr_op_iterator
name|operator
operator|++
operator|(
name|int
operator|)
block|{
name|expr_op_iterator
name|T
argument_list|(
operator|*
name|this
argument_list|)
block|;
name|increment
argument_list|()
block|;
return|return
name|T
return|;
block|}
comment|/// Get the next iterator.
comment|///
comment|/// \a std::next() doesn't work because this is technically an
comment|/// input_iterator, but it's a perfectly valid operation.  This is an
comment|/// accessor to provide the same functionality.
name|expr_op_iterator
name|getNext
argument_list|()
specifier|const
block|{
return|return
operator|++
name|expr_op_iterator
argument_list|(
operator|*
name|this
argument_list|)
return|;
block|}
name|bool
name|operator
operator|==
operator|(
specifier|const
name|expr_op_iterator
operator|&
name|X
operator|)
specifier|const
block|{
return|return
name|getBase
argument_list|()
operator|==
name|X
operator|.
name|getBase
argument_list|()
return|;
block|}
name|bool
name|operator
operator|!=
operator|(
specifier|const
name|expr_op_iterator
operator|&
name|X
operator|)
specifier|const
block|{
return|return
name|getBase
argument_list|()
operator|!=
name|X
operator|.
name|getBase
argument_list|()
return|;
block|}
name|private
operator|:
name|void
name|increment
argument_list|()
block|{
name|Op
operator|=
name|ExprOperand
argument_list|(
name|getBase
argument_list|()
operator|+
name|Op
operator|.
name|getSize
argument_list|()
argument_list|)
block|; }
expr|}
block|;
comment|/// Visit the elements via ExprOperand wrappers.
comment|///
comment|/// These range iterators visit elements through \a ExprOperand wrappers.
comment|/// This is not guaranteed to be a valid range unless \a isValid() gives \c
comment|/// true.
comment|///
comment|/// \pre \a isValid() gives \c true.
comment|/// @{
name|expr_op_iterator
name|expr_op_begin
argument_list|()
specifier|const
block|{
return|return
name|expr_op_iterator
argument_list|(
name|elements_begin
argument_list|()
argument_list|)
return|;
block|}
name|expr_op_iterator
name|expr_op_end
argument_list|()
specifier|const
block|{
return|return
name|expr_op_iterator
argument_list|(
name|elements_end
argument_list|()
argument_list|)
return|;
block|}
name|iterator_range
operator|<
name|expr_op_iterator
operator|>
name|expr_ops
argument_list|()
specifier|const
block|{
return|return
block|{
name|expr_op_begin
argument_list|()
block|,
name|expr_op_end
argument_list|()
block|}
return|;
block|}
comment|/// @}
name|bool
name|isValid
argument_list|()
specifier|const
block|;
specifier|static
name|bool
name|classof
argument_list|(
argument|const Metadata *MD
argument_list|)
block|{
return|return
name|MD
operator|->
name|getMetadataID
argument_list|()
operator|==
name|DIExpressionKind
return|;
block|}
comment|/// Return whether the first element a DW_OP_deref.
name|bool
name|startsWithDeref
argument_list|()
specifier|const
block|{
return|return
name|getNumElements
argument_list|()
operator|>
literal|0
operator|&&
name|getElement
argument_list|(
literal|0
argument_list|)
operator|==
name|dwarf
operator|::
name|DW_OP_deref
return|;
block|}
comment|/// Holds the characteristics of one fragment of a larger variable.
expr|struct
name|FragmentInfo
block|{
name|uint64_t
name|SizeInBits
block|;
name|uint64_t
name|OffsetInBits
block|;   }
block|;
comment|/// Retrieve the details of this fragment expression.
specifier|static
name|Optional
operator|<
name|FragmentInfo
operator|>
name|getFragmentInfo
argument_list|(
argument|expr_op_iterator Start
argument_list|,
argument|expr_op_iterator End
argument_list|)
block|;
comment|/// Retrieve the details of this fragment expression.
name|Optional
operator|<
name|FragmentInfo
operator|>
name|getFragmentInfo
argument_list|()
specifier|const
block|{
return|return
name|getFragmentInfo
argument_list|(
name|expr_op_begin
argument_list|()
argument_list|,
name|expr_op_end
argument_list|()
argument_list|)
return|;
block|}
comment|/// Return whether this is a piece of an aggregate variable.
name|bool
name|isFragment
argument_list|()
specifier|const
block|{
return|return
name|getFragmentInfo
argument_list|()
operator|.
name|hasValue
argument_list|()
return|;
block|}
comment|/// Append \p Ops with operations to apply the \p Offset.
specifier|static
name|void
name|appendOffset
argument_list|(
argument|SmallVectorImpl<uint64_t>&Ops
argument_list|,
argument|int64_t Offset
argument_list|)
block|;
comment|/// If this is a constant offset, extract it. If there is no expression,
comment|/// return true with an offset of zero.
name|bool
name|extractIfOffset
argument_list|(
argument|int64_t&Offset
argument_list|)
specifier|const
block|;
comment|/// Constants for DIExpression::prepend.
block|enum
block|{
name|NoDeref
operator|=
name|false
block|,
name|WithDeref
operator|=
name|true
block|,
name|WithStackValue
operator|=
name|true
block|}
block|;
comment|/// Prepend \p DIExpr with a deref and offset operation and optionally turn it
comment|/// into a stack value.
specifier|static
name|DIExpression
operator|*
name|prepend
argument_list|(
argument|const DIExpression *DIExpr
argument_list|,
argument|bool Deref
argument_list|,
argument|int64_t Offset =
literal|0
argument_list|,
argument|bool StackValue = false
argument_list|)
block|; }
block|;
comment|/// Global variables.
comment|///
comment|/// TODO: Remove DisplayName.  It's always equal to Name.
name|class
name|DIGlobalVariable
operator|:
name|public
name|DIVariable
block|{
name|friend
name|class
name|LLVMContextImpl
block|;
name|friend
name|class
name|MDNode
block|;
name|bool
name|IsLocalToUnit
block|;
name|bool
name|IsDefinition
block|;
name|DIGlobalVariable
argument_list|(
argument|LLVMContext&C
argument_list|,
argument|StorageType Storage
argument_list|,
argument|unsigned Line
argument_list|,
argument|bool IsLocalToUnit
argument_list|,
argument|bool IsDefinition
argument_list|,
argument|uint32_t AlignInBits
argument_list|,
argument|ArrayRef<Metadata *> Ops
argument_list|)
operator|:
name|DIVariable
argument_list|(
name|C
argument_list|,
name|DIGlobalVariableKind
argument_list|,
name|Storage
argument_list|,
name|Line
argument_list|,
name|Ops
argument_list|,
name|AlignInBits
argument_list|)
block|,
name|IsLocalToUnit
argument_list|(
name|IsLocalToUnit
argument_list|)
block|,
name|IsDefinition
argument_list|(
argument|IsDefinition
argument_list|)
block|{}
operator|~
name|DIGlobalVariable
argument_list|()
operator|=
expr|default
block|;
specifier|static
name|DIGlobalVariable
operator|*
name|getImpl
argument_list|(
argument|LLVMContext&Context
argument_list|,
argument|DIScope *Scope
argument_list|,
argument|StringRef Name
argument_list|,
argument|StringRef LinkageName
argument_list|,
argument|DIFile *File
argument_list|,
argument|unsigned Line
argument_list|,
argument|DITypeRef Type
argument_list|,
argument|bool IsLocalToUnit
argument_list|,
argument|bool IsDefinition
argument_list|,
argument|DIDerivedType *StaticDataMemberDeclaration
argument_list|,
argument|uint32_t AlignInBits
argument_list|,
argument|StorageType Storage
argument_list|,
argument|bool ShouldCreate = true
argument_list|)
block|{
return|return
name|getImpl
argument_list|(
name|Context
argument_list|,
name|Scope
argument_list|,
name|getCanonicalMDString
argument_list|(
name|Context
argument_list|,
name|Name
argument_list|)
argument_list|,
name|getCanonicalMDString
argument_list|(
name|Context
argument_list|,
name|LinkageName
argument_list|)
argument_list|,
name|File
argument_list|,
name|Line
argument_list|,
name|Type
argument_list|,
name|IsLocalToUnit
argument_list|,
name|IsDefinition
argument_list|,
name|StaticDataMemberDeclaration
argument_list|,
name|AlignInBits
argument_list|,
name|Storage
argument_list|,
name|ShouldCreate
argument_list|)
return|;
block|}
specifier|static
name|DIGlobalVariable
operator|*
name|getImpl
argument_list|(
argument|LLVMContext&Context
argument_list|,
argument|Metadata *Scope
argument_list|,
argument|MDString *Name
argument_list|,
argument|MDString *LinkageName
argument_list|,
argument|Metadata *File
argument_list|,
argument|unsigned Line
argument_list|,
argument|Metadata *Type
argument_list|,
argument|bool IsLocalToUnit
argument_list|,
argument|bool IsDefinition
argument_list|,
argument|Metadata *StaticDataMemberDeclaration
argument_list|,
argument|uint32_t AlignInBits
argument_list|,
argument|StorageType Storage
argument_list|,
argument|bool ShouldCreate = true
argument_list|)
block|;
name|TempDIGlobalVariable
name|cloneImpl
argument_list|()
specifier|const
block|{
return|return
name|getTemporary
argument_list|(
name|getContext
argument_list|()
argument_list|,
name|getScope
argument_list|()
argument_list|,
name|getName
argument_list|()
argument_list|,
name|getLinkageName
argument_list|()
argument_list|,
name|getFile
argument_list|()
argument_list|,
name|getLine
argument_list|()
argument_list|,
name|getType
argument_list|()
argument_list|,
name|isLocalToUnit
argument_list|()
argument_list|,
name|isDefinition
argument_list|()
argument_list|,
name|getStaticDataMemberDeclaration
argument_list|()
argument_list|,
name|getAlignInBits
argument_list|()
argument_list|)
return|;
block|}
name|public
operator|:
name|DEFINE_MDNODE_GET
argument_list|(
argument|DIGlobalVariable
argument_list|,
argument|(DIScope * Scope, StringRef Name, StringRef LinkageName,                      DIFile *File, unsigned Line, DITypeRef Type,                      bool IsLocalToUnit, bool IsDefinition,                      DIDerivedType *StaticDataMemberDeclaration,                      uint32_t AlignInBits)
argument_list|,
argument|(Scope, Name, LinkageName, File, Line, Type, IsLocalToUnit,                      IsDefinition, StaticDataMemberDeclaration, AlignInBits)
argument_list|)
name|DEFINE_MDNODE_GET
argument_list|(
argument|DIGlobalVariable
argument_list|,
argument|(Metadata * Scope, MDString *Name, MDString *LinkageName,                      Metadata *File, unsigned Line, Metadata *Type,                      bool IsLocalToUnit, bool IsDefinition,                      Metadata *StaticDataMemberDeclaration,                      uint32_t AlignInBits)
argument_list|,
argument|(Scope, Name, LinkageName, File, Line, Type, IsLocalToUnit,                      IsDefinition, StaticDataMemberDeclaration, AlignInBits)
argument_list|)
name|TempDIGlobalVariable
name|clone
argument_list|()
specifier|const
block|{
return|return
name|cloneImpl
argument_list|()
return|;
block|}
name|bool
name|isLocalToUnit
argument_list|()
specifier|const
block|{
return|return
name|IsLocalToUnit
return|;
block|}
name|bool
name|isDefinition
argument_list|()
specifier|const
block|{
return|return
name|IsDefinition
return|;
block|}
name|StringRef
name|getDisplayName
argument_list|()
specifier|const
block|{
return|return
name|getStringOperand
argument_list|(
literal|4
argument_list|)
return|;
block|}
name|StringRef
name|getLinkageName
argument_list|()
specifier|const
block|{
return|return
name|getStringOperand
argument_list|(
literal|5
argument_list|)
return|;
block|}
name|DIDerivedType
operator|*
name|getStaticDataMemberDeclaration
argument_list|()
specifier|const
block|{
return|return
name|cast_or_null
operator|<
name|DIDerivedType
operator|>
operator|(
name|getRawStaticDataMemberDeclaration
argument_list|()
operator|)
return|;
block|}
name|MDString
operator|*
name|getRawLinkageName
argument_list|()
specifier|const
block|{
return|return
name|getOperandAs
operator|<
name|MDString
operator|>
operator|(
literal|5
operator|)
return|;
block|}
name|Metadata
operator|*
name|getRawStaticDataMemberDeclaration
argument_list|()
specifier|const
block|{
return|return
name|getOperand
argument_list|(
literal|6
argument_list|)
return|;
block|}
specifier|static
name|bool
name|classof
argument_list|(
argument|const Metadata *MD
argument_list|)
block|{
return|return
name|MD
operator|->
name|getMetadataID
argument_list|()
operator|==
name|DIGlobalVariableKind
return|;
block|}
expr|}
block|;
comment|/// Local variable.
comment|///
comment|/// TODO: Split up flags.
name|class
name|DILocalVariable
operator|:
name|public
name|DIVariable
block|{
name|friend
name|class
name|LLVMContextImpl
block|;
name|friend
name|class
name|MDNode
block|;
name|unsigned
name|Arg
operator|:
literal|16
block|;
name|DIFlags
name|Flags
block|;
name|DILocalVariable
argument_list|(
argument|LLVMContext&C
argument_list|,
argument|StorageType Storage
argument_list|,
argument|unsigned Line
argument_list|,
argument|unsigned Arg
argument_list|,
argument|DIFlags Flags
argument_list|,
argument|uint32_t AlignInBits
argument_list|,
argument|ArrayRef<Metadata *> Ops
argument_list|)
operator|:
name|DIVariable
argument_list|(
name|C
argument_list|,
name|DILocalVariableKind
argument_list|,
name|Storage
argument_list|,
name|Line
argument_list|,
name|Ops
argument_list|,
name|AlignInBits
argument_list|)
block|,
name|Arg
argument_list|(
name|Arg
argument_list|)
block|,
name|Flags
argument_list|(
argument|Flags
argument_list|)
block|{
name|assert
argument_list|(
name|Arg
operator|<
operator|(
literal|1
operator|<<
literal|16
operator|)
operator|&&
literal|"DILocalVariable: Arg out of range"
argument_list|)
block|;   }
operator|~
name|DILocalVariable
argument_list|()
operator|=
expr|default
block|;
specifier|static
name|DILocalVariable
operator|*
name|getImpl
argument_list|(
argument|LLVMContext&Context
argument_list|,
argument|DIScope *Scope
argument_list|,
argument|StringRef Name
argument_list|,
argument|DIFile *File
argument_list|,
argument|unsigned Line
argument_list|,
argument|DITypeRef Type
argument_list|,
argument|unsigned Arg
argument_list|,
argument|DIFlags Flags
argument_list|,
argument|uint32_t AlignInBits
argument_list|,
argument|StorageType Storage
argument_list|,
argument|bool ShouldCreate = true
argument_list|)
block|{
return|return
name|getImpl
argument_list|(
name|Context
argument_list|,
name|Scope
argument_list|,
name|getCanonicalMDString
argument_list|(
name|Context
argument_list|,
name|Name
argument_list|)
argument_list|,
name|File
argument_list|,
name|Line
argument_list|,
name|Type
argument_list|,
name|Arg
argument_list|,
name|Flags
argument_list|,
name|AlignInBits
argument_list|,
name|Storage
argument_list|,
name|ShouldCreate
argument_list|)
return|;
block|}
specifier|static
name|DILocalVariable
operator|*
name|getImpl
argument_list|(
argument|LLVMContext&Context
argument_list|,
argument|Metadata *Scope
argument_list|,
argument|MDString *Name
argument_list|,
argument|Metadata *File
argument_list|,
argument|unsigned Line
argument_list|,
argument|Metadata *Type
argument_list|,
argument|unsigned Arg
argument_list|,
argument|DIFlags Flags
argument_list|,
argument|uint32_t AlignInBits
argument_list|,
argument|StorageType Storage
argument_list|,
argument|bool ShouldCreate = true
argument_list|)
block|;
name|TempDILocalVariable
name|cloneImpl
argument_list|()
specifier|const
block|{
return|return
name|getTemporary
argument_list|(
name|getContext
argument_list|()
argument_list|,
name|getScope
argument_list|()
argument_list|,
name|getName
argument_list|()
argument_list|,
name|getFile
argument_list|()
argument_list|,
name|getLine
argument_list|()
argument_list|,
name|getType
argument_list|()
argument_list|,
name|getArg
argument_list|()
argument_list|,
name|getFlags
argument_list|()
argument_list|,
name|getAlignInBits
argument_list|()
argument_list|)
return|;
block|}
name|public
operator|:
name|DEFINE_MDNODE_GET
argument_list|(
argument|DILocalVariable
argument_list|,
argument|(DILocalScope * Scope, StringRef Name, DIFile *File,                      unsigned Line, DITypeRef Type, unsigned Arg,                      DIFlags Flags, uint32_t AlignInBits)
argument_list|,
argument|(Scope, Name, File, Line, Type, Arg, Flags, AlignInBits)
argument_list|)
name|DEFINE_MDNODE_GET
argument_list|(
argument|DILocalVariable
argument_list|,
argument|(Metadata * Scope, MDString *Name, Metadata *File,                      unsigned Line, Metadata *Type, unsigned Arg,                      DIFlags Flags, uint32_t AlignInBits)
argument_list|,
argument|(Scope, Name, File, Line, Type, Arg, Flags, AlignInBits)
argument_list|)
name|TempDILocalVariable
name|clone
argument_list|()
specifier|const
block|{
return|return
name|cloneImpl
argument_list|()
return|;
block|}
comment|/// Get the local scope for this variable.
comment|///
comment|/// Variables must be defined in a local scope.
name|DILocalScope
operator|*
name|getScope
argument_list|()
specifier|const
block|{
return|return
name|cast
operator|<
name|DILocalScope
operator|>
operator|(
name|DIVariable
operator|::
name|getScope
argument_list|()
operator|)
return|;
block|}
name|bool
name|isParameter
argument_list|()
specifier|const
block|{
return|return
name|Arg
return|;
block|}
name|unsigned
name|getArg
argument_list|()
specifier|const
block|{
return|return
name|Arg
return|;
block|}
name|DIFlags
name|getFlags
argument_list|()
specifier|const
block|{
return|return
name|Flags
return|;
block|}
name|bool
name|isArtificial
argument_list|()
specifier|const
block|{
return|return
name|getFlags
argument_list|()
operator|&
name|FlagArtificial
return|;
block|}
name|bool
name|isObjectPointer
argument_list|()
specifier|const
block|{
return|return
name|getFlags
argument_list|()
operator|&
name|FlagObjectPointer
return|;
block|}
comment|/// Check that a location is valid for this variable.
comment|///
comment|/// Check that \c DL exists, is in the same subprogram, and has the same
comment|/// inlined-at location as \c this.  (Otherwise, it's not a valid attachment
comment|/// to a \a DbgInfoIntrinsic.)
name|bool
name|isValidLocationForIntrinsic
argument_list|(
argument|const DILocation *DL
argument_list|)
specifier|const
block|{
return|return
name|DL
operator|&&
name|getScope
argument_list|()
operator|->
name|getSubprogram
argument_list|()
operator|==
name|DL
operator|->
name|getScope
argument_list|()
operator|->
name|getSubprogram
argument_list|()
return|;
block|}
specifier|static
name|bool
name|classof
argument_list|(
argument|const Metadata *MD
argument_list|)
block|{
return|return
name|MD
operator|->
name|getMetadataID
argument_list|()
operator|==
name|DILocalVariableKind
return|;
block|}
expr|}
block|;
name|class
name|DIObjCProperty
operator|:
name|public
name|DINode
block|{
name|friend
name|class
name|LLVMContextImpl
block|;
name|friend
name|class
name|MDNode
block|;
name|unsigned
name|Line
block|;
name|unsigned
name|Attributes
block|;
name|DIObjCProperty
argument_list|(
argument|LLVMContext&C
argument_list|,
argument|StorageType Storage
argument_list|,
argument|unsigned Line
argument_list|,
argument|unsigned Attributes
argument_list|,
argument|ArrayRef<Metadata *> Ops
argument_list|)
operator|:
name|DINode
argument_list|(
name|C
argument_list|,
name|DIObjCPropertyKind
argument_list|,
name|Storage
argument_list|,
name|dwarf
operator|::
name|DW_TAG_APPLE_property
argument_list|,
name|Ops
argument_list|)
block|,
name|Line
argument_list|(
name|Line
argument_list|)
block|,
name|Attributes
argument_list|(
argument|Attributes
argument_list|)
block|{}
operator|~
name|DIObjCProperty
argument_list|()
operator|=
expr|default
block|;
specifier|static
name|DIObjCProperty
operator|*
name|getImpl
argument_list|(
argument|LLVMContext&Context
argument_list|,
argument|StringRef Name
argument_list|,
argument|DIFile *File
argument_list|,
argument|unsigned Line
argument_list|,
argument|StringRef GetterName
argument_list|,
argument|StringRef SetterName
argument_list|,
argument|unsigned Attributes
argument_list|,
argument|DITypeRef Type
argument_list|,
argument|StorageType Storage
argument_list|,
argument|bool ShouldCreate = true
argument_list|)
block|{
return|return
name|getImpl
argument_list|(
name|Context
argument_list|,
name|getCanonicalMDString
argument_list|(
name|Context
argument_list|,
name|Name
argument_list|)
argument_list|,
name|File
argument_list|,
name|Line
argument_list|,
name|getCanonicalMDString
argument_list|(
name|Context
argument_list|,
name|GetterName
argument_list|)
argument_list|,
name|getCanonicalMDString
argument_list|(
name|Context
argument_list|,
name|SetterName
argument_list|)
argument_list|,
name|Attributes
argument_list|,
name|Type
argument_list|,
name|Storage
argument_list|,
name|ShouldCreate
argument_list|)
return|;
block|}
specifier|static
name|DIObjCProperty
operator|*
name|getImpl
argument_list|(
argument|LLVMContext&Context
argument_list|,
argument|MDString *Name
argument_list|,
argument|Metadata *File
argument_list|,
argument|unsigned Line
argument_list|,
argument|MDString *GetterName
argument_list|,
argument|MDString *SetterName
argument_list|,
argument|unsigned Attributes
argument_list|,
argument|Metadata *Type
argument_list|,
argument|StorageType Storage
argument_list|,
argument|bool ShouldCreate = true
argument_list|)
block|;
name|TempDIObjCProperty
name|cloneImpl
argument_list|()
specifier|const
block|{
return|return
name|getTemporary
argument_list|(
name|getContext
argument_list|()
argument_list|,
name|getName
argument_list|()
argument_list|,
name|getFile
argument_list|()
argument_list|,
name|getLine
argument_list|()
argument_list|,
name|getGetterName
argument_list|()
argument_list|,
name|getSetterName
argument_list|()
argument_list|,
name|getAttributes
argument_list|()
argument_list|,
name|getType
argument_list|()
argument_list|)
return|;
block|}
name|public
operator|:
name|DEFINE_MDNODE_GET
argument_list|(
argument|DIObjCProperty
argument_list|,
argument|(StringRef Name, DIFile *File, unsigned Line,                      StringRef GetterName, StringRef SetterName,                      unsigned Attributes, DITypeRef Type)
argument_list|,
argument|(Name, File, Line, GetterName, SetterName, Attributes,                      Type)
argument_list|)
name|DEFINE_MDNODE_GET
argument_list|(
argument|DIObjCProperty
argument_list|,
argument|(MDString * Name, Metadata *File, unsigned Line,                      MDString *GetterName, MDString *SetterName,                      unsigned Attributes, Metadata *Type)
argument_list|,
argument|(Name, File, Line, GetterName, SetterName, Attributes,                      Type)
argument_list|)
name|TempDIObjCProperty
name|clone
argument_list|()
specifier|const
block|{
return|return
name|cloneImpl
argument_list|()
return|;
block|}
name|unsigned
name|getLine
argument_list|()
specifier|const
block|{
return|return
name|Line
return|;
block|}
name|unsigned
name|getAttributes
argument_list|()
specifier|const
block|{
return|return
name|Attributes
return|;
block|}
name|StringRef
name|getName
argument_list|()
specifier|const
block|{
return|return
name|getStringOperand
argument_list|(
literal|0
argument_list|)
return|;
block|}
name|DIFile
operator|*
name|getFile
argument_list|()
specifier|const
block|{
return|return
name|cast_or_null
operator|<
name|DIFile
operator|>
operator|(
name|getRawFile
argument_list|()
operator|)
return|;
block|}
name|StringRef
name|getGetterName
argument_list|()
specifier|const
block|{
return|return
name|getStringOperand
argument_list|(
literal|2
argument_list|)
return|;
block|}
name|StringRef
name|getSetterName
argument_list|()
specifier|const
block|{
return|return
name|getStringOperand
argument_list|(
literal|3
argument_list|)
return|;
block|}
name|DITypeRef
name|getType
argument_list|()
specifier|const
block|{
return|return
name|DITypeRef
argument_list|(
name|getRawType
argument_list|()
argument_list|)
return|;
block|}
name|StringRef
name|getFilename
argument_list|()
specifier|const
block|{
if|if
condition|(
name|auto
operator|*
name|F
operator|=
name|getFile
argument_list|()
condition|)
return|return
name|F
operator|->
name|getFilename
argument_list|()
return|;
return|return
literal|""
return|;
block|}
name|StringRef
name|getDirectory
argument_list|()
specifier|const
block|{
if|if
condition|(
name|auto
operator|*
name|F
operator|=
name|getFile
argument_list|()
condition|)
return|return
name|F
operator|->
name|getDirectory
argument_list|()
return|;
return|return
literal|""
return|;
block|}
name|MDString
operator|*
name|getRawName
argument_list|()
specifier|const
block|{
return|return
name|getOperandAs
operator|<
name|MDString
operator|>
operator|(
literal|0
operator|)
return|;
block|}
name|Metadata
operator|*
name|getRawFile
argument_list|()
specifier|const
block|{
return|return
name|getOperand
argument_list|(
literal|1
argument_list|)
return|;
block|}
name|MDString
operator|*
name|getRawGetterName
argument_list|()
specifier|const
block|{
return|return
name|getOperandAs
operator|<
name|MDString
operator|>
operator|(
literal|2
operator|)
return|;
block|}
name|MDString
operator|*
name|getRawSetterName
argument_list|()
specifier|const
block|{
return|return
name|getOperandAs
operator|<
name|MDString
operator|>
operator|(
literal|3
operator|)
return|;
block|}
name|Metadata
operator|*
name|getRawType
argument_list|()
specifier|const
block|{
return|return
name|getOperand
argument_list|(
literal|4
argument_list|)
return|;
block|}
specifier|static
name|bool
name|classof
argument_list|(
argument|const Metadata *MD
argument_list|)
block|{
return|return
name|MD
operator|->
name|getMetadataID
argument_list|()
operator|==
name|DIObjCPropertyKind
return|;
block|}
expr|}
block|;
comment|/// An imported module (C++ using directive or similar).
name|class
name|DIImportedEntity
operator|:
name|public
name|DINode
block|{
name|friend
name|class
name|LLVMContextImpl
block|;
name|friend
name|class
name|MDNode
block|;
name|unsigned
name|Line
block|;
name|DIImportedEntity
argument_list|(
argument|LLVMContext&C
argument_list|,
argument|StorageType Storage
argument_list|,
argument|unsigned Tag
argument_list|,
argument|unsigned Line
argument_list|,
argument|ArrayRef<Metadata *> Ops
argument_list|)
operator|:
name|DINode
argument_list|(
name|C
argument_list|,
name|DIImportedEntityKind
argument_list|,
name|Storage
argument_list|,
name|Tag
argument_list|,
name|Ops
argument_list|)
block|,
name|Line
argument_list|(
argument|Line
argument_list|)
block|{}
operator|~
name|DIImportedEntity
argument_list|()
operator|=
expr|default
block|;
specifier|static
name|DIImportedEntity
operator|*
name|getImpl
argument_list|(
argument|LLVMContext&Context
argument_list|,
argument|unsigned Tag
argument_list|,
argument|DIScope *Scope
argument_list|,
argument|DINodeRef Entity
argument_list|,
argument|unsigned Line
argument_list|,
argument|StringRef Name
argument_list|,
argument|StorageType Storage
argument_list|,
argument|bool ShouldCreate = true
argument_list|)
block|{
return|return
name|getImpl
argument_list|(
name|Context
argument_list|,
name|Tag
argument_list|,
name|Scope
argument_list|,
name|Entity
argument_list|,
name|Line
argument_list|,
name|getCanonicalMDString
argument_list|(
name|Context
argument_list|,
name|Name
argument_list|)
argument_list|,
name|Storage
argument_list|,
name|ShouldCreate
argument_list|)
return|;
block|}
specifier|static
name|DIImportedEntity
operator|*
name|getImpl
argument_list|(
argument|LLVMContext&Context
argument_list|,
argument|unsigned Tag
argument_list|,
argument|Metadata *Scope
argument_list|,
argument|Metadata *Entity
argument_list|,
argument|unsigned Line
argument_list|,
argument|MDString *Name
argument_list|,
argument|StorageType Storage
argument_list|,
argument|bool ShouldCreate = true
argument_list|)
block|;
name|TempDIImportedEntity
name|cloneImpl
argument_list|()
specifier|const
block|{
return|return
name|getTemporary
argument_list|(
name|getContext
argument_list|()
argument_list|,
name|getTag
argument_list|()
argument_list|,
name|getScope
argument_list|()
argument_list|,
name|getEntity
argument_list|()
argument_list|,
name|getLine
argument_list|()
argument_list|,
name|getName
argument_list|()
argument_list|)
return|;
block|}
name|public
operator|:
name|DEFINE_MDNODE_GET
argument_list|(
argument|DIImportedEntity
argument_list|,
argument|(unsigned Tag, DIScope *Scope, DINodeRef Entity,                      unsigned Line, StringRef Name =
literal|""
argument|)
argument_list|,
argument|(Tag, Scope, Entity, Line, Name)
argument_list|)
name|DEFINE_MDNODE_GET
argument_list|(
argument|DIImportedEntity
argument_list|,
argument|(unsigned Tag, Metadata *Scope, Metadata *Entity,                      unsigned Line, MDString *Name)
argument_list|,
argument|(Tag, Scope, Entity, Line, Name)
argument_list|)
name|TempDIImportedEntity
name|clone
argument_list|()
specifier|const
block|{
return|return
name|cloneImpl
argument_list|()
return|;
block|}
name|unsigned
name|getLine
argument_list|()
specifier|const
block|{
return|return
name|Line
return|;
block|}
name|DIScope
operator|*
name|getScope
argument_list|()
specifier|const
block|{
return|return
name|cast_or_null
operator|<
name|DIScope
operator|>
operator|(
name|getRawScope
argument_list|()
operator|)
return|;
block|}
name|DINodeRef
name|getEntity
argument_list|()
specifier|const
block|{
return|return
name|DINodeRef
argument_list|(
name|getRawEntity
argument_list|()
argument_list|)
return|;
block|}
name|StringRef
name|getName
argument_list|()
specifier|const
block|{
return|return
name|getStringOperand
argument_list|(
literal|2
argument_list|)
return|;
block|}
name|Metadata
operator|*
name|getRawScope
argument_list|()
specifier|const
block|{
return|return
name|getOperand
argument_list|(
literal|0
argument_list|)
return|;
block|}
name|Metadata
operator|*
name|getRawEntity
argument_list|()
specifier|const
block|{
return|return
name|getOperand
argument_list|(
literal|1
argument_list|)
return|;
block|}
name|MDString
operator|*
name|getRawName
argument_list|()
specifier|const
block|{
return|return
name|getOperandAs
operator|<
name|MDString
operator|>
operator|(
literal|2
operator|)
return|;
block|}
specifier|static
name|bool
name|classof
argument_list|(
argument|const Metadata *MD
argument_list|)
block|{
return|return
name|MD
operator|->
name|getMetadataID
argument_list|()
operator|==
name|DIImportedEntityKind
return|;
block|}
expr|}
block|;
comment|/// A pair of DIGlobalVariable and DIExpression.
name|class
name|DIGlobalVariableExpression
operator|:
name|public
name|MDNode
block|{
name|friend
name|class
name|LLVMContextImpl
block|;
name|friend
name|class
name|MDNode
block|;
name|DIGlobalVariableExpression
argument_list|(
argument|LLVMContext&C
argument_list|,
argument|StorageType Storage
argument_list|,
argument|ArrayRef<Metadata *> Ops
argument_list|)
operator|:
name|MDNode
argument_list|(
argument|C
argument_list|,
argument|DIGlobalVariableExpressionKind
argument_list|,
argument|Storage
argument_list|,
argument|Ops
argument_list|)
block|{}
operator|~
name|DIGlobalVariableExpression
argument_list|()
operator|=
expr|default
block|;
specifier|static
name|DIGlobalVariableExpression
operator|*
name|getImpl
argument_list|(
argument|LLVMContext&Context
argument_list|,
argument|Metadata *Variable
argument_list|,
argument|Metadata *Expression
argument_list|,
argument|StorageType Storage
argument_list|,
argument|bool ShouldCreate = true
argument_list|)
block|;
name|TempDIGlobalVariableExpression
name|cloneImpl
argument_list|()
specifier|const
block|{
return|return
name|getTemporary
argument_list|(
name|getContext
argument_list|()
argument_list|,
name|getVariable
argument_list|()
argument_list|,
name|getExpression
argument_list|()
argument_list|)
return|;
block|}
name|public
operator|:
name|DEFINE_MDNODE_GET
argument_list|(
argument|DIGlobalVariableExpression
argument_list|,
argument|(Metadata * Variable, Metadata *Expression)
argument_list|,
argument|(Variable, Expression)
argument_list|)
name|TempDIGlobalVariableExpression
name|clone
argument_list|()
specifier|const
block|{
return|return
name|cloneImpl
argument_list|()
return|;
block|}
name|Metadata
operator|*
name|getRawVariable
argument_list|()
specifier|const
block|{
return|return
name|getOperand
argument_list|(
literal|0
argument_list|)
return|;
block|}
name|DIGlobalVariable
operator|*
name|getVariable
argument_list|()
specifier|const
block|{
return|return
name|cast_or_null
operator|<
name|DIGlobalVariable
operator|>
operator|(
name|getRawVariable
argument_list|()
operator|)
return|;
block|}
name|Metadata
operator|*
name|getRawExpression
argument_list|()
specifier|const
block|{
return|return
name|getOperand
argument_list|(
literal|1
argument_list|)
return|;
block|}
name|DIExpression
operator|*
name|getExpression
argument_list|()
specifier|const
block|{
return|return
name|cast_or_null
operator|<
name|DIExpression
operator|>
operator|(
name|getRawExpression
argument_list|()
operator|)
return|;
block|}
specifier|static
name|bool
name|classof
argument_list|(
argument|const Metadata *MD
argument_list|)
block|{
return|return
name|MD
operator|->
name|getMetadataID
argument_list|()
operator|==
name|DIGlobalVariableExpressionKind
return|;
block|}
expr|}
block|;
comment|/// Macro Info DWARF-like metadata node.
comment|///
comment|/// A metadata node with a DWARF macro info (i.e., a constant named
comment|/// \c DW_MACINFO_*, defined in llvm/Support/Dwarf.h).  Called \a DIMacroNode
comment|/// because it's potentially used for non-DWARF output.
name|class
name|DIMacroNode
operator|:
name|public
name|MDNode
block|{
name|friend
name|class
name|LLVMContextImpl
block|;
name|friend
name|class
name|MDNode
block|;
name|protected
operator|:
name|DIMacroNode
argument_list|(
argument|LLVMContext&C
argument_list|,
argument|unsigned ID
argument_list|,
argument|StorageType Storage
argument_list|,
argument|unsigned MIType
argument_list|,
argument|ArrayRef<Metadata *> Ops1
argument_list|,
argument|ArrayRef<Metadata *> Ops2 = None
argument_list|)
operator|:
name|MDNode
argument_list|(
argument|C
argument_list|,
argument|ID
argument_list|,
argument|Storage
argument_list|,
argument|Ops1
argument_list|,
argument|Ops2
argument_list|)
block|{
name|assert
argument_list|(
name|MIType
operator|<
literal|1u
operator|<<
literal|16
argument_list|)
block|;
name|SubclassData16
operator|=
name|MIType
block|;   }
operator|~
name|DIMacroNode
argument_list|()
operator|=
expr|default
block|;
name|template
operator|<
name|class
name|Ty
operator|>
name|Ty
operator|*
name|getOperandAs
argument_list|(
argument|unsigned I
argument_list|)
specifier|const
block|{
return|return
name|cast_or_null
operator|<
name|Ty
operator|>
operator|(
name|getOperand
argument_list|(
name|I
argument_list|)
operator|)
return|;
block|}
name|StringRef
name|getStringOperand
argument_list|(
argument|unsigned I
argument_list|)
specifier|const
block|{
if|if
condition|(
name|auto
operator|*
name|S
operator|=
name|getOperandAs
operator|<
name|MDString
operator|>
operator|(
name|I
operator|)
condition|)
return|return
name|S
operator|->
name|getString
argument_list|()
return|;
return|return
name|StringRef
argument_list|()
return|;
block|}
specifier|static
name|MDString
operator|*
name|getCanonicalMDString
argument_list|(
argument|LLVMContext&Context
argument_list|,
argument|StringRef S
argument_list|)
block|{
if|if
condition|(
name|S
operator|.
name|empty
argument_list|()
condition|)
return|return
name|nullptr
return|;
return|return
name|MDString
operator|::
name|get
argument_list|(
name|Context
argument_list|,
name|S
argument_list|)
return|;
block|}
name|public
operator|:
name|unsigned
name|getMacinfoType
argument_list|()
specifier|const
block|{
return|return
name|SubclassData16
return|;
block|}
specifier|static
name|bool
name|classof
argument_list|(
argument|const Metadata *MD
argument_list|)
block|{
switch|switch
condition|(
name|MD
operator|->
name|getMetadataID
argument_list|()
condition|)
block|{
default|default:
return|return
name|false
return|;
case|case
name|DIMacroKind
case|:
case|case
name|DIMacroFileKind
case|:
return|return
name|true
return|;
block|}
block|}
expr|}
block|;
name|class
name|DIMacro
operator|:
name|public
name|DIMacroNode
block|{
name|friend
name|class
name|LLVMContextImpl
block|;
name|friend
name|class
name|MDNode
block|;
name|unsigned
name|Line
block|;
name|DIMacro
argument_list|(
argument|LLVMContext&C
argument_list|,
argument|StorageType Storage
argument_list|,
argument|unsigned MIType
argument_list|,
argument|unsigned Line
argument_list|,
argument|ArrayRef<Metadata *> Ops
argument_list|)
operator|:
name|DIMacroNode
argument_list|(
name|C
argument_list|,
name|DIMacroKind
argument_list|,
name|Storage
argument_list|,
name|MIType
argument_list|,
name|Ops
argument_list|)
block|,
name|Line
argument_list|(
argument|Line
argument_list|)
block|{}
operator|~
name|DIMacro
argument_list|()
operator|=
expr|default
block|;
specifier|static
name|DIMacro
operator|*
name|getImpl
argument_list|(
argument|LLVMContext&Context
argument_list|,
argument|unsigned MIType
argument_list|,
argument|unsigned Line
argument_list|,
argument|StringRef Name
argument_list|,
argument|StringRef Value
argument_list|,
argument|StorageType Storage
argument_list|,
argument|bool ShouldCreate = true
argument_list|)
block|{
return|return
name|getImpl
argument_list|(
name|Context
argument_list|,
name|MIType
argument_list|,
name|Line
argument_list|,
name|getCanonicalMDString
argument_list|(
name|Context
argument_list|,
name|Name
argument_list|)
argument_list|,
name|getCanonicalMDString
argument_list|(
name|Context
argument_list|,
name|Value
argument_list|)
argument_list|,
name|Storage
argument_list|,
name|ShouldCreate
argument_list|)
return|;
block|}
specifier|static
name|DIMacro
operator|*
name|getImpl
argument_list|(
argument|LLVMContext&Context
argument_list|,
argument|unsigned MIType
argument_list|,
argument|unsigned Line
argument_list|,
argument|MDString *Name
argument_list|,
argument|MDString *Value
argument_list|,
argument|StorageType Storage
argument_list|,
argument|bool ShouldCreate = true
argument_list|)
block|;
name|TempDIMacro
name|cloneImpl
argument_list|()
specifier|const
block|{
return|return
name|getTemporary
argument_list|(
name|getContext
argument_list|()
argument_list|,
name|getMacinfoType
argument_list|()
argument_list|,
name|getLine
argument_list|()
argument_list|,
name|getName
argument_list|()
argument_list|,
name|getValue
argument_list|()
argument_list|)
return|;
block|}
name|public
operator|:
name|DEFINE_MDNODE_GET
argument_list|(
argument|DIMacro
argument_list|,
argument|(unsigned MIType, unsigned Line, StringRef Name,                               StringRef Value =
literal|""
argument|)
argument_list|,
argument|(MIType, Line, Name, Value)
argument_list|)
name|DEFINE_MDNODE_GET
argument_list|(
argument|DIMacro
argument_list|,
argument|(unsigned MIType, unsigned Line, MDString *Name,                               MDString *Value)
argument_list|,
argument|(MIType, Line, Name, Value)
argument_list|)
name|TempDIMacro
name|clone
argument_list|()
specifier|const
block|{
return|return
name|cloneImpl
argument_list|()
return|;
block|}
name|unsigned
name|getLine
argument_list|()
specifier|const
block|{
return|return
name|Line
return|;
block|}
name|StringRef
name|getName
argument_list|()
specifier|const
block|{
return|return
name|getStringOperand
argument_list|(
literal|0
argument_list|)
return|;
block|}
name|StringRef
name|getValue
argument_list|()
specifier|const
block|{
return|return
name|getStringOperand
argument_list|(
literal|1
argument_list|)
return|;
block|}
name|MDString
operator|*
name|getRawName
argument_list|()
specifier|const
block|{
return|return
name|getOperandAs
operator|<
name|MDString
operator|>
operator|(
literal|0
operator|)
return|;
block|}
name|MDString
operator|*
name|getRawValue
argument_list|()
specifier|const
block|{
return|return
name|getOperandAs
operator|<
name|MDString
operator|>
operator|(
literal|1
operator|)
return|;
block|}
specifier|static
name|bool
name|classof
argument_list|(
argument|const Metadata *MD
argument_list|)
block|{
return|return
name|MD
operator|->
name|getMetadataID
argument_list|()
operator|==
name|DIMacroKind
return|;
block|}
expr|}
block|;
name|class
name|DIMacroFile
operator|:
name|public
name|DIMacroNode
block|{
name|friend
name|class
name|LLVMContextImpl
block|;
name|friend
name|class
name|MDNode
block|;
name|unsigned
name|Line
block|;
name|DIMacroFile
argument_list|(
argument|LLVMContext&C
argument_list|,
argument|StorageType Storage
argument_list|,
argument|unsigned MIType
argument_list|,
argument|unsigned Line
argument_list|,
argument|ArrayRef<Metadata *> Ops
argument_list|)
operator|:
name|DIMacroNode
argument_list|(
name|C
argument_list|,
name|DIMacroFileKind
argument_list|,
name|Storage
argument_list|,
name|MIType
argument_list|,
name|Ops
argument_list|)
block|,
name|Line
argument_list|(
argument|Line
argument_list|)
block|{}
operator|~
name|DIMacroFile
argument_list|()
operator|=
expr|default
block|;
specifier|static
name|DIMacroFile
operator|*
name|getImpl
argument_list|(
argument|LLVMContext&Context
argument_list|,
argument|unsigned MIType
argument_list|,
argument|unsigned Line
argument_list|,
argument|DIFile *File
argument_list|,
argument|DIMacroNodeArray Elements
argument_list|,
argument|StorageType Storage
argument_list|,
argument|bool ShouldCreate = true
argument_list|)
block|{
return|return
name|getImpl
argument_list|(
name|Context
argument_list|,
name|MIType
argument_list|,
name|Line
argument_list|,
name|static_cast
operator|<
name|Metadata
operator|*
operator|>
operator|(
name|File
operator|)
argument_list|,
name|Elements
operator|.
name|get
argument_list|()
argument_list|,
name|Storage
argument_list|,
name|ShouldCreate
argument_list|)
return|;
block|}
specifier|static
name|DIMacroFile
operator|*
name|getImpl
argument_list|(
argument|LLVMContext&Context
argument_list|,
argument|unsigned MIType
argument_list|,
argument|unsigned Line
argument_list|,
argument|Metadata *File
argument_list|,
argument|Metadata *Elements
argument_list|,
argument|StorageType Storage
argument_list|,
argument|bool ShouldCreate = true
argument_list|)
block|;
name|TempDIMacroFile
name|cloneImpl
argument_list|()
specifier|const
block|{
return|return
name|getTemporary
argument_list|(
name|getContext
argument_list|()
argument_list|,
name|getMacinfoType
argument_list|()
argument_list|,
name|getLine
argument_list|()
argument_list|,
name|getFile
argument_list|()
argument_list|,
name|getElements
argument_list|()
argument_list|)
return|;
block|}
name|public
operator|:
name|DEFINE_MDNODE_GET
argument_list|(
argument|DIMacroFile
argument_list|,
argument|(unsigned MIType, unsigned Line, DIFile *File,                                   DIMacroNodeArray Elements)
argument_list|,
argument|(MIType, Line, File, Elements)
argument_list|)
name|DEFINE_MDNODE_GET
argument_list|(
argument|DIMacroFile
argument_list|,
argument|(unsigned MIType, unsigned Line,                                   Metadata *File, Metadata *Elements)
argument_list|,
argument|(MIType, Line, File, Elements)
argument_list|)
name|TempDIMacroFile
name|clone
argument_list|()
specifier|const
block|{
return|return
name|cloneImpl
argument_list|()
return|;
block|}
name|void
name|replaceElements
argument_list|(
argument|DIMacroNodeArray Elements
argument_list|)
block|{
ifndef|#
directive|ifndef
name|NDEBUG
for|for
control|(
name|DIMacroNode
modifier|*
name|Op
range|:
name|getElements
argument_list|()
control|)
name|assert
argument_list|(
name|is_contained
argument_list|(
name|Elements
operator|->
name|operands
argument_list|()
argument_list|,
name|Op
argument_list|)
operator|&&
literal|"Lost a macro node during macro node list replacement"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|replaceOperandWith
argument_list|(
literal|1
argument_list|,
name|Elements
operator|.
name|get
argument_list|()
argument_list|)
block|;   }
name|unsigned
name|getLine
argument_list|()
specifier|const
block|{
return|return
name|Line
return|;
block|}
name|DIFile
operator|*
name|getFile
argument_list|()
specifier|const
block|{
return|return
name|cast_or_null
operator|<
name|DIFile
operator|>
operator|(
name|getRawFile
argument_list|()
operator|)
return|;
block|}
name|DIMacroNodeArray
name|getElements
argument_list|()
specifier|const
block|{
return|return
name|cast_or_null
operator|<
name|MDTuple
operator|>
operator|(
name|getRawElements
argument_list|()
operator|)
return|;
block|}
name|Metadata
operator|*
name|getRawFile
argument_list|()
specifier|const
block|{
return|return
name|getOperand
argument_list|(
literal|0
argument_list|)
return|;
block|}
name|Metadata
operator|*
name|getRawElements
argument_list|()
specifier|const
block|{
return|return
name|getOperand
argument_list|(
literal|1
argument_list|)
return|;
block|}
specifier|static
name|bool
name|classof
argument_list|(
argument|const Metadata *MD
argument_list|)
block|{
return|return
name|MD
operator|->
name|getMetadataID
argument_list|()
operator|==
name|DIMacroFileKind
return|;
block|}
expr|}
block|;  }
end_decl_stmt

begin_comment
comment|// end namespace llvm
end_comment

begin_undef
undef|#
directive|undef
name|DEFINE_MDNODE_GET_UNPACK_IMPL
end_undef

begin_undef
undef|#
directive|undef
name|DEFINE_MDNODE_GET_UNPACK
end_undef

begin_undef
undef|#
directive|undef
name|DEFINE_MDNODE_GET
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|// LLVM_IR_DEBUGINFOMETADATA_H
end_comment

end_unit

