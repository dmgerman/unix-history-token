begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===- llvm/Analysis/LoopInfo.h - Natural Loop Calculator -------*- C++ -*-===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file defines the LoopInfo class that is used to identify natural loops
end_comment

begin_comment
comment|// and determine the loop depth of various nodes of the CFG.  A natural loop
end_comment

begin_comment
comment|// has exactly one entry-point, which is called the header. Note that natural
end_comment

begin_comment
comment|// loops may actually be several loops that share the same header node.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This analysis calculates the nesting structure of loops in a function.  For
end_comment

begin_comment
comment|// each natural loop identified, this analysis identifies natural loops
end_comment

begin_comment
comment|// contained entirely within the loop and the basic blocks the make up the loop.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// It can calculate on the fly various bits of information, for example:
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//  * whether there is a preheader for the loop
end_comment

begin_comment
comment|//  * the number of back edges to the header
end_comment

begin_comment
comment|//  * whether or not a particular block branches out of the loop
end_comment

begin_comment
comment|//  * the successor blocks of the loop
end_comment

begin_comment
comment|//  * the loop depth
end_comment

begin_comment
comment|//  * the trip count
end_comment

begin_comment
comment|//  * etc...
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LLVM_ANALYSIS_LOOP_INFO_H
end_ifndef

begin_define
define|#
directive|define
name|LLVM_ANALYSIS_LOOP_INFO_H
end_define

begin_include
include|#
directive|include
file|"llvm/Pass.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/DepthFirstIterator.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/GraphTraits.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/SmallVector.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Analysis/Dominators.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/CFG.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/raw_ostream.h"
end_include

begin_include
include|#
directive|include
file|<algorithm>
end_include

begin_decl_stmt
name|namespace
name|llvm
block|{
name|template
operator|<
name|typename
name|T
operator|>
specifier|static
name|void
name|RemoveFromVector
argument_list|(
argument|std::vector<T*>&V
argument_list|,
argument|T *N
argument_list|)
block|{
name|typename
name|std
operator|::
name|vector
operator|<
name|T
operator|*
operator|>
operator|::
name|iterator
name|I
operator|=
name|std
operator|::
name|find
argument_list|(
name|V
operator|.
name|begin
argument_list|()
argument_list|,
name|V
operator|.
name|end
argument_list|()
argument_list|,
name|N
argument_list|)
block|;
name|assert
argument_list|(
name|I
operator|!=
name|V
operator|.
name|end
argument_list|()
operator|&&
literal|"N is not in this list!"
argument_list|)
block|;
name|V
operator|.
name|erase
argument_list|(
name|I
argument_list|)
block|; }
name|class
name|DominatorTree
expr_stmt|;
name|class
name|LoopInfo
decl_stmt|;
name|class
name|Loop
decl_stmt|;
name|template
operator|<
name|class
name|N
operator|,
name|class
name|M
operator|>
name|class
name|LoopInfoBase
expr_stmt|;
name|template
operator|<
name|class
name|N
operator|,
name|class
name|M
operator|>
name|class
name|LoopBase
expr_stmt|;
comment|//===----------------------------------------------------------------------===//
comment|/// LoopBase class - Instances of this class are used to represent loops that
comment|/// are detected in the flow graph
comment|///
name|template
operator|<
name|class
name|BlockT
operator|,
name|class
name|LoopT
operator|>
name|class
name|LoopBase
block|{
name|LoopT
operator|*
name|ParentLoop
block|;
comment|// SubLoops - Loops contained entirely within this one.
name|std
operator|::
name|vector
operator|<
name|LoopT
operator|*
operator|>
name|SubLoops
block|;
comment|// Blocks - The list of blocks in this loop.  First entry is the header node.
name|std
operator|::
name|vector
operator|<
name|BlockT
operator|*
operator|>
name|Blocks
block|;
comment|// DO NOT IMPLEMENT
name|LoopBase
argument_list|(
specifier|const
name|LoopBase
operator|<
name|BlockT
argument_list|,
name|LoopT
operator|>
operator|&
argument_list|)
block|;
comment|// DO NOT IMPLEMENT
specifier|const
name|LoopBase
operator|<
name|BlockT
block|,
name|LoopT
operator|>
operator|&
name|operator
operator|=
operator|(
specifier|const
name|LoopBase
operator|<
name|BlockT
operator|,
name|LoopT
operator|>
operator|&
operator|)
block|;
name|public
operator|:
comment|/// Loop ctor - This creates an empty loop.
name|LoopBase
argument_list|()
operator|:
name|ParentLoop
argument_list|(
literal|0
argument_list|)
block|{}
operator|~
name|LoopBase
argument_list|()
block|{
for|for
control|(
name|size_t
name|i
init|=
literal|0
init|,
name|e
init|=
name|SubLoops
operator|.
name|size
argument_list|()
init|;
name|i
operator|!=
name|e
condition|;
operator|++
name|i
control|)
name|delete
name|SubLoops
index|[
name|i
index|]
decl_stmt|;
block|}
comment|/// getLoopDepth - Return the nesting level of this loop.  An outer-most
comment|/// loop has depth 1, for consistency with loop depth values used for basic
comment|/// blocks, where depth 0 is used for blocks not inside any loops.
name|unsigned
name|getLoopDepth
argument_list|()
specifier|const
block|{
name|unsigned
name|D
operator|=
literal|1
block|;
for|for
control|(
specifier|const
name|LoopT
modifier|*
name|CurLoop
init|=
name|ParentLoop
init|;
name|CurLoop
condition|;
name|CurLoop
operator|=
name|CurLoop
operator|->
name|ParentLoop
control|)
operator|++
name|D
expr_stmt|;
return|return
name|D
return|;
block|}
name|BlockT
operator|*
name|getHeader
argument_list|()
specifier|const
block|{
return|return
name|Blocks
operator|.
name|front
argument_list|()
return|;
block|}
name|LoopT
operator|*
name|getParentLoop
argument_list|()
specifier|const
block|{
return|return
name|ParentLoop
return|;
block|}
comment|/// contains - Return true if the specified loop is contained within in
comment|/// this loop.
comment|///
name|bool
name|contains
argument_list|(
specifier|const
name|LoopT
operator|*
name|L
argument_list|)
decl|const
block|{
if|if
condition|(
name|L
operator|==
name|this
condition|)
return|return
name|true
return|;
if|if
condition|(
name|L
operator|==
literal|0
condition|)
return|return
name|false
return|;
return|return
name|contains
argument_list|(
name|L
operator|->
name|getParentLoop
argument_list|()
argument_list|)
return|;
block|}
comment|/// contains - Return true if the specified basic block is in this loop.
comment|///
name|bool
name|contains
argument_list|(
specifier|const
name|BlockT
operator|*
name|BB
argument_list|)
decl|const
block|{
return|return
name|std
operator|::
name|find
argument_list|(
name|block_begin
argument_list|()
argument_list|,
name|block_end
argument_list|()
argument_list|,
name|BB
argument_list|)
operator|!=
name|block_end
argument_list|()
return|;
block|}
comment|/// contains - Return true if the specified instruction is in this loop.
comment|///
name|template
operator|<
name|class
name|InstT
operator|>
name|bool
name|contains
argument_list|(
argument|const InstT *Inst
argument_list|)
specifier|const
block|{
return|return
name|contains
argument_list|(
name|Inst
operator|->
name|getParent
argument_list|()
argument_list|)
return|;
block|}
comment|/// iterator/begin/end - Return the loops contained entirely within this loop.
comment|///
specifier|const
name|std
operator|::
name|vector
operator|<
name|LoopT
operator|*
operator|>
operator|&
name|getSubLoops
argument_list|()
specifier|const
block|{
return|return
name|SubLoops
return|;
block|}
typedef|typedef
name|typename
name|std
operator|::
name|vector
operator|<
name|LoopT
operator|*
operator|>
operator|::
name|const_iterator
name|iterator
expr_stmt|;
name|iterator
name|begin
argument_list|()
specifier|const
block|{
return|return
name|SubLoops
operator|.
name|begin
argument_list|()
return|;
block|}
name|iterator
name|end
argument_list|()
specifier|const
block|{
return|return
name|SubLoops
operator|.
name|end
argument_list|()
return|;
block|}
name|bool
name|empty
argument_list|()
specifier|const
block|{
return|return
name|SubLoops
operator|.
name|empty
argument_list|()
return|;
block|}
comment|/// getBlocks - Get a list of the basic blocks which make up this loop.
comment|///
specifier|const
name|std
operator|::
name|vector
operator|<
name|BlockT
operator|*
operator|>
operator|&
name|getBlocks
argument_list|()
specifier|const
block|{
return|return
name|Blocks
return|;
block|}
typedef|typedef
name|typename
name|std
operator|::
name|vector
operator|<
name|BlockT
operator|*
operator|>
operator|::
name|const_iterator
name|block_iterator
expr_stmt|;
name|block_iterator
name|block_begin
argument_list|()
specifier|const
block|{
return|return
name|Blocks
operator|.
name|begin
argument_list|()
return|;
block|}
name|block_iterator
name|block_end
argument_list|()
specifier|const
block|{
return|return
name|Blocks
operator|.
name|end
argument_list|()
return|;
block|}
comment|/// isLoopExiting - True if terminator in the block can branch to another
comment|/// block that is outside of the current loop.
comment|///
name|bool
name|isLoopExiting
argument_list|(
specifier|const
name|BlockT
operator|*
name|BB
argument_list|)
decl|const
block|{
typedef|typedef
name|GraphTraits
operator|<
name|BlockT
operator|*
operator|>
name|BlockTraits
expr_stmt|;
for|for
control|(
name|typename
name|BlockTraits
operator|::
name|ChildIteratorType
name|SI
operator|=
name|BlockTraits
operator|::
name|child_begin
argument_list|(
name|const_cast
operator|<
name|BlockT
operator|*
operator|>
operator|(
name|BB
operator|)
argument_list|)
operator|,
name|SE
operator|=
name|BlockTraits
operator|::
name|child_end
argument_list|(
name|const_cast
operator|<
name|BlockT
operator|*
operator|>
operator|(
name|BB
operator|)
argument_list|)
init|;
name|SI
operator|!=
name|SE
condition|;
operator|++
name|SI
control|)
block|{
if|if
condition|(
operator|!
name|contains
argument_list|(
operator|*
name|SI
argument_list|)
condition|)
return|return
name|true
return|;
block|}
return|return
name|false
return|;
block|}
comment|/// getNumBackEdges - Calculate the number of back edges to the loop header
comment|///
name|unsigned
name|getNumBackEdges
argument_list|()
specifier|const
block|{
name|unsigned
name|NumBackEdges
operator|=
literal|0
block|;
name|BlockT
operator|*
name|H
operator|=
name|getHeader
argument_list|()
block|;
typedef|typedef
name|GraphTraits
operator|<
name|Inverse
operator|<
name|BlockT
operator|*
operator|>
expr|>
name|InvBlockTraits
expr_stmt|;
for|for
control|(
name|typename
name|InvBlockTraits
operator|::
name|ChildIteratorType
name|I
operator|=
name|InvBlockTraits
operator|::
name|child_begin
argument_list|(
name|const_cast
operator|<
name|BlockT
operator|*
operator|>
operator|(
name|H
operator|)
argument_list|)
operator|,
name|E
operator|=
name|InvBlockTraits
operator|::
name|child_end
argument_list|(
name|const_cast
operator|<
name|BlockT
operator|*
operator|>
operator|(
name|H
operator|)
argument_list|)
init|;
name|I
operator|!=
name|E
condition|;
operator|++
name|I
control|)
if|if
condition|(
name|contains
argument_list|(
operator|*
name|I
argument_list|)
condition|)
operator|++
name|NumBackEdges
expr_stmt|;
return|return
name|NumBackEdges
return|;
block|}
end_decl_stmt

begin_comment
comment|//===--------------------------------------------------------------------===//
end_comment

begin_comment
comment|// APIs for simple analysis of the loop.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// Note that all of these methods can fail on general loops (ie, there may not
end_comment

begin_comment
comment|// be a preheader, etc).  For best success, the loop simplification and
end_comment

begin_comment
comment|// induction variable canonicalization pass should be used to normalize loops
end_comment

begin_comment
comment|// for easy analysis.  These methods assume canonical loops.
end_comment

begin_comment
comment|/// getExitingBlocks - Return all blocks inside the loop that have successors
end_comment

begin_comment
comment|/// outside of the loop.  These are the blocks _inside of the current loop_
end_comment

begin_comment
comment|/// which branch out.  The returned list is always unique.
end_comment

begin_comment
comment|///
end_comment

begin_decl_stmt
name|void
name|getExitingBlocks
argument_list|(
name|SmallVectorImpl
operator|<
name|BlockT
operator|*
operator|>
operator|&
name|ExitingBlocks
argument_list|)
decl|const
block|{
comment|// Sort the blocks vector so that we can use binary search to do quick
comment|// lookups.
name|SmallVector
operator|<
name|BlockT
operator|*
operator|,
literal|128
operator|>
name|LoopBBs
argument_list|(
name|block_begin
argument_list|()
argument_list|,
name|block_end
argument_list|()
argument_list|)
expr_stmt|;
name|std
operator|::
name|sort
argument_list|(
name|LoopBBs
operator|.
name|begin
argument_list|()
argument_list|,
name|LoopBBs
operator|.
name|end
argument_list|()
argument_list|)
expr_stmt|;
typedef|typedef
name|GraphTraits
operator|<
name|BlockT
operator|*
operator|>
name|BlockTraits
expr_stmt|;
for|for
control|(
name|block_iterator
name|BI
init|=
name|block_begin
argument_list|()
init|,
name|BE
init|=
name|block_end
argument_list|()
init|;
name|BI
operator|!=
name|BE
condition|;
operator|++
name|BI
control|)
for|for
control|(
name|typename
name|BlockTraits
operator|::
name|ChildIteratorType
name|I
operator|=
name|BlockTraits
operator|::
name|child_begin
argument_list|(
operator|*
name|BI
argument_list|)
operator|,
name|E
operator|=
name|BlockTraits
operator|::
name|child_end
argument_list|(
operator|*
name|BI
argument_list|)
init|;
name|I
operator|!=
name|E
condition|;
operator|++
name|I
control|)
if|if
condition|(
operator|!
name|std
operator|::
name|binary_search
argument_list|(
name|LoopBBs
operator|.
name|begin
argument_list|()
argument_list|,
name|LoopBBs
operator|.
name|end
argument_list|()
argument_list|,
operator|*
name|I
argument_list|)
condition|)
block|{
comment|// Not in current loop? It must be an exit block.
name|ExitingBlocks
operator|.
name|push_back
argument_list|(
operator|*
name|BI
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_decl_stmt

begin_comment
comment|/// getExitingBlock - If getExitingBlocks would return exactly one block,
end_comment

begin_comment
comment|/// return that block. Otherwise return null.
end_comment

begin_expr_stmt
name|BlockT
operator|*
name|getExitingBlock
argument_list|()
specifier|const
block|{
name|SmallVector
operator|<
name|BlockT
operator|*
block|,
literal|8
operator|>
name|ExitingBlocks
block|;
name|getExitingBlocks
argument_list|(
name|ExitingBlocks
argument_list|)
block|;
if|if
condition|(
name|ExitingBlocks
operator|.
name|size
argument_list|()
operator|==
literal|1
condition|)
return|return
name|ExitingBlocks
index|[
literal|0
index|]
return|;
end_expr_stmt

begin_return
return|return
literal|0
return|;
end_return

begin_comment
unit|}
comment|/// getExitBlocks - Return all of the successor blocks of this loop.  These
end_comment

begin_comment
comment|/// are the blocks _outside of the current loop_ which are branched to.
end_comment

begin_comment
comment|///
end_comment

begin_macro
unit|void
name|getExitBlocks
argument_list|(
argument|SmallVectorImpl<BlockT*>&ExitBlocks
argument_list|)
end_macro

begin_expr_stmt
specifier|const
block|{
comment|// Sort the blocks vector so that we can use binary search to do quick
comment|// lookups.
name|SmallVector
operator|<
name|BlockT
operator|*
block|,
literal|128
operator|>
name|LoopBBs
argument_list|(
name|block_begin
argument_list|()
argument_list|,
name|block_end
argument_list|()
argument_list|)
block|;
name|std
operator|::
name|sort
argument_list|(
name|LoopBBs
operator|.
name|begin
argument_list|()
argument_list|,
name|LoopBBs
operator|.
name|end
argument_list|()
argument_list|)
block|;
typedef|typedef
name|GraphTraits
operator|<
name|BlockT
operator|*
operator|>
name|BlockTraits
expr_stmt|;
end_expr_stmt

begin_for
for|for
control|(
name|block_iterator
name|BI
init|=
name|block_begin
argument_list|()
init|,
name|BE
init|=
name|block_end
argument_list|()
init|;
name|BI
operator|!=
name|BE
condition|;
operator|++
name|BI
control|)
for|for
control|(
name|typename
name|BlockTraits
operator|::
name|ChildIteratorType
name|I
operator|=
name|BlockTraits
operator|::
name|child_begin
argument_list|(
operator|*
name|BI
argument_list|)
operator|,
name|E
operator|=
name|BlockTraits
operator|::
name|child_end
argument_list|(
operator|*
name|BI
argument_list|)
init|;
name|I
operator|!=
name|E
condition|;
operator|++
name|I
control|)
if|if
condition|(
operator|!
name|std
operator|::
name|binary_search
argument_list|(
name|LoopBBs
operator|.
name|begin
argument_list|()
argument_list|,
name|LoopBBs
operator|.
name|end
argument_list|()
argument_list|,
operator|*
name|I
argument_list|)
condition|)
comment|// Not in current loop? It must be an exit block.
name|ExitBlocks
operator|.
name|push_back
argument_list|(
operator|*
name|I
argument_list|)
expr_stmt|;
end_for

begin_comment
unit|}
comment|/// getExitBlock - If getExitBlocks would return exactly one block,
end_comment

begin_comment
comment|/// return that block. Otherwise return null.
end_comment

begin_expr_stmt
unit|BlockT
operator|*
name|getExitBlock
argument_list|()
specifier|const
block|{
name|SmallVector
operator|<
name|BlockT
operator|*
block|,
literal|8
operator|>
name|ExitBlocks
block|;
name|getExitBlocks
argument_list|(
name|ExitBlocks
argument_list|)
block|;
if|if
condition|(
name|ExitBlocks
operator|.
name|size
argument_list|()
operator|==
literal|1
condition|)
return|return
name|ExitBlocks
index|[
literal|0
index|]
return|;
end_expr_stmt

begin_return
return|return
literal|0
return|;
end_return

begin_comment
unit|}
comment|/// getExitEdges - Return all pairs of (_inside_block_,_outside_block_).
end_comment

begin_expr_stmt
unit|typedef
name|std
operator|::
name|pair
operator|<
specifier|const
name|BlockT
operator|*
operator|,
specifier|const
name|BlockT
operator|*
operator|>
name|Edge
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|void
name|getExitEdges
argument_list|(
name|SmallVectorImpl
operator|<
name|Edge
operator|>
operator|&
name|ExitEdges
argument_list|)
decl|const
block|{
comment|// Sort the blocks vector so that we can use binary search to do quick
comment|// lookups.
name|SmallVector
operator|<
name|BlockT
operator|*
operator|,
literal|128
operator|>
name|LoopBBs
argument_list|(
name|block_begin
argument_list|()
argument_list|,
name|block_end
argument_list|()
argument_list|)
expr_stmt|;
name|std
operator|::
name|sort
argument_list|(
name|LoopBBs
operator|.
name|begin
argument_list|()
argument_list|,
name|LoopBBs
operator|.
name|end
argument_list|()
argument_list|)
expr_stmt|;
typedef|typedef
name|GraphTraits
operator|<
name|BlockT
operator|*
operator|>
name|BlockTraits
expr_stmt|;
for|for
control|(
name|block_iterator
name|BI
init|=
name|block_begin
argument_list|()
init|,
name|BE
init|=
name|block_end
argument_list|()
init|;
name|BI
operator|!=
name|BE
condition|;
operator|++
name|BI
control|)
for|for
control|(
name|typename
name|BlockTraits
operator|::
name|ChildIteratorType
name|I
operator|=
name|BlockTraits
operator|::
name|child_begin
argument_list|(
operator|*
name|BI
argument_list|)
operator|,
name|E
operator|=
name|BlockTraits
operator|::
name|child_end
argument_list|(
operator|*
name|BI
argument_list|)
init|;
name|I
operator|!=
name|E
condition|;
operator|++
name|I
control|)
if|if
condition|(
operator|!
name|std
operator|::
name|binary_search
argument_list|(
name|LoopBBs
operator|.
name|begin
argument_list|()
argument_list|,
name|LoopBBs
operator|.
name|end
argument_list|()
argument_list|,
operator|*
name|I
argument_list|)
condition|)
comment|// Not in current loop? It must be an exit block.
name|ExitEdges
operator|.
name|push_back
argument_list|(
name|std
operator|::
name|make_pair
argument_list|(
operator|*
name|BI
argument_list|,
operator|*
name|I
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_comment
comment|/// getLoopPreheader - If there is a preheader for this loop, return it.  A
end_comment

begin_comment
comment|/// loop has a preheader if there is only one edge to the header of the loop
end_comment

begin_comment
comment|/// from outside of the loop.  If this is the case, the block branching to the
end_comment

begin_comment
comment|/// header of the loop is the preheader node.
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|/// This method returns null if there is no preheader for the loop.
end_comment

begin_comment
comment|///
end_comment

begin_expr_stmt
name|BlockT
operator|*
name|getLoopPreheader
argument_list|()
specifier|const
block|{
comment|// Keep track of nodes outside the loop branching to the header...
name|BlockT
operator|*
name|Out
operator|=
literal|0
block|;
comment|// Loop over the predecessors of the header node...
name|BlockT
operator|*
name|Header
operator|=
name|getHeader
argument_list|()
block|;
typedef|typedef
name|GraphTraits
operator|<
name|BlockT
operator|*
operator|>
name|BlockTraits
expr_stmt|;
end_expr_stmt

begin_typedef
typedef|typedef
name|GraphTraits
operator|<
name|Inverse
operator|<
name|BlockT
operator|*
operator|>
expr|>
name|InvBlockTraits
expr_stmt|;
end_typedef

begin_for
for|for
control|(
name|typename
name|InvBlockTraits
operator|::
name|ChildIteratorType
name|PI
operator|=
name|InvBlockTraits
operator|::
name|child_begin
argument_list|(
name|Header
argument_list|)
operator|,
name|PE
operator|=
name|InvBlockTraits
operator|::
name|child_end
argument_list|(
name|Header
argument_list|)
init|;
name|PI
operator|!=
name|PE
condition|;
operator|++
name|PI
control|)
if|if
condition|(
operator|!
name|contains
argument_list|(
operator|*
name|PI
argument_list|)
condition|)
block|{
comment|// If the block is not in the loop...
if|if
condition|(
name|Out
operator|&&
name|Out
operator|!=
operator|*
name|PI
condition|)
return|return
literal|0
return|;
comment|// Multiple predecessors outside the loop
name|Out
operator|=
operator|*
name|PI
expr_stmt|;
block|}
end_for

begin_comment
comment|// Make sure there is only one exit out of the preheader.
end_comment

begin_expr_stmt
name|assert
argument_list|(
name|Out
operator|&&
literal|"Header of loop has no predecessors from outside loop?"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|typename
name|BlockTraits
operator|::
name|ChildIteratorType
name|SI
operator|=
name|BlockTraits
operator|::
name|child_begin
argument_list|(
name|Out
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
operator|++
name|SI
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|SI
operator|!=
name|BlockTraits
operator|::
name|child_end
argument_list|(
name|Out
argument_list|)
condition|)
return|return
literal|0
return|;
end_if

begin_comment
comment|// Multiple exits from the block, must not be a preheader.
end_comment

begin_comment
comment|// If there is exactly one preheader, return it.  If there was zero, then
end_comment

begin_comment
comment|// Out is still null.
end_comment

begin_return
return|return
name|Out
return|;
end_return

begin_comment
unit|}
comment|/// getLoopLatch - If there is a single latch block for this loop, return it.
end_comment

begin_comment
comment|/// A latch block is a block that contains a branch back to the header.
end_comment

begin_expr_stmt
unit|BlockT
operator|*
name|getLoopLatch
argument_list|()
specifier|const
block|{
name|BlockT
operator|*
name|Header
operator|=
name|getHeader
argument_list|()
block|;
typedef|typedef
name|GraphTraits
operator|<
name|Inverse
operator|<
name|BlockT
operator|*
operator|>
expr|>
name|InvBlockTraits
expr_stmt|;
name|typename
name|InvBlockTraits
operator|::
name|ChildIteratorType
name|PI
operator|=
name|InvBlockTraits
operator|::
name|child_begin
argument_list|(
name|Header
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|typename
name|InvBlockTraits
operator|::
name|ChildIteratorType
name|PE
operator|=
name|InvBlockTraits
operator|::
name|child_end
argument_list|(
name|Header
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|BlockT
modifier|*
name|Latch
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_for
for|for
control|(
init|;
name|PI
operator|!=
name|PE
condition|;
operator|++
name|PI
control|)
if|if
condition|(
name|contains
argument_list|(
operator|*
name|PI
argument_list|)
condition|)
block|{
if|if
condition|(
name|Latch
condition|)
return|return
literal|0
return|;
name|Latch
operator|=
operator|*
name|PI
expr_stmt|;
block|}
end_for

begin_return
return|return
name|Latch
return|;
end_return

begin_comment
unit|}
comment|//===--------------------------------------------------------------------===//
end_comment

begin_comment
comment|// APIs for updating loop information after changing the CFG
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|/// addBasicBlockToLoop - This method is used by other analyses to update loop
end_comment

begin_comment
comment|/// information.  NewBB is set to be a new member of the current loop.
end_comment

begin_comment
comment|/// Because of this, it is added as a member of all parent loops, and is added
end_comment

begin_comment
comment|/// to the specified LoopInfo object as being in the current basic block.  It
end_comment

begin_comment
comment|/// is not valid to replace the loop header with this method.
end_comment

begin_comment
comment|///
end_comment

begin_expr_stmt
unit|void
name|addBasicBlockToLoop
argument_list|(
name|BlockT
operator|*
name|NewBB
argument_list|,
name|LoopInfoBase
operator|<
name|BlockT
argument_list|,
name|LoopT
operator|>
operator|&
name|LI
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/// replaceChildLoopWith - This is used when splitting loops up.  It replaces
end_comment

begin_comment
comment|/// the OldChild entry in our children list with NewChild, and updates the
end_comment

begin_comment
comment|/// parent pointer of OldChild to be null and the NewChild to be this loop.
end_comment

begin_comment
comment|/// This updates the loop depth of the new child.
end_comment

begin_function
name|void
name|replaceChildLoopWith
parameter_list|(
name|LoopT
modifier|*
name|OldChild
parameter_list|,
name|LoopT
modifier|*
name|NewChild
parameter_list|)
block|{
name|assert
argument_list|(
name|OldChild
operator|->
name|ParentLoop
operator|==
name|this
operator|&&
literal|"This loop is already broken!"
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|NewChild
operator|->
name|ParentLoop
operator|==
literal|0
operator|&&
literal|"NewChild already has a parent!"
argument_list|)
expr_stmt|;
name|typename
name|std
operator|::
name|vector
operator|<
name|LoopT
operator|*
operator|>
operator|::
name|iterator
name|I
operator|=
name|std
operator|::
name|find
argument_list|(
name|SubLoops
operator|.
name|begin
argument_list|()
argument_list|,
name|SubLoops
operator|.
name|end
argument_list|()
argument_list|,
name|OldChild
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|I
operator|!=
name|SubLoops
operator|.
name|end
argument_list|()
operator|&&
literal|"OldChild not in loop!"
argument_list|)
expr_stmt|;
operator|*
name|I
operator|=
name|NewChild
expr_stmt|;
name|OldChild
operator|->
name|ParentLoop
operator|=
literal|0
expr_stmt|;
name|NewChild
operator|->
name|ParentLoop
operator|=
name|static_cast
operator|<
name|LoopT
operator|*
operator|>
operator|(
name|this
operator|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/// addChildLoop - Add the specified loop to be a child of this loop.  This
end_comment

begin_comment
comment|/// updates the loop depth of the new child.
end_comment

begin_comment
comment|///
end_comment

begin_function
name|void
name|addChildLoop
parameter_list|(
name|LoopT
modifier|*
name|NewChild
parameter_list|)
block|{
name|assert
argument_list|(
name|NewChild
operator|->
name|ParentLoop
operator|==
literal|0
operator|&&
literal|"NewChild already has a parent!"
argument_list|)
expr_stmt|;
name|NewChild
operator|->
name|ParentLoop
operator|=
name|static_cast
operator|<
name|LoopT
operator|*
operator|>
operator|(
name|this
operator|)
expr_stmt|;
name|SubLoops
operator|.
name|push_back
argument_list|(
name|NewChild
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/// removeChildLoop - This removes the specified child from being a subloop of
end_comment

begin_comment
comment|/// this loop.  The loop is not deleted, as it will presumably be inserted
end_comment

begin_comment
comment|/// into another loop.
end_comment

begin_function
name|LoopT
modifier|*
name|removeChildLoop
parameter_list|(
name|iterator
name|I
parameter_list|)
block|{
name|assert
argument_list|(
name|I
operator|!=
name|SubLoops
operator|.
name|end
argument_list|()
operator|&&
literal|"Cannot remove end iterator!"
argument_list|)
expr_stmt|;
name|LoopT
modifier|*
name|Child
init|=
operator|*
name|I
decl_stmt|;
name|assert
argument_list|(
name|Child
operator|->
name|ParentLoop
operator|==
name|this
operator|&&
literal|"Child is not a child of this loop!"
argument_list|)
expr_stmt|;
name|SubLoops
operator|.
name|erase
argument_list|(
name|SubLoops
operator|.
name|begin
argument_list|()
operator|+
operator|(
name|I
operator|-
name|begin
argument_list|()
operator|)
argument_list|)
expr_stmt|;
name|Child
operator|->
name|ParentLoop
operator|=
literal|0
expr_stmt|;
return|return
name|Child
return|;
block|}
end_function

begin_comment
comment|/// addBlockEntry - This adds a basic block directly to the basic block list.
end_comment

begin_comment
comment|/// This should only be used by transformations that create new loops.  Other
end_comment

begin_comment
comment|/// transformations should use addBasicBlockToLoop.
end_comment

begin_function
name|void
name|addBlockEntry
parameter_list|(
name|BlockT
modifier|*
name|BB
parameter_list|)
block|{
name|Blocks
operator|.
name|push_back
argument_list|(
name|BB
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/// moveToHeader - This method is used to move BB (which must be part of this
end_comment

begin_comment
comment|/// loop) to be the loop header of the loop (the block that dominates all
end_comment

begin_comment
comment|/// others).
end_comment

begin_function
name|void
name|moveToHeader
parameter_list|(
name|BlockT
modifier|*
name|BB
parameter_list|)
block|{
if|if
condition|(
name|Blocks
index|[
literal|0
index|]
operator|==
name|BB
condition|)
return|return;
for|for
control|(
name|unsigned
name|i
init|=
literal|0
init|;
condition|;
operator|++
name|i
control|)
block|{
name|assert
argument_list|(
name|i
operator|!=
name|Blocks
operator|.
name|size
argument_list|()
operator|&&
literal|"Loop does not contain BB!"
argument_list|)
expr_stmt|;
if|if
condition|(
name|Blocks
index|[
name|i
index|]
operator|==
name|BB
condition|)
block|{
name|Blocks
index|[
name|i
index|]
operator|=
name|Blocks
index|[
literal|0
index|]
expr_stmt|;
name|Blocks
index|[
literal|0
index|]
operator|=
name|BB
expr_stmt|;
return|return;
block|}
block|}
block|}
end_function

begin_comment
comment|/// removeBlockFromLoop - This removes the specified basic block from the
end_comment

begin_comment
comment|/// current loop, updating the Blocks as appropriate.  This does not update
end_comment

begin_comment
comment|/// the mapping in the LoopInfo class.
end_comment

begin_function
name|void
name|removeBlockFromLoop
parameter_list|(
name|BlockT
modifier|*
name|BB
parameter_list|)
block|{
name|RemoveFromVector
argument_list|(
name|Blocks
argument_list|,
name|BB
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/// verifyLoop - Verify loop structure
end_comment

begin_expr_stmt
name|void
name|verifyLoop
argument_list|()
specifier|const
block|{
ifndef|#
directive|ifndef
name|NDEBUG
name|assert
argument_list|(
operator|!
name|Blocks
operator|.
name|empty
argument_list|()
operator|&&
literal|"Loop header is missing"
argument_list|)
block|;
comment|// Sort the blocks vector so that we can use binary search to do quick
comment|// lookups.
name|SmallVector
operator|<
name|BlockT
operator|*
block|,
literal|128
operator|>
name|LoopBBs
argument_list|(
name|block_begin
argument_list|()
argument_list|,
name|block_end
argument_list|()
argument_list|)
block|;
name|std
operator|::
name|sort
argument_list|(
name|LoopBBs
operator|.
name|begin
argument_list|()
argument_list|,
name|LoopBBs
operator|.
name|end
argument_list|()
argument_list|)
block|;
comment|// Check the individual blocks.
for|for
control|(
name|block_iterator
name|I
init|=
name|block_begin
argument_list|()
init|,
name|E
init|=
name|block_end
argument_list|()
init|;
name|I
operator|!=
name|E
condition|;
operator|++
name|I
control|)
block|{
name|BlockT
modifier|*
name|BB
init|=
operator|*
name|I
decl_stmt|;
name|bool
name|HasInsideLoopSuccs
init|=
name|false
decl_stmt|;
name|bool
name|HasInsideLoopPreds
init|=
name|false
decl_stmt|;
name|SmallVector
operator|<
name|BlockT
operator|*
operator|,
literal|2
operator|>
name|OutsideLoopPreds
expr_stmt|;
typedef|typedef
name|GraphTraits
operator|<
name|BlockT
operator|*
operator|>
name|BlockTraits
expr_stmt|;
for|for
control|(
name|typename
name|BlockTraits
operator|::
name|ChildIteratorType
name|SI
operator|=
name|BlockTraits
operator|::
name|child_begin
argument_list|(
name|BB
argument_list|)
operator|,
name|SE
operator|=
name|BlockTraits
operator|::
name|child_end
argument_list|(
name|BB
argument_list|)
init|;
name|SI
operator|!=
name|SE
condition|;
operator|++
name|SI
control|)
if|if
condition|(
name|std
operator|::
name|binary_search
argument_list|(
name|LoopBBs
operator|.
name|begin
argument_list|()
argument_list|,
name|LoopBBs
operator|.
name|end
argument_list|()
argument_list|,
operator|*
name|SI
argument_list|)
condition|)
block|{
name|HasInsideLoopSuccs
operator|=
name|true
expr_stmt|;
break|break;
block|}
end_expr_stmt

begin_typedef
typedef|typedef
name|GraphTraits
operator|<
name|Inverse
operator|<
name|BlockT
operator|*
operator|>
expr|>
name|InvBlockTraits
expr_stmt|;
end_typedef

begin_for
for|for
control|(
name|typename
name|InvBlockTraits
operator|::
name|ChildIteratorType
name|PI
operator|=
name|InvBlockTraits
operator|::
name|child_begin
argument_list|(
name|BB
argument_list|)
operator|,
name|PE
operator|=
name|InvBlockTraits
operator|::
name|child_end
argument_list|(
name|BB
argument_list|)
init|;
name|PI
operator|!=
name|PE
condition|;
operator|++
name|PI
control|)
block|{
if|if
condition|(
name|std
operator|::
name|binary_search
argument_list|(
name|LoopBBs
operator|.
name|begin
argument_list|()
argument_list|,
name|LoopBBs
operator|.
name|end
argument_list|()
argument_list|,
operator|*
name|PI
argument_list|)
condition|)
name|HasInsideLoopPreds
operator|=
name|true
expr_stmt|;
else|else
name|OutsideLoopPreds
operator|.
name|push_back
argument_list|(
operator|*
name|PI
argument_list|)
expr_stmt|;
block|}
end_for

begin_if
if|if
condition|(
name|BB
operator|==
name|getHeader
argument_list|()
condition|)
block|{
name|assert
argument_list|(
operator|!
name|OutsideLoopPreds
operator|.
name|empty
argument_list|()
operator|&&
literal|"Loop is unreachable!"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|OutsideLoopPreds
operator|.
name|empty
argument_list|()
condition|)
block|{
comment|// A non-header loop shouldn't be reachable from outside the loop,
comment|// though it is permitted if the predecessor is not itself actually
comment|// reachable.
name|BlockT
modifier|*
name|EntryBB
init|=
name|BB
operator|->
name|getParent
argument_list|()
operator|->
name|begin
argument_list|()
decl_stmt|;
for|for
control|(
name|df_iterator
operator|<
name|BlockT
operator|*
operator|>
name|NI
operator|=
name|df_begin
argument_list|(
name|EntryBB
argument_list|)
operator|,
name|NE
operator|=
name|df_end
argument_list|(
name|EntryBB
argument_list|)
init|;
name|NI
operator|!=
name|NE
condition|;
operator|++
name|NI
control|)
for|for
control|(
name|unsigned
name|i
init|=
literal|0
init|,
name|e
init|=
name|OutsideLoopPreds
operator|.
name|size
argument_list|()
init|;
name|i
operator|!=
name|e
condition|;
operator|++
name|i
control|)
name|assert
argument_list|(
operator|*
name|NI
operator|!=
name|OutsideLoopPreds
index|[
name|i
index|]
operator|&&
literal|"Loop has multiple entry points!"
argument_list|)
expr_stmt|;
block|}
end_if

begin_expr_stmt
name|assert
argument_list|(
name|HasInsideLoopPreds
operator|&&
literal|"Loop block has no in-loop predecessors!"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|assert
argument_list|(
name|HasInsideLoopSuccs
operator|&&
literal|"Loop block has no in-loop successors!"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|assert
argument_list|(
name|BB
operator|!=
name|getHeader
argument_list|()
operator|->
name|getParent
argument_list|()
operator|->
name|begin
argument_list|()
operator|&&
literal|"Loop contains function entry block!"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
unit|}
comment|// Check the subloops.
end_comment

begin_expr_stmt
unit|for
operator|(
name|iterator
name|I
operator|=
name|begin
argument_list|()
operator|,
name|E
operator|=
name|end
argument_list|()
expr|;
name|I
operator|!=
name|E
expr|;
operator|++
name|I
operator|)
end_expr_stmt

begin_comment
comment|// Each block in each subloop should be contained within this loop.
end_comment

begin_for
for|for
control|(
name|block_iterator
name|BI
init|=
operator|(
operator|*
name|I
operator|)
operator|->
name|block_begin
argument_list|()
init|,
name|BE
init|=
operator|(
operator|*
name|I
operator|)
operator|->
name|block_end
argument_list|()
init|;
name|BI
operator|!=
name|BE
condition|;
operator|++
name|BI
control|)
block|{
name|assert
argument_list|(
name|std
operator|::
name|binary_search
argument_list|(
name|LoopBBs
operator|.
name|begin
argument_list|()
argument_list|,
name|LoopBBs
operator|.
name|end
argument_list|()
argument_list|,
operator|*
name|BI
argument_list|)
operator|&&
literal|"Loop does not contain all the blocks of a subloop!"
argument_list|)
expr_stmt|;
block|}
end_for

begin_comment
comment|// Check the parent loop pointer.
end_comment

begin_if
if|if
condition|(
name|ParentLoop
condition|)
block|{
name|assert
argument_list|(
name|std
operator|::
name|find
argument_list|(
name|ParentLoop
operator|->
name|begin
argument_list|()
argument_list|,
name|ParentLoop
operator|->
name|end
argument_list|()
argument_list|,
name|this
argument_list|)
operator|!=
name|ParentLoop
operator|->
name|end
argument_list|()
operator|&&
literal|"Loop is not a subloop of its parent!"
argument_list|)
expr_stmt|;
block|}
end_if

begin_endif
endif|#
directive|endif
end_endif

begin_comment
unit|}
comment|/// verifyLoop - Verify loop structure of this loop and all nested loops.
end_comment

begin_macro
unit|void
name|verifyLoopNest
argument_list|()
end_macro

begin_expr_stmt
specifier|const
block|{
comment|// Verify this loop.
name|verifyLoop
argument_list|()
block|;
comment|// Verify the subloops.
for|for
control|(
name|iterator
name|I
init|=
name|begin
argument_list|()
init|,
name|E
init|=
name|end
argument_list|()
init|;
name|I
operator|!=
name|E
condition|;
operator|++
name|I
control|)
operator|(
operator|*
name|I
operator|)
operator|->
name|verifyLoopNest
argument_list|()
expr_stmt|;
block|}
end_expr_stmt

begin_decl_stmt
name|void
name|print
argument_list|(
name|raw_ostream
operator|&
name|OS
argument_list|,
name|unsigned
name|Depth
operator|=
literal|0
argument_list|)
decl|const
block|{
name|OS
operator|.
name|indent
argument_list|(
name|Depth
operator|*
literal|2
argument_list|)
operator|<<
literal|"Loop at depth "
operator|<<
name|getLoopDepth
argument_list|()
operator|<<
literal|" containing: "
expr_stmt|;
for|for
control|(
name|unsigned
name|i
init|=
literal|0
init|;
name|i
operator|<
name|getBlocks
argument_list|()
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|i
condition|)
name|OS
operator|<<
literal|","
expr_stmt|;
name|BlockT
modifier|*
name|BB
init|=
name|getBlocks
argument_list|()
index|[
name|i
index|]
decl_stmt|;
name|WriteAsOperand
argument_list|(
name|OS
argument_list|,
name|BB
argument_list|,
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|BB
operator|==
name|getHeader
argument_list|()
condition|)
name|OS
operator|<<
literal|"<header>"
expr_stmt|;
if|if
condition|(
name|BB
operator|==
name|getLoopLatch
argument_list|()
condition|)
name|OS
operator|<<
literal|"<latch>"
expr_stmt|;
if|if
condition|(
name|isLoopExiting
argument_list|(
name|BB
argument_list|)
condition|)
name|OS
operator|<<
literal|"<exiting>"
expr_stmt|;
block|}
name|OS
operator|<<
literal|"\n"
expr_stmt|;
for|for
control|(
name|iterator
name|I
init|=
name|begin
argument_list|()
init|,
name|E
init|=
name|end
argument_list|()
init|;
name|I
operator|!=
name|E
condition|;
operator|++
name|I
control|)
operator|(
operator|*
name|I
operator|)
operator|->
name|print
argument_list|(
name|OS
argument_list|,
name|Depth
operator|+
literal|2
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_label
name|protected
label|:
end_label

begin_expr_stmt
name|friend
name|class
name|LoopInfoBase
operator|<
name|BlockT
operator|,
name|LoopT
operator|>
expr_stmt|;
end_expr_stmt

begin_macro
name|explicit
end_macro

begin_expr_stmt
name|LoopBase
argument_list|(
name|BlockT
operator|*
name|BB
argument_list|)
operator|:
name|ParentLoop
argument_list|(
literal|0
argument_list|)
block|{
name|Blocks
operator|.
name|push_back
argument_list|(
name|BB
argument_list|)
block|;   }
end_expr_stmt

begin_decl_stmt
unit|};
name|class
name|Loop
range|:
name|public
name|LoopBase
operator|<
name|BasicBlock
decl_stmt|,
name|Loop
decl|>
block|{
name|public
label|:
name|Loop
argument_list|()
block|{}
comment|/// isLoopInvariant - Return true if the specified value is loop invariant
comment|///
name|bool
name|isLoopInvariant
argument_list|(
name|Value
operator|*
name|V
argument_list|)
decl|const
decl_stmt|;
comment|/// isLoopInvariant - Return true if the specified instruction is
comment|/// loop-invariant.
comment|///
name|bool
name|isLoopInvariant
argument_list|(
name|Instruction
operator|*
name|I
argument_list|)
decl|const
decl_stmt|;
comment|/// makeLoopInvariant - If the given value is an instruction inside of the
comment|/// loop and it can be hoisted, do so to make it trivially loop-invariant.
comment|/// Return true if the value after any hoisting is loop invariant. This
comment|/// function can be used as a slightly more aggressive replacement for
comment|/// isLoopInvariant.
comment|///
comment|/// If InsertPt is specified, it is the point to hoist instructions to.
comment|/// If null, the terminator of the loop preheader is used.
comment|///
name|bool
name|makeLoopInvariant
argument_list|(
name|Value
operator|*
name|V
argument_list|,
name|bool
operator|&
name|Changed
argument_list|,
name|Instruction
operator|*
name|InsertPt
operator|=
literal|0
argument_list|)
decl|const
decl_stmt|;
comment|/// makeLoopInvariant - If the given instruction is inside of the
comment|/// loop and it can be hoisted, do so to make it trivially loop-invariant.
comment|/// Return true if the instruction after any hoisting is loop invariant. This
comment|/// function can be used as a slightly more aggressive replacement for
comment|/// isLoopInvariant.
comment|///
comment|/// If InsertPt is specified, it is the point to hoist instructions to.
comment|/// If null, the terminator of the loop preheader is used.
comment|///
name|bool
name|makeLoopInvariant
argument_list|(
name|Instruction
operator|*
name|I
argument_list|,
name|bool
operator|&
name|Changed
argument_list|,
name|Instruction
operator|*
name|InsertPt
operator|=
literal|0
argument_list|)
decl|const
decl_stmt|;
comment|/// getCanonicalInductionVariable - Check to see if the loop has a canonical
comment|/// induction variable: an integer recurrence that starts at 0 and increments
comment|/// by one each time through the loop.  If so, return the phi node that
comment|/// corresponds to it.
comment|///
comment|/// The IndVarSimplify pass transforms loops to have a canonical induction
comment|/// variable.
comment|///
name|PHINode
operator|*
name|getCanonicalInductionVariable
argument_list|()
specifier|const
expr_stmt|;
comment|/// getCanonicalInductionVariableIncrement - Return the LLVM value that holds
comment|/// the canonical induction variable value for the "next" iteration of the
comment|/// loop.  This always succeeds if getCanonicalInductionVariable succeeds.
comment|///
name|Instruction
operator|*
name|getCanonicalInductionVariableIncrement
argument_list|()
specifier|const
expr_stmt|;
comment|/// getTripCount - Return a loop-invariant LLVM value indicating the number of
comment|/// times the loop will be executed.  Note that this means that the backedge
comment|/// of the loop executes N-1 times.  If the trip-count cannot be determined,
comment|/// this returns null.
comment|///
comment|/// The IndVarSimplify pass transforms loops to have a form that this
comment|/// function easily understands.
comment|///
name|Value
operator|*
name|getTripCount
argument_list|()
specifier|const
expr_stmt|;
comment|/// getSmallConstantTripCount - Returns the trip count of this loop as a
comment|/// normal unsigned value, if possible. Returns 0 if the trip count is unknown
comment|/// of not constant. Will also return 0 if the trip count is very large
comment|/// (>= 2^32)
name|unsigned
name|getSmallConstantTripCount
argument_list|()
specifier|const
expr_stmt|;
comment|/// getSmallConstantTripMultiple - Returns the largest constant divisor of the
comment|/// trip count of this loop as a normal unsigned value, if possible. This
comment|/// means that the actual trip count is always a multiple of the returned
comment|/// value (don't forget the trip count could very well be zero as well!).
comment|///
comment|/// Returns 1 if the trip count is unknown or not guaranteed to be the
comment|/// multiple of a constant (which is also the case if the trip count is simply
comment|/// constant, use getSmallConstantTripCount for that case), Will also return 1
comment|/// if the trip count is very large (>= 2^32).
name|unsigned
name|getSmallConstantTripMultiple
argument_list|()
specifier|const
expr_stmt|;
comment|/// isLCSSAForm - Return true if the Loop is in LCSSA form
name|bool
name|isLCSSAForm
argument_list|()
specifier|const
expr_stmt|;
comment|/// isLoopSimplifyForm - Return true if the Loop is in the form that
comment|/// the LoopSimplify form transforms loops to, which is sometimes called
comment|/// normal form.
name|bool
name|isLoopSimplifyForm
argument_list|()
specifier|const
expr_stmt|;
comment|/// hasDedicatedExits - Return true if no exit block for the loop
comment|/// has a predecessor that is outside the loop.
name|bool
name|hasDedicatedExits
argument_list|()
specifier|const
expr_stmt|;
comment|/// getUniqueExitBlocks - Return all unique successor blocks of this loop.
comment|/// These are the blocks _outside of the current loop_ which are branched to.
comment|/// This assumes that loop exits are in canonical form.
comment|///
name|void
name|getUniqueExitBlocks
argument_list|(
name|SmallVectorImpl
operator|<
name|BasicBlock
operator|*
operator|>
operator|&
name|ExitBlocks
argument_list|)
decl|const
decl_stmt|;
comment|/// getUniqueExitBlock - If getUniqueExitBlocks would return exactly one
comment|/// block, return that block. Otherwise return null.
name|BasicBlock
operator|*
name|getUniqueExitBlock
argument_list|()
specifier|const
expr_stmt|;
name|void
name|dump
argument_list|()
specifier|const
expr_stmt|;
name|private
label|:
name|friend
name|class
name|LoopInfoBase
operator|<
name|BasicBlock
operator|,
name|Loop
operator|>
expr_stmt|;
name|explicit
name|Loop
argument_list|(
name|BasicBlock
operator|*
name|BB
argument_list|)
operator|:
name|LoopBase
operator|<
name|BasicBlock
operator|,
name|Loop
operator|>
operator|(
name|BB
operator|)
block|{}
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|/// LoopInfo - This class builds and contains all of the top level loop
end_comment

begin_comment
comment|/// structures in the specified function.
end_comment

begin_comment
comment|///
end_comment

begin_expr_stmt
name|template
operator|<
name|class
name|BlockT
operator|,
name|class
name|LoopT
operator|>
name|class
name|LoopInfoBase
block|{
comment|// BBMap - Mapping of basic blocks to the inner most loop they occur in
name|std
operator|::
name|map
operator|<
name|BlockT
operator|*
block|,
name|LoopT
operator|*
operator|>
name|BBMap
block|;
name|std
operator|::
name|vector
operator|<
name|LoopT
operator|*
operator|>
name|TopLevelLoops
block|;
name|friend
name|class
name|LoopBase
operator|<
name|BlockT
block|,
name|LoopT
operator|>
block|;
name|void
name|operator
operator|=
operator|(
specifier|const
name|LoopInfoBase
operator|&
operator|)
block|;
comment|// do not implement
name|LoopInfoBase
argument_list|(
specifier|const
name|LoopInfo
operator|&
argument_list|)
block|;
comment|// do not implement
name|public
operator|:
name|LoopInfoBase
argument_list|()
block|{ }
operator|~
name|LoopInfoBase
argument_list|()
block|{
name|releaseMemory
argument_list|()
block|; }
name|void
name|releaseMemory
argument_list|()
block|{
for|for
control|(
name|typename
name|std
operator|::
name|vector
operator|<
name|LoopT
operator|*
operator|>
operator|::
name|iterator
name|I
operator|=
name|TopLevelLoops
operator|.
name|begin
argument_list|()
operator|,
name|E
operator|=
name|TopLevelLoops
operator|.
name|end
argument_list|()
init|;
name|I
operator|!=
name|E
condition|;
operator|++
name|I
control|)
name|delete
modifier|*
name|I
decl_stmt|;
comment|// Delete all of the loops...
name|BBMap
operator|.
name|clear
argument_list|()
block|;
comment|// Reset internal state of analysis
name|TopLevelLoops
operator|.
name|clear
argument_list|()
block|;   }
end_expr_stmt

begin_comment
comment|/// iterator/begin/end - The interface to the top-level loops in the current
end_comment

begin_comment
comment|/// function.
end_comment

begin_comment
comment|///
end_comment

begin_typedef
typedef|typedef
name|typename
name|std
operator|::
name|vector
operator|<
name|LoopT
operator|*
operator|>
operator|::
name|const_iterator
name|iterator
expr_stmt|;
end_typedef

begin_expr_stmt
name|iterator
name|begin
argument_list|()
specifier|const
block|{
return|return
name|TopLevelLoops
operator|.
name|begin
argument_list|()
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|iterator
name|end
argument_list|()
specifier|const
block|{
return|return
name|TopLevelLoops
operator|.
name|end
argument_list|()
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|bool
name|empty
argument_list|()
specifier|const
block|{
return|return
name|TopLevelLoops
operator|.
name|empty
argument_list|()
return|;
block|}
end_expr_stmt

begin_comment
comment|/// getLoopFor - Return the inner most loop that BB lives in.  If a basic
end_comment

begin_comment
comment|/// block is in no loop (for example the entry node), null is returned.
end_comment

begin_comment
comment|///
end_comment

begin_decl_stmt
name|LoopT
modifier|*
name|getLoopFor
argument_list|(
specifier|const
name|BlockT
operator|*
name|BB
argument_list|)
decl|const
block|{
name|typename
name|std
operator|::
name|map
operator|<
name|BlockT
operator|*
operator|,
name|LoopT
operator|*
operator|>
operator|::
name|const_iterator
name|I
operator|=
name|BBMap
operator|.
name|find
argument_list|(
name|const_cast
operator|<
name|BlockT
operator|*
operator|>
operator|(
name|BB
operator|)
argument_list|)
expr_stmt|;
return|return
name|I
operator|!=
name|BBMap
operator|.
name|end
argument_list|()
condition|?
name|I
operator|->
name|second
else|:
literal|0
return|;
block|}
end_decl_stmt

begin_comment
comment|/// operator[] - same as getLoopFor...
end_comment

begin_comment
comment|///
end_comment

begin_decl_stmt
specifier|const
name|LoopT
modifier|*
name|operator
index|[]
argument_list|(
specifier|const
name|BlockT
operator|*
name|BB
argument_list|)
decl|const
block|{
return|return
name|getLoopFor
argument_list|(
name|BB
argument_list|)
return|;
block|}
end_decl_stmt

begin_comment
comment|/// getLoopDepth - Return the loop nesting level of the specified block.  A
end_comment

begin_comment
comment|/// depth of 0 means the block is not inside any loop.
end_comment

begin_comment
comment|///
end_comment

begin_decl_stmt
name|unsigned
name|getLoopDepth
argument_list|(
specifier|const
name|BlockT
operator|*
name|BB
argument_list|)
decl|const
block|{
specifier|const
name|LoopT
modifier|*
name|L
init|=
name|getLoopFor
argument_list|(
name|BB
argument_list|)
decl_stmt|;
return|return
name|L
condition|?
name|L
operator|->
name|getLoopDepth
argument_list|()
else|:
literal|0
return|;
block|}
end_decl_stmt

begin_comment
comment|// isLoopHeader - True if the block is a loop header node
end_comment

begin_decl_stmt
name|bool
name|isLoopHeader
argument_list|(
name|BlockT
operator|*
name|BB
argument_list|)
decl|const
block|{
specifier|const
name|LoopT
modifier|*
name|L
init|=
name|getLoopFor
argument_list|(
name|BB
argument_list|)
decl_stmt|;
return|return
name|L
operator|&&
name|L
operator|->
name|getHeader
argument_list|()
operator|==
name|BB
return|;
block|}
end_decl_stmt

begin_comment
comment|/// removeLoop - This removes the specified top-level loop from this loop info
end_comment

begin_comment
comment|/// object.  The loop is not deleted, as it will presumably be inserted into
end_comment

begin_comment
comment|/// another loop.
end_comment

begin_function
name|LoopT
modifier|*
name|removeLoop
parameter_list|(
name|iterator
name|I
parameter_list|)
block|{
name|assert
argument_list|(
name|I
operator|!=
name|end
argument_list|()
operator|&&
literal|"Cannot remove end iterator!"
argument_list|)
expr_stmt|;
name|LoopT
modifier|*
name|L
init|=
operator|*
name|I
decl_stmt|;
name|assert
argument_list|(
name|L
operator|->
name|getParentLoop
argument_list|()
operator|==
literal|0
operator|&&
literal|"Not a top-level loop!"
argument_list|)
expr_stmt|;
name|TopLevelLoops
operator|.
name|erase
argument_list|(
name|TopLevelLoops
operator|.
name|begin
argument_list|()
operator|+
operator|(
name|I
operator|-
name|begin
argument_list|()
operator|)
argument_list|)
expr_stmt|;
return|return
name|L
return|;
block|}
end_function

begin_comment
comment|/// changeLoopFor - Change the top-level loop that contains BB to the
end_comment

begin_comment
comment|/// specified loop.  This should be used by transformations that restructure
end_comment

begin_comment
comment|/// the loop hierarchy tree.
end_comment

begin_function
name|void
name|changeLoopFor
parameter_list|(
name|BlockT
modifier|*
name|BB
parameter_list|,
name|LoopT
modifier|*
name|L
parameter_list|)
block|{
name|LoopT
modifier|*
modifier|&
name|OldLoop
init|=
name|BBMap
index|[
name|BB
index|]
decl_stmt|;
name|assert
argument_list|(
name|OldLoop
operator|&&
literal|"Block not in a loop yet!"
argument_list|)
expr_stmt|;
name|OldLoop
operator|=
name|L
expr_stmt|;
block|}
end_function

begin_comment
comment|/// changeTopLevelLoop - Replace the specified loop in the top-level loops
end_comment

begin_comment
comment|/// list with the indicated loop.
end_comment

begin_function
name|void
name|changeTopLevelLoop
parameter_list|(
name|LoopT
modifier|*
name|OldLoop
parameter_list|,
name|LoopT
modifier|*
name|NewLoop
parameter_list|)
block|{
name|typename
name|std
operator|::
name|vector
operator|<
name|LoopT
operator|*
operator|>
operator|::
name|iterator
name|I
operator|=
name|std
operator|::
name|find
argument_list|(
name|TopLevelLoops
operator|.
name|begin
argument_list|()
argument_list|,
name|TopLevelLoops
operator|.
name|end
argument_list|()
argument_list|,
name|OldLoop
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|I
operator|!=
name|TopLevelLoops
operator|.
name|end
argument_list|()
operator|&&
literal|"Old loop not at top level!"
argument_list|)
expr_stmt|;
operator|*
name|I
operator|=
name|NewLoop
expr_stmt|;
name|assert
argument_list|(
name|NewLoop
operator|->
name|ParentLoop
operator|==
literal|0
operator|&&
name|OldLoop
operator|->
name|ParentLoop
operator|==
literal|0
operator|&&
literal|"Loops already embedded into a subloop!"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/// addTopLevelLoop - This adds the specified loop to the collection of
end_comment

begin_comment
comment|/// top-level loops.
end_comment

begin_function
name|void
name|addTopLevelLoop
parameter_list|(
name|LoopT
modifier|*
name|New
parameter_list|)
block|{
name|assert
argument_list|(
name|New
operator|->
name|getParentLoop
argument_list|()
operator|==
literal|0
operator|&&
literal|"Loop already in subloop!"
argument_list|)
expr_stmt|;
name|TopLevelLoops
operator|.
name|push_back
argument_list|(
name|New
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/// removeBlock - This method completely removes BB from all data structures,
end_comment

begin_comment
comment|/// including all of the Loop objects it is nested in and our mapping from
end_comment

begin_comment
comment|/// BasicBlocks to loops.
end_comment

begin_function
name|void
name|removeBlock
parameter_list|(
name|BlockT
modifier|*
name|BB
parameter_list|)
block|{
name|typename
name|std
operator|::
name|map
operator|<
name|BlockT
operator|*
operator|,
name|LoopT
operator|*
operator|>
operator|::
name|iterator
name|I
operator|=
name|BBMap
operator|.
name|find
argument_list|(
name|BB
argument_list|)
expr_stmt|;
if|if
condition|(
name|I
operator|!=
name|BBMap
operator|.
name|end
argument_list|()
condition|)
block|{
for|for
control|(
name|LoopT
modifier|*
name|L
init|=
name|I
operator|->
name|second
init|;
name|L
condition|;
name|L
operator|=
name|L
operator|->
name|getParentLoop
argument_list|()
control|)
name|L
operator|->
name|removeBlockFromLoop
argument_list|(
name|BB
argument_list|)
expr_stmt|;
name|BBMap
operator|.
name|erase
argument_list|(
name|I
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|// Internals
end_comment

begin_function
specifier|static
name|bool
name|isNotAlreadyContainedIn
parameter_list|(
specifier|const
name|LoopT
modifier|*
name|SubLoop
parameter_list|,
specifier|const
name|LoopT
modifier|*
name|ParentLoop
parameter_list|)
block|{
if|if
condition|(
name|SubLoop
operator|==
literal|0
condition|)
return|return
name|true
return|;
if|if
condition|(
name|SubLoop
operator|==
name|ParentLoop
condition|)
return|return
name|false
return|;
return|return
name|isNotAlreadyContainedIn
argument_list|(
name|SubLoop
operator|->
name|getParentLoop
argument_list|()
argument_list|,
name|ParentLoop
argument_list|)
return|;
block|}
end_function

begin_decl_stmt
name|void
name|Calculate
argument_list|(
name|DominatorTreeBase
operator|<
name|BlockT
operator|>
operator|&
name|DT
argument_list|)
block|{
name|BlockT
modifier|*
name|RootNode
init|=
name|DT
operator|.
name|getRootNode
argument_list|()
operator|->
name|getBlock
argument_list|()
decl_stmt|;
for|for
control|(
name|df_iterator
operator|<
name|BlockT
operator|*
operator|>
name|NI
operator|=
name|df_begin
argument_list|(
name|RootNode
argument_list|)
operator|,
name|NE
operator|=
name|df_end
argument_list|(
name|RootNode
argument_list|)
init|;
name|NI
operator|!=
name|NE
condition|;
operator|++
name|NI
control|)
if|if
condition|(
name|LoopT
modifier|*
name|L
init|=
name|ConsiderForLoop
argument_list|(
operator|*
name|NI
argument_list|,
name|DT
argument_list|)
condition|)
name|TopLevelLoops
operator|.
name|push_back
argument_list|(
name|L
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_decl_stmt
name|LoopT
modifier|*
name|ConsiderForLoop
argument_list|(
name|BlockT
operator|*
name|BB
argument_list|,
name|DominatorTreeBase
operator|<
name|BlockT
operator|>
operator|&
name|DT
argument_list|)
block|{
if|if
condition|(
name|BBMap
operator|.
name|find
argument_list|(
name|BB
argument_list|)
operator|!=
name|BBMap
operator|.
name|end
argument_list|()
condition|)
return|return
literal|0
return|;
comment|// Haven't processed this node?
name|std
operator|::
name|vector
operator|<
name|BlockT
operator|*
operator|>
name|TodoStack
expr_stmt|;
comment|// Scan the predecessors of BB, checking to see if BB dominates any of
comment|// them.  This identifies backedges which target this node...
typedef|typedef
name|GraphTraits
operator|<
name|Inverse
operator|<
name|BlockT
operator|*
operator|>
expr|>
name|InvBlockTraits
expr_stmt|;
for|for
control|(
name|typename
name|InvBlockTraits
operator|::
name|ChildIteratorType
name|I
operator|=
name|InvBlockTraits
operator|::
name|child_begin
argument_list|(
name|BB
argument_list|)
operator|,
name|E
operator|=
name|InvBlockTraits
operator|::
name|child_end
argument_list|(
name|BB
argument_list|)
init|;
name|I
operator|!=
name|E
condition|;
operator|++
name|I
control|)
if|if
condition|(
name|DT
operator|.
name|dominates
argument_list|(
name|BB
argument_list|,
operator|*
name|I
argument_list|)
condition|)
comment|// If BB dominates its predecessor...
name|TodoStack
operator|.
name|push_back
argument_list|(
operator|*
name|I
argument_list|)
expr_stmt|;
if|if
condition|(
name|TodoStack
operator|.
name|empty
argument_list|()
condition|)
return|return
literal|0
return|;
comment|// No backedges to this block...
comment|// Create a new loop to represent this basic block...
name|LoopT
modifier|*
name|L
init|=
name|new
name|LoopT
argument_list|(
name|BB
argument_list|)
decl_stmt|;
name|BBMap
index|[
name|BB
index|]
operator|=
name|L
expr_stmt|;
name|BlockT
modifier|*
name|EntryBlock
init|=
name|BB
operator|->
name|getParent
argument_list|()
operator|->
name|begin
argument_list|()
decl_stmt|;
while|while
condition|(
operator|!
name|TodoStack
operator|.
name|empty
argument_list|()
condition|)
block|{
comment|// Process all the nodes in the loop
name|BlockT
modifier|*
name|X
init|=
name|TodoStack
operator|.
name|back
argument_list|()
decl_stmt|;
name|TodoStack
operator|.
name|pop_back
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|L
operator|->
name|contains
argument_list|(
name|X
argument_list|)
operator|&&
comment|// As of yet unprocessed??
name|DT
operator|.
name|dominates
argument_list|(
name|EntryBlock
argument_list|,
name|X
argument_list|)
condition|)
block|{
comment|// X is reachable from entry block?
comment|// Check to see if this block already belongs to a loop.  If this occurs
comment|// then we have a case where a loop that is supposed to be a child of
comment|// the current loop was processed before the current loop.  When this
comment|// occurs, this child loop gets added to a part of the current loop,
comment|// making it a sibling to the current loop.  We have to reparent this
comment|// loop.
if|if
condition|(
name|LoopT
modifier|*
name|SubLoop
init|=
name|const_cast
operator|<
name|LoopT
operator|*
operator|>
operator|(
name|getLoopFor
argument_list|(
name|X
argument_list|)
operator|)
condition|)
if|if
condition|(
name|SubLoop
operator|->
name|getHeader
argument_list|()
operator|==
name|X
operator|&&
name|isNotAlreadyContainedIn
argument_list|(
name|SubLoop
argument_list|,
name|L
argument_list|)
condition|)
block|{
comment|// Remove the subloop from its current parent...
name|assert
argument_list|(
name|SubLoop
operator|->
name|ParentLoop
operator|&&
name|SubLoop
operator|->
name|ParentLoop
operator|!=
name|L
argument_list|)
expr_stmt|;
name|LoopT
modifier|*
name|SLP
init|=
name|SubLoop
operator|->
name|ParentLoop
decl_stmt|;
comment|// SubLoopParent
name|typename
name|std
operator|::
name|vector
operator|<
name|LoopT
operator|*
operator|>
operator|::
name|iterator
name|I
operator|=
name|std
operator|::
name|find
argument_list|(
name|SLP
operator|->
name|SubLoops
operator|.
name|begin
argument_list|()
argument_list|,
name|SLP
operator|->
name|SubLoops
operator|.
name|end
argument_list|()
argument_list|,
name|SubLoop
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|I
operator|!=
name|SLP
operator|->
name|SubLoops
operator|.
name|end
argument_list|()
operator|&&
literal|"SubLoop not a child of parent?"
argument_list|)
expr_stmt|;
name|SLP
operator|->
name|SubLoops
operator|.
name|erase
argument_list|(
name|I
argument_list|)
expr_stmt|;
comment|// Remove from parent...
comment|// Add the subloop to THIS loop...
name|SubLoop
operator|->
name|ParentLoop
operator|=
name|L
expr_stmt|;
name|L
operator|->
name|SubLoops
operator|.
name|push_back
argument_list|(
name|SubLoop
argument_list|)
expr_stmt|;
block|}
comment|// Normal case, add the block to our loop...
name|L
operator|->
name|Blocks
operator|.
name|push_back
argument_list|(
name|X
argument_list|)
expr_stmt|;
typedef|typedef
name|GraphTraits
operator|<
name|Inverse
operator|<
name|BlockT
operator|*
operator|>
expr|>
name|InvBlockTraits
expr_stmt|;
comment|// Add all of the predecessors of X to the end of the work stack...
name|TodoStack
operator|.
name|insert
argument_list|(
name|TodoStack
operator|.
name|end
argument_list|()
argument_list|,
name|InvBlockTraits
operator|::
name|child_begin
argument_list|(
name|X
argument_list|)
argument_list|,
name|InvBlockTraits
operator|::
name|child_end
argument_list|(
name|X
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|// If there are any loops nested within this loop, create them now!
for|for
control|(
name|typename
name|std
operator|::
name|vector
operator|<
name|BlockT
operator|*
operator|>
operator|::
name|iterator
name|I
operator|=
name|L
operator|->
name|Blocks
operator|.
name|begin
argument_list|()
operator|,
name|E
operator|=
name|L
operator|->
name|Blocks
operator|.
name|end
argument_list|()
init|;
name|I
operator|!=
name|E
condition|;
operator|++
name|I
control|)
if|if
condition|(
name|LoopT
modifier|*
name|NewLoop
init|=
name|ConsiderForLoop
argument_list|(
operator|*
name|I
argument_list|,
name|DT
argument_list|)
condition|)
block|{
name|L
operator|->
name|SubLoops
operator|.
name|push_back
argument_list|(
name|NewLoop
argument_list|)
expr_stmt|;
name|NewLoop
operator|->
name|ParentLoop
operator|=
name|L
expr_stmt|;
block|}
comment|// Add the basic blocks that comprise this loop to the BBMap so that this
comment|// loop can be found for them.
comment|//
for|for
control|(
name|typename
name|std
operator|::
name|vector
operator|<
name|BlockT
operator|*
operator|>
operator|::
name|iterator
name|I
operator|=
name|L
operator|->
name|Blocks
operator|.
name|begin
argument_list|()
operator|,
name|E
operator|=
name|L
operator|->
name|Blocks
operator|.
name|end
argument_list|()
init|;
name|I
operator|!=
name|E
condition|;
operator|++
name|I
control|)
name|BBMap
operator|.
name|insert
argument_list|(
name|std
operator|::
name|make_pair
argument_list|(
operator|*
name|I
argument_list|,
name|L
argument_list|)
argument_list|)
expr_stmt|;
comment|// Now that we have a list of all of the child loops of this loop, check to
comment|// see if any of them should actually be nested inside of each other.  We
comment|// can accidentally pull loops our of their parents, so we must make sure to
comment|// organize the loop nests correctly now.
block|{
name|std
operator|::
name|map
operator|<
name|BlockT
operator|*
operator|,
name|LoopT
operator|*
operator|>
name|ContainingLoops
expr_stmt|;
for|for
control|(
name|unsigned
name|i
init|=
literal|0
init|;
name|i
operator|!=
name|L
operator|->
name|SubLoops
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|LoopT
modifier|*
name|Child
init|=
name|L
operator|->
name|SubLoops
index|[
name|i
index|]
decl_stmt|;
name|assert
argument_list|(
name|Child
operator|->
name|getParentLoop
argument_list|()
operator|==
name|L
operator|&&
literal|"Not proper child loop?"
argument_list|)
expr_stmt|;
if|if
condition|(
name|LoopT
modifier|*
name|ContainingLoop
init|=
name|ContainingLoops
index|[
name|Child
operator|->
name|getHeader
argument_list|()
index|]
condition|)
block|{
comment|// If there is already a loop which contains this loop, move this loop
comment|// into the containing loop.
name|MoveSiblingLoopInto
argument_list|(
name|Child
argument_list|,
name|ContainingLoop
argument_list|)
expr_stmt|;
operator|--
name|i
expr_stmt|;
comment|// The loop got removed from the SubLoops list.
block|}
else|else
block|{
comment|// This is currently considered to be a top-level loop.  Check to see
comment|// if any of the contained blocks are loop headers for subloops we
comment|// have already processed.
for|for
control|(
name|unsigned
name|b
init|=
literal|0
init|,
name|e
init|=
name|Child
operator|->
name|Blocks
operator|.
name|size
argument_list|()
init|;
name|b
operator|!=
name|e
condition|;
operator|++
name|b
control|)
block|{
name|LoopT
modifier|*
modifier|&
name|BlockLoop
init|=
name|ContainingLoops
index|[
name|Child
operator|->
name|Blocks
index|[
name|b
index|]
index|]
decl_stmt|;
if|if
condition|(
name|BlockLoop
operator|==
literal|0
condition|)
block|{
comment|// Child block not processed yet...
name|BlockLoop
operator|=
name|Child
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|BlockLoop
operator|!=
name|Child
condition|)
block|{
name|LoopT
modifier|*
name|SubLoop
init|=
name|BlockLoop
decl_stmt|;
comment|// Reparent all of the blocks which used to belong to BlockLoops
for|for
control|(
name|unsigned
name|j
init|=
literal|0
init|,
name|e
init|=
name|SubLoop
operator|->
name|Blocks
operator|.
name|size
argument_list|()
init|;
name|j
operator|!=
name|e
condition|;
operator|++
name|j
control|)
name|ContainingLoops
index|[
name|SubLoop
operator|->
name|Blocks
index|[
name|j
index|]
index|]
operator|=
name|Child
expr_stmt|;
comment|// There is already a loop which contains this block, that means
comment|// that we should reparent the loop which the block is currently
comment|// considered to belong to to be a child of this loop.
name|MoveSiblingLoopInto
argument_list|(
name|SubLoop
argument_list|,
name|Child
argument_list|)
expr_stmt|;
operator|--
name|i
expr_stmt|;
comment|// We just shrunk the SubLoops list.
block|}
block|}
block|}
block|}
block|}
return|return
name|L
return|;
block|}
end_decl_stmt

begin_comment
comment|/// MoveSiblingLoopInto - This method moves the NewChild loop to live inside
end_comment

begin_comment
comment|/// of the NewParent Loop, instead of being a sibling of it.
end_comment

begin_function
name|void
name|MoveSiblingLoopInto
parameter_list|(
name|LoopT
modifier|*
name|NewChild
parameter_list|,
name|LoopT
modifier|*
name|NewParent
parameter_list|)
block|{
name|LoopT
modifier|*
name|OldParent
init|=
name|NewChild
operator|->
name|getParentLoop
argument_list|()
decl_stmt|;
name|assert
argument_list|(
name|OldParent
operator|&&
name|OldParent
operator|==
name|NewParent
operator|->
name|getParentLoop
argument_list|()
operator|&&
name|NewChild
operator|!=
name|NewParent
operator|&&
literal|"Not sibling loops!"
argument_list|)
expr_stmt|;
comment|// Remove NewChild from being a child of OldParent
name|typename
name|std
operator|::
name|vector
operator|<
name|LoopT
operator|*
operator|>
operator|::
name|iterator
name|I
operator|=
name|std
operator|::
name|find
argument_list|(
name|OldParent
operator|->
name|SubLoops
operator|.
name|begin
argument_list|()
argument_list|,
name|OldParent
operator|->
name|SubLoops
operator|.
name|end
argument_list|()
argument_list|,
name|NewChild
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|I
operator|!=
name|OldParent
operator|->
name|SubLoops
operator|.
name|end
argument_list|()
operator|&&
literal|"Parent fields incorrect??"
argument_list|)
expr_stmt|;
name|OldParent
operator|->
name|SubLoops
operator|.
name|erase
argument_list|(
name|I
argument_list|)
expr_stmt|;
comment|// Remove from parent's subloops list
name|NewChild
operator|->
name|ParentLoop
operator|=
literal|0
expr_stmt|;
name|InsertLoopInto
argument_list|(
name|NewChild
argument_list|,
name|NewParent
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/// InsertLoopInto - This inserts loop L into the specified parent loop.  If
end_comment

begin_comment
comment|/// the parent loop contains a loop which should contain L, the loop gets
end_comment

begin_comment
comment|/// inserted into L instead.
end_comment

begin_function
name|void
name|InsertLoopInto
parameter_list|(
name|LoopT
modifier|*
name|L
parameter_list|,
name|LoopT
modifier|*
name|Parent
parameter_list|)
block|{
name|BlockT
modifier|*
name|LHeader
init|=
name|L
operator|->
name|getHeader
argument_list|()
decl_stmt|;
name|assert
argument_list|(
name|Parent
operator|->
name|contains
argument_list|(
name|LHeader
argument_list|)
operator|&&
literal|"This loop should not be inserted here!"
argument_list|)
expr_stmt|;
comment|// Check to see if it belongs in a child loop...
for|for
control|(
name|unsigned
name|i
init|=
literal|0
init|,
name|e
init|=
name|static_cast
operator|<
name|unsigned
operator|>
operator|(
name|Parent
operator|->
name|SubLoops
operator|.
name|size
argument_list|()
operator|)
init|;
name|i
operator|!=
name|e
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|Parent
operator|->
name|SubLoops
index|[
name|i
index|]
operator|->
name|contains
argument_list|(
name|LHeader
argument_list|)
condition|)
block|{
name|InsertLoopInto
argument_list|(
name|L
argument_list|,
name|Parent
operator|->
name|SubLoops
index|[
name|i
index|]
argument_list|)
expr_stmt|;
return|return;
block|}
comment|// If not, insert it here!
name|Parent
operator|->
name|SubLoops
operator|.
name|push_back
argument_list|(
name|L
argument_list|)
expr_stmt|;
name|L
operator|->
name|ParentLoop
operator|=
name|Parent
expr_stmt|;
block|}
end_function

begin_comment
comment|// Debugging
end_comment

begin_decl_stmt
name|void
name|print
argument_list|(
name|raw_ostream
operator|&
name|OS
argument_list|)
decl|const
block|{
for|for
control|(
name|unsigned
name|i
init|=
literal|0
init|;
name|i
operator|<
name|TopLevelLoops
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
name|TopLevelLoops
index|[
name|i
index|]
operator|->
name|print
argument_list|(
name|OS
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|for (std::map<BasicBlock*, LoopT*>::const_iterator I = BBMap.begin(),            E = BBMap.end(); I != E; ++I)       OS<< "BB '"<< I->first->getName()<< "' level = "<< I->second->getLoopDepth()<< "\n";
endif|#
directive|endif
block|}
end_decl_stmt

begin_decl_stmt
unit|};
name|class
name|LoopInfo
range|:
name|public
name|FunctionPass
block|{
name|LoopInfoBase
operator|<
name|BasicBlock
block|,
name|Loop
operator|>
name|LI
block|;
name|friend
name|class
name|LoopBase
operator|<
name|BasicBlock
block|,
name|Loop
operator|>
block|;
name|void
name|operator
operator|=
operator|(
specifier|const
name|LoopInfo
operator|&
operator|)
block|;
comment|// do not implement
name|LoopInfo
argument_list|(
specifier|const
name|LoopInfo
operator|&
argument_list|)
block|;
comment|// do not implement
name|public
operator|:
specifier|static
name|char
name|ID
block|;
comment|// Pass identification, replacement for typeid
name|LoopInfo
argument_list|()
operator|:
name|FunctionPass
argument_list|(
argument|&ID
argument_list|)
block|{}
name|LoopInfoBase
operator|<
name|BasicBlock
block|,
name|Loop
operator|>
operator|&
name|getBase
argument_list|()
block|{
return|return
name|LI
return|;
block|}
comment|/// iterator/begin/end - The interface to the top-level loops in the current
comment|/// function.
comment|///
typedef|typedef
name|LoopInfoBase
operator|<
name|BasicBlock
operator|,
name|Loop
operator|>
operator|::
name|iterator
name|iterator
expr_stmt|;
specifier|inline
name|iterator
name|begin
argument_list|()
specifier|const
block|{
return|return
name|LI
operator|.
name|begin
argument_list|()
return|;
block|}
specifier|inline
name|iterator
name|end
argument_list|()
specifier|const
block|{
return|return
name|LI
operator|.
name|end
argument_list|()
return|;
block|}
name|bool
name|empty
argument_list|()
specifier|const
block|{
return|return
name|LI
operator|.
name|empty
argument_list|()
return|;
block|}
comment|/// getLoopFor - Return the inner most loop that BB lives in.  If a basic
comment|/// block is in no loop (for example the entry node), null is returned.
comment|///
specifier|inline
name|Loop
operator|*
name|getLoopFor
argument_list|(
argument|const BasicBlock *BB
argument_list|)
specifier|const
block|{
return|return
name|LI
operator|.
name|getLoopFor
argument_list|(
name|BB
argument_list|)
return|;
block|}
comment|/// operator[] - same as getLoopFor...
comment|///
specifier|inline
specifier|const
name|Loop
operator|*
name|operator
index|[]
operator|(
specifier|const
name|BasicBlock
operator|*
name|BB
operator|)
specifier|const
block|{
return|return
name|LI
operator|.
name|getLoopFor
argument_list|(
name|BB
argument_list|)
return|;
block|}
comment|/// getLoopDepth - Return the loop nesting level of the specified block.  A
comment|/// depth of 0 means the block is not inside any loop.
comment|///
specifier|inline
name|unsigned
name|getLoopDepth
argument_list|(
argument|const BasicBlock *BB
argument_list|)
specifier|const
block|{
return|return
name|LI
operator|.
name|getLoopDepth
argument_list|(
name|BB
argument_list|)
return|;
block|}
comment|// isLoopHeader - True if the block is a loop header node
specifier|inline
name|bool
name|isLoopHeader
argument_list|(
argument|BasicBlock *BB
argument_list|)
specifier|const
block|{
return|return
name|LI
operator|.
name|isLoopHeader
argument_list|(
name|BB
argument_list|)
return|;
block|}
comment|/// runOnFunction - Calculate the natural loop information.
comment|///
name|virtual
name|bool
name|runOnFunction
argument_list|(
name|Function
operator|&
name|F
argument_list|)
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|virtual
name|void
name|verifyAnalysis
argument_list|()
specifier|const
expr_stmt|;
end_expr_stmt

begin_function
name|virtual
name|void
name|releaseMemory
parameter_list|()
block|{
name|LI
operator|.
name|releaseMemory
argument_list|()
expr_stmt|;
block|}
end_function

begin_decl_stmt
name|virtual
name|void
name|print
argument_list|(
name|raw_ostream
operator|&
name|O
argument_list|,
specifier|const
name|Module
operator|*
name|M
operator|=
literal|0
argument_list|)
decl|const
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|virtual
name|void
name|getAnalysisUsage
argument_list|(
name|AnalysisUsage
operator|&
name|AU
argument_list|)
decl|const
decl_stmt|;
end_decl_stmt

begin_comment
comment|/// removeLoop - This removes the specified top-level loop from this loop info
end_comment

begin_comment
comment|/// object.  The loop is not deleted, as it will presumably be inserted into
end_comment

begin_comment
comment|/// another loop.
end_comment

begin_function
specifier|inline
name|Loop
modifier|*
name|removeLoop
parameter_list|(
name|iterator
name|I
parameter_list|)
block|{
return|return
name|LI
operator|.
name|removeLoop
argument_list|(
name|I
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/// changeLoopFor - Change the top-level loop that contains BB to the
end_comment

begin_comment
comment|/// specified loop.  This should be used by transformations that restructure
end_comment

begin_comment
comment|/// the loop hierarchy tree.
end_comment

begin_function
specifier|inline
name|void
name|changeLoopFor
parameter_list|(
name|BasicBlock
modifier|*
name|BB
parameter_list|,
name|Loop
modifier|*
name|L
parameter_list|)
block|{
name|LI
operator|.
name|changeLoopFor
argument_list|(
name|BB
argument_list|,
name|L
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/// changeTopLevelLoop - Replace the specified loop in the top-level loops
end_comment

begin_comment
comment|/// list with the indicated loop.
end_comment

begin_function
specifier|inline
name|void
name|changeTopLevelLoop
parameter_list|(
name|Loop
modifier|*
name|OldLoop
parameter_list|,
name|Loop
modifier|*
name|NewLoop
parameter_list|)
block|{
name|LI
operator|.
name|changeTopLevelLoop
argument_list|(
name|OldLoop
argument_list|,
name|NewLoop
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/// addTopLevelLoop - This adds the specified loop to the collection of
end_comment

begin_comment
comment|/// top-level loops.
end_comment

begin_function
specifier|inline
name|void
name|addTopLevelLoop
parameter_list|(
name|Loop
modifier|*
name|New
parameter_list|)
block|{
name|LI
operator|.
name|addTopLevelLoop
argument_list|(
name|New
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/// removeBlock - This method completely removes BB from all data structures,
end_comment

begin_comment
comment|/// including all of the Loop objects it is nested in and our mapping from
end_comment

begin_comment
comment|/// BasicBlocks to loops.
end_comment

begin_function
name|void
name|removeBlock
parameter_list|(
name|BasicBlock
modifier|*
name|BB
parameter_list|)
block|{
name|LI
operator|.
name|removeBlock
argument_list|(
name|BB
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
unit|};
comment|// Allow clients to walk the list of nested loops...
end_comment

begin_expr_stmt
name|template
operator|<
operator|>
expr|struct
name|GraphTraits
operator|<
specifier|const
name|Loop
operator|*
operator|>
block|{
typedef|typedef
specifier|const
name|Loop
name|NodeType
typedef|;
end_expr_stmt

begin_typedef
typedef|typedef
name|LoopInfo
operator|::
name|iterator
name|ChildIteratorType
expr_stmt|;
end_typedef

begin_function
specifier|static
name|NodeType
modifier|*
name|getEntryNode
parameter_list|(
specifier|const
name|Loop
modifier|*
name|L
parameter_list|)
block|{
return|return
name|L
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|ChildIteratorType
name|child_begin
parameter_list|(
name|NodeType
modifier|*
name|N
parameter_list|)
block|{
return|return
name|N
operator|->
name|begin
argument_list|()
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|ChildIteratorType
name|child_end
parameter_list|(
name|NodeType
modifier|*
name|N
parameter_list|)
block|{
return|return
name|N
operator|->
name|end
argument_list|()
return|;
block|}
end_function

begin_expr_stmt
unit|};
name|template
operator|<
operator|>
expr|struct
name|GraphTraits
operator|<
name|Loop
operator|*
operator|>
block|{
typedef|typedef
name|Loop
name|NodeType
typedef|;
end_expr_stmt

begin_typedef
typedef|typedef
name|LoopInfo
operator|::
name|iterator
name|ChildIteratorType
expr_stmt|;
end_typedef

begin_function
specifier|static
name|NodeType
modifier|*
name|getEntryNode
parameter_list|(
name|Loop
modifier|*
name|L
parameter_list|)
block|{
return|return
name|L
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|ChildIteratorType
name|child_begin
parameter_list|(
name|NodeType
modifier|*
name|N
parameter_list|)
block|{
return|return
name|N
operator|->
name|begin
argument_list|()
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|ChildIteratorType
name|child_end
parameter_list|(
name|NodeType
modifier|*
name|N
parameter_list|)
block|{
return|return
name|N
operator|->
name|end
argument_list|()
return|;
block|}
end_function

begin_expr_stmt
unit|};
name|template
operator|<
name|class
name|BlockT
operator|,
name|class
name|LoopT
operator|>
name|void
name|LoopBase
operator|<
name|BlockT
operator|,
name|LoopT
operator|>
operator|::
name|addBasicBlockToLoop
argument_list|(
argument|BlockT *NewBB
argument_list|,
argument|LoopInfoBase<BlockT
argument_list|,
argument|LoopT>&LIB
argument_list|)
block|{
name|assert
argument_list|(
operator|(
name|Blocks
operator|.
name|empty
argument_list|()
operator|||
name|LIB
index|[
name|getHeader
argument_list|()
index|]
operator|==
name|this
operator|)
operator|&&
literal|"Incorrect LI specified for this loop!"
argument_list|)
block|;
name|assert
argument_list|(
name|NewBB
operator|&&
literal|"Cannot add a null basic block to the loop!"
argument_list|)
block|;
name|assert
argument_list|(
name|LIB
index|[
name|NewBB
index|]
operator|==
literal|0
operator|&&
literal|"BasicBlock already in the loop!"
argument_list|)
block|;
name|LoopT
operator|*
name|L
operator|=
name|static_cast
operator|<
name|LoopT
operator|*
operator|>
operator|(
name|this
operator|)
block|;
comment|// Add the loop mapping to the LoopInfo object...
name|LIB
operator|.
name|BBMap
index|[
name|NewBB
index|]
operator|=
name|L
block|;
comment|// Add the basic block to this loop and all parent loops...
while|while
condition|(
name|L
condition|)
block|{
name|L
operator|->
name|Blocks
operator|.
name|push_back
argument_list|(
name|NewBB
argument_list|)
expr_stmt|;
name|L
operator|=
name|L
operator|->
name|getParentLoop
argument_list|()
expr_stmt|;
block|}
end_expr_stmt

begin_comment
unit|}  }
comment|// End llvm namespace
end_comment

begin_endif
endif|#
directive|endif
end_endif

end_unit

