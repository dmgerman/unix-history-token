begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===- llvm/Analysis/LoopInfo.h - Natural Loop Calculator -------*- C++ -*-===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file defines the LoopInfo class that is used to identify natural loops
end_comment

begin_comment
comment|// and determine the loop depth of various nodes of the CFG.  Note that natural
end_comment

begin_comment
comment|// loops may actually be several loops that share the same header node.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This analysis calculates the nesting structure of loops in a function.  For
end_comment

begin_comment
comment|// each natural loop identified, this analysis identifies natural loops
end_comment

begin_comment
comment|// contained entirely within the loop and the basic blocks the make up the loop.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// It can calculate on the fly various bits of information, for example:
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//  * whether there is a preheader for the loop
end_comment

begin_comment
comment|//  * the number of back edges to the header
end_comment

begin_comment
comment|//  * whether or not a particular block branches out of the loop
end_comment

begin_comment
comment|//  * the successor blocks of the loop
end_comment

begin_comment
comment|//  * the loop depth
end_comment

begin_comment
comment|//  * the trip count
end_comment

begin_comment
comment|//  * etc...
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LLVM_ANALYSIS_LOOP_INFO_H
end_ifndef

begin_define
define|#
directive|define
name|LLVM_ANALYSIS_LOOP_INFO_H
end_define

begin_include
include|#
directive|include
file|"llvm/Pass.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Constants.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Instructions.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/DepthFirstIterator.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/GraphTraits.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/SmallPtrSet.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/SmallVector.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Analysis/Dominators.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/CFG.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/Streams.h"
end_include

begin_include
include|#
directive|include
file|<algorithm>
end_include

begin_include
include|#
directive|include
file|<ostream>
end_include

begin_decl_stmt
name|namespace
name|llvm
block|{
name|template
operator|<
name|typename
name|T
operator|>
specifier|static
name|void
name|RemoveFromVector
argument_list|(
argument|std::vector<T*>&V
argument_list|,
argument|T *N
argument_list|)
block|{
name|typename
name|std
operator|::
name|vector
operator|<
name|T
operator|*
operator|>
operator|::
name|iterator
name|I
operator|=
name|std
operator|::
name|find
argument_list|(
name|V
operator|.
name|begin
argument_list|()
argument_list|,
name|V
operator|.
name|end
argument_list|()
argument_list|,
name|N
argument_list|)
block|;
name|assert
argument_list|(
name|I
operator|!=
name|V
operator|.
name|end
argument_list|()
operator|&&
literal|"N is not in this list!"
argument_list|)
block|;
name|V
operator|.
name|erase
argument_list|(
name|I
argument_list|)
block|; }
name|class
name|DominatorTree
expr_stmt|;
name|class
name|LoopInfo
decl_stmt|;
name|template
operator|<
name|class
name|N
operator|>
name|class
name|LoopInfoBase
expr_stmt|;
name|template
operator|<
name|class
name|N
operator|>
name|class
name|LoopBase
expr_stmt|;
typedef|typedef
name|LoopBase
operator|<
name|BasicBlock
operator|>
name|Loop
expr_stmt|;
comment|//===----------------------------------------------------------------------===//
comment|/// LoopBase class - Instances of this class are used to represent loops that
comment|/// are detected in the flow graph
comment|///
name|template
operator|<
name|class
name|BlockT
operator|>
name|class
name|LoopBase
block|{
name|LoopBase
operator|<
name|BlockT
operator|>
operator|*
name|ParentLoop
block|;
comment|// SubLoops - Loops contained entirely within this one.
name|std
operator|::
name|vector
operator|<
name|LoopBase
operator|<
name|BlockT
operator|>
operator|*
operator|>
name|SubLoops
block|;
comment|// Blocks - The list of blocks in this loop.  First entry is the header node.
name|std
operator|::
name|vector
operator|<
name|BlockT
operator|*
operator|>
name|Blocks
block|;
name|LoopBase
argument_list|(
specifier|const
name|LoopBase
operator|<
name|BlockT
operator|>
operator|&
argument_list|)
block|;
comment|// DO NOT IMPLEMENT
specifier|const
name|LoopBase
operator|<
name|BlockT
operator|>
operator|&
name|operator
operator|=
operator|(
specifier|const
name|LoopBase
operator|<
name|BlockT
operator|>
operator|&
operator|)
block|;
comment|// DO NOT IMPLEMENT
name|public
operator|:
comment|/// Loop ctor - This creates an empty loop.
name|LoopBase
argument_list|()
operator|:
name|ParentLoop
argument_list|(
literal|0
argument_list|)
block|{}
operator|~
name|LoopBase
argument_list|()
block|{
for|for
control|(
name|size_t
name|i
init|=
literal|0
init|,
name|e
init|=
name|SubLoops
operator|.
name|size
argument_list|()
init|;
name|i
operator|!=
name|e
condition|;
operator|++
name|i
control|)
name|delete
name|SubLoops
index|[
name|i
index|]
decl_stmt|;
block|}
comment|/// getLoopDepth - Return the nesting level of this loop.  An outer-most
comment|/// loop has depth 1, for consistency with loop depth values used for basic
comment|/// blocks, where depth 0 is used for blocks not inside any loops.
name|unsigned
name|getLoopDepth
argument_list|()
specifier|const
block|{
name|unsigned
name|D
operator|=
literal|1
block|;
for|for
control|(
specifier|const
name|LoopBase
operator|<
name|BlockT
operator|>
operator|*
name|CurLoop
operator|=
name|ParentLoop
init|;
name|CurLoop
condition|;
name|CurLoop
operator|=
name|CurLoop
operator|->
name|ParentLoop
control|)
operator|++
name|D
expr_stmt|;
return|return
name|D
return|;
block|}
name|BlockT
operator|*
name|getHeader
argument_list|()
specifier|const
block|{
return|return
name|Blocks
operator|.
name|front
argument_list|()
return|;
block|}
name|LoopBase
operator|<
name|BlockT
operator|>
operator|*
name|getParentLoop
argument_list|()
specifier|const
block|{
return|return
name|ParentLoop
return|;
block|}
comment|/// contains - Return true if the specified basic block is in this loop
comment|///
name|bool
name|contains
argument_list|(
specifier|const
name|BlockT
operator|*
name|BB
argument_list|)
decl|const
block|{
return|return
name|std
operator|::
name|find
argument_list|(
name|block_begin
argument_list|()
argument_list|,
name|block_end
argument_list|()
argument_list|,
name|BB
argument_list|)
operator|!=
name|block_end
argument_list|()
return|;
block|}
comment|/// iterator/begin/end - Return the loops contained entirely within this loop.
comment|///
specifier|const
name|std
operator|::
name|vector
operator|<
name|LoopBase
operator|<
name|BlockT
operator|>
operator|*
operator|>
operator|&
name|getSubLoops
argument_list|()
specifier|const
block|{
return|return
name|SubLoops
return|;
block|}
typedef|typedef
name|typename
name|std
operator|::
name|vector
operator|<
name|LoopBase
operator|<
name|BlockT
operator|>
operator|*
operator|>
operator|::
name|const_iterator
name|iterator
expr_stmt|;
name|iterator
name|begin
argument_list|()
specifier|const
block|{
return|return
name|SubLoops
operator|.
name|begin
argument_list|()
return|;
block|}
name|iterator
name|end
argument_list|()
specifier|const
block|{
return|return
name|SubLoops
operator|.
name|end
argument_list|()
return|;
block|}
name|bool
name|empty
argument_list|()
specifier|const
block|{
return|return
name|SubLoops
operator|.
name|empty
argument_list|()
return|;
block|}
comment|/// getBlocks - Get a list of the basic blocks which make up this loop.
comment|///
specifier|const
name|std
operator|::
name|vector
operator|<
name|BlockT
operator|*
operator|>
operator|&
name|getBlocks
argument_list|()
specifier|const
block|{
return|return
name|Blocks
return|;
block|}
typedef|typedef
name|typename
name|std
operator|::
name|vector
operator|<
name|BlockT
operator|*
operator|>
operator|::
name|const_iterator
name|block_iterator
expr_stmt|;
name|block_iterator
name|block_begin
argument_list|()
specifier|const
block|{
return|return
name|Blocks
operator|.
name|begin
argument_list|()
return|;
block|}
name|block_iterator
name|block_end
argument_list|()
specifier|const
block|{
return|return
name|Blocks
operator|.
name|end
argument_list|()
return|;
block|}
comment|/// isLoopExit - True if terminator in the block can branch to another block
comment|/// that is outside of the current loop.
comment|///
name|bool
name|isLoopExit
argument_list|(
specifier|const
name|BlockT
operator|*
name|BB
argument_list|)
decl|const
block|{
typedef|typedef
name|GraphTraits
operator|<
name|BlockT
operator|*
operator|>
name|BlockTraits
expr_stmt|;
for|for
control|(
name|typename
name|BlockTraits
operator|::
name|ChildIteratorType
name|SI
operator|=
name|BlockTraits
operator|::
name|child_begin
argument_list|(
name|const_cast
operator|<
name|BlockT
operator|*
operator|>
operator|(
name|BB
operator|)
argument_list|)
operator|,
name|SE
operator|=
name|BlockTraits
operator|::
name|child_end
argument_list|(
name|const_cast
operator|<
name|BlockT
operator|*
operator|>
operator|(
name|BB
operator|)
argument_list|)
init|;
name|SI
operator|!=
name|SE
condition|;
operator|++
name|SI
control|)
block|{
if|if
condition|(
operator|!
name|contains
argument_list|(
operator|*
name|SI
argument_list|)
condition|)
return|return
name|true
return|;
block|}
return|return
name|false
return|;
block|}
comment|/// getNumBackEdges - Calculate the number of back edges to the loop header
comment|///
name|unsigned
name|getNumBackEdges
argument_list|()
specifier|const
block|{
name|unsigned
name|NumBackEdges
operator|=
literal|0
block|;
name|BlockT
operator|*
name|H
operator|=
name|getHeader
argument_list|()
block|;
typedef|typedef
name|GraphTraits
operator|<
name|Inverse
operator|<
name|BlockT
operator|*
operator|>
expr|>
name|InvBlockTraits
expr_stmt|;
for|for
control|(
name|typename
name|InvBlockTraits
operator|::
name|ChildIteratorType
name|I
operator|=
name|InvBlockTraits
operator|::
name|child_begin
argument_list|(
name|const_cast
operator|<
name|BlockT
operator|*
operator|>
operator|(
name|H
operator|)
argument_list|)
operator|,
name|E
operator|=
name|InvBlockTraits
operator|::
name|child_end
argument_list|(
name|const_cast
operator|<
name|BlockT
operator|*
operator|>
operator|(
name|H
operator|)
argument_list|)
init|;
name|I
operator|!=
name|E
condition|;
operator|++
name|I
control|)
if|if
condition|(
name|contains
argument_list|(
operator|*
name|I
argument_list|)
condition|)
operator|++
name|NumBackEdges
expr_stmt|;
return|return
name|NumBackEdges
return|;
block|}
end_decl_stmt

begin_comment
comment|/// isLoopInvariant - Return true if the specified value is loop invariant
end_comment

begin_comment
comment|///
end_comment

begin_decl_stmt
specifier|inline
name|bool
name|isLoopInvariant
argument_list|(
name|Value
operator|*
name|V
argument_list|)
decl|const
block|{
if|if
condition|(
name|Instruction
modifier|*
name|I
init|=
name|dyn_cast
operator|<
name|Instruction
operator|>
operator|(
name|V
operator|)
condition|)
return|return
operator|!
name|contains
argument_list|(
name|I
operator|->
name|getParent
argument_list|()
argument_list|)
return|;
return|return
name|true
return|;
comment|// All non-instructions are loop invariant
block|}
end_decl_stmt

begin_comment
comment|//===--------------------------------------------------------------------===//
end_comment

begin_comment
comment|// APIs for simple analysis of the loop.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// Note that all of these methods can fail on general loops (ie, there may not
end_comment

begin_comment
comment|// be a preheader, etc).  For best success, the loop simplification and
end_comment

begin_comment
comment|// induction variable canonicalization pass should be used to normalize loops
end_comment

begin_comment
comment|// for easy analysis.  These methods assume canonical loops.
end_comment

begin_comment
comment|/// getExitingBlocks - Return all blocks inside the loop that have successors
end_comment

begin_comment
comment|/// outside of the loop.  These are the blocks _inside of the current loop_
end_comment

begin_comment
comment|/// which branch out.  The returned list is always unique.
end_comment

begin_comment
comment|///
end_comment

begin_decl_stmt
name|void
name|getExitingBlocks
argument_list|(
name|SmallVectorImpl
operator|<
name|BlockT
operator|*
operator|>
operator|&
name|ExitingBlocks
argument_list|)
decl|const
block|{
comment|// Sort the blocks vector so that we can use binary search to do quick
comment|// lookups.
name|SmallVector
operator|<
name|BlockT
operator|*
operator|,
literal|128
operator|>
name|LoopBBs
argument_list|(
name|block_begin
argument_list|()
argument_list|,
name|block_end
argument_list|()
argument_list|)
expr_stmt|;
name|std
operator|::
name|sort
argument_list|(
name|LoopBBs
operator|.
name|begin
argument_list|()
argument_list|,
name|LoopBBs
operator|.
name|end
argument_list|()
argument_list|)
expr_stmt|;
typedef|typedef
name|GraphTraits
operator|<
name|BlockT
operator|*
operator|>
name|BlockTraits
expr_stmt|;
for|for
control|(
name|block_iterator
name|BI
init|=
name|block_begin
argument_list|()
init|,
name|BE
init|=
name|block_end
argument_list|()
init|;
name|BI
operator|!=
name|BE
condition|;
operator|++
name|BI
control|)
for|for
control|(
name|typename
name|BlockTraits
operator|::
name|ChildIteratorType
name|I
operator|=
name|BlockTraits
operator|::
name|child_begin
argument_list|(
operator|*
name|BI
argument_list|)
operator|,
name|E
operator|=
name|BlockTraits
operator|::
name|child_end
argument_list|(
operator|*
name|BI
argument_list|)
init|;
name|I
operator|!=
name|E
condition|;
operator|++
name|I
control|)
if|if
condition|(
operator|!
name|std
operator|::
name|binary_search
argument_list|(
name|LoopBBs
operator|.
name|begin
argument_list|()
argument_list|,
name|LoopBBs
operator|.
name|end
argument_list|()
argument_list|,
operator|*
name|I
argument_list|)
condition|)
block|{
comment|// Not in current loop? It must be an exit block.
name|ExitingBlocks
operator|.
name|push_back
argument_list|(
operator|*
name|BI
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_decl_stmt

begin_comment
comment|/// getExitingBlock - If getExitingBlocks would return exactly one block,
end_comment

begin_comment
comment|/// return that block. Otherwise return null.
end_comment

begin_expr_stmt
name|BlockT
operator|*
name|getExitingBlock
argument_list|()
specifier|const
block|{
name|SmallVector
operator|<
name|BlockT
operator|*
block|,
literal|8
operator|>
name|ExitingBlocks
block|;
name|getExitingBlocks
argument_list|(
name|ExitingBlocks
argument_list|)
block|;
if|if
condition|(
name|ExitingBlocks
operator|.
name|size
argument_list|()
operator|==
literal|1
condition|)
return|return
name|ExitingBlocks
index|[
literal|0
index|]
return|;
end_expr_stmt

begin_return
return|return
literal|0
return|;
end_return

begin_comment
unit|}
comment|/// getExitBlocks - Return all of the successor blocks of this loop.  These
end_comment

begin_comment
comment|/// are the blocks _outside of the current loop_ which are branched to.
end_comment

begin_comment
comment|///
end_comment

begin_macro
unit|void
name|getExitBlocks
argument_list|(
argument|SmallVectorImpl<BlockT*>&ExitBlocks
argument_list|)
end_macro

begin_expr_stmt
specifier|const
block|{
comment|// Sort the blocks vector so that we can use binary search to do quick
comment|// lookups.
name|SmallVector
operator|<
name|BlockT
operator|*
block|,
literal|128
operator|>
name|LoopBBs
argument_list|(
name|block_begin
argument_list|()
argument_list|,
name|block_end
argument_list|()
argument_list|)
block|;
name|std
operator|::
name|sort
argument_list|(
name|LoopBBs
operator|.
name|begin
argument_list|()
argument_list|,
name|LoopBBs
operator|.
name|end
argument_list|()
argument_list|)
block|;
typedef|typedef
name|GraphTraits
operator|<
name|BlockT
operator|*
operator|>
name|BlockTraits
expr_stmt|;
end_expr_stmt

begin_for
for|for
control|(
name|block_iterator
name|BI
init|=
name|block_begin
argument_list|()
init|,
name|BE
init|=
name|block_end
argument_list|()
init|;
name|BI
operator|!=
name|BE
condition|;
operator|++
name|BI
control|)
for|for
control|(
name|typename
name|BlockTraits
operator|::
name|ChildIteratorType
name|I
operator|=
name|BlockTraits
operator|::
name|child_begin
argument_list|(
operator|*
name|BI
argument_list|)
operator|,
name|E
operator|=
name|BlockTraits
operator|::
name|child_end
argument_list|(
operator|*
name|BI
argument_list|)
init|;
name|I
operator|!=
name|E
condition|;
operator|++
name|I
control|)
if|if
condition|(
operator|!
name|std
operator|::
name|binary_search
argument_list|(
name|LoopBBs
operator|.
name|begin
argument_list|()
argument_list|,
name|LoopBBs
operator|.
name|end
argument_list|()
argument_list|,
operator|*
name|I
argument_list|)
condition|)
comment|// Not in current loop? It must be an exit block.
name|ExitBlocks
operator|.
name|push_back
argument_list|(
operator|*
name|I
argument_list|)
expr_stmt|;
end_for

begin_comment
unit|}
comment|/// getExitBlock - If getExitBlocks would return exactly one block,
end_comment

begin_comment
comment|/// return that block. Otherwise return null.
end_comment

begin_expr_stmt
unit|BlockT
operator|*
name|getExitBlock
argument_list|()
specifier|const
block|{
name|SmallVector
operator|<
name|BlockT
operator|*
block|,
literal|8
operator|>
name|ExitBlocks
block|;
name|getExitBlocks
argument_list|(
name|ExitBlocks
argument_list|)
block|;
if|if
condition|(
name|ExitBlocks
operator|.
name|size
argument_list|()
operator|==
literal|1
condition|)
return|return
name|ExitBlocks
index|[
literal|0
index|]
return|;
end_expr_stmt

begin_return
return|return
literal|0
return|;
end_return

begin_comment
unit|}
comment|/// getUniqueExitBlocks - Return all unique successor blocks of this loop.
end_comment

begin_comment
comment|/// These are the blocks _outside of the current loop_ which are branched to.
end_comment

begin_comment
comment|/// This assumes that loop is in canonical form.
end_comment

begin_comment
comment|///
end_comment

begin_macro
unit|void
name|getUniqueExitBlocks
argument_list|(
argument|SmallVectorImpl<BlockT*>&ExitBlocks
argument_list|)
end_macro

begin_expr_stmt
specifier|const
block|{
comment|// Sort the blocks vector so that we can use binary search to do quick
comment|// lookups.
name|SmallVector
operator|<
name|BlockT
operator|*
block|,
literal|128
operator|>
name|LoopBBs
argument_list|(
name|block_begin
argument_list|()
argument_list|,
name|block_end
argument_list|()
argument_list|)
block|;
name|std
operator|::
name|sort
argument_list|(
name|LoopBBs
operator|.
name|begin
argument_list|()
argument_list|,
name|LoopBBs
operator|.
name|end
argument_list|()
argument_list|)
block|;
name|std
operator|::
name|vector
operator|<
name|BlockT
operator|*
operator|>
name|switchExitBlocks
block|;
for|for
control|(
name|block_iterator
name|BI
init|=
name|block_begin
argument_list|()
init|,
name|BE
init|=
name|block_end
argument_list|()
init|;
name|BI
operator|!=
name|BE
condition|;
operator|++
name|BI
control|)
block|{
name|BlockT
modifier|*
name|current
init|=
operator|*
name|BI
decl_stmt|;
name|switchExitBlocks
operator|.
name|clear
argument_list|()
expr_stmt|;
typedef|typedef
name|GraphTraits
operator|<
name|BlockT
operator|*
operator|>
name|BlockTraits
expr_stmt|;
typedef|typedef
name|GraphTraits
operator|<
name|Inverse
operator|<
name|BlockT
operator|*
operator|>
expr|>
name|InvBlockTraits
expr_stmt|;
for|for
control|(
name|typename
name|BlockTraits
operator|::
name|ChildIteratorType
name|I
operator|=
name|BlockTraits
operator|::
name|child_begin
argument_list|(
operator|*
name|BI
argument_list|)
operator|,
name|E
operator|=
name|BlockTraits
operator|::
name|child_end
argument_list|(
operator|*
name|BI
argument_list|)
init|;
name|I
operator|!=
name|E
condition|;
operator|++
name|I
control|)
block|{
if|if
condition|(
name|std
operator|::
name|binary_search
argument_list|(
name|LoopBBs
operator|.
name|begin
argument_list|()
argument_list|,
name|LoopBBs
operator|.
name|end
argument_list|()
argument_list|,
operator|*
name|I
argument_list|)
condition|)
comment|// If block is inside the loop then it is not a exit block.
continue|continue;
name|typename
name|InvBlockTraits
operator|::
name|ChildIteratorType
name|PI
operator|=
name|InvBlockTraits
operator|::
name|child_begin
argument_list|(
operator|*
name|I
argument_list|)
expr_stmt|;
name|BlockT
modifier|*
name|firstPred
init|=
operator|*
name|PI
decl_stmt|;
comment|// If current basic block is this exit block's first predecessor
comment|// then only insert exit block in to the output ExitBlocks vector.
comment|// This ensures that same exit block is not inserted twice into
comment|// ExitBlocks vector.
if|if
condition|(
name|current
operator|!=
name|firstPred
condition|)
continue|continue;
comment|// If a terminator has more then two successors, for example SwitchInst,
comment|// then it is possible that there are multiple edges from current block
comment|// to one exit block.
if|if
condition|(
name|std
operator|::
name|distance
argument_list|(
name|BlockTraits
operator|::
name|child_begin
argument_list|(
name|current
argument_list|)
argument_list|,
name|BlockTraits
operator|::
name|child_end
argument_list|(
name|current
argument_list|)
argument_list|)
operator|<=
literal|2
condition|)
block|{
name|ExitBlocks
operator|.
name|push_back
argument_list|(
operator|*
name|I
argument_list|)
expr_stmt|;
continue|continue;
block|}
end_expr_stmt

begin_comment
comment|// In case of multiple edges from current block to exit block, collect
end_comment

begin_comment
comment|// only one edge in ExitBlocks. Use switchExitBlocks to keep track of
end_comment

begin_comment
comment|// duplicate edges.
end_comment

begin_if
if|if
condition|(
name|std
operator|::
name|find
argument_list|(
name|switchExitBlocks
operator|.
name|begin
argument_list|()
argument_list|,
name|switchExitBlocks
operator|.
name|end
argument_list|()
argument_list|,
operator|*
name|I
argument_list|)
operator|==
name|switchExitBlocks
operator|.
name|end
argument_list|()
condition|)
block|{
name|switchExitBlocks
operator|.
name|push_back
argument_list|(
operator|*
name|I
argument_list|)
expr_stmt|;
name|ExitBlocks
operator|.
name|push_back
argument_list|(
operator|*
name|I
argument_list|)
expr_stmt|;
block|}
end_if

begin_comment
unit|}     }   }
comment|/// getUniqueExitBlock - If getUniqueExitBlocks would return exactly one
end_comment

begin_comment
comment|/// block, return that block. Otherwise return null.
end_comment

begin_expr_stmt
unit|BlockT
operator|*
name|getUniqueExitBlock
argument_list|()
specifier|const
block|{
name|SmallVector
operator|<
name|BlockT
operator|*
block|,
literal|8
operator|>
name|UniqueExitBlocks
block|;
name|getUniqueExitBlocks
argument_list|(
name|UniqueExitBlocks
argument_list|)
block|;
if|if
condition|(
name|UniqueExitBlocks
operator|.
name|size
argument_list|()
operator|==
literal|1
condition|)
return|return
name|UniqueExitBlocks
index|[
literal|0
index|]
return|;
end_expr_stmt

begin_return
return|return
literal|0
return|;
end_return

begin_comment
unit|}
comment|/// getLoopPreheader - If there is a preheader for this loop, return it.  A
end_comment

begin_comment
comment|/// loop has a preheader if there is only one edge to the header of the loop
end_comment

begin_comment
comment|/// from outside of the loop.  If this is the case, the block branching to the
end_comment

begin_comment
comment|/// header of the loop is the preheader node.
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|/// This method returns null if there is no preheader for the loop.
end_comment

begin_comment
comment|///
end_comment

begin_expr_stmt
unit|BlockT
operator|*
name|getLoopPreheader
argument_list|()
specifier|const
block|{
comment|// Keep track of nodes outside the loop branching to the header...
name|BlockT
operator|*
name|Out
operator|=
literal|0
block|;
comment|// Loop over the predecessors of the header node...
name|BlockT
operator|*
name|Header
operator|=
name|getHeader
argument_list|()
block|;
typedef|typedef
name|GraphTraits
operator|<
name|BlockT
operator|*
operator|>
name|BlockTraits
expr_stmt|;
end_expr_stmt

begin_typedef
typedef|typedef
name|GraphTraits
operator|<
name|Inverse
operator|<
name|BlockT
operator|*
operator|>
expr|>
name|InvBlockTraits
expr_stmt|;
end_typedef

begin_for
for|for
control|(
name|typename
name|InvBlockTraits
operator|::
name|ChildIteratorType
name|PI
operator|=
name|InvBlockTraits
operator|::
name|child_begin
argument_list|(
name|Header
argument_list|)
operator|,
name|PE
operator|=
name|InvBlockTraits
operator|::
name|child_end
argument_list|(
name|Header
argument_list|)
init|;
name|PI
operator|!=
name|PE
condition|;
operator|++
name|PI
control|)
if|if
condition|(
operator|!
name|contains
argument_list|(
operator|*
name|PI
argument_list|)
condition|)
block|{
comment|// If the block is not in the loop...
if|if
condition|(
name|Out
operator|&&
name|Out
operator|!=
operator|*
name|PI
condition|)
return|return
literal|0
return|;
comment|// Multiple predecessors outside the loop
name|Out
operator|=
operator|*
name|PI
expr_stmt|;
block|}
end_for

begin_comment
comment|// Make sure there is only one exit out of the preheader.
end_comment

begin_expr_stmt
name|assert
argument_list|(
name|Out
operator|&&
literal|"Header of loop has no predecessors from outside loop?"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|typename
name|BlockTraits
operator|::
name|ChildIteratorType
name|SI
operator|=
name|BlockTraits
operator|::
name|child_begin
argument_list|(
name|Out
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
operator|++
name|SI
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|SI
operator|!=
name|BlockTraits
operator|::
name|child_end
argument_list|(
name|Out
argument_list|)
condition|)
return|return
literal|0
return|;
end_if

begin_comment
comment|// Multiple exits from the block, must not be a preheader.
end_comment

begin_comment
comment|// If there is exactly one preheader, return it.  If there was zero, then
end_comment

begin_comment
comment|// Out is still null.
end_comment

begin_return
return|return
name|Out
return|;
end_return

begin_comment
unit|}
comment|/// getLoopLatch - If there is a single latch block for this loop, return it.
end_comment

begin_comment
comment|/// A latch block is a block that contains a branch back to the header.
end_comment

begin_comment
comment|/// A loop header in normal form has two edges into it: one from a preheader
end_comment

begin_comment
comment|/// and one from a latch block.
end_comment

begin_expr_stmt
unit|BlockT
operator|*
name|getLoopLatch
argument_list|()
specifier|const
block|{
name|BlockT
operator|*
name|Header
operator|=
name|getHeader
argument_list|()
block|;
typedef|typedef
name|GraphTraits
operator|<
name|Inverse
operator|<
name|BlockT
operator|*
operator|>
expr|>
name|InvBlockTraits
expr_stmt|;
name|typename
name|InvBlockTraits
operator|::
name|ChildIteratorType
name|PI
operator|=
name|InvBlockTraits
operator|::
name|child_begin
argument_list|(
name|Header
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|typename
name|InvBlockTraits
operator|::
name|ChildIteratorType
name|PE
operator|=
name|InvBlockTraits
operator|::
name|child_end
argument_list|(
name|Header
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|PI
operator|==
name|PE
condition|)
return|return
literal|0
return|;
end_if

begin_comment
comment|// no preds?
end_comment

begin_decl_stmt
name|BlockT
modifier|*
name|Latch
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_if
if|if
condition|(
name|contains
argument_list|(
operator|*
name|PI
argument_list|)
condition|)
name|Latch
operator|=
operator|*
name|PI
expr_stmt|;
end_if

begin_expr_stmt
operator|++
name|PI
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|PI
operator|==
name|PE
condition|)
return|return
literal|0
return|;
end_if

begin_comment
comment|// only one pred?
end_comment

begin_if
if|if
condition|(
name|contains
argument_list|(
operator|*
name|PI
argument_list|)
condition|)
block|{
if|if
condition|(
name|Latch
condition|)
return|return
literal|0
return|;
comment|// multiple backedges
name|Latch
operator|=
operator|*
name|PI
expr_stmt|;
block|}
end_if

begin_expr_stmt
operator|++
name|PI
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|PI
operator|!=
name|PE
condition|)
return|return
literal|0
return|;
end_if

begin_comment
comment|// more than two preds
end_comment

begin_return
return|return
name|Latch
return|;
end_return

begin_comment
unit|}
comment|/// getCanonicalInductionVariable - Check to see if the loop has a canonical
end_comment

begin_comment
comment|/// induction variable: an integer recurrence that starts at 0 and increments
end_comment

begin_comment
comment|/// by one each time through the loop.  If so, return the phi node that
end_comment

begin_comment
comment|/// corresponds to it.
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|/// The IndVarSimplify pass transforms loops to have a canonical induction
end_comment

begin_comment
comment|/// variable.
end_comment

begin_comment
comment|///
end_comment

begin_expr_stmt
unit|inline
name|PHINode
operator|*
name|getCanonicalInductionVariable
argument_list|()
specifier|const
block|{
name|BlockT
operator|*
name|H
operator|=
name|getHeader
argument_list|()
block|;
name|BlockT
operator|*
name|Incoming
operator|=
literal|0
block|,
operator|*
name|Backedge
operator|=
literal|0
block|;
typedef|typedef
name|GraphTraits
operator|<
name|Inverse
operator|<
name|BlockT
operator|*
operator|>
expr|>
name|InvBlockTraits
expr_stmt|;
name|typename
name|InvBlockTraits
operator|::
name|ChildIteratorType
name|PI
operator|=
name|InvBlockTraits
operator|::
name|child_begin
argument_list|(
name|H
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|assert
argument_list|(
name|PI
operator|!=
name|InvBlockTraits
operator|::
name|child_end
argument_list|(
name|H
argument_list|)
operator|&&
literal|"Loop must have at least one backedge!"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|Backedge
operator|=
operator|*
name|PI
operator|++
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|PI
operator|==
name|InvBlockTraits
operator|::
name|child_end
argument_list|(
name|H
argument_list|)
condition|)
return|return
literal|0
return|;
end_if

begin_comment
comment|// dead loop
end_comment

begin_expr_stmt
name|Incoming
operator|=
operator|*
name|PI
operator|++
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|PI
operator|!=
name|InvBlockTraits
operator|::
name|child_end
argument_list|(
name|H
argument_list|)
condition|)
return|return
literal|0
return|;
end_if

begin_comment
comment|// multiple backedges?
end_comment

begin_if
if|if
condition|(
name|contains
argument_list|(
name|Incoming
argument_list|)
condition|)
block|{
if|if
condition|(
name|contains
argument_list|(
name|Backedge
argument_list|)
condition|)
return|return
literal|0
return|;
name|std
operator|::
name|swap
argument_list|(
name|Incoming
argument_list|,
name|Backedge
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|contains
argument_list|(
name|Backedge
argument_list|)
condition|)
return|return
literal|0
return|;
end_if

begin_comment
comment|// Loop over all of the PHI nodes, looking for a canonical indvar.
end_comment

begin_for
for|for
control|(
name|typename
name|BlockT
operator|::
name|iterator
name|I
operator|=
name|H
operator|->
name|begin
argument_list|()
init|;
name|isa
operator|<
name|PHINode
operator|>
operator|(
name|I
operator|)
condition|;
operator|++
name|I
control|)
block|{
name|PHINode
modifier|*
name|PN
init|=
name|cast
operator|<
name|PHINode
operator|>
operator|(
name|I
operator|)
decl_stmt|;
if|if
condition|(
name|ConstantInt
modifier|*
name|CI
init|=
name|dyn_cast
operator|<
name|ConstantInt
operator|>
operator|(
name|PN
operator|->
name|getIncomingValueForBlock
argument_list|(
name|Incoming
argument_list|)
operator|)
condition|)
if|if
condition|(
name|CI
operator|->
name|isNullValue
argument_list|()
condition|)
if|if
condition|(
name|Instruction
modifier|*
name|Inc
init|=
name|dyn_cast
operator|<
name|Instruction
operator|>
operator|(
name|PN
operator|->
name|getIncomingValueForBlock
argument_list|(
name|Backedge
argument_list|)
operator|)
condition|)
if|if
condition|(
name|Inc
operator|->
name|getOpcode
argument_list|()
operator|==
name|Instruction
operator|::
name|Add
operator|&&
name|Inc
operator|->
name|getOperand
argument_list|(
literal|0
argument_list|)
operator|==
name|PN
condition|)
if|if
condition|(
name|ConstantInt
modifier|*
name|CI
init|=
name|dyn_cast
operator|<
name|ConstantInt
operator|>
operator|(
name|Inc
operator|->
name|getOperand
argument_list|(
literal|1
argument_list|)
operator|)
condition|)
if|if
condition|(
name|CI
operator|->
name|equalsInt
argument_list|(
literal|1
argument_list|)
condition|)
return|return
name|PN
return|;
block|}
end_for

begin_return
return|return
literal|0
return|;
end_return

begin_comment
unit|}
comment|/// getCanonicalInductionVariableIncrement - Return the LLVM value that holds
end_comment

begin_comment
comment|/// the canonical induction variable value for the "next" iteration of the
end_comment

begin_comment
comment|/// loop.  This always succeeds if getCanonicalInductionVariable succeeds.
end_comment

begin_comment
comment|///
end_comment

begin_expr_stmt
unit|inline
name|Instruction
operator|*
name|getCanonicalInductionVariableIncrement
argument_list|()
specifier|const
block|{
if|if
condition|(
name|PHINode
modifier|*
name|PN
init|=
name|getCanonicalInductionVariable
argument_list|()
condition|)
block|{
name|bool
name|P1InLoop
init|=
name|contains
argument_list|(
name|PN
operator|->
name|getIncomingBlock
argument_list|(
literal|1
argument_list|)
argument_list|)
decl_stmt|;
return|return
name|cast
operator|<
name|Instruction
operator|>
operator|(
name|PN
operator|->
name|getIncomingValue
argument_list|(
name|P1InLoop
argument_list|)
operator|)
return|;
block|}
end_expr_stmt

begin_return
return|return
literal|0
return|;
end_return

begin_comment
unit|}
comment|/// getTripCount - Return a loop-invariant LLVM value indicating the number of
end_comment

begin_comment
comment|/// times the loop will be executed.  Note that this means that the backedge
end_comment

begin_comment
comment|/// of the loop executes N-1 times.  If the trip-count cannot be determined,
end_comment

begin_comment
comment|/// this returns null.
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|/// The IndVarSimplify pass transforms loops to have a form that this
end_comment

begin_comment
comment|/// function easily understands.
end_comment

begin_comment
comment|///
end_comment

begin_expr_stmt
unit|inline
name|Value
operator|*
name|getTripCount
argument_list|()
specifier|const
block|{
comment|// Canonical loops will end with a 'cmp ne I, V', where I is the incremented
comment|// canonical induction variable and V is the trip count of the loop.
name|Instruction
operator|*
name|Inc
operator|=
name|getCanonicalInductionVariableIncrement
argument_list|()
block|;
if|if
condition|(
name|Inc
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|PHINode
operator|*
name|IV
operator|=
name|cast
operator|<
name|PHINode
operator|>
operator|(
name|Inc
operator|->
name|getOperand
argument_list|(
literal|0
argument_list|)
operator|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|BlockT
modifier|*
name|BackedgeBlock
init|=
name|IV
operator|->
name|getIncomingBlock
argument_list|(
name|contains
argument_list|(
name|IV
operator|->
name|getIncomingBlock
argument_list|(
literal|1
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_if
if|if
condition|(
name|BranchInst
modifier|*
name|BI
init|=
name|dyn_cast
operator|<
name|BranchInst
operator|>
operator|(
name|BackedgeBlock
operator|->
name|getTerminator
argument_list|()
operator|)
condition|)
if|if
condition|(
name|BI
operator|->
name|isConditional
argument_list|()
condition|)
block|{
if|if
condition|(
name|ICmpInst
modifier|*
name|ICI
init|=
name|dyn_cast
operator|<
name|ICmpInst
operator|>
operator|(
name|BI
operator|->
name|getCondition
argument_list|()
operator|)
condition|)
block|{
if|if
condition|(
name|ICI
operator|->
name|getOperand
argument_list|(
literal|0
argument_list|)
operator|==
name|Inc
condition|)
block|{
if|if
condition|(
name|BI
operator|->
name|getSuccessor
argument_list|(
literal|0
argument_list|)
operator|==
name|getHeader
argument_list|()
condition|)
block|{
if|if
condition|(
name|ICI
operator|->
name|getPredicate
argument_list|()
operator|==
name|ICmpInst
operator|::
name|ICMP_NE
condition|)
return|return
name|ICI
operator|->
name|getOperand
argument_list|(
literal|1
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|ICI
operator|->
name|getPredicate
argument_list|()
operator|==
name|ICmpInst
operator|::
name|ICMP_EQ
condition|)
block|{
return|return
name|ICI
operator|->
name|getOperand
argument_list|(
literal|1
argument_list|)
return|;
block|}
block|}
block|}
block|}
end_if

begin_return
return|return
literal|0
return|;
end_return

begin_comment
unit|}
comment|/// getSmallConstantTripCount - Returns the trip count of this loop as a
end_comment

begin_comment
comment|/// normal unsigned value, if possible. Returns 0 if the trip count is unknown
end_comment

begin_comment
comment|/// of not constant. Will also return 0 if the trip count is very large
end_comment

begin_comment
comment|/// (>= 2^32)
end_comment

begin_expr_stmt
unit|inline
name|unsigned
name|getSmallConstantTripCount
argument_list|()
specifier|const
block|{
name|Value
operator|*
name|TripCount
operator|=
name|this
operator|->
name|getTripCount
argument_list|()
block|;
if|if
condition|(
name|TripCount
condition|)
block|{
if|if
condition|(
name|ConstantInt
modifier|*
name|TripCountC
init|=
name|dyn_cast
operator|<
name|ConstantInt
operator|>
operator|(
name|TripCount
operator|)
condition|)
block|{
comment|// Guard against huge trip counts.
if|if
condition|(
name|TripCountC
operator|->
name|getValue
argument_list|()
operator|.
name|getActiveBits
argument_list|()
operator|<=
literal|32
condition|)
block|{
return|return
operator|(
name|unsigned
operator|)
name|TripCountC
operator|->
name|getZExtValue
argument_list|()
return|;
block|}
end_expr_stmt

begin_return
unit|}     }
return|return
literal|0
return|;
end_return

begin_comment
unit|}
comment|/// getSmallConstantTripMultiple - Returns the largest constant divisor of the
end_comment

begin_comment
comment|/// trip count of this loop as a normal unsigned value, if possible. This
end_comment

begin_comment
comment|/// means that the actual trip count is always a multiple of the returned
end_comment

begin_comment
comment|/// value (don't forget the trip count could very well be zero as well!).
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|/// Returns 1 if the trip count is unknown or not guaranteed to be the
end_comment

begin_comment
comment|/// multiple of a constant (which is also the case if the trip count is simply
end_comment

begin_comment
comment|/// constant, use getSmallConstantTripCount for that case), Will also return 1
end_comment

begin_comment
comment|/// if the trip count is very large (>= 2^32).
end_comment

begin_expr_stmt
unit|inline
name|unsigned
name|getSmallConstantTripMultiple
argument_list|()
specifier|const
block|{
name|Value
operator|*
name|TripCount
operator|=
name|this
operator|->
name|getTripCount
argument_list|()
block|;
comment|// This will hold the ConstantInt result, if any
name|ConstantInt
operator|*
name|Result
operator|=
name|NULL
block|;
if|if
condition|(
name|TripCount
condition|)
block|{
comment|// See if the trip count is constant itself
name|Result
operator|=
name|dyn_cast
operator|<
name|ConstantInt
operator|>
operator|(
name|TripCount
operator|)
expr_stmt|;
comment|// if not, see if it is a multiplication
if|if
condition|(
operator|!
name|Result
condition|)
if|if
condition|(
name|BinaryOperator
modifier|*
name|BO
init|=
name|dyn_cast
operator|<
name|BinaryOperator
operator|>
operator|(
name|TripCount
operator|)
condition|)
block|{
switch|switch
condition|(
name|BO
operator|->
name|getOpcode
argument_list|()
condition|)
block|{
case|case
name|BinaryOperator
operator|::
name|Mul
case|:
name|Result
operator|=
name|dyn_cast
operator|<
name|ConstantInt
operator|>
operator|(
name|BO
operator|->
name|getOperand
argument_list|(
literal|1
argument_list|)
operator|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
end_expr_stmt

begin_comment
unit|}     }
comment|// Guard against huge trip counts.
end_comment

begin_if
if|if
condition|(
name|Result
operator|&&
name|Result
operator|->
name|getValue
argument_list|()
operator|.
name|getActiveBits
argument_list|()
operator|<=
literal|32
condition|)
block|{
return|return
operator|(
name|unsigned
operator|)
name|Result
operator|->
name|getZExtValue
argument_list|()
return|;
block|}
else|else
block|{
return|return
literal|1
return|;
block|}
end_if

begin_comment
unit|}
comment|/// isLCSSAForm - Return true if the Loop is in LCSSA form
end_comment

begin_expr_stmt
unit|inline
name|bool
name|isLCSSAForm
argument_list|()
specifier|const
block|{
comment|// Sort the blocks vector so that we can use binary search to do quick
comment|// lookups.
name|SmallPtrSet
operator|<
name|BlockT
operator|*
block|,
literal|16
operator|>
name|LoopBBs
argument_list|(
name|block_begin
argument_list|()
argument_list|,
name|block_end
argument_list|()
argument_list|)
block|;
for|for
control|(
name|block_iterator
name|BI
init|=
name|block_begin
argument_list|()
init|,
name|E
init|=
name|block_end
argument_list|()
init|;
name|BI
operator|!=
name|E
condition|;
operator|++
name|BI
control|)
block|{
name|BlockT
modifier|*
name|BB
init|=
operator|*
name|BI
decl_stmt|;
for|for
control|(
name|typename
name|BlockT
operator|::
name|iterator
name|I
operator|=
name|BB
operator|->
name|begin
argument_list|()
operator|,
name|E
operator|=
name|BB
operator|->
name|end
argument_list|()
init|;
name|I
operator|!=
name|E
condition|;
operator|++
name|I
control|)
for|for
control|(
name|Value
operator|::
name|use_iterator
name|UI
operator|=
name|I
operator|->
name|use_begin
argument_list|()
operator|,
name|E
operator|=
name|I
operator|->
name|use_end
argument_list|()
init|;
name|UI
operator|!=
name|E
condition|;
operator|++
name|UI
control|)
block|{
name|BlockT
modifier|*
name|UserBB
init|=
name|cast
operator|<
name|Instruction
operator|>
operator|(
operator|*
name|UI
operator|)
operator|->
name|getParent
argument_list|()
decl_stmt|;
if|if
condition|(
name|PHINode
modifier|*
name|P
init|=
name|dyn_cast
operator|<
name|PHINode
operator|>
operator|(
operator|*
name|UI
operator|)
condition|)
block|{
name|UserBB
operator|=
name|P
operator|->
name|getIncomingBlock
argument_list|(
name|UI
argument_list|)
expr_stmt|;
block|}
end_expr_stmt

begin_comment
comment|// Check the current block, as a fast-path.  Most values are used in
end_comment

begin_comment
comment|// the same block they are defined in.
end_comment

begin_if
if|if
condition|(
name|UserBB
operator|!=
name|BB
operator|&&
operator|!
name|LoopBBs
operator|.
name|count
argument_list|(
name|UserBB
argument_list|)
condition|)
return|return
name|false
return|;
end_if

begin_return
unit|}     }
return|return
name|true
return|;
end_return

begin_comment
unit|}
comment|//===--------------------------------------------------------------------===//
end_comment

begin_comment
comment|// APIs for updating loop information after changing the CFG
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|/// addBasicBlockToLoop - This method is used by other analyses to update loop
end_comment

begin_comment
comment|/// information.  NewBB is set to be a new member of the current loop.
end_comment

begin_comment
comment|/// Because of this, it is added as a member of all parent loops, and is added
end_comment

begin_comment
comment|/// to the specified LoopInfo object as being in the current basic block.  It
end_comment

begin_comment
comment|/// is not valid to replace the loop header with this method.
end_comment

begin_comment
comment|///
end_comment

begin_expr_stmt
unit|void
name|addBasicBlockToLoop
argument_list|(
name|BlockT
operator|*
name|NewBB
argument_list|,
name|LoopInfoBase
operator|<
name|BlockT
operator|>
operator|&
name|LI
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/// replaceChildLoopWith - This is used when splitting loops up.  It replaces
end_comment

begin_comment
comment|/// the OldChild entry in our children list with NewChild, and updates the
end_comment

begin_comment
comment|/// parent pointer of OldChild to be null and the NewChild to be this loop.
end_comment

begin_comment
comment|/// This updates the loop depth of the new child.
end_comment

begin_decl_stmt
name|void
name|replaceChildLoopWith
argument_list|(
name|LoopBase
operator|<
name|BlockT
operator|>
operator|*
name|OldChild
argument_list|,
name|LoopBase
operator|<
name|BlockT
operator|>
operator|*
name|NewChild
argument_list|)
block|{
name|assert
argument_list|(
name|OldChild
operator|->
name|ParentLoop
operator|==
name|this
operator|&&
literal|"This loop is already broken!"
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|NewChild
operator|->
name|ParentLoop
operator|==
literal|0
operator|&&
literal|"NewChild already has a parent!"
argument_list|)
expr_stmt|;
name|typename
name|std
operator|::
name|vector
operator|<
name|LoopBase
operator|<
name|BlockT
operator|>
operator|*
operator|>
operator|::
name|iterator
name|I
operator|=
name|std
operator|::
name|find
argument_list|(
name|SubLoops
operator|.
name|begin
argument_list|()
argument_list|,
name|SubLoops
operator|.
name|end
argument_list|()
argument_list|,
name|OldChild
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|I
operator|!=
name|SubLoops
operator|.
name|end
argument_list|()
operator|&&
literal|"OldChild not in loop!"
argument_list|)
expr_stmt|;
operator|*
name|I
operator|=
name|NewChild
expr_stmt|;
name|OldChild
operator|->
name|ParentLoop
operator|=
literal|0
expr_stmt|;
name|NewChild
operator|->
name|ParentLoop
operator|=
name|this
expr_stmt|;
block|}
end_decl_stmt

begin_comment
comment|/// addChildLoop - Add the specified loop to be a child of this loop.  This
end_comment

begin_comment
comment|/// updates the loop depth of the new child.
end_comment

begin_comment
comment|///
end_comment

begin_decl_stmt
name|void
name|addChildLoop
argument_list|(
name|LoopBase
operator|<
name|BlockT
operator|>
operator|*
name|NewChild
argument_list|)
block|{
name|assert
argument_list|(
name|NewChild
operator|->
name|ParentLoop
operator|==
literal|0
operator|&&
literal|"NewChild already has a parent!"
argument_list|)
expr_stmt|;
name|NewChild
operator|->
name|ParentLoop
operator|=
name|this
expr_stmt|;
name|SubLoops
operator|.
name|push_back
argument_list|(
name|NewChild
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_comment
comment|/// removeChildLoop - This removes the specified child from being a subloop of
end_comment

begin_comment
comment|/// this loop.  The loop is not deleted, as it will presumably be inserted
end_comment

begin_comment
comment|/// into another loop.
end_comment

begin_expr_stmt
name|LoopBase
operator|<
name|BlockT
operator|>
operator|*
name|removeChildLoop
argument_list|(
argument|iterator I
argument_list|)
block|{
name|assert
argument_list|(
name|I
operator|!=
name|SubLoops
operator|.
name|end
argument_list|()
operator|&&
literal|"Cannot remove end iterator!"
argument_list|)
block|;
name|LoopBase
operator|<
name|BlockT
operator|>
operator|*
name|Child
operator|=
operator|*
name|I
block|;
name|assert
argument_list|(
name|Child
operator|->
name|ParentLoop
operator|==
name|this
operator|&&
literal|"Child is not a child of this loop!"
argument_list|)
block|;
name|SubLoops
operator|.
name|erase
argument_list|(
name|SubLoops
operator|.
name|begin
argument_list|()
operator|+
operator|(
name|I
operator|-
name|begin
argument_list|()
operator|)
argument_list|)
block|;
name|Child
operator|->
name|ParentLoop
operator|=
literal|0
block|;
return|return
name|Child
return|;
block|}
end_expr_stmt

begin_comment
comment|/// addBlockEntry - This adds a basic block directly to the basic block list.
end_comment

begin_comment
comment|/// This should only be used by transformations that create new loops.  Other
end_comment

begin_comment
comment|/// transformations should use addBasicBlockToLoop.
end_comment

begin_function
name|void
name|addBlockEntry
parameter_list|(
name|BlockT
modifier|*
name|BB
parameter_list|)
block|{
name|Blocks
operator|.
name|push_back
argument_list|(
name|BB
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/// moveToHeader - This method is used to move BB (which must be part of this
end_comment

begin_comment
comment|/// loop) to be the loop header of the loop (the block that dominates all
end_comment

begin_comment
comment|/// others).
end_comment

begin_function
name|void
name|moveToHeader
parameter_list|(
name|BlockT
modifier|*
name|BB
parameter_list|)
block|{
if|if
condition|(
name|Blocks
index|[
literal|0
index|]
operator|==
name|BB
condition|)
return|return;
for|for
control|(
name|unsigned
name|i
init|=
literal|0
init|;
condition|;
operator|++
name|i
control|)
block|{
name|assert
argument_list|(
name|i
operator|!=
name|Blocks
operator|.
name|size
argument_list|()
operator|&&
literal|"Loop does not contain BB!"
argument_list|)
expr_stmt|;
if|if
condition|(
name|Blocks
index|[
name|i
index|]
operator|==
name|BB
condition|)
block|{
name|Blocks
index|[
name|i
index|]
operator|=
name|Blocks
index|[
literal|0
index|]
expr_stmt|;
name|Blocks
index|[
literal|0
index|]
operator|=
name|BB
expr_stmt|;
return|return;
block|}
block|}
block|}
end_function

begin_comment
comment|/// removeBlockFromLoop - This removes the specified basic block from the
end_comment

begin_comment
comment|/// current loop, updating the Blocks as appropriate.  This does not update
end_comment

begin_comment
comment|/// the mapping in the LoopInfo class.
end_comment

begin_function
name|void
name|removeBlockFromLoop
parameter_list|(
name|BlockT
modifier|*
name|BB
parameter_list|)
block|{
name|RemoveFromVector
argument_list|(
name|Blocks
argument_list|,
name|BB
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/// verifyLoop - Verify loop structure
end_comment

begin_expr_stmt
name|void
name|verifyLoop
argument_list|()
specifier|const
block|{
ifndef|#
directive|ifndef
name|NDEBUG
name|assert
argument_list|(
name|getHeader
argument_list|()
operator|&&
literal|"Loop header is missing"
argument_list|)
block|;
name|assert
argument_list|(
name|getLoopPreheader
argument_list|()
operator|&&
literal|"Loop preheader is missing"
argument_list|)
block|;
name|assert
argument_list|(
name|getLoopLatch
argument_list|()
operator|&&
literal|"Loop latch is missing"
argument_list|)
block|;
for|for
control|(
name|iterator
name|I
init|=
name|SubLoops
operator|.
name|begin
argument_list|()
init|,
name|E
init|=
name|SubLoops
operator|.
name|end
argument_list|()
init|;
name|I
operator|!=
name|E
condition|;
operator|++
name|I
control|)
operator|(
operator|*
name|I
operator|)
operator|->
name|verifyLoop
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
end_expr_stmt

begin_decl_stmt
name|void
name|print
argument_list|(
name|std
operator|::
name|ostream
operator|&
name|OS
argument_list|,
name|unsigned
name|Depth
operator|=
literal|0
argument_list|)
decl|const
block|{
name|OS
operator|<<
name|std
operator|::
name|string
argument_list|(
name|Depth
operator|*
literal|2
argument_list|,
literal|' '
argument_list|)
operator|<<
literal|"Loop at depth "
operator|<<
name|getLoopDepth
argument_list|()
operator|<<
literal|" containing: "
expr_stmt|;
for|for
control|(
name|unsigned
name|i
init|=
literal|0
init|;
name|i
operator|<
name|getBlocks
argument_list|()
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|i
condition|)
name|OS
operator|<<
literal|","
expr_stmt|;
name|BlockT
modifier|*
name|BB
init|=
name|getBlocks
argument_list|()
index|[
name|i
index|]
decl_stmt|;
name|WriteAsOperand
argument_list|(
name|OS
argument_list|,
name|BB
argument_list|,
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|BB
operator|==
name|getHeader
argument_list|()
condition|)
name|OS
operator|<<
literal|"<header>"
expr_stmt|;
if|if
condition|(
name|BB
operator|==
name|getLoopLatch
argument_list|()
condition|)
name|OS
operator|<<
literal|"<latch>"
expr_stmt|;
if|if
condition|(
name|isLoopExit
argument_list|(
name|BB
argument_list|)
condition|)
name|OS
operator|<<
literal|"<exit>"
expr_stmt|;
block|}
name|OS
operator|<<
literal|"\n"
expr_stmt|;
for|for
control|(
name|iterator
name|I
init|=
name|begin
argument_list|()
init|,
name|E
init|=
name|end
argument_list|()
init|;
name|I
operator|!=
name|E
condition|;
operator|++
name|I
control|)
operator|(
operator|*
name|I
operator|)
operator|->
name|print
argument_list|(
name|OS
argument_list|,
name|Depth
operator|+
literal|2
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_decl_stmt
name|void
name|print
argument_list|(
name|std
operator|::
name|ostream
operator|*
name|O
argument_list|,
name|unsigned
name|Depth
operator|=
literal|0
argument_list|)
decl|const
block|{
if|if
condition|(
name|O
condition|)
name|print
argument_list|(
operator|*
name|O
argument_list|,
name|Depth
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_expr_stmt
name|void
name|dump
argument_list|()
specifier|const
block|{
name|print
argument_list|(
name|cerr
argument_list|)
block|;   }
name|private
operator|:
name|friend
name|class
name|LoopInfoBase
operator|<
name|BlockT
operator|>
expr_stmt|;
end_expr_stmt

begin_macro
name|explicit
end_macro

begin_expr_stmt
name|LoopBase
argument_list|(
name|BlockT
operator|*
name|BB
argument_list|)
operator|:
name|ParentLoop
argument_list|(
literal|0
argument_list|)
block|{
name|Blocks
operator|.
name|push_back
argument_list|(
name|BB
argument_list|)
block|;   }
end_expr_stmt

begin_comment
unit|};
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|/// LoopInfo - This class builds and contains all of the top level loop
end_comment

begin_comment
comment|/// structures in the specified function.
end_comment

begin_comment
comment|///
end_comment

begin_expr_stmt
name|template
operator|<
name|class
name|BlockT
operator|>
name|class
name|LoopInfoBase
block|{
comment|// BBMap - Mapping of basic blocks to the inner most loop they occur in
name|std
operator|::
name|map
operator|<
name|BlockT
operator|*
block|,
name|LoopBase
operator|<
name|BlockT
operator|>
operator|*
operator|>
name|BBMap
block|;
name|std
operator|::
name|vector
operator|<
name|LoopBase
operator|<
name|BlockT
operator|>
operator|*
operator|>
name|TopLevelLoops
block|;
name|friend
name|class
name|LoopBase
operator|<
name|BlockT
operator|>
block|;
name|public
operator|:
name|LoopInfoBase
argument_list|()
block|{ }
operator|~
name|LoopInfoBase
argument_list|()
block|{
name|releaseMemory
argument_list|()
block|; }
name|void
name|releaseMemory
argument_list|()
block|{
for|for
control|(
name|typename
name|std
operator|::
name|vector
operator|<
name|LoopBase
operator|<
name|BlockT
operator|>
operator|*
operator|>
operator|::
name|iterator
name|I
operator|=
name|TopLevelLoops
operator|.
name|begin
argument_list|()
operator|,
name|E
operator|=
name|TopLevelLoops
operator|.
name|end
argument_list|()
init|;
name|I
operator|!=
name|E
condition|;
operator|++
name|I
control|)
name|delete
modifier|*
name|I
decl_stmt|;
comment|// Delete all of the loops...
name|BBMap
operator|.
name|clear
argument_list|()
block|;
comment|// Reset internal state of analysis
name|TopLevelLoops
operator|.
name|clear
argument_list|()
block|;   }
end_expr_stmt

begin_comment
comment|/// iterator/begin/end - The interface to the top-level loops in the current
end_comment

begin_comment
comment|/// function.
end_comment

begin_comment
comment|///
end_comment

begin_typedef
typedef|typedef
name|typename
name|std
operator|::
name|vector
operator|<
name|LoopBase
operator|<
name|BlockT
operator|>
operator|*
operator|>
operator|::
name|const_iterator
name|iterator
expr_stmt|;
end_typedef

begin_expr_stmt
name|iterator
name|begin
argument_list|()
specifier|const
block|{
return|return
name|TopLevelLoops
operator|.
name|begin
argument_list|()
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|iterator
name|end
argument_list|()
specifier|const
block|{
return|return
name|TopLevelLoops
operator|.
name|end
argument_list|()
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|bool
name|empty
argument_list|()
specifier|const
block|{
return|return
name|TopLevelLoops
operator|.
name|empty
argument_list|()
return|;
block|}
end_expr_stmt

begin_comment
comment|/// getLoopFor - Return the inner most loop that BB lives in.  If a basic
end_comment

begin_comment
comment|/// block is in no loop (for example the entry node), null is returned.
end_comment

begin_comment
comment|///
end_comment

begin_expr_stmt
name|LoopBase
operator|<
name|BlockT
operator|>
operator|*
name|getLoopFor
argument_list|(
argument|const BlockT *BB
argument_list|)
specifier|const
block|{
name|typename
name|std
operator|::
name|map
operator|<
name|BlockT
operator|*
block|,
name|LoopBase
operator|<
name|BlockT
operator|>
operator|*
operator|>
operator|::
name|const_iterator
name|I
operator|=
name|BBMap
operator|.
name|find
argument_list|(
name|const_cast
operator|<
name|BlockT
operator|*
operator|>
operator|(
name|BB
operator|)
argument_list|)
block|;
return|return
name|I
operator|!=
name|BBMap
operator|.
name|end
argument_list|()
condition|?
name|I
operator|->
name|second
else|:
literal|0
return|;
block|}
end_expr_stmt

begin_comment
comment|/// operator[] - same as getLoopFor...
end_comment

begin_comment
comment|///
end_comment

begin_expr_stmt
specifier|const
name|LoopBase
operator|<
name|BlockT
operator|>
operator|*
name|operator
index|[]
operator|(
specifier|const
name|BlockT
operator|*
name|BB
operator|)
specifier|const
block|{
return|return
name|getLoopFor
argument_list|(
name|BB
argument_list|)
return|;
block|}
end_expr_stmt

begin_comment
comment|/// getLoopDepth - Return the loop nesting level of the specified block.  A
end_comment

begin_comment
comment|/// depth of 0 means the block is not inside any loop.
end_comment

begin_comment
comment|///
end_comment

begin_decl_stmt
name|unsigned
name|getLoopDepth
argument_list|(
specifier|const
name|BlockT
operator|*
name|BB
argument_list|)
decl|const
block|{
specifier|const
name|LoopBase
operator|<
name|BlockT
operator|>
operator|*
name|L
operator|=
name|getLoopFor
argument_list|(
name|BB
argument_list|)
expr_stmt|;
return|return
name|L
condition|?
name|L
operator|->
name|getLoopDepth
argument_list|()
else|:
literal|0
return|;
block|}
end_decl_stmt

begin_comment
comment|// isLoopHeader - True if the block is a loop header node
end_comment

begin_decl_stmt
name|bool
name|isLoopHeader
argument_list|(
name|BlockT
operator|*
name|BB
argument_list|)
decl|const
block|{
specifier|const
name|LoopBase
operator|<
name|BlockT
operator|>
operator|*
name|L
operator|=
name|getLoopFor
argument_list|(
name|BB
argument_list|)
expr_stmt|;
return|return
name|L
operator|&&
name|L
operator|->
name|getHeader
argument_list|()
operator|==
name|BB
return|;
block|}
end_decl_stmt

begin_comment
comment|/// removeLoop - This removes the specified top-level loop from this loop info
end_comment

begin_comment
comment|/// object.  The loop is not deleted, as it will presumably be inserted into
end_comment

begin_comment
comment|/// another loop.
end_comment

begin_expr_stmt
name|LoopBase
operator|<
name|BlockT
operator|>
operator|*
name|removeLoop
argument_list|(
argument|iterator I
argument_list|)
block|{
name|assert
argument_list|(
name|I
operator|!=
name|end
argument_list|()
operator|&&
literal|"Cannot remove end iterator!"
argument_list|)
block|;
name|LoopBase
operator|<
name|BlockT
operator|>
operator|*
name|L
operator|=
operator|*
name|I
block|;
name|assert
argument_list|(
name|L
operator|->
name|getParentLoop
argument_list|()
operator|==
literal|0
operator|&&
literal|"Not a top-level loop!"
argument_list|)
block|;
name|TopLevelLoops
operator|.
name|erase
argument_list|(
name|TopLevelLoops
operator|.
name|begin
argument_list|()
operator|+
operator|(
name|I
operator|-
name|begin
argument_list|()
operator|)
argument_list|)
block|;
return|return
name|L
return|;
block|}
end_expr_stmt

begin_comment
comment|/// changeLoopFor - Change the top-level loop that contains BB to the
end_comment

begin_comment
comment|/// specified loop.  This should be used by transformations that restructure
end_comment

begin_comment
comment|/// the loop hierarchy tree.
end_comment

begin_decl_stmt
name|void
name|changeLoopFor
argument_list|(
name|BlockT
operator|*
name|BB
argument_list|,
name|LoopBase
operator|<
name|BlockT
operator|>
operator|*
name|L
argument_list|)
block|{
name|LoopBase
operator|<
name|BlockT
operator|>
operator|*
operator|&
name|OldLoop
operator|=
name|BBMap
index|[
name|BB
index|]
expr_stmt|;
name|assert
argument_list|(
name|OldLoop
operator|&&
literal|"Block not in a loop yet!"
argument_list|)
expr_stmt|;
name|OldLoop
operator|=
name|L
expr_stmt|;
block|}
end_decl_stmt

begin_comment
comment|/// changeTopLevelLoop - Replace the specified loop in the top-level loops
end_comment

begin_comment
comment|/// list with the indicated loop.
end_comment

begin_decl_stmt
name|void
name|changeTopLevelLoop
argument_list|(
name|LoopBase
operator|<
name|BlockT
operator|>
operator|*
name|OldLoop
argument_list|,
name|LoopBase
operator|<
name|BlockT
operator|>
operator|*
name|NewLoop
argument_list|)
block|{
name|typename
name|std
operator|::
name|vector
operator|<
name|LoopBase
operator|<
name|BlockT
operator|>
operator|*
operator|>
operator|::
name|iterator
name|I
operator|=
name|std
operator|::
name|find
argument_list|(
name|TopLevelLoops
operator|.
name|begin
argument_list|()
argument_list|,
name|TopLevelLoops
operator|.
name|end
argument_list|()
argument_list|,
name|OldLoop
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|I
operator|!=
name|TopLevelLoops
operator|.
name|end
argument_list|()
operator|&&
literal|"Old loop not at top level!"
argument_list|)
expr_stmt|;
operator|*
name|I
operator|=
name|NewLoop
expr_stmt|;
name|assert
argument_list|(
name|NewLoop
operator|->
name|ParentLoop
operator|==
literal|0
operator|&&
name|OldLoop
operator|->
name|ParentLoop
operator|==
literal|0
operator|&&
literal|"Loops already embedded into a subloop!"
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_comment
comment|/// addTopLevelLoop - This adds the specified loop to the collection of
end_comment

begin_comment
comment|/// top-level loops.
end_comment

begin_decl_stmt
name|void
name|addTopLevelLoop
argument_list|(
name|LoopBase
operator|<
name|BlockT
operator|>
operator|*
name|New
argument_list|)
block|{
name|assert
argument_list|(
name|New
operator|->
name|getParentLoop
argument_list|()
operator|==
literal|0
operator|&&
literal|"Loop already in subloop!"
argument_list|)
expr_stmt|;
name|TopLevelLoops
operator|.
name|push_back
argument_list|(
name|New
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_comment
comment|/// removeBlock - This method completely removes BB from all data structures,
end_comment

begin_comment
comment|/// including all of the Loop objects it is nested in and our mapping from
end_comment

begin_comment
comment|/// BasicBlocks to loops.
end_comment

begin_function
name|void
name|removeBlock
parameter_list|(
name|BlockT
modifier|*
name|BB
parameter_list|)
block|{
name|typename
name|std
operator|::
name|map
operator|<
name|BlockT
operator|*
operator|,
name|LoopBase
operator|<
name|BlockT
operator|>
operator|*
operator|>
operator|::
name|iterator
name|I
operator|=
name|BBMap
operator|.
name|find
argument_list|(
name|BB
argument_list|)
expr_stmt|;
if|if
condition|(
name|I
operator|!=
name|BBMap
operator|.
name|end
argument_list|()
condition|)
block|{
for|for
control|(
name|LoopBase
operator|<
name|BlockT
operator|>
operator|*
name|L
operator|=
name|I
operator|->
name|second
init|;
name|L
condition|;
name|L
operator|=
name|L
operator|->
name|getParentLoop
argument_list|()
control|)
name|L
operator|->
name|removeBlockFromLoop
argument_list|(
name|BB
argument_list|)
expr_stmt|;
name|BBMap
operator|.
name|erase
argument_list|(
name|I
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|// Internals
end_comment

begin_decl_stmt
specifier|static
name|bool
name|isNotAlreadyContainedIn
argument_list|(
specifier|const
name|LoopBase
operator|<
name|BlockT
operator|>
operator|*
name|SubLoop
argument_list|,
specifier|const
name|LoopBase
operator|<
name|BlockT
operator|>
operator|*
name|ParentLoop
argument_list|)
block|{
if|if
condition|(
name|SubLoop
operator|==
literal|0
condition|)
return|return
name|true
return|;
if|if
condition|(
name|SubLoop
operator|==
name|ParentLoop
condition|)
return|return
name|false
return|;
return|return
name|isNotAlreadyContainedIn
argument_list|(
name|SubLoop
operator|->
name|getParentLoop
argument_list|()
argument_list|,
name|ParentLoop
argument_list|)
return|;
block|}
end_decl_stmt

begin_decl_stmt
name|void
name|Calculate
argument_list|(
name|DominatorTreeBase
operator|<
name|BlockT
operator|>
operator|&
name|DT
argument_list|)
block|{
name|BlockT
modifier|*
name|RootNode
init|=
name|DT
operator|.
name|getRootNode
argument_list|()
operator|->
name|getBlock
argument_list|()
decl_stmt|;
for|for
control|(
name|df_iterator
operator|<
name|BlockT
operator|*
operator|>
name|NI
operator|=
name|df_begin
argument_list|(
name|RootNode
argument_list|)
operator|,
name|NE
operator|=
name|df_end
argument_list|(
name|RootNode
argument_list|)
init|;
name|NI
operator|!=
name|NE
condition|;
operator|++
name|NI
control|)
if|if
condition|(
name|LoopBase
operator|<
name|BlockT
operator|>
operator|*
name|L
operator|=
name|ConsiderForLoop
argument_list|(
operator|*
name|NI
argument_list|,
name|DT
argument_list|)
condition|)
name|TopLevelLoops
operator|.
name|push_back
argument_list|(
name|L
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_expr_stmt
name|LoopBase
operator|<
name|BlockT
operator|>
operator|*
name|ConsiderForLoop
argument_list|(
argument|BlockT *BB
argument_list|,
argument|DominatorTreeBase<BlockT>&DT
argument_list|)
block|{
if|if
condition|(
name|BBMap
operator|.
name|find
argument_list|(
name|BB
argument_list|)
operator|!=
name|BBMap
operator|.
name|end
argument_list|()
condition|)
return|return
literal|0
return|;
comment|// Haven't processed this node?
name|std
operator|::
name|vector
operator|<
name|BlockT
operator|*
operator|>
name|TodoStack
expr_stmt|;
end_expr_stmt

begin_comment
comment|// Scan the predecessors of BB, checking to see if BB dominates any of
end_comment

begin_comment
comment|// them.  This identifies backedges which target this node...
end_comment

begin_typedef
typedef|typedef
name|GraphTraits
operator|<
name|Inverse
operator|<
name|BlockT
operator|*
operator|>
expr|>
name|InvBlockTraits
expr_stmt|;
end_typedef

begin_for
for|for
control|(
name|typename
name|InvBlockTraits
operator|::
name|ChildIteratorType
name|I
operator|=
name|InvBlockTraits
operator|::
name|child_begin
argument_list|(
name|BB
argument_list|)
operator|,
name|E
operator|=
name|InvBlockTraits
operator|::
name|child_end
argument_list|(
name|BB
argument_list|)
init|;
name|I
operator|!=
name|E
condition|;
operator|++
name|I
control|)
if|if
condition|(
name|DT
operator|.
name|dominates
argument_list|(
name|BB
argument_list|,
operator|*
name|I
argument_list|)
condition|)
comment|// If BB dominates it's predecessor...
name|TodoStack
operator|.
name|push_back
argument_list|(
operator|*
name|I
argument_list|)
expr_stmt|;
end_for

begin_if
if|if
condition|(
name|TodoStack
operator|.
name|empty
argument_list|()
condition|)
return|return
literal|0
return|;
end_if

begin_comment
comment|// No backedges to this block...
end_comment

begin_comment
comment|// Create a new loop to represent this basic block...
end_comment

begin_expr_stmt
name|LoopBase
operator|<
name|BlockT
operator|>
operator|*
name|L
operator|=
name|new
name|LoopBase
operator|<
name|BlockT
operator|>
operator|(
name|BB
operator|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|BBMap
index|[
name|BB
index|]
operator|=
name|L
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|BlockT
modifier|*
name|EntryBlock
init|=
name|BB
operator|->
name|getParent
argument_list|()
operator|->
name|begin
argument_list|()
decl_stmt|;
end_decl_stmt

begin_while
while|while
condition|(
operator|!
name|TodoStack
operator|.
name|empty
argument_list|()
condition|)
block|{
comment|// Process all the nodes in the loop
name|BlockT
modifier|*
name|X
init|=
name|TodoStack
operator|.
name|back
argument_list|()
decl_stmt|;
name|TodoStack
operator|.
name|pop_back
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|L
operator|->
name|contains
argument_list|(
name|X
argument_list|)
operator|&&
comment|// As of yet unprocessed??
name|DT
operator|.
name|dominates
argument_list|(
name|EntryBlock
argument_list|,
name|X
argument_list|)
condition|)
block|{
comment|// X is reachable from entry block?
comment|// Check to see if this block already belongs to a loop.  If this occurs
comment|// then we have a case where a loop that is supposed to be a child of
comment|// the current loop was processed before the current loop.  When this
comment|// occurs, this child loop gets added to a part of the current loop,
comment|// making it a sibling to the current loop.  We have to reparent this
comment|// loop.
if|if
condition|(
name|LoopBase
operator|<
name|BlockT
operator|>
operator|*
name|SubLoop
operator|=
name|const_cast
operator|<
name|LoopBase
operator|<
name|BlockT
operator|>
operator|*
operator|>
operator|(
name|getLoopFor
argument_list|(
name|X
argument_list|)
operator|)
condition|)
if|if
condition|(
name|SubLoop
operator|->
name|getHeader
argument_list|()
operator|==
name|X
operator|&&
name|isNotAlreadyContainedIn
argument_list|(
name|SubLoop
argument_list|,
name|L
argument_list|)
condition|)
block|{
comment|// Remove the subloop from it's current parent...
name|assert
argument_list|(
name|SubLoop
operator|->
name|ParentLoop
operator|&&
name|SubLoop
operator|->
name|ParentLoop
operator|!=
name|L
argument_list|)
expr_stmt|;
name|LoopBase
operator|<
name|BlockT
operator|>
operator|*
name|SLP
operator|=
name|SubLoop
operator|->
name|ParentLoop
expr_stmt|;
comment|// SubLoopParent
name|typename
name|std
operator|::
name|vector
operator|<
name|LoopBase
operator|<
name|BlockT
operator|>
operator|*
operator|>
operator|::
name|iterator
name|I
operator|=
name|std
operator|::
name|find
argument_list|(
name|SLP
operator|->
name|SubLoops
operator|.
name|begin
argument_list|()
argument_list|,
name|SLP
operator|->
name|SubLoops
operator|.
name|end
argument_list|()
argument_list|,
name|SubLoop
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|I
operator|!=
name|SLP
operator|->
name|SubLoops
operator|.
name|end
argument_list|()
operator|&&
literal|"SubLoop not a child of parent?"
argument_list|)
expr_stmt|;
name|SLP
operator|->
name|SubLoops
operator|.
name|erase
argument_list|(
name|I
argument_list|)
expr_stmt|;
comment|// Remove from parent...
comment|// Add the subloop to THIS loop...
name|SubLoop
operator|->
name|ParentLoop
operator|=
name|L
expr_stmt|;
name|L
operator|->
name|SubLoops
operator|.
name|push_back
argument_list|(
name|SubLoop
argument_list|)
expr_stmt|;
block|}
comment|// Normal case, add the block to our loop...
name|L
operator|->
name|Blocks
operator|.
name|push_back
argument_list|(
name|X
argument_list|)
expr_stmt|;
typedef|typedef
name|GraphTraits
operator|<
name|Inverse
operator|<
name|BlockT
operator|*
operator|>
expr|>
name|InvBlockTraits
expr_stmt|;
comment|// Add all of the predecessors of X to the end of the work stack...
name|TodoStack
operator|.
name|insert
argument_list|(
name|TodoStack
operator|.
name|end
argument_list|()
argument_list|,
name|InvBlockTraits
operator|::
name|child_begin
argument_list|(
name|X
argument_list|)
argument_list|,
name|InvBlockTraits
operator|::
name|child_end
argument_list|(
name|X
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_while

begin_comment
comment|// If there are any loops nested within this loop, create them now!
end_comment

begin_for
for|for
control|(
name|typename
name|std
operator|::
name|vector
operator|<
name|BlockT
operator|*
operator|>
operator|::
name|iterator
name|I
operator|=
name|L
operator|->
name|Blocks
operator|.
name|begin
argument_list|()
operator|,
name|E
operator|=
name|L
operator|->
name|Blocks
operator|.
name|end
argument_list|()
init|;
name|I
operator|!=
name|E
condition|;
operator|++
name|I
control|)
if|if
condition|(
name|LoopBase
operator|<
name|BlockT
operator|>
operator|*
name|NewLoop
operator|=
name|ConsiderForLoop
argument_list|(
operator|*
name|I
argument_list|,
name|DT
argument_list|)
condition|)
block|{
name|L
operator|->
name|SubLoops
operator|.
name|push_back
argument_list|(
name|NewLoop
argument_list|)
expr_stmt|;
name|NewLoop
operator|->
name|ParentLoop
operator|=
name|L
expr_stmt|;
block|}
end_for

begin_comment
comment|// Add the basic blocks that comprise this loop to the BBMap so that this
end_comment

begin_comment
comment|// loop can be found for them.
end_comment

begin_comment
comment|//
end_comment

begin_for
for|for
control|(
name|typename
name|std
operator|::
name|vector
operator|<
name|BlockT
operator|*
operator|>
operator|::
name|iterator
name|I
operator|=
name|L
operator|->
name|Blocks
operator|.
name|begin
argument_list|()
operator|,
name|E
operator|=
name|L
operator|->
name|Blocks
operator|.
name|end
argument_list|()
init|;
name|I
operator|!=
name|E
condition|;
operator|++
name|I
control|)
block|{
name|typename
name|std
operator|::
name|map
operator|<
name|BlockT
operator|*
operator|,
name|LoopBase
operator|<
name|BlockT
operator|>
operator|*
operator|>
operator|::
name|iterator
name|BBMI
operator|=
name|BBMap
operator|.
name|find
argument_list|(
operator|*
name|I
argument_list|)
expr_stmt|;
if|if
condition|(
name|BBMI
operator|==
name|BBMap
operator|.
name|end
argument_list|()
condition|)
comment|// Not in map yet...
name|BBMap
operator|.
name|insert
argument_list|(
name|BBMI
argument_list|,
name|std
operator|::
name|make_pair
argument_list|(
operator|*
name|I
argument_list|,
name|L
argument_list|)
argument_list|)
expr_stmt|;
comment|// Must be at this level
block|}
end_for

begin_comment
comment|// Now that we have a list of all of the child loops of this loop, check to
end_comment

begin_comment
comment|// see if any of them should actually be nested inside of each other.  We
end_comment

begin_comment
comment|// can accidentally pull loops our of their parents, so we must make sure to
end_comment

begin_comment
comment|// organize the loop nests correctly now.
end_comment

begin_block
block|{
name|std
operator|::
name|map
operator|<
name|BlockT
operator|*
operator|,
name|LoopBase
operator|<
name|BlockT
operator|>
operator|*
operator|>
name|ContainingLoops
expr_stmt|;
for|for
control|(
name|unsigned
name|i
init|=
literal|0
init|;
name|i
operator|!=
name|L
operator|->
name|SubLoops
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|LoopBase
operator|<
name|BlockT
operator|>
operator|*
name|Child
operator|=
name|L
operator|->
name|SubLoops
index|[
name|i
index|]
expr_stmt|;
name|assert
argument_list|(
name|Child
operator|->
name|getParentLoop
argument_list|()
operator|==
name|L
operator|&&
literal|"Not proper child loop?"
argument_list|)
expr_stmt|;
if|if
condition|(
name|LoopBase
operator|<
name|BlockT
operator|>
operator|*
name|ContainingLoop
operator|=
name|ContainingLoops
index|[
name|Child
operator|->
name|getHeader
argument_list|()
index|]
condition|)
block|{
comment|// If there is already a loop which contains this loop, move this loop
comment|// into the containing loop.
name|MoveSiblingLoopInto
argument_list|(
name|Child
argument_list|,
name|ContainingLoop
argument_list|)
expr_stmt|;
operator|--
name|i
expr_stmt|;
comment|// The loop got removed from the SubLoops list.
block|}
else|else
block|{
comment|// This is currently considered to be a top-level loop.  Check to see
comment|// if any of the contained blocks are loop headers for subloops we
comment|// have already processed.
for|for
control|(
name|unsigned
name|b
init|=
literal|0
init|,
name|e
init|=
name|Child
operator|->
name|Blocks
operator|.
name|size
argument_list|()
init|;
name|b
operator|!=
name|e
condition|;
operator|++
name|b
control|)
block|{
name|LoopBase
operator|<
name|BlockT
operator|>
operator|*
operator|&
name|BlockLoop
operator|=
name|ContainingLoops
index|[
name|Child
operator|->
name|Blocks
index|[
name|b
index|]
index|]
expr_stmt|;
if|if
condition|(
name|BlockLoop
operator|==
literal|0
condition|)
block|{
comment|// Child block not processed yet...
name|BlockLoop
operator|=
name|Child
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|BlockLoop
operator|!=
name|Child
condition|)
block|{
name|LoopBase
operator|<
name|BlockT
operator|>
operator|*
name|SubLoop
operator|=
name|BlockLoop
expr_stmt|;
comment|// Reparent all of the blocks which used to belong to BlockLoops
for|for
control|(
name|unsigned
name|j
init|=
literal|0
init|,
name|e
init|=
name|SubLoop
operator|->
name|Blocks
operator|.
name|size
argument_list|()
init|;
name|j
operator|!=
name|e
condition|;
operator|++
name|j
control|)
name|ContainingLoops
index|[
name|SubLoop
operator|->
name|Blocks
index|[
name|j
index|]
index|]
operator|=
name|Child
expr_stmt|;
comment|// There is already a loop which contains this block, that means
comment|// that we should reparent the loop which the block is currently
comment|// considered to belong to to be a child of this loop.
name|MoveSiblingLoopInto
argument_list|(
name|SubLoop
argument_list|,
name|Child
argument_list|)
expr_stmt|;
operator|--
name|i
expr_stmt|;
comment|// We just shrunk the SubLoops list.
block|}
block|}
block|}
block|}
block|}
end_block

begin_return
return|return
name|L
return|;
end_return

begin_comment
unit|}
comment|/// MoveSiblingLoopInto - This method moves the NewChild loop to live inside
end_comment

begin_comment
comment|/// of the NewParent Loop, instead of being a sibling of it.
end_comment

begin_macro
unit|void
name|MoveSiblingLoopInto
argument_list|(
argument|LoopBase<BlockT> *NewChild
argument_list|,
argument|LoopBase<BlockT> *NewParent
argument_list|)
end_macro

begin_block
block|{
name|LoopBase
operator|<
name|BlockT
operator|>
operator|*
name|OldParent
operator|=
name|NewChild
operator|->
name|getParentLoop
argument_list|()
expr_stmt|;
name|assert
argument_list|(
name|OldParent
operator|&&
name|OldParent
operator|==
name|NewParent
operator|->
name|getParentLoop
argument_list|()
operator|&&
name|NewChild
operator|!=
name|NewParent
operator|&&
literal|"Not sibling loops!"
argument_list|)
expr_stmt|;
comment|// Remove NewChild from being a child of OldParent
name|typename
name|std
operator|::
name|vector
operator|<
name|LoopBase
operator|<
name|BlockT
operator|>
operator|*
operator|>
operator|::
name|iterator
name|I
operator|=
name|std
operator|::
name|find
argument_list|(
name|OldParent
operator|->
name|SubLoops
operator|.
name|begin
argument_list|()
argument_list|,
name|OldParent
operator|->
name|SubLoops
operator|.
name|end
argument_list|()
argument_list|,
name|NewChild
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|I
operator|!=
name|OldParent
operator|->
name|SubLoops
operator|.
name|end
argument_list|()
operator|&&
literal|"Parent fields incorrect??"
argument_list|)
expr_stmt|;
name|OldParent
operator|->
name|SubLoops
operator|.
name|erase
argument_list|(
name|I
argument_list|)
expr_stmt|;
comment|// Remove from parent's subloops list
name|NewChild
operator|->
name|ParentLoop
operator|=
literal|0
expr_stmt|;
name|InsertLoopInto
argument_list|(
name|NewChild
argument_list|,
name|NewParent
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/// InsertLoopInto - This inserts loop L into the specified parent loop.  If
end_comment

begin_comment
comment|/// the parent loop contains a loop which should contain L, the loop gets
end_comment

begin_comment
comment|/// inserted into L instead.
end_comment

begin_decl_stmt
name|void
name|InsertLoopInto
argument_list|(
name|LoopBase
operator|<
name|BlockT
operator|>
operator|*
name|L
argument_list|,
name|LoopBase
operator|<
name|BlockT
operator|>
operator|*
name|Parent
argument_list|)
block|{
name|BlockT
modifier|*
name|LHeader
init|=
name|L
operator|->
name|getHeader
argument_list|()
decl_stmt|;
name|assert
argument_list|(
name|Parent
operator|->
name|contains
argument_list|(
name|LHeader
argument_list|)
operator|&&
literal|"This loop should not be inserted here!"
argument_list|)
expr_stmt|;
comment|// Check to see if it belongs in a child loop...
for|for
control|(
name|unsigned
name|i
init|=
literal|0
init|,
name|e
init|=
name|static_cast
operator|<
name|unsigned
operator|>
operator|(
name|Parent
operator|->
name|SubLoops
operator|.
name|size
argument_list|()
operator|)
init|;
name|i
operator|!=
name|e
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|Parent
operator|->
name|SubLoops
index|[
name|i
index|]
operator|->
name|contains
argument_list|(
name|LHeader
argument_list|)
condition|)
block|{
name|InsertLoopInto
argument_list|(
name|L
argument_list|,
name|Parent
operator|->
name|SubLoops
index|[
name|i
index|]
argument_list|)
expr_stmt|;
return|return;
block|}
comment|// If not, insert it here!
name|Parent
operator|->
name|SubLoops
operator|.
name|push_back
argument_list|(
name|L
argument_list|)
expr_stmt|;
name|L
operator|->
name|ParentLoop
operator|=
name|Parent
expr_stmt|;
block|}
end_decl_stmt

begin_comment
comment|// Debugging
end_comment

begin_decl_stmt
name|void
name|print
argument_list|(
name|std
operator|::
name|ostream
operator|&
name|OS
argument_list|,
specifier|const
name|Module
operator|*
argument_list|)
decl|const
block|{
for|for
control|(
name|unsigned
name|i
init|=
literal|0
init|;
name|i
operator|<
name|TopLevelLoops
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
name|TopLevelLoops
index|[
name|i
index|]
operator|->
name|print
argument_list|(
name|OS
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|for (std::map<BasicBlock*, Loop*>::const_iterator I = BBMap.begin(),            E = BBMap.end(); I != E; ++I)       OS<< "BB '"<< I->first->getName()<< "' level = "<< I->second->getLoopDepth()<< "\n";
endif|#
directive|endif
block|}
end_decl_stmt

begin_decl_stmt
unit|};
name|class
name|LoopInfo
range|:
name|public
name|FunctionPass
block|{
name|LoopInfoBase
operator|<
name|BasicBlock
operator|>
operator|*
name|LI
block|;
name|friend
name|class
name|LoopBase
operator|<
name|BasicBlock
operator|>
block|;
name|public
operator|:
specifier|static
name|char
name|ID
block|;
comment|// Pass identification, replacement for typeid
name|LoopInfo
argument_list|()
operator|:
name|FunctionPass
argument_list|(
argument|&ID
argument_list|)
block|{
name|LI
operator|=
name|new
name|LoopInfoBase
operator|<
name|BasicBlock
operator|>
operator|(
operator|)
block|;   }
operator|~
name|LoopInfo
argument_list|()
block|{
name|delete
name|LI
block|; }
name|LoopInfoBase
operator|<
name|BasicBlock
operator|>
operator|&
name|getBase
argument_list|()
block|{
return|return
operator|*
name|LI
return|;
block|}
comment|/// iterator/begin/end - The interface to the top-level loops in the current
comment|/// function.
comment|///
typedef|typedef
name|std
operator|::
name|vector
operator|<
name|Loop
operator|*
operator|>
operator|::
name|const_iterator
name|iterator
expr_stmt|;
specifier|inline
name|iterator
name|begin
argument_list|()
specifier|const
block|{
return|return
name|LI
operator|->
name|begin
argument_list|()
return|;
block|}
specifier|inline
name|iterator
name|end
argument_list|()
specifier|const
block|{
return|return
name|LI
operator|->
name|end
argument_list|()
return|;
block|}
name|bool
name|empty
argument_list|()
specifier|const
block|{
return|return
name|LI
operator|->
name|empty
argument_list|()
return|;
block|}
comment|/// getLoopFor - Return the inner most loop that BB lives in.  If a basic
comment|/// block is in no loop (for example the entry node), null is returned.
comment|///
specifier|inline
name|Loop
operator|*
name|getLoopFor
argument_list|(
argument|const BasicBlock *BB
argument_list|)
specifier|const
block|{
return|return
name|LI
operator|->
name|getLoopFor
argument_list|(
name|BB
argument_list|)
return|;
block|}
comment|/// operator[] - same as getLoopFor...
comment|///
specifier|inline
specifier|const
name|Loop
operator|*
name|operator
index|[]
operator|(
specifier|const
name|BasicBlock
operator|*
name|BB
operator|)
specifier|const
block|{
return|return
name|LI
operator|->
name|getLoopFor
argument_list|(
name|BB
argument_list|)
return|;
block|}
comment|/// getLoopDepth - Return the loop nesting level of the specified block.  A
comment|/// depth of 0 means the block is not inside any loop.
comment|///
specifier|inline
name|unsigned
name|getLoopDepth
argument_list|(
argument|const BasicBlock *BB
argument_list|)
specifier|const
block|{
return|return
name|LI
operator|->
name|getLoopDepth
argument_list|(
name|BB
argument_list|)
return|;
block|}
comment|// isLoopHeader - True if the block is a loop header node
specifier|inline
name|bool
name|isLoopHeader
argument_list|(
argument|BasicBlock *BB
argument_list|)
specifier|const
block|{
return|return
name|LI
operator|->
name|isLoopHeader
argument_list|(
name|BB
argument_list|)
return|;
block|}
comment|/// runOnFunction - Calculate the natural loop information.
comment|///
name|virtual
name|bool
name|runOnFunction
argument_list|(
name|Function
operator|&
name|F
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
name|virtual
name|void
name|releaseMemory
parameter_list|()
block|{
name|LI
operator|->
name|releaseMemory
argument_list|()
expr_stmt|;
block|}
end_function

begin_decl_stmt
name|virtual
name|void
name|print
argument_list|(
name|std
operator|::
name|ostream
operator|&
name|O
argument_list|,
specifier|const
name|Module
operator|*
name|M
operator|=
literal|0
argument_list|)
decl|const
block|{
if|if
condition|(
name|O
condition|)
name|LI
operator|->
name|print
argument_list|(
name|O
argument_list|,
name|M
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_decl_stmt
name|virtual
name|void
name|getAnalysisUsage
argument_list|(
name|AnalysisUsage
operator|&
name|AU
argument_list|)
decl|const
decl_stmt|;
end_decl_stmt

begin_comment
comment|/// removeLoop - This removes the specified top-level loop from this loop info
end_comment

begin_comment
comment|/// object.  The loop is not deleted, as it will presumably be inserted into
end_comment

begin_comment
comment|/// another loop.
end_comment

begin_function
specifier|inline
name|Loop
modifier|*
name|removeLoop
parameter_list|(
name|iterator
name|I
parameter_list|)
block|{
return|return
name|LI
operator|->
name|removeLoop
argument_list|(
name|I
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/// changeLoopFor - Change the top-level loop that contains BB to the
end_comment

begin_comment
comment|/// specified loop.  This should be used by transformations that restructure
end_comment

begin_comment
comment|/// the loop hierarchy tree.
end_comment

begin_function
specifier|inline
name|void
name|changeLoopFor
parameter_list|(
name|BasicBlock
modifier|*
name|BB
parameter_list|,
name|Loop
modifier|*
name|L
parameter_list|)
block|{
name|LI
operator|->
name|changeLoopFor
argument_list|(
name|BB
argument_list|,
name|L
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/// changeTopLevelLoop - Replace the specified loop in the top-level loops
end_comment

begin_comment
comment|/// list with the indicated loop.
end_comment

begin_function
specifier|inline
name|void
name|changeTopLevelLoop
parameter_list|(
name|Loop
modifier|*
name|OldLoop
parameter_list|,
name|Loop
modifier|*
name|NewLoop
parameter_list|)
block|{
name|LI
operator|->
name|changeTopLevelLoop
argument_list|(
name|OldLoop
argument_list|,
name|NewLoop
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/// addTopLevelLoop - This adds the specified loop to the collection of
end_comment

begin_comment
comment|/// top-level loops.
end_comment

begin_function
specifier|inline
name|void
name|addTopLevelLoop
parameter_list|(
name|Loop
modifier|*
name|New
parameter_list|)
block|{
name|LI
operator|->
name|addTopLevelLoop
argument_list|(
name|New
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/// removeBlock - This method completely removes BB from all data structures,
end_comment

begin_comment
comment|/// including all of the Loop objects it is nested in and our mapping from
end_comment

begin_comment
comment|/// BasicBlocks to loops.
end_comment

begin_function
name|void
name|removeBlock
parameter_list|(
name|BasicBlock
modifier|*
name|BB
parameter_list|)
block|{
name|LI
operator|->
name|removeBlock
argument_list|(
name|BB
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
unit|};
comment|// Allow clients to walk the list of nested loops...
end_comment

begin_expr_stmt
name|template
operator|<
operator|>
expr|struct
name|GraphTraits
operator|<
specifier|const
name|Loop
operator|*
operator|>
block|{
typedef|typedef
specifier|const
name|Loop
name|NodeType
typedef|;
end_expr_stmt

begin_typedef
typedef|typedef
name|std
operator|::
name|vector
operator|<
name|Loop
operator|*
operator|>
operator|::
name|const_iterator
name|ChildIteratorType
expr_stmt|;
end_typedef

begin_function
specifier|static
name|NodeType
modifier|*
name|getEntryNode
parameter_list|(
specifier|const
name|Loop
modifier|*
name|L
parameter_list|)
block|{
return|return
name|L
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|ChildIteratorType
name|child_begin
parameter_list|(
name|NodeType
modifier|*
name|N
parameter_list|)
block|{
return|return
name|N
operator|->
name|begin
argument_list|()
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|ChildIteratorType
name|child_end
parameter_list|(
name|NodeType
modifier|*
name|N
parameter_list|)
block|{
return|return
name|N
operator|->
name|end
argument_list|()
return|;
block|}
end_function

begin_expr_stmt
unit|};
name|template
operator|<
operator|>
expr|struct
name|GraphTraits
operator|<
name|Loop
operator|*
operator|>
block|{
typedef|typedef
name|Loop
name|NodeType
typedef|;
end_expr_stmt

begin_typedef
typedef|typedef
name|std
operator|::
name|vector
operator|<
name|Loop
operator|*
operator|>
operator|::
name|const_iterator
name|ChildIteratorType
expr_stmt|;
end_typedef

begin_function
specifier|static
name|NodeType
modifier|*
name|getEntryNode
parameter_list|(
name|Loop
modifier|*
name|L
parameter_list|)
block|{
return|return
name|L
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|ChildIteratorType
name|child_begin
parameter_list|(
name|NodeType
modifier|*
name|N
parameter_list|)
block|{
return|return
name|N
operator|->
name|begin
argument_list|()
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|ChildIteratorType
name|child_end
parameter_list|(
name|NodeType
modifier|*
name|N
parameter_list|)
block|{
return|return
name|N
operator|->
name|end
argument_list|()
return|;
block|}
end_function

begin_expr_stmt
unit|};
name|template
operator|<
name|class
name|BlockT
operator|>
name|void
name|LoopBase
operator|<
name|BlockT
operator|>
operator|::
name|addBasicBlockToLoop
argument_list|(
argument|BlockT *NewBB
argument_list|,
argument|LoopInfoBase<BlockT>&LIB
argument_list|)
block|{
name|assert
argument_list|(
operator|(
name|Blocks
operator|.
name|empty
argument_list|()
operator|||
name|LIB
index|[
name|getHeader
argument_list|()
index|]
operator|==
name|this
operator|)
operator|&&
literal|"Incorrect LI specified for this loop!"
argument_list|)
block|;
name|assert
argument_list|(
name|NewBB
operator|&&
literal|"Cannot add a null basic block to the loop!"
argument_list|)
block|;
name|assert
argument_list|(
name|LIB
index|[
name|NewBB
index|]
operator|==
literal|0
operator|&&
literal|"BasicBlock already in the loop!"
argument_list|)
block|;
comment|// Add the loop mapping to the LoopInfo object...
name|LIB
operator|.
name|BBMap
index|[
name|NewBB
index|]
operator|=
name|this
block|;
comment|// Add the basic block to this loop and all parent loops...
name|LoopBase
operator|<
name|BlockT
operator|>
operator|*
name|L
operator|=
name|this
block|;
while|while
condition|(
name|L
condition|)
block|{
name|L
operator|->
name|Blocks
operator|.
name|push_back
argument_list|(
name|NewBB
argument_list|)
expr_stmt|;
name|L
operator|=
name|L
operator|->
name|getParentLoop
argument_list|()
expr_stmt|;
block|}
end_expr_stmt

begin_comment
unit|}  }
comment|// End llvm namespace
end_comment

begin_endif
endif|#
directive|endif
end_endif

end_unit

