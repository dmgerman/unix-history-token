begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===---- llvm/Analysis/ScalarEvolutionExpander.h - SCEV Exprs --*- C++ -*-===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file defines the classes used to generate code from scalar expressions.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LLVM_ANALYSIS_SCALAREVOLUTIONEXPANDER_H
end_ifndef

begin_define
define|#
directive|define
name|LLVM_ANALYSIS_SCALAREVOLUTIONEXPANDER_H
end_define

begin_include
include|#
directive|include
file|"llvm/ADT/DenseMap.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/DenseSet.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/Optional.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Analysis/ScalarEvolutionExpressions.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Analysis/ScalarEvolutionNormalization.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Analysis/TargetFolder.h"
end_include

begin_include
include|#
directive|include
file|"llvm/IR/IRBuilder.h"
end_include

begin_include
include|#
directive|include
file|"llvm/IR/ValueHandle.h"
end_include

begin_decl_stmt
name|namespace
name|llvm
block|{
name|class
name|TargetTransformInfo
decl_stmt|;
comment|/// Return true if the given expression is safe to expand in the sense that
comment|/// all materialized values are safe to speculate.
name|bool
name|isSafeToExpand
parameter_list|(
specifier|const
name|SCEV
modifier|*
name|S
parameter_list|,
name|ScalarEvolution
modifier|&
name|SE
parameter_list|)
function_decl|;
comment|/// This class uses information about analyze scalars to rewrite expressions
comment|/// in canonical form.
comment|///
comment|/// Clients should create an instance of this class when rewriting is needed,
comment|/// and destroy it when finished to allow the release of the associated
comment|/// memory.
name|class
name|SCEVExpander
range|:
name|public
name|SCEVVisitor
operator|<
name|SCEVExpander
decl_stmt|,
name|Value
modifier|*
decl|>
block|{
name|ScalarEvolution
modifier|&
name|SE
decl_stmt|;
specifier|const
name|DataLayout
modifier|&
name|DL
decl_stmt|;
comment|// New instructions receive a name to identifies them with the current pass.
specifier|const
name|char
modifier|*
name|IVName
decl_stmt|;
comment|// InsertedExpressions caches Values for reuse, so must track RAUW.
name|DenseMap
operator|<
name|std
operator|::
name|pair
operator|<
specifier|const
name|SCEV
operator|*
operator|,
name|Instruction
operator|*
operator|>
operator|,
name|TrackingVH
operator|<
name|Value
operator|>>
name|InsertedExpressions
expr_stmt|;
comment|// InsertedValues only flags inserted instructions so needs no RAUW.
name|DenseSet
operator|<
name|AssertingVH
operator|<
name|Value
operator|>>
name|InsertedValues
expr_stmt|;
name|DenseSet
operator|<
name|AssertingVH
operator|<
name|Value
operator|>>
name|InsertedPostIncValues
expr_stmt|;
comment|/// A memoization of the "relevant" loop for a given SCEV.
name|DenseMap
operator|<
specifier|const
name|SCEV
operator|*
operator|,
specifier|const
name|Loop
operator|*
operator|>
name|RelevantLoops
expr_stmt|;
comment|/// Addrecs referring to any of the given loops are expanded in post-inc
comment|/// mode. For example, expanding {1,+,1}<L> in post-inc mode returns the add
comment|/// instruction that adds one to the phi for {0,+,1}<L>, as opposed to a new
comment|/// phi starting at 1. This is only supported in non-canonical mode.
name|PostIncLoopSet
name|PostIncLoops
decl_stmt|;
comment|/// When this is non-null, addrecs expanded in the loop it indicates should
comment|/// be inserted with increments at IVIncInsertPos.
specifier|const
name|Loop
modifier|*
name|IVIncInsertLoop
decl_stmt|;
comment|/// When expanding addrecs in the IVIncInsertLoop loop, insert the IV
comment|/// increment at this position.
name|Instruction
modifier|*
name|IVIncInsertPos
decl_stmt|;
comment|/// Phis that complete an IV chain. Reuse
name|DenseSet
operator|<
name|AssertingVH
operator|<
name|PHINode
operator|>>
name|ChainedPhis
expr_stmt|;
comment|/// When true, expressions are expanded in "canonical" form. In particular,
comment|/// addrecs are expanded as arithmetic based on a canonical induction
comment|/// variable. When false, expression are expanded in a more literal form.
name|bool
name|CanonicalMode
decl_stmt|;
comment|/// When invoked from LSR, the expander is in "strength reduction" mode. The
comment|/// only difference is that phi's are only reused if they are already in
comment|/// "expanded" form.
name|bool
name|LSRMode
decl_stmt|;
typedef|typedef
name|IRBuilder
operator|<
name|TargetFolder
operator|>
name|BuilderType
expr_stmt|;
name|BuilderType
name|Builder
decl_stmt|;
comment|// RAII object that stores the current insertion point and restores it when
comment|// the object is destroyed. This includes the debug location.  Duplicated
comment|// from InsertPointGuard to add SetInsertPoint() which is used to updated
comment|// InsertPointGuards stack when insert points are moved during SCEV
comment|// expansion.
name|class
name|SCEVInsertPointGuard
block|{
name|IRBuilderBase
modifier|&
name|Builder
decl_stmt|;
name|AssertingVH
operator|<
name|BasicBlock
operator|>
name|Block
expr_stmt|;
name|BasicBlock
operator|::
name|iterator
name|Point
expr_stmt|;
name|DebugLoc
name|DbgLoc
decl_stmt|;
name|SCEVExpander
modifier|*
name|SE
decl_stmt|;
name|SCEVInsertPointGuard
argument_list|(
specifier|const
name|SCEVInsertPointGuard
operator|&
argument_list|)
operator|=
name|delete
expr_stmt|;
name|SCEVInsertPointGuard
modifier|&
name|operator
init|=
operator|(
specifier|const
name|SCEVInsertPointGuard
operator|&
operator|)
operator|=
name|delete
decl_stmt|;
name|public
label|:
name|SCEVInsertPointGuard
argument_list|(
name|IRBuilderBase
operator|&
name|B
argument_list|,
name|SCEVExpander
operator|*
name|SE
argument_list|)
operator|:
name|Builder
argument_list|(
name|B
argument_list|)
operator|,
name|Block
argument_list|(
name|B
operator|.
name|GetInsertBlock
argument_list|()
argument_list|)
operator|,
name|Point
argument_list|(
name|B
operator|.
name|GetInsertPoint
argument_list|()
argument_list|)
operator|,
name|DbgLoc
argument_list|(
name|B
operator|.
name|getCurrentDebugLocation
argument_list|()
argument_list|)
operator|,
name|SE
argument_list|(
argument|SE
argument_list|)
block|{
name|SE
operator|->
name|InsertPointGuards
operator|.
name|push_back
argument_list|(
name|this
argument_list|)
block|;       }
operator|~
name|SCEVInsertPointGuard
argument_list|()
block|{
comment|// These guards should always created/destroyed in FIFO order since they
comment|// are used to guard lexically scoped blocks of code in
comment|// ScalarEvolutionExpander.
name|assert
argument_list|(
name|SE
operator|->
name|InsertPointGuards
operator|.
name|back
argument_list|()
operator|==
name|this
argument_list|)
block|;
name|SE
operator|->
name|InsertPointGuards
operator|.
name|pop_back
argument_list|()
block|;
name|Builder
operator|.
name|restoreIP
argument_list|(
name|IRBuilderBase
operator|::
name|InsertPoint
argument_list|(
name|Block
argument_list|,
name|Point
argument_list|)
argument_list|)
block|;
name|Builder
operator|.
name|SetCurrentDebugLocation
argument_list|(
name|DbgLoc
argument_list|)
block|;       }
name|BasicBlock
operator|::
name|iterator
name|GetInsertPoint
argument_list|()
specifier|const
block|{
return|return
name|Point
return|;
block|}
name|void
name|SetInsertPoint
argument_list|(
name|BasicBlock
operator|::
name|iterator
name|I
argument_list|)
block|{
name|Point
operator|=
name|I
expr_stmt|;
block|}
block|}
empty_stmt|;
comment|/// Stack of pointers to saved insert points, used to keep insert points
comment|/// consistent when instructions are moved.
name|SmallVector
operator|<
name|SCEVInsertPointGuard
operator|*
operator|,
literal|8
operator|>
name|InsertPointGuards
expr_stmt|;
ifndef|#
directive|ifndef
name|NDEBUG
specifier|const
name|char
modifier|*
name|DebugType
decl_stmt|;
endif|#
directive|endif
name|friend
block|struct
name|SCEVVisitor
operator|<
name|SCEVExpander
operator|,
name|Value
operator|*
operator|>
expr_stmt|;
name|public
label|:
comment|/// Construct a SCEVExpander in "canonical" mode.
name|explicit
name|SCEVExpander
argument_list|(
name|ScalarEvolution
operator|&
name|se
argument_list|,
specifier|const
name|DataLayout
operator|&
name|DL
argument_list|,
specifier|const
name|char
operator|*
name|name
argument_list|)
operator|:
name|SE
argument_list|(
name|se
argument_list|)
operator|,
name|DL
argument_list|(
name|DL
argument_list|)
operator|,
name|IVName
argument_list|(
name|name
argument_list|)
operator|,
name|IVIncInsertLoop
argument_list|(
name|nullptr
argument_list|)
operator|,
name|IVIncInsertPos
argument_list|(
name|nullptr
argument_list|)
operator|,
name|CanonicalMode
argument_list|(
name|true
argument_list|)
operator|,
name|LSRMode
argument_list|(
name|false
argument_list|)
operator|,
name|Builder
argument_list|(
argument|se.getContext()
argument_list|,
argument|TargetFolder(DL)
argument_list|)
block|{
ifndef|#
directive|ifndef
name|NDEBUG
name|DebugType
operator|=
literal|""
block|;
endif|#
directive|endif
block|}
operator|~
name|SCEVExpander
argument_list|()
block|{
comment|// Make sure the insert point guard stack is consistent.
name|assert
argument_list|(
name|InsertPointGuards
operator|.
name|empty
argument_list|()
argument_list|)
block|;     }
ifndef|#
directive|ifndef
name|NDEBUG
name|void
name|setDebugType
argument_list|(
argument|const char* s
argument_list|)
block|{
name|DebugType
operator|=
name|s
block|; }
endif|#
directive|endif
comment|/// Erase the contents of the InsertedExpressions map so that users trying
comment|/// to expand the same expression into multiple BasicBlocks or different
comment|/// places within the same BasicBlock can do so.
name|void
name|clear
argument_list|()
block|{
name|InsertedExpressions
operator|.
name|clear
argument_list|()
block|;
name|InsertedValues
operator|.
name|clear
argument_list|()
block|;
name|InsertedPostIncValues
operator|.
name|clear
argument_list|()
block|;
name|ChainedPhis
operator|.
name|clear
argument_list|()
block|;     }
comment|/// Return true for expressions that may incur non-trivial cost to evaluate
comment|/// at runtime.
comment|///
comment|/// At is an optional parameter which specifies point in code where user is
comment|/// going to expand this expression. Sometimes this knowledge can lead to a
comment|/// more accurate cost estimation.
name|bool
name|isHighCostExpansion
argument_list|(
argument|const SCEV *Expr
argument_list|,
argument|Loop *L
argument_list|,
argument|const Instruction *At = nullptr
argument_list|)
block|{
name|SmallPtrSet
operator|<
specifier|const
name|SCEV
operator|*
block|,
literal|8
operator|>
name|Processed
block|;
return|return
name|isHighCostExpansionHelper
argument_list|(
name|Expr
argument_list|,
name|L
argument_list|,
name|At
argument_list|,
name|Processed
argument_list|)
return|;
block|}
comment|/// This method returns the canonical induction variable of the specified
comment|/// type for the specified loop (inserting one if there is none).  A
comment|/// canonical induction variable starts at zero and steps by one on each
comment|/// iteration.
name|PHINode
modifier|*
name|getOrInsertCanonicalInductionVariable
parameter_list|(
specifier|const
name|Loop
modifier|*
name|L
parameter_list|,
name|Type
modifier|*
name|Ty
parameter_list|)
function_decl|;
comment|/// Return the induction variable increment's IV operand.
name|Instruction
modifier|*
name|getIVIncOperand
parameter_list|(
name|Instruction
modifier|*
name|IncV
parameter_list|,
name|Instruction
modifier|*
name|InsertPos
parameter_list|,
name|bool
name|allowScale
parameter_list|)
function_decl|;
comment|/// Utility for hoisting an IV increment.
name|bool
name|hoistIVInc
parameter_list|(
name|Instruction
modifier|*
name|IncV
parameter_list|,
name|Instruction
modifier|*
name|InsertPos
parameter_list|)
function_decl|;
comment|/// replace congruent phis with their most canonical representative. Return
comment|/// the number of phis eliminated.
name|unsigned
name|replaceCongruentIVs
argument_list|(
name|Loop
operator|*
name|L
argument_list|,
specifier|const
name|DominatorTree
operator|*
name|DT
argument_list|,
name|SmallVectorImpl
operator|<
name|WeakTrackingVH
operator|>
operator|&
name|DeadInsts
argument_list|,
specifier|const
name|TargetTransformInfo
operator|*
name|TTI
operator|=
name|nullptr
argument_list|)
decl_stmt|;
comment|/// Insert code to directly compute the specified SCEV expression into the
comment|/// program.  The inserted code is inserted into the specified block.
name|Value
modifier|*
name|expandCodeFor
parameter_list|(
specifier|const
name|SCEV
modifier|*
name|SH
parameter_list|,
name|Type
modifier|*
name|Ty
parameter_list|,
name|Instruction
modifier|*
name|I
parameter_list|)
function_decl|;
comment|/// Insert code to directly compute the specified SCEV expression into the
comment|/// program.  The inserted code is inserted into the SCEVExpander's current
comment|/// insertion point. If a type is specified, the result will be expanded to
comment|/// have that type, with a cast if necessary.
name|Value
modifier|*
name|expandCodeFor
parameter_list|(
specifier|const
name|SCEV
modifier|*
name|SH
parameter_list|,
name|Type
modifier|*
name|Ty
init|=
name|nullptr
parameter_list|)
function_decl|;
comment|/// Generates a code sequence that evaluates this predicate.  The inserted
comment|/// instructions will be at position \p Loc.  The result will be of type i1
comment|/// and will have a value of 0 when the predicate is false and 1 otherwise.
name|Value
modifier|*
name|expandCodeForPredicate
parameter_list|(
specifier|const
name|SCEVPredicate
modifier|*
name|Pred
parameter_list|,
name|Instruction
modifier|*
name|Loc
parameter_list|)
function_decl|;
comment|/// A specialized variant of expandCodeForPredicate, handling the case when
comment|/// we are expanding code for a SCEVEqualPredicate.
name|Value
modifier|*
name|expandEqualPredicate
parameter_list|(
specifier|const
name|SCEVEqualPredicate
modifier|*
name|Pred
parameter_list|,
name|Instruction
modifier|*
name|Loc
parameter_list|)
function_decl|;
comment|/// Generates code that evaluates if the \p AR expression will overflow.
name|Value
modifier|*
name|generateOverflowCheck
parameter_list|(
specifier|const
name|SCEVAddRecExpr
modifier|*
name|AR
parameter_list|,
name|Instruction
modifier|*
name|Loc
parameter_list|,
name|bool
name|Signed
parameter_list|)
function_decl|;
comment|/// A specialized variant of expandCodeForPredicate, handling the case when
comment|/// we are expanding code for a SCEVWrapPredicate.
name|Value
modifier|*
name|expandWrapPredicate
parameter_list|(
specifier|const
name|SCEVWrapPredicate
modifier|*
name|P
parameter_list|,
name|Instruction
modifier|*
name|Loc
parameter_list|)
function_decl|;
comment|/// A specialized variant of expandCodeForPredicate, handling the case when
comment|/// we are expanding code for a SCEVUnionPredicate.
name|Value
modifier|*
name|expandUnionPredicate
parameter_list|(
specifier|const
name|SCEVUnionPredicate
modifier|*
name|Pred
parameter_list|,
name|Instruction
modifier|*
name|Loc
parameter_list|)
function_decl|;
comment|/// Set the current IV increment loop and position.
name|void
name|setIVIncInsertPos
parameter_list|(
specifier|const
name|Loop
modifier|*
name|L
parameter_list|,
name|Instruction
modifier|*
name|Pos
parameter_list|)
block|{
name|assert
argument_list|(
operator|!
name|CanonicalMode
operator|&&
literal|"IV increment positions are not supported in CanonicalMode"
argument_list|)
expr_stmt|;
name|IVIncInsertLoop
operator|=
name|L
expr_stmt|;
name|IVIncInsertPos
operator|=
name|Pos
expr_stmt|;
block|}
comment|/// Enable post-inc expansion for addrecs referring to the given
comment|/// loops. Post-inc expansion is only supported in non-canonical mode.
name|void
name|setPostInc
parameter_list|(
specifier|const
name|PostIncLoopSet
modifier|&
name|L
parameter_list|)
block|{
name|assert
argument_list|(
operator|!
name|CanonicalMode
operator|&&
literal|"Post-inc expansion is not supported in CanonicalMode"
argument_list|)
expr_stmt|;
name|PostIncLoops
operator|=
name|L
expr_stmt|;
block|}
comment|/// Disable all post-inc expansion.
name|void
name|clearPostInc
parameter_list|()
block|{
name|PostIncLoops
operator|.
name|clear
argument_list|()
expr_stmt|;
comment|// When we change the post-inc loop set, cached expansions may no
comment|// longer be valid.
name|InsertedPostIncValues
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
comment|/// Disable the behavior of expanding expressions in canonical form rather
comment|/// than in a more literal form. Non-canonical mode is useful for late
comment|/// optimization passes.
name|void
name|disableCanonicalMode
parameter_list|()
block|{
name|CanonicalMode
operator|=
name|false
expr_stmt|;
block|}
name|void
name|enableLSRMode
parameter_list|()
block|{
name|LSRMode
operator|=
name|true
expr_stmt|;
block|}
comment|/// Set the current insertion point. This is useful if multiple calls to
comment|/// expandCodeFor() are going to be made with the same insert point and the
comment|/// insert point may be moved during one of the expansions (e.g. if the
comment|/// insert point is not a block terminator).
name|void
name|setInsertPoint
parameter_list|(
name|Instruction
modifier|*
name|IP
parameter_list|)
block|{
name|assert
argument_list|(
name|IP
argument_list|)
expr_stmt|;
name|Builder
operator|.
name|SetInsertPoint
argument_list|(
name|IP
argument_list|)
expr_stmt|;
block|}
comment|/// Clear the current insertion point. This is useful if the instruction
comment|/// that had been serving as the insertion point may have been deleted.
name|void
name|clearInsertPoint
parameter_list|()
block|{
name|Builder
operator|.
name|ClearInsertionPoint
argument_list|()
expr_stmt|;
block|}
comment|/// Return true if the specified instruction was inserted by the code
comment|/// rewriter.  If so, the client should not modify the instruction.
name|bool
name|isInsertedInstruction
argument_list|(
name|Instruction
operator|*
name|I
argument_list|)
decl|const
block|{
return|return
name|InsertedValues
operator|.
name|count
argument_list|(
name|I
argument_list|)
operator|||
name|InsertedPostIncValues
operator|.
name|count
argument_list|(
name|I
argument_list|)
return|;
block|}
name|void
name|setChainedPhi
parameter_list|(
name|PHINode
modifier|*
name|PN
parameter_list|)
block|{
name|ChainedPhis
operator|.
name|insert
argument_list|(
name|PN
argument_list|)
expr_stmt|;
block|}
comment|/// Try to find existing LLVM IR value for S available at the point At.
name|Value
modifier|*
name|getExactExistingExpansion
parameter_list|(
specifier|const
name|SCEV
modifier|*
name|S
parameter_list|,
specifier|const
name|Instruction
modifier|*
name|At
parameter_list|,
name|Loop
modifier|*
name|L
parameter_list|)
function_decl|;
comment|/// Try to find the ValueOffsetPair for S. The function is mainly used to
comment|/// check whether S can be expanded cheaply.  If this returns a non-None
comment|/// value, we know we can codegen the `ValueOffsetPair` into a suitable
comment|/// expansion identical with S so that S can be expanded cheaply.
comment|///
comment|/// L is a hint which tells in which loop to look for the suitable value.
comment|/// On success return value which is equivalent to the expanded S at point
comment|/// At. Return nullptr if value was not found.
comment|///
comment|/// Note that this function does not perform an exhaustive search. I.e if it
comment|/// didn't find any value it does not mean that there is no such value.
comment|///
name|Optional
operator|<
name|ScalarEvolution
operator|::
name|ValueOffsetPair
operator|>
name|getRelatedExistingExpansion
argument_list|(
specifier|const
name|SCEV
operator|*
name|S
argument_list|,
specifier|const
name|Instruction
operator|*
name|At
argument_list|,
name|Loop
operator|*
name|L
argument_list|)
expr_stmt|;
name|private
label|:
name|LLVMContext
operator|&
name|getContext
argument_list|()
specifier|const
block|{
return|return
name|SE
operator|.
name|getContext
argument_list|()
return|;
block|}
comment|/// Recursive helper function for isHighCostExpansion.
name|bool
name|isHighCostExpansionHelper
argument_list|(
specifier|const
name|SCEV
operator|*
name|S
argument_list|,
name|Loop
operator|*
name|L
argument_list|,
specifier|const
name|Instruction
operator|*
name|At
argument_list|,
name|SmallPtrSetImpl
operator|<
specifier|const
name|SCEV
operator|*
operator|>
operator|&
name|Processed
argument_list|)
decl_stmt|;
comment|/// Insert the specified binary operator, doing a small amount of work to
comment|/// avoid inserting an obviously redundant operation.
name|Value
modifier|*
name|InsertBinop
argument_list|(
name|Instruction
operator|::
name|BinaryOps
name|Opcode
argument_list|,
name|Value
operator|*
name|LHS
argument_list|,
name|Value
operator|*
name|RHS
argument_list|)
decl_stmt|;
comment|/// Arrange for there to be a cast of V to Ty at IP, reusing an existing
comment|/// cast if a suitable one exists, moving an existing cast if a suitable one
comment|/// exists but isn't in the right place, or or creating a new one.
name|Value
modifier|*
name|ReuseOrCreateCast
argument_list|(
name|Value
operator|*
name|V
argument_list|,
name|Type
operator|*
name|Ty
argument_list|,
name|Instruction
operator|::
name|CastOps
name|Op
argument_list|,
name|BasicBlock
operator|::
name|iterator
name|IP
argument_list|)
decl_stmt|;
comment|/// Insert a cast of V to the specified type, which must be possible with a
comment|/// noop cast, doing what we can to share the casts.
name|Value
modifier|*
name|InsertNoopCastOfTo
parameter_list|(
name|Value
modifier|*
name|V
parameter_list|,
name|Type
modifier|*
name|Ty
parameter_list|)
function_decl|;
comment|/// Expand a SCEVAddExpr with a pointer type into a GEP instead of using
comment|/// ptrtoint+arithmetic+inttoptr.
name|Value
modifier|*
name|expandAddToGEP
parameter_list|(
specifier|const
name|SCEV
modifier|*
specifier|const
modifier|*
name|op_begin
parameter_list|,
specifier|const
name|SCEV
modifier|*
specifier|const
modifier|*
name|op_end
parameter_list|,
name|PointerType
modifier|*
name|PTy
parameter_list|,
name|Type
modifier|*
name|Ty
parameter_list|,
name|Value
modifier|*
name|V
parameter_list|)
function_decl|;
comment|/// Find a previous Value in ExprValueMap for expand.
name|ScalarEvolution
operator|::
name|ValueOffsetPair
name|FindValueInExprValueMap
argument_list|(
specifier|const
name|SCEV
operator|*
name|S
argument_list|,
specifier|const
name|Instruction
operator|*
name|InsertPt
argument_list|)
expr_stmt|;
name|Value
modifier|*
name|expand
parameter_list|(
specifier|const
name|SCEV
modifier|*
name|S
parameter_list|)
function_decl|;
comment|/// Determine the most "relevant" loop for the given SCEV.
specifier|const
name|Loop
modifier|*
name|getRelevantLoop
parameter_list|(
specifier|const
name|SCEV
modifier|*
parameter_list|)
function_decl|;
name|Value
modifier|*
name|visitConstant
parameter_list|(
specifier|const
name|SCEVConstant
modifier|*
name|S
parameter_list|)
block|{
return|return
name|S
operator|->
name|getValue
argument_list|()
return|;
block|}
name|Value
modifier|*
name|visitTruncateExpr
parameter_list|(
specifier|const
name|SCEVTruncateExpr
modifier|*
name|S
parameter_list|)
function_decl|;
name|Value
modifier|*
name|visitZeroExtendExpr
parameter_list|(
specifier|const
name|SCEVZeroExtendExpr
modifier|*
name|S
parameter_list|)
function_decl|;
name|Value
modifier|*
name|visitSignExtendExpr
parameter_list|(
specifier|const
name|SCEVSignExtendExpr
modifier|*
name|S
parameter_list|)
function_decl|;
name|Value
modifier|*
name|visitAddExpr
parameter_list|(
specifier|const
name|SCEVAddExpr
modifier|*
name|S
parameter_list|)
function_decl|;
name|Value
modifier|*
name|visitMulExpr
parameter_list|(
specifier|const
name|SCEVMulExpr
modifier|*
name|S
parameter_list|)
function_decl|;
name|Value
modifier|*
name|visitUDivExpr
parameter_list|(
specifier|const
name|SCEVUDivExpr
modifier|*
name|S
parameter_list|)
function_decl|;
name|Value
modifier|*
name|visitAddRecExpr
parameter_list|(
specifier|const
name|SCEVAddRecExpr
modifier|*
name|S
parameter_list|)
function_decl|;
name|Value
modifier|*
name|visitSMaxExpr
parameter_list|(
specifier|const
name|SCEVSMaxExpr
modifier|*
name|S
parameter_list|)
function_decl|;
name|Value
modifier|*
name|visitUMaxExpr
parameter_list|(
specifier|const
name|SCEVUMaxExpr
modifier|*
name|S
parameter_list|)
function_decl|;
name|Value
modifier|*
name|visitUnknown
parameter_list|(
specifier|const
name|SCEVUnknown
modifier|*
name|S
parameter_list|)
block|{
return|return
name|S
operator|->
name|getValue
argument_list|()
return|;
block|}
name|void
name|rememberInstruction
parameter_list|(
name|Value
modifier|*
name|I
parameter_list|)
function_decl|;
name|bool
name|isNormalAddRecExprPHI
parameter_list|(
name|PHINode
modifier|*
name|PN
parameter_list|,
name|Instruction
modifier|*
name|IncV
parameter_list|,
specifier|const
name|Loop
modifier|*
name|L
parameter_list|)
function_decl|;
name|bool
name|isExpandedAddRecExprPHI
parameter_list|(
name|PHINode
modifier|*
name|PN
parameter_list|,
name|Instruction
modifier|*
name|IncV
parameter_list|,
specifier|const
name|Loop
modifier|*
name|L
parameter_list|)
function_decl|;
name|Value
modifier|*
name|expandAddRecExprLiterally
parameter_list|(
specifier|const
name|SCEVAddRecExpr
modifier|*
parameter_list|)
function_decl|;
name|PHINode
modifier|*
name|getAddRecExprPHILiterally
parameter_list|(
specifier|const
name|SCEVAddRecExpr
modifier|*
name|Normalized
parameter_list|,
specifier|const
name|Loop
modifier|*
name|L
parameter_list|,
name|Type
modifier|*
name|ExpandTy
parameter_list|,
name|Type
modifier|*
name|IntTy
parameter_list|,
name|Type
modifier|*
modifier|&
name|TruncTy
parameter_list|,
name|bool
modifier|&
name|InvertStep
parameter_list|)
function_decl|;
name|Value
modifier|*
name|expandIVInc
parameter_list|(
name|PHINode
modifier|*
name|PN
parameter_list|,
name|Value
modifier|*
name|StepV
parameter_list|,
specifier|const
name|Loop
modifier|*
name|L
parameter_list|,
name|Type
modifier|*
name|ExpandTy
parameter_list|,
name|Type
modifier|*
name|IntTy
parameter_list|,
name|bool
name|useSubtract
parameter_list|)
function_decl|;
name|void
name|hoistBeforePos
parameter_list|(
name|DominatorTree
modifier|*
name|DT
parameter_list|,
name|Instruction
modifier|*
name|InstToHoist
parameter_list|,
name|Instruction
modifier|*
name|Pos
parameter_list|,
name|PHINode
modifier|*
name|LoopPhi
parameter_list|)
function_decl|;
name|void
name|fixupInsertPoints
parameter_list|(
name|Instruction
modifier|*
name|I
parameter_list|)
function_decl|;
block|}
empty_stmt|;
block|}
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

end_unit

