begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===- llvm/Analysis/ScalarEvolutionExpressions.h - SCEV Exprs --*- C++ -*-===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file defines the classes used to represent and build scalar expressions.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LLVM_ANALYSIS_SCALAREVOLUTION_EXPRESSIONS_H
end_ifndef

begin_define
define|#
directive|define
name|LLVM_ANALYSIS_SCALAREVOLUTION_EXPRESSIONS_H
end_define

begin_include
include|#
directive|include
file|"llvm/Analysis/ScalarEvolution.h"
end_include

begin_decl_stmt
name|namespace
name|llvm
block|{
name|class
name|ConstantInt
decl_stmt|;
name|class
name|ConstantRange
decl_stmt|;
name|class
name|APInt
decl_stmt|;
name|class
name|DominatorTree
decl_stmt|;
enum|enum
name|SCEVTypes
block|{
comment|// These should be ordered in terms of increasing complexity to make the
comment|// folders simpler.
name|scConstant
block|,
name|scTruncate
block|,
name|scZeroExtend
block|,
name|scSignExtend
block|,
name|scAddExpr
block|,
name|scMulExpr
block|,
name|scUDivExpr
block|,
name|scAddRecExpr
block|,
name|scUMaxExpr
block|,
name|scSMaxExpr
block|,
name|scUnknown
block|,
name|scCouldNotCompute
block|}
enum|;
comment|//===--------------------------------------------------------------------===//
comment|/// SCEVConstant - This class represents a constant integer value.
comment|///
name|class
name|SCEVConstant
range|:
name|public
name|SCEV
block|{
name|friend
name|class
name|ScalarEvolution
block|;
name|ConstantInt
operator|*
name|V
block|;
name|explicit
name|SCEVConstant
argument_list|(
name|ConstantInt
operator|*
name|v
argument_list|)
operator|:
name|SCEV
argument_list|(
name|scConstant
argument_list|)
block|,
name|V
argument_list|(
argument|v
argument_list|)
block|{}
name|virtual
operator|~
name|SCEVConstant
argument_list|()
block|;
name|public
operator|:
name|ConstantInt
operator|*
name|getValue
argument_list|()
specifier|const
block|{
return|return
name|V
return|;
block|}
name|virtual
name|bool
name|isLoopInvariant
argument_list|(
argument|const Loop *L
argument_list|)
specifier|const
block|{
return|return
name|true
return|;
block|}
name|virtual
name|bool
name|hasComputableLoopEvolution
argument_list|(
argument|const Loop *L
argument_list|)
specifier|const
block|{
return|return
name|false
return|;
comment|// Not loop variant
block|}
name|virtual
specifier|const
name|Type
operator|*
name|getType
argument_list|()
specifier|const
block|;
name|SCEVHandle
name|replaceSymbolicValuesWithConcrete
argument_list|(
argument|const SCEVHandle&Sym
argument_list|,
argument|const SCEVHandle&Conc
argument_list|,
argument|ScalarEvolution&SE
argument_list|)
specifier|const
block|{
return|return
name|this
return|;
block|}
name|bool
name|dominates
argument_list|(
argument|BasicBlock *BB
argument_list|,
argument|DominatorTree *DT
argument_list|)
specifier|const
block|{
return|return
name|true
return|;
block|}
name|virtual
name|void
name|print
argument_list|(
argument|raw_ostream&OS
argument_list|)
specifier|const
block|;
comment|/// Methods for support type inquiry through isa, cast, and dyn_cast:
specifier|static
specifier|inline
name|bool
name|classof
argument_list|(
argument|const SCEVConstant *S
argument_list|)
block|{
return|return
name|true
return|;
block|}
specifier|static
specifier|inline
name|bool
name|classof
argument_list|(
argument|const SCEV *S
argument_list|)
block|{
return|return
name|S
operator|->
name|getSCEVType
argument_list|()
operator|==
name|scConstant
return|;
block|}
expr|}
block|;
comment|//===--------------------------------------------------------------------===//
comment|/// SCEVCastExpr - This is the base class for unary cast operator classes.
comment|///
name|class
name|SCEVCastExpr
operator|:
name|public
name|SCEV
block|{
name|protected
operator|:
name|SCEVHandle
name|Op
block|;
specifier|const
name|Type
operator|*
name|Ty
block|;
name|SCEVCastExpr
argument_list|(
argument|unsigned SCEVTy
argument_list|,
argument|const SCEVHandle&op
argument_list|,
argument|const Type *ty
argument_list|)
block|;
name|virtual
operator|~
name|SCEVCastExpr
argument_list|()
block|;
name|public
operator|:
specifier|const
name|SCEVHandle
operator|&
name|getOperand
argument_list|()
specifier|const
block|{
return|return
name|Op
return|;
block|}
name|virtual
specifier|const
name|Type
operator|*
name|getType
argument_list|()
specifier|const
block|{
return|return
name|Ty
return|;
block|}
name|virtual
name|bool
name|isLoopInvariant
argument_list|(
argument|const Loop *L
argument_list|)
specifier|const
block|{
return|return
name|Op
operator|->
name|isLoopInvariant
argument_list|(
name|L
argument_list|)
return|;
block|}
name|virtual
name|bool
name|hasComputableLoopEvolution
argument_list|(
argument|const Loop *L
argument_list|)
specifier|const
block|{
return|return
name|Op
operator|->
name|hasComputableLoopEvolution
argument_list|(
name|L
argument_list|)
return|;
block|}
name|virtual
name|bool
name|dominates
argument_list|(
argument|BasicBlock *BB
argument_list|,
argument|DominatorTree *DT
argument_list|)
specifier|const
block|;
comment|/// Methods for support type inquiry through isa, cast, and dyn_cast:
specifier|static
specifier|inline
name|bool
name|classof
argument_list|(
argument|const SCEVCastExpr *S
argument_list|)
block|{
return|return
name|true
return|;
block|}
specifier|static
specifier|inline
name|bool
name|classof
argument_list|(
argument|const SCEV *S
argument_list|)
block|{
return|return
name|S
operator|->
name|getSCEVType
argument_list|()
operator|==
name|scTruncate
operator|||
name|S
operator|->
name|getSCEVType
argument_list|()
operator|==
name|scZeroExtend
operator|||
name|S
operator|->
name|getSCEVType
argument_list|()
operator|==
name|scSignExtend
return|;
block|}
expr|}
block|;
comment|//===--------------------------------------------------------------------===//
comment|/// SCEVTruncateExpr - This class represents a truncation of an integer value
comment|/// to a smaller integer value.
comment|///
name|class
name|SCEVTruncateExpr
operator|:
name|public
name|SCEVCastExpr
block|{
name|friend
name|class
name|ScalarEvolution
block|;
name|SCEVTruncateExpr
argument_list|(
specifier|const
name|SCEVHandle
operator|&
name|op
argument_list|,
specifier|const
name|Type
operator|*
name|ty
argument_list|)
block|;
name|virtual
operator|~
name|SCEVTruncateExpr
argument_list|()
block|;
name|public
operator|:
name|SCEVHandle
name|replaceSymbolicValuesWithConcrete
argument_list|(
argument|const SCEVHandle&Sym
argument_list|,
argument|const SCEVHandle&Conc
argument_list|,
argument|ScalarEvolution&SE
argument_list|)
specifier|const
block|{
name|SCEVHandle
name|H
operator|=
name|Op
operator|->
name|replaceSymbolicValuesWithConcrete
argument_list|(
name|Sym
argument_list|,
name|Conc
argument_list|,
name|SE
argument_list|)
block|;
if|if
condition|(
name|H
operator|==
name|Op
condition|)
return|return
name|this
return|;
return|return
name|SE
operator|.
name|getTruncateExpr
argument_list|(
name|H
argument_list|,
name|Ty
argument_list|)
return|;
block|}
name|virtual
name|void
name|print
argument_list|(
argument|raw_ostream&OS
argument_list|)
specifier|const
block|;
comment|/// Methods for support type inquiry through isa, cast, and dyn_cast:
specifier|static
specifier|inline
name|bool
name|classof
argument_list|(
argument|const SCEVTruncateExpr *S
argument_list|)
block|{
return|return
name|true
return|;
block|}
specifier|static
specifier|inline
name|bool
name|classof
argument_list|(
argument|const SCEV *S
argument_list|)
block|{
return|return
name|S
operator|->
name|getSCEVType
argument_list|()
operator|==
name|scTruncate
return|;
block|}
expr|}
block|;
comment|//===--------------------------------------------------------------------===//
comment|/// SCEVZeroExtendExpr - This class represents a zero extension of a small
comment|/// integer value to a larger integer value.
comment|///
name|class
name|SCEVZeroExtendExpr
operator|:
name|public
name|SCEVCastExpr
block|{
name|friend
name|class
name|ScalarEvolution
block|;
name|SCEVZeroExtendExpr
argument_list|(
specifier|const
name|SCEVHandle
operator|&
name|op
argument_list|,
specifier|const
name|Type
operator|*
name|ty
argument_list|)
block|;
name|virtual
operator|~
name|SCEVZeroExtendExpr
argument_list|()
block|;
name|public
operator|:
name|SCEVHandle
name|replaceSymbolicValuesWithConcrete
argument_list|(
argument|const SCEVHandle&Sym
argument_list|,
argument|const SCEVHandle&Conc
argument_list|,
argument|ScalarEvolution&SE
argument_list|)
specifier|const
block|{
name|SCEVHandle
name|H
operator|=
name|Op
operator|->
name|replaceSymbolicValuesWithConcrete
argument_list|(
name|Sym
argument_list|,
name|Conc
argument_list|,
name|SE
argument_list|)
block|;
if|if
condition|(
name|H
operator|==
name|Op
condition|)
return|return
name|this
return|;
return|return
name|SE
operator|.
name|getZeroExtendExpr
argument_list|(
name|H
argument_list|,
name|Ty
argument_list|)
return|;
block|}
name|virtual
name|void
name|print
argument_list|(
argument|raw_ostream&OS
argument_list|)
specifier|const
block|;
comment|/// Methods for support type inquiry through isa, cast, and dyn_cast:
specifier|static
specifier|inline
name|bool
name|classof
argument_list|(
argument|const SCEVZeroExtendExpr *S
argument_list|)
block|{
return|return
name|true
return|;
block|}
specifier|static
specifier|inline
name|bool
name|classof
argument_list|(
argument|const SCEV *S
argument_list|)
block|{
return|return
name|S
operator|->
name|getSCEVType
argument_list|()
operator|==
name|scZeroExtend
return|;
block|}
expr|}
block|;
comment|//===--------------------------------------------------------------------===//
comment|/// SCEVSignExtendExpr - This class represents a sign extension of a small
comment|/// integer value to a larger integer value.
comment|///
name|class
name|SCEVSignExtendExpr
operator|:
name|public
name|SCEVCastExpr
block|{
name|friend
name|class
name|ScalarEvolution
block|;
name|SCEVSignExtendExpr
argument_list|(
specifier|const
name|SCEVHandle
operator|&
name|op
argument_list|,
specifier|const
name|Type
operator|*
name|ty
argument_list|)
block|;
name|virtual
operator|~
name|SCEVSignExtendExpr
argument_list|()
block|;
name|public
operator|:
name|SCEVHandle
name|replaceSymbolicValuesWithConcrete
argument_list|(
argument|const SCEVHandle&Sym
argument_list|,
argument|const SCEVHandle&Conc
argument_list|,
argument|ScalarEvolution&SE
argument_list|)
specifier|const
block|{
name|SCEVHandle
name|H
operator|=
name|Op
operator|->
name|replaceSymbolicValuesWithConcrete
argument_list|(
name|Sym
argument_list|,
name|Conc
argument_list|,
name|SE
argument_list|)
block|;
if|if
condition|(
name|H
operator|==
name|Op
condition|)
return|return
name|this
return|;
return|return
name|SE
operator|.
name|getSignExtendExpr
argument_list|(
name|H
argument_list|,
name|Ty
argument_list|)
return|;
block|}
name|virtual
name|void
name|print
argument_list|(
argument|raw_ostream&OS
argument_list|)
specifier|const
block|;
comment|/// Methods for support type inquiry through isa, cast, and dyn_cast:
specifier|static
specifier|inline
name|bool
name|classof
argument_list|(
argument|const SCEVSignExtendExpr *S
argument_list|)
block|{
return|return
name|true
return|;
block|}
specifier|static
specifier|inline
name|bool
name|classof
argument_list|(
argument|const SCEV *S
argument_list|)
block|{
return|return
name|S
operator|->
name|getSCEVType
argument_list|()
operator|==
name|scSignExtend
return|;
block|}
expr|}
block|;
comment|//===--------------------------------------------------------------------===//
comment|/// SCEVNAryExpr - This node is a base class providing common
comment|/// functionality for n'ary operators.
comment|///
name|class
name|SCEVNAryExpr
operator|:
name|public
name|SCEV
block|{
name|protected
operator|:
name|std
operator|::
name|vector
operator|<
name|SCEVHandle
operator|>
name|Operands
block|;
name|SCEVNAryExpr
argument_list|(
argument|enum SCEVTypes T
argument_list|,
argument|const std::vector<SCEVHandle>&ops
argument_list|)
operator|:
name|SCEV
argument_list|(
name|T
argument_list|)
block|,
name|Operands
argument_list|(
argument|ops
argument_list|)
block|{}
name|virtual
operator|~
name|SCEVNAryExpr
argument_list|()
block|{}
name|public
operator|:
name|unsigned
name|getNumOperands
argument_list|()
specifier|const
block|{
return|return
operator|(
name|unsigned
operator|)
name|Operands
operator|.
name|size
argument_list|()
return|;
block|}
specifier|const
name|SCEVHandle
operator|&
name|getOperand
argument_list|(
argument|unsigned i
argument_list|)
specifier|const
block|{
name|assert
argument_list|(
name|i
operator|<
name|Operands
operator|.
name|size
argument_list|()
operator|&&
literal|"Operand index out of range!"
argument_list|)
block|;
return|return
name|Operands
index|[
name|i
index|]
return|;
block|}
specifier|const
name|std
operator|::
name|vector
operator|<
name|SCEVHandle
operator|>
operator|&
name|getOperands
argument_list|()
specifier|const
block|{
return|return
name|Operands
return|;
block|}
typedef|typedef
name|std
operator|::
name|vector
operator|<
name|SCEVHandle
operator|>
operator|::
name|const_iterator
name|op_iterator
expr_stmt|;
name|op_iterator
name|op_begin
argument_list|()
specifier|const
block|{
return|return
name|Operands
operator|.
name|begin
argument_list|()
return|;
block|}
name|op_iterator
name|op_end
argument_list|()
specifier|const
block|{
return|return
name|Operands
operator|.
name|end
argument_list|()
return|;
block|}
name|virtual
name|bool
name|isLoopInvariant
argument_list|(
argument|const Loop *L
argument_list|)
specifier|const
block|{
for|for
control|(
name|unsigned
name|i
init|=
literal|0
init|,
name|e
init|=
name|getNumOperands
argument_list|()
init|;
name|i
operator|!=
name|e
condition|;
operator|++
name|i
control|)
if|if
condition|(
operator|!
name|getOperand
argument_list|(
name|i
argument_list|)
operator|->
name|isLoopInvariant
argument_list|(
name|L
argument_list|)
condition|)
return|return
name|false
return|;
return|return
name|true
return|;
block|}
comment|// hasComputableLoopEvolution - N-ary expressions have computable loop
comment|// evolutions iff they have at least one operand that varies with the loop,
comment|// but that all varying operands are computable.
name|virtual
name|bool
name|hasComputableLoopEvolution
argument_list|(
argument|const Loop *L
argument_list|)
specifier|const
block|{
name|bool
name|HasVarying
operator|=
name|false
block|;
for|for
control|(
name|unsigned
name|i
init|=
literal|0
init|,
name|e
init|=
name|getNumOperands
argument_list|()
init|;
name|i
operator|!=
name|e
condition|;
operator|++
name|i
control|)
if|if
condition|(
operator|!
name|getOperand
argument_list|(
name|i
argument_list|)
operator|->
name|isLoopInvariant
argument_list|(
name|L
argument_list|)
condition|)
block|{
if|if
condition|(
name|getOperand
argument_list|(
name|i
argument_list|)
operator|->
name|hasComputableLoopEvolution
argument_list|(
name|L
argument_list|)
condition|)
name|HasVarying
operator|=
name|true
expr_stmt|;
else|else
return|return
name|false
return|;
block|}
return|return
name|HasVarying
return|;
block|}
name|bool
name|dominates
argument_list|(
argument|BasicBlock *BB
argument_list|,
argument|DominatorTree *DT
argument_list|)
specifier|const
block|;
name|virtual
specifier|const
name|Type
operator|*
name|getType
argument_list|()
specifier|const
block|{
return|return
name|getOperand
argument_list|(
literal|0
argument_list|)
operator|->
name|getType
argument_list|()
return|;
block|}
comment|/// Methods for support type inquiry through isa, cast, and dyn_cast:
specifier|static
specifier|inline
name|bool
name|classof
argument_list|(
argument|const SCEVNAryExpr *S
argument_list|)
block|{
return|return
name|true
return|;
block|}
specifier|static
specifier|inline
name|bool
name|classof
argument_list|(
argument|const SCEV *S
argument_list|)
block|{
return|return
name|S
operator|->
name|getSCEVType
argument_list|()
operator|==
name|scAddExpr
operator|||
name|S
operator|->
name|getSCEVType
argument_list|()
operator|==
name|scMulExpr
operator|||
name|S
operator|->
name|getSCEVType
argument_list|()
operator|==
name|scSMaxExpr
operator|||
name|S
operator|->
name|getSCEVType
argument_list|()
operator|==
name|scUMaxExpr
operator|||
name|S
operator|->
name|getSCEVType
argument_list|()
operator|==
name|scAddRecExpr
return|;
block|}
expr|}
block|;
comment|//===--------------------------------------------------------------------===//
comment|/// SCEVCommutativeExpr - This node is the base class for n'ary commutative
comment|/// operators.
comment|///
name|class
name|SCEVCommutativeExpr
operator|:
name|public
name|SCEVNAryExpr
block|{
name|protected
operator|:
name|SCEVCommutativeExpr
argument_list|(
argument|enum SCEVTypes T
argument_list|,
argument|const std::vector<SCEVHandle>&ops
argument_list|)
operator|:
name|SCEVNAryExpr
argument_list|(
argument|T
argument_list|,
argument|ops
argument_list|)
block|{}
operator|~
name|SCEVCommutativeExpr
argument_list|()
block|;
name|public
operator|:
name|SCEVHandle
name|replaceSymbolicValuesWithConcrete
argument_list|(
argument|const SCEVHandle&Sym
argument_list|,
argument|const SCEVHandle&Conc
argument_list|,
argument|ScalarEvolution&SE
argument_list|)
specifier|const
block|;
name|virtual
specifier|const
name|char
operator|*
name|getOperationStr
argument_list|()
specifier|const
operator|=
literal|0
block|;
name|virtual
name|void
name|print
argument_list|(
argument|raw_ostream&OS
argument_list|)
specifier|const
block|;
comment|/// Methods for support type inquiry through isa, cast, and dyn_cast:
specifier|static
specifier|inline
name|bool
name|classof
argument_list|(
argument|const SCEVCommutativeExpr *S
argument_list|)
block|{
return|return
name|true
return|;
block|}
specifier|static
specifier|inline
name|bool
name|classof
argument_list|(
argument|const SCEV *S
argument_list|)
block|{
return|return
name|S
operator|->
name|getSCEVType
argument_list|()
operator|==
name|scAddExpr
operator|||
name|S
operator|->
name|getSCEVType
argument_list|()
operator|==
name|scMulExpr
operator|||
name|S
operator|->
name|getSCEVType
argument_list|()
operator|==
name|scSMaxExpr
operator|||
name|S
operator|->
name|getSCEVType
argument_list|()
operator|==
name|scUMaxExpr
return|;
block|}
expr|}
block|;
comment|//===--------------------------------------------------------------------===//
comment|/// SCEVAddExpr - This node represents an addition of some number of SCEVs.
comment|///
name|class
name|SCEVAddExpr
operator|:
name|public
name|SCEVCommutativeExpr
block|{
name|friend
name|class
name|ScalarEvolution
block|;
name|explicit
name|SCEVAddExpr
argument_list|(
specifier|const
name|std
operator|::
name|vector
operator|<
name|SCEVHandle
operator|>
operator|&
name|ops
argument_list|)
operator|:
name|SCEVCommutativeExpr
argument_list|(
argument|scAddExpr
argument_list|,
argument|ops
argument_list|)
block|{     }
name|public
operator|:
name|virtual
specifier|const
name|char
operator|*
name|getOperationStr
argument_list|()
specifier|const
block|{
return|return
literal|" + "
return|;
block|}
comment|/// Methods for support type inquiry through isa, cast, and dyn_cast:
specifier|static
specifier|inline
name|bool
name|classof
argument_list|(
argument|const SCEVAddExpr *S
argument_list|)
block|{
return|return
name|true
return|;
block|}
specifier|static
specifier|inline
name|bool
name|classof
argument_list|(
argument|const SCEV *S
argument_list|)
block|{
return|return
name|S
operator|->
name|getSCEVType
argument_list|()
operator|==
name|scAddExpr
return|;
block|}
expr|}
block|;
comment|//===--------------------------------------------------------------------===//
comment|/// SCEVMulExpr - This node represents multiplication of some number of SCEVs.
comment|///
name|class
name|SCEVMulExpr
operator|:
name|public
name|SCEVCommutativeExpr
block|{
name|friend
name|class
name|ScalarEvolution
block|;
name|explicit
name|SCEVMulExpr
argument_list|(
specifier|const
name|std
operator|::
name|vector
operator|<
name|SCEVHandle
operator|>
operator|&
name|ops
argument_list|)
operator|:
name|SCEVCommutativeExpr
argument_list|(
argument|scMulExpr
argument_list|,
argument|ops
argument_list|)
block|{     }
name|public
operator|:
name|virtual
specifier|const
name|char
operator|*
name|getOperationStr
argument_list|()
specifier|const
block|{
return|return
literal|" * "
return|;
block|}
comment|/// Methods for support type inquiry through isa, cast, and dyn_cast:
specifier|static
specifier|inline
name|bool
name|classof
argument_list|(
argument|const SCEVMulExpr *S
argument_list|)
block|{
return|return
name|true
return|;
block|}
specifier|static
specifier|inline
name|bool
name|classof
argument_list|(
argument|const SCEV *S
argument_list|)
block|{
return|return
name|S
operator|->
name|getSCEVType
argument_list|()
operator|==
name|scMulExpr
return|;
block|}
expr|}
block|;
comment|//===--------------------------------------------------------------------===//
comment|/// SCEVUDivExpr - This class represents a binary unsigned division operation.
comment|///
name|class
name|SCEVUDivExpr
operator|:
name|public
name|SCEV
block|{
name|friend
name|class
name|ScalarEvolution
block|;
name|SCEVHandle
name|LHS
block|,
name|RHS
block|;
name|SCEVUDivExpr
argument_list|(
specifier|const
name|SCEVHandle
operator|&
name|lhs
argument_list|,
specifier|const
name|SCEVHandle
operator|&
name|rhs
argument_list|)
operator|:
name|SCEV
argument_list|(
name|scUDivExpr
argument_list|)
block|,
name|LHS
argument_list|(
name|lhs
argument_list|)
block|,
name|RHS
argument_list|(
argument|rhs
argument_list|)
block|{}
name|virtual
operator|~
name|SCEVUDivExpr
argument_list|()
block|;
name|public
operator|:
specifier|const
name|SCEVHandle
operator|&
name|getLHS
argument_list|()
specifier|const
block|{
return|return
name|LHS
return|;
block|}
specifier|const
name|SCEVHandle
operator|&
name|getRHS
argument_list|()
specifier|const
block|{
return|return
name|RHS
return|;
block|}
name|virtual
name|bool
name|isLoopInvariant
argument_list|(
argument|const Loop *L
argument_list|)
specifier|const
block|{
return|return
name|LHS
operator|->
name|isLoopInvariant
argument_list|(
name|L
argument_list|)
operator|&&
name|RHS
operator|->
name|isLoopInvariant
argument_list|(
name|L
argument_list|)
return|;
block|}
name|virtual
name|bool
name|hasComputableLoopEvolution
argument_list|(
argument|const Loop *L
argument_list|)
specifier|const
block|{
return|return
name|LHS
operator|->
name|hasComputableLoopEvolution
argument_list|(
name|L
argument_list|)
operator|&&
name|RHS
operator|->
name|hasComputableLoopEvolution
argument_list|(
name|L
argument_list|)
return|;
block|}
name|SCEVHandle
name|replaceSymbolicValuesWithConcrete
argument_list|(
argument|const SCEVHandle&Sym
argument_list|,
argument|const SCEVHandle&Conc
argument_list|,
argument|ScalarEvolution&SE
argument_list|)
specifier|const
block|{
name|SCEVHandle
name|L
operator|=
name|LHS
operator|->
name|replaceSymbolicValuesWithConcrete
argument_list|(
name|Sym
argument_list|,
name|Conc
argument_list|,
name|SE
argument_list|)
block|;
name|SCEVHandle
name|R
operator|=
name|RHS
operator|->
name|replaceSymbolicValuesWithConcrete
argument_list|(
name|Sym
argument_list|,
name|Conc
argument_list|,
name|SE
argument_list|)
block|;
if|if
condition|(
name|L
operator|==
name|LHS
operator|&&
name|R
operator|==
name|RHS
condition|)
return|return
name|this
return|;
else|else
return|return
name|SE
operator|.
name|getUDivExpr
argument_list|(
name|L
argument_list|,
name|R
argument_list|)
return|;
block|}
name|bool
name|dominates
argument_list|(
argument|BasicBlock *BB
argument_list|,
argument|DominatorTree *DT
argument_list|)
specifier|const
block|;
name|virtual
specifier|const
name|Type
operator|*
name|getType
argument_list|()
specifier|const
block|;
name|void
name|print
argument_list|(
argument|raw_ostream&OS
argument_list|)
specifier|const
block|;
comment|/// Methods for support type inquiry through isa, cast, and dyn_cast:
specifier|static
specifier|inline
name|bool
name|classof
argument_list|(
argument|const SCEVUDivExpr *S
argument_list|)
block|{
return|return
name|true
return|;
block|}
specifier|static
specifier|inline
name|bool
name|classof
argument_list|(
argument|const SCEV *S
argument_list|)
block|{
return|return
name|S
operator|->
name|getSCEVType
argument_list|()
operator|==
name|scUDivExpr
return|;
block|}
expr|}
block|;
comment|//===--------------------------------------------------------------------===//
comment|/// SCEVAddRecExpr - This node represents a polynomial recurrence on the trip
comment|/// count of the specified loop.  This is the primary focus of the
comment|/// ScalarEvolution framework; all the other SCEV subclasses are mostly just
comment|/// supporting infrastructure to allow SCEVAddRecExpr expressions to be
comment|/// created and analyzed.
comment|///
comment|/// All operands of an AddRec are required to be loop invariant.
comment|///
name|class
name|SCEVAddRecExpr
operator|:
name|public
name|SCEVNAryExpr
block|{
name|friend
name|class
name|ScalarEvolution
block|;
specifier|const
name|Loop
operator|*
name|L
block|;
name|SCEVAddRecExpr
argument_list|(
specifier|const
name|std
operator|::
name|vector
operator|<
name|SCEVHandle
operator|>
operator|&
name|ops
argument_list|,
specifier|const
name|Loop
operator|*
name|l
argument_list|)
operator|:
name|SCEVNAryExpr
argument_list|(
name|scAddRecExpr
argument_list|,
name|ops
argument_list|)
block|,
name|L
argument_list|(
argument|l
argument_list|)
block|{
for|for
control|(
name|size_t
name|i
init|=
literal|0
init|,
name|e
init|=
name|Operands
operator|.
name|size
argument_list|()
init|;
name|i
operator|!=
name|e
condition|;
operator|++
name|i
control|)
name|assert
argument_list|(
name|Operands
index|[
name|i
index|]
operator|->
name|isLoopInvariant
argument_list|(
name|l
argument_list|)
operator|&&
literal|"Operands of AddRec must be loop-invariant!"
argument_list|)
expr_stmt|;
block|}
operator|~
name|SCEVAddRecExpr
argument_list|()
block|;
name|public
operator|:
specifier|const
name|SCEVHandle
operator|&
name|getStart
argument_list|()
specifier|const
block|{
return|return
name|Operands
index|[
literal|0
index|]
return|;
block|}
specifier|const
name|Loop
operator|*
name|getLoop
argument_list|()
specifier|const
block|{
return|return
name|L
return|;
block|}
comment|/// getStepRecurrence - This method constructs and returns the recurrence
comment|/// indicating how much this expression steps by.  If this is a polynomial
comment|/// of degree N, it returns a chrec of degree N-1.
name|SCEVHandle
name|getStepRecurrence
argument_list|(
argument|ScalarEvolution&SE
argument_list|)
specifier|const
block|{
if|if
condition|(
name|isAffine
argument_list|()
condition|)
return|return
name|getOperand
argument_list|(
literal|1
argument_list|)
return|;
return|return
name|SE
operator|.
name|getAddRecExpr
argument_list|(
name|std
operator|::
name|vector
operator|<
name|SCEVHandle
operator|>
operator|(
name|op_begin
argument_list|()
operator|+
literal|1
expr|,
name|op_end
argument_list|()
operator|)
argument_list|,
name|getLoop
argument_list|()
argument_list|)
return|;
block|}
name|virtual
name|bool
name|hasComputableLoopEvolution
argument_list|(
argument|const Loop *QL
argument_list|)
specifier|const
block|{
if|if
condition|(
name|L
operator|==
name|QL
condition|)
return|return
name|true
return|;
return|return
name|false
return|;
block|}
name|virtual
name|bool
name|isLoopInvariant
argument_list|(
argument|const Loop *QueryLoop
argument_list|)
specifier|const
block|;
comment|/// isAffine - Return true if this is an affine AddRec (i.e., it represents
comment|/// an expressions A+B*x where A and B are loop invariant values.
name|bool
name|isAffine
argument_list|()
specifier|const
block|{
comment|// We know that the start value is invariant.  This expression is thus
comment|// affine iff the step is also invariant.
return|return
name|getNumOperands
argument_list|()
operator|==
literal|2
return|;
block|}
comment|/// isQuadratic - Return true if this is an quadratic AddRec (i.e., it
comment|/// represents an expressions A+B*x+C*x^2 where A, B and C are loop
comment|/// invariant values.  This corresponds to an addrec of the form {L,+,M,+,N}
name|bool
name|isQuadratic
argument_list|()
specifier|const
block|{
return|return
name|getNumOperands
argument_list|()
operator|==
literal|3
return|;
block|}
comment|/// evaluateAtIteration - Return the value of this chain of recurrences at
comment|/// the specified iteration number.
name|SCEVHandle
name|evaluateAtIteration
argument_list|(
argument|SCEVHandle It
argument_list|,
argument|ScalarEvolution&SE
argument_list|)
specifier|const
block|;
comment|/// getNumIterationsInRange - Return the number of iterations of this loop
comment|/// that produce values in the specified constant range.  Another way of
comment|/// looking at this is that it returns the first iteration number where the
comment|/// value is not in the condition, thus computing the exit count.  If the
comment|/// iteration count can't be computed, an instance of SCEVCouldNotCompute is
comment|/// returned.
name|SCEVHandle
name|getNumIterationsInRange
argument_list|(
argument|ConstantRange Range
argument_list|,
argument|ScalarEvolution&SE
argument_list|)
specifier|const
block|;
name|SCEVHandle
name|replaceSymbolicValuesWithConcrete
argument_list|(
argument|const SCEVHandle&Sym
argument_list|,
argument|const SCEVHandle&Conc
argument_list|,
argument|ScalarEvolution&SE
argument_list|)
specifier|const
block|;
name|virtual
name|void
name|print
argument_list|(
argument|raw_ostream&OS
argument_list|)
specifier|const
block|;
comment|/// Methods for support type inquiry through isa, cast, and dyn_cast:
specifier|static
specifier|inline
name|bool
name|classof
argument_list|(
argument|const SCEVAddRecExpr *S
argument_list|)
block|{
return|return
name|true
return|;
block|}
specifier|static
specifier|inline
name|bool
name|classof
argument_list|(
argument|const SCEV *S
argument_list|)
block|{
return|return
name|S
operator|->
name|getSCEVType
argument_list|()
operator|==
name|scAddRecExpr
return|;
block|}
expr|}
block|;
comment|//===--------------------------------------------------------------------===//
comment|/// SCEVSMaxExpr - This class represents a signed maximum selection.
comment|///
name|class
name|SCEVSMaxExpr
operator|:
name|public
name|SCEVCommutativeExpr
block|{
name|friend
name|class
name|ScalarEvolution
block|;
name|explicit
name|SCEVSMaxExpr
argument_list|(
specifier|const
name|std
operator|::
name|vector
operator|<
name|SCEVHandle
operator|>
operator|&
name|ops
argument_list|)
operator|:
name|SCEVCommutativeExpr
argument_list|(
argument|scSMaxExpr
argument_list|,
argument|ops
argument_list|)
block|{     }
name|public
operator|:
name|virtual
specifier|const
name|char
operator|*
name|getOperationStr
argument_list|()
specifier|const
block|{
return|return
literal|" smax "
return|;
block|}
comment|/// Methods for support type inquiry through isa, cast, and dyn_cast:
specifier|static
specifier|inline
name|bool
name|classof
argument_list|(
argument|const SCEVSMaxExpr *S
argument_list|)
block|{
return|return
name|true
return|;
block|}
specifier|static
specifier|inline
name|bool
name|classof
argument_list|(
argument|const SCEV *S
argument_list|)
block|{
return|return
name|S
operator|->
name|getSCEVType
argument_list|()
operator|==
name|scSMaxExpr
return|;
block|}
expr|}
block|;
comment|//===--------------------------------------------------------------------===//
comment|/// SCEVUMaxExpr - This class represents an unsigned maximum selection.
comment|///
name|class
name|SCEVUMaxExpr
operator|:
name|public
name|SCEVCommutativeExpr
block|{
name|friend
name|class
name|ScalarEvolution
block|;
name|explicit
name|SCEVUMaxExpr
argument_list|(
specifier|const
name|std
operator|::
name|vector
operator|<
name|SCEVHandle
operator|>
operator|&
name|ops
argument_list|)
operator|:
name|SCEVCommutativeExpr
argument_list|(
argument|scUMaxExpr
argument_list|,
argument|ops
argument_list|)
block|{     }
name|public
operator|:
name|virtual
specifier|const
name|char
operator|*
name|getOperationStr
argument_list|()
specifier|const
block|{
return|return
literal|" umax "
return|;
block|}
comment|/// Methods for support type inquiry through isa, cast, and dyn_cast:
specifier|static
specifier|inline
name|bool
name|classof
argument_list|(
argument|const SCEVUMaxExpr *S
argument_list|)
block|{
return|return
name|true
return|;
block|}
specifier|static
specifier|inline
name|bool
name|classof
argument_list|(
argument|const SCEV *S
argument_list|)
block|{
return|return
name|S
operator|->
name|getSCEVType
argument_list|()
operator|==
name|scUMaxExpr
return|;
block|}
expr|}
block|;
comment|//===--------------------------------------------------------------------===//
comment|/// SCEVUnknown - This means that we are dealing with an entirely unknown SCEV
comment|/// value, and only represent it as it's LLVM Value.  This is the "bottom"
comment|/// value for the analysis.
comment|///
name|class
name|SCEVUnknown
operator|:
name|public
name|SCEV
block|{
name|friend
name|class
name|ScalarEvolution
block|;
name|Value
operator|*
name|V
block|;
name|explicit
name|SCEVUnknown
argument_list|(
name|Value
operator|*
name|v
argument_list|)
operator|:
name|SCEV
argument_list|(
name|scUnknown
argument_list|)
block|,
name|V
argument_list|(
argument|v
argument_list|)
block|{}
name|protected
operator|:
operator|~
name|SCEVUnknown
argument_list|()
block|;
name|public
operator|:
name|Value
operator|*
name|getValue
argument_list|()
specifier|const
block|{
return|return
name|V
return|;
block|}
name|virtual
name|bool
name|isLoopInvariant
argument_list|(
argument|const Loop *L
argument_list|)
specifier|const
block|;
name|virtual
name|bool
name|hasComputableLoopEvolution
argument_list|(
argument|const Loop *QL
argument_list|)
specifier|const
block|{
return|return
name|false
return|;
comment|// not computable
block|}
name|SCEVHandle
name|replaceSymbolicValuesWithConcrete
argument_list|(
argument|const SCEVHandle&Sym
argument_list|,
argument|const SCEVHandle&Conc
argument_list|,
argument|ScalarEvolution&SE
argument_list|)
specifier|const
block|{
if|if
condition|(
operator|&
operator|*
name|Sym
operator|==
name|this
condition|)
return|return
name|Conc
return|;
return|return
name|this
return|;
block|}
name|bool
name|dominates
argument_list|(
argument|BasicBlock *BB
argument_list|,
argument|DominatorTree *DT
argument_list|)
specifier|const
block|;
name|virtual
specifier|const
name|Type
operator|*
name|getType
argument_list|()
specifier|const
block|;
name|virtual
name|void
name|print
argument_list|(
argument|raw_ostream&OS
argument_list|)
specifier|const
block|;
comment|/// Methods for support type inquiry through isa, cast, and dyn_cast:
specifier|static
specifier|inline
name|bool
name|classof
argument_list|(
argument|const SCEVUnknown *S
argument_list|)
block|{
return|return
name|true
return|;
block|}
specifier|static
specifier|inline
name|bool
name|classof
argument_list|(
argument|const SCEV *S
argument_list|)
block|{
return|return
name|S
operator|->
name|getSCEVType
argument_list|()
operator|==
name|scUnknown
return|;
block|}
expr|}
block|;
comment|/// SCEVVisitor - This class defines a simple visitor class that may be used
comment|/// for various SCEV analysis purposes.
name|template
operator|<
name|typename
name|SC
block|,
name|typename
name|RetVal
operator|=
name|void
operator|>
expr|struct
name|SCEVVisitor
block|{
name|RetVal
name|visit
argument_list|(
argument|const SCEV *S
argument_list|)
block|{
switch|switch
condition|(
name|S
operator|->
name|getSCEVType
argument_list|()
condition|)
block|{
case|case
name|scConstant
case|:
return|return
operator|(
operator|(
name|SC
operator|*
operator|)
name|this
operator|)
operator|->
name|visitConstant
argument_list|(
operator|(
specifier|const
name|SCEVConstant
operator|*
operator|)
name|S
argument_list|)
return|;
case|case
name|scTruncate
case|:
return|return
operator|(
operator|(
name|SC
operator|*
operator|)
name|this
operator|)
operator|->
name|visitTruncateExpr
argument_list|(
operator|(
specifier|const
name|SCEVTruncateExpr
operator|*
operator|)
name|S
argument_list|)
return|;
case|case
name|scZeroExtend
case|:
return|return
operator|(
operator|(
name|SC
operator|*
operator|)
name|this
operator|)
operator|->
name|visitZeroExtendExpr
argument_list|(
operator|(
specifier|const
name|SCEVZeroExtendExpr
operator|*
operator|)
name|S
argument_list|)
return|;
case|case
name|scSignExtend
case|:
return|return
operator|(
operator|(
name|SC
operator|*
operator|)
name|this
operator|)
operator|->
name|visitSignExtendExpr
argument_list|(
operator|(
specifier|const
name|SCEVSignExtendExpr
operator|*
operator|)
name|S
argument_list|)
return|;
case|case
name|scAddExpr
case|:
return|return
operator|(
operator|(
name|SC
operator|*
operator|)
name|this
operator|)
operator|->
name|visitAddExpr
argument_list|(
operator|(
specifier|const
name|SCEVAddExpr
operator|*
operator|)
name|S
argument_list|)
return|;
case|case
name|scMulExpr
case|:
return|return
operator|(
operator|(
name|SC
operator|*
operator|)
name|this
operator|)
operator|->
name|visitMulExpr
argument_list|(
operator|(
specifier|const
name|SCEVMulExpr
operator|*
operator|)
name|S
argument_list|)
return|;
case|case
name|scUDivExpr
case|:
return|return
operator|(
operator|(
name|SC
operator|*
operator|)
name|this
operator|)
operator|->
name|visitUDivExpr
argument_list|(
operator|(
specifier|const
name|SCEVUDivExpr
operator|*
operator|)
name|S
argument_list|)
return|;
case|case
name|scAddRecExpr
case|:
return|return
operator|(
operator|(
name|SC
operator|*
operator|)
name|this
operator|)
operator|->
name|visitAddRecExpr
argument_list|(
operator|(
specifier|const
name|SCEVAddRecExpr
operator|*
operator|)
name|S
argument_list|)
return|;
case|case
name|scSMaxExpr
case|:
return|return
operator|(
operator|(
name|SC
operator|*
operator|)
name|this
operator|)
operator|->
name|visitSMaxExpr
argument_list|(
operator|(
specifier|const
name|SCEVSMaxExpr
operator|*
operator|)
name|S
argument_list|)
return|;
case|case
name|scUMaxExpr
case|:
return|return
operator|(
operator|(
name|SC
operator|*
operator|)
name|this
operator|)
operator|->
name|visitUMaxExpr
argument_list|(
operator|(
specifier|const
name|SCEVUMaxExpr
operator|*
operator|)
name|S
argument_list|)
return|;
case|case
name|scUnknown
case|:
return|return
operator|(
operator|(
name|SC
operator|*
operator|)
name|this
operator|)
operator|->
name|visitUnknown
argument_list|(
operator|(
specifier|const
name|SCEVUnknown
operator|*
operator|)
name|S
argument_list|)
return|;
case|case
name|scCouldNotCompute
case|:
return|return
operator|(
operator|(
name|SC
operator|*
operator|)
name|this
operator|)
operator|->
name|visitCouldNotCompute
argument_list|(
operator|(
specifier|const
name|SCEVCouldNotCompute
operator|*
operator|)
name|S
argument_list|)
return|;
default|default:
name|assert
argument_list|(
literal|0
operator|&&
literal|"Unknown SCEV type!"
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
name|RetVal
name|visitCouldNotCompute
argument_list|(
argument|const SCEVCouldNotCompute *S
argument_list|)
block|{
name|assert
argument_list|(
literal|0
operator|&&
literal|"Invalid use of SCEVCouldNotCompute!"
argument_list|)
block|;
name|abort
argument_list|()
block|;
return|return
name|RetVal
argument_list|()
return|;
block|}
expr|}
block|; }
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

end_unit

