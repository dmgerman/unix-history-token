begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===- RegionInfoImpl.h - SESE region detection analysis --------*- C++ -*-===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|// Detects single entry single exit regions in the control flow graph.
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LLVM_ANALYSIS_REGIONINFOIMPL_H
end_ifndef

begin_define
define|#
directive|define
name|LLVM_ANALYSIS_REGIONINFOIMPL_H
end_define

begin_include
include|#
directive|include
file|"llvm/ADT/PostOrderIterator.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Analysis/DominanceFrontier.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Analysis/LoopInfo.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Analysis/PostDominators.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Analysis/RegionInfo.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Analysis/RegionIterator.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/CommandLine.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/Debug.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/ErrorHandling.h"
end_include

begin_include
include|#
directive|include
file|<algorithm>
end_include

begin_include
include|#
directive|include
file|<iterator>
end_include

begin_include
include|#
directive|include
file|<set>
end_include

begin_decl_stmt
name|namespace
name|llvm
block|{
define|#
directive|define
name|DEBUG_TYPE
value|"region"
comment|//===----------------------------------------------------------------------===//
comment|/// RegionBase Implementation
name|template
operator|<
name|class
name|Tr
operator|>
name|RegionBase
operator|<
name|Tr
operator|>
operator|::
name|RegionBase
argument_list|(
argument|BlockT *Entry
argument_list|,
argument|BlockT *Exit
argument_list|,
argument|typename Tr::RegionInfoT *RInfo
argument_list|,
argument|DomTreeT *dt
argument_list|,
argument|RegionT *Parent
argument_list|)
operator|:
name|RegionNodeBase
operator|<
name|Tr
operator|>
operator|(
name|Parent
operator|,
name|Entry
operator|,
literal|1
operator|)
operator|,
name|RI
argument_list|(
name|RInfo
argument_list|)
operator|,
name|DT
argument_list|(
name|dt
argument_list|)
operator|,
name|exit
argument_list|(
argument|Exit
argument_list|)
block|{}
name|template
operator|<
name|class
name|Tr
operator|>
name|RegionBase
operator|<
name|Tr
operator|>
operator|::
operator|~
name|RegionBase
argument_list|()
block|{
comment|// Free the cached nodes.
for|for
control|(
name|typename
name|BBNodeMapT
operator|::
name|iterator
name|it
operator|=
name|BBNodeMap
operator|.
name|begin
argument_list|()
operator|,
name|ie
operator|=
name|BBNodeMap
operator|.
name|end
argument_list|()
init|;
name|it
operator|!=
name|ie
condition|;
operator|++
name|it
control|)
name|delete
name|it
operator|->
name|second
decl_stmt|;
comment|// Only clean the cache for this Region. Caches of child Regions will be
comment|// cleaned when the child Regions are deleted.
name|BBNodeMap
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
end_decl_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|Tr
operator|>
name|void
name|RegionBase
operator|<
name|Tr
operator|>
operator|::
name|replaceEntry
argument_list|(
argument|BlockT *BB
argument_list|)
block|{
name|this
operator|->
name|entry
operator|.
name|setPointer
argument_list|(
name|BB
argument_list|)
block|; }
name|template
operator|<
name|class
name|Tr
operator|>
name|void
name|RegionBase
operator|<
name|Tr
operator|>
operator|::
name|replaceExit
argument_list|(
argument|BlockT *BB
argument_list|)
block|{
name|assert
argument_list|(
name|exit
operator|&&
literal|"No exit to replace!"
argument_list|)
block|;
name|exit
operator|=
name|BB
block|; }
name|template
operator|<
name|class
name|Tr
operator|>
name|void
name|RegionBase
operator|<
name|Tr
operator|>
operator|::
name|replaceEntryRecursive
argument_list|(
argument|BlockT *NewEntry
argument_list|)
block|{
name|std
operator|::
name|vector
operator|<
name|RegionT
operator|*
operator|>
name|RegionQueue
block|;
name|BlockT
operator|*
name|OldEntry
operator|=
name|getEntry
argument_list|()
block|;
name|RegionQueue
operator|.
name|push_back
argument_list|(
name|static_cast
operator|<
name|RegionT
operator|*
operator|>
operator|(
name|this
operator|)
argument_list|)
block|;
while|while
condition|(
operator|!
name|RegionQueue
operator|.
name|empty
argument_list|()
condition|)
block|{
name|RegionT
modifier|*
name|R
init|=
name|RegionQueue
operator|.
name|back
argument_list|()
decl_stmt|;
name|RegionQueue
operator|.
name|pop_back
argument_list|()
expr_stmt|;
name|R
operator|->
name|replaceEntry
argument_list|(
name|NewEntry
argument_list|)
expr_stmt|;
for|for
control|(
name|typename
name|RegionT
operator|::
name|const_iterator
name|RI
operator|=
name|R
operator|->
name|begin
argument_list|()
operator|,
name|RE
operator|=
name|R
operator|->
name|end
argument_list|()
init|;
name|RI
operator|!=
name|RE
condition|;
operator|++
name|RI
control|)
block|{
if|if
condition|(
operator|(
operator|*
name|RI
operator|)
operator|->
name|getEntry
argument_list|()
operator|==
name|OldEntry
condition|)
name|RegionQueue
operator|.
name|push_back
argument_list|(
name|RI
operator|->
name|get
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_expr_stmt

begin_expr_stmt
unit|} }
name|template
operator|<
name|class
name|Tr
operator|>
name|void
name|RegionBase
operator|<
name|Tr
operator|>
operator|::
name|replaceExitRecursive
argument_list|(
argument|BlockT *NewExit
argument_list|)
block|{
name|std
operator|::
name|vector
operator|<
name|RegionT
operator|*
operator|>
name|RegionQueue
block|;
name|BlockT
operator|*
name|OldExit
operator|=
name|getExit
argument_list|()
block|;
name|RegionQueue
operator|.
name|push_back
argument_list|(
name|static_cast
operator|<
name|RegionT
operator|*
operator|>
operator|(
name|this
operator|)
argument_list|)
block|;
while|while
condition|(
operator|!
name|RegionQueue
operator|.
name|empty
argument_list|()
condition|)
block|{
name|RegionT
modifier|*
name|R
init|=
name|RegionQueue
operator|.
name|back
argument_list|()
decl_stmt|;
name|RegionQueue
operator|.
name|pop_back
argument_list|()
expr_stmt|;
name|R
operator|->
name|replaceExit
argument_list|(
name|NewExit
argument_list|)
expr_stmt|;
for|for
control|(
name|typename
name|RegionT
operator|::
name|const_iterator
name|RI
operator|=
name|R
operator|->
name|begin
argument_list|()
operator|,
name|RE
operator|=
name|R
operator|->
name|end
argument_list|()
init|;
name|RI
operator|!=
name|RE
condition|;
operator|++
name|RI
control|)
block|{
if|if
condition|(
operator|(
operator|*
name|RI
operator|)
operator|->
name|getExit
argument_list|()
operator|==
name|OldExit
condition|)
name|RegionQueue
operator|.
name|push_back
argument_list|(
name|RI
operator|->
name|get
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_expr_stmt

begin_expr_stmt
unit|} }
name|template
operator|<
name|class
name|Tr
operator|>
name|bool
name|RegionBase
operator|<
name|Tr
operator|>
operator|::
name|contains
argument_list|(
argument|const BlockT *B
argument_list|)
specifier|const
block|{
name|BlockT
operator|*
name|BB
operator|=
name|const_cast
operator|<
name|BlockT
operator|*
operator|>
operator|(
name|B
operator|)
block|;
if|if
condition|(
operator|!
name|DT
operator|->
name|getNode
argument_list|(
name|BB
argument_list|)
condition|)
return|return
name|false
return|;
name|BlockT
operator|*
name|entry
operator|=
name|getEntry
argument_list|()
operator|,
operator|*
name|exit
operator|=
name|getExit
argument_list|()
expr_stmt|;
end_expr_stmt

begin_comment
comment|// Toplevel region.
end_comment

begin_if
if|if
condition|(
operator|!
name|exit
condition|)
return|return
name|true
return|;
end_if

begin_return
return|return
operator|(
name|DT
operator|->
name|dominates
argument_list|(
name|entry
argument_list|,
name|BB
argument_list|)
operator|&&
operator|!
operator|(
name|DT
operator|->
name|dominates
argument_list|(
name|exit
argument_list|,
name|BB
argument_list|)
operator|&&
name|DT
operator|->
name|dominates
argument_list|(
name|entry
argument_list|,
name|exit
argument_list|)
operator|)
operator|)
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|class
name|Tr
operator|>
name|bool
name|RegionBase
operator|<
name|Tr
operator|>
operator|::
name|contains
argument_list|(
argument|const LoopT *L
argument_list|)
specifier|const
block|{
comment|// BBs that are not part of any loop are element of the Loop
comment|// described by the NULL pointer. This loop is not part of any region,
comment|// except if the region describes the whole function.
if|if
condition|(
operator|!
name|L
condition|)
return|return
name|getExit
argument_list|()
operator|==
name|nullptr
return|;
end_expr_stmt

begin_if
if|if
condition|(
operator|!
name|contains
argument_list|(
name|L
operator|->
name|getHeader
argument_list|()
argument_list|)
condition|)
return|return
name|false
return|;
end_if

begin_expr_stmt
name|SmallVector
operator|<
name|BlockT
operator|*
operator|,
literal|8
operator|>
name|ExitingBlocks
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|L
operator|->
name|getExitingBlocks
argument_list|(
name|ExitingBlocks
argument_list|)
expr_stmt|;
end_expr_stmt

begin_for
for|for
control|(
name|BlockT
modifier|*
name|BB
range|:
name|ExitingBlocks
control|)
block|{
if|if
condition|(
operator|!
name|contains
argument_list|(
name|BB
argument_list|)
condition|)
return|return
name|false
return|;
block|}
end_for

begin_return
return|return
name|true
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|class
name|Tr
operator|>
name|typename
name|Tr
operator|::
name|LoopT
operator|*
name|RegionBase
operator|<
name|Tr
operator|>
operator|::
name|outermostLoopInRegion
argument_list|(
argument|LoopT *L
argument_list|)
specifier|const
block|{
if|if
condition|(
operator|!
name|contains
argument_list|(
name|L
argument_list|)
condition|)
return|return
name|nullptr
return|;
end_expr_stmt

begin_while
while|while
condition|(
name|L
operator|&&
name|contains
argument_list|(
name|L
operator|->
name|getParentLoop
argument_list|()
argument_list|)
condition|)
block|{
name|L
operator|=
name|L
operator|->
name|getParentLoop
argument_list|()
expr_stmt|;
block|}
end_while

begin_return
return|return
name|L
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|class
name|Tr
operator|>
name|typename
name|Tr
operator|::
name|LoopT
operator|*
name|RegionBase
operator|<
name|Tr
operator|>
operator|::
name|outermostLoopInRegion
argument_list|(
argument|LoopInfoT *LI
argument_list|,
argument|BlockT *BB
argument_list|)
specifier|const
block|{
name|assert
argument_list|(
name|LI
operator|&&
name|BB
operator|&&
literal|"LI and BB cannot be null!"
argument_list|)
block|;
name|LoopT
operator|*
name|L
operator|=
name|LI
operator|->
name|getLoopFor
argument_list|(
name|BB
argument_list|)
block|;
return|return
name|outermostLoopInRegion
argument_list|(
name|L
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|Tr
operator|>
name|typename
name|RegionBase
operator|<
name|Tr
operator|>
operator|::
name|BlockT
operator|*
name|RegionBase
operator|<
name|Tr
operator|>
operator|::
name|getEnteringBlock
argument_list|()
specifier|const
block|{
name|BlockT
operator|*
name|entry
operator|=
name|getEntry
argument_list|()
block|;
name|BlockT
operator|*
name|Pred
block|;
name|BlockT
operator|*
name|enteringBlock
operator|=
name|nullptr
block|;
for|for
control|(
name|PredIterTy
name|PI
init|=
name|InvBlockTraits
operator|::
name|child_begin
argument_list|(
name|entry
argument_list|)
init|,
name|PE
init|=
name|InvBlockTraits
operator|::
name|child_end
argument_list|(
name|entry
argument_list|)
init|;
name|PI
operator|!=
name|PE
condition|;
operator|++
name|PI
control|)
block|{
name|Pred
operator|=
operator|*
name|PI
expr_stmt|;
if|if
condition|(
name|DT
operator|->
name|getNode
argument_list|(
name|Pred
argument_list|)
operator|&&
operator|!
name|contains
argument_list|(
name|Pred
argument_list|)
condition|)
block|{
if|if
condition|(
name|enteringBlock
condition|)
return|return
name|nullptr
return|;
name|enteringBlock
operator|=
name|Pred
expr_stmt|;
block|}
end_expr_stmt

begin_expr_stmt
unit|}    return
name|enteringBlock
expr_stmt|;
end_expr_stmt

begin_expr_stmt
unit|}  template
operator|<
name|class
name|Tr
operator|>
name|typename
name|RegionBase
operator|<
name|Tr
operator|>
operator|::
name|BlockT
operator|*
name|RegionBase
operator|<
name|Tr
operator|>
operator|::
name|getExitingBlock
argument_list|()
specifier|const
block|{
name|BlockT
operator|*
name|exit
operator|=
name|getExit
argument_list|()
block|;
name|BlockT
operator|*
name|Pred
block|;
name|BlockT
operator|*
name|exitingBlock
operator|=
name|nullptr
block|;
if|if
condition|(
operator|!
name|exit
condition|)
return|return
name|nullptr
return|;
end_expr_stmt

begin_for
for|for
control|(
name|PredIterTy
name|PI
init|=
name|InvBlockTraits
operator|::
name|child_begin
argument_list|(
name|exit
argument_list|)
init|,
name|PE
init|=
name|InvBlockTraits
operator|::
name|child_end
argument_list|(
name|exit
argument_list|)
init|;
name|PI
operator|!=
name|PE
condition|;
operator|++
name|PI
control|)
block|{
name|Pred
operator|=
operator|*
name|PI
expr_stmt|;
if|if
condition|(
name|contains
argument_list|(
name|Pred
argument_list|)
condition|)
block|{
if|if
condition|(
name|exitingBlock
condition|)
return|return
name|nullptr
return|;
name|exitingBlock
operator|=
name|Pred
expr_stmt|;
block|}
block|}
end_for

begin_return
return|return
name|exitingBlock
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|class
name|Tr
operator|>
name|bool
name|RegionBase
operator|<
name|Tr
operator|>
operator|::
name|isSimple
argument_list|()
specifier|const
block|{
return|return
operator|!
name|isTopLevelRegion
argument_list|()
operator|&&
name|getEnteringBlock
argument_list|()
operator|&&
name|getExitingBlock
argument_list|()
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|Tr
operator|>
name|std
operator|::
name|string
name|RegionBase
operator|<
name|Tr
operator|>
operator|::
name|getNameStr
argument_list|()
specifier|const
block|{
name|std
operator|::
name|string
name|exitName
block|;
name|std
operator|::
name|string
name|entryName
block|;
if|if
condition|(
name|getEntry
argument_list|()
operator|->
name|getName
argument_list|()
operator|.
name|empty
argument_list|()
condition|)
block|{
name|raw_string_ostream
name|OS
parameter_list|(
name|entryName
parameter_list|)
function_decl|;
name|getEntry
argument_list|()
operator|->
name|printAsOperand
argument_list|(
name|OS
argument_list|,
name|false
argument_list|)
expr_stmt|;
block|}
end_expr_stmt

begin_else
else|else
name|entryName
operator|=
name|getEntry
argument_list|()
operator|->
name|getName
argument_list|()
expr_stmt|;
end_else

begin_if
if|if
condition|(
name|getExit
argument_list|()
condition|)
block|{
if|if
condition|(
name|getExit
argument_list|()
operator|->
name|getName
argument_list|()
operator|.
name|empty
argument_list|()
condition|)
block|{
name|raw_string_ostream
name|OS
parameter_list|(
name|exitName
parameter_list|)
function_decl|;
name|getExit
argument_list|()
operator|->
name|printAsOperand
argument_list|(
name|OS
argument_list|,
name|false
argument_list|)
expr_stmt|;
block|}
else|else
name|exitName
operator|=
name|getExit
argument_list|()
operator|->
name|getName
argument_list|()
expr_stmt|;
block|}
else|else
name|exitName
operator|=
literal|"<Function Return>"
expr_stmt|;
end_if

begin_return
return|return
name|entryName
operator|+
literal|" => "
operator|+
name|exitName
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|class
name|Tr
operator|>
name|void
name|RegionBase
operator|<
name|Tr
operator|>
operator|::
name|verifyBBInRegion
argument_list|(
argument|BlockT *BB
argument_list|)
specifier|const
block|{
if|if
condition|(
operator|!
name|contains
argument_list|(
name|BB
argument_list|)
condition|)
name|llvm_unreachable
argument_list|(
literal|"Broken region found: enumerated BB not in region!"
argument_list|)
expr_stmt|;
name|BlockT
operator|*
name|entry
operator|=
name|getEntry
argument_list|()
operator|,
operator|*
name|exit
operator|=
name|getExit
argument_list|()
expr_stmt|;
end_expr_stmt

begin_for
for|for
control|(
name|SuccIterTy
name|SI
init|=
name|BlockTraits
operator|::
name|child_begin
argument_list|(
name|BB
argument_list|)
init|,
name|SE
init|=
name|BlockTraits
operator|::
name|child_end
argument_list|(
name|BB
argument_list|)
init|;
name|SI
operator|!=
name|SE
condition|;
operator|++
name|SI
control|)
block|{
if|if
condition|(
operator|!
name|contains
argument_list|(
operator|*
name|SI
argument_list|)
operator|&&
name|exit
operator|!=
operator|*
name|SI
condition|)
name|llvm_unreachable
argument_list|(
literal|"Broken region found: edges leaving the region must go "
literal|"to the exit node!"
argument_list|)
expr_stmt|;
block|}
end_for

begin_if
if|if
condition|(
name|entry
operator|!=
name|BB
condition|)
block|{
for|for
control|(
name|PredIterTy
name|SI
init|=
name|InvBlockTraits
operator|::
name|child_begin
argument_list|(
name|BB
argument_list|)
init|,
name|SE
init|=
name|InvBlockTraits
operator|::
name|child_end
argument_list|(
name|BB
argument_list|)
init|;
name|SI
operator|!=
name|SE
condition|;
operator|++
name|SI
control|)
block|{
if|if
condition|(
operator|!
name|contains
argument_list|(
operator|*
name|SI
argument_list|)
condition|)
name|llvm_unreachable
argument_list|(
literal|"Broken region found: edges entering the region must "
literal|"go to the entry node!"
argument_list|)
expr_stmt|;
block|}
block|}
end_if

begin_expr_stmt
unit|}  template
operator|<
name|class
name|Tr
operator|>
name|void
name|RegionBase
operator|<
name|Tr
operator|>
operator|::
name|verifyWalk
argument_list|(
argument|BlockT *BB
argument_list|,
argument|std::set<BlockT *> *visited
argument_list|)
specifier|const
block|{
name|BlockT
operator|*
name|exit
operator|=
name|getExit
argument_list|()
block|;
name|visited
operator|->
name|insert
argument_list|(
name|BB
argument_list|)
block|;
name|verifyBBInRegion
argument_list|(
name|BB
argument_list|)
block|;
for|for
control|(
name|SuccIterTy
name|SI
init|=
name|BlockTraits
operator|::
name|child_begin
argument_list|(
name|BB
argument_list|)
init|,
name|SE
init|=
name|BlockTraits
operator|::
name|child_end
argument_list|(
name|BB
argument_list|)
init|;
name|SI
operator|!=
name|SE
condition|;
operator|++
name|SI
control|)
block|{
if|if
condition|(
operator|*
name|SI
operator|!=
name|exit
operator|&&
name|visited
operator|->
name|find
argument_list|(
operator|*
name|SI
argument_list|)
operator|==
name|visited
operator|->
name|end
argument_list|()
condition|)
name|verifyWalk
argument_list|(
operator|*
name|SI
argument_list|,
name|visited
argument_list|)
expr_stmt|;
block|}
end_expr_stmt

begin_expr_stmt
unit|}  template
operator|<
name|class
name|Tr
operator|>
name|void
name|RegionBase
operator|<
name|Tr
operator|>
operator|::
name|verifyRegion
argument_list|()
specifier|const
block|{
comment|// Only do verification when user wants to, otherwise this expensive check
comment|// will be invoked by PMDataManager::verifyPreservedAnalysis when
comment|// a regionpass (marked PreservedAll) finish.
if|if
condition|(
operator|!
name|RegionInfoBase
operator|<
name|Tr
operator|>
operator|::
name|VerifyRegionInfo
condition|)
return|return;
name|std
operator|::
name|set
operator|<
name|BlockT
operator|*
operator|>
name|visited
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|verifyWalk
argument_list|(
name|getEntry
argument_list|()
argument_list|,
operator|&
name|visited
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
unit|}  template
operator|<
name|class
name|Tr
operator|>
name|void
name|RegionBase
operator|<
name|Tr
operator|>
operator|::
name|verifyRegionNest
argument_list|()
specifier|const
block|{
for|for
control|(
name|typename
name|RegionT
operator|::
name|const_iterator
name|RI
operator|=
name|begin
argument_list|()
operator|,
name|RE
operator|=
name|end
argument_list|()
init|;
name|RI
operator|!=
name|RE
condition|;
operator|++
name|RI
control|)
operator|(
operator|*
name|RI
operator|)
operator|->
name|verifyRegionNest
argument_list|()
expr_stmt|;
name|verifyRegion
argument_list|()
expr_stmt|;
end_expr_stmt

begin_expr_stmt
unit|}  template
operator|<
name|class
name|Tr
operator|>
name|typename
name|RegionBase
operator|<
name|Tr
operator|>
operator|::
name|element_iterator
name|RegionBase
operator|<
name|Tr
operator|>
operator|::
name|element_begin
argument_list|()
block|{
return|return
name|GraphTraits
operator|<
name|RegionT
operator|*
operator|>
operator|::
name|nodes_begin
argument_list|(
name|static_cast
operator|<
name|RegionT
operator|*
operator|>
operator|(
name|this
operator|)
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|Tr
operator|>
name|typename
name|RegionBase
operator|<
name|Tr
operator|>
operator|::
name|element_iterator
name|RegionBase
operator|<
name|Tr
operator|>
operator|::
name|element_end
argument_list|()
block|{
return|return
name|GraphTraits
operator|<
name|RegionT
operator|*
operator|>
operator|::
name|nodes_end
argument_list|(
name|static_cast
operator|<
name|RegionT
operator|*
operator|>
operator|(
name|this
operator|)
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|Tr
operator|>
name|typename
name|RegionBase
operator|<
name|Tr
operator|>
operator|::
name|const_element_iterator
name|RegionBase
operator|<
name|Tr
operator|>
operator|::
name|element_begin
argument_list|()
specifier|const
block|{
return|return
name|GraphTraits
operator|<
specifier|const
name|RegionT
operator|*
operator|>
operator|::
name|nodes_begin
argument_list|(
name|static_cast
operator|<
specifier|const
name|RegionT
operator|*
operator|>
operator|(
name|this
operator|)
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|Tr
operator|>
name|typename
name|RegionBase
operator|<
name|Tr
operator|>
operator|::
name|const_element_iterator
name|RegionBase
operator|<
name|Tr
operator|>
operator|::
name|element_end
argument_list|()
specifier|const
block|{
return|return
name|GraphTraits
operator|<
specifier|const
name|RegionT
operator|*
operator|>
operator|::
name|nodes_end
argument_list|(
name|static_cast
operator|<
specifier|const
name|RegionT
operator|*
operator|>
operator|(
name|this
operator|)
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|Tr
operator|>
name|typename
name|Tr
operator|::
name|RegionT
operator|*
name|RegionBase
operator|<
name|Tr
operator|>
operator|::
name|getSubRegionNode
argument_list|(
argument|BlockT *BB
argument_list|)
specifier|const
block|{
typedef|typedef
name|typename
name|Tr
operator|::
name|RegionT
name|RegionT
expr_stmt|;
name|RegionT
operator|*
name|R
operator|=
name|RI
operator|->
name|getRegionFor
argument_list|(
name|BB
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
operator|!
name|R
operator|||
name|R
operator|==
name|this
condition|)
return|return
name|nullptr
return|;
end_if

begin_comment
comment|// If we pass the BB out of this region, that means our code is broken.
end_comment

begin_expr_stmt
name|assert
argument_list|(
name|contains
argument_list|(
name|R
argument_list|)
operator|&&
literal|"BB not in current region!"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_while
while|while
condition|(
name|contains
argument_list|(
name|R
operator|->
name|getParent
argument_list|()
argument_list|)
operator|&&
name|R
operator|->
name|getParent
argument_list|()
operator|!=
name|this
condition|)
name|R
operator|=
name|R
operator|->
name|getParent
argument_list|()
expr_stmt|;
end_while

begin_if
if|if
condition|(
name|R
operator|->
name|getEntry
argument_list|()
operator|!=
name|BB
condition|)
return|return
name|nullptr
return|;
end_if

begin_return
return|return
name|R
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|class
name|Tr
operator|>
name|typename
name|Tr
operator|::
name|RegionNodeT
operator|*
name|RegionBase
operator|<
name|Tr
operator|>
operator|::
name|getBBNode
argument_list|(
argument|BlockT *BB
argument_list|)
specifier|const
block|{
name|assert
argument_list|(
name|contains
argument_list|(
name|BB
argument_list|)
operator|&&
literal|"Can get BB node out of this region!"
argument_list|)
block|;
name|typename
name|BBNodeMapT
operator|::
name|const_iterator
name|at
operator|=
name|BBNodeMap
operator|.
name|find
argument_list|(
name|BB
argument_list|)
block|;
if|if
condition|(
name|at
operator|!=
name|BBNodeMap
operator|.
name|end
argument_list|()
condition|)
return|return
name|at
operator|->
name|second
return|;
name|auto
name|Deconst
operator|=
name|const_cast
operator|<
name|RegionBase
operator|<
name|Tr
operator|>
operator|*
operator|>
operator|(
name|this
operator|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|RegionNodeT
modifier|*
name|NewNode
init|=
name|new
name|RegionNodeT
argument_list|(
name|static_cast
operator|<
name|RegionT
operator|*
operator|>
operator|(
name|Deconst
operator|)
argument_list|,
name|BB
argument_list|)
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|BBNodeMap
operator|.
name|insert
argument_list|(
name|std
operator|::
name|make_pair
argument_list|(
name|BB
argument_list|,
name|NewNode
argument_list|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|NewNode
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|class
name|Tr
operator|>
name|typename
name|Tr
operator|::
name|RegionNodeT
operator|*
name|RegionBase
operator|<
name|Tr
operator|>
operator|::
name|getNode
argument_list|(
argument|BlockT *BB
argument_list|)
specifier|const
block|{
name|assert
argument_list|(
name|contains
argument_list|(
name|BB
argument_list|)
operator|&&
literal|"Can get BB node out of this region!"
argument_list|)
block|;
if|if
condition|(
name|RegionT
modifier|*
name|Child
init|=
name|getSubRegionNode
argument_list|(
name|BB
argument_list|)
condition|)
return|return
name|Child
operator|->
name|getNode
argument_list|()
return|;
end_expr_stmt

begin_return
return|return
name|getBBNode
argument_list|(
name|BB
argument_list|)
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|class
name|Tr
operator|>
name|void
name|RegionBase
operator|<
name|Tr
operator|>
operator|::
name|transferChildrenTo
argument_list|(
argument|RegionT *To
argument_list|)
block|{
for|for
control|(
name|iterator
name|I
init|=
name|begin
argument_list|()
init|,
name|E
init|=
name|end
argument_list|()
init|;
name|I
operator|!=
name|E
condition|;
operator|++
name|I
control|)
block|{
operator|(
operator|*
name|I
operator|)
operator|->
name|parent
operator|=
name|To
expr_stmt|;
name|To
operator|->
name|children
operator|.
name|push_back
argument_list|(
name|std
operator|::
name|move
argument_list|(
operator|*
name|I
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|children
operator|.
name|clear
argument_list|()
expr_stmt|;
end_expr_stmt

begin_expr_stmt
unit|}  template
operator|<
name|class
name|Tr
operator|>
name|void
name|RegionBase
operator|<
name|Tr
operator|>
operator|::
name|addSubRegion
argument_list|(
argument|RegionT *SubRegion
argument_list|,
argument|bool moveChildren
argument_list|)
block|{
name|assert
argument_list|(
operator|!
name|SubRegion
operator|->
name|parent
operator|&&
literal|"SubRegion already has a parent!"
argument_list|)
block|;
name|assert
argument_list|(
name|std
operator|::
name|find_if
argument_list|(
name|begin
argument_list|()
argument_list|,
name|end
argument_list|()
argument_list|,
index|[
operator|&
index|]
operator|(
specifier|const
name|std
operator|::
name|unique_ptr
operator|<
name|RegionT
operator|>
operator|&
name|R
operator|)
block|{
return|return
name|R
operator|.
name|get
argument_list|()
operator|==
name|SubRegion
return|;
block|}
end_expr_stmt

begin_expr_stmt
unit|)
operator|==
name|children
operator|.
name|end
argument_list|()
operator|&&
literal|"Subregion already exists!"
end_expr_stmt

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_expr_stmt
name|SubRegion
operator|->
name|parent
operator|=
name|static_cast
operator|<
name|RegionT
operator|*
operator|>
operator|(
name|this
operator|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|children
operator|.
name|push_back
argument_list|(
name|std
operator|::
name|unique_ptr
operator|<
name|RegionT
operator|>
operator|(
name|SubRegion
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
operator|!
name|moveChildren
condition|)
return|return;
end_if

begin_expr_stmt
name|assert
argument_list|(
name|SubRegion
operator|->
name|children
operator|.
name|empty
argument_list|()
operator|&&
literal|"SubRegions that contain children are not supported"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_for
for|for
control|(
name|element_iterator
name|I
init|=
name|element_begin
argument_list|()
init|,
name|E
init|=
name|element_end
argument_list|()
init|;
name|I
operator|!=
name|E
condition|;
operator|++
name|I
control|)
block|{
if|if
condition|(
operator|!
operator|(
operator|*
name|I
operator|)
operator|->
name|isSubRegion
argument_list|()
condition|)
block|{
name|BlockT
modifier|*
name|BB
init|=
operator|(
operator|*
name|I
operator|)
operator|->
name|template
name|getNodeAs
operator|<
name|BlockT
operator|>
operator|(
operator|)
decl_stmt|;
if|if
condition|(
name|SubRegion
operator|->
name|contains
argument_list|(
name|BB
argument_list|)
condition|)
name|RI
operator|->
name|setRegionFor
argument_list|(
name|BB
argument_list|,
name|SubRegion
argument_list|)
expr_stmt|;
block|}
block|}
end_for

begin_expr_stmt
name|std
operator|::
name|vector
operator|<
name|std
operator|::
name|unique_ptr
operator|<
name|RegionT
operator|>>
name|Keep
expr_stmt|;
end_expr_stmt

begin_for
for|for
control|(
name|iterator
name|I
init|=
name|begin
argument_list|()
init|,
name|E
init|=
name|end
argument_list|()
init|;
name|I
operator|!=
name|E
condition|;
operator|++
name|I
control|)
block|{
if|if
condition|(
name|SubRegion
operator|->
name|contains
argument_list|(
name|I
operator|->
name|get
argument_list|()
argument_list|)
operator|&&
name|I
operator|->
name|get
argument_list|()
operator|!=
name|SubRegion
condition|)
block|{
operator|(
operator|*
name|I
operator|)
operator|->
name|parent
operator|=
name|SubRegion
expr_stmt|;
name|SubRegion
operator|->
name|children
operator|.
name|push_back
argument_list|(
name|std
operator|::
name|move
argument_list|(
operator|*
name|I
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|Keep
operator|.
name|push_back
argument_list|(
name|std
operator|::
name|move
argument_list|(
operator|*
name|I
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_for

begin_expr_stmt
name|children
operator|.
name|clear
argument_list|()
expr_stmt|;
end_expr_stmt

begin_macro
name|children
end_macro

begin_expr_stmt
operator|.
name|insert
argument_list|(
argument|children.begin()
argument_list|,
argument|std::move_iterator<typename RegionSet::iterator>(Keep.begin())
argument_list|,
argument|std::move_iterator<typename RegionSet::iterator>(Keep.end())
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
unit|}  template
operator|<
name|class
name|Tr
operator|>
name|typename
name|Tr
operator|::
name|RegionT
operator|*
name|RegionBase
operator|<
name|Tr
operator|>
operator|::
name|removeSubRegion
argument_list|(
argument|RegionT *Child
argument_list|)
block|{
name|assert
argument_list|(
name|Child
operator|->
name|parent
operator|==
name|this
operator|&&
literal|"Child is not a child of this region!"
argument_list|)
block|;
name|Child
operator|->
name|parent
operator|=
name|nullptr
block|;
name|typename
name|RegionSet
operator|::
name|iterator
name|I
operator|=
name|std
operator|::
name|find_if
argument_list|(
name|children
operator|.
name|begin
argument_list|()
argument_list|,
name|children
operator|.
name|end
argument_list|()
argument_list|,
index|[
operator|&
index|]
operator|(
specifier|const
name|std
operator|::
name|unique_ptr
operator|<
name|RegionT
operator|>
operator|&
name|R
operator|)
block|{
return|return
name|R
operator|.
name|get
argument_list|()
operator|==
name|Child
return|;
block|}
end_expr_stmt

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_expr_stmt
name|assert
argument_list|(
name|I
operator|!=
name|children
operator|.
name|end
argument_list|()
operator|&&
literal|"Region does not exit. Unable to remove."
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|children
operator|.
name|erase
argument_list|(
name|children
operator|.
name|begin
argument_list|()
operator|+
operator|(
name|I
operator|-
name|begin
argument_list|()
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|Child
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|class
name|Tr
operator|>
name|unsigned
name|RegionBase
operator|<
name|Tr
operator|>
operator|::
name|getDepth
argument_list|()
specifier|const
block|{
name|unsigned
name|Depth
operator|=
literal|0
block|;
for|for
control|(
name|RegionT
modifier|*
name|R
init|=
name|getParent
argument_list|()
init|;
name|R
operator|!=
name|nullptr
condition|;
name|R
operator|=
name|R
operator|->
name|getParent
argument_list|()
control|)
operator|++
name|Depth
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|Depth
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|class
name|Tr
operator|>
name|typename
name|Tr
operator|::
name|RegionT
operator|*
name|RegionBase
operator|<
name|Tr
operator|>
operator|::
name|getExpandedRegion
argument_list|()
specifier|const
block|{
name|unsigned
name|NumSuccessors
operator|=
name|Tr
operator|::
name|getNumSuccessors
argument_list|(
name|exit
argument_list|)
block|;
if|if
condition|(
name|NumSuccessors
operator|==
literal|0
condition|)
return|return
name|nullptr
return|;
name|RegionT
operator|*
name|R
operator|=
name|RI
operator|->
name|getRegionFor
argument_list|(
name|exit
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|R
operator|->
name|getEntry
argument_list|()
operator|!=
name|exit
condition|)
block|{
for|for
control|(
name|PredIterTy
name|PI
init|=
name|InvBlockTraits
operator|::
name|child_begin
argument_list|(
name|getExit
argument_list|()
argument_list|)
init|,
name|PE
init|=
name|InvBlockTraits
operator|::
name|child_end
argument_list|(
name|getExit
argument_list|()
argument_list|)
init|;
name|PI
operator|!=
name|PE
condition|;
operator|++
name|PI
control|)
if|if
condition|(
operator|!
name|contains
argument_list|(
operator|*
name|PI
argument_list|)
condition|)
return|return
name|nullptr
return|;
if|if
condition|(
name|Tr
operator|::
name|getNumSuccessors
argument_list|(
name|exit
argument_list|)
operator|==
literal|1
condition|)
return|return
name|new
name|RegionT
argument_list|(
name|getEntry
argument_list|()
argument_list|,
operator|*
name|BlockTraits
operator|::
name|child_begin
argument_list|(
name|exit
argument_list|)
argument_list|,
name|RI
argument_list|,
name|DT
argument_list|)
return|;
return|return
name|nullptr
return|;
block|}
end_if

begin_while
while|while
condition|(
name|R
operator|->
name|getParent
argument_list|()
operator|&&
name|R
operator|->
name|getParent
argument_list|()
operator|->
name|getEntry
argument_list|()
operator|==
name|exit
condition|)
name|R
operator|=
name|R
operator|->
name|getParent
argument_list|()
expr_stmt|;
end_while

begin_for
for|for
control|(
name|PredIterTy
name|PI
init|=
name|InvBlockTraits
operator|::
name|child_begin
argument_list|(
name|getExit
argument_list|()
argument_list|)
init|,
name|PE
init|=
name|InvBlockTraits
operator|::
name|child_end
argument_list|(
name|getExit
argument_list|()
argument_list|)
init|;
name|PI
operator|!=
name|PE
condition|;
operator|++
name|PI
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|contains
argument_list|(
operator|*
name|PI
argument_list|)
operator|||
name|R
operator|->
name|contains
argument_list|(
operator|*
name|PI
argument_list|)
operator|)
condition|)
return|return
name|nullptr
return|;
block|}
end_for

begin_return
return|return
name|new
name|RegionT
argument_list|(
name|getEntry
argument_list|()
argument_list|,
name|R
operator|->
name|getExit
argument_list|()
argument_list|,
name|RI
argument_list|,
name|DT
argument_list|)
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|class
name|Tr
operator|>
name|void
name|RegionBase
operator|<
name|Tr
operator|>
operator|::
name|print
argument_list|(
argument|raw_ostream&OS
argument_list|,
argument|bool print_tree
argument_list|,
argument|unsigned level
argument_list|,
argument|PrintStyle Style
argument_list|)
specifier|const
block|{
if|if
condition|(
name|print_tree
condition|)
name|OS
operator|.
name|indent
argument_list|(
name|level
operator|*
literal|2
argument_list|)
operator|<<
literal|'['
operator|<<
name|level
operator|<<
literal|"] "
operator|<<
name|getNameStr
argument_list|()
expr_stmt|;
else|else
name|OS
operator|.
name|indent
argument_list|(
name|level
operator|*
literal|2
argument_list|)
operator|<<
name|getNameStr
argument_list|()
expr_stmt|;
name|OS
operator|<<
literal|'\n'
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|Style
operator|!=
name|PrintNone
condition|)
block|{
name|OS
operator|.
name|indent
argument_list|(
name|level
operator|*
literal|2
argument_list|)
operator|<<
literal|"{\n"
expr_stmt|;
name|OS
operator|.
name|indent
argument_list|(
name|level
operator|*
literal|2
operator|+
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|Style
operator|==
name|PrintBB
condition|)
block|{
for|for
control|(
specifier|const
specifier|auto
modifier|*
name|BB
range|:
name|blocks
argument_list|()
control|)
name|OS
operator|<<
name|BB
operator|->
name|getName
argument_list|()
operator|<<
literal|", "
expr_stmt|;
comment|// TODO: remove the last ","
block|}
elseif|else
if|if
condition|(
name|Style
operator|==
name|PrintRN
condition|)
block|{
for|for
control|(
name|const_element_iterator
name|I
init|=
name|element_begin
argument_list|()
init|,
name|E
init|=
name|element_end
argument_list|()
init|;
name|I
operator|!=
name|E
condition|;
operator|++
name|I
control|)
block|{
name|OS
operator|<<
operator|*
operator|*
name|I
operator|<<
literal|", "
expr_stmt|;
comment|// TODO: remove the last ",
block|}
block|}
name|OS
operator|<<
literal|'\n'
expr_stmt|;
block|}
end_if

begin_if
if|if
condition|(
name|print_tree
condition|)
block|{
for|for
control|(
name|const_iterator
name|RI
init|=
name|begin
argument_list|()
init|,
name|RE
init|=
name|end
argument_list|()
init|;
name|RI
operator|!=
name|RE
condition|;
operator|++
name|RI
control|)
operator|(
operator|*
name|RI
operator|)
operator|->
name|print
argument_list|(
name|OS
argument_list|,
name|print_tree
argument_list|,
name|level
operator|+
literal|1
argument_list|,
name|Style
argument_list|)
expr_stmt|;
block|}
end_if

begin_if
if|if
condition|(
name|Style
operator|!=
name|PrintNone
condition|)
name|OS
operator|.
name|indent
argument_list|(
name|level
operator|*
literal|2
argument_list|)
operator|<<
literal|"} \n"
expr_stmt|;
end_if

begin_if
unit|}
if|#
directive|if
operator|!
name|defined
argument_list|(
name|NDEBUG
argument_list|)
operator|||
name|defined
argument_list|(
name|LLVM_ENABLE_DUMP
argument_list|)
end_if

begin_expr_stmt
unit|template
operator|<
name|class
name|Tr
operator|>
name|void
name|RegionBase
operator|<
name|Tr
operator|>
operator|::
name|dump
argument_list|()
specifier|const
block|{
name|print
argument_list|(
name|dbgs
argument_list|()
argument_list|,
name|true
argument_list|,
name|getDepth
argument_list|()
argument_list|,
name|RegionInfoBase
operator|<
name|Tr
operator|>
operator|::
name|printStyle
argument_list|)
block|; }
endif|#
directive|endif
name|template
operator|<
name|class
name|Tr
operator|>
name|void
name|RegionBase
operator|<
name|Tr
operator|>
operator|::
name|clearNodeCache
argument_list|()
block|{
comment|// Free the cached nodes.
for|for
control|(
name|typename
name|BBNodeMapT
operator|::
name|iterator
name|I
operator|=
name|BBNodeMap
operator|.
name|begin
argument_list|()
operator|,
name|IE
operator|=
name|BBNodeMap
operator|.
name|end
argument_list|()
init|;
name|I
operator|!=
name|IE
condition|;
operator|++
name|I
control|)
name|delete
name|I
operator|->
name|second
decl_stmt|;
name|BBNodeMap
operator|.
name|clear
argument_list|()
expr_stmt|;
end_expr_stmt

begin_for
for|for
control|(
name|typename
name|RegionT
operator|::
name|iterator
name|RI
operator|=
name|begin
argument_list|()
operator|,
name|RE
operator|=
name|end
argument_list|()
init|;
name|RI
operator|!=
name|RE
condition|;
operator|++
name|RI
control|)
operator|(
operator|*
name|RI
operator|)
operator|->
name|clearNodeCache
argument_list|()
expr_stmt|;
end_for

begin_comment
unit|}
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|// RegionInfoBase implementation
end_comment

begin_comment
comment|//
end_comment

begin_expr_stmt
unit|template
operator|<
name|class
name|Tr
operator|>
name|RegionInfoBase
operator|<
name|Tr
operator|>
operator|::
name|RegionInfoBase
argument_list|()
operator|:
name|TopLevelRegion
argument_list|(
argument|nullptr
argument_list|)
block|{}
name|template
operator|<
name|class
name|Tr
operator|>
name|RegionInfoBase
operator|<
name|Tr
operator|>
operator|::
operator|~
name|RegionInfoBase
argument_list|()
block|{
name|releaseMemory
argument_list|()
block|; }
name|template
operator|<
name|class
name|Tr
operator|>
name|void
name|RegionInfoBase
operator|<
name|Tr
operator|>
operator|::
name|verifyBBMap
argument_list|(
argument|const RegionT *R
argument_list|)
specifier|const
block|{
name|assert
argument_list|(
name|R
operator|&&
literal|"Re must be non-null"
argument_list|)
block|;
for|for
control|(
name|auto
name|I
init|=
name|R
operator|->
name|element_begin
argument_list|()
init|,
name|E
init|=
name|R
operator|->
name|element_end
argument_list|()
init|;
name|I
operator|!=
name|E
condition|;
operator|++
name|I
control|)
block|{
if|if
condition|(
name|I
operator|->
name|isSubRegion
argument_list|()
condition|)
block|{
specifier|const
name|RegionT
modifier|*
name|SR
init|=
name|I
operator|->
name|template
name|getNodeAs
operator|<
name|RegionT
operator|>
operator|(
operator|)
decl_stmt|;
name|verifyBBMap
argument_list|(
name|SR
argument_list|)
expr_stmt|;
block|}
end_expr_stmt

begin_else
else|else
block|{
name|BlockT
modifier|*
name|BB
init|=
name|I
operator|->
name|template
name|getNodeAs
operator|<
name|BlockT
operator|>
operator|(
operator|)
decl_stmt|;
if|if
condition|(
name|getRegionFor
argument_list|(
name|BB
argument_list|)
operator|!=
name|R
condition|)
name|llvm_unreachable
argument_list|(
literal|"BB map does not match region nesting"
argument_list|)
expr_stmt|;
block|}
end_else

begin_expr_stmt
unit|} }
name|template
operator|<
name|class
name|Tr
operator|>
name|bool
name|RegionInfoBase
operator|<
name|Tr
operator|>
operator|::
name|isCommonDomFrontier
argument_list|(
argument|BlockT *BB
argument_list|,
argument|BlockT *entry
argument_list|,
argument|BlockT *exit
argument_list|)
specifier|const
block|{
for|for
control|(
name|PredIterTy
name|PI
init|=
name|InvBlockTraits
operator|::
name|child_begin
argument_list|(
name|BB
argument_list|)
init|,
name|PE
init|=
name|InvBlockTraits
operator|::
name|child_end
argument_list|(
name|BB
argument_list|)
init|;
name|PI
operator|!=
name|PE
condition|;
operator|++
name|PI
control|)
block|{
name|BlockT
modifier|*
name|P
init|=
operator|*
name|PI
decl_stmt|;
if|if
condition|(
name|DT
operator|->
name|dominates
argument_list|(
name|entry
argument_list|,
name|P
argument_list|)
operator|&&
operator|!
name|DT
operator|->
name|dominates
argument_list|(
name|exit
argument_list|,
name|P
argument_list|)
condition|)
return|return
name|false
return|;
block|}
end_expr_stmt

begin_return
return|return
name|true
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|class
name|Tr
operator|>
name|bool
name|RegionInfoBase
operator|<
name|Tr
operator|>
operator|::
name|isRegion
argument_list|(
argument|BlockT *entry
argument_list|,
argument|BlockT *exit
argument_list|)
specifier|const
block|{
name|assert
argument_list|(
name|entry
operator|&&
name|exit
operator|&&
literal|"entry and exit must not be null!"
argument_list|)
block|;
typedef|typedef
name|typename
name|DomFrontierT
operator|::
name|DomSetType
name|DST
expr_stmt|;
name|DST
operator|*
name|entrySuccs
operator|=
operator|&
name|DF
operator|->
name|find
argument_list|(
name|entry
argument_list|)
operator|->
name|second
expr_stmt|;
end_expr_stmt

begin_comment
comment|// Exit is the header of a loop that contains the entry. In this case,
end_comment

begin_comment
comment|// the dominance frontier must only contain the exit.
end_comment

begin_if
if|if
condition|(
operator|!
name|DT
operator|->
name|dominates
argument_list|(
name|entry
argument_list|,
name|exit
argument_list|)
condition|)
block|{
for|for
control|(
name|typename
name|DST
operator|::
name|iterator
name|SI
operator|=
name|entrySuccs
operator|->
name|begin
argument_list|()
operator|,
name|SE
operator|=
name|entrySuccs
operator|->
name|end
argument_list|()
init|;
name|SI
operator|!=
name|SE
condition|;
operator|++
name|SI
control|)
block|{
if|if
condition|(
operator|*
name|SI
operator|!=
name|exit
operator|&&
operator|*
name|SI
operator|!=
name|entry
condition|)
return|return
name|false
return|;
block|}
return|return
name|true
return|;
block|}
end_if

begin_decl_stmt
name|DST
modifier|*
name|exitSuccs
init|=
operator|&
name|DF
operator|->
name|find
argument_list|(
name|exit
argument_list|)
operator|->
name|second
decl_stmt|;
end_decl_stmt

begin_comment
comment|// Do not allow edges leaving the region.
end_comment

begin_for
for|for
control|(
name|typename
name|DST
operator|::
name|iterator
name|SI
operator|=
name|entrySuccs
operator|->
name|begin
argument_list|()
operator|,
name|SE
operator|=
name|entrySuccs
operator|->
name|end
argument_list|()
init|;
name|SI
operator|!=
name|SE
condition|;
operator|++
name|SI
control|)
block|{
if|if
condition|(
operator|*
name|SI
operator|==
name|exit
operator|||
operator|*
name|SI
operator|==
name|entry
condition|)
continue|continue;
if|if
condition|(
name|exitSuccs
operator|->
name|find
argument_list|(
operator|*
name|SI
argument_list|)
operator|==
name|exitSuccs
operator|->
name|end
argument_list|()
condition|)
return|return
name|false
return|;
if|if
condition|(
operator|!
name|isCommonDomFrontier
argument_list|(
operator|*
name|SI
argument_list|,
name|entry
argument_list|,
name|exit
argument_list|)
condition|)
return|return
name|false
return|;
block|}
end_for

begin_comment
comment|// Do not allow edges pointing into the region.
end_comment

begin_for
for|for
control|(
name|typename
name|DST
operator|::
name|iterator
name|SI
operator|=
name|exitSuccs
operator|->
name|begin
argument_list|()
operator|,
name|SE
operator|=
name|exitSuccs
operator|->
name|end
argument_list|()
init|;
name|SI
operator|!=
name|SE
condition|;
operator|++
name|SI
control|)
block|{
if|if
condition|(
name|DT
operator|->
name|properlyDominates
argument_list|(
name|entry
argument_list|,
operator|*
name|SI
argument_list|)
operator|&&
operator|*
name|SI
operator|!=
name|exit
condition|)
return|return
name|false
return|;
block|}
end_for

begin_return
return|return
name|true
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|class
name|Tr
operator|>
name|void
name|RegionInfoBase
operator|<
name|Tr
operator|>
operator|::
name|insertShortCut
argument_list|(
argument|BlockT *entry
argument_list|,
argument|BlockT *exit
argument_list|,
argument|BBtoBBMap *ShortCut
argument_list|)
specifier|const
block|{
name|assert
argument_list|(
name|entry
operator|&&
name|exit
operator|&&
literal|"entry and exit must not be null!"
argument_list|)
block|;
name|typename
name|BBtoBBMap
operator|::
name|iterator
name|e
operator|=
name|ShortCut
operator|->
name|find
argument_list|(
name|exit
argument_list|)
block|;
if|if
condition|(
name|e
operator|==
name|ShortCut
operator|->
name|end
argument_list|()
condition|)
comment|// No further region at exit available.
operator|(
operator|*
name|ShortCut
operator|)
index|[
name|entry
index|]
operator|=
name|exit
expr_stmt|;
else|else
block|{
comment|// We found a region e that starts at exit. Therefore (entry, e->second)
comment|// is also a region, that is larger than (entry, exit). Insert the
comment|// larger one.
name|BlockT
modifier|*
name|BB
init|=
name|e
operator|->
name|second
decl_stmt|;
operator|(
operator|*
name|ShortCut
operator|)
index|[
name|entry
index|]
operator|=
name|BB
expr_stmt|;
block|}
end_expr_stmt

begin_expr_stmt
unit|}  template
operator|<
name|class
name|Tr
operator|>
name|typename
name|Tr
operator|::
name|DomTreeNodeT
operator|*
name|RegionInfoBase
operator|<
name|Tr
operator|>
operator|::
name|getNextPostDom
argument_list|(
argument|DomTreeNodeT *N
argument_list|,
argument|BBtoBBMap *ShortCut
argument_list|)
specifier|const
block|{
name|typename
name|BBtoBBMap
operator|::
name|iterator
name|e
operator|=
name|ShortCut
operator|->
name|find
argument_list|(
name|N
operator|->
name|getBlock
argument_list|()
argument_list|)
block|;
if|if
condition|(
name|e
operator|==
name|ShortCut
operator|->
name|end
argument_list|()
condition|)
return|return
name|N
operator|->
name|getIDom
argument_list|()
return|;
end_expr_stmt

begin_return
return|return
name|PDT
operator|->
name|getNode
argument_list|(
name|e
operator|->
name|second
argument_list|)
operator|->
name|getIDom
argument_list|()
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|class
name|Tr
operator|>
name|bool
name|RegionInfoBase
operator|<
name|Tr
operator|>
operator|::
name|isTrivialRegion
argument_list|(
argument|BlockT *entry
argument_list|,
argument|BlockT *exit
argument_list|)
specifier|const
block|{
name|assert
argument_list|(
name|entry
operator|&&
name|exit
operator|&&
literal|"entry and exit must not be null!"
argument_list|)
block|;
name|unsigned
name|num_successors
operator|=
name|BlockTraits
operator|::
name|child_end
argument_list|(
name|entry
argument_list|)
operator|-
name|BlockTraits
operator|::
name|child_begin
argument_list|(
name|entry
argument_list|)
block|;
if|if
condition|(
name|num_successors
operator|<=
literal|1
operator|&&
name|exit
operator|==
operator|*
operator|(
name|BlockTraits
operator|::
name|child_begin
argument_list|(
name|entry
argument_list|)
operator|)
condition|)
return|return
name|true
return|;
end_expr_stmt

begin_return
return|return
name|false
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|class
name|Tr
operator|>
name|typename
name|Tr
operator|::
name|RegionT
operator|*
name|RegionInfoBase
operator|<
name|Tr
operator|>
operator|::
name|createRegion
argument_list|(
argument|BlockT *entry
argument_list|,
argument|BlockT *exit
argument_list|)
block|{
name|assert
argument_list|(
name|entry
operator|&&
name|exit
operator|&&
literal|"entry and exit must not be null!"
argument_list|)
block|;
if|if
condition|(
name|isTrivialRegion
argument_list|(
name|entry
argument_list|,
name|exit
argument_list|)
condition|)
return|return
name|nullptr
return|;
name|RegionT
operator|*
name|region
operator|=
name|new
name|RegionT
argument_list|(
name|entry
argument_list|,
name|exit
argument_list|,
name|static_cast
operator|<
name|RegionInfoT
operator|*
operator|>
operator|(
name|this
operator|)
argument_list|,
name|DT
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|BBtoRegion
operator|.
name|insert
argument_list|(
name|std
operator|::
name|make_pair
argument_list|(
name|entry
argument_list|,
name|region
argument_list|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|XDEBUG
end_ifdef

begin_expr_stmt
name|region
operator|->
name|verifyRegion
argument_list|()
expr_stmt|;
end_expr_stmt

begin_else
else|#
directive|else
end_else

begin_expr_stmt
name|DEBUG
argument_list|(
name|region
operator|->
name|verifyRegion
argument_list|()
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_expr_stmt
name|updateStatistics
argument_list|(
name|region
argument_list|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|region
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|class
name|Tr
operator|>
name|void
name|RegionInfoBase
operator|<
name|Tr
operator|>
operator|::
name|findRegionsWithEntry
argument_list|(
argument|BlockT *entry
argument_list|,
argument|BBtoBBMap *ShortCut
argument_list|)
block|{
name|assert
argument_list|(
name|entry
argument_list|)
block|;
name|DomTreeNodeT
operator|*
name|N
operator|=
name|PDT
operator|->
name|getNode
argument_list|(
name|entry
argument_list|)
block|;
if|if
condition|(
operator|!
name|N
condition|)
return|return;
name|RegionT
operator|*
name|lastRegion
operator|=
name|nullptr
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|BlockT
modifier|*
name|lastExit
init|=
name|entry
decl_stmt|;
end_decl_stmt

begin_comment
comment|// As only a BasicBlock that postdominates entry can finish a region, walk the
end_comment

begin_comment
comment|// post dominance tree upwards.
end_comment

begin_while
while|while
condition|(
operator|(
name|N
operator|=
name|getNextPostDom
argument_list|(
name|N
argument_list|,
name|ShortCut
argument_list|)
operator|)
condition|)
block|{
name|BlockT
modifier|*
name|exit
init|=
name|N
operator|->
name|getBlock
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|exit
condition|)
break|break;
if|if
condition|(
name|isRegion
argument_list|(
name|entry
argument_list|,
name|exit
argument_list|)
condition|)
block|{
name|RegionT
modifier|*
name|newRegion
init|=
name|createRegion
argument_list|(
name|entry
argument_list|,
name|exit
argument_list|)
decl_stmt|;
if|if
condition|(
name|lastRegion
condition|)
name|newRegion
operator|->
name|addSubRegion
argument_list|(
name|lastRegion
argument_list|)
expr_stmt|;
name|lastRegion
operator|=
name|newRegion
expr_stmt|;
name|lastExit
operator|=
name|exit
expr_stmt|;
block|}
comment|// This can never be a region, so stop the search.
if|if
condition|(
operator|!
name|DT
operator|->
name|dominates
argument_list|(
name|entry
argument_list|,
name|exit
argument_list|)
condition|)
break|break;
block|}
end_while

begin_comment
comment|// Tried to create regions from entry to lastExit.  Next time take a
end_comment

begin_comment
comment|// shortcut from entry to lastExit.
end_comment

begin_if
if|if
condition|(
name|lastExit
operator|!=
name|entry
condition|)
name|insertShortCut
argument_list|(
name|entry
argument_list|,
name|lastExit
argument_list|,
name|ShortCut
argument_list|)
expr_stmt|;
end_if

begin_expr_stmt
unit|}  template
operator|<
name|class
name|Tr
operator|>
name|void
name|RegionInfoBase
operator|<
name|Tr
operator|>
operator|::
name|scanForRegions
argument_list|(
argument|FuncT&F
argument_list|,
argument|BBtoBBMap *ShortCut
argument_list|)
block|{
typedef|typedef
name|typename
name|std
operator|::
name|add_pointer
operator|<
name|FuncT
operator|>
operator|::
name|type
name|FuncPtrT
expr_stmt|;
name|BlockT
operator|*
name|entry
operator|=
name|GraphTraits
operator|<
name|FuncPtrT
operator|>
operator|::
name|getEntryNode
argument_list|(
operator|&
name|F
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|DomTreeNodeT
modifier|*
name|N
init|=
name|DT
operator|->
name|getNode
argument_list|(
name|entry
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|// Iterate over the dominance tree in post order to start with the small
end_comment

begin_comment
comment|// regions from the bottom of the dominance tree.  If the small regions are
end_comment

begin_comment
comment|// detected first, detection of bigger regions is faster, as we can jump
end_comment

begin_comment
comment|// over the small regions.
end_comment

begin_for
for|for
control|(
name|auto
name|DomNode
range|:
name|post_order
argument_list|(
name|N
argument_list|)
control|)
name|findRegionsWithEntry
argument_list|(
name|DomNode
operator|->
name|getBlock
argument_list|()
argument_list|,
name|ShortCut
argument_list|)
expr_stmt|;
end_for

begin_expr_stmt
unit|}  template
operator|<
name|class
name|Tr
operator|>
name|typename
name|Tr
operator|::
name|RegionT
operator|*
name|RegionInfoBase
operator|<
name|Tr
operator|>
operator|::
name|getTopMostParent
argument_list|(
argument|RegionT *region
argument_list|)
block|{
while|while
condition|(
name|region
operator|->
name|getParent
argument_list|()
condition|)
name|region
operator|=
name|region
operator|->
name|getParent
argument_list|()
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|region
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|class
name|Tr
operator|>
name|void
name|RegionInfoBase
operator|<
name|Tr
operator|>
operator|::
name|buildRegionsTree
argument_list|(
argument|DomTreeNodeT *N
argument_list|,
argument|RegionT *region
argument_list|)
block|{
name|BlockT
operator|*
name|BB
operator|=
name|N
operator|->
name|getBlock
argument_list|()
block|;
comment|// Passed region exit
while|while
condition|(
name|BB
operator|==
name|region
operator|->
name|getExit
argument_list|()
condition|)
name|region
operator|=
name|region
operator|->
name|getParent
argument_list|()
expr_stmt|;
name|typename
name|BBtoRegionMap
operator|::
name|iterator
name|it
operator|=
name|BBtoRegion
operator|.
name|find
argument_list|(
name|BB
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|// This basic block is a start block of a region. It is already in the
end_comment

begin_comment
comment|// BBtoRegion relation. Only the child basic blocks have to be updated.
end_comment

begin_if
if|if
condition|(
name|it
operator|!=
name|BBtoRegion
operator|.
name|end
argument_list|()
condition|)
block|{
name|RegionT
modifier|*
name|newRegion
init|=
name|it
operator|->
name|second
decl_stmt|;
name|region
operator|->
name|addSubRegion
argument_list|(
name|getTopMostParent
argument_list|(
name|newRegion
argument_list|)
argument_list|)
expr_stmt|;
name|region
operator|=
name|newRegion
expr_stmt|;
block|}
else|else
block|{
name|BBtoRegion
index|[
name|BB
index|]
operator|=
name|region
expr_stmt|;
block|}
end_if

begin_for
for|for
control|(
name|typename
name|DomTreeNodeT
operator|::
name|iterator
name|CI
operator|=
name|N
operator|->
name|begin
argument_list|()
operator|,
name|CE
operator|=
name|N
operator|->
name|end
argument_list|()
init|;
name|CI
operator|!=
name|CE
condition|;
operator|++
name|CI
control|)
block|{
name|buildRegionsTree
argument_list|(
operator|*
name|CI
argument_list|,
name|region
argument_list|)
expr_stmt|;
block|}
end_for

begin_ifdef
unit|}
ifdef|#
directive|ifdef
name|XDEBUG
end_ifdef

begin_expr_stmt
unit|template
operator|<
name|class
name|Tr
operator|>
name|bool
name|RegionInfoBase
operator|<
name|Tr
operator|>
operator|::
name|VerifyRegionInfo
operator|=
name|true
expr_stmt|;
end_expr_stmt

begin_else
else|#
directive|else
end_else

begin_expr_stmt
name|template
operator|<
name|class
name|Tr
operator|>
name|bool
name|RegionInfoBase
operator|<
name|Tr
operator|>
operator|::
name|VerifyRegionInfo
operator|=
name|false
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_expr_stmt
name|template
operator|<
name|class
name|Tr
operator|>
name|typename
name|Tr
operator|::
name|RegionT
operator|::
name|PrintStyle
name|RegionInfoBase
operator|<
name|Tr
operator|>
operator|::
name|printStyle
operator|=
name|RegionBase
operator|<
name|Tr
operator|>
operator|::
name|PrintNone
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|Tr
operator|>
name|void
name|RegionInfoBase
operator|<
name|Tr
operator|>
operator|::
name|print
argument_list|(
argument|raw_ostream&OS
argument_list|)
specifier|const
block|{
name|OS
operator|<<
literal|"Region tree:\n"
block|;
name|TopLevelRegion
operator|->
name|print
argument_list|(
name|OS
argument_list|,
name|true
argument_list|,
literal|0
argument_list|,
name|printStyle
argument_list|)
block|;
name|OS
operator|<<
literal|"End region tree\n"
block|; }
if|#
directive|if
operator|!
name|defined
argument_list|(
name|NDEBUG
argument_list|)
operator|||
name|defined
argument_list|(
name|LLVM_ENABLE_DUMP
argument_list|)
name|template
operator|<
name|class
name|Tr
operator|>
name|void
name|RegionInfoBase
operator|<
name|Tr
operator|>
operator|::
name|dump
argument_list|()
specifier|const
block|{
name|print
argument_list|(
name|dbgs
argument_list|()
argument_list|)
block|; }
endif|#
directive|endif
name|template
operator|<
name|class
name|Tr
operator|>
name|void
name|RegionInfoBase
operator|<
name|Tr
operator|>
operator|::
name|releaseMemory
argument_list|()
block|{
name|BBtoRegion
operator|.
name|clear
argument_list|()
block|;
if|if
condition|(
name|TopLevelRegion
condition|)
name|delete
name|TopLevelRegion
decl_stmt|;
name|TopLevelRegion
operator|=
name|nullptr
expr_stmt|;
end_expr_stmt

begin_expr_stmt
unit|}  template
operator|<
name|class
name|Tr
operator|>
name|void
name|RegionInfoBase
operator|<
name|Tr
operator|>
operator|::
name|verifyAnalysis
argument_list|()
specifier|const
block|{
comment|// Do only verify regions if explicitely activated using XDEBUG or
comment|// -verify-region-info
if|if
condition|(
operator|!
name|RegionInfoBase
operator|<
name|Tr
operator|>
operator|::
name|VerifyRegionInfo
condition|)
return|return;
name|TopLevelRegion
operator|->
name|verifyRegionNest
argument_list|()
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|verifyBBMap
argument_list|(
name|TopLevelRegion
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
unit|}
comment|// Region pass manager support.
end_comment

begin_expr_stmt
unit|template
operator|<
name|class
name|Tr
operator|>
name|typename
name|Tr
operator|::
name|RegionT
operator|*
name|RegionInfoBase
operator|<
name|Tr
operator|>
operator|::
name|getRegionFor
argument_list|(
argument|BlockT *BB
argument_list|)
specifier|const
block|{
name|typename
name|BBtoRegionMap
operator|::
name|const_iterator
name|I
operator|=
name|BBtoRegion
operator|.
name|find
argument_list|(
name|BB
argument_list|)
block|;
return|return
name|I
operator|!=
name|BBtoRegion
operator|.
name|end
argument_list|()
condition|?
name|I
operator|->
name|second
else|:
name|nullptr
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|Tr
operator|>
name|void
name|RegionInfoBase
operator|<
name|Tr
operator|>
operator|::
name|setRegionFor
argument_list|(
argument|BlockT *BB
argument_list|,
argument|RegionT *R
argument_list|)
block|{
name|BBtoRegion
index|[
name|BB
index|]
operator|=
name|R
block|; }
name|template
operator|<
name|class
name|Tr
operator|>
name|typename
name|Tr
operator|::
name|RegionT
operator|*
name|RegionInfoBase
operator|<
name|Tr
operator|>
operator|::
name|operator
index|[]
operator|(
name|BlockT
operator|*
name|BB
operator|)
specifier|const
block|{
return|return
name|getRegionFor
argument_list|(
name|BB
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|Tr
operator|>
name|typename
name|RegionInfoBase
operator|<
name|Tr
operator|>
operator|::
name|BlockT
operator|*
name|RegionInfoBase
operator|<
name|Tr
operator|>
operator|::
name|getMaxRegionExit
argument_list|(
argument|BlockT *BB
argument_list|)
specifier|const
block|{
name|BlockT
operator|*
name|Exit
operator|=
name|nullptr
block|;
while|while
condition|(
name|true
condition|)
block|{
comment|// Get largest region that starts at BB.
name|RegionT
modifier|*
name|R
init|=
name|getRegionFor
argument_list|(
name|BB
argument_list|)
decl_stmt|;
while|while
condition|(
name|R
operator|&&
name|R
operator|->
name|getParent
argument_list|()
operator|&&
name|R
operator|->
name|getParent
argument_list|()
operator|->
name|getEntry
argument_list|()
operator|==
name|BB
condition|)
name|R
operator|=
name|R
operator|->
name|getParent
argument_list|()
expr_stmt|;
comment|// Get the single exit of BB.
if|if
condition|(
name|R
operator|&&
name|R
operator|->
name|getEntry
argument_list|()
operator|==
name|BB
condition|)
name|Exit
operator|=
name|R
operator|->
name|getExit
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
operator|++
name|BlockTraits
operator|::
name|child_begin
argument_list|(
name|BB
argument_list|)
operator|==
name|BlockTraits
operator|::
name|child_end
argument_list|(
name|BB
argument_list|)
condition|)
name|Exit
operator|=
operator|*
name|BlockTraits
operator|::
name|child_begin
argument_list|(
name|BB
argument_list|)
expr_stmt|;
else|else
comment|// No single exit exists.
return|return
name|Exit
return|;
comment|// Get largest region that starts at Exit.
name|RegionT
modifier|*
name|ExitR
init|=
name|getRegionFor
argument_list|(
name|Exit
argument_list|)
decl_stmt|;
while|while
condition|(
name|ExitR
operator|&&
name|ExitR
operator|->
name|getParent
argument_list|()
operator|&&
name|ExitR
operator|->
name|getParent
argument_list|()
operator|->
name|getEntry
argument_list|()
operator|==
name|Exit
condition|)
name|ExitR
operator|=
name|ExitR
operator|->
name|getParent
argument_list|()
expr_stmt|;
for|for
control|(
name|PredIterTy
name|PI
init|=
name|InvBlockTraits
operator|::
name|child_begin
argument_list|(
name|Exit
argument_list|)
init|,
name|PE
init|=
name|InvBlockTraits
operator|::
name|child_end
argument_list|(
name|Exit
argument_list|)
init|;
name|PI
operator|!=
name|PE
condition|;
operator|++
name|PI
control|)
block|{
if|if
condition|(
operator|!
name|R
operator|->
name|contains
argument_list|(
operator|*
name|PI
argument_list|)
operator|&&
operator|!
name|ExitR
operator|->
name|contains
argument_list|(
operator|*
name|PI
argument_list|)
condition|)
break|break;
block|}
end_expr_stmt

begin_comment
comment|// This stops infinite cycles.
end_comment

begin_if
if|if
condition|(
name|DT
operator|->
name|dominates
argument_list|(
name|Exit
argument_list|,
name|BB
argument_list|)
condition|)
break|break;
end_if

begin_expr_stmt
name|BB
operator|=
name|Exit
expr_stmt|;
end_expr_stmt

begin_expr_stmt
unit|}    return
name|Exit
expr_stmt|;
end_expr_stmt

begin_expr_stmt
unit|}  template
operator|<
name|class
name|Tr
operator|>
name|typename
name|Tr
operator|::
name|RegionT
operator|*
name|RegionInfoBase
operator|<
name|Tr
operator|>
operator|::
name|getCommonRegion
argument_list|(
argument|RegionT *A
argument_list|,
argument|RegionT *B
argument_list|)
specifier|const
block|{
name|assert
argument_list|(
name|A
operator|&&
name|B
operator|&&
literal|"One of the Regions is NULL"
argument_list|)
block|;
if|if
condition|(
name|A
operator|->
name|contains
argument_list|(
name|B
argument_list|)
condition|)
return|return
name|A
return|;
end_expr_stmt

begin_while
while|while
condition|(
operator|!
name|B
operator|->
name|contains
argument_list|(
name|A
argument_list|)
condition|)
name|B
operator|=
name|B
operator|->
name|getParent
argument_list|()
expr_stmt|;
end_while

begin_return
return|return
name|B
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|class
name|Tr
operator|>
name|typename
name|Tr
operator|::
name|RegionT
operator|*
name|RegionInfoBase
operator|<
name|Tr
operator|>
operator|::
name|getCommonRegion
argument_list|(
argument|SmallVectorImpl<RegionT *>&Regions
argument_list|)
specifier|const
block|{
name|RegionT
operator|*
name|ret
operator|=
name|Regions
operator|.
name|back
argument_list|()
block|;
name|Regions
operator|.
name|pop_back
argument_list|()
block|;
for|for
control|(
name|RegionT
modifier|*
name|R
range|:
name|Regions
control|)
name|ret
operator|=
name|getCommonRegion
argument_list|(
name|ret
argument_list|,
name|R
argument_list|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|ret
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|class
name|Tr
operator|>
name|typename
name|Tr
operator|::
name|RegionT
operator|*
name|RegionInfoBase
operator|<
name|Tr
operator|>
operator|::
name|getCommonRegion
argument_list|(
argument|SmallVectorImpl<BlockT *>&BBs
argument_list|)
specifier|const
block|{
name|RegionT
operator|*
name|ret
operator|=
name|getRegionFor
argument_list|(
name|BBs
operator|.
name|back
argument_list|()
argument_list|)
block|;
name|BBs
operator|.
name|pop_back
argument_list|()
block|;
for|for
control|(
name|BlockT
modifier|*
name|BB
range|:
name|BBs
control|)
name|ret
operator|=
name|getCommonRegion
argument_list|(
name|ret
argument_list|,
name|getRegionFor
argument_list|(
name|BB
argument_list|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|ret
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|class
name|Tr
operator|>
name|void
name|RegionInfoBase
operator|<
name|Tr
operator|>
operator|::
name|calculate
argument_list|(
argument|FuncT&F
argument_list|)
block|{
typedef|typedef
name|typename
name|std
operator|::
name|add_pointer
operator|<
name|FuncT
operator|>
operator|::
name|type
name|FuncPtrT
expr_stmt|;
comment|// ShortCut a function where for every BB the exit of the largest region
comment|// starting with BB is stored. These regions can be threated as single BBS.
comment|// This improves performance on linear CFGs.
name|BBtoBBMap
name|ShortCut
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|scanForRegions
argument_list|(
name|F
argument_list|,
operator|&
name|ShortCut
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|BlockT
modifier|*
name|BB
init|=
name|GraphTraits
operator|<
name|FuncPtrT
operator|>
operator|::
name|getEntryNode
argument_list|(
operator|&
name|F
argument_list|)
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|buildRegionsTree
argument_list|(
name|DT
operator|->
name|getNode
argument_list|(
name|BB
argument_list|)
argument_list|,
name|TopLevelRegion
argument_list|)
expr_stmt|;
end_expr_stmt

begin_undef
unit|}
undef|#
directive|undef
name|DEBUG_TYPE
end_undef

begin_comment
unit|}
comment|// end namespace llvm
end_comment

begin_endif
endif|#
directive|endif
end_endif

end_unit

