begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//=== llvm/Analysis/DominatorInternals.h - Dominator Calculation -*- C++ -*-==//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LLVM_ANALYSIS_DOMINATOR_INTERNALS_H
end_ifndef

begin_define
define|#
directive|define
name|LLVM_ANALYSIS_DOMINATOR_INTERNALS_H
end_define

begin_include
include|#
directive|include
file|"llvm/Analysis/Dominators.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/SmallPtrSet.h"
end_include

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// DominatorTree construction - This pass constructs immediate dominator
end_comment

begin_comment
comment|// information for a flow-graph based on the algorithm described in this
end_comment

begin_comment
comment|// document:
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//   A Fast Algorithm for Finding Dominators in a Flowgraph
end_comment

begin_comment
comment|//   T. Lengauer& R. Tarjan, ACM TOPLAS July 1979, pgs 121-141.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This implements both the O(n*ack(n)) and the O(n*log(n)) versions of EVAL and
end_comment

begin_comment
comment|// LINK, but it turns out that the theoretically slower O(n*log(n))
end_comment

begin_comment
comment|// implementation is actually faster than the "efficient" algorithm (even for
end_comment

begin_comment
comment|// large CFGs) because the constant overheads are substantially smaller.  The
end_comment

begin_comment
comment|// lower-complexity version can be enabled with the following #define:
end_comment

begin_comment
comment|//
end_comment

begin_define
define|#
directive|define
name|BALANCE_IDOM_TREE
value|0
end_define

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_decl_stmt
name|namespace
name|llvm
block|{
name|template
operator|<
name|class
name|GraphT
operator|>
name|unsigned
name|DFSPass
argument_list|(
argument|DominatorTreeBase<typename GraphT::NodeType>& DT
argument_list|,
argument|typename GraphT::NodeType* V
argument_list|,
argument|unsigned N
argument_list|)
block|{
comment|// This is more understandable as a recursive algorithm, but we can't use the
comment|// recursive algorithm due to stack depth issues.  Keep it here for
comment|// documentation purposes.
if|#
directive|if
literal|0
block|InfoRec&VInfo = DT.Info[DT.Roots[i]];   VInfo.DFSNum = VInfo.Semi = ++N;   VInfo.Label = V;    Vertex.push_back(V);
comment|// Vertex[n] = V;
comment|//Info[V].Ancestor = 0;     // Ancestor[n] = 0
comment|//Info[V].Child = 0;        // Child[v] = 0
block|VInfo.Size = 1;
comment|// Size[v] = 1
block|for (succ_iterator SI = succ_begin(V), E = succ_end(V); SI != E; ++SI) {     InfoRec&SuccVInfo = DT.Info[*SI];     if (SuccVInfo.Semi == 0) {       SuccVInfo.Parent = V;       N = DTDFSPass(DT, *SI, N);     }   }
else|#
directive|else
name|bool
name|IsChilOfArtificialExit
operator|=
operator|(
name|N
operator|!=
literal|0
operator|)
block|;
name|std
operator|::
name|vector
operator|<
name|std
operator|::
name|pair
operator|<
name|typename
name|GraphT
operator|::
name|NodeType
operator|*
block|,
name|typename
name|GraphT
operator|::
name|ChildIteratorType
operator|>
expr|>
name|Worklist
block|;
name|Worklist
operator|.
name|push_back
argument_list|(
name|std
operator|::
name|make_pair
argument_list|(
name|V
argument_list|,
name|GraphT
operator|::
name|child_begin
argument_list|(
name|V
argument_list|)
argument_list|)
argument_list|)
block|;
while|while
condition|(
operator|!
name|Worklist
operator|.
name|empty
argument_list|()
condition|)
block|{
name|typename
name|GraphT
operator|::
name|NodeType
operator|*
name|BB
operator|=
name|Worklist
operator|.
name|back
argument_list|()
operator|.
name|first
expr_stmt|;
name|typename
name|GraphT
operator|::
name|ChildIteratorType
name|NextSucc
operator|=
name|Worklist
operator|.
name|back
argument_list|()
operator|.
name|second
expr_stmt|;
name|typename
name|DominatorTreeBase
operator|<
name|typename
name|GraphT
operator|::
name|NodeType
operator|>
operator|::
name|InfoRec
operator|&
name|BBInfo
operator|=
name|DT
operator|.
name|Info
index|[
name|BB
index|]
expr_stmt|;
comment|// First time we visited this BB?
if|if
condition|(
name|NextSucc
operator|==
name|GraphT
operator|::
name|child_begin
argument_list|(
name|BB
argument_list|)
condition|)
block|{
name|BBInfo
operator|.
name|DFSNum
operator|=
name|BBInfo
operator|.
name|Semi
operator|=
operator|++
name|N
expr_stmt|;
name|BBInfo
operator|.
name|Label
operator|=
name|BB
expr_stmt|;
name|DT
operator|.
name|Vertex
operator|.
name|push_back
argument_list|(
name|BB
argument_list|)
expr_stmt|;
comment|// Vertex[n] = V;
comment|//BBInfo[V].Ancestor = 0;   // Ancestor[n] = 0
comment|//BBInfo[V].Child = 0;      // Child[v] = 0
name|BBInfo
operator|.
name|Size
operator|=
literal|1
expr_stmt|;
comment|// Size[v] = 1
if|if
condition|(
name|IsChilOfArtificialExit
condition|)
name|BBInfo
operator|.
name|Parent
operator|=
literal|1
expr_stmt|;
name|IsChilOfArtificialExit
operator|=
name|false
expr_stmt|;
block|}
comment|// store the DFS number of the current BB - the reference to BBInfo might
comment|// get invalidated when processing the successors.
name|unsigned
name|BBDFSNum
init|=
name|BBInfo
operator|.
name|DFSNum
decl_stmt|;
comment|// If we are done with this block, remove it from the worklist.
if|if
condition|(
name|NextSucc
operator|==
name|GraphT
operator|::
name|child_end
argument_list|(
name|BB
argument_list|)
condition|)
block|{
name|Worklist
operator|.
name|pop_back
argument_list|()
expr_stmt|;
continue|continue;
block|}
comment|// Increment the successor number for the next time we get to it.
operator|++
name|Worklist
operator|.
name|back
argument_list|()
operator|.
name|second
expr_stmt|;
comment|// Visit the successor next, if it isn't already visited.
name|typename
name|GraphT
operator|::
name|NodeType
operator|*
name|Succ
operator|=
operator|*
name|NextSucc
expr_stmt|;
name|typename
name|DominatorTreeBase
operator|<
name|typename
name|GraphT
operator|::
name|NodeType
operator|>
operator|::
name|InfoRec
operator|&
name|SuccVInfo
operator|=
name|DT
operator|.
name|Info
index|[
name|Succ
index|]
expr_stmt|;
if|if
condition|(
name|SuccVInfo
operator|.
name|Semi
operator|==
literal|0
condition|)
block|{
name|SuccVInfo
operator|.
name|Parent
operator|=
name|BBDFSNum
expr_stmt|;
name|Worklist
operator|.
name|push_back
argument_list|(
name|std
operator|::
name|make_pair
argument_list|(
name|Succ
argument_list|,
name|GraphT
operator|::
name|child_begin
argument_list|(
name|Succ
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
return|return
name|N
return|;
block|}
name|template
operator|<
name|class
name|GraphT
operator|>
name|void
name|Compress
argument_list|(
argument|DominatorTreeBase<typename GraphT::NodeType>& DT
argument_list|,
argument|typename GraphT::NodeType *VIn
argument_list|)
block|{
name|std
operator|::
name|vector
operator|<
name|typename
name|GraphT
operator|::
name|NodeType
operator|*
operator|>
name|Work
block|;
name|SmallPtrSet
operator|<
name|typename
name|GraphT
operator|::
name|NodeType
operator|*
block|,
literal|32
operator|>
name|Visited
block|;
name|typename
name|DominatorTreeBase
operator|<
name|typename
name|GraphT
operator|::
name|NodeType
operator|>
operator|::
name|InfoRec
operator|&
name|VInVAInfo
operator|=
name|DT
operator|.
name|Info
index|[
name|DT
operator|.
name|Vertex
index|[
name|DT
operator|.
name|Info
index|[
name|VIn
index|]
operator|.
name|Ancestor
index|]
index|]
block|;
if|if
condition|(
name|VInVAInfo
operator|.
name|Ancestor
operator|!=
literal|0
condition|)
name|Work
operator|.
name|push_back
argument_list|(
name|VIn
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|Work
operator|.
name|empty
argument_list|()
condition|)
block|{
name|typename
name|GraphT
operator|::
name|NodeType
operator|*
name|V
operator|=
name|Work
operator|.
name|back
argument_list|()
expr_stmt|;
name|typename
name|DominatorTreeBase
operator|<
name|typename
name|GraphT
operator|::
name|NodeType
operator|>
operator|::
name|InfoRec
operator|&
name|VInfo
operator|=
name|DT
operator|.
name|Info
index|[
name|V
index|]
expr_stmt|;
name|typename
name|GraphT
operator|::
name|NodeType
operator|*
name|VAncestor
operator|=
name|DT
operator|.
name|Vertex
index|[
name|VInfo
operator|.
name|Ancestor
index|]
expr_stmt|;
name|typename
name|DominatorTreeBase
operator|<
name|typename
name|GraphT
operator|::
name|NodeType
operator|>
operator|::
name|InfoRec
operator|&
name|VAInfo
operator|=
name|DT
operator|.
name|Info
index|[
name|VAncestor
index|]
expr_stmt|;
comment|// Process Ancestor first
if|if
condition|(
name|Visited
operator|.
name|insert
argument_list|(
name|VAncestor
argument_list|)
operator|&&
name|VAInfo
operator|.
name|Ancestor
operator|!=
literal|0
condition|)
block|{
name|Work
operator|.
name|push_back
argument_list|(
name|VAncestor
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|Work
operator|.
name|pop_back
argument_list|()
expr_stmt|;
comment|// Update VInfo based on Ancestor info
if|if
condition|(
name|VAInfo
operator|.
name|Ancestor
operator|==
literal|0
condition|)
continue|continue;
name|typename
name|GraphT
operator|::
name|NodeType
operator|*
name|VAncestorLabel
operator|=
name|VAInfo
operator|.
name|Label
expr_stmt|;
name|typename
name|GraphT
operator|::
name|NodeType
operator|*
name|VLabel
operator|=
name|VInfo
operator|.
name|Label
expr_stmt|;
if|if
condition|(
name|DT
operator|.
name|Info
index|[
name|VAncestorLabel
index|]
operator|.
name|Semi
operator|<
name|DT
operator|.
name|Info
index|[
name|VLabel
index|]
operator|.
name|Semi
condition|)
name|VInfo
operator|.
name|Label
operator|=
name|VAncestorLabel
expr_stmt|;
name|VInfo
operator|.
name|Ancestor
operator|=
name|VAInfo
operator|.
name|Ancestor
expr_stmt|;
block|}
block|}
end_decl_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|GraphT
operator|>
name|typename
name|GraphT
operator|::
name|NodeType
operator|*
name|Eval
argument_list|(
argument|DominatorTreeBase<typename GraphT::NodeType>& DT
argument_list|,
argument|typename GraphT::NodeType *V
argument_list|)
block|{
name|typename
name|DominatorTreeBase
operator|<
name|typename
name|GraphT
operator|::
name|NodeType
operator|>
operator|::
name|InfoRec
operator|&
name|VInfo
operator|=
name|DT
operator|.
name|Info
index|[
name|V
index|]
block|;
if|#
directive|if
operator|!
name|BALANCE_IDOM_TREE
comment|// Higher-complexity but faster implementation
if|if
condition|(
name|VInfo
operator|.
name|Ancestor
operator|==
literal|0
condition|)
return|return
name|V
return|;
name|Compress
operator|<
name|GraphT
operator|>
operator|(
name|DT
operator|,
name|V
operator|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|VInfo
operator|.
name|Label
return|;
end_return

begin_else
else|#
directive|else
end_else

begin_comment
comment|// Lower-complexity but slower implementation
end_comment

begin_if
if|if
condition|(
name|VInfo
operator|.
name|Ancestor
operator|==
literal|0
condition|)
return|return
name|VInfo
operator|.
name|Label
return|;
end_if

begin_expr_stmt
name|Compress
operator|<
name|GraphT
operator|>
operator|(
name|DT
operator|,
name|V
operator|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|GraphT
operator|::
name|NodeType
operator|*
name|VLabel
operator|=
name|VInfo
operator|.
name|Label
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|GraphT
operator|::
name|NodeType
operator|*
name|VAncestorLabel
operator|=
name|DT
operator|.
name|Info
index|[
name|VInfo
operator|.
name|Ancestor
index|]
operator|.
name|Label
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|DT
operator|.
name|Info
index|[
name|VAncestorLabel
index|]
operator|.
name|Semi
operator|>=
name|DT
operator|.
name|Info
index|[
name|VLabel
index|]
operator|.
name|Semi
condition|)
return|return
name|VLabel
return|;
else|else
return|return
name|VAncestorLabel
return|;
end_if

begin_endif
endif|#
directive|endif
end_endif

begin_expr_stmt
unit|}  template
operator|<
name|class
name|GraphT
operator|>
name|void
name|Link
argument_list|(
argument|DominatorTreeBase<typename GraphT::NodeType>& DT
argument_list|,
argument|unsigned DFSNumV
argument_list|,
argument|typename GraphT::NodeType* W
argument_list|,
argument|typename DominatorTreeBase<typename GraphT::NodeType>::InfoRec&WInfo
argument_list|)
block|{
if|#
directive|if
operator|!
name|BALANCE_IDOM_TREE
comment|// Higher-complexity but faster implementation
name|WInfo
operator|.
name|Ancestor
operator|=
name|DFSNumV
block|;
else|#
directive|else
comment|// Lower-complexity but slower implementation
name|GraphT
operator|::
name|NodeType
operator|*
name|WLabel
operator|=
name|WInfo
operator|.
name|Label
block|;
name|unsigned
name|WLabelSemi
operator|=
name|DT
operator|.
name|Info
index|[
name|WLabel
index|]
operator|.
name|Semi
block|;
name|GraphT
operator|::
name|NodeType
operator|*
name|S
operator|=
name|W
block|;
name|InfoRec
operator|*
name|SInfo
operator|=
operator|&
name|DT
operator|.
name|Info
index|[
name|S
index|]
block|;
name|GraphT
operator|::
name|NodeType
operator|*
name|SChild
operator|=
name|SInfo
operator|->
name|Child
block|;
name|InfoRec
operator|*
name|SChildInfo
operator|=
operator|&
name|DT
operator|.
name|Info
index|[
name|SChild
index|]
block|;
while|while
condition|(
name|WLabelSemi
operator|<
name|DT
operator|.
name|Info
index|[
name|SChildInfo
operator|->
name|Label
index|]
operator|.
name|Semi
condition|)
block|{
name|GraphT
operator|::
name|NodeType
operator|*
name|SChildChild
operator|=
name|SChildInfo
operator|->
name|Child
expr_stmt|;
if|if
condition|(
name|SInfo
operator|->
name|Size
operator|+
name|DT
operator|.
name|Info
index|[
name|SChildChild
index|]
operator|.
name|Size
operator|>=
literal|2
operator|*
name|SChildInfo
operator|->
name|Size
condition|)
block|{
name|SChildInfo
operator|->
name|Ancestor
operator|=
name|S
expr_stmt|;
name|SInfo
operator|->
name|Child
operator|=
name|SChild
operator|=
name|SChildChild
expr_stmt|;
name|SChildInfo
operator|=
operator|&
name|DT
operator|.
name|Info
index|[
name|SChild
index|]
expr_stmt|;
block|}
end_expr_stmt

begin_else
else|else
block|{
name|SChildInfo
operator|->
name|Size
operator|=
name|SInfo
operator|->
name|Size
expr_stmt|;
name|S
operator|=
name|SInfo
operator|->
name|Ancestor
operator|=
name|SChild
expr_stmt|;
name|SInfo
operator|=
name|SChildInfo
expr_stmt|;
name|SChild
operator|=
name|SChildChild
expr_stmt|;
name|SChildInfo
operator|=
operator|&
name|DT
operator|.
name|Info
index|[
name|SChild
index|]
expr_stmt|;
block|}
end_else

begin_expr_stmt
unit|}    DominatorTreeBase
operator|::
name|InfoRec
operator|&
name|VInfo
operator|=
name|DT
operator|.
name|Info
index|[
name|V
index|]
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SInfo
operator|->
name|Label
operator|=
name|WLabel
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|assert
argument_list|(
name|V
operator|!=
name|W
operator|&&
literal|"The optimization here will not work in this case!"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|unsigned
name|WSize
init|=
name|WInfo
operator|.
name|Size
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|VSize
init|=
operator|(
name|VInfo
operator|.
name|Size
operator|+=
name|WSize
operator|)
decl_stmt|;
end_decl_stmt

begin_if
if|if
condition|(
name|VSize
operator|<
literal|2
operator|*
name|WSize
condition|)
name|std
operator|::
name|swap
argument_list|(
name|S
argument_list|,
name|VInfo
operator|.
name|Child
argument_list|)
expr_stmt|;
end_if

begin_while
while|while
condition|(
name|S
condition|)
block|{
name|SInfo
operator|=
operator|&
name|DT
operator|.
name|Info
index|[
name|S
index|]
expr_stmt|;
name|SInfo
operator|->
name|Ancestor
operator|=
name|V
expr_stmt|;
name|S
operator|=
name|SInfo
operator|->
name|Child
expr_stmt|;
block|}
end_while

begin_endif
endif|#
directive|endif
end_endif

begin_expr_stmt
unit|}  template
operator|<
name|class
name|FuncT
operator|,
name|class
name|NodeT
operator|>
name|void
name|Calculate
argument_list|(
argument|DominatorTreeBase<typename GraphTraits<NodeT>::NodeType>& DT
argument_list|,
argument|FuncT& F
argument_list|)
block|{
typedef|typedef
name|GraphTraits
operator|<
name|NodeT
operator|>
name|GraphT
expr_stmt|;
name|unsigned
name|N
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|bool
name|MultipleRoots
init|=
operator|(
name|DT
operator|.
name|Roots
operator|.
name|size
argument_list|()
operator|>
literal|1
operator|)
decl_stmt|;
end_decl_stmt

begin_if
if|if
condition|(
name|MultipleRoots
condition|)
block|{
name|typename
name|DominatorTreeBase
operator|<
name|typename
name|GraphT
operator|::
name|NodeType
operator|>
operator|::
name|InfoRec
operator|&
name|BBInfo
operator|=
name|DT
operator|.
name|Info
index|[
name|NULL
index|]
expr_stmt|;
name|BBInfo
operator|.
name|DFSNum
operator|=
name|BBInfo
operator|.
name|Semi
operator|=
operator|++
name|N
expr_stmt|;
name|BBInfo
operator|.
name|Label
operator|=
name|NULL
expr_stmt|;
name|DT
operator|.
name|Vertex
operator|.
name|push_back
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
comment|// Vertex[n] = V;
comment|//BBInfo[V].Ancestor = 0;   // Ancestor[n] = 0
comment|//BBInfo[V].Child = 0;      // Child[v] = 0
name|BBInfo
operator|.
name|Size
operator|=
literal|1
expr_stmt|;
comment|// Size[v] = 1
block|}
end_if

begin_comment
comment|// Step #1: Number blocks in depth-first order and initialize variables used
end_comment

begin_comment
comment|// in later stages of the algorithm.
end_comment

begin_for
for|for
control|(
name|unsigned
name|i
init|=
literal|0
init|,
name|e
init|=
name|static_cast
operator|<
name|unsigned
operator|>
operator|(
name|DT
operator|.
name|Roots
operator|.
name|size
argument_list|()
operator|)
init|;
name|i
operator|!=
name|e
condition|;
operator|++
name|i
control|)
name|N
operator|=
name|DFSPass
operator|<
name|GraphT
operator|>
operator|(
name|DT
operator|,
name|DT
operator|.
name|Roots
index|[
name|i
index|]
operator|,
name|N
operator|)
expr_stmt|;
end_for

begin_comment
comment|// it might be that some blocks did not get a DFS number (e.g., blocks of
end_comment

begin_comment
comment|// infinite loops). In these cases an artificial exit node is required.
end_comment

begin_expr_stmt
name|MultipleRoots
operator||=
operator|(
name|DT
operator|.
name|isPostDominator
argument_list|()
operator|&&
name|N
operator|!=
name|F
operator|.
name|size
argument_list|()
operator|)
expr_stmt|;
end_expr_stmt

begin_for
for|for
control|(
name|unsigned
name|i
init|=
name|N
init|;
name|i
operator|>=
literal|2
condition|;
operator|--
name|i
control|)
block|{
name|typename
name|GraphT
operator|::
name|NodeType
operator|*
name|W
operator|=
name|DT
operator|.
name|Vertex
index|[
name|i
index|]
expr_stmt|;
name|typename
name|DominatorTreeBase
operator|<
name|typename
name|GraphT
operator|::
name|NodeType
operator|>
operator|::
name|InfoRec
operator|&
name|WInfo
operator|=
name|DT
operator|.
name|Info
index|[
name|W
index|]
expr_stmt|;
comment|// Step #2: Calculate the semidominators of all vertices
comment|// initialize the semi dominator to point to the parent node
name|WInfo
operator|.
name|Semi
operator|=
name|WInfo
operator|.
name|Parent
expr_stmt|;
for|for
control|(
name|typename
name|GraphTraits
operator|<
name|Inverse
operator|<
name|NodeT
operator|>
expr|>
operator|::
name|ChildIteratorType
name|CI
operator|=
name|GraphTraits
operator|<
name|Inverse
operator|<
name|NodeT
operator|>
expr|>
operator|::
name|child_begin
argument_list|(
name|W
argument_list|)
operator|,
name|E
operator|=
name|GraphTraits
operator|<
name|Inverse
operator|<
name|NodeT
operator|>
expr|>
operator|::
name|child_end
argument_list|(
name|W
argument_list|)
init|;
name|CI
operator|!=
name|E
condition|;
operator|++
name|CI
control|)
if|if
condition|(
name|DT
operator|.
name|Info
operator|.
name|count
argument_list|(
operator|*
name|CI
argument_list|)
condition|)
block|{
comment|// Only if this predecessor is reachable!
name|unsigned
name|SemiU
init|=
name|DT
operator|.
name|Info
index|[
name|Eval
operator|<
name|GraphT
operator|>
operator|(
name|DT
expr|,
operator|*
name|CI
operator|)
index|]
operator|.
name|Semi
decl_stmt|;
if|if
condition|(
name|SemiU
operator|<
name|WInfo
operator|.
name|Semi
condition|)
name|WInfo
operator|.
name|Semi
operator|=
name|SemiU
expr_stmt|;
block|}
name|DT
operator|.
name|Info
index|[
name|DT
operator|.
name|Vertex
index|[
name|WInfo
operator|.
name|Semi
index|]
index|]
operator|.
name|Bucket
operator|.
name|push_back
argument_list|(
name|W
argument_list|)
expr_stmt|;
name|typename
name|GraphT
operator|::
name|NodeType
operator|*
name|WParent
operator|=
name|DT
operator|.
name|Vertex
index|[
name|WInfo
operator|.
name|Parent
index|]
expr_stmt|;
name|Link
operator|<
name|GraphT
operator|>
operator|(
name|DT
operator|,
name|WInfo
operator|.
name|Parent
operator|,
name|W
operator|,
name|WInfo
operator|)
expr_stmt|;
comment|// Step #3: Implicitly define the immediate dominator of vertices
name|std
operator|::
name|vector
operator|<
name|typename
name|GraphT
operator|::
name|NodeType
operator|*
operator|>
operator|&
name|WParentBucket
operator|=
name|DT
operator|.
name|Info
index|[
name|WParent
index|]
operator|.
name|Bucket
expr_stmt|;
while|while
condition|(
operator|!
name|WParentBucket
operator|.
name|empty
argument_list|()
condition|)
block|{
name|typename
name|GraphT
operator|::
name|NodeType
operator|*
name|V
operator|=
name|WParentBucket
operator|.
name|back
argument_list|()
expr_stmt|;
name|WParentBucket
operator|.
name|pop_back
argument_list|()
expr_stmt|;
name|typename
name|GraphT
operator|::
name|NodeType
operator|*
name|U
operator|=
name|Eval
operator|<
name|GraphT
operator|>
operator|(
name|DT
operator|,
name|V
operator|)
expr_stmt|;
name|DT
operator|.
name|IDoms
index|[
name|V
index|]
operator|=
name|DT
operator|.
name|Info
index|[
name|U
index|]
operator|.
name|Semi
operator|<
name|DT
operator|.
name|Info
index|[
name|V
index|]
operator|.
name|Semi
condition|?
name|U
else|:
name|WParent
expr_stmt|;
block|}
block|}
end_for

begin_comment
comment|// Step #4: Explicitly define the immediate dominator of each vertex
end_comment

begin_for
for|for
control|(
name|unsigned
name|i
init|=
literal|2
init|;
name|i
operator|<=
name|N
condition|;
operator|++
name|i
control|)
block|{
name|typename
name|GraphT
operator|::
name|NodeType
operator|*
name|W
operator|=
name|DT
operator|.
name|Vertex
index|[
name|i
index|]
expr_stmt|;
name|typename
name|GraphT
operator|::
name|NodeType
operator|*
operator|&
name|WIDom
operator|=
name|DT
operator|.
name|IDoms
index|[
name|W
index|]
expr_stmt|;
if|if
condition|(
name|WIDom
operator|!=
name|DT
operator|.
name|Vertex
index|[
name|DT
operator|.
name|Info
index|[
name|W
index|]
operator|.
name|Semi
index|]
condition|)
name|WIDom
operator|=
name|DT
operator|.
name|IDoms
index|[
name|WIDom
index|]
expr_stmt|;
block|}
end_for

begin_if
if|if
condition|(
name|DT
operator|.
name|Roots
operator|.
name|empty
argument_list|()
condition|)
return|return;
end_if

begin_comment
comment|// Add a node for the root.  This node might be the actual root, if there is
end_comment

begin_comment
comment|// one exit block, or it may be the virtual exit (denoted by (BasicBlock *)0)
end_comment

begin_comment
comment|// which postdominates all real exits if there are multiple exit blocks, or
end_comment

begin_comment
comment|// an infinite loop.
end_comment

begin_expr_stmt
name|typename
name|GraphT
operator|::
name|NodeType
operator|*
name|Root
operator|=
operator|!
name|MultipleRoots
condition|?
name|DT
operator|.
name|Roots
index|[
literal|0
index|]
else|:
literal|0
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|DT
operator|.
name|DomTreeNodes
index|[
name|Root
index|]
operator|=
name|DT
operator|.
name|RootNode
operator|=
name|new
name|DomTreeNodeBase
operator|<
name|typename
name|GraphT
operator|::
name|NodeType
operator|>
operator|(
name|Root
operator|,
literal|0
operator|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|// Loop over all of the reachable blocks in the function...
end_comment

begin_for
for|for
control|(
name|unsigned
name|i
init|=
literal|2
init|;
name|i
operator|<=
name|N
condition|;
operator|++
name|i
control|)
block|{
name|typename
name|GraphT
operator|::
name|NodeType
operator|*
name|W
operator|=
name|DT
operator|.
name|Vertex
index|[
name|i
index|]
expr_stmt|;
name|DomTreeNodeBase
operator|<
name|typename
name|GraphT
operator|::
name|NodeType
operator|>
operator|*
name|BBNode
operator|=
name|DT
operator|.
name|DomTreeNodes
index|[
name|W
index|]
expr_stmt|;
if|if
condition|(
name|BBNode
condition|)
continue|continue;
comment|// Haven't calculated this node yet?
name|typename
name|GraphT
operator|::
name|NodeType
operator|*
name|ImmDom
operator|=
name|DT
operator|.
name|getIDom
argument_list|(
name|W
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|ImmDom
operator|||
name|DT
operator|.
name|DomTreeNodes
index|[
name|NULL
index|]
argument_list|)
expr_stmt|;
comment|// Get or calculate the node for the immediate dominator
name|DomTreeNodeBase
operator|<
name|typename
name|GraphT
operator|::
name|NodeType
operator|>
operator|*
name|IDomNode
operator|=
name|DT
operator|.
name|getNodeForBlock
argument_list|(
name|ImmDom
argument_list|)
expr_stmt|;
comment|// Add a new tree node for this BasicBlock, and link it as a child of
comment|// IDomNode
name|DomTreeNodeBase
operator|<
name|typename
name|GraphT
operator|::
name|NodeType
operator|>
operator|*
name|C
operator|=
name|new
name|DomTreeNodeBase
operator|<
name|typename
name|GraphT
operator|::
name|NodeType
operator|>
operator|(
name|W
operator|,
name|IDomNode
operator|)
expr_stmt|;
name|DT
operator|.
name|DomTreeNodes
index|[
name|W
index|]
operator|=
name|IDomNode
operator|->
name|addChild
argument_list|(
name|C
argument_list|)
expr_stmt|;
block|}
end_for

begin_comment
comment|// Free temporary memory used to construct idom's
end_comment

begin_expr_stmt
name|DT
operator|.
name|IDoms
operator|.
name|clear
argument_list|()
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|DT
operator|.
name|Info
operator|.
name|clear
argument_list|()
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|std
operator|::
name|vector
operator|<
name|typename
name|GraphT
operator|::
name|NodeType
operator|*
operator|>
operator|(
operator|)
operator|.
name|swap
argument_list|(
name|DT
operator|.
name|Vertex
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|DT
operator|.
name|updateDFSNumbers
argument_list|()
expr_stmt|;
end_expr_stmt

begin_endif
unit|}  }
endif|#
directive|endif
end_endif

end_unit

