begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//==- llvm/Analysis/ConstantsScanner.h - Iterate over constants -*- C++ -*-===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This class implements an iterator to walk through the constants referenced by
end_comment

begin_comment
comment|// a method.  This is used by the Bitcode& Assembly writers to build constant
end_comment

begin_comment
comment|// pools.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LLVM_ANALYSIS_CONSTANTSSCANNER_H
end_ifndef

begin_define
define|#
directive|define
name|LLVM_ANALYSIS_CONSTANTSSCANNER_H
end_define

begin_include
include|#
directive|include
file|"llvm/IR/InstIterator.h"
end_include

begin_decl_stmt
name|namespace
name|llvm
block|{
name|class
name|Constant
decl_stmt|;
name|class
name|constant_iterator
range|:
name|public
name|std
operator|::
name|iterator
operator|<
name|std
operator|::
name|forward_iterator_tag
decl_stmt|,                                                const
name|Constant
decl_stmt|,
name|ptrdiff_t
decl|>
block|{
name|const_inst_iterator
name|InstI
decl_stmt|;
comment|// Method instruction iterator
name|unsigned
name|OpIdx
decl_stmt|;
comment|// Operand index
typedef|typedef
name|constant_iterator
name|_Self
typedef|;
specifier|inline
name|bool
name|isAtConstant
argument_list|()
specifier|const
block|{
name|assert
argument_list|(
operator|!
name|InstI
operator|.
name|atEnd
argument_list|()
operator|&&
name|OpIdx
operator|<
name|InstI
operator|->
name|getNumOperands
argument_list|()
operator|&&
literal|"isAtConstant called with invalid arguments!"
argument_list|)
block|;
return|return
name|isa
operator|<
name|Constant
operator|>
operator|(
name|InstI
operator|->
name|getOperand
argument_list|(
name|OpIdx
argument_list|)
operator|)
return|;
block|}
name|public
label|:
specifier|inline
name|constant_iterator
argument_list|(
specifier|const
name|Function
operator|*
name|F
argument_list|)
operator|:
name|InstI
argument_list|(
name|inst_begin
argument_list|(
name|F
argument_list|)
argument_list|)
operator|,
name|OpIdx
argument_list|(
literal|0
argument_list|)
block|{
comment|// Advance to first constant... if we are not already at constant or end
if|if
condition|(
name|InstI
operator|!=
name|inst_end
argument_list|(
name|F
argument_list|)
operator|&&
comment|// InstI is valid?
operator|(
name|InstI
operator|->
name|getNumOperands
argument_list|()
operator|==
literal|0
operator|||
operator|!
name|isAtConstant
argument_list|()
operator|)
condition|)
comment|// Not at constant?
name|operator
operator|++
operator|(
operator|)
expr_stmt|;
block|}
specifier|inline
name|constant_iterator
argument_list|(
specifier|const
name|Function
operator|*
name|F
argument_list|,
name|bool
argument_list|)
comment|// end ctor
operator|:
name|InstI
argument_list|(
name|inst_end
argument_list|(
name|F
argument_list|)
argument_list|)
operator|,
name|OpIdx
argument_list|(
literal|0
argument_list|)
block|{   }
specifier|inline
name|bool
name|operator
operator|==
operator|(
specifier|const
name|_Self
operator|&
name|x
operator|)
specifier|const
block|{
return|return
name|OpIdx
operator|==
name|x
operator|.
name|OpIdx
operator|&&
name|InstI
operator|==
name|x
operator|.
name|InstI
return|;
block|}
specifier|inline
name|bool
name|operator
operator|!=
operator|(
specifier|const
name|_Self
operator|&
name|x
operator|)
specifier|const
block|{
return|return
operator|!
name|operator
operator|==
operator|(
name|x
operator|)
return|;
block|}
specifier|inline
name|pointer
name|operator
operator|*
operator|(
operator|)
specifier|const
block|{
name|assert
argument_list|(
name|isAtConstant
argument_list|()
operator|&&
literal|"Dereferenced an iterator at the end!"
argument_list|)
block|;
return|return
name|cast
operator|<
name|Constant
operator|>
operator|(
name|InstI
operator|->
name|getOperand
argument_list|(
name|OpIdx
argument_list|)
operator|)
return|;
block|}
specifier|inline
name|pointer
name|operator
operator|->
expr|(
block|)
decl|const
block|{
return|return
name|operator
operator|*
operator|(
operator|)
return|;
block|}
specifier|inline
name|_Self
operator|&
name|operator
operator|++
operator|(
operator|)
block|{
comment|// Preincrement implementation
operator|++
name|OpIdx
block|;
do|do
block|{
name|unsigned
name|NumOperands
init|=
name|InstI
operator|->
name|getNumOperands
argument_list|()
decl_stmt|;
while|while
condition|(
name|OpIdx
operator|<
name|NumOperands
operator|&&
operator|!
name|isAtConstant
argument_list|()
condition|)
block|{
operator|++
name|OpIdx
expr_stmt|;
block|}
if|if
condition|(
name|OpIdx
operator|<
name|NumOperands
condition|)
return|return
operator|*
name|this
return|;
comment|// Found a constant!
operator|++
name|InstI
expr_stmt|;
name|OpIdx
operator|=
literal|0
expr_stmt|;
block|}
while|while
condition|(
operator|!
name|InstI
operator|.
name|atEnd
argument_list|()
condition|)
empty_stmt|;
do|return *this;
comment|// At the end of the method
do|}
specifier|inline
namespace|_Self
name|operator
namespace|++(
name|int
block|)
block|{
comment|// Postincrement
name|_Self
name|tmp
operator|=
operator|*
name|this
block|;
operator|++
operator|*
name|this
block|;
return|return
name|tmp
return|;
block|}
specifier|inline
name|bool
name|atEnd
argument_list|()
specifier|const
block|{
return|return
name|InstI
operator|.
name|atEnd
argument_list|()
return|;
block|}
block|}
empty_stmt|;
specifier|inline
name|constant_iterator
name|constant_begin
parameter_list|(
specifier|const
name|Function
modifier|*
name|F
parameter_list|)
block|{
return|return
name|constant_iterator
argument_list|(
name|F
argument_list|)
return|;
block|}
specifier|inline
name|constant_iterator
name|constant_end
parameter_list|(
specifier|const
name|Function
modifier|*
name|F
parameter_list|)
block|{
return|return
name|constant_iterator
argument_list|(
name|F
argument_list|,
name|true
argument_list|)
return|;
block|}
block|}
end_decl_stmt

begin_comment
comment|// End llvm namespace
end_comment

begin_endif
endif|#
directive|endif
end_endif

end_unit

