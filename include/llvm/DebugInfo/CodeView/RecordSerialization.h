begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===- RecordSerialization.h ------------------------------------*- C++ -*-===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LLVM_DEBUGINFO_CODEVIEW_RECORDSERIALIZATION_H
end_ifndef

begin_define
define|#
directive|define
name|LLVM_DEBUGINFO_CODEVIEW_RECORDSERIALIZATION_H
end_define

begin_include
include|#
directive|include
file|"llvm/ADT/APSInt.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/ArrayRef.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/StringRef.h"
end_include

begin_include
include|#
directive|include
file|"llvm/DebugInfo/CodeView/CodeView.h"
end_include

begin_include
include|#
directive|include
file|"llvm/DebugInfo/CodeView/CodeViewError.h"
end_include

begin_include
include|#
directive|include
file|"llvm/DebugInfo/MSF/StreamReader.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/Endian.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/Error.h"
end_include

begin_include
include|#
directive|include
file|<cinttypes>
end_include

begin_include
include|#
directive|include
file|<tuple>
end_include

begin_decl_stmt
name|namespace
name|llvm
block|{
name|namespace
name|codeview
block|{
name|using
name|llvm
operator|::
name|support
operator|::
name|little32_t
expr_stmt|;
name|using
name|llvm
operator|::
name|support
operator|::
name|ulittle16_t
expr_stmt|;
name|using
name|llvm
operator|::
name|support
operator|::
name|ulittle32_t
expr_stmt|;
comment|/// Limit on the size of all codeview symbol and type records, including the
comment|/// RecordPrefix. MSVC does not emit any records larger than this.
enum_decl|enum :
name|unsigned
block|{
name|MaxRecordLength
init|=
literal|0xFF00
block|}
enum_decl|;
struct|struct
name|RecordPrefix
block|{
name|ulittle16_t
name|RecordLen
decl_stmt|;
comment|// Record length, starting from&RecordKind.
name|ulittle16_t
name|RecordKind
decl_stmt|;
comment|// Record kind enum (SymRecordKind or TypeRecordKind)
block|}
struct|;
comment|/// Reinterpret a byte array as an array of characters. Does not interpret as
comment|/// a C string, as StringRef has several helpers (split) that make that easy.
name|StringRef
name|getBytesAsCharacters
argument_list|(
name|ArrayRef
operator|<
name|uint8_t
operator|>
name|LeafData
argument_list|)
decl_stmt|;
name|StringRef
name|getBytesAsCString
argument_list|(
name|ArrayRef
operator|<
name|uint8_t
operator|>
name|LeafData
argument_list|)
decl_stmt|;
specifier|inline
name|Error
name|consume
argument_list|(
name|msf
operator|::
name|StreamReader
operator|&
name|Reader
argument_list|)
block|{
return|return
name|Error
operator|::
name|success
argument_list|()
return|;
block|}
comment|/// Decodes a numeric "leaf" value. These are integer literals encountered in
comment|/// the type stream. If the value is positive and less than LF_NUMERIC (1<<
comment|/// 15), it is emitted directly in Data. Otherwise, it has a tag like LF_CHAR
comment|/// that indicates the bitwidth and sign of the numeric data.
name|Error
name|consume
argument_list|(
name|msf
operator|::
name|StreamReader
operator|&
name|Reader
argument_list|,
name|APSInt
operator|&
name|Num
argument_list|)
decl_stmt|;
comment|/// Decodes a numeric leaf value that is known to be a particular type.
name|Error
name|consume_numeric
argument_list|(
name|msf
operator|::
name|StreamReader
operator|&
name|Reader
argument_list|,
name|uint64_t
operator|&
name|Value
argument_list|)
decl_stmt|;
comment|/// Decodes signed and unsigned fixed-length integers.
name|Error
name|consume
argument_list|(
name|msf
operator|::
name|StreamReader
operator|&
name|Reader
argument_list|,
name|uint32_t
operator|&
name|Item
argument_list|)
decl_stmt|;
name|Error
name|consume
argument_list|(
name|msf
operator|::
name|StreamReader
operator|&
name|Reader
argument_list|,
name|int32_t
operator|&
name|Item
argument_list|)
decl_stmt|;
comment|/// Decodes a null terminated string.
name|Error
name|consume
argument_list|(
name|msf
operator|::
name|StreamReader
operator|&
name|Reader
argument_list|,
name|StringRef
operator|&
name|Item
argument_list|)
decl_stmt|;
name|Error
name|consume
parameter_list|(
name|StringRef
modifier|&
name|Data
parameter_list|,
name|APSInt
modifier|&
name|Num
parameter_list|)
function_decl|;
name|Error
name|consume
parameter_list|(
name|StringRef
modifier|&
name|Data
parameter_list|,
name|uint32_t
modifier|&
name|Item
parameter_list|)
function_decl|;
comment|/// Decodes an arbitrary object whose layout matches that of the underlying
comment|/// byte sequence, and returns a pointer to the object.
name|template
operator|<
name|typename
name|T
operator|>
name|Error
name|consume
argument_list|(
argument|msf::StreamReader&Reader
argument_list|,
argument|T *&Item
argument_list|)
block|{
return|return
name|Reader
operator|.
name|readObject
argument_list|(
name|Item
argument_list|)
return|;
block|}
name|template
operator|<
name|typename
name|T
operator|,
name|typename
name|U
operator|>
expr|struct
name|serialize_conditional_impl
block|{
name|serialize_conditional_impl
argument_list|(
argument|T&Item
argument_list|,
argument|U Func
argument_list|)
operator|:
name|Item
argument_list|(
name|Item
argument_list|)
block|,
name|Func
argument_list|(
argument|Func
argument_list|)
block|{}
name|Error
name|deserialize
argument_list|(
argument|msf::StreamReader&Reader
argument_list|)
specifier|const
block|{
if|if
condition|(
operator|!
name|Func
argument_list|()
condition|)
return|return
name|Error
operator|::
name|success
argument_list|()
return|;
return|return
name|consume
argument_list|(
name|Reader
argument_list|,
name|Item
argument_list|)
return|;
block|}
name|T
modifier|&
name|Item
decl_stmt|;
name|U
name|Func
decl_stmt|;
block|}
empty_stmt|;
name|template
operator|<
name|typename
name|T
operator|,
name|typename
name|U
operator|>
name|serialize_conditional_impl
operator|<
name|T
operator|,
name|U
operator|>
name|serialize_conditional
argument_list|(
argument|T&Item
argument_list|,
argument|U Func
argument_list|)
block|{
return|return
name|serialize_conditional_impl
operator|<
name|T
operator|,
name|U
operator|>
operator|(
name|Item
operator|,
name|Func
operator|)
return|;
block|}
name|template
operator|<
name|typename
name|T
operator|,
name|typename
name|U
operator|>
expr|struct
name|serialize_array_impl
block|{
name|serialize_array_impl
argument_list|(
argument|ArrayRef<T>&Item
argument_list|,
argument|U Func
argument_list|)
operator|:
name|Item
argument_list|(
name|Item
argument_list|)
block|,
name|Func
argument_list|(
argument|Func
argument_list|)
block|{}
name|Error
name|deserialize
argument_list|(
argument|msf::StreamReader&Reader
argument_list|)
specifier|const
block|{
return|return
name|Reader
operator|.
name|readArray
argument_list|(
name|Item
argument_list|,
name|Func
argument_list|()
argument_list|)
return|;
block|}
name|ArrayRef
operator|<
name|T
operator|>
operator|&
name|Item
block|;
name|U
name|Func
block|; }
expr_stmt|;
name|template
operator|<
name|typename
name|T
operator|>
expr|struct
name|serialize_vector_tail_impl
block|{
name|serialize_vector_tail_impl
argument_list|(
name|std
operator|::
name|vector
operator|<
name|T
operator|>
operator|&
name|Item
argument_list|)
operator|:
name|Item
argument_list|(
argument|Item
argument_list|)
block|{}
name|Error
name|deserialize
argument_list|(
argument|msf::StreamReader&Reader
argument_list|)
specifier|const
block|{
name|T
name|Field
block|;
comment|// Stop when we run out of bytes or we hit record padding bytes.
while|while
condition|(
operator|!
name|Reader
operator|.
name|empty
argument_list|()
operator|&&
name|Reader
operator|.
name|peek
argument_list|()
operator|<
name|LF_PAD0
condition|)
block|{
if|if
condition|(
name|auto
name|EC
init|=
name|consume
argument_list|(
name|Reader
argument_list|,
name|Field
argument_list|)
condition|)
return|return
name|EC
return|;
name|Item
operator|.
name|push_back
argument_list|(
name|Field
argument_list|)
expr_stmt|;
block|}
return|return
name|Error
operator|::
name|success
argument_list|()
return|;
block|}
name|std
operator|::
name|vector
operator|<
name|T
operator|>
operator|&
name|Item
block|; }
expr_stmt|;
struct|struct
name|serialize_null_term_string_array_impl
block|{
name|serialize_null_term_string_array_impl
argument_list|(
name|std
operator|::
name|vector
operator|<
name|StringRef
operator|>
operator|&
name|Item
argument_list|)
operator|:
name|Item
argument_list|(
argument|Item
argument_list|)
block|{}
name|Error
name|deserialize
argument_list|(
argument|msf::StreamReader&Reader
argument_list|)
specifier|const
block|{
if|if
condition|(
name|Reader
operator|.
name|empty
argument_list|()
condition|)
return|return
name|make_error
operator|<
name|CodeViewError
operator|>
operator|(
name|cv_error_code
operator|::
name|insufficient_buffer
operator|,
literal|"Null terminated string is empty!"
operator|)
return|;
while|while
condition|(
name|Reader
operator|.
name|peek
argument_list|()
operator|!=
literal|0
condition|)
block|{
name|StringRef
name|Field
decl_stmt|;
if|if
condition|(
name|auto
name|EC
init|=
name|Reader
operator|.
name|readZeroString
argument_list|(
name|Field
argument_list|)
condition|)
return|return
name|EC
return|;
name|Item
operator|.
name|push_back
argument_list|(
name|Field
argument_list|)
expr_stmt|;
block|}
return|return
name|Reader
operator|.
name|skip
argument_list|(
literal|1
argument_list|)
return|;
block|}
name|std
decl|::
name|vector
decl|<
name|StringRef
decl|>
modifier|&
name|Item
struct|;
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|T
operator|>
expr|struct
name|serialize_arrayref_tail_impl
block|{
name|serialize_arrayref_tail_impl
argument_list|(
name|ArrayRef
operator|<
name|T
operator|>
operator|&
name|Item
argument_list|)
operator|:
name|Item
argument_list|(
argument|Item
argument_list|)
block|{}
name|Error
name|deserialize
argument_list|(
argument|msf::StreamReader&Reader
argument_list|)
specifier|const
block|{
name|uint32_t
name|Count
operator|=
name|Reader
operator|.
name|bytesRemaining
argument_list|()
operator|/
sizeof|sizeof
argument_list|(
name|T
argument_list|)
block|;
return|return
name|Reader
operator|.
name|readArray
argument_list|(
name|Item
argument_list|,
name|Count
argument_list|)
return|;
block|}
name|ArrayRef
operator|<
name|T
operator|>
operator|&
name|Item
expr_stmt|;
end_expr_stmt

begin_expr_stmt
unit|};
name|template
operator|<
name|typename
name|T
operator|>
expr|struct
name|serialize_numeric_impl
block|{
name|serialize_numeric_impl
argument_list|(
name|T
operator|&
name|Item
argument_list|)
operator|:
name|Item
argument_list|(
argument|Item
argument_list|)
block|{}
name|Error
name|deserialize
argument_list|(
argument|msf::StreamReader&Reader
argument_list|)
specifier|const
block|{
return|return
name|consume_numeric
argument_list|(
name|Reader
argument_list|,
name|Item
argument_list|)
return|;
block|}
name|T
operator|&
name|Item
expr_stmt|;
end_expr_stmt

begin_expr_stmt
unit|};
name|template
operator|<
name|typename
name|T
operator|,
name|typename
name|U
operator|>
name|serialize_array_impl
operator|<
name|T
operator|,
name|U
operator|>
name|serialize_array
argument_list|(
argument|ArrayRef<T>&Item
argument_list|,
argument|U Func
argument_list|)
block|{
return|return
name|serialize_array_impl
operator|<
name|T
operator|,
name|U
operator|>
operator|(
name|Item
operator|,
name|Func
operator|)
return|;
block|}
end_expr_stmt

begin_decl_stmt
specifier|inline
name|serialize_null_term_string_array_impl
name|serialize_null_term_string_array
argument_list|(
name|std
operator|::
name|vector
operator|<
name|StringRef
operator|>
operator|&
name|Item
argument_list|)
block|{
return|return
name|serialize_null_term_string_array_impl
argument_list|(
name|Item
argument_list|)
return|;
block|}
end_decl_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|T
operator|>
name|serialize_vector_tail_impl
operator|<
name|T
operator|>
name|serialize_array_tail
argument_list|(
argument|std::vector<T>&Item
argument_list|)
block|{
return|return
name|serialize_vector_tail_impl
operator|<
name|T
operator|>
operator|(
name|Item
operator|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|T
operator|>
name|serialize_arrayref_tail_impl
operator|<
name|T
operator|>
name|serialize_array_tail
argument_list|(
argument|ArrayRef<T>&Item
argument_list|)
block|{
return|return
name|serialize_arrayref_tail_impl
operator|<
name|T
operator|>
operator|(
name|Item
operator|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|T
operator|>
name|serialize_numeric_impl
operator|<
name|T
operator|>
name|serialize_numeric
argument_list|(
argument|T&Item
argument_list|)
block|{
return|return
name|serialize_numeric_impl
operator|<
name|T
operator|>
operator|(
name|Item
operator|)
return|;
block|}
end_expr_stmt

begin_comment
comment|// This field is only present in the byte record if the condition is true.  The
end_comment

begin_comment
comment|// condition is evaluated lazily, so it can depend on items that were
end_comment

begin_comment
comment|// deserialized
end_comment

begin_comment
comment|// earlier.
end_comment

begin_define
define|#
directive|define
name|CV_CONDITIONAL_FIELD
parameter_list|(
name|I
parameter_list|,
name|C
parameter_list|)
define|\
value|serialize_conditional(I, [&]() { return !!(C); })
end_define

begin_comment
comment|// This is an array of N items, where N is evaluated lazily, so it can refer
end_comment

begin_comment
comment|// to a field deserialized earlier.
end_comment

begin_define
define|#
directive|define
name|CV_ARRAY_FIELD_N
parameter_list|(
name|I
parameter_list|,
name|N
parameter_list|)
value|serialize_array(I, [&]() { return N; })
end_define

begin_comment
comment|// This is an array that exhausts the remainder of the input buffer.
end_comment

begin_define
define|#
directive|define
name|CV_ARRAY_FIELD_TAIL
parameter_list|(
name|I
parameter_list|)
value|serialize_array_tail(I)
end_define

begin_comment
comment|// This is an array that consumes null terminated strings until a double null
end_comment

begin_comment
comment|// is encountered.
end_comment

begin_define
define|#
directive|define
name|CV_STRING_ARRAY_NULL_TERM
parameter_list|(
name|I
parameter_list|)
value|serialize_null_term_string_array(I)
end_define

begin_define
define|#
directive|define
name|CV_NUMERIC_FIELD
parameter_list|(
name|I
parameter_list|)
value|serialize_numeric(I)
end_define

begin_expr_stmt
name|template
operator|<
name|typename
name|T
operator|,
name|typename
name|U
operator|>
name|Error
name|consume
argument_list|(
argument|msf::StreamReader&Reader
argument_list|,
argument|const serialize_conditional_impl<T
argument_list|,
argument|U>&Item
argument_list|)
block|{
return|return
name|Item
operator|.
name|deserialize
argument_list|(
name|Reader
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|T
operator|,
name|typename
name|U
operator|>
name|Error
name|consume
argument_list|(
argument|msf::StreamReader&Reader
argument_list|,
argument|const serialize_array_impl<T
argument_list|,
argument|U>&Item
argument_list|)
block|{
return|return
name|Item
operator|.
name|deserialize
argument_list|(
name|Reader
argument_list|)
return|;
block|}
end_expr_stmt

begin_decl_stmt
specifier|inline
name|Error
name|consume
argument_list|(
name|msf
operator|::
name|StreamReader
operator|&
name|Reader
argument_list|,
specifier|const
name|serialize_null_term_string_array_impl
operator|&
name|Item
argument_list|)
block|{
return|return
name|Item
operator|.
name|deserialize
argument_list|(
name|Reader
argument_list|)
return|;
block|}
end_decl_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|T
operator|>
name|Error
name|consume
argument_list|(
argument|msf::StreamReader&Reader
argument_list|,
argument|const serialize_vector_tail_impl<T>&Item
argument_list|)
block|{
return|return
name|Item
operator|.
name|deserialize
argument_list|(
name|Reader
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|T
operator|>
name|Error
name|consume
argument_list|(
argument|msf::StreamReader&Reader
argument_list|,
argument|const serialize_arrayref_tail_impl<T>&Item
argument_list|)
block|{
return|return
name|Item
operator|.
name|deserialize
argument_list|(
name|Reader
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|T
operator|>
name|Error
name|consume
argument_list|(
argument|msf::StreamReader&Reader
argument_list|,
argument|const serialize_numeric_impl<T>&Item
argument_list|)
block|{
return|return
name|Item
operator|.
name|deserialize
argument_list|(
name|Reader
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|T
operator|,
name|typename
name|U
operator|,
name|typename
operator|...
name|Args
operator|>
name|Error
name|consume
argument_list|(
argument|msf::StreamReader&Reader
argument_list|,
argument|T&&X
argument_list|,
argument|U&&Y
argument_list|,
argument|Args&&... Rest
argument_list|)
block|{
if|if
condition|(
name|auto
name|EC
init|=
name|consume
argument_list|(
name|Reader
argument_list|,
name|X
argument_list|)
condition|)
return|return
name|EC
return|;
end_expr_stmt

begin_return
return|return
name|consume
argument_list|(
name|Reader
argument_list|,
name|Y
argument_list|,
name|std
operator|::
name|forward
operator|<
name|Args
operator|>
operator|(
name|Rest
operator|)
operator|...
argument_list|)
return|;
end_return

begin_define
unit|}
define|#
directive|define
name|CV_DESERIALIZE
parameter_list|(
modifier|...
parameter_list|)
define|\
value|if (auto EC = consume(__VA_ARGS__))                                          \     return std::move(EC);
end_define

begin_endif
unit|} }
endif|#
directive|endif
end_endif

end_unit

