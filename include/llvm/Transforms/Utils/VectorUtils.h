begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===- llvm/Transforms/Utils/VectorUtils.h - Vector utilities -*- C++ -*-=====//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file defines some vectorizer utilities.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LLVM_TRANSFORMS_UTILS_VECTORUTILS_H
end_ifndef

begin_define
define|#
directive|define
name|LLVM_TRANSFORMS_UTILS_VECTORUTILS_H
end_define

begin_include
include|#
directive|include
file|"llvm/IR/Intrinsics.h"
end_include

begin_include
include|#
directive|include
file|"llvm/IR/IntrinsicInst.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Target/TargetLibraryInfo.h"
end_include

begin_decl_stmt
name|namespace
name|llvm
block|{
comment|/// \brief Identify if the intrinsic is trivially vectorizable.
comment|///
comment|/// This method returns true if the intrinsic's argument types are all
comment|/// scalars for the scalar form of the intrinsic and all vectors for
comment|/// the vector form of the intrinsic.
specifier|static
specifier|inline
name|bool
name|isTriviallyVectorizable
argument_list|(
name|Intrinsic
operator|::
name|ID
name|ID
argument_list|)
block|{
switch|switch
condition|(
name|ID
condition|)
block|{
case|case
name|Intrinsic
operator|::
name|sqrt
case|:
case|case
name|Intrinsic
operator|::
name|sin
case|:
case|case
name|Intrinsic
operator|::
name|cos
case|:
case|case
name|Intrinsic
operator|::
name|exp
case|:
case|case
name|Intrinsic
operator|::
name|exp2
case|:
case|case
name|Intrinsic
operator|::
name|log
case|:
case|case
name|Intrinsic
operator|::
name|log10
case|:
case|case
name|Intrinsic
operator|::
name|log2
case|:
case|case
name|Intrinsic
operator|::
name|fabs
case|:
case|case
name|Intrinsic
operator|::
name|copysign
case|:
case|case
name|Intrinsic
operator|::
name|floor
case|:
case|case
name|Intrinsic
operator|::
name|ceil
case|:
case|case
name|Intrinsic
operator|::
name|trunc
case|:
case|case
name|Intrinsic
operator|::
name|rint
case|:
case|case
name|Intrinsic
operator|::
name|nearbyint
case|:
case|case
name|Intrinsic
operator|::
name|round
case|:
case|case
name|Intrinsic
operator|::
name|bswap
case|:
case|case
name|Intrinsic
operator|::
name|ctpop
case|:
case|case
name|Intrinsic
operator|::
name|pow
case|:
case|case
name|Intrinsic
operator|::
name|fma
case|:
case|case
name|Intrinsic
operator|::
name|fmuladd
case|:
case|case
name|Intrinsic
operator|::
name|ctlz
case|:
case|case
name|Intrinsic
operator|::
name|cttz
case|:
case|case
name|Intrinsic
operator|::
name|powi
case|:
return|return
name|true
return|;
default|default:
return|return
name|false
return|;
block|}
block|}
specifier|static
name|bool
name|hasVectorInstrinsicScalarOpd
argument_list|(
name|Intrinsic
operator|::
name|ID
name|ID
argument_list|,
name|unsigned
name|ScalarOpdIdx
argument_list|)
block|{
switch|switch
condition|(
name|ID
condition|)
block|{
case|case
name|Intrinsic
operator|::
name|ctlz
case|:
case|case
name|Intrinsic
operator|::
name|cttz
case|:
case|case
name|Intrinsic
operator|::
name|powi
case|:
return|return
operator|(
name|ScalarOpdIdx
operator|==
literal|1
operator|)
return|;
default|default:
return|return
name|false
return|;
block|}
block|}
specifier|static
name|Intrinsic
operator|::
name|ID
name|checkUnaryFloatSignature
argument_list|(
argument|const CallInst&I
argument_list|,
argument|Intrinsic::ID ValidIntrinsicID
argument_list|)
block|{
if|if
condition|(
name|I
operator|.
name|getNumArgOperands
argument_list|()
operator|!=
literal|1
operator|||
operator|!
name|I
operator|.
name|getArgOperand
argument_list|(
literal|0
argument_list|)
operator|->
name|getType
argument_list|()
operator|->
name|isFloatingPointTy
argument_list|()
operator|||
name|I
operator|.
name|getType
argument_list|()
operator|!=
name|I
operator|.
name|getArgOperand
argument_list|(
literal|0
argument_list|)
operator|->
name|getType
argument_list|()
operator|||
operator|!
name|I
operator|.
name|onlyReadsMemory
argument_list|()
condition|)
return|return
name|Intrinsic
operator|::
name|not_intrinsic
return|;
return|return
name|ValidIntrinsicID
return|;
block|}
end_decl_stmt

begin_expr_stmt
specifier|static
name|Intrinsic
operator|::
name|ID
name|checkBinaryFloatSignature
argument_list|(
argument|const CallInst&I
argument_list|,
argument|Intrinsic::ID ValidIntrinsicID
argument_list|)
block|{
if|if
condition|(
name|I
operator|.
name|getNumArgOperands
argument_list|()
operator|!=
literal|2
operator|||
operator|!
name|I
operator|.
name|getArgOperand
argument_list|(
literal|0
argument_list|)
operator|->
name|getType
argument_list|()
operator|->
name|isFloatingPointTy
argument_list|()
operator|||
operator|!
name|I
operator|.
name|getArgOperand
argument_list|(
literal|1
argument_list|)
operator|->
name|getType
argument_list|()
operator|->
name|isFloatingPointTy
argument_list|()
operator|||
name|I
operator|.
name|getType
argument_list|()
operator|!=
name|I
operator|.
name|getArgOperand
argument_list|(
literal|0
argument_list|)
operator|->
name|getType
argument_list|()
operator|||
name|I
operator|.
name|getType
argument_list|()
operator|!=
name|I
operator|.
name|getArgOperand
argument_list|(
literal|1
argument_list|)
operator|->
name|getType
argument_list|()
operator|||
operator|!
name|I
operator|.
name|onlyReadsMemory
argument_list|()
condition|)
return|return
name|Intrinsic
operator|::
name|not_intrinsic
return|;
end_expr_stmt

begin_return
return|return
name|ValidIntrinsicID
return|;
end_return

begin_expr_stmt
unit|}  static
name|Intrinsic
operator|::
name|ID
name|getIntrinsicIDForCall
argument_list|(
argument|CallInst *CI
argument_list|,
argument|const TargetLibraryInfo *TLI
argument_list|)
block|{
comment|// If we have an intrinsic call, check if it is trivially vectorizable.
if|if
condition|(
name|IntrinsicInst
modifier|*
name|II
init|=
name|dyn_cast
operator|<
name|IntrinsicInst
operator|>
operator|(
name|CI
operator|)
condition|)
block|{
name|Intrinsic
operator|::
name|ID
name|ID
operator|=
name|II
operator|->
name|getIntrinsicID
argument_list|()
expr_stmt|;
if|if
condition|(
name|isTriviallyVectorizable
argument_list|(
name|ID
argument_list|)
operator|||
name|ID
operator|==
name|Intrinsic
operator|::
name|lifetime_start
operator|||
name|ID
operator|==
name|Intrinsic
operator|::
name|lifetime_end
condition|)
return|return
name|ID
return|;
else|else
return|return
name|Intrinsic
operator|::
name|not_intrinsic
return|;
block|}
end_expr_stmt

begin_if
if|if
condition|(
operator|!
name|TLI
condition|)
return|return
name|Intrinsic
operator|::
name|not_intrinsic
return|;
end_if

begin_expr_stmt
name|LibFunc
operator|::
name|Func
name|Func
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|Function
modifier|*
name|F
init|=
name|CI
operator|->
name|getCalledFunction
argument_list|()
decl_stmt|;
end_decl_stmt

begin_comment
comment|// We're going to make assumptions on the semantics of the functions, check
end_comment

begin_comment
comment|// that the target knows that it's available in this environment and it does
end_comment

begin_comment
comment|// not have local linkage.
end_comment

begin_if
if|if
condition|(
operator|!
name|F
operator|||
name|F
operator|->
name|hasLocalLinkage
argument_list|()
operator|||
operator|!
name|TLI
operator|->
name|getLibFunc
argument_list|(
name|F
operator|->
name|getName
argument_list|()
argument_list|,
name|Func
argument_list|)
condition|)
return|return
name|Intrinsic
operator|::
name|not_intrinsic
return|;
end_if

begin_comment
comment|// Otherwise check if we have a call to a function that can be turned into a
end_comment

begin_comment
comment|// vector intrinsic.
end_comment

begin_switch
switch|switch
condition|(
name|Func
condition|)
block|{
default|default:
break|break;
case|case
name|LibFunc
operator|::
name|sin
case|:
case|case
name|LibFunc
operator|::
name|sinf
case|:
case|case
name|LibFunc
operator|::
name|sinl
case|:
return|return
name|checkUnaryFloatSignature
argument_list|(
operator|*
name|CI
argument_list|,
name|Intrinsic
operator|::
name|sin
argument_list|)
return|;
case|case
name|LibFunc
operator|::
name|cos
case|:
case|case
name|LibFunc
operator|::
name|cosf
case|:
case|case
name|LibFunc
operator|::
name|cosl
case|:
return|return
name|checkUnaryFloatSignature
argument_list|(
operator|*
name|CI
argument_list|,
name|Intrinsic
operator|::
name|cos
argument_list|)
return|;
case|case
name|LibFunc
operator|::
name|exp
case|:
case|case
name|LibFunc
operator|::
name|expf
case|:
case|case
name|LibFunc
operator|::
name|expl
case|:
return|return
name|checkUnaryFloatSignature
argument_list|(
operator|*
name|CI
argument_list|,
name|Intrinsic
operator|::
name|exp
argument_list|)
return|;
case|case
name|LibFunc
operator|::
name|exp2
case|:
case|case
name|LibFunc
operator|::
name|exp2f
case|:
case|case
name|LibFunc
operator|::
name|exp2l
case|:
return|return
name|checkUnaryFloatSignature
argument_list|(
operator|*
name|CI
argument_list|,
name|Intrinsic
operator|::
name|exp2
argument_list|)
return|;
case|case
name|LibFunc
operator|::
name|log
case|:
case|case
name|LibFunc
operator|::
name|logf
case|:
case|case
name|LibFunc
operator|::
name|logl
case|:
return|return
name|checkUnaryFloatSignature
argument_list|(
operator|*
name|CI
argument_list|,
name|Intrinsic
operator|::
name|log
argument_list|)
return|;
case|case
name|LibFunc
operator|::
name|log10
case|:
case|case
name|LibFunc
operator|::
name|log10f
case|:
case|case
name|LibFunc
operator|::
name|log10l
case|:
return|return
name|checkUnaryFloatSignature
argument_list|(
operator|*
name|CI
argument_list|,
name|Intrinsic
operator|::
name|log10
argument_list|)
return|;
case|case
name|LibFunc
operator|::
name|log2
case|:
case|case
name|LibFunc
operator|::
name|log2f
case|:
case|case
name|LibFunc
operator|::
name|log2l
case|:
return|return
name|checkUnaryFloatSignature
argument_list|(
operator|*
name|CI
argument_list|,
name|Intrinsic
operator|::
name|log2
argument_list|)
return|;
case|case
name|LibFunc
operator|::
name|fabs
case|:
case|case
name|LibFunc
operator|::
name|fabsf
case|:
case|case
name|LibFunc
operator|::
name|fabsl
case|:
return|return
name|checkUnaryFloatSignature
argument_list|(
operator|*
name|CI
argument_list|,
name|Intrinsic
operator|::
name|fabs
argument_list|)
return|;
case|case
name|LibFunc
operator|::
name|copysign
case|:
case|case
name|LibFunc
operator|::
name|copysignf
case|:
case|case
name|LibFunc
operator|::
name|copysignl
case|:
return|return
name|checkBinaryFloatSignature
argument_list|(
operator|*
name|CI
argument_list|,
name|Intrinsic
operator|::
name|copysign
argument_list|)
return|;
case|case
name|LibFunc
operator|::
name|floor
case|:
case|case
name|LibFunc
operator|::
name|floorf
case|:
case|case
name|LibFunc
operator|::
name|floorl
case|:
return|return
name|checkUnaryFloatSignature
argument_list|(
operator|*
name|CI
argument_list|,
name|Intrinsic
operator|::
name|floor
argument_list|)
return|;
case|case
name|LibFunc
operator|::
name|ceil
case|:
case|case
name|LibFunc
operator|::
name|ceilf
case|:
case|case
name|LibFunc
operator|::
name|ceill
case|:
return|return
name|checkUnaryFloatSignature
argument_list|(
operator|*
name|CI
argument_list|,
name|Intrinsic
operator|::
name|ceil
argument_list|)
return|;
case|case
name|LibFunc
operator|::
name|trunc
case|:
case|case
name|LibFunc
operator|::
name|truncf
case|:
case|case
name|LibFunc
operator|::
name|truncl
case|:
return|return
name|checkUnaryFloatSignature
argument_list|(
operator|*
name|CI
argument_list|,
name|Intrinsic
operator|::
name|trunc
argument_list|)
return|;
case|case
name|LibFunc
operator|::
name|rint
case|:
case|case
name|LibFunc
operator|::
name|rintf
case|:
case|case
name|LibFunc
operator|::
name|rintl
case|:
return|return
name|checkUnaryFloatSignature
argument_list|(
operator|*
name|CI
argument_list|,
name|Intrinsic
operator|::
name|rint
argument_list|)
return|;
case|case
name|LibFunc
operator|::
name|nearbyint
case|:
case|case
name|LibFunc
operator|::
name|nearbyintf
case|:
case|case
name|LibFunc
operator|::
name|nearbyintl
case|:
return|return
name|checkUnaryFloatSignature
argument_list|(
operator|*
name|CI
argument_list|,
name|Intrinsic
operator|::
name|nearbyint
argument_list|)
return|;
case|case
name|LibFunc
operator|::
name|round
case|:
case|case
name|LibFunc
operator|::
name|roundf
case|:
case|case
name|LibFunc
operator|::
name|roundl
case|:
return|return
name|checkUnaryFloatSignature
argument_list|(
operator|*
name|CI
argument_list|,
name|Intrinsic
operator|::
name|round
argument_list|)
return|;
case|case
name|LibFunc
operator|::
name|pow
case|:
case|case
name|LibFunc
operator|::
name|powf
case|:
case|case
name|LibFunc
operator|::
name|powl
case|:
return|return
name|checkBinaryFloatSignature
argument_list|(
operator|*
name|CI
argument_list|,
name|Intrinsic
operator|::
name|pow
argument_list|)
return|;
block|}
end_switch

begin_return
return|return
name|Intrinsic
operator|::
name|not_intrinsic
return|;
end_return

begin_comment
unit|}  }
comment|// llvm namespace
end_comment

begin_endif
endif|#
directive|endif
end_endif

end_unit

