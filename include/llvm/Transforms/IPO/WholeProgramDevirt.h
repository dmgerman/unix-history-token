begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===- WholeProgramDevirt.h - Whole-program devirt pass ---------*- C++ -*-===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file defines parts of the whole-program devirtualization pass
end_comment

begin_comment
comment|// implementation that may be usefully unit tested.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LLVM_TRANSFORMS_IPO_WHOLEPROGRAMDEVIRT_H
end_ifndef

begin_define
define|#
directive|define
name|LLVM_TRANSFORMS_IPO_WHOLEPROGRAMDEVIRT_H
end_define

begin_include
include|#
directive|include
file|"llvm/IR/Module.h"
end_include

begin_include
include|#
directive|include
file|"llvm/IR/PassManager.h"
end_include

begin_include
include|#
directive|include
file|<cassert>
end_include

begin_include
include|#
directive|include
file|<cstdint>
end_include

begin_include
include|#
directive|include
file|<utility>
end_include

begin_include
include|#
directive|include
file|<vector>
end_include

begin_decl_stmt
name|namespace
name|llvm
block|{
name|template
operator|<
name|typename
name|T
operator|>
name|class
name|ArrayRef
expr_stmt|;
name|template
operator|<
name|typename
name|T
operator|>
name|class
name|MutableArrayRef
expr_stmt|;
name|class
name|Function
decl_stmt|;
name|class
name|GlobalVariable
decl_stmt|;
name|namespace
name|wholeprogramdevirt
block|{
comment|// A bit vector that keeps track of which bits are used. We use this to
comment|// pack constant values compactly before and after each virtual table.
struct|struct
name|AccumBitVector
block|{
name|std
operator|::
name|vector
operator|<
name|uint8_t
operator|>
name|Bytes
expr_stmt|;
comment|// Bits in BytesUsed[I] are 1 if matching bit in Bytes[I] is used, 0 if not.
name|std
operator|::
name|vector
operator|<
name|uint8_t
operator|>
name|BytesUsed
expr_stmt|;
name|std
operator|::
name|pair
operator|<
name|uint8_t
operator|*
operator|,
name|uint8_t
operator|*
operator|>
name|getPtrToData
argument_list|(
argument|uint64_t Pos
argument_list|,
argument|uint8_t Size
argument_list|)
block|{
if|if
condition|(
name|Bytes
operator|.
name|size
argument_list|()
operator|<
name|Pos
operator|+
name|Size
condition|)
block|{
name|Bytes
operator|.
name|resize
argument_list|(
name|Pos
operator|+
name|Size
argument_list|)
expr_stmt|;
name|BytesUsed
operator|.
name|resize
argument_list|(
name|Pos
operator|+
name|Size
argument_list|)
expr_stmt|;
block|}
return|return
name|std
operator|::
name|make_pair
argument_list|(
name|Bytes
operator|.
name|data
argument_list|()
operator|+
name|Pos
argument_list|,
name|BytesUsed
operator|.
name|data
argument_list|()
operator|+
name|Pos
argument_list|)
return|;
block|}
comment|// Set little-endian value Val with size Size at bit position Pos,
comment|// and mark bytes as used.
name|void
name|setLE
parameter_list|(
name|uint64_t
name|Pos
parameter_list|,
name|uint64_t
name|Val
parameter_list|,
name|uint8_t
name|Size
parameter_list|)
block|{
name|assert
argument_list|(
name|Pos
operator|%
literal|8
operator|==
literal|0
argument_list|)
expr_stmt|;
name|auto
name|DataUsed
init|=
name|getPtrToData
argument_list|(
name|Pos
operator|/
literal|8
argument_list|,
name|Size
argument_list|)
decl_stmt|;
for|for
control|(
name|unsigned
name|I
init|=
literal|0
init|;
name|I
operator|!=
name|Size
condition|;
operator|++
name|I
control|)
block|{
name|DataUsed
operator|.
name|first
index|[
name|I
index|]
operator|=
name|Val
operator|>>
operator|(
name|I
operator|*
literal|8
operator|)
expr_stmt|;
name|assert
argument_list|(
operator|!
name|DataUsed
operator|.
name|second
index|[
name|I
index|]
argument_list|)
expr_stmt|;
name|DataUsed
operator|.
name|second
index|[
name|I
index|]
operator|=
literal|0xff
expr_stmt|;
block|}
block|}
comment|// Set big-endian value Val with size Size at bit position Pos,
comment|// and mark bytes as used.
name|void
name|setBE
parameter_list|(
name|uint64_t
name|Pos
parameter_list|,
name|uint64_t
name|Val
parameter_list|,
name|uint8_t
name|Size
parameter_list|)
block|{
name|assert
argument_list|(
name|Pos
operator|%
literal|8
operator|==
literal|0
argument_list|)
expr_stmt|;
name|auto
name|DataUsed
init|=
name|getPtrToData
argument_list|(
name|Pos
operator|/
literal|8
argument_list|,
name|Size
argument_list|)
decl_stmt|;
for|for
control|(
name|unsigned
name|I
init|=
literal|0
init|;
name|I
operator|!=
name|Size
condition|;
operator|++
name|I
control|)
block|{
name|DataUsed
operator|.
name|first
index|[
name|Size
operator|-
name|I
operator|-
literal|1
index|]
operator|=
name|Val
operator|>>
operator|(
name|I
operator|*
literal|8
operator|)
expr_stmt|;
name|assert
argument_list|(
operator|!
name|DataUsed
operator|.
name|second
index|[
name|Size
operator|-
name|I
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
name|DataUsed
operator|.
name|second
index|[
name|Size
operator|-
name|I
operator|-
literal|1
index|]
operator|=
literal|0xff
expr_stmt|;
block|}
block|}
comment|// Set bit at bit position Pos to b and mark bit as used.
name|void
name|setBit
parameter_list|(
name|uint64_t
name|Pos
parameter_list|,
name|bool
name|b
parameter_list|)
block|{
name|auto
name|DataUsed
init|=
name|getPtrToData
argument_list|(
name|Pos
operator|/
literal|8
argument_list|,
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|b
condition|)
operator|*
name|DataUsed
operator|.
name|first
operator||=
literal|1
operator|<<
operator|(
name|Pos
operator|%
literal|8
operator|)
expr_stmt|;
name|assert
argument_list|(
operator|!
operator|(
operator|*
name|DataUsed
operator|.
name|second
operator|&
operator|(
literal|1
operator|<<
name|Pos
operator|%
literal|8
operator|)
operator|)
argument_list|)
expr_stmt|;
operator|*
name|DataUsed
operator|.
name|second
operator||=
literal|1
operator|<<
operator|(
name|Pos
operator|%
literal|8
operator|)
expr_stmt|;
block|}
block|}
struct|;
comment|// The bits that will be stored before and after a particular vtable.
struct|struct
name|VTableBits
block|{
comment|// The vtable global.
name|GlobalVariable
modifier|*
name|GV
decl_stmt|;
comment|// Cache of the vtable's size in bytes.
name|uint64_t
name|ObjectSize
init|=
literal|0
decl_stmt|;
comment|// The bit vector that will be laid out before the vtable. Note that these
comment|// bytes are stored in reverse order until the globals are rebuilt. This means
comment|// that any values in the array must be stored using the opposite endianness
comment|// from the target.
name|AccumBitVector
name|Before
decl_stmt|;
comment|// The bit vector that will be laid out after the vtable.
name|AccumBitVector
name|After
decl_stmt|;
block|}
struct|;
comment|// Information about a member of a particular type identifier.
struct|struct
name|TypeMemberInfo
block|{
comment|// The VTableBits for the vtable.
name|VTableBits
modifier|*
name|Bits
decl_stmt|;
comment|// The offset in bytes from the start of the vtable (i.e. the address point).
name|uint64_t
name|Offset
decl_stmt|;
name|bool
name|operator
operator|<
operator|(
specifier|const
name|TypeMemberInfo
operator|&
name|other
operator|)
specifier|const
block|{
return|return
name|Bits
operator|<
name|other
operator|.
name|Bits
operator|||
operator|(
name|Bits
operator|==
name|other
operator|.
name|Bits
operator|&&
name|Offset
operator|<
name|other
operator|.
name|Offset
operator|)
return|;
block|}
block|}
struct|;
comment|// A virtual call target, i.e. an entry in a particular vtable.
struct|struct
name|VirtualCallTarget
block|{
name|VirtualCallTarget
argument_list|(
name|Function
operator|*
name|Fn
argument_list|,
specifier|const
name|TypeMemberInfo
operator|*
name|TM
argument_list|)
expr_stmt|;
comment|// For testing only.
name|VirtualCallTarget
argument_list|(
argument|const TypeMemberInfo *TM
argument_list|,
argument|bool IsBigEndian
argument_list|)
block|:
name|Fn
argument_list|(
name|nullptr
argument_list|)
operator|,
name|TM
argument_list|(
name|TM
argument_list|)
operator|,
name|IsBigEndian
argument_list|(
name|IsBigEndian
argument_list|)
operator|,
name|WasDevirt
argument_list|(
argument|false
argument_list|)
block|{}
comment|// The function stored in the vtable.
name|Function
operator|*
name|Fn
expr_stmt|;
comment|// A pointer to the type identifier member through which the pointer to Fn is
comment|// accessed.
specifier|const
name|TypeMemberInfo
modifier|*
name|TM
decl_stmt|;
comment|// When doing virtual constant propagation, this stores the return value for
comment|// the function when passed the currently considered argument list.
name|uint64_t
name|RetVal
decl_stmt|;
comment|// Whether the target is big endian.
name|bool
name|IsBigEndian
decl_stmt|;
comment|// Whether at least one call site to the target was devirtualized.
name|bool
name|WasDevirt
decl_stmt|;
comment|// The minimum byte offset before the address point. This covers the bytes in
comment|// the vtable object before the address point (e.g. RTTI, access-to-top,
comment|// vtables for other base classes) and is equal to the offset from the start
comment|// of the vtable object to the address point.
name|uint64_t
name|minBeforeBytes
argument_list|()
specifier|const
block|{
return|return
name|TM
operator|->
name|Offset
return|;
block|}
comment|// The minimum byte offset after the address point. This covers the bytes in
comment|// the vtable object after the address point (e.g. the vtable for the current
comment|// class and any later base classes) and is equal to the size of the vtable
comment|// object minus the offset from the start of the vtable object to the address
comment|// point.
name|uint64_t
name|minAfterBytes
argument_list|()
specifier|const
block|{
return|return
name|TM
operator|->
name|Bits
operator|->
name|ObjectSize
operator|-
name|TM
operator|->
name|Offset
return|;
block|}
comment|// The number of bytes allocated (for the vtable plus the byte array) before
comment|// the address point.
name|uint64_t
name|allocatedBeforeBytes
argument_list|()
specifier|const
block|{
return|return
name|minBeforeBytes
argument_list|()
operator|+
name|TM
operator|->
name|Bits
operator|->
name|Before
operator|.
name|Bytes
operator|.
name|size
argument_list|()
return|;
block|}
comment|// The number of bytes allocated (for the vtable plus the byte array) after
comment|// the address point.
name|uint64_t
name|allocatedAfterBytes
argument_list|()
specifier|const
block|{
return|return
name|minAfterBytes
argument_list|()
operator|+
name|TM
operator|->
name|Bits
operator|->
name|After
operator|.
name|Bytes
operator|.
name|size
argument_list|()
return|;
block|}
comment|// Set the bit at position Pos before the address point to RetVal.
name|void
name|setBeforeBit
parameter_list|(
name|uint64_t
name|Pos
parameter_list|)
block|{
name|assert
argument_list|(
name|Pos
operator|>=
literal|8
operator|*
name|minBeforeBytes
argument_list|()
argument_list|)
expr_stmt|;
name|TM
operator|->
name|Bits
operator|->
name|Before
operator|.
name|setBit
argument_list|(
name|Pos
operator|-
literal|8
operator|*
name|minBeforeBytes
argument_list|()
argument_list|,
name|RetVal
argument_list|)
expr_stmt|;
block|}
comment|// Set the bit at position Pos after the address point to RetVal.
name|void
name|setAfterBit
parameter_list|(
name|uint64_t
name|Pos
parameter_list|)
block|{
name|assert
argument_list|(
name|Pos
operator|>=
literal|8
operator|*
name|minAfterBytes
argument_list|()
argument_list|)
expr_stmt|;
name|TM
operator|->
name|Bits
operator|->
name|After
operator|.
name|setBit
argument_list|(
name|Pos
operator|-
literal|8
operator|*
name|minAfterBytes
argument_list|()
argument_list|,
name|RetVal
argument_list|)
expr_stmt|;
block|}
comment|// Set the bytes at position Pos before the address point to RetVal.
comment|// Because the bytes in Before are stored in reverse order, we use the
comment|// opposite endianness to the target.
name|void
name|setBeforeBytes
parameter_list|(
name|uint64_t
name|Pos
parameter_list|,
name|uint8_t
name|Size
parameter_list|)
block|{
name|assert
argument_list|(
name|Pos
operator|>=
literal|8
operator|*
name|minBeforeBytes
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|IsBigEndian
condition|)
name|TM
operator|->
name|Bits
operator|->
name|Before
operator|.
name|setLE
argument_list|(
name|Pos
operator|-
literal|8
operator|*
name|minBeforeBytes
argument_list|()
argument_list|,
name|RetVal
argument_list|,
name|Size
argument_list|)
expr_stmt|;
else|else
name|TM
operator|->
name|Bits
operator|->
name|Before
operator|.
name|setBE
argument_list|(
name|Pos
operator|-
literal|8
operator|*
name|minBeforeBytes
argument_list|()
argument_list|,
name|RetVal
argument_list|,
name|Size
argument_list|)
expr_stmt|;
block|}
comment|// Set the bytes at position Pos after the address point to RetVal.
name|void
name|setAfterBytes
parameter_list|(
name|uint64_t
name|Pos
parameter_list|,
name|uint8_t
name|Size
parameter_list|)
block|{
name|assert
argument_list|(
name|Pos
operator|>=
literal|8
operator|*
name|minAfterBytes
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|IsBigEndian
condition|)
name|TM
operator|->
name|Bits
operator|->
name|After
operator|.
name|setBE
argument_list|(
name|Pos
operator|-
literal|8
operator|*
name|minAfterBytes
argument_list|()
argument_list|,
name|RetVal
argument_list|,
name|Size
argument_list|)
expr_stmt|;
else|else
name|TM
operator|->
name|Bits
operator|->
name|After
operator|.
name|setLE
argument_list|(
name|Pos
operator|-
literal|8
operator|*
name|minAfterBytes
argument_list|()
argument_list|,
name|RetVal
argument_list|,
name|Size
argument_list|)
expr_stmt|;
block|}
block|}
struct|;
comment|// Find the minimum offset that we may store a value of size Size bits at. If
comment|// IsAfter is set, look for an offset before the object, otherwise look for an
comment|// offset after the object.
name|uint64_t
name|findLowestOffset
argument_list|(
name|ArrayRef
operator|<
name|VirtualCallTarget
operator|>
name|Targets
argument_list|,
name|bool
name|IsAfter
argument_list|,
name|uint64_t
name|Size
argument_list|)
decl_stmt|;
comment|// Set the stored value in each of Targets to VirtualCallTarget::RetVal at the
comment|// given allocation offset before the vtable address. Stores the computed
comment|// byte/bit offset to OffsetByte/OffsetBit.
name|void
name|setBeforeReturnValues
argument_list|(
name|MutableArrayRef
operator|<
name|VirtualCallTarget
operator|>
name|Targets
argument_list|,
name|uint64_t
name|AllocBefore
argument_list|,
name|unsigned
name|BitWidth
argument_list|,
name|int64_t
operator|&
name|OffsetByte
argument_list|,
name|uint64_t
operator|&
name|OffsetBit
argument_list|)
decl_stmt|;
comment|// Set the stored value in each of Targets to VirtualCallTarget::RetVal at the
comment|// given allocation offset after the vtable address. Stores the computed
comment|// byte/bit offset to OffsetByte/OffsetBit.
name|void
name|setAfterReturnValues
argument_list|(
name|MutableArrayRef
operator|<
name|VirtualCallTarget
operator|>
name|Targets
argument_list|,
name|uint64_t
name|AllocAfter
argument_list|,
name|unsigned
name|BitWidth
argument_list|,
name|int64_t
operator|&
name|OffsetByte
argument_list|,
name|uint64_t
operator|&
name|OffsetBit
argument_list|)
decl_stmt|;
block|}
comment|// end namespace wholeprogramdevirt
name|struct
name|WholeProgramDevirtPass
range|:
name|public
name|PassInfoMixin
operator|<
name|WholeProgramDevirtPass
operator|>
block|{
name|PreservedAnalyses
name|run
argument_list|(
name|Module
operator|&
name|M
argument_list|,
name|ModuleAnalysisManager
operator|&
argument_list|)
block|; }
decl_stmt|;
block|}
end_decl_stmt

begin_comment
comment|// end namespace llvm
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|// LLVM_TRANSFORMS_IPO_WHOLEPROGRAMDEVIRT_H
end_comment

end_unit

