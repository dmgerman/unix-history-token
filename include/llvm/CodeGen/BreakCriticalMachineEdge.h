begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===--------- BreakCriticalMachineEdge.h - Break critical edges ---------===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===---------------------------------------------------------------------===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// Helper function to break a critical machine edge.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===---------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LLVM_CODEGEN_BREAKCRITICALMACHINEEDGE_H
end_ifndef

begin_define
define|#
directive|define
name|LLVM_CODEGEN_BREAKCRITICALMACHINEEDGE_H
end_define

begin_include
include|#
directive|include
file|"llvm/CodeGen/MachineJumpTableInfo.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Target/TargetInstrInfo.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Target/TargetMachine.h"
end_include

begin_decl_stmt
name|namespace
name|llvm
block|{
name|MachineBasicBlock
modifier|*
name|SplitCriticalMachineEdge
parameter_list|(
name|MachineBasicBlock
modifier|*
name|src
parameter_list|,
name|MachineBasicBlock
modifier|*
name|dst
parameter_list|)
block|{
name|MachineFunction
modifier|&
name|MF
init|=
operator|*
name|src
operator|->
name|getParent
argument_list|()
decl_stmt|;
specifier|const
name|BasicBlock
modifier|*
name|srcBB
init|=
name|src
operator|->
name|getBasicBlock
argument_list|()
decl_stmt|;
name|MachineBasicBlock
modifier|*
name|crit_mbb
init|=
name|MF
operator|.
name|CreateMachineBasicBlock
argument_list|(
name|srcBB
argument_list|)
decl_stmt|;
comment|// modify the llvm control flow graph
name|src
operator|->
name|removeSuccessor
argument_list|(
name|dst
argument_list|)
expr_stmt|;
name|src
operator|->
name|addSuccessor
argument_list|(
name|crit_mbb
argument_list|)
expr_stmt|;
name|crit_mbb
operator|->
name|addSuccessor
argument_list|(
name|dst
argument_list|)
expr_stmt|;
comment|// insert the new block into the machine function.
name|MF
operator|.
name|push_back
argument_list|(
name|crit_mbb
argument_list|)
expr_stmt|;
comment|// insert a unconditional branch linking the new block to dst
specifier|const
name|TargetMachine
modifier|&
name|TM
init|=
name|MF
operator|.
name|getTarget
argument_list|()
decl_stmt|;
specifier|const
name|TargetInstrInfo
modifier|*
name|TII
init|=
name|TM
operator|.
name|getInstrInfo
argument_list|()
decl_stmt|;
name|std
operator|::
name|vector
operator|<
name|MachineOperand
operator|>
name|emptyConditions
expr_stmt|;
name|TII
operator|->
name|InsertBranch
argument_list|(
operator|*
name|crit_mbb
argument_list|,
name|dst
argument_list|,
operator|(
name|MachineBasicBlock
operator|*
operator|)
literal|0
argument_list|,
name|emptyConditions
argument_list|)
expr_stmt|;
comment|// modify every branch in src that points to dst to point to the new
comment|// machine basic block instead:
name|MachineBasicBlock
operator|::
name|iterator
name|mii
operator|=
name|src
operator|->
name|end
argument_list|()
expr_stmt|;
name|bool
name|found_branch
init|=
name|false
decl_stmt|;
while|while
condition|(
name|mii
operator|!=
name|src
operator|->
name|begin
argument_list|()
condition|)
block|{
name|mii
operator|--
expr_stmt|;
comment|// if there are no more branches, finish the loop
if|if
condition|(
operator|!
name|mii
operator|->
name|getDesc
argument_list|()
operator|.
name|isTerminator
argument_list|()
condition|)
block|{
break|break;
block|}
comment|// Scan the operands of this branch, replacing any uses of dst with
comment|// crit_mbb.
for|for
control|(
name|unsigned
name|i
init|=
literal|0
init|,
name|e
init|=
name|mii
operator|->
name|getNumOperands
argument_list|()
init|;
name|i
operator|!=
name|e
condition|;
operator|++
name|i
control|)
block|{
name|MachineOperand
modifier|&
name|mo
init|=
name|mii
operator|->
name|getOperand
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|mo
operator|.
name|isMBB
argument_list|()
operator|&&
name|mo
operator|.
name|getMBB
argument_list|()
operator|==
name|dst
condition|)
block|{
name|found_branch
operator|=
name|true
expr_stmt|;
name|mo
operator|.
name|setMBB
argument_list|(
name|crit_mbb
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|// TODO: This is tentative. It may be necessary to fix this code. Maybe
comment|// I am inserting too many gotos, but I am trusting that the asm printer
comment|// will optimize the unnecessary gotos.
if|if
condition|(
operator|!
name|found_branch
condition|)
block|{
name|TII
operator|->
name|InsertBranch
argument_list|(
operator|*
name|src
argument_list|,
name|crit_mbb
argument_list|,
operator|(
name|MachineBasicBlock
operator|*
operator|)
literal|0
argument_list|,
name|emptyConditions
argument_list|)
expr_stmt|;
block|}
comment|/// Change all the phi functions in dst, so that the incoming block be
comment|/// crit_mbb, instead of src
for|for
control|(
name|mii
operator|=
name|dst
operator|->
name|begin
argument_list|()
init|;
name|mii
operator|!=
name|dst
operator|->
name|end
argument_list|()
condition|;
name|mii
operator|++
control|)
block|{
comment|/// the first instructions are always phi functions.
if|if
condition|(
name|mii
operator|->
name|getOpcode
argument_list|()
operator|!=
name|TargetInstrInfo
operator|::
name|PHI
condition|)
break|break;
comment|// Find the operands corresponding to the source block
name|std
operator|::
name|vector
operator|<
name|unsigned
operator|>
name|toRemove
expr_stmt|;
name|unsigned
name|reg
init|=
literal|0
decl_stmt|;
for|for
control|(
name|unsigned
name|u
init|=
literal|0
init|;
name|u
operator|!=
name|mii
operator|->
name|getNumOperands
argument_list|()
condition|;
operator|++
name|u
control|)
if|if
condition|(
name|mii
operator|->
name|getOperand
argument_list|(
name|u
argument_list|)
operator|.
name|isMBB
argument_list|()
operator|&&
name|mii
operator|->
name|getOperand
argument_list|(
name|u
argument_list|)
operator|.
name|getMBB
argument_list|()
operator|==
name|src
condition|)
block|{
name|reg
operator|=
name|mii
operator|->
name|getOperand
argument_list|(
name|u
operator|-
literal|1
argument_list|)
operator|.
name|getReg
argument_list|()
expr_stmt|;
name|toRemove
operator|.
name|push_back
argument_list|(
name|u
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
comment|// Remove all uses of this MBB
for|for
control|(
name|std
operator|::
name|vector
operator|<
name|unsigned
operator|>
operator|::
name|reverse_iterator
name|I
operator|=
name|toRemove
operator|.
name|rbegin
argument_list|()
operator|,
name|E
operator|=
name|toRemove
operator|.
name|rend
argument_list|()
init|;
name|I
operator|!=
name|E
condition|;
operator|++
name|I
control|)
block|{
name|mii
operator|->
name|RemoveOperand
argument_list|(
operator|*
name|I
operator|+
literal|1
argument_list|)
expr_stmt|;
name|mii
operator|->
name|RemoveOperand
argument_list|(
operator|*
name|I
argument_list|)
expr_stmt|;
block|}
comment|// Add a single use corresponding to the new MBB
name|mii
operator|->
name|addOperand
argument_list|(
name|MachineOperand
operator|::
name|CreateReg
argument_list|(
name|reg
argument_list|,
name|false
argument_list|)
argument_list|)
expr_stmt|;
name|mii
operator|->
name|addOperand
argument_list|(
name|MachineOperand
operator|::
name|CreateMBB
argument_list|(
name|crit_mbb
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|crit_mbb
return|;
block|}
block|}
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

end_unit

