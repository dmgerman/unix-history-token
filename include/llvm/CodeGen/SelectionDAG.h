begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===-- llvm/CodeGen/SelectionDAG.h - InstSelection DAG ---------*- C++ -*-===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file declares the SelectionDAG class, and transitively defines the
end_comment

begin_comment
comment|// SDNode class and subclasses.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LLVM_CODEGEN_SELECTIONDAG_H
end_ifndef

begin_define
define|#
directive|define
name|LLVM_CODEGEN_SELECTIONDAG_H
end_define

begin_include
include|#
directive|include
file|"llvm/ADT/DenseSet.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/SetVector.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/StringMap.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/ilist.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Analysis/AliasAnalysis.h"
end_include

begin_include
include|#
directive|include
file|"llvm/CodeGen/DAGCombine.h"
end_include

begin_include
include|#
directive|include
file|"llvm/CodeGen/MachineFunction.h"
end_include

begin_include
include|#
directive|include
file|"llvm/CodeGen/SelectionDAGNodes.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/ArrayRecycler.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/RecyclingAllocator.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Target/TargetMachine.h"
end_include

begin_include
include|#
directive|include
file|<cassert>
end_include

begin_include
include|#
directive|include
file|<map>
end_include

begin_include
include|#
directive|include
file|<string>
end_include

begin_include
include|#
directive|include
file|<vector>
end_include

begin_decl_stmt
name|namespace
name|llvm
block|{
name|class
name|MachineConstantPoolValue
decl_stmt|;
name|class
name|MachineFunction
decl_stmt|;
name|class
name|MDNode
decl_stmt|;
name|class
name|SDDbgValue
decl_stmt|;
name|class
name|TargetLowering
decl_stmt|;
name|class
name|SelectionDAGTargetInfo
decl_stmt|;
name|class
name|SDVTListNode
range|:
name|public
name|FoldingSetNode
block|{
name|friend
expr|struct
name|FoldingSetTrait
operator|<
name|SDVTListNode
operator|>
block|;
comment|/// A reference to an Interned FoldingSetNodeID for this node.
comment|/// The Allocator in SelectionDAG holds the data.
comment|/// SDVTList contains all types which are frequently accessed in SelectionDAG.
comment|/// The size of this list is not expected to be big so it won't introduce
comment|/// a memory penalty.
name|FoldingSetNodeIDRef
name|FastID
block|;
specifier|const
name|EVT
operator|*
name|VTs
block|;
name|unsigned
name|int
name|NumVTs
block|;
comment|/// The hash value for SDVTList is fixed, so cache it to avoid
comment|/// hash calculation.
name|unsigned
name|HashValue
block|;
name|public
operator|:
name|SDVTListNode
argument_list|(
argument|const FoldingSetNodeIDRef ID
argument_list|,
argument|const EVT *VT
argument_list|,
argument|unsigned int Num
argument_list|)
operator|:
name|FastID
argument_list|(
name|ID
argument_list|)
block|,
name|VTs
argument_list|(
name|VT
argument_list|)
block|,
name|NumVTs
argument_list|(
argument|Num
argument_list|)
block|{
name|HashValue
operator|=
name|ID
operator|.
name|ComputeHash
argument_list|()
block|;   }
name|SDVTList
name|getSDVTList
argument_list|()
block|{
name|SDVTList
name|result
operator|=
block|{
name|VTs
block|,
name|NumVTs
block|}
block|;
return|return
name|result
return|;
block|}
expr|}
block|;
comment|/// Specialize FoldingSetTrait for SDVTListNode
comment|/// to avoid computing temp FoldingSetNodeID and hash value.
name|template
operator|<
operator|>
expr|struct
name|FoldingSetTrait
operator|<
name|SDVTListNode
operator|>
operator|:
name|DefaultFoldingSetTrait
operator|<
name|SDVTListNode
operator|>
block|{
specifier|static
name|void
name|Profile
argument_list|(
argument|const SDVTListNode&X
argument_list|,
argument|FoldingSetNodeID& ID
argument_list|)
block|{
name|ID
operator|=
name|X
operator|.
name|FastID
block|;   }
specifier|static
name|bool
name|Equals
argument_list|(
argument|const SDVTListNode&X
argument_list|,
argument|const FoldingSetNodeID&ID
argument_list|,
argument|unsigned IDHash
argument_list|,
argument|FoldingSetNodeID&TempID
argument_list|)
block|{
if|if
condition|(
name|X
operator|.
name|HashValue
operator|!=
name|IDHash
condition|)
return|return
name|false
return|;
return|return
name|ID
operator|==
name|X
operator|.
name|FastID
return|;
block|}
specifier|static
name|unsigned
name|ComputeHash
argument_list|(
argument|const SDVTListNode&X
argument_list|,
argument|FoldingSetNodeID&TempID
argument_list|)
block|{
return|return
name|X
operator|.
name|HashValue
return|;
block|}
expr|}
block|;
name|template
operator|<
operator|>
expr|struct
name|ilist_alloc_traits
operator|<
name|SDNode
operator|>
block|{
specifier|static
name|void
name|deleteNode
argument_list|(
argument|SDNode *
argument_list|)
block|{
name|llvm_unreachable
argument_list|(
literal|"ilist_traits<SDNode> shouldn't see a deleteNode call!"
argument_list|)
block|;   }
block|}
block|;
comment|/// Keeps track of dbg_value information through SDISel.  We do
comment|/// not build SDNodes for these so as not to perturb the generated code;
comment|/// instead the info is kept off to the side in this structure. Each SDNode may
comment|/// have one or more associated dbg_value entries. This information is kept in
comment|/// DbgValMap.
comment|/// Byval parameters are handled separately because they don't use alloca's,
comment|/// which busts the normal mechanism.  There is good reason for handling all
comment|/// parameters separately:  they may not have code generated for them, they
comment|/// should always go at the beginning of the function regardless of other code
comment|/// motion, and debug info for them is potentially useful even if the parameter
comment|/// is unused.  Right now only byval parameters are handled separately.
name|class
name|SDDbgInfo
block|{
name|BumpPtrAllocator
name|Alloc
block|;
name|SmallVector
operator|<
name|SDDbgValue
operator|*
block|,
literal|32
operator|>
name|DbgValues
block|;
name|SmallVector
operator|<
name|SDDbgValue
operator|*
block|,
literal|32
operator|>
name|ByvalParmDbgValues
block|;
typedef|typedef
name|DenseMap
operator|<
specifier|const
name|SDNode
operator|*
operator|,
name|SmallVector
operator|<
name|SDDbgValue
operator|*
operator|,
literal|2
operator|>
expr|>
name|DbgValMapType
expr_stmt|;
name|DbgValMapType
name|DbgValMap
block|;
name|void
name|operator
operator|=
operator|(
specifier|const
name|SDDbgInfo
operator|&
operator|)
operator|=
name|delete
block|;
name|SDDbgInfo
argument_list|(
specifier|const
name|SDDbgInfo
operator|&
argument_list|)
operator|=
name|delete
block|;
name|public
operator|:
name|SDDbgInfo
argument_list|()
block|{}
name|void
name|add
argument_list|(
argument|SDDbgValue *V
argument_list|,
argument|const SDNode *Node
argument_list|,
argument|bool isParameter
argument_list|)
block|{
if|if
condition|(
name|isParameter
condition|)
block|{
name|ByvalParmDbgValues
operator|.
name|push_back
argument_list|(
name|V
argument_list|)
expr_stmt|;
block|}
else|else
name|DbgValues
operator|.
name|push_back
argument_list|(
name|V
argument_list|)
expr_stmt|;
if|if
condition|(
name|Node
condition|)
name|DbgValMap
index|[
name|Node
index|]
operator|.
name|push_back
argument_list|(
name|V
argument_list|)
expr_stmt|;
block|}
comment|/// \brief Invalidate all DbgValues attached to the node and remove
comment|/// it from the Node-to-DbgValues map.
name|void
name|erase
parameter_list|(
specifier|const
name|SDNode
modifier|*
name|Node
parameter_list|)
function_decl|;
name|void
name|clear
parameter_list|()
block|{
name|DbgValMap
operator|.
name|clear
argument_list|()
expr_stmt|;
name|DbgValues
operator|.
name|clear
argument_list|()
expr_stmt|;
name|ByvalParmDbgValues
operator|.
name|clear
argument_list|()
expr_stmt|;
name|Alloc
operator|.
name|Reset
argument_list|()
expr_stmt|;
block|}
name|BumpPtrAllocator
modifier|&
name|getAlloc
parameter_list|()
block|{
return|return
name|Alloc
return|;
block|}
name|bool
name|empty
argument_list|()
specifier|const
block|{
return|return
name|DbgValues
operator|.
name|empty
argument_list|()
operator|&&
name|ByvalParmDbgValues
operator|.
name|empty
argument_list|()
return|;
block|}
name|ArrayRef
operator|<
name|SDDbgValue
operator|*
operator|>
name|getSDDbgValues
argument_list|(
argument|const SDNode *Node
argument_list|)
block|{
name|DbgValMapType
operator|::
name|iterator
name|I
operator|=
name|DbgValMap
operator|.
name|find
argument_list|(
name|Node
argument_list|)
block|;
if|if
condition|(
name|I
operator|!=
name|DbgValMap
operator|.
name|end
argument_list|()
condition|)
return|return
name|I
operator|->
name|second
return|;
return|return
name|ArrayRef
operator|<
name|SDDbgValue
operator|*
operator|>
operator|(
operator|)
return|;
block|}
end_decl_stmt

begin_typedef
typedef|typedef
name|SmallVectorImpl
operator|<
name|SDDbgValue
operator|*
operator|>
operator|::
name|iterator
name|DbgIterator
expr_stmt|;
end_typedef

begin_function
name|DbgIterator
name|DbgBegin
parameter_list|()
block|{
return|return
name|DbgValues
operator|.
name|begin
argument_list|()
return|;
block|}
end_function

begin_function
name|DbgIterator
name|DbgEnd
parameter_list|()
block|{
return|return
name|DbgValues
operator|.
name|end
argument_list|()
return|;
block|}
end_function

begin_function
name|DbgIterator
name|ByvalParmDbgBegin
parameter_list|()
block|{
return|return
name|ByvalParmDbgValues
operator|.
name|begin
argument_list|()
return|;
block|}
end_function

begin_function
name|DbgIterator
name|ByvalParmDbgEnd
parameter_list|()
block|{
return|return
name|ByvalParmDbgValues
operator|.
name|end
argument_list|()
return|;
block|}
end_function

begin_decl_stmt
unit|};
name|class
name|SelectionDAG
decl_stmt|;
end_decl_stmt

begin_function_decl
name|void
name|checkForCycles
parameter_list|(
specifier|const
name|SelectionDAG
modifier|*
name|DAG
parameter_list|,
name|bool
name|force
init|=
name|false
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/// This is used to represent a portion of an LLVM function in a low-level
end_comment

begin_comment
comment|/// Data Dependence DAG representation suitable for instruction selection.
end_comment

begin_comment
comment|/// This DAG is constructed as the first step of instruction selection in order
end_comment

begin_comment
comment|/// to allow implementation of machine specific optimizations
end_comment

begin_comment
comment|/// and code simplifications.
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|/// The representation used by the SelectionDAG is a target-independent
end_comment

begin_comment
comment|/// representation, which has some similarities to the GCC RTL representation,
end_comment

begin_comment
comment|/// but is significantly more simple, powerful, and is a graph form instead of a
end_comment

begin_comment
comment|/// linear form.
end_comment

begin_comment
comment|///
end_comment

begin_decl_stmt
name|class
name|SelectionDAG
block|{
specifier|const
name|TargetMachine
modifier|&
name|TM
decl_stmt|;
specifier|const
name|SelectionDAGTargetInfo
modifier|*
name|TSI
decl_stmt|;
specifier|const
name|TargetLowering
modifier|*
name|TLI
decl_stmt|;
name|MachineFunction
modifier|*
name|MF
decl_stmt|;
name|LLVMContext
modifier|*
name|Context
decl_stmt|;
name|CodeGenOpt
operator|::
name|Level
name|OptLevel
expr_stmt|;
comment|/// The starting token.
name|SDNode
name|EntryNode
decl_stmt|;
comment|/// The root of the entire DAG.
name|SDValue
name|Root
decl_stmt|;
comment|/// A linked list of nodes in the current DAG.
name|ilist
operator|<
name|SDNode
operator|>
name|AllNodes
expr_stmt|;
comment|/// The AllocatorType for allocating SDNodes. We use
comment|/// pool allocation with recycling.
typedef|typedef
name|RecyclingAllocator
operator|<
name|BumpPtrAllocator
operator|,
name|SDNode
operator|,
sizeof|sizeof
argument_list|(
name|LargestSDNode
argument_list|)
operator|,
name|alignof
argument_list|(
name|MostAlignedSDNode
argument_list|)
operator|>
name|NodeAllocatorType
expr_stmt|;
comment|/// Pool allocation for nodes.
name|NodeAllocatorType
name|NodeAllocator
decl_stmt|;
comment|/// This structure is used to memoize nodes, automatically performing
comment|/// CSE with existing nodes when a duplicate is requested.
name|FoldingSet
operator|<
name|SDNode
operator|>
name|CSEMap
expr_stmt|;
comment|/// Pool allocation for machine-opcode SDNode operands.
name|BumpPtrAllocator
name|OperandAllocator
decl_stmt|;
name|ArrayRecycler
operator|<
name|SDUse
operator|>
name|OperandRecycler
expr_stmt|;
comment|/// Pool allocation for misc. objects that are created once per SelectionDAG.
name|BumpPtrAllocator
name|Allocator
decl_stmt|;
comment|/// Tracks dbg_value information through SDISel.
name|SDDbgInfo
modifier|*
name|DbgInfo
decl_stmt|;
name|uint16_t
name|NextPersistentId
init|=
literal|0
decl_stmt|;
name|public
label|:
comment|/// Clients of various APIs that cause global effects on
comment|/// the DAG can optionally implement this interface.  This allows the clients
comment|/// to handle the various sorts of updates that happen.
comment|///
comment|/// A DAGUpdateListener automatically registers itself with DAG when it is
comment|/// constructed, and removes itself when destroyed in RAII fashion.
struct|struct
name|DAGUpdateListener
block|{
name|DAGUpdateListener
modifier|*
specifier|const
name|Next
decl_stmt|;
name|SelectionDAG
modifier|&
name|DAG
decl_stmt|;
name|explicit
name|DAGUpdateListener
argument_list|(
name|SelectionDAG
operator|&
name|D
argument_list|)
operator|:
name|Next
argument_list|(
name|D
operator|.
name|UpdateListeners
argument_list|)
operator|,
name|DAG
argument_list|(
argument|D
argument_list|)
block|{
name|DAG
operator|.
name|UpdateListeners
operator|=
name|this
block|;     }
name|virtual
operator|~
name|DAGUpdateListener
argument_list|()
block|{
name|assert
argument_list|(
name|DAG
operator|.
name|UpdateListeners
operator|==
name|this
operator|&&
literal|"DAGUpdateListeners must be destroyed in LIFO order"
argument_list|)
block|;
name|DAG
operator|.
name|UpdateListeners
operator|=
name|Next
block|;     }
comment|/// The node N that was deleted and, if E is not null, an
comment|/// equivalent node E that replaced it.
name|virtual
name|void
name|NodeDeleted
argument_list|(
name|SDNode
operator|*
name|N
argument_list|,
name|SDNode
operator|*
name|E
argument_list|)
expr_stmt|;
comment|/// The node N that was updated.
name|virtual
name|void
name|NodeUpdated
parameter_list|(
name|SDNode
modifier|*
name|N
parameter_list|)
function_decl|;
block|}
struct|;
name|struct
name|DAGNodeDeletedListener
range|:
name|public
name|DAGUpdateListener
block|{
name|std
operator|::
name|function
operator|<
name|void
argument_list|(
name|SDNode
operator|*
argument_list|,
name|SDNode
operator|*
argument_list|)
operator|>
name|Callback
block|;
name|DAGNodeDeletedListener
argument_list|(
name|SelectionDAG
operator|&
name|DAG
argument_list|,
name|std
operator|::
name|function
operator|<
name|void
argument_list|(
name|SDNode
operator|*
argument_list|,
name|SDNode
operator|*
argument_list|)
operator|>
name|Callback
argument_list|)
operator|:
name|DAGUpdateListener
argument_list|(
name|DAG
argument_list|)
block|,
name|Callback
argument_list|(
argument|Callback
argument_list|)
block|{}
name|void
name|NodeDeleted
argument_list|(
argument|SDNode *N
argument_list|,
argument|SDNode *E
argument_list|)
name|override
block|{
name|Callback
argument_list|(
name|N
argument_list|,
name|E
argument_list|)
block|; }
block|}
decl_stmt|;
comment|/// When true, additional steps are taken to
comment|/// ensure that getConstant() and similar functions return DAG nodes that
comment|/// have legal types. This is important after type legalization since
comment|/// any illegally typed nodes generated after this point will not experience
comment|/// type legalization.
name|bool
name|NewNodesMustHaveLegalTypes
decl_stmt|;
name|private
label|:
comment|/// DAGUpdateListener is a friend so it can manipulate the listener stack.
name|friend
struct_decl|struct
name|DAGUpdateListener
struct_decl|;
comment|/// Linked list of registered DAGUpdateListener instances.
comment|/// This stack is maintained by DAGUpdateListener RAII.
name|DAGUpdateListener
modifier|*
name|UpdateListeners
decl_stmt|;
comment|/// Implementation of setSubgraphColor.
comment|/// Return whether we had to truncate the search.
name|bool
name|setSubgraphColorHelper
argument_list|(
name|SDNode
operator|*
name|N
argument_list|,
specifier|const
name|char
operator|*
name|Color
argument_list|,
name|DenseSet
operator|<
name|SDNode
operator|*
operator|>
operator|&
name|visited
argument_list|,
name|int
name|level
argument_list|,
name|bool
operator|&
name|printed
argument_list|)
decl_stmt|;
name|template
operator|<
name|typename
name|SDNodeT
operator|,
name|typename
operator|...
name|ArgTypes
operator|>
name|SDNodeT
operator|*
name|newSDNode
argument_list|(
argument|ArgTypes&&... Args
argument_list|)
block|{
return|return
name|new
argument_list|(
argument|NodeAllocator.template Allocate<SDNodeT>()
argument_list|)
name|SDNodeT
argument_list|(
name|std
operator|::
name|forward
operator|<
name|ArgTypes
operator|>
operator|(
name|Args
operator|)
operator|...
argument_list|)
return|;
block|}
comment|/// Build a synthetic SDNodeT with the given args and extract its subclass
comment|/// data as an integer (e.g. for use in a folding set).
comment|///
comment|/// The args to this function are the same as the args to SDNodeT's
comment|/// constructor, except the second arg (assumed to be a const DebugLoc&) is
comment|/// omitted.
name|template
operator|<
name|typename
name|SDNodeT
operator|,
name|typename
operator|...
name|ArgTypes
operator|>
specifier|static
name|uint16_t
name|getSyntheticNodeSubclassData
argument_list|(
argument|unsigned IROrder
argument_list|,
argument|ArgTypes&&... Args
argument_list|)
block|{
comment|// The compiler can reduce this expression to a constant iff we pass an
comment|// empty DebugLoc.  Thankfully, the debug location doesn't have any bearing
comment|// on the subclass data.
return|return
name|SDNodeT
argument_list|(
name|IROrder
argument_list|,
name|DebugLoc
argument_list|()
argument_list|,
name|std
operator|::
name|forward
operator|<
name|ArgTypes
operator|>
operator|(
name|Args
operator|)
operator|...
argument_list|)
operator|.
name|getRawSubclassData
argument_list|()
return|;
block|}
name|void
name|createOperands
argument_list|(
name|SDNode
operator|*
name|Node
argument_list|,
name|ArrayRef
operator|<
name|SDValue
operator|>
name|Vals
argument_list|)
block|{
name|assert
argument_list|(
operator|!
name|Node
operator|->
name|OperandList
operator|&&
literal|"Node already has operands"
argument_list|)
expr_stmt|;
name|SDUse
modifier|*
name|Ops
init|=
name|OperandRecycler
operator|.
name|allocate
argument_list|(
name|ArrayRecycler
operator|<
name|SDUse
operator|>
operator|::
name|Capacity
operator|::
name|get
argument_list|(
name|Vals
operator|.
name|size
argument_list|()
argument_list|)
argument_list|,
name|OperandAllocator
argument_list|)
decl_stmt|;
for|for
control|(
name|unsigned
name|I
init|=
literal|0
init|;
name|I
operator|!=
name|Vals
operator|.
name|size
argument_list|()
condition|;
operator|++
name|I
control|)
block|{
name|Ops
index|[
name|I
index|]
operator|.
name|setUser
argument_list|(
name|Node
argument_list|)
expr_stmt|;
name|Ops
index|[
name|I
index|]
operator|.
name|setInitial
argument_list|(
name|Vals
index|[
name|I
index|]
argument_list|)
expr_stmt|;
block|}
name|Node
operator|->
name|NumOperands
operator|=
name|Vals
operator|.
name|size
argument_list|()
expr_stmt|;
name|Node
operator|->
name|OperandList
operator|=
name|Ops
expr_stmt|;
name|checkForCycles
argument_list|(
name|Node
argument_list|)
expr_stmt|;
block|}
name|void
name|removeOperands
parameter_list|(
name|SDNode
modifier|*
name|Node
parameter_list|)
block|{
if|if
condition|(
operator|!
name|Node
operator|->
name|OperandList
condition|)
return|return;
name|OperandRecycler
operator|.
name|deallocate
argument_list|(
name|ArrayRecycler
operator|<
name|SDUse
operator|>
operator|::
name|Capacity
operator|::
name|get
argument_list|(
name|Node
operator|->
name|NumOperands
argument_list|)
argument_list|,
name|Node
operator|->
name|OperandList
argument_list|)
expr_stmt|;
name|Node
operator|->
name|NumOperands
operator|=
literal|0
expr_stmt|;
name|Node
operator|->
name|OperandList
operator|=
name|nullptr
expr_stmt|;
block|}
name|void
name|operator
init|=
operator|(
specifier|const
name|SelectionDAG
operator|&
operator|)
operator|=
name|delete
decl_stmt|;
name|SelectionDAG
argument_list|(
specifier|const
name|SelectionDAG
operator|&
argument_list|)
operator|=
name|delete
expr_stmt|;
name|public
label|:
name|explicit
name|SelectionDAG
argument_list|(
specifier|const
name|TargetMachine
operator|&
name|TM
argument_list|,
name|llvm
operator|::
name|CodeGenOpt
operator|::
name|Level
argument_list|)
decl_stmt|;
operator|~
name|SelectionDAG
argument_list|()
expr_stmt|;
comment|/// Prepare this SelectionDAG to process code in the given MachineFunction.
name|void
name|init
parameter_list|(
name|MachineFunction
modifier|&
name|mf
parameter_list|)
function_decl|;
comment|/// Clear state and free memory necessary to make this
comment|/// SelectionDAG ready to process a new block.
name|void
name|clear
parameter_list|()
function_decl|;
name|MachineFunction
operator|&
name|getMachineFunction
argument_list|()
specifier|const
block|{
return|return
operator|*
name|MF
return|;
block|}
specifier|const
name|DataLayout
operator|&
name|getDataLayout
argument_list|()
specifier|const
block|{
return|return
name|MF
operator|->
name|getDataLayout
argument_list|()
return|;
block|}
specifier|const
name|TargetMachine
operator|&
name|getTarget
argument_list|()
specifier|const
block|{
return|return
name|TM
return|;
block|}
specifier|const
name|TargetSubtargetInfo
operator|&
name|getSubtarget
argument_list|()
specifier|const
block|{
return|return
name|MF
operator|->
name|getSubtarget
argument_list|()
return|;
block|}
specifier|const
name|TargetLowering
operator|&
name|getTargetLoweringInfo
argument_list|()
specifier|const
block|{
return|return
operator|*
name|TLI
return|;
block|}
specifier|const
name|SelectionDAGTargetInfo
operator|&
name|getSelectionDAGInfo
argument_list|()
specifier|const
block|{
return|return
operator|*
name|TSI
return|;
block|}
name|LLVMContext
operator|*
name|getContext
argument_list|()
specifier|const
block|{
return|return
name|Context
return|;
block|}
comment|/// Pop up a GraphViz/gv window with the DAG rendered using 'dot'.
name|void
name|viewGraph
argument_list|(
specifier|const
name|std
operator|::
name|string
operator|&
name|Title
argument_list|)
decl_stmt|;
name|void
name|viewGraph
parameter_list|()
function_decl|;
ifndef|#
directive|ifndef
name|NDEBUG
name|std
operator|::
name|map
operator|<
specifier|const
name|SDNode
operator|*
operator|,
name|std
operator|::
name|string
operator|>
name|NodeGraphAttrs
expr_stmt|;
endif|#
directive|endif
comment|/// Clear all previously defined node graph attributes.
comment|/// Intended to be used from a debugging tool (eg. gdb).
name|void
name|clearGraphAttrs
parameter_list|()
function_decl|;
comment|/// Set graph attributes for a node. (eg. "color=red".)
name|void
name|setGraphAttrs
parameter_list|(
specifier|const
name|SDNode
modifier|*
name|N
parameter_list|,
specifier|const
name|char
modifier|*
name|Attrs
parameter_list|)
function_decl|;
comment|/// Get graph attributes for a node. (eg. "color=red".)
comment|/// Used from getNodeAttributes.
specifier|const
name|std
operator|::
name|string
name|getGraphAttrs
argument_list|(
argument|const SDNode *N
argument_list|)
specifier|const
expr_stmt|;
comment|/// Convenience for setting node color attribute.
name|void
name|setGraphColor
parameter_list|(
specifier|const
name|SDNode
modifier|*
name|N
parameter_list|,
specifier|const
name|char
modifier|*
name|Color
parameter_list|)
function_decl|;
comment|/// Convenience for setting subgraph color attribute.
name|void
name|setSubgraphColor
parameter_list|(
name|SDNode
modifier|*
name|N
parameter_list|,
specifier|const
name|char
modifier|*
name|Color
parameter_list|)
function_decl|;
typedef|typedef
name|ilist
operator|<
name|SDNode
operator|>
operator|::
name|const_iterator
name|allnodes_const_iterator
expr_stmt|;
name|allnodes_const_iterator
name|allnodes_begin
argument_list|()
specifier|const
block|{
return|return
name|AllNodes
operator|.
name|begin
argument_list|()
return|;
block|}
name|allnodes_const_iterator
name|allnodes_end
argument_list|()
specifier|const
block|{
return|return
name|AllNodes
operator|.
name|end
argument_list|()
return|;
block|}
typedef|typedef
name|ilist
operator|<
name|SDNode
operator|>
operator|::
name|iterator
name|allnodes_iterator
expr_stmt|;
name|allnodes_iterator
name|allnodes_begin
parameter_list|()
block|{
return|return
name|AllNodes
operator|.
name|begin
argument_list|()
return|;
block|}
name|allnodes_iterator
name|allnodes_end
parameter_list|()
block|{
return|return
name|AllNodes
operator|.
name|end
argument_list|()
return|;
block|}
name|ilist
operator|<
name|SDNode
operator|>
operator|::
name|size_type
name|allnodes_size
argument_list|()
specifier|const
block|{
return|return
name|AllNodes
operator|.
name|size
argument_list|()
return|;
block|}
name|iterator_range
operator|<
name|allnodes_iterator
operator|>
name|allnodes
argument_list|()
block|{
return|return
name|make_range
argument_list|(
name|allnodes_begin
argument_list|()
argument_list|,
name|allnodes_end
argument_list|()
argument_list|)
return|;
block|}
name|iterator_range
operator|<
name|allnodes_const_iterator
operator|>
name|allnodes
argument_list|()
specifier|const
block|{
return|return
name|make_range
argument_list|(
name|allnodes_begin
argument_list|()
argument_list|,
name|allnodes_end
argument_list|()
argument_list|)
return|;
block|}
comment|/// Return the root tag of the SelectionDAG.
specifier|const
name|SDValue
operator|&
name|getRoot
argument_list|()
specifier|const
block|{
return|return
name|Root
return|;
block|}
comment|/// Return the token chain corresponding to the entry of the function.
name|SDValue
name|getEntryNode
argument_list|()
specifier|const
block|{
return|return
name|SDValue
argument_list|(
name|const_cast
operator|<
name|SDNode
operator|*
operator|>
operator|(
operator|&
name|EntryNode
operator|)
argument_list|,
literal|0
argument_list|)
return|;
block|}
comment|/// Set the current root tag of the SelectionDAG.
comment|///
specifier|const
name|SDValue
modifier|&
name|setRoot
parameter_list|(
name|SDValue
name|N
parameter_list|)
block|{
name|assert
argument_list|(
operator|(
operator|!
name|N
operator|.
name|getNode
argument_list|()
operator|||
name|N
operator|.
name|getValueType
argument_list|()
operator|==
name|MVT
operator|::
name|Other
operator|)
operator|&&
literal|"DAG root value is not a chain!"
argument_list|)
expr_stmt|;
if|if
condition|(
name|N
operator|.
name|getNode
argument_list|()
condition|)
name|checkForCycles
argument_list|(
name|N
operator|.
name|getNode
argument_list|()
argument_list|,
name|this
argument_list|)
expr_stmt|;
name|Root
operator|=
name|N
expr_stmt|;
if|if
condition|(
name|N
operator|.
name|getNode
argument_list|()
condition|)
name|checkForCycles
argument_list|(
name|this
argument_list|)
expr_stmt|;
return|return
name|Root
return|;
block|}
comment|/// This iterates over the nodes in the SelectionDAG, folding
comment|/// certain types of nodes together, or eliminating superfluous nodes.  The
comment|/// Level argument controls whether Combine is allowed to produce nodes and
comment|/// types that are illegal on the target.
name|void
name|Combine
argument_list|(
name|CombineLevel
name|Level
argument_list|,
name|AliasAnalysis
operator|&
name|AA
argument_list|,
name|CodeGenOpt
operator|::
name|Level
name|OptLevel
argument_list|)
decl_stmt|;
comment|/// This transforms the SelectionDAG into a SelectionDAG that
comment|/// only uses types natively supported by the target.
comment|/// Returns "true" if it made any changes.
comment|///
comment|/// Note that this is an involved process that may invalidate pointers into
comment|/// the graph.
name|bool
name|LegalizeTypes
parameter_list|()
function_decl|;
comment|/// This transforms the SelectionDAG into a SelectionDAG that is
comment|/// compatible with the target instruction selector, as indicated by the
comment|/// TargetLowering object.
comment|///
comment|/// Note that this is an involved process that may invalidate pointers into
comment|/// the graph.
name|void
name|Legalize
parameter_list|()
function_decl|;
comment|/// \brief Transforms a SelectionDAG node and any operands to it into a node
comment|/// that is compatible with the target instruction selector, as indicated by
comment|/// the TargetLowering object.
comment|///
comment|/// \returns true if \c N is a valid, legal node after calling this.
comment|///
comment|/// This essentially runs a single recursive walk of the \c Legalize process
comment|/// over the given node (and its operands). This can be used to incrementally
comment|/// legalize the DAG. All of the nodes which are directly replaced,
comment|/// potentially including N, are added to the output parameter \c
comment|/// UpdatedNodes so that the delta to the DAG can be understood by the
comment|/// caller.
comment|///
comment|/// When this returns false, N has been legalized in a way that make the
comment|/// pointer passed in no longer valid. It may have even been deleted from the
comment|/// DAG, and so it shouldn't be used further. When this returns true, the
comment|/// N passed in is a legal node, and can be immediately processed as such.
comment|/// This may still have done some work on the DAG, and will still populate
comment|/// UpdatedNodes with any new nodes replacing those originally in the DAG.
name|bool
name|LegalizeOp
argument_list|(
name|SDNode
operator|*
name|N
argument_list|,
name|SmallSetVector
operator|<
name|SDNode
operator|*
argument_list|,
literal|16
operator|>
operator|&
name|UpdatedNodes
argument_list|)
decl_stmt|;
comment|/// This transforms the SelectionDAG into a SelectionDAG
comment|/// that only uses vector math operations supported by the target.  This is
comment|/// necessary as a separate step from Legalize because unrolling a vector
comment|/// operation can introduce illegal types, which requires running
comment|/// LegalizeTypes again.
comment|///
comment|/// This returns true if it made any changes; in that case, LegalizeTypes
comment|/// is called again before Legalize.
comment|///
comment|/// Note that this is an involved process that may invalidate pointers into
comment|/// the graph.
name|bool
name|LegalizeVectors
parameter_list|()
function_decl|;
comment|/// This method deletes all unreachable nodes in the SelectionDAG.
name|void
name|RemoveDeadNodes
parameter_list|()
function_decl|;
comment|/// Remove the specified node from the system.  This node must
comment|/// have no referrers.
name|void
name|DeleteNode
parameter_list|(
name|SDNode
modifier|*
name|N
parameter_list|)
function_decl|;
comment|/// Return an SDVTList that represents the list of values specified.
name|SDVTList
name|getVTList
parameter_list|(
name|EVT
name|VT
parameter_list|)
function_decl|;
name|SDVTList
name|getVTList
parameter_list|(
name|EVT
name|VT1
parameter_list|,
name|EVT
name|VT2
parameter_list|)
function_decl|;
name|SDVTList
name|getVTList
parameter_list|(
name|EVT
name|VT1
parameter_list|,
name|EVT
name|VT2
parameter_list|,
name|EVT
name|VT3
parameter_list|)
function_decl|;
name|SDVTList
name|getVTList
parameter_list|(
name|EVT
name|VT1
parameter_list|,
name|EVT
name|VT2
parameter_list|,
name|EVT
name|VT3
parameter_list|,
name|EVT
name|VT4
parameter_list|)
function_decl|;
name|SDVTList
name|getVTList
argument_list|(
name|ArrayRef
operator|<
name|EVT
operator|>
name|VTs
argument_list|)
decl_stmt|;
comment|//===--------------------------------------------------------------------===//
comment|// Node creation methods.
comment|//
comment|/// \brief Create a ConstantSDNode wrapping a constant value.
comment|/// If VT is a vector type, the constant is splatted into a BUILD_VECTOR.
comment|///
comment|/// If only legal types can be produced, this does the necessary
comment|/// transformations (e.g., if the vector element type is illegal).
comment|/// @{
name|SDValue
name|getConstant
parameter_list|(
name|uint64_t
name|Val
parameter_list|,
specifier|const
name|SDLoc
modifier|&
name|DL
parameter_list|,
name|EVT
name|VT
parameter_list|,
name|bool
name|isTarget
init|=
name|false
parameter_list|,
name|bool
name|isOpaque
init|=
name|false
parameter_list|)
function_decl|;
name|SDValue
name|getConstant
parameter_list|(
specifier|const
name|APInt
modifier|&
name|Val
parameter_list|,
specifier|const
name|SDLoc
modifier|&
name|DL
parameter_list|,
name|EVT
name|VT
parameter_list|,
name|bool
name|isTarget
init|=
name|false
parameter_list|,
name|bool
name|isOpaque
init|=
name|false
parameter_list|)
function_decl|;
name|SDValue
name|getConstant
parameter_list|(
specifier|const
name|ConstantInt
modifier|&
name|Val
parameter_list|,
specifier|const
name|SDLoc
modifier|&
name|DL
parameter_list|,
name|EVT
name|VT
parameter_list|,
name|bool
name|isTarget
init|=
name|false
parameter_list|,
name|bool
name|isOpaque
init|=
name|false
parameter_list|)
function_decl|;
name|SDValue
name|getIntPtrConstant
parameter_list|(
name|uint64_t
name|Val
parameter_list|,
specifier|const
name|SDLoc
modifier|&
name|DL
parameter_list|,
name|bool
name|isTarget
init|=
name|false
parameter_list|)
function_decl|;
name|SDValue
name|getTargetConstant
parameter_list|(
name|uint64_t
name|Val
parameter_list|,
specifier|const
name|SDLoc
modifier|&
name|DL
parameter_list|,
name|EVT
name|VT
parameter_list|,
name|bool
name|isOpaque
init|=
name|false
parameter_list|)
block|{
return|return
name|getConstant
argument_list|(
name|Val
argument_list|,
name|DL
argument_list|,
name|VT
argument_list|,
name|true
argument_list|,
name|isOpaque
argument_list|)
return|;
block|}
name|SDValue
name|getTargetConstant
parameter_list|(
specifier|const
name|APInt
modifier|&
name|Val
parameter_list|,
specifier|const
name|SDLoc
modifier|&
name|DL
parameter_list|,
name|EVT
name|VT
parameter_list|,
name|bool
name|isOpaque
init|=
name|false
parameter_list|)
block|{
return|return
name|getConstant
argument_list|(
name|Val
argument_list|,
name|DL
argument_list|,
name|VT
argument_list|,
name|true
argument_list|,
name|isOpaque
argument_list|)
return|;
block|}
name|SDValue
name|getTargetConstant
parameter_list|(
specifier|const
name|ConstantInt
modifier|&
name|Val
parameter_list|,
specifier|const
name|SDLoc
modifier|&
name|DL
parameter_list|,
name|EVT
name|VT
parameter_list|,
name|bool
name|isOpaque
init|=
name|false
parameter_list|)
block|{
return|return
name|getConstant
argument_list|(
name|Val
argument_list|,
name|DL
argument_list|,
name|VT
argument_list|,
name|true
argument_list|,
name|isOpaque
argument_list|)
return|;
block|}
comment|/// @}
comment|/// \brief Create a ConstantFPSDNode wrapping a constant value.
comment|/// If VT is a vector type, the constant is splatted into a BUILD_VECTOR.
comment|///
comment|/// If only legal types can be produced, this does the necessary
comment|/// transformations (e.g., if the vector element type is illegal).
comment|/// The forms that take a double should only be used for simple constants
comment|/// that can be exactly represented in VT.  No checks are made.
comment|/// @{
name|SDValue
name|getConstantFP
parameter_list|(
name|double
name|Val
parameter_list|,
specifier|const
name|SDLoc
modifier|&
name|DL
parameter_list|,
name|EVT
name|VT
parameter_list|,
name|bool
name|isTarget
init|=
name|false
parameter_list|)
function_decl|;
name|SDValue
name|getConstantFP
parameter_list|(
specifier|const
name|APFloat
modifier|&
name|Val
parameter_list|,
specifier|const
name|SDLoc
modifier|&
name|DL
parameter_list|,
name|EVT
name|VT
parameter_list|,
name|bool
name|isTarget
init|=
name|false
parameter_list|)
function_decl|;
name|SDValue
name|getConstantFP
parameter_list|(
specifier|const
name|ConstantFP
modifier|&
name|CF
parameter_list|,
specifier|const
name|SDLoc
modifier|&
name|DL
parameter_list|,
name|EVT
name|VT
parameter_list|,
name|bool
name|isTarget
init|=
name|false
parameter_list|)
function_decl|;
name|SDValue
name|getTargetConstantFP
parameter_list|(
name|double
name|Val
parameter_list|,
specifier|const
name|SDLoc
modifier|&
name|DL
parameter_list|,
name|EVT
name|VT
parameter_list|)
block|{
return|return
name|getConstantFP
argument_list|(
name|Val
argument_list|,
name|DL
argument_list|,
name|VT
argument_list|,
name|true
argument_list|)
return|;
block|}
name|SDValue
name|getTargetConstantFP
parameter_list|(
specifier|const
name|APFloat
modifier|&
name|Val
parameter_list|,
specifier|const
name|SDLoc
modifier|&
name|DL
parameter_list|,
name|EVT
name|VT
parameter_list|)
block|{
return|return
name|getConstantFP
argument_list|(
name|Val
argument_list|,
name|DL
argument_list|,
name|VT
argument_list|,
name|true
argument_list|)
return|;
block|}
name|SDValue
name|getTargetConstantFP
parameter_list|(
specifier|const
name|ConstantFP
modifier|&
name|Val
parameter_list|,
specifier|const
name|SDLoc
modifier|&
name|DL
parameter_list|,
name|EVT
name|VT
parameter_list|)
block|{
return|return
name|getConstantFP
argument_list|(
name|Val
argument_list|,
name|DL
argument_list|,
name|VT
argument_list|,
name|true
argument_list|)
return|;
block|}
comment|/// @}
name|SDValue
name|getGlobalAddress
parameter_list|(
specifier|const
name|GlobalValue
modifier|*
name|GV
parameter_list|,
specifier|const
name|SDLoc
modifier|&
name|DL
parameter_list|,
name|EVT
name|VT
parameter_list|,
name|int64_t
name|offset
init|=
literal|0
parameter_list|,
name|bool
name|isTargetGA
init|=
name|false
parameter_list|,
name|unsigned
name|char
name|TargetFlags
init|=
literal|0
parameter_list|)
function_decl|;
name|SDValue
name|getTargetGlobalAddress
parameter_list|(
specifier|const
name|GlobalValue
modifier|*
name|GV
parameter_list|,
specifier|const
name|SDLoc
modifier|&
name|DL
parameter_list|,
name|EVT
name|VT
parameter_list|,
name|int64_t
name|offset
init|=
literal|0
parameter_list|,
name|unsigned
name|char
name|TargetFlags
init|=
literal|0
parameter_list|)
block|{
return|return
name|getGlobalAddress
argument_list|(
name|GV
argument_list|,
name|DL
argument_list|,
name|VT
argument_list|,
name|offset
argument_list|,
name|true
argument_list|,
name|TargetFlags
argument_list|)
return|;
block|}
name|SDValue
name|getFrameIndex
parameter_list|(
name|int
name|FI
parameter_list|,
name|EVT
name|VT
parameter_list|,
name|bool
name|isTarget
init|=
name|false
parameter_list|)
function_decl|;
name|SDValue
name|getTargetFrameIndex
parameter_list|(
name|int
name|FI
parameter_list|,
name|EVT
name|VT
parameter_list|)
block|{
return|return
name|getFrameIndex
argument_list|(
name|FI
argument_list|,
name|VT
argument_list|,
name|true
argument_list|)
return|;
block|}
name|SDValue
name|getJumpTable
parameter_list|(
name|int
name|JTI
parameter_list|,
name|EVT
name|VT
parameter_list|,
name|bool
name|isTarget
init|=
name|false
parameter_list|,
name|unsigned
name|char
name|TargetFlags
init|=
literal|0
parameter_list|)
function_decl|;
name|SDValue
name|getTargetJumpTable
parameter_list|(
name|int
name|JTI
parameter_list|,
name|EVT
name|VT
parameter_list|,
name|unsigned
name|char
name|TargetFlags
init|=
literal|0
parameter_list|)
block|{
return|return
name|getJumpTable
argument_list|(
name|JTI
argument_list|,
name|VT
argument_list|,
name|true
argument_list|,
name|TargetFlags
argument_list|)
return|;
block|}
name|SDValue
name|getConstantPool
parameter_list|(
specifier|const
name|Constant
modifier|*
name|C
parameter_list|,
name|EVT
name|VT
parameter_list|,
name|unsigned
name|Align
init|=
literal|0
parameter_list|,
name|int
name|Offs
init|=
literal|0
parameter_list|,
name|bool
name|isT
init|=
name|false
parameter_list|,
name|unsigned
name|char
name|TargetFlags
init|=
literal|0
parameter_list|)
function_decl|;
name|SDValue
name|getTargetConstantPool
parameter_list|(
specifier|const
name|Constant
modifier|*
name|C
parameter_list|,
name|EVT
name|VT
parameter_list|,
name|unsigned
name|Align
init|=
literal|0
parameter_list|,
name|int
name|Offset
init|=
literal|0
parameter_list|,
name|unsigned
name|char
name|TargetFlags
init|=
literal|0
parameter_list|)
block|{
return|return
name|getConstantPool
argument_list|(
name|C
argument_list|,
name|VT
argument_list|,
name|Align
argument_list|,
name|Offset
argument_list|,
name|true
argument_list|,
name|TargetFlags
argument_list|)
return|;
block|}
name|SDValue
name|getConstantPool
parameter_list|(
name|MachineConstantPoolValue
modifier|*
name|C
parameter_list|,
name|EVT
name|VT
parameter_list|,
name|unsigned
name|Align
init|=
literal|0
parameter_list|,
name|int
name|Offs
init|=
literal|0
parameter_list|,
name|bool
name|isT
init|=
name|false
parameter_list|,
name|unsigned
name|char
name|TargetFlags
init|=
literal|0
parameter_list|)
function_decl|;
name|SDValue
name|getTargetConstantPool
parameter_list|(
name|MachineConstantPoolValue
modifier|*
name|C
parameter_list|,
name|EVT
name|VT
parameter_list|,
name|unsigned
name|Align
init|=
literal|0
parameter_list|,
name|int
name|Offset
init|=
literal|0
parameter_list|,
name|unsigned
name|char
name|TargetFlags
init|=
literal|0
parameter_list|)
block|{
return|return
name|getConstantPool
argument_list|(
name|C
argument_list|,
name|VT
argument_list|,
name|Align
argument_list|,
name|Offset
argument_list|,
name|true
argument_list|,
name|TargetFlags
argument_list|)
return|;
block|}
name|SDValue
name|getTargetIndex
parameter_list|(
name|int
name|Index
parameter_list|,
name|EVT
name|VT
parameter_list|,
name|int64_t
name|Offset
init|=
literal|0
parameter_list|,
name|unsigned
name|char
name|TargetFlags
init|=
literal|0
parameter_list|)
function_decl|;
comment|// When generating a branch to a BB, we don't in general know enough
comment|// to provide debug info for the BB at that time, so keep this one around.
name|SDValue
name|getBasicBlock
parameter_list|(
name|MachineBasicBlock
modifier|*
name|MBB
parameter_list|)
function_decl|;
name|SDValue
name|getBasicBlock
parameter_list|(
name|MachineBasicBlock
modifier|*
name|MBB
parameter_list|,
name|SDLoc
name|dl
parameter_list|)
function_decl|;
name|SDValue
name|getExternalSymbol
parameter_list|(
specifier|const
name|char
modifier|*
name|Sym
parameter_list|,
name|EVT
name|VT
parameter_list|)
function_decl|;
name|SDValue
name|getExternalSymbol
parameter_list|(
specifier|const
name|char
modifier|*
name|Sym
parameter_list|,
specifier|const
name|SDLoc
modifier|&
name|dl
parameter_list|,
name|EVT
name|VT
parameter_list|)
function_decl|;
name|SDValue
name|getTargetExternalSymbol
parameter_list|(
specifier|const
name|char
modifier|*
name|Sym
parameter_list|,
name|EVT
name|VT
parameter_list|,
name|unsigned
name|char
name|TargetFlags
init|=
literal|0
parameter_list|)
function_decl|;
name|SDValue
name|getMCSymbol
parameter_list|(
name|MCSymbol
modifier|*
name|Sym
parameter_list|,
name|EVT
name|VT
parameter_list|)
function_decl|;
name|SDValue
name|getValueType
parameter_list|(
name|EVT
parameter_list|)
function_decl|;
name|SDValue
name|getRegister
parameter_list|(
name|unsigned
name|Reg
parameter_list|,
name|EVT
name|VT
parameter_list|)
function_decl|;
name|SDValue
name|getRegisterMask
parameter_list|(
specifier|const
name|uint32_t
modifier|*
name|RegMask
parameter_list|)
function_decl|;
name|SDValue
name|getEHLabel
parameter_list|(
specifier|const
name|SDLoc
modifier|&
name|dl
parameter_list|,
name|SDValue
name|Root
parameter_list|,
name|MCSymbol
modifier|*
name|Label
parameter_list|)
function_decl|;
name|SDValue
name|getBlockAddress
parameter_list|(
specifier|const
name|BlockAddress
modifier|*
name|BA
parameter_list|,
name|EVT
name|VT
parameter_list|,
name|int64_t
name|Offset
init|=
literal|0
parameter_list|,
name|bool
name|isTarget
init|=
name|false
parameter_list|,
name|unsigned
name|char
name|TargetFlags
init|=
literal|0
parameter_list|)
function_decl|;
name|SDValue
name|getTargetBlockAddress
parameter_list|(
specifier|const
name|BlockAddress
modifier|*
name|BA
parameter_list|,
name|EVT
name|VT
parameter_list|,
name|int64_t
name|Offset
init|=
literal|0
parameter_list|,
name|unsigned
name|char
name|TargetFlags
init|=
literal|0
parameter_list|)
block|{
return|return
name|getBlockAddress
argument_list|(
name|BA
argument_list|,
name|VT
argument_list|,
name|Offset
argument_list|,
name|true
argument_list|,
name|TargetFlags
argument_list|)
return|;
block|}
name|SDValue
name|getCopyToReg
parameter_list|(
name|SDValue
name|Chain
parameter_list|,
specifier|const
name|SDLoc
modifier|&
name|dl
parameter_list|,
name|unsigned
name|Reg
parameter_list|,
name|SDValue
name|N
parameter_list|)
block|{
return|return
name|getNode
argument_list|(
name|ISD
operator|::
name|CopyToReg
argument_list|,
name|dl
argument_list|,
name|MVT
operator|::
name|Other
argument_list|,
name|Chain
argument_list|,
name|getRegister
argument_list|(
name|Reg
argument_list|,
name|N
operator|.
name|getValueType
argument_list|()
argument_list|)
argument_list|,
name|N
argument_list|)
return|;
block|}
comment|// This version of the getCopyToReg method takes an extra operand, which
comment|// indicates that there is potentially an incoming glue value (if Glue is not
comment|// null) and that there should be a glue result.
name|SDValue
name|getCopyToReg
parameter_list|(
name|SDValue
name|Chain
parameter_list|,
specifier|const
name|SDLoc
modifier|&
name|dl
parameter_list|,
name|unsigned
name|Reg
parameter_list|,
name|SDValue
name|N
parameter_list|,
name|SDValue
name|Glue
parameter_list|)
block|{
name|SDVTList
name|VTs
init|=
name|getVTList
argument_list|(
name|MVT
operator|::
name|Other
argument_list|,
name|MVT
operator|::
name|Glue
argument_list|)
decl_stmt|;
name|SDValue
name|Ops
index|[]
init|=
block|{
name|Chain
block|,
name|getRegister
argument_list|(
name|Reg
argument_list|,
name|N
operator|.
name|getValueType
argument_list|()
argument_list|)
block|,
name|N
block|,
name|Glue
block|}
decl_stmt|;
return|return
name|getNode
argument_list|(
name|ISD
operator|::
name|CopyToReg
argument_list|,
name|dl
argument_list|,
name|VTs
argument_list|,
name|makeArrayRef
argument_list|(
name|Ops
argument_list|,
name|Glue
operator|.
name|getNode
argument_list|()
condition|?
literal|4
else|:
literal|3
argument_list|)
argument_list|)
return|;
block|}
comment|// Similar to last getCopyToReg() except parameter Reg is a SDValue
name|SDValue
name|getCopyToReg
parameter_list|(
name|SDValue
name|Chain
parameter_list|,
specifier|const
name|SDLoc
modifier|&
name|dl
parameter_list|,
name|SDValue
name|Reg
parameter_list|,
name|SDValue
name|N
parameter_list|,
name|SDValue
name|Glue
parameter_list|)
block|{
name|SDVTList
name|VTs
init|=
name|getVTList
argument_list|(
name|MVT
operator|::
name|Other
argument_list|,
name|MVT
operator|::
name|Glue
argument_list|)
decl_stmt|;
name|SDValue
name|Ops
index|[]
init|=
block|{
name|Chain
block|,
name|Reg
block|,
name|N
block|,
name|Glue
block|}
decl_stmt|;
return|return
name|getNode
argument_list|(
name|ISD
operator|::
name|CopyToReg
argument_list|,
name|dl
argument_list|,
name|VTs
argument_list|,
name|makeArrayRef
argument_list|(
name|Ops
argument_list|,
name|Glue
operator|.
name|getNode
argument_list|()
condition|?
literal|4
else|:
literal|3
argument_list|)
argument_list|)
return|;
block|}
name|SDValue
name|getCopyFromReg
parameter_list|(
name|SDValue
name|Chain
parameter_list|,
specifier|const
name|SDLoc
modifier|&
name|dl
parameter_list|,
name|unsigned
name|Reg
parameter_list|,
name|EVT
name|VT
parameter_list|)
block|{
name|SDVTList
name|VTs
init|=
name|getVTList
argument_list|(
name|VT
argument_list|,
name|MVT
operator|::
name|Other
argument_list|)
decl_stmt|;
name|SDValue
name|Ops
index|[]
init|=
block|{
name|Chain
block|,
name|getRegister
argument_list|(
argument|Reg
argument_list|,
argument|VT
argument_list|)
block|}
decl_stmt|;
return|return
name|getNode
argument_list|(
name|ISD
operator|::
name|CopyFromReg
argument_list|,
name|dl
argument_list|,
name|VTs
argument_list|,
name|Ops
argument_list|)
return|;
block|}
comment|// This version of the getCopyFromReg method takes an extra operand, which
comment|// indicates that there is potentially an incoming glue value (if Glue is not
comment|// null) and that there should be a glue result.
name|SDValue
name|getCopyFromReg
parameter_list|(
name|SDValue
name|Chain
parameter_list|,
specifier|const
name|SDLoc
modifier|&
name|dl
parameter_list|,
name|unsigned
name|Reg
parameter_list|,
name|EVT
name|VT
parameter_list|,
name|SDValue
name|Glue
parameter_list|)
block|{
name|SDVTList
name|VTs
init|=
name|getVTList
argument_list|(
name|VT
argument_list|,
name|MVT
operator|::
name|Other
argument_list|,
name|MVT
operator|::
name|Glue
argument_list|)
decl_stmt|;
name|SDValue
name|Ops
index|[]
init|=
block|{
name|Chain
block|,
name|getRegister
argument_list|(
name|Reg
argument_list|,
name|VT
argument_list|)
block|,
name|Glue
block|}
decl_stmt|;
return|return
name|getNode
argument_list|(
name|ISD
operator|::
name|CopyFromReg
argument_list|,
name|dl
argument_list|,
name|VTs
argument_list|,
name|makeArrayRef
argument_list|(
name|Ops
argument_list|,
name|Glue
operator|.
name|getNode
argument_list|()
condition|?
literal|3
else|:
literal|2
argument_list|)
argument_list|)
return|;
block|}
name|SDValue
name|getCondCode
argument_list|(
name|ISD
operator|::
name|CondCode
name|Cond
argument_list|)
decl_stmt|;
comment|/// Returns the ConvertRndSat Note: Avoid using this node because it may
comment|/// disappear in the future and most targets don't support it.
name|SDValue
name|getConvertRndSat
argument_list|(
name|EVT
name|VT
argument_list|,
specifier|const
name|SDLoc
operator|&
name|dl
argument_list|,
name|SDValue
name|Val
argument_list|,
name|SDValue
name|DTy
argument_list|,
name|SDValue
name|STy
argument_list|,
name|SDValue
name|Rnd
argument_list|,
name|SDValue
name|Sat
argument_list|,
name|ISD
operator|::
name|CvtCode
name|Code
argument_list|)
decl_stmt|;
comment|/// Return an ISD::VECTOR_SHUFFLE node. The number of elements in VT,
comment|/// which must be a vector type, must match the number of mask elements
comment|/// NumElts. An integer mask element equal to -1 is treated as undefined.
name|SDValue
name|getVectorShuffle
argument_list|(
name|EVT
name|VT
argument_list|,
specifier|const
name|SDLoc
operator|&
name|dl
argument_list|,
name|SDValue
name|N1
argument_list|,
name|SDValue
name|N2
argument_list|,
name|ArrayRef
operator|<
name|int
operator|>
name|Mask
argument_list|)
decl_stmt|;
comment|/// Return an ISD::BUILD_VECTOR node. The number of elements in VT,
comment|/// which must be a vector type, must match the number of operands in Ops.
comment|/// The operands must have the same type as (or, for integers, a type wider
comment|/// than) VT's element type.
name|SDValue
name|getBuildVector
argument_list|(
name|EVT
name|VT
argument_list|,
specifier|const
name|SDLoc
operator|&
name|DL
argument_list|,
name|ArrayRef
operator|<
name|SDValue
operator|>
name|Ops
argument_list|)
block|{
comment|// VerifySDNode (via InsertNode) checks BUILD_VECTOR later.
return|return
name|getNode
argument_list|(
name|ISD
operator|::
name|BUILD_VECTOR
argument_list|,
name|DL
argument_list|,
name|VT
argument_list|,
name|Ops
argument_list|)
return|;
block|}
comment|/// Return a splat ISD::BUILD_VECTOR node, consisting of Op splatted to all
comment|/// elements. VT must be a vector type. Op's type must be the same as (or,
comment|/// for integers, a type wider than) VT's element type.
name|SDValue
name|getSplatBuildVector
parameter_list|(
name|EVT
name|VT
parameter_list|,
specifier|const
name|SDLoc
modifier|&
name|DL
parameter_list|,
name|SDValue
name|Op
parameter_list|)
block|{
comment|// VerifySDNode (via InsertNode) checks BUILD_VECTOR later.
if|if
condition|(
name|Op
operator|.
name|getOpcode
argument_list|()
operator|==
name|ISD
operator|::
name|UNDEF
condition|)
block|{
name|assert
argument_list|(
operator|(
name|VT
operator|.
name|getVectorElementType
argument_list|()
operator|==
name|Op
operator|.
name|getValueType
argument_list|()
operator|||
operator|(
name|VT
operator|.
name|isInteger
argument_list|()
operator|&&
name|VT
operator|.
name|getVectorElementType
argument_list|()
operator|.
name|bitsLE
argument_list|(
name|Op
operator|.
name|getValueType
argument_list|()
argument_list|)
operator|)
operator|)
operator|&&
literal|"A splatted value must have a width equal or (for integers) "
literal|"greater than the vector element type!"
argument_list|)
expr_stmt|;
return|return
name|getNode
argument_list|(
name|ISD
operator|::
name|UNDEF
argument_list|,
name|SDLoc
argument_list|()
argument_list|,
name|VT
argument_list|)
return|;
block|}
name|SmallVector
operator|<
name|SDValue
operator|,
literal|16
operator|>
name|Ops
argument_list|(
name|VT
operator|.
name|getVectorNumElements
argument_list|()
argument_list|,
name|Op
argument_list|)
expr_stmt|;
return|return
name|getNode
argument_list|(
name|ISD
operator|::
name|BUILD_VECTOR
argument_list|,
name|DL
argument_list|,
name|VT
argument_list|,
name|Ops
argument_list|)
return|;
block|}
comment|/// \brief Returns an ISD::VECTOR_SHUFFLE node semantically equivalent to
comment|/// the shuffle node in input but with swapped operands.
comment|///
comment|/// Example: shuffle A, B,<0,5,2,7> -> shuffle B, A,<4,1,6,3>
name|SDValue
name|getCommutedVectorShuffle
parameter_list|(
specifier|const
name|ShuffleVectorSDNode
modifier|&
name|SV
parameter_list|)
function_decl|;
comment|/// Convert Op, which must be of integer type, to the
comment|/// integer type VT, by either any-extending or truncating it.
name|SDValue
name|getAnyExtOrTrunc
parameter_list|(
name|SDValue
name|Op
parameter_list|,
specifier|const
name|SDLoc
modifier|&
name|DL
parameter_list|,
name|EVT
name|VT
parameter_list|)
function_decl|;
comment|/// Convert Op, which must be of integer type, to the
comment|/// integer type VT, by either sign-extending or truncating it.
name|SDValue
name|getSExtOrTrunc
parameter_list|(
name|SDValue
name|Op
parameter_list|,
specifier|const
name|SDLoc
modifier|&
name|DL
parameter_list|,
name|EVT
name|VT
parameter_list|)
function_decl|;
comment|/// Convert Op, which must be of integer type, to the
comment|/// integer type VT, by either zero-extending or truncating it.
name|SDValue
name|getZExtOrTrunc
parameter_list|(
name|SDValue
name|Op
parameter_list|,
specifier|const
name|SDLoc
modifier|&
name|DL
parameter_list|,
name|EVT
name|VT
parameter_list|)
function_decl|;
comment|/// Return the expression required to zero extend the Op
comment|/// value assuming it was the smaller SrcTy value.
name|SDValue
name|getZeroExtendInReg
parameter_list|(
name|SDValue
name|Op
parameter_list|,
specifier|const
name|SDLoc
modifier|&
name|DL
parameter_list|,
name|EVT
name|SrcTy
parameter_list|)
function_decl|;
comment|/// Return an operation which will any-extend the low lanes of the operand
comment|/// into the specified vector type. For example,
comment|/// this can convert a v16i8 into a v4i32 by any-extending the low four
comment|/// lanes of the operand from i8 to i32.
name|SDValue
name|getAnyExtendVectorInReg
parameter_list|(
name|SDValue
name|Op
parameter_list|,
specifier|const
name|SDLoc
modifier|&
name|DL
parameter_list|,
name|EVT
name|VT
parameter_list|)
function_decl|;
comment|/// Return an operation which will sign extend the low lanes of the operand
comment|/// into the specified vector type. For example,
comment|/// this can convert a v16i8 into a v4i32 by sign extending the low four
comment|/// lanes of the operand from i8 to i32.
name|SDValue
name|getSignExtendVectorInReg
parameter_list|(
name|SDValue
name|Op
parameter_list|,
specifier|const
name|SDLoc
modifier|&
name|DL
parameter_list|,
name|EVT
name|VT
parameter_list|)
function_decl|;
comment|/// Return an operation which will zero extend the low lanes of the operand
comment|/// into the specified vector type. For example,
comment|/// this can convert a v16i8 into a v4i32 by zero extending the low four
comment|/// lanes of the operand from i8 to i32.
name|SDValue
name|getZeroExtendVectorInReg
parameter_list|(
name|SDValue
name|Op
parameter_list|,
specifier|const
name|SDLoc
modifier|&
name|DL
parameter_list|,
name|EVT
name|VT
parameter_list|)
function_decl|;
comment|/// Convert Op, which must be of integer type, to the integer type VT,
comment|/// by using an extension appropriate for the target's
comment|/// BooleanContent for type OpVT or truncating it.
name|SDValue
name|getBoolExtOrTrunc
parameter_list|(
name|SDValue
name|Op
parameter_list|,
specifier|const
name|SDLoc
modifier|&
name|SL
parameter_list|,
name|EVT
name|VT
parameter_list|,
name|EVT
name|OpVT
parameter_list|)
function_decl|;
comment|/// Create a bitwise NOT operation as (XOR Val, -1).
name|SDValue
name|getNOT
parameter_list|(
specifier|const
name|SDLoc
modifier|&
name|DL
parameter_list|,
name|SDValue
name|Val
parameter_list|,
name|EVT
name|VT
parameter_list|)
function_decl|;
comment|/// \brief Create a logical NOT operation as (XOR Val, BooleanOne).
name|SDValue
name|getLogicalNOT
parameter_list|(
specifier|const
name|SDLoc
modifier|&
name|DL
parameter_list|,
name|SDValue
name|Val
parameter_list|,
name|EVT
name|VT
parameter_list|)
function_decl|;
comment|/// Return a new CALLSEQ_START node, which always must have a glue result
comment|/// (to ensure it's not CSE'd).  CALLSEQ_START does not have a useful SDLoc.
name|SDValue
name|getCALLSEQ_START
parameter_list|(
name|SDValue
name|Chain
parameter_list|,
name|SDValue
name|Op
parameter_list|,
specifier|const
name|SDLoc
modifier|&
name|DL
parameter_list|)
block|{
name|SDVTList
name|VTs
init|=
name|getVTList
argument_list|(
name|MVT
operator|::
name|Other
argument_list|,
name|MVT
operator|::
name|Glue
argument_list|)
decl_stmt|;
name|SDValue
name|Ops
index|[]
init|=
block|{
name|Chain
block|,
name|Op
block|}
decl_stmt|;
return|return
name|getNode
argument_list|(
name|ISD
operator|::
name|CALLSEQ_START
argument_list|,
name|DL
argument_list|,
name|VTs
argument_list|,
name|Ops
argument_list|)
return|;
block|}
comment|/// Return a new CALLSEQ_END node, which always must have a
comment|/// glue result (to ensure it's not CSE'd).
comment|/// CALLSEQ_END does not have a useful SDLoc.
name|SDValue
name|getCALLSEQ_END
parameter_list|(
name|SDValue
name|Chain
parameter_list|,
name|SDValue
name|Op1
parameter_list|,
name|SDValue
name|Op2
parameter_list|,
name|SDValue
name|InGlue
parameter_list|,
specifier|const
name|SDLoc
modifier|&
name|DL
parameter_list|)
block|{
name|SDVTList
name|NodeTys
init|=
name|getVTList
argument_list|(
name|MVT
operator|::
name|Other
argument_list|,
name|MVT
operator|::
name|Glue
argument_list|)
decl_stmt|;
name|SmallVector
operator|<
name|SDValue
operator|,
literal|4
operator|>
name|Ops
expr_stmt|;
name|Ops
operator|.
name|push_back
argument_list|(
name|Chain
argument_list|)
expr_stmt|;
name|Ops
operator|.
name|push_back
argument_list|(
name|Op1
argument_list|)
expr_stmt|;
name|Ops
operator|.
name|push_back
argument_list|(
name|Op2
argument_list|)
expr_stmt|;
if|if
condition|(
name|InGlue
operator|.
name|getNode
argument_list|()
condition|)
name|Ops
operator|.
name|push_back
argument_list|(
name|InGlue
argument_list|)
expr_stmt|;
return|return
name|getNode
argument_list|(
name|ISD
operator|::
name|CALLSEQ_END
argument_list|,
name|DL
argument_list|,
name|NodeTys
argument_list|,
name|Ops
argument_list|)
return|;
block|}
comment|/// Return an UNDEF node. UNDEF does not have a useful SDLoc.
name|SDValue
name|getUNDEF
parameter_list|(
name|EVT
name|VT
parameter_list|)
block|{
return|return
name|getNode
argument_list|(
name|ISD
operator|::
name|UNDEF
argument_list|,
name|SDLoc
argument_list|()
argument_list|,
name|VT
argument_list|)
return|;
block|}
comment|/// Return a GLOBAL_OFFSET_TABLE node. This does not have a useful SDLoc.
name|SDValue
name|getGLOBAL_OFFSET_TABLE
parameter_list|(
name|EVT
name|VT
parameter_list|)
block|{
return|return
name|getNode
argument_list|(
name|ISD
operator|::
name|GLOBAL_OFFSET_TABLE
argument_list|,
name|SDLoc
argument_list|()
argument_list|,
name|VT
argument_list|)
return|;
block|}
comment|/// Gets or creates the specified node.
comment|///
name|SDValue
name|getNode
argument_list|(
name|unsigned
name|Opcode
argument_list|,
specifier|const
name|SDLoc
operator|&
name|DL
argument_list|,
name|EVT
name|VT
argument_list|,
name|ArrayRef
operator|<
name|SDUse
operator|>
name|Ops
argument_list|)
decl_stmt|;
name|SDValue
name|getNode
argument_list|(
name|unsigned
name|Opcode
argument_list|,
specifier|const
name|SDLoc
operator|&
name|DL
argument_list|,
name|EVT
name|VT
argument_list|,
name|ArrayRef
operator|<
name|SDValue
operator|>
name|Ops
argument_list|,
specifier|const
name|SDNodeFlags
operator|*
name|Flags
operator|=
name|nullptr
argument_list|)
decl_stmt|;
name|SDValue
name|getNode
argument_list|(
name|unsigned
name|Opcode
argument_list|,
specifier|const
name|SDLoc
operator|&
name|DL
argument_list|,
name|ArrayRef
operator|<
name|EVT
operator|>
name|ResultTys
argument_list|,
name|ArrayRef
operator|<
name|SDValue
operator|>
name|Ops
argument_list|)
decl_stmt|;
name|SDValue
name|getNode
argument_list|(
name|unsigned
name|Opcode
argument_list|,
specifier|const
name|SDLoc
operator|&
name|DL
argument_list|,
name|SDVTList
name|VTs
argument_list|,
name|ArrayRef
operator|<
name|SDValue
operator|>
name|Ops
argument_list|)
decl_stmt|;
comment|// Specialize based on number of operands.
name|SDValue
name|getNode
parameter_list|(
name|unsigned
name|Opcode
parameter_list|,
specifier|const
name|SDLoc
modifier|&
name|DL
parameter_list|,
name|EVT
name|VT
parameter_list|)
function_decl|;
name|SDValue
name|getNode
parameter_list|(
name|unsigned
name|Opcode
parameter_list|,
specifier|const
name|SDLoc
modifier|&
name|DL
parameter_list|,
name|EVT
name|VT
parameter_list|,
name|SDValue
name|N
parameter_list|)
function_decl|;
name|SDValue
name|getNode
parameter_list|(
name|unsigned
name|Opcode
parameter_list|,
specifier|const
name|SDLoc
modifier|&
name|DL
parameter_list|,
name|EVT
name|VT
parameter_list|,
name|SDValue
name|N1
parameter_list|,
name|SDValue
name|N2
parameter_list|,
specifier|const
name|SDNodeFlags
modifier|*
name|Flags
init|=
name|nullptr
parameter_list|)
function_decl|;
name|SDValue
name|getNode
parameter_list|(
name|unsigned
name|Opcode
parameter_list|,
specifier|const
name|SDLoc
modifier|&
name|DL
parameter_list|,
name|EVT
name|VT
parameter_list|,
name|SDValue
name|N1
parameter_list|,
name|SDValue
name|N2
parameter_list|,
name|SDValue
name|N3
parameter_list|)
function_decl|;
name|SDValue
name|getNode
parameter_list|(
name|unsigned
name|Opcode
parameter_list|,
specifier|const
name|SDLoc
modifier|&
name|DL
parameter_list|,
name|EVT
name|VT
parameter_list|,
name|SDValue
name|N1
parameter_list|,
name|SDValue
name|N2
parameter_list|,
name|SDValue
name|N3
parameter_list|,
name|SDValue
name|N4
parameter_list|)
function_decl|;
name|SDValue
name|getNode
parameter_list|(
name|unsigned
name|Opcode
parameter_list|,
specifier|const
name|SDLoc
modifier|&
name|DL
parameter_list|,
name|EVT
name|VT
parameter_list|,
name|SDValue
name|N1
parameter_list|,
name|SDValue
name|N2
parameter_list|,
name|SDValue
name|N3
parameter_list|,
name|SDValue
name|N4
parameter_list|,
name|SDValue
name|N5
parameter_list|)
function_decl|;
comment|// Specialize again based on number of operands for nodes with a VTList
comment|// rather than a single VT.
name|SDValue
name|getNode
parameter_list|(
name|unsigned
name|Opcode
parameter_list|,
specifier|const
name|SDLoc
modifier|&
name|DL
parameter_list|,
name|SDVTList
name|VTs
parameter_list|)
function_decl|;
name|SDValue
name|getNode
parameter_list|(
name|unsigned
name|Opcode
parameter_list|,
specifier|const
name|SDLoc
modifier|&
name|DL
parameter_list|,
name|SDVTList
name|VTs
parameter_list|,
name|SDValue
name|N
parameter_list|)
function_decl|;
name|SDValue
name|getNode
parameter_list|(
name|unsigned
name|Opcode
parameter_list|,
specifier|const
name|SDLoc
modifier|&
name|DL
parameter_list|,
name|SDVTList
name|VTs
parameter_list|,
name|SDValue
name|N1
parameter_list|,
name|SDValue
name|N2
parameter_list|)
function_decl|;
name|SDValue
name|getNode
parameter_list|(
name|unsigned
name|Opcode
parameter_list|,
specifier|const
name|SDLoc
modifier|&
name|DL
parameter_list|,
name|SDVTList
name|VTs
parameter_list|,
name|SDValue
name|N1
parameter_list|,
name|SDValue
name|N2
parameter_list|,
name|SDValue
name|N3
parameter_list|)
function_decl|;
name|SDValue
name|getNode
parameter_list|(
name|unsigned
name|Opcode
parameter_list|,
specifier|const
name|SDLoc
modifier|&
name|DL
parameter_list|,
name|SDVTList
name|VTs
parameter_list|,
name|SDValue
name|N1
parameter_list|,
name|SDValue
name|N2
parameter_list|,
name|SDValue
name|N3
parameter_list|,
name|SDValue
name|N4
parameter_list|)
function_decl|;
name|SDValue
name|getNode
parameter_list|(
name|unsigned
name|Opcode
parameter_list|,
specifier|const
name|SDLoc
modifier|&
name|DL
parameter_list|,
name|SDVTList
name|VTs
parameter_list|,
name|SDValue
name|N1
parameter_list|,
name|SDValue
name|N2
parameter_list|,
name|SDValue
name|N3
parameter_list|,
name|SDValue
name|N4
parameter_list|,
name|SDValue
name|N5
parameter_list|)
function_decl|;
comment|/// Compute a TokenFactor to force all the incoming stack arguments to be
comment|/// loaded from the stack. This is used in tail call lowering to protect
comment|/// stack arguments from being clobbered.
name|SDValue
name|getStackArgumentTokenFactor
parameter_list|(
name|SDValue
name|Chain
parameter_list|)
function_decl|;
name|SDValue
name|getMemcpy
parameter_list|(
name|SDValue
name|Chain
parameter_list|,
specifier|const
name|SDLoc
modifier|&
name|dl
parameter_list|,
name|SDValue
name|Dst
parameter_list|,
name|SDValue
name|Src
parameter_list|,
name|SDValue
name|Size
parameter_list|,
name|unsigned
name|Align
parameter_list|,
name|bool
name|isVol
parameter_list|,
name|bool
name|AlwaysInline
parameter_list|,
name|bool
name|isTailCall
parameter_list|,
name|MachinePointerInfo
name|DstPtrInfo
parameter_list|,
name|MachinePointerInfo
name|SrcPtrInfo
parameter_list|)
function_decl|;
name|SDValue
name|getMemmove
parameter_list|(
name|SDValue
name|Chain
parameter_list|,
specifier|const
name|SDLoc
modifier|&
name|dl
parameter_list|,
name|SDValue
name|Dst
parameter_list|,
name|SDValue
name|Src
parameter_list|,
name|SDValue
name|Size
parameter_list|,
name|unsigned
name|Align
parameter_list|,
name|bool
name|isVol
parameter_list|,
name|bool
name|isTailCall
parameter_list|,
name|MachinePointerInfo
name|DstPtrInfo
parameter_list|,
name|MachinePointerInfo
name|SrcPtrInfo
parameter_list|)
function_decl|;
name|SDValue
name|getMemset
parameter_list|(
name|SDValue
name|Chain
parameter_list|,
specifier|const
name|SDLoc
modifier|&
name|dl
parameter_list|,
name|SDValue
name|Dst
parameter_list|,
name|SDValue
name|Src
parameter_list|,
name|SDValue
name|Size
parameter_list|,
name|unsigned
name|Align
parameter_list|,
name|bool
name|isVol
parameter_list|,
name|bool
name|isTailCall
parameter_list|,
name|MachinePointerInfo
name|DstPtrInfo
parameter_list|)
function_decl|;
comment|/// Helper function to make it easier to build SetCC's if you just
comment|/// have an ISD::CondCode instead of an SDValue.
comment|///
name|SDValue
name|getSetCC
argument_list|(
specifier|const
name|SDLoc
operator|&
name|DL
argument_list|,
name|EVT
name|VT
argument_list|,
name|SDValue
name|LHS
argument_list|,
name|SDValue
name|RHS
argument_list|,
name|ISD
operator|::
name|CondCode
name|Cond
argument_list|)
block|{
name|assert
argument_list|(
name|LHS
operator|.
name|getValueType
argument_list|()
operator|.
name|isVector
argument_list|()
operator|==
name|RHS
operator|.
name|getValueType
argument_list|()
operator|.
name|isVector
argument_list|()
operator|&&
literal|"Cannot compare scalars to vectors"
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|LHS
operator|.
name|getValueType
argument_list|()
operator|.
name|isVector
argument_list|()
operator|==
name|VT
operator|.
name|isVector
argument_list|()
operator|&&
literal|"Cannot compare scalars to vectors"
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|Cond
operator|!=
name|ISD
operator|::
name|SETCC_INVALID
operator|&&
literal|"Cannot create a setCC of an invalid node."
argument_list|)
expr_stmt|;
return|return
name|getNode
argument_list|(
name|ISD
operator|::
name|SETCC
argument_list|,
name|DL
argument_list|,
name|VT
argument_list|,
name|LHS
argument_list|,
name|RHS
argument_list|,
name|getCondCode
argument_list|(
name|Cond
argument_list|)
argument_list|)
return|;
block|}
comment|/// Helper function to make it easier to build Select's if you just
comment|/// have operands and don't want to check for vector.
name|SDValue
name|getSelect
parameter_list|(
specifier|const
name|SDLoc
modifier|&
name|DL
parameter_list|,
name|EVT
name|VT
parameter_list|,
name|SDValue
name|Cond
parameter_list|,
name|SDValue
name|LHS
parameter_list|,
name|SDValue
name|RHS
parameter_list|)
block|{
name|assert
argument_list|(
name|LHS
operator|.
name|getValueType
argument_list|()
operator|==
name|RHS
operator|.
name|getValueType
argument_list|()
operator|&&
literal|"Cannot use select on differing types"
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|VT
operator|.
name|isVector
argument_list|()
operator|==
name|LHS
operator|.
name|getValueType
argument_list|()
operator|.
name|isVector
argument_list|()
operator|&&
literal|"Cannot mix vectors and scalars"
argument_list|)
expr_stmt|;
return|return
name|getNode
argument_list|(
name|Cond
operator|.
name|getValueType
argument_list|()
operator|.
name|isVector
argument_list|()
condition|?
name|ISD
operator|::
name|VSELECT
else|:
name|ISD
operator|::
name|SELECT
argument_list|,
name|DL
argument_list|,
name|VT
argument_list|,
name|Cond
argument_list|,
name|LHS
argument_list|,
name|RHS
argument_list|)
return|;
block|}
comment|/// Helper function to make it easier to build SelectCC's if you
comment|/// just have an ISD::CondCode instead of an SDValue.
comment|///
name|SDValue
name|getSelectCC
argument_list|(
specifier|const
name|SDLoc
operator|&
name|DL
argument_list|,
name|SDValue
name|LHS
argument_list|,
name|SDValue
name|RHS
argument_list|,
name|SDValue
name|True
argument_list|,
name|SDValue
name|False
argument_list|,
name|ISD
operator|::
name|CondCode
name|Cond
argument_list|)
block|{
return|return
name|getNode
argument_list|(
name|ISD
operator|::
name|SELECT_CC
argument_list|,
name|DL
argument_list|,
name|True
operator|.
name|getValueType
argument_list|()
argument_list|,
name|LHS
argument_list|,
name|RHS
argument_list|,
name|True
argument_list|,
name|False
argument_list|,
name|getCondCode
argument_list|(
name|Cond
argument_list|)
argument_list|)
return|;
block|}
comment|/// VAArg produces a result and token chain, and takes a pointer
comment|/// and a source value as input.
name|SDValue
name|getVAArg
parameter_list|(
name|EVT
name|VT
parameter_list|,
specifier|const
name|SDLoc
modifier|&
name|dl
parameter_list|,
name|SDValue
name|Chain
parameter_list|,
name|SDValue
name|Ptr
parameter_list|,
name|SDValue
name|SV
parameter_list|,
name|unsigned
name|Align
parameter_list|)
function_decl|;
comment|/// Gets a node for an atomic cmpxchg op. There are two
comment|/// valid Opcodes. ISD::ATOMIC_CMO_SWAP produces the value loaded and a
comment|/// chain result. ISD::ATOMIC_CMP_SWAP_WITH_SUCCESS produces the value loaded,
comment|/// a success flag (initially i1), and a chain.
name|SDValue
name|getAtomicCmpSwap
parameter_list|(
name|unsigned
name|Opcode
parameter_list|,
specifier|const
name|SDLoc
modifier|&
name|dl
parameter_list|,
name|EVT
name|MemVT
parameter_list|,
name|SDVTList
name|VTs
parameter_list|,
name|SDValue
name|Chain
parameter_list|,
name|SDValue
name|Ptr
parameter_list|,
name|SDValue
name|Cmp
parameter_list|,
name|SDValue
name|Swp
parameter_list|,
name|MachinePointerInfo
name|PtrInfo
parameter_list|,
name|unsigned
name|Alignment
parameter_list|,
name|AtomicOrdering
name|SuccessOrdering
parameter_list|,
name|AtomicOrdering
name|FailureOrdering
parameter_list|,
name|SynchronizationScope
name|SynchScope
parameter_list|)
function_decl|;
name|SDValue
name|getAtomicCmpSwap
parameter_list|(
name|unsigned
name|Opcode
parameter_list|,
specifier|const
name|SDLoc
modifier|&
name|dl
parameter_list|,
name|EVT
name|MemVT
parameter_list|,
name|SDVTList
name|VTs
parameter_list|,
name|SDValue
name|Chain
parameter_list|,
name|SDValue
name|Ptr
parameter_list|,
name|SDValue
name|Cmp
parameter_list|,
name|SDValue
name|Swp
parameter_list|,
name|MachineMemOperand
modifier|*
name|MMO
parameter_list|)
function_decl|;
comment|/// Gets a node for an atomic op, produces result (if relevant)
comment|/// and chain and takes 2 operands.
name|SDValue
name|getAtomic
parameter_list|(
name|unsigned
name|Opcode
parameter_list|,
specifier|const
name|SDLoc
modifier|&
name|dl
parameter_list|,
name|EVT
name|MemVT
parameter_list|,
name|SDValue
name|Chain
parameter_list|,
name|SDValue
name|Ptr
parameter_list|,
name|SDValue
name|Val
parameter_list|,
specifier|const
name|Value
modifier|*
name|PtrVal
parameter_list|,
name|unsigned
name|Alignment
parameter_list|,
name|AtomicOrdering
name|Ordering
parameter_list|,
name|SynchronizationScope
name|SynchScope
parameter_list|)
function_decl|;
name|SDValue
name|getAtomic
parameter_list|(
name|unsigned
name|Opcode
parameter_list|,
specifier|const
name|SDLoc
modifier|&
name|dl
parameter_list|,
name|EVT
name|MemVT
parameter_list|,
name|SDValue
name|Chain
parameter_list|,
name|SDValue
name|Ptr
parameter_list|,
name|SDValue
name|Val
parameter_list|,
name|MachineMemOperand
modifier|*
name|MMO
parameter_list|)
function_decl|;
comment|/// Gets a node for an atomic op, produces result and chain and
comment|/// takes 1 operand.
name|SDValue
name|getAtomic
parameter_list|(
name|unsigned
name|Opcode
parameter_list|,
specifier|const
name|SDLoc
modifier|&
name|dl
parameter_list|,
name|EVT
name|MemVT
parameter_list|,
name|EVT
name|VT
parameter_list|,
name|SDValue
name|Chain
parameter_list|,
name|SDValue
name|Ptr
parameter_list|,
name|MachineMemOperand
modifier|*
name|MMO
parameter_list|)
function_decl|;
comment|/// Gets a node for an atomic op, produces result and chain and takes N
comment|/// operands.
name|SDValue
name|getAtomic
argument_list|(
name|unsigned
name|Opcode
argument_list|,
specifier|const
name|SDLoc
operator|&
name|dl
argument_list|,
name|EVT
name|MemVT
argument_list|,
name|SDVTList
name|VTList
argument_list|,
name|ArrayRef
operator|<
name|SDValue
operator|>
name|Ops
argument_list|,
name|MachineMemOperand
operator|*
name|MMO
argument_list|)
decl_stmt|;
comment|/// Creates a MemIntrinsicNode that may produce a
comment|/// result and takes a list of operands. Opcode may be INTRINSIC_VOID,
comment|/// INTRINSIC_W_CHAIN, or a target-specific opcode with a value not
comment|/// less than FIRST_TARGET_MEMORY_OPCODE.
name|SDValue
name|getMemIntrinsicNode
argument_list|(
name|unsigned
name|Opcode
argument_list|,
specifier|const
name|SDLoc
operator|&
name|dl
argument_list|,
name|SDVTList
name|VTList
argument_list|,
name|ArrayRef
operator|<
name|SDValue
operator|>
name|Ops
argument_list|,
name|EVT
name|MemVT
argument_list|,
name|MachinePointerInfo
name|PtrInfo
argument_list|,
name|unsigned
name|Align
operator|=
literal|0
argument_list|,
name|bool
name|Vol
operator|=
name|false
argument_list|,
name|bool
name|ReadMem
operator|=
name|true
argument_list|,
name|bool
name|WriteMem
operator|=
name|true
argument_list|,
name|unsigned
name|Size
operator|=
literal|0
argument_list|)
decl_stmt|;
name|SDValue
name|getMemIntrinsicNode
argument_list|(
name|unsigned
name|Opcode
argument_list|,
specifier|const
name|SDLoc
operator|&
name|dl
argument_list|,
name|SDVTList
name|VTList
argument_list|,
name|ArrayRef
operator|<
name|SDValue
operator|>
name|Ops
argument_list|,
name|EVT
name|MemVT
argument_list|,
name|MachineMemOperand
operator|*
name|MMO
argument_list|)
decl_stmt|;
comment|/// Create a MERGE_VALUES node from the given operands.
name|SDValue
name|getMergeValues
argument_list|(
name|ArrayRef
operator|<
name|SDValue
operator|>
name|Ops
argument_list|,
specifier|const
name|SDLoc
operator|&
name|dl
argument_list|)
decl_stmt|;
comment|/// Loads are not normal binary operators: their result type is not
comment|/// determined by their operands, and they produce a value AND a token chain.
comment|///
comment|/// This function will set the MOLoad flag on MMOFlags, but you can set it if
comment|/// you want.  The MOStore flag must not be set.
name|SDValue
name|getLoad
argument_list|(
name|EVT
name|VT
argument_list|,
specifier|const
name|SDLoc
operator|&
name|dl
argument_list|,
name|SDValue
name|Chain
argument_list|,
name|SDValue
name|Ptr
argument_list|,
name|MachinePointerInfo
name|PtrInfo
argument_list|,
name|unsigned
name|Alignment
operator|=
literal|0
argument_list|,
name|MachineMemOperand
operator|::
name|Flags
name|MMOFlags
operator|=
name|MachineMemOperand
operator|::
name|MONone
argument_list|,
specifier|const
name|AAMDNodes
operator|&
name|AAInfo
operator|=
name|AAMDNodes
argument_list|()
argument_list|,
specifier|const
name|MDNode
operator|*
name|Ranges
operator|=
name|nullptr
argument_list|)
decl_stmt|;
name|SDValue
name|getLoad
parameter_list|(
name|EVT
name|VT
parameter_list|,
specifier|const
name|SDLoc
modifier|&
name|dl
parameter_list|,
name|SDValue
name|Chain
parameter_list|,
name|SDValue
name|Ptr
parameter_list|,
name|MachineMemOperand
modifier|*
name|MMO
parameter_list|)
function_decl|;
name|SDValue
name|getExtLoad
argument_list|(
name|ISD
operator|::
name|LoadExtType
name|ExtType
argument_list|,
specifier|const
name|SDLoc
operator|&
name|dl
argument_list|,
name|EVT
name|VT
argument_list|,
name|SDValue
name|Chain
argument_list|,
name|SDValue
name|Ptr
argument_list|,
name|MachinePointerInfo
name|PtrInfo
argument_list|,
name|EVT
name|MemVT
argument_list|,
name|unsigned
name|Alignment
operator|=
literal|0
argument_list|,
name|MachineMemOperand
operator|::
name|Flags
name|MMOFlags
operator|=
name|MachineMemOperand
operator|::
name|MONone
argument_list|,
specifier|const
name|AAMDNodes
operator|&
name|AAInfo
operator|=
name|AAMDNodes
argument_list|()
argument_list|)
decl_stmt|;
name|SDValue
name|getExtLoad
argument_list|(
name|ISD
operator|::
name|LoadExtType
name|ExtType
argument_list|,
specifier|const
name|SDLoc
operator|&
name|dl
argument_list|,
name|EVT
name|VT
argument_list|,
name|SDValue
name|Chain
argument_list|,
name|SDValue
name|Ptr
argument_list|,
name|EVT
name|MemVT
argument_list|,
name|MachineMemOperand
operator|*
name|MMO
argument_list|)
decl_stmt|;
name|SDValue
name|getIndexedLoad
argument_list|(
name|SDValue
name|OrigLoad
argument_list|,
specifier|const
name|SDLoc
operator|&
name|dl
argument_list|,
name|SDValue
name|Base
argument_list|,
name|SDValue
name|Offset
argument_list|,
name|ISD
operator|::
name|MemIndexedMode
name|AM
argument_list|)
decl_stmt|;
name|SDValue
name|getLoad
argument_list|(
name|ISD
operator|::
name|MemIndexedMode
name|AM
argument_list|,
name|ISD
operator|::
name|LoadExtType
name|ExtType
argument_list|,
name|EVT
name|VT
argument_list|,
specifier|const
name|SDLoc
operator|&
name|dl
argument_list|,
name|SDValue
name|Chain
argument_list|,
name|SDValue
name|Ptr
argument_list|,
name|SDValue
name|Offset
argument_list|,
name|MachinePointerInfo
name|PtrInfo
argument_list|,
name|EVT
name|MemVT
argument_list|,
name|unsigned
name|Alignment
operator|=
literal|0
argument_list|,
name|MachineMemOperand
operator|::
name|Flags
name|MMOFlags
operator|=
name|MachineMemOperand
operator|::
name|MONone
argument_list|,
specifier|const
name|AAMDNodes
operator|&
name|AAInfo
operator|=
name|AAMDNodes
argument_list|()
argument_list|,
specifier|const
name|MDNode
operator|*
name|Ranges
operator|=
name|nullptr
argument_list|)
decl_stmt|;
name|SDValue
name|getLoad
argument_list|(
name|ISD
operator|::
name|MemIndexedMode
name|AM
argument_list|,
name|ISD
operator|::
name|LoadExtType
name|ExtType
argument_list|,
name|EVT
name|VT
argument_list|,
specifier|const
name|SDLoc
operator|&
name|dl
argument_list|,
name|SDValue
name|Chain
argument_list|,
name|SDValue
name|Ptr
argument_list|,
name|SDValue
name|Offset
argument_list|,
name|EVT
name|MemVT
argument_list|,
name|MachineMemOperand
operator|*
name|MMO
argument_list|)
decl_stmt|;
comment|/// Helper function to build ISD::STORE nodes.
comment|///
comment|/// This function will set the MOStore flag on MMOFlags, but you can set it if
comment|/// you want.  The MOLoad and MOInvariant flags must not be set.
name|SDValue
name|getStore
argument_list|(
name|SDValue
name|Chain
argument_list|,
specifier|const
name|SDLoc
operator|&
name|dl
argument_list|,
name|SDValue
name|Val
argument_list|,
name|SDValue
name|Ptr
argument_list|,
name|MachinePointerInfo
name|PtrInfo
argument_list|,
name|unsigned
name|Alignment
operator|=
literal|0
argument_list|,
name|MachineMemOperand
operator|::
name|Flags
name|MMOFlags
operator|=
name|MachineMemOperand
operator|::
name|MONone
argument_list|,
specifier|const
name|AAMDNodes
operator|&
name|AAInfo
operator|=
name|AAMDNodes
argument_list|()
argument_list|)
decl_stmt|;
name|SDValue
name|getStore
parameter_list|(
name|SDValue
name|Chain
parameter_list|,
specifier|const
name|SDLoc
modifier|&
name|dl
parameter_list|,
name|SDValue
name|Val
parameter_list|,
name|SDValue
name|Ptr
parameter_list|,
name|MachineMemOperand
modifier|*
name|MMO
parameter_list|)
function_decl|;
name|SDValue
name|getTruncStore
argument_list|(
name|SDValue
name|Chain
argument_list|,
specifier|const
name|SDLoc
operator|&
name|dl
argument_list|,
name|SDValue
name|Val
argument_list|,
name|SDValue
name|Ptr
argument_list|,
name|MachinePointerInfo
name|PtrInfo
argument_list|,
name|EVT
name|TVT
argument_list|,
name|unsigned
name|Alignment
operator|=
literal|0
argument_list|,
name|MachineMemOperand
operator|::
name|Flags
name|MMOFlags
operator|=
name|MachineMemOperand
operator|::
name|MONone
argument_list|,
specifier|const
name|AAMDNodes
operator|&
name|AAInfo
operator|=
name|AAMDNodes
argument_list|()
argument_list|)
decl_stmt|;
name|SDValue
name|getTruncStore
parameter_list|(
name|SDValue
name|Chain
parameter_list|,
specifier|const
name|SDLoc
modifier|&
name|dl
parameter_list|,
name|SDValue
name|Val
parameter_list|,
name|SDValue
name|Ptr
parameter_list|,
name|EVT
name|TVT
parameter_list|,
name|MachineMemOperand
modifier|*
name|MMO
parameter_list|)
function_decl|;
name|SDValue
name|getIndexedStore
argument_list|(
name|SDValue
name|OrigStoe
argument_list|,
specifier|const
name|SDLoc
operator|&
name|dl
argument_list|,
name|SDValue
name|Base
argument_list|,
name|SDValue
name|Offset
argument_list|,
name|ISD
operator|::
name|MemIndexedMode
name|AM
argument_list|)
decl_stmt|;
comment|/// Returns sum of the base pointer and offset.
name|SDValue
name|getMemBasePlusOffset
parameter_list|(
name|SDValue
name|Base
parameter_list|,
name|unsigned
name|Offset
parameter_list|,
specifier|const
name|SDLoc
modifier|&
name|DL
parameter_list|)
function_decl|;
name|SDValue
name|getMaskedLoad
argument_list|(
name|EVT
name|VT
argument_list|,
specifier|const
name|SDLoc
operator|&
name|dl
argument_list|,
name|SDValue
name|Chain
argument_list|,
name|SDValue
name|Ptr
argument_list|,
name|SDValue
name|Mask
argument_list|,
name|SDValue
name|Src0
argument_list|,
name|EVT
name|MemVT
argument_list|,
name|MachineMemOperand
operator|*
name|MMO
argument_list|,
name|ISD
operator|::
name|LoadExtType
argument_list|,
name|bool
name|IsExpanding
operator|=
name|false
argument_list|)
decl_stmt|;
name|SDValue
name|getMaskedStore
parameter_list|(
name|SDValue
name|Chain
parameter_list|,
specifier|const
name|SDLoc
modifier|&
name|dl
parameter_list|,
name|SDValue
name|Val
parameter_list|,
name|SDValue
name|Ptr
parameter_list|,
name|SDValue
name|Mask
parameter_list|,
name|EVT
name|MemVT
parameter_list|,
name|MachineMemOperand
modifier|*
name|MMO
parameter_list|,
name|bool
name|IsTruncating
init|=
name|false
parameter_list|,
name|bool
name|IsCompressing
init|=
name|false
parameter_list|)
function_decl|;
name|SDValue
name|getMaskedGather
argument_list|(
name|SDVTList
name|VTs
argument_list|,
name|EVT
name|VT
argument_list|,
specifier|const
name|SDLoc
operator|&
name|dl
argument_list|,
name|ArrayRef
operator|<
name|SDValue
operator|>
name|Ops
argument_list|,
name|MachineMemOperand
operator|*
name|MMO
argument_list|)
decl_stmt|;
name|SDValue
name|getMaskedScatter
argument_list|(
name|SDVTList
name|VTs
argument_list|,
name|EVT
name|VT
argument_list|,
specifier|const
name|SDLoc
operator|&
name|dl
argument_list|,
name|ArrayRef
operator|<
name|SDValue
operator|>
name|Ops
argument_list|,
name|MachineMemOperand
operator|*
name|MMO
argument_list|)
decl_stmt|;
comment|/// Return (create a new or find existing) a target-specific node.
comment|/// TargetMemSDNode should be derived class from MemSDNode.
name|template
operator|<
name|class
name|TargetMemSDNode
operator|>
name|SDValue
name|getTargetMemSDNode
argument_list|(
argument|SDVTList VTs
argument_list|,
argument|ArrayRef<SDValue> Ops
argument_list|,
argument|const SDLoc&dl
argument_list|,
argument|EVT MemVT
argument_list|,
argument|MachineMemOperand *MMO
argument_list|)
expr_stmt|;
comment|/// Construct a node to track a Value* through the backend.
name|SDValue
name|getSrcValue
parameter_list|(
specifier|const
name|Value
modifier|*
name|v
parameter_list|)
function_decl|;
comment|/// Return an MDNodeSDNode which holds an MDNode.
name|SDValue
name|getMDNode
parameter_list|(
specifier|const
name|MDNode
modifier|*
name|MD
parameter_list|)
function_decl|;
comment|/// Return a bitcast using the SDLoc of the value operand, and casting to the
comment|/// provided type. Use getNode to set a custom SDLoc.
name|SDValue
name|getBitcast
parameter_list|(
name|EVT
name|VT
parameter_list|,
name|SDValue
name|V
parameter_list|)
function_decl|;
comment|/// Return an AddrSpaceCastSDNode.
name|SDValue
name|getAddrSpaceCast
parameter_list|(
specifier|const
name|SDLoc
modifier|&
name|dl
parameter_list|,
name|EVT
name|VT
parameter_list|,
name|SDValue
name|Ptr
parameter_list|,
name|unsigned
name|SrcAS
parameter_list|,
name|unsigned
name|DestAS
parameter_list|)
function_decl|;
comment|/// Return the specified value casted to
comment|/// the target's desired shift amount type.
name|SDValue
name|getShiftAmountOperand
parameter_list|(
name|EVT
name|LHSTy
parameter_list|,
name|SDValue
name|Op
parameter_list|)
function_decl|;
comment|/// Expand the specified \c ISD::VAARG node as the Legalize pass would.
name|SDValue
name|expandVAArg
parameter_list|(
name|SDNode
modifier|*
name|Node
parameter_list|)
function_decl|;
comment|/// Expand the specified \c ISD::VACOPY node as the Legalize pass would.
name|SDValue
name|expandVACopy
parameter_list|(
name|SDNode
modifier|*
name|Node
parameter_list|)
function_decl|;
comment|/// *Mutate* the specified node in-place to have the
comment|/// specified operands.  If the resultant node already exists in the DAG,
comment|/// this does not modify the specified node, instead it returns the node that
comment|/// already exists.  If the resultant node does not exist in the DAG, the
comment|/// input node is returned.  As a degenerate case, if you specify the same
comment|/// input operands as the node already has, the input node is returned.
name|SDNode
modifier|*
name|UpdateNodeOperands
parameter_list|(
name|SDNode
modifier|*
name|N
parameter_list|,
name|SDValue
name|Op
parameter_list|)
function_decl|;
name|SDNode
modifier|*
name|UpdateNodeOperands
parameter_list|(
name|SDNode
modifier|*
name|N
parameter_list|,
name|SDValue
name|Op1
parameter_list|,
name|SDValue
name|Op2
parameter_list|)
function_decl|;
name|SDNode
modifier|*
name|UpdateNodeOperands
parameter_list|(
name|SDNode
modifier|*
name|N
parameter_list|,
name|SDValue
name|Op1
parameter_list|,
name|SDValue
name|Op2
parameter_list|,
name|SDValue
name|Op3
parameter_list|)
function_decl|;
name|SDNode
modifier|*
name|UpdateNodeOperands
parameter_list|(
name|SDNode
modifier|*
name|N
parameter_list|,
name|SDValue
name|Op1
parameter_list|,
name|SDValue
name|Op2
parameter_list|,
name|SDValue
name|Op3
parameter_list|,
name|SDValue
name|Op4
parameter_list|)
function_decl|;
name|SDNode
modifier|*
name|UpdateNodeOperands
parameter_list|(
name|SDNode
modifier|*
name|N
parameter_list|,
name|SDValue
name|Op1
parameter_list|,
name|SDValue
name|Op2
parameter_list|,
name|SDValue
name|Op3
parameter_list|,
name|SDValue
name|Op4
parameter_list|,
name|SDValue
name|Op5
parameter_list|)
function_decl|;
name|SDNode
modifier|*
name|UpdateNodeOperands
argument_list|(
name|SDNode
operator|*
name|N
argument_list|,
name|ArrayRef
operator|<
name|SDValue
operator|>
name|Ops
argument_list|)
decl_stmt|;
comment|/// These are used for target selectors to *mutate* the
comment|/// specified node to have the specified return type, Target opcode, and
comment|/// operands.  Note that target opcodes are stored as
comment|/// ~TargetOpcode in the node opcode field.  The resultant node is returned.
name|SDNode
modifier|*
name|SelectNodeTo
parameter_list|(
name|SDNode
modifier|*
name|N
parameter_list|,
name|unsigned
name|TargetOpc
parameter_list|,
name|EVT
name|VT
parameter_list|)
function_decl|;
name|SDNode
modifier|*
name|SelectNodeTo
parameter_list|(
name|SDNode
modifier|*
name|N
parameter_list|,
name|unsigned
name|TargetOpc
parameter_list|,
name|EVT
name|VT
parameter_list|,
name|SDValue
name|Op1
parameter_list|)
function_decl|;
name|SDNode
modifier|*
name|SelectNodeTo
parameter_list|(
name|SDNode
modifier|*
name|N
parameter_list|,
name|unsigned
name|TargetOpc
parameter_list|,
name|EVT
name|VT
parameter_list|,
name|SDValue
name|Op1
parameter_list|,
name|SDValue
name|Op2
parameter_list|)
function_decl|;
name|SDNode
modifier|*
name|SelectNodeTo
parameter_list|(
name|SDNode
modifier|*
name|N
parameter_list|,
name|unsigned
name|TargetOpc
parameter_list|,
name|EVT
name|VT
parameter_list|,
name|SDValue
name|Op1
parameter_list|,
name|SDValue
name|Op2
parameter_list|,
name|SDValue
name|Op3
parameter_list|)
function_decl|;
name|SDNode
modifier|*
name|SelectNodeTo
argument_list|(
name|SDNode
operator|*
name|N
argument_list|,
name|unsigned
name|TargetOpc
argument_list|,
name|EVT
name|VT
argument_list|,
name|ArrayRef
operator|<
name|SDValue
operator|>
name|Ops
argument_list|)
decl_stmt|;
name|SDNode
modifier|*
name|SelectNodeTo
parameter_list|(
name|SDNode
modifier|*
name|N
parameter_list|,
name|unsigned
name|TargetOpc
parameter_list|,
name|EVT
name|VT1
parameter_list|,
name|EVT
name|VT2
parameter_list|)
function_decl|;
name|SDNode
modifier|*
name|SelectNodeTo
argument_list|(
name|SDNode
operator|*
name|N
argument_list|,
name|unsigned
name|TargetOpc
argument_list|,
name|EVT
name|VT1
argument_list|,
name|EVT
name|VT2
argument_list|,
name|ArrayRef
operator|<
name|SDValue
operator|>
name|Ops
argument_list|)
decl_stmt|;
name|SDNode
modifier|*
name|SelectNodeTo
argument_list|(
name|SDNode
operator|*
name|N
argument_list|,
name|unsigned
name|TargetOpc
argument_list|,
name|EVT
name|VT1
argument_list|,
name|EVT
name|VT2
argument_list|,
name|EVT
name|VT3
argument_list|,
name|ArrayRef
operator|<
name|SDValue
operator|>
name|Ops
argument_list|)
decl_stmt|;
name|SDNode
modifier|*
name|SelectNodeTo
parameter_list|(
name|SDNode
modifier|*
name|N
parameter_list|,
name|unsigned
name|TargetOpc
parameter_list|,
name|EVT
name|VT1
parameter_list|,
name|EVT
name|VT2
parameter_list|,
name|SDValue
name|Op1
parameter_list|)
function_decl|;
name|SDNode
modifier|*
name|SelectNodeTo
parameter_list|(
name|SDNode
modifier|*
name|N
parameter_list|,
name|unsigned
name|TargetOpc
parameter_list|,
name|EVT
name|VT1
parameter_list|,
name|EVT
name|VT2
parameter_list|,
name|SDValue
name|Op1
parameter_list|,
name|SDValue
name|Op2
parameter_list|)
function_decl|;
name|SDNode
modifier|*
name|SelectNodeTo
argument_list|(
name|SDNode
operator|*
name|N
argument_list|,
name|unsigned
name|TargetOpc
argument_list|,
name|SDVTList
name|VTs
argument_list|,
name|ArrayRef
operator|<
name|SDValue
operator|>
name|Ops
argument_list|)
decl_stmt|;
comment|/// This *mutates* the specified node to have the specified
comment|/// return type, opcode, and operands.
name|SDNode
modifier|*
name|MorphNodeTo
argument_list|(
name|SDNode
operator|*
name|N
argument_list|,
name|unsigned
name|Opc
argument_list|,
name|SDVTList
name|VTs
argument_list|,
name|ArrayRef
operator|<
name|SDValue
operator|>
name|Ops
argument_list|)
decl_stmt|;
comment|/// These are used for target selectors to create a new node
comment|/// with specified return type(s), MachineInstr opcode, and operands.
comment|///
comment|/// Note that getMachineNode returns the resultant node.  If there is already
comment|/// a node of the specified opcode and operands, it returns that node instead
comment|/// of the current one.
name|MachineSDNode
modifier|*
name|getMachineNode
parameter_list|(
name|unsigned
name|Opcode
parameter_list|,
specifier|const
name|SDLoc
modifier|&
name|dl
parameter_list|,
name|EVT
name|VT
parameter_list|)
function_decl|;
name|MachineSDNode
modifier|*
name|getMachineNode
parameter_list|(
name|unsigned
name|Opcode
parameter_list|,
specifier|const
name|SDLoc
modifier|&
name|dl
parameter_list|,
name|EVT
name|VT
parameter_list|,
name|SDValue
name|Op1
parameter_list|)
function_decl|;
name|MachineSDNode
modifier|*
name|getMachineNode
parameter_list|(
name|unsigned
name|Opcode
parameter_list|,
specifier|const
name|SDLoc
modifier|&
name|dl
parameter_list|,
name|EVT
name|VT
parameter_list|,
name|SDValue
name|Op1
parameter_list|,
name|SDValue
name|Op2
parameter_list|)
function_decl|;
name|MachineSDNode
modifier|*
name|getMachineNode
parameter_list|(
name|unsigned
name|Opcode
parameter_list|,
specifier|const
name|SDLoc
modifier|&
name|dl
parameter_list|,
name|EVT
name|VT
parameter_list|,
name|SDValue
name|Op1
parameter_list|,
name|SDValue
name|Op2
parameter_list|,
name|SDValue
name|Op3
parameter_list|)
function_decl|;
name|MachineSDNode
modifier|*
name|getMachineNode
argument_list|(
name|unsigned
name|Opcode
argument_list|,
specifier|const
name|SDLoc
operator|&
name|dl
argument_list|,
name|EVT
name|VT
argument_list|,
name|ArrayRef
operator|<
name|SDValue
operator|>
name|Ops
argument_list|)
decl_stmt|;
name|MachineSDNode
modifier|*
name|getMachineNode
parameter_list|(
name|unsigned
name|Opcode
parameter_list|,
specifier|const
name|SDLoc
modifier|&
name|dl
parameter_list|,
name|EVT
name|VT1
parameter_list|,
name|EVT
name|VT2
parameter_list|,
name|SDValue
name|Op1
parameter_list|,
name|SDValue
name|Op2
parameter_list|)
function_decl|;
name|MachineSDNode
modifier|*
name|getMachineNode
parameter_list|(
name|unsigned
name|Opcode
parameter_list|,
specifier|const
name|SDLoc
modifier|&
name|dl
parameter_list|,
name|EVT
name|VT1
parameter_list|,
name|EVT
name|VT2
parameter_list|,
name|SDValue
name|Op1
parameter_list|,
name|SDValue
name|Op2
parameter_list|,
name|SDValue
name|Op3
parameter_list|)
function_decl|;
name|MachineSDNode
modifier|*
name|getMachineNode
argument_list|(
name|unsigned
name|Opcode
argument_list|,
specifier|const
name|SDLoc
operator|&
name|dl
argument_list|,
name|EVT
name|VT1
argument_list|,
name|EVT
name|VT2
argument_list|,
name|ArrayRef
operator|<
name|SDValue
operator|>
name|Ops
argument_list|)
decl_stmt|;
name|MachineSDNode
modifier|*
name|getMachineNode
parameter_list|(
name|unsigned
name|Opcode
parameter_list|,
specifier|const
name|SDLoc
modifier|&
name|dl
parameter_list|,
name|EVT
name|VT1
parameter_list|,
name|EVT
name|VT2
parameter_list|,
name|EVT
name|VT3
parameter_list|,
name|SDValue
name|Op1
parameter_list|,
name|SDValue
name|Op2
parameter_list|)
function_decl|;
name|MachineSDNode
modifier|*
name|getMachineNode
parameter_list|(
name|unsigned
name|Opcode
parameter_list|,
specifier|const
name|SDLoc
modifier|&
name|dl
parameter_list|,
name|EVT
name|VT1
parameter_list|,
name|EVT
name|VT2
parameter_list|,
name|EVT
name|VT3
parameter_list|,
name|SDValue
name|Op1
parameter_list|,
name|SDValue
name|Op2
parameter_list|,
name|SDValue
name|Op3
parameter_list|)
function_decl|;
name|MachineSDNode
modifier|*
name|getMachineNode
argument_list|(
name|unsigned
name|Opcode
argument_list|,
specifier|const
name|SDLoc
operator|&
name|dl
argument_list|,
name|EVT
name|VT1
argument_list|,
name|EVT
name|VT2
argument_list|,
name|EVT
name|VT3
argument_list|,
name|ArrayRef
operator|<
name|SDValue
operator|>
name|Ops
argument_list|)
decl_stmt|;
name|MachineSDNode
modifier|*
name|getMachineNode
argument_list|(
name|unsigned
name|Opcode
argument_list|,
specifier|const
name|SDLoc
operator|&
name|dl
argument_list|,
name|ArrayRef
operator|<
name|EVT
operator|>
name|ResultTys
argument_list|,
name|ArrayRef
operator|<
name|SDValue
operator|>
name|Ops
argument_list|)
decl_stmt|;
name|MachineSDNode
modifier|*
name|getMachineNode
argument_list|(
name|unsigned
name|Opcode
argument_list|,
specifier|const
name|SDLoc
operator|&
name|dl
argument_list|,
name|SDVTList
name|VTs
argument_list|,
name|ArrayRef
operator|<
name|SDValue
operator|>
name|Ops
argument_list|)
decl_stmt|;
comment|/// A convenience function for creating TargetInstrInfo::EXTRACT_SUBREG nodes.
name|SDValue
name|getTargetExtractSubreg
parameter_list|(
name|int
name|SRIdx
parameter_list|,
specifier|const
name|SDLoc
modifier|&
name|DL
parameter_list|,
name|EVT
name|VT
parameter_list|,
name|SDValue
name|Operand
parameter_list|)
function_decl|;
comment|/// A convenience function for creating TargetInstrInfo::INSERT_SUBREG nodes.
name|SDValue
name|getTargetInsertSubreg
parameter_list|(
name|int
name|SRIdx
parameter_list|,
specifier|const
name|SDLoc
modifier|&
name|DL
parameter_list|,
name|EVT
name|VT
parameter_list|,
name|SDValue
name|Operand
parameter_list|,
name|SDValue
name|Subreg
parameter_list|)
function_decl|;
comment|/// Get the specified node if it's already available, or else return NULL.
name|SDNode
modifier|*
name|getNodeIfExists
argument_list|(
name|unsigned
name|Opcode
argument_list|,
name|SDVTList
name|VTs
argument_list|,
name|ArrayRef
operator|<
name|SDValue
operator|>
name|Ops
argument_list|,
specifier|const
name|SDNodeFlags
operator|*
name|Flags
operator|=
name|nullptr
argument_list|)
decl_stmt|;
comment|/// Creates a SDDbgValue node.
name|SDDbgValue
modifier|*
name|getDbgValue
parameter_list|(
name|MDNode
modifier|*
name|Var
parameter_list|,
name|MDNode
modifier|*
name|Expr
parameter_list|,
name|SDNode
modifier|*
name|N
parameter_list|,
name|unsigned
name|R
parameter_list|,
name|bool
name|IsIndirect
parameter_list|,
name|uint64_t
name|Off
parameter_list|,
specifier|const
name|DebugLoc
modifier|&
name|DL
parameter_list|,
name|unsigned
name|O
parameter_list|)
function_decl|;
comment|/// Constant
name|SDDbgValue
modifier|*
name|getConstantDbgValue
parameter_list|(
name|MDNode
modifier|*
name|Var
parameter_list|,
name|MDNode
modifier|*
name|Expr
parameter_list|,
specifier|const
name|Value
modifier|*
name|C
parameter_list|,
name|uint64_t
name|Off
parameter_list|,
specifier|const
name|DebugLoc
modifier|&
name|DL
parameter_list|,
name|unsigned
name|O
parameter_list|)
function_decl|;
comment|/// FrameIndex
name|SDDbgValue
modifier|*
name|getFrameIndexDbgValue
parameter_list|(
name|MDNode
modifier|*
name|Var
parameter_list|,
name|MDNode
modifier|*
name|Expr
parameter_list|,
name|unsigned
name|FI
parameter_list|,
name|uint64_t
name|Off
parameter_list|,
specifier|const
name|DebugLoc
modifier|&
name|DL
parameter_list|,
name|unsigned
name|O
parameter_list|)
function_decl|;
comment|/// Remove the specified node from the system. If any of its
comment|/// operands then becomes dead, remove them as well. Inform UpdateListener
comment|/// for each node deleted.
name|void
name|RemoveDeadNode
parameter_list|(
name|SDNode
modifier|*
name|N
parameter_list|)
function_decl|;
comment|/// This method deletes the unreachable nodes in the
comment|/// given list, and any nodes that become unreachable as a result.
name|void
name|RemoveDeadNodes
argument_list|(
name|SmallVectorImpl
operator|<
name|SDNode
operator|*
operator|>
operator|&
name|DeadNodes
argument_list|)
decl_stmt|;
comment|/// Modify anything using 'From' to use 'To' instead.
comment|/// This can cause recursive merging of nodes in the DAG.  Use the first
comment|/// version if 'From' is known to have a single result, use the second
comment|/// if you have two nodes with identical results (or if 'To' has a superset
comment|/// of the results of 'From'), use the third otherwise.
comment|///
comment|/// These methods all take an optional UpdateListener, which (if not null) is
comment|/// informed about nodes that are deleted and modified due to recursive
comment|/// changes in the dag.
comment|///
comment|/// These functions only replace all existing uses. It's possible that as
comment|/// these replacements are being performed, CSE may cause the From node
comment|/// to be given new uses. These new uses of From are left in place, and
comment|/// not automatically transferred to To.
comment|///
name|void
name|ReplaceAllUsesWith
parameter_list|(
name|SDValue
name|From
parameter_list|,
name|SDValue
name|Op
parameter_list|)
function_decl|;
name|void
name|ReplaceAllUsesWith
parameter_list|(
name|SDNode
modifier|*
name|From
parameter_list|,
name|SDNode
modifier|*
name|To
parameter_list|)
function_decl|;
name|void
name|ReplaceAllUsesWith
parameter_list|(
name|SDNode
modifier|*
name|From
parameter_list|,
specifier|const
name|SDValue
modifier|*
name|To
parameter_list|)
function_decl|;
comment|/// Replace any uses of From with To, leaving
comment|/// uses of other values produced by From.Val alone.
name|void
name|ReplaceAllUsesOfValueWith
parameter_list|(
name|SDValue
name|From
parameter_list|,
name|SDValue
name|To
parameter_list|)
function_decl|;
comment|/// Like ReplaceAllUsesOfValueWith, but for multiple values at once.
comment|/// This correctly handles the case where
comment|/// there is an overlap between the From values and the To values.
name|void
name|ReplaceAllUsesOfValuesWith
parameter_list|(
specifier|const
name|SDValue
modifier|*
name|From
parameter_list|,
specifier|const
name|SDValue
modifier|*
name|To
parameter_list|,
name|unsigned
name|Num
parameter_list|)
function_decl|;
comment|/// Topological-sort the AllNodes list and a
comment|/// assign a unique node id for each node in the DAG based on their
comment|/// topological order. Returns the number of nodes.
name|unsigned
name|AssignTopologicalOrder
parameter_list|()
function_decl|;
comment|/// Move node N in the AllNodes list to be immediately
comment|/// before the given iterator Position. This may be used to update the
comment|/// topological ordering when the list of nodes is modified.
name|void
name|RepositionNode
parameter_list|(
name|allnodes_iterator
name|Position
parameter_list|,
name|SDNode
modifier|*
name|N
parameter_list|)
block|{
name|AllNodes
operator|.
name|insert
argument_list|(
name|Position
argument_list|,
name|AllNodes
operator|.
name|remove
argument_list|(
name|N
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/// Returns true if the opcode is a commutative binary operation.
specifier|static
name|bool
name|isCommutativeBinOp
parameter_list|(
name|unsigned
name|Opcode
parameter_list|)
block|{
comment|// FIXME: This should get its info from the td file, so that we can include
comment|// target info.
switch|switch
condition|(
name|Opcode
condition|)
block|{
case|case
name|ISD
operator|::
name|ADD
case|:
case|case
name|ISD
operator|::
name|SMIN
case|:
case|case
name|ISD
operator|::
name|SMAX
case|:
case|case
name|ISD
operator|::
name|UMIN
case|:
case|case
name|ISD
operator|::
name|UMAX
case|:
case|case
name|ISD
operator|::
name|MUL
case|:
case|case
name|ISD
operator|::
name|MULHU
case|:
case|case
name|ISD
operator|::
name|MULHS
case|:
case|case
name|ISD
operator|::
name|SMUL_LOHI
case|:
case|case
name|ISD
operator|::
name|UMUL_LOHI
case|:
case|case
name|ISD
operator|::
name|FADD
case|:
case|case
name|ISD
operator|::
name|FMUL
case|:
case|case
name|ISD
operator|::
name|AND
case|:
case|case
name|ISD
operator|::
name|OR
case|:
case|case
name|ISD
operator|::
name|XOR
case|:
case|case
name|ISD
operator|::
name|SADDO
case|:
case|case
name|ISD
operator|::
name|UADDO
case|:
case|case
name|ISD
operator|::
name|ADDC
case|:
case|case
name|ISD
operator|::
name|ADDE
case|:
case|case
name|ISD
operator|::
name|FMINNUM
case|:
case|case
name|ISD
operator|::
name|FMAXNUM
case|:
case|case
name|ISD
operator|::
name|FMINNAN
case|:
case|case
name|ISD
operator|::
name|FMAXNAN
case|:
return|return
name|true
return|;
default|default:
return|return
name|false
return|;
block|}
block|}
comment|/// Returns an APFloat semantics tag appropriate for the given type. If VT is
comment|/// a vector type, the element semantics are returned.
specifier|static
specifier|const
name|fltSemantics
modifier|&
name|EVTToAPFloatSemantics
parameter_list|(
name|EVT
name|VT
parameter_list|)
block|{
switch|switch
condition|(
name|VT
operator|.
name|getScalarType
argument_list|()
operator|.
name|getSimpleVT
argument_list|()
operator|.
name|SimpleTy
condition|)
block|{
default|default:
name|llvm_unreachable
argument_list|(
literal|"Unknown FP format"
argument_list|)
expr_stmt|;
case|case
name|MVT
operator|::
name|f16
case|:
return|return
name|APFloat
operator|::
name|IEEEhalf
argument_list|()
return|;
case|case
name|MVT
operator|::
name|f32
case|:
return|return
name|APFloat
operator|::
name|IEEEsingle
argument_list|()
return|;
case|case
name|MVT
operator|::
name|f64
case|:
return|return
name|APFloat
operator|::
name|IEEEdouble
argument_list|()
return|;
case|case
name|MVT
operator|::
name|f80
case|:
return|return
name|APFloat
operator|::
name|x87DoubleExtended
argument_list|()
return|;
case|case
name|MVT
operator|::
name|f128
case|:
return|return
name|APFloat
operator|::
name|IEEEquad
argument_list|()
return|;
case|case
name|MVT
operator|::
name|ppcf128
case|:
return|return
name|APFloat
operator|::
name|PPCDoubleDouble
argument_list|()
return|;
block|}
block|}
comment|/// Add a dbg_value SDNode. If SD is non-null that means the
comment|/// value is produced by SD.
name|void
name|AddDbgValue
parameter_list|(
name|SDDbgValue
modifier|*
name|DB
parameter_list|,
name|SDNode
modifier|*
name|SD
parameter_list|,
name|bool
name|isParameter
parameter_list|)
function_decl|;
comment|/// Get the debug values which reference the given SDNode.
name|ArrayRef
operator|<
name|SDDbgValue
operator|*
operator|>
name|GetDbgValues
argument_list|(
argument|const SDNode* SD
argument_list|)
block|{
return|return
name|DbgInfo
operator|->
name|getSDDbgValues
argument_list|(
name|SD
argument_list|)
return|;
block|}
name|private
label|:
comment|/// Transfer SDDbgValues. Called via ReplaceAllUses{OfValue}?With
name|void
name|TransferDbgValues
parameter_list|(
name|SDValue
name|From
parameter_list|,
name|SDValue
name|To
parameter_list|)
function_decl|;
name|public
label|:
comment|/// Return true if there are any SDDbgValue nodes associated
comment|/// with this SelectionDAG.
name|bool
name|hasDebugValues
argument_list|()
specifier|const
block|{
return|return
operator|!
name|DbgInfo
operator|->
name|empty
argument_list|()
return|;
block|}
name|SDDbgInfo
operator|::
name|DbgIterator
name|DbgBegin
argument_list|()
block|{
return|return
name|DbgInfo
operator|->
name|DbgBegin
argument_list|()
return|;
block|}
name|SDDbgInfo
operator|::
name|DbgIterator
name|DbgEnd
argument_list|()
block|{
return|return
name|DbgInfo
operator|->
name|DbgEnd
argument_list|()
return|;
block|}
name|SDDbgInfo
operator|::
name|DbgIterator
name|ByvalParmDbgBegin
argument_list|()
block|{
return|return
name|DbgInfo
operator|->
name|ByvalParmDbgBegin
argument_list|()
return|;
block|}
name|SDDbgInfo
operator|::
name|DbgIterator
name|ByvalParmDbgEnd
argument_list|()
block|{
return|return
name|DbgInfo
operator|->
name|ByvalParmDbgEnd
argument_list|()
return|;
block|}
name|void
name|dump
argument_list|()
specifier|const
expr_stmt|;
comment|/// Create a stack temporary, suitable for holding the specified value type.
comment|/// If minAlign is specified, the slot size will have at least that alignment.
name|SDValue
name|CreateStackTemporary
parameter_list|(
name|EVT
name|VT
parameter_list|,
name|unsigned
name|minAlign
init|=
literal|1
parameter_list|)
function_decl|;
comment|/// Create a stack temporary suitable for holding either of the specified
comment|/// value types.
name|SDValue
name|CreateStackTemporary
parameter_list|(
name|EVT
name|VT1
parameter_list|,
name|EVT
name|VT2
parameter_list|)
function_decl|;
name|SDValue
name|FoldSymbolOffset
parameter_list|(
name|unsigned
name|Opcode
parameter_list|,
name|EVT
name|VT
parameter_list|,
specifier|const
name|GlobalAddressSDNode
modifier|*
name|GA
parameter_list|,
specifier|const
name|SDNode
modifier|*
name|N2
parameter_list|)
function_decl|;
name|SDValue
name|FoldConstantArithmetic
parameter_list|(
name|unsigned
name|Opcode
parameter_list|,
specifier|const
name|SDLoc
modifier|&
name|DL
parameter_list|,
name|EVT
name|VT
parameter_list|,
name|SDNode
modifier|*
name|Cst1
parameter_list|,
name|SDNode
modifier|*
name|Cst2
parameter_list|)
function_decl|;
name|SDValue
name|FoldConstantArithmetic
parameter_list|(
name|unsigned
name|Opcode
parameter_list|,
specifier|const
name|SDLoc
modifier|&
name|DL
parameter_list|,
name|EVT
name|VT
parameter_list|,
specifier|const
name|ConstantSDNode
modifier|*
name|Cst1
parameter_list|,
specifier|const
name|ConstantSDNode
modifier|*
name|Cst2
parameter_list|)
function_decl|;
name|SDValue
name|FoldConstantVectorArithmetic
argument_list|(
name|unsigned
name|Opcode
argument_list|,
specifier|const
name|SDLoc
operator|&
name|DL
argument_list|,
name|EVT
name|VT
argument_list|,
name|ArrayRef
operator|<
name|SDValue
operator|>
name|Ops
argument_list|,
specifier|const
name|SDNodeFlags
operator|*
name|Flags
operator|=
name|nullptr
argument_list|)
decl_stmt|;
comment|/// Constant fold a setcc to true or false.
name|SDValue
name|FoldSetCC
argument_list|(
name|EVT
name|VT
argument_list|,
name|SDValue
name|N1
argument_list|,
name|SDValue
name|N2
argument_list|,
name|ISD
operator|::
name|CondCode
name|Cond
argument_list|,
specifier|const
name|SDLoc
operator|&
name|dl
argument_list|)
decl_stmt|;
comment|/// Return true if the sign bit of Op is known to be zero.
comment|/// We use this predicate to simplify operations downstream.
name|bool
name|SignBitIsZero
argument_list|(
name|SDValue
name|Op
argument_list|,
name|unsigned
name|Depth
operator|=
literal|0
argument_list|)
decl|const
decl_stmt|;
comment|/// Return true if 'Op& Mask' is known to be zero.  We
comment|/// use this predicate to simplify operations downstream.  Op and Mask are
comment|/// known to be the same type.
name|bool
name|MaskedValueIsZero
argument_list|(
name|SDValue
name|Op
argument_list|,
specifier|const
name|APInt
operator|&
name|Mask
argument_list|,
name|unsigned
name|Depth
operator|=
literal|0
argument_list|)
decl|const
decl_stmt|;
comment|/// Determine which bits of Op are known to be either zero or one and return
comment|/// them in the KnownZero/KnownOne bitsets. For vectors, the known bits are
comment|/// those that are shared by every vector element.
comment|/// Targets can implement the computeKnownBitsForTargetNode method in the
comment|/// TargetLowering class to allow target nodes to be understood.
name|void
name|computeKnownBits
argument_list|(
name|SDValue
name|Op
argument_list|,
name|APInt
operator|&
name|KnownZero
argument_list|,
name|APInt
operator|&
name|KnownOne
argument_list|,
name|unsigned
name|Depth
operator|=
literal|0
argument_list|)
decl|const
decl_stmt|;
comment|/// Determine which bits of Op are known to be either zero or one and return
comment|/// them in the KnownZero/KnownOne bitsets. The DemandedElts argument allows
comment|/// us to only collect the known bits that are shared by the requested vector
comment|/// elements.
comment|/// Targets can implement the computeKnownBitsForTargetNode method in the
comment|/// TargetLowering class to allow target nodes to be understood.
name|void
name|computeKnownBits
argument_list|(
name|SDValue
name|Op
argument_list|,
name|APInt
operator|&
name|KnownZero
argument_list|,
name|APInt
operator|&
name|KnownOne
argument_list|,
specifier|const
name|APInt
operator|&
name|DemandedElts
argument_list|,
name|unsigned
name|Depth
operator|=
literal|0
argument_list|)
decl|const
decl_stmt|;
comment|/// Test if the given value is known to have exactly one bit set. This differs
comment|/// from computeKnownBits in that it doesn't necessarily determine which bit
comment|/// is set.
name|bool
name|isKnownToBeAPowerOfTwo
argument_list|(
name|SDValue
name|Val
argument_list|)
decl|const
decl_stmt|;
comment|/// Return the number of times the sign bit of the register is replicated into
comment|/// the other bits. We know that at least 1 bit is always equal to the sign
comment|/// bit (itself), but other cases can give us information. For example,
comment|/// immediately after an "SRA X, 2", we know that the top 3 bits are all equal
comment|/// to each other, so we return 3. Targets can implement the
comment|/// ComputeNumSignBitsForTarget method in the TargetLowering class to allow
comment|/// target nodes to be understood.
name|unsigned
name|ComputeNumSignBits
argument_list|(
name|SDValue
name|Op
argument_list|,
name|unsigned
name|Depth
operator|=
literal|0
argument_list|)
decl|const
decl_stmt|;
comment|/// Return true if the specified operand is an ISD::ADD with a ConstantSDNode
comment|/// on the right-hand side, or if it is an ISD::OR with a ConstantSDNode that
comment|/// is guaranteed to have the same semantics as an ADD. This handles the
comment|/// equivalence:
comment|///     X|Cst == X+Cst iff X&Cst = 0.
name|bool
name|isBaseWithConstantOffset
argument_list|(
name|SDValue
name|Op
argument_list|)
decl|const
decl_stmt|;
comment|/// Test whether the given SDValue is known to never be NaN.
name|bool
name|isKnownNeverNaN
argument_list|(
name|SDValue
name|Op
argument_list|)
decl|const
decl_stmt|;
comment|/// Test whether the given SDValue is known to never be positive or negative
comment|/// zero.
name|bool
name|isKnownNeverZero
argument_list|(
name|SDValue
name|Op
argument_list|)
decl|const
decl_stmt|;
comment|/// Test whether two SDValues are known to compare equal. This
comment|/// is true if they are the same value, or if one is negative zero and the
comment|/// other positive zero.
name|bool
name|isEqualTo
argument_list|(
name|SDValue
name|A
argument_list|,
name|SDValue
name|B
argument_list|)
decl|const
decl_stmt|;
comment|/// Return true if A and B have no common bits set. As an example, this can
comment|/// allow an 'add' to be transformed into an 'or'.
name|bool
name|haveNoCommonBitsSet
argument_list|(
name|SDValue
name|A
argument_list|,
name|SDValue
name|B
argument_list|)
decl|const
decl_stmt|;
comment|/// Utility function used by legalize and lowering to
comment|/// "unroll" a vector operation by splitting out the scalars and operating
comment|/// on each element individually.  If the ResNE is 0, fully unroll the vector
comment|/// op. If ResNE is less than the width of the vector op, unroll up to ResNE.
comment|/// If the  ResNE is greater than the width of the vector op, unroll the
comment|/// vector op and fill the end of the resulting vector with UNDEFS.
name|SDValue
name|UnrollVectorOp
parameter_list|(
name|SDNode
modifier|*
name|N
parameter_list|,
name|unsigned
name|ResNE
init|=
literal|0
parameter_list|)
function_decl|;
comment|/// Return true if loads are next to each other and can be
comment|/// merged. Check that both are nonvolatile and if LD is loading
comment|/// 'Bytes' bytes from a location that is 'Dist' units away from the
comment|/// location that the 'Base' load is loading from.
name|bool
name|areNonVolatileConsecutiveLoads
argument_list|(
name|LoadSDNode
operator|*
name|LD
argument_list|,
name|LoadSDNode
operator|*
name|Base
argument_list|,
name|unsigned
name|Bytes
argument_list|,
name|int
name|Dist
argument_list|)
decl|const
decl_stmt|;
comment|/// Infer alignment of a load / store address. Return 0 if
comment|/// it cannot be inferred.
name|unsigned
name|InferPtrAlignment
argument_list|(
name|SDValue
name|Ptr
argument_list|)
decl|const
decl_stmt|;
comment|/// Compute the VTs needed for the low/hi parts of a type
comment|/// which is split (or expanded) into two not necessarily identical pieces.
name|std
operator|::
name|pair
operator|<
name|EVT
operator|,
name|EVT
operator|>
name|GetSplitDestVTs
argument_list|(
argument|const EVT&VT
argument_list|)
specifier|const
expr_stmt|;
comment|/// Split the vector with EXTRACT_SUBVECTOR using the provides
comment|/// VTs and return the low/high part.
name|std
operator|::
name|pair
operator|<
name|SDValue
operator|,
name|SDValue
operator|>
name|SplitVector
argument_list|(
specifier|const
name|SDValue
operator|&
name|N
argument_list|,
specifier|const
name|SDLoc
operator|&
name|DL
argument_list|,
specifier|const
name|EVT
operator|&
name|LoVT
argument_list|,
specifier|const
name|EVT
operator|&
name|HiVT
argument_list|)
expr_stmt|;
comment|/// Split the vector with EXTRACT_SUBVECTOR and return the low/high part.
name|std
operator|::
name|pair
operator|<
name|SDValue
operator|,
name|SDValue
operator|>
name|SplitVector
argument_list|(
argument|const SDValue&N
argument_list|,
argument|const SDLoc&DL
argument_list|)
block|{
name|EVT
name|LoVT
block|,
name|HiVT
block|;
name|std
operator|::
name|tie
argument_list|(
name|LoVT
argument_list|,
name|HiVT
argument_list|)
operator|=
name|GetSplitDestVTs
argument_list|(
name|N
operator|.
name|getValueType
argument_list|()
argument_list|)
block|;
return|return
name|SplitVector
argument_list|(
name|N
argument_list|,
name|DL
argument_list|,
name|LoVT
argument_list|,
name|HiVT
argument_list|)
return|;
block|}
comment|/// Split the node's operand with EXTRACT_SUBVECTOR and
comment|/// return the low/high part.
name|std
operator|::
name|pair
operator|<
name|SDValue
operator|,
name|SDValue
operator|>
name|SplitVectorOperand
argument_list|(
argument|const SDNode *N
argument_list|,
argument|unsigned OpNo
argument_list|)
block|{
return|return
name|SplitVector
argument_list|(
name|N
operator|->
name|getOperand
argument_list|(
name|OpNo
argument_list|)
argument_list|,
name|SDLoc
argument_list|(
name|N
argument_list|)
argument_list|)
return|;
block|}
comment|/// Append the extracted elements from Start to Count out of the vector Op
comment|/// in Args. If Count is 0, all of the elements will be extracted.
name|void
name|ExtractVectorElements
argument_list|(
name|SDValue
name|Op
argument_list|,
name|SmallVectorImpl
operator|<
name|SDValue
operator|>
operator|&
name|Args
argument_list|,
name|unsigned
name|Start
operator|=
literal|0
argument_list|,
name|unsigned
name|Count
operator|=
literal|0
argument_list|)
decl_stmt|;
comment|/// Compute the default alignment value for the given type.
name|unsigned
name|getEVTAlignment
argument_list|(
name|EVT
name|MemoryVT
argument_list|)
decl|const
decl_stmt|;
comment|/// Test whether the given value is a constant int or similar node.
name|SDNode
modifier|*
name|isConstantIntBuildVectorOrConstantInt
parameter_list|(
name|SDValue
name|N
parameter_list|)
function_decl|;
comment|/// Test whether the given value is a constant FP or similar node.
name|SDNode
modifier|*
name|isConstantFPBuildVectorOrConstantFP
parameter_list|(
name|SDValue
name|N
parameter_list|)
function_decl|;
comment|/// \returns true if \p N is any kind of constant or build_vector of
comment|/// constants, int or float. If a vector, it may not necessarily be a splat.
specifier|inline
name|bool
name|isConstantValueOfAnyType
parameter_list|(
name|SDValue
name|N
parameter_list|)
block|{
return|return
name|isConstantIntBuildVectorOrConstantInt
argument_list|(
name|N
argument_list|)
operator|||
name|isConstantFPBuildVectorOrConstantFP
argument_list|(
name|N
argument_list|)
return|;
block|}
name|private
label|:
name|void
name|InsertNode
parameter_list|(
name|SDNode
modifier|*
name|N
parameter_list|)
function_decl|;
name|bool
name|RemoveNodeFromCSEMaps
parameter_list|(
name|SDNode
modifier|*
name|N
parameter_list|)
function_decl|;
name|void
name|AddModifiedNodeToCSEMaps
parameter_list|(
name|SDNode
modifier|*
name|N
parameter_list|)
function_decl|;
name|SDNode
modifier|*
name|FindModifiedNodeSlot
parameter_list|(
name|SDNode
modifier|*
name|N
parameter_list|,
name|SDValue
name|Op
parameter_list|,
name|void
modifier|*
modifier|&
name|InsertPos
parameter_list|)
function_decl|;
name|SDNode
modifier|*
name|FindModifiedNodeSlot
parameter_list|(
name|SDNode
modifier|*
name|N
parameter_list|,
name|SDValue
name|Op1
parameter_list|,
name|SDValue
name|Op2
parameter_list|,
name|void
modifier|*
modifier|&
name|InsertPos
parameter_list|)
function_decl|;
name|SDNode
modifier|*
name|FindModifiedNodeSlot
argument_list|(
name|SDNode
operator|*
name|N
argument_list|,
name|ArrayRef
operator|<
name|SDValue
operator|>
name|Ops
argument_list|,
name|void
operator|*
operator|&
name|InsertPos
argument_list|)
decl_stmt|;
name|SDNode
modifier|*
name|UpdateSDLocOnMergeSDNode
parameter_list|(
name|SDNode
modifier|*
name|N
parameter_list|,
specifier|const
name|SDLoc
modifier|&
name|loc
parameter_list|)
function_decl|;
name|void
name|DeleteNodeNotInCSEMaps
parameter_list|(
name|SDNode
modifier|*
name|N
parameter_list|)
function_decl|;
name|void
name|DeallocateNode
parameter_list|(
name|SDNode
modifier|*
name|N
parameter_list|)
function_decl|;
name|void
name|allnodes_clear
parameter_list|()
function_decl|;
name|SDNode
modifier|*
name|GetBinarySDNode
parameter_list|(
name|unsigned
name|Opcode
parameter_list|,
specifier|const
name|SDLoc
modifier|&
name|DL
parameter_list|,
name|SDVTList
name|VTs
parameter_list|,
name|SDValue
name|N1
parameter_list|,
name|SDValue
name|N2
parameter_list|,
specifier|const
name|SDNodeFlags
modifier|*
name|Flags
init|=
name|nullptr
parameter_list|)
function_decl|;
comment|/// Look up the node specified by ID in CSEMap.  If it exists, return it.  If
comment|/// not, return the insertion token that will make insertion faster.  This
comment|/// overload is for nodes other than Constant or ConstantFP, use the other one
comment|/// for those.
name|SDNode
modifier|*
name|FindNodeOrInsertPos
parameter_list|(
specifier|const
name|FoldingSetNodeID
modifier|&
name|ID
parameter_list|,
name|void
modifier|*
modifier|&
name|InsertPos
parameter_list|)
function_decl|;
comment|/// Look up the node specified by ID in CSEMap.  If it exists, return it.  If
comment|/// not, return the insertion token that will make insertion faster.  Performs
comment|/// additional processing for constant nodes.
name|SDNode
modifier|*
name|FindNodeOrInsertPos
parameter_list|(
specifier|const
name|FoldingSetNodeID
modifier|&
name|ID
parameter_list|,
specifier|const
name|SDLoc
modifier|&
name|DL
parameter_list|,
name|void
modifier|*
modifier|&
name|InsertPos
parameter_list|)
function_decl|;
comment|/// List of non-single value types.
name|FoldingSet
operator|<
name|SDVTListNode
operator|>
name|VTListMap
expr_stmt|;
comment|/// Maps to auto-CSE operations.
name|std
operator|::
name|vector
operator|<
name|CondCodeSDNode
operator|*
operator|>
name|CondCodeNodes
expr_stmt|;
name|std
operator|::
name|vector
operator|<
name|SDNode
operator|*
operator|>
name|ValueTypeNodes
expr_stmt|;
name|std
operator|::
name|map
operator|<
name|EVT
operator|,
name|SDNode
operator|*
operator|,
name|EVT
operator|::
name|compareRawBits
operator|>
name|ExtendedValueTypeNodes
expr_stmt|;
name|StringMap
operator|<
name|SDNode
operator|*
operator|>
name|ExternalSymbols
expr_stmt|;
name|std
operator|::
name|map
operator|<
name|std
operator|::
name|pair
operator|<
name|std
operator|::
name|string
operator|,
name|unsigned
name|char
operator|>
operator|,
name|SDNode
operator|*
operator|>
name|TargetExternalSymbols
expr_stmt|;
name|DenseMap
operator|<
name|MCSymbol
operator|*
operator|,
name|SDNode
operator|*
operator|>
name|MCSymbols
expr_stmt|;
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_expr_stmt
name|template
operator|<
operator|>
expr|struct
name|GraphTraits
operator|<
name|SelectionDAG
operator|*
operator|>
operator|:
name|public
name|GraphTraits
operator|<
name|SDNode
operator|*
operator|>
block|{
typedef|typedef
name|pointer_iterator
operator|<
name|SelectionDAG
operator|::
name|allnodes_iterator
operator|>
name|nodes_iterator
expr_stmt|;
specifier|static
name|nodes_iterator
name|nodes_begin
argument_list|(
argument|SelectionDAG *G
argument_list|)
block|{
return|return
name|nodes_iterator
argument_list|(
name|G
operator|->
name|allnodes_begin
argument_list|()
argument_list|)
return|;
block|}
specifier|static
name|nodes_iterator
name|nodes_end
argument_list|(
argument|SelectionDAG *G
argument_list|)
block|{
return|return
name|nodes_iterator
argument_list|(
name|G
operator|->
name|allnodes_end
argument_list|()
argument_list|)
return|;
block|}
block|}
end_expr_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|TargetMemSDNode
operator|>
name|SDValue
name|SelectionDAG
operator|::
name|getTargetMemSDNode
argument_list|(
argument|SDVTList VTs
argument_list|,
argument|ArrayRef<SDValue> Ops
argument_list|,
argument|const SDLoc&dl
argument_list|,
argument|EVT MemVT
argument_list|,
argument|MachineMemOperand *MMO
argument_list|)
block|{
comment|/// Compose node ID and try to find an existing node.
name|FoldingSetNodeID
name|ID
block|;
name|unsigned
name|Opcode
operator|=
name|TargetMemSDNode
argument_list|(
name|dl
operator|.
name|getIROrder
argument_list|()
argument_list|,
name|DebugLoc
argument_list|()
argument_list|,
name|VTs
argument_list|,
name|MemVT
argument_list|,
name|MMO
argument_list|)
operator|.
name|getOpcode
argument_list|()
block|;
name|ID
operator|.
name|AddInteger
argument_list|(
name|Opcode
argument_list|)
block|;
name|ID
operator|.
name|AddPointer
argument_list|(
name|VTs
operator|.
name|VTs
argument_list|)
block|;
for|for
control|(
name|auto
operator|&
name|Op
operator|:
name|Ops
control|)
block|{
name|ID
operator|.
name|AddPointer
argument_list|(
name|Op
operator|.
name|getNode
argument_list|()
argument_list|)
expr_stmt|;
name|ID
operator|.
name|AddInteger
argument_list|(
name|Op
operator|.
name|getResNo
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|ID
operator|.
name|AddInteger
argument_list|(
name|MemVT
operator|.
name|getRawBits
argument_list|()
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|ID
operator|.
name|AddInteger
argument_list|(
name|MMO
operator|->
name|getPointerInfo
argument_list|()
operator|.
name|getAddrSpace
argument_list|()
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|ID
operator|.
name|AddInteger
argument_list|(
name|getSyntheticNodeSubclassData
operator|<
name|TargetMemSDNode
operator|>
operator|(
name|dl
operator|.
name|getIROrder
argument_list|()
operator|,
name|VTs
operator|,
name|MemVT
operator|,
name|MMO
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|void
modifier|*
name|IP
init|=
name|nullptr
decl_stmt|;
end_decl_stmt

begin_if
if|if
condition|(
name|SDNode
modifier|*
name|E
init|=
name|FindNodeOrInsertPos
argument_list|(
name|ID
argument_list|,
name|dl
argument_list|,
name|IP
argument_list|)
condition|)
block|{
name|cast
operator|<
name|TargetMemSDNode
operator|>
operator|(
name|E
operator|)
operator|->
name|refineAlignment
argument_list|(
name|MMO
argument_list|)
expr_stmt|;
return|return
name|SDValue
argument_list|(
name|E
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_if

begin_comment
comment|/// Existing node was not found. Create a new one.
end_comment

begin_expr_stmt
name|auto
operator|*
name|N
operator|=
name|newSDNode
operator|<
name|TargetMemSDNode
operator|>
operator|(
name|dl
operator|.
name|getIROrder
argument_list|()
operator|,
name|dl
operator|.
name|getDebugLoc
argument_list|()
operator|,
name|VTs
operator|,
name|MemVT
operator|,
name|MMO
operator|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|createOperands
argument_list|(
name|N
argument_list|,
name|Ops
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|CSEMap
operator|.
name|InsertNode
argument_list|(
name|N
argument_list|,
name|IP
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|InsertNode
argument_list|(
name|N
argument_list|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|SDValue
argument_list|(
name|N
argument_list|,
literal|0
argument_list|)
return|;
end_return

begin_comment
unit|}  }
comment|// end namespace llvm
end_comment

begin_endif
endif|#
directive|endif
end_endif

end_unit

