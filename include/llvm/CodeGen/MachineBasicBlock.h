begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===- llvm/CodeGen/MachineBasicBlock.h -------------------------*- C++ -*-===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// Collect the sequence of machine instructions for a basic block.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LLVM_CODEGEN_MACHINEBASICBLOCK_H
end_ifndef

begin_define
define|#
directive|define
name|LLVM_CODEGEN_MACHINEBASICBLOCK_H
end_define

begin_include
include|#
directive|include
file|"llvm/ADT/GraphTraits.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/ilist.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/ilist_node.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/iterator_range.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/simple_ilist.h"
end_include

begin_include
include|#
directive|include
file|"llvm/CodeGen/MachineInstrBundleIterator.h"
end_include

begin_include
include|#
directive|include
file|"llvm/CodeGen/MachineInstr.h"
end_include

begin_include
include|#
directive|include
file|"llvm/IR/DebugLoc.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/BranchProbability.h"
end_include

begin_include
include|#
directive|include
file|"llvm/MC/LaneBitmask.h"
end_include

begin_include
include|#
directive|include
file|"llvm/MC/MCRegisterInfo.h"
end_include

begin_include
include|#
directive|include
file|<cassert>
end_include

begin_include
include|#
directive|include
file|<cstdint>
end_include

begin_include
include|#
directive|include
file|<functional>
end_include

begin_include
include|#
directive|include
file|<iterator>
end_include

begin_include
include|#
directive|include
file|<string>
end_include

begin_include
include|#
directive|include
file|<vector>
end_include

begin_decl_stmt
name|namespace
name|llvm
block|{
name|class
name|BasicBlock
decl_stmt|;
name|class
name|MachineFunction
decl_stmt|;
name|class
name|MCSymbol
decl_stmt|;
name|class
name|ModuleSlotTracker
decl_stmt|;
name|class
name|Pass
decl_stmt|;
name|class
name|SlotIndexes
decl_stmt|;
name|class
name|StringRef
decl_stmt|;
name|class
name|raw_ostream
decl_stmt|;
name|class
name|TargetRegisterClass
decl_stmt|;
name|class
name|TargetRegisterInfo
decl_stmt|;
name|template
operator|<
operator|>
expr|struct
name|ilist_traits
operator|<
name|MachineInstr
operator|>
block|{
name|private
operator|:
name|friend
name|class
name|MachineBasicBlock
block|;
comment|// Set by the owning MachineBasicBlock.
name|MachineBasicBlock
operator|*
name|Parent
block|;
name|using
name|instr_iterator
operator|=
name|simple_ilist
operator|<
name|MachineInstr
block|,
name|ilist_sentinel_tracking
operator|<
name|true
operator|>>
operator|::
name|iterator
block|;
name|public
operator|:
name|void
name|addNodeToList
argument_list|(
name|MachineInstr
operator|*
name|N
argument_list|)
block|;
name|void
name|removeNodeFromList
argument_list|(
name|MachineInstr
operator|*
name|N
argument_list|)
block|;
name|void
name|transferNodesFromList
argument_list|(
argument|ilist_traits&OldList
argument_list|,
argument|instr_iterator First
argument_list|,
argument|instr_iterator Last
argument_list|)
block|;
name|void
name|deleteNode
argument_list|(
name|MachineInstr
operator|*
name|MI
argument_list|)
block|; }
expr_stmt|;
name|class
name|MachineBasicBlock
range|:
name|public
name|ilist_node_with_parent
operator|<
name|MachineBasicBlock
decl_stmt|,
name|MachineFunction
decl|>
block|{
name|public
label|:
comment|/// Pair of physical register and lane mask.
comment|/// This is not simply a std::pair typedef because the members should be named
comment|/// clearly as they both have an integer type.
struct|struct
name|RegisterMaskPair
block|{
name|public
label|:
name|MCPhysReg
name|PhysReg
decl_stmt|;
name|LaneBitmask
name|LaneMask
decl_stmt|;
name|RegisterMaskPair
argument_list|(
argument|MCPhysReg PhysReg
argument_list|,
argument|LaneBitmask LaneMask
argument_list|)
block|:
name|PhysReg
argument_list|(
name|PhysReg
argument_list|)
operator|,
name|LaneMask
argument_list|(
argument|LaneMask
argument_list|)
block|{}
block|}
struct|;
name|private
label|:
name|using
name|Instructions
init|=
name|ilist
operator|<
name|MachineInstr
decl_stmt|,
name|ilist_sentinel_tracking
decl|<
name|true
decl|>>
decl_stmt|;
name|Instructions
name|Insts
decl_stmt|;
specifier|const
name|BasicBlock
modifier|*
name|BB
decl_stmt|;
name|int
name|Number
decl_stmt|;
name|MachineFunction
modifier|*
name|xParent
decl_stmt|;
comment|/// Keep track of the predecessor / successor basic blocks.
name|std
operator|::
name|vector
operator|<
name|MachineBasicBlock
operator|*
operator|>
name|Predecessors
expr_stmt|;
name|std
operator|::
name|vector
operator|<
name|MachineBasicBlock
operator|*
operator|>
name|Successors
expr_stmt|;
comment|/// Keep track of the probabilities to the successors. This vector has the
comment|/// same order as Successors, or it is empty if we don't use it (disable
comment|/// optimization).
name|std
operator|::
name|vector
operator|<
name|BranchProbability
operator|>
name|Probs
expr_stmt|;
name|using
name|probability_iterator
init|=
name|std
operator|::
name|vector
operator|<
name|BranchProbability
operator|>
operator|::
name|iterator
decl_stmt|;
name|using
name|const_probability_iterator
init|=
name|std
operator|::
name|vector
operator|<
name|BranchProbability
operator|>
operator|::
name|const_iterator
decl_stmt|;
comment|/// Keep track of the physical registers that are livein of the basicblock.
name|using
name|LiveInVector
init|=
name|std
operator|::
name|vector
operator|<
name|RegisterMaskPair
operator|>
decl_stmt|;
name|LiveInVector
name|LiveIns
decl_stmt|;
comment|/// Alignment of the basic block. Zero if the basic block does not need to be
comment|/// aligned. The alignment is specified as log2(bytes).
name|unsigned
name|Alignment
init|=
literal|0
decl_stmt|;
comment|/// Indicate that this basic block is entered via an exception handler.
name|bool
name|IsEHPad
init|=
name|false
decl_stmt|;
comment|/// Indicate that this basic block is potentially the target of an indirect
comment|/// branch.
name|bool
name|AddressTaken
init|=
name|false
decl_stmt|;
comment|/// Indicate that this basic block is the entry block of an EH funclet.
name|bool
name|IsEHFuncletEntry
init|=
name|false
decl_stmt|;
comment|/// Indicate that this basic block is the entry block of a cleanup funclet.
name|bool
name|IsCleanupFuncletEntry
init|=
name|false
decl_stmt|;
comment|/// \brief since getSymbol is a relatively heavy-weight operation, the symbol
comment|/// is only computed once and is cached.
name|mutable
name|MCSymbol
modifier|*
name|CachedMCSymbol
init|=
name|nullptr
decl_stmt|;
comment|// Intrusive list support
name|MachineBasicBlock
argument_list|()
operator|=
expr|default
expr_stmt|;
name|explicit
name|MachineBasicBlock
parameter_list|(
name|MachineFunction
modifier|&
name|MF
parameter_list|,
specifier|const
name|BasicBlock
modifier|*
name|BB
parameter_list|)
function_decl|;
operator|~
name|MachineBasicBlock
argument_list|()
expr_stmt|;
comment|// MachineBasicBlocks are allocated and owned by MachineFunction.
name|friend
name|class
name|MachineFunction
decl_stmt|;
name|public
label|:
comment|/// Return the LLVM basic block that this instance corresponded to originally.
comment|/// Note that this may be NULL if this instance does not correspond directly
comment|/// to an LLVM basic block.
specifier|const
name|BasicBlock
operator|*
name|getBasicBlock
argument_list|()
specifier|const
block|{
return|return
name|BB
return|;
block|}
comment|/// Return the name of the corresponding LLVM basic block, or an empty string.
name|StringRef
name|getName
argument_list|()
specifier|const
expr_stmt|;
comment|/// Return a formatted string to identify this block and its parent function.
name|std
operator|::
name|string
name|getFullName
argument_list|()
specifier|const
expr_stmt|;
comment|/// Test whether this block is potentially the target of an indirect branch.
name|bool
name|hasAddressTaken
argument_list|()
specifier|const
block|{
return|return
name|AddressTaken
return|;
block|}
comment|/// Set this block to reflect that it potentially is the target of an indirect
comment|/// branch.
name|void
name|setHasAddressTaken
parameter_list|()
block|{
name|AddressTaken
operator|=
name|true
expr_stmt|;
block|}
comment|/// Return the MachineFunction containing this basic block.
specifier|const
name|MachineFunction
operator|*
name|getParent
argument_list|()
specifier|const
block|{
return|return
name|xParent
return|;
block|}
name|MachineFunction
modifier|*
name|getParent
parameter_list|()
block|{
return|return
name|xParent
return|;
block|}
name|using
name|instr_iterator
init|=
name|Instructions
operator|::
name|iterator
decl_stmt|;
name|using
name|const_instr_iterator
init|=
name|Instructions
operator|::
name|const_iterator
decl_stmt|;
name|using
name|reverse_instr_iterator
init|=
name|Instructions
operator|::
name|reverse_iterator
decl_stmt|;
name|using
name|const_reverse_instr_iterator
init|=
name|Instructions
operator|::
name|const_reverse_iterator
decl_stmt|;
name|using
name|iterator
init|=
name|MachineInstrBundleIterator
operator|<
name|MachineInstr
operator|>
decl_stmt|;
name|using
name|const_iterator
init|=
name|MachineInstrBundleIterator
operator|<
specifier|const
name|MachineInstr
operator|>
decl_stmt|;
name|using
name|reverse_iterator
init|=
name|MachineInstrBundleIterator
operator|<
name|MachineInstr
decl_stmt|,
name|true
decl|>
decl_stmt|;
name|using
name|const_reverse_iterator
init|=
name|MachineInstrBundleIterator
operator|<
specifier|const
name|MachineInstr
decl_stmt|,
name|true
decl|>
decl_stmt|;
name|unsigned
name|size
argument_list|()
specifier|const
block|{
return|return
operator|(
name|unsigned
operator|)
name|Insts
operator|.
name|size
argument_list|()
return|;
block|}
name|bool
name|empty
argument_list|()
specifier|const
block|{
return|return
name|Insts
operator|.
name|empty
argument_list|()
return|;
block|}
name|MachineInstr
modifier|&
name|instr_front
parameter_list|()
block|{
return|return
name|Insts
operator|.
name|front
argument_list|()
return|;
block|}
name|MachineInstr
modifier|&
name|instr_back
parameter_list|()
block|{
return|return
name|Insts
operator|.
name|back
argument_list|()
return|;
block|}
specifier|const
name|MachineInstr
operator|&
name|instr_front
argument_list|()
specifier|const
block|{
return|return
name|Insts
operator|.
name|front
argument_list|()
return|;
block|}
specifier|const
name|MachineInstr
operator|&
name|instr_back
argument_list|()
specifier|const
block|{
return|return
name|Insts
operator|.
name|back
argument_list|()
return|;
block|}
name|MachineInstr
modifier|&
name|front
parameter_list|()
block|{
return|return
name|Insts
operator|.
name|front
argument_list|()
return|;
block|}
name|MachineInstr
modifier|&
name|back
parameter_list|()
block|{
return|return
operator|*
operator|--
name|end
argument_list|()
return|;
block|}
specifier|const
name|MachineInstr
operator|&
name|front
argument_list|()
specifier|const
block|{
return|return
name|Insts
operator|.
name|front
argument_list|()
return|;
block|}
specifier|const
name|MachineInstr
operator|&
name|back
argument_list|()
specifier|const
block|{
return|return
operator|*
operator|--
name|end
argument_list|()
return|;
block|}
name|instr_iterator
name|instr_begin
parameter_list|()
block|{
return|return
name|Insts
operator|.
name|begin
argument_list|()
return|;
block|}
name|const_instr_iterator
name|instr_begin
argument_list|()
specifier|const
block|{
return|return
name|Insts
operator|.
name|begin
argument_list|()
return|;
block|}
name|instr_iterator
name|instr_end
parameter_list|()
block|{
return|return
name|Insts
operator|.
name|end
argument_list|()
return|;
block|}
name|const_instr_iterator
name|instr_end
argument_list|()
specifier|const
block|{
return|return
name|Insts
operator|.
name|end
argument_list|()
return|;
block|}
name|reverse_instr_iterator
name|instr_rbegin
parameter_list|()
block|{
return|return
name|Insts
operator|.
name|rbegin
argument_list|()
return|;
block|}
name|const_reverse_instr_iterator
name|instr_rbegin
argument_list|()
specifier|const
block|{
return|return
name|Insts
operator|.
name|rbegin
argument_list|()
return|;
block|}
name|reverse_instr_iterator
name|instr_rend
parameter_list|()
block|{
return|return
name|Insts
operator|.
name|rend
argument_list|()
return|;
block|}
name|const_reverse_instr_iterator
name|instr_rend
argument_list|()
specifier|const
block|{
return|return
name|Insts
operator|.
name|rend
argument_list|()
return|;
block|}
name|using
name|instr_range
init|=
name|iterator_range
operator|<
name|instr_iterator
operator|>
decl_stmt|;
name|using
name|const_instr_range
init|=
name|iterator_range
operator|<
name|const_instr_iterator
operator|>
decl_stmt|;
name|instr_range
name|instrs
parameter_list|()
block|{
return|return
name|instr_range
argument_list|(
name|instr_begin
argument_list|()
argument_list|,
name|instr_end
argument_list|()
argument_list|)
return|;
block|}
name|const_instr_range
name|instrs
argument_list|()
specifier|const
block|{
return|return
name|const_instr_range
argument_list|(
name|instr_begin
argument_list|()
argument_list|,
name|instr_end
argument_list|()
argument_list|)
return|;
block|}
name|iterator
name|begin
parameter_list|()
block|{
return|return
name|instr_begin
argument_list|()
return|;
block|}
name|const_iterator
name|begin
argument_list|()
specifier|const
block|{
return|return
name|instr_begin
argument_list|()
return|;
block|}
name|iterator
name|end
parameter_list|()
block|{
return|return
name|instr_end
argument_list|()
return|;
block|}
name|const_iterator
name|end
argument_list|()
specifier|const
block|{
return|return
name|instr_end
argument_list|()
return|;
block|}
name|reverse_iterator
name|rbegin
parameter_list|()
block|{
return|return
name|reverse_iterator
operator|::
name|getAtBundleBegin
argument_list|(
name|instr_rbegin
argument_list|()
argument_list|)
return|;
block|}
name|const_reverse_iterator
name|rbegin
argument_list|()
specifier|const
block|{
return|return
name|const_reverse_iterator
operator|::
name|getAtBundleBegin
argument_list|(
name|instr_rbegin
argument_list|()
argument_list|)
return|;
block|}
name|reverse_iterator
name|rend
parameter_list|()
block|{
return|return
name|reverse_iterator
argument_list|(
name|instr_rend
argument_list|()
argument_list|)
return|;
block|}
name|const_reverse_iterator
name|rend
argument_list|()
specifier|const
block|{
return|return
name|const_reverse_iterator
argument_list|(
name|instr_rend
argument_list|()
argument_list|)
return|;
block|}
comment|/// Support for MachineInstr::getNextNode().
specifier|static
name|Instructions
name|MachineBasicBlock
operator|::
operator|*
name|getSublistAccess
argument_list|(
argument|MachineInstr *
argument_list|)
block|{
return|return
operator|&
name|MachineBasicBlock
operator|::
name|Insts
return|;
block|}
specifier|inline
name|iterator_range
operator|<
name|iterator
operator|>
name|terminators
argument_list|()
block|{
return|return
name|make_range
argument_list|(
name|getFirstTerminator
argument_list|()
argument_list|,
name|end
argument_list|()
argument_list|)
return|;
block|}
specifier|inline
name|iterator_range
operator|<
name|const_iterator
operator|>
name|terminators
argument_list|()
specifier|const
block|{
return|return
name|make_range
argument_list|(
name|getFirstTerminator
argument_list|()
argument_list|,
name|end
argument_list|()
argument_list|)
return|;
block|}
comment|// Machine-CFG iterators
name|using
name|pred_iterator
init|=
name|std
operator|::
name|vector
operator|<
name|MachineBasicBlock
operator|*
operator|>
operator|::
name|iterator
decl_stmt|;
name|using
name|const_pred_iterator
init|=
name|std
operator|::
name|vector
operator|<
name|MachineBasicBlock
operator|*
operator|>
operator|::
name|const_iterator
decl_stmt|;
name|using
name|succ_iterator
init|=
name|std
operator|::
name|vector
operator|<
name|MachineBasicBlock
operator|*
operator|>
operator|::
name|iterator
decl_stmt|;
name|using
name|const_succ_iterator
init|=
name|std
operator|::
name|vector
operator|<
name|MachineBasicBlock
operator|*
operator|>
operator|::
name|const_iterator
decl_stmt|;
name|using
name|pred_reverse_iterator
init|=
name|std
operator|::
name|vector
operator|<
name|MachineBasicBlock
operator|*
operator|>
operator|::
name|reverse_iterator
decl_stmt|;
name|using
name|const_pred_reverse_iterator
init|=
name|std
operator|::
name|vector
operator|<
name|MachineBasicBlock
operator|*
operator|>
operator|::
name|const_reverse_iterator
decl_stmt|;
name|using
name|succ_reverse_iterator
init|=
name|std
operator|::
name|vector
operator|<
name|MachineBasicBlock
operator|*
operator|>
operator|::
name|reverse_iterator
decl_stmt|;
name|using
name|const_succ_reverse_iterator
init|=
name|std
operator|::
name|vector
operator|<
name|MachineBasicBlock
operator|*
operator|>
operator|::
name|const_reverse_iterator
decl_stmt|;
name|pred_iterator
name|pred_begin
parameter_list|()
block|{
return|return
name|Predecessors
operator|.
name|begin
argument_list|()
return|;
block|}
name|const_pred_iterator
name|pred_begin
argument_list|()
specifier|const
block|{
return|return
name|Predecessors
operator|.
name|begin
argument_list|()
return|;
block|}
name|pred_iterator
name|pred_end
parameter_list|()
block|{
return|return
name|Predecessors
operator|.
name|end
argument_list|()
return|;
block|}
name|const_pred_iterator
name|pred_end
argument_list|()
specifier|const
block|{
return|return
name|Predecessors
operator|.
name|end
argument_list|()
return|;
block|}
name|pred_reverse_iterator
name|pred_rbegin
parameter_list|()
block|{
return|return
name|Predecessors
operator|.
name|rbegin
argument_list|()
return|;
block|}
name|const_pred_reverse_iterator
name|pred_rbegin
argument_list|()
specifier|const
block|{
return|return
name|Predecessors
operator|.
name|rbegin
argument_list|()
return|;
block|}
name|pred_reverse_iterator
name|pred_rend
parameter_list|()
block|{
return|return
name|Predecessors
operator|.
name|rend
argument_list|()
return|;
block|}
name|const_pred_reverse_iterator
name|pred_rend
argument_list|()
specifier|const
block|{
return|return
name|Predecessors
operator|.
name|rend
argument_list|()
return|;
block|}
name|unsigned
name|pred_size
argument_list|()
specifier|const
block|{
return|return
operator|(
name|unsigned
operator|)
name|Predecessors
operator|.
name|size
argument_list|()
return|;
block|}
name|bool
name|pred_empty
argument_list|()
specifier|const
block|{
return|return
name|Predecessors
operator|.
name|empty
argument_list|()
return|;
block|}
name|succ_iterator
name|succ_begin
parameter_list|()
block|{
return|return
name|Successors
operator|.
name|begin
argument_list|()
return|;
block|}
name|const_succ_iterator
name|succ_begin
argument_list|()
specifier|const
block|{
return|return
name|Successors
operator|.
name|begin
argument_list|()
return|;
block|}
name|succ_iterator
name|succ_end
parameter_list|()
block|{
return|return
name|Successors
operator|.
name|end
argument_list|()
return|;
block|}
name|const_succ_iterator
name|succ_end
argument_list|()
specifier|const
block|{
return|return
name|Successors
operator|.
name|end
argument_list|()
return|;
block|}
name|succ_reverse_iterator
name|succ_rbegin
parameter_list|()
block|{
return|return
name|Successors
operator|.
name|rbegin
argument_list|()
return|;
block|}
name|const_succ_reverse_iterator
name|succ_rbegin
argument_list|()
specifier|const
block|{
return|return
name|Successors
operator|.
name|rbegin
argument_list|()
return|;
block|}
name|succ_reverse_iterator
name|succ_rend
parameter_list|()
block|{
return|return
name|Successors
operator|.
name|rend
argument_list|()
return|;
block|}
name|const_succ_reverse_iterator
name|succ_rend
argument_list|()
specifier|const
block|{
return|return
name|Successors
operator|.
name|rend
argument_list|()
return|;
block|}
name|unsigned
name|succ_size
argument_list|()
specifier|const
block|{
return|return
operator|(
name|unsigned
operator|)
name|Successors
operator|.
name|size
argument_list|()
return|;
block|}
name|bool
name|succ_empty
argument_list|()
specifier|const
block|{
return|return
name|Successors
operator|.
name|empty
argument_list|()
return|;
block|}
specifier|inline
name|iterator_range
operator|<
name|pred_iterator
operator|>
name|predecessors
argument_list|()
block|{
return|return
name|make_range
argument_list|(
name|pred_begin
argument_list|()
argument_list|,
name|pred_end
argument_list|()
argument_list|)
return|;
block|}
specifier|inline
name|iterator_range
operator|<
name|const_pred_iterator
operator|>
name|predecessors
argument_list|()
specifier|const
block|{
return|return
name|make_range
argument_list|(
name|pred_begin
argument_list|()
argument_list|,
name|pred_end
argument_list|()
argument_list|)
return|;
block|}
specifier|inline
name|iterator_range
operator|<
name|succ_iterator
operator|>
name|successors
argument_list|()
block|{
return|return
name|make_range
argument_list|(
name|succ_begin
argument_list|()
argument_list|,
name|succ_end
argument_list|()
argument_list|)
return|;
block|}
specifier|inline
name|iterator_range
operator|<
name|const_succ_iterator
operator|>
name|successors
argument_list|()
specifier|const
block|{
return|return
name|make_range
argument_list|(
name|succ_begin
argument_list|()
argument_list|,
name|succ_end
argument_list|()
argument_list|)
return|;
block|}
comment|// LiveIn management methods.
comment|/// Adds the specified register as a live in. Note that it is an error to add
comment|/// the same register to the same set more than once unless the intention is
comment|/// to call sortUniqueLiveIns after all registers are added.
name|void
name|addLiveIn
parameter_list|(
name|MCPhysReg
name|PhysReg
parameter_list|,
name|LaneBitmask
name|LaneMask
init|=
name|LaneBitmask
operator|::
name|getAll
argument_list|()
parameter_list|)
block|{
name|LiveIns
operator|.
name|push_back
argument_list|(
name|RegisterMaskPair
argument_list|(
name|PhysReg
argument_list|,
name|LaneMask
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|void
name|addLiveIn
parameter_list|(
specifier|const
name|RegisterMaskPair
modifier|&
name|RegMaskPair
parameter_list|)
block|{
name|LiveIns
operator|.
name|push_back
argument_list|(
name|RegMaskPair
argument_list|)
expr_stmt|;
block|}
comment|/// Sorts and uniques the LiveIns vector. It can be significantly faster to do
comment|/// this than repeatedly calling isLiveIn before calling addLiveIn for every
comment|/// LiveIn insertion.
name|void
name|sortUniqueLiveIns
parameter_list|()
function_decl|;
comment|/// Clear live in list.
name|void
name|clearLiveIns
parameter_list|()
function_decl|;
comment|/// Add PhysReg as live in to this block, and ensure that there is a copy of
comment|/// PhysReg to a virtual register of class RC. Return the virtual register
comment|/// that is a copy of the live in PhysReg.
name|unsigned
name|addLiveIn
parameter_list|(
name|MCPhysReg
name|PhysReg
parameter_list|,
specifier|const
name|TargetRegisterClass
modifier|*
name|RC
parameter_list|)
function_decl|;
comment|/// Remove the specified register from the live in set.
name|void
name|removeLiveIn
parameter_list|(
name|MCPhysReg
name|Reg
parameter_list|,
name|LaneBitmask
name|LaneMask
init|=
name|LaneBitmask
operator|::
name|getAll
argument_list|()
parameter_list|)
function_decl|;
comment|/// Return true if the specified register is in the live in set.
name|bool
name|isLiveIn
argument_list|(
name|MCPhysReg
name|Reg
argument_list|,
name|LaneBitmask
name|LaneMask
operator|=
name|LaneBitmask
operator|::
name|getAll
argument_list|()
argument_list|)
decl|const
decl_stmt|;
comment|// Iteration support for live in sets.  These sets are kept in sorted
comment|// order by their register number.
name|using
name|livein_iterator
init|=
name|LiveInVector
operator|::
name|const_iterator
decl_stmt|;
ifndef|#
directive|ifndef
name|NDEBUG
comment|/// Unlike livein_begin, this method does not check that the liveness
comment|/// information is accurate. Still for debug purposes it may be useful
comment|/// to have iterators that won't assert if the liveness information
comment|/// is not current.
name|livein_iterator
name|livein_begin_dbg
argument_list|()
specifier|const
block|{
return|return
name|LiveIns
operator|.
name|begin
argument_list|()
return|;
block|}
name|iterator_range
operator|<
name|livein_iterator
operator|>
name|liveins_dbg
argument_list|()
specifier|const
block|{
return|return
name|make_range
argument_list|(
name|livein_begin_dbg
argument_list|()
argument_list|,
name|livein_end
argument_list|()
argument_list|)
return|;
block|}
endif|#
directive|endif
name|livein_iterator
name|livein_begin
argument_list|()
specifier|const
expr_stmt|;
name|livein_iterator
name|livein_end
argument_list|()
specifier|const
block|{
return|return
name|LiveIns
operator|.
name|end
argument_list|()
return|;
block|}
name|bool
name|livein_empty
argument_list|()
specifier|const
block|{
return|return
name|LiveIns
operator|.
name|empty
argument_list|()
return|;
block|}
name|iterator_range
operator|<
name|livein_iterator
operator|>
name|liveins
argument_list|()
specifier|const
block|{
return|return
name|make_range
argument_list|(
name|livein_begin
argument_list|()
argument_list|,
name|livein_end
argument_list|()
argument_list|)
return|;
block|}
comment|/// Remove entry from the livein set and return iterator to the next.
name|livein_iterator
name|removeLiveIn
parameter_list|(
name|livein_iterator
name|I
parameter_list|)
function_decl|;
comment|/// Get the clobber mask for the start of this basic block. Funclets use this
comment|/// to prevent register allocation across funclet transitions.
specifier|const
name|uint32_t
modifier|*
name|getBeginClobberMask
argument_list|(
specifier|const
name|TargetRegisterInfo
operator|*
name|TRI
argument_list|)
decl|const
decl_stmt|;
comment|/// Get the clobber mask for the end of the basic block.
comment|/// \see getBeginClobberMask()
specifier|const
name|uint32_t
modifier|*
name|getEndClobberMask
argument_list|(
specifier|const
name|TargetRegisterInfo
operator|*
name|TRI
argument_list|)
decl|const
decl_stmt|;
comment|/// Return alignment of the basic block. The alignment is specified as
comment|/// log2(bytes).
name|unsigned
name|getAlignment
argument_list|()
specifier|const
block|{
return|return
name|Alignment
return|;
block|}
comment|/// Set alignment of the basic block. The alignment is specified as
comment|/// log2(bytes).
name|void
name|setAlignment
parameter_list|(
name|unsigned
name|Align
parameter_list|)
block|{
name|Alignment
operator|=
name|Align
expr_stmt|;
block|}
comment|/// Returns true if the block is a landing pad. That is this basic block is
comment|/// entered via an exception handler.
name|bool
name|isEHPad
argument_list|()
specifier|const
block|{
return|return
name|IsEHPad
return|;
block|}
comment|/// Indicates the block is a landing pad.  That is this basic block is entered
comment|/// via an exception handler.
name|void
name|setIsEHPad
parameter_list|(
name|bool
name|V
init|=
name|true
parameter_list|)
block|{
name|IsEHPad
operator|=
name|V
expr_stmt|;
block|}
name|bool
name|hasEHPadSuccessor
argument_list|()
specifier|const
expr_stmt|;
comment|/// Returns true if this is the entry block of an EH funclet.
name|bool
name|isEHFuncletEntry
argument_list|()
specifier|const
block|{
return|return
name|IsEHFuncletEntry
return|;
block|}
comment|/// Indicates if this is the entry block of an EH funclet.
name|void
name|setIsEHFuncletEntry
parameter_list|(
name|bool
name|V
init|=
name|true
parameter_list|)
block|{
name|IsEHFuncletEntry
operator|=
name|V
expr_stmt|;
block|}
comment|/// Returns true if this is the entry block of a cleanup funclet.
name|bool
name|isCleanupFuncletEntry
argument_list|()
specifier|const
block|{
return|return
name|IsCleanupFuncletEntry
return|;
block|}
comment|/// Indicates if this is the entry block of a cleanup funclet.
name|void
name|setIsCleanupFuncletEntry
parameter_list|(
name|bool
name|V
init|=
name|true
parameter_list|)
block|{
name|IsCleanupFuncletEntry
operator|=
name|V
expr_stmt|;
block|}
comment|// Code Layout methods.
comment|/// Move 'this' block before or after the specified block.  This only moves
comment|/// the block, it does not modify the CFG or adjust potential fall-throughs at
comment|/// the end of the block.
name|void
name|moveBefore
parameter_list|(
name|MachineBasicBlock
modifier|*
name|NewAfter
parameter_list|)
function_decl|;
name|void
name|moveAfter
parameter_list|(
name|MachineBasicBlock
modifier|*
name|NewBefore
parameter_list|)
function_decl|;
comment|/// Update the terminator instructions in block to account for changes to the
comment|/// layout. If the block previously used a fallthrough, it may now need a
comment|/// branch, and if it previously used branching it may now be able to use a
comment|/// fallthrough.
name|void
name|updateTerminator
parameter_list|()
function_decl|;
comment|// Machine-CFG mutators
comment|/// Add Succ as a successor of this MachineBasicBlock.  The Predecessors list
comment|/// of Succ is automatically updated. PROB parameter is stored in
comment|/// Probabilities list. The default probability is set as unknown. Mixing
comment|/// known and unknown probabilities in successor list is not allowed. When all
comment|/// successors have unknown probabilities, 1 / N is returned as the
comment|/// probability for each successor, where N is the number of successors.
comment|///
comment|/// Note that duplicate Machine CFG edges are not allowed.
name|void
name|addSuccessor
parameter_list|(
name|MachineBasicBlock
modifier|*
name|Succ
parameter_list|,
name|BranchProbability
name|Prob
init|=
name|BranchProbability
operator|::
name|getUnknown
argument_list|()
parameter_list|)
function_decl|;
comment|/// Add Succ as a successor of this MachineBasicBlock.  The Predecessors list
comment|/// of Succ is automatically updated. The probability is not provided because
comment|/// BPI is not available (e.g. -O0 is used), in which case edge probabilities
comment|/// won't be used. Using this interface can save some space.
name|void
name|addSuccessorWithoutProb
parameter_list|(
name|MachineBasicBlock
modifier|*
name|Succ
parameter_list|)
function_decl|;
comment|/// Set successor probability of a given iterator.
name|void
name|setSuccProbability
parameter_list|(
name|succ_iterator
name|I
parameter_list|,
name|BranchProbability
name|Prob
parameter_list|)
function_decl|;
comment|/// Normalize probabilities of all successors so that the sum of them becomes
comment|/// one. This is usually done when the current update on this MBB is done, and
comment|/// the sum of its successors' probabilities is not guaranteed to be one. The
comment|/// user is responsible for the correct use of this function.
comment|/// MBB::removeSuccessor() has an option to do this automatically.
name|void
name|normalizeSuccProbs
parameter_list|()
block|{
name|BranchProbability
operator|::
name|normalizeProbabilities
argument_list|(
name|Probs
operator|.
name|begin
argument_list|()
argument_list|,
name|Probs
operator|.
name|end
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/// Validate successors' probabilities and check if the sum of them is
comment|/// approximate one. This only works in DEBUG mode.
name|void
name|validateSuccProbs
argument_list|()
specifier|const
expr_stmt|;
comment|/// Remove successor from the successors list of this MachineBasicBlock. The
comment|/// Predecessors list of Succ is automatically updated.
comment|/// If NormalizeSuccProbs is true, then normalize successors' probabilities
comment|/// after the successor is removed.
name|void
name|removeSuccessor
parameter_list|(
name|MachineBasicBlock
modifier|*
name|Succ
parameter_list|,
name|bool
name|NormalizeSuccProbs
init|=
name|false
parameter_list|)
function_decl|;
comment|/// Remove specified successor from the successors list of this
comment|/// MachineBasicBlock. The Predecessors list of Succ is automatically updated.
comment|/// If NormalizeSuccProbs is true, then normalize successors' probabilities
comment|/// after the successor is removed.
comment|/// Return the iterator to the element after the one removed.
name|succ_iterator
name|removeSuccessor
parameter_list|(
name|succ_iterator
name|I
parameter_list|,
name|bool
name|NormalizeSuccProbs
init|=
name|false
parameter_list|)
function_decl|;
comment|/// Replace successor OLD with NEW and update probability info.
name|void
name|replaceSuccessor
parameter_list|(
name|MachineBasicBlock
modifier|*
name|Old
parameter_list|,
name|MachineBasicBlock
modifier|*
name|New
parameter_list|)
function_decl|;
comment|/// Transfers all the successors from MBB to this machine basic block (i.e.,
comment|/// copies all the successors FromMBB and remove all the successors from
comment|/// FromMBB).
name|void
name|transferSuccessors
parameter_list|(
name|MachineBasicBlock
modifier|*
name|FromMBB
parameter_list|)
function_decl|;
comment|/// Transfers all the successors, as in transferSuccessors, and update PHI
comment|/// operands in the successor blocks which refer to FromMBB to refer to this.
name|void
name|transferSuccessorsAndUpdatePHIs
parameter_list|(
name|MachineBasicBlock
modifier|*
name|FromMBB
parameter_list|)
function_decl|;
comment|/// Return true if any of the successors have probabilities attached to them.
name|bool
name|hasSuccessorProbabilities
argument_list|()
specifier|const
block|{
return|return
operator|!
name|Probs
operator|.
name|empty
argument_list|()
return|;
block|}
comment|/// Return true if the specified MBB is a predecessor of this block.
name|bool
name|isPredecessor
argument_list|(
specifier|const
name|MachineBasicBlock
operator|*
name|MBB
argument_list|)
decl|const
decl_stmt|;
comment|/// Return true if the specified MBB is a successor of this block.
name|bool
name|isSuccessor
argument_list|(
specifier|const
name|MachineBasicBlock
operator|*
name|MBB
argument_list|)
decl|const
decl_stmt|;
comment|/// Return true if the specified MBB will be emitted immediately after this
comment|/// block, such that if this block exits by falling through, control will
comment|/// transfer to the specified MBB. Note that MBB need not be a successor at
comment|/// all, for example if this block ends with an unconditional branch to some
comment|/// other block.
name|bool
name|isLayoutSuccessor
argument_list|(
specifier|const
name|MachineBasicBlock
operator|*
name|MBB
argument_list|)
decl|const
decl_stmt|;
comment|/// Return the fallthrough block if the block can implicitly
comment|/// transfer control to the block after it by falling off the end of
comment|/// it.  This should return null if it can reach the block after
comment|/// it, but it uses an explicit branch to do so (e.g., a table
comment|/// jump).  Non-null return  is a conservative answer.
name|MachineBasicBlock
modifier|*
name|getFallThrough
parameter_list|()
function_decl|;
comment|/// Return true if the block can implicitly transfer control to the
comment|/// block after it by falling off the end of it.  This should return
comment|/// false if it can reach the block after it, but it uses an
comment|/// explicit branch to do so (e.g., a table jump).  True is a
comment|/// conservative answer.
name|bool
name|canFallThrough
parameter_list|()
function_decl|;
comment|/// Returns a pointer to the first instruction in this block that is not a
comment|/// PHINode instruction. When adding instructions to the beginning of the
comment|/// basic block, they should be added before the returned value, not before
comment|/// the first instruction, which might be PHI.
comment|/// Returns end() is there's no non-PHI instruction.
name|iterator
name|getFirstNonPHI
parameter_list|()
function_decl|;
comment|/// Return the first instruction in MBB after I that is not a PHI or a label.
comment|/// This is the correct point to insert lowered copies at the beginning of a
comment|/// basic block that must be before any debugging information.
name|iterator
name|SkipPHIsAndLabels
parameter_list|(
name|iterator
name|I
parameter_list|)
function_decl|;
comment|/// Return the first instruction in MBB after I that is not a PHI, label or
comment|/// debug.  This is the correct point to insert copies at the beginning of a
comment|/// basic block.
name|iterator
name|SkipPHIsLabelsAndDebug
parameter_list|(
name|iterator
name|I
parameter_list|)
function_decl|;
comment|/// Returns an iterator to the first terminator instruction of this basic
comment|/// block. If a terminator does not exist, it returns end().
name|iterator
name|getFirstTerminator
parameter_list|()
function_decl|;
name|const_iterator
name|getFirstTerminator
argument_list|()
specifier|const
block|{
return|return
name|const_cast
operator|<
name|MachineBasicBlock
operator|*
operator|>
operator|(
name|this
operator|)
operator|->
name|getFirstTerminator
argument_list|()
return|;
block|}
comment|/// Same getFirstTerminator but it ignores bundles and return an
comment|/// instr_iterator instead.
name|instr_iterator
name|getFirstInstrTerminator
parameter_list|()
function_decl|;
comment|/// Returns an iterator to the first non-debug instruction in the basic block,
comment|/// or end().
name|iterator
name|getFirstNonDebugInstr
parameter_list|()
function_decl|;
name|const_iterator
name|getFirstNonDebugInstr
argument_list|()
specifier|const
block|{
return|return
name|const_cast
operator|<
name|MachineBasicBlock
operator|*
operator|>
operator|(
name|this
operator|)
operator|->
name|getFirstNonDebugInstr
argument_list|()
return|;
block|}
comment|/// Returns an iterator to the last non-debug instruction in the basic block,
comment|/// or end().
name|iterator
name|getLastNonDebugInstr
parameter_list|()
function_decl|;
name|const_iterator
name|getLastNonDebugInstr
argument_list|()
specifier|const
block|{
return|return
name|const_cast
operator|<
name|MachineBasicBlock
operator|*
operator|>
operator|(
name|this
operator|)
operator|->
name|getLastNonDebugInstr
argument_list|()
return|;
block|}
comment|/// Convenience function that returns true if the block ends in a return
comment|/// instruction.
name|bool
name|isReturnBlock
argument_list|()
specifier|const
block|{
return|return
operator|!
name|empty
argument_list|()
operator|&&
name|back
argument_list|()
operator|.
name|isReturn
argument_list|()
return|;
block|}
comment|/// Split the critical edge from this block to the given successor block, and
comment|/// return the newly created block, or null if splitting is not possible.
comment|///
comment|/// This function updates LiveVariables, MachineDominatorTree, and
comment|/// MachineLoopInfo, as applicable.
name|MachineBasicBlock
modifier|*
name|SplitCriticalEdge
parameter_list|(
name|MachineBasicBlock
modifier|*
name|Succ
parameter_list|,
name|Pass
modifier|&
name|P
parameter_list|)
function_decl|;
comment|/// Check if the edge between this block and the given successor \p
comment|/// Succ, can be split. If this returns true a subsequent call to
comment|/// SplitCriticalEdge is guaranteed to return a valid basic block if
comment|/// no changes occured in the meantime.
name|bool
name|canSplitCriticalEdge
argument_list|(
specifier|const
name|MachineBasicBlock
operator|*
name|Succ
argument_list|)
decl|const
decl_stmt|;
name|void
name|pop_front
parameter_list|()
block|{
name|Insts
operator|.
name|pop_front
argument_list|()
expr_stmt|;
block|}
name|void
name|pop_back
parameter_list|()
block|{
name|Insts
operator|.
name|pop_back
argument_list|()
expr_stmt|;
block|}
name|void
name|push_back
parameter_list|(
name|MachineInstr
modifier|*
name|MI
parameter_list|)
block|{
name|Insts
operator|.
name|push_back
argument_list|(
name|MI
argument_list|)
expr_stmt|;
block|}
comment|/// Insert MI into the instruction list before I, possibly inside a bundle.
comment|///
comment|/// If the insertion point is inside a bundle, MI will be added to the bundle,
comment|/// otherwise MI will not be added to any bundle. That means this function
comment|/// alone can't be used to prepend or append instructions to bundles. See
comment|/// MIBundleBuilder::insert() for a more reliable way of doing that.
name|instr_iterator
name|insert
parameter_list|(
name|instr_iterator
name|I
parameter_list|,
name|MachineInstr
modifier|*
name|M
parameter_list|)
function_decl|;
comment|/// Insert a range of instructions into the instruction list before I.
name|template
operator|<
name|typename
name|IT
operator|>
name|void
name|insert
argument_list|(
argument|iterator I
argument_list|,
argument|IT S
argument_list|,
argument|IT E
argument_list|)
block|{
name|assert
argument_list|(
operator|(
name|I
operator|==
name|end
argument_list|()
operator|||
name|I
operator|->
name|getParent
argument_list|()
operator|==
name|this
operator|)
operator|&&
literal|"iterator points outside of basic block"
argument_list|)
block|;
name|Insts
operator|.
name|insert
argument_list|(
name|I
operator|.
name|getInstrIterator
argument_list|()
argument_list|,
name|S
argument_list|,
name|E
argument_list|)
block|;   }
comment|/// Insert MI into the instruction list before I.
name|iterator
name|insert
argument_list|(
argument|iterator I
argument_list|,
argument|MachineInstr *MI
argument_list|)
block|{
name|assert
argument_list|(
operator|(
name|I
operator|==
name|end
argument_list|()
operator|||
name|I
operator|->
name|getParent
argument_list|()
operator|==
name|this
operator|)
operator|&&
literal|"iterator points outside of basic block"
argument_list|)
block|;
name|assert
argument_list|(
operator|!
name|MI
operator|->
name|isBundledWithPred
argument_list|()
operator|&&
operator|!
name|MI
operator|->
name|isBundledWithSucc
argument_list|()
operator|&&
literal|"Cannot insert instruction with bundle flags"
argument_list|)
block|;
return|return
name|Insts
operator|.
name|insert
argument_list|(
name|I
operator|.
name|getInstrIterator
argument_list|()
argument_list|,
name|MI
argument_list|)
return|;
block|}
comment|/// Insert MI into the instruction list after I.
name|iterator
name|insertAfter
parameter_list|(
name|iterator
name|I
parameter_list|,
name|MachineInstr
modifier|*
name|MI
parameter_list|)
block|{
name|assert
argument_list|(
operator|(
name|I
operator|==
name|end
argument_list|()
operator|||
name|I
operator|->
name|getParent
argument_list|()
operator|==
name|this
operator|)
operator|&&
literal|"iterator points outside of basic block"
argument_list|)
expr_stmt|;
name|assert
argument_list|(
operator|!
name|MI
operator|->
name|isBundledWithPred
argument_list|()
operator|&&
operator|!
name|MI
operator|->
name|isBundledWithSucc
argument_list|()
operator|&&
literal|"Cannot insert instruction with bundle flags"
argument_list|)
expr_stmt|;
return|return
name|Insts
operator|.
name|insertAfter
argument_list|(
name|I
operator|.
name|getInstrIterator
argument_list|()
argument_list|,
name|MI
argument_list|)
return|;
block|}
comment|/// Remove an instruction from the instruction list and delete it.
comment|///
comment|/// If the instruction is part of a bundle, the other instructions in the
comment|/// bundle will still be bundled after removing the single instruction.
name|instr_iterator
name|erase
parameter_list|(
name|instr_iterator
name|I
parameter_list|)
function_decl|;
comment|/// Remove an instruction from the instruction list and delete it.
comment|///
comment|/// If the instruction is part of a bundle, the other instructions in the
comment|/// bundle will still be bundled after removing the single instruction.
name|instr_iterator
name|erase_instr
parameter_list|(
name|MachineInstr
modifier|*
name|I
parameter_list|)
block|{
return|return
name|erase
argument_list|(
name|instr_iterator
argument_list|(
name|I
argument_list|)
argument_list|)
return|;
block|}
comment|/// Remove a range of instructions from the instruction list and delete them.
name|iterator
name|erase
parameter_list|(
name|iterator
name|I
parameter_list|,
name|iterator
name|E
parameter_list|)
block|{
return|return
name|Insts
operator|.
name|erase
argument_list|(
name|I
operator|.
name|getInstrIterator
argument_list|()
argument_list|,
name|E
operator|.
name|getInstrIterator
argument_list|()
argument_list|)
return|;
block|}
comment|/// Remove an instruction or bundle from the instruction list and delete it.
comment|///
comment|/// If I points to a bundle of instructions, they are all erased.
name|iterator
name|erase
parameter_list|(
name|iterator
name|I
parameter_list|)
block|{
return|return
name|erase
argument_list|(
name|I
argument_list|,
name|std
operator|::
name|next
argument_list|(
name|I
argument_list|)
argument_list|)
return|;
block|}
comment|/// Remove an instruction from the instruction list and delete it.
comment|///
comment|/// If I is the head of a bundle of instructions, the whole bundle will be
comment|/// erased.
name|iterator
name|erase
parameter_list|(
name|MachineInstr
modifier|*
name|I
parameter_list|)
block|{
return|return
name|erase
argument_list|(
name|iterator
argument_list|(
name|I
argument_list|)
argument_list|)
return|;
block|}
comment|/// Remove the unbundled instruction from the instruction list without
comment|/// deleting it.
comment|///
comment|/// This function can not be used to remove bundled instructions, use
comment|/// remove_instr to remove individual instructions from a bundle.
name|MachineInstr
modifier|*
name|remove
parameter_list|(
name|MachineInstr
modifier|*
name|I
parameter_list|)
block|{
name|assert
argument_list|(
operator|!
name|I
operator|->
name|isBundled
argument_list|()
operator|&&
literal|"Cannot remove bundled instructions"
argument_list|)
expr_stmt|;
return|return
name|Insts
operator|.
name|remove
argument_list|(
name|instr_iterator
argument_list|(
name|I
argument_list|)
argument_list|)
return|;
block|}
comment|/// Remove the possibly bundled instruction from the instruction list
comment|/// without deleting it.
comment|///
comment|/// If the instruction is part of a bundle, the other instructions in the
comment|/// bundle will still be bundled after removing the single instruction.
name|MachineInstr
modifier|*
name|remove_instr
parameter_list|(
name|MachineInstr
modifier|*
name|I
parameter_list|)
function_decl|;
name|void
name|clear
parameter_list|()
block|{
name|Insts
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
comment|/// Take an instruction from MBB 'Other' at the position From, and insert it
comment|/// into this MBB right before 'Where'.
comment|///
comment|/// If From points to a bundle of instructions, the whole bundle is moved.
name|void
name|splice
parameter_list|(
name|iterator
name|Where
parameter_list|,
name|MachineBasicBlock
modifier|*
name|Other
parameter_list|,
name|iterator
name|From
parameter_list|)
block|{
comment|// The range splice() doesn't allow noop moves, but this one does.
if|if
condition|(
name|Where
operator|!=
name|From
condition|)
name|splice
argument_list|(
name|Where
argument_list|,
name|Other
argument_list|,
name|From
argument_list|,
name|std
operator|::
name|next
argument_list|(
name|From
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/// Take a block of instructions from MBB 'Other' in the range [From, To),
comment|/// and insert them into this MBB right before 'Where'.
comment|///
comment|/// The instruction at 'Where' must not be included in the range of
comment|/// instructions to move.
name|void
name|splice
parameter_list|(
name|iterator
name|Where
parameter_list|,
name|MachineBasicBlock
modifier|*
name|Other
parameter_list|,
name|iterator
name|From
parameter_list|,
name|iterator
name|To
parameter_list|)
block|{
name|Insts
operator|.
name|splice
argument_list|(
name|Where
operator|.
name|getInstrIterator
argument_list|()
argument_list|,
name|Other
operator|->
name|Insts
argument_list|,
name|From
operator|.
name|getInstrIterator
argument_list|()
argument_list|,
name|To
operator|.
name|getInstrIterator
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/// This method unlinks 'this' from the containing function, and returns it,
comment|/// but does not delete it.
name|MachineBasicBlock
modifier|*
name|removeFromParent
parameter_list|()
function_decl|;
comment|/// This method unlinks 'this' from the containing function and deletes it.
name|void
name|eraseFromParent
parameter_list|()
function_decl|;
comment|/// Given a machine basic block that branched to 'Old', change the code and
comment|/// CFG so that it branches to 'New' instead.
name|void
name|ReplaceUsesOfBlockWith
parameter_list|(
name|MachineBasicBlock
modifier|*
name|Old
parameter_list|,
name|MachineBasicBlock
modifier|*
name|New
parameter_list|)
function_decl|;
comment|/// Various pieces of code can cause excess edges in the CFG to be inserted.
comment|/// If we have proven that MBB can only branch to DestA and DestB, remove any
comment|/// other MBB successors from the CFG. DestA and DestB can be null. Besides
comment|/// DestA and DestB, retain other edges leading to LandingPads (currently
comment|/// there can be only one; we don't check or require that here). Note it is
comment|/// possible that DestA and/or DestB are LandingPads.
name|bool
name|CorrectExtraCFGEdges
parameter_list|(
name|MachineBasicBlock
modifier|*
name|DestA
parameter_list|,
name|MachineBasicBlock
modifier|*
name|DestB
parameter_list|,
name|bool
name|IsCond
parameter_list|)
function_decl|;
comment|/// Find the next valid DebugLoc starting at MBBI, skipping any DBG_VALUE
comment|/// instructions.  Return UnknownLoc if there is none.
name|DebugLoc
name|findDebugLoc
parameter_list|(
name|instr_iterator
name|MBBI
parameter_list|)
function_decl|;
name|DebugLoc
name|findDebugLoc
parameter_list|(
name|iterator
name|MBBI
parameter_list|)
block|{
return|return
name|findDebugLoc
argument_list|(
name|MBBI
operator|.
name|getInstrIterator
argument_list|()
argument_list|)
return|;
block|}
comment|/// Find and return the merged DebugLoc of the branch instructions of the
comment|/// block. Return UnknownLoc if there is none.
name|DebugLoc
name|findBranchDebugLoc
parameter_list|()
function_decl|;
comment|/// Possible outcome of a register liveness query to computeRegisterLiveness()
enum|enum
name|LivenessQueryResult
block|{
name|LQR_Live
block|,
comment|///< Register is known to be (at least partially) live.
name|LQR_Dead
block|,
comment|///< Register is known to be fully dead.
name|LQR_Unknown
comment|///< Register liveness not decidable from local neighborhood.
block|}
enum|;
comment|/// Return whether (physical) register \p Reg has been<def>ined and not
comment|///<kill>ed as of just before \p Before.
comment|///
comment|/// Search is localised to a neighborhood of \p Neighborhood instructions
comment|/// before (searching for defs or kills) and \p Neighborhood instructions
comment|/// after (searching just for defs) \p Before.
comment|///
comment|/// \p Reg must be a physical register.
name|LivenessQueryResult
name|computeRegisterLiveness
argument_list|(
specifier|const
name|TargetRegisterInfo
operator|*
name|TRI
argument_list|,
name|unsigned
name|Reg
argument_list|,
name|const_iterator
name|Before
argument_list|,
name|unsigned
name|Neighborhood
operator|=
literal|10
argument_list|)
decl|const
decl_stmt|;
comment|// Debugging methods.
name|void
name|dump
argument_list|()
specifier|const
expr_stmt|;
name|void
name|print
argument_list|(
name|raw_ostream
operator|&
name|OS
argument_list|,
specifier|const
name|SlotIndexes
operator|*
operator|=
name|nullptr
argument_list|)
decl|const
decl_stmt|;
name|void
name|print
argument_list|(
name|raw_ostream
operator|&
name|OS
argument_list|,
name|ModuleSlotTracker
operator|&
name|MST
argument_list|,
specifier|const
name|SlotIndexes
operator|*
operator|=
name|nullptr
argument_list|)
decl|const
decl_stmt|;
comment|// Printing method used by LoopInfo.
name|void
name|printAsOperand
argument_list|(
name|raw_ostream
operator|&
name|OS
argument_list|,
name|bool
name|PrintType
operator|=
name|true
argument_list|)
decl|const
decl_stmt|;
comment|/// MachineBasicBlocks are uniquely numbered at the function level, unless
comment|/// they're not in a MachineFunction yet, in which case this will return -1.
name|int
name|getNumber
argument_list|()
specifier|const
block|{
return|return
name|Number
return|;
block|}
name|void
name|setNumber
parameter_list|(
name|int
name|N
parameter_list|)
block|{
name|Number
operator|=
name|N
expr_stmt|;
block|}
comment|/// Return the MCSymbol for this basic block.
name|MCSymbol
operator|*
name|getSymbol
argument_list|()
specifier|const
expr_stmt|;
name|private
label|:
comment|/// Return probability iterator corresponding to the I successor iterator.
name|probability_iterator
name|getProbabilityIterator
parameter_list|(
name|succ_iterator
name|I
parameter_list|)
function_decl|;
name|const_probability_iterator
name|getProbabilityIterator
argument_list|(
name|const_succ_iterator
name|I
argument_list|)
decl|const
decl_stmt|;
name|friend
name|class
name|MachineBranchProbabilityInfo
decl_stmt|;
name|friend
name|class
name|MIPrinter
decl_stmt|;
comment|/// Return probability of the edge from this block to MBB. This method should
comment|/// NOT be called directly, but by using getEdgeProbability method from
comment|/// MachineBranchProbabilityInfo class.
name|BranchProbability
name|getSuccProbability
argument_list|(
name|const_succ_iterator
name|Succ
argument_list|)
decl|const
decl_stmt|;
comment|// Methods used to maintain doubly linked list of blocks...
name|friend
block|struct
name|ilist_callback_traits
operator|<
name|MachineBasicBlock
operator|>
expr_stmt|;
comment|// Machine-CFG mutators
comment|/// Remove Pred as a predecessor of this MachineBasicBlock. Don't do this
comment|/// unless you know what you're doing, because it doesn't update Pred's
comment|/// successors list. Use Pred->addSuccessor instead.
name|void
name|addPredecessor
parameter_list|(
name|MachineBasicBlock
modifier|*
name|Pred
parameter_list|)
function_decl|;
comment|/// Remove Pred as a predecessor of this MachineBasicBlock. Don't do this
comment|/// unless you know what you're doing, because it doesn't update Pred's
comment|/// successors list. Use Pred->removeSuccessor instead.
name|void
name|removePredecessor
parameter_list|(
name|MachineBasicBlock
modifier|*
name|Pred
parameter_list|)
function_decl|;
block|}
empty_stmt|;
name|raw_ostream
operator|&
name|operator
operator|<<
operator|(
name|raw_ostream
operator|&
name|OS
operator|,
specifier|const
name|MachineBasicBlock
operator|&
name|MBB
operator|)
expr_stmt|;
comment|// This is useful when building IndexedMaps keyed on basic block pointers.
name|struct
name|MBB2NumberFunctor
range|:
name|public
name|std
operator|::
name|unary_function
operator|<
specifier|const
name|MachineBasicBlock
operator|*
decl_stmt|,
name|unsigned
decl|>
block|{
name|unsigned
name|operator
argument_list|()
operator|(
specifier|const
name|MachineBasicBlock
operator|*
name|MBB
operator|)
specifier|const
block|{
return|return
name|MBB
operator|->
name|getNumber
argument_list|()
return|;
block|}
block|}
empty_stmt|;
comment|//===--------------------------------------------------------------------===//
comment|// GraphTraits specializations for machine basic block graphs (machine-CFGs)
comment|//===--------------------------------------------------------------------===//
comment|// Provide specializations of GraphTraits to be able to treat a
comment|// MachineFunction as a graph of MachineBasicBlocks.
comment|//
name|template
operator|<
operator|>
expr|struct
name|GraphTraits
operator|<
name|MachineBasicBlock
operator|*
operator|>
block|{
name|using
name|NodeRef
operator|=
name|MachineBasicBlock
operator|*
block|;
name|using
name|ChildIteratorType
operator|=
name|MachineBasicBlock
operator|::
name|succ_iterator
block|;
specifier|static
name|NodeRef
name|getEntryNode
argument_list|(
argument|MachineBasicBlock *BB
argument_list|)
block|{
return|return
name|BB
return|;
block|}
specifier|static
name|ChildIteratorType
name|child_begin
argument_list|(
argument|NodeRef N
argument_list|)
block|{
return|return
name|N
operator|->
name|succ_begin
argument_list|()
return|;
block|}
specifier|static
name|ChildIteratorType
name|child_end
argument_list|(
argument|NodeRef N
argument_list|)
block|{
return|return
name|N
operator|->
name|succ_end
argument_list|()
return|;
block|}
expr|}
block|;
name|template
operator|<
operator|>
expr|struct
name|GraphTraits
operator|<
specifier|const
name|MachineBasicBlock
operator|*
operator|>
block|{
name|using
name|NodeRef
operator|=
specifier|const
name|MachineBasicBlock
operator|*
block|;
name|using
name|ChildIteratorType
operator|=
name|MachineBasicBlock
operator|::
name|const_succ_iterator
block|;
specifier|static
name|NodeRef
name|getEntryNode
argument_list|(
argument|const MachineBasicBlock *BB
argument_list|)
block|{
return|return
name|BB
return|;
block|}
specifier|static
name|ChildIteratorType
name|child_begin
argument_list|(
argument|NodeRef N
argument_list|)
block|{
return|return
name|N
operator|->
name|succ_begin
argument_list|()
return|;
block|}
specifier|static
name|ChildIteratorType
name|child_end
argument_list|(
argument|NodeRef N
argument_list|)
block|{
return|return
name|N
operator|->
name|succ_end
argument_list|()
return|;
block|}
expr|}
block|;
comment|// Provide specializations of GraphTraits to be able to treat a
comment|// MachineFunction as a graph of MachineBasicBlocks and to walk it
comment|// in inverse order.  Inverse order for a function is considered
comment|// to be when traversing the predecessor edges of a MBB
comment|// instead of the successor edges.
comment|//
name|template
operator|<
operator|>
expr|struct
name|GraphTraits
operator|<
name|Inverse
operator|<
name|MachineBasicBlock
operator|*
operator|>>
block|{
name|using
name|NodeRef
operator|=
name|MachineBasicBlock
operator|*
block|;
name|using
name|ChildIteratorType
operator|=
name|MachineBasicBlock
operator|::
name|pred_iterator
block|;
specifier|static
name|NodeRef
name|getEntryNode
argument_list|(
argument|Inverse<MachineBasicBlock *> G
argument_list|)
block|{
return|return
name|G
operator|.
name|Graph
return|;
block|}
specifier|static
name|ChildIteratorType
name|child_begin
argument_list|(
argument|NodeRef N
argument_list|)
block|{
return|return
name|N
operator|->
name|pred_begin
argument_list|()
return|;
block|}
specifier|static
name|ChildIteratorType
name|child_end
argument_list|(
argument|NodeRef N
argument_list|)
block|{
return|return
name|N
operator|->
name|pred_end
argument_list|()
return|;
block|}
expr|}
block|;
name|template
operator|<
operator|>
expr|struct
name|GraphTraits
operator|<
name|Inverse
operator|<
specifier|const
name|MachineBasicBlock
operator|*
operator|>>
block|{
name|using
name|NodeRef
operator|=
specifier|const
name|MachineBasicBlock
operator|*
block|;
name|using
name|ChildIteratorType
operator|=
name|MachineBasicBlock
operator|::
name|const_pred_iterator
block|;
specifier|static
name|NodeRef
name|getEntryNode
argument_list|(
argument|Inverse<const MachineBasicBlock *> G
argument_list|)
block|{
return|return
name|G
operator|.
name|Graph
return|;
block|}
specifier|static
name|ChildIteratorType
name|child_begin
argument_list|(
argument|NodeRef N
argument_list|)
block|{
return|return
name|N
operator|->
name|pred_begin
argument_list|()
return|;
block|}
specifier|static
name|ChildIteratorType
name|child_end
argument_list|(
argument|NodeRef N
argument_list|)
block|{
return|return
name|N
operator|->
name|pred_end
argument_list|()
return|;
block|}
expr|}
block|;
comment|/// MachineInstrSpan provides an interface to get an iteration range
comment|/// containing the instruction it was initialized with, along with all
comment|/// those instructions inserted prior to or following that instruction
comment|/// at some point after the MachineInstrSpan is constructed.
name|class
name|MachineInstrSpan
block|{
name|MachineBasicBlock
operator|&
name|MBB
block|;
name|MachineBasicBlock
operator|::
name|iterator
name|I
block|,
name|B
block|,
name|E
block|;
name|public
operator|:
name|MachineInstrSpan
argument_list|(
argument|MachineBasicBlock::iterator I
argument_list|)
operator|:
name|MBB
argument_list|(
operator|*
name|I
operator|->
name|getParent
argument_list|()
argument_list|)
block|,
name|I
argument_list|(
name|I
argument_list|)
block|,
name|B
argument_list|(
name|I
operator|==
name|MBB
operator|.
name|begin
argument_list|()
condition|?
name|MBB
operator|.
name|end
argument_list|()
else|:
name|std
operator|::
name|prev
argument_list|(
name|I
argument_list|)
argument_list|)
block|,
name|E
argument_list|(
argument|std::next(I)
argument_list|)
block|{}
name|MachineBasicBlock
operator|::
name|iterator
name|begin
argument_list|()
block|{
return|return
name|B
operator|==
name|MBB
operator|.
name|end
argument_list|()
condition|?
name|MBB
operator|.
name|begin
argument_list|()
else|:
name|std
operator|::
name|next
argument_list|(
name|B
argument_list|)
return|;
block|}
name|MachineBasicBlock
operator|::
name|iterator
name|end
argument_list|()
block|{
return|return
name|E
return|;
block|}
name|bool
name|empty
argument_list|()
block|{
return|return
name|begin
argument_list|()
operator|==
name|end
argument_list|()
return|;
block|}
name|MachineBasicBlock
operator|::
name|iterator
name|getInitial
argument_list|()
block|{
return|return
name|I
return|;
block|}
expr|}
block|;
comment|/// Increment \p It until it points to a non-debug instruction or to \p End
comment|/// and return the resulting iterator. This function should only be used
comment|/// MachineBasicBlock::{iterator, const_iterator, instr_iterator,
comment|/// const_instr_iterator} and the respective reverse iterators.
name|template
operator|<
name|typename
name|IterT
operator|>
specifier|inline
name|IterT
name|skipDebugInstructionsForward
argument_list|(
argument|IterT It
argument_list|,
argument|IterT End
argument_list|)
block|{
while|while
condition|(
name|It
operator|!=
name|End
operator|&&
name|It
operator|->
name|isDebugValue
argument_list|()
condition|)
name|It
operator|++
expr_stmt|;
return|return
name|It
return|;
block|}
comment|/// Decrement \p It until it points to a non-debug instruction or to \p Begin
comment|/// and return the resulting iterator. This function should only be used
comment|/// MachineBasicBlock::{iterator, const_iterator, instr_iterator,
comment|/// const_instr_iterator} and the respective reverse iterators.
name|template
operator|<
name|class
name|IterT
operator|>
specifier|inline
name|IterT
name|skipDebugInstructionsBackward
argument_list|(
argument|IterT It
argument_list|,
argument|IterT Begin
argument_list|)
block|{
while|while
condition|(
name|It
operator|!=
name|Begin
operator|&&
name|It
operator|->
name|isDebugValue
argument_list|()
condition|)
name|It
operator|--
expr_stmt|;
return|return
name|It
return|;
block|}
expr|}
end_decl_stmt

begin_comment
comment|// end namespace llvm
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|// LLVM_CODEGEN_MACHINEBASICBLOCK_H
end_comment

end_unit

