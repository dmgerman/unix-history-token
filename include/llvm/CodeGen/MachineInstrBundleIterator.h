begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===- llvm/CodeGen/MachineInstrBundleIterator.h ----------------*- C++ -*-===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// Defines an iterator class that bundles MachineInstr.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LLVM_CODEGEN_MACHINEINSTRBUNDLEITERATOR_H
end_ifndef

begin_define
define|#
directive|define
name|LLVM_CODEGEN_MACHINEINSTRBUNDLEITERATOR_H
end_define

begin_include
include|#
directive|include
file|"llvm/ADT/ilist.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/simple_ilist.h"
end_include

begin_include
include|#
directive|include
file|<cassert>
end_include

begin_include
include|#
directive|include
file|<iterator>
end_include

begin_include
include|#
directive|include
file|<type_traits>
end_include

begin_decl_stmt
name|namespace
name|llvm
block|{
name|template
operator|<
name|class
name|T
operator|,
name|bool
name|IsReverse
operator|>
expr|struct
name|MachineInstrBundleIteratorTraits
expr_stmt|;
name|template
operator|<
name|class
name|T
operator|>
expr|struct
name|MachineInstrBundleIteratorTraits
operator|<
name|T
operator|,
name|false
operator|>
block|{
name|using
name|list_type
operator|=
name|simple_ilist
operator|<
name|T
block|,
name|ilist_sentinel_tracking
operator|<
name|true
operator|>>
block|;
name|using
name|instr_iterator
operator|=
name|typename
name|list_type
operator|::
name|iterator
block|;
name|using
name|nonconst_instr_iterator
operator|=
name|typename
name|list_type
operator|::
name|iterator
block|;
name|using
name|const_instr_iterator
operator|=
name|typename
name|list_type
operator|::
name|const_iterator
block|; }
expr_stmt|;
name|template
operator|<
name|class
name|T
operator|>
expr|struct
name|MachineInstrBundleIteratorTraits
operator|<
name|T
operator|,
name|true
operator|>
block|{
name|using
name|list_type
operator|=
name|simple_ilist
operator|<
name|T
block|,
name|ilist_sentinel_tracking
operator|<
name|true
operator|>>
block|;
name|using
name|instr_iterator
operator|=
name|typename
name|list_type
operator|::
name|reverse_iterator
block|;
name|using
name|nonconst_instr_iterator
operator|=
name|typename
name|list_type
operator|::
name|reverse_iterator
block|;
name|using
name|const_instr_iterator
operator|=
name|typename
name|list_type
operator|::
name|const_reverse_iterator
block|; }
expr_stmt|;
name|template
operator|<
name|class
name|T
operator|>
expr|struct
name|MachineInstrBundleIteratorTraits
operator|<
specifier|const
name|T
operator|,
name|false
operator|>
block|{
name|using
name|list_type
operator|=
name|simple_ilist
operator|<
name|T
block|,
name|ilist_sentinel_tracking
operator|<
name|true
operator|>>
block|;
name|using
name|instr_iterator
operator|=
name|typename
name|list_type
operator|::
name|const_iterator
block|;
name|using
name|nonconst_instr_iterator
operator|=
name|typename
name|list_type
operator|::
name|iterator
block|;
name|using
name|const_instr_iterator
operator|=
name|typename
name|list_type
operator|::
name|const_iterator
block|; }
expr_stmt|;
name|template
operator|<
name|class
name|T
operator|>
expr|struct
name|MachineInstrBundleIteratorTraits
operator|<
specifier|const
name|T
operator|,
name|true
operator|>
block|{
name|using
name|list_type
operator|=
name|simple_ilist
operator|<
name|T
block|,
name|ilist_sentinel_tracking
operator|<
name|true
operator|>>
block|;
name|using
name|instr_iterator
operator|=
name|typename
name|list_type
operator|::
name|const_reverse_iterator
block|;
name|using
name|nonconst_instr_iterator
operator|=
name|typename
name|list_type
operator|::
name|reverse_iterator
block|;
name|using
name|const_instr_iterator
operator|=
name|typename
name|list_type
operator|::
name|const_reverse_iterator
block|; }
expr_stmt|;
name|template
operator|<
name|bool
name|IsReverse
operator|>
expr|struct
name|MachineInstrBundleIteratorHelper
expr_stmt|;
name|template
operator|<
operator|>
expr|struct
name|MachineInstrBundleIteratorHelper
operator|<
name|false
operator|>
block|{
comment|/// Get the beginning of the current bundle.
name|template
operator|<
name|class
name|Iterator
operator|>
specifier|static
name|Iterator
name|getBundleBegin
argument_list|(
argument|Iterator I
argument_list|)
block|{
if|if
condition|(
operator|!
name|I
operator|.
name|isEnd
argument_list|()
condition|)
while|while
condition|(
name|I
operator|->
name|isBundledWithPred
argument_list|()
condition|)
operator|--
name|I
expr_stmt|;
return|return
name|I
return|;
block|}
comment|/// Get the final node of the current bundle.
name|template
operator|<
name|class
name|Iterator
operator|>
specifier|static
name|Iterator
name|getBundleFinal
argument_list|(
argument|Iterator I
argument_list|)
block|{
if|if
condition|(
operator|!
name|I
operator|.
name|isEnd
argument_list|()
condition|)
while|while
condition|(
name|I
operator|->
name|isBundledWithSucc
argument_list|()
condition|)
operator|++
name|I
expr_stmt|;
return|return
name|I
return|;
block|}
end_decl_stmt

begin_comment
comment|/// Increment forward ilist iterator.
end_comment

begin_expr_stmt
name|template
operator|<
name|class
name|Iterator
operator|>
specifier|static
name|void
name|increment
argument_list|(
argument|Iterator&I
argument_list|)
block|{
name|I
operator|=
name|std
operator|::
name|next
argument_list|(
name|getBundleFinal
argument_list|(
name|I
argument_list|)
argument_list|)
block|;   }
comment|/// Decrement forward ilist iterator.
name|template
operator|<
name|class
name|Iterator
operator|>
specifier|static
name|void
name|decrement
argument_list|(
argument|Iterator&I
argument_list|)
block|{
name|I
operator|=
name|getBundleBegin
argument_list|(
name|std
operator|::
name|prev
argument_list|(
name|I
argument_list|)
argument_list|)
block|;   }
end_expr_stmt

begin_expr_stmt
unit|};
name|template
operator|<
operator|>
expr|struct
name|MachineInstrBundleIteratorHelper
operator|<
name|true
operator|>
block|{
comment|/// Get the beginning of the current bundle.
name|template
operator|<
name|class
name|Iterator
operator|>
specifier|static
name|Iterator
name|getBundleBegin
argument_list|(
argument|Iterator I
argument_list|)
block|{
return|return
name|MachineInstrBundleIteratorHelper
operator|<
name|false
operator|>
operator|::
name|getBundleBegin
argument_list|(
name|I
operator|.
name|getReverse
argument_list|()
argument_list|)
operator|.
name|getReverse
argument_list|()
return|;
block|}
comment|/// Get the final node of the current bundle.
name|template
operator|<
name|class
name|Iterator
operator|>
specifier|static
name|Iterator
name|getBundleFinal
argument_list|(
argument|Iterator I
argument_list|)
block|{
return|return
name|MachineInstrBundleIteratorHelper
operator|<
name|false
operator|>
operator|::
name|getBundleFinal
argument_list|(
name|I
operator|.
name|getReverse
argument_list|()
argument_list|)
operator|.
name|getReverse
argument_list|()
return|;
block|}
end_expr_stmt

begin_comment
comment|/// Increment reverse ilist iterator.
end_comment

begin_expr_stmt
name|template
operator|<
name|class
name|Iterator
operator|>
specifier|static
name|void
name|increment
argument_list|(
argument|Iterator&I
argument_list|)
block|{
name|I
operator|=
name|getBundleBegin
argument_list|(
name|std
operator|::
name|next
argument_list|(
name|I
argument_list|)
argument_list|)
block|;   }
comment|/// Decrement reverse ilist iterator.
name|template
operator|<
name|class
name|Iterator
operator|>
specifier|static
name|void
name|decrement
argument_list|(
argument|Iterator&I
argument_list|)
block|{
name|I
operator|=
name|std
operator|::
name|prev
argument_list|(
name|getBundleFinal
argument_list|(
name|I
argument_list|)
argument_list|)
block|;   }
end_expr_stmt

begin_comment
unit|};
comment|/// MachineBasicBlock iterator that automatically skips over MIs that are
end_comment

begin_comment
comment|/// inside bundles (i.e. walk top level MIs only).
end_comment

begin_expr_stmt
name|template
operator|<
name|typename
name|Ty
operator|,
name|bool
name|IsReverse
operator|=
name|false
operator|>
name|class
name|MachineInstrBundleIterator
operator|:
name|MachineInstrBundleIteratorHelper
operator|<
name|IsReverse
operator|>
block|{
name|using
name|Traits
operator|=
name|MachineInstrBundleIteratorTraits
operator|<
name|Ty
block|,
name|IsReverse
operator|>
block|;
name|using
name|instr_iterator
operator|=
name|typename
name|Traits
operator|::
name|instr_iterator
block|;
name|instr_iterator
name|MII
block|;
name|public
operator|:
name|using
name|value_type
operator|=
name|typename
name|instr_iterator
operator|::
name|value_type
block|;
name|using
name|difference_type
operator|=
name|typename
name|instr_iterator
operator|::
name|difference_type
block|;
name|using
name|pointer
operator|=
name|typename
name|instr_iterator
operator|::
name|pointer
block|;
name|using
name|reference
operator|=
name|typename
name|instr_iterator
operator|::
name|reference
block|;
name|using
name|const_pointer
operator|=
name|typename
name|instr_iterator
operator|::
name|const_pointer
block|;
name|using
name|const_reference
operator|=
name|typename
name|instr_iterator
operator|::
name|const_reference
block|;
name|using
name|iterator_category
operator|=
name|std
operator|::
name|bidirectional_iterator_tag
block|;
name|private
operator|:
name|using
name|nonconst_instr_iterator
operator|=
name|typename
name|Traits
operator|::
name|nonconst_instr_iterator
block|;
name|using
name|const_instr_iterator
operator|=
name|typename
name|Traits
operator|::
name|const_instr_iterator
block|;
name|using
name|nonconst_iterator
operator|=
name|MachineInstrBundleIterator
operator|<
name|typename
name|nonconst_instr_iterator
operator|::
name|value_type
block|,
name|IsReverse
operator|>
block|;
name|using
name|reverse_iterator
operator|=
name|MachineInstrBundleIterator
operator|<
name|Ty
block|,
operator|!
name|IsReverse
operator|>
block|;
name|public
operator|:
name|MachineInstrBundleIterator
argument_list|(
argument|instr_iterator MI
argument_list|)
operator|:
name|MII
argument_list|(
argument|MI
argument_list|)
block|{
name|assert
argument_list|(
operator|(
operator|!
name|MI
operator|.
name|getNodePtr
argument_list|()
operator|||
name|MI
operator|.
name|isEnd
argument_list|()
operator|||
operator|!
name|MI
operator|->
name|isBundledWithPred
argument_list|()
operator|)
operator|&&
literal|"It's not legal to initialize MachineInstrBundleIterator with a "
literal|"bundled MI"
argument_list|)
block|;   }
name|MachineInstrBundleIterator
argument_list|(
argument|reference MI
argument_list|)
operator|:
name|MII
argument_list|(
argument|MI
argument_list|)
block|{
name|assert
argument_list|(
operator|!
name|MI
operator|.
name|isBundledWithPred
argument_list|()
operator|&&
literal|"It's not legal to initialize "
literal|"MachineInstrBundleIterator with a "
literal|"bundled MI"
argument_list|)
block|;   }
name|MachineInstrBundleIterator
argument_list|(
argument|pointer MI
argument_list|)
operator|:
name|MII
argument_list|(
argument|MI
argument_list|)
block|{
comment|// FIXME: This conversion should be explicit.
name|assert
argument_list|(
operator|(
operator|!
name|MI
operator|||
operator|!
name|MI
operator|->
name|isBundledWithPred
argument_list|()
operator|)
operator|&&
literal|"It's not legal to initialize "
literal|"MachineInstrBundleIterator "
literal|"with a bundled MI"
argument_list|)
block|;   }
comment|// Template allows conversion from const to nonconst.
name|template
operator|<
name|class
name|OtherTy
operator|>
name|MachineInstrBundleIterator
argument_list|(
argument|const MachineInstrBundleIterator<OtherTy
argument_list|,
argument|IsReverse>&I
argument_list|,
argument|typename std::enable_if<std::is_convertible<OtherTy *
argument_list|,
argument|Ty *>::value
argument_list|,
argument|void *>::type = nullptr
argument_list|)
operator|:
name|MII
argument_list|(
argument|I.getInstrIterator()
argument_list|)
block|{}
name|MachineInstrBundleIterator
argument_list|()
operator|:
name|MII
argument_list|(
argument|nullptr
argument_list|)
block|{}
comment|/// Explicit conversion between forward/reverse iterators.
comment|///
comment|/// Translate between forward and reverse iterators without changing range
comment|/// boundaries.  The resulting iterator will dereference (and have a handle)
comment|/// to the previous node, which is somewhat unexpected; but converting the
comment|/// two endpoints in a range will give the same range in reverse.
comment|///
comment|/// This matches std::reverse_iterator conversions.
name|explicit
name|MachineInstrBundleIterator
argument_list|(
specifier|const
name|MachineInstrBundleIterator
operator|<
name|Ty
argument_list|,
operator|!
name|IsReverse
operator|>
operator|&
name|I
argument_list|)
operator|:
name|MachineInstrBundleIterator
argument_list|(
argument|++I.getReverse()
argument_list|)
block|{}
comment|/// Get the bundle iterator for the given instruction's bundle.
specifier|static
name|MachineInstrBundleIterator
name|getAtBundleBegin
argument_list|(
argument|instr_iterator MI
argument_list|)
block|{
return|return
name|MachineInstrBundleIteratorHelper
operator|<
name|IsReverse
operator|>
operator|::
name|getBundleBegin
argument_list|(
name|MI
argument_list|)
return|;
block|}
name|reference
name|operator
operator|*
operator|(
operator|)
specifier|const
block|{
return|return
operator|*
name|MII
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|pointer
name|operator
operator|->
expr|(
end_expr_stmt

begin_expr_stmt
unit|)
specifier|const
block|{
return|return
operator|&
name|operator
operator|*
operator|(
operator|)
return|;
block|}
end_expr_stmt

begin_comment
comment|/// Check for null.
end_comment

begin_expr_stmt
name|bool
name|isValid
argument_list|()
specifier|const
block|{
return|return
name|MII
operator|.
name|getNodePtr
argument_list|()
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|friend
name|bool
name|operator
operator|==
operator|(
specifier|const
name|MachineInstrBundleIterator
operator|&
name|L
operator|,
specifier|const
name|MachineInstrBundleIterator
operator|&
name|R
operator|)
block|{
return|return
name|L
operator|.
name|MII
operator|==
name|R
operator|.
name|MII
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|friend
name|bool
name|operator
operator|==
operator|(
specifier|const
name|MachineInstrBundleIterator
operator|&
name|L
operator|,
specifier|const
name|const_instr_iterator
operator|&
name|R
operator|)
block|{
return|return
name|L
operator|.
name|MII
operator|==
name|R
return|;
comment|// Avoid assertion about validity of R.
block|}
end_expr_stmt

begin_expr_stmt
name|friend
name|bool
name|operator
operator|==
operator|(
specifier|const
name|const_instr_iterator
operator|&
name|L
operator|,
specifier|const
name|MachineInstrBundleIterator
operator|&
name|R
operator|)
block|{
return|return
name|L
operator|==
name|R
operator|.
name|MII
return|;
comment|// Avoid assertion about validity of L.
block|}
end_expr_stmt

begin_expr_stmt
name|friend
name|bool
name|operator
operator|==
operator|(
specifier|const
name|MachineInstrBundleIterator
operator|&
name|L
operator|,
specifier|const
name|nonconst_instr_iterator
operator|&
name|R
operator|)
block|{
return|return
name|L
operator|.
name|MII
operator|==
name|R
return|;
comment|// Avoid assertion about validity of R.
block|}
end_expr_stmt

begin_expr_stmt
name|friend
name|bool
name|operator
operator|==
operator|(
specifier|const
name|nonconst_instr_iterator
operator|&
name|L
operator|,
specifier|const
name|MachineInstrBundleIterator
operator|&
name|R
operator|)
block|{
return|return
name|L
operator|==
name|R
operator|.
name|MII
return|;
comment|// Avoid assertion about validity of L.
block|}
end_expr_stmt

begin_expr_stmt
name|friend
name|bool
name|operator
operator|==
operator|(
specifier|const
name|MachineInstrBundleIterator
operator|&
name|L
operator|,
name|const_pointer
name|R
operator|)
block|{
return|return
name|L
operator|==
name|const_instr_iterator
argument_list|(
name|R
argument_list|)
return|;
comment|// Avoid assertion about validity of R.
block|}
end_expr_stmt

begin_expr_stmt
name|friend
name|bool
name|operator
operator|==
operator|(
name|const_pointer
name|L
operator|,
specifier|const
name|MachineInstrBundleIterator
operator|&
name|R
operator|)
block|{
return|return
name|const_instr_iterator
argument_list|(
name|L
argument_list|)
operator|==
name|R
return|;
comment|// Avoid assertion about validity of L.
block|}
end_expr_stmt

begin_expr_stmt
name|friend
name|bool
name|operator
operator|==
operator|(
specifier|const
name|MachineInstrBundleIterator
operator|&
name|L
operator|,
name|const_reference
name|R
operator|)
block|{
return|return
name|L
operator|==
operator|&
name|R
return|;
comment|// Avoid assertion about validity of R.
block|}
end_expr_stmt

begin_expr_stmt
name|friend
name|bool
name|operator
operator|==
operator|(
name|const_reference
name|L
operator|,
specifier|const
name|MachineInstrBundleIterator
operator|&
name|R
operator|)
block|{
return|return
operator|&
name|L
operator|==
name|R
return|;
comment|// Avoid assertion about validity of L.
block|}
end_expr_stmt

begin_expr_stmt
name|friend
name|bool
name|operator
operator|!=
operator|(
specifier|const
name|MachineInstrBundleIterator
operator|&
name|L
operator|,
specifier|const
name|MachineInstrBundleIterator
operator|&
name|R
operator|)
block|{
return|return
operator|!
operator|(
name|L
operator|==
name|R
operator|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|friend
name|bool
name|operator
operator|!=
operator|(
specifier|const
name|MachineInstrBundleIterator
operator|&
name|L
operator|,
specifier|const
name|const_instr_iterator
operator|&
name|R
operator|)
block|{
return|return
operator|!
operator|(
name|L
operator|==
name|R
operator|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|friend
name|bool
name|operator
operator|!=
operator|(
specifier|const
name|const_instr_iterator
operator|&
name|L
operator|,
specifier|const
name|MachineInstrBundleIterator
operator|&
name|R
operator|)
block|{
return|return
operator|!
operator|(
name|L
operator|==
name|R
operator|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|friend
name|bool
name|operator
operator|!=
operator|(
specifier|const
name|MachineInstrBundleIterator
operator|&
name|L
operator|,
specifier|const
name|nonconst_instr_iterator
operator|&
name|R
operator|)
block|{
return|return
operator|!
operator|(
name|L
operator|==
name|R
operator|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|friend
name|bool
name|operator
operator|!=
operator|(
specifier|const
name|nonconst_instr_iterator
operator|&
name|L
operator|,
specifier|const
name|MachineInstrBundleIterator
operator|&
name|R
operator|)
block|{
return|return
operator|!
operator|(
name|L
operator|==
name|R
operator|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|friend
name|bool
name|operator
operator|!=
operator|(
specifier|const
name|MachineInstrBundleIterator
operator|&
name|L
operator|,
name|const_pointer
name|R
operator|)
block|{
return|return
operator|!
operator|(
name|L
operator|==
name|R
operator|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|friend
name|bool
name|operator
operator|!=
operator|(
name|const_pointer
name|L
operator|,
specifier|const
name|MachineInstrBundleIterator
operator|&
name|R
operator|)
block|{
return|return
operator|!
operator|(
name|L
operator|==
name|R
operator|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|friend
name|bool
name|operator
operator|!=
operator|(
specifier|const
name|MachineInstrBundleIterator
operator|&
name|L
operator|,
name|const_reference
name|R
operator|)
block|{
return|return
operator|!
operator|(
name|L
operator|==
name|R
operator|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|friend
name|bool
name|operator
operator|!=
operator|(
name|const_reference
name|L
operator|,
specifier|const
name|MachineInstrBundleIterator
operator|&
name|R
operator|)
block|{
return|return
operator|!
operator|(
name|L
operator|==
name|R
operator|)
return|;
block|}
end_expr_stmt

begin_comment
comment|// Increment and decrement operators...
end_comment

begin_expr_stmt
name|MachineInstrBundleIterator
operator|&
name|operator
operator|--
operator|(
operator|)
block|{
name|this
operator|->
name|decrement
argument_list|(
name|MII
argument_list|)
block|;
return|return
operator|*
name|this
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|MachineInstrBundleIterator
operator|&
name|operator
operator|++
operator|(
operator|)
block|{
name|this
operator|->
name|increment
argument_list|(
name|MII
argument_list|)
block|;
return|return
operator|*
name|this
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|MachineInstrBundleIterator
name|operator
operator|--
operator|(
name|int
operator|)
block|{
name|MachineInstrBundleIterator
name|Temp
operator|=
operator|*
name|this
block|;
operator|--
operator|*
name|this
block|;
return|return
name|Temp
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|MachineInstrBundleIterator
name|operator
operator|++
operator|(
name|int
operator|)
block|{
name|MachineInstrBundleIterator
name|Temp
operator|=
operator|*
name|this
block|;
operator|++
operator|*
name|this
block|;
return|return
name|Temp
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|instr_iterator
name|getInstrIterator
argument_list|()
specifier|const
block|{
return|return
name|MII
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|nonconst_iterator
name|getNonConstIterator
argument_list|()
specifier|const
block|{
return|return
name|MII
operator|.
name|getNonConst
argument_list|()
return|;
block|}
end_expr_stmt

begin_comment
comment|/// Get a reverse iterator to the same node.
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|/// Gives a reverse iterator that will dereference (and have a handle) to the
end_comment

begin_comment
comment|/// same node.  Converting the endpoint iterators in a range will give a
end_comment

begin_comment
comment|/// different range; for range operations, use the explicit conversions.
end_comment

begin_expr_stmt
name|reverse_iterator
name|getReverse
argument_list|()
specifier|const
block|{
return|return
name|MII
operator|.
name|getReverse
argument_list|()
return|;
block|}
end_expr_stmt

begin_comment
unit|};  }
comment|// end namespace llvm
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|// LLVM_CODEGEN_MACHINEINSTRBUNDLEITERATOR_H
end_comment

end_unit

