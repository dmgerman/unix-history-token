begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===------ Math.h - PBQP Vector and Matrix classes -------------*- C++ -*-===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LLVM_CODEGEN_PBQP_MATH_H
end_ifndef

begin_define
define|#
directive|define
name|LLVM_CODEGEN_PBQP_MATH_H
end_define

begin_include
include|#
directive|include
file|"llvm/ADT/Hashing.h"
end_include

begin_include
include|#
directive|include
file|<algorithm>
end_include

begin_include
include|#
directive|include
file|<cassert>
end_include

begin_include
include|#
directive|include
file|<functional>
end_include

begin_decl_stmt
name|namespace
name|llvm
block|{
name|namespace
name|PBQP
block|{
typedef|typedef
name|float
name|PBQPNum
typedef|;
comment|/// \brief PBQP Vector class.
name|class
name|Vector
block|{
name|friend
name|hash_code
name|hash_value
parameter_list|(
specifier|const
name|Vector
modifier|&
parameter_list|)
function_decl|;
name|public
label|:
comment|/// \brief Construct a PBQP vector of the given size.
name|explicit
name|Vector
argument_list|(
argument|unsigned Length
argument_list|)
block|:
name|Length
argument_list|(
name|Length
argument_list|)
operator|,
name|Data
argument_list|(
argument|llvm::make_unique<PBQPNum []>(Length)
argument_list|)
block|{}
comment|/// \brief Construct a PBQP vector with initializer.
name|Vector
argument_list|(
argument|unsigned Length
argument_list|,
argument|PBQPNum InitVal
argument_list|)
operator|:
name|Length
argument_list|(
name|Length
argument_list|)
operator|,
name|Data
argument_list|(
argument|llvm::make_unique<PBQPNum []>(Length)
argument_list|)
block|{
name|std
operator|::
name|fill
argument_list|(
name|Data
operator|.
name|get
argument_list|()
argument_list|,
name|Data
operator|.
name|get
argument_list|()
operator|+
name|Length
argument_list|,
name|InitVal
argument_list|)
block|;   }
comment|/// \brief Copy construct a PBQP vector.
name|Vector
argument_list|(
specifier|const
name|Vector
operator|&
name|V
argument_list|)
operator|:
name|Length
argument_list|(
name|V
operator|.
name|Length
argument_list|)
operator|,
name|Data
argument_list|(
argument|llvm::make_unique<PBQPNum []>(Length)
argument_list|)
block|{
name|std
operator|::
name|copy
argument_list|(
name|V
operator|.
name|Data
operator|.
name|get
argument_list|()
argument_list|,
name|V
operator|.
name|Data
operator|.
name|get
argument_list|()
operator|+
name|Length
argument_list|,
name|Data
operator|.
name|get
argument_list|()
argument_list|)
block|;   }
comment|/// \brief Move construct a PBQP vector.
name|Vector
argument_list|(
name|Vector
operator|&&
name|V
argument_list|)
operator|:
name|Length
argument_list|(
name|V
operator|.
name|Length
argument_list|)
operator|,
name|Data
argument_list|(
argument|std::move(V.Data)
argument_list|)
block|{
name|V
operator|.
name|Length
operator|=
literal|0
block|;   }
comment|/// \brief Comparison operator.
name|bool
name|operator
operator|==
operator|(
specifier|const
name|Vector
operator|&
name|V
operator|)
specifier|const
block|{
name|assert
argument_list|(
name|Length
operator|!=
literal|0
operator|&&
name|Data
operator|&&
literal|"Invalid vector"
argument_list|)
block|;
if|if
condition|(
name|Length
operator|!=
name|V
operator|.
name|Length
condition|)
return|return
name|false
return|;
return|return
name|std
operator|::
name|equal
argument_list|(
name|Data
operator|.
name|get
argument_list|()
argument_list|,
name|Data
operator|.
name|get
argument_list|()
operator|+
name|Length
argument_list|,
name|V
operator|.
name|Data
operator|.
name|get
argument_list|()
argument_list|)
return|;
block|}
comment|/// \brief Return the length of the vector
name|unsigned
name|getLength
argument_list|()
specifier|const
block|{
name|assert
argument_list|(
name|Length
operator|!=
literal|0
operator|&&
name|Data
operator|&&
literal|"Invalid vector"
argument_list|)
block|;
return|return
name|Length
return|;
block|}
comment|/// \brief Element access.
name|PBQPNum
modifier|&
name|operator
function|[]
parameter_list|(
name|unsigned
name|Index
parameter_list|)
block|{
name|assert
argument_list|(
name|Length
operator|!=
literal|0
operator|&&
name|Data
operator|&&
literal|"Invalid vector"
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|Index
operator|<
name|Length
operator|&&
literal|"Vector element access out of bounds."
argument_list|)
expr_stmt|;
return|return
name|Data
index|[
name|Index
index|]
return|;
block|}
comment|/// \brief Const element access.
specifier|const
name|PBQPNum
modifier|&
name|operator
index|[]
argument_list|(
name|unsigned
name|Index
argument_list|)
decl|const
block|{
name|assert
argument_list|(
name|Length
operator|!=
literal|0
operator|&&
name|Data
operator|&&
literal|"Invalid vector"
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|Index
operator|<
name|Length
operator|&&
literal|"Vector element access out of bounds."
argument_list|)
expr_stmt|;
return|return
name|Data
index|[
name|Index
index|]
return|;
block|}
comment|/// \brief Add another vector to this one.
name|Vector
operator|&
name|operator
operator|+=
operator|(
specifier|const
name|Vector
operator|&
name|V
operator|)
block|{
name|assert
argument_list|(
name|Length
operator|!=
literal|0
operator|&&
name|Data
operator|&&
literal|"Invalid vector"
argument_list|)
block|;
name|assert
argument_list|(
name|Length
operator|==
name|V
operator|.
name|Length
operator|&&
literal|"Vector length mismatch."
argument_list|)
block|;
name|std
operator|::
name|transform
argument_list|(
name|Data
operator|.
name|get
argument_list|()
argument_list|,
name|Data
operator|.
name|get
argument_list|()
operator|+
name|Length
argument_list|,
name|V
operator|.
name|Data
operator|.
name|get
argument_list|()
argument_list|,
name|Data
operator|.
name|get
argument_list|()
argument_list|,
name|std
operator|::
name|plus
operator|<
name|PBQPNum
operator|>
operator|(
operator|)
argument_list|)
block|;
return|return
operator|*
name|this
return|;
block|}
comment|/// \brief Returns the index of the minimum value in this vector
name|unsigned
name|minIndex
argument_list|()
specifier|const
block|{
name|assert
argument_list|(
name|Length
operator|!=
literal|0
operator|&&
name|Data
operator|&&
literal|"Invalid vector"
argument_list|)
block|;
return|return
name|std
operator|::
name|min_element
argument_list|(
name|Data
operator|.
name|get
argument_list|()
argument_list|,
name|Data
operator|.
name|get
argument_list|()
operator|+
name|Length
argument_list|)
operator|-
name|Data
operator|.
name|get
argument_list|()
return|;
block|}
name|private
label|:
name|unsigned
name|Length
decl_stmt|;
name|std
operator|::
name|unique_ptr
operator|<
name|PBQPNum
index|[]
operator|>
name|Data
expr_stmt|;
block|}
empty_stmt|;
comment|/// \brief Return a hash_value for the given vector.
specifier|inline
name|hash_code
name|hash_value
parameter_list|(
specifier|const
name|Vector
modifier|&
name|V
parameter_list|)
block|{
name|unsigned
modifier|*
name|VBegin
init|=
name|reinterpret_cast
operator|<
name|unsigned
operator|*
operator|>
operator|(
name|V
operator|.
name|Data
operator|.
name|get
argument_list|()
operator|)
decl_stmt|;
name|unsigned
modifier|*
name|VEnd
init|=
name|reinterpret_cast
operator|<
name|unsigned
operator|*
operator|>
operator|(
name|V
operator|.
name|Data
operator|.
name|get
argument_list|()
operator|+
name|V
operator|.
name|Length
operator|)
decl_stmt|;
return|return
name|hash_combine
argument_list|(
name|V
operator|.
name|Length
argument_list|,
name|hash_combine_range
argument_list|(
name|VBegin
argument_list|,
name|VEnd
argument_list|)
argument_list|)
return|;
block|}
comment|/// \brief Output a textual representation of the given vector on the given
comment|///        output stream.
name|template
operator|<
name|typename
name|OStream
operator|>
name|OStream
operator|&
name|operator
operator|<<
operator|(
name|OStream
operator|&
name|OS
operator|,
specifier|const
name|Vector
operator|&
name|V
operator|)
block|{
name|assert
argument_list|(
operator|(
name|V
operator|.
name|getLength
argument_list|()
operator|!=
literal|0
operator|)
operator|&&
literal|"Zero-length vector badness."
argument_list|)
block|;
name|OS
operator|<<
literal|"[ "
operator|<<
name|V
index|[
literal|0
index|]
block|;
for|for
control|(
name|unsigned
name|i
init|=
literal|1
init|;
name|i
operator|<
name|V
operator|.
name|getLength
argument_list|()
condition|;
operator|++
name|i
control|)
name|OS
operator|<<
literal|", "
operator|<<
name|V
index|[
name|i
index|]
expr_stmt|;
name|OS
operator|<<
literal|" ]"
expr_stmt|;
return|return
name|OS
return|;
block|}
end_decl_stmt

begin_comment
comment|/// \brief PBQP Matrix class
end_comment

begin_decl_stmt
name|class
name|Matrix
block|{
name|private
label|:
name|friend
name|hash_code
name|hash_value
parameter_list|(
specifier|const
name|Matrix
modifier|&
parameter_list|)
function_decl|;
name|public
label|:
comment|/// \brief Construct a PBQP Matrix with the given dimensions.
name|Matrix
argument_list|(
argument|unsigned Rows
argument_list|,
argument|unsigned Cols
argument_list|)
block|:
name|Rows
argument_list|(
name|Rows
argument_list|)
operator|,
name|Cols
argument_list|(
name|Cols
argument_list|)
operator|,
name|Data
argument_list|(
argument|llvm::make_unique<PBQPNum []>(Rows * Cols)
argument_list|)
block|{   }
comment|/// \brief Construct a PBQP Matrix with the given dimensions and initial
comment|/// value.
name|Matrix
argument_list|(
argument|unsigned Rows
argument_list|,
argument|unsigned Cols
argument_list|,
argument|PBQPNum InitVal
argument_list|)
operator|:
name|Rows
argument_list|(
name|Rows
argument_list|)
operator|,
name|Cols
argument_list|(
name|Cols
argument_list|)
operator|,
name|Data
argument_list|(
argument|llvm::make_unique<PBQPNum []>(Rows * Cols)
argument_list|)
block|{
name|std
operator|::
name|fill
argument_list|(
name|Data
operator|.
name|get
argument_list|()
argument_list|,
name|Data
operator|.
name|get
argument_list|()
operator|+
operator|(
name|Rows
operator|*
name|Cols
operator|)
argument_list|,
name|InitVal
argument_list|)
block|;   }
comment|/// \brief Copy construct a PBQP matrix.
name|Matrix
argument_list|(
specifier|const
name|Matrix
operator|&
name|M
argument_list|)
operator|:
name|Rows
argument_list|(
name|M
operator|.
name|Rows
argument_list|)
operator|,
name|Cols
argument_list|(
name|M
operator|.
name|Cols
argument_list|)
operator|,
name|Data
argument_list|(
argument|llvm::make_unique<PBQPNum []>(Rows * Cols)
argument_list|)
block|{
name|std
operator|::
name|copy
argument_list|(
name|M
operator|.
name|Data
operator|.
name|get
argument_list|()
argument_list|,
name|M
operator|.
name|Data
operator|.
name|get
argument_list|()
operator|+
operator|(
name|Rows
operator|*
name|Cols
operator|)
argument_list|,
name|Data
operator|.
name|get
argument_list|()
argument_list|)
block|;   }
comment|/// \brief Move construct a PBQP matrix.
name|Matrix
argument_list|(
name|Matrix
operator|&&
name|M
argument_list|)
operator|:
name|Rows
argument_list|(
name|M
operator|.
name|Rows
argument_list|)
operator|,
name|Cols
argument_list|(
name|M
operator|.
name|Cols
argument_list|)
operator|,
name|Data
argument_list|(
argument|std::move(M.Data)
argument_list|)
block|{
name|M
operator|.
name|Rows
operator|=
name|M
operator|.
name|Cols
operator|=
literal|0
block|;   }
comment|/// \brief Comparison operator.
name|bool
name|operator
operator|==
operator|(
specifier|const
name|Matrix
operator|&
name|M
operator|)
specifier|const
block|{
name|assert
argument_list|(
name|Rows
operator|!=
literal|0
operator|&&
name|Cols
operator|!=
literal|0
operator|&&
name|Data
operator|&&
literal|"Invalid matrix"
argument_list|)
block|;
if|if
condition|(
name|Rows
operator|!=
name|M
operator|.
name|Rows
operator|||
name|Cols
operator|!=
name|M
operator|.
name|Cols
condition|)
return|return
name|false
return|;
return|return
name|std
operator|::
name|equal
argument_list|(
name|Data
operator|.
name|get
argument_list|()
argument_list|,
name|Data
operator|.
name|get
argument_list|()
operator|+
operator|(
name|Rows
operator|*
name|Cols
operator|)
argument_list|,
name|M
operator|.
name|Data
operator|.
name|get
argument_list|()
argument_list|)
return|;
block|}
end_decl_stmt

begin_comment
comment|/// \brief Return the number of rows in this matrix.
end_comment

begin_expr_stmt
name|unsigned
name|getRows
argument_list|()
specifier|const
block|{
name|assert
argument_list|(
name|Rows
operator|!=
literal|0
operator|&&
name|Cols
operator|!=
literal|0
operator|&&
name|Data
operator|&&
literal|"Invalid matrix"
argument_list|)
block|;
return|return
name|Rows
return|;
block|}
end_expr_stmt

begin_comment
comment|/// \brief Return the number of cols in this matrix.
end_comment

begin_expr_stmt
name|unsigned
name|getCols
argument_list|()
specifier|const
block|{
name|assert
argument_list|(
name|Rows
operator|!=
literal|0
operator|&&
name|Cols
operator|!=
literal|0
operator|&&
name|Data
operator|&&
literal|"Invalid matrix"
argument_list|)
block|;
return|return
name|Cols
return|;
block|}
end_expr_stmt

begin_comment
comment|/// \brief Matrix element access.
end_comment

begin_function
name|PBQPNum
modifier|*
name|operator
function|[]
parameter_list|(
name|unsigned
name|R
parameter_list|)
block|{
name|assert
argument_list|(
name|Rows
operator|!=
literal|0
operator|&&
name|Cols
operator|!=
literal|0
operator|&&
name|Data
operator|&&
literal|"Invalid matrix"
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|R
operator|<
name|Rows
operator|&&
literal|"Row out of bounds."
argument_list|)
expr_stmt|;
return|return
name|Data
operator|.
name|get
argument_list|()
operator|+
operator|(
name|R
operator|*
name|Cols
operator|)
return|;
block|}
end_function

begin_comment
comment|/// \brief Matrix element access.
end_comment

begin_decl_stmt
specifier|const
name|PBQPNum
modifier|*
name|operator
index|[]
argument_list|(
name|unsigned
name|R
argument_list|)
decl|const
block|{
name|assert
argument_list|(
name|Rows
operator|!=
literal|0
operator|&&
name|Cols
operator|!=
literal|0
operator|&&
name|Data
operator|&&
literal|"Invalid matrix"
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|R
operator|<
name|Rows
operator|&&
literal|"Row out of bounds."
argument_list|)
expr_stmt|;
return|return
name|Data
operator|.
name|get
argument_list|()
operator|+
operator|(
name|R
operator|*
name|Cols
operator|)
return|;
block|}
end_decl_stmt

begin_comment
comment|/// \brief Returns the given row as a vector.
end_comment

begin_decl_stmt
name|Vector
name|getRowAsVector
argument_list|(
name|unsigned
name|R
argument_list|)
decl|const
block|{
name|assert
argument_list|(
name|Rows
operator|!=
literal|0
operator|&&
name|Cols
operator|!=
literal|0
operator|&&
name|Data
operator|&&
literal|"Invalid matrix"
argument_list|)
expr_stmt|;
name|Vector
name|V
parameter_list|(
name|Cols
parameter_list|)
function_decl|;
for|for
control|(
name|unsigned
name|C
init|=
literal|0
init|;
name|C
operator|<
name|Cols
condition|;
operator|++
name|C
control|)
name|V
index|[
name|C
index|]
operator|=
operator|(
operator|*
name|this
operator|)
index|[
name|R
index|]
index|[
name|C
index|]
expr_stmt|;
return|return
name|V
return|;
block|}
end_decl_stmt

begin_comment
comment|/// \brief Returns the given column as a vector.
end_comment

begin_decl_stmt
name|Vector
name|getColAsVector
argument_list|(
name|unsigned
name|C
argument_list|)
decl|const
block|{
name|assert
argument_list|(
name|Rows
operator|!=
literal|0
operator|&&
name|Cols
operator|!=
literal|0
operator|&&
name|Data
operator|&&
literal|"Invalid matrix"
argument_list|)
expr_stmt|;
name|Vector
name|V
parameter_list|(
name|Rows
parameter_list|)
function_decl|;
for|for
control|(
name|unsigned
name|R
init|=
literal|0
init|;
name|R
operator|<
name|Rows
condition|;
operator|++
name|R
control|)
name|V
index|[
name|R
index|]
operator|=
operator|(
operator|*
name|this
operator|)
index|[
name|R
index|]
index|[
name|C
index|]
expr_stmt|;
return|return
name|V
return|;
block|}
end_decl_stmt

begin_comment
comment|/// \brief Matrix transpose.
end_comment

begin_expr_stmt
name|Matrix
name|transpose
argument_list|()
specifier|const
block|{
name|assert
argument_list|(
name|Rows
operator|!=
literal|0
operator|&&
name|Cols
operator|!=
literal|0
operator|&&
name|Data
operator|&&
literal|"Invalid matrix"
argument_list|)
block|;
name|Matrix
name|M
argument_list|(
name|Cols
argument_list|,
name|Rows
argument_list|)
block|;
for|for
control|(
name|unsigned
name|r
init|=
literal|0
init|;
name|r
operator|<
name|Rows
condition|;
operator|++
name|r
control|)
for|for
control|(
name|unsigned
name|c
init|=
literal|0
init|;
name|c
operator|<
name|Cols
condition|;
operator|++
name|c
control|)
name|M
index|[
name|c
index|]
index|[
name|r
index|]
operator|=
operator|(
operator|*
name|this
operator|)
index|[
name|r
index|]
index|[
name|c
index|]
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|M
return|;
end_return

begin_comment
unit|}
comment|/// \brief Add the given matrix to this one.
end_comment

begin_expr_stmt
unit|Matrix
operator|&
name|operator
operator|+=
operator|(
specifier|const
name|Matrix
operator|&
name|M
operator|)
block|{
name|assert
argument_list|(
name|Rows
operator|!=
literal|0
operator|&&
name|Cols
operator|!=
literal|0
operator|&&
name|Data
operator|&&
literal|"Invalid matrix"
argument_list|)
block|;
name|assert
argument_list|(
name|Rows
operator|==
name|M
operator|.
name|Rows
operator|&&
name|Cols
operator|==
name|M
operator|.
name|Cols
operator|&&
literal|"Matrix dimensions mismatch."
argument_list|)
block|;
name|std
operator|::
name|transform
argument_list|(
name|Data
operator|.
name|get
argument_list|()
argument_list|,
name|Data
operator|.
name|get
argument_list|()
operator|+
operator|(
name|Rows
operator|*
name|Cols
operator|)
argument_list|,
name|M
operator|.
name|Data
operator|.
name|get
argument_list|()
argument_list|,
name|Data
operator|.
name|get
argument_list|()
argument_list|,
name|std
operator|::
name|plus
operator|<
name|PBQPNum
operator|>
operator|(
operator|)
argument_list|)
block|;
return|return
operator|*
name|this
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|Matrix
name|operator
operator|+
operator|(
specifier|const
name|Matrix
operator|&
name|M
operator|)
block|{
name|assert
argument_list|(
name|Rows
operator|!=
literal|0
operator|&&
name|Cols
operator|!=
literal|0
operator|&&
name|Data
operator|&&
literal|"Invalid matrix"
argument_list|)
block|;
name|Matrix
name|Tmp
argument_list|(
operator|*
name|this
argument_list|)
block|;
name|Tmp
operator|+=
name|M
block|;
return|return
name|Tmp
return|;
block|}
end_expr_stmt

begin_label
name|private
label|:
end_label

begin_decl_stmt
name|unsigned
name|Rows
decl_stmt|,
name|Cols
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|std
operator|::
name|unique_ptr
operator|<
name|PBQPNum
index|[]
operator|>
name|Data
expr_stmt|;
end_expr_stmt

begin_comment
unit|};
comment|/// \brief Return a hash_code for the given matrix.
end_comment

begin_function
specifier|inline
name|hash_code
name|hash_value
parameter_list|(
specifier|const
name|Matrix
modifier|&
name|M
parameter_list|)
block|{
name|unsigned
modifier|*
name|MBegin
init|=
name|reinterpret_cast
operator|<
name|unsigned
operator|*
operator|>
operator|(
name|M
operator|.
name|Data
operator|.
name|get
argument_list|()
operator|)
decl_stmt|;
name|unsigned
modifier|*
name|MEnd
init|=
name|reinterpret_cast
operator|<
name|unsigned
operator|*
operator|>
operator|(
name|M
operator|.
name|Data
operator|.
name|get
argument_list|()
operator|+
operator|(
name|M
operator|.
name|Rows
operator|*
name|M
operator|.
name|Cols
operator|)
operator|)
decl_stmt|;
return|return
name|hash_combine
argument_list|(
name|M
operator|.
name|Rows
argument_list|,
name|M
operator|.
name|Cols
argument_list|,
name|hash_combine_range
argument_list|(
name|MBegin
argument_list|,
name|MEnd
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/// \brief Output a textual representation of the given matrix on the given
end_comment

begin_comment
comment|///        output stream.
end_comment

begin_expr_stmt
name|template
operator|<
name|typename
name|OStream
operator|>
name|OStream
operator|&
name|operator
operator|<<
operator|(
name|OStream
operator|&
name|OS
operator|,
specifier|const
name|Matrix
operator|&
name|M
operator|)
block|{
name|assert
argument_list|(
operator|(
name|M
operator|.
name|getRows
argument_list|()
operator|!=
literal|0
operator|)
operator|&&
literal|"Zero-row matrix badness."
argument_list|)
block|;
for|for
control|(
name|unsigned
name|i
init|=
literal|0
init|;
name|i
operator|<
name|M
operator|.
name|getRows
argument_list|()
condition|;
operator|++
name|i
control|)
name|OS
operator|<<
name|M
operator|.
name|getRowAsVector
argument_list|(
name|i
argument_list|)
operator|<<
literal|"\n"
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|OS
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|Metadata
operator|>
name|class
name|MDVector
operator|:
name|public
name|Vector
block|{
name|public
operator|:
name|MDVector
argument_list|(
specifier|const
name|Vector
operator|&
name|v
argument_list|)
operator|:
name|Vector
argument_list|(
name|v
argument_list|)
block|,
name|md
argument_list|(
argument|*this
argument_list|)
block|{ }
name|MDVector
argument_list|(
name|Vector
operator|&&
name|v
argument_list|)
operator|:
name|Vector
argument_list|(
name|std
operator|::
name|move
argument_list|(
name|v
argument_list|)
argument_list|)
block|,
name|md
argument_list|(
argument|*this
argument_list|)
block|{ }
specifier|const
name|Metadata
operator|&
name|getMetadata
argument_list|()
specifier|const
block|{
return|return
name|md
return|;
block|}
name|private
operator|:
name|Metadata
name|md
expr_stmt|;
end_expr_stmt

begin_expr_stmt
unit|};
name|template
operator|<
name|typename
name|Metadata
operator|>
specifier|inline
name|hash_code
name|hash_value
argument_list|(
argument|const MDVector<Metadata>&V
argument_list|)
block|{
return|return
name|hash_value
argument_list|(
name|static_cast
operator|<
specifier|const
name|Vector
operator|&
operator|>
operator|(
name|V
operator|)
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|Metadata
operator|>
name|class
name|MDMatrix
operator|:
name|public
name|Matrix
block|{
name|public
operator|:
name|MDMatrix
argument_list|(
specifier|const
name|Matrix
operator|&
name|m
argument_list|)
operator|:
name|Matrix
argument_list|(
name|m
argument_list|)
block|,
name|md
argument_list|(
argument|*this
argument_list|)
block|{ }
name|MDMatrix
argument_list|(
name|Matrix
operator|&&
name|m
argument_list|)
operator|:
name|Matrix
argument_list|(
name|std
operator|::
name|move
argument_list|(
name|m
argument_list|)
argument_list|)
block|,
name|md
argument_list|(
argument|*this
argument_list|)
block|{ }
specifier|const
name|Metadata
operator|&
name|getMetadata
argument_list|()
specifier|const
block|{
return|return
name|md
return|;
block|}
name|private
operator|:
name|Metadata
name|md
expr_stmt|;
end_expr_stmt

begin_expr_stmt
unit|};
name|template
operator|<
name|typename
name|Metadata
operator|>
specifier|inline
name|hash_code
name|hash_value
argument_list|(
argument|const MDMatrix<Metadata>&M
argument_list|)
block|{
return|return
name|hash_value
argument_list|(
name|static_cast
operator|<
specifier|const
name|Matrix
operator|&
operator|>
operator|(
name|M
operator|)
argument_list|)
return|;
block|}
end_expr_stmt

begin_comment
unit|}
comment|// namespace PBQP
end_comment

begin_comment
unit|}
comment|// namespace llvm
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|// LLVM_CODEGEN_PBQP_MATH_H
end_comment

end_unit

