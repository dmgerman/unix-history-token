begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===- llvm/CodeGen/GCStrategy.h - Garbage collection -----------*- C++ -*-===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// GCStrategy coordinates code generation algorithms and implements some itself
end_comment

begin_comment
comment|// in order to generate code compatible with a target code generator as
end_comment

begin_comment
comment|// specified in a function's 'gc' attribute. Algorithms are enabled by setting
end_comment

begin_comment
comment|// flags in a subclass's constructor, and some virtual methods can be
end_comment

begin_comment
comment|// overridden.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// GCStrategy is relevant for implementations using either gc.root or
end_comment

begin_comment
comment|// gc.statepoint based lowering strategies, but is currently focused mostly on
end_comment

begin_comment
comment|// options for gc.root.  This will change over time.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// When requested by a subclass of GCStrategy, the gc.root implementation will
end_comment

begin_comment
comment|// populate GCModuleInfo and GCFunctionInfo with that about each Function in
end_comment

begin_comment
comment|// the Module that opts in to garbage collection.  Specifically:
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// - Safe points
end_comment

begin_comment
comment|//   Garbage collection is generally only possible at certain points in code.
end_comment

begin_comment
comment|//   GCStrategy can request that the collector insert such points:
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//     - At and after any call to a subroutine
end_comment

begin_comment
comment|//     - Before returning from the current function
end_comment

begin_comment
comment|//     - Before backwards branches (loops)
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// - Roots
end_comment

begin_comment
comment|//   When a reference to a GC-allocated object exists on the stack, it must be
end_comment

begin_comment
comment|//   stored in an alloca registered with llvm.gcoot.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This information can used to emit the metadata tables which are required by
end_comment

begin_comment
comment|// the target garbage collector runtime.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// When used with gc.statepoint, information about safepoint and roots can be
end_comment

begin_comment
comment|// found in the binary StackMap section after code generation.  Safepoint
end_comment

begin_comment
comment|// placement is currently the responsibility of the frontend, though late
end_comment

begin_comment
comment|// insertion support is planned.  gc.statepoint does not currently support
end_comment

begin_comment
comment|// custom stack map formats; such can be generated by parsing the standard
end_comment

begin_comment
comment|// stack map section if desired.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// The read and write barrier support can be used with either implementation.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LLVM_CODEGEN_GCSTRATEGY_H
end_ifndef

begin_define
define|#
directive|define
name|LLVM_CODEGEN_GCSTRATEGY_H
end_define

begin_include
include|#
directive|include
file|"llvm/ADT/None.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/Optional.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/Registry.h"
end_include

begin_include
include|#
directive|include
file|<string>
end_include

begin_decl_stmt
name|namespace
name|llvm
block|{
name|class
name|Type
decl_stmt|;
name|namespace
name|GC
block|{
comment|/// PointKind - Used to indicate whether the address of the call instruction
comment|/// or the address after the call instruction is listed in the stackmap.  For
comment|/// most runtimes, PostCall safepoints are appropriate.
comment|///
enum|enum
name|PointKind
block|{
name|PreCall
block|,
comment|///< Instr is a call instruction.
name|PostCall
comment|///< Instr is the return address of a call.
block|}
enum|;
block|}
comment|// end namespace GC
comment|/// GCStrategy describes a garbage collector algorithm's code generation
comment|/// requirements, and provides overridable hooks for those needs which cannot
comment|/// be abstractly described.  GCStrategy objects must be looked up through
comment|/// the Function.  The objects themselves are owned by the Context and must
comment|/// be immutable.
name|class
name|GCStrategy
block|{
name|private
label|:
name|friend
name|class
name|GCModuleInfo
decl_stmt|;
name|std
operator|::
name|string
name|Name
expr_stmt|;
name|protected
label|:
name|bool
name|UseStatepoints
init|=
name|false
decl_stmt|;
comment|/// Uses gc.statepoints as opposed to gc.roots,
comment|/// if set, none of the other options can be
comment|/// anything but their default values.
name|unsigned
name|NeededSafePoints
init|=
literal|0
decl_stmt|;
comment|///< Bitmask of required safe points.
name|bool
name|CustomReadBarriers
init|=
name|false
decl_stmt|;
comment|///< Default is to insert loads.
name|bool
name|CustomWriteBarriers
init|=
name|false
decl_stmt|;
comment|///< Default is to insert stores.
name|bool
name|CustomRoots
init|=
name|false
decl_stmt|;
comment|///< Default is to pass through to backend.
name|bool
name|InitRoots
init|=
name|true
decl_stmt|;
comment|///< If set, roots are nulled during lowering.
name|bool
name|UsesMetadata
init|=
name|false
decl_stmt|;
comment|///< If set, backend must emit metadata tables.
name|public
label|:
name|GCStrategy
argument_list|()
expr_stmt|;
name|virtual
operator|~
name|GCStrategy
argument_list|()
operator|=
expr|default
expr_stmt|;
comment|/// Return the name of the GC strategy.  This is the value of the collector
comment|/// name string specified on functions which use this strategy.
specifier|const
name|std
operator|::
name|string
operator|&
name|getName
argument_list|()
specifier|const
block|{
return|return
name|Name
return|;
block|}
comment|/// By default, write barriers are replaced with simple store
comment|/// instructions. If true, you must provide a custom pass to lower
comment|/// calls to @llvm.gcwrite.
name|bool
name|customWriteBarrier
argument_list|()
specifier|const
block|{
return|return
name|CustomWriteBarriers
return|;
block|}
comment|/// By default, read barriers are replaced with simple load
comment|/// instructions. If true, you must provide a custom pass to lower
comment|/// calls to @llvm.gcread.
name|bool
name|customReadBarrier
argument_list|()
specifier|const
block|{
return|return
name|CustomReadBarriers
return|;
block|}
comment|/// Returns true if this strategy is expecting the use of gc.statepoints,
comment|/// and false otherwise.
name|bool
name|useStatepoints
argument_list|()
specifier|const
block|{
return|return
name|UseStatepoints
return|;
block|}
comment|/** @name Statepoint Specific Properties */
comment|///@{
comment|/// If the type specified can be reliably distinguished, returns true for
comment|/// pointers to GC managed locations and false for pointers to non-GC
comment|/// managed locations.  Note a GCStrategy can always return 'None' (i.e. an
comment|/// empty optional indicating it can't reliably distinguish.
name|virtual
name|Optional
operator|<
name|bool
operator|>
name|isGCManagedPointer
argument_list|(
argument|const Type *Ty
argument_list|)
specifier|const
block|{
return|return
name|None
return|;
block|}
comment|///@}
comment|/** @name GCRoot Specific Properties    * These properties and overrides only apply to collector strategies using    * GCRoot.    */
comment|///@{
comment|/// True if safe points of any kind are required. By default, none are
comment|/// recorded.
name|bool
name|needsSafePoints
argument_list|()
specifier|const
block|{
return|return
name|NeededSafePoints
operator|!=
literal|0
return|;
block|}
comment|/// True if the given kind of safe point is required. By default, none are
comment|/// recorded.
name|bool
name|needsSafePoint
argument_list|(
name|GC
operator|::
name|PointKind
name|Kind
argument_list|)
decl|const
block|{
return|return
operator|(
name|NeededSafePoints
operator|&
literal|1
operator|<<
name|Kind
operator|)
operator|!=
literal|0
return|;
block|}
comment|/// By default, roots are left for the code generator so it can generate a
comment|/// stack map. If true, you must provide a custom pass to lower
comment|/// calls to @llvm.gcroot.
name|bool
name|customRoots
argument_list|()
specifier|const
block|{
return|return
name|CustomRoots
return|;
block|}
comment|/// If set, gcroot intrinsics should initialize their allocas to null
comment|/// before the first use. This is necessary for most GCs and is enabled by
comment|/// default.
name|bool
name|initializeRoots
argument_list|()
specifier|const
block|{
return|return
name|InitRoots
return|;
block|}
comment|/// If set, appropriate metadata tables must be emitted by the back-end
comment|/// (assembler, JIT, or otherwise). For statepoint, this method is
comment|/// currently unsupported.  The stackmap information can be found in the
comment|/// StackMap section as described in the documentation.
name|bool
name|usesMetadata
argument_list|()
specifier|const
block|{
return|return
name|UsesMetadata
return|;
block|}
comment|///@}
block|}
empty_stmt|;
comment|/// Subclasses of GCStrategy are made available for use during compilation by
comment|/// adding them to the global GCRegistry.  This can done either within the
comment|/// LLVM source tree or via a loadable plugin.  An example registeration
comment|/// would be:
comment|/// static GCRegistry::Add<CustomGC> X("custom-name",
comment|///        "my custom supper fancy gc strategy");
comment|///
comment|/// Note that to use a custom GCMetadataPrinter w/gc.roots, you must also
comment|/// register your GCMetadataPrinter subclass with the
comment|/// GCMetadataPrinterRegistery as well.
typedef|typedef
name|Registry
operator|<
name|GCStrategy
operator|>
name|GCRegistry
expr_stmt|;
block|}
end_decl_stmt

begin_comment
comment|// end namespace llvm
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|// LLVM_CODEGEN_GCSTRATEGY_H
end_comment

end_unit

