begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===- lib/CodeGen/DIE.h - DWARF Info Entries -------------------*- C++ -*-===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// Data structures for DWARF info entries.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LLVM_LIB_CODEGEN_ASMPRINTER_DIE_H
end_ifndef

begin_define
define|#
directive|define
name|LLVM_LIB_CODEGEN_ASMPRINTER_DIE_H
end_define

begin_include
include|#
directive|include
file|"llvm/ADT/FoldingSet.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/PointerIntPair.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/PointerUnion.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/SmallVector.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/StringRef.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/iterator.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/iterator_range.h"
end_include

begin_include
include|#
directive|include
file|"llvm/CodeGen/DwarfStringPoolEntry.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/AlignOf.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/Allocator.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/Dwarf.h"
end_include

begin_include
include|#
directive|include
file|<cassert>
end_include

begin_include
include|#
directive|include
file|<cstddef>
end_include

begin_include
include|#
directive|include
file|<cstdint>
end_include

begin_include
include|#
directive|include
file|<iterator>
end_include

begin_include
include|#
directive|include
file|<new>
end_include

begin_include
include|#
directive|include
file|<type_traits>
end_include

begin_include
include|#
directive|include
file|<utility>
end_include

begin_include
include|#
directive|include
file|<vector>
end_include

begin_decl_stmt
name|namespace
name|llvm
block|{
name|class
name|AsmPrinter
decl_stmt|;
name|class
name|DIE
decl_stmt|;
name|class
name|DIEUnit
decl_stmt|;
name|class
name|MCExpr
decl_stmt|;
name|class
name|MCSection
decl_stmt|;
name|class
name|MCSymbol
decl_stmt|;
name|class
name|raw_ostream
decl_stmt|;
comment|//===--------------------------------------------------------------------===//
comment|/// Dwarf abbreviation data, describes one attribute of a Dwarf abbreviation.
name|class
name|DIEAbbrevData
block|{
comment|/// Dwarf attribute code.
name|dwarf
operator|::
name|Attribute
name|Attribute
expr_stmt|;
comment|/// Dwarf form code.
name|dwarf
operator|::
name|Form
name|Form
expr_stmt|;
comment|/// Dwarf attribute value for DW_FORM_implicit_const
name|int64_t
name|Value
init|=
literal|0
decl_stmt|;
name|public
label|:
name|DIEAbbrevData
argument_list|(
argument|dwarf::Attribute A
argument_list|,
argument|dwarf::Form F
argument_list|)
block|:
name|Attribute
argument_list|(
name|A
argument_list|)
operator|,
name|Form
argument_list|(
argument|F
argument_list|)
block|{}
name|DIEAbbrevData
argument_list|(
argument|dwarf::Attribute A
argument_list|,
argument|int64_t V
argument_list|)
operator|:
name|Attribute
argument_list|(
name|A
argument_list|)
operator|,
name|Form
argument_list|(
name|dwarf
operator|::
name|DW_FORM_implicit_const
argument_list|)
operator|,
name|Value
argument_list|(
argument|V
argument_list|)
block|{}
comment|/// Accessors.
comment|/// @{
name|dwarf
operator|::
name|Attribute
name|getAttribute
argument_list|()
specifier|const
block|{
return|return
name|Attribute
return|;
block|}
name|dwarf
operator|::
name|Form
name|getForm
argument_list|()
specifier|const
block|{
return|return
name|Form
return|;
block|}
name|int64_t
name|getValue
argument_list|()
specifier|const
block|{
return|return
name|Value
return|;
block|}
comment|/// @}
comment|/// Used to gather unique data for the abbreviation folding set.
name|void
name|Profile
argument_list|(
name|FoldingSetNodeID
operator|&
name|ID
argument_list|)
decl|const
decl_stmt|;
block|}
empty_stmt|;
comment|//===--------------------------------------------------------------------===//
comment|/// Dwarf abbreviation, describes the organization of a debug information
comment|/// object.
name|class
name|DIEAbbrev
range|:
name|public
name|FoldingSetNode
block|{
comment|/// Unique number for node.
name|unsigned
name|Number
block|;
comment|/// Dwarf tag code.
name|dwarf
operator|::
name|Tag
name|Tag
block|;
comment|/// Whether or not this node has children.
comment|///
comment|/// This cheats a bit in all of the uses since the values in the standard
comment|/// are 0 and 1 for no children and children respectively.
name|bool
name|Children
block|;
comment|/// Raw data bytes for abbreviation.
name|SmallVector
operator|<
name|DIEAbbrevData
block|,
literal|12
operator|>
name|Data
block|;
name|public
operator|:
name|DIEAbbrev
argument_list|(
argument|dwarf::Tag T
argument_list|,
argument|bool C
argument_list|)
operator|:
name|Tag
argument_list|(
name|T
argument_list|)
block|,
name|Children
argument_list|(
argument|C
argument_list|)
block|{}
comment|/// Accessors.
comment|/// @{
name|dwarf
operator|::
name|Tag
name|getTag
argument_list|()
specifier|const
block|{
return|return
name|Tag
return|;
block|}
name|unsigned
name|getNumber
argument_list|()
specifier|const
block|{
return|return
name|Number
return|;
block|}
name|bool
name|hasChildren
argument_list|()
specifier|const
block|{
return|return
name|Children
return|;
block|}
specifier|const
name|SmallVectorImpl
operator|<
name|DIEAbbrevData
operator|>
operator|&
name|getData
argument_list|()
specifier|const
block|{
return|return
name|Data
return|;
block|}
name|void
name|setChildrenFlag
argument_list|(
argument|bool hasChild
argument_list|)
block|{
name|Children
operator|=
name|hasChild
block|; }
name|void
name|setNumber
argument_list|(
argument|unsigned N
argument_list|)
block|{
name|Number
operator|=
name|N
block|; }
comment|/// @}
comment|/// Adds another set of attribute information to the abbreviation.
name|void
name|AddAttribute
argument_list|(
argument|dwarf::Attribute Attribute
argument_list|,
argument|dwarf::Form Form
argument_list|)
block|{
name|Data
operator|.
name|push_back
argument_list|(
name|DIEAbbrevData
argument_list|(
name|Attribute
argument_list|,
name|Form
argument_list|)
argument_list|)
block|;   }
comment|/// Adds attribute with DW_FORM_implicit_const value
name|void
name|AddImplicitConstAttribute
argument_list|(
argument|dwarf::Attribute Attribute
argument_list|,
argument|int64_t Value
argument_list|)
block|{
name|Data
operator|.
name|push_back
argument_list|(
name|DIEAbbrevData
argument_list|(
name|Attribute
argument_list|,
name|Value
argument_list|)
argument_list|)
block|;   }
comment|/// Used to gather unique data for the abbreviation folding set.
name|void
name|Profile
argument_list|(
argument|FoldingSetNodeID&ID
argument_list|)
specifier|const
block|;
comment|/// Print the abbreviation using the specified asm printer.
name|void
name|Emit
argument_list|(
argument|const AsmPrinter *AP
argument_list|)
specifier|const
block|;
name|void
name|print
argument_list|(
name|raw_ostream
operator|&
name|O
argument_list|)
block|;
name|void
name|dump
argument_list|()
block|; }
decl_stmt|;
comment|//===--------------------------------------------------------------------===//
comment|/// Helps unique DIEAbbrev objects and assigns abbreviation numbers.
comment|///
comment|/// This class will unique the DIE abbreviations for a llvm::DIE object and
comment|/// assign a unique abbreviation number to each unique DIEAbbrev object it
comment|/// finds. The resulting collection of DIEAbbrev objects can then be emitted
comment|/// into the .debug_abbrev section.
name|class
name|DIEAbbrevSet
block|{
comment|/// The bump allocator to use when creating DIEAbbrev objects in the uniqued
comment|/// storage container.
name|BumpPtrAllocator
modifier|&
name|Alloc
decl_stmt|;
comment|/// \brief FoldingSet that uniques the abbreviations.
name|FoldingSet
operator|<
name|DIEAbbrev
operator|>
name|AbbreviationsSet
expr_stmt|;
comment|/// A list of all the unique abbreviations in use.
name|std
operator|::
name|vector
operator|<
name|DIEAbbrev
operator|*
operator|>
name|Abbreviations
expr_stmt|;
name|public
label|:
name|DIEAbbrevSet
argument_list|(
name|BumpPtrAllocator
operator|&
name|A
argument_list|)
operator|:
name|Alloc
argument_list|(
argument|A
argument_list|)
block|{}
operator|~
name|DIEAbbrevSet
argument_list|()
expr_stmt|;
comment|/// Generate the abbreviation declaration for a DIE and return a pointer to
comment|/// the generated abbreviation.
comment|///
comment|/// \param Die the debug info entry to generate the abbreviation for.
comment|/// \returns A reference to the uniqued abbreviation declaration that is
comment|/// owned by this class.
name|DIEAbbrev
modifier|&
name|uniqueAbbreviation
parameter_list|(
name|DIE
modifier|&
name|Die
parameter_list|)
function_decl|;
comment|/// Print all abbreviations using the specified asm printer.
name|void
name|Emit
argument_list|(
specifier|const
name|AsmPrinter
operator|*
name|AP
argument_list|,
name|MCSection
operator|*
name|Section
argument_list|)
decl|const
decl_stmt|;
block|}
empty_stmt|;
comment|//===--------------------------------------------------------------------===//
comment|/// An integer value DIE.
comment|///
name|class
name|DIEInteger
block|{
name|uint64_t
name|Integer
decl_stmt|;
name|public
label|:
name|explicit
name|DIEInteger
argument_list|(
argument|uint64_t I
argument_list|)
block|:
name|Integer
argument_list|(
argument|I
argument_list|)
block|{}
comment|/// Choose the best form for integer.
specifier|static
name|dwarf
operator|::
name|Form
name|BestForm
argument_list|(
argument|bool IsSigned
argument_list|,
argument|uint64_t Int
argument_list|)
block|{
if|if
condition|(
name|IsSigned
condition|)
block|{
specifier|const
name|int64_t
name|SignedInt
init|=
name|Int
decl_stmt|;
if|if
condition|(
operator|(
name|char
operator|)
name|Int
operator|==
name|SignedInt
condition|)
return|return
name|dwarf
operator|::
name|DW_FORM_data1
return|;
if|if
condition|(
operator|(
name|short
operator|)
name|Int
operator|==
name|SignedInt
condition|)
return|return
name|dwarf
operator|::
name|DW_FORM_data2
return|;
if|if
condition|(
operator|(
name|int
operator|)
name|Int
operator|==
name|SignedInt
condition|)
return|return
name|dwarf
operator|::
name|DW_FORM_data4
return|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|unsigned
name|char
operator|)
name|Int
operator|==
name|Int
condition|)
return|return
name|dwarf
operator|::
name|DW_FORM_data1
return|;
if|if
condition|(
operator|(
name|unsigned
name|short
operator|)
name|Int
operator|==
name|Int
condition|)
return|return
name|dwarf
operator|::
name|DW_FORM_data2
return|;
if|if
condition|(
operator|(
name|unsigned
name|int
operator|)
name|Int
operator|==
name|Int
condition|)
return|return
name|dwarf
operator|::
name|DW_FORM_data4
return|;
block|}
return|return
name|dwarf
operator|::
name|DW_FORM_data8
return|;
block|}
name|uint64_t
name|getValue
argument_list|()
specifier|const
block|{
return|return
name|Integer
return|;
block|}
name|void
name|setValue
parameter_list|(
name|uint64_t
name|Val
parameter_list|)
block|{
name|Integer
operator|=
name|Val
expr_stmt|;
block|}
name|void
name|EmitValue
argument_list|(
specifier|const
name|AsmPrinter
operator|*
name|AP
argument_list|,
name|dwarf
operator|::
name|Form
name|Form
argument_list|)
decl|const
decl_stmt|;
name|unsigned
name|SizeOf
argument_list|(
specifier|const
name|AsmPrinter
operator|*
name|AP
argument_list|,
name|dwarf
operator|::
name|Form
name|Form
argument_list|)
decl|const
decl_stmt|;
name|void
name|print
argument_list|(
name|raw_ostream
operator|&
name|O
argument_list|)
decl|const
decl_stmt|;
block|}
empty_stmt|;
comment|//===--------------------------------------------------------------------===//
comment|/// An expression DIE.
name|class
name|DIEExpr
block|{
specifier|const
name|MCExpr
modifier|*
name|Expr
decl_stmt|;
name|public
label|:
name|explicit
name|DIEExpr
argument_list|(
specifier|const
name|MCExpr
operator|*
name|E
argument_list|)
operator|:
name|Expr
argument_list|(
argument|E
argument_list|)
block|{}
comment|/// Get MCExpr.
specifier|const
name|MCExpr
operator|*
name|getValue
argument_list|()
specifier|const
block|{
return|return
name|Expr
return|;
block|}
name|void
name|EmitValue
argument_list|(
specifier|const
name|AsmPrinter
operator|*
name|AP
argument_list|,
name|dwarf
operator|::
name|Form
name|Form
argument_list|)
decl|const
decl_stmt|;
name|unsigned
name|SizeOf
argument_list|(
specifier|const
name|AsmPrinter
operator|*
name|AP
argument_list|,
name|dwarf
operator|::
name|Form
name|Form
argument_list|)
decl|const
decl_stmt|;
name|void
name|print
argument_list|(
name|raw_ostream
operator|&
name|O
argument_list|)
decl|const
decl_stmt|;
block|}
empty_stmt|;
comment|//===--------------------------------------------------------------------===//
comment|/// A label DIE.
name|class
name|DIELabel
block|{
specifier|const
name|MCSymbol
modifier|*
name|Label
decl_stmt|;
name|public
label|:
name|explicit
name|DIELabel
argument_list|(
specifier|const
name|MCSymbol
operator|*
name|L
argument_list|)
operator|:
name|Label
argument_list|(
argument|L
argument_list|)
block|{}
comment|/// Get MCSymbol.
specifier|const
name|MCSymbol
operator|*
name|getValue
argument_list|()
specifier|const
block|{
return|return
name|Label
return|;
block|}
name|void
name|EmitValue
argument_list|(
specifier|const
name|AsmPrinter
operator|*
name|AP
argument_list|,
name|dwarf
operator|::
name|Form
name|Form
argument_list|)
decl|const
decl_stmt|;
name|unsigned
name|SizeOf
argument_list|(
specifier|const
name|AsmPrinter
operator|*
name|AP
argument_list|,
name|dwarf
operator|::
name|Form
name|Form
argument_list|)
decl|const
decl_stmt|;
name|void
name|print
argument_list|(
name|raw_ostream
operator|&
name|O
argument_list|)
decl|const
decl_stmt|;
block|}
empty_stmt|;
comment|//===--------------------------------------------------------------------===//
comment|/// A simple label difference DIE.
comment|///
name|class
name|DIEDelta
block|{
specifier|const
name|MCSymbol
modifier|*
name|LabelHi
decl_stmt|;
specifier|const
name|MCSymbol
modifier|*
name|LabelLo
decl_stmt|;
name|public
label|:
name|DIEDelta
argument_list|(
specifier|const
name|MCSymbol
operator|*
name|Hi
argument_list|,
specifier|const
name|MCSymbol
operator|*
name|Lo
argument_list|)
operator|:
name|LabelHi
argument_list|(
name|Hi
argument_list|)
operator|,
name|LabelLo
argument_list|(
argument|Lo
argument_list|)
block|{}
name|void
name|EmitValue
argument_list|(
argument|const AsmPrinter *AP
argument_list|,
argument|dwarf::Form Form
argument_list|)
specifier|const
expr_stmt|;
name|unsigned
name|SizeOf
argument_list|(
specifier|const
name|AsmPrinter
operator|*
name|AP
argument_list|,
name|dwarf
operator|::
name|Form
name|Form
argument_list|)
decl|const
decl_stmt|;
name|void
name|print
argument_list|(
name|raw_ostream
operator|&
name|O
argument_list|)
decl|const
decl_stmt|;
block|}
empty_stmt|;
comment|//===--------------------------------------------------------------------===//
comment|/// A container for string pool string values.
comment|///
comment|/// This class is used with the DW_FORM_strp and DW_FORM_GNU_str_index forms.
name|class
name|DIEString
block|{
name|DwarfStringPoolEntryRef
name|S
decl_stmt|;
name|public
label|:
name|DIEString
argument_list|(
argument|DwarfStringPoolEntryRef S
argument_list|)
block|:
name|S
argument_list|(
argument|S
argument_list|)
block|{}
comment|/// Grab the string out of the object.
name|StringRef
name|getString
argument_list|()
specifier|const
block|{
return|return
name|S
operator|.
name|getString
argument_list|()
return|;
block|}
name|void
name|EmitValue
argument_list|(
specifier|const
name|AsmPrinter
operator|*
name|AP
argument_list|,
name|dwarf
operator|::
name|Form
name|Form
argument_list|)
decl|const
decl_stmt|;
name|unsigned
name|SizeOf
argument_list|(
specifier|const
name|AsmPrinter
operator|*
name|AP
argument_list|,
name|dwarf
operator|::
name|Form
name|Form
argument_list|)
decl|const
decl_stmt|;
name|void
name|print
argument_list|(
name|raw_ostream
operator|&
name|O
argument_list|)
decl|const
decl_stmt|;
block|}
empty_stmt|;
comment|//===--------------------------------------------------------------------===//
comment|/// A container for inline string values.
comment|///
comment|/// This class is used with the DW_FORM_string form.
name|class
name|DIEInlineString
block|{
name|StringRef
name|S
decl_stmt|;
name|public
label|:
name|template
operator|<
name|typename
name|Allocator
operator|>
name|explicit
name|DIEInlineString
argument_list|(
argument|StringRef Str
argument_list|,
argument|Allocator&A
argument_list|)
operator|:
name|S
argument_list|(
argument|Str.copy(A)
argument_list|)
block|{}
operator|~
name|DIEInlineString
argument_list|()
operator|=
expr|default
expr_stmt|;
comment|/// Grab the string out of the object.
name|StringRef
name|getString
argument_list|()
specifier|const
block|{
return|return
name|S
return|;
block|}
name|void
name|EmitValue
argument_list|(
specifier|const
name|AsmPrinter
operator|*
name|AP
argument_list|,
name|dwarf
operator|::
name|Form
name|Form
argument_list|)
decl|const
decl_stmt|;
name|unsigned
name|SizeOf
argument_list|(
specifier|const
name|AsmPrinter
operator|*
name|AP
argument_list|,
name|dwarf
operator|::
name|Form
name|Form
argument_list|)
decl|const
decl_stmt|;
name|void
name|print
argument_list|(
name|raw_ostream
operator|&
name|O
argument_list|)
decl|const
decl_stmt|;
block|}
empty_stmt|;
comment|//===--------------------------------------------------------------------===//
comment|/// A pointer to another debug information entry.  An instance of this class can
comment|/// also be used as a proxy for a debug information entry not yet defined
comment|/// (ie. types.)
name|class
name|DIEEntry
block|{
name|DIE
modifier|*
name|Entry
decl_stmt|;
name|public
label|:
name|DIEEntry
argument_list|()
operator|=
name|delete
expr_stmt|;
name|explicit
name|DIEEntry
argument_list|(
name|DIE
operator|&
name|E
argument_list|)
operator|:
name|Entry
argument_list|(
argument|&E
argument_list|)
block|{}
name|DIE
operator|&
name|getEntry
argument_list|()
specifier|const
block|{
return|return
operator|*
name|Entry
return|;
block|}
name|void
name|EmitValue
argument_list|(
specifier|const
name|AsmPrinter
operator|*
name|AP
argument_list|,
name|dwarf
operator|::
name|Form
name|Form
argument_list|)
decl|const
decl_stmt|;
name|unsigned
name|SizeOf
argument_list|(
specifier|const
name|AsmPrinter
operator|*
name|AP
argument_list|,
name|dwarf
operator|::
name|Form
name|Form
argument_list|)
decl|const
decl_stmt|;
name|void
name|print
argument_list|(
name|raw_ostream
operator|&
name|O
argument_list|)
decl|const
decl_stmt|;
block|}
empty_stmt|;
comment|//===--------------------------------------------------------------------===//
comment|/// Represents a pointer to a location list in the debug_loc
comment|/// section.
name|class
name|DIELocList
block|{
comment|/// Index into the .debug_loc vector.
name|size_t
name|Index
decl_stmt|;
name|public
label|:
name|DIELocList
argument_list|(
argument|size_t I
argument_list|)
block|:
name|Index
argument_list|(
argument|I
argument_list|)
block|{}
comment|/// Grab the current index out.
name|size_t
name|getValue
argument_list|()
specifier|const
block|{
return|return
name|Index
return|;
block|}
name|void
name|EmitValue
argument_list|(
specifier|const
name|AsmPrinter
operator|*
name|AP
argument_list|,
name|dwarf
operator|::
name|Form
name|Form
argument_list|)
decl|const
decl_stmt|;
name|unsigned
name|SizeOf
argument_list|(
specifier|const
name|AsmPrinter
operator|*
name|AP
argument_list|,
name|dwarf
operator|::
name|Form
name|Form
argument_list|)
decl|const
decl_stmt|;
name|void
name|print
argument_list|(
name|raw_ostream
operator|&
name|O
argument_list|)
decl|const
decl_stmt|;
block|}
empty_stmt|;
comment|//===--------------------------------------------------------------------===//
comment|/// A debug information entry value. Some of these roughly correlate
comment|/// to DWARF attribute classes.
name|class
name|DIEBlock
decl_stmt|;
name|class
name|DIELoc
decl_stmt|;
name|class
name|DIEValue
block|{
name|public
label|:
enum|enum
name|Type
block|{
name|isNone
block|,
define|#
directive|define
name|HANDLE_DIEVALUE
parameter_list|(
name|T
parameter_list|)
value|is##T,
include|#
directive|include
file|"llvm/CodeGen/DIEValue.def"
block|}
enum|;
name|private
label|:
comment|/// Type of data stored in the value.
name|Type
name|Ty
init|=
name|isNone
decl_stmt|;
name|dwarf
operator|::
name|Attribute
name|Attribute
operator|=
operator|(
name|dwarf
operator|::
name|Attribute
operator|)
literal|0
expr_stmt|;
name|dwarf
operator|::
name|Form
name|Form
operator|=
operator|(
name|dwarf
operator|::
name|Form
operator|)
literal|0
expr_stmt|;
comment|/// Storage for the value.
comment|///
comment|/// All values that aren't standard layout (or are larger than 8 bytes)
comment|/// should be stored by reference instead of by value.
name|using
name|ValTy
init|=
name|AlignedCharArrayUnion
operator|<
name|DIEInteger
decl_stmt|,
name|DIEString
decl_stmt|,
name|DIEExpr
decl_stmt|,
name|DIELabel
decl_stmt|,
name|DIEDelta
modifier|*
decl_stmt|,
name|DIEEntry
decl_stmt|,
name|DIEBlock
modifier|*
decl_stmt|,
name|DIELoc
modifier|*
decl_stmt|,
name|DIELocList
decl|>
decl_stmt|;
name|static_assert
argument_list|(
sizeof|sizeof
argument_list|(
name|ValTy
argument_list|)
operator|<=
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
operator|||
sizeof|sizeof
argument_list|(
name|ValTy
argument_list|)
operator|<=
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
argument_list|,
literal|"Expected all large types to be stored via pointer"
argument_list|)
expr_stmt|;
comment|/// Underlying stored value.
name|ValTy
name|Val
decl_stmt|;
name|template
operator|<
name|class
name|T
operator|>
name|void
name|construct
argument_list|(
argument|T V
argument_list|)
block|{
name|static_assert
argument_list|(
name|std
operator|::
name|is_standard_layout
operator|<
name|T
operator|>
operator|::
name|value
operator|||
name|std
operator|::
name|is_pointer
operator|<
name|T
operator|>
operator|::
name|value
argument_list|,
literal|"Expected standard layout or pointer"
argument_list|)
block|;
name|new
argument_list|(
argument|reinterpret_cast<void *>(Val.buffer)
argument_list|)
name|T
argument_list|(
name|V
argument_list|)
block|;   }
name|template
operator|<
name|class
name|T
operator|>
name|T
operator|*
name|get
argument_list|()
block|{
return|return
name|reinterpret_cast
operator|<
name|T
operator|*
operator|>
operator|(
name|Val
operator|.
name|buffer
operator|)
return|;
block|}
name|template
operator|<
name|class
name|T
operator|>
specifier|const
name|T
operator|*
name|get
argument_list|()
specifier|const
block|{
return|return
name|reinterpret_cast
operator|<
specifier|const
name|T
operator|*
operator|>
operator|(
name|Val
operator|.
name|buffer
operator|)
return|;
block|}
name|template
operator|<
name|class
name|T
operator|>
name|void
name|destruct
argument_list|()
block|{
name|get
operator|<
name|T
operator|>
operator|(
operator|)
operator|->
operator|~
name|T
argument_list|()
block|; }
comment|/// Destroy the underlying value.
comment|///
comment|/// This should get optimized down to a no-op.  We could skip it if we could
comment|/// add a static assert on \a std::is_trivially_copyable(), but we currently
comment|/// support versions of GCC that don't understand that.
name|void
name|destroyVal
argument_list|()
block|{
switch|switch
condition|(
name|Ty
condition|)
block|{
case|case
name|isNone
case|:
return|return;
define|#
directive|define
name|HANDLE_DIEVALUE_SMALL
parameter_list|(
name|T
parameter_list|)
define|\
value|case is##T:                                                                  \     destruct<DIE##T>();
return|return;
define|#
directive|define
name|HANDLE_DIEVALUE_LARGE
parameter_list|(
name|T
parameter_list|)
define|\
value|case is##T:                                                                  \     destruct<const DIE##T *>();
return|return;
include|#
directive|include
file|"llvm/CodeGen/DIEValue.def"
block|}
block|}
comment|/// Copy the underlying value.
comment|///
comment|/// This should get optimized down to a simple copy.  We need to actually
comment|/// construct the value, rather than calling memcpy, to satisfy strict
comment|/// aliasing rules.
name|void
name|copyVal
argument_list|(
argument|const DIEValue&X
argument_list|)
block|{
switch|switch
condition|(
name|Ty
condition|)
block|{
case|case
name|isNone
case|:
return|return;
define|#
directive|define
name|HANDLE_DIEVALUE_SMALL
parameter_list|(
name|T
parameter_list|)
define|\
value|case is##T:                                                                  \     construct<DIE##T>(*X.get<DIE##T>());                                       \     return;
define|#
directive|define
name|HANDLE_DIEVALUE_LARGE
parameter_list|(
name|T
parameter_list|)
define|\
value|case is##T:                                                                  \     construct<const DIE##T *>(*X.get<const DIE##T *>());                       \     return;
include|#
directive|include
file|"llvm/CodeGen/DIEValue.def"
block|}
block|}
name|public
operator|:
name|DIEValue
argument_list|()
operator|=
expr|default
expr_stmt|;
name|DIEValue
argument_list|(
specifier|const
name|DIEValue
operator|&
name|X
argument_list|)
operator|:
name|Ty
argument_list|(
name|X
operator|.
name|Ty
argument_list|)
operator|,
name|Attribute
argument_list|(
name|X
operator|.
name|Attribute
argument_list|)
operator|,
name|Form
argument_list|(
argument|X.Form
argument_list|)
block|{
name|copyVal
argument_list|(
name|X
argument_list|)
block|;   }
name|DIEValue
operator|&
name|operator
operator|=
operator|(
specifier|const
name|DIEValue
operator|&
name|X
operator|)
block|{
name|destroyVal
argument_list|()
block|;
name|Ty
operator|=
name|X
operator|.
name|Ty
block|;
name|Attribute
operator|=
name|X
operator|.
name|Attribute
block|;
name|Form
operator|=
name|X
operator|.
name|Form
block|;
name|copyVal
argument_list|(
name|X
argument_list|)
block|;
return|return
operator|*
name|this
return|;
block|}
operator|~
name|DIEValue
argument_list|()
block|{
name|destroyVal
argument_list|()
block|; }
define|#
directive|define
name|HANDLE_DIEVALUE_SMALL
parameter_list|(
name|T
parameter_list|)
define|\
value|DIEValue(dwarf::Attribute Attribute, dwarf::Form Form, const DIE##T&V)      \       : Ty(is##T), Attribute(Attribute), Form(Form) {                          \     construct<DIE##T>(V);                                                      \   }
define|#
directive|define
name|HANDLE_DIEVALUE_LARGE
parameter_list|(
name|T
parameter_list|)
define|\
value|DIEValue(dwarf::Attribute Attribute, dwarf::Form Form, const DIE##T *V)      \       : Ty(is##T), Attribute(Attribute), Form(Form) {                          \     assert(V&& "Expected valid value");                                       \     construct<const DIE##T *>(V);                                              \   }
include|#
directive|include
file|"llvm/CodeGen/DIEValue.def"
comment|/// Accessors.
comment|/// @{
name|Type
name|getType
argument_list|()
specifier|const
block|{
return|return
name|Ty
return|;
block|}
name|dwarf
operator|::
name|Attribute
name|getAttribute
argument_list|()
specifier|const
block|{
return|return
name|Attribute
return|;
block|}
name|dwarf
operator|::
name|Form
name|getForm
argument_list|()
specifier|const
block|{
return|return
name|Form
return|;
block|}
name|explicit
name|operator
name|bool
argument_list|()
specifier|const
block|{
return|return
name|Ty
return|;
block|}
comment|/// @}
define|#
directive|define
name|HANDLE_DIEVALUE_SMALL
parameter_list|(
name|T
parameter_list|)
define|\
value|const DIE##T&getDIE##T() const {                                            \     assert(getType() == is##T&& "Expected " #T);                              \     return *get<DIE##T>();                                                     \   }
define|#
directive|define
name|HANDLE_DIEVALUE_LARGE
parameter_list|(
name|T
parameter_list|)
define|\
value|const DIE##T&getDIE##T() const {                                            \     assert(getType() == is##T&& "Expected " #T);                              \     return **get<const DIE##T *>();                                            \   }
include|#
directive|include
file|"llvm/CodeGen/DIEValue.def"
comment|/// Emit value via the Dwarf writer.
name|void
name|EmitValue
argument_list|(
specifier|const
name|AsmPrinter
operator|*
name|AP
argument_list|)
decl|const
decl_stmt|;
comment|/// Return the size of a value in bytes.
name|unsigned
name|SizeOf
argument_list|(
specifier|const
name|AsmPrinter
operator|*
name|AP
argument_list|)
decl|const
decl_stmt|;
name|void
name|print
argument_list|(
name|raw_ostream
operator|&
name|O
argument_list|)
decl|const
decl_stmt|;
name|void
name|dump
argument_list|()
specifier|const
expr_stmt|;
block|}
empty_stmt|;
struct|struct
name|IntrusiveBackListNode
block|{
name|PointerIntPair
operator|<
name|IntrusiveBackListNode
operator|*
operator|,
literal|1
operator|>
name|Next
expr_stmt|;
name|IntrusiveBackListNode
argument_list|()
operator|:
name|Next
argument_list|(
argument|this
argument_list|,
argument|true
argument_list|)
block|{}
name|IntrusiveBackListNode
operator|*
name|getNext
argument_list|()
specifier|const
block|{
return|return
name|Next
operator|.
name|getInt
argument_list|()
operator|?
name|nullptr
operator|:
name|Next
operator|.
name|getPointer
argument_list|()
return|;
block|}
block|}
struct|;
struct|struct
name|IntrusiveBackListBase
block|{
name|using
name|Node
init|=
name|IntrusiveBackListNode
decl_stmt|;
name|Node
modifier|*
name|Last
init|=
name|nullptr
decl_stmt|;
name|bool
name|empty
argument_list|()
specifier|const
block|{
return|return
operator|!
name|Last
return|;
block|}
name|void
name|push_back
parameter_list|(
name|Node
modifier|&
name|N
parameter_list|)
block|{
name|assert
argument_list|(
name|N
operator|.
name|Next
operator|.
name|getPointer
argument_list|()
operator|==
operator|&
name|N
operator|&&
literal|"Expected unlinked node"
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|N
operator|.
name|Next
operator|.
name|getInt
argument_list|()
operator|==
name|true
operator|&&
literal|"Expected unlinked node"
argument_list|)
expr_stmt|;
if|if
condition|(
name|Last
condition|)
block|{
name|N
operator|.
name|Next
operator|=
name|Last
operator|->
name|Next
expr_stmt|;
name|Last
operator|->
name|Next
operator|.
name|setPointerAndInt
argument_list|(
operator|&
name|N
argument_list|,
name|false
argument_list|)
expr_stmt|;
block|}
name|Last
operator|=
operator|&
name|N
expr_stmt|;
block|}
block|}
struct|;
name|template
operator|<
name|class
name|T
operator|>
name|class
name|IntrusiveBackList
operator|:
name|IntrusiveBackListBase
block|{
name|public
operator|:
name|using
name|IntrusiveBackListBase
operator|::
name|empty
block|;
name|void
name|push_back
argument_list|(
argument|T&N
argument_list|)
block|{
name|IntrusiveBackListBase
operator|::
name|push_back
argument_list|(
name|N
argument_list|)
block|; }
name|T
operator|&
name|back
argument_list|()
block|{
return|return
operator|*
name|static_cast
operator|<
name|T
operator|*
operator|>
operator|(
name|Last
operator|)
return|;
block|}
specifier|const
name|T
operator|&
name|back
argument_list|()
specifier|const
block|{
return|return
operator|*
name|static_cast
operator|<
name|T
operator|*
operator|>
operator|(
name|Last
operator|)
return|;
block|}
name|class
name|const_iterator
block|;
name|class
name|iterator
operator|:
name|public
name|iterator_facade_base
operator|<
name|iterator
block|,
name|std
operator|::
name|forward_iterator_tag
block|,
name|T
operator|>
block|{
name|friend
name|class
name|const_iterator
block|;
name|Node
operator|*
name|N
operator|=
name|nullptr
block|;
name|public
operator|:
name|iterator
argument_list|()
operator|=
expr|default
block|;
name|explicit
name|iterator
argument_list|(
name|T
operator|*
name|N
argument_list|)
operator|:
name|N
argument_list|(
argument|N
argument_list|)
block|{}
name|iterator
operator|&
name|operator
operator|++
operator|(
operator|)
block|{
name|N
operator|=
name|N
operator|->
name|getNext
argument_list|()
block|;
return|return
operator|*
name|this
return|;
block|}
name|explicit
name|operator
name|bool
argument_list|()
specifier|const
block|{
return|return
name|N
return|;
block|}
name|T
operator|&
name|operator
operator|*
operator|(
operator|)
specifier|const
block|{
return|return
operator|*
name|static_cast
operator|<
name|T
operator|*
operator|>
operator|(
name|N
operator|)
return|;
block|}
name|bool
name|operator
operator|==
operator|(
specifier|const
name|iterator
operator|&
name|X
operator|)
specifier|const
block|{
return|return
name|N
operator|==
name|X
operator|.
name|N
return|;
block|}
name|bool
name|operator
operator|!=
operator|(
specifier|const
name|iterator
operator|&
name|X
operator|)
specifier|const
block|{
return|return
name|N
operator|!=
name|X
operator|.
name|N
return|;
block|}
expr|}
block|;
name|class
name|const_iterator
operator|:
name|public
name|iterator_facade_base
operator|<
name|const_iterator
block|,
name|std
operator|::
name|forward_iterator_tag
block|,
specifier|const
name|T
operator|>
block|{
specifier|const
name|Node
operator|*
name|N
operator|=
name|nullptr
block|;
name|public
operator|:
name|const_iterator
argument_list|()
operator|=
expr|default
block|;
comment|// Placate MSVC by explicitly scoping 'iterator'.
name|const_iterator
argument_list|(
argument|typename IntrusiveBackList<T>::iterator X
argument_list|)
operator|:
name|N
argument_list|(
argument|X.N
argument_list|)
block|{}
name|explicit
name|const_iterator
argument_list|(
specifier|const
name|T
operator|*
name|N
argument_list|)
operator|:
name|N
argument_list|(
argument|N
argument_list|)
block|{}
name|const_iterator
operator|&
name|operator
operator|++
operator|(
operator|)
block|{
name|N
operator|=
name|N
operator|->
name|getNext
argument_list|()
block|;
return|return
operator|*
name|this
return|;
block|}
name|explicit
name|operator
name|bool
argument_list|()
specifier|const
block|{
return|return
name|N
return|;
block|}
specifier|const
name|T
operator|&
name|operator
operator|*
operator|(
operator|)
specifier|const
block|{
return|return
operator|*
name|static_cast
operator|<
specifier|const
name|T
operator|*
operator|>
operator|(
name|N
operator|)
return|;
block|}
name|bool
name|operator
operator|==
operator|(
specifier|const
name|const_iterator
operator|&
name|X
operator|)
specifier|const
block|{
return|return
name|N
operator|==
name|X
operator|.
name|N
return|;
block|}
name|bool
name|operator
operator|!=
operator|(
specifier|const
name|const_iterator
operator|&
name|X
operator|)
specifier|const
block|{
return|return
name|N
operator|!=
name|X
operator|.
name|N
return|;
block|}
expr|}
block|;
name|iterator
name|begin
argument_list|()
block|{
return|return
name|Last
operator|?
name|iterator
argument_list|(
name|static_cast
operator|<
name|T
operator|*
operator|>
operator|(
name|Last
operator|->
name|Next
operator|.
name|getPointer
argument_list|()
operator|)
argument_list|)
operator|:
name|end
argument_list|()
return|;
block|}
name|const_iterator
name|begin
argument_list|()
specifier|const
block|{
return|return
name|const_cast
operator|<
name|IntrusiveBackList
operator|*
operator|>
operator|(
name|this
operator|)
operator|->
name|begin
argument_list|()
return|;
block|}
name|iterator
name|end
argument_list|()
block|{
return|return
name|iterator
argument_list|()
return|;
block|}
name|const_iterator
name|end
argument_list|()
specifier|const
block|{
return|return
name|const_iterator
argument_list|()
return|;
block|}
specifier|static
name|iterator
name|toIterator
argument_list|(
argument|T&N
argument_list|)
block|{
return|return
name|iterator
argument_list|(
operator|&
name|N
argument_list|)
return|;
block|}
specifier|static
name|const_iterator
name|toIterator
argument_list|(
argument|const T&N
argument_list|)
block|{
return|return
name|const_iterator
argument_list|(
operator|&
name|N
argument_list|)
return|;
block|}
expr|}
block|;
comment|/// A list of DIE values.
comment|///
comment|/// This is a singly-linked list, but instead of reversing the order of
comment|/// insertion, we keep a pointer to the back of the list so we can push in
comment|/// order.
comment|///
comment|/// There are two main reasons to choose a linked list over a customized
comment|/// vector-like data structure.
comment|///
comment|///  1. For teardown efficiency, we want DIEs to be BumpPtrAllocated.  Using a
comment|///     linked list here makes this way easier to accomplish.
comment|///  2. Carrying an extra pointer per \a DIEValue isn't expensive.  45% of DIEs
comment|///     have 2 or fewer values, and 90% have 5 or fewer.  A vector would be
comment|///     over-allocated by 50% on average anyway, the same cost as the
comment|///     linked-list node.
name|class
name|DIEValueList
block|{   struct
name|Node
operator|:
name|IntrusiveBackListNode
block|{
name|DIEValue
name|V
block|;
name|explicit
name|Node
argument_list|(
argument|DIEValue V
argument_list|)
operator|:
name|V
argument_list|(
argument|V
argument_list|)
block|{}
block|}
block|;
name|using
name|ListTy
operator|=
name|IntrusiveBackList
operator|<
name|Node
operator|>
block|;
name|ListTy
name|List
block|;
name|public
operator|:
name|class
name|const_value_iterator
block|;
name|class
name|value_iterator
operator|:
name|public
name|iterator_adaptor_base
operator|<
name|value_iterator
block|,
name|ListTy
operator|::
name|iterator
block|,
name|std
operator|::
name|forward_iterator_tag
block|,
name|DIEValue
operator|>
block|{
name|friend
name|class
name|const_value_iterator
block|;
name|using
name|iterator_adaptor
operator|=
name|iterator_adaptor_base
operator|<
name|value_iterator
block|,
name|ListTy
operator|::
name|iterator
block|,
name|std
operator|::
name|forward_iterator_tag
block|,
name|DIEValue
operator|>
block|;
name|public
operator|:
name|value_iterator
argument_list|()
operator|=
expr|default
block|;
name|explicit
name|value_iterator
argument_list|(
argument|ListTy::iterator X
argument_list|)
operator|:
name|iterator_adaptor
argument_list|(
argument|X
argument_list|)
block|{}
name|explicit
name|operator
name|bool
argument_list|()
specifier|const
block|{
return|return
name|bool
argument_list|(
name|wrapped
argument_list|()
argument_list|)
return|;
block|}
name|DIEValue
operator|&
name|operator
operator|*
operator|(
operator|)
specifier|const
block|{
return|return
name|wrapped
argument_list|()
operator|->
name|V
return|;
block|}
expr|}
block|;
name|class
name|const_value_iterator
operator|:
name|public
name|iterator_adaptor_base
operator|<
name|const_value_iterator
block|,
name|ListTy
operator|::
name|const_iterator
block|,
name|std
operator|::
name|forward_iterator_tag
block|,
specifier|const
name|DIEValue
operator|>
block|{
name|using
name|iterator_adaptor
operator|=
name|iterator_adaptor_base
operator|<
name|const_value_iterator
block|,
name|ListTy
operator|::
name|const_iterator
block|,
name|std
operator|::
name|forward_iterator_tag
block|,
specifier|const
name|DIEValue
operator|>
block|;
name|public
operator|:
name|const_value_iterator
argument_list|()
operator|=
expr|default
block|;
name|const_value_iterator
argument_list|(
argument|DIEValueList::value_iterator X
argument_list|)
operator|:
name|iterator_adaptor
argument_list|(
argument|X.wrapped()
argument_list|)
block|{}
name|explicit
name|const_value_iterator
argument_list|(
argument|ListTy::const_iterator X
argument_list|)
operator|:
name|iterator_adaptor
argument_list|(
argument|X
argument_list|)
block|{}
name|explicit
name|operator
name|bool
argument_list|()
specifier|const
block|{
return|return
name|bool
argument_list|(
name|wrapped
argument_list|()
argument_list|)
return|;
block|}
specifier|const
name|DIEValue
operator|&
name|operator
operator|*
operator|(
operator|)
specifier|const
block|{
return|return
name|wrapped
argument_list|()
operator|->
name|V
return|;
block|}
expr|}
block|;
name|using
name|value_range
operator|=
name|iterator_range
operator|<
name|value_iterator
operator|>
block|;
name|using
name|const_value_range
operator|=
name|iterator_range
operator|<
name|const_value_iterator
operator|>
block|;
name|value_iterator
name|addValue
argument_list|(
argument|BumpPtrAllocator&Alloc
argument_list|,
argument|const DIEValue&V
argument_list|)
block|{
name|List
operator|.
name|push_back
argument_list|(
operator|*
name|new
argument_list|(
argument|Alloc
argument_list|)
name|Node
argument_list|(
name|V
argument_list|)
argument_list|)
block|;
return|return
name|value_iterator
argument_list|(
name|ListTy
operator|::
name|toIterator
argument_list|(
name|List
operator|.
name|back
argument_list|()
argument_list|)
argument_list|)
return|;
block|}
name|template
operator|<
name|class
name|T
operator|>
name|value_iterator
name|addValue
argument_list|(
argument|BumpPtrAllocator&Alloc
argument_list|,
argument|dwarf::Attribute Attribute
argument_list|,
argument|dwarf::Form Form
argument_list|,
argument|T&&Value
argument_list|)
block|{
return|return
name|addValue
argument_list|(
name|Alloc
argument_list|,
name|DIEValue
argument_list|(
name|Attribute
argument_list|,
name|Form
argument_list|,
name|std
operator|::
name|forward
operator|<
name|T
operator|>
operator|(
name|Value
operator|)
argument_list|)
argument_list|)
return|;
block|}
name|value_range
name|values
argument_list|()
block|{
return|return
name|make_range
argument_list|(
name|value_iterator
argument_list|(
name|List
operator|.
name|begin
argument_list|()
argument_list|)
argument_list|,
name|value_iterator
argument_list|(
name|List
operator|.
name|end
argument_list|()
argument_list|)
argument_list|)
return|;
block|}
name|const_value_range
name|values
argument_list|()
specifier|const
block|{
return|return
name|make_range
argument_list|(
name|const_value_iterator
argument_list|(
name|List
operator|.
name|begin
argument_list|()
argument_list|)
argument_list|,
name|const_value_iterator
argument_list|(
name|List
operator|.
name|end
argument_list|()
argument_list|)
argument_list|)
return|;
block|}
expr|}
block|;
comment|//===--------------------------------------------------------------------===//
comment|/// A structured debug information entry.  Has an abbreviation which
comment|/// describes its organization.
name|class
name|DIE
operator|:
name|IntrusiveBackListNode
block|,
name|public
name|DIEValueList
block|{
name|friend
name|class
name|IntrusiveBackList
operator|<
name|DIE
operator|>
block|;
name|friend
name|class
name|DIEUnit
block|;
comment|/// Dwarf unit relative offset.
name|unsigned
name|Offset
operator|=
literal|0
block|;
comment|/// Size of instance + children.
name|unsigned
name|Size
operator|=
literal|0
block|;
name|unsigned
name|AbbrevNumber
operator|=
operator|~
literal|0u
block|;
comment|/// Dwarf tag code.
name|dwarf
operator|::
name|Tag
name|Tag
operator|=
operator|(
name|dwarf
operator|::
name|Tag
operator|)
literal|0
block|;
comment|/// Set to true to force a DIE to emit an abbreviation that says it has
comment|/// children even when it doesn't. This is used for unit testing purposes.
name|bool
name|ForceChildren
operator|=
name|false
block|;
comment|/// Children DIEs.
name|IntrusiveBackList
operator|<
name|DIE
operator|>
name|Children
block|;
comment|/// The owner is either the parent DIE for children of other DIEs, or a
comment|/// DIEUnit which contains this DIE as its unit DIE.
name|PointerUnion
operator|<
name|DIE
operator|*
block|,
name|DIEUnit
operator|*
operator|>
name|Owner
block|;
name|explicit
name|DIE
argument_list|(
argument|dwarf::Tag Tag
argument_list|)
operator|:
name|Tag
argument_list|(
argument|Tag
argument_list|)
block|{}
name|public
operator|:
name|DIE
argument_list|()
operator|=
name|delete
block|;
name|DIE
argument_list|(
specifier|const
name|DIE
operator|&
name|RHS
argument_list|)
operator|=
name|delete
block|;
name|DIE
argument_list|(
name|DIE
operator|&&
name|RHS
argument_list|)
operator|=
name|delete
block|;
name|DIE
operator|&
name|operator
operator|=
operator|(
specifier|const
name|DIE
operator|&
name|RHS
operator|)
operator|=
name|delete
block|;
name|DIE
operator|&
name|operator
operator|=
operator|(
specifier|const
name|DIE
operator|&&
name|RHS
operator|)
operator|=
name|delete
block|;
specifier|static
name|DIE
operator|*
name|get
argument_list|(
argument|BumpPtrAllocator&Alloc
argument_list|,
argument|dwarf::Tag Tag
argument_list|)
block|{
return|return
name|new
argument_list|(
argument|Alloc
argument_list|)
name|DIE
argument_list|(
name|Tag
argument_list|)
return|;
block|}
comment|// Accessors.
name|unsigned
name|getAbbrevNumber
argument_list|()
specifier|const
block|{
return|return
name|AbbrevNumber
return|;
block|}
name|dwarf
operator|::
name|Tag
name|getTag
argument_list|()
specifier|const
block|{
return|return
name|Tag
return|;
block|}
comment|/// Get the compile/type unit relative offset of this DIE.
name|unsigned
name|getOffset
argument_list|()
specifier|const
block|{
return|return
name|Offset
return|;
block|}
name|unsigned
name|getSize
argument_list|()
specifier|const
block|{
return|return
name|Size
return|;
block|}
name|bool
name|hasChildren
argument_list|()
specifier|const
block|{
return|return
name|ForceChildren
operator|||
operator|!
name|Children
operator|.
name|empty
argument_list|()
return|;
block|}
name|void
name|setForceChildren
argument_list|(
argument|bool B
argument_list|)
block|{
name|ForceChildren
operator|=
name|B
block|; }
name|using
name|child_iterator
operator|=
name|IntrusiveBackList
operator|<
name|DIE
operator|>
operator|::
name|iterator
block|;
name|using
name|const_child_iterator
operator|=
name|IntrusiveBackList
operator|<
name|DIE
operator|>
operator|::
name|const_iterator
block|;
name|using
name|child_range
operator|=
name|iterator_range
operator|<
name|child_iterator
operator|>
block|;
name|using
name|const_child_range
operator|=
name|iterator_range
operator|<
name|const_child_iterator
operator|>
block|;
name|child_range
name|children
argument_list|()
block|{
return|return
name|make_range
argument_list|(
name|Children
operator|.
name|begin
argument_list|()
argument_list|,
name|Children
operator|.
name|end
argument_list|()
argument_list|)
return|;
block|}
name|const_child_range
name|children
argument_list|()
specifier|const
block|{
return|return
name|make_range
argument_list|(
name|Children
operator|.
name|begin
argument_list|()
argument_list|,
name|Children
operator|.
name|end
argument_list|()
argument_list|)
return|;
block|}
name|DIE
operator|*
name|getParent
argument_list|()
specifier|const
block|;
comment|/// Generate the abbreviation for this DIE.
comment|///
comment|/// Calculate the abbreviation for this, which should be uniqued and
comment|/// eventually used to call \a setAbbrevNumber().
name|DIEAbbrev
name|generateAbbrev
argument_list|()
specifier|const
block|;
comment|/// Set the abbreviation number for this DIE.
name|void
name|setAbbrevNumber
argument_list|(
argument|unsigned I
argument_list|)
block|{
name|AbbrevNumber
operator|=
name|I
block|; }
comment|/// Get the absolute offset within the .debug_info or .debug_types section
comment|/// for this DIE.
name|unsigned
name|getDebugSectionOffset
argument_list|()
specifier|const
block|;
comment|/// Compute the offset of this DIE and all its children.
comment|///
comment|/// This function gets called just before we are going to generate the debug
comment|/// information and gives each DIE a chance to figure out its CU relative DIE
comment|/// offset, unique its abbreviation and fill in the abbreviation code, and
comment|/// return the unit offset that points to where the next DIE will be emitted
comment|/// within the debug unit section. After this function has been called for all
comment|/// DIE objects, the DWARF can be generated since all DIEs will be able to
comment|/// properly refer to other DIE objects since all DIEs have calculated their
comment|/// offsets.
comment|///
comment|/// \param AP AsmPrinter to use when calculating sizes.
comment|/// \param AbbrevSet the abbreviation used to unique DIE abbreviations.
comment|/// \param CUOffset the compile/type unit relative offset in bytes.
comment|/// \returns the offset for the DIE that follows this DIE within the
comment|/// current compile/type unit.
name|unsigned
name|computeOffsetsAndAbbrevs
argument_list|(
argument|const AsmPrinter *AP
argument_list|,
argument|DIEAbbrevSet&AbbrevSet
argument_list|,
argument|unsigned CUOffset
argument_list|)
block|;
comment|/// Climb up the parent chain to get the compile unit or type unit DIE that
comment|/// this DIE belongs to.
comment|///
comment|/// \returns the compile or type unit DIE that owns this DIE, or NULL if
comment|/// this DIE hasn't been added to a unit DIE.
specifier|const
name|DIE
operator|*
name|getUnitDie
argument_list|()
specifier|const
block|;
comment|/// Climb up the parent chain to get the compile unit or type unit that this
comment|/// DIE belongs to.
comment|///
comment|/// \returns the DIEUnit that represents the compile or type unit that owns
comment|/// this DIE, or NULL if this DIE hasn't been added to a unit DIE.
specifier|const
name|DIEUnit
operator|*
name|getUnit
argument_list|()
specifier|const
block|;
name|void
name|setOffset
argument_list|(
argument|unsigned O
argument_list|)
block|{
name|Offset
operator|=
name|O
block|; }
name|void
name|setSize
argument_list|(
argument|unsigned S
argument_list|)
block|{
name|Size
operator|=
name|S
block|; }
comment|/// Add a child to the DIE.
name|DIE
operator|&
name|addChild
argument_list|(
argument|DIE *Child
argument_list|)
block|{
name|assert
argument_list|(
operator|!
name|Child
operator|->
name|getParent
argument_list|()
operator|&&
literal|"Child should be orphaned"
argument_list|)
block|;
name|Child
operator|->
name|Owner
operator|=
name|this
block|;
name|Children
operator|.
name|push_back
argument_list|(
operator|*
name|Child
argument_list|)
block|;
return|return
name|Children
operator|.
name|back
argument_list|()
return|;
block|}
comment|/// Find a value in the DIE with the attribute given.
comment|///
comment|/// Returns a default-constructed DIEValue (where \a DIEValue::getType()
comment|/// gives \a DIEValue::isNone) if no such attribute exists.
name|DIEValue
name|findAttribute
argument_list|(
argument|dwarf::Attribute Attribute
argument_list|)
specifier|const
block|;
name|void
name|print
argument_list|(
argument|raw_ostream&O
argument_list|,
argument|unsigned IndentCount =
literal|0
argument_list|)
specifier|const
block|;
name|void
name|dump
argument_list|()
block|; }
block|;
comment|//===--------------------------------------------------------------------===//
comment|/// Represents a compile or type unit.
name|class
name|DIEUnit
block|{
comment|/// The compile unit or type unit DIE. This variable must be an instance of
comment|/// DIE so that we can calculate the DIEUnit from any DIE by traversing the
comment|/// parent backchain and getting the Unit DIE, and then casting itself to a
comment|/// DIEUnit. This allows us to be able to find the DIEUnit for any DIE without
comment|/// having to store a pointer to the DIEUnit in each DIE instance.
name|DIE
name|Die
block|;
comment|/// The section this unit will be emitted in. This may or may not be set to
comment|/// a valid section depending on the client that is emitting DWARF.
name|MCSection
operator|*
name|Section
block|;
name|uint64_t
name|Offset
block|;
comment|/// .debug_info or .debug_types absolute section offset.
name|uint32_t
name|Length
block|;
comment|/// The length in bytes of all of the DIEs in this unit.
specifier|const
name|uint16_t
name|Version
block|;
comment|/// The Dwarf version number for this unit.
specifier|const
name|uint8_t
name|AddrSize
block|;
comment|/// The size in bytes of an address for this unit.
name|protected
operator|:
operator|~
name|DIEUnit
argument_list|()
operator|=
expr|default
block|;
name|public
operator|:
name|DIEUnit
argument_list|(
argument|uint16_t Version
argument_list|,
argument|uint8_t AddrSize
argument_list|,
argument|dwarf::Tag UnitTag
argument_list|)
block|;
name|DIEUnit
argument_list|(
specifier|const
name|DIEUnit
operator|&
name|RHS
argument_list|)
operator|=
name|delete
block|;
name|DIEUnit
argument_list|(
name|DIEUnit
operator|&&
name|RHS
argument_list|)
operator|=
name|delete
block|;
name|void
name|operator
operator|=
operator|(
specifier|const
name|DIEUnit
operator|&
name|RHS
operator|)
operator|=
name|delete
block|;
name|void
name|operator
operator|=
operator|(
specifier|const
name|DIEUnit
operator|&&
name|RHS
operator|)
operator|=
name|delete
block|;
comment|/// Set the section that this DIEUnit will be emitted into.
comment|///
comment|/// This function is used by some clients to set the section. Not all clients
comment|/// that emit DWARF use this section variable.
name|void
name|setSection
argument_list|(
argument|MCSection *Section
argument_list|)
block|{
name|assert
argument_list|(
operator|!
name|this
operator|->
name|Section
argument_list|)
block|;
name|this
operator|->
name|Section
operator|=
name|Section
block|;   }
name|virtual
specifier|const
name|MCSymbol
operator|*
name|getCrossSectionRelativeBaseAddress
argument_list|()
specifier|const
block|{
return|return
name|nullptr
return|;
block|}
comment|/// Return the section that this DIEUnit will be emitted into.
comment|///
comment|/// \returns Section pointer which can be NULL.
name|MCSection
operator|*
name|getSection
argument_list|()
specifier|const
block|{
return|return
name|Section
return|;
block|}
name|void
name|setDebugSectionOffset
argument_list|(
argument|unsigned O
argument_list|)
block|{
name|Offset
operator|=
name|O
block|; }
name|unsigned
name|getDebugSectionOffset
argument_list|()
specifier|const
block|{
return|return
name|Offset
return|;
block|}
name|void
name|setLength
argument_list|(
argument|uint64_t L
argument_list|)
block|{
name|Length
operator|=
name|L
block|; }
name|uint64_t
name|getLength
argument_list|()
specifier|const
block|{
return|return
name|Length
return|;
block|}
name|uint16_t
name|getDwarfVersion
argument_list|()
specifier|const
block|{
return|return
name|Version
return|;
block|}
name|uint16_t
name|getAddressSize
argument_list|()
specifier|const
block|{
return|return
name|AddrSize
return|;
block|}
name|DIE
operator|&
name|getUnitDie
argument_list|()
block|{
return|return
name|Die
return|;
block|}
specifier|const
name|DIE
operator|&
name|getUnitDie
argument_list|()
specifier|const
block|{
return|return
name|Die
return|;
block|}
expr|}
block|;  struct
name|BasicDIEUnit
name|final
operator|:
name|DIEUnit
block|{
name|BasicDIEUnit
argument_list|(
argument|uint16_t Version
argument_list|,
argument|uint8_t AddrSize
argument_list|,
argument|dwarf::Tag UnitTag
argument_list|)
operator|:
name|DIEUnit
argument_list|(
argument|Version
argument_list|,
argument|AddrSize
argument_list|,
argument|UnitTag
argument_list|)
block|{}
block|}
block|;
comment|//===--------------------------------------------------------------------===//
comment|/// DIELoc - Represents an expression location.
comment|//
name|class
name|DIELoc
operator|:
name|public
name|DIEValueList
block|{
name|mutable
name|unsigned
name|Size
operator|=
literal|0
block|;
comment|// Size in bytes excluding size header.
name|public
operator|:
name|DIELoc
argument_list|()
operator|=
expr|default
block|;
comment|/// ComputeSize - Calculate the size of the location expression.
comment|///
name|unsigned
name|ComputeSize
argument_list|(
argument|const AsmPrinter *AP
argument_list|)
specifier|const
block|;
comment|/// BestForm - Choose the best form for data.
comment|///
name|dwarf
operator|::
name|Form
name|BestForm
argument_list|(
argument|unsigned DwarfVersion
argument_list|)
specifier|const
block|{
if|if
condition|(
name|DwarfVersion
operator|>
literal|3
condition|)
return|return
name|dwarf
operator|::
name|DW_FORM_exprloc
return|;
comment|// Pre-DWARF4 location expressions were blocks and not exprloc.
if|if
condition|(
operator|(
name|unsigned
name|char
operator|)
name|Size
operator|==
name|Size
condition|)
return|return
name|dwarf
operator|::
name|DW_FORM_block1
return|;
if|if
condition|(
operator|(
name|unsigned
name|short
operator|)
name|Size
operator|==
name|Size
condition|)
return|return
name|dwarf
operator|::
name|DW_FORM_block2
return|;
if|if
condition|(
operator|(
name|unsigned
name|int
operator|)
name|Size
operator|==
name|Size
condition|)
return|return
name|dwarf
operator|::
name|DW_FORM_block4
return|;
return|return
name|dwarf
operator|::
name|DW_FORM_block
return|;
block|}
name|void
name|EmitValue
argument_list|(
argument|const AsmPrinter *AP
argument_list|,
argument|dwarf::Form Form
argument_list|)
specifier|const
block|;
name|unsigned
name|SizeOf
argument_list|(
argument|const AsmPrinter *AP
argument_list|,
argument|dwarf::Form Form
argument_list|)
specifier|const
block|;
name|void
name|print
argument_list|(
argument|raw_ostream&O
argument_list|)
specifier|const
block|; }
block|;
comment|//===--------------------------------------------------------------------===//
comment|/// DIEBlock - Represents a block of values.
comment|//
name|class
name|DIEBlock
operator|:
name|public
name|DIEValueList
block|{
name|mutable
name|unsigned
name|Size
operator|=
literal|0
block|;
comment|// Size in bytes excluding size header.
name|public
operator|:
name|DIEBlock
argument_list|()
operator|=
expr|default
block|;
comment|/// ComputeSize - Calculate the size of the location expression.
comment|///
name|unsigned
name|ComputeSize
argument_list|(
argument|const AsmPrinter *AP
argument_list|)
specifier|const
block|;
comment|/// BestForm - Choose the best form for data.
comment|///
name|dwarf
operator|::
name|Form
name|BestForm
argument_list|()
specifier|const
block|{
if|if
condition|(
operator|(
name|unsigned
name|char
operator|)
name|Size
operator|==
name|Size
condition|)
return|return
name|dwarf
operator|::
name|DW_FORM_block1
return|;
if|if
condition|(
operator|(
name|unsigned
name|short
operator|)
name|Size
operator|==
name|Size
condition|)
return|return
name|dwarf
operator|::
name|DW_FORM_block2
return|;
if|if
condition|(
operator|(
name|unsigned
name|int
operator|)
name|Size
operator|==
name|Size
condition|)
return|return
name|dwarf
operator|::
name|DW_FORM_block4
return|;
return|return
name|dwarf
operator|::
name|DW_FORM_block
return|;
block|}
name|void
name|EmitValue
argument_list|(
argument|const AsmPrinter *AP
argument_list|,
argument|dwarf::Form Form
argument_list|)
specifier|const
block|;
name|unsigned
name|SizeOf
argument_list|(
argument|const AsmPrinter *AP
argument_list|,
argument|dwarf::Form Form
argument_list|)
specifier|const
block|;
name|void
name|print
argument_list|(
argument|raw_ostream&O
argument_list|)
specifier|const
block|; }
expr_stmt|;
block|}
end_decl_stmt

begin_comment
comment|// end namespace llvm
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|// LLVM_LIB_CODEGEN_ASMPRINTER_DIE_H
end_comment

end_unit

