begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===- llvm/CodeGen/SlotIndexes.h - Slot indexes representation -*- C++ -*-===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file implements SlotIndex and related classes. The purpuse of SlotIndex
end_comment

begin_comment
comment|// is to describe a position at which a register can become live, or cease to
end_comment

begin_comment
comment|// be live.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// SlotIndex is mostly a proxy for entries of the SlotIndexList, a class which
end_comment

begin_comment
comment|// is held is LiveIntervals and provides the real numbering. This allows
end_comment

begin_comment
comment|// LiveIntervals to perform largely transparent renumbering. The SlotIndex
end_comment

begin_comment
comment|// class does hold a PHI bit, which determines whether the index relates to a
end_comment

begin_comment
comment|// PHI use or def point, or an actual instruction. See the SlotIndex class
end_comment

begin_comment
comment|// description for futher information.
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LLVM_CODEGEN_SLOTINDEXES_H
end_ifndef

begin_define
define|#
directive|define
name|LLVM_CODEGEN_SLOTINDEXES_H
end_define

begin_include
include|#
directive|include
file|"llvm/ADT/PointerIntPair.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/SmallVector.h"
end_include

begin_include
include|#
directive|include
file|"llvm/CodeGen/MachineBasicBlock.h"
end_include

begin_include
include|#
directive|include
file|"llvm/CodeGen/MachineFunctionPass.h"
end_include

begin_include
include|#
directive|include
file|"llvm/CodeGen/MachineInstr.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/Allocator.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/ErrorHandling.h"
end_include

begin_decl_stmt
name|namespace
name|llvm
block|{
comment|/// This class represents an entry in the slot index list held in the
comment|/// SlotIndexes pass. It should not be used directly. See the
comment|/// SlotIndex& SlotIndexes classes for the public interface to this
comment|/// information.
name|class
name|IndexListEntry
block|{
name|private
label|:
specifier|static
specifier|const
name|unsigned
name|EMPTY_KEY_INDEX
init|=
operator|~
literal|0U
operator|&
operator|~
literal|3U
decl_stmt|,
name|TOMBSTONE_KEY_INDEX
init|=
operator|~
literal|0U
operator|&
operator|~
literal|7U
decl_stmt|;
name|IndexListEntry
modifier|*
name|next
decl_stmt|,
modifier|*
name|prev
decl_stmt|;
name|MachineInstr
modifier|*
name|mi
decl_stmt|;
name|unsigned
name|index
decl_stmt|;
name|protected
label|:
typedef|typedef
enum|enum
block|{
name|EMPTY_KEY
block|,
name|TOMBSTONE_KEY
block|}
name|ReservedEntryType
typedef|;
comment|// This constructor is only to be used by getEmptyKeyEntry
comment|//& getTombstoneKeyEntry. It sets index to the given
comment|// value and mi to zero.
name|IndexListEntry
argument_list|(
argument|ReservedEntryType r
argument_list|)
block|:
name|mi
argument_list|(
literal|0
argument_list|)
block|{
switch|switch
condition|(
name|r
condition|)
block|{
case|case
name|EMPTY_KEY
case|:
name|index
operator|=
name|EMPTY_KEY_INDEX
expr_stmt|;
break|break;
case|case
name|TOMBSTONE_KEY
case|:
name|index
operator|=
name|TOMBSTONE_KEY_INDEX
expr_stmt|;
break|break;
default|default:
name|assert
argument_list|(
name|false
operator|&&
literal|"Invalid value for constructor."
argument_list|)
expr_stmt|;
block|}
name|next
operator|=
name|this
expr_stmt|;
name|prev
operator|=
name|this
expr_stmt|;
block|}
name|public
label|:
name|IndexListEntry
argument_list|(
argument|MachineInstr *mi
argument_list|,
argument|unsigned index
argument_list|)
block|:
name|mi
argument_list|(
name|mi
argument_list|)
operator|,
name|index
argument_list|(
argument|index
argument_list|)
block|{
if|if
condition|(
name|index
operator|==
name|EMPTY_KEY_INDEX
operator|||
name|index
operator|==
name|TOMBSTONE_KEY_INDEX
condition|)
block|{
name|llvm_report_error
argument_list|(
literal|"Attempt to create invalid index. "
literal|"Available indexes may have been exhausted?."
argument_list|)
expr_stmt|;
block|}
block|}
name|MachineInstr
operator|*
name|getInstr
argument_list|()
specifier|const
block|{
return|return
name|mi
return|;
block|}
name|void
name|setInstr
parameter_list|(
name|MachineInstr
modifier|*
name|mi
parameter_list|)
block|{
name|assert
argument_list|(
name|index
operator|!=
name|EMPTY_KEY_INDEX
operator|&&
name|index
operator|!=
name|TOMBSTONE_KEY_INDEX
operator|&&
literal|"Attempt to modify reserved index."
argument_list|)
expr_stmt|;
name|this
operator|->
name|mi
operator|=
name|mi
expr_stmt|;
block|}
name|unsigned
name|getIndex
argument_list|()
specifier|const
block|{
return|return
name|index
return|;
block|}
name|void
name|setIndex
parameter_list|(
name|unsigned
name|index
parameter_list|)
block|{
name|assert
argument_list|(
name|index
operator|!=
name|EMPTY_KEY_INDEX
operator|&&
name|index
operator|!=
name|TOMBSTONE_KEY_INDEX
operator|&&
literal|"Attempt to set index to invalid value."
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|this
operator|->
name|index
operator|!=
name|EMPTY_KEY_INDEX
operator|&&
name|this
operator|->
name|index
operator|!=
name|TOMBSTONE_KEY_INDEX
operator|&&
literal|"Attempt to reset reserved index value."
argument_list|)
expr_stmt|;
name|this
operator|->
name|index
operator|=
name|index
expr_stmt|;
block|}
name|IndexListEntry
modifier|*
name|getNext
parameter_list|()
block|{
return|return
name|next
return|;
block|}
specifier|const
name|IndexListEntry
operator|*
name|getNext
argument_list|()
specifier|const
block|{
return|return
name|next
return|;
block|}
name|void
name|setNext
parameter_list|(
name|IndexListEntry
modifier|*
name|next
parameter_list|)
block|{
name|assert
argument_list|(
name|index
operator|!=
name|EMPTY_KEY_INDEX
operator|&&
name|index
operator|!=
name|TOMBSTONE_KEY_INDEX
operator|&&
literal|"Attempt to modify reserved index."
argument_list|)
expr_stmt|;
name|this
operator|->
name|next
operator|=
name|next
expr_stmt|;
block|}
name|IndexListEntry
modifier|*
name|getPrev
parameter_list|()
block|{
return|return
name|prev
return|;
block|}
specifier|const
name|IndexListEntry
operator|*
name|getPrev
argument_list|()
specifier|const
block|{
return|return
name|prev
return|;
block|}
name|void
name|setPrev
parameter_list|(
name|IndexListEntry
modifier|*
name|prev
parameter_list|)
block|{
name|assert
argument_list|(
name|index
operator|!=
name|EMPTY_KEY_INDEX
operator|&&
name|index
operator|!=
name|TOMBSTONE_KEY_INDEX
operator|&&
literal|"Attempt to modify reserved index."
argument_list|)
expr_stmt|;
name|this
operator|->
name|prev
operator|=
name|prev
expr_stmt|;
block|}
comment|// This function returns the index list entry that is to be used for empty
comment|// SlotIndex keys.
specifier|static
name|IndexListEntry
modifier|*
name|getEmptyKeyEntry
parameter_list|()
function_decl|;
comment|// This function returns the index list entry that is to be used for
comment|// tombstone SlotIndex keys.
specifier|static
name|IndexListEntry
modifier|*
name|getTombstoneKeyEntry
parameter_list|()
function_decl|;
block|}
empty_stmt|;
comment|// Specialize PointerLikeTypeTraits for IndexListEntry.
name|template
operator|<
operator|>
name|class
name|PointerLikeTypeTraits
operator|<
name|IndexListEntry
operator|*
operator|>
block|{
name|public
operator|:
specifier|static
specifier|inline
name|void
operator|*
name|getAsVoidPointer
argument_list|(
argument|IndexListEntry *p
argument_list|)
block|{
return|return
name|p
return|;
block|}
specifier|static
specifier|inline
name|IndexListEntry
operator|*
name|getFromVoidPointer
argument_list|(
argument|void *p
argument_list|)
block|{
return|return
name|static_cast
operator|<
name|IndexListEntry
operator|*
operator|>
operator|(
name|p
operator|)
return|;
block|}
expr|enum
block|{
name|NumLowBitsAvailable
operator|=
literal|3
block|}
block|;   }
expr_stmt|;
comment|/// SlotIndex - An opaque wrapper around machine indexes.
name|class
name|SlotIndex
block|{
name|friend
name|class
name|SlotIndexes
decl_stmt|;
name|friend
block|struct
name|DenseMapInfo
operator|<
name|SlotIndex
operator|>
expr_stmt|;
name|private
label|:
specifier|static
specifier|const
name|unsigned
name|PHI_BIT
init|=
literal|1
operator|<<
literal|2
decl_stmt|;
name|PointerIntPair
operator|<
name|IndexListEntry
operator|*
operator|,
literal|3
operator|,
name|unsigned
operator|>
name|lie
expr_stmt|;
name|SlotIndex
argument_list|(
argument|IndexListEntry *entry
argument_list|,
argument|unsigned phiAndSlot
argument_list|)
block|:
name|lie
argument_list|(
argument|entry
argument_list|,
argument|phiAndSlot
argument_list|)
block|{
name|assert
argument_list|(
name|entry
operator|!=
literal|0
operator|&&
literal|"Attempt to construct index with 0 pointer."
argument_list|)
expr_stmt|;
block|}
name|IndexListEntry
operator|&
name|entry
argument_list|()
specifier|const
block|{
return|return
operator|*
name|lie
operator|.
name|getPointer
argument_list|()
return|;
block|}
name|int
name|getIndex
argument_list|()
specifier|const
block|{
return|return
name|entry
argument_list|()
operator|.
name|getIndex
argument_list|()
operator||
name|getSlot
argument_list|()
return|;
block|}
specifier|static
specifier|inline
name|unsigned
name|getHashValue
parameter_list|(
specifier|const
name|SlotIndex
modifier|&
name|v
parameter_list|)
block|{
name|IndexListEntry
modifier|*
name|ptrVal
init|=
operator|&
name|v
operator|.
name|entry
argument_list|()
decl_stmt|;
return|return
operator|(
name|unsigned
argument_list|(
operator|(
name|intptr_t
operator|)
name|ptrVal
argument_list|)
operator|>>
literal|4
operator|)
operator|^
operator|(
name|unsigned
argument_list|(
operator|(
name|intptr_t
operator|)
name|ptrVal
argument_list|)
operator|>>
literal|9
operator|)
return|;
block|}
name|public
label|:
comment|// FIXME: Ugh. This is public because LiveIntervalAnalysis is still using it
comment|// for some spill weight stuff. Fix that, then make this private.
enum|enum
name|Slot
block|{
name|LOAD
block|,
name|USE
block|,
name|DEF
block|,
name|STORE
block|,
name|NUM
block|}
enum|;
specifier|static
specifier|inline
name|SlotIndex
name|getEmptyKey
parameter_list|()
block|{
return|return
name|SlotIndex
argument_list|(
name|IndexListEntry
operator|::
name|getEmptyKeyEntry
argument_list|()
argument_list|,
literal|0
argument_list|)
return|;
block|}
specifier|static
specifier|inline
name|SlotIndex
name|getTombstoneKey
parameter_list|()
block|{
return|return
name|SlotIndex
argument_list|(
name|IndexListEntry
operator|::
name|getTombstoneKeyEntry
argument_list|()
argument_list|,
literal|0
argument_list|)
return|;
block|}
comment|/// Construct an invalid index.
name|SlotIndex
argument_list|()
operator|:
name|lie
argument_list|(
argument|IndexListEntry::getEmptyKeyEntry()
argument_list|,
literal|0
argument_list|)
block|{}
comment|// Construct a new slot index from the given one, set the phi flag on the
comment|// new index to the value of the phi parameter.
name|SlotIndex
argument_list|(
argument|const SlotIndex&li
argument_list|,
argument|bool phi
argument_list|)
operator|:
name|lie
argument_list|(
argument|&li.entry()
argument_list|,
argument|phi ? PHI_BIT | li.getSlot() : (unsigned)li.getSlot()
argument_list|)
block|{
name|assert
argument_list|(
name|lie
operator|.
name|getPointer
argument_list|()
operator|!=
literal|0
operator|&&
literal|"Attempt to construct index with 0 pointer."
argument_list|)
block|;     }
comment|// Construct a new slot index from the given one, set the phi flag on the
comment|// new index to the value of the phi parameter, and the slot to the new slot.
name|SlotIndex
argument_list|(
argument|const SlotIndex&li
argument_list|,
argument|bool phi
argument_list|,
argument|Slot s
argument_list|)
operator|:
name|lie
argument_list|(
argument|&li.entry()
argument_list|,
argument|phi ? PHI_BIT | s : (unsigned)s
argument_list|)
block|{
name|assert
argument_list|(
name|lie
operator|.
name|getPointer
argument_list|()
operator|!=
literal|0
operator|&&
literal|"Attempt to construct index with 0 pointer."
argument_list|)
block|;     }
comment|/// Returns true if this is a valid index. Invalid indicies do
comment|/// not point into an index table, and cannot be compared.
name|bool
name|isValid
argument_list|()
specifier|const
block|{
return|return
operator|(
name|lie
operator|.
name|getPointer
argument_list|()
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|lie
operator|.
name|getPointer
argument_list|()
operator|->
name|getIndex
argument_list|()
operator|!=
literal|0
operator|)
return|;
block|}
comment|/// Print this index to the given raw_ostream.
name|void
name|print
argument_list|(
name|raw_ostream
operator|&
name|os
argument_list|)
decl|const
decl_stmt|;
comment|/// Dump this index to stderr.
name|void
name|dump
argument_list|()
specifier|const
expr_stmt|;
comment|/// Compare two SlotIndex objects for equality.
name|bool
name|operator
operator|==
operator|(
name|SlotIndex
name|other
operator|)
specifier|const
block|{
return|return
name|getIndex
argument_list|()
operator|==
name|other
operator|.
name|getIndex
argument_list|()
return|;
block|}
comment|/// Compare two SlotIndex objects for inequality.
name|bool
name|operator
operator|!=
operator|(
name|SlotIndex
name|other
operator|)
specifier|const
block|{
return|return
name|getIndex
argument_list|()
operator|!=
name|other
operator|.
name|getIndex
argument_list|()
return|;
block|}
comment|/// Compare two SlotIndex objects. Return true if the first index
comment|/// is strictly lower than the second.
name|bool
name|operator
operator|<
operator|(
name|SlotIndex
name|other
operator|)
specifier|const
block|{
return|return
name|getIndex
argument_list|()
operator|<
name|other
operator|.
name|getIndex
argument_list|()
return|;
block|}
comment|/// Compare two SlotIndex objects. Return true if the first index
comment|/// is lower than, or equal to, the second.
name|bool
name|operator
operator|<=
operator|(
name|SlotIndex
name|other
operator|)
specifier|const
block|{
return|return
name|getIndex
argument_list|()
operator|<=
name|other
operator|.
name|getIndex
argument_list|()
return|;
block|}
comment|/// Compare two SlotIndex objects. Return true if the first index
comment|/// is greater than the second.
name|bool
name|operator
operator|>
operator|(
name|SlotIndex
name|other
operator|)
specifier|const
block|{
return|return
name|getIndex
argument_list|()
operator|>
name|other
operator|.
name|getIndex
argument_list|()
return|;
block|}
comment|/// Compare two SlotIndex objects. Return true if the first index
comment|/// is greater than, or equal to, the second.
name|bool
name|operator
operator|>=
operator|(
name|SlotIndex
name|other
operator|)
specifier|const
block|{
return|return
name|getIndex
argument_list|()
operator|>=
name|other
operator|.
name|getIndex
argument_list|()
return|;
block|}
comment|/// Return the distance from this index to the given one.
name|int
name|distance
argument_list|(
name|SlotIndex
name|other
argument_list|)
decl|const
block|{
return|return
name|other
operator|.
name|getIndex
argument_list|()
operator|-
name|getIndex
argument_list|()
return|;
block|}
comment|/// Returns the slot for this SlotIndex.
name|Slot
name|getSlot
argument_list|()
specifier|const
block|{
return|return
name|static_cast
operator|<
name|Slot
operator|>
operator|(
name|lie
operator|.
name|getInt
argument_list|()
operator|&
operator|~
name|PHI_BIT
operator|)
return|;
block|}
comment|/// Returns the state of the PHI bit.
name|bool
name|isPHI
argument_list|()
specifier|const
block|{
return|return
name|lie
operator|.
name|getInt
argument_list|()
operator|&
name|PHI_BIT
return|;
block|}
comment|/// Returns the base index for associated with this index. The base index
comment|/// is the one associated with the LOAD slot for the instruction pointed to
comment|/// by this index.
name|SlotIndex
name|getBaseIndex
argument_list|()
specifier|const
block|{
return|return
name|getLoadIndex
argument_list|()
return|;
block|}
comment|/// Returns the boundary index for associated with this index. The boundary
comment|/// index is the one associated with the LOAD slot for the instruction
comment|/// pointed to by this index.
name|SlotIndex
name|getBoundaryIndex
argument_list|()
specifier|const
block|{
return|return
name|getStoreIndex
argument_list|()
return|;
block|}
comment|/// Returns the index of the LOAD slot for the instruction pointed to by
comment|/// this index.
name|SlotIndex
name|getLoadIndex
argument_list|()
specifier|const
block|{
return|return
name|SlotIndex
argument_list|(
operator|&
name|entry
argument_list|()
argument_list|,
name|SlotIndex
operator|::
name|LOAD
argument_list|)
return|;
block|}
comment|/// Returns the index of the USE slot for the instruction pointed to by
comment|/// this index.
name|SlotIndex
name|getUseIndex
argument_list|()
specifier|const
block|{
return|return
name|SlotIndex
argument_list|(
operator|&
name|entry
argument_list|()
argument_list|,
name|SlotIndex
operator|::
name|USE
argument_list|)
return|;
block|}
comment|/// Returns the index of the DEF slot for the instruction pointed to by
comment|/// this index.
name|SlotIndex
name|getDefIndex
argument_list|()
specifier|const
block|{
return|return
name|SlotIndex
argument_list|(
operator|&
name|entry
argument_list|()
argument_list|,
name|SlotIndex
operator|::
name|DEF
argument_list|)
return|;
block|}
comment|/// Returns the index of the STORE slot for the instruction pointed to by
comment|/// this index.
name|SlotIndex
name|getStoreIndex
argument_list|()
specifier|const
block|{
return|return
name|SlotIndex
argument_list|(
operator|&
name|entry
argument_list|()
argument_list|,
name|SlotIndex
operator|::
name|STORE
argument_list|)
return|;
block|}
comment|/// Returns the next slot in the index list. This could be either the
comment|/// next slot for the instruction pointed to by this index or, if this
comment|/// index is a STORE, the first slot for the next instruction.
comment|/// WARNING: This method is considerably more expensive than the methods
comment|/// that return specific slots (getUseIndex(), etc). If you can - please
comment|/// use one of those methods.
name|SlotIndex
name|getNextSlot
argument_list|()
specifier|const
block|{
name|Slot
name|s
operator|=
name|getSlot
argument_list|()
block|;
if|if
condition|(
name|s
operator|==
name|SlotIndex
operator|::
name|STORE
condition|)
block|{
return|return
name|SlotIndex
argument_list|(
name|entry
argument_list|()
operator|.
name|getNext
argument_list|()
argument_list|,
name|SlotIndex
operator|::
name|LOAD
argument_list|)
return|;
block|}
return|return
name|SlotIndex
argument_list|(
operator|&
name|entry
argument_list|()
argument_list|,
name|s
operator|+
literal|1
argument_list|)
return|;
block|}
comment|/// Returns the next index. This is the index corresponding to the this
comment|/// index's slot, but for the next instruction.
name|SlotIndex
name|getNextIndex
argument_list|()
specifier|const
block|{
return|return
name|SlotIndex
argument_list|(
name|entry
argument_list|()
operator|.
name|getNext
argument_list|()
argument_list|,
name|getSlot
argument_list|()
argument_list|)
return|;
block|}
comment|/// Returns the previous slot in the index list. This could be either the
comment|/// previous slot for the instruction pointed to by this index or, if this
comment|/// index is a LOAD, the last slot for the previous instruction.
comment|/// WARNING: This method is considerably more expensive than the methods
comment|/// that return specific slots (getUseIndex(), etc). If you can - please
comment|/// use one of those methods.
name|SlotIndex
name|getPrevSlot
argument_list|()
specifier|const
block|{
name|Slot
name|s
operator|=
name|getSlot
argument_list|()
block|;
if|if
condition|(
name|s
operator|==
name|SlotIndex
operator|::
name|LOAD
condition|)
block|{
return|return
name|SlotIndex
argument_list|(
name|entry
argument_list|()
operator|.
name|getPrev
argument_list|()
argument_list|,
name|SlotIndex
operator|::
name|STORE
argument_list|)
return|;
block|}
return|return
name|SlotIndex
argument_list|(
operator|&
name|entry
argument_list|()
argument_list|,
name|s
operator|-
literal|1
argument_list|)
return|;
block|}
comment|/// Returns the previous index. This is the index corresponding to this
comment|/// index's slot, but for the previous instruction.
name|SlotIndex
name|getPrevIndex
argument_list|()
specifier|const
block|{
return|return
name|SlotIndex
argument_list|(
name|entry
argument_list|()
operator|.
name|getPrev
argument_list|()
argument_list|,
name|getSlot
argument_list|()
argument_list|)
return|;
block|}
block|}
empty_stmt|;
comment|/// DenseMapInfo specialization for SlotIndex.
name|template
operator|<
operator|>
expr|struct
name|DenseMapInfo
operator|<
name|SlotIndex
operator|>
block|{
specifier|static
specifier|inline
name|SlotIndex
name|getEmptyKey
argument_list|()
block|{
return|return
name|SlotIndex
operator|::
name|getEmptyKey
argument_list|()
return|;
block|}
specifier|static
specifier|inline
name|SlotIndex
name|getTombstoneKey
argument_list|()
block|{
return|return
name|SlotIndex
operator|::
name|getTombstoneKey
argument_list|()
return|;
block|}
specifier|static
specifier|inline
name|unsigned
name|getHashValue
argument_list|(
argument|const SlotIndex&v
argument_list|)
block|{
return|return
name|SlotIndex
operator|::
name|getHashValue
argument_list|(
name|v
argument_list|)
return|;
block|}
specifier|static
specifier|inline
name|bool
name|isEqual
argument_list|(
argument|const SlotIndex&LHS
argument_list|,
argument|const SlotIndex&RHS
argument_list|)
block|{
return|return
operator|(
name|LHS
operator|==
name|RHS
operator|)
return|;
block|}
expr|}
block|;
name|template
operator|<
operator|>
expr|struct
name|isPodLike
operator|<
name|SlotIndex
operator|>
block|{
specifier|static
specifier|const
name|bool
name|value
operator|=
name|true
block|; }
block|;
specifier|inline
name|raw_ostream
operator|&
name|operator
operator|<<
operator|(
name|raw_ostream
operator|&
name|os
operator|,
name|SlotIndex
name|li
operator|)
block|{
name|li
operator|.
name|print
argument_list|(
name|os
argument_list|)
block|;
return|return
name|os
return|;
block|}
typedef|typedef
name|std
operator|::
name|pair
operator|<
name|SlotIndex
operator|,
name|MachineBasicBlock
operator|*
operator|>
name|IdxMBBPair
expr_stmt|;
specifier|inline
name|bool
name|operator
operator|<
operator|(
name|SlotIndex
name|V
operator|,
specifier|const
name|IdxMBBPair
operator|&
name|IM
operator|)
block|{
return|return
name|V
operator|<
name|IM
operator|.
name|first
return|;
block|}
specifier|inline
name|bool
name|operator
operator|<
operator|(
specifier|const
name|IdxMBBPair
operator|&
name|IM
operator|,
name|SlotIndex
name|V
operator|)
block|{
return|return
name|IM
operator|.
name|first
operator|<
name|V
return|;
block|}
block|struct
name|Idx2MBBCompare
block|{
name|bool
name|operator
argument_list|()
operator|(
specifier|const
name|IdxMBBPair
operator|&
name|LHS
operator|,
specifier|const
name|IdxMBBPair
operator|&
name|RHS
operator|)
specifier|const
block|{
return|return
name|LHS
operator|.
name|first
operator|<
name|RHS
operator|.
name|first
return|;
block|}
expr|}
block|;
comment|/// SlotIndexes pass.
comment|///
comment|/// This pass assigns indexes to each instruction.
name|class
name|SlotIndexes
operator|:
name|public
name|MachineFunctionPass
block|{
name|private
operator|:
name|MachineFunction
operator|*
name|mf
block|;
name|IndexListEntry
operator|*
name|indexListHead
block|;
name|unsigned
name|functionSize
block|;
typedef|typedef
name|DenseMap
operator|<
specifier|const
name|MachineInstr
operator|*
operator|,
name|SlotIndex
operator|>
name|Mi2IndexMap
expr_stmt|;
name|Mi2IndexMap
name|mi2iMap
block|;
comment|/// MBB2IdxMap - The indexes of the first and last instructions in the
comment|/// specified basic block.
typedef|typedef
name|DenseMap
operator|<
specifier|const
name|MachineBasicBlock
operator|*
operator|,
name|std
operator|::
name|pair
operator|<
name|SlotIndex
operator|,
name|SlotIndex
operator|>
expr|>
name|MBB2IdxMap
expr_stmt|;
name|MBB2IdxMap
name|mbb2IdxMap
expr_stmt|;
comment|/// Idx2MBBMap - Sorted list of pairs of index of first instruction
comment|/// and MBB id.
name|std
operator|::
name|vector
operator|<
name|IdxMBBPair
operator|>
name|idx2MBBMap
expr_stmt|;
typedef|typedef
name|DenseMap
operator|<
specifier|const
name|MachineBasicBlock
operator|*
operator|,
name|SlotIndex
operator|>
name|TerminatorGapsMap
expr_stmt|;
name|TerminatorGapsMap
name|terminatorGaps
decl_stmt|;
comment|// IndexListEntry allocator.
name|BumpPtrAllocator
name|ileAllocator
decl_stmt|;
name|IndexListEntry
modifier|*
name|createEntry
parameter_list|(
name|MachineInstr
modifier|*
name|mi
parameter_list|,
name|unsigned
name|index
parameter_list|)
block|{
name|IndexListEntry
modifier|*
name|entry
init|=
name|static_cast
operator|<
name|IndexListEntry
operator|*
operator|>
operator|(
name|ileAllocator
operator|.
name|Allocate
argument_list|(
sizeof|sizeof
argument_list|(
name|IndexListEntry
argument_list|)
argument_list|,
name|alignof
operator|<
name|IndexListEntry
operator|>
operator|(
operator|)
argument_list|)
operator|)
decl_stmt|;
name|new
argument_list|(
argument|entry
argument_list|)
name|IndexListEntry
argument_list|(
name|mi
argument_list|,
name|index
argument_list|)
expr_stmt|;
return|return
name|entry
return|;
block|}
name|void
name|initList
parameter_list|()
block|{
name|assert
argument_list|(
name|indexListHead
operator|==
literal|0
operator|&&
literal|"Zero entry non-null at initialisation."
argument_list|)
expr_stmt|;
name|indexListHead
operator|=
name|createEntry
argument_list|(
literal|0
argument_list|,
operator|~
literal|0U
argument_list|)
expr_stmt|;
name|indexListHead
operator|->
name|setNext
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|indexListHead
operator|->
name|setPrev
argument_list|(
name|indexListHead
argument_list|)
expr_stmt|;
block|}
name|void
name|clearList
parameter_list|()
block|{
name|indexListHead
operator|=
literal|0
expr_stmt|;
name|ileAllocator
operator|.
name|Reset
argument_list|()
expr_stmt|;
block|}
name|IndexListEntry
modifier|*
name|getTail
parameter_list|()
block|{
name|assert
argument_list|(
name|indexListHead
operator|!=
literal|0
operator|&&
literal|"Call to getTail on uninitialized list."
argument_list|)
expr_stmt|;
return|return
name|indexListHead
operator|->
name|getPrev
argument_list|()
return|;
block|}
specifier|const
name|IndexListEntry
operator|*
name|getTail
argument_list|()
specifier|const
block|{
name|assert
argument_list|(
name|indexListHead
operator|!=
literal|0
operator|&&
literal|"Call to getTail on uninitialized list."
argument_list|)
block|;
return|return
name|indexListHead
operator|->
name|getPrev
argument_list|()
return|;
block|}
comment|// Returns true if the index list is empty.
name|bool
name|empty
argument_list|()
specifier|const
block|{
return|return
operator|(
name|indexListHead
operator|==
name|getTail
argument_list|()
operator|)
return|;
block|}
name|IndexListEntry
modifier|*
name|front
parameter_list|()
block|{
name|assert
argument_list|(
operator|!
name|empty
argument_list|()
operator|&&
literal|"front() called on empty index list."
argument_list|)
expr_stmt|;
return|return
name|indexListHead
return|;
block|}
specifier|const
name|IndexListEntry
operator|*
name|front
argument_list|()
specifier|const
block|{
name|assert
argument_list|(
operator|!
name|empty
argument_list|()
operator|&&
literal|"front() called on empty index list."
argument_list|)
block|;
return|return
name|indexListHead
return|;
block|}
name|IndexListEntry
modifier|*
name|back
parameter_list|()
block|{
name|assert
argument_list|(
operator|!
name|empty
argument_list|()
operator|&&
literal|"back() called on empty index list."
argument_list|)
expr_stmt|;
return|return
name|getTail
argument_list|()
operator|->
name|getPrev
argument_list|()
return|;
block|}
specifier|const
name|IndexListEntry
operator|*
name|back
argument_list|()
specifier|const
block|{
name|assert
argument_list|(
operator|!
name|empty
argument_list|()
operator|&&
literal|"back() called on empty index list."
argument_list|)
block|;
return|return
name|getTail
argument_list|()
operator|->
name|getPrev
argument_list|()
return|;
block|}
comment|/// Insert a new entry before itr.
name|void
name|insert
parameter_list|(
name|IndexListEntry
modifier|*
name|itr
parameter_list|,
name|IndexListEntry
modifier|*
name|val
parameter_list|)
block|{
name|assert
argument_list|(
name|itr
operator|!=
literal|0
operator|&&
literal|"itr should not be null."
argument_list|)
expr_stmt|;
name|IndexListEntry
modifier|*
name|prev
init|=
name|itr
operator|->
name|getPrev
argument_list|()
decl_stmt|;
name|val
operator|->
name|setNext
argument_list|(
name|itr
argument_list|)
expr_stmt|;
name|val
operator|->
name|setPrev
argument_list|(
name|prev
argument_list|)
expr_stmt|;
if|if
condition|(
name|itr
operator|!=
name|indexListHead
condition|)
block|{
name|prev
operator|->
name|setNext
argument_list|(
name|val
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|indexListHead
operator|=
name|val
expr_stmt|;
block|}
name|itr
operator|->
name|setPrev
argument_list|(
name|val
argument_list|)
expr_stmt|;
block|}
comment|/// Push a new entry on to the end of the list.
name|void
name|push_back
parameter_list|(
name|IndexListEntry
modifier|*
name|val
parameter_list|)
block|{
name|insert
argument_list|(
name|getTail
argument_list|()
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
name|public
label|:
specifier|static
name|char
name|ID
decl_stmt|;
name|SlotIndexes
argument_list|()
operator|:
name|MachineFunctionPass
argument_list|(
operator|&
name|ID
argument_list|)
operator|,
name|indexListHead
argument_list|(
literal|0
argument_list|)
block|{}
name|virtual
name|void
name|getAnalysisUsage
argument_list|(
argument|AnalysisUsage&au
argument_list|)
specifier|const
expr_stmt|;
name|virtual
name|void
name|releaseMemory
parameter_list|()
function_decl|;
name|virtual
name|bool
name|runOnMachineFunction
parameter_list|(
name|MachineFunction
modifier|&
name|fn
parameter_list|)
function_decl|;
comment|/// Dump the indexes.
name|void
name|dump
argument_list|()
specifier|const
expr_stmt|;
comment|/// Renumber the index list, providing space for new instructions.
name|void
name|renumberIndexes
parameter_list|()
function_decl|;
comment|/// Returns the zero index for this analysis.
name|SlotIndex
name|getZeroIndex
parameter_list|()
block|{
name|assert
argument_list|(
name|front
argument_list|()
operator|->
name|getIndex
argument_list|()
operator|==
literal|0
operator|&&
literal|"First index is not 0?"
argument_list|)
expr_stmt|;
return|return
name|SlotIndex
argument_list|(
name|front
argument_list|()
argument_list|,
literal|0
argument_list|)
return|;
block|}
comment|/// Returns the invalid index marker for this analysis.
name|SlotIndex
name|getInvalidIndex
parameter_list|()
block|{
return|return
name|getZeroIndex
argument_list|()
return|;
block|}
comment|/// Returns the distance between the highest and lowest indexes allocated
comment|/// so far.
name|unsigned
name|getIndexesLength
argument_list|()
specifier|const
block|{
name|assert
argument_list|(
name|front
argument_list|()
operator|->
name|getIndex
argument_list|()
operator|==
literal|0
operator|&&
literal|"Initial index isn't zero?"
argument_list|)
block|;
return|return
name|back
argument_list|()
operator|->
name|getIndex
argument_list|()
return|;
block|}
comment|/// Returns the number of instructions in the function.
name|unsigned
name|getFunctionSize
argument_list|()
specifier|const
block|{
return|return
name|functionSize
return|;
block|}
comment|/// Returns true if the given machine instr is mapped to an index,
comment|/// otherwise returns false.
name|bool
name|hasIndex
argument_list|(
specifier|const
name|MachineInstr
operator|*
name|instr
argument_list|)
decl|const
block|{
return|return
operator|(
name|mi2iMap
operator|.
name|find
argument_list|(
name|instr
argument_list|)
operator|!=
name|mi2iMap
operator|.
name|end
argument_list|()
operator|)
return|;
block|}
comment|/// Returns the base index for the given instruction.
name|SlotIndex
name|getInstructionIndex
argument_list|(
specifier|const
name|MachineInstr
operator|*
name|instr
argument_list|)
decl|const
block|{
name|Mi2IndexMap
operator|::
name|const_iterator
name|itr
operator|=
name|mi2iMap
operator|.
name|find
argument_list|(
name|instr
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|itr
operator|!=
name|mi2iMap
operator|.
name|end
argument_list|()
operator|&&
literal|"Instruction not found in maps."
argument_list|)
expr_stmt|;
return|return
name|itr
operator|->
name|second
return|;
block|}
comment|/// Returns the instruction for the given index, or null if the given
comment|/// index has no instruction associated with it.
name|MachineInstr
modifier|*
name|getInstructionFromIndex
argument_list|(
name|SlotIndex
name|index
argument_list|)
decl|const
block|{
return|return
name|index
operator|.
name|entry
argument_list|()
operator|.
name|getInstr
argument_list|()
return|;
block|}
comment|/// Returns the next non-null index.
name|SlotIndex
name|getNextNonNullIndex
parameter_list|(
name|SlotIndex
name|index
parameter_list|)
block|{
name|SlotIndex
name|nextNonNull
init|=
name|index
operator|.
name|getNextIndex
argument_list|()
decl_stmt|;
while|while
condition|(
operator|&
name|nextNonNull
operator|.
name|entry
argument_list|()
operator|!=
name|getTail
argument_list|()
operator|&&
name|getInstructionFromIndex
argument_list|(
name|nextNonNull
argument_list|)
operator|==
literal|0
condition|)
block|{
name|nextNonNull
operator|=
name|nextNonNull
operator|.
name|getNextIndex
argument_list|()
expr_stmt|;
block|}
return|return
name|nextNonNull
return|;
block|}
comment|/// Returns the first index in the given basic block.
name|SlotIndex
name|getMBBStartIdx
argument_list|(
specifier|const
name|MachineBasicBlock
operator|*
name|mbb
argument_list|)
decl|const
block|{
name|MBB2IdxMap
operator|::
name|const_iterator
name|itr
operator|=
name|mbb2IdxMap
operator|.
name|find
argument_list|(
name|mbb
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|itr
operator|!=
name|mbb2IdxMap
operator|.
name|end
argument_list|()
operator|&&
literal|"MBB not found in maps."
argument_list|)
expr_stmt|;
return|return
name|itr
operator|->
name|second
operator|.
name|first
return|;
block|}
comment|/// Returns the last index in the given basic block.
name|SlotIndex
name|getMBBEndIdx
argument_list|(
specifier|const
name|MachineBasicBlock
operator|*
name|mbb
argument_list|)
decl|const
block|{
name|MBB2IdxMap
operator|::
name|const_iterator
name|itr
operator|=
name|mbb2IdxMap
operator|.
name|find
argument_list|(
name|mbb
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|itr
operator|!=
name|mbb2IdxMap
operator|.
name|end
argument_list|()
operator|&&
literal|"MBB not found in maps."
argument_list|)
expr_stmt|;
return|return
name|itr
operator|->
name|second
operator|.
name|second
return|;
block|}
comment|/// Returns the terminator gap for the given index.
name|SlotIndex
name|getTerminatorGap
parameter_list|(
specifier|const
name|MachineBasicBlock
modifier|*
name|mbb
parameter_list|)
block|{
name|TerminatorGapsMap
operator|::
name|iterator
name|itr
operator|=
name|terminatorGaps
operator|.
name|find
argument_list|(
name|mbb
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|itr
operator|!=
name|terminatorGaps
operator|.
name|end
argument_list|()
operator|&&
literal|"All MBBs should have terminator gaps in their indexes."
argument_list|)
expr_stmt|;
return|return
name|itr
operator|->
name|second
return|;
block|}
comment|/// Returns the basic block which the given index falls in.
name|MachineBasicBlock
modifier|*
name|getMBBFromIndex
argument_list|(
name|SlotIndex
name|index
argument_list|)
decl|const
block|{
name|std
operator|::
name|vector
operator|<
name|IdxMBBPair
operator|>
operator|::
name|const_iterator
name|I
operator|=
name|std
operator|::
name|lower_bound
argument_list|(
name|idx2MBBMap
operator|.
name|begin
argument_list|()
argument_list|,
name|idx2MBBMap
operator|.
name|end
argument_list|()
argument_list|,
name|index
argument_list|)
expr_stmt|;
comment|// Take the pair containing the index
name|std
operator|::
name|vector
operator|<
name|IdxMBBPair
operator|>
operator|::
name|const_iterator
name|J
operator|=
operator|(
operator|(
name|I
operator|!=
name|idx2MBBMap
operator|.
name|end
argument_list|()
operator|&&
name|I
operator|->
name|first
operator|>
name|index
operator|)
operator|||
operator|(
name|I
operator|==
name|idx2MBBMap
operator|.
name|end
argument_list|()
operator|&&
name|idx2MBBMap
operator|.
name|size
argument_list|()
operator|>
literal|0
operator|)
operator|)
condition|?
operator|(
name|I
operator|-
literal|1
operator|)
else|:
name|I
expr_stmt|;
name|assert
argument_list|(
name|J
operator|!=
name|idx2MBBMap
operator|.
name|end
argument_list|()
operator|&&
name|J
operator|->
name|first
operator|<=
name|index
operator|&&
name|index
operator|<
name|getMBBEndIdx
argument_list|(
name|J
operator|->
name|second
argument_list|)
operator|&&
literal|"index does not correspond to an MBB"
argument_list|)
expr_stmt|;
return|return
name|J
operator|->
name|second
return|;
block|}
name|bool
name|findLiveInMBBs
argument_list|(
name|SlotIndex
name|start
argument_list|,
name|SlotIndex
name|end
argument_list|,
name|SmallVectorImpl
operator|<
name|MachineBasicBlock
operator|*
operator|>
operator|&
name|mbbs
argument_list|)
decl|const
block|{
name|std
operator|::
name|vector
operator|<
name|IdxMBBPair
operator|>
operator|::
name|const_iterator
name|itr
operator|=
name|std
operator|::
name|lower_bound
argument_list|(
name|idx2MBBMap
operator|.
name|begin
argument_list|()
argument_list|,
name|idx2MBBMap
operator|.
name|end
argument_list|()
argument_list|,
name|start
argument_list|)
expr_stmt|;
name|bool
name|resVal
init|=
name|false
decl_stmt|;
while|while
condition|(
name|itr
operator|!=
name|idx2MBBMap
operator|.
name|end
argument_list|()
condition|)
block|{
if|if
condition|(
name|itr
operator|->
name|first
operator|>=
name|end
condition|)
break|break;
name|mbbs
operator|.
name|push_back
argument_list|(
name|itr
operator|->
name|second
argument_list|)
expr_stmt|;
name|resVal
operator|=
name|true
expr_stmt|;
operator|++
name|itr
expr_stmt|;
block|}
return|return
name|resVal
return|;
block|}
comment|/// Return a list of MBBs that can be reach via any branches or
comment|/// fall-throughs.
name|bool
name|findReachableMBBs
argument_list|(
name|SlotIndex
name|start
argument_list|,
name|SlotIndex
name|end
argument_list|,
name|SmallVectorImpl
operator|<
name|MachineBasicBlock
operator|*
operator|>
operator|&
name|mbbs
argument_list|)
decl|const
block|{
name|std
operator|::
name|vector
operator|<
name|IdxMBBPair
operator|>
operator|::
name|const_iterator
name|itr
operator|=
name|std
operator|::
name|lower_bound
argument_list|(
name|idx2MBBMap
operator|.
name|begin
argument_list|()
argument_list|,
name|idx2MBBMap
operator|.
name|end
argument_list|()
argument_list|,
name|start
argument_list|)
expr_stmt|;
name|bool
name|resVal
init|=
name|false
decl_stmt|;
while|while
condition|(
name|itr
operator|!=
name|idx2MBBMap
operator|.
name|end
argument_list|()
condition|)
block|{
if|if
condition|(
name|itr
operator|->
name|first
operator|>
name|end
condition|)
break|break;
name|MachineBasicBlock
modifier|*
name|mbb
init|=
name|itr
operator|->
name|second
decl_stmt|;
if|if
condition|(
name|getMBBEndIdx
argument_list|(
name|mbb
argument_list|)
operator|>
name|end
condition|)
break|break;
for|for
control|(
name|MachineBasicBlock
operator|::
name|succ_iterator
name|si
operator|=
name|mbb
operator|->
name|succ_begin
argument_list|()
operator|,
name|se
operator|=
name|mbb
operator|->
name|succ_end
argument_list|()
init|;
name|si
operator|!=
name|se
condition|;
operator|++
name|si
control|)
name|mbbs
operator|.
name|push_back
argument_list|(
operator|*
name|si
argument_list|)
expr_stmt|;
name|resVal
operator|=
name|true
expr_stmt|;
operator|++
name|itr
expr_stmt|;
block|}
return|return
name|resVal
return|;
block|}
comment|/// Returns the MBB covering the given range, or null if the range covers
comment|/// more than one basic block.
name|MachineBasicBlock
modifier|*
name|getMBBCoveringRange
argument_list|(
name|SlotIndex
name|start
argument_list|,
name|SlotIndex
name|end
argument_list|)
decl|const
block|{
name|assert
argument_list|(
name|start
operator|<
name|end
operator|&&
literal|"Backwards ranges not allowed."
argument_list|)
expr_stmt|;
name|std
operator|::
name|vector
operator|<
name|IdxMBBPair
operator|>
operator|::
name|const_iterator
name|itr
operator|=
name|std
operator|::
name|lower_bound
argument_list|(
name|idx2MBBMap
operator|.
name|begin
argument_list|()
argument_list|,
name|idx2MBBMap
operator|.
name|end
argument_list|()
argument_list|,
name|start
argument_list|)
expr_stmt|;
if|if
condition|(
name|itr
operator|==
name|idx2MBBMap
operator|.
name|end
argument_list|()
condition|)
block|{
name|itr
operator|=
name|prior
argument_list|(
name|itr
argument_list|)
expr_stmt|;
return|return
name|itr
operator|->
name|second
return|;
block|}
comment|// Check that we don't cross the boundary into this block.
if|if
condition|(
name|itr
operator|->
name|first
operator|<
name|end
condition|)
return|return
literal|0
return|;
name|itr
operator|=
name|prior
argument_list|(
name|itr
argument_list|)
expr_stmt|;
if|if
condition|(
name|itr
operator|->
name|first
operator|<=
name|start
condition|)
return|return
name|itr
operator|->
name|second
return|;
return|return
literal|0
return|;
block|}
comment|/// Insert the given machine instruction into the mapping. Returns the
comment|/// assigned index.
name|SlotIndex
name|insertMachineInstrInMaps
parameter_list|(
name|MachineInstr
modifier|*
name|mi
parameter_list|,
name|bool
modifier|*
name|deferredRenumber
init|=
literal|0
parameter_list|)
block|{
name|assert
argument_list|(
name|mi2iMap
operator|.
name|find
argument_list|(
name|mi
argument_list|)
operator|==
name|mi2iMap
operator|.
name|end
argument_list|()
operator|&&
literal|"Instr already indexed."
argument_list|)
expr_stmt|;
name|MachineBasicBlock
modifier|*
name|mbb
init|=
name|mi
operator|->
name|getParent
argument_list|()
decl_stmt|;
name|assert
argument_list|(
name|mbb
operator|!=
literal|0
operator|&&
literal|"Instr must be added to function."
argument_list|)
expr_stmt|;
name|MBB2IdxMap
operator|::
name|iterator
name|mbbRangeItr
operator|=
name|mbb2IdxMap
operator|.
name|find
argument_list|(
name|mbb
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|mbbRangeItr
operator|!=
name|mbb2IdxMap
operator|.
name|end
argument_list|()
operator|&&
literal|"Instruction's parent MBB has not been added to SlotIndexes."
argument_list|)
expr_stmt|;
name|MachineBasicBlock
operator|::
name|iterator
name|miItr
argument_list|(
name|mi
argument_list|)
expr_stmt|;
name|bool
name|needRenumber
init|=
name|false
decl_stmt|;
name|IndexListEntry
modifier|*
name|newEntry
decl_stmt|;
name|IndexListEntry
modifier|*
name|prevEntry
decl_stmt|;
if|if
condition|(
name|miItr
operator|==
name|mbb
operator|->
name|begin
argument_list|()
condition|)
block|{
comment|// If mi is at the mbb beginning, get the prev index from the mbb.
name|prevEntry
operator|=
operator|&
name|mbbRangeItr
operator|->
name|second
operator|.
name|first
operator|.
name|entry
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|// Otherwise get it from the previous instr.
name|MachineBasicBlock
operator|::
name|iterator
name|pItr
argument_list|(
name|prior
argument_list|(
name|miItr
argument_list|)
argument_list|)
expr_stmt|;
name|prevEntry
operator|=
operator|&
name|getInstructionIndex
argument_list|(
name|pItr
argument_list|)
operator|.
name|entry
argument_list|()
expr_stmt|;
block|}
comment|// Get next entry from previous entry.
name|IndexListEntry
modifier|*
name|nextEntry
init|=
name|prevEntry
operator|->
name|getNext
argument_list|()
decl_stmt|;
comment|// Get a number for the new instr, or 0 if there's no room currently.
comment|// In the latter case we'll force a renumber later.
name|unsigned
name|dist
init|=
name|nextEntry
operator|->
name|getIndex
argument_list|()
operator|-
name|prevEntry
operator|->
name|getIndex
argument_list|()
decl_stmt|;
name|unsigned
name|newNumber
init|=
name|dist
operator|>
name|SlotIndex
operator|::
name|NUM
condition|?
name|prevEntry
operator|->
name|getIndex
argument_list|()
operator|+
operator|(
operator|(
name|dist
operator|>>
literal|1
operator|)
operator|&
operator|~
literal|3U
operator|)
else|:
literal|0
decl_stmt|;
if|if
condition|(
name|newNumber
operator|==
literal|0
condition|)
block|{
name|needRenumber
operator|=
name|true
expr_stmt|;
block|}
comment|// Insert a new list entry for mi.
name|newEntry
operator|=
name|createEntry
argument_list|(
name|mi
argument_list|,
name|newNumber
argument_list|)
expr_stmt|;
name|insert
argument_list|(
name|nextEntry
argument_list|,
name|newEntry
argument_list|)
expr_stmt|;
name|SlotIndex
name|newIndex
argument_list|(
name|newEntry
argument_list|,
name|SlotIndex
operator|::
name|LOAD
argument_list|)
decl_stmt|;
name|mi2iMap
operator|.
name|insert
argument_list|(
name|std
operator|::
name|make_pair
argument_list|(
name|mi
argument_list|,
name|newIndex
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|miItr
operator|==
name|mbb
operator|->
name|end
argument_list|()
condition|)
block|{
comment|// If this is the last instr in the MBB then we need to fix up the bb
comment|// range:
name|mbbRangeItr
operator|->
name|second
operator|.
name|second
operator|=
name|SlotIndex
argument_list|(
name|newEntry
argument_list|,
name|SlotIndex
operator|::
name|STORE
argument_list|)
expr_stmt|;
block|}
comment|// Renumber if we need to.
if|if
condition|(
name|needRenumber
condition|)
block|{
if|if
condition|(
name|deferredRenumber
operator|==
literal|0
condition|)
name|renumberIndexes
argument_list|()
expr_stmt|;
else|else
operator|*
name|deferredRenumber
operator|=
name|true
expr_stmt|;
block|}
return|return
name|newIndex
return|;
block|}
comment|/// Add all instructions in the vector to the index list. This method will
comment|/// defer renumbering until all instrs have been added, and should be
comment|/// preferred when adding multiple instrs.
name|void
name|insertMachineInstrsInMaps
argument_list|(
name|SmallVectorImpl
operator|<
name|MachineInstr
operator|*
operator|>
operator|&
name|mis
argument_list|)
block|{
name|bool
name|renumber
init|=
name|false
decl_stmt|;
for|for
control|(
name|SmallVectorImpl
operator|<
name|MachineInstr
operator|*
operator|>
operator|::
name|iterator
name|miItr
operator|=
name|mis
operator|.
name|begin
argument_list|()
operator|,
name|miEnd
operator|=
name|mis
operator|.
name|end
argument_list|()
init|;
name|miItr
operator|!=
name|miEnd
condition|;
operator|++
name|miItr
control|)
block|{
name|insertMachineInstrInMaps
argument_list|(
operator|*
name|miItr
argument_list|,
operator|&
name|renumber
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|renumber
condition|)
name|renumberIndexes
argument_list|()
expr_stmt|;
block|}
comment|/// Remove the given machine instruction from the mapping.
name|void
name|removeMachineInstrFromMaps
parameter_list|(
name|MachineInstr
modifier|*
name|mi
parameter_list|)
block|{
comment|// remove index -> MachineInstr and
comment|// MachineInstr -> index mappings
name|Mi2IndexMap
operator|::
name|iterator
name|mi2iItr
operator|=
name|mi2iMap
operator|.
name|find
argument_list|(
name|mi
argument_list|)
expr_stmt|;
if|if
condition|(
name|mi2iItr
operator|!=
name|mi2iMap
operator|.
name|end
argument_list|()
condition|)
block|{
name|IndexListEntry
modifier|*
name|miEntry
argument_list|(
operator|&
name|mi2iItr
operator|->
name|second
operator|.
name|entry
argument_list|()
argument_list|)
decl_stmt|;
name|assert
argument_list|(
name|miEntry
operator|->
name|getInstr
argument_list|()
operator|==
name|mi
operator|&&
literal|"Instruction indexes broken."
argument_list|)
expr_stmt|;
comment|// FIXME: Eventually we want to actually delete these indexes.
name|miEntry
operator|->
name|setInstr
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|mi2iMap
operator|.
name|erase
argument_list|(
name|mi2iItr
argument_list|)
expr_stmt|;
block|}
block|}
comment|/// ReplaceMachineInstrInMaps - Replacing a machine instr with a new one in
comment|/// maps used by register allocator.
name|void
name|replaceMachineInstrInMaps
parameter_list|(
name|MachineInstr
modifier|*
name|mi
parameter_list|,
name|MachineInstr
modifier|*
name|newMI
parameter_list|)
block|{
name|Mi2IndexMap
operator|::
name|iterator
name|mi2iItr
operator|=
name|mi2iMap
operator|.
name|find
argument_list|(
name|mi
argument_list|)
expr_stmt|;
if|if
condition|(
name|mi2iItr
operator|==
name|mi2iMap
operator|.
name|end
argument_list|()
condition|)
return|return;
name|SlotIndex
name|replaceBaseIndex
init|=
name|mi2iItr
operator|->
name|second
decl_stmt|;
name|IndexListEntry
modifier|*
name|miEntry
argument_list|(
operator|&
name|replaceBaseIndex
operator|.
name|entry
argument_list|()
argument_list|)
decl_stmt|;
name|assert
argument_list|(
name|miEntry
operator|->
name|getInstr
argument_list|()
operator|==
name|mi
operator|&&
literal|"Mismatched instruction in index tables."
argument_list|)
expr_stmt|;
name|miEntry
operator|->
name|setInstr
argument_list|(
name|newMI
argument_list|)
expr_stmt|;
name|mi2iMap
operator|.
name|erase
argument_list|(
name|mi2iItr
argument_list|)
expr_stmt|;
name|mi2iMap
operator|.
name|insert
argument_list|(
name|std
operator|::
name|make_pair
argument_list|(
name|newMI
argument_list|,
name|replaceBaseIndex
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_endif
unit|}
endif|#
directive|endif
end_endif

begin_comment
comment|// LLVM_CODEGEN_LIVEINDEX_H
end_comment

end_unit

