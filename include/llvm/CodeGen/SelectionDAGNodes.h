begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===- llvm/CodeGen/SelectionDAGNodes.h - SelectionDAG Nodes ----*- C++ -*-===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file declares the SDNode class and derived classes, which are used to
end_comment

begin_comment
comment|// represent the nodes and operations present in a SelectionDAG.  These nodes
end_comment

begin_comment
comment|// and operations are machine code level operations, with some similarities to
end_comment

begin_comment
comment|// the GCC RTL representation.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// Clients should include the SelectionDAG.h file instead of this file directly.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LLVM_CODEGEN_SELECTIONDAGNODES_H
end_ifndef

begin_define
define|#
directive|define
name|LLVM_CODEGEN_SELECTIONDAGNODES_H
end_define

begin_include
include|#
directive|include
file|"llvm/ADT/APFloat.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/ArrayRef.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/BitVector.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/FoldingSet.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/GraphTraits.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/SmallPtrSet.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/SmallVector.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/ilist_node.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/iterator.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/iterator_range.h"
end_include

begin_include
include|#
directive|include
file|"llvm/CodeGen/ISDOpcodes.h"
end_include

begin_include
include|#
directive|include
file|"llvm/CodeGen/MachineMemOperand.h"
end_include

begin_include
include|#
directive|include
file|"llvm/CodeGen/MachineValueType.h"
end_include

begin_include
include|#
directive|include
file|"llvm/CodeGen/ValueTypes.h"
end_include

begin_include
include|#
directive|include
file|"llvm/IR/Constants.h"
end_include

begin_include
include|#
directive|include
file|"llvm/IR/DebugLoc.h"
end_include

begin_include
include|#
directive|include
file|"llvm/IR/Instruction.h"
end_include

begin_include
include|#
directive|include
file|"llvm/IR/Instructions.h"
end_include

begin_include
include|#
directive|include
file|"llvm/IR/Metadata.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/AlignOf.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/AtomicOrdering.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/Casting.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/ErrorHandling.h"
end_include

begin_include
include|#
directive|include
file|<algorithm>
end_include

begin_include
include|#
directive|include
file|<cassert>
end_include

begin_include
include|#
directive|include
file|<climits>
end_include

begin_include
include|#
directive|include
file|<cstddef>
end_include

begin_include
include|#
directive|include
file|<cstdint>
end_include

begin_include
include|#
directive|include
file|<cstring>
end_include

begin_include
include|#
directive|include
file|<iterator>
end_include

begin_include
include|#
directive|include
file|<string>
end_include

begin_include
include|#
directive|include
file|<tuple>
end_include

begin_decl_stmt
name|namespace
name|llvm
block|{
name|class
name|APInt
decl_stmt|;
name|class
name|Constant
decl_stmt|;
name|template
operator|<
name|typename
name|T
operator|>
expr|struct
name|DenseMapInfo
expr_stmt|;
name|class
name|GlobalValue
decl_stmt|;
name|class
name|MachineBasicBlock
decl_stmt|;
name|class
name|MachineConstantPoolValue
decl_stmt|;
name|class
name|MCSymbol
decl_stmt|;
name|class
name|raw_ostream
decl_stmt|;
name|class
name|SDNode
decl_stmt|;
name|class
name|SelectionDAG
decl_stmt|;
name|class
name|Type
decl_stmt|;
name|class
name|Value
decl_stmt|;
name|void
name|checkForCycles
parameter_list|(
specifier|const
name|SDNode
modifier|*
name|N
parameter_list|,
specifier|const
name|SelectionDAG
modifier|*
name|DAG
init|=
name|nullptr
parameter_list|,
name|bool
name|force
init|=
name|false
parameter_list|)
function_decl|;
comment|/// This represents a list of ValueType's that has been intern'd by
comment|/// a SelectionDAG.  Instances of this simple value class are returned by
comment|/// SelectionDAG::getVTList(...).
comment|///
struct|struct
name|SDVTList
block|{
specifier|const
name|EVT
modifier|*
name|VTs
decl_stmt|;
name|unsigned
name|int
name|NumVTs
decl_stmt|;
block|}
struct|;
name|namespace
name|ISD
block|{
comment|/// Node predicates
comment|/// If N is a BUILD_VECTOR node whose elements are all the same constant or
comment|/// undefined, return true and return the constant value in \p SplatValue.
name|bool
name|isConstantSplatVector
parameter_list|(
specifier|const
name|SDNode
modifier|*
name|N
parameter_list|,
name|APInt
modifier|&
name|SplatValue
parameter_list|)
function_decl|;
comment|/// Return true if the specified node is a BUILD_VECTOR where all of the
comment|/// elements are ~0 or undef.
name|bool
name|isBuildVectorAllOnes
parameter_list|(
specifier|const
name|SDNode
modifier|*
name|N
parameter_list|)
function_decl|;
comment|/// Return true if the specified node is a BUILD_VECTOR where all of the
comment|/// elements are 0 or undef.
name|bool
name|isBuildVectorAllZeros
parameter_list|(
specifier|const
name|SDNode
modifier|*
name|N
parameter_list|)
function_decl|;
comment|/// Return true if the specified node is a BUILD_VECTOR node of all
comment|/// ConstantSDNode or undef.
name|bool
name|isBuildVectorOfConstantSDNodes
parameter_list|(
specifier|const
name|SDNode
modifier|*
name|N
parameter_list|)
function_decl|;
comment|/// Return true if the specified node is a BUILD_VECTOR node of all
comment|/// ConstantFPSDNode or undef.
name|bool
name|isBuildVectorOfConstantFPSDNodes
parameter_list|(
specifier|const
name|SDNode
modifier|*
name|N
parameter_list|)
function_decl|;
comment|/// Return true if the node has at least one operand and all operands of the
comment|/// specified node are ISD::UNDEF.
name|bool
name|allOperandsUndef
parameter_list|(
specifier|const
name|SDNode
modifier|*
name|N
parameter_list|)
function_decl|;
block|}
comment|// end namespace ISD
comment|//===----------------------------------------------------------------------===//
comment|/// Unlike LLVM values, Selection DAG nodes may return multiple
comment|/// values as the result of a computation.  Many nodes return multiple values,
comment|/// from loads (which define a token and a return value) to ADDC (which returns
comment|/// a result and a carry value), to calls (which may return an arbitrary number
comment|/// of values).
comment|///
comment|/// As such, each use of a SelectionDAG computation must indicate the node that
comment|/// computes it as well as which return value to use from that node.  This pair
comment|/// of information is represented with the SDValue value type.
comment|///
name|class
name|SDValue
block|{
name|friend
block|struct
name|DenseMapInfo
operator|<
name|SDValue
operator|>
expr_stmt|;
name|SDNode
modifier|*
name|Node
init|=
name|nullptr
decl_stmt|;
comment|// The node defining the value we are using.
name|unsigned
name|ResNo
init|=
literal|0
decl_stmt|;
comment|// Which return value of the node we are using.
name|public
label|:
name|SDValue
argument_list|()
operator|=
expr|default
expr_stmt|;
name|SDValue
argument_list|(
argument|SDNode *node
argument_list|,
argument|unsigned resno
argument_list|)
empty_stmt|;
comment|/// get the index which selects a specific result in the SDNode
name|unsigned
name|getResNo
argument_list|()
specifier|const
block|{
return|return
name|ResNo
return|;
block|}
comment|/// get the SDNode which holds the desired result
name|SDNode
operator|*
name|getNode
argument_list|()
specifier|const
block|{
return|return
name|Node
return|;
block|}
comment|/// set the SDNode
name|void
name|setNode
parameter_list|(
name|SDNode
modifier|*
name|N
parameter_list|)
block|{
name|Node
operator|=
name|N
expr_stmt|;
block|}
specifier|inline
name|SDNode
operator|*
name|operator
operator|->
expr|(
block|)
decl|const
block|{
return|return
name|Node
return|;
block|}
name|bool
name|operator
operator|==
operator|(
specifier|const
name|SDValue
operator|&
name|O
operator|)
specifier|const
block|{
return|return
name|Node
operator|==
name|O
operator|.
name|Node
operator|&&
name|ResNo
operator|==
name|O
operator|.
name|ResNo
return|;
block|}
name|bool
name|operator
operator|!=
operator|(
specifier|const
name|SDValue
operator|&
name|O
operator|)
specifier|const
block|{
return|return
operator|!
name|operator
operator|==
operator|(
name|O
operator|)
return|;
block|}
name|bool
name|operator
operator|<
operator|(
specifier|const
name|SDValue
operator|&
name|O
operator|)
specifier|const
block|{
return|return
name|std
operator|::
name|tie
argument_list|(
name|Node
argument_list|,
name|ResNo
argument_list|)
operator|<
name|std
operator|::
name|tie
argument_list|(
name|O
operator|.
name|Node
argument_list|,
name|O
operator|.
name|ResNo
argument_list|)
return|;
block|}
name|explicit
name|operator
name|bool
argument_list|()
specifier|const
block|{
return|return
name|Node
operator|!=
name|nullptr
return|;
block|}
name|SDValue
name|getValue
argument_list|(
name|unsigned
name|R
argument_list|)
decl|const
block|{
return|return
name|SDValue
argument_list|(
name|Node
argument_list|,
name|R
argument_list|)
return|;
block|}
comment|/// Return true if this node is an operand of N.
name|bool
name|isOperandOf
argument_list|(
specifier|const
name|SDNode
operator|*
name|N
argument_list|)
decl|const
decl_stmt|;
comment|/// Return the ValueType of the referenced return value.
specifier|inline
name|EVT
name|getValueType
argument_list|()
specifier|const
expr_stmt|;
comment|/// Return the simple ValueType of the referenced return value.
name|MVT
name|getSimpleValueType
argument_list|()
specifier|const
block|{
return|return
name|getValueType
argument_list|()
operator|.
name|getSimpleVT
argument_list|()
return|;
block|}
comment|/// Returns the size of the value in bits.
name|unsigned
name|getValueSizeInBits
argument_list|()
specifier|const
block|{
return|return
name|getValueType
argument_list|()
operator|.
name|getSizeInBits
argument_list|()
return|;
block|}
name|unsigned
name|getScalarValueSizeInBits
argument_list|()
specifier|const
block|{
return|return
name|getValueType
argument_list|()
operator|.
name|getScalarType
argument_list|()
operator|.
name|getSizeInBits
argument_list|()
return|;
block|}
comment|// Forwarding methods - These forward to the corresponding methods in SDNode.
specifier|inline
name|unsigned
name|getOpcode
argument_list|()
specifier|const
expr_stmt|;
specifier|inline
name|unsigned
name|getNumOperands
argument_list|()
specifier|const
expr_stmt|;
specifier|inline
specifier|const
name|SDValue
modifier|&
name|getOperand
argument_list|(
name|unsigned
name|i
argument_list|)
decl|const
decl_stmt|;
specifier|inline
name|uint64_t
name|getConstantOperandVal
argument_list|(
name|unsigned
name|i
argument_list|)
decl|const
decl_stmt|;
specifier|inline
name|bool
name|isTargetMemoryOpcode
argument_list|()
specifier|const
expr_stmt|;
specifier|inline
name|bool
name|isTargetOpcode
argument_list|()
specifier|const
expr_stmt|;
specifier|inline
name|bool
name|isMachineOpcode
argument_list|()
specifier|const
expr_stmt|;
specifier|inline
name|bool
name|isUndef
argument_list|()
specifier|const
expr_stmt|;
specifier|inline
name|unsigned
name|getMachineOpcode
argument_list|()
specifier|const
expr_stmt|;
specifier|inline
specifier|const
name|DebugLoc
operator|&
name|getDebugLoc
argument_list|()
specifier|const
expr_stmt|;
specifier|inline
name|void
name|dump
argument_list|()
specifier|const
expr_stmt|;
specifier|inline
name|void
name|dumpr
argument_list|()
specifier|const
expr_stmt|;
comment|/// Return true if this operand (which must be a chain) reaches the
comment|/// specified operand without crossing any side-effecting instructions.
comment|/// In practice, this looks through token factors and non-volatile loads.
comment|/// In order to remain efficient, this only
comment|/// looks a couple of nodes in, it does not do an exhaustive search.
name|bool
name|reachesChainWithoutSideEffects
argument_list|(
name|SDValue
name|Dest
argument_list|,
name|unsigned
name|Depth
operator|=
literal|2
argument_list|)
decl|const
decl_stmt|;
comment|/// Return true if there are no nodes using value ResNo of Node.
specifier|inline
name|bool
name|use_empty
argument_list|()
specifier|const
expr_stmt|;
comment|/// Return true if there is exactly one node using value ResNo of Node.
specifier|inline
name|bool
name|hasOneUse
argument_list|()
specifier|const
expr_stmt|;
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_expr_stmt
name|template
operator|<
operator|>
expr|struct
name|DenseMapInfo
operator|<
name|SDValue
operator|>
block|{
specifier|static
specifier|inline
name|SDValue
name|getEmptyKey
argument_list|()
block|{
name|SDValue
name|V
block|;
name|V
operator|.
name|ResNo
operator|=
operator|-
literal|1U
block|;
return|return
name|V
return|;
block|}
specifier|static
specifier|inline
name|SDValue
name|getTombstoneKey
argument_list|()
block|{
name|SDValue
name|V
block|;
name|V
operator|.
name|ResNo
operator|=
operator|-
literal|2U
block|;
return|return
name|V
return|;
block|}
end_expr_stmt

begin_function
specifier|static
name|unsigned
name|getHashValue
parameter_list|(
specifier|const
name|SDValue
modifier|&
name|Val
parameter_list|)
block|{
return|return
operator|(
call|(
name|unsigned
call|)
argument_list|(
operator|(
name|uintptr_t
operator|)
name|Val
operator|.
name|getNode
argument_list|()
operator|>>
literal|4
argument_list|)
operator|^
call|(
name|unsigned
call|)
argument_list|(
operator|(
name|uintptr_t
operator|)
name|Val
operator|.
name|getNode
argument_list|()
operator|>>
literal|9
argument_list|)
operator|)
operator|+
name|Val
operator|.
name|getResNo
argument_list|()
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|isEqual
parameter_list|(
specifier|const
name|SDValue
modifier|&
name|LHS
parameter_list|,
specifier|const
name|SDValue
modifier|&
name|RHS
parameter_list|)
block|{
return|return
name|LHS
operator|==
name|RHS
return|;
block|}
end_function

begin_expr_stmt
unit|};
name|template
operator|<
operator|>
expr|struct
name|isPodLike
operator|<
name|SDValue
operator|>
block|{
specifier|static
specifier|const
name|bool
name|value
operator|=
name|true
block|; }
expr_stmt|;
end_expr_stmt

begin_comment
comment|/// Allow casting operators to work directly on
end_comment

begin_comment
comment|/// SDValues as if they were SDNode*'s.
end_comment

begin_expr_stmt
name|template
operator|<
operator|>
expr|struct
name|simplify_type
operator|<
name|SDValue
operator|>
block|{
name|using
name|SimpleType
operator|=
name|SDNode
operator|*
block|;
specifier|static
name|SimpleType
name|getSimplifiedValue
argument_list|(
argument|SDValue&Val
argument_list|)
block|{
return|return
name|Val
operator|.
name|getNode
argument_list|()
return|;
block|}
end_expr_stmt

begin_expr_stmt
unit|};
name|template
operator|<
operator|>
expr|struct
name|simplify_type
operator|<
specifier|const
name|SDValue
operator|>
block|{
name|using
name|SimpleType
operator|=
comment|/*const*/
name|SDNode
operator|*
block|;
specifier|static
name|SimpleType
name|getSimplifiedValue
argument_list|(
argument|const SDValue&Val
argument_list|)
block|{
return|return
name|Val
operator|.
name|getNode
argument_list|()
return|;
block|}
end_expr_stmt

begin_comment
unit|};
comment|/// Represents a use of a SDNode. This class holds an SDValue,
end_comment

begin_comment
comment|/// which records the SDNode being used and the result number, a
end_comment

begin_comment
comment|/// pointer to the SDNode using the value, and Next and Prev pointers,
end_comment

begin_comment
comment|/// which link together all the uses of an SDNode.
end_comment

begin_comment
comment|///
end_comment

begin_decl_stmt
name|class
name|SDUse
block|{
comment|/// Val - The value being used.
name|SDValue
name|Val
decl_stmt|;
comment|/// User - The user of this value.
name|SDNode
modifier|*
name|User
init|=
name|nullptr
decl_stmt|;
comment|/// Prev, Next - Pointers to the uses list of the SDNode referred by
comment|/// this operand.
name|SDUse
modifier|*
modifier|*
name|Prev
init|=
name|nullptr
decl_stmt|;
name|SDUse
modifier|*
name|Next
init|=
name|nullptr
decl_stmt|;
name|public
label|:
name|SDUse
argument_list|()
operator|=
expr|default
expr_stmt|;
name|SDUse
argument_list|(
specifier|const
name|SDUse
operator|&
name|U
argument_list|)
operator|=
name|delete
expr_stmt|;
name|SDUse
modifier|&
name|operator
init|=
operator|(
specifier|const
name|SDUse
operator|&
operator|)
operator|=
name|delete
decl_stmt|;
comment|/// Normally SDUse will just implicitly convert to an SDValue that it holds.
name|operator
specifier|const
name|SDValue
operator|&
operator|(
operator|)
specifier|const
block|{
return|return
name|Val
return|;
block|}
comment|/// If implicit conversion to SDValue doesn't work, the get() method returns
comment|/// the SDValue.
specifier|const
name|SDValue
operator|&
name|get
argument_list|()
specifier|const
block|{
return|return
name|Val
return|;
block|}
comment|/// This returns the SDNode that contains this Use.
name|SDNode
modifier|*
name|getUser
parameter_list|()
block|{
return|return
name|User
return|;
block|}
comment|/// Get the next SDUse in the use list.
name|SDUse
operator|*
name|getNext
argument_list|()
specifier|const
block|{
return|return
name|Next
return|;
block|}
comment|/// Convenience function for get().getNode().
name|SDNode
operator|*
name|getNode
argument_list|()
specifier|const
block|{
return|return
name|Val
operator|.
name|getNode
argument_list|()
return|;
block|}
comment|/// Convenience function for get().getResNo().
name|unsigned
name|getResNo
argument_list|()
specifier|const
block|{
return|return
name|Val
operator|.
name|getResNo
argument_list|()
return|;
block|}
comment|/// Convenience function for get().getValueType().
name|EVT
name|getValueType
argument_list|()
specifier|const
block|{
return|return
name|Val
operator|.
name|getValueType
argument_list|()
return|;
block|}
comment|/// Convenience function for get().operator==
name|bool
name|operator
operator|==
operator|(
specifier|const
name|SDValue
operator|&
name|V
operator|)
specifier|const
block|{
return|return
name|Val
operator|==
name|V
return|;
block|}
comment|/// Convenience function for get().operator!=
name|bool
name|operator
operator|!=
operator|(
specifier|const
name|SDValue
operator|&
name|V
operator|)
specifier|const
block|{
return|return
name|Val
operator|!=
name|V
return|;
block|}
comment|/// Convenience function for get().operator<
name|bool
name|operator
operator|<
operator|(
specifier|const
name|SDValue
operator|&
name|V
operator|)
specifier|const
block|{
return|return
name|Val
operator|<
name|V
return|;
block|}
name|private
label|:
name|friend
name|class
name|SelectionDAG
decl_stmt|;
name|friend
name|class
name|SDNode
decl_stmt|;
comment|// TODO: unfriend HandleSDNode once we fix its operand handling.
name|friend
name|class
name|HandleSDNode
decl_stmt|;
name|void
name|setUser
parameter_list|(
name|SDNode
modifier|*
name|p
parameter_list|)
block|{
name|User
operator|=
name|p
expr_stmt|;
block|}
comment|/// Remove this use from its existing use list, assign it the
comment|/// given value, and add it to the new value's node's use list.
specifier|inline
name|void
name|set
parameter_list|(
specifier|const
name|SDValue
modifier|&
name|V
parameter_list|)
function_decl|;
comment|/// Like set, but only supports initializing a newly-allocated
comment|/// SDUse with a non-null value.
specifier|inline
name|void
name|setInitial
parameter_list|(
specifier|const
name|SDValue
modifier|&
name|V
parameter_list|)
function_decl|;
comment|/// Like set, but only sets the Node portion of the value,
comment|/// leaving the ResNo portion unmodified.
specifier|inline
name|void
name|setNode
parameter_list|(
name|SDNode
modifier|*
name|N
parameter_list|)
function_decl|;
name|void
name|addToList
parameter_list|(
name|SDUse
modifier|*
modifier|*
name|List
parameter_list|)
block|{
name|Next
operator|=
operator|*
name|List
expr_stmt|;
if|if
condition|(
name|Next
condition|)
name|Next
operator|->
name|Prev
operator|=
operator|&
name|Next
expr_stmt|;
name|Prev
operator|=
name|List
expr_stmt|;
operator|*
name|List
operator|=
name|this
expr_stmt|;
block|}
name|void
name|removeFromList
parameter_list|()
block|{
operator|*
name|Prev
operator|=
name|Next
expr_stmt|;
if|if
condition|(
name|Next
condition|)
name|Next
operator|->
name|Prev
operator|=
name|Prev
expr_stmt|;
block|}
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_comment
comment|/// simplify_type specializations - Allow casting operators to work directly on
end_comment

begin_comment
comment|/// SDValues as if they were SDNode*'s.
end_comment

begin_expr_stmt
name|template
operator|<
operator|>
expr|struct
name|simplify_type
operator|<
name|SDUse
operator|>
block|{
name|using
name|SimpleType
operator|=
name|SDNode
operator|*
block|;
specifier|static
name|SimpleType
name|getSimplifiedValue
argument_list|(
argument|SDUse&Val
argument_list|)
block|{
return|return
name|Val
operator|.
name|getNode
argument_list|()
return|;
block|}
end_expr_stmt

begin_comment
unit|};
comment|/// These are IR-level optimization flags that may be propagated to SDNodes.
end_comment

begin_comment
comment|/// TODO: This data structure should be shared by the IR optimizer and the
end_comment

begin_comment
comment|/// the backend.
end_comment

begin_struct
struct|struct
name|SDNodeFlags
block|{
name|private
label|:
comment|// This bit is used to determine if the flags are in a defined state.
comment|// Flag bits can only be masked out during intersection if the masking flags
comment|// are defined.
name|bool
name|AnyDefined
range|:
literal|1
decl_stmt|;
name|bool
name|NoUnsignedWrap
range|:
literal|1
decl_stmt|;
name|bool
name|NoSignedWrap
range|:
literal|1
decl_stmt|;
name|bool
name|Exact
range|:
literal|1
decl_stmt|;
name|bool
name|UnsafeAlgebra
range|:
literal|1
decl_stmt|;
name|bool
name|NoNaNs
range|:
literal|1
decl_stmt|;
name|bool
name|NoInfs
range|:
literal|1
decl_stmt|;
name|bool
name|NoSignedZeros
range|:
literal|1
decl_stmt|;
name|bool
name|AllowReciprocal
range|:
literal|1
decl_stmt|;
name|bool
name|VectorReduction
range|:
literal|1
decl_stmt|;
name|bool
name|AllowContract
range|:
literal|1
decl_stmt|;
name|public
label|:
comment|/// Default constructor turns off all optimization flags.
name|SDNodeFlags
argument_list|()
operator|:
name|AnyDefined
argument_list|(
name|false
argument_list|)
operator|,
name|NoUnsignedWrap
argument_list|(
name|false
argument_list|)
operator|,
name|NoSignedWrap
argument_list|(
name|false
argument_list|)
operator|,
name|Exact
argument_list|(
name|false
argument_list|)
operator|,
name|UnsafeAlgebra
argument_list|(
name|false
argument_list|)
operator|,
name|NoNaNs
argument_list|(
name|false
argument_list|)
operator|,
name|NoInfs
argument_list|(
name|false
argument_list|)
operator|,
name|NoSignedZeros
argument_list|(
name|false
argument_list|)
operator|,
name|AllowReciprocal
argument_list|(
name|false
argument_list|)
operator|,
name|VectorReduction
argument_list|(
name|false
argument_list|)
operator|,
name|AllowContract
argument_list|(
argument|false
argument_list|)
block|{}
comment|/// Sets the state of the flags to the defined state.
name|void
name|setDefined
argument_list|()
block|{
name|AnyDefined
operator|=
name|true
block|; }
comment|/// Returns true if the flags are in a defined state.
name|bool
name|isDefined
argument_list|()
specifier|const
block|{
return|return
name|AnyDefined
return|;
block|}
comment|// These are mutators for each flag.
name|void
name|setNoUnsignedWrap
parameter_list|(
name|bool
name|b
parameter_list|)
block|{
name|setDefined
argument_list|()
expr_stmt|;
name|NoUnsignedWrap
operator|=
name|b
expr_stmt|;
block|}
name|void
name|setNoSignedWrap
parameter_list|(
name|bool
name|b
parameter_list|)
block|{
name|setDefined
argument_list|()
expr_stmt|;
name|NoSignedWrap
operator|=
name|b
expr_stmt|;
block|}
name|void
name|setExact
parameter_list|(
name|bool
name|b
parameter_list|)
block|{
name|setDefined
argument_list|()
expr_stmt|;
name|Exact
operator|=
name|b
expr_stmt|;
block|}
name|void
name|setUnsafeAlgebra
parameter_list|(
name|bool
name|b
parameter_list|)
block|{
name|setDefined
argument_list|()
expr_stmt|;
name|UnsafeAlgebra
operator|=
name|b
expr_stmt|;
block|}
name|void
name|setNoNaNs
parameter_list|(
name|bool
name|b
parameter_list|)
block|{
name|setDefined
argument_list|()
expr_stmt|;
name|NoNaNs
operator|=
name|b
expr_stmt|;
block|}
name|void
name|setNoInfs
parameter_list|(
name|bool
name|b
parameter_list|)
block|{
name|setDefined
argument_list|()
expr_stmt|;
name|NoInfs
operator|=
name|b
expr_stmt|;
block|}
name|void
name|setNoSignedZeros
parameter_list|(
name|bool
name|b
parameter_list|)
block|{
name|setDefined
argument_list|()
expr_stmt|;
name|NoSignedZeros
operator|=
name|b
expr_stmt|;
block|}
name|void
name|setAllowReciprocal
parameter_list|(
name|bool
name|b
parameter_list|)
block|{
name|setDefined
argument_list|()
expr_stmt|;
name|AllowReciprocal
operator|=
name|b
expr_stmt|;
block|}
name|void
name|setVectorReduction
parameter_list|(
name|bool
name|b
parameter_list|)
block|{
name|setDefined
argument_list|()
expr_stmt|;
name|VectorReduction
operator|=
name|b
expr_stmt|;
block|}
name|void
name|setAllowContract
parameter_list|(
name|bool
name|b
parameter_list|)
block|{
name|setDefined
argument_list|()
expr_stmt|;
name|AllowContract
operator|=
name|b
expr_stmt|;
block|}
comment|// These are accessors for each flag.
name|bool
name|hasNoUnsignedWrap
argument_list|()
specifier|const
block|{
return|return
name|NoUnsignedWrap
return|;
block|}
name|bool
name|hasNoSignedWrap
argument_list|()
specifier|const
block|{
return|return
name|NoSignedWrap
return|;
block|}
name|bool
name|hasExact
argument_list|()
specifier|const
block|{
return|return
name|Exact
return|;
block|}
name|bool
name|hasUnsafeAlgebra
argument_list|()
specifier|const
block|{
return|return
name|UnsafeAlgebra
return|;
block|}
name|bool
name|hasNoNaNs
argument_list|()
specifier|const
block|{
return|return
name|NoNaNs
return|;
block|}
name|bool
name|hasNoInfs
argument_list|()
specifier|const
block|{
return|return
name|NoInfs
return|;
block|}
name|bool
name|hasNoSignedZeros
argument_list|()
specifier|const
block|{
return|return
name|NoSignedZeros
return|;
block|}
name|bool
name|hasAllowReciprocal
argument_list|()
specifier|const
block|{
return|return
name|AllowReciprocal
return|;
block|}
name|bool
name|hasVectorReduction
argument_list|()
specifier|const
block|{
return|return
name|VectorReduction
return|;
block|}
name|bool
name|hasAllowContract
argument_list|()
specifier|const
block|{
return|return
name|AllowContract
return|;
block|}
comment|/// Clear any flags in this flag set that aren't also set in Flags.
comment|/// If the given Flags are undefined then don't do anything.
name|void
name|intersectWith
parameter_list|(
specifier|const
name|SDNodeFlags
name|Flags
parameter_list|)
block|{
if|if
condition|(
operator|!
name|Flags
operator|.
name|isDefined
argument_list|()
condition|)
return|return;
name|NoUnsignedWrap
operator|&=
name|Flags
operator|.
name|NoUnsignedWrap
expr_stmt|;
name|NoSignedWrap
operator|&=
name|Flags
operator|.
name|NoSignedWrap
expr_stmt|;
name|Exact
operator|&=
name|Flags
operator|.
name|Exact
expr_stmt|;
name|UnsafeAlgebra
operator|&=
name|Flags
operator|.
name|UnsafeAlgebra
expr_stmt|;
name|NoNaNs
operator|&=
name|Flags
operator|.
name|NoNaNs
expr_stmt|;
name|NoInfs
operator|&=
name|Flags
operator|.
name|NoInfs
expr_stmt|;
name|NoSignedZeros
operator|&=
name|Flags
operator|.
name|NoSignedZeros
expr_stmt|;
name|AllowReciprocal
operator|&=
name|Flags
operator|.
name|AllowReciprocal
expr_stmt|;
name|VectorReduction
operator|&=
name|Flags
operator|.
name|VectorReduction
expr_stmt|;
name|AllowContract
operator|&=
name|Flags
operator|.
name|AllowContract
expr_stmt|;
block|}
block|}
struct|;
end_struct

begin_comment
comment|/// Represents one node in the SelectionDAG.
end_comment

begin_comment
comment|///
end_comment

begin_decl_stmt
name|class
name|SDNode
range|:
name|public
name|FoldingSetNode
decl_stmt|,
name|public
name|ilist_node
decl|<
name|SDNode
decl|>
block|{
name|private
label|:
comment|/// The operation that this node performs.
name|int16_t
name|NodeType
decl_stmt|;
name|protected
label|:
comment|// We define a set of mini-helper classes to help us interpret the bits in our
comment|// SubclassData.  These are designed to fit within a uint16_t so they pack
comment|// with NodeType.
name|class
name|SDNodeBitfields
block|{
name|friend
name|class
name|SDNode
decl_stmt|;
name|friend
name|class
name|MemIntrinsicSDNode
decl_stmt|;
name|friend
name|class
name|MemSDNode
decl_stmt|;
name|uint16_t
name|HasDebugValue
range|:
literal|1
decl_stmt|;
name|uint16_t
name|IsMemIntrinsic
range|:
literal|1
decl_stmt|;
block|}
empty_stmt|;
enum|enum
block|{
name|NumSDNodeBits
init|=
literal|2
block|}
enum|;
name|class
name|ConstantSDNodeBitfields
block|{
name|friend
name|class
name|ConstantSDNode
decl_stmt|;
name|uint16_t
label|:
name|NumSDNodeBits
expr_stmt|;
name|uint16_t
name|IsOpaque
range|:
literal|1
decl_stmt|;
block|}
empty_stmt|;
name|class
name|MemSDNodeBitfields
block|{
name|friend
name|class
name|MemSDNode
decl_stmt|;
name|friend
name|class
name|MemIntrinsicSDNode
decl_stmt|;
name|friend
name|class
name|AtomicSDNode
decl_stmt|;
name|uint16_t
label|:
name|NumSDNodeBits
expr_stmt|;
name|uint16_t
name|IsVolatile
range|:
literal|1
decl_stmt|;
name|uint16_t
name|IsNonTemporal
range|:
literal|1
decl_stmt|;
name|uint16_t
name|IsDereferenceable
range|:
literal|1
decl_stmt|;
name|uint16_t
name|IsInvariant
range|:
literal|1
decl_stmt|;
block|}
empty_stmt|;
enum|enum
block|{
name|NumMemSDNodeBits
init|=
name|NumSDNodeBits
operator|+
literal|4
block|}
enum|;
name|class
name|LSBaseSDNodeBitfields
block|{
name|friend
name|class
name|LSBaseSDNode
decl_stmt|;
name|uint16_t
label|:
name|NumMemSDNodeBits
expr_stmt|;
name|uint16_t
name|AddressingMode
range|:
literal|3
decl_stmt|;
comment|// enum ISD::MemIndexedMode
block|}
empty_stmt|;
enum|enum
block|{
name|NumLSBaseSDNodeBits
init|=
name|NumMemSDNodeBits
operator|+
literal|3
block|}
enum|;
name|class
name|LoadSDNodeBitfields
block|{
name|friend
name|class
name|LoadSDNode
decl_stmt|;
name|friend
name|class
name|MaskedLoadSDNode
decl_stmt|;
name|uint16_t
label|:
name|NumLSBaseSDNodeBits
expr_stmt|;
name|uint16_t
name|ExtTy
range|:
literal|2
decl_stmt|;
comment|// enum ISD::LoadExtType
name|uint16_t
name|IsExpanding
range|:
literal|1
decl_stmt|;
block|}
empty_stmt|;
name|class
name|StoreSDNodeBitfields
block|{
name|friend
name|class
name|StoreSDNode
decl_stmt|;
name|friend
name|class
name|MaskedStoreSDNode
decl_stmt|;
name|uint16_t
label|:
name|NumLSBaseSDNodeBits
expr_stmt|;
name|uint16_t
name|IsTruncating
range|:
literal|1
decl_stmt|;
name|uint16_t
name|IsCompressing
range|:
literal|1
decl_stmt|;
block|}
empty_stmt|;
union|union
block|{
name|char
name|RawSDNodeBits
index|[
sizeof|sizeof
argument_list|(
name|uint16_t
argument_list|)
index|]
decl_stmt|;
name|SDNodeBitfields
name|SDNodeBits
decl_stmt|;
name|ConstantSDNodeBitfields
name|ConstantSDNodeBits
decl_stmt|;
name|MemSDNodeBitfields
name|MemSDNodeBits
decl_stmt|;
name|LSBaseSDNodeBitfields
name|LSBaseSDNodeBits
decl_stmt|;
name|LoadSDNodeBitfields
name|LoadSDNodeBits
decl_stmt|;
name|StoreSDNodeBitfields
name|StoreSDNodeBits
decl_stmt|;
block|}
union|;
comment|// RawSDNodeBits must cover the entirety of the union.  This means that all of
comment|// the union's members must have size<= RawSDNodeBits.  We write the RHS as
comment|// "2" instead of sizeof(RawSDNodeBits) because MSVC can't handle the latter.
name|static_assert
argument_list|(
sizeof|sizeof
argument_list|(
name|SDNodeBitfields
argument_list|)
operator|<=
literal|2
argument_list|,
literal|"field too wide"
argument_list|)
expr_stmt|;
name|static_assert
argument_list|(
sizeof|sizeof
argument_list|(
name|ConstantSDNodeBitfields
argument_list|)
operator|<=
literal|2
argument_list|,
literal|"field too wide"
argument_list|)
expr_stmt|;
name|static_assert
argument_list|(
sizeof|sizeof
argument_list|(
name|MemSDNodeBitfields
argument_list|)
operator|<=
literal|2
argument_list|,
literal|"field too wide"
argument_list|)
expr_stmt|;
name|static_assert
argument_list|(
sizeof|sizeof
argument_list|(
name|LSBaseSDNodeBitfields
argument_list|)
operator|<=
literal|2
argument_list|,
literal|"field too wide"
argument_list|)
expr_stmt|;
name|static_assert
argument_list|(
sizeof|sizeof
argument_list|(
name|LoadSDNodeBitfields
argument_list|)
operator|<=
literal|4
argument_list|,
literal|"field too wide"
argument_list|)
expr_stmt|;
name|static_assert
argument_list|(
sizeof|sizeof
argument_list|(
name|StoreSDNodeBitfields
argument_list|)
operator|<=
literal|2
argument_list|,
literal|"field too wide"
argument_list|)
expr_stmt|;
name|private
label|:
name|friend
name|class
name|SelectionDAG
decl_stmt|;
comment|// TODO: unfriend HandleSDNode once we fix its operand handling.
name|friend
name|class
name|HandleSDNode
decl_stmt|;
comment|/// Unique id per SDNode in the DAG.
name|int
name|NodeId
init|=
operator|-
literal|1
decl_stmt|;
comment|/// The values that are used by this operation.
name|SDUse
modifier|*
name|OperandList
init|=
name|nullptr
decl_stmt|;
comment|/// The types of the values this node defines.  SDNode's may
comment|/// define multiple values simultaneously.
specifier|const
name|EVT
modifier|*
name|ValueList
decl_stmt|;
comment|/// List of uses for this SDNode.
name|SDUse
modifier|*
name|UseList
init|=
name|nullptr
decl_stmt|;
comment|/// The number of entries in the Operand/Value list.
name|unsigned
name|short
name|NumOperands
init|=
literal|0
decl_stmt|;
name|unsigned
name|short
name|NumValues
decl_stmt|;
comment|// The ordering of the SDNodes. It roughly corresponds to the ordering of the
comment|// original LLVM instructions.
comment|// This is used for turning off scheduling, because we'll forgo
comment|// the normal scheduling algorithms and output the instructions according to
comment|// this ordering.
name|unsigned
name|IROrder
decl_stmt|;
comment|/// Source line information.
name|DebugLoc
name|debugLoc
decl_stmt|;
comment|/// Return a pointer to the specified value type.
specifier|static
specifier|const
name|EVT
modifier|*
name|getValueTypeList
parameter_list|(
name|EVT
name|VT
parameter_list|)
function_decl|;
name|SDNodeFlags
name|Flags
decl_stmt|;
name|public
label|:
comment|/// Unique and persistent id per SDNode in the DAG.
comment|/// Used for debug printing.
name|uint16_t
name|PersistentId
decl_stmt|;
comment|//===--------------------------------------------------------------------===//
comment|//  Accessors
comment|//
comment|/// Return the SelectionDAG opcode value for this node. For
comment|/// pre-isel nodes (those for which isMachineOpcode returns false), these
comment|/// are the opcode values in the ISD and<target>ISD namespaces. For
comment|/// post-isel opcodes, see getMachineOpcode.
name|unsigned
name|getOpcode
argument_list|()
specifier|const
block|{
return|return
operator|(
name|unsigned
name|short
operator|)
name|NodeType
return|;
block|}
comment|/// Test if this node has a target-specific opcode (in the
comment|/// \<target\>ISD namespace).
name|bool
name|isTargetOpcode
argument_list|()
specifier|const
block|{
return|return
name|NodeType
operator|>=
name|ISD
operator|::
name|BUILTIN_OP_END
return|;
block|}
comment|/// Test if this node has a target-specific
comment|/// memory-referencing opcode (in the \<target\>ISD namespace and
comment|/// greater than FIRST_TARGET_MEMORY_OPCODE).
name|bool
name|isTargetMemoryOpcode
argument_list|()
specifier|const
block|{
return|return
name|NodeType
operator|>=
name|ISD
operator|::
name|FIRST_TARGET_MEMORY_OPCODE
return|;
block|}
comment|/// Return true if the type of the node type undefined.
name|bool
name|isUndef
argument_list|()
specifier|const
block|{
return|return
name|NodeType
operator|==
name|ISD
operator|::
name|UNDEF
return|;
block|}
comment|/// Test if this node is a memory intrinsic (with valid pointer information).
comment|/// INTRINSIC_W_CHAIN and INTRINSIC_VOID nodes are sometimes created for
comment|/// non-memory intrinsics (with chains) that are not really instances of
comment|/// MemSDNode. For such nodes, we need some extra state to determine the
comment|/// proper classof relationship.
name|bool
name|isMemIntrinsic
argument_list|()
specifier|const
block|{
return|return
operator|(
name|NodeType
operator|==
name|ISD
operator|::
name|INTRINSIC_W_CHAIN
operator|||
name|NodeType
operator|==
name|ISD
operator|::
name|INTRINSIC_VOID
operator|)
operator|&&
name|SDNodeBits
operator|.
name|IsMemIntrinsic
return|;
block|}
comment|/// Test if this node is a strict floating point pseudo-op.
name|bool
name|isStrictFPOpcode
parameter_list|()
block|{
switch|switch
condition|(
name|NodeType
condition|)
block|{
default|default:
return|return
name|false
return|;
case|case
name|ISD
operator|::
name|STRICT_FADD
case|:
case|case
name|ISD
operator|::
name|STRICT_FSUB
case|:
case|case
name|ISD
operator|::
name|STRICT_FMUL
case|:
case|case
name|ISD
operator|::
name|STRICT_FDIV
case|:
case|case
name|ISD
operator|::
name|STRICT_FREM
case|:
case|case
name|ISD
operator|::
name|STRICT_FSQRT
case|:
case|case
name|ISD
operator|::
name|STRICT_FPOW
case|:
case|case
name|ISD
operator|::
name|STRICT_FPOWI
case|:
case|case
name|ISD
operator|::
name|STRICT_FSIN
case|:
case|case
name|ISD
operator|::
name|STRICT_FCOS
case|:
case|case
name|ISD
operator|::
name|STRICT_FEXP
case|:
case|case
name|ISD
operator|::
name|STRICT_FEXP2
case|:
case|case
name|ISD
operator|::
name|STRICT_FLOG
case|:
case|case
name|ISD
operator|::
name|STRICT_FLOG10
case|:
case|case
name|ISD
operator|::
name|STRICT_FLOG2
case|:
case|case
name|ISD
operator|::
name|STRICT_FRINT
case|:
case|case
name|ISD
operator|::
name|STRICT_FNEARBYINT
case|:
return|return
name|true
return|;
block|}
block|}
comment|/// Test if this node has a post-isel opcode, directly
comment|/// corresponding to a MachineInstr opcode.
name|bool
name|isMachineOpcode
argument_list|()
specifier|const
block|{
return|return
name|NodeType
operator|<
literal|0
return|;
block|}
comment|/// This may only be called if isMachineOpcode returns
comment|/// true. It returns the MachineInstr opcode value that the node's opcode
comment|/// corresponds to.
name|unsigned
name|getMachineOpcode
argument_list|()
specifier|const
block|{
name|assert
argument_list|(
name|isMachineOpcode
argument_list|()
operator|&&
literal|"Not a MachineInstr opcode!"
argument_list|)
block|;
return|return
operator|~
name|NodeType
return|;
block|}
name|bool
name|getHasDebugValue
argument_list|()
specifier|const
block|{
return|return
name|SDNodeBits
operator|.
name|HasDebugValue
return|;
block|}
name|void
name|setHasDebugValue
parameter_list|(
name|bool
name|b
parameter_list|)
block|{
name|SDNodeBits
operator|.
name|HasDebugValue
operator|=
name|b
expr_stmt|;
block|}
comment|/// Return true if there are no uses of this node.
name|bool
name|use_empty
argument_list|()
specifier|const
block|{
return|return
name|UseList
operator|==
name|nullptr
return|;
block|}
comment|/// Return true if there is exactly one use of this node.
name|bool
name|hasOneUse
argument_list|()
specifier|const
block|{
return|return
operator|!
name|use_empty
argument_list|()
operator|&&
name|std
operator|::
name|next
argument_list|(
name|use_begin
argument_list|()
argument_list|)
operator|==
name|use_end
argument_list|()
return|;
block|}
comment|/// Return the number of uses of this node. This method takes
comment|/// time proportional to the number of uses.
name|size_t
name|use_size
argument_list|()
specifier|const
block|{
return|return
name|std
operator|::
name|distance
argument_list|(
name|use_begin
argument_list|()
argument_list|,
name|use_end
argument_list|()
argument_list|)
return|;
block|}
comment|/// Return the unique node id.
name|int
name|getNodeId
argument_list|()
specifier|const
block|{
return|return
name|NodeId
return|;
block|}
comment|/// Set unique node id.
name|void
name|setNodeId
parameter_list|(
name|int
name|Id
parameter_list|)
block|{
name|NodeId
operator|=
name|Id
expr_stmt|;
block|}
comment|/// Return the node ordering.
name|unsigned
name|getIROrder
argument_list|()
specifier|const
block|{
return|return
name|IROrder
return|;
block|}
comment|/// Set the node ordering.
name|void
name|setIROrder
parameter_list|(
name|unsigned
name|Order
parameter_list|)
block|{
name|IROrder
operator|=
name|Order
expr_stmt|;
block|}
comment|/// Return the source location info.
specifier|const
name|DebugLoc
operator|&
name|getDebugLoc
argument_list|()
specifier|const
block|{
return|return
name|debugLoc
return|;
block|}
comment|/// Set source location info.  Try to avoid this, putting
comment|/// it in the constructor is preferable.
name|void
name|setDebugLoc
parameter_list|(
name|DebugLoc
name|dl
parameter_list|)
block|{
name|debugLoc
operator|=
name|std
operator|::
name|move
argument_list|(
name|dl
argument_list|)
expr_stmt|;
block|}
comment|/// This class provides iterator support for SDUse
comment|/// operands that use a specific SDNode.
name|class
name|use_iterator
range|:
name|public
name|std
operator|::
name|iterator
operator|<
name|std
operator|::
name|forward_iterator_tag
decl_stmt|,
name|SDUse
decl_stmt|,
name|ptrdiff_t
decl|>
block|{
name|friend
name|class
name|SDNode
decl_stmt|;
name|SDUse
modifier|*
name|Op
init|=
name|nullptr
decl_stmt|;
name|explicit
name|use_iterator
argument_list|(
name|SDUse
operator|*
name|op
argument_list|)
operator|:
name|Op
argument_list|(
argument|op
argument_list|)
block|{}
name|public
operator|:
name|using
name|reference
operator|=
name|std
operator|::
name|iterator
operator|<
name|std
operator|::
name|forward_iterator_tag
operator|,
name|SDUse
operator|,
name|ptrdiff_t
operator|>
operator|::
name|reference
expr_stmt|;
name|using
name|pointer
init|=
name|std
operator|::
name|iterator
operator|<
name|std
operator|::
name|forward_iterator_tag
decl_stmt|,
name|SDUse
decl_stmt|,
name|ptrdiff_t
decl|>::
name|pointer
decl_stmt|;
name|use_iterator
argument_list|()
operator|=
expr|default
expr_stmt|;
name|use_iterator
argument_list|(
specifier|const
name|use_iterator
operator|&
name|I
argument_list|)
operator|:
name|Op
argument_list|(
argument|I.Op
argument_list|)
block|{}
name|bool
name|operator
operator|==
operator|(
specifier|const
name|use_iterator
operator|&
name|x
operator|)
specifier|const
block|{
return|return
name|Op
operator|==
name|x
operator|.
name|Op
return|;
block|}
name|bool
name|operator
operator|!=
operator|(
specifier|const
name|use_iterator
operator|&
name|x
operator|)
specifier|const
block|{
return|return
operator|!
name|operator
operator|==
operator|(
name|x
operator|)
return|;
block|}
comment|/// Return true if this iterator is at the end of uses list.
name|bool
name|atEnd
argument_list|()
specifier|const
block|{
return|return
name|Op
operator|==
name|nullptr
return|;
block|}
comment|// Iterator traversal: forward iteration only.
name|use_iterator
operator|&
name|operator
operator|++
operator|(
operator|)
block|{
comment|// Preincrement
name|assert
argument_list|(
name|Op
operator|&&
literal|"Cannot increment end iterator!"
argument_list|)
block|;
name|Op
operator|=
name|Op
operator|->
name|getNext
argument_list|()
block|;
return|return
operator|*
name|this
return|;
block|}
name|use_iterator
name|operator
operator|++
operator|(
name|int
operator|)
block|{
comment|// Postincrement
name|use_iterator
name|tmp
operator|=
operator|*
name|this
block|;
operator|++
operator|*
name|this
block|;
return|return
name|tmp
return|;
block|}
comment|/// Retrieve a pointer to the current user node.
name|SDNode
operator|*
name|operator
operator|*
operator|(
operator|)
specifier|const
block|{
name|assert
argument_list|(
name|Op
operator|&&
literal|"Cannot dereference end iterator!"
argument_list|)
block|;
return|return
name|Op
operator|->
name|getUser
argument_list|()
return|;
block|}
name|SDNode
operator|*
name|operator
operator|->
expr|(
block|)
decl|const
block|{
return|return
name|operator
operator|*
operator|(
operator|)
return|;
block|}
name|SDUse
operator|&
name|getUse
argument_list|()
specifier|const
block|{
return|return
operator|*
name|Op
return|;
block|}
comment|/// Retrieve the operand # of this use in its user.
name|unsigned
name|getOperandNo
argument_list|()
specifier|const
block|{
name|assert
argument_list|(
name|Op
operator|&&
literal|"Cannot dereference end iterator!"
argument_list|)
block|;
return|return
call|(
name|unsigned
call|)
argument_list|(
name|Op
operator|-
name|Op
operator|->
name|getUser
argument_list|()
operator|->
name|OperandList
argument_list|)
return|;
block|}
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_comment
comment|/// Provide iteration support to walk over all uses of an SDNode.
end_comment

begin_expr_stmt
name|use_iterator
name|use_begin
argument_list|()
specifier|const
block|{
return|return
name|use_iterator
argument_list|(
name|UseList
argument_list|)
return|;
block|}
end_expr_stmt

begin_function
specifier|static
name|use_iterator
name|use_end
parameter_list|()
block|{
return|return
name|use_iterator
argument_list|(
name|nullptr
argument_list|)
return|;
block|}
end_function

begin_expr_stmt
specifier|inline
name|iterator_range
operator|<
name|use_iterator
operator|>
name|uses
argument_list|()
block|{
return|return
name|make_range
argument_list|(
name|use_begin
argument_list|()
argument_list|,
name|use_end
argument_list|()
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
specifier|inline
name|iterator_range
operator|<
name|use_iterator
operator|>
name|uses
argument_list|()
specifier|const
block|{
return|return
name|make_range
argument_list|(
name|use_begin
argument_list|()
argument_list|,
name|use_end
argument_list|()
argument_list|)
return|;
block|}
end_expr_stmt

begin_comment
comment|/// Return true if there are exactly NUSES uses of the indicated value.
end_comment

begin_comment
comment|/// This method ignores uses of other values defined by this operation.
end_comment

begin_decl_stmt
name|bool
name|hasNUsesOfValue
argument_list|(
name|unsigned
name|NUses
argument_list|,
name|unsigned
name|Value
argument_list|)
decl|const
decl_stmt|;
end_decl_stmt

begin_comment
comment|/// Return true if there are any use of the indicated value.
end_comment

begin_comment
comment|/// This method ignores uses of other values defined by this operation.
end_comment

begin_decl_stmt
name|bool
name|hasAnyUseOfValue
argument_list|(
name|unsigned
name|Value
argument_list|)
decl|const
decl_stmt|;
end_decl_stmt

begin_comment
comment|/// Return true if this node is the only use of N.
end_comment

begin_decl_stmt
name|bool
name|isOnlyUserOf
argument_list|(
specifier|const
name|SDNode
operator|*
name|N
argument_list|)
decl|const
decl_stmt|;
end_decl_stmt

begin_comment
comment|/// Return true if this node is an operand of N.
end_comment

begin_decl_stmt
name|bool
name|isOperandOf
argument_list|(
specifier|const
name|SDNode
operator|*
name|N
argument_list|)
decl|const
decl_stmt|;
end_decl_stmt

begin_comment
comment|/// Return true if this node is a predecessor of N.
end_comment

begin_comment
comment|/// NOTE: Implemented on top of hasPredecessor and every bit as
end_comment

begin_comment
comment|/// expensive. Use carefully.
end_comment

begin_decl_stmt
name|bool
name|isPredecessorOf
argument_list|(
specifier|const
name|SDNode
operator|*
name|N
argument_list|)
decl|const
block|{
return|return
name|N
operator|->
name|hasPredecessor
argument_list|(
name|this
argument_list|)
return|;
block|}
end_decl_stmt

begin_comment
comment|/// Return true if N is a predecessor of this node.
end_comment

begin_comment
comment|/// N is either an operand of this node, or can be reached by recursively
end_comment

begin_comment
comment|/// traversing up the operands.
end_comment

begin_comment
comment|/// NOTE: This is an expensive method. Use it carefully.
end_comment

begin_decl_stmt
name|bool
name|hasPredecessor
argument_list|(
specifier|const
name|SDNode
operator|*
name|N
argument_list|)
decl|const
decl_stmt|;
end_decl_stmt

begin_comment
comment|/// Returns true if N is a predecessor of any node in Worklist. This
end_comment

begin_comment
comment|/// helper keeps Visited and Worklist sets externally to allow unions
end_comment

begin_comment
comment|/// searches to be performed in parallel, caching of results across
end_comment

begin_comment
comment|/// queries and incremental addition to Worklist. Stops early if N is
end_comment

begin_comment
comment|/// found but will resume. Remember to clear Visited and Worklists
end_comment

begin_comment
comment|/// if DAG changes.
end_comment

begin_decl_stmt
specifier|static
name|bool
name|hasPredecessorHelper
argument_list|(
specifier|const
name|SDNode
operator|*
name|N
argument_list|,
name|SmallPtrSetImpl
operator|<
specifier|const
name|SDNode
operator|*
operator|>
operator|&
name|Visited
argument_list|,
name|SmallVectorImpl
operator|<
specifier|const
name|SDNode
operator|*
operator|>
operator|&
name|Worklist
argument_list|)
block|{
if|if
condition|(
name|Visited
operator|.
name|count
argument_list|(
name|N
argument_list|)
condition|)
return|return
name|true
return|;
while|while
condition|(
operator|!
name|Worklist
operator|.
name|empty
argument_list|()
condition|)
block|{
specifier|const
name|SDNode
modifier|*
name|M
init|=
name|Worklist
operator|.
name|pop_back_val
argument_list|()
decl_stmt|;
name|bool
name|Found
init|=
name|false
decl_stmt|;
for|for
control|(
specifier|const
name|SDValue
modifier|&
name|OpV
range|:
name|M
operator|->
name|op_values
argument_list|()
control|)
block|{
name|SDNode
modifier|*
name|Op
init|=
name|OpV
operator|.
name|getNode
argument_list|()
decl_stmt|;
if|if
condition|(
name|Visited
operator|.
name|insert
argument_list|(
name|Op
argument_list|)
operator|.
name|second
condition|)
name|Worklist
operator|.
name|push_back
argument_list|(
name|Op
argument_list|)
expr_stmt|;
if|if
condition|(
name|Op
operator|==
name|N
condition|)
name|Found
operator|=
name|true
expr_stmt|;
block|}
if|if
condition|(
name|Found
condition|)
return|return
name|true
return|;
block|}
return|return
name|false
return|;
block|}
end_decl_stmt

begin_comment
comment|/// Return true if all the users of N are contained in Nodes.
end_comment

begin_comment
comment|/// NOTE: Requires at least one match, but doesn't require them all.
end_comment

begin_decl_stmt
specifier|static
name|bool
name|areOnlyUsersOf
argument_list|(
name|ArrayRef
operator|<
specifier|const
name|SDNode
operator|*
operator|>
name|Nodes
argument_list|,
specifier|const
name|SDNode
operator|*
name|N
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/// Return the number of values used by this operation.
end_comment

begin_expr_stmt
name|unsigned
name|getNumOperands
argument_list|()
specifier|const
block|{
return|return
name|NumOperands
return|;
block|}
end_expr_stmt

begin_comment
comment|/// Helper method returns the integer value of a ConstantSDNode operand.
end_comment

begin_decl_stmt
specifier|inline
name|uint64_t
name|getConstantOperandVal
argument_list|(
name|unsigned
name|Num
argument_list|)
decl|const
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|SDValue
modifier|&
name|getOperand
argument_list|(
name|unsigned
name|Num
argument_list|)
decl|const
block|{
name|assert
argument_list|(
name|Num
operator|<
name|NumOperands
operator|&&
literal|"Invalid child # of SDNode!"
argument_list|)
expr_stmt|;
return|return
name|OperandList
index|[
name|Num
index|]
return|;
block|}
end_decl_stmt

begin_decl_stmt
name|using
name|op_iterator
init|=
name|SDUse
operator|*
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|op_iterator
name|op_begin
argument_list|()
specifier|const
block|{
return|return
name|OperandList
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|op_iterator
name|op_end
argument_list|()
specifier|const
block|{
return|return
name|OperandList
operator|+
name|NumOperands
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|ArrayRef
operator|<
name|SDUse
operator|>
name|ops
argument_list|()
specifier|const
block|{
return|return
name|makeArrayRef
argument_list|(
name|op_begin
argument_list|()
argument_list|,
name|op_end
argument_list|()
argument_list|)
return|;
block|}
end_expr_stmt

begin_comment
comment|/// Iterator for directly iterating over the operand SDValue's.
end_comment

begin_decl_stmt
name|struct
name|value_op_iterator
range|:
name|iterator_adaptor_base
operator|<
name|value_op_iterator
decl_stmt|,
name|op_iterator
decl_stmt|,
name|std
decl|::
name|random_access_iterator_tag
decl_stmt|,
name|SDValue
decl_stmt|,
name|ptrdiff_t
decl_stmt|,
name|value_op_iterator
modifier|*
decl_stmt|,
name|value_op_iterator
modifier|*
decl|>
block|{
name|explicit
name|value_op_iterator
argument_list|(
name|SDUse
operator|*
name|U
operator|=
name|nullptr
argument_list|)
operator|:
name|iterator_adaptor_base
argument_list|(
argument|U
argument_list|)
block|{}
specifier|const
name|SDValue
operator|&
name|operator
operator|*
operator|(
operator|)
specifier|const
block|{
return|return
name|I
operator|->
name|get
argument_list|()
return|;
block|}
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_expr_stmt
name|iterator_range
operator|<
name|value_op_iterator
operator|>
name|op_values
argument_list|()
specifier|const
block|{
return|return
name|make_range
argument_list|(
name|value_op_iterator
argument_list|(
name|op_begin
argument_list|()
argument_list|)
argument_list|,
name|value_op_iterator
argument_list|(
name|op_end
argument_list|()
argument_list|)
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|SDVTList
name|getVTList
argument_list|()
specifier|const
block|{
name|SDVTList
name|X
operator|=
block|{
name|ValueList
block|,
name|NumValues
block|}
block|;
return|return
name|X
return|;
block|}
end_expr_stmt

begin_comment
comment|/// If this node has a glue operand, return the node
end_comment

begin_comment
comment|/// to which the glue operand points. Otherwise return NULL.
end_comment

begin_expr_stmt
name|SDNode
operator|*
name|getGluedNode
argument_list|()
specifier|const
block|{
if|if
condition|(
name|getNumOperands
argument_list|()
operator|!=
literal|0
operator|&&
name|getOperand
argument_list|(
name|getNumOperands
argument_list|()
operator|-
literal|1
argument_list|)
operator|.
name|getValueType
argument_list|()
operator|==
name|MVT
operator|::
name|Glue
condition|)
return|return
name|getOperand
argument_list|(
name|getNumOperands
argument_list|()
operator|-
literal|1
argument_list|)
operator|.
name|getNode
argument_list|()
return|;
end_expr_stmt

begin_return
return|return
name|nullptr
return|;
end_return

begin_comment
unit|}
comment|/// If this node has a glue value with a user, return
end_comment

begin_comment
comment|/// the user (there is at most one). Otherwise return NULL.
end_comment

begin_expr_stmt
unit|SDNode
operator|*
name|getGluedUser
argument_list|()
specifier|const
block|{
for|for
control|(
name|use_iterator
name|UI
init|=
name|use_begin
argument_list|()
init|,
name|UE
init|=
name|use_end
argument_list|()
init|;
name|UI
operator|!=
name|UE
condition|;
operator|++
name|UI
control|)
if|if
condition|(
name|UI
operator|.
name|getUse
argument_list|()
operator|.
name|get
argument_list|()
operator|.
name|getValueType
argument_list|()
operator|==
name|MVT
operator|::
name|Glue
condition|)
return|return
operator|*
name|UI
return|;
end_expr_stmt

begin_return
return|return
name|nullptr
return|;
end_return

begin_expr_stmt
unit|}    const
name|SDNodeFlags
name|getFlags
argument_list|()
specifier|const
block|{
return|return
name|Flags
return|;
block|}
end_expr_stmt

begin_function
name|void
name|setFlags
parameter_list|(
name|SDNodeFlags
name|NewFlags
parameter_list|)
block|{
name|Flags
operator|=
name|NewFlags
expr_stmt|;
block|}
end_function

begin_comment
comment|/// Clear any flags in this node that aren't also set in Flags.
end_comment

begin_comment
comment|/// If Flags is not in a defined state then this has no effect.
end_comment

begin_function_decl
name|void
name|intersectFlagsWith
parameter_list|(
specifier|const
name|SDNodeFlags
name|Flags
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/// Return the number of values defined/returned by this operator.
end_comment

begin_expr_stmt
name|unsigned
name|getNumValues
argument_list|()
specifier|const
block|{
return|return
name|NumValues
return|;
block|}
end_expr_stmt

begin_comment
comment|/// Return the type of a specified result.
end_comment

begin_decl_stmt
name|EVT
name|getValueType
argument_list|(
name|unsigned
name|ResNo
argument_list|)
decl|const
block|{
name|assert
argument_list|(
name|ResNo
operator|<
name|NumValues
operator|&&
literal|"Illegal result number!"
argument_list|)
expr_stmt|;
return|return
name|ValueList
index|[
name|ResNo
index|]
return|;
block|}
end_decl_stmt

begin_comment
comment|/// Return the type of a specified result as a simple type.
end_comment

begin_decl_stmt
name|MVT
name|getSimpleValueType
argument_list|(
name|unsigned
name|ResNo
argument_list|)
decl|const
block|{
return|return
name|getValueType
argument_list|(
name|ResNo
argument_list|)
operator|.
name|getSimpleVT
argument_list|()
return|;
block|}
end_decl_stmt

begin_comment
comment|/// Returns MVT::getSizeInBits(getValueType(ResNo)).
end_comment

begin_decl_stmt
name|unsigned
name|getValueSizeInBits
argument_list|(
name|unsigned
name|ResNo
argument_list|)
decl|const
block|{
return|return
name|getValueType
argument_list|(
name|ResNo
argument_list|)
operator|.
name|getSizeInBits
argument_list|()
return|;
block|}
end_decl_stmt

begin_decl_stmt
name|using
name|value_iterator
init|=
specifier|const
name|EVT
operator|*
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|value_iterator
name|value_begin
argument_list|()
specifier|const
block|{
return|return
name|ValueList
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|value_iterator
name|value_end
argument_list|()
specifier|const
block|{
return|return
name|ValueList
operator|+
name|NumValues
return|;
block|}
end_expr_stmt

begin_comment
comment|/// Return the opcode of this operation for printing.
end_comment

begin_expr_stmt
name|std
operator|::
name|string
name|getOperationName
argument_list|(
argument|const SelectionDAG *G = nullptr
argument_list|)
specifier|const
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|getIndexedModeName
argument_list|(
name|ISD
operator|::
name|MemIndexedMode
name|AM
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|print_types
argument_list|(
name|raw_ostream
operator|&
name|OS
argument_list|,
specifier|const
name|SelectionDAG
operator|*
name|G
argument_list|)
decl|const
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|print_details
argument_list|(
name|raw_ostream
operator|&
name|OS
argument_list|,
specifier|const
name|SelectionDAG
operator|*
name|G
argument_list|)
decl|const
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|print
argument_list|(
name|raw_ostream
operator|&
name|OS
argument_list|,
specifier|const
name|SelectionDAG
operator|*
name|G
operator|=
name|nullptr
argument_list|)
decl|const
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|printr
argument_list|(
name|raw_ostream
operator|&
name|OS
argument_list|,
specifier|const
name|SelectionDAG
operator|*
name|G
operator|=
name|nullptr
argument_list|)
decl|const
decl_stmt|;
end_decl_stmt

begin_comment
comment|/// Print a SelectionDAG node and all children down to
end_comment

begin_comment
comment|/// the leaves.  The given SelectionDAG allows target-specific nodes
end_comment

begin_comment
comment|/// to be printed in human-readable form.  Unlike printr, this will
end_comment

begin_comment
comment|/// print the whole DAG, including children that appear multiple
end_comment

begin_comment
comment|/// times.
end_comment

begin_comment
comment|///
end_comment

begin_decl_stmt
name|void
name|printrFull
argument_list|(
name|raw_ostream
operator|&
name|O
argument_list|,
specifier|const
name|SelectionDAG
operator|*
name|G
operator|=
name|nullptr
argument_list|)
decl|const
decl_stmt|;
end_decl_stmt

begin_comment
comment|/// Print a SelectionDAG node and children up to
end_comment

begin_comment
comment|/// depth "depth."  The given SelectionDAG allows target-specific
end_comment

begin_comment
comment|/// nodes to be printed in human-readable form.  Unlike printr, this
end_comment

begin_comment
comment|/// will print children that appear multiple times wherever they are
end_comment

begin_comment
comment|/// used.
end_comment

begin_comment
comment|///
end_comment

begin_decl_stmt
name|void
name|printrWithDepth
argument_list|(
name|raw_ostream
operator|&
name|O
argument_list|,
specifier|const
name|SelectionDAG
operator|*
name|G
operator|=
name|nullptr
argument_list|,
name|unsigned
name|depth
operator|=
literal|100
argument_list|)
decl|const
decl_stmt|;
end_decl_stmt

begin_comment
comment|/// Dump this node, for debugging.
end_comment

begin_expr_stmt
name|void
name|dump
argument_list|()
specifier|const
expr_stmt|;
end_expr_stmt

begin_comment
comment|/// Dump (recursively) this node and its use-def subgraph.
end_comment

begin_expr_stmt
name|void
name|dumpr
argument_list|()
specifier|const
expr_stmt|;
end_expr_stmt

begin_comment
comment|/// Dump this node, for debugging.
end_comment

begin_comment
comment|/// The given SelectionDAG allows target-specific nodes to be printed
end_comment

begin_comment
comment|/// in human-readable form.
end_comment

begin_decl_stmt
name|void
name|dump
argument_list|(
specifier|const
name|SelectionDAG
operator|*
name|G
argument_list|)
decl|const
decl_stmt|;
end_decl_stmt

begin_comment
comment|/// Dump (recursively) this node and its use-def subgraph.
end_comment

begin_comment
comment|/// The given SelectionDAG allows target-specific nodes to be printed
end_comment

begin_comment
comment|/// in human-readable form.
end_comment

begin_decl_stmt
name|void
name|dumpr
argument_list|(
specifier|const
name|SelectionDAG
operator|*
name|G
argument_list|)
decl|const
decl_stmt|;
end_decl_stmt

begin_comment
comment|/// printrFull to dbgs().  The given SelectionDAG allows
end_comment

begin_comment
comment|/// target-specific nodes to be printed in human-readable form.
end_comment

begin_comment
comment|/// Unlike dumpr, this will print the whole DAG, including children
end_comment

begin_comment
comment|/// that appear multiple times.
end_comment

begin_decl_stmt
name|void
name|dumprFull
argument_list|(
specifier|const
name|SelectionDAG
operator|*
name|G
operator|=
name|nullptr
argument_list|)
decl|const
decl_stmt|;
end_decl_stmt

begin_comment
comment|/// printrWithDepth to dbgs().  The given
end_comment

begin_comment
comment|/// SelectionDAG allows target-specific nodes to be printed in
end_comment

begin_comment
comment|/// human-readable form.  Unlike dumpr, this will print children
end_comment

begin_comment
comment|/// that appear multiple times wherever they are used.
end_comment

begin_comment
comment|///
end_comment

begin_decl_stmt
name|void
name|dumprWithDepth
argument_list|(
specifier|const
name|SelectionDAG
operator|*
name|G
operator|=
name|nullptr
argument_list|,
name|unsigned
name|depth
operator|=
literal|100
argument_list|)
decl|const
decl_stmt|;
end_decl_stmt

begin_comment
comment|/// Gather unique data for the node.
end_comment

begin_decl_stmt
name|void
name|Profile
argument_list|(
name|FoldingSetNodeID
operator|&
name|ID
argument_list|)
decl|const
decl_stmt|;
end_decl_stmt

begin_comment
comment|/// This method should only be used by the SDUse class.
end_comment

begin_function
name|void
name|addUse
parameter_list|(
name|SDUse
modifier|&
name|U
parameter_list|)
block|{
name|U
operator|.
name|addToList
argument_list|(
operator|&
name|UseList
argument_list|)
expr_stmt|;
block|}
end_function

begin_label
name|protected
label|:
end_label

begin_function
specifier|static
name|SDVTList
name|getSDVTList
parameter_list|(
name|EVT
name|VT
parameter_list|)
block|{
name|SDVTList
name|Ret
init|=
block|{
name|getValueTypeList
argument_list|(
name|VT
argument_list|)
block|,
literal|1
block|}
decl_stmt|;
return|return
name|Ret
return|;
block|}
end_function

begin_comment
comment|/// Create an SDNode.
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|/// SDNodes are created without any operands, and never own the operand
end_comment

begin_comment
comment|/// storage. To add operands, see SelectionDAG::createOperands.
end_comment

begin_macro
name|SDNode
argument_list|(
argument|unsigned Opc
argument_list|,
argument|unsigned Order
argument_list|,
argument|DebugLoc dl
argument_list|,
argument|SDVTList VTs
argument_list|)
end_macro

begin_expr_stmt
unit|:
name|NodeType
argument_list|(
name|Opc
argument_list|)
operator|,
name|ValueList
argument_list|(
name|VTs
operator|.
name|VTs
argument_list|)
operator|,
name|NumValues
argument_list|(
name|VTs
operator|.
name|NumVTs
argument_list|)
operator|,
name|IROrder
argument_list|(
name|Order
argument_list|)
operator|,
name|debugLoc
argument_list|(
argument|std::move(dl)
argument_list|)
block|{
name|memset
argument_list|(
operator|&
name|RawSDNodeBits
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|RawSDNodeBits
argument_list|)
argument_list|)
block|;
name|assert
argument_list|(
name|debugLoc
operator|.
name|hasTrivialDestructor
argument_list|()
operator|&&
literal|"Expected trivial destructor"
argument_list|)
block|;
name|assert
argument_list|(
name|NumValues
operator|==
name|VTs
operator|.
name|NumVTs
operator|&&
literal|"NumValues wasn't wide enough for its operands!"
argument_list|)
block|;   }
comment|/// Release the operands and set this node to have zero operands.
name|void
name|DropOperands
argument_list|()
expr_stmt|;
end_expr_stmt

begin_comment
unit|};
comment|/// Wrapper class for IR location info (IR ordering and DebugLoc) to be passed
end_comment

begin_comment
comment|/// into SDNode creation functions.
end_comment

begin_comment
comment|/// When an SDNode is created from the DAGBuilder, the DebugLoc is extracted
end_comment

begin_comment
comment|/// from the original Instruction, and IROrder is the ordinal position of
end_comment

begin_comment
comment|/// the instruction.
end_comment

begin_comment
comment|/// When an SDNode is created after the DAG is being built, both DebugLoc and
end_comment

begin_comment
comment|/// the IROrder are propagated from the original SDNode.
end_comment

begin_comment
comment|/// So SDLoc class provides two constructors besides the default one, one to
end_comment

begin_comment
comment|/// be used by the DAGBuilder, the other to be used by others.
end_comment

begin_decl_stmt
name|class
name|SDLoc
block|{
name|private
label|:
name|DebugLoc
name|DL
decl_stmt|;
name|int
name|IROrder
init|=
literal|0
decl_stmt|;
name|public
label|:
name|SDLoc
argument_list|()
operator|=
expr|default
expr_stmt|;
name|SDLoc
argument_list|(
specifier|const
name|SDNode
operator|*
name|N
argument_list|)
operator|:
name|DL
argument_list|(
name|N
operator|->
name|getDebugLoc
argument_list|()
argument_list|)
operator|,
name|IROrder
argument_list|(
argument|N->getIROrder()
argument_list|)
block|{}
name|SDLoc
argument_list|(
argument|const SDValue V
argument_list|)
operator|:
name|SDLoc
argument_list|(
argument|V.getNode()
argument_list|)
block|{}
name|SDLoc
argument_list|(
argument|const Instruction *I
argument_list|,
argument|int Order
argument_list|)
operator|:
name|IROrder
argument_list|(
argument|Order
argument_list|)
block|{
name|assert
argument_list|(
name|Order
operator|>=
literal|0
operator|&&
literal|"bad IROrder"
argument_list|)
block|;
if|if
condition|(
name|I
condition|)
name|DL
operator|=
name|I
operator|->
name|getDebugLoc
argument_list|()
expr_stmt|;
block|}
name|unsigned
name|getIROrder
argument_list|()
specifier|const
block|{
return|return
name|IROrder
return|;
block|}
specifier|const
name|DebugLoc
operator|&
name|getDebugLoc
argument_list|()
specifier|const
block|{
return|return
name|DL
return|;
block|}
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_comment
comment|// Define inline functions from the SDValue class.
end_comment

begin_expr_stmt
specifier|inline
name|SDValue
operator|::
name|SDValue
argument_list|(
argument|SDNode *node
argument_list|,
argument|unsigned resno
argument_list|)
operator|:
name|Node
argument_list|(
name|node
argument_list|)
operator|,
name|ResNo
argument_list|(
argument|resno
argument_list|)
block|{
comment|// Explicitly check for !ResNo to avoid use-after-free, because there are
comment|// callers that use SDValue(N, 0) with a deleted N to indicate successful
comment|// combines.
name|assert
argument_list|(
operator|(
operator|!
name|Node
operator|||
operator|!
name|ResNo
operator|||
name|ResNo
operator|<
name|Node
operator|->
name|getNumValues
argument_list|()
operator|)
operator|&&
literal|"Invalid result number for the given node!"
argument_list|)
block|;
name|assert
argument_list|(
name|ResNo
operator|<
operator|-
literal|2U
operator|&&
literal|"Cannot use result numbers reserved for DenseMaps."
argument_list|)
block|; }
specifier|inline
name|unsigned
name|SDValue
operator|::
name|getOpcode
argument_list|()
specifier|const
block|{
return|return
name|Node
operator|->
name|getOpcode
argument_list|()
return|;
block|}
end_expr_stmt

begin_expr_stmt
specifier|inline
name|EVT
name|SDValue
operator|::
name|getValueType
argument_list|()
specifier|const
block|{
return|return
name|Node
operator|->
name|getValueType
argument_list|(
name|ResNo
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
specifier|inline
name|unsigned
name|SDValue
operator|::
name|getNumOperands
argument_list|()
specifier|const
block|{
return|return
name|Node
operator|->
name|getNumOperands
argument_list|()
return|;
block|}
end_expr_stmt

begin_expr_stmt
specifier|inline
specifier|const
name|SDValue
operator|&
name|SDValue
operator|::
name|getOperand
argument_list|(
argument|unsigned i
argument_list|)
specifier|const
block|{
return|return
name|Node
operator|->
name|getOperand
argument_list|(
name|i
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
specifier|inline
name|uint64_t
name|SDValue
operator|::
name|getConstantOperandVal
argument_list|(
argument|unsigned i
argument_list|)
specifier|const
block|{
return|return
name|Node
operator|->
name|getConstantOperandVal
argument_list|(
name|i
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
specifier|inline
name|bool
name|SDValue
operator|::
name|isTargetOpcode
argument_list|()
specifier|const
block|{
return|return
name|Node
operator|->
name|isTargetOpcode
argument_list|()
return|;
block|}
end_expr_stmt

begin_expr_stmt
specifier|inline
name|bool
name|SDValue
operator|::
name|isTargetMemoryOpcode
argument_list|()
specifier|const
block|{
return|return
name|Node
operator|->
name|isTargetMemoryOpcode
argument_list|()
return|;
block|}
end_expr_stmt

begin_expr_stmt
specifier|inline
name|bool
name|SDValue
operator|::
name|isMachineOpcode
argument_list|()
specifier|const
block|{
return|return
name|Node
operator|->
name|isMachineOpcode
argument_list|()
return|;
block|}
end_expr_stmt

begin_expr_stmt
specifier|inline
name|unsigned
name|SDValue
operator|::
name|getMachineOpcode
argument_list|()
specifier|const
block|{
return|return
name|Node
operator|->
name|getMachineOpcode
argument_list|()
return|;
block|}
end_expr_stmt

begin_expr_stmt
specifier|inline
name|bool
name|SDValue
operator|::
name|isUndef
argument_list|()
specifier|const
block|{
return|return
name|Node
operator|->
name|isUndef
argument_list|()
return|;
block|}
end_expr_stmt

begin_expr_stmt
specifier|inline
name|bool
name|SDValue
operator|::
name|use_empty
argument_list|()
specifier|const
block|{
return|return
operator|!
name|Node
operator|->
name|hasAnyUseOfValue
argument_list|(
name|ResNo
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
specifier|inline
name|bool
name|SDValue
operator|::
name|hasOneUse
argument_list|()
specifier|const
block|{
return|return
name|Node
operator|->
name|hasNUsesOfValue
argument_list|(
literal|1
argument_list|,
name|ResNo
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
specifier|inline
specifier|const
name|DebugLoc
operator|&
name|SDValue
operator|::
name|getDebugLoc
argument_list|()
specifier|const
block|{
return|return
name|Node
operator|->
name|getDebugLoc
argument_list|()
return|;
block|}
end_expr_stmt

begin_expr_stmt
specifier|inline
name|void
name|SDValue
operator|::
name|dump
argument_list|()
specifier|const
block|{
return|return
name|Node
operator|->
name|dump
argument_list|()
return|;
block|}
end_expr_stmt

begin_expr_stmt
specifier|inline
name|void
name|SDValue
operator|::
name|dumpr
argument_list|()
specifier|const
block|{
return|return
name|Node
operator|->
name|dumpr
argument_list|()
return|;
block|}
end_expr_stmt

begin_comment
comment|// Define inline functions from the SDUse class.
end_comment

begin_expr_stmt
specifier|inline
name|void
name|SDUse
operator|::
name|set
argument_list|(
argument|const SDValue&V
argument_list|)
block|{
if|if
condition|(
name|Val
operator|.
name|getNode
argument_list|()
condition|)
name|removeFromList
argument_list|()
expr_stmt|;
name|Val
operator|=
name|V
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|V
operator|.
name|getNode
argument_list|()
condition|)
name|V
operator|.
name|getNode
argument_list|()
operator|->
name|addUse
argument_list|(
operator|*
name|this
argument_list|)
expr_stmt|;
end_if

begin_expr_stmt
unit|}  inline
name|void
name|SDUse
operator|::
name|setInitial
argument_list|(
argument|const SDValue&V
argument_list|)
block|{
name|Val
operator|=
name|V
block|;
name|V
operator|.
name|getNode
argument_list|()
operator|->
name|addUse
argument_list|(
operator|*
name|this
argument_list|)
block|; }
specifier|inline
name|void
name|SDUse
operator|::
name|setNode
argument_list|(
argument|SDNode *N
argument_list|)
block|{
if|if
condition|(
name|Val
operator|.
name|getNode
argument_list|()
condition|)
name|removeFromList
argument_list|()
expr_stmt|;
name|Val
operator|.
name|setNode
argument_list|(
name|N
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|N
condition|)
name|N
operator|->
name|addUse
argument_list|(
operator|*
name|this
argument_list|)
expr_stmt|;
end_if

begin_comment
unit|}
comment|/// This class is used to form a handle around another node that
end_comment

begin_comment
comment|/// is persistent and is updated across invocations of replaceAllUsesWith on its
end_comment

begin_comment
comment|/// operand.  This node should be directly created by end-users and not added to
end_comment

begin_comment
comment|/// the AllNodes list.
end_comment

begin_label
unit|class
name|HandleSDNode
label|:
end_label

begin_decl_stmt
name|public
name|SDNode
block|{
name|SDUse
name|Op
decl_stmt|;
name|public
label|:
name|explicit
name|HandleSDNode
argument_list|(
argument|SDValue X
argument_list|)
block|:
name|SDNode
argument_list|(
argument|ISD::HANDLENODE
argument_list|,
literal|0
argument_list|,
argument|DebugLoc()
argument_list|,
argument|getSDVTList(MVT::Other)
argument_list|)
block|{
comment|// HandleSDNodes are never inserted into the DAG, so they won't be
comment|// auto-numbered. Use ID 65535 as a sentinel.
name|PersistentId
operator|=
literal|0xffff
expr_stmt|;
comment|// Manually set up the operand list. This node type is special in that it's
comment|// always stack allocated and SelectionDAG does not manage its operands.
comment|// TODO: This should either (a) not be in the SDNode hierarchy, or (b) not
comment|// be so special.
name|Op
operator|.
name|setUser
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|Op
operator|.
name|setInitial
argument_list|(
name|X
argument_list|)
expr_stmt|;
name|NumOperands
operator|=
literal|1
expr_stmt|;
name|OperandList
operator|=
operator|&
name|Op
expr_stmt|;
block|}
operator|~
name|HandleSDNode
argument_list|()
expr_stmt|;
specifier|const
name|SDValue
operator|&
name|getValue
argument_list|()
specifier|const
block|{
return|return
name|Op
return|;
block|}
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_decl_stmt
name|class
name|AddrSpaceCastSDNode
range|:
name|public
name|SDNode
block|{
name|private
operator|:
name|unsigned
name|SrcAddrSpace
block|;
name|unsigned
name|DestAddrSpace
block|;
name|public
operator|:
name|AddrSpaceCastSDNode
argument_list|(
argument|unsigned Order
argument_list|,
argument|const DebugLoc&dl
argument_list|,
argument|EVT VT
argument_list|,
argument|unsigned SrcAS
argument_list|,
argument|unsigned DestAS
argument_list|)
block|;
name|unsigned
name|getSrcAddressSpace
argument_list|()
specifier|const
block|{
return|return
name|SrcAddrSpace
return|;
block|}
name|unsigned
name|getDestAddressSpace
argument_list|()
specifier|const
block|{
return|return
name|DestAddrSpace
return|;
block|}
specifier|static
name|bool
name|classof
argument_list|(
argument|const SDNode *N
argument_list|)
block|{
return|return
name|N
operator|->
name|getOpcode
argument_list|()
operator|==
name|ISD
operator|::
name|ADDRSPACECAST
return|;
block|}
expr|}
block|;
comment|/// This is an abstract virtual class for memory operations.
name|class
name|MemSDNode
operator|:
name|public
name|SDNode
block|{
name|private
operator|:
comment|// VT of in-memory value.
name|EVT
name|MemoryVT
block|;
name|protected
operator|:
comment|/// Memory reference information.
name|MachineMemOperand
operator|*
name|MMO
block|;
name|public
operator|:
name|MemSDNode
argument_list|(
argument|unsigned Opc
argument_list|,
argument|unsigned Order
argument_list|,
argument|const DebugLoc&dl
argument_list|,
argument|SDVTList VTs
argument_list|,
argument|EVT MemoryVT
argument_list|,
argument|MachineMemOperand *MMO
argument_list|)
block|;
name|bool
name|readMem
argument_list|()
specifier|const
block|{
return|return
name|MMO
operator|->
name|isLoad
argument_list|()
return|;
block|}
name|bool
name|writeMem
argument_list|()
specifier|const
block|{
return|return
name|MMO
operator|->
name|isStore
argument_list|()
return|;
block|}
comment|/// Returns alignment and volatility of the memory access
name|unsigned
name|getOriginalAlignment
argument_list|()
specifier|const
block|{
return|return
name|MMO
operator|->
name|getBaseAlignment
argument_list|()
return|;
block|}
name|unsigned
name|getAlignment
argument_list|()
specifier|const
block|{
return|return
name|MMO
operator|->
name|getAlignment
argument_list|()
return|;
block|}
comment|/// Return the SubclassData value, without HasDebugValue. This contains an
comment|/// encoding of the volatile flag, as well as bits used by subclasses. This
comment|/// function should only be used to compute a FoldingSetNodeID value.
comment|/// The HasDebugValue bit is masked out because CSE map needs to match
comment|/// nodes with debug info with nodes without debug info.
name|unsigned
name|getRawSubclassData
argument_list|()
specifier|const
block|{
name|uint16_t
name|Data
block|;
expr|union
block|{
name|char
name|RawSDNodeBits
index|[
sizeof|sizeof
argument_list|(
name|uint16_t
argument_list|)
index|]
block|;
name|SDNodeBitfields
name|SDNodeBits
block|;     }
block|;
name|memcpy
argument_list|(
operator|&
name|RawSDNodeBits
argument_list|,
operator|&
name|this
operator|->
name|RawSDNodeBits
argument_list|,
sizeof|sizeof
argument_list|(
name|this
operator|->
name|RawSDNodeBits
argument_list|)
argument_list|)
block|;
name|SDNodeBits
operator|.
name|HasDebugValue
operator|=
literal|0
block|;
name|memcpy
argument_list|(
operator|&
name|Data
argument_list|,
operator|&
name|RawSDNodeBits
argument_list|,
sizeof|sizeof
argument_list|(
name|RawSDNodeBits
argument_list|)
argument_list|)
block|;
return|return
name|Data
return|;
block|}
name|bool
name|isVolatile
argument_list|()
specifier|const
block|{
return|return
name|MemSDNodeBits
operator|.
name|IsVolatile
return|;
block|}
name|bool
name|isNonTemporal
argument_list|()
specifier|const
block|{
return|return
name|MemSDNodeBits
operator|.
name|IsNonTemporal
return|;
block|}
name|bool
name|isDereferenceable
argument_list|()
specifier|const
block|{
return|return
name|MemSDNodeBits
operator|.
name|IsDereferenceable
return|;
block|}
name|bool
name|isInvariant
argument_list|()
specifier|const
block|{
return|return
name|MemSDNodeBits
operator|.
name|IsInvariant
return|;
block|}
comment|// Returns the offset from the location of the access.
name|int64_t
name|getSrcValueOffset
argument_list|()
specifier|const
block|{
return|return
name|MMO
operator|->
name|getOffset
argument_list|()
return|;
block|}
comment|/// Returns the AA info that describes the dereference.
name|AAMDNodes
name|getAAInfo
argument_list|()
specifier|const
block|{
return|return
name|MMO
operator|->
name|getAAInfo
argument_list|()
return|;
block|}
comment|/// Returns the Ranges that describes the dereference.
specifier|const
name|MDNode
operator|*
name|getRanges
argument_list|()
specifier|const
block|{
return|return
name|MMO
operator|->
name|getRanges
argument_list|()
return|;
block|}
comment|/// Return the synchronization scope for this memory operation.
name|SynchronizationScope
name|getSynchScope
argument_list|()
specifier|const
block|{
return|return
name|MMO
operator|->
name|getSynchScope
argument_list|()
return|;
block|}
comment|/// Return the atomic ordering requirements for this memory operation. For
comment|/// cmpxchg atomic operations, return the atomic ordering requirements when
comment|/// store occurs.
name|AtomicOrdering
name|getOrdering
argument_list|()
specifier|const
block|{
return|return
name|MMO
operator|->
name|getOrdering
argument_list|()
return|;
block|}
comment|/// Return the type of the in-memory value.
name|EVT
name|getMemoryVT
argument_list|()
specifier|const
block|{
return|return
name|MemoryVT
return|;
block|}
comment|/// Return a MachineMemOperand object describing the memory
comment|/// reference performed by operation.
name|MachineMemOperand
operator|*
name|getMemOperand
argument_list|()
specifier|const
block|{
return|return
name|MMO
return|;
block|}
specifier|const
name|MachinePointerInfo
operator|&
name|getPointerInfo
argument_list|()
specifier|const
block|{
return|return
name|MMO
operator|->
name|getPointerInfo
argument_list|()
return|;
block|}
comment|/// Return the address space for the associated pointer
name|unsigned
name|getAddressSpace
argument_list|()
specifier|const
block|{
return|return
name|getPointerInfo
argument_list|()
operator|.
name|getAddrSpace
argument_list|()
return|;
block|}
comment|/// Update this MemSDNode's MachineMemOperand information
comment|/// to reflect the alignment of NewMMO, if it has a greater alignment.
comment|/// This must only be used when the new alignment applies to all users of
comment|/// this MachineMemOperand.
name|void
name|refineAlignment
argument_list|(
argument|const MachineMemOperand *NewMMO
argument_list|)
block|{
name|MMO
operator|->
name|refineAlignment
argument_list|(
name|NewMMO
argument_list|)
block|;   }
specifier|const
name|SDValue
operator|&
name|getChain
argument_list|()
specifier|const
block|{
return|return
name|getOperand
argument_list|(
literal|0
argument_list|)
return|;
block|}
specifier|const
name|SDValue
operator|&
name|getBasePtr
argument_list|()
specifier|const
block|{
return|return
name|getOperand
argument_list|(
name|getOpcode
argument_list|()
operator|==
name|ISD
operator|::
name|STORE
operator|?
literal|2
operator|:
literal|1
argument_list|)
return|;
block|}
comment|// Methods to support isa and dyn_cast
specifier|static
name|bool
name|classof
argument_list|(
argument|const SDNode *N
argument_list|)
block|{
comment|// For some targets, we lower some target intrinsics to a MemIntrinsicNode
comment|// with either an intrinsic or a target opcode.
return|return
name|N
operator|->
name|getOpcode
argument_list|()
operator|==
name|ISD
operator|::
name|LOAD
operator|||
name|N
operator|->
name|getOpcode
argument_list|()
operator|==
name|ISD
operator|::
name|STORE
operator|||
name|N
operator|->
name|getOpcode
argument_list|()
operator|==
name|ISD
operator|::
name|PREFETCH
operator|||
name|N
operator|->
name|getOpcode
argument_list|()
operator|==
name|ISD
operator|::
name|ATOMIC_CMP_SWAP
operator|||
name|N
operator|->
name|getOpcode
argument_list|()
operator|==
name|ISD
operator|::
name|ATOMIC_CMP_SWAP_WITH_SUCCESS
operator|||
name|N
operator|->
name|getOpcode
argument_list|()
operator|==
name|ISD
operator|::
name|ATOMIC_SWAP
operator|||
name|N
operator|->
name|getOpcode
argument_list|()
operator|==
name|ISD
operator|::
name|ATOMIC_LOAD_ADD
operator|||
name|N
operator|->
name|getOpcode
argument_list|()
operator|==
name|ISD
operator|::
name|ATOMIC_LOAD_SUB
operator|||
name|N
operator|->
name|getOpcode
argument_list|()
operator|==
name|ISD
operator|::
name|ATOMIC_LOAD_AND
operator|||
name|N
operator|->
name|getOpcode
argument_list|()
operator|==
name|ISD
operator|::
name|ATOMIC_LOAD_OR
operator|||
name|N
operator|->
name|getOpcode
argument_list|()
operator|==
name|ISD
operator|::
name|ATOMIC_LOAD_XOR
operator|||
name|N
operator|->
name|getOpcode
argument_list|()
operator|==
name|ISD
operator|::
name|ATOMIC_LOAD_NAND
operator|||
name|N
operator|->
name|getOpcode
argument_list|()
operator|==
name|ISD
operator|::
name|ATOMIC_LOAD_MIN
operator|||
name|N
operator|->
name|getOpcode
argument_list|()
operator|==
name|ISD
operator|::
name|ATOMIC_LOAD_MAX
operator|||
name|N
operator|->
name|getOpcode
argument_list|()
operator|==
name|ISD
operator|::
name|ATOMIC_LOAD_UMIN
operator|||
name|N
operator|->
name|getOpcode
argument_list|()
operator|==
name|ISD
operator|::
name|ATOMIC_LOAD_UMAX
operator|||
name|N
operator|->
name|getOpcode
argument_list|()
operator|==
name|ISD
operator|::
name|ATOMIC_LOAD
operator|||
name|N
operator|->
name|getOpcode
argument_list|()
operator|==
name|ISD
operator|::
name|ATOMIC_STORE
operator|||
name|N
operator|->
name|getOpcode
argument_list|()
operator|==
name|ISD
operator|::
name|MLOAD
operator|||
name|N
operator|->
name|getOpcode
argument_list|()
operator|==
name|ISD
operator|::
name|MSTORE
operator|||
name|N
operator|->
name|getOpcode
argument_list|()
operator|==
name|ISD
operator|::
name|MGATHER
operator|||
name|N
operator|->
name|getOpcode
argument_list|()
operator|==
name|ISD
operator|::
name|MSCATTER
operator|||
name|N
operator|->
name|isMemIntrinsic
argument_list|()
operator|||
name|N
operator|->
name|isTargetMemoryOpcode
argument_list|()
return|;
block|}
expr|}
block|;
comment|/// This is an SDNode representing atomic operations.
name|class
name|AtomicSDNode
operator|:
name|public
name|MemSDNode
block|{
name|public
operator|:
name|AtomicSDNode
argument_list|(
argument|unsigned Opc
argument_list|,
argument|unsigned Order
argument_list|,
argument|const DebugLoc&dl
argument_list|,
argument|SDVTList VTL
argument_list|,
argument|EVT MemVT
argument_list|,
argument|MachineMemOperand *MMO
argument_list|)
operator|:
name|MemSDNode
argument_list|(
argument|Opc
argument_list|,
argument|Order
argument_list|,
argument|dl
argument_list|,
argument|VTL
argument_list|,
argument|MemVT
argument_list|,
argument|MMO
argument_list|)
block|{}
specifier|const
name|SDValue
operator|&
name|getBasePtr
argument_list|()
specifier|const
block|{
return|return
name|getOperand
argument_list|(
literal|1
argument_list|)
return|;
block|}
specifier|const
name|SDValue
operator|&
name|getVal
argument_list|()
specifier|const
block|{
return|return
name|getOperand
argument_list|(
literal|2
argument_list|)
return|;
block|}
comment|/// Returns true if this SDNode represents cmpxchg atomic operation, false
comment|/// otherwise.
name|bool
name|isCompareAndSwap
argument_list|()
specifier|const
block|{
name|unsigned
name|Op
operator|=
name|getOpcode
argument_list|()
block|;
return|return
name|Op
operator|==
name|ISD
operator|::
name|ATOMIC_CMP_SWAP
operator|||
name|Op
operator|==
name|ISD
operator|::
name|ATOMIC_CMP_SWAP_WITH_SUCCESS
return|;
block|}
comment|/// For cmpxchg atomic operations, return the atomic ordering requirements
comment|/// when store does not occur.
name|AtomicOrdering
name|getFailureOrdering
argument_list|()
specifier|const
block|{
name|assert
argument_list|(
name|isCompareAndSwap
argument_list|()
operator|&&
literal|"Must be cmpxchg operation"
argument_list|)
block|;
return|return
name|MMO
operator|->
name|getFailureOrdering
argument_list|()
return|;
block|}
comment|// Methods to support isa and dyn_cast
specifier|static
name|bool
name|classof
argument_list|(
argument|const SDNode *N
argument_list|)
block|{
return|return
name|N
operator|->
name|getOpcode
argument_list|()
operator|==
name|ISD
operator|::
name|ATOMIC_CMP_SWAP
operator|||
name|N
operator|->
name|getOpcode
argument_list|()
operator|==
name|ISD
operator|::
name|ATOMIC_CMP_SWAP_WITH_SUCCESS
operator|||
name|N
operator|->
name|getOpcode
argument_list|()
operator|==
name|ISD
operator|::
name|ATOMIC_SWAP
operator|||
name|N
operator|->
name|getOpcode
argument_list|()
operator|==
name|ISD
operator|::
name|ATOMIC_LOAD_ADD
operator|||
name|N
operator|->
name|getOpcode
argument_list|()
operator|==
name|ISD
operator|::
name|ATOMIC_LOAD_SUB
operator|||
name|N
operator|->
name|getOpcode
argument_list|()
operator|==
name|ISD
operator|::
name|ATOMIC_LOAD_AND
operator|||
name|N
operator|->
name|getOpcode
argument_list|()
operator|==
name|ISD
operator|::
name|ATOMIC_LOAD_OR
operator|||
name|N
operator|->
name|getOpcode
argument_list|()
operator|==
name|ISD
operator|::
name|ATOMIC_LOAD_XOR
operator|||
name|N
operator|->
name|getOpcode
argument_list|()
operator|==
name|ISD
operator|::
name|ATOMIC_LOAD_NAND
operator|||
name|N
operator|->
name|getOpcode
argument_list|()
operator|==
name|ISD
operator|::
name|ATOMIC_LOAD_MIN
operator|||
name|N
operator|->
name|getOpcode
argument_list|()
operator|==
name|ISD
operator|::
name|ATOMIC_LOAD_MAX
operator|||
name|N
operator|->
name|getOpcode
argument_list|()
operator|==
name|ISD
operator|::
name|ATOMIC_LOAD_UMIN
operator|||
name|N
operator|->
name|getOpcode
argument_list|()
operator|==
name|ISD
operator|::
name|ATOMIC_LOAD_UMAX
operator|||
name|N
operator|->
name|getOpcode
argument_list|()
operator|==
name|ISD
operator|::
name|ATOMIC_LOAD
operator|||
name|N
operator|->
name|getOpcode
argument_list|()
operator|==
name|ISD
operator|::
name|ATOMIC_STORE
return|;
block|}
expr|}
block|;
comment|/// This SDNode is used for target intrinsics that touch
comment|/// memory and need an associated MachineMemOperand. Its opcode may be
comment|/// INTRINSIC_VOID, INTRINSIC_W_CHAIN, PREFETCH, or a target-specific opcode
comment|/// with a value not less than FIRST_TARGET_MEMORY_OPCODE.
name|class
name|MemIntrinsicSDNode
operator|:
name|public
name|MemSDNode
block|{
name|public
operator|:
name|MemIntrinsicSDNode
argument_list|(
argument|unsigned Opc
argument_list|,
argument|unsigned Order
argument_list|,
argument|const DebugLoc&dl
argument_list|,
argument|SDVTList VTs
argument_list|,
argument|EVT MemoryVT
argument_list|,
argument|MachineMemOperand *MMO
argument_list|)
operator|:
name|MemSDNode
argument_list|(
argument|Opc
argument_list|,
argument|Order
argument_list|,
argument|dl
argument_list|,
argument|VTs
argument_list|,
argument|MemoryVT
argument_list|,
argument|MMO
argument_list|)
block|{
name|SDNodeBits
operator|.
name|IsMemIntrinsic
operator|=
name|true
block|;   }
comment|// Methods to support isa and dyn_cast
specifier|static
name|bool
name|classof
argument_list|(
argument|const SDNode *N
argument_list|)
block|{
comment|// We lower some target intrinsics to their target opcode
comment|// early a node with a target opcode can be of this class
return|return
name|N
operator|->
name|isMemIntrinsic
argument_list|()
operator|||
name|N
operator|->
name|getOpcode
argument_list|()
operator|==
name|ISD
operator|::
name|PREFETCH
operator|||
name|N
operator|->
name|isTargetMemoryOpcode
argument_list|()
return|;
block|}
expr|}
block|;
comment|/// This SDNode is used to implement the code generator
comment|/// support for the llvm IR shufflevector instruction.  It combines elements
comment|/// from two input vectors into a new input vector, with the selection and
comment|/// ordering of elements determined by an array of integers, referred to as
comment|/// the shuffle mask.  For input vectors of width N, mask indices of 0..N-1
comment|/// refer to elements from the LHS input, and indices from N to 2N-1 the RHS.
comment|/// An index of -1 is treated as undef, such that the code generator may put
comment|/// any value in the corresponding element of the result.
name|class
name|ShuffleVectorSDNode
operator|:
name|public
name|SDNode
block|{
comment|// The memory for Mask is owned by the SelectionDAG's OperandAllocator, and
comment|// is freed when the SelectionDAG object is destroyed.
specifier|const
name|int
operator|*
name|Mask
block|;
name|protected
operator|:
name|friend
name|class
name|SelectionDAG
block|;
name|ShuffleVectorSDNode
argument_list|(
argument|EVT VT
argument_list|,
argument|unsigned Order
argument_list|,
argument|const DebugLoc&dl
argument_list|,
argument|const int *M
argument_list|)
operator|:
name|SDNode
argument_list|(
name|ISD
operator|::
name|VECTOR_SHUFFLE
argument_list|,
name|Order
argument_list|,
name|dl
argument_list|,
name|getSDVTList
argument_list|(
name|VT
argument_list|)
argument_list|)
block|,
name|Mask
argument_list|(
argument|M
argument_list|)
block|{}
name|public
operator|:
name|ArrayRef
operator|<
name|int
operator|>
name|getMask
argument_list|()
specifier|const
block|{
name|EVT
name|VT
operator|=
name|getValueType
argument_list|(
literal|0
argument_list|)
block|;
return|return
name|makeArrayRef
argument_list|(
name|Mask
argument_list|,
name|VT
operator|.
name|getVectorNumElements
argument_list|()
argument_list|)
return|;
block|}
name|int
name|getMaskElt
argument_list|(
argument|unsigned Idx
argument_list|)
specifier|const
block|{
name|assert
argument_list|(
name|Idx
operator|<
name|getValueType
argument_list|(
literal|0
argument_list|)
operator|.
name|getVectorNumElements
argument_list|()
operator|&&
literal|"Idx out of range!"
argument_list|)
block|;
return|return
name|Mask
index|[
name|Idx
index|]
return|;
block|}
name|bool
name|isSplat
argument_list|()
specifier|const
block|{
return|return
name|isSplatMask
argument_list|(
name|Mask
argument_list|,
name|getValueType
argument_list|(
literal|0
argument_list|)
argument_list|)
return|;
block|}
name|int
name|getSplatIndex
argument_list|()
specifier|const
block|{
name|assert
argument_list|(
name|isSplat
argument_list|()
operator|&&
literal|"Cannot get splat index for non-splat!"
argument_list|)
block|;
name|EVT
name|VT
operator|=
name|getValueType
argument_list|(
literal|0
argument_list|)
block|;
for|for
control|(
name|unsigned
name|i
init|=
literal|0
init|,
name|e
init|=
name|VT
operator|.
name|getVectorNumElements
argument_list|()
init|;
name|i
operator|!=
name|e
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|Mask
index|[
name|i
index|]
operator|>=
literal|0
condition|)
return|return
name|Mask
index|[
name|i
index|]
return|;
block|}
name|llvm_unreachable
argument_list|(
literal|"Splat with all undef indices?"
argument_list|)
expr_stmt|;
block|}
specifier|static
name|bool
name|isSplatMask
argument_list|(
argument|const int *Mask
argument_list|,
argument|EVT VT
argument_list|)
block|;
comment|/// Change values in a shuffle permute mask assuming
comment|/// the two vector operands have swapped position.
specifier|static
name|void
name|commuteMask
argument_list|(
argument|MutableArrayRef<int> Mask
argument_list|)
block|{
name|unsigned
name|NumElems
operator|=
name|Mask
operator|.
name|size
argument_list|()
block|;
for|for
control|(
name|unsigned
name|i
init|=
literal|0
init|;
name|i
operator|!=
name|NumElems
condition|;
operator|++
name|i
control|)
block|{
name|int
name|idx
init|=
name|Mask
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|idx
operator|<
literal|0
condition|)
continue|continue;
elseif|else
if|if
condition|(
name|idx
operator|<
operator|(
name|int
operator|)
name|NumElems
condition|)
name|Mask
index|[
name|i
index|]
operator|=
name|idx
operator|+
name|NumElems
expr_stmt|;
else|else
name|Mask
index|[
name|i
index|]
operator|=
name|idx
operator|-
name|NumElems
expr_stmt|;
block|}
block|}
specifier|static
name|bool
name|classof
argument_list|(
argument|const SDNode *N
argument_list|)
block|{
return|return
name|N
operator|->
name|getOpcode
argument_list|()
operator|==
name|ISD
operator|::
name|VECTOR_SHUFFLE
return|;
block|}
expr|}
block|;
name|class
name|ConstantSDNode
operator|:
name|public
name|SDNode
block|{
name|friend
name|class
name|SelectionDAG
block|;
specifier|const
name|ConstantInt
operator|*
name|Value
block|;
name|ConstantSDNode
argument_list|(
argument|bool isTarget
argument_list|,
argument|bool isOpaque
argument_list|,
argument|const ConstantInt *val
argument_list|,
argument|const DebugLoc&DL
argument_list|,
argument|EVT VT
argument_list|)
operator|:
name|SDNode
argument_list|(
name|isTarget
condition|?
name|ISD
operator|::
name|TargetConstant
else|:
name|ISD
operator|::
name|Constant
argument_list|,
literal|0
argument_list|,
name|DL
argument_list|,
name|getSDVTList
argument_list|(
name|VT
argument_list|)
argument_list|)
block|,
name|Value
argument_list|(
argument|val
argument_list|)
block|{
name|ConstantSDNodeBits
operator|.
name|IsOpaque
operator|=
name|isOpaque
block|;   }
name|public
operator|:
specifier|const
name|ConstantInt
operator|*
name|getConstantIntValue
argument_list|()
specifier|const
block|{
return|return
name|Value
return|;
block|}
specifier|const
name|APInt
operator|&
name|getAPIntValue
argument_list|()
specifier|const
block|{
return|return
name|Value
operator|->
name|getValue
argument_list|()
return|;
block|}
name|uint64_t
name|getZExtValue
argument_list|()
specifier|const
block|{
return|return
name|Value
operator|->
name|getZExtValue
argument_list|()
return|;
block|}
name|int64_t
name|getSExtValue
argument_list|()
specifier|const
block|{
return|return
name|Value
operator|->
name|getSExtValue
argument_list|()
return|;
block|}
name|bool
name|isOne
argument_list|()
specifier|const
block|{
return|return
name|Value
operator|->
name|isOne
argument_list|()
return|;
block|}
name|bool
name|isNullValue
argument_list|()
specifier|const
block|{
return|return
name|Value
operator|->
name|isNullValue
argument_list|()
return|;
block|}
name|bool
name|isAllOnesValue
argument_list|()
specifier|const
block|{
return|return
name|Value
operator|->
name|isAllOnesValue
argument_list|()
return|;
block|}
name|bool
name|isOpaque
argument_list|()
specifier|const
block|{
return|return
name|ConstantSDNodeBits
operator|.
name|IsOpaque
return|;
block|}
specifier|static
name|bool
name|classof
argument_list|(
argument|const SDNode *N
argument_list|)
block|{
return|return
name|N
operator|->
name|getOpcode
argument_list|()
operator|==
name|ISD
operator|::
name|Constant
operator|||
name|N
operator|->
name|getOpcode
argument_list|()
operator|==
name|ISD
operator|::
name|TargetConstant
return|;
block|}
expr|}
block|;
name|uint64_t
name|SDNode
operator|::
name|getConstantOperandVal
argument_list|(
argument|unsigned Num
argument_list|)
specifier|const
block|{
return|return
name|cast
operator|<
name|ConstantSDNode
operator|>
operator|(
name|getOperand
argument_list|(
name|Num
argument_list|)
operator|)
operator|->
name|getZExtValue
argument_list|()
return|;
block|}
name|class
name|ConstantFPSDNode
operator|:
name|public
name|SDNode
block|{
name|friend
name|class
name|SelectionDAG
block|;
specifier|const
name|ConstantFP
operator|*
name|Value
block|;
name|ConstantFPSDNode
argument_list|(
argument|bool isTarget
argument_list|,
argument|const ConstantFP *val
argument_list|,
argument|const DebugLoc&DL
argument_list|,
argument|EVT VT
argument_list|)
operator|:
name|SDNode
argument_list|(
name|isTarget
condition|?
name|ISD
operator|::
name|TargetConstantFP
else|:
name|ISD
operator|::
name|ConstantFP
argument_list|,
literal|0
argument_list|,
name|DL
argument_list|,
name|getSDVTList
argument_list|(
name|VT
argument_list|)
argument_list|)
block|,
name|Value
argument_list|(
argument|val
argument_list|)
block|{}
name|public
operator|:
specifier|const
name|APFloat
operator|&
name|getValueAPF
argument_list|()
specifier|const
block|{
return|return
name|Value
operator|->
name|getValueAPF
argument_list|()
return|;
block|}
specifier|const
name|ConstantFP
operator|*
name|getConstantFPValue
argument_list|()
specifier|const
block|{
return|return
name|Value
return|;
block|}
comment|/// Return true if the value is positive or negative zero.
name|bool
name|isZero
argument_list|()
specifier|const
block|{
return|return
name|Value
operator|->
name|isZero
argument_list|()
return|;
block|}
comment|/// Return true if the value is a NaN.
name|bool
name|isNaN
argument_list|()
specifier|const
block|{
return|return
name|Value
operator|->
name|isNaN
argument_list|()
return|;
block|}
comment|/// Return true if the value is an infinity
name|bool
name|isInfinity
argument_list|()
specifier|const
block|{
return|return
name|Value
operator|->
name|isInfinity
argument_list|()
return|;
block|}
comment|/// Return true if the value is negative.
name|bool
name|isNegative
argument_list|()
specifier|const
block|{
return|return
name|Value
operator|->
name|isNegative
argument_list|()
return|;
block|}
comment|/// We don't rely on operator== working on double values, as
comment|/// it returns true for things that are clearly not equal, like -0.0 and 0.0.
comment|/// As such, this method can be used to do an exact bit-for-bit comparison of
comment|/// two floating point values.
comment|/// We leave the version with the double argument here because it's just so
comment|/// convenient to write "2.0" and the like.  Without this function we'd
comment|/// have to duplicate its logic everywhere it's called.
name|bool
name|isExactlyValue
argument_list|(
argument|double V
argument_list|)
specifier|const
block|{
name|bool
name|ignored
block|;
name|APFloat
name|Tmp
argument_list|(
name|V
argument_list|)
block|;
name|Tmp
operator|.
name|convert
argument_list|(
name|Value
operator|->
name|getValueAPF
argument_list|()
operator|.
name|getSemantics
argument_list|()
argument_list|,
name|APFloat
operator|::
name|rmNearestTiesToEven
argument_list|,
operator|&
name|ignored
argument_list|)
block|;
return|return
name|isExactlyValue
argument_list|(
name|Tmp
argument_list|)
return|;
block|}
name|bool
name|isExactlyValue
argument_list|(
argument|const APFloat& V
argument_list|)
specifier|const
block|;
specifier|static
name|bool
name|isValueValidForType
argument_list|(
argument|EVT VT
argument_list|,
argument|const APFloat& Val
argument_list|)
block|;
specifier|static
name|bool
name|classof
argument_list|(
argument|const SDNode *N
argument_list|)
block|{
return|return
name|N
operator|->
name|getOpcode
argument_list|()
operator|==
name|ISD
operator|::
name|ConstantFP
operator|||
name|N
operator|->
name|getOpcode
argument_list|()
operator|==
name|ISD
operator|::
name|TargetConstantFP
return|;
block|}
expr|}
block|;
comment|/// Returns true if \p V is a constant integer zero.
name|bool
name|isNullConstant
argument_list|(
argument|SDValue V
argument_list|)
block|;
comment|/// Returns true if \p V is an FP constant with a value of positive zero.
name|bool
name|isNullFPConstant
argument_list|(
argument|SDValue V
argument_list|)
block|;
comment|/// Returns true if \p V is an integer constant with all bits set.
name|bool
name|isAllOnesConstant
argument_list|(
argument|SDValue V
argument_list|)
block|;
comment|/// Returns true if \p V is a constant integer one.
name|bool
name|isOneConstant
argument_list|(
argument|SDValue V
argument_list|)
block|;
comment|/// Returns true if \p V is a bitwise not operation. Assumes that an all ones
comment|/// constant is canonicalized to be operand 1.
name|bool
name|isBitwiseNot
argument_list|(
argument|SDValue V
argument_list|)
block|;
comment|/// Returns the SDNode if it is a constant splat BuildVector or constant int.
name|ConstantSDNode
operator|*
name|isConstOrConstSplat
argument_list|(
argument|SDValue V
argument_list|)
block|;
comment|/// Returns the SDNode if it is a constant splat BuildVector or constant float.
name|ConstantFPSDNode
operator|*
name|isConstOrConstSplatFP
argument_list|(
argument|SDValue V
argument_list|)
block|;
name|class
name|GlobalAddressSDNode
operator|:
name|public
name|SDNode
block|{
name|friend
name|class
name|SelectionDAG
block|;
specifier|const
name|GlobalValue
operator|*
name|TheGlobal
block|;
name|int64_t
name|Offset
block|;
name|unsigned
name|char
name|TargetFlags
block|;
name|GlobalAddressSDNode
argument_list|(
argument|unsigned Opc
argument_list|,
argument|unsigned Order
argument_list|,
argument|const DebugLoc&DL
argument_list|,
argument|const GlobalValue *GA
argument_list|,
argument|EVT VT
argument_list|,
argument|int64_t o
argument_list|,
argument|unsigned char TargetFlags
argument_list|)
block|;
name|public
operator|:
specifier|const
name|GlobalValue
operator|*
name|getGlobal
argument_list|()
specifier|const
block|{
return|return
name|TheGlobal
return|;
block|}
name|int64_t
name|getOffset
argument_list|()
specifier|const
block|{
return|return
name|Offset
return|;
block|}
name|unsigned
name|char
name|getTargetFlags
argument_list|()
specifier|const
block|{
return|return
name|TargetFlags
return|;
block|}
comment|// Return the address space this GlobalAddress belongs to.
name|unsigned
name|getAddressSpace
argument_list|()
specifier|const
block|;
specifier|static
name|bool
name|classof
argument_list|(
argument|const SDNode *N
argument_list|)
block|{
return|return
name|N
operator|->
name|getOpcode
argument_list|()
operator|==
name|ISD
operator|::
name|GlobalAddress
operator|||
name|N
operator|->
name|getOpcode
argument_list|()
operator|==
name|ISD
operator|::
name|TargetGlobalAddress
operator|||
name|N
operator|->
name|getOpcode
argument_list|()
operator|==
name|ISD
operator|::
name|GlobalTLSAddress
operator|||
name|N
operator|->
name|getOpcode
argument_list|()
operator|==
name|ISD
operator|::
name|TargetGlobalTLSAddress
return|;
block|}
expr|}
block|;
name|class
name|FrameIndexSDNode
operator|:
name|public
name|SDNode
block|{
name|friend
name|class
name|SelectionDAG
block|;
name|int
name|FI
block|;
name|FrameIndexSDNode
argument_list|(
argument|int fi
argument_list|,
argument|EVT VT
argument_list|,
argument|bool isTarg
argument_list|)
operator|:
name|SDNode
argument_list|(
name|isTarg
condition|?
name|ISD
operator|::
name|TargetFrameIndex
else|:
name|ISD
operator|::
name|FrameIndex
argument_list|,
literal|0
argument_list|,
name|DebugLoc
argument_list|()
argument_list|,
name|getSDVTList
argument_list|(
name|VT
argument_list|)
argument_list|)
block|,
name|FI
argument_list|(
argument|fi
argument_list|)
block|{   }
name|public
operator|:
name|int
name|getIndex
argument_list|()
specifier|const
block|{
return|return
name|FI
return|;
block|}
specifier|static
name|bool
name|classof
argument_list|(
argument|const SDNode *N
argument_list|)
block|{
return|return
name|N
operator|->
name|getOpcode
argument_list|()
operator|==
name|ISD
operator|::
name|FrameIndex
operator|||
name|N
operator|->
name|getOpcode
argument_list|()
operator|==
name|ISD
operator|::
name|TargetFrameIndex
return|;
block|}
expr|}
block|;
name|class
name|JumpTableSDNode
operator|:
name|public
name|SDNode
block|{
name|friend
name|class
name|SelectionDAG
block|;
name|int
name|JTI
block|;
name|unsigned
name|char
name|TargetFlags
block|;
name|JumpTableSDNode
argument_list|(
argument|int jti
argument_list|,
argument|EVT VT
argument_list|,
argument|bool isTarg
argument_list|,
argument|unsigned char TF
argument_list|)
operator|:
name|SDNode
argument_list|(
name|isTarg
condition|?
name|ISD
operator|::
name|TargetJumpTable
else|:
name|ISD
operator|::
name|JumpTable
argument_list|,
literal|0
argument_list|,
name|DebugLoc
argument_list|()
argument_list|,
name|getSDVTList
argument_list|(
name|VT
argument_list|)
argument_list|)
block|,
name|JTI
argument_list|(
name|jti
argument_list|)
block|,
name|TargetFlags
argument_list|(
argument|TF
argument_list|)
block|{   }
name|public
operator|:
name|int
name|getIndex
argument_list|()
specifier|const
block|{
return|return
name|JTI
return|;
block|}
name|unsigned
name|char
name|getTargetFlags
argument_list|()
specifier|const
block|{
return|return
name|TargetFlags
return|;
block|}
specifier|static
name|bool
name|classof
argument_list|(
argument|const SDNode *N
argument_list|)
block|{
return|return
name|N
operator|->
name|getOpcode
argument_list|()
operator|==
name|ISD
operator|::
name|JumpTable
operator|||
name|N
operator|->
name|getOpcode
argument_list|()
operator|==
name|ISD
operator|::
name|TargetJumpTable
return|;
block|}
expr|}
block|;
name|class
name|ConstantPoolSDNode
operator|:
name|public
name|SDNode
block|{
name|friend
name|class
name|SelectionDAG
block|;
expr|union
block|{
specifier|const
name|Constant
operator|*
name|ConstVal
block|;
name|MachineConstantPoolValue
operator|*
name|MachineCPVal
block|;   }
name|Val
block|;
name|int
name|Offset
block|;
comment|// It's a MachineConstantPoolValue if top bit is set.
name|unsigned
name|Alignment
block|;
comment|// Minimum alignment requirement of CP (not log2 value).
name|unsigned
name|char
name|TargetFlags
block|;
name|ConstantPoolSDNode
argument_list|(
argument|bool isTarget
argument_list|,
argument|const Constant *c
argument_list|,
argument|EVT VT
argument_list|,
argument|int o
argument_list|,
argument|unsigned Align
argument_list|,
argument|unsigned char TF
argument_list|)
operator|:
name|SDNode
argument_list|(
name|isTarget
condition|?
name|ISD
operator|::
name|TargetConstantPool
else|:
name|ISD
operator|::
name|ConstantPool
argument_list|,
literal|0
argument_list|,
name|DebugLoc
argument_list|()
argument_list|,
name|getSDVTList
argument_list|(
name|VT
argument_list|)
argument_list|)
block|,
name|Offset
argument_list|(
name|o
argument_list|)
block|,
name|Alignment
argument_list|(
name|Align
argument_list|)
block|,
name|TargetFlags
argument_list|(
argument|TF
argument_list|)
block|{
name|assert
argument_list|(
name|Offset
operator|>=
literal|0
operator|&&
literal|"Offset is too large"
argument_list|)
block|;
name|Val
operator|.
name|ConstVal
operator|=
name|c
block|;   }
name|ConstantPoolSDNode
argument_list|(
argument|bool isTarget
argument_list|,
argument|MachineConstantPoolValue *v
argument_list|,
argument|EVT VT
argument_list|,
argument|int o
argument_list|,
argument|unsigned Align
argument_list|,
argument|unsigned char TF
argument_list|)
operator|:
name|SDNode
argument_list|(
name|isTarget
condition|?
name|ISD
operator|::
name|TargetConstantPool
else|:
name|ISD
operator|::
name|ConstantPool
argument_list|,
literal|0
argument_list|,
name|DebugLoc
argument_list|()
argument_list|,
name|getSDVTList
argument_list|(
name|VT
argument_list|)
argument_list|)
block|,
name|Offset
argument_list|(
name|o
argument_list|)
block|,
name|Alignment
argument_list|(
name|Align
argument_list|)
block|,
name|TargetFlags
argument_list|(
argument|TF
argument_list|)
block|{
name|assert
argument_list|(
name|Offset
operator|>=
literal|0
operator|&&
literal|"Offset is too large"
argument_list|)
block|;
name|Val
operator|.
name|MachineCPVal
operator|=
name|v
block|;
name|Offset
operator||=
literal|1
operator|<<
operator|(
sizeof|sizeof
argument_list|(
name|unsigned
argument_list|)
operator|*
name|CHAR_BIT
operator|-
literal|1
operator|)
block|;   }
name|public
operator|:
name|bool
name|isMachineConstantPoolEntry
argument_list|()
specifier|const
block|{
return|return
name|Offset
operator|<
literal|0
return|;
block|}
specifier|const
name|Constant
operator|*
name|getConstVal
argument_list|()
specifier|const
block|{
name|assert
argument_list|(
operator|!
name|isMachineConstantPoolEntry
argument_list|()
operator|&&
literal|"Wrong constantpool type"
argument_list|)
block|;
return|return
name|Val
operator|.
name|ConstVal
return|;
block|}
name|MachineConstantPoolValue
operator|*
name|getMachineCPVal
argument_list|()
specifier|const
block|{
name|assert
argument_list|(
name|isMachineConstantPoolEntry
argument_list|()
operator|&&
literal|"Wrong constantpool type"
argument_list|)
block|;
return|return
name|Val
operator|.
name|MachineCPVal
return|;
block|}
name|int
name|getOffset
argument_list|()
specifier|const
block|{
return|return
name|Offset
operator|&
operator|~
operator|(
literal|1
operator|<<
operator|(
sizeof|sizeof
argument_list|(
name|unsigned
argument_list|)
operator|*
name|CHAR_BIT
operator|-
literal|1
operator|)
operator|)
return|;
block|}
comment|// Return the alignment of this constant pool object, which is either 0 (for
comment|// default alignment) or the desired value.
name|unsigned
name|getAlignment
argument_list|()
specifier|const
block|{
return|return
name|Alignment
return|;
block|}
name|unsigned
name|char
name|getTargetFlags
argument_list|()
specifier|const
block|{
return|return
name|TargetFlags
return|;
block|}
name|Type
operator|*
name|getType
argument_list|()
specifier|const
block|;
specifier|static
name|bool
name|classof
argument_list|(
argument|const SDNode *N
argument_list|)
block|{
return|return
name|N
operator|->
name|getOpcode
argument_list|()
operator|==
name|ISD
operator|::
name|ConstantPool
operator|||
name|N
operator|->
name|getOpcode
argument_list|()
operator|==
name|ISD
operator|::
name|TargetConstantPool
return|;
block|}
expr|}
block|;
comment|/// Completely target-dependent object reference.
name|class
name|TargetIndexSDNode
operator|:
name|public
name|SDNode
block|{
name|friend
name|class
name|SelectionDAG
block|;
name|unsigned
name|char
name|TargetFlags
block|;
name|int
name|Index
block|;
name|int64_t
name|Offset
block|;
name|public
operator|:
name|TargetIndexSDNode
argument_list|(
argument|int Idx
argument_list|,
argument|EVT VT
argument_list|,
argument|int64_t Ofs
argument_list|,
argument|unsigned char TF
argument_list|)
operator|:
name|SDNode
argument_list|(
name|ISD
operator|::
name|TargetIndex
argument_list|,
literal|0
argument_list|,
name|DebugLoc
argument_list|()
argument_list|,
name|getSDVTList
argument_list|(
name|VT
argument_list|)
argument_list|)
block|,
name|TargetFlags
argument_list|(
name|TF
argument_list|)
block|,
name|Index
argument_list|(
name|Idx
argument_list|)
block|,
name|Offset
argument_list|(
argument|Ofs
argument_list|)
block|{}
name|unsigned
name|char
name|getTargetFlags
argument_list|()
specifier|const
block|{
return|return
name|TargetFlags
return|;
block|}
name|int
name|getIndex
argument_list|()
specifier|const
block|{
return|return
name|Index
return|;
block|}
name|int64_t
name|getOffset
argument_list|()
specifier|const
block|{
return|return
name|Offset
return|;
block|}
specifier|static
name|bool
name|classof
argument_list|(
argument|const SDNode *N
argument_list|)
block|{
return|return
name|N
operator|->
name|getOpcode
argument_list|()
operator|==
name|ISD
operator|::
name|TargetIndex
return|;
block|}
expr|}
block|;
name|class
name|BasicBlockSDNode
operator|:
name|public
name|SDNode
block|{
name|friend
name|class
name|SelectionDAG
block|;
name|MachineBasicBlock
operator|*
name|MBB
block|;
comment|/// Debug info is meaningful and potentially useful here, but we create
comment|/// blocks out of order when they're jumped to, which makes it a bit
comment|/// harder.  Let's see if we need it first.
name|explicit
name|BasicBlockSDNode
argument_list|(
name|MachineBasicBlock
operator|*
name|mbb
argument_list|)
operator|:
name|SDNode
argument_list|(
name|ISD
operator|::
name|BasicBlock
argument_list|,
literal|0
argument_list|,
name|DebugLoc
argument_list|()
argument_list|,
name|getSDVTList
argument_list|(
name|MVT
operator|::
name|Other
argument_list|)
argument_list|)
block|,
name|MBB
argument_list|(
argument|mbb
argument_list|)
block|{}
name|public
operator|:
name|MachineBasicBlock
operator|*
name|getBasicBlock
argument_list|()
specifier|const
block|{
return|return
name|MBB
return|;
block|}
specifier|static
name|bool
name|classof
argument_list|(
argument|const SDNode *N
argument_list|)
block|{
return|return
name|N
operator|->
name|getOpcode
argument_list|()
operator|==
name|ISD
operator|::
name|BasicBlock
return|;
block|}
expr|}
block|;
comment|/// A "pseudo-class" with methods for operating on BUILD_VECTORs.
name|class
name|BuildVectorSDNode
operator|:
name|public
name|SDNode
block|{
name|public
operator|:
comment|// These are constructed as SDNodes and then cast to BuildVectorSDNodes.
name|explicit
name|BuildVectorSDNode
argument_list|()
operator|=
name|delete
block|;
comment|/// Check if this is a constant splat, and if so, find the
comment|/// smallest element size that splats the vector.  If MinSplatBits is
comment|/// nonzero, the element size must be at least that large.  Note that the
comment|/// splat element may be the entire vector (i.e., a one element vector).
comment|/// Returns the splat element value in SplatValue.  Any undefined bits in
comment|/// that value are zero, and the corresponding bits in the SplatUndef mask
comment|/// are set.  The SplatBitSize value is set to the splat element size in
comment|/// bits.  HasAnyUndefs is set to true if any bits in the vector are
comment|/// undefined.  isBigEndian describes the endianness of the target.
name|bool
name|isConstantSplat
argument_list|(
argument|APInt&SplatValue
argument_list|,
argument|APInt&SplatUndef
argument_list|,
argument|unsigned&SplatBitSize
argument_list|,
argument|bool&HasAnyUndefs
argument_list|,
argument|unsigned MinSplatBits =
literal|0
argument_list|,
argument|bool isBigEndian = false
argument_list|)
specifier|const
block|;
comment|/// \brief Returns the splatted value or a null value if this is not a splat.
comment|///
comment|/// If passed a non-null UndefElements bitvector, it will resize it to match
comment|/// the vector width and set the bits where elements are undef.
name|SDValue
name|getSplatValue
argument_list|(
argument|BitVector *UndefElements = nullptr
argument_list|)
specifier|const
block|;
comment|/// \brief Returns the splatted constant or null if this is not a constant
comment|/// splat.
comment|///
comment|/// If passed a non-null UndefElements bitvector, it will resize it to match
comment|/// the vector width and set the bits where elements are undef.
name|ConstantSDNode
operator|*
name|getConstantSplatNode
argument_list|(
argument|BitVector *UndefElements = nullptr
argument_list|)
specifier|const
block|;
comment|/// \brief Returns the splatted constant FP or null if this is not a constant
comment|/// FP splat.
comment|///
comment|/// If passed a non-null UndefElements bitvector, it will resize it to match
comment|/// the vector width and set the bits where elements are undef.
name|ConstantFPSDNode
operator|*
name|getConstantFPSplatNode
argument_list|(
argument|BitVector *UndefElements = nullptr
argument_list|)
specifier|const
block|;
comment|/// \brief If this is a constant FP splat and the splatted constant FP is an
comment|/// exact power or 2, return the log base 2 integer value.  Otherwise,
comment|/// return -1.
comment|///
comment|/// The BitWidth specifies the necessary bit precision.
name|int32_t
name|getConstantFPSplatPow2ToLog2Int
argument_list|(
argument|BitVector *UndefElements
argument_list|,
argument|uint32_t BitWidth
argument_list|)
specifier|const
block|;
name|bool
name|isConstant
argument_list|()
specifier|const
block|;
specifier|static
specifier|inline
name|bool
name|classof
argument_list|(
argument|const SDNode *N
argument_list|)
block|{
return|return
name|N
operator|->
name|getOpcode
argument_list|()
operator|==
name|ISD
operator|::
name|BUILD_VECTOR
return|;
block|}
expr|}
block|;
comment|/// An SDNode that holds an arbitrary LLVM IR Value. This is
comment|/// used when the SelectionDAG needs to make a simple reference to something
comment|/// in the LLVM IR representation.
comment|///
name|class
name|SrcValueSDNode
operator|:
name|public
name|SDNode
block|{
name|friend
name|class
name|SelectionDAG
block|;
specifier|const
name|Value
operator|*
name|V
block|;
comment|/// Create a SrcValue for a general value.
name|explicit
name|SrcValueSDNode
argument_list|(
specifier|const
name|Value
operator|*
name|v
argument_list|)
operator|:
name|SDNode
argument_list|(
name|ISD
operator|::
name|SRCVALUE
argument_list|,
literal|0
argument_list|,
name|DebugLoc
argument_list|()
argument_list|,
name|getSDVTList
argument_list|(
name|MVT
operator|::
name|Other
argument_list|)
argument_list|)
block|,
name|V
argument_list|(
argument|v
argument_list|)
block|{}
name|public
operator|:
comment|/// Return the contained Value.
specifier|const
name|Value
operator|*
name|getValue
argument_list|()
specifier|const
block|{
return|return
name|V
return|;
block|}
specifier|static
name|bool
name|classof
argument_list|(
argument|const SDNode *N
argument_list|)
block|{
return|return
name|N
operator|->
name|getOpcode
argument_list|()
operator|==
name|ISD
operator|::
name|SRCVALUE
return|;
block|}
expr|}
block|;
name|class
name|MDNodeSDNode
operator|:
name|public
name|SDNode
block|{
name|friend
name|class
name|SelectionDAG
block|;
specifier|const
name|MDNode
operator|*
name|MD
block|;
name|explicit
name|MDNodeSDNode
argument_list|(
specifier|const
name|MDNode
operator|*
name|md
argument_list|)
operator|:
name|SDNode
argument_list|(
name|ISD
operator|::
name|MDNODE_SDNODE
argument_list|,
literal|0
argument_list|,
name|DebugLoc
argument_list|()
argument_list|,
name|getSDVTList
argument_list|(
name|MVT
operator|::
name|Other
argument_list|)
argument_list|)
block|,
name|MD
argument_list|(
argument|md
argument_list|)
block|{}
name|public
operator|:
specifier|const
name|MDNode
operator|*
name|getMD
argument_list|()
specifier|const
block|{
return|return
name|MD
return|;
block|}
specifier|static
name|bool
name|classof
argument_list|(
argument|const SDNode *N
argument_list|)
block|{
return|return
name|N
operator|->
name|getOpcode
argument_list|()
operator|==
name|ISD
operator|::
name|MDNODE_SDNODE
return|;
block|}
expr|}
block|;
name|class
name|RegisterSDNode
operator|:
name|public
name|SDNode
block|{
name|friend
name|class
name|SelectionDAG
block|;
name|unsigned
name|Reg
block|;
name|RegisterSDNode
argument_list|(
argument|unsigned reg
argument_list|,
argument|EVT VT
argument_list|)
operator|:
name|SDNode
argument_list|(
name|ISD
operator|::
name|Register
argument_list|,
literal|0
argument_list|,
name|DebugLoc
argument_list|()
argument_list|,
name|getSDVTList
argument_list|(
name|VT
argument_list|)
argument_list|)
block|,
name|Reg
argument_list|(
argument|reg
argument_list|)
block|{}
name|public
operator|:
name|unsigned
name|getReg
argument_list|()
specifier|const
block|{
return|return
name|Reg
return|;
block|}
specifier|static
name|bool
name|classof
argument_list|(
argument|const SDNode *N
argument_list|)
block|{
return|return
name|N
operator|->
name|getOpcode
argument_list|()
operator|==
name|ISD
operator|::
name|Register
return|;
block|}
expr|}
block|;
name|class
name|RegisterMaskSDNode
operator|:
name|public
name|SDNode
block|{
name|friend
name|class
name|SelectionDAG
block|;
comment|// The memory for RegMask is not owned by the node.
specifier|const
name|uint32_t
operator|*
name|RegMask
block|;
name|RegisterMaskSDNode
argument_list|(
specifier|const
name|uint32_t
operator|*
name|mask
argument_list|)
operator|:
name|SDNode
argument_list|(
name|ISD
operator|::
name|RegisterMask
argument_list|,
literal|0
argument_list|,
name|DebugLoc
argument_list|()
argument_list|,
name|getSDVTList
argument_list|(
name|MVT
operator|::
name|Untyped
argument_list|)
argument_list|)
block|,
name|RegMask
argument_list|(
argument|mask
argument_list|)
block|{}
name|public
operator|:
specifier|const
name|uint32_t
operator|*
name|getRegMask
argument_list|()
specifier|const
block|{
return|return
name|RegMask
return|;
block|}
specifier|static
name|bool
name|classof
argument_list|(
argument|const SDNode *N
argument_list|)
block|{
return|return
name|N
operator|->
name|getOpcode
argument_list|()
operator|==
name|ISD
operator|::
name|RegisterMask
return|;
block|}
expr|}
block|;
name|class
name|BlockAddressSDNode
operator|:
name|public
name|SDNode
block|{
name|friend
name|class
name|SelectionDAG
block|;
specifier|const
name|BlockAddress
operator|*
name|BA
block|;
name|int64_t
name|Offset
block|;
name|unsigned
name|char
name|TargetFlags
block|;
name|BlockAddressSDNode
argument_list|(
argument|unsigned NodeTy
argument_list|,
argument|EVT VT
argument_list|,
argument|const BlockAddress *ba
argument_list|,
argument|int64_t o
argument_list|,
argument|unsigned char Flags
argument_list|)
operator|:
name|SDNode
argument_list|(
name|NodeTy
argument_list|,
literal|0
argument_list|,
name|DebugLoc
argument_list|()
argument_list|,
name|getSDVTList
argument_list|(
name|VT
argument_list|)
argument_list|)
block|,
name|BA
argument_list|(
name|ba
argument_list|)
block|,
name|Offset
argument_list|(
name|o
argument_list|)
block|,
name|TargetFlags
argument_list|(
argument|Flags
argument_list|)
block|{}
name|public
operator|:
specifier|const
name|BlockAddress
operator|*
name|getBlockAddress
argument_list|()
specifier|const
block|{
return|return
name|BA
return|;
block|}
name|int64_t
name|getOffset
argument_list|()
specifier|const
block|{
return|return
name|Offset
return|;
block|}
name|unsigned
name|char
name|getTargetFlags
argument_list|()
specifier|const
block|{
return|return
name|TargetFlags
return|;
block|}
specifier|static
name|bool
name|classof
argument_list|(
argument|const SDNode *N
argument_list|)
block|{
return|return
name|N
operator|->
name|getOpcode
argument_list|()
operator|==
name|ISD
operator|::
name|BlockAddress
operator|||
name|N
operator|->
name|getOpcode
argument_list|()
operator|==
name|ISD
operator|::
name|TargetBlockAddress
return|;
block|}
expr|}
block|;
name|class
name|EHLabelSDNode
operator|:
name|public
name|SDNode
block|{
name|friend
name|class
name|SelectionDAG
block|;
name|MCSymbol
operator|*
name|Label
block|;
name|EHLabelSDNode
argument_list|(
argument|unsigned Order
argument_list|,
argument|const DebugLoc&dl
argument_list|,
argument|MCSymbol *L
argument_list|)
operator|:
name|SDNode
argument_list|(
name|ISD
operator|::
name|EH_LABEL
argument_list|,
name|Order
argument_list|,
name|dl
argument_list|,
name|getSDVTList
argument_list|(
name|MVT
operator|::
name|Other
argument_list|)
argument_list|)
block|,
name|Label
argument_list|(
argument|L
argument_list|)
block|{}
name|public
operator|:
name|MCSymbol
operator|*
name|getLabel
argument_list|()
specifier|const
block|{
return|return
name|Label
return|;
block|}
specifier|static
name|bool
name|classof
argument_list|(
argument|const SDNode *N
argument_list|)
block|{
return|return
name|N
operator|->
name|getOpcode
argument_list|()
operator|==
name|ISD
operator|::
name|EH_LABEL
return|;
block|}
expr|}
block|;
name|class
name|ExternalSymbolSDNode
operator|:
name|public
name|SDNode
block|{
name|friend
name|class
name|SelectionDAG
block|;
specifier|const
name|char
operator|*
name|Symbol
block|;
name|unsigned
name|char
name|TargetFlags
block|;
name|ExternalSymbolSDNode
argument_list|(
argument|bool isTarget
argument_list|,
argument|const char *Sym
argument_list|,
argument|unsigned char TF
argument_list|,
argument|EVT VT
argument_list|)
operator|:
name|SDNode
argument_list|(
name|isTarget
condition|?
name|ISD
operator|::
name|TargetExternalSymbol
else|:
name|ISD
operator|::
name|ExternalSymbol
argument_list|,
literal|0
argument_list|,
name|DebugLoc
argument_list|()
argument_list|,
name|getSDVTList
argument_list|(
name|VT
argument_list|)
argument_list|)
block|,
name|Symbol
argument_list|(
name|Sym
argument_list|)
block|,
name|TargetFlags
argument_list|(
argument|TF
argument_list|)
block|{}
name|public
operator|:
specifier|const
name|char
operator|*
name|getSymbol
argument_list|()
specifier|const
block|{
return|return
name|Symbol
return|;
block|}
name|unsigned
name|char
name|getTargetFlags
argument_list|()
specifier|const
block|{
return|return
name|TargetFlags
return|;
block|}
specifier|static
name|bool
name|classof
argument_list|(
argument|const SDNode *N
argument_list|)
block|{
return|return
name|N
operator|->
name|getOpcode
argument_list|()
operator|==
name|ISD
operator|::
name|ExternalSymbol
operator|||
name|N
operator|->
name|getOpcode
argument_list|()
operator|==
name|ISD
operator|::
name|TargetExternalSymbol
return|;
block|}
expr|}
block|;
name|class
name|MCSymbolSDNode
operator|:
name|public
name|SDNode
block|{
name|friend
name|class
name|SelectionDAG
block|;
name|MCSymbol
operator|*
name|Symbol
block|;
name|MCSymbolSDNode
argument_list|(
argument|MCSymbol *Symbol
argument_list|,
argument|EVT VT
argument_list|)
operator|:
name|SDNode
argument_list|(
name|ISD
operator|::
name|MCSymbol
argument_list|,
literal|0
argument_list|,
name|DebugLoc
argument_list|()
argument_list|,
name|getSDVTList
argument_list|(
name|VT
argument_list|)
argument_list|)
block|,
name|Symbol
argument_list|(
argument|Symbol
argument_list|)
block|{}
name|public
operator|:
name|MCSymbol
operator|*
name|getMCSymbol
argument_list|()
specifier|const
block|{
return|return
name|Symbol
return|;
block|}
specifier|static
name|bool
name|classof
argument_list|(
argument|const SDNode *N
argument_list|)
block|{
return|return
name|N
operator|->
name|getOpcode
argument_list|()
operator|==
name|ISD
operator|::
name|MCSymbol
return|;
block|}
expr|}
block|;
name|class
name|CondCodeSDNode
operator|:
name|public
name|SDNode
block|{
name|friend
name|class
name|SelectionDAG
block|;
name|ISD
operator|::
name|CondCode
name|Condition
block|;
name|explicit
name|CondCodeSDNode
argument_list|(
argument|ISD::CondCode Cond
argument_list|)
operator|:
name|SDNode
argument_list|(
name|ISD
operator|::
name|CONDCODE
argument_list|,
literal|0
argument_list|,
name|DebugLoc
argument_list|()
argument_list|,
name|getSDVTList
argument_list|(
name|MVT
operator|::
name|Other
argument_list|)
argument_list|)
block|,
name|Condition
argument_list|(
argument|Cond
argument_list|)
block|{}
name|public
operator|:
name|ISD
operator|::
name|CondCode
name|get
argument_list|()
specifier|const
block|{
return|return
name|Condition
return|;
block|}
specifier|static
name|bool
name|classof
argument_list|(
argument|const SDNode *N
argument_list|)
block|{
return|return
name|N
operator|->
name|getOpcode
argument_list|()
operator|==
name|ISD
operator|::
name|CONDCODE
return|;
block|}
expr|}
block|;
comment|/// This class is used to represent EVT's, which are used
comment|/// to parameterize some operations.
name|class
name|VTSDNode
operator|:
name|public
name|SDNode
block|{
name|friend
name|class
name|SelectionDAG
block|;
name|EVT
name|ValueType
block|;
name|explicit
name|VTSDNode
argument_list|(
argument|EVT VT
argument_list|)
operator|:
name|SDNode
argument_list|(
name|ISD
operator|::
name|VALUETYPE
argument_list|,
literal|0
argument_list|,
name|DebugLoc
argument_list|()
argument_list|,
name|getSDVTList
argument_list|(
name|MVT
operator|::
name|Other
argument_list|)
argument_list|)
block|,
name|ValueType
argument_list|(
argument|VT
argument_list|)
block|{}
name|public
operator|:
name|EVT
name|getVT
argument_list|()
specifier|const
block|{
return|return
name|ValueType
return|;
block|}
specifier|static
name|bool
name|classof
argument_list|(
argument|const SDNode *N
argument_list|)
block|{
return|return
name|N
operator|->
name|getOpcode
argument_list|()
operator|==
name|ISD
operator|::
name|VALUETYPE
return|;
block|}
expr|}
block|;
comment|/// Base class for LoadSDNode and StoreSDNode
name|class
name|LSBaseSDNode
operator|:
name|public
name|MemSDNode
block|{
name|public
operator|:
name|LSBaseSDNode
argument_list|(
argument|ISD::NodeType NodeTy
argument_list|,
argument|unsigned Order
argument_list|,
argument|const DebugLoc&dl
argument_list|,
argument|SDVTList VTs
argument_list|,
argument|ISD::MemIndexedMode AM
argument_list|,
argument|EVT MemVT
argument_list|,
argument|MachineMemOperand *MMO
argument_list|)
operator|:
name|MemSDNode
argument_list|(
argument|NodeTy
argument_list|,
argument|Order
argument_list|,
argument|dl
argument_list|,
argument|VTs
argument_list|,
argument|MemVT
argument_list|,
argument|MMO
argument_list|)
block|{
name|LSBaseSDNodeBits
operator|.
name|AddressingMode
operator|=
name|AM
block|;
name|assert
argument_list|(
name|getAddressingMode
argument_list|()
operator|==
name|AM
operator|&&
literal|"Value truncated"
argument_list|)
block|;   }
specifier|const
name|SDValue
operator|&
name|getOffset
argument_list|()
specifier|const
block|{
return|return
name|getOperand
argument_list|(
name|getOpcode
argument_list|()
operator|==
name|ISD
operator|::
name|LOAD
condition|?
literal|2
else|:
literal|3
argument_list|)
return|;
block|}
comment|/// Return the addressing mode for this load or store:
comment|/// unindexed, pre-inc, pre-dec, post-inc, or post-dec.
name|ISD
operator|::
name|MemIndexedMode
name|getAddressingMode
argument_list|()
specifier|const
block|{
return|return
name|static_cast
operator|<
name|ISD
operator|::
name|MemIndexedMode
operator|>
operator|(
name|LSBaseSDNodeBits
operator|.
name|AddressingMode
operator|)
return|;
block|}
comment|/// Return true if this is a pre/post inc/dec load/store.
name|bool
name|isIndexed
argument_list|()
specifier|const
block|{
return|return
name|getAddressingMode
argument_list|()
operator|!=
name|ISD
operator|::
name|UNINDEXED
return|;
block|}
comment|/// Return true if this is NOT a pre/post inc/dec load/store.
name|bool
name|isUnindexed
argument_list|()
specifier|const
block|{
return|return
name|getAddressingMode
argument_list|()
operator|==
name|ISD
operator|::
name|UNINDEXED
return|;
block|}
specifier|static
name|bool
name|classof
argument_list|(
argument|const SDNode *N
argument_list|)
block|{
return|return
name|N
operator|->
name|getOpcode
argument_list|()
operator|==
name|ISD
operator|::
name|LOAD
operator|||
name|N
operator|->
name|getOpcode
argument_list|()
operator|==
name|ISD
operator|::
name|STORE
return|;
block|}
expr|}
block|;
comment|/// This class is used to represent ISD::LOAD nodes.
name|class
name|LoadSDNode
operator|:
name|public
name|LSBaseSDNode
block|{
name|friend
name|class
name|SelectionDAG
block|;
name|LoadSDNode
argument_list|(
argument|unsigned Order
argument_list|,
argument|const DebugLoc&dl
argument_list|,
argument|SDVTList VTs
argument_list|,
argument|ISD::MemIndexedMode AM
argument_list|,
argument|ISD::LoadExtType ETy
argument_list|,
argument|EVT MemVT
argument_list|,
argument|MachineMemOperand *MMO
argument_list|)
operator|:
name|LSBaseSDNode
argument_list|(
argument|ISD::LOAD
argument_list|,
argument|Order
argument_list|,
argument|dl
argument_list|,
argument|VTs
argument_list|,
argument|AM
argument_list|,
argument|MemVT
argument_list|,
argument|MMO
argument_list|)
block|{
name|LoadSDNodeBits
operator|.
name|ExtTy
operator|=
name|ETy
block|;
name|assert
argument_list|(
name|readMem
argument_list|()
operator|&&
literal|"Load MachineMemOperand is not a load!"
argument_list|)
block|;
name|assert
argument_list|(
operator|!
name|writeMem
argument_list|()
operator|&&
literal|"Load MachineMemOperand is a store!"
argument_list|)
block|;   }
name|public
operator|:
comment|/// Return whether this is a plain node,
comment|/// or one of the varieties of value-extending loads.
name|ISD
operator|::
name|LoadExtType
name|getExtensionType
argument_list|()
specifier|const
block|{
return|return
name|static_cast
operator|<
name|ISD
operator|::
name|LoadExtType
operator|>
operator|(
name|LoadSDNodeBits
operator|.
name|ExtTy
operator|)
return|;
block|}
specifier|const
name|SDValue
operator|&
name|getBasePtr
argument_list|()
specifier|const
block|{
return|return
name|getOperand
argument_list|(
literal|1
argument_list|)
return|;
block|}
specifier|const
name|SDValue
operator|&
name|getOffset
argument_list|()
specifier|const
block|{
return|return
name|getOperand
argument_list|(
literal|2
argument_list|)
return|;
block|}
specifier|static
name|bool
name|classof
argument_list|(
argument|const SDNode *N
argument_list|)
block|{
return|return
name|N
operator|->
name|getOpcode
argument_list|()
operator|==
name|ISD
operator|::
name|LOAD
return|;
block|}
expr|}
block|;
comment|/// This class is used to represent ISD::STORE nodes.
name|class
name|StoreSDNode
operator|:
name|public
name|LSBaseSDNode
block|{
name|friend
name|class
name|SelectionDAG
block|;
name|StoreSDNode
argument_list|(
argument|unsigned Order
argument_list|,
argument|const DebugLoc&dl
argument_list|,
argument|SDVTList VTs
argument_list|,
argument|ISD::MemIndexedMode AM
argument_list|,
argument|bool isTrunc
argument_list|,
argument|EVT MemVT
argument_list|,
argument|MachineMemOperand *MMO
argument_list|)
operator|:
name|LSBaseSDNode
argument_list|(
argument|ISD::STORE
argument_list|,
argument|Order
argument_list|,
argument|dl
argument_list|,
argument|VTs
argument_list|,
argument|AM
argument_list|,
argument|MemVT
argument_list|,
argument|MMO
argument_list|)
block|{
name|StoreSDNodeBits
operator|.
name|IsTruncating
operator|=
name|isTrunc
block|;
name|assert
argument_list|(
operator|!
name|readMem
argument_list|()
operator|&&
literal|"Store MachineMemOperand is a load!"
argument_list|)
block|;
name|assert
argument_list|(
name|writeMem
argument_list|()
operator|&&
literal|"Store MachineMemOperand is not a store!"
argument_list|)
block|;   }
name|public
operator|:
comment|/// Return true if the op does a truncation before store.
comment|/// For integers this is the same as doing a TRUNCATE and storing the result.
comment|/// For floats, it is the same as doing an FP_ROUND and storing the result.
name|bool
name|isTruncatingStore
argument_list|()
specifier|const
block|{
return|return
name|StoreSDNodeBits
operator|.
name|IsTruncating
return|;
block|}
specifier|const
name|SDValue
operator|&
name|getValue
argument_list|()
specifier|const
block|{
return|return
name|getOperand
argument_list|(
literal|1
argument_list|)
return|;
block|}
specifier|const
name|SDValue
operator|&
name|getBasePtr
argument_list|()
specifier|const
block|{
return|return
name|getOperand
argument_list|(
literal|2
argument_list|)
return|;
block|}
specifier|const
name|SDValue
operator|&
name|getOffset
argument_list|()
specifier|const
block|{
return|return
name|getOperand
argument_list|(
literal|3
argument_list|)
return|;
block|}
specifier|static
name|bool
name|classof
argument_list|(
argument|const SDNode *N
argument_list|)
block|{
return|return
name|N
operator|->
name|getOpcode
argument_list|()
operator|==
name|ISD
operator|::
name|STORE
return|;
block|}
expr|}
block|;
comment|/// This base class is used to represent MLOAD and MSTORE nodes
name|class
name|MaskedLoadStoreSDNode
operator|:
name|public
name|MemSDNode
block|{
name|public
operator|:
name|friend
name|class
name|SelectionDAG
block|;
name|MaskedLoadStoreSDNode
argument_list|(
argument|ISD::NodeType NodeTy
argument_list|,
argument|unsigned Order
argument_list|,
argument|const DebugLoc&dl
argument_list|,
argument|SDVTList VTs
argument_list|,
argument|EVT MemVT
argument_list|,
argument|MachineMemOperand *MMO
argument_list|)
operator|:
name|MemSDNode
argument_list|(
argument|NodeTy
argument_list|,
argument|Order
argument_list|,
argument|dl
argument_list|,
argument|VTs
argument_list|,
argument|MemVT
argument_list|,
argument|MMO
argument_list|)
block|{}
comment|// In the both nodes address is Op1, mask is Op2:
comment|// MaskedLoadSDNode (Chain, ptr, mask, src0), src0 is a passthru value
comment|// MaskedStoreSDNode (Chain, ptr, mask, data)
comment|// Mask is a vector of i1 elements
specifier|const
name|SDValue
operator|&
name|getBasePtr
argument_list|()
specifier|const
block|{
return|return
name|getOperand
argument_list|(
literal|1
argument_list|)
return|;
block|}
specifier|const
name|SDValue
operator|&
name|getMask
argument_list|()
specifier|const
block|{
return|return
name|getOperand
argument_list|(
literal|2
argument_list|)
return|;
block|}
specifier|static
name|bool
name|classof
argument_list|(
argument|const SDNode *N
argument_list|)
block|{
return|return
name|N
operator|->
name|getOpcode
argument_list|()
operator|==
name|ISD
operator|::
name|MLOAD
operator|||
name|N
operator|->
name|getOpcode
argument_list|()
operator|==
name|ISD
operator|::
name|MSTORE
return|;
block|}
expr|}
block|;
comment|/// This class is used to represent an MLOAD node
name|class
name|MaskedLoadSDNode
operator|:
name|public
name|MaskedLoadStoreSDNode
block|{
name|public
operator|:
name|friend
name|class
name|SelectionDAG
block|;
name|MaskedLoadSDNode
argument_list|(
argument|unsigned Order
argument_list|,
argument|const DebugLoc&dl
argument_list|,
argument|SDVTList VTs
argument_list|,
argument|ISD::LoadExtType ETy
argument_list|,
argument|bool IsExpanding
argument_list|,
argument|EVT MemVT
argument_list|,
argument|MachineMemOperand *MMO
argument_list|)
operator|:
name|MaskedLoadStoreSDNode
argument_list|(
argument|ISD::MLOAD
argument_list|,
argument|Order
argument_list|,
argument|dl
argument_list|,
argument|VTs
argument_list|,
argument|MemVT
argument_list|,
argument|MMO
argument_list|)
block|{
name|LoadSDNodeBits
operator|.
name|ExtTy
operator|=
name|ETy
block|;
name|LoadSDNodeBits
operator|.
name|IsExpanding
operator|=
name|IsExpanding
block|;   }
name|ISD
operator|::
name|LoadExtType
name|getExtensionType
argument_list|()
specifier|const
block|{
return|return
name|static_cast
operator|<
name|ISD
operator|::
name|LoadExtType
operator|>
operator|(
name|LoadSDNodeBits
operator|.
name|ExtTy
operator|)
return|;
block|}
specifier|const
name|SDValue
operator|&
name|getSrc0
argument_list|()
specifier|const
block|{
return|return
name|getOperand
argument_list|(
literal|3
argument_list|)
return|;
block|}
specifier|static
name|bool
name|classof
argument_list|(
argument|const SDNode *N
argument_list|)
block|{
return|return
name|N
operator|->
name|getOpcode
argument_list|()
operator|==
name|ISD
operator|::
name|MLOAD
return|;
block|}
name|bool
name|isExpandingLoad
argument_list|()
specifier|const
block|{
return|return
name|LoadSDNodeBits
operator|.
name|IsExpanding
return|;
block|}
expr|}
block|;
comment|/// This class is used to represent an MSTORE node
name|class
name|MaskedStoreSDNode
operator|:
name|public
name|MaskedLoadStoreSDNode
block|{
name|public
operator|:
name|friend
name|class
name|SelectionDAG
block|;
name|MaskedStoreSDNode
argument_list|(
argument|unsigned Order
argument_list|,
argument|const DebugLoc&dl
argument_list|,
argument|SDVTList VTs
argument_list|,
argument|bool isTrunc
argument_list|,
argument|bool isCompressing
argument_list|,
argument|EVT MemVT
argument_list|,
argument|MachineMemOperand *MMO
argument_list|)
operator|:
name|MaskedLoadStoreSDNode
argument_list|(
argument|ISD::MSTORE
argument_list|,
argument|Order
argument_list|,
argument|dl
argument_list|,
argument|VTs
argument_list|,
argument|MemVT
argument_list|,
argument|MMO
argument_list|)
block|{
name|StoreSDNodeBits
operator|.
name|IsTruncating
operator|=
name|isTrunc
block|;
name|StoreSDNodeBits
operator|.
name|IsCompressing
operator|=
name|isCompressing
block|;   }
comment|/// Return true if the op does a truncation before store.
comment|/// For integers this is the same as doing a TRUNCATE and storing the result.
comment|/// For floats, it is the same as doing an FP_ROUND and storing the result.
name|bool
name|isTruncatingStore
argument_list|()
specifier|const
block|{
return|return
name|StoreSDNodeBits
operator|.
name|IsTruncating
return|;
block|}
comment|/// Returns true if the op does a compression to the vector before storing.
comment|/// The node contiguously stores the active elements (integers or floats)
comment|/// in src (those with their respective bit set in writemask k) to unaligned
comment|/// memory at base_addr.
name|bool
name|isCompressingStore
argument_list|()
specifier|const
block|{
return|return
name|StoreSDNodeBits
operator|.
name|IsCompressing
return|;
block|}
specifier|const
name|SDValue
operator|&
name|getValue
argument_list|()
specifier|const
block|{
return|return
name|getOperand
argument_list|(
literal|3
argument_list|)
return|;
block|}
specifier|static
name|bool
name|classof
argument_list|(
argument|const SDNode *N
argument_list|)
block|{
return|return
name|N
operator|->
name|getOpcode
argument_list|()
operator|==
name|ISD
operator|::
name|MSTORE
return|;
block|}
expr|}
block|;
comment|/// This is a base class used to represent
comment|/// MGATHER and MSCATTER nodes
comment|///
name|class
name|MaskedGatherScatterSDNode
operator|:
name|public
name|MemSDNode
block|{
name|public
operator|:
name|friend
name|class
name|SelectionDAG
block|;
name|MaskedGatherScatterSDNode
argument_list|(
argument|unsigned NodeTy
argument_list|,
argument|unsigned Order
argument_list|,
argument|const DebugLoc&dl
argument_list|,
argument|SDVTList VTs
argument_list|,
argument|EVT MemVT
argument_list|,
argument|MachineMemOperand *MMO
argument_list|)
operator|:
name|MemSDNode
argument_list|(
argument|NodeTy
argument_list|,
argument|Order
argument_list|,
argument|dl
argument_list|,
argument|VTs
argument_list|,
argument|MemVT
argument_list|,
argument|MMO
argument_list|)
block|{}
comment|// In the both nodes address is Op1, mask is Op2:
comment|// MaskedGatherSDNode  (Chain, src0, mask, base, index), src0 is a passthru value
comment|// MaskedScatterSDNode (Chain, value, mask, base, index)
comment|// Mask is a vector of i1 elements
specifier|const
name|SDValue
operator|&
name|getBasePtr
argument_list|()
specifier|const
block|{
return|return
name|getOperand
argument_list|(
literal|3
argument_list|)
return|;
block|}
specifier|const
name|SDValue
operator|&
name|getIndex
argument_list|()
specifier|const
block|{
return|return
name|getOperand
argument_list|(
literal|4
argument_list|)
return|;
block|}
specifier|const
name|SDValue
operator|&
name|getMask
argument_list|()
specifier|const
block|{
return|return
name|getOperand
argument_list|(
literal|2
argument_list|)
return|;
block|}
specifier|const
name|SDValue
operator|&
name|getValue
argument_list|()
specifier|const
block|{
return|return
name|getOperand
argument_list|(
literal|1
argument_list|)
return|;
block|}
specifier|static
name|bool
name|classof
argument_list|(
argument|const SDNode *N
argument_list|)
block|{
return|return
name|N
operator|->
name|getOpcode
argument_list|()
operator|==
name|ISD
operator|::
name|MGATHER
operator|||
name|N
operator|->
name|getOpcode
argument_list|()
operator|==
name|ISD
operator|::
name|MSCATTER
return|;
block|}
expr|}
block|;
comment|/// This class is used to represent an MGATHER node
comment|///
name|class
name|MaskedGatherSDNode
operator|:
name|public
name|MaskedGatherScatterSDNode
block|{
name|public
operator|:
name|friend
name|class
name|SelectionDAG
block|;
name|MaskedGatherSDNode
argument_list|(
argument|unsigned Order
argument_list|,
argument|const DebugLoc&dl
argument_list|,
argument|SDVTList VTs
argument_list|,
argument|EVT MemVT
argument_list|,
argument|MachineMemOperand *MMO
argument_list|)
operator|:
name|MaskedGatherScatterSDNode
argument_list|(
argument|ISD::MGATHER
argument_list|,
argument|Order
argument_list|,
argument|dl
argument_list|,
argument|VTs
argument_list|,
argument|MemVT
argument_list|,
argument|MMO
argument_list|)
block|{}
specifier|static
name|bool
name|classof
argument_list|(
argument|const SDNode *N
argument_list|)
block|{
return|return
name|N
operator|->
name|getOpcode
argument_list|()
operator|==
name|ISD
operator|::
name|MGATHER
return|;
block|}
expr|}
block|;
comment|/// This class is used to represent an MSCATTER node
comment|///
name|class
name|MaskedScatterSDNode
operator|:
name|public
name|MaskedGatherScatterSDNode
block|{
name|public
operator|:
name|friend
name|class
name|SelectionDAG
block|;
name|MaskedScatterSDNode
argument_list|(
argument|unsigned Order
argument_list|,
argument|const DebugLoc&dl
argument_list|,
argument|SDVTList VTs
argument_list|,
argument|EVT MemVT
argument_list|,
argument|MachineMemOperand *MMO
argument_list|)
operator|:
name|MaskedGatherScatterSDNode
argument_list|(
argument|ISD::MSCATTER
argument_list|,
argument|Order
argument_list|,
argument|dl
argument_list|,
argument|VTs
argument_list|,
argument|MemVT
argument_list|,
argument|MMO
argument_list|)
block|{}
specifier|static
name|bool
name|classof
argument_list|(
argument|const SDNode *N
argument_list|)
block|{
return|return
name|N
operator|->
name|getOpcode
argument_list|()
operator|==
name|ISD
operator|::
name|MSCATTER
return|;
block|}
expr|}
block|;
comment|/// An SDNode that represents everything that will be needed
comment|/// to construct a MachineInstr. These nodes are created during the
comment|/// instruction selection proper phase.
name|class
name|MachineSDNode
operator|:
name|public
name|SDNode
block|{
name|public
operator|:
name|using
name|mmo_iterator
operator|=
name|MachineMemOperand
operator|*
operator|*
block|;
name|private
operator|:
name|friend
name|class
name|SelectionDAG
block|;
name|MachineSDNode
argument_list|(
argument|unsigned Opc
argument_list|,
argument|unsigned Order
argument_list|,
argument|const DebugLoc&DL
argument_list|,
argument|SDVTList VTs
argument_list|)
operator|:
name|SDNode
argument_list|(
argument|Opc
argument_list|,
argument|Order
argument_list|,
argument|DL
argument_list|,
argument|VTs
argument_list|)
block|{}
comment|/// Memory reference descriptions for this instruction.
name|mmo_iterator
name|MemRefs
operator|=
name|nullptr
block|;
name|mmo_iterator
name|MemRefsEnd
operator|=
name|nullptr
block|;
name|public
operator|:
name|mmo_iterator
name|memoperands_begin
argument_list|()
specifier|const
block|{
return|return
name|MemRefs
return|;
block|}
name|mmo_iterator
name|memoperands_end
argument_list|()
specifier|const
block|{
return|return
name|MemRefsEnd
return|;
block|}
name|bool
name|memoperands_empty
argument_list|()
specifier|const
block|{
return|return
name|MemRefsEnd
operator|==
name|MemRefs
return|;
block|}
comment|/// Assign this MachineSDNodes's memory reference descriptor
comment|/// list. This does not transfer ownership.
name|void
name|setMemRefs
argument_list|(
argument|mmo_iterator NewMemRefs
argument_list|,
argument|mmo_iterator NewMemRefsEnd
argument_list|)
block|{
for|for
control|(
name|mmo_iterator
name|MMI
init|=
name|NewMemRefs
init|,
name|MME
init|=
name|NewMemRefsEnd
init|;
name|MMI
operator|!=
name|MME
condition|;
operator|++
name|MMI
control|)
name|assert
argument_list|(
operator|*
name|MMI
operator|&&
literal|"Null mem ref detected!"
argument_list|)
expr_stmt|;
name|MemRefs
operator|=
name|NewMemRefs
block|;
name|MemRefsEnd
operator|=
name|NewMemRefsEnd
block|;   }
specifier|static
name|bool
name|classof
argument_list|(
argument|const SDNode *N
argument_list|)
block|{
return|return
name|N
operator|->
name|isMachineOpcode
argument_list|()
return|;
block|}
expr|}
block|;
name|class
name|SDNodeIterator
operator|:
name|public
name|std
operator|::
name|iterator
operator|<
name|std
operator|::
name|forward_iterator_tag
block|,
name|SDNode
block|,
name|ptrdiff_t
operator|>
block|{
specifier|const
name|SDNode
operator|*
name|Node
block|;
name|unsigned
name|Operand
block|;
name|SDNodeIterator
argument_list|(
argument|const SDNode *N
argument_list|,
argument|unsigned Op
argument_list|)
operator|:
name|Node
argument_list|(
name|N
argument_list|)
block|,
name|Operand
argument_list|(
argument|Op
argument_list|)
block|{}
name|public
operator|:
name|bool
name|operator
operator|==
operator|(
specifier|const
name|SDNodeIterator
operator|&
name|x
operator|)
specifier|const
block|{
return|return
name|Operand
operator|==
name|x
operator|.
name|Operand
return|;
block|}
name|bool
name|operator
operator|!=
operator|(
specifier|const
name|SDNodeIterator
operator|&
name|x
operator|)
specifier|const
block|{
return|return
operator|!
name|operator
operator|==
operator|(
name|x
operator|)
return|;
block|}
name|pointer
name|operator
operator|*
operator|(
operator|)
specifier|const
block|{
return|return
name|Node
operator|->
name|getOperand
argument_list|(
name|Operand
argument_list|)
operator|.
name|getNode
argument_list|()
return|;
block|}
name|pointer
name|operator
operator|->
expr|(
block|)
specifier|const
block|{
return|return
name|operator
operator|*
operator|(
operator|)
return|;
block|}
name|SDNodeIterator
operator|&
name|operator
operator|++
operator|(
operator|)
block|{
comment|// Preincrement
operator|++
name|Operand
block|;
return|return
operator|*
name|this
return|;
block|}
name|SDNodeIterator
name|operator
operator|++
operator|(
name|int
operator|)
block|{
comment|// Postincrement
name|SDNodeIterator
name|tmp
operator|=
operator|*
name|this
block|;
operator|++
operator|*
name|this
block|;
return|return
name|tmp
return|;
block|}
name|size_t
name|operator
operator|-
operator|(
name|SDNodeIterator
name|Other
operator|)
specifier|const
block|{
name|assert
argument_list|(
name|Node
operator|==
name|Other
operator|.
name|Node
operator|&&
literal|"Cannot compare iterators of two different nodes!"
argument_list|)
block|;
return|return
name|Operand
operator|-
name|Other
operator|.
name|Operand
return|;
block|}
specifier|static
name|SDNodeIterator
name|begin
argument_list|(
argument|const SDNode *N
argument_list|)
block|{
return|return
name|SDNodeIterator
argument_list|(
name|N
argument_list|,
literal|0
argument_list|)
return|;
block|}
specifier|static
name|SDNodeIterator
name|end
argument_list|(
argument|const SDNode *N
argument_list|)
block|{
return|return
name|SDNodeIterator
argument_list|(
name|N
argument_list|,
name|N
operator|->
name|getNumOperands
argument_list|()
argument_list|)
return|;
block|}
name|unsigned
name|getOperand
argument_list|()
specifier|const
block|{
return|return
name|Operand
return|;
block|}
specifier|const
name|SDNode
operator|*
name|getNode
argument_list|()
specifier|const
block|{
return|return
name|Node
return|;
block|}
expr|}
block|;
name|template
operator|<
operator|>
expr|struct
name|GraphTraits
operator|<
name|SDNode
operator|*
operator|>
block|{
name|using
name|NodeRef
operator|=
name|SDNode
operator|*
block|;
name|using
name|ChildIteratorType
operator|=
name|SDNodeIterator
block|;
specifier|static
name|NodeRef
name|getEntryNode
argument_list|(
argument|SDNode *N
argument_list|)
block|{
return|return
name|N
return|;
block|}
specifier|static
name|ChildIteratorType
name|child_begin
argument_list|(
argument|NodeRef N
argument_list|)
block|{
return|return
name|SDNodeIterator
operator|::
name|begin
argument_list|(
name|N
argument_list|)
return|;
block|}
specifier|static
name|ChildIteratorType
name|child_end
argument_list|(
argument|NodeRef N
argument_list|)
block|{
return|return
name|SDNodeIterator
operator|::
name|end
argument_list|(
name|N
argument_list|)
return|;
block|}
expr|}
block|;
comment|/// A representation of the largest SDNode, for use in sizeof().
comment|///
comment|/// This needs to be a union because the largest node differs on 32 bit systems
comment|/// with 4 and 8 byte pointer alignment, respectively.
name|using
name|LargestSDNode
operator|=
name|AlignedCharArrayUnion
operator|<
name|AtomicSDNode
block|,
name|TargetIndexSDNode
block|,
name|BlockAddressSDNode
block|,
name|GlobalAddressSDNode
operator|>
block|;
comment|/// The SDNode class with the greatest alignment requirement.
name|using
name|MostAlignedSDNode
operator|=
name|GlobalAddressSDNode
block|;
name|namespace
name|ISD
block|{
comment|/// Returns true if the specified node is a non-extending and unindexed load.
specifier|inline
name|bool
name|isNormalLoad
argument_list|(
argument|const SDNode *N
argument_list|)
block|{
specifier|const
name|LoadSDNode
operator|*
name|Ld
operator|=
name|dyn_cast
operator|<
name|LoadSDNode
operator|>
operator|(
name|N
operator|)
block|;
return|return
name|Ld
operator|&&
name|Ld
operator|->
name|getExtensionType
argument_list|()
operator|==
name|ISD
operator|::
name|NON_EXTLOAD
operator|&&
name|Ld
operator|->
name|getAddressingMode
argument_list|()
operator|==
name|ISD
operator|::
name|UNINDEXED
return|;
block|}
comment|/// Returns true if the specified node is a non-extending load.
specifier|inline
name|bool
name|isNON_EXTLoad
argument_list|(
argument|const SDNode *N
argument_list|)
block|{
return|return
name|isa
operator|<
name|LoadSDNode
operator|>
operator|(
name|N
operator|)
operator|&&
name|cast
operator|<
name|LoadSDNode
operator|>
operator|(
name|N
operator|)
operator|->
name|getExtensionType
argument_list|()
operator|==
name|ISD
operator|::
name|NON_EXTLOAD
return|;
block|}
comment|/// Returns true if the specified node is a EXTLOAD.
specifier|inline
name|bool
name|isEXTLoad
argument_list|(
argument|const SDNode *N
argument_list|)
block|{
return|return
name|isa
operator|<
name|LoadSDNode
operator|>
operator|(
name|N
operator|)
operator|&&
name|cast
operator|<
name|LoadSDNode
operator|>
operator|(
name|N
operator|)
operator|->
name|getExtensionType
argument_list|()
operator|==
name|ISD
operator|::
name|EXTLOAD
return|;
block|}
comment|/// Returns true if the specified node is a SEXTLOAD.
specifier|inline
name|bool
name|isSEXTLoad
argument_list|(
argument|const SDNode *N
argument_list|)
block|{
return|return
name|isa
operator|<
name|LoadSDNode
operator|>
operator|(
name|N
operator|)
operator|&&
name|cast
operator|<
name|LoadSDNode
operator|>
operator|(
name|N
operator|)
operator|->
name|getExtensionType
argument_list|()
operator|==
name|ISD
operator|::
name|SEXTLOAD
return|;
block|}
comment|/// Returns true if the specified node is a ZEXTLOAD.
specifier|inline
name|bool
name|isZEXTLoad
argument_list|(
argument|const SDNode *N
argument_list|)
block|{
return|return
name|isa
operator|<
name|LoadSDNode
operator|>
operator|(
name|N
operator|)
operator|&&
name|cast
operator|<
name|LoadSDNode
operator|>
operator|(
name|N
operator|)
operator|->
name|getExtensionType
argument_list|()
operator|==
name|ISD
operator|::
name|ZEXTLOAD
return|;
block|}
comment|/// Returns true if the specified node is an unindexed load.
specifier|inline
name|bool
name|isUNINDEXEDLoad
argument_list|(
argument|const SDNode *N
argument_list|)
block|{
return|return
name|isa
operator|<
name|LoadSDNode
operator|>
operator|(
name|N
operator|)
operator|&&
name|cast
operator|<
name|LoadSDNode
operator|>
operator|(
name|N
operator|)
operator|->
name|getAddressingMode
argument_list|()
operator|==
name|ISD
operator|::
name|UNINDEXED
return|;
block|}
comment|/// Returns true if the specified node is a non-truncating
comment|/// and unindexed store.
specifier|inline
name|bool
name|isNormalStore
argument_list|(
argument|const SDNode *N
argument_list|)
block|{
specifier|const
name|StoreSDNode
operator|*
name|St
operator|=
name|dyn_cast
operator|<
name|StoreSDNode
operator|>
operator|(
name|N
operator|)
block|;
return|return
name|St
operator|&&
operator|!
name|St
operator|->
name|isTruncatingStore
argument_list|()
operator|&&
name|St
operator|->
name|getAddressingMode
argument_list|()
operator|==
name|ISD
operator|::
name|UNINDEXED
return|;
block|}
comment|/// Returns true if the specified node is a non-truncating store.
specifier|inline
name|bool
name|isNON_TRUNCStore
argument_list|(
argument|const SDNode *N
argument_list|)
block|{
return|return
name|isa
operator|<
name|StoreSDNode
operator|>
operator|(
name|N
operator|)
operator|&&
operator|!
name|cast
operator|<
name|StoreSDNode
operator|>
operator|(
name|N
operator|)
operator|->
name|isTruncatingStore
argument_list|()
return|;
block|}
comment|/// Returns true if the specified node is a truncating store.
specifier|inline
name|bool
name|isTRUNCStore
argument_list|(
argument|const SDNode *N
argument_list|)
block|{
return|return
name|isa
operator|<
name|StoreSDNode
operator|>
operator|(
name|N
operator|)
operator|&&
name|cast
operator|<
name|StoreSDNode
operator|>
operator|(
name|N
operator|)
operator|->
name|isTruncatingStore
argument_list|()
return|;
block|}
comment|/// Returns true if the specified node is an unindexed store.
specifier|inline
name|bool
name|isUNINDEXEDStore
argument_list|(
argument|const SDNode *N
argument_list|)
block|{
return|return
name|isa
operator|<
name|StoreSDNode
operator|>
operator|(
name|N
operator|)
operator|&&
name|cast
operator|<
name|StoreSDNode
operator|>
operator|(
name|N
operator|)
operator|->
name|getAddressingMode
argument_list|()
operator|==
name|ISD
operator|::
name|UNINDEXED
return|;
block|}
expr|}
comment|// end namespace ISD
expr|}
end_decl_stmt

begin_comment
comment|// end namespace llvm
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|// LLVM_CODEGEN_SELECTIONDAGNODES_H
end_comment

end_unit

