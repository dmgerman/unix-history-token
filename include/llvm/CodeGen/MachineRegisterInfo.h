begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===-- llvm/CodeGen/MachineRegisterInfo.h ----------------------*- C++ -*-===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file defines the MachineRegisterInfo class.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LLVM_CODEGEN_MACHINEREGISTERINFO_H
end_ifndef

begin_define
define|#
directive|define
name|LLVM_CODEGEN_MACHINEREGISTERINFO_H
end_define

begin_include
include|#
directive|include
file|"llvm/Target/TargetRegisterInfo.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/BitVector.h"
end_include

begin_include
include|#
directive|include
file|<vector>
end_include

begin_decl_stmt
name|namespace
name|llvm
block|{
comment|/// MachineRegisterInfo - Keep track of information for virtual and physical
comment|/// registers, including vreg register classes, use/def chains for registers,
comment|/// etc.
name|class
name|MachineRegisterInfo
block|{
comment|/// VRegInfo - Information we keep for each virtual register.  The entries in
comment|/// this vector are actually converted to vreg numbers by adding the
comment|/// TargetRegisterInfo::FirstVirtualRegister delta to their index.
comment|///
comment|/// Each element in this list contains the register class of the vreg and the
comment|/// start of the use/def list for the register.
name|std
operator|::
name|vector
operator|<
name|std
operator|::
name|pair
operator|<
specifier|const
name|TargetRegisterClass
operator|*
operator|,
name|MachineOperand
operator|*
operator|>
expr|>
name|VRegInfo
expr_stmt|;
comment|/// RegClassVRegMap - This vector acts as a map from TargetRegisterClass to
comment|/// virtual registers. For each target register class, it keeps a list of
comment|/// virtual registers belonging to the class.
name|std
operator|::
name|vector
operator|<
name|std
operator|::
name|vector
operator|<
name|unsigned
operator|>
expr|>
name|RegClass2VRegMap
expr_stmt|;
comment|/// RegAllocHints - This vector records register allocation hints for virtual
comment|/// registers. For each virtual register, it keeps a register and hint type
comment|/// pair making up the allocation hint. Hint type is target specific except
comment|/// for the value 0 which means the second value of the pair is the preferred
comment|/// register for allocation. For example, if the hint is<0, 1024>, it means
comment|/// the allocator should prefer the physical register allocated to the virtual
comment|/// register of the hint.
name|std
operator|::
name|vector
operator|<
name|std
operator|::
name|pair
operator|<
name|unsigned
operator|,
name|unsigned
operator|>
expr|>
name|RegAllocHints
expr_stmt|;
comment|/// PhysRegUseDefLists - This is an array of the head of the use/def list for
comment|/// physical registers.
name|MachineOperand
modifier|*
modifier|*
name|PhysRegUseDefLists
decl_stmt|;
comment|/// UsedPhysRegs - This is a bit vector that is computed and set by the
comment|/// register allocator, and must be kept up to date by passes that run after
comment|/// register allocation (though most don't modify this).  This is used
comment|/// so that the code generator knows which callee save registers to save and
comment|/// for other target specific uses.
name|BitVector
name|UsedPhysRegs
decl_stmt|;
comment|/// LiveIns/LiveOuts - Keep track of the physical registers that are
comment|/// livein/liveout of the function.  Live in values are typically arguments in
comment|/// registers, live out values are typically return values in registers.
comment|/// LiveIn values are allowed to have virtual registers associated with them,
comment|/// stored in the second element.
name|std
operator|::
name|vector
operator|<
name|std
operator|::
name|pair
operator|<
name|unsigned
operator|,
name|unsigned
operator|>
expr|>
name|LiveIns
expr_stmt|;
name|std
operator|::
name|vector
operator|<
name|unsigned
operator|>
name|LiveOuts
expr_stmt|;
name|MachineRegisterInfo
argument_list|(
specifier|const
name|MachineRegisterInfo
operator|&
argument_list|)
expr_stmt|;
comment|// DO NOT IMPLEMENT
name|void
name|operator
init|=
operator|(
specifier|const
name|MachineRegisterInfo
operator|&
operator|)
decl_stmt|;
comment|// DO NOT IMPLEMENT
name|public
label|:
name|explicit
name|MachineRegisterInfo
parameter_list|(
specifier|const
name|TargetRegisterInfo
modifier|&
name|TRI
parameter_list|)
function_decl|;
operator|~
name|MachineRegisterInfo
argument_list|()
expr_stmt|;
comment|//===--------------------------------------------------------------------===//
comment|// Register Info
comment|//===--------------------------------------------------------------------===//
comment|/// reg_begin/reg_end - Provide iteration support to walk over all definitions
comment|/// and uses of a register within the MachineFunction that corresponds to this
comment|/// MachineRegisterInfo object.
name|template
operator|<
name|bool
name|Uses
operator|,
name|bool
name|Defs
operator|,
name|bool
name|SkipDebug
operator|>
name|class
name|defusechain_iterator
expr_stmt|;
comment|/// reg_iterator/reg_begin/reg_end - Walk all defs and uses of the specified
comment|/// register.
typedef|typedef
name|defusechain_iterator
operator|<
name|true
operator|,
name|true
operator|,
name|false
operator|>
name|reg_iterator
expr_stmt|;
name|reg_iterator
name|reg_begin
argument_list|(
name|unsigned
name|RegNo
argument_list|)
decl|const
block|{
return|return
name|reg_iterator
argument_list|(
name|getRegUseDefListHead
argument_list|(
name|RegNo
argument_list|)
argument_list|)
return|;
block|}
specifier|static
name|reg_iterator
name|reg_end
parameter_list|()
block|{
return|return
name|reg_iterator
argument_list|(
literal|0
argument_list|)
return|;
block|}
comment|/// reg_empty - Return true if there are no instructions using or defining the
comment|/// specified register (it may be live-in).
name|bool
name|reg_empty
argument_list|(
name|unsigned
name|RegNo
argument_list|)
decl|const
block|{
return|return
name|reg_begin
argument_list|(
name|RegNo
argument_list|)
operator|==
name|reg_end
argument_list|()
return|;
block|}
comment|/// def_iterator/def_begin/def_end - Walk all defs of the specified register.
typedef|typedef
name|defusechain_iterator
operator|<
name|false
operator|,
name|true
operator|,
name|false
operator|>
name|def_iterator
expr_stmt|;
name|def_iterator
name|def_begin
argument_list|(
name|unsigned
name|RegNo
argument_list|)
decl|const
block|{
return|return
name|def_iterator
argument_list|(
name|getRegUseDefListHead
argument_list|(
name|RegNo
argument_list|)
argument_list|)
return|;
block|}
specifier|static
name|def_iterator
name|def_end
parameter_list|()
block|{
return|return
name|def_iterator
argument_list|(
literal|0
argument_list|)
return|;
block|}
comment|/// def_empty - Return true if there are no instructions defining the
comment|/// specified register (it may be live-in).
name|bool
name|def_empty
argument_list|(
name|unsigned
name|RegNo
argument_list|)
decl|const
block|{
return|return
name|def_begin
argument_list|(
name|RegNo
argument_list|)
operator|==
name|def_end
argument_list|()
return|;
block|}
comment|/// use_iterator/use_begin/use_end - Walk all uses of the specified register.
typedef|typedef
name|defusechain_iterator
operator|<
name|true
operator|,
name|false
operator|,
name|false
operator|>
name|use_iterator
expr_stmt|;
name|use_iterator
name|use_begin
argument_list|(
name|unsigned
name|RegNo
argument_list|)
decl|const
block|{
return|return
name|use_iterator
argument_list|(
name|getRegUseDefListHead
argument_list|(
name|RegNo
argument_list|)
argument_list|)
return|;
block|}
specifier|static
name|use_iterator
name|use_end
parameter_list|()
block|{
return|return
name|use_iterator
argument_list|(
literal|0
argument_list|)
return|;
block|}
comment|/// use_empty - Return true if there are no instructions using the specified
comment|/// register.
name|bool
name|use_empty
argument_list|(
name|unsigned
name|RegNo
argument_list|)
decl|const
block|{
return|return
name|use_begin
argument_list|(
name|RegNo
argument_list|)
operator|==
name|use_end
argument_list|()
return|;
block|}
comment|/// hasOneUse - Return true if there is exactly one instruction using the
comment|/// specified register.
name|bool
name|hasOneUse
argument_list|(
name|unsigned
name|RegNo
argument_list|)
decl|const
decl_stmt|;
comment|/// use_nodbg_iterator/use_nodbg_begin/use_nodbg_end - Walk all uses of the
comment|/// specified register, skipping those marked as Debug.
typedef|typedef
name|defusechain_iterator
operator|<
name|true
operator|,
name|false
operator|,
name|true
operator|>
name|use_nodbg_iterator
expr_stmt|;
name|use_nodbg_iterator
name|use_nodbg_begin
argument_list|(
name|unsigned
name|RegNo
argument_list|)
decl|const
block|{
return|return
name|use_nodbg_iterator
argument_list|(
name|getRegUseDefListHead
argument_list|(
name|RegNo
argument_list|)
argument_list|)
return|;
block|}
specifier|static
name|use_nodbg_iterator
name|use_nodbg_end
parameter_list|()
block|{
return|return
name|use_nodbg_iterator
argument_list|(
literal|0
argument_list|)
return|;
block|}
comment|/// use_nodbg_empty - Return true if there are no non-Debug instructions
comment|/// using the specified register.
name|bool
name|use_nodbg_empty
argument_list|(
name|unsigned
name|RegNo
argument_list|)
decl|const
block|{
return|return
name|use_nodbg_begin
argument_list|(
name|RegNo
argument_list|)
operator|==
name|use_nodbg_end
argument_list|()
return|;
block|}
comment|/// hasOneNonDBGUse - Return true if there is exactly one non-Debug
comment|/// instruction using the specified register.
name|bool
name|hasOneNonDBGUse
argument_list|(
name|unsigned
name|RegNo
argument_list|)
decl|const
decl_stmt|;
comment|/// replaceRegWith - Replace all instances of FromReg with ToReg in the
comment|/// machine function.  This is like llvm-level X->replaceAllUsesWith(Y),
comment|/// except that it also changes any definitions of the register as well.
name|void
name|replaceRegWith
parameter_list|(
name|unsigned
name|FromReg
parameter_list|,
name|unsigned
name|ToReg
parameter_list|)
function_decl|;
comment|/// getRegUseDefListHead - Return the head pointer for the register use/def
comment|/// list for the specified virtual or physical register.
name|MachineOperand
modifier|*
modifier|&
name|getRegUseDefListHead
parameter_list|(
name|unsigned
name|RegNo
parameter_list|)
block|{
if|if
condition|(
name|RegNo
operator|<
name|TargetRegisterInfo
operator|::
name|FirstVirtualRegister
condition|)
return|return
name|PhysRegUseDefLists
index|[
name|RegNo
index|]
return|;
name|RegNo
operator|-=
name|TargetRegisterInfo
operator|::
name|FirstVirtualRegister
expr_stmt|;
return|return
name|VRegInfo
index|[
name|RegNo
index|]
operator|.
name|second
return|;
block|}
name|MachineOperand
modifier|*
name|getRegUseDefListHead
argument_list|(
name|unsigned
name|RegNo
argument_list|)
decl|const
block|{
if|if
condition|(
name|RegNo
operator|<
name|TargetRegisterInfo
operator|::
name|FirstVirtualRegister
condition|)
return|return
name|PhysRegUseDefLists
index|[
name|RegNo
index|]
return|;
name|RegNo
operator|-=
name|TargetRegisterInfo
operator|::
name|FirstVirtualRegister
expr_stmt|;
return|return
name|VRegInfo
index|[
name|RegNo
index|]
operator|.
name|second
return|;
block|}
comment|/// getVRegDef - Return the machine instr that defines the specified virtual
comment|/// register or null if none is found.  This assumes that the code is in SSA
comment|/// form, so there should only be one definition.
name|MachineInstr
modifier|*
name|getVRegDef
argument_list|(
name|unsigned
name|Reg
argument_list|)
decl|const
decl_stmt|;
ifndef|#
directive|ifndef
name|NDEBUG
name|void
name|dumpUses
argument_list|(
name|unsigned
name|RegNo
argument_list|)
decl|const
decl_stmt|;
endif|#
directive|endif
comment|//===--------------------------------------------------------------------===//
comment|// Virtual Register Info
comment|//===--------------------------------------------------------------------===//
comment|/// getRegClass - Return the register class of the specified virtual register.
comment|///
specifier|const
name|TargetRegisterClass
modifier|*
name|getRegClass
argument_list|(
name|unsigned
name|Reg
argument_list|)
decl|const
block|{
name|Reg
operator|-=
name|TargetRegisterInfo
operator|::
name|FirstVirtualRegister
expr_stmt|;
name|assert
argument_list|(
name|Reg
operator|<
name|VRegInfo
operator|.
name|size
argument_list|()
operator|&&
literal|"Invalid vreg!"
argument_list|)
expr_stmt|;
return|return
name|VRegInfo
index|[
name|Reg
index|]
operator|.
name|first
return|;
block|}
comment|/// setRegClass - Set the register class of the specified virtual register.
comment|///
name|void
name|setRegClass
parameter_list|(
name|unsigned
name|Reg
parameter_list|,
specifier|const
name|TargetRegisterClass
modifier|*
name|RC
parameter_list|)
function_decl|;
comment|/// createVirtualRegister - Create and return a new virtual register in the
comment|/// function with the specified register class.
comment|///
name|unsigned
name|createVirtualRegister
parameter_list|(
specifier|const
name|TargetRegisterClass
modifier|*
name|RegClass
parameter_list|)
function_decl|;
comment|/// getLastVirtReg - Return the highest currently assigned virtual register.
comment|///
name|unsigned
name|getLastVirtReg
argument_list|()
specifier|const
block|{
return|return
operator|(
name|unsigned
operator|)
name|VRegInfo
operator|.
name|size
argument_list|()
operator|+
name|TargetRegisterInfo
operator|::
name|FirstVirtualRegister
operator|-
literal|1
return|;
block|}
comment|/// getRegClassVirtRegs - Return the list of virtual registers of the given
comment|/// target register class.
name|std
operator|::
name|vector
operator|<
name|unsigned
operator|>
operator|&
name|getRegClassVirtRegs
argument_list|(
argument|const TargetRegisterClass *RC
argument_list|)
block|{
return|return
name|RegClass2VRegMap
index|[
name|RC
operator|->
name|getID
argument_list|()
index|]
return|;
block|}
comment|/// setRegAllocationHint - Specify a register allocation hint for the
comment|/// specified virtual register.
name|void
name|setRegAllocationHint
parameter_list|(
name|unsigned
name|Reg
parameter_list|,
name|unsigned
name|Type
parameter_list|,
name|unsigned
name|PrefReg
parameter_list|)
block|{
name|Reg
operator|-=
name|TargetRegisterInfo
operator|::
name|FirstVirtualRegister
expr_stmt|;
name|assert
argument_list|(
name|Reg
operator|<
name|VRegInfo
operator|.
name|size
argument_list|()
operator|&&
literal|"Invalid vreg!"
argument_list|)
expr_stmt|;
name|RegAllocHints
index|[
name|Reg
index|]
operator|.
name|first
operator|=
name|Type
expr_stmt|;
name|RegAllocHints
index|[
name|Reg
index|]
operator|.
name|second
operator|=
name|PrefReg
expr_stmt|;
block|}
comment|/// getRegAllocationHint - Return the register allocation hint for the
comment|/// specified virtual register.
name|std
operator|::
name|pair
operator|<
name|unsigned
operator|,
name|unsigned
operator|>
name|getRegAllocationHint
argument_list|(
argument|unsigned Reg
argument_list|)
specifier|const
block|{
name|Reg
operator|-=
name|TargetRegisterInfo
operator|::
name|FirstVirtualRegister
block|;
name|assert
argument_list|(
name|Reg
operator|<
name|VRegInfo
operator|.
name|size
argument_list|()
operator|&&
literal|"Invalid vreg!"
argument_list|)
block|;
return|return
name|RegAllocHints
index|[
name|Reg
index|]
return|;
block|}
comment|//===--------------------------------------------------------------------===//
comment|// Physical Register Use Info
comment|//===--------------------------------------------------------------------===//
comment|/// isPhysRegUsed - Return true if the specified register is used in this
comment|/// function.  This only works after register allocation.
name|bool
name|isPhysRegUsed
argument_list|(
name|unsigned
name|Reg
argument_list|)
decl|const
block|{
return|return
name|UsedPhysRegs
index|[
name|Reg
index|]
return|;
block|}
comment|/// setPhysRegUsed - Mark the specified register used in this function.
comment|/// This should only be called during and after register allocation.
name|void
name|setPhysRegUsed
parameter_list|(
name|unsigned
name|Reg
parameter_list|)
block|{
name|UsedPhysRegs
index|[
name|Reg
index|]
operator|=
name|true
expr_stmt|;
block|}
comment|/// setPhysRegUnused - Mark the specified register unused in this function.
comment|/// This should only be called during and after register allocation.
name|void
name|setPhysRegUnused
parameter_list|(
name|unsigned
name|Reg
parameter_list|)
block|{
name|UsedPhysRegs
index|[
name|Reg
index|]
operator|=
name|false
expr_stmt|;
block|}
comment|//===--------------------------------------------------------------------===//
comment|// LiveIn/LiveOut Management
comment|//===--------------------------------------------------------------------===//
comment|/// addLiveIn/Out - Add the specified register as a live in/out.  Note that it
comment|/// is an error to add the same register to the same set more than once.
name|void
name|addLiveIn
parameter_list|(
name|unsigned
name|Reg
parameter_list|,
name|unsigned
name|vreg
init|=
literal|0
parameter_list|)
block|{
name|LiveIns
operator|.
name|push_back
argument_list|(
name|std
operator|::
name|make_pair
argument_list|(
name|Reg
argument_list|,
name|vreg
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|void
name|addLiveOut
parameter_list|(
name|unsigned
name|Reg
parameter_list|)
block|{
name|LiveOuts
operator|.
name|push_back
argument_list|(
name|Reg
argument_list|)
expr_stmt|;
block|}
comment|// Iteration support for live in/out sets.  These sets are kept in sorted
comment|// order by their register number.
typedef|typedef
name|std
operator|::
name|vector
operator|<
name|std
operator|::
name|pair
operator|<
name|unsigned
operator|,
name|unsigned
operator|>
expr|>
operator|::
name|const_iterator
name|livein_iterator
expr_stmt|;
typedef|typedef
name|std
operator|::
name|vector
operator|<
name|unsigned
operator|>
operator|::
name|const_iterator
name|liveout_iterator
expr_stmt|;
name|livein_iterator
name|livein_begin
argument_list|()
specifier|const
block|{
return|return
name|LiveIns
operator|.
name|begin
argument_list|()
return|;
block|}
name|livein_iterator
name|livein_end
argument_list|()
specifier|const
block|{
return|return
name|LiveIns
operator|.
name|end
argument_list|()
return|;
block|}
name|bool
name|livein_empty
argument_list|()
specifier|const
block|{
return|return
name|LiveIns
operator|.
name|empty
argument_list|()
return|;
block|}
name|liveout_iterator
name|liveout_begin
argument_list|()
specifier|const
block|{
return|return
name|LiveOuts
operator|.
name|begin
argument_list|()
return|;
block|}
name|liveout_iterator
name|liveout_end
argument_list|()
specifier|const
block|{
return|return
name|LiveOuts
operator|.
name|end
argument_list|()
return|;
block|}
name|bool
name|liveout_empty
argument_list|()
specifier|const
block|{
return|return
name|LiveOuts
operator|.
name|empty
argument_list|()
return|;
block|}
name|bool
name|isLiveIn
argument_list|(
name|unsigned
name|Reg
argument_list|)
decl|const
decl_stmt|;
name|bool
name|isLiveOut
argument_list|(
name|unsigned
name|Reg
argument_list|)
decl|const
decl_stmt|;
comment|/// getLiveInPhysReg - If VReg is a live-in virtual register, return the
comment|/// corresponding live-in physical register.
name|unsigned
name|getLiveInPhysReg
argument_list|(
name|unsigned
name|VReg
argument_list|)
decl|const
decl_stmt|;
comment|/// EmitLiveInCopies - Emit copies to initialize livein virtual registers
comment|/// into the given entry block.
name|void
name|EmitLiveInCopies
parameter_list|(
name|MachineBasicBlock
modifier|*
name|EntryMBB
parameter_list|,
specifier|const
name|TargetRegisterInfo
modifier|&
name|TRI
parameter_list|,
specifier|const
name|TargetInstrInfo
modifier|&
name|TII
parameter_list|)
function_decl|;
name|private
label|:
name|void
name|HandleVRegListReallocation
parameter_list|()
function_decl|;
name|public
label|:
comment|/// defusechain_iterator - This class provides iterator support for machine
comment|/// operands in the function that use or define a specific register.  If
comment|/// ReturnUses is true it returns uses of registers, if ReturnDefs is true it
comment|/// returns defs.  If neither are true then you are silly and it always
comment|/// returns end().  If SkipDebug is true it skips uses marked Debug
comment|/// when incrementing.
name|template
operator|<
name|bool
name|ReturnUses
operator|,
name|bool
name|ReturnDefs
operator|,
name|bool
name|SkipDebug
operator|>
name|class
name|defusechain_iterator
operator|:
name|public
name|std
operator|::
name|iterator
operator|<
name|std
operator|::
name|forward_iterator_tag
operator|,
name|MachineInstr
operator|,
name|ptrdiff_t
operator|>
block|{
name|MachineOperand
operator|*
name|Op
block|;
name|explicit
name|defusechain_iterator
argument_list|(
name|MachineOperand
operator|*
name|op
argument_list|)
operator|:
name|Op
argument_list|(
argument|op
argument_list|)
block|{
comment|// If the first node isn't one we're interested in, advance to one that
comment|// we are interested in.
if|if
condition|(
name|op
condition|)
block|{
if|if
condition|(
operator|(
operator|!
name|ReturnUses
operator|&&
name|op
operator|->
name|isUse
argument_list|()
operator|)
operator|||
operator|(
operator|!
name|ReturnDefs
operator|&&
name|op
operator|->
name|isDef
argument_list|()
operator|)
operator|||
operator|(
name|SkipDebug
operator|&&
name|op
operator|->
name|isDebug
argument_list|()
operator|)
condition|)
operator|++
operator|*
name|this
expr_stmt|;
block|}
block|}
name|friend
name|class
name|MachineRegisterInfo
block|;
name|public
operator|:
typedef|typedef
name|std
operator|::
name|iterator
operator|<
name|std
operator|::
name|forward_iterator_tag
operator|,
name|MachineInstr
operator|,
name|ptrdiff_t
operator|>
operator|::
name|reference
name|reference
expr_stmt|;
typedef|typedef
name|std
operator|::
name|iterator
operator|<
name|std
operator|::
name|forward_iterator_tag
operator|,
name|MachineInstr
operator|,
name|ptrdiff_t
operator|>
operator|::
name|pointer
name|pointer
expr_stmt|;
name|defusechain_iterator
argument_list|(
specifier|const
name|defusechain_iterator
operator|&
name|I
argument_list|)
operator|:
name|Op
argument_list|(
argument|I.Op
argument_list|)
block|{}
name|defusechain_iterator
argument_list|()
operator|:
name|Op
argument_list|(
literal|0
argument_list|)
block|{}
name|bool
name|operator
operator|==
operator|(
specifier|const
name|defusechain_iterator
operator|&
name|x
operator|)
specifier|const
block|{
return|return
name|Op
operator|==
name|x
operator|.
name|Op
return|;
block|}
name|bool
name|operator
operator|!=
operator|(
specifier|const
name|defusechain_iterator
operator|&
name|x
operator|)
specifier|const
block|{
return|return
operator|!
name|operator
operator|==
operator|(
name|x
operator|)
return|;
block|}
comment|/// atEnd - return true if this iterator is equal to reg_end() on the value.
name|bool
name|atEnd
argument_list|()
specifier|const
block|{
return|return
name|Op
operator|==
literal|0
return|;
block|}
comment|// Iterator traversal: forward iteration only
name|defusechain_iterator
operator|&
name|operator
operator|++
operator|(
operator|)
block|{
comment|// Preincrement
name|assert
argument_list|(
name|Op
operator|&&
literal|"Cannot increment end iterator!"
argument_list|)
block|;
name|Op
operator|=
name|Op
operator|->
name|getNextOperandForReg
argument_list|()
block|;
comment|// If this is an operand we don't care about, skip it.
while|while
condition|(
name|Op
operator|&&
operator|(
operator|(
operator|!
name|ReturnUses
operator|&&
name|Op
operator|->
name|isUse
argument_list|()
operator|)
operator|||
operator|(
operator|!
name|ReturnDefs
operator|&&
name|Op
operator|->
name|isDef
argument_list|()
operator|)
operator|||
operator|(
name|SkipDebug
operator|&&
name|Op
operator|->
name|isDebug
argument_list|()
operator|)
operator|)
condition|)
name|Op
operator|=
name|Op
operator|->
name|getNextOperandForReg
argument_list|()
expr_stmt|;
return|return
operator|*
name|this
return|;
block|}
name|defusechain_iterator
name|operator
operator|++
operator|(
name|int
operator|)
block|{
comment|// Postincrement
name|defusechain_iterator
name|tmp
operator|=
operator|*
name|this
block|;
operator|++
operator|*
name|this
block|;
return|return
name|tmp
return|;
block|}
name|MachineOperand
operator|&
name|getOperand
argument_list|()
specifier|const
block|{
name|assert
argument_list|(
name|Op
operator|&&
literal|"Cannot dereference end iterator!"
argument_list|)
block|;
return|return
operator|*
name|Op
return|;
block|}
comment|/// getOperandNo - Return the operand # of this MachineOperand in its
comment|/// MachineInstr.
name|unsigned
name|getOperandNo
argument_list|()
specifier|const
block|{
name|assert
argument_list|(
name|Op
operator|&&
literal|"Cannot dereference end iterator!"
argument_list|)
block|;
return|return
name|Op
operator|-
operator|&
name|Op
operator|->
name|getParent
argument_list|()
operator|->
name|getOperand
argument_list|(
literal|0
argument_list|)
return|;
block|}
comment|// Retrieve a reference to the current operand.
name|MachineInstr
operator|&
name|operator
operator|*
operator|(
operator|)
specifier|const
block|{
name|assert
argument_list|(
name|Op
operator|&&
literal|"Cannot dereference end iterator!"
argument_list|)
block|;
return|return
operator|*
name|Op
operator|->
name|getParent
argument_list|()
return|;
block|}
name|MachineInstr
operator|*
name|operator
operator|->
expr|(
block|)
decl|const
block|{
name|assert
argument_list|(
name|Op
operator|&&
literal|"Cannot dereference end iterator!"
argument_list|)
expr_stmt|;
return|return
name|Op
operator|->
name|getParent
argument_list|()
return|;
block|}
end_decl_stmt

begin_comment
unit|};    };  }
comment|// End llvm namespace
end_comment

begin_endif
endif|#
directive|endif
end_endif

end_unit

