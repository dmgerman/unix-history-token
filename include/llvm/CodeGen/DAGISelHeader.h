begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//==-llvm/CodeGen/DAGISelHeader.h - Common DAG ISel definitions  -*- C++ -*-==//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file provides definitions of the common, target-independent methods and
end_comment

begin_comment
comment|// data, which is used by SelectionDAG-based instruction selectors.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// *** NOTE: This file is #included into the middle of the target
end_comment

begin_comment
comment|// instruction selector class.  These functions are really methods.
end_comment

begin_comment
comment|// This is a little awkward, but it allows this code to be shared
end_comment

begin_comment
comment|// by all the targets while still being able to call into
end_comment

begin_comment
comment|// target-specific code without using a virtual function call.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LLVM_CODEGEN_DAGISEL_HEADER_H
end_ifndef

begin_define
define|#
directive|define
name|LLVM_CODEGEN_DAGISEL_HEADER_H
end_define

begin_comment
comment|/// ISelPosition - Node iterator marking the current position of
end_comment

begin_comment
comment|/// instruction selection as it procedes through the topologically-sorted
end_comment

begin_comment
comment|/// node list.
end_comment

begin_expr_stmt
name|SelectionDAG
operator|::
name|allnodes_iterator
name|ISelPosition
expr_stmt|;
end_expr_stmt

begin_comment
comment|/// IsChainCompatible - Returns true if Chain is Op or Chain does
end_comment

begin_comment
comment|/// not reach Op.
end_comment

begin_function
specifier|static
name|bool
name|IsChainCompatible
parameter_list|(
name|SDNode
modifier|*
name|Chain
parameter_list|,
name|SDNode
modifier|*
name|Op
parameter_list|)
block|{
if|if
condition|(
name|Chain
operator|->
name|getOpcode
argument_list|()
operator|==
name|ISD
operator|::
name|EntryToken
condition|)
return|return
name|true
return|;
if|if
condition|(
name|Chain
operator|->
name|getOpcode
argument_list|()
operator|==
name|ISD
operator|::
name|TokenFactor
condition|)
return|return
name|false
return|;
if|if
condition|(
name|Chain
operator|->
name|getNumOperands
argument_list|()
operator|>
literal|0
condition|)
block|{
name|SDValue
name|C0
init|=
name|Chain
operator|->
name|getOperand
argument_list|(
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|C0
operator|.
name|getValueType
argument_list|()
operator|==
name|MVT
operator|::
name|Other
condition|)
return|return
name|C0
operator|.
name|getNode
argument_list|()
operator|!=
name|Op
operator|&&
name|IsChainCompatible
argument_list|(
name|C0
operator|.
name|getNode
argument_list|()
argument_list|,
name|Op
argument_list|)
return|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/// ISelUpdater - helper class to handle updates of the
end_comment

begin_comment
comment|/// instruciton selection graph.
end_comment

begin_decl_stmt
name|class
name|VISIBILITY_HIDDEN
name|ISelUpdater
range|:
name|public
name|SelectionDAG
operator|::
name|DAGUpdateListener
block|{
name|SelectionDAG
operator|::
name|allnodes_iterator
operator|&
name|ISelPosition
block|;
name|public
operator|:
name|explicit
name|ISelUpdater
argument_list|(
name|SelectionDAG
operator|::
name|allnodes_iterator
operator|&
name|isp
argument_list|)
operator|:
name|ISelPosition
argument_list|(
argument|isp
argument_list|)
block|{}
comment|/// NodeDeleted - Handle nodes deleted from the graph. If the
comment|/// node being deleted is the current ISelPosition node, update
comment|/// ISelPosition.
comment|///
name|virtual
name|void
name|NodeDeleted
argument_list|(
argument|SDNode *N
argument_list|,
argument|SDNode *E
argument_list|)
block|{
if|if
condition|(
name|ISelPosition
operator|==
name|SelectionDAG
operator|::
name|allnodes_iterator
argument_list|(
name|N
argument_list|)
condition|)
operator|++
name|ISelPosition
expr_stmt|;
block|}
comment|/// NodeUpdated - Ignore updates for now.
name|virtual
name|void
name|NodeUpdated
argument_list|(
argument|SDNode *N
argument_list|)
block|{}
expr|}
block|;
comment|/// ReplaceUses - replace all uses of the old node F with the use
comment|/// of the new node T.
name|DISABLE_INLINE
name|void
name|ReplaceUses
argument_list|(
argument|SDValue F
argument_list|,
argument|SDValue T
argument_list|)
block|{
name|ISelUpdater
name|ISU
argument_list|(
name|ISelPosition
argument_list|)
block|;
name|CurDAG
operator|->
name|ReplaceAllUsesOfValueWith
argument_list|(
name|F
argument_list|,
name|T
argument_list|,
operator|&
name|ISU
argument_list|)
block|; }
comment|/// ReplaceUses - replace all uses of the old nodes F with the use
comment|/// of the new nodes T.
name|DISABLE_INLINE
name|void
name|ReplaceUses
argument_list|(
argument|const SDValue *F
argument_list|,
argument|const SDValue *T
argument_list|,
argument|unsigned Num
argument_list|)
block|{
name|ISelUpdater
name|ISU
argument_list|(
name|ISelPosition
argument_list|)
block|;
name|CurDAG
operator|->
name|ReplaceAllUsesOfValuesWith
argument_list|(
name|F
argument_list|,
name|T
argument_list|,
name|Num
argument_list|,
operator|&
name|ISU
argument_list|)
block|; }
comment|/// ReplaceUses - replace all uses of the old node F with the use
comment|/// of the new node T.
name|DISABLE_INLINE
name|void
name|ReplaceUses
argument_list|(
argument|SDNode *F
argument_list|,
argument|SDNode *T
argument_list|)
block|{
name|ISelUpdater
name|ISU
argument_list|(
name|ISelPosition
argument_list|)
block|;
name|CurDAG
operator|->
name|ReplaceAllUsesWith
argument_list|(
name|F
argument_list|,
name|T
argument_list|,
operator|&
name|ISU
argument_list|)
block|; }
comment|/// SelectRoot - Top level entry to DAG instruction selector.
comment|/// Selects instructions starting at the root of the current DAG.
name|void
name|SelectRoot
argument_list|(
argument|SelectionDAG&DAG
argument_list|)
block|{
name|SelectRootInit
argument_list|()
block|;
comment|// Create a dummy node (which is not added to allnodes), that adds
comment|// a reference to the root node, preventing it from being deleted,
comment|// and tracking any changes of the root.
name|HandleSDNode
name|Dummy
argument_list|(
name|CurDAG
operator|->
name|getRoot
argument_list|()
argument_list|)
block|;
name|ISelPosition
operator|=
name|llvm
operator|::
name|next
argument_list|(
name|SelectionDAG
operator|::
name|allnodes_iterator
argument_list|(
name|CurDAG
operator|->
name|getRoot
argument_list|()
operator|.
name|getNode
argument_list|()
argument_list|)
argument_list|)
block|;
comment|// The AllNodes list is now topological-sorted. Visit the
comment|// nodes by starting at the end of the list (the root of the
comment|// graph) and preceding back toward the beginning (the entry
comment|// node).
while|while
condition|(
name|ISelPosition
operator|!=
name|CurDAG
operator|->
name|allnodes_begin
argument_list|()
condition|)
block|{
name|SDNode
modifier|*
name|Node
init|=
operator|--
name|ISelPosition
decl_stmt|;
comment|// Skip dead nodes. DAGCombiner is expected to eliminate all dead nodes,
comment|// but there are currently some corner cases that it misses. Also, this
comment|// makes it theoretically possible to disable the DAGCombiner.
if|if
condition|(
name|Node
operator|->
name|use_empty
argument_list|()
condition|)
continue|continue;
if|#
directive|if
literal|0
block|DAG.setSubgraphColor(Node, "red");
endif|#
directive|endif
name|SDNode
modifier|*
name|ResNode
init|=
name|Select
argument_list|(
name|Node
argument_list|)
decl_stmt|;
comment|// If node should not be replaced, continue with the next one.
if|if
condition|(
name|ResNode
operator|==
name|Node
condition|)
continue|continue;
comment|// Replace node.
if|if
condition|(
name|ResNode
condition|)
block|{
if|#
directive|if
literal|0
block|DAG.setSubgraphColor(ResNode, "yellow");       DAG.setSubgraphColor(ResNode, "black");
endif|#
directive|endif
name|ReplaceUses
argument_list|(
name|Node
argument_list|,
name|ResNode
argument_list|)
expr_stmt|;
block|}
comment|// If after the replacement this node is not used any more,
comment|// remove this dead node.
if|if
condition|(
name|Node
operator|->
name|use_empty
argument_list|()
condition|)
block|{
comment|// Don't delete EntryToken, etc.
name|ISelUpdater
name|ISU
parameter_list|(
name|ISelPosition
parameter_list|)
function_decl|;
name|CurDAG
operator|->
name|RemoveDeadNode
argument_list|(
name|Node
argument_list|,
operator|&
name|ISU
argument_list|)
expr_stmt|;
block|}
block|}
name|CurDAG
operator|->
name|setRoot
argument_list|(
name|Dummy
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/// CheckInteger - Return true if the specified node is not a ConstantSDNode or
comment|/// if it doesn't have the specified value.
specifier|static
name|bool
name|CheckInteger
argument_list|(
argument|SDValue V
argument_list|,
argument|int64_t Val
argument_list|)
block|{
name|ConstantSDNode
operator|*
name|C
operator|=
name|dyn_cast
operator|<
name|ConstantSDNode
operator|>
operator|(
name|V
operator|)
block|;
return|return
name|C
operator|==
literal|0
operator|||
name|C
operator|->
name|getSExtValue
argument_list|()
operator|!=
name|Val
return|;
block|}
comment|/// CheckAndImmediate - Check to see if the specified node is an and with an
comment|/// immediate returning true on failure.
comment|///
comment|/// FIXME: Inline this gunk into CheckAndMask.
name|bool
name|CheckAndImmediate
argument_list|(
argument|SDValue V
argument_list|,
argument|int64_t Val
argument_list|)
block|{
if|if
condition|(
name|V
operator|->
name|getOpcode
argument_list|()
operator|==
name|ISD
operator|::
name|AND
condition|)
if|if
condition|(
name|ConstantSDNode
modifier|*
name|C
init|=
name|dyn_cast
operator|<
name|ConstantSDNode
operator|>
operator|(
name|V
operator|->
name|getOperand
argument_list|(
literal|1
argument_list|)
operator|)
condition|)
if|if
condition|(
name|CheckAndMask
argument_list|(
name|V
operator|.
name|getOperand
argument_list|(
literal|0
argument_list|)
argument_list|,
name|C
argument_list|,
name|Val
argument_list|)
condition|)
return|return
name|false
return|;
return|return
name|true
return|;
block|}
end_decl_stmt

begin_comment
comment|/// CheckOrImmediate - Check to see if the specified node is an or with an
end_comment

begin_comment
comment|/// immediate returning true on failure.
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|/// FIXME: Inline this gunk into CheckOrMask.
end_comment

begin_function
name|bool
name|CheckOrImmediate
parameter_list|(
name|SDValue
name|V
parameter_list|,
name|int64_t
name|Val
parameter_list|)
block|{
if|if
condition|(
name|V
operator|->
name|getOpcode
argument_list|()
operator|==
name|ISD
operator|::
name|OR
condition|)
if|if
condition|(
name|ConstantSDNode
modifier|*
name|C
init|=
name|dyn_cast
operator|<
name|ConstantSDNode
operator|>
operator|(
name|V
operator|->
name|getOperand
argument_list|(
literal|1
argument_list|)
operator|)
condition|)
if|if
condition|(
name|CheckOrMask
argument_list|(
name|V
operator|.
name|getOperand
argument_list|(
literal|0
argument_list|)
argument_list|,
name|C
argument_list|,
name|Val
argument_list|)
condition|)
return|return
name|false
return|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|// These functions are marked always inline so that Idx doesn't get pinned to
end_comment

begin_comment
comment|// the stack.
end_comment

begin_function
name|ALWAYS_INLINE
specifier|static
name|int8_t
name|GetInt1
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|MatcherTable
parameter_list|,
name|unsigned
modifier|&
name|Idx
parameter_list|)
block|{
return|return
name|MatcherTable
index|[
name|Idx
operator|++
index|]
return|;
block|}
end_function

begin_function
name|ALWAYS_INLINE
specifier|static
name|int16_t
name|GetInt2
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|MatcherTable
parameter_list|,
name|unsigned
modifier|&
name|Idx
parameter_list|)
block|{
name|int16_t
name|Val
init|=
name|GetInt1
argument_list|(
name|MatcherTable
argument_list|,
name|Idx
argument_list|)
decl_stmt|;
name|Val
operator||=
name|int16_t
argument_list|(
name|GetInt1
argument_list|(
name|MatcherTable
argument_list|,
name|Idx
argument_list|)
argument_list|)
operator|<<
literal|8
expr_stmt|;
return|return
name|Val
return|;
block|}
end_function

begin_function
name|ALWAYS_INLINE
specifier|static
name|int32_t
name|GetInt4
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|MatcherTable
parameter_list|,
name|unsigned
modifier|&
name|Idx
parameter_list|)
block|{
name|int32_t
name|Val
init|=
name|GetInt2
argument_list|(
name|MatcherTable
argument_list|,
name|Idx
argument_list|)
decl_stmt|;
name|Val
operator||=
name|int32_t
argument_list|(
name|GetInt2
argument_list|(
name|MatcherTable
argument_list|,
name|Idx
argument_list|)
argument_list|)
operator|<<
literal|16
expr_stmt|;
return|return
name|Val
return|;
block|}
end_function

begin_function
name|ALWAYS_INLINE
specifier|static
name|int64_t
name|GetInt8
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|MatcherTable
parameter_list|,
name|unsigned
modifier|&
name|Idx
parameter_list|)
block|{
name|int64_t
name|Val
init|=
name|GetInt4
argument_list|(
name|MatcherTable
argument_list|,
name|Idx
argument_list|)
decl_stmt|;
name|Val
operator||=
name|int64_t
argument_list|(
name|GetInt4
argument_list|(
name|MatcherTable
argument_list|,
name|Idx
argument_list|)
argument_list|)
operator|<<
literal|32
expr_stmt|;
return|return
name|Val
return|;
block|}
end_function

begin_enum
enum|enum
name|BuiltinOpcodes
block|{
name|OPC_Emit
block|,
name|OPC_Push
block|,
name|OPC_Record
block|,
name|OPC_MoveChild
block|,
name|OPC_MoveParent
block|,
name|OPC_CheckSame
block|,
name|OPC_CheckPatternPredicate
block|,
name|OPC_CheckPredicate
block|,
name|OPC_CheckOpcode
block|,
name|OPC_CheckType
block|,
name|OPC_CheckInteger1
block|,
name|OPC_CheckInteger2
block|,
name|OPC_CheckInteger4
block|,
name|OPC_CheckInteger8
block|,
name|OPC_CheckCondCode
block|,
name|OPC_CheckValueType
block|,
name|OPC_CheckComplexPat
block|,
name|OPC_CheckAndImm1
block|,
name|OPC_CheckAndImm2
block|,
name|OPC_CheckAndImm4
block|,
name|OPC_CheckAndImm8
block|,
name|OPC_CheckOrImm1
block|,
name|OPC_CheckOrImm2
block|,
name|OPC_CheckOrImm4
block|,
name|OPC_CheckOrImm8
block|,
name|OPC_IsProfitableToFold
block|,
name|OPC_IsLegalToFold
block|}
enum|;
end_enum

begin_struct
struct|struct
name|MatchScope
block|{
comment|/// FailIndex - If this match fails, this is the index to continue with.
name|unsigned
name|FailIndex
decl_stmt|;
comment|/// NodeStackSize - The size of the node stack when the scope was formed.
name|unsigned
name|NodeStackSize
decl_stmt|;
comment|/// NumRecordedNodes - The number of recorded nodes when the scope was formed.
name|unsigned
name|NumRecordedNodes
decl_stmt|;
block|}
struct|;
end_struct

begin_function
name|SDNode
modifier|*
name|SelectCodeCommon
parameter_list|(
name|SDNode
modifier|*
name|NodeToMatch
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|MatcherTable
parameter_list|,
name|unsigned
name|TableSize
parameter_list|)
block|{
switch|switch
condition|(
name|NodeToMatch
operator|->
name|getOpcode
argument_list|()
condition|)
block|{
default|default:
break|break;
case|case
name|ISD
operator|::
name|EntryToken
case|:
comment|// These nodes remain the same.
case|case
name|ISD
operator|::
name|BasicBlock
case|:
case|case
name|ISD
operator|::
name|Register
case|:
case|case
name|ISD
operator|::
name|HANDLENODE
case|:
case|case
name|ISD
operator|::
name|TargetConstant
case|:
case|case
name|ISD
operator|::
name|TargetConstantFP
case|:
case|case
name|ISD
operator|::
name|TargetConstantPool
case|:
case|case
name|ISD
operator|::
name|TargetFrameIndex
case|:
case|case
name|ISD
operator|::
name|TargetExternalSymbol
case|:
case|case
name|ISD
operator|::
name|TargetBlockAddress
case|:
case|case
name|ISD
operator|::
name|TargetJumpTable
case|:
case|case
name|ISD
operator|::
name|TargetGlobalTLSAddress
case|:
case|case
name|ISD
operator|::
name|TargetGlobalAddress
case|:
case|case
name|ISD
operator|::
name|TokenFactor
case|:
case|case
name|ISD
operator|::
name|CopyFromReg
case|:
case|case
name|ISD
operator|::
name|CopyToReg
case|:
return|return
literal|0
return|;
case|case
name|ISD
operator|::
name|AssertSext
case|:
case|case
name|ISD
operator|::
name|AssertZext
case|:
name|ReplaceUses
argument_list|(
name|SDValue
argument_list|(
name|NodeToMatch
argument_list|,
literal|0
argument_list|)
argument_list|,
name|NodeToMatch
operator|->
name|getOperand
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|ISD
operator|::
name|INLINEASM
case|:
return|return
name|Select_INLINEASM
argument_list|(
name|NodeToMatch
argument_list|)
return|;
case|case
name|ISD
operator|::
name|EH_LABEL
case|:
return|return
name|Select_EH_LABEL
argument_list|(
name|NodeToMatch
argument_list|)
return|;
case|case
name|ISD
operator|::
name|UNDEF
case|:
return|return
name|Select_UNDEF
argument_list|(
name|NodeToMatch
argument_list|)
return|;
block|}
name|assert
argument_list|(
operator|!
name|NodeToMatch
operator|->
name|isMachineOpcode
argument_list|()
operator|&&
literal|"Node already selected!"
argument_list|)
expr_stmt|;
name|SmallVector
operator|<
name|MatchScope
operator|,
literal|8
operator|>
name|MatchScopes
expr_stmt|;
comment|// RecordedNodes - This is the set of nodes that have been recorded by the
comment|// state machine.
name|SmallVector
operator|<
name|SDValue
operator|,
literal|8
operator|>
name|RecordedNodes
expr_stmt|;
comment|// Set up the node stack with NodeToMatch as the only node on the stack.
name|SmallVector
operator|<
name|SDValue
operator|,
literal|8
operator|>
name|NodeStack
expr_stmt|;
name|SDValue
name|N
init|=
name|SDValue
argument_list|(
name|NodeToMatch
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|NodeStack
operator|.
name|push_back
argument_list|(
name|N
argument_list|)
expr_stmt|;
comment|// Interpreter starts at opcode #0.
name|unsigned
name|MatcherIndex
init|=
literal|0
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|assert
argument_list|(
name|MatcherIndex
operator|<
name|TableSize
operator|&&
literal|"Invalid index"
argument_list|)
expr_stmt|;
switch|switch
condition|(
operator|(
name|BuiltinOpcodes
operator|)
name|MatcherTable
index|[
name|MatcherIndex
operator|++
index|]
condition|)
block|{
case|case
name|OPC_Emit
case|:
block|{
name|errs
argument_list|()
operator|<<
literal|"EMIT NODE\n"
expr_stmt|;
return|return
literal|0
return|;
block|}
case|case
name|OPC_Push
case|:
block|{
name|unsigned
name|NumToSkip
init|=
name|MatcherTable
index|[
name|MatcherIndex
operator|++
index|]
decl_stmt|;
name|MatchScope
name|NewEntry
decl_stmt|;
name|NewEntry
operator|.
name|FailIndex
operator|=
name|MatcherIndex
operator|+
name|NumToSkip
expr_stmt|;
name|NewEntry
operator|.
name|NodeStackSize
operator|=
name|NodeStack
operator|.
name|size
argument_list|()
expr_stmt|;
name|NewEntry
operator|.
name|NumRecordedNodes
operator|=
name|RecordedNodes
operator|.
name|size
argument_list|()
expr_stmt|;
name|MatchScopes
operator|.
name|push_back
argument_list|(
name|NewEntry
argument_list|)
expr_stmt|;
continue|continue;
block|}
case|case
name|OPC_Record
case|:
comment|// Remember this node, it may end up being an operand in the pattern.
name|RecordedNodes
operator|.
name|push_back
argument_list|(
name|N
argument_list|)
expr_stmt|;
continue|continue;
case|case
name|OPC_MoveChild
case|:
block|{
name|unsigned
name|Child
init|=
name|MatcherTable
index|[
name|MatcherIndex
operator|++
index|]
decl_stmt|;
if|if
condition|(
name|Child
operator|>=
name|N
operator|.
name|getNumOperands
argument_list|()
condition|)
break|break;
comment|// Match fails if out of range child #.
name|N
operator|=
name|N
operator|.
name|getOperand
argument_list|(
name|Child
argument_list|)
expr_stmt|;
name|NodeStack
operator|.
name|push_back
argument_list|(
name|N
argument_list|)
expr_stmt|;
continue|continue;
block|}
case|case
name|OPC_MoveParent
case|:
comment|// Pop the current node off the NodeStack.
name|NodeStack
operator|.
name|pop_back
argument_list|()
expr_stmt|;
name|assert
argument_list|(
operator|!
name|NodeStack
operator|.
name|empty
argument_list|()
operator|&&
literal|"Node stack imbalance!"
argument_list|)
expr_stmt|;
name|N
operator|=
name|NodeStack
operator|.
name|back
argument_list|()
expr_stmt|;
continue|continue;
case|case
name|OPC_CheckSame
case|:
block|{
comment|// Accept if it is exactly the same as a previously recorded node.
name|unsigned
name|RecNo
init|=
name|MatcherTable
index|[
name|MatcherIndex
operator|++
index|]
decl_stmt|;
name|assert
argument_list|(
name|RecNo
operator|<
name|RecordedNodes
operator|.
name|size
argument_list|()
operator|&&
literal|"Invalid CheckSame"
argument_list|)
expr_stmt|;
if|if
condition|(
name|N
operator|!=
name|RecordedNodes
index|[
name|RecNo
index|]
condition|)
break|break;
continue|continue;
block|}
case|case
name|OPC_CheckPatternPredicate
case|:
if|if
condition|(
operator|!
name|CheckPatternPredicate
argument_list|(
name|MatcherTable
index|[
name|MatcherIndex
operator|++
index|]
argument_list|)
condition|)
break|break;
continue|continue;
case|case
name|OPC_CheckPredicate
case|:
if|if
condition|(
operator|!
name|CheckNodePredicate
argument_list|(
name|N
operator|.
name|getNode
argument_list|()
argument_list|,
name|MatcherTable
index|[
name|MatcherIndex
operator|++
index|]
argument_list|)
condition|)
break|break;
continue|continue;
case|case
name|OPC_CheckComplexPat
case|:
block|{
name|unsigned
name|PatNo
init|=
name|MatcherTable
index|[
name|MatcherIndex
operator|++
index|]
decl_stmt|;
operator|(
name|void
operator|)
name|PatNo
expr_stmt|;
comment|// FIXME: CHECK IT.
continue|continue;
block|}
case|case
name|OPC_CheckOpcode
case|:
if|if
condition|(
name|N
operator|->
name|getOpcode
argument_list|()
operator|!=
name|MatcherTable
index|[
name|MatcherIndex
operator|++
index|]
condition|)
break|break;
continue|continue;
case|case
name|OPC_CheckType
case|:
if|if
condition|(
name|N
operator|.
name|getValueType
argument_list|()
operator|!=
operator|(
name|MVT
operator|::
name|SimpleValueType
operator|)
name|MatcherTable
index|[
name|MatcherIndex
operator|++
index|]
condition|)
break|break;
continue|continue;
case|case
name|OPC_CheckCondCode
case|:
if|if
condition|(
name|cast
operator|<
name|CondCodeSDNode
operator|>
operator|(
name|N
operator|)
operator|->
name|get
argument_list|()
operator|!=
operator|(
name|ISD
operator|::
name|CondCode
operator|)
name|MatcherTable
index|[
name|MatcherIndex
operator|++
index|]
condition|)
break|break;
continue|continue;
case|case
name|OPC_CheckValueType
case|:
if|if
condition|(
name|cast
operator|<
name|VTSDNode
operator|>
operator|(
name|N
operator|)
operator|->
name|getVT
argument_list|()
operator|!=
operator|(
name|MVT
operator|::
name|SimpleValueType
operator|)
name|MatcherTable
index|[
name|MatcherIndex
operator|++
index|]
condition|)
break|break;
continue|continue;
case|case
name|OPC_CheckInteger1
case|:
if|if
condition|(
name|CheckInteger
argument_list|(
name|N
argument_list|,
name|GetInt1
argument_list|(
name|MatcherTable
argument_list|,
name|MatcherIndex
argument_list|)
argument_list|)
condition|)
break|break;
continue|continue;
case|case
name|OPC_CheckInteger2
case|:
if|if
condition|(
name|CheckInteger
argument_list|(
name|N
argument_list|,
name|GetInt2
argument_list|(
name|MatcherTable
argument_list|,
name|MatcherIndex
argument_list|)
argument_list|)
condition|)
break|break;
continue|continue;
case|case
name|OPC_CheckInteger4
case|:
if|if
condition|(
name|CheckInteger
argument_list|(
name|N
argument_list|,
name|GetInt4
argument_list|(
name|MatcherTable
argument_list|,
name|MatcherIndex
argument_list|)
argument_list|)
condition|)
break|break;
continue|continue;
case|case
name|OPC_CheckInteger8
case|:
if|if
condition|(
name|CheckInteger
argument_list|(
name|N
argument_list|,
name|GetInt8
argument_list|(
name|MatcherTable
argument_list|,
name|MatcherIndex
argument_list|)
argument_list|)
condition|)
break|break;
continue|continue;
case|case
name|OPC_CheckAndImm1
case|:
if|if
condition|(
name|CheckAndImmediate
argument_list|(
name|N
argument_list|,
name|GetInt1
argument_list|(
name|MatcherTable
argument_list|,
name|MatcherIndex
argument_list|)
argument_list|)
condition|)
break|break;
continue|continue;
case|case
name|OPC_CheckAndImm2
case|:
if|if
condition|(
name|CheckAndImmediate
argument_list|(
name|N
argument_list|,
name|GetInt2
argument_list|(
name|MatcherTable
argument_list|,
name|MatcherIndex
argument_list|)
argument_list|)
condition|)
break|break;
continue|continue;
case|case
name|OPC_CheckAndImm4
case|:
if|if
condition|(
name|CheckAndImmediate
argument_list|(
name|N
argument_list|,
name|GetInt4
argument_list|(
name|MatcherTable
argument_list|,
name|MatcherIndex
argument_list|)
argument_list|)
condition|)
break|break;
continue|continue;
case|case
name|OPC_CheckAndImm8
case|:
if|if
condition|(
name|CheckAndImmediate
argument_list|(
name|N
argument_list|,
name|GetInt8
argument_list|(
name|MatcherTable
argument_list|,
name|MatcherIndex
argument_list|)
argument_list|)
condition|)
break|break;
continue|continue;
case|case
name|OPC_CheckOrImm1
case|:
if|if
condition|(
name|CheckOrImmediate
argument_list|(
name|N
argument_list|,
name|GetInt1
argument_list|(
name|MatcherTable
argument_list|,
name|MatcherIndex
argument_list|)
argument_list|)
condition|)
break|break;
continue|continue;
case|case
name|OPC_CheckOrImm2
case|:
if|if
condition|(
name|CheckOrImmediate
argument_list|(
name|N
argument_list|,
name|GetInt2
argument_list|(
name|MatcherTable
argument_list|,
name|MatcherIndex
argument_list|)
argument_list|)
condition|)
break|break;
continue|continue;
case|case
name|OPC_CheckOrImm4
case|:
if|if
condition|(
name|CheckOrImmediate
argument_list|(
name|N
argument_list|,
name|GetInt4
argument_list|(
name|MatcherTable
argument_list|,
name|MatcherIndex
argument_list|)
argument_list|)
condition|)
break|break;
continue|continue;
case|case
name|OPC_CheckOrImm8
case|:
if|if
condition|(
name|CheckOrImmediate
argument_list|(
name|N
argument_list|,
name|GetInt8
argument_list|(
name|MatcherTable
argument_list|,
name|MatcherIndex
argument_list|)
argument_list|)
condition|)
break|break;
continue|continue;
case|case
name|OPC_IsProfitableToFold
case|:
name|assert
argument_list|(
operator|!
name|NodeStack
operator|.
name|size
argument_list|()
operator|==
literal|1
operator|&&
literal|"No parent node"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|IsProfitableToFold
argument_list|(
name|N
argument_list|,
name|NodeStack
index|[
name|NodeStack
operator|.
name|size
argument_list|()
operator|-
literal|2
index|]
operator|.
name|getNode
argument_list|()
argument_list|,
name|NodeToMatch
argument_list|)
condition|)
break|break;
continue|continue;
case|case
name|OPC_IsLegalToFold
case|:
name|assert
argument_list|(
operator|!
name|NodeStack
operator|.
name|size
argument_list|()
operator|==
literal|1
operator|&&
literal|"No parent node"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|IsLegalToFold
argument_list|(
name|N
argument_list|,
name|NodeStack
index|[
name|NodeStack
operator|.
name|size
argument_list|()
operator|-
literal|2
index|]
operator|.
name|getNode
argument_list|()
argument_list|,
name|NodeToMatch
argument_list|)
condition|)
break|break;
continue|continue;
block|}
comment|// If the code reached this point, then the match failed pop out to the next
comment|// match scope.
if|if
condition|(
name|MatchScopes
operator|.
name|empty
argument_list|()
condition|)
block|{
name|CannotYetSelect
argument_list|(
name|NodeToMatch
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|RecordedNodes
operator|.
name|resize
argument_list|(
name|MatchScopes
operator|.
name|back
argument_list|()
operator|.
name|NumRecordedNodes
argument_list|)
expr_stmt|;
name|NodeStack
operator|.
name|resize
argument_list|(
name|MatchScopes
operator|.
name|back
argument_list|()
operator|.
name|NodeStackSize
argument_list|)
expr_stmt|;
name|MatcherIndex
operator|=
name|MatchScopes
operator|.
name|back
argument_list|()
operator|.
name|FailIndex
expr_stmt|;
name|MatchScopes
operator|.
name|pop_back
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* LLVM_CODEGEN_DAGISEL_HEADER_H */
end_comment

end_unit

