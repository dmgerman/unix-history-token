begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===-- LiveIntervalAnalysis.h - Live Interval Analysis ---------*- C++ -*-===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file implements the LiveInterval analysis pass.  Given some numbering of
end_comment

begin_comment
comment|// each the machine instructions (in this implemention depth-first order) an
end_comment

begin_comment
comment|// interval [i, j) is said to be a live interval for register v if there is no
end_comment

begin_comment
comment|// instruction with number j'> j such that v is live at j' and there is no
end_comment

begin_comment
comment|// instruction with number i'< i such that v is live at i'. In this
end_comment

begin_comment
comment|// implementation intervals can have holes, i.e. an interval might look like
end_comment

begin_comment
comment|// [1,20), [50,65), [1000,1001).
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LLVM_CODEGEN_LIVEINTERVAL_ANALYSIS_H
end_ifndef

begin_define
define|#
directive|define
name|LLVM_CODEGEN_LIVEINTERVAL_ANALYSIS_H
end_define

begin_include
include|#
directive|include
file|"llvm/CodeGen/MachineBasicBlock.h"
end_include

begin_include
include|#
directive|include
file|"llvm/CodeGen/MachineFunctionPass.h"
end_include

begin_include
include|#
directive|include
file|"llvm/CodeGen/LiveInterval.h"
end_include

begin_include
include|#
directive|include
file|"llvm/CodeGen/SlotIndexes.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/BitVector.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/DenseMap.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/SmallPtrSet.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/SmallVector.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/Allocator.h"
end_include

begin_include
include|#
directive|include
file|<cmath>
end_include

begin_include
include|#
directive|include
file|<iterator>
end_include

begin_decl_stmt
name|namespace
name|llvm
block|{
name|class
name|AliasAnalysis
decl_stmt|;
name|class
name|LiveVariables
decl_stmt|;
name|class
name|MachineLoopInfo
decl_stmt|;
name|class
name|TargetRegisterInfo
decl_stmt|;
name|class
name|MachineRegisterInfo
decl_stmt|;
name|class
name|TargetInstrInfo
decl_stmt|;
name|class
name|TargetRegisterClass
decl_stmt|;
name|class
name|VirtRegMap
decl_stmt|;
name|class
name|LiveIntervals
range|:
name|public
name|MachineFunctionPass
block|{
name|MachineFunction
operator|*
name|mf_
block|;
name|MachineRegisterInfo
operator|*
name|mri_
block|;
specifier|const
name|TargetMachine
operator|*
name|tm_
block|;
specifier|const
name|TargetRegisterInfo
operator|*
name|tri_
block|;
specifier|const
name|TargetInstrInfo
operator|*
name|tii_
block|;
name|AliasAnalysis
operator|*
name|aa_
block|;
name|LiveVariables
operator|*
name|lv_
block|;
name|SlotIndexes
operator|*
name|indexes_
block|;
comment|/// Special pool allocator for VNInfo's (LiveInterval val#).
comment|///
name|BumpPtrAllocator
name|VNInfoAllocator
block|;
typedef|typedef
name|DenseMap
operator|<
name|unsigned
operator|,
name|LiveInterval
operator|*
operator|>
name|Reg2IntervalMap
expr_stmt|;
name|Reg2IntervalMap
name|r2iMap_
decl_stmt|;
comment|/// allocatableRegs_ - A bit vector of allocatable registers.
name|BitVector
name|allocatableRegs_
decl_stmt|;
comment|/// CloneMIs - A list of clones as result of re-materialization.
name|std
operator|::
name|vector
operator|<
name|MachineInstr
operator|*
operator|>
name|CloneMIs
expr_stmt|;
name|public
label|:
specifier|static
name|char
name|ID
decl_stmt|;
comment|// Pass identification, replacement for typeid
name|LiveIntervals
argument_list|()
operator|:
name|MachineFunctionPass
argument_list|(
argument|&ID
argument_list|)
block|{}
specifier|static
name|float
name|getSpillWeight
argument_list|(
argument|bool isDef
argument_list|,
argument|bool isUse
argument_list|,
argument|unsigned loopDepth
argument_list|)
block|{
return|return
operator|(
name|isDef
operator|+
name|isUse
operator|)
operator|*
name|powf
argument_list|(
literal|10.0F
argument_list|,
operator|(
name|float
operator|)
name|loopDepth
argument_list|)
return|;
block|}
typedef|typedef
name|Reg2IntervalMap
operator|::
name|iterator
name|iterator
expr_stmt|;
typedef|typedef
name|Reg2IntervalMap
operator|::
name|const_iterator
name|const_iterator
expr_stmt|;
name|const_iterator
name|begin
argument_list|()
specifier|const
block|{
return|return
name|r2iMap_
operator|.
name|begin
argument_list|()
return|;
block|}
name|const_iterator
name|end
argument_list|()
specifier|const
block|{
return|return
name|r2iMap_
operator|.
name|end
argument_list|()
return|;
block|}
name|iterator
name|begin
parameter_list|()
block|{
return|return
name|r2iMap_
operator|.
name|begin
argument_list|()
return|;
block|}
name|iterator
name|end
parameter_list|()
block|{
return|return
name|r2iMap_
operator|.
name|end
argument_list|()
return|;
block|}
name|unsigned
name|getNumIntervals
argument_list|()
specifier|const
block|{
return|return
operator|(
name|unsigned
operator|)
name|r2iMap_
operator|.
name|size
argument_list|()
return|;
block|}
name|LiveInterval
modifier|&
name|getInterval
parameter_list|(
name|unsigned
name|reg
parameter_list|)
block|{
name|Reg2IntervalMap
operator|::
name|iterator
name|I
operator|=
name|r2iMap_
operator|.
name|find
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|I
operator|!=
name|r2iMap_
operator|.
name|end
argument_list|()
operator|&&
literal|"Interval does not exist for register"
argument_list|)
expr_stmt|;
return|return
operator|*
name|I
operator|->
name|second
return|;
block|}
specifier|const
name|LiveInterval
modifier|&
name|getInterval
argument_list|(
name|unsigned
name|reg
argument_list|)
decl|const
block|{
name|Reg2IntervalMap
operator|::
name|const_iterator
name|I
operator|=
name|r2iMap_
operator|.
name|find
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|I
operator|!=
name|r2iMap_
operator|.
name|end
argument_list|()
operator|&&
literal|"Interval does not exist for register"
argument_list|)
expr_stmt|;
return|return
operator|*
name|I
operator|->
name|second
return|;
block|}
name|bool
name|hasInterval
argument_list|(
name|unsigned
name|reg
argument_list|)
decl|const
block|{
return|return
name|r2iMap_
operator|.
name|count
argument_list|(
name|reg
argument_list|)
return|;
block|}
comment|/// getScaledIntervalSize - get the size of an interval in "units,"
comment|/// where every function is composed of one thousand units.  This
comment|/// measure scales properly with empty index slots in the function.
name|double
name|getScaledIntervalSize
parameter_list|(
name|LiveInterval
modifier|&
name|I
parameter_list|)
block|{
return|return
operator|(
literal|1000.0
operator|*
name|I
operator|.
name|getSize
argument_list|()
operator|)
operator|/
name|indexes_
operator|->
name|getIndexesLength
argument_list|()
return|;
block|}
comment|/// getApproximateInstructionCount - computes an estimate of the number
comment|/// of instructions in a given LiveInterval.
name|unsigned
name|getApproximateInstructionCount
parameter_list|(
name|LiveInterval
modifier|&
name|I
parameter_list|)
block|{
name|double
name|IntervalPercentage
init|=
name|getScaledIntervalSize
argument_list|(
name|I
argument_list|)
operator|/
literal|1000.0
decl_stmt|;
return|return
call|(
name|unsigned
call|)
argument_list|(
name|IntervalPercentage
operator|*
name|indexes_
operator|->
name|getFunctionSize
argument_list|()
argument_list|)
return|;
block|}
comment|/// conflictsWithPhysRegDef - Returns true if the specified register
comment|/// is defined during the duration of the specified interval.
name|bool
name|conflictsWithPhysRegDef
parameter_list|(
specifier|const
name|LiveInterval
modifier|&
name|li
parameter_list|,
name|VirtRegMap
modifier|&
name|vrm
parameter_list|,
name|unsigned
name|reg
parameter_list|)
function_decl|;
comment|/// conflictsWithPhysRegRef - Similar to conflictsWithPhysRegRef except
comment|/// it can check use as well.
name|bool
name|conflictsWithPhysRegRef
argument_list|(
name|LiveInterval
operator|&
name|li
argument_list|,
name|unsigned
name|Reg
argument_list|,
name|bool
name|CheckUse
argument_list|,
name|SmallPtrSet
operator|<
name|MachineInstr
operator|*
argument_list|,
literal|32
operator|>
operator|&
name|JoinedCopies
argument_list|)
decl_stmt|;
comment|// Interval creation
name|LiveInterval
modifier|&
name|getOrCreateInterval
parameter_list|(
name|unsigned
name|reg
parameter_list|)
block|{
name|Reg2IntervalMap
operator|::
name|iterator
name|I
operator|=
name|r2iMap_
operator|.
name|find
argument_list|(
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|I
operator|==
name|r2iMap_
operator|.
name|end
argument_list|()
condition|)
name|I
operator|=
name|r2iMap_
operator|.
name|insert
argument_list|(
name|std
operator|::
name|make_pair
argument_list|(
name|reg
argument_list|,
name|createInterval
argument_list|(
name|reg
argument_list|)
argument_list|)
argument_list|)
operator|.
name|first
expr_stmt|;
return|return
operator|*
name|I
operator|->
name|second
return|;
block|}
comment|/// dupInterval - Duplicate a live interval. The caller is responsible for
comment|/// managing the allocated memory.
name|LiveInterval
modifier|*
name|dupInterval
parameter_list|(
name|LiveInterval
modifier|*
name|li
parameter_list|)
function_decl|;
comment|/// addLiveRangeToEndOfBlock - Given a register and an instruction,
comment|/// adds a live range from that instruction to the end of its MBB.
name|LiveRange
name|addLiveRangeToEndOfBlock
parameter_list|(
name|unsigned
name|reg
parameter_list|,
name|MachineInstr
modifier|*
name|startInst
parameter_list|)
function_decl|;
comment|// Interval removal
name|void
name|removeInterval
parameter_list|(
name|unsigned
name|Reg
parameter_list|)
block|{
name|DenseMap
operator|<
name|unsigned
operator|,
name|LiveInterval
operator|*
operator|>
operator|::
name|iterator
name|I
operator|=
name|r2iMap_
operator|.
name|find
argument_list|(
name|Reg
argument_list|)
expr_stmt|;
name|delete
name|I
operator|->
name|second
decl_stmt|;
name|r2iMap_
operator|.
name|erase
argument_list|(
name|I
argument_list|)
expr_stmt|;
block|}
name|SlotIndex
name|getZeroIndex
argument_list|()
specifier|const
block|{
return|return
name|indexes_
operator|->
name|getZeroIndex
argument_list|()
return|;
block|}
name|SlotIndex
name|getInvalidIndex
argument_list|()
specifier|const
block|{
return|return
name|indexes_
operator|->
name|getInvalidIndex
argument_list|()
return|;
block|}
comment|/// isNotInMIMap - returns true if the specified machine instr has been
comment|/// removed or was never entered in the map.
name|bool
name|isNotInMIMap
argument_list|(
specifier|const
name|MachineInstr
operator|*
name|Instr
argument_list|)
decl|const
block|{
return|return
operator|!
name|indexes_
operator|->
name|hasIndex
argument_list|(
name|Instr
argument_list|)
return|;
block|}
comment|/// Returns the base index of the given instruction.
name|SlotIndex
name|getInstructionIndex
argument_list|(
specifier|const
name|MachineInstr
operator|*
name|instr
argument_list|)
decl|const
block|{
return|return
name|indexes_
operator|->
name|getInstructionIndex
argument_list|(
name|instr
argument_list|)
return|;
block|}
comment|/// Returns the instruction associated with the given index.
name|MachineInstr
modifier|*
name|getInstructionFromIndex
argument_list|(
name|SlotIndex
name|index
argument_list|)
decl|const
block|{
return|return
name|indexes_
operator|->
name|getInstructionFromIndex
argument_list|(
name|index
argument_list|)
return|;
block|}
comment|/// Return the first index in the given basic block.
name|SlotIndex
name|getMBBStartIdx
argument_list|(
specifier|const
name|MachineBasicBlock
operator|*
name|mbb
argument_list|)
decl|const
block|{
return|return
name|indexes_
operator|->
name|getMBBStartIdx
argument_list|(
name|mbb
argument_list|)
return|;
block|}
comment|/// Return the last index in the given basic block.
name|SlotIndex
name|getMBBEndIdx
argument_list|(
specifier|const
name|MachineBasicBlock
operator|*
name|mbb
argument_list|)
decl|const
block|{
return|return
name|indexes_
operator|->
name|getMBBEndIdx
argument_list|(
name|mbb
argument_list|)
return|;
block|}
name|MachineBasicBlock
modifier|*
name|getMBBFromIndex
argument_list|(
name|SlotIndex
name|index
argument_list|)
decl|const
block|{
return|return
name|indexes_
operator|->
name|getMBBFromIndex
argument_list|(
name|index
argument_list|)
return|;
block|}
name|SlotIndex
name|InsertMachineInstrInMaps
parameter_list|(
name|MachineInstr
modifier|*
name|MI
parameter_list|)
block|{
return|return
name|indexes_
operator|->
name|insertMachineInstrInMaps
argument_list|(
name|MI
argument_list|)
return|;
block|}
name|void
name|RemoveMachineInstrFromMaps
parameter_list|(
name|MachineInstr
modifier|*
name|MI
parameter_list|)
block|{
name|indexes_
operator|->
name|removeMachineInstrFromMaps
argument_list|(
name|MI
argument_list|)
expr_stmt|;
block|}
name|void
name|ReplaceMachineInstrInMaps
parameter_list|(
name|MachineInstr
modifier|*
name|MI
parameter_list|,
name|MachineInstr
modifier|*
name|NewMI
parameter_list|)
block|{
name|indexes_
operator|->
name|replaceMachineInstrInMaps
argument_list|(
name|MI
argument_list|,
name|NewMI
argument_list|)
expr_stmt|;
block|}
name|bool
name|findLiveInMBBs
argument_list|(
name|SlotIndex
name|Start
argument_list|,
name|SlotIndex
name|End
argument_list|,
name|SmallVectorImpl
operator|<
name|MachineBasicBlock
operator|*
operator|>
operator|&
name|MBBs
argument_list|)
decl|const
block|{
return|return
name|indexes_
operator|->
name|findLiveInMBBs
argument_list|(
name|Start
argument_list|,
name|End
argument_list|,
name|MBBs
argument_list|)
return|;
block|}
name|void
name|renumber
parameter_list|()
block|{
name|indexes_
operator|->
name|renumberIndexes
argument_list|()
expr_stmt|;
block|}
name|BumpPtrAllocator
modifier|&
name|getVNInfoAllocator
parameter_list|()
block|{
return|return
name|VNInfoAllocator
return|;
block|}
comment|/// getVNInfoSourceReg - Helper function that parses the specified VNInfo
comment|/// copy field and returns the source register that defines it.
name|unsigned
name|getVNInfoSourceReg
argument_list|(
specifier|const
name|VNInfo
operator|*
name|VNI
argument_list|)
decl|const
decl_stmt|;
name|virtual
name|void
name|getAnalysisUsage
argument_list|(
name|AnalysisUsage
operator|&
name|AU
argument_list|)
decl|const
decl_stmt|;
name|virtual
name|void
name|releaseMemory
parameter_list|()
function_decl|;
comment|/// runOnMachineFunction - pass entry point
name|virtual
name|bool
name|runOnMachineFunction
parameter_list|(
name|MachineFunction
modifier|&
parameter_list|)
function_decl|;
comment|/// print - Implement the dump method.
name|virtual
name|void
name|print
argument_list|(
name|raw_ostream
operator|&
name|O
argument_list|,
specifier|const
name|Module
operator|*
operator|=
literal|0
argument_list|)
decl|const
decl_stmt|;
comment|/// addIntervalsForSpills - Create new intervals for spilled defs / uses of
comment|/// the given interval. FIXME: It also returns the weight of the spill slot
comment|/// (if any is created) by reference. This is temporary.
name|std
operator|::
name|vector
operator|<
name|LiveInterval
operator|*
operator|>
name|addIntervalsForSpills
argument_list|(
specifier|const
name|LiveInterval
operator|&
name|i
argument_list|,
name|SmallVectorImpl
operator|<
name|LiveInterval
operator|*
operator|>
operator|&
name|SpillIs
argument_list|,
specifier|const
name|MachineLoopInfo
operator|*
name|loopInfo
argument_list|,
name|VirtRegMap
operator|&
name|vrm
argument_list|)
expr_stmt|;
comment|/// addIntervalsForSpillsFast - Quickly create new intervals for spilled
comment|/// defs / uses without remat or splitting.
name|std
operator|::
name|vector
operator|<
name|LiveInterval
operator|*
operator|>
name|addIntervalsForSpillsFast
argument_list|(
specifier|const
name|LiveInterval
operator|&
name|li
argument_list|,
specifier|const
name|MachineLoopInfo
operator|*
name|loopInfo
argument_list|,
name|VirtRegMap
operator|&
name|vrm
argument_list|)
expr_stmt|;
comment|/// spillPhysRegAroundRegDefsUses - Spill the specified physical register
comment|/// around all defs and uses of the specified interval. Return true if it
comment|/// was able to cut its interval.
name|bool
name|spillPhysRegAroundRegDefsUses
parameter_list|(
specifier|const
name|LiveInterval
modifier|&
name|li
parameter_list|,
name|unsigned
name|PhysReg
parameter_list|,
name|VirtRegMap
modifier|&
name|vrm
parameter_list|)
function_decl|;
comment|/// isReMaterializable - Returns true if every definition of MI of every
comment|/// val# of the specified interval is re-materializable. Also returns true
comment|/// by reference if all of the defs are load instructions.
name|bool
name|isReMaterializable
argument_list|(
specifier|const
name|LiveInterval
operator|&
name|li
argument_list|,
name|SmallVectorImpl
operator|<
name|LiveInterval
operator|*
operator|>
operator|&
name|SpillIs
argument_list|,
name|bool
operator|&
name|isLoad
argument_list|)
decl_stmt|;
comment|/// isReMaterializable - Returns true if the definition MI of the specified
comment|/// val# of the specified interval is re-materializable.
name|bool
name|isReMaterializable
parameter_list|(
specifier|const
name|LiveInterval
modifier|&
name|li
parameter_list|,
specifier|const
name|VNInfo
modifier|*
name|ValNo
parameter_list|,
name|MachineInstr
modifier|*
name|MI
parameter_list|)
function_decl|;
comment|/// getRepresentativeReg - Find the largest super register of the specified
comment|/// physical register.
name|unsigned
name|getRepresentativeReg
argument_list|(
name|unsigned
name|Reg
argument_list|)
decl|const
decl_stmt|;
comment|/// getNumConflictsWithPhysReg - Return the number of uses and defs of the
comment|/// specified interval that conflicts with the specified physical register.
name|unsigned
name|getNumConflictsWithPhysReg
argument_list|(
specifier|const
name|LiveInterval
operator|&
name|li
argument_list|,
name|unsigned
name|PhysReg
argument_list|)
decl|const
decl_stmt|;
comment|/// processImplicitDefs - Process IMPLICIT_DEF instructions. Add isUndef
comment|/// marker to implicit_def defs and their uses.
name|void
name|processImplicitDefs
parameter_list|()
function_decl|;
comment|/// intervalIsInOneMBB - Returns true if the specified interval is entirely
comment|/// within a single basic block.
name|bool
name|intervalIsInOneMBB
argument_list|(
specifier|const
name|LiveInterval
operator|&
name|li
argument_list|)
decl|const
decl_stmt|;
name|private
label|:
comment|/// computeIntervals - Compute live intervals.
name|void
name|computeIntervals
parameter_list|()
function_decl|;
comment|/// handleRegisterDef - update intervals for a register def
comment|/// (calls handlePhysicalRegisterDef and
comment|/// handleVirtualRegisterDef)
name|void
name|handleRegisterDef
argument_list|(
name|MachineBasicBlock
operator|*
name|MBB
argument_list|,
name|MachineBasicBlock
operator|::
name|iterator
name|MI
argument_list|,
name|SlotIndex
name|MIIdx
argument_list|,
name|MachineOperand
operator|&
name|MO
argument_list|,
name|unsigned
name|MOIdx
argument_list|)
decl_stmt|;
comment|/// handleVirtualRegisterDef - update intervals for a virtual
comment|/// register def
name|void
name|handleVirtualRegisterDef
argument_list|(
name|MachineBasicBlock
operator|*
name|MBB
argument_list|,
name|MachineBasicBlock
operator|::
name|iterator
name|MI
argument_list|,
name|SlotIndex
name|MIIdx
argument_list|,
name|MachineOperand
operator|&
name|MO
argument_list|,
name|unsigned
name|MOIdx
argument_list|,
name|LiveInterval
operator|&
name|interval
argument_list|)
decl_stmt|;
comment|/// handlePhysicalRegisterDef - update intervals for a physical register
comment|/// def.
name|void
name|handlePhysicalRegisterDef
argument_list|(
name|MachineBasicBlock
operator|*
name|mbb
argument_list|,
name|MachineBasicBlock
operator|::
name|iterator
name|mi
argument_list|,
name|SlotIndex
name|MIIdx
argument_list|,
name|MachineOperand
operator|&
name|MO
argument_list|,
name|LiveInterval
operator|&
name|interval
argument_list|,
name|MachineInstr
operator|*
name|CopyMI
argument_list|)
decl_stmt|;
comment|/// handleLiveInRegister - Create interval for a livein register.
name|void
name|handleLiveInRegister
parameter_list|(
name|MachineBasicBlock
modifier|*
name|mbb
parameter_list|,
name|SlotIndex
name|MIIdx
parameter_list|,
name|LiveInterval
modifier|&
name|interval
parameter_list|,
name|bool
name|isAlias
init|=
name|false
parameter_list|)
function_decl|;
comment|/// getReMatImplicitUse - If the remat definition MI has one (for now, we
comment|/// only allow one) virtual register operand, then its uses are implicitly
comment|/// using the register. Returns the virtual register.
name|unsigned
name|getReMatImplicitUse
argument_list|(
specifier|const
name|LiveInterval
operator|&
name|li
argument_list|,
name|MachineInstr
operator|*
name|MI
argument_list|)
decl|const
decl_stmt|;
comment|/// isValNoAvailableAt - Return true if the val# of the specified interval
comment|/// which reaches the given instruction also reaches the specified use
comment|/// index.
name|bool
name|isValNoAvailableAt
argument_list|(
specifier|const
name|LiveInterval
operator|&
name|li
argument_list|,
name|MachineInstr
operator|*
name|MI
argument_list|,
name|SlotIndex
name|UseIdx
argument_list|)
decl|const
decl_stmt|;
comment|/// isReMaterializable - Returns true if the definition MI of the specified
comment|/// val# of the specified interval is re-materializable. Also returns true
comment|/// by reference if the def is a load.
name|bool
name|isReMaterializable
argument_list|(
specifier|const
name|LiveInterval
operator|&
name|li
argument_list|,
specifier|const
name|VNInfo
operator|*
name|ValNo
argument_list|,
name|MachineInstr
operator|*
name|MI
argument_list|,
name|SmallVectorImpl
operator|<
name|LiveInterval
operator|*
operator|>
operator|&
name|SpillIs
argument_list|,
name|bool
operator|&
name|isLoad
argument_list|)
decl_stmt|;
comment|/// tryFoldMemoryOperand - Attempts to fold either a spill / restore from
comment|/// slot / to reg or any rematerialized load into ith operand of specified
comment|/// MI. If it is successul, MI is updated with the newly created MI and
comment|/// returns true.
name|bool
name|tryFoldMemoryOperand
argument_list|(
name|MachineInstr
operator|*
operator|&
name|MI
argument_list|,
name|VirtRegMap
operator|&
name|vrm
argument_list|,
name|MachineInstr
operator|*
name|DefMI
argument_list|,
name|SlotIndex
name|InstrIdx
argument_list|,
name|SmallVector
operator|<
name|unsigned
argument_list|,
literal|2
operator|>
operator|&
name|Ops
argument_list|,
name|bool
name|isSS
argument_list|,
name|int
name|FrameIndex
argument_list|,
name|unsigned
name|Reg
argument_list|)
decl_stmt|;
comment|/// canFoldMemoryOperand - Return true if the specified load / store
comment|/// folding is possible.
name|bool
name|canFoldMemoryOperand
argument_list|(
name|MachineInstr
operator|*
name|MI
argument_list|,
name|SmallVector
operator|<
name|unsigned
argument_list|,
literal|2
operator|>
operator|&
name|Ops
argument_list|,
name|bool
name|ReMatLoadSS
argument_list|)
decl|const
decl_stmt|;
comment|/// anyKillInMBBAfterIdx - Returns true if there is a kill of the specified
comment|/// VNInfo that's after the specified index but is within the basic block.
name|bool
name|anyKillInMBBAfterIdx
argument_list|(
specifier|const
name|LiveInterval
operator|&
name|li
argument_list|,
specifier|const
name|VNInfo
operator|*
name|VNI
argument_list|,
name|MachineBasicBlock
operator|*
name|MBB
argument_list|,
name|SlotIndex
name|Idx
argument_list|)
decl|const
decl_stmt|;
comment|/// hasAllocatableSuperReg - Return true if the specified physical register
comment|/// has any super register that's allocatable.
name|bool
name|hasAllocatableSuperReg
argument_list|(
name|unsigned
name|Reg
argument_list|)
decl|const
decl_stmt|;
comment|/// SRInfo - Spill / restore info.
struct|struct
name|SRInfo
block|{
name|SlotIndex
name|index
decl_stmt|;
name|unsigned
name|vreg
decl_stmt|;
name|bool
name|canFold
decl_stmt|;
name|SRInfo
argument_list|(
argument|SlotIndex i
argument_list|,
argument|unsigned vr
argument_list|,
argument|bool f
argument_list|)
block|:
name|index
argument_list|(
name|i
argument_list|)
operator|,
name|vreg
argument_list|(
name|vr
argument_list|)
operator|,
name|canFold
argument_list|(
argument|f
argument_list|)
block|{}
block|}
struct|;
name|bool
name|alsoFoldARestore
argument_list|(
name|int
name|Id
argument_list|,
name|SlotIndex
name|index
argument_list|,
name|unsigned
name|vr
argument_list|,
name|BitVector
operator|&
name|RestoreMBBs
argument_list|,
name|DenseMap
operator|<
name|unsigned
argument_list|,
name|std
operator|::
name|vector
operator|<
name|SRInfo
operator|>
expr|>
operator|&
name|RestoreIdxes
argument_list|)
decl_stmt|;
name|void
name|eraseRestoreInfo
argument_list|(
name|int
name|Id
argument_list|,
name|SlotIndex
name|index
argument_list|,
name|unsigned
name|vr
argument_list|,
name|BitVector
operator|&
name|RestoreMBBs
argument_list|,
name|DenseMap
operator|<
name|unsigned
argument_list|,
name|std
operator|::
name|vector
operator|<
name|SRInfo
operator|>
expr|>
operator|&
name|RestoreIdxes
argument_list|)
decl_stmt|;
comment|/// handleSpilledImpDefs - Remove IMPLICIT_DEF instructions which are being
comment|/// spilled and create empty intervals for their uses.
name|void
name|handleSpilledImpDefs
argument_list|(
specifier|const
name|LiveInterval
operator|&
name|li
argument_list|,
name|VirtRegMap
operator|&
name|vrm
argument_list|,
specifier|const
name|TargetRegisterClass
operator|*
name|rc
argument_list|,
name|std
operator|::
name|vector
operator|<
name|LiveInterval
operator|*
operator|>
operator|&
name|NewLIs
argument_list|)
decl_stmt|;
comment|/// rewriteImplicitOps - Rewrite implicit use operands of MI (i.e. uses of
comment|/// interval on to-be re-materialized operands of MI) with new register.
name|void
name|rewriteImplicitOps
parameter_list|(
specifier|const
name|LiveInterval
modifier|&
name|li
parameter_list|,
name|MachineInstr
modifier|*
name|MI
parameter_list|,
name|unsigned
name|NewVReg
parameter_list|,
name|VirtRegMap
modifier|&
name|vrm
parameter_list|)
function_decl|;
comment|/// rewriteInstructionForSpills, rewriteInstructionsForSpills - Helper
comment|/// functions for addIntervalsForSpills to rewrite uses / defs for the given
comment|/// live range.
name|bool
name|rewriteInstructionForSpills
argument_list|(
specifier|const
name|LiveInterval
operator|&
name|li
argument_list|,
specifier|const
name|VNInfo
operator|*
name|VNI
argument_list|,
name|bool
name|TrySplit
argument_list|,
name|SlotIndex
name|index
argument_list|,
name|SlotIndex
name|end
argument_list|,
name|MachineInstr
operator|*
name|MI
argument_list|,
name|MachineInstr
operator|*
name|OrigDefMI
argument_list|,
name|MachineInstr
operator|*
name|DefMI
argument_list|,
name|unsigned
name|Slot
argument_list|,
name|int
name|LdSlot
argument_list|,
name|bool
name|isLoad
argument_list|,
name|bool
name|isLoadSS
argument_list|,
name|bool
name|DefIsReMat
argument_list|,
name|bool
name|CanDelete
argument_list|,
name|VirtRegMap
operator|&
name|vrm
argument_list|,
specifier|const
name|TargetRegisterClass
operator|*
name|rc
argument_list|,
name|SmallVector
operator|<
name|int
argument_list|,
literal|4
operator|>
operator|&
name|ReMatIds
argument_list|,
specifier|const
name|MachineLoopInfo
operator|*
name|loopInfo
argument_list|,
name|unsigned
operator|&
name|NewVReg
argument_list|,
name|unsigned
name|ImpUse
argument_list|,
name|bool
operator|&
name|HasDef
argument_list|,
name|bool
operator|&
name|HasUse
argument_list|,
name|DenseMap
operator|<
name|unsigned
argument_list|,
name|unsigned
operator|>
operator|&
name|MBBVRegsMap
argument_list|,
name|std
operator|::
name|vector
operator|<
name|LiveInterval
operator|*
operator|>
operator|&
name|NewLIs
argument_list|)
decl_stmt|;
name|void
name|rewriteInstructionsForSpills
argument_list|(
specifier|const
name|LiveInterval
operator|&
name|li
argument_list|,
name|bool
name|TrySplit
argument_list|,
name|LiveInterval
operator|::
name|Ranges
operator|::
name|const_iterator
operator|&
name|I
argument_list|,
name|MachineInstr
operator|*
name|OrigDefMI
argument_list|,
name|MachineInstr
operator|*
name|DefMI
argument_list|,
name|unsigned
name|Slot
argument_list|,
name|int
name|LdSlot
argument_list|,
name|bool
name|isLoad
argument_list|,
name|bool
name|isLoadSS
argument_list|,
name|bool
name|DefIsReMat
argument_list|,
name|bool
name|CanDelete
argument_list|,
name|VirtRegMap
operator|&
name|vrm
argument_list|,
specifier|const
name|TargetRegisterClass
operator|*
name|rc
argument_list|,
name|SmallVector
operator|<
name|int
argument_list|,
literal|4
operator|>
operator|&
name|ReMatIds
argument_list|,
specifier|const
name|MachineLoopInfo
operator|*
name|loopInfo
argument_list|,
name|BitVector
operator|&
name|SpillMBBs
argument_list|,
name|DenseMap
operator|<
name|unsigned
argument_list|,
name|std
operator|::
name|vector
operator|<
name|SRInfo
operator|>
expr|>
operator|&
name|SpillIdxes
argument_list|,
name|BitVector
operator|&
name|RestoreMBBs
argument_list|,
name|DenseMap
operator|<
name|unsigned
argument_list|,
name|std
operator|::
name|vector
operator|<
name|SRInfo
operator|>
expr|>
operator|&
name|RestoreIdxes
argument_list|,
name|DenseMap
operator|<
name|unsigned
argument_list|,
name|unsigned
operator|>
operator|&
name|MBBVRegsMap
argument_list|,
name|std
operator|::
name|vector
operator|<
name|LiveInterval
operator|*
operator|>
operator|&
name|NewLIs
argument_list|)
decl_stmt|;
specifier|static
name|LiveInterval
modifier|*
name|createInterval
parameter_list|(
name|unsigned
name|Reg
parameter_list|)
function_decl|;
name|void
name|printInstrs
argument_list|(
name|raw_ostream
operator|&
name|O
argument_list|)
decl|const
decl_stmt|;
name|void
name|dumpInstrs
argument_list|()
specifier|const
expr_stmt|;
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_comment
unit|}
comment|// End llvm namespace
end_comment

begin_endif
endif|#
directive|endif
end_endif

end_unit

