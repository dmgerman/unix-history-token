begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===-- LiveIntervalAnalysis.h - Live Interval Analysis ---------*- C++ -*-===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file implements the LiveInterval analysis pass.  Given some numbering of
end_comment

begin_comment
comment|// each the machine instructions (in this implemention depth-first order) an
end_comment

begin_comment
comment|// interval [i, j) is said to be a live interval for register v if there is no
end_comment

begin_comment
comment|// instruction with number j'> j such that v is live at j' and there is no
end_comment

begin_comment
comment|// instruction with number i'< i such that v is live at i'. In this
end_comment

begin_comment
comment|// implementation intervals can have holes, i.e. an interval might look like
end_comment

begin_comment
comment|// [1,20), [50,65), [1000,1001).
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LLVM_CODEGEN_LIVEINTERVAL_ANALYSIS_H
end_ifndef

begin_define
define|#
directive|define
name|LLVM_CODEGEN_LIVEINTERVAL_ANALYSIS_H
end_define

begin_include
include|#
directive|include
file|"llvm/CodeGen/MachineFunctionPass.h"
end_include

begin_include
include|#
directive|include
file|"llvm/CodeGen/LiveInterval.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/BitVector.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/DenseMap.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/SmallPtrSet.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/SmallVector.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/Allocator.h"
end_include

begin_include
include|#
directive|include
file|<cmath>
end_include

begin_decl_stmt
name|namespace
name|llvm
block|{
name|class
name|AliasAnalysis
decl_stmt|;
name|class
name|LiveVariables
decl_stmt|;
name|class
name|MachineLoopInfo
decl_stmt|;
name|class
name|TargetRegisterInfo
decl_stmt|;
name|class
name|MachineRegisterInfo
decl_stmt|;
name|class
name|TargetInstrInfo
decl_stmt|;
name|class
name|TargetRegisterClass
decl_stmt|;
name|class
name|VirtRegMap
decl_stmt|;
typedef|typedef
name|std
operator|::
name|pair
operator|<
name|unsigned
operator|,
name|MachineBasicBlock
operator|*
operator|>
name|IdxMBBPair
expr_stmt|;
specifier|inline
name|bool
name|operator
operator|<
operator|(
name|unsigned
name|V
operator|,
specifier|const
name|IdxMBBPair
operator|&
name|IM
operator|)
block|{
return|return
name|V
operator|<
name|IM
operator|.
name|first
return|;
block|}
specifier|inline
name|bool
name|operator
operator|<
operator|(
specifier|const
name|IdxMBBPair
operator|&
name|IM
operator|,
name|unsigned
name|V
operator|)
block|{
return|return
name|IM
operator|.
name|first
operator|<
name|V
return|;
block|}
struct|struct
name|Idx2MBBCompare
block|{
name|bool
name|operator
argument_list|()
operator|(
specifier|const
name|IdxMBBPair
operator|&
name|LHS
operator|,
specifier|const
name|IdxMBBPair
operator|&
name|RHS
operator|)
specifier|const
block|{
return|return
name|LHS
operator|.
name|first
operator|<
name|RHS
operator|.
name|first
return|;
block|}
block|}
struct|;
name|class
name|LiveIntervals
range|:
name|public
name|MachineFunctionPass
block|{
name|MachineFunction
operator|*
name|mf_
block|;
name|MachineRegisterInfo
operator|*
name|mri_
block|;
specifier|const
name|TargetMachine
operator|*
name|tm_
block|;
specifier|const
name|TargetRegisterInfo
operator|*
name|tri_
block|;
specifier|const
name|TargetInstrInfo
operator|*
name|tii_
block|;
name|AliasAnalysis
operator|*
name|aa_
block|;
name|LiveVariables
operator|*
name|lv_
block|;
comment|/// Special pool allocator for VNInfo's (LiveInterval val#).
comment|///
name|BumpPtrAllocator
name|VNInfoAllocator
block|;
comment|/// MBB2IdxMap - The indexes of the first and last instructions in the
comment|/// specified basic block.
name|std
operator|::
name|vector
operator|<
name|std
operator|::
name|pair
operator|<
name|unsigned
block|,
name|unsigned
operator|>
expr|>
name|MBB2IdxMap
block|;
comment|/// Idx2MBBMap - Sorted list of pairs of index of first instruction
comment|/// and MBB id.
name|std
operator|::
name|vector
operator|<
name|IdxMBBPair
operator|>
name|Idx2MBBMap
block|;
comment|/// FunctionSize - The number of instructions present in the function
name|uint64_t
name|FunctionSize
block|;
typedef|typedef
name|DenseMap
operator|<
name|MachineInstr
operator|*
operator|,
name|unsigned
operator|>
name|Mi2IndexMap
expr_stmt|;
name|Mi2IndexMap
name|mi2iMap_
decl_stmt|;
typedef|typedef
name|std
operator|::
name|vector
operator|<
name|MachineInstr
operator|*
operator|>
name|Index2MiMap
expr_stmt|;
name|Index2MiMap
name|i2miMap_
decl_stmt|;
typedef|typedef
name|DenseMap
operator|<
name|unsigned
operator|,
name|LiveInterval
operator|*
operator|>
name|Reg2IntervalMap
expr_stmt|;
name|Reg2IntervalMap
name|r2iMap_
decl_stmt|;
name|BitVector
name|allocatableRegs_
decl_stmt|;
name|std
operator|::
name|vector
operator|<
name|MachineInstr
operator|*
operator|>
name|ClonedMIs
expr_stmt|;
typedef|typedef
name|LiveInterval
operator|::
name|InstrSlots
name|InstrSlots
expr_stmt|;
name|public
label|:
specifier|static
name|char
name|ID
decl_stmt|;
comment|// Pass identification, replacement for typeid
name|LiveIntervals
argument_list|()
operator|:
name|MachineFunctionPass
argument_list|(
argument|&ID
argument_list|)
block|{}
specifier|static
name|unsigned
name|getBaseIndex
argument_list|(
argument|unsigned index
argument_list|)
block|{
return|return
name|index
operator|-
operator|(
name|index
operator|%
name|InstrSlots
operator|::
name|NUM
operator|)
return|;
block|}
specifier|static
name|unsigned
name|getBoundaryIndex
parameter_list|(
name|unsigned
name|index
parameter_list|)
block|{
return|return
name|getBaseIndex
argument_list|(
name|index
operator|+
name|InstrSlots
operator|::
name|NUM
operator|-
literal|1
argument_list|)
return|;
block|}
specifier|static
name|unsigned
name|getLoadIndex
parameter_list|(
name|unsigned
name|index
parameter_list|)
block|{
return|return
name|getBaseIndex
argument_list|(
name|index
argument_list|)
operator|+
name|InstrSlots
operator|::
name|LOAD
return|;
block|}
specifier|static
name|unsigned
name|getUseIndex
parameter_list|(
name|unsigned
name|index
parameter_list|)
block|{
return|return
name|getBaseIndex
argument_list|(
name|index
argument_list|)
operator|+
name|InstrSlots
operator|::
name|USE
return|;
block|}
specifier|static
name|unsigned
name|getDefIndex
parameter_list|(
name|unsigned
name|index
parameter_list|)
block|{
return|return
name|getBaseIndex
argument_list|(
name|index
argument_list|)
operator|+
name|InstrSlots
operator|::
name|DEF
return|;
block|}
specifier|static
name|unsigned
name|getStoreIndex
parameter_list|(
name|unsigned
name|index
parameter_list|)
block|{
return|return
name|getBaseIndex
argument_list|(
name|index
argument_list|)
operator|+
name|InstrSlots
operator|::
name|STORE
return|;
block|}
specifier|static
name|float
name|getSpillWeight
parameter_list|(
name|bool
name|isDef
parameter_list|,
name|bool
name|isUse
parameter_list|,
name|unsigned
name|loopDepth
parameter_list|)
block|{
return|return
operator|(
name|isDef
operator|+
name|isUse
operator|)
operator|*
name|powf
argument_list|(
literal|10.0F
argument_list|,
operator|(
name|float
operator|)
name|loopDepth
argument_list|)
return|;
block|}
typedef|typedef
name|Reg2IntervalMap
operator|::
name|iterator
name|iterator
expr_stmt|;
typedef|typedef
name|Reg2IntervalMap
operator|::
name|const_iterator
name|const_iterator
expr_stmt|;
name|const_iterator
name|begin
argument_list|()
specifier|const
block|{
return|return
name|r2iMap_
operator|.
name|begin
argument_list|()
return|;
block|}
name|const_iterator
name|end
argument_list|()
specifier|const
block|{
return|return
name|r2iMap_
operator|.
name|end
argument_list|()
return|;
block|}
name|iterator
name|begin
parameter_list|()
block|{
return|return
name|r2iMap_
operator|.
name|begin
argument_list|()
return|;
block|}
name|iterator
name|end
parameter_list|()
block|{
return|return
name|r2iMap_
operator|.
name|end
argument_list|()
return|;
block|}
name|unsigned
name|getNumIntervals
argument_list|()
specifier|const
block|{
return|return
operator|(
name|unsigned
operator|)
name|r2iMap_
operator|.
name|size
argument_list|()
return|;
block|}
name|LiveInterval
modifier|&
name|getInterval
parameter_list|(
name|unsigned
name|reg
parameter_list|)
block|{
name|Reg2IntervalMap
operator|::
name|iterator
name|I
operator|=
name|r2iMap_
operator|.
name|find
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|I
operator|!=
name|r2iMap_
operator|.
name|end
argument_list|()
operator|&&
literal|"Interval does not exist for register"
argument_list|)
expr_stmt|;
return|return
operator|*
name|I
operator|->
name|second
return|;
block|}
specifier|const
name|LiveInterval
modifier|&
name|getInterval
argument_list|(
name|unsigned
name|reg
argument_list|)
decl|const
block|{
name|Reg2IntervalMap
operator|::
name|const_iterator
name|I
operator|=
name|r2iMap_
operator|.
name|find
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|I
operator|!=
name|r2iMap_
operator|.
name|end
argument_list|()
operator|&&
literal|"Interval does not exist for register"
argument_list|)
expr_stmt|;
return|return
operator|*
name|I
operator|->
name|second
return|;
block|}
name|bool
name|hasInterval
argument_list|(
name|unsigned
name|reg
argument_list|)
decl|const
block|{
return|return
name|r2iMap_
operator|.
name|count
argument_list|(
name|reg
argument_list|)
return|;
block|}
comment|/// getMBBStartIdx - Return the base index of the first instruction in the
comment|/// specified MachineBasicBlock.
name|unsigned
name|getMBBStartIdx
argument_list|(
name|MachineBasicBlock
operator|*
name|MBB
argument_list|)
decl|const
block|{
return|return
name|getMBBStartIdx
argument_list|(
name|MBB
operator|->
name|getNumber
argument_list|()
argument_list|)
return|;
block|}
name|unsigned
name|getMBBStartIdx
argument_list|(
name|unsigned
name|MBBNo
argument_list|)
decl|const
block|{
name|assert
argument_list|(
name|MBBNo
operator|<
name|MBB2IdxMap
operator|.
name|size
argument_list|()
operator|&&
literal|"Invalid MBB number!"
argument_list|)
expr_stmt|;
return|return
name|MBB2IdxMap
index|[
name|MBBNo
index|]
operator|.
name|first
return|;
block|}
comment|/// getMBBEndIdx - Return the store index of the last instruction in the
comment|/// specified MachineBasicBlock.
name|unsigned
name|getMBBEndIdx
argument_list|(
name|MachineBasicBlock
operator|*
name|MBB
argument_list|)
decl|const
block|{
return|return
name|getMBBEndIdx
argument_list|(
name|MBB
operator|->
name|getNumber
argument_list|()
argument_list|)
return|;
block|}
name|unsigned
name|getMBBEndIdx
argument_list|(
name|unsigned
name|MBBNo
argument_list|)
decl|const
block|{
name|assert
argument_list|(
name|MBBNo
operator|<
name|MBB2IdxMap
operator|.
name|size
argument_list|()
operator|&&
literal|"Invalid MBB number!"
argument_list|)
expr_stmt|;
return|return
name|MBB2IdxMap
index|[
name|MBBNo
index|]
operator|.
name|second
return|;
block|}
comment|/// getScaledIntervalSize - get the size of an interval in "units,"
comment|/// where every function is composed of one thousand units.  This
comment|/// measure scales properly with empty index slots in the function.
name|double
name|getScaledIntervalSize
parameter_list|(
name|LiveInterval
modifier|&
name|I
parameter_list|)
block|{
return|return
operator|(
literal|1000.0
operator|/
name|InstrSlots
operator|::
name|NUM
operator|*
name|I
operator|.
name|getSize
argument_list|()
operator|)
operator|/
name|i2miMap_
operator|.
name|size
argument_list|()
return|;
block|}
comment|/// getApproximateInstructionCount - computes an estimate of the number
comment|/// of instructions in a given LiveInterval.
name|unsigned
name|getApproximateInstructionCount
parameter_list|(
name|LiveInterval
modifier|&
name|I
parameter_list|)
block|{
name|double
name|IntervalPercentage
init|=
name|getScaledIntervalSize
argument_list|(
name|I
argument_list|)
operator|/
literal|1000.0
decl_stmt|;
return|return
call|(
name|unsigned
call|)
argument_list|(
name|IntervalPercentage
operator|*
name|FunctionSize
argument_list|)
return|;
block|}
comment|/// getMBBFromIndex - given an index in any instruction of an
comment|/// MBB return a pointer the MBB
name|MachineBasicBlock
modifier|*
name|getMBBFromIndex
argument_list|(
name|unsigned
name|index
argument_list|)
decl|const
block|{
name|std
operator|::
name|vector
operator|<
name|IdxMBBPair
operator|>
operator|::
name|const_iterator
name|I
operator|=
name|std
operator|::
name|lower_bound
argument_list|(
name|Idx2MBBMap
operator|.
name|begin
argument_list|()
argument_list|,
name|Idx2MBBMap
operator|.
name|end
argument_list|()
argument_list|,
name|index
argument_list|)
expr_stmt|;
comment|// Take the pair containing the index
name|std
operator|::
name|vector
operator|<
name|IdxMBBPair
operator|>
operator|::
name|const_iterator
name|J
operator|=
operator|(
operator|(
name|I
operator|!=
name|Idx2MBBMap
operator|.
name|end
argument_list|()
operator|&&
name|I
operator|->
name|first
operator|>
name|index
operator|)
operator|||
operator|(
name|I
operator|==
name|Idx2MBBMap
operator|.
name|end
argument_list|()
operator|&&
name|Idx2MBBMap
operator|.
name|size
argument_list|()
operator|>
literal|0
operator|)
operator|)
condition|?
operator|(
name|I
operator|-
literal|1
operator|)
else|:
name|I
expr_stmt|;
name|assert
argument_list|(
name|J
operator|!=
name|Idx2MBBMap
operator|.
name|end
argument_list|()
operator|&&
name|J
operator|->
name|first
operator|<
name|index
operator|+
literal|1
operator|&&
name|index
operator|<=
name|getMBBEndIdx
argument_list|(
name|J
operator|->
name|second
argument_list|)
operator|&&
literal|"index does not correspond to an MBB"
argument_list|)
expr_stmt|;
return|return
name|J
operator|->
name|second
return|;
block|}
comment|/// getInstructionIndex - returns the base index of instr
name|unsigned
name|getInstructionIndex
argument_list|(
name|MachineInstr
operator|*
name|instr
argument_list|)
decl|const
block|{
name|Mi2IndexMap
operator|::
name|const_iterator
name|it
operator|=
name|mi2iMap_
operator|.
name|find
argument_list|(
name|instr
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|it
operator|!=
name|mi2iMap_
operator|.
name|end
argument_list|()
operator|&&
literal|"Invalid instruction!"
argument_list|)
expr_stmt|;
return|return
name|it
operator|->
name|second
return|;
block|}
comment|/// getInstructionFromIndex - given an index in any slot of an
comment|/// instruction return a pointer the instruction
name|MachineInstr
modifier|*
name|getInstructionFromIndex
argument_list|(
name|unsigned
name|index
argument_list|)
decl|const
block|{
name|index
operator|/=
name|InstrSlots
operator|::
name|NUM
expr_stmt|;
comment|// convert index to vector index
name|assert
argument_list|(
name|index
operator|<
name|i2miMap_
operator|.
name|size
argument_list|()
operator|&&
literal|"index does not correspond to an instruction"
argument_list|)
expr_stmt|;
return|return
name|i2miMap_
index|[
name|index
index|]
return|;
block|}
comment|/// hasGapBeforeInstr - Return true if the previous instruction slot,
comment|/// i.e. Index - InstrSlots::NUM, is not occupied.
name|bool
name|hasGapBeforeInstr
parameter_list|(
name|unsigned
name|Index
parameter_list|)
block|{
name|Index
operator|=
name|getBaseIndex
argument_list|(
name|Index
operator|-
name|InstrSlots
operator|::
name|NUM
argument_list|)
expr_stmt|;
return|return
name|getInstructionFromIndex
argument_list|(
name|Index
argument_list|)
operator|==
literal|0
return|;
block|}
comment|/// hasGapAfterInstr - Return true if the successive instruction slot,
comment|/// i.e. Index + InstrSlots::Num, is not occupied.
name|bool
name|hasGapAfterInstr
parameter_list|(
name|unsigned
name|Index
parameter_list|)
block|{
name|Index
operator|=
name|getBaseIndex
argument_list|(
name|Index
operator|+
name|InstrSlots
operator|::
name|NUM
argument_list|)
expr_stmt|;
return|return
name|getInstructionFromIndex
argument_list|(
name|Index
argument_list|)
operator|==
literal|0
return|;
block|}
comment|/// findGapBeforeInstr - Find an empty instruction slot before the
comment|/// specified index. If "Furthest" is true, find one that's furthest
comment|/// away from the index (but before any index that's occupied).
name|unsigned
name|findGapBeforeInstr
parameter_list|(
name|unsigned
name|Index
parameter_list|,
name|bool
name|Furthest
init|=
name|false
parameter_list|)
block|{
name|Index
operator|=
name|getBaseIndex
argument_list|(
name|Index
operator|-
name|InstrSlots
operator|::
name|NUM
argument_list|)
expr_stmt|;
if|if
condition|(
name|getInstructionFromIndex
argument_list|(
name|Index
argument_list|)
condition|)
return|return
literal|0
return|;
comment|// No gap!
if|if
condition|(
operator|!
name|Furthest
condition|)
return|return
name|Index
return|;
name|unsigned
name|PrevIndex
init|=
name|getBaseIndex
argument_list|(
name|Index
operator|-
name|InstrSlots
operator|::
name|NUM
argument_list|)
decl_stmt|;
while|while
condition|(
name|getInstructionFromIndex
argument_list|(
name|Index
argument_list|)
condition|)
block|{
name|Index
operator|=
name|PrevIndex
expr_stmt|;
name|PrevIndex
operator|=
name|getBaseIndex
argument_list|(
name|Index
operator|-
name|InstrSlots
operator|::
name|NUM
argument_list|)
expr_stmt|;
block|}
return|return
name|Index
return|;
block|}
comment|/// InsertMachineInstrInMaps - Insert the specified machine instruction
comment|/// into the instruction index map at the given index.
name|void
name|InsertMachineInstrInMaps
parameter_list|(
name|MachineInstr
modifier|*
name|MI
parameter_list|,
name|unsigned
name|Index
parameter_list|)
block|{
name|i2miMap_
index|[
name|Index
operator|/
name|InstrSlots
operator|::
name|NUM
index|]
operator|=
name|MI
expr_stmt|;
name|Mi2IndexMap
operator|::
name|iterator
name|it
operator|=
name|mi2iMap_
operator|.
name|find
argument_list|(
name|MI
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|it
operator|==
name|mi2iMap_
operator|.
name|end
argument_list|()
operator|&&
literal|"Already in map!"
argument_list|)
expr_stmt|;
name|mi2iMap_
index|[
name|MI
index|]
operator|=
name|Index
expr_stmt|;
block|}
comment|/// conflictsWithPhysRegDef - Returns true if the specified register
comment|/// is defined during the duration of the specified interval.
name|bool
name|conflictsWithPhysRegDef
parameter_list|(
specifier|const
name|LiveInterval
modifier|&
name|li
parameter_list|,
name|VirtRegMap
modifier|&
name|vrm
parameter_list|,
name|unsigned
name|reg
parameter_list|)
function_decl|;
comment|/// conflictsWithPhysRegRef - Similar to conflictsWithPhysRegRef except
comment|/// it can check use as well.
name|bool
name|conflictsWithPhysRegRef
argument_list|(
name|LiveInterval
operator|&
name|li
argument_list|,
name|unsigned
name|Reg
argument_list|,
name|bool
name|CheckUse
argument_list|,
name|SmallPtrSet
operator|<
name|MachineInstr
operator|*
argument_list|,
literal|32
operator|>
operator|&
name|JoinedCopies
argument_list|)
decl_stmt|;
comment|/// findLiveInMBBs - Given a live range, if the value of the range
comment|/// is live in any MBB returns true as well as the list of basic blocks
comment|/// in which the value is live.
name|bool
name|findLiveInMBBs
argument_list|(
name|unsigned
name|Start
argument_list|,
name|unsigned
name|End
argument_list|,
name|SmallVectorImpl
operator|<
name|MachineBasicBlock
operator|*
operator|>
operator|&
name|MBBs
argument_list|)
decl|const
decl_stmt|;
comment|/// findReachableMBBs - Return a list MBB that can be reached via any
comment|/// branch or fallthroughs. Return true if the list is not empty.
name|bool
name|findReachableMBBs
argument_list|(
name|unsigned
name|Start
argument_list|,
name|unsigned
name|End
argument_list|,
name|SmallVectorImpl
operator|<
name|MachineBasicBlock
operator|*
operator|>
operator|&
name|MBBs
argument_list|)
decl|const
decl_stmt|;
comment|// Interval creation
name|LiveInterval
modifier|&
name|getOrCreateInterval
parameter_list|(
name|unsigned
name|reg
parameter_list|)
block|{
name|Reg2IntervalMap
operator|::
name|iterator
name|I
operator|=
name|r2iMap_
operator|.
name|find
argument_list|(
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|I
operator|==
name|r2iMap_
operator|.
name|end
argument_list|()
condition|)
name|I
operator|=
name|r2iMap_
operator|.
name|insert
argument_list|(
name|std
operator|::
name|make_pair
argument_list|(
name|reg
argument_list|,
name|createInterval
argument_list|(
name|reg
argument_list|)
argument_list|)
argument_list|)
operator|.
name|first
expr_stmt|;
return|return
operator|*
name|I
operator|->
name|second
return|;
block|}
comment|/// dupInterval - Duplicate a live interval. The caller is responsible for
comment|/// managing the allocated memory.
name|LiveInterval
modifier|*
name|dupInterval
parameter_list|(
name|LiveInterval
modifier|*
name|li
parameter_list|)
function_decl|;
comment|/// addLiveRangeToEndOfBlock - Given a register and an instruction,
comment|/// adds a live range from that instruction to the end of its MBB.
name|LiveRange
name|addLiveRangeToEndOfBlock
parameter_list|(
name|unsigned
name|reg
parameter_list|,
name|MachineInstr
modifier|*
name|startInst
parameter_list|)
function_decl|;
comment|// Interval removal
name|void
name|removeInterval
parameter_list|(
name|unsigned
name|Reg
parameter_list|)
block|{
name|DenseMap
operator|<
name|unsigned
operator|,
name|LiveInterval
operator|*
operator|>
operator|::
name|iterator
name|I
operator|=
name|r2iMap_
operator|.
name|find
argument_list|(
name|Reg
argument_list|)
expr_stmt|;
name|delete
name|I
operator|->
name|second
decl_stmt|;
name|r2iMap_
operator|.
name|erase
argument_list|(
name|I
argument_list|)
expr_stmt|;
block|}
comment|/// isNotInMIMap - returns true if the specified machine instr has been
comment|/// removed or was never entered in the map.
name|bool
name|isNotInMIMap
argument_list|(
name|MachineInstr
operator|*
name|instr
argument_list|)
decl|const
block|{
return|return
operator|!
name|mi2iMap_
operator|.
name|count
argument_list|(
name|instr
argument_list|)
return|;
block|}
comment|/// RemoveMachineInstrFromMaps - This marks the specified machine instr as
comment|/// deleted.
name|void
name|RemoveMachineInstrFromMaps
parameter_list|(
name|MachineInstr
modifier|*
name|MI
parameter_list|)
block|{
comment|// remove index -> MachineInstr and
comment|// MachineInstr -> index mappings
name|Mi2IndexMap
operator|::
name|iterator
name|mi2i
operator|=
name|mi2iMap_
operator|.
name|find
argument_list|(
name|MI
argument_list|)
expr_stmt|;
if|if
condition|(
name|mi2i
operator|!=
name|mi2iMap_
operator|.
name|end
argument_list|()
condition|)
block|{
name|i2miMap_
index|[
name|mi2i
operator|->
name|second
operator|/
name|InstrSlots
operator|::
name|NUM
index|]
operator|=
literal|0
expr_stmt|;
name|mi2iMap_
operator|.
name|erase
argument_list|(
name|mi2i
argument_list|)
expr_stmt|;
block|}
block|}
comment|/// ReplaceMachineInstrInMaps - Replacing a machine instr with a new one in
comment|/// maps used by register allocator.
name|void
name|ReplaceMachineInstrInMaps
parameter_list|(
name|MachineInstr
modifier|*
name|MI
parameter_list|,
name|MachineInstr
modifier|*
name|NewMI
parameter_list|)
block|{
name|Mi2IndexMap
operator|::
name|iterator
name|mi2i
operator|=
name|mi2iMap_
operator|.
name|find
argument_list|(
name|MI
argument_list|)
expr_stmt|;
if|if
condition|(
name|mi2i
operator|==
name|mi2iMap_
operator|.
name|end
argument_list|()
condition|)
return|return;
name|i2miMap_
index|[
name|mi2i
operator|->
name|second
operator|/
name|InstrSlots
operator|::
name|NUM
index|]
operator|=
name|NewMI
expr_stmt|;
name|Mi2IndexMap
operator|::
name|iterator
name|it
operator|=
name|mi2iMap_
operator|.
name|find
argument_list|(
name|MI
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|it
operator|!=
name|mi2iMap_
operator|.
name|end
argument_list|()
operator|&&
literal|"Invalid instruction!"
argument_list|)
expr_stmt|;
name|unsigned
name|Index
init|=
name|it
operator|->
name|second
decl_stmt|;
name|mi2iMap_
operator|.
name|erase
argument_list|(
name|it
argument_list|)
expr_stmt|;
name|mi2iMap_
index|[
name|NewMI
index|]
operator|=
name|Index
expr_stmt|;
block|}
name|BumpPtrAllocator
modifier|&
name|getVNInfoAllocator
parameter_list|()
block|{
return|return
name|VNInfoAllocator
return|;
block|}
comment|/// getVNInfoSourceReg - Helper function that parses the specified VNInfo
comment|/// copy field and returns the source register that defines it.
name|unsigned
name|getVNInfoSourceReg
argument_list|(
specifier|const
name|VNInfo
operator|*
name|VNI
argument_list|)
decl|const
decl_stmt|;
name|virtual
name|void
name|getAnalysisUsage
argument_list|(
name|AnalysisUsage
operator|&
name|AU
argument_list|)
decl|const
decl_stmt|;
name|virtual
name|void
name|releaseMemory
parameter_list|()
function_decl|;
comment|/// runOnMachineFunction - pass entry point
name|virtual
name|bool
name|runOnMachineFunction
parameter_list|(
name|MachineFunction
modifier|&
parameter_list|)
function_decl|;
comment|/// print - Implement the dump method.
name|virtual
name|void
name|print
argument_list|(
name|std
operator|::
name|ostream
operator|&
name|O
argument_list|,
specifier|const
name|Module
operator|*
operator|=
literal|0
argument_list|)
decl|const
decl_stmt|;
name|void
name|print
argument_list|(
name|std
operator|::
name|ostream
operator|*
name|O
argument_list|,
specifier|const
name|Module
operator|*
name|M
operator|=
literal|0
argument_list|)
decl|const
block|{
if|if
condition|(
name|O
condition|)
name|print
argument_list|(
operator|*
name|O
argument_list|,
name|M
argument_list|)
expr_stmt|;
block|}
comment|/// addIntervalsForSpills - Create new intervals for spilled defs / uses of
comment|/// the given interval. FIXME: It also returns the weight of the spill slot
comment|/// (if any is created) by reference. This is temporary.
name|std
operator|::
name|vector
operator|<
name|LiveInterval
operator|*
operator|>
name|addIntervalsForSpills
argument_list|(
specifier|const
name|LiveInterval
operator|&
name|i
argument_list|,
name|SmallVectorImpl
operator|<
name|LiveInterval
operator|*
operator|>
operator|&
name|SpillIs
argument_list|,
specifier|const
name|MachineLoopInfo
operator|*
name|loopInfo
argument_list|,
name|VirtRegMap
operator|&
name|vrm
argument_list|)
expr_stmt|;
comment|/// addIntervalsForSpillsFast - Quickly create new intervals for spilled
comment|/// defs / uses without remat or splitting.
name|std
operator|::
name|vector
operator|<
name|LiveInterval
operator|*
operator|>
name|addIntervalsForSpillsFast
argument_list|(
specifier|const
name|LiveInterval
operator|&
name|li
argument_list|,
specifier|const
name|MachineLoopInfo
operator|*
name|loopInfo
argument_list|,
name|VirtRegMap
operator|&
name|vrm
argument_list|)
expr_stmt|;
comment|/// spillPhysRegAroundRegDefsUses - Spill the specified physical register
comment|/// around all defs and uses of the specified interval. Return true if it
comment|/// was able to cut its interval.
name|bool
name|spillPhysRegAroundRegDefsUses
parameter_list|(
specifier|const
name|LiveInterval
modifier|&
name|li
parameter_list|,
name|unsigned
name|PhysReg
parameter_list|,
name|VirtRegMap
modifier|&
name|vrm
parameter_list|)
function_decl|;
comment|/// isReMaterializable - Returns true if every definition of MI of every
comment|/// val# of the specified interval is re-materializable. Also returns true
comment|/// by reference if all of the defs are load instructions.
name|bool
name|isReMaterializable
argument_list|(
specifier|const
name|LiveInterval
operator|&
name|li
argument_list|,
name|SmallVectorImpl
operator|<
name|LiveInterval
operator|*
operator|>
operator|&
name|SpillIs
argument_list|,
name|bool
operator|&
name|isLoad
argument_list|)
decl_stmt|;
comment|/// isReMaterializable - Returns true if the definition MI of the specified
comment|/// val# of the specified interval is re-materializable.
name|bool
name|isReMaterializable
parameter_list|(
specifier|const
name|LiveInterval
modifier|&
name|li
parameter_list|,
specifier|const
name|VNInfo
modifier|*
name|ValNo
parameter_list|,
name|MachineInstr
modifier|*
name|MI
parameter_list|)
function_decl|;
comment|/// getRepresentativeReg - Find the largest super register of the specified
comment|/// physical register.
name|unsigned
name|getRepresentativeReg
argument_list|(
name|unsigned
name|Reg
argument_list|)
decl|const
decl_stmt|;
comment|/// getNumConflictsWithPhysReg - Return the number of uses and defs of the
comment|/// specified interval that conflicts with the specified physical register.
name|unsigned
name|getNumConflictsWithPhysReg
argument_list|(
specifier|const
name|LiveInterval
operator|&
name|li
argument_list|,
name|unsigned
name|PhysReg
argument_list|)
decl|const
decl_stmt|;
comment|/// processImplicitDefs - Process IMPLICIT_DEF instructions. Add isUndef
comment|/// marker to implicit_def defs and their uses.
name|void
name|processImplicitDefs
parameter_list|()
function_decl|;
comment|/// computeNumbering - Compute the index numbering.
name|void
name|computeNumbering
parameter_list|()
function_decl|;
comment|/// scaleNumbering - Rescale interval numbers to introduce gaps for new
comment|/// instructions
name|void
name|scaleNumbering
parameter_list|(
name|int
name|factor
parameter_list|)
function_decl|;
comment|/// intervalIsInOneMBB - Returns true if the specified interval is entirely
comment|/// within a single basic block.
name|bool
name|intervalIsInOneMBB
argument_list|(
specifier|const
name|LiveInterval
operator|&
name|li
argument_list|)
decl|const
decl_stmt|;
name|private
label|:
comment|/// computeIntervals - Compute live intervals.
name|void
name|computeIntervals
parameter_list|()
function_decl|;
comment|/// handleRegisterDef - update intervals for a register def
comment|/// (calls handlePhysicalRegisterDef and
comment|/// handleVirtualRegisterDef)
name|void
name|handleRegisterDef
argument_list|(
name|MachineBasicBlock
operator|*
name|MBB
argument_list|,
name|MachineBasicBlock
operator|::
name|iterator
name|MI
argument_list|,
name|unsigned
name|MIIdx
argument_list|,
name|MachineOperand
operator|&
name|MO
argument_list|,
name|unsigned
name|MOIdx
argument_list|)
decl_stmt|;
comment|/// handleVirtualRegisterDef - update intervals for a virtual
comment|/// register def
name|void
name|handleVirtualRegisterDef
argument_list|(
name|MachineBasicBlock
operator|*
name|MBB
argument_list|,
name|MachineBasicBlock
operator|::
name|iterator
name|MI
argument_list|,
name|unsigned
name|MIIdx
argument_list|,
name|MachineOperand
operator|&
name|MO
argument_list|,
name|unsigned
name|MOIdx
argument_list|,
name|LiveInterval
operator|&
name|interval
argument_list|)
decl_stmt|;
comment|/// handlePhysicalRegisterDef - update intervals for a physical register
comment|/// def.
name|void
name|handlePhysicalRegisterDef
argument_list|(
name|MachineBasicBlock
operator|*
name|mbb
argument_list|,
name|MachineBasicBlock
operator|::
name|iterator
name|mi
argument_list|,
name|unsigned
name|MIIdx
argument_list|,
name|MachineOperand
operator|&
name|MO
argument_list|,
name|LiveInterval
operator|&
name|interval
argument_list|,
name|MachineInstr
operator|*
name|CopyMI
argument_list|)
decl_stmt|;
comment|/// handleLiveInRegister - Create interval for a livein register.
name|void
name|handleLiveInRegister
parameter_list|(
name|MachineBasicBlock
modifier|*
name|mbb
parameter_list|,
name|unsigned
name|MIIdx
parameter_list|,
name|LiveInterval
modifier|&
name|interval
parameter_list|,
name|bool
name|isAlias
init|=
name|false
parameter_list|)
function_decl|;
comment|/// getReMatImplicitUse - If the remat definition MI has one (for now, we
comment|/// only allow one) virtual register operand, then its uses are implicitly
comment|/// using the register. Returns the virtual register.
name|unsigned
name|getReMatImplicitUse
argument_list|(
specifier|const
name|LiveInterval
operator|&
name|li
argument_list|,
name|MachineInstr
operator|*
name|MI
argument_list|)
decl|const
decl_stmt|;
comment|/// isValNoAvailableAt - Return true if the val# of the specified interval
comment|/// which reaches the given instruction also reaches the specified use
comment|/// index.
name|bool
name|isValNoAvailableAt
argument_list|(
specifier|const
name|LiveInterval
operator|&
name|li
argument_list|,
name|MachineInstr
operator|*
name|MI
argument_list|,
name|unsigned
name|UseIdx
argument_list|)
decl|const
decl_stmt|;
comment|/// isReMaterializable - Returns true if the definition MI of the specified
comment|/// val# of the specified interval is re-materializable. Also returns true
comment|/// by reference if the def is a load.
name|bool
name|isReMaterializable
argument_list|(
specifier|const
name|LiveInterval
operator|&
name|li
argument_list|,
specifier|const
name|VNInfo
operator|*
name|ValNo
argument_list|,
name|MachineInstr
operator|*
name|MI
argument_list|,
name|SmallVectorImpl
operator|<
name|LiveInterval
operator|*
operator|>
operator|&
name|SpillIs
argument_list|,
name|bool
operator|&
name|isLoad
argument_list|)
decl_stmt|;
comment|/// tryFoldMemoryOperand - Attempts to fold either a spill / restore from
comment|/// slot / to reg or any rematerialized load into ith operand of specified
comment|/// MI. If it is successul, MI is updated with the newly created MI and
comment|/// returns true.
name|bool
name|tryFoldMemoryOperand
argument_list|(
name|MachineInstr
operator|*
operator|&
name|MI
argument_list|,
name|VirtRegMap
operator|&
name|vrm
argument_list|,
name|MachineInstr
operator|*
name|DefMI
argument_list|,
name|unsigned
name|InstrIdx
argument_list|,
name|SmallVector
operator|<
name|unsigned
argument_list|,
literal|2
operator|>
operator|&
name|Ops
argument_list|,
name|bool
name|isSS
argument_list|,
name|int
name|Slot
argument_list|,
name|unsigned
name|Reg
argument_list|)
decl_stmt|;
comment|/// canFoldMemoryOperand - Return true if the specified load / store
comment|/// folding is possible.
name|bool
name|canFoldMemoryOperand
argument_list|(
name|MachineInstr
operator|*
name|MI
argument_list|,
name|SmallVector
operator|<
name|unsigned
argument_list|,
literal|2
operator|>
operator|&
name|Ops
argument_list|,
name|bool
name|ReMatLoadSS
argument_list|)
decl|const
decl_stmt|;
comment|/// anyKillInMBBAfterIdx - Returns true if there is a kill of the specified
comment|/// VNInfo that's after the specified index but is within the basic block.
name|bool
name|anyKillInMBBAfterIdx
argument_list|(
specifier|const
name|LiveInterval
operator|&
name|li
argument_list|,
specifier|const
name|VNInfo
operator|*
name|VNI
argument_list|,
name|MachineBasicBlock
operator|*
name|MBB
argument_list|,
name|unsigned
name|Idx
argument_list|)
decl|const
decl_stmt|;
comment|/// hasAllocatableSuperReg - Return true if the specified physical register
comment|/// has any super register that's allocatable.
name|bool
name|hasAllocatableSuperReg
argument_list|(
name|unsigned
name|Reg
argument_list|)
decl|const
decl_stmt|;
comment|/// SRInfo - Spill / restore info.
struct|struct
name|SRInfo
block|{
name|int
name|index
decl_stmt|;
name|unsigned
name|vreg
decl_stmt|;
name|bool
name|canFold
decl_stmt|;
name|SRInfo
argument_list|(
argument|int i
argument_list|,
argument|unsigned vr
argument_list|,
argument|bool f
argument_list|)
block|:
name|index
argument_list|(
name|i
argument_list|)
operator|,
name|vreg
argument_list|(
name|vr
argument_list|)
operator|,
name|canFold
argument_list|(
argument|f
argument_list|)
block|{}
expr_stmt|;
block|}
struct|;
name|bool
name|alsoFoldARestore
argument_list|(
name|int
name|Id
argument_list|,
name|int
name|index
argument_list|,
name|unsigned
name|vr
argument_list|,
name|BitVector
operator|&
name|RestoreMBBs
argument_list|,
name|DenseMap
operator|<
name|unsigned
argument_list|,
name|std
operator|::
name|vector
operator|<
name|SRInfo
operator|>
expr|>
operator|&
name|RestoreIdxes
argument_list|)
decl_stmt|;
name|void
name|eraseRestoreInfo
argument_list|(
name|int
name|Id
argument_list|,
name|int
name|index
argument_list|,
name|unsigned
name|vr
argument_list|,
name|BitVector
operator|&
name|RestoreMBBs
argument_list|,
name|DenseMap
operator|<
name|unsigned
argument_list|,
name|std
operator|::
name|vector
operator|<
name|SRInfo
operator|>
expr|>
operator|&
name|RestoreIdxes
argument_list|)
decl_stmt|;
comment|/// handleSpilledImpDefs - Remove IMPLICIT_DEF instructions which are being
comment|/// spilled and create empty intervals for their uses.
name|void
name|handleSpilledImpDefs
argument_list|(
specifier|const
name|LiveInterval
operator|&
name|li
argument_list|,
name|VirtRegMap
operator|&
name|vrm
argument_list|,
specifier|const
name|TargetRegisterClass
operator|*
name|rc
argument_list|,
name|std
operator|::
name|vector
operator|<
name|LiveInterval
operator|*
operator|>
operator|&
name|NewLIs
argument_list|)
decl_stmt|;
comment|/// rewriteImplicitOps - Rewrite implicit use operands of MI (i.e. uses of
comment|/// interval on to-be re-materialized operands of MI) with new register.
name|void
name|rewriteImplicitOps
parameter_list|(
specifier|const
name|LiveInterval
modifier|&
name|li
parameter_list|,
name|MachineInstr
modifier|*
name|MI
parameter_list|,
name|unsigned
name|NewVReg
parameter_list|,
name|VirtRegMap
modifier|&
name|vrm
parameter_list|)
function_decl|;
comment|/// rewriteInstructionForSpills, rewriteInstructionsForSpills - Helper
comment|/// functions for addIntervalsForSpills to rewrite uses / defs for the given
comment|/// live range.
name|bool
name|rewriteInstructionForSpills
argument_list|(
specifier|const
name|LiveInterval
operator|&
name|li
argument_list|,
specifier|const
name|VNInfo
operator|*
name|VNI
argument_list|,
name|bool
name|TrySplit
argument_list|,
name|unsigned
name|index
argument_list|,
name|unsigned
name|end
argument_list|,
name|MachineInstr
operator|*
name|MI
argument_list|,
name|MachineInstr
operator|*
name|OrigDefMI
argument_list|,
name|MachineInstr
operator|*
name|DefMI
argument_list|,
name|unsigned
name|Slot
argument_list|,
name|int
name|LdSlot
argument_list|,
name|bool
name|isLoad
argument_list|,
name|bool
name|isLoadSS
argument_list|,
name|bool
name|DefIsReMat
argument_list|,
name|bool
name|CanDelete
argument_list|,
name|VirtRegMap
operator|&
name|vrm
argument_list|,
specifier|const
name|TargetRegisterClass
operator|*
name|rc
argument_list|,
name|SmallVector
operator|<
name|int
argument_list|,
literal|4
operator|>
operator|&
name|ReMatIds
argument_list|,
specifier|const
name|MachineLoopInfo
operator|*
name|loopInfo
argument_list|,
name|unsigned
operator|&
name|NewVReg
argument_list|,
name|unsigned
name|ImpUse
argument_list|,
name|bool
operator|&
name|HasDef
argument_list|,
name|bool
operator|&
name|HasUse
argument_list|,
name|DenseMap
operator|<
name|unsigned
argument_list|,
name|unsigned
operator|>
operator|&
name|MBBVRegsMap
argument_list|,
name|std
operator|::
name|vector
operator|<
name|LiveInterval
operator|*
operator|>
operator|&
name|NewLIs
argument_list|)
decl_stmt|;
name|void
name|rewriteInstructionsForSpills
argument_list|(
specifier|const
name|LiveInterval
operator|&
name|li
argument_list|,
name|bool
name|TrySplit
argument_list|,
name|LiveInterval
operator|::
name|Ranges
operator|::
name|const_iterator
operator|&
name|I
argument_list|,
name|MachineInstr
operator|*
name|OrigDefMI
argument_list|,
name|MachineInstr
operator|*
name|DefMI
argument_list|,
name|unsigned
name|Slot
argument_list|,
name|int
name|LdSlot
argument_list|,
name|bool
name|isLoad
argument_list|,
name|bool
name|isLoadSS
argument_list|,
name|bool
name|DefIsReMat
argument_list|,
name|bool
name|CanDelete
argument_list|,
name|VirtRegMap
operator|&
name|vrm
argument_list|,
specifier|const
name|TargetRegisterClass
operator|*
name|rc
argument_list|,
name|SmallVector
operator|<
name|int
argument_list|,
literal|4
operator|>
operator|&
name|ReMatIds
argument_list|,
specifier|const
name|MachineLoopInfo
operator|*
name|loopInfo
argument_list|,
name|BitVector
operator|&
name|SpillMBBs
argument_list|,
name|DenseMap
operator|<
name|unsigned
argument_list|,
name|std
operator|::
name|vector
operator|<
name|SRInfo
operator|>
expr|>
operator|&
name|SpillIdxes
argument_list|,
name|BitVector
operator|&
name|RestoreMBBs
argument_list|,
name|DenseMap
operator|<
name|unsigned
argument_list|,
name|std
operator|::
name|vector
operator|<
name|SRInfo
operator|>
expr|>
operator|&
name|RestoreIdxes
argument_list|,
name|DenseMap
operator|<
name|unsigned
argument_list|,
name|unsigned
operator|>
operator|&
name|MBBVRegsMap
argument_list|,
name|std
operator|::
name|vector
operator|<
name|LiveInterval
operator|*
operator|>
operator|&
name|NewLIs
argument_list|)
decl_stmt|;
specifier|static
name|LiveInterval
modifier|*
name|createInterval
parameter_list|(
name|unsigned
name|Reg
parameter_list|)
function_decl|;
name|void
name|printRegName
argument_list|(
name|unsigned
name|reg
argument_list|)
decl|const
decl_stmt|;
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_comment
unit|}
comment|// End llvm namespace
end_comment

begin_endif
endif|#
directive|endif
end_endif

end_unit

