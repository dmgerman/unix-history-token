begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===- BasicTTIImpl.h -------------------------------------------*- C++ -*-===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|/// \file
end_comment

begin_comment
comment|/// This file provides a helper that implements much of the TTI interface in
end_comment

begin_comment
comment|/// terms of the target-independent code generator and TargetLowering
end_comment

begin_comment
comment|/// interfaces.
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LLVM_CODEGEN_BASICTTIIMPL_H
end_ifndef

begin_define
define|#
directive|define
name|LLVM_CODEGEN_BASICTTIIMPL_H
end_define

begin_include
include|#
directive|include
file|"llvm/Analysis/LoopInfo.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Analysis/TargetTransformInfoImpl.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/CommandLine.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Target/TargetLowering.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Target/TargetSubtargetInfo.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Analysis/TargetLibraryInfo.h"
end_include

begin_decl_stmt
name|namespace
name|llvm
block|{
extern|extern cl::opt<unsigned> PartialUnrollingThreshold;
comment|/// \brief Base class which can be used to help build a TTI implementation.
comment|///
comment|/// This class provides as much implementation of the TTI interface as is
comment|/// possible using the target independent parts of the code generator.
comment|///
comment|/// In order to subclass it, your class must implement a getST() method to
comment|/// return the subtarget, and a getTLI() method to return the target lowering.
comment|/// We need these methods implemented in the derived class so that this class
comment|/// doesn't have to duplicate storage for them.
name|template
operator|<
name|typename
name|T
operator|>
name|class
name|BasicTTIImplBase
operator|:
name|public
name|TargetTransformInfoImplCRTPBase
operator|<
name|T
operator|>
block|{
name|private
operator|:
typedef|typedef
name|TargetTransformInfoImplCRTPBase
operator|<
name|T
operator|>
name|BaseT
expr_stmt|;
typedef|typedef
name|TargetTransformInfo
name|TTI
typedef|;
comment|/// Estimate a cost of shuffle as a sequence of extract and insert
comment|/// operations.
name|unsigned
name|getPermuteShuffleOverhead
parameter_list|(
name|Type
modifier|*
name|Ty
parameter_list|)
block|{
name|assert
argument_list|(
name|Ty
operator|->
name|isVectorTy
argument_list|()
operator|&&
literal|"Can only shuffle vectors"
argument_list|)
expr_stmt|;
name|unsigned
name|Cost
init|=
literal|0
decl_stmt|;
comment|// Shuffle cost is equal to the cost of extracting element from its argument
comment|// plus the cost of inserting them onto the result vector.
comment|// e.g.<4 x float> has a mask of<0,5,2,7> i.e we need to extract from
comment|// index 0 of first vector, index 1 of second vector,index 2 of first
comment|// vector and finally index 3 of second vector and insert them at index
comment|//<0,1,2,3> of result vector.
for|for
control|(
name|int
name|i
init|=
literal|0
init|,
name|e
init|=
name|Ty
operator|->
name|getVectorNumElements
argument_list|()
init|;
name|i
operator|<
name|e
condition|;
operator|++
name|i
control|)
block|{
name|Cost
operator|+=
name|static_cast
operator|<
name|T
operator|*
operator|>
operator|(
name|this
operator|)
operator|->
name|getVectorInstrCost
argument_list|(
name|Instruction
operator|::
name|InsertElement
argument_list|,
name|Ty
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|Cost
operator|+=
name|static_cast
operator|<
name|T
operator|*
operator|>
operator|(
name|this
operator|)
operator|->
name|getVectorInstrCost
argument_list|(
name|Instruction
operator|::
name|ExtractElement
argument_list|,
name|Ty
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
return|return
name|Cost
return|;
block|}
comment|/// \brief Local query method delegates up to T which *must* implement this!
specifier|const
name|TargetSubtargetInfo
operator|*
name|getST
argument_list|()
specifier|const
block|{
return|return
name|static_cast
operator|<
specifier|const
name|T
operator|*
operator|>
operator|(
name|this
operator|)
operator|->
name|getST
argument_list|()
return|;
block|}
comment|/// \brief Local query method delegates up to T which *must* implement this!
specifier|const
name|TargetLoweringBase
operator|*
name|getTLI
argument_list|()
specifier|const
block|{
return|return
name|static_cast
operator|<
specifier|const
name|T
operator|*
operator|>
operator|(
name|this
operator|)
operator|->
name|getTLI
argument_list|()
return|;
block|}
name|protected
label|:
name|explicit
name|BasicTTIImplBase
argument_list|(
specifier|const
name|TargetMachine
operator|*
name|TM
argument_list|,
specifier|const
name|DataLayout
operator|&
name|DL
argument_list|)
operator|:
name|BaseT
argument_list|(
argument|DL
argument_list|)
block|{}
name|using
name|TargetTransformInfoImplBase
operator|::
name|DL
expr_stmt|;
name|public
label|:
comment|/// \name Scalar TTI Implementations
comment|/// @{
name|bool
name|allowsMisalignedMemoryAccesses
argument_list|(
name|LLVMContext
operator|&
name|Context
argument_list|,
name|unsigned
name|BitWidth
argument_list|,
name|unsigned
name|AddressSpace
argument_list|,
name|unsigned
name|Alignment
argument_list|,
name|bool
operator|*
name|Fast
argument_list|)
decl|const
block|{
name|EVT
name|E
init|=
name|EVT
operator|::
name|getIntegerVT
argument_list|(
name|Context
argument_list|,
name|BitWidth
argument_list|)
decl_stmt|;
return|return
name|getTLI
argument_list|()
operator|->
name|allowsMisalignedMemoryAccesses
argument_list|(
name|E
argument_list|,
name|AddressSpace
argument_list|,
name|Alignment
argument_list|,
name|Fast
argument_list|)
return|;
block|}
name|bool
name|hasBranchDivergence
parameter_list|()
block|{
return|return
name|false
return|;
block|}
name|bool
name|isSourceOfDivergence
parameter_list|(
specifier|const
name|Value
modifier|*
name|V
parameter_list|)
block|{
return|return
name|false
return|;
block|}
name|unsigned
name|getFlatAddressSpace
parameter_list|()
block|{
comment|// Return an invalid address space.
return|return
operator|-
literal|1
return|;
block|}
name|bool
name|isLegalAddImmediate
parameter_list|(
name|int64_t
name|imm
parameter_list|)
block|{
return|return
name|getTLI
argument_list|()
operator|->
name|isLegalAddImmediate
argument_list|(
name|imm
argument_list|)
return|;
block|}
name|bool
name|isLegalICmpImmediate
parameter_list|(
name|int64_t
name|imm
parameter_list|)
block|{
return|return
name|getTLI
argument_list|()
operator|->
name|isLegalICmpImmediate
argument_list|(
name|imm
argument_list|)
return|;
block|}
name|bool
name|isLegalAddressingMode
parameter_list|(
name|Type
modifier|*
name|Ty
parameter_list|,
name|GlobalValue
modifier|*
name|BaseGV
parameter_list|,
name|int64_t
name|BaseOffset
parameter_list|,
name|bool
name|HasBaseReg
parameter_list|,
name|int64_t
name|Scale
parameter_list|,
name|unsigned
name|AddrSpace
parameter_list|)
block|{
name|TargetLoweringBase
operator|::
name|AddrMode
name|AM
expr_stmt|;
name|AM
operator|.
name|BaseGV
operator|=
name|BaseGV
expr_stmt|;
name|AM
operator|.
name|BaseOffs
operator|=
name|BaseOffset
expr_stmt|;
name|AM
operator|.
name|HasBaseReg
operator|=
name|HasBaseReg
expr_stmt|;
name|AM
operator|.
name|Scale
operator|=
name|Scale
expr_stmt|;
return|return
name|getTLI
argument_list|()
operator|->
name|isLegalAddressingMode
argument_list|(
name|DL
argument_list|,
name|AM
argument_list|,
name|Ty
argument_list|,
name|AddrSpace
argument_list|)
return|;
block|}
name|int
name|getScalingFactorCost
parameter_list|(
name|Type
modifier|*
name|Ty
parameter_list|,
name|GlobalValue
modifier|*
name|BaseGV
parameter_list|,
name|int64_t
name|BaseOffset
parameter_list|,
name|bool
name|HasBaseReg
parameter_list|,
name|int64_t
name|Scale
parameter_list|,
name|unsigned
name|AddrSpace
parameter_list|)
block|{
name|TargetLoweringBase
operator|::
name|AddrMode
name|AM
expr_stmt|;
name|AM
operator|.
name|BaseGV
operator|=
name|BaseGV
expr_stmt|;
name|AM
operator|.
name|BaseOffs
operator|=
name|BaseOffset
expr_stmt|;
name|AM
operator|.
name|HasBaseReg
operator|=
name|HasBaseReg
expr_stmt|;
name|AM
operator|.
name|Scale
operator|=
name|Scale
expr_stmt|;
return|return
name|getTLI
argument_list|()
operator|->
name|getScalingFactorCost
argument_list|(
name|DL
argument_list|,
name|AM
argument_list|,
name|Ty
argument_list|,
name|AddrSpace
argument_list|)
return|;
block|}
name|bool
name|isFoldableMemAccessOffset
parameter_list|(
name|Instruction
modifier|*
name|I
parameter_list|,
name|int64_t
name|Offset
parameter_list|)
block|{
return|return
name|getTLI
argument_list|()
operator|->
name|isFoldableMemAccessOffset
argument_list|(
name|I
argument_list|,
name|Offset
argument_list|)
return|;
block|}
name|bool
name|isTruncateFree
parameter_list|(
name|Type
modifier|*
name|Ty1
parameter_list|,
name|Type
modifier|*
name|Ty2
parameter_list|)
block|{
return|return
name|getTLI
argument_list|()
operator|->
name|isTruncateFree
argument_list|(
name|Ty1
argument_list|,
name|Ty2
argument_list|)
return|;
block|}
name|bool
name|isProfitableToHoist
parameter_list|(
name|Instruction
modifier|*
name|I
parameter_list|)
block|{
return|return
name|getTLI
argument_list|()
operator|->
name|isProfitableToHoist
argument_list|(
name|I
argument_list|)
return|;
block|}
name|bool
name|isTypeLegal
parameter_list|(
name|Type
modifier|*
name|Ty
parameter_list|)
block|{
name|EVT
name|VT
init|=
name|getTLI
argument_list|()
operator|->
name|getValueType
argument_list|(
name|DL
argument_list|,
name|Ty
argument_list|)
decl_stmt|;
return|return
name|getTLI
argument_list|()
operator|->
name|isTypeLegal
argument_list|(
name|VT
argument_list|)
return|;
block|}
name|int
name|getGEPCost
argument_list|(
name|Type
operator|*
name|PointeeType
argument_list|,
specifier|const
name|Value
operator|*
name|Ptr
argument_list|,
name|ArrayRef
operator|<
specifier|const
name|Value
operator|*
operator|>
name|Operands
argument_list|)
block|{
return|return
name|BaseT
operator|::
name|getGEPCost
argument_list|(
name|PointeeType
argument_list|,
name|Ptr
argument_list|,
name|Operands
argument_list|)
return|;
block|}
name|unsigned
name|getIntrinsicCost
argument_list|(
name|Intrinsic
operator|::
name|ID
name|IID
argument_list|,
name|Type
operator|*
name|RetTy
argument_list|,
name|ArrayRef
operator|<
specifier|const
name|Value
operator|*
operator|>
name|Arguments
argument_list|)
block|{
return|return
name|BaseT
operator|::
name|getIntrinsicCost
argument_list|(
name|IID
argument_list|,
name|RetTy
argument_list|,
name|Arguments
argument_list|)
return|;
block|}
name|unsigned
name|getIntrinsicCost
argument_list|(
name|Intrinsic
operator|::
name|ID
name|IID
argument_list|,
name|Type
operator|*
name|RetTy
argument_list|,
name|ArrayRef
operator|<
name|Type
operator|*
operator|>
name|ParamTys
argument_list|)
block|{
if|if
condition|(
name|IID
operator|==
name|Intrinsic
operator|::
name|cttz
condition|)
block|{
if|if
condition|(
name|getTLI
argument_list|()
operator|->
name|isCheapToSpeculateCttz
argument_list|()
condition|)
return|return
name|TargetTransformInfo
operator|::
name|TCC_Basic
return|;
return|return
name|TargetTransformInfo
operator|::
name|TCC_Expensive
return|;
block|}
if|if
condition|(
name|IID
operator|==
name|Intrinsic
operator|::
name|ctlz
condition|)
block|{
if|if
condition|(
name|getTLI
argument_list|()
operator|->
name|isCheapToSpeculateCtlz
argument_list|()
condition|)
return|return
name|TargetTransformInfo
operator|::
name|TCC_Basic
return|;
return|return
name|TargetTransformInfo
operator|::
name|TCC_Expensive
return|;
block|}
return|return
name|BaseT
operator|::
name|getIntrinsicCost
argument_list|(
name|IID
argument_list|,
name|RetTy
argument_list|,
name|ParamTys
argument_list|)
return|;
block|}
name|unsigned
name|getEstimatedNumberOfCaseClusters
parameter_list|(
specifier|const
name|SwitchInst
modifier|&
name|SI
parameter_list|,
name|unsigned
modifier|&
name|JumpTableSize
parameter_list|)
block|{
comment|/// Try to find the estimated number of clusters. Note that the number of
comment|/// clusters identified in this function could be different from the actural
comment|/// numbers found in lowering. This function ignore switches that are
comment|/// lowered with a mix of jump table / bit test / BTree. This function was
comment|/// initially intended to be used when estimating the cost of switch in
comment|/// inline cost heuristic, but it's a generic cost model to be used in other
comment|/// places (e.g., in loop unrolling).
name|unsigned
name|N
init|=
name|SI
operator|.
name|getNumCases
argument_list|()
decl_stmt|;
specifier|const
name|TargetLoweringBase
modifier|*
name|TLI
init|=
name|getTLI
argument_list|()
decl_stmt|;
specifier|const
name|DataLayout
modifier|&
name|DL
init|=
name|this
operator|->
name|getDataLayout
argument_list|()
decl_stmt|;
name|JumpTableSize
operator|=
literal|0
expr_stmt|;
name|bool
name|IsJTAllowed
init|=
name|TLI
operator|->
name|areJTsAllowed
argument_list|(
name|SI
operator|.
name|getParent
argument_list|()
operator|->
name|getParent
argument_list|()
argument_list|)
decl_stmt|;
comment|// Early exit if both a jump table and bit test are not allowed.
if|if
condition|(
name|N
operator|<
literal|1
operator|||
operator|(
operator|!
name|IsJTAllowed
operator|&&
name|DL
operator|.
name|getPointerSizeInBits
argument_list|()
operator|<
name|N
operator|)
condition|)
return|return
name|N
return|;
name|APInt
name|MaxCaseVal
init|=
name|SI
operator|.
name|case_begin
argument_list|()
operator|->
name|getCaseValue
argument_list|()
operator|->
name|getValue
argument_list|()
decl_stmt|;
name|APInt
name|MinCaseVal
init|=
name|MaxCaseVal
decl_stmt|;
for|for
control|(
name|auto
name|CI
range|:
name|SI
operator|.
name|cases
argument_list|()
control|)
block|{
specifier|const
name|APInt
modifier|&
name|CaseVal
init|=
name|CI
operator|.
name|getCaseValue
argument_list|()
operator|->
name|getValue
argument_list|()
decl_stmt|;
if|if
condition|(
name|CaseVal
operator|.
name|sgt
argument_list|(
name|MaxCaseVal
argument_list|)
condition|)
name|MaxCaseVal
operator|=
name|CaseVal
expr_stmt|;
if|if
condition|(
name|CaseVal
operator|.
name|slt
argument_list|(
name|MinCaseVal
argument_list|)
condition|)
name|MinCaseVal
operator|=
name|CaseVal
expr_stmt|;
block|}
comment|// Check if suitable for a bit test
if|if
condition|(
name|N
operator|<=
name|DL
operator|.
name|getPointerSizeInBits
argument_list|()
condition|)
block|{
name|SmallPtrSet
operator|<
specifier|const
name|BasicBlock
operator|*
operator|,
literal|4
operator|>
name|Dests
expr_stmt|;
for|for
control|(
name|auto
name|I
range|:
name|SI
operator|.
name|cases
argument_list|()
control|)
name|Dests
operator|.
name|insert
argument_list|(
name|I
operator|.
name|getCaseSuccessor
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|TLI
operator|->
name|isSuitableForBitTests
argument_list|(
name|Dests
operator|.
name|size
argument_list|()
argument_list|,
name|N
argument_list|,
name|MinCaseVal
argument_list|,
name|MaxCaseVal
argument_list|,
name|DL
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
comment|// Check if suitable for a jump table.
if|if
condition|(
name|IsJTAllowed
condition|)
block|{
if|if
condition|(
name|N
operator|<
literal|2
operator|||
name|N
operator|<
name|TLI
operator|->
name|getMinimumJumpTableEntries
argument_list|()
condition|)
return|return
name|N
return|;
name|uint64_t
name|Range
init|=
operator|(
name|MaxCaseVal
operator|-
name|MinCaseVal
operator|)
operator|.
name|getLimitedValue
argument_list|(
name|UINT64_MAX
operator|-
literal|1
argument_list|)
operator|+
literal|1
decl_stmt|;
comment|// Check whether a range of clusters is dense enough for a jump table
if|if
condition|(
name|TLI
operator|->
name|isSuitableForJumpTable
argument_list|(
operator|&
name|SI
argument_list|,
name|N
argument_list|,
name|Range
argument_list|)
condition|)
block|{
name|JumpTableSize
operator|=
name|Range
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
return|return
name|N
return|;
block|}
name|unsigned
name|getJumpBufAlignment
parameter_list|()
block|{
return|return
name|getTLI
argument_list|()
operator|->
name|getJumpBufAlignment
argument_list|()
return|;
block|}
name|unsigned
name|getJumpBufSize
parameter_list|()
block|{
return|return
name|getTLI
argument_list|()
operator|->
name|getJumpBufSize
argument_list|()
return|;
block|}
name|bool
name|shouldBuildLookupTables
parameter_list|()
block|{
specifier|const
name|TargetLoweringBase
modifier|*
name|TLI
init|=
name|getTLI
argument_list|()
decl_stmt|;
return|return
name|TLI
operator|->
name|isOperationLegalOrCustom
argument_list|(
name|ISD
operator|::
name|BR_JT
argument_list|,
name|MVT
operator|::
name|Other
argument_list|)
operator|||
name|TLI
operator|->
name|isOperationLegalOrCustom
argument_list|(
name|ISD
operator|::
name|BRIND
argument_list|,
name|MVT
operator|::
name|Other
argument_list|)
return|;
block|}
name|bool
name|haveFastSqrt
parameter_list|(
name|Type
modifier|*
name|Ty
parameter_list|)
block|{
specifier|const
name|TargetLoweringBase
modifier|*
name|TLI
init|=
name|getTLI
argument_list|()
decl_stmt|;
name|EVT
name|VT
init|=
name|TLI
operator|->
name|getValueType
argument_list|(
name|DL
argument_list|,
name|Ty
argument_list|)
decl_stmt|;
return|return
name|TLI
operator|->
name|isTypeLegal
argument_list|(
name|VT
argument_list|)
operator|&&
name|TLI
operator|->
name|isOperationLegalOrCustom
argument_list|(
name|ISD
operator|::
name|FSQRT
argument_list|,
name|VT
argument_list|)
return|;
block|}
name|unsigned
name|getFPOpCost
parameter_list|(
name|Type
modifier|*
name|Ty
parameter_list|)
block|{
comment|// By default, FP instructions are no more expensive since they are
comment|// implemented in HW.  Target specific TTI can override this.
return|return
name|TargetTransformInfo
operator|::
name|TCC_Basic
return|;
block|}
name|unsigned
name|getOperationCost
parameter_list|(
name|unsigned
name|Opcode
parameter_list|,
name|Type
modifier|*
name|Ty
parameter_list|,
name|Type
modifier|*
name|OpTy
parameter_list|)
block|{
specifier|const
name|TargetLoweringBase
modifier|*
name|TLI
init|=
name|getTLI
argument_list|()
decl_stmt|;
switch|switch
condition|(
name|Opcode
condition|)
block|{
default|default:
break|break;
case|case
name|Instruction
operator|::
name|Trunc
case|:
block|{
if|if
condition|(
name|TLI
operator|->
name|isTruncateFree
argument_list|(
name|OpTy
argument_list|,
name|Ty
argument_list|)
condition|)
return|return
name|TargetTransformInfo
operator|::
name|TCC_Free
return|;
return|return
name|TargetTransformInfo
operator|::
name|TCC_Basic
return|;
block|}
case|case
name|Instruction
operator|::
name|ZExt
case|:
block|{
if|if
condition|(
name|TLI
operator|->
name|isZExtFree
argument_list|(
name|OpTy
argument_list|,
name|Ty
argument_list|)
condition|)
return|return
name|TargetTransformInfo
operator|::
name|TCC_Free
return|;
return|return
name|TargetTransformInfo
operator|::
name|TCC_Basic
return|;
block|}
block|}
return|return
name|BaseT
operator|::
name|getOperationCost
argument_list|(
name|Opcode
argument_list|,
name|Ty
argument_list|,
name|OpTy
argument_list|)
return|;
block|}
name|unsigned
name|getInliningThresholdMultiplier
parameter_list|()
block|{
return|return
literal|1
return|;
block|}
name|void
name|getUnrollingPreferences
argument_list|(
name|Loop
operator|*
name|L
argument_list|,
name|TTI
operator|::
name|UnrollingPreferences
operator|&
name|UP
argument_list|)
block|{
comment|// This unrolling functionality is target independent, but to provide some
comment|// motivation for its intended use, for x86:
comment|// According to the Intel 64 and IA-32 Architectures Optimization Reference
comment|// Manual, Intel Core models and later have a loop stream detector (and
comment|// associated uop queue) that can benefit from partial unrolling.
comment|// The relevant requirements are:
comment|//  - The loop must have no more than 4 (8 for Nehalem and later) branches
comment|//    taken, and none of them may be calls.
comment|//  - The loop can have no more than 18 (28 for Nehalem and later) uops.
comment|// According to the Software Optimization Guide for AMD Family 15h
comment|// Processors, models 30h-4fh (Steamroller and later) have a loop predictor
comment|// and loop buffer which can benefit from partial unrolling.
comment|// The relevant requirements are:
comment|//  - The loop must have fewer than 16 branches
comment|//  - The loop must have less than 40 uops in all executed loop branches
comment|// The number of taken branches in a loop is hard to estimate here, and
comment|// benchmarking has revealed that it is better not to be conservative when
comment|// estimating the branch count. As a result, we'll ignore the branch limits
comment|// until someone finds a case where it matters in practice.
name|unsigned
name|MaxOps
decl_stmt|;
specifier|const
name|TargetSubtargetInfo
modifier|*
name|ST
init|=
name|getST
argument_list|()
decl_stmt|;
if|if
condition|(
name|PartialUnrollingThreshold
operator|.
name|getNumOccurrences
argument_list|()
operator|>
literal|0
condition|)
name|MaxOps
operator|=
name|PartialUnrollingThreshold
expr_stmt|;
elseif|else
if|if
condition|(
name|ST
operator|->
name|getSchedModel
argument_list|()
operator|.
name|LoopMicroOpBufferSize
operator|>
literal|0
condition|)
name|MaxOps
operator|=
name|ST
operator|->
name|getSchedModel
argument_list|()
operator|.
name|LoopMicroOpBufferSize
expr_stmt|;
else|else
return|return;
comment|// Scan the loop: don't unroll loops with calls.
for|for
control|(
name|Loop
operator|::
name|block_iterator
name|I
operator|=
name|L
operator|->
name|block_begin
argument_list|()
operator|,
name|E
operator|=
name|L
operator|->
name|block_end
argument_list|()
init|;
name|I
operator|!=
name|E
condition|;
operator|++
name|I
control|)
block|{
name|BasicBlock
modifier|*
name|BB
init|=
operator|*
name|I
decl_stmt|;
for|for
control|(
name|BasicBlock
operator|::
name|iterator
name|J
operator|=
name|BB
operator|->
name|begin
argument_list|()
operator|,
name|JE
operator|=
name|BB
operator|->
name|end
argument_list|()
init|;
name|J
operator|!=
name|JE
condition|;
operator|++
name|J
control|)
if|if
condition|(
name|isa
operator|<
name|CallInst
operator|>
operator|(
name|J
operator|)
operator|||
name|isa
operator|<
name|InvokeInst
operator|>
operator|(
name|J
operator|)
condition|)
block|{
name|ImmutableCallSite
name|CS
argument_list|(
operator|&
operator|*
name|J
argument_list|)
decl_stmt|;
if|if
condition|(
specifier|const
name|Function
modifier|*
name|F
init|=
name|CS
operator|.
name|getCalledFunction
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
name|static_cast
operator|<
name|T
operator|*
operator|>
operator|(
name|this
operator|)
operator|->
name|isLoweredToCall
argument_list|(
name|F
argument_list|)
condition|)
continue|continue;
block|}
return|return;
block|}
block|}
comment|// Enable runtime and partial unrolling up to the specified size.
comment|// Enable using trip count upper bound to unroll loops.
name|UP
operator|.
name|Partial
operator|=
name|UP
operator|.
name|Runtime
operator|=
name|UP
operator|.
name|UpperBound
operator|=
name|true
expr_stmt|;
name|UP
operator|.
name|PartialThreshold
operator|=
name|MaxOps
expr_stmt|;
comment|// Avoid unrolling when optimizing for size.
name|UP
operator|.
name|OptSizeThreshold
operator|=
literal|0
expr_stmt|;
name|UP
operator|.
name|PartialOptSizeThreshold
operator|=
literal|0
expr_stmt|;
comment|// Set number of instructions optimized when "back edge"
comment|// becomes "fall through" to default value of 2.
name|UP
operator|.
name|BEInsns
operator|=
literal|2
expr_stmt|;
block|}
comment|/// @}
comment|/// \name Vector TTI Implementations
comment|/// @{
name|unsigned
name|getNumberOfRegisters
parameter_list|(
name|bool
name|Vector
parameter_list|)
block|{
return|return
name|Vector
condition|?
literal|0
else|:
literal|1
return|;
block|}
name|unsigned
name|getRegisterBitWidth
parameter_list|(
name|bool
name|Vector
parameter_list|)
block|{
return|return
literal|32
return|;
block|}
comment|/// Estimate the overhead of scalarizing an instruction. Insert and Extract
comment|/// are set if the result needs to be inserted and/or extracted from vectors.
name|unsigned
name|getScalarizationOverhead
parameter_list|(
name|Type
modifier|*
name|Ty
parameter_list|,
name|bool
name|Insert
parameter_list|,
name|bool
name|Extract
parameter_list|)
block|{
name|assert
argument_list|(
name|Ty
operator|->
name|isVectorTy
argument_list|()
operator|&&
literal|"Can only scalarize vectors"
argument_list|)
expr_stmt|;
name|unsigned
name|Cost
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|,
name|e
init|=
name|Ty
operator|->
name|getVectorNumElements
argument_list|()
init|;
name|i
operator|<
name|e
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|Insert
condition|)
name|Cost
operator|+=
name|static_cast
operator|<
name|T
operator|*
operator|>
operator|(
name|this
operator|)
operator|->
name|getVectorInstrCost
argument_list|(
name|Instruction
operator|::
name|InsertElement
argument_list|,
name|Ty
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|Extract
condition|)
name|Cost
operator|+=
name|static_cast
operator|<
name|T
operator|*
operator|>
operator|(
name|this
operator|)
operator|->
name|getVectorInstrCost
argument_list|(
name|Instruction
operator|::
name|ExtractElement
argument_list|,
name|Ty
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
return|return
name|Cost
return|;
block|}
comment|/// Estimate the overhead of scalarizing an instructions unique
comment|/// non-constant operands. The types of the arguments are ordinarily
comment|/// scalar, in which case the costs are multiplied with VF.
name|unsigned
name|getOperandsScalarizationOverhead
argument_list|(
name|ArrayRef
operator|<
specifier|const
name|Value
operator|*
operator|>
name|Args
argument_list|,
name|unsigned
name|VF
argument_list|)
block|{
name|unsigned
name|Cost
init|=
literal|0
decl_stmt|;
name|SmallPtrSet
operator|<
specifier|const
name|Value
operator|*
operator|,
literal|4
operator|>
name|UniqueOperands
expr_stmt|;
for|for
control|(
specifier|const
name|Value
modifier|*
name|A
range|:
name|Args
control|)
block|{
if|if
condition|(
operator|!
name|isa
operator|<
name|Constant
operator|>
operator|(
name|A
operator|)
operator|&&
name|UniqueOperands
operator|.
name|insert
argument_list|(
name|A
argument_list|)
operator|.
name|second
condition|)
block|{
name|Type
modifier|*
name|VecTy
init|=
name|nullptr
decl_stmt|;
if|if
condition|(
name|A
operator|->
name|getType
argument_list|()
operator|->
name|isVectorTy
argument_list|()
condition|)
block|{
name|VecTy
operator|=
name|A
operator|->
name|getType
argument_list|()
expr_stmt|;
comment|// If A is a vector operand, VF should be 1 or correspond to A.
name|assert
argument_list|(
operator|(
name|VF
operator|==
literal|1
operator|||
name|VF
operator|==
name|VecTy
operator|->
name|getVectorNumElements
argument_list|()
operator|)
operator|&&
literal|"Vector argument does not match VF"
argument_list|)
expr_stmt|;
block|}
else|else
name|VecTy
operator|=
name|VectorType
operator|::
name|get
argument_list|(
name|A
operator|->
name|getType
argument_list|()
argument_list|,
name|VF
argument_list|)
expr_stmt|;
name|Cost
operator|+=
name|getScalarizationOverhead
argument_list|(
name|VecTy
argument_list|,
name|false
argument_list|,
name|true
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|Cost
return|;
block|}
name|unsigned
name|getScalarizationOverhead
argument_list|(
name|Type
operator|*
name|VecTy
argument_list|,
name|ArrayRef
operator|<
specifier|const
name|Value
operator|*
operator|>
name|Args
argument_list|)
block|{
name|assert
argument_list|(
name|VecTy
operator|->
name|isVectorTy
argument_list|()
argument_list|)
expr_stmt|;
name|unsigned
name|Cost
init|=
literal|0
decl_stmt|;
name|Cost
operator|+=
name|getScalarizationOverhead
argument_list|(
name|VecTy
argument_list|,
name|true
argument_list|,
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|Args
operator|.
name|empty
argument_list|()
condition|)
name|Cost
operator|+=
name|getOperandsScalarizationOverhead
argument_list|(
name|Args
argument_list|,
name|VecTy
operator|->
name|getVectorNumElements
argument_list|()
argument_list|)
expr_stmt|;
else|else
comment|// When no information on arguments is provided, we add the cost
comment|// associated with one argument as a heuristic.
name|Cost
operator|+=
name|getScalarizationOverhead
argument_list|(
name|VecTy
argument_list|,
name|false
argument_list|,
name|true
argument_list|)
expr_stmt|;
return|return
name|Cost
return|;
block|}
name|unsigned
name|getMaxInterleaveFactor
parameter_list|(
name|unsigned
name|VF
parameter_list|)
block|{
return|return
literal|1
return|;
block|}
name|unsigned
name|getArithmeticInstrCost
argument_list|(
name|unsigned
name|Opcode
argument_list|,
name|Type
operator|*
name|Ty
argument_list|,
name|TTI
operator|::
name|OperandValueKind
name|Opd1Info
operator|=
name|TTI
operator|::
name|OK_AnyValue
argument_list|,
name|TTI
operator|::
name|OperandValueKind
name|Opd2Info
operator|=
name|TTI
operator|::
name|OK_AnyValue
argument_list|,
name|TTI
operator|::
name|OperandValueProperties
name|Opd1PropInfo
operator|=
name|TTI
operator|::
name|OP_None
argument_list|,
name|TTI
operator|::
name|OperandValueProperties
name|Opd2PropInfo
operator|=
name|TTI
operator|::
name|OP_None
argument_list|,
name|ArrayRef
operator|<
specifier|const
name|Value
operator|*
operator|>
name|Args
operator|=
name|ArrayRef
operator|<
specifier|const
name|Value
operator|*
operator|>
operator|(
operator|)
argument_list|)
block|{
comment|// Check if any of the operands are vector operands.
specifier|const
name|TargetLoweringBase
modifier|*
name|TLI
init|=
name|getTLI
argument_list|()
decl_stmt|;
name|int
name|ISD
init|=
name|TLI
operator|->
name|InstructionOpcodeToISD
argument_list|(
name|Opcode
argument_list|)
decl_stmt|;
name|assert
argument_list|(
name|ISD
operator|&&
literal|"Invalid opcode"
argument_list|)
expr_stmt|;
name|std
operator|::
name|pair
operator|<
name|unsigned
operator|,
name|MVT
operator|>
name|LT
operator|=
name|TLI
operator|->
name|getTypeLegalizationCost
argument_list|(
name|DL
argument_list|,
name|Ty
argument_list|)
expr_stmt|;
name|bool
name|IsFloat
init|=
name|Ty
operator|->
name|getScalarType
argument_list|()
operator|->
name|isFloatingPointTy
argument_list|()
decl_stmt|;
comment|// Assume that floating point arithmetic operations cost twice as much as
comment|// integer operations.
name|unsigned
name|OpCost
init|=
operator|(
name|IsFloat
condition|?
literal|2
else|:
literal|1
operator|)
decl_stmt|;
if|if
condition|(
name|TLI
operator|->
name|isOperationLegalOrPromote
argument_list|(
name|ISD
argument_list|,
name|LT
operator|.
name|second
argument_list|)
condition|)
block|{
comment|// The operation is legal. Assume it costs 1.
comment|// TODO: Once we have extract/insert subvector cost we need to use them.
return|return
name|LT
operator|.
name|first
operator|*
name|OpCost
return|;
block|}
if|if
condition|(
operator|!
name|TLI
operator|->
name|isOperationExpand
argument_list|(
name|ISD
argument_list|,
name|LT
operator|.
name|second
argument_list|)
condition|)
block|{
comment|// If the operation is custom lowered, then assume that the code is twice
comment|// as expensive.
return|return
name|LT
operator|.
name|first
operator|*
literal|2
operator|*
name|OpCost
return|;
block|}
comment|// Else, assume that we need to scalarize this op.
comment|// TODO: If one of the types get legalized by splitting, handle this
comment|// similarly to what getCastInstrCost() does.
if|if
condition|(
name|Ty
operator|->
name|isVectorTy
argument_list|()
condition|)
block|{
name|unsigned
name|Num
init|=
name|Ty
operator|->
name|getVectorNumElements
argument_list|()
decl_stmt|;
name|unsigned
name|Cost
init|=
name|static_cast
operator|<
name|T
operator|*
operator|>
operator|(
name|this
operator|)
operator|->
name|getArithmeticInstrCost
argument_list|(
name|Opcode
argument_list|,
name|Ty
operator|->
name|getScalarType
argument_list|()
argument_list|)
decl_stmt|;
comment|// Return the cost of multiple scalar invocation plus the cost of
comment|// inserting and extracting the values.
return|return
name|getScalarizationOverhead
argument_list|(
name|Ty
argument_list|,
name|Args
argument_list|)
operator|+
name|Num
operator|*
name|Cost
return|;
block|}
comment|// We don't know anything about this scalar instruction.
return|return
name|OpCost
return|;
block|}
name|unsigned
name|getShuffleCost
argument_list|(
name|TTI
operator|::
name|ShuffleKind
name|Kind
argument_list|,
name|Type
operator|*
name|Tp
argument_list|,
name|int
name|Index
argument_list|,
name|Type
operator|*
name|SubTp
argument_list|)
block|{
if|if
condition|(
name|Kind
operator|==
name|TTI
operator|::
name|SK_Alternate
operator|||
name|Kind
operator|==
name|TTI
operator|::
name|SK_PermuteTwoSrc
operator|||
name|Kind
operator|==
name|TTI
operator|::
name|SK_PermuteSingleSrc
condition|)
block|{
return|return
name|getPermuteShuffleOverhead
argument_list|(
name|Tp
argument_list|)
return|;
block|}
return|return
literal|1
return|;
block|}
name|unsigned
name|getCastInstrCost
parameter_list|(
name|unsigned
name|Opcode
parameter_list|,
name|Type
modifier|*
name|Dst
parameter_list|,
name|Type
modifier|*
name|Src
parameter_list|,
specifier|const
name|Instruction
modifier|*
name|I
init|=
name|nullptr
parameter_list|)
block|{
specifier|const
name|TargetLoweringBase
modifier|*
name|TLI
init|=
name|getTLI
argument_list|()
decl_stmt|;
name|int
name|ISD
init|=
name|TLI
operator|->
name|InstructionOpcodeToISD
argument_list|(
name|Opcode
argument_list|)
decl_stmt|;
name|assert
argument_list|(
name|ISD
operator|&&
literal|"Invalid opcode"
argument_list|)
expr_stmt|;
name|std
operator|::
name|pair
operator|<
name|unsigned
operator|,
name|MVT
operator|>
name|SrcLT
operator|=
name|TLI
operator|->
name|getTypeLegalizationCost
argument_list|(
name|DL
argument_list|,
name|Src
argument_list|)
expr_stmt|;
name|std
operator|::
name|pair
operator|<
name|unsigned
operator|,
name|MVT
operator|>
name|DstLT
operator|=
name|TLI
operator|->
name|getTypeLegalizationCost
argument_list|(
name|DL
argument_list|,
name|Dst
argument_list|)
expr_stmt|;
comment|// Check for NOOP conversions.
if|if
condition|(
name|SrcLT
operator|.
name|first
operator|==
name|DstLT
operator|.
name|first
operator|&&
name|SrcLT
operator|.
name|second
operator|.
name|getSizeInBits
argument_list|()
operator|==
name|DstLT
operator|.
name|second
operator|.
name|getSizeInBits
argument_list|()
condition|)
block|{
comment|// Bitcast between types that are legalized to the same type are free.
if|if
condition|(
name|Opcode
operator|==
name|Instruction
operator|::
name|BitCast
operator|||
name|Opcode
operator|==
name|Instruction
operator|::
name|Trunc
condition|)
return|return
literal|0
return|;
block|}
if|if
condition|(
name|Opcode
operator|==
name|Instruction
operator|::
name|Trunc
operator|&&
name|TLI
operator|->
name|isTruncateFree
argument_list|(
name|SrcLT
operator|.
name|second
argument_list|,
name|DstLT
operator|.
name|second
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|Opcode
operator|==
name|Instruction
operator|::
name|ZExt
operator|&&
name|TLI
operator|->
name|isZExtFree
argument_list|(
name|SrcLT
operator|.
name|second
argument_list|,
name|DstLT
operator|.
name|second
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|Opcode
operator|==
name|Instruction
operator|::
name|AddrSpaceCast
operator|&&
name|TLI
operator|->
name|isNoopAddrSpaceCast
argument_list|(
name|Src
operator|->
name|getPointerAddressSpace
argument_list|()
argument_list|,
name|Dst
operator|->
name|getPointerAddressSpace
argument_list|()
argument_list|)
condition|)
return|return
literal|0
return|;
comment|// If this is a zext/sext of a load, return 0 if the corresponding
comment|// extending load exists on target.
if|if
condition|(
operator|(
name|Opcode
operator|==
name|Instruction
operator|::
name|ZExt
operator|||
name|Opcode
operator|==
name|Instruction
operator|::
name|SExt
operator|)
operator|&&
name|I
operator|&&
name|isa
operator|<
name|LoadInst
operator|>
operator|(
name|I
operator|->
name|getOperand
argument_list|(
literal|0
argument_list|)
operator|)
condition|)
block|{
name|EVT
name|ExtVT
init|=
name|EVT
operator|::
name|getEVT
argument_list|(
name|Dst
argument_list|)
decl_stmt|;
name|EVT
name|LoadVT
init|=
name|EVT
operator|::
name|getEVT
argument_list|(
name|Src
argument_list|)
decl_stmt|;
name|unsigned
name|LType
init|=
operator|(
operator|(
name|Opcode
operator|==
name|Instruction
operator|::
name|ZExt
operator|)
condition|?
name|ISD
operator|::
name|ZEXTLOAD
else|:
name|ISD
operator|::
name|SEXTLOAD
operator|)
decl_stmt|;
if|if
condition|(
name|TLI
operator|->
name|isLoadExtLegal
argument_list|(
name|LType
argument_list|,
name|ExtVT
argument_list|,
name|LoadVT
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
comment|// If the cast is marked as legal (or promote) then assume low cost.
if|if
condition|(
name|SrcLT
operator|.
name|first
operator|==
name|DstLT
operator|.
name|first
operator|&&
name|TLI
operator|->
name|isOperationLegalOrPromote
argument_list|(
name|ISD
argument_list|,
name|DstLT
operator|.
name|second
argument_list|)
condition|)
return|return
literal|1
return|;
comment|// Handle scalar conversions.
if|if
condition|(
operator|!
name|Src
operator|->
name|isVectorTy
argument_list|()
operator|&&
operator|!
name|Dst
operator|->
name|isVectorTy
argument_list|()
condition|)
block|{
comment|// Scalar bitcasts are usually free.
if|if
condition|(
name|Opcode
operator|==
name|Instruction
operator|::
name|BitCast
condition|)
return|return
literal|0
return|;
comment|// Just check the op cost. If the operation is legal then assume it costs
comment|// 1.
if|if
condition|(
operator|!
name|TLI
operator|->
name|isOperationExpand
argument_list|(
name|ISD
argument_list|,
name|DstLT
operator|.
name|second
argument_list|)
condition|)
return|return
literal|1
return|;
comment|// Assume that illegal scalar instruction are expensive.
return|return
literal|4
return|;
block|}
comment|// Check vector-to-vector casts.
if|if
condition|(
name|Dst
operator|->
name|isVectorTy
argument_list|()
operator|&&
name|Src
operator|->
name|isVectorTy
argument_list|()
condition|)
block|{
comment|// If the cast is between same-sized registers, then the check is simple.
if|if
condition|(
name|SrcLT
operator|.
name|first
operator|==
name|DstLT
operator|.
name|first
operator|&&
name|SrcLT
operator|.
name|second
operator|.
name|getSizeInBits
argument_list|()
operator|==
name|DstLT
operator|.
name|second
operator|.
name|getSizeInBits
argument_list|()
condition|)
block|{
comment|// Assume that Zext is done using AND.
if|if
condition|(
name|Opcode
operator|==
name|Instruction
operator|::
name|ZExt
condition|)
return|return
literal|1
return|;
comment|// Assume that sext is done using SHL and SRA.
if|if
condition|(
name|Opcode
operator|==
name|Instruction
operator|::
name|SExt
condition|)
return|return
literal|2
return|;
comment|// Just check the op cost. If the operation is legal then assume it
comment|// costs
comment|// 1 and multiply by the type-legalization overhead.
if|if
condition|(
operator|!
name|TLI
operator|->
name|isOperationExpand
argument_list|(
name|ISD
argument_list|,
name|DstLT
operator|.
name|second
argument_list|)
condition|)
return|return
name|SrcLT
operator|.
name|first
operator|*
literal|1
return|;
block|}
comment|// If we are legalizing by splitting, query the concrete TTI for the cost
comment|// of casting the original vector twice. We also need to factor int the
comment|// cost of the split itself. Count that as 1, to be consistent with
comment|// TLI->getTypeLegalizationCost().
if|if
condition|(
operator|(
name|TLI
operator|->
name|getTypeAction
argument_list|(
name|Src
operator|->
name|getContext
argument_list|()
argument_list|,
name|TLI
operator|->
name|getValueType
argument_list|(
name|DL
argument_list|,
name|Src
argument_list|)
argument_list|)
operator|==
name|TargetLowering
operator|::
name|TypeSplitVector
operator|)
operator|||
operator|(
name|TLI
operator|->
name|getTypeAction
argument_list|(
name|Dst
operator|->
name|getContext
argument_list|()
argument_list|,
name|TLI
operator|->
name|getValueType
argument_list|(
name|DL
argument_list|,
name|Dst
argument_list|)
argument_list|)
operator|==
name|TargetLowering
operator|::
name|TypeSplitVector
operator|)
condition|)
block|{
name|Type
modifier|*
name|SplitDst
init|=
name|VectorType
operator|::
name|get
argument_list|(
name|Dst
operator|->
name|getVectorElementType
argument_list|()
argument_list|,
name|Dst
operator|->
name|getVectorNumElements
argument_list|()
operator|/
literal|2
argument_list|)
decl_stmt|;
name|Type
modifier|*
name|SplitSrc
init|=
name|VectorType
operator|::
name|get
argument_list|(
name|Src
operator|->
name|getVectorElementType
argument_list|()
argument_list|,
name|Src
operator|->
name|getVectorNumElements
argument_list|()
operator|/
literal|2
argument_list|)
decl_stmt|;
name|T
modifier|*
name|TTI
init|=
name|static_cast
operator|<
name|T
operator|*
operator|>
operator|(
name|this
operator|)
decl_stmt|;
return|return
name|TTI
operator|->
name|getVectorSplitCost
argument_list|()
operator|+
operator|(
literal|2
operator|*
name|TTI
operator|->
name|getCastInstrCost
argument_list|(
name|Opcode
argument_list|,
name|SplitDst
argument_list|,
name|SplitSrc
argument_list|,
name|I
argument_list|)
operator|)
return|;
block|}
comment|// In other cases where the source or destination are illegal, assume
comment|// the operation will get scalarized.
name|unsigned
name|Num
init|=
name|Dst
operator|->
name|getVectorNumElements
argument_list|()
decl_stmt|;
name|unsigned
name|Cost
init|=
name|static_cast
operator|<
name|T
operator|*
operator|>
operator|(
name|this
operator|)
operator|->
name|getCastInstrCost
argument_list|(
name|Opcode
argument_list|,
name|Dst
operator|->
name|getScalarType
argument_list|()
argument_list|,
name|Src
operator|->
name|getScalarType
argument_list|()
argument_list|,
name|I
argument_list|)
decl_stmt|;
comment|// Return the cost of multiple scalar invocation plus the cost of
comment|// inserting and extracting the values.
return|return
name|getScalarizationOverhead
argument_list|(
name|Dst
argument_list|,
name|true
argument_list|,
name|true
argument_list|)
operator|+
name|Num
operator|*
name|Cost
return|;
block|}
comment|// We already handled vector-to-vector and scalar-to-scalar conversions.
comment|// This
comment|// is where we handle bitcast between vectors and scalars. We need to assume
comment|//  that the conversion is scalarized in one way or another.
if|if
condition|(
name|Opcode
operator|==
name|Instruction
operator|::
name|BitCast
condition|)
comment|// Illegal bitcasts are done by storing and loading from a stack slot.
return|return
operator|(
name|Src
operator|->
name|isVectorTy
argument_list|()
condition|?
name|getScalarizationOverhead
argument_list|(
name|Src
argument_list|,
name|false
argument_list|,
name|true
argument_list|)
else|:
literal|0
operator|)
operator|+
operator|(
name|Dst
operator|->
name|isVectorTy
argument_list|()
condition|?
name|getScalarizationOverhead
argument_list|(
name|Dst
argument_list|,
name|true
argument_list|,
name|false
argument_list|)
else|:
literal|0
operator|)
return|;
name|llvm_unreachable
argument_list|(
literal|"Unhandled cast"
argument_list|)
expr_stmt|;
block|}
name|unsigned
name|getExtractWithExtendCost
parameter_list|(
name|unsigned
name|Opcode
parameter_list|,
name|Type
modifier|*
name|Dst
parameter_list|,
name|VectorType
modifier|*
name|VecTy
parameter_list|,
name|unsigned
name|Index
parameter_list|)
block|{
return|return
name|static_cast
operator|<
name|T
operator|*
operator|>
operator|(
name|this
operator|)
operator|->
name|getVectorInstrCost
argument_list|(
name|Instruction
operator|::
name|ExtractElement
argument_list|,
name|VecTy
argument_list|,
name|Index
argument_list|)
operator|+
name|static_cast
operator|<
name|T
operator|*
operator|>
operator|(
name|this
operator|)
operator|->
name|getCastInstrCost
argument_list|(
name|Opcode
argument_list|,
name|Dst
argument_list|,
name|VecTy
operator|->
name|getElementType
argument_list|()
argument_list|)
return|;
block|}
name|unsigned
name|getCFInstrCost
parameter_list|(
name|unsigned
name|Opcode
parameter_list|)
block|{
comment|// Branches are assumed to be predicted.
return|return
literal|0
return|;
block|}
name|unsigned
name|getCmpSelInstrCost
parameter_list|(
name|unsigned
name|Opcode
parameter_list|,
name|Type
modifier|*
name|ValTy
parameter_list|,
name|Type
modifier|*
name|CondTy
parameter_list|,
specifier|const
name|Instruction
modifier|*
name|I
parameter_list|)
block|{
specifier|const
name|TargetLoweringBase
modifier|*
name|TLI
init|=
name|getTLI
argument_list|()
decl_stmt|;
name|int
name|ISD
init|=
name|TLI
operator|->
name|InstructionOpcodeToISD
argument_list|(
name|Opcode
argument_list|)
decl_stmt|;
name|assert
argument_list|(
name|ISD
operator|&&
literal|"Invalid opcode"
argument_list|)
expr_stmt|;
comment|// Selects on vectors are actually vector selects.
if|if
condition|(
name|ISD
operator|==
name|ISD
operator|::
name|SELECT
condition|)
block|{
name|assert
argument_list|(
name|CondTy
operator|&&
literal|"CondTy must exist"
argument_list|)
expr_stmt|;
if|if
condition|(
name|CondTy
operator|->
name|isVectorTy
argument_list|()
condition|)
name|ISD
operator|=
name|ISD
operator|::
name|VSELECT
expr_stmt|;
block|}
name|std
operator|::
name|pair
operator|<
name|unsigned
operator|,
name|MVT
operator|>
name|LT
operator|=
name|TLI
operator|->
name|getTypeLegalizationCost
argument_list|(
name|DL
argument_list|,
name|ValTy
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|ValTy
operator|->
name|isVectorTy
argument_list|()
operator|&&
operator|!
name|LT
operator|.
name|second
operator|.
name|isVector
argument_list|()
operator|)
operator|&&
operator|!
name|TLI
operator|->
name|isOperationExpand
argument_list|(
name|ISD
argument_list|,
name|LT
operator|.
name|second
argument_list|)
condition|)
block|{
comment|// The operation is legal. Assume it costs 1. Multiply
comment|// by the type-legalization overhead.
return|return
name|LT
operator|.
name|first
operator|*
literal|1
return|;
block|}
comment|// Otherwise, assume that the cast is scalarized.
comment|// TODO: If one of the types get legalized by splitting, handle this
comment|// similarly to what getCastInstrCost() does.
if|if
condition|(
name|ValTy
operator|->
name|isVectorTy
argument_list|()
condition|)
block|{
name|unsigned
name|Num
init|=
name|ValTy
operator|->
name|getVectorNumElements
argument_list|()
decl_stmt|;
if|if
condition|(
name|CondTy
condition|)
name|CondTy
operator|=
name|CondTy
operator|->
name|getScalarType
argument_list|()
expr_stmt|;
name|unsigned
name|Cost
init|=
name|static_cast
operator|<
name|T
operator|*
operator|>
operator|(
name|this
operator|)
operator|->
name|getCmpSelInstrCost
argument_list|(
name|Opcode
argument_list|,
name|ValTy
operator|->
name|getScalarType
argument_list|()
argument_list|,
name|CondTy
argument_list|,
name|I
argument_list|)
decl_stmt|;
comment|// Return the cost of multiple scalar invocation plus the cost of
comment|// inserting and extracting the values.
return|return
name|getScalarizationOverhead
argument_list|(
name|ValTy
argument_list|,
name|true
argument_list|,
name|false
argument_list|)
operator|+
name|Num
operator|*
name|Cost
return|;
block|}
comment|// Unknown scalar opcode.
return|return
literal|1
return|;
block|}
name|unsigned
name|getVectorInstrCost
parameter_list|(
name|unsigned
name|Opcode
parameter_list|,
name|Type
modifier|*
name|Val
parameter_list|,
name|unsigned
name|Index
parameter_list|)
block|{
name|std
operator|::
name|pair
operator|<
name|unsigned
operator|,
name|MVT
operator|>
name|LT
operator|=
name|getTLI
argument_list|()
operator|->
name|getTypeLegalizationCost
argument_list|(
name|DL
argument_list|,
name|Val
operator|->
name|getScalarType
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|LT
operator|.
name|first
return|;
block|}
name|unsigned
name|getMemoryOpCost
parameter_list|(
name|unsigned
name|Opcode
parameter_list|,
name|Type
modifier|*
name|Src
parameter_list|,
name|unsigned
name|Alignment
parameter_list|,
name|unsigned
name|AddressSpace
parameter_list|,
specifier|const
name|Instruction
modifier|*
name|I
init|=
name|nullptr
parameter_list|)
block|{
name|assert
argument_list|(
operator|!
name|Src
operator|->
name|isVoidTy
argument_list|()
operator|&&
literal|"Invalid type"
argument_list|)
expr_stmt|;
name|std
operator|::
name|pair
operator|<
name|unsigned
operator|,
name|MVT
operator|>
name|LT
operator|=
name|getTLI
argument_list|()
operator|->
name|getTypeLegalizationCost
argument_list|(
name|DL
argument_list|,
name|Src
argument_list|)
expr_stmt|;
comment|// Assuming that all loads of legal types cost 1.
name|unsigned
name|Cost
init|=
name|LT
operator|.
name|first
decl_stmt|;
if|if
condition|(
name|Src
operator|->
name|isVectorTy
argument_list|()
operator|&&
name|Src
operator|->
name|getPrimitiveSizeInBits
argument_list|()
operator|<
name|LT
operator|.
name|second
operator|.
name|getSizeInBits
argument_list|()
condition|)
block|{
comment|// This is a vector load that legalizes to a larger type than the vector
comment|// itself. Unless the corresponding extending load or truncating store is
comment|// legal, then this will scalarize.
name|TargetLowering
operator|::
name|LegalizeAction
name|LA
operator|=
name|TargetLowering
operator|::
name|Expand
expr_stmt|;
name|EVT
name|MemVT
init|=
name|getTLI
argument_list|()
operator|->
name|getValueType
argument_list|(
name|DL
argument_list|,
name|Src
argument_list|)
decl_stmt|;
if|if
condition|(
name|Opcode
operator|==
name|Instruction
operator|::
name|Store
condition|)
name|LA
operator|=
name|getTLI
argument_list|()
operator|->
name|getTruncStoreAction
argument_list|(
name|LT
operator|.
name|second
argument_list|,
name|MemVT
argument_list|)
expr_stmt|;
else|else
name|LA
operator|=
name|getTLI
argument_list|()
operator|->
name|getLoadExtAction
argument_list|(
name|ISD
operator|::
name|EXTLOAD
argument_list|,
name|LT
operator|.
name|second
argument_list|,
name|MemVT
argument_list|)
expr_stmt|;
if|if
condition|(
name|LA
operator|!=
name|TargetLowering
operator|::
name|Legal
operator|&&
name|LA
operator|!=
name|TargetLowering
operator|::
name|Custom
condition|)
block|{
comment|// This is a vector load/store for some illegal type that is scalarized.
comment|// We must account for the cost of building or decomposing the vector.
name|Cost
operator|+=
name|getScalarizationOverhead
argument_list|(
name|Src
argument_list|,
name|Opcode
operator|!=
name|Instruction
operator|::
name|Store
argument_list|,
name|Opcode
operator|==
name|Instruction
operator|::
name|Store
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|Cost
return|;
block|}
name|unsigned
name|getInterleavedMemoryOpCost
argument_list|(
name|unsigned
name|Opcode
argument_list|,
name|Type
operator|*
name|VecTy
argument_list|,
name|unsigned
name|Factor
argument_list|,
name|ArrayRef
operator|<
name|unsigned
operator|>
name|Indices
argument_list|,
name|unsigned
name|Alignment
argument_list|,
name|unsigned
name|AddressSpace
argument_list|)
block|{
name|VectorType
modifier|*
name|VT
init|=
name|dyn_cast
operator|<
name|VectorType
operator|>
operator|(
name|VecTy
operator|)
decl_stmt|;
name|assert
argument_list|(
name|VT
operator|&&
literal|"Expect a vector type for interleaved memory op"
argument_list|)
expr_stmt|;
name|unsigned
name|NumElts
init|=
name|VT
operator|->
name|getNumElements
argument_list|()
decl_stmt|;
name|assert
argument_list|(
name|Factor
operator|>
literal|1
operator|&&
name|NumElts
operator|%
name|Factor
operator|==
literal|0
operator|&&
literal|"Invalid interleave factor"
argument_list|)
expr_stmt|;
name|unsigned
name|NumSubElts
init|=
name|NumElts
operator|/
name|Factor
decl_stmt|;
name|VectorType
modifier|*
name|SubVT
init|=
name|VectorType
operator|::
name|get
argument_list|(
name|VT
operator|->
name|getElementType
argument_list|()
argument_list|,
name|NumSubElts
argument_list|)
decl_stmt|;
comment|// Firstly, the cost of load/store operation.
name|unsigned
name|Cost
init|=
name|static_cast
operator|<
name|T
operator|*
operator|>
operator|(
name|this
operator|)
operator|->
name|getMemoryOpCost
argument_list|(
name|Opcode
argument_list|,
name|VecTy
argument_list|,
name|Alignment
argument_list|,
name|AddressSpace
argument_list|)
decl_stmt|;
comment|// Legalize the vector type, and get the legalized and unlegalized type
comment|// sizes.
name|MVT
name|VecTyLT
init|=
name|getTLI
argument_list|()
operator|->
name|getTypeLegalizationCost
argument_list|(
name|DL
argument_list|,
name|VecTy
argument_list|)
operator|.
name|second
decl_stmt|;
name|unsigned
name|VecTySize
init|=
name|static_cast
operator|<
name|T
operator|*
operator|>
operator|(
name|this
operator|)
operator|->
name|getDataLayout
argument_list|()
operator|.
name|getTypeStoreSize
argument_list|(
name|VecTy
argument_list|)
decl_stmt|;
name|unsigned
name|VecTyLTSize
init|=
name|VecTyLT
operator|.
name|getStoreSize
argument_list|()
decl_stmt|;
comment|// Return the ceiling of dividing A by B.
name|auto
name|ceil
init|=
index|[]
operator|(
name|unsigned
name|A
expr|,
name|unsigned
name|B
operator|)
block|{
return|return
operator|(
name|A
operator|+
name|B
operator|-
literal|1
operator|)
operator|/
name|B
return|;
block|}
empty_stmt|;
comment|// Scale the cost of the memory operation by the fraction of legalized
comment|// instructions that will actually be used. We shouldn't account for the
comment|// cost of dead instructions since they will be removed.
comment|//
comment|// E.g., An interleaved load of factor 8:
comment|//       %vec = load<16 x i64>,<16 x i64>* %ptr
comment|//       %v0 = shufflevector %vec, undef,<0, 8>
comment|//
comment|// If<16 x i64> is legalized to 8 v2i64 loads, only 2 of the loads will be
comment|// used (those corresponding to elements [0:1] and [8:9] of the unlegalized
comment|// type). The other loads are unused.
comment|//
comment|// We only scale the cost of loads since interleaved store groups aren't
comment|// allowed to have gaps.
if|if
condition|(
name|Opcode
operator|==
name|Instruction
operator|::
name|Load
operator|&&
name|VecTySize
operator|>
name|VecTyLTSize
condition|)
block|{
comment|// The number of loads of a legal type it will take to represent a load
comment|// of the unlegalized vector type.
name|unsigned
name|NumLegalInsts
init|=
name|ceil
argument_list|(
name|VecTySize
argument_list|,
name|VecTyLTSize
argument_list|)
decl_stmt|;
comment|// The number of elements of the unlegalized type that correspond to a
comment|// single legal instruction.
name|unsigned
name|NumEltsPerLegalInst
init|=
name|ceil
argument_list|(
name|NumElts
argument_list|,
name|NumLegalInsts
argument_list|)
decl_stmt|;
comment|// Determine which legal instructions will be used.
name|BitVector
name|UsedInsts
parameter_list|(
name|NumLegalInsts
parameter_list|,
name|false
parameter_list|)
function_decl|;
for|for
control|(
name|unsigned
name|Index
range|:
name|Indices
control|)
for|for
control|(
name|unsigned
name|Elt
init|=
literal|0
init|;
name|Elt
operator|<
name|NumSubElts
condition|;
operator|++
name|Elt
control|)
name|UsedInsts
operator|.
name|set
argument_list|(
operator|(
name|Index
operator|+
name|Elt
operator|*
name|Factor
operator|)
operator|/
name|NumEltsPerLegalInst
argument_list|)
expr_stmt|;
comment|// Scale the cost of the load by the fraction of legal instructions that
comment|// will be used.
name|Cost
operator|*=
name|UsedInsts
operator|.
name|count
argument_list|()
operator|/
name|NumLegalInsts
expr_stmt|;
block|}
comment|// Then plus the cost of interleave operation.
if|if
condition|(
name|Opcode
operator|==
name|Instruction
operator|::
name|Load
condition|)
block|{
comment|// The interleave cost is similar to extract sub vectors' elements
comment|// from the wide vector, and insert them into sub vectors.
comment|//
comment|// E.g. An interleaved load of factor 2 (with one member of index 0):
comment|//      %vec = load<8 x i32>,<8 x i32>* %ptr
comment|//      %v0 = shuffle %vec, undef,<0, 2, 4, 6>         ; Index 0
comment|// The cost is estimated as extract elements at 0, 2, 4, 6 from the
comment|//<8 x i32> vector and insert them into a<4 x i32> vector.
name|assert
argument_list|(
name|Indices
operator|.
name|size
argument_list|()
operator|<=
name|Factor
operator|&&
literal|"Interleaved memory op has too many members"
argument_list|)
expr_stmt|;
for|for
control|(
name|unsigned
name|Index
range|:
name|Indices
control|)
block|{
name|assert
argument_list|(
name|Index
operator|<
name|Factor
operator|&&
literal|"Invalid index for interleaved memory op"
argument_list|)
expr_stmt|;
comment|// Extract elements from loaded vector for each sub vector.
for|for
control|(
name|unsigned
name|i
init|=
literal|0
init|;
name|i
operator|<
name|NumSubElts
condition|;
name|i
operator|++
control|)
name|Cost
operator|+=
name|static_cast
operator|<
name|T
operator|*
operator|>
operator|(
name|this
operator|)
operator|->
name|getVectorInstrCost
argument_list|(
name|Instruction
operator|::
name|ExtractElement
argument_list|,
name|VT
argument_list|,
name|Index
operator|+
name|i
operator|*
name|Factor
argument_list|)
expr_stmt|;
block|}
name|unsigned
name|InsSubCost
init|=
literal|0
decl_stmt|;
for|for
control|(
name|unsigned
name|i
init|=
literal|0
init|;
name|i
operator|<
name|NumSubElts
condition|;
name|i
operator|++
control|)
name|InsSubCost
operator|+=
name|static_cast
operator|<
name|T
operator|*
operator|>
operator|(
name|this
operator|)
operator|->
name|getVectorInstrCost
argument_list|(
name|Instruction
operator|::
name|InsertElement
argument_list|,
name|SubVT
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|Cost
operator|+=
name|Indices
operator|.
name|size
argument_list|()
operator|*
name|InsSubCost
expr_stmt|;
block|}
else|else
block|{
comment|// The interleave cost is extract all elements from sub vectors, and
comment|// insert them into the wide vector.
comment|//
comment|// E.g. An interleaved store of factor 2:
comment|//      %v0_v1 = shuffle %v0, %v1,<0, 4, 1, 5, 2, 6, 3, 7>
comment|//      store<8 x i32> %interleaved.vec,<8 x i32>* %ptr
comment|// The cost is estimated as extract all elements from both<4 x i32>
comment|// vectors and insert into the<8 x i32> vector.
name|unsigned
name|ExtSubCost
init|=
literal|0
decl_stmt|;
for|for
control|(
name|unsigned
name|i
init|=
literal|0
init|;
name|i
operator|<
name|NumSubElts
condition|;
name|i
operator|++
control|)
name|ExtSubCost
operator|+=
name|static_cast
operator|<
name|T
operator|*
operator|>
operator|(
name|this
operator|)
operator|->
name|getVectorInstrCost
argument_list|(
name|Instruction
operator|::
name|ExtractElement
argument_list|,
name|SubVT
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|Cost
operator|+=
name|ExtSubCost
operator|*
name|Factor
expr_stmt|;
for|for
control|(
name|unsigned
name|i
init|=
literal|0
init|;
name|i
operator|<
name|NumElts
condition|;
name|i
operator|++
control|)
name|Cost
operator|+=
name|static_cast
operator|<
name|T
operator|*
operator|>
operator|(
name|this
operator|)
operator|->
name|getVectorInstrCost
argument_list|(
name|Instruction
operator|::
name|InsertElement
argument_list|,
name|VT
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
return|return
name|Cost
return|;
block|}
comment|/// Get intrinsic cost based on arguments.
name|unsigned
name|getIntrinsicInstrCost
argument_list|(
name|Intrinsic
operator|::
name|ID
name|IID
argument_list|,
name|Type
operator|*
name|RetTy
argument_list|,
name|ArrayRef
operator|<
name|Value
operator|*
operator|>
name|Args
argument_list|,
name|FastMathFlags
name|FMF
argument_list|,
name|unsigned
name|VF
operator|=
literal|1
argument_list|)
block|{
name|unsigned
name|RetVF
init|=
operator|(
name|RetTy
operator|->
name|isVectorTy
argument_list|()
condition|?
name|RetTy
operator|->
name|getVectorNumElements
argument_list|()
else|:
literal|1
operator|)
decl_stmt|;
name|assert
argument_list|(
operator|(
name|RetVF
operator|==
literal|1
operator|||
name|VF
operator|==
literal|1
operator|)
operator|&&
literal|"VF> 1 and RetVF is a vector type"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|IID
condition|)
block|{
default|default:
block|{
comment|// Assume that we need to scalarize this intrinsic.
name|SmallVector
operator|<
name|Type
operator|*
operator|,
literal|4
operator|>
name|Types
expr_stmt|;
for|for
control|(
name|Value
modifier|*
name|Op
range|:
name|Args
control|)
block|{
name|Type
modifier|*
name|OpTy
init|=
name|Op
operator|->
name|getType
argument_list|()
decl_stmt|;
name|assert
argument_list|(
name|VF
operator|==
literal|1
operator|||
operator|!
name|OpTy
operator|->
name|isVectorTy
argument_list|()
argument_list|)
expr_stmt|;
name|Types
operator|.
name|push_back
argument_list|(
name|VF
operator|==
literal|1
condition|?
name|OpTy
else|:
name|VectorType
operator|::
name|get
argument_list|(
name|OpTy
argument_list|,
name|VF
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|VF
operator|>
literal|1
operator|&&
operator|!
name|RetTy
operator|->
name|isVoidTy
argument_list|()
condition|)
name|RetTy
operator|=
name|VectorType
operator|::
name|get
argument_list|(
name|RetTy
argument_list|,
name|VF
argument_list|)
expr_stmt|;
comment|// Compute the scalarization overhead based on Args for a vector
comment|// intrinsic. A vectorizer will pass a scalar RetTy and VF> 1, while
comment|// CostModel will pass a vector RetTy and VF is 1.
name|unsigned
name|ScalarizationCost
init|=
name|UINT_MAX
decl_stmt|;
if|if
condition|(
name|RetVF
operator|>
literal|1
operator|||
name|VF
operator|>
literal|1
condition|)
block|{
name|ScalarizationCost
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|RetTy
operator|->
name|isVoidTy
argument_list|()
condition|)
name|ScalarizationCost
operator|+=
name|getScalarizationOverhead
argument_list|(
name|RetTy
argument_list|,
name|true
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|ScalarizationCost
operator|+=
name|getOperandsScalarizationOverhead
argument_list|(
name|Args
argument_list|,
name|VF
argument_list|)
expr_stmt|;
block|}
return|return
name|static_cast
operator|<
name|T
operator|*
operator|>
operator|(
name|this
operator|)
operator|->
name|getIntrinsicInstrCost
argument_list|(
name|IID
argument_list|,
name|RetTy
argument_list|,
name|Types
argument_list|,
name|FMF
argument_list|,
name|ScalarizationCost
argument_list|)
return|;
block|}
case|case
name|Intrinsic
operator|::
name|masked_scatter
case|:
block|{
name|assert
argument_list|(
name|VF
operator|==
literal|1
operator|&&
literal|"Can't vectorize types here."
argument_list|)
expr_stmt|;
name|Value
modifier|*
name|Mask
init|=
name|Args
index|[
literal|3
index|]
decl_stmt|;
name|bool
name|VarMask
init|=
operator|!
name|isa
operator|<
name|Constant
operator|>
operator|(
name|Mask
operator|)
decl_stmt|;
name|unsigned
name|Alignment
init|=
name|cast
operator|<
name|ConstantInt
operator|>
operator|(
name|Args
index|[
literal|2
index|]
operator|)
operator|->
name|getZExtValue
argument_list|()
decl_stmt|;
return|return
name|static_cast
operator|<
name|T
operator|*
operator|>
operator|(
name|this
operator|)
operator|->
name|getGatherScatterOpCost
argument_list|(
name|Instruction
operator|::
name|Store
argument_list|,
name|Args
index|[
literal|0
index|]
operator|->
name|getType
argument_list|()
argument_list|,
name|Args
index|[
literal|1
index|]
argument_list|,
name|VarMask
argument_list|,
name|Alignment
argument_list|)
return|;
block|}
case|case
name|Intrinsic
operator|::
name|masked_gather
case|:
block|{
name|assert
argument_list|(
name|VF
operator|==
literal|1
operator|&&
literal|"Can't vectorize types here."
argument_list|)
expr_stmt|;
name|Value
modifier|*
name|Mask
init|=
name|Args
index|[
literal|2
index|]
decl_stmt|;
name|bool
name|VarMask
init|=
operator|!
name|isa
operator|<
name|Constant
operator|>
operator|(
name|Mask
operator|)
decl_stmt|;
name|unsigned
name|Alignment
init|=
name|cast
operator|<
name|ConstantInt
operator|>
operator|(
name|Args
index|[
literal|1
index|]
operator|)
operator|->
name|getZExtValue
argument_list|()
decl_stmt|;
return|return
name|static_cast
operator|<
name|T
operator|*
operator|>
operator|(
name|this
operator|)
operator|->
name|getGatherScatterOpCost
argument_list|(
name|Instruction
operator|::
name|Load
argument_list|,
name|RetTy
argument_list|,
name|Args
index|[
literal|0
index|]
argument_list|,
name|VarMask
argument_list|,
name|Alignment
argument_list|)
return|;
block|}
block|}
block|}
comment|/// Get intrinsic cost based on argument types.
comment|/// If ScalarizationCostPassed is UINT_MAX, the cost of scalarizing the
comment|/// arguments and the return value will be computed based on types.
name|unsigned
name|getIntrinsicInstrCost
argument_list|(
name|Intrinsic
operator|::
name|ID
name|IID
argument_list|,
name|Type
operator|*
name|RetTy
argument_list|,
name|ArrayRef
operator|<
name|Type
operator|*
operator|>
name|Tys
argument_list|,
name|FastMathFlags
name|FMF
argument_list|,
name|unsigned
name|ScalarizationCostPassed
operator|=
name|UINT_MAX
argument_list|)
block|{
name|SmallVector
operator|<
name|unsigned
operator|,
literal|2
operator|>
name|ISDs
expr_stmt|;
name|unsigned
name|SingleCallCost
init|=
literal|10
decl_stmt|;
comment|// Library call cost. Make it expensive.
switch|switch
condition|(
name|IID
condition|)
block|{
default|default:
block|{
comment|// Assume that we need to scalarize this intrinsic.
name|unsigned
name|ScalarizationCost
init|=
name|ScalarizationCostPassed
decl_stmt|;
name|unsigned
name|ScalarCalls
init|=
literal|1
decl_stmt|;
name|Type
modifier|*
name|ScalarRetTy
init|=
name|RetTy
decl_stmt|;
if|if
condition|(
name|RetTy
operator|->
name|isVectorTy
argument_list|()
condition|)
block|{
if|if
condition|(
name|ScalarizationCostPassed
operator|==
name|UINT_MAX
condition|)
name|ScalarizationCost
operator|=
name|getScalarizationOverhead
argument_list|(
name|RetTy
argument_list|,
name|true
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|ScalarCalls
operator|=
name|std
operator|::
name|max
argument_list|(
name|ScalarCalls
argument_list|,
name|RetTy
operator|->
name|getVectorNumElements
argument_list|()
argument_list|)
expr_stmt|;
name|ScalarRetTy
operator|=
name|RetTy
operator|->
name|getScalarType
argument_list|()
expr_stmt|;
block|}
name|SmallVector
operator|<
name|Type
operator|*
operator|,
literal|4
operator|>
name|ScalarTys
expr_stmt|;
for|for
control|(
name|unsigned
name|i
init|=
literal|0
init|,
name|ie
init|=
name|Tys
operator|.
name|size
argument_list|()
init|;
name|i
operator|!=
name|ie
condition|;
operator|++
name|i
control|)
block|{
name|Type
modifier|*
name|Ty
init|=
name|Tys
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|Ty
operator|->
name|isVectorTy
argument_list|()
condition|)
block|{
if|if
condition|(
name|ScalarizationCostPassed
operator|==
name|UINT_MAX
condition|)
name|ScalarizationCost
operator|+=
name|getScalarizationOverhead
argument_list|(
name|Ty
argument_list|,
name|false
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|ScalarCalls
operator|=
name|std
operator|::
name|max
argument_list|(
name|ScalarCalls
argument_list|,
name|Ty
operator|->
name|getVectorNumElements
argument_list|()
argument_list|)
expr_stmt|;
name|Ty
operator|=
name|Ty
operator|->
name|getScalarType
argument_list|()
expr_stmt|;
block|}
name|ScalarTys
operator|.
name|push_back
argument_list|(
name|Ty
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ScalarCalls
operator|==
literal|1
condition|)
return|return
literal|1
return|;
comment|// Return cost of a scalar intrinsic. Assume it to be cheap.
name|unsigned
name|ScalarCost
init|=
name|static_cast
operator|<
name|T
operator|*
operator|>
operator|(
name|this
operator|)
operator|->
name|getIntrinsicInstrCost
argument_list|(
name|IID
argument_list|,
name|ScalarRetTy
argument_list|,
name|ScalarTys
argument_list|,
name|FMF
argument_list|)
decl_stmt|;
return|return
name|ScalarCalls
operator|*
name|ScalarCost
operator|+
name|ScalarizationCost
return|;
block|}
comment|// Look for intrinsics that can be lowered directly or turned into a scalar
comment|// intrinsic call.
case|case
name|Intrinsic
operator|::
name|sqrt
case|:
name|ISDs
operator|.
name|push_back
argument_list|(
name|ISD
operator|::
name|FSQRT
argument_list|)
expr_stmt|;
break|break;
case|case
name|Intrinsic
operator|::
name|sin
case|:
name|ISDs
operator|.
name|push_back
argument_list|(
name|ISD
operator|::
name|FSIN
argument_list|)
expr_stmt|;
break|break;
case|case
name|Intrinsic
operator|::
name|cos
case|:
name|ISDs
operator|.
name|push_back
argument_list|(
name|ISD
operator|::
name|FCOS
argument_list|)
expr_stmt|;
break|break;
case|case
name|Intrinsic
operator|::
name|exp
case|:
name|ISDs
operator|.
name|push_back
argument_list|(
name|ISD
operator|::
name|FEXP
argument_list|)
expr_stmt|;
break|break;
case|case
name|Intrinsic
operator|::
name|exp2
case|:
name|ISDs
operator|.
name|push_back
argument_list|(
name|ISD
operator|::
name|FEXP2
argument_list|)
expr_stmt|;
break|break;
case|case
name|Intrinsic
operator|::
name|log
case|:
name|ISDs
operator|.
name|push_back
argument_list|(
name|ISD
operator|::
name|FLOG
argument_list|)
expr_stmt|;
break|break;
case|case
name|Intrinsic
operator|::
name|log10
case|:
name|ISDs
operator|.
name|push_back
argument_list|(
name|ISD
operator|::
name|FLOG10
argument_list|)
expr_stmt|;
break|break;
case|case
name|Intrinsic
operator|::
name|log2
case|:
name|ISDs
operator|.
name|push_back
argument_list|(
name|ISD
operator|::
name|FLOG2
argument_list|)
expr_stmt|;
break|break;
case|case
name|Intrinsic
operator|::
name|fabs
case|:
name|ISDs
operator|.
name|push_back
argument_list|(
name|ISD
operator|::
name|FABS
argument_list|)
expr_stmt|;
break|break;
case|case
name|Intrinsic
operator|::
name|minnum
case|:
name|ISDs
operator|.
name|push_back
argument_list|(
name|ISD
operator|::
name|FMINNUM
argument_list|)
expr_stmt|;
if|if
condition|(
name|FMF
operator|.
name|noNaNs
argument_list|()
condition|)
name|ISDs
operator|.
name|push_back
argument_list|(
name|ISD
operator|::
name|FMINNAN
argument_list|)
expr_stmt|;
break|break;
case|case
name|Intrinsic
operator|::
name|maxnum
case|:
name|ISDs
operator|.
name|push_back
argument_list|(
name|ISD
operator|::
name|FMAXNUM
argument_list|)
expr_stmt|;
if|if
condition|(
name|FMF
operator|.
name|noNaNs
argument_list|()
condition|)
name|ISDs
operator|.
name|push_back
argument_list|(
name|ISD
operator|::
name|FMAXNAN
argument_list|)
expr_stmt|;
break|break;
case|case
name|Intrinsic
operator|::
name|copysign
case|:
name|ISDs
operator|.
name|push_back
argument_list|(
name|ISD
operator|::
name|FCOPYSIGN
argument_list|)
expr_stmt|;
break|break;
case|case
name|Intrinsic
operator|::
name|floor
case|:
name|ISDs
operator|.
name|push_back
argument_list|(
name|ISD
operator|::
name|FFLOOR
argument_list|)
expr_stmt|;
break|break;
case|case
name|Intrinsic
operator|::
name|ceil
case|:
name|ISDs
operator|.
name|push_back
argument_list|(
name|ISD
operator|::
name|FCEIL
argument_list|)
expr_stmt|;
break|break;
case|case
name|Intrinsic
operator|::
name|trunc
case|:
name|ISDs
operator|.
name|push_back
argument_list|(
name|ISD
operator|::
name|FTRUNC
argument_list|)
expr_stmt|;
break|break;
case|case
name|Intrinsic
operator|::
name|nearbyint
case|:
name|ISDs
operator|.
name|push_back
argument_list|(
name|ISD
operator|::
name|FNEARBYINT
argument_list|)
expr_stmt|;
break|break;
case|case
name|Intrinsic
operator|::
name|rint
case|:
name|ISDs
operator|.
name|push_back
argument_list|(
name|ISD
operator|::
name|FRINT
argument_list|)
expr_stmt|;
break|break;
case|case
name|Intrinsic
operator|::
name|round
case|:
name|ISDs
operator|.
name|push_back
argument_list|(
name|ISD
operator|::
name|FROUND
argument_list|)
expr_stmt|;
break|break;
case|case
name|Intrinsic
operator|::
name|pow
case|:
name|ISDs
operator|.
name|push_back
argument_list|(
name|ISD
operator|::
name|FPOW
argument_list|)
expr_stmt|;
break|break;
case|case
name|Intrinsic
operator|::
name|fma
case|:
name|ISDs
operator|.
name|push_back
argument_list|(
name|ISD
operator|::
name|FMA
argument_list|)
expr_stmt|;
break|break;
case|case
name|Intrinsic
operator|::
name|fmuladd
case|:
name|ISDs
operator|.
name|push_back
argument_list|(
name|ISD
operator|::
name|FMA
argument_list|)
expr_stmt|;
break|break;
comment|// FIXME: We should return 0 whenever getIntrinsicCost == TCC_Free.
case|case
name|Intrinsic
operator|::
name|lifetime_start
case|:
case|case
name|Intrinsic
operator|::
name|lifetime_end
case|:
return|return
literal|0
return|;
case|case
name|Intrinsic
operator|::
name|masked_store
case|:
return|return
name|static_cast
operator|<
name|T
operator|*
operator|>
operator|(
name|this
operator|)
operator|->
name|getMaskedMemoryOpCost
argument_list|(
name|Instruction
operator|::
name|Store
argument_list|,
name|Tys
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
return|;
case|case
name|Intrinsic
operator|::
name|masked_load
case|:
return|return
name|static_cast
operator|<
name|T
operator|*
operator|>
operator|(
name|this
operator|)
operator|->
name|getMaskedMemoryOpCost
argument_list|(
name|Instruction
operator|::
name|Load
argument_list|,
name|RetTy
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
return|;
case|case
name|Intrinsic
operator|::
name|ctpop
case|:
name|ISDs
operator|.
name|push_back
argument_list|(
name|ISD
operator|::
name|CTPOP
argument_list|)
expr_stmt|;
comment|// In case of legalization use TCC_Expensive. This is cheaper than a
comment|// library call but still not a cheap instruction.
name|SingleCallCost
operator|=
name|TargetTransformInfo
operator|::
name|TCC_Expensive
expr_stmt|;
break|break;
comment|// FIXME: ctlz, cttz, ...
block|}
specifier|const
name|TargetLoweringBase
modifier|*
name|TLI
init|=
name|getTLI
argument_list|()
decl_stmt|;
name|std
operator|::
name|pair
operator|<
name|unsigned
operator|,
name|MVT
operator|>
name|LT
operator|=
name|TLI
operator|->
name|getTypeLegalizationCost
argument_list|(
name|DL
argument_list|,
name|RetTy
argument_list|)
expr_stmt|;
name|SmallVector
operator|<
name|unsigned
operator|,
literal|2
operator|>
name|LegalCost
expr_stmt|;
name|SmallVector
operator|<
name|unsigned
operator|,
literal|2
operator|>
name|CustomCost
expr_stmt|;
for|for
control|(
name|unsigned
name|ISD
range|:
name|ISDs
control|)
block|{
if|if
condition|(
name|TLI
operator|->
name|isOperationLegalOrPromote
argument_list|(
name|ISD
argument_list|,
name|LT
operator|.
name|second
argument_list|)
condition|)
block|{
if|if
condition|(
name|IID
operator|==
name|Intrinsic
operator|::
name|fabs
operator|&&
name|TLI
operator|->
name|isFAbsFree
argument_list|(
name|LT
operator|.
name|second
argument_list|)
condition|)
block|{
return|return
literal|0
return|;
block|}
comment|// The operation is legal. Assume it costs 1.
comment|// If the type is split to multiple registers, assume that there is some
comment|// overhead to this.
comment|// TODO: Once we have extract/insert subvector cost we need to use them.
if|if
condition|(
name|LT
operator|.
name|first
operator|>
literal|1
condition|)
name|LegalCost
operator|.
name|push_back
argument_list|(
name|LT
operator|.
name|first
operator|*
literal|2
argument_list|)
expr_stmt|;
else|else
name|LegalCost
operator|.
name|push_back
argument_list|(
name|LT
operator|.
name|first
operator|*
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|TLI
operator|->
name|isOperationExpand
argument_list|(
name|ISD
argument_list|,
name|LT
operator|.
name|second
argument_list|)
condition|)
block|{
comment|// If the operation is custom lowered then assume
comment|// that the code is twice as expensive.
name|CustomCost
operator|.
name|push_back
argument_list|(
name|LT
operator|.
name|first
operator|*
literal|2
argument_list|)
expr_stmt|;
block|}
block|}
name|auto
name|MinLegalCostI
init|=
name|std
operator|::
name|min_element
argument_list|(
name|LegalCost
operator|.
name|begin
argument_list|()
argument_list|,
name|LegalCost
operator|.
name|end
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|MinLegalCostI
operator|!=
name|LegalCost
operator|.
name|end
argument_list|()
condition|)
return|return
operator|*
name|MinLegalCostI
return|;
name|auto
name|MinCustomCostI
init|=
name|std
operator|::
name|min_element
argument_list|(
name|CustomCost
operator|.
name|begin
argument_list|()
argument_list|,
name|CustomCost
operator|.
name|end
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|MinCustomCostI
operator|!=
name|CustomCost
operator|.
name|end
argument_list|()
condition|)
return|return
operator|*
name|MinCustomCostI
return|;
comment|// If we can't lower fmuladd into an FMA estimate the cost as a floating
comment|// point mul followed by an add.
if|if
condition|(
name|IID
operator|==
name|Intrinsic
operator|::
name|fmuladd
condition|)
return|return
name|static_cast
operator|<
name|T
operator|*
operator|>
operator|(
name|this
operator|)
operator|->
name|getArithmeticInstrCost
argument_list|(
name|BinaryOperator
operator|::
name|FMul
argument_list|,
name|RetTy
argument_list|)
operator|+
name|static_cast
operator|<
name|T
operator|*
operator|>
operator|(
name|this
operator|)
operator|->
name|getArithmeticInstrCost
argument_list|(
name|BinaryOperator
operator|::
name|FAdd
argument_list|,
name|RetTy
argument_list|)
return|;
comment|// Else, assume that we need to scalarize this intrinsic. For math builtins
comment|// this will emit a costly libcall, adding call overhead and spills. Make it
comment|// very expensive.
if|if
condition|(
name|RetTy
operator|->
name|isVectorTy
argument_list|()
condition|)
block|{
name|unsigned
name|ScalarizationCost
init|=
operator|(
operator|(
name|ScalarizationCostPassed
operator|!=
name|UINT_MAX
operator|)
condition|?
name|ScalarizationCostPassed
else|:
name|getScalarizationOverhead
argument_list|(
name|RetTy
argument_list|,
name|true
argument_list|,
name|false
argument_list|)
operator|)
decl_stmt|;
name|unsigned
name|ScalarCalls
init|=
name|RetTy
operator|->
name|getVectorNumElements
argument_list|()
decl_stmt|;
name|SmallVector
operator|<
name|Type
operator|*
operator|,
literal|4
operator|>
name|ScalarTys
expr_stmt|;
for|for
control|(
name|unsigned
name|i
init|=
literal|0
init|,
name|ie
init|=
name|Tys
operator|.
name|size
argument_list|()
init|;
name|i
operator|!=
name|ie
condition|;
operator|++
name|i
control|)
block|{
name|Type
modifier|*
name|Ty
init|=
name|Tys
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|Ty
operator|->
name|isVectorTy
argument_list|()
condition|)
name|Ty
operator|=
name|Ty
operator|->
name|getScalarType
argument_list|()
expr_stmt|;
name|ScalarTys
operator|.
name|push_back
argument_list|(
name|Ty
argument_list|)
expr_stmt|;
block|}
name|unsigned
name|ScalarCost
init|=
name|static_cast
operator|<
name|T
operator|*
operator|>
operator|(
name|this
operator|)
operator|->
name|getIntrinsicInstrCost
argument_list|(
name|IID
argument_list|,
name|RetTy
operator|->
name|getScalarType
argument_list|()
argument_list|,
name|ScalarTys
argument_list|,
name|FMF
argument_list|)
decl_stmt|;
for|for
control|(
name|unsigned
name|i
init|=
literal|0
init|,
name|ie
init|=
name|Tys
operator|.
name|size
argument_list|()
init|;
name|i
operator|!=
name|ie
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|Tys
index|[
name|i
index|]
operator|->
name|isVectorTy
argument_list|()
condition|)
block|{
if|if
condition|(
name|ScalarizationCostPassed
operator|==
name|UINT_MAX
condition|)
name|ScalarizationCost
operator|+=
name|getScalarizationOverhead
argument_list|(
name|Tys
index|[
name|i
index|]
argument_list|,
name|false
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|ScalarCalls
operator|=
name|std
operator|::
name|max
argument_list|(
name|ScalarCalls
argument_list|,
name|Tys
index|[
name|i
index|]
operator|->
name|getVectorNumElements
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|ScalarCalls
operator|*
name|ScalarCost
operator|+
name|ScalarizationCost
return|;
block|}
comment|// This is going to be turned into a library call, make it expensive.
return|return
name|SingleCallCost
return|;
block|}
comment|/// \brief Compute a cost of the given call instruction.
comment|///
comment|/// Compute the cost of calling function F with return type RetTy and
comment|/// argument types Tys. F might be nullptr, in this case the cost of an
comment|/// arbitrary call with the specified signature will be returned.
comment|/// This is used, for instance,  when we estimate call of a vector
comment|/// counterpart of the given function.
comment|/// \param F Called function, might be nullptr.
comment|/// \param RetTy Return value types.
comment|/// \param Tys Argument types.
comment|/// \returns The cost of Call instruction.
name|unsigned
name|getCallInstrCost
argument_list|(
name|Function
operator|*
name|F
argument_list|,
name|Type
operator|*
name|RetTy
argument_list|,
name|ArrayRef
operator|<
name|Type
operator|*
operator|>
name|Tys
argument_list|)
block|{
return|return
literal|10
return|;
block|}
name|unsigned
name|getNumberOfParts
parameter_list|(
name|Type
modifier|*
name|Tp
parameter_list|)
block|{
name|std
operator|::
name|pair
operator|<
name|unsigned
operator|,
name|MVT
operator|>
name|LT
operator|=
name|getTLI
argument_list|()
operator|->
name|getTypeLegalizationCost
argument_list|(
name|DL
argument_list|,
name|Tp
argument_list|)
expr_stmt|;
return|return
name|LT
operator|.
name|first
return|;
block|}
name|unsigned
name|getAddressComputationCost
parameter_list|(
name|Type
modifier|*
name|Ty
parameter_list|,
name|ScalarEvolution
modifier|*
parameter_list|,
specifier|const
name|SCEV
modifier|*
parameter_list|)
block|{
return|return
literal|0
return|;
block|}
name|unsigned
name|getReductionCost
parameter_list|(
name|unsigned
name|Opcode
parameter_list|,
name|Type
modifier|*
name|Ty
parameter_list|,
name|bool
name|IsPairwise
parameter_list|)
block|{
name|assert
argument_list|(
name|Ty
operator|->
name|isVectorTy
argument_list|()
operator|&&
literal|"Expect a vector type"
argument_list|)
expr_stmt|;
name|Type
modifier|*
name|ScalarTy
init|=
name|Ty
operator|->
name|getVectorElementType
argument_list|()
decl_stmt|;
name|unsigned
name|NumVecElts
init|=
name|Ty
operator|->
name|getVectorNumElements
argument_list|()
decl_stmt|;
name|unsigned
name|NumReduxLevels
init|=
name|Log2_32
argument_list|(
name|NumVecElts
argument_list|)
decl_stmt|;
comment|// Try to calculate arithmetic and shuffle op costs for reduction operations.
comment|// We're assuming that reduction operation are performing the following way:
comment|// 1. Non-pairwise reduction
comment|// %val1 = shufflevector<n x t> %val,<n x t> %undef,
comment|//<n x i32><i32 n/2, i32 n/2 + 1, ..., i32 n, i32 undef, ..., i32 undef>
comment|//            \----------------v-------------/  \----------v------------/
comment|//                            n/2 elements               n/2 elements
comment|// %red1 = op<n x t> %val,<n x t> val1
comment|// After this operation we have a vector %red1 with only maningfull the
comment|// first n/2 elements, the second n/2 elements are undefined and can be
comment|// dropped. All other operations are actually working with the vector of
comment|// length n/2, not n. though the real vector length is still n.
comment|// %val2 = shufflevector<n x t> %red1,<n x t> %undef,
comment|//<n x i32><i32 n/4, i32 n/4 + 1, ..., i32 n/2, i32 undef, ..., i32 undef>
comment|//            \----------------v-------------/  \----------v------------/
comment|//                            n/4 elements               3*n/4 elements
comment|// %red2 = op<n x t> %red1,<n x t> val2  - working with the vector of
comment|// length n/2, the resulting vector has length n/4 etc.
comment|// 2. Pairwise reduction:
comment|// Everything is the same except for an additional shuffle operation which
comment|// is used to produce operands for pairwise kind of reductions.
comment|// %val1 = shufflevector<n x t> %val,<n x t> %undef,
comment|//<n x i32><i32 0, i32 2, ..., i32 n-2, i32 undef, ..., i32 undef>
comment|//            \-------------v----------/  \----------v------------/
comment|//                   n/2 elements               n/2 elements
comment|// %val2 = shufflevector<n x t> %val,<n x t> %undef,
comment|//<n x i32><i32 1, i32 3, ..., i32 n-1, i32 undef, ..., i32 undef>
comment|//            \-------------v----------/  \----------v------------/
comment|//                   n/2 elements               n/2 elements
comment|// %red1 = op<n x t> %val1,<n x t> val2
comment|// Again, the operation is performed on<n x t> vector, but the resulting
comment|// vector %red1 is<n/2 x t> vector.
comment|//
comment|// The cost model should take into account that the actual length of the
comment|// vector is reduced on each iteration.
name|unsigned
name|ArithCost
init|=
literal|0
decl_stmt|;
name|unsigned
name|ShuffleCost
init|=
literal|0
decl_stmt|;
name|auto
operator|*
name|ConcreteTTI
operator|=
name|static_cast
operator|<
name|T
operator|*
operator|>
operator|(
name|this
operator|)
expr_stmt|;
name|std
operator|::
name|pair
operator|<
name|unsigned
operator|,
name|MVT
operator|>
name|LT
operator|=
name|ConcreteTTI
operator|->
name|getTLI
argument_list|()
operator|->
name|getTypeLegalizationCost
argument_list|(
name|DL
argument_list|,
name|Ty
argument_list|)
expr_stmt|;
name|unsigned
name|LongVectorCount
init|=
literal|0
decl_stmt|;
name|unsigned
name|MVTLen
init|=
name|LT
operator|.
name|second
operator|.
name|isVector
argument_list|()
condition|?
name|LT
operator|.
name|second
operator|.
name|getVectorNumElements
argument_list|()
else|:
literal|1
decl_stmt|;
while|while
condition|(
name|NumVecElts
operator|>
name|MVTLen
condition|)
block|{
name|NumVecElts
operator|/=
literal|2
expr_stmt|;
comment|// Assume the pairwise shuffles add a cost.
name|ShuffleCost
operator|+=
operator|(
name|IsPairwise
operator|+
literal|1
operator|)
operator|*
name|ConcreteTTI
operator|->
name|getShuffleCost
argument_list|(
name|TTI
operator|::
name|SK_ExtractSubvector
argument_list|,
name|Ty
argument_list|,
name|NumVecElts
argument_list|,
name|Ty
argument_list|)
expr_stmt|;
name|ArithCost
operator|+=
name|ConcreteTTI
operator|->
name|getArithmeticInstrCost
argument_list|(
name|Opcode
argument_list|,
name|Ty
argument_list|)
expr_stmt|;
name|Ty
operator|=
name|VectorType
operator|::
name|get
argument_list|(
name|ScalarTy
argument_list|,
name|NumVecElts
argument_list|)
expr_stmt|;
operator|++
name|LongVectorCount
expr_stmt|;
block|}
comment|// The minimal length of the vector is limited by the real length of vector
comment|// operations performed on the current platform. That's why several final
comment|// reduction opertions are perfomed on the vectors with the same
comment|// architecture-dependent length.
name|ShuffleCost
operator|+=
operator|(
name|NumReduxLevels
operator|-
name|LongVectorCount
operator|)
operator|*
operator|(
name|IsPairwise
operator|+
literal|1
operator|)
operator|*
name|ConcreteTTI
operator|->
name|getShuffleCost
argument_list|(
name|TTI
operator|::
name|SK_ExtractSubvector
argument_list|,
name|Ty
argument_list|,
name|NumVecElts
argument_list|,
name|Ty
argument_list|)
expr_stmt|;
name|ArithCost
operator|+=
operator|(
name|NumReduxLevels
operator|-
name|LongVectorCount
operator|)
operator|*
name|ConcreteTTI
operator|->
name|getArithmeticInstrCost
argument_list|(
name|Opcode
argument_list|,
name|Ty
argument_list|)
expr_stmt|;
return|return
name|ShuffleCost
operator|+
name|ArithCost
operator|+
name|getScalarizationOverhead
argument_list|(
name|Ty
argument_list|,
name|false
argument_list|,
name|true
argument_list|)
return|;
block|}
name|unsigned
name|getVectorSplitCost
parameter_list|()
block|{
return|return
literal|1
return|;
block|}
comment|/// @}
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_comment
comment|/// \brief Concrete BasicTTIImpl that can be used if no further customization
end_comment

begin_comment
comment|/// is needed.
end_comment

begin_decl_stmt
name|class
name|BasicTTIImpl
range|:
name|public
name|BasicTTIImplBase
operator|<
name|BasicTTIImpl
operator|>
block|{
typedef|typedef
name|BasicTTIImplBase
operator|<
name|BasicTTIImpl
operator|>
name|BaseT
expr_stmt|;
name|friend
name|class
name|BasicTTIImplBase
operator|<
name|BasicTTIImpl
operator|>
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|TargetSubtargetInfo
modifier|*
name|ST
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|TargetLoweringBase
modifier|*
name|TLI
decl_stmt|;
end_decl_stmt

begin_expr_stmt
specifier|const
name|TargetSubtargetInfo
operator|*
name|getST
argument_list|()
specifier|const
block|{
return|return
name|ST
return|;
block|}
end_expr_stmt

begin_expr_stmt
specifier|const
name|TargetLoweringBase
operator|*
name|getTLI
argument_list|()
specifier|const
block|{
return|return
name|TLI
return|;
block|}
end_expr_stmt

begin_label
name|public
label|:
end_label

begin_function_decl
name|explicit
name|BasicTTIImpl
parameter_list|(
specifier|const
name|TargetMachine
modifier|*
name|ST
parameter_list|,
specifier|const
name|Function
modifier|&
name|F
parameter_list|)
function_decl|;
end_function_decl

begin_endif
unit|};  }
endif|#
directive|endif
end_endif

end_unit

