begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Interface definition for configurable Xtensa ISA support.    Copyright 2003, 2004, 2005, 2006 Free Software Foundation, Inc.     This file is part of BFD, the Binary File Descriptor library.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|XTENSA_LIBISA_H
end_ifndef

begin_define
define|#
directive|define
name|XTENSA_LIBISA_H
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|__cplusplus
end_ifdef

begin_extern
extern|extern
literal|"C"
block|{
endif|#
directive|endif
comment|/* Version number: This is intended to help support code that works with    versions of this library from multiple Xtensa releases.  */
define|#
directive|define
name|XTENSA_ISA_VERSION
value|7000
ifndef|#
directive|ifndef
name|uint32
define|#
directive|define
name|uint32
value|unsigned int
endif|#
directive|endif
comment|/* This file defines the interface to the Xtensa ISA library.  This    library contains most of the ISA-specific information for a    particular Xtensa processor.  For example, the set of valid    instructions, their opcode encodings and operand fields are all    included here.     This interface basically defines a number of abstract data types.     . an instruction buffer - for holding the raw instruction bits    . ISA info - information about the ISA as a whole    . instruction formats - instruction size and slot structure    . opcodes - information about individual instructions    . operands - information about register and immediate instruction operands    . stateOperands - information about processor state instruction operands    . interfaceOperands - information about interface instruction operands    . register files - register file information    . processor states - internal processor state information    . system registers - "special registers" and "user registers"    . interfaces - TIE interfaces that are external to the processor    . functional units - TIE shared functions     The interface defines a set of functions to access each data type.    With the exception of the instruction buffer, the internal    representations of the data structures are hidden.  All accesses must    be made through the functions defined here.  */
typedef|typedef
struct|struct
name|xtensa_isa_opaque
block|{
name|int
name|unused
decl_stmt|;
block|}
typedef|*
name|xtensa_isa
typedef|;
comment|/* Most of the Xtensa ISA entities (e.g., opcodes, regfiles, etc.) are    represented here using sequential integers beginning with 0.  The    specific values are only fixed for a particular instantiation of an    xtensa_isa structure, so these values should only be used    internally.  */
typedef|typedef
name|int
name|xtensa_opcode
typedef|;
typedef|typedef
name|int
name|xtensa_format
typedef|;
typedef|typedef
name|int
name|xtensa_regfile
typedef|;
typedef|typedef
name|int
name|xtensa_state
typedef|;
typedef|typedef
name|int
name|xtensa_sysreg
typedef|;
typedef|typedef
name|int
name|xtensa_interface
typedef|;
typedef|typedef
name|int
name|xtensa_funcUnit
typedef|;
comment|/* Define a unique value for undefined items.  */
define|#
directive|define
name|XTENSA_UNDEFINED
value|-1
comment|/* Overview of using this interface to decode/encode instructions:     Each Xtensa instruction is associated with a particular instruction    format, where the format defines a fixed number of slots for    operations.  The formats for the core Xtensa ISA have only one slot,    but FLIX instructions may have multiple slots.  Within each slot,    there is a single opcode and some number of associated operands.     The encoding and decoding functions operate on instruction buffers,    not on the raw bytes of the instructions.  The same instruction    buffer data structure is used for both entire instructions and    individual slots in those instructions -- the contents of a slot need    to be extracted from or inserted into the buffer for the instruction    as a whole.     Decoding an instruction involves first finding the format, which    identifies the number of slots, and then decoding each slot    separately.  A slot is decoded by finding the opcode and then using    the opcode to determine how many operands there are.  For example:     xtensa_insnbuf_from_chars    xtensa_format_decode    for each slot {      xtensa_format_get_slot      xtensa_opcode_decode      for each operand {        xtensa_operand_get_field        xtensa_operand_decode      }    }     Encoding an instruction is roughly the same procedure in reverse:     xtensa_format_encode    for each slot {      xtensa_opcode_encode      for each operand {        xtensa_operand_encode        xtensa_operand_set_field      }      xtensa_format_set_slot    }    xtensa_insnbuf_to_chars */
comment|/* Error handling.  */
comment|/* Error codes.  The code for the most recent error condition can be    retrieved with the "errno" function.  For any result other than    xtensa_isa_ok, an error message containing additional information    about the problem can be retrieved using the "error_msg" function.    The error messages are stored in an internal buffer, which should    not be freed and may be overwritten by subsequent operations.  */
typedef|typedef
enum|enum
name|xtensa_isa_status_enum
block|{
name|xtensa_isa_ok
init|=
literal|0
block|,
name|xtensa_isa_bad_format
block|,
name|xtensa_isa_bad_slot
block|,
name|xtensa_isa_bad_opcode
block|,
name|xtensa_isa_bad_operand
block|,
name|xtensa_isa_bad_field
block|,
name|xtensa_isa_bad_iclass
block|,
name|xtensa_isa_bad_regfile
block|,
name|xtensa_isa_bad_sysreg
block|,
name|xtensa_isa_bad_state
block|,
name|xtensa_isa_bad_interface
block|,
name|xtensa_isa_bad_funcUnit
block|,
name|xtensa_isa_wrong_slot
block|,
name|xtensa_isa_no_field
block|,
name|xtensa_isa_out_of_memory
block|,
name|xtensa_isa_buffer_overflow
block|,
name|xtensa_isa_internal_error
block|,
name|xtensa_isa_bad_value
block|}
name|xtensa_isa_status
typedef|;
specifier|extern
name|xtensa_isa_status
name|xtensa_isa_errno
parameter_list|(
name|xtensa_isa
name|isa
parameter_list|)
function_decl|;
specifier|extern
name|char
modifier|*
name|xtensa_isa_error_msg
parameter_list|(
name|xtensa_isa
name|isa
parameter_list|)
function_decl|;
comment|/* Instruction buffers.  */
typedef|typedef
name|uint32
name|xtensa_insnbuf_word
typedef|;
typedef|typedef
name|xtensa_insnbuf_word
modifier|*
name|xtensa_insnbuf
typedef|;
comment|/* Get the size in "insnbuf_words" of the xtensa_insnbuf array.  */
specifier|extern
name|int
name|xtensa_insnbuf_size
parameter_list|(
name|xtensa_isa
name|isa
parameter_list|)
function_decl|;
comment|/* Allocate an xtensa_insnbuf of the right size.  */
specifier|extern
name|xtensa_insnbuf
name|xtensa_insnbuf_alloc
parameter_list|(
name|xtensa_isa
name|isa
parameter_list|)
function_decl|;
comment|/* Release an xtensa_insnbuf.  */
specifier|extern
name|void
name|xtensa_insnbuf_free
parameter_list|(
name|xtensa_isa
name|isa
parameter_list|,
name|xtensa_insnbuf
name|buf
parameter_list|)
function_decl|;
comment|/* Conversion between raw memory (char arrays) and our internal    instruction representation.  This is complicated by the Xtensa ISA's    variable instruction lengths.  When converting to chars, the buffer    must contain a valid instruction so we know how many bytes to copy;    thus, the "to_chars" function returns the number of bytes copied or    XTENSA_UNDEFINED on error.  The "from_chars" function first reads the    minimal number of bytes required to decode the instruction length and    then proceeds to copy the entire instruction into the buffer; if the    memory does not contain a valid instruction, it copies the maximum    number of bytes required for the longest Xtensa instruction.  The    "num_chars" argument may be used to limit the number of bytes that    can be read or written.  Otherwise, if "num_chars" is zero, the    functions may read or write past the end of the code.  */
specifier|extern
name|int
name|xtensa_insnbuf_to_chars
parameter_list|(
name|xtensa_isa
name|isa
parameter_list|,
specifier|const
name|xtensa_insnbuf
name|insn
parameter_list|,
name|unsigned
name|char
modifier|*
name|cp
parameter_list|,
name|int
name|num_chars
parameter_list|)
function_decl|;
specifier|extern
name|void
name|xtensa_insnbuf_from_chars
parameter_list|(
name|xtensa_isa
name|isa
parameter_list|,
name|xtensa_insnbuf
name|insn
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|cp
parameter_list|,
name|int
name|num_chars
parameter_list|)
function_decl|;
comment|/* ISA information.  */
comment|/* Initialize the ISA information.  */
specifier|extern
name|xtensa_isa
name|xtensa_isa_init
parameter_list|(
name|xtensa_isa_status
modifier|*
name|errno_p
parameter_list|,
name|char
modifier|*
modifier|*
name|error_msg_p
parameter_list|)
function_decl|;
comment|/* Deallocate an xtensa_isa structure.  */
specifier|extern
name|void
name|xtensa_isa_free
parameter_list|(
name|xtensa_isa
name|isa
parameter_list|)
function_decl|;
comment|/* Get the maximum instruction size in bytes.  */
specifier|extern
name|int
name|xtensa_isa_maxlength
parameter_list|(
name|xtensa_isa
name|isa
parameter_list|)
function_decl|;
comment|/* Decode the length in bytes of an instruction in raw memory (not an    insnbuf).  This function reads only the minimal number of bytes    required to decode the instruction length.  Returns    XTENSA_UNDEFINED on error.  */
specifier|extern
name|int
name|xtensa_isa_length_from_chars
parameter_list|(
name|xtensa_isa
name|isa
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|cp
parameter_list|)
function_decl|;
comment|/* Get the number of stages in the processor's pipeline.  The pipeline    stage values returned by other functions in this library will range    from 0 to N-1, where N is the value returned by this function.    Note that the stage numbers used here may not correspond to the    actual processor hardware, e.g., the hardware may have additional    stages before stage 0.  Returns XTENSA_UNDEFINED on error.  */
specifier|extern
name|int
name|xtensa_isa_num_pipe_stages
parameter_list|(
name|xtensa_isa
name|isa
parameter_list|)
function_decl|;
comment|/* Get the number of various entities that are defined for this processor.  */
specifier|extern
name|int
name|xtensa_isa_num_formats
parameter_list|(
name|xtensa_isa
name|isa
parameter_list|)
function_decl|;
specifier|extern
name|int
name|xtensa_isa_num_opcodes
parameter_list|(
name|xtensa_isa
name|isa
parameter_list|)
function_decl|;
specifier|extern
name|int
name|xtensa_isa_num_regfiles
parameter_list|(
name|xtensa_isa
name|isa
parameter_list|)
function_decl|;
specifier|extern
name|int
name|xtensa_isa_num_states
parameter_list|(
name|xtensa_isa
name|isa
parameter_list|)
function_decl|;
specifier|extern
name|int
name|xtensa_isa_num_sysregs
parameter_list|(
name|xtensa_isa
name|isa
parameter_list|)
function_decl|;
specifier|extern
name|int
name|xtensa_isa_num_interfaces
parameter_list|(
name|xtensa_isa
name|isa
parameter_list|)
function_decl|;
specifier|extern
name|int
name|xtensa_isa_num_funcUnits
parameter_list|(
name|xtensa_isa
name|isa
parameter_list|)
function_decl|;
comment|/* Instruction formats.  */
comment|/* Get the name of a format.  Returns null on error.  */
specifier|extern
specifier|const
name|char
modifier|*
name|xtensa_format_name
parameter_list|(
name|xtensa_isa
name|isa
parameter_list|,
name|xtensa_format
name|fmt
parameter_list|)
function_decl|;
comment|/* Given a format name, return the format number.  Returns    XTENSA_UNDEFINED if the name is not a valid format.  */
specifier|extern
name|xtensa_format
name|xtensa_format_lookup
parameter_list|(
name|xtensa_isa
name|isa
parameter_list|,
specifier|const
name|char
modifier|*
name|fmtname
parameter_list|)
function_decl|;
comment|/* Decode the instruction format from a binary instruction buffer.    Returns XTENSA_UNDEFINED if the format is not recognized.  */
specifier|extern
name|xtensa_format
name|xtensa_format_decode
parameter_list|(
name|xtensa_isa
name|isa
parameter_list|,
specifier|const
name|xtensa_insnbuf
name|insn
parameter_list|)
function_decl|;
comment|/* Set the instruction format field(s) in a binary instruction buffer.    All the other fields are set to zero.  Returns non-zero on error.  */
specifier|extern
name|int
name|xtensa_format_encode
parameter_list|(
name|xtensa_isa
name|isa
parameter_list|,
name|xtensa_format
name|fmt
parameter_list|,
name|xtensa_insnbuf
name|insn
parameter_list|)
function_decl|;
comment|/* Find the length (in bytes) of an instruction.  Returns    XTENSA_UNDEFINED on error.  */
specifier|extern
name|int
name|xtensa_format_length
parameter_list|(
name|xtensa_isa
name|isa
parameter_list|,
name|xtensa_format
name|fmt
parameter_list|)
function_decl|;
comment|/* Get the number of slots in an instruction.  Returns XTENSA_UNDEFINED    on error.  */
specifier|extern
name|int
name|xtensa_format_num_slots
parameter_list|(
name|xtensa_isa
name|isa
parameter_list|,
name|xtensa_format
name|fmt
parameter_list|)
function_decl|;
comment|/* Get the opcode for a no-op in a particular slot.    Returns XTENSA_UNDEFINED on error.  */
specifier|extern
name|xtensa_opcode
name|xtensa_format_slot_nop_opcode
parameter_list|(
name|xtensa_isa
name|isa
parameter_list|,
name|xtensa_format
name|fmt
parameter_list|,
name|int
name|slot
parameter_list|)
function_decl|;
comment|/* Get the bits for a specified slot out of an insnbuf for the    instruction as a whole and put them into an insnbuf for that one    slot, and do the opposite to set a slot.  Return non-zero on error.  */
specifier|extern
name|int
name|xtensa_format_get_slot
parameter_list|(
name|xtensa_isa
name|isa
parameter_list|,
name|xtensa_format
name|fmt
parameter_list|,
name|int
name|slot
parameter_list|,
specifier|const
name|xtensa_insnbuf
name|insn
parameter_list|,
name|xtensa_insnbuf
name|slotbuf
parameter_list|)
function_decl|;
specifier|extern
name|int
name|xtensa_format_set_slot
parameter_list|(
name|xtensa_isa
name|isa
parameter_list|,
name|xtensa_format
name|fmt
parameter_list|,
name|int
name|slot
parameter_list|,
name|xtensa_insnbuf
name|insn
parameter_list|,
specifier|const
name|xtensa_insnbuf
name|slotbuf
parameter_list|)
function_decl|;
comment|/* Opcode information.  */
comment|/* Translate a mnemonic name to an opcode.  Returns XTENSA_UNDEFINED if    the name is not a valid opcode mnemonic.  */
specifier|extern
name|xtensa_opcode
name|xtensa_opcode_lookup
parameter_list|(
name|xtensa_isa
name|isa
parameter_list|,
specifier|const
name|char
modifier|*
name|opname
parameter_list|)
function_decl|;
comment|/* Decode the opcode for one instruction slot from a binary instruction    buffer.  Returns the opcode or XTENSA_UNDEFINED if the opcode is    illegal.  */
specifier|extern
name|xtensa_opcode
name|xtensa_opcode_decode
parameter_list|(
name|xtensa_isa
name|isa
parameter_list|,
name|xtensa_format
name|fmt
parameter_list|,
name|int
name|slot
parameter_list|,
specifier|const
name|xtensa_insnbuf
name|slotbuf
parameter_list|)
function_decl|;
comment|/* Set the opcode field(s) for an instruction slot.  All other fields    in the slot are set to zero.  Returns non-zero if the opcode cannot    be encoded.  */
specifier|extern
name|int
name|xtensa_opcode_encode
parameter_list|(
name|xtensa_isa
name|isa
parameter_list|,
name|xtensa_format
name|fmt
parameter_list|,
name|int
name|slot
parameter_list|,
name|xtensa_insnbuf
name|slotbuf
parameter_list|,
name|xtensa_opcode
name|opc
parameter_list|)
function_decl|;
comment|/* Get the mnemonic name for an opcode.  Returns null on error.  */
specifier|extern
specifier|const
name|char
modifier|*
name|xtensa_opcode_name
parameter_list|(
name|xtensa_isa
name|isa
parameter_list|,
name|xtensa_opcode
name|opc
parameter_list|)
function_decl|;
comment|/* Check various properties of opcodes.  These functions return 0 if    the condition is false, 1 if the condition is true, and    XTENSA_UNDEFINED on error.  The instructions are classified as    follows:     branch: conditional branch; may fall through to next instruction (B*)    jump: unconditional branch (J, JX, RET*, RF*)    loop: zero-overhead loop (LOOP*)    call: unconditional call; control returns to next instruction (CALL*)     For the opcodes that affect control flow in some way, the branch    target may be specified by an immediate operand or it may be an    address stored in a register.  You can distinguish these by    checking if the instruction has a PC-relative immediate    operand.  */
specifier|extern
name|int
name|xtensa_opcode_is_branch
parameter_list|(
name|xtensa_isa
name|isa
parameter_list|,
name|xtensa_opcode
name|opc
parameter_list|)
function_decl|;
specifier|extern
name|int
name|xtensa_opcode_is_jump
parameter_list|(
name|xtensa_isa
name|isa
parameter_list|,
name|xtensa_opcode
name|opc
parameter_list|)
function_decl|;
specifier|extern
name|int
name|xtensa_opcode_is_loop
parameter_list|(
name|xtensa_isa
name|isa
parameter_list|,
name|xtensa_opcode
name|opc
parameter_list|)
function_decl|;
specifier|extern
name|int
name|xtensa_opcode_is_call
parameter_list|(
name|xtensa_isa
name|isa
parameter_list|,
name|xtensa_opcode
name|opc
parameter_list|)
function_decl|;
comment|/* Find the number of ordinary operands, state operands, and interface    operands for an instruction.  These return XTENSA_UNDEFINED on    error.  */
specifier|extern
name|int
name|xtensa_opcode_num_operands
parameter_list|(
name|xtensa_isa
name|isa
parameter_list|,
name|xtensa_opcode
name|opc
parameter_list|)
function_decl|;
specifier|extern
name|int
name|xtensa_opcode_num_stateOperands
parameter_list|(
name|xtensa_isa
name|isa
parameter_list|,
name|xtensa_opcode
name|opc
parameter_list|)
function_decl|;
specifier|extern
name|int
name|xtensa_opcode_num_interfaceOperands
parameter_list|(
name|xtensa_isa
name|isa
parameter_list|,
name|xtensa_opcode
name|opc
parameter_list|)
function_decl|;
comment|/* Get functional unit usage requirements for an opcode.  Each "use"    is identified by a<functional unit, pipeline stage> pair.  The    "num_funcUnit_uses" function returns the number of these "uses" or    XTENSA_UNDEFINED on error.  The "funcUnit_use" function returns    a pointer to a "use" pair or null on error.  */
typedef|typedef
struct|struct
name|xtensa_funcUnit_use_struct
block|{
name|xtensa_funcUnit
name|unit
decl_stmt|;
name|int
name|stage
decl_stmt|;
block|}
name|xtensa_funcUnit_use
typedef|;
specifier|extern
name|int
name|xtensa_opcode_num_funcUnit_uses
parameter_list|(
name|xtensa_isa
name|isa
parameter_list|,
name|xtensa_opcode
name|opc
parameter_list|)
function_decl|;
specifier|extern
name|xtensa_funcUnit_use
modifier|*
name|xtensa_opcode_funcUnit_use
parameter_list|(
name|xtensa_isa
name|isa
parameter_list|,
name|xtensa_opcode
name|opc
parameter_list|,
name|int
name|u
parameter_list|)
function_decl|;
comment|/* Operand information.  */
comment|/* Get the name of an operand.  Returns null on error.  */
specifier|extern
specifier|const
name|char
modifier|*
name|xtensa_operand_name
parameter_list|(
name|xtensa_isa
name|isa
parameter_list|,
name|xtensa_opcode
name|opc
parameter_list|,
name|int
name|opnd
parameter_list|)
function_decl|;
comment|/* Some operands are "invisible", i.e., not explicitly specified in    assembly language.  When assembling an instruction, you need not set    the values of invisible operands, since they are either hardwired or    derived from other field values.  The values of invisible operands    can be examined in the same way as other operands, but remember that    an invisible operand may get its value from another visible one, so    the entire instruction must be available before examining the    invisible operand values.  This function returns 1 if an operand is    visible, 0 if it is invisible, or XTENSA_UNDEFINED on error.  Note    that whether an operand is visible is orthogonal to whether it is    "implicit", i.e., whether it is encoded in a field in the    instruction.  */
specifier|extern
name|int
name|xtensa_operand_is_visible
parameter_list|(
name|xtensa_isa
name|isa
parameter_list|,
name|xtensa_opcode
name|opc
parameter_list|,
name|int
name|opnd
parameter_list|)
function_decl|;
comment|/* Check if an operand is an input ('i'), output ('o'), or inout ('m')    operand.  Note: The output operand of a conditional assignment    (e.g., movnez) appears here as an inout ('m') even if it is declared    in the TIE code as an output ('o'); this allows the compiler to    properly handle register allocation for conditional assignments.    Returns 0 on error.  */
specifier|extern
name|char
name|xtensa_operand_inout
parameter_list|(
name|xtensa_isa
name|isa
parameter_list|,
name|xtensa_opcode
name|opc
parameter_list|,
name|int
name|opnd
parameter_list|)
function_decl|;
comment|/* Get and set the raw (encoded) value of the field for the specified    operand.  The "set" function does not check if the value fits in the    field; that is done by the "encode" function below.  Both of these    functions return non-zero on error, e.g., if the field is not defined    for the specified slot.  */
specifier|extern
name|int
name|xtensa_operand_get_field
parameter_list|(
name|xtensa_isa
name|isa
parameter_list|,
name|xtensa_opcode
name|opc
parameter_list|,
name|int
name|opnd
parameter_list|,
name|xtensa_format
name|fmt
parameter_list|,
name|int
name|slot
parameter_list|,
specifier|const
name|xtensa_insnbuf
name|slotbuf
parameter_list|,
name|uint32
modifier|*
name|valp
parameter_list|)
function_decl|;
specifier|extern
name|int
name|xtensa_operand_set_field
parameter_list|(
name|xtensa_isa
name|isa
parameter_list|,
name|xtensa_opcode
name|opc
parameter_list|,
name|int
name|opnd
parameter_list|,
name|xtensa_format
name|fmt
parameter_list|,
name|int
name|slot
parameter_list|,
name|xtensa_insnbuf
name|slotbuf
parameter_list|,
name|uint32
name|val
parameter_list|)
function_decl|;
comment|/* Encode and decode operands.  The raw bits in the operand field may    be encoded in a variety of different ways.  These functions hide    the details of that encoding.  The result values are returned through    the argument pointer.  The return value is non-zero on error.  */
specifier|extern
name|int
name|xtensa_operand_encode
parameter_list|(
name|xtensa_isa
name|isa
parameter_list|,
name|xtensa_opcode
name|opc
parameter_list|,
name|int
name|opnd
parameter_list|,
name|uint32
modifier|*
name|valp
parameter_list|)
function_decl|;
specifier|extern
name|int
name|xtensa_operand_decode
parameter_list|(
name|xtensa_isa
name|isa
parameter_list|,
name|xtensa_opcode
name|opc
parameter_list|,
name|int
name|opnd
parameter_list|,
name|uint32
modifier|*
name|valp
parameter_list|)
function_decl|;
comment|/* An operand may be either a register operand or an immediate of some    sort (e.g., PC-relative or not).  The "is_register" function returns    0 if the operand is an immediate, 1 if it is a register, and    XTENSA_UNDEFINED on error.  The "regfile" function returns the    regfile for a register operand, or XTENSA_UNDEFINED on error.  */
specifier|extern
name|int
name|xtensa_operand_is_register
parameter_list|(
name|xtensa_isa
name|isa
parameter_list|,
name|xtensa_opcode
name|opc
parameter_list|,
name|int
name|opnd
parameter_list|)
function_decl|;
specifier|extern
name|xtensa_regfile
name|xtensa_operand_regfile
parameter_list|(
name|xtensa_isa
name|isa
parameter_list|,
name|xtensa_opcode
name|opc
parameter_list|,
name|int
name|opnd
parameter_list|)
function_decl|;
comment|/* Register operands may span multiple consecutive registers, e.g., a    64-bit data type may occupy two 32-bit registers.  Only the first    register is encoded in the operand field.  This function specifies    the number of consecutive registers occupied by this operand.  For    non-register operands, the return value is undefined.  Returns    XTENSA_UNDEFINED on error.  */
specifier|extern
name|int
name|xtensa_operand_num_regs
parameter_list|(
name|xtensa_isa
name|isa
parameter_list|,
name|xtensa_opcode
name|opc
parameter_list|,
name|int
name|opnd
parameter_list|)
function_decl|;
comment|/* Some register operands do not completely identify the register being    accessed.  For example, the operand value may be added to an internal    state value.  By definition, this implies that the corresponding    regfile is not allocatable.  Unknown registers should generally be    treated with worst-case assumptions.  The function returns 0 if the    register value is unknown, 1 if known, and XTENSA_UNDEFINED on    error.  */
specifier|extern
name|int
name|xtensa_operand_is_known_reg
parameter_list|(
name|xtensa_isa
name|isa
parameter_list|,
name|xtensa_opcode
name|opc
parameter_list|,
name|int
name|opnd
parameter_list|)
function_decl|;
comment|/* Check if an immediate operand is PC-relative.  Returns 0 for register    operands and non-PC-relative immediates, 1 for PC-relative    immediates, and XTENSA_UNDEFINED on error.  */
specifier|extern
name|int
name|xtensa_operand_is_PCrelative
parameter_list|(
name|xtensa_isa
name|isa
parameter_list|,
name|xtensa_opcode
name|opc
parameter_list|,
name|int
name|opnd
parameter_list|)
function_decl|;
comment|/* For PC-relative offset operands, the interpretation of the offset may    vary between opcodes, e.g., is it relative to the current PC or that    of the next instruction?  The following functions are defined to    perform PC-relative relocations and to undo them (as in the    disassembler).  The "do_reloc" function takes the desired address    value and the PC of the current instruction and sets the value to the    corresponding PC-relative offset (which can then be encoded and    stored into the operand field).  The "undo_reloc" function takes the    unencoded offset value and the current PC and sets the value to the    appropriate address.  The return values are non-zero on error.  Note    that these functions do not replace the encode/decode functions; the    operands must be encoded/decoded separately and the encode functions    are responsible for detecting invalid operand values.  */
specifier|extern
name|int
name|xtensa_operand_do_reloc
parameter_list|(
name|xtensa_isa
name|isa
parameter_list|,
name|xtensa_opcode
name|opc
parameter_list|,
name|int
name|opnd
parameter_list|,
name|uint32
modifier|*
name|valp
parameter_list|,
name|uint32
name|pc
parameter_list|)
function_decl|;
specifier|extern
name|int
name|xtensa_operand_undo_reloc
parameter_list|(
name|xtensa_isa
name|isa
parameter_list|,
name|xtensa_opcode
name|opc
parameter_list|,
name|int
name|opnd
parameter_list|,
name|uint32
modifier|*
name|valp
parameter_list|,
name|uint32
name|pc
parameter_list|)
function_decl|;
comment|/* State Operands.  */
comment|/* Get the state accessed by a state operand.  Returns XTENSA_UNDEFINED    on error.  */
specifier|extern
name|xtensa_state
name|xtensa_stateOperand_state
parameter_list|(
name|xtensa_isa
name|isa
parameter_list|,
name|xtensa_opcode
name|opc
parameter_list|,
name|int
name|stOp
parameter_list|)
function_decl|;
comment|/* Check if a state operand is an input ('i'), output ('o'), or inout    ('m') operand.  Returns 0 on error.  */
specifier|extern
name|char
name|xtensa_stateOperand_inout
parameter_list|(
name|xtensa_isa
name|isa
parameter_list|,
name|xtensa_opcode
name|opc
parameter_list|,
name|int
name|stOp
parameter_list|)
function_decl|;
comment|/* Interface Operands.  */
comment|/* Get the external interface accessed by an interface operand.    Returns XTENSA_UNDEFINED on error.  */
specifier|extern
name|xtensa_interface
name|xtensa_interfaceOperand_interface
parameter_list|(
name|xtensa_isa
name|isa
parameter_list|,
name|xtensa_opcode
name|opc
parameter_list|,
name|int
name|ifOp
parameter_list|)
function_decl|;
comment|/* Register Files.  */
comment|/* Regfiles include both "real" regfiles and "views", where a view    allows a group of adjacent registers in a real "parent" regfile to be    viewed as a single register.  A regfile view has all the same    properties as its parent except for its (long) name, bit width, number    of entries, and default ctype.  You can use the parent function to    distinguish these two classes.  */
comment|/* Look up a regfile by either its name or its abbreviated "short name".    Returns XTENSA_UNDEFINED on error.  The "lookup_shortname" function    ignores "view" regfiles since they always have the same shortname as    their parents.  */
specifier|extern
name|xtensa_regfile
name|xtensa_regfile_lookup
parameter_list|(
name|xtensa_isa
name|isa
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
function_decl|;
specifier|extern
name|xtensa_regfile
name|xtensa_regfile_lookup_shortname
parameter_list|(
name|xtensa_isa
name|isa
parameter_list|,
specifier|const
name|char
modifier|*
name|shortname
parameter_list|)
function_decl|;
comment|/* Get the name or abbreviated "short name" of a regfile.    Returns null on error.  */
specifier|extern
specifier|const
name|char
modifier|*
name|xtensa_regfile_name
parameter_list|(
name|xtensa_isa
name|isa
parameter_list|,
name|xtensa_regfile
name|rf
parameter_list|)
function_decl|;
specifier|extern
specifier|const
name|char
modifier|*
name|xtensa_regfile_shortname
parameter_list|(
name|xtensa_isa
name|isa
parameter_list|,
name|xtensa_regfile
name|rf
parameter_list|)
function_decl|;
comment|/* Get the parent regfile of a "view" regfile.  If the regfile is not a    view, the result is the same as the input parameter.  Returns    XTENSA_UNDEFINED on error.  */
specifier|extern
name|xtensa_regfile
name|xtensa_regfile_view_parent
parameter_list|(
name|xtensa_isa
name|isa
parameter_list|,
name|xtensa_regfile
name|rf
parameter_list|)
function_decl|;
comment|/* Get the bit width of a regfile or regfile view.    Returns XTENSA_UNDEFINED on error.  */
specifier|extern
name|int
name|xtensa_regfile_num_bits
parameter_list|(
name|xtensa_isa
name|isa
parameter_list|,
name|xtensa_regfile
name|rf
parameter_list|)
function_decl|;
comment|/* Get the number of regfile entries.  Returns XTENSA_UNDEFINED on    error.  */
specifier|extern
name|int
name|xtensa_regfile_num_entries
parameter_list|(
name|xtensa_isa
name|isa
parameter_list|,
name|xtensa_regfile
name|rf
parameter_list|)
function_decl|;
comment|/* Processor States.  */
comment|/* Look up a state by name.  Returns XTENSA_UNDEFINED on error.  */
specifier|extern
name|xtensa_state
name|xtensa_state_lookup
parameter_list|(
name|xtensa_isa
name|isa
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
function_decl|;
comment|/* Get the name for a processor state.  Returns null on error.  */
specifier|extern
specifier|const
name|char
modifier|*
name|xtensa_state_name
parameter_list|(
name|xtensa_isa
name|isa
parameter_list|,
name|xtensa_state
name|st
parameter_list|)
function_decl|;
comment|/* Get the bit width for a processor state.    Returns XTENSA_UNDEFINED on error.  */
specifier|extern
name|int
name|xtensa_state_num_bits
parameter_list|(
name|xtensa_isa
name|isa
parameter_list|,
name|xtensa_state
name|st
parameter_list|)
function_decl|;
comment|/* Check if a state is exported from the processor core.  Returns 0 if    the condition is false, 1 if the condition is true, and    XTENSA_UNDEFINED on error.  */
specifier|extern
name|int
name|xtensa_state_is_exported
parameter_list|(
name|xtensa_isa
name|isa
parameter_list|,
name|xtensa_state
name|st
parameter_list|)
function_decl|;
comment|/* Sysregs ("special registers" and "user registers").  */
comment|/* Look up a register by its number and whether it is a "user register"    or a "special register".  Returns XTENSA_UNDEFINED if the sysreg does    not exist.  */
specifier|extern
name|xtensa_sysreg
name|xtensa_sysreg_lookup
parameter_list|(
name|xtensa_isa
name|isa
parameter_list|,
name|int
name|num
parameter_list|,
name|int
name|is_user
parameter_list|)
function_decl|;
comment|/* Check if there exists a sysreg with a given name.    If not, this function returns XTENSA_UNDEFINED.  */
specifier|extern
name|xtensa_sysreg
name|xtensa_sysreg_lookup_name
parameter_list|(
name|xtensa_isa
name|isa
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
function_decl|;
comment|/* Get the name of a sysreg.  Returns null on error.  */
specifier|extern
specifier|const
name|char
modifier|*
name|xtensa_sysreg_name
parameter_list|(
name|xtensa_isa
name|isa
parameter_list|,
name|xtensa_sysreg
name|sysreg
parameter_list|)
function_decl|;
comment|/* Get the register number.  Returns XTENSA_UNDEFINED on error.  */
specifier|extern
name|int
name|xtensa_sysreg_number
parameter_list|(
name|xtensa_isa
name|isa
parameter_list|,
name|xtensa_sysreg
name|sysreg
parameter_list|)
function_decl|;
comment|/* Check if a sysreg is a "special register" or a "user register".    Returns 0 for special registers, 1 for user registers and    XTENSA_UNDEFINED on error.  */
specifier|extern
name|int
name|xtensa_sysreg_is_user
parameter_list|(
name|xtensa_isa
name|isa
parameter_list|,
name|xtensa_sysreg
name|sysreg
parameter_list|)
function_decl|;
comment|/* Interfaces.  */
comment|/* Find an interface by name.  The return value is XTENSA_UNDEFINED if    the specified interface is not found.  */
specifier|extern
name|xtensa_interface
name|xtensa_interface_lookup
parameter_list|(
name|xtensa_isa
name|isa
parameter_list|,
specifier|const
name|char
modifier|*
name|ifname
parameter_list|)
function_decl|;
comment|/* Get the name of an interface.  Returns null on error.  */
specifier|extern
specifier|const
name|char
modifier|*
name|xtensa_interface_name
parameter_list|(
name|xtensa_isa
name|isa
parameter_list|,
name|xtensa_interface
name|intf
parameter_list|)
function_decl|;
comment|/* Get the bit width for an interface.    Returns XTENSA_UNDEFINED on error.  */
specifier|extern
name|int
name|xtensa_interface_num_bits
parameter_list|(
name|xtensa_isa
name|isa
parameter_list|,
name|xtensa_interface
name|intf
parameter_list|)
function_decl|;
comment|/* Check if an interface is an input ('i') or output ('o') with respect    to the Xtensa processor core.  Returns 0 on error.  */
specifier|extern
name|char
name|xtensa_interface_inout
parameter_list|(
name|xtensa_isa
name|isa
parameter_list|,
name|xtensa_interface
name|intf
parameter_list|)
function_decl|;
comment|/* Check if accessing an interface has potential side effects.    Currently "data" interfaces have side effects and "control"    interfaces do not.  Returns 1 if there are side effects, 0 if not,    and XTENSA_UNDEFINED on error.  */
specifier|extern
name|int
name|xtensa_interface_has_side_effect
parameter_list|(
name|xtensa_isa
name|isa
parameter_list|,
name|xtensa_interface
name|intf
parameter_list|)
function_decl|;
comment|/* Some interfaces may be related such that accessing one interface    has side effects on a set of related interfaces.  The interfaces    are partitioned into equivalence classes of related interfaces, and    each class is assigned a unique identifier number.  This function    returns the class identifier for an interface, or XTENSA_UNDEFINED    on error.  These identifiers can be compared to determine if two    interfaces are related; the specific values of the identifiers have    no particular meaning otherwise.  */
specifier|extern
name|int
name|xtensa_interface_class_id
parameter_list|(
name|xtensa_isa
name|isa
parameter_list|,
name|xtensa_interface
name|intf
parameter_list|)
function_decl|;
comment|/* Functional Units.  */
comment|/* Find a functional unit by name.  The return value is XTENSA_UNDEFINED if    the specified unit is not found.  */
specifier|extern
name|xtensa_funcUnit
name|xtensa_funcUnit_lookup
parameter_list|(
name|xtensa_isa
name|isa
parameter_list|,
specifier|const
name|char
modifier|*
name|fname
parameter_list|)
function_decl|;
comment|/* Get the name of a functional unit.  Returns null on error.  */
specifier|extern
specifier|const
name|char
modifier|*
name|xtensa_funcUnit_name
parameter_list|(
name|xtensa_isa
name|isa
parameter_list|,
name|xtensa_funcUnit
name|fun
parameter_list|)
function_decl|;
comment|/* Functional units may be replicated.  See how many instances of a    particular function unit exist.  Returns XTENSA_UNDEFINED on error.  */
specifier|extern
name|int
name|xtensa_funcUnit_num_copies
parameter_list|(
name|xtensa_isa
name|isa
parameter_list|,
name|xtensa_funcUnit
name|fun
parameter_list|)
function_decl|;
ifdef|#
directive|ifdef
name|__cplusplus
block|}
end_extern

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* XTENSA_LIBISA_H */
end_comment

end_unit

