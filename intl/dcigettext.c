begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Implementation of the internal dcigettext function.    Copyright (C) 1995-1999, 2000-2003 Free Software Foundation, Inc.     This program is free software; you can redistribute it and/or modify it    under the terms of the GNU Library General Public License as published    by the Free Software Foundation; either version 2, or (at your option)    any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU    Library General Public License for more details.     You should have received a copy of the GNU Library General Public    License along with this program; if not, write to the Free Software    Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301,    USA.  */
end_comment

begin_comment
comment|/* Tell glibc's<string.h> to provide a prototype for mempcpy().    This must come before<config.h> because<config.h> may include<features.h>, and once<features.h> has been included, it's too late.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|_GNU_SOURCE
end_ifndef

begin_define
define|#
directive|define
name|_GNU_SOURCE
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_CONFIG_H
end_ifdef

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|__GNUC__
end_ifdef

begin_define
define|#
directive|define
name|alloca
value|__builtin_alloca
end_define

begin_define
define|#
directive|define
name|HAVE_ALLOCA
value|1
end_define

begin_else
else|#
directive|else
end_else

begin_ifdef
ifdef|#
directive|ifdef
name|_MSC_VER
end_ifdef

begin_include
include|#
directive|include
file|<malloc.h>
end_include

begin_define
define|#
directive|define
name|alloca
value|_alloca
end_define

begin_else
else|#
directive|else
end_else

begin_if
if|#
directive|if
name|defined
name|HAVE_ALLOCA_H
operator|||
name|defined
name|_LIBC
end_if

begin_include
include|#
directive|include
file|<alloca.h>
end_include

begin_else
else|#
directive|else
end_else

begin_ifdef
ifdef|#
directive|ifdef
name|_AIX
end_ifdef

begin_pragma
pragma|#
directive|pragma
name|alloca
end_pragma

begin_else
else|#
directive|else
end_else

begin_ifndef
ifndef|#
directive|ifndef
name|alloca
end_ifndef

begin_function_decl
name|char
modifier|*
name|alloca
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|errno
end_ifndef

begin_decl_stmt
specifier|extern
name|int
name|errno
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|__set_errno
end_ifndef

begin_define
define|#
directive|define
name|__set_errno
parameter_list|(
name|val
parameter_list|)
value|errno = (val)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<stddef.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_if
if|#
directive|if
name|defined
name|HAVE_UNISTD_H
operator|||
name|defined
name|_LIBC
end_if

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<locale.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|_LIBC
end_ifdef

begin_comment
comment|/* Guess whether integer division by zero raises signal SIGFPE.      Set to 1 only if you know for sure.  In case of doubt, set to 0.  */
end_comment

begin_if
if|#
directive|if
name|defined
name|__alpha__
operator|||
name|defined
name|__arm__
operator|||
name|defined
name|__i386__
expr|\
operator|||
name|defined
name|__m68k__
operator|||
name|defined
name|__s390__
end_if

begin_define
define|#
directive|define
name|INTDIV0_RAISES_SIGFPE
value|1
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|INTDIV0_RAISES_SIGFPE
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|INTDIV0_RAISES_SIGFPE
end_if

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
name|HAVE_SYS_PARAM_H
operator|||
name|defined
name|_LIBC
end_if

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"gettextP.h"
end_include

begin_include
include|#
directive|include
file|"plural-exp.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|_LIBC
end_ifdef

begin_include
include|#
directive|include
file|<libintl.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|"libgnuintl.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"hash-string.h"
end_include

begin_comment
comment|/* Thread safetyness.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|_LIBC
end_ifdef

begin_include
include|#
directive|include
file|<bits/libc-lock.h>
end_include

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* Provide dummy implementation if this is outside glibc.  */
end_comment

begin_define
define|#
directive|define
name|__libc_lock_define_initialized
parameter_list|(
name|CLASS
parameter_list|,
name|NAME
parameter_list|)
end_define

begin_define
define|#
directive|define
name|__libc_lock_lock
parameter_list|(
name|NAME
parameter_list|)
end_define

begin_define
define|#
directive|define
name|__libc_lock_unlock
parameter_list|(
name|NAME
parameter_list|)
end_define

begin_define
define|#
directive|define
name|__libc_rwlock_define_initialized
parameter_list|(
name|CLASS
parameter_list|,
name|NAME
parameter_list|)
end_define

begin_define
define|#
directive|define
name|__libc_rwlock_rdlock
parameter_list|(
name|NAME
parameter_list|)
end_define

begin_define
define|#
directive|define
name|__libc_rwlock_unlock
parameter_list|(
name|NAME
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Alignment of types.  */
end_comment

begin_if
if|#
directive|if
name|defined
name|__GNUC__
operator|&&
name|__GNUC__
operator|>=
literal|2
end_if

begin_define
define|#
directive|define
name|alignof
parameter_list|(
name|TYPE
parameter_list|)
value|__alignof__ (TYPE)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|alignof
parameter_list|(
name|TYPE
parameter_list|)
define|\
value|((int)&((struct { char dummy1; TYPE dummy2; } *) 0)->dummy2)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* The internal variables in the standalone libintl.a must have different    names than the internal variables in GNU libc, otherwise programs    using libintl.a cannot be linked statically.  */
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
name|_LIBC
end_if

begin_define
define|#
directive|define
name|_nl_default_default_domain
value|libintl_nl_default_default_domain
end_define

begin_define
define|#
directive|define
name|_nl_current_default_domain
value|libintl_nl_current_default_domain
end_define

begin_define
define|#
directive|define
name|_nl_default_dirname
value|libintl_nl_default_dirname
end_define

begin_define
define|#
directive|define
name|_nl_domain_bindings
value|libintl_nl_domain_bindings
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Some compilers, like SunOS4 cc, don't have offsetof in<stddef.h>.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|offsetof
end_ifndef

begin_define
define|#
directive|define
name|offsetof
parameter_list|(
name|type
parameter_list|,
name|ident
parameter_list|)
value|((size_t)&(((type*)0)->ident))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* @@ end of prolog @@ */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|_LIBC
end_ifdef

begin_comment
comment|/* Rename the non ANSI C functions.  This is required by the standard    because some ANSI C functions will require linking with this object    file and the name space must not be polluted.  */
end_comment

begin_define
define|#
directive|define
name|getcwd
value|__getcwd
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|stpcpy
end_ifndef

begin_define
define|#
directive|define
name|stpcpy
value|__stpcpy
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|tfind
value|__tfind
end_define

begin_else
else|#
directive|else
end_else

begin_if
if|#
directive|if
operator|!
name|defined
name|HAVE_GETCWD
end_if

begin_function_decl
name|char
modifier|*
name|getwd
parameter_list|()
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|getcwd
parameter_list|(
name|buf
parameter_list|,
name|max
parameter_list|)
value|getwd (buf)
end_define

begin_else
else|#
directive|else
end_else

begin_function_decl
name|char
modifier|*
name|getcwd
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|HAVE_STPCPY
end_ifndef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|stpcpy
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
name|dest
operator|,
specifier|const
name|char
operator|*
name|src
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|HAVE_MEMPCPY
end_ifndef

begin_decl_stmt
specifier|static
name|void
modifier|*
name|mempcpy
name|PARAMS
argument_list|(
operator|(
name|void
operator|*
name|dest
operator|,
specifier|const
name|void
operator|*
name|src
operator|,
name|size_t
name|n
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Amount to increase buffer size by in each try.  */
end_comment

begin_define
define|#
directive|define
name|PATH_INCR
value|32
end_define

begin_comment
comment|/* The following is from pathmax.h.  */
end_comment

begin_comment
comment|/* Non-POSIX BSD systems might have gcc's limits.h, which doesn't define    PATH_MAX but might cause redefinition warnings when sys/param.h is    later included (as on MORE/BSD 4.3).  */
end_comment

begin_if
if|#
directive|if
name|defined
name|_POSIX_VERSION
operator|||
operator|(
name|defined
name|HAVE_LIMITS_H
operator|&&
operator|!
name|defined
name|__GNUC__
operator|)
end_if

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|_POSIX_PATH_MAX
end_ifndef

begin_define
define|#
directive|define
name|_POSIX_PATH_MAX
value|255
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
name|PATH_MAX
operator|&&
name|defined
name|_PC_PATH_MAX
end_if

begin_define
define|#
directive|define
name|PATH_MAX
value|(pathconf ("/", _PC_PATH_MAX)< 1 ? 1024 : pathconf ("/", _PC_PATH_MAX))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Don't include sys/param.h if it already has been.  */
end_comment

begin_if
if|#
directive|if
name|defined
name|HAVE_SYS_PARAM_H
operator|&&
operator|!
name|defined
name|PATH_MAX
operator|&&
operator|!
name|defined
name|MAXPATHLEN
end_if

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
name|PATH_MAX
operator|&&
name|defined
name|MAXPATHLEN
end_if

begin_define
define|#
directive|define
name|PATH_MAX
value|MAXPATHLEN
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|PATH_MAX
end_ifndef

begin_define
define|#
directive|define
name|PATH_MAX
value|_POSIX_PATH_MAX
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Pathname support.    ISSLASH(C)           tests whether C is a directory separator character.    IS_ABSOLUTE_PATH(P)  tests whether P is an absolute path.  If it is not,                         it may be concatenated to a directory pathname.    IS_PATH_WITH_DIR(P)  tests whether P contains a directory specification.  */
end_comment

begin_if
if|#
directive|if
name|defined
name|_WIN32
operator|||
name|defined
name|__WIN32__
operator|||
name|defined
name|__EMX__
operator|||
name|defined
name|__DJGPP__
end_if

begin_comment
comment|/* Win32, OS/2, DOS */
end_comment

begin_define
define|#
directive|define
name|ISSLASH
parameter_list|(
name|C
parameter_list|)
value|((C) == '/' || (C) == '\\')
end_define

begin_define
define|#
directive|define
name|HAS_DEVICE
parameter_list|(
name|P
parameter_list|)
define|\
value|((((P)[0]>= 'A'&& (P)[0]<= 'Z') || ((P)[0]>= 'a'&& (P)[0]<= 'z')) \&& (P)[1] == ':')
end_define

begin_define
define|#
directive|define
name|IS_ABSOLUTE_PATH
parameter_list|(
name|P
parameter_list|)
value|(ISSLASH ((P)[0]) || HAS_DEVICE (P))
end_define

begin_define
define|#
directive|define
name|IS_PATH_WITH_DIR
parameter_list|(
name|P
parameter_list|)
define|\
value|(strchr (P, '/') != NULL || strchr (P, '\\') != NULL || HAS_DEVICE (P))
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* Unix */
end_comment

begin_define
define|#
directive|define
name|ISSLASH
parameter_list|(
name|C
parameter_list|)
value|((C) == '/')
end_define

begin_define
define|#
directive|define
name|IS_ABSOLUTE_PATH
parameter_list|(
name|P
parameter_list|)
value|ISSLASH ((P)[0])
end_define

begin_define
define|#
directive|define
name|IS_PATH_WITH_DIR
parameter_list|(
name|P
parameter_list|)
value|(strchr (P, '/') != NULL)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* This is the type used for the search tree where known translations    are stored.  */
end_comment

begin_struct
struct|struct
name|known_translation_t
block|{
comment|/* Domain in which to search.  */
name|char
modifier|*
name|domainname
decl_stmt|;
comment|/* The category.  */
name|int
name|category
decl_stmt|;
comment|/* State of the catalog counter at the point the string was found.  */
name|int
name|counter
decl_stmt|;
comment|/* Catalog where the string was found.  */
name|struct
name|loaded_l10nfile
modifier|*
name|domain
decl_stmt|;
comment|/* And finally the translation.  */
specifier|const
name|char
modifier|*
name|translation
decl_stmt|;
name|size_t
name|translation_length
decl_stmt|;
comment|/* Pointer to the string in question.  */
name|char
name|msgid
index|[
name|ZERO
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Root of the search tree with known translations.  We can use this    only if the system provides the `tsearch' function family.  */
end_comment

begin_if
if|#
directive|if
name|defined
name|HAVE_TSEARCH
operator|||
name|defined
name|_LIBC
end_if

begin_include
include|#
directive|include
file|<search.h>
end_include

begin_decl_stmt
specifier|static
name|void
modifier|*
name|root
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|_LIBC
end_ifdef

begin_define
define|#
directive|define
name|tsearch
value|__tsearch
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Function to compare two entries in the table of known translations.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|transcmp
name|PARAMS
argument_list|(
operator|(
specifier|const
name|void
operator|*
name|p1
operator|,
specifier|const
name|void
operator|*
name|p2
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|transcmp
parameter_list|(
name|p1
parameter_list|,
name|p2
parameter_list|)
specifier|const
name|void
modifier|*
name|p1
decl_stmt|;
specifier|const
name|void
modifier|*
name|p2
decl_stmt|;
block|{
specifier|const
name|struct
name|known_translation_t
modifier|*
name|s1
decl_stmt|;
specifier|const
name|struct
name|known_translation_t
modifier|*
name|s2
decl_stmt|;
name|int
name|result
decl_stmt|;
name|s1
operator|=
operator|(
specifier|const
expr|struct
name|known_translation_t
operator|*
operator|)
name|p1
expr_stmt|;
name|s2
operator|=
operator|(
specifier|const
expr|struct
name|known_translation_t
operator|*
operator|)
name|p2
expr_stmt|;
name|result
operator|=
name|strcmp
argument_list|(
name|s1
operator|->
name|msgid
argument_list|,
name|s2
operator|->
name|msgid
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
literal|0
condition|)
block|{
name|result
operator|=
name|strcmp
argument_list|(
name|s1
operator|->
name|domainname
argument_list|,
name|s2
operator|->
name|domainname
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
literal|0
condition|)
comment|/* We compare the category last (though this is the cheapest 	   operation) since it is hopefully always the same (namely 	   LC_MESSAGES).  */
name|result
operator|=
name|s1
operator|->
name|category
operator|-
name|s2
operator|->
name|category
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|INTVARDEF
end_ifndef

begin_define
define|#
directive|define
name|INTVARDEF
parameter_list|(
name|name
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|INTUSE
end_ifndef

begin_define
define|#
directive|define
name|INTUSE
parameter_list|(
name|name
parameter_list|)
value|name
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Name of the default domain used for gettext(3) prior any call to    textdomain(3).  The default value for this is "messages".  */
end_comment

begin_decl_stmt
specifier|const
name|char
name|_nl_default_default_domain
index|[]
name|attribute_hidden
init|=
literal|"messages"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Value used as the default domain for gettext(3).  */
end_comment

begin_decl_stmt
specifier|const
name|char
modifier|*
name|_nl_current_default_domain
name|attribute_hidden
init|=
name|_nl_default_default_domain
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Contains the default location of the message catalogs.  */
end_comment

begin_if
if|#
directive|if
name|defined
name|__EMX__
end_if

begin_decl_stmt
specifier|extern
specifier|const
name|char
name|_nl_default_dirname
index|[]
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_decl_stmt
specifier|const
name|char
name|_nl_default_dirname
index|[]
init|=
name|LOCALEDIR
decl_stmt|;
end_decl_stmt

begin_macro
name|INTVARDEF
argument_list|(
argument|_nl_default_dirname
argument_list|)
end_macro

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* List with bindings of specific domains created by bindtextdomain()    calls.  */
end_comment

begin_decl_stmt
name|struct
name|binding
modifier|*
name|_nl_domain_bindings
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Prototypes for local functions.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|plural_lookup
name|PARAMS
argument_list|(
operator|(
expr|struct
name|loaded_l10nfile
operator|*
name|domain
operator|,
name|unsigned
name|long
name|int
name|n
operator|,
specifier|const
name|char
operator|*
name|translation
operator|,
name|size_t
name|translation_len
operator|)
argument_list|)
name|internal_function
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|guess_category_value
name|PARAMS
argument_list|(
operator|(
name|int
name|category
operator|,
specifier|const
name|char
operator|*
name|categoryname
operator|)
argument_list|)
name|internal_function
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|_LIBC
end_ifdef

begin_include
include|#
directive|include
file|"../locale/localeinfo.h"
end_include

begin_define
define|#
directive|define
name|category_to_name
parameter_list|(
name|category
parameter_list|)
value|_nl_category_names[category]
end_define

begin_else
else|#
directive|else
end_else

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|category_to_name
name|PARAMS
argument_list|(
operator|(
name|int
name|category
operator|)
argument_list|)
name|internal_function
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* For those loosing systems which don't have `alloca' we have to add    some additional code emulating it.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_ALLOCA
end_ifdef

begin_comment
comment|/* Nothing has to be done.  */
end_comment

begin_define
define|#
directive|define
name|freea
parameter_list|(
name|p
parameter_list|)
end_define

begin_comment
comment|/* nothing */
end_comment

begin_define
define|#
directive|define
name|ADD_BLOCK
parameter_list|(
name|list
parameter_list|,
name|address
parameter_list|)
end_define

begin_comment
comment|/* nothing */
end_comment

begin_define
define|#
directive|define
name|FREE_BLOCKS
parameter_list|(
name|list
parameter_list|)
end_define

begin_comment
comment|/* nothing */
end_comment

begin_else
else|#
directive|else
end_else

begin_struct
struct|struct
name|block_list
block|{
name|void
modifier|*
name|address
decl_stmt|;
name|struct
name|block_list
modifier|*
name|next
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|ADD_BLOCK
parameter_list|(
name|list
parameter_list|,
name|addr
parameter_list|)
define|\
value|do {									      \     struct block_list *newp = (struct block_list *) malloc (sizeof (*newp));  \
comment|/* If we cannot get a free block we cannot add the new element to	      \        the list.  */
value|\     if (newp != NULL) {							      \       newp->address = (addr);						      \       newp->next = (list);						      \       (list) = newp;							      \     }									      \   } while (0)
end_define

begin_define
define|#
directive|define
name|FREE_BLOCKS
parameter_list|(
name|list
parameter_list|)
define|\
value|do {									      \     while (list != NULL) {						      \       struct block_list *old = list;					      \       list = list->next;						      \       free (old->address);						      \       free (old);							      \     }									      \   } while (0)
end_define

begin_undef
undef|#
directive|undef
name|alloca
end_undef

begin_define
define|#
directive|define
name|alloca
parameter_list|(
name|size
parameter_list|)
value|(malloc (size))
end_define

begin_define
define|#
directive|define
name|freea
parameter_list|(
name|p
parameter_list|)
value|free (p)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* have alloca */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|_LIBC
end_ifdef

begin_comment
comment|/* List of blocks allocated for translations.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|transmem_list
block|{
name|struct
name|transmem_list
modifier|*
name|next
decl_stmt|;
name|char
name|data
index|[
name|ZERO
index|]
decl_stmt|;
block|}
name|transmem_block_t
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|struct
name|transmem_list
modifier|*
name|transmem_list
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_typedef
typedef|typedef
name|unsigned
name|char
name|transmem_block_t
typedef|;
end_typedef

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Names for the libintl functions are a problem.  They must not clash    with existing names and they should follow ANSI C.  But this source    code is also used in GNU C Library where the names have a __    prefix.  So we have to make a difference here.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|_LIBC
end_ifdef

begin_define
define|#
directive|define
name|DCIGETTEXT
value|__dcigettext
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|DCIGETTEXT
value|libintl_dcigettext
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Lock variable to protect the global data in the gettext implementation.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|_LIBC
end_ifdef

begin_macro
name|__libc_rwlock_define_initialized
argument_list|(
argument_list|,
argument|_nl_state_lock attribute_hidden
argument_list|)
end_macro

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Checking whether the binaries runs SUID must be done and glibc provides    easier methods therefore we make a difference here.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|_LIBC
end_ifdef

begin_define
define|#
directive|define
name|ENABLE_SECURE
value|__libc_enable_secure
end_define

begin_define
define|#
directive|define
name|DETERMINE_SECURE
end_define

begin_else
else|#
directive|else
end_else

begin_ifndef
ifndef|#
directive|ifndef
name|HAVE_GETUID
end_ifndef

begin_define
define|#
directive|define
name|getuid
parameter_list|()
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|HAVE_GETGID
end_ifndef

begin_define
define|#
directive|define
name|getgid
parameter_list|()
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|HAVE_GETEUID
end_ifndef

begin_define
define|#
directive|define
name|geteuid
parameter_list|()
value|getuid()
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|HAVE_GETEGID
end_ifndef

begin_define
define|#
directive|define
name|getegid
parameter_list|()
value|getgid()
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|int
name|enable_secure
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|ENABLE_SECURE
value|(enable_secure == 1)
end_define

begin_define
define|#
directive|define
name|DETERMINE_SECURE
define|\
value|if (enable_secure == 0)						      \     {									      \       if (getuid () != geteuid () || getgid () != getegid ())		      \ 	enable_secure = 1;						      \       else								      \ 	enable_secure = -1;						      \     }
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Get the function to evaluate the plural expression.  */
end_comment

begin_include
include|#
directive|include
file|"eval-plural.h"
end_include

begin_comment
comment|/* Look up MSGID in the DOMAINNAME message catalog for the current    CATEGORY locale and, if PLURAL is nonzero, search over string    depending on the plural form determined by N.  */
end_comment

begin_function
name|char
modifier|*
name|DCIGETTEXT
parameter_list|(
name|domainname
parameter_list|,
name|msgid1
parameter_list|,
name|msgid2
parameter_list|,
name|plural
parameter_list|,
name|n
parameter_list|,
name|category
parameter_list|)
specifier|const
name|char
modifier|*
name|domainname
decl_stmt|;
specifier|const
name|char
modifier|*
name|msgid1
decl_stmt|;
specifier|const
name|char
modifier|*
name|msgid2
decl_stmt|;
name|int
name|plural
decl_stmt|;
name|unsigned
name|long
name|int
name|n
decl_stmt|;
name|int
name|category
decl_stmt|;
block|{
ifndef|#
directive|ifndef
name|HAVE_ALLOCA
name|struct
name|block_list
modifier|*
name|block_list
init|=
name|NULL
decl_stmt|;
endif|#
directive|endif
name|struct
name|loaded_l10nfile
modifier|*
name|domain
decl_stmt|;
name|struct
name|binding
modifier|*
name|binding
decl_stmt|;
specifier|const
name|char
modifier|*
name|categoryname
decl_stmt|;
specifier|const
name|char
modifier|*
name|categoryvalue
decl_stmt|;
name|char
modifier|*
name|dirname
decl_stmt|,
modifier|*
name|xdomainname
decl_stmt|;
name|char
modifier|*
name|single_locale
decl_stmt|;
name|char
modifier|*
name|retval
decl_stmt|;
name|size_t
name|retlen
decl_stmt|;
name|int
name|saved_errno
decl_stmt|;
if|#
directive|if
name|defined
name|HAVE_TSEARCH
operator|||
name|defined
name|_LIBC
name|struct
name|known_translation_t
modifier|*
name|search
decl_stmt|;
name|struct
name|known_translation_t
modifier|*
modifier|*
name|foundp
init|=
name|NULL
decl_stmt|;
name|size_t
name|msgid_len
decl_stmt|;
endif|#
directive|endif
name|size_t
name|domainname_len
decl_stmt|;
comment|/* If no real MSGID is given return NULL.  */
if|if
condition|(
name|msgid1
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
ifdef|#
directive|ifdef
name|_LIBC
if|if
condition|(
name|category
operator|<
literal|0
operator|||
name|category
operator|>=
name|__LC_LAST
operator|||
name|category
operator|==
name|LC_ALL
condition|)
comment|/* Bogus.  */
return|return
operator|(
name|plural
operator|==
literal|0
condition|?
operator|(
name|char
operator|*
operator|)
name|msgid1
comment|/* Use the Germanic plural rule.  */
else|:
name|n
operator|==
literal|1
condition|?
operator|(
name|char
operator|*
operator|)
name|msgid1
else|:
operator|(
name|char
operator|*
operator|)
name|msgid2
operator|)
return|;
endif|#
directive|endif
name|__libc_rwlock_rdlock
argument_list|(
name|_nl_state_lock
argument_list|)
expr_stmt|;
comment|/* If DOMAINNAME is NULL, we are interested in the default domain.  If      CATEGORY is not LC_MESSAGES this might not make much sense but the      definition left this undefined.  */
if|if
condition|(
name|domainname
operator|==
name|NULL
condition|)
name|domainname
operator|=
name|_nl_current_default_domain
expr_stmt|;
comment|/* OS/2 specific: backward compatibility with older libintl versions  */
ifdef|#
directive|ifdef
name|LC_MESSAGES_COMPAT
if|if
condition|(
name|category
operator|==
name|LC_MESSAGES_COMPAT
condition|)
name|category
operator|=
name|LC_MESSAGES
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
name|HAVE_TSEARCH
operator|||
name|defined
name|_LIBC
name|msgid_len
operator|=
name|strlen
argument_list|(
name|msgid1
argument_list|)
operator|+
literal|1
expr_stmt|;
comment|/* Try to find the translation among those which we found at      some time.  */
name|search
operator|=
operator|(
expr|struct
name|known_translation_t
operator|*
operator|)
name|alloca
argument_list|(
name|offsetof
argument_list|(
expr|struct
name|known_translation_t
argument_list|,
name|msgid
argument_list|)
operator|+
name|msgid_len
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|search
operator|->
name|msgid
argument_list|,
name|msgid1
argument_list|,
name|msgid_len
argument_list|)
expr_stmt|;
name|search
operator|->
name|domainname
operator|=
operator|(
name|char
operator|*
operator|)
name|domainname
expr_stmt|;
name|search
operator|->
name|category
operator|=
name|category
expr_stmt|;
name|foundp
operator|=
operator|(
expr|struct
name|known_translation_t
operator|*
operator|*
operator|)
name|tfind
argument_list|(
name|search
argument_list|,
operator|&
name|root
argument_list|,
name|transcmp
argument_list|)
expr_stmt|;
name|freea
argument_list|(
name|search
argument_list|)
expr_stmt|;
if|if
condition|(
name|foundp
operator|!=
name|NULL
operator|&&
operator|(
operator|*
name|foundp
operator|)
operator|->
name|counter
operator|==
name|_nl_msg_cat_cntr
condition|)
block|{
comment|/* Now deal with plural.  */
if|if
condition|(
name|plural
condition|)
name|retval
operator|=
name|plural_lookup
argument_list|(
operator|(
operator|*
name|foundp
operator|)
operator|->
name|domain
argument_list|,
name|n
argument_list|,
operator|(
operator|*
name|foundp
operator|)
operator|->
name|translation
argument_list|,
operator|(
operator|*
name|foundp
operator|)
operator|->
name|translation_length
argument_list|)
expr_stmt|;
else|else
name|retval
operator|=
operator|(
name|char
operator|*
operator|)
operator|(
operator|*
name|foundp
operator|)
operator|->
name|translation
expr_stmt|;
name|__libc_rwlock_unlock
argument_list|(
name|_nl_state_lock
argument_list|)
expr_stmt|;
return|return
name|retval
return|;
block|}
endif|#
directive|endif
comment|/* Preserve the `errno' value.  */
name|saved_errno
operator|=
name|errno
expr_stmt|;
comment|/* See whether this is a SUID binary or not.  */
name|DETERMINE_SECURE
expr_stmt|;
comment|/* First find matching binding.  */
for|for
control|(
name|binding
operator|=
name|_nl_domain_bindings
init|;
name|binding
operator|!=
name|NULL
condition|;
name|binding
operator|=
name|binding
operator|->
name|next
control|)
block|{
name|int
name|compare
init|=
name|strcmp
argument_list|(
name|domainname
argument_list|,
name|binding
operator|->
name|domainname
argument_list|)
decl_stmt|;
if|if
condition|(
name|compare
operator|==
literal|0
condition|)
comment|/* We found it!  */
break|break;
if|if
condition|(
name|compare
operator|<
literal|0
condition|)
block|{
comment|/* It is not in the list.  */
name|binding
operator|=
name|NULL
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|binding
operator|==
name|NULL
condition|)
name|dirname
operator|=
operator|(
name|char
operator|*
operator|)
name|INTUSE
argument_list|(
name|_nl_default_dirname
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|IS_ABSOLUTE_PATH
argument_list|(
name|binding
operator|->
name|dirname
argument_list|)
condition|)
name|dirname
operator|=
name|binding
operator|->
name|dirname
expr_stmt|;
else|else
block|{
comment|/* We have a relative path.  Make it absolute now.  */
name|size_t
name|dirname_len
init|=
name|strlen
argument_list|(
name|binding
operator|->
name|dirname
argument_list|)
operator|+
literal|1
decl_stmt|;
name|size_t
name|path_max
decl_stmt|;
name|char
modifier|*
name|ret
decl_stmt|;
name|path_max
operator|=
operator|(
name|unsigned
name|int
operator|)
name|PATH_MAX
expr_stmt|;
name|path_max
operator|+=
literal|2
expr_stmt|;
comment|/* The getcwd docs say to do this.  */
for|for
control|(
init|;
condition|;
control|)
block|{
name|dirname
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|path_max
operator|+
name|dirname_len
argument_list|)
expr_stmt|;
name|ADD_BLOCK
argument_list|(
name|block_list
argument_list|,
name|dirname
argument_list|)
expr_stmt|;
name|__set_errno
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|ret
operator|=
name|getcwd
argument_list|(
name|dirname
argument_list|,
name|path_max
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|NULL
operator|||
name|errno
operator|!=
name|ERANGE
condition|)
break|break;
name|path_max
operator|+=
name|path_max
operator|/
literal|2
expr_stmt|;
name|path_max
operator|+=
name|PATH_INCR
expr_stmt|;
block|}
if|if
condition|(
name|ret
operator|==
name|NULL
condition|)
comment|/* We cannot get the current working directory.  Don't signal an 	   error but simply return the default string.  */
goto|goto
name|return_untranslated
goto|;
name|stpcpy
argument_list|(
name|stpcpy
argument_list|(
name|strchr
argument_list|(
name|dirname
argument_list|,
literal|'\0'
argument_list|)
argument_list|,
literal|"/"
argument_list|)
argument_list|,
name|binding
operator|->
name|dirname
argument_list|)
expr_stmt|;
block|}
comment|/* Now determine the symbolic name of CATEGORY and its value.  */
name|categoryname
operator|=
name|category_to_name
argument_list|(
name|category
argument_list|)
expr_stmt|;
name|categoryvalue
operator|=
name|guess_category_value
argument_list|(
name|category
argument_list|,
name|categoryname
argument_list|)
expr_stmt|;
name|domainname_len
operator|=
name|strlen
argument_list|(
name|domainname
argument_list|)
expr_stmt|;
name|xdomainname
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|strlen
argument_list|(
name|categoryname
argument_list|)
operator|+
name|domainname_len
operator|+
literal|5
argument_list|)
expr_stmt|;
name|ADD_BLOCK
argument_list|(
name|block_list
argument_list|,
name|xdomainname
argument_list|)
expr_stmt|;
name|stpcpy
argument_list|(
name|mempcpy
argument_list|(
name|stpcpy
argument_list|(
name|stpcpy
argument_list|(
name|xdomainname
argument_list|,
name|categoryname
argument_list|)
argument_list|,
literal|"/"
argument_list|)
argument_list|,
name|domainname
argument_list|,
name|domainname_len
argument_list|)
argument_list|,
literal|".mo"
argument_list|)
expr_stmt|;
comment|/* Creating working area.  */
name|single_locale
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|strlen
argument_list|(
name|categoryvalue
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|ADD_BLOCK
argument_list|(
name|block_list
argument_list|,
name|single_locale
argument_list|)
expr_stmt|;
comment|/* Search for the given string.  This is a loop because we perhaps      got an ordered list of languages to consider for the translation.  */
while|while
condition|(
literal|1
condition|)
block|{
comment|/* Make CATEGORYVALUE point to the next element of the list.  */
while|while
condition|(
name|categoryvalue
index|[
literal|0
index|]
operator|!=
literal|'\0'
operator|&&
name|categoryvalue
index|[
literal|0
index|]
operator|==
literal|':'
condition|)
operator|++
name|categoryvalue
expr_stmt|;
if|if
condition|(
name|categoryvalue
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
block|{
comment|/* The whole contents of CATEGORYVALUE has been searched but 	     no valid entry has been found.  We solve this situation 	     by implicitly appending a "C" entry, i.e. no translation 	     will take place.  */
name|single_locale
index|[
literal|0
index|]
operator|=
literal|'C'
expr_stmt|;
name|single_locale
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
else|else
block|{
name|char
modifier|*
name|cp
init|=
name|single_locale
decl_stmt|;
while|while
condition|(
name|categoryvalue
index|[
literal|0
index|]
operator|!=
literal|'\0'
operator|&&
name|categoryvalue
index|[
literal|0
index|]
operator|!=
literal|':'
condition|)
operator|*
name|cp
operator|++
operator|=
operator|*
name|categoryvalue
operator|++
expr_stmt|;
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
comment|/* When this is a SUID binary we must not allow accessing files 	     outside the dedicated directories.  */
if|if
condition|(
name|ENABLE_SECURE
operator|&&
name|IS_PATH_WITH_DIR
argument_list|(
name|single_locale
argument_list|)
condition|)
comment|/* Ingore this entry.  */
continue|continue;
block|}
comment|/* If the current locale value is C (or POSIX) we don't load a 	 domain.  Return the MSGID.  */
if|if
condition|(
name|strcmp
argument_list|(
name|single_locale
argument_list|,
literal|"C"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|single_locale
argument_list|,
literal|"POSIX"
argument_list|)
operator|==
literal|0
condition|)
break|break;
comment|/* Find structure describing the message catalog matching the 	 DOMAINNAME and CATEGORY.  */
name|domain
operator|=
name|_nl_find_domain
argument_list|(
name|dirname
argument_list|,
name|single_locale
argument_list|,
name|xdomainname
argument_list|,
name|binding
argument_list|)
expr_stmt|;
if|if
condition|(
name|domain
operator|!=
name|NULL
condition|)
block|{
name|retval
operator|=
name|_nl_find_msg
argument_list|(
name|domain
argument_list|,
name|binding
argument_list|,
name|msgid1
argument_list|,
operator|&
name|retlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|==
name|NULL
condition|)
block|{
name|int
name|cnt
decl_stmt|;
for|for
control|(
name|cnt
operator|=
literal|0
init|;
name|domain
operator|->
name|successor
index|[
name|cnt
index|]
operator|!=
name|NULL
condition|;
operator|++
name|cnt
control|)
block|{
name|retval
operator|=
name|_nl_find_msg
argument_list|(
name|domain
operator|->
name|successor
index|[
name|cnt
index|]
argument_list|,
name|binding
argument_list|,
name|msgid1
argument_list|,
operator|&
name|retlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|!=
name|NULL
condition|)
block|{
name|domain
operator|=
name|domain
operator|->
name|successor
index|[
name|cnt
index|]
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
name|retval
operator|!=
name|NULL
condition|)
block|{
comment|/* Found the translation of MSGID1 in domain DOMAIN: 		 starting at RETVAL, RETLEN bytes.  */
name|FREE_BLOCKS
argument_list|(
name|block_list
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
name|HAVE_TSEARCH
operator|||
name|defined
name|_LIBC
if|if
condition|(
name|foundp
operator|==
name|NULL
condition|)
block|{
comment|/* Create a new entry and add it to the search tree.  */
name|struct
name|known_translation_t
modifier|*
name|newp
decl_stmt|;
name|newp
operator|=
operator|(
expr|struct
name|known_translation_t
operator|*
operator|)
name|malloc
argument_list|(
name|offsetof
argument_list|(
expr|struct
name|known_translation_t
argument_list|,
name|msgid
argument_list|)
operator|+
name|msgid_len
operator|+
name|domainname_len
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|newp
operator|!=
name|NULL
condition|)
block|{
name|newp
operator|->
name|domainname
operator|=
name|mempcpy
argument_list|(
name|newp
operator|->
name|msgid
argument_list|,
name|msgid1
argument_list|,
name|msgid_len
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|newp
operator|->
name|domainname
argument_list|,
name|domainname
argument_list|,
name|domainname_len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|newp
operator|->
name|category
operator|=
name|category
expr_stmt|;
name|newp
operator|->
name|counter
operator|=
name|_nl_msg_cat_cntr
expr_stmt|;
name|newp
operator|->
name|domain
operator|=
name|domain
expr_stmt|;
name|newp
operator|->
name|translation
operator|=
name|retval
expr_stmt|;
name|newp
operator|->
name|translation_length
operator|=
name|retlen
expr_stmt|;
comment|/* Insert the entry in the search tree.  */
name|foundp
operator|=
operator|(
expr|struct
name|known_translation_t
operator|*
operator|*
operator|)
name|tsearch
argument_list|(
name|newp
argument_list|,
operator|&
name|root
argument_list|,
name|transcmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|foundp
operator|==
name|NULL
operator|||
name|__builtin_expect
argument_list|(
operator|*
name|foundp
operator|!=
name|newp
argument_list|,
literal|0
argument_list|)
condition|)
comment|/* The insert failed.  */
name|free
argument_list|(
name|newp
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* We can update the existing entry.  */
operator|(
operator|*
name|foundp
operator|)
operator|->
name|counter
operator|=
name|_nl_msg_cat_cntr
expr_stmt|;
operator|(
operator|*
name|foundp
operator|)
operator|->
name|domain
operator|=
name|domain
expr_stmt|;
operator|(
operator|*
name|foundp
operator|)
operator|->
name|translation
operator|=
name|retval
expr_stmt|;
operator|(
operator|*
name|foundp
operator|)
operator|->
name|translation_length
operator|=
name|retlen
expr_stmt|;
block|}
endif|#
directive|endif
name|__set_errno
argument_list|(
name|saved_errno
argument_list|)
expr_stmt|;
comment|/* Now deal with plural.  */
if|if
condition|(
name|plural
condition|)
name|retval
operator|=
name|plural_lookup
argument_list|(
name|domain
argument_list|,
name|n
argument_list|,
name|retval
argument_list|,
name|retlen
argument_list|)
expr_stmt|;
name|__libc_rwlock_unlock
argument_list|(
name|_nl_state_lock
argument_list|)
expr_stmt|;
return|return
name|retval
return|;
block|}
block|}
block|}
name|return_untranslated
label|:
comment|/* Return the untranslated MSGID.  */
name|FREE_BLOCKS
argument_list|(
name|block_list
argument_list|)
expr_stmt|;
name|__libc_rwlock_unlock
argument_list|(
name|_nl_state_lock
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|_LIBC
if|if
condition|(
operator|!
name|ENABLE_SECURE
condition|)
block|{
specifier|extern
name|void
name|_nl_log_untranslated
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
name|logfilename
operator|,
specifier|const
name|char
operator|*
name|domainname
operator|,
specifier|const
name|char
operator|*
name|msgid1
operator|,
specifier|const
name|char
operator|*
name|msgid2
operator|,
name|int
name|plural
operator|)
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|logfilename
init|=
name|getenv
argument_list|(
literal|"GETTEXT_LOG_UNTRANSLATED"
argument_list|)
decl_stmt|;
if|if
condition|(
name|logfilename
operator|!=
name|NULL
operator|&&
name|logfilename
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
name|_nl_log_untranslated
argument_list|(
name|logfilename
argument_list|,
name|domainname
argument_list|,
name|msgid1
argument_list|,
name|msgid2
argument_list|,
name|plural
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|__set_errno
argument_list|(
name|saved_errno
argument_list|)
expr_stmt|;
return|return
operator|(
name|plural
operator|==
literal|0
condition|?
operator|(
name|char
operator|*
operator|)
name|msgid1
comment|/* Use the Germanic plural rule.  */
else|:
name|n
operator|==
literal|1
condition|?
operator|(
name|char
operator|*
operator|)
name|msgid1
else|:
operator|(
name|char
operator|*
operator|)
name|msgid2
operator|)
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|internal_function
name|_nl_find_msg
parameter_list|(
name|domain_file
parameter_list|,
name|domainbinding
parameter_list|,
name|msgid
parameter_list|,
name|lengthp
parameter_list|)
name|struct
name|loaded_l10nfile
modifier|*
name|domain_file
decl_stmt|;
name|struct
name|binding
modifier|*
name|domainbinding
decl_stmt|;
specifier|const
name|char
modifier|*
name|msgid
decl_stmt|;
name|size_t
modifier|*
name|lengthp
decl_stmt|;
block|{
name|struct
name|loaded_domain
modifier|*
name|domain
decl_stmt|;
name|nls_uint32
name|nstrings
decl_stmt|;
name|size_t
name|act
decl_stmt|;
name|char
modifier|*
name|result
decl_stmt|;
name|size_t
name|resultlen
decl_stmt|;
if|if
condition|(
name|domain_file
operator|->
name|decided
operator|==
literal|0
condition|)
name|_nl_load_domain
argument_list|(
name|domain_file
argument_list|,
name|domainbinding
argument_list|)
expr_stmt|;
if|if
condition|(
name|domain_file
operator|->
name|data
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|domain
operator|=
operator|(
expr|struct
name|loaded_domain
operator|*
operator|)
name|domain_file
operator|->
name|data
expr_stmt|;
name|nstrings
operator|=
name|domain
operator|->
name|nstrings
expr_stmt|;
comment|/* Locate the MSGID and its translation.  */
if|if
condition|(
name|domain
operator|->
name|hash_tab
operator|!=
name|NULL
condition|)
block|{
comment|/* Use the hashing table.  */
name|nls_uint32
name|len
init|=
name|strlen
argument_list|(
name|msgid
argument_list|)
decl_stmt|;
name|nls_uint32
name|hash_val
init|=
name|hash_string
argument_list|(
name|msgid
argument_list|)
decl_stmt|;
name|nls_uint32
name|idx
init|=
name|hash_val
operator|%
name|domain
operator|->
name|hash_size
decl_stmt|;
name|nls_uint32
name|incr
init|=
literal|1
operator|+
operator|(
name|hash_val
operator|%
operator|(
name|domain
operator|->
name|hash_size
operator|-
literal|2
operator|)
operator|)
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|nls_uint32
name|nstr
init|=
name|W
argument_list|(
name|domain
operator|->
name|must_swap_hash_tab
argument_list|,
name|domain
operator|->
name|hash_tab
index|[
name|idx
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|nstr
operator|==
literal|0
condition|)
comment|/* Hash table entry is empty.  */
return|return
name|NULL
return|;
name|nstr
operator|--
expr_stmt|;
comment|/* Compare msgid with the original string at index nstr. 	     We compare the lengths with>=, not ==, because plural entries 	     are represented by strings with an embedded NUL.  */
if|if
condition|(
name|nstr
operator|<
name|nstrings
condition|?
name|W
argument_list|(
name|domain
operator|->
name|must_swap
argument_list|,
name|domain
operator|->
name|orig_tab
index|[
name|nstr
index|]
operator|.
name|length
argument_list|)
operator|>=
name|len
operator|&&
operator|(
name|strcmp
argument_list|(
name|msgid
argument_list|,
name|domain
operator|->
name|data
operator|+
name|W
argument_list|(
name|domain
operator|->
name|must_swap
argument_list|,
name|domain
operator|->
name|orig_tab
index|[
name|nstr
index|]
operator|.
name|offset
argument_list|)
argument_list|)
operator|==
literal|0
operator|)
else|:
name|domain
operator|->
name|orig_sysdep_tab
index|[
name|nstr
operator|-
name|nstrings
index|]
operator|.
name|length
operator|>
name|len
operator|&&
operator|(
name|strcmp
argument_list|(
name|msgid
argument_list|,
name|domain
operator|->
name|orig_sysdep_tab
index|[
name|nstr
operator|-
name|nstrings
index|]
operator|.
name|pointer
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|act
operator|=
name|nstr
expr_stmt|;
goto|goto
name|found
goto|;
block|}
if|if
condition|(
name|idx
operator|>=
name|domain
operator|->
name|hash_size
operator|-
name|incr
condition|)
name|idx
operator|-=
name|domain
operator|->
name|hash_size
operator|-
name|incr
expr_stmt|;
else|else
name|idx
operator|+=
name|incr
expr_stmt|;
block|}
comment|/* NOTREACHED */
block|}
else|else
block|{
comment|/* Try the default method:  binary search in the sorted array of 	 messages.  */
name|size_t
name|top
decl_stmt|,
name|bottom
decl_stmt|;
name|bottom
operator|=
literal|0
expr_stmt|;
name|top
operator|=
name|nstrings
expr_stmt|;
while|while
condition|(
name|bottom
operator|<
name|top
condition|)
block|{
name|int
name|cmp_val
decl_stmt|;
name|act
operator|=
operator|(
name|bottom
operator|+
name|top
operator|)
operator|/
literal|2
expr_stmt|;
name|cmp_val
operator|=
name|strcmp
argument_list|(
name|msgid
argument_list|,
operator|(
name|domain
operator|->
name|data
operator|+
name|W
argument_list|(
name|domain
operator|->
name|must_swap
argument_list|,
name|domain
operator|->
name|orig_tab
index|[
name|act
index|]
operator|.
name|offset
argument_list|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmp_val
operator|<
literal|0
condition|)
name|top
operator|=
name|act
expr_stmt|;
elseif|else
if|if
condition|(
name|cmp_val
operator|>
literal|0
condition|)
name|bottom
operator|=
name|act
operator|+
literal|1
expr_stmt|;
else|else
goto|goto
name|found
goto|;
block|}
comment|/* No translation was found.  */
return|return
name|NULL
return|;
block|}
name|found
label|:
comment|/* The translation was found at index ACT.  If we have to convert the      string to use a different character set, this is the time.  */
if|if
condition|(
name|act
operator|<
name|nstrings
condition|)
block|{
name|result
operator|=
operator|(
name|char
operator|*
operator|)
operator|(
name|domain
operator|->
name|data
operator|+
name|W
argument_list|(
name|domain
operator|->
name|must_swap
argument_list|,
name|domain
operator|->
name|trans_tab
index|[
name|act
index|]
operator|.
name|offset
argument_list|)
operator|)
expr_stmt|;
name|resultlen
operator|=
name|W
argument_list|(
name|domain
operator|->
name|must_swap
argument_list|,
name|domain
operator|->
name|trans_tab
index|[
name|act
index|]
operator|.
name|length
argument_list|)
operator|+
literal|1
expr_stmt|;
block|}
else|else
block|{
name|result
operator|=
operator|(
name|char
operator|*
operator|)
name|domain
operator|->
name|trans_sysdep_tab
index|[
name|act
operator|-
name|nstrings
index|]
operator|.
name|pointer
expr_stmt|;
name|resultlen
operator|=
name|domain
operator|->
name|trans_sysdep_tab
index|[
name|act
operator|-
name|nstrings
index|]
operator|.
name|length
expr_stmt|;
block|}
if|#
directive|if
name|defined
name|_LIBC
operator|||
name|HAVE_ICONV
if|if
condition|(
name|domain
operator|->
name|codeset_cntr
operator|!=
operator|(
name|domainbinding
operator|!=
name|NULL
condition|?
name|domainbinding
operator|->
name|codeset_cntr
else|:
literal|0
operator|)
condition|)
block|{
comment|/* The domain's codeset has changed through bind_textdomain_codeset() 	 since the message catalog was initialized or last accessed.  We 	 have to reinitialize the converter.  */
name|_nl_free_domain_conv
argument_list|(
name|domain
argument_list|)
expr_stmt|;
name|_nl_init_domain_conv
argument_list|(
name|domain_file
argument_list|,
name|domain
argument_list|,
name|domainbinding
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
ifdef|#
directive|ifdef
name|_LIBC
name|domain
operator|->
name|conv
operator|!=
operator|(
name|__gconv_t
operator|)
operator|-
literal|1
else|#
directive|else
if|#
directive|if
name|HAVE_ICONV
name|domain
operator|->
name|conv
operator|!=
operator|(
name|iconv_t
operator|)
operator|-
literal|1
endif|#
directive|endif
endif|#
directive|endif
condition|)
block|{
comment|/* We are supposed to do a conversion.  First allocate an 	 appropriate table with the same structure as the table 	 of translations in the file, where we can put the pointers 	 to the converted strings in. 	 There is a slight complication with plural entries.  They 	 are represented by consecutive NUL terminated strings.  We 	 handle this case by converting RESULTLEN bytes, including 	 NULs.  */
if|if
condition|(
name|domain
operator|->
name|conv_tab
operator|==
name|NULL
operator|&&
operator|(
operator|(
name|domain
operator|->
name|conv_tab
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|calloc
argument_list|(
name|nstrings
operator|+
name|domain
operator|->
name|n_sysdep_strings
argument_list|,
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
operator|)
condition|)
comment|/* Mark that we didn't succeed allocating a table.  */
name|domain
operator|->
name|conv_tab
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|__builtin_expect
argument_list|(
name|domain
operator|->
name|conv_tab
operator|==
operator|(
name|char
operator|*
operator|*
operator|)
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
condition|)
comment|/* Nothing we can do, no more memory.  */
goto|goto
name|converted
goto|;
if|if
condition|(
name|domain
operator|->
name|conv_tab
index|[
name|act
index|]
operator|==
name|NULL
condition|)
block|{
comment|/* We haven't used this string so far, so it is not 	     translated yet.  Do this now.  */
comment|/* We use a bit more efficient memory handling. 	     We allocate always larger blocks which get used over 	     time.  This is faster than many small allocations.   */
name|__libc_lock_define_initialized
argument_list|(
argument|static
argument_list|,
argument|lock
argument_list|)
define|#
directive|define
name|INITIAL_BLOCK_SIZE
value|4080
specifier|static
name|unsigned
name|char
modifier|*
name|freemem
decl_stmt|;
specifier|static
name|size_t
name|freemem_size
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|inbuf
decl_stmt|;
name|unsigned
name|char
modifier|*
name|outbuf
decl_stmt|;
name|int
name|malloc_count
decl_stmt|;
ifndef|#
directive|ifndef
name|_LIBC
name|transmem_block_t
modifier|*
name|transmem_list
init|=
name|NULL
decl_stmt|;
endif|#
directive|endif
name|__libc_lock_lock
argument_list|(
name|lock
argument_list|)
expr_stmt|;
name|inbuf
operator|=
operator|(
specifier|const
name|unsigned
name|char
operator|*
operator|)
name|result
expr_stmt|;
name|outbuf
operator|=
name|freemem
operator|+
sizeof|sizeof
argument_list|(
name|size_t
argument_list|)
expr_stmt|;
name|malloc_count
operator|=
literal|0
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|transmem_block_t
modifier|*
name|newmem
decl_stmt|;
ifdef|#
directive|ifdef
name|_LIBC
name|size_t
name|non_reversible
decl_stmt|;
name|int
name|res
decl_stmt|;
if|if
condition|(
name|freemem_size
operator|<
sizeof|sizeof
argument_list|(
name|size_t
argument_list|)
condition|)
goto|goto
name|resize_freemem
goto|;
name|res
operator|=
name|__gconv
argument_list|(
name|domain
operator|->
name|conv
argument_list|,
operator|&
name|inbuf
argument_list|,
name|inbuf
operator|+
name|resultlen
argument_list|,
operator|&
name|outbuf
argument_list|,
name|outbuf
operator|+
name|freemem_size
operator|-
sizeof|sizeof
argument_list|(
name|size_t
argument_list|)
argument_list|,
operator|&
name|non_reversible
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|==
name|__GCONV_OK
operator|||
name|res
operator|==
name|__GCONV_EMPTY_INPUT
condition|)
break|break;
if|if
condition|(
name|res
operator|!=
name|__GCONV_FULL_OUTPUT
condition|)
block|{
name|__libc_lock_unlock
argument_list|(
name|lock
argument_list|)
expr_stmt|;
goto|goto
name|converted
goto|;
block|}
name|inbuf
operator|=
name|result
expr_stmt|;
else|#
directive|else
if|#
directive|if
name|HAVE_ICONV
specifier|const
name|char
modifier|*
name|inptr
init|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|inbuf
decl_stmt|;
name|size_t
name|inleft
init|=
name|resultlen
decl_stmt|;
name|char
modifier|*
name|outptr
init|=
operator|(
name|char
operator|*
operator|)
name|outbuf
decl_stmt|;
name|size_t
name|outleft
decl_stmt|;
if|if
condition|(
name|freemem_size
operator|<
sizeof|sizeof
argument_list|(
name|size_t
argument_list|)
condition|)
goto|goto
name|resize_freemem
goto|;
name|outleft
operator|=
name|freemem_size
operator|-
sizeof|sizeof
argument_list|(
name|size_t
argument_list|)
expr_stmt|;
if|if
condition|(
name|iconv
argument_list|(
name|domain
operator|->
name|conv
argument_list|,
operator|(
name|ICONV_CONST
name|char
operator|*
operator|*
operator|)
operator|&
name|inptr
argument_list|,
operator|&
name|inleft
argument_list|,
operator|&
name|outptr
argument_list|,
operator|&
name|outleft
argument_list|)
operator|!=
call|(
name|size_t
call|)
argument_list|(
operator|-
literal|1
argument_list|)
condition|)
block|{
name|outbuf
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|outptr
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|errno
operator|!=
name|E2BIG
condition|)
block|{
name|__libc_lock_unlock
argument_list|(
name|lock
argument_list|)
expr_stmt|;
goto|goto
name|converted
goto|;
block|}
endif|#
directive|endif
endif|#
directive|endif
name|resize_freemem
label|:
comment|/* We must allocate a new buffer or resize the old one.  */
if|if
condition|(
name|malloc_count
operator|>
literal|0
condition|)
block|{
operator|++
name|malloc_count
expr_stmt|;
name|freemem_size
operator|=
name|malloc_count
operator|*
name|INITIAL_BLOCK_SIZE
expr_stmt|;
name|newmem
operator|=
operator|(
name|transmem_block_t
operator|*
operator|)
name|realloc
argument_list|(
name|transmem_list
argument_list|,
name|freemem_size
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|_LIBC
if|if
condition|(
name|newmem
operator|!=
name|NULL
condition|)
name|transmem_list
operator|=
name|transmem_list
operator|->
name|next
expr_stmt|;
else|else
block|{
name|struct
name|transmem_list
modifier|*
name|old
init|=
name|transmem_list
decl_stmt|;
name|transmem_list
operator|=
name|transmem_list
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|old
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
else|else
block|{
name|malloc_count
operator|=
literal|1
expr_stmt|;
name|freemem_size
operator|=
name|INITIAL_BLOCK_SIZE
expr_stmt|;
name|newmem
operator|=
operator|(
name|transmem_block_t
operator|*
operator|)
name|malloc
argument_list|(
name|freemem_size
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|__builtin_expect
argument_list|(
name|newmem
operator|==
name|NULL
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|freemem
operator|=
name|NULL
expr_stmt|;
name|freemem_size
operator|=
literal|0
expr_stmt|;
name|__libc_lock_unlock
argument_list|(
name|lock
argument_list|)
expr_stmt|;
goto|goto
name|converted
goto|;
block|}
ifdef|#
directive|ifdef
name|_LIBC
comment|/* Add the block to the list of blocks we have to free                  at some point.  */
name|newmem
operator|->
name|next
operator|=
name|transmem_list
expr_stmt|;
name|transmem_list
operator|=
name|newmem
expr_stmt|;
name|freemem
operator|=
name|newmem
operator|->
name|data
expr_stmt|;
name|freemem_size
operator|-=
name|offsetof
argument_list|(
expr|struct
name|transmem_list
argument_list|,
name|data
argument_list|)
expr_stmt|;
else|#
directive|else
name|transmem_list
operator|=
name|newmem
expr_stmt|;
name|freemem
operator|=
name|newmem
expr_stmt|;
endif|#
directive|endif
name|outbuf
operator|=
name|freemem
operator|+
sizeof|sizeof
argument_list|(
name|size_t
argument_list|)
expr_stmt|;
block|}
comment|/* We have now in our buffer a converted string.  Put this 	     into the table of conversions.  */
operator|*
operator|(
name|size_t
operator|*
operator|)
name|freemem
operator|=
name|outbuf
operator|-
name|freemem
operator|-
sizeof|sizeof
argument_list|(
name|size_t
argument_list|)
expr_stmt|;
name|domain
operator|->
name|conv_tab
index|[
name|act
index|]
operator|=
operator|(
name|char
operator|*
operator|)
name|freemem
expr_stmt|;
comment|/* Shrink freemem, but keep it aligned.  */
name|freemem_size
operator|-=
name|outbuf
operator|-
name|freemem
expr_stmt|;
name|freemem
operator|=
name|outbuf
expr_stmt|;
name|freemem
operator|+=
name|freemem_size
operator|&
operator|(
name|alignof
argument_list|(
name|size_t
argument_list|)
operator|-
literal|1
operator|)
expr_stmt|;
name|freemem_size
operator|=
name|freemem_size
operator|&
operator|~
operator|(
name|alignof
argument_list|(
name|size_t
argument_list|)
operator|-
literal|1
operator|)
expr_stmt|;
name|__libc_lock_unlock
argument_list|(
name|lock
argument_list|)
expr_stmt|;
block|}
comment|/* Now domain->conv_tab[act] contains the translation of all 	 the plural variants.  */
name|result
operator|=
name|domain
operator|->
name|conv_tab
index|[
name|act
index|]
operator|+
sizeof|sizeof
argument_list|(
name|size_t
argument_list|)
expr_stmt|;
name|resultlen
operator|=
operator|*
operator|(
name|size_t
operator|*
operator|)
name|domain
operator|->
name|conv_tab
index|[
name|act
index|]
expr_stmt|;
block|}
name|converted
label|:
comment|/* The result string is converted.  */
endif|#
directive|endif
comment|/* _LIBC || HAVE_ICONV */
operator|*
name|lengthp
operator|=
name|resultlen
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Look up a plural variant.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|internal_function
name|plural_lookup
parameter_list|(
name|domain
parameter_list|,
name|n
parameter_list|,
name|translation
parameter_list|,
name|translation_len
parameter_list|)
name|struct
name|loaded_l10nfile
modifier|*
name|domain
decl_stmt|;
name|unsigned
name|long
name|int
name|n
decl_stmt|;
specifier|const
name|char
modifier|*
name|translation
decl_stmt|;
name|size_t
name|translation_len
decl_stmt|;
block|{
name|struct
name|loaded_domain
modifier|*
name|domaindata
init|=
operator|(
expr|struct
name|loaded_domain
operator|*
operator|)
name|domain
operator|->
name|data
decl_stmt|;
name|unsigned
name|long
name|int
name|index
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
name|index
operator|=
name|plural_eval
argument_list|(
name|domaindata
operator|->
name|plural
argument_list|,
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|index
operator|>=
name|domaindata
operator|->
name|nplurals
condition|)
comment|/* This should never happen.  It means the plural expression and the        given maximum value do not match.  */
name|index
operator|=
literal|0
expr_stmt|;
comment|/* Skip INDEX strings at TRANSLATION.  */
name|p
operator|=
name|translation
expr_stmt|;
while|while
condition|(
name|index
operator|--
operator|>
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|_LIBC
name|p
operator|=
name|__rawmemchr
argument_list|(
name|p
argument_list|,
literal|'\0'
argument_list|)
expr_stmt|;
else|#
directive|else
name|p
operator|=
name|strchr
argument_list|(
name|p
argument_list|,
literal|'\0'
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* And skip over the NUL byte.  */
name|p
operator|++
expr_stmt|;
if|if
condition|(
name|p
operator|>=
name|translation
operator|+
name|translation_len
condition|)
comment|/* This should never happen.  It means the plural expression 	   evaluated to a value larger than the number of variants 	   available for MSGID1.  */
return|return
operator|(
name|char
operator|*
operator|)
name|translation
return|;
block|}
return|return
operator|(
name|char
operator|*
operator|)
name|p
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|_LIBC
end_ifndef

begin_comment
comment|/* Return string representation of locale CATEGORY.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|internal_function
name|category_to_name
parameter_list|(
name|category
parameter_list|)
name|int
name|category
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|retval
decl_stmt|;
switch|switch
condition|(
name|category
condition|)
block|{
ifdef|#
directive|ifdef
name|LC_COLLATE
case|case
name|LC_COLLATE
case|:
name|retval
operator|=
literal|"LC_COLLATE"
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|LC_CTYPE
case|case
name|LC_CTYPE
case|:
name|retval
operator|=
literal|"LC_CTYPE"
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|LC_MONETARY
case|case
name|LC_MONETARY
case|:
name|retval
operator|=
literal|"LC_MONETARY"
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|LC_NUMERIC
case|case
name|LC_NUMERIC
case|:
name|retval
operator|=
literal|"LC_NUMERIC"
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|LC_TIME
case|case
name|LC_TIME
case|:
name|retval
operator|=
literal|"LC_TIME"
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|LC_MESSAGES
case|case
name|LC_MESSAGES
case|:
name|retval
operator|=
literal|"LC_MESSAGES"
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|LC_RESPONSE
case|case
name|LC_RESPONSE
case|:
name|retval
operator|=
literal|"LC_RESPONSE"
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|LC_ALL
case|case
name|LC_ALL
case|:
comment|/* This might not make sense but is perhaps better than any other        value.  */
name|retval
operator|=
literal|"LC_ALL"
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
comment|/* If you have a better idea for a default value let me know.  */
name|retval
operator|=
literal|"LC_XXX"
expr_stmt|;
block|}
return|return
name|retval
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Guess value of current locale from value of the environment variables.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|internal_function
name|guess_category_value
parameter_list|(
name|category
parameter_list|,
name|categoryname
parameter_list|)
name|int
name|category
decl_stmt|;
specifier|const
name|char
modifier|*
name|categoryname
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|language
decl_stmt|;
specifier|const
name|char
modifier|*
name|retval
decl_stmt|;
comment|/* The highest priority value is the `LANGUAGE' environment      variable.  But we don't use the value if the currently selected      locale is the C locale.  This is a GNU extension.  */
name|language
operator|=
name|getenv
argument_list|(
literal|"LANGUAGE"
argument_list|)
expr_stmt|;
if|if
condition|(
name|language
operator|!=
name|NULL
operator|&&
name|language
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
name|language
operator|=
name|NULL
expr_stmt|;
comment|/* We have to proceed with the POSIX methods of looking to `LC_ALL',      `LC_xxx', and `LANG'.  On some systems this can be done by the      `setlocale' function itself.  */
ifdef|#
directive|ifdef
name|_LIBC
name|retval
operator|=
name|__current_locale_name
argument_list|(
name|category
argument_list|)
expr_stmt|;
else|#
directive|else
name|retval
operator|=
name|_nl_locale_name
argument_list|(
name|category
argument_list|,
name|categoryname
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Ignore LANGUAGE if the locale is set to "C" because      1. "C" locale usually uses the ASCII encoding, and most international 	messages use non-ASCII characters. These characters get displayed 	as question marks (if using glibc's iconv()) or as invalid 8-bit 	characters (because other iconv()s refuse to convert most non-ASCII 	characters to ASCII). In any case, the output is ugly.      2. The precise output of some programs in the "C" locale is specified 	by POSIX and should not depend on environment variables like 	"LANGUAGE".  We allow such programs to use gettext().  */
return|return
name|language
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
name|retval
argument_list|,
literal|"C"
argument_list|)
operator|!=
literal|0
condition|?
name|language
else|:
name|retval
return|;
block|}
end_function

begin_comment
comment|/* @@ begin of epilog @@ */
end_comment

begin_comment
comment|/* We don't want libintl.a to depend on any other library.  So we    avoid the non-standard function stpcpy.  In GNU C Library this    function is available, though.  Also allow the symbol HAVE_STPCPY    to be defined.  */
end_comment

begin_if
if|#
directive|if
operator|!
name|_LIBC
operator|&&
operator|!
name|HAVE_STPCPY
end_if

begin_function
specifier|static
name|char
modifier|*
name|stpcpy
parameter_list|(
name|dest
parameter_list|,
name|src
parameter_list|)
name|char
modifier|*
name|dest
decl_stmt|;
specifier|const
name|char
modifier|*
name|src
decl_stmt|;
block|{
while|while
condition|(
operator|(
operator|*
name|dest
operator|++
operator|=
operator|*
name|src
operator|++
operator|)
operator|!=
literal|'\0'
condition|)
comment|/* Do nothing. */
empty_stmt|;
return|return
name|dest
operator|-
literal|1
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|_LIBC
operator|&&
operator|!
name|HAVE_MEMPCPY
end_if

begin_function
specifier|static
name|void
modifier|*
name|mempcpy
parameter_list|(
name|dest
parameter_list|,
name|src
parameter_list|,
name|n
parameter_list|)
name|void
modifier|*
name|dest
decl_stmt|;
specifier|const
name|void
modifier|*
name|src
decl_stmt|;
name|size_t
name|n
decl_stmt|;
block|{
return|return
operator|(
name|void
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|memcpy
argument_list|(
name|dest
argument_list|,
name|src
argument_list|,
name|n
argument_list|)
operator|+
name|n
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|_LIBC
end_ifdef

begin_comment
comment|/* If we want to free all resources we have to do some work at    program's end.  */
end_comment

begin_macro
name|libc_freeres_fn
argument_list|(
argument|free_mem
argument_list|)
end_macro

begin_block
block|{
name|void
modifier|*
name|old
decl_stmt|;
while|while
condition|(
name|_nl_domain_bindings
operator|!=
name|NULL
condition|)
block|{
name|struct
name|binding
modifier|*
name|oldp
init|=
name|_nl_domain_bindings
decl_stmt|;
name|_nl_domain_bindings
operator|=
name|_nl_domain_bindings
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|oldp
operator|->
name|dirname
operator|!=
name|INTUSE
argument_list|(
name|_nl_default_dirname
argument_list|)
condition|)
comment|/* Yes, this is a pointer comparison.  */
name|free
argument_list|(
name|oldp
operator|->
name|dirname
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|oldp
operator|->
name|codeset
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|oldp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|_nl_current_default_domain
operator|!=
name|_nl_default_default_domain
condition|)
comment|/* Yes, again a pointer comparison.  */
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|_nl_current_default_domain
argument_list|)
expr_stmt|;
comment|/* Remove the search tree with the known translations.  */
name|__tdestroy
argument_list|(
name|root
argument_list|,
name|free
argument_list|)
expr_stmt|;
name|root
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
name|transmem_list
operator|!=
name|NULL
condition|)
block|{
name|old
operator|=
name|transmem_list
expr_stmt|;
name|transmem_list
operator|=
name|transmem_list
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|old
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

end_unit

