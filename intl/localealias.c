begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Handle aliases for locale names.    Copyright (C) 1995-1999, 2000-2001, 2003 Free Software Foundation, Inc.     This program is free software; you can redistribute it and/or modify it    under the terms of the GNU Library General Public License as published    by the Free Software Foundation; either version 2, or (at your option)    any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU    Library General Public License for more details.     You should have received a copy of the GNU Library General Public    License along with this program; if not, write to the Free Software    Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301,    USA.  */
end_comment

begin_comment
comment|/* Tell glibc's<string.h> to provide a prototype for mempcpy().    This must come before<config.h> because<config.h> may include<features.h>, and once<features.h> has been included, it's too late.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|_GNU_SOURCE
end_ifndef

begin_define
define|#
directive|define
name|_GNU_SOURCE
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_CONFIG_H
end_ifdef

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_if
if|#
directive|if
name|defined
name|_LIBC
operator|||
name|defined
name|HAVE___FSETLOCKING
end_if

begin_include
include|#
directive|include
file|<stdio_ext.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|__GNUC__
end_ifdef

begin_undef
undef|#
directive|undef
name|alloca
end_undef

begin_define
define|#
directive|define
name|alloca
value|__builtin_alloca
end_define

begin_define
define|#
directive|define
name|HAVE_ALLOCA
value|1
end_define

begin_else
else|#
directive|else
end_else

begin_ifdef
ifdef|#
directive|ifdef
name|_MSC_VER
end_ifdef

begin_include
include|#
directive|include
file|<malloc.h>
end_include

begin_define
define|#
directive|define
name|alloca
value|_alloca
end_define

begin_else
else|#
directive|else
end_else

begin_if
if|#
directive|if
name|defined
name|HAVE_ALLOCA_H
operator|||
name|defined
name|_LIBC
end_if

begin_include
include|#
directive|include
file|<alloca.h>
end_include

begin_else
else|#
directive|else
end_else

begin_ifdef
ifdef|#
directive|ifdef
name|_AIX
end_ifdef

begin_pragma
pragma|#
directive|pragma
name|alloca
end_pragma

begin_else
else|#
directive|else
end_else

begin_ifndef
ifndef|#
directive|ifndef
name|alloca
end_ifndef

begin_function_decl
name|char
modifier|*
name|alloca
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|"gettextP.h"
end_include

begin_if
if|#
directive|if
name|ENABLE_RELOCATABLE
end_if

begin_include
include|#
directive|include
file|"relocatable.h"
end_include

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|relocate
parameter_list|(
name|pathname
parameter_list|)
value|(pathname)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* @@ end of prolog @@ */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|_LIBC
end_ifdef

begin_comment
comment|/* Rename the non ANSI C functions.  This is required by the standard    because some ANSI C functions will require linking with this object    file and the name space must not be polluted.  */
end_comment

begin_define
define|#
directive|define
name|strcasecmp
value|__strcasecmp
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|mempcpy
end_ifndef

begin_define
define|#
directive|define
name|mempcpy
value|__mempcpy
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|HAVE_MEMPCPY
value|1
end_define

begin_define
define|#
directive|define
name|HAVE___FSETLOCKING
value|1
end_define

begin_comment
comment|/* We need locking here since we can be called from different places.  */
end_comment

begin_include
include|#
directive|include
file|<bits/libc-lock.h>
end_include

begin_expr_stmt
name|__libc_lock_define_initialized
argument_list|(
specifier|static
argument_list|,
name|lock
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|internal_function
end_ifndef

begin_define
define|#
directive|define
name|internal_function
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Some optimizations for glibc.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|_LIBC
end_ifdef

begin_define
define|#
directive|define
name|FEOF
parameter_list|(
name|fp
parameter_list|)
value|feof_unlocked (fp)
end_define

begin_define
define|#
directive|define
name|FGETS
parameter_list|(
name|buf
parameter_list|,
name|n
parameter_list|,
name|fp
parameter_list|)
value|fgets_unlocked (buf, n, fp)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|FEOF
parameter_list|(
name|fp
parameter_list|)
value|feof (fp)
end_define

begin_define
define|#
directive|define
name|FGETS
parameter_list|(
name|buf
parameter_list|,
name|n
parameter_list|,
name|fp
parameter_list|)
value|fgets (buf, n, fp)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* For those losing systems which don't have `alloca' we have to add    some additional code emulating it.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_ALLOCA
end_ifdef

begin_define
define|#
directive|define
name|freea
parameter_list|(
name|p
parameter_list|)
end_define

begin_comment
comment|/* nothing */
end_comment

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|alloca
parameter_list|(
name|n
parameter_list|)
value|malloc (n)
end_define

begin_define
define|#
directive|define
name|freea
parameter_list|(
name|p
parameter_list|)
value|free (p)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
name|_LIBC_REENTRANT
operator|||
name|defined
name|HAVE_FGETS_UNLOCKED
end_if

begin_undef
undef|#
directive|undef
name|fgets
end_undef

begin_define
define|#
directive|define
name|fgets
parameter_list|(
name|buf
parameter_list|,
name|len
parameter_list|,
name|s
parameter_list|)
value|fgets_unlocked (buf, len, s)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
name|_LIBC_REENTRANT
operator|||
name|defined
name|HAVE_FEOF_UNLOCKED
end_if

begin_undef
undef|#
directive|undef
name|feof
end_undef

begin_define
define|#
directive|define
name|feof
parameter_list|(
name|s
parameter_list|)
value|feof_unlocked (s)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_struct
struct|struct
name|alias_map
block|{
specifier|const
name|char
modifier|*
name|alias
decl_stmt|;
specifier|const
name|char
modifier|*
name|value
decl_stmt|;
block|}
struct|;
end_struct

begin_ifndef
ifndef|#
directive|ifndef
name|_LIBC
end_ifndef

begin_define
define|#
directive|define
name|libc_freeres_ptr
parameter_list|(
name|decl
parameter_list|)
value|decl
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_expr_stmt
name|libc_freeres_ptr
argument_list|(
specifier|static
name|char
operator|*
name|string_space
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|size_t
name|string_space_act
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|size_t
name|string_space_max
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|libc_freeres_ptr
argument_list|(
specifier|static
expr|struct
name|alias_map
operator|*
name|map
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|size_t
name|nmap
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|size_t
name|maxmap
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Prototypes for local functions.  */
end_comment

begin_decl_stmt
specifier|static
name|size_t
name|read_alias_file
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
name|fname
operator|,
name|int
name|fname_len
operator|)
argument_list|)
name|internal_function
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|extend_alias_table
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|alias_compare
name|PARAMS
argument_list|(
operator|(
specifier|const
expr|struct
name|alias_map
operator|*
name|map1
operator|,
specifier|const
expr|struct
name|alias_map
operator|*
name|map2
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|const
name|char
modifier|*
name|_nl_expand_alias
parameter_list|(
name|name
parameter_list|)
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|{
specifier|static
specifier|const
name|char
modifier|*
name|locale_alias_path
decl_stmt|;
name|struct
name|alias_map
modifier|*
name|retval
decl_stmt|;
specifier|const
name|char
modifier|*
name|result
init|=
name|NULL
decl_stmt|;
name|size_t
name|added
decl_stmt|;
ifdef|#
directive|ifdef
name|_LIBC
name|__libc_lock_lock
argument_list|(
name|lock
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|locale_alias_path
operator|==
name|NULL
condition|)
name|locale_alias_path
operator|=
name|LOCALE_ALIAS_PATH
expr_stmt|;
do|do
block|{
name|struct
name|alias_map
name|item
decl_stmt|;
name|item
operator|.
name|alias
operator|=
name|name
expr_stmt|;
if|if
condition|(
name|nmap
operator|>
literal|0
condition|)
name|retval
operator|=
operator|(
expr|struct
name|alias_map
operator|*
operator|)
name|bsearch
argument_list|(
operator|&
name|item
argument_list|,
name|map
argument_list|,
name|nmap
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|alias_map
argument_list|)
argument_list|,
operator|(
name|int
argument_list|(
argument|*
argument_list|)
name|PARAMS
argument_list|(
operator|(
specifier|const
name|void
operator|*
operator|,
specifier|const
name|void
operator|*
operator|)
argument_list|)
operator|)
name|alias_compare
argument_list|)
expr_stmt|;
else|else
name|retval
operator|=
name|NULL
expr_stmt|;
comment|/* We really found an alias.  Return the value.  */
if|if
condition|(
name|retval
operator|!=
name|NULL
condition|)
block|{
name|result
operator|=
name|retval
operator|->
name|value
expr_stmt|;
break|break;
block|}
comment|/* Perhaps we can find another alias file.  */
name|added
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|added
operator|==
literal|0
operator|&&
name|locale_alias_path
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
block|{
specifier|const
name|char
modifier|*
name|start
decl_stmt|;
while|while
condition|(
name|locale_alias_path
index|[
literal|0
index|]
operator|==
name|PATH_SEPARATOR
condition|)
operator|++
name|locale_alias_path
expr_stmt|;
name|start
operator|=
name|locale_alias_path
expr_stmt|;
while|while
condition|(
name|locale_alias_path
index|[
literal|0
index|]
operator|!=
literal|'\0'
operator|&&
name|locale_alias_path
index|[
literal|0
index|]
operator|!=
name|PATH_SEPARATOR
condition|)
operator|++
name|locale_alias_path
expr_stmt|;
if|if
condition|(
name|start
operator|<
name|locale_alias_path
condition|)
name|added
operator|=
name|read_alias_file
argument_list|(
name|start
argument_list|,
name|locale_alias_path
operator|-
name|start
argument_list|)
expr_stmt|;
block|}
block|}
do|while
condition|(
name|added
operator|!=
literal|0
condition|)
do|;
ifdef|#
directive|ifdef
name|_LIBC
name|__libc_lock_unlock
argument_list|(
name|lock
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|result
return|;
block|}
end_function

begin_function
specifier|static
name|size_t
name|internal_function
name|read_alias_file
parameter_list|(
name|fname
parameter_list|,
name|fname_len
parameter_list|)
specifier|const
name|char
modifier|*
name|fname
decl_stmt|;
name|int
name|fname_len
decl_stmt|;
block|{
name|FILE
modifier|*
name|fp
decl_stmt|;
name|char
modifier|*
name|full_fname
decl_stmt|;
name|size_t
name|added
decl_stmt|;
specifier|static
specifier|const
name|char
name|aliasfile
index|[]
init|=
literal|"/locale.alias"
decl_stmt|;
name|full_fname
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|fname_len
operator|+
sizeof|sizeof
name|aliasfile
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_MEMPCPY
name|mempcpy
argument_list|(
name|mempcpy
argument_list|(
name|full_fname
argument_list|,
name|fname
argument_list|,
name|fname_len
argument_list|)
argument_list|,
name|aliasfile
argument_list|,
sizeof|sizeof
name|aliasfile
argument_list|)
expr_stmt|;
else|#
directive|else
name|memcpy
argument_list|(
name|full_fname
argument_list|,
name|fname
argument_list|,
name|fname_len
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|full_fname
index|[
name|fname_len
index|]
argument_list|,
name|aliasfile
argument_list|,
sizeof|sizeof
name|aliasfile
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|fp
operator|=
name|fopen
argument_list|(
name|relocate
argument_list|(
name|full_fname
argument_list|)
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
name|freea
argument_list|(
name|full_fname
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
ifdef|#
directive|ifdef
name|HAVE___FSETLOCKING
comment|/* No threads present.  */
name|__fsetlocking
argument_list|(
name|fp
argument_list|,
name|FSETLOCKING_BYCALLER
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|added
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|!
name|FEOF
argument_list|(
name|fp
argument_list|)
condition|)
block|{
comment|/* It is a reasonable approach to use a fix buffer here because 	 a) we are only interested in the first two fields 	 b) these fields must be usable as file names and so must not 	    be that long 	 We avoid a multi-kilobyte buffer here since this would use up 	 stack space which we might not have if the program ran out of 	 memory.  */
name|char
name|buf
index|[
literal|400
index|]
decl_stmt|;
name|char
modifier|*
name|alias
decl_stmt|;
name|char
modifier|*
name|value
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
if|if
condition|(
name|FGETS
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
name|fp
argument_list|)
operator|==
name|NULL
condition|)
comment|/* EOF reached.  */
break|break;
name|cp
operator|=
name|buf
expr_stmt|;
comment|/* Ignore leading white space.  */
while|while
condition|(
name|isspace
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|cp
index|[
literal|0
index|]
argument_list|)
condition|)
operator|++
name|cp
expr_stmt|;
comment|/* A leading '#' signals a comment line.  */
if|if
condition|(
name|cp
index|[
literal|0
index|]
operator|!=
literal|'\0'
operator|&&
name|cp
index|[
literal|0
index|]
operator|!=
literal|'#'
condition|)
block|{
name|alias
operator|=
name|cp
operator|++
expr_stmt|;
while|while
condition|(
name|cp
index|[
literal|0
index|]
operator|!=
literal|'\0'
operator|&&
operator|!
name|isspace
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|cp
index|[
literal|0
index|]
argument_list|)
condition|)
operator|++
name|cp
expr_stmt|;
comment|/* Terminate alias name.  */
if|if
condition|(
name|cp
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
operator|*
name|cp
operator|++
operator|=
literal|'\0'
expr_stmt|;
comment|/* Now look for the beginning of the value.  */
while|while
condition|(
name|isspace
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|cp
index|[
literal|0
index|]
argument_list|)
condition|)
operator|++
name|cp
expr_stmt|;
if|if
condition|(
name|cp
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
block|{
name|size_t
name|alias_len
decl_stmt|;
name|size_t
name|value_len
decl_stmt|;
name|value
operator|=
name|cp
operator|++
expr_stmt|;
while|while
condition|(
name|cp
index|[
literal|0
index|]
operator|!=
literal|'\0'
operator|&&
operator|!
name|isspace
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|cp
index|[
literal|0
index|]
argument_list|)
condition|)
operator|++
name|cp
expr_stmt|;
comment|/* Terminate value.  */
if|if
condition|(
name|cp
index|[
literal|0
index|]
operator|==
literal|'\n'
condition|)
block|{
comment|/* This has to be done to make the following test 		     for the end of line possible.  We are looking for 		     the terminating '\n' which do not overwrite here.  */
operator|*
name|cp
operator|++
operator|=
literal|'\0'
expr_stmt|;
operator|*
name|cp
operator|=
literal|'\n'
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cp
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
operator|*
name|cp
operator|++
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|nmap
operator|>=
name|maxmap
condition|)
if|if
condition|(
name|__builtin_expect
argument_list|(
name|extend_alias_table
argument_list|()
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|added
return|;
name|alias_len
operator|=
name|strlen
argument_list|(
name|alias
argument_list|)
operator|+
literal|1
expr_stmt|;
name|value_len
operator|=
name|strlen
argument_list|(
name|value
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|string_space_act
operator|+
name|alias_len
operator|+
name|value_len
operator|>
name|string_space_max
condition|)
block|{
comment|/* Increase size of memory pool.  */
name|size_t
name|new_size
init|=
operator|(
name|string_space_max
operator|+
operator|(
name|alias_len
operator|+
name|value_len
operator|>
literal|1024
condition|?
name|alias_len
operator|+
name|value_len
else|:
literal|1024
operator|)
operator|)
decl_stmt|;
name|char
modifier|*
name|new_pool
init|=
operator|(
name|char
operator|*
operator|)
name|realloc
argument_list|(
name|string_space
argument_list|,
name|new_size
argument_list|)
decl_stmt|;
if|if
condition|(
name|new_pool
operator|==
name|NULL
condition|)
return|return
name|added
return|;
if|if
condition|(
name|__builtin_expect
argument_list|(
name|string_space
operator|!=
name|new_pool
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|size_t
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nmap
condition|;
name|i
operator|++
control|)
block|{
name|map
index|[
name|i
index|]
operator|.
name|alias
operator|+=
name|new_pool
operator|-
name|string_space
expr_stmt|;
name|map
index|[
name|i
index|]
operator|.
name|value
operator|+=
name|new_pool
operator|-
name|string_space
expr_stmt|;
block|}
block|}
name|string_space
operator|=
name|new_pool
expr_stmt|;
name|string_space_max
operator|=
name|new_size
expr_stmt|;
block|}
name|map
index|[
name|nmap
index|]
operator|.
name|alias
operator|=
name|memcpy
argument_list|(
operator|&
name|string_space
index|[
name|string_space_act
index|]
argument_list|,
name|alias
argument_list|,
name|alias_len
argument_list|)
expr_stmt|;
name|string_space_act
operator|+=
name|alias_len
expr_stmt|;
name|map
index|[
name|nmap
index|]
operator|.
name|value
operator|=
name|memcpy
argument_list|(
operator|&
name|string_space
index|[
name|string_space_act
index|]
argument_list|,
name|value
argument_list|,
name|value_len
argument_list|)
expr_stmt|;
name|string_space_act
operator|+=
name|value_len
expr_stmt|;
operator|++
name|nmap
expr_stmt|;
operator|++
name|added
expr_stmt|;
block|}
block|}
comment|/* Possibly not the whole line fits into the buffer.  Ignore 	 the rest of the line.  */
while|while
condition|(
name|strchr
argument_list|(
name|buf
argument_list|,
literal|'\n'
argument_list|)
operator|==
name|NULL
condition|)
if|if
condition|(
name|FGETS
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
name|fp
argument_list|)
operator|==
name|NULL
condition|)
comment|/* Make sure the inner loop will be left.  The outer loop 	     will exit at the `feof' test.  */
break|break;
block|}
comment|/* Should we test for ferror()?  I think we have to silently ignore      errors.  --drepper  */
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|added
operator|>
literal|0
condition|)
name|qsort
argument_list|(
name|map
argument_list|,
name|nmap
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|alias_map
argument_list|)
argument_list|,
operator|(
name|int
argument_list|(
argument|*
argument_list|)
name|PARAMS
argument_list|(
operator|(
specifier|const
name|void
operator|*
operator|,
specifier|const
name|void
operator|*
operator|)
argument_list|)
operator|)
name|alias_compare
argument_list|)
expr_stmt|;
return|return
name|added
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|extend_alias_table
parameter_list|()
block|{
name|size_t
name|new_size
decl_stmt|;
name|struct
name|alias_map
modifier|*
name|new_map
decl_stmt|;
name|new_size
operator|=
name|maxmap
operator|==
literal|0
condition|?
literal|100
else|:
literal|2
operator|*
name|maxmap
expr_stmt|;
name|new_map
operator|=
operator|(
expr|struct
name|alias_map
operator|*
operator|)
name|realloc
argument_list|(
name|map
argument_list|,
operator|(
name|new_size
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|alias_map
argument_list|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_map
operator|==
name|NULL
condition|)
comment|/* Simply don't extend: we don't have any more core.  */
return|return
operator|-
literal|1
return|;
name|map
operator|=
name|new_map
expr_stmt|;
name|maxmap
operator|=
name|new_size
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|alias_compare
parameter_list|(
name|map1
parameter_list|,
name|map2
parameter_list|)
specifier|const
name|struct
name|alias_map
modifier|*
name|map1
decl_stmt|;
specifier|const
name|struct
name|alias_map
modifier|*
name|map2
decl_stmt|;
block|{
if|#
directive|if
name|defined
name|_LIBC
operator|||
name|defined
name|HAVE_STRCASECMP
return|return
name|strcasecmp
argument_list|(
name|map1
operator|->
name|alias
argument_list|,
name|map2
operator|->
name|alias
argument_list|)
return|;
else|#
directive|else
specifier|const
name|unsigned
name|char
modifier|*
name|p1
init|=
operator|(
specifier|const
name|unsigned
name|char
operator|*
operator|)
name|map1
operator|->
name|alias
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|p2
init|=
operator|(
specifier|const
name|unsigned
name|char
operator|*
operator|)
name|map2
operator|->
name|alias
decl_stmt|;
name|unsigned
name|char
name|c1
decl_stmt|,
name|c2
decl_stmt|;
if|if
condition|(
name|p1
operator|==
name|p2
condition|)
return|return
literal|0
return|;
do|do
block|{
comment|/* I know this seems to be odd but the tolower() function in 	 some systems libc cannot handle nonalpha characters.  */
name|c1
operator|=
name|isupper
argument_list|(
operator|*
name|p1
argument_list|)
condition|?
name|tolower
argument_list|(
operator|*
name|p1
argument_list|)
else|:
operator|*
name|p1
expr_stmt|;
name|c2
operator|=
name|isupper
argument_list|(
operator|*
name|p2
argument_list|)
condition|?
name|tolower
argument_list|(
operator|*
name|p2
argument_list|)
else|:
operator|*
name|p2
expr_stmt|;
if|if
condition|(
name|c1
operator|==
literal|'\0'
condition|)
break|break;
operator|++
name|p1
expr_stmt|;
operator|++
name|p2
expr_stmt|;
block|}
do|while
condition|(
name|c1
operator|==
name|c2
condition|)
do|;
return|return
name|c1
operator|-
name|c2
return|;
endif|#
directive|endif
block|}
end_function

end_unit

