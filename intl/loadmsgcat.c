begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Load needed message catalogs.    Copyright (C) 1995-1999, 2000-2003 Free Software Foundation, Inc.     This program is free software; you can redistribute it and/or modify it    under the terms of the GNU Library General Public License as published    by the Free Software Foundation; either version 2, or (at your option)    any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU    Library General Public License for more details.     You should have received a copy of the GNU Library General Public    License along with this program; if not, write to the Free Software    Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301,    USA.  */
end_comment

begin_comment
comment|/* Tell glibc's<string.h> to provide a prototype for mempcpy().    This must come before<config.h> because<config.h> may include<features.h>, and once<features.h> has been included, it's too late.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|_GNU_SOURCE
end_ifndef

begin_define
define|#
directive|define
name|_GNU_SOURCE
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_CONFIG_H
end_ifdef

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|__GNUC__
end_ifdef

begin_undef
undef|#
directive|undef
name|alloca
end_undef

begin_define
define|#
directive|define
name|alloca
value|__builtin_alloca
end_define

begin_define
define|#
directive|define
name|HAVE_ALLOCA
value|1
end_define

begin_else
else|#
directive|else
end_else

begin_ifdef
ifdef|#
directive|ifdef
name|_MSC_VER
end_ifdef

begin_include
include|#
directive|include
file|<malloc.h>
end_include

begin_define
define|#
directive|define
name|alloca
value|_alloca
end_define

begin_else
else|#
directive|else
end_else

begin_if
if|#
directive|if
name|defined
name|HAVE_ALLOCA_H
operator|||
name|defined
name|_LIBC
end_if

begin_include
include|#
directive|include
file|<alloca.h>
end_include

begin_else
else|#
directive|else
end_else

begin_ifdef
ifdef|#
directive|ifdef
name|_AIX
end_ifdef

begin_pragma
pragma|#
directive|pragma
name|alloca
end_pragma

begin_else
else|#
directive|else
end_else

begin_ifndef
ifndef|#
directive|ifndef
name|alloca
end_ifndef

begin_function_decl
name|char
modifier|*
name|alloca
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_if
if|#
directive|if
name|defined
name|HAVE_UNISTD_H
operator|||
name|defined
name|_LIBC
end_if

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|_LIBC
end_ifdef

begin_include
include|#
directive|include
file|<langinfo.h>
end_include

begin_include
include|#
directive|include
file|<locale.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|(
name|defined
name|HAVE_MMAP
operator|&&
name|defined
name|HAVE_MUNMAP
operator|&&
operator|!
name|defined
name|DISALLOW_MMAP
operator|)
expr|\
operator|||
operator|(
name|defined
name|_LIBC
operator|&&
name|defined
name|_POSIX_MAPPED_FILES
operator|)
end_if

begin_include
include|#
directive|include
file|<sys/mman.h>
end_include

begin_undef
undef|#
directive|undef
name|HAVE_MMAP
end_undef

begin_define
define|#
directive|define
name|HAVE_MMAP
value|1
end_define

begin_else
else|#
directive|else
end_else

begin_undef
undef|#
directive|undef
name|HAVE_MMAP
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
name|HAVE_STDINT_H_WITH_UINTMAX
operator|||
name|defined
name|_LIBC
end_if

begin_include
include|#
directive|include
file|<stdint.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
name|HAVE_INTTYPES_H
operator|||
name|defined
name|_LIBC
end_if

begin_include
include|#
directive|include
file|<inttypes.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"gmo.h"
end_include

begin_include
include|#
directive|include
file|"gettextP.h"
end_include

begin_include
include|#
directive|include
file|"hash-string.h"
end_include

begin_include
include|#
directive|include
file|"plural-exp.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|_LIBC
end_ifdef

begin_include
include|#
directive|include
file|"../locale/localeinfo.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Provide fallback values for macros that ought to be defined in<inttypes.h>.    Note that our fallback values need not be literal strings, because we don't    use them with preprocessor string concatenation.  */
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
name|PRId8
operator|||
name|PRI_MACROS_BROKEN
end_if

begin_undef
undef|#
directive|undef
name|PRId8
end_undef

begin_define
define|#
directive|define
name|PRId8
value|"d"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
name|PRIi8
operator|||
name|PRI_MACROS_BROKEN
end_if

begin_undef
undef|#
directive|undef
name|PRIi8
end_undef

begin_define
define|#
directive|define
name|PRIi8
value|"i"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
name|PRIo8
operator|||
name|PRI_MACROS_BROKEN
end_if

begin_undef
undef|#
directive|undef
name|PRIo8
end_undef

begin_define
define|#
directive|define
name|PRIo8
value|"o"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
name|PRIu8
operator|||
name|PRI_MACROS_BROKEN
end_if

begin_undef
undef|#
directive|undef
name|PRIu8
end_undef

begin_define
define|#
directive|define
name|PRIu8
value|"u"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
name|PRIx8
operator|||
name|PRI_MACROS_BROKEN
end_if

begin_undef
undef|#
directive|undef
name|PRIx8
end_undef

begin_define
define|#
directive|define
name|PRIx8
value|"x"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
name|PRIX8
operator|||
name|PRI_MACROS_BROKEN
end_if

begin_undef
undef|#
directive|undef
name|PRIX8
end_undef

begin_define
define|#
directive|define
name|PRIX8
value|"X"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
name|PRId16
operator|||
name|PRI_MACROS_BROKEN
end_if

begin_undef
undef|#
directive|undef
name|PRId16
end_undef

begin_define
define|#
directive|define
name|PRId16
value|"d"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
name|PRIi16
operator|||
name|PRI_MACROS_BROKEN
end_if

begin_undef
undef|#
directive|undef
name|PRIi16
end_undef

begin_define
define|#
directive|define
name|PRIi16
value|"i"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
name|PRIo16
operator|||
name|PRI_MACROS_BROKEN
end_if

begin_undef
undef|#
directive|undef
name|PRIo16
end_undef

begin_define
define|#
directive|define
name|PRIo16
value|"o"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
name|PRIu16
operator|||
name|PRI_MACROS_BROKEN
end_if

begin_undef
undef|#
directive|undef
name|PRIu16
end_undef

begin_define
define|#
directive|define
name|PRIu16
value|"u"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
name|PRIx16
operator|||
name|PRI_MACROS_BROKEN
end_if

begin_undef
undef|#
directive|undef
name|PRIx16
end_undef

begin_define
define|#
directive|define
name|PRIx16
value|"x"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
name|PRIX16
operator|||
name|PRI_MACROS_BROKEN
end_if

begin_undef
undef|#
directive|undef
name|PRIX16
end_undef

begin_define
define|#
directive|define
name|PRIX16
value|"X"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
name|PRId32
operator|||
name|PRI_MACROS_BROKEN
end_if

begin_undef
undef|#
directive|undef
name|PRId32
end_undef

begin_define
define|#
directive|define
name|PRId32
value|"d"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
name|PRIi32
operator|||
name|PRI_MACROS_BROKEN
end_if

begin_undef
undef|#
directive|undef
name|PRIi32
end_undef

begin_define
define|#
directive|define
name|PRIi32
value|"i"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
name|PRIo32
operator|||
name|PRI_MACROS_BROKEN
end_if

begin_undef
undef|#
directive|undef
name|PRIo32
end_undef

begin_define
define|#
directive|define
name|PRIo32
value|"o"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
name|PRIu32
operator|||
name|PRI_MACROS_BROKEN
end_if

begin_undef
undef|#
directive|undef
name|PRIu32
end_undef

begin_define
define|#
directive|define
name|PRIu32
value|"u"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
name|PRIx32
operator|||
name|PRI_MACROS_BROKEN
end_if

begin_undef
undef|#
directive|undef
name|PRIx32
end_undef

begin_define
define|#
directive|define
name|PRIx32
value|"x"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
name|PRIX32
operator|||
name|PRI_MACROS_BROKEN
end_if

begin_undef
undef|#
directive|undef
name|PRIX32
end_undef

begin_define
define|#
directive|define
name|PRIX32
value|"X"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
name|PRId64
operator|||
name|PRI_MACROS_BROKEN
end_if

begin_undef
undef|#
directive|undef
name|PRId64
end_undef

begin_define
define|#
directive|define
name|PRId64
value|(sizeof (long) == 8 ? "ld" : "lld")
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
name|PRIi64
operator|||
name|PRI_MACROS_BROKEN
end_if

begin_undef
undef|#
directive|undef
name|PRIi64
end_undef

begin_define
define|#
directive|define
name|PRIi64
value|(sizeof (long) == 8 ? "li" : "lli")
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
name|PRIo64
operator|||
name|PRI_MACROS_BROKEN
end_if

begin_undef
undef|#
directive|undef
name|PRIo64
end_undef

begin_define
define|#
directive|define
name|PRIo64
value|(sizeof (long) == 8 ? "lo" : "llo")
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
name|PRIu64
operator|||
name|PRI_MACROS_BROKEN
end_if

begin_undef
undef|#
directive|undef
name|PRIu64
end_undef

begin_define
define|#
directive|define
name|PRIu64
value|(sizeof (long) == 8 ? "lu" : "llu")
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
name|PRIx64
operator|||
name|PRI_MACROS_BROKEN
end_if

begin_undef
undef|#
directive|undef
name|PRIx64
end_undef

begin_define
define|#
directive|define
name|PRIx64
value|(sizeof (long) == 8 ? "lx" : "llx")
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
name|PRIX64
operator|||
name|PRI_MACROS_BROKEN
end_if

begin_undef
undef|#
directive|undef
name|PRIX64
end_undef

begin_define
define|#
directive|define
name|PRIX64
value|(sizeof (long) == 8 ? "lX" : "llX")
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
name|PRIdLEAST8
operator|||
name|PRI_MACROS_BROKEN
end_if

begin_undef
undef|#
directive|undef
name|PRIdLEAST8
end_undef

begin_define
define|#
directive|define
name|PRIdLEAST8
value|"d"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
name|PRIiLEAST8
operator|||
name|PRI_MACROS_BROKEN
end_if

begin_undef
undef|#
directive|undef
name|PRIiLEAST8
end_undef

begin_define
define|#
directive|define
name|PRIiLEAST8
value|"i"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
name|PRIoLEAST8
operator|||
name|PRI_MACROS_BROKEN
end_if

begin_undef
undef|#
directive|undef
name|PRIoLEAST8
end_undef

begin_define
define|#
directive|define
name|PRIoLEAST8
value|"o"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
name|PRIuLEAST8
operator|||
name|PRI_MACROS_BROKEN
end_if

begin_undef
undef|#
directive|undef
name|PRIuLEAST8
end_undef

begin_define
define|#
directive|define
name|PRIuLEAST8
value|"u"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
name|PRIxLEAST8
operator|||
name|PRI_MACROS_BROKEN
end_if

begin_undef
undef|#
directive|undef
name|PRIxLEAST8
end_undef

begin_define
define|#
directive|define
name|PRIxLEAST8
value|"x"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
name|PRIXLEAST8
operator|||
name|PRI_MACROS_BROKEN
end_if

begin_undef
undef|#
directive|undef
name|PRIXLEAST8
end_undef

begin_define
define|#
directive|define
name|PRIXLEAST8
value|"X"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
name|PRIdLEAST16
operator|||
name|PRI_MACROS_BROKEN
end_if

begin_undef
undef|#
directive|undef
name|PRIdLEAST16
end_undef

begin_define
define|#
directive|define
name|PRIdLEAST16
value|"d"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
name|PRIiLEAST16
operator|||
name|PRI_MACROS_BROKEN
end_if

begin_undef
undef|#
directive|undef
name|PRIiLEAST16
end_undef

begin_define
define|#
directive|define
name|PRIiLEAST16
value|"i"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
name|PRIoLEAST16
operator|||
name|PRI_MACROS_BROKEN
end_if

begin_undef
undef|#
directive|undef
name|PRIoLEAST16
end_undef

begin_define
define|#
directive|define
name|PRIoLEAST16
value|"o"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
name|PRIuLEAST16
operator|||
name|PRI_MACROS_BROKEN
end_if

begin_undef
undef|#
directive|undef
name|PRIuLEAST16
end_undef

begin_define
define|#
directive|define
name|PRIuLEAST16
value|"u"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
name|PRIxLEAST16
operator|||
name|PRI_MACROS_BROKEN
end_if

begin_undef
undef|#
directive|undef
name|PRIxLEAST16
end_undef

begin_define
define|#
directive|define
name|PRIxLEAST16
value|"x"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
name|PRIXLEAST16
operator|||
name|PRI_MACROS_BROKEN
end_if

begin_undef
undef|#
directive|undef
name|PRIXLEAST16
end_undef

begin_define
define|#
directive|define
name|PRIXLEAST16
value|"X"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
name|PRIdLEAST32
operator|||
name|PRI_MACROS_BROKEN
end_if

begin_undef
undef|#
directive|undef
name|PRIdLEAST32
end_undef

begin_define
define|#
directive|define
name|PRIdLEAST32
value|"d"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
name|PRIiLEAST32
operator|||
name|PRI_MACROS_BROKEN
end_if

begin_undef
undef|#
directive|undef
name|PRIiLEAST32
end_undef

begin_define
define|#
directive|define
name|PRIiLEAST32
value|"i"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
name|PRIoLEAST32
operator|||
name|PRI_MACROS_BROKEN
end_if

begin_undef
undef|#
directive|undef
name|PRIoLEAST32
end_undef

begin_define
define|#
directive|define
name|PRIoLEAST32
value|"o"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
name|PRIuLEAST32
operator|||
name|PRI_MACROS_BROKEN
end_if

begin_undef
undef|#
directive|undef
name|PRIuLEAST32
end_undef

begin_define
define|#
directive|define
name|PRIuLEAST32
value|"u"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
name|PRIxLEAST32
operator|||
name|PRI_MACROS_BROKEN
end_if

begin_undef
undef|#
directive|undef
name|PRIxLEAST32
end_undef

begin_define
define|#
directive|define
name|PRIxLEAST32
value|"x"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
name|PRIXLEAST32
operator|||
name|PRI_MACROS_BROKEN
end_if

begin_undef
undef|#
directive|undef
name|PRIXLEAST32
end_undef

begin_define
define|#
directive|define
name|PRIXLEAST32
value|"X"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
name|PRIdLEAST64
operator|||
name|PRI_MACROS_BROKEN
end_if

begin_undef
undef|#
directive|undef
name|PRIdLEAST64
end_undef

begin_define
define|#
directive|define
name|PRIdLEAST64
value|PRId64
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
name|PRIiLEAST64
operator|||
name|PRI_MACROS_BROKEN
end_if

begin_undef
undef|#
directive|undef
name|PRIiLEAST64
end_undef

begin_define
define|#
directive|define
name|PRIiLEAST64
value|PRIi64
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
name|PRIoLEAST64
operator|||
name|PRI_MACROS_BROKEN
end_if

begin_undef
undef|#
directive|undef
name|PRIoLEAST64
end_undef

begin_define
define|#
directive|define
name|PRIoLEAST64
value|PRIo64
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
name|PRIuLEAST64
operator|||
name|PRI_MACROS_BROKEN
end_if

begin_undef
undef|#
directive|undef
name|PRIuLEAST64
end_undef

begin_define
define|#
directive|define
name|PRIuLEAST64
value|PRIu64
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
name|PRIxLEAST64
operator|||
name|PRI_MACROS_BROKEN
end_if

begin_undef
undef|#
directive|undef
name|PRIxLEAST64
end_undef

begin_define
define|#
directive|define
name|PRIxLEAST64
value|PRIx64
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
name|PRIXLEAST64
operator|||
name|PRI_MACROS_BROKEN
end_if

begin_undef
undef|#
directive|undef
name|PRIXLEAST64
end_undef

begin_define
define|#
directive|define
name|PRIXLEAST64
value|PRIX64
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
name|PRIdFAST8
operator|||
name|PRI_MACROS_BROKEN
end_if

begin_undef
undef|#
directive|undef
name|PRIdFAST8
end_undef

begin_define
define|#
directive|define
name|PRIdFAST8
value|"d"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
name|PRIiFAST8
operator|||
name|PRI_MACROS_BROKEN
end_if

begin_undef
undef|#
directive|undef
name|PRIiFAST8
end_undef

begin_define
define|#
directive|define
name|PRIiFAST8
value|"i"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
name|PRIoFAST8
operator|||
name|PRI_MACROS_BROKEN
end_if

begin_undef
undef|#
directive|undef
name|PRIoFAST8
end_undef

begin_define
define|#
directive|define
name|PRIoFAST8
value|"o"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
name|PRIuFAST8
operator|||
name|PRI_MACROS_BROKEN
end_if

begin_undef
undef|#
directive|undef
name|PRIuFAST8
end_undef

begin_define
define|#
directive|define
name|PRIuFAST8
value|"u"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
name|PRIxFAST8
operator|||
name|PRI_MACROS_BROKEN
end_if

begin_undef
undef|#
directive|undef
name|PRIxFAST8
end_undef

begin_define
define|#
directive|define
name|PRIxFAST8
value|"x"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
name|PRIXFAST8
operator|||
name|PRI_MACROS_BROKEN
end_if

begin_undef
undef|#
directive|undef
name|PRIXFAST8
end_undef

begin_define
define|#
directive|define
name|PRIXFAST8
value|"X"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
name|PRIdFAST16
operator|||
name|PRI_MACROS_BROKEN
end_if

begin_undef
undef|#
directive|undef
name|PRIdFAST16
end_undef

begin_define
define|#
directive|define
name|PRIdFAST16
value|"d"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
name|PRIiFAST16
operator|||
name|PRI_MACROS_BROKEN
end_if

begin_undef
undef|#
directive|undef
name|PRIiFAST16
end_undef

begin_define
define|#
directive|define
name|PRIiFAST16
value|"i"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
name|PRIoFAST16
operator|||
name|PRI_MACROS_BROKEN
end_if

begin_undef
undef|#
directive|undef
name|PRIoFAST16
end_undef

begin_define
define|#
directive|define
name|PRIoFAST16
value|"o"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
name|PRIuFAST16
operator|||
name|PRI_MACROS_BROKEN
end_if

begin_undef
undef|#
directive|undef
name|PRIuFAST16
end_undef

begin_define
define|#
directive|define
name|PRIuFAST16
value|"u"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
name|PRIxFAST16
operator|||
name|PRI_MACROS_BROKEN
end_if

begin_undef
undef|#
directive|undef
name|PRIxFAST16
end_undef

begin_define
define|#
directive|define
name|PRIxFAST16
value|"x"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
name|PRIXFAST16
operator|||
name|PRI_MACROS_BROKEN
end_if

begin_undef
undef|#
directive|undef
name|PRIXFAST16
end_undef

begin_define
define|#
directive|define
name|PRIXFAST16
value|"X"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
name|PRIdFAST32
operator|||
name|PRI_MACROS_BROKEN
end_if

begin_undef
undef|#
directive|undef
name|PRIdFAST32
end_undef

begin_define
define|#
directive|define
name|PRIdFAST32
value|"d"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
name|PRIiFAST32
operator|||
name|PRI_MACROS_BROKEN
end_if

begin_undef
undef|#
directive|undef
name|PRIiFAST32
end_undef

begin_define
define|#
directive|define
name|PRIiFAST32
value|"i"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
name|PRIoFAST32
operator|||
name|PRI_MACROS_BROKEN
end_if

begin_undef
undef|#
directive|undef
name|PRIoFAST32
end_undef

begin_define
define|#
directive|define
name|PRIoFAST32
value|"o"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
name|PRIuFAST32
operator|||
name|PRI_MACROS_BROKEN
end_if

begin_undef
undef|#
directive|undef
name|PRIuFAST32
end_undef

begin_define
define|#
directive|define
name|PRIuFAST32
value|"u"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
name|PRIxFAST32
operator|||
name|PRI_MACROS_BROKEN
end_if

begin_undef
undef|#
directive|undef
name|PRIxFAST32
end_undef

begin_define
define|#
directive|define
name|PRIxFAST32
value|"x"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
name|PRIXFAST32
operator|||
name|PRI_MACROS_BROKEN
end_if

begin_undef
undef|#
directive|undef
name|PRIXFAST32
end_undef

begin_define
define|#
directive|define
name|PRIXFAST32
value|"X"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
name|PRIdFAST64
operator|||
name|PRI_MACROS_BROKEN
end_if

begin_undef
undef|#
directive|undef
name|PRIdFAST64
end_undef

begin_define
define|#
directive|define
name|PRIdFAST64
value|PRId64
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
name|PRIiFAST64
operator|||
name|PRI_MACROS_BROKEN
end_if

begin_undef
undef|#
directive|undef
name|PRIiFAST64
end_undef

begin_define
define|#
directive|define
name|PRIiFAST64
value|PRIi64
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
name|PRIoFAST64
operator|||
name|PRI_MACROS_BROKEN
end_if

begin_undef
undef|#
directive|undef
name|PRIoFAST64
end_undef

begin_define
define|#
directive|define
name|PRIoFAST64
value|PRIo64
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
name|PRIuFAST64
operator|||
name|PRI_MACROS_BROKEN
end_if

begin_undef
undef|#
directive|undef
name|PRIuFAST64
end_undef

begin_define
define|#
directive|define
name|PRIuFAST64
value|PRIu64
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
name|PRIxFAST64
operator|||
name|PRI_MACROS_BROKEN
end_if

begin_undef
undef|#
directive|undef
name|PRIxFAST64
end_undef

begin_define
define|#
directive|define
name|PRIxFAST64
value|PRIx64
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
name|PRIXFAST64
operator|||
name|PRI_MACROS_BROKEN
end_if

begin_undef
undef|#
directive|undef
name|PRIXFAST64
end_undef

begin_define
define|#
directive|define
name|PRIXFAST64
value|PRIX64
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
name|PRIdMAX
operator|||
name|PRI_MACROS_BROKEN
end_if

begin_undef
undef|#
directive|undef
name|PRIdMAX
end_undef

begin_define
define|#
directive|define
name|PRIdMAX
value|(sizeof (uintmax_t) == sizeof (long) ? "ld" : "lld")
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
name|PRIiMAX
operator|||
name|PRI_MACROS_BROKEN
end_if

begin_undef
undef|#
directive|undef
name|PRIiMAX
end_undef

begin_define
define|#
directive|define
name|PRIiMAX
value|(sizeof (uintmax_t) == sizeof (long) ? "li" : "lli")
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
name|PRIoMAX
operator|||
name|PRI_MACROS_BROKEN
end_if

begin_undef
undef|#
directive|undef
name|PRIoMAX
end_undef

begin_define
define|#
directive|define
name|PRIoMAX
value|(sizeof (uintmax_t) == sizeof (long) ? "lo" : "llo")
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
name|PRIuMAX
operator|||
name|PRI_MACROS_BROKEN
end_if

begin_undef
undef|#
directive|undef
name|PRIuMAX
end_undef

begin_define
define|#
directive|define
name|PRIuMAX
value|(sizeof (uintmax_t) == sizeof (long) ? "lu" : "llu")
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
name|PRIxMAX
operator|||
name|PRI_MACROS_BROKEN
end_if

begin_undef
undef|#
directive|undef
name|PRIxMAX
end_undef

begin_define
define|#
directive|define
name|PRIxMAX
value|(sizeof (uintmax_t) == sizeof (long) ? "lx" : "llx")
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
name|PRIXMAX
operator|||
name|PRI_MACROS_BROKEN
end_if

begin_undef
undef|#
directive|undef
name|PRIXMAX
end_undef

begin_define
define|#
directive|define
name|PRIXMAX
value|(sizeof (uintmax_t) == sizeof (long) ? "lX" : "llX")
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
name|PRIdPTR
operator|||
name|PRI_MACROS_BROKEN
end_if

begin_undef
undef|#
directive|undef
name|PRIdPTR
end_undef

begin_define
define|#
directive|define
name|PRIdPTR
define|\
value|(sizeof (void *) == sizeof (long) ? "ld" : \    sizeof (void *) == sizeof (int) ? "d" : \    "lld")
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
name|PRIiPTR
operator|||
name|PRI_MACROS_BROKEN
end_if

begin_undef
undef|#
directive|undef
name|PRIiPTR
end_undef

begin_define
define|#
directive|define
name|PRIiPTR
define|\
value|(sizeof (void *) == sizeof (long) ? "li" : \    sizeof (void *) == sizeof (int) ? "i" : \    "lli")
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
name|PRIoPTR
operator|||
name|PRI_MACROS_BROKEN
end_if

begin_undef
undef|#
directive|undef
name|PRIoPTR
end_undef

begin_define
define|#
directive|define
name|PRIoPTR
define|\
value|(sizeof (void *) == sizeof (long) ? "lo" : \    sizeof (void *) == sizeof (int) ? "o" : \    "llo")
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
name|PRIuPTR
operator|||
name|PRI_MACROS_BROKEN
end_if

begin_undef
undef|#
directive|undef
name|PRIuPTR
end_undef

begin_define
define|#
directive|define
name|PRIuPTR
define|\
value|(sizeof (void *) == sizeof (long) ? "lu" : \    sizeof (void *) == sizeof (int) ? "u" : \    "llu")
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
name|PRIxPTR
operator|||
name|PRI_MACROS_BROKEN
end_if

begin_undef
undef|#
directive|undef
name|PRIxPTR
end_undef

begin_define
define|#
directive|define
name|PRIxPTR
define|\
value|(sizeof (void *) == sizeof (long) ? "lx" : \    sizeof (void *) == sizeof (int) ? "x" : \    "llx")
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
name|PRIXPTR
operator|||
name|PRI_MACROS_BROKEN
end_if

begin_undef
undef|#
directive|undef
name|PRIXPTR
end_undef

begin_define
define|#
directive|define
name|PRIXPTR
define|\
value|(sizeof (void *) == sizeof (long) ? "lX" : \    sizeof (void *) == sizeof (int) ? "X" : \    "llX")
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* @@ end of prolog @@ */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|_LIBC
end_ifdef

begin_comment
comment|/* Rename the non ISO C functions.  This is required by the standard    because some ISO C functions will require linking with this object    file and the name space must not be polluted.  */
end_comment

begin_define
define|#
directive|define
name|open
value|__open
end_define

begin_define
define|#
directive|define
name|close
value|__close
end_define

begin_define
define|#
directive|define
name|read
value|__read
end_define

begin_define
define|#
directive|define
name|mmap
value|__mmap
end_define

begin_define
define|#
directive|define
name|munmap
value|__munmap
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* For those losing systems which don't have `alloca' we have to add    some additional code emulating it.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_ALLOCA
end_ifdef

begin_define
define|#
directive|define
name|freea
parameter_list|(
name|p
parameter_list|)
end_define

begin_comment
comment|/* nothing */
end_comment

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|alloca
parameter_list|(
name|n
parameter_list|)
value|malloc (n)
end_define

begin_define
define|#
directive|define
name|freea
parameter_list|(
name|p
parameter_list|)
value|free (p)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* For systems that distinguish between text and binary I/O.    O_BINARY is usually declared in<fcntl.h>. */
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
name|O_BINARY
operator|&&
name|defined
name|_O_BINARY
end_if

begin_comment
comment|/* For MSC-compatible compilers.  */
end_comment

begin_define
define|#
directive|define
name|O_BINARY
value|_O_BINARY
end_define

begin_define
define|#
directive|define
name|O_TEXT
value|_O_TEXT
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|__BEOS__
end_ifdef

begin_comment
comment|/* BeOS 5 has O_BINARY and O_TEXT, but they have no effect.  */
end_comment

begin_undef
undef|#
directive|undef
name|O_BINARY
end_undef

begin_undef
undef|#
directive|undef
name|O_TEXT
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* On reasonable systems, binary I/O is the default.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|O_BINARY
end_ifndef

begin_define
define|#
directive|define
name|O_BINARY
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Prototypes for local functions.  Needed to ensure compiler checking of    function argument counts despite of K&R C function definition syntax.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|get_sysdep_segment_value
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
name|name
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* We need a sign, whether a new catalog was loaded, which can be associated    with all translations.  This is important if the translations are    cached by one of GCC's features.  */
end_comment

begin_decl_stmt
name|int
name|_nl_msg_cat_cntr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Expand a system dependent string segment.  Return NULL if unsupported.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|get_sysdep_segment_value
parameter_list|(
name|name
parameter_list|)
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|{
comment|/* Test for an ISO C 99 section 7.8.1 format string directive.      Syntax:      P R I { d | i | o | u | x | X }      { { | LEAST | FAST } { 8 | 16 | 32 | 64 } | MAX | PTR }  */
comment|/* We don't use a table of 14 times 6 'const char *' strings here, because      data relocations cost startup time.  */
if|if
condition|(
name|name
index|[
literal|0
index|]
operator|==
literal|'P'
operator|&&
name|name
index|[
literal|1
index|]
operator|==
literal|'R'
operator|&&
name|name
index|[
literal|2
index|]
operator|==
literal|'I'
condition|)
block|{
if|if
condition|(
name|name
index|[
literal|3
index|]
operator|==
literal|'d'
operator|||
name|name
index|[
literal|3
index|]
operator|==
literal|'i'
operator|||
name|name
index|[
literal|3
index|]
operator|==
literal|'o'
operator|||
name|name
index|[
literal|3
index|]
operator|==
literal|'u'
operator|||
name|name
index|[
literal|3
index|]
operator|==
literal|'x'
operator|||
name|name
index|[
literal|3
index|]
operator|==
literal|'X'
condition|)
block|{
if|if
condition|(
name|name
index|[
literal|4
index|]
operator|==
literal|'8'
operator|&&
name|name
index|[
literal|5
index|]
operator|==
literal|'\0'
condition|)
block|{
if|if
condition|(
name|name
index|[
literal|3
index|]
operator|==
literal|'d'
condition|)
return|return
name|PRId8
return|;
if|if
condition|(
name|name
index|[
literal|3
index|]
operator|==
literal|'i'
condition|)
return|return
name|PRIi8
return|;
if|if
condition|(
name|name
index|[
literal|3
index|]
operator|==
literal|'o'
condition|)
return|return
name|PRIo8
return|;
if|if
condition|(
name|name
index|[
literal|3
index|]
operator|==
literal|'u'
condition|)
return|return
name|PRIu8
return|;
if|if
condition|(
name|name
index|[
literal|3
index|]
operator|==
literal|'x'
condition|)
return|return
name|PRIx8
return|;
if|if
condition|(
name|name
index|[
literal|3
index|]
operator|==
literal|'X'
condition|)
return|return
name|PRIX8
return|;
name|abort
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|name
index|[
literal|4
index|]
operator|==
literal|'1'
operator|&&
name|name
index|[
literal|5
index|]
operator|==
literal|'6'
operator|&&
name|name
index|[
literal|6
index|]
operator|==
literal|'\0'
condition|)
block|{
if|if
condition|(
name|name
index|[
literal|3
index|]
operator|==
literal|'d'
condition|)
return|return
name|PRId16
return|;
if|if
condition|(
name|name
index|[
literal|3
index|]
operator|==
literal|'i'
condition|)
return|return
name|PRIi16
return|;
if|if
condition|(
name|name
index|[
literal|3
index|]
operator|==
literal|'o'
condition|)
return|return
name|PRIo16
return|;
if|if
condition|(
name|name
index|[
literal|3
index|]
operator|==
literal|'u'
condition|)
return|return
name|PRIu16
return|;
if|if
condition|(
name|name
index|[
literal|3
index|]
operator|==
literal|'x'
condition|)
return|return
name|PRIx16
return|;
if|if
condition|(
name|name
index|[
literal|3
index|]
operator|==
literal|'X'
condition|)
return|return
name|PRIX16
return|;
name|abort
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|name
index|[
literal|4
index|]
operator|==
literal|'3'
operator|&&
name|name
index|[
literal|5
index|]
operator|==
literal|'2'
operator|&&
name|name
index|[
literal|6
index|]
operator|==
literal|'\0'
condition|)
block|{
if|if
condition|(
name|name
index|[
literal|3
index|]
operator|==
literal|'d'
condition|)
return|return
name|PRId32
return|;
if|if
condition|(
name|name
index|[
literal|3
index|]
operator|==
literal|'i'
condition|)
return|return
name|PRIi32
return|;
if|if
condition|(
name|name
index|[
literal|3
index|]
operator|==
literal|'o'
condition|)
return|return
name|PRIo32
return|;
if|if
condition|(
name|name
index|[
literal|3
index|]
operator|==
literal|'u'
condition|)
return|return
name|PRIu32
return|;
if|if
condition|(
name|name
index|[
literal|3
index|]
operator|==
literal|'x'
condition|)
return|return
name|PRIx32
return|;
if|if
condition|(
name|name
index|[
literal|3
index|]
operator|==
literal|'X'
condition|)
return|return
name|PRIX32
return|;
name|abort
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|name
index|[
literal|4
index|]
operator|==
literal|'6'
operator|&&
name|name
index|[
literal|5
index|]
operator|==
literal|'4'
operator|&&
name|name
index|[
literal|6
index|]
operator|==
literal|'\0'
condition|)
block|{
if|if
condition|(
name|name
index|[
literal|3
index|]
operator|==
literal|'d'
condition|)
return|return
name|PRId64
return|;
if|if
condition|(
name|name
index|[
literal|3
index|]
operator|==
literal|'i'
condition|)
return|return
name|PRIi64
return|;
if|if
condition|(
name|name
index|[
literal|3
index|]
operator|==
literal|'o'
condition|)
return|return
name|PRIo64
return|;
if|if
condition|(
name|name
index|[
literal|3
index|]
operator|==
literal|'u'
condition|)
return|return
name|PRIu64
return|;
if|if
condition|(
name|name
index|[
literal|3
index|]
operator|==
literal|'x'
condition|)
return|return
name|PRIx64
return|;
if|if
condition|(
name|name
index|[
literal|3
index|]
operator|==
literal|'X'
condition|)
return|return
name|PRIX64
return|;
name|abort
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|name
index|[
literal|4
index|]
operator|==
literal|'L'
operator|&&
name|name
index|[
literal|5
index|]
operator|==
literal|'E'
operator|&&
name|name
index|[
literal|6
index|]
operator|==
literal|'A'
operator|&&
name|name
index|[
literal|7
index|]
operator|==
literal|'S'
operator|&&
name|name
index|[
literal|8
index|]
operator|==
literal|'T'
condition|)
block|{
if|if
condition|(
name|name
index|[
literal|9
index|]
operator|==
literal|'8'
operator|&&
name|name
index|[
literal|10
index|]
operator|==
literal|'\0'
condition|)
block|{
if|if
condition|(
name|name
index|[
literal|3
index|]
operator|==
literal|'d'
condition|)
return|return
name|PRIdLEAST8
return|;
if|if
condition|(
name|name
index|[
literal|3
index|]
operator|==
literal|'i'
condition|)
return|return
name|PRIiLEAST8
return|;
if|if
condition|(
name|name
index|[
literal|3
index|]
operator|==
literal|'o'
condition|)
return|return
name|PRIoLEAST8
return|;
if|if
condition|(
name|name
index|[
literal|3
index|]
operator|==
literal|'u'
condition|)
return|return
name|PRIuLEAST8
return|;
if|if
condition|(
name|name
index|[
literal|3
index|]
operator|==
literal|'x'
condition|)
return|return
name|PRIxLEAST8
return|;
if|if
condition|(
name|name
index|[
literal|3
index|]
operator|==
literal|'X'
condition|)
return|return
name|PRIXLEAST8
return|;
name|abort
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|name
index|[
literal|9
index|]
operator|==
literal|'1'
operator|&&
name|name
index|[
literal|10
index|]
operator|==
literal|'6'
operator|&&
name|name
index|[
literal|11
index|]
operator|==
literal|'\0'
condition|)
block|{
if|if
condition|(
name|name
index|[
literal|3
index|]
operator|==
literal|'d'
condition|)
return|return
name|PRIdLEAST16
return|;
if|if
condition|(
name|name
index|[
literal|3
index|]
operator|==
literal|'i'
condition|)
return|return
name|PRIiLEAST16
return|;
if|if
condition|(
name|name
index|[
literal|3
index|]
operator|==
literal|'o'
condition|)
return|return
name|PRIoLEAST16
return|;
if|if
condition|(
name|name
index|[
literal|3
index|]
operator|==
literal|'u'
condition|)
return|return
name|PRIuLEAST16
return|;
if|if
condition|(
name|name
index|[
literal|3
index|]
operator|==
literal|'x'
condition|)
return|return
name|PRIxLEAST16
return|;
if|if
condition|(
name|name
index|[
literal|3
index|]
operator|==
literal|'X'
condition|)
return|return
name|PRIXLEAST16
return|;
name|abort
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|name
index|[
literal|9
index|]
operator|==
literal|'3'
operator|&&
name|name
index|[
literal|10
index|]
operator|==
literal|'2'
operator|&&
name|name
index|[
literal|11
index|]
operator|==
literal|'\0'
condition|)
block|{
if|if
condition|(
name|name
index|[
literal|3
index|]
operator|==
literal|'d'
condition|)
return|return
name|PRIdLEAST32
return|;
if|if
condition|(
name|name
index|[
literal|3
index|]
operator|==
literal|'i'
condition|)
return|return
name|PRIiLEAST32
return|;
if|if
condition|(
name|name
index|[
literal|3
index|]
operator|==
literal|'o'
condition|)
return|return
name|PRIoLEAST32
return|;
if|if
condition|(
name|name
index|[
literal|3
index|]
operator|==
literal|'u'
condition|)
return|return
name|PRIuLEAST32
return|;
if|if
condition|(
name|name
index|[
literal|3
index|]
operator|==
literal|'x'
condition|)
return|return
name|PRIxLEAST32
return|;
if|if
condition|(
name|name
index|[
literal|3
index|]
operator|==
literal|'X'
condition|)
return|return
name|PRIXLEAST32
return|;
name|abort
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|name
index|[
literal|9
index|]
operator|==
literal|'6'
operator|&&
name|name
index|[
literal|10
index|]
operator|==
literal|'4'
operator|&&
name|name
index|[
literal|11
index|]
operator|==
literal|'\0'
condition|)
block|{
if|if
condition|(
name|name
index|[
literal|3
index|]
operator|==
literal|'d'
condition|)
return|return
name|PRIdLEAST64
return|;
if|if
condition|(
name|name
index|[
literal|3
index|]
operator|==
literal|'i'
condition|)
return|return
name|PRIiLEAST64
return|;
if|if
condition|(
name|name
index|[
literal|3
index|]
operator|==
literal|'o'
condition|)
return|return
name|PRIoLEAST64
return|;
if|if
condition|(
name|name
index|[
literal|3
index|]
operator|==
literal|'u'
condition|)
return|return
name|PRIuLEAST64
return|;
if|if
condition|(
name|name
index|[
literal|3
index|]
operator|==
literal|'x'
condition|)
return|return
name|PRIxLEAST64
return|;
if|if
condition|(
name|name
index|[
literal|3
index|]
operator|==
literal|'X'
condition|)
return|return
name|PRIXLEAST64
return|;
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
name|name
index|[
literal|4
index|]
operator|==
literal|'F'
operator|&&
name|name
index|[
literal|5
index|]
operator|==
literal|'A'
operator|&&
name|name
index|[
literal|6
index|]
operator|==
literal|'S'
operator|&&
name|name
index|[
literal|7
index|]
operator|==
literal|'T'
condition|)
block|{
if|if
condition|(
name|name
index|[
literal|8
index|]
operator|==
literal|'8'
operator|&&
name|name
index|[
literal|9
index|]
operator|==
literal|'\0'
condition|)
block|{
if|if
condition|(
name|name
index|[
literal|3
index|]
operator|==
literal|'d'
condition|)
return|return
name|PRIdFAST8
return|;
if|if
condition|(
name|name
index|[
literal|3
index|]
operator|==
literal|'i'
condition|)
return|return
name|PRIiFAST8
return|;
if|if
condition|(
name|name
index|[
literal|3
index|]
operator|==
literal|'o'
condition|)
return|return
name|PRIoFAST8
return|;
if|if
condition|(
name|name
index|[
literal|3
index|]
operator|==
literal|'u'
condition|)
return|return
name|PRIuFAST8
return|;
if|if
condition|(
name|name
index|[
literal|3
index|]
operator|==
literal|'x'
condition|)
return|return
name|PRIxFAST8
return|;
if|if
condition|(
name|name
index|[
literal|3
index|]
operator|==
literal|'X'
condition|)
return|return
name|PRIXFAST8
return|;
name|abort
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|name
index|[
literal|8
index|]
operator|==
literal|'1'
operator|&&
name|name
index|[
literal|9
index|]
operator|==
literal|'6'
operator|&&
name|name
index|[
literal|10
index|]
operator|==
literal|'\0'
condition|)
block|{
if|if
condition|(
name|name
index|[
literal|3
index|]
operator|==
literal|'d'
condition|)
return|return
name|PRIdFAST16
return|;
if|if
condition|(
name|name
index|[
literal|3
index|]
operator|==
literal|'i'
condition|)
return|return
name|PRIiFAST16
return|;
if|if
condition|(
name|name
index|[
literal|3
index|]
operator|==
literal|'o'
condition|)
return|return
name|PRIoFAST16
return|;
if|if
condition|(
name|name
index|[
literal|3
index|]
operator|==
literal|'u'
condition|)
return|return
name|PRIuFAST16
return|;
if|if
condition|(
name|name
index|[
literal|3
index|]
operator|==
literal|'x'
condition|)
return|return
name|PRIxFAST16
return|;
if|if
condition|(
name|name
index|[
literal|3
index|]
operator|==
literal|'X'
condition|)
return|return
name|PRIXFAST16
return|;
name|abort
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|name
index|[
literal|8
index|]
operator|==
literal|'3'
operator|&&
name|name
index|[
literal|9
index|]
operator|==
literal|'2'
operator|&&
name|name
index|[
literal|10
index|]
operator|==
literal|'\0'
condition|)
block|{
if|if
condition|(
name|name
index|[
literal|3
index|]
operator|==
literal|'d'
condition|)
return|return
name|PRIdFAST32
return|;
if|if
condition|(
name|name
index|[
literal|3
index|]
operator|==
literal|'i'
condition|)
return|return
name|PRIiFAST32
return|;
if|if
condition|(
name|name
index|[
literal|3
index|]
operator|==
literal|'o'
condition|)
return|return
name|PRIoFAST32
return|;
if|if
condition|(
name|name
index|[
literal|3
index|]
operator|==
literal|'u'
condition|)
return|return
name|PRIuFAST32
return|;
if|if
condition|(
name|name
index|[
literal|3
index|]
operator|==
literal|'x'
condition|)
return|return
name|PRIxFAST32
return|;
if|if
condition|(
name|name
index|[
literal|3
index|]
operator|==
literal|'X'
condition|)
return|return
name|PRIXFAST32
return|;
name|abort
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|name
index|[
literal|8
index|]
operator|==
literal|'6'
operator|&&
name|name
index|[
literal|9
index|]
operator|==
literal|'4'
operator|&&
name|name
index|[
literal|10
index|]
operator|==
literal|'\0'
condition|)
block|{
if|if
condition|(
name|name
index|[
literal|3
index|]
operator|==
literal|'d'
condition|)
return|return
name|PRIdFAST64
return|;
if|if
condition|(
name|name
index|[
literal|3
index|]
operator|==
literal|'i'
condition|)
return|return
name|PRIiFAST64
return|;
if|if
condition|(
name|name
index|[
literal|3
index|]
operator|==
literal|'o'
condition|)
return|return
name|PRIoFAST64
return|;
if|if
condition|(
name|name
index|[
literal|3
index|]
operator|==
literal|'u'
condition|)
return|return
name|PRIuFAST64
return|;
if|if
condition|(
name|name
index|[
literal|3
index|]
operator|==
literal|'x'
condition|)
return|return
name|PRIxFAST64
return|;
if|if
condition|(
name|name
index|[
literal|3
index|]
operator|==
literal|'X'
condition|)
return|return
name|PRIXFAST64
return|;
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
name|name
index|[
literal|4
index|]
operator|==
literal|'M'
operator|&&
name|name
index|[
literal|5
index|]
operator|==
literal|'A'
operator|&&
name|name
index|[
literal|6
index|]
operator|==
literal|'X'
operator|&&
name|name
index|[
literal|7
index|]
operator|==
literal|'\0'
condition|)
block|{
if|if
condition|(
name|name
index|[
literal|3
index|]
operator|==
literal|'d'
condition|)
return|return
name|PRIdMAX
return|;
if|if
condition|(
name|name
index|[
literal|3
index|]
operator|==
literal|'i'
condition|)
return|return
name|PRIiMAX
return|;
if|if
condition|(
name|name
index|[
literal|3
index|]
operator|==
literal|'o'
condition|)
return|return
name|PRIoMAX
return|;
if|if
condition|(
name|name
index|[
literal|3
index|]
operator|==
literal|'u'
condition|)
return|return
name|PRIuMAX
return|;
if|if
condition|(
name|name
index|[
literal|3
index|]
operator|==
literal|'x'
condition|)
return|return
name|PRIxMAX
return|;
if|if
condition|(
name|name
index|[
literal|3
index|]
operator|==
literal|'X'
condition|)
return|return
name|PRIXMAX
return|;
name|abort
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|name
index|[
literal|4
index|]
operator|==
literal|'P'
operator|&&
name|name
index|[
literal|5
index|]
operator|==
literal|'T'
operator|&&
name|name
index|[
literal|6
index|]
operator|==
literal|'R'
operator|&&
name|name
index|[
literal|7
index|]
operator|==
literal|'\0'
condition|)
block|{
if|if
condition|(
name|name
index|[
literal|3
index|]
operator|==
literal|'d'
condition|)
return|return
name|PRIdPTR
return|;
if|if
condition|(
name|name
index|[
literal|3
index|]
operator|==
literal|'i'
condition|)
return|return
name|PRIiPTR
return|;
if|if
condition|(
name|name
index|[
literal|3
index|]
operator|==
literal|'o'
condition|)
return|return
name|PRIoPTR
return|;
if|if
condition|(
name|name
index|[
literal|3
index|]
operator|==
literal|'u'
condition|)
return|return
name|PRIuPTR
return|;
if|if
condition|(
name|name
index|[
literal|3
index|]
operator|==
literal|'x'
condition|)
return|return
name|PRIxPTR
return|;
if|if
condition|(
name|name
index|[
literal|3
index|]
operator|==
literal|'X'
condition|)
return|return
name|PRIXPTR
return|;
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|/* Other system dependent strings are not valid.  */
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Initialize the codeset dependent parts of an opened message catalog.    Return the header entry.  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|internal_function
name|_nl_init_domain_conv
parameter_list|(
name|domain_file
parameter_list|,
name|domain
parameter_list|,
name|domainbinding
parameter_list|)
name|struct
name|loaded_l10nfile
modifier|*
name|domain_file
decl_stmt|;
name|struct
name|loaded_domain
modifier|*
name|domain
decl_stmt|;
name|struct
name|binding
modifier|*
name|domainbinding
decl_stmt|;
block|{
comment|/* Find out about the character set the file is encoded with.      This can be found (in textual form) in the entry "".  If this      entry does not exist or if this does not contain the `charset='      information, we will assume the charset matches the one the      current locale and we don't have to perform any conversion.  */
name|char
modifier|*
name|nullentry
decl_stmt|;
name|size_t
name|nullentrylen
decl_stmt|;
comment|/* Preinitialize fields, to avoid recursion during _nl_find_msg.  */
name|domain
operator|->
name|codeset_cntr
operator|=
operator|(
name|domainbinding
operator|!=
name|NULL
condition|?
name|domainbinding
operator|->
name|codeset_cntr
else|:
literal|0
operator|)
expr_stmt|;
ifdef|#
directive|ifdef
name|_LIBC
name|domain
operator|->
name|conv
operator|=
operator|(
name|__gconv_t
operator|)
operator|-
literal|1
expr_stmt|;
else|#
directive|else
if|#
directive|if
name|HAVE_ICONV
name|domain
operator|->
name|conv
operator|=
operator|(
name|iconv_t
operator|)
operator|-
literal|1
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
name|domain
operator|->
name|conv_tab
operator|=
name|NULL
expr_stmt|;
comment|/* Get the header entry.  */
name|nullentry
operator|=
name|_nl_find_msg
argument_list|(
name|domain_file
argument_list|,
name|domainbinding
argument_list|,
literal|""
argument_list|,
operator|&
name|nullentrylen
argument_list|)
expr_stmt|;
if|if
condition|(
name|nullentry
operator|!=
name|NULL
condition|)
block|{
if|#
directive|if
name|defined
name|_LIBC
operator|||
name|HAVE_ICONV
specifier|const
name|char
modifier|*
name|charsetstr
decl_stmt|;
name|charsetstr
operator|=
name|strstr
argument_list|(
name|nullentry
argument_list|,
literal|"charset="
argument_list|)
expr_stmt|;
if|if
condition|(
name|charsetstr
operator|!=
name|NULL
condition|)
block|{
name|size_t
name|len
decl_stmt|;
name|char
modifier|*
name|charset
decl_stmt|;
specifier|const
name|char
modifier|*
name|outcharset
decl_stmt|;
name|charsetstr
operator|+=
name|strlen
argument_list|(
literal|"charset="
argument_list|)
expr_stmt|;
name|len
operator|=
name|strcspn
argument_list|(
name|charsetstr
argument_list|,
literal|" \t\n"
argument_list|)
expr_stmt|;
name|charset
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
name|_LIBC
operator|||
name|HAVE_MEMPCPY
operator|*
operator|(
operator|(
name|char
operator|*
operator|)
name|mempcpy
argument_list|(
name|charset
argument_list|,
name|charsetstr
argument_list|,
name|len
argument_list|)
operator|)
operator|=
literal|'\0'
expr_stmt|;
else|#
directive|else
name|memcpy
argument_list|(
name|charset
argument_list|,
name|charsetstr
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|charset
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
endif|#
directive|endif
comment|/* The output charset should normally be determined by the 	     locale.  But sometimes the locale is not used or not correctly 	     set up, so we provide a possibility for the user to override 	     this.  Moreover, the value specified through 	     bind_textdomain_codeset overrides both.  */
if|if
condition|(
name|domainbinding
operator|!=
name|NULL
operator|&&
name|domainbinding
operator|->
name|codeset
operator|!=
name|NULL
condition|)
name|outcharset
operator|=
name|domainbinding
operator|->
name|codeset
expr_stmt|;
else|else
block|{
name|outcharset
operator|=
name|getenv
argument_list|(
literal|"OUTPUT_CHARSET"
argument_list|)
expr_stmt|;
if|if
condition|(
name|outcharset
operator|==
name|NULL
operator|||
name|outcharset
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
block|{
ifdef|#
directive|ifdef
name|_LIBC
name|outcharset
operator|=
name|_NL_CURRENT
argument_list|(
name|LC_CTYPE
argument_list|,
name|CODESET
argument_list|)
expr_stmt|;
else|#
directive|else
if|#
directive|if
name|HAVE_ICONV
specifier|extern
specifier|const
name|char
modifier|*
name|locale_charset
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
name|outcharset
operator|=
name|locale_charset
argument_list|()
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
block|}
block|}
ifdef|#
directive|ifdef
name|_LIBC
comment|/* We always want to use transliteration.  */
name|outcharset
operator|=
name|norm_add_slashes
argument_list|(
name|outcharset
argument_list|,
literal|"TRANSLIT"
argument_list|)
expr_stmt|;
name|charset
operator|=
name|norm_add_slashes
argument_list|(
name|charset
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|__gconv_open
argument_list|(
name|outcharset
argument_list|,
name|charset
argument_list|,
operator|&
name|domain
operator|->
name|conv
argument_list|,
name|GCONV_AVOID_NOCONV
argument_list|)
operator|!=
name|__GCONV_OK
condition|)
name|domain
operator|->
name|conv
operator|=
operator|(
name|__gconv_t
operator|)
operator|-
literal|1
expr_stmt|;
else|#
directive|else
if|#
directive|if
name|HAVE_ICONV
comment|/* When using GNU libc>= 2.2 or GNU libiconv>= 1.5, 	     we want to use transliteration.  */
if|#
directive|if
operator|(
name|__GLIBC__
operator|==
literal|2
operator|&&
name|__GLIBC_MINOR__
operator|>=
literal|2
operator|)
operator|||
name|__GLIBC__
operator|>
literal|2
expr|\
operator|||
name|_LIBICONV_VERSION
operator|>=
literal|0x0105
if|if
condition|(
name|strchr
argument_list|(
name|outcharset
argument_list|,
literal|'/'
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|char
modifier|*
name|tmp
decl_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|outcharset
argument_list|)
expr_stmt|;
name|tmp
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|len
operator|+
literal|10
operator|+
literal|1
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|tmp
argument_list|,
name|outcharset
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|tmp
operator|+
name|len
argument_list|,
literal|"//TRANSLIT"
argument_list|,
literal|10
operator|+
literal|1
argument_list|)
expr_stmt|;
name|outcharset
operator|=
name|tmp
expr_stmt|;
name|domain
operator|->
name|conv
operator|=
name|iconv_open
argument_list|(
name|outcharset
argument_list|,
name|charset
argument_list|)
expr_stmt|;
name|freea
argument_list|(
name|outcharset
argument_list|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
name|domain
operator|->
name|conv
operator|=
name|iconv_open
argument_list|(
name|outcharset
argument_list|,
name|charset
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
name|freea
argument_list|(
name|charset
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* _LIBC || HAVE_ICONV */
block|}
return|return
name|nullentry
return|;
block|}
end_function

begin_comment
comment|/* Frees the codeset dependent parts of an opened message catalog.  */
end_comment

begin_function
name|void
name|internal_function
name|_nl_free_domain_conv
parameter_list|(
name|domain
parameter_list|)
name|struct
name|loaded_domain
modifier|*
name|domain
decl_stmt|;
block|{
if|if
condition|(
name|domain
operator|->
name|conv_tab
operator|!=
name|NULL
operator|&&
name|domain
operator|->
name|conv_tab
operator|!=
operator|(
name|char
operator|*
operator|*
operator|)
operator|-
literal|1
condition|)
name|free
argument_list|(
name|domain
operator|->
name|conv_tab
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|_LIBC
if|if
condition|(
name|domain
operator|->
name|conv
operator|!=
operator|(
name|__gconv_t
operator|)
operator|-
literal|1
condition|)
name|__gconv_close
argument_list|(
name|domain
operator|->
name|conv
argument_list|)
expr_stmt|;
else|#
directive|else
if|#
directive|if
name|HAVE_ICONV
if|if
condition|(
name|domain
operator|->
name|conv
operator|!=
operator|(
name|iconv_t
operator|)
operator|-
literal|1
condition|)
name|iconv_close
argument_list|(
name|domain
operator|->
name|conv
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Load the message catalogs specified by FILENAME.  If it is no valid    message catalog do nothing.  */
end_comment

begin_function
name|void
name|internal_function
name|_nl_load_domain
parameter_list|(
name|domain_file
parameter_list|,
name|domainbinding
parameter_list|)
name|struct
name|loaded_l10nfile
modifier|*
name|domain_file
decl_stmt|;
name|struct
name|binding
modifier|*
name|domainbinding
decl_stmt|;
block|{
name|int
name|fd
decl_stmt|;
name|size_t
name|size
decl_stmt|;
ifdef|#
directive|ifdef
name|_LIBC
name|struct
name|stat64
name|st
decl_stmt|;
else|#
directive|else
name|struct
name|stat
name|st
decl_stmt|;
endif|#
directive|endif
name|struct
name|mo_file_header
modifier|*
name|data
init|=
operator|(
expr|struct
name|mo_file_header
operator|*
operator|)
operator|-
literal|1
decl_stmt|;
name|int
name|use_mmap
init|=
literal|0
decl_stmt|;
name|struct
name|loaded_domain
modifier|*
name|domain
decl_stmt|;
name|int
name|revision
decl_stmt|;
specifier|const
name|char
modifier|*
name|nullentry
decl_stmt|;
name|domain_file
operator|->
name|decided
operator|=
literal|1
expr_stmt|;
name|domain_file
operator|->
name|data
operator|=
name|NULL
expr_stmt|;
comment|/* Note that it would be useless to store domainbinding in domain_file      because domainbinding might be == NULL now but != NULL later (after      a call to bind_textdomain_codeset).  */
comment|/* If the record does not represent a valid locale the FILENAME      might be NULL.  This can happen when according to the given      specification the locale file name is different for XPG and CEN      syntax.  */
if|if
condition|(
name|domain_file
operator|->
name|filename
operator|==
name|NULL
condition|)
return|return;
comment|/* Try to open the addressed file.  */
name|fd
operator|=
name|open
argument_list|(
name|domain_file
operator|->
name|filename
argument_list|,
name|O_RDONLY
operator||
name|O_BINARY
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|==
operator|-
literal|1
condition|)
return|return;
comment|/* We must know about the size of the file.  */
if|if
condition|(
ifdef|#
directive|ifdef
name|_LIBC
name|__builtin_expect
argument_list|(
argument|fstat64 (fd,&st) !=
literal|0
argument_list|,
literal|0
argument_list|)
else|#
directive|else
name|__builtin_expect
argument_list|(
name|fstat
argument_list|(
name|fd
argument_list|,
operator|&
name|st
argument_list|)
operator|!=
literal|0
argument_list|,
literal|0
argument_list|)
endif|#
directive|endif
operator|||
name|__builtin_expect
argument_list|(
operator|(
name|size
operator|=
operator|(
name|size_t
operator|)
name|st
operator|.
name|st_size
operator|)
operator|!=
name|st
operator|.
name|st_size
argument_list|,
literal|0
argument_list|)
operator|||
name|__builtin_expect
argument_list|(
name|size
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|mo_file_header
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|)
block|{
comment|/* Something went wrong.  */
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return;
block|}
ifdef|#
directive|ifdef
name|HAVE_MMAP
comment|/* Now we are ready to load the file.  If mmap() is available we try      this first.  If not available or it failed we try to load it.  */
name|data
operator|=
operator|(
expr|struct
name|mo_file_header
operator|*
operator|)
name|mmap
argument_list|(
name|NULL
argument_list|,
name|size
argument_list|,
name|PROT_READ
argument_list|,
name|MAP_PRIVATE
argument_list|,
name|fd
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|__builtin_expect
argument_list|(
name|data
operator|!=
operator|(
expr|struct
name|mo_file_header
operator|*
operator|)
operator|-
literal|1
argument_list|,
literal|1
argument_list|)
condition|)
block|{
comment|/* mmap() call was successful.  */
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|use_mmap
operator|=
literal|1
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* If the data is not yet available (i.e. mmap'ed) we try to load      it manually.  */
if|if
condition|(
name|data
operator|==
operator|(
expr|struct
name|mo_file_header
operator|*
operator|)
operator|-
literal|1
condition|)
block|{
name|size_t
name|to_read
decl_stmt|;
name|char
modifier|*
name|read_ptr
decl_stmt|;
name|data
operator|=
operator|(
expr|struct
name|mo_file_header
operator|*
operator|)
name|malloc
argument_list|(
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|data
operator|==
name|NULL
condition|)
return|return;
name|to_read
operator|=
name|size
expr_stmt|;
name|read_ptr
operator|=
operator|(
name|char
operator|*
operator|)
name|data
expr_stmt|;
do|do
block|{
name|long
name|int
name|nb
init|=
operator|(
name|long
name|int
operator|)
name|read
argument_list|(
name|fd
argument_list|,
name|read_ptr
argument_list|,
name|to_read
argument_list|)
decl_stmt|;
if|if
condition|(
name|nb
operator|<=
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|EINTR
if|if
condition|(
name|nb
operator|==
operator|-
literal|1
operator|&&
name|errno
operator|==
name|EINTR
condition|)
continue|continue;
endif|#
directive|endif
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return;
block|}
name|read_ptr
operator|+=
name|nb
expr_stmt|;
name|to_read
operator|-=
name|nb
expr_stmt|;
block|}
do|while
condition|(
name|to_read
operator|>
literal|0
condition|)
do|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
block|}
comment|/* Using the magic number we can test whether it really is a message      catalog file.  */
if|if
condition|(
name|__builtin_expect
argument_list|(
name|data
operator|->
name|magic
operator|!=
name|_MAGIC
operator|&&
name|data
operator|->
name|magic
operator|!=
name|_MAGIC_SWAPPED
argument_list|,
literal|0
argument_list|)
condition|)
block|{
comment|/* The magic number is wrong: not a message catalog file.  */
ifdef|#
directive|ifdef
name|HAVE_MMAP
if|if
condition|(
name|use_mmap
condition|)
name|munmap
argument_list|(
operator|(
name|caddr_t
operator|)
name|data
argument_list|,
name|size
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
name|free
argument_list|(
name|data
argument_list|)
expr_stmt|;
return|return;
block|}
name|domain
operator|=
operator|(
expr|struct
name|loaded_domain
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|loaded_domain
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|domain
operator|==
name|NULL
condition|)
return|return;
name|domain_file
operator|->
name|data
operator|=
name|domain
expr_stmt|;
name|domain
operator|->
name|data
operator|=
operator|(
name|char
operator|*
operator|)
name|data
expr_stmt|;
name|domain
operator|->
name|use_mmap
operator|=
name|use_mmap
expr_stmt|;
name|domain
operator|->
name|mmap_size
operator|=
name|size
expr_stmt|;
name|domain
operator|->
name|must_swap
operator|=
name|data
operator|->
name|magic
operator|!=
name|_MAGIC
expr_stmt|;
name|domain
operator|->
name|malloced
operator|=
name|NULL
expr_stmt|;
comment|/* Fill in the information about the available tables.  */
name|revision
operator|=
name|W
argument_list|(
name|domain
operator|->
name|must_swap
argument_list|,
name|data
operator|->
name|revision
argument_list|)
expr_stmt|;
comment|/* We support only the major revision 0.  */
switch|switch
condition|(
name|revision
operator|>>
literal|16
condition|)
block|{
case|case
literal|0
case|:
name|domain
operator|->
name|nstrings
operator|=
name|W
argument_list|(
name|domain
operator|->
name|must_swap
argument_list|,
name|data
operator|->
name|nstrings
argument_list|)
expr_stmt|;
name|domain
operator|->
name|orig_tab
operator|=
operator|(
specifier|const
expr|struct
name|string_desc
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|data
operator|+
name|W
argument_list|(
name|domain
operator|->
name|must_swap
argument_list|,
name|data
operator|->
name|orig_tab_offset
argument_list|)
operator|)
expr_stmt|;
name|domain
operator|->
name|trans_tab
operator|=
operator|(
specifier|const
expr|struct
name|string_desc
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|data
operator|+
name|W
argument_list|(
name|domain
operator|->
name|must_swap
argument_list|,
name|data
operator|->
name|trans_tab_offset
argument_list|)
operator|)
expr_stmt|;
name|domain
operator|->
name|hash_size
operator|=
name|W
argument_list|(
name|domain
operator|->
name|must_swap
argument_list|,
name|data
operator|->
name|hash_tab_size
argument_list|)
expr_stmt|;
name|domain
operator|->
name|hash_tab
operator|=
operator|(
name|domain
operator|->
name|hash_size
operator|>
literal|2
condition|?
operator|(
specifier|const
name|nls_uint32
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|data
operator|+
name|W
argument_list|(
name|domain
operator|->
name|must_swap
argument_list|,
name|data
operator|->
name|hash_tab_offset
argument_list|)
operator|)
else|:
name|NULL
operator|)
expr_stmt|;
name|domain
operator|->
name|must_swap_hash_tab
operator|=
name|domain
operator|->
name|must_swap
expr_stmt|;
comment|/* Now dispatch on the minor revision.  */
switch|switch
condition|(
name|revision
operator|&
literal|0xffff
condition|)
block|{
case|case
literal|0
case|:
name|domain
operator|->
name|n_sysdep_strings
operator|=
literal|0
expr_stmt|;
name|domain
operator|->
name|orig_sysdep_tab
operator|=
name|NULL
expr_stmt|;
name|domain
operator|->
name|trans_sysdep_tab
operator|=
name|NULL
expr_stmt|;
break|break;
case|case
literal|1
case|:
default|default:
block|{
name|nls_uint32
name|n_sysdep_strings
decl_stmt|;
if|if
condition|(
name|domain
operator|->
name|hash_tab
operator|==
name|NULL
condition|)
comment|/* This is invalid.  These minor revisions need a hash table.  */
goto|goto
name|invalid
goto|;
name|n_sysdep_strings
operator|=
name|W
argument_list|(
name|domain
operator|->
name|must_swap
argument_list|,
name|data
operator|->
name|n_sysdep_strings
argument_list|)
expr_stmt|;
if|if
condition|(
name|n_sysdep_strings
operator|>
literal|0
condition|)
block|{
name|nls_uint32
name|n_sysdep_segments
decl_stmt|;
specifier|const
name|struct
name|sysdep_segment
modifier|*
name|sysdep_segments
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|sysdep_segment_values
decl_stmt|;
specifier|const
name|nls_uint32
modifier|*
name|orig_sysdep_tab
decl_stmt|;
specifier|const
name|nls_uint32
modifier|*
name|trans_sysdep_tab
decl_stmt|;
name|size_t
name|memneed
decl_stmt|;
name|char
modifier|*
name|mem
decl_stmt|;
name|struct
name|sysdep_string_desc
modifier|*
name|inmem_orig_sysdep_tab
decl_stmt|;
name|struct
name|sysdep_string_desc
modifier|*
name|inmem_trans_sysdep_tab
decl_stmt|;
name|nls_uint32
modifier|*
name|inmem_hash_tab
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
comment|/* Get the values of the system dependent segments.  */
name|n_sysdep_segments
operator|=
name|W
argument_list|(
name|domain
operator|->
name|must_swap
argument_list|,
name|data
operator|->
name|n_sysdep_segments
argument_list|)
expr_stmt|;
name|sysdep_segments
operator|=
operator|(
specifier|const
expr|struct
name|sysdep_segment
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|data
operator|+
name|W
argument_list|(
name|domain
operator|->
name|must_swap
argument_list|,
name|data
operator|->
name|sysdep_segments_offset
argument_list|)
operator|)
expr_stmt|;
name|sysdep_segment_values
operator|=
name|alloca
argument_list|(
name|n_sysdep_segments
operator|*
sizeof|sizeof
argument_list|(
specifier|const
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_sysdep_segments
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|char
modifier|*
name|name
init|=
operator|(
name|char
operator|*
operator|)
name|data
operator|+
name|W
argument_list|(
name|domain
operator|->
name|must_swap
argument_list|,
name|sysdep_segments
index|[
name|i
index|]
operator|.
name|offset
argument_list|)
decl_stmt|;
name|nls_uint32
name|namelen
init|=
name|W
argument_list|(
name|domain
operator|->
name|must_swap
argument_list|,
name|sysdep_segments
index|[
name|i
index|]
operator|.
name|length
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|namelen
operator|>
literal|0
operator|&&
name|name
index|[
name|namelen
operator|-
literal|1
index|]
operator|==
literal|'\0'
operator|)
condition|)
block|{
name|freea
argument_list|(
name|sysdep_segment_values
argument_list|)
expr_stmt|;
goto|goto
name|invalid
goto|;
block|}
name|sysdep_segment_values
index|[
name|i
index|]
operator|=
name|get_sysdep_segment_value
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
name|orig_sysdep_tab
operator|=
operator|(
specifier|const
name|nls_uint32
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|data
operator|+
name|W
argument_list|(
name|domain
operator|->
name|must_swap
argument_list|,
name|data
operator|->
name|orig_sysdep_tab_offset
argument_list|)
operator|)
expr_stmt|;
name|trans_sysdep_tab
operator|=
operator|(
specifier|const
name|nls_uint32
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|data
operator|+
name|W
argument_list|(
name|domain
operator|->
name|must_swap
argument_list|,
name|data
operator|->
name|trans_sysdep_tab_offset
argument_list|)
operator|)
expr_stmt|;
comment|/* Compute the amount of additional memory needed for the 		   system dependent strings and the augmented hash table.  */
name|memneed
operator|=
literal|2
operator|*
name|n_sysdep_strings
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|sysdep_string_desc
argument_list|)
operator|+
name|domain
operator|->
name|hash_size
operator|*
sizeof|sizeof
argument_list|(
name|nls_uint32
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|2
operator|*
name|n_sysdep_strings
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|struct
name|sysdep_string
modifier|*
name|sysdep_string
init|=
operator|(
specifier|const
expr|struct
name|sysdep_string
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|data
operator|+
name|W
argument_list|(
name|domain
operator|->
name|must_swap
argument_list|,
name|i
operator|<
name|n_sysdep_strings
condition|?
name|orig_sysdep_tab
index|[
name|i
index|]
else|:
name|trans_sysdep_tab
index|[
name|i
operator|-
name|n_sysdep_strings
index|]
argument_list|)
operator|)
decl_stmt|;
name|size_t
name|need
init|=
literal|0
decl_stmt|;
specifier|const
name|struct
name|segment_pair
modifier|*
name|p
init|=
name|sysdep_string
operator|->
name|segments
decl_stmt|;
if|if
condition|(
name|W
argument_list|(
name|domain
operator|->
name|must_swap
argument_list|,
name|p
operator|->
name|sysdepref
argument_list|)
operator|!=
name|SEGMENTS_END
condition|)
for|for
control|(
name|p
operator|=
name|sysdep_string
operator|->
name|segments
init|;
condition|;
name|p
operator|++
control|)
block|{
name|nls_uint32
name|sysdepref
decl_stmt|;
name|need
operator|+=
name|W
argument_list|(
name|domain
operator|->
name|must_swap
argument_list|,
name|p
operator|->
name|segsize
argument_list|)
expr_stmt|;
name|sysdepref
operator|=
name|W
argument_list|(
name|domain
operator|->
name|must_swap
argument_list|,
name|p
operator|->
name|sysdepref
argument_list|)
expr_stmt|;
if|if
condition|(
name|sysdepref
operator|==
name|SEGMENTS_END
condition|)
break|break;
if|if
condition|(
name|sysdepref
operator|>=
name|n_sysdep_segments
condition|)
block|{
comment|/* Invalid.  */
name|freea
argument_list|(
name|sysdep_segment_values
argument_list|)
expr_stmt|;
goto|goto
name|invalid
goto|;
block|}
name|need
operator|+=
name|strlen
argument_list|(
name|sysdep_segment_values
index|[
name|sysdepref
index|]
argument_list|)
expr_stmt|;
block|}
name|memneed
operator|+=
name|need
expr_stmt|;
block|}
comment|/* Allocate additional memory.  */
name|mem
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|memneed
argument_list|)
expr_stmt|;
if|if
condition|(
name|mem
operator|==
name|NULL
condition|)
goto|goto
name|invalid
goto|;
name|domain
operator|->
name|malloced
operator|=
name|mem
expr_stmt|;
name|inmem_orig_sysdep_tab
operator|=
operator|(
expr|struct
name|sysdep_string_desc
operator|*
operator|)
name|mem
expr_stmt|;
name|mem
operator|+=
name|n_sysdep_strings
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|sysdep_string_desc
argument_list|)
expr_stmt|;
name|inmem_trans_sysdep_tab
operator|=
operator|(
expr|struct
name|sysdep_string_desc
operator|*
operator|)
name|mem
expr_stmt|;
name|mem
operator|+=
name|n_sysdep_strings
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|sysdep_string_desc
argument_list|)
expr_stmt|;
name|inmem_hash_tab
operator|=
operator|(
name|nls_uint32
operator|*
operator|)
name|mem
expr_stmt|;
name|mem
operator|+=
name|domain
operator|->
name|hash_size
operator|*
sizeof|sizeof
argument_list|(
name|nls_uint32
argument_list|)
expr_stmt|;
comment|/* Compute the system dependent strings.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|2
operator|*
name|n_sysdep_strings
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|struct
name|sysdep_string
modifier|*
name|sysdep_string
init|=
operator|(
specifier|const
expr|struct
name|sysdep_string
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|data
operator|+
name|W
argument_list|(
name|domain
operator|->
name|must_swap
argument_list|,
name|i
operator|<
name|n_sysdep_strings
condition|?
name|orig_sysdep_tab
index|[
name|i
index|]
else|:
name|trans_sysdep_tab
index|[
name|i
operator|-
name|n_sysdep_strings
index|]
argument_list|)
operator|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|static_segments
init|=
operator|(
name|char
operator|*
operator|)
name|data
operator|+
name|W
argument_list|(
name|domain
operator|->
name|must_swap
argument_list|,
name|sysdep_string
operator|->
name|offset
argument_list|)
decl_stmt|;
specifier|const
name|struct
name|segment_pair
modifier|*
name|p
init|=
name|sysdep_string
operator|->
name|segments
decl_stmt|;
comment|/* Concatenate the segments, and fill 		       inmem_orig_sysdep_tab[i] (for i< n_sysdep_strings) and 		       inmem_trans_sysdep_tab[i-n_sysdep_strings] (for 		       i>= n_sysdep_strings).  */
if|if
condition|(
name|W
argument_list|(
name|domain
operator|->
name|must_swap
argument_list|,
name|p
operator|->
name|sysdepref
argument_list|)
operator|==
name|SEGMENTS_END
condition|)
block|{
comment|/* Only one static segment.  */
name|inmem_orig_sysdep_tab
index|[
name|i
index|]
operator|.
name|length
operator|=
name|W
argument_list|(
name|domain
operator|->
name|must_swap
argument_list|,
name|p
operator|->
name|segsize
argument_list|)
expr_stmt|;
name|inmem_orig_sysdep_tab
index|[
name|i
index|]
operator|.
name|pointer
operator|=
name|static_segments
expr_stmt|;
block|}
else|else
block|{
name|inmem_orig_sysdep_tab
index|[
name|i
index|]
operator|.
name|pointer
operator|=
name|mem
expr_stmt|;
for|for
control|(
name|p
operator|=
name|sysdep_string
operator|->
name|segments
init|;
condition|;
name|p
operator|++
control|)
block|{
name|nls_uint32
name|segsize
init|=
name|W
argument_list|(
name|domain
operator|->
name|must_swap
argument_list|,
name|p
operator|->
name|segsize
argument_list|)
decl_stmt|;
name|nls_uint32
name|sysdepref
init|=
name|W
argument_list|(
name|domain
operator|->
name|must_swap
argument_list|,
name|p
operator|->
name|sysdepref
argument_list|)
decl_stmt|;
name|size_t
name|n
decl_stmt|;
if|if
condition|(
name|segsize
operator|>
literal|0
condition|)
block|{
name|memcpy
argument_list|(
name|mem
argument_list|,
name|static_segments
argument_list|,
name|segsize
argument_list|)
expr_stmt|;
name|mem
operator|+=
name|segsize
expr_stmt|;
name|static_segments
operator|+=
name|segsize
expr_stmt|;
block|}
if|if
condition|(
name|sysdepref
operator|==
name|SEGMENTS_END
condition|)
break|break;
name|n
operator|=
name|strlen
argument_list|(
name|sysdep_segment_values
index|[
name|sysdepref
index|]
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|mem
argument_list|,
name|sysdep_segment_values
index|[
name|sysdepref
index|]
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|mem
operator|+=
name|n
expr_stmt|;
block|}
name|inmem_orig_sysdep_tab
index|[
name|i
index|]
operator|.
name|length
operator|=
name|mem
operator|-
name|inmem_orig_sysdep_tab
index|[
name|i
index|]
operator|.
name|pointer
expr_stmt|;
block|}
block|}
comment|/* Compute the augmented hash table.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|domain
operator|->
name|hash_size
condition|;
name|i
operator|++
control|)
name|inmem_hash_tab
index|[
name|i
index|]
operator|=
name|W
argument_list|(
name|domain
operator|->
name|must_swap_hash_tab
argument_list|,
name|domain
operator|->
name|hash_tab
index|[
name|i
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_sysdep_strings
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|char
modifier|*
name|msgid
init|=
name|inmem_orig_sysdep_tab
index|[
name|i
index|]
operator|.
name|pointer
decl_stmt|;
name|nls_uint32
name|hash_val
init|=
name|hash_string
argument_list|(
name|msgid
argument_list|)
decl_stmt|;
name|nls_uint32
name|idx
init|=
name|hash_val
operator|%
name|domain
operator|->
name|hash_size
decl_stmt|;
name|nls_uint32
name|incr
init|=
literal|1
operator|+
operator|(
name|hash_val
operator|%
operator|(
name|domain
operator|->
name|hash_size
operator|-
literal|2
operator|)
operator|)
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|inmem_hash_tab
index|[
name|idx
index|]
operator|==
literal|0
condition|)
block|{
comment|/* Hash table entry is empty.  Use it.  */
name|inmem_hash_tab
index|[
name|idx
index|]
operator|=
literal|1
operator|+
name|domain
operator|->
name|nstrings
operator|+
name|i
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|idx
operator|>=
name|domain
operator|->
name|hash_size
operator|-
name|incr
condition|)
name|idx
operator|-=
name|domain
operator|->
name|hash_size
operator|-
name|incr
expr_stmt|;
else|else
name|idx
operator|+=
name|incr
expr_stmt|;
block|}
block|}
name|freea
argument_list|(
name|sysdep_segment_values
argument_list|)
expr_stmt|;
name|domain
operator|->
name|n_sysdep_strings
operator|=
name|n_sysdep_strings
expr_stmt|;
name|domain
operator|->
name|orig_sysdep_tab
operator|=
name|inmem_orig_sysdep_tab
expr_stmt|;
name|domain
operator|->
name|trans_sysdep_tab
operator|=
name|inmem_trans_sysdep_tab
expr_stmt|;
name|domain
operator|->
name|hash_tab
operator|=
name|inmem_hash_tab
expr_stmt|;
name|domain
operator|->
name|must_swap_hash_tab
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|domain
operator|->
name|n_sysdep_strings
operator|=
literal|0
expr_stmt|;
name|domain
operator|->
name|orig_sysdep_tab
operator|=
name|NULL
expr_stmt|;
name|domain
operator|->
name|trans_sysdep_tab
operator|=
name|NULL
expr_stmt|;
block|}
block|}
break|break;
block|}
break|break;
default|default:
comment|/* This is an invalid revision.  */
name|invalid
label|:
comment|/* This is an invalid .mo file.  */
if|if
condition|(
name|domain
operator|->
name|malloced
condition|)
name|free
argument_list|(
name|domain
operator|->
name|malloced
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_MMAP
if|if
condition|(
name|use_mmap
condition|)
name|munmap
argument_list|(
operator|(
name|caddr_t
operator|)
name|data
argument_list|,
name|size
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
name|free
argument_list|(
name|data
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|domain
argument_list|)
expr_stmt|;
name|domain_file
operator|->
name|data
operator|=
name|NULL
expr_stmt|;
return|return;
block|}
comment|/* Now initialize the character set converter from the character set      the file is encoded with (found in the header entry) to the domain's      specified character set or the locale's character set.  */
name|nullentry
operator|=
name|_nl_init_domain_conv
argument_list|(
name|domain_file
argument_list|,
name|domain
argument_list|,
name|domainbinding
argument_list|)
expr_stmt|;
comment|/* Also look for a plural specification.  */
name|EXTRACT_PLURAL_EXPRESSION
argument_list|(
name|nullentry
argument_list|,
operator|&
name|domain
operator|->
name|plural
argument_list|,
operator|&
name|domain
operator|->
name|nplurals
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|_LIBC
end_ifdef

begin_function
name|void
name|internal_function
name|_nl_unload_domain
parameter_list|(
name|domain
parameter_list|)
name|struct
name|loaded_domain
modifier|*
name|domain
decl_stmt|;
block|{
if|if
condition|(
name|domain
operator|->
name|plural
operator|!=
operator|&
name|__gettext_germanic_plural
condition|)
name|__gettext_free_exp
argument_list|(
name|domain
operator|->
name|plural
argument_list|)
expr_stmt|;
name|_nl_free_domain_conv
argument_list|(
name|domain
argument_list|)
expr_stmt|;
if|if
condition|(
name|domain
operator|->
name|malloced
condition|)
name|free
argument_list|(
name|domain
operator|->
name|malloced
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|_POSIX_MAPPED_FILES
if|if
condition|(
name|domain
operator|->
name|use_mmap
condition|)
name|munmap
argument_list|(
operator|(
name|caddr_t
operator|)
name|domain
operator|->
name|data
argument_list|,
name|domain
operator|->
name|mmap_size
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
comment|/* _POSIX_MAPPED_FILES */
name|free
argument_list|(
operator|(
name|void
operator|*
operator|)
name|domain
operator|->
name|data
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|domain
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

