begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Plural expression evaluation.    Copyright (C) 2000-2002 Free Software Foundation, Inc.     This program is free software; you can redistribute it and/or modify it    under the terms of the GNU Library General Public License as published    by the Free Software Foundation; either version 2, or (at your option)    any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU    Library General Public License for more details.     You should have received a copy of the GNU Library General Public    License along with this program; if not, write to the Free Software    Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301,    USA.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|STATIC
end_ifndef

begin_define
define|#
directive|define
name|STATIC
value|static
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Evaluate the plural expression and return an index value.  */
end_comment

begin_decl_stmt
name|STATIC
name|unsigned
name|long
name|int
name|plural_eval
name|PARAMS
argument_list|(
operator|(
expr|struct
name|expression
operator|*
name|pexp
operator|,
name|unsigned
name|long
name|int
name|n
operator|)
argument_list|)
name|internal_function
decl_stmt|;
end_decl_stmt

begin_function
name|STATIC
name|unsigned
name|long
name|int
name|internal_function
name|plural_eval
parameter_list|(
name|pexp
parameter_list|,
name|n
parameter_list|)
name|struct
name|expression
modifier|*
name|pexp
decl_stmt|;
name|unsigned
name|long
name|int
name|n
decl_stmt|;
block|{
switch|switch
condition|(
name|pexp
operator|->
name|nargs
condition|)
block|{
case|case
literal|0
case|:
switch|switch
condition|(
name|pexp
operator|->
name|operation
condition|)
block|{
case|case
name|var
case|:
return|return
name|n
return|;
case|case
name|num
case|:
return|return
name|pexp
operator|->
name|val
operator|.
name|num
return|;
default|default:
break|break;
block|}
comment|/* NOTREACHED */
break|break;
case|case
literal|1
case|:
block|{
comment|/* pexp->operation must be lnot.  */
name|unsigned
name|long
name|int
name|arg
init|=
name|plural_eval
argument_list|(
name|pexp
operator|->
name|val
operator|.
name|args
index|[
literal|0
index|]
argument_list|,
name|n
argument_list|)
decl_stmt|;
return|return
operator|!
name|arg
return|;
block|}
case|case
literal|2
case|:
block|{
name|unsigned
name|long
name|int
name|leftarg
init|=
name|plural_eval
argument_list|(
name|pexp
operator|->
name|val
operator|.
name|args
index|[
literal|0
index|]
argument_list|,
name|n
argument_list|)
decl_stmt|;
if|if
condition|(
name|pexp
operator|->
name|operation
operator|==
name|lor
condition|)
return|return
name|leftarg
operator|||
name|plural_eval
argument_list|(
name|pexp
operator|->
name|val
operator|.
name|args
index|[
literal|1
index|]
argument_list|,
name|n
argument_list|)
return|;
elseif|else
if|if
condition|(
name|pexp
operator|->
name|operation
operator|==
name|land
condition|)
return|return
name|leftarg
operator|&&
name|plural_eval
argument_list|(
name|pexp
operator|->
name|val
operator|.
name|args
index|[
literal|1
index|]
argument_list|,
name|n
argument_list|)
return|;
else|else
block|{
name|unsigned
name|long
name|int
name|rightarg
init|=
name|plural_eval
argument_list|(
name|pexp
operator|->
name|val
operator|.
name|args
index|[
literal|1
index|]
argument_list|,
name|n
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|pexp
operator|->
name|operation
condition|)
block|{
case|case
name|mult
case|:
return|return
name|leftarg
operator|*
name|rightarg
return|;
case|case
name|divide
case|:
if|#
directive|if
operator|!
name|INTDIV0_RAISES_SIGFPE
if|if
condition|(
name|rightarg
operator|==
literal|0
condition|)
name|raise
argument_list|(
name|SIGFPE
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|leftarg
operator|/
name|rightarg
return|;
case|case
name|module
case|:
if|#
directive|if
operator|!
name|INTDIV0_RAISES_SIGFPE
if|if
condition|(
name|rightarg
operator|==
literal|0
condition|)
name|raise
argument_list|(
name|SIGFPE
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|leftarg
operator|%
name|rightarg
return|;
case|case
name|plus
case|:
return|return
name|leftarg
operator|+
name|rightarg
return|;
case|case
name|minus
case|:
return|return
name|leftarg
operator|-
name|rightarg
return|;
case|case
name|less_than
case|:
return|return
name|leftarg
operator|<
name|rightarg
return|;
case|case
name|greater_than
case|:
return|return
name|leftarg
operator|>
name|rightarg
return|;
case|case
name|less_or_equal
case|:
return|return
name|leftarg
operator|<=
name|rightarg
return|;
case|case
name|greater_or_equal
case|:
return|return
name|leftarg
operator|>=
name|rightarg
return|;
case|case
name|equal
case|:
return|return
name|leftarg
operator|==
name|rightarg
return|;
case|case
name|not_equal
case|:
return|return
name|leftarg
operator|!=
name|rightarg
return|;
default|default:
break|break;
block|}
block|}
comment|/* NOTREACHED */
break|break;
block|}
case|case
literal|3
case|:
block|{
comment|/* pexp->operation must be qmop.  */
name|unsigned
name|long
name|int
name|boolarg
init|=
name|plural_eval
argument_list|(
name|pexp
operator|->
name|val
operator|.
name|args
index|[
literal|0
index|]
argument_list|,
name|n
argument_list|)
decl_stmt|;
return|return
name|plural_eval
argument_list|(
name|pexp
operator|->
name|val
operator|.
name|args
index|[
name|boolarg
condition|?
literal|1
else|:
literal|2
index|]
argument_list|,
name|n
argument_list|)
return|;
block|}
block|}
comment|/* NOTREACHED */
return|return
literal|0
return|;
block|}
end_function

end_unit

