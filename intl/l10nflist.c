begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Copyright (C) 1995-1999, 2000, 2001, 2002 Free Software Foundation, Inc.    Contributed by Ulrich Drepper<drepper@gnu.ai.mit.edu>, 1995.     This program is free software; you can redistribute it and/or modify it    under the terms of the GNU Library General Public License as published    by the Free Software Foundation; either version 2, or (at your option)    any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU    Library General Public License for more details.     You should have received a copy of the GNU Library General Public    License along with this program; if not, write to the Free Software    Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301,    USA.  */
end_comment

begin_comment
comment|/* Tell glibc's<string.h> to provide a prototype for stpcpy().    This must come before<config.h> because<config.h> may include<features.h>, and once<features.h> has been included, it's too late.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|_GNU_SOURCE
end_ifndef

begin_define
define|#
directive|define
name|_GNU_SOURCE
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_CONFIG_H
end_ifdef

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_if
if|#
directive|if
name|defined
name|_LIBC
operator|||
name|defined
name|HAVE_ARGZ_H
end_if

begin_include
include|#
directive|include
file|<argz.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|"loadinfo.h"
end_include

begin_comment
comment|/* On some strange systems still no definition of NULL is found.  Sigh!  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|NULL
end_ifndef

begin_if
if|#
directive|if
name|defined
name|__STDC__
operator|&&
name|__STDC__
end_if

begin_define
define|#
directive|define
name|NULL
value|((void *) 0)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|NULL
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* @@ end of prolog @@ */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|_LIBC
end_ifdef

begin_comment
comment|/* Rename the non ANSI C functions.  This is required by the standard    because some ANSI C functions will require linking with this object    file and the name space must not be polluted.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|stpcpy
end_ifndef

begin_define
define|#
directive|define
name|stpcpy
parameter_list|(
name|dest
parameter_list|,
name|src
parameter_list|)
value|__stpcpy(dest, src)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_else
else|#
directive|else
end_else

begin_ifndef
ifndef|#
directive|ifndef
name|HAVE_STPCPY
end_ifndef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|stpcpy
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
name|dest
operator|,
specifier|const
name|char
operator|*
name|src
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Pathname support.    ISSLASH(C)           tests whether C is a directory separator character.    IS_ABSOLUTE_PATH(P)  tests whether P is an absolute path.  If it is not,                         it may be concatenated to a directory pathname.  */
end_comment

begin_if
if|#
directive|if
name|defined
name|_WIN32
operator|||
name|defined
name|__WIN32__
operator|||
name|defined
name|__EMX__
operator|||
name|defined
name|__DJGPP__
end_if

begin_comment
comment|/* Win32, OS/2, DOS */
end_comment

begin_define
define|#
directive|define
name|ISSLASH
parameter_list|(
name|C
parameter_list|)
value|((C) == '/' || (C) == '\\')
end_define

begin_define
define|#
directive|define
name|HAS_DEVICE
parameter_list|(
name|P
parameter_list|)
define|\
value|((((P)[0]>= 'A'&& (P)[0]<= 'Z') || ((P)[0]>= 'a'&& (P)[0]<= 'z')) \&& (P)[1] == ':')
end_define

begin_define
define|#
directive|define
name|IS_ABSOLUTE_PATH
parameter_list|(
name|P
parameter_list|)
value|(ISSLASH ((P)[0]) || HAS_DEVICE (P))
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* Unix */
end_comment

begin_define
define|#
directive|define
name|ISSLASH
parameter_list|(
name|C
parameter_list|)
value|((C) == '/')
end_define

begin_define
define|#
directive|define
name|IS_ABSOLUTE_PATH
parameter_list|(
name|P
parameter_list|)
value|ISSLASH ((P)[0])
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Define function which are usually not available.  */
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
name|_LIBC
operator|&&
operator|!
name|defined
name|HAVE___ARGZ_COUNT
end_if

begin_comment
comment|/* Returns the number of strings in ARGZ.  */
end_comment

begin_decl_stmt
specifier|static
name|size_t
name|argz_count__
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
name|argz
operator|,
name|size_t
name|len
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|size_t
name|argz_count__
parameter_list|(
name|argz
parameter_list|,
name|len
parameter_list|)
specifier|const
name|char
modifier|*
name|argz
decl_stmt|;
name|size_t
name|len
decl_stmt|;
block|{
name|size_t
name|count
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|len
operator|>
literal|0
condition|)
block|{
name|size_t
name|part_len
init|=
name|strlen
argument_list|(
name|argz
argument_list|)
decl_stmt|;
name|argz
operator|+=
name|part_len
operator|+
literal|1
expr_stmt|;
name|len
operator|-=
name|part_len
operator|+
literal|1
expr_stmt|;
name|count
operator|++
expr_stmt|;
block|}
return|return
name|count
return|;
block|}
end_function

begin_undef
undef|#
directive|undef
name|__argz_count
end_undef

begin_define
define|#
directive|define
name|__argz_count
parameter_list|(
name|argz
parameter_list|,
name|len
parameter_list|)
value|argz_count__ (argz, len)
end_define

begin_else
else|#
directive|else
end_else

begin_ifdef
ifdef|#
directive|ifdef
name|_LIBC
end_ifdef

begin_define
define|#
directive|define
name|__argz_count
parameter_list|(
name|argz
parameter_list|,
name|len
parameter_list|)
value|INTUSE(__argz_count) (argz, len)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !_LIBC&& !HAVE___ARGZ_COUNT */
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
name|_LIBC
operator|&&
operator|!
name|defined
name|HAVE___ARGZ_STRINGIFY
end_if

begin_comment
comment|/* Make '\0' separated arg vector ARGZ printable by converting all the '\0's    except the last into the character SEP.  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|argz_stringify__
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
name|argz
operator|,
name|size_t
name|len
operator|,
name|int
name|sep
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|argz_stringify__
parameter_list|(
name|argz
parameter_list|,
name|len
parameter_list|,
name|sep
parameter_list|)
name|char
modifier|*
name|argz
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|int
name|sep
decl_stmt|;
block|{
while|while
condition|(
name|len
operator|>
literal|0
condition|)
block|{
name|size_t
name|part_len
init|=
name|strlen
argument_list|(
name|argz
argument_list|)
decl_stmt|;
name|argz
operator|+=
name|part_len
expr_stmt|;
name|len
operator|-=
name|part_len
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|len
operator|>
literal|0
condition|)
operator|*
name|argz
operator|++
operator|=
name|sep
expr_stmt|;
block|}
block|}
end_function

begin_undef
undef|#
directive|undef
name|__argz_stringify
end_undef

begin_define
define|#
directive|define
name|__argz_stringify
parameter_list|(
name|argz
parameter_list|,
name|len
parameter_list|,
name|sep
parameter_list|)
value|argz_stringify__ (argz, len, sep)
end_define

begin_else
else|#
directive|else
end_else

begin_ifdef
ifdef|#
directive|ifdef
name|_LIBC
end_ifdef

begin_define
define|#
directive|define
name|__argz_stringify
parameter_list|(
name|argz
parameter_list|,
name|len
parameter_list|,
name|sep
parameter_list|)
define|\
value|INTUSE(__argz_stringify) (argz, len, sep)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !_LIBC&& !HAVE___ARGZ_STRINGIFY */
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
name|_LIBC
operator|&&
operator|!
name|defined
name|HAVE___ARGZ_NEXT
end_if

begin_decl_stmt
specifier|static
name|char
modifier|*
name|argz_next__
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
name|argz
operator|,
name|size_t
name|argz_len
operator|,
specifier|const
name|char
operator|*
name|entry
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|char
modifier|*
name|argz_next__
parameter_list|(
name|argz
parameter_list|,
name|argz_len
parameter_list|,
name|entry
parameter_list|)
name|char
modifier|*
name|argz
decl_stmt|;
name|size_t
name|argz_len
decl_stmt|;
specifier|const
name|char
modifier|*
name|entry
decl_stmt|;
block|{
if|if
condition|(
name|entry
condition|)
block|{
if|if
condition|(
name|entry
operator|<
name|argz
operator|+
name|argz_len
condition|)
name|entry
operator|=
name|strchr
argument_list|(
name|entry
argument_list|,
literal|'\0'
argument_list|)
operator|+
literal|1
expr_stmt|;
return|return
name|entry
operator|>=
name|argz
operator|+
name|argz_len
condition|?
name|NULL
else|:
operator|(
name|char
operator|*
operator|)
name|entry
return|;
block|}
elseif|else
if|if
condition|(
name|argz_len
operator|>
literal|0
condition|)
return|return
name|argz
return|;
else|else
return|return
literal|0
return|;
block|}
end_function

begin_undef
undef|#
directive|undef
name|__argz_next
end_undef

begin_define
define|#
directive|define
name|__argz_next
parameter_list|(
name|argz
parameter_list|,
name|len
parameter_list|,
name|entry
parameter_list|)
value|argz_next__ (argz, len, entry)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !_LIBC&& !HAVE___ARGZ_NEXT */
end_comment

begin_comment
comment|/* Return number of bits set in X.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|pop
name|PARAMS
argument_list|(
operator|(
name|int
name|x
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
specifier|inline
name|int
name|pop
parameter_list|(
name|x
parameter_list|)
name|int
name|x
decl_stmt|;
block|{
comment|/* We assume that no more than 16 bits are used.  */
name|x
operator|=
operator|(
operator|(
name|x
operator|&
operator|~
literal|0x5555
operator|)
operator|>>
literal|1
operator|)
operator|+
operator|(
name|x
operator|&
literal|0x5555
operator|)
expr_stmt|;
name|x
operator|=
operator|(
operator|(
name|x
operator|&
operator|~
literal|0x3333
operator|)
operator|>>
literal|2
operator|)
operator|+
operator|(
name|x
operator|&
literal|0x3333
operator|)
expr_stmt|;
name|x
operator|=
operator|(
operator|(
name|x
operator|>>
literal|4
operator|)
operator|+
name|x
operator|)
operator|&
literal|0x0f0f
expr_stmt|;
name|x
operator|=
operator|(
operator|(
name|x
operator|>>
literal|8
operator|)
operator|+
name|x
operator|)
operator|&
literal|0xff
expr_stmt|;
return|return
name|x
return|;
block|}
end_function

begin_escape
end_escape

begin_function
name|struct
name|loaded_l10nfile
modifier|*
name|_nl_make_l10nflist
parameter_list|(
name|l10nfile_list
parameter_list|,
name|dirlist
parameter_list|,
name|dirlist_len
parameter_list|,
name|mask
parameter_list|,
name|language
parameter_list|,
name|territory
parameter_list|,
name|codeset
parameter_list|,
name|normalized_codeset
parameter_list|,
name|modifier
parameter_list|,
name|special
parameter_list|,
name|sponsor
parameter_list|,
name|revision
parameter_list|,
name|filename
parameter_list|,
name|do_allocate
parameter_list|)
name|struct
name|loaded_l10nfile
modifier|*
modifier|*
name|l10nfile_list
decl_stmt|;
specifier|const
name|char
modifier|*
name|dirlist
decl_stmt|;
name|size_t
name|dirlist_len
decl_stmt|;
name|int
name|mask
decl_stmt|;
specifier|const
name|char
modifier|*
name|language
decl_stmt|;
specifier|const
name|char
modifier|*
name|territory
decl_stmt|;
specifier|const
name|char
modifier|*
name|codeset
decl_stmt|;
specifier|const
name|char
modifier|*
name|normalized_codeset
decl_stmt|;
specifier|const
name|char
modifier|*
name|modifier
decl_stmt|;
specifier|const
name|char
modifier|*
name|special
decl_stmt|;
specifier|const
name|char
modifier|*
name|sponsor
decl_stmt|;
specifier|const
name|char
modifier|*
name|revision
decl_stmt|;
specifier|const
name|char
modifier|*
name|filename
decl_stmt|;
name|int
name|do_allocate
decl_stmt|;
block|{
name|char
modifier|*
name|abs_filename
decl_stmt|;
name|struct
name|loaded_l10nfile
modifier|*
modifier|*
name|lastp
decl_stmt|;
name|struct
name|loaded_l10nfile
modifier|*
name|retval
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
name|size_t
name|dirlist_count
decl_stmt|;
name|size_t
name|entries
decl_stmt|;
name|int
name|cnt
decl_stmt|;
comment|/* If LANGUAGE contains an absolute directory specification, we ignore      DIRLIST.  */
if|if
condition|(
name|IS_ABSOLUTE_PATH
argument_list|(
name|language
argument_list|)
condition|)
name|dirlist_len
operator|=
literal|0
expr_stmt|;
comment|/* Allocate room for the full file name.  */
name|abs_filename
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|dirlist_len
operator|+
name|strlen
argument_list|(
name|language
argument_list|)
operator|+
operator|(
operator|(
name|mask
operator|&
name|TERRITORY
operator|)
operator|!=
literal|0
condition|?
name|strlen
argument_list|(
name|territory
argument_list|)
operator|+
literal|1
else|:
literal|0
operator|)
operator|+
operator|(
operator|(
name|mask
operator|&
name|XPG_CODESET
operator|)
operator|!=
literal|0
condition|?
name|strlen
argument_list|(
name|codeset
argument_list|)
operator|+
literal|1
else|:
literal|0
operator|)
operator|+
operator|(
operator|(
name|mask
operator|&
name|XPG_NORM_CODESET
operator|)
operator|!=
literal|0
condition|?
name|strlen
argument_list|(
name|normalized_codeset
argument_list|)
operator|+
literal|1
else|:
literal|0
operator|)
operator|+
operator|(
operator|(
operator|(
name|mask
operator|&
name|XPG_MODIFIER
operator|)
operator|!=
literal|0
operator|||
operator|(
name|mask
operator|&
name|CEN_AUDIENCE
operator|)
operator|!=
literal|0
operator|)
condition|?
name|strlen
argument_list|(
name|modifier
argument_list|)
operator|+
literal|1
else|:
literal|0
operator|)
operator|+
operator|(
operator|(
name|mask
operator|&
name|CEN_SPECIAL
operator|)
operator|!=
literal|0
condition|?
name|strlen
argument_list|(
name|special
argument_list|)
operator|+
literal|1
else|:
literal|0
operator|)
operator|+
operator|(
operator|(
operator|(
name|mask
operator|&
name|CEN_SPONSOR
operator|)
operator|!=
literal|0
operator|||
operator|(
name|mask
operator|&
name|CEN_REVISION
operator|)
operator|!=
literal|0
operator|)
condition|?
operator|(
literal|1
operator|+
operator|(
operator|(
name|mask
operator|&
name|CEN_SPONSOR
operator|)
operator|!=
literal|0
condition|?
name|strlen
argument_list|(
name|sponsor
argument_list|)
else|:
literal|0
operator|)
operator|+
operator|(
operator|(
name|mask
operator|&
name|CEN_REVISION
operator|)
operator|!=
literal|0
condition|?
name|strlen
argument_list|(
name|revision
argument_list|)
operator|+
literal|1
else|:
literal|0
operator|)
operator|)
else|:
literal|0
operator|)
operator|+
literal|1
operator|+
name|strlen
argument_list|(
name|filename
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|abs_filename
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
comment|/* Construct file name.  */
name|cp
operator|=
name|abs_filename
expr_stmt|;
if|if
condition|(
name|dirlist_len
operator|>
literal|0
condition|)
block|{
name|memcpy
argument_list|(
name|cp
argument_list|,
name|dirlist
argument_list|,
name|dirlist_len
argument_list|)
expr_stmt|;
name|__argz_stringify
argument_list|(
name|cp
argument_list|,
name|dirlist_len
argument_list|,
name|PATH_SEPARATOR
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|dirlist_len
expr_stmt|;
name|cp
index|[
operator|-
literal|1
index|]
operator|=
literal|'/'
expr_stmt|;
block|}
name|cp
operator|=
name|stpcpy
argument_list|(
name|cp
argument_list|,
name|language
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|mask
operator|&
name|TERRITORY
operator|)
operator|!=
literal|0
condition|)
block|{
operator|*
name|cp
operator|++
operator|=
literal|'_'
expr_stmt|;
name|cp
operator|=
name|stpcpy
argument_list|(
name|cp
argument_list|,
name|territory
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|mask
operator|&
name|XPG_CODESET
operator|)
operator|!=
literal|0
condition|)
block|{
operator|*
name|cp
operator|++
operator|=
literal|'.'
expr_stmt|;
name|cp
operator|=
name|stpcpy
argument_list|(
name|cp
argument_list|,
name|codeset
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|mask
operator|&
name|XPG_NORM_CODESET
operator|)
operator|!=
literal|0
condition|)
block|{
operator|*
name|cp
operator|++
operator|=
literal|'.'
expr_stmt|;
name|cp
operator|=
name|stpcpy
argument_list|(
name|cp
argument_list|,
name|normalized_codeset
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|mask
operator|&
operator|(
name|XPG_MODIFIER
operator||
name|CEN_AUDIENCE
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* This component can be part of both syntaces but has different 	 leading characters.  For CEN we use `+', else `@'.  */
operator|*
name|cp
operator|++
operator|=
operator|(
name|mask
operator|&
name|CEN_AUDIENCE
operator|)
operator|!=
literal|0
condition|?
literal|'+'
else|:
literal|'@'
expr_stmt|;
name|cp
operator|=
name|stpcpy
argument_list|(
name|cp
argument_list|,
name|modifier
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|mask
operator|&
name|CEN_SPECIAL
operator|)
operator|!=
literal|0
condition|)
block|{
operator|*
name|cp
operator|++
operator|=
literal|'+'
expr_stmt|;
name|cp
operator|=
name|stpcpy
argument_list|(
name|cp
argument_list|,
name|special
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|mask
operator|&
operator|(
name|CEN_SPONSOR
operator||
name|CEN_REVISION
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
operator|*
name|cp
operator|++
operator|=
literal|','
expr_stmt|;
if|if
condition|(
operator|(
name|mask
operator|&
name|CEN_SPONSOR
operator|)
operator|!=
literal|0
condition|)
name|cp
operator|=
name|stpcpy
argument_list|(
name|cp
argument_list|,
name|sponsor
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|mask
operator|&
name|CEN_REVISION
operator|)
operator|!=
literal|0
condition|)
block|{
operator|*
name|cp
operator|++
operator|=
literal|'_'
expr_stmt|;
name|cp
operator|=
name|stpcpy
argument_list|(
name|cp
argument_list|,
name|revision
argument_list|)
expr_stmt|;
block|}
block|}
operator|*
name|cp
operator|++
operator|=
literal|'/'
expr_stmt|;
name|stpcpy
argument_list|(
name|cp
argument_list|,
name|filename
argument_list|)
expr_stmt|;
comment|/* Look in list of already loaded domains whether it is already      available.  */
name|lastp
operator|=
name|l10nfile_list
expr_stmt|;
for|for
control|(
name|retval
operator|=
operator|*
name|l10nfile_list
init|;
name|retval
operator|!=
name|NULL
condition|;
name|retval
operator|=
name|retval
operator|->
name|next
control|)
if|if
condition|(
name|retval
operator|->
name|filename
operator|!=
name|NULL
condition|)
block|{
name|int
name|compare
init|=
name|strcmp
argument_list|(
name|retval
operator|->
name|filename
argument_list|,
name|abs_filename
argument_list|)
decl_stmt|;
if|if
condition|(
name|compare
operator|==
literal|0
condition|)
comment|/* We found it!  */
break|break;
if|if
condition|(
name|compare
operator|<
literal|0
condition|)
block|{
comment|/* It's not in the list.  */
name|retval
operator|=
name|NULL
expr_stmt|;
break|break;
block|}
name|lastp
operator|=
operator|&
name|retval
operator|->
name|next
expr_stmt|;
block|}
if|if
condition|(
name|retval
operator|!=
name|NULL
operator|||
name|do_allocate
operator|==
literal|0
condition|)
block|{
name|free
argument_list|(
name|abs_filename
argument_list|)
expr_stmt|;
return|return
name|retval
return|;
block|}
name|dirlist_count
operator|=
operator|(
name|dirlist_len
operator|>
literal|0
condition|?
name|__argz_count
argument_list|(
name|dirlist
argument_list|,
name|dirlist_len
argument_list|)
else|:
literal|1
operator|)
expr_stmt|;
comment|/* Allocate a new loaded_l10nfile.  */
name|retval
operator|=
operator|(
expr|struct
name|loaded_l10nfile
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|retval
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|dirlist_count
operator|<<
name|pop
argument_list|(
name|mask
argument_list|)
operator|)
operator|+
operator|(
name|dirlist_count
operator|>
literal|1
condition|?
literal|1
else|:
literal|0
operator|)
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|loaded_l10nfile
operator|*
argument_list|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|retval
operator|->
name|filename
operator|=
name|abs_filename
expr_stmt|;
comment|/* We set retval->data to NULL here; it is filled in later.      Setting retval->decided to 1 here means that retval does not      correspond to a real file (dirlist_count> 1) or is not worth      looking up (if an unnormalized codeset was specified).  */
name|retval
operator|->
name|decided
operator|=
operator|(
name|dirlist_count
operator|>
literal|1
operator|||
operator|(
operator|(
name|mask
operator|&
name|XPG_CODESET
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|mask
operator|&
name|XPG_NORM_CODESET
operator|)
operator|!=
literal|0
operator|)
operator|)
expr_stmt|;
name|retval
operator|->
name|data
operator|=
name|NULL
expr_stmt|;
name|retval
operator|->
name|next
operator|=
operator|*
name|lastp
expr_stmt|;
operator|*
name|lastp
operator|=
name|retval
expr_stmt|;
name|entries
operator|=
literal|0
expr_stmt|;
comment|/* Recurse to fill the inheritance list of RETVAL.      If the DIRLIST is a real list (i.e. DIRLIST_COUNT> 1), the RETVAL      entry does not correspond to a real file; retval->filename contains      colons.  In this case we loop across all elements of DIRLIST and      across all bit patterns dominated by MASK.      If the DIRLIST is a single directory or entirely redundant (i.e.      DIRLIST_COUNT == 1), we loop across all bit patterns dominated by      MASK, excluding MASK itself.      In either case, we loop down from MASK to 0.  This has the effect      that the extra bits in the locale name are dropped in this order:      first the modifier, then the territory, then the codeset, then the      normalized_codeset.  */
for|for
control|(
name|cnt
operator|=
name|dirlist_count
operator|>
literal|1
condition|?
name|mask
else|:
name|mask
operator|-
literal|1
init|;
name|cnt
operator|>=
literal|0
condition|;
operator|--
name|cnt
control|)
if|if
condition|(
operator|(
name|cnt
operator|&
operator|~
name|mask
operator|)
operator|==
literal|0
operator|&&
operator|(
operator|(
name|cnt
operator|&
name|CEN_SPECIFIC
operator|)
operator|==
literal|0
operator|||
operator|(
name|cnt
operator|&
name|XPG_SPECIFIC
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|(
operator|(
name|cnt
operator|&
name|XPG_CODESET
operator|)
operator|==
literal|0
operator|||
operator|(
name|cnt
operator|&
name|XPG_NORM_CODESET
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|dirlist_count
operator|>
literal|1
condition|)
block|{
comment|/* Iterate over all elements of the DIRLIST.  */
name|char
modifier|*
name|dir
init|=
name|NULL
decl_stmt|;
while|while
condition|(
operator|(
name|dir
operator|=
name|__argz_next
argument_list|(
operator|(
name|char
operator|*
operator|)
name|dirlist
argument_list|,
name|dirlist_len
argument_list|,
name|dir
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|retval
operator|->
name|successor
index|[
name|entries
operator|++
index|]
operator|=
name|_nl_make_l10nflist
argument_list|(
name|l10nfile_list
argument_list|,
name|dir
argument_list|,
name|strlen
argument_list|(
name|dir
argument_list|)
operator|+
literal|1
argument_list|,
name|cnt
argument_list|,
name|language
argument_list|,
name|territory
argument_list|,
name|codeset
argument_list|,
name|normalized_codeset
argument_list|,
name|modifier
argument_list|,
name|special
argument_list|,
name|sponsor
argument_list|,
name|revision
argument_list|,
name|filename
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
name|retval
operator|->
name|successor
index|[
name|entries
operator|++
index|]
operator|=
name|_nl_make_l10nflist
argument_list|(
name|l10nfile_list
argument_list|,
name|dirlist
argument_list|,
name|dirlist_len
argument_list|,
name|cnt
argument_list|,
name|language
argument_list|,
name|territory
argument_list|,
name|codeset
argument_list|,
name|normalized_codeset
argument_list|,
name|modifier
argument_list|,
name|special
argument_list|,
name|sponsor
argument_list|,
name|revision
argument_list|,
name|filename
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|retval
operator|->
name|successor
index|[
name|entries
index|]
operator|=
name|NULL
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Normalize codeset name.  There is no standard for the codeset    names.  Normalization allows the user to use any of the common    names.  The return value is dynamically allocated and has to be    freed by the caller.  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|_nl_normalize_codeset
parameter_list|(
name|codeset
parameter_list|,
name|name_len
parameter_list|)
specifier|const
name|char
modifier|*
name|codeset
decl_stmt|;
name|size_t
name|name_len
decl_stmt|;
block|{
name|int
name|len
init|=
literal|0
decl_stmt|;
name|int
name|only_digit
init|=
literal|1
decl_stmt|;
name|char
modifier|*
name|retval
decl_stmt|;
name|char
modifier|*
name|wp
decl_stmt|;
name|size_t
name|cnt
decl_stmt|;
for|for
control|(
name|cnt
operator|=
literal|0
init|;
name|cnt
operator|<
name|name_len
condition|;
operator|++
name|cnt
control|)
if|if
condition|(
name|isalnum
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|codeset
index|[
name|cnt
index|]
argument_list|)
condition|)
block|{
operator|++
name|len
expr_stmt|;
if|if
condition|(
name|isalpha
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|codeset
index|[
name|cnt
index|]
argument_list|)
condition|)
name|only_digit
operator|=
literal|0
expr_stmt|;
block|}
name|retval
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
operator|(
name|only_digit
condition|?
literal|3
else|:
literal|0
operator|)
operator|+
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|only_digit
condition|)
name|wp
operator|=
name|stpcpy
argument_list|(
name|retval
argument_list|,
literal|"iso"
argument_list|)
expr_stmt|;
else|else
name|wp
operator|=
name|retval
expr_stmt|;
for|for
control|(
name|cnt
operator|=
literal|0
init|;
name|cnt
operator|<
name|name_len
condition|;
operator|++
name|cnt
control|)
if|if
condition|(
name|isalpha
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|codeset
index|[
name|cnt
index|]
argument_list|)
condition|)
operator|*
name|wp
operator|++
operator|=
name|tolower
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|codeset
index|[
name|cnt
index|]
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|isdigit
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|codeset
index|[
name|cnt
index|]
argument_list|)
condition|)
operator|*
name|wp
operator|++
operator|=
name|codeset
index|[
name|cnt
index|]
expr_stmt|;
operator|*
name|wp
operator|=
literal|'\0'
expr_stmt|;
block|}
return|return
operator|(
specifier|const
name|char
operator|*
operator|)
name|retval
return|;
block|}
end_function

begin_comment
comment|/* @@ begin of epilog @@ */
end_comment

begin_comment
comment|/* We don't want libintl.a to depend on any other library.  So we    avoid the non-standard function stpcpy.  In GNU C Library this    function is available, though.  Also allow the symbol HAVE_STPCPY    to be defined.  */
end_comment

begin_if
if|#
directive|if
operator|!
name|_LIBC
operator|&&
operator|!
name|HAVE_STPCPY
end_if

begin_function
specifier|static
name|char
modifier|*
name|stpcpy
parameter_list|(
name|dest
parameter_list|,
name|src
parameter_list|)
name|char
modifier|*
name|dest
decl_stmt|;
specifier|const
name|char
modifier|*
name|src
decl_stmt|;
block|{
while|while
condition|(
operator|(
operator|*
name|dest
operator|++
operator|=
operator|*
name|src
operator|++
operator|)
operator|!=
literal|'\0'
condition|)
comment|/* Do nothing. */
empty_stmt|;
return|return
name|dest
operator|-
literal|1
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

