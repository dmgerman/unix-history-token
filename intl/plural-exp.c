begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Expression parsing for plural form selection.    Copyright (C) 2000, 2001 Free Software Foundation, Inc.    Written by Ulrich Drepper<drepper@cygnus.com>, 2000.     This program is free software; you can redistribute it and/or modify it    under the terms of the GNU Library General Public License as published    by the Free Software Foundation; either version 2, or (at your option)    any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU    Library General Public License for more details.     You should have received a copy of the GNU Library General Public    License along with this program; if not, write to the Free Software    Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301,    USA.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_CONFIG_H
end_ifdef

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|"plural-exp.h"
end_include

begin_if
if|#
directive|if
operator|(
name|defined
name|__GNUC__
operator|&&
operator|!
name|defined
name|__APPLE_CC__
operator|)
expr|\
operator|||
operator|(
name|defined
name|__STDC_VERSION__
operator|&&
name|__STDC_VERSION__
operator|>=
literal|199901L
operator|)
end_if

begin_comment
comment|/* These structs are the constant expression for the germanic plural    form determination.  It represents the expression  "n != 1".  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|expression
name|plvar
init|=
block|{
operator|.
name|nargs
operator|=
literal|0
block|,
operator|.
name|operation
operator|=
name|var
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|expression
name|plone
init|=
block|{
operator|.
name|nargs
operator|=
literal|0
block|,
operator|.
name|operation
operator|=
name|num
block|,
operator|.
name|val
operator|=
block|{
operator|.
name|num
operator|=
literal|1
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|expression
name|GERMANIC_PLURAL
init|=
block|{
operator|.
name|nargs
operator|=
literal|2
block|,
operator|.
name|operation
operator|=
name|not_equal
block|,
operator|.
name|val
operator|=
block|{
operator|.
name|args
operator|=
block|{
index|[
literal|0
index|]
operator|=
operator|(
expr|struct
name|expression
operator|*
operator|)
operator|&
name|plvar
block|,
index|[
literal|1
index|]
operator|=
operator|(
expr|struct
name|expression
operator|*
operator|)
operator|&
name|plone
block|}
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|INIT_GERMANIC_PLURAL
parameter_list|()
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* For compilers without support for ISO C 99 struct/union initializers:    Initialization at run-time.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|expression
name|plvar
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|expression
name|plone
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|expression
name|GERMANIC_PLURAL
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|init_germanic_plural
parameter_list|()
block|{
if|if
condition|(
name|plone
operator|.
name|val
operator|.
name|num
operator|==
literal|0
condition|)
block|{
name|plvar
operator|.
name|nargs
operator|=
literal|0
expr_stmt|;
name|plvar
operator|.
name|operation
operator|=
name|var
expr_stmt|;
name|plone
operator|.
name|nargs
operator|=
literal|0
expr_stmt|;
name|plone
operator|.
name|operation
operator|=
name|num
expr_stmt|;
name|plone
operator|.
name|val
operator|.
name|num
operator|=
literal|1
expr_stmt|;
name|GERMANIC_PLURAL
operator|.
name|nargs
operator|=
literal|2
expr_stmt|;
name|GERMANIC_PLURAL
operator|.
name|operation
operator|=
name|not_equal
expr_stmt|;
name|GERMANIC_PLURAL
operator|.
name|val
operator|.
name|args
index|[
literal|0
index|]
operator|=
operator|&
name|plvar
expr_stmt|;
name|GERMANIC_PLURAL
operator|.
name|val
operator|.
name|args
index|[
literal|1
index|]
operator|=
operator|&
name|plone
expr_stmt|;
block|}
block|}
end_function

begin_define
define|#
directive|define
name|INIT_GERMANIC_PLURAL
parameter_list|()
value|init_germanic_plural ()
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|void
name|internal_function
name|EXTRACT_PLURAL_EXPRESSION
parameter_list|(
name|nullentry
parameter_list|,
name|pluralp
parameter_list|,
name|npluralsp
parameter_list|)
specifier|const
name|char
modifier|*
name|nullentry
decl_stmt|;
name|struct
name|expression
modifier|*
modifier|*
name|pluralp
decl_stmt|;
name|unsigned
name|long
name|int
modifier|*
name|npluralsp
decl_stmt|;
block|{
if|if
condition|(
name|nullentry
operator|!=
name|NULL
condition|)
block|{
specifier|const
name|char
modifier|*
name|plural
decl_stmt|;
specifier|const
name|char
modifier|*
name|nplurals
decl_stmt|;
name|plural
operator|=
name|strstr
argument_list|(
name|nullentry
argument_list|,
literal|"plural="
argument_list|)
expr_stmt|;
name|nplurals
operator|=
name|strstr
argument_list|(
name|nullentry
argument_list|,
literal|"nplurals="
argument_list|)
expr_stmt|;
if|if
condition|(
name|plural
operator|==
name|NULL
operator|||
name|nplurals
operator|==
name|NULL
condition|)
goto|goto
name|no_plural
goto|;
else|else
block|{
name|char
modifier|*
name|endp
decl_stmt|;
name|unsigned
name|long
name|int
name|n
decl_stmt|;
name|struct
name|parse_args
name|args
decl_stmt|;
comment|/* First get the number.  */
name|nplurals
operator|+=
literal|9
expr_stmt|;
while|while
condition|(
operator|*
name|nplurals
operator|!=
literal|'\0'
operator|&&
name|isspace
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|nplurals
argument_list|)
condition|)
operator|++
name|nplurals
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|*
name|nplurals
operator|>=
literal|'0'
operator|&&
operator|*
name|nplurals
operator|<=
literal|'9'
operator|)
condition|)
goto|goto
name|no_plural
goto|;
if|#
directive|if
name|defined
name|HAVE_STRTOUL
operator|||
name|defined
name|_LIBC
name|n
operator|=
name|strtoul
argument_list|(
name|nplurals
argument_list|,
operator|&
name|endp
argument_list|,
literal|10
argument_list|)
expr_stmt|;
else|#
directive|else
for|for
control|(
name|endp
operator|=
name|nplurals
operator|,
name|n
operator|=
literal|0
init|;
operator|*
name|endp
operator|>=
literal|'0'
operator|&&
operator|*
name|endp
operator|<=
literal|'9'
condition|;
name|endp
operator|++
control|)
name|n
operator|=
name|n
operator|*
literal|10
operator|+
operator|(
operator|*
name|endp
operator|-
literal|'0'
operator|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|nplurals
operator|==
name|endp
condition|)
goto|goto
name|no_plural
goto|;
operator|*
name|npluralsp
operator|=
name|n
expr_stmt|;
comment|/* Due to the restrictions bison imposes onto the interface of the 	     scanner function we have to put the input string and the result 	     passed up from the parser into the same structure which address 	     is passed down to the parser.  */
name|plural
operator|+=
literal|7
expr_stmt|;
name|args
operator|.
name|cp
operator|=
name|plural
expr_stmt|;
if|if
condition|(
name|PLURAL_PARSE
argument_list|(
operator|&
name|args
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|no_plural
goto|;
operator|*
name|pluralp
operator|=
name|args
operator|.
name|res
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* By default we are using the Germanic form: singular form only          for `one', the plural form otherwise.  Yes, this is also what          English is using since English is a Germanic language.  */
name|no_plural
label|:
name|INIT_GERMANIC_PLURAL
argument_list|()
expr_stmt|;
operator|*
name|pluralp
operator|=
operator|&
name|GERMANIC_PLURAL
expr_stmt|;
operator|*
name|npluralsp
operator|=
literal|2
expr_stmt|;
block|}
block|}
end_function

end_unit

