begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2000-2002, 2006 Sendmail, Inc. and its suppliers.  *      All rights reserved.  * Copyright (c) 1990, 1993  *	The Regents of the University of California.  All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * Chris Torek.  *  * By using this file, you agree to the terms and conditions set  * forth in the LICENSE file which can be found at the top level of  * the sendmail distribution.  */
end_comment

begin_include
include|#
directive|include
file|<sm/gen.h>
end_include

begin_macro
name|SM_RCSID
argument_list|(
literal|"@(#)$Id: findfp.c,v 1.67 2006/08/28 21:24:46 ca Exp $"
argument_list|)
end_macro

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<syslog.h>
end_include

begin_include
include|#
directive|include
file|<sm/io.h>
end_include

begin_include
include|#
directive|include
file|<sm/assert.h>
end_include

begin_include
include|#
directive|include
file|<sm/heap.h>
end_include

begin_include
include|#
directive|include
file|<sm/string.h>
end_include

begin_include
include|#
directive|include
file|<sm/conf.h>
end_include

begin_include
include|#
directive|include
file|"local.h"
end_include

begin_include
include|#
directive|include
file|"glue.h"
end_include

begin_decl_stmt
name|bool
name|Sm_IO_DidInit
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* IO system has been initialized? */
end_comment

begin_decl_stmt
specifier|const
name|char
name|SmFileMagic
index|[]
init|=
literal|"sm_file"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* An open type to map to fopen()-like behavior */
end_comment

begin_decl_stmt
name|SM_FILE_T
name|SmFtStdio_def
init|=
block|{
name|SmFileMagic
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
operator|(
name|SMRW
operator||
name|SMFBF
operator|)
block|,
operator|-
literal|1
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|sm_stdclose
block|,
name|sm_stdread
block|,
name|sm_stdseek
block|,
name|sm_stdwrite
block|,
name|sm_stdopen
block|,
name|sm_stdsetinfo
block|,
name|sm_stdgetinfo
block|,
name|SM_TIME_FOREVER
block|,
name|SM_TIME_BLOCK
block|,
literal|"stdio"
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* An open type to map to fdopen()-like behavior */
end_comment

begin_decl_stmt
name|SM_FILE_T
name|SmFtStdiofd_def
init|=
block|{
name|SmFileMagic
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
operator|(
name|SMRW
operator||
name|SMFBF
operator|)
block|,
operator|-
literal|1
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|sm_stdclose
block|,
name|sm_stdread
block|,
name|sm_stdseek
block|,
name|sm_stdwrite
block|,
name|sm_stdfdopen
block|,
name|sm_stdsetinfo
block|,
name|sm_stdgetinfo
block|,
name|SM_TIME_FOREVER
block|,
name|SM_TIME_BLOCK
block|,
literal|"stdiofd"
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* A string file type */
end_comment

begin_decl_stmt
name|SM_FILE_T
name|SmFtString_def
init|=
block|{
name|SmFileMagic
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
operator|(
name|SMRW
operator||
name|SMNBF
operator|)
block|,
operator|-
literal|1
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|sm_strclose
block|,
name|sm_strread
block|,
name|sm_strseek
block|,
name|sm_strwrite
block|,
name|sm_stropen
block|,
name|sm_strsetinfo
block|,
name|sm_strgetinfo
block|,
name|SM_TIME_FOREVER
block|,
name|SM_TIME_BLOCK
block|,
literal|"string"
block|}
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* A file type for syslog communications */
end_comment

begin_endif
unit|SM_FILE_T SmFtSyslog_def =     {SmFileMagic, 0, 0, 0, (SMRW|SMNBF), -1, {0, 0}, 0, 0, 0, 	sm_syslogclose, sm_syslogread, sm_syslogseek, sm_syslogwrite, 	sm_syslogopen, sm_syslogsetinfo, sm_sysloggetinfo, SM_TIME_FOREVER, 	SM_TIME_BLOCK, "syslog" };
endif|#
directive|endif
end_endif

begin_comment
comment|/* 0 */
end_comment

begin_define
define|#
directive|define
name|NDYNAMIC
value|10
end_define

begin_comment
comment|/* add ten more whenever necessary */
end_comment

begin_define
define|#
directive|define
name|smio
parameter_list|(
name|flags
parameter_list|,
name|file
parameter_list|,
name|name
parameter_list|)
define|\
value|{SmFileMagic, 0, 0, 0, flags, file, {0}, 0, SmIoF+file, 0,		\ 	sm_stdclose, sm_stdread, sm_stdseek, sm_stdwrite,		\ 	sm_stdopen, sm_stdsetinfo, sm_stdgetinfo, SM_TIME_FOREVER,	\ 	SM_TIME_BLOCK, name}
end_define

begin_comment
comment|/* sm_magic p r w flags file bf lbfsize cookie ival */
end_comment

begin_define
define|#
directive|define
name|smstd
parameter_list|(
name|flags
parameter_list|,
name|file
parameter_list|,
name|name
parameter_list|)
define|\
value|{SmFileMagic, 0, 0, 0, flags, -1, {0}, 0, 0, file,			\ 	sm_stdioclose, sm_stdioread, sm_stdioseek, sm_stdiowrite,	\ 	sm_stdioopen, sm_stdiosetinfo, sm_stdiogetinfo, SM_TIME_FOREVER,\ 	SM_TIME_BLOCK, name}
end_define

begin_comment
comment|/* A file type for interfacing to stdio FILE* streams. */
end_comment

begin_decl_stmt
name|SM_FILE_T
name|SmFtRealStdio_def
init|=
name|smstd
argument_list|(
name|SMRW
operator||
name|SMNBF
argument_list|,
operator|-
literal|1
argument_list|,
literal|"realstdio"
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* the usual - (stdin + stdout + stderr) */
end_comment

begin_decl_stmt
specifier|static
name|SM_FILE_T
name|usual
index|[
name|SM_IO_OPEN_MAX
operator|-
literal|3
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|sm_glue
name|smuglue
init|=
block|{
literal|0
block|,
name|SM_IO_OPEN_MAX
operator|-
literal|3
block|,
name|usual
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* List of builtin automagically already open file pointers */
end_comment

begin_decl_stmt
name|SM_FILE_T
name|SmIoF
index|[
literal|6
index|]
init|=
block|{
name|smio
argument_list|(
name|SMRD
operator||
name|SMLBF
argument_list|,
name|SMIOIN_FILENO
argument_list|,
literal|"smioin"
argument_list|)
block|,
comment|/* smioin */
name|smio
argument_list|(
name|SMWR
operator||
name|SMLBF
argument_list|,
name|SMIOOUT_FILENO
argument_list|,
literal|"smioout"
argument_list|)
block|,
comment|/* smioout */
name|smio
argument_list|(
name|SMWR
operator||
name|SMNBF
argument_list|,
name|SMIOERR_FILENO
argument_list|,
literal|"smioerr"
argument_list|)
block|,
comment|/* smioerr */
name|smstd
argument_list|(
name|SMRD
operator||
name|SMNBF
argument_list|,
name|SMIOIN_FILENO
argument_list|,
literal|"smiostdin"
argument_list|)
block|,
comment|/* smiostdin */
name|smstd
argument_list|(
name|SMWR
operator||
name|SMNBF
argument_list|,
name|SMIOOUT_FILENO
argument_list|,
literal|"smiostdout"
argument_list|)
block|,
comment|/* smiostdout */
name|smstd
argument_list|(
argument|SMWR|SMNBF
argument_list|,
argument|SMIOERR_FILENO
argument_list|,
literal|"smiostderr"
argument_list|)
comment|/* smiostderr */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Structure containing list of currently open file pointers */
end_comment

begin_decl_stmt
name|struct
name|sm_glue
name|smglue
init|=
block|{
operator|&
name|smuglue
block|,
literal|3
block|,
name|SmIoF
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* **  SM_MOREGLUE -- adds more space for open file pointers ** **	Parameters: **		n -- number of new spaces for file pointers ** **	Returns: **		Raises an exception if no more memory. **		Otherwise, returns a pointer to new spaces. */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|sm_glue
modifier|*
name|sm_moreglue_x
name|__P
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|SM_FILE_T
name|empty
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|struct
name|sm_glue
modifier|*
name|sm_moreglue_x
parameter_list|(
name|n
parameter_list|)
specifier|register
name|int
name|n
decl_stmt|;
block|{
specifier|register
name|struct
name|sm_glue
modifier|*
name|g
decl_stmt|;
specifier|register
name|SM_FILE_T
modifier|*
name|p
decl_stmt|;
name|g
operator|=
operator|(
expr|struct
name|sm_glue
operator|*
operator|)
name|sm_pmalloc_x
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|g
argument_list|)
operator|+
name|SM_ALIGN_BITS
operator|+
name|n
operator|*
sizeof|sizeof
argument_list|(
name|SM_FILE_T
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|=
operator|(
name|SM_FILE_T
operator|*
operator|)
name|SM_ALIGN
argument_list|(
name|g
operator|+
literal|1
argument_list|)
expr_stmt|;
name|g
operator|->
name|gl_next
operator|=
name|NULL
expr_stmt|;
name|g
operator|->
name|gl_niobs
operator|=
name|n
expr_stmt|;
name|g
operator|->
name|gl_iobs
operator|=
name|p
expr_stmt|;
while|while
condition|(
operator|--
name|n
operator|>=
literal|0
condition|)
operator|*
name|p
operator|++
operator|=
name|empty
expr_stmt|;
return|return
name|g
return|;
block|}
end_function

begin_comment
comment|/* **  SM_FP -- allocate and initialize an SM_FILE structure ** **	Parameters: **		t -- file type requested to be opened. **		flags -- control flags for file type behavior **		oldfp -- file pointer to reuse if available (optional) ** **	Returns: **		Raises exception on memory exhaustion. **		Aborts if type is invalid. **		Otherwise, returns file pointer for requested file type. */
end_comment

begin_function
name|SM_FILE_T
modifier|*
name|sm_fp
parameter_list|(
name|t
parameter_list|,
name|flags
parameter_list|,
name|oldfp
parameter_list|)
specifier|const
name|SM_FILE_T
modifier|*
name|t
decl_stmt|;
specifier|const
name|int
name|flags
decl_stmt|;
name|SM_FILE_T
modifier|*
name|oldfp
decl_stmt|;
block|{
specifier|register
name|SM_FILE_T
modifier|*
name|fp
decl_stmt|;
specifier|register
name|int
name|n
decl_stmt|;
specifier|register
name|struct
name|sm_glue
modifier|*
name|g
decl_stmt|;
name|SM_REQUIRE
argument_list|(
name|t
operator|->
name|f_open
operator|&&
name|t
operator|->
name|f_close
operator|&&
operator|(
name|t
operator|->
name|f_read
operator|||
name|t
operator|->
name|f_write
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|Sm_IO_DidInit
condition|)
name|sm_init
argument_list|()
expr_stmt|;
if|if
condition|(
name|oldfp
operator|!=
name|NULL
condition|)
block|{
name|fp
operator|=
name|oldfp
expr_stmt|;
goto|goto
name|found
goto|;
comment|/* for opening reusing an 'fp' */
block|}
for|for
control|(
name|g
operator|=
operator|&
name|smglue
init|;
condition|;
name|g
operator|=
name|g
operator|->
name|gl_next
control|)
block|{
for|for
control|(
name|fp
operator|=
name|g
operator|->
name|gl_iobs
operator|,
name|n
operator|=
name|g
operator|->
name|gl_niobs
init|;
operator|--
name|n
operator|>=
literal|0
condition|;
name|fp
operator|++
control|)
if|if
condition|(
name|fp
operator|->
name|sm_magic
operator|==
name|NULL
condition|)
goto|goto
name|found
goto|;
if|if
condition|(
name|g
operator|->
name|gl_next
operator|==
name|NULL
condition|)
name|g
operator|->
name|gl_next
operator|=
name|sm_moreglue_x
argument_list|(
name|NDYNAMIC
argument_list|)
expr_stmt|;
block|}
name|found
label|:
name|fp
operator|->
name|sm_magic
operator|=
name|SmFileMagic
expr_stmt|;
comment|/* 'fp' now valid and in-use */
name|fp
operator|->
name|f_p
operator|=
name|NULL
expr_stmt|;
comment|/* no current pointer */
name|fp
operator|->
name|f_w
operator|=
literal|0
expr_stmt|;
comment|/* nothing to write */
name|fp
operator|->
name|f_r
operator|=
literal|0
expr_stmt|;
comment|/* nothing to read */
name|fp
operator|->
name|f_flags
operator|=
name|flags
expr_stmt|;
name|fp
operator|->
name|f_file
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* no file */
name|fp
operator|->
name|f_bf
operator|.
name|smb_base
operator|=
name|NULL
expr_stmt|;
comment|/* no buffer */
name|fp
operator|->
name|f_bf
operator|.
name|smb_size
operator|=
literal|0
expr_stmt|;
comment|/* no buffer size with no buffer */
name|fp
operator|->
name|f_lbfsize
operator|=
literal|0
expr_stmt|;
comment|/* not line buffered */
name|fp
operator|->
name|f_flushfp
operator|=
name|NULL
expr_stmt|;
comment|/* no associated flush file */
name|fp
operator|->
name|f_cookie
operator|=
name|fp
expr_stmt|;
comment|/* default: *open* overrides cookie setting */
name|fp
operator|->
name|f_close
operator|=
name|t
operator|->
name|f_close
expr_stmt|;
comment|/* assign close function */
name|fp
operator|->
name|f_read
operator|=
name|t
operator|->
name|f_read
expr_stmt|;
comment|/* assign read function */
name|fp
operator|->
name|f_seek
operator|=
name|t
operator|->
name|f_seek
expr_stmt|;
comment|/* assign seek function */
name|fp
operator|->
name|f_write
operator|=
name|t
operator|->
name|f_write
expr_stmt|;
comment|/* assign write function */
name|fp
operator|->
name|f_open
operator|=
name|t
operator|->
name|f_open
expr_stmt|;
comment|/* assign open function */
name|fp
operator|->
name|f_setinfo
operator|=
name|t
operator|->
name|f_setinfo
expr_stmt|;
comment|/* assign setinfo function */
name|fp
operator|->
name|f_getinfo
operator|=
name|t
operator|->
name|f_getinfo
expr_stmt|;
comment|/* assign getinfo function */
name|fp
operator|->
name|f_type
operator|=
name|t
operator|->
name|f_type
expr_stmt|;
comment|/* file type */
name|fp
operator|->
name|f_ub
operator|.
name|smb_base
operator|=
name|NULL
expr_stmt|;
comment|/* no ungetc buffer */
name|fp
operator|->
name|f_ub
operator|.
name|smb_size
operator|=
literal|0
expr_stmt|;
comment|/* no size for no ungetc buffer */
if|if
condition|(
name|fp
operator|->
name|f_timeout
operator|==
name|SM_TIME_DEFAULT
condition|)
name|fp
operator|->
name|f_timeout
operator|=
name|SM_TIME_FOREVER
expr_stmt|;
else|else
name|fp
operator|->
name|f_timeout
operator|=
name|t
operator|->
name|f_timeout
expr_stmt|;
comment|/* traditional behavior */
name|fp
operator|->
name|f_timeoutstate
operator|=
name|SM_TIME_BLOCK
expr_stmt|;
comment|/* by default */
return|return
name|fp
return|;
block|}
end_function

begin_comment
comment|/* **  SM_CLEANUP -- cleanup function when exit called. ** **	This function is registered via atexit(). ** **	Parameters: **		none ** **	Returns: **		nothing. ** **	Side Effects: **		flushes open files before they are forced closed */
end_comment

begin_function
name|void
name|sm_cleanup
parameter_list|()
block|{
name|int
name|timeout
init|=
name|SM_TIME_DEFAULT
decl_stmt|;
operator|(
name|void
operator|)
name|sm_fwalk
argument_list|(
name|sm_flush
argument_list|,
operator|&
name|timeout
argument_list|)
expr_stmt|;
comment|/* `cheating' */
block|}
end_function

begin_comment
comment|/* **  SM_INIT -- called whenever sm_io's internal variables must be set up. ** **	Parameters: **		none ** **	Returns: **		none ** **	Side Effects: **		Registers sm_cleanup() using atexit(). */
end_comment

begin_function
name|void
name|sm_init
parameter_list|()
block|{
if|if
condition|(
name|Sm_IO_DidInit
condition|)
comment|/* paranoia */
return|return;
comment|/* more paranoia: initialize pointers in a static variable */
name|empty
operator|.
name|f_type
operator|=
name|NULL
expr_stmt|;
name|empty
operator|.
name|sm_magic
operator|=
name|NULL
expr_stmt|;
comment|/* make sure we clean up on exit */
name|atexit
argument_list|(
name|sm_cleanup
argument_list|)
expr_stmt|;
comment|/* conservative */
name|Sm_IO_DidInit
operator|=
name|true
expr_stmt|;
block|}
end_function

begin_comment
comment|/* **  SM_IO_SETINFO -- change info for an open file type (fp) ** **	The generic SM_IO_WHAT_VECTORS is auto supplied for all file types. **	If the request is to set info other than SM_IO_WHAT_VECTORS then **	the request is passed on to the file type's specific setinfo vector. **	WARNING: this is working on an active/open file type. ** **	Parameters: **		fp -- file to make the setting on **		what -- type of information to set **		valp -- structure to obtain info from ** **	Returns: **		0 on success **		-1 on error and sets errno: **			- when what != SM_IO_WHAT_VECTORS and setinfo vector **				not set **			- when vectored setinfo returns -1 */
end_comment

begin_function
name|int
name|sm_io_setinfo
parameter_list|(
name|fp
parameter_list|,
name|what
parameter_list|,
name|valp
parameter_list|)
name|SM_FILE_T
modifier|*
name|fp
decl_stmt|;
name|int
name|what
decl_stmt|;
name|void
modifier|*
name|valp
decl_stmt|;
block|{
name|SM_FILE_T
modifier|*
name|v
init|=
operator|(
name|SM_FILE_T
operator|*
operator|)
name|valp
decl_stmt|;
name|SM_REQUIRE_ISA
argument_list|(
name|fp
argument_list|,
name|SmFileMagic
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|what
condition|)
block|{
case|case
name|SM_IO_WHAT_VECTORS
case|:
comment|/* 		**  This is the "generic" available for all. 		**  This allows the function vectors to be replaced 		**  while the file type is active. 		*/
name|fp
operator|->
name|f_close
operator|=
name|v
operator|->
name|f_close
expr_stmt|;
name|fp
operator|->
name|f_read
operator|=
name|v
operator|->
name|f_read
expr_stmt|;
name|fp
operator|->
name|f_seek
operator|=
name|v
operator|->
name|f_seek
expr_stmt|;
name|fp
operator|->
name|f_write
operator|=
name|v
operator|->
name|f_write
expr_stmt|;
name|fp
operator|->
name|f_open
operator|=
name|v
operator|->
name|f_open
expr_stmt|;
name|fp
operator|->
name|f_setinfo
operator|=
name|v
operator|->
name|f_setinfo
expr_stmt|;
name|fp
operator|->
name|f_getinfo
operator|=
name|v
operator|->
name|f_getinfo
expr_stmt|;
name|sm_free
argument_list|(
name|fp
operator|->
name|f_type
argument_list|)
expr_stmt|;
name|fp
operator|->
name|f_type
operator|=
name|sm_strdup_x
argument_list|(
name|v
operator|->
name|f_type
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|SM_IO_WHAT_TIMEOUT
case|:
name|fp
operator|->
name|f_timeout
operator|=
operator|*
operator|(
operator|(
name|int
operator|*
operator|)
name|valp
operator|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* Otherwise the vector will check it out */
if|if
condition|(
name|fp
operator|->
name|f_setinfo
operator|==
name|NULL
condition|)
block|{
name|errno
operator|=
name|EINVAL
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
else|else
return|return
call|(
modifier|*
name|fp
operator|->
name|f_setinfo
call|)
argument_list|(
name|fp
argument_list|,
name|what
argument_list|,
name|valp
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* **  SM_IO_GETINFO -- get information for an active file type (fp) ** **  This function supplies for all file types the answers for the **		three requests SM_IO_WHAT_VECTORS, SM_IO_WHAT_TYPE and **		SM_IO_WHAT_ISTYPE. Other requests are handled by the getinfo **		vector if available for the open file type. **	SM_IO_WHAT_VECTORS returns information for the file pointer vectors. **	SM_IO_WHAT_TYPE returns the type identifier for the file pointer **	SM_IO_WHAT_ISTYPE returns>0 if the passed in type matches the **		file pointer's type. **	SM_IO_IS_READABLE returns 1 if there is data available for reading, **		0 otherwise. ** **	Parameters: **		fp -- file pointer for active file type **		what -- type of information request **		valp -- structure to place obtained info into ** **	Returns: **		-1 on error and sets errno: **			- when valp==NULL and request expects otherwise **			- when request is not SM_IO_WHAT_VECTORS and not **				SM_IO_WHAT_TYPE and not SM_IO_WHAT_ISTYPE **				and getinfo vector is NULL **			- when getinfo type vector returns -1 **>=0 on success */
end_comment

begin_function
name|int
name|sm_io_getinfo
parameter_list|(
name|fp
parameter_list|,
name|what
parameter_list|,
name|valp
parameter_list|)
name|SM_FILE_T
modifier|*
name|fp
decl_stmt|;
name|int
name|what
decl_stmt|;
name|void
modifier|*
name|valp
decl_stmt|;
block|{
name|SM_FILE_T
modifier|*
name|v
init|=
operator|(
name|SM_FILE_T
operator|*
operator|)
name|valp
decl_stmt|;
name|SM_REQUIRE_ISA
argument_list|(
name|fp
argument_list|,
name|SmFileMagic
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|what
condition|)
block|{
case|case
name|SM_IO_WHAT_VECTORS
case|:
if|if
condition|(
name|valp
operator|==
name|NULL
condition|)
block|{
name|errno
operator|=
name|EINVAL
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* This is the "generic" available for all */
name|v
operator|->
name|f_close
operator|=
name|fp
operator|->
name|f_close
expr_stmt|;
name|v
operator|->
name|f_read
operator|=
name|fp
operator|->
name|f_read
expr_stmt|;
name|v
operator|->
name|f_seek
operator|=
name|fp
operator|->
name|f_seek
expr_stmt|;
name|v
operator|->
name|f_write
operator|=
name|fp
operator|->
name|f_write
expr_stmt|;
name|v
operator|->
name|f_open
operator|=
name|fp
operator|->
name|f_open
expr_stmt|;
name|v
operator|->
name|f_setinfo
operator|=
name|fp
operator|->
name|f_setinfo
expr_stmt|;
name|v
operator|->
name|f_getinfo
operator|=
name|fp
operator|->
name|f_getinfo
expr_stmt|;
name|v
operator|->
name|f_type
operator|=
name|fp
operator|->
name|f_type
expr_stmt|;
return|return
literal|0
return|;
case|case
name|SM_IO_WHAT_TYPE
case|:
if|if
condition|(
name|valp
operator|==
name|NULL
condition|)
block|{
name|errno
operator|=
name|EINVAL
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|valp
operator|=
name|sm_strdup_x
argument_list|(
name|fp
operator|->
name|f_type
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|SM_IO_WHAT_ISTYPE
case|:
if|if
condition|(
name|valp
operator|==
name|NULL
condition|)
block|{
name|errno
operator|=
name|EINVAL
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
return|return
name|strcmp
argument_list|(
name|fp
operator|->
name|f_type
argument_list|,
name|valp
argument_list|)
operator|==
literal|0
return|;
case|case
name|SM_IO_IS_READABLE
case|:
comment|/* if there is data in the buffer, it must be readable */
if|if
condition|(
name|fp
operator|->
name|f_r
operator|>
literal|0
condition|)
return|return
literal|1
return|;
comment|/* otherwise query the underlying file */
break|break;
case|case
name|SM_IO_WHAT_TIMEOUT
case|:
operator|*
operator|(
operator|(
name|int
operator|*
operator|)
name|valp
operator|)
operator|=
name|fp
operator|->
name|f_timeout
expr_stmt|;
return|return
literal|0
return|;
case|case
name|SM_IO_WHAT_FD
case|:
if|if
condition|(
name|fp
operator|->
name|f_file
operator|>
operator|-
literal|1
condition|)
return|return
name|fp
operator|->
name|f_file
return|;
comment|/* try the file type specific getinfo to see if it knows */
break|break;
block|}
comment|/* Otherwise the vector will check it out */
if|if
condition|(
name|fp
operator|->
name|f_getinfo
operator|==
name|NULL
condition|)
block|{
name|errno
operator|=
name|EINVAL
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
return|return
call|(
modifier|*
name|fp
operator|->
name|f_getinfo
call|)
argument_list|(
name|fp
argument_list|,
name|what
argument_list|,
name|valp
argument_list|)
return|;
block|}
end_function

end_unit

