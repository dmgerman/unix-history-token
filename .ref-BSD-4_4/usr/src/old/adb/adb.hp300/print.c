begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)print.c 4.11 5/2/85"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  *  *	UNIX debugger  *  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_decl_stmt
name|MSG
name|LONGFIL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|MSG
name|NOTOPEN
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|MSG
name|A68BAD
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|MSG
name|A68LNK
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|MSG
name|BADMOD
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|MAP
name|txtmap
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|MAP
name|datmap
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|MAP
name|physmap
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|ADDR
name|lastframe
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|ADDR
name|callpc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|INT
name|infile
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|INT
name|outfile
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|CHAR
modifier|*
name|lp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|L_INT
name|maxoff
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|L_INT
name|maxpos
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|INT
name|radix
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* symbol management */
end_comment

begin_decl_stmt
name|L_INT
name|localval
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* breakpoints */
end_comment

begin_decl_stmt
name|BKPTR
name|bkpthead
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|REGLIST
name|reglist
index|[]
init|=
block|{
ifdef|#
directive|ifdef
name|pdp11
name|help
operator|!
endif|#
directive|endif
ifdef|#
directive|ifdef
name|vax
literal|"p1lr"
block|,
name|P1LR
block|,
operator|&
name|pcb
operator|.
name|pcb_p1lr
block|,
literal|"p1br"
block|,
name|P1BR
block|,
operator|&
name|pcb
operator|.
name|pcb_p1br
block|,
literal|"p0lr"
block|,
name|P0LR
block|,
operator|&
name|pcb
operator|.
name|pcb_p0lr
block|,
literal|"p0br"
block|,
name|P0BR
block|,
operator|&
name|pcb
operator|.
name|pcb_p0br
block|,
literal|"ksp"
block|,
name|KSP
block|,
operator|&
name|pcb
operator|.
name|pcb_ksp
block|,
literal|"esp"
block|,
name|ESP
block|,
operator|&
name|pcb
operator|.
name|pcb_esp
block|,
literal|"ssp"
block|,
name|SSP
block|,
operator|&
name|pcb
operator|.
name|pcb_ssp
block|,
literal|"psl"
block|,
name|PSL
block|,
operator|&
name|pcb
operator|.
name|pcb_psl
block|,
literal|"pc"
block|,
name|PC
block|,
operator|&
name|pcb
operator|.
name|pcb_pc
block|,
literal|"usp"
block|,
name|USP
block|,
operator|&
name|pcb
operator|.
name|pcb_usp
block|,
literal|"fp"
block|,
name|FP
block|,
operator|&
name|pcb
operator|.
name|pcb_fp
block|,
literal|"ap"
block|,
name|AP
block|,
operator|&
name|pcb
operator|.
name|pcb_ap
block|,
literal|"r11"
block|,
name|R11
block|,
operator|&
name|pcb
operator|.
name|pcb_r11
block|,
literal|"r10"
block|,
name|R10
block|,
operator|&
name|pcb
operator|.
name|pcb_r10
block|,
literal|"r9"
block|,
name|R9
block|,
operator|&
name|pcb
operator|.
name|pcb_r9
block|,
literal|"r8"
block|,
name|R8
block|,
operator|&
name|pcb
operator|.
name|pcb_r8
block|,
literal|"r7"
block|,
name|R7
block|,
operator|&
name|pcb
operator|.
name|pcb_r7
block|,
literal|"r6"
block|,
name|R6
block|,
operator|&
name|pcb
operator|.
name|pcb_r6
block|,
literal|"r5"
block|,
name|R5
block|,
operator|&
name|pcb
operator|.
name|pcb_r5
block|,
literal|"r4"
block|,
name|R4
block|,
operator|&
name|pcb
operator|.
name|pcb_r4
block|,
literal|"r3"
block|,
name|R3
block|,
operator|&
name|pcb
operator|.
name|pcb_r3
block|,
literal|"r2"
block|,
name|R2
block|,
operator|&
name|pcb
operator|.
name|pcb_r2
block|,
literal|"r1"
block|,
name|R1
block|,
operator|&
name|pcb
operator|.
name|pcb_r1
block|,
literal|"r0"
block|,
name|R0
block|,
operator|&
name|pcb
operator|.
name|pcb_r0
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|hp300
comment|/* not all register info is available from the pcb */
comment|/* for hp (and other 68000's) we add a print format field and a type field */
ifndef|#
directive|ifndef
name|NEWVM
literal|"p0br"
block|,
name|P0BR
block|,
operator|&
name|pcb
operator|.
name|pcb_p0br
block|,
name|FMTTAB
block|,
name|HEXINT
block|,
literal|"p0lr"
block|,
name|P0LR
block|,
operator|&
name|pcb
operator|.
name|pcb_p0lr
block|,
name|FMTNL
block|,
name|HEXINT
block|,
literal|"p1br"
block|,
name|P1BR
block|,
operator|&
name|pcb
operator|.
name|pcb_p1br
block|,
name|FMTTAB
block|,
name|HEXINT
block|,
literal|"p1lr"
block|,
name|P1LR
block|,
operator|&
name|pcb
operator|.
name|pcb_p1lr
block|,
name|FMTNL
block|,
name|HEXINT
block|,
endif|#
directive|endif
literal|"psw"
block|,
name|PSW
block|,
operator|&
name|pcb
operator|.
name|pcb_flags
block|,
name|FMTNL
block|,
name|HEXINT
block|,
literal|"usp"
block|,
name|USP
block|,
operator|&
name|pcb
operator|.
name|pcb_usp
block|,
name|FMTTAB
block|,
name|HEXINT
block|,
literal|"pc"
block|,
name|PC
block|,
literal|0
block|,
name|FMTNL
block|,
name|HEXADDR
block|,
literal|"d7"
block|,
name|D7
block|,
operator|&
name|pcb
operator|.
name|pcb_regs
index|[
literal|5
index|]
block|,
name|FMTTAB
block|,
name|HEXINT
block|,
literal|"sp"
block|,
name|A7
block|,
operator|&
name|pcb
operator|.
name|pcb_regs
index|[
literal|11
index|]
block|,
name|FMTNL
block|,
name|HEXADDR
block|,
literal|"d6"
block|,
name|D6
block|,
operator|&
name|pcb
operator|.
name|pcb_regs
index|[
literal|4
index|]
block|,
name|FMTTAB
block|,
name|HEXINT
block|,
literal|"a6"
block|,
name|A6
block|,
operator|&
name|pcb
operator|.
name|pcb_regs
index|[
literal|10
index|]
block|,
name|FMTNL
block|,
name|HEXADDR
block|,
literal|"d5"
block|,
name|D5
block|,
operator|&
name|pcb
operator|.
name|pcb_regs
index|[
literal|3
index|]
block|,
name|FMTTAB
block|,
name|HEXINT
block|,
literal|"a5"
block|,
name|A5
block|,
operator|&
name|pcb
operator|.
name|pcb_regs
index|[
literal|9
index|]
block|,
name|FMTNL
block|,
name|HEXADDR
block|,
literal|"d4"
block|,
name|D4
block|,
operator|&
name|pcb
operator|.
name|pcb_regs
index|[
literal|2
index|]
block|,
name|FMTTAB
block|,
name|HEXINT
block|,
literal|"a4"
block|,
name|A4
block|,
operator|&
name|pcb
operator|.
name|pcb_regs
index|[
literal|8
index|]
block|,
name|FMTNL
block|,
name|HEXADDR
block|,
literal|"d3"
block|,
name|D3
block|,
operator|&
name|pcb
operator|.
name|pcb_regs
index|[
literal|1
index|]
block|,
name|FMTTAB
block|,
name|HEXINT
block|,
literal|"a3"
block|,
name|A3
block|,
operator|&
name|pcb
operator|.
name|pcb_regs
index|[
literal|7
index|]
block|,
name|FMTNL
block|,
name|HEXADDR
block|,
literal|"d2"
block|,
name|D2
block|,
operator|&
name|pcb
operator|.
name|pcb_regs
index|[
literal|0
index|]
block|,
name|FMTTAB
block|,
name|HEXINT
block|,
literal|"a2"
block|,
name|A2
block|,
operator|&
name|pcb
operator|.
name|pcb_regs
index|[
literal|6
index|]
block|,
name|FMTNL
block|,
name|HEXADDR
block|,
literal|"d1"
block|,
name|D1
block|,
literal|0
block|,
name|FMTTAB
block|,
name|HEXINT
block|,
literal|"a1"
block|,
name|A1
block|,
literal|0
block|,
name|FMTNL
block|,
name|HEXADDR
block|,
literal|"d0"
block|,
name|D0
block|,
literal|0
block|,
name|FMTTAB
block|,
name|HEXINT
block|,
literal|"a0"
block|,
name|A0
block|,
literal|0
block|,
name|FMTNL
block|,
name|HEXADDR
block|,
literal|"fp0"
block|,
name|FP0
block|,
operator|&
name|pcb
operator|.
name|pcb_fpregs
operator|.
name|fpf_regs
index|[
literal|0
index|]
block|,
name|FMTTAB
block|,
name|XPFLOAT
block|,
literal|"fp4"
block|,
name|FP4
block|,
operator|&
name|pcb
operator|.
name|pcb_fpregs
operator|.
name|fpf_regs
index|[
literal|12
index|]
block|,
name|FMTNL
block|,
name|XPFLOAT
block|,
literal|"fp1"
block|,
name|FP1
block|,
operator|&
name|pcb
operator|.
name|pcb_fpregs
operator|.
name|fpf_regs
index|[
literal|3
index|]
block|,
name|FMTTAB
block|,
name|XPFLOAT
block|,
literal|"fp5"
block|,
name|FP5
block|,
operator|&
name|pcb
operator|.
name|pcb_fpregs
operator|.
name|fpf_regs
index|[
literal|15
index|]
block|,
name|FMTNL
block|,
name|XPFLOAT
block|,
literal|"fp2"
block|,
name|FP2
block|,
operator|&
name|pcb
operator|.
name|pcb_fpregs
operator|.
name|fpf_regs
index|[
literal|6
index|]
block|,
name|FMTTAB
block|,
name|XPFLOAT
block|,
literal|"fp6"
block|,
name|FP6
block|,
operator|&
name|pcb
operator|.
name|pcb_fpregs
operator|.
name|fpf_regs
index|[
literal|18
index|]
block|,
name|FMTNL
block|,
name|XPFLOAT
block|,
literal|"fp3"
block|,
name|FP3
block|,
operator|&
name|pcb
operator|.
name|pcb_fpregs
operator|.
name|fpf_regs
index|[
literal|9
index|]
block|,
name|FMTTAB
block|,
name|XPFLOAT
block|,
literal|"fp7"
block|,
name|FP7
block|,
operator|&
name|pcb
operator|.
name|pcb_fpregs
operator|.
name|fpf_regs
index|[
literal|21
index|]
block|,
name|FMTNL
block|,
name|XPFLOAT
block|,
literal|"fpcr"
block|,
name|FPCR
block|,
operator|&
name|pcb
operator|.
name|pcb_fpregs
operator|.
name|fpf_fpcr
block|,
name|FMTTAB
block|,
name|HEXINT
block|,
literal|"fpsr"
block|,
name|FPSR
block|,
operator|&
name|pcb
operator|.
name|pcb_fpregs
operator|.
name|fpf_fpsr
block|,
name|FMTTAB
block|,
name|HEXINT
block|,
literal|"fpiar"
block|,
name|FPIAR
block|,
operator|&
name|pcb
operator|.
name|pcb_fpregs
operator|.
name|fpf_fpiar
block|,
name|FMTNL
block|,
name|HEXINT
block|,
endif|#
directive|endif
if|#
directive|if
operator|!
name|pdp11
operator|&&
operator|!
name|vax
operator|&&
operator|!
name|hp300
name|edit
name|this
name|file
name|and
name|add
name|the
name|reglist
for|for your machine
endif|#
directive|endif
for|}
empty_stmt|;
name|INT
name|nregs
operator|=
sizeof|sizeof
name|reglist
operator|/
sizeof|sizeof
name|reglist
index|[
literal|0
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|lastc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|INT
name|fcor
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STRING
name|errflg
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|INT
name|signo
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|INT
name|sigcode
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|L_INT
name|dot
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|L_INT
name|var
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STRING
name|symfil
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STRING
name|corfil
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|INT
name|pid
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|L_INT
name|adrval
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|INT
name|adrflg
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|L_INT
name|cntval
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|INT
name|cntflg
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|STRING
name|sys_siglist
index|[
name|NSIG
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* general printing routines ($) */
end_comment

begin_macro
name|printtrace
argument_list|(
argument|modif
argument_list|)
end_macro

begin_block
block|{
name|INT
name|narg
decl_stmt|,
name|i
decl_stmt|,
name|stat
decl_stmt|,
name|name
decl_stmt|,
name|limit
decl_stmt|;
name|POS
name|dynam
decl_stmt|;
name|REG
name|BKPTR
name|bkptr
decl_stmt|;
name|CHAR
name|hi
decl_stmt|,
name|lo
decl_stmt|;
name|ADDR
name|word
decl_stmt|;
name|STRING
name|comptr
decl_stmt|;
name|ADDR
name|argp
decl_stmt|,
name|frame
decl_stmt|,
name|link
decl_stmt|;
specifier|register
name|struct
name|nlist
modifier|*
name|sp
decl_stmt|;
name|INT
name|stack
decl_stmt|;
name|INT
name|ntramp
decl_stmt|;
name|INT
name|tracefirst
decl_stmt|;
name|L_INT
name|radj
decl_stmt|;
name|IF
name|cntflg
operator|==
literal|0
name|THEN
name|cntval
operator|=
operator|-
literal|1
expr_stmt|;
name|FI
switch|switch
condition|(
name|modif
condition|)
block|{
case|case
literal|'<'
case|:
name|IF
name|cntval
operator|==
literal|0
name|THEN
name|WHILE
name|readchar
argument_list|()
operator|!=
name|EOR
name|DO
name|OD
name|lp
operator|--
expr_stmt|;
break|break;
name|FI
name|IF
name|rdc
argument_list|()
operator|==
literal|'<'
name|THEN
name|stack
operator|=
literal|1
expr_stmt|;
name|ELSE
name|stack
init|=
literal|0
decl_stmt|;
name|lp
operator|--
expr_stmt|;
name|FI
comment|/* fall thru... */
case|case
literal|'>'
case|:
block|{
name|CHAR
name|file
index|[
literal|64
index|]
decl_stmt|;
name|CHAR
name|Ifile
index|[
literal|128
index|]
decl_stmt|;
specifier|extern
name|CHAR
modifier|*
name|Ipath
decl_stmt|;
name|INT
name|index
decl_stmt|;
name|index
operator|=
literal|0
expr_stmt|;
name|IF
name|rdc
argument_list|()
operator|!=
name|EOR
name|THEN
name|REP
name|file
index|[
name|index
operator|++
index|]
operator|=
name|lastc
expr_stmt|;
name|IF
name|index
operator|>=
literal|63
name|THEN
name|error
argument_list|(
name|LONGFIL
argument_list|)
expr_stmt|;
name|FI
name|PER
name|readchar
argument_list|()
operator|!=
name|EOR
name|DONE
name|file
index|[
name|index
index|]
operator|=
literal|0
expr_stmt|;
name|IF
name|modif
operator|==
literal|'<'
name|THEN
name|IF
name|Ipath
name|THEN
name|IF
name|findifile
argument_list|(
name|file
argument_list|,
name|Ifile
argument_list|)
operator|==
literal|0
name|THEN
name|error
argument_list|(
name|NOTOPEN
argument_list|)
expr_stmt|;
name|FI
name|FI
name|IF
name|strcmp
argument_list|(
name|file
argument_list|,
literal|"-"
argument_list|)
decl|!=0
name|THEN
name|iclose
argument_list|(
name|stack
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|infile
operator|=
name|open
argument_list|(
name|file
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|IF
name|infile
operator|<
literal|0
name|THEN
name|infile
operator|=
name|open
argument_list|(
name|Ifile
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|FI
name|ELSE
name|lseek
argument_list|(
name|infile
argument_list|,
operator|(
name|off_t
operator|)
literal|0
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|FI
name|IF
name|infile
operator|<
literal|0
name|THEN
name|infile
operator|=
literal|0
expr_stmt|;
name|error
argument_list|(
name|NOTOPEN
argument_list|)
expr_stmt|;
name|ELSE
name|IF
name|cntflg
name|THEN
name|var
index|[
literal|9
index|]
init|=
name|cntval
decl_stmt|;
name|ELSE
name|var
index|[
literal|9
index|]
init|=
literal|1
decl_stmt|;
name|FI
name|FI
name|ELSE
name|oclose
parameter_list|()
function_decl|;
name|outfile
operator|=
name|open
argument_list|(
name|file
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|IF
name|outfile
operator|<
literal|0
name|THEN
name|outfile
operator|=
name|creat
argument_list|(
name|file
argument_list|,
literal|0644
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|EDDT
name|ELSE
name|lseek
argument_list|(
name|outfile
argument_list|,
operator|(
name|off_t
operator|)
literal|0
argument_list|,
literal|2
argument_list|)
decl_stmt|;
endif|#
directive|endif
name|FI
name|FI
name|ELSE
name|IF
name|modif
operator|==
literal|'<'
name|THEN
name|iclose
argument_list|(
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ELSE
name|oclose
parameter_list|()
function_decl|;
name|FI
name|FI
name|lp
operator|--
expr_stmt|;
block|}
break|break;
case|case
literal|'p'
case|:
ifdef|#
directive|ifdef
name|vax
name|IF
name|kernel
operator|==
literal|0
name|THEN
name|printf
argument_list|(
literal|"not debugging kernel\n"
argument_list|)
expr_stmt|;
name|ELSE
name|IF
name|adrflg
name|THEN
name|int
name|pte
init|=
name|access
argument_list|(
name|RD
argument_list|,
name|dot
argument_list|,
name|DSP
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|masterpcbb
operator|=
operator|(
name|pte
operator|&
name|PG_PFNUM
operator|)
operator|*
literal|512
expr_stmt|;
name|FI
name|getpcb
parameter_list|()
function_decl|;
name|FI
endif|#
directive|endif
ifdef|#
directive|ifdef
name|hp300
name|IF
name|kernel
operator|==
literal|0
name|THEN
name|printf
argument_list|(
literal|"not debugging kernel\n"
argument_list|)
expr_stmt|;
name|ELSE
name|IF
name|adrflg
name|THEN
name|masterpcbb
init|=
name|ctob
argument_list|(
name|dot
argument_list|)
decl_stmt|;
ifndef|#
directive|ifndef
name|NEWVM
name|IF
name|kcore
operator|&&
operator|!
name|kmem
name|THEN
name|masterpcbb
operator|-=
name|lowram
expr_stmt|;
name|FI
endif|#
directive|endif
name|FI
name|getpcb
parameter_list|()
function_decl|;
name|FI
endif|#
directive|endif
if|#
directive|if
operator|!
name|vax
operator|&&
operator|!
name|hp300
name|edit
name|this
name|file
name|and
name|fix
name|it
for|for your kernel
endif|#
directive|endif
for|break
empty_stmt|;
case|case
literal|'d'
case|:
name|IF
name|adrflg
name|THEN
name|IF
name|adrval
operator|<
literal|2
name|ORF
name|adrval
operator|>
literal|16
name|THEN
name|printf
argument_list|(
literal|"must have 2<= radix<= 16"
argument_list|)
expr_stmt|;
break|break;
name|FI
name|printf
argument_list|(
literal|"radix=%d base ten"
argument_list|,
name|radix
operator|=
name|adrval
argument_list|)
decl_stmt|;
name|FI
break|break;
case|case
literal|'q'
case|:
case|case
literal|'Q'
case|:
case|case
literal|'%'
case|:
name|done
argument_list|()
expr_stmt|;
case|case
literal|'w'
case|:
case|case
literal|'W'
case|:
name|maxpos
operator|=
operator|(
name|adrflg
condition|?
name|adrval
else|:
name|MAXPOS
operator|)
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
case|case
literal|'S'
case|:
name|maxoff
operator|=
operator|(
name|adrflg
condition|?
name|adrval
else|:
name|MAXOFF
operator|)
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
case|case
literal|'V'
case|:
name|prints
argument_list|(
literal|"variables\n"
argument_list|)
expr_stmt|;
name|FOR
name|i
init|=
literal|0
decl_stmt|;
name|i
operator|<=
literal|35
expr_stmt|;
name|i
operator|++
name|DO
name|IF
name|var
index|[
name|i
index|]
name|THEN
name|printc
argument_list|(
operator|(
name|i
operator|<=
literal|9
condition|?
literal|'0'
else|:
literal|'a'
operator|-
literal|10
operator|)
operator|+
name|i
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" = %x\n"
argument_list|,
name|var
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|FI
name|OD
break|break;
case|case
literal|'m'
case|:
case|case
literal|'M'
case|:
name|printmap
argument_list|(
literal|"? map"
argument_list|,
operator|&
name|txtmap
argument_list|)
expr_stmt|;
name|printmap
argument_list|(
literal|"/ map"
argument_list|,
operator|&
name|datmap
argument_list|)
expr_stmt|;
if|if
condition|(
name|kernel
condition|)
name|printmap
argument_list|(
literal|"] map"
argument_list|,
operator|&
name|physmap
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0
case|:
case|case
literal|'?'
case|:
name|IF
name|pid
name|THEN
name|printf
argument_list|(
literal|"pcs id = %d\n"
argument_list|,
name|pid
argument_list|)
decl_stmt|;
name|ELSE
name|prints
argument_list|(
literal|"no process\n"
argument_list|)
decl_stmt|;
name|FI
name|sigprint
parameter_list|()
function_decl|;
name|flushbuf
argument_list|()
expr_stmt|;
case|case
literal|'r'
case|:
case|case
literal|'R'
case|:
name|printregs
argument_list|()
expr_stmt|;
return|return;
case|case
literal|'c'
case|:
case|case
literal|'C'
case|:
ifdef|#
directive|ifdef
name|vax
name|IF
name|adrflg
name|THEN
name|frame
init|=
name|adrval
decl_stmt|;
name|word
operator|=
name|get
argument_list|(
name|adrval
operator|+
literal|6
argument_list|,
name|DSP
argument_list|)
operator|&
literal|0xFFFF
expr_stmt|;
name|IF
name|word
operator|&
literal|0x2000
name|THEN
comment|/* 'calls', can figure out argp */
name|argp
operator|=
name|adrval
operator|+
literal|20
operator|+
operator|(
operator|(
name|word
operator|>>
literal|14
operator|)
operator|&
literal|3
operator|)
expr_stmt|;
name|word
operator|&=
literal|0xFFF
expr_stmt|;
name|WHILE
name|word
name|DO
name|IF
name|word
operator|&
literal|1
name|THEN
name|argp
operator|+=
literal|4
expr_stmt|;
name|FI
name|word
operator|>>=
literal|1
expr_stmt|;
name|OD
name|ELSE
comment|/* 'callg', can't tell where argp is */
name|argp
init|=
name|frame
decl_stmt|;
name|FI
name|callpc
init|=
name|get
argument_list|(
name|frame
operator|+
literal|16
argument_list|,
name|DSP
argument_list|)
decl_stmt|;
name|ELIF
name|kcore
name|THEN
name|argp
init|=
name|pcb
operator|.
name|pcb_ap
decl_stmt|;
name|frame
operator|=
name|pcb
operator|.
name|pcb_fp
expr_stmt|;
name|callpc
operator|=
name|pcb
operator|.
name|pcb_pc
expr_stmt|;
name|ELSE
name|argp
init|=
operator|*
operator|(
name|ADDR
operator|*
operator|)
operator|(
operator|(
operator|(
name|ADDR
operator|)
operator|&
name|u
operator|)
operator|+
name|AP
operator|)
decl_stmt|;
name|frame
operator|=
operator|*
operator|(
name|ADDR
operator|*
operator|)
operator|(
operator|(
operator|(
name|ADDR
operator|)
operator|&
name|u
operator|)
operator|+
name|FP
operator|)
expr_stmt|;
name|callpc
operator|=
operator|*
operator|(
name|ADDR
operator|*
operator|)
operator|(
operator|(
operator|(
name|ADDR
operator|)
operator|&
name|u
operator|)
operator|+
name|PC
operator|)
expr_stmt|;
name|FI
endif|#
directive|endif
ifdef|#
directive|ifdef
name|hp300
name|tracefirst
init|=
literal|0
decl_stmt|;
name|IF
operator|!
name|kcore
name|THEN
name|radj
operator|=
name|getradj
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|FI
name|IF
name|adrflg
name|THEN
name|frame
init|=
name|adrval
decl_stmt|;
name|argp
operator|=
name|frame
operator|+
literal|4
expr_stmt|;
comment|/* base of args minus one word */
name|callpc
operator|=
name|lget
argument_list|(
name|frame
operator|+
literal|4
argument_list|,
name|DSP
argument_list|)
expr_stmt|;
comment|/* best we can do? */
name|ELIF
name|kcore
name|THEN
name|frame
init|=
name|pcb
operator|.
name|pcb_regs
index|[
literal|10
index|]
decl_stmt|;
name|argp
operator|=
name|frame
operator|+
literal|4
expr_stmt|;
name|callpc
operator|=
name|lget
argument_list|(
name|frame
argument_list|,
name|DSP
argument_list|)
expr_stmt|;
name|ELSE
name|callpc
init|=
operator|*
operator|(
name|ADDR
operator|*
operator|)
operator|(
operator|(
operator|(
name|ADDR
operator|)
operator|&
name|u
operator|)
operator|+
name|PC
operator|-
name|radj
operator|)
decl_stmt|;
name|IF
argument_list|(
operator|*
operator|(
name|INT
operator|*
operator|)
operator|(
operator|(
operator|(
name|ADDR
operator|)
operator|&
name|u
operator|)
operator|+
name|PC
operator|+
literal|4
operator|-
name|radj
operator|)
operator|&
literal|07777
argument_list|)
operator|==
literal|0200
name|THEN
comment|/* system call, fake a stack frame */
name|tracefirst
operator|=
literal|1
expr_stmt|;
name|frame
operator|=
operator|*
operator|(
name|ADDR
operator|*
operator|)
operator|(
operator|(
operator|(
name|ADDR
operator|)
operator|&
name|u
operator|)
operator|+
name|USP
operator|-
name|radj
operator|)
operator|-
literal|4
expr_stmt|;
name|ELSE
name|frame
init|=
operator|*
operator|(
name|ADDR
operator|*
operator|)
operator|(
operator|(
operator|(
name|ADDR
operator|)
operator|&
name|u
operator|)
operator|+
name|FP
operator|-
name|radj
operator|)
decl_stmt|;
name|FI
name|argp
init|=
name|frame
operator|+
literal|4
decl_stmt|;
name|FI
endif|#
directive|endif
if|#
directive|if
operator|!
name|vax
operator|&&
operator|!
name|hp300
name|get
name|help
operator|!
endif|#
directive|endif
name|lastframe
operator|=
literal|0
expr_stmt|;
name|ntramp
operator|=
literal|0
expr_stmt|;
name|WHILE
name|cntval
operator|--
name|DO
name|char
operator|*
name|name
expr_stmt|;
name|chkerr
argument_list|()
expr_stmt|;
comment|/* if in extended pcb must be signal trampoline code */
name|IF
name|KERNOFF
operator|-
name|ctob
argument_list|(
name|UPAGES
argument_list|)
operator|<
name|callpc
name|ANDF
argument_list|(
argument|unsigned
argument_list|)
name|callpc
operator|<
name|KERNOFF
name|THEN
name|name
operator|=
literal|"sigtramp"
expr_stmt|;
name|ntramp
operator|++
expr_stmt|;
name|ELSE
name|ntramp
init|=
literal|0
decl_stmt|;
name|findsym
argument_list|(
name|callpc
argument_list|,
name|ISYM
argument_list|)
expr_stmt|;
name|IF
name|cursym
name|ANDF
operator|!
name|strcmp
argument_list|(
argument|cursym->n_un.n_name
argument_list|,
literal|"start"
argument_list|)
name|THEN
break|break;
name|FI
name|IF
name|cursym
name|THEN
name|name
init|=
name|cursym
operator|->
name|n_un
operator|.
name|n_name
decl_stmt|;
name|ELSE
name|name
init|=
literal|"?"
decl_stmt|;
name|FI
name|FI
name|printf
argument_list|(
literal|"%s("
argument_list|,
name|name
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|vax
name|narg
operator|=
name|get
argument_list|(
name|argp
argument_list|,
name|DSP
argument_list|)
expr_stmt|;
name|IF
name|narg
operator|&
operator|~
literal|0xFF
name|THEN
name|narg
operator|=
literal|0
expr_stmt|;
name|FI
endif|#
directive|endif
ifdef|#
directive|ifdef
name|hp300
name|narg
init|=
name|getnargs
argument_list|(
name|frame
argument_list|)
decl_stmt|;
endif|#
directive|endif
if|#
directive|if
operator|!
name|vax
operator|&&
operator|!
name|hp300
name|edit
name|this
name|file
name|to
name|calculate
name|arg
name|count
for|for your machine
endif|#
directive|endif
for|LOOP	IF narg==0 THEN break
empty_stmt|;
name|FI
ifdef|#
directive|ifdef
name|vax
name|printf
argument_list|(
literal|"%R"
argument_list|,
name|get
argument_list|(
name|argp
operator|+=
literal|4
argument_list|,
name|DSP
argument_list|)
argument_list|)
decl_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|hp300
name|printf
argument_list|(
literal|"%X"
argument_list|,
name|lget
argument_list|(
name|argp
operator|+=
literal|4
argument_list|,
name|DSP
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|IF
operator|--
name|narg
operator|!=
literal|0
name|THEN
name|printc
argument_list|(
literal|','
argument_list|)
expr_stmt|;
name|FI
name|POOL
ifdef|#
directive|ifdef
name|vax
name|IF
name|ntramp
operator|==
literal|1
name|THEN
name|callpc
operator|=
name|get
argument_list|(
name|frame
operator|+
literal|92
argument_list|,
name|DSP
argument_list|)
expr_stmt|;
name|ELSE
name|callpc
init|=
name|get
argument_list|(
name|frame
operator|+
literal|16
argument_list|,
name|DSP
argument_list|)
decl_stmt|;
name|FI
endif|#
directive|endif
ifdef|#
directive|ifdef
name|hp300
name|callpc
init|=
name|lget
argument_list|(
name|frame
operator|+
literal|4
argument_list|,
name|DSP
argument_list|)
decl_stmt|;
endif|#
directive|endif
name|IF
name|callpc
operator|!=
literal|0
name|THEN
name|prints
argument_list|(
literal|") from "
argument_list|)
expr_stmt|;
name|psymoff
argument_list|(
name|callpc
argument_list|,
name|ISYM
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|ELSE
name|prints
argument_list|(
literal|")\n"
argument_list|)
decl_stmt|;
name|FI
name|IF
name|modif
operator|==
literal|'C'
name|THEN
name|WHILE
name|localsym
argument_list|(
argument|frame
argument_list|,
argument|argp
argument_list|)
name|DO
name|word
operator|=
name|get
argument_list|(
name|localval
argument_list|,
name|DSP
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%8t%s:%10t"
argument_list|,
name|cursym
operator|->
name|n_un
operator|.
name|n_name
argument_list|)
expr_stmt|;
name|IF
name|errflg
name|THEN
name|prints
argument_list|(
literal|"?\n"
argument_list|)
decl_stmt|;
name|errflg
operator|=
literal|0
expr_stmt|;
name|ELSE
name|printf
argument_list|(
literal|"%R\n"
argument_list|,
name|word
argument_list|)
decl_stmt|;
name|FI
name|OD
name|FI
ifdef|#
directive|ifdef
name|vax
name|argp
init|=
name|get
argument_list|(
name|frame
operator|+
literal|8
argument_list|,
name|DSP
argument_list|)
decl_stmt|;
name|lastframe
operator|=
name|frame
expr_stmt|;
name|frame
operator|=
name|get
argument_list|(
name|frame
operator|+
literal|12
argument_list|,
name|DSP
argument_list|)
operator|&
name|EVEN
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|hp300
name|lastframe
operator|=
name|frame
expr_stmt|;
name|IF
name|tracefirst
name|THEN
name|tracefirst
init|=
literal|0
decl_stmt|;
name|frame
operator|=
operator|*
operator|(
name|ADDR
operator|*
operator|)
operator|(
operator|(
operator|(
name|ADDR
operator|)
operator|&
name|u
operator|)
operator|+
name|FP
operator|-
name|radj
operator|)
expr_stmt|;
name|ELSE
name|frame
init|=
name|lget
argument_list|(
name|frame
argument_list|,
name|DSP
argument_list|)
decl_stmt|;
name|FI
name|argp
init|=
name|frame
operator|+
literal|4
decl_stmt|;
endif|#
directive|endif
name|IF
name|frame
operator|==
literal|0
name|THEN
break|break;
name|FI
name|IF
operator|!
name|adrflg
name|ANDF
operator|!
name|INSTACK
argument_list|(
argument|frame
argument_list|)
name|THEN
name|IF
operator|!
name|kcore
name|ORF
operator|!
name|kstackaddr
argument_list|(
argument|frame
argument_list|)
name|THEN
break|break;
name|FI
name|FI
name|OD
break|break;
comment|/*print externals*/
case|case
literal|'e'
case|:
case|case
literal|'E'
case|:
name|FOR
name|sp
init|=
name|symtab
decl_stmt|;
name|sp
operator|<
name|esymtab
expr_stmt|;
name|sp
operator|++
name|DO
name|IF
name|sp
operator|->
name|n_type
operator|==
operator|(
name|N_DATA
operator||
name|N_EXT
operator|)
name|ORF
name|sp
operator|->
name|n_type
operator|==
operator|(
name|N_BSS
operator||
name|N_EXT
operator|)
name|THEN
name|printf
argument_list|(
literal|"%s:%12t%R\n"
argument_list|,
name|sp
operator|->
name|n_un
operator|.
name|n_name
argument_list|,
name|get
argument_list|(
name|sp
operator|->
name|n_value
argument_list|,
name|DSP
argument_list|)
argument_list|)
expr_stmt|;
name|FI
name|OD
break|break;
case|case
literal|'a'
case|:
case|case
literal|'A'
case|:
name|error
argument_list|(
literal|"No algol 68 on VAX"
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
comment|/*print breakpoints*/
case|case
literal|'b'
case|:
case|case
literal|'B'
case|:
name|printf
argument_list|(
literal|"breakpoints\ncount%8tbkpt%24tcommand\n"
argument_list|)
expr_stmt|;
name|FOR
name|bkptr
init|=
name|bkpthead
decl_stmt|;
name|bkptr
expr_stmt|;
name|bkptr
operator|=
name|bkptr
operator|->
name|nxtbkpt
name|DO
name|IF
name|bkptr
operator|->
name|flag
name|THEN
name|printf
argument_list|(
literal|"%-8.8d"
argument_list|,
name|bkptr
operator|->
name|count
argument_list|)
expr_stmt|;
name|psymoff
argument_list|(
operator|(
name|long
operator|)
name|bkptr
operator|->
name|loc
argument_list|,
name|ISYM
argument_list|,
literal|"%24t"
argument_list|)
expr_stmt|;
name|comptr
operator|=
name|bkptr
operator|->
name|comm
expr_stmt|;
name|WHILE
modifier|*
name|comptr
name|DO
name|printc
argument_list|(
operator|*
name|comptr
operator|++
argument_list|)
decl_stmt|;
name|OD
name|FI
name|OD
break|break;
default|default:
name|error
argument_list|(
name|BADMOD
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|hp300
end_ifdef

begin_define
define|#
directive|define
name|ADDQ
value|0x500f
end_define

begin_define
define|#
directive|define
name|ADDL
value|0xd1fc
end_define

begin_define
define|#
directive|define
name|ADDW
value|0xd0fc
end_define

begin_define
define|#
directive|define
name|LEA
value|0x4fef
end_define

begin_macro
name|getnargs
argument_list|(
argument|fp
argument_list|)
end_macro

begin_decl_stmt
name|ADDR
name|fp
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|narg
decl_stmt|;
name|ADDR
name|rtn
init|=
name|lget
argument_list|(
name|fp
operator|+
literal|4
argument_list|,
name|DSP
argument_list|)
decl_stmt|;
name|unsigned
name|inst
init|=
name|get
argument_list|(
name|rtn
argument_list|,
name|ISP
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|inst
operator|&
literal|0xf13f
operator|)
operator|==
name|ADDQ
condition|)
block|{
name|narg
operator|=
operator|(
name|inst
operator|>>
literal|9
operator|)
operator|&
literal|07
expr_stmt|;
if|if
condition|(
name|narg
operator|==
literal|0
condition|)
name|narg
operator|=
literal|8
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|inst
operator|&
literal|0xf1fc
operator|)
operator|==
name|ADDL
condition|)
name|narg
operator|=
name|lget
argument_list|(
name|rtn
operator|+
literal|2
argument_list|,
name|ISP
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|inst
operator|&
literal|0xf1fc
operator|)
operator|==
name|ADDW
condition|)
name|narg
operator|=
name|get
argument_list|(
name|rtn
operator|+
literal|2
argument_list|,
name|ISP
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|inst
operator|==
name|LEA
condition|)
name|narg
operator|=
name|get
argument_list|(
name|rtn
operator|+
literal|2
argument_list|,
name|ISP
argument_list|)
expr_stmt|;
else|else
name|narg
operator|=
literal|0
expr_stmt|;
name|narg
operator|>>=
literal|2
expr_stmt|;
return|return
name|narg
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_macro
name|printmap
argument_list|(
argument|s
argument_list|,
argument|amap
argument_list|)
end_macro

begin_decl_stmt
name|STRING
name|s
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|MAP
modifier|*
name|amap
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|file
decl_stmt|;
name|file
operator|=
name|amap
operator|->
name|ufd
expr_stmt|;
name|printf
argument_list|(
literal|"%s%12t`%s'\n"
argument_list|,
name|s
argument_list|,
operator|(
name|file
operator|<
literal|0
condition|?
literal|"-"
else|:
operator|(
name|file
operator|==
name|fcor
condition|?
name|corfil
else|:
name|symfil
operator|)
operator|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"b1 = %-16R"
argument_list|,
name|amap
operator|->
name|b1
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"e1 = %-16R"
argument_list|,
name|amap
operator|->
name|e1
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"f1 = %-16R"
argument_list|,
name|amap
operator|->
name|f1
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\nb2 = %-16R"
argument_list|,
name|amap
operator|->
name|b2
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"e2 = %-16R"
argument_list|,
name|amap
operator|->
name|e2
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"f2 = %-16R"
argument_list|,
name|amap
operator|->
name|f2
argument_list|)
expr_stmt|;
name|printc
argument_list|(
name|EOR
argument_list|)
expr_stmt|;
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|hp300
end_ifdef

begin_comment
comment|/* convert 68881 extended precision to double precision */
end_comment

begin_function
name|double
name|xptod
parameter_list|(
name|vp
parameter_list|)
name|ADDR
modifier|*
name|vp
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|__HCC__
asm|asm("mov.l	8(%a6),%a0");
asm|asm("fmov.x	(%a0),%fp0");
asm|asm("fmov.d	%fp0,-(%sp)");
asm|asm("mov.l	(%sp)+,%d0");
asm|asm("mov.l	(%sp),%d1");
asm|asm("unlk	%a6");
asm|asm("rts");
else|#
directive|else
ifdef|#
directive|ifdef
name|__GNUC__
asm|asm("movel a6@(8),a0");
asm|asm("fmovex a0@,fp0");
asm|asm("fmoved fp0,sp@-");
asm|asm("movel sp@+,d0");
asm|asm("movel sp@+,d1");
asm|asm("unlk a6");
asm|asm("rts");
else|#
directive|else
comment|/* hack -- we convert to single precision */
asm|asm("movl	a6@(8),a0");
asm|asm(".word	0xf210");
comment|/* fmovx a0@,fp0 */
asm|asm(".word	0x4800");
asm|asm(".word	0xf200");
comment|/* fmovf fp0,d0 */
asm|asm(".word	0x6400");
asm|asm("clrl	d1");
asm|asm("unlk	a6");
asm|asm("rts");
endif|#
directive|endif
endif|#
directive|endif
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_macro
name|printregs
argument_list|()
end_macro

begin_block
block|{
name|REG
name|REGPTR
name|p
decl_stmt|;
name|ADDR
modifier|*
name|vp
decl_stmt|;
name|L_INT
name|radj
init|=
name|getradj
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|L_INT
name|offset
decl_stmt|;
name|FOR
name|p
init|=
name|reglist
decl_stmt|;
name|p
operator|<
operator|&
name|reglist
index|[
name|nregs
index|]
expr_stmt|;
name|p
operator|++
name|DO
name|IF
name|kcore
name|THEN
name|IF
operator|!
name|p
operator|->
name|rkern
name|THEN
continue|continue;
name|FI
name|vp
init|=
name|p
operator|->
name|rkern
decl_stmt|;
name|ELSE
name|IF
argument_list|(
name|offset
operator|=
name|p
operator|->
name|roffs
argument_list|)
decl|>= sizeof
argument_list|(
expr|struct
name|user
argument_list|)
name|THEN
name|offset
decl|-=
name|radj
decl_stmt|;
name|FI
name|vp
init|=
operator|(
name|ADDR
operator|*
operator|)
operator|(
operator|(
operator|(
name|ADDR
operator|)
operator|&
name|u
operator|)
operator|+
name|offset
operator|)
decl_stmt|;
name|FI
ifndef|#
directive|ifndef
name|hp300
name|printf
argument_list|(
literal|"%s%6t%X %16t"
argument_list|,
name|p
operator|->
name|rname
argument_list|,
operator|*
operator|(
name|L_INT
operator|*
operator|)
name|vp
argument_list|)
decl_stmt|;
name|valpr
argument_list|(
operator|*
operator|(
name|L_INT
operator|*
operator|)
name|vp
argument_list|,
operator|(
name|p
operator|->
name|roffs
operator|==
name|PC
condition|?
name|ISYM
else|:
name|DSYM
operator|)
argument_list|)
expr_stmt|;
name|printc
argument_list|(
name|EOR
argument_list|)
expr_stmt|;
else|#
directive|else
switch|switch
condition|(
name|p
operator|->
name|rtype
condition|)
block|{
case|case
name|HEXINT
case|:
name|printf
argument_list|(
literal|"%-8s%8X"
argument_list|,
name|p
operator|->
name|rname
argument_list|,
operator|*
operator|(
name|L_INT
operator|*
operator|)
name|vp
argument_list|)
expr_stmt|;
break|break;
case|case
name|HEXADDR
case|:
name|printf
argument_list|(
literal|"%-8s%8X%8t"
argument_list|,
name|p
operator|->
name|rname
argument_list|,
operator|*
operator|(
name|L_INT
operator|*
operator|)
name|vp
argument_list|)
expr_stmt|;
name|valpr
argument_list|(
operator|*
operator|(
name|L_INT
operator|*
operator|)
name|vp
argument_list|,
operator|(
name|p
operator|->
name|roffs
operator|==
name|PC
condition|?
name|ISYM
else|:
name|DSYM
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|XPFLOAT
case|:
name|printf
argument_list|(
literal|"%-8s%F"
argument_list|,
name|p
operator|->
name|rname
argument_list|,
name|xptod
argument_list|(
name|vp
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"???"
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|p
operator|->
name|rfmt
condition|)
block|{
case|case
name|FMTTAB
case|:
name|printf
argument_list|(
literal|"%8t"
argument_list|)
expr_stmt|;
break|break;
default|default:
case|case
name|FMTNL
case|:
name|printc
argument_list|(
name|EOR
argument_list|)
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
name|OD
name|printpc
parameter_list|()
function_decl|;
block|}
end_block

begin_macro
name|getreg
argument_list|(
argument|regnam
argument_list|)
end_macro

begin_block
block|{
name|REG
name|REGPTR
name|p
decl_stmt|;
name|REG
name|STRING
name|regptr
decl_stmt|;
name|CHAR
modifier|*
name|olp
decl_stmt|;
name|CHAR
name|regnxt
decl_stmt|;
name|olp
operator|=
name|lp
expr_stmt|;
name|FOR
name|p
init|=
name|reglist
decl_stmt|;
name|p
operator|<
operator|&
name|reglist
index|[
name|nregs
index|]
expr_stmt|;
name|p
operator|++
name|DO
name|IF
name|kcore
name|ANDF
operator|!
name|p
operator|->
name|rkern
name|THEN
continue|continue;
name|FI
name|regptr
init|=
name|p
operator|->
name|rname
decl_stmt|;
name|IF
argument_list|(
argument|regnam == *regptr++
argument_list|)
name|THEN
name|WHILE
modifier|*
name|regptr
name|DO
name|IF
argument_list|(
name|regnxt
operator|=
name|readchar
argument_list|()
argument_list|)
decl|!=
modifier|*
name|regptr
decl|++
name|THEN
decl|--
name|regptr
decl_stmt|;
break|break;
name|FI
name|OD
name|IF
modifier|*
name|regptr
name|THEN
name|lp
init|=
name|olp
decl_stmt|;
name|ELSE
name|IF
name|kcore
name|THEN
return|return
operator|(
operator|(
name|int
operator|)
name|p
operator|->
name|rkern
operator|)
return|;
name|FI
return|return
operator|(
name|p
operator|->
name|roffs
operator|)
return|;
name|FI
name|FI
name|OD
name|lp
init|=
name|olp
decl_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_macro
name|printpc
argument_list|()
end_macro

begin_block
block|{
ifdef|#
directive|ifdef
name|hp300
name|IF
name|kcore
name|THEN
return|return;
name|FI
comment|/* no pc in pcb */
endif|#
directive|endif
name|dot
init|=
operator|*
operator|(
name|ADDR
operator|*
operator|)
operator|(
operator|(
operator|(
name|ADDR
operator|)
operator|&
name|u
operator|)
operator|+
name|PC
operator|-
name|getradj
argument_list|(
literal|0
argument_list|)
operator|)
decl_stmt|;
name|psymoff
argument_list|(
name|dot
argument_list|,
name|ISYM
argument_list|,
literal|":%16t"
argument_list|)
expr_stmt|;
name|printins
argument_list|(
literal|0
argument_list|,
name|ISP
argument_list|,
name|chkget
argument_list|(
name|dot
argument_list|,
name|ISP
argument_list|)
argument_list|)
expr_stmt|;
name|printc
argument_list|(
name|EOR
argument_list|)
expr_stmt|;
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|vax
end_ifdef

begin_decl_stmt
name|char
modifier|*
name|illinames
index|[]
init|=
block|{
literal|"reserved addressing fault"
block|,
literal|"priviliged instruction fault"
block|,
literal|"reserved operand fault"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|fpenames
index|[]
init|=
block|{
literal|0
block|,
literal|"integer overflow trap"
block|,
literal|"integer divide by zero trap"
block|,
literal|"floating overflow trap"
block|,
literal|"floating/decimal divide by zero trap"
block|,
literal|"floating underflow trap"
block|,
literal|"decimal overflow trap"
block|,
literal|"subscript out of range trap"
block|,
literal|"floating overflow fault"
block|,
literal|"floating divide by zero fault"
block|,
literal|"floating undeflow fault"
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_macro
name|sigprint
argument_list|()
end_macro

begin_block
block|{
name|IF
argument_list|(
argument|signo>=
literal|0
argument_list|)
name|ANDF
argument_list|(
argument|signo<sizeof sys_siglist/sizeof sys_siglist[
literal|0
argument|]
argument_list|)
name|THEN
name|prints
parameter_list|(
name|sys_siglist
index|[
name|signo
index|]
parameter_list|)
function_decl|;
name|FI
ifdef|#
directive|ifdef
name|vax
switch|switch
condition|(
name|signo
condition|)
block|{
case|case
name|SIGFPE
case|:
name|IF
argument_list|(
argument|sigcode>
literal|0
argument|&& 		    sigcode< sizeof fpenames / sizeof fpenames[
literal|0
argument|]
argument_list|)
name|THEN
name|prints
argument_list|(
literal|" ("
argument_list|)
decl_stmt|;
name|prints
argument_list|(
name|fpenames
index|[
name|sigcode
index|]
argument_list|)
expr_stmt|;
name|prints
argument_list|(
literal|")"
argument_list|)
expr_stmt|;
name|FI
break|break;
case|case
name|SIGILL
case|:
name|IF
argument_list|(
argument|sigcode>=
literal|0
argument|&& 		    sigcode< sizeof illinames / sizeof illinames[
literal|0
argument|]
argument_list|)
name|THEN
name|prints
argument_list|(
literal|" ("
argument_list|)
decl_stmt|;
name|prints
argument_list|(
name|illinames
index|[
name|sigcode
index|]
argument_list|)
expr_stmt|;
name|prints
argument_list|(
literal|")"
argument_list|)
expr_stmt|;
name|FI
break|break;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|mc68000
comment|/* XXX any equivalent on 68000 boxen? */
endif|#
directive|endif
block|}
end_block

end_unit

