begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  *	Copyright (c) 1982 Regents of the University of California  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)asjxxx.c 4.7 6/30/83"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
endif|not lint
end_endif

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"as.h"
end_include

begin_include
include|#
directive|include
file|"assyms.h"
end_include

begin_define
define|#
directive|define
name|JBR
value|0x11
end_define

begin_define
define|#
directive|define
name|BRW
value|0x13
end_define

begin_define
define|#
directive|define
name|JMP
value|0x71
end_define

begin_comment
comment|/*  *	The number of bytes to add if the jxxx must be "exploded"  *	into the long form  */
end_comment

begin_define
define|#
directive|define
name|JBRDELTA
value|1
end_define

begin_comment
comment|/* brb<byte> ==> brw<byte><byte> */
end_comment

begin_define
define|#
directive|define
name|JXXXDELTA
value|3
end_define

begin_comment
comment|/* brb<byte> ==> brb<byte> brw<byte><byte> */
end_comment

begin_define
define|#
directive|define
name|JBRJDELTA
value|d124
end_define

begin_comment
comment|/* brb<byte> ==> jmp L^(pc)<byte>*d124 */
end_comment

begin_define
define|#
directive|define
name|JXXXJDELTA
value|d124+2
end_define

begin_comment
comment|/* brb<byte> ==> brb<byte> jmp L^(pc)<byte>*d124 */
end_comment

begin_decl_stmt
name|int
name|jbrfsize
init|=
name|JBRDELTA
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|jxxxfsize
init|=
name|JXXXDELTA
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  *	These variables are filled by asscan.c with the  *	last name encountered (a pointer buried in the intermediate file),  *	and the last jxxx symbol table entry encountered.  */
end_comment

begin_decl_stmt
name|struct
name|symtab
modifier|*
name|lastnam
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|symtab
modifier|*
name|lastjxxx
decl_stmt|;
end_decl_stmt

begin_macro
name|initijxxx
argument_list|()
end_macro

begin_block
block|{
name|jbrfsize
operator|=
name|jxxxJUMP
condition|?
name|JBRJDELTA
else|:
name|JBRDELTA
expr_stmt|;
name|jxxxfsize
operator|=
name|jxxxJUMP
condition|?
name|JXXXJDELTA
else|:
name|JXXXDELTA
expr_stmt|;
comment|/* 	 *	Note: ifjxxxJUMP is set, then we do NOT do any tunnelling; 	 *	this was too complicated to figure out, and in the first 	 *	version of the assembler, tunnelling proved to be the hardest 	 *	to get to work! 	 */
block|}
end_block

begin_comment
comment|/*  *	Handle jxxx instructions  */
end_comment

begin_macro
name|ijxout
argument_list|(
argument|opcode
argument_list|,
argument|ap
argument_list|,
argument|nact
argument_list|)
end_macro

begin_decl_stmt
name|u_char
name|opcode
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|arg
modifier|*
name|ap
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|nact
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|passno
operator|==
literal|1
condition|)
block|{
comment|/* 		 *	READ THIS BEFORE LOOKING AT jxxxfix() 		 * 		 *	Record the jxxx in a special symbol table entry 		 */
specifier|register
name|struct
name|symtab
modifier|*
name|jumpfrom
decl_stmt|;
comment|/* 		 *	We assume the MINIMAL length 		 */
name|putins
argument_list|(
name|opcode
argument_list|,
name|ap
argument_list|,
name|nact
argument_list|)
expr_stmt|;
name|jumpfrom
operator|=
name|lastjxxx
expr_stmt|;
name|jumpfrom
operator|->
name|s_tag
operator|=
name|JXACTIVE
expr_stmt|;
name|jumpfrom
operator|->
name|s_jxbump
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|opcode
operator|==
name|JBR
condition|)
name|jumpfrom
operator|->
name|s_jxfear
operator|=
name|jbrfsize
expr_stmt|;
else|else
name|jumpfrom
operator|->
name|s_jxfear
operator|=
name|jxxxfsize
expr_stmt|;
if|if
condition|(
name|lastnam
operator|==
literal|0
condition|)
name|yyerror
argument_list|(
literal|"jxxx destination not a label"
argument_list|)
expr_stmt|;
name|jumpfrom
operator|->
name|s_dest
operator|=
name|lastnam
expr_stmt|;
name|jumpfrom
operator|->
name|s_type
operator|=
name|dotp
operator|->
name|e_xtype
expr_stmt|;
comment|/*only TEXT or DATA*/
name|jumpfrom
operator|->
name|s_index
operator|=
name|dotp
operator|-
name|usedot
expr_stmt|;
comment|/* 		 *	value ALWAYS (ALWAYS!!!) indexes the next instruction 		 *	after the jump, even in the jump must be exploded 		 *	(bumped) 		 */
name|jumpfrom
operator|->
name|s_value
operator|=
name|dotp
operator|->
name|e_xvalue
expr_stmt|;
name|njxxx
operator|++
expr_stmt|;
block|}
else|else
block|{
comment|/* pass2, resolve */
comment|/* 		 *	READ THIS AFTER LOOKING AT jxxxfix() 		 */
name|reg
name|long
name|oxvalue
decl_stmt|;
name|reg
name|struct
name|exp
modifier|*
name|xp
decl_stmt|;
name|reg
name|struct
name|symtab
modifier|*
name|tunnel
decl_stmt|;
name|reg
name|struct
name|arg
modifier|*
name|aplast
decl_stmt|;
name|aplast
operator|=
name|ap
operator|+
name|nact
operator|-
literal|1
expr_stmt|;
name|xp
operator|=
name|aplast
operator|->
name|a_xp
expr_stmt|;
if|if
condition|(
name|lastjxxx
operator|->
name|s_tag
operator|==
name|JXTUNNEL
condition|)
block|{
name|lastjxxx
operator|->
name|s_tag
operator|=
name|JXINACTIVE
expr_stmt|;
name|tunnel
operator|=
name|lastjxxx
operator|->
name|s_dest
expr_stmt|;
name|xp
operator|->
name|e_xvalue
operator|=
name|tunnel
operator|->
name|s_value
comment|/*index of instruction following*/
operator|-
literal|3
comment|/* size of brw + word*/
operator|+
operator|(
operator|(
operator|(
name|tunnel
operator|->
name|s_jxfear
operator|==
name|jbrfsize
operator|)
operator|&&
operator|(
name|tunnel
operator|->
name|s_jxbump
operator|==
literal|0
operator|)
operator|)
condition|?
literal|1
else|:
literal|0
operator|)
expr_stmt|;
comment|/*non bumped branch byteis only 2 back*/
block|}
if|if
condition|(
name|lastjxxx
operator|->
name|s_jxbump
operator|==
literal|0
condition|)
block|{
comment|/*wasn't bumped, so is short form*/
name|putins
argument_list|(
name|opcode
argument_list|,
name|ap
argument_list|,
name|nact
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|opcode
operator|!=
name|JBR
condition|)
block|{
comment|/* 				 *	branch reverse conditional byte over 				 *	branch unconditional word 				 */
name|oxvalue
operator|=
name|xp
operator|->
name|e_xvalue
expr_stmt|;
name|xp
operator|->
name|e_xvalue
operator|=
name|lastjxxx
operator|->
name|s_value
expr_stmt|;
name|putins
argument_list|(
name|opcode
operator|^
literal|0x10
argument_list|,
name|ap
argument_list|,
name|nact
argument_list|)
expr_stmt|;
name|xp
operator|->
name|e_xvalue
operator|=
name|oxvalue
expr_stmt|;
block|}
name|putins
argument_list|(
name|jxxxJUMP
condition|?
name|JMP
else|:
name|BRW
argument_list|,
name|aplast
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_block

begin_expr_stmt
name|jalign
argument_list|(
name|xp
argument_list|,
name|sp
argument_list|)
specifier|register
expr|struct
name|exp
operator|*
name|xp
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|struct
name|symtab
modifier|*
name|sp
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|mask
decl_stmt|;
comment|/* 	 *	Problem with .align 	 * 	 *	When the loader constructs an executable file from 	 *	a number of objects, it effectively concatnates 	 *	together all of the text segments from all objects, 	 *	and then all of the data segments. 	 * 	 *	If we do an align by a large value, we can align 	 *	within the a.out this assembly produces, but 	 *	after the loader concatnates, the alignment can't 	 *	be guaranteed if the objects preceding this one 	 *	in the load are also aligned to the same size. 	 * 	 *	Currently, the loader guarantees full word alignment. 	 *	So, ridiculous aligns are caught here and converted 	 *	to a .align 2, if possible. 	 */
if|if
condition|(
operator|(
operator|(
name|xp
operator|->
name|e_xtype
operator|&
name|XTYPE
operator|)
operator|!=
name|XABS
operator|)
operator|||
operator|(
name|xp
operator|->
name|e_xvalue
operator|<
literal|0
operator|)
operator|||
operator|(
name|xp
operator|->
name|e_xvalue
operator|>
literal|16
operator|)
condition|)
block|{
name|yyerror
argument_list|(
literal|"Illegal `align' argument"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|xp
operator|->
name|e_xvalue
operator|>
literal|2
condition|)
block|{
if|if
condition|(
name|passno
operator|==
literal|1
condition|)
block|{
name|yywarning
argument_list|(
literal|".align %d is NOT preserved by the loader"
argument_list|,
name|xp
operator|->
name|e_xvalue
argument_list|)
expr_stmt|;
name|yywarning
argument_list|(
literal|".align %d converted to .align 2"
argument_list|,
name|xp
operator|->
name|e_xvalue
argument_list|)
expr_stmt|;
block|}
name|xp
operator|->
name|e_xvalue
operator|=
literal|2
expr_stmt|;
block|}
name|flushfield
argument_list|(
name|NBPW
operator|/
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|passno
operator|==
literal|1
condition|)
block|{
name|sp
operator|->
name|s_tag
operator|=
name|JXALIGN
expr_stmt|;
name|sp
operator|->
name|s_jxfear
operator|=
operator|(
literal|1
operator|<<
name|xp
operator|->
name|e_xvalue
operator|)
operator|-
literal|1
expr_stmt|;
name|sp
operator|->
name|s_type
operator|=
name|dotp
operator|->
name|e_xtype
expr_stmt|;
name|sp
operator|->
name|s_index
operator|=
name|dotp
operator|-
name|usedot
expr_stmt|;
comment|/* 		 *	We guess that the align will take up at least one 		 *	byte in the code output.  We will correct for this 		 *	initial high guess when we explode (bump) aligns 		 *	when we fix the jxxxes.  We must do this guess 		 *	so that the symbol table is sorted correctly 		 *	and labels declared to fall before the align 		 *	really get their, instead of guessing zero size 		 *	and have the label (incorrectly) fall after the jxxx. 		 *	This is a quirk of our requirement that indices into 		 *	the code stream point to the next byte following 		 *	the logical entry in the symbol table 		 */
name|dotp
operator|->
name|e_xvalue
operator|+=
literal|1
expr_stmt|;
name|sp
operator|->
name|s_value
operator|=
name|dotp
operator|->
name|e_xvalue
expr_stmt|;
name|njxxx
operator|++
expr_stmt|;
block|}
else|else
block|{
name|mask
operator|=
operator|(
literal|1
operator|<<
name|xp
operator|->
name|e_xvalue
operator|)
operator|-
literal|1
expr_stmt|;
while|while
condition|(
name|dotp
operator|->
name|e_xvalue
operator|&
name|mask
condition|)
block|{
name|Outb
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|liston
condition|)
block|{
operator|*
name|layoutpos
operator|++
operator|=
literal|'0'
expr_stmt|;
operator|*
name|layoutpos
operator|++
operator|=
literal|'0'
expr_stmt|;
block|}
block|}
block|}
block|}
end_block

begin_expr_stmt
name|djalign
argument_list|(
name|xp
argument_list|,
name|sp
argument_list|)
specifier|register
expr|struct
name|exp
operator|*
name|xp
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|struct
name|symtab
modifier|*
name|sp
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|mask
decl_stmt|;
if|if
condition|(
operator|(
operator|(
name|xp
operator|->
name|e_xtype
operator|&
name|XTYPE
operator|)
operator|!=
name|XABS
operator|)
operator|||
operator|(
name|xp
operator|->
name|e_xvalue
operator|<
literal|0
operator|)
operator|||
operator|(
name|xp
operator|->
name|e_xvalue
operator|>
literal|16
operator|)
condition|)
block|{
name|yyerror
argument_list|(
literal|"Illegal `align' argument"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|xp
operator|->
name|e_xvalue
operator|>
literal|2
condition|)
block|{
if|if
condition|(
name|passno
operator|==
literal|1
condition|)
block|{
name|yywarning
argument_list|(
literal|".align %d is NOT preserved by the loader"
argument_list|,
name|xp
operator|->
name|e_xvalue
argument_list|)
expr_stmt|;
name|yywarning
argument_list|(
literal|".align %d converted to .align 2"
argument_list|,
name|xp
operator|->
name|e_xvalue
argument_list|)
expr_stmt|;
block|}
name|xp
operator|->
name|e_xvalue
operator|=
literal|2
expr_stmt|;
block|}
name|flushfield
argument_list|(
name|NBPW
operator|/
literal|4
argument_list|)
expr_stmt|;
name|mask
operator|=
operator|(
literal|1
operator|<<
name|xp
operator|->
name|e_xvalue
operator|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|passno
operator|==
literal|1
condition|)
block|{
name|sp
operator|->
name|s_tag
operator|=
name|JXALIGN
expr_stmt|;
name|sp
operator|->
name|s_jxfear
operator|=
operator|(
literal|1
operator|<<
name|xp
operator|->
name|e_xvalue
operator|)
operator|-
literal|1
expr_stmt|;
name|sp
operator|->
name|s_type
operator|=
name|dotp
operator|->
name|e_xtype
expr_stmt|;
name|sp
operator|->
name|s_index
operator|=
name|dotp
operator|-
name|usedot
expr_stmt|;
while|while
condition|(
name|dotp
operator|->
name|e_xvalue
operator|&
name|mask
condition|)
name|dotp
operator|->
name|e_xvalue
operator|++
expr_stmt|;
name|sp
operator|->
name|s_value
operator|=
name|dotp
operator|->
name|e_xvalue
expr_stmt|;
name|njxxx
operator|++
expr_stmt|;
block|}
else|else
block|{
while|while
condition|(
name|dotp
operator|->
name|e_xvalue
operator|&
name|mask
condition|)
block|{
name|Outb
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|liston
condition|)
block|{
operator|*
name|layoutpos
operator|++
operator|=
literal|'0'
expr_stmt|;
operator|*
name|layoutpos
operator|++
operator|=
literal|'0'
expr_stmt|;
block|}
block|}
block|}
block|}
end_block

begin_comment
comment|/*  *	Pass 1.5, resolve jxxx instructions and .align in .text  */
end_comment

begin_macro
name|jxxxfix
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|struct
name|symtab
modifier|*
name|jumpfrom
decl_stmt|;
name|struct
name|symtab
modifier|*
modifier|*
name|cojumpfrom
decl_stmt|,
modifier|*
name|ubjumpfrom
decl_stmt|;
specifier|register
name|struct
name|symtab
modifier|*
name|dest
decl_stmt|;
specifier|register
name|struct
name|symtab
modifier|*
name|intdest
decl_stmt|;
comment|/*intermediate dest*/
specifier|register
name|struct
name|symtab
modifier|*
modifier|*
name|cointdest
decl_stmt|,
modifier|*
name|ubintdest
decl_stmt|;
specifier|register
name|struct
name|symtab
modifier|*
name|tunnel
decl_stmt|;
name|int
name|displ
decl_stmt|,
name|nchange
decl_stmt|;
name|int
name|badjxalign
decl_stmt|;
comment|/*if jump across an align*/
name|int
name|stillactives
decl_stmt|;
comment|/*if still active jxxxes*/
name|int
name|segno
decl_stmt|;
comment|/*current segment number*/
name|int
name|topono
decl_stmt|;
comment|/*which iteration in the topo sort*/
specifier|register
name|unsigned
name|char
name|tag
decl_stmt|;
comment|/* 	 *	consider each segment in turn... 	 */
for|for
control|(
name|segno
operator|=
literal|0
init|;
name|segno
operator|<
name|NLOC
operator|+
name|NLOC
condition|;
name|segno
operator|++
control|)
block|{
name|badjxalign
operator|=
literal|0
expr_stmt|;
comment|/*done on a per segment basis*/
comment|/* 	     *	Do a lazy topological sort. 	     */
for|for
control|(
name|topono
operator|=
literal|1
operator|,
name|nchange
operator|=
literal|1
init|;
name|nchange
operator|!=
literal|0
condition|;
name|topono
operator|++
control|)
block|{
ifdef|#
directive|ifdef
name|lint
name|topno
operator|=
name|topno
expr_stmt|;
endif|#
directive|endif
endif|lint
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"\nSegment %d, topo iteration %d\n"
argument_list|,
name|segno
argument_list|,
name|topono
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|nchange
operator|=
literal|0
expr_stmt|;
name|stillactives
operator|=
literal|0
expr_stmt|;
comment|/* 		 *	We keep track of one possible tunnel location. 		 *	A tunnel will eventually be an unconditional 		 *	branch to the same place that another jxxx 		 *	will want to branch to.  We will turn a 		 *	branch conditional/unconditional (word) that would 		 *	have to get bumped because its destination is too 		 *	far away, into a branch conditional/unconditional 		 *	byte to the tunnel branch conditional/unconditional. 		 *	Of course, the tunnel must branch to the same place 		 *	as we want to go. 		 */
name|tunnel
operator|=
literal|0
expr_stmt|;
comment|/*initially, no tunnel*/
name|SEGITERATE
argument_list|(
argument|segno
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
argument|cojumpfrom
argument_list|,
argument|jumpfrom
argument_list|,
argument|ubjumpfrom
argument_list|,
argument|++
argument_list|)
block|{
name|tag
operator|=
name|jumpfrom
operator|->
name|s_tag
expr_stmt|;
if|if
condition|(
name|tag
operator|<=
name|IGNOREBOUND
condition|)
continue|continue;
comment|/*just an ordinary symbol*/
if|if
condition|(
name|tag
operator|==
name|JXALIGN
condition|)
block|{
name|tunnel
operator|=
literal|0
expr_stmt|;
comment|/*avoid tunneling across a flex alocation*/
continue|continue;
comment|/*we take care of these later*/
block|}
if|if
condition|(
name|jumpfrom
operator|->
name|s_jxfear
operator|==
name|jbrfsize
comment|/*unconditional*/
operator|||
operator|(
name|tag
operator|==
name|JXINACTIVE
comment|/*inactive bumped*/
operator|&&
operator|(
name|jumpfrom
operator|->
name|s_jxbump
operator|!=
literal|0
operator|)
operator|)
condition|)
name|tunnel
operator|=
name|jumpfrom
expr_stmt|;
if|if
condition|(
name|tag
operator|!=
name|JXACTIVE
condition|)
continue|continue;
name|dest
operator|=
name|jumpfrom
operator|->
name|s_dest
expr_stmt|;
if|if
condition|(
name|jumpfrom
operator|->
name|s_index
operator|!=
name|dest
operator|->
name|s_index
condition|)
block|{
name|yyerror
argument_list|(
literal|"Intersegment jxxx"
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|displ
operator|=
name|dest
operator|->
name|s_value
operator|-
name|jumpfrom
operator|->
name|s_value
expr_stmt|;
if|if
condition|(
name|displ
operator|<
name|MINBYTE
operator|||
name|displ
operator|>
name|MAXBYTE
condition|)
block|{
comment|/* 				 *	This is an immediate lose! 				 * 				 *	We first attempt to tunnel 				 *	by finding an intervening jump that 				 *	has  the same destination. 				 *	The tunnel is always the first preceeding 				 *	jxxx instruction, so the displacement 				 *	to the tunnel is less than zero, and 				 *	its relative position will be unaffected 				 *	by future jxxx expansions. 				 * 				 *	No tunnels if doing jumps... 				 */
if|if
condition|(
operator|(
operator|!
name|jxxxJUMP
operator|)
operator|&&
operator|(
name|jumpfrom
operator|->
name|s_jxfear
operator|>
name|jbrfsize
operator|)
operator|&&
operator|(
name|tunnel
operator|)
operator|&&
operator|(
name|tunnel
operator|->
name|s_dest
operator|==
name|jumpfrom
operator|->
name|s_dest
operator|)
operator|&&
operator|(
name|tunnel
operator|->
name|s_index
operator|==
name|jumpfrom
operator|->
name|s_index
operator|)
operator|&&
operator|(
name|tunnel
operator|->
name|s_value
operator|-
name|jumpfrom
operator|->
name|s_value
operator|>=
name|MINBYTE
operator|+
name|jxxxfsize
operator|)
condition|)
block|{
comment|/* 						 *	tunnelling is OK 						 */
name|jumpfrom
operator|->
name|s_dest
operator|=
name|tunnel
expr_stmt|;
comment|/* 						 * no bumping needed, this 						 * is now effectively inactive 						 * but must be remembered 						 */
name|jumpfrom
operator|->
name|s_tag
operator|=
name|JXTUNNEL
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"Tunnel from %s from line %d\n"
argument_list|,
name|FETCHNAME
argument_list|(
name|jumpfrom
argument_list|)
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
endif|#
directive|endif
continue|continue;
block|}
else|else
block|{
comment|/*tunneling not possible*/
comment|/* 					 *	since this will be turned 					 *	into a bumped jump, we can 					 *	use the unconditional jump 					 *	as a tunnel 					 */
name|tunnel
operator|=
name|jumpfrom
expr_stmt|;
name|jumpfrom
operator|->
name|s_tag
operator|=
name|JXNOTYET
expr_stmt|;
operator|++
name|nchange
expr_stmt|;
continue|continue;
block|}
block|}
comment|/*end of immediate lose*/
comment|/* 			 *	Do a forward search for an intervening jxxx 			 */
if|if
condition|(
name|displ
operator|>=
literal|0
condition|)
block|{
name|SEGITERATE
argument_list|(
argument|segno
argument_list|,
argument|cojumpfrom +
literal|1
argument_list|,
literal|0
argument_list|,
argument|cointdest
argument_list|,
argument|intdest
argument_list|,
argument|ubintdest
argument_list|,
argument|++
argument_list|)
block|{
if|if
condition|(
name|intdest
operator|->
name|s_value
operator|>
name|dest
operator|->
name|s_value
condition|)
break|break;
comment|/* beyond destination */
if|if
condition|(
name|intdest
operator|->
name|s_tag
operator|<=
name|JXQUESTIONABLE
condition|)
continue|continue;
comment|/*frozen solid*/
if|if
condition|(
name|intdest
operator|->
name|s_tag
operator|==
name|JXALIGN
condition|)
block|{
name|jumpfrom
operator|->
name|s_jxoveralign
operator|=
literal|1
expr_stmt|;
name|badjxalign
operator|++
expr_stmt|;
block|}
comment|/* 					 *	we assume the worst case 					 *	for unfrozen jxxxxes 					 */
name|displ
operator|+=
name|intdest
operator|->
name|s_jxfear
expr_stmt|;
block|}
if|if
condition|(
name|displ
operator|<=
name|MAXBYTE
condition|)
block|{
comment|/* 					 *	the worst possible conditions 					 *	can't hurt us, so forget about 					 *	this jump 					 */
name|jumpfrom
operator|->
name|s_tag
operator|=
name|JXINACTIVE
expr_stmt|;
block|}
else|else
block|{
name|stillactives
operator|++
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 			 *	backward search for intervening jxxx 			 */
name|SEGITERATE
argument_list|(
argument|segno
argument_list|,
argument|cojumpfrom -
literal|1
argument_list|,
literal|1
argument_list|,
argument|cointdest
argument_list|,
argument|intdest
argument_list|,
argument|ubintdest
argument_list|,
argument|--
argument_list|)
block|{
if|if
condition|(
name|intdest
operator|->
name|s_value
operator|<=
name|dest
operator|->
name|s_value
condition|)
break|break;
comment|/* beyond destination */
if|if
condition|(
name|intdest
operator|->
name|s_tag
operator|<=
name|JXQUESTIONABLE
condition|)
continue|continue;
comment|/*frozen solid*/
if|if
condition|(
name|intdest
operator|->
name|s_tag
operator|==
name|JXALIGN
condition|)
block|{
name|jumpfrom
operator|->
name|s_jxoveralign
operator|=
literal|1
expr_stmt|;
name|badjxalign
operator|++
expr_stmt|;
block|}
name|displ
operator|-=
name|intdest
operator|->
name|s_jxfear
expr_stmt|;
block|}
if|if
condition|(
name|displ
operator|>=
name|MINBYTE
condition|)
block|{
name|jumpfrom
operator|->
name|s_tag
operator|=
name|JXINACTIVE
expr_stmt|;
block|}
else|else
block|{
name|stillactives
operator|++
expr_stmt|;
block|}
block|}
comment|/*end of backwards search*/
block|}
comment|/*end of iterating through all symbols in this seg*/
if|if
condition|(
name|nchange
operator|==
literal|0
condition|)
block|{
comment|/* 			 *	Now, if there are still active jxxx entries, 			 *	we are partially deadlocked.  We can leave 			 *	these jxxx entries in their assumed short jump 			 *	form, as all initial displacement calcualtions 			 *	are hanging on unresolved jxxx instructions 			 *	that might explode into a long form, causing 			 *	other jxxxes jumping across the first set of 			 *	jxxxes to explode, etc. 			 *	However, if a jxxx jumps across a .align, 			 *	we assume the worst for the deadlock cycle, 			 *	and resolve all of them towards the long 			 *	jump. 			 *	Currently, the C compiler does not produce 			 *	jumps across aligns, as aligns are only used 			 *	in data segments, or in text segments to align 			 *	functions. 			 */
if|if
condition|(
name|stillactives
condition|)
block|{
name|SEGITERATE
argument_list|(
argument|segno
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
argument|cojumpfrom
argument_list|,
argument|jumpfrom
argument_list|,
argument|ubjumpfrom
argument_list|,
argument|++
argument_list|)
block|{
if|if
condition|(
name|jumpfrom
operator|->
name|s_tag
operator|==
name|JXACTIVE
condition|)
block|{
name|jumpfrom
operator|->
name|s_tag
operator|=
name|badjxalign
condition|?
name|JXNOTYET
else|:
name|JXINACTIVE
expr_stmt|;
block|}
block|}
if|if
condition|(
name|badjxalign
condition|)
block|{
name|jxxxbump
argument_list|(
name|segno
argument_list|,
operator|(
expr|struct
name|symtab
operator|*
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 			 *	Handle  all of the .align s 			 */
name|SEGITERATE
argument_list|(
argument|segno
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
argument|cojumpfrom
argument_list|,
argument|jumpfrom
argument_list|,
argument|ubjumpfrom
argument_list|,
argument|++
argument_list|)
block|{
if|if
condition|(
name|jumpfrom
operator|->
name|s_tag
operator|==
name|JXALIGN
condition|)
block|{
comment|/* 				 *	Predict the true displacement 				 *	needed, irregardless of the 				 *	fact that we guessed 1 				 */
name|displ
operator|=
operator|(
name|jumpfrom
operator|->
name|s_value
operator|-
literal|1
operator|)
operator|&
operator|(
name|unsigned
operator|)
name|jumpfrom
operator|->
name|s_jxfear
expr_stmt|;
if|if
condition|(
name|displ
operator|==
literal|0
condition|)
block|{
comment|/*no virtual displacement*/
name|jumpfrom
operator|->
name|s_jxfear
operator|=
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|jumpfrom
operator|->
name|s_jxfear
operator|=
operator|(
name|jumpfrom
operator|->
name|s_jxfear
operator|+
literal|1
operator|)
operator|-
name|displ
expr_stmt|;
comment|/* 					 *	assert jumpfrom->s_jxfear> 0 					 */
if|if
condition|(
name|jumpfrom
operator|->
name|s_jxfear
operator|==
literal|1
condition|)
block|{
comment|/*our prediction was correct*/
continue|continue;
block|}
comment|/* 					 *	assert jumpfrom->s_jxfear> 1 					 */
name|jumpfrom
operator|->
name|s_jxfear
operator|-=
literal|1
expr_stmt|;
comment|/*correct guess*/
block|}
comment|/* 				 *	assert jumpfrom->s_jxfear = -1, +1...2**n-1 				 */
name|jumpfrom
operator|->
name|s_tag
operator|=
name|JXNOTYET
expr_stmt|;
comment|/*signal*/
name|jxxxbump
argument_list|(
name|segno
argument_list|,
name|cojumpfrom
argument_list|)
expr_stmt|;
name|jumpfrom
operator|->
name|s_tag
operator|=
name|JXINACTIVE
expr_stmt|;
comment|/* 				 *	Assert jxfrom->jxvalue indexes the first 				 *	code byte after the added bytes, and 				 *	has n low order zeroes. 				 */
block|}
block|}
comment|/*end of walking through each segment*/
block|}
comment|/*end of no changes */
else|else
block|{
comment|/*changes, and still have to try another pass*/
name|jxxxbump
argument_list|(
name|segno
argument_list|,
operator|(
expr|struct
name|symtab
operator|*
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*end of doing the topologic sort*/
block|}
comment|/*end of iterating through all segments*/
block|}
end_block

begin_comment
comment|/*end of jxxxfix*/
end_comment

begin_comment
comment|/*  *	Go through the symbols in a given segment number,  *	and see which entries are jxxx entries that have  *	been logically "exploded" (expanded), but for which  *	the value of textually following symbols has not been  *	increased  */
end_comment

begin_macro
name|jxxxbump
argument_list|(
argument|segno
argument_list|,
argument|starthint
argument_list|)
end_macro

begin_decl_stmt
name|int
name|segno
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|symtab
modifier|*
modifier|*
name|starthint
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|symtab
modifier|*
modifier|*
name|cosp
decl_stmt|,
modifier|*
name|sp
decl_stmt|;
specifier|register
name|struct
name|symtab
modifier|*
name|ub
decl_stmt|;
specifier|register
name|int
name|cum_bump
decl_stmt|;
specifier|register
name|unsigned
name|char
name|tag
decl_stmt|;
name|cum_bump
operator|=
literal|0
expr_stmt|;
name|SEGITERATE
argument_list|(
argument|segno
argument_list|,
argument|starthint
argument_list|,
literal|0
argument_list|,
argument|cosp
argument_list|,
argument|sp
argument_list|,
argument|ub
argument_list|,
argument|++
argument_list|)
block|{
name|tag
operator|=
name|sp
operator|->
name|s_tag
expr_stmt|;
if|if
condition|(
name|tag
operator|==
name|JXNOTYET
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
block|{
if|if
condition|(
name|sp
operator|->
name|s_dest
operator|!=
literal|0
condition|)
name|printf
argument_list|(
literal|"Explode jump to %s on line %d\n"
argument_list|,
name|FETCHNAME
argument_list|(
name|sp
operator|->
name|s_dest
argument_list|)
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"Explode an align!\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|sp
operator|->
name|s_tag
operator|=
name|JXINACTIVE
expr_stmt|;
name|sp
operator|->
name|s_jxbump
operator|=
literal|1
expr_stmt|;
name|cum_bump
operator|+=
name|sp
operator|->
name|s_jxfear
expr_stmt|;
block|}
comment|/* 		 *	Only bump labels and jxxxes. Ignored entries can 		 *	be incremented, as they are thrown away later on. 		 *	Stabds are given their final value in the second  		 *	pass. 		 */
if|if
condition|(
name|tag
operator|>=
name|OKTOBUMP
condition|)
comment|/*only bump labels and jxxxes and floating stabs*/
name|sp
operator|->
name|s_value
operator|+=
name|cum_bump
expr_stmt|;
block|}
name|usedot
index|[
name|segno
index|]
operator|.
name|e_xvalue
operator|+=
name|cum_bump
expr_stmt|;
block|}
end_block

end_unit

