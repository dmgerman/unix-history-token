begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1980 Regents of the University of California.  * All rights reserved.  The Berkeley software License Agreement  * specifies the terms and conditions for redistribution.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
name|char
name|copyright
index|[]
init|=
literal|"@(#) Copyright (c) 1980 Regents of the University of California.\n\  All rights reserved.\n"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
endif|not lint
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)analyze.c	5.2 (Berkeley) 5/14/86"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
endif|not lint
end_endif

begin_comment
comment|/*  * Analyze - analyze a core (and optional paging area) saved from  * a virtual Unix system crash.  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/dir.h>
end_include

begin_include
include|#
directive|include
file|<machine/pte.h>
end_include

begin_include
include|#
directive|include
file|<nlist.h>
end_include

begin_include
include|#
directive|include
file|<sys/map.h>
end_include

begin_include
include|#
directive|include
file|<sys/user.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/text.h>
end_include

begin_include
include|#
directive|include
file|<sys/cmap.h>
end_include

begin_include
include|#
directive|include
file|<sys/vm.h>
end_include

begin_decl_stmt
name|int
name|Dflg
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|dflg
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|vflg
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|mflg
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|fflg
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|sflg
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|uflg
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* use vprintf with care; it plays havoc with ``else's'' */
end_comment

begin_define
define|#
directive|define
name|vprintf
value|if (vflg) printf
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|vax
end_ifdef

begin_define
define|#
directive|define
name|clear
parameter_list|(
name|x
parameter_list|)
value|((int)x& 0x7fffffff)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|clear
parameter_list|(
name|x
parameter_list|)
value|((int)x)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|struct
name|proc
modifier|*
name|proc
decl_stmt|,
modifier|*
name|aproc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|nproc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|text
modifier|*
name|text
decl_stmt|,
modifier|*
name|atext
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|ntext
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|mapent
modifier|*
name|swapmap
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|nswapmap
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|dmmin
decl_stmt|,
name|dmmax
decl_stmt|,
name|dmtext
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|cmap
modifier|*
name|cmap
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|ecmx
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|pte
modifier|*
name|usrpt
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|pte
modifier|*
name|Usrptma
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|firstfree
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|maxfree
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|freemem
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|pte
name|p0br
index|[
name|ctopt
argument_list|(
name|btoc
argument_list|(
name|MAXTSIZ
operator|+
name|MAXDSIZ
operator|+
name|MAXSSIZ
argument_list|)
argument_list|)
index|]
index|[
name|NPTEPG
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|pid
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|paginfo
block|{
name|char
name|z_type
decl_stmt|;
name|char
name|z_count
decl_stmt|;
name|short
name|z_pid
decl_stmt|;
name|struct
name|pte
name|z_pte
decl_stmt|;
block|}
modifier|*
name|paginfo
struct|;
end_struct

begin_define
define|#
directive|define
name|ZLOST
value|0
end_define

begin_define
define|#
directive|define
name|ZDATA
value|1
end_define

begin_define
define|#
directive|define
name|ZSTACK
value|2
end_define

begin_define
define|#
directive|define
name|ZUDOT
value|3
end_define

begin_define
define|#
directive|define
name|ZPAGET
value|4
end_define

begin_define
define|#
directive|define
name|ZTEXT
value|5
end_define

begin_define
define|#
directive|define
name|ZFREE
value|6
end_define

begin_define
define|#
directive|define
name|ZINTRAN
value|7
end_define

begin_struct
struct|struct
name|dblks
block|{
name|short
name|d_first
decl_stmt|;
name|short
name|d_size
decl_stmt|;
name|char
name|d_type
decl_stmt|;
name|char
name|d_index
decl_stmt|;
block|}
modifier|*
name|dblks
struct|;
end_struct

begin_decl_stmt
name|int
name|ndblks
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|DFREE
value|0
end_define

begin_define
define|#
directive|define
name|DDATA
value|1
end_define

begin_define
define|#
directive|define
name|DSTACK
value|2
end_define

begin_define
define|#
directive|define
name|DTEXT
value|3
end_define

begin_define
define|#
directive|define
name|DUDOT
value|4
end_define

begin_define
define|#
directive|define
name|DPAGET
value|5
end_define

begin_union
union|union
block|{
name|char
name|buf
index|[
name|UPAGES
index|]
index|[
name|NBPG
index|]
decl_stmt|;
name|struct
name|user
name|U
decl_stmt|;
block|}
name|u_area
union|;
end_union

begin_define
define|#
directive|define
name|u
value|u_area.U
end_define

begin_decl_stmt
name|int
name|fcore
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|fswap
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|nlist
name|nl
index|[]
init|=
block|{
define|#
directive|define
name|X_PROC
value|0
block|{
literal|"_proc"
block|}
block|,
define|#
directive|define
name|X_USRPT
value|1
block|{
literal|"_usrpt"
block|}
block|,
define|#
directive|define
name|X_PTMA
value|2
block|{
literal|"_Usrptmap"
block|}
block|,
define|#
directive|define
name|X_FIRSTFREE
value|3
block|{
literal|"_firstfree"
block|}
block|,
define|#
directive|define
name|X_MAXFREE
value|4
block|{
literal|"_maxfree"
block|}
block|,
define|#
directive|define
name|X_TEXT
value|5
block|{
literal|"_text"
block|}
block|,
define|#
directive|define
name|X_FREEMEM
value|6
block|{
literal|"_freemem"
block|}
block|,
define|#
directive|define
name|X_CMAP
value|7
block|{
literal|"_cmap"
block|}
block|,
define|#
directive|define
name|X_ECMAP
value|8
block|{
literal|"_ecmap"
block|}
block|,
define|#
directive|define
name|X_SWAPMAP
value|9
block|{
literal|"_swapmap"
block|}
block|,
define|#
directive|define
name|X_NPROC
value|10
block|{
literal|"_nproc"
block|}
block|,
define|#
directive|define
name|X_NTEXT
value|11
block|{
literal|"_ntext"
block|}
block|,
define|#
directive|define
name|X_NSWAPMAP
value|12
block|{
literal|"_nswapmap"
block|}
block|,
define|#
directive|define
name|X_DMMIN
value|13
block|{
literal|"_dmmin"
block|}
block|,
define|#
directive|define
name|X_DMMAX
value|14
block|{
literal|"_dmmax"
block|}
block|,
define|#
directive|define
name|X_DMTEXT
value|15
block|{
literal|"_dmtext"
block|}
block|,
block|{
literal|""
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
specifier|register
name|struct
name|nlist
modifier|*
name|np
decl_stmt|;
specifier|register
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
specifier|register
name|struct
name|text
modifier|*
name|xp
decl_stmt|;
specifier|register
name|struct
name|pte
modifier|*
name|pte
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|int
name|w
decl_stmt|,
name|a
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|setbuf
argument_list|(
name|stdout
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|argc
operator|--
operator|,
name|argv
operator|++
expr_stmt|;
while|while
condition|(
name|argc
operator|>
literal|0
operator|&&
name|argv
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|==
literal|'-'
condition|)
block|{
specifier|register
name|char
modifier|*
name|cp
init|=
operator|*
name|argv
operator|++
decl_stmt|;
name|argc
operator|--
expr_stmt|;
while|while
condition|(
operator|*
operator|++
name|cp
condition|)
switch|switch
condition|(
operator|*
name|cp
condition|)
block|{
case|case
literal|'m'
case|:
name|mflg
operator|++
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
name|vflg
operator|++
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
if|if
condition|(
name|argc
operator|<
literal|2
condition|)
goto|goto
name|usage
goto|;
if|if
condition|(
operator|(
name|fswap
operator|=
name|open
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|argc
operator|--
operator|,
name|argv
operator|++
expr_stmt|;
name|sflg
operator|++
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
name|fflg
operator|++
expr_stmt|;
break|break;
case|case
literal|'D'
case|:
name|Dflg
operator|++
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|dflg
operator|++
expr_stmt|;
break|break;
case|case
literal|'u'
case|:
name|uflg
operator|++
expr_stmt|;
break|break;
default|default:
goto|goto
name|usage
goto|;
block|}
block|}
if|if
condition|(
name|argc
operator|<
literal|1
condition|)
block|{
name|usage
label|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"usage: analyze [ -vmfd ] [ -s swapfile ] corefile [ system ]\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|close
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fcore
operator|=
name|open
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|nlist
argument_list|(
name|argc
operator|>
literal|1
condition|?
name|argv
index|[
literal|1
index|]
else|:
literal|"/vmunix"
argument_list|,
name|nl
argument_list|)
expr_stmt|;
if|if
condition|(
name|nl
index|[
literal|0
index|]
operator|.
name|n_value
operator|==
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: bad namelist\n"
argument_list|,
name|argc
operator|>
literal|1
condition|?
name|argv
index|[
literal|1
index|]
else|:
literal|"/vmunix"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|np
operator|=
name|nl
init|;
name|np
operator|->
name|n_name
operator|&&
operator|*
name|np
operator|->
name|n_name
condition|;
name|np
operator|++
control|)
name|vprintf
argument_list|(
literal|"%8.8s %x\n"
argument_list|,
name|np
operator|->
name|n_name
argument_list|,
name|np
operator|->
name|n_value
argument_list|)
expr_stmt|;
name|usrpt
operator|=
operator|(
expr|struct
name|pte
operator|*
operator|)
name|clear
argument_list|(
name|nl
index|[
name|X_USRPT
index|]
operator|.
name|n_value
argument_list|)
expr_stmt|;
name|Usrptma
operator|=
operator|(
expr|struct
name|pte
operator|*
operator|)
name|clear
argument_list|(
name|nl
index|[
name|X_PTMA
index|]
operator|.
name|n_value
argument_list|)
expr_stmt|;
name|firstfree
operator|=
name|get
argument_list|(
name|nl
index|[
name|X_FIRSTFREE
index|]
operator|.
name|n_value
argument_list|)
expr_stmt|;
name|maxfree
operator|=
name|get
argument_list|(
name|nl
index|[
name|X_MAXFREE
index|]
operator|.
name|n_value
argument_list|)
expr_stmt|;
name|freemem
operator|=
name|get
argument_list|(
name|nl
index|[
name|X_FREEMEM
index|]
operator|.
name|n_value
argument_list|)
expr_stmt|;
name|dmmin
operator|=
name|get
argument_list|(
name|nl
index|[
name|X_DMMIN
index|]
argument_list|)
expr_stmt|;
name|dmmax
operator|=
name|get
argument_list|(
name|nl
index|[
name|X_DMMAX
index|]
argument_list|)
expr_stmt|;
name|dmtext
operator|=
name|get
argument_list|(
name|nl
index|[
name|X_DMTEXT
index|]
argument_list|)
expr_stmt|;
name|paginfo
operator|=
operator|(
expr|struct
name|paginfo
operator|*
operator|)
name|calloc
argument_list|(
name|maxfree
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|paginfo
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|paginfo
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"maxfree %x?... out of mem!\n"
argument_list|,
name|maxfree
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|vprintf
argument_list|(
literal|"usrpt %x\nUsrptma %x\nfirstfree %x\nmaxfree %x\nfreemem %x\n"
argument_list|,
name|usrpt
argument_list|,
name|Usrptma
argument_list|,
name|firstfree
argument_list|,
name|maxfree
argument_list|,
name|freemem
argument_list|)
expr_stmt|;
block|{
name|lseek
argument_list|(
name|fcore
argument_list|,
operator|(
name|long
operator|)
name|clear
argument_list|(
name|nl
index|[
name|X_PROC
index|]
operator|.
name|n_value
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|read
argument_list|(
name|fcore
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|aproc
argument_list|,
sizeof|sizeof
name|aproc
argument_list|)
expr_stmt|;
name|lseek
argument_list|(
name|fcore
argument_list|,
operator|(
name|long
operator|)
name|clear
argument_list|(
name|nl
index|[
name|X_NPROC
index|]
operator|.
name|n_value
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|read
argument_list|(
name|fcore
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|nproc
argument_list|,
sizeof|sizeof
name|nproc
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%d procs\n"
argument_list|,
name|nproc
argument_list|)
expr_stmt|;
name|proc
operator|=
operator|(
expr|struct
name|proc
operator|*
operator|)
name|calloc
argument_list|(
name|nproc
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|proc
argument_list|)
argument_list|)
expr_stmt|;
name|lseek
argument_list|(
name|fcore
argument_list|,
operator|(
name|long
operator|)
name|clear
argument_list|(
name|aproc
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|read
argument_list|(
name|fcore
argument_list|,
operator|(
name|char
operator|*
operator|)
name|proc
argument_list|,
name|nproc
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|proc
argument_list|)
argument_list|)
operator|!=
name|nproc
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|proc
argument_list|)
condition|)
block|{
name|perror
argument_list|(
literal|"proc read"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
block|{
name|lseek
argument_list|(
name|fcore
argument_list|,
operator|(
name|long
operator|)
name|clear
argument_list|(
name|nl
index|[
name|X_TEXT
index|]
operator|.
name|n_value
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|read
argument_list|(
name|fcore
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|atext
argument_list|,
sizeof|sizeof
name|atext
argument_list|)
expr_stmt|;
name|lseek
argument_list|(
name|fcore
argument_list|,
operator|(
name|long
operator|)
name|clear
argument_list|(
name|nl
index|[
name|X_NTEXT
index|]
operator|.
name|n_value
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|read
argument_list|(
name|fcore
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|ntext
argument_list|,
sizeof|sizeof
name|ntext
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%d texts\n"
argument_list|,
name|ntext
argument_list|)
expr_stmt|;
name|text
operator|=
operator|(
expr|struct
name|text
operator|*
operator|)
name|calloc
argument_list|(
name|ntext
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|text
argument_list|)
argument_list|)
expr_stmt|;
name|lseek
argument_list|(
name|fcore
argument_list|,
operator|(
name|long
operator|)
name|clear
argument_list|(
name|atext
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|read
argument_list|(
name|fcore
argument_list|,
operator|(
name|char
operator|*
operator|)
name|text
argument_list|,
name|ntext
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|text
argument_list|)
argument_list|)
operator|!=
name|ntext
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|text
argument_list|)
condition|)
block|{
name|perror
argument_list|(
literal|"text read"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
name|i
operator|=
operator|(
name|get
argument_list|(
name|nl
index|[
name|X_ECMAP
index|]
operator|.
name|n_value
argument_list|)
operator|-
name|get
argument_list|(
name|nl
index|[
name|X_CMAP
index|]
operator|.
name|n_value
argument_list|)
operator|)
expr_stmt|;
name|ecmx
operator|=
name|i
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|cmap
argument_list|)
expr_stmt|;
name|cmap
operator|=
operator|(
expr|struct
name|cmap
operator|*
operator|)
name|calloc
argument_list|(
name|i
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmap
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"not enough mem for %x bytes of cmap\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|lseek
argument_list|(
name|fcore
argument_list|,
operator|(
name|long
operator|)
name|clear
argument_list|(
name|get
argument_list|(
name|nl
index|[
name|X_CMAP
index|]
operator|.
name|n_value
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|read
argument_list|(
name|fcore
argument_list|,
operator|(
name|char
operator|*
operator|)
name|cmap
argument_list|,
name|i
argument_list|)
operator|!=
name|i
condition|)
block|{
name|perror
argument_list|(
literal|"cmap read"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|{
name|struct
name|mapent
modifier|*
name|aswapmap
decl_stmt|;
name|lseek
argument_list|(
name|fcore
argument_list|,
operator|(
name|long
operator|)
name|clear
argument_list|(
name|nl
index|[
name|X_SWAPMAP
index|]
operator|.
name|n_value
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|read
argument_list|(
name|fcore
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|aswapmap
argument_list|,
sizeof|sizeof
name|aswapmap
argument_list|)
expr_stmt|;
name|lseek
argument_list|(
name|fcore
argument_list|,
operator|(
name|long
operator|)
name|clear
argument_list|(
name|nl
index|[
name|X_NSWAPMAP
index|]
operator|.
name|n_value
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|read
argument_list|(
name|fcore
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|nswapmap
argument_list|,
sizeof|sizeof
name|nswapmap
argument_list|)
expr_stmt|;
name|nswapmap
operator|--
expr_stmt|;
name|printf
argument_list|(
literal|"%d swapmap entries\n"
argument_list|,
name|nswapmap
argument_list|)
expr_stmt|;
name|swapmap
operator|=
operator|(
expr|struct
name|mapent
operator|*
operator|)
name|calloc
argument_list|(
name|nswapmap
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|mapent
argument_list|)
argument_list|)
expr_stmt|;
name|dblks
operator|=
operator|(
expr|struct
name|dblks
operator|*
operator|)
name|calloc
argument_list|(
literal|2
operator|*
name|nswapmap
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|dblks
argument_list|)
argument_list|)
expr_stmt|;
name|lseek
argument_list|(
name|fcore
argument_list|,
operator|(
name|long
operator|)
name|clear
argument_list|(
name|aswapmap
operator|+
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|read
argument_list|(
name|fcore
argument_list|,
operator|(
name|char
operator|*
operator|)
name|swapmap
argument_list|,
name|nswapmap
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|mapent
argument_list|)
argument_list|)
operator|!=
name|nswapmap
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|mapent
argument_list|)
condition|)
block|{
name|perror
argument_list|(
literal|"swapmap read"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|p
operator|=
operator|&
name|proc
index|[
literal|1
index|]
init|;
name|p
operator|<
name|proc
operator|+
name|nproc
condition|;
name|p
operator|++
control|)
block|{
name|p
operator|->
name|p_p0br
operator|=
operator|(
expr|struct
name|pte
operator|*
operator|)
name|clear
argument_list|(
name|p
operator|->
name|p_p0br
argument_list|)
expr_stmt|;
name|p
operator|->
name|p_addr
operator|=
operator|(
expr|struct
name|pte
operator|*
operator|)
name|clear
argument_list|(
name|p
operator|->
name|p_addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|p_stat
operator|==
literal|0
condition|)
continue|continue;
name|printf
argument_list|(
literal|"proc %d "
argument_list|,
name|p
operator|->
name|p_pid
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|p_stat
operator|==
name|SZOMB
condition|)
block|{
name|printf
argument_list|(
literal|"zombie\n"
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|p
operator|->
name|p_flag
operator|&
name|SLOAD
condition|)
block|{
name|printf
argument_list|(
literal|"loaded, p0br %x, "
argument_list|,
name|p
operator|->
name|p_p0br
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%d pages of page tables:"
argument_list|,
name|p
operator|->
name|p_szpt
argument_list|)
expr_stmt|;
name|a
operator|=
name|btokmx
argument_list|(
name|p
operator|->
name|p_p0br
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|p
operator|->
name|p_szpt
condition|;
name|i
operator|++
control|)
block|{
name|w
operator|=
name|get
argument_list|(
operator|&
name|Usrptma
index|[
name|a
operator|+
name|i
index|]
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" %x"
argument_list|,
name|w
operator|&
name|PG_PFNUM
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|p
operator|->
name|p_szpt
condition|;
name|i
operator|++
control|)
block|{
name|w
operator|=
name|get
argument_list|(
operator|&
name|Usrptma
index|[
name|a
operator|+
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|getpt
argument_list|(
name|w
argument_list|,
name|i
argument_list|)
condition|)
name|count
argument_list|(
name|p
argument_list|,
operator|(
expr|struct
name|pte
operator|*
operator|)
operator|&
name|w
argument_list|,
name|ZPAGET
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* i = ctopt(btoc(u.u_exdata.ux_dsize)); */
name|i
operator|=
name|clrnd
argument_list|(
name|ctopt
argument_list|(
name|p
operator|->
name|p_tsize
operator|+
name|p
operator|->
name|p_dsize
operator|+
name|p
operator|->
name|p_ssize
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"swapped, swaddr %x\n"
argument_list|,
name|p
operator|->
name|p_swaddr
argument_list|)
expr_stmt|;
name|duse
argument_list|(
name|p
operator|->
name|p_swaddr
argument_list|,
name|ctod
argument_list|(
name|clrnd
argument_list|(
name|UPAGES
argument_list|)
argument_list|)
argument_list|,
name|DUDOT
argument_list|,
name|p
operator|-
name|proc
argument_list|)
expr_stmt|;
name|duse
argument_list|(
name|p
operator|->
name|p_swaddr
operator|+
name|ctod
argument_list|(
name|UPAGES
argument_list|)
argument_list|,
name|ctod
argument_list|(
name|clrnd
argument_list|(
name|i
operator|-
name|p
operator|->
name|p_tsize
operator|/
name|NPTEPG
argument_list|)
argument_list|)
argument_list|,
name|DPAGET
argument_list|,
name|p
operator|-
name|proc
argument_list|)
expr_stmt|;
comment|/* i, DPAGET, p - proc); */
block|}
name|p
operator|->
name|p_p0br
operator|=
operator|(
expr|struct
name|pte
operator|*
operator|)
name|p0br
expr_stmt|;
name|p
operator|->
name|p_addr
operator|=
name|uaddr
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|p_textp
condition|)
name|p
operator|->
name|p_textp
operator|=
operator|&
name|text
index|[
name|p
operator|->
name|p_textp
operator|-
name|atext
index|]
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|p_pid
operator|==
literal|2
condition|)
continue|continue;
if|if
condition|(
name|getu
argument_list|(
name|p
argument_list|)
condition|)
continue|continue;
name|u
operator|.
name|u_procp
operator|=
name|p
expr_stmt|;
name|pdmap
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|p
operator|->
name|p_flag
operator|&
name|SLOAD
operator|)
operator|==
literal|0
condition|)
continue|continue;
name|pid
operator|=
name|p
operator|->
name|p_pid
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|p
operator|->
name|p_tsize
condition|;
name|i
operator|++
control|)
block|{
name|pte
operator|=
name|tptopte
argument_list|(
name|p
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|pte
operator|->
name|pg_fod
operator|||
name|pte
operator|->
name|pg_pfnum
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|pte
operator|->
name|pg_pfnum
operator|>=
name|firstfree
operator|&&
name|pte
operator|->
name|pg_pfnum
operator|<
name|maxfree
operator|&&
name|cmap
index|[
name|pgtocm
argument_list|(
name|pte
operator|->
name|pg_pfnum
argument_list|)
index|]
operator|.
name|c_intrans
condition|)
name|count
argument_list|(
name|p
argument_list|,
name|pte
argument_list|,
name|ZINTRAN
argument_list|)
expr_stmt|;
else|else
name|count
argument_list|(
name|p
argument_list|,
name|pte
argument_list|,
name|ZTEXT
argument_list|)
expr_stmt|;
block|}
name|vprintf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|p
operator|->
name|p_dsize
condition|;
name|i
operator|++
control|)
block|{
name|pte
operator|=
name|dptopte
argument_list|(
name|p
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|pte
operator|->
name|pg_fod
operator|||
name|pte
operator|->
name|pg_pfnum
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|pte
operator|->
name|pg_pfnum
operator|>=
name|firstfree
operator|&&
name|pte
operator|->
name|pg_pfnum
operator|<
name|maxfree
operator|&&
name|cmap
index|[
name|pgtocm
argument_list|(
name|pte
operator|->
name|pg_pfnum
argument_list|)
index|]
operator|.
name|c_intrans
condition|)
name|count
argument_list|(
name|p
argument_list|,
name|pte
argument_list|,
name|ZINTRAN
argument_list|)
expr_stmt|;
else|else
name|count
argument_list|(
name|p
argument_list|,
name|pte
argument_list|,
name|ZDATA
argument_list|)
expr_stmt|;
block|}
name|vprintf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|p
operator|->
name|p_ssize
condition|;
name|i
operator|++
control|)
block|{
name|pte
operator|=
name|sptopte
argument_list|(
name|p
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|pte
operator|->
name|pg_fod
operator|||
name|pte
operator|->
name|pg_pfnum
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|pte
operator|->
name|pg_pfnum
operator|>=
name|firstfree
operator|&&
name|pte
operator|->
name|pg_pfnum
operator|<
name|maxfree
operator|&&
name|cmap
index|[
name|pgtocm
argument_list|(
name|pte
operator|->
name|pg_pfnum
argument_list|)
index|]
operator|.
name|c_intrans
condition|)
name|count
argument_list|(
name|p
argument_list|,
name|pte
argument_list|,
name|ZINTRAN
argument_list|)
expr_stmt|;
else|else
name|count
argument_list|(
name|p
argument_list|,
name|pte
argument_list|,
name|ZSTACK
argument_list|)
expr_stmt|;
block|}
name|vprintf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|UPAGES
condition|;
name|i
operator|++
control|)
name|count
argument_list|(
name|p
argument_list|,
operator|&
name|p
operator|->
name|p_addr
index|[
name|i
index|]
argument_list|,
name|ZUDOT
argument_list|)
expr_stmt|;
name|vprintf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|vprintf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|xp
operator|=
operator|&
name|text
index|[
literal|0
index|]
init|;
name|xp
operator|<
name|text
operator|+
name|ntext
condition|;
name|xp
operator|++
control|)
if|if
condition|(
name|xp
operator|->
name|x_iptr
condition|)
block|{
name|int
name|size
init|=
name|ctod
argument_list|(
name|xp
operator|->
name|x_size
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|size
condition|;
name|i
operator|+=
name|dmtext
control|)
name|duse
argument_list|(
name|xp
operator|->
name|x_daddr
index|[
name|i
index|]
argument_list|,
operator|(
name|size
operator|-
name|i
operator|)
operator|>
name|dmtext
condition|?
name|dmtext
else|:
name|size
operator|-
name|i
argument_list|,
name|DTEXT
argument_list|,
name|xp
operator|-
name|text
argument_list|)
expr_stmt|;
if|if
condition|(
name|xp
operator|->
name|x_flag
operator|&
name|XPAGI
condition|)
name|duse
argument_list|(
name|xp
operator|->
name|x_ptdaddr
argument_list|,
name|ctod
argument_list|(
name|clrnd
argument_list|(
name|ctopt
argument_list|(
name|xp
operator|->
name|x_size
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|DTEXT
argument_list|,
name|xp
operator|-
name|text
argument_list|)
expr_stmt|;
block|}
name|dmcheck
argument_list|()
expr_stmt|;
name|fixfree
argument_list|()
expr_stmt|;
name|summary
argument_list|()
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_macro
name|pdmap
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|struct
name|text
modifier|*
name|xp
decl_stmt|;
if|if
condition|(
name|fswap
operator|==
operator|-
literal|1
operator|&&
operator|(
name|u
operator|.
name|u_procp
operator|->
name|p_flag
operator|&
name|SLOAD
operator|)
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
name|Dflg
condition|)
name|printf
argument_list|(
literal|"disk for pid %d"
argument_list|,
name|u
operator|.
name|u_procp
operator|->
name|p_pid
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|xp
operator|=
name|u
operator|.
name|u_procp
operator|->
name|p_textp
operator|)
operator|&&
name|Dflg
condition|)
name|ptdmap
argument_list|(
name|xp
operator|->
name|x_daddr
argument_list|,
name|xp
operator|->
name|x_size
argument_list|)
expr_stmt|;
name|pdmseg
argument_list|(
literal|"data"
argument_list|,
operator|&
name|u
operator|.
name|u_dmap
argument_list|,
name|DDATA
argument_list|)
expr_stmt|;
name|pdmseg
argument_list|(
literal|"stack"
argument_list|,
operator|&
name|u
operator|.
name|u_smap
argument_list|,
name|DSTACK
argument_list|)
expr_stmt|;
if|if
condition|(
name|Dflg
condition|)
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|ptdmap
argument_list|(
name|dp
argument_list|,
name|size
argument_list|)
specifier|register
name|daddr_t
operator|*
name|dp
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|size
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|int
name|rem
decl_stmt|;
if|if
condition|(
name|Dflg
condition|)
name|printf
argument_list|(
literal|" text:"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|rem
operator|=
name|size
init|;
name|rem
operator|>
literal|0
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|Dflg
condition|)
name|printf
argument_list|(
literal|" %x<%x>"
argument_list|,
name|dp
index|[
name|i
index|]
argument_list|,
name|rem
operator|<
name|dmtext
condition|?
name|rem
else|:
name|dmtext
argument_list|)
expr_stmt|;
name|rem
operator|-=
name|rem
operator|<
name|dmtext
condition|?
name|rem
else|:
name|dmtext
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|pdmseg
argument_list|(
argument|cp
argument_list|,
argument|dmp
argument_list|,
argument|type
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|cp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|dmap
modifier|*
name|dmp
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|int
name|b
decl_stmt|,
name|rem
decl_stmt|;
if|if
condition|(
name|Dflg
condition|)
name|printf
argument_list|(
literal|", %s:"
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|b
operator|=
name|dmmin
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|rem
operator|=
name|dmp
operator|->
name|dm_size
init|;
name|rem
operator|>
literal|0
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|Dflg
condition|)
name|printf
argument_list|(
literal|" %x<%x>"
argument_list|,
name|dmp
operator|->
name|dm_map
index|[
name|i
index|]
argument_list|,
name|rem
operator|<
name|b
condition|?
name|rem
else|:
name|b
argument_list|)
expr_stmt|;
name|duse
argument_list|(
name|dmp
operator|->
name|dm_map
index|[
name|i
index|]
argument_list|,
name|b
argument_list|,
name|type
argument_list|,
name|u
operator|.
name|u_procp
operator|-
name|proc
argument_list|)
expr_stmt|;
name|rem
operator|-=
name|b
expr_stmt|;
if|if
condition|(
name|b
operator|<
name|dmmax
condition|)
name|b
operator|*=
literal|2
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|duse
argument_list|(
argument|first
argument_list|,
argument|size
argument_list|,
argument|type
argument_list|,
argument|index
argument_list|)
end_macro

begin_block
block|{
specifier|register
name|struct
name|dblks
modifier|*
name|dp
decl_stmt|;
if|if
condition|(
name|fswap
operator|==
operator|-
literal|1
condition|)
return|return;
name|dp
operator|=
operator|&
name|dblks
index|[
name|ndblks
index|]
expr_stmt|;
if|if
condition|(
operator|++
name|ndblks
operator|>
literal|2
operator|*
name|nswapmap
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"too many disk blocks\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|dp
operator|->
name|d_first
operator|=
name|first
expr_stmt|;
name|dp
operator|->
name|d_size
operator|=
name|size
expr_stmt|;
name|dp
operator|->
name|d_type
operator|=
name|type
expr_stmt|;
name|dp
operator|->
name|d_index
operator|=
name|index
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|dsort
argument_list|(
name|d
argument_list|,
name|e
argument_list|)
specifier|register
expr|struct
name|dblks
operator|*
name|d
operator|,
operator|*
name|e
expr_stmt|;
end_expr_stmt

begin_block
block|{
return|return
operator|(
name|e
operator|->
name|d_first
operator|-
name|d
operator|->
name|d_first
operator|)
return|;
block|}
end_block

begin_macro
name|dmcheck
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|struct
name|mapent
modifier|*
name|smp
decl_stmt|;
specifier|register
name|struct
name|dblks
modifier|*
name|d
decl_stmt|,
modifier|*
name|e
decl_stmt|;
for|for
control|(
name|smp
operator|=
name|swapmap
init|;
name|smp
operator|->
name|m_size
condition|;
name|smp
operator|++
control|)
name|duse
argument_list|(
name|smp
operator|->
name|m_addr
argument_list|,
name|smp
operator|->
name|m_size
argument_list|,
name|DFREE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|duse
argument_list|(
name|ctod
argument_list|(
name|CLSIZE
argument_list|)
argument_list|,
name|dmtext
operator|-
name|ctod
argument_list|(
name|CLSIZE
argument_list|)
argument_list|,
name|DFREE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|qsort
argument_list|(
name|dblks
argument_list|,
name|ndblks
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|dblks
argument_list|)
argument_list|,
name|dsort
argument_list|)
expr_stmt|;
name|d
operator|=
operator|&
name|dblks
index|[
name|ndblks
operator|-
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|d_first
operator|>
literal|1
condition|)
name|printf
argument_list|(
literal|"lost swap map: start %x size %x\n"
argument_list|,
literal|1
argument_list|,
name|d
operator|->
name|d_first
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|d
operator|>
name|dblks
condition|;
name|d
operator|--
control|)
block|{
if|if
condition|(
name|dflg
condition|)
name|dprint
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|e
operator|=
name|d
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|d_first
operator|+
name|d
operator|->
name|d_size
operator|>
name|e
operator|->
name|d_first
condition|)
block|{
name|printf
argument_list|(
literal|"overlap in swap mappings:\n"
argument_list|)
expr_stmt|;
name|dprint
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|dprint
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|d
operator|->
name|d_first
operator|+
name|d
operator|->
name|d_size
operator|<
name|e
operator|->
name|d_first
condition|)
block|{
name|printf
argument_list|(
literal|"lost swap map: start %x size %x\n"
argument_list|,
name|d
operator|->
name|d_first
operator|+
name|d
operator|->
name|d_size
argument_list|,
name|e
operator|->
name|d_first
operator|-
operator|(
name|d
operator|->
name|d_first
operator|+
name|d
operator|->
name|d_size
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|dflg
condition|)
name|dprint
argument_list|(
name|dblks
argument_list|)
expr_stmt|;
if|if
condition|(
name|sflg
condition|)
name|printf
argument_list|(
literal|"swap space ends at %x\n"
argument_list|,
name|d
operator|->
name|d_first
operator|+
name|d
operator|->
name|d_size
argument_list|)
expr_stmt|;
block|}
end_block

begin_decl_stmt
name|char
modifier|*
name|dnames
index|[]
init|=
block|{
literal|"DFREE"
block|,
literal|"DDATA"
block|,
literal|"DSTACK"
block|,
literal|"DTEXT"
block|,
literal|"DUDOT"
block|,
literal|"DPAGET"
block|, }
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|dprint
argument_list|(
name|d
argument_list|)
specifier|register
expr|struct
name|dblks
operator|*
name|d
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|printf
argument_list|(
literal|"at %4x size %4x type %s"
argument_list|,
name|d
operator|->
name|d_first
argument_list|,
name|d
operator|->
name|d_size
argument_list|,
name|dnames
index|[
name|d
operator|->
name|d_type
index|]
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|d
operator|->
name|d_type
condition|)
block|{
case|case
name|DSTACK
case|:
case|case
name|DDATA
case|:
name|printf
argument_list|(
literal|" pid %d"
argument_list|,
name|proc
index|[
name|d
operator|->
name|d_index
index|]
operator|.
name|p_pid
argument_list|)
expr_stmt|;
break|break;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|getpt
argument_list|(
argument|x
argument_list|,
argument|i
argument_list|)
end_macro

begin_decl_stmt
name|int
name|x
decl_stmt|,
name|i
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|lseek
argument_list|(
name|fcore
argument_list|,
operator|(
name|long
operator|)
name|ctob
argument_list|(
operator|(
name|x
operator|&
name|PG_PFNUM
operator|)
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|read
argument_list|(
name|fcore
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|(
name|p0br
index|[
name|i
index|]
operator|)
argument_list|,
name|NBPG
argument_list|)
operator|!=
name|NBPG
condition|)
block|{
name|perror
argument_list|(
literal|"read"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"getpt error reading frame %x\n"
argument_list|,
name|clear
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_expr_stmt
name|checkpg
argument_list|(
name|p
argument_list|,
name|pte
argument_list|,
name|type
argument_list|)
specifier|register
expr|struct
name|pte
operator|*
name|pte
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|type
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
name|corepg
index|[
name|NBPG
index|]
decl_stmt|,
name|swapg
index|[
name|NBPG
index|]
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|,
name|count
decl_stmt|,
name|dblock
decl_stmt|;
specifier|register
name|int
name|pfnum
init|=
name|pte
operator|->
name|pg_pfnum
decl_stmt|;
if|if
condition|(
name|type
operator|==
name|ZPAGET
operator|||
name|type
operator|==
name|ZUDOT
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|lseek
argument_list|(
name|fcore
argument_list|,
call|(
name|long
call|)
argument_list|(
name|NBPG
operator|*
name|pfnum
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|read
argument_list|(
name|fcore
argument_list|,
name|corepg
argument_list|,
name|NBPG
argument_list|)
operator|!=
name|NBPG
condition|)
block|{
name|perror
argument_list|(
literal|"read"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Error reading core page %x\n"
argument_list|,
name|pfnum
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|ZDATA
case|:
if|if
condition|(
name|ptetodp
argument_list|(
name|p
argument_list|,
name|pte
argument_list|)
operator|>=
name|u
operator|.
name|u_dmap
operator|.
name|dm_size
condition|)
return|return
operator|(
literal|0
operator|)
return|;
break|break;
case|case
name|ZTEXT
case|:
break|break;
case|case
name|ZSTACK
case|:
if|if
condition|(
name|ptetosp
argument_list|(
name|p
argument_list|,
name|pte
argument_list|)
operator|>=
name|u
operator|.
name|u_smap
operator|.
name|dm_size
condition|)
return|return
operator|(
literal|0
operator|)
return|;
break|break;
default|default:
return|return
operator|(
literal|0
operator|)
return|;
break|break;
block|}
name|dblock
operator|=
name|vtod
argument_list|(
name|p
argument_list|,
name|ptetov
argument_list|(
name|p
argument_list|,
name|pte
argument_list|)
argument_list|,
operator|&
name|u
operator|.
name|u_dmap
argument_list|,
operator|&
name|u
operator|.
name|u_smap
argument_list|)
expr_stmt|;
name|vprintf
argument_list|(
literal|"   %x"
argument_list|,
name|dblock
argument_list|)
expr_stmt|;
if|if
condition|(
name|pte
operator|->
name|pg_fod
operator|||
name|pte
operator|->
name|pg_pfnum
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|cmap
index|[
name|pgtocm
argument_list|(
name|pte
operator|->
name|pg_pfnum
argument_list|)
index|]
operator|.
name|c_intrans
operator|||
name|pte
operator|->
name|pg_m
operator|||
name|pte
operator|->
name|pg_swapm
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|lseek
argument_list|(
name|fswap
argument_list|,
call|(
name|long
call|)
argument_list|(
name|DEV_BSIZE
operator|*
name|dblock
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|read
argument_list|(
name|fswap
argument_list|,
name|swapg
argument_list|,
name|NBPG
argument_list|)
operator|!=
name|NBPG
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"swap page %x: "
argument_list|,
name|dblock
argument_list|)
expr_stmt|;
name|perror
argument_list|(
literal|"read"
argument_list|)
expr_stmt|;
block|}
name|count
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NBPG
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|corepg
index|[
name|i
index|]
operator|!=
name|swapg
index|[
name|i
index|]
condition|)
name|count
operator|++
expr_stmt|;
if|if
condition|(
name|count
operator|==
literal|0
condition|)
name|vprintf
argument_list|(
literal|"\tsame"
argument_list|)
expr_stmt|;
return|return
operator|(
name|count
operator|)
return|;
block|}
end_block

begin_expr_stmt
name|getu
argument_list|(
name|p
argument_list|)
specifier|register
expr|struct
name|proc
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|int
name|i
decl_stmt|,
name|w
decl_stmt|,
name|cc
decl_stmt|,
name|errs
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|uflg
operator|&&
operator|(
name|p
operator|->
name|p_flag
operator|&
name|SLOAD
operator|)
condition|)
name|printf
argument_list|(
literal|"pid %d u. pages:"
argument_list|,
name|p
operator|->
name|p_pid
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|UPAGES
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|p
operator|->
name|p_flag
operator|&
name|SLOAD
condition|)
block|{
if|if
condition|(
name|uflg
condition|)
name|printf
argument_list|(
literal|" %x"
argument_list|,
name|p
operator|->
name|p_addr
index|[
name|i
index|]
operator|.
name|pg_pfnum
argument_list|)
expr_stmt|;
name|lseek
argument_list|(
name|fcore
argument_list|,
name|ctob
argument_list|(
name|p
operator|->
name|p_addr
index|[
name|i
index|]
operator|.
name|pg_pfnum
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|read
argument_list|(
name|fcore
argument_list|,
name|u_area
operator|.
name|buf
index|[
name|i
index|]
argument_list|,
name|NBPG
argument_list|)
operator|!=
name|NBPG
condition|)
name|perror
argument_list|(
literal|"core u. read"
argument_list|)
operator|,
name|errs
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fswap
operator|>=
literal|0
condition|)
block|{
name|lseek
argument_list|(
name|fswap
argument_list|,
call|(
name|long
call|)
argument_list|(
name|NBPG
operator|*
operator|(
name|p
operator|->
name|p_swaddr
operator|+
name|i
operator|)
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|read
argument_list|(
name|fswap
argument_list|,
name|u_area
operator|.
name|buf
index|[
name|i
index|]
argument_list|,
name|NBPG
argument_list|)
operator|!=
name|NBPG
condition|)
name|perror
argument_list|(
literal|"swap u. read"
argument_list|)
operator|,
name|errs
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|uflg
operator|&&
operator|(
name|p
operator|->
name|p_flag
operator|&
name|SLOAD
operator|)
condition|)
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|errs
operator|)
return|;
block|}
end_block

begin_decl_stmt
name|char
modifier|*
name|typepg
index|[]
init|=
block|{
literal|"lost"
block|,
literal|"data"
block|,
literal|"stack"
block|,
literal|"udot"
block|,
literal|"paget"
block|,
literal|"text"
block|,
literal|"free"
block|,
literal|"intransit"
block|, }
decl_stmt|;
end_decl_stmt

begin_macro
name|count
argument_list|(
argument|p
argument_list|,
argument|pte
argument_list|,
argument|type
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|struct
name|pte
modifier|*
name|pte
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|type
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|pfnum
init|=
name|pte
operator|->
name|pg_pfnum
decl_stmt|;
specifier|register
name|struct
name|paginfo
modifier|*
name|zp
init|=
operator|&
name|paginfo
index|[
name|pfnum
index|]
decl_stmt|;
name|int
name|ndif
decl_stmt|;
define|#
directive|define
name|zprintf
value|if (type==ZINTRAN || vflg) printf
if|if
condition|(
name|type
operator|==
name|ZINTRAN
operator|&&
name|pfnum
operator|==
literal|0
condition|)
return|return;
name|zprintf
argument_list|(
literal|"page %x %s"
argument_list|,
name|pfnum
argument_list|,
name|typepg
index|[
name|type
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|sflg
operator|==
literal|0
operator|||
operator|(
name|ndif
operator|=
name|checkpg
argument_list|(
name|p
argument_list|,
name|pte
argument_list|,
name|type
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|zprintf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|vflg
operator|==
literal|0
operator|&&
name|type
operator|!=
name|ZINTRAN
condition|)
name|printf
argument_list|(
literal|"page %x %s,"
argument_list|,
name|pfnum
argument_list|,
name|typepg
index|[
name|type
index|]
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" %d bytes differ\n"
argument_list|,
name|ndif
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pfnum
operator|<
name|firstfree
operator|||
name|pfnum
operator|>
name|maxfree
condition|)
block|{
name|printf
argument_list|(
literal|"page number out of range:\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\tpage %x type %s pid %d\n"
argument_list|,
name|pfnum
argument_list|,
name|typepg
index|[
name|type
index|]
argument_list|,
name|pid
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|bad
argument_list|(
name|zp
argument_list|,
name|type
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"dup page pte %x"
argument_list|,
operator|*
operator|(
name|int
operator|*
operator|)
name|pte
argument_list|)
expr_stmt|;
name|dumpcm
argument_list|(
literal|""
argument_list|,
name|pte
operator|->
name|pg_pfnum
argument_list|)
expr_stmt|;
name|dump
argument_list|(
name|zp
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"pte %x and as %s in pid %d\n"
argument_list|,
name|zp
operator|->
name|z_pte
argument_list|,
name|typepg
index|[
name|type
index|]
argument_list|,
name|pid
argument_list|)
expr_stmt|;
return|return;
block|}
name|zp
operator|->
name|z_type
operator|=
name|type
expr_stmt|;
name|zp
operator|->
name|z_count
operator|++
expr_stmt|;
name|zp
operator|->
name|z_pid
operator|=
name|pid
expr_stmt|;
name|zp
operator|->
name|z_pte
operator|=
operator|*
name|pte
expr_stmt|;
block|}
end_block

begin_macro
name|bad
argument_list|(
argument|zp
argument_list|,
argument|type
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|paginfo
modifier|*
name|zp
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|type
operator|==
name|ZTEXT
condition|)
block|{
if|if
condition|(
name|zp
operator|->
name|z_type
operator|!=
literal|0
operator|&&
name|zp
operator|->
name|z_type
operator|!=
name|ZTEXT
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
name|zp
operator|->
name|z_count
operator|)
return|;
block|}
end_block

begin_macro
name|dump
argument_list|(
argument|zp
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|paginfo
modifier|*
name|zp
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|printf
argument_list|(
literal|"page %x type %s pid %d "
argument_list|,
name|zp
operator|-
name|paginfo
argument_list|,
name|typepg
index|[
name|zp
operator|->
name|z_type
index|]
argument_list|,
name|zp
operator|->
name|z_pid
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|summary
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|struct
name|paginfo
modifier|*
name|zp
decl_stmt|;
specifier|register
name|int
name|pfnum
decl_stmt|;
for|for
control|(
name|i
operator|=
name|firstfree
operator|+
name|UPAGES
init|;
name|i
operator|<
name|maxfree
condition|;
name|i
operator|+=
name|CLSIZE
control|)
block|{
name|zp
operator|=
operator|&
name|paginfo
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|zp
operator|->
name|z_type
operator|==
name|ZLOST
condition|)
name|dumpcm
argument_list|(
literal|"lost"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|pfnum
operator|=
name|pgtocm
argument_list|(
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmap
index|[
name|pfnum
index|]
operator|.
name|c_lock
operator|&&
name|cmap
index|[
name|pfnum
index|]
operator|.
name|c_type
operator|!=
name|CSYS
condition|)
name|dumpcm
argument_list|(
literal|"locked"
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|mflg
condition|)
name|dumpcm
argument_list|(
literal|"mem"
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_decl_stmt
name|char
modifier|*
name|tynames
index|[]
init|=
block|{
literal|"sys"
block|,
literal|"text"
block|,
literal|"data"
block|,
literal|"stack"
block|}
decl_stmt|;
end_decl_stmt

begin_macro
name|dumpcm
argument_list|(
argument|cp
argument_list|,
argument|pg
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|cp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|pg
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|pslot
decl_stmt|;
name|int
name|cm
decl_stmt|;
specifier|register
name|struct
name|cmap
modifier|*
name|c
decl_stmt|;
name|cm
operator|=
name|pgtocm
argument_list|(
name|pg
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"cm %x %s page %x "
argument_list|,
name|cm
argument_list|,
name|cp
argument_list|,
name|pg
argument_list|)
expr_stmt|;
name|c
operator|=
operator|&
name|cmap
index|[
name|cm
index|]
expr_stmt|;
name|printf
argument_list|(
literal|"\t[%x, %x"
argument_list|,
name|c
operator|->
name|c_page
argument_list|,
name|c
operator|->
name|c_ndx
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|c_type
operator|==
name|CSYS
condition|)
goto|goto
name|skip
goto|;
if|if
condition|(
name|c
operator|->
name|c_type
operator|!=
name|CTEXT
condition|)
block|{
if|if
condition|(
name|c
operator|->
name|c_ndx
operator|>=
name|nproc
condition|)
block|{
name|printf
argument_list|(
literal|" [text c->c_ndx %d?]"
argument_list|,
name|c
operator|->
name|c_ndx
argument_list|)
expr_stmt|;
goto|goto
name|skip
goto|;
block|}
name|printf
argument_list|(
literal|" (=pid %d)"
argument_list|,
name|proc
index|[
name|c
operator|->
name|c_ndx
index|]
operator|.
name|p_pid
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|c
operator|->
name|c_ndx
operator|>=
name|ntext
condition|)
block|{
name|printf
argument_list|(
literal|" [text c->c_ndx %d?]"
argument_list|,
name|c
operator|->
name|c_ndx
argument_list|)
expr_stmt|;
goto|goto
name|skip
goto|;
block|}
name|pslot
operator|=
operator|(
name|text
index|[
name|c
operator|->
name|c_ndx
index|]
operator|.
name|x_caddr
operator|-
name|aproc
operator|)
expr_stmt|;
name|printf
argument_list|(
literal|" (=pid"
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|printf
argument_list|(
literal|" %d"
argument_list|,
name|proc
index|[
name|pslot
index|]
operator|.
name|p_pid
argument_list|)
expr_stmt|;
if|if
condition|(
name|proc
index|[
name|pslot
index|]
operator|.
name|p_xlink
operator|==
literal|0
condition|)
break|break;
name|pslot
operator|=
operator|(
name|proc
index|[
name|pslot
index|]
operator|.
name|p_xlink
operator|-
name|aproc
operator|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|")"
argument_list|)
expr_stmt|;
block|}
name|skip
label|:
name|printf
argument_list|(
literal|"] "
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|tynames
index|[
name|c
operator|->
name|c_type
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|c_free
condition|)
name|printf
argument_list|(
literal|" free"
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|c_gone
condition|)
name|printf
argument_list|(
literal|" gone"
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|c_lock
condition|)
name|printf
argument_list|(
literal|" lock"
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|c_want
condition|)
name|printf
argument_list|(
literal|" want"
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|c_intrans
condition|)
name|printf
argument_list|(
literal|" intrans"
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|c_blkno
condition|)
name|printf
argument_list|(
literal|" blkno %x mdev %d"
argument_list|,
name|c
operator|->
name|c_blkno
argument_list|,
name|c
operator|->
name|c_mdev
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|c_hlink
condition|)
block|{
name|printf
argument_list|(
literal|" hlink %x page %x"
argument_list|,
name|c
operator|->
name|c_hlink
argument_list|,
name|cmtopg
argument_list|(
name|c
operator|->
name|c_hlink
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|c_hlink
operator|>
name|ecmx
condition|)
name|printf
argument_list|(
literal|"<<<"
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|fixfree
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|next
decl_stmt|,
name|prev
decl_stmt|;
name|next
operator|=
name|CMHEAD
expr_stmt|;
for|for
control|(
name|i
operator|=
name|freemem
operator|/
name|CLSIZE
init|;
operator|--
name|i
operator|>=
literal|0
condition|;
control|)
block|{
name|prev
operator|=
name|next
expr_stmt|;
name|next
operator|=
name|cmap
index|[
name|next
index|]
operator|.
name|c_next
expr_stmt|;
if|if
condition|(
name|cmap
index|[
name|next
index|]
operator|.
name|c_free
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"link to non free block: in %x to %x\n"
argument_list|,
name|cmtopg
argument_list|(
name|prev
argument_list|)
argument_list|,
name|cmtopg
argument_list|(
name|next
argument_list|)
argument_list|)
expr_stmt|;
name|dumpcm
argument_list|(
literal|"bad free link in"
argument_list|,
name|cmtopg
argument_list|(
name|prev
argument_list|)
argument_list|)
expr_stmt|;
name|dumpcm
argument_list|(
literal|"to non free block"
argument_list|,
name|cmtopg
argument_list|(
name|next
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cmtopg
argument_list|(
name|next
argument_list|)
operator|>
name|maxfree
condition|)
block|{
name|printf
argument_list|(
literal|"free list link out of range: in %x to %x\n"
argument_list|,
name|cmtopg
argument_list|(
name|prev
argument_list|)
argument_list|,
name|cmtopg
argument_list|(
name|next
argument_list|)
argument_list|)
expr_stmt|;
name|dumpcm
argument_list|(
literal|"bad link in"
argument_list|,
name|cmtopg
argument_list|(
name|prev
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|paginfo
index|[
name|cmtopg
argument_list|(
name|next
argument_list|)
index|]
operator|.
name|z_type
operator|=
name|ZFREE
expr_stmt|;
if|if
condition|(
name|fflg
condition|)
name|dumpcm
argument_list|(
literal|"free"
argument_list|,
name|cmtopg
argument_list|(
name|next
argument_list|)
argument_list|)
expr_stmt|;
name|paginfo
index|[
name|cmtopg
argument_list|(
name|next
argument_list|)
operator|+
literal|1
index|]
operator|.
name|z_type
operator|=
name|ZFREE
expr_stmt|;
if|if
condition|(
name|fflg
condition|)
name|dumpcm
argument_list|(
literal|"free"
argument_list|,
name|cmtopg
argument_list|(
name|next
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|get
argument_list|(
argument|loc
argument_list|)
end_macro

begin_decl_stmt
name|unsigned
name|loc
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|x
decl_stmt|;
name|lseek
argument_list|(
name|fcore
argument_list|,
operator|(
name|long
operator|)
name|clear
argument_list|(
name|loc
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|read
argument_list|(
name|fcore
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|x
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
condition|)
block|{
name|perror
argument_list|(
literal|"read"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"get failed on %x\n"
argument_list|,
name|clear
argument_list|(
name|loc
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
name|x
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Convert a virtual page number   * to its corresponding disk block number.  * Used in pagein/pageout to initiate single page transfers.  */
end_comment

begin_expr_stmt
name|vtod
argument_list|(
name|p
argument_list|,
name|v
argument_list|,
name|dmap
argument_list|,
name|smap
argument_list|)
specifier|register
expr|struct
name|proc
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|struct
name|dmap
modifier|*
name|dmap
decl_stmt|,
modifier|*
name|smap
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|dblock
name|db
decl_stmt|;
if|if
condition|(
name|isatsv
argument_list|(
name|p
argument_list|,
name|v
argument_list|)
condition|)
block|{
name|v
operator|=
name|ctod
argument_list|(
name|vtotp
argument_list|(
name|p
argument_list|,
name|v
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|p
operator|->
name|p_textp
operator|->
name|x_daddr
index|[
name|v
operator|/
name|dmtext
index|]
operator|+
name|v
operator|%
name|dmtext
operator|)
return|;
block|}
if|if
condition|(
name|isassv
argument_list|(
name|p
argument_list|,
name|v
argument_list|)
condition|)
name|vstodb
argument_list|(
name|ctod
argument_list|(
name|vtosp
argument_list|(
name|p
argument_list|,
name|v
argument_list|)
argument_list|)
argument_list|,
name|ctod
argument_list|(
literal|1
argument_list|)
argument_list|,
name|smap
argument_list|,
operator|&
name|db
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
name|vstodb
argument_list|(
name|ctod
argument_list|(
name|vtodp
argument_list|(
name|p
argument_list|,
name|v
argument_list|)
argument_list|)
argument_list|,
name|ctod
argument_list|(
literal|1
argument_list|)
argument_list|,
name|dmap
argument_list|,
operator|&
name|db
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|db
operator|.
name|db_base
operator|)
return|;
block|}
end_block

begin_comment
comment|/*   * Convert a pte pointer to  * a virtual page number.  */
end_comment

begin_expr_stmt
name|ptetov
argument_list|(
name|p
argument_list|,
name|pte
argument_list|)
specifier|register
expr|struct
name|proc
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|struct
name|pte
modifier|*
name|pte
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|isatpte
argument_list|(
name|p
argument_list|,
name|pte
argument_list|)
condition|)
return|return
operator|(
name|tptov
argument_list|(
name|p
argument_list|,
name|ptetotp
argument_list|(
name|p
argument_list|,
name|pte
argument_list|)
argument_list|)
operator|)
return|;
elseif|else
if|if
condition|(
name|isadpte
argument_list|(
name|p
argument_list|,
name|pte
argument_list|)
condition|)
return|return
operator|(
name|dptov
argument_list|(
name|p
argument_list|,
name|ptetodp
argument_list|(
name|p
argument_list|,
name|pte
argument_list|)
argument_list|)
operator|)
return|;
else|else
return|return
operator|(
name|sptov
argument_list|(
name|p
argument_list|,
name|ptetosp
argument_list|(
name|p
argument_list|,
name|pte
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Given a base/size pair in virtual swap area,  * return a physical base/size pair which is the  * (largest) initial, physically contiguous block.  */
end_comment

begin_expr_stmt
name|vstodb
argument_list|(
name|vsbase
argument_list|,
name|vssize
argument_list|,
name|dmp
argument_list|,
name|dbp
argument_list|,
name|rev
argument_list|)
specifier|register
name|int
name|vsbase
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|vssize
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|struct
name|dmap
modifier|*
name|dmp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|struct
name|dblock
modifier|*
name|dbp
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|blk
init|=
name|dmmin
decl_stmt|;
specifier|register
name|swblk_t
modifier|*
name|ip
init|=
name|dmp
operator|->
name|dm_map
decl_stmt|;
if|if
condition|(
name|vsbase
operator|<
literal|0
operator|||
name|vsbase
operator|+
name|vssize
operator|>
name|dmp
operator|->
name|dm_size
condition|)
name|panic
argument_list|(
literal|"vstodb"
argument_list|)
expr_stmt|;
while|while
condition|(
name|vsbase
operator|>=
name|blk
condition|)
block|{
name|vsbase
operator|-=
name|blk
expr_stmt|;
if|if
condition|(
name|blk
operator|<
name|dmmax
condition|)
name|blk
operator|*=
literal|2
expr_stmt|;
name|ip
operator|++
expr_stmt|;
block|}
name|dbp
operator|->
name|db_size
operator|=
name|min
argument_list|(
name|vssize
argument_list|,
name|blk
operator|-
name|vsbase
argument_list|)
expr_stmt|;
name|dbp
operator|->
name|db_base
operator|=
operator|*
name|ip
operator|+
operator|(
name|rev
condition|?
name|blk
operator|-
operator|(
name|vsbase
operator|+
name|vssize
operator|)
else|:
name|vsbase
operator|)
expr_stmt|;
block|}
end_block

begin_macro
name|panic
argument_list|(
argument|cp
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|cp
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|printf
argument_list|(
literal|"panic!: %s\n"
argument_list|,
name|cp
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|min
argument_list|(
argument|a
argument_list|,
argument|b
argument_list|)
end_macro

begin_block
block|{
return|return
operator|(
name|a
operator|<
name|b
condition|?
name|a
else|:
name|b
operator|)
return|;
block|}
end_block

end_unit

