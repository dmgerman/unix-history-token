begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1993  *	The Regents of the University of California.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by the University of  *	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)svi_smap.c	8.1 (Berkeley) 6/9/93"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<curses.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|"vi.h"
end_include

begin_include
include|#
directive|include
file|"vcmd.h"
end_include

begin_include
include|#
directive|include
file|"svi_screen.h"
end_include

begin_comment
comment|/*  * svi_change --  *	Make a change to the screen.  */
end_comment

begin_function
name|int
name|svi_change
parameter_list|(
name|sp
parameter_list|,
name|ep
parameter_list|,
name|lno
parameter_list|,
name|op
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
name|EXF
modifier|*
name|ep
decl_stmt|;
name|recno_t
name|lno
decl_stmt|;
name|enum
name|operation
name|op
decl_stmt|;
block|{
name|SMAP
modifier|*
name|p
decl_stmt|;
name|size_t
name|oldy
decl_stmt|,
name|oldx
decl_stmt|;
comment|/* Appending is the same as inserting, if the line is incremented. */
if|if
condition|(
name|op
operator|==
name|LINE_APPEND
condition|)
block|{
operator|++
name|lno
expr_stmt|;
name|op
operator|=
name|LINE_INSERT
expr_stmt|;
block|}
comment|/* Ignore the change if the line is after the map. */
if|if
condition|(
name|lno
operator|>
name|TMAP
operator|->
name|lno
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 	 * If the line is before the map, and it's a decrement, decrement 	 * the map.  If it's an increment, increment the map.  Otherwise, 	 * ignore it. 	 */
if|if
condition|(
name|lno
operator|<
name|HMAP
operator|->
name|lno
condition|)
block|{
if|if
condition|(
name|op
operator|==
name|LINE_DELETE
condition|)
for|for
control|(
name|p
operator|=
name|HMAP
init|;
name|p
operator|<=
name|TMAP
condition|;
operator|++
name|p
control|)
operator|--
name|p
operator|->
name|lno
expr_stmt|;
elseif|else
if|if
condition|(
name|op
operator|==
name|LINE_INSERT
condition|)
for|for
control|(
name|p
operator|=
name|HMAP
init|;
name|p
operator|<=
name|TMAP
condition|;
operator|++
name|p
control|)
operator|++
name|p
operator|->
name|lno
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* Invalidate the cursor, if it's on this line. */
if|if
condition|(
name|sp
operator|->
name|lno
operator|==
name|lno
condition|)
name|F_SET
argument_list|(
name|sp
argument_list|,
name|S_CUR_INVALID
argument_list|)
expr_stmt|;
name|getyx
argument_list|(
name|stdscr
argument_list|,
name|oldy
argument_list|,
name|oldx
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|LINE_DELETE
case|:
if|if
condition|(
name|svi_sm_delete
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
name|lno
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
break|break;
case|case
name|LINE_INSERT
case|:
if|if
condition|(
name|svi_sm_insert
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
name|lno
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
break|break;
case|case
name|LINE_RESET
case|:
if|if
condition|(
name|svi_sm_reset
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
name|lno
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
name|MOVEA
argument_list|(
name|sp
argument_list|,
name|oldy
argument_list|,
name|oldx
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * svi_sm_fill --  *	Fill in the screen map, placing the specified line at the  *	right position.  */
end_comment

begin_function
name|int
name|svi_sm_fill
parameter_list|(
name|sp
parameter_list|,
name|ep
parameter_list|,
name|lno
parameter_list|,
name|pos
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
name|EXF
modifier|*
name|ep
decl_stmt|;
name|recno_t
name|lno
decl_stmt|;
name|enum
name|position
name|pos
decl_stmt|;
block|{
name|SMAP
modifier|*
name|p
decl_stmt|,
name|tmp
decl_stmt|;
switch|switch
condition|(
name|pos
condition|)
block|{
case|case
name|P_FILL
case|:
name|tmp
operator|.
name|lno
operator|=
literal|1
expr_stmt|;
name|tmp
operator|.
name|off
operator|=
literal|1
expr_stmt|;
comment|/* See if less than half a screen from the top. */
if|if
condition|(
name|svi_sm_nlines
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
operator|&
name|tmp
argument_list|,
name|lno
argument_list|,
name|HALFSCREEN
argument_list|(
name|sp
argument_list|)
argument_list|)
operator|<=
name|HALFSCREEN
argument_list|(
name|sp
argument_list|)
condition|)
block|{
name|lno
operator|=
literal|1
expr_stmt|;
goto|goto
name|top
goto|;
block|}
comment|/* See if less than half a screen from the bottom. */
if|if
condition|(
name|file_lline
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
operator|&
name|tmp
operator|.
name|lno
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|tmp
operator|.
name|off
operator|=
name|svi_screens
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
name|tmp
operator|.
name|lno
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|svi_sm_nlines
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
operator|&
name|tmp
argument_list|,
name|lno
argument_list|,
name|HALFSCREEN
argument_list|(
name|sp
argument_list|)
argument_list|)
operator|<=
name|HALFSCREEN
argument_list|(
name|sp
argument_list|)
condition|)
block|{
name|TMAP
operator|->
name|lno
operator|=
name|tmp
operator|.
name|lno
expr_stmt|;
name|TMAP
operator|->
name|off
operator|=
name|tmp
operator|.
name|off
expr_stmt|;
goto|goto
name|bottom
goto|;
block|}
goto|goto
name|middle
goto|;
case|case
name|P_TOP
case|:
comment|/* If we fail, just punt. */
name|top
label|:
for|for
control|(
name|p
operator|=
name|HMAP
operator|,
name|p
operator|->
name|lno
operator|=
name|lno
operator|,
name|p
operator|->
name|off
operator|=
literal|1
init|;
name|p
operator|<
name|TMAP
condition|;
operator|++
name|p
control|)
if|if
condition|(
name|svi_sm_next
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
name|p
argument_list|,
name|p
operator|+
literal|1
argument_list|)
condition|)
goto|goto
name|err
goto|;
break|break;
case|case
name|P_MIDDLE
case|:
comment|/* If we fail, guess that the file is too small. */
name|middle
label|:
name|p
operator|=
name|HMAP
operator|+
operator|(
name|TMAP
operator|-
name|HMAP
operator|)
operator|/
literal|2
expr_stmt|;
for|for
control|(
name|p
operator|->
name|lno
operator|=
name|lno
operator|,
name|p
operator|->
name|off
operator|=
literal|1
init|;
name|p
operator|>
name|HMAP
condition|;
operator|--
name|p
control|)
if|if
condition|(
name|svi_sm_prev
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
name|p
argument_list|,
name|p
operator|-
literal|1
argument_list|)
condition|)
block|{
name|lno
operator|=
literal|1
expr_stmt|;
goto|goto
name|top
goto|;
block|}
comment|/* If we fail, just punt. */
name|p
operator|=
name|HMAP
operator|+
operator|(
name|TMAP
operator|-
name|HMAP
operator|)
operator|/
literal|2
expr_stmt|;
for|for
control|(
init|;
name|p
operator|<
name|TMAP
condition|;
operator|++
name|p
control|)
if|if
condition|(
name|svi_sm_next
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
name|p
argument_list|,
name|p
operator|+
literal|1
argument_list|)
condition|)
goto|goto
name|err
goto|;
break|break;
case|case
name|P_BOTTOM
case|:
comment|/* If we fail, guess that the file is too small. */
name|TMAP
operator|->
name|lno
operator|=
name|lno
expr_stmt|;
name|TMAP
operator|->
name|off
operator|=
name|svi_screens
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
name|lno
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|bottom
label|:
for|for
control|(
name|p
operator|=
name|TMAP
init|;
name|p
operator|>
name|HMAP
condition|;
operator|--
name|p
control|)
if|if
condition|(
name|svi_sm_prev
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
name|p
argument_list|,
name|p
operator|-
literal|1
argument_list|)
condition|)
block|{
name|lno
operator|=
literal|1
expr_stmt|;
goto|goto
name|top
goto|;
block|}
break|break;
block|}
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 	 * Try and put *something* on the screen.  If this fails, 	 * we have a serious hard error. 	 */
name|err
label|:
name|HMAP
operator|->
name|lno
operator|=
literal|1
expr_stmt|;
name|HMAP
operator|->
name|off
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|p
operator|=
name|HMAP
init|;
name|p
operator|<
name|TMAP
condition|;
operator|++
name|p
control|)
if|if
condition|(
name|svi_sm_next
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
name|p
argument_list|,
name|p
operator|+
literal|1
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * For the routines svi_sm_reset, svi_sm_delete and svi_sm_insert: if the  * screen only contains one line, or, if the line is the entire screen, this  * gets fairly exciting.  Skip the fun and simply return if there's only one  * line in the screen, or just call fill.  Fill may not be entirely accurate,  * i.e. we may be painting the screen with something not even close to the  * cursor, but it's not like we're into serious performance issues here, and  * the refresh routine will fix it for us.  */
end_comment

begin_define
define|#
directive|define
name|TOO_WEIRD
value|{							\ 	if (cnt_orig>= sp->t_rows) {					\ 		if (cnt_orig == 1)					\ 			return (0);					\ 		if (file_gline(sp, ep, lno, NULL) == NULL)		\ 			if (file_lline(sp, ep,&lno))			\ 				return (1);				\ 		F_SET(sp, S_REDRAW);					\ 		return (svi_sm_fill(sp, ep, lno, P_TOP));		\ 	}								\ }
end_define

begin_comment
comment|/*  * svi_sm_delete --  *	Delete a line out of the SMAP.  */
end_comment

begin_function
name|int
name|svi_sm_delete
parameter_list|(
name|sp
parameter_list|,
name|ep
parameter_list|,
name|lno
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
name|EXF
modifier|*
name|ep
decl_stmt|;
name|recno_t
name|lno
decl_stmt|;
block|{
name|SMAP
modifier|*
name|p
decl_stmt|,
modifier|*
name|t
decl_stmt|;
name|size_t
name|cnt_orig
decl_stmt|;
comment|/* 	 * Find the line in the map, and count the number of screen lines 	 * which display any part of the deleted line. 	 */
for|for
control|(
name|p
operator|=
name|HMAP
init|;
name|p
operator|->
name|lno
operator|!=
name|lno
condition|;
operator|++
name|p
control|)
empty_stmt|;
for|for
control|(
name|cnt_orig
operator|=
literal|1
operator|,
name|t
operator|=
name|p
operator|+
literal|1
init|;
name|t
operator|<=
name|TMAP
operator|&&
name|t
operator|->
name|lno
operator|==
name|lno
condition|;
operator|++
name|cnt_orig
operator|,
operator|++
name|t
control|)
empty_stmt|;
name|TOO_WEIRD
expr_stmt|;
comment|/* Delete that many lines from the screen. */
name|MOVE
argument_list|(
name|sp
argument_list|,
name|p
operator|-
name|HMAP
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|svi_deleteln
argument_list|(
name|sp
argument_list|,
name|cnt_orig
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* Shift the screen map up. */
name|memmove
argument_list|(
name|p
argument_list|,
name|p
operator|+
name|cnt_orig
argument_list|,
operator|(
operator|(
operator|(
name|TMAP
operator|-
name|p
operator|)
operator|-
name|cnt_orig
operator|)
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|SMAP
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Decrement the line numbers for the rest of the map. */
for|for
control|(
name|t
operator|=
name|TMAP
operator|-
name|cnt_orig
init|;
name|p
operator|<=
name|t
condition|;
operator|++
name|p
control|)
operator|--
name|p
operator|->
name|lno
expr_stmt|;
comment|/* Display the new lines. */
for|for
control|(
name|p
operator|=
name|TMAP
operator|-
name|cnt_orig
init|;
condition|;
control|)
block|{
if|if
condition|(
name|p
operator|<
name|TMAP
operator|&&
name|svi_sm_next
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
name|p
argument_list|,
name|p
operator|+
literal|1
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|svi_line
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
operator|++
name|p
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|p
operator|==
name|TMAP
condition|)
break|break;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * svi_sm_insert --  *	Insert a line into the SMAP.  */
end_comment

begin_function
name|int
name|svi_sm_insert
parameter_list|(
name|sp
parameter_list|,
name|ep
parameter_list|,
name|lno
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
name|EXF
modifier|*
name|ep
decl_stmt|;
name|recno_t
name|lno
decl_stmt|;
block|{
name|SMAP
modifier|*
name|p
decl_stmt|,
modifier|*
name|t
decl_stmt|;
name|size_t
name|cnt_orig
decl_stmt|,
name|cnt
decl_stmt|;
comment|/* 	 * Find the line in the map, find out how many screen lines 	 * needed to display the line. 	 */
for|for
control|(
name|p
operator|=
name|HMAP
init|;
name|p
operator|->
name|lno
operator|!=
name|lno
condition|;
operator|++
name|p
control|)
empty_stmt|;
name|cnt_orig
operator|=
name|svi_screens
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
name|lno
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|TOO_WEIRD
expr_stmt|;
comment|/* 	 * The lines left in the screen override the number of screen 	 * lines in the inserted line. 	 */
name|cnt
operator|=
operator|(
name|TMAP
operator|-
name|p
operator|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|cnt_orig
operator|>
name|cnt
condition|)
name|cnt_orig
operator|=
name|cnt
expr_stmt|;
comment|/* Push down that many lines. */
name|MOVE
argument_list|(
name|sp
argument_list|,
name|p
operator|-
name|HMAP
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|svi_insertln
argument_list|(
name|sp
argument_list|,
name|cnt_orig
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* Shift the screen map down. */
name|memmove
argument_list|(
name|p
operator|+
name|cnt_orig
argument_list|,
name|p
argument_list|,
operator|(
operator|(
operator|(
name|TMAP
operator|-
name|p
operator|)
operator|-
name|cnt_orig
operator|)
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|SMAP
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Increment the line numbers for the rest of the map. */
for|for
control|(
name|t
operator|=
name|p
operator|+
name|cnt_orig
init|;
name|t
operator|<=
name|TMAP
condition|;
operator|++
name|t
control|)
operator|++
name|t
operator|->
name|lno
expr_stmt|;
comment|/* Fill in the SMAP for the new lines, and display. */
for|for
control|(
name|cnt
operator|=
literal|1
operator|,
name|t
operator|=
name|p
init|;
name|cnt
operator|<=
name|cnt_orig
condition|;
operator|++
name|t
operator|,
operator|++
name|cnt
control|)
block|{
name|t
operator|->
name|lno
operator|=
name|lno
expr_stmt|;
name|t
operator|->
name|off
operator|=
name|cnt
expr_stmt|;
if|if
condition|(
name|svi_line
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
name|t
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * svi_sm_reset --  *	Reset a line in the SMAP.  */
end_comment

begin_function
name|int
name|svi_sm_reset
parameter_list|(
name|sp
parameter_list|,
name|ep
parameter_list|,
name|lno
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
name|EXF
modifier|*
name|ep
decl_stmt|;
name|recno_t
name|lno
decl_stmt|;
block|{
name|SMAP
modifier|*
name|p
decl_stmt|,
modifier|*
name|t
decl_stmt|;
name|size_t
name|cnt_orig
decl_stmt|,
name|cnt_new
decl_stmt|,
name|cnt
decl_stmt|,
name|diff
decl_stmt|;
comment|/* 	 * See if the number of on-screen rows taken up by the old display 	 * for the line is the same as the number needed for the new one. 	 * If so, repaint, otherwise do it the hard way. 	 */
for|for
control|(
name|p
operator|=
name|HMAP
init|;
name|p
operator|->
name|lno
operator|!=
name|lno
condition|;
operator|++
name|p
control|)
empty_stmt|;
for|for
control|(
name|cnt_orig
operator|=
literal|0
operator|,
name|t
operator|=
name|p
init|;
name|t
operator|->
name|lno
operator|==
name|lno
operator|&&
name|t
operator|<=
name|TMAP
condition|;
operator|++
name|cnt_orig
operator|,
operator|++
name|t
control|)
empty_stmt|;
name|cnt_new
operator|=
name|svi_screens
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
name|lno
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|TOO_WEIRD
expr_stmt|;
if|if
condition|(
name|cnt_orig
operator|==
name|cnt_new
condition|)
block|{
do|do
block|{
if|if
condition|(
name|svi_line
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
name|p
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
do|while
condition|(
operator|++
name|p
operator|<
name|t
condition|)
do|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|cnt_orig
operator|<
name|cnt_new
condition|)
block|{
comment|/* Get the difference. */
name|diff
operator|=
name|cnt_new
operator|-
name|cnt_orig
expr_stmt|;
comment|/* 		 * The lines left in the screen override the number of screen 		 * lines in the inserted line. 		 */
if|if
condition|(
name|diff
operator|>
name|cnt_orig
condition|)
name|diff
operator|=
name|cnt_orig
expr_stmt|;
comment|/* Push down the extra lines. */
name|MOVE
argument_list|(
name|sp
argument_list|,
name|p
operator|-
name|HMAP
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|svi_insertln
argument_list|(
name|sp
argument_list|,
name|diff
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* Shift the screen map down. */
name|memmove
argument_list|(
name|p
operator|+
name|diff
argument_list|,
name|p
argument_list|,
operator|(
operator|(
operator|(
name|TMAP
operator|-
name|p
operator|)
operator|-
name|diff
operator|)
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|SMAP
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Fill in the SMAP for the replaced line, and display. */
for|for
control|(
name|cnt
operator|=
literal|1
operator|,
name|t
operator|=
name|p
init|;
name|cnt_new
operator|--
operator|&&
name|t
operator|<=
name|TMAP
condition|;
operator|++
name|t
operator|,
operator|++
name|cnt
control|)
block|{
name|t
operator|->
name|lno
operator|=
name|lno
expr_stmt|;
name|t
operator|->
name|off
operator|=
name|cnt
expr_stmt|;
if|if
condition|(
name|svi_line
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
name|t
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
else|else
block|{
comment|/* Get the difference. */
name|diff
operator|=
name|cnt_orig
operator|-
name|cnt_new
expr_stmt|;
comment|/* Delete that many lines from the screen. */
name|MOVE
argument_list|(
name|sp
argument_list|,
name|p
operator|-
name|HMAP
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|svi_deleteln
argument_list|(
name|sp
argument_list|,
name|diff
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* Shift the screen map up. */
name|memmove
argument_list|(
name|p
argument_list|,
name|p
operator|+
name|diff
argument_list|,
operator|(
operator|(
operator|(
name|TMAP
operator|-
name|p
operator|)
operator|-
name|diff
operator|)
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|SMAP
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Fill in the SMAP for the replaced line, and display. */
for|for
control|(
name|cnt
operator|=
literal|1
operator|,
name|t
operator|=
name|p
init|;
name|cnt_new
operator|--
condition|;
operator|++
name|t
operator|,
operator|++
name|cnt
control|)
block|{
name|t
operator|->
name|lno
operator|=
name|lno
expr_stmt|;
name|t
operator|->
name|off
operator|=
name|cnt
expr_stmt|;
if|if
condition|(
name|svi_line
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
name|t
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* Display the new lines at the bottom of the screen. */
for|for
control|(
name|t
operator|=
name|TMAP
operator|-
name|diff
init|;
condition|;
control|)
block|{
if|if
condition|(
name|t
operator|<
name|TMAP
operator|&&
name|svi_sm_next
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
name|t
argument_list|,
name|t
operator|+
literal|1
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|svi_line
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
operator|++
name|t
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|t
operator|==
name|TMAP
condition|)
break|break;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * svi_sm_up --  *	Scroll the SMAP up count logical lines.  */
end_comment

begin_function
name|int
name|svi_sm_up
parameter_list|(
name|sp
parameter_list|,
name|ep
parameter_list|,
name|rp
parameter_list|,
name|count
parameter_list|,
name|cursor_move
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
name|EXF
modifier|*
name|ep
decl_stmt|;
name|MARK
modifier|*
name|rp
decl_stmt|;
name|recno_t
name|count
decl_stmt|;
name|int
name|cursor_move
decl_stmt|;
block|{
name|SMAP
modifier|*
name|p
decl_stmt|,
name|svmap
decl_stmt|,
name|tmp
decl_stmt|;
name|recno_t
name|last
decl_stmt|;
name|int
name|scrolled
decl_stmt|;
comment|/* Set the default return position. */
name|rp
operator|->
name|lno
operator|=
name|sp
operator|->
name|lno
expr_stmt|;
name|rp
operator|->
name|cno
operator|=
name|sp
operator|->
name|cno
expr_stmt|;
comment|/* 	 * There are two forms of this command, one where the cursor follows 	 * the line, and one where it doesn't.  In the latter, we try and keep 	 * the cursor at the same position on the screen, but, if the screen 	 * is small enough and the line length large enough, the cursor can 	 * end up in very strange places.  Probably not worth fixing. 	 * 	 * Find the line in the SMAP. 	 */
for|for
control|(
name|p
operator|=
name|HMAP
init|;
condition|;
operator|++
name|p
control|)
block|{
if|if
condition|(
name|p
operator|>
name|TMAP
condition|)
block|{
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_ERR
argument_list|,
literal|"Line %lu not on the screen."
argument_list|,
name|sp
operator|->
name|lno
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|p
operator|->
name|lno
operator|==
name|sp
operator|->
name|lno
condition|)
break|break;
block|}
if|if
condition|(
name|file_lline
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
operator|&
name|last
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|last
operator|==
literal|0
condition|)
block|{
name|v_eof
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
for|for
control|(
name|svmap
operator|=
operator|*
name|p
operator|,
name|scrolled
operator|=
literal|0
init|;
condition|;
name|scrolled
operator|=
literal|1
control|)
block|{
if|if
condition|(
name|count
operator|==
literal|0
condition|)
break|break;
operator|--
name|count
expr_stmt|;
comment|/* Decide what would show up on the screen. */
if|if
condition|(
name|svi_sm_next
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
name|TMAP
argument_list|,
operator|&
name|tmp
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* If the line doesn't exist, we're done. */
if|if
condition|(
name|tmp
operator|.
name|lno
operator|>
name|last
condition|)
break|break;
comment|/* Scroll up one logical line. */
if|if
condition|(
name|svi_sm_1up
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
operator|!
name|cursor_move
operator|&&
name|p
operator|>
name|HMAP
condition|)
operator|--
name|p
expr_stmt|;
block|}
if|if
condition|(
name|cursor_move
condition|)
block|{
comment|/* 		 * If didn't move enough lines, it's an error if we're at the 		 * EOF, else move there.  Otherwise, try and place the cursor 		 * roughly where it was before. 		 */
if|if
condition|(
operator|!
name|scrolled
operator|||
name|count
condition|)
block|{
if|if
condition|(
name|sp
operator|->
name|lno
operator|==
name|last
condition|)
block|{
name|v_eof
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|last
operator|<
name|TMAP
operator|->
name|lno
condition|)
block|{
for|for
control|(
name|p
operator|=
name|HMAP
init|;
condition|;
operator|++
name|p
control|)
if|if
condition|(
name|p
operator|->
name|lno
operator|==
name|last
condition|)
break|break;
block|}
else|else
name|p
operator|=
name|TMAP
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 		 * If the line itself moved, invalidate the cursor, because 		 * the comparison with the old line/new line won't be right 		 */
name|F_SET
argument_list|(
name|sp
argument_list|,
name|S_CUR_INVALID
argument_list|)
expr_stmt|;
comment|/* It's an error if we didn't scroll enough. */
if|if
condition|(
operator|!
name|scrolled
operator|||
name|count
condition|)
block|{
name|v_eof
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* If the cursor moved off the screen, move it to the top. */
if|if
condition|(
name|sp
operator|->
name|lno
operator|<
name|HMAP
operator|->
name|lno
condition|)
name|p
operator|=
name|HMAP
expr_stmt|;
block|}
comment|/* 	 * On a logical movement, we try and keep the cursor as close as 	 * possible to the last position, but also set it up so that the 	 * next "real" movement will return the cursor to the closest position 	 * to the last real movement. 	 */
if|if
condition|(
name|p
operator|->
name|lno
operator|!=
name|svmap
operator|.
name|lno
operator|||
name|p
operator|->
name|off
operator|!=
name|svmap
operator|.
name|off
condition|)
block|{
name|rp
operator|->
name|lno
operator|=
name|p
operator|->
name|lno
expr_stmt|;
name|rp
operator|->
name|cno
operator|=
name|svi_lrelative
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
name|p
operator|->
name|lno
argument_list|,
name|p
operator|->
name|off
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * svi_sm_1up --  *	Scroll the SMAP up one.  */
end_comment

begin_function
name|int
name|svi_sm_1up
parameter_list|(
name|sp
parameter_list|,
name|ep
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
name|EXF
modifier|*
name|ep
decl_stmt|;
block|{
comment|/* 	 * Delete the top line of the screen.  Shift the screen map up. 	 * Display a new line at the bottom of the screen. 	 */
name|MOVE
argument_list|(
name|sp
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|svi_deleteln
argument_list|(
name|sp
argument_list|,
literal|1
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* One-line screens can fail. */
if|if
condition|(
name|HMAP
operator|==
name|TMAP
condition|)
block|{
if|if
condition|(
name|svi_sm_next
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
name|TMAP
argument_list|,
name|TMAP
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
else|else
block|{
name|memmove
argument_list|(
name|HMAP
argument_list|,
name|HMAP
operator|+
literal|1
argument_list|,
name|sp
operator|->
name|rows
operator|*
sizeof|sizeof
argument_list|(
name|SMAP
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|svi_sm_next
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
name|TMAP
operator|-
literal|1
argument_list|,
name|TMAP
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|svi_line
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
name|TMAP
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * svi_deleteln --  *	Delete a line a la curses, make sure to put the information  *	line and other screens back.  */
end_comment

begin_function
name|int
name|svi_deleteln
parameter_list|(
name|sp
parameter_list|,
name|cnt
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
name|int
name|cnt
decl_stmt|;
block|{
name|size_t
name|oldy
decl_stmt|,
name|oldx
decl_stmt|;
name|getyx
argument_list|(
name|stdscr
argument_list|,
name|oldy
argument_list|,
name|oldx
argument_list|)
expr_stmt|;
while|while
condition|(
name|cnt
operator|--
condition|)
block|{
name|deleteln
argument_list|()
expr_stmt|;
name|MOVE
argument_list|(
name|sp
argument_list|,
name|INFOLINE
argument_list|(
name|sp
argument_list|)
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|insertln
argument_list|()
expr_stmt|;
name|MOVEA
argument_list|(
name|sp
argument_list|,
name|oldy
argument_list|,
name|oldx
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * svi_sm_down --  *	Scroll the SMAP down count logical lines.  */
end_comment

begin_function
name|int
name|svi_sm_down
parameter_list|(
name|sp
parameter_list|,
name|ep
parameter_list|,
name|rp
parameter_list|,
name|count
parameter_list|,
name|cursor_move
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
name|EXF
modifier|*
name|ep
decl_stmt|;
name|MARK
modifier|*
name|rp
decl_stmt|;
name|recno_t
name|count
decl_stmt|;
name|int
name|cursor_move
decl_stmt|;
block|{
name|SMAP
modifier|*
name|p
decl_stmt|,
name|svmap
decl_stmt|;
name|int
name|scrolled
decl_stmt|;
comment|/* Set the default return position. */
name|rp
operator|->
name|lno
operator|=
name|sp
operator|->
name|lno
expr_stmt|;
name|rp
operator|->
name|cno
operator|=
name|sp
operator|->
name|cno
expr_stmt|;
comment|/* 	 * There are two forms of this command, one where the cursor follows 	 * the line, and one where it doesn't.  In the latter, we try and keep 	 * the cursor at the same position on the screen, but, if the screen 	 * is small enough and the line length large enough, the cursor can 	 * end up in very strange places.  Probably not worth fixing. 	 * 	 * Find the line in the SMAP. 	 */
for|for
control|(
name|p
operator|=
name|HMAP
init|;
condition|;
operator|++
name|p
control|)
block|{
if|if
condition|(
name|p
operator|>
name|TMAP
condition|)
block|{
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_ERR
argument_list|,
literal|"Line %lu not on the screen"
argument_list|,
name|sp
operator|->
name|lno
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|p
operator|->
name|lno
operator|==
name|sp
operator|->
name|lno
condition|)
break|break;
block|}
for|for
control|(
name|svmap
operator|=
operator|*
name|p
operator|,
name|scrolled
operator|=
literal|0
init|;
condition|;
name|scrolled
operator|=
literal|1
control|)
block|{
if|if
condition|(
name|count
operator|==
literal|0
condition|)
break|break;
operator|--
name|count
expr_stmt|;
comment|/* If the line doesn't exist, we're done. */
if|if
condition|(
name|HMAP
operator|->
name|lno
operator|==
literal|1
operator|&&
name|HMAP
operator|->
name|off
operator|==
literal|1
condition|)
break|break;
comment|/* Scroll down one logical line. */
if|if
condition|(
name|svi_sm_1down
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
operator|!
name|cursor_move
operator|&&
name|p
operator|<
name|TMAP
condition|)
operator|++
name|p
expr_stmt|;
block|}
if|if
condition|(
name|cursor_move
condition|)
block|{
comment|/* 		 * If didn't move enough lines, it's an error if we're at the 		 * SOF, else move there.  Otherwise, try and place the cursor 		 * roughly where it was before. 		 */
if|if
condition|(
operator|!
name|scrolled
operator|||
name|count
condition|)
block|{
if|if
condition|(
name|sp
operator|->
name|lno
operator|==
name|HMAP
operator|->
name|lno
condition|)
block|{
name|v_sof
argument_list|(
name|sp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|p
operator|=
name|HMAP
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 		 * If the line itself moved, invalidate the cursor, because 		 * the comparison with the old line/new line won't be right 		 */
name|F_SET
argument_list|(
name|sp
argument_list|,
name|S_CUR_INVALID
argument_list|)
expr_stmt|;
comment|/* It's an error if we didn't scroll enough. */
if|if
condition|(
operator|!
name|scrolled
operator|||
name|count
condition|)
block|{
name|v_sof
argument_list|(
name|sp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* If the cursor moved off the screen, move it to the bottom. */
if|if
condition|(
name|sp
operator|->
name|lno
operator|>
name|TMAP
operator|->
name|lno
condition|)
name|p
operator|=
name|TMAP
expr_stmt|;
block|}
comment|/* 	 * On a logical movement, we try and keep the cursor as close as 	 * possible to the last position, but also set it up so that the 	 * next "real" movement will return the cursor to the closest position 	 * to the last real movement. 	 */
if|if
condition|(
name|p
operator|->
name|lno
operator|!=
name|svmap
operator|.
name|lno
operator|||
name|p
operator|->
name|off
operator|!=
name|svmap
operator|.
name|off
condition|)
block|{
name|rp
operator|->
name|lno
operator|=
name|p
operator|->
name|lno
expr_stmt|;
name|rp
operator|->
name|cno
operator|=
name|svi_lrelative
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
name|p
operator|->
name|lno
argument_list|,
name|p
operator|->
name|off
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * svi_sm_1down --  *	Scroll the SMAP down one.  */
end_comment

begin_function
name|int
name|svi_sm_1down
parameter_list|(
name|sp
parameter_list|,
name|ep
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
name|EXF
modifier|*
name|ep
decl_stmt|;
block|{
comment|/* 	 * Clear the bottom line of the screen, insert a line at the top 	 * of the screen.  Shift the screen map down, display a new line 	 * at the top of the screen. 	 */
name|MOVE
argument_list|(
name|sp
argument_list|,
name|sp
operator|->
name|t_rows
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|clrtoeol
argument_list|()
expr_stmt|;
name|MOVE
argument_list|(
name|sp
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|svi_insertln
argument_list|(
name|sp
argument_list|,
literal|1
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|memmove
argument_list|(
name|HMAP
operator|+
literal|1
argument_list|,
name|HMAP
argument_list|,
name|sp
operator|->
name|rows
operator|*
sizeof|sizeof
argument_list|(
name|SMAP
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|svi_sm_prev
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
name|HMAP
operator|+
literal|1
argument_list|,
name|HMAP
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|svi_line
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
name|HMAP
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * svi_insertln --  *	Insert a line a la curses, make sure to put the information  *	line and other screens back.  */
end_comment

begin_function
name|int
name|svi_insertln
parameter_list|(
name|sp
parameter_list|,
name|cnt
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
name|int
name|cnt
decl_stmt|;
block|{
name|size_t
name|oldy
decl_stmt|,
name|oldx
decl_stmt|;
name|getyx
argument_list|(
name|stdscr
argument_list|,
name|oldy
argument_list|,
name|oldx
argument_list|)
expr_stmt|;
while|while
condition|(
name|cnt
operator|--
condition|)
block|{
name|MOVE
argument_list|(
name|sp
argument_list|,
name|INFOLINE
argument_list|(
name|sp
argument_list|)
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|deleteln
argument_list|()
expr_stmt|;
name|MOVEA
argument_list|(
name|sp
argument_list|,
name|oldy
argument_list|,
name|oldx
argument_list|)
expr_stmt|;
name|insertln
argument_list|()
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * svi_sm_next --  *	Fill in the next entry in the SMAP.  */
end_comment

begin_function
name|int
name|svi_sm_next
parameter_list|(
name|sp
parameter_list|,
name|ep
parameter_list|,
name|p
parameter_list|,
name|t
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
name|EXF
modifier|*
name|ep
decl_stmt|;
name|SMAP
modifier|*
name|p
decl_stmt|,
decl|*
name|t
decl_stmt|;
end_function

begin_block
block|{
name|size_t
name|lcnt
decl_stmt|;
if|if
condition|(
name|O_ISSET
argument_list|(
name|sp
argument_list|,
name|O_LEFTRIGHT
argument_list|)
condition|)
block|{
name|t
operator|->
name|lno
operator|=
name|p
operator|->
name|lno
operator|+
literal|1
expr_stmt|;
name|t
operator|->
name|off
operator|=
name|p
operator|->
name|off
expr_stmt|;
block|}
else|else
block|{
name|lcnt
operator|=
name|svi_screens
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
name|p
operator|->
name|lno
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|lcnt
operator|==
name|p
operator|->
name|off
condition|)
block|{
name|t
operator|->
name|lno
operator|=
name|p
operator|->
name|lno
operator|+
literal|1
expr_stmt|;
name|t
operator|->
name|off
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|t
operator|->
name|lno
operator|=
name|p
operator|->
name|lno
expr_stmt|;
name|t
operator|->
name|off
operator|=
name|p
operator|->
name|off
operator|+
literal|1
expr_stmt|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * svi_sm_prev --  *	Fill in the previous entry in the SMAP.  */
end_comment

begin_function
name|int
name|svi_sm_prev
parameter_list|(
name|sp
parameter_list|,
name|ep
parameter_list|,
name|p
parameter_list|,
name|t
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
name|EXF
modifier|*
name|ep
decl_stmt|;
name|SMAP
modifier|*
name|p
decl_stmt|,
decl|*
name|t
decl_stmt|;
end_function

begin_block
block|{
if|if
condition|(
name|O_ISSET
argument_list|(
name|sp
argument_list|,
name|O_LEFTRIGHT
argument_list|)
condition|)
block|{
name|t
operator|->
name|lno
operator|=
name|p
operator|->
name|lno
operator|-
literal|1
expr_stmt|;
name|t
operator|->
name|off
operator|=
name|p
operator|->
name|off
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|p
operator|->
name|off
operator|!=
literal|1
condition|)
block|{
name|t
operator|->
name|lno
operator|=
name|p
operator|->
name|lno
expr_stmt|;
name|t
operator|->
name|off
operator|=
name|p
operator|->
name|off
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|t
operator|->
name|lno
operator|=
name|p
operator|->
name|lno
operator|-
literal|1
expr_stmt|;
name|t
operator|->
name|off
operator|=
name|svi_screens
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
name|t
operator|->
name|lno
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|t
operator|->
name|lno
operator|==
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * svi_sm_position --  *	Return the line number of the top, middle or last line on the screen.  *	(The vi H, M and L commands.)  Here because only the screen routines  *	know what's really out there.  */
end_comment

begin_function
name|int
name|svi_sm_position
parameter_list|(
name|sp
parameter_list|,
name|ep
parameter_list|,
name|lnop
parameter_list|,
name|cnt
parameter_list|,
name|pos
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
name|EXF
modifier|*
name|ep
decl_stmt|;
name|recno_t
modifier|*
name|lnop
decl_stmt|;
name|u_long
name|cnt
decl_stmt|;
name|enum
name|position
name|pos
decl_stmt|;
block|{
name|SMAP
modifier|*
name|p
decl_stmt|,
modifier|*
name|t
decl_stmt|;
name|recno_t
name|down
decl_stmt|,
name|last
decl_stmt|;
switch|switch
condition|(
name|pos
condition|)
block|{
case|case
name|P_TOP
case|:
comment|/* 		 * Note, the top line number may not be at the top of the 		 * screen, because we search for a line that starts on the 		 * screen.  It works that way because that's how the historic 		 * vi behaved. 		 * 		 * Set t to point at the map entry one past the last legal 		 * entry in the map. 		 */
if|if
condition|(
name|file_lline
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
operator|&
name|last
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|TMAP
operator|->
name|lno
operator|<=
name|last
condition|)
name|t
operator|=
name|TMAP
operator|+
literal|1
expr_stmt|;
else|else
for|for
control|(
name|t
operator|=
name|HMAP
init|;
name|t
operator|->
name|lno
operator|<=
name|last
condition|;
operator|++
name|t
control|)
empty_stmt|;
comment|/* Step past cnt start-of-lines, stopping at t. */
for|for
control|(
name|p
operator|=
name|HMAP
operator|-
literal|1
init|;
name|cnt
condition|;
operator|--
name|cnt
control|)
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
operator|++
name|p
operator|==
name|t
condition|)
block|{
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_ERR
argument_list|,
literal|"No such line on the screen."
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|p
operator|->
name|off
operator|==
literal|1
condition|)
break|break;
block|}
operator|*
name|lnop
operator|=
name|p
operator|->
name|lno
expr_stmt|;
break|break;
case|case
name|P_MIDDLE
case|:
comment|/* 		 * Note, the middle line number may not be anywhere near the 		 * middle of the screen, because that's how the historic vi 		 * behaved. 		 * 		 * Check for less than a full screen of lines. 		 */
if|if
condition|(
name|file_lline
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
operator|&
name|last
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|TMAP
operator|->
name|lno
operator|<
name|last
condition|)
name|last
operator|=
name|TMAP
operator|->
name|lno
expr_stmt|;
name|down
operator|=
operator|(
name|last
operator|-
name|HMAP
operator|->
name|lno
operator|+
literal|1
operator|)
operator|/
literal|2
expr_stmt|;
if|if
condition|(
name|down
operator|==
literal|0
operator|&&
name|HMAP
operator|->
name|off
operator|!=
literal|1
condition|)
block|{
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_ERR
argument_list|,
literal|"No such line on the screen."
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
operator|*
name|lnop
operator|=
name|HMAP
operator|->
name|lno
operator|+
name|down
expr_stmt|;
break|break;
case|case
name|P_BOTTOM
case|:
comment|/* Set p to point at the last legal entry in the map. */
if|if
condition|(
name|file_lline
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
operator|&
name|last
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|TMAP
operator|->
name|lno
operator|<=
name|last
condition|)
name|p
operator|=
name|TMAP
operator|+
literal|1
expr_stmt|;
else|else
for|for
control|(
name|p
operator|=
name|HMAP
init|;
name|p
operator|->
name|lno
operator|<=
name|last
condition|;
operator|++
name|p
control|)
empty_stmt|;
comment|/* Step past cnt start-of-lines, stopping at HMAP. */
for|for
control|(
init|;
name|cnt
condition|;
operator|--
name|cnt
control|)
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
operator|--
name|p
operator|<
name|HMAP
condition|)
block|{
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_ERR
argument_list|,
literal|"No such line on the screen."
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|p
operator|->
name|off
operator|==
literal|1
condition|)
break|break;
block|}
operator|*
name|lnop
operator|=
name|p
operator|->
name|lno
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * svi_sm_nlines --  *	Return the number of screen lines from an SMAP entry to the  *	start of some file line, less than a maximum value.  */
end_comment

begin_function
name|recno_t
name|svi_sm_nlines
parameter_list|(
name|sp
parameter_list|,
name|ep
parameter_list|,
name|from_sp
parameter_list|,
name|to_lno
parameter_list|,
name|max
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
name|EXF
modifier|*
name|ep
decl_stmt|;
name|SMAP
modifier|*
name|from_sp
decl_stmt|;
name|recno_t
name|to_lno
decl_stmt|;
name|size_t
name|max
decl_stmt|;
block|{
name|recno_t
name|lno
decl_stmt|,
name|lcnt
decl_stmt|;
if|if
condition|(
name|O_ISSET
argument_list|(
name|sp
argument_list|,
name|O_LEFTRIGHT
argument_list|)
condition|)
if|if
condition|(
name|from_sp
operator|->
name|lno
operator|>
name|to_lno
condition|)
return|return
operator|(
name|from_sp
operator|->
name|lno
operator|-
name|to_lno
operator|)
return|;
else|else
return|return
operator|(
name|to_lno
operator|-
name|from_sp
operator|->
name|lno
operator|)
return|;
if|if
condition|(
name|from_sp
operator|->
name|lno
operator|==
name|to_lno
condition|)
return|return
operator|(
name|from_sp
operator|->
name|off
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|from_sp
operator|->
name|lno
operator|>
name|to_lno
condition|)
block|{
name|lcnt
operator|=
name|from_sp
operator|->
name|off
operator|-
literal|1
expr_stmt|;
comment|/* Correct for off-by-one. */
for|for
control|(
name|lno
operator|=
name|from_sp
operator|->
name|lno
init|;
operator|--
name|lno
operator|>=
name|to_lno
operator|&&
name|lcnt
operator|<=
name|max
condition|;
control|)
name|lcnt
operator|+=
name|svi_screens
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
name|lno
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|lno
operator|=
name|from_sp
operator|->
name|lno
expr_stmt|;
name|lcnt
operator|=
operator|(
name|svi_screens
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
name|lno
argument_list|,
name|NULL
argument_list|)
operator|-
name|from_sp
operator|->
name|off
operator|)
operator|+
literal|1
expr_stmt|;
for|for
control|(
init|;
operator|++
name|lno
operator|<
name|to_lno
operator|&&
name|lcnt
operator|<=
name|max
condition|;
control|)
name|lcnt
operator|+=
name|svi_screens
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
name|lno
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|lcnt
operator|)
return|;
block|}
end_function

end_unit

