begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1992, 1993  *	The Regents of the University of California.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by the University of  *	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)v_word.c	8.1 (Berkeley) 6/9/93"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|"vi.h"
end_include

begin_include
include|#
directive|include
file|"vcmd.h"
end_include

begin_comment
comment|/*  * There are two types of "words".  Bigwords are easy -- groups of anything  * delimited by whitespace.  Normal words are trickier.  They are either a  * group of characters, numbers and underscores, or a group of anything but,  * delimited by whitespace.  When for a word, if you're in whitespace, it's  * easy, just remove the whitespace and go to the beginning or end of the  * word.  Otherwise, figure out if the next character is in a different group.  * If it is, go to the beginning or end of that group, otherwise, go to the  * beginning or end of the current group.  The historic version of vi didn't  * get this right.  To get it right you have to resolve the cursor after each  * search so that the look-ahead to figure out what type of "word" the cursor  * is in will be correct.  *  * Empty lines count as a single word, and the beginning and end of the file  * counts as an infinite number of words.  */
end_comment

begin_define
define|#
directive|define
name|FW
parameter_list|(
name|test
parameter_list|)
value|for (; len&& (test); --len, ++p)
end_define

begin_define
define|#
directive|define
name|BW
parameter_list|(
name|test
parameter_list|)
value|for (; len&& (test); --len, --p)
end_define

begin_decl_stmt
specifier|static
name|int
name|bword
name|__P
argument_list|(
operator|(
name|SCR
operator|*
operator|,
name|EXF
operator|*
operator|,
name|VICMDARG
operator|*
operator|,
name|MARK
operator|*
operator|,
name|MARK
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|eword
name|__P
argument_list|(
operator|(
name|SCR
operator|*
operator|,
name|EXF
operator|*
operator|,
name|VICMDARG
operator|*
operator|,
name|MARK
operator|*
operator|,
name|MARK
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|fword
name|__P
argument_list|(
operator|(
name|SCR
operator|*
operator|,
name|EXF
operator|*
operator|,
name|VICMDARG
operator|*
operator|,
name|MARK
operator|*
operator|,
name|MARK
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * v_wordw -- [count]w  *	Move forward a word at a time.  */
end_comment

begin_function
name|int
name|v_wordw
parameter_list|(
name|sp
parameter_list|,
name|ep
parameter_list|,
name|vp
parameter_list|,
name|fm
parameter_list|,
name|tm
parameter_list|,
name|rp
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
name|EXF
modifier|*
name|ep
decl_stmt|;
name|VICMDARG
modifier|*
name|vp
decl_stmt|;
name|MARK
modifier|*
name|fm
decl_stmt|,
decl|*
name|tm
decl_stmt|,
modifier|*
name|rp
decl_stmt|;
end_function

begin_block
block|{
return|return
operator|(
name|fword
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
name|vp
argument_list|,
name|fm
argument_list|,
name|rp
argument_list|,
literal|0
argument_list|)
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * v_wordW -- [count]W  *	Move forward a bigword at a time.  */
end_comment

begin_function
name|int
name|v_wordW
parameter_list|(
name|sp
parameter_list|,
name|ep
parameter_list|,
name|vp
parameter_list|,
name|fm
parameter_list|,
name|tm
parameter_list|,
name|rp
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
name|EXF
modifier|*
name|ep
decl_stmt|;
name|VICMDARG
modifier|*
name|vp
decl_stmt|;
name|MARK
modifier|*
name|fm
decl_stmt|,
decl|*
name|tm
decl_stmt|,
modifier|*
name|rp
decl_stmt|;
end_function

begin_block
block|{
return|return
operator|(
name|fword
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
name|vp
argument_list|,
name|fm
argument_list|,
name|rp
argument_list|,
literal|1
argument_list|)
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * fword --  *	Move forward by words.  */
end_comment

begin_function
specifier|static
name|int
name|fword
parameter_list|(
name|sp
parameter_list|,
name|ep
parameter_list|,
name|vp
parameter_list|,
name|fm
parameter_list|,
name|rp
parameter_list|,
name|spaceonly
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
name|EXF
modifier|*
name|ep
decl_stmt|;
name|VICMDARG
modifier|*
name|vp
decl_stmt|;
name|MARK
modifier|*
name|fm
decl_stmt|,
decl|*
name|rp
decl_stmt|;
end_function

begin_decl_stmt
name|int
name|spaceonly
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|recno_t
name|lno
decl_stmt|;
name|size_t
name|len
decl_stmt|,
name|llen
decl_stmt|;
name|u_long
name|cno
decl_stmt|,
name|cnt
decl_stmt|;
name|int
name|empty
decl_stmt|;
name|char
modifier|*
name|startp
decl_stmt|;
name|lno
operator|=
name|fm
operator|->
name|lno
expr_stmt|;
name|cno
operator|=
name|fm
operator|->
name|cno
expr_stmt|;
if|if
condition|(
operator|(
name|p
operator|=
name|file_gline
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
name|lno
argument_list|,
operator|&
name|llen
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|file_lline
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
operator|&
name|lno
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|lno
operator|==
literal|0
condition|)
name|v_eof
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
else|else
name|GETLINE_ERR
argument_list|(
name|sp
argument_list|,
name|lno
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|cnt
operator|=
name|F_ISSET
argument_list|(
name|vp
argument_list|,
name|VC_C1SET
argument_list|)
condition|?
name|vp
operator|->
name|count
else|:
literal|1
expr_stmt|;
comment|/* 	 * Reset the length; the first character is the current cursor 	 * position.  If no more characters in this line, may already 	 * be at EOF. 	 * 	 * Note, there are several special cases.  Movements associated 	 * with commands are slightly different than movement commands. 	 * For example, in "abc def ghi", "cw" is from 'a' to 'c', while 	 * "w" is from 'a' to 'd'.  "Bill, it's another ugly tale from 	 * BSD's ugliest city." 	 */
name|len
operator|=
name|llen
operator|-
name|cno
expr_stmt|;
name|empty
operator|=
name|llen
operator|==
literal|0
operator|||
name|llen
operator|==
name|cno
operator|+
literal|1
expr_stmt|;
for|for
control|(
name|startp
operator|=
name|p
operator|+=
name|cno
init|;
name|cnt
operator|--
condition|;
name|empty
operator|=
literal|0
control|)
block|{
if|if
condition|(
name|len
operator|!=
literal|0
condition|)
if|if
condition|(
name|spaceonly
condition|)
block|{
name|FW
argument_list|(
operator|!
name|isspace
argument_list|(
operator|*
name|p
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 'c' and 'y' don't skip more space. */
if|if
condition|(
name|cnt
operator|==
literal|0
operator|&&
name|F_ISSET
argument_list|(
name|vp
argument_list|,
name|VC_C
operator||
name|VC_Y
argument_list|)
condition|)
break|break;
name|FW
argument_list|(
name|isspace
argument_list|(
operator|*
name|p
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|inword
argument_list|(
operator|*
name|p
argument_list|)
condition|)
name|FW
argument_list|(
name|inword
argument_list|(
operator|*
name|p
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|FW
argument_list|(
operator|!
name|isspace
argument_list|(
operator|*
name|p
argument_list|)
operator|&&
operator|!
name|inword
argument_list|(
operator|*
name|p
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 'c' and 'y' don't skip more space. */
if|if
condition|(
name|cnt
operator|==
literal|0
operator|&&
name|F_ISSET
argument_list|(
name|vp
argument_list|,
name|VC_C
operator||
name|VC_Y
argument_list|)
condition|)
break|break;
name|FW
argument_list|(
name|isspace
argument_list|(
operator|*
name|p
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * 'c', 'd' and 'y' don't move into the next line unless 		 * this line was empty. 		 */
if|if
condition|(
name|cnt
operator|==
literal|0
operator|&&
name|llen
operator|!=
literal|0
operator|&&
name|F_ISSET
argument_list|(
name|vp
argument_list|,
name|VC_C
operator||
name|VC_D
operator||
name|VC_Y
argument_list|)
condition|)
break|break;
if|if
condition|(
name|len
operator|==
literal|0
condition|)
block|{
comment|/* If we hit EOF, stay there (historic practice). */
if|if
condition|(
operator|(
name|p
operator|=
name|file_gline
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
operator|++
name|lno
argument_list|,
operator|&
name|llen
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
comment|/* 				 * Complain if were already at eof, unless 				 * it's a change command. 				 */
if|if
condition|(
name|empty
operator|&&
operator|!
name|F_ISSET
argument_list|(
name|vp
argument_list|,
name|VC_C
argument_list|)
condition|)
block|{
name|v_eof
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|p
operator|=
name|file_gline
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
operator|--
name|lno
argument_list|,
operator|&
name|llen
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|GETLINE_ERR
argument_list|(
name|sp
argument_list|,
name|lno
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|rp
operator|->
name|lno
operator|=
name|lno
expr_stmt|;
comment|/* 'c', 'd', and 'y' move 1 past EOF. */
name|rp
operator|->
name|cno
operator|=
name|llen
condition|?
name|F_ISSET
argument_list|(
name|vp
argument_list|,
name|VC_C
operator||
name|VC_D
operator||
name|VC_Y
argument_list|)
condition|?
name|llen
else|:
name|llen
operator|-
literal|1
else|:
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|len
operator|=
name|llen
expr_stmt|;
name|cno
operator|=
literal|0
expr_stmt|;
name|startp
operator|=
name|p
expr_stmt|;
comment|/* Skip leading space to first word. */
name|FW
argument_list|(
name|isspace
argument_list|(
operator|*
name|p
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|rp
operator|->
name|lno
operator|=
name|lno
expr_stmt|;
name|rp
operator|->
name|cno
operator|=
name|cno
operator|+
operator|(
name|p
operator|-
name|startp
operator|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * v_wordb -- [count]b  *	Move backward a word at a time.  */
end_comment

begin_function
name|int
name|v_wordb
parameter_list|(
name|sp
parameter_list|,
name|ep
parameter_list|,
name|vp
parameter_list|,
name|fm
parameter_list|,
name|tm
parameter_list|,
name|rp
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
name|EXF
modifier|*
name|ep
decl_stmt|;
name|VICMDARG
modifier|*
name|vp
decl_stmt|;
name|MARK
modifier|*
name|fm
decl_stmt|,
decl|*
name|tm
decl_stmt|,
modifier|*
name|rp
decl_stmt|;
end_function

begin_block
block|{
return|return
operator|(
name|bword
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
name|vp
argument_list|,
name|fm
argument_list|,
name|rp
argument_list|,
literal|0
argument_list|)
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * v_WordB -- [count]B  *	Move backward a bigword at a time.  */
end_comment

begin_function
name|int
name|v_wordB
parameter_list|(
name|sp
parameter_list|,
name|ep
parameter_list|,
name|vp
parameter_list|,
name|fm
parameter_list|,
name|tm
parameter_list|,
name|rp
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
name|EXF
modifier|*
name|ep
decl_stmt|;
name|VICMDARG
modifier|*
name|vp
decl_stmt|;
name|MARK
modifier|*
name|fm
decl_stmt|,
decl|*
name|tm
decl_stmt|,
modifier|*
name|rp
decl_stmt|;
end_function

begin_block
block|{
return|return
operator|(
name|bword
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
name|vp
argument_list|,
name|fm
argument_list|,
name|rp
argument_list|,
literal|1
argument_list|)
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * bword --  *	Move backward by words.  */
end_comment

begin_function
specifier|static
name|int
name|bword
parameter_list|(
name|sp
parameter_list|,
name|ep
parameter_list|,
name|vp
parameter_list|,
name|fm
parameter_list|,
name|rp
parameter_list|,
name|spaceonly
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
name|EXF
modifier|*
name|ep
decl_stmt|;
name|VICMDARG
modifier|*
name|vp
decl_stmt|;
name|MARK
modifier|*
name|fm
decl_stmt|,
decl|*
name|rp
decl_stmt|;
end_function

begin_decl_stmt
name|int
name|spaceonly
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|recno_t
name|lno
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|u_long
name|cno
decl_stmt|,
name|cnt
decl_stmt|;
name|char
modifier|*
name|startp
decl_stmt|;
name|lno
operator|=
name|fm
operator|->
name|lno
expr_stmt|;
name|cno
operator|=
name|fm
operator|->
name|cno
expr_stmt|;
comment|/* Check for start of file. */
if|if
condition|(
name|lno
operator|==
literal|1
operator|&&
name|cno
operator|==
literal|0
condition|)
block|{
name|v_sof
argument_list|(
name|sp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|p
operator|=
name|file_gline
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
name|lno
argument_list|,
operator|&
name|len
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|file_lline
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
operator|&
name|lno
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|lno
operator|==
literal|0
condition|)
name|v_sof
argument_list|(
name|sp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
else|else
name|GETLINE_ERR
argument_list|(
name|sp
argument_list|,
name|lno
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|cnt
operator|=
name|F_ISSET
argument_list|(
name|vp
argument_list|,
name|VC_C1SET
argument_list|)
condition|?
name|vp
operator|->
name|count
else|:
literal|1
expr_stmt|;
comment|/* 	 * Reset the length to the number of characters in the line; the 	 * first character is the current cursor position. 	 */
name|len
operator|=
name|cno
condition|?
name|cno
operator|+
literal|1
else|:
literal|0
expr_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
condition|)
goto|goto
name|line
goto|;
for|for
control|(
name|startp
operator|=
name|p
operator|,
name|p
operator|+=
name|cno
init|;
name|cnt
operator|--
condition|;
control|)
block|{
if|if
condition|(
name|spaceonly
condition|)
block|{
if|if
condition|(
operator|!
name|isspace
argument_list|(
operator|*
name|p
argument_list|)
condition|)
block|{
if|if
condition|(
name|len
operator|<
literal|2
condition|)
goto|goto
name|line
goto|;
operator|--
name|p
expr_stmt|;
operator|--
name|len
expr_stmt|;
block|}
name|BW
argument_list|(
name|isspace
argument_list|(
operator|*
name|p
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
condition|)
name|BW
argument_list|(
operator|!
name|isspace
argument_list|(
operator|*
name|p
argument_list|)
argument_list|)
expr_stmt|;
else|else
goto|goto
name|line
goto|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|isspace
argument_list|(
operator|*
name|p
argument_list|)
condition|)
block|{
if|if
condition|(
name|len
operator|<
literal|2
condition|)
goto|goto
name|line
goto|;
operator|--
name|p
expr_stmt|;
operator|--
name|len
expr_stmt|;
block|}
name|BW
argument_list|(
name|isspace
argument_list|(
operator|*
name|p
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
condition|)
if|if
condition|(
name|inword
argument_list|(
operator|*
name|p
argument_list|)
condition|)
name|BW
argument_list|(
name|inword
argument_list|(
operator|*
name|p
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|BW
argument_list|(
operator|!
name|isspace
argument_list|(
operator|*
name|p
argument_list|)
operator|&&
operator|!
name|inword
argument_list|(
operator|*
name|p
argument_list|)
argument_list|)
expr_stmt|;
else|else
goto|goto
name|line
goto|;
block|}
if|if
condition|(
name|cnt
operator|&&
name|len
operator|==
literal|0
condition|)
block|{
comment|/* If we hit SOF, stay there (historic practice). */
name|line
label|:
if|if
condition|(
name|lno
operator|==
literal|1
condition|)
block|{
name|rp
operator|->
name|lno
operator|=
literal|1
expr_stmt|;
name|rp
operator|->
name|cno
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 			 * Get the line.  If the line is empty, decrement 			 * count and get another one. 			 */
if|if
condition|(
operator|(
name|p
operator|=
name|file_gline
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
operator|--
name|lno
argument_list|,
operator|&
name|len
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|GETLINE_ERR
argument_list|(
name|sp
argument_list|,
name|lno
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|len
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|cnt
operator|==
literal|0
operator|||
operator|--
name|cnt
operator|==
literal|0
condition|)
block|{
name|rp
operator|->
name|lno
operator|=
name|lno
expr_stmt|;
name|rp
operator|->
name|cno
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
goto|goto
name|line
goto|;
block|}
comment|/* 			 * Set the cursor to the end of the line.  If the word 			 * at the end of this line has only a single character, 			 * we've already skipped over it. 			 */
name|startp
operator|=
name|p
expr_stmt|;
if|if
condition|(
name|len
condition|)
block|{
name|p
operator|+=
name|len
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|cnt
operator|&&
name|len
operator|>
literal|1
operator|&&
operator|!
name|isspace
argument_list|(
name|p
index|[
literal|0
index|]
argument_list|)
condition|)
if|if
condition|(
name|inword
argument_list|(
name|p
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|inword
argument_list|(
name|p
index|[
operator|-
literal|1
index|]
argument_list|)
condition|)
operator|--
name|cnt
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|isspace
argument_list|(
name|p
index|[
operator|-
literal|1
index|]
argument_list|)
operator|&&
operator|!
name|inword
argument_list|(
name|p
index|[
operator|-
literal|1
index|]
argument_list|)
condition|)
operator|--
name|cnt
expr_stmt|;
block|}
block|}
else|else
block|{
operator|++
name|p
expr_stmt|;
operator|++
name|len
expr_stmt|;
block|}
block|}
name|rp
operator|->
name|lno
operator|=
name|lno
expr_stmt|;
name|rp
operator|->
name|cno
operator|=
name|p
operator|-
name|startp
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * v_worde -- [count]e  *	Move forward to the end of the word.  */
end_comment

begin_function
name|int
name|v_worde
parameter_list|(
name|sp
parameter_list|,
name|ep
parameter_list|,
name|vp
parameter_list|,
name|fm
parameter_list|,
name|tm
parameter_list|,
name|rp
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
name|EXF
modifier|*
name|ep
decl_stmt|;
name|VICMDARG
modifier|*
name|vp
decl_stmt|;
name|MARK
modifier|*
name|fm
decl_stmt|,
decl|*
name|tm
decl_stmt|,
modifier|*
name|rp
decl_stmt|;
end_function

begin_block
block|{
return|return
operator|(
name|eword
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
name|vp
argument_list|,
name|fm
argument_list|,
name|rp
argument_list|,
literal|0
argument_list|)
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * v_wordE -- [count]E  *	Move forward to the end of the bigword.  */
end_comment

begin_function
name|int
name|v_wordE
parameter_list|(
name|sp
parameter_list|,
name|ep
parameter_list|,
name|vp
parameter_list|,
name|fm
parameter_list|,
name|tm
parameter_list|,
name|rp
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
name|EXF
modifier|*
name|ep
decl_stmt|;
name|VICMDARG
modifier|*
name|vp
decl_stmt|;
name|MARK
modifier|*
name|fm
decl_stmt|,
decl|*
name|tm
decl_stmt|,
modifier|*
name|rp
decl_stmt|;
end_function

begin_block
block|{
return|return
operator|(
name|eword
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
name|vp
argument_list|,
name|fm
argument_list|,
name|rp
argument_list|,
literal|1
argument_list|)
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * eword --  *	Move forward to the end of the word.  */
end_comment

begin_function
specifier|static
name|int
name|eword
parameter_list|(
name|sp
parameter_list|,
name|ep
parameter_list|,
name|vp
parameter_list|,
name|fm
parameter_list|,
name|rp
parameter_list|,
name|spaceonly
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
name|EXF
modifier|*
name|ep
decl_stmt|;
name|VICMDARG
modifier|*
name|vp
decl_stmt|;
name|MARK
modifier|*
name|fm
decl_stmt|,
decl|*
name|rp
decl_stmt|;
end_function

begin_decl_stmt
name|int
name|spaceonly
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|recno_t
name|lno
decl_stmt|;
name|size_t
name|len
decl_stmt|,
name|llen
decl_stmt|;
name|u_long
name|cno
decl_stmt|,
name|cnt
decl_stmt|;
name|int
name|empty
decl_stmt|;
name|char
modifier|*
name|startp
decl_stmt|;
name|lno
operator|=
name|fm
operator|->
name|lno
expr_stmt|;
name|cno
operator|=
name|fm
operator|->
name|cno
expr_stmt|;
if|if
condition|(
operator|(
name|p
operator|=
name|file_gline
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
name|lno
argument_list|,
operator|&
name|llen
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|file_lline
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
operator|&
name|lno
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|lno
operator|==
literal|0
condition|)
name|v_eof
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
else|else
name|GETLINE_ERR
argument_list|(
name|sp
argument_list|,
name|lno
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|cnt
operator|=
name|F_ISSET
argument_list|(
name|vp
argument_list|,
name|VC_C1SET
argument_list|)
condition|?
name|vp
operator|->
name|count
else|:
literal|1
expr_stmt|;
comment|/* 	 * Reset the length; the first character is the current cursor 	 * position.  If no more characters in this line, may already 	 * be at EOF. 	 */
name|len
operator|=
name|llen
operator|-
name|cno
expr_stmt|;
if|if
condition|(
name|empty
operator|=
name|llen
operator|==
literal|0
operator|||
name|llen
operator|==
name|cno
operator|+
literal|1
condition|)
goto|goto
name|line
goto|;
for|for
control|(
name|startp
operator|=
name|p
operator|+=
name|cno
init|;
name|cnt
operator|--
condition|;
name|empty
operator|=
literal|0
control|)
block|{
if|if
condition|(
name|spaceonly
condition|)
block|{
if|if
condition|(
operator|!
name|isspace
argument_list|(
operator|*
name|p
argument_list|)
condition|)
block|{
if|if
condition|(
name|len
operator|<
literal|2
condition|)
goto|goto
name|line
goto|;
operator|++
name|p
expr_stmt|;
operator|--
name|len
expr_stmt|;
block|}
name|FW
argument_list|(
name|isspace
argument_list|(
operator|*
name|p
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
condition|)
name|FW
argument_list|(
operator|!
name|isspace
argument_list|(
operator|*
name|p
argument_list|)
argument_list|)
expr_stmt|;
else|else
operator|++
name|cnt
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|isspace
argument_list|(
operator|*
name|p
argument_list|)
condition|)
block|{
if|if
condition|(
name|len
operator|<
literal|2
condition|)
goto|goto
name|line
goto|;
operator|++
name|p
expr_stmt|;
operator|--
name|len
expr_stmt|;
block|}
name|FW
argument_list|(
name|isspace
argument_list|(
operator|*
name|p
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
condition|)
if|if
condition|(
name|inword
argument_list|(
operator|*
name|p
argument_list|)
condition|)
name|FW
argument_list|(
name|inword
argument_list|(
operator|*
name|p
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|FW
argument_list|(
operator|!
name|isspace
argument_list|(
operator|*
name|p
argument_list|)
operator|&&
operator|!
name|inword
argument_list|(
operator|*
name|p
argument_list|)
argument_list|)
expr_stmt|;
else|else
operator|++
name|cnt
expr_stmt|;
block|}
if|if
condition|(
name|cnt
operator|&&
name|len
operator|==
literal|0
condition|)
block|{
comment|/* If we hit EOF, stay there (historic practice). */
name|line
label|:
if|if
condition|(
operator|(
name|p
operator|=
name|file_gline
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
operator|++
name|lno
argument_list|,
operator|&
name|llen
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
comment|/* 				 * If already at eof, complain, unless it's 				 * a change command or a delete command and 				 * there's something to delete. 				 */
if|if
condition|(
name|empty
condition|)
block|{
if|if
condition|(
name|F_ISSET
argument_list|(
name|vp
argument_list|,
name|VC_C
argument_list|)
operator|||
name|F_ISSET
argument_list|(
name|vp
argument_list|,
name|VC_D
argument_list|)
operator|&&
name|llen
operator|!=
literal|0
condition|)
block|{
name|rp
operator|->
name|lno
operator|=
name|lno
operator|-
literal|1
expr_stmt|;
name|rp
operator|->
name|cno
operator|=
name|llen
condition|?
name|llen
else|:
literal|1
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|v_eof
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|p
operator|=
name|file_gline
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
operator|--
name|lno
argument_list|,
operator|&
name|llen
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|GETLINE_ERR
argument_list|(
name|sp
argument_list|,
name|lno
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|rp
operator|->
name|lno
operator|=
name|lno
expr_stmt|;
name|rp
operator|->
name|cno
operator|=
name|llen
condition|?
name|llen
operator|-
literal|1
else|:
literal|0
expr_stmt|;
comment|/* The 'c', 'd' and 'y' need one more space. */
if|if
condition|(
name|F_ISSET
argument_list|(
name|vp
argument_list|,
name|VC_C
operator||
name|VC_D
operator||
name|VC_Y
argument_list|)
condition|)
operator|++
name|rp
operator|->
name|cno
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|len
operator|=
name|llen
expr_stmt|;
name|cno
operator|=
literal|0
expr_stmt|;
name|startp
operator|=
name|p
expr_stmt|;
block|}
else|else
block|{
operator|--
name|p
expr_stmt|;
operator|++
name|len
expr_stmt|;
block|}
block|}
name|rp
operator|->
name|lno
operator|=
name|lno
expr_stmt|;
name|rp
operator|->
name|cno
operator|=
name|cno
operator|+
operator|(
name|p
operator|-
name|startp
operator|)
expr_stmt|;
comment|/* The 'c', 'd' and 'y' need one more space. */
if|if
condition|(
name|F_ISSET
argument_list|(
name|vp
argument_list|,
name|VC_C
operator||
name|VC_D
operator||
name|VC_Y
argument_list|)
condition|)
operator|++
name|rp
operator|->
name|cno
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

end_unit

