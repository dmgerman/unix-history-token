begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1993  *	The Regents of the University of California.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by the University of  *	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)v_ntext.c	8.1 (Berkeley) 6/9/93"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|"vi.h"
end_include

begin_include
include|#
directive|include
file|"vcmd.h"
end_include

begin_decl_stmt
specifier|static
name|int
name|txt_abbrev
name|__P
argument_list|(
operator|(
name|SCR
operator|*
operator|,
name|TEXT
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|TEXT
modifier|*
name|txt_backup
name|__P
argument_list|(
operator|(
name|SCR
operator|*
operator|,
name|EXF
operator|*
operator|,
name|HDR
operator|*
operator|,
name|TEXT
operator|*
operator|,
name|u_int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|txt_err
name|__P
argument_list|(
operator|(
name|SCR
operator|*
operator|,
name|EXF
operator|*
operator|,
name|HDR
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|txt_indent
name|__P
argument_list|(
operator|(
name|SCR
operator|*
operator|,
name|TEXT
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|txt_outdent
name|__P
argument_list|(
operator|(
name|SCR
operator|*
operator|,
name|TEXT
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|txt_resolve
name|__P
argument_list|(
operator|(
name|SCR
operator|*
operator|,
name|EXF
operator|*
operator|,
name|HDR
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Cursor character (space is hard to track on the screen). */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_define
define|#
directive|define
name|CURSOR_CHAR
value|'+'
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CURSOR_CHAR
value|' '
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Error jump. */
end_comment

begin_define
define|#
directive|define
name|ERR
value|{								\ 	eval = 1;							\ 	txt_err(sp, ep, hp);						\ 	goto ret;							\ }
end_define

begin_comment
comment|/* Local version of BINC. */
end_comment

begin_define
define|#
directive|define
name|TBINC
parameter_list|(
name|sp
parameter_list|,
name|lp
parameter_list|,
name|llen
parameter_list|,
name|nlen
parameter_list|)
value|{					\ 	if ((nlen)> llen&& binc(sp,&(lp),&(llen), nlen))		\ 		ERR;							\ }
end_define

begin_comment
comment|/*  * newtext --  *	Read in text from the user.  */
end_comment

begin_function
name|int
name|v_ntext
parameter_list|(
name|sp
parameter_list|,
name|ep
parameter_list|,
name|hp
parameter_list|,
name|tm
parameter_list|,
name|p
parameter_list|,
name|len
parameter_list|,
name|rp
parameter_list|,
name|prompt
parameter_list|,
name|ai_line
parameter_list|,
name|flags
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
name|EXF
modifier|*
name|ep
decl_stmt|;
name|HDR
modifier|*
name|hp
decl_stmt|;
name|MARK
modifier|*
name|tm
decl_stmt|;
comment|/* To MARK. */
name|char
modifier|*
name|p
decl_stmt|;
comment|/* Input line. */
name|size_t
name|len
decl_stmt|;
comment|/* Input line length. */
name|MARK
modifier|*
name|rp
decl_stmt|;
comment|/* Return MARK. */
name|int
name|prompt
decl_stmt|;
comment|/* Prompt to display. */
name|recno_t
name|ai_line
decl_stmt|;
comment|/* Line number to use for autoindent count. */
name|u_int
name|flags
decl_stmt|;
comment|/* TXT_ flags. */
block|{
comment|/* State of the "[^0]^D" sequences. */
enum|enum
block|{
name|C_CARATSET
block|,
name|C_NOCHANGE
block|,
name|C_NOTSET
block|,
name|C_ZEROSET
block|}
name|carat_st
enum|;
comment|/* State of quotation. */
enum|enum
block|{
name|Q_NOTSET
block|,
name|Q_NEXTCHAR
block|,
name|Q_THISCHAR
block|}
name|quoted
enum|;
comment|/* State of abbreviation checks. */
enum|enum
block|{
name|L_NOCHECK
block|,
name|L_SPACE
block|,
name|L_NOTSPACE
block|}
name|lch
enum|;
name|TEXT
modifier|*
name|tp
decl_stmt|,
modifier|*
name|ntp
decl_stmt|;
comment|/* Input text structures. */
name|TEXT
modifier|*
name|aitp
decl_stmt|;
comment|/* Autoindent text structure. */
name|size_t
name|rcol
decl_stmt|;
comment|/* 0-N: insert offset in the replay buffer. */
name|int
name|ch
decl_stmt|;
comment|/* Input character. */
name|int
name|eval
decl_stmt|;
comment|/* Routine return value. */
name|int
name|replay
decl_stmt|;
comment|/* If replaying a set of input. */
name|int
name|tty_cwait
decl_stmt|;
comment|/* Characters waiting. */
name|int
name|max
decl_stmt|,
name|tmp
decl_stmt|;
comment|/* Set the input flag, so tabs get displayed correctly. */
name|F_SET
argument_list|(
name|sp
argument_list|,
name|S_INPUT
argument_list|)
expr_stmt|;
comment|/* Set text buffer in-use flag. */
name|F_SET
argument_list|(
name|hp
argument_list|,
name|HDR_INUSE
argument_list|)
expr_stmt|;
comment|/* Set return value. */
name|eval
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Get one TEXT structure with some initial buffer space, reusing 	 * the last one if it's big enough.  (All TEXT bookkeeping fields 	 * default to 0 -- text_init() handles this.)  If changing a line, 	 * copy it into the TEXT buffer. 	 */
if|if
condition|(
name|hp
operator|->
name|next
operator|!=
name|hp
condition|)
block|{
name|tp
operator|=
name|hp
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|next
operator|!=
operator|(
name|TEXT
operator|*
operator|)
name|hp
operator|||
name|tp
operator|->
name|lb_len
operator|<
name|len
operator|+
literal|32
condition|)
block|{
name|hdr_text_free
argument_list|(
name|hp
argument_list|)
expr_stmt|;
goto|goto
name|newtp
goto|;
block|}
name|tp
operator|->
name|ai
operator|=
name|tp
operator|->
name|insert
operator|=
name|tp
operator|->
name|offset
operator|=
name|tp
operator|->
name|overwrite
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
block|{
name|tp
operator|->
name|len
operator|=
name|len
expr_stmt|;
name|memmove
argument_list|(
name|tp
operator|->
name|lb
argument_list|,
name|p
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
else|else
name|tp
operator|->
name|len
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|newtp
label|:
if|if
condition|(
operator|(
name|tp
operator|=
name|text_init
argument_list|(
name|sp
argument_list|,
name|p
argument_list|,
name|len
argument_list|,
name|len
operator|+
literal|32
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|HDR_INSERT
argument_list|(
name|tp
argument_list|,
name|hp
argument_list|,
name|next
argument_list|,
name|prev
argument_list|,
name|TEXT
argument_list|)
expr_stmt|;
block|}
comment|/* Set the starting line number. */
name|tp
operator|->
name|lno
operator|=
name|sp
operator|->
name|lno
expr_stmt|;
comment|/* 	 * Set the insert and overwrite counts.  If overwriting characters, 	 * do insertion afterward.  If not overwriting characters, assume 	 * doing insertion.  If change is to a mark, emphasize it with an 	 * END_CH. 	 */
if|if
condition|(
name|len
condition|)
block|{
if|if
condition|(
name|LF_ISSET
argument_list|(
name|TXT_OVERWRITE
argument_list|)
condition|)
block|{
name|tp
operator|->
name|overwrite
operator|=
name|tm
operator|->
name|cno
operator|-
name|sp
operator|->
name|cno
expr_stmt|;
name|tp
operator|->
name|insert
operator|=
name|len
operator|-
name|tm
operator|->
name|cno
expr_stmt|;
block|}
else|else
name|tp
operator|->
name|insert
operator|=
name|len
operator|-
name|sp
operator|->
name|cno
expr_stmt|;
if|if
condition|(
name|LF_ISSET
argument_list|(
name|TXT_EMARK
argument_list|)
condition|)
name|tp
operator|->
name|lb
index|[
name|tm
operator|->
name|cno
operator|-
literal|1
index|]
operator|=
name|END_CH
expr_stmt|;
block|}
comment|/* 	 * Many of the special cases in this routine are to handle autoindent 	 * support.  Some utter fool decided that it would be a good idea if 	 * "^^D" and "0^D" deleted all of the autoindented characters.  In an 	 * editor that takes single character input from the user, this is so 	 * stupid as to be unbelievable.  Note also that "^^D" resets the next 	 * lines' autoindent, but "0^D" doesn't. 	 * 	 * We assume that autoindent only happens on empty lines, so insert 	 * and overwrite will be zero.  If doing autoindent, figure out how 	 * much indentation we need and fill it in.  Update input column and 	 * screen cursor as necessary. 	 */
if|if
condition|(
name|LF_ISSET
argument_list|(
name|TXT_AUTOINDENT
argument_list|)
operator|&&
name|ai_line
operator|!=
name|OOBLNO
condition|)
block|{
if|if
condition|(
name|txt_auto
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
name|ai_line
argument_list|,
name|NULL
argument_list|,
name|tp
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|sp
operator|->
name|cno
operator|=
name|tp
operator|->
name|ai
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * The change command has a special "feature" -- leading space 		 * characters are handled as autoindent characters.  Beauty! 		 */
if|if
condition|(
name|LF_ISSET
argument_list|(
name|TXT_AICHARS
argument_list|)
condition|)
block|{
name|tp
operator|->
name|offset
operator|=
literal|0
expr_stmt|;
name|tp
operator|->
name|ai
operator|=
name|sp
operator|->
name|cno
expr_stmt|;
block|}
else|else
name|tp
operator|->
name|offset
operator|=
name|sp
operator|->
name|cno
expr_stmt|;
block|}
name|aitp
operator|=
name|tp
expr_stmt|;
comment|/* If getting a command buffer from the user, there may be a prompt. */
if|if
condition|(
name|LF_ISSET
argument_list|(
name|TXT_PROMPT
argument_list|)
condition|)
block|{
name|tp
operator|->
name|lb
index|[
name|sp
operator|->
name|cno
operator|++
index|]
operator|=
name|prompt
expr_stmt|;
operator|++
name|tp
operator|->
name|len
expr_stmt|;
operator|++
name|tp
operator|->
name|offset
expr_stmt|;
block|}
comment|/* 	 * If appending after the end-of-line, add a space into the buffer 	 * and move the cursor right.  This space is inserted, i.e. pushed 	 * along, and then deleted when the line is resolved.  Assumes that 	 * the cursor is already positioned at the end of the line.  This 	 * avoids the nastiness of having the cursor reside on a magical 	 * column, i.e. a column that doesn't really exist.  The only down 	 * side is that we may wrap lines or scroll the screen before it's 	 * strictly necessary.  Not a big deal. 	 */
if|if
condition|(
name|LF_ISSET
argument_list|(
name|TXT_APPENDEOL
argument_list|)
condition|)
block|{
name|tp
operator|->
name|lb
index|[
name|sp
operator|->
name|cno
index|]
operator|=
name|CURSOR_CHAR
expr_stmt|;
operator|++
name|tp
operator|->
name|len
expr_stmt|;
operator|++
name|tp
operator|->
name|insert
expr_stmt|;
block|}
comment|/* 	 * Set up the dot command.  Dot commands are done by saving the 	 * actual characters and replaying the input. 	 * 	 * XXX 	 * It would be nice if we could swallow backspaces and such, but 	 * it's not all that easy to do.  Another possibility would be to 	 * recognize full line insertions, which could be performed quickly, 	 * without replay. 	 */
name|rcol
operator|=
literal|0
expr_stmt|;
name|replay
operator|=
name|LF_ISSET
argument_list|(
name|TXT_REPLAY
argument_list|)
expr_stmt|;
comment|/* Initialize abbreviations check. */
name|lch
operator|=
name|F_ISSET
argument_list|(
name|sp
argument_list|,
name|S_ABBREV
argument_list|)
operator|&&
name|LF_ISSET
argument_list|(
name|TXT_MAPINPUT
argument_list|)
condition|?
name|L_NOTSPACE
else|:
name|L_NOCHECK
expr_stmt|;
for|for
control|(
name|carat_st
operator|=
name|C_NOTSET
operator|,
name|quoted
operator|=
name|Q_NOTSET
operator|,
name|tty_cwait
operator|=
literal|0
init|;
condition|;
control|)
block|{
comment|/* Reset the line and update the screen. */
if|if
condition|(
name|sp
operator|->
name|s_change
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
name|tp
operator|->
name|lno
argument_list|,
name|LINE_RESET
argument_list|)
condition|)
name|ERR
expr_stmt|;
comment|/* Three chosen by random selection. */
if|if
condition|(
name|tty_cwait
operator|>
literal|3
operator|||
operator|!
name|term_waiting
argument_list|(
name|sp
argument_list|)
condition|)
block|{
name|tty_cwait
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|s_refresh
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|)
condition|)
name|ERR
expr_stmt|;
block|}
else|else
operator|++
name|tty_cwait
expr_stmt|;
name|next_ch
label|:
if|if
condition|(
name|replay
condition|)
name|ch
operator|=
name|sp
operator|->
name|rep
index|[
name|rcol
operator|++
index|]
expr_stmt|;
else|else
block|{
comment|/* Get the character. */
name|ch
operator|=
name|term_key
argument_list|(
name|sp
argument_list|,
name|flags
operator|&
name|TXT_GETKEY_MASK
argument_list|)
expr_stmt|;
comment|/* 			 * Check if the character fits into the input and 			 * replay buffers; allocate space as necesssary. 			 * It's not necessary to check tp->len, since it 			 * doesn't include the overwrite characters, but 			 * it's not worth fixing it. 			 */
name|TBINC
argument_list|(
name|sp
argument_list|,
name|tp
operator|->
name|lb
argument_list|,
name|tp
operator|->
name|lb_len
argument_list|,
name|tp
operator|->
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|LF_ISSET
argument_list|(
name|TXT_RECORD
argument_list|)
condition|)
block|{
comment|/* Store the character into replay buffer. */
name|TBINC
argument_list|(
name|sp
argument_list|,
name|sp
operator|->
name|rep
argument_list|,
name|sp
operator|->
name|rep_len
argument_list|,
name|rcol
operator|+
literal|1
argument_list|)
expr_stmt|;
name|sp
operator|->
name|rep
index|[
name|rcol
operator|++
index|]
operator|=
name|ch
expr_stmt|;
block|}
block|}
comment|/* 		 * If the character was quoted, replace the last 		 * character (the literal mark) with the new character. 		 */
if|if
condition|(
name|quoted
operator|==
name|Q_THISCHAR
condition|)
block|{
operator|--
name|sp
operator|->
name|cno
expr_stmt|;
operator|++
name|tp
operator|->
name|overwrite
expr_stmt|;
name|quoted
operator|=
name|Q_NOTSET
expr_stmt|;
goto|goto
name|ins_ch
goto|;
block|}
switch|switch
condition|(
name|sp
operator|->
name|special
index|[
name|ch
index|]
condition|)
block|{
case|case
name|K_CR
case|:
case|case
name|K_NL
case|:
comment|/* New line. */
define|#
directive|define
name|LINE_RESOLVE
value|{							\
comment|/* Handle abbreviations. */
value|\ 			if (lch == L_NOTSPACE&& txt_abbrev(sp, tp))	\ 				ERR;					\ 			if (lch != L_NOCHECK)				\ 				lch = L_SPACE;				\
comment|/*						\ 			 * The "R" command doesn't delete characters	\ 			 * that it could have overwritten.  Other input	\ 			 * modes do.					\ 			 */
value|\ 			if (LF_ISSET(TXT_REPLACE)) {			\ 				tp->insert += tp->overwrite;		\ 				tp->overwrite = 0;			\ 			}						\
comment|/* Delete any appended cursor. */
value|\ 			if (LF_ISSET(TXT_APPENDEOL)) {			\ 				--tp->len;				\ 				--tp->insert;				\ 			}						\
comment|/*						\ 			 * If the user has not inserted any characters	\ 			 * and there aren't any other characters in the	\ 			 * line, delete the autoindent characters.	\ 			 */
value|\ 			if (LF_ISSET(TXT_AUTOINDENT)&&			\ 			    !tp->insert&& sp->cno<= tp->ai) {		\ 				tp->len = tp->overwrite = 0;		\ 				sp->cno = 0;				\ 			}						\ }
name|LINE_RESOLVE
expr_stmt|;
if|if
condition|(
name|LF_ISSET
argument_list|(
name|TXT_CR
argument_list|)
condition|)
goto|goto
name|k_escape
goto|;
comment|/* 			 * Move any remaining insert characters into 			 * a new TEXT structure. 			 */
if|if
condition|(
operator|(
name|ntp
operator|=
name|text_init
argument_list|(
name|sp
argument_list|,
name|tp
operator|->
name|lb
operator|+
name|sp
operator|->
name|cno
operator|+
name|tp
operator|->
name|overwrite
argument_list|,
name|tp
operator|->
name|insert
argument_list|,
name|tp
operator|->
name|insert
operator|+
literal|32
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|ERR
expr_stmt|;
name|HDR_INSERT
argument_list|(
name|ntp
argument_list|,
name|hp
argument_list|,
name|next
argument_list|,
name|prev
argument_list|,
name|TEXT
argument_list|)
expr_stmt|;
comment|/* Set bookkeeping for the new line. */
name|ntp
operator|->
name|lno
operator|=
name|tp
operator|->
name|lno
operator|+
literal|1
expr_stmt|;
name|ntp
operator|->
name|insert
operator|=
name|tp
operator|->
name|insert
expr_stmt|;
comment|/* 			 * Reset the autoindent line.  0^D keeps the ai 			 * line from changing, ^D changes the level, even 			 * if no characters in the line. 			 */
if|if
condition|(
name|LF_ISSET
argument_list|(
name|TXT_AUTOINDENT
argument_list|)
condition|)
block|{
if|if
condition|(
name|carat_st
operator|!=
name|C_NOCHANGE
condition|)
name|aitp
operator|=
name|tp
expr_stmt|;
if|if
condition|(
name|txt_auto
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
name|OOBLNO
argument_list|,
name|aitp
argument_list|,
name|ntp
argument_list|)
condition|)
name|ERR
expr_stmt|;
name|carat_st
operator|=
name|C_NOTSET
expr_stmt|;
block|}
comment|/* Can now reset bookkeeping for the old line. */
name|tp
operator|->
name|len
operator|=
name|sp
operator|->
name|cno
expr_stmt|;
name|tp
operator|->
name|ai
operator|=
name|tp
operator|->
name|insert
operator|=
name|tp
operator|->
name|overwrite
operator|=
literal|0
expr_stmt|;
comment|/* New cursor position. */
name|sp
operator|->
name|cno
operator|=
name|ntp
operator|->
name|ai
expr_stmt|;
comment|/* New lines are TXT_APPENDEOL if nothing to insert. */
if|if
condition|(
name|ntp
operator|->
name|insert
operator|==
literal|0
condition|)
block|{
name|TBINC
argument_list|(
name|sp
argument_list|,
name|tp
operator|->
name|lb
argument_list|,
name|tp
operator|->
name|lb_len
argument_list|,
name|tp
operator|->
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|LF_SET
argument_list|(
name|TXT_APPENDEOL
argument_list|)
expr_stmt|;
name|ntp
operator|->
name|lb
index|[
name|sp
operator|->
name|cno
index|]
operator|=
name|CURSOR_CHAR
expr_stmt|;
operator|++
name|ntp
operator|->
name|insert
expr_stmt|;
operator|++
name|ntp
operator|->
name|len
expr_stmt|;
block|}
comment|/* Update the old line. */
if|if
condition|(
name|sp
operator|->
name|s_change
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
name|tp
operator|->
name|lno
argument_list|,
name|LINE_RESET
argument_list|)
condition|)
name|ERR
expr_stmt|;
comment|/* Swap old and new TEXT's. */
name|tp
operator|=
name|ntp
expr_stmt|;
comment|/* Reset the cursor. */
name|sp
operator|->
name|lno
operator|=
name|tp
operator|->
name|lno
expr_stmt|;
comment|/* Update the new line. */
if|if
condition|(
name|sp
operator|->
name|s_change
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
name|tp
operator|->
name|lno
argument_list|,
name|LINE_INSERT
argument_list|)
operator|||
name|sp
operator|->
name|s_refresh
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|)
condition|)
name|ERR
expr_stmt|;
goto|goto
name|next_ch
goto|;
case|case
name|K_ESCAPE
case|:
comment|/* Escape. */
if|if
condition|(
operator|!
name|LF_ISSET
argument_list|(
name|TXT_ESCAPE
argument_list|)
condition|)
goto|goto
name|ins_ch
goto|;
name|LINE_RESOLVE
expr_stmt|;
comment|/* If there are insert characters, copy them down. */
name|k_escape
label|:
if|if
condition|(
name|tp
operator|->
name|insert
operator|&&
name|tp
operator|->
name|overwrite
condition|)
name|memmove
argument_list|(
name|tp
operator|->
name|lb
operator|+
name|sp
operator|->
name|cno
argument_list|,
name|tp
operator|->
name|lb
operator|+
name|sp
operator|->
name|cno
operator|+
name|tp
operator|->
name|overwrite
argument_list|,
name|tp
operator|->
name|insert
argument_list|)
expr_stmt|;
name|tp
operator|->
name|len
operator|-=
name|tp
operator|->
name|overwrite
expr_stmt|;
comment|/* 			 * Delete any lines that were inserted into the text 			 * structure and then erased. 			 */
while|while
condition|(
name|tp
operator|->
name|next
operator|!=
operator|(
name|TEXT
operator|*
operator|)
name|hp
condition|)
block|{
name|HDR_DELETE
argument_list|(
name|tp
operator|->
name|next
argument_list|,
name|next
argument_list|,
name|prev
argument_list|,
name|TEXT
argument_list|)
expr_stmt|;
name|text_free
argument_list|(
name|tp
operator|->
name|next
argument_list|)
expr_stmt|;
block|}
comment|/* 			 * If not resolving the lines into the file, end 			 * it with a nul. 			 */
if|if
condition|(
name|LF_ISSET
argument_list|(
name|TXT_RESOLVE
argument_list|)
condition|)
block|{
if|if
condition|(
name|txt_resolve
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
name|hp
argument_list|)
condition|)
name|ERR
expr_stmt|;
block|}
else|else
block|{
name|TBINC
argument_list|(
name|sp
argument_list|,
name|tp
operator|->
name|lb
argument_list|,
name|tp
operator|->
name|lb_len
argument_list|,
name|tp
operator|->
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|tp
operator|->
name|lb
index|[
name|tp
operator|->
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
comment|/* 			 * Set the return cursor position to rest on the last 			 * inserted character. 			 */
if|if
condition|(
name|rp
operator|!=
name|NULL
condition|)
block|{
name|rp
operator|->
name|lno
operator|=
name|tp
operator|->
name|lno
expr_stmt|;
name|rp
operator|->
name|cno
operator|=
name|sp
operator|->
name|cno
condition|?
name|sp
operator|->
name|cno
operator|-
literal|1
else|:
literal|0
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|s_change
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
name|rp
operator|->
name|lno
argument_list|,
name|LINE_RESET
argument_list|)
condition|)
name|ERR
expr_stmt|;
block|}
goto|goto
name|ret
goto|;
case|case
name|K_CARAT
case|:
comment|/* Delete autoindent chars. */
if|if
condition|(
name|LF_ISSET
argument_list|(
name|TXT_AUTOINDENT
argument_list|)
operator|&&
name|sp
operator|->
name|cno
operator|<=
name|tp
operator|->
name|ai
condition|)
name|carat_st
operator|=
name|C_CARATSET
expr_stmt|;
goto|goto
name|ins_ch
goto|;
case|case
name|K_ZERO
case|:
comment|/* Delete autoindent chars. */
if|if
condition|(
name|LF_ISSET
argument_list|(
name|TXT_AUTOINDENT
argument_list|)
operator|&&
name|sp
operator|->
name|cno
operator|<=
name|tp
operator|->
name|ai
condition|)
name|carat_st
operator|=
name|C_ZEROSET
expr_stmt|;
goto|goto
name|ins_ch
goto|;
case|case
name|K_CNTRLD
case|:
comment|/* Delete autoindent char. */
if|if
condition|(
operator|!
name|LF_ISSET
argument_list|(
name|TXT_AUTOINDENT
argument_list|)
condition|)
goto|goto
name|ins_ch
goto|;
switch|switch
condition|(
name|carat_st
condition|)
block|{
case|case
name|C_CARATSET
case|:
comment|/* ^^D */
if|if
condition|(
name|sp
operator|->
name|cno
operator|==
literal|0
operator|||
name|sp
operator|->
name|cno
operator|>
name|tp
operator|->
name|ai
operator|+
literal|1
condition|)
goto|goto
name|ins_ch
goto|;
name|carat_st
operator|=
name|C_NOTSET
expr_stmt|;
name|tp
operator|->
name|overwrite
operator|+=
name|sp
operator|->
name|cno
expr_stmt|;
name|tp
operator|->
name|ai
operator|=
name|sp
operator|->
name|cno
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|C_ZEROSET
case|:
comment|/* 0^D */
if|if
condition|(
name|sp
operator|->
name|cno
operator|==
literal|0
operator|||
name|sp
operator|->
name|cno
operator|>
name|tp
operator|->
name|ai
operator|+
literal|1
condition|)
goto|goto
name|ins_ch
goto|;
name|carat_st
operator|=
name|C_NOCHANGE
expr_stmt|;
name|tp
operator|->
name|overwrite
operator|+=
name|sp
operator|->
name|cno
expr_stmt|;
name|tp
operator|->
name|ai
operator|=
name|sp
operator|->
name|cno
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|C_NOTSET
case|:
comment|/* ^D */
if|if
condition|(
name|sp
operator|->
name|cno
operator|==
literal|0
operator|||
name|sp
operator|->
name|cno
operator|>
name|tp
operator|->
name|ai
condition|)
goto|goto
name|ins_ch
goto|;
operator|(
name|void
operator|)
name|txt_outdent
argument_list|(
name|sp
argument_list|,
name|tp
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
name|K_CNTRLT
case|:
comment|/* Add autoindent char. */
if|if
condition|(
operator|!
name|LF_ISSET
argument_list|(
name|TXT_CNTRLT
argument_list|)
operator|||
name|sp
operator|->
name|cno
operator|>
name|tp
operator|->
name|ai
condition|)
goto|goto
name|ins_ch
goto|;
if|if
condition|(
name|txt_indent
argument_list|(
name|sp
argument_list|,
name|tp
argument_list|)
condition|)
break|break;
break|break;
case|case
name|K_VERASE
case|:
comment|/* Erase the last character. */
comment|/* If can erase over the prompt, return. */
if|if
condition|(
name|LF_ISSET
argument_list|(
name|TXT_BS
argument_list|)
operator|&&
name|sp
operator|->
name|cno
operator|<=
name|tp
operator|->
name|offset
condition|)
block|{
name|tp
operator|->
name|len
operator|=
name|tp
operator|->
name|offset
expr_stmt|;
goto|goto
name|ret
goto|;
block|}
comment|/* 			 * If at the beginning of the line, try and drop back 			 * to a previously inserted line. 			 */
if|if
condition|(
name|sp
operator|->
name|cno
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|ntp
operator|=
name|txt_backup
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
name|hp
argument_list|,
name|tp
argument_list|,
name|flags
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|ERR
expr_stmt|;
name|tp
operator|=
name|ntp
expr_stmt|;
break|break;
block|}
comment|/* If nothing to erase, bell the user. */
if|if
condition|(
name|sp
operator|->
name|cno
operator|<=
name|tp
operator|->
name|offset
condition|)
block|{
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_BERR
argument_list|,
literal|"No more characters to erase."
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Drop back one character. */
operator|--
name|sp
operator|->
name|cno
expr_stmt|;
comment|/* Increment overwrite, decrement ai if deleted. */
operator|++
name|tp
operator|->
name|overwrite
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|cno
operator|<
name|tp
operator|->
name|ai
condition|)
operator|--
name|tp
operator|->
name|ai
expr_stmt|;
break|break;
case|case
name|K_VWERASE
case|:
comment|/* Skip back one word. */
comment|/* 			 * If at the beginning of the line, try and drop back 			 * to a previously inserted line. 			 */
if|if
condition|(
name|sp
operator|->
name|cno
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|ntp
operator|=
name|txt_backup
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
name|hp
argument_list|,
name|tp
argument_list|,
name|flags
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|ERR
expr_stmt|;
name|tp
operator|=
name|ntp
expr_stmt|;
block|}
comment|/* 			 * If at offset, nothing to erase so bell the user. 			 */
if|if
condition|(
name|sp
operator|->
name|cno
operator|<=
name|tp
operator|->
name|offset
condition|)
block|{
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_BERR
argument_list|,
literal|"No more characters to erase."
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* 			 * First werase goes back to any autoindent 			 * and second werase goes back to the offset. 			 */
if|if
condition|(
name|tp
operator|->
name|ai
operator|&&
name|sp
operator|->
name|cno
operator|>
name|tp
operator|->
name|ai
condition|)
name|max
operator|=
name|tp
operator|->
name|ai
expr_stmt|;
else|else
name|max
operator|=
name|tp
operator|->
name|offset
expr_stmt|;
comment|/* Skip over trailing space characters. */
while|while
condition|(
name|sp
operator|->
name|cno
operator|>
name|max
operator|&&
name|isspace
argument_list|(
name|tp
operator|->
name|lb
index|[
name|sp
operator|->
name|cno
operator|-
literal|1
index|]
argument_list|)
condition|)
block|{
operator|--
name|sp
operator|->
name|cno
expr_stmt|;
operator|++
name|tp
operator|->
name|overwrite
expr_stmt|;
block|}
if|if
condition|(
name|sp
operator|->
name|cno
operator|==
name|max
condition|)
break|break;
for|for
control|(
name|tmp
operator|=
name|inword
argument_list|(
name|tp
operator|->
name|lb
index|[
name|sp
operator|->
name|cno
operator|-
literal|1
index|]
argument_list|)
init|;
name|sp
operator|->
name|cno
operator|>
name|max
condition|;
control|)
block|{
operator|--
name|sp
operator|->
name|cno
expr_stmt|;
operator|++
name|tp
operator|->
name|overwrite
expr_stmt|;
if|if
condition|(
name|tmp
operator|!=
name|inword
argument_list|(
name|tp
operator|->
name|lb
index|[
name|sp
operator|->
name|cno
operator|-
literal|1
index|]
argument_list|)
operator|||
name|isspace
argument_list|(
name|tp
operator|->
name|lb
index|[
name|sp
operator|->
name|cno
operator|-
literal|1
index|]
argument_list|)
condition|)
break|break;
block|}
break|break;
case|case
name|K_VKILL
case|:
comment|/* Restart this line. */
comment|/* 			 * If at the beginning of the line, try and drop back 			 * to a previously inserted line. 			 */
if|if
condition|(
name|sp
operator|->
name|cno
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|ntp
operator|=
name|txt_backup
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
name|hp
argument_list|,
name|tp
argument_list|,
name|flags
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|ERR
expr_stmt|;
name|tp
operator|=
name|ntp
expr_stmt|;
block|}
comment|/* If at offset, nothing to erase so bell the user. */
if|if
condition|(
name|sp
operator|->
name|cno
operator|<=
name|tp
operator|->
name|offset
condition|)
block|{
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_BERR
argument_list|,
literal|"No more characters to erase."
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* 			 * First kill goes back to any autoindent 			 * and second kill goes back to the offset. 			 */
if|if
condition|(
name|tp
operator|->
name|ai
operator|&&
name|sp
operator|->
name|cno
operator|>
name|tp
operator|->
name|ai
condition|)
name|max
operator|=
name|tp
operator|->
name|ai
expr_stmt|;
else|else
name|max
operator|=
name|tp
operator|->
name|offset
expr_stmt|;
name|tp
operator|->
name|overwrite
operator|+=
name|sp
operator|->
name|cno
operator|-
name|max
expr_stmt|;
name|sp
operator|->
name|cno
operator|=
name|max
expr_stmt|;
break|break;
case|case
name|K_CNTRLZ
case|:
operator|(
name|void
operator|)
name|sp
operator|->
name|s_suspend
argument_list|(
name|sp
argument_list|)
expr_stmt|;
break|break;
case|case
name|K_FORMFEED
case|:
name|F_SET
argument_list|(
name|sp
argument_list|,
name|S_REFRESH
argument_list|)
expr_stmt|;
break|break;
case|case
name|K_VLNEXT
case|:
comment|/* Quote the next character. */
name|ch
operator|=
literal|'^'
expr_stmt|;
name|quoted
operator|=
name|Q_NEXTCHAR
expr_stmt|;
comment|/* FALLTHROUGH */
default|default:
comment|/* Insert the character. */
comment|/* 			 * If entering a space character after a word, check 			 * for abbreviations. 			 */
name|ins_ch
label|:
if|if
condition|(
name|isspace
argument_list|(
name|ch
argument_list|)
operator|&&
name|lch
operator|==
name|L_NOTSPACE
operator|&&
name|txt_abbrev
argument_list|(
name|sp
argument_list|,
name|tp
argument_list|)
condition|)
name|ERR
expr_stmt|;
if|if
condition|(
name|lch
operator|!=
name|L_NOCHECK
condition|)
name|lch
operator|=
name|isspace
argument_list|(
name|ch
argument_list|)
condition|?
name|L_SPACE
else|:
name|L_NOTSPACE
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|overwrite
condition|)
comment|/* Overwrite a character. */
operator|--
name|tp
operator|->
name|overwrite
expr_stmt|;
elseif|else
if|if
condition|(
name|tp
operator|->
name|insert
condition|)
block|{
comment|/* Insert a character. */
operator|++
name|tp
operator|->
name|len
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|insert
operator|==
literal|1
condition|)
name|tp
operator|->
name|lb
index|[
name|sp
operator|->
name|cno
operator|+
literal|1
index|]
operator|=
name|tp
operator|->
name|lb
index|[
name|sp
operator|->
name|cno
index|]
expr_stmt|;
else|else
name|memmove
argument_list|(
name|tp
operator|->
name|lb
operator|+
name|sp
operator|->
name|cno
operator|+
literal|1
argument_list|,
name|tp
operator|->
name|lb
operator|+
name|sp
operator|->
name|cno
argument_list|,
name|tp
operator|->
name|insert
argument_list|)
expr_stmt|;
block|}
name|tp
operator|->
name|lb
index|[
name|sp
operator|->
name|cno
operator|++
index|]
operator|=
name|ch
expr_stmt|;
comment|/* 			 * If we've reached the end of the buffer, then we 			 * need to switch into insert mode.  This happens 			 * when there's a change to a mark and the user puts 			 * in more characters than the length of the motion. 			 */
if|if
condition|(
name|sp
operator|->
name|cno
operator|>=
name|tp
operator|->
name|len
condition|)
block|{
name|TBINC
argument_list|(
name|sp
argument_list|,
name|tp
operator|->
name|lb
argument_list|,
name|tp
operator|->
name|lb_len
argument_list|,
name|tp
operator|->
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|LF_SET
argument_list|(
name|TXT_APPENDEOL
argument_list|)
expr_stmt|;
name|tp
operator|->
name|lb
index|[
name|sp
operator|->
name|cno
index|]
operator|=
name|CURSOR_CHAR
expr_stmt|;
operator|++
name|tp
operator|->
name|insert
expr_stmt|;
operator|++
name|tp
operator|->
name|len
expr_stmt|;
block|}
if|if
condition|(
name|quoted
operator|==
name|Q_NEXTCHAR
condition|)
name|quoted
operator|=
name|Q_THISCHAR
expr_stmt|;
break|break;
block|}
if|#
directive|if
name|DEBUG
operator|&&
literal|1
if|if
condition|(
name|sp
operator|->
name|cno
operator|+
name|tp
operator|->
name|insert
operator|+
name|tp
operator|->
name|overwrite
operator|!=
name|tp
operator|->
name|len
condition|)
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_ERR
argument_list|,
literal|"len %u != cno: %u ai: %u insert %u overwrite %u"
argument_list|,
name|tp
operator|->
name|len
argument_list|,
name|sp
operator|->
name|cno
argument_list|,
name|tp
operator|->
name|ai
argument_list|,
name|tp
operator|->
name|insert
argument_list|,
name|tp
operator|->
name|overwrite
argument_list|)
expr_stmt|;
name|tp
operator|->
name|len
operator|=
name|sp
operator|->
name|cno
operator|+
name|tp
operator|->
name|insert
operator|+
name|tp
operator|->
name|overwrite
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* Clear input, text buffer in-use flags. */
name|ret
label|:
name|F_CLR
argument_list|(
name|sp
argument_list|,
name|S_INPUT
argument_list|)
expr_stmt|;
name|F_CLR
argument_list|(
name|hp
argument_list|,
name|HDR_INUSE
argument_list|)
expr_stmt|;
return|return
operator|(
name|eval
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * txt_abbrev --  *	Handle abbreviations.  */
end_comment

begin_function
specifier|static
name|int
name|txt_abbrev
parameter_list|(
name|sp
parameter_list|,
name|tp
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
name|TEXT
modifier|*
name|tp
decl_stmt|;
block|{
name|SEQ
modifier|*
name|qp
decl_stmt|;
name|size_t
name|diff
decl_stmt|,
name|len
decl_stmt|,
name|off
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
comment|/* Find the beginning of this "word". */
for|for
control|(
name|off
operator|=
name|sp
operator|->
name|cno
operator|-
literal|1
operator|,
name|p
operator|=
name|tp
operator|->
name|lb
operator|+
name|off
operator|,
name|len
operator|=
literal|0
init|;
condition|;
operator|--
name|p
operator|,
operator|--
name|off
control|)
block|{
if|if
condition|(
name|isspace
argument_list|(
operator|*
name|p
argument_list|)
condition|)
block|{
operator|++
name|p
expr_stmt|;
break|break;
block|}
operator|++
name|len
expr_stmt|;
if|if
condition|(
name|off
operator|==
name|tp
operator|->
name|ai
operator|||
name|off
operator|==
name|tp
operator|->
name|offset
condition|)
break|break;
block|}
comment|/* Check for any abbreviations. */
if|if
condition|(
operator|(
name|qp
operator|=
name|seq_find
argument_list|(
name|sp
argument_list|,
name|p
argument_list|,
name|len
argument_list|,
name|SEQ_ABBREV
argument_list|,
name|NULL
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Copy up or down, depending on the lengths. */
if|if
condition|(
name|len
operator|<
name|qp
operator|->
name|olen
condition|)
block|{
name|diff
operator|=
name|qp
operator|->
name|olen
operator|-
name|len
expr_stmt|;
name|BINC
argument_list|(
name|sp
argument_list|,
name|tp
operator|->
name|lb
argument_list|,
name|tp
operator|->
name|lb_len
argument_list|,
name|tp
operator|->
name|len
operator|+
name|diff
argument_list|)
expr_stmt|;
name|memmove
argument_list|(
name|tp
operator|->
name|lb
operator|+
name|sp
operator|->
name|cno
operator|+
name|diff
argument_list|,
name|tp
operator|->
name|lb
operator|+
name|sp
operator|->
name|cno
argument_list|,
name|tp
operator|->
name|insert
argument_list|)
expr_stmt|;
name|sp
operator|->
name|cno
operator|+=
name|diff
expr_stmt|;
name|tp
operator|->
name|len
operator|+=
name|diff
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|len
operator|>
name|qp
operator|->
name|olen
condition|)
block|{
name|diff
operator|=
name|len
operator|-
name|qp
operator|->
name|olen
expr_stmt|;
name|memmove
argument_list|(
name|tp
operator|->
name|lb
operator|+
name|sp
operator|->
name|cno
operator|-
name|diff
argument_list|,
name|tp
operator|->
name|lb
operator|+
name|sp
operator|->
name|cno
argument_list|,
name|tp
operator|->
name|insert
argument_list|)
expr_stmt|;
name|sp
operator|->
name|cno
operator|-=
name|diff
expr_stmt|;
name|tp
operator|->
name|len
operator|-=
name|diff
expr_stmt|;
block|}
name|memmove
argument_list|(
name|p
argument_list|,
name|qp
operator|->
name|output
argument_list|,
name|qp
operator|->
name|olen
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * txt_auto --  *	Handle autoindent.  If aitp isn't NULL, use it, otherwise,  *	retrieve the line.  */
end_comment

begin_function
name|int
name|txt_auto
parameter_list|(
name|sp
parameter_list|,
name|ep
parameter_list|,
name|lno
parameter_list|,
name|aitp
parameter_list|,
name|tp
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
name|EXF
modifier|*
name|ep
decl_stmt|;
name|recno_t
name|lno
decl_stmt|;
name|TEXT
modifier|*
name|aitp
decl_stmt|,
decl|*
name|tp
decl_stmt|;
end_function

begin_block
block|{
name|size_t
name|len
decl_stmt|,
name|nlen
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|t
decl_stmt|;
if|if
condition|(
name|aitp
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|p
operator|=
name|t
operator|=
name|file_gline
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
name|lno
argument_list|,
operator|&
name|len
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
else|else
block|{
name|len
operator|=
name|aitp
operator|->
name|len
condition|?
name|aitp
operator|->
name|len
else|:
name|aitp
operator|->
name|ai
expr_stmt|;
name|p
operator|=
name|t
operator|=
name|aitp
operator|->
name|lb
expr_stmt|;
block|}
for|for
control|(
name|nlen
operator|=
literal|0
init|;
name|len
condition|;
operator|++
name|p
control|)
block|{
if|if
condition|(
operator|!
name|isspace
argument_list|(
operator|*
name|p
argument_list|)
condition|)
break|break;
comment|/* If last character is a space, it counts. */
if|if
condition|(
operator|--
name|len
operator|==
literal|0
condition|)
block|{
operator|++
name|p
expr_stmt|;
break|break;
block|}
block|}
comment|/* No indentation. */
if|if
condition|(
name|p
operator|==
name|t
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Set count. */
name|nlen
operator|=
name|p
operator|-
name|t
expr_stmt|;
comment|/* Make sure the buffer's big enough. */
name|BINC
argument_list|(
name|sp
argument_list|,
name|tp
operator|->
name|lb
argument_list|,
name|tp
operator|->
name|lb_len
argument_list|,
name|tp
operator|->
name|len
operator|+
name|nlen
argument_list|)
expr_stmt|;
comment|/* Copy the indentation into the new buffer. */
name|memmove
argument_list|(
name|tp
operator|->
name|lb
operator|+
name|nlen
argument_list|,
name|tp
operator|->
name|lb
argument_list|,
name|tp
operator|->
name|len
argument_list|)
expr_stmt|;
name|memmove
argument_list|(
name|tp
operator|->
name|lb
argument_list|,
name|t
argument_list|,
name|nlen
argument_list|)
expr_stmt|;
name|tp
operator|->
name|len
operator|+=
name|nlen
expr_stmt|;
comment|/* Return the additional length. */
name|tp
operator|->
name|ai
operator|=
name|nlen
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * txt_backup --  *	Back up to the previously edited line.  */
end_comment

begin_function
specifier|static
name|TEXT
modifier|*
name|txt_backup
parameter_list|(
name|sp
parameter_list|,
name|ep
parameter_list|,
name|hp
parameter_list|,
name|tp
parameter_list|,
name|flags
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
name|EXF
modifier|*
name|ep
decl_stmt|;
name|HDR
modifier|*
name|hp
decl_stmt|;
name|TEXT
modifier|*
name|tp
decl_stmt|;
name|u_int
name|flags
decl_stmt|;
block|{
name|TEXT
modifier|*
name|ntp
decl_stmt|;
name|size_t
name|col
decl_stmt|;
if|if
condition|(
name|tp
operator|->
name|prev
operator|==
operator|(
name|TEXT
operator|*
operator|)
name|hp
condition|)
block|{
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_BERR
argument_list|,
literal|"Already at the beginning of the insert"
argument_list|)
expr_stmt|;
return|return
operator|(
name|tp
operator|)
return|;
block|}
comment|/* Update the old line on the screen. */
if|if
condition|(
name|sp
operator|->
name|s_change
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
name|tp
operator|->
name|lno
argument_list|,
name|LINE_DELETE
argument_list|)
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* Get a handle on the previous TEXT structure. */
name|ntp
operator|=
name|tp
operator|->
name|prev
expr_stmt|;
comment|/* Make sure that we can get enough space. */
if|if
condition|(
name|LF_ISSET
argument_list|(
name|TXT_APPENDEOL
argument_list|)
operator|&&
name|ntp
operator|->
name|len
operator|+
literal|1
operator|>
name|ntp
operator|->
name|lb_len
operator|&&
name|binc
argument_list|(
name|sp
argument_list|,
operator|&
name|ntp
operator|->
name|lb
argument_list|,
operator|&
name|ntp
operator|->
name|lb_len
argument_list|,
name|ntp
operator|->
name|len
operator|+
literal|1
argument_list|)
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* 	 * Release current TEXT; now committed to the swap, nothing 	 * better fail. 	 */
name|HDR_DELETE
argument_list|(
name|tp
argument_list|,
name|next
argument_list|,
name|prev
argument_list|,
name|TEXT
argument_list|)
expr_stmt|;
name|text_free
argument_list|(
name|tp
argument_list|)
expr_stmt|;
comment|/* Swap TEXT's. */
name|tp
operator|=
name|ntp
expr_stmt|;
comment|/* Set bookkeeping information. */
name|col
operator|=
name|tp
operator|->
name|len
expr_stmt|;
if|if
condition|(
name|LF_ISSET
argument_list|(
name|TXT_APPENDEOL
argument_list|)
condition|)
block|{
name|tp
operator|->
name|lb
index|[
name|col
index|]
operator|=
name|CURSOR_CHAR
expr_stmt|;
operator|++
name|tp
operator|->
name|insert
expr_stmt|;
operator|++
name|tp
operator|->
name|len
expr_stmt|;
block|}
name|sp
operator|->
name|lno
operator|=
name|tp
operator|->
name|lno
expr_stmt|;
name|sp
operator|->
name|cno
operator|=
name|col
expr_stmt|;
return|return
operator|(
name|tp
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * txt_err --  *	Handle an error during input processing.  */
end_comment

begin_function
specifier|static
name|void
name|txt_err
parameter_list|(
name|sp
parameter_list|,
name|ep
parameter_list|,
name|hp
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
name|EXF
modifier|*
name|ep
decl_stmt|;
name|HDR
modifier|*
name|hp
decl_stmt|;
block|{
name|recno_t
name|lno
decl_stmt|;
name|size_t
name|len
decl_stmt|;
comment|/* 	 * The problem with input processing is that the cursor is at an 	 * indeterminate position since some input may have been lost due 	 * to a malloc error.  So, try to go back to the place from which 	 * the cursor started, knowing that it may no longer be available. 	 * 	 * We depend on at least one line number being set in the text 	 * chain. 	 */
for|for
control|(
name|lno
operator|=
operator|(
operator|(
name|TEXT
operator|*
operator|)
operator|(
name|hp
operator|->
name|next
operator|)
operator|)
operator|->
name|lno
init|;
name|file_gline
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
name|lno
argument_list|,
operator|&
name|len
argument_list|)
operator|==
name|NULL
operator|&&
name|lno
operator|>
literal|0
condition|;
operator|--
name|lno
control|)
empty_stmt|;
name|sp
operator|->
name|lno
operator|=
name|lno
operator|==
literal|0
condition|?
literal|1
else|:
name|lno
expr_stmt|;
name|sp
operator|->
name|cno
operator|=
literal|0
expr_stmt|;
comment|/* Redraw the screen, just in case. */
name|F_SET
argument_list|(
name|sp
argument_list|,
name|S_REDRAW
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Txt_indent and txt_outdent are truly strange.  ^T and ^D do movements to  * the next or previous shiftwidth value, i.e. for a 1-based numbering, with  * shiftwidth=3, ^T moves a cursor on the 7th, 8th or 9th column to the 10th  * column, and ^D  moves it back.  *  * XXX  * Technically, txt_indent, txt_outdent should part of the screen interface,  * as they require knowledge of the size of a space character on the screen.  * (Not the size of tabs, because tabs are logically composed of spaces.)  * They're left in the text code  because they're complicated, not to mention  * the gruesome awareness that if spaces aren't a single column on the screen  * for any language we're into some serious, for lack of a better word,  * "issues".  */
end_comment

begin_comment
comment|/* Offset to next column of stop size. */
end_comment

begin_define
define|#
directive|define
name|STOP_OFF
parameter_list|(
name|c
parameter_list|,
name|stop
parameter_list|)
value|(stop - (c) % stop)
end_define

begin_comment
comment|/*  * txt_indent --  *	Handle ^T indents.  */
end_comment

begin_function
specifier|static
name|int
name|txt_indent
parameter_list|(
name|sp
parameter_list|,
name|tp
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
name|TEXT
modifier|*
name|tp
decl_stmt|;
block|{
name|u_long
name|sw
decl_stmt|,
name|ts
decl_stmt|;
name|size_t
name|cno
decl_stmt|,
name|off
decl_stmt|,
name|scno
decl_stmt|,
name|spaces
decl_stmt|,
name|tabs
decl_stmt|;
name|sw
operator|=
name|O_VAL
argument_list|(
name|sp
argument_list|,
name|O_SHIFTWIDTH
argument_list|)
expr_stmt|;
name|ts
operator|=
name|O_VAL
argument_list|(
name|sp
argument_list|,
name|O_TABSTOP
argument_list|)
expr_stmt|;
comment|/* Get the current screen column. */
for|for
control|(
name|off
operator|=
name|scno
operator|=
literal|0
init|;
name|off
operator|<
name|sp
operator|->
name|cno
condition|;
operator|++
name|off
control|)
if|if
condition|(
name|tp
operator|->
name|lb
index|[
name|off
index|]
operator|==
literal|'\t'
condition|)
name|scno
operator|+=
name|STOP_OFF
argument_list|(
name|scno
argument_list|,
name|ts
argument_list|)
expr_stmt|;
else|else
operator|++
name|scno
expr_stmt|;
comment|/* Count up spaces/tabs needed to get to the target. */
for|for
control|(
name|cno
operator|=
name|scno
operator|,
name|scno
operator|+=
name|STOP_OFF
argument_list|(
name|scno
argument_list|,
name|sw
argument_list|)
operator|,
name|tabs
operator|=
literal|0
init|;
name|cno
operator|+
name|STOP_OFF
argument_list|(
name|cno
argument_list|,
name|ts
argument_list|)
operator|<=
name|scno
condition|;
operator|++
name|tabs
control|)
name|cno
operator|+=
name|STOP_OFF
argument_list|(
name|cno
argument_list|,
name|ts
argument_list|)
expr_stmt|;
name|spaces
operator|=
name|scno
operator|-
name|cno
expr_stmt|;
comment|/* Make sure there's enough room. */
name|BINC
argument_list|(
name|sp
argument_list|,
name|tp
operator|->
name|lb
argument_list|,
name|tp
operator|->
name|lb_len
argument_list|,
name|tp
operator|->
name|len
operator|+
name|spaces
operator|+
name|tabs
argument_list|)
expr_stmt|;
comment|/* Move the insert characters out of the way. */
if|if
condition|(
name|tp
operator|->
name|insert
condition|)
name|memmove
argument_list|(
name|tp
operator|->
name|lb
operator|+
name|sp
operator|->
name|cno
operator|+
name|spaces
operator|+
name|tabs
argument_list|,
name|tp
operator|->
name|lb
operator|+
name|sp
operator|->
name|cno
argument_list|,
name|tp
operator|->
name|insert
argument_list|)
expr_stmt|;
comment|/* Add new space/tab characters. */
for|for
control|(
init|;
name|tabs
operator|--
condition|;
operator|++
name|tp
operator|->
name|len
operator|,
operator|++
name|tp
operator|->
name|ai
control|)
name|tp
operator|->
name|lb
index|[
name|sp
operator|->
name|cno
operator|++
index|]
operator|=
literal|'\t'
expr_stmt|;
for|for
control|(
init|;
name|spaces
operator|--
condition|;
operator|++
name|tp
operator|->
name|len
operator|,
operator|++
name|tp
operator|->
name|ai
control|)
name|tp
operator|->
name|lb
index|[
name|sp
operator|->
name|cno
operator|++
index|]
operator|=
literal|' '
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * txt_outdent --  *	Handle ^D outdents.  *  */
end_comment

begin_function
specifier|static
name|int
name|txt_outdent
parameter_list|(
name|sp
parameter_list|,
name|tp
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
name|TEXT
modifier|*
name|tp
decl_stmt|;
block|{
name|u_long
name|sw
decl_stmt|,
name|ts
decl_stmt|;
name|size_t
name|cno
decl_stmt|,
name|off
decl_stmt|,
name|scno
decl_stmt|,
name|spaces
decl_stmt|;
name|sw
operator|=
name|O_VAL
argument_list|(
name|sp
argument_list|,
name|O_SHIFTWIDTH
argument_list|)
expr_stmt|;
name|ts
operator|=
name|O_VAL
argument_list|(
name|sp
argument_list|,
name|O_TABSTOP
argument_list|)
expr_stmt|;
comment|/* Get the current screen column. */
for|for
control|(
name|off
operator|=
name|scno
operator|=
literal|0
init|;
name|off
operator|<
name|sp
operator|->
name|cno
condition|;
operator|++
name|off
control|)
if|if
condition|(
name|tp
operator|->
name|lb
index|[
name|off
index|]
operator|==
literal|'\t'
condition|)
name|scno
operator|+=
name|STOP_OFF
argument_list|(
name|scno
argument_list|,
name|ts
argument_list|)
expr_stmt|;
else|else
operator|++
name|scno
expr_stmt|;
comment|/* Get the previous shiftwidth column. */
for|for
control|(
name|cno
operator|=
name|scno
init|;
operator|--
name|scno
operator|%
name|sw
operator|!=
literal|0
condition|;
control|)
empty_stmt|;
comment|/* Decrement characters until less than or equal to that slot. */
for|for
control|(
init|;
name|cno
operator|>
name|scno
condition|;
operator|--
name|sp
operator|->
name|cno
operator|,
operator|--
name|tp
operator|->
name|ai
operator|,
operator|++
name|tp
operator|->
name|overwrite
control|)
if|if
condition|(
name|tp
operator|->
name|lb
index|[
operator|--
name|off
index|]
operator|==
literal|'\t'
condition|)
name|cno
operator|-=
name|STOP_OFF
argument_list|(
name|cno
argument_list|,
name|ts
argument_list|)
expr_stmt|;
else|else
operator|--
name|cno
expr_stmt|;
comment|/* Spaces needed to get to the target. */
name|spaces
operator|=
name|scno
operator|-
name|cno
expr_stmt|;
comment|/* Maybe just a delete. */
if|if
condition|(
name|spaces
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Make sure there's enough room. */
name|BINC
argument_list|(
name|sp
argument_list|,
name|tp
operator|->
name|lb
argument_list|,
name|tp
operator|->
name|lb_len
argument_list|,
name|tp
operator|->
name|len
operator|+
name|spaces
argument_list|)
expr_stmt|;
comment|/* Use up any overwrite characters. */
for|for
control|(
init|;
name|tp
operator|->
name|overwrite
operator|&&
name|spaces
condition|;
operator|--
name|spaces
operator|,
operator|++
name|tp
operator|->
name|ai
operator|,
operator|--
name|tp
operator|->
name|overwrite
control|)
name|tp
operator|->
name|lb
index|[
name|sp
operator|->
name|cno
operator|++
index|]
operator|=
literal|' '
expr_stmt|;
comment|/* Maybe that was enough. */
if|if
condition|(
name|spaces
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Move the insert characters out of the way. */
if|if
condition|(
name|tp
operator|->
name|insert
condition|)
name|memmove
argument_list|(
name|tp
operator|->
name|lb
operator|+
name|sp
operator|->
name|cno
operator|+
name|spaces
argument_list|,
name|tp
operator|->
name|lb
operator|+
name|sp
operator|->
name|cno
argument_list|,
name|tp
operator|->
name|insert
argument_list|)
expr_stmt|;
comment|/* Add new space characters. */
for|for
control|(
init|;
name|spaces
operator|--
condition|;
operator|++
name|tp
operator|->
name|len
operator|,
operator|++
name|tp
operator|->
name|ai
control|)
name|tp
operator|->
name|lb
index|[
name|sp
operator|->
name|cno
operator|++
index|]
operator|=
literal|' '
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * txt_resolve --  *	Resolve the input text chain into the file.  */
end_comment

begin_function
specifier|static
name|int
name|txt_resolve
parameter_list|(
name|sp
parameter_list|,
name|ep
parameter_list|,
name|hp
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
name|EXF
modifier|*
name|ep
decl_stmt|;
name|HDR
modifier|*
name|hp
decl_stmt|;
block|{
name|TEXT
modifier|*
name|tp
decl_stmt|;
name|recno_t
name|lno
decl_stmt|;
name|tp
operator|=
name|hp
operator|->
name|next
expr_stmt|;
comment|/* The first line replaces a current line. */
if|if
condition|(
name|file_sline
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
name|tp
operator|->
name|lno
argument_list|,
name|tp
operator|->
name|lb
argument_list|,
name|tp
operator|->
name|len
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* All subsequent lines are appended into the file. */
for|for
control|(
name|lno
operator|=
name|tp
operator|->
name|lno
init|;
operator|(
name|tp
operator|=
name|tp
operator|->
name|next
operator|)
operator|!=
operator|(
name|TEXT
operator|*
operator|)
operator|&
name|sp
operator|->
name|txthdr
condition|;
operator|++
name|lno
control|)
if|if
condition|(
name|file_aline
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
literal|0
argument_list|,
name|lno
argument_list|,
name|tp
operator|->
name|lb
argument_list|,
name|tp
operator|->
name|len
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

end_unit

