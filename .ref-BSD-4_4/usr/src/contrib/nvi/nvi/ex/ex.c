begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1992, 1993  *	The Regents of the University of California.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by the University of  *	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)ex.c	8.1 (Berkeley) 6/9/93"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|"vi.h"
end_include

begin_include
include|#
directive|include
file|"excmd.h"
end_include

begin_decl_stmt
name|char
modifier|*
name|defcmdarg
index|[
literal|2
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|linespec
name|__P
argument_list|(
operator|(
name|SCR
operator|*
operator|,
name|EXF
operator|*
operator|,
name|char
operator|*
operator|,
name|EXCMDARG
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|DEFCOM
value|".+1"
end_define

begin_comment
comment|/*  * ex --  *	Read an ex command and execute it.  */
end_comment

begin_function
name|int
name|ex
parameter_list|(
name|sp
parameter_list|,
name|ep
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
name|EXF
modifier|*
name|ep
decl_stmt|;
block|{
name|TEXT
modifier|*
name|tp
decl_stmt|;
name|int
name|eval
decl_stmt|;
name|char
name|defcom
index|[
sizeof|sizeof
argument_list|(
name|DEFCOM
argument_list|)
index|]
decl_stmt|;
if|if
condition|(
name|ex_init
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|sp
operator|->
name|s_refresh
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|)
condition|)
return|return
operator|(
name|ex_end
argument_list|(
name|sp
argument_list|)
operator|)
return|;
for|for
control|(
name|eval
operator|=
literal|0
init|;
condition|;
control|)
block|{
if|if
condition|(
name|sp
operator|->
name|s_get
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
operator|&
name|sp
operator|->
name|bhdr
argument_list|,
literal|':'
argument_list|,
name|TXT_CR
operator||
name|TXT_PROMPT
argument_list|)
condition|)
continue|continue;
name|tp
operator|=
name|sp
operator|->
name|bhdr
operator|.
name|next
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|len
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fputc
argument_list|(
literal|'\r'
argument_list|,
name|sp
operator|->
name|stdfp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|sp
operator|->
name|stdfp
argument_list|)
expr_stmt|;
name|memmove
argument_list|(
name|defcom
argument_list|,
name|DEFCOM
argument_list|,
sizeof|sizeof
argument_list|(
name|DEFCOM
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|ex_cstring
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
name|defcom
argument_list|,
sizeof|sizeof
argument_list|(
name|DEFCOM
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|sp
operator|->
name|stdfp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|ex_cstring
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
name|tp
operator|->
name|lb
argument_list|,
name|tp
operator|->
name|len
argument_list|)
expr_stmt|;
block|}
name|msg_rpt
argument_list|(
name|sp
argument_list|,
name|sp
operator|->
name|stdfp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|F_ISSET
argument_list|(
name|sp
argument_list|,
name|S_MODE_EX
argument_list|)
operator|||
name|F_ISSET
argument_list|(
name|sp
argument_list|,
name|S_MAJOR_CHANGE
argument_list|)
condition|)
break|break;
if|if
condition|(
name|sp
operator|->
name|s_refresh
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|)
condition|)
block|{
name|eval
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
return|return
operator|(
name|ex_end
argument_list|(
name|sp
argument_list|)
operator|||
name|eval
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * ex_cfile --  *	Execute ex commands from a file.  */
end_comment

begin_function
name|int
name|ex_cfile
parameter_list|(
name|sp
parameter_list|,
name|ep
parameter_list|,
name|filename
parameter_list|,
name|noexisterr
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
name|EXF
modifier|*
name|ep
decl_stmt|;
name|char
modifier|*
name|filename
decl_stmt|;
name|int
name|noexisterr
decl_stmt|;
block|{
name|struct
name|stat
name|sb
decl_stmt|;
name|int
name|fd
decl_stmt|,
name|len
decl_stmt|,
name|rval
decl_stmt|;
name|char
modifier|*
name|bp
decl_stmt|;
if|if
condition|(
operator|(
name|fd
operator|=
name|open
argument_list|(
name|filename
argument_list|,
name|O_RDONLY
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|noexisterr
condition|)
goto|goto
name|e1
goto|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|fstat
argument_list|(
name|fd
argument_list|,
operator|&
name|sb
argument_list|)
condition|)
goto|goto
name|e2
goto|;
if|if
condition|(
name|sb
operator|.
name|st_size
operator|>
name|SIZE_T_MAX
condition|)
block|{
name|errno
operator|=
name|E2BIG
expr_stmt|;
goto|goto
name|e2
goto|;
block|}
if|if
condition|(
operator|(
name|bp
operator|=
name|malloc
argument_list|(
name|sb
operator|.
name|st_size
argument_list|)
operator|)
operator|==
name|NULL
condition|)
goto|goto
name|e2
goto|;
name|len
operator|=
name|read
argument_list|(
name|fd
argument_list|,
name|bp
argument_list|,
operator|(
name|int
operator|)
name|sb
operator|.
name|st_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|==
operator|-
literal|1
operator|||
name|len
operator|!=
name|sb
operator|.
name|st_size
condition|)
block|{
if|if
condition|(
name|len
operator|!=
name|sb
operator|.
name|st_size
condition|)
name|errno
operator|=
name|EIO
expr_stmt|;
goto|goto
name|e3
goto|;
block|}
name|bp
index|[
name|sb
operator|.
name|st_size
index|]
operator|=
literal|'\0'
expr_stmt|;
name|rval
operator|=
name|ex_cstring
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
name|bp
argument_list|,
name|len
argument_list|)
expr_stmt|;
comment|/* 	 * XXX 	 * THE UNDERLYING EXF MAY HAVE CHANGED (but we don't care). 	 */
name|free
argument_list|(
name|bp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
operator|(
name|rval
operator|)
return|;
name|e3
label|:
name|free
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|e2
label|:
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|e1
label|:
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_ERR
argument_list|,
literal|"%s: %s."
argument_list|,
name|filename
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * ex_cstring --  *	Execute EX commands from a string.  The commands may be separated  *	by newlines or by | characters, and may be quoted.  Quotes are  *	either the user's literal next character or a backslash.  Literal  *	next characters are translated into backslashes.  */
end_comment

begin_function
name|int
name|ex_cstring
parameter_list|(
name|sp
parameter_list|,
name|ep
parameter_list|,
name|cmd
parameter_list|,
name|len
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
name|EXF
modifier|*
name|ep
decl_stmt|;
name|char
modifier|*
name|cmd
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
name|u_int
name|saved_mode
decl_stmt|;
name|int
name|ch
decl_stmt|,
name|cnt
decl_stmt|,
name|rval
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|t
decl_stmt|;
name|rval
operator|=
literal|0
expr_stmt|;
name|saved_mode
operator|=
name|F_ISSET
argument_list|(
name|sp
argument_list|,
name|S_MODE_EX
operator||
name|S_MODE_VI
operator||
name|S_MAJOR_CHANGE
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|t
operator|=
name|cmd
operator|,
name|cnt
operator|=
literal|0
init|;
condition|;
operator|++
name|cnt
operator|,
operator|--
name|len
control|)
block|{
if|if
condition|(
name|len
operator|==
literal|0
condition|)
goto|goto
name|cend
goto|;
switch|switch
condition|(
name|ch
operator|=
operator|*
name|t
operator|++
condition|)
block|{
case|case
literal|'|'
case|:
case|case
literal|'\n'
case|:
name|cend
label|:
if|if
condition|(
name|p
operator|>
name|cmd
condition|)
block|{
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
comment|/* XXX: 8BIT */
comment|/* 				 * Errors are ignored, although error 				 * messages will be displayed later. 				 */
if|if
condition|(
name|ex_cmd
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
name|cmd
argument_list|)
condition|)
name|rval
operator|=
literal|1
expr_stmt|;
name|p
operator|=
name|cmd
expr_stmt|;
block|}
if|if
condition|(
name|len
operator|==
literal|0
condition|)
return|return
operator|(
name|rval
operator|)
return|;
if|if
condition|(
name|saved_mode
operator|!=
name|F_ISSET
argument_list|(
name|sp
argument_list|,
name|S_MODE_EX
operator||
name|S_MODE_VI
operator||
name|S_MAJOR_CHANGE
argument_list|)
condition|)
block|{
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_ERR
argument_list|,
literal|"File or status changed, remaining input discarded."
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
break|break;
default|default:
if|if
condition|(
name|ch
operator|==
literal|'\\'
operator|||
name|sp
operator|->
name|special
index|[
name|ch
index|]
operator|==
name|K_VLNEXT
condition|)
block|{
operator|*
name|p
operator|++
operator|=
literal|'\\'
expr_stmt|;
if|if
condition|(
name|len
operator|==
literal|1
condition|)
break|break;
operator|--
name|len
expr_stmt|;
name|ch
operator|=
operator|*
name|t
operator|++
expr_stmt|;
block|}
operator|*
name|p
operator|++
operator|=
name|ch
expr_stmt|;
break|break;
block|}
block|}
comment|/* NOTREACHED */
block|}
end_function

begin_comment
comment|/*  * ex_cmd --  *	Parse and execute an ex command.    */
end_comment

begin_function
name|int
name|ex_cmd
parameter_list|(
name|sp
parameter_list|,
name|ep
parameter_list|,
name|exc
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
name|EXF
modifier|*
name|ep
decl_stmt|;
name|char
modifier|*
name|exc
decl_stmt|;
block|{
name|EXCMDARG
name|cmd
decl_stmt|;
name|EXCMDLIST
modifier|*
name|cp
decl_stmt|;
name|recno_t
name|lcount
decl_stmt|,
name|lno
decl_stmt|,
name|num
decl_stmt|;
name|long
name|flagoff
decl_stmt|;
name|u_int
name|saved_mode
decl_stmt|;
name|int
name|ch
decl_stmt|,
name|cmdlen
decl_stmt|,
name|flags
decl_stmt|,
name|uselastcmd
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|endp
decl_stmt|;
if|#
directive|if
name|DEBUG
operator|&&
literal|0
name|TRACE
argument_list|(
name|sp
argument_list|,
literal|"ex: {%s}\n"
argument_list|,
name|exc
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Permit a single extra colon at the start of the line, for 	 * historical reasons. 	 */
if|if
condition|(
operator|*
name|exc
operator|==
literal|':'
condition|)
operator|++
name|exc
expr_stmt|;
comment|/* Ignore command lines that start with a double-quote. */
if|if
condition|(
operator|*
name|exc
operator|==
literal|'"'
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Skip whitespace. */
for|for
control|(
init|;
name|isspace
argument_list|(
operator|*
name|exc
argument_list|)
condition|;
operator|++
name|exc
control|)
empty_stmt|;
comment|/* Initialize the argument structure. */
name|memset
argument_list|(
operator|&
name|cmd
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|EXCMDARG
argument_list|)
argument_list|)
expr_stmt|;
name|cmd
operator|.
name|buffer
operator|=
name|OOBCB
expr_stmt|;
comment|/* 	 * Parse line specifiers if the command uses addresses.  New command 	 * line position is returned, or NULL on error.   	 */
if|if
condition|(
operator|(
name|exc
operator|=
name|linespec
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
name|exc
argument_list|,
operator|&
name|cmd
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* Skip whitespace. */
for|for
control|(
init|;
name|isspace
argument_list|(
operator|*
name|exc
argument_list|)
condition|;
operator|++
name|exc
control|)
empty_stmt|;
comment|/* 	 * If no command, ex does the last specified of p, l, or #, and vi 	 * moves to the line.  Otherwise, find out how long the command name 	 * is.  There are a few commands that aren't alphabetic, but they 	 * are all single character commands. 	 */
if|if
condition|(
operator|*
name|exc
condition|)
block|{
if|if
condition|(
name|strchr
argument_list|(
literal|"!#&<=>@"
argument_list|,
operator|*
name|exc
argument_list|)
condition|)
block|{
name|p
operator|=
name|exc
expr_stmt|;
name|exc
operator|++
expr_stmt|;
name|cmdlen
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|p
operator|=
name|exc
init|;
name|isalpha
argument_list|(
operator|*
name|exc
argument_list|)
condition|;
operator|++
name|exc
control|)
empty_stmt|;
name|cmdlen
operator|=
name|exc
operator|-
name|p
expr_stmt|;
block|}
for|for
control|(
name|cp
operator|=
name|cmds
init|;
name|cp
operator|->
name|name
operator|&&
name|memcmp
argument_list|(
name|p
argument_list|,
name|cp
operator|->
name|name
argument_list|,
name|cmdlen
argument_list|)
condition|;
operator|++
name|cp
control|)
empty_stmt|;
if|if
condition|(
name|cp
operator|->
name|name
operator|==
name|NULL
condition|)
block|{
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_ERR
argument_list|,
literal|"The %.*s command is unknown."
argument_list|,
name|cmdlen
argument_list|,
name|p
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|uselastcmd
operator|=
literal|0
expr_stmt|;
comment|/* Some commands are turned off. */
if|if
condition|(
name|F_ISSET
argument_list|(
name|cp
argument_list|,
name|E_NOPERM
argument_list|)
condition|)
block|{
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_ERR
argument_list|,
literal|"The %.*s command is not currently supported."
argument_list|,
name|cmdlen
argument_list|,
name|p
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* Some commands aren't okay in globals. */
if|if
condition|(
name|F_ISSET
argument_list|(
name|sp
argument_list|,
name|S_GLOBAL
argument_list|)
operator|&&
name|F_ISSET
argument_list|(
name|cp
argument_list|,
name|E_NOGLOBAL
argument_list|)
condition|)
block|{
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_ERR
argument_list|,
literal|"The %.*s command can't be used as part of a global command."
argument_list|,
name|cmdlen
argument_list|,
name|p
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* 		 * Another "special" feature. 		 * NOTE: cmd.string is NOT nul terminated in this case. 		 */
if|if
condition|(
name|cp
operator|==
operator|&
name|cmds
index|[
name|C_SHIFTL
index|]
operator|&&
operator|*
name|exc
operator|==
literal|'<'
operator|||
name|cp
operator|==
operator|&
name|cmds
index|[
name|C_SHIFTR
index|]
operator|&&
operator|*
name|exc
operator|==
literal|'>'
condition|)
block|{
name|ch
operator|=
operator|*
name|exc
expr_stmt|;
for|for
control|(
name|cmd
operator|.
name|string
operator|=
name|exc
init|;
operator|*
operator|++
name|exc
operator|==
name|ch
condition|;
control|)
empty_stmt|;
block|}
block|}
else|else
block|{
name|cp
operator|=
name|sp
operator|->
name|lastcmd
expr_stmt|;
name|uselastcmd
operator|=
literal|1
expr_stmt|;
block|}
name|LF_INIT
argument_list|(
name|cp
operator|->
name|flags
argument_list|)
expr_stmt|;
comment|/* 	 * File state must be checked throughout this code, because it is 	 * called when reading the .exrc file and similar things.  There's 	 * this little chicken and egg problem -- if we read the file first, 	 * we won't know how to display it.  If we read/set the exrc stuff 	 * first, we can't allow any command that requires file state. 	 * Historic vi generally took the easy way out and dropped core.  	 */
if|if
condition|(
name|LF_ISSET
argument_list|(
name|E_NORC
argument_list|)
operator|&&
name|ep
operator|==
name|NULL
condition|)
block|{
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_ERR
argument_list|,
literal|"The %s command requires a file to already have been read in."
argument_list|,
name|cp
operator|->
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* 	 * Set the default addresses.  It's an error to specify an address for 	 * a command that doesn't take them.  If two addresses are specified 	 * for a command that only takes one, lose the first one.  Two special 	 * cases here, some commands take 0 or 2 addresses.  For most of them 	 * (the E_ADDR2_ALL flag), 0 defaults to the entire file.  For one 	 * (the `!' command, the E_ADDR2_NONE flag), 0 defaults to no lines. 	 * 	 * Also, if the file is empty, some commands want to use an address of 	 * 0, i.e. the entire file is 0 to 0, and the default first address is 	 * 0.  Otherwise, an entire file is 1 to N and the default line is 1. 	 * Note, we also add the E_ZERO flag to the command flags, for the case 	 * where the 0 address is only valid if it's a default address. 	 */
name|flagoff
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|flags
operator|&
operator|(
name|E_ADDR1
operator||
name|E_ADDR2
operator||
name|E_ADDR2_ALL
operator||
name|E_ADDR2_NONE
operator|)
condition|)
block|{
case|case
name|E_ADDR1
case|:
comment|/* One address: */
switch|switch
condition|(
name|cmd
operator|.
name|addrcnt
condition|)
block|{
case|case
literal|0
case|:
comment|/* Default cursor/empty file. */
name|cmd
operator|.
name|addrcnt
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|LF_ISSET
argument_list|(
name|E_ZERODEF
argument_list|)
condition|)
block|{
if|if
condition|(
name|file_lline
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
operator|&
name|lno
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|lno
operator|==
literal|0
condition|)
block|{
name|cmd
operator|.
name|addr1
operator|.
name|lno
operator|=
literal|0
expr_stmt|;
name|LF_SET
argument_list|(
name|E_ZERO
argument_list|)
expr_stmt|;
block|}
else|else
name|cmd
operator|.
name|addr1
operator|.
name|lno
operator|=
name|sp
operator|->
name|lno
expr_stmt|;
block|}
else|else
name|cmd
operator|.
name|addr1
operator|.
name|lno
operator|=
name|sp
operator|->
name|lno
expr_stmt|;
name|cmd
operator|.
name|addr1
operator|.
name|cno
operator|=
name|sp
operator|->
name|cno
expr_stmt|;
break|break;
case|case
literal|1
case|:
break|break;
case|case
literal|2
case|:
comment|/* Lose the first address. */
name|cmd
operator|.
name|addrcnt
operator|=
literal|1
expr_stmt|;
name|cmd
operator|.
name|addr1
operator|=
name|cmd
operator|.
name|addr2
expr_stmt|;
block|}
break|break;
case|case
name|E_ADDR2_NONE
case|:
comment|/* Zero/two addresses: */
if|if
condition|(
name|cmd
operator|.
name|addrcnt
operator|==
literal|0
condition|)
comment|/* Default to nothing. */
break|break;
goto|goto
name|two
goto|;
case|case
name|E_ADDR2_ALL
case|:
comment|/* Zero/two addresses: */
if|if
condition|(
name|cmd
operator|.
name|addrcnt
operator|==
literal|0
condition|)
block|{
comment|/* Default entire/empty file. */
name|cmd
operator|.
name|addrcnt
operator|=
literal|2
expr_stmt|;
if|if
condition|(
name|file_lline
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
operator|&
name|cmd
operator|.
name|addr2
operator|.
name|lno
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|LF_ISSET
argument_list|(
name|E_ZERODEF
argument_list|)
operator|&&
name|cmd
operator|.
name|addr2
operator|.
name|lno
operator|==
literal|0
condition|)
block|{
name|cmd
operator|.
name|addr1
operator|.
name|lno
operator|=
literal|0
expr_stmt|;
name|LF_SET
argument_list|(
name|E_ZERO
argument_list|)
expr_stmt|;
block|}
else|else
name|cmd
operator|.
name|addr1
operator|.
name|lno
operator|=
literal|1
expr_stmt|;
name|cmd
operator|.
name|addr1
operator|.
name|cno
operator|=
name|cmd
operator|.
name|addr2
operator|.
name|cno
operator|=
literal|0
expr_stmt|;
name|cmd
operator|.
name|flags
operator||=
name|E_ADDR2_ALL
expr_stmt|;
break|break;
block|}
comment|/* FALLTHROUGH */
case|case
name|E_ADDR2
case|:
comment|/* Two addresses: */
name|two
label|:
switch|switch
condition|(
name|cmd
operator|.
name|addrcnt
condition|)
block|{
case|case
literal|0
case|:
comment|/* Default cursor/empty file. */
name|cmd
operator|.
name|addrcnt
operator|=
literal|2
expr_stmt|;
if|if
condition|(
name|LF_ISSET
argument_list|(
name|E_ZERODEF
argument_list|)
operator|&&
name|sp
operator|->
name|lno
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|file_lline
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
operator|&
name|lno
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|lno
operator|==
literal|0
condition|)
block|{
name|cmd
operator|.
name|addr1
operator|.
name|lno
operator|=
name|cmd
operator|.
name|addr2
operator|.
name|lno
operator|=
literal|0
expr_stmt|;
name|LF_SET
argument_list|(
name|E_ZERO
argument_list|)
expr_stmt|;
block|}
else|else
name|cmd
operator|.
name|addr1
operator|.
name|lno
operator|=
name|cmd
operator|.
name|addr2
operator|.
name|lno
operator|=
name|sp
operator|->
name|lno
expr_stmt|;
block|}
else|else
name|cmd
operator|.
name|addr1
operator|.
name|lno
operator|=
name|cmd
operator|.
name|addr2
operator|.
name|lno
operator|=
name|sp
operator|->
name|lno
expr_stmt|;
name|cmd
operator|.
name|addr1
operator|.
name|cno
operator|=
name|cmd
operator|.
name|addr2
operator|.
name|cno
operator|=
name|sp
operator|->
name|cno
expr_stmt|;
break|break;
case|case
literal|1
case|:
comment|/* Default to first address. */
name|cmd
operator|.
name|addrcnt
operator|=
literal|2
expr_stmt|;
name|cmd
operator|.
name|addr2
operator|=
name|cmd
operator|.
name|addr1
expr_stmt|;
break|break;
case|case
literal|2
case|:
break|break;
block|}
break|break;
default|default:
if|if
condition|(
name|cmd
operator|.
name|addrcnt
condition|)
comment|/* Error. */
goto|goto
name|usage
goto|;
block|}
comment|/* 	 * If the entire string is parsed by the command itself, we don't 	 * even skip leading white-space, it's significant for some commands. 	 * However, require that there be *something*. 	 */
if|if
condition|(
name|cp
operator|->
name|syntax
index|[
literal|0
index|]
operator|==
literal|'s'
condition|)
block|{
for|for
control|(
name|p
operator|=
name|exc
init|;
operator|*
name|p
operator|&&
name|isspace
argument_list|(
operator|*
name|p
argument_list|)
condition|;
operator|++
name|p
control|)
empty_stmt|;
name|cmd
operator|.
name|string
operator|=
operator|*
name|p
condition|?
name|exc
else|:
name|NULL
expr_stmt|;
goto|goto
name|addr2
goto|;
block|}
for|for
control|(
name|lcount
operator|=
literal|0
operator|,
name|p
operator|=
name|cp
operator|->
name|syntax
init|;
operator|*
name|p
condition|;
operator|++
name|p
control|)
block|{
for|for
control|(
init|;
name|isspace
argument_list|(
operator|*
name|exc
argument_list|)
condition|;
operator|++
name|exc
control|)
empty_stmt|;
comment|/* Skip whitespace. */
if|if
condition|(
operator|!
operator|*
name|exc
condition|)
break|break;
switch|switch
condition|(
operator|*
name|p
condition|)
block|{
case|case
literal|'!'
case|:
comment|/* ! */
if|if
condition|(
operator|*
name|exc
operator|==
literal|'!'
condition|)
block|{
operator|++
name|exc
expr_stmt|;
name|cmd
operator|.
name|flags
operator||=
name|E_FORCE
expr_stmt|;
block|}
break|break;
case|case
literal|'+'
case|:
comment|/* +cmd */
if|if
condition|(
operator|*
name|exc
operator|!=
literal|'+'
condition|)
break|break;
for|for
control|(
name|cmd
operator|.
name|plus
operator|=
operator|++
name|exc
init|;
operator|!
name|isspace
argument_list|(
operator|*
name|exc
argument_list|)
condition|;
operator|++
name|exc
control|)
empty_stmt|;
if|if
condition|(
operator|*
name|exc
condition|)
operator|*
name|exc
operator|++
operator|=
literal|'\0'
expr_stmt|;
break|break;
case|case
literal|'1'
case|:
comment|/* #, l, p */
for|for
control|(
init|;
operator|*
name|exc
operator|==
literal|'+'
operator|||
operator|*
name|exc
operator|==
literal|'-'
condition|;
operator|++
name|exc
control|)
switch|switch
condition|(
operator|*
name|exc
condition|)
block|{
case|case
literal|'+'
case|:
operator|++
name|flagoff
expr_stmt|;
break|break;
case|case
literal|'-'
case|:
operator|--
name|flagoff
expr_stmt|;
break|break;
block|}
for|for
control|(
init|;
operator|*
name|exc
operator|==
literal|'#'
operator|||
operator|*
name|exc
operator|==
literal|'l'
operator|||
operator|*
name|exc
operator|==
literal|'p'
condition|;
operator|++
name|exc
control|)
switch|switch
condition|(
operator|*
name|exc
condition|)
block|{
case|case
literal|'#'
case|:
name|cmd
operator|.
name|flags
operator||=
name|E_F_HASH
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
name|cmd
operator|.
name|flags
operator||=
name|E_F_LIST
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
name|cmd
operator|.
name|flags
operator||=
name|E_F_PRINT
expr_stmt|;
break|break;
block|}
for|for
control|(
init|;
operator|*
name|exc
operator|==
literal|'+'
operator|||
operator|*
name|exc
operator|==
literal|'-'
condition|;
operator|++
name|exc
control|)
switch|switch
condition|(
operator|*
name|exc
condition|)
block|{
case|case
literal|'+'
case|:
operator|++
name|flagoff
expr_stmt|;
break|break;
case|case
literal|'-'
case|:
operator|--
name|flagoff
expr_stmt|;
break|break;
block|}
break|break;
case|case
literal|'2'
case|:
comment|/* -, ., +, ^ */
for|for
control|(
init|;
condition|;
operator|++
name|exc
control|)
switch|switch
condition|(
operator|*
name|exc
condition|)
block|{
case|case
literal|'-'
case|:
name|cmd
operator|.
name|flags
operator||=
name|E_F_DASH
expr_stmt|;
break|break;
case|case
literal|'.'
case|:
name|cmd
operator|.
name|flags
operator||=
name|E_F_DOT
expr_stmt|;
break|break;
case|case
literal|'+'
case|:
name|cmd
operator|.
name|flags
operator||=
name|E_F_PLUS
expr_stmt|;
break|break;
case|case
literal|'^'
case|:
name|cmd
operator|.
name|flags
operator||=
name|E_F_CARAT
expr_stmt|;
break|break;
default|default:
goto|goto
name|end2
goto|;
block|}
name|end2
label|:
break|break;
ifdef|#
directive|ifdef
name|XXX_THIS_NO_LONGER_USED
case|case
literal|'>'
case|:
comment|/*>> */
if|if
condition|(
name|exc
index|[
literal|0
index|]
operator|==
literal|'>'
operator|&&
name|exc
index|[
literal|1
index|]
operator|==
literal|'>'
condition|)
block|{
name|cmd
operator|.
name|flags
operator||=
name|E_APPEND
expr_stmt|;
name|exc
operator|+=
literal|2
expr_stmt|;
block|}
break|break;
endif|#
directive|endif
case|case
literal|'b'
case|:
comment|/* buffer */
name|cmd
operator|.
name|buffer
operator|=
operator|*
name|exc
operator|++
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
comment|/* count */
if|if
condition|(
name|isdigit
argument_list|(
operator|*
name|exc
argument_list|)
condition|)
block|{
name|lcount
operator|=
name|strtol
argument_list|(
name|exc
argument_list|,
operator|&
name|endp
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|lcount
operator|==
literal|0
condition|)
block|{
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_ERR
argument_list|,
literal|"Count may not be zero."
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|exc
operator|=
name|endp
expr_stmt|;
comment|/* 				 * Fix up the addresses.  Count's only occur 				 * with commands taking two addresses.  The 				 * historic vi practice was to use the count 				 * as an offset from the *second* address. 				 */
name|cmd
operator|.
name|addr1
operator|=
name|cmd
operator|.
name|addr2
expr_stmt|;
name|cmd
operator|.
name|addr2
operator|.
name|lno
operator|=
name|cmd
operator|.
name|addr1
operator|.
name|lno
operator|+
name|lcount
operator|-
literal|1
expr_stmt|;
block|}
break|break;
case|case
literal|'l'
case|:
comment|/* line */
if|if
condition|(
name|isdigit
argument_list|(
operator|*
name|exc
argument_list|)
condition|)
block|{
name|cmd
operator|.
name|lineno
operator|=
name|strtol
argument_list|(
name|exc
argument_list|,
operator|&
name|endp
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|exc
operator|=
name|endp
expr_stmt|;
block|}
break|break;
case|case
literal|'f'
case|:
comment|/* file */
if|if
condition|(
name|buildargv
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
name|exc
argument_list|,
literal|1
argument_list|,
operator|&
name|cmd
operator|.
name|argc
argument_list|,
operator|&
name|cmd
operator|.
name|argv
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
goto|goto
name|countchk
goto|;
case|case
literal|'s'
case|:
comment|/* string */
for|for
control|(
name|p
operator|=
name|exc
init|;
operator|*
name|p
operator|&&
name|isspace
argument_list|(
operator|*
name|p
argument_list|)
condition|;
operator|++
name|p
control|)
empty_stmt|;
name|cmd
operator|.
name|string
operator|=
operator|*
name|p
condition|?
name|exc
else|:
name|NULL
expr_stmt|;
goto|goto
name|addr2
goto|;
case|case
literal|'w'
case|:
comment|/* word */
if|if
condition|(
name|buildargv
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
name|exc
argument_list|,
literal|0
argument_list|,
operator|&
name|cmd
operator|.
name|argc
argument_list|,
operator|&
name|cmd
operator|.
name|argv
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|countchk
label|:
if|if
condition|(
operator|*
operator|++
name|p
operator|!=
literal|'N'
condition|)
block|{
comment|/* N */
comment|/* 				 * If a number is specified, must either be 				 * 0 or that number, if optional, and that 				 * number, if required. 				 */
name|num
operator|=
operator|*
name|p
operator|-
literal|'0'
expr_stmt|;
if|if
condition|(
operator|(
operator|*
operator|++
name|p
operator|!=
literal|'o'
operator|||
name|cmd
operator|.
name|argc
operator|!=
literal|0
operator|)
operator|&&
name|cmd
operator|.
name|argc
operator|!=
name|num
condition|)
goto|goto
name|usage
goto|;
block|}
goto|goto
name|addr2
goto|;
default|default:
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_ERR
argument_list|,
literal|"Internal syntax table error (%s)."
argument_list|,
name|cp
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * Shouldn't be anything left, and no more required fields. 	 * That means neither 'l' or 'r' in the syntax. 	 */
for|for
control|(
init|;
operator|*
name|exc
operator|&&
name|isspace
argument_list|(
operator|*
name|exc
argument_list|)
condition|;
operator|++
name|exc
control|)
empty_stmt|;
if|if
condition|(
operator|*
name|exc
operator|||
name|strpbrk
argument_list|(
name|p
argument_list|,
literal|"lr"
argument_list|)
condition|)
block|{
name|usage
label|:
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_ERR
argument_list|,
literal|"Usage: %s."
argument_list|,
name|cp
operator|->
name|usage
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* Verify that the addresses are legal. */
name|addr2
label|:
switch|switch
condition|(
name|cmd
operator|.
name|addrcnt
condition|)
block|{
case|case
literal|2
case|:
if|if
condition|(
name|file_lline
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
operator|&
name|lcount
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|cmd
operator|.
name|addr2
operator|.
name|lno
operator|>
name|lcount
condition|)
block|{
if|if
condition|(
name|lcount
operator|==
literal|0
condition|)
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_ERR
argument_list|,
literal|"The file is empty."
argument_list|)
expr_stmt|;
else|else
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_ERR
argument_list|,
literal|"Only %lu line%s in the file"
argument_list|,
name|lcount
argument_list|,
name|lcount
operator|>
literal|1
condition|?
literal|"s"
else|:
literal|""
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* FALLTHROUGH */
case|case
literal|1
case|:
name|num
operator|=
name|cmd
operator|.
name|addr1
operator|.
name|lno
expr_stmt|;
comment|/* 		 * If it's a "default vi command", zero is okay.  Historic 		 * vi allowed this, note, it's also the hack that allows 		 * "vi + nonexistent_file" to work. 		 */
if|if
condition|(
name|num
operator|==
literal|0
operator|&&
operator|(
operator|!
name|F_ISSET
argument_list|(
name|sp
argument_list|,
name|S_MODE_VI
argument_list|)
operator|||
name|uselastcmd
operator|!=
literal|1
operator|)
operator|&&
operator|!
name|LF_ISSET
argument_list|(
name|E_ZERO
argument_list|)
condition|)
block|{
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_ERR
argument_list|,
literal|"The %s command doesn't permit an address of 0."
argument_list|,
name|cp
operator|->
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|file_lline
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
operator|&
name|lcount
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|num
operator|>
name|lcount
condition|)
block|{
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_ERR
argument_list|,
literal|"Only %lu line%s in the file"
argument_list|,
name|lcount
argument_list|,
name|lcount
operator|>
literal|1
condition|?
literal|"s"
else|:
literal|""
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
break|break;
block|}
comment|/* If doing a default command, vi just moves to the line. */
if|if
condition|(
name|F_ISSET
argument_list|(
name|sp
argument_list|,
name|S_MODE_VI
argument_list|)
operator|&&
name|uselastcmd
condition|)
block|{
name|sp
operator|->
name|lno
operator|=
name|cmd
operator|.
name|addr1
operator|.
name|lno
condition|?
name|cmd
operator|.
name|addr1
operator|.
name|lno
else|:
literal|1
expr_stmt|;
name|sp
operator|->
name|cno
operator|=
name|cmd
operator|.
name|addr1
operator|.
name|cno
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* Reset "last" command. */
if|if
condition|(
name|LF_ISSET
argument_list|(
name|E_SETLAST
argument_list|)
condition|)
name|sp
operator|->
name|lastcmd
operator|=
name|cp
expr_stmt|;
name|cmd
operator|.
name|cmd
operator|=
name|cp
expr_stmt|;
if|#
directive|if
name|DEBUG
operator|&&
literal|0
block|{
name|int
name|__cnt
decl_stmt|;
name|TRACE
argument_list|(
name|sp
argument_list|,
literal|"ex_cmd: %s"
argument_list|,
name|cmd
operator|.
name|cmd
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmd
operator|.
name|addrcnt
operator|>
literal|0
condition|)
block|{
name|TRACE
argument_list|(
name|sp
argument_list|,
literal|"\taddr1 %d"
argument_list|,
name|cmd
operator|.
name|addr1
operator|.
name|lno
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmd
operator|.
name|addrcnt
operator|>
literal|1
condition|)
name|TRACE
argument_list|(
name|sp
argument_list|,
literal|" addr2: %d"
argument_list|,
name|cmd
operator|.
name|addr2
operator|.
name|lno
argument_list|)
expr_stmt|;
name|TRACE
argument_list|(
name|sp
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cmd
operator|.
name|lineno
condition|)
name|TRACE
argument_list|(
name|sp
argument_list|,
literal|"\tlineno %d"
argument_list|,
name|cmd
operator|.
name|lineno
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmd
operator|.
name|flags
condition|)
name|TRACE
argument_list|(
name|sp
argument_list|,
literal|"\tflags %0x"
argument_list|,
name|cmd
operator|.
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmd
operator|.
name|command
condition|)
name|TRACE
argument_list|(
name|sp
argument_list|,
literal|"\tcommand %s"
argument_list|,
name|cmd
operator|.
name|command
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmd
operator|.
name|plus
condition|)
name|TRACE
argument_list|(
name|sp
argument_list|,
literal|"\tplus %s"
argument_list|,
name|cmd
operator|.
name|plus
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmd
operator|.
name|buffer
operator|!=
name|OOBCB
condition|)
name|TRACE
argument_list|(
name|sp
argument_list|,
literal|"\tbuffer %c"
argument_list|,
name|cmd
operator|.
name|buffer
argument_list|)
expr_stmt|;
name|TRACE
argument_list|(
name|sp
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmd
operator|.
name|argc
condition|)
block|{
for|for
control|(
name|__cnt
operator|=
literal|0
init|;
name|__cnt
operator|<
name|cmd
operator|.
name|argc
condition|;
operator|++
name|__cnt
control|)
name|TRACE
argument_list|(
name|sp
argument_list|,
literal|"\targ %d: {%s}"
argument_list|,
name|__cnt
argument_list|,
name|cmd
operator|.
name|argv
index|[
name|__cnt
index|]
argument_list|)
expr_stmt|;
name|TRACE
argument_list|(
name|sp
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* Clear autoprint. */
name|F_CLR
argument_list|(
name|sp
argument_list|,
name|S_AUTOPRINT
argument_list|)
expr_stmt|;
comment|/* 	 * If file state and not doing a global command, log the start of 	 * an action. 	 */
if|if
condition|(
name|ep
operator|!=
name|NULL
operator|&&
operator|!
name|F_ISSET
argument_list|(
name|sp
argument_list|,
name|S_GLOBAL
argument_list|)
condition|)
operator|(
name|void
operator|)
name|log_cursor
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|)
expr_stmt|;
comment|/* Save the current mode. */
name|saved_mode
operator|=
name|F_ISSET
argument_list|(
name|sp
argument_list|,
name|S_MODE_EX
operator||
name|S_MODE_VI
operator||
name|S_MAJOR_CHANGE
argument_list|)
expr_stmt|;
comment|/* Do the command. */
if|if
condition|(
call|(
name|cp
operator|->
name|fn
call|)
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
operator|&
name|cmd
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* If the world changed, we're done. */
if|if
condition|(
name|saved_mode
operator|!=
name|F_ISSET
argument_list|(
name|sp
argument_list|,
name|S_MODE_EX
operator||
name|S_MODE_VI
operator||
name|S_MAJOR_CHANGE
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* If just starting up, or not in ex mode, we're done. */
if|if
condition|(
name|ep
operator|==
name|NULL
operator|||
operator|!
name|F_ISSET
argument_list|(
name|sp
argument_list|,
name|S_MODE_EX
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 	 * The print commands have already handled the `print' flags. 	 * If so, clear them.  Don't return, autoprint may still have 	 * stuff to print out. 	 */
if|if
condition|(
name|LF_ISSET
argument_list|(
name|E_F_PRCLEAR
argument_list|)
condition|)
name|cmd
operator|.
name|flags
operator|&=
operator|~
operator|(
name|E_F_HASH
operator||
name|E_F_LIST
operator||
name|E_F_PRINT
operator|)
expr_stmt|;
comment|/* 	 * If the command was successful, and there was an explicit flag to 	 * display the new cursor line, or we're in ex mode, autoprint is set, 	 * and a change was made, display the line. 	 */
if|if
condition|(
name|flagoff
condition|)
block|{
if|if
condition|(
name|flagoff
operator|<
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|recno_t
operator|)
name|flagoff
operator|>
name|sp
operator|->
name|lno
condition|)
block|{
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_ERR
argument_list|,
literal|"Flag offset before line 1."
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|file_lline
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
operator|&
name|lno
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|sp
operator|->
name|lno
operator|+
name|flagoff
operator|>
name|lno
condition|)
block|{
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_ERR
argument_list|,
literal|"Flag offset past end-of-file."
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
name|sp
operator|->
name|lno
operator|+=
name|flagoff
expr_stmt|;
block|}
if|if
condition|(
name|F_ISSET
argument_list|(
name|sp
argument_list|,
name|S_AUTOPRINT
argument_list|)
operator|&&
name|O_ISSET
argument_list|(
name|sp
argument_list|,
name|O_AUTOPRINT
argument_list|)
condition|)
name|LF_INIT
argument_list|(
name|E_F_PRINT
argument_list|)
expr_stmt|;
else|else
name|LF_INIT
argument_list|(
name|cmd
operator|.
name|flags
operator|&
operator|(
name|E_F_HASH
operator||
name|E_F_LIST
operator||
name|E_F_PRINT
operator|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|cmd
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|EXCMDARG
argument_list|)
argument_list|)
expr_stmt|;
name|cmd
operator|.
name|addrcnt
operator|=
literal|2
expr_stmt|;
name|cmd
operator|.
name|addr1
operator|.
name|lno
operator|=
name|cmd
operator|.
name|addr2
operator|.
name|lno
operator|=
name|sp
operator|->
name|lno
expr_stmt|;
name|cmd
operator|.
name|addr1
operator|.
name|cno
operator|=
name|cmd
operator|.
name|addr2
operator|.
name|cno
operator|=
name|sp
operator|->
name|cno
expr_stmt|;
if|if
condition|(
name|flags
condition|)
block|{
switch|switch
condition|(
name|flags
condition|)
block|{
case|case
name|E_F_HASH
case|:
name|cmd
operator|.
name|cmd
operator|=
operator|&
name|cmds
index|[
name|C_HASH
index|]
expr_stmt|;
name|ex_number
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
operator|&
name|cmd
argument_list|)
expr_stmt|;
break|break;
case|case
name|E_F_LIST
case|:
name|cmd
operator|.
name|cmd
operator|=
operator|&
name|cmds
index|[
name|C_LIST
index|]
expr_stmt|;
name|ex_list
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
operator|&
name|cmd
argument_list|)
expr_stmt|;
break|break;
case|case
name|E_F_PRINT
case|:
name|cmd
operator|.
name|cmd
operator|=
operator|&
name|cmds
index|[
name|C_PRINT
index|]
expr_stmt|;
name|ex_pr
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
operator|&
name|cmd
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * linespec --  *	Parse a line specifier for ex commands.  *  * XXX  *	Currently ignores any character quoting.  Not sure that's right.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|linespec
parameter_list|(
name|sp
parameter_list|,
name|ep
parameter_list|,
name|cmd
parameter_list|,
name|cp
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
name|EXF
modifier|*
name|ep
decl_stmt|;
name|char
modifier|*
name|cmd
decl_stmt|;
name|EXCMDARG
modifier|*
name|cp
decl_stmt|;
block|{
name|MARK
name|cur
decl_stmt|,
name|savecursor
decl_stmt|,
name|sm
decl_stmt|,
modifier|*
name|mp
decl_stmt|;
name|long
name|num
decl_stmt|,
name|total
decl_stmt|;
name|int
name|savecursor_set
decl_stmt|;
name|char
modifier|*
name|endp
decl_stmt|;
comment|/* Percent character is all lines in the file. */
if|if
condition|(
operator|*
name|cmd
operator|==
literal|'%'
condition|)
block|{
name|cp
operator|->
name|addr1
operator|.
name|lno
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|file_lline
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
operator|&
name|cp
operator|->
name|addr2
operator|.
name|lno
argument_list|)
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* If an empty file, then the first line is 0, not 1. */
if|if
condition|(
name|cp
operator|->
name|addr2
operator|.
name|lno
operator|==
literal|0
condition|)
name|cp
operator|->
name|addr1
operator|.
name|lno
operator|=
literal|0
expr_stmt|;
name|cp
operator|->
name|addr1
operator|.
name|cno
operator|=
name|cp
operator|->
name|addr2
operator|.
name|cno
operator|=
literal|0
expr_stmt|;
name|cp
operator|->
name|addrcnt
operator|=
literal|2
expr_stmt|;
return|return
operator|(
operator|++
name|cmd
operator|)
return|;
block|}
comment|/* Parse comma or semi-colon delimited line specs. */
name|savecursor_set
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|cp
operator|->
name|addrcnt
operator|=
literal|0
init|;
condition|;
control|)
block|{
switch|switch
condition|(
operator|*
name|cmd
condition|)
block|{
case|case
literal|';'
case|:
comment|/* Semi-colon delimiter. */
comment|/* 			 * Comma delimiters delimit; semi-colon delimiters 			 * change the current address for the 2nd address 			 * to be the first address.  Trailing or multiple 			 * delimiters are discarded. 			 */
if|if
condition|(
name|cp
operator|->
name|addrcnt
operator|==
literal|0
condition|)
goto|goto
name|done
goto|;
if|if
condition|(
operator|!
name|savecursor_set
condition|)
block|{
name|savecursor
operator|.
name|lno
operator|=
name|sp
operator|->
name|lno
expr_stmt|;
name|savecursor
operator|.
name|cno
operator|=
name|sp
operator|->
name|cno
expr_stmt|;
name|sp
operator|->
name|lno
operator|=
name|cp
operator|->
name|addr1
operator|.
name|lno
expr_stmt|;
name|sp
operator|->
name|cno
operator|=
name|cp
operator|->
name|addr1
operator|.
name|cno
expr_stmt|;
block|}
name|savecursor_set
operator|=
literal|1
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
literal|','
case|:
comment|/* Comma delimiter. */
operator|++
name|cmd
expr_stmt|;
break|break;
case|case
literal|'$'
case|:
comment|/* Last line. */
if|if
condition|(
name|file_lline
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
operator|&
name|cur
operator|.
name|lno
argument_list|)
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|cur
operator|.
name|cno
operator|=
literal|0
expr_stmt|;
operator|++
name|cmd
expr_stmt|;
break|break;
comment|/* Absolute line number. */
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
name|cur
operator|.
name|lno
operator|=
name|strtol
argument_list|(
name|cmd
argument_list|,
operator|&
name|endp
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|cur
operator|.
name|cno
operator|=
literal|0
expr_stmt|;
name|cmd
operator|=
name|endp
expr_stmt|;
break|break;
case|case
literal|'\''
case|:
comment|/* Set mark. */
if|if
condition|(
name|cmd
index|[
literal|1
index|]
operator|==
literal|'\0'
condition|)
block|{
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_ERR
argument_list|,
literal|"No mark name; use 'a' to 'z'."
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|mp
operator|=
name|mark_get
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
name|cmd
index|[
literal|1
index|]
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|cur
operator|=
operator|*
name|mp
expr_stmt|;
name|cmd
operator|+=
literal|2
expr_stmt|;
break|break;
case|case
literal|'/'
case|:
comment|/* Search forward. */
name|sm
operator|.
name|lno
operator|=
name|sp
operator|->
name|lno
expr_stmt|;
name|sm
operator|.
name|cno
operator|=
name|sp
operator|->
name|cno
expr_stmt|;
if|if
condition|(
name|f_search
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
operator|&
name|sm
argument_list|,
operator|&
name|sm
argument_list|,
name|cmd
argument_list|,
operator|&
name|endp
argument_list|,
name|SEARCH_MSG
operator||
name|SEARCH_PARSE
argument_list|)
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|cur
operator|.
name|lno
operator|=
name|sp
operator|->
name|lno
operator|=
name|sm
operator|.
name|lno
expr_stmt|;
name|cur
operator|.
name|cno
operator|=
name|sp
operator|->
name|cno
operator|=
name|sm
operator|.
name|cno
expr_stmt|;
name|cmd
operator|=
name|endp
expr_stmt|;
break|break;
case|case
literal|'?'
case|:
comment|/* Search backward. */
name|sm
operator|.
name|lno
operator|=
name|sp
operator|->
name|lno
expr_stmt|;
name|sm
operator|.
name|cno
operator|=
name|sp
operator|->
name|cno
expr_stmt|;
if|if
condition|(
name|b_search
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
operator|&
name|sm
argument_list|,
operator|&
name|sm
argument_list|,
name|cmd
argument_list|,
operator|&
name|endp
argument_list|,
name|SEARCH_MSG
operator||
name|SEARCH_PARSE
argument_list|)
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|cur
operator|.
name|lno
operator|=
name|sp
operator|->
name|lno
operator|=
name|sm
operator|.
name|lno
expr_stmt|;
name|cur
operator|.
name|cno
operator|=
name|sp
operator|->
name|cno
operator|=
name|sm
operator|.
name|cno
expr_stmt|;
name|cmd
operator|=
name|endp
expr_stmt|;
break|break;
case|case
literal|'.'
case|:
comment|/* Current position. */
operator|++
name|cmd
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
literal|'+'
case|:
comment|/* Increment. */
case|case
literal|'-'
case|:
comment|/* Decrement. */
comment|/* If an empty file, then '.' is 0, not 1. */
if|if
condition|(
name|sp
operator|->
name|lno
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|file_lline
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
operator|&
name|cur
operator|.
name|lno
argument_list|)
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
if|if
condition|(
name|cur
operator|.
name|lno
operator|!=
literal|0
condition|)
name|cur
operator|.
name|lno
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|cur
operator|.
name|lno
operator|=
name|sp
operator|->
name|lno
expr_stmt|;
name|cur
operator|.
name|cno
operator|=
name|sp
operator|->
name|cno
expr_stmt|;
break|break;
default|default:
goto|goto
name|done
goto|;
block|}
comment|/* 		 * Evaluate any offset.  Offsets are +/- any number, or, 		 * any number of +/- signs, or any combination thereof. 		 */
for|for
control|(
name|total
operator|=
literal|0
init|;
operator|*
name|cmd
operator|==
literal|'-'
operator|||
operator|*
name|cmd
operator|==
literal|'+'
condition|;
name|total
operator|+=
name|num
control|)
block|{
name|num
operator|=
operator|*
name|cmd
operator|==
literal|'-'
condition|?
operator|-
literal|1
else|:
literal|1
expr_stmt|;
if|if
condition|(
name|isdigit
argument_list|(
operator|*
operator|++
name|cmd
argument_list|)
condition|)
block|{
name|num
operator|*=
name|strtol
argument_list|(
name|cmd
argument_list|,
operator|&
name|endp
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|cmd
operator|=
name|endp
expr_stmt|;
block|}
block|}
if|if
condition|(
name|total
operator|<
literal|0
operator|&&
operator|-
name|total
operator|>
name|cur
operator|.
name|lno
condition|)
block|{
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_ERR
argument_list|,
literal|"Reference to a line number less than 0."
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|cur
operator|.
name|lno
operator|+=
name|total
expr_stmt|;
comment|/* Extra addresses are discarded, starting with the first. */
switch|switch
condition|(
name|cp
operator|->
name|addrcnt
condition|)
block|{
case|case
literal|0
case|:
name|cp
operator|->
name|addr1
operator|=
name|cur
expr_stmt|;
name|cp
operator|->
name|addrcnt
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|cp
operator|->
name|addr2
operator|=
name|cur
expr_stmt|;
name|cp
operator|->
name|addrcnt
operator|=
literal|2
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|cp
operator|->
name|addr1
operator|=
name|cp
operator|->
name|addr2
expr_stmt|;
name|cp
operator|->
name|addr2
operator|=
name|cur
expr_stmt|;
break|break;
block|}
block|}
comment|/* 	 * XXX 	 * This is probably not right for treatment of savecursor -- figure 	 * out what the historical ex did for ";,;,;5p" or similar stupidity. 	 */
name|done
label|:
if|if
condition|(
name|savecursor_set
condition|)
block|{
name|sp
operator|->
name|lno
operator|=
name|savecursor
operator|.
name|lno
expr_stmt|;
name|sp
operator|->
name|cno
operator|=
name|savecursor
operator|.
name|cno
expr_stmt|;
block|}
return|return
operator|(
name|cmd
operator|)
return|;
block|}
end_function

end_unit

