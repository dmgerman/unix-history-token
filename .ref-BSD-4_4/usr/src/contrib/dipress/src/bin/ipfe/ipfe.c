begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/***  file = ipfe.c  ********************************************/
end_comment

begin_comment
comment|/*** start of specifications ************************************  *  * name = ipfe  * descriptive name = interpress file editor  * filename = ipfe.c  * module type = main  * subsystem name = interpress toolkit  * copyright = (c) 1985, 1986, xerox corporation  * author = mark l. rollins  * date written = 10/oct/85  *  * change activity =  *   07/18/86 r1.05 mlr wrc:	changed so Scale follows, rather than  *				  precedes, Rotate, BindingOffset, XOffset,  *				  and YOffset in output processing  *   06/16/86 r1.04 mlr wrc:	add Scale processing  *   05/19/86 r1.03 mlr wrc:	fixed bug in dsply of Y-offset values  *   04/22/86 r1.02 mlr wrc:	fixed bug in pagerange parsing that gave  *				  error on terminating "]";  *				add vers display  *   03/14/86 r1.01 mlr wrc:	major enhancements  *   10/10/85 r1.00 mlr wrc:	original date  *  *   release = r1.05  *   date = 18/jul/86  *  * function = provide the following skeleton- and page-level functions  *		for editing interpress masters:  *		.  concatenate masters  *		.  merge pages from multiple masters into one master  *		.  overlay selected pages as a single page (may be  *			combined with merge function)  *		.  chapterize a master into multiple masters  *		.  satisfy sequenceInsertFile& sequenceInsertMaster  *			references  *		.  resolve alias and binding offset printing instructions  *		.  return information about the properties of a set of  *			masters  *  * function description =  *  *	Usage:  ipfe [ options ] file [ pagerange] ... [ file [pagerange] ...]  *	Options: [-l logfile] [-dDiLqrRsS] [-a alias:actual [-a alias:actual]  *		 ...] [-b offset:unit] [-c count:unit] [-o outfile]  *		 [-p level:propfile] [-S factor] [-X offset:unit]  *		 [-Y offset:unit]  *  *		 -a alias:actual  *				(alias). If the -s option is specified,  *				replace any SIF matching the string "alias"  *				with the string "actual" before attempting  *				to satisfy the SIF. If "actual" cannot be  *				opened or there is some error, the SIF  *				"alias" is preserved, unless the -r option  *				is also specified.  *		 -b offset:unit	(binding offset). Shift the image offset units  *				in the x-direction, where unit may be: none  *				(default centimeters), c (centimeters), i  *				(inches), p (points), P (Picas). If the -L  *				(Landscape) switch is set, the image offset  *				is in the y-direction.  *		 -c count:unit	(chapterize) every count units, where unit may  *				be p (pages), k (kilobytes), or m (megabytes).  *		 -d		(duplex). For resolving binding offset.  *		 -D		(Debug). If the -p option is specified, also  *				write to the properties file the offsets of  *				each skeleton-level token encountered.  *		 -i		(insert SIF for overlay). Insert (create) a  *				SIF for any unresolvable overlays.  *		 -l logfile	(log). Keep a running log.  *		 -L		(Landscape). Rotate every page 90 degrees  *				counterclockwise and preserve the upper left  *				corner. Intended for printing text in  *				landscape orientation.  *		 -o outfile	(output). Where the output goes. If there is  *				no -o and there is a -p, only the properties  *				are written, else if there is no -o  *				"infile.ip" is used if it doesn't already  *				exist, else "infileN.ip" is used, where N  *				is the lowest ordinal number such that  *				"infileN.ip" does not already exist.  *		 -p level:propfile  *				(properties). Where the properties are  *				written. Increasing levels provide increasing  *				information details.  *		 -q		(quiet). Don't write info& error msgs (to  *				STDERR).  *		 -r		(remove SIFS). If -s is also specified, it  *				takes precedence and a SIF reference is  *				removed only if it is unresolved or there is  *				some other error.  *		 -R		(Rotate). Rotate every page 90 degrees  *				clockwise and preserve the center point.  *				Intended for rotating an image created for  *				a "landscape printer" to print in portrait  *				orientation.  *		 -s		(satisfy SIFS). Replace any SIF references  *				tokens found in the referenced file. If the  *				referenced file cannot be opened, the SIF  *				reference is preserved unless -r is also  *				specified.  *		 -S factor	(scale). Scale the image by factor.  *		 -X offset:unit	(X-imageShift). Shift the image offset units  *				in the x-direction, where unit may be: none  *				(default centimeters), c (centimeters), i  *				(inches), p (points), P (Picas). The shift  *				is independent of the -L and -R switches  *				(i.e., the x-direction is the same as the  *				unrotated image).  *		 -Y offset:unit	(Y-imageShift). Shift the image offset units  *				in the y-direction, where unit may be: none  *				(default centimeters), c (centimeters), i  *				(inches), p (points), P (Picas). The shift  *				is independent of the -L and -R switches  *				(i.e., the y-direction is the same as the  *				unrotated image).  *		 infile [pagerange]  *				See the manual page for syntax details.  *		  Example:  *		   [1,4-6,9[pic1],10-11,12[pic2:2(2P,4P)][pic3(-4P,-2P)],15-]  *				include page 1.  *				skip pages 2-3.  *				include pages 4-6.  *				skip pages 7-8.  *				include page 9, overlaying it with pic1.  *				include pages 10-11.  *				include pages 12, overlaying it with page 2 of  *				  pic2 at an offset of 2 Picas to the right  *				  and 4 Picas up, and pic3 at an offset of  *				  4 Picas to the left and 2 Picas down.  *				skip pages 13-14.  *				include pages 15 thru the end of the master.  *  * linkage =  *   entry = exec ipfe  *   input = see cmd line options above  *   output = interpress master(s), STDERR, log file, property file  *   exit = exit(exit_status)  *  * publics =  *  * dependencies =  *   src = iptokens.h, ipnames.h  *   obj =  *   lnk =  *  * environment =  *   runtime = vax/masscomp unix/4.23bsd  *   development = vax unix/4.23bsd  *   processor = cc  *   code = unix c mnemonics& linkages  *  *** end of specifications **************************************/
end_comment

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|vax11c
end_ifdef

begin_include
include|#
directive|include
include|stdio
end_include

begin_include
include|#
directive|include
include|setjmp
end_include

begin_include
include|#
directive|include
include|ctype
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_comment
comment|/*** # include<sys/time.h> # include<sys/resource.h> ***/
end_comment

begin_include
include|#
directive|include
file|<setjmp.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"iptokens.h"
end_include

begin_include
include|#
directive|include
file|"ipnames.h"
end_include

begin_define
define|#
directive|define
name|IPFE_VERS
value|"1.05"
end_define

begin_define
define|#
directive|define
name|IPFE_DATE
value|"18 JUL 86"
end_define

begin_define
define|#
directive|define
name|FALSE
value|0
end_define

begin_define
define|#
directive|define
name|TRUE
value|1
end_define

begin_define
define|#
directive|define
name|FLAG_OFF
value|0
end_define

begin_define
define|#
directive|define
name|FLAG_ON
value|1
end_define

begin_define
define|#
directive|define
name|CR
value|13
end_define

begin_define
define|#
directive|define
name|BEL
value|07
end_define

begin_define
define|#
directive|define
name|BS
value|08
end_define

begin_define
define|#
directive|define
name|TAB
value|09
end_define

begin_define
define|#
directive|define
name|LF
value|10
end_define

begin_define
define|#
directive|define
name|FF
value|12
end_define

begin_define
define|#
directive|define
name|TOF
value|12
end_define

begin_define
define|#
directive|define
name|SPC
value|32
end_define

begin_define
define|#
directive|define
name|ESC
value|27
end_define

begin_define
define|#
directive|define
name|DEL
value|127
end_define

begin_escape
end_escape

begin_define
define|#
directive|define
name|STDIN
value|stdin
end_define

begin_define
define|#
directive|define
name|STDOUT
value|stdout
end_define

begin_define
define|#
directive|define
name|STDERR
value|stderr
end_define

begin_define
define|#
directive|define
name|STDIN_DEV
value|0
end_define

begin_define
define|#
directive|define
name|STDOUT_DEV
value|1
end_define

begin_define
define|#
directive|define
name|STDERR_DEV
value|2
end_define

begin_define
define|#
directive|define
name|DEF_LOGFILENAME
value|"ipfe.log"
end_define

begin_define
define|#
directive|define
name|DEF_OUTFILENAME
value|"ipfe.ip"
end_define

begin_define
define|#
directive|define
name|DEF_PROPFILENAME
value|"ipfe.prop"
end_define

begin_define
define|#
directive|define
name|DEF_WORKFILENAME
value|"ipfe.wrk"
end_define

begin_define
define|#
directive|define
name|BUFSIZE
value|2048
end_define

begin_define
define|#
directive|define
name|OP_Mask
value|0xe0
end_define

begin_define
define|#
directive|define
name|OK
value|0
end_define

begin_define
define|#
directive|define
name|ERROR
value|(-1)
end_define

begin_define
define|#
directive|define
name|DONT_FORMAT
value|0
end_define

begin_define
define|#
directive|define
name|FORMAT
value|1
end_define

begin_define
define|#
directive|define
name|MX_NO_INFILES
value|64
end_define

begin_define
define|#
directive|define
name|MX_NO_OUTFILES
value|64
end_define

begin_define
define|#
directive|define
name|MX_NO_OVLY_FILES
value|64
end_define

begin_define
define|#
directive|define
name|IP_HDR_CHKLEN
value|17
end_define

begin_define
define|#
directive|define
name|IP_VERS_OFFSET
value|17
end_define

begin_define
define|#
directive|define
name|IP_HDR_MASTERLEN
value|21
end_define

begin_define
define|#
directive|define
name|MX_HDR_BUFLEN
value|255
end_define

begin_define
define|#
directive|define
name|MX_NO_ALIASES
value|128
end_define

begin_define
define|#
directive|define
name|MX_NO_MPG_ENTRIES
value|128
end_define

begin_define
define|#
directive|define
name|MX_BLOCK_DEPTH
value|8
end_define

begin_define
define|#
directive|define
name|MX_BODY_DEPTH
value|8
end_define

begin_define
define|#
directive|define
name|MX_BOP_DEPTH
value|16
end_define

begin_comment
comment|/* max # of nested body_operators */
end_comment

begin_define
define|#
directive|define
name|MX_SIF_DEPTH
value|8
end_define

begin_comment
comment|/* max sif nesting depth */
end_comment

begin_define
define|#
directive|define
name|INDENT_INCR
value|3
end_define

begin_comment
comment|/* # cols to incr indent each nesting depth */
end_comment

begin_comment
comment|/*  *  defines for ipfe fn types  */
end_comment

begin_define
define|#
directive|define
name|CONCAT
value|0
end_define

begin_define
define|#
directive|define
name|CHAPTERIZE
value|1
end_define

begin_define
define|#
directive|define
name|SATISFY_SIFS
value|2
end_define

begin_define
define|#
directive|define
name|REMOVE_SIFS
value|3
end_define

begin_define
define|#
directive|define
name|PROPERTIES
value|4
end_define

begin_define
define|#
directive|define
name|INSERT_OVLY
value|5
end_define

begin_define
define|#
directive|define
name|DEBUG
value|6
end_define

begin_define
define|#
directive|define
name|PROC_LOG
value|7
end_define

begin_define
define|#
directive|define
name|FORCE_STDOUT
value|8
end_define

begin_define
define|#
directive|define
name|BINDING_OFFSET
value|9
end_define

begin_define
define|#
directive|define
name|DUPLEX
value|10
end_define

begin_define
define|#
directive|define
name|QUIET
value|11
end_define

begin_define
define|#
directive|define
name|LANDSCAPE
value|12
end_define

begin_define
define|#
directive|define
name|ROTATE
value|13
end_define

begin_define
define|#
directive|define
name|SCALE
value|14
end_define

begin_define
define|#
directive|define
name|X_OFFSET
value|15
end_define

begin_define
define|#
directive|define
name|Y_OFFSET
value|16
end_define

begin_define
define|#
directive|define
name|NUM_FNS
value|17
end_define

begin_comment
comment|/*  *  defines for chapterization type  */
end_comment

begin_define
define|#
directive|define
name|CH_PAGES
value|1
end_define

begin_define
define|#
directive|define
name|CH_KBYTES
value|2
end_define

begin_define
define|#
directive|define
name|CH_MBYTES
value|3
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|lcv2
end_ifdef

begin_comment
comment|/* if Lattice C vers 2.15 or earlier */
end_comment

begin_define
define|#
directive|define
name|void
value|int
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  *  lattice C defines for fopen file types (binary& text)  */
end_comment

begin_define
define|#
directive|define
name|BINARY_FILE
value|0x8000
end_define

begin_define
define|#
directive|define
name|TEXT_FILE
value|0
end_define

begin_decl_stmt
name|FILE
modifier|*
name|input
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE
modifier|*
name|output
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE
modifier|*
name|workfile
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* work file for testing input file opens& storing 			   hdr/preamble for chapterizing */
end_comment

begin_decl_stmt
name|FILE
modifier|*
name|ovly_file
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE
modifier|*
name|sif_file
index|[
name|MX_SIF_DEPTH
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE
modifier|*
name|siffile
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE
modifier|*
name|logfile
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE
modifier|*
name|propfile
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|jmp_buf
name|next_file
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|errno
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|_fmode
init|=
name|TEXT_FILE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* lattice C file_mode */
end_comment

begin_decl_stmt
name|int
name|abort_flag
decl_stmt|,
name|debug_flag
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|terrno
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|exit_status
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|long
name|pos
decl_stmt|,
name|in_offset
decl_stmt|,
name|out_offset
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|long
name|out_beg_offset
index|[
name|MX_BLOCK_DEPTH
index|]
decl_stmt|,
name|out_end_offset
index|[
name|MX_BLOCK_DEPTH
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|long
name|chap_val
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|long
name|boff_num
decl_stmt|,
name|boff_den
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* binding offset numerator, denominator */
end_comment

begin_decl_stmt
name|long
name|xoff_num
decl_stmt|,
name|xoff_den
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* xOffset numerator, denominator */
end_comment

begin_decl_stmt
name|long
name|yoff_num
decl_stmt|,
name|yoff_den
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* yOffset numerator, denominator */
end_comment

begin_decl_stmt
name|long
name|rxoff_num
decl_stmt|,
name|rxoff_den
decl_stmt|,
comment|/* rotation xOffset numerator, denominator */
name|ryoff_num
decl_stmt|,
name|ryoff_den
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*          yOffset numerator, denominator */
end_comment

begin_decl_stmt
name|long
name|scale_num
decl_stmt|,
name|scale_den
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* scale factor numerator, denominator */
end_comment

begin_decl_stmt
name|long
name|blk_num_bytes
index|[
name|MX_BLOCK_DEPTH
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|long
name|pg_num_bytes
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|num_infiles
decl_stmt|,
name|out_filnum
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|input_indx
decl_stmt|,
name|output_indx
decl_stmt|,
name|sif_indx
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|prop_level
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|cur_indent
decl_stmt|,
name|off_indent
decl_stmt|,
name|cur_col
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|ovly_flag
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|proc_flag
index|[
name|NUM_FNS
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|chap_type
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|ipwrite_flag
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|rot_deg
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* rotation degrees */
end_comment

begin_decl_stmt
name|int
name|num_aliases
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|alias_indx
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|begBody_flag
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|preamble_expected
decl_stmt|,
name|endpreamble_expected
decl_stmt|,
name|frstpg_flag
decl_stmt|,
name|bop_preamble_expected
index|[
name|MX_BOP_DEPTH
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  *  MERGE& OVERLAY ARRAYS  *    There are 2 second order arrays, one for merge pages and one for  *    overlay files. The 1st order of both is indexed by input_indx, and  *    the 2nd order by merge_indx. For overlay files, there are 3  *    additional arrays, one for an overlay pagenum, one for page offset  *    numerators, and one for page offset denominators. These 3 arrays  *    are indexed by ovly_indx (the 1st order indexing for the numerator  *    and denominator arrays is 0 for the x-offset and 1 for the y-offset).  *  *    Each 2nd order vector of the merge_pg[][] array is initialized to  *    (-1),0,0,... which indicates to include all pages, and each vector  *    of the ovly_pg[][] array is initialized to (-1),(-1),(-1),... which  *    indicates no overlay files.  *    As IPFE scans the command line, an entry is put into the merge_pg[][]  *    array for each pageNum specified in a pagerange for an infile (the  *    value put into the entry is pageNum). If there is an overlay file  *    specified for pageNum, the (-1) in the ovly_pg[][merge_indx] entry  *    is replaced with the current value of ovly_indx and ovly_indx is  *    incremented. If there is another overlay file specified for pageNum,  *    the value pageNum is repeated in the next merge_pg[][] entry and the  *    incremented ovly_indx is placed in the next ovly_pg[][] entry.  *      Example:  *        ipfe infile "[2,4-6,9[ovly1],12[ovly2][ovly3],15-]"  *      will yield the following merge_pg[input_indx][]&   *      ovly_pg[input_indx][] vectors:  *                    0    1    2    3    4    5    6    7    8    9   10  *                  ----|----|----|----|----|----|----|----|----|----|----  *        merge_pg:   2 ,  4 ,(-1),  6 ,  9 , 12 , 12 , 15 ,(-1),  0 ,  0 ,...  *        ovly_pg:  (-1),(-1),(-1),(-1),  0 ,  1 ,  2 ,(-1),(-1),(-1),(-1),...  *  *    The algorithm used to decode the merge_pg vector for each infile is  *    as follows:  *      Initialize merge_indx to 0;  *      Loop:  *      Current_entry = merge_pg[input_indx][merge_indx];  *        If Current_entry = 0, we're all done with this infile;  *	  Else if Current_entry = (-1), look at next merge_indx entry;  *          Next_entry = merge_pg[input_indx][merge_indx+1];  *            If Next_entry = 0, include all pages to the end of infile;  *	      Else include all pages until the value of Next_entry is  *              reached in infile; when it is, increment merge_indx (making  *              Current_entry = Next_entry, and goto Loop;  *        Else exclude all pages until Current_entry is reached in infile  *          (it may already be reached); when it is, include that page and  *	      check the ovly_pg[][] entry;  *          Ovly_entry = ovly_pg[input_indx][merge_indx];  *            If Ovly_entry != (-1) do overlay processing;  *          Increment merge_indx, and goto Loop;  */
end_comment

begin_decl_stmt
name|int
name|merge_indx
decl_stmt|,
name|merge_pg
index|[
name|MX_NO_INFILES
index|]
index|[
name|MX_NO_MPG_ENTRIES
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|ovly_indx
decl_stmt|,
name|ovly_pg
index|[
name|MX_NO_INFILES
index|]
index|[
name|MX_NO_MPG_ENTRIES
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|ovly_pgnum
index|[
name|MX_NO_OVLY_FILES
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|long
name|ovly_num
index|[
literal|2
index|]
index|[
name|MX_NO_OVLY_FILES
index|]
decl_stmt|,
name|ovly_den
index|[
literal|2
index|]
index|[
name|MX_NO_OVLY_FILES
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|block_indx
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|block_flag
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|bproc_indx
decl_stmt|,
name|bop_indx
decl_stmt|,
name|bop_iindx
index|[
name|MX_BOP_DEPTH
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|bproc_flag
decl_stmt|,
name|bop_flag
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|num_blocks
decl_stmt|,
name|num_pages
decl_stmt|,
name|num_sifs
decl_stmt|,
name|tnum_blocks
decl_stmt|,
name|tnum_pages
decl_stmt|,
name|tnum_sifs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|out_numpages
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|infile_flag
index|[
name|MX_NO_INFILES
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|hdr_len
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|hdr_buf
index|[
name|MX_HDR_BUFLEN
operator|+
literal|1
index|]
decl_stmt|,
name|hdr_workbuf
index|[
name|MX_HDR_BUFLEN
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|input_name
index|[
name|MX_NO_INFILES
index|]
index|[
literal|128
index|]
decl_stmt|,
name|input_fnm
index|[
literal|128
index|]
decl_stmt|,
name|input_ext
index|[
literal|128
index|]
decl_stmt|,
name|output_name
index|[
literal|128
index|]
decl_stmt|,
name|output_fnm
index|[
literal|128
index|]
decl_stmt|,
name|output_ext
index|[
literal|128
index|]
decl_stmt|,
name|work_fname
index|[
literal|128
index|]
decl_stmt|,
name|sif_name
index|[
name|MX_SIF_DEPTH
index|]
index|[
literal|128
index|]
decl_stmt|,
name|prop_fname
index|[
literal|128
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|ovly_fname
index|[
name|MX_NO_OVLY_FILES
index|]
index|[
literal|128
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|alias_ref
index|[
name|MX_NO_ALIASES
index|]
index|[
literal|128
index|]
decl_stmt|,
name|alias_act
index|[
name|MX_NO_ALIASES
index|]
index|[
literal|128
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|inputname
decl_stmt|,
modifier|*
name|outputname
decl_stmt|,
modifier|*
name|sifname
decl_stmt|,
modifier|*
name|propfname
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|logfilename
init|=
literal|"ipfe.log"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|itostr
argument_list|()
decl_stmt|,
name|lcase
argument_list|()
decl_stmt|,
modifier|*
name|op_name
argument_list|()
decl_stmt|,
modifier|*
name|strcat
argument_list|()
decl_stmt|,
modifier|*
name|strcpy
argument_list|()
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/****************************************************************  *  *	main(argc, argv):	ipfe mainline:  *	main:			  interpress file editor  *  ****************************************************************/
end_comment

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
name|argv
index|[]
decl_stmt|;
block|{
name|char
name|msg
index|[
literal|128
index|]
decl_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|msg
argument_list|,
literal|"\nIPFE Version %s, %s -- Interpress File Editor\n"
argument_list|,
name|IPFE_VERS
argument_list|,
name|IPFE_DATE
argument_list|)
expr_stmt|;
name|pip_error
argument_list|(
name|msg
argument_list|)
expr_stmt|;
name|pip_error
argument_list|(
literal|"Copyright (c) 1985,1986 Xerox Corporation\n\n"
argument_list|)
expr_stmt|;
name|init_ipfe
argument_list|()
expr_stmt|;
name|get_cmd_args
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
expr_stmt|;
name|init1_ipfe
argument_list|()
expr_stmt|;
comment|/* initialization after getting cmd args */
for|for
control|(
name|input_indx
operator|=
literal|0
init|;
name|input_indx
operator|<
name|num_infiles
condition|;
name|input_indx
operator|++
control|)
block|{
name|init_proc_file
argument_list|()
expr_stmt|;
name|inputname
operator|=
name|input_name
index|[
name|input_indx
index|]
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|msg
argument_list|,
literal|"-- File:  %s--\n"
argument_list|,
name|inputname
argument_list|)
expr_stmt|;
name|pip_error
argument_list|(
name|msg
argument_list|)
expr_stmt|;
name|pip_prop
argument_list|(
name|msg
argument_list|)
expr_stmt|;
name|_fmode
operator|=
name|BINARY_FILE
expr_stmt|;
name|input
operator|=
name|fopen
argument_list|(
name|inputname
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|input
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|msg
argument_list|,
literal|"\nError opening input file: %s\n"
argument_list|,
name|inputname
argument_list|)
expr_stmt|;
name|pip_error
argument_list|(
name|msg
argument_list|)
expr_stmt|;
name|pip_prop
argument_list|(
name|msg
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|proc_file
argument_list|()
expr_stmt|;
comment|/* do the real work */
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|input
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|abort_flag
operator|==
name|FLAG_OFF
operator|)
operator|&&
operator|(
name|proc_flag
index|[
name|CONCAT
index|]
operator|==
name|FLAG_ON
operator|)
condition|)
block|{
name|ipwrite_flag
operator|=
name|FLAG_ON
expr_stmt|;
comment|/* in case it was turned off by 					   last file processed */
name|put_op
argument_list|(
name|OP_endBlock
argument_list|)
expr_stmt|;
block|}
name|cleanup
argument_list|()
expr_stmt|;
name|exit
argument_list|(
name|exit_status
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/****************************************************************  *  *	cleanup:		housecleaning  *  ****************************************************************/
end_comment

begin_macro
name|cleanup
argument_list|()
end_macro

begin_block
block|{
name|char
name|msg
index|[
literal|128
index|]
decl_stmt|;
if|if
condition|(
name|proc_flag
index|[
name|CONCAT
index|]
operator|==
name|FLAG_ON
condition|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|msg
argument_list|,
literal|"\n--Total Number of Blocks:%4d\n"
argument_list|,
name|tnum_blocks
argument_list|)
expr_stmt|;
name|pip_prop
argument_list|(
name|msg
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|msg
argument_list|,
literal|"--Total Number of Pages :%4d\n"
argument_list|,
name|tnum_pages
argument_list|)
expr_stmt|;
name|pip_prop
argument_list|(
name|msg
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|msg
argument_list|,
literal|"--Total Number of SIFs  :%4d\n"
argument_list|,
name|tnum_sifs
argument_list|)
expr_stmt|;
name|pip_prop
argument_list|(
name|msg
argument_list|)
expr_stmt|;
block|}
name|mputc_prop
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|msg
argument_list|,
literal|"\n-- Total Number of Input Pages :%4d\n"
argument_list|,
name|tnum_pages
argument_list|)
expr_stmt|;
name|pip_error
argument_list|(
name|msg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|output
operator|!=
name|NULL
operator|)
operator|||
operator|(
name|out_numpages
operator|>
literal|0
operator|)
condition|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|msg
argument_list|,
literal|"-- Total Number of Output Pages:%4d\n"
argument_list|,
name|out_numpages
argument_list|)
expr_stmt|;
name|pip_error
argument_list|(
name|msg
argument_list|)
expr_stmt|;
block|}
name|pip_error
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|logfile
operator|!=
name|NULL
condition|)
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|logfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|propfile
operator|!=
name|NULL
condition|)
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|propfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|output
operator|!=
name|NULL
condition|)
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|output
argument_list|)
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/****************************************************************  *  *	int count_int_bytes(val):  *	int count_int_bytes:	return the number of bytes in the  *				specified int val  *  ****************************************************************/
end_comment

begin_function
name|int
name|count_int_bytes
parameter_list|(
name|val
parameter_list|)
name|long
name|val
decl_stmt|;
block|{
name|long
name|mask
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|(
name|val
operator|==
literal|0
operator|)
operator|||
operator|(
name|val
operator|==
operator|(
operator|-
literal|1
operator|)
operator|)
condition|)
name|i
operator|=
literal|1
expr_stmt|;
comment|/* avoid infinite looping */
else|else
block|{
if|if
condition|(
name|val
operator|<
literal|0
condition|)
name|val
operator|=
operator|~
operator|(
name|val
operator|)
expr_stmt|;
comment|/* same # of bytes as one's complement */
name|mask
operator|=
literal|0xff800000
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|4
init|;
operator|(
operator|(
name|val
operator|&
name|mask
operator|)
operator|==
literal|0
operator|)
condition|;
name|i
operator|--
control|)
name|mask
operator|=
name|mask
operator|>>
literal|8
expr_stmt|;
block|}
return|return
operator|(
name|i
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/****************************************************************  *  *	create_SIF(fname):  *	create_SIF:		create a new SIF (for ovly handling)  *  ****************************************************************/
end_comment

begin_macro
name|create_SIF
argument_list|(
argument|fname
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|fname
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|not_created_flag
decl_stmt|;
name|char
name|msg
index|[
literal|128
index|]
decl_stmt|;
name|not_created_flag
operator|=
name|FLAG_OFF
expr_stmt|;
if|if
condition|(
name|proc_flag
index|[
name|INSERT_OVLY
index|]
operator|==
name|FLAG_ON
condition|)
block|{
if|if
condition|(
name|ovly_pgnum
index|[
name|ovly_indx
index|]
operator|<
literal|2
condition|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|msg
argument_list|,
literal|"                  --Creating SIF:  %s\n"
argument_list|,
name|fname
argument_list|)
expr_stmt|;
name|pip_error
argument_list|(
name|msg
argument_list|)
expr_stmt|;
name|put_seq_type_len
argument_list|(
name|sequenceInsertFile
argument_list|,
operator|(
name|long
operator|)
name|strlen
argument_list|(
name|fname
argument_list|)
argument_list|)
expr_stmt|;
name|ip_puts
argument_list|(
name|fname
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|pip_error
argument_list|(
literal|"                  --Cannot create SIF for overlay with pageNum> 1\n"
argument_list|)
expr_stmt|;
name|not_created_flag
operator|=
name|FLAG_ON
expr_stmt|;
block|}
block|}
else|else
block|{
name|pip_error
argument_list|(
literal|"                    -i switch (Insert SIF for overlay) not specified\n"
argument_list|)
expr_stmt|;
name|not_created_flag
operator|=
name|FLAG_ON
expr_stmt|;
block|}
if|if
condition|(
name|not_created_flag
operator|==
name|FLAG_ON
condition|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|msg
argument_list|,
literal|"                  --SIF Not Created for:  %s\n"
argument_list|,
name|fname
argument_list|)
expr_stmt|;
name|pip_error
argument_list|(
name|msg
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/****************************************************************  *  *	get_cmd_args(argc, argv):  *	get_cmd_args:		get cmd_line arguments  *	gca:			label for editing  *  ****************************************************************/
end_comment

begin_macro
name|get_cmd_args
argument_list|(
argument|argc
argument_list|,
argument|argv
argument_list|)
end_macro

begin_decl_stmt
name|int
name|argc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|argv
index|[]
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|long
name|val
decl_stmt|,
name|val1
decl_stmt|,
name|d
decl_stmt|;
name|int
name|arg
decl_stmt|,
name|opt
decl_stmt|,
name|opt_len
decl_stmt|,
name|ch_ctr
decl_stmt|,
name|neg_flag
decl_stmt|,
name|sep_flag
decl_stmt|,
name|retcd
decl_stmt|;
name|int
name|err_flag
init|=
name|FLAG_OFF
decl_stmt|;
name|char
name|ch
decl_stmt|,
name|sep_char
decl_stmt|,
name|msg
index|[
literal|128
index|]
decl_stmt|;
for|for
control|(
name|arg
operator|=
literal|1
init|;
name|arg
operator|<
name|argc
condition|;
name|arg
operator|++
control|)
comment|/* look for cmd_arguments */
block|{
switch|switch
condition|(
name|argv
index|[
name|arg
index|]
index|[
literal|0
index|]
condition|)
block|{
case|case
operator|(
literal|'-'
operator|)
case|:
name|opt_len
operator|=
name|strlen
argument_list|(
name|argv
index|[
name|arg
index|]
argument_list|)
expr_stmt|;
comment|/* because arg can be */
comment|/*   modified below   */
for|for
control|(
name|opt
operator|=
literal|1
init|;
name|opt
operator|<
name|opt_len
condition|;
name|opt
operator|++
control|)
block|{
switch|switch
condition|(
name|argv
index|[
name|arg
index|]
index|[
name|opt
index|]
condition|)
block|{
case|case
operator|(
literal|'-'
operator|)
case|:
name|opt
operator|=
name|opt_len
expr_stmt|;
comment|/* to handle '--' switch */
break|break;
case|case
operator|(
literal|'a'
operator|)
case|:
if|if
condition|(
name|strlen
argument_list|(
operator|&
operator|(
name|argv
index|[
name|arg
index|]
index|[
name|opt
index|]
operator|)
argument_list|)
operator|>
literal|1
condition|)
operator|++
name|opt
expr_stmt|;
else|else
block|{
operator|++
name|arg
expr_stmt|;
name|opt
operator|=
literal|0
expr_stmt|;
name|opt_len
operator|=
name|strlen
argument_list|(
name|argv
index|[
name|arg
index|]
argument_list|)
expr_stmt|;
block|}
name|proc_alias
argument_list|(
operator|&
operator|(
name|argv
index|[
name|arg
index|]
index|[
name|opt
index|]
operator|)
argument_list|)
expr_stmt|;
name|opt
operator|=
name|opt_len
expr_stmt|;
comment|/* to get out of loop */
break|break;
case|case
operator|(
literal|'b'
operator|)
case|:
if|if
condition|(
name|strlen
argument_list|(
operator|&
operator|(
name|argv
index|[
name|arg
index|]
index|[
name|opt
index|]
operator|)
argument_list|)
operator|>
literal|1
condition|)
operator|++
name|opt
expr_stmt|;
else|else
block|{
operator|++
name|arg
expr_stmt|;
name|opt
operator|=
literal|0
expr_stmt|;
name|opt_len
operator|=
name|strlen
argument_list|(
name|argv
index|[
name|arg
index|]
argument_list|)
expr_stmt|;
block|}
comment|/*  *  binding offset:unit  */
name|val
operator|=
name|val1
operator|=
name|d
operator|=
name|ch_ctr
operator|=
literal|0
expr_stmt|;
name|neg_flag
operator|=
name|FLAG_OFF
expr_stmt|;
while|while
condition|(
name|opt
operator|<
name|opt_len
condition|)
block|{
name|ch
operator|=
name|argv
index|[
name|arg
index|]
index|[
name|opt
operator|++
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|ch
operator|==
literal|'-'
operator|)
operator|&&
operator|(
name|ch_ctr
operator|==
literal|0
operator|)
condition|)
name|neg_flag
operator|=
name|FLAG_ON
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|ch
operator|>=
literal|'0'
operator|)
operator|&&
operator|(
name|ch
operator|<=
literal|'9'
operator|)
condition|)
block|{
name|ch
operator|=
name|ch
operator|-
literal|'0'
expr_stmt|;
if|if
condition|(
name|d
operator|==
literal|0
condition|)
name|val
operator|=
operator|(
name|val
operator|*
literal|10
operator|)
operator|+
name|ch
expr_stmt|;
elseif|else
if|if
condition|(
name|d
operator|<=
literal|1000
condition|)
comment|/* prec = 10**(-3) 							    truncated */
block|{
name|val1
operator|=
operator|(
name|val1
operator|*
literal|10
operator|)
operator|+
name|ch
expr_stmt|;
name|d
operator|=
name|d
operator|*
literal|10
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|ch
operator|==
literal|'.'
condition|)
name|d
operator|=
literal|1
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|(
name|ch
operator|==
literal|':'
operator|)
operator|&&
operator|(
name|opt
operator|<
name|opt_len
operator|)
condition|)
name|ch
operator|=
name|argv
index|[
name|arg
index|]
index|[
name|opt
operator|++
index|]
expr_stmt|;
break|break;
comment|/* exit loop */
block|}
operator|++
name|ch_ctr
expr_stmt|;
block|}
comment|/*				end while (opt< opt_len) */
if|if
condition|(
name|d
operator|==
literal|0
condition|)
name|d
operator|=
literal|1
expr_stmt|;
else|else
name|val
operator|=
operator|(
name|val
operator|*
name|d
operator|)
operator|+
name|val1
expr_stmt|;
if|if
condition|(
name|val
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|neg_flag
operator|==
name|FLAG_ON
condition|)
name|val
operator|=
operator|-
operator|(
name|val
operator|)
expr_stmt|;
switch|switch
condition|(
name|ch
condition|)
block|{
case|case
operator|(
literal|'c'
operator|)
case|:
name|d
operator|=
name|d
operator|*
literal|100
expr_stmt|;
break|break;
case|case
operator|(
literal|'i'
operator|)
case|:
name|val
operator|=
name|val
operator|*
literal|254
expr_stmt|;
name|d
operator|=
name|d
operator|*
literal|10000
expr_stmt|;
break|break;
case|case
operator|(
literal|'p'
operator|)
case|:
name|val
operator|=
name|val
operator|*
literal|254
expr_stmt|;
name|d
operator|=
operator|(
operator|(
name|d
operator|*
literal|720000
operator|)
operator|&
literal|0x7fffffff
operator|)
expr_stmt|;
break|break;
case|case
operator|(
literal|'P'
operator|)
case|:
name|val
operator|=
name|val
operator|*
literal|254
expr_stmt|;
name|d
operator|=
operator|(
operator|(
name|d
operator|*
literal|60000
operator|)
operator|&
literal|0x7fffffff
operator|)
expr_stmt|;
break|break;
default|default:
name|d
operator|=
name|d
operator|*
literal|100
expr_stmt|;
comment|/* def=cm */
break|break;
block|}
comment|/*				    end switch (ch) */
if|if
condition|(
name|d
operator|!=
literal|0
condition|)
comment|/* last chk for div 						     by 0 just in case 						     of ovflw */
block|{
name|boff_num
operator|=
name|val
expr_stmt|;
name|boff_den
operator|=
name|d
expr_stmt|;
name|proc_flag
index|[
name|BINDING_OFFSET
index|]
operator|=
name|FLAG_ON
expr_stmt|;
block|}
block|}
else|else
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|msg
argument_list|,
literal|"--ipfe:  No binding offset value specified in (%s)\n"
argument_list|,
name|argv
index|[
name|arg
index|]
argument_list|)
expr_stmt|;
name|pip_error
argument_list|(
name|msg
argument_list|)
expr_stmt|;
name|err_flag
operator|=
name|FLAG_ON
expr_stmt|;
block|}
operator|--
name|opt
expr_stmt|;
comment|/* to parse cur ch at cmd line */
break|break;
case|case
operator|(
literal|'c'
operator|)
case|:
if|if
condition|(
name|strlen
argument_list|(
operator|&
operator|(
name|argv
index|[
name|arg
index|]
index|[
name|opt
index|]
operator|)
argument_list|)
operator|>
literal|1
condition|)
operator|++
name|opt
expr_stmt|;
else|else
block|{
operator|++
name|arg
expr_stmt|;
name|opt
operator|=
literal|0
expr_stmt|;
name|opt_len
operator|=
name|strlen
argument_list|(
name|argv
index|[
name|arg
index|]
argument_list|)
expr_stmt|;
block|}
name|ch
operator|=
name|val
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|opt
operator|<
name|opt_len
condition|)
block|{
name|ch
operator|=
name|argv
index|[
name|arg
index|]
index|[
name|opt
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|ch
operator|>=
literal|'0'
operator|)
operator|&&
operator|(
name|ch
operator|<=
literal|'9'
operator|)
condition|)
block|{
name|ch
operator|=
name|ch
operator|-
literal|'0'
expr_stmt|;
name|val
operator|=
operator|(
name|val
operator|*
literal|10
operator|)
operator|+
name|ch
expr_stmt|;
operator|++
name|opt
expr_stmt|;
block|}
else|else
break|break;
block|}
if|if
condition|(
name|val
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|msg
argument_list|,
literal|"--ipfe:  No length specified for chapterize in %s\n"
argument_list|,
name|argv
index|[
name|arg
index|]
argument_list|)
expr_stmt|;
name|pip_error
argument_list|(
name|msg
argument_list|)
expr_stmt|;
name|err_flag
operator|=
name|FLAG_ON
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|ch
operator|==
literal|':'
operator|)
operator|&&
operator|(
name|opt
operator|<
name|opt_len
operator|)
condition|)
name|ch
operator|=
name|argv
index|[
name|arg
index|]
index|[
operator|++
name|opt
index|]
expr_stmt|;
switch|switch
condition|(
name|ch
condition|)
block|{
case|case
operator|(
literal|'p'
operator|)
case|:
name|proc_flag
index|[
name|CHAPTERIZE
index|]
operator|=
name|FLAG_ON
expr_stmt|;
name|chap_type
operator|=
name|CH_PAGES
expr_stmt|;
name|chap_val
operator|=
name|val
expr_stmt|;
break|break;
case|case
operator|(
literal|'k'
operator|)
case|:
name|proc_flag
index|[
name|CHAPTERIZE
index|]
operator|=
name|FLAG_ON
expr_stmt|;
name|chap_type
operator|=
name|CH_KBYTES
expr_stmt|;
name|chap_val
operator|=
name|val
operator|*
literal|1024
expr_stmt|;
break|break;
case|case
operator|(
literal|'m'
operator|)
case|:
name|proc_flag
index|[
name|CHAPTERIZE
index|]
operator|=
name|FLAG_ON
expr_stmt|;
name|chap_type
operator|=
name|CH_MBYTES
expr_stmt|;
name|chap_val
operator|=
operator|(
operator|(
name|val
operator|*
literal|1048576
operator|)
operator|&
literal|0x7fffffff
operator|)
expr_stmt|;
break|break;
default|default:
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|msg
argument_list|,
literal|"--ipfe:  No unit specified for chapterize in %s\n"
argument_list|,
name|argv
index|[
name|arg
index|]
argument_list|)
expr_stmt|;
name|pip_error
argument_list|(
name|msg
argument_list|)
expr_stmt|;
name|err_flag
operator|=
name|FLAG_ON
expr_stmt|;
operator|--
name|opt
expr_stmt|;
comment|/* parse opt again */
break|break;
block|}
block|}
break|break;
case|case
operator|(
literal|'d'
operator|)
case|:
name|proc_flag
index|[
name|DUPLEX
index|]
operator|=
name|FLAG_ON
expr_stmt|;
break|break;
case|case
operator|(
literal|'D'
operator|)
case|:
name|proc_flag
index|[
name|DEBUG
index|]
operator|=
name|FLAG_ON
expr_stmt|;
break|break;
case|case
operator|(
literal|'i'
operator|)
case|:
name|proc_flag
index|[
name|INSERT_OVLY
index|]
operator|=
name|FLAG_ON
expr_stmt|;
break|break;
case|case
operator|(
literal|'l'
operator|)
case|:
name|proc_flag
index|[
name|PROC_LOG
index|]
operator|=
name|FLAG_ON
expr_stmt|;
if|if
condition|(
name|strlen
argument_list|(
operator|&
operator|(
name|argv
index|[
name|arg
index|]
index|[
name|opt
index|]
operator|)
argument_list|)
operator|>
literal|1
condition|)
operator|++
name|opt
expr_stmt|;
else|else
block|{
operator|++
name|arg
expr_stmt|;
name|opt
operator|=
literal|0
expr_stmt|;
name|opt_len
operator|=
name|strlen
argument_list|(
name|argv
index|[
name|arg
index|]
argument_list|)
expr_stmt|;
block|}
name|ch
operator|=
name|argv
index|[
name|arg
index|]
index|[
name|opt
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|ch
operator|!=
literal|':'
operator|)
operator|&&
operator|(
name|ch
operator|!=
literal|'-'
operator|)
condition|)
block|{
name|logfilename
operator|=
operator|&
operator|(
name|argv
index|[
name|arg
index|]
index|[
name|opt
index|]
operator|)
expr_stmt|;
name|opt
operator|=
name|opt_len
expr_stmt|;
comment|/* to get out of lp */
block|}
name|open_logfile
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
expr_stmt|;
break|break;
case|case
operator|(
literal|'L'
operator|)
case|:
name|rot_deg
operator|=
literal|90
expr_stmt|;
name|rxoff_num
operator|=
name|rxoff_den
operator|=
literal|0
expr_stmt|;
name|ryoff_num
operator|=
operator|-
operator|(
literal|2794
operator|)
expr_stmt|;
name|ryoff_den
operator|=
literal|10000
expr_stmt|;
name|proc_flag
index|[
name|LANDSCAPE
index|]
operator|=
name|FLAG_ON
expr_stmt|;
break|break;
case|case
operator|(
literal|'o'
operator|)
case|:
if|if
condition|(
name|strlen
argument_list|(
operator|&
operator|(
name|argv
index|[
name|arg
index|]
index|[
name|opt
index|]
operator|)
argument_list|)
operator|>
literal|1
condition|)
name|outputname
operator|=
operator|&
operator|(
name|argv
index|[
name|arg
index|]
index|[
name|opt
operator|+
literal|1
index|]
operator|)
expr_stmt|;
else|else
name|outputname
operator|=
name|argv
index|[
operator|++
name|arg
index|]
expr_stmt|;
name|opt
operator|=
name|opt_len
expr_stmt|;
comment|/* to get out of loop */
break|break;
case|case
operator|(
literal|'p'
operator|)
case|:
name|proc_flag
index|[
name|PROPERTIES
index|]
operator|=
name|FLAG_ON
expr_stmt|;
if|if
condition|(
name|strlen
argument_list|(
operator|&
operator|(
name|argv
index|[
name|arg
index|]
index|[
name|opt
index|]
operator|)
argument_list|)
operator|>
literal|1
condition|)
operator|++
name|opt
expr_stmt|;
else|else
block|{
operator|++
name|arg
expr_stmt|;
name|opt
operator|=
literal|0
expr_stmt|;
name|opt_len
operator|=
name|strlen
argument_list|(
name|argv
index|[
name|arg
index|]
argument_list|)
expr_stmt|;
block|}
name|ch
operator|=
name|argv
index|[
name|arg
index|]
index|[
name|opt
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|ch
operator|!=
literal|':'
operator|)
operator|&&
operator|(
name|ch
operator|!=
literal|'-'
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|ch
operator|>=
literal|'0'
operator|)
operator|&&
operator|(
name|ch
operator|<=
literal|'9'
operator|)
condition|)
block|{
name|prop_level
operator|=
name|ch
operator|-
literal|'0'
expr_stmt|;
operator|++
name|opt
expr_stmt|;
if|if
condition|(
name|argv
index|[
name|arg
index|]
index|[
name|opt
index|]
operator|==
literal|':'
condition|)
operator|++
name|opt
expr_stmt|;
if|if
condition|(
name|opt
operator|<
name|opt_len
condition|)
name|propfname
operator|=
operator|&
operator|(
name|argv
index|[
name|arg
index|]
index|[
name|opt
index|]
operator|)
expr_stmt|;
name|opt
operator|=
name|opt_len
expr_stmt|;
comment|/* to exit loop */
block|}
else|else
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|msg
argument_list|,
literal|"--ipfe:  *** warning -- property level not specified in %s\n"
argument_list|,
name|argv
index|[
name|arg
index|]
argument_list|)
expr_stmt|;
name|pip_error
argument_list|(
name|msg
argument_list|)
expr_stmt|;
name|err_flag
operator|=
name|FLAG_ON
expr_stmt|;
name|propfname
operator|=
operator|&
operator|(
name|argv
index|[
name|arg
index|]
index|[
name|opt
index|]
operator|)
expr_stmt|;
name|opt
operator|=
name|opt_len
expr_stmt|;
comment|/* to exit loop */
block|}
block|}
break|break;
case|case
operator|(
literal|'q'
operator|)
case|:
name|proc_flag
index|[
name|QUIET
index|]
operator|=
name|FLAG_ON
expr_stmt|;
break|break;
case|case
operator|(
literal|'r'
operator|)
case|:
name|proc_flag
index|[
name|REMOVE_SIFS
index|]
operator|=
name|FLAG_ON
expr_stmt|;
break|break;
case|case
operator|(
literal|'R'
operator|)
case|:
name|rot_deg
operator|=
operator|-
operator|(
literal|90
operator|)
expr_stmt|;
name|rxoff_num
operator|=
operator|-
operator|(
literal|2477
operator|)
expr_stmt|;
comment|/* xOff = -(9 3/4") */
name|ryoff_num
operator|=
operator|-
operator|(
literal|318
operator|)
expr_stmt|;
comment|/* yOff = -(1 1/4") */
name|rxoff_den
operator|=
name|ryoff_den
operator|=
literal|10000
expr_stmt|;
name|proc_flag
index|[
name|ROTATE
index|]
operator|=
name|FLAG_ON
expr_stmt|;
break|break;
case|case
operator|(
literal|'s'
operator|)
case|:
name|proc_flag
index|[
name|SATISFY_SIFS
index|]
operator|=
name|FLAG_ON
expr_stmt|;
break|break;
case|case
operator|(
literal|'S'
operator|)
case|:
if|if
condition|(
name|strlen
argument_list|(
operator|&
operator|(
name|argv
index|[
name|arg
index|]
index|[
name|opt
index|]
operator|)
argument_list|)
operator|>
literal|1
condition|)
operator|++
name|opt
expr_stmt|;
else|else
block|{
operator|++
name|arg
expr_stmt|;
name|opt
operator|=
literal|0
expr_stmt|;
name|opt_len
operator|=
name|strlen
argument_list|(
name|argv
index|[
name|arg
index|]
argument_list|)
expr_stmt|;
block|}
comment|/*  *  scale  */
name|val
operator|=
name|val1
operator|=
name|d
operator|=
name|ch_ctr
operator|=
literal|0
expr_stmt|;
name|neg_flag
operator|=
name|sep_flag
operator|=
name|FLAG_OFF
expr_stmt|;
while|while
condition|(
name|opt
operator|<
name|opt_len
condition|)
block|{
name|ch
operator|=
name|argv
index|[
name|arg
index|]
index|[
name|opt
operator|++
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|ch
operator|==
literal|'-'
operator|)
operator|&&
operator|(
name|ch_ctr
operator|==
literal|0
operator|)
condition|)
name|neg_flag
operator|=
name|FLAG_ON
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|ch
operator|>=
literal|'0'
operator|)
operator|&&
operator|(
name|ch
operator|<=
literal|'9'
operator|)
condition|)
block|{
name|ch
operator|=
name|ch
operator|-
literal|'0'
expr_stmt|;
if|if
condition|(
name|d
operator|==
literal|0
condition|)
name|val
operator|=
operator|(
name|val
operator|*
literal|10
operator|)
operator|+
name|ch
expr_stmt|;
elseif|else
if|if
condition|(
name|d
operator|<=
literal|1000
condition|)
comment|/* prec = 10**(-3) 							    truncated */
block|{
name|val1
operator|=
operator|(
name|val1
operator|*
literal|10
operator|)
operator|+
name|ch
expr_stmt|;
name|d
operator|=
name|d
operator|*
literal|10
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|ch
operator|==
literal|'.'
operator|)
operator|||
operator|(
name|ch
operator|==
literal|'/'
operator|)
condition|)
block|{
if|if
condition|(
name|sep_flag
operator|==
name|FLAG_OFF
condition|)
block|{
name|d
operator|=
literal|1
expr_stmt|;
name|sep_char
operator|=
name|ch
expr_stmt|;
name|sep_flag
operator|=
name|FLAG_ON
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|msg
argument_list|,
literal|"--ipfe:  Scale factor cannot have BOTH a '.' AND a '/' in (%s)\n"
argument_list|,
name|argv
index|[
name|arg
index|]
argument_list|)
expr_stmt|;
name|pip_error
argument_list|(
name|msg
argument_list|)
expr_stmt|;
name|err_flag
operator|=
name|FLAG_ON
expr_stmt|;
break|break;
comment|/* exit loop */
block|}
block|}
else|else
block|{
if|if
condition|(
operator|(
name|ch
operator|==
literal|':'
operator|)
operator|&&
operator|(
name|opt
operator|<
name|opt_len
operator|)
condition|)
name|ch
operator|=
name|argv
index|[
name|arg
index|]
index|[
name|opt
operator|++
index|]
expr_stmt|;
break|break;
comment|/* exit loop */
block|}
operator|++
name|ch_ctr
expr_stmt|;
block|}
comment|/*				end while (opt< opt_len) */
if|if
condition|(
name|d
operator|==
literal|0
condition|)
name|d
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|sep_char
operator|==
literal|'/'
condition|)
name|d
operator|=
name|val1
expr_stmt|;
else|else
name|val
operator|=
operator|(
name|val
operator|*
name|d
operator|)
operator|+
name|val1
expr_stmt|;
if|if
condition|(
operator|(
name|val
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|err_flag
operator|==
name|FLAG_OFF
operator|)
condition|)
block|{
if|if
condition|(
name|neg_flag
operator|==
name|FLAG_ON
condition|)
name|val
operator|=
operator|-
operator|(
name|val
operator|)
expr_stmt|;
if|if
condition|(
name|d
operator|!=
literal|0
condition|)
comment|/* last chk for div 						     by 0 just in case 						     of ovflw */
block|{
name|scale_num
operator|=
name|val
expr_stmt|;
name|scale_den
operator|=
name|d
expr_stmt|;
name|proc_flag
index|[
name|SCALE
index|]
operator|=
name|FLAG_ON
expr_stmt|;
block|}
block|}
else|else
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|msg
argument_list|,
literal|"--ipfe:  No scale factor value specified in (%s)\n"
argument_list|,
name|argv
index|[
name|arg
index|]
argument_list|)
expr_stmt|;
name|pip_error
argument_list|(
name|msg
argument_list|)
expr_stmt|;
name|err_flag
operator|=
name|FLAG_ON
expr_stmt|;
block|}
operator|--
name|opt
expr_stmt|;
comment|/* to parse cur ch at cmd line */
break|break;
case|case
operator|(
literal|'X'
operator|)
case|:
if|if
condition|(
name|strlen
argument_list|(
operator|&
operator|(
name|argv
index|[
name|arg
index|]
index|[
name|opt
index|]
operator|)
argument_list|)
operator|>
literal|1
condition|)
operator|++
name|opt
expr_stmt|;
else|else
block|{
operator|++
name|arg
expr_stmt|;
name|opt
operator|=
literal|0
expr_stmt|;
name|opt_len
operator|=
name|strlen
argument_list|(
name|argv
index|[
name|arg
index|]
argument_list|)
expr_stmt|;
block|}
comment|/*  *  xOffset:unit  */
name|val
operator|=
name|val1
operator|=
name|d
operator|=
name|ch_ctr
operator|=
literal|0
expr_stmt|;
name|neg_flag
operator|=
name|FLAG_OFF
expr_stmt|;
while|while
condition|(
name|opt
operator|<
name|opt_len
condition|)
block|{
name|ch
operator|=
name|argv
index|[
name|arg
index|]
index|[
name|opt
operator|++
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|ch
operator|==
literal|'-'
operator|)
operator|&&
operator|(
name|ch_ctr
operator|==
literal|0
operator|)
condition|)
name|neg_flag
operator|=
name|FLAG_ON
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|ch
operator|>=
literal|'0'
operator|)
operator|&&
operator|(
name|ch
operator|<=
literal|'9'
operator|)
condition|)
block|{
name|ch
operator|=
name|ch
operator|-
literal|'0'
expr_stmt|;
if|if
condition|(
name|d
operator|==
literal|0
condition|)
name|val
operator|=
operator|(
name|val
operator|*
literal|10
operator|)
operator|+
name|ch
expr_stmt|;
elseif|else
if|if
condition|(
name|d
operator|<=
literal|1000
condition|)
comment|/* prec = 10**(-3) 							    truncated */
block|{
name|val1
operator|=
operator|(
name|val1
operator|*
literal|10
operator|)
operator|+
name|ch
expr_stmt|;
name|d
operator|=
name|d
operator|*
literal|10
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|ch
operator|==
literal|'.'
condition|)
block|{
name|d
operator|=
literal|1
expr_stmt|;
name|val1
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|ch
operator|==
literal|':'
operator|)
operator|&&
operator|(
name|opt
operator|<
name|opt_len
operator|)
condition|)
name|ch
operator|=
name|argv
index|[
name|arg
index|]
index|[
name|opt
operator|++
index|]
expr_stmt|;
break|break;
comment|/* exit loop */
block|}
operator|++
name|ch_ctr
expr_stmt|;
block|}
comment|/*				end while (opt< opt_len) */
if|if
condition|(
name|d
operator|==
literal|0
condition|)
name|d
operator|=
literal|1
expr_stmt|;
else|else
name|val
operator|=
operator|(
name|val
operator|*
name|d
operator|)
operator|+
name|val1
expr_stmt|;
if|if
condition|(
name|val
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|neg_flag
operator|==
name|FLAG_ON
condition|)
name|val
operator|=
operator|-
operator|(
name|val
operator|)
expr_stmt|;
switch|switch
condition|(
name|ch
condition|)
block|{
case|case
operator|(
literal|'c'
operator|)
case|:
name|d
operator|=
name|d
operator|*
literal|100
expr_stmt|;
break|break;
case|case
operator|(
literal|'i'
operator|)
case|:
name|val
operator|=
name|val
operator|*
literal|254
expr_stmt|;
name|d
operator|=
name|d
operator|*
literal|10000
expr_stmt|;
break|break;
case|case
operator|(
literal|'p'
operator|)
case|:
name|val
operator|=
name|val
operator|*
literal|254
expr_stmt|;
name|d
operator|=
operator|(
operator|(
name|d
operator|*
literal|720000
operator|)
operator|&
literal|0x7fffffff
operator|)
expr_stmt|;
break|break;
case|case
operator|(
literal|'P'
operator|)
case|:
name|val
operator|=
name|val
operator|*
literal|254
expr_stmt|;
name|d
operator|=
operator|(
operator|(
name|d
operator|*
literal|60000
operator|)
operator|&
literal|0x7fffffff
operator|)
expr_stmt|;
break|break;
default|default:
name|d
operator|=
name|d
operator|*
literal|100
expr_stmt|;
comment|/* def=cm */
break|break;
block|}
comment|/*				    end switch (ch) */
if|if
condition|(
name|d
operator|!=
literal|0
condition|)
comment|/* last chk for div 						     by 0 just in case 						     of ovflw */
block|{
name|xoff_num
operator|=
name|val
expr_stmt|;
name|xoff_den
operator|=
name|d
expr_stmt|;
name|proc_flag
index|[
name|X_OFFSET
index|]
operator|=
name|FLAG_ON
expr_stmt|;
block|}
block|}
else|else
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|msg
argument_list|,
literal|"--ipfe:  No xOffset value specified in (%s)\n"
argument_list|,
name|argv
index|[
name|arg
index|]
argument_list|)
expr_stmt|;
name|pip_error
argument_list|(
name|msg
argument_list|)
expr_stmt|;
name|err_flag
operator|=
name|FLAG_ON
expr_stmt|;
block|}
operator|--
name|opt
expr_stmt|;
comment|/* to parse cur ch at cmd line */
break|break;
case|case
operator|(
literal|'Y'
operator|)
case|:
if|if
condition|(
name|strlen
argument_list|(
operator|&
operator|(
name|argv
index|[
name|arg
index|]
index|[
name|opt
index|]
operator|)
argument_list|)
operator|>
literal|1
condition|)
operator|++
name|opt
expr_stmt|;
else|else
block|{
operator|++
name|arg
expr_stmt|;
name|opt
operator|=
literal|0
expr_stmt|;
name|opt_len
operator|=
name|strlen
argument_list|(
name|argv
index|[
name|arg
index|]
argument_list|)
expr_stmt|;
block|}
comment|/*  *  yOffset:unit  */
name|val
operator|=
name|val1
operator|=
name|d
operator|=
name|ch_ctr
operator|=
literal|0
expr_stmt|;
name|neg_flag
operator|=
name|FLAG_OFF
expr_stmt|;
while|while
condition|(
name|opt
operator|<
name|opt_len
condition|)
block|{
name|ch
operator|=
name|argv
index|[
name|arg
index|]
index|[
name|opt
operator|++
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|ch
operator|==
literal|'-'
operator|)
operator|&&
operator|(
name|ch_ctr
operator|==
literal|0
operator|)
condition|)
name|neg_flag
operator|=
name|FLAG_ON
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|ch
operator|>=
literal|'0'
operator|)
operator|&&
operator|(
name|ch
operator|<=
literal|'9'
operator|)
condition|)
block|{
name|ch
operator|=
name|ch
operator|-
literal|'0'
expr_stmt|;
if|if
condition|(
name|d
operator|==
literal|0
condition|)
name|val
operator|=
operator|(
name|val
operator|*
literal|10
operator|)
operator|+
name|ch
expr_stmt|;
elseif|else
if|if
condition|(
name|d
operator|<=
literal|1000
condition|)
comment|/* prec = 10**(-3) 							    truncated */
block|{
name|val1
operator|=
operator|(
name|val1
operator|*
literal|10
operator|)
operator|+
name|ch
expr_stmt|;
name|d
operator|=
name|d
operator|*
literal|10
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|ch
operator|==
literal|'.'
condition|)
block|{
name|d
operator|=
literal|1
expr_stmt|;
name|val1
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|ch
operator|==
literal|':'
operator|)
operator|&&
operator|(
name|opt
operator|<
name|opt_len
operator|)
condition|)
name|ch
operator|=
name|argv
index|[
name|arg
index|]
index|[
name|opt
operator|++
index|]
expr_stmt|;
break|break;
comment|/* exit loop */
block|}
operator|++
name|ch_ctr
expr_stmt|;
block|}
comment|/*				end while (opt< opt_len) */
if|if
condition|(
name|d
operator|==
literal|0
condition|)
name|d
operator|=
literal|1
expr_stmt|;
else|else
name|val
operator|=
operator|(
name|val
operator|*
name|d
operator|)
operator|+
name|val1
expr_stmt|;
if|if
condition|(
name|val
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|neg_flag
operator|==
name|FLAG_ON
condition|)
name|val
operator|=
operator|-
operator|(
name|val
operator|)
expr_stmt|;
switch|switch
condition|(
name|ch
condition|)
block|{
case|case
operator|(
literal|'c'
operator|)
case|:
name|d
operator|=
name|d
operator|*
literal|100
expr_stmt|;
break|break;
case|case
operator|(
literal|'i'
operator|)
case|:
name|val
operator|=
name|val
operator|*
literal|254
expr_stmt|;
name|d
operator|=
name|d
operator|*
literal|10000
expr_stmt|;
break|break;
case|case
operator|(
literal|'p'
operator|)
case|:
name|val
operator|=
name|val
operator|*
literal|254
expr_stmt|;
name|d
operator|=
operator|(
operator|(
name|d
operator|*
literal|720000
operator|)
operator|&
literal|0x7fffffff
operator|)
expr_stmt|;
break|break;
case|case
operator|(
literal|'P'
operator|)
case|:
name|val
operator|=
name|val
operator|*
literal|254
expr_stmt|;
name|d
operator|=
operator|(
operator|(
name|d
operator|*
literal|60000
operator|)
operator|&
literal|0x7fffffff
operator|)
expr_stmt|;
break|break;
default|default:
name|d
operator|=
name|d
operator|*
literal|100
expr_stmt|;
comment|/* def=cm */
break|break;
block|}
comment|/*				    end switch (ch) */
if|if
condition|(
name|d
operator|!=
literal|0
condition|)
comment|/* last chk for div 						     by 0 just in case 						     of ovflw */
block|{
name|yoff_num
operator|=
name|val
expr_stmt|;
name|yoff_den
operator|=
name|d
expr_stmt|;
name|proc_flag
index|[
name|Y_OFFSET
index|]
operator|=
name|FLAG_ON
expr_stmt|;
block|}
block|}
else|else
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|msg
argument_list|,
literal|"--ipfe:  No yOffset value specified in (%s)\n"
argument_list|,
name|argv
index|[
name|arg
index|]
argument_list|)
expr_stmt|;
name|pip_error
argument_list|(
name|msg
argument_list|)
expr_stmt|;
name|err_flag
operator|=
name|FLAG_ON
expr_stmt|;
block|}
operator|--
name|opt
expr_stmt|;
comment|/* to parse cur ch at cmd line */
break|break;
default|default:
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|msg
argument_list|,
literal|"--ipfe:  Invalid option in %s (%s)\n"
argument_list|,
name|argv
index|[
name|arg
index|]
argument_list|,
operator|&
operator|(
name|argv
index|[
name|arg
index|]
index|[
name|opt
index|]
operator|)
argument_list|)
expr_stmt|;
name|pip_error
argument_list|(
name|msg
argument_list|)
expr_stmt|;
name|err_flag
operator|=
name|FLAG_ON
expr_stmt|;
break|break;
block|}
block|}
break|break;
case|case
operator|(
literal|'['
operator|)
case|:
break|break;
case|case
operator|(
literal|'>'
operator|)
case|:
break|break;
default|default:
comment|/*  *  the current arg is an input file; try to open it  */
if|if
condition|(
name|input_indx
operator|<
name|MX_NO_INFILES
condition|)
block|{
name|_fmode
operator|=
name|BINARY_FILE
expr_stmt|;
name|workfile
operator|=
name|fopen
argument_list|(
name|argv
index|[
name|arg
index|]
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|workfile
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|msg
argument_list|,
literal|"--ipfe:  Error opening input file: %s\n"
argument_list|,
name|argv
index|[
name|arg
index|]
argument_list|)
expr_stmt|;
name|pip_error
argument_list|(
name|msg
argument_list|)
expr_stmt|;
name|err_flag
operator|=
name|FLAG_ON
expr_stmt|;
block|}
else|else
block|{
comment|/*  *  check for valid hdr  */
name|retcd
operator|=
name|get_ip_hdr
argument_list|(
name|workfile
argument_list|,
name|argv
index|[
name|arg
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|retcd
operator|==
name|OK
condition|)
block|{
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|input_name
index|[
name|input_indx
index|]
argument_list|,
name|argv
index|[
name|arg
index|]
argument_list|)
expr_stmt|;
comment|/*  *  check for page range  */
if|if
condition|(
operator|(
operator|(
name|arg
operator|+
literal|1
operator|)
operator|<
name|argc
operator|)
operator|&&
operator|(
operator|(
name|argv
index|[
name|arg
operator|+
literal|1
index|]
index|[
literal|0
index|]
operator|==
literal|'['
operator|)
operator|||
operator|(
name|argv
index|[
name|arg
operator|+
literal|1
index|]
index|[
literal|0
index|]
operator|==
literal|'+'
operator|)
operator|||
operator|(
name|argv
index|[
name|arg
operator|+
literal|1
index|]
index|[
literal|0
index|]
operator|==
literal|'#'
operator|)
operator|)
condition|)
block|{
operator|++
name|arg
expr_stmt|;
name|get_pagerange
argument_list|(
name|arg
argument_list|,
name|argv
argument_list|)
expr_stmt|;
block|}
else|else
name|merge_pg
index|[
name|input_indx
index|]
index|[
literal|0
index|]
operator|=
operator|(
operator|-
literal|1
operator|)
expr_stmt|;
name|infile_flag
index|[
name|input_indx
index|]
operator|=
name|FLAG_ON
expr_stmt|;
operator|++
name|input_indx
expr_stmt|;
operator|++
name|num_infiles
expr_stmt|;
block|}
else|else
name|err_flag
operator|=
name|FLAG_ON
expr_stmt|;
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|workfile
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|msg
argument_list|,
literal|"--ipfe:  Maximum # of input files = %d; File:  %s not processed\n"
argument_list|,
name|MX_NO_INFILES
argument_list|,
name|argv
index|[
name|arg
index|]
argument_list|)
expr_stmt|;
name|pip_error
argument_list|(
name|msg
argument_list|)
expr_stmt|;
name|err_flag
operator|=
name|FLAG_ON
expr_stmt|;
block|}
break|break;
block|}
comment|/*	    end switch (argv[arg][0]) */
block|}
comment|/*	end for (arg=1; arg< argc; arg++) */
if|if
condition|(
name|err_flag
operator|==
name|FLAG_ON
condition|)
name|pip_error
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/****************************************************************  *  *	int get_ip_hdr(file, filename):  *	int get_ip_hdr:	get the ip_hdr from the specified  *				file into a work_buf& return a  *				ptr to the buf  *  ****************************************************************/
end_comment

begin_function
name|int
name|get_ip_hdr
parameter_list|(
name|file
parameter_list|,
name|filename
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
name|char
modifier|*
name|filename
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|retcd
decl_stmt|,
name|hdr_flag
decl_stmt|;
name|int
name|c
decl_stmt|;
comment|/* must be int for stdio EOF compare */
name|char
modifier|*
name|ptr
decl_stmt|,
name|msg
index|[
literal|128
index|]
decl_stmt|;
name|retcd
operator|=
name|OK
expr_stmt|;
comment|/*  *  get the header  */
name|ptr
operator|=
name|hdr_workbuf
expr_stmt|;
name|hdr_flag
operator|=
name|FLAG_OFF
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MX_HDR_BUFLEN
condition|;
name|i
operator|++
control|)
block|{
name|c
operator|=
name|getc_testeof
argument_list|(
name|file
argument_list|,
name|filename
argument_list|)
expr_stmt|;
comment|/* get a char,          */
operator|*
name|ptr
operator|++
operator|=
name|c
expr_stmt|;
comment|/*& stick it in the buffer  */
if|if
condition|(
name|c
operator|==
literal|' '
condition|)
comment|/* if c=ip_hdr_terminate_char, */
block|{
name|hdr_flag
operator|=
name|FLAG_ON
expr_stmt|;
comment|/*   set hdr_ok flag,          */
break|break;
comment|/*& exit the loop           */
block|}
block|}
operator|*
name|ptr
operator|=
literal|'\0'
expr_stmt|;
comment|/*  *  ...& check its validity  */
if|if
condition|(
name|hdr_flag
operator|==
name|FLAG_OFF
condition|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|msg
argument_list|,
literal|"--ipfe:  Hdr length> %d chars in file: %s\n"
argument_list|,
name|MX_HDR_BUFLEN
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|pip_error
argument_list|(
name|msg
argument_list|)
expr_stmt|;
name|retcd
operator|=
name|ERROR
expr_stmt|;
block|}
if|if
condition|(
name|mstrncmp
argument_list|(
name|hdr_workbuf
argument_list|,
name|IP_Header
argument_list|,
name|IP_HDR_CHKLEN
argument_list|)
operator|!=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|msg
argument_list|,
literal|"--ipfe:  INVALID HEADER! in file: %s\n"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|pip_error
argument_list|(
name|msg
argument_list|)
expr_stmt|;
name|retcd
operator|=
name|ERROR
expr_stmt|;
block|}
return|return
operator|(
name|retcd
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/****************************************************************  *  *	get_pagerange(arg, argv):  *	get_pagerange:	get cmd_line page range argument  *				for current input_indx from  *				specified argument  *  ****************************************************************/
end_comment

begin_macro
name|get_pagerange
argument_list|(
argument|arg
argument_list|,
argument|argv
argument_list|)
end_macro

begin_decl_stmt
name|int
name|arg
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|argv
index|[]
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|i
decl_stmt|,
name|opt
decl_stmt|,
name|opt_len
decl_stmt|,
name|d
decl_stmt|,
name|val
decl_stmt|,
name|val1
decl_stmt|,
name|lp_ctr
decl_stmt|,
name|ch_ctr
decl_stmt|,
name|prv_mpg_num
decl_stmt|,
name|err_flag
decl_stmt|,
name|neg_flag
decl_stmt|;
name|char
name|ch
decl_stmt|,
name|nc
decl_stmt|;
name|char
name|msg
index|[
literal|128
index|]
decl_stmt|,
name|name_buf
index|[
literal|128
index|]
decl_stmt|;
name|merge_indx
operator|=
name|val
operator|=
literal|0
expr_stmt|;
name|prv_mpg_num
operator|=
literal|0
expr_stmt|;
name|opt_len
operator|=
name|strlen
argument_list|(
name|argv
index|[
name|arg
index|]
argument_list|)
expr_stmt|;
name|err_flag
operator|=
name|FLAG_OFF
expr_stmt|;
for|for
control|(
name|opt
operator|=
literal|1
init|;
operator|(
operator|(
name|opt
operator|<
name|opt_len
operator|)
operator|&&
operator|(
name|err_flag
operator|==
name|FLAG_OFF
operator|)
operator|)
condition|;
name|opt
operator|++
control|)
block|{
switch|switch
condition|(
name|argv
index|[
name|arg
index|]
index|[
name|opt
index|]
condition|)
block|{
case|case
operator|(
literal|'-'
operator|)
case|:
name|merge_pg
index|[
name|input_indx
index|]
index|[
name|merge_indx
index|]
operator|=
operator|(
operator|-
literal|1
operator|)
expr_stmt|;
operator|++
name|merge_indx
expr_stmt|;
break|break;
comment|/*  *  all of the following can just be ignored at this level  */
case|case
operator|(
literal|','
operator|)
case|:
case|case
operator|(
literal|']'
operator|)
case|:
case|case
operator|(
literal|')'
operator|)
case|:
case|case
operator|(
name|SPC
operator|)
case|:
case|case
operator|(
literal|'\n'
operator|)
case|:
break|break;
case|case
operator|(
literal|'['
operator|)
case|:
case|case
operator|(
literal|'+'
operator|)
case|:
comment|/*  *  overlay filename  */
if|if
condition|(
name|strlen
argument_list|(
operator|&
operator|(
name|argv
index|[
name|arg
index|]
index|[
name|opt
index|]
operator|)
argument_list|)
operator|>
literal|1
condition|)
block|{
name|ch
operator|=
literal|'\0'
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
operator|++
name|opt
expr_stmt|;
while|while
condition|(
name|opt
operator|<
name|opt_len
condition|)
block|{
name|ch
operator|=
name|argv
index|[
name|arg
index|]
index|[
name|opt
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|ch
operator|==
literal|':'
operator|)
operator|||
operator|(
name|ch
operator|==
literal|'('
operator|)
operator|||
operator|(
name|ch
operator|==
literal|'@'
operator|)
operator|||
operator|(
name|ch
operator|==
literal|'+'
operator|)
condition|)
block|{
operator|--
name|opt
expr_stmt|;
comment|/* reparse opt at switch level */
break|break;
block|}
elseif|else
if|if
condition|(
operator|(
name|ch
operator|==
literal|']'
operator|)
operator|||
operator|(
name|ch
operator|==
literal|','
operator|)
condition|)
break|break;
comment|/* don't bother reparsing */
else|else
block|{
name|name_buf
index|[
name|i
operator|++
index|]
operator|=
name|ch
expr_stmt|;
operator|++
name|opt
expr_stmt|;
block|}
block|}
name|name_buf
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|i
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|merge_indx
operator|==
literal|0
condition|)
block|{
name|merge_pg
index|[
name|input_indx
index|]
index|[
literal|0
index|]
operator|=
literal|1
expr_stmt|;
operator|++
name|merge_indx
expr_stmt|;
block|}
if|if
condition|(
name|merge_pg
index|[
name|input_indx
index|]
index|[
operator|(
name|merge_indx
operator|-
literal|1
operator|)
index|]
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|ovly_pg
index|[
name|input_indx
index|]
index|[
operator|(
name|merge_indx
operator|-
literal|1
operator|)
index|]
operator|!=
operator|(
operator|-
literal|1
operator|)
condition|)
block|{
name|merge_pg
index|[
name|input_indx
index|]
index|[
name|merge_indx
index|]
operator|=
name|merge_pg
index|[
name|input_indx
index|]
index|[
operator|(
name|merge_indx
operator|-
literal|1
operator|)
index|]
expr_stmt|;
operator|++
name|merge_indx
expr_stmt|;
block|}
name|ovly_pg
index|[
name|input_indx
index|]
index|[
operator|(
name|merge_indx
operator|-
literal|1
operator|)
index|]
operator|=
name|ovly_indx
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|ovly_fname
index|[
name|ovly_indx
index|]
argument_list|,
name|name_buf
argument_list|)
expr_stmt|;
operator|++
name|ovly_indx
expr_stmt|;
block|}
else|else
name|err_flag
operator|=
name|FLAG_ON
expr_stmt|;
block|}
else|else
name|err_flag
operator|=
name|FLAG_ON
expr_stmt|;
block|}
else|else
name|err_flag
operator|=
name|FLAG_ON
expr_stmt|;
break|break;
case|case
operator|(
literal|':'
operator|)
case|:
comment|/*  *  overlay pagenum  */
if|if
condition|(
operator|(
name|ovly_indx
operator|==
literal|0
operator|)
operator|||
operator|(
name|ovly_pg
index|[
name|input_indx
index|]
index|[
name|merge_indx
operator|-
literal|1
index|]
operator|==
operator|(
operator|-
literal|1
operator|)
operator|)
operator|||
operator|(
name|ovly_pgnum
index|[
name|ovly_indx
operator|-
literal|1
index|]
operator|!=
literal|0
operator|)
condition|)
name|err_flag
operator|=
name|FLAG_ON
expr_stmt|;
elseif|else
if|if
condition|(
name|strlen
argument_list|(
operator|&
operator|(
name|argv
index|[
name|arg
index|]
index|[
name|opt
index|]
operator|)
argument_list|)
operator|>
literal|1
condition|)
block|{
name|val
operator|=
literal|0
expr_stmt|;
operator|++
name|opt
expr_stmt|;
while|while
condition|(
name|opt
operator|<
name|opt_len
condition|)
block|{
name|ch
operator|=
name|argv
index|[
name|arg
index|]
index|[
name|opt
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|ch
operator|>=
literal|'0'
operator|)
operator|&&
operator|(
name|ch
operator|<=
literal|'9'
operator|)
condition|)
block|{
name|ch
operator|=
name|ch
operator|-
literal|'0'
expr_stmt|;
name|val
operator|=
operator|(
name|val
operator|*
literal|10
operator|)
operator|+
name|ch
expr_stmt|;
operator|++
name|opt
expr_stmt|;
block|}
else|else
block|{
operator|--
name|opt
expr_stmt|;
comment|/* reparse everything else at the 					   switch level */
break|break;
block|}
block|}
comment|/*  *  if the pagenum is good, process it  */
if|if
condition|(
name|val
operator|>
literal|0
condition|)
name|ovly_pgnum
index|[
name|ovly_indx
operator|-
literal|1
index|]
operator|=
name|val
expr_stmt|;
block|}
else|else
name|err_flag
operator|=
name|FLAG_ON
expr_stmt|;
break|break;
case|case
operator|(
literal|'('
operator|)
case|:
case|case
operator|(
literal|'@'
operator|)
case|:
comment|/*  *  overlay page offset  */
if|if
condition|(
operator|(
name|ovly_indx
operator|==
literal|0
operator|)
operator|||
operator|(
name|ovly_pg
index|[
name|input_indx
index|]
index|[
name|merge_indx
operator|-
literal|1
index|]
operator|==
operator|(
operator|-
literal|1
operator|)
operator|)
condition|)
name|err_flag
operator|=
name|FLAG_ON
expr_stmt|;
elseif|else
if|if
condition|(
name|strlen
argument_list|(
operator|&
operator|(
name|argv
index|[
name|arg
index|]
index|[
name|opt
index|]
operator|)
argument_list|)
operator|>
literal|1
condition|)
block|{
name|val
operator|=
name|val1
operator|=
name|d
operator|=
name|lp_ctr
operator|=
name|ch_ctr
operator|=
literal|0
expr_stmt|;
name|neg_flag
operator|=
name|FLAG_OFF
expr_stmt|;
operator|++
name|opt
expr_stmt|;
while|while
condition|(
operator|(
name|opt
operator|<
name|opt_len
operator|)
operator|&&
operator|(
name|lp_ctr
operator|<
literal|2
operator|)
condition|)
block|{
name|ch
operator|=
name|argv
index|[
name|arg
index|]
index|[
name|opt
operator|++
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|ch
operator|==
literal|'-'
operator|)
operator|&&
operator|(
name|ch_ctr
operator|==
literal|0
operator|)
condition|)
name|neg_flag
operator|=
name|FLAG_ON
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|ch
operator|>=
literal|'0'
operator|)
operator|&&
operator|(
name|ch
operator|<=
literal|'9'
operator|)
condition|)
block|{
name|ch
operator|=
name|ch
operator|-
literal|'0'
expr_stmt|;
if|if
condition|(
name|d
operator|==
literal|0
condition|)
name|val
operator|=
operator|(
name|val
operator|*
literal|10
operator|)
operator|+
name|ch
expr_stmt|;
elseif|else
if|if
condition|(
name|d
operator|<=
literal|1000
condition|)
comment|/* precision = 10**(-3) 						    truncated */
block|{
name|val1
operator|=
operator|(
name|val1
operator|*
literal|10
operator|)
operator|+
name|ch
expr_stmt|;
name|d
operator|=
name|d
operator|*
literal|10
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|ch
operator|==
literal|'.'
condition|)
block|{
name|d
operator|=
literal|1
expr_stmt|;
name|val1
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|d
operator|!=
literal|0
condition|)
name|val
operator|=
operator|(
name|val
operator|*
name|d
operator|)
operator|+
name|val1
expr_stmt|;
else|else
name|d
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|val
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|neg_flag
operator|==
name|FLAG_ON
condition|)
name|val
operator|=
operator|-
operator|(
name|val
operator|)
expr_stmt|;
switch|switch
condition|(
name|ch
condition|)
block|{
case|case
operator|(
literal|'c'
operator|)
case|:
name|d
operator|=
name|d
operator|*
literal|100
expr_stmt|;
break|break;
case|case
operator|(
literal|'i'
operator|)
case|:
name|val
operator|=
name|val
operator|*
literal|254
expr_stmt|;
name|d
operator|=
name|d
operator|*
literal|10000
expr_stmt|;
break|break;
case|case
operator|(
literal|'p'
operator|)
case|:
name|val
operator|=
name|val
operator|*
literal|254
expr_stmt|;
name|d
operator|=
operator|(
operator|(
name|d
operator|*
literal|720000
operator|)
operator|&
literal|0x7fffffff
operator|)
expr_stmt|;
break|break;
case|case
operator|(
literal|'P'
operator|)
case|:
name|val
operator|=
name|val
operator|*
literal|254
expr_stmt|;
name|d
operator|=
operator|(
operator|(
name|d
operator|*
literal|60000
operator|)
operator|&
literal|0x7fffffff
operator|)
expr_stmt|;
break|break;
default|default:
name|d
operator|=
name|d
operator|*
literal|100
expr_stmt|;
comment|/* assume cm */
break|break;
block|}
if|if
condition|(
name|d
operator|!=
literal|0
condition|)
comment|/* last chk for div by 0 						     just in case of ovflw */
block|{
name|ovly_num
index|[
name|lp_ctr
index|]
index|[
name|ovly_indx
operator|-
literal|1
index|]
operator|=
name|val
expr_stmt|;
name|ovly_den
index|[
name|lp_ctr
index|]
index|[
name|ovly_indx
operator|-
literal|1
index|]
operator|=
name|d
expr_stmt|;
block|}
if|if
condition|(
name|lp_ctr
operator|==
literal|0
condition|)
block|{
name|nc
operator|=
name|argv
index|[
name|arg
index|]
index|[
name|opt
index|]
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|nc
operator|<
literal|'0'
operator|)
operator|&&
operator|(
name|nc
operator|!=
literal|'-'
operator|)
operator|)
operator|||
operator|(
name|nc
operator|>
literal|'9'
operator|)
condition|)
operator|++
name|opt
expr_stmt|;
comment|/* assume only 1 separator 						      after scale char */
block|}
block|}
name|val
operator|=
name|d
operator|=
literal|0
expr_stmt|;
name|neg_flag
operator|=
name|FLAG_OFF
expr_stmt|;
operator|++
name|lp_ctr
expr_stmt|;
name|ch_ctr
operator|=
operator|(
operator|-
literal|1
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|lp_ctr
operator|==
literal|2
operator|)
operator|&&
operator|(
operator|(
name|ch
operator|==
literal|'+'
operator|)
operator|||
operator|(
name|ch
operator|==
literal|'['
operator|)
operator|||
operator|(
name|ch
operator|==
literal|'-'
operator|)
operator|)
condition|)
operator|--
name|opt
expr_stmt|;
comment|/* reparse at switch level */
block|}
operator|++
name|ch_ctr
expr_stmt|;
block|}
operator|--
name|opt
expr_stmt|;
comment|/* to undo the automatic incr above */
block|}
else|else
name|err_flag
operator|=
name|FLAG_ON
expr_stmt|;
break|break;
default|default:
comment|/*  *  current opt should be a pageNum  */
name|val
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|opt
operator|<
name|opt_len
condition|)
block|{
name|ch
operator|=
name|argv
index|[
name|arg
index|]
index|[
name|opt
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|ch
operator|>=
literal|'0'
operator|)
operator|&&
operator|(
name|ch
operator|<=
literal|'9'
operator|)
condition|)
block|{
name|ch
operator|=
name|ch
operator|-
literal|'0'
expr_stmt|;
name|val
operator|=
operator|(
name|val
operator|*
literal|10
operator|)
operator|+
name|ch
expr_stmt|;
operator|++
name|opt
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|ch
operator|==
literal|'-'
operator|)
operator|||
operator|(
name|ch
operator|==
literal|','
operator|)
operator|||
operator|(
name|ch
operator|==
literal|'['
operator|)
operator|||
operator|(
name|ch
operator|==
literal|']'
operator|)
operator|||
operator|(
name|ch
operator|==
literal|'+'
operator|)
condition|)
block|{
operator|--
name|opt
expr_stmt|;
comment|/* reparse opt at switch level */
break|break;
block|}
elseif|else
if|if
condition|(
operator|(
name|ch
operator|==
name|SPC
operator|)
operator|||
operator|(
name|ch
operator|==
literal|'\n'
operator|)
condition|)
break|break;
comment|/* don't bother to reparse */
else|else
block|{
name|err_flag
operator|=
name|FLAG_ON
expr_stmt|;
break|break;
block|}
block|}
comment|/*  *  if the val is good, process it  */
if|if
condition|(
name|val
operator|>
name|prv_mpg_num
condition|)
block|{
name|merge_pg
index|[
name|input_indx
index|]
index|[
name|merge_indx
index|]
operator|=
name|val
expr_stmt|;
name|prv_mpg_num
operator|=
name|val
expr_stmt|;
operator|++
name|merge_indx
expr_stmt|;
block|}
else|else
name|err_flag
operator|=
name|FLAG_ON
expr_stmt|;
break|break;
block|}
comment|/*	    end of switch (argv[arg][opt]) */
if|if
condition|(
name|err_flag
operator|==
name|FLAG_ON
condition|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|msg
argument_list|,
literal|"--ipfe:  Invalid pagerange specification in %s (%s)\n"
argument_list|,
name|argv
index|[
name|arg
index|]
argument_list|,
operator|&
operator|(
name|argv
index|[
name|arg
index|]
index|[
name|opt
index|]
operator|)
argument_list|)
expr_stmt|;
name|pip_error
argument_list|(
name|msg
argument_list|)
expr_stmt|;
name|exit_status
operator|=
literal|5
expr_stmt|;
block|}
block|}
comment|/*	end of for (opt=1; ((opt< opt_len)&& (err_flag == FLAG_OFF)); 		    ++ opt) */
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/****************************************************************  *  *	int getc_testeof(file, filename):  *	int getc_testeof:	get a char from input file;  *				if we get an EOF here,  *				    it's an error;  *				else,  *				    return the char as an int  *  ****************************************************************/
end_comment

begin_function
name|int
name|getc_testeof
parameter_list|(
name|file
parameter_list|,
name|filename
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
name|char
modifier|*
name|filename
decl_stmt|;
block|{
name|int
name|val
decl_stmt|;
name|char
name|msg
index|[
literal|128
index|]
decl_stmt|;
name|val
operator|=
name|mgetc
argument_list|(
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|feof
argument_list|(
name|file
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|msg
argument_list|,
literal|"\nUnexpected EOF! in file:  %s\n"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|pip_error
argument_list|(
name|msg
argument_list|)
expr_stmt|;
name|longjmp
argument_list|(
name|next_file
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|val
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/****************************************************************  *  *	indent(cnt, file):  *	indent:		put<cnt> spcs to specified file  *  ****************************************************************/
end_comment

begin_macro
name|indent
argument_list|(
argument|cnt
argument_list|,
argument|file
argument_list|)
end_macro

begin_decl_stmt
name|FILE
modifier|*
name|file
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|cnt
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|file
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|file
operator|==
name|propfile
operator|)
operator|&&
operator|(
name|cnt
operator|>
literal|0
operator|)
condition|)
name|cur_col
operator|=
name|cur_col
operator|+
name|cnt
expr_stmt|;
while|while
condition|(
name|cnt
operator|--
operator|>
literal|0
condition|)
block|{
name|putc
argument_list|(
literal|' '
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/****************************************************************  *  *	init:  *	init_ipfe:		initialization  *  ****************************************************************/
end_comment

begin_macro
name|init_ipfe
argument_list|()
end_macro

begin_block
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|abort_flag
operator|=
name|debug_flag
operator|=
name|FLAG_OFF
expr_stmt|;
name|exit_status
operator|=
literal|0
expr_stmt|;
name|ovly_flag
operator|=
name|FLAG_OFF
expr_stmt|;
name|frstpg_flag
operator|=
name|FLAG_OFF
expr_stmt|;
name|num_infiles
operator|=
name|out_filnum
operator|=
literal|0
expr_stmt|;
name|input_indx
operator|=
name|output_indx
operator|=
name|sif_indx
operator|=
literal|0
expr_stmt|;
name|num_aliases
operator|=
literal|0
expr_stmt|;
name|alias_indx
operator|=
literal|0
expr_stmt|;
name|prop_level
operator|=
literal|0
expr_stmt|;
name|hdr_len
operator|=
literal|0
expr_stmt|;
name|pos
operator|=
name|in_offset
operator|=
literal|0
expr_stmt|;
name|block_indx
operator|=
literal|0
expr_stmt|;
name|block_flag
operator|=
name|FLAG_OFF
expr_stmt|;
name|out_beg_offset
index|[
name|block_indx
index|]
operator|=
literal|0
expr_stmt|;
name|tnum_blocks
operator|=
name|tnum_pages
operator|=
name|tnum_sifs
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_FNS
condition|;
name|i
operator|++
control|)
name|proc_flag
index|[
name|i
index|]
operator|=
name|FLAG_OFF
expr_stmt|;
name|chap_type
operator|=
name|chap_val
operator|=
literal|0
expr_stmt|;
name|ipwrite_flag
operator|=
name|FLAG_ON
expr_stmt|;
name|merge_indx
operator|=
name|ovly_indx
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MX_NO_INFILES
condition|;
name|i
operator|++
control|)
block|{
name|merge_pg
index|[
name|i
index|]
index|[
literal|0
index|]
operator|=
operator|(
operator|-
literal|1
operator|)
expr_stmt|;
comment|/* init to all pages */
name|ovly_pg
index|[
name|i
index|]
index|[
literal|0
index|]
operator|=
operator|(
operator|-
literal|1
operator|)
expr_stmt|;
comment|/* init to no overlay */
for|for
control|(
name|j
operator|=
literal|1
init|;
name|j
operator|<
name|MX_NO_MPG_ENTRIES
condition|;
name|j
operator|++
control|)
block|{
name|merge_pg
index|[
name|i
index|]
index|[
name|j
index|]
operator|=
literal|0
expr_stmt|;
name|ovly_pg
index|[
name|i
index|]
index|[
name|j
index|]
operator|=
operator|(
operator|-
literal|1
operator|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MX_BLOCK_DEPTH
condition|;
name|i
operator|++
control|)
name|blk_num_bytes
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|pg_num_bytes
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MX_NO_INFILES
condition|;
name|i
operator|++
control|)
name|infile_flag
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|outputname
operator|=
name|propfname
operator|=
literal|0
expr_stmt|;
comment|/*  *  make the beginBlock& endBlock names upper case  */
name|op_names
index|[
name|OP_beginBlock
index|]
operator|=
literal|"BEGIN"
expr_stmt|;
name|op_names
index|[
name|OP_endBlock
index|]
operator|=
literal|"END"
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/****************************************************************  *  *	init_proc_file:	initialize proc_file() loop  *  ****************************************************************/
end_comment

begin_macro
name|init_proc_file
argument_list|()
end_macro

begin_block
block|{
name|sif_indx
operator|=
literal|0
expr_stmt|;
name|cur_indent
operator|=
name|cur_col
operator|=
literal|0
expr_stmt|;
name|in_offset
operator|=
literal|0
expr_stmt|;
name|num_blocks
operator|=
name|num_pages
operator|=
name|num_sifs
operator|=
literal|0
expr_stmt|;
name|preamble_expected
operator|=
name|FLAG_OFF
expr_stmt|;
name|merge_indx
operator|=
literal|0
expr_stmt|;
name|bproc_indx
operator|=
name|bop_indx
operator|=
literal|0
expr_stmt|;
name|bproc_flag
operator|=
name|bop_flag
operator|=
name|FLAG_OFF
expr_stmt|;
name|ipwrite_flag
operator|=
name|FLAG_ON
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/****************************************************************  *  *	init1:  *	init1_ipfe:		initialization after getting cmd args  *  ****************************************************************/
end_comment

begin_macro
name|init1_ipfe
argument_list|()
end_macro

begin_block
block|{
name|int
name|i
decl_stmt|,
name|tval
decl_stmt|,
name|procflag
decl_stmt|,
name|exit_flag
decl_stmt|;
name|char
name|msg
index|[
literal|128
index|]
decl_stmt|;
if|if
condition|(
name|num_infiles
operator|==
literal|0
condition|)
comment|/* input_name req'd for now */
name|Usage
argument_list|()
expr_stmt|;
else|else
block|{
comment|/*  *  split the 1st input_name into input_fnm& input_ext  */
name|i
operator|=
name|mrstrichr
argument_list|(
name|input_name
index|[
literal|0
index|]
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|!=
operator|(
operator|-
literal|1
operator|)
condition|)
block|{
operator|(
name|void
operator|)
name|mstrncpy
argument_list|(
name|input_fnm
argument_list|,
name|input_name
index|[
literal|0
index|]
argument_list|,
name|i
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|input_ext
argument_list|,
operator|(
name|input_name
index|[
literal|0
index|]
operator|+
name|i
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|input_fnm
argument_list|,
name|input_name
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
comment|/*  *  Open properties file  */
if|if
condition|(
name|proc_flag
index|[
name|PROPERTIES
index|]
operator|==
name|FLAG_ON
condition|)
name|open_propfile
argument_list|()
expr_stmt|;
comment|/*  *  Tell about rotate, xOffset, yOffset, binding offset, duplex, and scale  */
if|if
condition|(
operator|(
name|proc_flag
index|[
name|LANDSCAPE
index|]
operator|==
name|FLAG_ON
operator|)
operator|||
operator|(
name|proc_flag
index|[
name|ROTATE
index|]
operator|==
name|FLAG_ON
operator|)
condition|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|msg
argument_list|,
literal|"--ipfe:  Rotate %d degrees\n"
argument_list|,
name|rot_deg
argument_list|)
expr_stmt|;
name|pip_error
argument_list|(
name|msg
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|proc_flag
index|[
name|X_OFFSET
index|]
operator|==
name|FLAG_ON
condition|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|msg
argument_list|,
literal|"--ipfe:  xOffset = %ld/%ld meters\n"
argument_list|,
name|xoff_num
argument_list|,
name|xoff_den
argument_list|)
expr_stmt|;
name|pip_error
argument_list|(
name|msg
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|proc_flag
index|[
name|Y_OFFSET
index|]
operator|==
name|FLAG_ON
condition|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|msg
argument_list|,
literal|"--ipfe:  yOffset = %ld/%ld meters\n"
argument_list|,
name|yoff_num
argument_list|,
name|yoff_den
argument_list|)
expr_stmt|;
name|pip_error
argument_list|(
name|msg
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|proc_flag
index|[
name|BINDING_OFFSET
index|]
operator|==
name|FLAG_ON
condition|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|msg
argument_list|,
literal|"--ipfe:  Binding offset = %ld/%ld meters\n"
argument_list|,
name|boff_num
argument_list|,
name|boff_den
argument_list|)
expr_stmt|;
name|pip_error
argument_list|(
name|msg
argument_list|)
expr_stmt|;
if|if
condition|(
name|proc_flag
index|[
name|DUPLEX
index|]
operator|==
name|FLAG_ON
condition|)
name|pip_error
argument_list|(
literal|"--ipfe:  Duplex processing set\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|proc_flag
index|[
name|SCALE
index|]
operator|==
name|FLAG_ON
condition|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|msg
argument_list|,
literal|"--ipfe:  Scale = %ld/%ld\n"
argument_list|,
name|scale_num
argument_list|,
name|scale_den
argument_list|)
expr_stmt|;
name|pip_error
argument_list|(
name|msg
argument_list|)
expr_stmt|;
block|}
comment|/*  *  Tell about chapterizing  */
if|if
condition|(
name|proc_flag
index|[
name|CHAPTERIZE
index|]
operator|==
name|FLAG_ON
condition|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|msg
argument_list|,
literal|"--ipfe:  Chapterize every %d "
argument_list|,
name|chap_val
argument_list|)
expr_stmt|;
name|pip_error
argument_list|(
name|msg
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|chap_type
condition|)
block|{
case|case
operator|(
name|CH_PAGES
operator|)
case|:
name|pip_error
argument_list|(
literal|"pages"
argument_list|)
expr_stmt|;
break|break;
case|case
operator|(
name|CH_KBYTES
operator|)
case|:
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|msg
argument_list|,
literal|"bytes (%d kbytes)"
argument_list|,
operator|(
name|chap_val
operator|/
literal|1024
operator|)
argument_list|)
expr_stmt|;
name|pip_error
argument_list|(
name|msg
argument_list|)
expr_stmt|;
break|break;
case|case
operator|(
name|CH_MBYTES
operator|)
case|:
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|msg
argument_list|,
literal|"bytes (%d mbytes)"
argument_list|,
operator|(
name|chap_val
operator|/
literal|1048576
operator|)
argument_list|)
expr_stmt|;
name|pip_error
argument_list|(
name|msg
argument_list|)
expr_stmt|;
break|break;
block|}
name|pip_error
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
comment|/*  *  Show any aliases  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_aliases
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|==
literal|0
condition|)
name|pip_error
argument_list|(
literal|"--ipfe:  "
argument_list|)
expr_stmt|;
else|else
name|pip_error
argument_list|(
literal|"--       "
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|msg
argument_list|,
literal|"Alias: %s=%s\n"
argument_list|,
name|alias_ref
index|[
name|i
index|]
argument_list|,
name|alias_act
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|pip_error
argument_list|(
name|msg
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|num_infiles
operator|>
literal|1
condition|)
name|proc_flag
index|[
name|CONCAT
index|]
operator|=
name|FLAG_ON
expr_stmt|;
if|if
condition|(
name|proc_flag
index|[
name|DEBUG
index|]
operator|==
name|FLAG_ON
condition|)
name|off_indent
operator|=
literal|10
expr_stmt|;
else|else
name|off_indent
operator|=
literal|0
expr_stmt|;
comment|/*  *  For now, IF the properties option flag is SET AND there is no output  *  file specified,  *  THEN set the environment for properties only (don't open output)  */
if|if
condition|(
operator|(
name|proc_flag
index|[
name|PROPERTIES
index|]
operator|==
name|FLAG_ON
operator|)
operator|&&
operator|(
name|outputname
operator|==
literal|0
operator|)
condition|)
empty_stmt|;
comment|/* process properties only; no output */
else|else
block|{
comment|/*  *  open the output file  */
if|if
condition|(
name|outputname
operator|==
literal|0
condition|)
block|{
comment|/*  *  construct a default output filename by concatenating ".ip" to the  *    fnm component of the 1st input filename, making sure the resulting  *    filename doesn't already exist; if it does exist, append "1" to  *    the fnm, then "2" to the fnm, etc. until the filename doesn't exist  */
name|tval
operator|=
literal|0
expr_stmt|;
name|exit_flag
operator|=
name|procflag
operator|=
name|FLAG_OFF
expr_stmt|;
while|while
condition|(
name|exit_flag
operator|==
name|FLAG_OFF
condition|)
block|{
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|work_fname
argument_list|,
name|input_fnm
argument_list|)
expr_stmt|;
if|if
condition|(
name|procflag
operator|==
name|FLAG_ON
condition|)
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|work_fname
argument_list|,
name|itostr
argument_list|(
name|tval
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|work_fname
argument_list|,
literal|".ip"
argument_list|)
expr_stmt|;
name|_fmode
operator|=
name|BINARY_FILE
expr_stmt|;
name|workfile
operator|=
name|fopen
argument_list|(
name|work_fname
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|workfile
operator|==
name|NULL
condition|)
block|{
name|outputname
operator|=
name|work_fname
expr_stmt|;
name|exit_flag
operator|=
name|FLAG_ON
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|workfile
argument_list|)
expr_stmt|;
operator|++
name|tval
expr_stmt|;
name|procflag
operator|=
name|FLAG_ON
expr_stmt|;
block|}
block|}
block|}
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|output_name
argument_list|,
name|outputname
argument_list|)
expr_stmt|;
name|outputname
operator|=
name|output_name
expr_stmt|;
name|i
operator|=
name|mrstrichr
argument_list|(
name|outputname
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|!=
operator|(
operator|-
literal|1
operator|)
condition|)
block|{
operator|(
name|void
operator|)
name|mstrncpy
argument_list|(
name|output_fnm
argument_list|,
name|outputname
argument_list|,
name|i
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|output_ext
argument_list|,
operator|(
name|outputname
operator|+
name|i
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|output_fnm
argument_list|,
name|outputname
argument_list|)
expr_stmt|;
if|if
condition|(
name|proc_flag
index|[
name|CHAPTERIZE
index|]
operator|==
name|FLAG_ON
condition|)
block|{
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|output_name
argument_list|,
name|output_fnm
argument_list|)
expr_stmt|;
name|out_filnum
operator|=
literal|1
expr_stmt|;
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|output_name
argument_list|,
name|itostr
argument_list|(
name|out_filnum
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|output_name
argument_list|,
name|output_ext
argument_list|)
expr_stmt|;
block|}
name|open_output
argument_list|()
expr_stmt|;
block|}
block|}
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/****************************************************************  *  *	iocopyn(length, file, filename):  *	iocopyn:		copy<length> bytes from specified  *				file to output, checking for  *				unexpected EOF  *  ****************************************************************/
end_comment

begin_macro
name|iocopyn
argument_list|(
argument|length
argument_list|,
argument|file
argument_list|,
argument|filename
argument_list|)
end_macro

begin_decl_stmt
name|FILE
modifier|*
name|file
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|long
name|length
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|filename
decl_stmt|;
end_decl_stmt

begin_block
block|{
while|while
condition|(
name|length
operator|--
operator|>
literal|0
condition|)
block|{
name|ip_putc
argument_list|(
name|getc_testeof
argument_list|(
name|file
argument_list|,
name|filename
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/****************************************************************  *  *	iogetn(length, file, filename, buf):  *	iogetn:		read<length> bytes from specified  *				file into specified buf, checking  *				for unexpected EOF  *				-- throw the bytes away, for now  *  ****************************************************************/
end_comment

begin_macro
name|iogetn
argument_list|(
argument|length
argument_list|,
argument|file
argument_list|,
argument|filename
argument_list|,
argument|buf
argument_list|)
end_macro

begin_decl_stmt
name|FILE
modifier|*
name|file
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|long
name|length
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|filename
decl_stmt|,
modifier|*
name|buf
decl_stmt|;
end_decl_stmt

begin_block
block|{
while|while
condition|(
name|length
operator|--
operator|>
literal|0
condition|)
block|{
operator|*
name|buf
operator|++
operator|=
name|getc_testeof
argument_list|(
name|file
argument_list|,
name|filename
argument_list|)
expr_stmt|;
block|}
operator|*
name|buf
operator|=
literal|'\0'
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/****************************************************************  *  *	ioputn(length, buf):  *	ioputn:		put<length> bytes from specified  *				buf to output  *  ****************************************************************/
end_comment

begin_macro
name|ioputn
argument_list|(
argument|length
argument_list|,
argument|buf
argument_list|)
end_macro

begin_decl_stmt
name|long
name|length
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|buf
decl_stmt|;
end_decl_stmt

begin_block
block|{
while|while
condition|(
name|length
operator|--
operator|>
literal|0
condition|)
block|{
name|ip_putc
argument_list|(
operator|*
name|buf
operator|++
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/****************************************************************  *  *	ioreadn(length, file, filename):  *	ioreadn:		read<length> bytes from specified  *				file, checking for unexpected EOF  *				-- throw the bytes away, for now  *  ****************************************************************/
end_comment

begin_macro
name|ioreadn
argument_list|(
argument|length
argument_list|,
argument|file
argument_list|,
argument|filename
argument_list|)
end_macro

begin_decl_stmt
name|FILE
modifier|*
name|file
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|long
name|length
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|filename
decl_stmt|;
end_decl_stmt

begin_block
block|{
while|while
condition|(
name|length
operator|--
operator|>
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|getc_testeof
argument_list|(
name|file
argument_list|,
name|filename
argument_list|)
expr_stmt|;
comment|/* throw it away */
block|}
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/****************************************************************  *  *	ip_putc(ch):  *	ip_putc:		put char to (interpress) output&  *				bump out_offset  *  ****************************************************************/
end_comment

begin_macro
name|ip_putc
argument_list|(
argument|ch
argument_list|)
end_macro

begin_decl_stmt
name|char
name|ch
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
operator|(
name|output
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|ipwrite_flag
operator|==
name|FLAG_ON
operator|)
condition|)
block|{
name|putc
argument_list|(
name|ch
argument_list|,
name|output
argument_list|)
expr_stmt|;
operator|++
name|out_offset
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/****************************************************************  *  *	ip_puts(string):  *	ip_puts:		put string to (interpress) output  *& add strlen(string) to out_offset  *  ****************************************************************/
end_comment

begin_macro
name|ip_puts
argument_list|(
argument|string
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|string
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
operator|(
name|output
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|ipwrite_flag
operator|==
name|FLAG_ON
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|output
argument_list|,
name|string
argument_list|)
expr_stmt|;
name|out_offset
operator|=
name|out_offset
operator|+
name|strlen
argument_list|(
name|string
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/****************************************************************  *  *	char *itostr(ival):  *	char *itostr:		cvt int to ascii string; return ptr  *  ****************************************************************/
end_comment

begin_function
name|char
modifier|*
name|itostr
parameter_list|(
name|ival
parameter_list|)
name|int
name|ival
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|digit
decl_stmt|,
name|digit_flag
decl_stmt|;
name|char
name|num_buf
index|[
literal|17
index|]
decl_stmt|,
modifier|*
name|s
decl_stmt|;
name|s
operator|=
name|num_buf
expr_stmt|;
name|digit_flag
operator|=
name|FLAG_OFF
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|10000
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|=
name|i
operator|/
literal|10
control|)
block|{
name|digit
operator|=
name|ival
operator|/
name|i
expr_stmt|;
if|if
condition|(
operator|(
name|digit
operator|==
literal|0
operator|)
operator|&&
operator|(
name|digit_flag
operator|==
name|FLAG_OFF
operator|)
operator|&&
operator|(
name|i
operator|>
literal|1
operator|)
condition|)
empty_stmt|;
comment|/* do nothing */
else|else
block|{
operator|*
name|s
operator|=
name|digit
operator|+
literal|'0'
expr_stmt|;
operator|++
name|s
expr_stmt|;
name|ival
operator|=
name|ival
operator|-
operator|(
name|digit
operator|*
name|i
operator|)
expr_stmt|;
name|digit_flag
operator|=
name|FLAG_ON
expr_stmt|;
block|}
block|}
operator|*
name|s
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
name|num_buf
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/****************************************************************  *  *	mgetc(file):  *	mgetc:		get char from input& bump  *				appropriate counters  *  ****************************************************************/
end_comment

begin_function
name|int
name|mgetc
parameter_list|(
name|file
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
block|{
name|int
name|val
decl_stmt|;
name|val
operator|=
name|getc
argument_list|(
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|feof
argument_list|(
name|file
argument_list|)
operator|)
condition|)
block|{
name|val
operator|=
name|val
operator|&
literal|0xff
expr_stmt|;
operator|++
name|in_offset
expr_stmt|;
operator|++
name|blk_num_bytes
index|[
name|block_indx
index|]
expr_stmt|;
operator|++
name|pg_num_bytes
expr_stmt|;
block|}
return|return
operator|(
name|val
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/****************************************************************  *  *	mputc_prop(ch):  *	mputc_prop:		put char to propfile  *  ****************************************************************/
end_comment

begin_macro
name|mputc_prop
argument_list|(
argument|ch
argument_list|)
end_macro

begin_block
block|{
if|if
condition|(
operator|(
name|propfile
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|ovly_flag
operator|==
name|FLAG_OFF
operator|)
condition|)
block|{
name|putc
argument_list|(
name|ch
argument_list|,
name|propfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|ch
operator|==
literal|'\n'
condition|)
name|cur_col
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/****************************************************************  *  *	int mrstrichr(str, ch):  *	int mrstrichr:	reverse srch for char in string;  *				if fnd,  *				  return its pos (indexed from 0);  *				else  *				  return (-1)  *  ****************************************************************/
end_comment

begin_function
name|int
name|mrstrichr
parameter_list|(
name|str
parameter_list|,
name|ch
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|,
name|ch
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|indx
decl_stmt|,
name|retcd
decl_stmt|;
name|retcd
operator|=
operator|(
operator|-
literal|1
operator|)
expr_stmt|;
name|indx
operator|=
name|strlen
argument_list|(
name|str
argument_list|)
operator|-
literal|1
expr_stmt|;
name|str
operator|=
name|str
operator|+
name|indx
expr_stmt|;
for|for
control|(
name|i
operator|=
name|indx
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
operator|,
name|str
operator|--
control|)
block|{
if|if
condition|(
operator|*
name|str
operator|==
name|ch
condition|)
block|{
name|retcd
operator|=
name|i
expr_stmt|;
break|break;
block|}
block|}
return|return
operator|(
name|retcd
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/****************************************************************  *  *	int mstrncmp(s1, s2, len):  *	int mstrncmp:		cmp s1 to s2 for max of len bytes  *				(byte-wise compare, left to right);  *				if *s1 != *s2,  *				  return (int)(*s1 - *s2)  *				  (i.e.,<0 if s1<s2,>0 if s1>s2)  *				else  *				  return 0  *  ****************************************************************/
end_comment

begin_function
name|int
name|mstrncmp
parameter_list|(
name|s1
parameter_list|,
name|s2
parameter_list|,
name|len
parameter_list|)
name|int
name|len
decl_stmt|;
name|char
modifier|*
name|s1
decl_stmt|,
decl|*
name|s2
decl_stmt|;
end_function

begin_block
block|{
name|int
name|i
decl_stmt|,
name|retcd
decl_stmt|;
name|retcd
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
operator|,
name|s1
operator|++
operator|,
name|s2
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|s1
operator|!=
operator|*
name|s2
condition|)
block|{
name|retcd
operator|=
call|(
name|int
call|)
argument_list|(
operator|*
name|s1
operator|-
operator|*
name|s2
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
return|return
operator|(
name|retcd
operator|)
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/****************************************************************  *  *	int mstrncpy(to, from, len):  *	int mstrncpy:		copy from -> to for len; return  *				actual # bytes copied (will be  *< len if<from> is null-terminated  *				shorter than len);  *				guarantees not overwriting allocated  *				space for<to> if sizeof(to) is at  *				least len + 1 (i.e., if len =  *				sizeof(to) - 1;  *				destination<to> is always null-  *				terminated  *  ****************************************************************/
end_comment

begin_function
name|int
name|mstrncpy
parameter_list|(
name|to
parameter_list|,
name|from
parameter_list|,
name|len
parameter_list|)
name|int
name|len
decl_stmt|;
name|char
modifier|*
name|to
decl_stmt|,
decl|*
name|from
decl_stmt|;
end_function

begin_block
block|{
name|int
name|cnt
decl_stmt|;
name|cnt
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|len
operator|--
operator|>
literal|0
operator|)
operator|&&
operator|(
operator|*
name|from
operator|!=
literal|'\0'
operator|)
condition|)
block|{
operator|*
name|to
operator|++
operator|=
operator|*
name|from
operator|++
expr_stmt|;
operator|++
name|cnt
expr_stmt|;
block|}
operator|*
name|to
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
name|cnt
operator|)
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/****************************************************************  *  *	open_logfile(argc, argv):  *	open_logfile:		open the logfile for processing  *  ****************************************************************/
end_comment

begin_macro
name|open_logfile
argument_list|(
argument|argc
argument_list|,
argument|argv
argument_list|)
end_macro

begin_decl_stmt
name|int
name|argc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|argv
index|[]
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|i
decl_stmt|;
name|_fmode
operator|=
name|TEXT_FILE
expr_stmt|;
name|logfile
operator|=
name|fopen
argument_list|(
name|logfilename
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|logfile
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|STDERR
argument_list|,
literal|"--ipfe:  Can't open log file: %s\n"
argument_list|,
name|logfilename
argument_list|)
expr_stmt|;
operator|*
name|logfilename
operator|=
literal|'\0'
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|STDERR
argument_list|,
literal|"--ipfe:  Log file: %s is open\n"
argument_list|,
name|logfilename
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|logfile
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
name|fprintf
argument_list|(
name|logfile
argument_list|,
literal|"%s "
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|logfile
argument_list|,
literal|"\n\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/****************************************************************  *  *	open_output:		open the output for processing  *  ****************************************************************/
end_comment

begin_macro
name|open_output
argument_list|()
end_macro

begin_block
block|{
name|char
name|msg
index|[
literal|128
index|]
decl_stmt|;
name|_fmode
operator|=
name|BINARY_FILE
expr_stmt|;
name|output
operator|=
name|fopen
argument_list|(
name|outputname
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|output
operator|==
name|NULL
condition|)
block|{
name|terrno
operator|=
name|errno
expr_stmt|;
comment|/* save errno */
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|msg
argument_list|,
literal|"--ipfe:  Error opening output file: %s, retcd=%d\n"
argument_list|,
name|outputname
argument_list|,
name|errno
argument_list|)
expr_stmt|;
name|pip_error
argument_list|(
name|msg
argument_list|)
expr_stmt|;
name|errno
operator|=
name|terrno
expr_stmt|;
name|exit
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/****************************************************************  *  *	open_propfile:	open the properties file for processing  *  ****************************************************************/
end_comment

begin_macro
name|open_propfile
argument_list|()
end_macro

begin_block
block|{
name|char
name|msg
index|[
literal|128
index|]
decl_stmt|;
name|_fmode
operator|=
name|TEXT_FILE
expr_stmt|;
if|if
condition|(
name|propfname
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|prop_fname
argument_list|,
name|input_fnm
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|prop_fname
argument_list|,
literal|".prop"
argument_list|)
expr_stmt|;
name|propfname
operator|=
name|prop_fname
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|msg
argument_list|,
literal|"--ipfe:  No properties filename specified. Using: %s\n"
argument_list|,
name|propfname
argument_list|)
expr_stmt|;
name|pip_error
argument_list|(
name|msg
argument_list|)
expr_stmt|;
block|}
name|propfile
operator|=
name|fopen
argument_list|(
name|propfname
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|propfile
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|msg
argument_list|,
literal|"--ipfe:  Can't open properties file: %s\n"
argument_list|,
name|propfname
argument_list|)
expr_stmt|;
name|pip_error
argument_list|(
name|msg
argument_list|)
expr_stmt|;
operator|*
name|propfname
operator|=
literal|'\0'
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|msg
argument_list|,
literal|"--ipfe:  Properties file: %s is open\n"
argument_list|,
name|propfname
argument_list|)
expr_stmt|;
name|pip_error
argument_list|(
name|msg
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/****************************************************************  *  *	char *op_name(op):  *	char *op_name:	check op_names[] table of op_code  *				name strings for non-null entry;  *				if non_null,  *				  return ptr to the string,  *				else,  *				  return ptr to string  *				  "--Unknown op:<op>"  *  ****************************************************************/
end_comment

begin_function
name|char
modifier|*
name|op_name
parameter_list|(
name|op
parameter_list|)
name|int
name|op
decl_stmt|;
block|{
name|char
name|buf
index|[
literal|20
index|]
decl_stmt|;
if|if
condition|(
name|op_names
index|[
name|op
index|]
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"--Unknown op: %d --"
argument_list|,
name|op
argument_list|)
expr_stmt|;
return|return
operator|(
name|buf
operator|)
return|;
block|}
else|else
return|return
operator|(
name|op_names
index|[
name|op
index|]
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/****************************************************************  *  *	pip_error(msg):  *	pip_error:		put error msg to stdout& logfile  *  ****************************************************************/
end_comment

begin_macro
name|pip_error
argument_list|(
argument|msg
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|msg
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|proc_flag
index|[
name|QUIET
index|]
operator|!=
name|FLAG_ON
condition|)
name|fprintf
argument_list|(
name|STDERR
argument_list|,
name|msg
argument_list|)
expr_stmt|;
if|if
condition|(
name|logfile
operator|!=
name|NULL
condition|)
name|fprintf
argument_list|(
name|logfile
argument_list|,
name|msg
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/****************************************************************  *  *	pip_prop(msg):  *	pip_prop:		put msg to propfile  *  ****************************************************************/
end_comment

begin_macro
name|pip_prop
argument_list|(
argument|msg
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|msg
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
operator|(
name|propfile
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|ovly_flag
operator|==
name|FLAG_OFF
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|propfile
argument_list|,
name|msg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
operator|(
name|msg
operator|+
name|strlen
argument_list|(
name|msg
argument_list|)
operator|-
literal|1
operator|)
operator|==
literal|'\n'
condition|)
name|cur_col
operator|=
literal|0
expr_stmt|;
else|else
name|cur_col
operator|=
name|cur_col
operator|+
name|strlen
argument_list|(
name|msg
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/****************************************************************  *  *	preserve_SIF_copy(type_byte, length, file, filename):  *	preserve_SIF_copy:	preserve SIF reference by copying  *				from specified input file to output  *  ****************************************************************/
end_comment

begin_macro
name|copy_preserve_SIF
argument_list|(
argument|type_byte
argument_list|,
argument|length
argument_list|,
argument|file
argument_list|,
argument|filename
argument_list|)
end_macro

begin_decl_stmt
name|FILE
modifier|*
name|file
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|long
name|length
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|type_byte
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|filename
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|put_seq_type_len
argument_list|(
name|type_byte
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|iocopyn
argument_list|(
name|length
argument_list|,
name|file
argument_list|,
name|filename
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/****************************************************************  *  *	preserve_SIF_put(type_byte, length, buf):  *	preserve_SIF_put:	preserve SIF reference by copying  *				from specified buffer to output  *  ****************************************************************/
end_comment

begin_macro
name|put_preserve_SIF
argument_list|(
argument|type_byte
argument_list|,
argument|length
argument_list|,
argument|buf
argument_list|)
end_macro

begin_decl_stmt
name|long
name|length
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|type_byte
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|buf
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|put_seq_type_len
argument_list|(
name|type_byte
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|ioputn
argument_list|(
name|length
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/****************************************************************  *  *	proc_alias(alias_string):  *	proc_alias:		process alias argument  *  ****************************************************************/
end_comment

begin_macro
name|proc_alias
argument_list|(
argument|alias_string
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|alias_string
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|indx
decl_stmt|,
name|len
decl_stmt|;
name|char
name|msg
index|[
literal|128
index|]
decl_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|alias_string
argument_list|)
expr_stmt|;
name|indx
operator|=
name|mrstrichr
argument_list|(
name|alias_string
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|indx
operator|>
literal|0
operator|)
operator|&&
operator|(
name|indx
operator|<
operator|(
name|len
operator|-
literal|1
operator|)
operator|)
condition|)
comment|/* past beg& before end */
block|{
operator|(
name|void
operator|)
name|mstrncpy
argument_list|(
name|alias_ref
index|[
name|alias_indx
index|]
argument_list|,
name|alias_string
argument_list|,
name|indx
argument_list|)
expr_stmt|;
operator|++
name|indx
expr_stmt|;
operator|(
name|void
operator|)
name|mstrncpy
argument_list|(
name|alias_act
index|[
name|alias_indx
index|]
argument_list|,
operator|(
name|alias_string
operator|+
name|indx
operator|)
argument_list|,
operator|(
name|len
operator|-
name|indx
operator|)
argument_list|)
expr_stmt|;
operator|++
name|alias_indx
expr_stmt|;
operator|++
name|num_aliases
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|msg
argument_list|,
literal|"--ipfe:  *** warning -- invalid alias specification (%s)\n"
argument_list|,
name|alias_string
argument_list|)
expr_stmt|;
name|pip_error
argument_list|(
name|msg
argument_list|)
expr_stmt|;
name|exit_status
operator|=
literal|4
expr_stmt|;
block|}
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/****************************************************************  *  *	proc_chapterize:	test for& process chapterizing  *  ****************************************************************/
end_comment

begin_macro
name|proc_chapterize
argument_list|()
end_macro

begin_block
block|{
name|long
name|len
decl_stmt|,
name|temp_end_offset
decl_stmt|;
name|int
name|i
decl_stmt|,
name|op
decl_stmt|,
name|terrno
decl_stmt|,
name|tblock_indx
decl_stmt|,
name|proc_op_flag
decl_stmt|,
name|eof_flag
decl_stmt|,
name|proc_type
decl_stmt|;
name|int
name|type_byte
decl_stmt|;
comment|/* must be int for stdio EOF */
name|char
name|msg
index|[
literal|128
index|]
decl_stmt|;
if|if
condition|(
operator|(
name|proc_flag
index|[
name|CHAPTERIZE
index|]
operator|==
name|FLAG_ON
operator|)
operator|&&
operator|(
operator|(
operator|(
name|chap_type
operator|==
name|CH_PAGES
operator|)
operator|&&
operator|(
name|out_numpages
operator|==
name|chap_val
operator|)
operator|)
operator|||
operator|(
operator|(
operator|(
name|chap_type
operator|==
name|CH_KBYTES
operator|)
operator|||
operator|(
name|chap_type
operator|==
name|CH_MBYTES
operator|)
operator|)
operator|&&
operator|(
name|out_offset
operator|>=
name|chap_val
operator|)
operator|)
operator|)
condition|)
block|{
comment|/*  *  Eventually, the next two lines should be rewritten to check to see  *  if we might somehow be nested in a body before putting the  *  OP_endblock(s)  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|block_indx
condition|;
name|i
operator|++
control|)
name|put_op
argument_list|(
name|OP_endBlock
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|output
argument_list|)
expr_stmt|;
comment|/*  *  Now, check for OP_endBlock(s) appearing immediately in the input  *  file. If so, skip them: they were already put out above. In looking,  *  if we get an EOF and there are no more input files, don't open a  *  new output file.  */
name|proc_op_flag
operator|=
name|eof_flag
operator|=
name|FLAG_OFF
expr_stmt|;
name|tblock_indx
operator|=
name|block_indx
expr_stmt|;
comment|/* because the actual block_indx can 					     be dcr'd in the loop */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|tblock_indx
condition|;
name|i
operator|++
control|)
block|{
name|type_byte
operator|=
name|mgetc
argument_list|(
name|input
argument_list|)
expr_stmt|;
if|if
condition|(
name|feof
argument_list|(
name|input
argument_list|)
condition|)
block|{
comment|/*  *  set eof_flag only if there are no more input files  */
if|if
condition|(
name|input_indx
operator|>=
operator|(
name|num_infiles
operator|-
literal|1
operator|)
condition|)
name|eof_flag
operator|=
name|FLAG_ON
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
operator|(
name|type_byte
operator|&
name|OP_Mask
operator|)
operator|==
operator|(
name|LONG_OP
operator|&
name|OP_Mask
operator|)
condition|)
block|{
name|op
operator|=
operator|(
operator|(
name|type_byte
operator|&
literal|0x1f
operator|)
operator|<<
literal|8
operator|)
operator|+
name|getc_testeof
argument_list|(
name|input
argument_list|,
name|inputname
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|op
operator|==
name|OP_endBlock
operator|)
operator|&&
operator|(
name|i
operator|<
name|block_indx
operator|)
condition|)
operator|--
name|block_indx
expr_stmt|;
else|else
block|{
name|proc_op_flag
operator|=
name|FLAG_ON
expr_stmt|;
comment|/* set flag for use below */
name|proc_type
operator|=
name|LONG_OP
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
name|proc_op_flag
operator|=
name|FLAG_ON
expr_stmt|;
comment|/* set flag for use below */
name|proc_type
operator|=
operator|~
operator|(
name|LONG_OP
operator|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|eof_flag
operator|==
name|FLAG_OFF
condition|)
block|{
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|work_fname
argument_list|,
name|outputname
argument_list|)
expr_stmt|;
name|workfile
operator|=
name|fopen
argument_list|(
name|work_fname
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|workfile
operator|==
name|NULL
condition|)
block|{
name|terrno
operator|=
name|errno
expr_stmt|;
comment|/* save errno */
name|pip_error
argument_list|(
literal|"Chapterize error opening previous output file as input\n"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|msg
argument_list|,
literal|"  file=%s, retcd=%d\n"
argument_list|,
name|outputname
argument_list|,
name|errno
argument_list|)
expr_stmt|;
name|pip_error
argument_list|(
name|msg
argument_list|)
expr_stmt|;
name|pip_error
argument_list|(
literal|"  Can't complete chapterization --\n\n"
argument_list|)
expr_stmt|;
name|pip_error
argument_list|(
literal|"  *** ABORTING ***\n"
argument_list|)
expr_stmt|;
name|errno
operator|=
name|terrno
expr_stmt|;
name|exit
argument_list|(
literal|3
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|++
name|out_filnum
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|output_name
argument_list|,
name|output_fnm
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|output_name
argument_list|,
name|itostr
argument_list|(
name|out_filnum
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|output_name
argument_list|,
name|output_ext
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|msg
argument_list|,
literal|"--ipfe:  Processing output file: %s\n"
argument_list|,
name|outputname
argument_list|)
expr_stmt|;
name|pip_error
argument_list|(
name|msg
argument_list|)
expr_stmt|;
name|_fmode
operator|=
name|BINARY_FILE
expr_stmt|;
name|output
operator|=
name|fopen
argument_list|(
name|outputname
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|output
operator|==
name|NULL
condition|)
block|{
name|terrno
operator|=
name|errno
expr_stmt|;
comment|/* save errno */
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|msg
argument_list|,
literal|"--ipfe:  Error opening output file=%s, retcd=%d\n"
argument_list|,
name|outputname
argument_list|,
name|errno
argument_list|)
expr_stmt|;
name|pip_error
argument_list|(
name|msg
argument_list|)
expr_stmt|;
name|errno
operator|=
name|terrno
expr_stmt|;
name|exit
argument_list|(
literal|4
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/*  *  Then, copy Hdr& BEGIN/Preamble(s) to new output  */
name|out_numpages
operator|=
literal|0
expr_stmt|;
name|out_offset
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|block_indx
condition|;
name|i
operator|++
control|)
block|{
name|len
operator|=
name|out_end_offset
index|[
name|i
index|]
operator|-
name|out_beg_offset
index|[
name|i
index|]
operator|+
literal|1
expr_stmt|;
name|out_beg_offset
index|[
name|i
index|]
operator|=
name|out_offset
expr_stmt|;
name|iocopyn
argument_list|(
name|len
argument_list|,
name|workfile
argument_list|,
name|work_fname
argument_list|)
expr_stmt|;
name|temp_end_offset
operator|=
name|out_end_offset
index|[
name|i
index|]
expr_stmt|;
name|out_end_offset
index|[
name|i
index|]
operator|=
name|out_offset
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|i
operator|<
name|block_indx
condition|)
comment|/* if there is more to do */
block|{
name|len
operator|=
name|out_beg_offset
index|[
name|i
operator|+
literal|1
index|]
operator|-
name|temp_end_offset
operator|-
literal|1
expr_stmt|;
name|ioreadn
argument_list|(
name|len
argument_list|,
name|workfile
argument_list|,
name|work_fname
argument_list|)
expr_stmt|;
block|}
block|}
block|}
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|workfile
argument_list|)
expr_stmt|;
comment|/*  *  Finally, if a token other than OP_endBlock token was read above,  *  process it  */
if|if
condition|(
name|proc_op_flag
operator|==
name|FLAG_ON
condition|)
block|{
if|if
condition|(
name|proc_type
operator|==
name|LONG_OP
condition|)
name|proc_long_op
argument_list|(
name|op
argument_list|)
expr_stmt|;
else|else
name|proc_ip_token
argument_list|(
name|type_byte
argument_list|,
name|input
argument_list|,
name|inputname
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/****************************************************************  *  *	proc_file:		process the input file  *  ****************************************************************/
end_comment

begin_macro
name|proc_file
argument_list|()
end_macro

begin_block
block|{
name|long
name|offset
decl_stmt|;
name|int
name|i
decl_stmt|,
name|op
decl_stmt|,
name|retcd
decl_stmt|,
name|exit_flag
decl_stmt|;
name|int
name|type_byte
decl_stmt|;
comment|/* must be int for stdio EOF */
name|char
name|msg
index|[
literal|128
index|]
decl_stmt|;
if|if
condition|(
name|setjmp
argument_list|(
name|next_file
argument_list|)
operator|!=
literal|0
condition|)
comment|/* for error recovery of */
block|{
comment|/*   unexpected EOF      */
return|return;
block|}
name|offset
operator|=
name|in_offset
expr_stmt|;
name|retcd
operator|=
name|get_ip_hdr
argument_list|(
name|input
argument_list|,
name|inputname
argument_list|)
expr_stmt|;
comment|/* get the hdr */
if|if
condition|(
name|retcd
operator|==
name|OK
condition|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|msg
argument_list|,
literal|"-- Hdr :  %s--\n"
argument_list|,
name|hdr_workbuf
argument_list|)
expr_stmt|;
name|pip_error
argument_list|(
name|msg
argument_list|)
expr_stmt|;
name|mputc_prop
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|put_offset_msg_to_prop
argument_list|(
name|offset
argument_list|,
name|hdr_workbuf
argument_list|)
expr_stmt|;
name|pip_prop
argument_list|(
literal|"--\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|input_indx
operator|==
literal|0
condition|)
comment|/* if 1st file,   */
block|{
if|if
condition|(
name|proc_flag
index|[
name|CONCAT
index|]
operator|==
name|FLAG_ON
condition|)
operator|(
name|void
operator|)
name|strcpy
argument_list|(
operator|(
name|hdr_workbuf
operator|+
name|IP_VERS_OFFSET
operator|)
argument_list|,
literal|"2.1 "
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|hdr_buf
argument_list|,
name|hdr_workbuf
argument_list|)
expr_stmt|;
comment|/* save hdr */
if|if
condition|(
name|output
operator|!=
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|msg
argument_list|,
literal|"\nProcessing output file: %s\n"
argument_list|,
name|outputname
argument_list|)
expr_stmt|;
name|pip_error
argument_list|(
name|msg
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|msg
argument_list|,
literal|"-- Output Hdr:  %s--\n"
argument_list|,
name|hdr_workbuf
argument_list|)
expr_stmt|;
name|pip_error
argument_list|(
name|msg
argument_list|)
expr_stmt|;
name|ip_puts
argument_list|(
name|hdr_workbuf
argument_list|)
expr_stmt|;
comment|/* copy hdr& add len to 						   out_offset */
block|}
comment|/*  *  copy everything up to, but NOT including (will include later),  *    OP_beginBlock  */
name|exit_flag
operator|=
name|FLAG_OFF
expr_stmt|;
while|while
condition|(
name|exit_flag
operator|==
name|FLAG_OFF
condition|)
block|{
name|type_byte
operator|=
name|getc_testeof
argument_list|(
name|input
argument_list|,
name|inputname
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|type_byte
operator|&
name|OP_Mask
operator|)
operator|==
operator|(
name|LONG_OP
operator|&
name|OP_Mask
operator|)
condition|)
block|{
name|op
operator|=
operator|(
operator|(
name|type_byte
operator|&
literal|0x1f
operator|)
operator|<<
literal|8
operator|)
operator|+
name|getc_testeof
argument_list|(
name|input
argument_list|,
name|inputname
argument_list|)
expr_stmt|;
if|if
condition|(
name|op
operator|==
name|OP_beginBlock
condition|)
name|exit_flag
operator|=
name|FLAG_ON
expr_stmt|;
else|else
block|{
name|ip_putc
argument_list|(
name|type_byte
argument_list|)
expr_stmt|;
name|ip_putc
argument_list|(
name|op
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|proc_ip_token
argument_list|(
name|type_byte
argument_list|,
name|input
argument_list|,
name|inputname
argument_list|)
expr_stmt|;
block|}
name|out_end_offset
index|[
literal|0
index|]
operator|=
name|out_offset
operator|-
literal|1
expr_stmt|;
comment|/*  *  if concatenating, wrap a BEGIN empty_preamble END after the hdr&  *    instructionsBody and around the rest of the output  */
if|if
condition|(
name|proc_flag
index|[
name|CONCAT
index|]
operator|==
name|FLAG_ON
condition|)
block|{
operator|++
name|block_indx
expr_stmt|;
name|out_beg_offset
index|[
name|block_indx
index|]
operator|=
name|out_offset
expr_stmt|;
name|put_op
argument_list|(
name|OP_beginBlock
argument_list|)
expr_stmt|;
name|put_op
argument_list|(
name|OP_beginBody
argument_list|)
expr_stmt|;
name|put_op
argument_list|(
name|OP_endBody
argument_list|)
expr_stmt|;
name|out_end_offset
index|[
name|block_indx
index|]
operator|=
name|out_offset
operator|-
literal|1
expr_stmt|;
block|}
comment|/*  *  NOW include the OP_beginBlock,& process the rest of the master  */
name|proc_long_op
argument_list|(
name|OP_beginBlock
argument_list|)
expr_stmt|;
block|}
name|prc_ip_tokens
argument_list|(
name|input
argument_list|,
name|inputname
argument_list|)
expr_stmt|;
name|mputc_prop
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|indent
argument_list|(
name|off_indent
argument_list|,
name|propfile
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|msg
argument_list|,
literal|"--Number of Blocks:%4d\n"
argument_list|,
name|num_blocks
argument_list|)
expr_stmt|;
name|pip_prop
argument_list|(
name|msg
argument_list|)
expr_stmt|;
name|indent
argument_list|(
name|off_indent
argument_list|,
name|propfile
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|msg
argument_list|,
literal|"--Number of Pages :%4d\n"
argument_list|,
name|num_pages
argument_list|)
expr_stmt|;
name|pip_prop
argument_list|(
name|msg
argument_list|)
expr_stmt|;
name|indent
argument_list|(
name|off_indent
argument_list|,
name|propfile
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|msg
argument_list|,
literal|"--Number of SIFs  :%4d\n"
argument_list|,
name|num_sifs
argument_list|)
expr_stmt|;
name|pip_prop
argument_list|(
name|msg
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|merge_pg
index|[
name|input_indx
index|]
index|[
name|i
index|]
operator|!=
literal|0
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|merge_pg
index|[
name|input_indx
index|]
index|[
name|i
index|]
operator|>
name|num_pages
condition|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|msg
argument_list|,
literal|"\n--ipfe:  *** Page %d selected> # of pages in %s (%d)\n"
argument_list|,
name|merge_pg
index|[
name|input_indx
index|]
index|[
name|i
index|]
argument_list|,
name|inputname
argument_list|,
name|num_pages
argument_list|)
expr_stmt|;
name|pip_error
argument_list|(
name|msg
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
comment|/*** 	else 	{ 	    (void)sprintf(msg, "(***  PROCESSING ABORTED  ***)\n"); 	    pip_error(msg); 	    input_indx = num_infiles; 	    abort_flag = FLAG_ON; 	} ***/
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/****************************************************************  *  *	prc_IF_bof(ifile, ifilename):  *	prc_IF_bof:		read specified Interpress file&  *				discard everything up to, and  *				including, first OP_beginBlock  *  ****************************************************************/
end_comment

begin_macro
name|prc_IF_bof
argument_list|(
argument|ifile
argument_list|,
argument|ifilename
argument_list|)
end_macro

begin_decl_stmt
name|FILE
modifier|*
name|ifile
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|ifilename
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|op
decl_stmt|,
name|exit_flag
decl_stmt|;
name|int
name|type_byte
decl_stmt|;
comment|/* must be int for stdio EOF */
name|exit_flag
operator|=
name|FLAG_OFF
expr_stmt|;
while|while
condition|(
name|exit_flag
operator|==
name|FLAG_OFF
condition|)
block|{
name|type_byte
operator|=
name|getc_testeof
argument_list|(
name|ifile
argument_list|,
name|ifilename
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|type_byte
operator|&
name|OP_Mask
operator|)
operator|==
operator|(
name|LONG_OP
operator|&
name|OP_Mask
operator|)
condition|)
block|{
name|op
operator|=
operator|(
operator|(
name|type_byte
operator|&
literal|0x1f
operator|)
operator|<<
literal|8
operator|)
operator|+
name|getc_testeof
argument_list|(
name|ifile
argument_list|,
name|ifilename
argument_list|)
expr_stmt|;
if|if
condition|(
name|op
operator|==
name|OP_beginBlock
condition|)
name|exit_flag
operator|=
name|FLAG_ON
expr_stmt|;
block|}
block|}
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/****************************************************************  *  *	prc_IF_fragment(ifile, ifilename):  *	prc_IF_fragment:	process specified Interpress fragment  *				(i.e., skip everything up to, and  *				 including the first OP_beginBlock;  *				 then include everything up to, but  *				 not including, the next OP_endBlock)  *  ****************************************************************/
end_comment

begin_macro
name|prc_IF_fragment
argument_list|(
argument|ifile
argument_list|,
argument|ifilename
argument_list|)
end_macro

begin_decl_stmt
name|FILE
modifier|*
name|ifile
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|ifilename
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|op
decl_stmt|,
name|exit_flag
decl_stmt|;
name|int
name|type_byte
decl_stmt|;
comment|/* must be int for stdio EOF */
comment|/*  *  read& discard everything up to, and including, OP_beginBlock  */
name|prc_IF_bof
argument_list|(
name|ifile
argument_list|,
name|ifilename
argument_list|)
expr_stmt|;
comment|/*  *  read& copy everything up to, but NOT including OP_endBlock  */
name|exit_flag
operator|=
name|FLAG_OFF
expr_stmt|;
while|while
condition|(
name|exit_flag
operator|==
name|FLAG_OFF
condition|)
block|{
name|type_byte
operator|=
name|getc_testeof
argument_list|(
name|ifile
argument_list|,
name|ifilename
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|type_byte
operator|&
name|OP_Mask
operator|)
operator|==
operator|(
name|LONG_OP
operator|&
name|OP_Mask
operator|)
condition|)
block|{
name|op
operator|=
operator|(
operator|(
name|type_byte
operator|&
literal|0x1f
operator|)
operator|<<
literal|8
operator|)
operator|+
name|getc_testeof
argument_list|(
name|ifile
argument_list|,
name|ifilename
argument_list|)
expr_stmt|;
if|if
condition|(
name|op
operator|==
name|OP_endBlock
condition|)
name|exit_flag
operator|=
name|FLAG_ON
expr_stmt|;
else|else
name|put_op
argument_list|(
name|op
argument_list|)
expr_stmt|;
block|}
else|else
name|proc_ip_token
argument_list|(
name|type_byte
argument_list|,
name|ifile
argument_list|,
name|ifilename
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/****************************************************************  *  *	prc_IF_master(ifile, ifilename, pg):  *	prc_IF_master:	process specified page of the  *				specified Interpress master  *				(i.e., skip everything up to, and  *				 including the first OP_beginBlock;  *				 then include the contents of the  *				 preamble and the specified page,  *				 without including the body tokens)  *  ****************************************************************/
end_comment

begin_macro
name|prc_IF_master
argument_list|(
argument|ifile
argument_list|,
argument|ifilename
argument_list|,
argument|pg
argument_list|)
end_macro

begin_decl_stmt
name|FILE
modifier|*
name|ifile
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|pg
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|ifilename
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|op
decl_stmt|,
name|exit_flag
decl_stmt|,
name|wrt_flag
decl_stmt|,
name|blk_indx
decl_stmt|,
name|pg_cnt
decl_stmt|;
name|int
name|level
index|[
name|MX_BLOCK_DEPTH
index|]
decl_stmt|,
name|ctr
index|[
name|MX_BLOCK_DEPTH
index|]
decl_stmt|;
name|int
name|type_byte
decl_stmt|;
comment|/* must be int for stdio EOF */
comment|/*  *  read& discard everything up to, and including, OP_beginBlock  */
name|prc_IF_bof
argument_list|(
name|ifile
argument_list|,
name|ifilename
argument_list|)
expr_stmt|;
comment|/*  *  read& copy the contents of the preamble; then, copy only the  *  contents of the specified page  */
name|blk_indx
operator|=
name|pg_cnt
operator|=
literal|0
expr_stmt|;
name|level
index|[
name|blk_indx
index|]
operator|=
name|ctr
index|[
name|blk_indx
index|]
operator|=
literal|0
expr_stmt|;
name|wrt_flag
operator|=
name|FLAG_OFF
expr_stmt|;
name|exit_flag
operator|=
name|FLAG_OFF
expr_stmt|;
while|while
condition|(
name|exit_flag
operator|==
name|FLAG_OFF
condition|)
block|{
name|type_byte
operator|=
name|getc_testeof
argument_list|(
name|ifile
argument_list|,
name|ifilename
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|type_byte
operator|&
name|OP_Mask
operator|)
operator|==
operator|(
name|LONG_OP
operator|&
name|OP_Mask
operator|)
condition|)
block|{
name|op
operator|=
operator|(
operator|(
name|type_byte
operator|&
literal|0x1f
operator|)
operator|<<
literal|8
operator|)
operator|+
name|getc_testeof
argument_list|(
name|ifile
argument_list|,
name|ifilename
argument_list|)
expr_stmt|;
if|if
condition|(
name|op
operator|==
name|OP_beginBlock
condition|)
block|{
operator|++
name|blk_indx
expr_stmt|;
name|level
index|[
name|blk_indx
index|]
operator|=
name|ctr
index|[
name|blk_indx
index|]
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|op
operator|==
name|OP_endBlock
condition|)
block|{
if|if
condition|(
name|blk_indx
operator|>
literal|0
condition|)
operator|--
name|blk_indx
expr_stmt|;
else|else
name|exit_flag
operator|=
name|FLAG_ON
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|op
operator|==
name|OP_beginBody
condition|)
block|{
if|if
condition|(
name|level
index|[
name|blk_indx
index|]
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|ctr
index|[
name|blk_indx
index|]
operator|==
literal|0
condition|)
name|wrt_flag
operator|=
name|FLAG_ON
expr_stmt|;
comment|/* processing preamble */
else|else
block|{
operator|++
name|pg_cnt
expr_stmt|;
if|if
condition|(
name|pg
operator|==
name|pg_cnt
condition|)
name|wrt_flag
operator|=
name|FLAG_ON
expr_stmt|;
comment|/* got the right pg */
block|}
operator|++
name|ctr
index|[
name|blk_indx
index|]
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|wrt_flag
operator|==
name|FLAG_ON
condition|)
name|put_op
argument_list|(
name|op
argument_list|)
expr_stmt|;
operator|++
name|level
index|[
name|blk_indx
index|]
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|op
operator|==
name|OP_endBody
condition|)
block|{
operator|--
name|level
index|[
name|blk_indx
index|]
expr_stmt|;
if|if
condition|(
name|level
index|[
name|blk_indx
index|]
operator|==
literal|0
condition|)
block|{
name|wrt_flag
operator|=
name|FLAG_OFF
expr_stmt|;
if|if
condition|(
name|pg
operator|==
name|pg_cnt
condition|)
name|exit_flag
operator|=
name|FLAG_ON
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|wrt_flag
operator|==
name|FLAG_ON
condition|)
name|put_op
argument_list|(
name|op
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|wrt_flag
operator|==
name|FLAG_ON
condition|)
name|put_op
argument_list|(
name|op
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|wrt_flag
operator|==
name|FLAG_ON
condition|)
name|proc_ip_token
argument_list|(
name|type_byte
argument_list|,
name|ifile
argument_list|,
name|ifilename
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/****************************************************************  *  *	proc_ip_token(type_byte, file, filename):  *	proc_ip_token:	process interpress token of specified  *				type from specified file  *  ****************************************************************/
end_comment

begin_macro
name|proc_ip_token
argument_list|(
argument|type_byte
argument_list|,
argument|file
argument_list|,
argument|filename
argument_list|)
end_macro

begin_decl_stmt
name|FILE
modifier|*
name|file
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|type_byte
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|filename
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|long
name|len
decl_stmt|;
name|int
name|op
decl_stmt|;
if|if
condition|(
name|type_byte
operator|!=
name|EOF
condition|)
block|{
if|if
condition|(
operator|(
name|type_byte
operator|&
literal|0x80
operator|)
operator|==
literal|0
condition|)
comment|/* token is a SHORT NUMBER */
block|{
name|ip_putc
argument_list|(
name|type_byte
argument_list|)
expr_stmt|;
comment|/* 2-byte token */
name|ip_putc
argument_list|(
name|getc_testeof
argument_list|(
name|file
argument_list|,
name|filename
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* token is something else */
block|{
switch|switch
condition|(
name|type_byte
operator|&
name|OP_Mask
condition|)
block|{
case|case
operator|(
name|SHORT_OP
operator|&
name|OP_Mask
operator|)
case|:
name|ip_putc
argument_list|(
name|type_byte
argument_list|)
expr_stmt|;
comment|/* 1-byte token */
break|break;
case|case
operator|(
name|LONG_OP
operator|&
name|OP_Mask
operator|)
case|:
name|op
operator|=
operator|(
operator|(
name|type_byte
operator|&
literal|0x1f
operator|)
operator|<<
literal|8
operator|)
operator|+
name|getc_testeof
argument_list|(
name|file
argument_list|,
name|filename
argument_list|)
expr_stmt|;
comment|/* 2-byte token */
name|proc_long_op
argument_list|(
name|op
argument_list|)
expr_stmt|;
break|break;
case|case
operator|(
name|SHORT_SEQUENCE
operator|&
name|OP_Mask
operator|)
case|:
name|len
operator|=
name|getc_testeof
argument_list|(
name|file
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|proc_sequence
argument_list|(
name|type_byte
argument_list|,
name|len
argument_list|,
name|file
argument_list|,
name|filename
argument_list|)
expr_stmt|;
break|break;
case|case
operator|(
name|LONG_SEQUENCE
operator|&
name|OP_Mask
operator|)
case|:
name|len
operator|=
name|getc_testeof
argument_list|(
name|file
argument_list|,
name|filename
argument_list|)
operator|<<
literal|16
expr_stmt|;
name|len
operator|=
name|len
operator|+
operator|(
name|getc_testeof
argument_list|(
name|file
argument_list|,
name|filename
argument_list|)
operator|<<
literal|8
operator|)
expr_stmt|;
name|len
operator|=
name|len
operator|+
name|getc_testeof
argument_list|(
name|file
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|proc_sequence
argument_list|(
name|type_byte
argument_list|,
name|len
argument_list|,
name|file
argument_list|,
name|filename
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/****************************************************************  *  *	prc_ip_tokens(file, filename):  *	prc_ip_tokens:	process interpress tokens  *				specified file  *  ****************************************************************/
end_comment

begin_macro
name|prc_ip_tokens
argument_list|(
argument|file
argument_list|,
argument|filename
argument_list|)
end_macro

begin_decl_stmt
name|FILE
modifier|*
name|file
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|filename
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|type_byte
decl_stmt|;
comment|/* must be int for stdio EOF */
while|while
condition|(
operator|(
name|type_byte
operator|=
name|mgetc
argument_list|(
name|file
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
block|{
name|proc_ip_token
argument_list|(
name|type_byte
argument_list|,
name|file
argument_list|,
name|filename
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/****************************************************************  *  *	proc_long_op(op):  *	proc_long_op:		process long_op  *  ****************************************************************/
end_comment

begin_macro
name|proc_long_op
argument_list|(
argument|op
argument_list|)
end_macro

begin_decl_stmt
name|int
name|op
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|long
name|val
decl_stmt|;
name|int
name|i
decl_stmt|,
name|nesting_level
decl_stmt|;
switch|switch
condition|(
name|op
condition|)
block|{
case|case
operator|(
name|OP_beginBlock
operator|)
case|:
name|put_op
argument_list|(
name|op
argument_list|)
expr_stmt|;
operator|++
name|num_blocks
expr_stmt|;
operator|++
name|tnum_blocks
expr_stmt|;
if|if
condition|(
name|block_indx
operator|==
literal|0
condition|)
name|out_end_offset
index|[
name|block_indx
index|]
operator|=
name|out_offset
operator|-
literal|3
expr_stmt|;
operator|++
name|block_indx
expr_stmt|;
name|out_beg_offset
index|[
name|block_indx
index|]
operator|=
name|out_offset
operator|-
literal|2
expr_stmt|;
name|blk_num_bytes
index|[
name|block_indx
index|]
operator|=
literal|2
expr_stmt|;
name|put_opname_to_prop
argument_list|(
name|op
argument_list|)
expr_stmt|;
name|preamble_expected
operator|=
name|FLAG_ON
expr_stmt|;
break|break;
case|case
operator|(
name|OP_endBlock
operator|)
case|:
name|put_op
argument_list|(
name|op
argument_list|)
expr_stmt|;
name|put_opname_to_prop
argument_list|(
name|op
argument_list|)
expr_stmt|;
operator|--
name|block_indx
expr_stmt|;
break|break;
case|case
operator|(
name|OP_beginBody
operator|)
case|:
name|put_opname_to_prop
argument_list|(
name|op
argument_list|)
expr_stmt|;
if|if
condition|(
name|preamble_expected
operator|==
name|FLAG_ON
condition|)
block|{
name|put_op
argument_list|(
name|op
argument_list|)
expr_stmt|;
name|preamble_expected
operator|=
name|FLAG_OFF
expr_stmt|;
name|endpreamble_expected
operator|=
name|FLAG_ON
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bop_flag
operator|==
name|FLAG_ON
condition|)
block|{
name|put_op
argument_list|(
name|op
argument_list|)
expr_stmt|;
if|if
condition|(
name|bop_iindx
index|[
name|bop_indx
index|]
operator|==
literal|0
condition|)
name|bop_preamble_expected
index|[
name|bop_indx
index|]
operator|=
name|FLAG_ON
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|bop_iindx
index|[
name|bop_indx
index|]
operator|==
literal|1
operator|)
operator|&&
operator|(
name|bop_preamble_expected
index|[
name|bop_indx
index|]
operator|==
name|FLAG_ON
operator|)
condition|)
name|bop_preamble_expected
index|[
name|bop_indx
index|]
operator|=
name|FLAG_OFF
expr_stmt|;
operator|++
name|bop_iindx
index|[
name|bop_indx
index|]
expr_stmt|;
block|}
else|else
comment|/* we have a righteous pageBody */
block|{
operator|++
name|num_pages
expr_stmt|;
operator|++
name|tnum_pages
expr_stmt|;
name|frstpg_flag
operator|=
name|FLAG_ON
expr_stmt|;
name|pg_num_bytes
operator|=
literal|2
expr_stmt|;
if|if
condition|(
operator|(
name|merge_pg
index|[
name|input_indx
index|]
index|[
name|merge_indx
index|]
operator|==
literal|0
operator|)
operator|||
operator|(
name|num_pages
operator|<
name|merge_pg
index|[
name|input_indx
index|]
index|[
name|merge_indx
index|]
operator|)
condition|)
name|ipwrite_flag
operator|=
name|FLAG_OFF
expr_stmt|;
else|else
block|{
name|ipwrite_flag
operator|=
name|FLAG_ON
expr_stmt|;
comment|/* it should already be on */
name|put_op
argument_list|(
name|op
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|proc_flag
index|[
name|LANDSCAPE
index|]
operator|==
name|FLAG_ON
operator|)
operator|||
operator|(
name|proc_flag
index|[
name|ROTATE
index|]
operator|==
name|FLAG_ON
operator|)
condition|)
block|{
name|put_Integer
argument_list|(
operator|(
name|long
operator|)
name|rot_deg
argument_list|)
expr_stmt|;
name|put_op
argument_list|(
name|OP_rotate
argument_list|)
expr_stmt|;
name|put_op
argument_list|(
name|OP_concatt
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|rxoff_den
operator|==
literal|0
operator|)
operator|||
operator|(
name|rxoff_den
operator|==
literal|1
operator|)
condition|)
name|put_Integer
argument_list|(
name|rxoff_num
argument_list|)
expr_stmt|;
else|else
name|put_seqRational
argument_list|(
name|rxoff_num
argument_list|,
name|rxoff_den
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ryoff_den
operator|==
literal|0
operator|)
operator|||
operator|(
name|ryoff_den
operator|==
literal|1
operator|)
condition|)
name|put_Integer
argument_list|(
name|ryoff_num
argument_list|)
expr_stmt|;
else|else
name|put_seqRational
argument_list|(
name|ryoff_num
argument_list|,
name|ryoff_den
argument_list|)
expr_stmt|;
name|put_op
argument_list|(
name|OP_translate
argument_list|)
expr_stmt|;
name|put_op
argument_list|(
name|OP_concatt
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|proc_flag
index|[
name|BINDING_OFFSET
index|]
operator|==
name|FLAG_ON
condition|)
block|{
if|if
condition|(
operator|(
name|proc_flag
index|[
name|DUPLEX
index|]
operator|==
name|FLAG_ON
operator|)
operator|&&
operator|(
operator|(
name|num_pages
operator|%
literal|2
operator|)
operator|==
literal|0
operator|)
condition|)
name|val
operator|=
operator|-
operator|(
name|boff_num
operator|)
expr_stmt|;
else|else
name|val
operator|=
name|boff_num
expr_stmt|;
if|if
condition|(
name|proc_flag
index|[
name|LANDSCAPE
index|]
operator|==
name|FLAG_ON
condition|)
block|{
name|put_Integer
argument_list|(
literal|0L
argument_list|)
expr_stmt|;
comment|/* no xShift */
if|if
condition|(
operator|(
name|boff_den
operator|==
literal|0
operator|)
operator|||
operator|(
name|boff_den
operator|==
literal|1
operator|)
condition|)
name|put_Integer
argument_list|(
operator|-
operator|(
name|val
operator|)
argument_list|)
expr_stmt|;
comment|/* -(yShift) */
else|else
name|put_seqRational
argument_list|(
operator|-
operator|(
name|val
operator|)
argument_list|,
name|boff_den
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|boff_den
operator|==
literal|0
operator|)
operator|||
operator|(
name|boff_den
operator|==
literal|1
operator|)
condition|)
name|put_Integer
argument_list|(
name|val
argument_list|)
expr_stmt|;
else|else
name|put_seqRational
argument_list|(
name|val
argument_list|,
name|boff_den
argument_list|)
expr_stmt|;
name|put_Integer
argument_list|(
literal|0L
argument_list|)
expr_stmt|;
comment|/* no yShift */
block|}
name|put_op
argument_list|(
name|OP_translate
argument_list|)
expr_stmt|;
name|put_op
argument_list|(
name|OP_concatt
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|proc_flag
index|[
name|X_OFFSET
index|]
operator|==
name|FLAG_ON
operator|)
operator|||
operator|(
name|proc_flag
index|[
name|Y_OFFSET
index|]
operator|==
name|FLAG_ON
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|xoff_den
operator|==
literal|0
operator|)
operator|||
operator|(
name|xoff_den
operator|==
literal|1
operator|)
condition|)
name|put_Integer
argument_list|(
name|xoff_num
argument_list|)
expr_stmt|;
else|else
name|put_seqRational
argument_list|(
name|xoff_num
argument_list|,
name|xoff_den
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|yoff_den
operator|==
literal|0
operator|)
operator|||
operator|(
name|yoff_den
operator|==
literal|1
operator|)
condition|)
name|put_Integer
argument_list|(
name|yoff_num
argument_list|)
expr_stmt|;
else|else
name|put_seqRational
argument_list|(
name|yoff_num
argument_list|,
name|yoff_den
argument_list|)
expr_stmt|;
name|put_op
argument_list|(
name|OP_translate
argument_list|)
expr_stmt|;
name|put_op
argument_list|(
name|OP_concatt
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|proc_flag
index|[
name|SCALE
index|]
operator|==
name|FLAG_ON
condition|)
block|{
if|if
condition|(
operator|(
name|scale_den
operator|==
literal|0
operator|)
operator||
operator|(
name|scale_den
operator|==
literal|1
operator|)
condition|)
name|put_Integer
argument_list|(
name|scale_num
argument_list|)
expr_stmt|;
else|else
name|put_seqRational
argument_list|(
name|scale_num
argument_list|,
name|scale_den
argument_list|)
expr_stmt|;
name|put_op
argument_list|(
name|OP_scale
argument_list|)
expr_stmt|;
name|put_op
argument_list|(
name|OP_concatt
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|merge_pg
index|[
name|input_indx
index|]
index|[
name|merge_indx
index|]
operator|==
operator|(
operator|-
literal|1
operator|)
operator|)
operator|&&
operator|(
name|num_pages
operator|==
name|merge_pg
index|[
name|input_indx
index|]
index|[
operator|(
name|merge_indx
operator|+
literal|1
operator|)
index|]
operator|)
condition|)
operator|++
name|merge_indx
expr_stmt|;
if|if
condition|(
operator|(
name|num_pages
operator|==
name|merge_pg
index|[
name|input_indx
index|]
index|[
name|merge_indx
index|]
operator|)
operator|&&
operator|(
name|ovly_pg
index|[
name|input_indx
index|]
index|[
name|merge_indx
index|]
operator|!=
operator|(
operator|-
literal|1
operator|)
operator|)
condition|)
block|{
name|put_op
argument_list|(
name|OP_dosavesimplebody
argument_list|)
expr_stmt|;
name|put_op
argument_list|(
name|OP_beginBody
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|begBody_flag
operator|=
name|FLAG_ON
expr_stmt|;
break|break;
case|case
operator|(
name|OP_endBody
operator|)
case|:
name|put_opname_to_prop
argument_list|(
name|op
argument_list|)
expr_stmt|;
if|if
condition|(
name|bop_flag
operator|==
name|FLAG_ON
condition|)
block|{
name|put_op
argument_list|(
name|op
argument_list|)
expr_stmt|;
operator|--
name|bop_iindx
index|[
name|bop_indx
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|bop_iindx
index|[
name|bop_indx
index|]
operator|==
literal|0
operator|)
operator|&&
operator|(
name|bop_indx
operator|>
literal|0
operator|)
condition|)
operator|--
name|bop_indx
expr_stmt|;
if|if
condition|(
operator|(
name|bop_indx
operator|==
literal|0
operator|)
operator|&&
operator|(
name|bop_iindx
index|[
name|bop_indx
index|]
operator|==
literal|0
operator|)
condition|)
name|bop_flag
operator|=
name|FLAG_OFF
expr_stmt|;
block|}
else|else
comment|/* bop_flag == FLAG_OFF */
block|{
if|if
condition|(
name|endpreamble_expected
operator|==
name|FLAG_ON
condition|)
comment|/*	then processing preamble -- can't chapterize */
block|{
name|put_op
argument_list|(
name|op
argument_list|)
expr_stmt|;
name|endpreamble_expected
operator|=
name|FLAG_OFF
expr_stmt|;
comment|/*  *  this next code determines the length of each BEGIN/Preamble to copy  *  for chapterizing as part of handling nested blocks  */
name|out_end_offset
index|[
name|block_indx
index|]
operator|=
name|out_offset
operator|-
literal|1
expr_stmt|;
block|}
else|else
comment|/* we have a righteous endBody */
block|{
if|if
condition|(
name|ipwrite_flag
operator|==
name|FLAG_ON
condition|)
block|{
name|put_op
argument_list|(
name|op
argument_list|)
expr_stmt|;
operator|++
name|out_numpages
expr_stmt|;
name|ovly_flag
operator|=
name|FLAG_OFF
expr_stmt|;
while|while
condition|(
name|num_pages
operator|==
name|merge_pg
index|[
name|input_indx
index|]
index|[
name|merge_indx
index|]
condition|)
block|{
if|if
condition|(
name|ovly_pg
index|[
name|input_indx
index|]
index|[
name|merge_indx
index|]
operator|!=
operator|(
operator|-
literal|1
operator|)
condition|)
block|{
name|ovly_flag
operator|=
name|FLAG_ON
expr_stmt|;
name|proc_overlay
argument_list|()
expr_stmt|;
block|}
operator|++
name|merge_indx
expr_stmt|;
block|}
if|if
condition|(
name|ovly_flag
operator|==
name|FLAG_ON
condition|)
block|{
name|put_op
argument_list|(
name|OP_endBody
argument_list|)
expr_stmt|;
name|ovly_flag
operator|=
name|FLAG_OFF
expr_stmt|;
block|}
name|proc_chapterize
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|merge_pg
index|[
name|input_indx
index|]
index|[
name|merge_indx
index|]
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|proc_flag
index|[
name|CONCAT
index|]
operator|==
name|FLAG_ON
condition|)
name|nesting_level
operator|=
name|block_indx
operator|-
literal|1
expr_stmt|;
else|else
name|nesting_level
operator|=
name|block_indx
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nesting_level
condition|;
name|i
operator|++
control|)
name|put_op
argument_list|(
name|OP_endBlock
argument_list|)
expr_stmt|;
name|ipwrite_flag
operator|=
name|FLAG_OFF
expr_stmt|;
block|}
else|else
name|ipwrite_flag
operator|=
name|FLAG_ON
expr_stmt|;
block|}
block|}
break|break;
case|case
operator|(
name|OP_makesimpleco
operator|)
case|:
case|case
operator|(
name|OP_dosavesimplebody
operator|)
case|:
case|case
operator|(
name|OP_if
operator|)
case|:
case|case
operator|(
name|OP_ifelse
operator|)
case|:
case|case
operator|(
name|OP_ifcopy
operator|)
case|:
case|case
operator|(
name|OP_correct
operator|)
case|:
name|put_op
argument_list|(
name|op
argument_list|)
expr_stmt|;
name|put_opname_to_prop
argument_list|(
name|op
argument_list|)
expr_stmt|;
if|if
condition|(
name|bop_flag
operator|==
name|FLAG_OFF
condition|)
block|{
name|bop_indx
operator|=
literal|0
expr_stmt|;
name|bop_flag
operator|=
name|FLAG_ON
expr_stmt|;
block|}
else|else
operator|++
name|bop_indx
expr_stmt|;
name|bop_iindx
index|[
name|bop_indx
index|]
operator|=
literal|0
expr_stmt|;
name|bop_preamble_expected
index|[
name|bop_indx
index|]
operator|=
name|FLAG_OFF
expr_stmt|;
break|break;
default|default:
name|put_op
argument_list|(
name|op
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/****************************************************************  *  *	proc_overlay:		process the current  *				  ovly_pg[input_indx][merge_indx]  *  ****************************************************************/
end_comment

begin_macro
name|proc_overlay
argument_list|()
end_macro

begin_block
block|{
name|put_op
argument_list|(
name|OP_dosavesimplebody
argument_list|)
expr_stmt|;
name|put_op
argument_list|(
name|OP_beginBody
argument_list|)
expr_stmt|;
name|ovly_indx
operator|=
name|ovly_pg
index|[
name|input_indx
index|]
index|[
name|merge_indx
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|ovly_den
index|[
literal|0
index|]
index|[
name|ovly_indx
index|]
operator|!=
literal|0
operator|)
operator|||
operator|(
name|ovly_den
index|[
literal|1
index|]
index|[
name|ovly_indx
index|]
operator|!=
literal|0
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|ovly_den
index|[
literal|0
index|]
index|[
name|ovly_indx
index|]
operator|==
literal|0
operator|)
operator|||
operator|(
name|ovly_den
index|[
literal|0
index|]
index|[
name|ovly_indx
index|]
operator|==
literal|1
operator|)
condition|)
name|put_Integer
argument_list|(
name|ovly_num
index|[
literal|0
index|]
index|[
name|ovly_indx
index|]
argument_list|)
expr_stmt|;
else|else
name|put_seqRational
argument_list|(
name|ovly_num
index|[
literal|0
index|]
index|[
name|ovly_indx
index|]
argument_list|,
name|ovly_den
index|[
literal|0
index|]
index|[
name|ovly_indx
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ovly_den
index|[
literal|1
index|]
index|[
name|ovly_indx
index|]
operator|==
literal|0
operator|)
operator|||
operator|(
name|ovly_den
index|[
literal|1
index|]
index|[
name|ovly_indx
index|]
operator|==
literal|1
operator|)
condition|)
name|put_Integer
argument_list|(
name|ovly_num
index|[
literal|1
index|]
index|[
name|ovly_indx
index|]
argument_list|)
expr_stmt|;
else|else
name|put_seqRational
argument_list|(
name|ovly_num
index|[
literal|1
index|]
index|[
name|ovly_indx
index|]
argument_list|,
name|ovly_den
index|[
literal|1
index|]
index|[
name|ovly_indx
index|]
argument_list|)
expr_stmt|;
name|put_op
argument_list|(
name|OP_translate
argument_list|)
expr_stmt|;
name|put_op
argument_list|(
name|OP_concatt
argument_list|)
expr_stmt|;
block|}
name|proc_ovly_file
argument_list|(
name|ovly_fname
index|[
name|ovly_indx
index|]
argument_list|)
expr_stmt|;
name|put_op
argument_list|(
name|OP_endBody
argument_list|)
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/****************************************************************  *  *	prc_ovly_file(fname):  *	proc_ovly_file:	try to open specified filename;  *				if open_err,  *				    create a SIF reference  *				else,  *				    process as a SIF  *  ****************************************************************/
end_comment

begin_macro
name|proc_ovly_file
argument_list|(
argument|fname
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|fname
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|retcd
decl_stmt|,
name|pgnum
decl_stmt|;
name|char
name|msg
index|[
literal|128
index|]
decl_stmt|;
name|ovly_file
operator|=
name|fopen
argument_list|(
name|fname
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ovly_file
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|msg
argument_list|,
literal|"                  --Error opening overlay file:  %s\n"
argument_list|,
name|fname
argument_list|)
expr_stmt|;
name|pip_error
argument_list|(
name|msg
argument_list|)
expr_stmt|;
name|create_SIF
argument_list|(
name|fname
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|retcd
operator|=
name|get_ip_hdr
argument_list|(
name|ovly_file
argument_list|,
name|fname
argument_list|)
expr_stmt|;
if|if
condition|(
name|retcd
operator|==
name|ERROR
condition|)
name|create_SIF
argument_list|(
name|fname
argument_list|)
expr_stmt|;
else|else
block|{
comment|/*** 	The following assumes we're not already nested in a body_operator 	(i.e., that we were at a real endBody when invoked) ***/
name|bop_flag
operator|=
name|FLAG_ON
expr_stmt|;
name|bop_indx
operator|=
literal|0
expr_stmt|;
name|bop_iindx
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|bop_preamble_expected
index|[
literal|0
index|]
operator|=
name|FLAG_ON
expr_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|hdr_workbuf
argument_list|)
operator|>
name|IP_HDR_MASTERLEN
condition|)
name|prc_IF_fragment
argument_list|(
name|ovly_file
argument_list|,
name|fname
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|ovly_pgnum
index|[
name|ovly_indx
index|]
operator|==
literal|0
condition|)
name|pgnum
operator|=
literal|1
expr_stmt|;
else|else
name|pgnum
operator|=
name|ovly_pgnum
index|[
name|ovly_indx
index|]
expr_stmt|;
name|prc_IF_master
argument_list|(
name|ovly_file
argument_list|,
name|fname
argument_list|,
name|pgnum
argument_list|)
expr_stmt|;
block|}
name|bop_flag
operator|=
name|FLAG_OFF
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|ovly_file
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/****************************************************************  *  *	proc_sequence(type_byte, length, file, filename):  *	proc_sequence:	process Interpress tokens of type  *<sequence>  *  ****************************************************************/
end_comment

begin_macro
name|proc_sequence
argument_list|(
argument|type_byte
argument_list|,
argument|length
argument_list|,
argument|file
argument_list|,
argument|filename
argument_list|)
end_macro

begin_decl_stmt
name|FILE
modifier|*
name|file
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|long
name|length
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|type_byte
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|filename
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
operator|(
name|type_byte
operator|&
literal|0x1f
operator|)
operator|==
name|sequenceInsertFile
condition|)
name|proc_SIF_token
argument_list|(
name|type_byte
argument_list|,
name|length
argument_list|,
name|file
argument_list|,
name|filename
argument_list|)
expr_stmt|;
else|else
block|{
name|put_seq_type_len
argument_list|(
name|type_byte
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|iocopyn
argument_list|(
name|length
argument_list|,
name|file
argument_list|,
name|filename
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/****************************************************************  *  *	prc_SIF_file(sfile, sfilename):  *	prc_SIF_file:		process sequenceInsertFile  *  ****************************************************************/
end_comment

begin_macro
name|prc_SIF_file
argument_list|(
argument|sfile
argument_list|,
argument|sfilename
argument_list|)
end_macro

begin_decl_stmt
name|FILE
modifier|*
name|sfile
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|sfilename
decl_stmt|;
end_decl_stmt

begin_block
block|{
comment|/*  *  if the IP_HDR indicates the SIF is a fragment, process as such;  *  else, for a regular SIF, just process the first page of a master  */
if|if
condition|(
name|strlen
argument_list|(
name|hdr_workbuf
argument_list|)
operator|>
name|IP_HDR_MASTERLEN
condition|)
name|prc_IF_fragment
argument_list|(
name|sfile
argument_list|,
name|sfilename
argument_list|)
expr_stmt|;
else|else
name|prc_IF_master
argument_list|(
name|sfile
argument_list|,
name|sfilename
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/****************************************************************  *  *	proc_SIF_token(type, length, file, filename):  *	proc_SIF_token:	process sequenceInsertFile token  *  ****************************************************************/
end_comment

begin_macro
name|proc_SIF_token
argument_list|(
argument|type_byte
argument_list|,
argument|length
argument_list|,
argument|file
argument_list|,
argument|filename
argument_list|)
end_macro

begin_decl_stmt
name|FILE
modifier|*
name|file
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|long
name|length
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|type_byte
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|filename
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|i
decl_stmt|,
name|retcd
decl_stmt|;
name|char
name|msg
index|[
literal|128
index|]
decl_stmt|,
name|buf
index|[
name|MX_HDR_BUFLEN
index|]
decl_stmt|,
name|open_buf
index|[
name|MX_HDR_BUFLEN
index|]
decl_stmt|;
specifier|static
name|char
modifier|*
name|preserve_msg
init|=
literal|"                  --(Preserving the SIF reference)\n"
decl_stmt|,
modifier|*
name|remove_msg
init|=
literal|"                  --(Removing the SIF reference)\n"
decl_stmt|;
operator|++
name|num_sifs
expr_stmt|;
operator|++
name|tnum_sifs
expr_stmt|;
name|test_newline
argument_list|()
expr_stmt|;
name|put_offset_msg_to_prop
argument_list|(
operator|(
name|in_offset
operator|-
literal|1
operator|)
argument_list|,
literal|"--SIF:  "
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|length
operator|==
literal|0
operator|)
operator|||
operator|(
name|length
operator|>
name|MX_HDR_BUFLEN
operator|)
condition|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|msg
argument_list|,
literal|"--Warning:  sequenceInsertFile token encountered with\n"
argument_list|)
expr_stmt|;
name|pip_error
argument_list|(
name|msg
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|msg
argument_list|,
literal|"            descriptor length = %d\n"
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|pip_error
argument_list|(
name|msg
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|msg
argument_list|,
literal|"(ERROR:  Descriptor length = %d)\n"
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|pip_prop
argument_list|(
name|msg
argument_list|)
expr_stmt|;
if|if
condition|(
name|proc_flag
index|[
name|REMOVE_SIFS
index|]
operator|==
name|FLAG_ON
condition|)
block|{
name|pip_error
argument_list|(
name|remove_msg
argument_list|)
expr_stmt|;
name|ioreadn
argument_list|(
name|length
argument_list|,
name|file
argument_list|,
name|filename
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|pip_error
argument_list|(
name|preserve_msg
argument_list|)
expr_stmt|;
comment|/*  *  preserve the SIF reference  */
name|copy_preserve_SIF
argument_list|(
name|type_byte
argument_list|,
name|length
argument_list|,
name|file
argument_list|,
name|filename
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|iogetn
argument_list|(
name|length
argument_list|,
name|file
argument_list|,
name|filename
argument_list|,
name|buf
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|open_buf
argument_list|,
name|buf
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|msg
argument_list|,
literal|"          --SIF:  %s  (nesting depth=%d)\n"
argument_list|,
name|buf
argument_list|,
name|sif_indx
argument_list|)
expr_stmt|;
name|pip_error
argument_list|(
name|msg
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|msg
argument_list|,
literal|"%s\n"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|pip_prop
argument_list|(
name|msg
argument_list|)
expr_stmt|;
comment|/*  *  Check for alias  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_aliases
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|buf
argument_list|,
name|alias_ref
index|[
name|i
index|]
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|open_buf
argument_list|,
name|alias_act
index|[
name|i
index|]
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|msg
argument_list|,
literal|"                  --Alias: %s=%s\n"
argument_list|,
name|buf
argument_list|,
name|open_buf
argument_list|)
expr_stmt|;
name|pip_error
argument_list|(
name|msg
argument_list|)
expr_stmt|;
name|indent
argument_list|(
operator|(
name|off_indent
operator|+
name|cur_indent
operator|+
literal|8
operator|)
argument_list|,
name|propfile
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|msg
argument_list|,
literal|"--Alias: %s=%s\n"
argument_list|,
name|buf
argument_list|,
name|open_buf
argument_list|)
expr_stmt|;
name|pip_prop
argument_list|(
name|msg
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|proc_flag
index|[
name|SATISFY_SIFS
index|]
operator|==
name|FLAG_OFF
condition|)
block|{
if|if
condition|(
name|proc_flag
index|[
name|REMOVE_SIFS
index|]
operator|==
name|FLAG_ON
condition|)
name|pip_error
argument_list|(
name|remove_msg
argument_list|)
expr_stmt|;
else|else
block|{
name|pip_error
argument_list|(
literal|"                  -s switch (Satisfy SIFS option) not specified\n"
argument_list|)
expr_stmt|;
name|pip_error
argument_list|(
name|preserve_msg
argument_list|)
expr_stmt|;
name|put_preserve_SIF
argument_list|(
name|type_byte
argument_list|,
name|length
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|sif_indx
operator|>=
name|MX_SIF_DEPTH
condition|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|msg
argument_list|,
literal|"*** warning:  maximum SIF nesting depth allowed in IPFE=%d\n"
argument_list|,
name|MX_SIF_DEPTH
argument_list|)
expr_stmt|;
name|pip_error
argument_list|(
name|msg
argument_list|)
expr_stmt|;
if|if
condition|(
name|proc_flag
index|[
name|REMOVE_SIFS
index|]
operator|==
name|FLAG_ON
condition|)
name|pip_error
argument_list|(
name|remove_msg
argument_list|)
expr_stmt|;
else|else
block|{
name|pip_error
argument_list|(
name|preserve_msg
argument_list|)
expr_stmt|;
comment|/*  *  preserve the SIF reference  */
name|put_preserve_SIF
argument_list|(
name|type_byte
argument_list|,
name|length
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|sif_file
index|[
name|sif_indx
index|]
operator|=
name|fopen
argument_list|(
name|open_buf
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sif_file
index|[
name|sif_indx
index|]
operator|==
name|NULL
condition|)
block|{
name|pip_error
argument_list|(
literal|"                  "
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|msg
argument_list|,
literal|"--Error opening SIF file: %s\n"
argument_list|,
name|open_buf
argument_list|)
expr_stmt|;
name|pip_error
argument_list|(
name|msg
argument_list|)
expr_stmt|;
name|indent
argument_list|(
operator|(
name|off_indent
operator|+
name|cur_indent
operator|+
literal|8
operator|)
argument_list|,
name|propfile
argument_list|)
expr_stmt|;
name|pip_prop
argument_list|(
name|msg
argument_list|)
expr_stmt|;
if|if
condition|(
name|proc_flag
index|[
name|REMOVE_SIFS
index|]
operator|==
name|FLAG_ON
condition|)
name|pip_error
argument_list|(
name|remove_msg
argument_list|)
expr_stmt|;
else|else
block|{
name|pip_error
argument_list|(
name|preserve_msg
argument_list|)
expr_stmt|;
comment|/*  *  preserve the SIF reference  */
name|put_preserve_SIF
argument_list|(
name|type_byte
argument_list|,
name|length
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/*  *  check the validity of the SIF hdr  */
name|retcd
operator|=
name|get_ip_hdr
argument_list|(
name|sif_file
index|[
name|sif_indx
index|]
argument_list|,
name|open_buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|retcd
operator|==
name|ERROR
condition|)
block|{
if|if
condition|(
name|proc_flag
index|[
name|REMOVE_SIFS
index|]
operator|==
name|FLAG_ON
condition|)
name|pip_error
argument_list|(
name|remove_msg
argument_list|)
expr_stmt|;
else|else
block|{
name|pip_error
argument_list|(
name|preserve_msg
argument_list|)
expr_stmt|;
comment|/*  *  preserve the SIF reference  */
name|put_preserve_SIF
argument_list|(
name|type_byte
argument_list|,
name|length
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|sif_name
index|[
name|sif_indx
index|]
argument_list|,
name|open_buf
argument_list|)
expr_stmt|;
name|sifname
operator|=
name|sif_name
index|[
name|sif_indx
index|]
expr_stmt|;
name|siffile
operator|=
name|sif_file
index|[
name|sif_indx
index|]
expr_stmt|;
name|pip_error
argument_list|(
literal|"                  -- Processing SIF content --\n"
argument_list|)
expr_stmt|;
operator|++
name|sif_indx
expr_stmt|;
name|prc_SIF_file
argument_list|(
name|siffile
argument_list|,
name|sifname
argument_list|)
expr_stmt|;
operator|--
name|sif_indx
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|sif_file
index|[
name|sif_indx
index|]
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/****************************************************************  *  *	put_Integer(val):  *	put_Integer:		if  ((val> INTEGER_MAX) ||  *				     (val< INTEGER_MIN))  *				    put val out as seqInteger  *				else  *				    put val out as Short Number  *				    token (biased by 4000 (0xfa0))  *  ****************************************************************/
end_comment

begin_macro
name|put_Integer
argument_list|(
argument|val
argument_list|)
end_macro

begin_decl_stmt
name|long
name|val
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|len
decl_stmt|;
if|if
condition|(
operator|(
name|val
operator|<
name|INTEGER_MIN
operator|)
operator|||
operator|(
name|val
operator|>
name|INTEGER_MAX
operator|)
condition|)
block|{
name|len
operator|=
name|count_int_bytes
argument_list|(
name|val
argument_list|)
expr_stmt|;
name|put_seq_type_len
argument_list|(
name|sequenceInteger
argument_list|,
operator|(
name|long
operator|)
name|len
argument_list|)
expr_stmt|;
name|put_intn
argument_list|(
name|val
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|val
operator|=
name|val
operator|+
name|INTEGER_ZERO
expr_stmt|;
comment|/* add bias */
name|ip_putc
argument_list|(
call|(
name|char
call|)
argument_list|(
operator|(
name|val
operator|>>
literal|8
operator|)
operator|&
literal|0x7f
argument_list|)
argument_list|)
expr_stmt|;
name|ip_putc
argument_list|(
operator|(
name|char
operator|)
name|val
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/****************************************************************  *  *	put_intn(val, len):  *	put_intn:		put specified val out as len bytes  *  ****************************************************************/
end_comment

begin_macro
name|put_intn
argument_list|(
argument|val
argument_list|,
argument|len
argument_list|)
end_macro

begin_decl_stmt
name|long
name|val
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|len
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* measured in bytes */
end_comment

begin_block
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|len
operator|>
literal|0
condition|)
block|{
operator|--
name|len
expr_stmt|;
for|for
control|(
name|i
operator|=
name|len
operator|*
literal|8
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|=
name|i
operator|-
literal|8
control|)
name|ip_putc
argument_list|(
call|(
name|char
call|)
argument_list|(
name|val
operator|>>
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/****************************************************************  *  *	put_offset_msg_to_prop(off, msg):  *	put_offset_msg_to_prop:  put specified in_offset (formatted)  *				   +<:> +<cur_indent> + msg  *				   to propfile  *  ****************************************************************/
end_comment

begin_macro
name|put_offset_msg_to_prop
argument_list|(
argument|off
argument_list|,
argument|msg
argument_list|)
end_macro

begin_decl_stmt
name|long
name|off
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|msg
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|cur_col
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|proc_flag
index|[
name|DEBUG
index|]
operator|==
name|FLAG_ON
condition|)
name|put_offp_to_prop
argument_list|(
name|off
argument_list|)
expr_stmt|;
name|indent
argument_list|(
name|cur_indent
argument_list|,
name|propfile
argument_list|)
expr_stmt|;
block|}
name|pip_prop
argument_list|(
name|msg
argument_list|)
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/****************************************************************  *  *	put_off_to_prop(off, format_flag):  *	put_off_to_prop:	put specified in_offset (formatted)  *				to propfile  *  ****************************************************************/
end_comment

begin_macro
name|put_off_to_prop
argument_list|(
argument|off
argument_list|,
argument|format_flag
argument_list|)
end_macro

begin_decl_stmt
name|long
name|off
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|format_flag
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|i
decl_stmt|,
name|procflag
decl_stmt|;
name|char
name|digit
decl_stmt|;
if|if
condition|(
name|propfile
operator|!=
name|NULL
condition|)
block|{
name|procflag
operator|=
name|FLAG_OFF
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|20
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|=
name|i
operator|-
literal|4
control|)
block|{
name|digit
operator|=
operator|(
name|off
operator|>>
name|i
operator|)
operator|&
literal|0x0f
expr_stmt|;
if|if
condition|(
operator|(
name|digit
operator|==
literal|0
operator|)
operator|&&
operator|(
name|procflag
operator|==
name|FLAG_OFF
operator|)
operator|&&
operator|(
name|i
operator|>
literal|4
operator|)
condition|)
block|{
if|if
condition|(
name|format_flag
operator|==
name|FORMAT
condition|)
name|mputc_prop
argument_list|(
name|SPC
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|digit
operator|>
literal|9
condition|)
name|digit
operator|=
name|digit
operator|+
literal|7
expr_stmt|;
name|mputc_prop
argument_list|(
name|digit
operator|+
literal|0x30
argument_list|)
expr_stmt|;
name|procflag
operator|=
name|FLAG_ON
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|i
operator|==
literal|16
operator|)
operator|&&
operator|(
operator|(
name|format_flag
operator|==
name|FORMAT
operator|)
operator|||
operator|(
name|procflag
operator|==
name|FLAG_ON
operator|)
operator|)
condition|)
name|mputc_prop
argument_list|(
name|SPC
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/****************************************************************  *  *	put_offp_to_prop(off):  *	put_offp_to_prop:	put specified in_offset (formatted  *				plus "+  " or ":  " to propfile  *  ****************************************************************/
end_comment

begin_macro
name|put_offp_to_prop
argument_list|(
argument|off
argument_list|)
end_macro

begin_decl_stmt
name|long
name|off
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|put_off_to_prop
argument_list|(
name|off
argument_list|,
name|FORMAT
argument_list|)
expr_stmt|;
if|if
condition|(
name|off
operator|>
literal|0xffffff
condition|)
name|pip_prop
argument_list|(
literal|"+  "
argument_list|)
expr_stmt|;
else|else
name|pip_prop
argument_list|(
literal|":  "
argument_list|)
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/****************************************************************  *  *	put_op(op):  *	put_op:		put specified op to output  *  ****************************************************************/
end_comment

begin_macro
name|put_op
argument_list|(
argument|op
argument_list|)
end_macro

begin_decl_stmt
name|int
name|op
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|op
operator|<=
name|SHORT_OP_LIMIT
condition|)
name|ip_putc
argument_list|(
name|op
operator||
name|SHORT_OP
argument_list|)
expr_stmt|;
else|else
block|{
name|ip_putc
argument_list|(
operator|(
name|op
operator|>>
literal|8
operator|)
operator||
name|LONG_OP
argument_list|)
expr_stmt|;
name|ip_putc
argument_list|(
name|op
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/****************************************************************  *  *	put_opname_to_prop(op):  *	put_opname_to_prop:	put specified op_name to propfile  *  ****************************************************************/
end_comment

begin_macro
name|put_opname_to_prop
argument_list|(
argument|op
argument_list|)
end_macro

begin_decl_stmt
name|int
name|op
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
name|msg
index|[
literal|128
index|]
decl_stmt|;
if|if
condition|(
name|op
operator|!=
name|OP_endBody
condition|)
name|test_begBody
argument_list|()
expr_stmt|;
name|begBody_flag
operator|=
name|FLAG_OFF
expr_stmt|;
comment|/* reset because we're ALWAYS putting 					   SOMETHING to propfile here */
switch|switch
condition|(
name|op
condition|)
block|{
case|case
operator|(
name|OP_beginBlock
operator|)
case|:
name|test_newline
argument_list|()
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|msg
argument_list|,
literal|"%s\n"
argument_list|,
name|op_name
argument_list|(
name|op
argument_list|)
argument_list|)
expr_stmt|;
name|put_offset_msg_to_prop
argument_list|(
operator|(
name|in_offset
operator|-
literal|2
operator|)
argument_list|,
name|msg
argument_list|)
expr_stmt|;
name|cur_indent
operator|=
name|cur_indent
operator|+
name|INDENT_INCR
expr_stmt|;
break|break;
case|case
operator|(
name|OP_endBlock
operator|)
case|:
name|cur_indent
operator|=
name|cur_indent
operator|-
name|INDENT_INCR
expr_stmt|;
name|test_newline
argument_list|()
expr_stmt|;
name|put_offset_msg_to_prop
argument_list|(
operator|(
name|in_offset
operator|-
literal|2
operator|)
argument_list|,
name|op_name
argument_list|(
name|op
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|proc_flag
index|[
name|DEBUG
index|]
operator|==
name|FLAG_ON
condition|)
block|{
name|indent
argument_list|(
operator|(
name|INDENT_INCR
operator|-
literal|1
operator|)
argument_list|,
name|propfile
argument_list|)
expr_stmt|;
name|mputc_prop
argument_list|(
literal|'('
argument_list|)
expr_stmt|;
name|put_off_to_prop
argument_list|(
operator|(
name|in_offset
operator|-
literal|1
operator|)
argument_list|,
name|DONT_FORMAT
argument_list|)
expr_stmt|;
name|mputc_prop
argument_list|(
literal|')'
argument_list|)
expr_stmt|;
block|}
name|mputc_prop
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
break|break;
case|case
operator|(
name|OP_beginBody
operator|)
case|:
name|put_offset_msg_to_prop
argument_list|(
operator|(
name|in_offset
operator|-
literal|2
operator|)
argument_list|,
name|op_name
argument_list|(
name|op
argument_list|)
argument_list|)
expr_stmt|;
name|indent
argument_list|(
operator|(
name|INDENT_INCR
operator|-
literal|1
operator|)
argument_list|,
name|propfile
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|proc_flag
index|[
name|PROPERTIES
index|]
operator|==
name|FLAG_ON
operator|)
operator|&&
operator|(
name|prop_level
operator|>
literal|0
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|preamble_expected
operator|==
name|FLAG_OFF
operator|)
operator|&&
operator|(
name|endpreamble_expected
operator|==
name|FLAG_OFF
operator|)
operator|&&
operator|(
name|bop_flag
operator|==
name|FLAG_OFF
operator|)
condition|)
block|{
comment|/* we have a righteous pageBody */
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|msg
argument_list|,
literal|"Pg%d"
argument_list|,
operator|(
name|tnum_pages
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
name|pip_prop
argument_list|(
name|msg
argument_list|)
expr_stmt|;
name|indent
argument_list|(
operator|(
name|INDENT_INCR
operator|-
literal|1
operator|)
argument_list|,
name|propfile
argument_list|)
expr_stmt|;
block|}
block|}
name|cur_indent
operator|=
name|cur_indent
operator|+
name|INDENT_INCR
expr_stmt|;
break|break;
case|case
operator|(
name|OP_endBody
operator|)
case|:
name|cur_indent
operator|=
name|cur_indent
operator|-
name|INDENT_INCR
expr_stmt|;
if|if
condition|(
name|cur_col
operator|==
literal|0
condition|)
name|indent
argument_list|(
operator|(
name|cur_indent
operator|+
name|off_indent
operator|)
argument_list|,
name|propfile
argument_list|)
expr_stmt|;
name|pip_prop
argument_list|(
name|op_name
argument_list|(
name|op
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|proc_flag
index|[
name|PROPERTIES
index|]
operator|==
name|FLAG_ON
operator|)
operator|&&
operator|(
name|prop_level
operator|>
literal|0
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|endpreamble_expected
operator|==
name|FLAG_OFF
operator|)
operator|&&
operator|(
name|bop_flag
operator|==
name|FLAG_OFF
operator|)
condition|)
block|{
comment|/* we have a righteous endBody */
name|indent
argument_list|(
operator|(
name|INDENT_INCR
operator|-
literal|1
operator|)
argument_list|,
name|propfile
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|msg
argument_list|,
literal|"endPg%d"
argument_list|,
name|tnum_pages
argument_list|)
expr_stmt|;
name|pip_prop
argument_list|(
name|msg
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|proc_flag
index|[
name|DEBUG
index|]
operator|==
name|FLAG_ON
condition|)
block|{
name|indent
argument_list|(
operator|(
name|INDENT_INCR
operator|-
literal|1
operator|)
argument_list|,
name|propfile
argument_list|)
expr_stmt|;
name|mputc_prop
argument_list|(
literal|'('
argument_list|)
expr_stmt|;
name|put_off_to_prop
argument_list|(
operator|(
name|in_offset
operator|-
literal|1
operator|)
argument_list|,
name|DONT_FORMAT
argument_list|)
expr_stmt|;
name|mputc_prop
argument_list|(
literal|')'
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|debug_flag
operator|==
name|FLAG_ON
condition|)
block|{
name|indent
argument_list|(
operator|(
name|INDENT_INCR
operator|-
literal|1
operator|)
argument_list|,
name|propfile
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|msg
argument_list|,
literal|"[%d %d %d %d]"
argument_list|,
name|bop_indx
argument_list|,
name|bop_iindx
index|[
name|bop_indx
index|]
argument_list|,
name|bop_iindx
index|[
literal|0
index|]
argument_list|,
name|endpreamble_expected
argument_list|)
expr_stmt|;
name|pip_prop
argument_list|(
name|msg
argument_list|)
expr_stmt|;
block|}
name|mputc_prop
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
break|break;
case|case
operator|(
name|OP_makesimpleco
operator|)
case|:
case|case
operator|(
name|OP_dosavesimplebody
operator|)
case|:
case|case
operator|(
name|OP_if
operator|)
case|:
case|case
operator|(
name|OP_ifelse
operator|)
case|:
case|case
operator|(
name|OP_ifcopy
operator|)
case|:
name|put_offset_msg_to_prop
argument_list|(
operator|(
name|in_offset
operator|-
literal|2
operator|)
argument_list|,
name|op_name
argument_list|(
name|op
argument_list|)
argument_list|)
expr_stmt|;
name|mputc_prop
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
break|break;
case|case
operator|(
name|OP_correct
operator|)
case|:
comment|/*  *  don't do all those nasty CORRECT's unless the user forces us to  */
if|if
condition|(
name|prop_level
operator|>
literal|1
condition|)
block|{
name|put_offset_msg_to_prop
argument_list|(
operator|(
name|in_offset
operator|-
literal|2
operator|)
argument_list|,
name|op_name
argument_list|(
name|op
argument_list|)
argument_list|)
expr_stmt|;
name|mputc_prop
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
break|break;
block|}
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/****************************************************************  *  *	put_seqRational(num, den):  *	put_seqRational:	put specified numerator& denominator  *				out as a sequenceRational  *  ****************************************************************/
end_comment

begin_macro
name|put_seqRational
argument_list|(
argument|num
argument_list|,
argument|den
argument_list|)
end_macro

begin_decl_stmt
name|long
name|num
decl_stmt|,
name|den
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|len
decl_stmt|,
name|num_len
decl_stmt|,
name|den_len
decl_stmt|;
name|num_len
operator|=
name|count_int_bytes
argument_list|(
name|num
argument_list|)
expr_stmt|;
name|den_len
operator|=
name|count_int_bytes
argument_list|(
name|den
argument_list|)
expr_stmt|;
if|if
condition|(
name|num_len
operator|>
name|den_len
condition|)
name|len
operator|=
name|num_len
expr_stmt|;
else|else
name|len
operator|=
name|den_len
expr_stmt|;
name|put_seq_type_len
argument_list|(
name|sequenceRational
argument_list|,
call|(
name|long
call|)
argument_list|(
name|len
operator|*
literal|2
argument_list|)
argument_list|)
expr_stmt|;
name|put_intn
argument_list|(
name|num
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|put_intn
argument_list|(
name|den
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/****************************************************************  *  *	put_seq_type_len(type_byte, length):  *	put_seq_type_len:	put specified type_byte& length  *				to output  *  ****************************************************************/
end_comment

begin_macro
name|put_seq_type_len
argument_list|(
argument|type_byte
argument_list|,
argument|length
argument_list|)
end_macro

begin_decl_stmt
name|long
name|length
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|type_byte
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|length
operator|>
name|SHORT_SEQUENCE_LIMIT
condition|)
block|{
name|ip_putc
argument_list|(
call|(
name|char
call|)
argument_list|(
name|LONG_SEQUENCE
operator||
operator|(
name|type_byte
operator|&
literal|0x1f
operator|)
argument_list|)
argument_list|)
expr_stmt|;
name|ip_putc
argument_list|(
call|(
name|char
call|)
argument_list|(
name|length
operator|>>
literal|16
argument_list|)
argument_list|)
expr_stmt|;
name|ip_putc
argument_list|(
call|(
name|char
call|)
argument_list|(
name|length
operator|>>
literal|8
argument_list|)
argument_list|)
expr_stmt|;
name|ip_putc
argument_list|(
operator|(
name|char
operator|)
name|length
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ip_putc
argument_list|(
call|(
name|char
call|)
argument_list|(
name|SHORT_SEQUENCE
operator||
operator|(
name|type_byte
operator|&
literal|0x1f
operator|)
argument_list|)
argument_list|)
expr_stmt|;
name|ip_putc
argument_list|(
operator|(
name|char
operator|)
name|length
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/****************************************************************  *  *	test_begBody:		if beBody flag is set,  *				  put a newline to propfile  *  ****************************************************************/
end_comment

begin_macro
name|test_begBody
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|begBody_flag
operator|==
name|FLAG_ON
condition|)
block|{
name|mputc_prop
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|begBody_flag
operator|=
name|FLAG_OFF
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/****************************************************************  *  *	test_newline:		if cur_col != 0,  *				  put a newline to propfile  *  ****************************************************************/
end_comment

begin_macro
name|test_newline
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|cur_col
operator|!=
literal|0
condition|)
name|mputc_prop
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/****************************************************************  *  *	usage:		dsply the cmd_line interface  *  ****************************************************************/
end_comment

begin_macro
name|Usage
argument_list|()
end_macro

begin_block
block|{
name|fprintf
argument_list|(
name|STDERR
argument_list|,
literal|"Usage:\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|STDERR
argument_list|,
literal|"        ipfe [ options ] file [pagerange ... [file [pagerange]...]\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|STDERR
argument_list|,
literal|"Options:\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|STDERR
argument_list|,
literal|"         [-l logfile] [-dDiLqrRs] [-a alias:actual [-a alias:actual]\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|STDERR
argument_list|,
literal|"         ...] [-b offset:unit] [-c count:unit] [-o outfile]\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|STDERR
argument_list|,
literal|"         [-p level:propfile] [-S factor] [-X offset:unit]\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|STDERR
argument_list|,
literal|"         [-Y offset:unit]\n\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|STDERR
argument_list|,
literal|"          -a alias:actual (alias). If the -s option is specified,\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|STDERR
argument_list|,
literal|"                         replace any SIF matching the string \"alias\"\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|STDERR
argument_list|,
literal|"                         with the string \"actual\" before attempting\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|STDERR
argument_list|,
literal|"                         to satisfy the SIF. If \"actual\" cannot be\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|STDERR
argument_list|,
literal|"                         opened or there is some error, the SIF\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|STDERR
argument_list|,
literal|"                         \"alias\" is preserved, unless the -r option\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|STDERR
argument_list|,
literal|"                         is also specified.\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|STDERR
argument_list|,
literal|"          -b offset:unit (binding offset). Shift the image offset units\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|STDERR
argument_list|,
literal|"                         in the x-direction, where unit may be: none\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|STDERR
argument_list|,
literal|"                         (default centimeters), c (centimeters), i\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|STDERR
argument_list|,
literal|"                         (inches), p (points), P (Picas). If the -L\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|STDERR
argument_list|,
literal|"                         (Landscape) switch is set, the image shift\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|STDERR
argument_list|,
literal|"                         is in the y-direction.\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|STDERR
argument_list|,
literal|"          -c count:unit  (chapterize) every count units, where unit\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|STDERR
argument_list|,
literal|"                         be: p (pages), k (kilobytes), m (megabytes).\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|STDERR
argument_list|,
literal|"          -d             (duplex). For resolving binding offset.\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|STDERR
argument_list|,
literal|"          -D             (debug). If the -p option is specified, also\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|STDERR
argument_list|,
literal|"                         write to the properties file the offsets of\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|STDERR
argument_list|,
literal|"                         each skeleton-level token encountered.\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|STDERR
argument_list|,
literal|"          -i             (insert SIF for overlay). Insert (create) a\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|STDERR
argument_list|,
literal|"                         SIF for any unresolvable overlays.\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|STDERR
argument_list|,
literal|"          -l logfile     (log). Keep a running log.\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|STDERR
argument_list|,
literal|"          -L             (Landscape). Rotate every page 90 degrees\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|STDERR
argument_list|,
literal|"                         counterclockwise and preserve the upper left\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|STDERR
argument_list|,
literal|"                         corner. Intended for printing text in\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|STDERR
argument_list|,
literal|"                         landscape orientation.\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|STDERR
argument_list|,
literal|"          -o outfile     (output). Where the output goes. If there is\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|STDERR
argument_list|,
literal|"                         no -o and there is a -p, only the properties\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|STDERR
argument_list|,
literal|"                         are written, else if there is no -o,\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|STDERR
argument_list|,
literal|"                         \"infile.ip\" is used if it doesn't already\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|STDERR
argument_list|,
literal|"                         exist, else \"infileN.ip\" is used, where N\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|STDERR
argument_list|,
literal|"                         is the lowest integer such that \"infileN.ip\"\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|STDERR
argument_list|,
literal|"                         does not already exist.\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|STDERR
argument_list|,
literal|"          -p level:propfile\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|STDERR
argument_list|,
literal|"                         (properties). Where the properties are\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|STDERR
argument_list|,
literal|"                         written. Increasing levels provide increasing\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|STDERR
argument_list|,
literal|"                         information details.\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|STDERR
argument_list|,
literal|"          -q             (quiet). Don't write info and error msgs (to\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|STDERR
argument_list|,
literal|"                         STDERR).\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|STDERR
argument_list|,
literal|"          -r             (remove SIFS). If -s is also specified, it\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|STDERR
argument_list|,
literal|"                         takes precedence and a SIF reference is\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|STDERR
argument_list|,
literal|"                         removed only if it is unresolved or there is\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|STDERR
argument_list|,
literal|"                         some other error.\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|STDERR
argument_list|,
literal|"          -R             (Rotate). Rotate every page 90 degrees\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|STDERR
argument_list|,
literal|"                         clockwise and preserve the center point.\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|STDERR
argument_list|,
literal|"                         Intended for rotating an image created for a\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|STDERR
argument_list|,
literal|"                         \"landscape printer\" to print in portrait\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|STDERR
argument_list|,
literal|"                         orientation.\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|STDERR
argument_list|,
literal|"          -s             (satisfy SIFS). Replace any SIF reference\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|STDERR
argument_list|,
literal|"                         with the tokens found in the referenced file.\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|STDERR
argument_list|,
literal|"                         If the referenced file cannot be opened, the\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|STDERR
argument_list|,
literal|"                         SIF reference is preserved unless -r is also\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|STDERR
argument_list|,
literal|"                         specified.\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|STDERR
argument_list|,
literal|"          -S factor      (scale). Scale the image by factor.\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|STDERR
argument_list|,
literal|"          -X offset:unit (X-imageShift). Shift the image offset units\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|STDERR
argument_list|,
literal|"                         in the x-direction, where unit may be: none\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|STDERR
argument_list|,
literal|"                         (default centimeters), c (centimeters), i\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|STDERR
argument_list|,
literal|"                         (inches), p (points), P (Picas). The shift\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|STDERR
argument_list|,
literal|"                         is independent of the -L and -R switches\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|STDERR
argument_list|,
literal|"                         (i.e., the x-direction is the same as the\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|STDERR
argument_list|,
literal|"                         unrotated image).\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|STDERR
argument_list|,
literal|"          -Y offset:unit (Y-imageShift). Shift the image offset units\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|STDERR
argument_list|,
literal|"                         in the y-direction, where unit may be: none\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|STDERR
argument_list|,
literal|"                         (default centimeters), c (centimeters), i\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|STDERR
argument_list|,
literal|"                         (inches), p (points), P (Picas). The shift\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|STDERR
argument_list|,
literal|"                         is independent of the -L and -R switches\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|STDERR
argument_list|,
literal|"                         (i.e., the y-direction is the same as the\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|STDERR
argument_list|,
literal|"                         unrotated image).\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|STDERR
argument_list|,
literal|"          infile [pagerange]\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|STDERR
argument_list|,
literal|"                         See the manual page for syntax details.\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|STDERR
argument_list|,
literal|"            Example:\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|STDERR
argument_list|,
literal|"              [1,4-6,9[pic1],10-11,12[pic2:2(2P,4P)][pic3(-4P,-2P)],15-]\n\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/***  end of file = IPFE.C  *************************************/
end_comment

end_unit

