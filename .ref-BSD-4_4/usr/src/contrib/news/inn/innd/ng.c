begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  $Revision: 1.19 $ ** **  Routine for the in-core data structures for the active and newsfeeds **  files. */
end_comment

begin_include
include|#
directive|include
file|"innd.h"
end_include

begin_include
include|#
directive|include
file|"mydir.h"
end_include

begin_comment
comment|/* **  Hash function taken from Chris Torek's hash package posted to **  comp.lang.c on 18-Oct-90 in<27038@mimsy.umd.edu>.  Thanks, Chris. */
end_comment

begin_define
define|#
directive|define
name|NGH_HASH
parameter_list|(
name|Name
parameter_list|,
name|p
parameter_list|,
name|j
parameter_list|)
define|\
value|for (p = Name, j = 0; *p; ) j = (j<< 5) + j + *p++
end_define

begin_comment
comment|/* **  Size of hash table.   Change NGH_BUCKET if not a power of two. */
end_comment

begin_define
define|#
directive|define
name|NGH_SIZE
value|512
end_define

begin_define
define|#
directive|define
name|NGH_BUCKET
parameter_list|(
name|j
parameter_list|)
value|&NGHtable[j& (NGH_SIZE - 1)]
end_define

begin_comment
comment|/* **  Newsgroup hash entry, which is really a hash bucket -- pointers **  to all the groups with this hash code. */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|_NGHASH
block|{
name|int
name|Size
decl_stmt|;
name|int
name|Used
decl_stmt|;
name|NEWSGROUP
modifier|*
modifier|*
name|Groups
decl_stmt|;
block|}
name|NGHASH
typedef|;
end_typedef

begin_decl_stmt
name|STATIC
name|BUFFER
name|NGdirs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|BUFFER
name|NGnames
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|NGHASH
name|NGHtable
index|[
name|NGH_SIZE
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|int
name|NGHbuckets
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|int
name|NGHcount
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* **  Sorting predicate for qsort call in NGparsefile.  Put newsgroups in **  rough order of their activity.  Will be better if we write a "counts" **  file sometime. */
end_comment

begin_function
name|STATIC
name|int
name|NGcompare
parameter_list|(
name|p1
parameter_list|,
name|p2
parameter_list|)
name|POINTER
name|p1
decl_stmt|;
name|POINTER
name|p2
decl_stmt|;
block|{
name|NEWSGROUP
modifier|*
modifier|*
name|ng1
decl_stmt|;
name|NEWSGROUP
modifier|*
modifier|*
name|ng2
decl_stmt|;
name|ng1
operator|=
name|CAST
argument_list|(
name|NEWSGROUP
operator|*
operator|*
argument_list|,
name|p1
argument_list|)
expr_stmt|;
name|ng2
operator|=
name|CAST
argument_list|(
name|NEWSGROUP
operator|*
operator|*
argument_list|,
name|p2
argument_list|)
expr_stmt|;
return|return
name|ng1
index|[
literal|0
index|]
operator|->
name|Last
operator|-
name|ng2
index|[
literal|0
index|]
operator|->
name|Last
return|;
block|}
end_function

begin_comment
comment|/* **  Convert a newsgroup name into a directory name. */
end_comment

begin_function
name|STATIC
name|void
name|NGdirname
parameter_list|(
name|p
parameter_list|)
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
block|{
for|for
control|(
init|;
operator|*
name|p
condition|;
name|p
operator|++
control|)
if|if
condition|(
operator|*
name|p
operator|==
literal|'.'
condition|)
operator|*
name|p
operator|=
literal|'/'
expr_stmt|;
block|}
end_function

begin_comment
comment|/* **  Parse a single line from the active file, filling in ngp.  Be careful **  not to write NUL's into the in-core copy, since we're either mmap(2)'d, **  or we want to just blat it out to disk later. */
end_comment

begin_function
name|STATIC
name|BOOL
name|NGparseentry
parameter_list|(
name|ngp
parameter_list|,
name|p
parameter_list|,
name|end
parameter_list|)
specifier|register
name|NEWSGROUP
modifier|*
name|ngp
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|char
modifier|*
name|end
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|q
decl_stmt|;
specifier|register
name|unsigned
name|int
name|j
decl_stmt|;
specifier|register
name|NGHASH
modifier|*
name|htp
decl_stmt|;
specifier|register
name|NEWSGROUP
modifier|*
modifier|*
name|ngpp
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|(
name|q
operator|=
name|strchr
argument_list|(
name|p
argument_list|,
literal|' '
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|i
operator|=
name|q
operator|-
name|p
expr_stmt|;
name|ngp
operator|->
name|NameLength
operator|=
name|i
expr_stmt|;
name|ngp
operator|->
name|Name
operator|=
operator|&
name|NGnames
operator|.
name|Data
index|[
name|NGnames
operator|.
name|Used
index|]
expr_stmt|;
operator|(
name|void
operator|)
name|strncpy
argument_list|(
name|ngp
operator|->
name|Name
argument_list|,
name|p
argument_list|,
operator|(
name|SIZE_T
operator|)
name|i
argument_list|)
expr_stmt|;
name|ngp
operator|->
name|Name
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
name|NGnames
operator|.
name|Used
operator|+=
name|i
operator|+
literal|1
expr_stmt|;
name|ngp
operator|->
name|Dir
operator|=
operator|&
name|NGdirs
operator|.
name|Data
index|[
name|NGdirs
operator|.
name|Used
index|]
expr_stmt|;
operator|(
name|void
operator|)
name|strncpy
argument_list|(
name|ngp
operator|->
name|Dir
argument_list|,
name|p
argument_list|,
operator|(
name|SIZE_T
operator|)
name|i
argument_list|)
expr_stmt|;
name|ngp
operator|->
name|Dir
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
name|NGdirs
operator|.
name|Used
operator|+=
name|i
operator|+
literal|1
expr_stmt|;
name|NGdirname
argument_list|(
name|ngp
operator|->
name|Dir
argument_list|)
expr_stmt|;
name|ngp
operator|->
name|LastString
operator|=
operator|++
name|q
expr_stmt|;
if|if
condition|(
operator|(
name|q
operator|=
name|strchr
argument_list|(
name|q
argument_list|,
literal|' '
argument_list|)
operator|)
operator|==
name|NULL
operator|||
name|q
operator|>
name|end
condition|)
return|return
name|FALSE
return|;
name|ngp
operator|->
name|Lastwidth
operator|=
name|q
operator|-
name|ngp
operator|->
name|LastString
expr_stmt|;
if|if
condition|(
operator|(
name|q
operator|=
name|strchr
argument_list|(
name|q
argument_list|,
literal|' '
argument_list|)
operator|)
operator|==
name|NULL
operator|||
name|q
operator|>
name|end
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
operator|(
name|q
operator|=
name|strchr
argument_list|(
name|q
operator|+
literal|1
argument_list|,
literal|' '
argument_list|)
operator|)
operator|==
name|NULL
operator|||
name|q
operator|>
name|end
condition|)
return|return
name|FALSE
return|;
name|ngp
operator|->
name|Rest
operator|=
operator|++
name|q
expr_stmt|;
comment|/* We count on atoi() to stop at the space after the digits! */
name|ngp
operator|->
name|Last
operator|=
name|atol
argument_list|(
name|ngp
operator|->
name|LastString
argument_list|)
expr_stmt|;
name|ngp
operator|->
name|nSites
operator|=
literal|0
expr_stmt|;
name|ngp
operator|->
name|Sites
operator|=
name|NEW
argument_list|(
name|int
argument_list|,
name|NGHcount
argument_list|)
expr_stmt|;
name|ngp
operator|->
name|Alias
operator|=
name|NULL
expr_stmt|;
comment|/* Find the right bucket for the group, make sure there is room. */
comment|/* SUPPRESS 6 */
comment|/* Over/underflow from plus expression */
name|NGH_HASH
argument_list|(
name|ngp
operator|->
name|Name
argument_list|,
name|p
argument_list|,
name|j
argument_list|)
expr_stmt|;
name|htp
operator|=
name|NGH_BUCKET
argument_list|(
name|j
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|ngp
operator|->
name|Name
operator|,
name|ngpp
operator|=
name|htp
operator|->
name|Groups
operator|,
name|i
operator|=
name|htp
operator|->
name|Used
init|;
operator|--
name|i
operator|>=
literal|0
condition|;
name|ngpp
operator|++
control|)
if|if
condition|(
operator|*
name|p
operator|==
name|ngpp
index|[
literal|0
index|]
operator|->
name|Name
index|[
literal|0
index|]
operator|&&
name|EQ
argument_list|(
name|p
argument_list|,
name|ngpp
index|[
literal|0
index|]
operator|->
name|Name
argument_list|)
condition|)
block|{
name|syslog
argument_list|(
name|L_ERROR
argument_list|,
literal|"%s duplicate_group %s"
argument_list|,
name|LogName
argument_list|,
name|p
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|htp
operator|->
name|Used
operator|>=
name|htp
operator|->
name|Size
condition|)
block|{
name|htp
operator|->
name|Size
operator|+=
name|NGHbuckets
expr_stmt|;
name|RENEW
argument_list|(
name|htp
operator|->
name|Groups
argument_list|,
name|NEWSGROUP
operator|*
argument_list|,
name|htp
operator|->
name|Size
argument_list|)
expr_stmt|;
block|}
name|htp
operator|->
name|Groups
index|[
name|htp
operator|->
name|Used
operator|++
index|]
operator|=
name|ngp
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* **  Parse the active file, building the initial Groups global. */
end_comment

begin_function
name|void
name|NGparsefile
parameter_list|()
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|char
modifier|*
name|q
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|BOOL
name|SawMe
decl_stmt|;
specifier|register
name|NEWSGROUP
modifier|*
name|ngp
decl_stmt|;
specifier|register
name|NGHASH
modifier|*
name|htp
decl_stmt|;
name|char
modifier|*
modifier|*
name|strings
decl_stmt|;
name|char
modifier|*
name|active
decl_stmt|;
name|char
modifier|*
name|end
decl_stmt|;
comment|/* If re-reading, remove anything we might have had. */
if|if
condition|(
name|Groups
condition|)
block|{
for|for
control|(
name|i
operator|=
name|nGroups
operator|,
name|ngp
operator|=
name|Groups
init|;
operator|--
name|i
operator|>=
literal|0
condition|;
name|ngp
operator|++
control|)
name|DISPOSE
argument_list|(
name|ngp
operator|->
name|Sites
argument_list|)
expr_stmt|;
name|DISPOSE
argument_list|(
name|Groups
argument_list|)
expr_stmt|;
name|DISPOSE
argument_list|(
name|GroupPointers
argument_list|)
expr_stmt|;
name|DISPOSE
argument_list|(
name|NGdirs
operator|.
name|Data
argument_list|)
expr_stmt|;
name|DISPOSE
argument_list|(
name|NGnames
operator|.
name|Data
argument_list|)
expr_stmt|;
block|}
comment|/* Get active file and space for group entries. */
name|active
operator|=
name|ICDreadactive
argument_list|(
operator|&
name|end
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|active
operator|,
name|i
operator|=
literal|0
init|;
name|p
operator|<
name|end
operator|&&
operator|(
name|p
operator|=
name|strchr
argument_list|(
name|p
argument_list|,
literal|'\n'
argument_list|)
operator|)
operator|!=
name|NULL
condition|;
name|p
operator|++
operator|,
name|i
operator|++
control|)
continue|continue;
name|nGroups
operator|=
name|i
expr_stmt|;
name|Groups
operator|=
name|NEW
argument_list|(
name|NEWSGROUP
argument_list|,
name|nGroups
argument_list|)
expr_stmt|;
name|GroupPointers
operator|=
name|NEW
argument_list|(
name|NEWSGROUP
operator|*
argument_list|,
name|nGroups
argument_list|)
expr_stmt|;
comment|/* Get space to hold copies of the names and the directory names.      * This might take more space than individually allocating each      * element, but it is definitely easier on the system. */
name|i
operator|=
name|end
operator|-
name|active
expr_stmt|;
name|NGdirs
operator|.
name|Size
operator|=
name|i
expr_stmt|;
name|NGdirs
operator|.
name|Data
operator|=
name|NEW
argument_list|(
name|char
argument_list|,
name|NGdirs
operator|.
name|Size
operator|+
literal|1
argument_list|)
expr_stmt|;
name|NGdirs
operator|.
name|Used
operator|=
literal|0
expr_stmt|;
name|NGnames
operator|.
name|Size
operator|=
name|i
expr_stmt|;
name|NGnames
operator|.
name|Data
operator|=
name|NEW
argument_list|(
name|char
argument_list|,
name|NGnames
operator|.
name|Size
operator|+
literal|1
argument_list|)
expr_stmt|;
name|NGnames
operator|.
name|Used
operator|=
literal|0
expr_stmt|;
comment|/* Set up the default hash buckets. */
name|NGHbuckets
operator|=
name|nGroups
operator|/
name|NGH_SIZE
expr_stmt|;
if|if
condition|(
name|NGHbuckets
operator|==
literal|0
condition|)
name|NGHbuckets
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|NGHtable
index|[
literal|0
index|]
operator|.
name|Groups
condition|)
for|for
control|(
name|i
operator|=
name|NGH_SIZE
operator|,
name|htp
operator|=
name|NGHtable
init|;
operator|--
name|i
operator|>=
literal|0
condition|;
name|htp
operator|++
control|)
name|htp
operator|->
name|Used
operator|=
literal|0
expr_stmt|;
else|else
for|for
control|(
name|i
operator|=
name|NGH_SIZE
operator|,
name|htp
operator|=
name|NGHtable
init|;
operator|--
name|i
operator|>=
literal|0
condition|;
name|htp
operator|++
control|)
block|{
name|htp
operator|->
name|Size
operator|=
name|NGHbuckets
expr_stmt|;
name|htp
operator|->
name|Groups
operator|=
name|NEW
argument_list|(
name|NEWSGROUP
operator|*
argument_list|,
name|htp
operator|->
name|Size
argument_list|)
expr_stmt|;
name|htp
operator|->
name|Used
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Count the number of sites. */
name|SawMe
operator|=
name|FALSE
expr_stmt|;
for|for
control|(
name|strings
operator|=
name|SITEreadfile
argument_list|(
name|TRUE
argument_list|)
operator|,
name|i
operator|=
literal|0
init|;
operator|(
name|p
operator|=
name|strings
index|[
name|i
index|]
operator|)
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|*
name|p
operator|==
literal|'M'
operator|&&
operator|*
operator|++
name|p
operator|==
literal|'E'
operator|&&
operator|*
operator|++
name|p
operator|==
literal|':'
condition|)
name|SawMe
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
operator|||
operator|(
name|i
operator|==
literal|1
operator|&&
name|SawMe
operator|)
condition|)
block|{
name|syslog
argument_list|(
name|L_ERROR
argument_list|,
literal|"%s bad_newsfeeds no feeding sites"
argument_list|,
name|LogName
argument_list|)
expr_stmt|;
name|NGHcount
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|NGHcount
operator|=
name|i
expr_stmt|;
comment|/* Loop over all lines in the active file, filling in the fields of      * the Groups array. */
for|for
control|(
name|p
operator|=
name|active
operator|,
name|ngp
operator|=
name|Groups
operator|,
name|i
operator|=
name|nGroups
init|;
operator|--
name|i
operator|>=
literal|0
condition|;
name|ngp
operator|++
operator|,
name|p
operator|=
name|q
operator|+
literal|1
control|)
block|{
name|ngp
operator|->
name|Start
operator|=
name|p
operator|-
name|active
expr_stmt|;
if|if
condition|(
operator|(
name|q
operator|=
name|strchr
argument_list|(
name|p
argument_list|,
literal|'\n'
argument_list|)
operator|)
operator|==
name|NULL
operator|||
operator|!
name|NGparseentry
argument_list|(
name|ngp
argument_list|,
name|p
argument_list|,
name|q
argument_list|)
condition|)
block|{
name|syslog
argument_list|(
name|L_FATAL
argument_list|,
literal|"%s bad_active %s..."
argument_list|,
name|LogName
argument_list|,
name|MaxLength
argument_list|(
name|p
argument_list|,
name|p
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Sort each bucket. */
for|for
control|(
name|i
operator|=
name|NGH_SIZE
operator|,
name|htp
operator|=
name|NGHtable
init|;
operator|--
name|i
operator|>=
literal|0
condition|;
name|htp
operator|++
control|)
if|if
condition|(
name|htp
operator|->
name|Used
operator|>
literal|1
condition|)
name|qsort
argument_list|(
operator|(
name|POINTER
operator|)
name|htp
operator|->
name|Groups
argument_list|,
operator|(
name|SIZE_T
operator|)
name|htp
operator|->
name|Used
argument_list|,
sizeof|sizeof
name|htp
operator|->
name|Groups
index|[
literal|0
index|]
argument_list|,
name|NGcompare
argument_list|)
expr_stmt|;
comment|/* Chase down any alias flags. */
for|for
control|(
name|ngp
operator|=
name|Groups
operator|,
name|i
operator|=
name|nGroups
init|;
operator|--
name|i
operator|>=
literal|0
condition|;
name|ngp
operator|++
control|)
if|if
condition|(
name|ngp
operator|->
name|Rest
index|[
literal|0
index|]
operator|==
name|NF_FLAG_ALIAS
condition|)
block|{
name|ngp
operator|->
name|Alias
operator|=
name|ngp
expr_stmt|;
if|if
condition|(
operator|(
name|p
operator|=
name|strchr
argument_list|(
name|ngp
operator|->
name|Alias
operator|->
name|Rest
argument_list|,
literal|'\n'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
name|ngp
operator|->
name|Alias
operator|=
name|NGfind
argument_list|(
operator|&
name|ngp
operator|->
name|Alias
operator|->
name|Rest
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
condition|)
operator|*
name|p
operator|=
literal|'\n'
expr_stmt|;
if|if
condition|(
name|ngp
operator|->
name|Alias
operator|!=
name|NULL
operator|&&
name|ngp
operator|->
name|Alias
operator|->
name|Rest
index|[
literal|0
index|]
operator|==
name|NF_FLAG_ALIAS
condition|)
name|syslog
argument_list|(
name|L_NOTICE
argument_list|,
literal|"%s alias_error %s too many levels"
argument_list|,
name|LogName
argument_list|,
name|ngp
operator|->
name|Name
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* **  Hash a newsgroup and see if we get it. */
end_comment

begin_function
name|NEWSGROUP
modifier|*
name|NGfind
parameter_list|(
name|Name
parameter_list|)
name|char
modifier|*
name|Name
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|unsigned
name|int
name|j
decl_stmt|;
specifier|register
name|NEWSGROUP
modifier|*
modifier|*
name|ngp
decl_stmt|;
name|char
name|c
decl_stmt|;
name|NGHASH
modifier|*
name|htp
decl_stmt|;
comment|/* SUPPRESS 6 */
comment|/* Over/underflow from plus expression */
name|NGH_HASH
argument_list|(
name|Name
argument_list|,
name|p
argument_list|,
name|j
argument_list|)
expr_stmt|;
name|htp
operator|=
name|NGH_BUCKET
argument_list|(
name|j
argument_list|)
expr_stmt|;
for|for
control|(
name|c
operator|=
operator|*
name|Name
operator|,
name|ngp
operator|=
name|htp
operator|->
name|Groups
operator|,
name|i
operator|=
name|htp
operator|->
name|Used
init|;
operator|--
name|i
operator|>=
literal|0
condition|;
name|ngp
operator|++
control|)
if|if
condition|(
name|c
operator|==
name|ngp
index|[
literal|0
index|]
operator|->
name|Name
index|[
literal|0
index|]
operator|&&
name|EQ
argument_list|(
name|Name
argument_list|,
name|ngp
index|[
literal|0
index|]
operator|->
name|Name
argument_list|)
condition|)
return|return
name|ngp
index|[
literal|0
index|]
return|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* **  Split a newsgroups header line into the groups we get.  Return a **  point to static memory and clobber the argument along the way. */
end_comment

begin_function
name|char
modifier|*
modifier|*
name|NGsplit
parameter_list|(
name|p
parameter_list|)
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
block|{
specifier|static
name|char
modifier|*
modifier|*
name|groups
decl_stmt|;
specifier|static
name|int
name|oldlength
decl_stmt|;
specifier|register
name|char
modifier|*
modifier|*
name|gp
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
comment|/* Get an array of character pointers. */
name|i
operator|=
name|strlen
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|groups
operator|==
name|NULL
condition|)
block|{
name|groups
operator|=
name|NEW
argument_list|(
name|char
operator|*
argument_list|,
name|i
operator|+
literal|1
argument_list|)
expr_stmt|;
name|oldlength
operator|=
name|i
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|oldlength
operator|<
name|i
condition|)
block|{
name|RENEW
argument_list|(
name|groups
argument_list|,
name|char
operator|*
argument_list|,
name|i
operator|+
literal|1
argument_list|)
expr_stmt|;
name|oldlength
operator|=
name|i
expr_stmt|;
block|}
comment|/* Loop over text. */
for|for
control|(
name|gp
operator|=
name|groups
init|;
operator|*
name|p
condition|;
operator|*
name|p
operator|++
operator|=
literal|'\0'
control|)
block|{
comment|/* Skip leading separators. */
for|for
control|(
init|;
name|NG_ISSEP
argument_list|(
operator|*
name|p
argument_list|)
condition|;
name|p
operator|++
control|)
continue|continue;
if|if
condition|(
operator|*
name|p
operator|==
literal|'\0'
condition|)
break|break;
comment|/* Mark the start of the newsgroup, move to the end of it. */
for|for
control|(
operator|*
name|gp
operator|++
operator|=
name|p
init|;
operator|*
name|p
operator|&&
operator|!
name|NG_ISSEP
argument_list|(
operator|*
name|p
argument_list|)
condition|;
name|p
operator|++
control|)
continue|continue;
if|if
condition|(
operator|*
name|p
operator|==
literal|'\0'
condition|)
break|break;
block|}
operator|*
name|gp
operator|=
name|NULL
expr_stmt|;
return|return
name|groups
return|;
block|}
end_function

begin_comment
comment|/* **  Renumber a group. */
end_comment

begin_function
name|BOOL
name|NGrenumber
parameter_list|(
name|ngp
parameter_list|)
name|NEWSGROUP
modifier|*
name|ngp
decl_stmt|;
block|{
specifier|static
name|char
name|NORENUMBER
index|[]
init|=
literal|"%s cant renumber %s %s too wide"
decl_stmt|;
specifier|static
name|char
name|RENUMBER
index|[]
init|=
literal|"%s renumber %s %s from %ld to %ld"
decl_stmt|;
specifier|register
name|DIR
modifier|*
name|dp
decl_stmt|;
specifier|register
name|DIRENTRY
modifier|*
name|ep
decl_stmt|;
specifier|register
name|char
modifier|*
name|f2
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|f3
decl_stmt|;
name|char
modifier|*
name|f4
decl_stmt|;
name|char
modifier|*
name|start
decl_stmt|;
name|long
name|l
decl_stmt|;
name|long
name|himark
decl_stmt|;
name|long
name|lomark
decl_stmt|;
name|char
modifier|*
name|dummy
decl_stmt|;
comment|/* Get a valid offset into the active file. */
if|if
condition|(
name|ICDneedsetup
condition|)
block|{
name|syslog
argument_list|(
name|L_ERROR
argument_list|,
literal|"%s unsynched must reload before renumber"
argument_list|,
name|LogName
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|start
operator|=
name|ICDreadactive
argument_list|(
operator|&
name|dummy
argument_list|)
operator|+
name|ngp
operator|->
name|Start
expr_stmt|;
comment|/* Check the file format. */
if|if
condition|(
operator|(
name|f2
operator|=
name|strchr
argument_list|(
name|start
argument_list|,
literal|' '
argument_list|)
operator|)
operator|==
name|NULL
operator|||
operator|(
name|f3
operator|=
name|strchr
argument_list|(
operator|++
name|f2
argument_list|,
literal|' '
argument_list|)
operator|)
operator|==
name|NULL
operator|||
operator|(
name|f4
operator|=
name|strchr
argument_list|(
operator|++
name|f3
argument_list|,
literal|' '
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|syslog
argument_list|(
name|L_ERROR
argument_list|,
literal|"%s bad_format active %s"
argument_list|,
name|LogName
argument_list|,
name|MaxLength
argument_list|(
name|start
argument_list|,
name|start
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|himark
operator|=
name|atol
argument_list|(
name|f2
argument_list|)
expr_stmt|;
name|lomark
operator|=
name|himark
operator|+
literal|1
expr_stmt|;
comment|/* Scan the directory. */
if|if
condition|(
operator|(
name|dp
operator|=
name|opendir
argument_list|(
name|ngp
operator|->
name|Dir
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
while|while
condition|(
operator|(
name|ep
operator|=
name|readdir
argument_list|(
name|dp
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|p
operator|=
name|ep
operator|->
name|d_name
expr_stmt|;
if|if
condition|(
operator|!
name|CTYPE
argument_list|(
name|isdigit
argument_list|,
name|p
index|[
literal|0
index|]
argument_list|)
operator|||
name|strspn
argument_list|(
name|p
argument_list|,
literal|"0123456789"
argument_list|)
operator|!=
name|strlen
argument_list|(
name|p
argument_list|)
operator|||
operator|(
name|l
operator|=
name|atol
argument_list|(
name|p
argument_list|)
operator|)
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|l
operator|<
name|lomark
condition|)
name|lomark
operator|=
name|l
expr_stmt|;
if|if
condition|(
name|l
operator|>
name|himark
condition|)
name|himark
operator|=
name|l
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|closedir
argument_list|(
name|dp
argument_list|)
expr_stmt|;
block|}
name|l
operator|=
name|atol
argument_list|(
name|f2
argument_list|)
expr_stmt|;
if|if
condition|(
name|himark
operator|!=
name|l
condition|)
block|{
name|syslog
argument_list|(
name|L_NOTICE
argument_list|,
name|RENUMBER
argument_list|,
name|LogName
argument_list|,
name|ngp
operator|->
name|Name
argument_list|,
literal|"hi"
argument_list|,
name|l
argument_list|,
name|himark
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|FormatLong
argument_list|(
name|f2
argument_list|,
name|himark
argument_list|,
name|f3
operator|-
name|f2
operator|-
literal|1
argument_list|)
condition|)
block|{
name|syslog
argument_list|(
name|L_NOTICE
argument_list|,
name|NORENUMBER
argument_list|,
name|LogName
argument_list|,
name|ngp
operator|->
name|Name
argument_list|,
literal|"hi"
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|ngp
operator|->
name|Last
operator|=
name|himark
expr_stmt|;
name|ICDactivedirty
operator|++
expr_stmt|;
block|}
name|l
operator|=
name|atol
argument_list|(
name|f3
argument_list|)
expr_stmt|;
if|if
condition|(
name|lomark
operator|!=
name|l
condition|)
block|{
if|if
condition|(
name|lomark
operator|<
name|l
condition|)
name|syslog
argument_list|(
name|L_NOTICE
argument_list|,
name|RENUMBER
argument_list|,
name|LogName
argument_list|,
name|ngp
operator|->
name|Name
argument_list|,
literal|"lo"
argument_list|,
name|l
argument_list|,
name|lomark
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|FormatLong
argument_list|(
name|f3
argument_list|,
name|lomark
argument_list|,
name|f4
operator|-
name|f3
argument_list|)
condition|)
block|{
name|syslog
argument_list|(
name|L_NOTICE
argument_list|,
name|NORENUMBER
argument_list|,
name|LogName
argument_list|,
name|ngp
operator|->
name|Name
argument_list|,
literal|"lo"
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|ICDactivedirty
operator|++
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

end_unit

