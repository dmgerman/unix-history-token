begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  $Revision: 1.14 $ ** **  Rebuild the history database. */
end_comment

begin_include
include|#
directive|include
file|"configdata.h"
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|DO_NEED_TIME
argument_list|)
end_if

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* defined(DO_NEED_TIME) */
end_comment

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|"paths.h"
end_include

begin_include
include|#
directive|include
file|"libinn.h"
end_include

begin_include
include|#
directive|include
file|"clibrary.h"
end_include

begin_include
include|#
directive|include
file|"inndcomm.h"
end_include

begin_include
include|#
directive|include
file|"dbz.h"
end_include

begin_include
include|#
directive|include
file|"qio.h"
end_include

begin_include
include|#
directive|include
file|"macros.h"
end_include

begin_include
include|#
directive|include
file|"mydir.h"
end_include

begin_typedef
typedef|typedef
struct|struct
name|_BUFFER
block|{
name|char
modifier|*
name|Data
decl_stmt|;
name|int
name|Size
decl_stmt|;
name|int
name|Used
decl_stmt|;
block|}
name|BUFFER
typedef|;
end_typedef

begin_decl_stmt
name|STATIC
name|char
name|ACTIVE
index|[]
init|=
name|_PATH_ACTIVE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|char
name|SPOOL
index|[]
init|=
name|_PATH_SPOOL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|char
modifier|*
name|HISTORYDIR
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|char
name|HISTORY
index|[]
init|=
name|_PATH_HISTORY
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|char
name|MESSAGEID
index|[]
init|=
literal|"Message-ID:"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|char
name|EXPIRES
index|[]
init|=
literal|"Expires:"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|char
name|DATE
index|[]
init|=
literal|"Date:"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|BOOL
name|INNDrunning
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|char
modifier|*
name|TextFile
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|char
name|Reason
index|[]
init|=
literal|"makehistory is running"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|TIMEINFO
name|Now
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|extern
name|long
name|dbztagmask
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* **  Change to a directory or exit out. */
end_comment

begin_function
name|STATIC
name|void
name|xchdir
parameter_list|(
name|where
parameter_list|)
name|char
modifier|*
name|where
decl_stmt|;
block|{
if|if
condition|(
name|chdir
argument_list|(
name|where
argument_list|)
operator|<
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Can't change to \"%s\", %s\n"
argument_list|,
name|where
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* **  Remove the DBZ files for the specified base text file. */
end_comment

begin_function
name|STATIC
name|void
name|RemoveDBZFiles
parameter_list|(
name|p
parameter_list|)
name|char
modifier|*
name|p
decl_stmt|;
block|{
specifier|static
name|char
name|NOCANDO
index|[]
init|=
literal|"Can't remove \"%s\", %s\n"
decl_stmt|;
name|char
name|buff
index|[
name|SMBUF
index|]
decl_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buff
argument_list|,
literal|"%s.dir"
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlink
argument_list|(
name|buff
argument_list|)
operator|&&
name|errno
operator|!=
name|ENOENT
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|NOCANDO
argument_list|,
name|buff
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buff
argument_list|,
literal|"%s.pag"
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlink
argument_list|(
name|buff
argument_list|)
operator|&&
name|errno
operator|!=
name|ENOENT
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|NOCANDO
argument_list|,
name|buff
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* **  Rebuild the DBZ file from the text file. */
end_comment

begin_function
name|STATIC
name|void
name|Rebuild
parameter_list|(
name|size
parameter_list|,
name|IgnoreOld
parameter_list|,
name|Overwrite
parameter_list|)
name|long
name|size
decl_stmt|;
name|BOOL
name|IgnoreOld
decl_stmt|;
name|BOOL
name|Overwrite
decl_stmt|;
block|{
specifier|register
name|QIOSTATE
modifier|*
name|qp
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|char
modifier|*
name|save
decl_stmt|;
specifier|register
name|long
name|count
decl_stmt|;
name|long
name|where
decl_stmt|;
name|datum
name|key
decl_stmt|;
name|datum
name|value
decl_stmt|;
name|char
name|temp
index|[
name|SMBUF
index|]
decl_stmt|;
name|xchdir
argument_list|(
name|HISTORYDIR
argument_list|)
expr_stmt|;
comment|/* Open the text file. */
name|qp
operator|=
name|QIOopen
argument_list|(
name|TextFile
argument_list|,
name|QIO_BUFFER
argument_list|)
expr_stmt|;
if|if
condition|(
name|qp
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Can't open \"%s\", %s\n"
argument_list|,
name|TextFile
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* If using the standard history file, force DBZ to use history.n. */
if|if
condition|(
name|EQ
argument_list|(
name|TextFile
argument_list|,
name|HISTORY
argument_list|)
operator|&&
operator|!
name|Overwrite
condition|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|temp
argument_list|,
literal|"%s.n"
argument_list|,
name|HISTORY
argument_list|)
expr_stmt|;
if|if
condition|(
name|link
argument_list|(
name|HISTORY
argument_list|,
name|temp
argument_list|)
operator|<
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Can't make temporary link to \"%s\", %s\n"
argument_list|,
name|temp
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|RemoveDBZFiles
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|p
operator|=
name|temp
expr_stmt|;
block|}
else|else
block|{
name|temp
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|RemoveDBZFiles
argument_list|(
name|TextFile
argument_list|)
expr_stmt|;
name|p
operator|=
name|TextFile
expr_stmt|;
block|}
comment|/* Open the new database, using the old file if desired and possible. */
operator|(
name|void
operator|)
name|dbzincore
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|IgnoreOld
condition|)
block|{
if|if
condition|(
name|dbzfresh
argument_list|(
name|p
argument_list|,
name|dbzsize
argument_list|(
name|size
argument_list|)
argument_list|,
name|HIS_FIELDSEP
argument_list|,
literal|'C'
argument_list|,
name|dbztagmask
argument_list|(
name|size
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Can't do dbzfresh, %s\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
index|[
literal|0
index|]
condition|)
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|dbzagain
argument_list|(
name|p
argument_list|,
name|HISTORY
argument_list|)
operator|<
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Can't do dbzagain, %s\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
index|[
literal|0
index|]
condition|)
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Set up the value pointer. */
name|value
operator|.
name|dptr
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|where
expr_stmt|;
name|value
operator|.
name|dsize
operator|=
sizeof|sizeof
name|where
expr_stmt|;
comment|/* Loop through all lines in the text file. */
name|count
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|where
operator|=
name|QIOtell
argument_list|(
name|qp
argument_list|)
init|;
operator|(
name|p
operator|=
name|QIOread
argument_list|(
name|qp
argument_list|)
operator|)
operator|!=
name|NULL
condition|;
name|where
operator|=
name|QIOtell
argument_list|(
name|qp
argument_list|)
control|)
block|{
name|count
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|save
operator|=
name|strchr
argument_list|(
name|p
argument_list|,
name|HIS_FIELDSEP
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Bad line #%ld \"%.30s...\"\n"
argument_list|,
name|count
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
index|[
literal|0
index|]
condition|)
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
operator|*
name|save
operator|=
literal|'\0'
expr_stmt|;
name|key
operator|.
name|dptr
operator|=
name|p
expr_stmt|;
name|key
operator|.
name|dsize
operator|=
name|save
operator|-
name|p
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|dbzstore
argument_list|(
name|key
argument_list|,
name|value
argument_list|)
operator|<
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Can't store \"%s\", %s\n"
argument_list|,
name|p
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
index|[
literal|0
index|]
condition|)
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|QIOerror
argument_list|(
name|qp
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Can't read \"%s\" near line %ld, %s\n"
argument_list|,
name|TextFile
argument_list|,
name|count
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
index|[
literal|0
index|]
condition|)
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|QIOtoolong
argument_list|(
name|qp
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Line %ld is too long\n"
argument_list|,
name|count
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
index|[
literal|0
index|]
condition|)
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Close files. */
name|QIOclose
argument_list|(
name|qp
argument_list|)
expr_stmt|;
if|if
condition|(
name|dbmclose
argument_list|()
operator|<
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Can't close history, %s\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
index|[
literal|0
index|]
condition|)
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|temp
index|[
literal|0
index|]
condition|)
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|temp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* **  Remove a bad article. */
end_comment

begin_function
name|STATIC
name|void
name|Removeit
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|char
modifier|*
name|p
decl_stmt|;
comment|/* Already in the spool directory, so skip right past the name;      * the strchr can't return NULL. */
name|p
operator|=
name|strchr
argument_list|(
name|name
argument_list|,
literal|'/'
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|unlink
argument_list|(
name|p
argument_list|)
operator|<
literal|0
operator|&&
name|errno
operator|!=
name|ENOENT
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Can't unlink %s, %s\n"
argument_list|,
name|name
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Removing %s\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* **  Check and parse a Message-ID header line.  Return an allocated copy **  or a static empty string on error. */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|GetMessageID
parameter_list|(
name|p
parameter_list|)
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
block|{
specifier|static
name|char
name|NIL
index|[]
init|=
literal|""
decl_stmt|;
name|char
modifier|*
name|save
decl_stmt|;
while|while
condition|(
name|ISWHITE
argument_list|(
operator|*
name|p
argument_list|)
condition|)
name|p
operator|++
expr_stmt|;
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|!=
literal|'<'
operator|||
name|p
index|[
name|strlen
argument_list|(
name|p
argument_list|)
operator|-
literal|1
index|]
operator|!=
literal|'>'
condition|)
return|return
name|NIL
return|;
for|for
control|(
name|save
operator|=
name|COPY
argument_list|(
name|p
argument_list|)
operator|,
name|p
operator|=
name|save
init|;
operator|*
name|p
condition|;
name|p
operator|++
control|)
if|if
condition|(
operator|*
name|p
operator|==
name|HIS_FIELDSEP
condition|)
operator|*
name|p
operator|=
name|HIS_BADCHAR
expr_stmt|;
return|return
name|save
return|;
block|}
end_function

begin_comment
comment|/* **  Check and parse an date header line.  Return the new value or **  zero on error. */
end_comment

begin_function
specifier|static
name|long
name|GetaDate
parameter_list|(
name|p
parameter_list|)
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
block|{
name|time_t
name|t
decl_stmt|;
while|while
condition|(
name|ISWHITE
argument_list|(
operator|*
name|p
argument_list|)
condition|)
name|p
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|t
operator|=
name|parsedate
argument_list|(
name|p
argument_list|,
operator|&
name|Now
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
return|return
literal|0L
return|;
return|return
operator|(
name|long
operator|)
name|t
return|;
block|}
end_function

begin_comment
comment|/* **  Process a single article. */
end_comment

begin_function
name|STATIC
name|void
name|DoArticle
parameter_list|(
name|qp
parameter_list|,
name|Sbp
parameter_list|,
name|name
parameter_list|,
name|out
parameter_list|,
name|RemoveBad
parameter_list|,
name|Update
parameter_list|)
specifier|register
name|QIOSTATE
modifier|*
name|qp
decl_stmt|;
name|struct
name|stat
modifier|*
name|Sbp
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|FILE
modifier|*
name|out
decl_stmt|;
name|BOOL
name|RemoveBad
decl_stmt|;
name|BOOL
name|Update
decl_stmt|;
block|{
specifier|static
name|char
name|IGNORE
index|[]
init|=
literal|"Ignoring duplicate %s header in %s\n"
decl_stmt|;
specifier|static
name|char
name|BADHDR
index|[]
init|=
literal|"Bad %s header in %s\n"
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|MessageID
decl_stmt|;
name|time_t
name|Arrived
decl_stmt|;
name|time_t
name|Expires
decl_stmt|;
name|time_t
name|Posted
decl_stmt|;
name|int
name|i
decl_stmt|;
name|datum
name|key
decl_stmt|;
name|datum
name|value
decl_stmt|;
comment|/* Read the file for Message-ID and Expires header. */
name|Arrived
operator|=
name|Sbp
operator|->
name|st_mtime
expr_stmt|;
name|Expires
operator|=
literal|0
expr_stmt|;
name|MessageID
operator|=
name|NULL
expr_stmt|;
name|Posted
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|p
operator|=
name|QIOread
argument_list|(
name|qp
argument_list|)
operator|)
operator|!=
name|NULL
operator|&&
operator|*
name|p
operator|!=
literal|'\0'
condition|)
switch|switch
condition|(
operator|*
name|p
condition|)
block|{
default|default:
break|break;
case|case
literal|'M'
case|:
case|case
literal|'m'
case|:
if|if
condition|(
name|caseEQn
argument_list|(
name|p
argument_list|,
name|MESSAGEID
argument_list|,
name|STRLEN
argument_list|(
name|MESSAGEID
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|MessageID
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|IGNORE
argument_list|,
name|MESSAGEID
argument_list|,
name|name
argument_list|)
expr_stmt|;
else|else
block|{
name|MessageID
operator|=
name|GetMessageID
argument_list|(
operator|&
name|p
index|[
name|STRLEN
argument_list|(
name|MESSAGEID
argument_list|)
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|MessageID
operator|==
literal|'\0'
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|BADHDR
argument_list|,
name|MESSAGEID
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
literal|'E'
case|:
case|case
literal|'e'
case|:
if|if
condition|(
name|caseEQn
argument_list|(
name|p
argument_list|,
name|EXPIRES
argument_list|,
name|STRLEN
argument_list|(
name|EXPIRES
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|Expires
operator|>
literal|0
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|IGNORE
argument_list|,
name|EXPIRES
argument_list|,
name|name
argument_list|)
expr_stmt|;
else|else
block|{
name|Expires
operator|=
name|GetaDate
argument_list|(
operator|&
name|p
index|[
name|STRLEN
argument_list|(
name|EXPIRES
argument_list|)
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|Expires
operator|==
literal|0
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|BADHDR
argument_list|,
name|EXPIRES
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
literal|'D'
case|:
case|case
literal|'d'
case|:
if|if
condition|(
name|caseEQn
argument_list|(
name|p
argument_list|,
name|DATE
argument_list|,
name|STRLEN
argument_list|(
name|DATE
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|Posted
operator|>
literal|0
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|IGNORE
argument_list|,
name|DATE
argument_list|,
name|name
argument_list|)
expr_stmt|;
else|else
block|{
name|Posted
operator|=
name|GetaDate
argument_list|(
operator|&
name|p
index|[
name|STRLEN
argument_list|(
name|DATE
argument_list|)
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|Posted
operator|==
literal|0
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|BADHDR
argument_list|,
name|DATE
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
block|}
comment|/* Check for errors, close the input. */
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|QIOerror
argument_list|(
name|qp
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Can't read %s, %s\n"
argument_list|,
name|name
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|QIOtoolong
argument_list|(
name|qp
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Line too long in %s\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|/* Make sure we have everything we need. */
if|if
condition|(
name|MessageID
operator|==
name|NULL
operator|||
operator|*
name|MessageID
operator|==
literal|'\0'
condition|)
block|{
if|if
condition|(
name|MessageID
operator|==
name|NULL
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"No %s in %s\n"
argument_list|,
name|MESSAGEID
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|RemoveBad
condition|)
name|Removeit
argument_list|(
name|name
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|Update
condition|)
block|{
comment|/* Server already know about this one? */
name|key
operator|.
name|dptr
operator|=
name|MessageID
expr_stmt|;
name|key
operator|.
name|dsize
operator|=
name|strlen
argument_list|(
name|MessageID
argument_list|)
operator|+
literal|1
expr_stmt|;
name|value
operator|=
name|dbzfetch
argument_list|(
name|key
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|.
name|dptr
operator|!=
name|NULL
condition|)
return|return;
block|}
comment|/* Output the line. */
if|if
condition|(
name|Posted
operator|==
literal|0
condition|)
name|Posted
operator|=
name|Arrived
expr_stmt|;
if|if
condition|(
name|Expires
operator|>
literal|0
condition|)
name|i
operator|=
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"%s%c%ld%c%ld%c%ld%c%s\n"
argument_list|,
name|MessageID
argument_list|,
name|HIS_FIELDSEP
argument_list|,
operator|(
name|long
operator|)
name|Arrived
argument_list|,
name|HIS_SUBFIELDSEP
argument_list|,
operator|(
name|long
operator|)
name|Expires
argument_list|,
name|HIS_SUBFIELDSEP
argument_list|,
operator|(
name|long
operator|)
name|Posted
argument_list|,
name|HIS_FIELDSEP
argument_list|,
name|name
argument_list|)
expr_stmt|;
else|else
name|i
operator|=
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"%s%c%ld%c%s%c%ld%c%s\n"
argument_list|,
name|MessageID
argument_list|,
name|HIS_FIELDSEP
argument_list|,
operator|(
name|long
operator|)
name|Arrived
argument_list|,
name|HIS_SUBFIELDSEP
argument_list|,
name|HIS_NOEXP
argument_list|,
name|HIS_SUBFIELDSEP
argument_list|,
operator|(
name|long
operator|)
name|Posted
argument_list|,
name|HIS_FIELDSEP
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|EOF
operator|||
name|ferror
argument_list|(
name|out
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Can't write history line, %s\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|DISPOSE
argument_list|(
name|MessageID
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* **  Process one newsgroup directory. */
end_comment

begin_function
name|STATIC
name|void
name|DoNewsgroup
parameter_list|(
name|group
parameter_list|,
name|out
parameter_list|,
name|RemoveBad
parameter_list|,
name|Update
parameter_list|)
name|char
modifier|*
name|group
decl_stmt|;
name|FILE
modifier|*
name|out
decl_stmt|;
name|BOOL
name|RemoveBad
decl_stmt|;
name|BOOL
name|Update
decl_stmt|;
block|{
specifier|register
name|DIR
modifier|*
name|dp
decl_stmt|;
specifier|register
name|DIRENTRY
modifier|*
name|ep
decl_stmt|;
specifier|register
name|QIOSTATE
modifier|*
name|qp
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|char
modifier|*
name|q
decl_stmt|;
name|struct
name|stat
name|Sb
decl_stmt|;
name|char
name|buff
index|[
name|SPOOLNAMEBUFF
index|]
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|DO_HAVE_SYMLINK
argument_list|)
name|char
name|linkbuff
index|[
name|SPOOLNAMEBUFF
index|]
decl_stmt|;
name|int
name|oerrno
decl_stmt|;
endif|#
directive|endif
comment|/* defined(DO_HAVE_SYMLINK) */
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|buff
argument_list|,
name|group
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|group
init|;
operator|*
name|p
condition|;
name|p
operator|++
control|)
if|if
condition|(
operator|*
name|p
operator|==
literal|'.'
condition|)
operator|*
name|p
operator|=
literal|'/'
expr_stmt|;
name|xchdir
argument_list|(
name|SPOOL
argument_list|)
expr_stmt|;
if|if
condition|(
name|chdir
argument_list|(
name|group
argument_list|)
operator|<
literal|0
condition|)
return|return;
if|if
condition|(
operator|(
name|dp
operator|=
name|opendir
argument_list|(
literal|"."
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Can't opendir %s, %s\n"
argument_list|,
name|group
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|q
operator|=
operator|&
name|buff
index|[
name|strlen
argument_list|(
name|buff
argument_list|)
index|]
expr_stmt|;
operator|*
name|q
operator|++
operator|=
literal|'/'
expr_stmt|;
comment|/* Read all entries in the directory. */
while|while
condition|(
operator|(
name|ep
operator|=
name|readdir
argument_list|(
name|dp
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|p
operator|=
name|ep
operator|->
name|d_name
expr_stmt|;
if|if
condition|(
operator|!
name|CTYPE
argument_list|(
name|isdigit
argument_list|,
operator|*
name|p
argument_list|)
operator|||
name|strspn
argument_list|(
name|p
argument_list|,
literal|"0123456789"
argument_list|)
operator|!=
name|strlen
argument_list|(
name|p
argument_list|)
condition|)
continue|continue;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|q
argument_list|,
name|p
argument_list|)
expr_stmt|;
comment|/* Is this a regular file? */
if|if
condition|(
name|stat
argument_list|(
name|p
argument_list|,
operator|&
name|Sb
argument_list|)
operator|<
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Can't stat %s, %s\n"
argument_list|,
name|buff
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|DO_HAVE_SYMLINK
argument_list|)
comment|/* Symlink to nowhere? */
name|oerrno
operator|=
name|errno
expr_stmt|;
operator|(
name|void
operator|)
name|memset
argument_list|(
operator|(
name|POINTER
operator|)
name|linkbuff
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
name|linkbuff
argument_list|)
expr_stmt|;
if|if
condition|(
name|lstat
argument_list|(
name|p
argument_list|,
operator|&
name|Sb
argument_list|)
operator|>=
literal|0
operator|&&
name|readlink
argument_list|(
name|p
argument_list|,
name|linkbuff
argument_list|,
sizeof|sizeof
name|linkbuff
operator|-
literal|1
argument_list|)
operator|>=
literal|0
condition|)
block|{
name|linkbuff
index|[
sizeof|sizeof
name|linkbuff
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Bad symlink %s -> %s, %s\n"
argument_list|,
name|buff
argument_list|,
name|linkbuff
argument_list|,
name|strerror
argument_list|(
name|oerrno
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|RemoveBad
condition|)
name|Removeit
argument_list|(
name|buff
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* defined(DO_HAVE_SYMLINK) */
continue|continue;
block|}
if|if
condition|(
operator|!
name|S_ISREG
argument_list|(
name|Sb
operator|.
name|st_mode
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s is not a file\n"
argument_list|,
name|buff
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* Open the article. */
if|if
condition|(
operator|(
name|qp
operator|=
name|QIOopen
argument_list|(
name|p
argument_list|,
name|QIO_BUFFER
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Can't open %s, %s\n"
argument_list|,
name|buff
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|DoArticle
argument_list|(
name|qp
argument_list|,
operator|&
name|Sb
argument_list|,
name|buff
argument_list|,
name|out
argument_list|,
name|RemoveBad
argument_list|,
name|Update
argument_list|)
expr_stmt|;
name|QIOclose
argument_list|(
name|qp
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|closedir
argument_list|(
name|dp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* **  Tell innd to add a history line. */
end_comment

begin_function
name|STATIC
name|BOOL
name|AddThis
parameter_list|(
name|line
parameter_list|,
name|Verbose
parameter_list|)
specifier|register
name|char
modifier|*
name|line
decl_stmt|;
name|BOOL
name|Verbose
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|arrive
decl_stmt|;
name|char
modifier|*
name|exp
decl_stmt|;
name|char
modifier|*
name|posted
decl_stmt|;
name|char
modifier|*
name|paths
decl_stmt|;
name|char
modifier|*
name|av
index|[
literal|6
index|]
decl_stmt|;
if|if
condition|(
operator|(
name|arrive
operator|=
name|strchr
argument_list|(
name|line
argument_list|,
name|HIS_FIELDSEP
argument_list|)
operator|)
operator|==
name|NULL
operator|||
operator|(
name|exp
operator|=
name|strchr
argument_list|(
name|arrive
operator|+
literal|1
argument_list|,
name|HIS_SUBFIELDSEP
argument_list|)
operator|)
operator|==
name|NULL
operator|||
operator|(
name|posted
operator|=
name|strchr
argument_list|(
name|exp
operator|+
literal|1
argument_list|,
name|HIS_SUBFIELDSEP
argument_list|)
operator|)
operator|==
name|NULL
operator|||
operator|(
name|paths
operator|=
name|strchr
argument_list|(
name|exp
operator|+
literal|1
argument_list|,
name|HIS_FIELDSEP
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Got bad history line \"%s\"\n"
argument_list|,
name|line
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|av
index|[
literal|0
index|]
operator|=
name|line
expr_stmt|;
operator|*
name|arrive
operator|=
literal|'\0'
expr_stmt|;
name|av
index|[
literal|1
index|]
operator|=
name|arrive
operator|+
literal|1
expr_stmt|;
operator|*
name|exp
operator|=
literal|'\0'
expr_stmt|;
name|av
index|[
literal|2
index|]
operator|=
name|exp
operator|+
literal|1
expr_stmt|;
operator|*
name|posted
operator|=
literal|'\0'
expr_stmt|;
name|av
index|[
literal|3
index|]
operator|=
name|posted
operator|+
literal|1
expr_stmt|;
operator|*
name|paths
operator|=
literal|'\0'
expr_stmt|;
name|av
index|[
literal|4
index|]
operator|=
name|paths
operator|+
literal|1
expr_stmt|;
name|av
index|[
literal|5
index|]
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|EQ
argument_list|(
name|av
index|[
literal|2
index|]
argument_list|,
name|HIS_NOEXP
argument_list|)
condition|)
name|av
index|[
literal|2
index|]
operator|=
literal|"0"
expr_stmt|;
name|i
operator|=
name|ICCcommand
argument_list|(
name|SC_ADDHIST
argument_list|,
name|av
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
operator|*
name|arrive
operator|=
name|HIS_FIELDSEP
expr_stmt|;
operator|*
name|exp
operator|=
name|HIS_SUBFIELDSEP
expr_stmt|;
operator|*
name|posted
operator|=
name|HIS_SUBFIELDSEP
expr_stmt|;
operator|*
name|paths
operator|=
name|HIS_FIELDSEP
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Can't add history line \"%s\", %s\n"
argument_list|,
name|line
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|Verbose
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Added %s\n"
argument_list|,
name|line
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* **  Close the server link, and exit. */
end_comment

begin_function
name|STATIC
name|NORETURN
name|ErrorExit
parameter_list|(
name|Updating
parameter_list|,
name|Stopped
parameter_list|)
name|BOOL
name|Updating
decl_stmt|;
name|BOOL
name|Stopped
decl_stmt|;
block|{
if|if
condition|(
name|Updating
condition|)
block|{
if|if
condition|(
operator|!
name|INNDrunning
operator|&&
name|Stopped
operator|&&
name|ICCgo
argument_list|(
name|Reason
argument_list|)
operator|<
literal|0
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Can't restart server, %s\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ICCclose
argument_list|()
operator|<
literal|0
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Can't close link, %s\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* **  Print a usage message and exit. */
end_comment

begin_function
name|STATIC
name|NORETURN
name|Usage
parameter_list|()
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Usage: makehistory [-f file] [-n] [-r] [-s size] [-u]\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
end_function

begin_function
name|int
name|main
parameter_list|(
name|ac
parameter_list|,
name|av
parameter_list|)
name|int
name|ac
decl_stmt|;
name|char
modifier|*
name|av
index|[]
decl_stmt|;
block|{
specifier|register
name|QIOSTATE
modifier|*
name|qp
decl_stmt|;
specifier|register
name|FILE
modifier|*
name|out
decl_stmt|;
specifier|register
name|char
modifier|*
name|line
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|char
modifier|*
name|q
decl_stmt|;
specifier|register
name|long
name|count
decl_stmt|;
name|BUFFER
name|B
decl_stmt|;
name|long
name|size
decl_stmt|;
name|int
name|i
decl_stmt|;
name|BOOL
name|JustRebuild
decl_stmt|;
name|BOOL
name|DoRebuild
decl_stmt|;
name|BOOL
name|IgnoreOld
decl_stmt|;
name|BOOL
name|Overwrite
decl_stmt|;
name|BOOL
name|Update
decl_stmt|;
name|BOOL
name|RemoveBad
decl_stmt|;
name|BOOL
name|Verbose
decl_stmt|;
name|char
name|temp
index|[
name|SMBUF
index|]
decl_stmt|;
name|char
modifier|*
name|TempTextFile
decl_stmt|;
name|char
modifier|*
name|tv
index|[
literal|2
index|]
decl_stmt|;
name|STRING
name|tmpdir
decl_stmt|;
name|char
modifier|*
name|Tflag
decl_stmt|;
comment|/* Set defaults. */
name|TextFile
operator|=
name|HISTORY
expr_stmt|;
name|DoRebuild
operator|=
name|TRUE
expr_stmt|;
name|JustRebuild
operator|=
name|FALSE
expr_stmt|;
name|IgnoreOld
operator|=
name|FALSE
expr_stmt|;
name|Update
operator|=
name|FALSE
expr_stmt|;
name|RemoveBad
operator|=
name|FALSE
expr_stmt|;
name|Overwrite
operator|=
name|FALSE
expr_stmt|;
name|Verbose
operator|=
name|FALSE
expr_stmt|;
name|Tflag
operator|=
literal|""
expr_stmt|;
name|size
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|tmpdir
operator|=
name|getenv
argument_list|(
literal|"TMPDIR"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|tmpdir
operator|=
name|_PATH_TMP
expr_stmt|;
operator|(
name|void
operator|)
name|umask
argument_list|(
name|NEWSUMASK
argument_list|)
expr_stmt|;
comment|/* Parse JCL. */
while|while
condition|(
operator|(
name|i
operator|=
name|getopt
argument_list|(
name|ac
argument_list|,
name|av
argument_list|,
literal|"bf:inors:T:uv"
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
switch|switch
condition|(
name|i
condition|)
block|{
default|default:
name|Usage
argument_list|()
expr_stmt|;
comment|/* NOTREACHED */
case|case
literal|'b'
case|:
name|RemoveBad
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
name|TextFile
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
name|size
operator|=
name|atol
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
literal|'i'
case|:
name|IgnoreOld
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
name|DoRebuild
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
literal|'o'
case|:
name|Overwrite
operator|=
name|TRUE
expr_stmt|;
name|IgnoreOld
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
name|JustRebuild
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'T'
case|:
name|tmpdir
operator|=
name|optarg
expr_stmt|;
name|Tflag
operator|=
name|NEW
argument_list|(
name|char
argument_list|,
literal|3
operator|+
name|strlen
argument_list|(
name|optarg
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|Tflag
argument_list|,
literal|"-T %s"
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'u'
case|:
name|Update
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
name|Verbose
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
name|ac
operator|-=
name|optind
expr_stmt|;
name|av
operator|+=
name|optind
expr_stmt|;
if|if
condition|(
name|ac
operator|||
operator|(
name|Overwrite
operator|&&
name|Update
operator|)
operator|||
operator|(
name|Verbose
operator|&&
operator|!
name|Update
operator|)
condition|)
name|Usage
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|p
operator|=
name|strrchr
argument_list|(
name|TextFile
argument_list|,
literal|'/'
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|HISTORYDIR
operator|=
name|_PATH_NEWSLIB
expr_stmt|;
else|else
block|{
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
name|HISTORYDIR
operator|=
name|COPY
argument_list|(
name|TextFile
argument_list|)
expr_stmt|;
operator|*
name|p
operator|=
literal|'/'
expr_stmt|;
block|}
comment|/* If we're not gonna scan the database, get out. */
if|if
condition|(
name|JustRebuild
condition|)
block|{
name|Rebuild
argument_list|(
name|size
argument_list|,
name|IgnoreOld
argument_list|,
name|Overwrite
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* Get the time.  Only get it once, which is good enough. */
if|if
condition|(
name|GetTimeInfo
argument_list|(
operator|&
name|Now
argument_list|)
operator|<
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Can't get the time, %s\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Open history file. */
name|xchdir
argument_list|(
name|HISTORYDIR
argument_list|)
expr_stmt|;
if|if
condition|(
name|Update
operator|||
operator|!
name|Overwrite
condition|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|temp
argument_list|,
literal|"%s/histXXXXXX"
argument_list|,
name|tmpdir
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|mktemp
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|TempTextFile
operator|=
name|COPY
argument_list|(
name|temp
argument_list|)
expr_stmt|;
block|}
else|else
name|TempTextFile
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|Update
condition|)
block|{
if|if
condition|(
name|ICCopen
argument_list|()
operator|<
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Can't talk to server, %s\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|tv
index|[
literal|0
index|]
operator|=
name|Reason
expr_stmt|;
name|tv
index|[
literal|1
index|]
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|DoRebuild
operator|&&
name|ICCcommand
argument_list|(
name|SC_THROTTLE
argument_list|,
name|tv
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
argument_list|)
operator|<
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Can't throttle innd, %s\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dbminit
argument_list|(
name|TextFile
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Can't open dbz file, %s\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|ErrorExit
argument_list|(
name|TRUE
argument_list|,
name|DoRebuild
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|out
operator|=
name|fopen
argument_list|(
name|TempTextFile
condition|?
name|TempTextFile
else|:
name|TextFile
argument_list|,
literal|"w"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Can't write to history file, %s\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Start scanning the directories. */
if|if
condition|(
operator|(
name|qp
operator|=
name|QIOopen
argument_list|(
name|ACTIVE
argument_list|,
name|QIO_BUFFER
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Can't open %s, %s\n"
argument_list|,
name|ACTIVE
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|count
operator|=
literal|1
init|;
operator|(
name|line
operator|=
name|QIOread
argument_list|(
name|qp
argument_list|)
operator|)
operator|!=
name|NULL
condition|;
name|count
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|p
operator|=
name|strchr
argument_list|(
name|line
argument_list|,
literal|' '
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Bad line %ld, \"%s\"\n"
argument_list|,
name|count
argument_list|,
name|line
argument_list|)
expr_stmt|;
continue|continue;
block|}
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
name|DoNewsgroup
argument_list|(
name|line
argument_list|,
name|out
argument_list|,
name|RemoveBad
argument_list|,
name|Update
argument_list|)
expr_stmt|;
block|}
comment|/* Test error conditions; QIOtoolong shouldn't happen. */
if|if
condition|(
name|QIOtoolong
argument_list|(
name|qp
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Line %ld is too long\n"
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|ErrorExit
argument_list|(
name|Update
argument_list|,
name|DoRebuild
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|QIOerror
argument_list|(
name|qp
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Can't read %s around line %ld, %s\n"
argument_list|,
name|ACTIVE
argument_list|,
name|count
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|ErrorExit
argument_list|(
name|Update
argument_list|,
name|DoRebuild
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fflush
argument_list|(
name|out
argument_list|)
operator|==
name|EOF
operator|||
name|ferror
argument_list|(
name|out
argument_list|)
operator|||
name|fclose
argument_list|(
name|out
argument_list|)
operator|==
name|EOF
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Can't close history file, %s\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|ErrorExit
argument_list|(
name|Update
argument_list|,
name|DoRebuild
argument_list|)
expr_stmt|;
block|}
comment|/* Move. */
name|xchdir
argument_list|(
name|HISTORYDIR
argument_list|)
expr_stmt|;
if|if
condition|(
name|Update
condition|)
block|{
name|INNDrunning
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|dbmclose
argument_list|()
operator|<
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Can't close DBZ file, %s\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|ErrorExit
argument_list|(
name|Update
argument_list|,
name|DoRebuild
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|DoRebuild
operator|&&
name|ICCgo
argument_list|(
name|Reason
argument_list|)
operator|<
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Can't restart innd, %s\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|ErrorExit
argument_list|(
name|Update
argument_list|,
name|DoRebuild
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Make a temporary file, sort the text file into it. */
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|temp
argument_list|,
literal|"%s/histXXXXXX"
argument_list|,
name|tmpdir
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|mktemp
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|i
operator|=
literal|50
operator|+
name|strlen
argument_list|(
name|TempTextFile
condition|?
name|TempTextFile
else|:
name|TextFile
argument_list|)
operator|+
name|strlen
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|p
operator|=
name|NEW
argument_list|(
name|char
argument_list|,
name|i
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|p
argument_list|,
literal|"exec sort %s -t'%c' +1n -o %s %s"
argument_list|,
name|Tflag
argument_list|,
name|HIS_FIELDSEP
argument_list|,
name|temp
argument_list|,
name|TempTextFile
condition|?
name|TempTextFile
else|:
name|TextFile
argument_list|)
expr_stmt|;
name|i
operator|=
name|system
argument_list|(
name|p
argument_list|)
operator|>>
literal|8
expr_stmt|;
if|if
condition|(
name|i
operator|!=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Can't sort history file (exit %d), %s\n"
argument_list|,
name|i
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|ErrorExit
argument_list|(
name|Update
argument_list|,
name|DoRebuild
argument_list|)
expr_stmt|;
block|}
name|DISPOSE
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|TempTextFile
condition|)
block|{
if|if
condition|(
name|unlink
argument_list|(
name|TempTextFile
argument_list|)
operator|&&
name|errno
operator|!=
name|ENOENT
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Can't remove \"%s\", %s\n"
argument_list|,
name|TempTextFile
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|DISPOSE
argument_list|(
name|TempTextFile
argument_list|)
expr_stmt|;
name|TempTextFile
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* Open the sorted file, get ready to write the final text file. */
if|if
condition|(
operator|(
name|qp
operator|=
name|QIOopen
argument_list|(
name|temp
argument_list|,
name|QIO_BUFFER
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Can't open work file \"%s\", %s\n"
argument_list|,
name|temp
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|ErrorExit
argument_list|(
name|Update
argument_list|,
name|DoRebuild
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|Update
operator|&&
operator|(
name|out
operator|=
name|fopen
argument_list|(
name|TextFile
argument_list|,
literal|"w"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Can't start writing %s, %s\n"
argument_list|,
name|TextFile
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Work file %s untouched.\n"
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|ErrorExit
argument_list|(
name|Update
argument_list|,
name|DoRebuild
argument_list|)
expr_stmt|;
block|}
comment|/* Get space to keep the joined history lines. */
name|B
operator|.
name|Size
operator|=
literal|100
expr_stmt|;
name|B
operator|.
name|Used
operator|=
literal|0
expr_stmt|;
name|B
operator|.
name|Data
operator|=
name|NEW
argument_list|(
name|char
argument_list|,
name|B
operator|.
name|Size
argument_list|)
expr_stmt|;
name|p
operator|=
name|COPY
argument_list|(
literal|""
argument_list|)
expr_stmt|;
comment|/* Read the sorted work file. */
for|for
control|(
name|count
operator|=
literal|0
init|;
operator|(
name|line
operator|=
name|QIOread
argument_list|(
name|qp
argument_list|)
operator|)
operator|!=
name|NULL
condition|;
control|)
block|{
name|count
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|q
operator|=
name|strchr
argument_list|(
name|line
argument_list|,
name|HIS_FIELDSEP
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Work file line %ld had bad format\n"
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|ErrorExit
argument_list|(
name|Update
argument_list|,
name|DoRebuild
argument_list|)
expr_stmt|;
block|}
operator|*
name|q
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|EQ
argument_list|(
name|p
argument_list|,
name|line
argument_list|)
condition|)
block|{
comment|/* Same Message-ID as last time -- get filename */
if|if
condition|(
operator|(
name|q
operator|=
name|strchr
argument_list|(
name|q
operator|+
literal|1
argument_list|,
name|HIS_FIELDSEP
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Work file line %ld missing filename\n"
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|ErrorExit
argument_list|(
name|Update
argument_list|,
name|DoRebuild
argument_list|)
expr_stmt|;
block|}
name|i
operator|=
name|strlen
argument_list|(
name|q
argument_list|)
expr_stmt|;
if|if
condition|(
name|B
operator|.
name|Size
operator|<
name|B
operator|.
name|Used
operator|+
name|i
operator|+
literal|3
condition|)
block|{
name|B
operator|.
name|Size
operator|=
name|B
operator|.
name|Used
operator|+
name|i
operator|+
literal|3
expr_stmt|;
name|B
operator|.
name|Data
operator|=
name|RENEW
argument_list|(
name|B
operator|.
name|Data
argument_list|,
name|char
argument_list|,
name|B
operator|.
name|Size
argument_list|)
expr_stmt|;
block|}
operator|*
name|q
operator|=
literal|' '
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
operator|&
name|B
operator|.
name|Data
index|[
name|B
operator|.
name|Used
index|]
argument_list|,
name|q
argument_list|)
expr_stmt|;
name|B
operator|.
name|Used
operator|+=
name|i
expr_stmt|;
block|}
else|else
block|{
comment|/* Different Message-ID; end old line, start new one. */
if|if
condition|(
operator|*
name|p
condition|)
block|{
if|if
condition|(
operator|!
name|Update
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"%s\n"
argument_list|,
name|B
operator|.
name|Data
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|AddThis
argument_list|(
name|B
operator|.
name|Data
argument_list|,
name|Verbose
argument_list|)
condition|)
name|ErrorExit
argument_list|(
name|Update
argument_list|,
name|DoRebuild
argument_list|)
expr_stmt|;
block|}
name|DISPOSE
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|=
name|COPY
argument_list|(
name|line
argument_list|)
expr_stmt|;
operator|*
name|q
operator|=
name|HIS_FIELDSEP
expr_stmt|;
name|i
operator|=
name|strlen
argument_list|(
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
name|B
operator|.
name|Size
operator|<
name|i
condition|)
block|{
name|B
operator|.
name|Size
operator|=
name|i
operator|+
literal|2
expr_stmt|;
name|B
operator|.
name|Data
operator|=
name|RENEW
argument_list|(
name|B
operator|.
name|Data
argument_list|,
name|char
argument_list|,
name|B
operator|.
name|Size
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|B
operator|.
name|Data
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|B
operator|.
name|Used
operator|=
name|i
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|Update
operator|&&
name|ferror
argument_list|(
name|out
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Can't write output from line %ld, %s\n"
argument_list|,
name|count
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|ErrorExit
argument_list|(
name|Update
argument_list|,
name|DoRebuild
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Check for errors and close. */
if|if
condition|(
name|QIOtoolong
argument_list|(
name|qp
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Line %ld is too long\n"
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|ErrorExit
argument_list|(
name|Update
argument_list|,
name|DoRebuild
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|QIOerror
argument_list|(
name|qp
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Can't read work file, %s\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|ErrorExit
argument_list|(
name|Update
argument_list|,
name|DoRebuild
argument_list|)
expr_stmt|;
block|}
name|QIOclose
argument_list|(
name|qp
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlink
argument_list|(
name|temp
argument_list|)
operator|&&
name|errno
operator|!=
name|ENOENT
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Can't remove \"%s\", %s\n"
argument_list|,
name|temp
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|p
condition|)
block|{
comment|/* Add tail end of last line. */
if|if
condition|(
operator|!
name|Update
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"%s\n"
argument_list|,
name|B
operator|.
name|Data
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|AddThis
argument_list|(
name|B
operator|.
name|Data
argument_list|,
name|Verbose
argument_list|)
condition|)
name|ErrorExit
argument_list|(
name|Update
argument_list|,
name|DoRebuild
argument_list|)
expr_stmt|;
block|}
comment|/* Close the output file. */
if|if
condition|(
operator|!
name|Update
condition|)
block|{
if|if
condition|(
name|fflush
argument_list|(
name|out
argument_list|)
operator|==
name|EOF
operator|||
name|fclose
argument_list|(
name|out
argument_list|)
operator|==
name|EOF
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Can't close history file, %s\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|ErrorExit
argument_list|(
name|Update
argument_list|,
name|DoRebuild
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|DoRebuild
condition|)
name|Rebuild
argument_list|(
name|size
condition|?
name|size
else|:
name|count
argument_list|,
name|TRUE
argument_list|,
name|Overwrite
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ICCclose
argument_list|()
operator|<
literal|0
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Can't close link, %s\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
end_function

end_unit

