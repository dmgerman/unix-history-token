begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  $Revision: 1.3 $ ** **  Expire overview database. */
end_comment

begin_include
include|#
directive|include
file|"configdata.h"
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/uio.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|"clibrary.h"
end_include

begin_include
include|#
directive|include
file|"qio.h"
end_include

begin_include
include|#
directive|include
file|"mydir.h"
end_include

begin_include
include|#
directive|include
file|"libinn.h"
end_include

begin_include
include|#
directive|include
file|"macros.h"
end_include

begin_include
include|#
directive|include
file|"paths.h"
end_include

begin_define
define|#
directive|define
name|START_LIST_SIZE
value|128
end_define

begin_comment
comment|/* **   Information about a line in the overview file. */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|_LINE
block|{
name|ARTNUM
name|Article
decl_stmt|;
name|char
modifier|*
name|Start
decl_stmt|;
name|int
name|Length
decl_stmt|;
name|int
name|Offset
decl_stmt|;
block|}
name|LINE
typedef|;
end_typedef

begin_comment
comment|/* **  A list of articles; re-uses space. */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|_LIST
block|{
name|int
name|Used
decl_stmt|;
name|int
name|Size
decl_stmt|;
name|ARTNUM
modifier|*
name|Articles
decl_stmt|;
block|}
name|LIST
typedef|;
end_typedef

begin_comment
comment|/* **  A buffer; re-uses space. */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|_BUFFER
block|{
name|int
name|Used
decl_stmt|;
name|int
name|Size
decl_stmt|;
name|char
modifier|*
name|Data
decl_stmt|;
block|}
name|BUFFER
typedef|;
end_typedef

begin_comment
comment|/* **  Information about the schema of the news overview files. */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|_ARTOVERFIELD
block|{
name|char
modifier|*
name|Header
decl_stmt|;
name|int
name|Length
decl_stmt|;
name|BOOL
name|HasHeader
decl_stmt|;
block|}
name|ARTOVERFIELD
typedef|;
end_typedef

begin_comment
comment|/* **  Append an article to an LIST. */
end_comment

begin_define
define|#
directive|define
name|LISTappend
parameter_list|(
name|L
parameter_list|,
name|a
parameter_list|)
define|\
value|if ((L).Size == (L).Used) {			\ 	    (L).Size *= 2;				\ 	    RENEW((L).Articles, ARTNUM, (L).Size);	\ 	    (L).Articles[(L).Used++] = (a);		\ 	}						\ 	else						\ 	    (L).Articles[(L).Used++] = (a)
end_define

begin_comment
comment|/* **  Global variables. */
end_comment

begin_decl_stmt
name|STATIC
name|char
name|SPOOL
index|[]
init|=
name|_PATH_SPOOL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|char
modifier|*
name|SCHEMA
init|=
name|_PATH_SCHEMA
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|BOOL
name|InSpoolDir
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|BOOL
name|Verbose
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|BOOL
name|DoNothing
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|ARTOVERFIELD
modifier|*
name|ARTfields
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|int
name|ARTfieldsize
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* **  Sorting predicate for qsort to put articles in numeric order. */
end_comment

begin_function
name|STATIC
name|int
name|LISTcompare
parameter_list|(
name|p1
parameter_list|,
name|p2
parameter_list|)
name|POINTER
modifier|*
name|p1
decl_stmt|;
name|POINTER
modifier|*
name|p2
decl_stmt|;
block|{
name|ARTNUM
modifier|*
name|ip1
decl_stmt|;
name|ARTNUM
modifier|*
name|ip2
decl_stmt|;
name|ip1
operator|=
name|CAST
argument_list|(
name|ARTNUM
operator|*
argument_list|,
name|p1
argument_list|)
expr_stmt|;
name|ip2
operator|=
name|CAST
argument_list|(
name|ARTNUM
operator|*
argument_list|,
name|p2
argument_list|)
expr_stmt|;
return|return
operator|*
name|ip1
operator|-
operator|*
name|ip2
return|;
block|}
end_function

begin_comment
comment|/* **  If list is big enough, and out of order, sort it. */
end_comment

begin_function
name|STATIC
name|void
name|LISTsort
parameter_list|(
name|lp
parameter_list|)
name|LIST
modifier|*
name|lp
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|ARTNUM
modifier|*
name|ap
decl_stmt|;
for|for
control|(
name|ap
operator|=
name|lp
operator|->
name|Articles
operator|,
name|i
operator|=
name|lp
operator|->
name|Used
operator|-
literal|1
init|;
operator|--
name|i
operator|>=
literal|0
condition|;
name|ap
operator|++
control|)
if|if
condition|(
name|ap
index|[
literal|0
index|]
operator|>=
name|ap
index|[
literal|1
index|]
condition|)
block|{
name|qsort
argument_list|(
operator|(
name|POINTER
operator|)
name|lp
operator|->
name|Articles
argument_list|,
operator|(
name|SIZE_T
operator|)
name|lp
operator|->
name|Used
argument_list|,
sizeof|sizeof
name|lp
operator|->
name|Articles
index|[
literal|0
index|]
argument_list|,
name|LISTcompare
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/* **  Unlock the group. */
end_comment

begin_function
name|STATIC
name|void
name|UnlockGroup
parameter_list|(
name|lfd
parameter_list|,
name|lockfile
parameter_list|)
name|int
name|lfd
decl_stmt|;
name|char
modifier|*
name|lockfile
decl_stmt|;
block|{
if|if
condition|(
name|lfd
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|unlink
argument_list|(
name|lockfile
argument_list|)
operator|<
literal|0
operator|&&
name|errno
operator|!=
name|ENOENT
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"expireover cant unlink %s %s\n"
argument_list|,
name|lockfile
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|close
argument_list|(
name|lfd
argument_list|)
operator|<
literal|0
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"expireover cant close %s %s\n"
argument_list|,
name|lockfile
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|lfd
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* **  Sorting predicate to put lines in numeric order. */
end_comment

begin_function
name|STATIC
name|int
name|LINEcompare
parameter_list|(
name|p1
parameter_list|,
name|p2
parameter_list|)
name|POINTER
modifier|*
name|p1
decl_stmt|;
name|POINTER
modifier|*
name|p2
decl_stmt|;
block|{
name|LINE
modifier|*
name|lp1
decl_stmt|;
name|LINE
modifier|*
name|lp2
decl_stmt|;
name|lp1
operator|=
name|CAST
argument_list|(
name|LINE
operator|*
argument_list|,
name|p1
argument_list|)
expr_stmt|;
name|lp2
operator|=
name|CAST
argument_list|(
name|LINE
operator|*
argument_list|,
name|p2
argument_list|)
expr_stmt|;
return|return
name|lp1
operator|->
name|Article
operator|-
name|lp2
operator|->
name|Article
return|;
block|}
end_function

begin_comment
comment|/* **  Take in a sorted list of count article numbers in group, and delete **  them from the overview file. */
end_comment

begin_function
name|STATIC
name|void
name|RemoveLines
parameter_list|(
name|group
parameter_list|,
name|Deletes
parameter_list|)
name|char
modifier|*
name|group
decl_stmt|;
name|LIST
modifier|*
name|Deletes
decl_stmt|;
block|{
specifier|static
name|BUFFER
name|B
decl_stmt|;
specifier|static
name|LINE
modifier|*
name|Lines
decl_stmt|;
specifier|static
name|int
name|LineSize
decl_stmt|;
specifier|register
name|struct
name|iovec
modifier|*
name|vp
decl_stmt|;
specifier|register
name|LINE
modifier|*
name|lp
decl_stmt|;
specifier|register
name|LINE
modifier|*
name|end
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|char
modifier|*
name|next
decl_stmt|;
specifier|register
name|ARTNUM
modifier|*
name|ap
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|struct
name|stat
name|Sb
decl_stmt|;
name|struct
name|iovec
name|iov
index|[
literal|8
index|]
decl_stmt|;
name|char
name|file
index|[
name|SPOOLNAMEBUFF
index|]
decl_stmt|;
name|char
name|lockfile
index|[
name|SPOOLNAMEBUFF
index|]
decl_stmt|;
name|int
name|fd
decl_stmt|;
name|int
name|count
decl_stmt|;
name|int
name|lfd
decl_stmt|;
if|if
condition|(
name|Verbose
condition|)
block|{
for|for
control|(
name|ap
operator|=
name|Deletes
operator|->
name|Articles
operator|,
name|i
operator|=
name|Deletes
operator|->
name|Used
init|;
operator|--
name|i
operator|>=
literal|0
condition|;
name|ap
operator|++
control|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"- %s/%ld\n"
argument_list|,
name|group
argument_list|,
operator|*
name|ap
argument_list|)
expr_stmt|;
if|if
condition|(
name|DoNothing
condition|)
return|return;
block|}
comment|/* Lock the group. */
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|lockfile
argument_list|,
literal|"%s/.LCK%s"
argument_list|,
name|group
argument_list|,
name|_PATH_OVERVIEW
argument_list|)
expr_stmt|;
name|lfd
operator|=
name|open
argument_list|(
name|lockfile
argument_list|,
name|O_WRONLY
operator||
name|O_TRUNC
operator||
name|O_CREAT
argument_list|,
name|ARTFILE_MODE
argument_list|)
expr_stmt|;
if|if
condition|(
name|lfd
operator|<
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Can't open %s, %s\n"
argument_list|,
name|lockfile
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Open file, lock it. */
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|file
argument_list|,
literal|"%s/%s"
argument_list|,
name|group
argument_list|,
name|_PATH_OVERVIEW
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
operator|(
name|fd
operator|=
name|open
argument_list|(
name|file
argument_list|,
name|O_RDWR
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Can't open %s, %s\n"
argument_list|,
name|file
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|UnlockGroup
argument_list|(
name|lfd
argument_list|,
name|lockfile
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|LockFile
argument_list|(
name|fd
argument_list|,
name|FALSE
argument_list|)
operator|>=
literal|0
condition|)
break|break;
comment|/* Wait for lock; close file -- might be unlinked -- and try again. */
operator|(
name|void
operator|)
name|LockFile
argument_list|(
name|fd
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fstat
argument_list|(
name|fd
argument_list|,
operator|&
name|Sb
argument_list|)
operator|<
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Can't open %s, %s\n"
argument_list|,
name|file
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|UnlockGroup
argument_list|(
name|lfd
argument_list|,
name|lockfile
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|Sb
operator|.
name|st_size
operator|==
literal|0
condition|)
block|{
comment|/* Empty file; done deleting. */
name|UnlockGroup
argument_list|(
name|lfd
argument_list|,
name|lockfile
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Read in the whole file. */
if|if
condition|(
name|B
operator|.
name|Size
operator|==
literal|0
condition|)
block|{
name|B
operator|.
name|Size
operator|=
name|Sb
operator|.
name|st_size
operator|+
literal|1
expr_stmt|;
name|B
operator|.
name|Data
operator|=
name|NEW
argument_list|(
name|char
argument_list|,
name|B
operator|.
name|Size
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|B
operator|.
name|Size
operator|<
name|Sb
operator|.
name|st_size
condition|)
block|{
name|B
operator|.
name|Size
operator|=
name|Sb
operator|.
name|st_size
operator|+
literal|1
expr_stmt|;
name|RENEW
argument_list|(
name|B
operator|.
name|Data
argument_list|,
name|char
argument_list|,
name|B
operator|.
name|Size
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|xread
argument_list|(
name|fd
argument_list|,
name|B
operator|.
name|Data
argument_list|,
name|Sb
operator|.
name|st_size
argument_list|)
operator|<
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Can't read %s, %s\n"
argument_list|,
name|file
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|UnlockGroup
argument_list|(
name|lfd
argument_list|,
name|lockfile
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return;
block|}
name|B
operator|.
name|Data
index|[
name|Sb
operator|.
name|st_size
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* Count lines, get space. */
for|for
control|(
name|i
operator|=
literal|1
operator|,
name|p
operator|=
name|B
operator|.
name|Data
init|;
operator|(
name|p
operator|=
name|strchr
argument_list|(
name|p
argument_list|,
literal|'\n'
argument_list|)
operator|)
operator|!=
name|NULL
operator|&&
operator|*
operator|++
name|p
condition|;
name|i
operator|++
control|)
continue|continue;
if|if
condition|(
name|LineSize
operator|==
literal|0
condition|)
block|{
name|LineSize
operator|=
name|i
expr_stmt|;
name|Lines
operator|=
name|NEW
argument_list|(
name|LINE
argument_list|,
name|LineSize
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|LineSize
operator|<
name|i
condition|)
block|{
name|LineSize
operator|=
name|i
expr_stmt|;
name|RENEW
argument_list|(
name|Lines
argument_list|,
name|LINE
argument_list|,
name|LineSize
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Build line array. */
for|for
control|(
name|lp
operator|=
name|Lines
operator|,
name|p
operator|=
name|B
operator|.
name|Data
init|;
condition|;
name|p
operator|=
name|next
operator|,
name|lp
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|next
operator|=
name|strchr
argument_list|(
name|p
argument_list|,
literal|'\n'
argument_list|)
operator|)
operator|==
name|NULL
condition|)
break|break;
name|lp
operator|->
name|Start
operator|=
name|p
expr_stmt|;
name|lp
operator|->
name|Length
operator|=
operator|++
name|next
operator|-
name|p
expr_stmt|;
name|lp
operator|->
name|Article
operator|=
name|atol
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
name|qsort
argument_list|(
operator|(
name|POINTER
operator|)
name|Lines
argument_list|,
call|(
name|SIZE_T
call|)
argument_list|(
name|lp
operator|-
name|Lines
argument_list|)
argument_list|,
sizeof|sizeof
name|lp
index|[
literal|0
index|]
argument_list|,
name|LINEcompare
argument_list|)
expr_stmt|;
comment|/* Remove duplicates. */
for|for
control|(
name|end
operator|=
name|lp
operator|-
literal|1
operator|,
name|lp
operator|=
name|Lines
init|;
name|lp
operator|<
name|end
condition|;
name|lp
operator|++
control|)
if|if
condition|(
name|lp
index|[
literal|0
index|]
operator|.
name|Article
operator|==
name|lp
index|[
literal|1
index|]
operator|.
name|Article
condition|)
name|lp
operator|->
name|Article
operator|=
literal|0
expr_stmt|;
comment|/* Scan through lines, collecting clumps and skipping holes. */
name|ap
operator|=
name|Deletes
operator|->
name|Articles
expr_stmt|;
name|count
operator|=
name|Deletes
operator|->
name|Used
expr_stmt|;
name|iov
index|[
literal|0
index|]
operator|.
name|iov_len
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|vp
operator|=
name|iov
operator|,
name|lp
operator|=
name|Lines
init|;
name|lp
operator|<
name|end
operator|+
literal|1
condition|;
name|lp
operator|++
control|)
block|{
comment|/* An already-removed article, or one that should be? */
if|if
condition|(
name|lp
operator|->
name|Article
operator|==
literal|0
condition|)
continue|continue;
comment|/* Skip delete items before the current one. */
while|while
condition|(
operator|*
name|ap
operator|<
name|lp
operator|->
name|Article
operator|&&
name|count
operator|>
literal|0
condition|)
block|{
name|ap
operator|++
expr_stmt|;
name|count
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|count
operator|>
literal|0
operator|&&
name|lp
operator|->
name|Article
operator|==
operator|*
name|ap
condition|)
block|{
while|while
condition|(
operator|*
name|ap
operator|==
name|lp
operator|->
name|Article
operator|&&
name|count
operator|>
literal|0
condition|)
block|{
name|ap
operator|++
expr_stmt|;
name|count
operator|--
expr_stmt|;
block|}
continue|continue;
block|}
comment|/* We're keeping this entry; see if we can add it to any 	 * in-progress iov element. */
if|if
condition|(
name|vp
operator|->
name|iov_len
condition|)
block|{
if|if
condition|(
name|vp
operator|->
name|iov_base
operator|+
name|vp
operator|->
name|iov_len
operator|==
name|lp
operator|->
name|Start
condition|)
block|{
comment|/* Contiguous. */
name|vp
operator|->
name|iov_len
operator|+=
name|lp
operator|->
name|Length
expr_stmt|;
continue|continue;
block|}
comment|/* Doesn't fit -- get a new element. */
if|if
condition|(
operator|++
name|vp
operator|==
name|ENDOF
argument_list|(
name|iov
argument_list|)
condition|)
block|{
if|if
condition|(
name|xwritev
argument_list|(
name|lfd
argument_list|,
name|iov
argument_list|,
name|SIZEOF
argument_list|(
name|iov
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Can't write %s, %s\n"
argument_list|,
name|lockfile
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|UnlockGroup
argument_list|(
name|lfd
argument_list|,
name|lockfile
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return;
block|}
name|vp
operator|=
name|iov
expr_stmt|;
block|}
block|}
comment|/* Start new element. */
name|vp
operator|->
name|iov_base
operator|=
name|lp
operator|->
name|Start
expr_stmt|;
name|vp
operator|->
name|iov_len
operator|=
name|lp
operator|->
name|Length
expr_stmt|;
block|}
comment|/* Write out remaining. */
if|if
condition|(
name|vp
operator|->
name|iov_len
condition|)
name|vp
operator|++
expr_stmt|;
if|if
condition|(
name|iov
index|[
literal|0
index|]
operator|.
name|iov_len
operator|&&
name|xwritev
argument_list|(
name|lfd
argument_list|,
name|iov
argument_list|,
name|vp
operator|-
name|iov
argument_list|)
operator|<
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Can't write %s, %s\n"
argument_list|,
name|lockfile
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|UnlockGroup
argument_list|(
name|lfd
argument_list|,
name|lockfile
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|rename
argument_list|(
name|lockfile
argument_list|,
name|file
argument_list|)
operator|<
literal|0
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Can't rename %s, %s\n"
argument_list|,
name|lockfile
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Don't call UnlockGroup; do it inline. */
if|if
condition|(
name|close
argument_list|(
name|lfd
argument_list|)
operator|<
literal|0
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"expireover cant close %s %s\n"
argument_list|,
name|file
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|close
argument_list|(
name|fd
argument_list|)
operator|<
literal|0
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"expireover cant close unlinked %s %s\n"
argument_list|,
name|file
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* **  Read the overview schema. */
end_comment

begin_function
name|void
name|ARTreadschema
parameter_list|()
block|{
specifier|register
name|FILE
modifier|*
name|F
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|ARTOVERFIELD
modifier|*
name|fp
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|char
name|buff
index|[
name|SMBUF
index|]
decl_stmt|;
comment|/* Open file, count lines. */
if|if
condition|(
operator|(
name|F
operator|=
name|fopen
argument_list|(
name|SCHEMA
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Can't open %s, %s\n"
argument_list|,
name|SCHEMA
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|fgets
argument_list|(
name|buff
argument_list|,
sizeof|sizeof
name|buff
argument_list|,
name|F
argument_list|)
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
continue|continue;
operator|(
name|void
operator|)
name|fseek
argument_list|(
name|F
argument_list|,
operator|(
name|OFFSET_T
operator|)
literal|0
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
name|ARTfields
operator|=
name|NEW
argument_list|(
name|ARTOVERFIELD
argument_list|,
name|i
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* Parse each field. */
for|for
control|(
name|fp
operator|=
name|ARTfields
init|;
name|fgets
argument_list|(
name|buff
argument_list|,
sizeof|sizeof
name|buff
argument_list|,
name|F
argument_list|)
operator|!=
name|NULL
condition|;
control|)
block|{
comment|/* Ignore blank and comment lines. */
if|if
condition|(
operator|(
name|p
operator|=
name|strchr
argument_list|(
name|buff
argument_list|,
literal|'\n'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|(
name|p
operator|=
name|strchr
argument_list|(
name|buff
argument_list|,
name|COMMENT_CHAR
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|buff
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
continue|continue;
if|if
condition|(
operator|(
name|p
operator|=
name|strchr
argument_list|(
name|buff
argument_list|,
literal|':'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
operator|*
name|p
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|fp
operator|->
name|HasHeader
operator|=
name|EQ
argument_list|(
name|p
argument_list|,
literal|"full"
argument_list|)
expr_stmt|;
block|}
else|else
name|fp
operator|->
name|HasHeader
operator|=
name|FALSE
expr_stmt|;
name|fp
operator|->
name|Header
operator|=
name|COPY
argument_list|(
name|buff
argument_list|)
expr_stmt|;
name|fp
operator|->
name|Length
operator|=
name|strlen
argument_list|(
name|buff
argument_list|)
expr_stmt|;
name|fp
operator|++
expr_stmt|;
block|}
name|ARTfieldsize
operator|=
name|fp
operator|-
name|ARTfields
expr_stmt|;
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|F
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* **  Read an article and create an overview line without the trailing **  newline.  Returns pointer to static space or NULL on error. */
end_comment

begin_function
name|STATIC
name|char
modifier|*
name|OVERgen
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
specifier|static
name|ARTOVERFIELD
modifier|*
name|Headers
decl_stmt|;
specifier|static
name|BUFFER
name|B
decl_stmt|;
specifier|register
name|ARTOVERFIELD
modifier|*
name|fp
decl_stmt|;
specifier|register
name|ARTOVERFIELD
modifier|*
name|hp
decl_stmt|;
specifier|register
name|QIOSTATE
modifier|*
name|qp
decl_stmt|;
specifier|register
name|char
modifier|*
name|colon
decl_stmt|;
specifier|register
name|char
modifier|*
name|line
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|int
name|size
decl_stmt|;
specifier|register
name|int
name|ov_size
decl_stmt|;
specifier|register
name|long
name|lines
decl_stmt|;
name|struct
name|stat
name|Sb
decl_stmt|;
name|long
name|t
decl_stmt|;
name|char
name|value
index|[
literal|10
index|]
decl_stmt|;
comment|/* Open article. */
if|if
condition|(
operator|(
name|qp
operator|=
name|QIOopen
argument_list|(
name|name
argument_list|,
name|QIO_BUFFER
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
if|if
condition|(
operator|(
name|p
operator|=
name|strrchr
argument_list|(
name|name
argument_list|,
literal|'/'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|name
operator|=
name|p
operator|+
literal|1
expr_stmt|;
comment|/* Set up place to store headers. */
if|if
condition|(
name|Headers
operator|==
name|NULL
condition|)
block|{
name|Headers
operator|=
name|NEW
argument_list|(
name|ARTOVERFIELD
argument_list|,
name|ARTfieldsize
argument_list|)
expr_stmt|;
for|for
control|(
name|hp
operator|=
name|Headers
operator|,
name|i
operator|=
name|ARTfieldsize
init|;
operator|--
name|i
operator|>=
literal|0
condition|;
name|hp
operator|++
control|)
name|hp
operator|->
name|Length
operator|=
literal|0
expr_stmt|;
block|}
for|for
control|(
name|hp
operator|=
name|Headers
operator|,
name|i
operator|=
name|ARTfieldsize
init|;
operator|--
name|i
operator|>=
literal|0
condition|;
name|hp
operator|++
control|)
name|hp
operator|->
name|HasHeader
operator|=
name|FALSE
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* Read next line. */
if|if
condition|(
operator|(
name|line
operator|=
name|QIOread
argument_list|(
name|qp
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|QIOtoolong
argument_list|(
name|qp
argument_list|)
condition|)
continue|continue;
comment|/* Error or EOF (in headers!?); shouldn't happen. */
name|QIOclose
argument_list|(
name|qp
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* End of headers? */
if|if
condition|(
operator|*
name|line
operator|==
literal|'\0'
condition|)
break|break;
comment|/* See if we want this header. */
name|fp
operator|=
name|ARTfields
expr_stmt|;
for|for
control|(
name|hp
operator|=
name|Headers
operator|,
name|i
operator|=
name|ARTfieldsize
init|;
operator|--
name|i
operator|>=
literal|0
condition|;
name|hp
operator|++
operator|,
name|fp
operator|++
control|)
block|{
name|colon
operator|=
operator|&
name|line
index|[
name|fp
operator|->
name|Length
index|]
expr_stmt|;
if|if
condition|(
operator|*
name|colon
operator|!=
literal|':'
condition|)
continue|continue;
operator|*
name|colon
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|!
name|caseEQ
argument_list|(
name|line
argument_list|,
name|fp
operator|->
name|Header
argument_list|)
condition|)
block|{
operator|*
name|colon
operator|=
literal|':'
expr_stmt|;
continue|continue;
block|}
operator|*
name|colon
operator|=
literal|':'
expr_stmt|;
if|if
condition|(
name|fp
operator|->
name|HasHeader
condition|)
name|p
operator|=
name|line
expr_stmt|;
else|else
comment|/* Skip colon and whitespace, store value. */
for|for
control|(
name|p
operator|=
name|colon
init|;
operator|*
operator|++
name|p
operator|&&
name|ISWHITE
argument_list|(
operator|*
name|p
argument_list|)
condition|;
control|)
continue|continue;
name|size
operator|=
name|strlen
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|hp
operator|->
name|Length
operator|==
literal|0
condition|)
block|{
name|hp
operator|->
name|Length
operator|=
name|size
expr_stmt|;
name|hp
operator|->
name|Header
operator|=
name|NEW
argument_list|(
name|char
argument_list|,
name|hp
operator|->
name|Length
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|hp
operator|->
name|Length
operator|<
name|size
condition|)
block|{
name|hp
operator|->
name|Length
operator|=
name|size
expr_stmt|;
name|RENEW
argument_list|(
name|hp
operator|->
name|Header
argument_list|,
name|char
argument_list|,
name|hp
operator|->
name|Length
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|hp
operator|->
name|Header
argument_list|,
name|p
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|hp
operator|->
name|Header
init|;
operator|*
name|p
condition|;
name|p
operator|++
control|)
if|if
condition|(
operator|*
name|p
operator|==
literal|'\t'
operator|||
operator|*
name|p
operator|==
literal|'\n'
condition|)
operator|*
name|p
operator|=
literal|' '
expr_stmt|;
name|hp
operator|->
name|HasHeader
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
comment|/* Read body of article, just to get lines. */
for|for
control|(
name|lines
operator|=
literal|0
init|;
condition|;
name|lines
operator|++
control|)
if|if
condition|(
operator|(
name|p
operator|=
name|QIOread
argument_list|(
name|qp
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|QIOtoolong
argument_list|(
name|qp
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|QIOerror
argument_list|(
name|qp
argument_list|)
condition|)
block|{
name|QIOclose
argument_list|(
name|qp
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
break|break;
block|}
comment|/* Calculate total size, fix hardwired headers. */
name|ov_size
operator|=
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
name|ARTfieldsize
operator|+
literal|2
expr_stmt|;
for|for
control|(
name|hp
operator|=
name|Headers
operator|,
name|fp
operator|=
name|ARTfields
operator|,
name|i
operator|=
name|ARTfieldsize
init|;
operator|--
name|i
operator|>=
literal|0
condition|;
name|hp
operator|++
operator|,
name|fp
operator|++
control|)
block|{
if|if
condition|(
name|caseEQ
argument_list|(
name|fp
operator|->
name|Header
argument_list|,
literal|"Bytes"
argument_list|)
operator|||
name|caseEQ
argument_list|(
name|fp
operator|->
name|Header
argument_list|,
literal|"Lines"
argument_list|)
condition|)
block|{
if|if
condition|(
name|fp
operator|->
name|Header
index|[
literal|0
index|]
operator|==
literal|'B'
operator|||
name|fp
operator|->
name|Header
index|[
literal|0
index|]
operator|==
literal|'b'
condition|)
name|t
operator|=
name|fstat
argument_list|(
name|QIOfileno
argument_list|(
name|qp
argument_list|)
argument_list|,
operator|&
name|Sb
argument_list|)
operator|>=
literal|0
condition|?
operator|(
name|long
operator|)
name|Sb
operator|.
name|st_size
else|:
literal|0L
expr_stmt|;
else|else
name|t
operator|=
name|lines
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|value
argument_list|,
literal|"%ld"
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|size
operator|=
name|strlen
argument_list|(
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|hp
operator|->
name|Length
operator|==
literal|0
condition|)
block|{
name|hp
operator|->
name|Length
operator|=
name|size
expr_stmt|;
name|hp
operator|->
name|Header
operator|=
name|NEW
argument_list|(
name|char
argument_list|,
name|hp
operator|->
name|Length
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|hp
operator|->
name|Length
operator|<
name|size
condition|)
block|{
name|hp
operator|->
name|Length
operator|=
name|size
expr_stmt|;
name|RENEW
argument_list|(
name|hp
operator|->
name|Header
argument_list|,
name|char
argument_list|,
name|hp
operator|->
name|Length
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|hp
operator|->
name|Header
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|hp
operator|->
name|HasHeader
operator|=
name|TRUE
expr_stmt|;
block|}
if|if
condition|(
name|hp
operator|->
name|HasHeader
condition|)
name|ov_size
operator|+=
name|strlen
argument_list|(
name|hp
operator|->
name|Header
argument_list|)
expr_stmt|;
block|}
comment|/* Get space. */
if|if
condition|(
name|B
operator|.
name|Size
operator|==
literal|0
condition|)
block|{
name|B
operator|.
name|Size
operator|=
name|ov_size
expr_stmt|;
name|B
operator|.
name|Data
operator|=
name|NEW
argument_list|(
name|char
argument_list|,
name|B
operator|.
name|Size
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|B
operator|.
name|Size
operator|<
name|ov_size
condition|)
block|{
name|B
operator|.
name|Size
operator|=
name|ov_size
expr_stmt|;
name|RENEW
argument_list|(
name|B
operator|.
name|Data
argument_list|,
name|char
argument_list|,
name|B
operator|.
name|Size
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Glue all the fields together. */
name|p
operator|=
name|B
operator|.
name|Data
operator|+
name|strlen
argument_list|(
name|strcpy
argument_list|(
name|B
operator|.
name|Data
argument_list|,
name|name
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|hp
operator|=
name|Headers
operator|,
name|i
operator|=
name|ARTfieldsize
init|;
operator|--
name|i
operator|>=
literal|0
condition|;
name|hp
operator|++
control|)
block|{
operator|*
name|p
operator|++
operator|=
literal|'\t'
expr_stmt|;
if|if
condition|(
name|hp
operator|->
name|HasHeader
condition|)
name|p
operator|+=
name|strlen
argument_list|(
name|strcpy
argument_list|(
name|p
argument_list|,
name|hp
operator|->
name|Header
argument_list|)
argument_list|)
expr_stmt|;
block|}
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
name|QIOclose
argument_list|(
name|qp
argument_list|)
expr_stmt|;
return|return
name|B
operator|.
name|Data
return|;
block|}
end_function

begin_comment
comment|/* **  Take in a sorted list of count article numbers in group, and add **  them them to the overview file. */
end_comment

begin_function
name|STATIC
name|void
name|AddLines
parameter_list|(
name|group
parameter_list|,
name|Adds
parameter_list|)
name|char
modifier|*
name|group
decl_stmt|;
name|LIST
modifier|*
name|Adds
decl_stmt|;
block|{
specifier|static
name|BUFFER
name|New
decl_stmt|;
specifier|static
name|BUFFER
name|B
decl_stmt|;
specifier|static
name|LINE
modifier|*
name|Lines
decl_stmt|;
specifier|static
name|int
name|LineSize
decl_stmt|;
specifier|register
name|LINE
modifier|*
name|lp
decl_stmt|;
specifier|register
name|char
modifier|*
name|next
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|struct
name|iovec
modifier|*
name|vp
decl_stmt|;
specifier|register
name|ARTNUM
modifier|*
name|ap
decl_stmt|;
name|LINE
modifier|*
name|end
decl_stmt|;
name|struct
name|iovec
name|iov
index|[
literal|8
index|]
decl_stmt|;
name|struct
name|stat
name|Sb
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|char
name|file
index|[
name|SPOOLNAMEBUFF
index|]
decl_stmt|;
name|char
name|lockfile
index|[
name|SPOOLNAMEBUFF
index|]
decl_stmt|;
name|int
name|LineUsed
decl_stmt|;
name|int
name|fd
decl_stmt|;
name|int
name|lfd
decl_stmt|;
if|if
condition|(
name|Verbose
condition|)
block|{
for|for
control|(
name|ap
operator|=
name|Adds
operator|->
name|Articles
operator|,
name|i
operator|=
name|Adds
operator|->
name|Used
init|;
operator|--
name|i
operator|>=
literal|0
condition|;
name|ap
operator|++
control|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"+ %s/%ld\n"
argument_list|,
name|group
argument_list|,
operator|*
name|ap
argument_list|)
expr_stmt|;
if|if
condition|(
name|DoNothing
condition|)
return|return;
block|}
comment|/* Get space. */
if|if
condition|(
name|New
operator|.
name|Data
operator|==
name|NULL
condition|)
block|{
name|New
operator|.
name|Size
operator|=
literal|1024
expr_stmt|;
name|New
operator|.
name|Data
operator|=
name|NEW
argument_list|(
name|char
argument_list|,
name|New
operator|.
name|Size
argument_list|)
expr_stmt|;
name|LineSize
operator|=
name|Adds
operator|->
name|Size
operator|+
literal|1
expr_stmt|;
name|Lines
operator|=
name|NEW
argument_list|(
name|LINE
argument_list|,
name|LineSize
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|LineSize
operator|<
name|Adds
operator|->
name|Size
condition|)
block|{
name|LineSize
operator|=
name|Adds
operator|->
name|Size
operator|+
literal|1
expr_stmt|;
name|RENEW
argument_list|(
name|Lines
argument_list|,
name|LINE
argument_list|,
name|LineSize
argument_list|)
expr_stmt|;
block|}
name|New
operator|.
name|Used
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|lp
operator|=
name|Lines
operator|,
name|ap
operator|=
name|Adds
operator|->
name|Articles
operator|,
name|i
operator|=
name|Adds
operator|->
name|Used
init|;
operator|--
name|i
operator|>=
literal|0
condition|;
name|ap
operator|++
control|)
block|{
comment|/* Get the overview data. */
if|if
condition|(
name|InSpoolDir
condition|)
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|file
argument_list|,
literal|"%s/%ld"
argument_list|,
name|group
argument_list|,
operator|*
name|ap
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|file
argument_list|,
literal|"%s/%s/%ld"
argument_list|,
name|SPOOL
argument_list|,
name|group
argument_list|,
operator|*
name|ap
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|p
operator|=
name|OVERgen
argument_list|(
name|file
argument_list|)
operator|)
operator|==
name|NULL
condition|)
continue|continue;
comment|/* Add it to the buffer and the lines array. */
name|lp
operator|->
name|Article
operator|=
operator|*
name|ap
expr_stmt|;
name|lp
operator|->
name|Length
operator|=
name|strlen
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|lp
operator|->
name|Offset
operator|=
name|New
operator|.
name|Used
expr_stmt|;
while|while
condition|(
name|New
operator|.
name|Size
operator|<
name|New
operator|.
name|Used
operator|+
name|lp
operator|->
name|Length
operator|+
literal|1
condition|)
block|{
name|New
operator|.
name|Size
operator|*=
literal|2
expr_stmt|;
name|RENEW
argument_list|(
name|New
operator|.
name|Data
argument_list|,
name|char
argument_list|,
name|New
operator|.
name|Size
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|strcpy
argument_list|(
operator|&
name|New
operator|.
name|Data
index|[
name|New
operator|.
name|Used
index|]
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|New
operator|.
name|Used
operator|+=
name|lp
operator|->
name|Length
operator|++
expr_stmt|;
name|New
operator|.
name|Data
index|[
name|New
operator|.
name|Used
operator|++
index|]
operator|=
literal|'\n'
expr_stmt|;
name|lp
operator|++
expr_stmt|;
block|}
name|LineUsed
operator|=
name|lp
operator|-
name|Lines
expr_stmt|;
comment|/* Turn offsets into real pointers. */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|lp
operator|=
name|Lines
init|;
name|i
operator|<
name|LineUsed
condition|;
name|i
operator|++
operator|,
name|lp
operator|++
control|)
name|lp
operator|->
name|Start
operator|=
name|New
operator|.
name|Data
operator|+
name|lp
operator|->
name|Offset
expr_stmt|;
comment|/* Lock the group. */
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|lockfile
argument_list|,
literal|"%s/.LCK%s"
argument_list|,
name|group
argument_list|,
name|_PATH_OVERVIEW
argument_list|)
expr_stmt|;
name|lfd
operator|=
name|open
argument_list|(
name|lockfile
argument_list|,
name|O_WRONLY
operator||
name|O_TRUNC
operator||
name|O_CREAT
argument_list|,
name|ARTFILE_MODE
argument_list|)
expr_stmt|;
if|if
condition|(
name|lfd
operator|<
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Can't open %s, %s\n"
argument_list|,
name|lockfile
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Open file, lock it. */
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|file
argument_list|,
literal|"%s/%s"
argument_list|,
name|group
argument_list|,
name|_PATH_OVERVIEW
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
operator|(
name|fd
operator|=
name|open
argument_list|(
name|file
argument_list|,
name|O_RDWR
operator||
name|O_CREAT
argument_list|,
name|ARTFILE_MODE
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Can't open %s, %s\n"
argument_list|,
name|file
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|UnlockGroup
argument_list|(
name|lfd
argument_list|,
name|lockfile
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|LockFile
argument_list|(
name|fd
argument_list|,
name|FALSE
argument_list|)
operator|>=
literal|0
condition|)
break|break;
comment|/* Wait for lock; close file -- might be unlinked -- and try again. */
operator|(
name|void
operator|)
name|LockFile
argument_list|(
name|fd
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fstat
argument_list|(
name|fd
argument_list|,
operator|&
name|Sb
argument_list|)
operator|<
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Can't open %s, %s\n"
argument_list|,
name|file
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|UnlockGroup
argument_list|(
name|lfd
argument_list|,
name|lockfile
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|Sb
operator|.
name|st_size
operator|!=
literal|0
condition|)
block|{
comment|/* Read in the whole file. */
if|if
condition|(
name|B
operator|.
name|Size
operator|==
literal|0
condition|)
block|{
name|B
operator|.
name|Size
operator|=
name|Sb
operator|.
name|st_size
operator|+
literal|1
expr_stmt|;
name|B
operator|.
name|Data
operator|=
name|NEW
argument_list|(
name|char
argument_list|,
name|B
operator|.
name|Size
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|B
operator|.
name|Size
operator|<
name|Sb
operator|.
name|st_size
condition|)
block|{
name|B
operator|.
name|Size
operator|=
name|Sb
operator|.
name|st_size
operator|+
literal|1
expr_stmt|;
name|RENEW
argument_list|(
name|B
operator|.
name|Data
argument_list|,
name|char
argument_list|,
name|B
operator|.
name|Size
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|xread
argument_list|(
name|fd
argument_list|,
name|B
operator|.
name|Data
argument_list|,
name|Sb
operator|.
name|st_size
argument_list|)
operator|<
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Can't read %s, %s\n"
argument_list|,
name|file
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|UnlockGroup
argument_list|(
name|lfd
argument_list|,
name|lockfile
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return;
block|}
name|B
operator|.
name|Data
index|[
name|Sb
operator|.
name|st_size
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* Count lines, get space. */
for|for
control|(
name|i
operator|=
literal|1
operator|,
name|p
operator|=
name|B
operator|.
name|Data
init|;
operator|(
name|p
operator|=
name|strchr
argument_list|(
name|p
argument_list|,
literal|'\n'
argument_list|)
operator|)
operator|!=
name|NULL
operator|&&
operator|*
operator|++
name|p
condition|;
name|i
operator|++
control|)
continue|continue;
if|if
condition|(
name|LineSize
operator|<
name|i
operator|+
literal|1
operator|+
name|LineUsed
condition|)
block|{
name|LineSize
operator|=
name|i
operator|+
literal|1
operator|+
name|LineUsed
expr_stmt|;
name|RENEW
argument_list|(
name|Lines
argument_list|,
name|LINE
argument_list|,
name|LineSize
argument_list|)
expr_stmt|;
block|}
comment|/* Add to lines array. */
for|for
control|(
name|lp
operator|=
name|Lines
operator|+
name|LineUsed
operator|,
name|p
operator|=
name|B
operator|.
name|Data
init|;
condition|;
name|p
operator|=
name|next
operator|,
name|lp
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|next
operator|=
name|strchr
argument_list|(
name|p
argument_list|,
literal|'\n'
argument_list|)
operator|)
operator|==
name|NULL
condition|)
break|break;
name|lp
operator|->
name|Start
operator|=
name|p
expr_stmt|;
name|lp
operator|->
name|Length
operator|=
operator|++
name|next
operator|-
name|p
expr_stmt|;
name|lp
operator|->
name|Article
operator|=
name|atol
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
name|qsort
argument_list|(
operator|(
name|POINTER
operator|)
name|Lines
argument_list|,
call|(
name|SIZE_T
call|)
argument_list|(
name|lp
operator|-
name|Lines
argument_list|)
argument_list|,
sizeof|sizeof
name|lp
index|[
literal|0
index|]
argument_list|,
name|LINEcompare
argument_list|)
expr_stmt|;
name|LineUsed
operator|=
name|lp
operator|-
name|Lines
expr_stmt|;
block|}
comment|/* Remove duplicates. */
for|for
control|(
name|end
operator|=
name|lp
operator|-
literal|1
operator|,
name|lp
operator|=
name|Lines
init|;
name|lp
operator|<
name|end
condition|;
name|lp
operator|++
control|)
if|if
condition|(
name|lp
index|[
literal|0
index|]
operator|.
name|Article
operator|==
name|lp
index|[
literal|1
index|]
operator|.
name|Article
condition|)
name|lp
operator|->
name|Article
operator|=
literal|0
expr_stmt|;
comment|/* Scan through lines, collecting rocks and holes. */
name|iov
index|[
literal|0
index|]
operator|.
name|iov_len
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|vp
operator|=
name|iov
operator|,
name|lp
operator|=
name|Lines
init|;
name|lp
operator|<
name|end
operator|+
literal|1
condition|;
name|lp
operator|++
control|)
block|{
comment|/* An already-removed article, or one that should be? */
if|if
condition|(
name|lp
operator|->
name|Article
operator|==
literal|0
condition|)
continue|continue;
comment|/* We're keeping this entry; see if we can add it to any in-progress 	 * iov element. */
if|if
condition|(
name|vp
operator|->
name|iov_len
condition|)
block|{
if|if
condition|(
name|vp
operator|->
name|iov_base
operator|+
name|vp
operator|->
name|iov_len
operator|==
name|lp
operator|->
name|Start
condition|)
block|{
comment|/* Contiguous. */
name|vp
operator|->
name|iov_len
operator|+=
name|lp
operator|->
name|Length
expr_stmt|;
continue|continue;
block|}
comment|/* Doesn't fit -- get a new element. */
if|if
condition|(
operator|++
name|vp
operator|==
name|ENDOF
argument_list|(
name|iov
argument_list|)
condition|)
block|{
if|if
condition|(
name|xwritev
argument_list|(
name|lfd
argument_list|,
name|iov
argument_list|,
name|SIZEOF
argument_list|(
name|iov
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Can't write %s, %s\n"
argument_list|,
name|lockfile
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|UnlockGroup
argument_list|(
name|lfd
argument_list|,
name|lockfile
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return;
block|}
name|vp
operator|=
name|iov
expr_stmt|;
block|}
block|}
comment|/* Start new element. */
name|vp
operator|->
name|iov_base
operator|=
name|lp
operator|->
name|Start
expr_stmt|;
name|vp
operator|->
name|iov_len
operator|=
name|lp
operator|->
name|Length
expr_stmt|;
block|}
if|if
condition|(
name|vp
operator|->
name|iov_len
condition|)
name|vp
operator|++
expr_stmt|;
comment|/* Write out remaining. */
if|if
condition|(
name|iov
index|[
literal|0
index|]
operator|.
name|iov_len
operator|&&
name|xwritev
argument_list|(
name|lfd
argument_list|,
name|iov
argument_list|,
name|vp
operator|-
name|iov
argument_list|)
operator|<
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Can't write %s, %s\n"
argument_list|,
name|lockfile
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|UnlockGroup
argument_list|(
name|lfd
argument_list|,
name|lockfile
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|rename
argument_list|(
name|lockfile
argument_list|,
name|file
argument_list|)
operator|<
literal|0
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Can't rename %s, %s\n"
argument_list|,
name|lockfile
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Don't call UnlockGroup; do it inline. */
if|if
condition|(
name|close
argument_list|(
name|lfd
argument_list|)
operator|<
literal|0
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"expireover cant close %s %s\n"
argument_list|,
name|file
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|close
argument_list|(
name|fd
argument_list|)
operator|<
literal|0
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"expireover cant close unlinked %s %s\n"
argument_list|,
name|file
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* **  Expire by batch, or line at a time. */
end_comment

begin_function
name|STATIC
name|void
name|Expire
parameter_list|(
name|SortedInput
parameter_list|,
name|qp
parameter_list|)
name|BOOL
name|SortedInput
decl_stmt|;
specifier|register
name|QIOSTATE
modifier|*
name|qp
decl_stmt|;
block|{
specifier|static
name|LIST
name|List
decl_stmt|;
specifier|register
name|char
modifier|*
name|line
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|char
name|group
index|[
name|SPOOLNAMEBUFF
index|]
decl_stmt|;
if|if
condition|(
name|List
operator|.
name|Articles
operator|==
name|NULL
condition|)
block|{
name|List
operator|.
name|Size
operator|=
name|START_LIST_SIZE
expr_stmt|;
name|List
operator|.
name|Articles
operator|=
name|NEW
argument_list|(
name|ARTNUM
argument_list|,
name|List
operator|.
name|Size
argument_list|)
expr_stmt|;
block|}
name|List
operator|.
name|Used
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|SortedInput
condition|)
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
operator|(
name|line
operator|=
name|QIOread
argument_list|(
name|qp
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|QIOerror
argument_list|(
name|qp
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Can't read input %s\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|QIOtoolong
argument_list|(
name|qp
argument_list|)
condition|)
continue|continue;
break|break;
block|}
if|if
condition|(
operator|(
name|p
operator|=
name|strrchr
argument_list|(
name|line
argument_list|,
literal|'/'
argument_list|)
operator|)
operator|==
name|NULL
condition|)
continue|continue;
operator|*
name|p
operator|++
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|List
operator|.
name|Used
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|group
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|List
operator|.
name|Used
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|EQ
argument_list|(
name|line
argument_list|,
name|group
argument_list|)
condition|)
block|{
name|LISTsort
argument_list|(
operator|&
name|List
argument_list|)
expr_stmt|;
name|RemoveLines
argument_list|(
name|group
argument_list|,
operator|&
name|List
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|group
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|List
operator|.
name|Used
operator|=
literal|0
expr_stmt|;
block|}
name|LISTappend
argument_list|(
name|List
argument_list|,
name|atol
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Do the last group. */
if|if
condition|(
name|List
operator|.
name|Used
condition|)
block|{
name|LISTsort
argument_list|(
operator|&
name|List
argument_list|)
expr_stmt|;
name|RemoveLines
argument_list|(
name|group
argument_list|,
operator|&
name|List
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
for|for
control|(
name|List
operator|.
name|Used
operator|=
literal|1
init|;
condition|;
control|)
block|{
if|if
condition|(
operator|(
name|line
operator|=
name|QIOread
argument_list|(
name|qp
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|QIOerror
argument_list|(
name|qp
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Can't read input %s\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|QIOtoolong
argument_list|(
name|qp
argument_list|)
condition|)
continue|continue;
break|break;
block|}
if|if
condition|(
operator|(
name|p
operator|=
name|strrchr
argument_list|(
name|line
argument_list|,
literal|'/'
argument_list|)
operator|)
operator|==
name|NULL
condition|)
continue|continue;
operator|*
name|p
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|List
operator|.
name|Articles
index|[
literal|0
index|]
operator|=
name|atol
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|RemoveLines
argument_list|(
name|line
argument_list|,
operator|&
name|List
argument_list|)
expr_stmt|;
block|}
block|}
name|QIOclose
argument_list|(
name|qp
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* **  Read the overview file, return sorted list of all articles in it. */
end_comment

begin_function
name|STATIC
name|LIST
modifier|*
name|GetOverviewList
parameter_list|(
name|group
parameter_list|)
name|char
modifier|*
name|group
decl_stmt|;
block|{
specifier|static
name|LIST
name|List
decl_stmt|;
specifier|register
name|QIOSTATE
modifier|*
name|qp
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|char
name|file
index|[
name|SPOOLNAMEBUFF
index|]
decl_stmt|;
comment|/* Open the file. */
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|file
argument_list|,
literal|"%s/%s"
argument_list|,
name|group
argument_list|,
name|_PATH_OVERVIEW
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|qp
operator|=
name|QIOopen
argument_list|(
name|file
argument_list|,
name|QIO_BUFFER
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
comment|/* Setup the article list. */
if|if
condition|(
name|List
operator|.
name|Articles
operator|==
name|NULL
condition|)
block|{
name|List
operator|.
name|Size
operator|=
name|START_LIST_SIZE
expr_stmt|;
name|List
operator|.
name|Articles
operator|=
name|NEW
argument_list|(
name|ARTNUM
argument_list|,
name|List
operator|.
name|Size
argument_list|)
expr_stmt|;
block|}
name|List
operator|.
name|Used
operator|=
literal|0
expr_stmt|;
comment|/* Read all lines, picking up the article number. */
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
operator|(
name|p
operator|=
name|QIOread
argument_list|(
name|qp
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|QIOerror
argument_list|(
name|qp
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Can't read %s, %s\n"
argument_list|,
name|file
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|QIOclose
argument_list|(
name|qp
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|QIOtoolong
argument_list|(
name|qp
argument_list|)
condition|)
continue|continue;
break|break;
block|}
name|LISTappend
argument_list|(
name|List
argument_list|,
name|atol
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|QIOclose
argument_list|(
name|qp
argument_list|)
expr_stmt|;
if|if
condition|(
name|List
operator|.
name|Used
operator|==
literal|0
condition|)
return|return
name|NULL
return|;
name|LISTsort
argument_list|(
operator|&
name|List
argument_list|)
expr_stmt|;
return|return
operator|&
name|List
return|;
block|}
end_function

begin_comment
comment|/* **  Read spool directory and return sorted list of articles or NULL on error. */
end_comment

begin_function
name|STATIC
name|LIST
modifier|*
name|GetSpoolList
parameter_list|(
name|group
parameter_list|)
name|char
modifier|*
name|group
decl_stmt|;
block|{
specifier|static
name|LIST
name|List
decl_stmt|;
specifier|register
name|DIR
modifier|*
name|dp
decl_stmt|;
specifier|register
name|DIRENTRY
modifier|*
name|ep
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|char
name|buff
index|[
name|SPOOLNAMEBUFF
index|]
decl_stmt|;
comment|/* Open directory. */
if|if
condition|(
name|InSpoolDir
condition|)
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|buff
argument_list|,
name|group
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buff
argument_list|,
literal|"%s/%s"
argument_list|,
name|SPOOL
argument_list|,
name|group
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|dp
operator|=
name|opendir
argument_list|(
name|buff
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
comment|/* Setup article list. */
if|if
condition|(
name|List
operator|.
name|Articles
operator|==
name|NULL
condition|)
block|{
name|List
operator|.
name|Size
operator|=
name|START_LIST_SIZE
expr_stmt|;
name|List
operator|.
name|Articles
operator|=
name|NEW
argument_list|(
name|ARTNUM
argument_list|,
name|List
operator|.
name|Size
argument_list|)
expr_stmt|;
block|}
name|List
operator|.
name|Used
operator|=
literal|0
expr_stmt|;
comment|/* Get all articles. */
while|while
condition|(
operator|(
name|ep
operator|=
name|readdir
argument_list|(
name|dp
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|p
operator|=
name|ep
operator|->
name|d_name
expr_stmt|;
if|if
condition|(
operator|!
name|CTYPE
argument_list|(
name|isdigit
argument_list|,
name|p
index|[
literal|0
index|]
argument_list|)
operator|||
name|strspn
argument_list|(
name|p
argument_list|,
literal|"0123456789"
argument_list|)
operator|!=
name|strlen
argument_list|(
name|p
argument_list|)
condition|)
continue|continue;
name|LISTappend
argument_list|(
name|List
argument_list|,
name|atol
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|closedir
argument_list|(
name|dp
argument_list|)
expr_stmt|;
if|if
condition|(
name|List
operator|.
name|Used
operator|==
literal|0
condition|)
return|return
name|NULL
return|;
name|LISTsort
argument_list|(
operator|&
name|List
argument_list|)
expr_stmt|;
return|return
operator|&
name|List
return|;
block|}
end_function

begin_comment
comment|/* **  Return a list of all articles in the Over list that are not in **  the Spool list.  Both lists are sorted.  See SpoolUpdate for an **  explanation of the names. */
end_comment

begin_function
name|STATIC
name|LIST
modifier|*
name|GetNotIn
parameter_list|(
name|Over
parameter_list|,
name|Spool
parameter_list|)
specifier|register
name|LIST
modifier|*
name|Over
decl_stmt|;
specifier|register
name|LIST
modifier|*
name|Spool
decl_stmt|;
block|{
specifier|static
name|LIST
name|List
decl_stmt|;
specifier|register
name|ARTNUM
modifier|*
name|oEnd
decl_stmt|;
specifier|register
name|ARTNUM
modifier|*
name|sEnd
decl_stmt|;
specifier|register
name|ARTNUM
modifier|*
name|o
decl_stmt|;
specifier|register
name|ARTNUM
modifier|*
name|s
decl_stmt|;
comment|/* Setup the list. */
if|if
condition|(
name|List
operator|.
name|Articles
operator|==
name|NULL
condition|)
block|{
name|List
operator|.
name|Size
operator|=
name|START_LIST_SIZE
expr_stmt|;
name|List
operator|.
name|Articles
operator|=
name|NEW
argument_list|(
name|ARTNUM
argument_list|,
name|List
operator|.
name|Size
argument_list|)
expr_stmt|;
block|}
name|List
operator|.
name|Used
operator|=
literal|0
expr_stmt|;
name|o
operator|=
name|Over
operator|->
name|Articles
expr_stmt|;
name|s
operator|=
name|Spool
operator|->
name|Articles
expr_stmt|;
name|oEnd
operator|=
name|o
operator|+
name|Over
operator|->
name|Used
expr_stmt|;
name|sEnd
operator|=
name|s
operator|+
name|Spool
operator|->
name|Used
expr_stmt|;
while|while
condition|(
name|o
operator|!=
name|oEnd
operator|&&
name|s
operator|!=
name|sEnd
condition|)
block|{
if|if
condition|(
operator|*
name|o
operator|<
operator|*
name|s
condition|)
block|{
name|LISTappend
argument_list|(
name|List
argument_list|,
operator|*
name|o
operator|++
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|*
name|o
operator|==
operator|*
name|s
condition|)
name|o
operator|++
expr_stmt|;
name|s
operator|++
expr_stmt|;
block|}
comment|/* If we hit the end of the Spool, then add everything else in the      * Overview. */
if|if
condition|(
name|s
operator|==
name|sEnd
condition|)
block|{
while|while
condition|(
name|o
operator|!=
name|oEnd
condition|)
name|LISTappend
argument_list|(
name|List
argument_list|,
operator|*
name|o
operator|++
argument_list|)
expr_stmt|;
block|}
return|return
name|List
operator|.
name|Used
condition|?
operator|&
name|List
else|:
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* **  Try to make one directory.  Return FALSE on error. */
end_comment

begin_function
name|STATIC
name|BOOL
name|MakeDir
parameter_list|(
name|Name
parameter_list|)
name|char
modifier|*
name|Name
decl_stmt|;
block|{
name|struct
name|stat
name|Sb
decl_stmt|;
if|if
condition|(
name|mkdir
argument_list|(
name|Name
argument_list|,
name|GROUPDIR_MODE
argument_list|)
operator|>=
literal|0
condition|)
return|return
name|TRUE
return|;
comment|/* See if it failed because it already exists. */
return|return
name|stat
argument_list|(
name|Name
argument_list|,
operator|&
name|Sb
argument_list|)
operator|>=
literal|0
operator|&&
name|S_ISDIR
argument_list|(
name|Sb
operator|.
name|st_mode
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* **  Given a directory, comp/foo/bar, create that directory and all **  intermediate directories needed.  Return FALSE on error. */
end_comment

begin_function
name|BOOL
name|MakeOverDir
parameter_list|(
name|Name
parameter_list|)
specifier|register
name|char
modifier|*
name|Name
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|BOOL
name|made
decl_stmt|;
comment|/* Optimize common case -- parent almost always exists. */
if|if
condition|(
name|MakeDir
argument_list|(
name|Name
argument_list|)
condition|)
return|return
name|TRUE
return|;
comment|/* Try to make each of comp and comp/foo in turn. */
for|for
control|(
name|p
operator|=
name|Name
init|;
operator|*
name|p
condition|;
name|p
operator|++
control|)
if|if
condition|(
operator|*
name|p
operator|==
literal|'/'
condition|)
block|{
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
name|made
operator|=
name|MakeDir
argument_list|(
name|Name
argument_list|)
expr_stmt|;
operator|*
name|p
operator|=
literal|'/'
expr_stmt|;
if|if
condition|(
operator|!
name|made
condition|)
return|return
name|FALSE
return|;
block|}
return|return
name|MakeDir
argument_list|(
name|Name
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* **  Update using the News Spool.  Either add or delete entries. */
end_comment

begin_function
name|STATIC
name|void
name|SpoolUpdate
parameter_list|(
name|AddEntries
parameter_list|,
name|Name
parameter_list|)
name|BOOL
name|AddEntries
decl_stmt|;
name|char
modifier|*
name|Name
decl_stmt|;
block|{
specifier|register
name|QIOSTATE
modifier|*
name|qp
decl_stmt|;
specifier|register
name|char
modifier|*
name|line
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|LIST
modifier|*
name|Over
decl_stmt|;
name|LIST
modifier|*
name|Spool
decl_stmt|;
name|LIST
modifier|*
name|Missing
decl_stmt|;
comment|/* Open file. */
if|if
condition|(
name|EQ
argument_list|(
name|Name
argument_list|,
literal|"-"
argument_list|)
condition|)
name|qp
operator|=
name|QIOfdopen
argument_list|(
name|STDIN
argument_list|,
name|QIO_BUFFER
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|qp
operator|=
name|QIOopen
argument_list|(
name|Name
argument_list|,
name|QIO_BUFFER
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Can't open %s, %s\n"
argument_list|,
name|Name
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|AddEntries
condition|)
name|ARTreadschema
argument_list|()
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
operator|(
name|line
operator|=
name|QIOread
argument_list|(
name|qp
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|QIOtoolong
argument_list|(
name|qp
argument_list|)
operator|||
name|QIOerror
argument_list|(
name|qp
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Line too long or error reading %s, %s\n"
argument_list|,
name|Name
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
comment|/* Nip off newsgroup name, and turn it into a directory. */
for|for
control|(
name|p
operator|=
name|line
init|;
operator|*
name|p
operator|&&
operator|!
name|ISWHITE
argument_list|(
operator|*
name|p
argument_list|)
operator|&&
operator|*
name|p
operator|!=
literal|'\n'
condition|;
name|p
operator|++
control|)
if|if
condition|(
operator|*
name|p
operator|==
literal|'.'
condition|)
operator|*
name|p
operator|=
literal|'/'
expr_stmt|;
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|AddEntries
condition|)
block|{
if|if
condition|(
operator|(
name|Spool
operator|=
name|GetSpoolList
argument_list|(
name|line
argument_list|)
operator|)
operator|==
name|NULL
condition|)
continue|continue;
if|if
condition|(
operator|(
name|Over
operator|=
name|GetOverviewList
argument_list|(
name|line
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|Missing
operator|=
name|GetNotIn
argument_list|(
name|Spool
argument_list|,
name|Over
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|AddLines
argument_list|(
name|line
argument_list|,
name|Missing
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|InSpoolDir
condition|)
block|{
if|if
condition|(
name|MakeOverDir
argument_list|(
name|line
argument_list|)
condition|)
name|AddLines
argument_list|(
name|line
argument_list|,
name|Spool
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"expireover: cant mkdir %s, %s\n"
argument_list|,
name|line
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|AddLines
argument_list|(
name|line
argument_list|,
name|Spool
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|(
name|Over
operator|=
name|GetOverviewList
argument_list|(
name|line
argument_list|)
operator|)
operator|==
name|NULL
condition|)
continue|continue;
if|if
condition|(
operator|(
name|Spool
operator|=
name|GetSpoolList
argument_list|(
name|line
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|Missing
operator|=
name|GetNotIn
argument_list|(
name|Over
argument_list|,
name|Spool
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|RemoveLines
argument_list|(
name|line
argument_list|,
name|Missing
argument_list|)
expr_stmt|;
block|}
else|else
name|RemoveLines
argument_list|(
name|line
argument_list|,
name|Over
argument_list|)
expr_stmt|;
block|}
name|QIOclose
argument_list|(
name|qp
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* **  Print usage message and exit. */
end_comment

begin_function
name|STATIC
name|NORETURN
name|Usage
parameter_list|()
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Usage:  expireover [flags] [file...]\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|main
parameter_list|(
name|ac
parameter_list|,
name|av
parameter_list|)
name|int
name|ac
decl_stmt|;
name|char
modifier|*
name|av
index|[]
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|QIOSTATE
modifier|*
name|qp
decl_stmt|;
name|BOOL
name|AddEntries
decl_stmt|;
name|BOOL
name|ReadSpool
decl_stmt|;
name|BOOL
name|SortedInput
decl_stmt|;
name|char
modifier|*
name|Dir
decl_stmt|;
name|char
modifier|*
name|Name
decl_stmt|;
comment|/* Set defaults. */
name|Dir
operator|=
name|_PATH_OVERVIEWDIR
expr_stmt|;
name|Name
operator|=
name|_PATH_ACTIVE
expr_stmt|;
name|AddEntries
operator|=
name|FALSE
expr_stmt|;
name|ReadSpool
operator|=
name|FALSE
expr_stmt|;
name|SortedInput
operator|=
name|FALSE
expr_stmt|;
operator|(
name|void
operator|)
name|umask
argument_list|(
name|NEWSUMASK
argument_list|)
expr_stmt|;
comment|/* Parse JCL. */
while|while
condition|(
operator|(
name|i
operator|=
name|getopt
argument_list|(
name|ac
argument_list|,
name|av
argument_list|,
literal|"aD:f:nO:svz"
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
switch|switch
condition|(
name|i
condition|)
block|{
default|default:
name|Usage
argument_list|()
expr_stmt|;
comment|/* NOTREACHED */
case|case
literal|'a'
case|:
name|AddEntries
operator|=
name|TRUE
expr_stmt|;
name|ReadSpool
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'D'
case|:
name|Dir
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
name|Name
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
name|DoNothing
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'O'
case|:
name|SCHEMA
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
name|ReadSpool
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
name|Verbose
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'z'
case|:
name|SortedInput
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
name|ac
operator|-=
name|optind
expr_stmt|;
name|av
operator|+=
name|optind
expr_stmt|;
if|if
condition|(
operator|(
name|ReadSpool
operator|&&
name|ac
operator|)
operator|||
operator|(
name|AddEntries
operator|&&
operator|!
name|ReadSpool
operator|)
condition|)
name|Usage
argument_list|()
expr_stmt|;
comment|/* Setup. */
if|if
condition|(
name|chdir
argument_list|(
name|Dir
argument_list|)
operator|<
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Cant chdir to %s, %s\n"
argument_list|,
name|Dir
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|InSpoolDir
operator|=
name|EQ
argument_list|(
name|Dir
argument_list|,
name|SPOOL
argument_list|)
expr_stmt|;
comment|/* Do work. */
if|if
condition|(
name|ReadSpool
condition|)
name|SpoolUpdate
argument_list|(
name|AddEntries
argument_list|,
name|Name
argument_list|)
expr_stmt|;
if|if
condition|(
name|ac
operator|==
literal|0
condition|)
name|Expire
argument_list|(
name|SortedInput
argument_list|,
name|QIOfdopen
argument_list|(
name|STDIN
argument_list|,
name|QIO_BUFFER
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
for|for
control|(
init|;
operator|*
name|av
condition|;
name|av
operator|++
control|)
if|if
condition|(
name|EQ
argument_list|(
operator|*
name|av
argument_list|,
literal|"-"
argument_list|)
condition|)
name|Expire
argument_list|(
name|SortedInput
argument_list|,
name|QIOfdopen
argument_list|(
name|STDIN
argument_list|,
name|QIO_BUFFER
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|qp
operator|=
name|QIOopen
argument_list|(
operator|*
name|av
argument_list|,
name|QIO_BUFFER
argument_list|)
operator|)
operator|==
name|NULL
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Can't open %s, %s\n"
argument_list|,
operator|*
name|av
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|Expire
argument_list|(
name|SortedInput
argument_list|,
name|qp
argument_list|)
expr_stmt|;
block|}
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
end_function

end_unit

