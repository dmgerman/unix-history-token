begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  $Revision: 1.13 $ ** **  Newsgroups and the active file. */
end_comment

begin_include
include|#
directive|include
file|"nnrpd.h"
end_include

begin_include
include|#
directive|include
file|"mydir.h"
end_include

begin_comment
comment|/* **  Newsgroup hashing stuff.  See comments in innd/ng.c. */
end_comment

begin_define
define|#
directive|define
name|GRP_HASH
parameter_list|(
name|Name
parameter_list|,
name|p
parameter_list|,
name|j
parameter_list|)
define|\
value|for (p = Name, j = 0; *p; ) j = (j<< 5) + j + *p++
end_define

begin_define
define|#
directive|define
name|GRP_SIZE
value|512
end_define

begin_define
define|#
directive|define
name|GRP_BUCKET
parameter_list|(
name|j
parameter_list|)
value|&GRPtable[j& (GRP_SIZE - 1)]
end_define

begin_typedef
typedef|typedef
struct|struct
name|_GRPHASH
block|{
name|int
name|Size
decl_stmt|;
name|int
name|Used
decl_stmt|;
name|GROUPENTRY
modifier|*
modifier|*
name|Groups
decl_stmt|;
block|}
name|GRPHASH
typedef|;
end_typedef

begin_decl_stmt
name|STATIC
name|GRPHASH
name|GRPtable
index|[
name|GRP_SIZE
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|GROUPENTRY
modifier|*
name|GRPentries
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|int
name|GRPbuckets
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|int
name|GRPsize
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* **  See if a given newsgroup exists. */
end_comment

begin_function
name|GROUPENTRY
modifier|*
name|GRPfind
parameter_list|(
name|group
parameter_list|)
specifier|register
name|char
modifier|*
name|group
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|unsigned
name|int
name|j
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|GROUPENTRY
modifier|*
modifier|*
name|gpp
decl_stmt|;
name|GRPHASH
modifier|*
name|htp
decl_stmt|;
name|char
name|c
decl_stmt|;
comment|/* SUPPRESS 6 */
comment|/* Over/underflow from plus expression */
name|GRP_HASH
argument_list|(
name|group
argument_list|,
name|p
argument_list|,
name|j
argument_list|)
expr_stmt|;
name|htp
operator|=
name|GRP_BUCKET
argument_list|(
name|j
argument_list|)
expr_stmt|;
for|for
control|(
name|c
operator|=
operator|*
name|group
operator|,
name|gpp
operator|=
name|htp
operator|->
name|Groups
operator|,
name|i
operator|=
name|htp
operator|->
name|Used
init|;
operator|--
name|i
operator|>=
literal|0
condition|;
name|gpp
operator|++
control|)
if|if
condition|(
name|c
operator|==
name|gpp
index|[
literal|0
index|]
operator|->
name|Name
index|[
literal|0
index|]
operator|&&
name|EQ
argument_list|(
name|group
argument_list|,
name|gpp
index|[
literal|0
index|]
operator|->
name|Name
argument_list|)
condition|)
return|return
name|gpp
index|[
literal|0
index|]
return|;
return|return
name|NULL
return|;
block|}
end_function

begin_function
name|STATIC
name|void
name|GRPhash
parameter_list|()
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|GROUPENTRY
modifier|*
name|gp
decl_stmt|;
specifier|register
name|unsigned
name|int
name|j
decl_stmt|;
specifier|register
name|GRPHASH
modifier|*
name|htp
decl_stmt|;
comment|/* Set up the default hash buckets. */
name|GRPbuckets
operator|=
name|GRPsize
operator|/
name|GRP_SIZE
expr_stmt|;
if|if
condition|(
name|GRPbuckets
operator|==
literal|0
condition|)
name|GRPbuckets
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|GRPtable
index|[
literal|0
index|]
operator|.
name|Groups
condition|)
for|for
control|(
name|i
operator|=
name|GRP_SIZE
operator|,
name|htp
operator|=
name|GRPtable
init|;
operator|--
name|i
operator|>=
literal|0
condition|;
name|htp
operator|++
control|)
name|htp
operator|->
name|Used
operator|=
literal|0
expr_stmt|;
else|else
for|for
control|(
name|i
operator|=
name|GRP_SIZE
operator|,
name|htp
operator|=
name|GRPtable
init|;
operator|--
name|i
operator|>=
literal|0
condition|;
name|htp
operator|++
control|)
block|{
name|htp
operator|->
name|Size
operator|=
name|GRPbuckets
expr_stmt|;
name|htp
operator|->
name|Groups
operator|=
name|NEW
argument_list|(
name|GROUPENTRY
operator|*
argument_list|,
name|htp
operator|->
name|Size
argument_list|)
expr_stmt|;
name|htp
operator|->
name|Used
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Now put all groups into the hash table. */
for|for
control|(
name|i
operator|=
name|GRPsize
operator|,
name|gp
operator|=
name|GRPentries
init|;
operator|--
name|i
operator|>=
literal|0
condition|;
name|gp
operator|++
control|)
block|{
comment|/* SUPPRESS 6 */
comment|/* Over/underflow from plus expression */
name|GRP_HASH
argument_list|(
name|gp
operator|->
name|Name
argument_list|,
name|p
argument_list|,
name|j
argument_list|)
expr_stmt|;
name|htp
operator|=
name|GRP_BUCKET
argument_list|(
name|j
argument_list|)
expr_stmt|;
if|if
condition|(
name|htp
operator|->
name|Used
operator|>=
name|htp
operator|->
name|Size
condition|)
block|{
name|htp
operator|->
name|Size
operator|+=
name|GRPbuckets
expr_stmt|;
name|RENEW
argument_list|(
name|htp
operator|->
name|Groups
argument_list|,
name|GROUPENTRY
operator|*
argument_list|,
name|htp
operator|->
name|Size
argument_list|)
expr_stmt|;
block|}
name|htp
operator|->
name|Groups
index|[
name|htp
operator|->
name|Used
operator|++
index|]
operator|=
name|gp
expr_stmt|;
block|}
comment|/* Note that we don't sort the buckets. */
block|}
end_function

begin_comment
comment|/* **  Read the active file into memory, sort it, and set the number of **  newsgroups read in.  Return TRUE if okay, FALSE on error. */
end_comment

begin_function
name|BOOL
name|GetGroupList
parameter_list|()
block|{
specifier|static
name|char
modifier|*
name|active
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|char
modifier|*
name|q
decl_stmt|;
specifier|register
name|GROUPENTRY
modifier|*
name|gp
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
comment|/* If re-scanning, free previous groups. */
if|if
condition|(
name|active
operator|!=
name|NULL
condition|)
block|{
name|DISPOSE
argument_list|(
name|active
argument_list|)
expr_stmt|;
name|DISPOSE
argument_list|(
name|GRPentries
argument_list|)
expr_stmt|;
block|}
comment|/* Get the new file. */
name|active
operator|=
name|ReadInFile
argument_list|(
name|ACTIVE
argument_list|,
operator|(
expr|struct
name|stat
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|active
operator|==
name|NULL
condition|)
block|{
name|syslog
argument_list|(
name|L_ERROR
argument_list|,
literal|"%s cant read %s %m"
argument_list|,
name|ClientHost
argument_list|,
name|ACTIVE
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
comment|/* Count lines. */
for|for
control|(
name|p
operator|=
name|active
operator|,
name|i
operator|=
literal|0
init|;
operator|(
name|p
operator|=
name|strchr
argument_list|(
name|p
argument_list|,
literal|'\n'
argument_list|)
operator|)
operator|!=
name|NULL
condition|;
name|p
operator|++
operator|,
name|i
operator|++
control|)
continue|continue;
comment|/* Fill in the group array. */
name|GRPentries
operator|=
name|NEW
argument_list|(
name|GROUPENTRY
argument_list|,
name|i
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|gp
operator|=
name|GRPentries
operator|,
name|p
operator|=
name|active
init|;
operator|*
name|p
condition|;
name|i
operator|++
operator|,
name|gp
operator|++
operator|,
name|p
operator|=
name|q
operator|+
literal|1
control|)
block|{
name|gp
operator|->
name|Name
operator|=
name|p
expr_stmt|;
if|if
condition|(
operator|(
name|p
operator|=
name|strchr
argument_list|(
name|p
argument_list|,
literal|' '
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|syslog
argument_list|(
name|L_ERROR
argument_list|,
literal|"%s internal no_space1 \"%.20s...\""
argument_list|,
name|ClientHost
argument_list|,
name|gp
operator|->
name|Name
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
operator|*
name|p
operator|++
operator|=
literal|'\0'
expr_stmt|;
comment|/* Get the high mark. */
if|if
condition|(
operator|(
name|q
operator|=
name|strchr
argument_list|(
name|p
argument_list|,
literal|' '
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|syslog
argument_list|(
name|L_ERROR
argument_list|,
literal|"%s internal no_space2 \"%.20s...\""
argument_list|,
name|ClientHost
argument_list|,
name|gp
operator|->
name|Name
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
operator|*
name|q
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|gp
operator|->
name|High
operator|=
name|atol
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/* Get the low mark. */
if|if
condition|(
operator|(
name|p
operator|=
name|strchr
argument_list|(
name|q
argument_list|,
literal|' '
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|syslog
argument_list|(
name|L_ERROR
argument_list|,
literal|"%s internal no_space3 \"%.20s...\""
argument_list|,
name|ClientHost
argument_list|,
name|gp
operator|->
name|Name
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
operator|*
name|p
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|gp
operator|->
name|Low
operator|=
name|atol
argument_list|(
name|q
argument_list|)
expr_stmt|;
comment|/* Kill the newline. */
if|if
condition|(
operator|(
name|q
operator|=
name|strchr
argument_list|(
name|p
argument_list|,
literal|'\n'
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|syslog
argument_list|(
name|L_ERROR
argument_list|,
literal|"%s internal newline \"%.20s...\""
argument_list|,
name|ClientHost
argument_list|,
name|gp
operator|->
name|Name
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
operator|*
name|q
operator|=
literal|'\0'
expr_stmt|;
name|gp
operator|->
name|Flag
operator|=
operator|*
name|p
expr_stmt|;
name|gp
operator|->
name|Alias
operator|=
name|gp
operator|->
name|Flag
operator|==
name|NF_FLAG_ALIAS
condition|?
name|p
operator|+
literal|1
else|:
name|NULL
expr_stmt|;
block|}
name|GRPsize
operator|=
name|i
expr_stmt|;
name|GRPhash
argument_list|()
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* **  Sorting predicate to put newsgroup names into numeric order. */
end_comment

begin_function
name|STATIC
name|int
name|ARTcompare
parameter_list|(
name|p1
parameter_list|,
name|p2
parameter_list|)
name|POINTER
name|p1
decl_stmt|;
name|POINTER
name|p2
decl_stmt|;
block|{
name|ARTNUM
modifier|*
name|i1
decl_stmt|;
name|ARTNUM
modifier|*
name|i2
decl_stmt|;
name|i1
operator|=
name|CAST
argument_list|(
name|ARTNUM
operator|*
argument_list|,
name|p1
argument_list|)
expr_stmt|;
name|i2
operator|=
name|CAST
argument_list|(
name|ARTNUM
operator|*
argument_list|,
name|p2
argument_list|)
expr_stmt|;
return|return
operator|*
name|i1
operator|-
operator|*
name|i2
return|;
block|}
end_function

begin_comment
comment|/* **  Fill in ARTnumbers with the numbers of the articles in the current **  group. */
end_comment

begin_function
name|STATIC
name|void
name|GRPscandir
parameter_list|(
name|dir
parameter_list|)
name|char
modifier|*
name|dir
decl_stmt|;
block|{
specifier|static
name|char
name|SPOOL
index|[]
init|=
name|_PATH_SPOOL
decl_stmt|;
specifier|static
name|int
name|ARTarraysize
decl_stmt|;
specifier|register
name|DIRENTRY
modifier|*
name|ep
decl_stmt|;
specifier|register
name|DIR
modifier|*
name|dp
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|ARTNUM
name|i
decl_stmt|;
comment|/* Go to the directory. */
if|if
condition|(
name|chdir
argument_list|(
name|SPOOL
argument_list|)
operator|<
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|L_FATAL
argument_list|,
literal|"%s cant cd %s %m"
argument_list|,
name|ClientHost
argument_list|,
name|SPOOL
argument_list|)
expr_stmt|;
name|ExitWithStats
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ARTarraysize
operator|==
literal|0
condition|)
block|{
name|ARTarraysize
operator|=
literal|1024
expr_stmt|;
name|ARTnumbers
operator|=
name|NEW
argument_list|(
name|ARTNUM
argument_list|,
name|ARTarraysize
argument_list|)
expr_stmt|;
block|}
comment|/* The newsgroup directory might not exist; treat it as empty. */
name|ARTsize
operator|=
literal|0
expr_stmt|;
name|GRPcount
operator|++
expr_stmt|;
if|if
condition|(
name|chdir
argument_list|(
name|dir
argument_list|)
operator|<
literal|0
condition|)
return|return;
name|dp
operator|=
name|opendir
argument_list|(
literal|"."
argument_list|)
expr_stmt|;
if|if
condition|(
name|dp
operator|==
name|NULL
condition|)
block|{
name|syslog
argument_list|(
name|L_ERROR
argument_list|,
literal|"%s cant opendir %s %m"
argument_list|,
name|ClientHost
argument_list|,
name|dir
argument_list|)
expr_stmt|;
return|return;
block|}
while|while
condition|(
operator|(
name|ep
operator|=
name|readdir
argument_list|(
name|dp
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
comment|/* Get the numeric value of the filename, if it's all digits. */
for|for
control|(
name|p
operator|=
name|ep
operator|->
name|d_name
operator|,
name|i
operator|=
literal|0
init|;
operator|*
name|p
condition|;
name|p
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|CTYPE
argument_list|(
name|isdigit
argument_list|,
operator|*
name|p
argument_list|)
condition|)
break|break;
name|i
operator|=
name|i
operator|*
literal|10
operator|+
operator|*
name|p
operator|-
literal|'0'
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|p
operator|||
name|i
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|ARTsize
operator|+
literal|1
operator|>=
name|ARTarraysize
condition|)
block|{
name|ARTarraysize
operator|+=
literal|1024
expr_stmt|;
name|RENEW
argument_list|(
name|ARTnumbers
argument_list|,
name|ARTNUM
argument_list|,
name|ARTarraysize
argument_list|)
expr_stmt|;
block|}
name|ARTnumbers
index|[
name|ARTsize
operator|++
index|]
operator|=
name|i
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|closedir
argument_list|(
name|dp
argument_list|)
expr_stmt|;
name|ARTcache
operator|=
name|NULL
expr_stmt|;
name|qsort
argument_list|(
operator|(
name|POINTER
operator|)
name|ARTnumbers
argument_list|,
operator|(
name|SIZE_T
operator|)
name|ARTsize
argument_list|,
sizeof|sizeof
name|ARTnumbers
index|[
literal|0
index|]
argument_list|,
name|ARTcompare
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* **  Change to or list the specified newsgroup.  If invalid, stay in the old **  group. */
end_comment

begin_function
name|FUNCTYPE
name|CMDgroup
parameter_list|(
name|ac
parameter_list|,
name|av
parameter_list|)
name|int
name|ac
decl_stmt|;
name|char
modifier|*
name|av
index|[]
decl_stmt|;
block|{
specifier|static
name|time_t
name|last_time
decl_stmt|;
specifier|static
name|char
name|NOSUCHGROUP
index|[]
init|=
name|NNTP_NOSUCHGROUP
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|time_t
name|now
decl_stmt|;
name|char
modifier|*
name|grplist
index|[
literal|2
index|]
decl_stmt|;
name|char
modifier|*
name|group
decl_stmt|;
name|char
name|buff
index|[
name|SPOOLNAMEBUFF
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|PERMcanread
condition|)
block|{
name|Reply
argument_list|(
literal|"%s\r\n"
argument_list|,
name|NOACCESS
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Parse arguments. */
if|if
condition|(
name|ac
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|GRPcount
operator|==
literal|0
condition|)
block|{
name|Printf
argument_list|(
literal|"%d No group specified\r\n"
argument_list|,
name|NNTP_XGTITLE_BAD
argument_list|)
expr_stmt|;
return|return;
block|}
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|buff
argument_list|,
name|GRPlast
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|buff
init|;
operator|*
name|p
condition|;
name|p
operator|++
control|)
if|if
condition|(
operator|*
name|p
operator|==
literal|'/'
condition|)
operator|*
name|p
operator|=
literal|'.'
expr_stmt|;
name|group
operator|=
name|buff
expr_stmt|;
block|}
else|else
name|group
operator|=
name|av
index|[
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|GRPfind
argument_list|(
name|group
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|Reply
argument_list|(
literal|"%s\r\n"
argument_list|,
name|NOSUCHGROUP
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* If permission is denied, pretend group doesn't exist. */
if|if
condition|(
name|PERMspecified
condition|)
block|{
name|grplist
index|[
literal|0
index|]
operator|=
name|group
expr_stmt|;
name|grplist
index|[
literal|1
index|]
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
name|PERMmatch
argument_list|(
name|PERMdefault
argument_list|,
name|PERMlist
argument_list|,
name|grplist
argument_list|)
condition|)
block|{
name|Reply
argument_list|(
literal|"%s\r\n"
argument_list|,
name|NOSUCHGROUP
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|PERMdefault
condition|)
block|{
name|Reply
argument_list|(
literal|"%s\r\n"
argument_list|,
name|NOSUCHGROUP
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Close out any existing article, report group stats. */
name|ARTclose
argument_list|()
expr_stmt|;
name|ARTindex
operator|=
literal|0
expr_stmt|;
name|GRPreport
argument_list|()
expr_stmt|;
comment|/* Make the group name a directory name. */
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|buff
argument_list|,
name|group
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|buff
init|;
operator|*
name|p
condition|;
name|p
operator|++
control|)
if|if
condition|(
operator|*
name|p
operator|==
literal|'.'
condition|)
operator|*
name|p
operator|=
literal|'/'
expr_stmt|;
comment|/* If we haven't been in the group recently, rescan. */
operator|(
name|void
operator|)
name|time
argument_list|(
operator|&
name|now
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|EQ
argument_list|(
name|buff
argument_list|,
name|GRPlast
argument_list|)
operator|||
name|now
operator|>
name|last_time
operator|+
name|NNRP_RESCAN_DELAY
condition|)
block|{
name|GRPscandir
argument_list|(
name|buff
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|GRPlast
argument_list|,
name|buff
argument_list|)
expr_stmt|;
name|last_time
operator|=
name|now
expr_stmt|;
block|}
comment|/* Close down any overview file. */
name|OVERclose
argument_list|()
expr_stmt|;
comment|/* Doing a "group" command? */
if|if
condition|(
name|caseEQ
argument_list|(
name|av
index|[
literal|0
index|]
argument_list|,
literal|"group"
argument_list|)
condition|)
block|{
if|if
condition|(
name|ARTsize
operator|==
literal|0
condition|)
name|Reply
argument_list|(
literal|"%d 0 0 0 %s\r\n"
argument_list|,
name|NNTP_GROUPOK_VAL
argument_list|,
name|group
argument_list|)
expr_stmt|;
else|else
name|Reply
argument_list|(
literal|"%d %d %ld %ld %s\r\n"
argument_list|,
name|NNTP_GROUPOK_VAL
argument_list|,
name|ARTsize
argument_list|,
name|ARTnumbers
index|[
literal|0
index|]
argument_list|,
name|ARTnumbers
index|[
name|ARTsize
operator|-
literal|1
index|]
argument_list|,
name|group
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Must be doing a "listgroup" command. */
name|Reply
argument_list|(
literal|"%d Article list follows\r\n"
argument_list|,
name|NNTP_GROUPOK_VAL
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ARTsize
condition|;
name|i
operator|++
control|)
name|Printf
argument_list|(
literal|"%ld\r\n"
argument_list|,
name|ARTnumbers
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|Printf
argument_list|(
literal|".\r\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* **  Report on the number of articles read in the group, and clear the count. */
end_comment

begin_function
name|void
name|GRPreport
parameter_list|()
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|char
name|buff
index|[
name|SPOOLNAMEBUFF
index|]
decl_stmt|;
if|if
condition|(
name|GRPlast
index|[
literal|0
index|]
operator|&&
name|GRParticles
operator|!=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|buff
argument_list|,
name|GRPlast
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|buff
init|;
operator|*
name|p
condition|;
name|p
operator|++
control|)
if|if
condition|(
operator|*
name|p
operator|==
literal|'/'
condition|)
operator|*
name|p
operator|=
literal|'.'
expr_stmt|;
name|syslog
argument_list|(
name|L_NOTICE
argument_list|,
literal|"%s group %s %ld"
argument_list|,
name|ClientHost
argument_list|,
name|buff
argument_list|,
name|GRParticles
argument_list|)
expr_stmt|;
name|GRParticles
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* **  Used by ANU-News clients. */
end_comment

begin_function
name|FUNCTYPE
name|CMDxgtitle
parameter_list|(
name|ac
parameter_list|,
name|av
parameter_list|)
name|int
name|ac
decl_stmt|;
name|char
modifier|*
name|av
index|[]
decl_stmt|;
block|{
specifier|register
name|QIOSTATE
modifier|*
name|qp
decl_stmt|;
specifier|register
name|char
modifier|*
name|line
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|char
modifier|*
name|q
decl_stmt|;
name|char
name|save
decl_stmt|;
comment|/* Parse the arguments. */
if|if
condition|(
name|ac
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|GRPcount
operator|==
literal|0
condition|)
block|{
name|Printf
argument_list|(
literal|"%d No group specified\r\n"
argument_list|,
name|NNTP_XGTITLE_BAD
argument_list|)
expr_stmt|;
return|return;
block|}
name|p
operator|=
name|GRPlast
expr_stmt|;
block|}
else|else
name|p
operator|=
name|av
index|[
literal|1
index|]
expr_stmt|;
comment|/* Open the file, get ready to scan. */
if|if
condition|(
operator|(
name|qp
operator|=
name|QIOopen
argument_list|(
name|NEWSGROUPS
argument_list|,
name|QIO_BUFFER
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|syslog
argument_list|(
name|L_ERROR
argument_list|,
literal|"%s cant open %s %m"
argument_list|,
name|ClientHost
argument_list|,
name|NEWSGROUPS
argument_list|)
expr_stmt|;
name|Printf
argument_list|(
literal|"%d Can't open %s\r\n"
argument_list|,
name|NNTP_XGTITLE_BAD
argument_list|,
name|NEWSGROUPS
argument_list|)
expr_stmt|;
return|return;
block|}
name|Printf
argument_list|(
literal|"%d list follows\r\n"
argument_list|,
name|NNTP_XGTITLE_OK
argument_list|)
expr_stmt|;
comment|/* Print all lines with matching newsgroup name. */
while|while
condition|(
operator|(
name|line
operator|=
name|QIOread
argument_list|(
name|qp
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
name|q
operator|=
name|line
init|;
operator|*
name|q
operator|&&
operator|!
name|ISWHITE
argument_list|(
operator|*
name|q
argument_list|)
condition|;
name|q
operator|++
control|)
continue|continue;
name|save
operator|=
operator|*
name|q
expr_stmt|;
operator|*
name|q
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|wildmat
argument_list|(
name|line
argument_list|,
name|p
argument_list|)
condition|)
block|{
operator|*
name|q
operator|=
name|save
expr_stmt|;
name|Printf
argument_list|(
literal|"%s\r\n"
argument_list|,
name|line
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Done. */
name|QIOclose
argument_list|(
name|qp
argument_list|)
expr_stmt|;
name|Printf
argument_list|(
literal|".\r\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|DO_DO_XTHREAD
argument_list|)
end_if

begin_comment
comment|/* **  XTHREAD command.  Based on code by Tim Iverson<iverson@xstor.com>, **  Wayne Davison<davison@borland.com>, and Rob Robertson **<rob@violet.berkeley.edu>.  Usage: **	xthread [thread]	Dump thread file for current group. **	xthread dbinit		Dump db.init file. **  This is a very ugly command -- data is raw binary. */
end_comment

begin_function
name|FUNCTYPE
name|CMDxthread
parameter_list|(
name|ac
parameter_list|,
name|av
parameter_list|)
name|int
name|ac
decl_stmt|;
name|char
modifier|*
name|av
index|[]
decl_stmt|;
block|{
specifier|static
name|char
name|NOTAVAIL
index|[]
init|=
literal|"%d %s not available.\r\n"
decl_stmt|;
specifier|static
name|char
name|USAGE
index|[]
init|=
literal|"[dbinit|thread]"
decl_stmt|;
name|struct
name|stat
name|Sb
decl_stmt|;
specifier|register
name|FILE
modifier|*
name|F
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|char
name|buff
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|char
modifier|*
name|file
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|THREAD_NAMES_FLAT
argument_list|)
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|char
name|temp
index|[
name|SPOOLNAMEBUFF
index|]
decl_stmt|;
endif|#
directive|endif
comment|/* defined(THREAD_NAMES_FLAT) */
if|if
condition|(
operator|!
name|PERMcanread
condition|)
block|{
name|Reply
argument_list|(
literal|"%s\r\n"
argument_list|,
name|NOACCESS
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Parse the arguments. */
if|if
condition|(
name|ac
operator|==
literal|1
operator|||
operator|(
name|ac
operator|==
literal|2
operator|&&
name|caseEQ
argument_list|(
name|av
index|[
literal|1
index|]
argument_list|,
literal|"thread"
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|GRPcount
operator|==
literal|0
condition|)
block|{
name|Reply
argument_list|(
literal|"%s\r\n"
argument_list|,
name|NNTP_NOTINGROUP
argument_list|)
expr_stmt|;
return|return;
block|}
if|#
directive|if
name|defined
argument_list|(
name|THREAD_NAMES_FLAT
argument_list|)
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|temp
argument_list|,
name|GRPlast
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|temp
init|;
operator|*
name|p
condition|;
name|p
operator|++
control|)
if|if
condition|(
operator|*
name|p
operator|==
literal|'/'
condition|)
operator|*
name|p
operator|=
literal|'.'
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buff
argument_list|,
literal|"%s/%s%s"
argument_list|,
name|THREAD_DIR
argument_list|,
name|temp
argument_list|,
name|THREAD_SUFFIX
argument_list|)
expr_stmt|;
else|#
directive|else
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buff
argument_list|,
literal|"%s/%s%s"
argument_list|,
name|THREAD_DIR
argument_list|,
name|GRPlast
argument_list|,
name|THREAD_SUFFIX
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* defined(THREAD_NAMES_FLAT) */
name|file
operator|=
name|buff
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ac
operator|==
literal|2
operator|&&
name|caseEQ
argument_list|(
name|av
index|[
literal|1
index|]
argument_list|,
literal|"dbinit"
argument_list|)
condition|)
name|file
operator|=
name|THREAD_DB
expr_stmt|;
else|else
block|{
name|Reply
argument_list|(
literal|"%d Usage: %s\r\n"
argument_list|,
name|NNTP_SYNTAX_VAL
argument_list|,
name|USAGE
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Open the thread file, say what's coming. */
if|if
condition|(
operator|(
name|F
operator|=
name|fopen
argument_list|(
name|file
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|syslog
argument_list|(
name|L_ERROR
argument_list|,
literal|"%s cant fopen %s %m"
argument_list|,
name|ClientHost
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|Reply
argument_list|(
name|NOTAVAIL
argument_list|,
name|NNTP_TEMPERR_VAL
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Get file size. */
if|if
condition|(
name|fstat
argument_list|(
name|fileno
argument_list|(
name|F
argument_list|)
argument_list|,
operator|&
name|Sb
argument_list|)
operator|<
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|L_ERROR
argument_list|,
literal|"%s cant fstat %s %m"
argument_list|,
name|ClientHost
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|Reply
argument_list|(
name|NOTAVAIL
argument_list|,
name|NNTP_TEMPERR_VAL
argument_list|,
name|file
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|F
argument_list|)
expr_stmt|;
return|return;
block|}
name|Reply
argument_list|(
literal|"%d %ul binary bytes follow\r\n"
argument_list|,
name|THREAD_NNTP_CODE
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|Sb
operator|.
name|st_size
argument_list|)
expr_stmt|;
comment|/* Send the data.  Ignore errors since there is no way to put      * that info in the output stream -- symptomatic of binary      * data formats. */
while|while
condition|(
operator|(
name|i
operator|=
name|fread
argument_list|(
name|buff
argument_list|,
operator|(
name|SIZE_T
operator|)
literal|1
argument_list|,
operator|(
name|SIZE_T
operator|)
sizeof|sizeof
name|buff
argument_list|,
name|F
argument_list|)
operator|)
operator|>
literal|0
condition|)
operator|(
name|void
operator|)
name|fwrite
argument_list|(
name|buff
argument_list|,
operator|(
name|SIZE_T
operator|)
name|i
argument_list|,
operator|(
name|SIZE_T
operator|)
literal|1
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|F
argument_list|)
expr_stmt|;
name|Printf
argument_list|(
literal|"\r\n.\r\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* defined(DO_DO_XTHREAD) */
end_comment

end_unit

