begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* $Id: cache.c,v 3.0 1992/02/01 03:09:32 davison Trn $  */
end_comment

begin_comment
comment|/* This software is Copyright 1991 by Stan Barber.   *  * Permission is hereby granted to copy, reproduce, redistribute or otherwise  * use this software as long as: there is no monetary profit gained  * specifically from the use or reproduction of this software, it is not  * sold, rented, traded or otherwise marketed, and this copyright notice is  * included prominently in any copy made.   *  * The author make no claims as to the fitness or correctness of this software  * for any use whatsoever, and it is provided as is. Any use of this software  * is at the user's own risk.   */
end_comment

begin_include
include|#
directive|include
file|"EXTERN.h"
end_include

begin_include
include|#
directive|include
file|"common.h"
end_include

begin_include
include|#
directive|include
file|"INTERN.h"
end_include

begin_include
include|#
directive|include
file|"cache.h"
end_include

begin_include
include|#
directive|include
file|"EXTERN.h"
end_include

begin_include
include|#
directive|include
file|"intrp.h"
end_include

begin_include
include|#
directive|include
file|"search.h"
end_include

begin_include
include|#
directive|include
file|"ng.h"
end_include

begin_include
include|#
directive|include
file|"trn.h"
end_include

begin_include
include|#
directive|include
file|"ngdata.h"
end_include

begin_include
include|#
directive|include
file|"term.h"
end_include

begin_include
include|#
directive|include
file|"final.h"
end_include

begin_include
include|#
directive|include
file|"artsrch.h"
end_include

begin_include
include|#
directive|include
file|"head.h"
end_include

begin_include
include|#
directive|include
file|"bits.h"
end_include

begin_include
include|#
directive|include
file|"rcstuff.h"
end_include

begin_include
include|#
directive|include
file|"hash.h"
end_include

begin_include
include|#
directive|include
file|"rthread.h"
end_include

begin_include
include|#
directive|include
file|"rt-ov.h"
end_include

begin_include
include|#
directive|include
file|"rt-select.h"
end_include

begin_include
include|#
directive|include
file|"rt-util.h"
end_include

begin_include
include|#
directive|include
file|"util.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|PENDING
end_ifdef

begin_ifdef
ifdef|#
directive|ifdef
name|ARTSEARCH
end_ifdef

begin_decl_stmt
name|COMPEX
name|srchcompex
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* compiled regex for searchahead */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|HASHTABLE
modifier|*
name|subj_hash
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|subject_cmp
name|_
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|,
name|HASHDATUM
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|cache_init
parameter_list|()
block|{
empty_stmt|;
block|}
end_function

begin_decl_stmt
name|NG_NUM
name|cached_ng
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|time_t
name|cached_time
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|ART_NUM
name|cached_cnt
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|ART_NUM
name|cached_absfirst
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|build_cache
parameter_list|()
block|{
if|if
condition|(
name|cached_ng
operator|==
name|ng
operator|&&
name|cached_absfirst
operator|==
name|absfirst
operator|&&
name|time
argument_list|(
operator|(
name|time_t
operator|*
operator|)
name|NULL
argument_list|)
operator|<
name|cached_time
operator|+
literal|6
operator|*
literal|60
operator|*
literal|60L
condition|)
block|{
name|grow_cache
argument_list|(
name|lastart
argument_list|)
expr_stmt|;
name|rc_to_bits
argument_list|()
expr_stmt|;
name|thread_grow
argument_list|()
expr_stmt|;
return|return;
block|}
name|close_cache
argument_list|()
expr_stmt|;
name|cached_ng
operator|=
name|ng
expr_stmt|;
name|cached_absfirst
operator|=
name|absfirst
expr_stmt|;
name|cached_time
operator|=
name|time
argument_list|(
operator|(
name|time_t
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|cached_cnt
operator|=
name|lastart
operator|-
name|absfirst
operator|+
literal|2
operator|+
literal|5
expr_stmt|;
name|article_list
operator|=
operator|(
name|ARTICLE
operator|*
operator|)
name|safemalloc
argument_list|(
call|(
name|MEM_SIZE
call|)
argument_list|(
name|cached_cnt
operator|*
sizeof|sizeof
argument_list|(
name|ARTICLE
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|article_list
argument_list|,
name|cached_cnt
operator|*
sizeof|sizeof
argument_list|(
name|ARTICLE
argument_list|)
argument_list|)
expr_stmt|;
name|subj_hash
operator|=
name|hashcreate
argument_list|(
literal|201
argument_list|,
name|subject_cmp
argument_list|)
expr_stmt|;
comment|/*TODO: pick a better size */
name|rc_to_bits
argument_list|()
expr_stmt|;
comment|/* sets firstart */
name|first_cached
operator|=
name|thread_always
condition|?
name|absfirst
else|:
name|firstart
expr_stmt|;
name|last_cached
operator|=
name|first_cached
operator|-
literal|1
expr_stmt|;
name|cached_all_in_range
operator|=
name|FALSE
expr_stmt|;
ifdef|#
directive|ifdef
name|PENDING
name|subj_to_get
operator|=
name|xref_to_get
operator|=
name|firstart
expr_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|USE_NNTP
name|setmissingbits
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* Cache as much data in advance as possible, possibly threading     ** articles as we go. */
name|thread_open
argument_list|()
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|FIXPTR
parameter_list|(
name|p
parameter_list|)
value|(!(p) || (p)<old_list || ((p)-old_list)> (lastart-absfirst)\ 		   ? (p) : (article_list + ((p)-old_list)))
end_define

begin_function
name|void
name|grow_cache
parameter_list|(
name|newlast
parameter_list|)
name|ART_NUM
name|newlast
decl_stmt|;
block|{
name|ART_NUM
name|new_cnt
init|=
name|newlast
operator|-
name|absfirst
operator|+
literal|2
decl_stmt|;
if|if
condition|(
name|new_cnt
operator|>
name|cached_cnt
condition|)
block|{
name|ARTICLE
modifier|*
name|old_list
init|=
name|article_list
decl_stmt|;
name|new_cnt
operator|+=
literal|5
expr_stmt|;
name|article_list
operator|=
operator|(
name|ARTICLE
operator|*
operator|)
name|saferealloc
argument_list|(
operator|(
name|char
operator|*
operator|)
name|article_list
argument_list|,
call|(
name|MEM_SIZE
call|)
argument_list|(
name|new_cnt
operator|*
sizeof|sizeof
argument_list|(
name|ARTICLE
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|(
name|article_list
operator|+
name|cached_cnt
operator|)
argument_list|,
operator|(
name|new_cnt
operator|-
name|cached_cnt
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|ARTICLE
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|article_list
operator|!=
name|old_list
condition|)
block|{
specifier|register
name|ARTICLE
modifier|*
name|ap
decl_stmt|;
specifier|register
name|SUBJECT
modifier|*
name|sp
decl_stmt|;
for|for
control|(
name|sp
operator|=
name|first_subject
init|;
name|sp
condition|;
name|sp
operator|=
name|sp
operator|->
name|next
control|)
block|{
name|sp
operator|->
name|thread
operator|=
name|FIXPTR
argument_list|(
name|sp
operator|->
name|thread
argument_list|)
expr_stmt|;
name|sp
operator|->
name|articles
operator|=
name|FIXPTR
argument_list|(
name|sp
operator|->
name|articles
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|thread
condition|)
block|{
for|for
control|(
name|ap
operator|=
name|sp
operator|->
name|thread
init|;
name|ap
condition|;
name|ap
operator|=
name|bump_art
argument_list|(
name|ap
argument_list|)
control|)
block|{
name|ap
operator|->
name|child1
operator|=
name|FIXPTR
argument_list|(
name|ap
operator|->
name|child1
argument_list|)
expr_stmt|;
name|ap
operator|->
name|parent
operator|=
name|FIXPTR
argument_list|(
name|ap
operator|->
name|parent
argument_list|)
expr_stmt|;
name|ap
operator|->
name|sibling
operator|=
name|FIXPTR
argument_list|(
name|ap
operator|->
name|sibling
argument_list|)
expr_stmt|;
name|ap
operator|->
name|subj_next
operator|=
name|FIXPTR
argument_list|(
name|ap
operator|->
name|subj_next
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
for|for
control|(
name|ap
operator|=
name|sp
operator|->
name|articles
init|;
name|ap
condition|;
control|)
name|ap
operator|=
name|ap
operator|->
name|subj_next
operator|=
name|FIXPTR
argument_list|(
name|ap
operator|->
name|subj_next
argument_list|)
expr_stmt|;
block|}
block|}
name|artp
operator|=
name|FIXPTR
argument_list|(
name|artp
argument_list|)
expr_stmt|;
name|curr_artp
operator|=
name|FIXPTR
argument_list|(
name|curr_artp
argument_list|)
expr_stmt|;
name|recent_artp
operator|=
name|FIXPTR
argument_list|(
name|recent_artp
argument_list|)
expr_stmt|;
block|}
name|cached_cnt
operator|=
name|new_cnt
expr_stmt|;
block|}
name|cached_time
operator|=
name|time
argument_list|(
operator|(
name|time_t
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|close_cache
parameter_list|()
block|{
name|SUBJECT
modifier|*
name|sp
decl_stmt|,
modifier|*
name|next
decl_stmt|;
name|ARTICLE
modifier|*
name|ap
decl_stmt|;
name|ART_NUM
name|i
decl_stmt|;
if|if
condition|(
name|subj_hash
condition|)
block|{
name|hashdestroy
argument_list|(
name|subj_hash
argument_list|)
expr_stmt|;
name|subj_hash
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Free all the subjects. */
for|for
control|(
name|sp
operator|=
name|first_subject
init|;
name|sp
condition|;
name|sp
operator|=
name|next
control|)
block|{
name|next
operator|=
name|sp
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|sp
operator|->
name|str
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|sp
argument_list|)
expr_stmt|;
block|}
name|first_subject
operator|=
name|last_subject
operator|=
name|Nullsubj
expr_stmt|;
name|subject_count
operator|=
literal|0
expr_stmt|;
comment|/* just to be sure */
name|parsed_art
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|artptr_list
condition|)
block|{
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|artptr_list
argument_list|)
expr_stmt|;
name|artptr_list
operator|=
name|Null
argument_list|(
name|ARTICLE
operator|*
operator|*
argument_list|)
expr_stmt|;
block|}
name|artptr
operator|=
name|Null
argument_list|(
name|ARTICLE
operator|*
operator|*
argument_list|)
expr_stmt|;
name|thread_close
argument_list|()
expr_stmt|;
if|if
condition|(
name|cached_cnt
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|ap
operator|=
name|article_list
init|;
name|i
operator|<
name|cached_cnt
condition|;
name|i
operator|++
operator|,
name|ap
operator|++
control|)
name|clear_article
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|article_list
argument_list|)
expr_stmt|;
name|cached_cnt
operator|=
literal|0
expr_stmt|;
block|}
name|cached_ng
operator|=
operator|-
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The article has all it's data in place, so add it to the list of articles ** with the same subject. */
end_comment

begin_function
name|void
name|cache_article
parameter_list|(
name|ap
parameter_list|)
specifier|register
name|ARTICLE
modifier|*
name|ap
decl_stmt|;
block|{
specifier|register
name|ARTICLE
modifier|*
name|next
decl_stmt|,
modifier|*
name|ap2
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|next
operator|=
name|ap
operator|->
name|subj
operator|->
name|articles
operator|)
operator|||
name|ap
operator|->
name|date
operator|<
name|next
operator|->
name|date
condition|)
name|ap
operator|->
name|subj
operator|->
name|articles
operator|=
name|ap
expr_stmt|;
else|else
block|{
while|while
condition|(
operator|(
name|next
operator|=
operator|(
name|ap2
operator|=
name|next
operator|)
operator|->
name|subj_next
operator|)
operator|&&
name|next
operator|->
name|date
operator|<=
name|ap
operator|->
name|date
condition|)
empty_stmt|;
name|ap2
operator|->
name|subj_next
operator|=
name|ap
expr_stmt|;
block|}
name|ap
operator|->
name|subj_next
operator|=
name|next
expr_stmt|;
name|ap
operator|->
name|flags
operator||=
name|AF_CACHED
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|ap
operator|->
name|flags
operator|&
name|AF_READ
operator|)
operator|^
name|sel_rereading
condition|)
block|{
if|if
condition|(
name|selected_only
condition|)
block|{
if|if
condition|(
name|ap
operator|->
name|subj
operator|->
name|flags
operator|&
name|sel_mask
condition|)
block|{
name|ap
operator|->
name|flags
operator||=
name|sel_mask
expr_stmt|;
name|selected_count
operator|++
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|ap
operator|->
name|subj
operator|->
name|flags
operator|&
name|SF_WASSELECTED
condition|)
name|select_article
argument_list|(
name|ap
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
block|{
name|ap
operator|->
name|subj
operator|->
name|flags
operator||=
name|SF_VISIT
expr_stmt|;
if|if
condition|(
name|sel_mode
operator|==
name|SM_THREAD
condition|)
name|ap
operator|->
name|subj
operator|->
name|thread
operator|->
name|subj
operator|->
name|flags
operator||=
name|SF_VISIT
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|void
name|check_poster
parameter_list|(
name|ap
parameter_list|)
specifier|register
name|ARTICLE
modifier|*
name|ap
decl_stmt|;
block|{
if|if
condition|(
name|auto_select_postings
operator|&&
operator|!
operator|(
name|ap
operator|->
name|flags
operator|&
name|AF_MISSING
operator|)
condition|)
block|{
if|if
condition|(
name|ap
operator|->
name|flags
operator|&
name|AF_FROMTRUNCED
condition|)
block|{
name|strcpy
argument_list|(
name|cmd_buf
argument_list|,
name|realname
argument_list|)
expr_stmt|;
if|if
condition|(
name|strEQ
argument_list|(
name|ap
operator|->
name|from
argument_list|,
name|compress_name
argument_list|(
name|cmd_buf
argument_list|,
literal|16
argument_list|)
argument_list|)
condition|)
block|{
name|untrim_cache
operator|=
name|TRUE
expr_stmt|;
name|fetchfrom
argument_list|(
name|article_num
argument_list|(
name|ap
argument_list|)
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|untrim_cache
operator|=
name|FALSE
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
operator|(
name|ap
operator|->
name|flags
operator|&
name|AF_FROMTRUNCED
operator|)
condition|)
block|{
if|if
condition|(
name|instr
argument_list|(
name|ap
operator|->
name|from
argument_list|,
name|phostname
argument_list|,
name|FALSE
argument_list|)
condition|)
block|{
if|if
condition|(
name|instr
argument_list|(
name|ap
operator|->
name|from
argument_list|,
name|logname
argument_list|,
name|TRUE
argument_list|)
condition|)
name|select_subthread
argument_list|(
name|ap
argument_list|,
name|AF_AUTOSELECT
argument_list|)
expr_stmt|;
else|else
block|{
ifdef|#
directive|ifdef
name|SLOW_BUT_COMPLETE_POSTER_CHECKING
name|char
modifier|*
name|reply_buf
init|=
name|fetchlines
argument_list|(
name|article_num
argument_list|(
name|ap
argument_list|)
argument_list|,
name|REPLY_LINE
argument_list|)
decl_stmt|;
if|if
condition|(
name|instr
argument_list|(
name|reply_buf
argument_list|,
name|logname
argument_list|,
name|TRUE
argument_list|)
condition|)
name|select_subthread
argument_list|(
name|ap
argument_list|,
name|AF_AUTOSELECT
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|reply_buf
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/* The article turned out to be a duplicate, so remove it from the cached ** list and possibly destroy the subject (should only happen if the data ** was corrupt and the duplicate id got a different subject). */
end_comment

begin_function
name|void
name|uncache_article
parameter_list|(
name|ap
parameter_list|,
name|remove_empties
parameter_list|)
specifier|register
name|ARTICLE
modifier|*
name|ap
decl_stmt|;
name|bool_int
name|remove_empties
decl_stmt|;
block|{
specifier|register
name|ARTICLE
modifier|*
name|next
decl_stmt|,
modifier|*
name|ap2
decl_stmt|;
if|if
condition|(
name|ap
operator|->
name|subj
condition|)
block|{
if|if
condition|(
operator|(
name|ap
operator|->
name|flags
operator|&
operator|(
name|AF_CACHED
operator||
name|AF_MISSING
operator|)
operator|)
operator|==
name|AF_CACHED
condition|)
block|{
if|if
condition|(
operator|(
name|next
operator|=
name|ap
operator|->
name|subj
operator|->
name|articles
operator|)
operator|==
name|ap
condition|)
name|ap
operator|->
name|subj
operator|->
name|articles
operator|=
name|ap
operator|->
name|subj_next
expr_stmt|;
elseif|else
if|if
condition|(
name|next
condition|)
block|{
while|while
condition|(
name|next
operator|&&
operator|(
name|next
operator|=
operator|(
name|ap2
operator|=
name|next
operator|)
operator|->
name|subj_next
operator|)
operator|!=
name|ap
condition|)
empty_stmt|;
name|ap2
operator|->
name|subj_next
operator|=
name|next
expr_stmt|;
block|}
block|}
if|if
condition|(
name|remove_empties
operator|&&
operator|!
name|ap
operator|->
name|subj
operator|->
name|articles
condition|)
block|{
specifier|register
name|SUBJECT
modifier|*
name|sp
init|=
name|ap
operator|->
name|subj
decl_stmt|;
if|if
condition|(
name|sp
operator|==
name|first_subject
condition|)
name|first_subject
operator|=
name|sp
operator|->
name|next
expr_stmt|;
else|else
name|sp
operator|->
name|prev
operator|->
name|next
operator|=
name|sp
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|sp
operator|==
name|last_subject
condition|)
name|last_subject
operator|=
name|sp
operator|->
name|prev
expr_stmt|;
else|else
name|sp
operator|->
name|next
operator|->
name|prev
operator|=
name|sp
operator|->
name|prev
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|sp
argument_list|)
expr_stmt|;
name|ap
operator|->
name|subj
operator|=
name|Nullsubj
expr_stmt|;
name|subject_count
operator|--
expr_stmt|;
block|}
block|}
name|onemissing
argument_list|(
name|ap
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* get the header line from an article's cache or parse the article trying */
end_comment

begin_function
name|char
modifier|*
name|fetchcache
parameter_list|(
name|artnum
parameter_list|,
name|which_line
parameter_list|)
name|ART_NUM
name|artnum
decl_stmt|;
name|int
name|which_line
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
specifier|register
name|ARTICLE
modifier|*
name|ap
decl_stmt|;
specifier|register
name|bool
name|cached
init|=
operator|(
name|htype
index|[
name|which_line
index|]
operator|.
name|ht_flags
operator|&
name|HT_CACHED
operator|)
decl_stmt|;
comment|/* find_article() returns a Nullart if the artnum value is invalid */
if|if
condition|(
operator|!
operator|(
name|ap
operator|=
name|find_article
argument_list|(
name|artnum
argument_list|)
operator|)
operator|||
operator|(
name|ap
operator|->
name|flags
operator|&
name|AF_MISSING
operator|)
condition|)
return|return
name|nullstr
return|;
if|if
condition|(
name|cached
operator|&&
operator|(
name|s
operator|=
name|get_cached_line
argument_list|(
name|ap
argument_list|,
name|which_line
argument_list|,
name|untrim_cache
argument_list|)
operator|)
operator|!=
name|Nullch
condition|)
return|return
name|s
return|;
if|if
condition|(
operator|!
name|parseheader
argument_list|(
name|artnum
argument_list|)
condition|)
return|return
name|nullstr
return|;
if|if
condition|(
name|cached
operator|&&
operator|(
name|s
operator|=
name|get_cached_line
argument_list|(
name|ap
argument_list|,
name|which_line
argument_list|,
name|untrim_cache
argument_list|)
operator|)
operator|!=
name|Nullch
condition|)
return|return
name|s
return|;
return|return
name|Nullch
return|;
block|}
end_function

begin_comment
comment|/* Return a pointer to a cached header line for the indicated article. ** Truncated headers (e.g. from a .thread file) are optionally ignored. */
end_comment

begin_function
name|char
modifier|*
name|get_cached_line
parameter_list|(
name|ap
parameter_list|,
name|which_line
parameter_list|,
name|no_truncs
parameter_list|)
specifier|register
name|ARTICLE
modifier|*
name|ap
decl_stmt|;
name|int
name|which_line
decl_stmt|;
name|bool_int
name|no_truncs
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
switch|switch
condition|(
name|which_line
condition|)
block|{
case|case
name|SUBJ_LINE
case|:
if|if
condition|(
operator|!
name|ap
operator|->
name|subj
operator|||
operator|(
name|no_truncs
operator|&&
operator|(
name|ap
operator|->
name|subj
operator|->
name|flags
operator|&
name|SF_SUBJTRUNCED
operator|)
operator|)
condition|)
name|s
operator|=
name|Nullch
expr_stmt|;
else|else
name|s
operator|=
name|ap
operator|->
name|subj
operator|->
name|str
operator|+
operator|(
operator|(
name|ap
operator|->
name|flags
operator|&
name|AF_HAS_RE
operator|)
condition|?
literal|0
else|:
literal|4
operator|)
expr_stmt|;
break|break;
case|case
name|FROM_LINE
case|:
if|if
condition|(
name|no_truncs
operator|&&
operator|(
name|ap
operator|->
name|flags
operator|&
name|AF_FROMTRUNCED
operator|)
condition|)
name|s
operator|=
name|Nullch
expr_stmt|;
else|else
name|s
operator|=
name|ap
operator|->
name|from
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|DBM_XREFS
case|case
name|NGS_LINE
case|:
else|#
directive|else
case|case
name|XREF_LINE
case|:
endif|#
directive|endif
name|s
operator|=
name|ap
operator|->
name|xrefs
expr_stmt|;
break|break;
case|case
name|MESSID_LINE
case|:
name|s
operator|=
name|ap
operator|->
name|msgid
expr_stmt|;
break|break;
default|default:
name|s
operator|=
name|Nullch
expr_stmt|;
break|break;
block|}
return|return
name|s
return|;
block|}
end_function

begin_function
name|void
name|set_subj_line
parameter_list|(
name|ap
parameter_list|,
name|s
parameter_list|,
name|size
parameter_list|)
specifier|register
name|ARTICLE
modifier|*
name|ap
decl_stmt|;
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
comment|/* not yet allocated, so we can tweak it first */
specifier|register
name|int
name|size
decl_stmt|;
block|{
name|HASHDATUM
name|data
decl_stmt|;
name|SUBJECT
modifier|*
name|sp
decl_stmt|;
name|char
modifier|*
name|s2
decl_stmt|,
modifier|*
name|subj_start
init|=
name|get_subject_start
argument_list|(
name|s
argument_list|)
decl_stmt|;
if|if
condition|(
name|s
operator|!=
name|subj_start
condition|)
block|{
name|size
operator|-=
name|subj_start
operator|-
name|s
expr_stmt|;
name|ap
operator|->
name|flags
operator||=
name|AF_HAS_RE
expr_stmt|;
block|}
if|if
condition|(
name|ap
operator|->
name|subj
operator|&&
name|strnEQ
argument_list|(
name|ap
operator|->
name|subj
operator|->
name|str
operator|+
literal|4
argument_list|,
name|subj_start
argument_list|,
name|size
argument_list|)
condition|)
return|return;
name|s2
operator|=
name|safemalloc
argument_list|(
name|size
operator|+
literal|4
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|s2
argument_list|,
literal|"Re:"
argument_list|)
expr_stmt|;
name|safecat
argument_list|(
name|s2
argument_list|,
name|subj_start
argument_list|,
name|size
operator|+
literal|5
argument_list|)
expr_stmt|;
if|if
condition|(
name|ap
operator|->
name|subj
condition|)
block|{
comment|/* This only happens when we freshen truncated subjects */
name|hashdelete
argument_list|(
name|subj_hash
argument_list|,
name|ap
operator|->
name|subj
operator|->
name|str
operator|+
literal|4
argument_list|,
name|strlen
argument_list|(
name|ap
operator|->
name|subj
operator|->
name|str
operator|+
literal|4
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ap
operator|->
name|subj
operator|->
name|str
argument_list|)
expr_stmt|;
name|ap
operator|->
name|subj
operator|->
name|str
operator|=
name|s2
expr_stmt|;
name|data
operator|.
name|dat_ptr
operator|=
operator|(
name|char
operator|*
operator|)
name|ap
operator|->
name|subj
expr_stmt|;
name|hashstore
argument_list|(
name|subj_hash
argument_list|,
name|s2
operator|+
literal|4
argument_list|,
name|size
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|data
operator|=
name|hashfetch
argument_list|(
name|subj_hash
argument_list|,
name|s2
operator|+
literal|4
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|sp
operator|=
operator|(
name|SUBJECT
operator|*
operator|)
name|data
operator|.
name|dat_ptr
operator|)
condition|)
block|{
name|sp
operator|=
operator|(
name|SUBJECT
operator|*
operator|)
name|safemalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|SUBJECT
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|sp
argument_list|,
sizeof|sizeof
argument_list|(
name|SUBJECT
argument_list|)
argument_list|)
expr_stmt|;
name|subject_count
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|sp
operator|->
name|prev
operator|=
name|last_subject
operator|)
operator|!=
name|NULL
condition|)
name|sp
operator|->
name|prev
operator|->
name|next
operator|=
name|sp
expr_stmt|;
else|else
name|first_subject
operator|=
name|sp
expr_stmt|;
name|last_subject
operator|=
name|sp
expr_stmt|;
name|sp
operator|->
name|str
operator|=
name|s2
expr_stmt|;
name|sp
operator|->
name|thread_link
operator|=
name|sp
expr_stmt|;
name|sp
operator|->
name|flags
operator|=
name|SF_THREAD
expr_stmt|;
name|data
operator|.
name|dat_ptr
operator|=
operator|(
name|char
operator|*
operator|)
name|sp
expr_stmt|;
name|hashstorelast
argument_list|(
name|data
argument_list|)
expr_stmt|;
block|}
else|else
name|free
argument_list|(
name|s2
argument_list|)
expr_stmt|;
name|ap
operator|->
name|subj
operator|=
name|sp
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|set_cached_line
parameter_list|(
name|ap
parameter_list|,
name|which_line
parameter_list|,
name|s
parameter_list|)
specifier|register
name|ARTICLE
modifier|*
name|ap
decl_stmt|;
specifier|register
name|int
name|which_line
decl_stmt|;
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
comment|/* already allocated, ready to save */
block|{
comment|/* SUBJ_LINE is handled specially above */
switch|switch
condition|(
name|which_line
condition|)
block|{
case|case
name|FROM_LINE
case|:
name|ap
operator|->
name|flags
operator|&=
operator|~
name|AF_FROMTRUNCED
expr_stmt|;
if|if
condition|(
name|ap
operator|->
name|from
condition|)
name|free
argument_list|(
name|ap
operator|->
name|from
argument_list|)
expr_stmt|;
name|ap
operator|->
name|from
operator|=
name|s
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|DBM_XREFS
case|case
name|NGS_LINE
case|:
if|if
condition|(
name|ap
operator|->
name|xrefs
operator|&&
name|ap
operator|->
name|xrefs
operator|!=
name|nullstr
condition|)
name|free
argument_list|(
name|ap
operator|->
name|xrefs
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|index
argument_list|(
name|s
argument_list|,
literal|','
argument_list|)
condition|)
block|{
comment|/* if no comma, no Xref! */
name|free
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|s
operator|=
name|nullstr
expr_stmt|;
block|}
name|ap
operator|->
name|xrefs
operator|=
name|s
expr_stmt|;
break|break;
else|#
directive|else
case|case
name|XREF_LINE
case|:
if|if
condition|(
name|ap
operator|->
name|xrefs
operator|&&
name|ap
operator|->
name|xrefs
operator|!=
name|nullstr
condition|)
name|free
argument_list|(
name|ap
operator|->
name|xrefs
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_NNTP
if|if
condition|(
name|strEQ
argument_list|(
name|s
argument_list|,
literal|"(none)"
argument_list|)
condition|)
block|{
name|free
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|s
operator|=
name|nullstr
expr_stmt|;
block|}
endif|#
directive|endif
name|ap
operator|->
name|xrefs
operator|=
name|s
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
name|MESSID_LINE
case|:
if|if
condition|(
name|ap
operator|->
name|msgid
condition|)
name|free
argument_list|(
name|ap
operator|->
name|msgid
argument_list|)
expr_stmt|;
name|ap
operator|->
name|msgid
operator|=
name|s
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
name|int
name|subject_cmp
parameter_list|(
name|key
parameter_list|,
name|keylen
parameter_list|,
name|data
parameter_list|)
name|char
modifier|*
name|key
decl_stmt|;
name|int
name|keylen
decl_stmt|;
name|HASHDATUM
name|data
decl_stmt|;
block|{
comment|/* We already know that the lengths are equal, just compare the strings */
return|return
name|bcmp
argument_list|(
name|key
argument_list|,
operator|(
operator|(
name|SUBJECT
operator|*
operator|)
name|data
operator|.
name|dat_ptr
operator|)
operator|->
name|str
operator|+
literal|4
argument_list|,
name|keylen
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* see what we can do while they are reading */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|PENDING
end_ifdef

begin_function
name|void
name|look_ahead
parameter_list|()
block|{
ifdef|#
directive|ifdef
name|ARTSEARCH
specifier|register
name|char
modifier|*
name|h
decl_stmt|,
modifier|*
name|s
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|&&
name|srchahead
condition|)
block|{
name|printf
argument_list|(
literal|"(%ld)"
argument_list|,
operator|(
name|long
operator|)
name|srchahead
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
endif|#
directive|endif
if|if
condition|(
name|ThreadedGroup
condition|)
block|{
name|artp
operator|=
name|curr_artp
expr_stmt|;
name|inc_art
argument_list|(
name|selected_only
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|artp
condition|)
name|parseheader
argument_list|(
name|art
argument_list|)
expr_stmt|;
block|}
elseif|else
ifdef|#
directive|ifdef
name|ARTSEARCH
if|if
condition|(
name|srchahead
operator|&&
name|srchahead
operator|<
name|art
condition|)
block|{
comment|/* in ^N mode? */
name|char
modifier|*
name|pattern
decl_stmt|;
name|pattern
operator|=
name|buf
operator|+
literal|1
expr_stmt|;
name|strcpy
argument_list|(
name|pattern
argument_list|,
literal|": *"
argument_list|)
expr_stmt|;
name|h
operator|=
name|pattern
operator|+
name|strlen
argument_list|(
name|pattern
argument_list|)
expr_stmt|;
name|interp
argument_list|(
name|h
argument_list|,
operator|(
sizeof|sizeof
name|buf
operator|)
operator|-
operator|(
name|h
operator|-
name|buf
operator|)
argument_list|,
literal|"%\\s"
argument_list|)
expr_stmt|;
block|{
comment|/* compensate for notesfiles */
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|24
init|;
operator|*
name|h
operator|&&
name|i
operator|--
condition|;
name|h
operator|++
control|)
if|if
condition|(
operator|*
name|h
operator|==
literal|'\\'
condition|)
name|h
operator|++
expr_stmt|;
operator|*
name|h
operator|=
literal|'\0'
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|&
name|DEB_SEARCH_AHEAD
condition|)
block|{
name|fputs
argument_list|(
literal|"(hit CR)"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|gets
argument_list|(
name|buf
operator|+
literal|128
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\npattern = %s\n"
argument_list|,
name|pattern
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
operator|(
name|s
operator|=
name|compile
argument_list|(
operator|&
name|srchcompex
argument_list|,
name|pattern
argument_list|,
name|TRUE
argument_list|,
name|TRUE
argument_list|)
operator|)
operator|!=
name|Nullch
condition|)
block|{
comment|/* compile regular expression */
name|printf
argument_list|(
literal|"\n%s\n"
argument_list|,
argument|s
argument_list|)
name|FLUSH
expr_stmt|;
name|srchahead
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|srchahead
condition|)
block|{
name|srchahead
operator|=
name|art
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|srchahead
operator|++
expr_stmt|;
comment|/* go forward one article */
if|if
condition|(
name|srchahead
operator|>
name|lastart
condition|)
block|{
comment|/* out of articles? */
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|fputs
argument_list|(
literal|"(not found)"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
block|}
if|if
condition|(
operator|!
name|was_read
argument_list|(
name|srchahead
argument_list|)
operator|&&
name|wanted
argument_list|(
operator|&
name|srchcompex
argument_list|,
name|srchahead
argument_list|,
literal|0
argument_list|)
condition|)
block|{
comment|/* does the shoe fit? */
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"(%ld)"
argument_list|,
operator|(
name|long
operator|)
name|srchahead
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|parseheader
argument_list|(
name|srchahead
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|input_pending
argument_list|()
condition|)
break|break;
block|}
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
block|}
else|else
endif|#
directive|endif
comment|/* ARTSEARCH */
block|{
if|if
condition|(
name|art
operator|+
literal|1
operator|<=
name|lastart
condition|)
comment|/* how about a pre-fetch? */
name|parseheader
argument_list|(
name|art
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* look for the next article */
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* PENDING */
end_comment

begin_comment
comment|/* see what else we can do while they are reading */
end_comment

begin_function
name|void
name|cache_until_key
parameter_list|()
block|{
ifdef|#
directive|ifdef
name|PENDING
if|if
condition|(
operator|!
name|in_ng
operator|||
name|input_pending
argument_list|()
condition|)
return|return;
name|untrim_cache
operator|=
name|TRUE
expr_stmt|;
name|sentinel_artp
operator|=
name|curr_artp
expr_stmt|;
comment|/* Prioritize our caching based on what mode we're in */
if|if
condition|(
name|mode
operator|==
literal|'t'
condition|)
block|{
if|if
condition|(
name|cache_subjects
argument_list|()
condition|)
if|if
condition|(
name|cache_xrefs
argument_list|()
condition|)
if|if
condition|(
name|ThreadedGroup
condition|)
name|cache_all_arts
argument_list|()
expr_stmt|;
else|else
name|cache_unread_arts
argument_list|()
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|ThreadedGroup
operator|||
name|cache_all_arts
argument_list|()
condition|)
if|if
condition|(
name|cache_subjects
argument_list|()
condition|)
if|if
condition|(
name|cache_unread_arts
argument_list|()
condition|)
name|cache_xrefs
argument_list|()
expr_stmt|;
block|}
name|setspin
argument_list|(
name|SPIN_OFF
argument_list|)
expr_stmt|;
name|untrim_cache
operator|=
name|FALSE
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|PENDING
end_ifdef

begin_function
name|bool
name|cache_subjects
parameter_list|()
block|{
specifier|register
name|ARTICLE
modifier|*
name|ap
decl_stmt|;
specifier|register
name|ART_NUM
name|an
decl_stmt|;
if|if
condition|(
name|subj_to_get
operator|>
name|lastart
condition|)
return|return
name|TRUE
return|;
name|setspin
argument_list|(
name|SPIN_BACKGROUND
argument_list|)
expr_stmt|;
for|for
control|(
name|an
operator|=
name|subj_to_get
operator|,
name|ap
operator|=
name|article_ptr
argument_list|(
name|an
argument_list|)
init|;
name|an
operator|<=
name|lastart
condition|;
name|ap
operator|++
operator|,
name|an
operator|++
control|)
block|{
if|if
condition|(
name|input_pending
argument_list|()
condition|)
break|break;
if|if
condition|(
operator|!
operator|(
name|ap
operator|->
name|flags
operator|&
name|AF_READ
operator|)
condition|)
name|fetchsubj
argument_list|(
name|an
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
name|subj_to_get
operator|=
name|an
expr_stmt|;
return|return
name|subj_to_get
operator|>
name|lastart
return|;
block|}
end_function

begin_function
name|bool
name|cache_xrefs
parameter_list|()
block|{
specifier|register
name|ARTICLE
modifier|*
name|ap
decl_stmt|;
specifier|register
name|ART_NUM
name|an
decl_stmt|;
if|if
condition|(
name|olden_days
operator|||
name|xref_to_get
operator|>
name|lastart
condition|)
return|return
name|TRUE
return|;
name|setspin
argument_list|(
name|SPIN_BACKGROUND
argument_list|)
expr_stmt|;
for|for
control|(
name|an
operator|=
name|xref_to_get
operator|,
name|ap
operator|=
name|article_ptr
argument_list|(
name|an
argument_list|)
init|;
name|an
operator|<=
name|lastart
condition|;
name|ap
operator|++
operator|,
name|an
operator|++
control|)
block|{
if|if
condition|(
name|input_pending
argument_list|()
condition|)
break|break;
if|if
condition|(
operator|!
operator|(
name|ap
operator|->
name|flags
operator|&
name|AF_READ
operator|)
condition|)
name|fetchxref
argument_list|(
name|an
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
name|xref_to_get
operator|=
name|an
expr_stmt|;
return|return
name|xref_to_get
operator|>
name|lastart
return|;
block|}
end_function

begin_function
name|bool
name|cache_all_arts
parameter_list|()
block|{
if|if
condition|(
operator|!
name|cached_all_in_range
condition|)
name|last_cached
operator|=
name|first_cached
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|last_cached
operator|>=
name|lastart
operator|&&
name|first_cached
operator|<=
name|absfirst
condition|)
return|return
name|TRUE
return|;
comment|/* turn it on as late as possible to avoid fseek()ing openart */
name|setspin
argument_list|(
name|SPIN_BACKGROUND
argument_list|)
expr_stmt|;
if|if
condition|(
name|last_cached
operator|<
name|lastart
condition|)
block|{
if|if
condition|(
operator|!
name|art_data
argument_list|(
name|last_cached
operator|+
literal|1
argument_list|,
name|lastart
argument_list|,
name|TRUE
argument_list|,
name|TRUE
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|cached_all_in_range
operator|=
name|TRUE
expr_stmt|;
block|}
if|if
condition|(
name|first_cached
operator|>
name|absfirst
condition|)
block|{
ifdef|#
directive|ifdef
name|USE_OV
if|if
condition|(
name|ov_opened
condition|)
name|ov_data
argument_list|(
name|absfirst
argument_list|,
name|first_cached
operator|-
literal|1
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
name|art_data
argument_list|(
name|absfirst
argument_list|,
name|first_cached
operator|-
literal|1
argument_list|,
name|TRUE
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
comment|/* If we got interrupted, make a quick exit */
if|if
condition|(
name|first_cached
operator|>
name|absfirst
condition|)
return|return
name|FALSE
return|;
block|}
comment|/* We're all done threading the group, so if the current article is     ** still in doubt, tell them it's missing. */
if|if
condition|(
name|curr_artp
operator|&&
operator|!
operator|(
name|curr_artp
operator|->
name|flags
operator|&
name|AF_CACHED
operator|)
operator|&&
operator|!
name|input_pending
argument_list|()
condition|)
name|pushchar
argument_list|(
literal|'\f'
operator||
literal|0200
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_function
name|bool
name|cache_unread_arts
parameter_list|()
block|{
if|if
condition|(
name|last_cached
operator|>=
name|lastart
condition|)
return|return
name|TRUE
return|;
name|setspin
argument_list|(
name|SPIN_BACKGROUND
argument_list|)
expr_stmt|;
return|return
name|art_data
argument_list|(
name|last_cached
operator|+
literal|1
argument_list|,
name|lastart
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|bool
name|art_data
parameter_list|(
name|first
parameter_list|,
name|last
parameter_list|,
name|cheating
parameter_list|,
name|all_articles
parameter_list|)
name|ART_NUM
name|first
decl_stmt|,
name|last
decl_stmt|;
name|bool_int
name|cheating
decl_stmt|;
name|bool_int
name|all_articles
decl_stmt|;
block|{
specifier|register
name|ARTICLE
modifier|*
name|ap
decl_stmt|;
specifier|register
name|ART_NUM
name|i
decl_stmt|;
name|int
name|cachemask
init|=
operator|(
name|ThreadedGroup
condition|?
name|AF_THREADED
else|:
name|AF_CACHED
operator|)
operator|+
operator|(
name|all_articles
condition|?
literal|0
else|:
name|AF_READ
operator|)
decl_stmt|;
name|setspin
argument_list|(
name|cheating
condition|?
name|SPIN_BACKGROUND
else|:
name|SPIN_FOREGROUND
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|first
operator|>=
name|absfirst
operator|&&
name|last
operator|<=
name|lastart
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|first
operator|,
name|ap
operator|=
name|article_ptr
argument_list|(
name|first
argument_list|)
init|;
name|i
operator|<=
name|last
condition|;
name|i
operator|++
operator|,
name|ap
operator|++
control|)
block|{
if|if
condition|(
name|ap
operator|->
name|flags
operator|&
name|cachemask
condition|)
continue|continue;
if|if
condition|(
name|int_count
condition|)
block|{
name|int_count
operator|=
literal|0
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|cheating
condition|)
block|{
if|if
condition|(
name|input_pending
argument_list|()
condition|)
break|break;
comment|/* If the current article is no longer a '?', let them know. */
if|if
condition|(
name|curr_artp
operator|!=
name|sentinel_artp
condition|)
block|{
name|pushchar
argument_list|(
literal|'\f'
operator||
literal|0200
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
comment|/* This parses the header which will cache/thread the article */
operator|(
name|void
operator|)
name|parseheader
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
name|setspin
argument_list|(
name|SPIN_POP
argument_list|)
expr_stmt|;
if|if
condition|(
operator|--
name|i
operator|>
name|last_cached
condition|)
name|last_cached
operator|=
name|i
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|last
condition|)
block|{
if|if
condition|(
name|first
operator|<
name|first_cached
condition|)
name|first_cached
operator|=
name|first
expr_stmt|;
return|return
name|TRUE
return|;
block|}
return|return
name|FALSE
return|;
block|}
end_function

begin_function
name|bool
name|cache_range
parameter_list|(
name|first
parameter_list|,
name|last
parameter_list|)
name|ART_NUM
name|first
decl_stmt|;
name|ART_NUM
name|last
decl_stmt|;
block|{
name|bool
name|success
init|=
name|TRUE
decl_stmt|;
name|bool
name|all_arts
init|=
operator|(
name|sel_rereading
operator|||
name|thread_always
operator|)
decl_stmt|;
name|ART_NUM
name|count
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|sel_rereading
operator|&&
operator|!
name|cached_all_in_range
condition|)
block|{
name|first_cached
operator|=
name|first
expr_stmt|;
name|last_cached
operator|=
name|first
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|first
operator|<
name|first_cached
condition|)
name|count
operator|=
name|first_cached
operator|-
name|first
expr_stmt|;
if|if
condition|(
name|last
operator|>
name|last_cached
condition|)
name|count
operator|+=
name|last
operator|-
name|last_cached
expr_stmt|;
if|if
condition|(
operator|!
name|count
condition|)
return|return
name|TRUE
return|;
if|if
condition|(
name|first_cached
operator|>
name|last_cached
condition|)
block|{
if|if
condition|(
name|sel_rereading
condition|)
block|{
if|if
condition|(
name|first_subject
condition|)
name|count
operator|-=
name|toread
index|[
name|ng
index|]
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|first
operator|==
name|firstart
operator|&&
name|last
operator|==
name|lastart
operator|&&
operator|!
name|all_arts
condition|)
name|count
operator|=
name|toread
index|[
name|ng
index|]
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n%sing %ld article%s."
argument_list|,
argument|ThreadedGroup?
literal|"Thread"
argument|:
literal|"Cach"
argument_list|,
argument|(long)count
argument_list|,
argument|count==
literal|1
argument|? nullstr :
literal|"s"
argument_list|)
name|FLUSH
expr_stmt|;
name|setspin
argument_list|(
name|SPIN_FOREGROUND
argument_list|)
expr_stmt|;
if|if
condition|(
name|first
operator|<
name|first_cached
condition|)
block|{
ifdef|#
directive|ifdef
name|USE_OV
if|if
condition|(
name|ov_opened
condition|)
block|{
name|ov_data
argument_list|(
name|absfirst
argument_list|,
name|first_cached
operator|-
literal|1
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|success
operator|=
operator|(
name|first_cached
operator|==
name|absfirst
operator|)
operator|)
operator|!=
name|FALSE
condition|)
name|ov_close
argument_list|()
expr_stmt|;
block|}
else|else
endif|#
directive|endif
block|{
name|success
operator|=
name|art_data
argument_list|(
name|first
argument_list|,
name|first_cached
operator|-
literal|1
argument_list|,
name|FALSE
argument_list|,
name|all_arts
argument_list|)
expr_stmt|;
name|cached_all_in_range
operator|=
operator|(
name|all_arts
operator|&&
name|success
operator|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|success
operator|&&
name|last_cached
operator|<
name|last
condition|)
block|{
name|success
operator|=
name|art_data
argument_list|(
name|last_cached
operator|+
literal|1
argument_list|,
name|last
argument_list|,
name|FALSE
argument_list|,
name|all_arts
argument_list|)
expr_stmt|;
name|cached_all_in_range
operator|=
operator|(
name|all_arts
operator|&&
name|success
operator|)
expr_stmt|;
block|}
name|setspin
argument_list|(
name|SPIN_POP
argument_list|)
expr_stmt|;
return|return
name|success
return|;
block|}
end_function

begin_function
name|void
name|clear_article
parameter_list|(
name|ap
parameter_list|)
specifier|register
name|ARTICLE
modifier|*
name|ap
decl_stmt|;
block|{
if|if
condition|(
name|ap
operator|->
name|from
condition|)
name|free
argument_list|(
name|ap
operator|->
name|from
argument_list|)
expr_stmt|;
if|if
condition|(
name|ap
operator|->
name|msgid
condition|)
name|free
argument_list|(
name|ap
operator|->
name|msgid
argument_list|)
expr_stmt|;
if|if
condition|(
name|ap
operator|->
name|xrefs
operator|&&
name|ap
operator|->
name|xrefs
operator|!=
name|nullstr
condition|)
name|free
argument_list|(
name|ap
operator|->
name|xrefs
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

