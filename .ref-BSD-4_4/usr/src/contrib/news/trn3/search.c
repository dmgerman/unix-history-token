begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* $Id: search.c,v 3.0 1992/02/01 03:09:32 davison Trn $  */
end_comment

begin_comment
comment|/* string search routines */
end_comment

begin_comment
comment|/*		Copyright (c) 1981,1980 James Gosling		*/
end_comment

begin_comment
comment|/* Modified Aug. 12, 1981 by Tom London to include regular expressions    as in ed.  RE stuff hacked over by jag to correct a few major problems,    mainly dealing with searching within the buffer rather than copying    each line to a separate array.  Newlines can now appear in RE's */
end_comment

begin_comment
comment|/* Ripped to shreds and glued back together to make a search package,  * July 6, 1984, by Larry Wall. (If it doesn't work, it's probably my fault.)  * Changes include:  *	Buffer, window, and mlisp stuff gone.  *	Translation tables reduced to 1 table.  *	Expression buffer is now dynamically allocated.  *	Character classes now implemented with a bitmap.  */
end_comment

begin_include
include|#
directive|include
file|"EXTERN.h"
end_include

begin_include
include|#
directive|include
file|"common.h"
end_include

begin_include
include|#
directive|include
file|"util.h"
end_include

begin_include
include|#
directive|include
file|"INTERN.h"
end_include

begin_include
include|#
directive|include
file|"search.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|BITSPERBYTE
end_ifndef

begin_define
define|#
directive|define
name|BITSPERBYTE
value|8
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|BMAPSIZ
value|(127 / BITSPERBYTE + 1)
end_define

begin_comment
comment|/* meta characters in the "compiled" form of a regular expression */
end_comment

begin_define
define|#
directive|define
name|CBRA
value|2
end_define

begin_comment
comment|/* \( -- begin bracket */
end_comment

begin_define
define|#
directive|define
name|CCHR
value|4
end_define

begin_comment
comment|/* a vanilla character */
end_comment

begin_define
define|#
directive|define
name|CDOT
value|6
end_define

begin_comment
comment|/* . -- match anything except a newline */
end_comment

begin_define
define|#
directive|define
name|CCL
value|8
end_define

begin_comment
comment|/* [...] -- character class */
end_comment

begin_define
define|#
directive|define
name|NCCL
value|10
end_define

begin_comment
comment|/* [^...] -- negated character class */
end_comment

begin_define
define|#
directive|define
name|CDOL
value|12
end_define

begin_comment
comment|/* $ -- matches the end of a line */
end_comment

begin_define
define|#
directive|define
name|CEND
value|14
end_define

begin_comment
comment|/* The end of the pattern */
end_comment

begin_define
define|#
directive|define
name|CKET
value|16
end_define

begin_comment
comment|/* \) -- close bracket */
end_comment

begin_define
define|#
directive|define
name|CBACK
value|18
end_define

begin_comment
comment|/* \N -- backreference to the Nth bracketed 				   string */
end_comment

begin_define
define|#
directive|define
name|CIRC
value|20
end_define

begin_comment
comment|/* ^ matches the beginning of a line */
end_comment

begin_define
define|#
directive|define
name|WORD
value|32
end_define

begin_comment
comment|/* matches word character \w */
end_comment

begin_define
define|#
directive|define
name|NWORD
value|34
end_define

begin_comment
comment|/* matches non-word characer \W */
end_comment

begin_define
define|#
directive|define
name|WBOUND
value|36
end_define

begin_comment
comment|/* matches word boundary \b */
end_comment

begin_define
define|#
directive|define
name|NWBOUND
value|38
end_define

begin_comment
comment|/* matches non-(word boundary) \B */
end_comment

begin_define
define|#
directive|define
name|STAR
value|01
end_define

begin_comment
comment|/* * -- Kleene star, repeats the previous 				   REas many times as possible; the value 				   ORs with the other operator types */
end_comment

begin_define
define|#
directive|define
name|ASCSIZ
value|0200
end_define

begin_typedef
typedef|typedef
name|char
name|TRANSTABLE
index|[
name|ASCSIZ
index|]
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|TRANSTABLE
name|trans
init|=
block|{
literal|0000
block|,
literal|0001
block|,
literal|0002
block|,
literal|0003
block|,
literal|0004
block|,
literal|0005
block|,
literal|0006
block|,
literal|0007
block|,
literal|0010
block|,
literal|0011
block|,
literal|0012
block|,
literal|0013
block|,
literal|0014
block|,
literal|0015
block|,
literal|0016
block|,
literal|0017
block|,
literal|0020
block|,
literal|0021
block|,
literal|0022
block|,
literal|0023
block|,
literal|0024
block|,
literal|0025
block|,
literal|0026
block|,
literal|0027
block|,
literal|0030
block|,
literal|0031
block|,
literal|0032
block|,
literal|0033
block|,
literal|0034
block|,
literal|0035
block|,
literal|0036
block|,
literal|0037
block|,
literal|0040
block|,
literal|0041
block|,
literal|0042
block|,
literal|0043
block|,
literal|0044
block|,
literal|0045
block|,
literal|0046
block|,
literal|0047
block|,
literal|0050
block|,
literal|0051
block|,
literal|0052
block|,
literal|0053
block|,
literal|0054
block|,
literal|0055
block|,
literal|0056
block|,
literal|0057
block|,
literal|0060
block|,
literal|0061
block|,
literal|0062
block|,
literal|0063
block|,
literal|0064
block|,
literal|0065
block|,
literal|0066
block|,
literal|0067
block|,
literal|0070
block|,
literal|0071
block|,
literal|0072
block|,
literal|0073
block|,
literal|0074
block|,
literal|0075
block|,
literal|0076
block|,
literal|0077
block|,
literal|0100
block|,
literal|0101
block|,
literal|0102
block|,
literal|0103
block|,
literal|0104
block|,
literal|0105
block|,
literal|0106
block|,
literal|0107
block|,
literal|0110
block|,
literal|0111
block|,
literal|0112
block|,
literal|0113
block|,
literal|0114
block|,
literal|0115
block|,
literal|0116
block|,
literal|0117
block|,
literal|0120
block|,
literal|0121
block|,
literal|0122
block|,
literal|0123
block|,
literal|0124
block|,
literal|0125
block|,
literal|0126
block|,
literal|0127
block|,
literal|0130
block|,
literal|0131
block|,
literal|0132
block|,
literal|0133
block|,
literal|0134
block|,
literal|0135
block|,
literal|0136
block|,
literal|0137
block|,
literal|0140
block|,
literal|0141
block|,
literal|0142
block|,
literal|0143
block|,
literal|0144
block|,
literal|0145
block|,
literal|0146
block|,
literal|0147
block|,
literal|0150
block|,
literal|0151
block|,
literal|0152
block|,
literal|0153
block|,
literal|0154
block|,
literal|0155
block|,
literal|0156
block|,
literal|0157
block|,
literal|0160
block|,
literal|0161
block|,
literal|0162
block|,
literal|0163
block|,
literal|0164
block|,
literal|0165
block|,
literal|0166
block|,
literal|0167
block|,
literal|0170
block|,
literal|0171
block|,
literal|0172
block|,
literal|0173
block|,
literal|0174
block|,
literal|0175
block|,
literal|0176
block|,
literal|0177
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bool
name|folding
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|err
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|FirstCharacter
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|search_init
parameter_list|()
block|{
ifdef|#
directive|ifdef
name|UNDEF
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ASCSIZ
condition|;
name|i
operator|++
control|)
name|trans
index|[
name|i
index|]
operator|=
name|i
expr_stmt|;
else|#
directive|else
empty_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
name|void
name|init_compex
parameter_list|(
name|compex
parameter_list|)
specifier|register
name|COMPEX
modifier|*
name|compex
decl_stmt|;
block|{
comment|/* the following must start off zeroed */
name|compex
operator|->
name|eblen
operator|=
literal|0
expr_stmt|;
name|compex
operator|->
name|brastr
operator|=
name|Nullch
expr_stmt|;
block|}
end_function

begin_function
name|void
name|free_compex
parameter_list|(
name|compex
parameter_list|)
specifier|register
name|COMPEX
modifier|*
name|compex
decl_stmt|;
block|{
if|if
condition|(
name|compex
operator|->
name|eblen
condition|)
block|{
name|free
argument_list|(
name|compex
operator|->
name|expbuf
argument_list|)
expr_stmt|;
name|compex
operator|->
name|eblen
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|compex
operator|->
name|brastr
condition|)
block|{
name|free
argument_list|(
name|compex
operator|->
name|brastr
argument_list|)
expr_stmt|;
name|compex
operator|->
name|brastr
operator|=
name|Nullch
expr_stmt|;
block|}
block|}
end_function

begin_decl_stmt
specifier|static
name|char
modifier|*
name|gbr_str
init|=
name|Nullch
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|gbr_siz
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
name|char
modifier|*
name|getbracket
parameter_list|(
name|compex
parameter_list|,
name|n
parameter_list|)
specifier|register
name|COMPEX
modifier|*
name|compex
decl_stmt|;
name|int
name|n
decl_stmt|;
block|{
name|int
name|length
init|=
name|compex
operator|->
name|braelist
index|[
name|n
index|]
operator|-
name|compex
operator|->
name|braslist
index|[
name|n
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|compex
operator|->
name|nbra
operator|||
name|n
operator|>
name|compex
operator|->
name|nbra
operator|||
operator|!
name|compex
operator|->
name|braelist
index|[
name|n
index|]
operator|||
name|length
operator|<
literal|0
condition|)
return|return
name|nullstr
return|;
name|growstr
argument_list|(
operator|&
name|gbr_str
argument_list|,
operator|&
name|gbr_siz
argument_list|,
name|length
operator|+
literal|1
argument_list|)
expr_stmt|;
name|safecpy
argument_list|(
name|gbr_str
argument_list|,
name|compex
operator|->
name|braslist
index|[
name|n
index|]
argument_list|,
name|length
operator|+
literal|1
argument_list|)
expr_stmt|;
return|return
name|gbr_str
return|;
block|}
end_function

begin_function
name|void
name|case_fold
parameter_list|(
name|which
parameter_list|)
name|int
name|which
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
if|if
condition|(
name|which
operator|!=
name|folding
condition|)
block|{
if|if
condition|(
name|which
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|'A'
init|;
name|i
operator|<=
literal|'Z'
condition|;
name|i
operator|++
control|)
name|trans
index|[
name|i
index|]
operator|=
name|tolower
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|i
operator|=
literal|'A'
init|;
name|i
operator|<=
literal|'Z'
condition|;
name|i
operator|++
control|)
name|trans
index|[
name|i
index|]
operator|=
name|i
expr_stmt|;
block|}
name|folding
operator|=
name|which
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Compile the given regular expression into a [secret] internal format */
end_comment

begin_function
name|char
modifier|*
name|compile
parameter_list|(
name|compex
parameter_list|,
name|strp
parameter_list|,
name|RE
parameter_list|,
name|fold
parameter_list|)
specifier|register
name|COMPEX
modifier|*
name|compex
decl_stmt|;
specifier|register
name|char
modifier|*
name|strp
decl_stmt|;
name|int
name|RE
decl_stmt|;
name|int
name|fold
decl_stmt|;
block|{
specifier|register
name|int
name|c
decl_stmt|;
specifier|register
name|char
modifier|*
name|ep
decl_stmt|;
name|char
modifier|*
name|lastep
decl_stmt|;
name|char
name|bracket
index|[
name|NBRA
index|]
decl_stmt|,
modifier|*
name|bracketp
decl_stmt|;
name|char
modifier|*
modifier|*
name|alt
init|=
name|compex
operator|->
name|alternatives
decl_stmt|;
name|char
modifier|*
name|retmes
init|=
literal|"Badly formed search string"
decl_stmt|;
name|case_fold
argument_list|(
name|compex
operator|->
name|do_folding
operator|=
name|fold
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|compex
operator|->
name|eblen
condition|)
block|{
name|compex
operator|->
name|expbuf
operator|=
name|safemalloc
argument_list|(
literal|84
argument_list|)
expr_stmt|;
name|compex
operator|->
name|eblen
operator|=
literal|80
expr_stmt|;
block|}
name|ep
operator|=
name|compex
operator|->
name|expbuf
expr_stmt|;
comment|/* point at expression buffer */
operator|*
name|alt
operator|++
operator|=
name|ep
expr_stmt|;
comment|/* first alternative starts here */
name|bracketp
operator|=
name|bracket
expr_stmt|;
comment|/* first bracket goes here */
if|if
condition|(
operator|*
name|strp
operator|==
literal|0
condition|)
block|{
comment|/* nothing to compile? */
if|if
condition|(
operator|*
name|ep
operator|==
literal|0
condition|)
comment|/* nothing there yet? */
return|return
literal|"Null search string"
return|;
return|return
name|Nullch
return|;
comment|/* just keep old expression */
block|}
name|compex
operator|->
name|nbra
operator|=
literal|0
expr_stmt|;
comment|/* no brackets yet */
name|lastep
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|ep
operator|-
name|compex
operator|->
name|expbuf
operator|>=
name|compex
operator|->
name|eblen
condition|)
name|ep
operator|=
name|grow_eb
argument_list|(
name|compex
argument_list|,
name|ep
argument_list|,
name|alt
argument_list|)
expr_stmt|;
name|c
operator|=
operator|*
name|strp
operator|++
expr_stmt|;
comment|/* fetch next char of pattern */
if|if
condition|(
name|c
operator|==
literal|0
condition|)
block|{
comment|/* end of pattern? */
if|if
condition|(
name|bracketp
operator|!=
name|bracket
condition|)
block|{
comment|/* balanced brackets? */
ifdef|#
directive|ifdef
name|VERBOSE
name|retmes
operator|=
literal|"Unbalanced parens"
expr_stmt|;
endif|#
directive|endif
goto|goto
name|cerror
goto|;
block|}
operator|*
name|ep
operator|++
operator|=
name|CEND
expr_stmt|;
comment|/* terminate expression */
operator|*
name|alt
operator|++
operator|=
literal|0
expr_stmt|;
comment|/* terminal alternative list */
return|return
name|Nullch
return|;
comment|/* return success */
block|}
if|if
condition|(
name|c
operator|!=
literal|'*'
condition|)
name|lastep
operator|=
name|ep
expr_stmt|;
if|if
condition|(
operator|!
name|RE
condition|)
block|{
comment|/* just a normal search string? */
operator|*
name|ep
operator|++
operator|=
name|CCHR
expr_stmt|;
comment|/* everything is a normal char */
operator|*
name|ep
operator|++
operator|=
name|c
expr_stmt|;
block|}
else|else
comment|/* it is a regular expression */
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'\\'
case|:
comment|/* meta something */
switch|switch
condition|(
name|c
operator|=
operator|*
name|strp
operator|++
condition|)
block|{
case|case
literal|'('
case|:
if|if
condition|(
name|compex
operator|->
name|nbra
operator|>=
name|NBRA
condition|)
block|{
ifdef|#
directive|ifdef
name|VERBOSE
name|retmes
operator|=
literal|"Too many parens"
expr_stmt|;
endif|#
directive|endif
goto|goto
name|cerror
goto|;
block|}
operator|*
name|bracketp
operator|++
operator|=
operator|++
name|compex
operator|->
name|nbra
expr_stmt|;
operator|*
name|ep
operator|++
operator|=
name|CBRA
expr_stmt|;
operator|*
name|ep
operator|++
operator|=
name|compex
operator|->
name|nbra
expr_stmt|;
break|break;
case|case
literal|'|'
case|:
if|if
condition|(
name|bracketp
operator|>
name|bracket
condition|)
block|{
ifdef|#
directive|ifdef
name|VERBOSE
name|retmes
operator|=
literal|"No \\| in parens"
expr_stmt|;
comment|/* Alas! */
endif|#
directive|endif
goto|goto
name|cerror
goto|;
block|}
operator|*
name|ep
operator|++
operator|=
name|CEND
expr_stmt|;
operator|*
name|alt
operator|++
operator|=
name|ep
expr_stmt|;
break|break;
case|case
literal|')'
case|:
if|if
condition|(
name|bracketp
operator|<=
name|bracket
condition|)
block|{
ifdef|#
directive|ifdef
name|VERBOSE
name|retmes
operator|=
literal|"Unmatched right paren"
expr_stmt|;
endif|#
directive|endif
goto|goto
name|cerror
goto|;
block|}
operator|*
name|ep
operator|++
operator|=
name|CKET
expr_stmt|;
operator|*
name|ep
operator|++
operator|=
operator|*
operator|--
name|bracketp
expr_stmt|;
break|break;
case|case
literal|'w'
case|:
operator|*
name|ep
operator|++
operator|=
name|WORD
expr_stmt|;
break|break;
case|case
literal|'W'
case|:
operator|*
name|ep
operator|++
operator|=
name|NWORD
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
operator|*
name|ep
operator|++
operator|=
name|WBOUND
expr_stmt|;
break|break;
case|case
literal|'B'
case|:
operator|*
name|ep
operator|++
operator|=
name|NWBOUND
expr_stmt|;
break|break;
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
operator|*
name|ep
operator|++
operator|=
name|CBACK
expr_stmt|;
operator|*
name|ep
operator|++
operator|=
name|c
operator|-
literal|'0'
expr_stmt|;
break|break;
default|default:
operator|*
name|ep
operator|++
operator|=
name|CCHR
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\0'
condition|)
goto|goto
name|cerror
goto|;
operator|*
name|ep
operator|++
operator|=
name|c
expr_stmt|;
break|break;
block|}
break|break;
case|case
literal|'.'
case|:
operator|*
name|ep
operator|++
operator|=
name|CDOT
expr_stmt|;
continue|continue;
case|case
literal|'*'
case|:
if|if
condition|(
name|lastep
operator|==
literal|0
operator|||
operator|*
name|lastep
operator|==
name|CBRA
operator|||
operator|*
name|lastep
operator|==
name|CKET
operator|||
operator|*
name|lastep
operator|==
name|CIRC
operator|||
operator|(
operator|*
name|lastep
operator|&
name|STAR
operator|)
operator|||
operator|*
name|lastep
operator|>
name|NWORD
condition|)
goto|goto
name|defchar
goto|;
operator|*
name|lastep
operator||=
name|STAR
expr_stmt|;
continue|continue;
case|case
literal|'^'
case|:
if|if
condition|(
name|ep
operator|!=
name|compex
operator|->
name|expbuf
operator|&&
name|ep
index|[
operator|-
literal|1
index|]
operator|!=
name|CEND
condition|)
goto|goto
name|defchar
goto|;
operator|*
name|ep
operator|++
operator|=
name|CIRC
expr_stmt|;
continue|continue;
case|case
literal|'$'
case|:
if|if
condition|(
operator|*
name|strp
operator|!=
literal|0
operator|&&
operator|(
operator|*
name|strp
operator|!=
literal|'\\'
operator|||
name|strp
index|[
literal|1
index|]
operator|!=
literal|'|'
operator|)
condition|)
goto|goto
name|defchar
goto|;
operator|*
name|ep
operator|++
operator|=
name|CDOL
expr_stmt|;
continue|continue;
case|case
literal|'['
case|:
block|{
comment|/* character class */
specifier|register
name|int
name|i
decl_stmt|;
if|if
condition|(
name|ep
operator|-
name|compex
operator|->
name|expbuf
operator|>=
name|compex
operator|->
name|eblen
operator|-
name|BMAPSIZ
condition|)
name|ep
operator|=
name|grow_eb
argument_list|(
name|compex
argument_list|,
name|ep
argument_list|,
name|alt
argument_list|)
expr_stmt|;
comment|/* reserve bitmap */
for|for
control|(
name|i
operator|=
name|BMAPSIZ
init|;
name|i
condition|;
operator|--
name|i
control|)
name|ep
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|=
operator|*
name|strp
operator|++
operator|)
operator|==
literal|'^'
condition|)
block|{
name|c
operator|=
operator|*
name|strp
operator|++
expr_stmt|;
operator|*
name|ep
operator|++
operator|=
name|NCCL
expr_stmt|;
comment|/* negated */
block|}
else|else
operator|*
name|ep
operator|++
operator|=
name|CCL
expr_stmt|;
comment|/* normal */
name|i
operator|=
literal|0
expr_stmt|;
comment|/* remember oldchar */
do|do
block|{
if|if
condition|(
name|c
operator|==
literal|'\0'
condition|)
block|{
ifdef|#
directive|ifdef
name|VERBOSE
name|retmes
operator|=
literal|"Missing ]"
expr_stmt|;
endif|#
directive|endif
goto|goto
name|cerror
goto|;
block|}
if|if
condition|(
operator|*
name|strp
operator|==
literal|'-'
operator|&&
operator|*
operator|(
operator|++
name|strp
operator|)
operator|!=
literal|']'
operator|&&
operator|*
name|strp
condition|)
name|i
operator|=
operator|*
name|strp
operator|++
expr_stmt|;
else|else
name|i
operator|=
name|c
expr_stmt|;
while|while
condition|(
name|c
operator|<=
name|i
condition|)
block|{
name|ep
index|[
name|c
operator|/
name|BITSPERBYTE
index|]
operator||=
literal|1
operator|<<
operator|(
name|c
operator|%
name|BITSPERBYTE
operator|)
expr_stmt|;
if|if
condition|(
name|fold
operator|&&
name|isalpha
argument_list|(
name|c
argument_list|)
condition|)
name|ep
index|[
operator|(
name|c
operator|^
literal|32
operator|)
operator|/
name|BITSPERBYTE
index|]
operator||=
literal|1
operator|<<
operator|(
operator|(
name|c
operator|^
literal|32
operator|)
operator|%
name|BITSPERBYTE
operator|)
expr_stmt|;
comment|/* set the other bit too */
name|c
operator|++
expr_stmt|;
block|}
block|}
do|while
condition|(
operator|(
name|c
operator|=
operator|*
name|strp
operator|++
operator|)
operator|!=
literal|']'
condition|)
do|;
name|ep
operator|+=
name|BMAPSIZ
expr_stmt|;
continue|continue;
block|}
name|defchar
label|:
default|default:
operator|*
name|ep
operator|++
operator|=
name|CCHR
expr_stmt|;
operator|*
name|ep
operator|++
operator|=
name|c
expr_stmt|;
block|}
block|}
name|cerror
label|:
name|compex
operator|->
name|expbuf
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|compex
operator|->
name|nbra
operator|=
literal|0
expr_stmt|;
return|return
name|retmes
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|grow_eb
parameter_list|(
name|compex
parameter_list|,
name|epp
parameter_list|,
name|alt
parameter_list|)
specifier|register
name|COMPEX
modifier|*
name|compex
decl_stmt|;
name|char
modifier|*
name|epp
decl_stmt|;
name|char
modifier|*
modifier|*
name|alt
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|oldbuf
init|=
name|compex
operator|->
name|expbuf
decl_stmt|;
specifier|register
name|char
modifier|*
modifier|*
name|altlist
init|=
name|compex
operator|->
name|alternatives
decl_stmt|;
name|compex
operator|->
name|eblen
operator|+=
literal|80
expr_stmt|;
name|compex
operator|->
name|expbuf
operator|=
name|saferealloc
argument_list|(
name|compex
operator|->
name|expbuf
argument_list|,
operator|(
name|MEM_SIZE
operator|)
name|compex
operator|->
name|eblen
operator|+
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|compex
operator|->
name|expbuf
operator|!=
name|oldbuf
condition|)
block|{
comment|/* realloc can change expbuf! */
name|epp
operator|+=
name|compex
operator|->
name|expbuf
operator|-
name|oldbuf
expr_stmt|;
while|while
condition|(
name|altlist
operator|!=
name|alt
condition|)
operator|*
name|altlist
operator|++
operator|+=
name|compex
operator|->
name|expbuf
operator|-
name|oldbuf
expr_stmt|;
block|}
return|return
name|epp
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|execute
parameter_list|(
name|compex
parameter_list|,
name|addr
parameter_list|)
specifier|register
name|COMPEX
modifier|*
name|compex
decl_stmt|;
name|char
modifier|*
name|addr
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|p1
init|=
name|addr
decl_stmt|;
specifier|register
name|char
modifier|*
name|trt
init|=
name|trans
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
if|if
condition|(
name|addr
operator|==
name|Nullch
operator|||
name|compex
operator|->
name|expbuf
operator|==
name|Nullch
condition|)
return|return
name|Nullch
return|;
if|if
condition|(
name|compex
operator|->
name|nbra
condition|)
block|{
comment|/* any brackets? */
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<=
name|compex
operator|->
name|nbra
condition|;
name|c
operator|++
control|)
name|compex
operator|->
name|braslist
index|[
name|c
index|]
operator|=
name|compex
operator|->
name|braelist
index|[
name|c
index|]
operator|=
name|Nullch
expr_stmt|;
if|if
condition|(
name|compex
operator|->
name|brastr
condition|)
name|free
argument_list|(
name|compex
operator|->
name|brastr
argument_list|)
expr_stmt|;
name|compex
operator|->
name|brastr
operator|=
name|savestr
argument_list|(
name|p1
argument_list|)
expr_stmt|;
comment|/* in case p1 is not static */
name|p1
operator|=
name|compex
operator|->
name|brastr
expr_stmt|;
comment|/* ! */
block|}
name|case_fold
argument_list|(
name|compex
operator|->
name|do_folding
argument_list|)
expr_stmt|;
comment|/* make sure table is correct */
name|FirstCharacter
operator|=
name|p1
expr_stmt|;
comment|/* for ^ tests */
if|if
condition|(
name|compex
operator|->
name|expbuf
index|[
literal|0
index|]
operator|==
name|CCHR
operator|&&
operator|!
name|compex
operator|->
name|alternatives
index|[
literal|1
index|]
condition|)
block|{
name|c
operator|=
name|trt
index|[
name|compex
operator|->
name|expbuf
index|[
literal|1
index|]
index|]
expr_stmt|;
comment|/* fast check for first character */
do|do
block|{
if|if
condition|(
name|trt
index|[
operator|*
name|p1
index|]
operator|==
name|c
operator|&&
name|advance
argument_list|(
name|compex
argument_list|,
name|p1
argument_list|,
name|compex
operator|->
name|expbuf
argument_list|)
condition|)
return|return
name|p1
return|;
name|p1
operator|++
expr_stmt|;
block|}
do|while
condition|(
operator|*
name|p1
operator|&&
operator|!
name|err
condition|)
do|;
if|if
condition|(
name|err
condition|)
name|err
operator|=
literal|0
expr_stmt|;
return|return
name|Nullch
return|;
block|}
else|else
block|{
comment|/* regular algorithm */
do|do
block|{
specifier|register
name|char
modifier|*
modifier|*
name|alt
init|=
name|compex
operator|->
name|alternatives
decl_stmt|;
while|while
condition|(
operator|*
name|alt
condition|)
block|{
if|if
condition|(
name|advance
argument_list|(
name|compex
argument_list|,
name|p1
argument_list|,
operator|*
name|alt
operator|++
argument_list|)
condition|)
return|return
name|p1
return|;
block|}
name|p1
operator|++
expr_stmt|;
block|}
do|while
condition|(
operator|*
name|p1
operator|&&
operator|!
name|err
condition|)
do|;
if|if
condition|(
name|err
condition|)
name|err
operator|=
literal|0
expr_stmt|;
return|return
name|Nullch
return|;
block|}
comment|/*NOTREACHED*/
block|}
end_function

begin_comment
comment|/* advance the match of the regular expression starting at ep along the    string lp, simulates an NDFSA */
end_comment

begin_function
name|bool
name|advance
parameter_list|(
name|compex
parameter_list|,
name|lp
parameter_list|,
name|ep
parameter_list|)
specifier|register
name|COMPEX
modifier|*
name|compex
decl_stmt|;
specifier|register
name|char
modifier|*
name|ep
decl_stmt|;
specifier|register
name|char
modifier|*
name|lp
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|curlp
decl_stmt|;
specifier|register
name|char
modifier|*
name|trt
init|=
name|trans
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
while|while
condition|(
operator|(
operator|*
name|ep
operator|&
name|STAR
operator|)
operator|||
operator|*
name|lp
operator|||
operator|*
name|ep
operator|==
name|CIRC
operator|||
operator|*
name|ep
operator|==
name|CKET
condition|)
switch|switch
condition|(
operator|*
name|ep
operator|++
condition|)
block|{
case|case
name|CCHR
case|:
if|if
condition|(
name|trt
index|[
operator|*
name|ep
operator|++
index|]
operator|!=
name|trt
index|[
operator|*
name|lp
index|]
condition|)
return|return
name|FALSE
return|;
name|lp
operator|++
expr_stmt|;
continue|continue;
case|case
name|CDOT
case|:
if|if
condition|(
operator|*
name|lp
operator|==
literal|'\n'
condition|)
return|return
name|FALSE
return|;
name|lp
operator|++
expr_stmt|;
continue|continue;
case|case
name|CDOL
case|:
if|if
condition|(
operator|!
operator|*
name|lp
operator|||
operator|*
name|lp
operator|==
literal|'\n'
condition|)
continue|continue;
return|return
name|FALSE
return|;
case|case
name|CIRC
case|:
if|if
condition|(
name|lp
operator|==
name|FirstCharacter
operator|||
name|lp
index|[
operator|-
literal|1
index|]
operator|==
literal|'\n'
condition|)
continue|continue;
return|return
name|FALSE
return|;
case|case
name|WORD
case|:
if|if
condition|(
name|isalnum
argument_list|(
operator|*
name|lp
argument_list|)
condition|)
block|{
name|lp
operator|++
expr_stmt|;
continue|continue;
block|}
return|return
name|FALSE
return|;
case|case
name|NWORD
case|:
if|if
condition|(
operator|!
name|isalnum
argument_list|(
operator|*
name|lp
argument_list|)
condition|)
block|{
name|lp
operator|++
expr_stmt|;
continue|continue;
block|}
return|return
name|FALSE
return|;
case|case
name|WBOUND
case|:
if|if
condition|(
operator|(
name|lp
operator|==
name|FirstCharacter
operator|||
operator|!
name|isalnum
argument_list|(
name|lp
index|[
operator|-
literal|1
index|]
argument_list|)
operator|)
operator|!=
operator|(
operator|!
operator|*
name|lp
operator|||
operator|!
name|isalnum
argument_list|(
operator|*
name|lp
argument_list|)
operator|)
condition|)
continue|continue;
return|return
name|FALSE
return|;
case|case
name|NWBOUND
case|:
if|if
condition|(
operator|(
name|lp
operator|==
name|FirstCharacter
operator|||
operator|!
name|isalnum
argument_list|(
name|lp
index|[
operator|-
literal|1
index|]
argument_list|)
operator|)
operator|==
operator|(
operator|!
operator|*
name|lp
operator|||
operator|!
name|isalnum
argument_list|(
operator|*
name|lp
argument_list|)
operator|)
condition|)
continue|continue;
return|return
name|FALSE
return|;
case|case
name|CEND
case|:
return|return
name|TRUE
return|;
case|case
name|CCL
case|:
if|if
condition|(
name|cclass
argument_list|(
name|ep
argument_list|,
operator|*
name|lp
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|ep
operator|+=
name|BMAPSIZ
expr_stmt|;
name|lp
operator|++
expr_stmt|;
continue|continue;
block|}
return|return
name|FALSE
return|;
case|case
name|NCCL
case|:
if|if
condition|(
name|cclass
argument_list|(
name|ep
argument_list|,
operator|*
name|lp
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|ep
operator|+=
name|BMAPSIZ
expr_stmt|;
name|lp
operator|++
expr_stmt|;
continue|continue;
block|}
return|return
name|FALSE
return|;
case|case
name|CBRA
case|:
name|compex
operator|->
name|braslist
index|[
operator|*
name|ep
operator|++
index|]
operator|=
name|lp
expr_stmt|;
continue|continue;
case|case
name|CKET
case|:
name|i
operator|=
operator|*
name|ep
operator|++
expr_stmt|;
name|compex
operator|->
name|braelist
index|[
name|i
index|]
operator|=
name|lp
expr_stmt|;
name|compex
operator|->
name|braelist
index|[
literal|0
index|]
operator|=
name|lp
expr_stmt|;
name|compex
operator|->
name|braslist
index|[
literal|0
index|]
operator|=
name|compex
operator|->
name|braslist
index|[
name|i
index|]
expr_stmt|;
continue|continue;
case|case
name|CBACK
case|:
if|if
condition|(
name|compex
operator|->
name|braelist
index|[
name|i
operator|=
operator|*
name|ep
operator|++
index|]
operator|==
literal|0
condition|)
block|{
name|fputs
argument_list|(
literal|"bad braces\n"
argument_list|,
argument|stdout
argument_list|)
name|FLUSH
expr_stmt|;
name|err
operator|=
name|TRUE
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|backref
argument_list|(
name|compex
argument_list|,
name|i
argument_list|,
name|lp
argument_list|)
condition|)
block|{
name|lp
operator|+=
name|compex
operator|->
name|braelist
index|[
name|i
index|]
operator|-
name|compex
operator|->
name|braslist
index|[
name|i
index|]
expr_stmt|;
continue|continue;
block|}
return|return
name|FALSE
return|;
case|case
name|CBACK
operator||
name|STAR
case|:
if|if
condition|(
name|compex
operator|->
name|braelist
index|[
name|i
operator|=
operator|*
name|ep
operator|++
index|]
operator|==
literal|0
condition|)
block|{
name|fputs
argument_list|(
literal|"bad braces\n"
argument_list|,
argument|stdout
argument_list|)
name|FLUSH
expr_stmt|;
name|err
operator|=
name|TRUE
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|curlp
operator|=
name|lp
expr_stmt|;
while|while
condition|(
name|backref
argument_list|(
name|compex
argument_list|,
name|i
argument_list|,
name|lp
argument_list|)
condition|)
block|{
name|lp
operator|+=
name|compex
operator|->
name|braelist
index|[
name|i
index|]
operator|-
name|compex
operator|->
name|braslist
index|[
name|i
index|]
expr_stmt|;
block|}
while|while
condition|(
name|lp
operator|>=
name|curlp
condition|)
block|{
if|if
condition|(
name|advance
argument_list|(
name|compex
argument_list|,
name|lp
argument_list|,
name|ep
argument_list|)
condition|)
return|return
name|TRUE
return|;
name|lp
operator|-=
name|compex
operator|->
name|braelist
index|[
name|i
index|]
operator|-
name|compex
operator|->
name|braslist
index|[
name|i
index|]
expr_stmt|;
block|}
continue|continue;
case|case
name|CDOT
operator||
name|STAR
case|:
name|curlp
operator|=
name|lp
expr_stmt|;
while|while
condition|(
operator|*
name|lp
operator|++
operator|&&
name|lp
index|[
operator|-
literal|1
index|]
operator|!=
literal|'\n'
condition|)
empty_stmt|;
goto|goto
name|star
goto|;
case|case
name|WORD
operator||
name|STAR
case|:
name|curlp
operator|=
name|lp
expr_stmt|;
while|while
condition|(
operator|*
name|lp
operator|++
operator|&&
name|isalnum
argument_list|(
name|lp
index|[
operator|-
literal|1
index|]
argument_list|)
condition|)
empty_stmt|;
goto|goto
name|star
goto|;
case|case
name|NWORD
operator||
name|STAR
case|:
name|curlp
operator|=
name|lp
expr_stmt|;
while|while
condition|(
operator|*
name|lp
operator|++
operator|&&
operator|!
name|isalnum
argument_list|(
name|lp
index|[
operator|-
literal|1
index|]
argument_list|)
condition|)
empty_stmt|;
goto|goto
name|star
goto|;
case|case
name|CCHR
operator||
name|STAR
case|:
name|curlp
operator|=
name|lp
expr_stmt|;
while|while
condition|(
operator|*
name|lp
operator|++
operator|&&
name|trt
index|[
name|lp
index|[
operator|-
literal|1
index|]
index|]
operator|==
name|trt
index|[
operator|*
name|ep
index|]
condition|)
empty_stmt|;
name|ep
operator|++
expr_stmt|;
goto|goto
name|star
goto|;
case|case
name|CCL
operator||
name|STAR
case|:
case|case
name|NCCL
operator||
name|STAR
case|:
name|curlp
operator|=
name|lp
expr_stmt|;
while|while
condition|(
operator|*
name|lp
operator|++
operator|&&
name|cclass
argument_list|(
name|ep
argument_list|,
name|lp
index|[
operator|-
literal|1
index|]
argument_list|,
name|ep
index|[
operator|-
literal|1
index|]
operator|==
operator|(
name|CCL
operator||
name|STAR
operator|)
argument_list|)
condition|)
empty_stmt|;
name|ep
operator|+=
name|BMAPSIZ
expr_stmt|;
goto|goto
name|star
goto|;
name|star
label|:
do|do
block|{
name|lp
operator|--
expr_stmt|;
if|if
condition|(
name|advance
argument_list|(
name|compex
argument_list|,
name|lp
argument_list|,
name|ep
argument_list|)
condition|)
return|return
name|TRUE
return|;
block|}
do|while
condition|(
name|lp
operator|>
name|curlp
condition|)
do|;
return|return
name|FALSE
return|;
default|default:
name|fputs
argument_list|(
literal|"Badly compiled pattern\n"
argument_list|,
argument|stdout
argument_list|)
name|FLUSH
expr_stmt|;
name|err
operator|=
name|TRUE
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
operator|*
name|ep
operator|==
name|CEND
operator|||
operator|*
name|ep
operator|==
name|CDOL
operator|||
operator|*
name|ep
operator|==
name|WBOUND
condition|)
block|{
return|return
name|TRUE
return|;
block|}
return|return
name|FALSE
return|;
block|}
end_function

begin_function
name|bool
name|backref
parameter_list|(
name|compex
parameter_list|,
name|i
parameter_list|,
name|lp
parameter_list|)
specifier|register
name|COMPEX
modifier|*
name|compex
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|char
modifier|*
name|lp
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|bp
decl_stmt|;
name|bp
operator|=
name|compex
operator|->
name|braslist
index|[
name|i
index|]
expr_stmt|;
while|while
condition|(
operator|*
name|lp
operator|&&
operator|*
name|bp
operator|==
operator|*
name|lp
condition|)
block|{
name|bp
operator|++
expr_stmt|;
name|lp
operator|++
expr_stmt|;
if|if
condition|(
name|bp
operator|>=
name|compex
operator|->
name|braelist
index|[
name|i
index|]
condition|)
return|return
name|TRUE
return|;
block|}
return|return
name|FALSE
return|;
block|}
end_function

begin_function
name|bool
name|cclass
parameter_list|(
name|set
parameter_list|,
name|c
parameter_list|,
name|af
parameter_list|)
specifier|register
name|char
modifier|*
name|set
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
name|int
name|af
decl_stmt|;
block|{
name|c
operator|&=
literal|0177
expr_stmt|;
if|#
directive|if
name|BITSPERBYTE
operator|==
literal|8
if|if
condition|(
name|set
index|[
name|c
operator|>>
literal|3
index|]
operator|&
literal|1
operator|<<
operator|(
name|c
operator|&
literal|7
operator|)
condition|)
else|#
directive|else
if|if
condition|(
name|set
index|[
name|c
operator|/
name|BITSPERBYTE
index|]
operator|&
literal|1
operator|<<
operator|(
name|c
operator|%
name|BITSPERBYTE
operator|)
condition|)
endif|#
directive|endif
return|return
name|af
return|;
return|return
operator|!
name|af
return|;
block|}
end_function

end_unit

