begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* $Id: hash.c,v 3.0 1992/12/14 00:14:13 davison Trn $ */
end_comment

begin_comment
comment|/* This file is an altered version of a set of hash routines by ** Geoffrey Collyer.  See the end of the file for his copyright. */
end_comment

begin_include
include|#
directive|include
file|"EXTERN.h"
end_include

begin_include
include|#
directive|include
file|"common.h"
end_include

begin_include
include|#
directive|include
file|"util.h"
end_include

begin_include
include|#
directive|include
file|"INTERN.h"
end_include

begin_include
include|#
directive|include
file|"hash.h"
end_include

begin_comment
comment|/* tunable parameters */
end_comment

begin_define
define|#
directive|define
name|RETAIN
value|600
end_define

begin_comment
comment|/* retain& recycle this many HASHENTs */
end_comment

begin_decl_stmt
specifier|static
name|HASHENT
modifier|*
name|hereuse
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|reusables
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|HASHENT
modifier|*
modifier|*
name|hashfind
name|_
argument_list|(
operator|(
name|HASHTABLE
operator|*
operator|,
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|hash
name|_
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|default_cmp
name|_
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|,
name|HASHDATUM
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|HASHENT
modifier|*
name|healloc
name|_
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|hefree
name|_
argument_list|(
operator|(
name|HASHENT
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|HASHTABLE
modifier|*
name|hashcreate
argument_list|(
name|size
argument_list|,
name|cmpfunc
argument_list|)
name|unsigned
name|size
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* a crude guide to size */
end_comment

begin_function_decl
name|int
function_decl|(
modifier|*
name|cmpfunc
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_block
block|{
specifier|register
name|HASHTABLE
modifier|*
name|tbl
decl_stmt|;
comment|/* allocate HASHTABLE and (HASHENT*) array together to reduce the     ** number of malloc calls. */
specifier|register
struct|struct
name|alignalloc
block|{
name|HASHTABLE
name|ht
decl_stmt|;
name|HASHENT
modifier|*
name|hepa
index|[
literal|1
index|]
decl_stmt|;
comment|/* longer than it looks */
block|}
modifier|*
name|aap
struct|;
name|aap
operator|=
operator|(
expr|struct
name|alignalloc
operator|*
operator|)
name|safemalloc
argument_list|(
sizeof|sizeof
expr|*
name|aap
operator|+
operator|(
name|size
operator|-
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|HASHENT
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|aap
argument_list|,
sizeof|sizeof
expr|*
name|aap
operator|+
operator|(
name|size
operator|-
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|HASHENT
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|tbl
operator|=
operator|&
name|aap
operator|->
name|ht
expr_stmt|;
name|tbl
operator|->
name|ht_size
operator|=
operator|(
name|size
operator|==
literal|0
condition|?
literal|1
else|:
name|size
operator|)
expr_stmt|;
comment|/* size of 0 is nonsense */
name|tbl
operator|->
name|ht_magic
operator|=
name|HASHMAG
expr_stmt|;
name|tbl
operator|->
name|ht_cmp
operator|=
operator|(
name|cmpfunc
operator|==
name|NULL
condition|?
name|default_cmp
else|:
name|cmpfunc
operator|)
expr_stmt|;
name|tbl
operator|->
name|ht_addr
operator|=
name|aap
operator|->
name|hepa
expr_stmt|;
return|return
name|tbl
return|;
block|}
end_block

begin_comment
comment|/* Free all the memory associated with tbl, erase the pointers to it, and ** invalidate tbl to prevent further use via other pointers to it. */
end_comment

begin_function
name|void
name|hashdestroy
parameter_list|(
name|tbl
parameter_list|)
specifier|register
name|HASHTABLE
modifier|*
name|tbl
decl_stmt|;
block|{
specifier|register
name|unsigned
name|idx
decl_stmt|;
specifier|register
name|HASHENT
modifier|*
name|hp
decl_stmt|,
modifier|*
name|next
decl_stmt|;
specifier|register
name|HASHENT
modifier|*
modifier|*
name|hepp
decl_stmt|;
specifier|register
name|int
name|tblsize
decl_stmt|;
if|if
condition|(
name|tbl
operator|==
name|NULL
operator|||
name|BADTBL
argument_list|(
name|tbl
argument_list|)
condition|)
return|return;
name|tblsize
operator|=
name|tbl
operator|->
name|ht_size
expr_stmt|;
name|hepp
operator|=
name|tbl
operator|->
name|ht_addr
expr_stmt|;
for|for
control|(
name|idx
operator|=
literal|0
init|;
name|idx
operator|<
name|tblsize
condition|;
name|idx
operator|++
control|)
block|{
for|for
control|(
name|hp
operator|=
name|hepp
index|[
name|idx
index|]
init|;
name|hp
operator|!=
name|NULL
condition|;
name|hp
operator|=
name|next
control|)
block|{
name|next
operator|=
name|hp
operator|->
name|he_next
expr_stmt|;
name|hp
operator|->
name|he_next
operator|=
name|NULL
expr_stmt|;
name|hefree
argument_list|(
name|hp
argument_list|)
expr_stmt|;
block|}
name|hepp
index|[
name|idx
index|]
operator|=
name|NULL
expr_stmt|;
block|}
name|tbl
operator|->
name|ht_magic
operator|=
literal|0
expr_stmt|;
comment|/* de-certify this table */
name|tbl
operator|->
name|ht_addr
operator|=
name|NULL
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|tbl
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|hashstore
parameter_list|(
name|tbl
parameter_list|,
name|key
parameter_list|,
name|keylen
parameter_list|,
name|data
parameter_list|)
specifier|register
name|HASHTABLE
modifier|*
name|tbl
decl_stmt|;
name|char
modifier|*
name|key
decl_stmt|;
name|int
name|keylen
decl_stmt|;
name|HASHDATUM
name|data
decl_stmt|;
block|{
specifier|register
name|HASHENT
modifier|*
name|hp
decl_stmt|;
specifier|register
name|HASHENT
modifier|*
modifier|*
name|nextp
decl_stmt|;
name|nextp
operator|=
name|hashfind
argument_list|(
name|tbl
argument_list|,
name|key
argument_list|,
name|keylen
argument_list|)
expr_stmt|;
name|hp
operator|=
operator|*
name|nextp
expr_stmt|;
if|if
condition|(
name|hp
operator|==
name|NULL
condition|)
block|{
comment|/* absent; allocate an entry */
name|hp
operator|=
name|healloc
argument_list|()
expr_stmt|;
name|hp
operator|->
name|he_next
operator|=
name|NULL
expr_stmt|;
name|hp
operator|->
name|he_keylen
operator|=
name|keylen
expr_stmt|;
operator|*
name|nextp
operator|=
name|hp
expr_stmt|;
comment|/* append to hash chain */
block|}
name|hp
operator|->
name|he_data
operator|=
name|data
expr_stmt|;
comment|/* supersede any old data for this key */
block|}
end_function

begin_function
name|void
name|hashdelete
parameter_list|(
name|tbl
parameter_list|,
name|key
parameter_list|,
name|keylen
parameter_list|)
specifier|register
name|HASHTABLE
modifier|*
name|tbl
decl_stmt|;
name|char
modifier|*
name|key
decl_stmt|;
name|int
name|keylen
decl_stmt|;
block|{
specifier|register
name|HASHENT
modifier|*
name|hp
decl_stmt|;
specifier|register
name|HASHENT
modifier|*
modifier|*
name|nextp
decl_stmt|;
name|nextp
operator|=
name|hashfind
argument_list|(
name|tbl
argument_list|,
name|key
argument_list|,
name|keylen
argument_list|)
expr_stmt|;
name|hp
operator|=
operator|*
name|nextp
expr_stmt|;
if|if
condition|(
name|hp
operator|==
name|NULL
condition|)
comment|/* absent */
return|return;
operator|*
name|nextp
operator|=
name|hp
operator|->
name|he_next
expr_stmt|;
comment|/* skip this entry */
name|hp
operator|->
name|he_next
operator|=
name|NULL
expr_stmt|;
name|hp
operator|->
name|he_data
operator|.
name|dat_ptr
operator|=
name|NULL
expr_stmt|;
name|hefree
argument_list|(
name|hp
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
name|HASHENT
modifier|*
modifier|*
name|slast_nextp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|slast_keylen
decl_stmt|;
end_decl_stmt

begin_function
name|HASHDATUM
comment|/* data corresponding to key */
name|hashfetch
parameter_list|(
name|tbl
parameter_list|,
name|key
parameter_list|,
name|keylen
parameter_list|)
specifier|register
name|HASHTABLE
modifier|*
name|tbl
decl_stmt|;
name|char
modifier|*
name|key
decl_stmt|;
name|int
name|keylen
decl_stmt|;
block|{
specifier|register
name|HASHENT
modifier|*
name|hp
decl_stmt|;
specifier|register
name|HASHENT
modifier|*
modifier|*
name|nextp
decl_stmt|;
specifier|static
name|HASHDATUM
name|errdatum
init|=
block|{
name|NULL
block|,
literal|0
block|}
decl_stmt|;
name|nextp
operator|=
name|hashfind
argument_list|(
name|tbl
argument_list|,
name|key
argument_list|,
name|keylen
argument_list|)
expr_stmt|;
name|slast_nextp
operator|=
name|nextp
expr_stmt|;
name|slast_keylen
operator|=
name|keylen
expr_stmt|;
name|hp
operator|=
operator|*
name|nextp
expr_stmt|;
if|if
condition|(
name|hp
operator|==
name|NULL
condition|)
comment|/* absent */
return|return
name|errdatum
return|;
else|else
return|return
name|hp
operator|->
name|he_data
return|;
block|}
end_function

begin_function
name|void
name|hashstorelast
parameter_list|(
name|data
parameter_list|)
name|HASHDATUM
name|data
decl_stmt|;
block|{
specifier|register
name|HASHENT
modifier|*
name|hp
decl_stmt|;
name|hp
operator|=
operator|*
name|slast_nextp
expr_stmt|;
if|if
condition|(
name|hp
operator|==
name|NULL
condition|)
block|{
comment|/* absent; allocate an entry */
name|hp
operator|=
name|healloc
argument_list|()
expr_stmt|;
name|hp
operator|->
name|he_next
operator|=
name|NULL
expr_stmt|;
name|hp
operator|->
name|he_keylen
operator|=
name|slast_keylen
expr_stmt|;
operator|*
name|slast_nextp
operator|=
name|hp
expr_stmt|;
comment|/* append to hash chain */
block|}
name|hp
operator|->
name|he_data
operator|=
name|data
expr_stmt|;
comment|/* supersede any old data for this key */
block|}
end_function

begin_comment
comment|/* Visit each entry by calling nodefunc at each, with key, data and extra as ** arguments. */
end_comment

begin_decl_stmt
name|void
name|hashwalk
argument_list|(
name|tbl
argument_list|,
name|nodefunc
argument_list|,
name|extra
argument_list|)
name|HASHTABLE
modifier|*
name|tbl
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|register
name|void
function_decl|(
modifier|*
name|nodefunc
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|register
name|int
name|extra
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|unsigned
name|idx
decl_stmt|;
specifier|register
name|HASHENT
modifier|*
name|hp
decl_stmt|;
specifier|register
name|HASHENT
modifier|*
modifier|*
name|hepp
decl_stmt|;
specifier|register
name|int
name|tblsize
decl_stmt|;
if|if
condition|(
name|BADTBL
argument_list|(
name|tbl
argument_list|)
condition|)
return|return;
name|hepp
operator|=
name|tbl
operator|->
name|ht_addr
expr_stmt|;
name|tblsize
operator|=
name|tbl
operator|->
name|ht_size
expr_stmt|;
for|for
control|(
name|idx
operator|=
literal|0
init|;
name|idx
operator|<
name|tblsize
condition|;
name|idx
operator|++
control|)
for|for
control|(
name|hp
operator|=
name|hepp
index|[
name|idx
index|]
init|;
name|hp
operator|!=
name|NULL
condition|;
name|hp
operator|=
name|hp
operator|->
name|he_next
control|)
call|(
modifier|*
name|nodefunc
call|)
argument_list|(
operator|&
name|hp
operator|->
name|he_data
argument_list|,
name|extra
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* The returned value is the address of the pointer that refers to the ** found object.  Said pointer may be NULL if the object was not found; ** if so, this pointer should be updated with the address of the object ** to be inserted, if insertion is desired. */
end_comment

begin_function
specifier|static
name|HASHENT
modifier|*
modifier|*
name|hashfind
parameter_list|(
name|tbl
parameter_list|,
name|key
parameter_list|,
name|keylen
parameter_list|)
specifier|register
name|HASHTABLE
modifier|*
name|tbl
decl_stmt|;
name|char
modifier|*
name|key
decl_stmt|;
specifier|register
name|int
name|keylen
decl_stmt|;
block|{
specifier|register
name|HASHENT
modifier|*
name|hp
decl_stmt|,
modifier|*
name|prevhp
init|=
name|NULL
decl_stmt|;
specifier|register
name|HASHENT
modifier|*
modifier|*
name|hepp
decl_stmt|;
specifier|register
name|unsigned
name|size
decl_stmt|;
if|if
condition|(
name|BADTBL
argument_list|(
name|tbl
argument_list|)
condition|)
name|fatal_error
argument_list|(
literal|"Hash table is invalid."
argument_list|)
expr_stmt|;
name|size
operator|=
name|tbl
operator|->
name|ht_size
expr_stmt|;
name|hepp
operator|=
operator|&
name|tbl
operator|->
name|ht_addr
index|[
name|hash
argument_list|(
name|key
argument_list|,
name|keylen
argument_list|)
operator|%
name|size
index|]
expr_stmt|;
for|for
control|(
name|hp
operator|=
operator|*
name|hepp
init|;
name|hp
operator|!=
name|NULL
condition|;
name|prevhp
operator|=
name|hp
operator|,
name|hp
operator|=
name|hp
operator|->
name|he_next
control|)
block|{
if|if
condition|(
name|hp
operator|->
name|he_keylen
operator|==
name|keylen
operator|&&
operator|!
call|(
modifier|*
name|tbl
operator|->
name|ht_cmp
call|)
argument_list|(
name|key
argument_list|,
name|keylen
argument_list|,
name|hp
operator|->
name|he_data
argument_list|)
condition|)
break|break;
block|}
comment|/* assert: *(returned value) == hp */
return|return
operator|(
name|prevhp
operator|==
name|NULL
condition|?
name|hepp
else|:
operator|&
name|prevhp
operator|->
name|he_next
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|unsigned
comment|/* not yet taken modulus table size */
name|hash
parameter_list|(
name|key
parameter_list|,
name|keylen
parameter_list|)
specifier|register
name|char
modifier|*
name|key
decl_stmt|;
specifier|register
name|int
name|keylen
decl_stmt|;
block|{
specifier|register
name|unsigned
name|hash
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|keylen
operator|--
condition|)
name|hash
operator|+=
operator|*
name|key
operator|++
expr_stmt|;
return|return
name|hash
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|default_cmp
parameter_list|(
name|key
parameter_list|,
name|keylen
parameter_list|,
name|data
parameter_list|)
name|char
modifier|*
name|key
decl_stmt|;
name|int
name|keylen
decl_stmt|;
name|HASHDATUM
name|data
decl_stmt|;
block|{
comment|/* We already know that the lengths are equal, just compare the strings */
return|return
name|bcmp
argument_list|(
name|key
argument_list|,
name|data
operator|.
name|dat_ptr
argument_list|,
name|keylen
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|HASHENT
modifier|*
name|healloc
parameter_list|()
comment|/* allocate a hash entry */
block|{
specifier|register
name|HASHENT
modifier|*
name|hp
decl_stmt|;
if|if
condition|(
name|hereuse
operator|==
name|NULL
condition|)
return|return
operator|(
name|HASHENT
operator|*
operator|)
name|safemalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|HASHENT
argument_list|)
argument_list|)
return|;
comment|/* pull the first reusable one off the pile */
name|hp
operator|=
name|hereuse
expr_stmt|;
name|hereuse
operator|=
name|hereuse
operator|->
name|he_next
expr_stmt|;
name|hp
operator|->
name|he_next
operator|=
name|NULL
expr_stmt|;
comment|/* prevent accidents */
name|reusables
operator|--
expr_stmt|;
return|return
name|hp
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|hefree
parameter_list|(
name|hp
parameter_list|)
comment|/* free a hash entry */
specifier|register
name|HASHENT
modifier|*
name|hp
decl_stmt|;
block|{
if|if
condition|(
name|reusables
operator|>=
name|RETAIN
condition|)
comment|/* compost heap is full? */
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|hp
argument_list|)
expr_stmt|;
comment|/* yup, just pitch this one */
else|else
block|{
comment|/* no, just stash for reuse */
operator|++
name|reusables
expr_stmt|;
name|hp
operator|->
name|he_next
operator|=
name|hereuse
expr_stmt|;
name|hereuse
operator|=
name|hp
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Copyright (c) 1992 Geoffrey Collyer  * All rights reserved.  * Written by Geoffrey Collyer.  *  * This software is not subject to any license of the American Telephone  * and Telegraph Company, the Regents of the University of California, or  * the Free Software Foundation.  *  * Permission is granted to anyone to use this software for any purpose on  * any computer system, and to alter it and redistribute it freely, subject  * to the following restrictions:  *  * 1. The author is not responsible for the consequences of use of this  *    software, no matter how awful, even if they arise from flaws in it.  *  * 2. The origin of this software must not be misrepresented, either by  *    explicit claim or by omission.  Since few users ever read sources,  *    credits must appear in the documentation.  *  * 3. Altered versions must be plainly marked as such, and must not be  *    misrepresented as being the original software.  Since few users  *    ever read sources, credits must appear in the documentation.  *  * 4. This notice may not be removed or altered.  */
end_comment

end_unit

