begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* $Id: rt-wumpus.c,v 3.0 1992/12/14 00:14:00 davison Trn $ */
end_comment

begin_include
include|#
directive|include
file|"EXTERN.h"
end_include

begin_include
include|#
directive|include
file|"common.h"
end_include

begin_include
include|#
directive|include
file|"cache.h"
end_include

begin_include
include|#
directive|include
file|"ng.h"
end_include

begin_include
include|#
directive|include
file|"head.h"
end_include

begin_include
include|#
directive|include
file|"util.h"
end_include

begin_include
include|#
directive|include
file|"term.h"
end_include

begin_include
include|#
directive|include
file|"final.h"
end_include

begin_include
include|#
directive|include
file|"ngdata.h"
end_include

begin_include
include|#
directive|include
file|"artio.h"
end_include

begin_include
include|#
directive|include
file|"backpage.h"
end_include

begin_include
include|#
directive|include
file|"rthread.h"
end_include

begin_include
include|#
directive|include
file|"rt-select.h"
end_include

begin_include
include|#
directive|include
file|"INTERN.h"
end_include

begin_include
include|#
directive|include
file|"rt-wumpus.h"
end_include

begin_decl_stmt
specifier|static
name|char
name|tree_indent
index|[]
init|=
block|{
literal|' '
block|,
literal|0
block|,
literal|' '
block|,
literal|' '
block|,
literal|' '
block|,
literal|' '
block|,
literal|0
block|,
literal|' '
block|,
literal|' '
block|,
literal|' '
block|,
literal|' '
block|,
literal|0
block|,
literal|' '
block|,
literal|' '
block|,
literal|' '
block|,
literal|' '
block|,
literal|0
block|,
literal|' '
block|,
literal|' '
block|,
literal|' '
block|,
literal|' '
block|,
literal|0
block|,
literal|' '
block|,
literal|' '
block|,
literal|' '
block|,
literal|' '
block|,
literal|0
block|,
literal|' '
block|,
literal|' '
block|,
literal|' '
block|,
literal|' '
block|,
literal|0
block|,
literal|' '
block|,
literal|' '
block|,
literal|' '
block|,
literal|' '
block|,
literal|0
block|,
literal|' '
block|,
literal|' '
block|,
literal|' '
block|,
literal|' '
block|,
literal|0
block|,
literal|' '
block|,
literal|' '
block|,
literal|' '
block|,
literal|' '
block|,
literal|0
block|,
literal|' '
block|,
literal|' '
block|,
literal|' '
block|,
literal|' '
block|,
literal|0
block|,
literal|' '
block|,
literal|' '
block|,
literal|' '
block|,
literal|' '
block|,
literal|0
block|,
literal|' '
block|,
literal|' '
block|,
literal|' '
block|,
literal|' '
block|,
literal|0
block|,
literal|' '
block|,
literal|' '
block|,
literal|' '
block|,
literal|' '
block|,
literal|0
block|,
literal|' '
block|,
literal|' '
block|,
literal|' '
block|,
literal|' '
block|,
literal|0
block|,
literal|' '
block|,
literal|' '
block|,
literal|' '
block|,
literal|' '
block|,
literal|0
block|,
literal|' '
block|,
literal|' '
block|,
literal|' '
block|,
literal|' '
block|,
literal|0
block|,
literal|' '
block|,
literal|' '
block|,
literal|' '
block|,
literal|' '
block|,
literal|0
block|,
literal|' '
block|,
literal|' '
block|,
literal|' '
block|,
literal|' '
block|,
literal|0
block|,
literal|' '
block|,
literal|' '
block|,
literal|' '
block|,
literal|' '
block|,
literal|0
block|,
literal|' '
block|,
literal|' '
block|,
literal|' '
block|,
literal|' '
block|,
literal|0
block|,
literal|' '
block|,
literal|' '
block|,
literal|' '
block|,
literal|' '
block|,
literal|0
block|,
literal|' '
block|,
literal|' '
block|,
literal|' '
block|,
literal|' '
block|,
literal|0
block|,
literal|' '
block|,
literal|' '
block|,
literal|' '
block|,
literal|' '
block|,
literal|0
block|,
literal|' '
block|,
literal|' '
block|,
literal|' '
block|,
literal|' '
block|,
literal|0
block|,
literal|' '
block|,
literal|' '
block|,
literal|' '
block|,
literal|' '
block|,
literal|0
block|,
literal|' '
block|,
literal|' '
block|,
literal|' '
block|,
literal|' '
block|,
literal|0
block|,
literal|' '
block|,
literal|' '
block|,
literal|' '
block|,
literal|' '
block|,
literal|0
block|,
literal|' '
block|,
literal|' '
block|,
literal|' '
block|,
literal|' '
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|letters
index|[]
init|=
literal|"123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz+"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ARTICLE
modifier|*
name|tree_article
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|max_depth
decl_stmt|,
name|max_line
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|first_depth
decl_stmt|,
name|first_line
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|my_depth
decl_stmt|,
name|my_line
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bool
name|node_on_line
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|node_line_cnt
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|line_num
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|header_indent
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|tree_lines
index|[
literal|11
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|tree_buff
index|[
literal|128
index|]
decl_stmt|,
modifier|*
name|str
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Prepare tree display for inclusion in the article header. */
end_comment

begin_function
name|void
name|init_tree
parameter_list|()
block|{
name|ARTICLE
modifier|*
name|thread
decl_stmt|;
name|SUBJECT
modifier|*
name|sp
decl_stmt|;
name|int
name|num
decl_stmt|;
while|while
condition|(
name|max_line
operator|>=
literal|0
condition|)
comment|/* free any previous tree data */
name|free
argument_list|(
name|tree_lines
index|[
name|max_line
operator|--
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|tree_article
operator|=
name|curr_artp
operator|)
operator|||
operator|!
name|tree_article
operator|->
name|subj
condition|)
return|return;
if|if
condition|(
operator|!
operator|(
name|thread
operator|=
name|tree_article
operator|->
name|subj
operator|->
name|thread
operator|)
condition|)
return|return;
comment|/* Enumerate our subjects for display */
name|sp
operator|=
name|thread
operator|->
name|subj
expr_stmt|;
name|num
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|sp
operator|->
name|misc
operator|=
name|num
operator|++
expr_stmt|;
name|sp
operator|=
name|sp
operator|->
name|thread_link
expr_stmt|;
block|}
do|while
condition|(
name|sp
operator|!=
name|thread
operator|->
name|subj
condition|)
do|;
name|max_depth
operator|=
name|max_line
operator|=
name|my_depth
operator|=
name|my_line
operator|=
name|node_line_cnt
operator|=
literal|0
expr_stmt|;
name|find_depth
argument_list|(
name|thread
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|max_depth
operator|<=
literal|5
condition|)
block|{
name|first_depth
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|my_depth
operator|+
literal|2
operator|>
name|max_depth
condition|)
block|{
name|first_depth
operator|=
name|max_depth
operator|-
literal|5
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|first_depth
operator|=
name|my_depth
operator|-
literal|3
operator|)
operator|<
literal|0
condition|)
block|{
name|first_depth
operator|=
literal|0
expr_stmt|;
block|}
name|max_depth
operator|=
name|first_depth
operator|+
literal|5
expr_stmt|;
block|}
if|if
condition|(
operator|--
name|max_line
operator|<
name|max_tree_lines
condition|)
block|{
name|first_line
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|my_line
operator|+
name|max_tree_lines
operator|/
literal|2
operator|>
name|max_line
condition|)
block|{
name|first_line
operator|=
name|max_line
operator|-
operator|(
name|max_tree_lines
operator|-
literal|1
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|first_line
operator|=
name|my_line
operator|-
operator|(
name|max_tree_lines
operator|-
literal|1
operator|)
operator|/
literal|2
operator|)
operator|<
literal|0
condition|)
block|{
name|first_line
operator|=
literal|0
expr_stmt|;
block|}
name|max_line
operator|=
name|first_line
operator|+
name|max_tree_lines
operator|-
literal|1
expr_stmt|;
block|}
name|str
operator|=
name|tree_buff
expr_stmt|;
comment|/* initialize first line's data */
operator|*
name|str
operator|++
operator|=
literal|' '
expr_stmt|;
name|node_on_line
operator|=
name|FALSE
expr_stmt|;
name|line_num
operator|=
literal|0
expr_stmt|;
comment|/* cache our portion of the tree */
name|cache_tree
argument_list|(
name|thread
argument_list|,
literal|0
argument_list|,
name|tree_indent
argument_list|)
expr_stmt|;
name|max_depth
operator|=
operator|(
name|max_depth
operator|-
name|first_depth
operator|)
operator|*
literal|5
expr_stmt|;
comment|/* turn depth into char width */
name|max_line
operator|-=
name|first_line
expr_stmt|;
comment|/* turn max_line into count */
comment|/* shorten tree if lower lines aren't visible */
if|if
condition|(
name|node_line_cnt
operator|<
name|max_line
condition|)
block|{
name|max_line
operator|=
name|node_line_cnt
operator|+
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* A recursive routine to find the maximum tree extents and where we are. */
end_comment

begin_function
specifier|static
name|void
name|find_depth
parameter_list|(
name|article
parameter_list|,
name|depth
parameter_list|)
name|ARTICLE
modifier|*
name|article
decl_stmt|;
name|int
name|depth
decl_stmt|;
block|{
if|if
condition|(
name|depth
operator|>
name|max_depth
condition|)
block|{
name|max_depth
operator|=
name|depth
expr_stmt|;
block|}
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|article
operator|==
name|tree_article
condition|)
block|{
name|my_depth
operator|=
name|depth
expr_stmt|;
name|my_line
operator|=
name|max_line
expr_stmt|;
block|}
if|if
condition|(
name|article
operator|->
name|child1
condition|)
block|{
name|find_depth
argument_list|(
name|article
operator|->
name|child1
argument_list|,
name|depth
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|max_line
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|article
operator|=
name|article
operator|->
name|sibling
operator|)
condition|)
block|{
break|break;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Place the tree display in a maximum of 11 lines x 6 nodes. */
end_comment

begin_function
specifier|static
name|void
name|cache_tree
parameter_list|(
name|ap
parameter_list|,
name|depth
parameter_list|,
name|cp
parameter_list|)
name|ARTICLE
modifier|*
name|ap
decl_stmt|;
name|int
name|depth
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
block|{
name|int
name|depth_mode
decl_stmt|;
name|cp
index|[
literal|1
index|]
operator|=
literal|' '
expr_stmt|;
if|if
condition|(
name|depth
operator|>=
name|first_depth
operator|&&
name|depth
operator|<=
name|max_depth
condition|)
block|{
name|cp
operator|+=
literal|5
expr_stmt|;
name|depth_mode
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|depth
operator|+
literal|1
operator|==
name|first_depth
condition|)
block|{
name|depth_mode
operator|=
literal|2
expr_stmt|;
block|}
else|else
block|{
name|cp
operator|=
name|tree_indent
expr_stmt|;
name|depth_mode
operator|=
literal|0
expr_stmt|;
block|}
for|for
control|(
init|;
condition|;
control|)
block|{
switch|switch
condition|(
name|depth_mode
condition|)
block|{
case|case
literal|1
case|:
block|{
name|char
name|ch
decl_stmt|;
operator|*
name|str
operator|++
operator|=
operator|(
operator|(
name|ap
operator|->
name|flags
operator|&
name|AF_HAS_RE
operator|)
operator|||
name|ap
operator|->
name|parent
operator|)
condition|?
literal|'-'
else|:
literal|' '
expr_stmt|;
if|if
condition|(
name|ap
operator|==
name|tree_article
condition|)
operator|*
name|str
operator|++
operator|=
literal|'*'
expr_stmt|;
if|if
condition|(
name|ap
operator|->
name|flags
operator|&
name|AF_READ
condition|)
block|{
operator|*
name|str
operator|++
operator|=
literal|'('
expr_stmt|;
name|ch
operator|=
literal|')'
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|selected_only
operator|||
operator|(
name|ap
operator|->
name|flags
operator|&
name|AF_SEL
operator|)
condition|)
block|{
operator|*
name|str
operator|++
operator|=
literal|'['
expr_stmt|;
name|ch
operator|=
literal|']'
expr_stmt|;
block|}
else|else
block|{
operator|*
name|str
operator|++
operator|=
literal|'<'
expr_stmt|;
name|ch
operator|=
literal|'>'
expr_stmt|;
block|}
if|if
condition|(
name|ap
operator|==
name|recent_artp
operator|&&
name|ap
operator|!=
name|tree_article
condition|)
operator|*
name|str
operator|++
operator|=
literal|'@'
expr_stmt|;
operator|*
name|str
operator|++
operator|=
name|letter
argument_list|(
name|ap
argument_list|)
expr_stmt|;
operator|*
name|str
operator|++
operator|=
name|ch
expr_stmt|;
if|if
condition|(
name|ap
operator|->
name|child1
condition|)
block|{
operator|*
name|str
operator|++
operator|=
operator|(
name|ap
operator|->
name|child1
operator|->
name|sibling
condition|?
literal|'+'
else|:
literal|'-'
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|ap
operator|->
name|sibling
condition|)
operator|*
name|cp
operator|=
literal|'|'
expr_stmt|;
else|else
operator|*
name|cp
operator|=
literal|' '
expr_stmt|;
name|node_on_line
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
case|case
literal|2
case|:
operator|*
name|tree_buff
operator|=
operator|(
operator|!
name|ap
operator|->
name|child1
operator|)
condition|?
literal|' '
else|:
operator|(
name|ap
operator|->
name|child1
operator|->
name|sibling
operator|)
condition|?
literal|'+'
else|:
literal|'-'
expr_stmt|;
break|break;
default|default:
break|break;
block|}
if|if
condition|(
name|ap
operator|->
name|child1
condition|)
block|{
name|cache_tree
argument_list|(
name|ap
operator|->
name|child1
argument_list|,
name|depth
operator|+
literal|1
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|cp
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|node_on_line
operator|&&
name|first_line
operator|==
name|line_num
condition|)
block|{
name|first_line
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|line_num
operator|>=
name|first_line
condition|)
block|{
if|if
condition|(
name|str
index|[
operator|-
literal|1
index|]
operator|==
literal|' '
condition|)
block|{
name|str
operator|--
expr_stmt|;
block|}
operator|*
name|str
operator|=
literal|'\0'
expr_stmt|;
name|tree_lines
index|[
name|line_num
operator|-
name|first_line
index|]
operator|=
name|safemalloc
argument_list|(
name|str
operator|-
name|tree_buff
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|tree_lines
index|[
name|line_num
operator|-
name|first_line
index|]
argument_list|,
name|tree_buff
argument_list|)
expr_stmt|;
if|if
condition|(
name|node_on_line
condition|)
block|{
name|node_line_cnt
operator|=
name|line_num
operator|-
name|first_line
expr_stmt|;
block|}
block|}
name|line_num
operator|++
expr_stmt|;
name|node_on_line
operator|=
name|FALSE
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|ap
operator|=
name|ap
operator|->
name|sibling
operator|)
operator|||
name|line_num
operator|>
name|max_line
condition|)
break|break;
if|if
condition|(
operator|!
name|ap
operator|->
name|sibling
condition|)
operator|*
name|cp
operator|=
literal|'\\'
expr_stmt|;
if|if
condition|(
operator|!
name|first_depth
condition|)
name|tree_indent
index|[
literal|5
index|]
operator|=
literal|' '
expr_stmt|;
name|strcpy
argument_list|(
name|tree_buff
argument_list|,
name|tree_indent
operator|+
literal|5
argument_list|)
expr_stmt|;
name|str
operator|=
name|tree_buff
operator|+
name|strlen
argument_list|(
name|tree_buff
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Output a header line with possible tree display on the right hand side. ** Does automatic wrapping of lines that are too long. */
end_comment

begin_function
name|int
name|tree_puts
parameter_list|(
name|orig_line
parameter_list|,
name|header_line
parameter_list|,
name|use_underline
parameter_list|)
name|char
modifier|*
name|orig_line
decl_stmt|;
name|ART_LINE
name|header_line
decl_stmt|;
name|int
name|use_underline
decl_stmt|;
block|{
name|char
modifier|*
name|buf
decl_stmt|;
specifier|register
name|char
modifier|*
name|line
decl_stmt|,
modifier|*
name|cp
decl_stmt|,
modifier|*
name|end
decl_stmt|;
name|int
name|pad_cnt
decl_stmt|,
name|wrap_at
decl_stmt|;
name|ART_LINE
name|start_line
init|=
name|header_line
decl_stmt|;
name|int
name|i
decl_stmt|;
name|char
name|ch
decl_stmt|;
comment|/* Make a modifiable copy of the line */
name|buf
operator|=
name|safemalloc
argument_list|(
name|strlen
argument_list|(
name|orig_line
argument_list|)
operator|+
literal|2
argument_list|)
expr_stmt|;
comment|/* yes, I mean "2" */
name|strcpy
argument_list|(
name|buf
argument_list|,
name|orig_line
argument_list|)
expr_stmt|;
name|line
operator|=
name|buf
expr_stmt|;
comment|/* Change any embedded control characters to spaces */
for|for
control|(
name|end
operator|=
name|line
init|;
operator|*
name|end
operator|&&
operator|*
name|end
operator|!=
literal|'\n'
condition|;
name|end
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|end
operator|<
literal|' '
condition|)
block|{
operator|*
name|end
operator|=
literal|' '
expr_stmt|;
block|}
block|}
operator|*
name|end
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|line
condition|)
block|{
name|strcpy
argument_list|(
name|line
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
name|end
operator|=
name|line
operator|+
literal|1
expr_stmt|;
block|}
comment|/* If this is the first subject line, output it with a preceeding [1] */
if|if
condition|(
name|ThreadedGroup
operator|&&
name|use_underline
operator|&&
operator|(
name|unsigned
name|char
operator|)
operator|*
name|line
operator|>
literal|' '
condition|)
block|{
ifdef|#
directive|ifdef
name|NOFIREWORKS
name|no_sofire
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|standout
argument_list|()
expr_stmt|;
name|putchar
argument_list|(
literal|'['
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
name|letter
argument_list|(
name|curr_artp
argument_list|)
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|']'
argument_list|)
expr_stmt|;
name|un_standout
argument_list|()
expr_stmt|;
name|putchar
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|header_indent
operator|=
literal|4
expr_stmt|;
name|line
operator|+=
literal|9
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|*
name|line
operator|!=
literal|' '
condition|)
block|{
comment|/* A "normal" header line -- output keyword and set header_indent 	    ** _except_ for the first line, which is a non-standard header. 	    */
if|if
condition|(
operator|!
name|header_line
operator|||
operator|!
operator|(
name|cp
operator|=
name|index
argument_list|(
name|line
argument_list|,
literal|':'
argument_list|)
operator|)
operator|||
operator|*
operator|++
name|cp
operator|!=
literal|' '
condition|)
block|{
name|header_indent
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
name|fputs
argument_list|(
name|line
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|header_indent
operator|=
operator|++
name|cp
operator|-
name|line
expr_stmt|;
name|line
operator|=
name|cp
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|line
condition|)
block|{
operator|*
operator|--
name|line
operator|=
literal|' '
expr_stmt|;
block|}
block|}
name|i
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* Skip whitespace of continuation lines and prepare to indent */
while|while
condition|(
operator|*
operator|++
name|line
operator|==
literal|' '
condition|)
block|{
empty_stmt|;
block|}
name|i
operator|=
name|header_indent
expr_stmt|;
block|}
block|}
for|for
control|(
init|;
operator|*
name|line
condition|;
name|i
operator|=
name|header_indent
control|)
block|{
ifdef|#
directive|ifdef
name|CLEAREOL
name|maybe_eol
argument_list|()
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|i
condition|)
block|{
name|putchar
argument_list|(
literal|'+'
argument_list|)
expr_stmt|;
while|while
condition|(
operator|--
name|i
condition|)
block|{
name|putchar
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* If no (more) tree lines, wrap at COLS-1 */
if|if
condition|(
name|max_line
operator|<
literal|0
operator|||
name|header_line
operator|>
name|max_line
operator|+
literal|1
condition|)
block|{
name|wrap_at
operator|=
name|COLS
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|wrap_at
operator|=
name|COLS
operator|-
name|max_depth
operator|-
literal|5
operator|-
literal|3
expr_stmt|;
block|}
comment|/* Figure padding between header and tree output, wrapping long lines */
name|pad_cnt
operator|=
name|wrap_at
operator|-
operator|(
name|end
operator|-
name|line
operator|+
name|header_indent
operator|)
expr_stmt|;
if|if
condition|(
name|pad_cnt
operator|<=
literal|0
condition|)
block|{
name|cp
operator|=
name|line
operator|+
name|wrap_at
operator|-
name|header_indent
operator|-
literal|1
expr_stmt|;
name|pad_cnt
operator|=
literal|1
expr_stmt|;
while|while
condition|(
name|cp
operator|>
name|line
operator|&&
operator|*
name|cp
operator|!=
literal|' '
condition|)
block|{
if|if
condition|(
operator|*
operator|--
name|cp
operator|==
literal|','
operator|||
operator|*
name|cp
operator|==
literal|'.'
operator|||
operator|*
name|cp
operator|==
literal|'-'
operator|||
operator|*
name|cp
operator|==
literal|'!'
condition|)
block|{
name|cp
operator|++
expr_stmt|;
break|break;
block|}
name|pad_cnt
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|cp
operator|==
name|line
condition|)
block|{
name|cp
operator|+=
name|wrap_at
operator|-
name|header_indent
expr_stmt|;
name|pad_cnt
operator|=
literal|0
expr_stmt|;
block|}
name|ch
operator|=
operator|*
name|cp
expr_stmt|;
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
comment|/* keep rn's backpager happy */
name|vwtary
argument_list|(
name|artline
argument_list|,
name|vrdary
argument_list|(
name|artline
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|artline
operator|++
expr_stmt|;
block|}
else|else
block|{
name|cp
operator|=
name|end
expr_stmt|;
name|ch
operator|=
literal|'\0'
expr_stmt|;
block|}
if|if
condition|(
name|use_underline
condition|)
block|{
name|underprint
argument_list|(
name|line
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fputs
argument_list|(
name|line
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
block|}
operator|*
name|cp
operator|=
name|ch
expr_stmt|;
comment|/* Skip whitespace in wrapped line */
while|while
condition|(
operator|*
name|cp
operator|==
literal|' '
condition|)
block|{
name|cp
operator|++
expr_stmt|;
block|}
name|line
operator|=
name|cp
expr_stmt|;
comment|/* Check if we've got any tree lines to output */
if|if
condition|(
name|wrap_at
operator|!=
name|COLS
operator|-
literal|1
operator|&&
name|header_line
operator|<=
name|max_line
condition|)
block|{
name|char
modifier|*
name|cp1
decl_stmt|,
modifier|*
name|cp2
decl_stmt|;
do|do
block|{
name|putchar
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|pad_cnt
operator|--
condition|)
do|;
comment|/* Check string for the '*' flagging our current node 	    ** and the '@' flagging our prior node. 	    */
name|cp
operator|=
name|tree_lines
index|[
name|header_line
index|]
expr_stmt|;
name|cp1
operator|=
name|index
argument_list|(
name|cp
argument_list|,
literal|'*'
argument_list|)
expr_stmt|;
name|cp2
operator|=
name|index
argument_list|(
name|cp
argument_list|,
literal|'@'
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp1
operator|!=
name|Nullch
condition|)
block|{
operator|*
name|cp1
operator|=
literal|'\0'
expr_stmt|;
block|}
if|if
condition|(
name|cp2
operator|!=
name|Nullch
condition|)
block|{
operator|*
name|cp2
operator|=
literal|'\0'
expr_stmt|;
block|}
name|fputs
argument_list|(
name|cp
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
comment|/* Handle standout output for '*' and '@' marked nodes, then 	    ** continue with the rest of the line. 	    */
while|while
condition|(
name|cp1
operator|||
name|cp2
condition|)
block|{
name|standout
argument_list|()
expr_stmt|;
if|if
condition|(
name|cp1
operator|&&
operator|(
operator|!
name|cp2
operator|||
name|cp1
operator|<
name|cp2
operator|)
condition|)
block|{
name|cp
operator|=
name|cp1
expr_stmt|;
name|cp1
operator|=
name|Nullch
expr_stmt|;
operator|*
name|cp
operator|++
operator|=
literal|'*'
expr_stmt|;
name|putchar
argument_list|(
operator|*
name|cp
operator|++
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
operator|*
name|cp
operator|++
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|cp
operator|=
name|cp2
expr_stmt|;
name|cp2
operator|=
name|Nullch
expr_stmt|;
operator|*
name|cp
operator|++
operator|=
literal|'@'
expr_stmt|;
block|}
name|putchar
argument_list|(
operator|*
name|cp
operator|++
argument_list|)
expr_stmt|;
name|un_standout
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|cp
condition|)
block|{
name|fputs
argument_list|(
name|cp
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* while */
block|}
comment|/* if */
name|putchar
argument_list|(
literal|'\n'
argument_list|)
name|FLUSH
expr_stmt|;
name|header_line
operator|++
expr_stmt|;
block|}
comment|/* for remainder of line */
comment|/* free allocated copy of line */
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
comment|/* return number of lines displayed */
return|return
name|header_line
operator|-
name|start_line
return|;
block|}
end_function

begin_comment
comment|/* Output any parts of the tree that are left to display.  Called at the ** end of each header. */
end_comment

begin_function
name|int
name|finish_tree
parameter_list|(
name|last_line
parameter_list|)
name|ART_LINE
name|last_line
decl_stmt|;
block|{
name|ART_LINE
name|start_line
init|=
name|last_line
decl_stmt|;
while|while
condition|(
name|last_line
operator|<=
name|max_line
condition|)
block|{
name|artline
operator|++
expr_stmt|;
name|last_line
operator|+=
name|tree_puts
argument_list|(
literal|"+"
argument_list|,
name|last_line
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|vwtary
argument_list|(
name|artline
argument_list|,
name|artpos
argument_list|)
expr_stmt|;
comment|/* keep rn's backpager happy */
block|}
return|return
name|last_line
operator|-
name|start_line
return|;
block|}
end_function

begin_comment
comment|/* Output the entire article tree for the user. */
end_comment

begin_function
name|void
name|entire_tree
parameter_list|(
name|ap
parameter_list|)
name|ARTICLE
modifier|*
name|ap
decl_stmt|;
block|{
name|ARTICLE
modifier|*
name|thread
decl_stmt|;
name|SUBJECT
modifier|*
name|sp
decl_stmt|;
name|int
name|num
decl_stmt|;
if|if
condition|(
operator|!
name|ap
condition|)
block|{
ifdef|#
directive|ifdef
name|VERBOSE
name|IF
argument_list|(
argument|verbose
argument_list|)
name|fputs
argument_list|(
literal|"\nNo article tree to display.\n"
argument_list|,
argument|stdout
argument_list|)
name|FLUSH
expr_stmt|;
name|ELSE
endif|#
directive|endif
ifdef|#
directive|ifdef
name|TERSE
name|fputs
argument_list|(
literal|"\nNo tree.\n"
argument_list|,
name|stdout
argument_list|)
name|FLUSH
decl_stmt|;
endif|#
directive|endif
return|return;
block|}
if|if
condition|(
operator|!
name|ThreadedGroup
condition|)
block|{
name|ThreadedGroup
operator|=
name|TRUE
expr_stmt|;
name|printf
argument_list|(
literal|"Threading the group. "
argument_list|)
operator|,
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|thread_open
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|ThreadedGroup
condition|)
block|{
name|printf
argument_list|(
literal|"*failed*\n"
argument_list|)
name|FLUSH
expr_stmt|;
return|return;
block|}
name|count_subjects
argument_list|(
name|CS_NORM
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'\n'
argument_list|)
name|FLUSH
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|ap
operator|->
name|flags
operator|&
name|AF_THREADED
operator|)
condition|)
name|parseheader
argument_list|(
name|article_num
argument_list|(
name|ap
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|check_page_line
argument_list|()
condition|)
return|return;
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|thread
operator|=
name|ap
operator|->
name|subj
operator|->
name|thread
expr_stmt|;
comment|/* Enumerate our subjects for display */
name|sp
operator|=
name|thread
operator|->
name|subj
expr_stmt|;
name|num
operator|=
literal|0
expr_stmt|;
do|do
block|{
if|if
condition|(
name|check_page_line
argument_list|()
condition|)
return|return;
name|printf
argument_list|(
literal|"[%c] %s\n"
argument_list|,
argument|letters[num>
literal|9
argument|+
literal|26
argument|+
literal|26
argument|?
literal|9
argument|+
literal|26
argument|+
literal|26
argument|:num]
argument_list|,
argument|sp->str+
literal|4
argument_list|)
name|FLUSH
expr_stmt|;
name|sp
operator|->
name|misc
operator|=
name|num
operator|++
expr_stmt|;
name|sp
operator|=
name|sp
operator|->
name|thread_link
expr_stmt|;
block|}
do|while
condition|(
name|sp
operator|!=
name|thread
operator|->
name|subj
condition|)
do|;
if|if
condition|(
name|check_page_line
argument_list|()
condition|)
return|return;
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
if|if
condition|(
name|check_page_line
argument_list|()
condition|)
return|return;
name|putchar
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|buf
index|[
literal|3
index|]
operator|=
literal|'\0'
expr_stmt|;
name|display_tree
argument_list|(
name|thread
argument_list|,
name|tree_indent
argument_list|)
expr_stmt|;
if|if
condition|(
name|check_page_line
argument_list|()
condition|)
return|return;
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* A recursive routine to output the entire article tree. */
end_comment

begin_function
specifier|static
name|void
name|display_tree
parameter_list|(
name|article
parameter_list|,
name|cp
parameter_list|)
name|ARTICLE
modifier|*
name|article
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
block|{
if|if
condition|(
name|cp
operator|-
name|tree_indent
operator|>
name|COLS
operator|||
name|page_line
operator|<
literal|0
condition|)
return|return;
name|cp
index|[
literal|1
index|]
operator|=
literal|' '
expr_stmt|;
name|cp
operator|+=
literal|5
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|putchar
argument_list|(
operator|(
operator|(
name|article
operator|->
name|flags
operator|&
name|AF_HAS_RE
operator|)
operator|||
name|article
operator|->
name|parent
operator|)
condition|?
literal|'-'
else|:
literal|' '
argument_list|)
expr_stmt|;
if|if
condition|(
name|article
operator|->
name|flags
operator|&
name|AF_READ
condition|)
block|{
name|buf
index|[
literal|0
index|]
operator|=
literal|'('
expr_stmt|;
name|buf
index|[
literal|2
index|]
operator|=
literal|')'
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|selected_only
operator|||
operator|(
name|article
operator|->
name|flags
operator|&
name|AF_SEL
operator|)
condition|)
block|{
name|buf
index|[
literal|0
index|]
operator|=
literal|'['
expr_stmt|;
name|buf
index|[
literal|2
index|]
operator|=
literal|']'
expr_stmt|;
block|}
else|else
block|{
name|buf
index|[
literal|0
index|]
operator|=
literal|'<'
expr_stmt|;
name|buf
index|[
literal|2
index|]
operator|=
literal|'>'
expr_stmt|;
block|}
name|buf
index|[
literal|1
index|]
operator|=
name|letter
argument_list|(
name|article
argument_list|)
expr_stmt|;
if|if
condition|(
name|article
operator|==
name|curr_artp
condition|)
block|{
name|standout
argument_list|()
expr_stmt|;
name|fputs
argument_list|(
name|buf
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|un_standout
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|article
operator|==
name|recent_artp
condition|)
block|{
name|putchar
argument_list|(
name|buf
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|standout
argument_list|()
expr_stmt|;
name|putchar
argument_list|(
name|buf
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|un_standout
argument_list|()
expr_stmt|;
name|putchar
argument_list|(
name|buf
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fputs
argument_list|(
name|buf
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|article
operator|->
name|sibling
condition|)
block|{
operator|*
name|cp
operator|=
literal|'|'
expr_stmt|;
block|}
else|else
block|{
operator|*
name|cp
operator|=
literal|' '
expr_stmt|;
block|}
if|if
condition|(
name|article
operator|->
name|child1
condition|)
block|{
name|putchar
argument_list|(
operator|(
name|article
operator|->
name|child1
operator|->
name|sibling
operator|)
condition|?
literal|'+'
else|:
literal|'-'
argument_list|)
expr_stmt|;
name|display_tree
argument_list|(
name|article
operator|->
name|child1
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|cp
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
else|else
block|{
name|putchar
argument_list|(
literal|'\n'
argument_list|)
name|FLUSH
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|article
operator|=
name|article
operator|->
name|sibling
operator|)
condition|)
block|{
break|break;
block|}
if|if
condition|(
operator|!
name|article
operator|->
name|sibling
condition|)
block|{
operator|*
name|cp
operator|=
literal|'\\'
expr_stmt|;
block|}
name|tree_indent
index|[
literal|5
index|]
operator|=
literal|' '
expr_stmt|;
if|if
condition|(
name|check_page_line
argument_list|()
condition|)
block|{
return|return;
block|}
name|fputs
argument_list|(
name|tree_indent
operator|+
literal|5
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|check_page_line
parameter_list|()
block|{
if|if
condition|(
name|page_line
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|page_line
operator|>=
name|LINES
operator|||
name|int_count
condition|)
block|{
specifier|register
name|int
name|cmd
init|=
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|int_count
operator|||
operator|(
name|cmd
operator|=
name|get_anything
argument_list|()
operator|)
condition|)
block|{
name|page_line
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* disable further printing */
if|if
condition|(
name|cmd
operator|>
literal|0
condition|)
name|pushchar
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
return|return
name|cmd
return|;
block|}
block|}
name|page_line
operator|++
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Calculate the subject letter representation.  "Place-holder" nodes ** are marked with a ' ', others get a letter in the sequence: **	' ', '1'-'9', 'A'-'Z', 'a'-'z', '+' */
end_comment

begin_function
specifier|static
name|char
name|letter
parameter_list|(
name|ap
parameter_list|)
specifier|register
name|ARTICLE
modifier|*
name|ap
decl_stmt|;
block|{
name|int
name|subj
init|=
name|ap
operator|->
name|subj
operator|->
name|misc
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|ap
operator|->
name|flags
operator|&
name|AF_CACHED
operator|)
operator|&&
operator|(
name|absfirst
operator|<
name|first_cached
operator|||
name|last_cached
operator|<
name|lastart
operator|||
operator|!
name|cached_all_in_range
operator|)
condition|)
return|return
literal|'?'
return|;
if|if
condition|(
name|ap
operator|->
name|flags
operator|&
name|AF_MISSING
condition|)
return|return
literal|' '
return|;
return|return
name|letters
index|[
name|subj
operator|>
literal|9
operator|+
literal|26
operator|+
literal|26
condition|?
literal|9
operator|+
literal|26
operator|+
literal|26
else|:
name|subj
index|]
return|;
block|}
end_function

end_unit

