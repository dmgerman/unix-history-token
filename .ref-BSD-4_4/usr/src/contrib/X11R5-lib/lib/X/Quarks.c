begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * $XConsortium: Quarks.c,v 1.36 91/03/11 09:03:34 rws Exp $  */
end_comment

begin_comment
comment|/*********************************************************** Copyright 1987, 1988, 1990 by Digital Equipment Corporation, Maynard, Massachusetts, and the Massachusetts Institute of Technology, Cambridge, Massachusetts.                          All Rights Reserved  Permission to use, copy, modify, and distribute this software and its  documentation for any purpose and without fee is hereby granted,  provided that the above copyright notice appear in all copies and that both that copyright notice and this permission notice appear in  supporting documentation, and that the names of Digital or MIT not be used in advertising or publicity pertaining to distribution of the software without specific, written prior permission.    DIGITAL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL DIGITAL BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  ******************************************************************/
end_comment

begin_include
include|#
directive|include
file|"Xlibint.h"
end_include

begin_include
include|#
directive|include
file|<X11/Xresource.h>
end_include

begin_comment
comment|/* Not cost effective, at least for vanilla MIT clients */
end_comment

begin_comment
comment|/* #define PERMQ */
end_comment

begin_typedef
typedef|typedef
name|unsigned
name|long
name|Signature
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|unsigned
name|long
name|Entry
typedef|;
end_typedef

begin_ifdef
ifdef|#
directive|ifdef
name|PERMQ
end_ifdef

begin_typedef
typedef|typedef
name|unsigned
name|char
name|Bits
typedef|;
end_typedef

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|XrmQuark
name|nextQuark
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* next available quark number */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|long
name|quarkMask
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|Entry
name|zero
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|Entry
modifier|*
name|quarkTable
init|=
operator|&
name|zero
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* crock */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|long
name|quarkRehash
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|XrmString
modifier|*
modifier|*
name|stringTable
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|PERMQ
end_ifdef

begin_decl_stmt
specifier|static
name|Bits
modifier|*
modifier|*
name|permTable
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|XrmQuark
name|nextUniq
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* next quark from XrmUniqueQuark */
end_comment

begin_define
define|#
directive|define
name|QUANTUMSHIFT
value|8
end_define

begin_define
define|#
directive|define
name|QUANTUMMASK
value|((1<< QUANTUMSHIFT) - 1)
end_define

begin_define
define|#
directive|define
name|CHUNKPER
value|8
end_define

begin_define
define|#
directive|define
name|CHUNKMASK
value|((CHUNKPER<< QUANTUMSHIFT) - 1)
end_define

begin_define
define|#
directive|define
name|LARGEQUARK
value|((Entry)0x80000000L)
end_define

begin_define
define|#
directive|define
name|QUARKSHIFT
value|18
end_define

begin_define
define|#
directive|define
name|QUARKMASK
value|((LARGEQUARK - 1)>> QUARKSHIFT)
end_define

begin_define
define|#
directive|define
name|SIGMASK
value|((1L<< QUARKSHIFT) - 1)
end_define

begin_define
define|#
directive|define
name|STRQUANTSIZE
value|(sizeof(XrmString) * (QUANTUMMASK + 1))
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|PERMQ
end_ifdef

begin_define
define|#
directive|define
name|QUANTSIZE
value|(STRQUANTSIZE + \ 			 (sizeof(Bits) * ((QUANTUMMASK + 1)>> 3))
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|QUANTSIZE
value|STRQUANTSIZE
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|HASH
parameter_list|(
name|sig
parameter_list|)
value|((sig)& quarkMask)
end_define

begin_define
define|#
directive|define
name|REHASHVAL
parameter_list|(
name|sig
parameter_list|)
value|((((sig) % quarkRehash) + 2) | 1)
end_define

begin_define
define|#
directive|define
name|REHASH
parameter_list|(
name|idx
parameter_list|,
name|rehash
parameter_list|)
value|((idx + rehash)& quarkMask)
end_define

begin_define
define|#
directive|define
name|NAME
parameter_list|(
name|q
parameter_list|)
value|stringTable[(q)>> QUANTUMSHIFT][(q)& QUANTUMMASK]
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|PERMQ
end_ifdef

begin_define
define|#
directive|define
name|BYTEREF
parameter_list|(
name|q
parameter_list|)
value|permTable[(q)>> QUANTUMSHIFT][((q)& QUANTUMMASK)>> 3]
end_define

begin_define
define|#
directive|define
name|ISPERM
parameter_list|(
name|q
parameter_list|)
value|(BYTEREF(q)& (1<< ((q)& 7)))
end_define

begin_define
define|#
directive|define
name|SETPERM
parameter_list|(
name|q
parameter_list|)
value|BYTEREF(q) |= (1<< ((q)& 7))
end_define

begin_define
define|#
directive|define
name|CLEARPERM
parameter_list|(
name|q
parameter_list|)
value|BYTEREF(q)&= ~(1<< ((q)& 7))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Permanent memory allocation */
end_comment

begin_define
define|#
directive|define
name|WALIGN
value|sizeof(unsigned long)
end_define

begin_define
define|#
directive|define
name|DALIGN
value|sizeof(double)
end_define

begin_define
define|#
directive|define
name|NEVERFREETABLESIZE
value|((8192-12)& ~(DALIGN-1))
end_define

begin_decl_stmt
specifier|static
name|char
modifier|*
name|neverFreeTable
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|neverFreeTableSize
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|char
modifier|*
name|permalloc
parameter_list|(
name|length
parameter_list|)
specifier|register
name|unsigned
name|int
name|length
decl_stmt|;
block|{
name|char
modifier|*
name|ret
decl_stmt|;
if|if
condition|(
name|neverFreeTableSize
operator|<
name|length
condition|)
block|{
if|if
condition|(
name|length
operator|>=
name|NEVERFREETABLESIZE
condition|)
return|return
name|Xmalloc
argument_list|(
name|length
argument_list|)
return|;
if|if
condition|(
operator|!
operator|(
name|ret
operator|=
name|Xmalloc
argument_list|(
name|NEVERFREETABLESIZE
argument_list|)
operator|)
condition|)
return|return
operator|(
name|char
operator|*
operator|)
name|NULL
return|;
name|neverFreeTableSize
operator|=
name|NEVERFREETABLESIZE
expr_stmt|;
name|neverFreeTable
operator|=
name|ret
expr_stmt|;
block|}
name|ret
operator|=
name|neverFreeTable
expr_stmt|;
name|neverFreeTable
operator|+=
name|length
expr_stmt|;
name|neverFreeTableSize
operator|-=
name|length
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|Xpermalloc
parameter_list|(
name|length
parameter_list|)
name|unsigned
name|int
name|length
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|neverFreeTableSize
operator|&&
name|length
operator|<
name|NEVERFREETABLESIZE
condition|)
block|{
ifndef|#
directive|ifndef
name|WORD64
if|if
condition|(
operator|(
expr|sizeof
operator|(
expr|struct
block|{
name|char
name|a
decl_stmt|;
name|double
name|b
decl_stmt|;
block|}
block|)
operator|!=
operator|(
expr|sizeof
operator|(
expr|struct
block|{
name|char
name|a
block|;
name|unsigned
name|long
name|b
expr|;
block|}
end_function

begin_expr_stmt
unit|)
operator|-
expr|sizeof
operator|(
name|unsigned
name|long
operator|)
operator|+
sizeof|sizeof
argument_list|(
name|double
argument_list|)
end_expr_stmt

begin_expr_stmt
unit|))
operator|&&
operator|!
operator|(
name|length
operator|&
operator|(
name|DALIGN
operator|-
literal|1
operator|)
operator|)
operator|&&
operator|(
name|i
operator|=
operator|(
name|NEVERFREETABLESIZE
operator|-
name|neverFreeTableSize
operator|)
operator|&
operator|(
name|DALIGN
operator|-
literal|1
operator|)
operator|)
end_expr_stmt

begin_block
unit|)
block|{
name|neverFreeTableSize
operator|-=
name|DALIGN
operator|-
name|i
expr_stmt|;
name|neverFreeTable
operator|+=
name|DALIGN
operator|-
name|i
expr_stmt|;
block|}
end_block

begin_elseif
elseif|else
endif|#
directive|endif
if|if
condition|(
name|i
operator|=
operator|(
name|NEVERFREETABLESIZE
operator|-
name|neverFreeTableSize
operator|)
operator|&
operator|(
name|WALIGN
operator|-
literal|1
operator|)
condition|)
block|{
name|neverFreeTableSize
operator|-=
name|WALIGN
operator|-
name|i
expr_stmt|;
name|neverFreeTable
operator|+=
name|WALIGN
operator|-
name|i
expr_stmt|;
block|}
end_elseif

begin_expr_stmt
unit|}     return
name|permalloc
argument_list|(
name|length
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
unit|}  static
name|Bool
name|ExpandQuarkTable
parameter_list|()
block|{
name|unsigned
name|long
name|oldmask
decl_stmt|,
name|newmask
decl_stmt|;
specifier|register
name|char
name|c
decl_stmt|,
modifier|*
name|s
decl_stmt|;
specifier|register
name|Entry
modifier|*
name|oldentries
decl_stmt|,
modifier|*
name|entries
decl_stmt|;
specifier|register
name|Entry
name|entry
decl_stmt|;
specifier|register
name|int
name|oldidx
decl_stmt|,
name|newidx
decl_stmt|,
name|rehash
decl_stmt|;
name|Signature
name|sig
decl_stmt|;
name|XrmQuark
name|q
decl_stmt|;
name|oldentries
operator|=
name|quarkTable
expr_stmt|;
if|if
condition|(
name|oldmask
operator|=
name|quarkMask
condition|)
name|newmask
operator|=
operator|(
name|oldmask
operator|<<
literal|1
operator|)
operator|+
literal|1
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|!
name|stringTable
condition|)
block|{
name|stringTable
operator|=
operator|(
name|XrmString
operator|*
operator|*
operator|)
name|Xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|XrmString
operator|*
argument_list|)
operator|*
name|CHUNKPER
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|stringTable
condition|)
return|return
name|False
return|;
name|stringTable
index|[
literal|0
index|]
operator|=
operator|(
name|XrmString
operator|*
operator|)
name|NULL
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|PERMQ
if|if
condition|(
operator|!
name|permTable
condition|)
name|permTable
operator|=
operator|(
name|Bits
operator|*
operator|*
operator|)
name|Xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|Bits
operator|*
argument_list|)
operator|*
name|CHUNKPER
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|permTable
condition|)
return|return
name|False
return|;
endif|#
directive|endif
name|stringTable
index|[
literal|0
index|]
operator|=
operator|(
name|XrmString
operator|*
operator|)
name|Xpermalloc
argument_list|(
name|QUANTSIZE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|stringTable
index|[
literal|0
index|]
condition|)
return|return
name|False
return|;
ifdef|#
directive|ifdef
name|PERMQ
name|permTable
index|[
literal|0
index|]
operator|=
operator|(
name|Bits
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|stringTable
index|[
literal|0
index|]
operator|+
name|STRQUANTSIZE
operator|)
expr_stmt|;
endif|#
directive|endif
name|newmask
operator|=
literal|0x1ff
expr_stmt|;
block|}
name|entries
operator|=
operator|(
name|Entry
operator|*
operator|)
name|Xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|Entry
argument_list|)
operator|*
operator|(
name|newmask
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|entries
condition|)
return|return
name|False
return|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|entries
argument_list|,
sizeof|sizeof
argument_list|(
name|Entry
argument_list|)
operator|*
operator|(
name|newmask
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
name|quarkTable
operator|=
name|entries
expr_stmt|;
name|quarkMask
operator|=
name|newmask
expr_stmt|;
name|quarkRehash
operator|=
name|quarkMask
operator|-
literal|2
expr_stmt|;
for|for
control|(
name|oldidx
operator|=
literal|0
init|;
name|oldidx
operator|<=
name|oldmask
condition|;
name|oldidx
operator|++
control|)
block|{
if|if
condition|(
name|entry
operator|=
name|oldentries
index|[
name|oldidx
index|]
condition|)
block|{
if|if
condition|(
name|entry
operator|&
name|LARGEQUARK
condition|)
name|q
operator|=
name|entry
operator|&
operator|(
name|LARGEQUARK
operator|-
literal|1
operator|)
expr_stmt|;
else|else
name|q
operator|=
operator|(
name|entry
operator|>>
name|QUARKSHIFT
operator|)
operator|&
name|QUARKMASK
expr_stmt|;
for|for
control|(
name|sig
operator|=
literal|0
operator|,
name|s
operator|=
name|NAME
argument_list|(
name|q
argument_list|)
init|;
name|c
operator|=
operator|*
name|s
operator|++
condition|;
control|)
name|sig
operator|=
operator|(
name|sig
operator|<<
literal|1
operator|)
operator|+
name|c
expr_stmt|;
name|newidx
operator|=
name|HASH
argument_list|(
name|sig
argument_list|)
expr_stmt|;
if|if
condition|(
name|entries
index|[
name|newidx
index|]
condition|)
block|{
name|rehash
operator|=
name|REHASHVAL
argument_list|(
name|sig
argument_list|)
expr_stmt|;
do|do
block|{
name|newidx
operator|=
name|REHASH
argument_list|(
name|newidx
argument_list|,
name|rehash
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|entries
index|[
name|newidx
index|]
condition|)
do|;
block|}
name|entries
index|[
name|newidx
index|]
operator|=
name|entry
expr_stmt|;
block|}
block|}
if|if
condition|(
name|oldmask
condition|)
name|Xfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|oldentries
argument_list|)
expr_stmt|;
return|return
name|True
return|;
block|}
end_function

begin_if
if|#
directive|if
name|NeedFunctionPrototypes
end_if

begin_decl_stmt
name|XrmQuark
name|_XrmInternalStringToQuark
argument_list|(
specifier|register
name|_Xconst
name|char
operator|*
name|name
argument_list|,
specifier|register
name|int
name|len
argument_list|,
specifier|register
name|Signature
name|sig
argument_list|,
name|Bool
name|permstring
argument_list|)
else|#
directive|else
name|XrmQuark
name|_XrmInternalStringToQuark
argument_list|(
name|name
argument_list|,
name|len
argument_list|,
name|sig
argument_list|,
name|permstring
argument_list|)
decl|register
name|XrmString
name|name
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|int
name|len
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|Signature
name|sig
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Bool
name|permstring
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_block
block|{
specifier|register
name|XrmQuark
name|q
decl_stmt|;
specifier|register
name|Entry
name|entry
decl_stmt|;
specifier|register
name|int
name|idx
decl_stmt|,
name|rehash
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|char
modifier|*
name|s1
decl_stmt|,
modifier|*
name|s2
decl_stmt|;
name|char
modifier|*
name|new
decl_stmt|;
name|rehash
operator|=
literal|0
expr_stmt|;
name|idx
operator|=
name|HASH
argument_list|(
name|sig
argument_list|)
expr_stmt|;
while|while
condition|(
name|entry
operator|=
name|quarkTable
index|[
name|idx
index|]
condition|)
block|{
if|if
condition|(
name|entry
operator|&
name|LARGEQUARK
condition|)
name|q
operator|=
name|entry
operator|&
operator|(
name|LARGEQUARK
operator|-
literal|1
operator|)
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|(
name|entry
operator|-
name|sig
operator|)
operator|&
name|SIGMASK
condition|)
goto|goto
name|nomatch
goto|;
name|q
operator|=
operator|(
name|entry
operator|>>
name|QUARKSHIFT
operator|)
operator|&
name|QUARKMASK
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
name|len
operator|,
name|s1
operator|=
operator|(
name|char
operator|*
operator|)
name|name
operator|,
name|s2
operator|=
name|NAME
argument_list|(
name|q
argument_list|)
init|;
operator|--
name|i
operator|>=
literal|0
condition|;
control|)
block|{
if|if
condition|(
operator|*
name|s1
operator|++
operator|!=
operator|*
name|s2
operator|++
condition|)
goto|goto
name|nomatch
goto|;
block|}
if|if
condition|(
operator|*
name|s2
condition|)
block|{
name|nomatch
label|:
if|if
condition|(
operator|!
name|rehash
condition|)
name|rehash
operator|=
name|REHASHVAL
argument_list|(
name|sig
argument_list|)
expr_stmt|;
name|idx
operator|=
name|REHASH
argument_list|(
name|idx
argument_list|,
name|rehash
argument_list|)
expr_stmt|;
continue|continue;
block|}
ifdef|#
directive|ifdef
name|PERMQ
if|if
condition|(
name|permstring
operator|&&
operator|!
name|ISPERM
argument_list|(
name|q
argument_list|)
condition|)
block|{
name|Xfree
argument_list|(
name|NAME
argument_list|(
name|q
argument_list|)
argument_list|)
expr_stmt|;
name|NAME
argument_list|(
name|q
argument_list|)
operator|=
operator|(
name|char
operator|*
operator|)
name|name
expr_stmt|;
name|SETPERM
argument_list|(
name|q
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
return|return
name|q
return|;
block|}
if|if
condition|(
name|nextUniq
operator|==
name|nextQuark
condition|)
return|return
name|NULLQUARK
return|;
if|if
condition|(
operator|(
name|nextQuark
operator|+
operator|(
name|nextQuark
operator|>>
literal|2
operator|)
operator|)
operator|>
name|quarkMask
condition|)
block|{
if|if
condition|(
operator|!
name|ExpandQuarkTable
argument_list|()
condition|)
return|return
name|NULLQUARK
return|;
return|return
name|_XrmInternalStringToQuark
argument_list|(
name|name
argument_list|,
name|len
argument_list|,
name|sig
argument_list|,
name|permstring
argument_list|)
return|;
block|}
name|q
operator|=
name|nextQuark
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|q
operator|&
name|QUANTUMMASK
operator|)
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|q
operator|&
name|CHUNKMASK
operator|)
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|new
operator|=
name|Xrealloc
argument_list|(
operator|(
name|char
operator|*
operator|)
name|stringTable
argument_list|,
sizeof|sizeof
argument_list|(
name|XrmString
operator|*
argument_list|)
operator|*
operator|(
operator|(
name|q
operator|>>
name|QUANTUMSHIFT
operator|)
operator|+
name|CHUNKPER
operator|)
argument_list|)
operator|)
condition|)
return|return
name|NULLQUARK
return|;
name|stringTable
operator|=
operator|(
name|XrmString
operator|*
operator|*
operator|)
name|new
expr_stmt|;
ifdef|#
directive|ifdef
name|PERMQ
if|if
condition|(
operator|!
operator|(
name|new
operator|=
name|Xrealloc
argument_list|(
operator|(
name|char
operator|*
operator|)
name|permTable
argument_list|,
sizeof|sizeof
argument_list|(
name|Bits
operator|*
argument_list|)
operator|*
operator|(
operator|(
name|q
operator|>>
name|QUANTUMSHIFT
operator|)
operator|+
name|CHUNKPER
operator|)
argument_list|)
operator|)
condition|)
return|return
name|NULLQUARK
return|;
name|permTable
operator|=
operator|(
name|Bits
operator|*
operator|*
operator|)
name|new
expr_stmt|;
endif|#
directive|endif
block|}
name|new
operator|=
name|Xpermalloc
argument_list|(
name|QUANTSIZE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|new
condition|)
return|return
name|NULLQUARK
return|;
name|stringTable
index|[
name|q
operator|>>
name|QUANTUMSHIFT
index|]
operator|=
operator|(
name|XrmString
operator|*
operator|)
name|new
expr_stmt|;
ifdef|#
directive|ifdef
name|PERMQ
name|permTable
index|[
name|q
operator|>>
name|QUANTUMSHIFT
index|]
operator|=
operator|(
name|Bits
operator|*
operator|)
operator|(
name|new
operator|+
name|STRQUANTSIZE
operator|)
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
operator|!
name|permstring
condition|)
block|{
name|s2
operator|=
operator|(
name|char
operator|*
operator|)
name|name
expr_stmt|;
ifdef|#
directive|ifdef
name|PERMQ
name|name
operator|=
name|Xmalloc
argument_list|(
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
else|#
directive|else
name|name
operator|=
name|permalloc
argument_list|(
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|name
condition|)
return|return
name|NULLQUARK
return|;
for|for
control|(
name|i
operator|=
name|len
operator|,
name|s1
operator|=
operator|(
name|char
operator|*
operator|)
name|name
init|;
operator|--
name|i
operator|>=
literal|0
condition|;
control|)
operator|*
name|s1
operator|++
operator|=
operator|*
name|s2
operator|++
expr_stmt|;
operator|*
name|s1
operator|++
operator|=
literal|'\0'
expr_stmt|;
ifdef|#
directive|ifdef
name|PERMQ
name|CLEARPERM
argument_list|(
name|q
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SETPERM
argument_list|(
name|q
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|NAME
argument_list|(
name|q
argument_list|)
operator|=
operator|(
name|char
operator|*
operator|)
name|name
expr_stmt|;
if|if
condition|(
name|q
operator|<=
name|QUARKMASK
condition|)
name|entry
operator|=
operator|(
name|q
operator|<<
name|QUARKSHIFT
operator|)
operator||
operator|(
name|sig
operator|&
name|SIGMASK
operator|)
expr_stmt|;
else|else
name|entry
operator|=
name|q
operator||
name|LARGEQUARK
expr_stmt|;
name|quarkTable
index|[
name|idx
index|]
operator|=
name|entry
expr_stmt|;
name|nextQuark
operator|++
expr_stmt|;
return|return
name|q
return|;
block|}
end_block

begin_if
if|#
directive|if
name|NeedFunctionPrototypes
end_if

begin_function
name|XrmQuark
name|XrmStringToQuark
parameter_list|(
name|_Xconst
name|char
modifier|*
name|name
parameter_list|)
else|#
directive|else
function|XrmQuark XrmStringToQuark
parameter_list|(
name|name
parameter_list|)
name|XrmString
name|name
decl_stmt|;
endif|#
directive|endif
block|{
specifier|register
name|char
name|c
decl_stmt|,
modifier|*
name|tname
decl_stmt|;
specifier|register
name|Signature
name|sig
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|name
condition|)
return|return
operator|(
name|NULLQUARK
operator|)
return|;
for|for
control|(
name|tname
operator|=
operator|(
name|char
operator|*
operator|)
name|name
init|;
name|c
operator|=
operator|*
name|tname
operator|++
condition|;
control|)
name|sig
operator|=
operator|(
name|sig
operator|<<
literal|1
operator|)
operator|+
name|c
expr_stmt|;
return|return
name|_XrmInternalStringToQuark
argument_list|(
name|name
argument_list|,
name|tname
operator|-
operator|(
name|char
operator|*
operator|)
name|name
operator|-
literal|1
argument_list|,
name|sig
argument_list|,
name|False
argument_list|)
return|;
block|}
end_function

begin_if
if|#
directive|if
name|NeedFunctionPrototypes
end_if

begin_function
name|XrmQuark
name|XrmPermStringToQuark
parameter_list|(
name|_Xconst
name|char
modifier|*
name|name
parameter_list|)
else|#
directive|else
function|XrmQuark XrmPermStringToQuark
parameter_list|(
name|name
parameter_list|)
name|XrmString
name|name
decl_stmt|;
endif|#
directive|endif
block|{
specifier|register
name|char
name|c
decl_stmt|,
modifier|*
name|tname
decl_stmt|;
specifier|register
name|Signature
name|sig
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|name
condition|)
return|return
operator|(
name|NULLQUARK
operator|)
return|;
for|for
control|(
name|tname
operator|=
operator|(
name|char
operator|*
operator|)
name|name
init|;
name|c
operator|=
operator|*
name|tname
operator|++
condition|;
control|)
name|sig
operator|=
operator|(
name|sig
operator|<<
literal|1
operator|)
operator|+
name|c
expr_stmt|;
return|return
name|_XrmInternalStringToQuark
argument_list|(
name|name
argument_list|,
name|tname
operator|-
operator|(
name|char
operator|*
operator|)
name|name
operator|-
literal|1
argument_list|,
name|sig
argument_list|,
name|True
argument_list|)
return|;
block|}
end_function

begin_function
name|XrmQuark
name|XrmUniqueQuark
parameter_list|()
block|{
if|if
condition|(
name|nextUniq
operator|==
name|nextQuark
condition|)
return|return
name|NULLQUARK
return|;
return|return
name|nextUniq
operator|--
return|;
block|}
end_function

begin_function
name|XrmString
name|XrmQuarkToString
parameter_list|(
name|quark
parameter_list|)
specifier|register
name|XrmQuark
name|quark
decl_stmt|;
block|{
if|if
condition|(
name|quark
operator|<=
literal|0
operator|||
name|quark
operator|>=
name|nextQuark
condition|)
return|return
name|NULLSTRING
return|;
ifdef|#
directive|ifdef
name|PERMQ
comment|/* We have to mark the quark as permanent, since the caller might hold      * onto the string pointer forver.      */
name|SETPERM
argument_list|(
name|quark
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|NAME
argument_list|(
name|quark
argument_list|)
return|;
block|}
end_function

end_unit

