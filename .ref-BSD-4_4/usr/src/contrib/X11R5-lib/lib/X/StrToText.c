begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* $XConsortium: StrToText.c,v 1.4 91/01/08 14:40:18 gildea Exp $ */
end_comment

begin_comment
comment|/* Copyright 1989 Massachusetts Institute of Technology */
end_comment

begin_comment
comment|/* Permission to use, copy, modify, distribute, and sell this software and its documentation for any purpose is hereby granted without fee, provided that the above copyright notice appear in all copies and that both that copyright notice and this permission notice appear in supporting documentation, and that the name of M.I.T. not be used in advertising or publicity pertaining to distribution of the software without specific, written prior permission.  M.I.T. makes no representations about the suitability of this software for any purpose.  It is provided "as is" without express or implied warranty. */
end_comment

begin_include
include|#
directive|include
file|<X11/Xlibint.h>
end_include

begin_include
include|#
directive|include
file|<X11/Xatom.h>
end_include

begin_include
include|#
directive|include
file|<X11/Xutil.h>
end_include

begin_comment
comment|/*  * XStringListToTextProperty - fill in TextProperty structure with   * concatenated list of null-separated strings.  Return True if successful   * else False.  Allocate room on end for trailing NULL, but don't include in  * count.  */
end_comment

begin_function
name|Status
name|XStringListToTextProperty
parameter_list|(
name|argv
parameter_list|,
name|argc
parameter_list|,
name|textprop
parameter_list|)
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
name|int
name|argc
decl_stmt|;
name|XTextProperty
modifier|*
name|textprop
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|unsigned
name|int
name|nbytes
decl_stmt|;
name|XTextProperty
name|proto
decl_stmt|;
comment|/* figure out how much space we'll need for this list */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|nbytes
operator|=
literal|0
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
block|{
name|nbytes
operator|+=
call|(
name|unsigned
call|)
argument_list|(
operator|(
name|argv
index|[
name|i
index|]
condition|?
name|strlen
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|)
else|:
literal|0
operator|)
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* fill in a prototype containing results so far */
name|proto
operator|.
name|encoding
operator|=
name|XA_STRING
expr_stmt|;
name|proto
operator|.
name|format
operator|=
literal|8
expr_stmt|;
if|if
condition|(
name|nbytes
condition|)
name|proto
operator|.
name|nitems
operator|=
name|nbytes
operator|-
literal|1
expr_stmt|;
comment|/* subtract one for trailing<NUL> */
else|else
name|proto
operator|.
name|nitems
operator|=
literal|0
expr_stmt|;
name|proto
operator|.
name|value
operator|=
name|NULL
expr_stmt|;
comment|/* build concatenated list of strings */
if|if
condition|(
name|nbytes
operator|>
literal|0
condition|)
block|{
specifier|register
name|char
modifier|*
name|buf
init|=
name|Xmalloc
argument_list|(
name|nbytes
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|buf
condition|)
return|return
name|False
return|;
name|proto
operator|.
name|value
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|buf
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
block|{
name|char
modifier|*
name|arg
init|=
name|argv
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|arg
condition|)
block|{
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|buf
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|buf
operator|+=
operator|(
name|strlen
argument_list|(
name|arg
argument_list|)
operator|+
literal|1
operator|)
expr_stmt|;
block|}
else|else
block|{
operator|*
name|buf
operator|++
operator|=
literal|'\0'
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|proto
operator|.
name|value
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|Xmalloc
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* easier for client */
if|if
condition|(
operator|!
name|proto
operator|.
name|value
condition|)
return|return
name|False
return|;
name|proto
operator|.
name|value
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
comment|/* we were successful, so set return value */
operator|*
name|textprop
operator|=
name|proto
expr_stmt|;
return|return
name|True
return|;
block|}
end_function

end_unit

