begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* $XConsortium: XRdBitF.c,v 1.15 91/02/01 16:34:46 gildea Exp $ */
end_comment

begin_comment
comment|/* Copyright, 1987, Massachusetts Institute of Technology */
end_comment

begin_comment
comment|/* Permission to use, copy, modify, distribute, and sell this software and its documentation for any purpose is hereby granted without fee, provided that the above copyright notice appear in all copies and that both that copyright notice and this permission notice appear in supporting documentation, and that the name of M.I.T. not be used in advertising or publicity pertaining to distribution of the software without specific, written prior permission.  M.I.T. makes no representations about the suitability of this software for any purpose.  It is provided "as is" without express or implied warranty. */
end_comment

begin_comment
comment|/*  *	Code to read bitmaps from disk files. Interprets   *	data from X10 and X11 bitmap files and creates  *	Pixmap representations of files. Returns Pixmap  *	ID and specifics about image.  *  *	Modified for speedup by Jim Becker, changed image  *	data parsing logic (removed some fscanf()s).   *	Aug 5, 1988  *  * Note that this file and ../Xmu/RdBitF.c look very similar....  Keep them  * that way (but don't use common source code so that people can have one   * without the other).  */
end_comment

begin_include
include|#
directive|include
file|"Xlibint.h"
end_include

begin_include
include|#
directive|include
file|<X11/Xos.h>
end_include

begin_include
include|#
directive|include
file|"Xutil.h"
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_define
define|#
directive|define
name|MAX_SIZE
value|255
end_define

begin_comment
comment|/* shared data for the image read/parse logic */
end_comment

begin_decl_stmt
specifier|static
name|short
name|hexTable
index|[
literal|256
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* conversion value */
end_comment

begin_decl_stmt
specifier|static
name|Bool
name|initialized
init|=
name|False
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* easier to fill in at run time */
end_comment

begin_comment
comment|/*  *	Table index for the hex values. Initialized once, first time.  *	Used for translation value or delimiter significance lookup.  */
end_comment

begin_function
specifier|static
name|void
name|initHexTable
parameter_list|()
block|{
comment|/*      * We build the table at run time for several reasons:      *      *     1.  portable to non-ASCII machines.      *     2.  still reentrant since we set the init flag after setting table.      *     3.  easier to extend.      *     4.  less prone to bugs.      */
name|hexTable
index|[
literal|'0'
index|]
operator|=
literal|0
expr_stmt|;
name|hexTable
index|[
literal|'1'
index|]
operator|=
literal|1
expr_stmt|;
name|hexTable
index|[
literal|'2'
index|]
operator|=
literal|2
expr_stmt|;
name|hexTable
index|[
literal|'3'
index|]
operator|=
literal|3
expr_stmt|;
name|hexTable
index|[
literal|'4'
index|]
operator|=
literal|4
expr_stmt|;
name|hexTable
index|[
literal|'5'
index|]
operator|=
literal|5
expr_stmt|;
name|hexTable
index|[
literal|'6'
index|]
operator|=
literal|6
expr_stmt|;
name|hexTable
index|[
literal|'7'
index|]
operator|=
literal|7
expr_stmt|;
name|hexTable
index|[
literal|'8'
index|]
operator|=
literal|8
expr_stmt|;
name|hexTable
index|[
literal|'9'
index|]
operator|=
literal|9
expr_stmt|;
name|hexTable
index|[
literal|'A'
index|]
operator|=
literal|10
expr_stmt|;
name|hexTable
index|[
literal|'B'
index|]
operator|=
literal|11
expr_stmt|;
name|hexTable
index|[
literal|'C'
index|]
operator|=
literal|12
expr_stmt|;
name|hexTable
index|[
literal|'D'
index|]
operator|=
literal|13
expr_stmt|;
name|hexTable
index|[
literal|'E'
index|]
operator|=
literal|14
expr_stmt|;
name|hexTable
index|[
literal|'F'
index|]
operator|=
literal|15
expr_stmt|;
name|hexTable
index|[
literal|'a'
index|]
operator|=
literal|10
expr_stmt|;
name|hexTable
index|[
literal|'b'
index|]
operator|=
literal|11
expr_stmt|;
name|hexTable
index|[
literal|'c'
index|]
operator|=
literal|12
expr_stmt|;
name|hexTable
index|[
literal|'d'
index|]
operator|=
literal|13
expr_stmt|;
name|hexTable
index|[
literal|'e'
index|]
operator|=
literal|14
expr_stmt|;
name|hexTable
index|[
literal|'f'
index|]
operator|=
literal|15
expr_stmt|;
comment|/* delimiters of significance are flagged w/ negative value */
name|hexTable
index|[
literal|' '
index|]
operator|=
operator|-
literal|1
expr_stmt|;
name|hexTable
index|[
literal|','
index|]
operator|=
operator|-
literal|1
expr_stmt|;
name|hexTable
index|[
literal|'}'
index|]
operator|=
operator|-
literal|1
expr_stmt|;
name|hexTable
index|[
literal|'\n'
index|]
operator|=
operator|-
literal|1
expr_stmt|;
name|hexTable
index|[
literal|'\t'
index|]
operator|=
operator|-
literal|1
expr_stmt|;
name|initialized
operator|=
name|True
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *	read next hex value in the input stream, return -1 if EOF  */
end_comment

begin_expr_stmt
specifier|static
name|NextInt
argument_list|(
argument|fstream
argument_list|)
name|FILE
operator|*
name|fstream
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|int
name|ch
decl_stmt|;
name|int
name|value
init|=
literal|0
decl_stmt|;
name|int
name|gotone
init|=
literal|0
decl_stmt|;
name|int
name|done
init|=
literal|0
decl_stmt|;
comment|/* loop, accumulate hex value until find delimiter  */
comment|/* skip any initial delimiters found in read stream */
while|while
condition|(
operator|!
name|done
condition|)
block|{
name|ch
operator|=
name|getc
argument_list|(
name|fstream
argument_list|)
expr_stmt|;
if|if
condition|(
name|ch
operator|==
name|EOF
condition|)
block|{
name|value
operator|=
operator|-
literal|1
expr_stmt|;
name|done
operator|++
expr_stmt|;
block|}
else|else
block|{
comment|/* trim high bits, check type and accumulate */
name|ch
operator|&=
literal|0xff
expr_stmt|;
if|if
condition|(
name|isascii
argument_list|(
name|ch
argument_list|)
operator|&&
name|isxdigit
argument_list|(
name|ch
argument_list|)
condition|)
block|{
name|value
operator|=
operator|(
name|value
operator|<<
literal|4
operator|)
operator|+
name|hexTable
index|[
name|ch
index|]
expr_stmt|;
name|gotone
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|hexTable
index|[
name|ch
index|]
operator|)
operator|<
literal|0
operator|&&
name|gotone
condition|)
name|done
operator|++
expr_stmt|;
block|}
block|}
return|return
name|value
return|;
block|}
end_block

begin_if
if|#
directive|if
name|NeedFunctionPrototypes
end_if

begin_function
name|int
name|XReadBitmapFile
parameter_list|(
name|Display
modifier|*
name|display
parameter_list|,
name|Drawable
name|d
parameter_list|,
name|_Xconst
name|char
modifier|*
name|filename
parameter_list|,
name|unsigned
name|int
modifier|*
name|width
parameter_list|,
comment|/* RETURNED */
name|unsigned
name|int
modifier|*
name|height
parameter_list|,
comment|/* RETURNED */
name|Pixmap
modifier|*
name|pixmap
parameter_list|,
comment|/* RETURNED */
name|int
modifier|*
name|x_hot
parameter_list|,
comment|/* RETURNED */
name|int
modifier|*
name|y_hot
parameter_list|)
comment|/* RETURNED */
else|#
directive|else
function|int XReadBitmapFile
parameter_list|(
name|display
parameter_list|,
name|d
parameter_list|,
name|filename
parameter_list|,
name|width
parameter_list|,
name|height
parameter_list|,
name|pixmap
parameter_list|,
name|x_hot
parameter_list|,
name|y_hot
parameter_list|)
name|Display
modifier|*
name|display
decl_stmt|;
name|Drawable
name|d
decl_stmt|;
name|char
modifier|*
name|filename
decl_stmt|;
name|unsigned
name|int
modifier|*
name|width
decl_stmt|,
decl|*
name|height
decl_stmt|;
end_function

begin_comment
comment|/* RETURNED */
end_comment

begin_decl_stmt
name|Pixmap
modifier|*
name|pixmap
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* RETURNED */
end_comment

begin_decl_stmt
name|int
modifier|*
name|x_hot
decl_stmt|,
modifier|*
name|y_hot
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* RETURNED */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_block
block|{
name|Pixmap
name|pix
decl_stmt|;
comment|/* value to return */
name|FILE
modifier|*
name|fstream
decl_stmt|;
comment|/* handle on file  */
name|unsigned
name|char
modifier|*
name|data
init|=
name|NULL
decl_stmt|;
comment|/* working variable */
name|char
name|line
index|[
name|MAX_SIZE
index|]
decl_stmt|;
comment|/* input line from file */
name|int
name|size
decl_stmt|;
comment|/* number of bytes of data */
name|char
name|name_and_type
index|[
name|MAX_SIZE
index|]
decl_stmt|;
comment|/* an input line */
name|char
modifier|*
name|type
decl_stmt|;
comment|/* for parsing */
name|int
name|value
decl_stmt|;
comment|/* from an input line */
name|int
name|version10p
decl_stmt|;
comment|/* boolean, old format */
name|int
name|padding
decl_stmt|;
comment|/* to handle alignment */
name|int
name|bytes_per_line
decl_stmt|;
comment|/* per scanline of data */
name|unsigned
name|int
name|ww
init|=
literal|0
decl_stmt|;
comment|/* width */
name|unsigned
name|int
name|hh
init|=
literal|0
decl_stmt|;
comment|/* height */
name|int
name|hx
init|=
operator|-
literal|1
decl_stmt|;
comment|/* x hotspot */
name|int
name|hy
init|=
operator|-
literal|1
decl_stmt|;
comment|/* y hotspot */
comment|/* first time initialization */
if|if
condition|(
name|initialized
operator|==
name|False
condition|)
name|initHexTable
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|fstream
operator|=
name|fopen
argument_list|(
name|filename
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
return|return
name|BitmapOpenFailed
return|;
block|}
comment|/* error cleanup and return macro	*/
define|#
directive|define
name|RETURN
parameter_list|(
name|code
parameter_list|)
value|{ if (data) free (data); fclose (fstream); return code; }
while|while
condition|(
name|fgets
argument_list|(
name|line
argument_list|,
name|MAX_SIZE
argument_list|,
name|fstream
argument_list|)
condition|)
block|{
if|if
condition|(
name|strlen
argument_list|(
name|line
argument_list|)
operator|==
name|MAX_SIZE
operator|-
literal|1
condition|)
block|{
name|RETURN
argument_list|(
name|BitmapFileInvalid
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sscanf
argument_list|(
name|line
argument_list|,
literal|"#define %s %d"
argument_list|,
name|name_and_type
argument_list|,
operator|&
name|value
argument_list|)
operator|==
literal|2
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|type
operator|=
name|rindex
argument_list|(
name|name_and_type
argument_list|,
literal|'_'
argument_list|)
operator|)
condition|)
name|type
operator|=
name|name_and_type
expr_stmt|;
else|else
name|type
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
literal|"width"
argument_list|,
name|type
argument_list|)
condition|)
name|ww
operator|=
operator|(
name|unsigned
name|int
operator|)
name|value
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
literal|"height"
argument_list|,
name|type
argument_list|)
condition|)
name|hh
operator|=
operator|(
name|unsigned
name|int
operator|)
name|value
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
literal|"hot"
argument_list|,
name|type
argument_list|)
condition|)
block|{
if|if
condition|(
name|type
operator|--
operator|==
name|name_and_type
operator|||
name|type
operator|--
operator|==
name|name_and_type
condition|)
continue|continue;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
literal|"x_hot"
argument_list|,
name|type
argument_list|)
condition|)
name|hx
operator|=
name|value
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
literal|"y_hot"
argument_list|,
name|type
argument_list|)
condition|)
name|hy
operator|=
name|value
expr_stmt|;
block|}
continue|continue;
block|}
if|if
condition|(
name|sscanf
argument_list|(
name|line
argument_list|,
literal|"static short %s = {"
argument_list|,
name|name_and_type
argument_list|)
operator|==
literal|1
condition|)
name|version10p
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|sscanf
argument_list|(
name|line
argument_list|,
literal|"static unsigned char %s = {"
argument_list|,
name|name_and_type
argument_list|)
operator|==
literal|1
condition|)
name|version10p
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|sscanf
argument_list|(
name|line
argument_list|,
literal|"static char %s = {"
argument_list|,
name|name_and_type
argument_list|)
operator|==
literal|1
condition|)
name|version10p
operator|=
literal|0
expr_stmt|;
else|else
continue|continue;
if|if
condition|(
operator|!
operator|(
name|type
operator|=
name|rindex
argument_list|(
name|name_and_type
argument_list|,
literal|'_'
argument_list|)
operator|)
condition|)
name|type
operator|=
name|name_and_type
expr_stmt|;
else|else
name|type
operator|++
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
literal|"bits[]"
argument_list|,
name|type
argument_list|)
condition|)
continue|continue;
if|if
condition|(
operator|!
name|ww
operator|||
operator|!
name|hh
condition|)
name|RETURN
argument_list|(
name|BitmapFileInvalid
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ww
operator|%
literal|16
operator|)
operator|&&
operator|(
operator|(
name|ww
operator|%
literal|16
operator|)
operator|<
literal|9
operator|)
operator|&&
name|version10p
condition|)
name|padding
operator|=
literal|1
expr_stmt|;
else|else
name|padding
operator|=
literal|0
expr_stmt|;
name|bytes_per_line
operator|=
operator|(
name|ww
operator|+
literal|7
operator|)
operator|/
literal|8
operator|+
name|padding
expr_stmt|;
name|size
operator|=
name|bytes_per_line
operator|*
name|hh
expr_stmt|;
name|data
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|Xmalloc
argument_list|(
operator|(
name|unsigned
name|int
operator|)
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|data
condition|)
name|RETURN
argument_list|(
name|BitmapNoMemory
argument_list|)
expr_stmt|;
if|if
condition|(
name|version10p
condition|)
block|{
name|unsigned
name|char
modifier|*
name|ptr
decl_stmt|;
name|int
name|bytes
decl_stmt|;
for|for
control|(
name|bytes
operator|=
literal|0
operator|,
name|ptr
operator|=
name|data
init|;
name|bytes
operator|<
name|size
condition|;
operator|(
name|bytes
operator|+=
literal|2
operator|)
control|)
block|{
if|if
condition|(
operator|(
name|value
operator|=
name|NextInt
argument_list|(
name|fstream
argument_list|)
operator|)
operator|<
literal|0
condition|)
name|RETURN
argument_list|(
name|BitmapFileInvalid
argument_list|)
expr_stmt|;
operator|*
operator|(
name|ptr
operator|++
operator|)
operator|=
name|value
expr_stmt|;
if|if
condition|(
operator|!
name|padding
operator|||
operator|(
operator|(
name|bytes
operator|+
literal|2
operator|)
operator|%
name|bytes_per_line
operator|)
condition|)
operator|*
operator|(
name|ptr
operator|++
operator|)
operator|=
name|value
operator|>>
literal|8
expr_stmt|;
block|}
block|}
else|else
block|{
name|unsigned
name|char
modifier|*
name|ptr
decl_stmt|;
name|int
name|bytes
decl_stmt|;
for|for
control|(
name|bytes
operator|=
literal|0
operator|,
name|ptr
operator|=
name|data
init|;
name|bytes
operator|<
name|size
condition|;
name|bytes
operator|++
operator|,
name|ptr
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|value
operator|=
name|NextInt
argument_list|(
name|fstream
argument_list|)
operator|)
operator|<
literal|0
condition|)
name|RETURN
argument_list|(
name|BitmapFileInvalid
argument_list|)
expr_stmt|;
operator|*
name|ptr
operator|=
name|value
expr_stmt|;
block|}
block|}
block|}
comment|/* end while */
if|if
condition|(
name|data
operator|==
name|NULL
condition|)
block|{
name|RETURN
argument_list|(
name|BitmapFileInvalid
argument_list|)
expr_stmt|;
block|}
name|pix
operator|=
name|XCreateBitmapFromData
argument_list|(
name|display
argument_list|,
name|d
argument_list|,
operator|(
name|char
operator|*
operator|)
name|data
argument_list|,
name|ww
argument_list|,
name|hh
argument_list|)
expr_stmt|;
if|if
condition|(
name|pix
operator|==
name|None
condition|)
block|{
name|RETURN
argument_list|(
name|BitmapNoMemory
argument_list|)
expr_stmt|;
block|}
operator|*
name|pixmap
operator|=
name|pix
expr_stmt|;
operator|*
name|width
operator|=
name|ww
expr_stmt|;
operator|*
name|height
operator|=
name|hh
expr_stmt|;
if|if
condition|(
name|x_hot
condition|)
operator|*
name|x_hot
operator|=
name|hx
expr_stmt|;
if|if
condition|(
name|y_hot
condition|)
operator|*
name|y_hot
operator|=
name|hy
expr_stmt|;
name|RETURN
argument_list|(
name|BitmapSuccess
argument_list|)
expr_stmt|;
block|}
end_block

end_unit

