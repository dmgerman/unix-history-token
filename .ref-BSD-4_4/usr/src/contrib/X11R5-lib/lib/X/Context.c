begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* $XConsortium: Context.c,v 1.13 91/07/30 16:30:39 rws Exp $ */
end_comment

begin_comment
comment|/* static char *sccsid = "@(#)Context.c	1.5	2/24/87"; */
end_comment

begin_comment
comment|/*********************************************************** Copyright 1987, 1988, 1990 by Digital Equipment Corporation, Maynard, Massachusetts, and the Massachusetts Institute of Technology, Cambridge, Massachusetts.                          All Rights Reserved  Permission to use, copy, modify, and distribute this software and its  documentation for any purpose and without fee is hereby granted,  provided that the above copyright notice appear in all copies and that both that copyright notice and this permission notice appear in  supporting documentation, and that the names of Digital or MIT not be used in advertising or publicity pertaining to distribution of the software without specific, written prior permission.    DIGITAL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL DIGITAL BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  ******************************************************************/
end_comment

begin_comment
comment|/* Created by weissman, Thu Jun 26 15:18:59 1986 */
end_comment

begin_comment
comment|/* This module implements a simple sparse array.     XSaveContext(a,b,c,d) will store d in position (a,b,c) of the array.    XFindContext(a,b,c,&d) will set d to be the value in position (a,b,c).    XDeleteContext(a,b,c) will delete the entry in (a,b,c).     a is a display id, b is a resource id, and c is a Context.  d is just an    XPointer.  This code will work with any range of parameters, but is geared    to be most efficient with very few (one or two) different a's.  */
end_comment

begin_include
include|#
directive|include
file|"Xlibint.h"
end_include

begin_include
include|#
directive|include
file|"Xutil.h"
end_include

begin_define
define|#
directive|define
name|INITHASHMASK
value|63
end_define

begin_comment
comment|/* Number of entries originally in the hash table. */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|_TableEntryRec
block|{
comment|/* Stores one entry. */
name|XID
name|rid
decl_stmt|;
name|XContext
name|context
decl_stmt|;
name|XPointer
name|data
decl_stmt|;
name|struct
name|_TableEntryRec
modifier|*
name|next
decl_stmt|;
block|}
name|TableEntryRec
operator|,
typedef|*
name|TableEntry
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
name|_XContextDB
block|{
comment|/* Stores hash table for one display. */
name|TableEntry
modifier|*
name|table
decl_stmt|;
comment|/* Pointer to array of hash entries. */
name|int
name|mask
decl_stmt|;
comment|/* Current size of hash table minus 1. */
name|int
name|numentries
decl_stmt|;
comment|/* Number of entries currently in table. */
block|}
name|DBRec
operator|,
typedef|*
name|DB
typedef|;
end_typedef

begin_ifdef
ifdef|#
directive|ifdef
name|MOTIFBC
end_ifdef

begin_decl_stmt
specifier|static
name|DB
name|NullDB
init|=
operator|(
name|DB
operator|)
literal|0
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Given an XID and a context, returns a value between 0 and HashSize-1.    Currently, this requires that HashSize be a power of 2. */
end_comment

begin_define
define|#
directive|define
name|Hash
parameter_list|(
name|db
parameter_list|,
name|rid
parameter_list|,
name|context
parameter_list|)
define|\
value|(db)->table[(((rid)<< 1) + context)& (db)->mask]
end_define

begin_comment
comment|/* Resize the given db */
end_comment

begin_function
specifier|static
name|void
name|ResizeTable
parameter_list|(
name|db
parameter_list|)
specifier|register
name|DB
name|db
decl_stmt|;
block|{
name|TableEntry
modifier|*
name|otable
decl_stmt|;
specifier|register
name|TableEntry
name|entry
decl_stmt|,
name|next
decl_stmt|,
modifier|*
name|pold
decl_stmt|,
modifier|*
name|head
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|otable
operator|=
name|db
operator|->
name|table
expr_stmt|;
for|for
control|(
name|i
operator|=
name|INITHASHMASK
operator|+
literal|1
init|;
operator|(
name|i
operator|+
name|i
operator|)
operator|<
name|db
operator|->
name|numentries
condition|;
control|)
name|i
operator|+=
name|i
expr_stmt|;
name|db
operator|->
name|table
operator|=
operator|(
name|TableEntry
operator|*
operator|)
name|Xcalloc
argument_list|(
operator|(
name|unsigned
operator|)
name|i
argument_list|,
sizeof|sizeof
argument_list|(
name|TableEntry
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|db
operator|->
name|table
condition|)
block|{
name|db
operator|->
name|table
operator|=
name|otable
expr_stmt|;
return|return;
block|}
name|i
operator|=
name|db
operator|->
name|mask
operator|+
literal|1
expr_stmt|;
name|db
operator|->
name|mask
operator|=
name|i
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|pold
operator|=
name|otable
init|;
operator|--
name|i
operator|>=
literal|0
condition|;
name|pold
operator|++
control|)
block|{
for|for
control|(
name|entry
operator|=
operator|*
name|pold
init|;
name|entry
condition|;
name|entry
operator|=
name|next
control|)
block|{
name|next
operator|=
name|entry
operator|->
name|next
expr_stmt|;
name|head
operator|=
operator|&
name|Hash
argument_list|(
name|db
argument_list|,
name|entry
operator|->
name|rid
argument_list|,
name|entry
operator|->
name|context
argument_list|)
expr_stmt|;
name|entry
operator|->
name|next
operator|=
operator|*
name|head
expr_stmt|;
operator|*
name|head
operator|=
name|entry
expr_stmt|;
block|}
block|}
name|Xfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|otable
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|_XFreeContextDB
parameter_list|(
name|display
parameter_list|)
name|Display
modifier|*
name|display
decl_stmt|;
block|{
specifier|register
name|DB
name|db
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|TableEntry
modifier|*
name|pentry
decl_stmt|,
name|entry
decl_stmt|,
name|next
decl_stmt|;
if|if
condition|(
name|db
operator|=
name|display
operator|->
name|context_db
condition|)
block|{
for|for
control|(
name|i
operator|=
name|db
operator|->
name|mask
operator|+
literal|1
operator|,
name|pentry
operator|=
name|db
operator|->
name|table
init|;
operator|--
name|i
operator|>=
literal|0
condition|;
name|pentry
operator|++
control|)
block|{
for|for
control|(
name|entry
operator|=
operator|*
name|pentry
init|;
name|entry
condition|;
name|entry
operator|=
name|next
control|)
block|{
name|next
operator|=
name|entry
operator|->
name|next
expr_stmt|;
name|Xfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|entry
argument_list|)
expr_stmt|;
block|}
block|}
name|Xfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|db
operator|->
name|table
argument_list|)
expr_stmt|;
name|Xfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|db
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Public routines. */
end_comment

begin_comment
comment|/* Save the given value of data to correspond with the keys XID and context.    Returns nonzero error code if an error has occured, 0 otherwise.    Possible errors are Out-of-memory. */
end_comment

begin_if
if|#
directive|if
name|NeedFunctionPrototypes
end_if

begin_function
name|int
name|XSaveContext
parameter_list|(
name|Display
modifier|*
name|display
parameter_list|,
specifier|register
name|XID
name|rid
parameter_list|,
specifier|register
name|XContext
name|context
parameter_list|,
name|_Xconst
name|char
modifier|*
name|data
parameter_list|)
else|#
directive|else
function|int XSaveContext
parameter_list|(
name|display
parameter_list|,
name|rid
parameter_list|,
name|context
parameter_list|,
name|data
parameter_list|)
name|Display
modifier|*
name|display
decl_stmt|;
specifier|register
name|XID
name|rid
decl_stmt|;
specifier|register
name|XContext
name|context
decl_stmt|;
name|XPointer
name|data
decl_stmt|;
endif|#
directive|endif
block|{
name|DB
modifier|*
name|pdb
decl_stmt|;
specifier|register
name|DB
name|db
decl_stmt|;
name|TableEntry
modifier|*
name|head
decl_stmt|;
specifier|register
name|TableEntry
name|entry
decl_stmt|;
ifdef|#
directive|ifdef
name|MOTIFBC
if|if
condition|(
operator|!
name|display
condition|)
name|pdb
operator|=
operator|&
name|NullDB
expr_stmt|;
else|else
endif|#
directive|endif
name|pdb
operator|=
operator|&
name|display
operator|->
name|context_db
expr_stmt|;
name|db
operator|=
operator|*
name|pdb
expr_stmt|;
if|if
condition|(
operator|!
name|db
condition|)
block|{
name|db
operator|=
operator|(
name|DB
operator|)
name|Xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|DBRec
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|db
condition|)
return|return
name|XCNOMEM
return|;
name|db
operator|->
name|mask
operator|=
name|INITHASHMASK
expr_stmt|;
name|db
operator|->
name|table
operator|=
operator|(
name|TableEntry
operator|*
operator|)
name|Xcalloc
argument_list|(
name|db
operator|->
name|mask
operator|+
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|TableEntry
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|db
operator|->
name|table
condition|)
block|{
name|Xfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|db
argument_list|)
expr_stmt|;
return|return
name|XCNOMEM
return|;
block|}
name|db
operator|->
name|numentries
operator|=
literal|0
expr_stmt|;
operator|*
name|pdb
operator|=
name|db
expr_stmt|;
ifdef|#
directive|ifdef
name|MOTIFBC
if|if
condition|(
name|display
condition|)
endif|#
directive|endif
name|display
operator|->
name|free_funcs
operator|->
name|context_db
operator|=
name|_XFreeContextDB
expr_stmt|;
block|}
name|head
operator|=
operator|&
name|Hash
argument_list|(
name|db
argument_list|,
name|rid
argument_list|,
name|context
argument_list|)
expr_stmt|;
for|for
control|(
name|entry
operator|=
operator|*
name|head
init|;
name|entry
condition|;
name|entry
operator|=
name|entry
operator|->
name|next
control|)
block|{
if|if
condition|(
name|entry
operator|->
name|rid
operator|==
name|rid
operator|&&
name|entry
operator|->
name|context
operator|==
name|context
condition|)
block|{
name|entry
operator|->
name|data
operator|=
operator|(
name|XPointer
operator|)
name|data
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
name|entry
operator|=
operator|(
name|TableEntry
operator|)
name|Xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|TableEntryRec
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|entry
condition|)
return|return
name|XCNOMEM
return|;
name|entry
operator|->
name|rid
operator|=
name|rid
expr_stmt|;
name|entry
operator|->
name|context
operator|=
name|context
expr_stmt|;
name|entry
operator|->
name|data
operator|=
operator|(
name|XPointer
operator|)
name|data
expr_stmt|;
name|entry
operator|->
name|next
operator|=
operator|*
name|head
expr_stmt|;
operator|*
name|head
operator|=
name|entry
expr_stmt|;
name|db
operator|->
name|numentries
operator|++
expr_stmt|;
if|if
condition|(
name|db
operator|->
name|numentries
operator|>
operator|(
name|db
operator|->
name|mask
operator|<<
literal|2
operator|)
condition|)
name|ResizeTable
argument_list|(
name|db
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Given an XID and context, returns the associated data.  Note that data     here is a pointer since it is a return value.  Returns nonzero error code    if an error has occured, 0 otherwise.  Possible errors are Entry-not-found. */
end_comment

begin_function
name|int
name|XFindContext
parameter_list|(
name|display
parameter_list|,
name|rid
parameter_list|,
name|context
parameter_list|,
name|data
parameter_list|)
name|Display
modifier|*
name|display
decl_stmt|;
specifier|register
name|XID
name|rid
decl_stmt|;
specifier|register
name|XContext
name|context
decl_stmt|;
name|XPointer
modifier|*
name|data
decl_stmt|;
comment|/* RETURN */
block|{
specifier|register
name|DB
name|db
decl_stmt|;
specifier|register
name|TableEntry
name|entry
decl_stmt|;
ifdef|#
directive|ifdef
name|MOTIFBC
if|if
condition|(
operator|!
name|display
condition|)
name|db
operator|=
name|NullDB
expr_stmt|;
else|else
endif|#
directive|endif
name|db
operator|=
name|display
operator|->
name|context_db
expr_stmt|;
if|if
condition|(
operator|!
name|db
condition|)
return|return
name|XCNOENT
return|;
for|for
control|(
name|entry
operator|=
name|Hash
argument_list|(
name|db
argument_list|,
name|rid
argument_list|,
name|context
argument_list|)
init|;
name|entry
condition|;
name|entry
operator|=
name|entry
operator|->
name|next
control|)
block|{
if|if
condition|(
name|entry
operator|->
name|rid
operator|==
name|rid
operator|&&
name|entry
operator|->
name|context
operator|==
name|context
condition|)
block|{
operator|*
name|data
operator|=
operator|(
name|XPointer
operator|)
name|entry
operator|->
name|data
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
return|return
name|XCNOENT
return|;
block|}
end_function

begin_comment
comment|/* Deletes the entry for the given XID and context from the datastructure.    This returns the same thing that FindContext would have returned if called    with the same arguments. */
end_comment

begin_function
name|int
name|XDeleteContext
parameter_list|(
name|display
parameter_list|,
name|rid
parameter_list|,
name|context
parameter_list|)
name|Display
modifier|*
name|display
decl_stmt|;
specifier|register
name|XID
name|rid
decl_stmt|;
specifier|register
name|XContext
name|context
decl_stmt|;
block|{
specifier|register
name|DB
name|db
decl_stmt|;
specifier|register
name|TableEntry
name|entry
decl_stmt|,
modifier|*
name|prev
decl_stmt|;
ifdef|#
directive|ifdef
name|MOTIFBC
if|if
condition|(
operator|!
name|display
condition|)
name|db
operator|=
name|NullDB
expr_stmt|;
else|else
endif|#
directive|endif
name|db
operator|=
name|display
operator|->
name|context_db
expr_stmt|;
if|if
condition|(
operator|!
name|db
condition|)
return|return
name|XCNOENT
return|;
for|for
control|(
name|prev
operator|=
operator|&
name|Hash
argument_list|(
name|db
argument_list|,
name|rid
argument_list|,
name|context
argument_list|)
init|;
name|entry
operator|=
operator|*
name|prev
condition|;
name|prev
operator|=
operator|&
name|entry
operator|->
name|next
control|)
block|{
if|if
condition|(
name|entry
operator|->
name|rid
operator|==
name|rid
operator|&&
name|entry
operator|->
name|context
operator|==
name|context
condition|)
block|{
operator|*
name|prev
operator|=
name|entry
operator|->
name|next
expr_stmt|;
name|Xfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|entry
argument_list|)
expr_stmt|;
name|db
operator|->
name|numentries
operator|--
expr_stmt|;
if|if
condition|(
name|db
operator|->
name|numentries
operator|<
name|db
operator|->
name|mask
operator|&&
name|db
operator|->
name|mask
operator|>
name|INITHASHMASK
condition|)
name|ResizeTable
argument_list|(
name|db
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
return|return
name|XCNOENT
return|;
block|}
end_function

end_unit

