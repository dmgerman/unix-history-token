begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * $XConsortium: Xstreams.c,v 1.26 91/07/23 12:15:13 rws Exp $  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|STREAMSCONN
end_ifdef

begin_comment
comment|/*  * Copyright 1991 USL, Inc.  * Copyright 1991 Massachusetts Institute of Technology  * Copyright 1988, 1989 AT&T, Inc.  *  * Permission to use, copy, modify, and distribute this software and  * its documentation for any purpose and without fee is hereby  * granted, provided that the above copyright notice appear in all  * copies and that both that copyright notice and this permission  * notice appear in supporting documentation, and that the name of  * AT&T, USL, or MIT not be used in advertising or publicity  * pertaining to distribution of the software without specific,  * written prior permission.  AT&T, USL, and MIT make no  * representations about the suitability of this software for any  * purpose.  It is provided "as is" without express or implied  * warranty.  *  * AT&T, USL, AND MIT DISCLAIM ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,  * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN  * NO EVENT SHALL AT&T, USL, OR MIT BE LIABLE FOR ANY SPECIAL,  * INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER  * RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION  * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR  * IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  */
end_comment

begin_define
define|#
directive|define
name|_USHORT_H
end_define

begin_comment
comment|/* prevent conflicts between BSD sys/types.h and                            interlan/il_types.h */
end_comment

begin_define
define|#
directive|define
name|NEED_REPLIES
end_define

begin_include
include|#
directive|include
file|<X11/Xlibint.h>
end_include

begin_include
include|#
directive|include
file|<X11/Xos.h>
end_include

begin_include
include|#
directive|include
file|"Xlibnet.h"
end_include

begin_include
include|#
directive|include
file|<X11/Xauth.h>
end_include

begin_include
include|#
directive|include
file|<X11/Xproto.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<tiuser.h>
end_include

begin_comment
comment|/* TLI user defs */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/utsname.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/stropts.h>
end_include

begin_decl_stmt
specifier|extern
name|int
name|errno
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|sys_errlist
index|[]
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|SVR4
end_ifdef

begin_include
include|#
directive|include
file|<netdir.h>
end_include

begin_include
include|#
directive|include
file|<netconfig.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|__STDC__
end_ifndef

begin_comment
comment|/* buggy SVR4 include file */
end_comment

begin_function_decl
name|char
modifier|*
name|setnetpath
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|struct
name|netconfig
modifier|*
name|getnetconfigent
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|struct
name|netconfig
modifier|*
name|getnetpath
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|endnetpath
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"Xstreams.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_define
define|#
directive|define
name|PRMSG
parameter_list|(
name|x
parameter_list|,
name|a
parameter_list|,
name|b
parameter_list|)
value|fprintf(stderr, x,a,b); fflush(stderr)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|PRMSG
parameter_list|(
name|x
parameter_list|,
name|a
parameter_list|,
name|b
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|LISTEN_QUE_SIZE
value|8
end_define

begin_comment
comment|/* maximum # of connections for gen. listen */
end_comment

begin_define
define|#
directive|define
name|CLEAR
value|1
end_define

begin_comment
comment|/*  * Ridiculously high value for maximum number of connects per stream.  * Transport Provider will determine actual maximum to be used.  */
end_comment

begin_define
define|#
directive|define
name|MAXCONNECTIONS
value|100
end_define

begin_comment
comment|/* maximum # of connections for gen. listen */
end_comment

begin_define
define|#
directive|define
name|MAXLEN
value|80
end_define

begin_define
define|#
directive|define
name|BUFFERSIZE
value|2048
end_define

begin_define
define|#
directive|define
name|NOBUFFERNEEDED
value|512
end_define

begin_typedef
typedef|typedef
struct|struct
block|{
name|char
modifier|*
name|DataBuffer
decl_stmt|;
name|int
name|FirstBytePtr
decl_stmt|;
name|int
name|LastBytePtr
decl_stmt|;
block|}
name|InputBuffer
typedef|;
end_typedef

begin_ifdef
ifdef|#
directive|ifdef
name|SVR4
end_ifdef

begin_decl_stmt
name|InputBuffer
name|_XsInputBuffer
index|[
name|MAXCONNECTIONS
index|]
init|=
block|{
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_ifndef
ifndef|#
directive|ifndef
name|NOFILES_MAX
end_ifndef

begin_define
define|#
directive|define
name|NOFILES_MAX
value|128
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|InputBuffer
name|_XsInputBuffer
index|[
name|NOFILES_MAX
index|]
init|=
block|{
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SVR4*/
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|ptmx
init|=
literal|"/dev/ptmx"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|dispno
init|=
literal|"0"
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|att
end_ifdef

begin_function_decl
specifier|extern
name|char
modifier|*
name|GetXWINHome
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|char
name|_dispno
index|[
name|MAX_DISP_DIGITS
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|t_errno
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|char
modifier|*
modifier|*
name|addheader
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
modifier|*
name|addtliheader
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|struct
name|t_bind
name|bind_ret
decl_stmt|,
name|bind_req
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|t_call
name|call
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|ret_buf
index|[
name|MAXLEN
index|]
decl_stmt|,
name|req_buf
index|[
name|MAXLEN
index|]
decl_stmt|,
name|call_buf
index|[
name|MAXLEN
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|named
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* not using named streams connection */
end_comment

begin_comment
comment|/* ** The following stubs functions should be kept to keep the ** att libX11_s library (Shared library) happy. In the early versions ** of XWIN, these functions were used. */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|USL_COMPAT
end_ifdef

begin_function
name|void
name|CloseTcpStream
parameter_list|()
block|{}
end_function

begin_function
name|void
name|WriteTcpStream
parameter_list|()
block|{}
end_function

begin_function
name|void
name|ReadTcpStream
parameter_list|()
block|{}
end_function

begin_function
name|void
name|CallTcpServer
parameter_list|()
block|{}
end_function

begin_function
name|void
name|ConnectTcpClient
parameter_list|()
block|{}
end_function

begin_function
name|void
name|SetupTcpStream
parameter_list|()
block|{}
end_function

begin_function
name|int
name|CloseTliStream
parameter_list|()
block|{}
end_function

begin_function
name|int
name|WriteTliStream
parameter_list|()
block|{}
end_function

begin_function
name|int
name|ReadTliStream
parameter_list|()
block|{}
end_function

begin_function
name|int
name|CloseLocalStream
parameter_list|()
block|{}
end_function

begin_function
name|int
name|WriteLocalStream
parameter_list|()
block|{}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* USL_COMPAT */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|USL_SHARELIB
end_ifdef

begin_define
define|#
directive|define
name|fopen
value|(*_libX_fopen)
end_define

begin_function_decl
specifier|extern
name|FILE
modifier|*
name|fopen
parameter_list|()
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|t_bind
value|(*_libX_t_bind)
end_define

begin_function_decl
specifier|extern
name|int
name|t_bind
parameter_list|()
function_decl|;
end_function_decl

begin_undef
undef|#
directive|undef
name|t_bind
end_undef

begin_define
define|#
directive|define
name|_iob
value|(*_libX__iob)
end_define

begin_decl_stmt
specifier|extern
name|FILE
name|_iob
index|[]
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* USL_SHARELIB */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|t_errno
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|SYSV
end_ifdef

begin_define
define|#
directive|define
name|SIGNAL_T
value|int
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|SIGNAL_T
value|void
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_typedef
typedef|typedef
name|SIGNAL_T
function_decl|(
modifier|*
name|PFV
function_decl|)
parameter_list|()
function_decl|;
end_typedef

begin_function_decl
specifier|extern
name|PFV
name|signal
parameter_list|()
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|SUCCESS
value|"1"
end_define

begin_decl_stmt
specifier|extern
name|char
name|_XsTypeOfStream
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|Xstream
name|_XsStream
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|networkInfo
name|Network
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|NameServer
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|int
name|CallTheNameServer
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|checkNewEvent
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|OpenVirtualCircuit
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|LookForEvents
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|CheckListenQue
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|void
name|ClearCall
argument_list|()
decl_stmt|,
name|RemoveCall
argument_list|()
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|int
name|OpenLocalServer
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|OpenNamedServer
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|nameserver
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* Routines everybody shares */
end_comment

begin_macro
name|_XsErrorCall
argument_list|()
end_macro

begin_block
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"ErrorCall: invalid or unsupported subroutine call\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Following are some general queueing routines.  The call list head contains  * a pointer to the head of the queue and to the tail of the queue.  Normally,  * calls are added to the tail and removed from the head to ensure they are  * processed in the order received, however, because of the possible interruption  * of an acceptance with the resulting requeueing, it is necessary to have a  * way to do a "priority queueing" which inserts at the head of the queue for  * immediate processing  */
end_comment

begin_comment
comment|/*  * Que:  *  * add calls to tail of queue  */
end_comment

begin_function
specifier|static
name|void
name|Que
parameter_list|(
name|head
parameter_list|,
name|lc
parameter_list|,
name|flag
parameter_list|)
specifier|register
name|struct
name|listenQue
modifier|*
name|head
decl_stmt|;
specifier|register
name|struct
name|listenCall
modifier|*
name|lc
decl_stmt|;
name|char
name|flag
decl_stmt|;
block|{
if|if
condition|(
name|flag
operator|==
name|CLEAR
condition|)
name|ClearCall
argument_list|(
name|lc
operator|->
name|CurrentCall
argument_list|)
expr_stmt|;
if|if
condition|(
name|head
operator|->
name|QueTail
operator|==
operator|(
expr|struct
name|listenCall
operator|*
operator|)
name|NULL
condition|)
block|{
name|lc
operator|->
name|NextCall
operator|=
operator|(
expr|struct
name|listenCall
operator|*
operator|)
name|NULL
expr_stmt|;
name|head
operator|->
name|QueHead
operator|=
name|head
operator|->
name|QueTail
operator|=
name|lc
expr_stmt|;
block|}
else|else
block|{
name|lc
operator|->
name|NextCall
operator|=
name|head
operator|->
name|QueTail
operator|->
name|NextCall
expr_stmt|;
name|head
operator|->
name|QueTail
operator|->
name|NextCall
operator|=
name|lc
expr_stmt|;
name|head
operator|->
name|QueTail
operator|=
name|lc
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * pQue:  *  * priority queuer, add calls to head of queue  */
end_comment

begin_function
specifier|static
name|void
name|pQue
parameter_list|(
name|head
parameter_list|,
name|lc
parameter_list|)
specifier|register
name|struct
name|listenQue
modifier|*
name|head
decl_stmt|;
specifier|register
name|struct
name|listenCall
modifier|*
name|lc
decl_stmt|;
block|{
if|if
condition|(
name|head
operator|->
name|QueHead
operator|==
operator|(
expr|struct
name|listenCall
operator|*
operator|)
name|NULL
condition|)
block|{
name|lc
operator|->
name|NextCall
operator|=
operator|(
expr|struct
name|listenCall
operator|*
operator|)
name|NULL
expr_stmt|;
name|head
operator|->
name|QueHead
operator|=
name|head
operator|->
name|QueTail
operator|=
name|lc
expr_stmt|;
block|}
else|else
block|{
name|lc
operator|->
name|NextCall
operator|=
name|head
operator|->
name|QueHead
expr_stmt|;
name|head
operator|->
name|QueHead
operator|=
name|lc
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * dequeue:  *  * remove a call from the head of queue  */
end_comment

begin_function
specifier|static
name|struct
name|listenCall
modifier|*
name|deQue
parameter_list|(
name|head
parameter_list|)
specifier|register
name|struct
name|listenQue
modifier|*
name|head
decl_stmt|;
block|{
specifier|register
name|struct
name|listenCall
modifier|*
name|ret
decl_stmt|;
if|if
condition|(
name|head
operator|->
name|QueHead
operator|==
operator|(
expr|struct
name|listenCall
operator|*
operator|)
name|NULL
condition|)
block|{
name|PRMSG
argument_list|(
literal|"Fatal error. Queue is empty (shouldn't happen)\n"
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|ret
operator|=
name|head
operator|->
name|QueHead
expr_stmt|;
name|head
operator|->
name|QueHead
operator|=
name|ret
operator|->
name|NextCall
expr_stmt|;
if|if
condition|(
name|head
operator|->
name|QueHead
operator|==
operator|(
expr|struct
name|listenCall
operator|*
operator|)
name|NULL
condition|)
name|head
operator|->
name|QueTail
operator|=
operator|(
expr|struct
name|listenCall
operator|*
operator|)
name|NULL
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Routines for handling local Named streams  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|SVR4
end_ifdef

begin_macro
name|_XsSetupNamedStream
argument_list|(
argument|display
argument_list|,
argument|stype
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|display
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|stype
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|munix
decl_stmt|,
name|sunix
decl_stmt|;
name|char
modifier|*
name|slave
decl_stmt|;
name|char
name|buf
index|[
name|MAX_AUTO_BUF_LEN
index|]
decl_stmt|;
name|int
name|type
init|=
name|X_NAMED_STREAM
decl_stmt|;
name|int
name|fld
index|[
literal|2
index|]
decl_stmt|,
name|ret
decl_stmt|;
name|struct
name|stat
name|sbuf
decl_stmt|;
name|PRMSG
argument_list|(
literal|"Calling SetupNamedStream()\n"
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* if file not there create it, depends on SetupLocalStream to decide whether    server already running  , no checking is done here */
name|munix
operator|=
name|atoi
argument_list|(
name|display
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%s.%d"
argument_list|,
name|NAMED_LISTENER
argument_list|,
name|munix
argument_list|)
expr_stmt|;
name|PRMSG
argument_list|(
literal|"Calling SetupNamedStream()-(%s)\n"
argument_list|,
name|buf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|buf
argument_list|,
operator|&
name|sbuf
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|ENOENT
condition|)
block|{
if|if
condition|(
operator|(
name|munix
operator|=
name|creat
argument_list|(
name|buf
argument_list|,
operator|(
name|mode_t
operator|)
literal|0666
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
name|PRMSG
argument_list|(
literal|" Can't create: %s\n"
argument_list|,
name|buf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|close
argument_list|(
name|munix
argument_list|)
expr_stmt|;
if|if
condition|(
name|chmod
argument_list|(
name|buf
argument_list|,
operator|(
name|mode_t
operator|)
literal|0666
argument_list|)
operator|<
literal|0
condition|)
block|{
name|PRMSG
argument_list|(
literal|"Cannot chmod %s"
argument_list|,
name|buf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|perror
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
else|else
block|{
name|PRMSG
argument_list|(
literal|"stat err=%d,-%s\n"
argument_list|,
name|errno
argument_list|,
name|sys_errlist
index|[
name|errno
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
if|if
condition|(
name|pipe
argument_list|(
name|fld
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"pipe failed, errno=%d:%s\n"
argument_list|,
name|errno
argument_list|,
name|sys_errlist
index|[
name|errno
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|ret
operator|=
name|ioctl
argument_list|(
name|fld
index|[
literal|0
index|]
argument_list|,
name|I_PUSH
argument_list|,
literal|"connld"
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"ioctl error:%s\n"
argument_list|,
name|sys_errlist
index|[
name|errno
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|fattach
argument_list|(
name|fld
index|[
literal|0
index|]
argument_list|,
name|buf
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"fattach failed:%s\n"
argument_list|,
name|sys_errlist
index|[
name|errno
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|_XsTypeOfStream
index|[
name|fld
index|[
literal|1
index|]
index|]
operator|=
name|type
expr_stmt|;
name|NetworkInfo
operator|->
name|_nnets
operator|++
expr_stmt|;
return|return
operator|(
name|fld
index|[
literal|1
index|]
operator|)
return|;
block|}
end_block

begin_comment
comment|/* Enhanced Application Compatibility Support */
end_comment

begin_function
name|int
name|_XsSetupSpStream
parameter_list|(
name|display
parameter_list|,
name|stype
parameter_list|)
name|char
modifier|*
name|display
decl_stmt|;
name|char
modifier|*
name|stype
decl_stmt|;
block|{ }
end_function

begin_function
name|int
name|_XsConnectSpClient
parameter_list|(
name|connmaster
parameter_list|)
comment|/* Add connection to new slave */
name|int
name|connmaster
decl_stmt|;
comment|/* Master request connection */
block|{ }
end_function

begin_comment
comment|/* End Enhanced Application Compatibility Support */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SVR4 */
end_comment

begin_comment
comment|/* Routines for handling local streams (streams-pipes) */
end_comment

begin_macro
name|_XsSetupLocalStream
argument_list|(
argument|display
argument_list|,
argument|stype
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|display
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|stype
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|munix
decl_stmt|,
name|sunix
decl_stmt|;
name|char
modifier|*
name|slave
decl_stmt|;
name|char
name|buf
index|[
name|MAX_AUTO_BUF_LEN
index|]
decl_stmt|;
name|int
name|type
init|=
name|X_LOCAL_STREAM
decl_stmt|;
name|int
name|nameserver
parameter_list|()
function_decl|;
name|PRMSG
argument_list|(
literal|"Calling SetupLocalStream()\n"
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|SetupNetworkInfo
argument_list|()
expr_stmt|;
name|dispno
operator|=
name|display
expr_stmt|;
name|NetworkInfo
operator|->
name|_nnets
operator|=
name|NetworkInfo
operator|->
name|_npeers
operator|=
literal|0
expr_stmt|;
name|NetworkInfo
operator|->
name|_peer
operator|=
name|NULL
expr_stmt|;
name|NetworkInfo
operator|->
name|_peerlen
operator|=
name|NULL
expr_stmt|;
ifdef|#
directive|ifdef
name|SVR4
name|NetworkInfo
operator|->
name|_net
index|[
literal|0
index|]
operator|=
operator|(
expr|struct
name|netconfig
operator|*
operator|)
literal|0
expr_stmt|;
else|#
directive|else
name|NetworkInfo
operator|->
name|_net
index|[
literal|0
index|]
operator|=
operator|(
name|char
operator|*
operator|)
literal|0
expr_stmt|;
endif|#
directive|endif
name|NetworkInfo
operator|->
name|_nnets
operator|++
expr_stmt|;
name|munix
operator|=
name|atoi
argument_list|(
name|display
argument_list|)
expr_stmt|;
comment|/* 	if(munix != 0){ 		fprintf(stderr, "Only display # 0 can be used on this server\n"); 		return(-1); 		} */
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%s.%d"
argument_list|,
name|LOCAL_LISTENER
argument_list|,
name|munix
argument_list|)
expr_stmt|;
comment|/* 	if(open(buf, O_RDWR)>= 0){ 		fprintf(stderr, "Server is already running\n"); 		return(-1); 		} */
if|if
condition|(
operator|(
name|munix
operator|=
name|open
argument_list|(
name|ptmx
argument_list|,
name|O_RDWR
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Cannot open %s"
argument_list|,
name|ptmx
argument_list|)
expr_stmt|;
name|perror
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|grantpt
argument_list|(
name|munix
argument_list|)
expr_stmt|;
name|unlockpt
argument_list|(
name|munix
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlink
argument_list|(
name|buf
argument_list|)
operator|<
literal|0
operator|&&
name|errno
operator|!=
name|ENOENT
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Cannot unlink %s"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|perror
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
operator|!
operator|(
name|slave
operator|=
operator|(
name|char
operator|*
operator|)
name|ptsname
argument_list|(
name|munix
argument_list|)
operator|)
condition|)
block|{
name|close
argument_list|(
name|munix
argument_list|)
expr_stmt|;
name|perror
argument_list|(
literal|"Cannot get slave pt-name"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|link
argument_list|(
name|slave
argument_list|,
name|buf
argument_list|)
operator|<
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Cannot link %s to %s"
argument_list|,
name|slave
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|perror
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|chmod
argument_list|(
name|buf
argument_list|,
literal|0666
argument_list|)
operator|<
literal|0
condition|)
block|{
name|close
argument_list|(
name|munix
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Cannot chmod %s"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|perror
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|sunix
operator|=
name|open
argument_list|(
name|buf
argument_list|,
name|O_RDWR
argument_list|)
expr_stmt|;
if|if
condition|(
name|sunix
operator|<
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Cannot open %s"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|perror
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|munix
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|_XsTypeOfStream
index|[
name|munix
index|]
operator|=
name|type
expr_stmt|;
name|_XsTypeOfStream
index|[
name|sunix
index|]
operator|=
name|CLOSED_STREAM
expr_stmt|;
return|return
operator|(
name|munix
operator|)
return|;
block|}
end_block

begin_macro
name|_XsConnectLocalClient
argument_list|(
argument|ufd
argument_list|,
argument|MoreConnections
argument_list|)
end_macro

begin_decl_stmt
name|int
name|ufd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|MoreConnections
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|fd
decl_stmt|;
name|int
name|read_in
decl_stmt|;
name|unsigned
name|char
name|length
decl_stmt|;
name|char
name|buf
index|[
name|MAX_AUTO_BUF_LEN
index|]
decl_stmt|;
ifdef|#
directive|ifdef
name|SVR4
name|struct
name|strrecvfd
name|str
decl_stmt|;
endif|#
directive|endif
name|PRMSG
argument_list|(
literal|"Calling ConnectLocalClient(%d)\n"
argument_list|,
name|ufd
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* MoreConnections is set to zero because if any more connections are underway  * select() will return immediately. It is nicer if we can process all connections  * that exist the way we handle TLI connections by setting MoreConnections.  * May be I will end up doing it later.  */
operator|*
name|MoreConnections
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|SVR4
if|if
condition|(
name|_XsTypeOfStream
index|[
name|ufd
index|]
operator|==
name|X_NAMED_STREAM
condition|)
block|{
name|PRMSG
argument_list|(
literal|"Calling ConnectLocalClient(%d) - thru named streams\n"
argument_list|,
name|ufd
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|ufd
argument_list|,
name|I_RECVFD
argument_list|,
operator|&
name|str
argument_list|)
operator|<
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"I_RECVFD failed\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|_XsTypeOfStream
index|[
name|str
operator|.
name|fd
index|]
operator|=
name|_XsTypeOfStream
index|[
name|ufd
index|]
expr_stmt|;
name|PRMSG
argument_list|(
literal|"ConnectNamedClient(%d) return success\n"
argument_list|,
name|str
operator|.
name|fd
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|str
operator|.
name|fd
operator|)
return|;
block|}
comment|/* Enhanced Application Compatibility Support */
comment|/* End Enhanced Application Compatibility Support */
endif|#
directive|endif
comment|/* SVR4 */
name|PRMSG
argument_list|(
literal|"Calling ConnectLocalClient(%d) - thru psuedo tty\n"
argument_list|,
name|ufd
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|read_in
operator|=
name|read
argument_list|(
name|ufd
argument_list|,
operator|&
name|length
argument_list|,
literal|1
argument_list|)
operator|)
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|read_in
condition|)
comment|/* client closed fd */
name|perror
argument_list|(
literal|"0 bytes read"
argument_list|)
expr_stmt|;
else|else
name|perror
argument_list|(
literal|"Error in reading the local connection msg length"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|read_in
operator|=
name|read
argument_list|(
name|ufd
argument_list|,
name|buf
argument_list|,
name|length
argument_list|)
operator|)
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|read_in
condition|)
comment|/* client closed fd */
name|perror
argument_list|(
literal|"0 bytes read"
argument_list|)
expr_stmt|;
else|else
name|perror
argument_list|(
literal|"Error in reading the local connection slave name"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|buf
index|[
name|length
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|(
name|fd
operator|=
name|open
argument_list|(
name|buf
argument_list|,
name|O_RDWR
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|strcat
argument_list|(
name|buf
argument_list|,
literal|" open fail, clientfd"
argument_list|)
expr_stmt|;
name|perror
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|write
argument_list|(
name|fd
argument_list|,
name|SUCCESS
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|_XsTypeOfStream
index|[
name|fd
index|]
operator|=
name|_XsTypeOfStream
index|[
name|ufd
index|]
expr_stmt|;
name|PRMSG
argument_list|(
literal|"ConnectLocalClient(%d) return success\n"
argument_list|,
name|ufd
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|fd
operator|)
return|;
block|}
end_block

begin_function
specifier|static
name|void
name|dummy
parameter_list|(
name|sig
parameter_list|)
name|int
name|sig
decl_stmt|;
block|{ }
end_function

begin_macro
name|_XsCallLocalServer
argument_list|(
argument|host
argument_list|,
argument|idisplay
argument_list|,
argument|nettype
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|host
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|idisplay
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|SVR4
end_ifdef

begin_decl_stmt
name|struct
name|netconfig
modifier|*
name|nettype
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_decl_stmt
name|char
modifier|*
name|nettype
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_block
block|{
name|char
name|buf
index|[
name|MAX_AUTO_BUF_LEN
index|]
decl_stmt|;
name|char
modifier|*
name|listener
decl_stmt|;
name|int
name|type
init|=
name|X_LOCAL_STREAM
decl_stmt|;
name|int
name|fd
decl_stmt|;
name|PRMSG
argument_list|(
literal|"Calling CallLocalServer(%s)\n"
argument_list|,
name|host
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|_dispno
argument_list|,
literal|"%d"
argument_list|,
name|idisplay
argument_list|)
expr_stmt|;
name|dispno
operator|=
name|_dispno
expr_stmt|;
comment|/* 	 * Open channel to server 	 */
ifdef|#
directive|ifdef
name|SVR4
if|if
condition|(
name|strncmp
argument_list|(
literal|"NAMED"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|getenv
argument_list|(
literal|"XLOCAL"
argument_list|)
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
condition|)
block|{
name|named
operator|=
literal|1
expr_stmt|;
name|type
operator|=
name|X_NAMED_STREAM
expr_stmt|;
name|listener
operator|=
name|NAMED_LISTENER
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%s.%d"
argument_list|,
name|listener
argument_list|,
name|idisplay
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fd
operator|=
name|OpenNamedServer
argument_list|(
name|buf
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|PRMSG
argument_list|(
literal|"Cannot open %s\n"
argument_list|,
name|buf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|perror
argument_list|(
literal|"XIO"
argument_list|)
expr_stmt|;
comment|/* Sorry, but I don't have the dpy handy */
endif|#
directive|endif
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
comment|/* Enhanced Application Compatibility Support */
comment|/* End Enhanced Application Compatibility Support */
endif|#
directive|endif
if|if
condition|(
operator|!
name|named
condition|)
block|{
name|type
operator|=
name|X_LOCAL_STREAM
expr_stmt|;
name|listener
operator|=
name|LOCAL_LISTENER
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%s.%d"
argument_list|,
name|listener
argument_list|,
name|idisplay
argument_list|)
expr_stmt|;
name|PRMSG
argument_list|(
literal|"buf for local listener %s\n"
argument_list|,
name|buf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fd
operator|=
name|OpenLocalServer
argument_list|(
name|buf
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|PRMSG
argument_list|(
literal|"Cannot open %s\n"
argument_list|,
name|buf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|perror
argument_list|(
literal|"XIO"
argument_list|)
expr_stmt|;
comment|/* Sorry, but I don't have the dpy handy */
endif|#
directive|endif
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
name|_XsTypeOfStream
index|[
name|fd
index|]
operator|=
name|type
expr_stmt|;
if|if
condition|(
name|_XsInputBuffer
index|[
name|fd
index|]
operator|.
name|DataBuffer
operator|==
name|NULL
condition|)
if|if
condition|(
operator|(
name|_XsInputBuffer
index|[
name|fd
index|]
operator|.
name|DataBuffer
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|BUFFERSIZE
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|errno
operator|=
name|ENOMEM
expr_stmt|;
name|perror
argument_list|(
literal|"Client can't connect to local server"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|_XsInputBuffer
index|[
name|fd
index|]
operator|.
name|LastBytePtr
operator|=
literal|0
expr_stmt|;
name|_XsInputBuffer
index|[
name|fd
index|]
operator|.
name|FirstBytePtr
operator|=
literal|0
expr_stmt|;
name|PRMSG
argument_list|(
literal|"Calling CallLocalServer(%s) return success\n"
argument_list|,
name|host
argument_list|,
name|fd
argument_list|)
expr_stmt|;
return|return
operator|(
name|fd
operator|)
return|;
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|SVR4
end_ifdef

begin_function
specifier|static
name|int
name|OpenNamedServer
parameter_list|(
name|node
parameter_list|)
name|char
modifier|*
name|node
decl_stmt|;
block|{
name|int
name|fld
decl_stmt|;
name|PRMSG
argument_list|(
literal|"Calling 4.0 -- opening (%s)\n"
argument_list|,
name|node
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fld
operator|=
name|open
argument_list|(
name|node
argument_list|,
name|O_RDWR
argument_list|)
expr_stmt|;
if|if
condition|(
name|fld
operator|<
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"OpenNamedServer failed:%s\n"
argument_list|,
name|sys_errlist
index|[
name|errno
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|isastream
argument_list|(
name|fld
argument_list|)
operator|!=
literal|1
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"OpenNamedServer failed: %s is not a NamedStream\n"
argument_list|,
name|node
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
return|return
operator|(
name|fld
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Enhanced Application Compatibility Support */
end_comment

begin_function
specifier|static
name|int
name|_XsOpenSpServer
parameter_list|(
name|node
parameter_list|)
name|char
modifier|*
name|node
decl_stmt|;
block|{ }
end_function

begin_comment
comment|/* End Enhanced Application Compatibility Support */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SVR4 */
end_comment

begin_function
specifier|static
name|int
name|OpenLocalServer
parameter_list|(
name|node
parameter_list|)
name|char
modifier|*
name|node
decl_stmt|;
block|{
name|int
name|server
decl_stmt|,
name|fd
decl_stmt|,
name|c
decl_stmt|;
name|char
name|buf
index|[
name|MAX_AUTO_BUF_LEN
index|]
decl_stmt|,
modifier|*
name|slave
decl_stmt|;
name|PFV
name|savef
decl_stmt|;
if|if
condition|(
operator|(
name|server
operator|=
name|open
argument_list|(
name|node
argument_list|,
name|O_RDWR
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"open(%s) failed\n"
argument_list|,
name|node
argument_list|)
expr_stmt|;
name|perror
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* 	 * Open streams based pipe and get slave name 	 */
if|if
condition|(
operator|(
name|fd
operator|=
name|open
argument_list|(
name|ptmx
argument_list|,
name|O_RDWR
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|close
argument_list|(
name|server
argument_list|)
expr_stmt|;
name|PRMSG
argument_list|(
literal|"Cannot open %s\n"
argument_list|,
name|ptmx
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|grantpt
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|unlockpt
argument_list|(
name|fd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|slave
operator|=
operator|(
name|char
operator|*
operator|)
name|ptsname
argument_list|(
name|fd
argument_list|)
operator|)
condition|)
block|{
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|server
argument_list|)
expr_stmt|;
name|PRMSG
argument_list|(
literal|"Cannot get slave pt-name"
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|chmod
argument_list|(
name|slave
argument_list|,
literal|0666
argument_list|)
operator|<
literal|0
condition|)
block|{
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|server
argument_list|)
expr_stmt|;
name|PRMSG
argument_list|(
literal|"Cannot chmod %s\n"
argument_list|,
name|buf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|c
operator|=
name|strlen
argument_list|(
name|slave
argument_list|)
expr_stmt|;
name|buf
index|[
literal|0
index|]
operator|=
name|c
expr_stmt|;
name|sprintf
argument_list|(
operator|&
name|buf
index|[
literal|1
index|]
argument_list|,
name|slave
argument_list|)
expr_stmt|;
comment|/* 	 * write slave name to server 	 */
name|write
argument_list|(
name|server
argument_list|,
name|buf
argument_list|,
name|c
operator|+
literal|1
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|server
argument_list|)
expr_stmt|;
comment|/* 	 * wait for server to respond 	 */
name|savef
operator|=
name|signal
argument_list|(
name|SIGALRM
argument_list|,
name|dummy
argument_list|)
expr_stmt|;
name|alarm
argument_list|(
name|CONNECT_TIMEOUT
argument_list|)
expr_stmt|;
if|if
condition|(
name|read
argument_list|(
name|fd
argument_list|,
operator|&
name|c
argument_list|,
literal|1
argument_list|)
operator|!=
literal|1
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"No reply from the server.\n"
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|fd
operator|=
operator|-
literal|1
expr_stmt|;
block|}
name|alarm
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGALRM
argument_list|,
name|savef
argument_list|)
expr_stmt|;
return|return
operator|(
name|fd
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_expr_stmt
specifier|static
name|dumpBytes
argument_list|(
argument|len
argument_list|,
argument|data
argument_list|)
name|int
name|len
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|char
modifier|*
name|data
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|i
decl_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%d: "
argument_list|,
name|len
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%02x "
argument_list|,
name|data
index|[
name|i
index|]
operator|&
literal|0377
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|XSTREAMS_COMPILE
end_define

begin_comment
comment|/* magic symbol to avoid lint problems */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|SVR4
end_ifdef

begin_include
include|#
directive|include
file|"nameaddr.c"
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|"nameserver.c"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_undef
undef|#
directive|undef
name|XSTREAMS_COMPILE
end_undef

begin_macro
name|_XsReadLocalStream
argument_list|(
argument|fd
argument_list|,
argument|buf
argument_list|,
argument|count
argument_list|,
argument|do_buffering
argument_list|)
end_macro

begin_decl_stmt
name|int
name|fd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|buf
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|count
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|do_buffering
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|amount
decl_stmt|;
name|InputBuffer
modifier|*
name|ioptr
init|=
operator|&
name|_XsInputBuffer
index|[
name|fd
index|]
decl_stmt|;
if|if
condition|(
name|do_buffering
operator|==
name|NO_BUFFERING
condition|)
block|{
name|amount
operator|=
name|read
argument_list|(
name|fd
argument_list|,
name|buf
argument_list|,
name|count
argument_list|)
expr_stmt|;
return|return
operator|(
name|amount
operator|)
return|;
block|}
if|if
condition|(
name|ioptr
operator|->
name|LastBytePtr
operator|<=
name|ioptr
operator|->
name|FirstBytePtr
condition|)
block|{
name|errno
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|count
operator|>
name|BUFFERSIZE
condition|)
block|{
name|ioptr
operator|->
name|LastBytePtr
operator|=
name|ioptr
operator|->
name|FirstBytePtr
operator|=
literal|0
expr_stmt|;
name|amount
operator|=
name|read
argument_list|(
name|fd
argument_list|,
name|buf
argument_list|,
name|count
argument_list|)
expr_stmt|;
return|return
operator|(
name|amount
operator|)
return|;
block|}
name|ioptr
operator|->
name|LastBytePtr
operator|=
name|read
argument_list|(
name|fd
argument_list|,
name|ioptr
operator|->
name|DataBuffer
argument_list|,
name|BUFFERSIZE
argument_list|)
expr_stmt|;
name|ioptr
operator|->
name|FirstBytePtr
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|ioptr
operator|->
name|LastBytePtr
operator|>
literal|0
condition|)
block|{
name|amount
operator|=
name|ioptr
operator|->
name|LastBytePtr
operator|-
name|ioptr
operator|->
name|FirstBytePtr
expr_stmt|;
name|amount
operator|=
name|amount
operator|>
name|count
condition|?
name|count
else|:
name|amount
expr_stmt|;
name|memcpy
argument_list|(
name|buf
argument_list|,
operator|&
name|ioptr
operator|->
name|DataBuffer
index|[
name|ioptr
operator|->
name|FirstBytePtr
index|]
argument_list|,
name|amount
argument_list|)
expr_stmt|;
name|ioptr
operator|->
name|FirstBytePtr
operator|+=
name|amount
expr_stmt|;
return|return
name|amount
return|;
block|}
else|else
block|{
return|return
operator|(
name|ioptr
operator|->
name|LastBytePtr
operator|)
return|;
block|}
block|}
end_block

begin_macro
name|_XsWriteLocalStream
argument_list|(
argument|fd
argument_list|,
argument|buf
argument_list|,
argument|count
argument_list|)
end_macro

begin_decl_stmt
name|int
name|fd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|buf
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|count
decl_stmt|;
end_decl_stmt

begin_block
block|{
comment|/* obsolete code */
return|return
operator|(
name|write
argument_list|(
name|fd
argument_list|,
name|buf
argument_list|,
name|count
argument_list|)
operator|)
return|;
block|}
end_block

begin_macro
name|_XsCloseLocalStream
argument_list|(
argument|fd
argument_list|)
end_macro

begin_decl_stmt
name|int
name|fd
decl_stmt|;
end_decl_stmt

begin_block
block|{
comment|/* obvsolete code */
return|return
operator|(
name|close
argument_list|(
name|fd
argument_list|)
operator|)
return|;
block|}
end_block

begin_macro
name|_XsConnectTliClient
argument_list|(
argument|sfd
argument_list|,
argument|MoreConnections
argument_list|)
end_macro

begin_decl_stmt
name|int
name|sfd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|MoreConnections
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
name|type
init|=
name|_XsTypeOfStream
index|[
name|sfd
index|]
decl_stmt|;
specifier|register
name|struct
name|listenQue
modifier|*
name|freeq
decl_stmt|,
modifier|*
name|pendq
decl_stmt|;
name|freeq
operator|=
operator|&
name|Network
operator|.
name|FreeList
index|[
name|type
index|]
expr_stmt|;
name|pendq
operator|=
operator|&
name|Network
operator|.
name|PendingQue
index|[
name|type
index|]
expr_stmt|;
name|PRMSG
argument_list|(
literal|"Calling ConnectTliClient(%d)\n"
argument_list|,
name|sfd
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|LookForEvents
argument_list|(
name|freeq
argument_list|,
name|pendq
argument_list|,
name|sfd
argument_list|)
expr_stmt|;
return|return
operator|(
name|CheckListenQue
argument_list|(
name|freeq
argument_list|,
name|pendq
argument_list|,
name|sfd
argument_list|,
name|MoreConnections
argument_list|)
operator|)
return|;
block|}
end_block

begin_function
specifier|static
name|void
name|checkNewEvent
parameter_list|(
name|fd
parameter_list|)
name|int
name|fd
decl_stmt|;
block|{
name|int
name|t
decl_stmt|;
name|t
operator|=
name|t_look
argument_list|(
name|fd
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|t
condition|)
block|{
case|case
name|T_DATA
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"T_DATA received\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|T_EXDATA
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"T_EXDATA received\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|T_DISCONNECT
case|:
name|t_rcvdis
argument_list|(
name|fd
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"T_DISCONNECT received\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|T_ERROR
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"T_ERROR received\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|T_UDERR
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"T_UDERR received\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|T_ORDREL
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"T_ORDREL received\n"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_macro
name|_XsReadTliStream
argument_list|(
argument|fd
argument_list|,
argument|buf
argument_list|,
argument|count
argument_list|,
argument|do_buffering
argument_list|)
end_macro

begin_decl_stmt
name|int
name|fd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|buf
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|count
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|do_buffering
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|n
decl_stmt|;
name|int
name|flags
decl_stmt|;
comment|/* obsolete code */
block|}
end_block

begin_macro
name|_XsWriteTliStream
argument_list|(
argument|fd
argument_list|,
argument|buf
argument_list|,
argument|count
argument_list|)
end_macro

begin_decl_stmt
name|int
name|fd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|buf
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|count
decl_stmt|;
end_decl_stmt

begin_block
block|{
comment|/* obsolete code */
block|}
end_block

begin_function
specifier|static
name|void
name|OnError
parameter_list|(
name|sig
parameter_list|)
name|int
name|sig
decl_stmt|;
block|{ }
end_function

begin_macro
name|_XsCloseTliStream
argument_list|(
argument|fd
argument_list|)
end_macro

begin_decl_stmt
name|int
name|fd
decl_stmt|;
end_decl_stmt

begin_block
block|{
comment|/* obsolete code */
block|}
end_block

begin_comment
comment|/*  * LookForEvents:	handle an asynchronous event  */
end_comment

begin_function
specifier|static
name|void
name|LookForEvents
parameter_list|(
name|FreeHead
parameter_list|,
name|PendHead
parameter_list|,
name|fd
parameter_list|)
name|struct
name|listenQue
modifier|*
name|FreeHead
decl_stmt|;
name|struct
name|listenQue
modifier|*
name|PendHead
decl_stmt|;
name|int
name|fd
decl_stmt|;
block|{
name|int
name|address
decl_stmt|;
name|short
name|port
decl_stmt|,
name|nf
decl_stmt|;
name|struct
name|t_discon
name|disc
decl_stmt|;
specifier|register
name|struct
name|listenCall
modifier|*
name|current
decl_stmt|;
specifier|register
name|struct
name|t_call
modifier|*
name|call
decl_stmt|;
name|int
name|t
decl_stmt|;
name|char
name|buf
index|[
name|MAX_AUTO_BUF_LEN
index|]
decl_stmt|;
name|int
name|flag
decl_stmt|,
name|i
decl_stmt|;
if|if
condition|(
operator|(
name|t
operator|=
name|t_look
argument_list|(
name|fd
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|PRMSG
argument_list|(
literal|"t_look failed. t_errno %d\n"
argument_list|,
name|t_errno
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
switch|switch
condition|(
name|t
condition|)
block|{
case|case
literal|0
case|:
name|PRMSG
argument_list|(
literal|"t_look 0\n"
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
comment|/* no return */
case|case
name|T_LISTEN
case|:
name|PRMSG
argument_list|(
literal|"t_look T_LISTEN\n"
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|current
operator|=
name|deQue
argument_list|(
name|FreeHead
argument_list|)
expr_stmt|;
name|call
operator|=
name|current
operator|->
name|CurrentCall
expr_stmt|;
if|if
condition|(
name|t_listen
argument_list|(
name|fd
argument_list|,
name|call
argument_list|)
operator|<
literal|0
condition|)
block|{
name|PRMSG
argument_list|(
literal|"t_listen failed\n"
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
name|Que
argument_list|(
name|PendHead
argument_list|,
name|current
argument_list|,
operator|~
name|CLEAR
argument_list|)
expr_stmt|;
name|PRMSG
argument_list|(
literal|"incoming call seq # %d"
argument_list|,
name|call
operator|->
name|sequence
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|T_DISCONNECT
case|:
name|PRMSG
argument_list|(
literal|"t_look T_DISCONNECT\n"
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|t_rcvdis
argument_list|(
name|fd
argument_list|,
operator|&
name|disc
argument_list|)
operator|<
literal|0
condition|)
block|{
name|PRMSG
argument_list|(
literal|"Received T_DISCONNECT but t_rcvdis failed\n"
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|PRMSG
argument_list|(
literal|"incoming disconnect seq # %d"
argument_list|,
name|disc
operator|.
name|sequence
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|RemoveCall
argument_list|(
name|FreeHead
argument_list|,
name|PendHead
argument_list|,
operator|&
name|disc
argument_list|)
expr_stmt|;
name|t_close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|_XsTypeOfStream
index|[
name|fd
index|]
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
case|case
name|T_DATA
case|:
if|if
condition|(
operator|(
name|i
operator|=
name|t_rcv
argument_list|(
name|fd
argument_list|,
name|buf
argument_list|,
name|MAX_AUTO_BUF_LEN
argument_list|,
operator|&
name|flag
argument_list|)
operator|)
operator|>
literal|0
condition|)
break|break;
default|default:
name|PRMSG
argument_list|(
literal|"t_look default %o %x\n"
argument_list|,
name|t
argument_list|,
name|t
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/*  * CheckListenQue:	try to accept a connection  */
end_comment

begin_function
specifier|static
name|int
name|CheckListenQue
parameter_list|(
name|FreeHead
parameter_list|,
name|PendHead
parameter_list|,
name|fd
parameter_list|,
name|MoreConnections
parameter_list|)
name|struct
name|listenQue
modifier|*
name|FreeHead
decl_stmt|;
name|struct
name|listenQue
modifier|*
name|PendHead
decl_stmt|;
name|int
name|fd
decl_stmt|;
name|char
modifier|*
name|MoreConnections
decl_stmt|;
block|{
specifier|register
name|struct
name|listenCall
modifier|*
name|current
decl_stmt|;
specifier|register
name|struct
name|t_call
modifier|*
name|call
decl_stmt|;
name|int
name|pid
decl_stmt|,
name|nfd
decl_stmt|,
name|n
decl_stmt|;
name|char
modifier|*
name|retptr
decl_stmt|,
modifier|*
name|ptr
decl_stmt|;
name|int
name|address
decl_stmt|;
name|short
name|port
decl_stmt|,
name|nf
decl_stmt|;
name|PRMSG
argument_list|(
literal|"in CheckListenQue"
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|EMPTY
argument_list|(
name|PendHead
argument_list|)
operator|)
condition|)
block|{
name|current
operator|=
name|deQue
argument_list|(
name|PendHead
argument_list|)
expr_stmt|;
name|call
operator|=
name|current
operator|->
name|CurrentCall
expr_stmt|;
name|PRMSG
argument_list|(
literal|"try to accept #%d"
argument_list|,
name|call
operator|->
name|sequence
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|nfd
operator|=
name|OpenVirtualCircuit
argument_list|(
name|fd
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|PRMSG
argument_list|(
literal|"OpenVirtualCircuit failed\n"
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|Que
argument_list|(
name|FreeHead
argument_list|,
name|current
argument_list|,
name|CLEAR
argument_list|)
expr_stmt|;
operator|*
name|MoreConnections
operator|=
operator|!
name|EMPTY
argument_list|(
name|PendHead
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* let transport provider generate disconnect */
block|}
name|n
operator|=
name|t_accept
argument_list|(
name|fd
argument_list|,
name|nfd
argument_list|,
name|call
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
name|PRMSG
argument_list|(
literal|"t_accept failed\n"
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|t_errno
operator|==
name|TLOOK
condition|)
block|{
name|t_close
argument_list|(
name|nfd
argument_list|)
expr_stmt|;
name|PRMSG
argument_list|(
literal|"t_accept collision"
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|PRMSG
argument_list|(
literal|"save call #%d"
argument_list|,
name|call
operator|->
name|sequence
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|pQue
argument_list|(
name|PendHead
argument_list|,
name|current
argument_list|)
expr_stmt|;
operator|*
name|MoreConnections
operator|=
operator|!
name|EMPTY
argument_list|(
name|PendHead
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
else|else
block|{
name|PRMSG
argument_list|(
literal|"t_accept failed but not t_look\n"
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|t_close
argument_list|(
name|nfd
argument_list|)
expr_stmt|;
name|Que
argument_list|(
name|FreeHead
argument_list|,
name|current
argument_list|,
name|CLEAR
argument_list|)
expr_stmt|;
operator|*
name|MoreConnections
operator|=
operator|!
name|EMPTY
argument_list|(
name|PendHead
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
name|_XsTypeOfStream
index|[
name|nfd
index|]
operator|=
name|_XsTypeOfStream
index|[
name|fd
index|]
expr_stmt|;
name|retptr
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|GetNetworkInfo
argument_list|(
name|nfd
argument_list|,
name|Network
operator|.
name|_net
index|[
name|_XsTypeOfStream
index|[
name|fd
index|]
index|]
argument_list|,
name|ConvertTliCallToName
argument_list|,
name|addtliheader
argument_list|(
name|call
argument_list|)
argument_list|,
operator|&
name|retptr
argument_list|,
name|NULL
argument_list|)
operator|<=
literal|0
condition|)
block|{
name|retptr
operator|=
name|NULL
expr_stmt|;
block|}
name|ptr
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|retptr
operator|!=
name|NULL
condition|)
block|{
name|ptr
operator|=
name|retptr
expr_stmt|;
name|retptr
operator|+=
sizeof|sizeof
argument_list|(
name|xHostEntry
argument_list|)
expr_stmt|;
block|}
name|GetNetworkInfo
argument_list|(
name|nfd
argument_list|,
name|Network
operator|.
name|_net
index|[
name|_XsTypeOfStream
index|[
name|fd
index|]
index|]
argument_list|,
name|PEER_ALLOC
argument_list|,
operator|&
name|retptr
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptr
operator|!=
name|NULL
condition|)
name|Xfree
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
name|PRMSG
argument_list|(
literal|"Accepted call %d"
argument_list|,
name|call
operator|->
name|sequence
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|PRMSG
argument_list|(
literal|"Channel %d is opened\n"
argument_list|,
name|nfd
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|Que
argument_list|(
name|FreeHead
argument_list|,
name|current
argument_list|,
name|CLEAR
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|ioctl
argument_list|(
name|nfd
argument_list|,
name|I_POP
argument_list|,
literal|"timod"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|nfd
argument_list|,
name|I_PUSH
argument_list|,
literal|"tirdwr"
argument_list|)
operator|<
literal|0
condition|)
block|{
name|t_close
argument_list|(
name|nfd
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|PRMSG
argument_list|(
literal|"Accepted call %d"
argument_list|,
name|call
operator|->
name|sequence
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|PRMSG
argument_list|(
literal|"Channel %d is opened\n"
argument_list|,
name|nfd
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|*
name|MoreConnections
operator|=
operator|!
name|EMPTY
argument_list|(
name|PendHead
argument_list|)
expr_stmt|;
return|return
operator|(
name|nfd
operator|)
return|;
block|}
operator|*
name|MoreConnections
operator|=
operator|!
name|EMPTY
argument_list|(
name|PendHead
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * ClearCall:	clear out a call structure  */
end_comment

begin_function
specifier|static
name|void
name|ClearCall
parameter_list|(
name|call
parameter_list|)
name|struct
name|t_call
modifier|*
name|call
decl_stmt|;
block|{
name|call
operator|->
name|sequence
operator|=
literal|0
expr_stmt|;
name|call
operator|->
name|addr
operator|.
name|len
operator|=
literal|0
expr_stmt|;
name|call
operator|->
name|opt
operator|.
name|len
operator|=
literal|0
expr_stmt|;
name|call
operator|->
name|udata
operator|.
name|len
operator|=
literal|0
expr_stmt|;
name|memset
argument_list|(
name|call
operator|->
name|addr
operator|.
name|buf
argument_list|,
literal|0
argument_list|,
name|call
operator|->
name|addr
operator|.
name|maxlen
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|call
operator|->
name|opt
operator|.
name|buf
argument_list|,
literal|0
argument_list|,
name|call
operator|->
name|opt
operator|.
name|maxlen
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|call
operator|->
name|udata
operator|.
name|buf
argument_list|,
literal|0
argument_list|,
name|call
operator|->
name|udata
operator|.
name|maxlen
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * RemoveCall: remove call from pending list  */
end_comment

begin_function
specifier|static
name|void
name|RemoveCall
parameter_list|(
name|freeq
parameter_list|,
name|pendq
parameter_list|,
name|disc
parameter_list|)
name|struct
name|listenQue
modifier|*
name|freeq
decl_stmt|;
name|struct
name|listenQue
modifier|*
name|pendq
decl_stmt|;
name|struct
name|t_discon
modifier|*
name|disc
decl_stmt|;
block|{
specifier|register
name|struct
name|listenCall
modifier|*
name|p
decl_stmt|,
modifier|*
name|oldp
decl_stmt|;
name|PRMSG
argument_list|(
literal|"Removing call, sequence # is %d"
argument_list|,
name|disc
operator|->
name|sequence
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|EMPTY
argument_list|(
name|pendq
argument_list|)
condition|)
block|{
name|disc
operator|->
name|sequence
operator|=
operator|-
literal|1
expr_stmt|;
return|return;
block|}
name|p
operator|=
name|pendq
operator|->
name|QueHead
expr_stmt|;
name|oldp
operator|=
operator|(
expr|struct
name|listenCall
operator|*
operator|)
name|NULL
expr_stmt|;
while|while
condition|(
name|p
condition|)
block|{
if|if
condition|(
name|p
operator|->
name|CurrentCall
operator|->
name|sequence
operator|==
name|disc
operator|->
name|sequence
condition|)
block|{
if|if
condition|(
name|oldp
operator|==
operator|(
expr|struct
name|listenCall
operator|*
operator|)
name|NULL
condition|)
block|{
name|pendq
operator|->
name|QueHead
operator|=
name|p
operator|->
name|NextCall
expr_stmt|;
if|if
condition|(
name|pendq
operator|->
name|QueHead
operator|==
operator|(
expr|struct
name|listenCall
operator|*
operator|)
name|NULL
condition|)
block|{
name|pendq
operator|->
name|QueTail
operator|=
operator|(
expr|struct
name|listenCall
operator|*
operator|)
name|NULL
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|p
operator|==
name|pendq
operator|->
name|QueTail
condition|)
block|{
name|oldp
operator|->
name|NextCall
operator|=
name|p
operator|->
name|NextCall
expr_stmt|;
name|pendq
operator|->
name|QueTail
operator|=
name|oldp
expr_stmt|;
block|}
else|else
block|{
name|oldp
operator|->
name|NextCall
operator|=
name|p
operator|->
name|NextCall
expr_stmt|;
block|}
name|Que
argument_list|(
name|freeq
argument_list|,
name|p
argument_list|,
name|CLEAR
argument_list|)
expr_stmt|;
name|disc
operator|->
name|sequence
operator|=
operator|-
literal|1
expr_stmt|;
return|return;
block|}
name|oldp
operator|=
name|p
expr_stmt|;
name|p
operator|=
name|p
operator|->
name|NextCall
expr_stmt|;
block|}
name|disc
operator|->
name|sequence
operator|=
operator|-
literal|1
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|int
name|nameserver
parameter_list|(
name|fd
parameter_list|,
name|nettype
parameter_list|,
name|service
parameter_list|,
name|arg1
parameter_list|,
name|arg2
parameter_list|,
name|arg3
parameter_list|)
name|int
name|fd
decl_stmt|;
ifdef|#
directive|ifdef
name|SVR4
name|struct
name|netconfig
modifier|*
name|nettype
decl_stmt|;
else|#
directive|else
name|char
modifier|*
name|nettype
decl_stmt|;
endif|#
directive|endif
name|int
name|service
decl_stmt|;
name|char
modifier|*
modifier|*
name|arg1
decl_stmt|,
decl|*
modifier|*
name|arg2
decl_stmt|;
end_function

begin_decl_stmt
name|int
modifier|*
name|arg3
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
modifier|*
name|ptr
decl_stmt|;
name|int
name|n
decl_stmt|;
name|int
name|type
decl_stmt|;
if|if
condition|(
name|fd
operator|>=
literal|0
condition|)
name|type
operator|=
name|_XsTypeOfStream
index|[
name|fd
index|]
expr_stmt|;
else|else
name|type
operator|=
name|X_TLI_STREAM
expr_stmt|;
if|if
condition|(
name|type
operator|<
name|X_TLI_STREAM
operator|||
name|type
operator|>=
name|Network
operator|.
name|_nnets
condition|)
block|{
if|if
condition|(
name|type
operator|==
name|X_LOCAL_STREAM
operator|||
name|type
operator|==
name|X_NAMED_STREAM
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|fd
operator|>=
literal|0
condition|)
block|{
name|PRMSG
argument_list|(
literal|"in nameserver type %d unknown d\n"
argument_list|,
name|type
argument_list|,
name|fd
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
if|if
condition|(
name|nettype
operator|==
name|NULL
condition|)
name|nettype
operator|=
name|Network
operator|.
name|_net
index|[
name|type
index|]
expr_stmt|;
switch|switch
condition|(
name|service
condition|)
block|{
case|case
name|OpenDaemonConnection
case|:
ifdef|#
directive|ifdef
name|SVR4
return|return
operator|(
name|InitializeNetPath
argument_list|()
operator|)
return|;
else|#
directive|else
if|if
condition|(
name|NameServer
operator|<
literal|0
condition|)
name|NameServer
operator|=
name|OpenLocalServer
argument_list|(
name|NAME_SERVER_NODE
argument_list|)
expr_stmt|;
return|return
operator|(
name|NameServer
operator|)
return|;
endif|#
directive|endif
comment|/* SVR4 */
case|case
name|ConvertTliCallToName
case|:
case|case
name|ConvertNetAddrToName
case|:
case|case
name|ConvertNameToNetAddr
case|:
case|case
name|ConvertNameToTliBind
case|:
case|case
name|ConvertNameToTliCall
case|:
if|if
condition|(
operator|(
name|n
operator|=
name|CallTheNameServer
argument_list|(
name|service
argument_list|,
name|nettype
argument_list|,
name|arg1
argument_list|,
name|arg2
argument_list|,
name|arg3
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
return|return
operator|(
name|n
operator|)
return|;
case|case
name|PEER_NAME
case|:
if|if
condition|(
name|fd
operator|<
name|Network
operator|.
name|_npeers
condition|)
block|{
operator|*
name|arg2
operator|=
name|Network
operator|.
name|_peer
index|[
name|fd
index|]
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
operator|-
literal|1
operator|)
return|;
case|case
name|PEER_ALLOC
case|:
if|if
condition|(
name|fd
operator|>=
name|Network
operator|.
name|_npeers
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
operator|*
name|arg1
operator|==
name|NULL
condition|)
block|{
name|n
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|n
operator|=
name|strlen
argument_list|(
operator|*
name|arg1
argument_list|)
expr_stmt|;
name|Network
operator|.
name|_peerlen
index|[
name|fd
index|]
operator|=
name|n
expr_stmt|;
if|if
condition|(
name|n
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|Network
operator|.
name|_peerlen
index|[
name|fd
index|]
operator|>
name|UNAME_LENGTH
condition|)
name|Network
operator|.
name|_peerlen
index|[
name|fd
index|]
operator|=
name|UNAME_LENGTH
expr_stmt|;
name|bcopy
argument_list|(
operator|*
name|arg1
argument_list|,
name|Network
operator|.
name|_peer
index|[
name|fd
index|]
argument_list|,
name|Network
operator|.
name|_peerlen
index|[
name|fd
index|]
argument_list|)
expr_stmt|;
name|Network
operator|.
name|_peer
index|[
name|fd
index|]
index|[
name|Network
operator|.
name|_peerlen
index|[
name|fd
index|]
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
else|else
block|{
name|Network
operator|.
name|_peer
index|[
name|fd
index|]
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
case|case
name|PEER_FREE
case|:
if|if
condition|(
name|fd
operator|<
name|Network
operator|.
name|_npeers
operator|&&
name|Network
operator|.
name|_peer
index|[
name|fd
index|]
operator|!=
name|NULL
condition|)
block|{
name|Network
operator|.
name|_peer
index|[
name|fd
index|]
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|Network
operator|.
name|_peerlen
index|[
name|fd
index|]
operator|=
literal|0
expr_stmt|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
end_block

begin_decl_stmt
specifier|static
name|int
name|_hlen
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|_hptr
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|char
modifier|*
modifier|*
name|addheader
parameter_list|(
name|string
parameter_list|,
name|len
parameter_list|)
name|char
modifier|*
name|string
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
name|int
name|n
decl_stmt|,
name|m
decl_stmt|,
name|p
decl_stmt|;
name|char
modifier|*
name|ptr
decl_stmt|;
name|n
operator|=
name|len
expr_stmt|;
name|m
operator|=
name|n
operator|+
sizeof|sizeof
argument_list|(
name|xHostEntry
argument_list|)
expr_stmt|;
name|p
operator|=
name|m
operator|+
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|>
name|_hlen
condition|)
block|{
if|if
condition|(
name|_hptr
operator|==
name|NULL
condition|)
name|_hptr
operator|=
name|malloc
argument_list|(
name|p
argument_list|)
expr_stmt|;
else|else
name|_hptr
operator|=
name|realloc
argument_list|(
name|_hptr
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|_hptr
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"addheader(): malloc failed\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|p
operator|>
name|_hlen
condition|)
name|_hlen
operator|=
name|p
expr_stmt|;
name|ptr
operator|=
name|_hptr
expr_stmt|;
operator|*
operator|(
name|int
operator|*
operator|)
name|ptr
operator|=
name|m
expr_stmt|;
name|ptr
operator|+=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
operator|*
operator|(
name|int
operator|*
operator|)
name|ptr
operator|=
literal|1
expr_stmt|;
name|ptr
operator|+=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
operator|(
operator|(
name|xHostEntry
operator|*
operator|)
name|ptr
operator|)
operator|->
name|length
operator|=
name|n
expr_stmt|;
name|ptr
operator|+=
sizeof|sizeof
argument_list|(
name|xHostEntry
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|ptr
argument_list|,
name|string
argument_list|,
name|n
argument_list|)
expr_stmt|;
return|return
operator|(
operator|&
name|_hptr
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
modifier|*
name|addtliheader
parameter_list|(
name|call
parameter_list|)
name|struct
name|t_call
modifier|*
name|call
decl_stmt|;
block|{
name|char
modifier|*
name|ptr
decl_stmt|;
name|int
name|a
decl_stmt|,
name|o
decl_stmt|,
name|u
decl_stmt|;
name|int
name|ra
decl_stmt|,
name|ro
decl_stmt|,
name|ru
decl_stmt|,
name|rentlen
decl_stmt|;
name|a
operator|=
name|call
operator|->
name|addr
operator|.
name|len
expr_stmt|;
name|o
operator|=
name|call
operator|->
name|opt
operator|.
name|len
expr_stmt|;
name|u
operator|=
name|call
operator|->
name|udata
operator|.
name|len
expr_stmt|;
name|ra
operator|=
operator|(
operator|(
name|a
operator|+
sizeof|sizeof
argument_list|(
name|xHostEntry
argument_list|)
operator|+
literal|3
operator|)
operator|>>
literal|2
operator|)
operator|<<
literal|2
expr_stmt|;
name|ro
operator|=
operator|(
operator|(
name|o
operator|+
sizeof|sizeof
argument_list|(
name|xHostEntry
argument_list|)
operator|+
literal|3
operator|)
operator|>>
literal|2
operator|)
operator|<<
literal|2
expr_stmt|;
name|ru
operator|=
operator|(
operator|(
name|u
operator|+
sizeof|sizeof
argument_list|(
name|xHostEntry
argument_list|)
operator|+
literal|3
operator|)
operator|>>
literal|2
operator|)
operator|<<
literal|2
expr_stmt|;
name|rentlen
operator|=
name|ra
operator|+
name|ro
operator|+
name|ru
operator|+
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
if|if
condition|(
name|rentlen
operator|>
name|_hlen
condition|)
block|{
if|if
condition|(
name|_hptr
operator|==
name|NULL
condition|)
name|_hptr
operator|=
name|malloc
argument_list|(
name|rentlen
argument_list|)
expr_stmt|;
else|else
name|_hptr
operator|=
name|realloc
argument_list|(
name|_hptr
argument_list|,
name|rentlen
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|_hptr
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"addheader(): malloc failed\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|rentlen
operator|>
name|_hlen
condition|)
name|_hlen
operator|=
name|rentlen
expr_stmt|;
name|ptr
operator|=
name|_hptr
expr_stmt|;
operator|*
operator|(
name|int
operator|*
operator|)
name|ptr
operator|=
name|rentlen
operator|-
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
name|ptr
operator|+=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
operator|*
operator|(
name|int
operator|*
operator|)
name|ptr
operator|=
literal|1
expr_stmt|;
name|ptr
operator|+=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
operator|(
operator|(
name|xHostEntry
operator|*
operator|)
name|ptr
operator|)
operator|->
name|length
operator|=
name|a
expr_stmt|;
if|if
condition|(
name|a
operator|>
literal|0
condition|)
block|{
name|memcpy
argument_list|(
name|ptr
operator|+
sizeof|sizeof
argument_list|(
name|xHostEntry
argument_list|)
argument_list|,
name|call
operator|->
name|addr
operator|.
name|buf
argument_list|,
name|a
argument_list|)
expr_stmt|;
block|}
name|ptr
operator|+=
name|ra
expr_stmt|;
operator|(
operator|(
name|xHostEntry
operator|*
operator|)
name|ptr
operator|)
operator|->
name|length
operator|=
name|o
expr_stmt|;
if|if
condition|(
name|o
operator|>
literal|0
condition|)
name|memcpy
argument_list|(
name|ptr
operator|+
sizeof|sizeof
argument_list|(
name|xHostEntry
argument_list|)
argument_list|,
name|call
operator|->
name|opt
operator|.
name|buf
argument_list|,
name|o
argument_list|)
expr_stmt|;
name|ptr
operator|+=
name|ro
expr_stmt|;
operator|(
operator|(
name|xHostEntry
operator|*
operator|)
name|ptr
operator|)
operator|->
name|length
operator|=
name|u
expr_stmt|;
if|if
condition|(
name|u
operator|>
literal|0
condition|)
block|{
name|memcpy
argument_list|(
name|ptr
operator|+
sizeof|sizeof
argument_list|(
name|xHostEntry
argument_list|)
argument_list|,
name|call
operator|->
name|udata
operator|.
name|buf
argument_list|,
name|u
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
operator|&
name|_hptr
operator|)
return|;
block|}
end_function

begin_function
name|int
name|_XBytesReadable
parameter_list|(
name|fd
parameter_list|,
name|ptr
parameter_list|)
name|int
name|fd
decl_stmt|;
name|int
modifier|*
name|ptr
decl_stmt|;
block|{
name|int
name|inbuf
decl_stmt|;
name|int
name|n
decl_stmt|;
name|int
name|flg
decl_stmt|;
name|InputBuffer
modifier|*
name|ioptr
init|=
operator|&
name|_XsInputBuffer
index|[
name|fd
index|]
decl_stmt|;
name|inbuf
operator|=
name|ioptr
operator|->
name|LastBytePtr
operator|-
name|ioptr
operator|->
name|FirstBytePtr
expr_stmt|;
if|if
condition|(
name|inbuf
operator|>=
name|SIZEOF
argument_list|(
name|xReply
argument_list|)
condition|)
block|{
operator|*
name|ptr
operator|=
name|inbuf
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|ioptr
operator|->
name|FirstBytePtr
operator|>
literal|0
condition|)
block|{
comment|/* move tidbit to front of buffer */
name|bcopy
argument_list|(
operator|&
name|ioptr
operator|->
name|DataBuffer
index|[
name|ioptr
operator|->
name|FirstBytePtr
index|]
argument_list|,
name|ioptr
operator|->
name|DataBuffer
argument_list|,
name|inbuf
argument_list|)
expr_stmt|;
comment|/* Adjust pointers in buffer to reflect move */
name|ioptr
operator|->
name|LastBytePtr
operator|=
name|inbuf
expr_stmt|;
name|ioptr
operator|->
name|FirstBytePtr
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|inbuf
operator|<
literal|0
condition|)
block|{
name|inbuf
operator|=
literal|0
expr_stmt|;
name|ioptr
operator|->
name|LastBytePtr
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Read no more than number of bytes left in buffer */
name|errno
operator|=
literal|0
expr_stmt|;
name|n
operator|=
name|read
argument_list|(
name|fd
argument_list|,
operator|&
name|ioptr
operator|->
name|DataBuffer
index|[
name|inbuf
index|]
argument_list|,
name|BUFFERSIZE
operator|-
name|inbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|>
literal|0
condition|)
block|{
name|ioptr
operator|->
name|LastBytePtr
operator|+=
name|n
expr_stmt|;
operator|*
name|ptr
operator|=
name|ioptr
operator|->
name|LastBytePtr
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
else|else
block|{
if|if
condition|(
name|errno
operator|==
name|EWOULDBLOCK
condition|)
block|{
operator|*
name|ptr
operator|=
name|ioptr
operator|->
name|LastBytePtr
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
else|else
block|{
if|if
condition|(
name|n
operator|==
literal|0
condition|)
block|{
name|errno
operator|=
name|EPIPE
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
else|else
block|{
if|if
condition|(
name|errno
operator|!=
name|EINTR
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
else|else
block|{
operator|*
name|ptr
operator|=
name|ioptr
operator|->
name|LastBytePtr
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
block|}
block|}
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|SVR4
end_ifndef

begin_include
include|#
directive|include
file|<sys/poll.h>
end_include

begin_define
define|#
directive|define
name|POLLERROR
value|(POLLHUP | POLLNVAL | POLLERR)
end_define

begin_define
define|#
directive|define
name|PFD
parameter_list|(
name|fds
parameter_list|,
name|i
parameter_list|,
name|x
parameter_list|)
value|{ 	if (fds) 		if (ev& (x)) 			BITSET (fds, i); 		else 			BITCLEAR (fds, i); }
end_define

begin_define
define|#
directive|define
name|ERROR
parameter_list|(
name|x
parameter_list|)
value|{ 	errno = x; 	return -1; }
end_define

begin_comment
comment|/* 	simulate BSD select system call with SYSV poll system call 	note that efds parameter is not fully supported (or understood) */
end_comment

begin_function_decl
specifier|extern
name|long
name|ulimit
parameter_list|()
function_decl|;
end_function_decl

begin_function
name|int
name|pollselect
parameter_list|(
name|nfds
parameter_list|,
name|rfds
parameter_list|,
name|wfds
parameter_list|,
name|efds
parameter_list|,
name|timeout
parameter_list|)
name|int
name|nfds
decl_stmt|;
name|unsigned
name|long
modifier|*
name|rfds
decl_stmt|;
name|unsigned
name|long
modifier|*
name|wfds
decl_stmt|;
name|unsigned
name|long
modifier|*
name|efds
decl_stmt|;
name|struct
name|timeval
modifier|*
name|timeout
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|rc
decl_stmt|,
name|ev
decl_stmt|,
name|timevalue
decl_stmt|;
name|struct
name|pollfd
name|pfds
index|[
name|NOFILES_MAX
index|]
decl_stmt|;
specifier|static
name|long
name|_NOFILE
init|=
literal|0
decl_stmt|;
name|PRMSG
argument_list|(
literal|"in pollselect\n"
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|_NOFILE
operator|==
literal|0
condition|)
block|{
name|_NOFILE
operator|=
name|ulimit
argument_list|(
literal|4
argument_list|,
operator|(
name|long
operator|)
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|_NOFILE
operator|>
name|NOFILES_MAX
condition|)
name|_NOFILE
operator|=
name|NOFILES_MAX
expr_stmt|;
block|}
if|if
condition|(
name|nfds
operator|>
name|_NOFILE
condition|)
name|nfds
operator|=
name|_NOFILE
expr_stmt|;
comment|/* make poll happy */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nfds
condition|;
name|i
operator|++
control|)
block|{
name|ev
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|rfds
operator|&&
name|GETBIT
argument_list|(
name|rfds
argument_list|,
name|i
argument_list|)
condition|)
name|ev
operator||=
name|POLLIN
expr_stmt|;
if|if
condition|(
name|wfds
operator|&&
name|GETBIT
argument_list|(
name|wfds
argument_list|,
name|i
argument_list|)
condition|)
name|ev
operator||=
name|POLLOUT
expr_stmt|;
if|if
condition|(
name|ev
operator|||
operator|(
name|efds
operator|&&
name|GETBIT
argument_list|(
name|efds
argument_list|,
name|i
argument_list|)
operator|)
condition|)
name|pfds
index|[
name|i
index|]
operator|.
name|fd
operator|=
name|i
expr_stmt|;
else|else
name|pfds
index|[
name|i
index|]
operator|.
name|fd
operator|=
operator|-
literal|1
expr_stmt|;
name|pfds
index|[
name|i
index|]
operator|.
name|events
operator|=
name|ev
expr_stmt|;
block|}
if|if
condition|(
name|timeout
condition|)
name|timevalue
operator|=
name|timeout
operator|->
name|tv_sec
operator|*
literal|1000
operator|+
name|timeout
operator|->
name|tv_usec
operator|/
literal|1000
expr_stmt|;
else|else
name|timevalue
operator|=
operator|-
literal|1
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|rc
operator|=
name|poll
argument_list|(
name|pfds
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|nfds
argument_list|,
name|timevalue
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|<
literal|0
operator|&&
name|errno
operator|==
name|EAGAIN
condition|)
continue|continue;
else|else
break|break;
block|}
if|if
condition|(
name|rc
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|efds
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nfds
condition|;
operator|++
name|i
control|)
block|{
name|ev
operator|=
name|pfds
index|[
name|i
index|]
operator|.
name|revents
expr_stmt|;
if|if
condition|(
name|ev
operator|&
name|POLLERROR
condition|)
name|ERROR
argument_list|(
name|EBADF
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nfds
condition|;
operator|++
name|i
control|)
block|{
name|ev
operator|=
name|pfds
index|[
name|i
index|]
operator|.
name|revents
expr_stmt|;
name|PFD
argument_list|(
name|rfds
argument_list|,
name|i
argument_list|,
name|POLLIN
argument_list|)
expr_stmt|;
name|PFD
argument_list|(
name|wfds
argument_list|,
name|i
argument_list|,
name|POLLOUT
argument_list|)
expr_stmt|;
name|PFD
argument_list|(
name|efds
argument_list|,
name|i
argument_list|,
name|POLLERROR
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|rc
operator|==
literal|0
condition|)
block|{
name|i
operator|=
operator|(
name|nfds
operator|+
literal|7
operator|)
operator|/
literal|8
expr_stmt|;
if|if
condition|(
name|rfds
operator|!=
name|NULL
condition|)
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|rfds
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|wfds
operator|!=
name|NULL
condition|)
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|wfds
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|efds
operator|!=
name|NULL
condition|)
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|efds
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
return|return
name|rc
return|;
block|}
end_function

begin_define
define|#
directive|define
name|SELECT
value|pollselect
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|SELECT
value|select
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ndef SVR4 */
end_comment

begin_comment
comment|/*	The following routine is used for USL Compatibility between  *	Operating System versions of SVR4.0 and SVR3.2. In System  *	V Release 3.2 the select call is not available, and the  *	pollselect is used to poll for connections. In SVR4.0 the  * 	system supplies select and it is used. However, the arguments  *	to these routines are  not identical so this routine   * 	takes care of operating system differences by calling the  * 	proper os dependent routine. It is called (by USL) from the  *	server, Xlib  and Xt. */
end_comment

begin_function
name|int
name|_XSelect
parameter_list|(
name|nfds
parameter_list|,
name|r_mask
parameter_list|,
name|w_mask
parameter_list|,
name|e_mask
parameter_list|,
name|timeout
parameter_list|)
name|int
name|nfds
decl_stmt|;
name|unsigned
name|long
modifier|*
name|r_mask
decl_stmt|,
decl|*
name|w_mask
decl_stmt|,
modifier|*
name|e_mask
decl_stmt|;
end_function

begin_decl_stmt
name|struct
name|timeval
modifier|*
name|timeout
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|retval
init|=
literal|0
decl_stmt|;
name|int
name|count
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
name|unsigned
name|long
name|save_mask
index|[
name|MSKCNT
index|]
decl_stmt|;
specifier|static
name|struct
name|timeval
name|notime
decl_stmt|;
comment|/*PRMSG("IN XSelect from Xstreams nfds=%d r_mask=%0x\n",nfds ,r_mask);*/
if|if
condition|(
name|r_mask
condition|)
block|{
name|CLEARBITS
argument_list|(
name|save_mask
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nfds
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|GETBIT
argument_list|(
name|r_mask
argument_list|,
name|i
argument_list|)
operator|&&
operator|(
name|_XsInputBuffer
index|[
name|i
index|]
operator|.
name|LastBytePtr
operator|-
name|_XsInputBuffer
index|[
name|i
index|]
operator|.
name|FirstBytePtr
operator|)
operator|>
literal|0
condition|)
block|{
name|BITCLEAR
argument_list|(
name|r_mask
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|BITSET
argument_list|(
name|save_mask
argument_list|,
name|i
argument_list|)
expr_stmt|;
operator|++
name|count
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|count
condition|)
block|{
if|if
condition|(
name|_XANYSET
argument_list|(
name|r_mask
argument_list|)
operator|||
operator|(
name|w_mask
operator|&&
name|_XANYSET
argument_list|(
name|w_mask
argument_list|)
operator|)
operator|||
operator|(
name|e_mask
operator|&&
name|_XANYSET
argument_list|(
name|e_mask
argument_list|)
operator|)
condition|)
block|{
name|retval
operator|=
name|SELECT
argument_list|(
name|nfds
argument_list|,
name|r_mask
argument_list|,
name|w_mask
argument_list|,
name|e_mask
argument_list|,
operator|&
name|notime
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nfds
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|GETBIT
argument_list|(
name|save_mask
argument_list|,
name|i
argument_list|)
condition|)
block|{
name|BITSET
argument_list|(
name|r_mask
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|retval
operator|<
literal|0
condition|?
name|retval
else|:
name|retval
operator|+
name|count
return|;
block|}
else|else
block|{
return|return
name|SELECT
argument_list|(
name|nfds
argument_list|,
name|r_mask
argument_list|,
name|w_mask
argument_list|,
name|e_mask
argument_list|,
name|timeout
argument_list|)
return|;
block|}
block|}
end_block

begin_comment
comment|/* XSelect() */
end_comment

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* not STREAMSCONN */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|int
name|dummy
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* prevent ranlibs from complaining */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* STREAMSCONN */
end_comment

end_unit

