begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"popen.h"
end_include

begin_include
include|#
directive|include
file|<io.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<process.h>
end_include

begin_decl_stmt
specifier|static
name|char
name|template
index|[]
init|=
literal|"piXXXXXX"
decl_stmt|;
end_decl_stmt

begin_typedef
typedef|typedef
enum|enum
block|{
name|unopened
init|=
literal|0
block|,
name|reading
block|,
name|writing
block|}
name|pipemode
typedef|;
end_typedef

begin_struct
specifier|static
struct|struct
block|{
name|char
modifier|*
name|command
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|pipemode
name|pmode
decl_stmt|;
block|}
name|pipes
index|[
name|_NFILE
index|]
struct|;
end_struct

begin_function
name|FILE
modifier|*
name|popen
parameter_list|(
name|char
modifier|*
name|command
parameter_list|,
name|char
modifier|*
name|mode
parameter_list|)
block|{
name|FILE
modifier|*
name|current
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|cur
decl_stmt|;
name|pipemode
name|curmode
decl_stmt|;
comment|/*     ** decide on mode.     */
if|if
condition|(
name|strcmp
argument_list|(
name|mode
argument_list|,
literal|"r"
argument_list|)
operator|==
literal|0
condition|)
name|curmode
operator|=
name|reading
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|mode
argument_list|,
literal|"w"
argument_list|)
operator|==
literal|0
condition|)
name|curmode
operator|=
name|writing
expr_stmt|;
else|else
return|return
name|NULL
return|;
comment|/*     ** get a name to use.     */
if|if
condition|(
operator|(
name|name
operator|=
name|tempnam
argument_list|(
literal|"."
argument_list|,
literal|"pip"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
comment|/*     ** If we're reading, just call system to get a file filled with     ** output.     */
if|if
condition|(
name|curmode
operator|==
name|reading
condition|)
block|{
name|char
name|cmd
index|[
literal|256
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|cmd
argument_list|,
literal|"%s> %s"
argument_list|,
name|command
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|system
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|current
operator|=
name|fopen
argument_list|(
name|name
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|current
operator|=
name|fopen
argument_list|(
name|name
argument_list|,
literal|"w"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
block|}
name|cur
operator|=
name|fileno
argument_list|(
name|current
argument_list|)
expr_stmt|;
name|pipes
index|[
name|cur
index|]
operator|.
name|name
operator|=
name|name
expr_stmt|;
name|pipes
index|[
name|cur
index|]
operator|.
name|pmode
operator|=
name|curmode
expr_stmt|;
name|pipes
index|[
name|cur
index|]
operator|.
name|command
operator|=
name|strdup
argument_list|(
name|command
argument_list|)
expr_stmt|;
return|return
name|current
return|;
block|}
end_function

begin_function
name|int
name|pclose
parameter_list|(
name|FILE
modifier|*
name|current
parameter_list|)
block|{
name|int
name|cur
init|=
name|fileno
argument_list|(
name|current
argument_list|)
decl_stmt|,
name|rval
decl_stmt|;
comment|/*     ** check for an open file.     */
if|if
condition|(
name|pipes
index|[
name|cur
index|]
operator|.
name|pmode
operator|==
name|unopened
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|pipes
index|[
name|cur
index|]
operator|.
name|pmode
operator|==
name|reading
condition|)
block|{
comment|/*         ** input pipes are just files we're done with.         */
name|rval
operator|=
name|fclose
argument_list|(
name|current
argument_list|)
expr_stmt|;
name|unlink
argument_list|(
name|pipes
index|[
name|cur
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/*         ** output pipes are temporary files we have         ** to cram down the throats of programs.         */
name|char
name|command
index|[
literal|256
index|]
decl_stmt|;
name|fclose
argument_list|(
name|current
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|command
argument_list|,
literal|"%s< %s"
argument_list|,
name|pipes
index|[
name|cur
index|]
operator|.
name|command
argument_list|,
name|pipes
index|[
name|cur
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
name|rval
operator|=
name|system
argument_list|(
name|command
argument_list|)
expr_stmt|;
name|unlink
argument_list|(
name|pipes
index|[
name|cur
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
block|}
comment|/*     ** clean up current pipe.     */
name|pipes
index|[
name|cur
index|]
operator|.
name|pmode
operator|=
name|unopened
expr_stmt|;
name|free
argument_list|(
name|pipes
index|[
name|cur
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|pipes
index|[
name|cur
index|]
operator|.
name|command
argument_list|)
expr_stmt|;
return|return
name|rval
return|;
block|}
end_function

end_unit

