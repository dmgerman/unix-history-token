begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * builtin.c - Builtin functions and various utility procedures   */
end_comment

begin_comment
comment|/*   * Copyright (C) 1986, 1988, 1989, 1991, 1992 the Free Software Foundation, Inc.  *   * This file is part of GAWK, the GNU implementation of the  * AWK Progamming Language.  *   * GAWK is free software; you can redistribute it and/or modify  * it under the terms of the GNU General Public License as published by  * the Free Software Foundation; either version 2 of the License, or  * (at your option) any later version.  *   * GAWK is distributed in the hope that it will be useful,  * but WITHOUT ANY WARRANTY; without even the implied warranty of  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  * GNU General Public License for more details.  *   * You should have received a copy of the GNU General Public License  * along with GAWK; see the file COPYING.  If not, write to  * the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_include
include|#
directive|include
file|"awk.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|SRANDOM_PROTO
end_ifndef

begin_decl_stmt
specifier|extern
name|void
name|srandom
name|P
argument_list|(
operator|(
name|int
name|seed
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|linux
end_ifndef

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|initstate
name|P
argument_list|(
operator|(
name|unsigned
name|seed
operator|,
name|char
operator|*
name|state
operator|,
name|int
name|n
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|setstate
name|P
argument_list|(
operator|(
name|char
operator|*
name|state
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|long
name|random
name|P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|extern
name|NODE
modifier|*
modifier|*
name|fields_arr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|output_is_tty
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|NODE
modifier|*
name|sub_common
name|P
argument_list|(
operator|(
name|NODE
operator|*
name|tree
operator|,
name|int
name|global
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|GFMT_WORKAROUND
end_ifdef

begin_decl_stmt
name|char
modifier|*
name|gfmt
name|P
argument_list|(
operator|(
name|double
name|g
operator|,
name|int
name|prec
operator|,
name|char
operator|*
name|buf
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|_CRAY
end_ifdef

begin_comment
comment|/* Work around a problem in conversion of doubles to exact integers. */
end_comment

begin_include
include|#
directive|include
file|<float.h>
end_include

begin_define
define|#
directive|define
name|Floor
parameter_list|(
name|n
parameter_list|)
value|floor((n) * (1.0 + DBL_EPSILON))
end_define

begin_define
define|#
directive|define
name|Ceil
parameter_list|(
name|n
parameter_list|)
value|ceil((n) * (1.0 + DBL_EPSILON))
end_define

begin_comment
comment|/* Force the standard C compiler to use the library math functions. */
end_comment

begin_function_decl
specifier|extern
name|double
name|exp
parameter_list|(
name|double
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|double
function_decl|(
modifier|*
name|Exp
function_decl|)
parameter_list|()
init|=
name|exp
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|exp
parameter_list|(
name|x
parameter_list|)
value|(*Exp)(x)
end_define

begin_function_decl
specifier|extern
name|double
name|log
parameter_list|(
name|double
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|double
function_decl|(
modifier|*
name|Log
function_decl|)
parameter_list|()
init|=
name|log
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|log
parameter_list|(
name|x
parameter_list|)
value|(*Log)(x)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|Floor
parameter_list|(
name|n
parameter_list|)
value|floor(n)
end_define

begin_define
define|#
directive|define
name|Ceil
parameter_list|(
name|n
parameter_list|)
value|ceil(n)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|efwrite
parameter_list|(
name|ptr
parameter_list|,
name|size
parameter_list|,
name|count
parameter_list|,
name|fp
parameter_list|,
name|from
parameter_list|,
name|rp
parameter_list|,
name|flush
parameter_list|)
name|void
modifier|*
name|ptr
decl_stmt|;
name|unsigned
name|size
decl_stmt|,
name|count
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
name|char
modifier|*
name|from
decl_stmt|;
name|struct
name|redirect
modifier|*
name|rp
decl_stmt|;
name|int
name|flush
decl_stmt|;
block|{
name|errno
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|fwrite
argument_list|(
name|ptr
argument_list|,
name|size
argument_list|,
name|count
argument_list|,
name|fp
argument_list|)
operator|!=
name|count
condition|)
goto|goto
name|wrerror
goto|;
if|if
condition|(
name|flush
operator|&&
operator|(
operator|(
name|fp
operator|==
name|stdout
operator|&&
name|output_is_tty
operator|)
operator|||
operator|(
name|rp
operator|&&
operator|(
name|rp
operator|->
name|flag
operator|&
name|RED_NOBUF
operator|)
operator|)
operator|)
condition|)
block|{
name|fflush
argument_list|(
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ferror
argument_list|(
name|fp
argument_list|)
condition|)
goto|goto
name|wrerror
goto|;
block|}
return|return;
name|wrerror
label|:
name|fatal
argument_list|(
literal|"%s to \"%s\" failed (%s)"
argument_list|,
name|from
argument_list|,
name|rp
condition|?
name|rp
operator|->
name|value
else|:
literal|"standard output"
argument_list|,
name|errno
condition|?
name|strerror
argument_list|(
name|errno
argument_list|)
else|:
literal|"reason unknown"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Builtin functions */
end_comment

begin_function
name|NODE
modifier|*
name|do_exp
parameter_list|(
name|tree
parameter_list|)
name|NODE
modifier|*
name|tree
decl_stmt|;
block|{
name|NODE
modifier|*
name|tmp
decl_stmt|;
name|double
name|d
decl_stmt|,
name|res
decl_stmt|;
ifndef|#
directive|ifndef
name|exp
name|double
name|exp
name|P
argument_list|(
operator|(
name|double
operator|)
argument_list|)
decl_stmt|;
endif|#
directive|endif
name|tmp
operator|=
name|tree_eval
argument_list|(
name|tree
operator|->
name|lnode
argument_list|)
expr_stmt|;
name|d
operator|=
name|force_number
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
name|free_temp
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
name|res
operator|=
name|exp
argument_list|(
name|d
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
operator|==
name|ERANGE
condition|)
name|warning
argument_list|(
literal|"exp argument %g is out of range"
argument_list|,
name|d
argument_list|)
expr_stmt|;
return|return
name|tmp_number
argument_list|(
operator|(
name|AWKNUM
operator|)
name|res
argument_list|)
return|;
block|}
end_function

begin_function
name|NODE
modifier|*
name|do_index
parameter_list|(
name|tree
parameter_list|)
name|NODE
modifier|*
name|tree
decl_stmt|;
block|{
name|NODE
modifier|*
name|s1
decl_stmt|,
modifier|*
name|s2
decl_stmt|;
specifier|register
name|char
modifier|*
name|p1
decl_stmt|,
modifier|*
name|p2
decl_stmt|;
specifier|register
name|int
name|l1
decl_stmt|,
name|l2
decl_stmt|;
name|long
name|ret
decl_stmt|;
name|s1
operator|=
name|tree_eval
argument_list|(
name|tree
operator|->
name|lnode
argument_list|)
expr_stmt|;
name|s2
operator|=
name|tree_eval
argument_list|(
name|tree
operator|->
name|rnode
operator|->
name|lnode
argument_list|)
expr_stmt|;
name|force_string
argument_list|(
name|s1
argument_list|)
expr_stmt|;
name|force_string
argument_list|(
name|s2
argument_list|)
expr_stmt|;
name|p1
operator|=
name|s1
operator|->
name|stptr
expr_stmt|;
name|p2
operator|=
name|s2
operator|->
name|stptr
expr_stmt|;
name|l1
operator|=
name|s1
operator|->
name|stlen
expr_stmt|;
name|l2
operator|=
name|s2
operator|->
name|stlen
expr_stmt|;
name|ret
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|IGNORECASE
condition|)
block|{
while|while
condition|(
name|l1
condition|)
block|{
if|if
condition|(
name|l2
operator|>
name|l1
condition|)
break|break;
if|if
condition|(
name|casetable
index|[
operator|(
name|int
operator|)
operator|*
name|p1
index|]
operator|==
name|casetable
index|[
operator|(
name|int
operator|)
operator|*
name|p2
index|]
operator|&&
operator|(
name|l2
operator|==
literal|1
operator|||
name|strncasecmp
argument_list|(
name|p1
argument_list|,
name|p2
argument_list|,
name|l2
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|ret
operator|=
literal|1
operator|+
name|s1
operator|->
name|stlen
operator|-
name|l1
expr_stmt|;
break|break;
block|}
name|l1
operator|--
expr_stmt|;
name|p1
operator|++
expr_stmt|;
block|}
block|}
else|else
block|{
while|while
condition|(
name|l1
condition|)
block|{
if|if
condition|(
name|l2
operator|>
name|l1
condition|)
break|break;
if|if
condition|(
operator|*
name|p1
operator|==
operator|*
name|p2
operator|&&
operator|(
name|l2
operator|==
literal|1
operator|||
name|STREQN
argument_list|(
name|p1
argument_list|,
name|p2
argument_list|,
name|l2
argument_list|)
operator|)
condition|)
block|{
name|ret
operator|=
literal|1
operator|+
name|s1
operator|->
name|stlen
operator|-
name|l1
expr_stmt|;
break|break;
block|}
name|l1
operator|--
expr_stmt|;
name|p1
operator|++
expr_stmt|;
block|}
block|}
name|free_temp
argument_list|(
name|s1
argument_list|)
expr_stmt|;
name|free_temp
argument_list|(
name|s2
argument_list|)
expr_stmt|;
return|return
name|tmp_number
argument_list|(
operator|(
name|AWKNUM
operator|)
name|ret
argument_list|)
return|;
block|}
end_function

begin_function
name|NODE
modifier|*
name|do_int
parameter_list|(
name|tree
parameter_list|)
name|NODE
modifier|*
name|tree
decl_stmt|;
block|{
name|NODE
modifier|*
name|tmp
decl_stmt|;
name|double
name|floor
name|P
argument_list|(
operator|(
name|double
operator|)
argument_list|)
decl_stmt|;
name|double
name|ceil
name|P
argument_list|(
operator|(
name|double
operator|)
argument_list|)
decl_stmt|;
name|double
name|d
decl_stmt|;
name|tmp
operator|=
name|tree_eval
argument_list|(
name|tree
operator|->
name|lnode
argument_list|)
expr_stmt|;
name|d
operator|=
name|force_number
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|>=
literal|0
condition|)
name|d
operator|=
name|Floor
argument_list|(
name|d
argument_list|)
expr_stmt|;
else|else
name|d
operator|=
name|Ceil
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|free_temp
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
return|return
name|tmp_number
argument_list|(
operator|(
name|AWKNUM
operator|)
name|d
argument_list|)
return|;
block|}
end_function

begin_function
name|NODE
modifier|*
name|do_length
parameter_list|(
name|tree
parameter_list|)
name|NODE
modifier|*
name|tree
decl_stmt|;
block|{
name|NODE
modifier|*
name|tmp
decl_stmt|;
name|int
name|len
decl_stmt|;
name|tmp
operator|=
name|tree_eval
argument_list|(
name|tree
operator|->
name|lnode
argument_list|)
expr_stmt|;
name|len
operator|=
name|force_string
argument_list|(
name|tmp
argument_list|)
operator|->
name|stlen
expr_stmt|;
name|free_temp
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
return|return
name|tmp_number
argument_list|(
operator|(
name|AWKNUM
operator|)
name|len
argument_list|)
return|;
block|}
end_function

begin_function
name|NODE
modifier|*
name|do_log
parameter_list|(
name|tree
parameter_list|)
name|NODE
modifier|*
name|tree
decl_stmt|;
block|{
name|NODE
modifier|*
name|tmp
decl_stmt|;
ifndef|#
directive|ifndef
name|log
name|double
name|log
name|P
argument_list|(
operator|(
name|double
operator|)
argument_list|)
decl_stmt|;
endif|#
directive|endif
name|double
name|d
decl_stmt|,
name|arg
decl_stmt|;
name|tmp
operator|=
name|tree_eval
argument_list|(
name|tree
operator|->
name|lnode
argument_list|)
expr_stmt|;
name|arg
operator|=
operator|(
name|double
operator|)
name|force_number
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg
operator|<
literal|0.0
condition|)
name|warning
argument_list|(
literal|"log called with negative argument %g"
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|d
operator|=
name|log
argument_list|(
name|arg
argument_list|)
expr_stmt|;
name|free_temp
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
return|return
name|tmp_number
argument_list|(
operator|(
name|AWKNUM
operator|)
name|d
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* %e and %f formats are not properly implemented.  Someone should fix them */
end_comment

begin_comment
comment|/* Actually, this whole thing should be reimplemented. */
end_comment

begin_function
name|NODE
modifier|*
name|do_sprintf
parameter_list|(
name|tree
parameter_list|)
name|NODE
modifier|*
name|tree
decl_stmt|;
block|{
define|#
directive|define
name|bchunk
parameter_list|(
name|s
parameter_list|,
name|l
parameter_list|)
value|if(l) {\     while((l)>ofre) {\       erealloc(obuf, char *, osiz*2, "do_sprintf");\       ofre+=osiz;\       osiz*=2;\     }\     memcpy(obuf+olen,s,(l));\     olen+=(l);\     ofre-=(l);\   }
comment|/* Is there space for something L big in the buffer? */
define|#
directive|define
name|chksize
parameter_list|(
name|l
parameter_list|)
value|if((l)>ofre) {\     erealloc(obuf, char *, osiz*2, "do_sprintf");\     ofre+=osiz;\     osiz*=2;\   }
comment|/* 	 * Get the next arg to be formatted.  If we've run out of args, 	 * return "" (Null string)  	 */
define|#
directive|define
name|parse_next_arg
parameter_list|()
value|{\   if(!carg) { toofew = 1; break; }\   else {\ 	arg=tree_eval(carg->lnode);\ 	carg=carg->rnode;\   }\  }
name|NODE
modifier|*
name|r
decl_stmt|;
name|int
name|toofew
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|obuf
decl_stmt|;
name|int
name|osiz
decl_stmt|,
name|ofre
decl_stmt|,
name|olen
decl_stmt|;
specifier|static
name|char
name|chbuf
index|[]
init|=
literal|"0123456789abcdef"
decl_stmt|;
specifier|static
name|char
name|sp
index|[]
init|=
literal|" "
decl_stmt|;
name|char
modifier|*
name|s0
decl_stmt|,
modifier|*
name|s1
decl_stmt|;
name|int
name|n0
decl_stmt|;
name|NODE
modifier|*
name|sfmt
decl_stmt|,
modifier|*
name|arg
decl_stmt|;
specifier|register
name|NODE
modifier|*
name|carg
decl_stmt|;
name|long
name|fw
decl_stmt|,
name|prec
decl_stmt|,
name|lj
decl_stmt|,
name|alt
decl_stmt|,
name|big
decl_stmt|;
name|long
modifier|*
name|cur
decl_stmt|;
name|long
name|val
decl_stmt|;
ifdef|#
directive|ifdef
name|sun386
comment|/* Can't cast unsigned (int/long) from ptr->value */
name|long
name|tmp_uval
decl_stmt|;
comment|/* on 386i 4.0.1 C compiler -- it just hangs */
endif|#
directive|endif
name|unsigned
name|long
name|uval
decl_stmt|;
name|int
name|sgn
decl_stmt|;
name|int
name|base
decl_stmt|;
name|char
name|cpbuf
index|[
literal|30
index|]
decl_stmt|;
comment|/* if we have numbers bigger than 30 */
name|char
modifier|*
name|cend
init|=
operator|&
name|cpbuf
index|[
literal|30
index|]
decl_stmt|;
comment|/* chars, we lose, but seems unlikely */
name|char
modifier|*
name|cp
decl_stmt|;
name|char
modifier|*
name|fill
decl_stmt|;
name|double
name|tmpval
decl_stmt|;
name|char
modifier|*
name|pr_str
decl_stmt|;
name|int
name|ucasehex
init|=
literal|0
decl_stmt|;
name|char
name|signchar
init|=
literal|0
decl_stmt|;
name|int
name|len
decl_stmt|;
name|emalloc
argument_list|(
name|obuf
argument_list|,
name|char
operator|*
argument_list|,
literal|120
argument_list|,
literal|"do_sprintf"
argument_list|)
expr_stmt|;
name|osiz
operator|=
literal|120
expr_stmt|;
name|ofre
operator|=
name|osiz
operator|-
literal|1
expr_stmt|;
name|olen
operator|=
literal|0
expr_stmt|;
name|sfmt
operator|=
name|tree_eval
argument_list|(
name|tree
operator|->
name|lnode
argument_list|)
expr_stmt|;
name|sfmt
operator|=
name|force_string
argument_list|(
name|sfmt
argument_list|)
expr_stmt|;
name|carg
operator|=
name|tree
operator|->
name|rnode
expr_stmt|;
for|for
control|(
name|s0
operator|=
name|s1
operator|=
name|sfmt
operator|->
name|stptr
operator|,
name|n0
operator|=
name|sfmt
operator|->
name|stlen
init|;
name|n0
operator|--
operator|>
literal|0
condition|;
control|)
block|{
if|if
condition|(
operator|*
name|s1
operator|!=
literal|'%'
condition|)
block|{
name|s1
operator|++
expr_stmt|;
continue|continue;
block|}
name|bchunk
argument_list|(
name|s0
argument_list|,
name|s1
operator|-
name|s0
argument_list|)
expr_stmt|;
name|s0
operator|=
name|s1
expr_stmt|;
name|cur
operator|=
operator|&
name|fw
expr_stmt|;
name|fw
operator|=
literal|0
expr_stmt|;
name|prec
operator|=
literal|0
expr_stmt|;
name|lj
operator|=
name|alt
operator|=
name|big
operator|=
literal|0
expr_stmt|;
name|fill
operator|=
name|sp
expr_stmt|;
name|cp
operator|=
name|cend
expr_stmt|;
name|s1
operator|++
expr_stmt|;
name|retry
label|:
operator|--
name|n0
expr_stmt|;
switch|switch
condition|(
operator|*
name|s1
operator|++
condition|)
block|{
case|case
literal|'%'
case|:
name|bchunk
argument_list|(
literal|"%"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|s0
operator|=
name|s1
expr_stmt|;
break|break;
case|case
literal|'0'
case|:
if|if
condition|(
name|fill
operator|!=
name|sp
operator|||
name|lj
condition|)
goto|goto
name|lose
goto|;
if|if
condition|(
name|cur
operator|==
operator|&
name|fw
condition|)
name|fill
operator|=
literal|"0"
expr_stmt|;
comment|/* FALL through */
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
if|if
condition|(
name|cur
operator|==
literal|0
condition|)
goto|goto
name|lose
goto|;
operator|*
name|cur
operator|=
name|s1
index|[
operator|-
literal|1
index|]
operator|-
literal|'0'
expr_stmt|;
while|while
condition|(
name|n0
operator|>
literal|0
operator|&&
operator|*
name|s1
operator|>=
literal|'0'
operator|&&
operator|*
name|s1
operator|<=
literal|'9'
condition|)
block|{
operator|--
name|n0
expr_stmt|;
operator|*
name|cur
operator|=
operator|*
name|cur
operator|*
literal|10
operator|+
operator|*
name|s1
operator|++
operator|-
literal|'0'
expr_stmt|;
block|}
goto|goto
name|retry
goto|;
case|case
literal|'*'
case|:
if|if
condition|(
name|cur
operator|==
literal|0
condition|)
goto|goto
name|lose
goto|;
name|parse_next_arg
argument_list|()
expr_stmt|;
operator|*
name|cur
operator|=
name|force_number
argument_list|(
name|arg
argument_list|)
expr_stmt|;
name|free_temp
argument_list|(
name|arg
argument_list|)
expr_stmt|;
goto|goto
name|retry
goto|;
case|case
literal|' '
case|:
comment|/* print ' ' or '-' */
case|case
literal|'+'
case|:
comment|/* print '+' or '-' */
name|signchar
operator|=
operator|*
operator|(
name|s1
operator|-
literal|1
operator|)
expr_stmt|;
goto|goto
name|retry
goto|;
case|case
literal|'-'
case|:
if|if
condition|(
name|lj
operator|||
name|fill
operator|!=
name|sp
condition|)
goto|goto
name|lose
goto|;
name|lj
operator|++
expr_stmt|;
goto|goto
name|retry
goto|;
case|case
literal|'.'
case|:
if|if
condition|(
name|cur
operator|!=
operator|&
name|fw
condition|)
goto|goto
name|lose
goto|;
name|cur
operator|=
operator|&
name|prec
expr_stmt|;
goto|goto
name|retry
goto|;
case|case
literal|'#'
case|:
if|if
condition|(
name|alt
condition|)
goto|goto
name|lose
goto|;
name|alt
operator|++
expr_stmt|;
goto|goto
name|retry
goto|;
case|case
literal|'l'
case|:
if|if
condition|(
name|big
condition|)
goto|goto
name|lose
goto|;
name|big
operator|++
expr_stmt|;
goto|goto
name|retry
goto|;
case|case
literal|'c'
case|:
name|parse_next_arg
argument_list|()
expr_stmt|;
if|if
condition|(
name|arg
operator|->
name|flags
operator|&
name|NUMBER
condition|)
block|{
ifdef|#
directive|ifdef
name|sun386
name|tmp_uval
operator|=
name|arg
operator|->
name|numbr
expr_stmt|;
name|uval
operator|=
operator|(
name|unsigned
name|long
operator|)
name|tmp_uval
expr_stmt|;
else|#
directive|else
name|uval
operator|=
operator|(
name|unsigned
name|long
operator|)
name|arg
operator|->
name|numbr
expr_stmt|;
endif|#
directive|endif
name|cpbuf
index|[
literal|0
index|]
operator|=
name|uval
expr_stmt|;
name|prec
operator|=
literal|1
expr_stmt|;
name|pr_str
operator|=
name|cpbuf
expr_stmt|;
goto|goto
name|dopr_string
goto|;
block|}
if|if
condition|(
operator|!
name|prec
condition|)
name|prec
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|prec
operator|>
name|arg
operator|->
name|stlen
condition|)
name|prec
operator|=
name|arg
operator|->
name|stlen
expr_stmt|;
name|pr_str
operator|=
name|arg
operator|->
name|stptr
expr_stmt|;
goto|goto
name|dopr_string
goto|;
case|case
literal|'s'
case|:
name|parse_next_arg
argument_list|()
expr_stmt|;
name|arg
operator|=
name|force_string
argument_list|(
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|prec
operator|||
name|prec
operator|>
name|arg
operator|->
name|stlen
condition|)
name|prec
operator|=
name|arg
operator|->
name|stlen
expr_stmt|;
name|pr_str
operator|=
name|arg
operator|->
name|stptr
expr_stmt|;
name|dopr_string
label|:
if|if
condition|(
name|fw
operator|>
name|prec
operator|&&
operator|!
name|lj
condition|)
block|{
while|while
condition|(
name|fw
operator|>
name|prec
condition|)
block|{
name|bchunk
argument_list|(
name|sp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|fw
operator|--
expr_stmt|;
block|}
block|}
name|bchunk
argument_list|(
name|pr_str
argument_list|,
operator|(
name|int
operator|)
name|prec
argument_list|)
expr_stmt|;
if|if
condition|(
name|fw
operator|>
name|prec
condition|)
block|{
while|while
condition|(
name|fw
operator|>
name|prec
condition|)
block|{
name|bchunk
argument_list|(
name|sp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|fw
operator|--
expr_stmt|;
block|}
block|}
name|s0
operator|=
name|s1
expr_stmt|;
name|free_temp
argument_list|(
name|arg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
case|case
literal|'i'
case|:
name|parse_next_arg
argument_list|()
expr_stmt|;
name|val
operator|=
operator|(
name|long
operator|)
name|force_number
argument_list|(
name|arg
argument_list|)
expr_stmt|;
name|free_temp
argument_list|(
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|<
literal|0
condition|)
block|{
name|sgn
operator|=
literal|1
expr_stmt|;
name|val
operator|=
operator|-
name|val
expr_stmt|;
block|}
else|else
name|sgn
operator|=
literal|0
expr_stmt|;
do|do
block|{
operator|*
operator|--
name|cp
operator|=
literal|'0'
operator|+
name|val
operator|%
literal|10
expr_stmt|;
name|val
operator|/=
literal|10
expr_stmt|;
block|}
do|while
condition|(
name|val
condition|)
do|;
if|if
condition|(
name|sgn
condition|)
operator|*
operator|--
name|cp
operator|=
literal|'-'
expr_stmt|;
elseif|else
if|if
condition|(
name|signchar
condition|)
operator|*
operator|--
name|cp
operator|=
name|signchar
expr_stmt|;
if|if
condition|(
name|prec
operator|>
name|fw
condition|)
name|fw
operator|=
name|prec
expr_stmt|;
name|prec
operator|=
name|cend
operator|-
name|cp
expr_stmt|;
if|if
condition|(
name|fw
operator|>
name|prec
operator|&&
operator|!
name|lj
condition|)
block|{
if|if
condition|(
name|fill
operator|!=
name|sp
operator|&&
operator|(
operator|*
name|cp
operator|==
literal|'-'
operator|||
name|signchar
operator|)
condition|)
block|{
name|bchunk
argument_list|(
name|cp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|cp
operator|++
expr_stmt|;
name|prec
operator|--
expr_stmt|;
name|fw
operator|--
expr_stmt|;
block|}
while|while
condition|(
name|fw
operator|>
name|prec
condition|)
block|{
name|bchunk
argument_list|(
name|fill
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|fw
operator|--
expr_stmt|;
block|}
block|}
name|bchunk
argument_list|(
name|cp
argument_list|,
operator|(
name|int
operator|)
name|prec
argument_list|)
expr_stmt|;
if|if
condition|(
name|fw
operator|>
name|prec
condition|)
block|{
while|while
condition|(
name|fw
operator|>
name|prec
condition|)
block|{
name|bchunk
argument_list|(
name|fill
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|fw
operator|--
expr_stmt|;
block|}
block|}
name|s0
operator|=
name|s1
expr_stmt|;
break|break;
case|case
literal|'u'
case|:
name|base
operator|=
literal|10
expr_stmt|;
goto|goto
name|pr_unsigned
goto|;
case|case
literal|'o'
case|:
name|base
operator|=
literal|8
expr_stmt|;
goto|goto
name|pr_unsigned
goto|;
case|case
literal|'X'
case|:
name|ucasehex
operator|=
literal|1
expr_stmt|;
case|case
literal|'x'
case|:
name|base
operator|=
literal|16
expr_stmt|;
goto|goto
name|pr_unsigned
goto|;
name|pr_unsigned
label|:
name|parse_next_arg
argument_list|()
expr_stmt|;
name|uval
operator|=
operator|(
name|unsigned
name|long
operator|)
name|force_number
argument_list|(
name|arg
argument_list|)
expr_stmt|;
name|free_temp
argument_list|(
name|arg
argument_list|)
expr_stmt|;
do|do
block|{
operator|*
operator|--
name|cp
operator|=
name|chbuf
index|[
name|uval
operator|%
name|base
index|]
expr_stmt|;
if|if
condition|(
name|ucasehex
operator|&&
name|isalpha
argument_list|(
operator|*
name|cp
argument_list|)
condition|)
operator|*
name|cp
operator|=
name|toupper
argument_list|(
operator|*
name|cp
argument_list|)
expr_stmt|;
name|uval
operator|/=
name|base
expr_stmt|;
block|}
do|while
condition|(
name|uval
condition|)
do|;
if|if
condition|(
name|alt
operator|&&
operator|(
name|base
operator|==
literal|8
operator|||
name|base
operator|==
literal|16
operator|)
condition|)
block|{
if|if
condition|(
name|base
operator|==
literal|16
condition|)
block|{
if|if
condition|(
name|ucasehex
condition|)
operator|*
operator|--
name|cp
operator|=
literal|'X'
expr_stmt|;
else|else
operator|*
operator|--
name|cp
operator|=
literal|'x'
expr_stmt|;
block|}
operator|*
operator|--
name|cp
operator|=
literal|'0'
expr_stmt|;
block|}
name|prec
operator|=
name|cend
operator|-
name|cp
expr_stmt|;
if|if
condition|(
name|fw
operator|>
name|prec
operator|&&
operator|!
name|lj
condition|)
block|{
while|while
condition|(
name|fw
operator|>
name|prec
condition|)
block|{
name|bchunk
argument_list|(
name|fill
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|fw
operator|--
expr_stmt|;
block|}
block|}
name|bchunk
argument_list|(
name|cp
argument_list|,
operator|(
name|int
operator|)
name|prec
argument_list|)
expr_stmt|;
if|if
condition|(
name|fw
operator|>
name|prec
condition|)
block|{
while|while
condition|(
name|fw
operator|>
name|prec
condition|)
block|{
name|bchunk
argument_list|(
name|fill
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|fw
operator|--
expr_stmt|;
block|}
block|}
name|s0
operator|=
name|s1
expr_stmt|;
break|break;
case|case
literal|'g'
case|:
name|parse_next_arg
argument_list|()
expr_stmt|;
name|tmpval
operator|=
name|force_number
argument_list|(
name|arg
argument_list|)
expr_stmt|;
name|free_temp
argument_list|(
name|arg
argument_list|)
expr_stmt|;
name|chksize
argument_list|(
name|fw
operator|+
name|prec
operator|+
literal|9
argument_list|)
expr_stmt|;
comment|/* 9==slop */
name|cp
operator|=
name|cpbuf
expr_stmt|;
operator|*
name|cp
operator|++
operator|=
literal|'%'
expr_stmt|;
if|if
condition|(
name|lj
condition|)
operator|*
name|cp
operator|++
operator|=
literal|'-'
expr_stmt|;
if|if
condition|(
name|fill
operator|!=
name|sp
condition|)
operator|*
name|cp
operator|++
operator|=
literal|'0'
expr_stmt|;
ifndef|#
directive|ifndef
name|GFMT_WORKAROUND
if|if
condition|(
name|cur
operator|!=
operator|&
name|fw
condition|)
block|{
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|cp
argument_list|,
literal|"*.*g"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|obuf
operator|+
name|olen
argument_list|,
name|cpbuf
argument_list|,
operator|(
name|int
operator|)
name|fw
argument_list|,
operator|(
name|int
operator|)
name|prec
argument_list|,
operator|(
name|double
operator|)
name|tmpval
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|cp
argument_list|,
literal|"*g"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|obuf
operator|+
name|olen
argument_list|,
name|cpbuf
argument_list|,
operator|(
name|int
operator|)
name|fw
argument_list|,
operator|(
name|double
operator|)
name|tmpval
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
comment|/* GFMT_WORKAROUND */
block|{
name|char
modifier|*
name|gptr
decl_stmt|,
name|gbuf
index|[
literal|120
index|]
decl_stmt|;
define|#
directive|define
name|DEFAULT_G_PRECISION
value|6
if|if
condition|(
name|fw
operator|+
name|prec
operator|+
literal|9
operator|>
sizeof|sizeof
name|gbuf
condition|)
block|{
comment|/* 9==slop */
name|emalloc
argument_list|(
name|gptr
argument_list|,
name|char
operator|*
argument_list|,
name|fw
operator|+
name|prec
operator|+
literal|9
argument_list|,
literal|"do_sprintf(gfmt)"
argument_list|)
expr_stmt|;
block|}
else|else
name|gptr
operator|=
name|gbuf
expr_stmt|;
operator|(
name|void
operator|)
name|gfmt
argument_list|(
operator|(
name|double
operator|)
name|tmpval
argument_list|,
name|cur
operator|!=
operator|&
name|fw
condition|?
operator|(
name|int
operator|)
name|prec
else|:
name|DEFAULT_G_PRECISION
argument_list|,
name|gptr
argument_list|)
expr_stmt|;
operator|*
name|cp
operator|++
operator|=
literal|'*'
operator|,
operator|*
name|cp
operator|++
operator|=
literal|'s'
operator|,
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|obuf
operator|+
name|olen
argument_list|,
name|cpbuf
argument_list|,
operator|(
name|int
operator|)
name|fw
argument_list|,
name|gptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|fill
operator|!=
name|sp
operator|&&
operator|*
name|gptr
operator|==
literal|' '
condition|)
block|{
name|char
modifier|*
name|p
init|=
name|gptr
decl_stmt|;
do|do
block|{
operator|*
name|p
operator|++
operator|=
literal|'0'
expr_stmt|;
block|}
do|while
condition|(
operator|*
name|p
operator|==
literal|' '
condition|)
do|;
block|}
if|if
condition|(
name|gptr
operator|!=
name|gbuf
condition|)
name|free
argument_list|(
name|gptr
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* GFMT_WORKAROUND */
name|len
operator|=
name|strlen
argument_list|(
name|obuf
operator|+
name|olen
argument_list|)
expr_stmt|;
name|ofre
operator|-=
name|len
expr_stmt|;
name|olen
operator|+=
name|len
expr_stmt|;
name|s0
operator|=
name|s1
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
name|parse_next_arg
argument_list|()
expr_stmt|;
name|tmpval
operator|=
name|force_number
argument_list|(
name|arg
argument_list|)
expr_stmt|;
name|free_temp
argument_list|(
name|arg
argument_list|)
expr_stmt|;
name|chksize
argument_list|(
name|fw
operator|+
name|prec
operator|+
literal|9
argument_list|)
expr_stmt|;
comment|/* 9==slop */
name|cp
operator|=
name|cpbuf
expr_stmt|;
operator|*
name|cp
operator|++
operator|=
literal|'%'
expr_stmt|;
if|if
condition|(
name|lj
condition|)
operator|*
name|cp
operator|++
operator|=
literal|'-'
expr_stmt|;
if|if
condition|(
name|fill
operator|!=
name|sp
condition|)
operator|*
name|cp
operator|++
operator|=
literal|'0'
expr_stmt|;
if|if
condition|(
name|cur
operator|!=
operator|&
name|fw
condition|)
block|{
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|cp
argument_list|,
literal|"*.*f"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|obuf
operator|+
name|olen
argument_list|,
name|cpbuf
argument_list|,
operator|(
name|int
operator|)
name|fw
argument_list|,
operator|(
name|int
operator|)
name|prec
argument_list|,
operator|(
name|double
operator|)
name|tmpval
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|cp
argument_list|,
literal|"*f"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|obuf
operator|+
name|olen
argument_list|,
name|cpbuf
argument_list|,
operator|(
name|int
operator|)
name|fw
argument_list|,
operator|(
name|double
operator|)
name|tmpval
argument_list|)
expr_stmt|;
block|}
name|len
operator|=
name|strlen
argument_list|(
name|obuf
operator|+
name|olen
argument_list|)
expr_stmt|;
name|ofre
operator|-=
name|len
expr_stmt|;
name|olen
operator|+=
name|len
expr_stmt|;
name|s0
operator|=
name|s1
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
name|parse_next_arg
argument_list|()
expr_stmt|;
name|tmpval
operator|=
name|force_number
argument_list|(
name|arg
argument_list|)
expr_stmt|;
name|free_temp
argument_list|(
name|arg
argument_list|)
expr_stmt|;
name|chksize
argument_list|(
name|fw
operator|+
name|prec
operator|+
literal|9
argument_list|)
expr_stmt|;
comment|/* 9==slop */
name|cp
operator|=
name|cpbuf
expr_stmt|;
operator|*
name|cp
operator|++
operator|=
literal|'%'
expr_stmt|;
if|if
condition|(
name|lj
condition|)
operator|*
name|cp
operator|++
operator|=
literal|'-'
expr_stmt|;
if|if
condition|(
name|fill
operator|!=
name|sp
condition|)
operator|*
name|cp
operator|++
operator|=
literal|'0'
expr_stmt|;
if|if
condition|(
name|cur
operator|!=
operator|&
name|fw
condition|)
block|{
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|cp
argument_list|,
literal|"*.*e"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|obuf
operator|+
name|olen
argument_list|,
name|cpbuf
argument_list|,
operator|(
name|int
operator|)
name|fw
argument_list|,
operator|(
name|int
operator|)
name|prec
argument_list|,
operator|(
name|double
operator|)
name|tmpval
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|cp
argument_list|,
literal|"*e"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|obuf
operator|+
name|olen
argument_list|,
name|cpbuf
argument_list|,
operator|(
name|int
operator|)
name|fw
argument_list|,
operator|(
name|double
operator|)
name|tmpval
argument_list|)
expr_stmt|;
block|}
name|len
operator|=
name|strlen
argument_list|(
name|obuf
operator|+
name|olen
argument_list|)
expr_stmt|;
name|ofre
operator|-=
name|len
expr_stmt|;
name|olen
operator|+=
name|len
expr_stmt|;
name|s0
operator|=
name|s1
expr_stmt|;
break|break;
default|default:
name|lose
label|:
break|break;
block|}
if|if
condition|(
name|toofew
condition|)
name|fatal
argument_list|(
literal|"%s\n\t%s\n\t%*s%s"
argument_list|,
literal|"not enough arguments to satisfy format string"
argument_list|,
name|sfmt
operator|->
name|stptr
argument_list|,
name|s1
operator|-
name|sfmt
operator|->
name|stptr
operator|-
literal|2
argument_list|,
literal|""
argument_list|,
literal|"^ ran out for this one"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|do_lint
operator|&&
name|carg
operator|!=
name|NULL
condition|)
name|warning
argument_list|(
literal|"too many arguments supplied for format string"
argument_list|)
expr_stmt|;
name|bchunk
argument_list|(
name|s0
argument_list|,
name|s1
operator|-
name|s0
argument_list|)
expr_stmt|;
name|free_temp
argument_list|(
name|sfmt
argument_list|)
expr_stmt|;
name|r
operator|=
name|make_str_node
argument_list|(
name|obuf
argument_list|,
name|olen
argument_list|,
name|ALREADY_MALLOCED
argument_list|)
expr_stmt|;
name|r
operator|->
name|flags
operator||=
name|TEMP
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_function
name|void
name|do_printf
parameter_list|(
name|tree
parameter_list|)
specifier|register
name|NODE
modifier|*
name|tree
decl_stmt|;
block|{
name|struct
name|redirect
modifier|*
name|rp
init|=
name|NULL
decl_stmt|;
specifier|register
name|FILE
modifier|*
name|fp
decl_stmt|;
if|if
condition|(
name|tree
operator|->
name|rnode
condition|)
block|{
name|int
name|errflg
decl_stmt|;
comment|/* not used, sigh */
name|rp
operator|=
name|redirect
argument_list|(
name|tree
operator|->
name|rnode
argument_list|,
operator|&
name|errflg
argument_list|)
expr_stmt|;
if|if
condition|(
name|rp
condition|)
block|{
name|fp
operator|=
name|rp
operator|->
name|fp
expr_stmt|;
if|if
condition|(
operator|!
name|fp
condition|)
return|return;
block|}
else|else
return|return;
block|}
else|else
name|fp
operator|=
name|stdout
expr_stmt|;
name|tree
operator|=
name|do_sprintf
argument_list|(
name|tree
operator|->
name|lnode
argument_list|)
expr_stmt|;
name|efwrite
argument_list|(
name|tree
operator|->
name|stptr
argument_list|,
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|,
name|tree
operator|->
name|stlen
argument_list|,
name|fp
argument_list|,
literal|"printf"
argument_list|,
name|rp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|free_temp
argument_list|(
name|tree
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|NODE
modifier|*
name|do_sqrt
parameter_list|(
name|tree
parameter_list|)
name|NODE
modifier|*
name|tree
decl_stmt|;
block|{
name|NODE
modifier|*
name|tmp
decl_stmt|;
name|double
name|arg
decl_stmt|;
specifier|extern
name|double
name|sqrt
name|P
argument_list|(
operator|(
name|double
operator|)
argument_list|)
decl_stmt|;
name|tmp
operator|=
name|tree_eval
argument_list|(
name|tree
operator|->
name|lnode
argument_list|)
expr_stmt|;
name|arg
operator|=
operator|(
name|double
operator|)
name|force_number
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
name|free_temp
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg
operator|<
literal|0.0
condition|)
name|warning
argument_list|(
literal|"sqrt called with negative argument %g"
argument_list|,
name|arg
argument_list|)
expr_stmt|;
return|return
name|tmp_number
argument_list|(
operator|(
name|AWKNUM
operator|)
name|sqrt
argument_list|(
name|arg
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|NODE
modifier|*
name|do_substr
parameter_list|(
name|tree
parameter_list|)
name|NODE
modifier|*
name|tree
decl_stmt|;
block|{
name|NODE
modifier|*
name|t1
decl_stmt|,
modifier|*
name|t2
decl_stmt|,
modifier|*
name|t3
decl_stmt|;
name|NODE
modifier|*
name|r
decl_stmt|;
specifier|register
name|int
name|indx
decl_stmt|;
name|size_t
name|length
decl_stmt|;
name|t1
operator|=
name|tree_eval
argument_list|(
name|tree
operator|->
name|lnode
argument_list|)
expr_stmt|;
name|t2
operator|=
name|tree_eval
argument_list|(
name|tree
operator|->
name|rnode
operator|->
name|lnode
argument_list|)
expr_stmt|;
if|if
condition|(
name|tree
operator|->
name|rnode
operator|->
name|rnode
operator|==
name|NULL
condition|)
comment|/* third arg. missing */
name|length
operator|=
name|t1
operator|->
name|stlen
expr_stmt|;
else|else
block|{
name|t3
operator|=
name|tree_eval
argument_list|(
name|tree
operator|->
name|rnode
operator|->
name|rnode
operator|->
name|lnode
argument_list|)
expr_stmt|;
name|length
operator|=
operator|(
name|size_t
operator|)
name|force_number
argument_list|(
name|t3
argument_list|)
expr_stmt|;
name|free_temp
argument_list|(
name|t3
argument_list|)
expr_stmt|;
block|}
name|indx
operator|=
operator|(
name|int
operator|)
name|force_number
argument_list|(
name|t2
argument_list|)
operator|-
literal|1
expr_stmt|;
name|free_temp
argument_list|(
name|t2
argument_list|)
expr_stmt|;
name|t1
operator|=
name|force_string
argument_list|(
name|t1
argument_list|)
expr_stmt|;
if|if
condition|(
name|indx
operator|<
literal|0
condition|)
name|indx
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|indx
operator|>=
name|t1
operator|->
name|stlen
operator|||
name|length
operator|<=
literal|0
condition|)
block|{
name|free_temp
argument_list|(
name|t1
argument_list|)
expr_stmt|;
return|return
name|Nnull_string
return|;
block|}
if|if
condition|(
name|indx
operator|+
name|length
operator|>
name|t1
operator|->
name|stlen
operator|||
name|LONG_MAX
operator|-
name|indx
operator|<
name|length
condition|)
name|length
operator|=
name|t1
operator|->
name|stlen
operator|-
name|indx
expr_stmt|;
name|r
operator|=
name|tmp_string
argument_list|(
name|t1
operator|->
name|stptr
operator|+
name|indx
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|free_temp
argument_list|(
name|t1
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_function
name|NODE
modifier|*
name|do_strftime
parameter_list|(
name|tree
parameter_list|)
name|NODE
modifier|*
name|tree
decl_stmt|;
block|{
name|NODE
modifier|*
name|t1
decl_stmt|,
modifier|*
name|t2
decl_stmt|;
name|struct
name|tm
modifier|*
name|tm
decl_stmt|;
name|time_t
name|fclock
decl_stmt|;
name|char
name|buf
index|[
literal|100
index|]
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|t1
operator|=
name|force_string
argument_list|(
name|tree_eval
argument_list|(
name|tree
operator|->
name|lnode
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|tree
operator|->
name|rnode
operator|==
name|NULL
condition|)
comment|/* second arg. missing, default */
operator|(
name|void
operator|)
name|time
argument_list|(
operator|&
name|fclock
argument_list|)
expr_stmt|;
else|else
block|{
name|t2
operator|=
name|tree_eval
argument_list|(
name|tree
operator|->
name|rnode
operator|->
name|lnode
argument_list|)
expr_stmt|;
name|fclock
operator|=
operator|(
name|time_t
operator|)
name|force_number
argument_list|(
name|t2
argument_list|)
expr_stmt|;
name|free_temp
argument_list|(
name|t2
argument_list|)
expr_stmt|;
block|}
name|tm
operator|=
name|localtime
argument_list|(
operator|&
name|fclock
argument_list|)
expr_stmt|;
name|ret
operator|=
name|strftime
argument_list|(
name|buf
argument_list|,
literal|100
argument_list|,
name|t1
operator|->
name|stptr
argument_list|,
name|tm
argument_list|)
expr_stmt|;
return|return
name|tmp_string
argument_list|(
name|buf
argument_list|,
name|ret
argument_list|)
return|;
block|}
end_function

begin_function
name|NODE
modifier|*
name|do_systime
parameter_list|(
name|tree
parameter_list|)
name|NODE
modifier|*
name|tree
decl_stmt|;
block|{
name|time_t
name|lclock
decl_stmt|;
operator|(
name|void
operator|)
name|time
argument_list|(
operator|&
name|lclock
argument_list|)
expr_stmt|;
return|return
name|tmp_number
argument_list|(
operator|(
name|AWKNUM
operator|)
name|lclock
argument_list|)
return|;
block|}
end_function

begin_function
name|NODE
modifier|*
name|do_system
parameter_list|(
name|tree
parameter_list|)
name|NODE
modifier|*
name|tree
decl_stmt|;
block|{
name|NODE
modifier|*
name|tmp
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|cmd
decl_stmt|;
operator|(
name|void
operator|)
name|flush_io
argument_list|()
expr_stmt|;
comment|/* so output is synchronous with gawk's */
name|tmp
operator|=
name|tree_eval
argument_list|(
name|tree
operator|->
name|lnode
argument_list|)
expr_stmt|;
name|cmd
operator|=
name|force_string
argument_list|(
name|tmp
argument_list|)
operator|->
name|stptr
expr_stmt|;
if|if
condition|(
name|cmd
operator|&&
operator|*
name|cmd
condition|)
block|{
name|ret
operator|=
name|system
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
name|ret
operator|=
operator|(
name|ret
operator|>>
literal|8
operator|)
operator|&
literal|0xff
expr_stmt|;
block|}
name|free_temp
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
return|return
name|tmp_number
argument_list|(
operator|(
name|AWKNUM
operator|)
name|ret
argument_list|)
return|;
block|}
end_function

begin_function
name|void
name|do_print
parameter_list|(
name|tree
parameter_list|)
specifier|register
name|NODE
modifier|*
name|tree
decl_stmt|;
block|{
specifier|register
name|NODE
modifier|*
name|t1
decl_stmt|;
name|struct
name|redirect
modifier|*
name|rp
init|=
name|NULL
decl_stmt|;
specifier|register
name|FILE
modifier|*
name|fp
decl_stmt|;
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
if|if
condition|(
name|tree
operator|->
name|rnode
condition|)
block|{
name|int
name|errflg
decl_stmt|;
comment|/* not used, sigh */
name|rp
operator|=
name|redirect
argument_list|(
name|tree
operator|->
name|rnode
argument_list|,
operator|&
name|errflg
argument_list|)
expr_stmt|;
if|if
condition|(
name|rp
condition|)
block|{
name|fp
operator|=
name|rp
operator|->
name|fp
expr_stmt|;
if|if
condition|(
operator|!
name|fp
condition|)
return|return;
block|}
else|else
return|return;
block|}
else|else
name|fp
operator|=
name|stdout
expr_stmt|;
name|tree
operator|=
name|tree
operator|->
name|lnode
expr_stmt|;
while|while
condition|(
name|tree
condition|)
block|{
name|t1
operator|=
name|tree_eval
argument_list|(
name|tree
operator|->
name|lnode
argument_list|)
expr_stmt|;
if|if
condition|(
name|t1
operator|->
name|flags
operator|&
name|NUMBER
condition|)
block|{
if|if
condition|(
name|OFMTidx
operator|==
name|CONVFMTidx
condition|)
operator|(
name|void
operator|)
name|force_string
argument_list|(
name|t1
argument_list|)
expr_stmt|;
else|else
block|{
name|char
name|buf
index|[
literal|100
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
name|OFMT
argument_list|,
name|t1
operator|->
name|numbr
argument_list|)
expr_stmt|;
name|t1
operator|=
name|tmp_string
argument_list|(
name|buf
argument_list|,
name|strlen
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|efwrite
argument_list|(
name|t1
operator|->
name|stptr
argument_list|,
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|,
name|t1
operator|->
name|stlen
argument_list|,
name|fp
argument_list|,
literal|"print"
argument_list|,
name|rp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|free_temp
argument_list|(
name|t1
argument_list|)
expr_stmt|;
name|tree
operator|=
name|tree
operator|->
name|rnode
expr_stmt|;
if|if
condition|(
name|tree
condition|)
block|{
name|s
operator|=
name|OFS
expr_stmt|;
if|if
condition|(
name|OFSlen
condition|)
name|efwrite
argument_list|(
name|s
argument_list|,
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|,
name|OFSlen
argument_list|,
name|fp
argument_list|,
literal|"print"
argument_list|,
name|rp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
name|s
operator|=
name|ORS
expr_stmt|;
if|if
condition|(
name|ORSlen
condition|)
name|efwrite
argument_list|(
name|s
argument_list|,
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|,
name|ORSlen
argument_list|,
name|fp
argument_list|,
literal|"print"
argument_list|,
name|rp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|NODE
modifier|*
name|do_tolower
parameter_list|(
name|tree
parameter_list|)
name|NODE
modifier|*
name|tree
decl_stmt|;
block|{
name|NODE
modifier|*
name|t1
decl_stmt|,
modifier|*
name|t2
decl_stmt|;
specifier|register
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|cp2
decl_stmt|;
name|t1
operator|=
name|tree_eval
argument_list|(
name|tree
operator|->
name|lnode
argument_list|)
expr_stmt|;
name|t1
operator|=
name|force_string
argument_list|(
name|t1
argument_list|)
expr_stmt|;
name|t2
operator|=
name|tmp_string
argument_list|(
name|t1
operator|->
name|stptr
argument_list|,
name|t1
operator|->
name|stlen
argument_list|)
expr_stmt|;
for|for
control|(
name|cp
operator|=
name|t2
operator|->
name|stptr
operator|,
name|cp2
operator|=
name|t2
operator|->
name|stptr
operator|+
name|t2
operator|->
name|stlen
init|;
name|cp
operator|<
name|cp2
condition|;
name|cp
operator|++
control|)
if|if
condition|(
name|isupper
argument_list|(
operator|*
name|cp
argument_list|)
condition|)
operator|*
name|cp
operator|=
name|tolower
argument_list|(
operator|*
name|cp
argument_list|)
expr_stmt|;
name|free_temp
argument_list|(
name|t1
argument_list|)
expr_stmt|;
return|return
name|t2
return|;
block|}
end_function

begin_function
name|NODE
modifier|*
name|do_toupper
parameter_list|(
name|tree
parameter_list|)
name|NODE
modifier|*
name|tree
decl_stmt|;
block|{
name|NODE
modifier|*
name|t1
decl_stmt|,
modifier|*
name|t2
decl_stmt|;
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
name|t1
operator|=
name|tree_eval
argument_list|(
name|tree
operator|->
name|lnode
argument_list|)
expr_stmt|;
name|t1
operator|=
name|force_string
argument_list|(
name|t1
argument_list|)
expr_stmt|;
name|t2
operator|=
name|tmp_string
argument_list|(
name|t1
operator|->
name|stptr
argument_list|,
name|t1
operator|->
name|stlen
argument_list|)
expr_stmt|;
for|for
control|(
name|cp
operator|=
name|t2
operator|->
name|stptr
init|;
name|cp
operator|<
name|t2
operator|->
name|stptr
operator|+
name|t2
operator|->
name|stlen
condition|;
name|cp
operator|++
control|)
if|if
condition|(
name|islower
argument_list|(
operator|*
name|cp
argument_list|)
condition|)
operator|*
name|cp
operator|=
name|toupper
argument_list|(
operator|*
name|cp
argument_list|)
expr_stmt|;
name|free_temp
argument_list|(
name|t1
argument_list|)
expr_stmt|;
return|return
name|t2
return|;
block|}
end_function

begin_function
name|NODE
modifier|*
name|do_atan2
parameter_list|(
name|tree
parameter_list|)
name|NODE
modifier|*
name|tree
decl_stmt|;
block|{
name|NODE
modifier|*
name|t1
decl_stmt|,
modifier|*
name|t2
decl_stmt|;
specifier|extern
name|double
name|atan2
name|P
argument_list|(
operator|(
name|double
operator|,
name|double
operator|)
argument_list|)
decl_stmt|;
name|double
name|d1
decl_stmt|,
name|d2
decl_stmt|;
name|t1
operator|=
name|tree_eval
argument_list|(
name|tree
operator|->
name|lnode
argument_list|)
expr_stmt|;
name|t2
operator|=
name|tree_eval
argument_list|(
name|tree
operator|->
name|rnode
operator|->
name|lnode
argument_list|)
expr_stmt|;
name|d1
operator|=
name|force_number
argument_list|(
name|t1
argument_list|)
expr_stmt|;
name|d2
operator|=
name|force_number
argument_list|(
name|t2
argument_list|)
expr_stmt|;
name|free_temp
argument_list|(
name|t1
argument_list|)
expr_stmt|;
name|free_temp
argument_list|(
name|t2
argument_list|)
expr_stmt|;
return|return
name|tmp_number
argument_list|(
operator|(
name|AWKNUM
operator|)
name|atan2
argument_list|(
name|d1
argument_list|,
name|d2
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|NODE
modifier|*
name|do_sin
parameter_list|(
name|tree
parameter_list|)
name|NODE
modifier|*
name|tree
decl_stmt|;
block|{
name|NODE
modifier|*
name|tmp
decl_stmt|;
specifier|extern
name|double
name|sin
name|P
argument_list|(
operator|(
name|double
operator|)
argument_list|)
decl_stmt|;
name|double
name|d
decl_stmt|;
name|tmp
operator|=
name|tree_eval
argument_list|(
name|tree
operator|->
name|lnode
argument_list|)
expr_stmt|;
name|d
operator|=
name|sin
argument_list|(
operator|(
name|double
operator|)
name|force_number
argument_list|(
name|tmp
argument_list|)
argument_list|)
expr_stmt|;
name|free_temp
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
return|return
name|tmp_number
argument_list|(
operator|(
name|AWKNUM
operator|)
name|d
argument_list|)
return|;
block|}
end_function

begin_function
name|NODE
modifier|*
name|do_cos
parameter_list|(
name|tree
parameter_list|)
name|NODE
modifier|*
name|tree
decl_stmt|;
block|{
name|NODE
modifier|*
name|tmp
decl_stmt|;
specifier|extern
name|double
name|cos
name|P
argument_list|(
operator|(
name|double
operator|)
argument_list|)
decl_stmt|;
name|double
name|d
decl_stmt|;
name|tmp
operator|=
name|tree_eval
argument_list|(
name|tree
operator|->
name|lnode
argument_list|)
expr_stmt|;
name|d
operator|=
name|cos
argument_list|(
operator|(
name|double
operator|)
name|force_number
argument_list|(
name|tmp
argument_list|)
argument_list|)
expr_stmt|;
name|free_temp
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
return|return
name|tmp_number
argument_list|(
operator|(
name|AWKNUM
operator|)
name|d
argument_list|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|int
name|firstrand
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|state
index|[
literal|256
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|NODE
modifier|*
name|do_rand
parameter_list|(
name|tree
parameter_list|)
name|NODE
modifier|*
name|tree
decl_stmt|;
block|{
if|if
condition|(
name|firstrand
condition|)
block|{
operator|(
name|void
operator|)
name|initstate
argument_list|(
operator|(
name|unsigned
operator|)
literal|1
argument_list|,
name|state
argument_list|,
sizeof|sizeof
name|state
argument_list|)
expr_stmt|;
name|srandom
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|firstrand
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|tmp_number
argument_list|(
operator|(
name|AWKNUM
operator|)
name|random
argument_list|()
operator|/
name|LONG_MAX
argument_list|)
return|;
block|}
end_function

begin_function
name|NODE
modifier|*
name|do_srand
parameter_list|(
name|tree
parameter_list|)
name|NODE
modifier|*
name|tree
decl_stmt|;
block|{
name|NODE
modifier|*
name|tmp
decl_stmt|;
specifier|static
name|long
name|save_seed
init|=
literal|0
decl_stmt|;
name|long
name|ret
init|=
name|save_seed
decl_stmt|;
comment|/* SVR4 awk srand returns previous seed */
if|if
condition|(
name|firstrand
condition|)
operator|(
name|void
operator|)
name|initstate
argument_list|(
operator|(
name|unsigned
operator|)
literal|1
argument_list|,
name|state
argument_list|,
sizeof|sizeof
name|state
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|setstate
argument_list|(
name|state
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|tree
condition|)
name|srandom
argument_list|(
call|(
name|int
call|)
argument_list|(
name|save_seed
operator|=
operator|(
name|long
operator|)
name|time
argument_list|(
operator|(
name|time_t
operator|*
operator|)
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|tmp
operator|=
name|tree_eval
argument_list|(
name|tree
operator|->
name|lnode
argument_list|)
expr_stmt|;
name|srandom
argument_list|(
call|(
name|int
call|)
argument_list|(
name|save_seed
operator|=
operator|(
name|long
operator|)
name|force_number
argument_list|(
name|tmp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|free_temp
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
block|}
name|firstrand
operator|=
literal|0
expr_stmt|;
return|return
name|tmp_number
argument_list|(
operator|(
name|AWKNUM
operator|)
name|ret
argument_list|)
return|;
block|}
end_function

begin_function
name|NODE
modifier|*
name|do_match
parameter_list|(
name|tree
parameter_list|)
name|NODE
modifier|*
name|tree
decl_stmt|;
block|{
name|NODE
modifier|*
name|t1
decl_stmt|;
name|int
name|rstart
decl_stmt|;
name|AWKNUM
name|rlength
decl_stmt|;
name|Regexp
modifier|*
name|rp
decl_stmt|;
name|t1
operator|=
name|force_string
argument_list|(
name|tree_eval
argument_list|(
name|tree
operator|->
name|lnode
argument_list|)
argument_list|)
expr_stmt|;
name|tree
operator|=
name|tree
operator|->
name|rnode
operator|->
name|lnode
expr_stmt|;
name|rp
operator|=
name|re_update
argument_list|(
name|tree
argument_list|)
expr_stmt|;
name|rstart
operator|=
name|research
argument_list|(
name|rp
argument_list|,
name|t1
operator|->
name|stptr
argument_list|,
literal|0
argument_list|,
name|t1
operator|->
name|stlen
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|rstart
operator|>=
literal|0
condition|)
block|{
comment|/* match succeded */
name|rstart
operator|++
expr_stmt|;
comment|/* 1-based indexing */
name|rlength
operator|=
name|REEND
argument_list|(
name|rp
argument_list|,
name|t1
operator|->
name|stptr
argument_list|)
operator|-
name|RESTART
argument_list|(
name|rp
argument_list|,
name|t1
operator|->
name|stptr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* match failed */
name|rstart
operator|=
literal|0
expr_stmt|;
name|rlength
operator|=
operator|-
literal|1.0
expr_stmt|;
block|}
name|free_temp
argument_list|(
name|t1
argument_list|)
expr_stmt|;
name|unref
argument_list|(
name|RSTART_node
operator|->
name|var_value
argument_list|)
expr_stmt|;
name|RSTART_node
operator|->
name|var_value
operator|=
name|make_number
argument_list|(
operator|(
name|AWKNUM
operator|)
name|rstart
argument_list|)
expr_stmt|;
name|unref
argument_list|(
name|RLENGTH_node
operator|->
name|var_value
argument_list|)
expr_stmt|;
name|RLENGTH_node
operator|->
name|var_value
operator|=
name|make_number
argument_list|(
name|rlength
argument_list|)
expr_stmt|;
return|return
name|tmp_number
argument_list|(
operator|(
name|AWKNUM
operator|)
name|rstart
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|NODE
modifier|*
name|sub_common
parameter_list|(
name|tree
parameter_list|,
name|global
parameter_list|)
name|NODE
modifier|*
name|tree
decl_stmt|;
name|int
name|global
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|scan
decl_stmt|;
specifier|register
name|char
modifier|*
name|bp
decl_stmt|,
modifier|*
name|cp
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
name|int
name|buflen
decl_stmt|;
specifier|register
name|char
modifier|*
name|matchend
decl_stmt|;
specifier|register
name|int
name|len
decl_stmt|;
name|char
modifier|*
name|matchstart
decl_stmt|;
name|char
modifier|*
name|text
decl_stmt|;
name|int
name|textlen
decl_stmt|;
name|char
modifier|*
name|repl
decl_stmt|;
name|char
modifier|*
name|replend
decl_stmt|;
name|int
name|repllen
decl_stmt|;
name|int
name|sofar
decl_stmt|;
name|int
name|ampersands
decl_stmt|;
name|int
name|matches
init|=
literal|0
decl_stmt|;
name|Regexp
modifier|*
name|rp
decl_stmt|;
name|NODE
modifier|*
name|s
decl_stmt|;
comment|/* subst. pattern */
name|NODE
modifier|*
name|t
decl_stmt|;
comment|/* string to make sub. in; $0 if none given */
name|NODE
modifier|*
name|tmp
decl_stmt|;
name|NODE
modifier|*
modifier|*
name|lhs
init|=
operator|&
name|tree
decl_stmt|;
comment|/* value not used -- just different from NULL */
name|int
name|priv
init|=
literal|0
decl_stmt|;
name|Func_ptr
name|after_assign
init|=
name|NULL
decl_stmt|;
name|tmp
operator|=
name|tree
operator|->
name|lnode
expr_stmt|;
name|rp
operator|=
name|re_update
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
name|tree
operator|=
name|tree
operator|->
name|rnode
expr_stmt|;
name|s
operator|=
name|tree
operator|->
name|lnode
expr_stmt|;
name|tree
operator|=
name|tree
operator|->
name|rnode
expr_stmt|;
name|tmp
operator|=
name|tree
operator|->
name|lnode
expr_stmt|;
name|t
operator|=
name|force_string
argument_list|(
name|tree_eval
argument_list|(
name|tmp
argument_list|)
argument_list|)
expr_stmt|;
comment|/* do the search early to avoid work on non-match */
if|if
condition|(
name|research
argument_list|(
name|rp
argument_list|,
name|t
operator|->
name|stptr
argument_list|,
literal|0
argument_list|,
name|t
operator|->
name|stlen
argument_list|,
literal|1
argument_list|)
operator|==
operator|-
literal|1
operator|||
operator|(
name|RESTART
argument_list|(
name|rp
argument_list|,
name|t
operator|->
name|stptr
argument_list|)
operator|>
name|t
operator|->
name|stlen
operator|)
operator|&&
operator|(
name|matches
operator|=
literal|1
operator|)
condition|)
block|{
name|free_temp
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return
name|tmp_number
argument_list|(
operator|(
name|AWKNUM
operator|)
name|matches
argument_list|)
return|;
block|}
if|if
condition|(
name|tmp
operator|->
name|type
operator|==
name|Node_val
condition|)
name|lhs
operator|=
name|NULL
expr_stmt|;
else|else
name|lhs
operator|=
name|get_lhs
argument_list|(
name|tmp
argument_list|,
operator|&
name|after_assign
argument_list|)
expr_stmt|;
name|t
operator|->
name|flags
operator||=
name|STRING
expr_stmt|;
comment|/* 	 * create a private copy of the string 	 */
if|if
condition|(
name|t
operator|->
name|stref
operator|>
literal|1
operator|||
operator|(
name|t
operator|->
name|flags
operator|&
name|PERM
operator|)
condition|)
block|{
name|unsigned
name|int
name|saveflags
decl_stmt|;
name|saveflags
operator|=
name|t
operator|->
name|flags
expr_stmt|;
name|t
operator|->
name|flags
operator|&=
operator|~
name|MALLOC
expr_stmt|;
name|tmp
operator|=
name|dupnode
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|t
operator|->
name|flags
operator|=
name|saveflags
expr_stmt|;
name|t
operator|=
name|tmp
expr_stmt|;
name|priv
operator|=
literal|1
expr_stmt|;
block|}
name|text
operator|=
name|t
operator|->
name|stptr
expr_stmt|;
name|textlen
operator|=
name|t
operator|->
name|stlen
expr_stmt|;
name|buflen
operator|=
name|textlen
operator|+
literal|2
expr_stmt|;
name|s
operator|=
name|force_string
argument_list|(
name|tree_eval
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
name|repl
operator|=
name|s
operator|->
name|stptr
expr_stmt|;
name|replend
operator|=
name|repl
operator|+
name|s
operator|->
name|stlen
expr_stmt|;
name|repllen
operator|=
name|replend
operator|-
name|repl
expr_stmt|;
name|emalloc
argument_list|(
name|buf
argument_list|,
name|char
operator|*
argument_list|,
name|buflen
argument_list|,
literal|"do_sub"
argument_list|)
expr_stmt|;
name|ampersands
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|scan
operator|=
name|repl
init|;
name|scan
operator|<
name|replend
condition|;
name|scan
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|scan
operator|==
literal|'&'
condition|)
block|{
name|repllen
operator|--
expr_stmt|;
name|ampersands
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|scan
operator|==
literal|'\\'
operator|&&
operator|(
operator|*
operator|(
name|scan
operator|+
literal|1
operator|)
operator|==
literal|'&'
operator|||
operator|*
operator|(
name|scan
operator|+
literal|1
operator|)
operator|==
literal|'\\'
operator|)
condition|)
block|{
name|repllen
operator|--
expr_stmt|;
name|scan
operator|++
expr_stmt|;
block|}
block|}
name|bp
operator|=
name|buf
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|matches
operator|++
expr_stmt|;
name|matchstart
operator|=
name|t
operator|->
name|stptr
operator|+
name|RESTART
argument_list|(
name|rp
argument_list|,
name|t
operator|->
name|stptr
argument_list|)
expr_stmt|;
name|matchend
operator|=
name|t
operator|->
name|stptr
operator|+
name|REEND
argument_list|(
name|rp
argument_list|,
name|t
operator|->
name|stptr
argument_list|)
expr_stmt|;
comment|/* 		 * create the result, copying in parts of the original 		 * string  		 */
name|len
operator|=
name|matchstart
operator|-
name|text
operator|+
name|repllen
operator|+
name|ampersands
operator|*
operator|(
name|matchend
operator|-
name|matchstart
operator|)
expr_stmt|;
name|sofar
operator|=
name|bp
operator|-
name|buf
expr_stmt|;
while|while
condition|(
name|buflen
operator|-
name|sofar
operator|-
name|len
operator|-
literal|1
operator|<
literal|0
condition|)
block|{
name|buflen
operator|*=
literal|2
expr_stmt|;
name|erealloc
argument_list|(
name|buf
argument_list|,
name|char
operator|*
argument_list|,
name|buflen
argument_list|,
literal|"do_sub"
argument_list|)
expr_stmt|;
name|bp
operator|=
name|buf
operator|+
name|sofar
expr_stmt|;
block|}
for|for
control|(
name|scan
operator|=
name|text
init|;
name|scan
operator|<
name|matchstart
condition|;
name|scan
operator|++
control|)
operator|*
name|bp
operator|++
operator|=
operator|*
name|scan
expr_stmt|;
for|for
control|(
name|scan
operator|=
name|repl
init|;
name|scan
operator|<
name|replend
condition|;
name|scan
operator|++
control|)
if|if
condition|(
operator|*
name|scan
operator|==
literal|'&'
condition|)
for|for
control|(
name|cp
operator|=
name|matchstart
init|;
name|cp
operator|<
name|matchend
condition|;
name|cp
operator|++
control|)
operator|*
name|bp
operator|++
operator|=
operator|*
name|cp
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|scan
operator|==
literal|'\\'
operator|&&
operator|(
operator|*
operator|(
name|scan
operator|+
literal|1
operator|)
operator|==
literal|'&'
operator|||
operator|*
operator|(
name|scan
operator|+
literal|1
operator|)
operator|==
literal|'\\'
operator|)
condition|)
block|{
name|scan
operator|++
expr_stmt|;
operator|*
name|bp
operator|++
operator|=
operator|*
name|scan
expr_stmt|;
block|}
else|else
operator|*
name|bp
operator|++
operator|=
operator|*
name|scan
expr_stmt|;
if|if
condition|(
name|global
operator|&&
name|matchstart
operator|==
name|matchend
operator|&&
name|matchend
operator|<
name|text
operator|+
name|textlen
condition|)
block|{
operator|*
name|bp
operator|++
operator|=
operator|*
name|matchend
expr_stmt|;
name|matchend
operator|++
expr_stmt|;
block|}
name|textlen
operator|=
name|text
operator|+
name|textlen
operator|-
name|matchend
expr_stmt|;
name|text
operator|=
name|matchend
expr_stmt|;
if|if
condition|(
operator|!
name|global
operator|||
name|textlen
operator|<=
literal|0
operator|||
name|research
argument_list|(
name|rp
argument_list|,
name|t
operator|->
name|stptr
argument_list|,
name|text
operator|-
name|t
operator|->
name|stptr
argument_list|,
name|textlen
argument_list|,
literal|1
argument_list|)
operator|==
operator|-
literal|1
condition|)
break|break;
block|}
name|sofar
operator|=
name|bp
operator|-
name|buf
expr_stmt|;
if|if
condition|(
name|buflen
operator|-
name|sofar
operator|-
name|textlen
operator|-
literal|1
condition|)
block|{
name|buflen
operator|=
name|sofar
operator|+
name|textlen
operator|+
literal|2
expr_stmt|;
name|erealloc
argument_list|(
name|buf
argument_list|,
name|char
operator|*
argument_list|,
name|buflen
argument_list|,
literal|"do_sub"
argument_list|)
expr_stmt|;
name|bp
operator|=
name|buf
operator|+
name|sofar
expr_stmt|;
block|}
for|for
control|(
name|scan
operator|=
name|matchend
init|;
name|scan
operator|<
name|text
operator|+
name|textlen
condition|;
name|scan
operator|++
control|)
operator|*
name|bp
operator|++
operator|=
operator|*
name|scan
expr_stmt|;
name|textlen
operator|=
name|bp
operator|-
name|buf
expr_stmt|;
name|free
argument_list|(
name|t
operator|->
name|stptr
argument_list|)
expr_stmt|;
name|t
operator|->
name|stptr
operator|=
name|buf
expr_stmt|;
name|t
operator|->
name|stlen
operator|=
name|textlen
expr_stmt|;
name|free_temp
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|matches
operator|>
literal|0
operator|&&
name|lhs
condition|)
block|{
if|if
condition|(
name|priv
condition|)
block|{
name|unref
argument_list|(
operator|*
name|lhs
argument_list|)
expr_stmt|;
operator|*
name|lhs
operator|=
name|t
expr_stmt|;
block|}
if|if
condition|(
name|after_assign
condition|)
call|(
modifier|*
name|after_assign
call|)
argument_list|()
expr_stmt|;
name|t
operator|->
name|flags
operator|&=
operator|~
operator|(
name|NUM
operator||
name|NUMBER
operator|)
expr_stmt|;
block|}
return|return
name|tmp_number
argument_list|(
operator|(
name|AWKNUM
operator|)
name|matches
argument_list|)
return|;
block|}
end_function

begin_function
name|NODE
modifier|*
name|do_gsub
parameter_list|(
name|tree
parameter_list|)
name|NODE
modifier|*
name|tree
decl_stmt|;
block|{
return|return
name|sub_common
argument_list|(
name|tree
argument_list|,
literal|1
argument_list|)
return|;
block|}
end_function

begin_function
name|NODE
modifier|*
name|do_sub
parameter_list|(
name|tree
parameter_list|)
name|NODE
modifier|*
name|tree
decl_stmt|;
block|{
return|return
name|sub_common
argument_list|(
name|tree
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|GFMT_WORKAROUND
end_ifdef

begin_comment
comment|/* 	 *	printf's %g format [can't rely on gcvt()] 	 *		caveat: don't use as argument to *printf()! 	 */
end_comment

begin_function
name|char
modifier|*
name|gfmt
parameter_list|(
name|g
parameter_list|,
name|prec
parameter_list|,
name|buf
parameter_list|)
name|double
name|g
decl_stmt|;
comment|/* value to format */
name|int
name|prec
decl_stmt|;
comment|/* indicates desired significant digits, not decimal places */
name|char
modifier|*
name|buf
decl_stmt|;
comment|/* return buffer; assumed big enough to hold result */
block|{
if|if
condition|(
name|g
operator|==
literal|0.0
condition|)
block|{
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|buf
argument_list|,
literal|"0"
argument_list|)
expr_stmt|;
comment|/* easy special case */
block|}
else|else
block|{
specifier|register
name|char
modifier|*
name|d
decl_stmt|,
modifier|*
name|e
decl_stmt|,
modifier|*
name|p
decl_stmt|;
comment|/* start with 'e' format (it'll provide nice exponent) */
if|if
condition|(
name|prec
operator|<
literal|1
condition|)
name|prec
operator|=
literal|1
expr_stmt|;
comment|/* at least 1 significant digit */
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%.*e"
argument_list|,
name|prec
operator|-
literal|1
argument_list|,
name|g
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|e
operator|=
name|strchr
argument_list|(
name|buf
argument_list|,
literal|'e'
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* find exponent  */
name|int
name|exp
init|=
name|atoi
argument_list|(
name|e
operator|+
literal|1
argument_list|)
decl_stmt|;
comment|/* fetch exponent */
if|if
condition|(
name|exp
operator|>=
operator|-
literal|4
operator|&&
name|exp
operator|<
name|prec
condition|)
block|{
comment|/* per K&R2, B1.2 */
comment|/* switch to 'f' format and re-do */
name|prec
operator|-=
operator|(
name|exp
operator|+
literal|1
operator|)
expr_stmt|;
comment|/* decimal precision */
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%.*f"
argument_list|,
name|prec
argument_list|,
name|g
argument_list|)
expr_stmt|;
name|e
operator|=
name|buf
operator|+
name|strlen
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|d
operator|=
name|strchr
argument_list|(
name|buf
argument_list|,
literal|'.'
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* remove trailing zeroes and decimal point */
for|for
control|(
name|p
operator|=
name|e
init|;
name|p
operator|>
name|d
operator|&&
operator|*
operator|--
name|p
operator|==
literal|'0'
condition|;
control|)
continue|continue;
if|if
condition|(
operator|*
name|p
operator|==
literal|'.'
condition|)
operator|--
name|p
expr_stmt|;
if|if
condition|(
operator|++
name|p
operator|<
name|e
condition|)
comment|/* copy exponent and NUL */
while|while
condition|(
operator|(
operator|*
name|p
operator|++
operator|=
operator|*
name|e
operator|++
operator|)
operator|!=
literal|'\0'
condition|)
continue|continue;
block|}
block|}
block|}
return|return
name|buf
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* GFMT_WORKAROUND */
end_comment

end_unit

