begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * vms_gawk.c -- parse GAWK command line using DCL syntax ]  */
end_comment

begin_comment
comment|/*  * Copyright (C) 1991 the Free Software Foundation, Inc.  *  * This file is part of GAWK, the GNU implementation of the  * AWK Progamming Language.  *  * GAWK is free software; you can redistribute it and/or modify  * it under the terms of the GNU General Public License as published by  * the Free Software Foundation; either version 2 of the License, or  * (at your option) any later version.  *  * GAWK is distributed in the hope that it will be useful,  * but WITHOUT ANY WARRANTY; without even the implied warranty of  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  * GNU General Public License for more details.  *  * You should have received a copy of the GNU General Public License  * along with GAWK; see the file COPYING.  If not, write to  * the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_comment
comment|/*  * vms_gawk.c - routines to parse the command line as a native DCL command  *	       rather than as a foreign command string.  *							Pat Rankin, Nov'89  *						[ revised for 2.12, May'91 ]  */
end_comment

begin_include
include|#
directive|include
file|"awk.h"
end_include

begin_include
include|#
directive|include
file|"vms.h"
end_include

begin_define
define|#
directive|define
name|COMMAND_NAME
value|"GAWK"
end_define

begin_comment
comment|/* verb name& for 'usage' message(s) */
end_comment

begin_define
define|#
directive|define
name|USAGE_PROG_RQRD
value|1
end_define

begin_define
define|#
directive|define
name|USAGE_FILE_RQRD
value|2
end_define

begin_define
define|#
directive|define
name|USAGE_BAD_COMBO
value|3
end_define

begin_define
define|#
directive|define
name|USAGE_RUN_CMD
value|4
end_define

begin_define
define|#
directive|define
name|STS$M_INHIB_MSG
value|0x10000000
end_define

begin_define
define|#
directive|define
name|Present
parameter_list|(
name|arg
parameter_list|)
value|vmswork(Cli_Present(arg))
end_define

begin_define
define|#
directive|define
name|Get_Value
parameter_list|(
name|arg
parameter_list|,
name|buf
parameter_list|,
name|siz
parameter_list|)
value|vmswork(Cli_Get_Value(arg,buf,siz))
end_define

begin_function_decl
specifier|extern
name|void
name|gawk_cmd
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* created with $ SET COMMAND/OBJECT */
end_comment

begin_define
define|#
directive|define
name|GAWK_CMD
value|((const void *)gawk_cmd)
end_define

begin_function_decl
specifier|extern
name|void
name|_exit
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|vms_usage
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|ARG_SIZ
value|250
end_define

begin_union
union|union
name|arg_w_prefix
block|{
comment|/* structure used to simplify prepending of "-" */
name|char
name|value
index|[
literal|3
operator|+
name|ARG_SIZ
operator|+
literal|1
index|]
decl_stmt|;
struct|struct
block|{
name|char
name|prefix
index|[
literal|3
index|]
decl_stmt|;
comment|/* for "-? " */
name|char
name|buf
index|[
name|ARG_SIZ
index|]
decl_stmt|;
name|char
name|suffix
index|[
literal|1
index|]
decl_stmt|;
comment|/* room for '\0' */
block|}
name|arg
struct|;
block|}
union|;
end_union

begin_define
define|#
directive|define
name|chk_option
parameter_list|(
name|qualifier
parameter_list|,
name|optname
parameter_list|)
define|\
value|if (Present(qualifier))	\ 	strcat(strcat(buf.arg.buf, W_cnt++ ? "," : ""), optname)
end_define

begin_comment
comment|/* vms_gawk() - parse GAWK command line using DCL and convert it into the */
end_comment

begin_comment
comment|/*	       appropriate "-arg" values for compatability with GNU code  */
end_comment

begin_function
name|int
name|vms_gawk
parameter_list|()
block|{
name|u_long
name|sts
decl_stmt|;
name|union
name|arg_w_prefix
name|buf
decl_stmt|;
name|char
name|misc_args
index|[
literal|10
index|]
decl_stmt|,
modifier|*
name|misc_argp
decl_stmt|;
name|int
name|argc
decl_stmt|,
name|W_cnt
decl_stmt|;
comment|/* check "GAWK_P1"--it's required; its presence will tip us off */
name|sts
operator|=
name|Cli_Present
argument_list|(
literal|"GAWK_P1"
argument_list|)
expr_stmt|;
if|if
condition|(
name|CondVal
argument_list|(
name|sts
argument_list|)
operator|==
name|CondVal
argument_list|(
name|CLI$_SYNTAX
argument_list|)
condition|)
block|{
comment|/* syntax error indicates that we weren't invoked as a native DCL 	   command, so we'll now attempt to generate a command from the 	   foreign command string and parse that. 	*/
name|sts
operator|=
name|Cli_Parse_Command
argument_list|(
name|GAWK_CMD
argument_list|,
name|COMMAND_NAME
argument_list|)
expr_stmt|;
if|if
condition|(
name|vmswork
argument_list|(
name|sts
argument_list|)
condition|)
name|sts
operator|=
name|Cli_Present
argument_list|(
literal|"GAWK_P1"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|vmswork
argument_list|(
name|sts
argument_list|)
condition|)
comment|/* command parsed successfully */
name|v_add_arg
argument_list|(
name|argc
operator|=
literal|0
argument_list|,
name|COMMAND_NAME
argument_list|)
expr_stmt|;
comment|/* save "GAWK" as argv[0] */
elseif|else
if|if
condition|(
name|CondVal
argument_list|(
name|sts
argument_list|)
operator|==
name|CondVal
argument_list|(
name|CLI$_INSFPRM
argument_list|)
condition|)
return|return
name|vms_usage
argument_list|(
name|USAGE_FILE_RQRD
argument_list|)
return|;
comment|/* insufficient parameters */
elseif|else
if|if
condition|(
name|CondVal
argument_list|(
name|sts
argument_list|)
operator|==
name|CondVal
argument_list|(
name|CLI$_CONFLICT
argument_list|)
condition|)
return|return
name|vms_usage
argument_list|(
name|USAGE_BAD_COMBO
argument_list|)
return|;
comment|/* conflicting qualifiers (/input+/command) */
elseif|else
if|if
condition|(
name|CondVal
argument_list|(
name|sts
argument_list|)
operator|==
name|CondVal
argument_list|(
name|CLI$_RUNUSED
argument_list|)
condition|)
return|return
name|vms_usage
argument_list|(
name|USAGE_RUN_CMD
argument_list|)
return|;
comment|/* RUN GAWK won't work (no command line) */
else|else
return|return
literal|0
return|;
comment|/* forced to rely on original parsing */
if|if
condition|(
name|Present
argument_list|(
literal|"USAGE"
argument_list|)
condition|)
comment|/* give usage message and quit */
return|return
name|vms_usage
argument_list|(
literal|0
argument_list|)
return|;
elseif|else
if|if
condition|(
operator|!
operator|(
name|Present
argument_list|(
literal|"PROGRAM"
argument_list|)
operator|||
name|Present
argument_list|(
literal|"PROGFILE"
argument_list|)
operator|)
condition|)
return|return
name|vms_usage
argument_list|(
name|USAGE_PROG_RQRD
argument_list|)
return|;
comment|/* missing required option */
name|misc_argp
operator|=
name|misc_args
expr_stmt|;
operator|*
name|misc_argp
operator|++
operator|=
literal|'-'
expr_stmt|;
comment|/* now points at&misc_args[1] */
if|if
condition|(
name|Present
argument_list|(
literal|"REG_EXPR"
argument_list|)
condition|)
block|{
if|if
condition|(
name|Present
argument_list|(
literal|"REG_EXPR.AWK"
argument_list|)
condition|)
comment|/* /reg_exp=awk -> -a */
operator|*
name|misc_argp
operator|++
operator|=
literal|'a'
expr_stmt|;
elseif|else
if|if
condition|(
name|Present
argument_list|(
literal|"REG_EXPR.EGREP"
argument_list|)
comment|/* /reg_exp=egrep -> -e */
operator|||
name|Present
argument_list|(
literal|"REG_EXPR.POSIX"
argument_list|)
condition|)
comment|/* /reg_exp=posix -> -e */
operator|*
name|misc_argp
operator|++
operator|=
literal|'e'
expr_stmt|;
block|}
if|#
directive|if
literal|0
comment|/* gawk 2.11.1 */
block|if (Present("STRICT"))
comment|/* /strict -> -c */
block|*misc_argp++ = 'c';     if (Present("COPYRIGHT"))
comment|/* /copyright -> -C */
block|*misc_argp++ = 'C';     if (Present("VERSION"))
comment|/* /version -> -V */
block|*misc_argp++ = 'V';
else|#
directive|else
comment|/* gawk 2.12 */
name|W_cnt
operator|=
literal|0
operator|,
name|buf
operator|.
name|arg
operator|.
name|buf
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|strncpy
argument_list|(
name|buf
operator|.
name|arg
operator|.
name|prefix
argument_list|,
literal|"-W "
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|chk_option
argument_list|(
literal|"LINT"
argument_list|,
literal|"lint"
argument_list|)
expr_stmt|;
name|chk_option
argument_list|(
literal|"POSIX"
argument_list|,
literal|"posix"
argument_list|)
expr_stmt|;
name|chk_option
argument_list|(
literal|"STRICT"
argument_list|,
literal|"compat"
argument_list|)
expr_stmt|;
name|chk_option
argument_list|(
literal|"COPYRIGHT"
argument_list|,
literal|"copyright"
argument_list|)
expr_stmt|;
name|chk_option
argument_list|(
literal|"VERSION"
argument_list|,
literal|"version"
argument_list|)
expr_stmt|;
if|if
condition|(
name|W_cnt
operator|>
literal|0
condition|)
comment|/* got something */
name|v_add_arg
argument_list|(
operator|++
name|argc
argument_list|,
name|strdup
argument_list|(
name|buf
operator|.
name|value
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*0*/
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|Present
argument_list|(
literal|"DEBUG"
argument_list|)
condition|)
block|{
if|#
directive|if
literal|0
block|int both = Present("DEBUG.ALL"); 	if (both || Present("DEBUG.EXECUTION")) 	    *misc_argp++ = 'd'; 	if (both || Present("DEBUG.PARSE"))
endif|#
directive|endif
operator|*
name|misc_argp
operator|++
operator|=
literal|'D'
expr_stmt|;
block|}
endif|#
directive|endif
operator|*
name|misc_argp
operator|=
literal|'\0'
expr_stmt|;
comment|/* terminate misc_args[] */
if|if
condition|(
name|misc_argp
operator|>
operator|&
name|misc_args
index|[
literal|1
index|]
condition|)
comment|/* got something */
name|v_add_arg
argument_list|(
operator|++
name|argc
argument_list|,
name|misc_args
argument_list|)
expr_stmt|;
comment|/* store it/them */
if|if
condition|(
name|Present
argument_list|(
literal|"FIELD_SEP"
argument_list|)
condition|)
block|{
comment|/* field separator */
name|strncpy
argument_list|(
name|buf
operator|.
name|arg
operator|.
name|prefix
argument_list|,
literal|"-F "
argument_list|,
literal|3
argument_list|)
expr_stmt|;
if|if
condition|(
name|Get_Value
argument_list|(
literal|"FIELD_SEP"
argument_list|,
name|buf
operator|.
name|arg
operator|.
name|buf
argument_list|,
sizeof|sizeof
name|buf
operator|.
name|arg
operator|.
name|buf
argument_list|)
condition|)
name|v_add_arg
argument_list|(
operator|++
name|argc
argument_list|,
name|strdup
argument_list|(
name|buf
operator|.
name|value
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|Present
argument_list|(
literal|"VARIABLES"
argument_list|)
condition|)
block|{
comment|/* variables to init prior to BEGIN */
name|strncpy
argument_list|(
name|buf
operator|.
name|arg
operator|.
name|prefix
argument_list|,
literal|"-v "
argument_list|,
literal|3
argument_list|)
expr_stmt|;
while|while
condition|(
name|Get_Value
argument_list|(
literal|"VARIABLES"
argument_list|,
name|buf
operator|.
name|arg
operator|.
name|buf
argument_list|,
sizeof|sizeof
name|buf
operator|.
name|arg
operator|.
name|buf
argument_list|)
condition|)
name|v_add_arg
argument_list|(
operator|++
name|argc
argument_list|,
name|strdup
argument_list|(
name|buf
operator|.
name|value
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|Present
argument_list|(
literal|"PROGFILE"
argument_list|)
condition|)
block|{
comment|/* program files, /input=file -> -f file */
name|strncpy
argument_list|(
name|buf
operator|.
name|arg
operator|.
name|prefix
argument_list|,
literal|"-f "
argument_list|,
literal|3
argument_list|)
expr_stmt|;
while|while
condition|(
name|Get_Value
argument_list|(
literal|"PROGFILE"
argument_list|,
name|buf
operator|.
name|arg
operator|.
name|buf
argument_list|,
sizeof|sizeof
name|buf
operator|.
name|arg
operator|.
name|buf
argument_list|)
condition|)
name|v_add_arg
argument_list|(
operator|++
name|argc
argument_list|,
name|strdup
argument_list|(
name|buf
operator|.
name|value
argument_list|)
argument_list|)
expr_stmt|;
name|v_add_arg
argument_list|(
operator|++
name|argc
argument_list|,
literal|"--"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|Present
argument_list|(
literal|"PROGRAM"
argument_list|)
condition|)
block|{
comment|/* program text, /program -> 'text' */
name|v_add_arg
argument_list|(
operator|++
name|argc
argument_list|,
literal|"--"
argument_list|)
expr_stmt|;
if|if
condition|(
name|Get_Value
argument_list|(
literal|"PROGRAM"
argument_list|,
name|buf
operator|.
name|value
argument_list|,
sizeof|sizeof
name|buf
operator|.
name|value
argument_list|)
condition|)
name|v_add_arg
argument_list|(
operator|++
name|argc
argument_list|,
name|strdup
argument_list|(
name|buf
operator|.
name|value
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* we know that "GAWK_P1" is present [data files and/or 'var=value'] */
while|while
condition|(
name|Get_Value
argument_list|(
literal|"GAWK_P1"
argument_list|,
name|buf
operator|.
name|value
argument_list|,
sizeof|sizeof
name|buf
operator|.
name|value
argument_list|)
condition|)
name|v_add_arg
argument_list|(
operator|++
name|argc
argument_list|,
name|strdup
argument_list|(
name|buf
operator|.
name|value
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|Present
argument_list|(
literal|"OUTPUT"
argument_list|)
condition|)
block|{
comment|/* let other parser treat this as 'stdout' */
name|strncpy
argument_list|(
name|buf
operator|.
name|arg
operator|.
name|prefix
argument_list|,
literal|">$ "
argument_list|,
literal|3
argument_list|)
expr_stmt|;
if|if
condition|(
name|Get_Value
argument_list|(
literal|"OUTPUT"
argument_list|,
name|buf
operator|.
name|arg
operator|.
name|buf
argument_list|,
sizeof|sizeof
name|buf
operator|.
name|arg
operator|.
name|buf
argument_list|)
condition|)
name|v_add_arg
argument_list|(
operator|++
name|argc
argument_list|,
name|strdup
argument_list|(
name|buf
operator|.
name|value
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|++
name|argc
return|;
comment|/*(increment to account for arg[0])*/
block|}
end_function

begin_comment
comment|/* vms_usage() - display one or more messages and then terminate */
end_comment

begin_function
specifier|static
name|int
comment|/* note: doesn't return anything; allows 'return vms_usage()' */
name|vms_usage
parameter_list|(
name|int
name|complaint
parameter_list|)
block|{
specifier|static
name|char
modifier|*
name|usage_txt
init|=
literal|"\n\ usage:	%s  /COMMANDS=\"awk program text\"  data_file[,data_file,...] \n\    or	%s  /INPUT=awk_file  data_file[,\"Var=value\",data_file,...] \n\    or	%s  /INPUT=(awk_file1,awk_file2,...)  data_file[,...] \n\ "
decl_stmt|,
modifier|*
name|options_txt
init|=
literal|"\n\ options:  /FIELD_SEPARATOR=\"FS_value\" \n\    -	  /VARIABLES=(\"Var1=value1\",\"Var2=value2\",...) \n\    -	  /REG_EXPR= AWK or EGREP or POSIX \n\    -	  /LINT  /POSIX  /[NO]STRICT  /VERSION	/COPYRIGHT  /USAGE \n\    -	  /OUTPUT=out_file \n\ "
decl_stmt|,
modifier|*
name|no_prog
init|=
literal|"missing required element: /COMMANDS or /INPUT"
decl_stmt|,
modifier|*
name|no_file
init|=
literal|"missing required element: data_file \n\        (use \"SYS$INPUT:\" to read data lines from the terminal)"
decl_stmt|,
modifier|*
name|bad_combo
init|=
literal|"invalid combination of qualifiers \n\        (/INPUT=awk_file and /COMMANDS=\"awk program\" are mutually exclusive)"
decl_stmt|,
modifier|*
name|run_used
init|=
literal|"\"RUN\" was used; required command components missing"
decl_stmt|;
name|int
name|status
decl_stmt|,
name|argc
decl_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|complaint
condition|)
block|{
case|case
name|USAGE_PROG_RQRD
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n%%%s-W-%s, %s \n"
argument_list|,
name|COMMAND_NAME
argument_list|,
literal|"PROG_RQRD"
argument_list|,
name|no_prog
argument_list|)
expr_stmt|;
name|status
operator|=
name|CLI$_VALREQ
operator||
name|STS$M_INHIB_MSG
expr_stmt|;
break|break;
case|case
name|USAGE_FILE_RQRD
case|:
if|if
condition|(
name|Present
argument_list|(
literal|"USAGE"
argument_list|)
condition|)
block|{
name|status
operator|=
literal|1
expr_stmt|;
comment|/* clean exit */
block|}
elseif|else
if|if
condition|(
name|Present
argument_list|(
literal|"COPYRIGHT"
argument_list|)
operator|||
name|Present
argument_list|(
literal|"VERSION"
argument_list|)
condition|)
block|{
name|v_add_arg
argument_list|(
name|argc
operator|=
literal|0
argument_list|,
name|COMMAND_NAME
argument_list|)
expr_stmt|;
comment|/* save "GAWK" as argv[0] */
if|#
directive|if
literal|0
block|v_add_arg(++argc, Present("COPYRIGHT") ? "-C" : "-V");
else|#
directive|else
name|v_add_arg
argument_list|(
operator|++
name|argc
argument_list|,
literal|"-W"
argument_list|)
expr_stmt|;
name|v_add_arg
argument_list|(
operator|++
name|argc
argument_list|,
name|Present
argument_list|(
literal|"COPYRIGHT"
argument_list|)
condition|?
literal|"copyright"
else|:
literal|"version"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|v_add_arg
argument_list|(
operator|++
name|argc
argument_list|,
literal|"{}"
argument_list|)
expr_stmt|;
comment|/* kludge to suppress 'usage' */
name|v_add_arg
argument_list|(
operator|++
name|argc
argument_list|,
literal|"NL:"
argument_list|)
expr_stmt|;
comment|/* dummy input for kludge */
return|return
operator|++
name|argc
return|;
comment|/* count argv[0] too */
block|}
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n%%%s-W-%s, %s \n"
argument_list|,
name|COMMAND_NAME
argument_list|,
literal|"FILE_RQRD"
argument_list|,
name|no_file
argument_list|)
expr_stmt|;
name|status
operator|=
name|CLI$_INSFPRM
operator||
name|STS$M_INHIB_MSG
expr_stmt|;
block|}
break|break;
case|case
name|USAGE_BAD_COMBO
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n%%%s-W-%s, %s \n"
argument_list|,
name|COMMAND_NAME
argument_list|,
literal|"BAD_COMBO"
argument_list|,
name|bad_combo
argument_list|)
expr_stmt|;
name|status
operator|=
name|CLI$_CONFLICT
operator||
name|STS$M_INHIB_MSG
expr_stmt|;
break|break;
case|case
name|USAGE_RUN_CMD
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n%%%s-W-%s, %s \n"
argument_list|,
name|COMMAND_NAME
argument_list|,
literal|"RUN_CMD"
argument_list|,
name|run_used
argument_list|)
expr_stmt|;
name|status
operator|=
name|CLI$_NOOPTPRS
operator||
name|STS$M_INHIB_MSG
expr_stmt|;
break|break;
default|default:
name|status
operator|=
literal|1
expr_stmt|;
break|break;
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|usage_txt
argument_list|,
name|COMMAND_NAME
argument_list|,
name|COMMAND_NAME
argument_list|,
name|COMMAND_NAME
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|options_txt
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
name|errno
operator|=
name|EVMSERR
expr_stmt|;
name|vaxc$errno
operator|=
name|status
expr_stmt|;
name|_exit
argument_list|(
name|status
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
return|return
literal|0
return|;
block|}
end_function

end_unit

