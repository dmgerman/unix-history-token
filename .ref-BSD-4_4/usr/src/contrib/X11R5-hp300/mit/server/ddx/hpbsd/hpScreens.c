begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  Copyright (c) 1986, 1987 by Hewlett-Packard Company Copyright (c) 1986, 1987 by the Massachusetts Institute of Technology  Permission to use, copy, modify, and distribute this software and its documentation for any purpose and without fee is hereby granted, provided that the above copyright notice appear in all copies and that both that copyright notice and this permission notice appear in supporting documentation, and that the name of M.I.T. not be used in advertising or publicity pertaining to distribution of the software without specific, written prior permission.  HEWLETT-PACKARD MAKES NO WARRANTY OF ANY KIND WITH REGARD TO THIS SOFWARE, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR  PURPOSE.  Hewlett-Packard shall not be liable for errors  contained herein or direct, indirect, special, incidental or  consequential damages in connection with the furnishing,  performance, or use of this material.  This software is not subject to any license of the American Telephone and Telegraph Company or of the Regents of the University of California. */
end_comment

begin_include
include|#
directive|include
file|"X.h"
end_include

begin_define
define|#
directive|define
name|NEED_EVENTS
end_define

begin_include
include|#
directive|include
file|"Xproto.h"
end_include

begin_include
include|#
directive|include
file|"scrnintstr.h"
end_include

begin_include
include|#
directive|include
file|"pixmapstr.h"
end_include

begin_include
include|#
directive|include
file|"inputstr.h"
end_include

begin_include
include|#
directive|include
file|"regionstr.h"
end_include

begin_include
include|#
directive|include
file|"windowstr.h"
end_include

begin_include
include|#
directive|include
file|"hppriv.h"
end_include

begin_include
include|#
directive|include
file|"mi.h"
end_include

begin_include
include|#
directive|include
file|"hpBlock.h"
end_include

begin_comment
comment|/*   maintain a local pointer to the screen->devPrivate structure. When the   server restarts, this will be used to restore the screen pointer lost   when the screen structure is reallocated. */
end_comment

begin_decl_stmt
name|hpPrivScreenPtr
name|hp_screens
index|[
name|MAXSCREENS
index|]
init|=
block|{
operator|(
name|hpPrivScreenPtr
operator|)
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|WindowRec
name|WindowTable
index|[]
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|BlankScreen
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|UnblankScreen
parameter_list|()
function_decl|;
end_function_decl

begin_function
name|void
name|hpDoNothing
parameter_list|()
block|{  }
end_function

begin_comment
comment|/* one of the more exciting routines */
end_comment

begin_function
name|void
name|hpPlaceCursorInScreen
parameter_list|(
name|pScreen
parameter_list|,
name|x
parameter_list|,
name|y
parameter_list|)
name|ScreenPtr
name|pScreen
decl_stmt|;
name|int
name|x
decl_stmt|,
name|y
decl_stmt|;
block|{
specifier|register
name|WindowPtr
name|pOuterWin
decl_stmt|,
name|pInnerWin
decl_stmt|;
name|CursorPtr
name|pCurs
decl_stmt|;
name|pOuterWin
operator|=
operator|&
name|WindowTable
index|[
name|pScreen
operator|->
name|myNum
index|]
expr_stmt|;
comment|/* get root window for screen */
name|pInnerWin
operator|=
name|pOuterWin
operator|->
name|firstChild
expr_stmt|;
comment|/* check top windows for containment */
name|pCurs
operator|=
name|wCursor
argument_list|(
name|pOuterWin
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|NOT_DONE_YET
while|while
condition|(
name|pInnerWin
condition|)
block|{
if|if
condition|(
operator|(
name|pInnerWin
operator|->
name|mapped
operator|)
operator|&&
operator|(
name|x
operator|>=
name|pInnerWin
operator|->
name|drawable
operator|.
name|x
operator|-
name|pInnerWin
operator|->
name|borderWidth
operator|)
operator|&&
operator|(
name|x
operator|<
name|pInnerWin
operator|->
name|drawable
operator|.
name|x
operator|+
operator|(
name|int
operator|)
name|pInnerWin
operator|->
name|clientWinSize
operator|.
name|width
operator|+
name|pInnerWin
operator|->
name|borderWidth
operator|)
operator|&&
operator|(
name|y
operator|>=
name|pInnerWin
operator|->
name|drawable
operator|.
name|y
operator|-
name|pInnerWin
operator|->
name|borderWidth
operator|)
operator|&&
operator|(
name|y
operator|<
name|pInnerWin
operator|->
name|drawable
operator|.
name|y
operator|+
operator|(
name|int
operator|)
name|pInnerWin
operator|->
name|clientWinSize
operator|.
name|height
operator|+
name|pInnerWin
operator|->
name|borderWidth
operator|)
condition|)
block|{
if|if
condition|(
name|pInnerWin
operator|->
name|cursor
condition|)
name|pCurs
operator|=
name|pInnerWin
operator|->
name|cursor
expr_stmt|;
name|pOuterWin
operator|=
name|pInnerWin
expr_stmt|;
comment|/* sprite is contained here */
name|pInnerWin
operator|=
name|pOuterWin
operator|->
name|firstChild
expr_stmt|;
comment|/* any sub-windows? */
block|}
else|else
name|pInnerWin
operator|=
name|pInnerWin
operator|->
name|nextSib
expr_stmt|;
comment|/* not in here, continue */
block|}
endif|#
directive|endif
name|pScreen
operator|->
name|DisplayCursor
argument_list|(
name|pScreen
argument_list|,
name|pCurs
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|hpChangeScreens
parameter_list|(
name|pNewScreen
parameter_list|)
specifier|register
name|ScreenPtr
name|pNewScreen
decl_stmt|;
comment|/* screen being entered */
block|{
specifier|register
name|hpPrivScreenPtr
name|pNewPrivScreen
decl_stmt|,
name|pPrivScreen
decl_stmt|;
specifier|register
name|ScreenPtr
name|pScreen
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|pNewPrivScreen
operator|=
name|getPrivScreenPtr
argument_list|(
name|pNewScreen
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|screenInfo
operator|.
name|numScreens
condition|;
name|i
operator|++
control|)
block|{
name|pScreen
operator|=
name|screenInfo
operator|.
name|screens
index|[
name|i
index|]
expr_stmt|;
name|pPrivScreen
operator|=
name|getPrivScreenPtr
argument_list|(
name|pScreen
argument_list|)
expr_stmt|;
if|if
condition|(
name|pPrivScreen
operator|->
name|CursorOff
operator|==
name|hpDoNothing
condition|)
block|{
operator|(
call|(
name|HpRegisterStatePtr
call|)
argument_list|(
name|pScreen
operator|->
name|blockData
argument_list|)
operator|)
operator|->
name|cursorOff
argument_list|(
name|pScreen
argument_list|)
expr_stmt|;
operator|(
call|(
name|HpRegisterStatePtr
call|)
argument_list|(
name|pScreen
operator|->
name|wakeupData
argument_list|)
operator|)
operator|->
name|save
argument_list|(
name|pScreen
argument_list|,
name|pScreen
operator|->
name|wakeupData
argument_list|)
expr_stmt|;
operator|(
call|(
name|HpRegisterStatePtr
call|)
argument_list|(
name|pScreen
operator|->
name|blockData
argument_list|)
operator|)
operator|->
name|save
argument_list|(
name|pScreen
argument_list|,
name|pScreen
operator|->
name|blockData
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pScreen
operator|==
name|pNewScreen
condition|)
name|UnblankScreen
argument_list|(
name|pScreen
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|pPrivScreen
operator|->
name|gcid
operator|==
name|pNewPrivScreen
operator|->
name|gcid
operator|)
operator|&&
operator|(
name|pPrivScreen
operator|->
name|minor_num
operator|==
name|pNewPrivScreen
operator|->
name|minor_num
operator|)
condition|)
name|BlankScreen
argument_list|(
name|pScreen
argument_list|)
expr_stmt|;
comment|/* overlay ? clear : black */
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|BlankScreen
parameter_list|(
name|pScreen
parameter_list|)
name|ScreenPtr
name|pScreen
decl_stmt|;
block|{
name|hpPrivScreenPtr
name|pPrivScreen
init|=
name|getPrivScreenPtr
argument_list|(
name|pScreen
argument_list|)
decl_stmt|;
if|if
condition|(
name|pPrivScreen
operator|->
name|isBlank
condition|)
return|return;
if|if
condition|(
operator|!
name|pPrivScreen
operator|->
name|isSaved
condition|)
block|{
name|pScreen
operator|->
name|SaveScreen
argument_list|(
name|pScreen
argument_list|,
name|SCREEN_SAVER_ON
argument_list|)
expr_stmt|;
name|pPrivScreen
operator|->
name|isSaved
operator|=
name|FALSE
expr_stmt|;
comment|/* this didn't change */
block|}
name|pPrivScreen
operator|->
name|isBlank
operator|=
name|TRUE
expr_stmt|;
comment|/* but this did	   */
comment|/* if we get to here, we must be running with two heads (or we would        never ask to be blanked, and would never have called this) */
operator|(
call|(
name|HpRegisterStatePtr
call|)
argument_list|(
name|pScreen
operator|->
name|wakeupData
argument_list|)
operator|)
operator|->
name|save
argument_list|(
name|pScreen
argument_list|,
name|pScreen
operator|->
name|wakeupData
argument_list|)
expr_stmt|;
operator|(
call|(
name|HpRegisterStatePtr
call|)
argument_list|(
name|pScreen
operator|->
name|blockData
argument_list|)
operator|)
operator|->
name|save
argument_list|(
name|pScreen
argument_list|,
name|pScreen
operator|->
name|blockData
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|UnblankScreen
parameter_list|(
name|pScreen
parameter_list|)
name|ScreenPtr
name|pScreen
decl_stmt|;
block|{
name|hpPrivScreenPtr
name|pPrivScreen
init|=
name|getPrivScreenPtr
argument_list|(
name|pScreen
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|pPrivScreen
operator|->
name|isBlank
condition|)
return|return;
name|pPrivScreen
operator|->
name|isBlank
operator|=
name|FALSE
expr_stmt|;
comment|/* this will be true either way */
if|if
condition|(
operator|!
name|pPrivScreen
operator|->
name|isSaved
condition|)
comment|/* must have been blanked only  */
name|pScreen
operator|->
name|SaveScreen
argument_list|(
name|pScreen
argument_list|,
name|SCREEN_SAVER_OFF
argument_list|)
expr_stmt|;
comment|/* if we get to here, we must be running with two heads (or we would        never have been blanked, and so have taken the early return) */
operator|(
call|(
name|HpRegisterStatePtr
call|)
argument_list|(
name|pScreen
operator|->
name|wakeupData
argument_list|)
operator|)
operator|->
name|save
argument_list|(
name|pScreen
argument_list|,
name|pScreen
operator|->
name|wakeupData
argument_list|)
expr_stmt|;
operator|(
call|(
name|HpRegisterStatePtr
call|)
argument_list|(
name|pScreen
operator|->
name|blockData
argument_list|)
operator|)
operator|->
name|save
argument_list|(
name|pScreen
argument_list|,
name|pScreen
operator|->
name|blockData
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

