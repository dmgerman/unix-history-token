begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  Copyright (c) 1986, 1987 by Hewlett-Packard Company Copyright (c) 1986, 1987 by the Massachusetts Institute of Technology  Permission to use, copy, modify, and distribute this software and its documentation for any purpose and without fee is hereby granted, provided that the above copyright notice appear in all copies and that both that copyright notice and this permission notice appear in supporting documentation, and that the name of M.I.T. not be used in advertising or publicity pertaining to distribution of the software without specific, written prior permission.  HEWLETT-PACKARD MAKES NO WARRANTY OF ANY KIND WITH REGARD TO THIS SOFWARE, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR  PURPOSE.  Hewlett-Packard shall not be liable for errors  contained herein or direct, indirect, special, incidental or  consequential damages in connection with the furnishing,  performance, or use of this material.  This software is not subject to any license of the American Telephone and Telegraph Company or of the Regents of the University of California.  */
end_comment

begin_comment
comment|/***********************************************************************  *  file: hpByteBlt.c  *  *  Byte-Per-Pixel 68000 (and hopefully Spectrum) bit/byte order  *  image transfer routines. Specifically:  *	hpGetByteImage  *  *		Hewlett Packard -- Corvallis Workstation Operation  *		Project -- port of X11 to HP9000  *		Harry Phinney -- MTS  *  *  */
end_comment

begin_include
include|#
directive|include
file|"X.h"
end_include

begin_include
include|#
directive|include
file|"Xprotostr.h"
end_include

begin_include
include|#
directive|include
file|"cfb.h"
end_include

begin_include
include|#
directive|include
file|"gcstruct.h"
end_include

begin_include
include|#
directive|include
file|"pixmapstr.h"
end_include

begin_include
include|#
directive|include
file|"windowstr.h"
end_include

begin_include
include|#
directive|include
file|"scrnintstr.h"
end_include

begin_include
include|#
directive|include
file|"mi.h"
end_include

begin_include
include|#
directive|include
file|"regionstr.h"
end_include

begin_include
include|#
directive|include
file|"Xmd.h"
end_include

begin_include
include|#
directive|include
file|"servermd.h"
end_include

begin_decl_stmt
specifier|static
name|unsigned
name|char
name|masks
index|[
literal|8
index|]
init|=
block|{
literal|0x1
block|,
literal|0x2
block|,
literal|0x4
block|,
literal|0x8
block|,
literal|0x10
block|,
literal|0x20
block|,
literal|0x40
block|,
literal|0x80
block|}
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static unsigned char trailMasks[8] = { 0x80, 0x40, 0x20, 0x10, 0x8, 0x4, 				       0x2, 0x1 };  static unsigned long bmap[32] = { 	0x00000001, 0x00000002, 0x00000004, 0x00000008, 	0x00000010, 0x00000020, 0x00000040, 0x00000080, 	0x00000100, 0x00000200, 0x00000400, 0x00000800, 	0x00001000, 0x00002000, 0x00004000, 0x00008000, 	0x00010000, 0x00020000, 0x00040000, 0x00080000, 	0x00100000, 0x00200000, 0x00400000, 0x00800000, 	0x01000000, 0x02000000, 0x04000000, 0x08000000, 	0x10000000, 0x20000000, 0x40000000, 0x80000000 };
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|unsigned
name|long
name|rbmap
index|[
literal|32
index|]
init|=
block|{
literal|0x80000000
block|,
literal|0x40000000
block|,
literal|0x20000000
block|,
literal|0x10000000
block|,
literal|0x08000000
block|,
literal|0x04000000
block|,
literal|0x02000000
block|,
literal|0x01000000
block|,
literal|0x00800000
block|,
literal|0x00400000
block|,
literal|0x00200000
block|,
literal|0x00100000
block|,
literal|0x00080000
block|,
literal|0x00040000
block|,
literal|0x00020000
block|,
literal|0x00010000
block|,
literal|0x00008000
block|,
literal|0x00004000
block|,
literal|0x00002000
block|,
literal|0x00001000
block|,
literal|0x00000800
block|,
literal|0x00000400
block|,
literal|0x00000200
block|,
literal|0x00000100
block|,
literal|0x00000080
block|,
literal|0x00000040
block|,
literal|0x00000020
block|,
literal|0x00000010
block|,
literal|0x00000008
block|,
literal|0x00000004
block|,
literal|0x00000002
block|,
literal|0x00000001
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* hpGetPlane -- gets a bitmap representing one plane of pDraw  * A helper used for XY format GetImage   * No clever strategy here, we grab a scanline at a time, pull out the  * bits and then stuff them in a 1 bit deep map.  * This is a significantly modified version of miGetPlane.  The arguments  * are different, as here we pass in the start address within the source   * pixmap, instead of the sx and sy within the pixmap, and we pass in the  * stride that will get us to the next line - either the pixmap width or  * the screen width depending on whether the pixmap is in framebuffer or  * main memory.  */
end_comment

begin_function
name|unsigned
name|long
modifier|*
name|hpGetPlane
parameter_list|(
name|pDraw
parameter_list|,
name|planeNum
parameter_list|,
name|startAddr
parameter_list|,
name|w
parameter_list|,
name|h
parameter_list|,
name|stride
parameter_list|,
name|result
parameter_list|)
name|DrawablePtr
name|pDraw
decl_stmt|;
name|int
name|planeNum
decl_stmt|;
comment|/* number of the bitPlane */
name|unsigned
name|char
modifier|*
name|startAddr
decl_stmt|;
name|int
name|w
decl_stmt|,
name|h
decl_stmt|;
name|int
name|stride
decl_stmt|;
comment|/* stride to get to next line */
name|unsigned
name|long
modifier|*
name|result
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|int
name|k
decl_stmt|,
name|widthInBytes
decl_stmt|;
specifier|register
name|CARD32
name|bits
decl_stmt|;
name|CARD8
modifier|*
name|pCharsOut
decl_stmt|;
specifier|register
name|unsigned
name|char
modifier|*
name|pixAddr
decl_stmt|;
specifier|register
name|unsigned
name|char
name|pixel
decl_stmt|;
if|if
condition|(
name|pDraw
operator|->
name|depth
operator|!=
literal|8
condition|)
name|FatalError
argument_list|(
literal|"hpGetPlane: invalid depth\n"
argument_list|)
expr_stmt|;
name|widthInBytes
operator|=
name|PixmapBytePad
argument_list|(
name|w
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|result
condition|)
name|result
operator|=
operator|(
name|unsigned
name|long
operator|*
operator|)
name|xalloc
argument_list|(
name|h
operator|*
name|widthInBytes
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|h
condition|;
name|i
operator|++
control|)
block|{
name|pCharsOut
operator|=
operator|(
operator|(
name|unsigned
name|char
operator|*
operator|)
name|result
operator|)
operator|+
name|i
operator|*
name|widthInBytes
expr_stmt|;
name|pixAddr
operator|=
name|startAddr
operator|+
name|i
operator|*
operator|(
name|stride
operator|)
expr_stmt|;
name|k
operator|=
literal|0
expr_stmt|;
name|bits
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|w
condition|;
name|j
operator|++
control|)
block|{
name|pixel
operator|=
operator|*
name|pixAddr
operator|++
expr_stmt|;
if|if
condition|(
name|BITMAP_BIT_ORDER
operator|==
name|LSBFirst
condition|)
name|bits
operator|=
operator|(
name|bits
operator|<<
literal|1
operator|)
operator||
operator|(
operator|(
name|pixel
operator|>>
name|planeNum
operator|)
operator|&
literal|1
operator|)
expr_stmt|;
else|else
block|{
ifdef|#
directive|ifdef
name|notdef
comment|/* more portable, but slower code */
name|bits
operator||=
operator|(
operator|(
name|pixel
operator|>>
name|planeNum
operator|)
operator|&
literal|1
operator|)
operator|<<
operator|(
operator|(
name|BITMAP_SCANLINE_UNIT
operator|-
literal|1
operator|)
operator|-
name|k
operator|)
expr_stmt|;
else|#
directive|else
comment|/* faster, but less portable code */
if|if
condition|(
name|pixel
operator|&
name|masks
index|[
name|planeNum
index|]
condition|)
name|bits
operator||=
name|rbmap
index|[
name|k
index|]
expr_stmt|;
endif|#
directive|endif
block|}
name|k
operator|++
expr_stmt|;
if|if
condition|(
name|BITMAP_SCANLINE_UNIT
operator|==
name|k
condition|)
block|{
switch|switch
condition|(
name|BITMAP_SCANLINE_UNIT
condition|)
block|{
case|case
literal|8
case|:
operator|*
name|pCharsOut
operator|++
operator|=
operator|(
name|CARD8
operator|)
name|bits
expr_stmt|;
break|break;
case|case
literal|16
case|:
operator|*
operator|(
name|CARD16
operator|*
operator|)
name|pCharsOut
operator|=
operator|(
name|CARD16
operator|)
name|bits
expr_stmt|;
name|pCharsOut
operator|+=
sizeof|sizeof
argument_list|(
name|CARD16
argument_list|)
expr_stmt|;
break|break;
case|case
literal|32
case|:
operator|*
operator|(
name|CARD32
operator|*
operator|)
name|pCharsOut
operator|=
name|bits
expr_stmt|;
name|pCharsOut
operator|+=
sizeof|sizeof
argument_list|(
name|CARD32
argument_list|)
expr_stmt|;
break|break;
block|}
name|k
operator|=
name|bits
operator|=
literal|0
expr_stmt|;
block|}
block|}
define|#
directive|define
name|ORBITs
parameter_list|(
name|type
parameter_list|,
name|ptr
parameter_list|,
name|bits
parameter_list|)
value|*(type *)ptr = (type)bits
if|if
condition|(
name|k
condition|)
comment|/* trailing bits */
block|{
switch|switch
condition|(
name|BITMAP_SCANLINE_UNIT
condition|)
block|{
case|case
literal|8
case|:
name|ORBITs
argument_list|(
name|CARD8
argument_list|,
name|pCharsOut
argument_list|,
name|bits
argument_list|)
expr_stmt|;
break|break;
case|case
literal|16
case|:
name|ORBITs
argument_list|(
name|CARD16
argument_list|,
name|pCharsOut
argument_list|,
name|bits
argument_list|)
expr_stmt|;
break|break;
case|case
literal|32
case|:
name|ORBITs
argument_list|(
name|CARD32
argument_list|,
name|pCharsOut
argument_list|,
name|bits
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_comment
comment|/* hpGetByteImage -- public entry for the GetImage Request  * We're getting the image into a memory buffer.  * Since we know what an hp byte-deep framebuffer looks like, we can do  * this much faster than miGetImage.  *  * two different strategies are used, depending on whether we're getting the  * image in Z format or XY format  * Z format:  *   For each row  *	For each column  *	  Read the pixel into pdst  *   If planeMask is not all ones  (yech)  *	For each row  *	  For each column  *	    Mask the unwanted bits   *  * XY format:  *   Call hpGetBytePlane (see above in this file)  *     *  */
end_comment

begin_function
name|void
name|hpGetByteImage
parameter_list|(
name|pDraw
parameter_list|,
name|sx
parameter_list|,
name|sy
parameter_list|,
name|w
parameter_list|,
name|h
parameter_list|,
name|format
parameter_list|,
name|planeMask
parameter_list|,
name|pdstLine
parameter_list|)
name|DrawablePtr
name|pDraw
decl_stmt|;
name|int
name|sx
decl_stmt|,
name|sy
decl_stmt|,
name|w
decl_stmt|,
name|h
decl_stmt|;
name|unsigned
name|int
name|format
decl_stmt|;
name|unsigned
name|long
name|planeMask
decl_stmt|;
name|pointer
name|pdstLine
decl_stmt|;
block|{
name|int
name|depth
decl_stmt|,
name|i
decl_stmt|,
name|linelength
decl_stmt|;
name|unsigned
name|char
modifier|*
name|pSrc
decl_stmt|;
name|int
name|widthSrc
decl_stmt|;
name|unsigned
name|int
name|screenPlanes
init|=
name|getPlanesMask
argument_list|(
name|pDraw
operator|->
name|pScreen
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|w
operator|==
literal|0
operator|)
operator|||
operator|(
name|h
operator|==
literal|0
operator|)
condition|)
return|return;
name|depth
operator|=
name|pDraw
operator|->
name|depth
expr_stmt|;
switch|switch
condition|(
name|depth
condition|)
block|{
case|case
literal|1
case|:
name|mfbGetImage
argument_list|(
name|pDraw
argument_list|,
name|sx
argument_list|,
name|sy
argument_list|,
name|w
argument_list|,
name|h
argument_list|,
name|format
argument_list|,
name|planeMask
argument_list|,
name|pdstLine
argument_list|)
expr_stmt|;
return|return;
case|case
literal|8
case|:
break|break;
default|default:
name|miGetImage
argument_list|(
name|pDraw
argument_list|,
name|sx
argument_list|,
name|sy
argument_list|,
name|w
argument_list|,
name|h
argument_list|,
name|format
argument_list|,
name|planeMask
argument_list|,
name|pdstLine
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
operator|(
name|planeMask
operator|&=
name|screenPlanes
operator|)
condition|)
return|return;
name|linelength
operator|=
name|PixmapBytePad
argument_list|(
name|w
argument_list|,
name|depth
argument_list|)
expr_stmt|;
if|if
condition|(
name|pDraw
operator|->
name|type
operator|==
name|DRAWABLE_WINDOW
condition|)
block|{
name|sx
operator|+=
name|pDraw
operator|->
name|x
expr_stmt|;
name|sy
operator|+=
name|pDraw
operator|->
name|y
expr_stmt|;
name|widthSrc
operator|=
operator|(
name|int
operator|)
name|getPrivScreenPtr
argument_list|(
name|pDraw
operator|->
name|pScreen
argument_list|)
operator|->
name|stride
expr_stmt|;
name|pSrc
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|getPrivScreenPtr
argument_list|(
name|pDraw
operator|->
name|pScreen
argument_list|)
operator|->
name|bits
operator|+
name|sx
operator|+
name|sy
operator|*
name|widthSrc
expr_stmt|;
block|}
else|else
block|{
comment|/* we're getting from a pixmap */
name|hpPrivPixmapPtr
name|pPrivPix
init|=
call|(
name|hpPrivPixmapPtr
call|)
argument_list|(
operator|(
name|PixmapPtr
operator|)
name|pDraw
argument_list|)
operator|->
name|devPrivate
operator|.
name|ptr
decl_stmt|;
if|if
condition|(
operator|(
operator|(
name|PixmapPtr
operator|)
name|pDraw
operator|)
operator|->
name|devKind
operator|==
name|PIXMAP_FRAME_BUFFER
condition|)
block|{
name|sx
operator|+=
name|pPrivPix
operator|->
name|pChunk
operator|->
name|x
expr_stmt|;
name|sy
operator|+=
name|pPrivPix
operator|->
name|pChunk
operator|->
name|y
expr_stmt|;
name|widthSrc
operator|=
operator|(
name|int
operator|)
name|getPrivScreenPtr
argument_list|(
name|pDraw
operator|->
name|pScreen
argument_list|)
operator|->
name|stride
expr_stmt|;
name|pSrc
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|getPrivScreenPtr
argument_list|(
name|pDraw
operator|->
name|pScreen
argument_list|)
operator|->
name|bits
operator|+
name|sx
operator|+
name|sy
operator|*
name|widthSrc
expr_stmt|;
block|}
else|else
block|{
comment|/* main memory pixmap */
name|widthSrc
operator|=
operator|(
name|int
operator|)
name|pPrivPix
operator|->
name|stride
expr_stmt|;
name|pSrc
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|pPrivPix
operator|->
name|bits
operator|+
name|sx
operator|+
name|sy
operator|*
name|widthSrc
expr_stmt|;
block|}
block|}
if|if
condition|(
name|format
operator|==
name|ZPixmap
condition|)
block|{
name|WAIT_READY_TO_RENDER
argument_list|(
name|pDraw
operator|->
name|pScreen
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|h
condition|;
name|i
operator|++
control|)
block|{
comment|/* for each row */
specifier|register
name|int
name|j
decl_stmt|;
specifier|register
name|unsigned
name|char
modifier|*
name|pByteDst
decl_stmt|;
specifier|register
name|unsigned
name|char
modifier|*
name|pSrcByte
decl_stmt|;
name|pSrcByte
operator|=
name|pSrc
operator|+
name|i
operator|*
name|widthSrc
expr_stmt|;
name|pByteDst
operator|=
operator|(
operator|(
name|unsigned
name|char
operator|*
operator|)
name|pdstLine
operator|)
operator|+
name|i
operator|*
name|linelength
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|w
condition|;
name|j
operator|++
control|)
block|{
comment|/* for each pixel in row */
operator|*
name|pByteDst
operator|++
operator|=
operator|*
name|pSrcByte
operator|++
operator|&
name|planeMask
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|int
name|planes
init|=
name|Ones
argument_list|(
name|screenPlanes
argument_list|)
decl_stmt|;
name|int
name|planeSize
init|=
name|PixmapBytePad
argument_list|(
name|w
argument_list|,
literal|1
argument_list|)
operator|*
name|h
decl_stmt|;
for|for
control|(
name|i
operator|=
name|planes
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|planeMask
operator|&
operator|(
literal|1
operator|<<
name|i
operator|)
condition|)
block|{
operator|(
name|void
operator|)
name|hpGetPlane
argument_list|(
name|pDraw
argument_list|,
name|i
argument_list|,
name|pSrc
argument_list|,
name|w
argument_list|,
name|h
argument_list|,
name|widthSrc
argument_list|,
name|pdstLine
argument_list|)
expr_stmt|;
name|pdstLine
operator|+=
name|planeSize
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* hpPutByteImage -- public entry for the PutImage Request  *  This is here to try to make XY pixmap puts work reasonably on  *  our byte-deep framebuffers.  */
end_comment

begin_function
name|void
name|hpPutByteImage
parameter_list|(
name|pDraw
parameter_list|,
name|pGC
parameter_list|,
name|depth
parameter_list|,
name|dstx
parameter_list|,
name|dsty
parameter_list|,
name|w
parameter_list|,
name|h
parameter_list|,
name|srcOffset
parameter_list|,
name|format
parameter_list|,
name|pImage
parameter_list|)
name|DrawablePtr
name|pDraw
decl_stmt|;
name|GCPtr
name|pGC
decl_stmt|;
name|int
name|depth
decl_stmt|,
name|dstx
decl_stmt|,
name|dsty
decl_stmt|,
name|w
decl_stmt|,
name|h
decl_stmt|,
name|srcOffset
decl_stmt|;
name|unsigned
name|int
name|format
decl_stmt|;
name|unsigned
name|char
modifier|*
name|pImage
decl_stmt|;
block|{
name|unsigned
name|long
name|planeMask
init|=
name|pGC
operator|->
name|planemask
decl_stmt|;
name|int
name|i
decl_stmt|;
name|unsigned
name|int
name|planeSize
decl_stmt|,
name|srcStride
decl_stmt|,
name|widthDst
decl_stmt|,
name|garbageBits
decl_stmt|,
name|bits
decl_stmt|;
name|CARD8
modifier|*
name|psrc
decl_stmt|,
modifier|*
name|psrcLine
decl_stmt|,
modifier|*
name|psrcBase
decl_stmt|,
modifier|*
name|pdstBase
decl_stmt|,
modifier|*
name|pdstLine
decl_stmt|,
modifier|*
name|pdst
decl_stmt|;
name|RegionPtr
name|pRegion
decl_stmt|;
name|unsigned
name|int
name|alu
decl_stmt|;
specifier|register
name|BoxPtr
name|pBox
decl_stmt|;
name|unsigned
name|int
name|numBoxes
decl_stmt|;
name|CARD8
name|srcByte
decl_stmt|;
name|unsigned
name|int
name|rows
decl_stmt|;
name|unsigned
name|int
name|pixels
decl_stmt|;
if|if
condition|(
operator|(
name|w
operator|==
literal|0
operator|)
operator|||
operator|(
name|h
operator|==
literal|0
operator|)
condition|)
return|return;
name|planeMask
operator|&=
name|getPlanesMask
argument_list|(
name|pDraw
operator|->
name|pScreen
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|format
operator|==
name|ZPixmap
operator|)
operator|||
operator|(
operator|(
name|pDraw
operator|->
name|type
operator|==
name|DRAWABLE_PIXMAP
operator|)
operator|&&
operator|(
operator|(
call|(
name|PixmapPtr
call|)
argument_list|(
name|pDraw
argument_list|)
operator|)
operator|->
name|devKind
operator|==
name|PIXMAP_HOST_MEMORY
operator|)
operator|)
condition|)
block|{
comment|/* 	 * mi seems to work for ZPixmaps 	 * and my code doesn't work for main-memory pixmaps since 	 * I rely on the hardware plane-enable 	 */
name|miPutImage
argument_list|(
name|pDraw
argument_list|,
name|pGC
argument_list|,
name|depth
argument_list|,
name|dstx
argument_list|,
name|dsty
argument_list|,
name|w
argument_list|,
name|h
argument_list|,
name|srcOffset
argument_list|,
name|format
argument_list|,
name|pImage
argument_list|)
expr_stmt|;
return|return;
block|}
name|alu
operator|=
name|pGC
operator|->
name|alu
expr_stmt|;
name|pRegion
operator|=
operator|(
operator|(
name|cfbPrivGC
operator|*
operator|)
operator|(
name|pGC
operator|->
name|devPrivates
index|[
name|cfbGCPrivateIndex
index|]
operator|.
name|ptr
operator|)
operator|)
operator|->
name|pCompositeClip
expr_stmt|;
name|pBox
operator|=
name|REGION_RECTS
argument_list|(
name|pRegion
argument_list|)
expr_stmt|;
name|numBoxes
operator|=
name|REGION_NUM_RECTS
argument_list|(
name|pRegion
argument_list|)
expr_stmt|;
name|dstx
operator|+=
name|pDraw
operator|->
name|x
expr_stmt|;
name|dsty
operator|+=
name|pDraw
operator|->
name|y
expr_stmt|;
if|if
condition|(
name|pDraw
operator|->
name|type
operator|==
name|DRAWABLE_WINDOW
condition|)
block|{
name|widthDst
operator|=
operator|(
name|unsigned
name|int
operator|)
name|getPrivScreenPtr
argument_list|(
name|pDraw
operator|->
name|pScreen
argument_list|)
operator|->
name|stride
expr_stmt|;
name|pdstBase
operator|=
operator|(
name|CARD8
operator|*
operator|)
name|getPrivScreenPtr
argument_list|(
name|pDraw
operator|->
name|pScreen
argument_list|)
operator|->
name|bits
expr_stmt|;
block|}
else|else
block|{
name|widthDst
operator|=
call|(
name|unsigned
name|int
call|)
argument_list|(
operator|(
call|(
name|hpPrivPixmapPtr
call|)
argument_list|(
operator|(
operator|(
name|PixmapPtr
operator|)
name|pDraw
operator|)
operator|->
name|devPrivate
operator|.
name|ptr
argument_list|)
operator|)
operator|->
name|stride
argument_list|)
expr_stmt|;
name|pdstBase
operator|=
operator|(
name|CARD8
operator|*
operator|)
operator|(
operator|(
call|(
name|hpPrivPixmapPtr
call|)
argument_list|(
operator|(
operator|(
name|PixmapPtr
operator|)
name|pDraw
operator|)
operator|->
name|devPrivate
operator|.
name|ptr
argument_list|)
operator|)
operator|->
name|bits
operator|)
expr_stmt|;
block|}
name|srcStride
operator|=
name|PixmapBytePad
argument_list|(
name|w
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|planeSize
operator|=
name|h
operator|*
name|srcStride
expr_stmt|;
while|while
condition|(
name|numBoxes
operator|--
condition|)
block|{
name|int
name|clippedWidth
init|=
name|w
operator|-
name|srcOffset
decl_stmt|;
name|int
name|clippedHeight
init|=
name|h
decl_stmt|;
name|int
name|startx
init|=
name|dstx
decl_stmt|;
name|int
name|starty
init|=
name|dsty
decl_stmt|;
name|int
name|dx
init|=
literal|0
decl_stmt|,
name|dy
init|=
literal|0
decl_stmt|;
name|CARD8
modifier|*
name|pdstBox
init|=
name|pdstBase
decl_stmt|;
name|psrcBase
operator|=
operator|(
name|CARD8
operator|*
operator|)
name|pImage
expr_stmt|;
comment|/* 	 * clip the height 	 */
if|if
condition|(
name|dsty
operator|<
name|pBox
operator|->
name|y1
condition|)
block|{
name|dy
operator|=
name|pBox
operator|->
name|y1
operator|-
name|dsty
expr_stmt|;
name|clippedHeight
operator|-=
name|dy
expr_stmt|;
if|if
condition|(
name|clippedHeight
operator|<=
literal|0
condition|)
block|{
name|pBox
operator|++
expr_stmt|;
continue|continue;
block|}
name|starty
operator|=
name|pBox
operator|->
name|y1
expr_stmt|;
block|}
if|if
condition|(
name|starty
operator|+
name|clippedHeight
operator|>
name|pBox
operator|->
name|y2
condition|)
block|{
name|clippedHeight
operator|=
name|pBox
operator|->
name|y2
operator|-
name|starty
expr_stmt|;
if|if
condition|(
name|clippedHeight
operator|<=
literal|0
condition|)
block|{
name|pBox
operator|++
expr_stmt|;
continue|continue;
block|}
block|}
comment|/* 	 * clip the width 	 */
if|if
condition|(
name|dstx
operator|<
name|pBox
operator|->
name|x1
condition|)
block|{
name|dx
operator|=
name|pBox
operator|->
name|x1
operator|-
name|dstx
expr_stmt|;
name|clippedWidth
operator|-=
name|dx
expr_stmt|;
if|if
condition|(
name|clippedWidth
operator|<=
literal|0
condition|)
block|{
name|pBox
operator|++
expr_stmt|;
continue|continue;
block|}
name|startx
operator|=
name|pBox
operator|->
name|x1
expr_stmt|;
block|}
if|if
condition|(
name|startx
operator|+
name|clippedWidth
operator|>
name|pBox
operator|->
name|x2
condition|)
block|{
name|clippedWidth
operator|=
name|pBox
operator|->
name|x2
operator|-
name|startx
expr_stmt|;
if|if
condition|(
name|clippedWidth
operator|<=
literal|0
condition|)
block|{
name|pBox
operator|++
expr_stmt|;
continue|continue;
block|}
block|}
if|if
condition|(
operator|!
name|clippedWidth
operator|||
operator|!
name|clippedHeight
condition|)
block|{
name|pBox
operator|++
expr_stmt|;
continue|continue;
block|}
comment|/* 	 * get address of the first destination pixel 	 */
name|pdstBox
operator|+=
name|startx
operator|+
name|starty
operator|*
name|widthDst
expr_stmt|;
comment|/* 	 * get address of the first source bytes with useful bits 	 */
name|psrcBase
operator|+=
name|srcStride
operator|*
name|dy
operator|+
operator|(
name|srcOffset
operator|+
name|dx
operator|)
operator|/
literal|8
expr_stmt|;
name|garbageBits
operator|=
operator|(
name|srcOffset
operator|+
name|dx
operator|)
operator|%
literal|8
expr_stmt|;
if|if
condition|(
name|depth
operator|==
literal|1
condition|)
block|{
comment|/* 	     * XYBitmap code 	     */
name|unsigned
name|int
name|fore
init|=
name|pGC
operator|->
name|fgPixel
decl_stmt|;
name|unsigned
name|int
name|back
init|=
name|pGC
operator|->
name|bgPixel
decl_stmt|;
name|rows
operator|=
name|clippedHeight
expr_stmt|;
name|pixels
operator|=
name|clippedWidth
expr_stmt|;
comment|/* 	     * write enable the one plane we want to alter 	     */
name|SET_REGISTERS_FOR_WRITING
argument_list|(
name|pDraw
operator|->
name|pScreen
argument_list|,
name|planeMask
argument_list|,
name|alu
argument_list|)
expr_stmt|;
name|psrcLine
operator|=
name|psrcBase
expr_stmt|;
name|pdstLine
operator|=
name|pdstBox
expr_stmt|;
while|while
condition|(
name|rows
operator|--
condition|)
block|{
name|psrc
operator|=
name|psrcLine
expr_stmt|;
name|pdst
operator|=
name|pdstLine
expr_stmt|;
name|srcByte
operator|=
operator|*
name|psrc
operator|++
operator|<<
name|garbageBits
expr_stmt|;
name|bits
operator|=
literal|8
operator|-
name|garbageBits
expr_stmt|;
while|while
condition|(
name|pixels
operator|--
condition|)
block|{
if|if
condition|(
name|srcByte
operator|&
literal|0x80
condition|)
operator|*
name|pdst
operator|++
operator|=
name|fore
expr_stmt|;
else|else
operator|*
name|pdst
operator|++
operator|=
name|back
expr_stmt|;
if|if
condition|(
operator|--
name|bits
condition|)
name|srcByte
operator|<<=
literal|1
expr_stmt|;
else|else
block|{
name|bits
operator|=
literal|8
expr_stmt|;
name|srcByte
operator|=
operator|*
name|psrc
operator|++
expr_stmt|;
block|}
block|}
name|pixels
operator|=
name|clippedWidth
expr_stmt|;
name|psrcLine
operator|+=
name|srcStride
expr_stmt|;
name|pdstLine
operator|+=
name|widthDst
expr_stmt|;
block|}
block|}
else|else
block|{
for|for
control|(
name|i
operator|=
literal|1
operator|<<
operator|(
name|depth
operator|-
literal|1
operator|)
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|>>=
literal|1
operator|,
name|psrcBase
operator|+=
name|planeSize
control|)
block|{
if|if
condition|(
name|i
operator|&
name|planeMask
condition|)
block|{
name|rows
operator|=
name|clippedHeight
expr_stmt|;
name|pixels
operator|=
name|clippedWidth
expr_stmt|;
comment|/* 		     * write enable the one plane we want to alter 		     */
name|SET_REGISTERS_FOR_WRITING
argument_list|(
name|pDraw
operator|->
name|pScreen
argument_list|,
name|i
argument_list|,
name|alu
argument_list|)
expr_stmt|;
name|psrcLine
operator|=
name|psrcBase
expr_stmt|;
name|pdstLine
operator|=
name|pdstBox
expr_stmt|;
while|while
condition|(
name|rows
operator|--
condition|)
block|{
name|psrc
operator|=
name|psrcLine
expr_stmt|;
name|pdst
operator|=
name|pdstLine
expr_stmt|;
name|srcByte
operator|=
operator|*
name|psrc
operator|++
operator|<<
name|garbageBits
expr_stmt|;
name|bits
operator|=
literal|8
operator|-
name|garbageBits
expr_stmt|;
while|while
condition|(
name|pixels
operator|--
condition|)
block|{
if|if
condition|(
name|srcByte
operator|&
literal|0x80
condition|)
operator|*
name|pdst
operator|++
operator|=
literal|0xff
expr_stmt|;
else|else
operator|*
name|pdst
operator|++
operator|=
literal|0x00
expr_stmt|;
if|if
condition|(
operator|--
name|bits
condition|)
name|srcByte
operator|<<=
literal|1
expr_stmt|;
else|else
block|{
name|bits
operator|=
literal|8
expr_stmt|;
name|srcByte
operator|=
operator|*
name|psrc
operator|++
expr_stmt|;
block|}
block|}
name|pixels
operator|=
name|clippedWidth
expr_stmt|;
name|psrcLine
operator|+=
name|srcStride
expr_stmt|;
name|pdstLine
operator|+=
name|widthDst
expr_stmt|;
block|}
block|}
block|}
block|}
name|pBox
operator|++
expr_stmt|;
block|}
name|SET_REGISTERS_FOR_WRITING
argument_list|(
name|pDraw
operator|->
name|pScreen
argument_list|,
literal|0xff
argument_list|,
name|alu
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

