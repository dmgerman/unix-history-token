begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*********************************************************** Copyright 1987 by Digital Equipment Corporation, Maynard, Massachusetts, and the Massachusetts Institute of Technology, Cambridge, Massachusetts.                          All Rights Reserved  Permission to use, copy, modify, and distribute this software and its  documentation for any purpose and without fee is hereby granted,  provided that the above copyright notice appear in all copies and that both that copyright notice and this permission notice appear in  supporting documentation, and that the names of Digital or MIT not be used in advertising or publicity pertaining to distribution of the software without specific, written prior permission.    DIGITAL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL DIGITAL BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  ******************************************************************/
end_comment

begin_comment
comment|/* $XConsortium: mfbplygblt.c,v 5.4 91/01/27 13:02:11 keith Exp $ */
end_comment

begin_include
include|#
directive|include
file|"X.h"
end_include

begin_include
include|#
directive|include
file|"Xmd.h"
end_include

begin_include
include|#
directive|include
file|"Xproto.h"
end_include

begin_include
include|#
directive|include
file|"mfb.h"
end_include

begin_include
include|#
directive|include
file|"fontstruct.h"
end_include

begin_include
include|#
directive|include
file|"dixfontstr.h"
end_include

begin_include
include|#
directive|include
file|"gcstruct.h"
end_include

begin_include
include|#
directive|include
file|"windowstr.h"
end_include

begin_include
include|#
directive|include
file|"pixmapstr.h"
end_include

begin_include
include|#
directive|include
file|"scrnintstr.h"
end_include

begin_include
include|#
directive|include
file|"regionstr.h"
end_include

begin_include
include|#
directive|include
file|"maskbits.h"
end_include

begin_include
include|#
directive|include
file|"miscstruct.h"
end_include

begin_function_decl
specifier|extern
name|void
name|QueryGlyphExtents
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/*     we should eventually special-case fixed-width fonts, although its more important for ImageText, which is meant for terminal emulators.      this works for fonts with glyphs<= 32 bits wide.      the clipping calculations are done for worst-case fonts. we make no assumptions about the heights, widths, or bearings of the glyphs.  if we knew that the glyphs are all the same height, we could clip the tops and bottoms per clipping box, rather than per character per clipping box.  if we knew that the glyphs' left and right bearings were well-behaved, we could clip a single character at the start, output until the last unclipped character, and then clip the last one.  this is all straightforward to determine based on max-bounds and min-bounds from the font.     there is some inefficiency introduced in the per-character clipping to make what's going on clearer.      (it is possible, for example, for a font to be defined in which the next-to-last character in a font would be clipped out, but the last one wouldn't.  the code below deals with this.)      PolyText looks at the fg color and the rasterop; mfbValidateGC swaps in the right routine after looking at the reduced ratserop in the private field of the GC.       the register allocations are provisional; in particualr startmask and endmask might not be the right things.  pglyph, xoff, pdst, and tmpSrc are fairly obvious, though.     to avoid source proliferation, this file is compiled three times: 	MFBPOLYGLYPHBLT		OPEQ 	mfbPolyGlyphBltWhite	|= 	mfbPolyGlyphBltBlack&=~ 	mfbPolyGlyphBltInvert	^= */
end_comment

begin_function
name|void
name|MFBPOLYGLYPHBLT
parameter_list|(
name|pDrawable
parameter_list|,
name|pGC
parameter_list|,
name|x
parameter_list|,
name|y
parameter_list|,
name|nglyph
parameter_list|,
name|ppci
parameter_list|,
name|pglyphBase
parameter_list|)
name|DrawablePtr
name|pDrawable
decl_stmt|;
name|GCPtr
name|pGC
decl_stmt|;
name|int
name|x
decl_stmt|,
name|y
decl_stmt|;
name|unsigned
name|int
name|nglyph
decl_stmt|;
name|CharInfoPtr
modifier|*
name|ppci
decl_stmt|;
comment|/* array of character info */
name|unsigned
name|char
modifier|*
name|pglyphBase
decl_stmt|;
comment|/* start of array of glyphs (unused in R5) */
block|{
name|ExtentInfoRec
name|info
decl_stmt|;
comment|/* used by QueryGlyphExtents() */
name|BoxRec
name|bbox
decl_stmt|;
comment|/* string's bounding box */
name|CharInfoPtr
name|pci
decl_stmt|;
name|int
name|xorg
decl_stmt|,
name|yorg
decl_stmt|;
comment|/* origin of drawable in bitmap */
name|int
name|widthDst
decl_stmt|;
comment|/* width of dst in longwords */
comment|/* these keep track of the character origin */
name|unsigned
name|int
modifier|*
name|pdstBase
decl_stmt|;
comment|/* points to longword with character origin */
name|int
name|xchar
decl_stmt|;
comment|/* xorigin of char (mod 32) */
comment|/* these are used for placing the glyph */
specifier|register
name|int
name|xoff
decl_stmt|;
comment|/* x offset of left edge of glyph (mod 32) */
specifier|register
name|unsigned
name|int
modifier|*
name|pdst
decl_stmt|;
comment|/* pointer to current longword in dst */
name|int
name|w
decl_stmt|;
comment|/* width of glyph in bits */
name|int
name|h
decl_stmt|;
comment|/* height of glyph */
name|int
name|widthGlyph
decl_stmt|;
comment|/* width of glyph, in bytes */
specifier|register
name|unsigned
name|char
modifier|*
name|pglyph
decl_stmt|;
comment|/* pointer to current row of glyph */
comment|/* used for putting down glyph */
specifier|register
name|unsigned
name|int
name|tmpSrc
decl_stmt|;
comment|/* for getting bits from glyph */
specifier|register
name|int
name|startmask
decl_stmt|;
specifier|register
name|int
name|endmask
decl_stmt|;
specifier|register
name|int
name|nFirst
decl_stmt|;
comment|/* bits of glyph in current longword */
if|if
condition|(
operator|!
operator|(
name|pGC
operator|->
name|planemask
operator|&
literal|1
operator|)
condition|)
return|return;
name|xorg
operator|=
name|pDrawable
operator|->
name|x
expr_stmt|;
name|yorg
operator|=
name|pDrawable
operator|->
name|y
expr_stmt|;
if|if
condition|(
name|pDrawable
operator|->
name|type
operator|==
name|DRAWABLE_WINDOW
condition|)
block|{
name|pdstBase
operator|=
operator|(
name|unsigned
name|int
operator|*
operator|)
name|getPrivScreenPtr
argument_list|(
name|pDrawable
operator|->
name|pScreen
argument_list|)
operator|->
name|bits
expr_stmt|;
name|widthDst
operator|=
operator|(
name|int
operator|)
name|getPrivScreenPtr
argument_list|(
name|pDrawable
operator|->
name|pScreen
argument_list|)
operator|->
name|stride
operator|>>
literal|2
expr_stmt|;
block|}
else|else
block|{
name|pdstBase
operator|=
operator|(
name|unsigned
name|int
operator|*
operator|)
name|getPrivPixmapPtr
argument_list|(
name|pDrawable
argument_list|)
operator|->
name|bits
expr_stmt|;
name|widthDst
operator|=
operator|(
name|int
operator|)
name|getPrivPixmapPtr
argument_list|(
name|pDrawable
argument_list|)
operator|->
name|stride
operator|>>
literal|2
expr_stmt|;
block|}
name|x
operator|+=
name|xorg
expr_stmt|;
name|y
operator|+=
name|yorg
expr_stmt|;
name|QueryGlyphExtents
argument_list|(
name|pGC
operator|->
name|font
argument_list|,
name|ppci
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|nglyph
argument_list|,
operator|&
name|info
argument_list|)
expr_stmt|;
name|bbox
operator|.
name|x1
operator|=
name|x
operator|+
name|info
operator|.
name|overallLeft
expr_stmt|;
name|bbox
operator|.
name|x2
operator|=
name|x
operator|+
name|info
operator|.
name|overallRight
expr_stmt|;
name|bbox
operator|.
name|y1
operator|=
name|y
operator|-
name|info
operator|.
name|overallAscent
expr_stmt|;
name|bbox
operator|.
name|y2
operator|=
name|y
operator|+
name|info
operator|.
name|overallDescent
expr_stmt|;
switch|switch
condition|(
call|(
modifier|*
name|pGC
operator|->
name|pScreen
operator|->
name|RectIn
call|)
argument_list|(
operator|(
operator|(
name|mfbPrivGC
operator|*
operator|)
operator|(
name|pGC
operator|->
name|devPrivates
index|[
name|mfbGCPrivateIndex
index|]
operator|.
name|ptr
operator|)
operator|)
operator|->
name|pCompositeClip
argument_list|,
operator|&
name|bbox
argument_list|)
condition|)
block|{
case|case
name|rgnOUT
case|:
break|break;
case|case
name|rgnIN
case|:
name|pdstBase
operator|=
name|pdstBase
operator|+
operator|(
name|widthDst
operator|*
name|y
operator|)
operator|+
operator|(
name|x
operator|>>
literal|5
operator|)
expr_stmt|;
name|xchar
operator|=
name|x
operator|&
literal|0x1f
expr_stmt|;
while|while
condition|(
name|nglyph
operator|--
condition|)
block|{
name|pci
operator|=
operator|*
name|ppci
expr_stmt|;
name|pglyph
operator|=
name|FONTGLYPHBITS
argument_list|(
name|pglyphBase
argument_list|,
name|pci
argument_list|)
expr_stmt|;
name|w
operator|=
name|pci
operator|->
name|metrics
operator|.
name|rightSideBearing
operator|-
name|pci
operator|->
name|metrics
operator|.
name|leftSideBearing
expr_stmt|;
name|h
operator|=
name|pci
operator|->
name|metrics
operator|.
name|ascent
operator|+
name|pci
operator|->
name|metrics
operator|.
name|descent
expr_stmt|;
name|widthGlyph
operator|=
name|GLYPHWIDTHBYTESPADDED
argument_list|(
name|pci
argument_list|)
expr_stmt|;
comment|/* start at top scanline of glyph */
name|pdst
operator|=
name|pdstBase
operator|-
operator|(
name|pci
operator|->
name|metrics
operator|.
name|ascent
operator|*
name|widthDst
operator|)
expr_stmt|;
comment|/* find correct word in scanline and x offset within it 	       for left edge of glyph 	    */
name|xoff
operator|=
name|xchar
operator|+
name|pci
operator|->
name|metrics
operator|.
name|leftSideBearing
expr_stmt|;
if|if
condition|(
name|xoff
operator|>
literal|31
condition|)
block|{
name|pdst
operator|++
expr_stmt|;
name|xoff
operator|&=
literal|0x1f
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|xoff
operator|<
literal|0
condition|)
block|{
name|xoff
operator|+=
literal|32
expr_stmt|;
name|pdst
operator|--
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|xoff
operator|+
name|w
operator|)
operator|<=
literal|32
condition|)
block|{
comment|/* glyph all in one longword */
name|maskpartialbits
argument_list|(
name|xoff
argument_list|,
name|w
argument_list|,
name|startmask
argument_list|)
expr_stmt|;
while|while
condition|(
name|h
operator|--
condition|)
block|{
name|getleftbits
argument_list|(
name|pglyph
argument_list|,
name|w
argument_list|,
name|tmpSrc
argument_list|)
expr_stmt|;
operator|*
name|pdst
name|OPEQ
argument_list|(
name|SCRRIGHT
argument_list|(
name|tmpSrc
argument_list|,
name|xoff
argument_list|)
operator|&
name|startmask
argument_list|)
expr_stmt|;
name|pglyph
operator|+=
name|widthGlyph
expr_stmt|;
name|pdst
operator|+=
name|widthDst
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* glyph crosses longword boundary */
name|mask32bits
argument_list|(
name|xoff
argument_list|,
name|w
argument_list|,
name|startmask
argument_list|,
name|endmask
argument_list|)
expr_stmt|;
name|nFirst
operator|=
literal|32
operator|-
name|xoff
expr_stmt|;
while|while
condition|(
name|h
operator|--
condition|)
block|{
name|getleftbits
argument_list|(
name|pglyph
argument_list|,
name|w
argument_list|,
name|tmpSrc
argument_list|)
expr_stmt|;
operator|*
name|pdst
name|OPEQ
argument_list|(
name|SCRRIGHT
argument_list|(
name|tmpSrc
argument_list|,
name|xoff
argument_list|)
operator|&
name|startmask
argument_list|)
expr_stmt|;
operator|*
operator|(
name|pdst
operator|+
literal|1
operator|)
name|OPEQ
argument_list|(
name|SCRLEFT
argument_list|(
name|tmpSrc
argument_list|,
name|nFirst
argument_list|)
operator|&
name|endmask
argument_list|)
expr_stmt|;
name|pglyph
operator|+=
name|widthGlyph
expr_stmt|;
name|pdst
operator|+=
name|widthDst
expr_stmt|;
block|}
block|}
comment|/* glyph crosses longwords boundary */
comment|/* update character origin */
name|x
operator|+=
name|pci
operator|->
name|metrics
operator|.
name|characterWidth
expr_stmt|;
name|xchar
operator|+=
name|pci
operator|->
name|metrics
operator|.
name|characterWidth
expr_stmt|;
if|if
condition|(
name|xchar
operator|>
literal|31
condition|)
block|{
name|xchar
operator|-=
literal|32
expr_stmt|;
name|pdstBase
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|xchar
operator|<
literal|0
condition|)
block|{
name|xchar
operator|+=
literal|32
expr_stmt|;
name|pdstBase
operator|--
expr_stmt|;
block|}
name|ppci
operator|++
expr_stmt|;
block|}
comment|/* while nglyph-- */
break|break;
case|case
name|rgnPART
case|:
block|{
name|TEXTPOS
modifier|*
name|ppos
decl_stmt|;
name|RegionPtr
name|cclip
decl_stmt|;
name|int
name|nbox
decl_stmt|;
name|BoxPtr
name|pbox
decl_stmt|;
name|int
name|xpos
decl_stmt|;
comment|/* x position of char origin */
name|int
name|i
decl_stmt|;
name|BoxRec
name|clip
decl_stmt|;
name|int
name|leftEdge
decl_stmt|,
name|rightEdge
decl_stmt|;
name|int
name|topEdge
decl_stmt|,
name|bottomEdge
decl_stmt|;
name|int
name|glyphRow
decl_stmt|;
comment|/* first row of glyph not wholly 				   clipped out */
name|int
name|glyphCol
decl_stmt|;
comment|/* leftmost visible column of glyph */
name|int
name|getWidth
decl_stmt|;
comment|/* bits to get from glyph */
if|if
condition|(
operator|!
operator|(
name|ppos
operator|=
operator|(
name|TEXTPOS
operator|*
operator|)
name|ALLOCATE_LOCAL
argument_list|(
name|nglyph
operator|*
sizeof|sizeof
argument_list|(
name|TEXTPOS
argument_list|)
argument_list|)
operator|)
condition|)
return|return;
name|pdstBase
operator|=
name|pdstBase
operator|+
operator|(
name|widthDst
operator|*
name|y
operator|)
operator|+
operator|(
name|x
operator|>>
literal|5
operator|)
expr_stmt|;
name|xpos
operator|=
name|x
expr_stmt|;
name|xchar
operator|=
name|xpos
operator|&
literal|0x1f
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nglyph
condition|;
name|i
operator|++
control|)
block|{
name|pci
operator|=
name|ppci
index|[
name|i
index|]
expr_stmt|;
name|ppos
index|[
name|i
index|]
operator|.
name|xpos
operator|=
name|xpos
expr_stmt|;
name|ppos
index|[
name|i
index|]
operator|.
name|xchar
operator|=
name|xchar
expr_stmt|;
name|ppos
index|[
name|i
index|]
operator|.
name|leftEdge
operator|=
name|xpos
operator|+
name|pci
operator|->
name|metrics
operator|.
name|leftSideBearing
expr_stmt|;
name|ppos
index|[
name|i
index|]
operator|.
name|rightEdge
operator|=
name|xpos
operator|+
name|pci
operator|->
name|metrics
operator|.
name|rightSideBearing
expr_stmt|;
name|ppos
index|[
name|i
index|]
operator|.
name|topEdge
operator|=
name|y
operator|-
name|pci
operator|->
name|metrics
operator|.
name|ascent
expr_stmt|;
name|ppos
index|[
name|i
index|]
operator|.
name|bottomEdge
operator|=
name|y
operator|+
name|pci
operator|->
name|metrics
operator|.
name|descent
expr_stmt|;
name|ppos
index|[
name|i
index|]
operator|.
name|pdstBase
operator|=
name|pdstBase
expr_stmt|;
name|ppos
index|[
name|i
index|]
operator|.
name|widthGlyph
operator|=
name|GLYPHWIDTHBYTESPADDED
argument_list|(
name|pci
argument_list|)
expr_stmt|;
name|xpos
operator|+=
name|pci
operator|->
name|metrics
operator|.
name|characterWidth
expr_stmt|;
name|xchar
operator|+=
name|pci
operator|->
name|metrics
operator|.
name|characterWidth
expr_stmt|;
if|if
condition|(
name|xchar
operator|>
literal|31
condition|)
block|{
name|xchar
operator|&=
literal|0x1f
expr_stmt|;
name|pdstBase
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|xchar
operator|<
literal|0
condition|)
block|{
name|xchar
operator|+=
literal|32
expr_stmt|;
name|pdstBase
operator|--
expr_stmt|;
block|}
block|}
name|cclip
operator|=
operator|(
operator|(
name|mfbPrivGC
operator|*
operator|)
operator|(
name|pGC
operator|->
name|devPrivates
index|[
name|mfbGCPrivateIndex
index|]
operator|.
name|ptr
operator|)
operator|)
operator|->
name|pCompositeClip
expr_stmt|;
name|pbox
operator|=
name|REGION_RECTS
argument_list|(
name|cclip
argument_list|)
expr_stmt|;
name|nbox
operator|=
name|REGION_NUM_RECTS
argument_list|(
name|cclip
argument_list|)
expr_stmt|;
for|for
control|(
init|;
operator|--
name|nbox
operator|>=
literal|0
condition|;
name|pbox
operator|++
control|)
block|{
name|clip
operator|.
name|x1
operator|=
name|max
argument_list|(
name|bbox
operator|.
name|x1
argument_list|,
name|pbox
operator|->
name|x1
argument_list|)
expr_stmt|;
name|clip
operator|.
name|y1
operator|=
name|max
argument_list|(
name|bbox
operator|.
name|y1
argument_list|,
name|pbox
operator|->
name|y1
argument_list|)
expr_stmt|;
name|clip
operator|.
name|x2
operator|=
name|min
argument_list|(
name|bbox
operator|.
name|x2
argument_list|,
name|pbox
operator|->
name|x2
argument_list|)
expr_stmt|;
name|clip
operator|.
name|y2
operator|=
name|min
argument_list|(
name|bbox
operator|.
name|y2
argument_list|,
name|pbox
operator|->
name|y2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|clip
operator|.
name|x2
operator|<=
name|clip
operator|.
name|x1
operator|)
operator|||
operator|(
name|clip
operator|.
name|y2
operator|<=
name|clip
operator|.
name|y1
operator|)
condition|)
continue|continue;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nglyph
condition|;
name|i
operator|++
control|)
block|{
name|pci
operator|=
name|ppci
index|[
name|i
index|]
expr_stmt|;
name|xchar
operator|=
name|ppos
index|[
name|i
index|]
operator|.
name|xchar
expr_stmt|;
comment|/* clip the left and right edges */
if|if
condition|(
name|ppos
index|[
name|i
index|]
operator|.
name|leftEdge
operator|<
name|clip
operator|.
name|x1
condition|)
name|leftEdge
operator|=
name|clip
operator|.
name|x1
expr_stmt|;
else|else
name|leftEdge
operator|=
name|ppos
index|[
name|i
index|]
operator|.
name|leftEdge
expr_stmt|;
if|if
condition|(
name|ppos
index|[
name|i
index|]
operator|.
name|rightEdge
operator|>
name|clip
operator|.
name|x2
condition|)
name|rightEdge
operator|=
name|clip
operator|.
name|x2
expr_stmt|;
else|else
name|rightEdge
operator|=
name|ppos
index|[
name|i
index|]
operator|.
name|rightEdge
expr_stmt|;
name|w
operator|=
name|rightEdge
operator|-
name|leftEdge
expr_stmt|;
if|if
condition|(
name|w
operator|<=
literal|0
condition|)
continue|continue;
comment|/* clip the top and bottom edges */
if|if
condition|(
name|ppos
index|[
name|i
index|]
operator|.
name|topEdge
operator|<
name|clip
operator|.
name|y1
condition|)
name|topEdge
operator|=
name|clip
operator|.
name|y1
expr_stmt|;
else|else
name|topEdge
operator|=
name|ppos
index|[
name|i
index|]
operator|.
name|topEdge
expr_stmt|;
if|if
condition|(
name|ppos
index|[
name|i
index|]
operator|.
name|bottomEdge
operator|>
name|clip
operator|.
name|y2
condition|)
name|bottomEdge
operator|=
name|clip
operator|.
name|y2
expr_stmt|;
else|else
name|bottomEdge
operator|=
name|ppos
index|[
name|i
index|]
operator|.
name|bottomEdge
expr_stmt|;
name|h
operator|=
name|bottomEdge
operator|-
name|topEdge
expr_stmt|;
if|if
condition|(
name|h
operator|<=
literal|0
condition|)
continue|continue;
name|glyphRow
operator|=
operator|(
name|topEdge
operator|-
name|y
operator|)
operator|+
name|pci
operator|->
name|metrics
operator|.
name|ascent
expr_stmt|;
name|widthGlyph
operator|=
name|ppos
index|[
name|i
index|]
operator|.
name|widthGlyph
expr_stmt|;
name|pglyph
operator|=
name|FONTGLYPHBITS
argument_list|(
name|pglyphBase
argument_list|,
name|pci
argument_list|)
expr_stmt|;
name|pglyph
operator|+=
operator|(
name|glyphRow
operator|*
name|widthGlyph
operator|)
expr_stmt|;
name|pdst
operator|=
name|ppos
index|[
name|i
index|]
operator|.
name|pdstBase
operator|-
operator|(
operator|(
name|y
operator|-
name|topEdge
operator|)
operator|*
name|widthDst
operator|)
expr_stmt|;
name|glyphCol
operator|=
operator|(
name|leftEdge
operator|-
name|ppos
index|[
name|i
index|]
operator|.
name|xpos
operator|)
operator|-
operator|(
name|pci
operator|->
name|metrics
operator|.
name|leftSideBearing
operator|)
expr_stmt|;
name|getWidth
operator|=
name|w
operator|+
name|glyphCol
expr_stmt|;
name|xoff
operator|=
name|xchar
operator|+
operator|(
name|leftEdge
operator|-
name|ppos
index|[
name|i
index|]
operator|.
name|xpos
operator|)
expr_stmt|;
if|if
condition|(
name|xoff
operator|>
literal|31
condition|)
block|{
name|xoff
operator|&=
literal|0x1f
expr_stmt|;
name|pdst
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|xoff
operator|<
literal|0
condition|)
block|{
name|xoff
operator|+=
literal|32
expr_stmt|;
name|pdst
operator|--
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|xoff
operator|+
name|w
operator|)
operator|<=
literal|32
condition|)
block|{
name|maskpartialbits
argument_list|(
name|xoff
argument_list|,
name|w
argument_list|,
name|startmask
argument_list|)
expr_stmt|;
while|while
condition|(
name|h
operator|--
condition|)
block|{
name|getshiftedleftbits
argument_list|(
name|pglyph
argument_list|,
name|glyphCol
argument_list|,
name|getWidth
argument_list|,
name|tmpSrc
argument_list|)
expr_stmt|;
operator|*
name|pdst
name|OPEQ
argument_list|(
name|SCRRIGHT
argument_list|(
name|tmpSrc
argument_list|,
name|xoff
argument_list|)
operator|&
name|startmask
argument_list|)
expr_stmt|;
name|pglyph
operator|+=
name|widthGlyph
expr_stmt|;
name|pdst
operator|+=
name|widthDst
expr_stmt|;
block|}
block|}
else|else
block|{
name|mask32bits
argument_list|(
name|xoff
argument_list|,
name|w
argument_list|,
name|startmask
argument_list|,
name|endmask
argument_list|)
expr_stmt|;
name|nFirst
operator|=
literal|32
operator|-
name|xoff
expr_stmt|;
while|while
condition|(
name|h
operator|--
condition|)
block|{
name|getshiftedleftbits
argument_list|(
name|pglyph
argument_list|,
name|glyphCol
argument_list|,
name|getWidth
argument_list|,
name|tmpSrc
argument_list|)
expr_stmt|;
operator|*
name|pdst
name|OPEQ
argument_list|(
name|SCRRIGHT
argument_list|(
name|tmpSrc
argument_list|,
name|xoff
argument_list|)
operator|&
name|startmask
argument_list|)
expr_stmt|;
operator|*
operator|(
name|pdst
operator|+
literal|1
operator|)
name|OPEQ
argument_list|(
name|SCRLEFT
argument_list|(
name|tmpSrc
argument_list|,
name|nFirst
argument_list|)
operator|&
name|endmask
argument_list|)
expr_stmt|;
name|pglyph
operator|+=
name|widthGlyph
expr_stmt|;
name|pdst
operator|+=
name|widthDst
expr_stmt|;
block|}
block|}
block|}
comment|/* for each glyph */
block|}
comment|/* while nbox-- */
name|DEALLOCATE_LOCAL
argument_list|(
name|ppos
argument_list|)
expr_stmt|;
break|break;
block|}
default|default:
break|break;
block|}
block|}
end_function

end_unit

