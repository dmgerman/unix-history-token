begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* $Header: /host/kaukau/disk2/X11R5/R5-hp300/mit/server/ddx/hpbsd/input/RCS/getkeysym.c,v 1.1 1992/09/30 03:14:10 root Exp $ */
end_comment

begin_comment
comment|/***********************************************************************  *  * GetKeySyms - set the key map  *  *  ******************************************************************  *  *  (c) Copyright Hewlett-Packard Company, 1989.  All rights are  *  *  *  reserved.  Copying or other reproduction of this program      *  *  *  except for archival purposes is prohibited without prior      *  *  *  written consent of Hewlett-Packard Company.		     *  *  ******************************************************************  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<X11/XHPlib.h>
end_include

begin_comment
comment|/*#include<X11/keysym.h>*/
end_comment

begin_comment
comment|/* gets sucked in by XHPlib.h */
end_comment

begin_define
define|#
directive|define
name|SUCCESS
value|0
end_define

begin_function_decl
specifier|extern
name|char
modifier|*
name|malloc
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|FILE
modifier|*
name|keysym_file
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|num_headers
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|XHP_keymap_header
modifier|*
name|header_data
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* Not used any more */
end_comment

begin_comment
comment|/* GetKeySyms() gets a key sym table from a file.  * This routine was copied and modified from XHPSetKeyboardMapping() in  * lib/Xhp/XHPSetKbd.c.   * The routine accepts two arguments:  a keyboard id (specifying which  * keymap is to be loaded) and a pointer to a keysym array to be filled in.  * If the keyboard id is in the file, that keysym table is copied into the  * keysym array.  Otherwise, an error is returned and nothing is copied.   * The routine  returns  zero if it  succeeds.  Otherwise,  it returns a  * non-zero  value  specifying  the type of  error  that  occurred.  The  * keyboard  ID value (-2) is a special  value used to  specify a non-HP  * keyboard.  The keyboard ID value (-1) is used to identify HP keyboards  * that are not supported by X (i.e. Arabic, Hebrew, Turkish, ...).   * The  first  time  it  is   called,   the   routine   opens  the  file  * "/usr/lib/X11/Xkeymaps",  reading a header of the  keysym  tables  it  * contains.  The header contains a magic value for identification,  and  * the ID, size, and offset of each keysym table in the file.  */
end_comment

begin_comment
unit|Status GetKeySyms(kbd_id, keysyms)   KEYBOARD_ID 	kbd_id;   KeySym	*keysyms; {     char            magic[MAGIC_SIZE];     int 	    header_size;     int		    index;     int             n, return_code = SUCCESS;     char *name;     char filename[512];
comment|/* If this is the first time this routine has been called, then open      * the keysym file, read the header, and verify the magic and read in      * the keysym table.      */
end_comment

begin_comment
comment|/* get the correct keymapfile name -- use environment variable if it is      * set else use default.  If name starts with '/' it describes full path      * name, else it is relative to the default directory.      */
end_comment

begin_comment
unit|if ( ( name = (char *)getenv("XHPKEYMAPFILE") ) == NULL ) 	name = DEF_FILENAME;      if (name[0] != '/')     { 	strcpy(filename, DEF_DIRECTORY); 	strcat(filename, name);     }     else 	strcpy(filename, name);      if ((keysym_file = fopen(filename,"r")) == NULL) 	return(XHPKB_NOKEYFILE);
comment|/* Read and verify the magic number */
end_comment

begin_comment
unit|fread(magic,MAGIC_SIZE,1,keysym_file);     if ((strcmp(magic,VERIFY_MAGIC)) != 0) 	{ return_code = XHPKB_BADMAGIC; goto done; }
comment|/* Next read in the header size - it is in the next 4 bytes.      * Then read in the header table, which is found in the next      * header-size bytes of the file.      */
end_comment

begin_comment
unit|fread(&header_size,4,1,keysym_file);     if (!(header_data = (struct XHP_keymap_header *)malloc(header_size))) 	{ return_code = XHPKB_NOMEM; goto done; }     fread(header_data,header_size,1,keysym_file);      num_headers = header_size / sizeof(struct XHP_keymap_header);
comment|/* Verify that a valid keyboard ID has been passed in. While you're      * at it, position the header_data pointer to the correct record.      */
end_comment

begin_comment
unit|for (index = 0; index< num_headers; index++)     { 	if (kbd_id == header_data[index].kbd) 	    break;     }      if (index>= num_headers)
comment|/* It's an illegal keyboard ID */
end_comment

begin_comment
unit|{ return_code = XHPKB_BADKBID; goto done; }
comment|/* Copy the keysym table from the file into the keysyms array */
end_comment

begin_endif
unit|fseek(keysym_file, header_data[index].offset, 0);     fread((char *)keysyms, header_data[index].size, 1, keysym_file);  done:     free((char *)header_data);     fclose(keysym_file);     return(return_code); }
endif|#
directive|endif
end_endif

begin_comment
comment|/* This next stuff supersedes the above stuff.  It provides support for      *   keydevice names and modmap names.      * Most of this code was taken from lib/Xhp/tools/cdkeymap.c (probably      *   not called that anymore).      */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|kd_name_heap
init|=
name|NULL
decl_stmt|,
modifier|*
name|modmap_name_heap
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|kd_names
init|=
literal|0
decl_stmt|,
name|num_modmaps
init|=
literal|0
decl_stmt|,
name|num_keydevice_names
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|HPKKeyDeviceInfo
modifier|*
name|keydevice_name_table
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|HPKModMap
modifier|*
name|modmap_table
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|read_kd_name_table
argument_list|()
decl_stmt|,
name|read_modmap_table
argument_list|()
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|HPKsetup
parameter_list|()
block|{
name|char
name|magic
index|[
name|MAGIC_SIZE
index|]
decl_stmt|;
name|int
name|header_size
decl_stmt|;
name|int
name|index
decl_stmt|;
name|int
name|n
decl_stmt|,
name|return_code
init|=
name|True
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|char
name|filename
index|[
literal|512
index|]
decl_stmt|;
comment|/* If this is the first time this routine has been called, then open      * the keysym file, read the header, and verify the magic and read in      * the keysym table.      */
comment|/* get the correct keymapfile name -- use environment variable if it is      * set else use default.  If name starts with '/' it describes full path      * name, else it is relative to the default directory.      */
if|if
condition|(
operator|(
name|name
operator|=
operator|(
name|char
operator|*
operator|)
name|getenv
argument_list|(
literal|"XHPKEYMAPFILE"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|name
operator|=
name|DEF_FILENAME
expr_stmt|;
if|if
condition|(
name|name
index|[
literal|0
index|]
operator|!=
literal|'/'
condition|)
block|{
name|strcpy
argument_list|(
name|filename
argument_list|,
name|DEF_DIRECTORY
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|filename
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
else|else
name|strcpy
argument_list|(
name|filename
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|keysym_file
operator|=
name|fopen
argument_list|(
name|filename
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|XHPKB_NOKEYFILE
operator|)
return|;
comment|/* Read and verify the magic number */
name|fread
argument_list|(
name|magic
argument_list|,
name|MAGIC_SIZE
argument_list|,
literal|1
argument_list|,
name|keysym_file
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|strcmp
argument_list|(
name|magic
argument_list|,
name|VERIFY_MAGIC
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|return_code
operator|=
name|False
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* Next read in the header size - it is in the next 4 bytes.      * Then read in the header table, which is found in the next      * header-size bytes of the file.      */
name|fread
argument_list|(
operator|&
name|header_size
argument_list|,
literal|4
argument_list|,
literal|1
argument_list|,
name|keysym_file
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|header_data
operator|=
operator|(
expr|struct
name|XHP_keymap_header
operator|*
operator|)
name|malloc
argument_list|(
name|header_size
argument_list|)
operator|)
condition|)
block|{
name|return_code
operator|=
name|False
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|fread
argument_list|(
name|header_data
argument_list|,
name|header_size
argument_list|,
literal|1
argument_list|,
name|keysym_file
argument_list|)
expr_stmt|;
name|num_headers
operator|=
name|header_size
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|XHP_keymap_header
argument_list|)
expr_stmt|;
name|read_kd_name_table
argument_list|()
expr_stmt|;
name|read_modmap_table
argument_list|()
expr_stmt|;
name|done
label|:
return|return
name|return_code
return|;
block|}
end_function

begin_comment
comment|/* ******************************************************************** */
end_comment

begin_comment
comment|/* ************************* Lookup Routines ************************** */
end_comment

begin_comment
comment|/* ******************************************************************** */
end_comment

begin_comment
comment|/* Returns:      *   NULL : id not found      *    ptr : pointer into the header table      */
end_comment

begin_function
specifier|static
name|struct
name|XHP_keymap_header
modifier|*
name|HPKlookup_kd_id
parameter_list|(
name|kd_id
parameter_list|)
block|{
name|int
name|n
decl_stmt|;
name|struct
name|XHP_keymap_header
modifier|*
name|ptr
decl_stmt|;
for|for
control|(
name|n
operator|=
name|num_headers
operator|,
name|ptr
operator|=
name|header_data
init|;
name|n
operator|--
condition|;
name|ptr
operator|++
control|)
if|if
condition|(
name|kd_id
operator|==
name|ptr
operator|->
name|kbd
condition|)
return|return
name|ptr
return|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Returns:      *   NULL : id not found      *    ptr : pointer into name table      */
end_comment

begin_function
name|HPKKeyDeviceInfo
modifier|*
name|HPKlookup_kd_by_id
parameter_list|(
name|kd_id
parameter_list|)
block|{
name|int
name|n
decl_stmt|;
name|HPKKeyDeviceInfo
modifier|*
name|ptr
decl_stmt|;
for|for
control|(
name|n
operator|=
name|num_keydevice_names
operator|,
name|ptr
operator|=
name|keydevice_name_table
init|;
name|n
operator|--
condition|;
name|ptr
operator|++
control|)
if|if
condition|(
name|kd_id
operator|==
name|ptr
operator|->
name|keydevice_id
condition|)
return|return
name|ptr
return|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Returns:      *   NULL : modmap not found      *    ptr : pointer into name table      */
end_comment

begin_function
name|HPKModMap
modifier|*
name|HPKlookup_modmap
parameter_list|(
name|modmap_name
parameter_list|)
name|char
modifier|*
name|modmap_name
decl_stmt|;
block|{
name|int
name|n
decl_stmt|;
name|HPKModMap
modifier|*
name|ptr
decl_stmt|;
for|for
control|(
name|n
operator|=
name|num_modmaps
operator|,
name|ptr
operator|=
name|modmap_table
init|;
name|n
operator|--
condition|;
name|ptr
operator|++
control|)
if|if
condition|(
literal|0
operator|==
name|strcmp
argument_list|(
name|modmap_name
argument_list|,
name|ptr
operator|->
name|modmap_name
argument_list|)
condition|)
return|return
name|ptr
return|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Returns:      *   NULL : id not found      *    ptr : pointer into name table      */
end_comment

begin_function
name|HPKKeyDeviceInfo
modifier|*
name|HPKlookup_kd_by_name
parameter_list|(
name|kd_name
parameter_list|)
name|char
modifier|*
name|kd_name
decl_stmt|;
block|{
name|int
name|n
decl_stmt|;
name|HPKKeyDeviceInfo
modifier|*
name|ptr
decl_stmt|;
for|for
control|(
name|n
operator|=
name|num_keydevice_names
operator|,
name|ptr
operator|=
name|keydevice_name_table
init|;
name|n
operator|--
condition|;
name|ptr
operator|++
control|)
if|if
condition|(
literal|0
operator|==
name|strcmp
argument_list|(
name|kd_name
argument_list|,
name|ptr
operator|->
name|name
argument_list|)
condition|)
return|return
name|ptr
return|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* ******************************************************************** */
end_comment

begin_comment
comment|/* *************************** Read Tables **************************** */
end_comment

begin_comment
comment|/* ******************************************************************** */
end_comment

begin_function
specifier|static
name|int
name|read_kd_name_table
parameter_list|()
block|{
name|int
name|a
decl_stmt|,
name|b
decl_stmt|,
name|c
decl_stmt|,
name|d
decl_stmt|,
name|e
decl_stmt|,
name|f
decl_stmt|,
name|n
decl_stmt|,
name|z
decl_stmt|,
name|kd_id
decl_stmt|;
name|HPKKeyDeviceInfo
modifier|*
name|kptr
decl_stmt|;
name|struct
name|XHP_keymap_header
modifier|*
name|ptr
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|ptr
operator|=
name|HPKlookup_kd_id
argument_list|(
name|HPK_KEYDEVICE_NAME_TABLE_ID
argument_list|)
operator|)
condition|)
return|return
name|False
return|;
name|fseek
argument_list|(
name|keysym_file
argument_list|,
name|ptr
operator|->
name|offset
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fread
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|num_keydevice_names
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|,
literal|1
argument_list|,
name|keysym_file
argument_list|)
expr_stmt|;
name|n
operator|=
name|num_keydevice_names
expr_stmt|;
name|fread
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|z
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|,
literal|1
argument_list|,
name|keysym_file
argument_list|)
expr_stmt|;
comment|/* size of names table */
if|if
condition|(
operator|!
operator|(
name|kd_name_heap
operator|=
name|malloc
argument_list|(
name|z
argument_list|)
operator|)
operator|||
operator|!
operator|(
name|keydevice_name_table
operator|=
operator|(
name|HPKKeyDeviceInfo
operator|*
operator|)
name|malloc
argument_list|(
name|n
operator|*
sizeof|sizeof
argument_list|(
name|HPKKeyDeviceInfo
argument_list|)
argument_list|)
operator|)
condition|)
block|{
name|num_keydevice_names
operator|=
literal|0
expr_stmt|;
return|return
name|False
return|;
block|}
name|fread
argument_list|(
name|kd_name_heap
argument_list|,
name|z
argument_list|,
literal|1
argument_list|,
name|keysym_file
argument_list|)
expr_stmt|;
comment|/* read the names */
for|for
control|(
name|kptr
operator|=
name|keydevice_name_table
init|;
name|n
operator|--
condition|;
name|kptr
operator|++
control|)
comment|/* read the name table */
block|{
name|fread
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|a
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|,
literal|1
argument_list|,
name|keysym_file
argument_list|)
expr_stmt|;
comment|/* kd name offset */
name|fread
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|b
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|,
literal|1
argument_list|,
name|keysym_file
argument_list|)
expr_stmt|;
comment|/* key device id */
name|fread
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|c
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|,
literal|1
argument_list|,
name|keysym_file
argument_list|)
expr_stmt|;
comment|/* modmap name offset */
name|fread
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|d
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|,
literal|1
argument_list|,
name|keysym_file
argument_list|)
expr_stmt|;
comment|/* min keycode */
name|fread
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|e
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|,
literal|1
argument_list|,
name|keysym_file
argument_list|)
expr_stmt|;
comment|/* max keycode */
name|fread
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|f
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|,
literal|1
argument_list|,
name|keysym_file
argument_list|)
expr_stmt|;
comment|/* columns */
name|kptr
operator|->
name|name
operator|=
name|kd_name_heap
operator|+
name|a
expr_stmt|;
name|kptr
operator|->
name|keydevice_id
operator|=
name|b
expr_stmt|;
name|kptr
operator|->
name|modmap_name
operator|=
name|kd_name_heap
operator|+
name|c
expr_stmt|;
name|kptr
operator|->
name|min_keycode
operator|=
name|d
expr_stmt|;
name|kptr
operator|->
name|max_keycode
operator|=
name|e
expr_stmt|;
name|kptr
operator|->
name|columns
operator|=
name|f
expr_stmt|;
block|}
return|return
name|True
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|read_modmap_table
parameter_list|()
block|{
name|int
name|n
decl_stmt|,
name|a
decl_stmt|,
name|z
decl_stmt|;
name|HPKModMap
modifier|*
name|mptr
decl_stmt|;
name|struct
name|XHP_keymap_header
modifier|*
name|ptr
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|ptr
operator|=
name|HPKlookup_kd_id
argument_list|(
name|HPK_MODMAP_TABLE_ID
argument_list|)
operator|)
condition|)
return|return
name|False
return|;
name|fseek
argument_list|(
name|keysym_file
argument_list|,
name|ptr
operator|->
name|offset
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fread
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|num_modmaps
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|,
literal|1
argument_list|,
name|keysym_file
argument_list|)
expr_stmt|;
name|fread
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|z
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|,
literal|1
argument_list|,
name|keysym_file
argument_list|)
expr_stmt|;
comment|/* name table size */
if|if
condition|(
operator|!
operator|(
name|modmap_name_heap
operator|=
name|malloc
argument_list|(
name|z
argument_list|)
operator|)
operator|||
operator|!
operator|(
name|modmap_table
operator|=
operator|(
name|HPKModMap
operator|*
operator|)
name|malloc
argument_list|(
name|num_modmaps
operator|*
sizeof|sizeof
argument_list|(
name|HPKModMap
argument_list|)
argument_list|)
operator|)
condition|)
block|{
name|num_modmaps
operator|=
literal|0
expr_stmt|;
return|return
name|False
return|;
block|}
name|fread
argument_list|(
name|modmap_name_heap
argument_list|,
name|z
argument_list|,
literal|1
argument_list|,
name|keysym_file
argument_list|)
expr_stmt|;
comment|/* read the name table */
name|n
operator|=
name|num_modmaps
expr_stmt|;
for|for
control|(
name|mptr
operator|=
name|modmap_table
init|;
name|n
operator|--
condition|;
name|mptr
operator|++
control|)
comment|/* read& build the table */
block|{
name|fread
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|a
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|,
literal|1
argument_list|,
name|keysym_file
argument_list|)
expr_stmt|;
comment|/* modmap name offset */
name|fread
argument_list|(
operator|(
name|char
operator|*
operator|)
name|mptr
operator|->
name|modmap
argument_list|,
name|MODMAP_SIZE
argument_list|,
literal|1
argument_list|,
name|keysym_file
argument_list|)
expr_stmt|;
comment|/* modmap */
name|mptr
operator|->
name|modmap_name
operator|=
name|modmap_name_heap
operator|+
name|a
expr_stmt|;
block|}
return|return
name|True
return|;
block|}
end_function

begin_comment
comment|/* Read a keytable.      * Input:      *   kd_id:  id of the keytable to read.      *   keysyms:  pointer to an area big enough to hold the keytable.      * Returns:      *   TRUE: everything went as expected.      *   FALSE: couldn't find id.      */
end_comment

begin_function
name|int
name|HPKread_keymap
parameter_list|(
name|kd_id
parameter_list|,
name|keysyms
parameter_list|)
name|KeySym
modifier|*
name|keysyms
decl_stmt|;
block|{
name|struct
name|XHP_keymap_header
modifier|*
name|ptr
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|ptr
operator|=
name|HPKlookup_kd_id
argument_list|(
name|kd_id
argument_list|)
operator|)
condition|)
return|return
name|False
return|;
name|fseek
argument_list|(
name|keysym_file
argument_list|,
name|ptr
operator|->
name|offset
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fread
argument_list|(
operator|(
name|char
operator|*
operator|)
name|keysyms
argument_list|,
name|ptr
operator|->
name|size
argument_list|,
literal|1
argument_list|,
name|keysym_file
argument_list|)
expr_stmt|;
return|return
name|True
return|;
block|}
end_function

begin_comment
comment|/* ******************************************************************** */
end_comment

begin_comment
comment|/* ***************************** Clean Up ***************************** */
end_comment

begin_comment
comment|/* ******************************************************************** */
end_comment

begin_function
name|void
name|HPKclean_up
parameter_list|()
block|{
if|if
condition|(
name|keysym_file
condition|)
name|fclose
argument_list|(
name|keysym_file
argument_list|)
expr_stmt|;
name|keysym_file
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|header_data
condition|)
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|header_data
argument_list|)
expr_stmt|;
name|header_data
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|kd_name_heap
condition|)
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|kd_name_heap
argument_list|)
expr_stmt|;
name|kd_name_heap
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|keydevice_name_table
condition|)
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|keydevice_name_table
argument_list|)
expr_stmt|;
name|keydevice_name_table
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|modmap_name_heap
condition|)
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|modmap_name_heap
argument_list|)
expr_stmt|;
name|modmap_name_heap
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|modmap_table
condition|)
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|modmap_table
argument_list|)
expr_stmt|;
name|modmap_table
operator|=
name|NULL
expr_stmt|;
name|num_headers
operator|=
name|kd_names
operator|=
name|num_modmaps
operator|=
name|num_keydevice_names
operator|=
literal|0
expr_stmt|;
block|}
end_function

end_unit

