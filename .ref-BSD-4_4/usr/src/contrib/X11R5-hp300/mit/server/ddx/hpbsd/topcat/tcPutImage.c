begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  Copyright (c) 1986, 1987 by Hewlett-Packard Company Copyright (c) 1986, 1987 by the Massachusetts Institute of Technology  Permission to use, copy, modify, and distribute this software and its documentation for any purpose and without fee is hereby granted, provided that the above copyright notice appear in all copies and that both that copyright notice and this permission notice appear in supporting documentation, and that the name of M.I.T. not be used in advertising or publicity pertaining to distribution of the software without specific, written prior permission.  HEWLETT-PACKARD MAKES NO WARRANTY OF ANY KIND WITH REGARD TO THIS SOFWARE, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR  PURPOSE.  Hewlett-Packard shall not be liable for errors  contained herein or direct, indirect, special, incidental or  consequential damages in connection with the furnishing,  performance, or use of this material.  This software is not subject to any license of the American Telephone and Telegraph Company or of the Regents of the University of California.  */
end_comment

begin_comment
comment|/***********************************************************************  *  file: tcPutImage.c  *  *      PutImage routine for Topcat (should work for Catseye) displays    *   *  *  *		Hewlett Packard -- Corvallis Workstation Operation  *		Project -- port of X11 to HP9000  *		Harry Phinney -- MTS  *  *  */
end_comment

begin_include
include|#
directive|include
file|"X.h"
end_include

begin_include
include|#
directive|include
file|"Xprotostr.h"
end_include

begin_include
include|#
directive|include
file|"misc.h"
end_include

begin_include
include|#
directive|include
file|"gcstruct.h"
end_include

begin_include
include|#
directive|include
file|"pixmapstr.h"
end_include

begin_include
include|#
directive|include
file|"windowstr.h"
end_include

begin_include
include|#
directive|include
file|"scrnintstr.h"
end_include

begin_include
include|#
directive|include
file|"mi.h"
end_include

begin_include
include|#
directive|include
file|"regionstr.h"
end_include

begin_include
include|#
directive|include
file|"Xmd.h"
end_include

begin_include
include|#
directive|include
file|"servermd.h"
end_include

begin_include
include|#
directive|include
file|"../cfb/cfb.h"
end_include

begin_include
include|#
directive|include
file|"topcat.h"
end_include

begin_decl_stmt
specifier|extern
name|u_char
name|XHP_NewRule
index|[
literal|16
index|]
index|[
literal|6
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|XHP_pmap
index|[
literal|256
index|]
index|[
literal|2
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|XHP_QUADALIGN
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* tcPutImage -- entry for the PutImage Request  *  This is here to try to make XY pixmap puts work reasonably on  *  a Topcat/Catseye framebuffer.  It uses the "pmap" array gleaned from   *  Fort C. folks (thanks!) in conjunction with the video card's replacement  *  rule and plane enable registers.  */
end_comment

begin_function
name|void
name|tcPutImage
parameter_list|(
name|pDraw
parameter_list|,
name|pGC
parameter_list|,
name|depth
parameter_list|,
name|dstx
parameter_list|,
name|dsty
parameter_list|,
name|w
parameter_list|,
name|h
parameter_list|,
name|srcOffset
parameter_list|,
name|format
parameter_list|,
name|pImage
parameter_list|)
name|DrawablePtr
name|pDraw
decl_stmt|;
name|GCPtr
name|pGC
decl_stmt|;
name|int
name|depth
decl_stmt|,
name|dstx
decl_stmt|,
name|dsty
decl_stmt|,
name|w
decl_stmt|,
name|h
decl_stmt|,
name|srcOffset
decl_stmt|;
name|unsigned
name|int
name|format
decl_stmt|;
name|unsigned
name|char
modifier|*
name|pImage
decl_stmt|;
block|{
name|TOPCAT
modifier|*
name|hardware
init|=
name|getTcHardware
argument_list|(
name|pDraw
operator|->
name|pScreen
argument_list|)
decl_stmt|;
name|unsigned
name|long
name|screenPlanes
init|=
name|getPlanesMask
argument_list|(
name|pDraw
operator|->
name|pScreen
argument_list|)
decl_stmt|;
name|unsigned
name|long
name|planeMask
init|=
name|pGC
operator|->
name|planemask
operator|&
name|screenPlanes
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|unsigned
name|int
name|planeSize
decl_stmt|,
name|srcStride
decl_stmt|,
name|widthDst
decl_stmt|,
name|garbageBits
decl_stmt|,
name|bits
decl_stmt|;
name|unsigned
name|int
name|leadingBits
decl_stmt|,
name|trailingBits
decl_stmt|,
name|wholeBytes
decl_stmt|;
name|CARD8
modifier|*
name|psrc
decl_stmt|,
modifier|*
name|psrcLine
decl_stmt|,
modifier|*
name|psrcBase
decl_stmt|,
modifier|*
name|pdstBase
decl_stmt|,
modifier|*
name|pdstLine
decl_stmt|,
modifier|*
name|pdst
decl_stmt|;
name|RegionPtr
name|pRegion
decl_stmt|;
name|unsigned
name|int
name|alu
decl_stmt|;
specifier|register
name|BoxPtr
name|pBox
decl_stmt|;
name|unsigned
name|int
name|numBoxes
decl_stmt|;
name|CARD8
name|srcByte
decl_stmt|;
name|unsigned
name|int
name|rows
decl_stmt|;
name|unsigned
name|int
name|pixels
decl_stmt|;
specifier|static
name|unsigned
name|char
name|masks
index|[
literal|8
index|]
init|=
block|{
literal|0x1
block|,
literal|0x2
block|,
literal|0x4
block|,
literal|0x8
block|,
literal|0x10
block|,
literal|0x20
block|,
literal|0x40
block|,
literal|0x80
block|}
decl_stmt|;
specifier|static
name|unsigned
name|char
name|trailMasks
index|[
literal|8
index|]
init|=
block|{
literal|0x80
block|,
literal|0x40
block|,
literal|0x20
block|,
literal|0x10
block|,
literal|0x8
block|,
literal|0x4
block|,
literal|0x2
block|,
literal|0x1
block|}
decl_stmt|;
if|if
condition|(
operator|(
name|format
operator|==
name|ZPixmap
operator|)
operator|||
operator|(
operator|(
name|pDraw
operator|->
name|type
operator|==
name|DRAWABLE_PIXMAP
operator|)
operator|&&
operator|(
operator|(
call|(
name|PixmapPtr
call|)
argument_list|(
name|pDraw
argument_list|)
operator|)
operator|->
name|devKind
operator|==
name|PIXMAP_HOST_MEMORY
operator|)
operator|)
condition|)
block|{
comment|/* 	 * mi seems to work for ZPixmaps 	 * and my code doesn't work for main-memory pixmaps since 	 * I rely on the hardware plane-enable 	 */
name|miPutImage
argument_list|(
name|pDraw
argument_list|,
name|pGC
argument_list|,
name|depth
argument_list|,
name|dstx
argument_list|,
name|dsty
argument_list|,
name|w
argument_list|,
name|h
argument_list|,
name|srcOffset
argument_list|,
name|format
argument_list|,
name|pImage
argument_list|)
expr_stmt|;
return|return;
block|}
name|alu
operator|=
name|pGC
operator|->
name|alu
expr_stmt|;
name|pRegion
operator|=
operator|(
operator|(
name|cfbPrivGC
operator|*
operator|)
operator|(
name|pGC
operator|->
name|devPrivates
index|[
name|cfbGCPrivateIndex
index|]
operator|.
name|ptr
operator|)
operator|)
operator|->
name|pCompositeClip
expr_stmt|;
name|pBox
operator|=
name|REGION_RECTS
argument_list|(
name|pRegion
argument_list|)
expr_stmt|;
name|numBoxes
operator|=
name|REGION_NUM_RECTS
argument_list|(
name|pRegion
argument_list|)
expr_stmt|;
if|if
condition|(
name|pDraw
operator|->
name|type
operator|==
name|DRAWABLE_WINDOW
condition|)
block|{
name|dstx
operator|+=
name|pDraw
operator|->
name|x
expr_stmt|;
name|dsty
operator|+=
name|pDraw
operator|->
name|y
expr_stmt|;
name|widthDst
operator|=
operator|(
name|unsigned
name|int
operator|)
name|getPrivScreenPtr
argument_list|(
name|pDraw
operator|->
name|pScreen
argument_list|)
operator|->
name|stride
expr_stmt|;
name|pdstBase
operator|=
operator|(
name|CARD8
operator|*
operator|)
name|getPrivScreenPtr
argument_list|(
name|pDraw
operator|->
name|pScreen
argument_list|)
operator|->
name|bits
expr_stmt|;
block|}
else|else
block|{
name|widthDst
operator|=
call|(
name|unsigned
name|int
call|)
argument_list|(
operator|(
call|(
name|hpPrivPixmapPtr
call|)
argument_list|(
operator|(
operator|(
name|PixmapPtr
operator|)
name|pDraw
operator|)
operator|->
name|devPrivate
operator|.
name|ptr
argument_list|)
operator|)
operator|->
name|stride
argument_list|)
expr_stmt|;
name|pdstBase
operator|=
operator|(
name|CARD8
operator|*
operator|)
operator|(
operator|(
call|(
name|hpPrivPixmapPtr
call|)
argument_list|(
operator|(
operator|(
name|PixmapPtr
operator|)
name|pDraw
operator|)
operator|->
name|devPrivate
operator|.
name|ptr
argument_list|)
operator|)
operator|->
name|bits
operator|)
expr_stmt|;
block|}
name|srcStride
operator|=
name|PixmapBytePad
argument_list|(
name|w
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|planeSize
operator|=
name|h
operator|*
name|srcStride
expr_stmt|;
name|waitbusy
argument_list|(
name|screenPlanes
argument_list|,
name|hardware
argument_list|)
expr_stmt|;
while|while
condition|(
name|numBoxes
operator|--
condition|)
block|{
name|int
name|clippedWidth
init|=
name|w
operator|-
name|srcOffset
decl_stmt|;
name|int
name|clippedHeight
init|=
name|h
decl_stmt|;
name|int
name|startx
init|=
name|dstx
decl_stmt|;
name|int
name|starty
init|=
name|dsty
decl_stmt|;
name|int
name|dx
init|=
literal|0
decl_stmt|,
name|dy
init|=
literal|0
decl_stmt|;
name|CARD8
modifier|*
name|pdstBox
init|=
name|pdstBase
decl_stmt|;
name|psrcBase
operator|=
operator|(
name|CARD8
operator|*
operator|)
name|pImage
expr_stmt|;
comment|/* 	 * clip the height 	 */
if|if
condition|(
name|dsty
operator|<
name|pBox
operator|->
name|y1
condition|)
block|{
name|dy
operator|=
name|pBox
operator|->
name|y1
operator|-
name|dsty
expr_stmt|;
name|clippedHeight
operator|-=
name|dy
expr_stmt|;
if|if
condition|(
name|clippedHeight
operator|<=
literal|0
condition|)
block|{
name|pBox
operator|++
expr_stmt|;
continue|continue;
block|}
name|starty
operator|=
name|pBox
operator|->
name|y1
expr_stmt|;
block|}
if|if
condition|(
name|starty
operator|+
name|clippedHeight
operator|>
name|pBox
operator|->
name|y2
condition|)
block|{
name|clippedHeight
operator|=
name|pBox
operator|->
name|y2
operator|-
name|starty
expr_stmt|;
if|if
condition|(
name|clippedHeight
operator|<=
literal|0
condition|)
block|{
name|pBox
operator|++
expr_stmt|;
continue|continue;
block|}
block|}
comment|/* 	 * clip the width 	 */
if|if
condition|(
name|dstx
operator|<
name|pBox
operator|->
name|x1
condition|)
block|{
name|dx
operator|=
name|pBox
operator|->
name|x1
operator|-
name|dstx
expr_stmt|;
name|clippedWidth
operator|-=
name|dx
expr_stmt|;
if|if
condition|(
name|clippedWidth
operator|<=
literal|0
condition|)
block|{
name|pBox
operator|++
expr_stmt|;
continue|continue;
block|}
name|startx
operator|=
name|pBox
operator|->
name|x1
expr_stmt|;
block|}
if|if
condition|(
name|startx
operator|+
name|clippedWidth
operator|>
name|pBox
operator|->
name|x2
condition|)
block|{
name|clippedWidth
operator|=
name|pBox
operator|->
name|x2
operator|-
name|startx
expr_stmt|;
if|if
condition|(
name|clippedWidth
operator|<=
literal|0
condition|)
block|{
name|pBox
operator|++
expr_stmt|;
continue|continue;
block|}
block|}
if|if
condition|(
operator|(
name|clippedWidth
operator|<=
literal|0
operator|)
operator|||
operator|(
name|clippedHeight
operator|<=
literal|0
operator|)
condition|)
block|{
name|pBox
operator|++
expr_stmt|;
continue|continue;
block|}
comment|/* 	 * get address of the first destination pixel 	 */
name|pdstBox
operator|+=
name|startx
operator|+
name|starty
operator|*
name|widthDst
expr_stmt|;
comment|/* 	 * get address of the first source bytes with useful bits 	 */
name|psrcBase
operator|+=
name|srcStride
operator|*
name|dy
operator|+
operator|(
name|srcOffset
operator|+
name|dx
operator|)
operator|/
literal|8
expr_stmt|;
name|garbageBits
operator|=
operator|(
name|srcOffset
operator|+
name|dx
operator|)
operator|%
literal|8
expr_stmt|;
name|leadingBits
operator|=
literal|8
operator|-
name|garbageBits
expr_stmt|;
if|if
condition|(
name|leadingBits
operator|==
literal|8
condition|)
name|leadingBits
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|leadingBits
operator|>
name|clippedWidth
condition|)
name|leadingBits
operator|=
name|clippedWidth
expr_stmt|;
name|wholeBytes
operator|=
operator|(
name|clippedWidth
operator|-
name|leadingBits
operator|)
operator|/
literal|8
expr_stmt|;
name|trailingBits
operator|=
name|clippedWidth
operator|-
operator|(
name|wholeBytes
operator|*
literal|8
operator|+
name|leadingBits
operator|)
expr_stmt|;
if|if
condition|(
name|depth
operator|==
literal|1
condition|)
block|{
comment|/* 	     * XYBitmap code 	     */
name|unsigned
name|int
name|fore
init|=
name|pGC
operator|->
name|fgPixel
decl_stmt|;
name|unsigned
name|int
name|back
init|=
name|pGC
operator|->
name|bgPixel
decl_stmt|;
comment|/* 	     * Set up the registers so that writing 0xff will get us the 	     * foreground and writing 0x00 will get the background with 	     * the proper replacement rule  	     */
name|hardware
operator|->
name|write_enable
operator|=
name|planeMask
operator|&
operator|~
name|fore
operator|&
operator|~
name|back
expr_stmt|;
name|hardware
operator|->
name|pixel_write_replacement_rule
operator|=
name|XHP_NewRule
index|[
name|alu
index|]
index|[
literal|0
index|]
expr_stmt|;
name|hardware
operator|->
name|write_enable
operator|=
name|planeMask
operator|&
operator|~
name|fore
operator|&
name|back
expr_stmt|;
name|hardware
operator|->
name|pixel_write_replacement_rule
operator|=
name|XHP_NewRule
index|[
name|alu
index|]
index|[
literal|1
index|]
expr_stmt|;
name|hardware
operator|->
name|write_enable
operator|=
name|planeMask
operator|&
name|fore
operator|&
operator|~
name|back
expr_stmt|;
name|hardware
operator|->
name|pixel_write_replacement_rule
operator|=
name|XHP_NewRule
index|[
name|alu
index|]
index|[
literal|2
index|]
expr_stmt|;
name|hardware
operator|->
name|write_enable
operator|=
name|planeMask
operator|&
name|fore
operator|&
name|back
expr_stmt|;
name|hardware
operator|->
name|pixel_write_replacement_rule
operator|=
name|XHP_NewRule
index|[
name|alu
index|]
index|[
literal|3
index|]
expr_stmt|;
name|hardware
operator|->
name|frame_buf_write_enable
operator|=
name|planeMask
expr_stmt|;
name|psrcLine
operator|=
name|psrcBase
expr_stmt|;
name|pdstLine
operator|=
name|pdstBox
expr_stmt|;
name|pixels
operator|=
name|clippedWidth
expr_stmt|;
for|for
control|(
name|rows
operator|=
name|clippedHeight
init|;
name|rows
operator|--
condition|;
name|pixels
operator|=
name|clippedWidth
operator|,
name|psrcLine
operator|+=
name|srcStride
operator|,
name|pdstLine
operator|+=
name|widthDst
control|)
block|{
name|psrc
operator|=
name|psrcLine
expr_stmt|;
name|pdst
operator|=
name|pdstLine
expr_stmt|;
comment|/* 		 * write any leading bits one at a time until 		 * we're at a whole byte 		 */
if|if
condition|(
name|leadingBits
condition|)
block|{
name|srcByte
operator|=
operator|*
name|psrc
operator|++
expr_stmt|;
for|for
control|(
name|i
operator|=
name|leadingBits
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|srcByte
operator|&
name|masks
index|[
name|i
index|]
condition|)
operator|*
name|pdst
operator|++
operator|=
literal|0xff
expr_stmt|;
else|else
operator|*
name|pdst
operator|++
operator|=
literal|0x00
expr_stmt|;
block|}
block|}
comment|/* 		 * write out all the whole bytes of bitmap 		 */
if|if
condition|(
operator|!
name|XHP_QUADALIGN
operator|||
operator|!
operator|(
operator|(
name|unsigned
name|int
operator|)
name|pdst
operator|&
literal|0x01
operator|)
condition|)
block|{
comment|/*  		     * either we're on a 68020, or we meet the alignment  		     * requirements of a 68010, so we write 4 pixels at a time  		     */
specifier|register
name|unsigned
name|int
modifier|*
name|pdstInt
init|=
operator|(
name|unsigned
name|int
operator|*
operator|)
name|pdst
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|wholeBytes
condition|;
name|i
operator|++
control|)
block|{
name|srcByte
operator|=
operator|*
name|psrc
operator|++
expr_stmt|;
operator|*
name|pdstInt
operator|++
operator|=
name|XHP_pmap
index|[
name|srcByte
index|]
index|[
literal|0
index|]
expr_stmt|;
operator|*
name|pdstInt
operator|++
operator|=
name|XHP_pmap
index|[
name|srcByte
index|]
index|[
literal|1
index|]
expr_stmt|;
block|}
name|pdst
operator|=
operator|(
name|CARD8
operator|*
operator|)
name|pdstInt
expr_stmt|;
block|}
else|else
block|{
comment|/* 		     * we're unaligned on a 310 (bummer...) 		     */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|wholeBytes
condition|;
name|i
operator|++
control|)
block|{
name|srcByte
operator|=
operator|*
name|psrc
operator|++
expr_stmt|;
name|bits
operator|=
literal|8
expr_stmt|;
while|while
condition|(
name|bits
operator|--
condition|)
block|{
if|if
condition|(
name|srcByte
operator|&
name|masks
index|[
name|bits
index|]
condition|)
operator|*
name|pdst
operator|++
operator|=
literal|0xff
expr_stmt|;
else|else
operator|*
name|pdst
operator|++
operator|=
literal|0x00
expr_stmt|;
block|}
block|}
block|}
comment|/* 		 * write any trailing raggedy bits at the end of the row 		 */
if|if
condition|(
name|trailingBits
condition|)
block|{
name|srcByte
operator|=
operator|*
name|psrc
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|trailingBits
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|srcByte
operator|&
name|trailMasks
index|[
name|i
index|]
condition|)
operator|*
name|pdst
operator|++
operator|=
literal|0xff
expr_stmt|;
else|else
operator|*
name|pdst
operator|++
operator|=
literal|0x00
expr_stmt|;
block|}
block|}
block|}
block|}
else|else
block|{
comment|/* XYPixmap case */
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|1
operator|<<
operator|(
name|depth
operator|-
literal|1
operator|)
init|;
name|j
operator|>
literal|0
condition|;
name|j
operator|>>=
literal|1
operator|,
name|psrcBase
operator|+=
name|planeSize
control|)
block|{
if|if
condition|(
name|j
operator|&
name|planeMask
condition|)
block|{
name|rows
operator|=
name|clippedHeight
expr_stmt|;
name|pixels
operator|=
name|clippedWidth
expr_stmt|;
comment|/* 		     * write enable the one plane we want to alter 		     * and set the rep_rule according to the GC 		     */
name|SET_REGISTERS_FOR_WRITING
argument_list|(
name|pDraw
operator|->
name|pScreen
argument_list|,
name|j
argument_list|,
name|alu
argument_list|)
expr_stmt|;
name|psrcLine
operator|=
name|psrcBase
expr_stmt|;
name|pdstLine
operator|=
name|pdstBox
expr_stmt|;
for|for
control|(
name|rows
operator|=
name|clippedHeight
init|;
name|rows
operator|--
condition|;
name|pixels
operator|=
name|clippedWidth
operator|,
name|psrcLine
operator|+=
name|srcStride
operator|,
name|pdstLine
operator|+=
name|widthDst
control|)
block|{
name|psrc
operator|=
name|psrcLine
expr_stmt|;
name|pdst
operator|=
name|pdstLine
expr_stmt|;
comment|/* 			 * write any leading bits one at a time 			 * until at a whole byte 			 */
if|if
condition|(
name|leadingBits
condition|)
block|{
name|srcByte
operator|=
operator|*
name|psrc
operator|++
expr_stmt|;
for|for
control|(
name|i
operator|=
name|leadingBits
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|srcByte
operator|&
name|masks
index|[
name|i
index|]
condition|)
operator|*
name|pdst
operator|++
operator|=
literal|0xff
expr_stmt|;
else|else
operator|*
name|pdst
operator|++
operator|=
literal|0x00
expr_stmt|;
block|}
block|}
comment|/* 			 * write out all the whole bytes of bitmap 			 */
if|if
condition|(
operator|!
name|XHP_QUADALIGN
operator|||
operator|!
operator|(
operator|(
name|unsigned
name|int
operator|)
name|pdst
operator|&
literal|0x01
operator|)
condition|)
block|{
comment|/*  			     * either we're on a 68020, or we meet the alignment  			     * requirements of a 68010, so we write 4 pixels at a time  			     */
specifier|register
name|unsigned
name|int
modifier|*
name|pdstInt
init|=
operator|(
name|unsigned
name|int
operator|*
operator|)
name|pdst
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|wholeBytes
condition|;
name|i
operator|++
control|)
block|{
name|srcByte
operator|=
operator|*
name|psrc
operator|++
expr_stmt|;
operator|*
name|pdstInt
operator|++
operator|=
name|XHP_pmap
index|[
name|srcByte
index|]
index|[
literal|0
index|]
expr_stmt|;
operator|*
name|pdstInt
operator|++
operator|=
name|XHP_pmap
index|[
name|srcByte
index|]
index|[
literal|1
index|]
expr_stmt|;
block|}
name|pdst
operator|=
operator|(
name|CARD8
operator|*
operator|)
name|pdstInt
expr_stmt|;
block|}
else|else
block|{
comment|/* 			     * we're unaligned on a 310 (bummer...) 			     */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|wholeBytes
condition|;
name|i
operator|++
control|)
block|{
name|srcByte
operator|=
operator|*
name|psrc
operator|++
expr_stmt|;
name|bits
operator|=
literal|8
expr_stmt|;
while|while
condition|(
name|bits
operator|--
condition|)
block|{
if|if
condition|(
name|srcByte
operator|&
name|masks
index|[
name|bits
index|]
condition|)
operator|*
name|pdst
operator|++
operator|=
literal|0xff
expr_stmt|;
else|else
operator|*
name|pdst
operator|++
operator|=
literal|0x00
expr_stmt|;
block|}
block|}
block|}
comment|/* 			 * write any trailing raggedy bits at the end of the row 			 */
if|if
condition|(
name|trailingBits
condition|)
block|{
name|srcByte
operator|=
operator|*
name|psrc
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|trailingBits
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|srcByte
operator|&
name|trailMasks
index|[
name|i
index|]
condition|)
operator|*
name|pdst
operator|++
operator|=
literal|0xff
expr_stmt|;
else|else
operator|*
name|pdst
operator|++
operator|=
literal|0x00
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
block|}
name|pBox
operator|++
expr_stmt|;
block|}
name|SET_REGISTERS_FOR_WRITING
argument_list|(
name|pDraw
operator|->
name|pScreen
argument_list|,
literal|0xff
argument_list|,
name|alu
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

