begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*********************************************************** Copyright 1987 by Digital Equipment Corporation, Maynard, Massachusetts, and the Massachusetts Institute of Technology, Cambridge, Massachusetts.                          All Rights Reserved  Permission to use, copy, modify, and distribute this software and its  documentation for any purpose and without fee is hereby granted,  provided that the above copyright notice appear in all copies and that both that copyright notice and this permission notice appear in  supporting documentation, and that the names of Digital or MIT not be used in advertising or publicity pertaining to distribution of the software without specific, written prior permission.    DIGITAL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL DIGITAL BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  ******************************************************************/
end_comment

begin_comment
comment|/* $XConsortium: mfbgc.c,v 5.25 91/05/26 09:22:58 rws Exp $ */
end_comment

begin_include
include|#
directive|include
file|"X.h"
end_include

begin_include
include|#
directive|include
file|"Xmd.h"
end_include

begin_include
include|#
directive|include
file|"Xproto.h"
end_include

begin_include
include|#
directive|include
file|"mfb.h"
end_include

begin_include
include|#
directive|include
file|"dixfontstr.h"
end_include

begin_include
include|#
directive|include
file|"fontstruct.h"
end_include

begin_include
include|#
directive|include
file|"gcstruct.h"
end_include

begin_include
include|#
directive|include
file|"windowstr.h"
end_include

begin_include
include|#
directive|include
file|"pixmapstr.h"
end_include

begin_include
include|#
directive|include
file|"scrnintstr.h"
end_include

begin_include
include|#
directive|include
file|"region.h"
end_include

begin_include
include|#
directive|include
file|"mistruct.h"
end_include

begin_include
include|#
directive|include
file|"maskbits.h"
end_include

begin_function_decl
specifier|static
name|void
name|mfbDestroyOps
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|GCFuncs
name|mfbFuncs
init|=
block|{
name|mfbValidateGC
block|,
name|mfbChangeGC
block|,
name|mfbCopyGC
block|,
name|mfbDestroyGC
block|,
name|mfbChangeClip
block|,
name|mfbDestroyClip
block|,
name|mfbCopyClip
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|GCOps
name|whiteTECopyOps
init|=
block|{
name|mfbWhiteSolidFS
block|,
name|mfbSetSpans
block|,
name|mfbPutImage
block|,
name|mfbCopyArea
block|,
name|mfbCopyPlane
block|,
name|mfbPolyPoint
block|,
name|mfbLineSS
block|,
name|mfbSegmentSS
block|,
name|miPolyRectangle
block|,
name|mfbZeroPolyArcSS
block|,
name|miFillPolygon
block|,
name|mfbPolyFillRect
block|,
name|mfbPolyFillArcSolid
block|,
name|miPolyText8
block|,
name|miPolyText16
block|,
name|miImageText8
block|,
name|miImageText16
block|,
name|mfbTEGlyphBltWhite
block|,
name|mfbPolyGlyphBltWhite
block|,
name|mfbSolidPP
block|,
name|NULL
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|GCOps
name|blackTECopyOps
init|=
block|{
name|mfbBlackSolidFS
block|,
name|mfbSetSpans
block|,
name|mfbPutImage
block|,
name|mfbCopyArea
block|,
name|mfbCopyPlane
block|,
name|mfbPolyPoint
block|,
name|mfbLineSS
block|,
name|mfbSegmentSS
block|,
name|miPolyRectangle
block|,
name|mfbZeroPolyArcSS
block|,
name|miFillPolygon
block|,
name|mfbPolyFillRect
block|,
name|mfbPolyFillArcSolid
block|,
name|miPolyText8
block|,
name|miPolyText16
block|,
name|miImageText8
block|,
name|miImageText16
block|,
name|mfbTEGlyphBltBlack
block|,
name|mfbPolyGlyphBltBlack
block|,
name|mfbSolidPP
block|,
name|NULL
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|GCOps
name|whiteTEInvertOps
init|=
block|{
name|mfbInvertSolidFS
block|,
name|mfbSetSpans
block|,
name|mfbPutImage
block|,
name|mfbCopyArea
block|,
name|mfbCopyPlane
block|,
name|mfbPolyPoint
block|,
name|mfbLineSS
block|,
name|mfbSegmentSS
block|,
name|miPolyRectangle
block|,
name|miZeroPolyArc
block|,
name|miFillPolygon
block|,
name|mfbPolyFillRect
block|,
name|mfbPolyFillArcSolid
block|,
name|miPolyText8
block|,
name|miPolyText16
block|,
name|miImageText8
block|,
name|miImageText16
block|,
name|mfbTEGlyphBltWhite
block|,
name|mfbPolyGlyphBltInvert
block|,
name|mfbSolidPP
block|,
name|NULL
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|GCOps
name|blackTEInvertOps
init|=
block|{
name|mfbInvertSolidFS
block|,
name|mfbSetSpans
block|,
name|mfbPutImage
block|,
name|mfbCopyArea
block|,
name|mfbCopyPlane
block|,
name|mfbPolyPoint
block|,
name|mfbLineSS
block|,
name|mfbSegmentSS
block|,
name|miPolyRectangle
block|,
name|miZeroPolyArc
block|,
name|miFillPolygon
block|,
name|mfbPolyFillRect
block|,
name|mfbPolyFillArcSolid
block|,
name|miPolyText8
block|,
name|miPolyText16
block|,
name|miImageText8
block|,
name|miImageText16
block|,
name|mfbTEGlyphBltBlack
block|,
name|mfbPolyGlyphBltInvert
block|,
name|mfbSolidPP
block|,
name|NULL
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|GCOps
name|whiteCopyOps
init|=
block|{
name|mfbWhiteSolidFS
block|,
name|mfbSetSpans
block|,
name|mfbPutImage
block|,
name|mfbCopyArea
block|,
name|mfbCopyPlane
block|,
name|mfbPolyPoint
block|,
name|mfbLineSS
block|,
name|mfbSegmentSS
block|,
name|miPolyRectangle
block|,
name|mfbZeroPolyArcSS
block|,
name|miFillPolygon
block|,
name|mfbPolyFillRect
block|,
name|mfbPolyFillArcSolid
block|,
name|miPolyText8
block|,
name|miPolyText16
block|,
name|miImageText8
block|,
name|miImageText16
block|,
name|mfbImageGlyphBltWhite
block|,
name|mfbPolyGlyphBltWhite
block|,
name|mfbSolidPP
block|,
name|NULL
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|GCOps
name|blackCopyOps
init|=
block|{
name|mfbBlackSolidFS
block|,
name|mfbSetSpans
block|,
name|mfbPutImage
block|,
name|mfbCopyArea
block|,
name|mfbCopyPlane
block|,
name|mfbPolyPoint
block|,
name|mfbLineSS
block|,
name|mfbSegmentSS
block|,
name|miPolyRectangle
block|,
name|mfbZeroPolyArcSS
block|,
name|miFillPolygon
block|,
name|mfbPolyFillRect
block|,
name|mfbPolyFillArcSolid
block|,
name|miPolyText8
block|,
name|miPolyText16
block|,
name|miImageText8
block|,
name|miImageText16
block|,
name|mfbImageGlyphBltBlack
block|,
name|mfbPolyGlyphBltBlack
block|,
name|mfbSolidPP
block|,
name|NULL
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|GCOps
name|whiteInvertOps
init|=
block|{
name|mfbInvertSolidFS
block|,
name|mfbSetSpans
block|,
name|mfbPutImage
block|,
name|mfbCopyArea
block|,
name|mfbCopyPlane
block|,
name|mfbPolyPoint
block|,
name|mfbLineSS
block|,
name|mfbSegmentSS
block|,
name|miPolyRectangle
block|,
name|miZeroPolyArc
block|,
name|miFillPolygon
block|,
name|mfbPolyFillRect
block|,
name|mfbPolyFillArcSolid
block|,
name|miPolyText8
block|,
name|miPolyText16
block|,
name|miImageText8
block|,
name|miImageText16
block|,
name|mfbImageGlyphBltWhite
block|,
name|mfbPolyGlyphBltInvert
block|,
name|mfbSolidPP
block|,
name|NULL
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|GCOps
name|blackInvertOps
init|=
block|{
name|mfbInvertSolidFS
block|,
name|mfbSetSpans
block|,
name|mfbPutImage
block|,
name|mfbCopyArea
block|,
name|mfbCopyPlane
block|,
name|mfbPolyPoint
block|,
name|mfbLineSS
block|,
name|mfbSegmentSS
block|,
name|miPolyRectangle
block|,
name|miZeroPolyArc
block|,
name|miFillPolygon
block|,
name|mfbPolyFillRect
block|,
name|mfbPolyFillArcSolid
block|,
name|miPolyText8
block|,
name|miPolyText16
block|,
name|miImageText8
block|,
name|miImageText16
block|,
name|mfbImageGlyphBltBlack
block|,
name|mfbPolyGlyphBltInvert
block|,
name|mfbSolidPP
block|,
name|NULL
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|GCOps
name|whiteWhiteCopyOps
init|=
block|{
name|mfbWhiteSolidFS
block|,
name|mfbSetSpans
block|,
name|mfbPutImage
block|,
name|mfbCopyArea
block|,
name|mfbCopyPlane
block|,
name|mfbPolyPoint
block|,
name|mfbLineSS
block|,
name|mfbSegmentSS
block|,
name|miPolyRectangle
block|,
name|mfbZeroPolyArcSS
block|,
name|miFillPolygon
block|,
name|mfbPolyFillRect
block|,
name|mfbPolyFillArcSolid
block|,
name|miPolyText8
block|,
name|miPolyText16
block|,
name|miImageText8
block|,
name|miImageText16
block|,
name|miImageGlyphBlt
block|,
name|mfbPolyGlyphBltWhite
block|,
name|mfbSolidPP
block|,
name|NULL
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|GCOps
name|blackBlackCopyOps
init|=
block|{
name|mfbBlackSolidFS
block|,
name|mfbSetSpans
block|,
name|mfbPutImage
block|,
name|mfbCopyArea
block|,
name|mfbCopyPlane
block|,
name|mfbPolyPoint
block|,
name|mfbLineSS
block|,
name|mfbSegmentSS
block|,
name|miPolyRectangle
block|,
name|mfbZeroPolyArcSS
block|,
name|miFillPolygon
block|,
name|mfbPolyFillRect
block|,
name|mfbPolyFillArcSolid
block|,
name|miPolyText8
block|,
name|miPolyText16
block|,
name|miImageText8
block|,
name|miImageText16
block|,
name|miImageGlyphBlt
block|,
name|mfbPolyGlyphBltBlack
block|,
name|mfbSolidPP
block|,
name|NULL
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|GCOps
name|fgEqBgInvertOps
init|=
block|{
name|mfbInvertSolidFS
block|,
name|mfbSetSpans
block|,
name|mfbPutImage
block|,
name|mfbCopyArea
block|,
name|mfbCopyPlane
block|,
name|mfbPolyPoint
block|,
name|mfbLineSS
block|,
name|mfbSegmentSS
block|,
name|miPolyRectangle
block|,
name|miZeroPolyArc
block|,
name|miFillPolygon
block|,
name|mfbPolyFillRect
block|,
name|mfbPolyFillArcSolid
block|,
name|miPolyText8
block|,
name|miPolyText16
block|,
name|miImageText8
block|,
name|miImageText16
block|,
name|miImageGlyphBlt
block|,
name|mfbPolyGlyphBltInvert
block|,
name|mfbSolidPP
block|,
name|NULL
block|, }
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|commonOps
block|{
name|int
name|fg
decl_stmt|,
name|bg
decl_stmt|;
name|int
name|rrop
decl_stmt|;
name|int
name|terminalFont
decl_stmt|;
name|GCOps
modifier|*
name|ops
decl_stmt|;
name|void
function_decl|(
modifier|*
name|fillArea
function_decl|)
parameter_list|()
function_decl|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|commonOps
name|mfbCommonOps
index|[]
init|=
block|{
block|{
literal|1
block|,
literal|0
block|,
name|RROP_WHITE
block|,
literal|1
block|,
operator|&
name|whiteTECopyOps
block|,
name|mfbSolidWhiteArea
block|}
block|,
block|{
literal|0
block|,
literal|1
block|,
name|RROP_BLACK
block|,
literal|1
block|,
operator|&
name|blackTECopyOps
block|,
name|mfbSolidBlackArea
block|}
block|,
block|{
literal|1
block|,
literal|0
block|,
name|RROP_INVERT
block|,
literal|1
block|,
operator|&
name|whiteTEInvertOps
block|,
name|mfbSolidInvertArea
block|}
block|,
block|{
literal|0
block|,
literal|1
block|,
name|RROP_INVERT
block|,
literal|1
block|,
operator|&
name|blackTEInvertOps
block|,
name|mfbSolidInvertArea
block|}
block|,
block|{
literal|1
block|,
literal|0
block|,
name|RROP_WHITE
block|,
literal|0
block|,
operator|&
name|whiteCopyOps
block|,
name|mfbSolidWhiteArea
block|}
block|,
block|{
literal|0
block|,
literal|1
block|,
name|RROP_BLACK
block|,
literal|0
block|,
operator|&
name|blackCopyOps
block|,
name|mfbSolidBlackArea
block|}
block|,
block|{
literal|1
block|,
literal|0
block|,
name|RROP_INVERT
block|,
literal|0
block|,
operator|&
name|whiteInvertOps
block|,
name|mfbSolidInvertArea
block|}
block|,
block|{
literal|0
block|,
literal|1
block|,
name|RROP_INVERT
block|,
literal|0
block|,
operator|&
name|blackInvertOps
block|,
name|mfbSolidInvertArea
block|}
block|,
block|{
literal|1
block|,
literal|1
block|,
name|RROP_WHITE
block|,
literal|0
block|,
operator|&
name|whiteWhiteCopyOps
block|,
name|mfbSolidWhiteArea
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
name|RROP_BLACK
block|,
literal|0
block|,
operator|&
name|blackBlackCopyOps
block|,
name|mfbSolidBlackArea
block|}
block|,
block|{
literal|1
block|,
literal|1
block|,
name|RROP_INVERT
block|,
literal|0
block|,
operator|&
name|fgEqBgInvertOps
block|,
name|mfbSolidInvertArea
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
name|RROP_INVERT
block|,
literal|0
block|,
operator|&
name|fgEqBgInvertOps
block|,
name|mfbSolidInvertArea
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|numberCommonOps
value|(sizeof (mfbCommonOps) / sizeof (mfbCommonOps[0]))
end_define

begin_function
specifier|static
name|GCOps
modifier|*
name|matchCommon
parameter_list|(
name|pGC
parameter_list|)
name|GCPtr
name|pGC
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|struct
name|commonOps
modifier|*
name|cop
decl_stmt|;
name|mfbPrivGC
modifier|*
name|priv
decl_stmt|;
if|if
condition|(
name|pGC
operator|->
name|lineWidth
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|pGC
operator|->
name|lineStyle
operator|!=
name|LineSolid
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|pGC
operator|->
name|fillStyle
operator|!=
name|FillSolid
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|pGC
operator|->
name|font
operator|||
name|FONTMAXBOUNDS
argument_list|(
name|pGC
operator|->
name|font
argument_list|,
name|rightSideBearing
argument_list|)
operator|-
name|FONTMINBOUNDS
argument_list|(
name|pGC
operator|->
name|font
argument_list|,
name|leftSideBearing
argument_list|)
operator|>
literal|32
operator|||
name|FONTMINBOUNDS
argument_list|(
name|pGC
operator|->
name|font
argument_list|,
name|characterWidth
argument_list|)
operator|<
literal|0
condition|)
return|return
literal|0
return|;
name|priv
operator|=
operator|(
name|mfbPrivGC
operator|*
operator|)
name|pGC
operator|->
name|devPrivates
index|[
name|mfbGCPrivateIndex
index|]
operator|.
name|ptr
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numberCommonOps
condition|;
name|i
operator|++
control|)
block|{
name|cop
operator|=
operator|&
name|mfbCommonOps
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|pGC
operator|->
name|fgPixel
operator|&
literal|1
operator|)
operator|!=
name|cop
operator|->
name|fg
condition|)
continue|continue;
if|if
condition|(
operator|(
name|pGC
operator|->
name|bgPixel
operator|&
literal|1
operator|)
operator|!=
name|cop
operator|->
name|bg
condition|)
continue|continue;
if|if
condition|(
name|priv
operator|->
name|rop
operator|!=
name|cop
operator|->
name|rrop
condition|)
continue|continue;
if|if
condition|(
name|cop
operator|->
name|terminalFont
operator|&&
operator|!
name|TERMINALFONT
argument_list|(
name|pGC
operator|->
name|font
argument_list|)
condition|)
continue|continue;
name|priv
operator|->
name|FillArea
operator|=
name|cop
operator|->
name|fillArea
expr_stmt|;
return|return
name|cop
operator|->
name|ops
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*    to let hp displays with bit blt override the mfbCopyArea routine.    XXX: currently ignores the pScreen argument    XXX: and will break if multiple screens of different types are attached.  */
end_comment

begin_decl_stmt
name|void
name|mfbRegisterCopyAreaProc
argument_list|(
name|pScreen
argument_list|,
name|proc
argument_list|)
name|ScreenPtr
name|pScreen
decl_stmt|;
end_decl_stmt

begin_function_decl
name|RegionPtr
function_decl|(
modifier|*
name|proc
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_block
block|{
name|whiteTECopyOps
operator|.
name|CopyArea
operator|=
name|proc
expr_stmt|;
name|blackTECopyOps
operator|.
name|CopyArea
operator|=
name|proc
expr_stmt|;
name|whiteTEInvertOps
operator|.
name|CopyArea
operator|=
name|proc
expr_stmt|;
name|blackTEInvertOps
operator|.
name|CopyArea
operator|=
name|proc
expr_stmt|;
name|whiteCopyOps
operator|.
name|CopyArea
operator|=
name|proc
expr_stmt|;
name|blackCopyOps
operator|.
name|CopyArea
operator|=
name|proc
expr_stmt|;
name|whiteInvertOps
operator|.
name|CopyArea
operator|=
name|proc
expr_stmt|;
name|blackInvertOps
operator|.
name|CopyArea
operator|=
name|proc
expr_stmt|;
name|whiteWhiteCopyOps
operator|.
name|CopyArea
operator|=
name|proc
expr_stmt|;
name|blackBlackCopyOps
operator|.
name|CopyArea
operator|=
name|proc
expr_stmt|;
name|fgEqBgInvertOps
operator|.
name|CopyArea
operator|=
name|proc
expr_stmt|;
block|}
end_block

begin_function
name|Bool
name|mfbCreateGC
parameter_list|(
name|pGC
parameter_list|)
specifier|register
name|GCPtr
name|pGC
decl_stmt|;
block|{
name|mfbPrivGC
modifier|*
name|pPriv
decl_stmt|;
name|pGC
operator|->
name|clientClip
operator|=
name|NULL
expr_stmt|;
name|pGC
operator|->
name|clientClipType
operator|=
name|CT_NONE
expr_stmt|;
comment|/* some of the output primitives aren't really necessary, since        they will be filled in ValidateGC because of dix/CreateGC()        setting all the change bits.  Others are necessary because although        they depend on being a monochrome frame buffer, they don't change      */
name|pGC
operator|->
name|ops
operator|=
operator|&
name|whiteCopyOps
expr_stmt|;
name|pGC
operator|->
name|funcs
operator|=
operator|&
name|mfbFuncs
expr_stmt|;
comment|/* mfb wants to translate before scan convesion */
name|pGC
operator|->
name|miTranslate
operator|=
literal|1
expr_stmt|;
name|pPriv
operator|=
operator|(
name|mfbPrivGC
operator|*
operator|)
operator|(
name|pGC
operator|->
name|devPrivates
index|[
name|mfbGCPrivateIndex
index|]
operator|.
name|ptr
operator|)
expr_stmt|;
name|pPriv
operator|->
name|rop
operator|=
name|mfbReduceRop
argument_list|(
name|pGC
operator|->
name|alu
argument_list|,
name|pGC
operator|->
name|fgPixel
argument_list|)
expr_stmt|;
name|pPriv
operator|->
name|fExpose
operator|=
name|TRUE
expr_stmt|;
name|pPriv
operator|->
name|pRotatedPixmap
operator|=
name|NullPixmap
expr_stmt|;
name|pPriv
operator|->
name|freeCompClip
operator|=
name|FALSE
expr_stmt|;
name|pPriv
operator|->
name|FillArea
operator|=
name|mfbSolidInvertArea
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|void
name|mfbChangeGC
parameter_list|(
name|pGC
parameter_list|,
name|mask
parameter_list|)
name|GC
modifier|*
name|pGC
decl_stmt|;
name|BITS32
name|mask
decl_stmt|;
block|{
return|return;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|void
name|mfbCopyGC
parameter_list|(
name|pGCSrc
parameter_list|,
name|changes
parameter_list|,
name|pGCDst
parameter_list|)
name|GCPtr
name|pGCSrc
decl_stmt|;
name|Mask
name|changes
decl_stmt|;
name|GCPtr
name|pGCDst
decl_stmt|;
block|{
return|return;
block|}
end_function

begin_function
name|void
name|mfbDestroyGC
parameter_list|(
name|pGC
parameter_list|)
name|GC
modifier|*
name|pGC
decl_stmt|;
block|{
name|mfbPrivGC
modifier|*
name|pPriv
decl_stmt|;
name|pPriv
operator|=
operator|(
name|mfbPrivGC
operator|*
operator|)
operator|(
name|pGC
operator|->
name|devPrivates
index|[
name|mfbGCPrivateIndex
index|]
operator|.
name|ptr
operator|)
expr_stmt|;
if|if
condition|(
name|pPriv
operator|->
name|pRotatedPixmap
condition|)
name|mfbDestroyPixmap
argument_list|(
name|pPriv
operator|->
name|pRotatedPixmap
argument_list|)
expr_stmt|;
if|if
condition|(
name|pPriv
operator|->
name|freeCompClip
condition|)
call|(
modifier|*
name|pGC
operator|->
name|pScreen
operator|->
name|RegionDestroy
call|)
argument_list|(
name|pPriv
operator|->
name|pCompositeClip
argument_list|)
expr_stmt|;
name|mfbDestroyOps
argument_list|(
name|pGC
operator|->
name|ops
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * create a private op array for a gc  */
end_comment

begin_function
specifier|static
name|GCOps
modifier|*
name|mfbCreateOps
parameter_list|(
name|prototype
parameter_list|)
name|GCOps
modifier|*
name|prototype
decl_stmt|;
block|{
name|GCOps
modifier|*
name|ret
decl_stmt|;
specifier|extern
name|Bool
name|Must_have_memory
decl_stmt|;
comment|/* XXX */
name|Must_have_memory
operator|=
name|TRUE
expr_stmt|;
name|ret
operator|=
operator|(
name|GCOps
operator|*
operator|)
name|xalloc
argument_list|(
sizeof|sizeof
expr|*
name|ret
argument_list|)
expr_stmt|;
comment|/* XXX */
name|Must_have_memory
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
operator|!
name|ret
condition|)
return|return
literal|0
return|;
operator|*
name|ret
operator|=
operator|*
name|prototype
expr_stmt|;
name|ret
operator|->
name|devPrivate
operator|.
name|val
operator|=
literal|1
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|mfbDestroyOps
parameter_list|(
name|ops
parameter_list|)
name|GCOps
modifier|*
name|ops
decl_stmt|;
block|{
if|if
condition|(
name|ops
operator|->
name|devPrivate
operator|.
name|val
condition|)
name|xfree
argument_list|(
name|ops
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Clipping conventions 	if the drawable is a window 	    CT_REGION ==> pCompositeClip really is the composite 	    CT_other ==> pCompositeClip is the window clip region 	if the drawable is a pixmap 	    CT_REGION ==> pCompositeClip is the translated client region 		clipped to the pixmap boundary 	    CT_other ==> pCompositeClip is the pixmap bounding box */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|void
name|mfbValidateGC
parameter_list|(
name|pGC
parameter_list|,
name|changes
parameter_list|,
name|pDrawable
parameter_list|)
specifier|register
name|GCPtr
name|pGC
decl_stmt|;
name|Mask
name|changes
decl_stmt|;
name|DrawablePtr
name|pDrawable
decl_stmt|;
block|{
specifier|register
name|mfbPrivGCPtr
name|devPriv
decl_stmt|;
name|WindowPtr
name|pWin
decl_stmt|;
name|int
name|mask
decl_stmt|;
comment|/* stateChanges */
name|int
name|index
decl_stmt|;
comment|/* used for stepping through bitfields */
name|int
name|xrot
decl_stmt|,
name|yrot
decl_stmt|;
comment|/* rotations for tile and stipple pattern */
name|int
name|rrop
decl_stmt|;
comment|/* reduced rasterop */
comment|/* flags for changing the proc vector  				   and updating things in devPriv 				*/
name|int
name|new_rotate
decl_stmt|,
name|new_rrop
decl_stmt|,
name|new_line
decl_stmt|,
name|new_text
decl_stmt|,
name|new_fill
decl_stmt|;
name|DDXPointRec
name|oldOrg
decl_stmt|;
comment|/* origin of thing GC was last used with */
name|oldOrg
operator|=
name|pGC
operator|->
name|lastWinOrg
expr_stmt|;
name|pGC
operator|->
name|lastWinOrg
operator|.
name|x
operator|=
name|pDrawable
operator|->
name|x
expr_stmt|;
name|pGC
operator|->
name|lastWinOrg
operator|.
name|y
operator|=
name|pDrawable
operator|->
name|y
expr_stmt|;
if|if
condition|(
name|pDrawable
operator|->
name|type
operator|==
name|DRAWABLE_WINDOW
condition|)
name|pWin
operator|=
operator|(
name|WindowPtr
operator|)
name|pDrawable
expr_stmt|;
else|else
name|pWin
operator|=
operator|(
name|WindowPtr
operator|)
name|NULL
expr_stmt|;
comment|/* we need to re-rotate the tile if the previous window/pixmap        origin (oldOrg) differs from the new window/pixmap origin        (pGC->lastWinOrg)     */
name|new_rotate
operator|=
operator|(
name|oldOrg
operator|.
name|x
operator|!=
name|pGC
operator|->
name|lastWinOrg
operator|.
name|x
operator|)
operator|||
operator|(
name|oldOrg
operator|.
name|y
operator|!=
name|pGC
operator|->
name|lastWinOrg
operator|.
name|y
operator|)
expr_stmt|;
name|devPriv
operator|=
operator|(
call|(
name|mfbPrivGCPtr
call|)
argument_list|(
name|pGC
operator|->
name|devPrivates
index|[
name|mfbGCPrivateIndex
index|]
operator|.
name|ptr
argument_list|)
operator|)
expr_stmt|;
comment|/* 	if the client clip is different or moved OR 	the subwindowMode has changed OR 	the window's clip has changed since the last validation 	we need to recompute the composite clip     */
if|if
condition|(
operator|(
name|changes
operator|&
operator|(
name|GCClipXOrigin
operator||
name|GCClipYOrigin
operator||
name|GCClipMask
operator||
name|GCSubwindowMode
operator|)
operator|)
operator|||
operator|(
name|pDrawable
operator|->
name|serialNumber
operator|!=
operator|(
name|pGC
operator|->
name|serialNumber
operator|&
name|DRAWABLE_SERIAL_BITS
operator|)
operator|)
condition|)
block|{
name|ScreenPtr
name|pScreen
init|=
name|pGC
operator|->
name|pScreen
decl_stmt|;
if|if
condition|(
name|pWin
condition|)
block|{
name|Bool
name|freeTmpClip
decl_stmt|,
name|freeCompClip
decl_stmt|;
name|RegionPtr
name|pregWin
decl_stmt|;
comment|/* clip for this window, without 					   client clip */
if|if
condition|(
name|pGC
operator|->
name|subWindowMode
operator|==
name|IncludeInferiors
condition|)
block|{
name|pregWin
operator|=
name|NotClippedByChildren
argument_list|(
name|pWin
argument_list|)
expr_stmt|;
name|freeTmpClip
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
name|pregWin
operator|=
operator|&
name|pWin
operator|->
name|clipList
expr_stmt|;
name|freeTmpClip
operator|=
name|FALSE
expr_stmt|;
block|}
name|freeCompClip
operator|=
name|devPriv
operator|->
name|freeCompClip
expr_stmt|;
comment|/* if there is no client clip, we can get by with 	       just keeping the pointer we got, and remembering 	       whether or not should destroy (or maybe re-use) 	       it later.  this way, we avoid unnecessary copying 	       of regions.  (this wins especially if many clients clip 	       by children and have no client clip.) 	    */
if|if
condition|(
name|pGC
operator|->
name|clientClipType
operator|==
name|CT_NONE
condition|)
block|{
if|if
condition|(
name|freeCompClip
condition|)
call|(
modifier|*
name|pScreen
operator|->
name|RegionDestroy
call|)
argument_list|(
name|devPriv
operator|->
name|pCompositeClip
argument_list|)
expr_stmt|;
name|devPriv
operator|->
name|pCompositeClip
operator|=
name|pregWin
expr_stmt|;
name|devPriv
operator|->
name|freeCompClip
operator|=
name|freeTmpClip
expr_stmt|;
block|}
else|else
block|{
comment|/* we need one 'real' region to put into the composite 		   clip. 			if pregWin and the current composite clip  		   are real, we can get rid of one. 			if the current composite clip is real and 		   pregWin isn't, intersect the client clip and 		   pregWin into the existing composite clip. 			if pregWin is real and the current composite 		   clip isn't, intersect pregWin with the client clip 		   and replace the composite clip with it. 			if neither is real, create a new region and 		   do the intersection into it. 		*/
call|(
modifier|*
name|pScreen
operator|->
name|TranslateRegion
call|)
argument_list|(
name|pGC
operator|->
name|clientClip
argument_list|,
name|pDrawable
operator|->
name|x
operator|+
name|pGC
operator|->
name|clipOrg
operator|.
name|x
argument_list|,
name|pDrawable
operator|->
name|y
operator|+
name|pGC
operator|->
name|clipOrg
operator|.
name|y
argument_list|)
expr_stmt|;
if|if
condition|(
name|freeCompClip
condition|)
block|{
call|(
modifier|*
name|pScreen
operator|->
name|Intersect
call|)
argument_list|(
name|devPriv
operator|->
name|pCompositeClip
argument_list|,
name|pregWin
argument_list|,
name|pGC
operator|->
name|clientClip
argument_list|)
expr_stmt|;
if|if
condition|(
name|freeTmpClip
condition|)
call|(
modifier|*
name|pScreen
operator|->
name|RegionDestroy
call|)
argument_list|(
name|pregWin
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|freeTmpClip
condition|)
block|{
call|(
modifier|*
name|pScreen
operator|->
name|Intersect
call|)
argument_list|(
name|pregWin
argument_list|,
name|pregWin
argument_list|,
name|pGC
operator|->
name|clientClip
argument_list|)
expr_stmt|;
name|devPriv
operator|->
name|pCompositeClip
operator|=
name|pregWin
expr_stmt|;
block|}
else|else
block|{
name|devPriv
operator|->
name|pCompositeClip
operator|=
call|(
modifier|*
name|pScreen
operator|->
name|RegionCreate
call|)
argument_list|(
name|NullBox
argument_list|,
literal|0
argument_list|)
expr_stmt|;
call|(
modifier|*
name|pScreen
operator|->
name|Intersect
call|)
argument_list|(
name|devPriv
operator|->
name|pCompositeClip
argument_list|,
name|pregWin
argument_list|,
name|pGC
operator|->
name|clientClip
argument_list|)
expr_stmt|;
block|}
name|devPriv
operator|->
name|freeCompClip
operator|=
name|TRUE
expr_stmt|;
call|(
modifier|*
name|pScreen
operator|->
name|TranslateRegion
call|)
argument_list|(
name|pGC
operator|->
name|clientClip
argument_list|,
operator|-
operator|(
name|pDrawable
operator|->
name|x
operator|+
name|pGC
operator|->
name|clipOrg
operator|.
name|x
operator|)
argument_list|,
operator|-
operator|(
name|pDrawable
operator|->
name|y
operator|+
name|pGC
operator|->
name|clipOrg
operator|.
name|y
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* end of composite clip for a window */
else|else
block|{
name|BoxRec
name|pixbounds
decl_stmt|;
comment|/* XXX should we translate by drawable.x/y here ? */
name|pixbounds
operator|.
name|x1
operator|=
literal|0
expr_stmt|;
name|pixbounds
operator|.
name|y1
operator|=
literal|0
expr_stmt|;
name|pixbounds
operator|.
name|x2
operator|=
name|pDrawable
operator|->
name|width
expr_stmt|;
name|pixbounds
operator|.
name|y2
operator|=
name|pDrawable
operator|->
name|height
expr_stmt|;
if|if
condition|(
name|devPriv
operator|->
name|freeCompClip
condition|)
call|(
modifier|*
name|pScreen
operator|->
name|RegionReset
call|)
argument_list|(
name|devPriv
operator|->
name|pCompositeClip
argument_list|,
operator|&
name|pixbounds
argument_list|)
expr_stmt|;
else|else
block|{
name|devPriv
operator|->
name|freeCompClip
operator|=
name|TRUE
expr_stmt|;
name|devPriv
operator|->
name|pCompositeClip
operator|=
call|(
modifier|*
name|pScreen
operator|->
name|RegionCreate
call|)
argument_list|(
operator|&
name|pixbounds
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pGC
operator|->
name|clientClipType
operator|==
name|CT_REGION
condition|)
block|{
call|(
modifier|*
name|pScreen
operator|->
name|TranslateRegion
call|)
argument_list|(
name|devPriv
operator|->
name|pCompositeClip
argument_list|,
operator|-
name|pGC
operator|->
name|clipOrg
operator|.
name|x
argument_list|,
operator|-
name|pGC
operator|->
name|clipOrg
operator|.
name|y
argument_list|)
expr_stmt|;
call|(
modifier|*
name|pScreen
operator|->
name|Intersect
call|)
argument_list|(
name|devPriv
operator|->
name|pCompositeClip
argument_list|,
name|devPriv
operator|->
name|pCompositeClip
argument_list|,
name|pGC
operator|->
name|clientClip
argument_list|)
expr_stmt|;
call|(
modifier|*
name|pScreen
operator|->
name|TranslateRegion
call|)
argument_list|(
name|devPriv
operator|->
name|pCompositeClip
argument_list|,
name|pGC
operator|->
name|clipOrg
operator|.
name|x
argument_list|,
name|pGC
operator|->
name|clipOrg
operator|.
name|y
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* end of composite clip for pixmap */
block|}
name|new_rrop
operator|=
name|FALSE
expr_stmt|;
name|new_line
operator|=
name|FALSE
expr_stmt|;
name|new_text
operator|=
name|FALSE
expr_stmt|;
name|new_fill
operator|=
name|FALSE
expr_stmt|;
name|mask
operator|=
name|changes
expr_stmt|;
while|while
condition|(
name|mask
condition|)
block|{
name|index
operator|=
name|lowbit
argument_list|(
name|mask
argument_list|)
expr_stmt|;
name|mask
operator|&=
operator|~
name|index
expr_stmt|;
comment|/* this switch acculmulates a list of which procedures 	   might have to change due to changes in the GC.  in 	   some cases (e.g. changing one 16 bit tile for another) 	   we might not really need a change, but the code is 	   being paranoid. 	   this sort of batching wins if, for example, the alu 	   and the font have been changed, or any other pair 	   of items that both change the same thing. 	*/
switch|switch
condition|(
name|index
condition|)
block|{
case|case
name|GCFunction
case|:
case|case
name|GCForeground
case|:
name|new_rrop
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|GCPlaneMask
case|:
break|break;
case|case
name|GCBackground
case|:
name|new_rrop
operator|=
name|TRUE
expr_stmt|;
comment|/* for opaque stipples */
break|break;
case|case
name|GCLineStyle
case|:
case|case
name|GCLineWidth
case|:
case|case
name|GCJoinStyle
case|:
name|new_line
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|GCCapStyle
case|:
break|break;
case|case
name|GCFillStyle
case|:
name|new_fill
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|GCFillRule
case|:
break|break;
case|case
name|GCTile
case|:
if|if
condition|(
name|pGC
operator|->
name|tileIsPixel
condition|)
break|break;
name|new_rotate
operator|=
name|TRUE
expr_stmt|;
name|new_fill
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|GCStipple
case|:
if|if
condition|(
name|pGC
operator|->
name|stipple
operator|==
operator|(
name|PixmapPtr
operator|)
name|NULL
condition|)
break|break;
name|new_rotate
operator|=
name|TRUE
expr_stmt|;
name|new_fill
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|GCTileStipXOrigin
case|:
name|new_rotate
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|GCTileStipYOrigin
case|:
name|new_rotate
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|GCFont
case|:
name|new_text
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|GCSubwindowMode
case|:
break|break;
case|case
name|GCGraphicsExposures
case|:
break|break;
case|case
name|GCClipXOrigin
case|:
break|break;
case|case
name|GCClipYOrigin
case|:
break|break;
case|case
name|GCClipMask
case|:
break|break;
case|case
name|GCDashOffset
case|:
break|break;
case|case
name|GCDashList
case|:
break|break;
case|case
name|GCArcMode
case|:
break|break;
default|default:
break|break;
block|}
block|}
comment|/* deal with the changes we've collected .        new_rrop must be done first because subsequent things        depend on it.     */
if|if
condition|(
name|new_rotate
operator|||
name|new_fill
condition|)
block|{
name|Bool
name|new_pix
init|=
name|FALSE
decl_stmt|;
comment|/* figure out how much to rotate */
name|xrot
operator|=
name|pGC
operator|->
name|patOrg
operator|.
name|x
expr_stmt|;
name|yrot
operator|=
name|pGC
operator|->
name|patOrg
operator|.
name|y
expr_stmt|;
name|xrot
operator|+=
name|pDrawable
operator|->
name|x
expr_stmt|;
name|yrot
operator|+=
name|pDrawable
operator|->
name|y
expr_stmt|;
switch|switch
condition|(
name|pGC
operator|->
name|fillStyle
condition|)
block|{
case|case
name|FillTiled
case|:
comment|/* copy current tile and stipple */
if|if
condition|(
operator|!
name|pGC
operator|->
name|tileIsPixel
operator|&&
operator|(
name|pGC
operator|->
name|tile
operator|.
name|pixmap
operator|->
name|drawable
operator|.
name|width
operator|<=
literal|32
operator|)
operator|&&
operator|!
operator|(
name|pGC
operator|->
name|tile
operator|.
name|pixmap
operator|->
name|drawable
operator|.
name|width
operator|&
operator|(
name|pGC
operator|->
name|tile
operator|.
name|pixmap
operator|->
name|drawable
operator|.
name|width
operator|-
literal|1
operator|)
operator|)
condition|)
block|{
name|mfbCopyRotatePixmap
argument_list|(
name|pGC
operator|->
name|tile
operator|.
name|pixmap
argument_list|,
operator|&
name|devPriv
operator|->
name|pRotatedPixmap
argument_list|,
name|xrot
argument_list|,
name|yrot
argument_list|)
expr_stmt|;
name|new_pix
operator|=
name|TRUE
expr_stmt|;
block|}
break|break;
case|case
name|FillStippled
case|:
case|case
name|FillOpaqueStippled
case|:
if|if
condition|(
name|pGC
operator|->
name|stipple
operator|&&
operator|(
name|pGC
operator|->
name|stipple
operator|->
name|drawable
operator|.
name|width
operator|<=
literal|32
operator|)
operator|&&
operator|!
operator|(
name|pGC
operator|->
name|stipple
operator|->
name|drawable
operator|.
name|width
operator|&
operator|(
name|pGC
operator|->
name|stipple
operator|->
name|drawable
operator|.
name|width
operator|-
literal|1
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|pGC
operator|->
name|stipple
operator|==
name|pGC
operator|->
name|pScreen
operator|->
name|PixmapPerDepth
index|[
literal|0
index|]
condition|)
block|{
if|if
condition|(
name|pGC
operator|->
name|stipple
operator|->
name|drawable
operator|.
name|width
operator|!=
literal|32
condition|)
name|mfbPadPixmap
argument_list|(
name|pGC
operator|->
name|stipple
argument_list|)
expr_stmt|;
if|if
condition|(
name|devPriv
operator|->
name|pRotatedPixmap
condition|)
name|mfbDestroyPixmap
argument_list|(
name|devPriv
operator|->
name|pRotatedPixmap
argument_list|)
expr_stmt|;
name|devPriv
operator|->
name|pRotatedPixmap
operator|=
name|pGC
operator|->
name|stipple
expr_stmt|;
operator|++
name|devPriv
operator|->
name|pRotatedPixmap
operator|->
name|refcnt
expr_stmt|;
block|}
else|else
block|{
name|mfbCopyRotatePixmap
argument_list|(
name|pGC
operator|->
name|stipple
argument_list|,
operator|&
name|devPriv
operator|->
name|pRotatedPixmap
argument_list|,
name|xrot
argument_list|,
name|yrot
argument_list|)
expr_stmt|;
block|}
name|new_pix
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
comment|/* destroy any previously rotated tile or stipple */
if|if
condition|(
operator|!
name|new_pix
operator|&&
name|devPriv
operator|->
name|pRotatedPixmap
condition|)
block|{
name|mfbDestroyPixmap
argument_list|(
name|devPriv
operator|->
name|pRotatedPixmap
argument_list|)
expr_stmt|;
name|devPriv
operator|->
name|pRotatedPixmap
operator|=
operator|(
name|PixmapPtr
operator|)
name|NULL
expr_stmt|;
block|}
block|}
comment|/*      * duck out here when the GC is unchanged      */
if|if
condition|(
operator|!
name|changes
condition|)
return|return;
if|if
condition|(
name|new_rrop
operator|||
name|new_fill
condition|)
block|{
name|rrop
operator|=
name|mfbReduceRop
argument_list|(
name|pGC
operator|->
name|alu
argument_list|,
name|pGC
operator|->
name|fgPixel
argument_list|)
expr_stmt|;
name|devPriv
operator|->
name|rop
operator|=
name|rrop
expr_stmt|;
name|new_fill
operator|=
name|TRUE
expr_stmt|;
comment|/* FillArea raster op is GC's for tile filling, 	   and the reduced rop for solid and stipple 	*/
if|if
condition|(
name|pGC
operator|->
name|fillStyle
operator|==
name|FillTiled
condition|)
name|devPriv
operator|->
name|ropFillArea
operator|=
name|pGC
operator|->
name|alu
expr_stmt|;
else|else
name|devPriv
operator|->
name|ropFillArea
operator|=
name|rrop
expr_stmt|;
comment|/* opaque stipples: 	   fg	bg	ropOpStip	fill style 	   1	0	alu		tile 	   0	1	inverseAlu	tile 	   1	1	rrop(fg, alu)	solid 	   0	0	rrop(fg, alu)	solid 	Note that rrop(fg, alu) == mfbPrivGC.rop, so we don't really need to 	compute it. 	*/
if|if
condition|(
name|pGC
operator|->
name|fillStyle
operator|==
name|FillOpaqueStippled
condition|)
block|{
if|if
condition|(
operator|(
name|pGC
operator|->
name|fgPixel
operator|&
literal|1
operator|)
operator|!=
operator|(
name|pGC
operator|->
name|bgPixel
operator|&
literal|1
operator|)
condition|)
block|{
if|if
condition|(
name|pGC
operator|->
name|fgPixel
operator|&
literal|1
condition|)
name|devPriv
operator|->
name|ropOpStip
operator|=
name|pGC
operator|->
name|alu
expr_stmt|;
else|else
name|devPriv
operator|->
name|ropOpStip
operator|=
name|InverseAlu
index|[
name|pGC
operator|->
name|alu
index|]
expr_stmt|;
block|}
else|else
name|devPriv
operator|->
name|ropOpStip
operator|=
name|rrop
expr_stmt|;
name|devPriv
operator|->
name|ropFillArea
operator|=
name|devPriv
operator|->
name|ropOpStip
expr_stmt|;
block|}
block|}
else|else
name|rrop
operator|=
name|devPriv
operator|->
name|rop
expr_stmt|;
if|if
condition|(
name|new_line
operator|||
name|new_fill
operator|||
name|new_text
condition|)
block|{
name|GCOps
modifier|*
name|newops
decl_stmt|;
if|if
condition|(
name|newops
operator|=
name|matchCommon
argument_list|(
name|pGC
argument_list|)
condition|)
block|{
if|if
condition|(
name|pGC
operator|->
name|ops
operator|->
name|devPrivate
operator|.
name|val
condition|)
name|mfbDestroyOps
argument_list|(
name|pGC
operator|->
name|ops
argument_list|)
expr_stmt|;
name|pGC
operator|->
name|ops
operator|=
name|newops
expr_stmt|;
name|new_line
operator|=
name|new_fill
operator|=
name|new_text
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|pGC
operator|->
name|ops
operator|->
name|devPrivate
operator|.
name|val
condition|)
block|{
name|pGC
operator|->
name|ops
operator|=
name|mfbCreateOps
argument_list|(
name|pGC
operator|->
name|ops
argument_list|)
expr_stmt|;
name|pGC
operator|->
name|ops
operator|->
name|devPrivate
operator|.
name|val
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|new_line
operator|||
name|new_fill
condition|)
block|{
if|if
condition|(
name|pGC
operator|->
name|lineWidth
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|pGC
operator|->
name|lineStyle
operator|==
name|LineSolid
operator|)
operator|&&
operator|(
name|pGC
operator|->
name|fillStyle
operator|==
name|FillSolid
operator|)
operator|&&
operator|(
operator|(
name|rrop
operator|==
name|RROP_WHITE
operator|)
operator|||
operator|(
name|rrop
operator|==
name|RROP_BLACK
operator|)
operator|)
condition|)
name|pGC
operator|->
name|ops
operator|->
name|PolyArc
operator|=
name|mfbZeroPolyArcSS
expr_stmt|;
else|else
name|pGC
operator|->
name|ops
operator|->
name|PolyArc
operator|=
name|miZeroPolyArc
expr_stmt|;
block|}
else|else
name|pGC
operator|->
name|ops
operator|->
name|PolyArc
operator|=
name|miPolyArc
expr_stmt|;
if|if
condition|(
name|pGC
operator|->
name|lineStyle
operator|==
name|LineSolid
condition|)
block|{
if|if
condition|(
name|pGC
operator|->
name|lineWidth
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|pGC
operator|->
name|fillStyle
operator|==
name|FillSolid
condition|)
block|{
name|pGC
operator|->
name|ops
operator|->
name|PolySegment
operator|=
name|mfbSegmentSS
expr_stmt|;
name|pGC
operator|->
name|ops
operator|->
name|Polylines
operator|=
name|mfbLineSS
expr_stmt|;
block|}
else|else
block|{
name|pGC
operator|->
name|ops
operator|->
name|PolySegment
operator|=
name|miPolySegment
expr_stmt|;
name|pGC
operator|->
name|ops
operator|->
name|Polylines
operator|=
name|miZeroLine
expr_stmt|;
block|}
block|}
else|else
block|{
name|pGC
operator|->
name|ops
operator|->
name|PolySegment
operator|=
name|miPolySegment
expr_stmt|;
name|pGC
operator|->
name|ops
operator|->
name|Polylines
operator|=
name|miWideLine
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|pGC
operator|->
name|lineWidth
operator|==
literal|0
operator|&&
name|pGC
operator|->
name|fillStyle
operator|==
name|FillSolid
condition|)
block|{
name|pGC
operator|->
name|ops
operator|->
name|Polylines
operator|=
name|mfbLineSD
expr_stmt|;
name|pGC
operator|->
name|ops
operator|->
name|PolySegment
operator|=
name|mfbSegmentSD
expr_stmt|;
block|}
else|else
block|{
name|pGC
operator|->
name|ops
operator|->
name|Polylines
operator|=
name|miWideDash
expr_stmt|;
name|pGC
operator|->
name|ops
operator|->
name|PolySegment
operator|=
name|miPolySegment
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|new_text
operator|||
name|new_fill
condition|)
block|{
if|if
condition|(
operator|(
name|pGC
operator|->
name|font
operator|)
operator|&&
operator|(
name|FONTMAXBOUNDS
argument_list|(
name|pGC
operator|->
name|font
argument_list|,
name|rightSideBearing
argument_list|)
operator|-
name|FONTMINBOUNDS
argument_list|(
name|pGC
operator|->
name|font
argument_list|,
name|leftSideBearing
argument_list|)
operator|>
literal|32
operator|||
name|FONTMINBOUNDS
argument_list|(
name|pGC
operator|->
name|font
argument_list|,
name|characterWidth
argument_list|)
operator|<
literal|0
operator|)
condition|)
block|{
name|pGC
operator|->
name|ops
operator|->
name|PolyGlyphBlt
operator|=
name|miPolyGlyphBlt
expr_stmt|;
name|pGC
operator|->
name|ops
operator|->
name|ImageGlyphBlt
operator|=
name|miImageGlyphBlt
expr_stmt|;
block|}
else|else
block|{
comment|/* special case ImageGlyphBlt for terminal emulator fonts */
if|if
condition|(
operator|(
name|pGC
operator|->
name|font
operator|)
operator|&&
name|TERMINALFONT
argument_list|(
name|pGC
operator|->
name|font
argument_list|)
operator|&&
operator|(
operator|(
name|pGC
operator|->
name|fgPixel
operator|&
literal|1
operator|)
operator|!=
operator|(
name|pGC
operator|->
name|bgPixel
operator|&
literal|1
operator|)
operator|)
condition|)
block|{
comment|/* pcc bug makes this not compile... 		pGC->ops->ImageGlyphBlt = (pGC->fgPixel& 1) ? mfbTEGlyphBltWhite : 						      mfbTEGlyphBltBlack; 		*/
if|if
condition|(
name|pGC
operator|->
name|fgPixel
operator|&
literal|1
condition|)
name|pGC
operator|->
name|ops
operator|->
name|ImageGlyphBlt
operator|=
name|mfbTEGlyphBltWhite
expr_stmt|;
else|else
name|pGC
operator|->
name|ops
operator|->
name|ImageGlyphBlt
operator|=
name|mfbTEGlyphBltBlack
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|pGC
operator|->
name|fgPixel
operator|&
literal|1
condition|)
name|pGC
operator|->
name|ops
operator|->
name|ImageGlyphBlt
operator|=
name|mfbImageGlyphBltWhite
expr_stmt|;
else|else
name|pGC
operator|->
name|ops
operator|->
name|ImageGlyphBlt
operator|=
name|mfbImageGlyphBltBlack
expr_stmt|;
block|}
comment|/* now do PolyGlyphBlt */
if|if
condition|(
name|pGC
operator|->
name|fillStyle
operator|==
name|FillSolid
operator|||
operator|(
name|pGC
operator|->
name|fillStyle
operator|==
name|FillOpaqueStippled
operator|&&
operator|(
name|pGC
operator|->
name|fgPixel
operator|&
literal|1
operator|)
operator|==
operator|(
name|pGC
operator|->
name|bgPixel
operator|&
literal|1
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|rrop
operator|==
name|RROP_WHITE
condition|)
name|pGC
operator|->
name|ops
operator|->
name|PolyGlyphBlt
operator|=
name|mfbPolyGlyphBltWhite
expr_stmt|;
elseif|else
if|if
condition|(
name|rrop
operator|==
name|RROP_BLACK
condition|)
name|pGC
operator|->
name|ops
operator|->
name|PolyGlyphBlt
operator|=
name|mfbPolyGlyphBltBlack
expr_stmt|;
elseif|else
if|if
condition|(
name|rrop
operator|==
name|RROP_INVERT
condition|)
name|pGC
operator|->
name|ops
operator|->
name|PolyGlyphBlt
operator|=
name|mfbPolyGlyphBltInvert
expr_stmt|;
else|else
name|pGC
operator|->
name|ops
operator|->
name|PolyGlyphBlt
operator|=
name|NoopDDA
expr_stmt|;
block|}
else|else
block|{
name|pGC
operator|->
name|ops
operator|->
name|PolyGlyphBlt
operator|=
name|miPolyGlyphBlt
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|new_fill
condition|)
block|{
comment|/* install a suitable fillspans and pushpixels */
name|pGC
operator|->
name|ops
operator|->
name|PushPixels
operator|=
name|mfbPushPixels
expr_stmt|;
if|if
condition|(
operator|(
name|pGC
operator|->
name|fillStyle
operator|==
name|FillSolid
operator|)
operator|||
operator|(
operator|(
name|pGC
operator|->
name|fillStyle
operator|==
name|FillOpaqueStippled
operator|)
operator|&&
operator|(
operator|(
name|pGC
operator|->
name|fgPixel
operator|&
literal|1
operator|)
operator|==
operator|(
name|pGC
operator|->
name|bgPixel
operator|&
literal|1
operator|)
operator|)
operator|)
condition|)
block|{
name|pGC
operator|->
name|ops
operator|->
name|PushPixels
operator|=
name|mfbSolidPP
expr_stmt|;
switch|switch
condition|(
name|devPriv
operator|->
name|rop
condition|)
block|{
case|case
name|RROP_WHITE
case|:
name|pGC
operator|->
name|ops
operator|->
name|FillSpans
operator|=
name|mfbWhiteSolidFS
expr_stmt|;
break|break;
case|case
name|RROP_BLACK
case|:
name|pGC
operator|->
name|ops
operator|->
name|FillSpans
operator|=
name|mfbBlackSolidFS
expr_stmt|;
break|break;
case|case
name|RROP_INVERT
case|:
name|pGC
operator|->
name|ops
operator|->
name|FillSpans
operator|=
name|mfbInvertSolidFS
expr_stmt|;
break|break;
case|case
name|RROP_NOP
case|:
name|pGC
operator|->
name|ops
operator|->
name|FillSpans
operator|=
name|NoopDDA
expr_stmt|;
break|break;
block|}
block|}
comment|/* beyond this point, opaqueStippled ==> fg != bg */
elseif|else
if|if
condition|(
operator|(
operator|(
name|pGC
operator|->
name|fillStyle
operator|==
name|FillTiled
operator|)
operator|||
operator|(
name|pGC
operator|->
name|fillStyle
operator|==
name|FillOpaqueStippled
operator|)
operator|)
operator|&&
operator|!
name|devPriv
operator|->
name|pRotatedPixmap
condition|)
block|{
name|pGC
operator|->
name|ops
operator|->
name|FillSpans
operator|=
name|mfbUnnaturalTileFS
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|pGC
operator|->
name|fillStyle
operator|==
name|FillStippled
operator|)
operator|&&
operator|!
name|devPriv
operator|->
name|pRotatedPixmap
condition|)
block|{
name|pGC
operator|->
name|ops
operator|->
name|FillSpans
operator|=
name|mfbUnnaturalStippleFS
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pGC
operator|->
name|fillStyle
operator|==
name|FillStippled
condition|)
block|{
switch|switch
condition|(
name|devPriv
operator|->
name|rop
condition|)
block|{
case|case
name|RROP_WHITE
case|:
name|pGC
operator|->
name|ops
operator|->
name|FillSpans
operator|=
name|mfbWhiteStippleFS
expr_stmt|;
break|break;
case|case
name|RROP_BLACK
case|:
name|pGC
operator|->
name|ops
operator|->
name|FillSpans
operator|=
name|mfbBlackStippleFS
expr_stmt|;
break|break;
case|case
name|RROP_INVERT
case|:
name|pGC
operator|->
name|ops
operator|->
name|FillSpans
operator|=
name|mfbInvertStippleFS
expr_stmt|;
break|break;
case|case
name|RROP_NOP
case|:
name|pGC
operator|->
name|ops
operator|->
name|FillSpans
operator|=
name|NoopDDA
expr_stmt|;
break|break;
block|}
block|}
else|else
comment|/* overload tiles to do parti-colored opaque stipples */
block|{
name|pGC
operator|->
name|ops
operator|->
name|FillSpans
operator|=
name|mfbTileFS
expr_stmt|;
block|}
if|if
condition|(
name|pGC
operator|->
name|fillStyle
operator|==
name|FillSolid
condition|)
name|pGC
operator|->
name|ops
operator|->
name|PolyFillArc
operator|=
name|mfbPolyFillArcSolid
expr_stmt|;
else|else
name|pGC
operator|->
name|ops
operator|->
name|PolyFillArc
operator|=
name|miPolyFillArc
expr_stmt|;
comment|/* the rectangle code doesn't deal with opaque stipples that 	   are two colors -- we can fool it for fg==bg, though 	 */
if|if
condition|(
operator|(
operator|(
operator|(
name|pGC
operator|->
name|fillStyle
operator|==
name|FillTiled
operator|)
operator|||
operator|(
name|pGC
operator|->
name|fillStyle
operator|==
name|FillStippled
operator|)
operator|)
operator|&&
operator|!
name|devPriv
operator|->
name|pRotatedPixmap
operator|)
operator|||
operator|(
operator|(
name|pGC
operator|->
name|fillStyle
operator|==
name|FillOpaqueStippled
operator|)
operator|&&
operator|(
operator|(
name|pGC
operator|->
name|fgPixel
operator|&
literal|1
operator|)
operator|!=
operator|(
name|pGC
operator|->
name|bgPixel
operator|&
literal|1
operator|)
operator|)
operator|)
condition|)
block|{
name|pGC
operator|->
name|ops
operator|->
name|PolyFillRect
operator|=
name|miPolyFillRect
expr_stmt|;
block|}
else|else
comment|/* deal with solids and natural stipples and tiles */
block|{
name|pGC
operator|->
name|ops
operator|->
name|PolyFillRect
operator|=
name|mfbPolyFillRect
expr_stmt|;
if|if
condition|(
operator|(
name|pGC
operator|->
name|fillStyle
operator|==
name|FillSolid
operator|)
operator|||
operator|(
operator|(
name|pGC
operator|->
name|fillStyle
operator|==
name|FillOpaqueStippled
operator|)
operator|&&
operator|(
operator|(
name|pGC
operator|->
name|fgPixel
operator|&
literal|1
operator|)
operator|==
operator|(
name|pGC
operator|->
name|bgPixel
operator|&
literal|1
operator|)
operator|)
operator|)
condition|)
block|{
switch|switch
condition|(
name|devPriv
operator|->
name|rop
condition|)
block|{
case|case
name|RROP_WHITE
case|:
name|devPriv
operator|->
name|FillArea
operator|=
name|mfbSolidWhiteArea
expr_stmt|;
break|break;
case|case
name|RROP_BLACK
case|:
name|devPriv
operator|->
name|FillArea
operator|=
name|mfbSolidBlackArea
expr_stmt|;
break|break;
case|case
name|RROP_INVERT
case|:
name|devPriv
operator|->
name|FillArea
operator|=
name|mfbSolidInvertArea
expr_stmt|;
break|break;
case|case
name|RROP_NOP
case|:
name|devPriv
operator|->
name|FillArea
operator|=
name|NoopDDA
expr_stmt|;
break|break;
block|}
block|}
elseif|else
if|if
condition|(
name|pGC
operator|->
name|fillStyle
operator|==
name|FillStippled
condition|)
block|{
switch|switch
condition|(
name|devPriv
operator|->
name|rop
condition|)
block|{
case|case
name|RROP_WHITE
case|:
name|devPriv
operator|->
name|FillArea
operator|=
name|mfbStippleWhiteArea
expr_stmt|;
break|break;
case|case
name|RROP_BLACK
case|:
name|devPriv
operator|->
name|FillArea
operator|=
name|mfbStippleBlackArea
expr_stmt|;
break|break;
case|case
name|RROP_INVERT
case|:
name|devPriv
operator|->
name|FillArea
operator|=
name|mfbStippleInvertArea
expr_stmt|;
break|break;
case|case
name|RROP_NOP
case|:
name|devPriv
operator|->
name|FillArea
operator|=
name|NoopDDA
expr_stmt|;
break|break;
block|}
block|}
else|else
comment|/* deal with tiles */
block|{
specifier|extern
name|void
name|mfbTileArea32Copy
argument_list|()
decl_stmt|,
name|mfbTileArea32General
argument_list|()
decl_stmt|;
switch|switch
condition|(
name|pGC
operator|->
name|alu
condition|)
block|{
case|case
name|GXcopy
case|:
name|devPriv
operator|->
name|FillArea
operator|=
name|mfbTileArea32Copy
expr_stmt|;
break|break;
default|default:
name|devPriv
operator|->
name|FillArea
operator|=
name|mfbTileArea32General
expr_stmt|;
break|break;
block|}
block|}
block|}
comment|/* end of natural rectangles */
block|}
comment|/* end of new_fill */
block|}
end_function

begin_comment
comment|/* table to map alu(src, dst) to alu(~src, dst) */
end_comment

begin_decl_stmt
name|int
name|InverseAlu
index|[
literal|16
index|]
init|=
block|{
name|GXclear
block|,
name|GXandInverted
block|,
name|GXnor
block|,
name|GXcopyInverted
block|,
name|GXand
block|,
name|GXnoop
block|,
name|GXequiv
block|,
name|GXorInverted
block|,
name|GXandReverse
block|,
name|GXxor
block|,
name|GXinvert
block|,
name|GXnand
block|,
name|GXcopy
block|,
name|GXor
block|,
name|GXorReverse
block|,
name|GXset
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|mfbReduceRop
parameter_list|(
name|alu
parameter_list|,
name|src
parameter_list|)
specifier|register
name|unsigned
name|char
name|alu
decl_stmt|;
specifier|register
name|Pixel
name|src
decl_stmt|;
block|{
name|int
name|rop
decl_stmt|;
if|if
condition|(
operator|(
name|src
operator|&
literal|1
operator|)
operator|==
literal|0
condition|)
comment|/* src is black */
block|{
switch|switch
condition|(
name|alu
condition|)
block|{
case|case
name|GXclear
case|:
name|rop
operator|=
name|RROP_BLACK
expr_stmt|;
break|break;
case|case
name|GXand
case|:
name|rop
operator|=
name|RROP_BLACK
expr_stmt|;
break|break;
case|case
name|GXandReverse
case|:
name|rop
operator|=
name|RROP_BLACK
expr_stmt|;
break|break;
case|case
name|GXcopy
case|:
name|rop
operator|=
name|RROP_BLACK
expr_stmt|;
break|break;
case|case
name|GXandInverted
case|:
name|rop
operator|=
name|RROP_NOP
expr_stmt|;
break|break;
case|case
name|GXnoop
case|:
name|rop
operator|=
name|RROP_NOP
expr_stmt|;
break|break;
case|case
name|GXxor
case|:
name|rop
operator|=
name|RROP_NOP
expr_stmt|;
break|break;
case|case
name|GXor
case|:
name|rop
operator|=
name|RROP_NOP
expr_stmt|;
break|break;
case|case
name|GXnor
case|:
name|rop
operator|=
name|RROP_INVERT
expr_stmt|;
break|break;
case|case
name|GXequiv
case|:
name|rop
operator|=
name|RROP_INVERT
expr_stmt|;
break|break;
case|case
name|GXinvert
case|:
name|rop
operator|=
name|RROP_INVERT
expr_stmt|;
break|break;
case|case
name|GXorReverse
case|:
name|rop
operator|=
name|RROP_INVERT
expr_stmt|;
break|break;
case|case
name|GXcopyInverted
case|:
name|rop
operator|=
name|RROP_WHITE
expr_stmt|;
break|break;
case|case
name|GXorInverted
case|:
name|rop
operator|=
name|RROP_WHITE
expr_stmt|;
break|break;
case|case
name|GXnand
case|:
name|rop
operator|=
name|RROP_WHITE
expr_stmt|;
break|break;
case|case
name|GXset
case|:
name|rop
operator|=
name|RROP_WHITE
expr_stmt|;
break|break;
block|}
block|}
else|else
comment|/* src is white */
block|{
switch|switch
condition|(
name|alu
condition|)
block|{
case|case
name|GXclear
case|:
name|rop
operator|=
name|RROP_BLACK
expr_stmt|;
break|break;
case|case
name|GXand
case|:
name|rop
operator|=
name|RROP_NOP
expr_stmt|;
break|break;
case|case
name|GXandReverse
case|:
name|rop
operator|=
name|RROP_INVERT
expr_stmt|;
break|break;
case|case
name|GXcopy
case|:
name|rop
operator|=
name|RROP_WHITE
expr_stmt|;
break|break;
case|case
name|GXandInverted
case|:
name|rop
operator|=
name|RROP_BLACK
expr_stmt|;
break|break;
case|case
name|GXnoop
case|:
name|rop
operator|=
name|RROP_NOP
expr_stmt|;
break|break;
case|case
name|GXxor
case|:
name|rop
operator|=
name|RROP_INVERT
expr_stmt|;
break|break;
case|case
name|GXor
case|:
name|rop
operator|=
name|RROP_WHITE
expr_stmt|;
break|break;
case|case
name|GXnor
case|:
name|rop
operator|=
name|RROP_BLACK
expr_stmt|;
break|break;
case|case
name|GXequiv
case|:
name|rop
operator|=
name|RROP_NOP
expr_stmt|;
break|break;
case|case
name|GXinvert
case|:
name|rop
operator|=
name|RROP_INVERT
expr_stmt|;
break|break;
case|case
name|GXorReverse
case|:
name|rop
operator|=
name|RROP_WHITE
expr_stmt|;
break|break;
case|case
name|GXcopyInverted
case|:
name|rop
operator|=
name|RROP_BLACK
expr_stmt|;
break|break;
case|case
name|GXorInverted
case|:
name|rop
operator|=
name|RROP_NOP
expr_stmt|;
break|break;
case|case
name|GXnand
case|:
name|rop
operator|=
name|RROP_INVERT
expr_stmt|;
break|break;
case|case
name|GXset
case|:
name|rop
operator|=
name|RROP_WHITE
expr_stmt|;
break|break;
block|}
block|}
return|return
name|rop
return|;
block|}
end_function

begin_function
name|void
name|mfbDestroyClip
parameter_list|(
name|pGC
parameter_list|)
name|GCPtr
name|pGC
decl_stmt|;
block|{
if|if
condition|(
name|pGC
operator|->
name|clientClipType
operator|==
name|CT_NONE
condition|)
return|return;
elseif|else
if|if
condition|(
name|pGC
operator|->
name|clientClipType
operator|==
name|CT_PIXMAP
condition|)
block|{
name|mfbDestroyPixmap
argument_list|(
call|(
name|PixmapPtr
call|)
argument_list|(
name|pGC
operator|->
name|clientClip
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* we know we'll never have a list of rectangles, since 	   ChangeClip immediately turns them into a region  	*/
call|(
modifier|*
name|pGC
operator|->
name|pScreen
operator|->
name|RegionDestroy
call|)
argument_list|(
name|pGC
operator|->
name|clientClip
argument_list|)
expr_stmt|;
block|}
name|pGC
operator|->
name|clientClip
operator|=
name|NULL
expr_stmt|;
name|pGC
operator|->
name|clientClipType
operator|=
name|CT_NONE
expr_stmt|;
block|}
end_function

begin_function
name|void
name|mfbChangeClip
parameter_list|(
name|pGC
parameter_list|,
name|type
parameter_list|,
name|pvalue
parameter_list|,
name|nrects
parameter_list|)
name|GCPtr
name|pGC
decl_stmt|;
name|unsigned
name|int
name|type
decl_stmt|;
name|pointer
name|pvalue
decl_stmt|;
name|int
name|nrects
decl_stmt|;
block|{
name|mfbDestroyClip
argument_list|(
name|pGC
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|CT_PIXMAP
condition|)
block|{
comment|/* convert the pixmap to a region */
name|pGC
operator|->
name|clientClip
operator|=
call|(
name|pointer
call|)
argument_list|(
operator|*
name|pGC
operator|->
name|pScreen
operator|->
name|BitmapToRegion
argument_list|)
argument_list|(
operator|(
name|PixmapPtr
operator|)
name|pvalue
argument_list|)
expr_stmt|;
comment|/* you wouldn't do this if you were leaving the pixmap in 	   rather than converting it. 	*/
call|(
modifier|*
name|pGC
operator|->
name|pScreen
operator|->
name|DestroyPixmap
call|)
argument_list|(
name|pvalue
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type
operator|==
name|CT_REGION
condition|)
block|{
comment|/* stuff the region in the GC */
name|pGC
operator|->
name|clientClip
operator|=
name|pvalue
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type
operator|!=
name|CT_NONE
condition|)
block|{
name|pGC
operator|->
name|clientClip
operator|=
call|(
name|pointer
call|)
argument_list|(
operator|*
name|pGC
operator|->
name|pScreen
operator|->
name|RectsToRegion
argument_list|)
argument_list|(
name|nrects
argument_list|,
operator|(
name|xRectangle
operator|*
operator|)
name|pvalue
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
name|pvalue
argument_list|)
expr_stmt|;
block|}
name|pGC
operator|->
name|clientClipType
operator|=
operator|(
name|type
operator|!=
name|CT_NONE
operator|&&
name|pGC
operator|->
name|clientClip
operator|)
condition|?
name|CT_REGION
else|:
name|CT_NONE
expr_stmt|;
name|pGC
operator|->
name|stateChanges
operator||=
name|GCClipMask
expr_stmt|;
block|}
end_function

begin_function
name|void
name|mfbCopyClip
parameter_list|(
name|pgcDst
parameter_list|,
name|pgcSrc
parameter_list|)
name|GCPtr
name|pgcDst
decl_stmt|,
name|pgcSrc
decl_stmt|;
block|{
name|RegionPtr
name|prgnNew
decl_stmt|;
switch|switch
condition|(
name|pgcSrc
operator|->
name|clientClipType
condition|)
block|{
case|case
name|CT_PIXMAP
case|:
operator|(
operator|(
name|PixmapPtr
operator|)
name|pgcSrc
operator|->
name|clientClip
operator|)
operator|->
name|refcnt
operator|++
expr_stmt|;
comment|/* Fall through !! */
case|case
name|CT_NONE
case|:
name|mfbChangeClip
argument_list|(
name|pgcDst
argument_list|,
name|pgcSrc
operator|->
name|clientClipType
argument_list|,
name|pgcSrc
operator|->
name|clientClip
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|CT_REGION
case|:
name|prgnNew
operator|=
call|(
modifier|*
name|pgcSrc
operator|->
name|pScreen
operator|->
name|RegionCreate
call|)
argument_list|(
name|NULL
argument_list|,
literal|1
argument_list|)
expr_stmt|;
call|(
modifier|*
name|pgcSrc
operator|->
name|pScreen
operator|->
name|RegionCopy
call|)
argument_list|(
name|prgnNew
argument_list|,
call|(
name|RegionPtr
call|)
argument_list|(
name|pgcSrc
operator|->
name|clientClip
argument_list|)
argument_list|)
expr_stmt|;
name|mfbChangeClip
argument_list|(
name|pgcDst
argument_list|,
name|CT_REGION
argument_list|,
operator|(
name|pointer
operator|)
name|prgnNew
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

end_unit

