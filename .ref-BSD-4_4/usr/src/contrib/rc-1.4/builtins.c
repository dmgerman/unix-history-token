begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* builtins.c: the collection of rc's builtin commands */
end_comment

begin_comment
comment|/* 	NOTE: rc's builtins do not call "rc_error" because they are 	commands, and rc errors usually arise from syntax errors. e.g., 	you probably don't want interpretation of a shell script to stop 	because of a bad umask. */
end_comment

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_include
include|#
directive|include
file|<setjmp.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|"rc.h"
end_include

begin_include
include|#
directive|include
file|"jbwrap.h"
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/resource.h>
end_include

begin_function_decl
specifier|extern
name|int
name|umask
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|void
name|b_break
argument_list|(
name|char
operator|*
operator|*
argument_list|)
decl_stmt|,
name|b_cd
argument_list|(
name|char
operator|*
operator|*
argument_list|)
decl_stmt|,
name|b_eval
argument_list|(
name|char
operator|*
operator|*
argument_list|)
decl_stmt|,
name|b_exit
argument_list|(
name|char
operator|*
operator|*
argument_list|)
decl_stmt|,
name|b_newpgrp
argument_list|(
name|char
operator|*
operator|*
argument_list|)
decl_stmt|,
name|b_return
argument_list|(
name|char
operator|*
operator|*
argument_list|)
decl_stmt|,
name|b_shift
argument_list|(
name|char
operator|*
operator|*
argument_list|)
decl_stmt|,
name|b_umask
argument_list|(
name|char
operator|*
operator|*
argument_list|)
decl_stmt|,
name|b_wait
argument_list|(
name|char
operator|*
operator|*
argument_list|)
decl_stmt|,
name|b_whatis
argument_list|(
name|char
operator|*
operator|*
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|b_limit
parameter_list|(
name|char
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|b_echo
parameter_list|(
name|char
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_struct
specifier|static
struct|struct
block|{
name|builtin_t
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
block|}
name|builtins
index|[]
init|=
block|{
block|{
name|b_break
block|,
literal|"break"
block|}
block|,
block|{
name|b_builtin
block|,
literal|"builtin"
block|}
block|,
block|{
name|b_cd
block|,
literal|"cd"
block|}
block|,
block|{
name|b_echo
block|,
literal|"echo"
block|}
block|,
block|{
name|b_eval
block|,
literal|"eval"
block|}
block|,
block|{
name|b_exec
block|,
literal|"exec"
block|}
block|,
block|{
name|b_exit
block|,
literal|"exit"
block|}
block|,
block|{
name|b_limit
block|,
literal|"limit"
block|}
block|,
block|{
name|b_newpgrp
block|,
literal|"newpgrp"
block|}
block|,
block|{
name|b_return
block|,
literal|"return"
block|}
block|,
block|{
name|b_shift
block|,
literal|"shift"
block|}
block|,
block|{
name|b_umask
block|,
literal|"umask"
block|}
block|,
block|{
name|b_wait
block|,
literal|"wait"
block|}
block|,
block|{
name|b_whatis
block|,
literal|"whatis"
block|}
block|,
block|{
name|b_dot
block|,
literal|"."
block|}
block|, }
struct|;
end_struct

begin_function
specifier|extern
name|builtin_t
modifier|*
name|isbuiltin
parameter_list|(
name|char
modifier|*
name|s
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|arraysize
argument_list|(
name|builtins
argument_list|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|streq
argument_list|(
name|builtins
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|s
argument_list|)
condition|)
return|return
name|builtins
index|[
name|i
index|]
operator|.
name|p
return|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* funcall() is the wrapper used to invoke shell functions. pushes $*, and "return" returns here. */
end_comment

begin_function
specifier|extern
name|void
name|funcall
parameter_list|(
name|char
modifier|*
modifier|*
name|av
parameter_list|)
block|{
name|Jbwrap
name|j
decl_stmt|;
name|Estack
name|e1
decl_stmt|,
name|e2
decl_stmt|;
name|Edata
name|jreturn
decl_stmt|,
name|star
decl_stmt|;
if|if
condition|(
name|setjmp
argument_list|(
name|j
operator|.
name|j
argument_list|)
condition|)
return|return;
name|starassign
argument_list|(
operator|*
name|av
argument_list|,
name|av
operator|+
literal|1
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|jreturn
operator|.
name|jb
operator|=
operator|&
name|j
expr_stmt|;
name|star
operator|.
name|name
operator|=
literal|"*"
expr_stmt|;
name|except
argument_list|(
name|eReturn
argument_list|,
name|jreturn
argument_list|,
operator|&
name|e1
argument_list|)
expr_stmt|;
name|except
argument_list|(
name|eVarstack
argument_list|,
name|star
argument_list|,
operator|&
name|e2
argument_list|)
expr_stmt|;
name|walk
argument_list|(
name|treecpy
argument_list|(
name|fnlookup
argument_list|(
operator|*
name|av
argument_list|)
argument_list|,
name|nalloc
argument_list|)
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|varrm
argument_list|(
literal|"*"
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|unexcept
argument_list|()
expr_stmt|;
comment|/* eVarstack */
name|unexcept
argument_list|()
expr_stmt|;
comment|/* eReturn */
block|}
end_function

begin_function
specifier|static
name|void
name|arg_count
parameter_list|(
name|char
modifier|*
name|name
parameter_list|)
block|{
name|fprint
argument_list|(
literal|2
argument_list|,
literal|"too many arguments to %s\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|set
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|badnum
parameter_list|(
name|char
modifier|*
name|num
parameter_list|)
block|{
name|fprint
argument_list|(
literal|2
argument_list|,
literal|"%s is a bad number\n"
argument_list|,
name|num
argument_list|)
expr_stmt|;
name|set
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* a dummy command. (exec() performs "exec" simply by not forking) */
end_comment

begin_function
specifier|extern
name|void
name|b_exec
parameter_list|(
name|char
modifier|*
modifier|*
name|av
parameter_list|)
block|{ }
end_function

begin_comment
comment|/* echo -n omits a newline. echo -- -n echos '-n' */
end_comment

begin_function
specifier|static
name|void
name|b_echo
parameter_list|(
name|char
modifier|*
modifier|*
name|av
parameter_list|)
block|{
name|char
modifier|*
name|format
init|=
literal|"%A\n"
decl_stmt|;
if|if
condition|(
operator|*
operator|++
name|av
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|streq
argument_list|(
operator|*
name|av
argument_list|,
literal|"-n"
argument_list|)
condition|)
name|format
operator|=
literal|"%A"
operator|,
name|av
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|streq
argument_list|(
operator|*
name|av
argument_list|,
literal|"--"
argument_list|)
condition|)
name|av
operator|++
expr_stmt|;
block|}
name|fprint
argument_list|(
literal|1
argument_list|,
name|format
argument_list|,
name|av
argument_list|)
expr_stmt|;
name|set
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* cd. traverse $cdpath if the directory given is not an absolute pathname */
end_comment

begin_function
specifier|static
name|void
name|b_cd
parameter_list|(
name|char
modifier|*
modifier|*
name|av
parameter_list|)
block|{
name|List
modifier|*
name|s
decl_stmt|,
name|nil
decl_stmt|;
name|char
modifier|*
name|path
init|=
name|NULL
decl_stmt|;
name|size_t
name|t
decl_stmt|,
name|pathlen
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|*
operator|++
name|av
operator|==
name|NULL
condition|)
block|{
name|s
operator|=
name|varlookup
argument_list|(
literal|"home"
argument_list|)
expr_stmt|;
operator|*
name|av
operator|=
operator|(
name|s
operator|==
name|NULL
operator|)
condition|?
literal|"/"
else|:
name|s
operator|->
name|w
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|av
index|[
literal|1
index|]
operator|!=
name|NULL
condition|)
block|{
name|arg_count
argument_list|(
literal|"cd"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|isabsolute
argument_list|(
operator|*
name|av
argument_list|)
operator|||
name|streq
argument_list|(
operator|*
name|av
argument_list|,
literal|"."
argument_list|)
operator|||
name|streq
argument_list|(
operator|*
name|av
argument_list|,
literal|".."
argument_list|)
condition|)
block|{
comment|/* absolute pathname? */
if|if
condition|(
name|chdir
argument_list|(
operator|*
name|av
argument_list|)
operator|<
literal|0
condition|)
block|{
name|set
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
name|uerror
argument_list|(
operator|*
name|av
argument_list|)
expr_stmt|;
block|}
else|else
name|set
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|s
operator|=
name|varlookup
argument_list|(
literal|"cdpath"
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
block|{
name|s
operator|=
operator|&
name|nil
expr_stmt|;
name|nil
operator|.
name|w
operator|=
literal|""
expr_stmt|;
name|nil
operator|.
name|n
operator|=
name|NULL
expr_stmt|;
block|}
do|do
block|{
if|if
condition|(
name|s
operator|!=
operator|&
name|nil
operator|&&
operator|*
name|s
operator|->
name|w
operator|!=
literal|'\0'
condition|)
block|{
name|t
operator|=
name|strlen
argument_list|(
operator|*
name|av
argument_list|)
operator|+
name|strlen
argument_list|(
name|s
operator|->
name|w
argument_list|)
operator|+
literal|2
expr_stmt|;
if|if
condition|(
name|t
operator|>
name|pathlen
condition|)
name|path
operator|=
name|nalloc
argument_list|(
name|pathlen
operator|=
name|t
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|path
argument_list|,
name|s
operator|->
name|w
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|streq
argument_list|(
name|s
operator|->
name|w
argument_list|,
literal|"/"
argument_list|)
condition|)
comment|/* "//" is special to POSIX */
name|strcat
argument_list|(
name|path
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|path
argument_list|,
operator|*
name|av
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|pathlen
operator|=
literal|0
expr_stmt|;
name|path
operator|=
operator|*
name|av
expr_stmt|;
block|}
if|if
condition|(
name|chdir
argument_list|(
name|path
argument_list|)
operator|>=
literal|0
condition|)
block|{
name|set
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|interactive
operator|&&
operator|*
name|s
operator|->
name|w
operator|!=
literal|'\0'
operator|&&
operator|!
name|streq
argument_list|(
name|s
operator|->
name|w
argument_list|,
literal|"."
argument_list|)
condition|)
name|fprint
argument_list|(
literal|1
argument_list|,
literal|"%s\n"
argument_list|,
name|path
argument_list|)
expr_stmt|;
return|return;
block|}
name|s
operator|=
name|s
operator|->
name|n
expr_stmt|;
block|}
do|while
condition|(
name|s
operator|!=
name|NULL
condition|)
do|;
name|fprint
argument_list|(
literal|2
argument_list|,
literal|"couldn't cd to %s\n"
argument_list|,
operator|*
name|av
argument_list|)
expr_stmt|;
name|set
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|b_umask
parameter_list|(
name|char
modifier|*
modifier|*
name|av
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|*
operator|++
name|av
operator|==
name|NULL
condition|)
block|{
name|set
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
name|i
operator|=
name|umask
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|umask
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|fprint
argument_list|(
literal|1
argument_list|,
literal|"0%o\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|av
index|[
literal|1
index|]
operator|==
name|NULL
condition|)
block|{
name|i
operator|=
name|o2u
argument_list|(
operator|*
name|av
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|unsigned
name|int
operator|)
name|i
operator|>
literal|0777
condition|)
block|{
name|fprint
argument_list|(
literal|2
argument_list|,
literal|"bad umask\n"
argument_list|)
expr_stmt|;
name|set
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|umask
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|set
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|arg_count
argument_list|(
literal|"umask"
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|b_exit
parameter_list|(
name|char
modifier|*
modifier|*
name|av
parameter_list|)
block|{
if|if
condition|(
operator|*
operator|++
name|av
operator|!=
name|NULL
condition|)
name|ssetstatus
argument_list|(
name|av
argument_list|)
expr_stmt|;
name|rc_exit
argument_list|(
name|getstatus
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* raise a "return" exception, i.e., return from a function. if an integer argument is present, set $status to it */
end_comment

begin_function
specifier|static
name|void
name|b_return
parameter_list|(
name|char
modifier|*
modifier|*
name|av
parameter_list|)
block|{
if|if
condition|(
operator|*
operator|++
name|av
operator|!=
name|NULL
condition|)
name|ssetstatus
argument_list|(
name|av
argument_list|)
expr_stmt|;
name|rc_raise
argument_list|(
name|eReturn
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* raise a "break" exception for breaking out of for and while loops */
end_comment

begin_function
specifier|static
name|void
name|b_break
parameter_list|(
name|char
modifier|*
modifier|*
name|av
parameter_list|)
block|{
if|if
condition|(
name|av
index|[
literal|1
index|]
operator|!=
name|NULL
condition|)
block|{
name|arg_count
argument_list|(
literal|"break"
argument_list|)
expr_stmt|;
return|return;
block|}
name|rc_raise
argument_list|(
name|eBreak
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* shift $* n places (default 1) */
end_comment

begin_function
specifier|static
name|void
name|b_shift
parameter_list|(
name|char
modifier|*
modifier|*
name|av
parameter_list|)
block|{
name|int
name|shift
init|=
operator|(
name|av
index|[
literal|1
index|]
operator|==
name|NULL
condition|?
literal|1
else|:
name|a2u
argument_list|(
name|av
index|[
literal|1
index|]
argument_list|)
operator|)
decl_stmt|;
name|List
modifier|*
name|s
decl_stmt|,
modifier|*
name|dollarzero
decl_stmt|;
if|if
condition|(
name|av
index|[
literal|1
index|]
operator|!=
name|NULL
operator|&&
name|av
index|[
literal|2
index|]
operator|!=
name|NULL
condition|)
block|{
name|arg_count
argument_list|(
literal|"shift"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|shift
operator|<
literal|0
condition|)
block|{
name|badnum
argument_list|(
name|av
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
return|return;
block|}
name|s
operator|=
name|varlookup
argument_list|(
literal|"*"
argument_list|)
operator|->
name|n
expr_stmt|;
name|dollarzero
operator|=
name|varlookup
argument_list|(
literal|"0"
argument_list|)
expr_stmt|;
while|while
condition|(
name|s
operator|!=
name|NULL
operator|&&
name|shift
operator|!=
literal|0
condition|)
block|{
name|s
operator|=
name|s
operator|->
name|n
expr_stmt|;
operator|--
name|shift
expr_stmt|;
block|}
if|if
condition|(
name|s
operator|==
name|NULL
operator|&&
name|shift
operator|!=
literal|0
condition|)
block|{
name|fprint
argument_list|(
literal|2
argument_list|,
literal|"cannot shift\n"
argument_list|)
expr_stmt|;
name|set
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|varassign
argument_list|(
literal|"*"
argument_list|,
name|append
argument_list|(
name|dollarzero
argument_list|,
name|s
argument_list|)
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|set
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* dud function */
end_comment

begin_function
specifier|extern
name|void
name|b_builtin
parameter_list|(
name|char
modifier|*
modifier|*
name|av
parameter_list|)
block|{ }
end_function

begin_comment
comment|/* wait for a given process, or all outstanding processes */
end_comment

begin_function
specifier|static
name|void
name|b_wait
parameter_list|(
name|char
modifier|*
modifier|*
name|av
parameter_list|)
block|{
name|int
name|stat
decl_stmt|,
name|pid
decl_stmt|;
if|if
condition|(
name|av
index|[
literal|1
index|]
operator|==
name|NULL
condition|)
block|{
name|waitforall
argument_list|()
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|av
index|[
literal|2
index|]
operator|!=
name|NULL
condition|)
block|{
name|arg_count
argument_list|(
literal|"wait"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|pid
operator|=
name|a2u
argument_list|(
name|av
index|[
literal|1
index|]
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|badnum
argument_list|(
name|av
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|rc_wait4
argument_list|(
name|pid
argument_list|,
operator|&
name|stat
argument_list|,
name|FALSE
argument_list|)
operator|>
literal|0
condition|)
name|setstatus
argument_list|(
name|pid
argument_list|,
name|stat
argument_list|)
expr_stmt|;
else|else
name|set
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
name|SIGCHK
expr_stmt|;
block|}
end_function

begin_comment
comment|/*    whatis without arguments prints all variables and functions. Otherwise, check to see if a name    is defined as a variable, function or pathname. */
end_comment

begin_function
specifier|static
name|void
name|b_whatis
parameter_list|(
name|char
modifier|*
modifier|*
name|av
parameter_list|)
block|{
name|bool
name|f
decl_stmt|,
name|found
decl_stmt|;
name|bool
name|ess
init|=
name|FALSE
decl_stmt|;
name|int
name|i
decl_stmt|,
name|ac
decl_stmt|,
name|c
decl_stmt|;
name|List
modifier|*
name|s
decl_stmt|;
name|Node
modifier|*
name|n
decl_stmt|;
name|char
modifier|*
name|e
decl_stmt|;
for|for
control|(
name|rc_optind
operator|=
name|ac
operator|=
literal|0
init|;
name|av
index|[
name|ac
index|]
operator|!=
name|NULL
condition|;
name|ac
operator|++
control|)
empty_stmt|;
comment|/* count the arguments for getopt */
while|while
condition|(
operator|(
name|c
operator|=
name|rc_getopt
argument_list|(
name|ac
argument_list|,
name|av
argument_list|,
literal|"s"
argument_list|)
operator|)
operator|==
literal|'s'
condition|)
name|ess
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|c
operator|!=
operator|-
literal|1
condition|)
block|{
name|set
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
return|return;
block|}
name|av
operator|+=
name|rc_optind
expr_stmt|;
if|if
condition|(
operator|*
name|av
operator|==
name|NULL
operator|&&
operator|!
name|ess
condition|)
block|{
name|whatare_all_vars
argument_list|()
expr_stmt|;
name|set
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|ess
condition|)
name|whatare_all_signals
argument_list|()
expr_stmt|;
name|found
operator|=
name|TRUE
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|av
index|[
name|i
index|]
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
block|{
name|f
operator|=
name|FALSE
expr_stmt|;
name|errno
operator|=
name|ENOENT
expr_stmt|;
if|if
condition|(
operator|(
name|s
operator|=
name|varlookup
argument_list|(
name|av
index|[
name|i
index|]
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|f
operator|=
name|TRUE
expr_stmt|;
name|prettyprint_var
argument_list|(
literal|1
argument_list|,
name|av
index|[
name|i
index|]
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|n
operator|=
name|fnlookup
argument_list|(
name|av
index|[
name|i
index|]
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|f
operator|=
name|TRUE
expr_stmt|;
name|prettyprint_fn
argument_list|(
literal|1
argument_list|,
name|av
index|[
name|i
index|]
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|isbuiltin
argument_list|(
name|av
index|[
name|i
index|]
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|f
operator|=
name|TRUE
expr_stmt|;
name|fprint
argument_list|(
literal|1
argument_list|,
literal|"builtin %s\n"
argument_list|,
name|av
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|e
operator|=
name|which
argument_list|(
name|av
index|[
name|i
index|]
argument_list|,
name|FALSE
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|f
operator|=
name|TRUE
expr_stmt|;
name|fprint
argument_list|(
literal|1
argument_list|,
literal|"%s\n"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|f
condition|)
block|{
name|found
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|errno
operator|!=
name|ENOENT
condition|)
name|uerror
argument_list|(
name|av
index|[
name|i
index|]
argument_list|)
expr_stmt|;
else|else
name|fprint
argument_list|(
literal|2
argument_list|,
literal|"%s not found\n"
argument_list|,
name|av
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
name|set
argument_list|(
name|found
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* push a string to be eval'ed onto the input stack. evaluate it */
end_comment

begin_function
specifier|static
name|void
name|b_eval
parameter_list|(
name|char
modifier|*
modifier|*
name|av
parameter_list|)
block|{
name|bool
name|i
init|=
name|interactive
decl_stmt|;
if|if
condition|(
name|av
index|[
literal|1
index|]
operator|==
name|NULL
condition|)
return|return;
name|interactive
operator|=
name|FALSE
expr_stmt|;
name|pushstring
argument_list|(
name|av
operator|+
literal|1
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|/* don't reset line numbers on noninteractive eval */
name|doit
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
name|interactive
operator|=
name|i
expr_stmt|;
block|}
end_function

begin_comment
comment|/*    push a file to be interpreted onto the input stack. with "-i" treat this as an interactive    input source. */
end_comment

begin_function
specifier|extern
name|void
name|b_dot
parameter_list|(
name|char
modifier|*
modifier|*
name|av
parameter_list|)
block|{
name|int
name|fd
decl_stmt|;
name|bool
name|old_i
init|=
name|interactive
decl_stmt|,
name|i
init|=
name|FALSE
decl_stmt|;
name|Estack
name|e
decl_stmt|;
name|Edata
name|star
decl_stmt|;
name|av
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|av
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
name|streq
argument_list|(
operator|*
name|av
argument_list|,
literal|"-i"
argument_list|)
condition|)
block|{
name|av
operator|++
expr_stmt|;
name|i
operator|=
name|TRUE
expr_stmt|;
block|}
if|if
condition|(
name|dasheye
condition|)
block|{
comment|/* rc -i file has to do the right thing. reset the dasheye state to FALSE, though. */
name|dasheye
operator|=
name|FALSE
expr_stmt|;
name|i
operator|=
name|TRUE
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|av
operator|==
name|NULL
condition|)
return|return;
name|fd
operator|=
name|rc_open
argument_list|(
operator|*
name|av
argument_list|,
name|rFrom
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|rcrc
condition|)
comment|/* on rc -l, don't flag nonexistence of .rcrc */
name|rcrc
operator|=
name|FALSE
expr_stmt|;
else|else
block|{
name|uerror
argument_list|(
operator|*
name|av
argument_list|)
expr_stmt|;
name|set
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
name|rcrc
operator|=
name|FALSE
expr_stmt|;
name|starassign
argument_list|(
operator|*
name|av
argument_list|,
name|av
operator|+
literal|1
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|pushfd
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|interactive
operator|=
name|i
expr_stmt|;
name|star
operator|.
name|name
operator|=
literal|"*"
expr_stmt|;
name|except
argument_list|(
name|eVarstack
argument_list|,
name|star
argument_list|,
operator|&
name|e
argument_list|)
expr_stmt|;
name|doit
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
name|varrm
argument_list|(
literal|"*"
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|unexcept
argument_list|()
expr_stmt|;
comment|/* eVarstack */
name|interactive
operator|=
name|old_i
expr_stmt|;
block|}
end_function

begin_comment
comment|/* put rc into a new pgrp. Used on the NeXT where the Terminal program is broken (sigh) */
end_comment

begin_function
specifier|static
name|void
name|b_newpgrp
parameter_list|(
name|char
modifier|*
modifier|*
name|av
parameter_list|)
block|{
if|if
condition|(
name|av
index|[
literal|1
index|]
operator|!=
name|NULL
condition|)
block|{
name|arg_count
argument_list|(
literal|"newpgrp"
argument_list|)
expr_stmt|;
return|return;
block|}
name|setpgrp
argument_list|(
name|rc_pid
argument_list|,
name|rc_pid
argument_list|)
expr_stmt|;
name|ioctl
argument_list|(
literal|2
argument_list|,
name|TIOCSPGRP
argument_list|,
operator|&
name|rc_pid
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Berkeley limit support was cleaned up by Paul Haahr. */
end_comment

begin_typedef
typedef|typedef
name|struct
name|Suffix
name|Suffix
typedef|;
end_typedef

begin_struct
struct|struct
name|Suffix
block|{
specifier|const
name|Suffix
modifier|*
name|next
decl_stmt|;
name|long
name|amount
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
specifier|const
name|Suffix
name|kbsuf
init|=
block|{
name|NULL
block|,
literal|1024
block|,
literal|"k"
block|}
decl_stmt|,
name|mbsuf
init|=
block|{
operator|&
name|kbsuf
block|,
literal|1024
operator|*
literal|1024
block|,
literal|"m"
block|}
decl_stmt|,
name|gbsuf
init|=
block|{
operator|&
name|mbsuf
block|,
literal|1024
operator|*
literal|1024
operator|*
literal|1024
block|,
literal|"g"
block|}
decl_stmt|,
name|stsuf
init|=
block|{
name|NULL
block|,
literal|1
block|,
literal|"s"
block|}
decl_stmt|,
name|mtsuf
init|=
block|{
operator|&
name|stsuf
block|,
literal|60
block|,
literal|"m"
block|}
decl_stmt|,
name|htsuf
init|=
block|{
operator|&
name|mtsuf
block|,
literal|60
operator|*
literal|60
block|,
literal|"h"
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|SIZESUF
value|&gbsuf
end_define

begin_define
define|#
directive|define
name|TIMESUF
value|&htsuf
end_define

begin_define
define|#
directive|define
name|NOSUF
value|((Suffix *) NULL)
end_define

begin_comment
comment|/* for RLIMIT_NOFILE on SunOS 4.1 */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|flag
decl_stmt|;
specifier|const
name|Suffix
modifier|*
name|suffix
decl_stmt|;
block|}
name|Limit
typedef|;
end_typedef

begin_decl_stmt
specifier|static
specifier|const
name|Limit
name|limits
index|[]
init|=
block|{
block|{
literal|"cputime"
block|,
name|RLIMIT_CPU
block|,
name|TIMESUF
block|}
block|,
block|{
literal|"filesize"
block|,
name|RLIMIT_FSIZE
block|,
name|SIZESUF
block|}
block|,
block|{
literal|"datasize"
block|,
name|RLIMIT_DATA
block|,
name|SIZESUF
block|}
block|,
block|{
literal|"stacksize"
block|,
name|RLIMIT_STACK
block|,
name|SIZESUF
block|}
block|,
block|{
literal|"coredumpsize"
block|,
name|RLIMIT_CORE
block|,
name|SIZESUF
block|}
block|,
block|{
literal|"memoryuse"
block|,
name|RLIMIT_RSS
block|,
name|SIZESUF
block|}
block|,
block|{
literal|"descriptors"
block|,
name|RLIMIT_NOFILE
block|,
name|NOSUF
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|,
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|printlimit
parameter_list|(
specifier|const
name|Limit
modifier|*
name|limit
parameter_list|,
name|bool
name|hard
parameter_list|)
block|{
name|struct
name|rlimit
name|rlim
decl_stmt|;
name|long
name|lim
decl_stmt|;
name|getrlimit
argument_list|(
name|limit
operator|->
name|flag
argument_list|,
operator|&
name|rlim
argument_list|)
expr_stmt|;
if|if
condition|(
name|hard
condition|)
name|lim
operator|=
name|rlim
operator|.
name|rlim_max
expr_stmt|;
else|else
name|lim
operator|=
name|rlim
operator|.
name|rlim_cur
expr_stmt|;
if|if
condition|(
operator|(
name|unsigned
operator|)
name|lim
operator|==
operator|(
name|unsigned
operator|)
name|RLIM_INFINITY
condition|)
name|fprint
argument_list|(
literal|1
argument_list|,
literal|"%s \tunlimited\n"
argument_list|,
name|limit
operator|->
name|name
argument_list|)
expr_stmt|;
else|else
block|{
specifier|const
name|Suffix
modifier|*
name|suf
decl_stmt|;
for|for
control|(
name|suf
operator|=
name|limit
operator|->
name|suffix
init|;
name|suf
operator|!=
name|NULL
condition|;
name|suf
operator|=
name|suf
operator|->
name|next
control|)
if|if
condition|(
name|lim
operator|%
name|suf
operator|->
name|amount
operator|==
literal|0
operator|&&
operator|(
name|lim
operator|!=
literal|0
operator|||
name|suf
operator|->
name|amount
operator|>
literal|1
operator|)
condition|)
block|{
name|lim
operator|/=
name|suf
operator|->
name|amount
expr_stmt|;
break|break;
block|}
name|fprint
argument_list|(
literal|1
argument_list|,
literal|"%s \t%d%s\n"
argument_list|,
name|limit
operator|->
name|name
argument_list|,
name|lim
argument_list|,
operator|(
name|suf
operator|==
name|NULL
operator|||
name|lim
operator|==
literal|0
operator|)
condition|?
literal|""
else|:
name|suf
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|long
name|parselimit
parameter_list|(
specifier|const
name|Limit
modifier|*
name|limit
parameter_list|,
name|char
modifier|*
name|s
parameter_list|)
block|{
name|char
modifier|*
name|t
decl_stmt|;
name|int
name|len
init|=
name|strlen
argument_list|(
name|s
argument_list|)
decl_stmt|;
name|long
name|lim
init|=
literal|1
decl_stmt|;
specifier|const
name|Suffix
modifier|*
name|suf
init|=
name|limit
operator|->
name|suffix
decl_stmt|;
if|if
condition|(
name|streq
argument_list|(
name|s
argument_list|,
literal|"unlimited"
argument_list|)
condition|)
return|return
name|RLIM_INFINITY
return|;
if|if
condition|(
name|suf
operator|==
name|TIMESUF
operator|&&
operator|(
name|t
operator|=
name|strchr
argument_list|(
name|s
argument_list|,
literal|':'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
operator|*
name|t
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|lim
operator|=
literal|60
operator|*
name|a2u
argument_list|(
name|s
argument_list|)
operator|+
name|a2u
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
init|;
name|suf
operator|!=
name|NULL
condition|;
name|suf
operator|=
name|suf
operator|->
name|next
control|)
if|if
condition|(
name|streq
argument_list|(
name|suf
operator|->
name|name
argument_list|,
name|s
operator|+
name|len
operator|-
name|strlen
argument_list|(
name|suf
operator|->
name|name
argument_list|)
argument_list|)
condition|)
block|{
name|s
index|[
name|len
operator|-
name|strlen
argument_list|(
name|suf
operator|->
name|name
argument_list|)
index|]
operator|=
literal|'\0'
expr_stmt|;
name|lim
operator|*=
name|suf
operator|->
name|amount
expr_stmt|;
break|break;
block|}
name|lim
operator|*=
name|a2u
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
return|return
name|lim
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|b_limit
parameter_list|(
name|char
modifier|*
modifier|*
name|av
parameter_list|)
block|{
specifier|const
name|Limit
modifier|*
name|lp
init|=
name|limits
decl_stmt|;
name|bool
name|hard
init|=
name|FALSE
decl_stmt|;
if|if
condition|(
operator|*
operator|++
name|av
operator|!=
name|NULL
operator|&&
name|streq
argument_list|(
operator|*
name|av
argument_list|,
literal|"-h"
argument_list|)
condition|)
block|{
name|av
operator|++
expr_stmt|;
name|hard
operator|=
name|TRUE
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|av
operator|==
name|NULL
condition|)
block|{
for|for
control|(
init|;
name|lp
operator|->
name|name
operator|!=
name|NULL
condition|;
name|lp
operator|++
control|)
name|printlimit
argument_list|(
name|lp
argument_list|,
name|hard
argument_list|)
expr_stmt|;
return|return;
block|}
for|for
control|(
init|;
condition|;
name|lp
operator|++
control|)
block|{
if|if
condition|(
name|lp
operator|->
name|name
operator|==
name|NULL
condition|)
block|{
name|fprint
argument_list|(
literal|2
argument_list|,
literal|"no such limit\n"
argument_list|)
expr_stmt|;
name|set
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|streq
argument_list|(
operator|*
name|av
argument_list|,
name|lp
operator|->
name|name
argument_list|)
condition|)
break|break;
block|}
if|if
condition|(
operator|*
operator|++
name|av
operator|==
name|NULL
condition|)
name|printlimit
argument_list|(
name|lp
argument_list|,
name|hard
argument_list|)
expr_stmt|;
else|else
block|{
name|struct
name|rlimit
name|rlim
decl_stmt|;
name|long
name|pl
decl_stmt|;
name|getrlimit
argument_list|(
name|lp
operator|->
name|flag
argument_list|,
operator|&
name|rlim
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|pl
operator|=
name|parselimit
argument_list|(
name|lp
argument_list|,
operator|*
name|av
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|fprint
argument_list|(
literal|2
argument_list|,
literal|"bad limit\n"
argument_list|)
expr_stmt|;
name|set
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|hard
condition|)
name|rlim
operator|.
name|rlim_max
operator|=
name|pl
expr_stmt|;
else|else
name|rlim
operator|.
name|rlim_cur
operator|=
name|pl
expr_stmt|;
if|if
condition|(
name|setrlimit
argument_list|(
name|lp
operator|->
name|flag
argument_list|,
operator|&
name|rlim
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|uerror
argument_list|(
literal|"setrlimit"
argument_list|)
expr_stmt|;
name|set
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
block|}
else|else
name|set
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
block|}
block|}
end_function

end_unit

