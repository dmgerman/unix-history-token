begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*    fn.c: functions for adding and deleting functions from the symbol table.    Support for signal handlers is also found here. */
end_comment

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|"rc.h"
end_include

begin_include
include|#
directive|include
file|"sigmsgs.h"
end_include

begin_decl_stmt
specifier|static
name|void
name|fn_handler
argument_list|(
name|int
argument_list|)
decl_stmt|,
name|dud_handler
argument_list|(
name|int
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bool
name|runexit
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|Node
modifier|*
name|handlers
index|[
name|NUMOFSIGNALS
index|]
decl_stmt|,
name|null
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
function_decl|(
modifier|*
name|def_sigint
function_decl|)
parameter_list|(
name|int
parameter_list|)
init|=
name|SIG_DFL
operator|,
parameter_list|(
function_decl|*def_sigquit
end_function_decl

begin_expr_stmt
unit|)
operator|(
name|int
operator|)
operator|=
name|SIG_DFL
operator|,
call|(
modifier|*
name|def_sigterm
call|)
argument_list|(
name|int
argument_list|)
operator|=
name|SIG_DFL
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*    Set signals to default values for rc. This means that interactive    shells ignore SIGTERM, etc. */
end_comment

begin_function
specifier|extern
name|void
name|inithandler
parameter_list|()
block|{
name|int
name|i
decl_stmt|;
name|null
operator|.
name|type
operator|=
name|nBody
expr_stmt|;
name|null
operator|.
name|u
index|[
literal|0
index|]
operator|.
name|p
operator|=
name|null
operator|.
name|u
index|[
literal|1
index|]
operator|.
name|p
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|NUMOFSIGNALS
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|sighandlers
index|[
name|i
index|]
operator|==
name|SIG_IGN
condition|)
name|fnassign
argument_list|(
name|signals
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* ignore incoming ignored signals */
if|if
condition|(
name|interactive
operator|||
name|sighandlers
index|[
name|SIGINT
index|]
operator|!=
name|SIG_IGN
condition|)
block|{
name|def_sigint
operator|=
name|sigint
expr_stmt|;
name|fnrm
argument_list|(
literal|"sigint"
argument_list|)
expr_stmt|;
comment|/* installs SIGINT catcher if not inherited ignored */
block|}
if|if
condition|(
operator|!
name|dashdee
condition|)
block|{
if|if
condition|(
name|interactive
operator|||
name|sighandlers
index|[
name|SIGQUIT
index|]
operator|!=
name|SIG_IGN
condition|)
block|{
name|def_sigquit
operator|=
name|dud_handler
expr_stmt|;
name|fnrm
argument_list|(
literal|"sigquit"
argument_list|)
expr_stmt|;
comment|/* "ignores" SIGQUIT unless inherited ignored */
block|}
if|if
condition|(
name|interactive
condition|)
block|{
name|def_sigterm
operator|=
name|dud_handler
expr_stmt|;
name|fnrm
argument_list|(
literal|"sigterm"
argument_list|)
expr_stmt|;
comment|/* ditto for SIGTERM */
block|}
block|}
block|}
end_function

begin_comment
comment|/* only run this in a child process! resets signals to their default values */
end_comment

begin_function
specifier|extern
name|void
name|setsigdefaults
parameter_list|(
name|bool
name|sysvbackground
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
comment|/* 	   General housekeeping: setsigdefaults happens after fork(), 	   so it's a convenient place to clean up open file descriptors. 	   (history file, scripts, etc.) 	*/
name|closefds
argument_list|()
expr_stmt|;
comment|/* 	   Restore signals to SIG_DFL, paying close attention to 	   a few quirks: SIGINT, SIGQUIT and are treated specially 	   depending on whether we are doing v7-style backgrounding 	   or not; the default action for SIGINT, SIGQUIT and SIGTERM 	   must be set to the appropriate action; finally, care must 	   be taken not to set to SIG_DFL any signals which are being 	   ignored. 	*/
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|NUMOFSIGNALS
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|sighandlers
index|[
name|i
index|]
operator|!=
name|SIG_IGN
condition|)
block|{
name|handlers
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
switch|switch
condition|(
name|i
condition|)
block|{
case|case
name|SIGINT
case|:
if|if
condition|(
name|sysvbackground
condition|)
block|{
name|def_sigint
operator|=
name|SIG_IGN
expr_stmt|;
name|fnassign
argument_list|(
literal|"sigint"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* ignore */
block|}
else|else
block|{
name|def_sigint
operator|=
name|SIG_DFL
expr_stmt|;
goto|goto
name|sigcommon
goto|;
block|}
break|break;
case|case
name|SIGQUIT
case|:
if|if
condition|(
name|sysvbackground
condition|)
block|{
name|def_sigquit
operator|=
name|SIG_IGN
expr_stmt|;
name|fnassign
argument_list|(
literal|"sigquit"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* ignore */
block|}
else|else
block|{
name|def_sigquit
operator|=
name|SIG_DFL
expr_stmt|;
goto|goto
name|sigcommon
goto|;
block|}
break|break;
case|case
name|SIGTERM
case|:
name|def_sigterm
operator|=
name|SIG_DFL
expr_stmt|;
comment|/* FALLTHROUGH */
name|sigcommon
label|:
default|default:
if|if
condition|(
name|sighandlers
index|[
name|i
index|]
operator|!=
name|SIG_DFL
condition|)
block|{
name|rc_signal
argument_list|(
name|i
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
name|delete_fn
argument_list|(
name|signals
index|[
name|i
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|delete_fn
argument_list|(
literal|"sigexit"
argument_list|)
expr_stmt|;
name|runexit
operator|=
name|FALSE
expr_stmt|;
comment|/* No sigexit on subshells */
block|}
end_function

begin_comment
comment|/* rc's exit. if runexit is set, run the sigexit function. */
end_comment

begin_function
specifier|extern
name|void
name|rc_exit
parameter_list|(
name|int
name|stat
parameter_list|)
block|{
specifier|static
name|char
modifier|*
name|sigexit
index|[
literal|2
index|]
init|=
block|{
literal|"sigexit"
block|,
name|NULL
block|}
decl_stmt|;
if|if
condition|(
name|runexit
condition|)
block|{
name|runexit
operator|=
name|FALSE
expr_stmt|;
name|funcall
argument_list|(
name|sigexit
argument_list|)
expr_stmt|;
name|stat
operator|=
name|getstatus
argument_list|()
expr_stmt|;
block|}
name|exit
argument_list|(
name|stat
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The signal handler for all functions. calls walk() */
end_comment

begin_function
specifier|static
name|void
name|fn_handler
parameter_list|(
name|int
name|s
parameter_list|)
block|{
name|List
modifier|*
name|dollarzero
decl_stmt|;
name|Estack
name|e
decl_stmt|;
name|Edata
name|star
decl_stmt|;
name|int
name|olderrno
decl_stmt|;
if|if
condition|(
name|s
operator|<
literal|1
operator|||
name|s
operator|>=
name|NUMOFSIGNALS
condition|)
name|panic
argument_list|(
literal|"unknown signal"
argument_list|)
expr_stmt|;
name|olderrno
operator|=
name|errno
expr_stmt|;
name|dollarzero
operator|=
name|nnew
argument_list|(
name|List
argument_list|)
expr_stmt|;
name|dollarzero
operator|->
name|w
operator|=
name|signals
index|[
name|s
index|]
operator|.
name|name
expr_stmt|;
name|dollarzero
operator|->
name|n
operator|=
name|NULL
expr_stmt|;
name|varassign
argument_list|(
literal|"*"
argument_list|,
name|dollarzero
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|star
operator|.
name|name
operator|=
literal|"*"
expr_stmt|;
name|except
argument_list|(
name|eVarstack
argument_list|,
name|star
argument_list|,
operator|&
name|e
argument_list|)
expr_stmt|;
name|walk
argument_list|(
name|handlers
index|[
name|s
index|]
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|varrm
argument_list|(
literal|"*"
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|unexcept
argument_list|()
expr_stmt|;
comment|/* eVarstack */
name|errno
operator|=
name|olderrno
expr_stmt|;
block|}
end_function

begin_comment
comment|/* A dud signal handler for SIGQUIT and SIGTERM */
end_comment

begin_function
specifier|static
name|void
name|dud_handler
parameter_list|(
name|int
name|s
parameter_list|)
block|{ }
end_function

begin_comment
comment|/*    Assign a function in Node form. Check to see if the function is also    a signal, and set the signal vectors appropriately. */
end_comment

begin_function
specifier|extern
name|void
name|fnassign
parameter_list|(
name|char
modifier|*
name|name
parameter_list|,
name|Node
modifier|*
name|def
parameter_list|)
block|{
name|Node
modifier|*
name|newdef
init|=
name|treecpy
argument_list|(
name|def
operator|==
name|NULL
condition|?
operator|&
name|null
else|:
name|def
argument_list|,
name|ealloc
argument_list|)
decl_stmt|;
comment|/* important to do the treecopy first */
name|Function
modifier|*
name|new
init|=
name|get_fn_place
argument_list|(
name|name
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
name|new
operator|->
name|def
operator|=
name|newdef
expr_stmt|;
name|new
operator|->
name|extdef
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|name
argument_list|,
literal|"sig"
argument_list|,
name|conststrlen
argument_list|(
literal|"sig"
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* slight optimization */
if|if
condition|(
name|streq
argument_list|(
name|name
argument_list|,
literal|"sigexit"
argument_list|)
condition|)
name|runexit
operator|=
name|TRUE
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|NUMOFSIGNALS
condition|;
name|i
operator|++
control|)
comment|/* zero is a bogus signal */
if|if
condition|(
name|streq
argument_list|(
name|signals
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|name
argument_list|)
condition|)
block|{
name|handlers
index|[
name|i
index|]
operator|=
name|newdef
expr_stmt|;
if|if
condition|(
name|def
operator|==
name|NULL
condition|)
name|rc_signal
argument_list|(
name|i
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
else|else
name|rc_signal
argument_list|(
name|i
argument_list|,
name|fn_handler
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Assign a function from the environment. Store just the external representation */
end_comment

begin_function
specifier|extern
name|void
name|fnassign_string
parameter_list|(
name|char
modifier|*
name|extdef
parameter_list|)
block|{
name|char
modifier|*
name|name
init|=
name|get_name
argument_list|(
name|extdef
operator|+
literal|3
argument_list|)
decl_stmt|;
comment|/* +3 to skip over "fn_" */
name|Function
modifier|*
name|new
decl_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
return|return;
name|new
operator|=
name|get_fn_place
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|new
operator|->
name|def
operator|=
name|NULL
expr_stmt|;
name|new
operator|->
name|extdef
operator|=
name|ecpy
argument_list|(
name|extdef
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return a function in Node form, evaluating an entry from the environment if necessary */
end_comment

begin_function
specifier|extern
name|Node
modifier|*
name|fnlookup
parameter_list|(
name|char
modifier|*
name|name
parameter_list|)
block|{
name|Function
modifier|*
name|look
init|=
name|lookup_fn
argument_list|(
name|name
argument_list|)
decl_stmt|;
name|Node
modifier|*
name|ret
decl_stmt|;
if|if
condition|(
name|look
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
comment|/* not found */
if|if
condition|(
name|look
operator|->
name|def
operator|!=
name|NULL
condition|)
return|return
name|look
operator|->
name|def
return|;
if|if
condition|(
name|look
operator|->
name|extdef
operator|==
name|NULL
condition|)
comment|/* function was set to null, e.g., fn foo {} */
return|return
operator|&
name|null
return|;
name|ret
operator|=
name|parse_fn
argument_list|(
name|name
argument_list|,
name|look
operator|->
name|extdef
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|NULL
condition|)
block|{
name|efree
argument_list|(
name|look
operator|->
name|extdef
argument_list|)
expr_stmt|;
name|look
operator|->
name|extdef
operator|=
name|NULL
expr_stmt|;
return|return
operator|&
name|null
return|;
block|}
else|else
block|{
return|return
name|look
operator|->
name|def
operator|=
name|treecpy
argument_list|(
name|ret
argument_list|,
name|ealloc
argument_list|)
return|;
comment|/* Need to take it out of nalloc space */
block|}
block|}
end_function

begin_comment
comment|/* Return a function in string form (used by makeenv) */
end_comment

begin_function
specifier|extern
name|char
modifier|*
name|fnlookup_string
parameter_list|(
name|char
modifier|*
name|name
parameter_list|)
block|{
name|Function
modifier|*
name|look
init|=
name|lookup_fn
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|look
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|look
operator|->
name|extdef
operator|!=
name|NULL
condition|)
return|return
name|look
operator|->
name|extdef
return|;
return|return
name|look
operator|->
name|extdef
operator|=
name|fun2str
argument_list|(
name|name
argument_list|,
name|look
operator|->
name|def
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*    Remove a function from the symbol table. If it also defines a signal    handler, restore the signal handler to its default value. */
end_comment

begin_function
specifier|extern
name|void
name|fnrm
parameter_list|(
name|char
modifier|*
name|name
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|NUMOFSIGNALS
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|streq
argument_list|(
name|signals
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|name
argument_list|)
condition|)
block|{
name|handlers
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
switch|switch
condition|(
name|i
condition|)
block|{
case|case
name|SIGINT
case|:
name|rc_signal
argument_list|(
name|i
argument_list|,
name|def_sigint
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIGQUIT
case|:
name|rc_signal
argument_list|(
name|i
argument_list|,
name|def_sigquit
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIGTERM
case|:
name|rc_signal
argument_list|(
name|i
argument_list|,
name|def_sigterm
argument_list|)
expr_stmt|;
break|break;
default|default:
name|rc_signal
argument_list|(
name|i
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|streq
argument_list|(
name|name
argument_list|,
literal|"sigexit"
argument_list|)
condition|)
name|runexit
operator|=
name|FALSE
expr_stmt|;
name|delete_fn
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|extern
name|void
name|whatare_all_signals
parameter_list|()
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|NUMOFSIGNALS
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|*
name|signals
index|[
name|i
index|]
operator|.
name|name
operator|!=
literal|'\0'
condition|)
if|if
condition|(
name|sighandlers
index|[
name|i
index|]
operator|==
name|SIG_IGN
condition|)
name|fprint
argument_list|(
literal|1
argument_list|,
literal|"fn %s {}\n"
argument_list|,
name|signals
index|[
name|i
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|sighandlers
index|[
name|i
index|]
operator|==
name|fn_handler
condition|)
name|fprint
argument_list|(
literal|1
argument_list|,
literal|"fn %S {%T}\n"
argument_list|,
name|signals
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|handlers
index|[
name|i
index|]
argument_list|)
expr_stmt|;
else|else
name|fprint
argument_list|(
literal|1
argument_list|,
literal|"fn %s\n"
argument_list|,
name|signals
index|[
name|i
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|extern
name|void
name|prettyprint_fn
parameter_list|(
name|int
name|fd
parameter_list|,
name|char
modifier|*
name|name
parameter_list|,
name|Node
modifier|*
name|n
parameter_list|)
block|{
name|fprint
argument_list|(
name|fd
argument_list|,
literal|"fn %S {%T}\n"
argument_list|,
name|name
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

