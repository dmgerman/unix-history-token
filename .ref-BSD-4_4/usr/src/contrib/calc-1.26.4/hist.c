begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1993 David I. Bell  * Permission is granted to use, distribute, or modify this source,  * provided that this copyright notice remains intact.  *  * Adapted from code written by Stephen Rothwell.  *  * Interactive readline module.  This is called to read lines of input,  * while using emacs-like editing commands within a command stack.  * The key bindings for the editing commands are (slightly) configurable.  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<pwd.h>
end_include

begin_include
include|#
directive|include
file|"hist.h"
end_include

begin_include
include|#
directive|include
file|"terminal.h"
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|USE_TERMIOS
argument_list|)
end_if

begin_include
include|#
directive|include
file|<termios.h>
end_include

begin_define
define|#
directive|define
name|TTYSTRUCT
value|struct	termios
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* USE_SGTTY */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|USE_TERMIO
argument_list|)
end_if

begin_include
include|#
directive|include
file|<termio.h>
end_include

begin_define
define|#
directive|define
name|TTYSTRUCT
value|struct	termio
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* USE_TERMIO */
end_comment

begin_comment
comment|/* assume USE_SGTTY */
end_comment

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_define
define|#
directive|define
name|TTYSTRUCT
value|struct	sgttyb
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* USE_TERMIO */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* USE_SGTTY */
end_comment

begin_define
define|#
directive|define
name|STDIN
value|0
end_define

begin_define
define|#
directive|define
name|SAVE_SIZE
value|256
end_define

begin_comment
comment|/* size of save buffer */
end_comment

begin_define
define|#
directive|define
name|MAX_KEYS
value|60
end_define

begin_comment
comment|/* number of key bindings */
end_comment

begin_define
define|#
directive|define
name|CONTROL
parameter_list|(
name|x
parameter_list|)
value|((char)(((int)(x))& 0x1f))
end_define

begin_struct
specifier|static
struct|struct
block|{
name|char
modifier|*
name|prompt
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
name|char
modifier|*
name|pos
decl_stmt|;
name|char
modifier|*
name|end
decl_stmt|;
name|char
modifier|*
name|mark
decl_stmt|;
name|int
name|bufsize
decl_stmt|;
name|int
name|linelen
decl_stmt|;
name|int
name|histcount
decl_stmt|;
name|int
name|curhist
decl_stmt|;
block|}
name|HS
struct|;
end_struct

begin_typedef
typedef|typedef
name|void
function_decl|(
modifier|*
name|FUNCPTR
function_decl|)
parameter_list|()
function_decl|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|FUNCPTR
name|func
decl_stmt|;
block|}
name|FUNC
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|void
name|flush_input
argument_list|()
decl_stmt|,
name|start_of_line
argument_list|()
decl_stmt|,
name|end_of_line
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|forward_char
argument_list|()
decl_stmt|,
name|backward_char
argument_list|()
decl_stmt|,
name|forward_word
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|backward_word
argument_list|()
decl_stmt|,
name|delete_char
argument_list|()
decl_stmt|,
name|forward_kill_char
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|backward_kill_char
argument_list|()
decl_stmt|,
name|forward_kill_word
argument_list|()
decl_stmt|,
name|kill_line
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|new_line
argument_list|()
decl_stmt|,
name|save_line
argument_list|()
decl_stmt|,
name|forward_history
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|backward_history
argument_list|()
decl_stmt|,
name|insert_char
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|goto_line
argument_list|()
decl_stmt|,
name|list_history
argument_list|()
decl_stmt|,
name|refresh_line
argument_list|()
decl_stmt|,
name|swap_chars
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|set_mark
argument_list|()
decl_stmt|,
name|yank
argument_list|()
decl_stmt|,
name|save_region
argument_list|()
decl_stmt|,
name|kill_region
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|reverse_search
argument_list|()
decl_stmt|,
name|quote_char
argument_list|()
decl_stmt|,
name|uppercase_word
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|lowercase_word
argument_list|()
decl_stmt|,
name|ignore_char
argument_list|()
decl_stmt|,
name|arrow_key
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|FUNC
name|funcs
index|[]
init|=
block|{
block|{
literal|"ignore-char"
block|,
name|ignore_char
block|}
block|,
block|{
literal|"flush-input"
block|,
name|flush_input
block|}
block|,
block|{
literal|"start-of-line"
block|,
name|start_of_line
block|}
block|,
block|{
literal|"end-of-line"
block|,
name|end_of_line
block|}
block|,
block|{
literal|"forward-char"
block|,
name|forward_char
block|}
block|,
block|{
literal|"backward-char"
block|,
name|backward_char
block|}
block|,
block|{
literal|"forward-word"
block|,
name|forward_word
block|}
block|,
block|{
literal|"backward-word"
block|,
name|backward_word
block|}
block|,
block|{
literal|"delete-char"
block|,
name|delete_char
block|}
block|,
block|{
literal|"forward-kill-char"
block|,
name|forward_kill_char
block|}
block|,
block|{
literal|"backward-kill-char"
block|,
name|backward_kill_char
block|}
block|,
block|{
literal|"forward-kill-word"
block|,
name|forward_kill_word
block|}
block|,
block|{
literal|"uppercase-word"
block|,
name|uppercase_word
block|}
block|,
block|{
literal|"lowercase-word"
block|,
name|lowercase_word
block|}
block|,
block|{
literal|"kill-line"
block|,
name|kill_line
block|}
block|,
block|{
literal|"goto-line"
block|,
name|goto_line
block|}
block|,
block|{
literal|"new-line"
block|,
name|new_line
block|}
block|,
block|{
literal|"save-line"
block|,
name|save_line
block|}
block|,
block|{
literal|"forward-history"
block|,
name|forward_history
block|}
block|,
block|{
literal|"backward-history"
block|,
name|backward_history
block|}
block|,
block|{
literal|"insert-char"
block|,
name|insert_char
block|}
block|,
block|{
literal|"list-history"
block|,
name|list_history
block|}
block|,
block|{
literal|"refresh-line"
block|,
name|refresh_line
block|}
block|,
block|{
literal|"swap-chars"
block|,
name|swap_chars
block|}
block|,
block|{
literal|"set-mark"
block|,
name|set_mark
block|}
block|,
block|{
literal|"yank"
block|,
name|yank
block|}
block|,
block|{
literal|"save-region"
block|,
name|save_region
block|}
block|,
block|{
literal|"kill-region"
block|,
name|kill_region
block|}
block|,
block|{
literal|"reverse-search"
block|,
name|reverse_search
block|}
block|,
block|{
literal|"quote-char"
block|,
name|quote_char
block|}
block|,
block|{
literal|"arrow-key"
block|,
name|arrow_key
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_typedef
typedef|typedef
name|struct
name|key_ent
name|KEY_ENT
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|struct
name|key_map
name|KEY_MAP
typedef|;
end_typedef

begin_struct
struct|struct
name|key_ent
block|{
name|FUNCPTR
name|func
decl_stmt|;
name|KEY_MAP
modifier|*
name|next
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|key_map
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|KEY_ENT
name|default_ent
decl_stmt|;
name|KEY_ENT
modifier|*
name|map
index|[
literal|256
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|char
name|base_map_name
index|[]
init|=
literal|"base-map"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|esc_map_name
index|[]
init|=
literal|"esc-map"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|KEY_MAP
name|maps
index|[]
init|=
block|{
block|{
name|base_map_name
block|}
block|,
block|{
name|esc_map_name
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|INTROUND
value|(sizeof(int) - 1)
end_define

begin_define
define|#
directive|define
name|HISTLEN
parameter_list|(
name|hp
parameter_list|)
value|((((hp)->len + INTROUND)& ~INTROUND) + sizeof(int))
end_define

begin_define
define|#
directive|define
name|HISTOFFSET
parameter_list|(
name|hp
parameter_list|)
value|(((char *) (hp)) - histbuf)
end_define

begin_define
define|#
directive|define
name|FIRSTHIST
value|((HIST *) histbuf)
end_define

begin_define
define|#
directive|define
name|NEXTHIST
parameter_list|(
name|hp
parameter_list|)
value|((HIST *) (((char *) (hp)) + HISTLEN(hp)))
end_define

begin_typedef
typedef|typedef
struct|struct
block|{
name|int
name|len
decl_stmt|;
comment|/* length of data */
name|char
name|data
index|[
literal|1
index|]
decl_stmt|;
comment|/* varying length data */
block|}
name|HIST
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|int
name|inited
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|canedit
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|histused
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|key_count
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|save_len
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|TTYSTRUCT
name|oldtty
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|KEY_MAP
modifier|*
name|cur_map
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|KEY_MAP
modifier|*
name|base_map
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|KEY_ENT
name|key_table
index|[
name|MAX_KEYS
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|histbuf
index|[
name|HIST_SIZE
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|save_buffer
index|[
name|SAVE_SIZE
index|]
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|FUNCPTR
name|find_func
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|HIST
modifier|*
name|get_event
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|HIST
modifier|*
name|find_event
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|read_key
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|erasechar
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|newline
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|backspace
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|beep
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|echo_char
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|echo_string
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|savetext
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|memrcpy
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|read_bindings
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|in_word
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/*  * Read a line into the specified buffer.  The line ends in a newline,  * and is NULL terminated.  Returns the number of characters read, or  * zero on an end of file or error.  The prompt is printed before reading  * the line.  */
end_comment

begin_function
name|int
name|hist_getline
parameter_list|(
name|prompt
parameter_list|,
name|buf
parameter_list|,
name|len
parameter_list|)
name|char
modifier|*
name|prompt
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|inited
condition|)
operator|(
name|void
operator|)
name|hist_init
argument_list|(
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|HS
operator|.
name|prompt
operator|=
name|prompt
expr_stmt|;
name|HS
operator|.
name|bufsize
operator|=
name|len
operator|-
literal|2
expr_stmt|;
name|HS
operator|.
name|buf
operator|=
name|buf
expr_stmt|;
name|HS
operator|.
name|pos
operator|=
name|buf
expr_stmt|;
name|HS
operator|.
name|end
operator|=
name|buf
expr_stmt|;
name|HS
operator|.
name|mark
operator|=
name|NULL
expr_stmt|;
name|HS
operator|.
name|linelen
operator|=
operator|-
literal|1
expr_stmt|;
name|fputs
argument_list|(
name|prompt
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|canedit
condition|)
block|{
if|if
condition|(
name|fgets
argument_list|(
name|buf
argument_list|,
name|len
argument_list|,
name|stdin
argument_list|)
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
return|return
name|strlen
argument_list|(
name|buf
argument_list|)
return|;
block|}
while|while
condition|(
name|HS
operator|.
name|linelen
operator|<
literal|0
condition|)
name|read_key
argument_list|()
expr_stmt|;
return|return
name|HS
operator|.
name|linelen
return|;
block|}
end_function

begin_comment
comment|/*  * Initialize the module by reading in the key bindings from the specified  * filename, and then setting the terminal modes for noecho and cbreak mode.  * If the supplied filename is NULL, then a default filename will be used.  * Returns zero if successful, or a nonzero error code if unsuccessful.  * If this routine fails, hist_getline, hist_saveline, and hist_term can  * still be called but all fancy editing is disabled.  */
end_comment

begin_function
name|int
name|hist_init
parameter_list|(
name|filename
parameter_list|)
name|char
modifier|*
name|filename
decl_stmt|;
block|{
name|TTYSTRUCT
name|newtty
decl_stmt|;
if|if
condition|(
name|inited
condition|)
return|return
name|HIST_INITED
return|;
name|inited
operator|=
literal|1
expr_stmt|;
name|canedit
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|filename
operator|==
name|NULL
condition|)
name|filename
operator|=
name|HIST_BINDING_FILE
expr_stmt|;
if|if
condition|(
name|read_bindings
argument_list|(
name|filename
argument_list|)
condition|)
return|return
name|HIST_NOFILE
return|;
ifdef|#
directive|ifdef
name|USE_SGTTY
if|if
condition|(
name|ioctl
argument_list|(
name|STDIN
argument_list|,
name|TIOCGETP
argument_list|,
operator|&
name|oldtty
argument_list|)
operator|<
literal|0
condition|)
return|return
name|HIST_NOTTY
return|;
name|newtty
operator|=
name|oldtty
expr_stmt|;
name|newtty
operator|.
name|sg_flags
operator|&=
operator|~
name|ECHO
expr_stmt|;
name|newtty
operator|.
name|sg_flags
operator||=
name|CBREAK
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|STDIN
argument_list|,
name|TIOCSETP
argument_list|,
operator|&
name|newtty
argument_list|)
operator|<
literal|0
condition|)
return|return
name|HIST_NOTTY
return|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|USE_TERMIO
if|if
condition|(
name|ioctl
argument_list|(
name|STDIN
argument_list|,
name|TCGETA
argument_list|,
operator|&
name|oldtty
argument_list|)
operator|<
literal|0
condition|)
return|return
name|HIST_NOTTY
return|;
name|newtty
operator|=
name|oldtty
expr_stmt|;
name|newtty
operator|.
name|c_lflag
operator|&=
operator|~
operator|(
name|ECHO
operator||
name|ECHOE
operator||
name|ECHOK
operator|)
expr_stmt|;
name|newtty
operator|.
name|c_iflag
operator||=
name|ISTRIP
expr_stmt|;
name|newtty
operator|.
name|c_lflag
operator|&=
operator|~
name|ICANON
expr_stmt|;
name|newtty
operator|.
name|c_cc
index|[
name|VMIN
index|]
operator|=
literal|1
expr_stmt|;
name|newtty
operator|.
name|c_cc
index|[
name|VTIME
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|STDIN
argument_list|,
name|TCSETAW
argument_list|,
operator|&
name|newtty
argument_list|)
operator|<
literal|0
condition|)
return|return
name|HIST_NOTTY
return|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|USE_TERMIOS
if|if
condition|(
name|tcgetattr
argument_list|(
name|STDIN
argument_list|,
operator|&
name|oldtty
argument_list|)
operator|<
literal|0
condition|)
return|return
name|HIST_NOTTY
return|;
name|newtty
operator|=
name|oldtty
expr_stmt|;
name|newtty
operator|.
name|c_lflag
operator|&=
operator|~
operator|(
name|ECHO
operator||
name|ECHOE
operator||
name|ECHOK
operator|)
expr_stmt|;
name|newtty
operator|.
name|c_iflag
operator||=
name|ISTRIP
expr_stmt|;
name|newtty
operator|.
name|c_lflag
operator|&=
operator|~
name|ICANON
expr_stmt|;
name|newtty
operator|.
name|c_cc
index|[
name|VMIN
index|]
operator|=
literal|1
expr_stmt|;
name|newtty
operator|.
name|c_cc
index|[
name|VTIME
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|tcsetattr
argument_list|(
name|STDIN
argument_list|,
name|TCSANOW
argument_list|,
operator|&
name|newtty
argument_list|)
operator|<
literal|0
condition|)
return|return
name|HIST_NOTTY
return|;
endif|#
directive|endif
name|canedit
operator|=
literal|1
expr_stmt|;
return|return
name|HIST_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/*  * Reset the terminal modes just before exiting.  */
end_comment

begin_function
name|void
name|hist_term
parameter_list|()
block|{
if|if
condition|(
operator|!
name|inited
operator|||
operator|!
name|canedit
condition|)
block|{
name|inited
operator|=
literal|0
expr_stmt|;
return|return;
block|}
ifdef|#
directive|ifdef
name|USE_SGTTY
operator|(
name|void
operator|)
name|ioctl
argument_list|(
name|STDIN
argument_list|,
name|TIOCSETP
argument_list|,
operator|&
name|oldtty
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|USE_TERMIO
operator|(
name|void
operator|)
name|ioctl
argument_list|(
name|STDIN
argument_list|,
name|TCSETAW
argument_list|,
operator|&
name|oldtty
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|USE_TERMIOS
operator|(
name|void
operator|)
name|tcsetattr
argument_list|(
name|STDIN
argument_list|,
name|TCSANOW
argument_list|,
operator|&
name|oldtty
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|KEY_MAP
modifier|*
name|find_map
parameter_list|(
name|map
parameter_list|)
name|char
modifier|*
name|map
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|maps
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|maps
index|[
literal|0
index|]
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|map
argument_list|,
name|maps
index|[
name|i
index|]
operator|.
name|name
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|&
name|maps
index|[
name|i
index|]
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|unbind_key
parameter_list|(
name|map
parameter_list|,
name|key
parameter_list|)
name|KEY_MAP
modifier|*
name|map
decl_stmt|;
block|{
name|map
operator|->
name|map
index|[
name|key
index|]
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|raw_bind_key
parameter_list|(
name|map
parameter_list|,
name|key
parameter_list|,
name|func
parameter_list|,
name|next_map
parameter_list|)
name|KEY_MAP
modifier|*
name|map
decl_stmt|;
name|FUNCPTR
name|func
decl_stmt|;
name|KEY_MAP
modifier|*
name|next_map
decl_stmt|;
block|{
if|if
condition|(
name|map
operator|->
name|map
index|[
name|key
index|]
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|key_count
operator|>=
name|MAX_KEYS
condition|)
return|return;
name|map
operator|->
name|map
index|[
name|key
index|]
operator|=
operator|&
name|key_table
index|[
name|key_count
operator|++
index|]
expr_stmt|;
block|}
name|map
operator|->
name|map
index|[
name|key
index|]
operator|->
name|func
operator|=
name|func
expr_stmt|;
name|map
operator|->
name|map
index|[
name|key
index|]
operator|->
name|next
operator|=
name|next_map
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|KEY_MAP
modifier|*
name|do_map_line
parameter_list|(
name|line
parameter_list|)
name|char
name|line
index|[]
decl_stmt|;
block|{
name|char
modifier|*
name|cp
decl_stmt|;
name|char
modifier|*
name|map_name
decl_stmt|;
name|cp
operator|=
name|line
expr_stmt|;
while|while
condition|(
name|isspace
argument_list|(
operator|*
name|cp
argument_list|)
condition|)
name|cp
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|cp
operator|==
literal|'\0'
condition|)
return|return
name|NULL
return|;
name|map_name
operator|=
name|cp
expr_stmt|;
while|while
condition|(
operator|(
operator|*
name|cp
operator|!=
literal|'\0'
operator|)
operator|&&
operator|!
name|isspace
argument_list|(
operator|*
name|cp
argument_list|)
condition|)
name|cp
operator|++
expr_stmt|;
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
return|return
name|find_map
argument_list|(
name|map_name
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_bind_line
parameter_list|(
name|map
parameter_list|,
name|line
parameter_list|)
name|KEY_MAP
modifier|*
name|map
decl_stmt|;
name|char
name|line
index|[]
decl_stmt|;
block|{
name|char
modifier|*
name|cp
decl_stmt|;
name|char
name|key
decl_stmt|;
name|char
modifier|*
name|func_name
decl_stmt|;
name|char
modifier|*
name|next_name
decl_stmt|;
name|KEY_MAP
modifier|*
name|next
decl_stmt|;
name|FUNCPTR
name|func
decl_stmt|;
if|if
condition|(
name|map
operator|==
name|NULL
condition|)
return|return;
name|cp
operator|=
name|line
expr_stmt|;
name|key
operator|=
operator|*
name|cp
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|cp
operator|==
literal|'\0'
condition|)
block|{
name|unbind_key
argument_list|(
name|map
argument_list|,
name|key
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|key
operator|==
literal|'^'
condition|)
block|{
if|if
condition|(
operator|*
name|cp
operator|==
literal|'?'
condition|)
block|{
name|key
operator|=
literal|0177
expr_stmt|;
name|cp
operator|++
expr_stmt|;
block|}
else|else
name|key
operator|=
name|CONTROL
argument_list|(
operator|*
name|cp
operator|++
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|key
operator|==
literal|'\\'
condition|)
name|key
operator|=
operator|*
name|cp
operator|++
expr_stmt|;
while|while
condition|(
name|isspace
argument_list|(
operator|*
name|cp
argument_list|)
condition|)
name|cp
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|cp
operator|==
literal|'\0'
condition|)
block|{
name|unbind_key
argument_list|(
name|map
argument_list|,
name|key
argument_list|)
expr_stmt|;
return|return;
block|}
name|func_name
operator|=
name|cp
expr_stmt|;
while|while
condition|(
operator|(
operator|*
name|cp
operator|!=
literal|'\0'
operator|)
operator|&&
operator|!
name|isspace
argument_list|(
operator|*
name|cp
argument_list|)
condition|)
name|cp
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|cp
condition|)
block|{
operator|*
name|cp
operator|++
operator|=
literal|'\0'
expr_stmt|;
while|while
condition|(
name|isspace
argument_list|(
operator|*
name|cp
argument_list|)
condition|)
name|cp
operator|++
expr_stmt|;
block|}
name|func
operator|=
name|find_func
argument_list|(
name|func_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|func
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Unknown function \"%s\"\n"
argument_list|,
name|func_name
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|*
name|cp
operator|==
literal|'\0'
condition|)
block|{
name|next
operator|=
name|map
operator|->
name|default_ent
operator|.
name|next
expr_stmt|;
if|if
condition|(
name|next
operator|==
name|NULL
condition|)
name|next
operator|=
name|base_map
expr_stmt|;
block|}
else|else
block|{
name|next_name
operator|=
name|cp
expr_stmt|;
while|while
condition|(
operator|(
operator|*
name|cp
operator|!=
literal|'\0'
operator|)
operator|&&
operator|!
name|isspace
argument_list|(
operator|*
name|cp
argument_list|)
condition|)
name|cp
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|cp
condition|)
block|{
operator|*
name|cp
operator|++
operator|=
literal|'\0'
expr_stmt|;
while|while
condition|(
name|isspace
argument_list|(
operator|*
name|cp
argument_list|)
condition|)
name|cp
operator|++
expr_stmt|;
block|}
name|next
operator|=
name|find_map
argument_list|(
name|next_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|next
operator|==
name|NULL
condition|)
return|return;
block|}
name|raw_bind_key
argument_list|(
name|map
argument_list|,
name|key
argument_list|,
name|func
argument_list|,
name|next
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_default_line
parameter_list|(
name|map
parameter_list|,
name|line
parameter_list|)
name|KEY_MAP
modifier|*
name|map
decl_stmt|;
name|char
modifier|*
name|line
decl_stmt|;
block|{
name|char
modifier|*
name|cp
decl_stmt|;
name|char
modifier|*
name|func_name
decl_stmt|;
name|char
modifier|*
name|next_name
decl_stmt|;
name|KEY_MAP
modifier|*
name|next
decl_stmt|;
name|FUNCPTR
name|func
decl_stmt|;
if|if
condition|(
name|map
operator|==
name|NULL
condition|)
return|return;
name|cp
operator|=
name|line
expr_stmt|;
while|while
condition|(
name|isspace
argument_list|(
operator|*
name|cp
argument_list|)
condition|)
name|cp
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|cp
operator|==
literal|'\0'
condition|)
return|return;
name|func_name
operator|=
name|cp
expr_stmt|;
while|while
condition|(
operator|(
operator|*
name|cp
operator|!=
literal|'\0'
operator|)
operator|&&
operator|!
name|isspace
argument_list|(
operator|*
name|cp
argument_list|)
condition|)
name|cp
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|cp
operator|!=
literal|'\0'
condition|)
block|{
operator|*
name|cp
operator|++
operator|=
literal|'\0'
expr_stmt|;
while|while
condition|(
name|isspace
argument_list|(
operator|*
name|cp
argument_list|)
condition|)
name|cp
operator|++
expr_stmt|;
block|}
name|func
operator|=
name|find_func
argument_list|(
name|func_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|func
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
operator|*
name|cp
operator|==
literal|'\0'
condition|)
name|next
operator|=
name|map
expr_stmt|;
else|else
block|{
name|next_name
operator|=
name|cp
expr_stmt|;
while|while
condition|(
operator|(
operator|*
name|cp
operator|!=
literal|'\0'
operator|)
operator|&&
operator|!
name|isspace
argument_list|(
operator|*
name|cp
argument_list|)
condition|)
name|cp
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|cp
operator|!=
literal|'\0'
condition|)
block|{
operator|*
name|cp
operator|++
operator|=
literal|'\0'
expr_stmt|;
while|while
condition|(
name|isspace
argument_list|(
operator|*
name|cp
argument_list|)
condition|)
name|cp
operator|++
expr_stmt|;
block|}
name|next
operator|=
name|find_map
argument_list|(
name|next_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|next
operator|==
name|NULL
condition|)
return|return;
block|}
name|map
operator|->
name|default_ent
operator|.
name|func
operator|=
name|func
expr_stmt|;
name|map
operator|->
name|default_ent
operator|.
name|next
operator|=
name|next
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Read bindings from specified file.  * Returns nonzero on error.  */
end_comment

begin_function
specifier|static
name|int
name|read_bindings
parameter_list|(
name|bindfile
parameter_list|)
name|char
modifier|*
name|bindfile
decl_stmt|;
block|{
name|char
modifier|*
name|cp
decl_stmt|;
name|KEY_MAP
modifier|*
name|input_map
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
name|char
name|line
index|[
literal|100
index|]
decl_stmt|;
name|base_map
operator|=
name|find_map
argument_list|(
name|base_map_name
argument_list|)
expr_stmt|;
name|cur_map
operator|=
name|base_map
expr_stmt|;
name|input_map
operator|=
name|base_map
expr_stmt|;
name|fp
operator|=
name|fopen
argument_list|(
name|bindfile
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|==
name|NULL
condition|)
return|return
literal|1
return|;
while|while
condition|(
name|fgets
argument_list|(
name|line
argument_list|,
sizeof|sizeof
argument_list|(
name|line
argument_list|)
operator|-
literal|1
argument_list|,
name|fp
argument_list|)
condition|)
block|{
name|cp
operator|=
name|line
expr_stmt|;
while|while
condition|(
name|isspace
argument_list|(
operator|*
name|cp
argument_list|)
condition|)
name|cp
operator|++
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|cp
operator|==
literal|'\0'
operator|)
operator|||
operator|(
operator|*
name|cp
operator|==
literal|'#'
operator|)
operator|||
operator|(
operator|*
name|cp
operator|==
literal|'\n'
operator|)
condition|)
continue|continue;
if|if
condition|(
name|cp
index|[
name|strlen
argument_list|(
name|cp
argument_list|)
operator|-
literal|1
index|]
operator|==
literal|'\n'
condition|)
name|cp
index|[
name|strlen
argument_list|(
name|cp
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|memcmp
argument_list|(
name|cp
argument_list|,
literal|"map"
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
condition|)
name|input_map
operator|=
name|do_map_line
argument_list|(
operator|&
name|cp
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|memcmp
argument_list|(
name|cp
argument_list|,
literal|"default"
argument_list|,
literal|7
argument_list|)
operator|==
literal|0
condition|)
name|do_default_line
argument_list|(
name|input_map
argument_list|,
operator|&
name|cp
index|[
literal|7
index|]
argument_list|)
expr_stmt|;
else|else
name|do_bind_line
argument_list|(
name|input_map
argument_list|,
name|cp
argument_list|)
expr_stmt|;
block|}
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|read_key
parameter_list|()
block|{
name|KEY_ENT
modifier|*
name|ent
decl_stmt|;
name|int
name|key
decl_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|key
operator|=
name|fgetc
argument_list|(
name|stdin
argument_list|)
expr_stmt|;
if|if
condition|(
name|key
operator|==
name|EOF
condition|)
block|{
name|HS
operator|.
name|linelen
operator|=
literal|0
expr_stmt|;
name|HS
operator|.
name|buf
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return;
block|}
name|ent
operator|=
name|cur_map
operator|->
name|map
index|[
name|key
index|]
expr_stmt|;
if|if
condition|(
name|ent
operator|==
name|NULL
condition|)
name|ent
operator|=
operator|&
name|cur_map
operator|->
name|default_ent
expr_stmt|;
if|if
condition|(
name|ent
operator|->
name|next
condition|)
name|cur_map
operator|=
name|ent
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|ent
operator|->
name|func
condition|)
call|(
modifier|*
name|ent
operator|->
name|func
call|)
argument_list|(
name|key
argument_list|)
expr_stmt|;
else|else
name|insert_char
argument_list|(
name|key
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Return the Nth history event, indexed from zero.  * Earlier history events are lower in number.  */
end_comment

begin_function
specifier|static
name|HIST
modifier|*
name|get_event
parameter_list|(
name|n
parameter_list|)
block|{
specifier|register
name|HIST
modifier|*
name|hp
decl_stmt|;
if|if
condition|(
operator|(
name|n
operator|<
literal|0
operator|)
operator|||
operator|(
name|n
operator|>=
name|HS
operator|.
name|histcount
operator|)
condition|)
return|return
name|NULL
return|;
name|hp
operator|=
name|FIRSTHIST
expr_stmt|;
while|while
condition|(
name|n
operator|--
operator|>
literal|0
condition|)
name|hp
operator|=
name|NEXTHIST
argument_list|(
name|hp
argument_list|)
expr_stmt|;
return|return
name|hp
return|;
block|}
end_function

begin_comment
comment|/*  * Search the history list for the specified pattern.  * Returns the found history, or NULL.  */
end_comment

begin_function
specifier|static
name|HIST
modifier|*
name|find_event
parameter_list|(
name|pat
parameter_list|,
name|len
parameter_list|)
name|char
modifier|*
name|pat
decl_stmt|;
block|{
specifier|register
name|HIST
modifier|*
name|hp
decl_stmt|;
for|for
control|(
name|hp
operator|=
name|FIRSTHIST
init|;
name|hp
operator|->
name|len
condition|;
name|hp
operator|=
name|NEXTHIST
argument_list|(
name|hp
argument_list|)
control|)
block|{
if|if
condition|(
operator|(
name|hp
operator|->
name|len
operator|==
name|len
operator|)
operator|&&
operator|(
name|memcmp
argument_list|(
name|hp
operator|->
name|data
argument_list|,
name|pat
argument_list|,
name|len
argument_list|)
operator|==
literal|0
operator|)
condition|)
return|return
name|hp
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/*  * Insert a line into the end of the history table.  * If the line already appears in the table, then it is moved to the end.  * If the table is full, then the earliest commands are deleted as necessary.  * Warning: the incoming line cannot point into the history table.  */
end_comment

begin_function
name|void
name|hist_saveline
parameter_list|(
name|line
parameter_list|,
name|len
parameter_list|)
name|char
modifier|*
name|line
decl_stmt|;
block|{
name|HIST
modifier|*
name|hp
decl_stmt|;
name|HIST
modifier|*
name|hp2
decl_stmt|;
name|int
name|left
decl_stmt|;
if|if
condition|(
operator|(
name|len
operator|>
literal|0
operator|)
operator|&&
operator|(
name|line
index|[
name|len
operator|-
literal|1
index|]
operator|==
literal|'\n'
operator|)
condition|)
name|len
operator|--
expr_stmt|;
if|if
condition|(
name|len
operator|<=
literal|0
condition|)
return|return;
comment|/* 	 * See if the line is already present in the history table. 	 * If so, and it is already at the end, then we are all done. 	 * Otherwise delete it since we will reinsert it at the end. 	 */
name|hp
operator|=
name|find_event
argument_list|(
name|line
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|hp
condition|)
block|{
name|hp2
operator|=
name|NEXTHIST
argument_list|(
name|hp
argument_list|)
expr_stmt|;
name|left
operator|=
name|histused
operator|-
name|HISTOFFSET
argument_list|(
name|hp2
argument_list|)
expr_stmt|;
if|if
condition|(
name|left
operator|<=
literal|0
condition|)
return|return;
name|histused
operator|-=
name|HISTLEN
argument_list|(
name|hp
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|hp
argument_list|,
name|hp2
argument_list|,
name|left
operator|+
literal|1
argument_list|)
expr_stmt|;
name|HS
operator|.
name|histcount
operator|--
expr_stmt|;
block|}
comment|/* 	 * If there is not enough room left in the history buffer to add 	 * the new command, then repeatedly delete the earliest command 	 * as many times as necessary in order to make enough room. 	 */
while|while
condition|(
operator|(
name|histused
operator|+
name|len
operator|)
operator|>=
name|HIST_SIZE
condition|)
block|{
name|hp
operator|=
operator|(
name|HIST
operator|*
operator|)
name|histbuf
expr_stmt|;
name|hp2
operator|=
name|NEXTHIST
argument_list|(
name|hp
argument_list|)
expr_stmt|;
name|left
operator|=
name|histused
operator|-
name|HISTOFFSET
argument_list|(
name|hp2
argument_list|)
expr_stmt|;
name|histused
operator|-=
name|HISTLEN
argument_list|(
name|hp
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|hp
argument_list|,
name|hp2
argument_list|,
name|left
operator|+
literal|1
argument_list|)
expr_stmt|;
name|HS
operator|.
name|histcount
operator|--
expr_stmt|;
block|}
comment|/* 	 * Add the line to the end of the history table. 	 */
name|hp
operator|=
operator|(
name|HIST
operator|*
operator|)
operator|&
name|histbuf
index|[
name|histused
index|]
expr_stmt|;
name|hp
operator|->
name|len
operator|=
name|len
expr_stmt|;
name|memcpy
argument_list|(
name|hp
operator|->
name|data
argument_list|,
name|line
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|histused
operator|+=
name|HISTLEN
argument_list|(
name|hp
argument_list|)
expr_stmt|;
name|histbuf
index|[
name|histused
index|]
operator|=
literal|0
expr_stmt|;
name|HS
operator|.
name|histcount
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Find the function for a specified name.  */
end_comment

begin_function
specifier|static
name|FUNCPTR
name|find_func
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|FUNC
modifier|*
name|fp
decl_stmt|;
for|for
control|(
name|fp
operator|=
name|funcs
init|;
name|fp
operator|->
name|name
condition|;
name|fp
operator|++
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|fp
operator|->
name|name
argument_list|,
name|name
argument_list|)
operator|==
literal|0
condition|)
return|return
name|fp
operator|->
name|func
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|arrow_key
parameter_list|()
block|{
switch|switch
condition|(
name|fgetc
argument_list|(
name|stdin
argument_list|)
condition|)
block|{
case|case
literal|'A'
case|:
name|backward_history
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'B'
case|:
name|forward_history
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'C'
case|:
name|forward_char
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'D'
case|:
name|backward_char
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|back_over_char
parameter_list|(
name|ch
parameter_list|)
name|char
name|ch
decl_stmt|;
block|{
name|backspace
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|isprint
argument_list|(
name|ch
argument_list|)
condition|)
name|backspace
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|remove_char
parameter_list|(
name|ch
parameter_list|)
name|char
name|ch
decl_stmt|;
block|{
name|erasechar
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|isprint
argument_list|(
name|ch
argument_list|)
condition|)
name|erasechar
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|echo_rest_of_line
parameter_list|()
block|{
name|echo_string
argument_list|(
name|HS
operator|.
name|pos
argument_list|,
name|HS
operator|.
name|end
operator|-
name|HS
operator|.
name|pos
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|goto_start_of_line
parameter_list|()
block|{
while|while
condition|(
name|HS
operator|.
name|pos
operator|>
name|HS
operator|.
name|buf
condition|)
name|back_over_char
argument_list|(
operator|*
operator|--
name|HS
operator|.
name|pos
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|goto_end_of_line
parameter_list|()
block|{
name|echo_rest_of_line
argument_list|()
expr_stmt|;
name|HS
operator|.
name|pos
operator|=
name|HS
operator|.
name|end
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|decrement_end
parameter_list|(
name|n
parameter_list|)
block|{
name|HS
operator|.
name|end
operator|-=
name|n
expr_stmt|;
if|if
condition|(
name|HS
operator|.
name|mark
operator|&&
operator|(
name|HS
operator|.
name|mark
operator|>
name|HS
operator|.
name|end
operator|)
condition|)
name|HS
operator|.
name|mark
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ignore_char
parameter_list|()
block|{ }
end_function

begin_function
specifier|static
name|void
name|flush_input
parameter_list|()
block|{
name|echo_rest_of_line
argument_list|()
expr_stmt|;
while|while
condition|(
name|HS
operator|.
name|end
operator|>
name|HS
operator|.
name|buf
condition|)
name|remove_char
argument_list|(
operator|*
operator|--
name|HS
operator|.
name|end
argument_list|)
expr_stmt|;
name|HS
operator|.
name|pos
operator|=
name|HS
operator|.
name|buf
expr_stmt|;
name|HS
operator|.
name|mark
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|start_of_line
parameter_list|()
block|{
name|goto_start_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|end_of_line
parameter_list|()
block|{
name|goto_end_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|forward_char
parameter_list|()
block|{
if|if
condition|(
name|HS
operator|.
name|pos
operator|<
name|HS
operator|.
name|end
condition|)
name|echo_char
argument_list|(
operator|*
name|HS
operator|.
name|pos
operator|++
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|backward_char
parameter_list|()
block|{
if|if
condition|(
name|HS
operator|.
name|pos
operator|>
name|HS
operator|.
name|buf
condition|)
name|back_over_char
argument_list|(
operator|*
operator|--
name|HS
operator|.
name|pos
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|uppercase_word
parameter_list|()
block|{
while|while
condition|(
operator|(
name|HS
operator|.
name|pos
operator|<
name|HS
operator|.
name|end
operator|)
operator|&&
operator|!
name|in_word
argument_list|(
operator|*
name|HS
operator|.
name|pos
argument_list|)
condition|)
name|echo_char
argument_list|(
operator|*
name|HS
operator|.
name|pos
operator|++
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|HS
operator|.
name|pos
operator|<
name|HS
operator|.
name|end
operator|)
operator|&&
name|in_word
argument_list|(
operator|*
name|HS
operator|.
name|pos
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|HS
operator|.
name|pos
operator|>=
literal|'a'
operator|)
operator|&&
operator|(
operator|*
name|HS
operator|.
name|pos
operator|<=
literal|'z'
operator|)
condition|)
operator|*
name|HS
operator|.
name|pos
operator|+=
literal|'A'
operator|-
literal|'a'
expr_stmt|;
name|echo_char
argument_list|(
operator|*
name|HS
operator|.
name|pos
operator|++
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|lowercase_word
parameter_list|()
block|{
while|while
condition|(
operator|(
name|HS
operator|.
name|pos
operator|<
name|HS
operator|.
name|end
operator|)
operator|&&
operator|!
name|in_word
argument_list|(
operator|*
name|HS
operator|.
name|pos
argument_list|)
condition|)
name|echo_char
argument_list|(
operator|*
name|HS
operator|.
name|pos
operator|++
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|HS
operator|.
name|pos
operator|<
name|HS
operator|.
name|end
operator|)
operator|&&
name|in_word
argument_list|(
operator|*
name|HS
operator|.
name|pos
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|HS
operator|.
name|pos
operator|>=
literal|'A'
operator|)
operator|&&
operator|(
operator|*
name|HS
operator|.
name|pos
operator|<=
literal|'Z'
operator|)
condition|)
operator|*
name|HS
operator|.
name|pos
operator|+=
literal|'a'
operator|-
literal|'A'
expr_stmt|;
name|echo_char
argument_list|(
operator|*
name|HS
operator|.
name|pos
operator|++
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|forward_word
parameter_list|()
block|{
while|while
condition|(
operator|(
name|HS
operator|.
name|pos
operator|<
name|HS
operator|.
name|end
operator|)
operator|&&
operator|!
name|in_word
argument_list|(
operator|*
name|HS
operator|.
name|pos
argument_list|)
condition|)
name|echo_char
argument_list|(
operator|*
name|HS
operator|.
name|pos
operator|++
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|HS
operator|.
name|pos
operator|<
name|HS
operator|.
name|end
operator|)
operator|&&
name|in_word
argument_list|(
operator|*
name|HS
operator|.
name|pos
argument_list|)
condition|)
name|echo_char
argument_list|(
operator|*
name|HS
operator|.
name|pos
operator|++
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|backward_word
parameter_list|()
block|{
if|if
condition|(
operator|(
name|HS
operator|.
name|pos
operator|>
name|HS
operator|.
name|buf
operator|)
operator|&&
name|in_word
argument_list|(
operator|*
name|HS
operator|.
name|pos
argument_list|)
condition|)
name|back_over_char
argument_list|(
operator|*
operator|--
name|HS
operator|.
name|pos
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|HS
operator|.
name|pos
operator|>
name|HS
operator|.
name|buf
operator|)
operator|&&
operator|!
name|in_word
argument_list|(
operator|*
name|HS
operator|.
name|pos
argument_list|)
condition|)
name|back_over_char
argument_list|(
operator|*
operator|--
name|HS
operator|.
name|pos
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|HS
operator|.
name|pos
operator|>
name|HS
operator|.
name|buf
operator|)
operator|&&
name|in_word
argument_list|(
operator|*
name|HS
operator|.
name|pos
argument_list|)
condition|)
name|back_over_char
argument_list|(
operator|*
operator|--
name|HS
operator|.
name|pos
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|HS
operator|.
name|pos
operator|<
name|HS
operator|.
name|end
operator|)
operator|&&
operator|!
name|in_word
argument_list|(
operator|*
name|HS
operator|.
name|pos
argument_list|)
condition|)
name|echo_char
argument_list|(
operator|*
name|HS
operator|.
name|pos
operator|++
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|forward_kill_char
parameter_list|()
block|{
name|int
name|rest
decl_stmt|;
name|char
name|ch
decl_stmt|;
name|rest
operator|=
name|HS
operator|.
name|end
operator|-
name|HS
operator|.
name|pos
expr_stmt|;
if|if
condition|(
name|rest
operator|--
operator|<=
literal|0
condition|)
return|return;
name|ch
operator|=
operator|*
name|HS
operator|.
name|pos
expr_stmt|;
if|if
condition|(
name|rest
operator|>
literal|0
condition|)
block|{
name|memcpy
argument_list|(
name|HS
operator|.
name|pos
argument_list|,
name|HS
operator|.
name|pos
operator|+
literal|1
argument_list|,
name|rest
argument_list|)
expr_stmt|;
operator|*
operator|(
name|HS
operator|.
name|end
operator|-
literal|1
operator|)
operator|=
name|ch
expr_stmt|;
block|}
name|echo_rest_of_line
argument_list|()
expr_stmt|;
name|remove_char
argument_list|(
name|ch
argument_list|)
expr_stmt|;
name|decrement_end
argument_list|(
literal|1
argument_list|)
expr_stmt|;
while|while
condition|(
name|rest
operator|>
literal|0
condition|)
name|back_over_char
argument_list|(
name|HS
operator|.
name|pos
index|[
operator|--
name|rest
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|delete_char
parameter_list|()
block|{
if|if
condition|(
name|HS
operator|.
name|end
operator|>
name|HS
operator|.
name|buf
condition|)
name|forward_kill_char
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|backward_kill_char
parameter_list|()
block|{
if|if
condition|(
name|HS
operator|.
name|pos
operator|>
name|HS
operator|.
name|buf
condition|)
block|{
name|HS
operator|.
name|pos
operator|--
expr_stmt|;
name|back_over_char
argument_list|(
operator|*
name|HS
operator|.
name|pos
argument_list|)
expr_stmt|;
name|forward_kill_char
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|forward_kill_word
parameter_list|()
block|{
name|char
modifier|*
name|cp
decl_stmt|;
if|if
condition|(
name|HS
operator|.
name|pos
operator|>=
name|HS
operator|.
name|end
condition|)
return|return;
name|echo_rest_of_line
argument_list|()
expr_stmt|;
for|for
control|(
name|cp
operator|=
name|HS
operator|.
name|end
init|;
name|cp
operator|>
name|HS
operator|.
name|pos
condition|;
control|)
name|remove_char
argument_list|(
operator|*
operator|--
name|cp
argument_list|)
expr_stmt|;
name|cp
operator|=
name|HS
operator|.
name|pos
expr_stmt|;
while|while
condition|(
operator|(
name|cp
operator|<
name|HS
operator|.
name|end
operator|)
operator|&&
operator|!
name|in_word
argument_list|(
operator|*
name|cp
argument_list|)
condition|)
name|cp
operator|++
expr_stmt|;
while|while
condition|(
operator|(
name|cp
operator|<
name|HS
operator|.
name|end
operator|)
operator|&&
name|in_word
argument_list|(
operator|*
name|cp
argument_list|)
condition|)
name|cp
operator|++
expr_stmt|;
name|savetext
argument_list|(
name|HS
operator|.
name|pos
argument_list|,
name|cp
operator|-
name|HS
operator|.
name|pos
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|HS
operator|.
name|pos
argument_list|,
name|cp
argument_list|,
name|HS
operator|.
name|end
operator|-
name|cp
argument_list|)
expr_stmt|;
name|decrement_end
argument_list|(
name|cp
operator|-
name|HS
operator|.
name|pos
argument_list|)
expr_stmt|;
name|echo_rest_of_line
argument_list|()
expr_stmt|;
for|for
control|(
name|cp
operator|=
name|HS
operator|.
name|end
init|;
name|cp
operator|>
name|HS
operator|.
name|pos
condition|;
control|)
name|back_over_char
argument_list|(
operator|*
operator|--
name|cp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|kill_line
parameter_list|()
block|{
if|if
condition|(
name|HS
operator|.
name|end
operator|<=
name|HS
operator|.
name|pos
condition|)
return|return;
name|savetext
argument_list|(
name|HS
operator|.
name|pos
argument_list|,
name|HS
operator|.
name|end
operator|-
name|HS
operator|.
name|pos
argument_list|)
expr_stmt|;
name|echo_rest_of_line
argument_list|()
expr_stmt|;
while|while
condition|(
name|HS
operator|.
name|end
operator|>
name|HS
operator|.
name|pos
condition|)
name|remove_char
argument_list|(
operator|*
operator|--
name|HS
operator|.
name|end
argument_list|)
expr_stmt|;
name|decrement_end
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * This is the function which completes a command line editing session.  * The final line length is returned in the HS.linelen variable.  * The line is NOT put into the edit history, so that the caller can  * decide whether or not this should be done.  */
end_comment

begin_function
specifier|static
name|void
name|new_line
parameter_list|()
block|{
name|int
name|len
decl_stmt|;
name|newline
argument_list|()
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|HS
operator|.
name|mark
operator|=
name|NULL
expr_stmt|;
name|HS
operator|.
name|end
index|[
literal|0
index|]
operator|=
literal|'\n'
expr_stmt|;
name|HS
operator|.
name|end
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|len
operator|=
name|HS
operator|.
name|end
operator|-
name|HS
operator|.
name|buf
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|len
operator|<=
literal|1
condition|)
block|{
name|HS
operator|.
name|curhist
operator|=
name|HS
operator|.
name|histcount
expr_stmt|;
name|HS
operator|.
name|linelen
operator|=
literal|1
expr_stmt|;
return|return;
block|}
name|HS
operator|.
name|curhist
operator|=
name|HS
operator|.
name|histcount
expr_stmt|;
name|HS
operator|.
name|pos
operator|=
name|HS
operator|.
name|buf
expr_stmt|;
name|HS
operator|.
name|end
operator|=
name|HS
operator|.
name|buf
expr_stmt|;
name|HS
operator|.
name|linelen
operator|=
name|len
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|save_line
parameter_list|()
block|{
name|int
name|len
decl_stmt|;
name|len
operator|=
name|HS
operator|.
name|end
operator|-
name|HS
operator|.
name|buf
expr_stmt|;
if|if
condition|(
name|len
operator|>
literal|0
condition|)
block|{
name|hist_saveline
argument_list|(
name|HS
operator|.
name|buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|flush_input
argument_list|()
expr_stmt|;
block|}
name|HS
operator|.
name|curhist
operator|=
name|HS
operator|.
name|histcount
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|goto_line
parameter_list|()
block|{
name|int
name|num
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
name|HIST
modifier|*
name|hp
decl_stmt|;
name|num
operator|=
literal|0
expr_stmt|;
name|cp
operator|=
name|HS
operator|.
name|buf
expr_stmt|;
while|while
condition|(
operator|(
operator|*
name|cp
operator|>=
literal|'0'
operator|)
operator|&&
operator|(
operator|*
name|cp
operator|<=
literal|'9'
operator|)
operator|&&
operator|(
name|cp
operator|<
name|HS
operator|.
name|pos
operator|)
condition|)
name|num
operator|=
name|num
operator|*
literal|10
operator|+
operator|(
operator|*
name|cp
operator|++
operator|-
literal|'0'
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|num
operator|<=
literal|0
operator|)
operator|||
operator|(
name|num
operator|>
name|HS
operator|.
name|histcount
operator|)
operator|||
operator|(
name|cp
operator|!=
name|HS
operator|.
name|pos
operator|)
condition|)
block|{
name|beep
argument_list|()
expr_stmt|;
return|return;
block|}
name|flush_input
argument_list|()
expr_stmt|;
name|HS
operator|.
name|curhist
operator|=
name|HS
operator|.
name|histcount
operator|-
name|num
expr_stmt|;
name|hp
operator|=
name|get_event
argument_list|(
name|HS
operator|.
name|curhist
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|HS
operator|.
name|buf
argument_list|,
name|hp
operator|->
name|data
argument_list|,
name|hp
operator|->
name|len
argument_list|)
expr_stmt|;
name|HS
operator|.
name|end
operator|=
operator|&
name|HS
operator|.
name|buf
index|[
name|hp
operator|->
name|len
index|]
expr_stmt|;
name|goto_end_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|forward_history
parameter_list|()
block|{
name|HIST
modifier|*
name|hp
decl_stmt|;
name|flush_input
argument_list|()
expr_stmt|;
if|if
condition|(
operator|++
name|HS
operator|.
name|curhist
operator|>=
name|HS
operator|.
name|histcount
condition|)
name|HS
operator|.
name|curhist
operator|=
literal|0
expr_stmt|;
name|hp
operator|=
name|get_event
argument_list|(
name|HS
operator|.
name|curhist
argument_list|)
expr_stmt|;
if|if
condition|(
name|hp
condition|)
block|{
name|memcpy
argument_list|(
name|HS
operator|.
name|buf
argument_list|,
name|hp
operator|->
name|data
argument_list|,
name|hp
operator|->
name|len
argument_list|)
expr_stmt|;
name|HS
operator|.
name|end
operator|=
operator|&
name|HS
operator|.
name|buf
index|[
name|hp
operator|->
name|len
index|]
expr_stmt|;
block|}
name|goto_end_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|backward_history
parameter_list|()
block|{
name|HIST
modifier|*
name|hp
decl_stmt|;
name|flush_input
argument_list|()
expr_stmt|;
if|if
condition|(
operator|--
name|HS
operator|.
name|curhist
operator|<
literal|0
condition|)
name|HS
operator|.
name|curhist
operator|=
name|HS
operator|.
name|histcount
operator|-
literal|1
expr_stmt|;
name|hp
operator|=
name|get_event
argument_list|(
name|HS
operator|.
name|curhist
argument_list|)
expr_stmt|;
if|if
condition|(
name|hp
condition|)
block|{
name|memcpy
argument_list|(
name|HS
operator|.
name|buf
argument_list|,
name|hp
operator|->
name|data
argument_list|,
name|hp
operator|->
name|len
argument_list|)
expr_stmt|;
name|HS
operator|.
name|end
operator|=
operator|&
name|HS
operator|.
name|buf
index|[
name|hp
operator|->
name|len
index|]
expr_stmt|;
block|}
name|goto_end_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|insert_char
parameter_list|(
name|key
parameter_list|)
block|{
name|int
name|len
decl_stmt|;
name|int
name|rest
decl_stmt|;
name|len
operator|=
name|HS
operator|.
name|end
operator|-
name|HS
operator|.
name|buf
expr_stmt|;
if|if
condition|(
name|len
operator|>=
name|HS
operator|.
name|bufsize
condition|)
block|{
name|beep
argument_list|()
expr_stmt|;
return|return;
block|}
name|rest
operator|=
name|HS
operator|.
name|end
operator|-
name|HS
operator|.
name|pos
expr_stmt|;
if|if
condition|(
name|rest
operator|>
literal|0
condition|)
name|memrcpy
argument_list|(
name|HS
operator|.
name|pos
operator|+
literal|1
argument_list|,
name|HS
operator|.
name|pos
argument_list|,
name|rest
argument_list|)
expr_stmt|;
name|HS
operator|.
name|end
operator|++
expr_stmt|;
operator|*
name|HS
operator|.
name|pos
operator|++
operator|=
name|key
expr_stmt|;
name|echo_char
argument_list|(
name|key
argument_list|)
expr_stmt|;
name|echo_rest_of_line
argument_list|()
expr_stmt|;
while|while
condition|(
name|rest
operator|>
literal|0
condition|)
name|back_over_char
argument_list|(
name|HS
operator|.
name|pos
index|[
operator|--
name|rest
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|insert_string
parameter_list|(
name|str
parameter_list|,
name|len
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|int
name|rest
decl_stmt|;
name|int
name|totallen
decl_stmt|;
if|if
condition|(
name|len
operator|<=
literal|0
condition|)
return|return;
name|totallen
operator|=
operator|(
name|HS
operator|.
name|end
operator|-
name|HS
operator|.
name|buf
operator|)
operator|+
name|len
expr_stmt|;
if|if
condition|(
name|totallen
operator|>
name|HS
operator|.
name|bufsize
condition|)
block|{
name|beep
argument_list|()
expr_stmt|;
return|return;
block|}
name|rest
operator|=
name|HS
operator|.
name|end
operator|-
name|HS
operator|.
name|pos
expr_stmt|;
if|if
condition|(
name|rest
operator|>
literal|0
condition|)
name|memrcpy
argument_list|(
name|HS
operator|.
name|pos
operator|+
name|len
argument_list|,
name|HS
operator|.
name|pos
argument_list|,
name|rest
argument_list|)
expr_stmt|;
name|HS
operator|.
name|end
operator|+=
name|len
expr_stmt|;
name|memcpy
argument_list|(
name|HS
operator|.
name|pos
argument_list|,
name|str
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|HS
operator|.
name|pos
operator|+=
name|len
expr_stmt|;
name|echo_string
argument_list|(
name|str
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|echo_rest_of_line
argument_list|()
expr_stmt|;
while|while
condition|(
name|rest
operator|>
literal|0
condition|)
name|back_over_char
argument_list|(
name|HS
operator|.
name|pos
index|[
operator|--
name|rest
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|list_history
parameter_list|()
block|{
name|HIST
modifier|*
name|hp
decl_stmt|;
name|int
name|num
decl_stmt|;
for|for
control|(
name|num
operator|=
literal|0
init|;
name|num
operator|<
name|HS
operator|.
name|histcount
condition|;
name|num
operator|++
control|)
block|{
name|hp
operator|=
name|get_event
argument_list|(
name|num
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n%3d: "
argument_list|,
name|HS
operator|.
name|histcount
operator|-
name|num
argument_list|)
expr_stmt|;
name|echo_string
argument_list|(
name|hp
operator|->
name|data
argument_list|,
name|hp
operator|->
name|len
argument_list|)
expr_stmt|;
block|}
name|refresh_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|refresh_line
parameter_list|()
block|{
name|char
modifier|*
name|cp
decl_stmt|;
name|newline
argument_list|()
expr_stmt|;
name|fputs
argument_list|(
name|HS
operator|.
name|prompt
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
name|HS
operator|.
name|end
operator|>
name|HS
operator|.
name|buf
condition|)
block|{
name|echo_string
argument_list|(
name|HS
operator|.
name|buf
argument_list|,
name|HS
operator|.
name|end
operator|-
name|HS
operator|.
name|buf
argument_list|)
expr_stmt|;
name|cp
operator|=
name|HS
operator|.
name|end
expr_stmt|;
while|while
condition|(
name|cp
operator|>
name|HS
operator|.
name|pos
condition|)
name|back_over_char
argument_list|(
operator|*
operator|--
name|cp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|swap_chars
parameter_list|()
block|{
name|char
name|ch1
decl_stmt|;
name|char
name|ch2
decl_stmt|;
if|if
condition|(
operator|(
name|HS
operator|.
name|pos
operator|<=
name|HS
operator|.
name|buf
operator|)
operator|||
operator|(
name|HS
operator|.
name|pos
operator|>=
name|HS
operator|.
name|end
operator|)
condition|)
return|return;
name|ch1
operator|=
operator|*
name|HS
operator|.
name|pos
operator|--
expr_stmt|;
name|ch2
operator|=
operator|*
name|HS
operator|.
name|pos
expr_stmt|;
operator|*
name|HS
operator|.
name|pos
operator|++
operator|=
name|ch1
expr_stmt|;
operator|*
name|HS
operator|.
name|pos
operator|=
name|ch2
expr_stmt|;
name|back_over_char
argument_list|(
name|ch2
argument_list|)
expr_stmt|;
name|echo_char
argument_list|(
name|ch1
argument_list|)
expr_stmt|;
name|echo_char
argument_list|(
name|ch2
argument_list|)
expr_stmt|;
name|back_over_char
argument_list|(
name|ch2
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|set_mark
parameter_list|()
block|{
name|HS
operator|.
name|mark
operator|=
name|HS
operator|.
name|pos
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|save_region
parameter_list|()
block|{
name|int
name|len
decl_stmt|;
if|if
condition|(
name|HS
operator|.
name|mark
operator|==
name|NULL
condition|)
return|return;
name|len
operator|=
name|HS
operator|.
name|mark
operator|-
name|HS
operator|.
name|pos
expr_stmt|;
if|if
condition|(
name|len
operator|>
literal|0
condition|)
name|savetext
argument_list|(
name|HS
operator|.
name|pos
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<
literal|0
condition|)
name|savetext
argument_list|(
name|HS
operator|.
name|mark
argument_list|,
operator|-
name|len
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|kill_region
parameter_list|()
block|{
name|char
modifier|*
name|cp
decl_stmt|;
name|char
modifier|*
name|left
decl_stmt|;
name|char
modifier|*
name|right
decl_stmt|;
if|if
condition|(
operator|(
name|HS
operator|.
name|mark
operator|==
name|NULL
operator|)
operator|||
operator|(
name|HS
operator|.
name|mark
operator|==
name|HS
operator|.
name|pos
operator|)
condition|)
return|return;
name|echo_rest_of_line
argument_list|()
expr_stmt|;
if|if
condition|(
name|HS
operator|.
name|mark
operator|<
name|HS
operator|.
name|pos
condition|)
block|{
name|left
operator|=
name|HS
operator|.
name|mark
expr_stmt|;
name|right
operator|=
name|HS
operator|.
name|pos
expr_stmt|;
name|HS
operator|.
name|pos
operator|=
name|HS
operator|.
name|mark
expr_stmt|;
block|}
else|else
block|{
name|left
operator|=
name|HS
operator|.
name|pos
expr_stmt|;
name|right
operator|=
name|HS
operator|.
name|mark
expr_stmt|;
name|HS
operator|.
name|mark
operator|=
name|HS
operator|.
name|pos
expr_stmt|;
block|}
name|savetext
argument_list|(
name|left
argument_list|,
name|right
operator|-
name|left
argument_list|)
expr_stmt|;
for|for
control|(
name|cp
operator|=
name|HS
operator|.
name|end
init|;
name|cp
operator|>
name|left
condition|;
control|)
name|remove_char
argument_list|(
operator|*
operator|--
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
name|right
operator|<
name|HS
operator|.
name|end
condition|)
name|memcpy
argument_list|(
name|left
argument_list|,
name|right
argument_list|,
name|HS
operator|.
name|end
operator|-
name|right
argument_list|)
expr_stmt|;
name|decrement_end
argument_list|(
name|right
operator|-
name|left
argument_list|)
expr_stmt|;
name|echo_rest_of_line
argument_list|()
expr_stmt|;
for|for
control|(
name|cp
operator|=
name|HS
operator|.
name|end
init|;
name|cp
operator|>
name|HS
operator|.
name|pos
condition|;
control|)
name|back_over_char
argument_list|(
operator|*
operator|--
name|cp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|yank
parameter_list|()
block|{
name|insert_string
argument_list|(
name|save_buffer
argument_list|,
name|save_len
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|reverse_search
parameter_list|()
block|{
name|int
name|len
decl_stmt|;
name|int
name|count
decl_stmt|;
name|int
name|testhist
decl_stmt|;
name|HIST
modifier|*
name|hp
decl_stmt|;
name|char
modifier|*
name|save_pos
decl_stmt|;
name|count
operator|=
name|HS
operator|.
name|histcount
expr_stmt|;
name|len
operator|=
name|HS
operator|.
name|pos
operator|-
name|HS
operator|.
name|buf
expr_stmt|;
if|if
condition|(
name|len
operator|<=
literal|0
condition|)
name|count
operator|=
literal|0
expr_stmt|;
name|testhist
operator|=
name|HS
operator|.
name|curhist
expr_stmt|;
do|do
block|{
if|if
condition|(
operator|--
name|count
operator|<
literal|0
condition|)
block|{
name|beep
argument_list|()
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|--
name|testhist
operator|<
literal|0
condition|)
name|testhist
operator|=
name|HS
operator|.
name|histcount
operator|-
literal|1
expr_stmt|;
name|hp
operator|=
name|get_event
argument_list|(
name|testhist
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|hp
operator|==
name|NULL
operator|)
operator|||
operator|(
name|hp
operator|->
name|len
operator|<
name|len
operator|)
operator|||
name|memcmp
argument_list|(
name|hp
operator|->
name|data
argument_list|,
name|HS
operator|.
name|buf
argument_list|,
name|len
argument_list|)
condition|)
do|;
name|HS
operator|.
name|curhist
operator|=
name|testhist
expr_stmt|;
name|save_pos
operator|=
name|HS
operator|.
name|pos
expr_stmt|;
name|flush_input
argument_list|()
expr_stmt|;
name|memcpy
argument_list|(
name|HS
operator|.
name|buf
argument_list|,
name|hp
operator|->
name|data
argument_list|,
name|hp
operator|->
name|len
argument_list|)
expr_stmt|;
name|HS
operator|.
name|end
operator|=
operator|&
name|HS
operator|.
name|buf
index|[
name|hp
operator|->
name|len
index|]
expr_stmt|;
name|goto_end_of_line
argument_list|()
expr_stmt|;
while|while
condition|(
name|HS
operator|.
name|pos
operator|>
name|save_pos
condition|)
name|back_over_char
argument_list|(
operator|*
operator|--
name|HS
operator|.
name|pos
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|quote_char
parameter_list|()
block|{
name|int
name|ch
decl_stmt|;
name|ch
operator|=
name|fgetc
argument_list|(
name|stdin
argument_list|)
expr_stmt|;
if|if
condition|(
name|ch
operator|!=
name|EOF
condition|)
name|insert_char
argument_list|(
name|ch
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Save data in the save buffer.  */
end_comment

begin_function
specifier|static
name|void
name|savetext
parameter_list|(
name|str
parameter_list|,
name|len
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|save_len
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|len
operator|<=
literal|0
condition|)
return|return;
if|if
condition|(
name|len
operator|>
name|SAVE_SIZE
condition|)
name|len
operator|=
name|SAVE_SIZE
expr_stmt|;
name|memcpy
argument_list|(
name|save_buffer
argument_list|,
name|str
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|save_len
operator|=
name|len
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Test whether a character is part of a word.  */
end_comment

begin_function
specifier|static
name|int
name|in_word
parameter_list|(
name|ch
parameter_list|)
name|char
name|ch
decl_stmt|;
block|{
return|return
operator|(
name|isalnum
argument_list|(
name|ch
argument_list|)
operator|||
operator|(
name|ch
operator|==
literal|'_'
operator|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|erasechar
parameter_list|()
block|{
name|fputs
argument_list|(
literal|"\b \b"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|newline
parameter_list|()
block|{
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|backspace
parameter_list|()
block|{
name|fputc
argument_list|(
literal|'\b'
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|beep
parameter_list|()
block|{
name|fputc
argument_list|(
literal|'\007'
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|echo_char
parameter_list|(
name|ch
parameter_list|)
block|{
if|if
condition|(
name|isprint
argument_list|(
name|ch
argument_list|)
condition|)
name|putchar
argument_list|(
name|ch
argument_list|)
expr_stmt|;
else|else
block|{
name|putchar
argument_list|(
literal|'^'
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
operator|(
name|ch
operator|+
literal|'@'
operator|)
operator|&
literal|0x7f
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|echo_string
parameter_list|(
name|str
parameter_list|,
name|len
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
while|while
condition|(
name|len
operator|--
operator|>
literal|0
condition|)
name|echo_char
argument_list|(
operator|*
name|str
operator|++
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|memrcpy
parameter_list|(
name|dest
parameter_list|,
name|src
parameter_list|,
name|len
parameter_list|)
name|char
modifier|*
name|dest
decl_stmt|,
decl|*
name|src
decl_stmt|;
end_function

begin_block
block|{
name|dest
operator|+=
name|len
operator|-
literal|1
expr_stmt|;
name|src
operator|+=
name|len
operator|-
literal|1
expr_stmt|;
while|while
condition|(
name|len
operator|--
operator|>
literal|0
condition|)
operator|*
name|dest
operator|--
operator|=
operator|*
name|src
operator|--
expr_stmt|;
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|HIST_TEST
end_ifdef

begin_comment
comment|/*  * Main routine to test history.  */
end_comment

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
name|argv
index|[]
decl_stmt|;
block|{
name|char
modifier|*
name|filename
decl_stmt|;
name|int
name|len
decl_stmt|;
name|char
name|buf
index|[
literal|256
index|]
decl_stmt|;
name|filename
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|argc
operator|>
literal|1
condition|)
name|filename
operator|=
name|argv
index|[
literal|1
index|]
expr_stmt|;
switch|switch
condition|(
name|hist_init
argument_list|(
name|filename
argument_list|)
condition|)
block|{
case|case
name|HIST_SUCCESS
case|:
break|break;
case|case
name|HIST_NOFILE
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Binding file was not found\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|HIST_NOTTY
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Cannot set terminal parameters\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|HIST_INITED
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Hist is already inited\n"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Unknown error from hist_init\n"
argument_list|)
expr_stmt|;
break|break;
block|}
do|do
block|{
name|len
operator|=
name|hist_getline
argument_list|(
literal|"HIST> "
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|hist_saveline
argument_list|(
name|buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|len
operator|&&
operator|(
name|buf
index|[
literal|0
index|]
operator|!=
literal|'q'
operator|)
condition|)
do|;
name|hist_term
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* END CODE */
end_comment

end_unit

