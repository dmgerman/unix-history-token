begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1993 David I. Bell  * Permission is granted to use, distribute, or modify this source,  * provided that this copyright notice remains intact.  *  * "Object" handling primatives.  * This simply means that user-specified routines are called to perform  * the indicated operations.  */
end_comment

begin_include
include|#
directive|include
file|"calc.h"
end_include

begin_include
include|#
directive|include
file|"opcodes.h"
end_include

begin_include
include|#
directive|include
file|"func.h"
end_include

begin_include
include|#
directive|include
file|"symbol.h"
end_include

begin_include
include|#
directive|include
file|"string.h"
end_include

begin_comment
comment|/*  * Types of values returned by calling object routines.  */
end_comment

begin_define
define|#
directive|define
name|A_VALUE
value|0
end_define

begin_comment
comment|/* returns arbitrary value */
end_comment

begin_define
define|#
directive|define
name|A_INT
value|1
end_define

begin_comment
comment|/* returns integer value */
end_comment

begin_define
define|#
directive|define
name|A_UNDEF
value|2
end_define

begin_comment
comment|/* returns no value */
end_comment

begin_comment
comment|/*  * Error handling actions for when the function is undefined.  */
end_comment

begin_define
define|#
directive|define
name|E_NONE
value|0
end_define

begin_comment
comment|/* no special action */
end_comment

begin_define
define|#
directive|define
name|E_PRINT
value|1
end_define

begin_comment
comment|/* print element */
end_comment

begin_define
define|#
directive|define
name|E_CMP
value|2
end_define

begin_comment
comment|/* compare two values */
end_comment

begin_define
define|#
directive|define
name|E_TEST
value|3
end_define

begin_comment
comment|/* test value for nonzero */
end_comment

begin_define
define|#
directive|define
name|E_POW
value|4
end_define

begin_comment
comment|/* call generic power routine */
end_comment

begin_define
define|#
directive|define
name|E_ONE
value|5
end_define

begin_comment
comment|/* return number 1 */
end_comment

begin_define
define|#
directive|define
name|E_INC
value|6
end_define

begin_comment
comment|/* increment by one */
end_comment

begin_define
define|#
directive|define
name|E_DEC
value|7
end_define

begin_comment
comment|/* decrement by one */
end_comment

begin_define
define|#
directive|define
name|E_SQUARE
value|8
end_define

begin_comment
comment|/* square value */
end_comment

begin_struct
specifier|static
struct|struct
name|objectinfo
block|{
name|short
name|args
decl_stmt|;
comment|/* number of arguments */
name|short
name|retval
decl_stmt|;
comment|/* type of return value */
name|short
name|error
decl_stmt|;
comment|/* special action on errors */
name|char
modifier|*
name|name
decl_stmt|;
comment|/* name of function to call */
name|char
modifier|*
name|comment
decl_stmt|;
comment|/* useful comment if any */
block|}
name|objectinfo
index|[]
init|=
block|{
literal|1
block|,
name|A_UNDEF
block|,
name|E_PRINT
block|,
literal|"print"
block|,
literal|"print value, default prints elements"
block|,
literal|1
block|,
name|A_VALUE
block|,
name|E_ONE
block|,
literal|"one"
block|,
literal|"multiplicative identity, default is 1"
block|,
literal|1
block|,
name|A_INT
block|,
name|E_TEST
block|,
literal|"test"
block|,
literal|"logical test (false,true => 0,1), default tests elements"
block|,
literal|2
block|,
name|A_VALUE
block|,
name|E_NONE
block|,
literal|"add"
block|,
name|NULL
block|,
literal|2
block|,
name|A_VALUE
block|,
name|E_NONE
block|,
literal|"sub"
block|,
name|NULL
block|,
literal|1
block|,
name|A_VALUE
block|,
name|E_NONE
block|,
literal|"neg"
block|,
literal|"negative"
block|,
literal|2
block|,
name|A_VALUE
block|,
name|E_NONE
block|,
literal|"mul"
block|,
name|NULL
block|,
literal|2
block|,
name|A_VALUE
block|,
name|E_NONE
block|,
literal|"div"
block|,
literal|"non-integral division"
block|,
literal|1
block|,
name|A_VALUE
block|,
name|E_NONE
block|,
literal|"inv"
block|,
literal|"multiplicative inverse"
block|,
literal|2
block|,
name|A_VALUE
block|,
name|E_NONE
block|,
literal|"abs"
block|,
literal|"absolute value within given error"
block|,
literal|1
block|,
name|A_VALUE
block|,
name|E_NONE
block|,
literal|"norm"
block|,
literal|"square of absolute value"
block|,
literal|1
block|,
name|A_VALUE
block|,
name|E_NONE
block|,
literal|"conj"
block|,
literal|"conjugate"
block|,
literal|2
block|,
name|A_VALUE
block|,
name|E_POW
block|,
literal|"pow"
block|,
literal|"integer power, default does multiply, square, inverse"
block|,
literal|1
block|,
name|A_INT
block|,
name|E_NONE
block|,
literal|"sgn"
block|,
literal|"sign of value (-1, 0, 1)"
block|,
literal|2
block|,
name|A_INT
block|,
name|E_CMP
block|,
literal|"cmp"
block|,
literal|"equality (equal,nonequal => 0,1), default tests elements"
block|,
literal|2
block|,
name|A_INT
block|,
name|E_NONE
block|,
literal|"rel"
block|,
literal|"inequality (less,equal,greater => -1,0,1)"
block|,
literal|2
block|,
name|A_VALUE
block|,
name|E_NONE
block|,
literal|"quo"
block|,
literal|"integer quotient"
block|,
literal|2
block|,
name|A_VALUE
block|,
name|E_NONE
block|,
literal|"mod"
block|,
literal|"remainder of division"
block|,
literal|1
block|,
name|A_VALUE
block|,
name|E_NONE
block|,
literal|"int"
block|,
literal|"integer part"
block|,
literal|1
block|,
name|A_VALUE
block|,
name|E_NONE
block|,
literal|"frac"
block|,
literal|"fractional part"
block|,
literal|1
block|,
name|A_VALUE
block|,
name|E_INC
block|,
literal|"inc"
block|,
literal|"increment, default adds 1"
block|,
literal|1
block|,
name|A_VALUE
block|,
name|E_DEC
block|,
literal|"dec"
block|,
literal|"decrement, default subtracts 1"
block|,
literal|1
block|,
name|A_VALUE
block|,
name|E_SQUARE
block|,
literal|"square"
block|,
literal|"default multiplies by itself"
block|,
literal|2
block|,
name|A_VALUE
block|,
name|E_NONE
block|,
literal|"scale"
block|,
literal|"multiply by power of 2"
block|,
literal|2
block|,
name|A_VALUE
block|,
name|E_NONE
block|,
literal|"shift"
block|,
literal|"shift left by n bits (right if negative)"
block|,
literal|2
block|,
name|A_VALUE
block|,
name|E_NONE
block|,
literal|"round"
block|,
literal|"round to given number of decimal places"
block|,
literal|2
block|,
name|A_VALUE
block|,
name|E_NONE
block|,
literal|"bround"
block|,
literal|"round to given number of binary places"
block|,
literal|3
block|,
name|A_VALUE
block|,
name|E_NONE
block|,
literal|"root"
block|,
literal|"root of value within given error"
block|,
literal|2
block|,
name|A_VALUE
block|,
name|E_NONE
block|,
literal|"sqrt"
block|,
literal|"square root within given error"
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|NULL
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|STRINGHEAD
name|objectnames
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* names of objects */
end_comment

begin_decl_stmt
specifier|static
name|STRINGHEAD
name|elements
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* element names for parts of objects */
end_comment

begin_decl_stmt
specifier|static
name|OBJECTACTIONS
modifier|*
name|objects
index|[
name|MAXOBJECTS
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* table of actions for objects */
end_comment

begin_comment
comment|/*  * Free list of usual small objects.  */
end_comment

begin_decl_stmt
specifier|static
name|FREELIST
name|freelist
init|=
block|{
sizeof|sizeof
argument_list|(
name|OBJECT
argument_list|)
block|,
comment|/* size of typical objects */
literal|100
comment|/* number of free objects to keep */
block|}
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|VALUE
name|objpowi
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|BOOL
name|objtest
argument_list|()
decl_stmt|,
name|objcmp
argument_list|()
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|objprint
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/*  * Show all the routine names available for objects.  */
end_comment

begin_function
name|void
name|showobjfuncs
parameter_list|()
block|{
specifier|register
name|struct
name|objectinfo
modifier|*
name|oip
decl_stmt|;
name|printf
argument_list|(
literal|"\nThe following object routines are definable.\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Note: xx represents the actual object type name.\n\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Name	Args	Comments\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|oip
operator|=
name|objectinfo
init|;
name|oip
operator|->
name|name
condition|;
name|oip
operator|++
control|)
block|{
name|printf
argument_list|(
literal|"xx_%-8s %d	%s\n"
argument_list|,
name|oip
operator|->
name|name
argument_list|,
name|oip
operator|->
name|args
argument_list|,
name|oip
operator|->
name|comment
condition|?
name|oip
operator|->
name|comment
else|:
literal|""
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Call the appropriate user-defined routine to handle an object action.  * Returns the value that the routine returned.  */
end_comment

begin_comment
comment|/*VARARGS*/
end_comment

begin_function
name|VALUE
name|objcall
parameter_list|(
name|action
parameter_list|,
name|v1
parameter_list|,
name|v2
parameter_list|,
name|v3
parameter_list|)
name|VALUE
modifier|*
name|v1
decl_stmt|,
decl|*
name|v2
decl_stmt|,
modifier|*
name|v3
decl_stmt|;
end_function

begin_block
block|{
name|FUNC
modifier|*
name|fp
decl_stmt|;
comment|/* function to call */
name|OBJECTACTIONS
modifier|*
name|oap
decl_stmt|;
comment|/* object to call for */
name|struct
name|objectinfo
modifier|*
name|oip
decl_stmt|;
comment|/* information about action */
name|long
name|index
decl_stmt|;
comment|/* index of function (negative if undefined) */
name|VALUE
name|val
decl_stmt|;
comment|/* return value */
name|VALUE
name|tmp
decl_stmt|;
comment|/* temp value */
name|char
name|name
index|[
name|SYMBOLSIZE
operator|+
literal|1
index|]
decl_stmt|;
comment|/* full name of user routine to call */
if|if
condition|(
operator|(
name|unsigned
operator|)
name|action
operator|>
name|OBJ_MAXFUNC
condition|)
name|error
argument_list|(
literal|"Illegal action for object call"
argument_list|)
expr_stmt|;
name|oip
operator|=
operator|&
name|objectinfo
index|[
name|action
index|]
expr_stmt|;
if|if
condition|(
name|v1
operator|->
name|v_type
operator|==
name|V_OBJ
condition|)
name|oap
operator|=
name|v1
operator|->
name|v_obj
operator|->
name|o_actions
expr_stmt|;
elseif|else
if|if
condition|(
name|v2
operator|->
name|v_type
operator|==
name|V_OBJ
condition|)
name|oap
operator|=
name|v2
operator|->
name|v_obj
operator|->
name|o_actions
expr_stmt|;
else|else
name|error
argument_list|(
literal|"Object routine called with non-object"
argument_list|)
expr_stmt|;
name|index
operator|=
name|oap
operator|->
name|actions
index|[
name|action
index|]
expr_stmt|;
if|if
condition|(
name|index
operator|==
literal|0
condition|)
block|{
name|strcpy
argument_list|(
name|name
argument_list|,
name|oap
operator|->
name|name
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|name
argument_list|,
literal|"_"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|name
argument_list|,
name|oip
operator|->
name|name
argument_list|)
expr_stmt|;
name|index
operator|=
name|adduserfunc
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|oap
operator|->
name|actions
index|[
name|action
index|]
operator|=
name|index
expr_stmt|;
block|}
name|fp
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|index
operator|>
literal|0
condition|)
name|fp
operator|=
name|findfunc
argument_list|(
name|index
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|==
name|NULL
condition|)
block|{
switch|switch
condition|(
name|oip
operator|->
name|error
condition|)
block|{
case|case
name|E_PRINT
case|:
name|objprint
argument_list|(
name|v1
operator|->
name|v_obj
argument_list|)
expr_stmt|;
name|val
operator|.
name|v_type
operator|=
name|V_NULL
expr_stmt|;
break|break;
case|case
name|E_CMP
case|:
name|val
operator|.
name|v_type
operator|=
name|V_INT
expr_stmt|;
if|if
condition|(
name|v1
operator|->
name|v_type
operator|!=
name|v2
operator|->
name|v_type
condition|)
block|{
name|val
operator|.
name|v_int
operator|=
literal|1
expr_stmt|;
return|return
name|val
return|;
block|}
name|val
operator|.
name|v_int
operator|=
name|objcmp
argument_list|(
name|v1
operator|->
name|v_obj
argument_list|,
name|v2
operator|->
name|v_obj
argument_list|)
expr_stmt|;
break|break;
case|case
name|E_TEST
case|:
name|val
operator|.
name|v_type
operator|=
name|V_INT
expr_stmt|;
name|val
operator|.
name|v_int
operator|=
name|objtest
argument_list|(
name|v1
operator|->
name|v_obj
argument_list|)
expr_stmt|;
break|break;
case|case
name|E_POW
case|:
if|if
condition|(
name|v2
operator|->
name|v_type
operator|!=
name|V_NUM
condition|)
name|error
argument_list|(
literal|"Non-real power"
argument_list|)
expr_stmt|;
name|val
operator|=
name|objpowi
argument_list|(
name|v1
argument_list|,
name|v2
operator|->
name|v_num
argument_list|)
expr_stmt|;
break|break;
case|case
name|E_ONE
case|:
name|val
operator|.
name|v_type
operator|=
name|V_NUM
expr_stmt|;
name|val
operator|.
name|v_num
operator|=
name|qlink
argument_list|(
operator|&
name|_qone_
argument_list|)
expr_stmt|;
break|break;
case|case
name|E_INC
case|:
name|tmp
operator|.
name|v_type
operator|=
name|V_NUM
expr_stmt|;
name|tmp
operator|.
name|v_num
operator|=
operator|&
name|_qone_
expr_stmt|;
name|val
operator|=
name|objcall
argument_list|(
name|OBJ_ADD
argument_list|,
name|v1
argument_list|,
operator|&
name|tmp
argument_list|)
expr_stmt|;
break|break;
case|case
name|E_DEC
case|:
name|tmp
operator|.
name|v_type
operator|=
name|V_NUM
expr_stmt|;
name|tmp
operator|.
name|v_num
operator|=
operator|&
name|_qone_
expr_stmt|;
name|val
operator|=
name|objcall
argument_list|(
name|OBJ_SUB
argument_list|,
name|v1
argument_list|,
operator|&
name|tmp
argument_list|)
expr_stmt|;
break|break;
case|case
name|E_SQUARE
case|:
name|val
operator|=
name|objcall
argument_list|(
name|OBJ_MUL
argument_list|,
name|v1
argument_list|,
name|v1
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
argument_list|(
literal|"Function \"%s\" is undefined"
argument_list|,
name|namefunc
argument_list|(
name|index
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|val
return|;
block|}
switch|switch
condition|(
name|oip
operator|->
name|args
condition|)
block|{
case|case
literal|0
case|:
break|break;
case|case
literal|1
case|:
operator|++
name|stack
expr_stmt|;
name|stack
operator|->
name|v_addr
operator|=
name|v1
expr_stmt|;
name|stack
operator|->
name|v_type
operator|=
name|V_ADDR
expr_stmt|;
break|break;
case|case
literal|2
case|:
operator|++
name|stack
expr_stmt|;
name|stack
operator|->
name|v_addr
operator|=
name|v1
expr_stmt|;
name|stack
operator|->
name|v_type
operator|=
name|V_ADDR
expr_stmt|;
operator|++
name|stack
expr_stmt|;
name|stack
operator|->
name|v_addr
operator|=
name|v2
expr_stmt|;
name|stack
operator|->
name|v_type
operator|=
name|V_ADDR
expr_stmt|;
break|break;
case|case
literal|3
case|:
operator|++
name|stack
expr_stmt|;
name|stack
operator|->
name|v_addr
operator|=
name|v1
expr_stmt|;
name|stack
operator|->
name|v_type
operator|=
name|V_ADDR
expr_stmt|;
operator|++
name|stack
expr_stmt|;
name|stack
operator|->
name|v_addr
operator|=
name|v2
expr_stmt|;
name|stack
operator|->
name|v_type
operator|=
name|V_ADDR
expr_stmt|;
operator|++
name|stack
expr_stmt|;
name|stack
operator|->
name|v_addr
operator|=
name|v3
expr_stmt|;
name|stack
operator|->
name|v_type
operator|=
name|V_ADDR
expr_stmt|;
break|break;
default|default:
name|error
argument_list|(
literal|"Bad number of args to calculate"
argument_list|)
expr_stmt|;
block|}
name|calculate
argument_list|(
name|fp
argument_list|,
name|oip
operator|->
name|args
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|oip
operator|->
name|retval
condition|)
block|{
case|case
name|A_VALUE
case|:
return|return
operator|*
name|stack
operator|--
return|;
case|case
name|A_UNDEF
case|:
name|freevalue
argument_list|(
name|stack
operator|--
argument_list|)
expr_stmt|;
name|val
operator|.
name|v_type
operator|=
name|V_NULL
expr_stmt|;
break|break;
case|case
name|A_INT
case|:
if|if
condition|(
operator|(
name|stack
operator|->
name|v_type
operator|!=
name|V_NUM
operator|)
operator|||
name|qisfrac
argument_list|(
name|stack
operator|->
name|v_num
argument_list|)
condition|)
name|error
argument_list|(
literal|"Integer return value required"
argument_list|)
expr_stmt|;
name|index
operator|=
name|qtoi
argument_list|(
name|stack
operator|->
name|v_num
argument_list|)
expr_stmt|;
name|qfree
argument_list|(
name|stack
operator|->
name|v_num
argument_list|)
expr_stmt|;
name|stack
operator|--
expr_stmt|;
name|val
operator|.
name|v_type
operator|=
name|V_INT
expr_stmt|;
name|val
operator|.
name|v_int
operator|=
name|index
expr_stmt|;
break|break;
default|default:
name|error
argument_list|(
literal|"Bad object return"
argument_list|)
expr_stmt|;
block|}
return|return
name|val
return|;
block|}
end_block

begin_comment
comment|/*  * Routine called to clear the cache of known undefined functions for  * the objects.  This changes negative indices back into positive ones  * so that they will all be checked for existence again.  */
end_comment

begin_function
name|void
name|objuncache
parameter_list|()
block|{
specifier|register
name|int
modifier|*
name|ip
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|i
operator|=
name|objectnames
operator|.
name|h_count
expr_stmt|;
while|while
condition|(
operator|--
name|i
operator|>=
literal|0
condition|)
block|{
name|ip
operator|=
name|objects
index|[
name|i
index|]
operator|->
name|actions
expr_stmt|;
for|for
control|(
name|j
operator|=
name|OBJ_MAXFUNC
init|;
name|j
operator|--
operator|>=
literal|0
condition|;
name|ip
operator|++
control|)
if|if
condition|(
operator|*
name|ip
operator|<
literal|0
condition|)
operator|*
name|ip
operator|=
operator|-
operator|*
name|ip
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Print the elements of an object in short and unambiguous format.  * This is the default routine if the user's is not defined.  */
end_comment

begin_function
specifier|static
name|void
name|objprint
parameter_list|(
name|op
parameter_list|)
name|OBJECT
modifier|*
name|op
decl_stmt|;
comment|/* object being printed */
block|{
name|int
name|count
decl_stmt|;
comment|/* number of elements */
name|int
name|i
decl_stmt|;
comment|/* index */
name|count
operator|=
name|op
operator|->
name|o_actions
operator|->
name|count
expr_stmt|;
name|math_fmt
argument_list|(
literal|"obj %s {"
argument_list|,
name|op
operator|->
name|o_actions
operator|->
name|name
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
condition|)
name|math_str
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
name|printvalue
argument_list|(
operator|&
name|op
operator|->
name|o_table
index|[
name|i
index|]
argument_list|,
name|PRINT_SHORT
operator||
name|PRINT_UNAMBIG
argument_list|)
expr_stmt|;
block|}
name|math_chr
argument_list|(
literal|'}'
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Test an object for being "nonzero".  * This is the default routine if the user's is not defined.  * Returns TRUE if any of the elements are "nonzero".  */
end_comment

begin_function
specifier|static
name|BOOL
name|objtest
parameter_list|(
name|op
parameter_list|)
name|OBJECT
modifier|*
name|op
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
comment|/* loop counter */
name|i
operator|=
name|op
operator|->
name|o_actions
operator|->
name|count
expr_stmt|;
while|while
condition|(
operator|--
name|i
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|testvalue
argument_list|(
operator|&
name|op
operator|->
name|o_table
index|[
name|i
index|]
argument_list|)
condition|)
return|return
name|TRUE
return|;
block|}
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/*  * Compare two objects for equality, returning TRUE if they differ.  * This is the default routine if the user's is not defined.  * For equality, all elements must be equal.  */
end_comment

begin_function
specifier|static
name|BOOL
name|objcmp
parameter_list|(
name|op1
parameter_list|,
name|op2
parameter_list|)
name|OBJECT
modifier|*
name|op1
decl_stmt|,
decl|*
name|op2
decl_stmt|;
end_function

begin_block
block|{
name|int
name|i
decl_stmt|;
comment|/* loop counter */
if|if
condition|(
name|op1
operator|->
name|o_actions
operator|!=
name|op2
operator|->
name|o_actions
condition|)
return|return
name|TRUE
return|;
name|i
operator|=
name|op1
operator|->
name|o_actions
operator|->
name|count
expr_stmt|;
while|while
condition|(
operator|--
name|i
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|comparevalue
argument_list|(
operator|&
name|op1
operator|->
name|o_table
index|[
name|i
index|]
argument_list|,
operator|&
name|op2
operator|->
name|o_table
index|[
name|i
index|]
argument_list|)
condition|)
return|return
name|TRUE
return|;
block|}
return|return
name|FALSE
return|;
block|}
end_block

begin_comment
comment|/*  * Raise an object to an integral power.  * This is the default routine if the user's is not defined.  * Negative powers mean the positive power of the inverse.  * Zero means the multiplicative identity.  */
end_comment

begin_function
specifier|static
name|VALUE
name|objpowi
parameter_list|(
name|vp
parameter_list|,
name|q
parameter_list|)
name|VALUE
modifier|*
name|vp
decl_stmt|;
comment|/* value to be powered */
name|NUMBER
modifier|*
name|q
decl_stmt|;
comment|/* power to raise number to */
block|{
name|VALUE
name|res
decl_stmt|,
name|tmp
decl_stmt|;
name|long
name|power
decl_stmt|;
comment|/* power to raise to */
name|unsigned
name|long
name|bit
decl_stmt|;
comment|/* current bit value */
if|if
condition|(
name|qisfrac
argument_list|(
name|q
argument_list|)
condition|)
name|error
argument_list|(
literal|"Raising object to non-integral power"
argument_list|)
expr_stmt|;
if|if
condition|(
name|isbig
argument_list|(
name|q
operator|->
name|num
argument_list|)
condition|)
name|error
argument_list|(
literal|"Raising object to very large power"
argument_list|)
expr_stmt|;
name|power
operator|=
operator|(
name|istiny
argument_list|(
name|q
operator|->
name|num
argument_list|)
condition|?
name|z1tol
argument_list|(
name|q
operator|->
name|num
argument_list|)
else|:
name|z2tol
argument_list|(
name|q
operator|->
name|num
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|qisneg
argument_list|(
name|q
argument_list|)
condition|)
name|power
operator|=
operator|-
name|power
expr_stmt|;
comment|/* 	 * Handle some low powers specially 	 */
if|if
condition|(
operator|(
name|power
operator|<=
literal|2
operator|)
operator|&&
operator|(
name|power
operator|>=
operator|-
literal|2
operator|)
condition|)
block|{
switch|switch
condition|(
operator|(
name|int
operator|)
name|power
condition|)
block|{
case|case
literal|0
case|:
return|return
name|objcall
argument_list|(
name|OBJ_ONE
argument_list|,
name|vp
argument_list|)
return|;
case|case
literal|1
case|:
name|res
operator|.
name|v_obj
operator|=
name|objcopy
argument_list|(
name|vp
operator|->
name|v_obj
argument_list|)
expr_stmt|;
name|res
operator|.
name|v_type
operator|=
name|V_OBJ
expr_stmt|;
return|return
name|res
return|;
case|case
operator|-
literal|1
case|:
return|return
name|objcall
argument_list|(
name|OBJ_INV
argument_list|,
name|vp
argument_list|)
return|;
case|case
literal|2
case|:
return|return
name|objcall
argument_list|(
name|OBJ_SQUARE
argument_list|,
name|vp
argument_list|)
return|;
block|}
block|}
if|if
condition|(
name|power
operator|<
literal|0
condition|)
name|power
operator|=
operator|-
name|power
expr_stmt|;
comment|/* 	 * Compute the power by squaring and multiplying. 	 * This uses the left to right method of power raising. 	 */
name|bit
operator|=
name|TOPFULL
expr_stmt|;
while|while
condition|(
operator|(
name|bit
operator|&
name|power
operator|)
operator|==
literal|0
condition|)
name|bit
operator|>>=
literal|1L
expr_stmt|;
name|bit
operator|>>=
literal|1L
expr_stmt|;
name|res
operator|=
name|objcall
argument_list|(
name|OBJ_SQUARE
argument_list|,
name|vp
argument_list|)
expr_stmt|;
if|if
condition|(
name|bit
operator|&
name|power
condition|)
block|{
name|tmp
operator|=
name|objcall
argument_list|(
name|OBJ_MUL
argument_list|,
operator|&
name|res
argument_list|,
name|vp
argument_list|)
expr_stmt|;
name|objfree
argument_list|(
name|res
operator|.
name|v_obj
argument_list|)
expr_stmt|;
name|res
operator|=
name|tmp
expr_stmt|;
block|}
name|bit
operator|>>=
literal|1L
expr_stmt|;
while|while
condition|(
name|bit
condition|)
block|{
name|tmp
operator|=
name|objcall
argument_list|(
name|OBJ_SQUARE
argument_list|,
operator|&
name|res
argument_list|)
expr_stmt|;
name|objfree
argument_list|(
name|res
operator|.
name|v_obj
argument_list|)
expr_stmt|;
name|res
operator|=
name|tmp
expr_stmt|;
if|if
condition|(
name|bit
operator|&
name|power
condition|)
block|{
name|tmp
operator|=
name|objcall
argument_list|(
name|OBJ_MUL
argument_list|,
operator|&
name|res
argument_list|,
name|vp
argument_list|)
expr_stmt|;
name|objfree
argument_list|(
name|res
operator|.
name|v_obj
argument_list|)
expr_stmt|;
name|res
operator|=
name|tmp
expr_stmt|;
block|}
name|bit
operator|>>=
literal|1L
expr_stmt|;
block|}
if|if
condition|(
name|qisneg
argument_list|(
name|q
argument_list|)
condition|)
block|{
name|tmp
operator|=
name|objcall
argument_list|(
name|OBJ_INV
argument_list|,
operator|&
name|res
argument_list|)
expr_stmt|;
name|objfree
argument_list|(
name|res
operator|.
name|v_obj
argument_list|)
expr_stmt|;
return|return
name|tmp
return|;
block|}
return|return
name|res
return|;
block|}
end_function

begin_comment
comment|/*  * Define a (possibly) new class of objects.  * Returns the index of the object name which identifies it.  * This index can then be used to reference the object actions.  * The list of indexes for the element names is also specified here,  * and the number of elements defined for the object.  */
end_comment

begin_macro
name|defineobject
argument_list|(
argument|name
argument_list|,
argument|indices
argument_list|,
argument|count
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|name
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* name of object type */
end_comment

begin_decl_stmt
name|int
name|indices
index|[]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* table of indices for elements */
end_comment

begin_block
block|{
name|OBJECTACTIONS
modifier|*
name|oap
decl_stmt|;
comment|/* object definition structure */
name|STRINGHEAD
modifier|*
name|hp
decl_stmt|;
name|int
name|index
decl_stmt|;
name|hp
operator|=
operator|&
name|objectnames
expr_stmt|;
if|if
condition|(
name|hp
operator|->
name|h_list
operator|==
name|NULL
condition|)
name|initstr
argument_list|(
name|hp
argument_list|)
expr_stmt|;
name|index
operator|=
name|findstr
argument_list|(
name|hp
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|index
operator|>=
literal|0
condition|)
name|error
argument_list|(
literal|"Object type \"%s\" is already defined"
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|hp
operator|->
name|h_count
operator|>=
name|MAXOBJECTS
condition|)
name|error
argument_list|(
literal|"Too many object types in use"
argument_list|)
expr_stmt|;
name|oap
operator|=
operator|(
name|OBJECTACTIONS
operator|*
operator|)
name|malloc
argument_list|(
name|objectactionsize
argument_list|(
name|count
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|oap
condition|)
name|name
operator|=
name|addstr
argument_list|(
name|hp
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|oap
operator|==
name|NULL
operator|)
operator|||
operator|(
name|name
operator|==
name|NULL
operator|)
condition|)
name|error
argument_list|(
literal|"Cannot allocate object type"
argument_list|)
expr_stmt|;
name|oap
operator|->
name|name
operator|=
name|name
expr_stmt|;
name|oap
operator|->
name|count
operator|=
name|count
expr_stmt|;
for|for
control|(
name|index
operator|=
name|OBJ_MAXFUNC
init|;
name|index
operator|>=
literal|0
condition|;
name|index
operator|--
control|)
name|oap
operator|->
name|actions
index|[
name|index
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|index
operator|=
literal|0
init|;
name|index
operator|<
name|count
condition|;
name|index
operator|++
control|)
name|oap
operator|->
name|elements
index|[
name|index
index|]
operator|=
name|indices
index|[
name|index
index|]
expr_stmt|;
name|index
operator|=
name|findstr
argument_list|(
name|hp
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|objects
index|[
name|index
index|]
operator|=
name|oap
expr_stmt|;
return|return
name|index
return|;
block|}
end_block

begin_comment
comment|/*  * Check an object name to see if it is currently defined.  * If so, the index for the object type is returned.  * If the object name is currently unknown, then -1 is returned.  */
end_comment

begin_macro
name|checkobject
argument_list|(
argument|name
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|name
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|STRINGHEAD
modifier|*
name|hp
decl_stmt|;
name|hp
operator|=
operator|&
name|objectnames
expr_stmt|;
if|if
condition|(
name|hp
operator|->
name|h_list
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
return|return
name|findstr
argument_list|(
name|hp
argument_list|,
name|name
argument_list|)
return|;
block|}
end_block

begin_comment
comment|/*  * Define a (possibly) new element name for an object.  * Returns an index which identifies the element name.  */
end_comment

begin_macro
name|addelement
argument_list|(
argument|name
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|name
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|STRINGHEAD
modifier|*
name|hp
decl_stmt|;
name|int
name|index
decl_stmt|;
name|hp
operator|=
operator|&
name|elements
expr_stmt|;
if|if
condition|(
name|hp
operator|->
name|h_list
operator|==
name|NULL
condition|)
name|initstr
argument_list|(
name|hp
argument_list|)
expr_stmt|;
name|index
operator|=
name|findstr
argument_list|(
name|hp
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|index
operator|>=
literal|0
condition|)
return|return
name|index
return|;
if|if
condition|(
name|addstr
argument_list|(
name|hp
argument_list|,
name|name
argument_list|)
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|"Cannot allocate element name"
argument_list|)
expr_stmt|;
return|return
name|findstr
argument_list|(
name|hp
argument_list|,
name|name
argument_list|)
return|;
block|}
end_block

begin_comment
comment|/*  * Return the index which identifies an element name.  * Returns minus one if the element name is unknown.  */
end_comment

begin_macro
name|findelement
argument_list|(
argument|name
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|name
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* element name */
end_comment

begin_block
block|{
if|if
condition|(
name|elements
operator|.
name|h_list
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
return|return
name|findstr
argument_list|(
operator|&
name|elements
argument_list|,
name|name
argument_list|)
return|;
block|}
end_block

begin_comment
comment|/*  * Return the value table offset to be used for an object element name.  * This converts the element index from the element table into an offset  * into the object value array.  Returns -1 if the element index is unknown.  */
end_comment

begin_macro
name|objoffset
argument_list|(
argument|op
argument_list|,
argument|index
argument_list|)
end_macro

begin_decl_stmt
name|OBJECT
modifier|*
name|op
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|long
name|index
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|OBJECTACTIONS
modifier|*
name|oap
decl_stmt|;
name|int
name|offset
decl_stmt|;
comment|/* offset into value array */
name|oap
operator|=
name|op
operator|->
name|o_actions
expr_stmt|;
for|for
control|(
name|offset
operator|=
name|oap
operator|->
name|count
operator|-
literal|1
init|;
name|offset
operator|>=
literal|0
condition|;
name|offset
operator|--
control|)
block|{
if|if
condition|(
name|oap
operator|->
name|elements
index|[
name|offset
index|]
operator|==
name|index
condition|)
return|return
name|offset
return|;
block|}
return|return
operator|-
literal|1
return|;
block|}
end_block

begin_comment
comment|/*  * Allocate a new object structure with the specified index.  */
end_comment

begin_function
name|OBJECT
modifier|*
name|objalloc
parameter_list|(
name|index
parameter_list|)
name|long
name|index
decl_stmt|;
block|{
name|OBJECTACTIONS
modifier|*
name|oap
decl_stmt|;
name|OBJECT
modifier|*
name|op
decl_stmt|;
name|VALUE
modifier|*
name|vp
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|(
name|unsigned
operator|)
name|index
operator|>=
name|MAXOBJECTS
condition|)
name|error
argument_list|(
literal|"Allocating bad object index"
argument_list|)
expr_stmt|;
name|oap
operator|=
name|objects
index|[
name|index
index|]
expr_stmt|;
if|if
condition|(
name|oap
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|"Object type not defined"
argument_list|)
expr_stmt|;
name|i
operator|=
name|oap
operator|->
name|count
expr_stmt|;
if|if
condition|(
name|i
operator|<
name|USUAL_ELEMENTS
condition|)
name|i
operator|=
name|USUAL_ELEMENTS
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|USUAL_ELEMENTS
condition|)
name|op
operator|=
operator|(
name|OBJECT
operator|*
operator|)
name|allocitem
argument_list|(
operator|&
name|freelist
argument_list|)
expr_stmt|;
else|else
name|op
operator|=
operator|(
name|OBJECT
operator|*
operator|)
name|malloc
argument_list|(
name|objectsize
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|op
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|"Cannot allocate object"
argument_list|)
expr_stmt|;
name|op
operator|->
name|o_actions
operator|=
name|oap
expr_stmt|;
name|vp
operator|=
name|op
operator|->
name|o_table
expr_stmt|;
for|for
control|(
name|i
operator|=
name|oap
operator|->
name|count
init|;
name|i
operator|--
operator|>
literal|0
condition|;
name|vp
operator|++
control|)
name|vp
operator|->
name|v_type
operator|=
name|V_NULL
expr_stmt|;
return|return
name|op
return|;
block|}
end_function

begin_comment
comment|/*  * Free an object structure.  */
end_comment

begin_function
name|void
name|objfree
parameter_list|(
name|op
parameter_list|)
specifier|register
name|OBJECT
modifier|*
name|op
decl_stmt|;
block|{
name|VALUE
modifier|*
name|vp
decl_stmt|;
name|int
name|i
decl_stmt|;
name|vp
operator|=
name|op
operator|->
name|o_table
expr_stmt|;
for|for
control|(
name|i
operator|=
name|op
operator|->
name|o_actions
operator|->
name|count
init|;
name|i
operator|--
operator|>
literal|0
condition|;
name|vp
operator|++
control|)
block|{
if|if
condition|(
name|vp
operator|->
name|v_type
operator|==
name|V_NUM
condition|)
block|{
name|qfree
argument_list|(
name|vp
operator|->
name|v_num
argument_list|)
expr_stmt|;
block|}
else|else
name|freevalue
argument_list|(
name|vp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|op
operator|->
name|o_actions
operator|->
name|count
operator|<=
name|USUAL_ELEMENTS
condition|)
name|freeitem
argument_list|(
operator|&
name|freelist
argument_list|,
operator|(
name|FREEITEM
operator|*
operator|)
name|op
argument_list|)
expr_stmt|;
else|else
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|op
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Copy an object value  */
end_comment

begin_function
name|OBJECT
modifier|*
name|objcopy
parameter_list|(
name|op
parameter_list|)
name|OBJECT
modifier|*
name|op
decl_stmt|;
block|{
name|VALUE
modifier|*
name|v1
decl_stmt|,
modifier|*
name|v2
decl_stmt|;
name|OBJECT
modifier|*
name|np
decl_stmt|;
name|int
name|i
decl_stmt|;
name|i
operator|=
name|op
operator|->
name|o_actions
operator|->
name|count
expr_stmt|;
if|if
condition|(
name|i
operator|<
name|USUAL_ELEMENTS
condition|)
name|i
operator|=
name|USUAL_ELEMENTS
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|USUAL_ELEMENTS
condition|)
name|np
operator|=
operator|(
name|OBJECT
operator|*
operator|)
name|allocitem
argument_list|(
operator|&
name|freelist
argument_list|)
expr_stmt|;
else|else
name|np
operator|=
operator|(
name|OBJECT
operator|*
operator|)
name|malloc
argument_list|(
name|objectsize
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|np
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|"Cannot allocate object"
argument_list|)
expr_stmt|;
name|np
operator|->
name|o_actions
operator|=
name|op
operator|->
name|o_actions
expr_stmt|;
name|v1
operator|=
name|op
operator|->
name|o_table
expr_stmt|;
name|v2
operator|=
name|np
operator|->
name|o_table
expr_stmt|;
for|for
control|(
name|i
operator|=
name|op
operator|->
name|o_actions
operator|->
name|count
init|;
name|i
operator|--
operator|>
literal|0
condition|;
name|v1
operator|++
operator|,
name|v2
operator|++
control|)
block|{
if|if
condition|(
name|v1
operator|->
name|v_type
operator|==
name|V_NUM
condition|)
block|{
name|v2
operator|->
name|v_num
operator|=
name|qlink
argument_list|(
name|v1
operator|->
name|v_num
argument_list|)
expr_stmt|;
name|v2
operator|->
name|v_type
operator|=
name|V_NUM
expr_stmt|;
block|}
else|else
name|copyvalue
argument_list|(
name|v1
argument_list|,
name|v2
argument_list|)
expr_stmt|;
block|}
return|return
name|np
return|;
block|}
end_function

begin_comment
comment|/* END CODE */
end_comment

end_unit

