begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1993 David I. Bell  * Permission is granted to use, distribute, or modify this source,  * provided that this copyright notice remains intact.  *  * Scanf and printf routines for extended precision numbers  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"stdarg.h"
end_include

begin_include
include|#
directive|include
file|"math.h"
end_include

begin_define
define|#
directive|define
name|OUTBUFSIZE
value|200
end_define

begin_comment
comment|/* realloc size for output buffers */
end_comment

begin_define
define|#
directive|define
name|PUTCHAR
parameter_list|(
name|ch
parameter_list|)
value|math_chr(ch)
end_define

begin_define
define|#
directive|define
name|PUTSTR
parameter_list|(
name|str
parameter_list|)
value|math_str(str)
end_define

begin_define
define|#
directive|define
name|PRINTF1
parameter_list|(
name|fmt
parameter_list|,
name|a1
parameter_list|)
value|math_fmt(fmt, a1)
end_define

begin_define
define|#
directive|define
name|PRINTF2
parameter_list|(
name|fmt
parameter_list|,
name|a1
parameter_list|,
name|a2
parameter_list|)
value|math_fmt(fmt, a1, a2)
end_define

begin_decl_stmt
name|long
name|_outdigits_
init|=
literal|20
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* default digits for output */
end_comment

begin_decl_stmt
name|int
name|_outmode_
init|=
name|MODE_INITIAL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* default output mode */
end_comment

begin_comment
comment|/*  * Output state that has been saved when diversions are done.  */
end_comment

begin_typedef
typedef|typedef
name|struct
name|iostate
name|IOSTATE
typedef|;
end_typedef

begin_struct
struct|struct
name|iostate
block|{
name|IOSTATE
modifier|*
name|oldiostates
decl_stmt|;
comment|/* previous saved state */
name|long
name|outdigits
decl_stmt|;
comment|/* digits for output */
name|int
name|outmode
decl_stmt|;
comment|/* output mode */
name|FILE
modifier|*
name|outfp
decl_stmt|;
comment|/* file unit for output (if any) */
name|char
modifier|*
name|outbuf
decl_stmt|;
comment|/* output string buffer (if any) */
name|long
name|outbufsize
decl_stmt|;
comment|/* current size of string buffer */
name|long
name|outbufused
decl_stmt|;
comment|/* space used in string buffer */
name|BOOL
name|outputisstring
decl_stmt|;
comment|/* TRUE if output is to string buffer */
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|IOSTATE
modifier|*
name|oldiostates
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* list of saved output states */
end_comment

begin_decl_stmt
specifier|static
name|FILE
modifier|*
name|outfp
init|=
name|stdout
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* file unit for output */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|outbuf
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* current diverted buffer */
end_comment

begin_decl_stmt
specifier|static
name|long
name|scalefactor
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|long
name|outbufsize
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|long
name|outbufused
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|BOOL
name|outputisstring
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ZVALUE
name|scalenumber
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static long	etoalen; static char	*etoabuf = NULL;
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|void
name|zprintx
name|proto
argument_list|(
operator|(
name|ZVALUE
name|z
operator|,
name|long
name|width
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|zprintb
name|proto
argument_list|(
operator|(
name|ZVALUE
name|z
operator|,
name|long
name|width
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|zprinto
name|proto
argument_list|(
operator|(
name|ZVALUE
name|z
operator|,
name|long
name|width
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|zprintval
name|proto
argument_list|(
operator|(
name|ZVALUE
name|z
operator|,
name|long
name|decimals
operator|,
name|long
name|width
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|atoz
name|proto
argument_list|(
operator|(
name|char
operator|*
name|s
operator|,
name|ZVALUE
operator|*
name|res
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|qprintff
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|qprintfd
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|qprintfe
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|qprintfr
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|qprintfo
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|qprintfb
parameter_list|()
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|CODE
end_ifdef

begin_function_decl
specifier|extern
name|void
name|qprintfx
parameter_list|()
function_decl|;
end_function_decl

begin_else
else|#
directive|else
end_else

begin_function_decl
specifier|static
name|void
name|qprintfx
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Routine to output a character either to a FILE  * handle or into a string.  */
end_comment

begin_function
name|void
name|math_chr
parameter_list|(
name|ch
parameter_list|)
block|{
name|char
modifier|*
name|cp
decl_stmt|;
if|if
condition|(
operator|!
name|outputisstring
condition|)
block|{
name|fputc
argument_list|(
name|ch
argument_list|,
name|outfp
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|outbufused
operator|>=
name|outbufsize
condition|)
block|{
name|cp
operator|=
operator|(
name|char
operator|*
operator|)
name|realloc
argument_list|(
name|outbuf
argument_list|,
name|outbufsize
operator|+
name|OUTBUFSIZE
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|"Cannot realloc output string"
argument_list|)
expr_stmt|;
name|outbuf
operator|=
name|cp
expr_stmt|;
name|outbufsize
operator|+=
name|OUTBUFSIZE
expr_stmt|;
block|}
name|outbuf
index|[
name|outbufused
operator|++
index|]
operator|=
operator|(
name|char
operator|)
name|ch
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Routine to output a null-terminated string either  * to a FILE handle or into a string.  */
end_comment

begin_function
name|void
name|math_str
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|char
modifier|*
name|cp
decl_stmt|;
name|int
name|len
decl_stmt|;
if|if
condition|(
operator|!
name|outputisstring
condition|)
block|{
name|fputs
argument_list|(
name|str
argument_list|,
name|outfp
argument_list|)
expr_stmt|;
return|return;
block|}
name|len
operator|=
name|strlen
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|outbufused
operator|+
name|len
operator|)
operator|>
name|outbufsize
condition|)
block|{
name|cp
operator|=
operator|(
name|char
operator|*
operator|)
name|realloc
argument_list|(
name|outbuf
argument_list|,
name|outbufsize
operator|+
name|len
operator|+
name|OUTBUFSIZE
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|"Cannot realloc output string"
argument_list|)
expr_stmt|;
name|outbuf
operator|=
name|cp
expr_stmt|;
name|outbufsize
operator|+=
operator|(
name|len
operator|+
name|OUTBUFSIZE
operator|)
expr_stmt|;
block|}
name|memcpy
argument_list|(
operator|&
name|outbuf
index|[
name|outbufused
index|]
argument_list|,
name|str
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|outbufused
operator|+=
name|len
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Routine to output a printf-style formatted string either  * to a FILE handle or into a string.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|VARARGS
end_ifdef

begin_define
define|#
directive|define
name|VA_ALIST
value|fmt, va_alist
end_define

begin_define
define|#
directive|define
name|VA_DCL
value|char *fmt; va_dcl
end_define

begin_else
else|#
directive|else
end_else

begin_ifdef
ifdef|#
directive|ifdef
name|__STDC__
end_ifdef

begin_define
define|#
directive|define
name|VA_ALIST
value|char *fmt, ...
end_define

begin_define
define|#
directive|define
name|VA_DCL
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|VA_ALIST
value|fmt
end_define

begin_define
define|#
directive|define
name|VA_DCL
value|char *fmt;
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*VARARGS*/
end_comment

begin_function
name|void
name|math_fmt
parameter_list|(
name|VA_ALIST
parameter_list|)
function|VA_DCL
block|{
name|va_list
name|ap
decl_stmt|;
name|char
name|buf
index|[
literal|200
index|]
decl_stmt|;
ifdef|#
directive|ifdef
name|VARARGS
name|va_start
argument_list|(
name|ap
argument_list|)
expr_stmt|;
else|#
directive|else
name|va_start
argument_list|(
name|ap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|vsprintf
argument_list|(
name|buf
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|math_str
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Flush the current output stream.  */
end_comment

begin_function
name|void
name|math_flush
parameter_list|()
block|{
if|if
condition|(
operator|!
name|outputisstring
condition|)
name|fflush
argument_list|(
name|outfp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Divert further output so that it is saved into a string that will be  * returned later when the diversion is completed.  The current state of  * output is remembered for later restoration.  Diversions can be nested.  * Output diversion is only intended for saving output to "stdout".  */
end_comment

begin_function
name|void
name|divertio
parameter_list|()
block|{
specifier|register
name|IOSTATE
modifier|*
name|sp
decl_stmt|;
name|sp
operator|=
operator|(
name|IOSTATE
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|IOSTATE
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|"No memory for diverting output"
argument_list|)
expr_stmt|;
name|sp
operator|->
name|oldiostates
operator|=
name|oldiostates
expr_stmt|;
name|sp
operator|->
name|outdigits
operator|=
name|_outdigits_
expr_stmt|;
name|sp
operator|->
name|outmode
operator|=
name|_outmode_
expr_stmt|;
name|sp
operator|->
name|outfp
operator|=
name|outfp
expr_stmt|;
name|sp
operator|->
name|outbuf
operator|=
name|outbuf
expr_stmt|;
name|sp
operator|->
name|outbufsize
operator|=
name|outbufsize
expr_stmt|;
name|sp
operator|->
name|outbufused
operator|=
name|outbufused
expr_stmt|;
name|sp
operator|->
name|outputisstring
operator|=
name|outputisstring
expr_stmt|;
name|outbufused
operator|=
literal|0
expr_stmt|;
name|outbufsize
operator|=
literal|0
expr_stmt|;
name|outbuf
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|OUTBUFSIZE
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|outbuf
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|"Cannot allocate divert string"
argument_list|)
expr_stmt|;
name|outbufsize
operator|=
name|OUTBUFSIZE
expr_stmt|;
name|outputisstring
operator|=
name|TRUE
expr_stmt|;
name|oldiostates
operator|=
name|sp
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Undivert output and return the saved output as a string.  This also  * restores the output state to what it was before the diversion began.  * The string needs freeing by the caller when it is no longer needed.  */
end_comment

begin_function
name|char
modifier|*
name|getdivertedio
parameter_list|()
block|{
specifier|register
name|IOSTATE
modifier|*
name|sp
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
name|sp
operator|=
name|oldiostates
expr_stmt|;
if|if
condition|(
name|sp
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|"No diverted state to restore"
argument_list|)
expr_stmt|;
name|cp
operator|=
name|outbuf
expr_stmt|;
name|cp
index|[
name|outbufused
index|]
operator|=
literal|'\0'
expr_stmt|;
name|oldiostates
operator|=
name|sp
operator|->
name|oldiostates
expr_stmt|;
name|_outdigits_
operator|=
name|sp
operator|->
name|outdigits
expr_stmt|;
name|_outmode_
operator|=
name|sp
operator|->
name|outmode
expr_stmt|;
name|outfp
operator|=
name|sp
operator|->
name|outfp
expr_stmt|;
name|outbuf
operator|=
name|sp
operator|->
name|outbuf
expr_stmt|;
name|outbufsize
operator|=
name|sp
operator|->
name|outbufsize
expr_stmt|;
name|outbufused
operator|=
name|sp
operator|->
name|outbufused
expr_stmt|;
name|outbuf
operator|=
name|sp
operator|->
name|outbuf
expr_stmt|;
name|outputisstring
operator|=
name|sp
operator|->
name|outputisstring
expr_stmt|;
return|return
name|cp
return|;
block|}
end_function

begin_comment
comment|/*  * Clear all diversions and set output back to the original destination.  * This is called when resetting the global state of the program.  */
end_comment

begin_function
name|void
name|cleardiversions
parameter_list|()
block|{
while|while
condition|(
name|oldiostates
condition|)
name|free
argument_list|(
name|getdivertedio
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Set the output routines to output to the specified FILE stream.  * This interacts with output diversion in the following manner.  *	STDOUT	diversion	action  *	----	---------	------  *	yes	yes		set output to diversion string again.  *	yes	no		set output to stdout.  *	no	yes		set output to specified file.  *	no	no		set output to specified file.  */
end_comment

begin_function
name|void
name|setfp
parameter_list|(
name|newfp
parameter_list|)
name|FILE
modifier|*
name|newfp
decl_stmt|;
block|{
name|outfp
operator|=
name|newfp
expr_stmt|;
name|outputisstring
operator|=
operator|(
name|oldiostates
operator|&&
operator|(
name|newfp
operator|==
name|stdout
operator|)
operator|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Set the output mode for numeric output.  */
end_comment

begin_function
name|void
name|set_mode
parameter_list|(
name|newmode
parameter_list|)
block|{
if|if
condition|(
operator|(
name|newmode
operator|<=
name|MODE_DEFAULT
operator|)
operator|||
operator|(
name|newmode
operator|>
name|MODE_MAX
operator|)
condition|)
name|error
argument_list|(
literal|"Setting illegal output mode"
argument_list|)
expr_stmt|;
name|_outmode_
operator|=
name|newmode
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Set the number of digits for float or exponential output.  */
end_comment

begin_function
name|void
name|setdigits
parameter_list|(
name|newdigits
parameter_list|)
name|long
name|newdigits
decl_stmt|;
block|{
if|if
condition|(
name|newdigits
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|"Setting illegal number of digits"
argument_list|)
expr_stmt|;
name|_outdigits_
operator|=
name|newdigits
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Print a formatted string containing arbitrary numbers, similar to printf.  * ALL numeric arguments to this routine are rational NUMBERs.  * Various forms of printing such numbers are supplied, in addition  * to strings and characters.  Output can actually be to any FILE  * stream or a string.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|VARARGS
end_ifdef

begin_define
define|#
directive|define
name|VA_ALIST1
value|fmt, va_alist
end_define

begin_define
define|#
directive|define
name|VA_DCL1
value|char *fmt; va_dcl
end_define

begin_else
else|#
directive|else
end_else

begin_ifdef
ifdef|#
directive|ifdef
name|__STDC__
end_ifdef

begin_define
define|#
directive|define
name|VA_ALIST1
value|char *fmt, ...
end_define

begin_define
define|#
directive|define
name|VA_DCL1
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|VA_ALIST1
value|fmt
end_define

begin_define
define|#
directive|define
name|VA_DCL1
value|char *fmt;
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*VARARGS*/
end_comment

begin_function
name|void
name|qprintf
parameter_list|(
name|VA_ALIST1
parameter_list|)
function|VA_DCL1
block|{
name|va_list
name|ap
decl_stmt|;
name|NUMBER
modifier|*
name|q
decl_stmt|;
name|int
name|ch
decl_stmt|,
name|sign
decl_stmt|;
name|long
name|width
decl_stmt|,
name|precision
decl_stmt|;
ifdef|#
directive|ifdef
name|VARARGS
name|va_start
argument_list|(
name|ap
argument_list|)
expr_stmt|;
else|#
directive|else
name|va_start
argument_list|(
name|ap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
endif|#
directive|endif
while|while
condition|(
operator|(
name|ch
operator|=
operator|*
name|fmt
operator|++
operator|)
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
name|ch
operator|==
literal|'\\'
condition|)
block|{
name|ch
operator|=
operator|*
name|fmt
operator|++
expr_stmt|;
switch|switch
condition|(
name|ch
condition|)
block|{
case|case
literal|'n'
case|:
name|ch
operator|=
literal|'\n'
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
name|ch
operator|=
literal|'\r'
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
name|ch
operator|=
literal|'\t'
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
name|ch
operator|=
literal|'\f'
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
name|ch
operator|=
literal|'\v'
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
name|ch
operator|=
literal|'\b'
expr_stmt|;
break|break;
case|case
literal|0
case|:
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
return|return;
block|}
name|PUTCHAR
argument_list|(
name|ch
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|ch
operator|!=
literal|'%'
condition|)
block|{
name|PUTCHAR
argument_list|(
name|ch
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|ch
operator|=
operator|*
name|fmt
operator|++
expr_stmt|;
name|width
operator|=
literal|0
expr_stmt|;
name|precision
operator|=
literal|8
expr_stmt|;
name|sign
operator|=
literal|1
expr_stmt|;
name|percent
label|:
empty_stmt|;
switch|switch
condition|(
name|ch
condition|)
block|{
case|case
literal|'d'
case|:
name|q
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|NUMBER
operator|*
argument_list|)
expr_stmt|;
name|qprintfd
argument_list|(
name|q
argument_list|,
name|width
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
name|q
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|NUMBER
operator|*
argument_list|)
expr_stmt|;
name|qprintff
argument_list|(
name|q
argument_list|,
name|width
argument_list|,
name|precision
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
name|q
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|NUMBER
operator|*
argument_list|)
expr_stmt|;
name|qprintfe
argument_list|(
name|q
argument_list|,
name|width
argument_list|,
name|precision
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
case|case
literal|'R'
case|:
name|q
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|NUMBER
operator|*
argument_list|)
expr_stmt|;
name|qprintfr
argument_list|(
name|q
argument_list|,
name|width
argument_list|,
call|(
name|BOOL
call|)
argument_list|(
name|ch
operator|==
literal|'R'
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'N'
case|:
name|q
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|NUMBER
operator|*
argument_list|)
expr_stmt|;
name|zprintval
argument_list|(
name|q
operator|->
name|num
argument_list|,
literal|0L
argument_list|,
name|width
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'D'
case|:
name|q
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|NUMBER
operator|*
argument_list|)
expr_stmt|;
name|zprintval
argument_list|(
name|q
operator|->
name|den
argument_list|,
literal|0L
argument_list|,
name|width
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'o'
case|:
name|q
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|NUMBER
operator|*
argument_list|)
expr_stmt|;
name|qprintfo
argument_list|(
name|q
argument_list|,
name|width
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
name|q
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|NUMBER
operator|*
argument_list|)
expr_stmt|;
name|qprintfx
argument_list|(
name|q
argument_list|,
name|width
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
name|q
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|NUMBER
operator|*
argument_list|)
expr_stmt|;
name|qprintfb
argument_list|(
name|q
argument_list|,
name|width
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
name|PUTSTR
argument_list|(
name|va_arg
argument_list|(
name|ap
argument_list|,
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
name|PUTCHAR
argument_list|(
name|va_arg
argument_list|(
name|ap
argument_list|,
name|int
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0
case|:
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'-'
case|:
name|sign
operator|=
operator|-
literal|1
expr_stmt|;
name|ch
operator|=
operator|*
name|fmt
operator|++
expr_stmt|;
default|default:
if|if
condition|(
operator|(
literal|'0'
operator|<=
name|ch
operator|&&
name|ch
operator|<=
literal|'9'
operator|)
operator|||
name|ch
operator|==
literal|'.'
operator|||
name|ch
operator|==
literal|'*'
condition|)
block|{
if|if
condition|(
name|ch
operator|==
literal|'*'
condition|)
block|{
name|q
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|NUMBER
operator|*
argument_list|)
expr_stmt|;
name|width
operator|=
name|sign
operator|*
name|qtoi
argument_list|(
name|q
argument_list|)
expr_stmt|;
name|ch
operator|=
operator|*
name|fmt
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ch
operator|!=
literal|'.'
condition|)
block|{
name|width
operator|=
name|ch
operator|-
literal|'0'
expr_stmt|;
while|while
condition|(
literal|'0'
operator|<=
operator|(
name|ch
operator|=
operator|*
name|fmt
operator|++
operator|)
operator|&&
name|ch
operator|<=
literal|'9'
condition|)
name|width
operator|=
name|width
operator|*
literal|10
operator|+
name|ch
operator|-
literal|'0'
expr_stmt|;
name|width
operator|*=
name|sign
expr_stmt|;
block|}
if|if
condition|(
name|ch
operator|==
literal|'.'
condition|)
block|{
if|if
condition|(
operator|(
name|ch
operator|=
operator|*
name|fmt
operator|++
operator|)
operator|==
literal|'*'
condition|)
block|{
name|q
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|NUMBER
operator|*
argument_list|)
expr_stmt|;
name|precision
operator|=
name|qtoi
argument_list|(
name|q
argument_list|)
expr_stmt|;
name|ch
operator|=
operator|*
name|fmt
operator|++
expr_stmt|;
block|}
else|else
block|{
name|precision
operator|=
literal|0
expr_stmt|;
while|while
condition|(
literal|'0'
operator|<=
operator|(
name|ch
operator|=
operator|*
name|fmt
operator|++
operator|)
operator|&&
name|ch
operator|<=
literal|'9'
condition|)
name|precision
operator|=
name|precision
operator|*
literal|10
operator|+
name|ch
operator|-
literal|'0'
expr_stmt|;
block|}
block|}
goto|goto
name|percent
goto|;
block|}
block|}
block|}
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/*  * Read a number from the specified FILE stream (NULL means stdin).  * The number can be an integer, a fraction, a real number, an  * exponential number, or a hex, octal or binary number.  Leading blanks  * are skipped.  Illegal numbers return NULL.  Unrecognized characters  * remain to be read on the line.  *	q = qreadval(fp);  */
end_comment

begin_comment
unit|NUMBER * qreadval(fp) 	FILE *fp;
comment|/* file stream to read from (or NULL) */
end_comment

begin_comment
unit|{ 	NUMBER *r;
comment|/* returned number */
end_comment

begin_comment
unit|char *cp;
comment|/* current buffer location */
end_comment

begin_comment
unit|long savecc;
comment|/* characters saved in buffer */
end_comment

begin_comment
unit|long scancc;
comment|/* characters parsed correctly */
end_comment

begin_comment
unit|int ch;
comment|/* current character */
end_comment

begin_endif
unit|if (fp == NULL) 		fp = stdin; 	if (etoabuf == NULL) { 		etoabuf = (char *)malloc(OUTBUFSIZE + 2); 		if (etoabuf == NULL) 			return NULL; 		etoalen = OUTBUFSIZE; 	} 	cp = etoabuf; 	ch = fgetc(fp); 	while ((ch == ' ') || (ch == '\t')) 		ch = fgetc(fp); 	savecc = 0; 	for (;;) { 		if (ch == EOF) 			return NULL; 		if (savecc>= etoalen) 		{ 			cp = (char *)realloc(etoabuf, etoalen + OUTBUFSIZE + 2); 			if (cp == NULL) 				return NULL; 			etoabuf = cp; 			etoalen += OUTBUFSIZE; 			cp += savecc; 		} 		*cp++ = (char)ch; 		*cp = '\0'; 		scancc = qparse(etoabuf, QPF_SLASH); 		if (scancc != ++savecc) 			break; 		ch = fgetc(fp); 	} 	ungetc(ch, fp); 	if (scancc< 0) 		return NULL; 	r = atoq(etoabuf); 	if (iszero(r->den)) { 		qfree(r); 		r = NULL; 	} 	return r; }
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Print a complex number in rational representation.  * Example:  2/3-4i/5  */
end_comment

begin_function
name|void
name|cprintfr
parameter_list|(
name|c
parameter_list|)
name|COMPLEX
modifier|*
name|c
decl_stmt|;
block|{
name|NUMBER
modifier|*
name|r
decl_stmt|;
name|NUMBER
modifier|*
name|i
decl_stmt|;
name|r
operator|=
name|c
operator|->
name|real
expr_stmt|;
name|i
operator|=
name|c
operator|->
name|imag
expr_stmt|;
if|if
condition|(
operator|!
name|qiszero
argument_list|(
name|r
argument_list|)
operator|||
name|qiszero
argument_list|(
name|i
argument_list|)
condition|)
name|qprintfr
argument_list|(
name|r
argument_list|,
literal|0L
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|qiszero
argument_list|(
name|i
argument_list|)
condition|)
return|return;
if|if
condition|(
operator|!
name|qiszero
argument_list|(
name|r
argument_list|)
operator|&&
operator|!
name|qisneg
argument_list|(
name|i
argument_list|)
condition|)
name|PUTCHAR
argument_list|(
literal|'+'
argument_list|)
expr_stmt|;
name|zprintval
argument_list|(
name|i
operator|->
name|num
argument_list|,
literal|0L
argument_list|,
literal|0L
argument_list|)
expr_stmt|;
name|PUTCHAR
argument_list|(
literal|'i'
argument_list|)
expr_stmt|;
if|if
condition|(
name|qisfrac
argument_list|(
name|i
argument_list|)
condition|)
block|{
name|PUTCHAR
argument_list|(
literal|'/'
argument_list|)
expr_stmt|;
name|zprintval
argument_list|(
name|i
operator|->
name|den
argument_list|,
literal|0L
argument_list|,
literal|0L
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Print a number in the specified output mode.  * If MODE_DEFAULT is given, then the default output mode is used.  * Any approximate output is flagged with a leading tilde.  * Integers are always printed as themselves.  */
end_comment

begin_function
name|void
name|qprintnum
parameter_list|(
name|q
parameter_list|,
name|outmode
parameter_list|)
name|NUMBER
modifier|*
name|q
decl_stmt|;
block|{
name|NUMBER
name|tmpval
decl_stmt|;
name|long
name|prec
decl_stmt|,
name|exp
decl_stmt|;
if|if
condition|(
name|outmode
operator|==
name|MODE_DEFAULT
condition|)
name|outmode
operator|=
name|_outmode_
expr_stmt|;
if|if
condition|(
operator|(
name|outmode
operator|==
name|MODE_FRAC
operator|)
operator|||
operator|(
operator|(
name|outmode
operator|==
name|MODE_REAL
operator|)
operator|&&
name|qisint
argument_list|(
name|q
argument_list|)
operator|)
condition|)
block|{
name|qprintfr
argument_list|(
name|q
argument_list|,
literal|0L
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
return|return;
block|}
switch|switch
condition|(
name|outmode
condition|)
block|{
case|case
name|MODE_INT
case|:
if|if
condition|(
name|qisfrac
argument_list|(
name|q
argument_list|)
condition|)
name|PUTCHAR
argument_list|(
literal|'~'
argument_list|)
expr_stmt|;
name|qprintfd
argument_list|(
name|q
argument_list|,
literal|0L
argument_list|)
expr_stmt|;
break|break;
case|case
name|MODE_REAL
case|:
name|prec
operator|=
name|qplaces
argument_list|(
name|q
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|prec
operator|<
literal|0
operator|)
operator|||
operator|(
name|prec
operator|>
name|_outdigits_
operator|)
condition|)
block|{
name|prec
operator|=
name|_outdigits_
expr_stmt|;
name|PUTCHAR
argument_list|(
literal|'~'
argument_list|)
expr_stmt|;
block|}
name|qprintff
argument_list|(
name|q
argument_list|,
literal|0L
argument_list|,
name|prec
argument_list|)
expr_stmt|;
break|break;
case|case
name|MODE_EXP
case|:
if|if
condition|(
name|qiszero
argument_list|(
name|q
argument_list|)
condition|)
block|{
name|PUTCHAR
argument_list|(
literal|'0'
argument_list|)
expr_stmt|;
return|return;
block|}
name|tmpval
operator|=
operator|*
name|q
expr_stmt|;
name|tmpval
operator|.
name|num
operator|.
name|sign
operator|=
literal|0
expr_stmt|;
name|exp
operator|=
name|qilog10
argument_list|(
operator|&
name|tmpval
argument_list|)
expr_stmt|;
if|if
condition|(
name|exp
operator|==
literal|0
condition|)
block|{
comment|/* in range to output as real */
name|qprintnum
argument_list|(
name|q
argument_list|,
name|MODE_REAL
argument_list|)
expr_stmt|;
return|return;
block|}
name|tmpval
operator|.
name|num
operator|=
name|_one_
expr_stmt|;
name|tmpval
operator|.
name|den
operator|=
name|_one_
expr_stmt|;
if|if
condition|(
name|exp
operator|>
literal|0
condition|)
name|ztenpow
argument_list|(
name|exp
argument_list|,
operator|&
name|tmpval
operator|.
name|den
argument_list|)
expr_stmt|;
else|else
name|ztenpow
argument_list|(
operator|-
name|exp
argument_list|,
operator|&
name|tmpval
operator|.
name|num
argument_list|)
expr_stmt|;
name|q
operator|=
name|qmul
argument_list|(
name|q
argument_list|,
operator|&
name|tmpval
argument_list|)
expr_stmt|;
name|freeh
argument_list|(
name|tmpval
operator|.
name|num
operator|.
name|v
argument_list|)
expr_stmt|;
name|freeh
argument_list|(
name|tmpval
operator|.
name|den
operator|.
name|v
argument_list|)
expr_stmt|;
name|qprintnum
argument_list|(
name|q
argument_list|,
name|MODE_REAL
argument_list|)
expr_stmt|;
name|qfree
argument_list|(
name|q
argument_list|)
expr_stmt|;
name|PRINTF1
argument_list|(
literal|"e%ld"
argument_list|,
name|exp
argument_list|)
expr_stmt|;
break|break;
case|case
name|MODE_HEX
case|:
name|qprintfx
argument_list|(
name|q
argument_list|,
literal|0L
argument_list|)
expr_stmt|;
break|break;
case|case
name|MODE_OCTAL
case|:
name|qprintfo
argument_list|(
name|q
argument_list|,
literal|0L
argument_list|)
expr_stmt|;
break|break;
case|case
name|MODE_BINARY
case|:
name|qprintfb
argument_list|(
name|q
argument_list|,
literal|0L
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
argument_list|(
literal|"Bad mode for print"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Print a number in floating point representation.  * Example:  193.784  */
end_comment

begin_function
specifier|static
name|void
name|qprintff
parameter_list|(
name|q
parameter_list|,
name|width
parameter_list|,
name|precision
parameter_list|)
name|NUMBER
modifier|*
name|q
decl_stmt|;
name|long
name|width
decl_stmt|;
name|long
name|precision
decl_stmt|;
block|{
name|ZVALUE
name|z
decl_stmt|,
name|z1
decl_stmt|;
if|if
condition|(
name|precision
operator|!=
name|scalefactor
condition|)
block|{
if|if
condition|(
name|scalenumber
operator|.
name|v
condition|)
name|freeh
argument_list|(
name|scalenumber
operator|.
name|v
argument_list|)
expr_stmt|;
name|ztenpow
argument_list|(
name|precision
argument_list|,
operator|&
name|scalenumber
argument_list|)
expr_stmt|;
name|scalefactor
operator|=
name|precision
expr_stmt|;
block|}
if|if
condition|(
name|scalenumber
operator|.
name|v
condition|)
name|zmul
argument_list|(
name|q
operator|->
name|num
argument_list|,
name|scalenumber
argument_list|,
operator|&
name|z
argument_list|)
expr_stmt|;
else|else
name|z
operator|=
name|q
operator|->
name|num
expr_stmt|;
if|if
condition|(
name|qisfrac
argument_list|(
name|q
argument_list|)
condition|)
block|{
name|zquo
argument_list|(
name|z
argument_list|,
name|q
operator|->
name|den
argument_list|,
operator|&
name|z1
argument_list|)
expr_stmt|;
if|if
condition|(
name|z
operator|.
name|v
operator|!=
name|q
operator|->
name|num
operator|.
name|v
condition|)
name|freeh
argument_list|(
name|z
operator|.
name|v
argument_list|)
expr_stmt|;
name|z
operator|=
name|z1
expr_stmt|;
block|}
if|if
condition|(
name|qisneg
argument_list|(
name|q
argument_list|)
operator|&&
name|iszero
argument_list|(
name|z
argument_list|)
condition|)
name|PUTCHAR
argument_list|(
literal|'-'
argument_list|)
expr_stmt|;
name|zprintval
argument_list|(
name|z
argument_list|,
name|precision
argument_list|,
name|width
argument_list|)
expr_stmt|;
if|if
condition|(
name|z
operator|.
name|v
operator|!=
name|q
operator|->
name|num
operator|.
name|v
condition|)
name|freeh
argument_list|(
name|z
operator|.
name|v
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Print a number in exponential notation.  * Example: 4.1856e34  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|void
name|qprintfe
parameter_list|(
name|q
parameter_list|,
name|width
parameter_list|,
name|precision
parameter_list|)
specifier|register
name|NUMBER
modifier|*
name|q
decl_stmt|;
name|long
name|width
decl_stmt|;
name|long
name|precision
decl_stmt|;
block|{
name|long
name|exponent
decl_stmt|;
name|NUMBER
name|q2
decl_stmt|;
name|ZVALUE
name|num
decl_stmt|,
name|den
decl_stmt|,
name|tenpow
decl_stmt|,
name|tmp
decl_stmt|;
if|if
condition|(
name|qiszero
argument_list|(
name|q
argument_list|)
condition|)
block|{
name|PUTSTR
argument_list|(
literal|"0.0"
argument_list|)
expr_stmt|;
return|return;
block|}
name|num
operator|=
name|q
operator|->
name|num
expr_stmt|;
name|den
operator|=
name|q
operator|->
name|den
expr_stmt|;
name|num
operator|.
name|sign
operator|=
literal|0
expr_stmt|;
name|exponent
operator|=
name|zdigits
argument_list|(
name|num
argument_list|)
operator|-
name|zdigits
argument_list|(
name|den
argument_list|)
expr_stmt|;
if|if
condition|(
name|exponent
operator|>
literal|0
condition|)
block|{
name|ztenpow
argument_list|(
name|exponent
argument_list|,
operator|&
name|tenpow
argument_list|)
expr_stmt|;
name|zmul
argument_list|(
name|den
argument_list|,
name|tenpow
argument_list|,
operator|&
name|tmp
argument_list|)
expr_stmt|;
name|freeh
argument_list|(
name|tenpow
operator|.
name|v
argument_list|)
expr_stmt|;
name|den
operator|=
name|tmp
expr_stmt|;
block|}
if|if
condition|(
name|exponent
operator|<
literal|0
condition|)
block|{
name|ztenpow
argument_list|(
operator|-
name|exponent
argument_list|,
operator|&
name|tenpow
argument_list|)
expr_stmt|;
name|zmul
argument_list|(
name|num
argument_list|,
name|tenpow
argument_list|,
operator|&
name|tmp
argument_list|)
expr_stmt|;
name|freeh
argument_list|(
name|tenpow
operator|.
name|v
argument_list|)
expr_stmt|;
name|num
operator|=
name|tmp
expr_stmt|;
block|}
if|if
condition|(
name|zrel
argument_list|(
name|num
argument_list|,
name|den
argument_list|)
operator|<
literal|0
condition|)
block|{
name|zmuli
argument_list|(
name|num
argument_list|,
literal|10L
argument_list|,
operator|&
name|tmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|num
operator|.
name|v
operator|!=
name|q
operator|->
name|num
operator|.
name|v
condition|)
name|freeh
argument_list|(
name|num
operator|.
name|v
argument_list|)
expr_stmt|;
name|num
operator|=
name|tmp
expr_stmt|;
name|exponent
operator|--
expr_stmt|;
block|}
name|q2
operator|.
name|num
operator|=
name|num
expr_stmt|;
name|q2
operator|.
name|den
operator|=
name|den
expr_stmt|;
name|q2
operator|.
name|num
operator|.
name|sign
operator|=
name|q
operator|->
name|num
operator|.
name|sign
expr_stmt|;
name|qprintff
argument_list|(
operator|&
name|q2
argument_list|,
literal|0L
argument_list|,
name|precision
argument_list|)
expr_stmt|;
if|if
condition|(
name|exponent
condition|)
name|PRINTF1
argument_list|(
literal|"e%ld"
argument_list|,
name|exponent
argument_list|)
expr_stmt|;
if|if
condition|(
name|num
operator|.
name|v
operator|!=
name|q
operator|->
name|num
operator|.
name|v
condition|)
name|freeh
argument_list|(
name|num
operator|.
name|v
argument_list|)
expr_stmt|;
if|if
condition|(
name|den
operator|.
name|v
operator|!=
name|q
operator|->
name|den
operator|.
name|v
condition|)
name|freeh
argument_list|(
name|den
operator|.
name|v
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Print a number in rational representation.  * Example: 397/37  */
end_comment

begin_function
specifier|static
name|void
name|qprintfr
parameter_list|(
name|q
parameter_list|,
name|width
parameter_list|,
name|force
parameter_list|)
name|NUMBER
modifier|*
name|q
decl_stmt|;
name|long
name|width
decl_stmt|;
name|BOOL
name|force
decl_stmt|;
block|{
name|zprintval
argument_list|(
name|q
operator|->
name|num
argument_list|,
literal|0L
argument_list|,
name|width
argument_list|)
expr_stmt|;
if|if
condition|(
name|force
operator|||
name|qisfrac
argument_list|(
name|q
argument_list|)
condition|)
block|{
name|PUTCHAR
argument_list|(
literal|'/'
argument_list|)
expr_stmt|;
name|zprintval
argument_list|(
name|q
operator|->
name|den
argument_list|,
literal|0L
argument_list|,
name|width
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Print a number as an integer (truncating fractional part).  * Example: 958421  */
end_comment

begin_function
specifier|static
name|void
name|qprintfd
parameter_list|(
name|q
parameter_list|,
name|width
parameter_list|)
name|NUMBER
modifier|*
name|q
decl_stmt|;
name|long
name|width
decl_stmt|;
block|{
name|ZVALUE
name|z
decl_stmt|;
if|if
condition|(
name|qisfrac
argument_list|(
name|q
argument_list|)
condition|)
block|{
name|zquo
argument_list|(
name|q
operator|->
name|num
argument_list|,
name|q
operator|->
name|den
argument_list|,
operator|&
name|z
argument_list|)
expr_stmt|;
name|zprintval
argument_list|(
name|z
argument_list|,
literal|0L
argument_list|,
name|width
argument_list|)
expr_stmt|;
name|freeh
argument_list|(
name|z
operator|.
name|v
argument_list|)
expr_stmt|;
block|}
else|else
name|zprintval
argument_list|(
name|q
operator|->
name|num
argument_list|,
literal|0L
argument_list|,
name|width
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Print a number in hex.  * This prints the numerator and denominator in hex.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|CODE
end_ifndef

begin_function
specifier|static
endif|#
directive|endif
name|void
name|qprintfx
parameter_list|(
name|q
parameter_list|,
name|width
parameter_list|)
name|NUMBER
modifier|*
name|q
decl_stmt|;
name|long
name|width
decl_stmt|;
block|{
name|zprintx
argument_list|(
name|q
operator|->
name|num
argument_list|,
name|width
argument_list|)
expr_stmt|;
if|if
condition|(
name|qisfrac
argument_list|(
name|q
argument_list|)
condition|)
block|{
name|PUTCHAR
argument_list|(
literal|'/'
argument_list|)
expr_stmt|;
name|zprintx
argument_list|(
name|q
operator|->
name|den
argument_list|,
literal|0L
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Print a number in binary.  * This prints the numerator and denominator in binary.  */
end_comment

begin_function
specifier|static
name|void
name|qprintfb
parameter_list|(
name|q
parameter_list|,
name|width
parameter_list|)
name|NUMBER
modifier|*
name|q
decl_stmt|;
name|long
name|width
decl_stmt|;
block|{
name|zprintb
argument_list|(
name|q
operator|->
name|num
argument_list|,
name|width
argument_list|)
expr_stmt|;
if|if
condition|(
name|qisfrac
argument_list|(
name|q
argument_list|)
condition|)
block|{
name|PUTCHAR
argument_list|(
literal|'/'
argument_list|)
expr_stmt|;
name|zprintb
argument_list|(
name|q
operator|->
name|den
argument_list|,
literal|0L
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Print a number in octal.  * This prints the numerator and denominator in octal.  */
end_comment

begin_function
specifier|static
name|void
name|qprintfo
parameter_list|(
name|q
parameter_list|,
name|width
parameter_list|)
name|NUMBER
modifier|*
name|q
decl_stmt|;
name|long
name|width
decl_stmt|;
block|{
name|zprinto
argument_list|(
name|q
operator|->
name|num
argument_list|,
name|width
argument_list|)
expr_stmt|;
if|if
condition|(
name|qisfrac
argument_list|(
name|q
argument_list|)
condition|)
block|{
name|PUTCHAR
argument_list|(
literal|'/'
argument_list|)
expr_stmt|;
name|zprinto
argument_list|(
name|q
operator|->
name|den
argument_list|,
literal|0L
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Print an integer value as a hex number.  * The special characters 0x appear to indicate the number is hex.  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|void
name|zprintx
parameter_list|(
name|z
parameter_list|,
name|width
parameter_list|)
name|ZVALUE
name|z
decl_stmt|;
name|long
name|width
decl_stmt|;
block|{
specifier|register
name|HALF
modifier|*
name|hp
decl_stmt|;
comment|/* current word to print */
name|int
name|len
decl_stmt|;
comment|/* number of halfwords to type */
name|len
operator|=
name|z
operator|.
name|len
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|isneg
argument_list|(
name|z
argument_list|)
condition|)
name|PUTCHAR
argument_list|(
literal|'-'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|len
operator|==
literal|0
operator|)
operator|&&
operator|(
operator|*
name|z
operator|.
name|v
operator|<=
operator|(
name|FULL
operator|)
literal|9
operator|)
condition|)
block|{
name|len
operator|=
literal|'0'
operator|+
operator|*
name|z
operator|.
name|v
expr_stmt|;
name|PUTCHAR
argument_list|(
name|len
argument_list|)
expr_stmt|;
return|return;
block|}
name|hp
operator|=
name|z
operator|.
name|v
operator|+
name|len
expr_stmt|;
name|PRINTF1
argument_list|(
literal|"0x%x"
argument_list|,
operator|(
name|FULL
operator|)
operator|*
name|hp
operator|--
argument_list|)
expr_stmt|;
while|while
condition|(
operator|--
name|len
operator|>=
literal|0
condition|)
name|PRINTF1
argument_list|(
literal|"%04x"
argument_list|,
operator|(
name|FULL
operator|)
operator|*
name|hp
operator|--
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Print an integer value as a binary number.  * The special characters 0b appear to indicate the number is binary.  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|void
name|zprintb
parameter_list|(
name|z
parameter_list|,
name|width
parameter_list|)
name|ZVALUE
name|z
decl_stmt|;
name|long
name|width
decl_stmt|;
block|{
specifier|register
name|HALF
modifier|*
name|hp
decl_stmt|;
comment|/* current word to print */
name|int
name|len
decl_stmt|;
comment|/* number of halfwords to type */
name|HALF
name|val
decl_stmt|;
comment|/* current value */
name|HALF
name|mask
decl_stmt|;
comment|/* current mask */
name|int
name|didprint
decl_stmt|;
comment|/* nonzero if printed some digits */
name|int
name|ch
decl_stmt|;
comment|/* current char */
name|len
operator|=
name|z
operator|.
name|len
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|isneg
argument_list|(
name|z
argument_list|)
condition|)
name|PUTCHAR
argument_list|(
literal|'-'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|len
operator|==
literal|0
operator|)
operator|&&
operator|(
operator|*
name|z
operator|.
name|v
operator|<=
operator|(
name|FULL
operator|)
literal|1
operator|)
condition|)
block|{
name|len
operator|=
literal|'0'
operator|+
operator|*
name|z
operator|.
name|v
expr_stmt|;
name|PUTCHAR
argument_list|(
name|len
argument_list|)
expr_stmt|;
return|return;
block|}
name|hp
operator|=
name|z
operator|.
name|v
operator|+
name|len
expr_stmt|;
name|didprint
operator|=
literal|0
expr_stmt|;
name|PUTSTR
argument_list|(
literal|"0b"
argument_list|)
expr_stmt|;
while|while
condition|(
name|len
operator|--
operator|>=
literal|0
condition|)
block|{
name|val
operator|=
operator|*
name|hp
operator|--
expr_stmt|;
name|mask
operator|=
operator|(
literal|1
operator|<<
operator|(
name|BASEB
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
while|while
condition|(
name|mask
condition|)
block|{
name|ch
operator|=
literal|'0'
operator|+
operator|(
operator|(
name|mask
operator|&
name|val
operator|)
operator|!=
literal|0
operator|)
expr_stmt|;
if|if
condition|(
name|didprint
operator|||
operator|(
name|ch
operator|!=
literal|'0'
operator|)
condition|)
block|{
name|PUTCHAR
argument_list|(
name|ch
argument_list|)
expr_stmt|;
name|didprint
operator|=
literal|1
expr_stmt|;
block|}
name|mask
operator|>>=
literal|1
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Print an integer value as an octal number.  * The number begins with a leading 0 to indicate that it is octal.  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|void
name|zprinto
parameter_list|(
name|z
parameter_list|,
name|width
parameter_list|)
name|ZVALUE
name|z
decl_stmt|;
name|long
name|width
decl_stmt|;
block|{
specifier|register
name|HALF
modifier|*
name|hp
decl_stmt|;
comment|/* current word to print */
name|int
name|len
decl_stmt|;
comment|/* number of halfwords to type */
name|int
name|num1
decl_stmt|,
name|num2
decl_stmt|;
comment|/* numbers to type */
name|int
name|rem
decl_stmt|;
comment|/* remainder number of halfwords */
if|if
condition|(
name|isneg
argument_list|(
name|z
argument_list|)
condition|)
name|PUTCHAR
argument_list|(
literal|'-'
argument_list|)
expr_stmt|;
name|len
operator|=
name|z
operator|.
name|len
expr_stmt|;
if|if
condition|(
operator|(
name|len
operator|==
literal|1
operator|)
operator|&&
operator|(
operator|*
name|z
operator|.
name|v
operator|<=
operator|(
name|FULL
operator|)
literal|7
operator|)
condition|)
block|{
name|num1
operator|=
literal|'0'
operator|+
operator|*
name|z
operator|.
name|v
expr_stmt|;
name|PUTCHAR
argument_list|(
name|num1
argument_list|)
expr_stmt|;
return|return;
block|}
name|hp
operator|=
name|z
operator|.
name|v
operator|+
name|len
operator|-
literal|1
expr_stmt|;
name|rem
operator|=
name|len
operator|%
literal|3
expr_stmt|;
switch|switch
condition|(
name|rem
condition|)
block|{
comment|/* handle odd amounts first */
case|case
literal|0
case|:
name|num1
operator|=
operator|(
operator|(
operator|(
name|FULL
operator|)
name|hp
index|[
literal|0
index|]
operator|)
operator|<<
literal|8
operator|)
operator|+
operator|(
operator|(
operator|(
name|FULL
operator|)
name|hp
index|[
operator|-
literal|1
index|]
operator|)
operator|>>
literal|8
operator|)
expr_stmt|;
name|num2
operator|=
operator|(
operator|(
call|(
name|FULL
call|)
argument_list|(
name|hp
index|[
operator|-
literal|1
index|]
operator|&
literal|0xff
argument_list|)
operator|)
operator|<<
literal|16
operator|)
operator|+
operator|(
operator|(
name|FULL
operator|)
name|hp
index|[
operator|-
literal|2
index|]
operator|)
expr_stmt|;
name|rem
operator|=
literal|3
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|num1
operator|=
literal|0
expr_stmt|;
name|num2
operator|=
operator|(
name|FULL
operator|)
name|hp
index|[
literal|0
index|]
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|num1
operator|=
operator|(
operator|(
operator|(
name|FULL
operator|)
name|hp
index|[
literal|0
index|]
operator|)
operator|>>
literal|8
operator|)
expr_stmt|;
name|num2
operator|=
operator|(
operator|(
call|(
name|FULL
call|)
argument_list|(
name|hp
index|[
literal|0
index|]
operator|&
literal|0xff
argument_list|)
operator|)
operator|<<
literal|16
operator|)
operator|+
operator|(
operator|(
name|FULL
operator|)
name|hp
index|[
operator|-
literal|1
index|]
operator|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|num1
condition|)
name|PRINTF2
argument_list|(
literal|"0%o%08o"
argument_list|,
name|num1
argument_list|,
name|num2
argument_list|)
expr_stmt|;
else|else
name|PRINTF1
argument_list|(
literal|"0%o"
argument_list|,
name|num2
argument_list|)
expr_stmt|;
name|len
operator|-=
name|rem
expr_stmt|;
name|hp
operator|-=
name|rem
expr_stmt|;
while|while
condition|(
name|len
operator|>
literal|0
condition|)
block|{
comment|/* finish in groups of 3 halfwords */
name|num1
operator|=
operator|(
operator|(
operator|(
name|FULL
operator|)
name|hp
index|[
literal|0
index|]
operator|)
operator|<<
literal|8
operator|)
operator|+
operator|(
operator|(
operator|(
name|FULL
operator|)
name|hp
index|[
operator|-
literal|1
index|]
operator|)
operator|>>
literal|8
operator|)
expr_stmt|;
name|num2
operator|=
operator|(
operator|(
call|(
name|FULL
call|)
argument_list|(
name|hp
index|[
operator|-
literal|1
index|]
operator|&
literal|0xff
argument_list|)
operator|)
operator|<<
literal|16
operator|)
operator|+
operator|(
operator|(
name|FULL
operator|)
name|hp
index|[
operator|-
literal|2
index|]
operator|)
expr_stmt|;
name|PRINTF2
argument_list|(
literal|"%08o%08o"
argument_list|,
name|num1
argument_list|,
name|num2
argument_list|)
expr_stmt|;
name|hp
operator|-=
literal|3
expr_stmt|;
name|len
operator|-=
literal|3
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Print a decimal integer to the terminal.  * This works by dividing the number by 10^2^N for some N, and  * then doing this recursively on the quotient and remainder.  * Decimals supplies number of decimal places to print, with a decimal  * point at the right location, with zero meaning no decimal point.  * Width is the number of columns to print the number in, including the  * decimal point and sign if required.  If zero, no extra output is done.  * If positive, leading spaces are typed if necessary. If negative, trailing  * spaces are typed if necessary.  As examples of the effects of these values,  * (345,0,0) = "345", (345,2,0) = "3.45", (345,5,8) = "  .00345".  */
end_comment

begin_function
specifier|static
name|void
name|zprintval
parameter_list|(
name|z
parameter_list|,
name|decimals
parameter_list|,
name|width
parameter_list|)
name|ZVALUE
name|z
decl_stmt|;
comment|/* number to be printed */
name|long
name|decimals
decl_stmt|;
comment|/* number of decimal places */
name|long
name|width
decl_stmt|;
comment|/* number of columns to print in */
block|{
name|int
name|depth
decl_stmt|;
comment|/* maximum depth */
name|int
name|n
decl_stmt|;
comment|/* current index into array */
name|int
name|i
decl_stmt|;
comment|/* number to print */
name|long
name|leadspaces
decl_stmt|;
comment|/* number of leading spaces to print */
name|long
name|putpoint
decl_stmt|;
comment|/* digits until print decimal point */
name|long
name|digits
decl_stmt|;
comment|/* number of digits of raw number */
name|BOOL
name|output
decl_stmt|;
comment|/* TRUE if have output something */
name|BOOL
name|neg
decl_stmt|;
comment|/* TRUE if negative */
name|ZVALUE
name|quo
decl_stmt|,
name|rem
decl_stmt|;
comment|/* quotient and remainder */
name|ZVALUE
name|leftnums
index|[
literal|32
index|]
decl_stmt|;
comment|/* left parts of the number */
name|ZVALUE
name|rightnums
index|[
literal|32
index|]
decl_stmt|;
comment|/* right parts of the number */
if|if
condition|(
name|decimals
operator|<
literal|0
condition|)
name|decimals
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|width
operator|<
literal|0
condition|)
name|width
operator|=
literal|0
expr_stmt|;
name|neg
operator|=
operator|(
name|z
operator|.
name|sign
operator|!=
literal|0
operator|)
expr_stmt|;
name|leadspaces
operator|=
name|width
operator|-
name|neg
operator|-
operator|(
name|decimals
operator|>
literal|0
operator|)
expr_stmt|;
name|z
operator|.
name|sign
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Find the 2^N power of ten which is greater than or equal 	 * to the number, calculating it the first time if necessary. 	 */
name|_tenpowers_
index|[
literal|0
index|]
operator|=
name|_ten_
expr_stmt|;
name|depth
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|_tenpowers_
index|[
name|depth
index|]
operator|.
name|len
operator|<
name|z
operator|.
name|len
operator|)
operator|||
operator|(
name|zrel
argument_list|(
name|_tenpowers_
index|[
name|depth
index|]
argument_list|,
name|z
argument_list|)
operator|<=
literal|0
operator|)
condition|)
block|{
name|depth
operator|++
expr_stmt|;
if|if
condition|(
name|_tenpowers_
index|[
name|depth
index|]
operator|.
name|len
operator|==
literal|0
condition|)
name|zsquare
argument_list|(
name|_tenpowers_
index|[
name|depth
operator|-
literal|1
index|]
argument_list|,
operator|&
name|_tenpowers_
index|[
name|depth
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Divide by smaller 2^N powers of ten until the parts are small 	 * enough to output.  This algorithm walks through a binary tree 	 * where each node is a piece of the number to print, and such that 	 * we visit left nodes first.  We do the needed recursion in line. 	 */
name|digits
operator|=
literal|1
expr_stmt|;
name|output
operator|=
name|FALSE
expr_stmt|;
name|n
operator|=
literal|0
expr_stmt|;
name|putpoint
operator|=
literal|0
expr_stmt|;
name|rightnums
index|[
literal|0
index|]
operator|.
name|len
operator|=
literal|0
expr_stmt|;
name|leftnums
index|[
literal|0
index|]
operator|=
name|z
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
while|while
condition|(
name|n
operator|<
name|depth
condition|)
block|{
name|i
operator|=
name|depth
operator|-
name|n
operator|-
literal|1
expr_stmt|;
name|zdiv
argument_list|(
name|leftnums
index|[
name|n
index|]
argument_list|,
name|_tenpowers_
index|[
name|i
index|]
argument_list|,
operator|&
name|quo
argument_list|,
operator|&
name|rem
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|iszero
argument_list|(
name|quo
argument_list|)
condition|)
name|digits
operator|+=
operator|(
literal|1L
operator|<<
name|i
operator|)
expr_stmt|;
name|n
operator|++
expr_stmt|;
name|leftnums
index|[
name|n
index|]
operator|=
name|quo
expr_stmt|;
name|rightnums
index|[
name|n
index|]
operator|=
name|rem
expr_stmt|;
block|}
name|i
operator|=
name|leftnums
index|[
name|n
index|]
operator|.
name|v
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|output
operator|||
name|i
operator|||
operator|(
name|n
operator|==
literal|0
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|output
condition|)
block|{
name|output
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|decimals
operator|>
name|digits
condition|)
name|leadspaces
operator|-=
name|decimals
expr_stmt|;
else|else
name|leadspaces
operator|-=
name|digits
expr_stmt|;
while|while
condition|(
operator|--
name|leadspaces
operator|>=
literal|0
condition|)
name|PUTCHAR
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
if|if
condition|(
name|neg
condition|)
name|PUTCHAR
argument_list|(
literal|'-'
argument_list|)
expr_stmt|;
if|if
condition|(
name|decimals
condition|)
block|{
name|putpoint
operator|=
operator|(
name|digits
operator|-
name|decimals
operator|)
expr_stmt|;
if|if
condition|(
name|putpoint
operator|<=
literal|0
condition|)
block|{
name|PUTCHAR
argument_list|(
literal|'.'
argument_list|)
expr_stmt|;
while|while
condition|(
operator|++
name|putpoint
operator|<=
literal|0
condition|)
name|PUTCHAR
argument_list|(
literal|'0'
argument_list|)
expr_stmt|;
name|putpoint
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
name|i
operator|+=
literal|'0'
expr_stmt|;
name|PUTCHAR
argument_list|(
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
operator|--
name|putpoint
operator|==
literal|0
condition|)
name|PUTCHAR
argument_list|(
literal|'.'
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|rightnums
index|[
name|n
index|]
operator|.
name|len
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|n
operator|<=
literal|0
condition|)
return|return;
if|if
condition|(
name|leftnums
index|[
name|n
index|]
operator|.
name|len
condition|)
name|freeh
argument_list|(
name|leftnums
index|[
name|n
index|]
operator|.
name|v
argument_list|)
expr_stmt|;
name|n
operator|--
expr_stmt|;
block|}
name|freeh
argument_list|(
name|leftnums
index|[
name|n
index|]
operator|.
name|v
argument_list|)
expr_stmt|;
name|leftnums
index|[
name|n
index|]
operator|=
name|rightnums
index|[
name|n
index|]
expr_stmt|;
name|rightnums
index|[
name|n
index|]
operator|.
name|len
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Convert a string to a number in rational, floating point,  * exponential notation, hex, or octal.  *	q = atoq(string);  */
end_comment

begin_function
name|NUMBER
modifier|*
name|atoq
parameter_list|(
name|s
parameter_list|)
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
block|{
specifier|register
name|NUMBER
modifier|*
name|q
decl_stmt|;
specifier|register
name|char
modifier|*
name|t
decl_stmt|;
name|ZVALUE
name|div
decl_stmt|,
name|newnum
decl_stmt|,
name|newden
decl_stmt|,
name|tmp
decl_stmt|;
name|long
name|decimals
decl_stmt|,
name|exp
decl_stmt|;
name|BOOL
name|hex
decl_stmt|,
name|negexp
decl_stmt|;
name|q
operator|=
name|qalloc
argument_list|()
expr_stmt|;
name|decimals
operator|=
literal|0
expr_stmt|;
name|exp
operator|=
literal|0
expr_stmt|;
name|negexp
operator|=
name|FALSE
expr_stmt|;
name|hex
operator|=
name|FALSE
expr_stmt|;
name|t
operator|=
name|s
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|t
operator|==
literal|'+'
operator|)
operator|||
operator|(
operator|*
name|t
operator|==
literal|'-'
operator|)
condition|)
name|t
operator|++
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|t
operator|==
literal|'0'
operator|)
operator|&&
operator|(
operator|(
name|t
index|[
literal|1
index|]
operator|==
literal|'x'
operator|)
operator|||
operator|(
name|t
index|[
literal|1
index|]
operator|==
literal|'X'
operator|)
operator|)
condition|)
block|{
name|hex
operator|=
name|TRUE
expr_stmt|;
name|t
operator|+=
literal|2
expr_stmt|;
block|}
while|while
condition|(
operator|(
operator|(
operator|*
name|t
operator|>=
literal|'0'
operator|)
operator|&&
operator|(
operator|*
name|t
operator|<=
literal|'9'
operator|)
operator|)
operator|||
operator|(
name|hex
operator|&&
operator|(
operator|(
operator|(
operator|*
name|t
operator|>=
literal|'a'
operator|)
operator|&&
operator|(
operator|*
name|t
operator|<=
literal|'f'
operator|)
operator|)
operator|||
operator|(
operator|(
operator|*
name|t
operator|>=
literal|'A'
operator|)
operator|&&
operator|(
operator|*
name|t
operator|<=
literal|'F'
operator|)
operator|)
operator|)
operator|)
condition|)
name|t
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|t
operator|==
literal|'/'
condition|)
block|{
name|t
operator|++
expr_stmt|;
name|atoz
argument_list|(
name|t
argument_list|,
operator|&
name|q
operator|->
name|den
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
operator|*
name|t
operator|==
literal|'.'
operator|)
operator|||
operator|(
operator|*
name|t
operator|==
literal|'e'
operator|)
operator|||
operator|(
operator|*
name|t
operator|==
literal|'E'
operator|)
condition|)
block|{
if|if
condition|(
operator|*
name|t
operator|==
literal|'.'
condition|)
block|{
name|t
operator|++
expr_stmt|;
while|while
condition|(
operator|(
operator|*
name|t
operator|>=
literal|'0'
operator|)
operator|&&
operator|(
operator|*
name|t
operator|<=
literal|'9'
operator|)
condition|)
block|{
name|t
operator|++
expr_stmt|;
name|decimals
operator|++
expr_stmt|;
block|}
block|}
comment|/* 		 * Parse exponent if any 		 */
if|if
condition|(
operator|(
operator|*
name|t
operator|==
literal|'e'
operator|)
operator|||
operator|(
operator|*
name|t
operator|==
literal|'E'
operator|)
condition|)
block|{
name|t
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|t
operator|==
literal|'+'
condition|)
name|t
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|t
operator|==
literal|'-'
condition|)
block|{
name|negexp
operator|=
name|TRUE
expr_stmt|;
name|t
operator|++
expr_stmt|;
block|}
while|while
condition|(
operator|(
operator|*
name|t
operator|>=
literal|'0'
operator|)
operator|&&
operator|(
operator|*
name|t
operator|<=
literal|'9'
operator|)
condition|)
block|{
name|exp
operator|=
operator|(
name|exp
operator|*
literal|10
operator|)
operator|+
operator|*
name|t
operator|++
operator|-
literal|'0'
expr_stmt|;
if|if
condition|(
name|exp
operator|>
literal|1000000
condition|)
name|error
argument_list|(
literal|"Exponent too large"
argument_list|)
expr_stmt|;
block|}
block|}
name|ztenpow
argument_list|(
name|decimals
argument_list|,
operator|&
name|q
operator|->
name|den
argument_list|)
expr_stmt|;
block|}
name|atoz
argument_list|(
name|s
argument_list|,
operator|&
name|q
operator|->
name|num
argument_list|)
expr_stmt|;
if|if
condition|(
name|qiszero
argument_list|(
name|q
argument_list|)
condition|)
block|{
name|qfree
argument_list|(
name|q
argument_list|)
expr_stmt|;
return|return
name|qlink
argument_list|(
operator|&
name|_qzero_
argument_list|)
return|;
block|}
comment|/* 	 * Apply the exponential if any 	 */
if|if
condition|(
name|exp
condition|)
block|{
name|ztenpow
argument_list|(
name|exp
argument_list|,
operator|&
name|tmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|negexp
condition|)
block|{
name|zmul
argument_list|(
name|q
operator|->
name|den
argument_list|,
name|tmp
argument_list|,
operator|&
name|newden
argument_list|)
expr_stmt|;
name|freeh
argument_list|(
name|q
operator|->
name|den
operator|.
name|v
argument_list|)
expr_stmt|;
name|q
operator|->
name|den
operator|=
name|newden
expr_stmt|;
block|}
else|else
block|{
name|zmul
argument_list|(
name|q
operator|->
name|num
argument_list|,
name|tmp
argument_list|,
operator|&
name|newnum
argument_list|)
expr_stmt|;
name|freeh
argument_list|(
name|q
operator|->
name|num
operator|.
name|v
argument_list|)
expr_stmt|;
name|q
operator|->
name|num
operator|=
name|newnum
expr_stmt|;
block|}
name|freeh
argument_list|(
name|tmp
operator|.
name|v
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Reduce the fraction to lowest terms 	 */
if|if
condition|(
name|isunit
argument_list|(
name|q
operator|->
name|num
argument_list|)
operator|||
name|isunit
argument_list|(
name|q
operator|->
name|den
argument_list|)
condition|)
return|return
name|q
return|;
name|zgcd
argument_list|(
name|q
operator|->
name|num
argument_list|,
name|q
operator|->
name|den
argument_list|,
operator|&
name|div
argument_list|)
expr_stmt|;
if|if
condition|(
name|isunit
argument_list|(
name|div
argument_list|)
condition|)
return|return
name|q
return|;
name|zquo
argument_list|(
name|q
operator|->
name|num
argument_list|,
name|div
argument_list|,
operator|&
name|newnum
argument_list|)
expr_stmt|;
name|freeh
argument_list|(
name|q
operator|->
name|num
operator|.
name|v
argument_list|)
expr_stmt|;
name|zquo
argument_list|(
name|q
operator|->
name|den
argument_list|,
name|div
argument_list|,
operator|&
name|newden
argument_list|)
expr_stmt|;
name|freeh
argument_list|(
name|q
operator|->
name|den
operator|.
name|v
argument_list|)
expr_stmt|;
name|q
operator|->
name|num
operator|=
name|newnum
expr_stmt|;
name|q
operator|->
name|den
operator|=
name|newden
expr_stmt|;
return|return
name|q
return|;
block|}
end_function

begin_comment
comment|/*  * Read an integer value in decimal, hex, octal, or binary.  * Hex numbers are indicated by a leading "0x", binary with a leading "0b",  * and octal by a leading "0".  Periods are skipped over, but any other  * extraneous character stops the scan.  */
end_comment

begin_function
specifier|static
name|void
name|atoz
parameter_list|(
name|s
parameter_list|,
name|res
parameter_list|)
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
name|ZVALUE
modifier|*
name|res
decl_stmt|;
block|{
name|ZVALUE
name|z
decl_stmt|,
name|ztmp
decl_stmt|,
name|digit
decl_stmt|;
name|HALF
name|digval
decl_stmt|;
name|BOOL
name|minus
decl_stmt|;
name|long
name|shift
decl_stmt|;
name|minus
operator|=
name|FALSE
expr_stmt|;
name|shift
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|'+'
condition|)
name|s
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|s
operator|==
literal|'-'
condition|)
block|{
name|minus
operator|=
name|TRUE
expr_stmt|;
name|s
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|s
operator|==
literal|'0'
condition|)
block|{
comment|/* possibly hex, octal, or binary */
name|s
operator|++
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|s
operator|>=
literal|'0'
operator|)
operator|&&
operator|(
operator|*
name|s
operator|<=
literal|'7'
operator|)
condition|)
block|{
name|shift
operator|=
literal|3
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
operator|*
name|s
operator|==
literal|'x'
operator|)
operator|||
operator|(
operator|*
name|s
operator|==
literal|'X'
operator|)
condition|)
block|{
name|shift
operator|=
literal|4
expr_stmt|;
name|s
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
operator|*
name|s
operator|==
literal|'b'
operator|)
operator|||
operator|(
operator|*
name|s
operator|==
literal|'B'
operator|)
condition|)
block|{
name|shift
operator|=
literal|1
expr_stmt|;
name|s
operator|++
expr_stmt|;
block|}
block|}
name|digit
operator|.
name|v
operator|=
operator|&
name|digval
expr_stmt|;
name|digit
operator|.
name|len
operator|=
literal|1
expr_stmt|;
name|digit
operator|.
name|sign
operator|=
literal|0
expr_stmt|;
name|z
operator|=
name|_zero_
expr_stmt|;
while|while
condition|(
operator|*
name|s
condition|)
block|{
name|digval
operator|=
operator|*
name|s
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|digval
operator|>=
literal|'0'
operator|)
operator|&&
operator|(
name|digval
operator|<=
literal|'9'
operator|)
condition|)
name|digval
operator|-=
literal|'0'
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|digval
operator|>=
literal|'a'
operator|)
operator|&&
operator|(
name|digval
operator|<=
literal|'f'
operator|)
operator|&&
name|shift
condition|)
name|digval
operator|-=
operator|(
literal|'a'
operator|-
literal|10
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|digval
operator|>=
literal|'A'
operator|)
operator|&&
operator|(
name|digval
operator|<=
literal|'F'
operator|)
operator|&&
name|shift
condition|)
name|digval
operator|-=
operator|(
literal|'A'
operator|-
literal|10
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
name|digval
operator|==
literal|'.'
condition|)
continue|continue;
else|else
break|break;
if|if
condition|(
name|shift
condition|)
name|zshift
argument_list|(
name|z
argument_list|,
name|shift
argument_list|,
operator|&
name|ztmp
argument_list|)
expr_stmt|;
else|else
name|zmuli
argument_list|(
name|z
argument_list|,
literal|10L
argument_list|,
operator|&
name|ztmp
argument_list|)
expr_stmt|;
name|freeh
argument_list|(
name|z
operator|.
name|v
argument_list|)
expr_stmt|;
name|zadd
argument_list|(
name|ztmp
argument_list|,
name|digit
argument_list|,
operator|&
name|z
argument_list|)
expr_stmt|;
name|freeh
argument_list|(
name|ztmp
operator|.
name|v
argument_list|)
expr_stmt|;
block|}
name|trim
argument_list|(
operator|&
name|z
argument_list|)
expr_stmt|;
if|if
condition|(
name|minus
operator|&&
operator|!
name|iszero
argument_list|(
name|z
argument_list|)
condition|)
name|z
operator|.
name|sign
operator|=
literal|1
expr_stmt|;
operator|*
name|res
operator|=
name|z
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Parse a number in any of the various legal forms, and return the count  * of characters that are part of a legal number.  Numbers can be either a  * decimal integer, possibly two decimal integers separated with a slash, a  * floating point or exponential number, a hex number beginning with "0x",  * a binary number beginning with "0b", or an octal number beginning with "0".  * The flags argument modifies the end of number testing for ease in handling  * fractions or complex numbers.  Minus one is returned if the number format  * is definitely illegal.  */
end_comment

begin_function
name|long
name|qparse
parameter_list|(
name|cp
parameter_list|,
name|flags
parameter_list|)
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
block|{
name|char
modifier|*
name|oldcp
decl_stmt|;
name|oldcp
operator|=
name|cp
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|cp
operator|==
literal|'+'
operator|)
operator|||
operator|(
operator|*
name|cp
operator|==
literal|'-'
operator|)
condition|)
name|cp
operator|++
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|cp
operator|==
literal|'+'
operator|)
operator|||
operator|(
operator|*
name|cp
operator|==
literal|'-'
operator|)
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
operator|(
operator|*
name|cp
operator|==
literal|'0'
operator|)
operator|&&
operator|(
operator|(
name|cp
index|[
literal|1
index|]
operator|==
literal|'x'
operator|)
operator|||
operator|(
name|cp
index|[
literal|1
index|]
operator|==
literal|'X'
operator|)
operator|)
condition|)
block|{
comment|/* hex */
name|cp
operator|+=
literal|2
expr_stmt|;
while|while
condition|(
operator|(
operator|(
operator|*
name|cp
operator|>=
literal|'0'
operator|)
operator|&&
operator|(
operator|*
name|cp
operator|<=
literal|'9'
operator|)
operator|)
operator|||
operator|(
operator|(
operator|*
name|cp
operator|>=
literal|'a'
operator|)
operator|&&
operator|(
operator|*
name|cp
operator|<=
literal|'f'
operator|)
operator|)
operator|||
operator|(
operator|(
operator|*
name|cp
operator|>=
literal|'A'
operator|)
operator|&&
operator|(
operator|*
name|cp
operator|<=
literal|'F'
operator|)
operator|)
condition|)
name|cp
operator|++
expr_stmt|;
goto|goto
name|done
goto|;
block|}
if|if
condition|(
operator|(
operator|*
name|cp
operator|==
literal|'0'
operator|)
operator|&&
operator|(
operator|(
name|cp
index|[
literal|1
index|]
operator|==
literal|'b'
operator|)
operator|||
operator|(
name|cp
index|[
literal|1
index|]
operator|==
literal|'B'
operator|)
operator|)
condition|)
block|{
comment|/* binary */
name|cp
operator|+=
literal|2
expr_stmt|;
while|while
condition|(
operator|(
operator|*
name|cp
operator|==
literal|'0'
operator|)
operator|||
operator|(
operator|*
name|cp
operator|==
literal|'1'
operator|)
condition|)
name|cp
operator|++
expr_stmt|;
goto|goto
name|done
goto|;
block|}
if|if
condition|(
operator|(
operator|*
name|cp
operator|==
literal|'0'
operator|)
operator|&&
operator|(
name|cp
index|[
literal|1
index|]
operator|>=
literal|'0'
operator|)
operator|&&
operator|(
name|cp
index|[
literal|1
index|]
operator|<=
literal|'9'
operator|)
condition|)
block|{
comment|/* octal */
while|while
condition|(
operator|(
operator|*
name|cp
operator|>=
literal|'0'
operator|)
operator|&&
operator|(
operator|*
name|cp
operator|<=
literal|'7'
operator|)
condition|)
name|cp
operator|++
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* 	 * Number is decimal, but can still be a fraction or real or exponential. 	 */
while|while
condition|(
operator|(
operator|*
name|cp
operator|>=
literal|'0'
operator|)
operator|&&
operator|(
operator|*
name|cp
operator|<=
literal|'9'
operator|)
condition|)
name|cp
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|cp
operator|==
literal|'/'
operator|&&
name|flags
operator|&
name|QPF_SLASH
condition|)
block|{
comment|/* fraction */
name|cp
operator|++
expr_stmt|;
while|while
condition|(
operator|(
operator|*
name|cp
operator|>=
literal|'0'
operator|)
operator|&&
operator|(
operator|*
name|cp
operator|<=
literal|'9'
operator|)
condition|)
name|cp
operator|++
expr_stmt|;
goto|goto
name|done
goto|;
block|}
if|if
condition|(
operator|*
name|cp
operator|==
literal|'.'
condition|)
block|{
comment|/* floating point */
name|cp
operator|++
expr_stmt|;
while|while
condition|(
operator|(
operator|*
name|cp
operator|>=
literal|'0'
operator|)
operator|&&
operator|(
operator|*
name|cp
operator|<=
literal|'9'
operator|)
condition|)
name|cp
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|(
operator|*
name|cp
operator|==
literal|'e'
operator|)
operator|||
operator|(
operator|*
name|cp
operator|==
literal|'E'
operator|)
condition|)
block|{
comment|/* exponential */
name|cp
operator|++
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|cp
operator|==
literal|'+'
operator|)
operator|||
operator|(
operator|*
name|cp
operator|==
literal|'-'
operator|)
condition|)
name|cp
operator|++
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|cp
operator|==
literal|'+'
operator|)
operator|||
operator|(
operator|*
name|cp
operator|==
literal|'-'
operator|)
condition|)
return|return
operator|-
literal|1
return|;
while|while
condition|(
operator|(
operator|*
name|cp
operator|>=
literal|'0'
operator|)
operator|&&
operator|(
operator|*
name|cp
operator|<=
literal|'9'
operator|)
condition|)
name|cp
operator|++
expr_stmt|;
block|}
name|done
label|:
if|if
condition|(
operator|(
operator|(
operator|*
name|cp
operator|==
literal|'i'
operator|)
operator|||
operator|(
operator|*
name|cp
operator|==
literal|'I'
operator|)
operator|)
operator|&&
operator|(
name|flags
operator|&
name|QPF_IMAG
operator|)
condition|)
name|cp
operator|++
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|cp
operator|==
literal|'.'
operator|)
operator|||
operator|(
operator|(
operator|*
name|cp
operator|==
literal|'/'
operator|)
operator|&&
operator|(
name|flags
operator|&
name|QPF_SLASH
operator|)
operator|)
operator|||
operator|(
operator|(
operator|*
name|cp
operator|>=
literal|'0'
operator|)
operator|&&
operator|(
operator|*
name|cp
operator|<=
literal|'9'
operator|)
operator|)
operator|||
operator|(
operator|(
operator|*
name|cp
operator|>=
literal|'a'
operator|)
operator|&&
operator|(
operator|*
name|cp
operator|<=
literal|'z'
operator|)
operator|)
operator|||
operator|(
operator|(
operator|*
name|cp
operator|>=
literal|'A'
operator|)
operator|&&
operator|(
operator|*
name|cp
operator|<=
literal|'Z'
operator|)
operator|)
condition|)
return|return
operator|-
literal|1
return|;
return|return
operator|(
name|cp
operator|-
name|oldcp
operator|)
return|;
block|}
end_function

begin_comment
comment|/* END CODE */
end_comment

end_unit

