begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1993 David I. Bell  * Permission is granted to use, distribute, or modify this source,  * provided that this copyright notice remains intact.  *  * Nested input source file reader.  * For terminal input, this also provides a simple command stack.  */
end_comment

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<pwd.h>
end_include

begin_include
include|#
directive|include
file|"calc.h"
end_include

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"hist.h"
end_include

begin_define
define|#
directive|define
name|MAXSAVE
value|255
end_define

begin_comment
comment|/* number of saved terminal lines */
end_comment

begin_define
define|#
directive|define
name|TTYSIZE
value|100
end_define

begin_comment
comment|/* reallocation size for terminal buffers */
end_comment

begin_define
define|#
directive|define
name|DEPTH
value|10
end_define

begin_comment
comment|/* maximum depth of input */
end_comment

begin_define
define|#
directive|define
name|IS_READ
value|1
end_define

begin_comment
comment|/* reading normally */
end_comment

begin_define
define|#
directive|define
name|IS_REREAD
value|2
end_define

begin_comment
comment|/* reread current character */
end_comment

begin_define
define|#
directive|define
name|chartoint
parameter_list|(
name|ch
parameter_list|)
value|((ch)& 0xff)
end_define

begin_comment
comment|/* make sure char is not negative */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|short
name|i_state
decl_stmt|;
comment|/* state (read, reread) */
name|short
name|i_char
decl_stmt|;
comment|/* currently read char */
name|long
name|i_line
decl_stmt|;
comment|/* line number */
name|char
modifier|*
name|i_str
decl_stmt|;
comment|/* current string for input (if not NULL) */
name|char
modifier|*
name|i_origstr
decl_stmt|;
comment|/* original string so it can be freed */
name|char
modifier|*
name|i_ttystr
decl_stmt|;
comment|/* current character of tty line (or NULL) */
name|FILE
modifier|*
name|i_fp
decl_stmt|;
comment|/* current file for input (if not NULL) */
name|char
modifier|*
name|i_name
decl_stmt|;
comment|/* file name if known */
block|}
name|INPUT
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|int
name|stacksize
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of elements in command stack */
end_comment

begin_decl_stmt
specifier|static
name|int
name|stackindex
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* current index into command stack */
end_comment

begin_decl_stmt
specifier|static
name|int
name|cmdsize
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* current max size of terminal buffer */
end_comment

begin_decl_stmt
specifier|static
name|int
name|editsize
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* current max size of edit buffer */
end_comment

begin_decl_stmt
specifier|static
name|int
name|linesize
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* current max size of input line */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|linebuf
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* current input line buffer */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|cmdbuf
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* current command line buffer */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|editbuf
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* edit buffer */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
modifier|*
name|cmdstack
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* command stack */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|prompt
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* current prompt for terminal */
end_comment

begin_decl_stmt
specifier|static
name|BOOL
name|noprompt
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* TRUE if should not print prompt */
end_comment

begin_decl_stmt
specifier|static
name|int
name|depth
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* current input depth */
end_comment

begin_decl_stmt
specifier|static
name|INPUT
modifier|*
name|cip
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* current input source */
end_comment

begin_decl_stmt
specifier|static
name|INPUT
name|inputs
index|[
name|DEPTH
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* input sources */
end_comment

begin_function_decl
specifier|static
name|int
name|openfile
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ttychar
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|struct
name|passwd
modifier|*
name|getpwnam
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/*  * Open an input file by possibly searching through a path list  * and also possibly applying the specified extension.  For example:  * opensearchfile("barf", ".:/tmp", ".c") searches in order for the  * files "./barf", "./barf.c", "/tmp/barf", and "/tmp/barf.c".  *  * Returns -1 if all specified files cannot be opened.  */
end_comment

begin_macro
name|opensearchfile
argument_list|(
argument|name
argument_list|,
argument|pathlist
argument_list|,
argument|extension
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|name
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* file name to be read */
end_comment

begin_decl_stmt
name|char
modifier|*
name|pathlist
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* list of colon separated paths (or NULL) */
end_comment

begin_decl_stmt
name|char
modifier|*
name|extension
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* extra extension to try (or NULL) */
end_comment

begin_block
block|{
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
name|char
name|path
index|[
name|PATHSIZE
operator|+
literal|1
index|]
decl_stmt|;
comment|/* name being searched for */
comment|/* 	 * Don't try the extension if the filename already contains it. 	 */
if|if
condition|(
name|extension
condition|)
block|{
name|i
operator|=
name|strlen
argument_list|(
name|name
argument_list|)
operator|-
name|strlen
argument_list|(
name|extension
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|>=
literal|0
operator|)
operator|&&
operator|(
name|strcmp
argument_list|(
operator|&
name|name
index|[
name|i
index|]
argument_list|,
name|extension
argument_list|)
operator|==
literal|0
operator|)
condition|)
name|extension
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* 	 * If the name is absolute, or if there is no path list, then 	 * make one which just searches for the name straight.  Then 	 * search through the path list for the file, without and with 	 * the specified extension. 	 */
if|if
condition|(
name|name
index|[
literal|0
index|]
operator|==
name|PATHCHAR
operator|||
name|name
index|[
literal|0
index|]
operator|==
name|HOMECHAR
operator|||
operator|(
name|name
index|[
literal|0
index|]
operator|==
name|DOTCHAR
operator|&&
name|name
index|[
literal|1
index|]
operator|==
name|PATHCHAR
operator|)
operator|||
name|pathlist
operator|==
name|NULL
condition|)
block|{
name|pathlist
operator|=
literal|""
expr_stmt|;
block|}
name|pathlist
operator|--
expr_stmt|;
do|do
block|{
name|pathlist
operator|++
expr_stmt|;
name|cp
operator|=
name|path
expr_stmt|;
while|while
condition|(
operator|*
name|pathlist
operator|&&
operator|(
operator|*
name|pathlist
operator|!=
name|LISTCHAR
operator|)
condition|)
operator|*
name|cp
operator|++
operator|=
operator|*
name|pathlist
operator|++
expr_stmt|;
if|if
condition|(
name|cp
operator|!=
name|path
condition|)
operator|*
name|cp
operator|++
operator|=
name|PATHCHAR
expr_stmt|;
name|strcpy
argument_list|(
name|cp
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|i
operator|=
name|openfile
argument_list|(
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|<
literal|0
operator|)
operator|&&
name|extension
condition|)
block|{
name|strcat
argument_list|(
name|path
argument_list|,
name|extension
argument_list|)
expr_stmt|;
name|i
operator|=
name|openfile
argument_list|(
name|path
argument_list|)
expr_stmt|;
block|}
block|}
do|while
condition|(
operator|(
name|i
operator|<
literal|0
operator|)
operator|&&
operator|*
name|pathlist
condition|)
do|;
return|return
name|i
return|;
block|}
end_block

begin_comment
comment|/*  * Given a filename with a leading ~, expand it into a home directory for   * that user.  This function will malloc the space for the expanded path.  *  * If the path is just ~, or begins with ~/, expand it to the home  * directory of the current user.  If the environment variable $HOME  * is known, it will be used, otherwise the password file will be  * consulted.  *  * If the path is just ~username, or ~username/, expand it to the home  * directory of that user by looking it up in the password file.  *  * If the password file must be consulted and the username is not found  * a NULL pointer is returned.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|homeexpand
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
comment|/* a filename with a leading ~ */
block|{
name|struct
name|passwd
modifier|*
name|ent
decl_stmt|;
comment|/* password entry */
name|char
modifier|*
name|home2
decl_stmt|;
comment|/* fullpath of the home directory */
name|char
modifier|*
name|fullpath
decl_stmt|;
comment|/* the malloced expanded path */
name|char
modifier|*
name|after
decl_stmt|;
comment|/* after the ~user or ~ */
name|char
name|username
index|[
name|PATHSIZE
operator|+
literal|1
index|]
decl_stmt|;
comment|/* extratced username */
comment|/* firewall */
if|if
condition|(
name|name
index|[
literal|0
index|]
operator|!=
name|HOMECHAR
condition|)
return|return
name|NULL
return|;
comment|/* 	 * obtain the home directory component 	 */
switch|switch
condition|(
name|name
index|[
literal|1
index|]
condition|)
block|{
case|case
name|PATHCHAR
case|:
comment|/* ~/... */
case|case
literal|'\0'
case|:
comment|/* ~ */
name|home2
operator|=
name|home
expr_stmt|;
name|after
operator|=
name|name
operator|+
literal|1
expr_stmt|;
break|break;
default|default:
comment|/* ~username or ~username/... */
comment|/* extract the username after the ~ */
name|after
operator|=
operator|(
name|char
operator|*
operator|)
name|strchr
argument_list|(
name|name
operator|+
literal|2
argument_list|,
name|PATHCHAR
argument_list|)
expr_stmt|;
if|if
condition|(
name|after
operator|==
name|NULL
condition|)
block|{
comment|/* path is just ~username */
name|ent
operator|=
name|getpwnam
argument_list|(
name|name
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ent
operator|==
name|NULL
condition|)
block|{
comment|/* unknown user */
return|return
name|NULL
return|;
block|}
comment|/* just malloc the home directory and return it */
name|fullpath
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|strlen
argument_list|(
name|ent
operator|->
name|pw_dir
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|fullpath
argument_list|,
name|ent
operator|->
name|pw_dir
argument_list|)
expr_stmt|;
return|return
name|fullpath
return|;
block|}
if|if
condition|(
name|after
operator|-
name|name
operator|>
name|PATHSIZE
operator|+
literal|1
condition|)
block|{
comment|/* username is too big */
return|return
name|NULL
return|;
block|}
name|strncpy
argument_list|(
name|username
argument_list|,
name|name
operator|+
literal|1
argument_list|,
name|after
operator|-
name|name
operator|-
literal|1
argument_list|)
expr_stmt|;
name|username
index|[
name|after
operator|-
name|name
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* get that user's home directory */
name|ent
operator|=
name|getpwnam
argument_list|(
name|username
argument_list|)
expr_stmt|;
if|if
condition|(
name|ent
operator|==
name|NULL
condition|)
block|{
comment|/* unknown user */
return|return
name|NULL
return|;
block|}
name|home2
operator|=
name|ent
operator|->
name|pw_dir
expr_stmt|;
break|break;
block|}
comment|/* 	 * build the fullpath given the home directory 	 */
name|fullpath
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|strlen
argument_list|(
name|home2
argument_list|)
operator|+
name|strlen
argument_list|(
name|after
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|fullpath
argument_list|,
literal|"%s%s"
argument_list|,
name|home2
argument_list|,
name|after
argument_list|)
expr_stmt|;
return|return
name|fullpath
return|;
block|}
end_function

begin_comment
comment|/*  * f_open - ~-expand a filename and fopen() it  */
end_comment

begin_function
name|FILE
modifier|*
name|f_open
parameter_list|(
name|name
parameter_list|,
name|mode
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
comment|/* the filename to open */
name|char
modifier|*
name|mode
decl_stmt|;
comment|/* the fopen mode to use */
block|{
name|FILE
modifier|*
name|fp
decl_stmt|;
comment|/* open file descriptor */
name|char
modifier|*
name|fullname
decl_stmt|;
comment|/* file name with HOMECHAR expansion */
comment|/* 	 * expand ~ if needed 	 */
if|if
condition|(
name|name
index|[
literal|0
index|]
operator|==
name|HOMECHAR
condition|)
block|{
name|fullname
operator|=
name|homeexpand
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|fullname
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|fp
operator|=
name|fopen
argument_list|(
name|fullname
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|fullname
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fp
operator|=
name|fopen
argument_list|(
name|name
argument_list|,
name|mode
argument_list|)
expr_stmt|;
block|}
return|return
name|fp
return|;
block|}
end_function

begin_comment
comment|/*  * Setup for reading from a input file.  * Returns -1 if file could not be opened.  */
end_comment

begin_expr_stmt
specifier|static
name|openfile
argument_list|(
argument|name
argument_list|)
name|char
operator|*
name|name
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* file name to be read */
end_comment

begin_block
block|{
name|FILE
modifier|*
name|fp
decl_stmt|;
comment|/* open file descriptor */
if|if
condition|(
name|depth
operator|>=
name|DEPTH
condition|)
return|return
operator|-
literal|1
return|;
name|fp
operator|=
name|f_open
argument_list|(
name|name
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
name|cip
operator|++
expr_stmt|;
name|cip
operator|->
name|i_state
operator|=
name|IS_READ
expr_stmt|;
name|cip
operator|->
name|i_char
operator|=
literal|'\0'
expr_stmt|;
name|cip
operator|->
name|i_str
operator|=
name|NULL
expr_stmt|;
name|cip
operator|->
name|i_origstr
operator|=
name|NULL
expr_stmt|;
name|cip
operator|->
name|i_ttystr
operator|=
name|NULL
expr_stmt|;
name|cip
operator|->
name|i_fp
operator|=
name|fp
expr_stmt|;
name|cip
operator|->
name|i_line
operator|=
literal|1
expr_stmt|;
name|cip
operator|->
name|i_name
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|cip
operator|->
name|i_name
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|depth
operator|++
expr_stmt|;
return|return
literal|0
return|;
block|}
end_block

begin_comment
comment|/*  * Open a string for scanning. String is ended by a null character.  * String is copied into local memory so it can be trashed afterwards.  * Returns -1 if cannot open string.  */
end_comment

begin_macro
name|openstring
argument_list|(
argument|str
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|str
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* string to be opened */
end_comment

begin_block
block|{
name|char
modifier|*
name|cp
decl_stmt|;
comment|/* copied string */
if|if
condition|(
operator|(
name|depth
operator|>=
name|DEPTH
operator|)
operator|||
operator|(
name|str
operator|==
name|NULL
operator|)
condition|)
return|return
operator|-
literal|1
return|;
name|cp
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|strlen
argument_list|(
name|str
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
name|strcpy
argument_list|(
name|cp
argument_list|,
name|str
argument_list|)
expr_stmt|;
name|cip
operator|++
expr_stmt|;
name|cip
operator|->
name|i_state
operator|=
name|IS_READ
expr_stmt|;
name|cip
operator|->
name|i_char
operator|=
literal|'\0'
expr_stmt|;
name|cip
operator|->
name|i_str
operator|=
name|cp
expr_stmt|;
name|cip
operator|->
name|i_origstr
operator|=
name|cp
expr_stmt|;
name|cip
operator|->
name|i_fp
operator|=
name|NULL
expr_stmt|;
name|cip
operator|->
name|i_name
operator|=
name|NULL
expr_stmt|;
name|cip
operator|->
name|i_ttystr
operator|=
name|NULL
expr_stmt|;
name|cip
operator|->
name|i_line
operator|=
literal|1
expr_stmt|;
name|depth
operator|++
expr_stmt|;
return|return
literal|0
return|;
block|}
end_block

begin_comment
comment|/*  * Set to read input from the terminal.  * Returns -1 if there is no more depth for input.  */
end_comment

begin_macro
name|openterminal
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|depth
operator|>=
name|DEPTH
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|cmdsize
operator|==
literal|0
condition|)
block|{
name|cmdbuf
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|TTYSIZE
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmdbuf
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
name|cmdsize
operator|=
name|TTYSIZE
expr_stmt|;
block|}
if|if
condition|(
name|editsize
operator|==
literal|0
condition|)
block|{
name|editbuf
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|TTYSIZE
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|editbuf
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
name|editsize
operator|=
name|TTYSIZE
expr_stmt|;
block|}
if|if
condition|(
name|stacksize
operator|==
literal|0
condition|)
block|{
name|cmdstack
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|malloc
argument_list|(
name|MAXSAVE
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmdstack
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
name|stacksize
operator|=
name|MAXSAVE
expr_stmt|;
for|for
control|(
name|stackindex
operator|=
literal|0
init|;
name|stackindex
operator|<
name|MAXSAVE
condition|;
name|stackindex
operator|++
control|)
name|cmdstack
index|[
name|stackindex
index|]
operator|=
name|NULL
expr_stmt|;
name|stackindex
operator|=
literal|0
expr_stmt|;
block|}
name|cip
operator|++
expr_stmt|;
name|cip
operator|->
name|i_state
operator|=
name|IS_READ
expr_stmt|;
name|cip
operator|->
name|i_char
operator|=
literal|'\0'
expr_stmt|;
name|cip
operator|->
name|i_str
operator|=
name|NULL
expr_stmt|;
name|cip
operator|->
name|i_origstr
operator|=
name|NULL
expr_stmt|;
name|cip
operator|->
name|i_ttystr
operator|=
name|NULL
expr_stmt|;
name|cip
operator|->
name|i_fp
operator|=
name|NULL
expr_stmt|;
name|cip
operator|->
name|i_name
operator|=
name|NULL
expr_stmt|;
name|cip
operator|->
name|i_line
operator|=
literal|1
expr_stmt|;
name|depth
operator|++
expr_stmt|;
return|return
literal|0
return|;
block|}
end_block

begin_comment
comment|/*  * Close the current input source.  */
end_comment

begin_function
specifier|static
name|void
name|closeinput
parameter_list|()
block|{
if|if
condition|(
name|depth
operator|<=
literal|0
condition|)
return|return;
if|if
condition|(
name|cip
operator|->
name|i_origstr
condition|)
name|free
argument_list|(
name|cip
operator|->
name|i_origstr
argument_list|)
expr_stmt|;
if|if
condition|(
name|cip
operator|->
name|i_fp
condition|)
name|fclose
argument_list|(
name|cip
operator|->
name|i_fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|cip
operator|->
name|i_name
condition|)
name|free
argument_list|(
name|cip
operator|->
name|i_name
argument_list|)
expr_stmt|;
name|cip
operator|--
expr_stmt|;
name|depth
operator|--
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Reset the input sources back to the initial state.  */
end_comment

begin_function
name|void
name|resetinput
parameter_list|()
block|{
while|while
condition|(
name|depth
operator|>
literal|0
condition|)
name|closeinput
argument_list|()
expr_stmt|;
name|cip
operator|=
name|inputs
expr_stmt|;
name|noprompt
operator|=
name|FALSE
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Set the prompt for terminal input.  */
end_comment

begin_function
name|void
name|setprompt
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|prompt
operator|=
name|str
expr_stmt|;
name|noprompt
operator|=
name|FALSE
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Read the next character from the current input source.  * End of file returns newline character and closes current input source,  * except for the last input source, which returns EOF.  */
end_comment

begin_function
name|int
name|nextchar
parameter_list|()
block|{
name|int
name|ch
decl_stmt|;
comment|/* current input character */
if|if
condition|(
name|depth
operator|==
literal|0
condition|)
comment|/* input finished */
return|return
name|EOF
return|;
if|if
condition|(
name|cip
operator|->
name|i_state
operator|==
name|IS_REREAD
condition|)
block|{
comment|/* rereading current char */
name|ch
operator|=
name|cip
operator|->
name|i_char
expr_stmt|;
name|cip
operator|->
name|i_state
operator|=
name|IS_READ
expr_stmt|;
if|if
condition|(
name|ch
operator|==
literal|'\n'
condition|)
name|cip
operator|->
name|i_line
operator|++
expr_stmt|;
return|return
name|ch
return|;
block|}
if|if
condition|(
name|cip
operator|->
name|i_str
condition|)
block|{
comment|/* from string */
name|ch
operator|=
name|chartoint
argument_list|(
operator|*
name|cip
operator|->
name|i_str
operator|++
argument_list|)
expr_stmt|;
if|if
condition|(
name|ch
operator|==
literal|'\0'
condition|)
name|ch
operator|=
name|EOF
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cip
operator|->
name|i_fp
condition|)
block|{
comment|/* from file */
name|ch
operator|=
name|fgetc
argument_list|(
name|cip
operator|->
name|i_fp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* from terminal */
name|ch
operator|=
name|ttychar
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|ch
operator|==
name|EOF
condition|)
block|{
comment|/* fix up end of file */
name|closeinput
argument_list|()
expr_stmt|;
name|ch
operator|=
literal|'\n'
expr_stmt|;
if|if
condition|(
name|depth
operator|<=
literal|0
condition|)
name|ch
operator|=
name|EOF
expr_stmt|;
block|}
if|if
condition|(
name|depth
operator|>
literal|0
condition|)
name|cip
operator|->
name|i_char
operator|=
operator|(
name|char
operator|)
name|ch
expr_stmt|;
comment|/* save for rereads */
if|if
condition|(
name|ch
operator|==
literal|'\n'
condition|)
name|cip
operator|->
name|i_line
operator|++
expr_stmt|;
return|return
name|ch
return|;
block|}
end_function

begin_comment
comment|/*  * Read in the next line of input from the current input source.  * The line is terminated with a null character, and does not contain  * the final newline character.  The returned string is only valid  * until the next such call, and so must be copied if necessary.  * Returns NULL on end of file.  */
end_comment

begin_function
name|char
modifier|*
name|nextline
parameter_list|()
block|{
name|char
modifier|*
name|cp
decl_stmt|;
name|int
name|ch
decl_stmt|;
name|int
name|len
decl_stmt|;
name|cp
operator|=
name|linebuf
expr_stmt|;
if|if
condition|(
name|linesize
operator|==
literal|0
condition|)
block|{
name|cp
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|TTYSIZE
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|"Cannot allocate line buffer"
argument_list|)
expr_stmt|;
name|linebuf
operator|=
name|cp
expr_stmt|;
name|linesize
operator|=
name|TTYSIZE
expr_stmt|;
block|}
name|len
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|noprompt
operator|=
name|TRUE
expr_stmt|;
name|ch
operator|=
name|nextchar
argument_list|()
expr_stmt|;
name|noprompt
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|ch
operator|==
name|EOF
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|ch
operator|==
literal|'\0'
condition|)
continue|continue;
if|if
condition|(
name|ch
operator|==
literal|'\n'
condition|)
break|break;
if|if
condition|(
name|len
operator|>=
name|linesize
condition|)
block|{
name|cp
operator|=
operator|(
name|char
operator|*
operator|)
name|realloc
argument_list|(
name|cp
argument_list|,
name|linesize
operator|+
name|TTYSIZE
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|"Cannot realloc line buffer"
argument_list|)
expr_stmt|;
name|linebuf
operator|=
name|cp
expr_stmt|;
name|linesize
operator|+=
name|TTYSIZE
expr_stmt|;
block|}
name|cp
index|[
name|len
operator|++
index|]
operator|=
operator|(
name|char
operator|)
name|ch
expr_stmt|;
block|}
name|cp
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
name|linebuf
return|;
block|}
end_function

begin_comment
comment|/*  * Read the next character from the terminal.  * The routines in the history module are called so that the user  * can use a command history and emacs-like editing of the line.  */
end_comment

begin_function
specifier|static
name|int
name|ttychar
parameter_list|()
block|{
name|int
name|ch
decl_stmt|;
comment|/* current char */
name|int
name|len
decl_stmt|;
comment|/* length of current command */
specifier|static
name|char
name|charbuf
index|[
literal|1000
index|]
decl_stmt|;
comment|/* 	 * If we have more to read from the saved command line, then do that. 	 * When we see a newline character, then clear the pointer so we will 	 * read a new line on the next call. 	 */
if|if
condition|(
name|cip
operator|->
name|i_ttystr
condition|)
block|{
name|ch
operator|=
name|chartoint
argument_list|(
operator|*
name|cip
operator|->
name|i_ttystr
operator|++
argument_list|)
expr_stmt|;
if|if
condition|(
name|ch
operator|==
literal|'\n'
condition|)
name|cip
operator|->
name|i_ttystr
operator|=
name|NULL
expr_stmt|;
return|return
name|ch
return|;
block|}
comment|/* 	 * We need another complete line. 	 */
name|abortlevel
operator|=
literal|0
expr_stmt|;
name|inputwait
operator|=
name|TRUE
expr_stmt|;
name|len
operator|=
name|hist_getline
argument_list|(
name|noprompt
condition|?
literal|""
else|:
name|prompt
argument_list|,
name|charbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|charbuf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
condition|)
block|{
name|inputwait
operator|=
name|FALSE
expr_stmt|;
return|return
name|EOF
return|;
block|}
name|inputwait
operator|=
name|FALSE
expr_stmt|;
comment|/* 	 * Handle shell escape if present 	 */
if|if
condition|(
name|charbuf
index|[
literal|0
index|]
operator|==
literal|'!'
condition|)
block|{
comment|/* do a shell command */
name|char
modifier|*
name|cmd
decl_stmt|;
name|cmd
operator|=
name|charbuf
operator|+
literal|1
expr_stmt|;
if|if
condition|(
operator|*
name|cmd
operator|==
literal|'\0'
operator|||
operator|*
name|cmd
operator|==
literal|'\n'
condition|)
name|cmd
operator|=
name|shell
expr_stmt|;
name|system
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
return|return
literal|'\n'
return|;
block|}
name|hist_saveline
argument_list|(
name|charbuf
argument_list|,
name|len
argument_list|)
expr_stmt|;
comment|/* 	 * Return the first character of the line, and set up to 	 * return the rest of it with later calls. 	 */
name|ch
operator|=
name|chartoint
argument_list|(
name|charbuf
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|ch
operator|!=
literal|'\n'
condition|)
name|cip
operator|->
name|i_ttystr
operator|=
name|charbuf
operator|+
literal|1
expr_stmt|;
return|return
name|ch
return|;
block|}
end_function

begin_comment
comment|/*  * Return whether or not the input source is the terminal.  */
end_comment

begin_function
name|BOOL
name|inputisterminal
parameter_list|()
block|{
return|return
operator|(
operator|(
name|depth
operator|<=
literal|0
operator|)
operator|||
operator|(
operator|(
name|cip
operator|->
name|i_str
operator|==
name|NULL
operator|)
operator|&&
operator|(
name|cip
operator|->
name|i_fp
operator|==
name|NULL
operator|)
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Return the name of the current input file.  * Returns NULL for terminal or strings.  */
end_comment

begin_function
name|char
modifier|*
name|inputname
parameter_list|()
block|{
if|if
condition|(
name|depth
operator|<=
literal|0
condition|)
return|return
name|NULL
return|;
return|return
name|cip
operator|->
name|i_name
return|;
block|}
end_function

begin_comment
comment|/*  * Return the current line number.  */
end_comment

begin_function
name|long
name|linenumber
parameter_list|()
block|{
if|if
condition|(
name|depth
operator|>
literal|0
condition|)
return|return
name|cip
operator|->
name|i_line
return|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * Restore the next character to be read again on the next nextchar call.  */
end_comment

begin_function
name|void
name|reread
parameter_list|()
block|{
if|if
condition|(
operator|(
name|depth
operator|<=
literal|0
operator|)
operator|||
operator|(
name|cip
operator|->
name|i_state
operator|==
name|IS_REREAD
operator|)
condition|)
return|return;
name|cip
operator|->
name|i_state
operator|=
name|IS_REREAD
expr_stmt|;
if|if
condition|(
name|cip
operator|->
name|i_char
operator|==
literal|'\n'
condition|)
name|cip
operator|->
name|i_line
operator|--
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Process all startup files found in the $CALCRC path.  */
end_comment

begin_function
name|void
name|runrcfiles
parameter_list|()
block|{
name|char
name|path
index|[
name|PATHSIZE
operator|+
literal|1
index|]
decl_stmt|;
comment|/* name being searched for */
name|char
modifier|*
name|cp
decl_stmt|;
name|char
modifier|*
name|newcp
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* execute each file in the list */
for|for
control|(
name|cp
operator|=
name|calcrc
operator|,
name|newcp
operator|=
operator|(
name|char
operator|*
operator|)
name|strchr
argument_list|(
name|calcrc
argument_list|,
name|LISTCHAR
argument_list|)
init|;
name|cp
operator|!=
name|NULL
operator|&&
operator|*
name|cp
condition|;
name|cp
operator|=
name|newcp
operator|,
name|newcp
operator|=
operator|(
name|newcp
operator|)
condition|?
operator|(
name|char
operator|*
operator|)
name|strchr
argument_list|(
name|newcp
operator|+
literal|1
argument_list|,
name|LISTCHAR
argument_list|)
else|:
name|NULL
control|)
block|{
comment|/* load file name into the path */
if|if
condition|(
name|newcp
operator|==
name|NULL
condition|)
block|{
name|strcpy
argument_list|(
name|path
argument_list|,
name|cp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|strncpy
argument_list|(
name|path
argument_list|,
name|cp
argument_list|,
name|newcp
operator|-
name|cp
argument_list|)
expr_stmt|;
name|path
index|[
name|newcp
operator|-
name|cp
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
comment|/* find the start of the path */
name|p
operator|=
operator|(
name|path
index|[
literal|0
index|]
operator|==
literal|':'
operator|)
condition|?
name|path
operator|+
literal|1
else|:
name|path
expr_stmt|;
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
block|{
continue|continue;
block|}
comment|/* process the current file in the list */
name|i
operator|=
name|openfile
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
continue|continue;
name|getcommands
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* END CODE */
end_comment

end_unit

