begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1993 David I. Bell  * Permission is granted to use, distribute, or modify this source,  * provided that this copyright notice remains intact.  *  * Extended precision integral arithmetic non-primitive routines  */
end_comment

begin_include
include|#
directive|include
file|"math.h"
end_include

begin_decl_stmt
specifier|static
name|ZVALUE
name|primeprod
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* product of primes under 100 */
end_comment

begin_decl_stmt
name|ZVALUE
name|_tenpowers_
index|[
literal|32
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* table of 10^2^n */
end_comment

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static char *abortmsg = "Calculation aborted"; static char *memmsg = "Not enough memory";
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Compute the factorial of a number.  */
end_comment

begin_function
name|void
name|zfact
parameter_list|(
name|z
parameter_list|,
name|dest
parameter_list|)
name|ZVALUE
name|z
decl_stmt|,
decl|*
name|dest
decl_stmt|;
end_function

begin_block
block|{
name|long
name|ptwo
decl_stmt|;
comment|/* count of powers of two */
name|long
name|n
decl_stmt|;
comment|/* current multiplication value */
name|long
name|m
decl_stmt|;
comment|/* reduced multiplication value */
name|long
name|mul
decl_stmt|;
comment|/* collected value to multiply by */
name|ZVALUE
name|res
decl_stmt|,
name|temp
decl_stmt|;
if|if
condition|(
name|isneg
argument_list|(
name|z
argument_list|)
condition|)
name|error
argument_list|(
literal|"Negative argument for factorial"
argument_list|)
expr_stmt|;
if|if
condition|(
name|isbig
argument_list|(
name|z
argument_list|)
condition|)
name|error
argument_list|(
literal|"Very large factorial"
argument_list|)
expr_stmt|;
name|n
operator|=
operator|(
name|istiny
argument_list|(
name|z
argument_list|)
condition|?
name|z1tol
argument_list|(
name|z
argument_list|)
else|:
name|z2tol
argument_list|(
name|z
argument_list|)
operator|)
expr_stmt|;
name|ptwo
operator|=
literal|0
expr_stmt|;
name|mul
operator|=
literal|1
expr_stmt|;
name|res
operator|=
name|_one_
expr_stmt|;
comment|/* 	 * Multiply numbers together, but squeeze out all powers of two. 	 * We will put them back in at the end.  Also collect multiple 	 * numbers together until there is a risk of overflow. 	 */
for|for
control|(
init|;
name|n
operator|>
literal|1
condition|;
name|n
operator|--
control|)
block|{
for|for
control|(
name|m
operator|=
name|n
init|;
operator|(
operator|(
name|m
operator|&
literal|0x1
operator|)
operator|==
literal|0
operator|)
condition|;
name|m
operator|>>=
literal|1
control|)
name|ptwo
operator|++
expr_stmt|;
name|mul
operator|*=
name|m
expr_stmt|;
if|if
condition|(
name|mul
operator|<
name|BASE1
operator|/
literal|2
condition|)
continue|continue;
name|zmuli
argument_list|(
name|res
argument_list|,
name|mul
argument_list|,
operator|&
name|temp
argument_list|)
expr_stmt|;
name|freeh
argument_list|(
name|res
operator|.
name|v
argument_list|)
expr_stmt|;
name|res
operator|=
name|temp
expr_stmt|;
name|mul
operator|=
literal|1
expr_stmt|;
block|}
comment|/* 	 * Multiply by the remaining value, then scale result by 	 * the proper power of two. 	 */
if|if
condition|(
name|mul
operator|>
literal|1
condition|)
block|{
name|zmuli
argument_list|(
name|res
argument_list|,
name|mul
argument_list|,
operator|&
name|temp
argument_list|)
expr_stmt|;
name|freeh
argument_list|(
name|res
operator|.
name|v
argument_list|)
expr_stmt|;
name|res
operator|=
name|temp
expr_stmt|;
block|}
name|zshift
argument_list|(
name|res
argument_list|,
name|ptwo
argument_list|,
operator|&
name|temp
argument_list|)
expr_stmt|;
name|freeh
argument_list|(
name|res
operator|.
name|v
argument_list|)
expr_stmt|;
operator|*
name|dest
operator|=
name|temp
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Compute the product of the primes up to the specified number.  */
end_comment

begin_function
name|void
name|zpfact
parameter_list|(
name|z
parameter_list|,
name|dest
parameter_list|)
name|ZVALUE
name|z
decl_stmt|,
decl|*
name|dest
decl_stmt|;
end_function

begin_block
block|{
name|long
name|n
decl_stmt|;
comment|/* limiting number to multiply by */
name|long
name|p
decl_stmt|;
comment|/* current prime */
name|long
name|i
decl_stmt|;
comment|/* test value */
name|long
name|mul
decl_stmt|;
comment|/* collected value to multiply by */
name|ZVALUE
name|res
decl_stmt|,
name|temp
decl_stmt|;
if|if
condition|(
name|isneg
argument_list|(
name|z
argument_list|)
condition|)
name|error
argument_list|(
literal|"Negative argument for factorial"
argument_list|)
expr_stmt|;
if|if
condition|(
name|isbig
argument_list|(
name|z
argument_list|)
condition|)
name|error
argument_list|(
literal|"Very large factorial"
argument_list|)
expr_stmt|;
name|n
operator|=
operator|(
name|istiny
argument_list|(
name|z
argument_list|)
condition|?
name|z1tol
argument_list|(
name|z
argument_list|)
else|:
name|z2tol
argument_list|(
name|z
argument_list|)
operator|)
expr_stmt|;
comment|/* 	 * Multiply by the primes in order, collecting multiple numbers 	 * together until there is a change of overflow. 	 */
name|mul
operator|=
literal|1
operator|+
operator|(
name|n
operator|>
literal|1
operator|)
expr_stmt|;
name|res
operator|=
name|_one_
expr_stmt|;
for|for
control|(
name|p
operator|=
literal|3
init|;
name|p
operator|<=
name|n
condition|;
name|p
operator|+=
literal|2
control|)
block|{
for|for
control|(
name|i
operator|=
literal|3
init|;
operator|(
name|i
operator|*
name|i
operator|)
operator|<=
name|p
condition|;
name|i
operator|+=
literal|2
control|)
block|{
if|if
condition|(
operator|(
name|p
operator|%
name|i
operator|)
operator|==
literal|0
condition|)
goto|goto
name|next
goto|;
block|}
name|mul
operator|*=
name|p
expr_stmt|;
if|if
condition|(
name|mul
operator|<
name|BASE1
operator|/
literal|2
condition|)
continue|continue;
name|zmuli
argument_list|(
name|res
argument_list|,
name|mul
argument_list|,
operator|&
name|temp
argument_list|)
expr_stmt|;
name|freeh
argument_list|(
name|res
operator|.
name|v
argument_list|)
expr_stmt|;
name|res
operator|=
name|temp
expr_stmt|;
name|mul
operator|=
literal|1
expr_stmt|;
name|next
label|:
empty_stmt|;
block|}
comment|/* 	 * Multiply by the final value if any. 	 */
if|if
condition|(
name|mul
operator|>
literal|1
condition|)
block|{
name|zmuli
argument_list|(
name|res
argument_list|,
name|mul
argument_list|,
operator|&
name|temp
argument_list|)
expr_stmt|;
name|freeh
argument_list|(
name|res
operator|.
name|v
argument_list|)
expr_stmt|;
name|res
operator|=
name|temp
expr_stmt|;
block|}
operator|*
name|dest
operator|=
name|res
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Compute the least common multiple of all the numbers up to the  * specified number.  */
end_comment

begin_function
name|void
name|zlcmfact
parameter_list|(
name|z
parameter_list|,
name|dest
parameter_list|)
name|ZVALUE
name|z
decl_stmt|,
decl|*
name|dest
decl_stmt|;
end_function

begin_block
block|{
name|long
name|n
decl_stmt|;
comment|/* limiting number to multiply by */
name|long
name|p
decl_stmt|;
comment|/* current prime */
name|long
name|pp
decl_stmt|;
comment|/* power of prime */
name|long
name|i
decl_stmt|;
comment|/* test value */
name|ZVALUE
name|res
decl_stmt|,
name|temp
decl_stmt|;
if|if
condition|(
name|isneg
argument_list|(
name|z
argument_list|)
operator|||
name|iszero
argument_list|(
name|z
argument_list|)
condition|)
name|error
argument_list|(
literal|"Non-positive argument for lcmfact"
argument_list|)
expr_stmt|;
if|if
condition|(
name|isbig
argument_list|(
name|z
argument_list|)
condition|)
name|error
argument_list|(
literal|"Very large lcmfact"
argument_list|)
expr_stmt|;
name|n
operator|=
operator|(
name|istiny
argument_list|(
name|z
argument_list|)
condition|?
name|z1tol
argument_list|(
name|z
argument_list|)
else|:
name|z2tol
argument_list|(
name|z
argument_list|)
operator|)
expr_stmt|;
comment|/* 	 * Multiply by powers of the necessary odd primes in order. 	 * The power for each prime is the highest one which is not 	 * more than the specified number. 	 */
name|res
operator|=
name|_one_
expr_stmt|;
for|for
control|(
name|p
operator|=
literal|3
init|;
name|p
operator|<=
name|n
condition|;
name|p
operator|+=
literal|2
control|)
block|{
for|for
control|(
name|i
operator|=
literal|3
init|;
operator|(
name|i
operator|*
name|i
operator|)
operator|<=
name|p
condition|;
name|i
operator|+=
literal|2
control|)
block|{
if|if
condition|(
operator|(
name|p
operator|%
name|i
operator|)
operator|==
literal|0
condition|)
goto|goto
name|next
goto|;
block|}
name|i
operator|=
name|p
expr_stmt|;
while|while
condition|(
name|i
operator|<=
name|n
condition|)
block|{
name|pp
operator|=
name|i
expr_stmt|;
name|i
operator|*=
name|p
expr_stmt|;
block|}
name|zmuli
argument_list|(
name|res
argument_list|,
name|pp
argument_list|,
operator|&
name|temp
argument_list|)
expr_stmt|;
name|freeh
argument_list|(
name|res
operator|.
name|v
argument_list|)
expr_stmt|;
name|res
operator|=
name|temp
expr_stmt|;
name|next
label|:
empty_stmt|;
block|}
comment|/* 	 * Finish by scaling by the necessary power of two. 	 */
name|zshift
argument_list|(
name|res
argument_list|,
name|zhighbit
argument_list|(
name|z
argument_list|)
argument_list|,
name|dest
argument_list|)
expr_stmt|;
name|freeh
argument_list|(
name|res
operator|.
name|v
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Compute the permuation function  M! / (M - N)!.  */
end_comment

begin_function
name|void
name|zperm
parameter_list|(
name|z1
parameter_list|,
name|z2
parameter_list|,
name|res
parameter_list|)
name|ZVALUE
name|z1
decl_stmt|,
name|z2
decl_stmt|,
decl|*
name|res
decl_stmt|;
end_function

begin_block
block|{
name|long
name|count
decl_stmt|;
name|ZVALUE
name|cur
decl_stmt|,
name|tmp
decl_stmt|,
name|ans
decl_stmt|;
if|if
condition|(
name|isneg
argument_list|(
name|z1
argument_list|)
operator|||
name|isneg
argument_list|(
name|z2
argument_list|)
condition|)
name|error
argument_list|(
literal|"Negative argument for permutation"
argument_list|)
expr_stmt|;
if|if
condition|(
name|zrel
argument_list|(
name|z1
argument_list|,
name|z2
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|"Second arg larger than first in permutation"
argument_list|)
expr_stmt|;
if|if
condition|(
name|isbig
argument_list|(
name|z2
argument_list|)
condition|)
name|error
argument_list|(
literal|"Very large permutation"
argument_list|)
expr_stmt|;
name|count
operator|=
operator|(
name|istiny
argument_list|(
name|z2
argument_list|)
condition|?
name|z1tol
argument_list|(
name|z2
argument_list|)
else|:
name|z2tol
argument_list|(
name|z2
argument_list|)
operator|)
expr_stmt|;
name|zcopy
argument_list|(
name|z1
argument_list|,
operator|&
name|ans
argument_list|)
expr_stmt|;
name|zsub
argument_list|(
name|z1
argument_list|,
name|_one_
argument_list|,
operator|&
name|cur
argument_list|)
expr_stmt|;
while|while
condition|(
operator|--
name|count
operator|>
literal|0
condition|)
block|{
name|zmul
argument_list|(
name|ans
argument_list|,
name|cur
argument_list|,
operator|&
name|tmp
argument_list|)
expr_stmt|;
name|freeh
argument_list|(
name|ans
operator|.
name|v
argument_list|)
expr_stmt|;
name|ans
operator|=
name|tmp
expr_stmt|;
name|zsub
argument_list|(
name|cur
argument_list|,
name|_one_
argument_list|,
operator|&
name|tmp
argument_list|)
expr_stmt|;
name|freeh
argument_list|(
name|cur
operator|.
name|v
argument_list|)
expr_stmt|;
name|cur
operator|=
name|tmp
expr_stmt|;
block|}
name|freeh
argument_list|(
name|cur
operator|.
name|v
argument_list|)
expr_stmt|;
operator|*
name|res
operator|=
name|ans
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Compute the combinatorial function  M! / ( N! * (M - N)! ).  */
end_comment

begin_function
name|void
name|zcomb
parameter_list|(
name|z1
parameter_list|,
name|z2
parameter_list|,
name|res
parameter_list|)
name|ZVALUE
name|z1
decl_stmt|,
name|z2
decl_stmt|,
decl|*
name|res
decl_stmt|;
end_function

begin_block
block|{
name|ZVALUE
name|ans
decl_stmt|;
name|ZVALUE
name|mul
decl_stmt|,
name|div
decl_stmt|,
name|temp
decl_stmt|;
name|FULL
name|count
decl_stmt|,
name|i
decl_stmt|;
name|HALF
name|dh
index|[
literal|2
index|]
decl_stmt|;
if|if
condition|(
name|isneg
argument_list|(
name|z1
argument_list|)
operator|||
name|isneg
argument_list|(
name|z2
argument_list|)
condition|)
name|error
argument_list|(
literal|"Negative argument for combinatorial"
argument_list|)
expr_stmt|;
name|zsub
argument_list|(
name|z1
argument_list|,
name|z2
argument_list|,
operator|&
name|temp
argument_list|)
expr_stmt|;
if|if
condition|(
name|isneg
argument_list|(
name|temp
argument_list|)
condition|)
block|{
name|freeh
argument_list|(
name|temp
operator|.
name|v
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"Second arg larger than first for combinatorial"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|isbig
argument_list|(
name|z2
argument_list|)
operator|&&
name|isbig
argument_list|(
name|temp
argument_list|)
condition|)
block|{
name|freeh
argument_list|(
name|temp
operator|.
name|v
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"Very large combinatorial"
argument_list|)
expr_stmt|;
block|}
name|count
operator|=
operator|(
name|istiny
argument_list|(
name|z2
argument_list|)
condition|?
name|z1tol
argument_list|(
name|z2
argument_list|)
else|:
name|z2tol
argument_list|(
name|z2
argument_list|)
operator|)
expr_stmt|;
name|i
operator|=
operator|(
name|istiny
argument_list|(
name|temp
argument_list|)
condition|?
name|z1tol
argument_list|(
name|temp
argument_list|)
else|:
name|z2tol
argument_list|(
name|temp
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|isbig
argument_list|(
name|z2
argument_list|)
operator|||
operator|(
operator|!
name|isbig
argument_list|(
name|temp
argument_list|)
operator|&&
operator|(
name|i
operator|<
name|count
operator|)
operator|)
condition|)
name|count
operator|=
name|i
expr_stmt|;
name|freeh
argument_list|(
name|temp
operator|.
name|v
argument_list|)
expr_stmt|;
name|mul
operator|=
name|z1
expr_stmt|;
name|div
operator|.
name|sign
operator|=
literal|0
expr_stmt|;
name|div
operator|.
name|v
operator|=
name|dh
expr_stmt|;
name|ans
operator|=
name|_one_
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|count
condition|;
name|i
operator|++
control|)
block|{
name|dh
index|[
literal|0
index|]
operator|=
name|i
operator|&
name|BASE1
expr_stmt|;
name|dh
index|[
literal|1
index|]
operator|=
name|i
operator|/
name|BASE
expr_stmt|;
name|div
operator|.
name|len
operator|=
literal|1
operator|+
operator|(
name|dh
index|[
literal|1
index|]
operator|!=
literal|0
operator|)
expr_stmt|;
name|zmul
argument_list|(
name|ans
argument_list|,
name|mul
argument_list|,
operator|&
name|temp
argument_list|)
expr_stmt|;
name|freeh
argument_list|(
name|ans
operator|.
name|v
argument_list|)
expr_stmt|;
name|zquo
argument_list|(
name|temp
argument_list|,
name|div
argument_list|,
operator|&
name|ans
argument_list|)
expr_stmt|;
name|freeh
argument_list|(
name|temp
operator|.
name|v
argument_list|)
expr_stmt|;
name|zsub
argument_list|(
name|mul
argument_list|,
name|_one_
argument_list|,
operator|&
name|temp
argument_list|)
expr_stmt|;
if|if
condition|(
name|mul
operator|.
name|v
operator|!=
name|z1
operator|.
name|v
condition|)
name|freeh
argument_list|(
name|mul
operator|.
name|v
argument_list|)
expr_stmt|;
name|mul
operator|=
name|temp
expr_stmt|;
block|}
if|if
condition|(
name|mul
operator|.
name|v
operator|!=
name|z1
operator|.
name|v
condition|)
name|freeh
argument_list|(
name|mul
operator|.
name|v
argument_list|)
expr_stmt|;
operator|*
name|res
operator|=
name|ans
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Perform a probabilistic primality test (algorithm P in Knuth).  * Returns FALSE if definitely not prime, or TRUE if probably prime.  * Count determines how many times to check for primality.  * The chance of a non-prime passing this test is less than (1/4)^count.  * For example, a count of 100 fails for only 1 in 10^60 numbers.  */
end_comment

begin_function
name|BOOL
name|zprimetest
parameter_list|(
name|z
parameter_list|,
name|count
parameter_list|)
name|ZVALUE
name|z
decl_stmt|;
comment|/* number to test for primeness */
name|long
name|count
decl_stmt|;
block|{
name|long
name|ij
decl_stmt|,
name|ik
decl_stmt|,
name|ix
decl_stmt|;
name|ZVALUE
name|zm1
decl_stmt|,
name|z1
decl_stmt|,
name|z2
decl_stmt|,
name|z3
decl_stmt|,
name|ztmp
decl_stmt|;
name|HALF
name|val
index|[
literal|2
index|]
decl_stmt|;
name|z
operator|.
name|sign
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|iseven
argument_list|(
name|z
argument_list|)
condition|)
comment|/* if even, not prime if not 2 */
return|return
operator|(
name|istwo
argument_list|(
name|z
argument_list|)
operator|!=
literal|0
operator|)
return|;
comment|/* 	 * See if the number is small, and is either a small prime, 	 * or is divisible by a small prime. 	 */
if|if
condition|(
name|istiny
argument_list|(
name|z
argument_list|)
operator|&&
operator|(
operator|*
name|z
operator|.
name|v
operator|<=
call|(
name|HALF
call|)
argument_list|(
literal|101
operator|*
literal|101
operator|-
literal|1
argument_list|)
operator|)
condition|)
block|{
name|ix
operator|=
operator|*
name|z
operator|.
name|v
expr_stmt|;
for|for
control|(
name|ik
operator|=
literal|3
init|;
operator|(
name|ik
operator|<=
literal|97
operator|)
operator|&&
operator|(
operator|(
name|ik
operator|*
name|ik
operator|)
operator|<=
name|ix
operator|)
condition|;
name|ik
operator|+=
literal|2
control|)
if|if
condition|(
operator|(
name|ix
operator|%
name|ik
operator|)
operator|==
literal|0
condition|)
return|return
name|FALSE
return|;
return|return
name|TRUE
return|;
block|}
comment|/* 	 * See if the number is divisible by one of the primes 3, 5, 	 * 7, 11, or 13.  This is a very easy check. 	 */
name|ij
operator|=
name|zmodi
argument_list|(
name|z
argument_list|,
literal|15015L
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|ij
operator|%
literal|3
operator|)
operator|||
operator|!
operator|(
name|ij
operator|%
literal|5
operator|)
operator|||
operator|!
operator|(
name|ij
operator|%
literal|7
operator|)
operator|||
operator|!
operator|(
name|ij
operator|%
literal|11
operator|)
operator|||
operator|!
operator|(
name|ij
operator|%
literal|13
operator|)
condition|)
return|return
name|FALSE
return|;
comment|/* 	 * Check the gcd of the number and the product of more of the first 	 * few odd primes.  We must build the prime product on the first call. 	 */
name|ztmp
operator|.
name|sign
operator|=
literal|0
expr_stmt|;
name|ztmp
operator|.
name|len
operator|=
literal|1
expr_stmt|;
name|ztmp
operator|.
name|v
operator|=
name|val
expr_stmt|;
if|if
condition|(
name|primeprod
operator|.
name|len
operator|==
literal|0
condition|)
block|{
name|val
index|[
literal|0
index|]
operator|=
literal|101
expr_stmt|;
name|zpfact
argument_list|(
name|ztmp
argument_list|,
operator|&
name|primeprod
argument_list|)
expr_stmt|;
block|}
name|zgcd
argument_list|(
name|z
argument_list|,
name|primeprod
argument_list|,
operator|&
name|z1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|isunit
argument_list|(
name|z1
argument_list|)
condition|)
block|{
name|freeh
argument_list|(
name|z1
operator|.
name|v
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|freeh
argument_list|(
name|z1
operator|.
name|v
argument_list|)
expr_stmt|;
comment|/* 	 * Not divisible by a small prime, so onward with the real test. 	 * Make sure the count is limited by the number of odd numbers between 	 * three and the number being tested. 	 */
name|ix
operator|=
operator|(
operator|(
name|istiny
argument_list|(
name|z
argument_list|)
condition|?
name|z1tol
argument_list|(
name|z
argument_list|)
else|:
name|z2tol
argument_list|(
name|z
argument_list|)
operator|-
literal|3
operator|)
operator|/
literal|2
operator|)
expr_stmt|;
if|if
condition|(
name|count
operator|>
name|ix
condition|)
name|count
operator|=
name|ix
expr_stmt|;
name|zsub
argument_list|(
name|z
argument_list|,
name|_one_
argument_list|,
operator|&
name|zm1
argument_list|)
expr_stmt|;
name|ik
operator|=
name|zlowbit
argument_list|(
name|zm1
argument_list|)
expr_stmt|;
name|zshift
argument_list|(
name|zm1
argument_list|,
operator|-
name|ik
argument_list|,
operator|&
name|z1
argument_list|)
expr_stmt|;
comment|/* 	 * Loop over various "random" numbers, testing each one. 	 * These numbers are the odd numbers starting from three. 	 */
for|for
control|(
name|ix
operator|=
literal|0
init|;
name|ix
operator|<
name|count
condition|;
name|ix
operator|++
control|)
block|{
name|val
index|[
literal|0
index|]
operator|=
operator|(
name|ix
operator|*
literal|2
operator|)
operator|+
literal|3
expr_stmt|;
name|ij
operator|=
literal|0
expr_stmt|;
name|zpowermod
argument_list|(
name|ztmp
argument_list|,
name|z1
argument_list|,
name|z
argument_list|,
operator|&
name|z3
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|isone
argument_list|(
name|z3
argument_list|)
condition|)
block|{
if|if
condition|(
name|ij
condition|)
comment|/* number is definitely not prime */
goto|goto
name|notprime
goto|;
break|break;
block|}
if|if
condition|(
name|zcmp
argument_list|(
name|z3
argument_list|,
name|zm1
argument_list|)
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
operator|++
name|ij
operator|>=
name|ik
condition|)
goto|goto
name|notprime
goto|;
comment|/* number is definitely not prime */
name|zsquare
argument_list|(
name|z3
argument_list|,
operator|&
name|z2
argument_list|)
expr_stmt|;
name|freeh
argument_list|(
name|z3
operator|.
name|v
argument_list|)
expr_stmt|;
name|zmod
argument_list|(
name|z2
argument_list|,
name|z
argument_list|,
operator|&
name|z3
argument_list|)
expr_stmt|;
name|freeh
argument_list|(
name|z2
operator|.
name|v
argument_list|)
expr_stmt|;
block|}
name|freeh
argument_list|(
name|z3
operator|.
name|v
argument_list|)
expr_stmt|;
block|}
name|freeh
argument_list|(
name|zm1
operator|.
name|v
argument_list|)
expr_stmt|;
name|freeh
argument_list|(
name|z1
operator|.
name|v
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
comment|/* number might be prime */
name|notprime
label|:
name|freeh
argument_list|(
name|z3
operator|.
name|v
argument_list|)
expr_stmt|;
name|freeh
argument_list|(
name|zm1
operator|.
name|v
argument_list|)
expr_stmt|;
name|freeh
argument_list|(
name|z1
operator|.
name|v
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/*  * Compute the Jacobi function (p / q) for odd q.  * If q is prime then the result is:  *	1 if p == x^2 (mod q) for some x.  *	-1 otherwise.  * If q is not prime, then the result is not meaningful if it is 1.  * This function returns 0 if q is even or q< 0.  */
end_comment

begin_function
name|FLAG
name|zjacobi
parameter_list|(
name|z1
parameter_list|,
name|z2
parameter_list|)
name|ZVALUE
name|z1
decl_stmt|,
name|z2
decl_stmt|;
block|{
name|ZVALUE
name|p
decl_stmt|,
name|q
decl_stmt|,
name|tmp
decl_stmt|;
name|long
name|lowbit
decl_stmt|;
name|int
name|val
decl_stmt|;
if|if
condition|(
name|iseven
argument_list|(
name|z2
argument_list|)
operator|||
name|isneg
argument_list|(
name|z2
argument_list|)
condition|)
return|return
literal|0
return|;
name|val
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|iszero
argument_list|(
name|z1
argument_list|)
operator|||
name|isone
argument_list|(
name|z1
argument_list|)
condition|)
return|return
name|val
return|;
if|if
condition|(
name|isunit
argument_list|(
name|z1
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|z2
operator|.
name|v
operator|-
literal|1
operator|)
operator|&
literal|0x2
condition|)
name|val
operator|=
operator|-
name|val
expr_stmt|;
return|return
name|val
return|;
block|}
name|zcopy
argument_list|(
name|z1
argument_list|,
operator|&
name|p
argument_list|)
expr_stmt|;
name|zcopy
argument_list|(
name|z2
argument_list|,
operator|&
name|q
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|zmod
argument_list|(
name|p
argument_list|,
name|q
argument_list|,
operator|&
name|tmp
argument_list|)
expr_stmt|;
name|freeh
argument_list|(
name|p
operator|.
name|v
argument_list|)
expr_stmt|;
name|p
operator|=
name|tmp
expr_stmt|;
if|if
condition|(
name|iszero
argument_list|(
name|p
argument_list|)
condition|)
block|{
name|freeh
argument_list|(
name|p
operator|.
name|v
argument_list|)
expr_stmt|;
name|p
operator|=
name|_one_
expr_stmt|;
block|}
if|if
condition|(
name|iseven
argument_list|(
name|p
argument_list|)
condition|)
block|{
name|lowbit
operator|=
name|zlowbit
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|zshift
argument_list|(
name|p
argument_list|,
operator|-
name|lowbit
argument_list|,
operator|&
name|tmp
argument_list|)
expr_stmt|;
name|freeh
argument_list|(
name|p
operator|.
name|v
argument_list|)
expr_stmt|;
name|p
operator|=
name|tmp
expr_stmt|;
if|if
condition|(
operator|(
name|lowbit
operator|&
literal|1
operator|)
operator|&&
operator|(
operator|(
operator|(
operator|*
name|q
operator|.
name|v
operator|&
literal|0x7
operator|)
operator|==
literal|3
operator|)
operator|||
operator|(
operator|(
operator|*
name|q
operator|.
name|v
operator|&
literal|0x7
operator|)
operator|==
literal|5
operator|)
operator|)
condition|)
name|val
operator|=
operator|-
name|val
expr_stmt|;
block|}
if|if
condition|(
name|isunit
argument_list|(
name|p
argument_list|)
condition|)
block|{
name|freeh
argument_list|(
name|p
operator|.
name|v
argument_list|)
expr_stmt|;
name|freeh
argument_list|(
name|q
operator|.
name|v
argument_list|)
expr_stmt|;
return|return
name|val
return|;
block|}
if|if
condition|(
operator|(
operator|*
name|p
operator|.
name|v
operator|&
operator|*
name|q
operator|.
name|v
operator|&
literal|0x3
operator|)
operator|==
literal|3
condition|)
name|val
operator|=
operator|-
name|val
expr_stmt|;
name|tmp
operator|=
name|q
expr_stmt|;
name|q
operator|=
name|p
expr_stmt|;
name|p
operator|=
name|tmp
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Return the Fibonacci number F(n).  * This is evaluated by recursively using the formulas:  *	F(2N+1) = F(N+1)^2 + F(N)^2  * and  *	F(2N) = F(N+1)^2 - F(N-1)^2  */
end_comment

begin_function
name|void
name|zfib
parameter_list|(
name|z
parameter_list|,
name|res
parameter_list|)
name|ZVALUE
name|z
decl_stmt|,
decl|*
name|res
decl_stmt|;
end_function

begin_block
block|{
name|unsigned
name|long
name|i
decl_stmt|;
name|long
name|n
decl_stmt|;
name|int
name|sign
decl_stmt|;
name|ZVALUE
name|fnm1
decl_stmt|,
name|fn
decl_stmt|,
name|fnp1
decl_stmt|;
comment|/* consecutive fibonacci values */
name|ZVALUE
name|t1
decl_stmt|,
name|t2
decl_stmt|,
name|t3
decl_stmt|;
if|if
condition|(
name|isbig
argument_list|(
name|z
argument_list|)
condition|)
name|error
argument_list|(
literal|"Very large Fibonacci number"
argument_list|)
expr_stmt|;
name|n
operator|=
operator|(
name|istiny
argument_list|(
name|z
argument_list|)
condition|?
name|z1tol
argument_list|(
name|z
argument_list|)
else|:
name|z2tol
argument_list|(
name|z
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
literal|0
condition|)
block|{
operator|*
name|res
operator|=
name|_zero_
expr_stmt|;
return|return;
block|}
name|sign
operator|=
name|z
operator|.
name|sign
operator|&&
operator|(
operator|(
name|n
operator|&
literal|0x1
operator|)
operator|==
literal|0
operator|)
expr_stmt|;
if|if
condition|(
name|n
operator|<=
literal|2
condition|)
block|{
operator|*
name|res
operator|=
name|_one_
expr_stmt|;
name|res
operator|->
name|sign
operator|=
operator|(
name|BOOL
operator|)
name|sign
expr_stmt|;
return|return;
block|}
name|i
operator|=
name|TOPFULL
expr_stmt|;
while|while
condition|(
operator|(
name|i
operator|&
name|n
operator|)
operator|==
literal|0
condition|)
name|i
operator|>>=
literal|1L
expr_stmt|;
name|i
operator|>>=
literal|1L
expr_stmt|;
name|fnm1
operator|=
name|_zero_
expr_stmt|;
name|fn
operator|=
name|_one_
expr_stmt|;
name|fnp1
operator|=
name|_one_
expr_stmt|;
while|while
condition|(
name|i
condition|)
block|{
name|zsquare
argument_list|(
name|fnm1
argument_list|,
operator|&
name|t1
argument_list|)
expr_stmt|;
name|zsquare
argument_list|(
name|fn
argument_list|,
operator|&
name|t2
argument_list|)
expr_stmt|;
name|zsquare
argument_list|(
name|fnp1
argument_list|,
operator|&
name|t3
argument_list|)
expr_stmt|;
name|freeh
argument_list|(
name|fnm1
operator|.
name|v
argument_list|)
expr_stmt|;
name|freeh
argument_list|(
name|fn
operator|.
name|v
argument_list|)
expr_stmt|;
name|freeh
argument_list|(
name|fnp1
operator|.
name|v
argument_list|)
expr_stmt|;
name|zadd
argument_list|(
name|t2
argument_list|,
name|t3
argument_list|,
operator|&
name|fnp1
argument_list|)
expr_stmt|;
name|zsub
argument_list|(
name|t3
argument_list|,
name|t1
argument_list|,
operator|&
name|fn
argument_list|)
expr_stmt|;
name|freeh
argument_list|(
name|t1
operator|.
name|v
argument_list|)
expr_stmt|;
name|freeh
argument_list|(
name|t2
operator|.
name|v
argument_list|)
expr_stmt|;
name|freeh
argument_list|(
name|t3
operator|.
name|v
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|&
name|n
condition|)
block|{
name|fnm1
operator|=
name|fn
expr_stmt|;
name|fn
operator|=
name|fnp1
expr_stmt|;
name|zadd
argument_list|(
name|fnm1
argument_list|,
name|fn
argument_list|,
operator|&
name|fnp1
argument_list|)
expr_stmt|;
block|}
else|else
name|zsub
argument_list|(
name|fnp1
argument_list|,
name|fn
argument_list|,
operator|&
name|fnm1
argument_list|)
expr_stmt|;
name|i
operator|>>=
literal|1L
expr_stmt|;
block|}
name|freeh
argument_list|(
name|fnm1
operator|.
name|v
argument_list|)
expr_stmt|;
name|freeh
argument_list|(
name|fnp1
operator|.
name|v
argument_list|)
expr_stmt|;
operator|*
name|res
operator|=
name|fn
expr_stmt|;
name|res
operator|->
name|sign
operator|=
operator|(
name|BOOL
operator|)
name|sign
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Compute the result of raising one number to the power of another  * The second number is assumed to be non-negative.  * It cannot be too large except for trivial cases.  */
end_comment

begin_function
name|void
name|zpowi
parameter_list|(
name|z1
parameter_list|,
name|z2
parameter_list|,
name|res
parameter_list|)
name|ZVALUE
name|z1
decl_stmt|,
name|z2
decl_stmt|,
decl|*
name|res
decl_stmt|;
end_function

begin_block
block|{
name|int
name|sign
decl_stmt|;
comment|/* final sign of number */
name|unsigned
name|long
name|power
decl_stmt|;
comment|/* power to raise to */
name|unsigned
name|long
name|bit
decl_stmt|;
comment|/* current bit value */
name|long
name|twos
decl_stmt|;
comment|/* count of times 2 is in result */
name|ZVALUE
name|ans
decl_stmt|,
name|temp
decl_stmt|;
name|sign
operator|=
operator|(
name|z1
operator|.
name|sign
operator|&&
name|isodd
argument_list|(
name|z2
argument_list|)
operator|)
expr_stmt|;
name|z1
operator|.
name|sign
operator|=
literal|0
expr_stmt|;
name|z2
operator|.
name|sign
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|iszero
argument_list|(
name|z2
argument_list|)
condition|)
block|{
comment|/* number raised to power 0 */
if|if
condition|(
name|iszero
argument_list|(
name|z1
argument_list|)
condition|)
name|error
argument_list|(
literal|"Zero raised to zero power"
argument_list|)
expr_stmt|;
operator|*
name|res
operator|=
name|_one_
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|isleone
argument_list|(
name|z1
argument_list|)
condition|)
block|{
comment|/* 0, 1, or -1 raised to a power */
name|ans
operator|=
name|_one_
expr_stmt|;
name|ans
operator|.
name|sign
operator|=
operator|(
name|BOOL
operator|)
name|sign
expr_stmt|;
if|if
condition|(
operator|*
name|z1
operator|.
name|v
operator|==
literal|0
condition|)
name|ans
operator|=
name|_zero_
expr_stmt|;
operator|*
name|res
operator|=
name|ans
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|isbig
argument_list|(
name|z2
argument_list|)
condition|)
name|error
argument_list|(
literal|"Raising to very large power"
argument_list|)
expr_stmt|;
name|power
operator|=
operator|(
name|istiny
argument_list|(
name|z2
argument_list|)
condition|?
name|z1tol
argument_list|(
name|z2
argument_list|)
else|:
name|z2tol
argument_list|(
name|z2
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|istwo
argument_list|(
name|z1
argument_list|)
condition|)
block|{
comment|/* two raised to a power */
name|zbitvalue
argument_list|(
operator|(
name|long
operator|)
name|power
argument_list|,
name|res
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * See if this is a power of ten 	 */
if|if
condition|(
name|istiny
argument_list|(
name|z1
argument_list|)
operator|&&
operator|(
operator|*
name|z1
operator|.
name|v
operator|==
literal|10
operator|)
condition|)
block|{
name|ztenpow
argument_list|(
operator|(
name|long
operator|)
name|power
argument_list|,
name|res
argument_list|)
expr_stmt|;
name|res
operator|->
name|sign
operator|=
operator|(
name|BOOL
operator|)
name|sign
expr_stmt|;
return|return;
block|}
comment|/* 	 * Handle low powers specially 	 */
if|if
condition|(
name|power
operator|<=
literal|4
condition|)
block|{
switch|switch
condition|(
operator|(
name|int
operator|)
name|power
condition|)
block|{
case|case
literal|1
case|:
name|ans
operator|.
name|len
operator|=
name|z1
operator|.
name|len
expr_stmt|;
name|ans
operator|.
name|v
operator|=
name|alloc
argument_list|(
name|ans
operator|.
name|len
argument_list|)
expr_stmt|;
name|copyval
argument_list|(
name|z1
argument_list|,
name|ans
argument_list|)
expr_stmt|;
name|ans
operator|.
name|sign
operator|=
operator|(
name|BOOL
operator|)
name|sign
expr_stmt|;
operator|*
name|res
operator|=
name|ans
expr_stmt|;
return|return;
case|case
literal|2
case|:
name|zsquare
argument_list|(
name|z1
argument_list|,
name|res
argument_list|)
expr_stmt|;
return|return;
case|case
literal|3
case|:
name|zsquare
argument_list|(
name|z1
argument_list|,
operator|&
name|temp
argument_list|)
expr_stmt|;
name|zmul
argument_list|(
name|z1
argument_list|,
name|temp
argument_list|,
name|res
argument_list|)
expr_stmt|;
name|freeh
argument_list|(
name|temp
operator|.
name|v
argument_list|)
expr_stmt|;
name|res
operator|->
name|sign
operator|=
operator|(
name|BOOL
operator|)
name|sign
expr_stmt|;
return|return;
case|case
literal|4
case|:
name|zsquare
argument_list|(
name|z1
argument_list|,
operator|&
name|temp
argument_list|)
expr_stmt|;
name|zsquare
argument_list|(
name|temp
argument_list|,
name|res
argument_list|)
expr_stmt|;
name|freeh
argument_list|(
name|temp
operator|.
name|v
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|/* 	 * Shift out all powers of twos so the multiplies are smaller. 	 * We will shift back the right amount when done. 	 */
name|twos
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|iseven
argument_list|(
name|z1
argument_list|)
condition|)
block|{
name|twos
operator|=
name|zlowbit
argument_list|(
name|z1
argument_list|)
expr_stmt|;
name|ans
operator|.
name|v
operator|=
name|alloc
argument_list|(
name|z1
operator|.
name|len
argument_list|)
expr_stmt|;
name|ans
operator|.
name|len
operator|=
name|z1
operator|.
name|len
expr_stmt|;
name|copyval
argument_list|(
name|z1
argument_list|,
name|ans
argument_list|)
expr_stmt|;
name|shiftr
argument_list|(
name|ans
argument_list|,
name|twos
argument_list|)
expr_stmt|;
name|trim
argument_list|(
operator|&
name|ans
argument_list|)
expr_stmt|;
name|z1
operator|=
name|ans
expr_stmt|;
name|twos
operator|*=
name|power
expr_stmt|;
block|}
comment|/* 	 * Compute the power by squaring and multiplying. 	 * This uses the left to right method of power raising. 	 */
name|bit
operator|=
name|TOPFULL
expr_stmt|;
while|while
condition|(
operator|(
name|bit
operator|&
name|power
operator|)
operator|==
literal|0
condition|)
name|bit
operator|>>=
literal|1L
expr_stmt|;
name|bit
operator|>>=
literal|1L
expr_stmt|;
name|zsquare
argument_list|(
name|z1
argument_list|,
operator|&
name|ans
argument_list|)
expr_stmt|;
if|if
condition|(
name|bit
operator|&
name|power
condition|)
block|{
name|zmul
argument_list|(
name|ans
argument_list|,
name|z1
argument_list|,
operator|&
name|temp
argument_list|)
expr_stmt|;
name|freeh
argument_list|(
name|ans
operator|.
name|v
argument_list|)
expr_stmt|;
name|ans
operator|=
name|temp
expr_stmt|;
block|}
name|bit
operator|>>=
literal|1L
expr_stmt|;
while|while
condition|(
name|bit
condition|)
block|{
name|zsquare
argument_list|(
name|ans
argument_list|,
operator|&
name|temp
argument_list|)
expr_stmt|;
name|freeh
argument_list|(
name|ans
operator|.
name|v
argument_list|)
expr_stmt|;
name|ans
operator|=
name|temp
expr_stmt|;
if|if
condition|(
name|bit
operator|&
name|power
condition|)
block|{
name|zmul
argument_list|(
name|ans
argument_list|,
name|z1
argument_list|,
operator|&
name|temp
argument_list|)
expr_stmt|;
name|freeh
argument_list|(
name|ans
operator|.
name|v
argument_list|)
expr_stmt|;
name|ans
operator|=
name|temp
expr_stmt|;
block|}
name|bit
operator|>>=
literal|1L
expr_stmt|;
block|}
comment|/* 	 * Scale back up by proper power of two 	 */
if|if
condition|(
name|twos
condition|)
block|{
name|zshift
argument_list|(
name|ans
argument_list|,
name|twos
argument_list|,
operator|&
name|temp
argument_list|)
expr_stmt|;
name|freeh
argument_list|(
name|ans
operator|.
name|v
argument_list|)
expr_stmt|;
name|ans
operator|=
name|temp
expr_stmt|;
name|freeh
argument_list|(
name|z1
operator|.
name|v
argument_list|)
expr_stmt|;
block|}
name|ans
operator|.
name|sign
operator|=
operator|(
name|BOOL
operator|)
name|sign
expr_stmt|;
operator|*
name|res
operator|=
name|ans
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Compute ten to the specified power  * This saves some work since the squares of ten are saved.  */
end_comment

begin_function
name|void
name|ztenpow
parameter_list|(
name|power
parameter_list|,
name|res
parameter_list|)
name|long
name|power
decl_stmt|;
name|ZVALUE
modifier|*
name|res
decl_stmt|;
block|{
name|long
name|i
decl_stmt|;
name|ZVALUE
name|ans
decl_stmt|;
name|ZVALUE
name|temp
decl_stmt|;
if|if
condition|(
name|power
operator|<=
literal|0
condition|)
block|{
operator|*
name|res
operator|=
name|_one_
expr_stmt|;
return|return;
block|}
name|ans
operator|=
name|_one_
expr_stmt|;
name|_tenpowers_
index|[
literal|0
index|]
operator|=
name|_ten_
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|power
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|_tenpowers_
index|[
name|i
index|]
operator|.
name|len
operator|==
literal|0
condition|)
name|zsquare
argument_list|(
name|_tenpowers_
index|[
name|i
operator|-
literal|1
index|]
argument_list|,
operator|&
name|_tenpowers_
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|power
operator|&
literal|0x1
condition|)
block|{
name|zmul
argument_list|(
name|ans
argument_list|,
name|_tenpowers_
index|[
name|i
index|]
argument_list|,
operator|&
name|temp
argument_list|)
expr_stmt|;
name|freeh
argument_list|(
name|ans
operator|.
name|v
argument_list|)
expr_stmt|;
name|ans
operator|=
name|temp
expr_stmt|;
block|}
name|power
operator|/=
literal|2
expr_stmt|;
block|}
operator|*
name|res
operator|=
name|ans
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Calculate modular inverse suppressing unnecessary divisions.  * This is based on the Euclidian algorithm for large numbers.  * (Algorithm X from Knuth Vol 2, section 4.5.2. and exercise 17)  * Returns TRUE if there is no solution because the numbers  * are not relatively prime.  */
end_comment

begin_function
name|BOOL
name|zmodinv
parameter_list|(
name|u
parameter_list|,
name|v
parameter_list|,
name|res
parameter_list|)
name|ZVALUE
name|u
decl_stmt|,
name|v
decl_stmt|;
name|ZVALUE
modifier|*
name|res
decl_stmt|;
block|{
name|FULL
name|q1
decl_stmt|,
name|q2
decl_stmt|,
name|ui3
decl_stmt|,
name|vi3
decl_stmt|,
name|uh
decl_stmt|,
name|vh
decl_stmt|,
name|A
decl_stmt|,
name|B
decl_stmt|,
name|C
decl_stmt|,
name|D
decl_stmt|,
name|T
decl_stmt|;
name|ZVALUE
name|u2
decl_stmt|,
name|u3
decl_stmt|,
name|v2
decl_stmt|,
name|v3
decl_stmt|,
name|qz
decl_stmt|,
name|tmp1
decl_stmt|,
name|tmp2
decl_stmt|,
name|tmp3
decl_stmt|;
if|if
condition|(
name|isneg
argument_list|(
name|u
argument_list|)
operator|||
name|isneg
argument_list|(
name|v
argument_list|)
operator|||
operator|(
name|zrel
argument_list|(
name|u
argument_list|,
name|v
argument_list|)
operator|>=
literal|0
operator|)
condition|)
name|zmod
argument_list|(
name|u
argument_list|,
name|v
argument_list|,
operator|&
name|v3
argument_list|)
expr_stmt|;
else|else
name|zcopy
argument_list|(
name|u
argument_list|,
operator|&
name|v3
argument_list|)
expr_stmt|;
name|zcopy
argument_list|(
name|v
argument_list|,
operator|&
name|u3
argument_list|)
expr_stmt|;
name|u2
operator|=
name|_zero_
expr_stmt|;
name|v2
operator|=
name|_one_
expr_stmt|;
comment|/* 	 * Loop here while the size of the numbers remain above 	 * the size of a FULL.  Throughout this loop u3>= v3. 	 */
while|while
condition|(
operator|(
name|u3
operator|.
name|len
operator|>
literal|1
operator|)
operator|&&
operator|!
name|iszero
argument_list|(
name|v3
argument_list|)
condition|)
block|{
name|uh
operator|=
operator|(
operator|(
operator|(
name|FULL
operator|)
name|u3
operator|.
name|v
index|[
name|u3
operator|.
name|len
operator|-
literal|1
index|]
operator|)
operator|<<
name|BASEB
operator|)
operator|+
name|u3
operator|.
name|v
index|[
name|u3
operator|.
name|len
operator|-
literal|2
index|]
expr_stmt|;
name|vh
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|v3
operator|.
name|len
operator|+
literal|1
operator|)
operator|>=
name|u3
operator|.
name|len
condition|)
name|vh
operator|=
name|v3
operator|.
name|v
index|[
name|v3
operator|.
name|len
operator|-
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|v3
operator|.
name|len
operator|==
name|u3
operator|.
name|len
condition|)
name|vh
operator|=
operator|(
name|vh
operator|<<
name|BASEB
operator|)
operator|+
name|v3
operator|.
name|v
index|[
name|v3
operator|.
name|len
operator|-
literal|2
index|]
expr_stmt|;
name|A
operator|=
literal|1
expr_stmt|;
name|B
operator|=
literal|0
expr_stmt|;
name|C
operator|=
literal|0
expr_stmt|;
name|D
operator|=
literal|1
expr_stmt|;
comment|/* 		 * Calculate successive quotients of the continued fraction 		 * expansion using only single precision arithmetic until 		 * greater precision is required. 		 */
while|while
condition|(
operator|(
name|vh
operator|+
name|C
operator|)
operator|&&
operator|(
name|vh
operator|+
name|D
operator|)
condition|)
block|{
name|q1
operator|=
operator|(
name|uh
operator|+
name|A
operator|)
operator|/
operator|(
name|vh
operator|+
name|C
operator|)
expr_stmt|;
name|q2
operator|=
operator|(
name|uh
operator|+
name|B
operator|)
operator|/
operator|(
name|vh
operator|+
name|D
operator|)
expr_stmt|;
if|if
condition|(
name|q1
operator|!=
name|q2
condition|)
break|break;
name|T
operator|=
name|A
operator|-
name|q1
operator|*
name|C
expr_stmt|;
name|A
operator|=
name|C
expr_stmt|;
name|C
operator|=
name|T
expr_stmt|;
name|T
operator|=
name|B
operator|-
name|q1
operator|*
name|D
expr_stmt|;
name|B
operator|=
name|D
expr_stmt|;
name|D
operator|=
name|T
expr_stmt|;
name|T
operator|=
name|uh
operator|-
name|q1
operator|*
name|vh
expr_stmt|;
name|uh
operator|=
name|vh
expr_stmt|;
name|vh
operator|=
name|T
expr_stmt|;
block|}
comment|/* 		 * If B is zero, then we made no progress because 		 * the calculation requires a very large quotient. 		 * So we must do this step of the calculation in 		 * full precision 		 */
if|if
condition|(
name|B
operator|==
literal|0
condition|)
block|{
name|zquo
argument_list|(
name|u3
argument_list|,
name|v3
argument_list|,
operator|&
name|qz
argument_list|)
expr_stmt|;
name|zmul
argument_list|(
name|qz
argument_list|,
name|v2
argument_list|,
operator|&
name|tmp1
argument_list|)
expr_stmt|;
name|zsub
argument_list|(
name|u2
argument_list|,
name|tmp1
argument_list|,
operator|&
name|tmp2
argument_list|)
expr_stmt|;
name|freeh
argument_list|(
name|tmp1
operator|.
name|v
argument_list|)
expr_stmt|;
name|freeh
argument_list|(
name|u2
operator|.
name|v
argument_list|)
expr_stmt|;
name|u2
operator|=
name|v2
expr_stmt|;
name|v2
operator|=
name|tmp2
expr_stmt|;
name|zmul
argument_list|(
name|qz
argument_list|,
name|v3
argument_list|,
operator|&
name|tmp1
argument_list|)
expr_stmt|;
name|zsub
argument_list|(
name|u3
argument_list|,
name|tmp1
argument_list|,
operator|&
name|tmp2
argument_list|)
expr_stmt|;
name|freeh
argument_list|(
name|tmp1
operator|.
name|v
argument_list|)
expr_stmt|;
name|freeh
argument_list|(
name|u3
operator|.
name|v
argument_list|)
expr_stmt|;
name|u3
operator|=
name|v3
expr_stmt|;
name|v3
operator|=
name|tmp2
expr_stmt|;
name|freeh
argument_list|(
name|qz
operator|.
name|v
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* 		 * Apply the calculated A,B,C,D numbers to the current 		 * values to update them as if the full precision 		 * calculations had been carried out. 		 */
name|zmuli
argument_list|(
name|u2
argument_list|,
operator|(
name|long
operator|)
name|A
argument_list|,
operator|&
name|tmp1
argument_list|)
expr_stmt|;
name|zmuli
argument_list|(
name|v2
argument_list|,
operator|(
name|long
operator|)
name|B
argument_list|,
operator|&
name|tmp2
argument_list|)
expr_stmt|;
name|zadd
argument_list|(
name|tmp1
argument_list|,
name|tmp2
argument_list|,
operator|&
name|tmp3
argument_list|)
expr_stmt|;
name|freeh
argument_list|(
name|tmp1
operator|.
name|v
argument_list|)
expr_stmt|;
name|freeh
argument_list|(
name|tmp2
operator|.
name|v
argument_list|)
expr_stmt|;
name|zmuli
argument_list|(
name|u2
argument_list|,
operator|(
name|long
operator|)
name|C
argument_list|,
operator|&
name|tmp1
argument_list|)
expr_stmt|;
name|zmuli
argument_list|(
name|v2
argument_list|,
operator|(
name|long
operator|)
name|D
argument_list|,
operator|&
name|tmp2
argument_list|)
expr_stmt|;
name|freeh
argument_list|(
name|u2
operator|.
name|v
argument_list|)
expr_stmt|;
name|freeh
argument_list|(
name|v2
operator|.
name|v
argument_list|)
expr_stmt|;
name|u2
operator|=
name|tmp3
expr_stmt|;
name|zadd
argument_list|(
name|tmp1
argument_list|,
name|tmp2
argument_list|,
operator|&
name|v2
argument_list|)
expr_stmt|;
name|freeh
argument_list|(
name|tmp1
operator|.
name|v
argument_list|)
expr_stmt|;
name|freeh
argument_list|(
name|tmp2
operator|.
name|v
argument_list|)
expr_stmt|;
name|zmuli
argument_list|(
name|u3
argument_list|,
operator|(
name|long
operator|)
name|A
argument_list|,
operator|&
name|tmp1
argument_list|)
expr_stmt|;
name|zmuli
argument_list|(
name|v3
argument_list|,
operator|(
name|long
operator|)
name|B
argument_list|,
operator|&
name|tmp2
argument_list|)
expr_stmt|;
name|zadd
argument_list|(
name|tmp1
argument_list|,
name|tmp2
argument_list|,
operator|&
name|tmp3
argument_list|)
expr_stmt|;
name|freeh
argument_list|(
name|tmp1
operator|.
name|v
argument_list|)
expr_stmt|;
name|freeh
argument_list|(
name|tmp2
operator|.
name|v
argument_list|)
expr_stmt|;
name|zmuli
argument_list|(
name|u3
argument_list|,
operator|(
name|long
operator|)
name|C
argument_list|,
operator|&
name|tmp1
argument_list|)
expr_stmt|;
name|zmuli
argument_list|(
name|v3
argument_list|,
operator|(
name|long
operator|)
name|D
argument_list|,
operator|&
name|tmp2
argument_list|)
expr_stmt|;
name|freeh
argument_list|(
name|u3
operator|.
name|v
argument_list|)
expr_stmt|;
name|freeh
argument_list|(
name|v3
operator|.
name|v
argument_list|)
expr_stmt|;
name|u3
operator|=
name|tmp3
expr_stmt|;
name|zadd
argument_list|(
name|tmp1
argument_list|,
name|tmp2
argument_list|,
operator|&
name|v3
argument_list|)
expr_stmt|;
name|freeh
argument_list|(
name|tmp1
operator|.
name|v
argument_list|)
expr_stmt|;
name|freeh
argument_list|(
name|tmp2
operator|.
name|v
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Here when the remaining numbers become single precision in size. 	 * Finish the procedure using single precision calculations. 	 */
if|if
condition|(
name|iszero
argument_list|(
name|v3
argument_list|)
operator|&&
operator|!
name|isone
argument_list|(
name|u3
argument_list|)
condition|)
block|{
name|freeh
argument_list|(
name|u3
operator|.
name|v
argument_list|)
expr_stmt|;
name|freeh
argument_list|(
name|v3
operator|.
name|v
argument_list|)
expr_stmt|;
name|freeh
argument_list|(
name|u2
operator|.
name|v
argument_list|)
expr_stmt|;
name|freeh
argument_list|(
name|v2
operator|.
name|v
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
name|ui3
operator|=
operator|(
name|istiny
argument_list|(
name|u3
argument_list|)
condition|?
name|z1tol
argument_list|(
name|u3
argument_list|)
else|:
name|z2tol
argument_list|(
name|u3
argument_list|)
operator|)
expr_stmt|;
name|vi3
operator|=
operator|(
name|istiny
argument_list|(
name|v3
argument_list|)
condition|?
name|z1tol
argument_list|(
name|v3
argument_list|)
else|:
name|z2tol
argument_list|(
name|v3
argument_list|)
operator|)
expr_stmt|;
name|freeh
argument_list|(
name|u3
operator|.
name|v
argument_list|)
expr_stmt|;
name|freeh
argument_list|(
name|v3
operator|.
name|v
argument_list|)
expr_stmt|;
while|while
condition|(
name|vi3
condition|)
block|{
name|q1
operator|=
name|ui3
operator|/
name|vi3
expr_stmt|;
name|zmuli
argument_list|(
name|v2
argument_list|,
operator|(
name|long
operator|)
name|q1
argument_list|,
operator|&
name|tmp1
argument_list|)
expr_stmt|;
name|zsub
argument_list|(
name|u2
argument_list|,
name|tmp1
argument_list|,
operator|&
name|tmp2
argument_list|)
expr_stmt|;
name|freeh
argument_list|(
name|tmp1
operator|.
name|v
argument_list|)
expr_stmt|;
name|freeh
argument_list|(
name|u2
operator|.
name|v
argument_list|)
expr_stmt|;
name|u2
operator|=
name|v2
expr_stmt|;
name|v2
operator|=
name|tmp2
expr_stmt|;
name|q2
operator|=
name|ui3
operator|-
name|q1
operator|*
name|vi3
expr_stmt|;
name|ui3
operator|=
name|vi3
expr_stmt|;
name|vi3
operator|=
name|q2
expr_stmt|;
block|}
name|freeh
argument_list|(
name|v2
operator|.
name|v
argument_list|)
expr_stmt|;
if|if
condition|(
name|ui3
operator|!=
literal|1
condition|)
block|{
name|freeh
argument_list|(
name|u2
operator|.
name|v
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
if|if
condition|(
name|isneg
argument_list|(
name|u2
argument_list|)
condition|)
block|{
name|zadd
argument_list|(
name|v
argument_list|,
name|u2
argument_list|,
name|res
argument_list|)
expr_stmt|;
name|freeh
argument_list|(
name|u2
operator|.
name|v
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
operator|*
name|res
operator|=
name|u2
expr_stmt|;
return|return
name|FALSE
return|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/*  * Approximate the quotient of two integers by another set of smaller  * integers.  This uses continued fractions to determine the smaller set.  */
end_comment

begin_endif
unit|void zapprox(z1, z2, res1, res2) 	ZVALUE z1, z2, *res1, *res2; { 	int sign; 	ZVALUE u1, v1, u3, v3, q, t1, t2, t3;  	sign = ((z1.sign != 0) ^ (z2.sign != 0)); 	z1.sign = 0; 	z2.sign = 0; 	v3 = z2; 	u3 = z1; 	u1 = _one_; 	v1 = _zero_; 	while (!iszero(v3)) { 		zdiv(u3, v3,&q,&t1); 		zmul(v1, q,&t2); 		zsub(u1, t2,&t3); 		freeh(q.v); 		freeh(t2.v); 		freeh(u1.v); 		if ((u3.v != z1.v)&& (u3.v != z2.v)) 			freeh(u3.v); 		u1 = v1; 		u3 = v3; 		v1 = t3; 		v3 = t1; 	} 	if (!isunit(u3)) 		error("Non-relativly prime numbers for approx"); 	if ((u3.v != z1.v)&& (u3.v != z2.v)) 		freeh(u3.v); 	if ((v3.v != z1.v)&& (v3.v != z2.v)) 		freeh(v3.v); 	freeh(v1.v); 	zmul(u1, z1,&t1); 	zsub(t1, _one_,&t2); 	freeh(t1.v); 	zquo(t2, z2,&t1); 	freeh(t2.v); 	u1.sign = (BOOL)sign; 	t1.sign = 0; 	*res1 = t1; 	*res2 = u1; }
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Binary gcd algorithm  * This algorithm taken from Knuth  */
end_comment

begin_function
name|void
name|zgcd
parameter_list|(
name|z1
parameter_list|,
name|z2
parameter_list|,
name|res
parameter_list|)
name|ZVALUE
name|z1
decl_stmt|,
name|z2
decl_stmt|,
decl|*
name|res
decl_stmt|;
end_function

begin_block
block|{
name|ZVALUE
name|u
decl_stmt|,
name|v
decl_stmt|,
name|t
decl_stmt|;
specifier|register
name|long
name|j
decl_stmt|,
name|k
decl_stmt|,
name|olen
decl_stmt|,
name|mask
decl_stmt|;
specifier|register
name|HALF
name|h
decl_stmt|;
name|HALF
modifier|*
name|oldv1
decl_stmt|,
modifier|*
name|oldv2
decl_stmt|;
comment|/* 	 * First see if one number is very much larger than the other. 	 * If so, then divide as necessary to get the numbers near each other. 	 */
name|z1
operator|.
name|sign
operator|=
literal|0
expr_stmt|;
name|z2
operator|.
name|sign
operator|=
literal|0
expr_stmt|;
name|oldv1
operator|=
name|z1
operator|.
name|v
expr_stmt|;
name|oldv2
operator|=
name|z2
operator|.
name|v
expr_stmt|;
if|if
condition|(
name|z1
operator|.
name|len
operator|<
name|z2
operator|.
name|len
condition|)
block|{
name|t
operator|=
name|z1
expr_stmt|;
name|z1
operator|=
name|z2
expr_stmt|;
name|z2
operator|=
name|t
expr_stmt|;
block|}
while|while
condition|(
operator|(
name|z1
operator|.
name|len
operator|>
operator|(
name|z2
operator|.
name|len
operator|+
literal|5
operator|)
operator|)
operator|&&
operator|!
name|iszero
argument_list|(
name|z2
argument_list|)
condition|)
block|{
name|zmod
argument_list|(
name|z1
argument_list|,
name|z2
argument_list|,
operator|&
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|z1
operator|.
name|v
operator|!=
name|oldv1
operator|)
operator|&&
operator|(
name|z1
operator|.
name|v
operator|!=
name|oldv2
operator|)
condition|)
name|freeh
argument_list|(
name|z1
operator|.
name|v
argument_list|)
expr_stmt|;
name|z1
operator|=
name|z2
expr_stmt|;
name|z2
operator|=
name|t
expr_stmt|;
block|}
comment|/* 	 * Ok, now do the binary method proper 	 */
name|u
operator|.
name|len
operator|=
name|z1
operator|.
name|len
expr_stmt|;
name|v
operator|.
name|len
operator|=
name|z2
operator|.
name|len
expr_stmt|;
name|u
operator|.
name|sign
operator|=
literal|0
expr_stmt|;
name|v
operator|.
name|sign
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|ztest
argument_list|(
name|z1
argument_list|)
condition|)
block|{
name|v
operator|.
name|v
operator|=
name|alloc
argument_list|(
name|v
operator|.
name|len
argument_list|)
expr_stmt|;
name|copyval
argument_list|(
name|z2
argument_list|,
name|v
argument_list|)
expr_stmt|;
operator|*
name|res
operator|=
name|v
expr_stmt|;
goto|goto
name|done
goto|;
block|}
if|if
condition|(
operator|!
name|ztest
argument_list|(
name|z2
argument_list|)
condition|)
block|{
name|u
operator|.
name|v
operator|=
name|alloc
argument_list|(
name|u
operator|.
name|len
argument_list|)
expr_stmt|;
name|copyval
argument_list|(
name|z1
argument_list|,
name|u
argument_list|)
expr_stmt|;
operator|*
name|res
operator|=
name|u
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|u
operator|.
name|v
operator|=
name|alloc
argument_list|(
name|u
operator|.
name|len
argument_list|)
expr_stmt|;
name|v
operator|.
name|v
operator|=
name|alloc
argument_list|(
name|v
operator|.
name|len
argument_list|)
expr_stmt|;
name|copyval
argument_list|(
name|z1
argument_list|,
name|u
argument_list|)
expr_stmt|;
name|copyval
argument_list|(
name|z2
argument_list|,
name|v
argument_list|)
expr_stmt|;
name|k
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|u
operator|.
name|v
index|[
name|k
index|]
operator|==
literal|0
operator|&&
name|v
operator|.
name|v
index|[
name|k
index|]
operator|==
literal|0
condition|)
operator|++
name|k
expr_stmt|;
name|mask
operator|=
literal|01
expr_stmt|;
name|h
operator|=
name|u
operator|.
name|v
index|[
name|k
index|]
operator||
name|v
operator|.
name|v
index|[
name|k
index|]
expr_stmt|;
name|k
operator|*=
name|BASEB
expr_stmt|;
while|while
condition|(
operator|!
operator|(
name|h
operator|&
name|mask
operator|)
condition|)
block|{
name|mask
operator|<<=
literal|1
expr_stmt|;
name|k
operator|++
expr_stmt|;
block|}
name|shiftr
argument_list|(
name|u
argument_list|,
name|k
argument_list|)
expr_stmt|;
name|shiftr
argument_list|(
name|v
argument_list|,
name|k
argument_list|)
expr_stmt|;
name|trim
argument_list|(
operator|&
name|u
argument_list|)
expr_stmt|;
name|trim
argument_list|(
operator|&
name|v
argument_list|)
expr_stmt|;
if|if
condition|(
name|isodd
argument_list|(
name|u
argument_list|)
condition|)
block|{
name|t
operator|.
name|v
operator|=
name|alloc
argument_list|(
name|v
operator|.
name|len
argument_list|)
expr_stmt|;
name|t
operator|.
name|len
operator|=
name|v
operator|.
name|len
expr_stmt|;
name|copyval
argument_list|(
name|v
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|t
operator|.
name|sign
operator|=
operator|!
name|v
operator|.
name|sign
expr_stmt|;
block|}
else|else
block|{
name|t
operator|.
name|v
operator|=
name|alloc
argument_list|(
name|u
operator|.
name|len
argument_list|)
expr_stmt|;
name|t
operator|.
name|len
operator|=
name|u
operator|.
name|len
expr_stmt|;
name|copyval
argument_list|(
name|u
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|t
operator|.
name|sign
operator|=
name|u
operator|.
name|sign
expr_stmt|;
block|}
while|while
condition|(
name|ztest
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|j
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|!
name|t
operator|.
name|v
index|[
name|j
index|]
condition|)
operator|++
name|j
expr_stmt|;
name|mask
operator|=
literal|01
expr_stmt|;
name|h
operator|=
name|t
operator|.
name|v
index|[
name|j
index|]
expr_stmt|;
name|j
operator|*=
name|BASEB
expr_stmt|;
while|while
condition|(
operator|!
operator|(
name|h
operator|&
name|mask
operator|)
condition|)
block|{
name|mask
operator|<<=
literal|1
expr_stmt|;
name|j
operator|++
expr_stmt|;
block|}
name|shiftr
argument_list|(
name|t
argument_list|,
name|j
argument_list|)
expr_stmt|;
name|trim
argument_list|(
operator|&
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|ztest
argument_list|(
name|t
argument_list|)
operator|>
literal|0
condition|)
block|{
name|freeh
argument_list|(
name|u
operator|.
name|v
argument_list|)
expr_stmt|;
name|u
operator|=
name|t
expr_stmt|;
block|}
else|else
block|{
name|freeh
argument_list|(
name|v
operator|.
name|v
argument_list|)
expr_stmt|;
name|v
operator|=
name|t
expr_stmt|;
name|v
operator|.
name|sign
operator|=
operator|!
name|t
operator|.
name|sign
expr_stmt|;
block|}
name|zsub
argument_list|(
name|u
argument_list|,
name|v
argument_list|,
operator|&
name|t
argument_list|)
expr_stmt|;
block|}
name|freeh
argument_list|(
name|t
operator|.
name|v
argument_list|)
expr_stmt|;
name|freeh
argument_list|(
name|v
operator|.
name|v
argument_list|)
expr_stmt|;
if|if
condition|(
name|k
condition|)
block|{
name|olen
operator|=
name|u
operator|.
name|len
expr_stmt|;
name|u
operator|.
name|len
operator|+=
name|k
operator|/
name|BASEB
operator|+
literal|1
expr_stmt|;
name|u
operator|.
name|v
operator|=
operator|(
name|HALF
operator|*
operator|)
name|realloc
argument_list|(
name|u
operator|.
name|v
argument_list|,
name|u
operator|.
name|len
operator|*
sizeof|sizeof
argument_list|(
name|HALF
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|olen
operator|!=
name|u
operator|.
name|len
condition|)
name|u
operator|.
name|v
index|[
name|olen
operator|++
index|]
operator|=
literal|0
expr_stmt|;
name|shiftl
argument_list|(
name|u
argument_list|,
name|k
argument_list|)
expr_stmt|;
block|}
name|trim
argument_list|(
operator|&
name|u
argument_list|)
expr_stmt|;
operator|*
name|res
operator|=
name|u
expr_stmt|;
name|done
label|:
if|if
condition|(
operator|(
name|z1
operator|.
name|v
operator|!=
name|oldv1
operator|)
operator|&&
operator|(
name|z1
operator|.
name|v
operator|!=
name|oldv2
operator|)
condition|)
name|freeh
argument_list|(
name|z1
operator|.
name|v
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|z2
operator|.
name|v
operator|!=
name|oldv1
operator|)
operator|&&
operator|(
name|z2
operator|.
name|v
operator|!=
name|oldv2
operator|)
condition|)
name|freeh
argument_list|(
name|z2
operator|.
name|v
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Compute the lcm of two integers (least common multiple).  * This is done using the formula:  gcd(a,b) * lcm(a,b) = a * b.  */
end_comment

begin_function
name|void
name|zlcm
parameter_list|(
name|z1
parameter_list|,
name|z2
parameter_list|,
name|res
parameter_list|)
name|ZVALUE
name|z1
decl_stmt|,
name|z2
decl_stmt|,
decl|*
name|res
decl_stmt|;
end_function

begin_block
block|{
name|ZVALUE
name|temp1
decl_stmt|,
name|temp2
decl_stmt|;
name|zgcd
argument_list|(
name|z1
argument_list|,
name|z2
argument_list|,
operator|&
name|temp1
argument_list|)
expr_stmt|;
name|zquo
argument_list|(
name|z1
argument_list|,
name|temp1
argument_list|,
operator|&
name|temp2
argument_list|)
expr_stmt|;
name|freeh
argument_list|(
name|temp1
operator|.
name|v
argument_list|)
expr_stmt|;
name|zmul
argument_list|(
name|temp2
argument_list|,
name|z2
argument_list|,
name|res
argument_list|)
expr_stmt|;
name|freeh
argument_list|(
name|temp2
operator|.
name|v
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Return whether or not two numbers are relatively prime to each other.  */
end_comment

begin_function
name|BOOL
name|zrelprime
parameter_list|(
name|z1
parameter_list|,
name|z2
parameter_list|)
name|ZVALUE
name|z1
decl_stmt|,
name|z2
decl_stmt|;
comment|/* numbers to be tested */
block|{
name|FULL
name|rem1
decl_stmt|,
name|rem2
decl_stmt|;
comment|/* remainders */
name|ZVALUE
name|rem
decl_stmt|;
name|BOOL
name|result
decl_stmt|;
name|z1
operator|.
name|sign
operator|=
literal|0
expr_stmt|;
name|z2
operator|.
name|sign
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|iseven
argument_list|(
name|z1
argument_list|)
operator|&&
name|iseven
argument_list|(
name|z2
argument_list|)
condition|)
comment|/* false if both even */
return|return
name|FALSE
return|;
if|if
condition|(
name|isunit
argument_list|(
name|z1
argument_list|)
operator|||
name|isunit
argument_list|(
name|z2
argument_list|)
condition|)
comment|/* true if either is a unit */
return|return
name|TRUE
return|;
if|if
condition|(
name|iszero
argument_list|(
name|z1
argument_list|)
operator|||
name|iszero
argument_list|(
name|z2
argument_list|)
condition|)
comment|/* false if either is zero */
return|return
name|FALSE
return|;
if|if
condition|(
name|istwo
argument_list|(
name|z1
argument_list|)
operator|||
name|istwo
argument_list|(
name|z2
argument_list|)
condition|)
comment|/* true if either is two */
return|return
name|TRUE
return|;
comment|/* 	 * Try reducing each number by the product of the first few odd primes 	 * to see if any of them are a common factor. 	 */
name|rem1
operator|=
name|zmodi
argument_list|(
name|z1
argument_list|,
literal|3L
operator|*
literal|5
operator|*
literal|7
operator|*
literal|11
operator|*
literal|13
argument_list|)
expr_stmt|;
name|rem2
operator|=
name|zmodi
argument_list|(
name|z2
argument_list|,
literal|3L
operator|*
literal|5
operator|*
literal|7
operator|*
literal|11
operator|*
literal|13
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|rem1
operator|%
literal|3
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|(
operator|(
name|rem2
operator|%
literal|3
operator|)
operator|==
literal|0
operator|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
operator|(
operator|(
name|rem1
operator|%
literal|5
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|(
operator|(
name|rem2
operator|%
literal|5
operator|)
operator|==
literal|0
operator|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
operator|(
operator|(
name|rem1
operator|%
literal|7
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|(
operator|(
name|rem2
operator|%
literal|7
operator|)
operator|==
literal|0
operator|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
operator|(
operator|(
name|rem1
operator|%
literal|11
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|(
operator|(
name|rem2
operator|%
literal|11
operator|)
operator|==
literal|0
operator|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
operator|(
operator|(
name|rem1
operator|%
literal|13
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|(
operator|(
name|rem2
operator|%
literal|13
operator|)
operator|==
literal|0
operator|)
condition|)
return|return
name|FALSE
return|;
comment|/* 	 * Try a new batch of primes now 	 */
name|rem1
operator|=
name|zmodi
argument_list|(
name|z1
argument_list|,
literal|17L
operator|*
literal|19
operator|*
literal|23
argument_list|)
expr_stmt|;
name|rem2
operator|=
name|zmodi
argument_list|(
name|z2
argument_list|,
literal|17L
operator|*
literal|19
operator|*
literal|23
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|rem1
operator|%
literal|17
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|(
operator|(
name|rem2
operator|%
literal|17
operator|)
operator|==
literal|0
operator|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
operator|(
operator|(
name|rem1
operator|%
literal|19
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|(
operator|(
name|rem2
operator|%
literal|19
operator|)
operator|==
literal|0
operator|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
operator|(
operator|(
name|rem1
operator|%
literal|23
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|(
operator|(
name|rem2
operator|%
literal|23
operator|)
operator|==
literal|0
operator|)
condition|)
return|return
name|FALSE
return|;
comment|/* 	 * Yuk, we must actually compute the gcd to know the answer 	 */
name|zgcd
argument_list|(
name|z1
argument_list|,
name|z2
argument_list|,
operator|&
name|rem
argument_list|)
expr_stmt|;
name|result
operator|=
name|isunit
argument_list|(
name|rem
argument_list|)
expr_stmt|;
name|freeh
argument_list|(
name|rem
operator|.
name|v
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/*  * Compute the log of one number base another, to the closest integer.  * This is the largest integer which when the second number is raised to it,  * the resulting value is less than or equal to the first number.  * Example:  zlog(123456, 10) = 5.  */
end_comment

begin_function
name|long
name|zlog
parameter_list|(
name|z1
parameter_list|,
name|z2
parameter_list|)
name|ZVALUE
name|z1
decl_stmt|,
name|z2
decl_stmt|;
block|{
specifier|register
name|ZVALUE
modifier|*
name|zp
decl_stmt|;
comment|/* current square */
name|long
name|power
decl_stmt|;
comment|/* current power */
name|long
name|worth
decl_stmt|;
comment|/* worth of current square */
name|ZVALUE
name|val
decl_stmt|;
comment|/* current value of power */
name|ZVALUE
name|temp
decl_stmt|;
comment|/* temporary */
name|ZVALUE
name|squares
index|[
literal|32
index|]
decl_stmt|;
comment|/* table of squares of base */
comment|/* 	 * Make sure that the numbers are nonzero and the base is greater than one. 	 */
if|if
condition|(
name|isneg
argument_list|(
name|z1
argument_list|)
operator|||
name|iszero
argument_list|(
name|z1
argument_list|)
operator|||
name|isneg
argument_list|(
name|z2
argument_list|)
operator|||
name|isleone
argument_list|(
name|z2
argument_list|)
condition|)
name|error
argument_list|(
literal|"Bad arguments for log"
argument_list|)
expr_stmt|;
comment|/* 	 * Reject trivial cases. 	 */
if|if
condition|(
name|z1
operator|.
name|len
operator|<
name|z2
operator|.
name|len
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|(
name|z1
operator|.
name|len
operator|==
name|z2
operator|.
name|len
operator|)
operator|&&
operator|(
name|z1
operator|.
name|v
index|[
name|z1
operator|.
name|len
operator|-
literal|1
index|]
operator|<
name|z2
operator|.
name|v
index|[
name|z2
operator|.
name|len
operator|-
literal|1
index|]
operator|)
condition|)
return|return
literal|0
return|;
name|power
operator|=
name|zrel
argument_list|(
name|z1
argument_list|,
name|z2
argument_list|)
expr_stmt|;
if|if
condition|(
name|power
operator|<=
literal|0
condition|)
return|return
operator|(
name|power
operator|+
literal|1
operator|)
return|;
comment|/* 	 * Handle any power of two special. 	 */
if|if
condition|(
name|zisonebit
argument_list|(
name|z2
argument_list|)
condition|)
return|return
operator|(
name|zhighbit
argument_list|(
name|z1
argument_list|)
operator|/
name|zlowbit
argument_list|(
name|z2
argument_list|)
operator|)
return|;
comment|/* 	 * Handle base 10 special 	 */
if|if
condition|(
operator|(
name|z2
operator|.
name|len
operator|==
literal|1
operator|)
operator|&&
operator|(
operator|*
name|z2
operator|.
name|v
operator|==
literal|10
operator|)
condition|)
return|return
name|zlog10
argument_list|(
name|z1
argument_list|)
return|;
comment|/* 	 * Now loop by squaring the base each time, and see whether or 	 * not each successive square is still smaller than the number. 	 */
name|worth
operator|=
literal|1
expr_stmt|;
name|zp
operator|=
operator|&
name|squares
index|[
literal|0
index|]
expr_stmt|;
operator|*
name|zp
operator|=
name|z2
expr_stmt|;
while|while
condition|(
operator|(
operator|(
name|zp
operator|->
name|len
operator|*
literal|2
operator|)
operator|-
literal|1
operator|)
operator|<=
name|z1
operator|.
name|len
condition|)
block|{
comment|/* while square not too large */
name|zsquare
argument_list|(
operator|*
name|zp
argument_list|,
name|zp
operator|+
literal|1
argument_list|)
expr_stmt|;
name|zp
operator|++
expr_stmt|;
name|worth
operator|*=
literal|2
expr_stmt|;
block|}
comment|/* 	 * Now back down the squares, and multiply them together to see 	 * exactly how many times the base can be raised by. 	 */
name|val
operator|=
name|_one_
expr_stmt|;
name|power
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
name|zp
operator|>=
name|squares
condition|;
name|zp
operator|--
operator|,
name|worth
operator|/=
literal|2
control|)
block|{
if|if
condition|(
operator|(
name|val
operator|.
name|len
operator|+
name|zp
operator|->
name|len
operator|-
literal|1
operator|)
operator|<=
name|z1
operator|.
name|len
condition|)
block|{
name|zmul
argument_list|(
name|val
argument_list|,
operator|*
name|zp
argument_list|,
operator|&
name|temp
argument_list|)
expr_stmt|;
if|if
condition|(
name|zrel
argument_list|(
name|z1
argument_list|,
name|temp
argument_list|)
operator|>=
literal|0
condition|)
block|{
name|freeh
argument_list|(
name|val
operator|.
name|v
argument_list|)
expr_stmt|;
name|val
operator|=
name|temp
expr_stmt|;
name|power
operator|+=
name|worth
expr_stmt|;
block|}
else|else
name|freeh
argument_list|(
name|temp
operator|.
name|v
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|zp
operator|!=
name|squares
condition|)
name|freeh
argument_list|(
name|zp
operator|->
name|v
argument_list|)
expr_stmt|;
block|}
return|return
name|power
return|;
block|}
end_function

begin_comment
comment|/*  * Return the integral log base 10 of a number.  */
end_comment

begin_function
name|long
name|zlog10
parameter_list|(
name|z
parameter_list|)
name|ZVALUE
name|z
decl_stmt|;
block|{
specifier|register
name|ZVALUE
modifier|*
name|zp
decl_stmt|;
comment|/* current square */
name|long
name|power
decl_stmt|;
comment|/* current power */
name|long
name|worth
decl_stmt|;
comment|/* worth of current square */
name|ZVALUE
name|val
decl_stmt|;
comment|/* current value of power */
name|ZVALUE
name|temp
decl_stmt|;
comment|/* temporary */
if|if
condition|(
operator|!
name|ispos
argument_list|(
name|z
argument_list|)
condition|)
name|error
argument_list|(
literal|"Non-positive number for log10"
argument_list|)
expr_stmt|;
comment|/* 	 * Loop by squaring the base each time, and see whether or 	 * not each successive square is still smaller than the number. 	 */
name|worth
operator|=
literal|1
expr_stmt|;
name|zp
operator|=
operator|&
name|_tenpowers_
index|[
literal|0
index|]
expr_stmt|;
operator|*
name|zp
operator|=
name|_ten_
expr_stmt|;
while|while
condition|(
operator|(
operator|(
name|zp
operator|->
name|len
operator|*
literal|2
operator|)
operator|-
literal|1
operator|)
operator|<=
name|z
operator|.
name|len
condition|)
block|{
comment|/* while square not too large */
if|if
condition|(
name|zp
index|[
literal|1
index|]
operator|.
name|len
operator|==
literal|0
condition|)
name|zsquare
argument_list|(
operator|*
name|zp
argument_list|,
name|zp
operator|+
literal|1
argument_list|)
expr_stmt|;
name|zp
operator|++
expr_stmt|;
name|worth
operator|*=
literal|2
expr_stmt|;
block|}
comment|/* 	 * Now back down the squares, and multiply them together to see 	 * exactly how many times the base can be raised by. 	 */
name|val
operator|=
name|_one_
expr_stmt|;
name|power
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
name|zp
operator|>=
name|_tenpowers_
condition|;
name|zp
operator|--
operator|,
name|worth
operator|/=
literal|2
control|)
block|{
if|if
condition|(
operator|(
name|val
operator|.
name|len
operator|+
name|zp
operator|->
name|len
operator|-
literal|1
operator|)
operator|<=
name|z
operator|.
name|len
condition|)
block|{
name|zmul
argument_list|(
name|val
argument_list|,
operator|*
name|zp
argument_list|,
operator|&
name|temp
argument_list|)
expr_stmt|;
if|if
condition|(
name|zrel
argument_list|(
name|z
argument_list|,
name|temp
argument_list|)
operator|>=
literal|0
condition|)
block|{
name|freeh
argument_list|(
name|val
operator|.
name|v
argument_list|)
expr_stmt|;
name|val
operator|=
name|temp
expr_stmt|;
name|power
operator|+=
name|worth
expr_stmt|;
block|}
else|else
name|freeh
argument_list|(
name|temp
operator|.
name|v
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|power
return|;
block|}
end_function

begin_comment
comment|/*  * Return the number of times that one number will divide another.  * This works similarly to zlog, except that divisions must be exact.  * For example, zdivcount(540, 3) = 3, since 3^3 divides 540 but 3^4 won't.  */
end_comment

begin_function
name|long
name|zdivcount
parameter_list|(
name|z1
parameter_list|,
name|z2
parameter_list|)
name|ZVALUE
name|z1
decl_stmt|,
name|z2
decl_stmt|;
block|{
name|long
name|count
decl_stmt|;
comment|/* number of factors removed */
name|ZVALUE
name|tmp
decl_stmt|;
comment|/* ignored return value */
name|count
operator|=
name|zfacrem
argument_list|(
name|z1
argument_list|,
name|z2
argument_list|,
operator|&
name|tmp
argument_list|)
expr_stmt|;
name|freeh
argument_list|(
name|tmp
operator|.
name|v
argument_list|)
expr_stmt|;
return|return
name|count
return|;
block|}
end_function

begin_comment
comment|/*  * Remove all occurances of the specified factor from a number.  * Also returns the number of factors removed as a function return value.  * Example:  zfacrem(540, 3,&x) returns 3 and sets x to 20.  */
end_comment

begin_function
name|long
name|zfacrem
parameter_list|(
name|z1
parameter_list|,
name|z2
parameter_list|,
name|rem
parameter_list|)
name|ZVALUE
name|z1
decl_stmt|,
name|z2
decl_stmt|,
decl|*
name|rem
decl_stmt|;
end_function

begin_block
block|{
specifier|register
name|ZVALUE
modifier|*
name|zp
decl_stmt|;
comment|/* current square */
name|long
name|count
decl_stmt|;
comment|/* total count of divisions */
name|long
name|worth
decl_stmt|;
comment|/* worth of current square */
name|ZVALUE
name|temp1
decl_stmt|,
name|temp2
decl_stmt|,
name|temp3
decl_stmt|;
comment|/* temporaries */
name|ZVALUE
name|squares
index|[
literal|32
index|]
decl_stmt|;
comment|/* table of squares of factor */
name|z1
operator|.
name|sign
operator|=
literal|0
expr_stmt|;
name|z2
operator|.
name|sign
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Make sure factor isn't 0 or 1. 	 */
if|if
condition|(
name|isleone
argument_list|(
name|z2
argument_list|)
condition|)
name|error
argument_list|(
literal|"Bad argument for facrem"
argument_list|)
expr_stmt|;
comment|/* 	 * Reject trivial cases. 	 */
if|if
condition|(
operator|(
name|z1
operator|.
name|len
operator|<
name|z2
operator|.
name|len
operator|)
operator|||
operator|(
name|isodd
argument_list|(
name|z1
argument_list|)
operator|&&
name|iseven
argument_list|(
name|z2
argument_list|)
operator|)
operator|||
operator|(
operator|(
name|z1
operator|.
name|len
operator|==
name|z2
operator|.
name|len
operator|)
operator|&&
operator|(
name|z1
operator|.
name|v
index|[
name|z1
operator|.
name|len
operator|-
literal|1
index|]
operator|<
name|z2
operator|.
name|v
index|[
name|z2
operator|.
name|len
operator|-
literal|1
index|]
operator|)
operator|)
condition|)
block|{
name|rem
operator|->
name|v
operator|=
name|alloc
argument_list|(
name|z1
operator|.
name|len
argument_list|)
expr_stmt|;
name|rem
operator|->
name|len
operator|=
name|z1
operator|.
name|len
expr_stmt|;
name|rem
operator|->
name|sign
operator|=
literal|0
expr_stmt|;
name|copyval
argument_list|(
name|z1
argument_list|,
operator|*
name|rem
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* 	 * Handle any power of two special. 	 */
if|if
condition|(
name|zisonebit
argument_list|(
name|z2
argument_list|)
condition|)
block|{
name|count
operator|=
name|zlowbit
argument_list|(
name|z1
argument_list|)
operator|/
name|zlowbit
argument_list|(
name|z2
argument_list|)
expr_stmt|;
name|rem
operator|->
name|v
operator|=
name|alloc
argument_list|(
name|z1
operator|.
name|len
argument_list|)
expr_stmt|;
name|rem
operator|->
name|len
operator|=
name|z1
operator|.
name|len
expr_stmt|;
name|rem
operator|->
name|sign
operator|=
literal|0
expr_stmt|;
name|copyval
argument_list|(
name|z1
argument_list|,
operator|*
name|rem
argument_list|)
expr_stmt|;
name|shiftr
argument_list|(
operator|*
name|rem
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|trim
argument_list|(
name|rem
argument_list|)
expr_stmt|;
return|return
name|count
return|;
block|}
comment|/* 	 * See if the factor goes in even once. 	 */
name|zdiv
argument_list|(
name|z1
argument_list|,
name|z2
argument_list|,
operator|&
name|temp1
argument_list|,
operator|&
name|temp2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|iszero
argument_list|(
name|temp2
argument_list|)
condition|)
block|{
name|freeh
argument_list|(
name|temp1
operator|.
name|v
argument_list|)
expr_stmt|;
name|freeh
argument_list|(
name|temp2
operator|.
name|v
argument_list|)
expr_stmt|;
name|rem
operator|->
name|v
operator|=
name|alloc
argument_list|(
name|z1
operator|.
name|len
argument_list|)
expr_stmt|;
name|rem
operator|->
name|len
operator|=
name|z1
operator|.
name|len
expr_stmt|;
name|rem
operator|->
name|sign
operator|=
literal|0
expr_stmt|;
name|copyval
argument_list|(
name|z1
argument_list|,
operator|*
name|rem
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|freeh
argument_list|(
name|temp2
operator|.
name|v
argument_list|)
expr_stmt|;
name|z1
operator|=
name|temp1
expr_stmt|;
comment|/* 	 * Now loop by squaring the factor each time, and see whether 	 * or not each successive square will still divide the number. 	 */
name|count
operator|=
literal|1
expr_stmt|;
name|worth
operator|=
literal|1
expr_stmt|;
name|zp
operator|=
operator|&
name|squares
index|[
literal|0
index|]
expr_stmt|;
operator|*
name|zp
operator|=
name|z2
expr_stmt|;
while|while
condition|(
operator|(
operator|(
name|zp
operator|->
name|len
operator|*
literal|2
operator|)
operator|-
literal|1
operator|)
operator|<=
name|z1
operator|.
name|len
condition|)
block|{
comment|/* while square not too large */
name|zsquare
argument_list|(
operator|*
name|zp
argument_list|,
operator|&
name|temp1
argument_list|)
expr_stmt|;
name|zdiv
argument_list|(
name|z1
argument_list|,
name|temp1
argument_list|,
operator|&
name|temp2
argument_list|,
operator|&
name|temp3
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|iszero
argument_list|(
name|temp3
argument_list|)
condition|)
block|{
name|freeh
argument_list|(
name|temp1
operator|.
name|v
argument_list|)
expr_stmt|;
name|freeh
argument_list|(
name|temp2
operator|.
name|v
argument_list|)
expr_stmt|;
name|freeh
argument_list|(
name|temp3
operator|.
name|v
argument_list|)
expr_stmt|;
break|break;
block|}
name|freeh
argument_list|(
name|temp3
operator|.
name|v
argument_list|)
expr_stmt|;
name|freeh
argument_list|(
name|z1
operator|.
name|v
argument_list|)
expr_stmt|;
name|z1
operator|=
name|temp2
expr_stmt|;
operator|*
operator|++
name|zp
operator|=
name|temp1
expr_stmt|;
name|worth
operator|*=
literal|2
expr_stmt|;
name|count
operator|+=
name|worth
expr_stmt|;
block|}
comment|/* 	 * Now back down the list of squares, and see if the lower powers 	 * will divide any more times. 	 */
for|for
control|(
init|;
name|zp
operator|>=
name|squares
condition|;
name|zp
operator|--
operator|,
name|worth
operator|/=
literal|2
control|)
block|{
if|if
condition|(
name|zp
operator|->
name|len
operator|<=
name|z1
operator|.
name|len
condition|)
block|{
name|zdiv
argument_list|(
name|z1
argument_list|,
operator|*
name|zp
argument_list|,
operator|&
name|temp1
argument_list|,
operator|&
name|temp2
argument_list|)
expr_stmt|;
if|if
condition|(
name|iszero
argument_list|(
name|temp2
argument_list|)
condition|)
block|{
name|temp3
operator|=
name|z1
expr_stmt|;
name|z1
operator|=
name|temp1
expr_stmt|;
name|temp1
operator|=
name|temp3
expr_stmt|;
name|count
operator|+=
name|worth
expr_stmt|;
block|}
name|freeh
argument_list|(
name|temp1
operator|.
name|v
argument_list|)
expr_stmt|;
name|freeh
argument_list|(
name|temp2
operator|.
name|v
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|zp
operator|!=
name|squares
condition|)
name|freeh
argument_list|(
name|zp
operator|->
name|v
argument_list|)
expr_stmt|;
block|}
operator|*
name|rem
operator|=
name|z1
expr_stmt|;
return|return
name|count
return|;
block|}
end_block

begin_comment
comment|/*  * Keep dividing a number by the gcd of it with another number until the  * result is relatively prime to the second number.  */
end_comment

begin_function
name|void
name|zgcdrem
parameter_list|(
name|z1
parameter_list|,
name|z2
parameter_list|,
name|res
parameter_list|)
name|ZVALUE
name|z1
decl_stmt|,
name|z2
decl_stmt|,
decl|*
name|res
decl_stmt|;
end_function

begin_block
block|{
name|ZVALUE
name|tmp1
decl_stmt|,
name|tmp2
decl_stmt|;
comment|/* 	 * Begin by taking the gcd for the first time. 	 * If the number is already relatively prime, then we are done. 	 */
name|zgcd
argument_list|(
name|z1
argument_list|,
name|z2
argument_list|,
operator|&
name|tmp1
argument_list|)
expr_stmt|;
if|if
condition|(
name|isunit
argument_list|(
name|tmp1
argument_list|)
operator|||
name|iszero
argument_list|(
name|tmp1
argument_list|)
condition|)
block|{
name|res
operator|->
name|len
operator|=
name|z1
operator|.
name|len
expr_stmt|;
name|res
operator|->
name|v
operator|=
name|alloc
argument_list|(
name|z1
operator|.
name|len
argument_list|)
expr_stmt|;
name|res
operator|->
name|sign
operator|=
name|z1
operator|.
name|sign
expr_stmt|;
name|copyval
argument_list|(
name|z1
argument_list|,
operator|*
name|res
argument_list|)
expr_stmt|;
return|return;
block|}
name|zquo
argument_list|(
name|z1
argument_list|,
name|tmp1
argument_list|,
operator|&
name|tmp2
argument_list|)
expr_stmt|;
name|z1
operator|=
name|tmp2
expr_stmt|;
name|z2
operator|=
name|tmp1
expr_stmt|;
comment|/* 	 * Now keep alternately taking the gcd and removing factors until 	 * the gcd becomes one. 	 */
while|while
condition|(
operator|!
name|isunit
argument_list|(
name|z2
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|zfacrem
argument_list|(
name|z1
argument_list|,
name|z2
argument_list|,
operator|&
name|tmp1
argument_list|)
expr_stmt|;
name|freeh
argument_list|(
name|z1
operator|.
name|v
argument_list|)
expr_stmt|;
name|z1
operator|=
name|tmp1
expr_stmt|;
name|zgcd
argument_list|(
name|z1
argument_list|,
name|z2
argument_list|,
operator|&
name|tmp1
argument_list|)
expr_stmt|;
name|freeh
argument_list|(
name|z2
operator|.
name|v
argument_list|)
expr_stmt|;
name|z2
operator|=
name|tmp1
expr_stmt|;
block|}
operator|*
name|res
operator|=
name|z1
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Find the lowest prime factor of a number if one can be found.  * Search is conducted for the first count primes.  * Returns 1 if no factor was found.  */
end_comment

begin_function
name|long
name|zlowfactor
parameter_list|(
name|z
parameter_list|,
name|count
parameter_list|)
name|ZVALUE
name|z
decl_stmt|;
name|long
name|count
decl_stmt|;
block|{
name|FULL
name|p
decl_stmt|,
name|d
decl_stmt|;
name|ZVALUE
name|div
decl_stmt|,
name|tmp
decl_stmt|;
name|HALF
name|divval
index|[
literal|2
index|]
decl_stmt|;
if|if
condition|(
operator|(
operator|--
name|count
operator|<
literal|0
operator|)
operator|||
name|iszero
argument_list|(
name|z
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|iseven
argument_list|(
name|z
argument_list|)
condition|)
return|return
literal|2
return|;
name|div
operator|.
name|sign
operator|=
literal|0
expr_stmt|;
name|div
operator|.
name|v
operator|=
name|divval
expr_stmt|;
for|for
control|(
name|p
operator|=
literal|3
init|;
operator|(
name|count
operator|>
literal|0
operator|)
condition|;
name|p
operator|+=
literal|2
control|)
block|{
for|for
control|(
name|d
operator|=
literal|3
init|;
operator|(
name|d
operator|*
name|d
operator|)
operator|<=
name|p
condition|;
name|d
operator|+=
literal|2
control|)
if|if
condition|(
operator|(
name|p
operator|%
name|d
operator|)
operator|==
literal|0
condition|)
goto|goto
name|next
goto|;
name|divval
index|[
literal|0
index|]
operator|=
operator|(
name|p
operator|&
name|BASE1
operator|)
expr_stmt|;
name|divval
index|[
literal|1
index|]
operator|=
operator|(
name|p
operator|/
name|BASE
operator|)
expr_stmt|;
name|div
operator|.
name|len
operator|=
literal|1
operator|+
operator|(
name|p
operator|>=
name|BASE
operator|)
expr_stmt|;
name|zmod
argument_list|(
name|z
argument_list|,
name|div
argument_list|,
operator|&
name|tmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|iszero
argument_list|(
name|tmp
argument_list|)
condition|)
return|return
name|p
return|;
name|freeh
argument_list|(
name|tmp
operator|.
name|v
argument_list|)
expr_stmt|;
name|count
operator|--
expr_stmt|;
name|next
label|:
empty_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * Return the number of digits (base 10) in a number, ignoring the sign.  */
end_comment

begin_function
name|long
name|zdigits
parameter_list|(
name|z1
parameter_list|)
name|ZVALUE
name|z1
decl_stmt|;
block|{
name|long
name|count
decl_stmt|,
name|val
decl_stmt|;
name|z1
operator|.
name|sign
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|istiny
argument_list|(
name|z1
argument_list|)
condition|)
block|{
comment|/* do small numbers ourself */
name|count
operator|=
literal|1
expr_stmt|;
name|val
operator|=
literal|10
expr_stmt|;
while|while
condition|(
operator|*
name|z1
operator|.
name|v
operator|>=
operator|(
name|HALF
operator|)
name|val
condition|)
block|{
name|count
operator|++
expr_stmt|;
name|val
operator|*=
literal|10
expr_stmt|;
block|}
return|return
name|count
return|;
block|}
return|return
operator|(
name|zlog10
argument_list|(
name|z1
argument_list|)
operator|+
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Return the single digit at the specified decimal place of a number,  * where 0 means the rightmost digit.  Example:  zdigit(1234, 1) = 3.  */
end_comment

begin_function
name|FLAG
name|zdigit
parameter_list|(
name|z1
parameter_list|,
name|n
parameter_list|)
name|ZVALUE
name|z1
decl_stmt|;
name|long
name|n
decl_stmt|;
block|{
name|ZVALUE
name|tmp1
decl_stmt|,
name|tmp2
decl_stmt|;
name|FLAG
name|res
decl_stmt|;
name|z1
operator|.
name|sign
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|iszero
argument_list|(
name|z1
argument_list|)
operator|||
operator|(
name|n
operator|<
literal|0
operator|)
operator|||
operator|(
name|n
operator|/
name|BASEDIG
operator|>=
name|z1
operator|.
name|len
operator|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|n
operator|==
literal|0
condition|)
return|return
name|zmodi
argument_list|(
name|z1
argument_list|,
literal|10L
argument_list|)
return|;
if|if
condition|(
name|n
operator|==
literal|1
condition|)
return|return
name|zmodi
argument_list|(
name|z1
argument_list|,
literal|100L
argument_list|)
operator|/
literal|10
return|;
if|if
condition|(
name|n
operator|==
literal|2
condition|)
return|return
name|zmodi
argument_list|(
name|z1
argument_list|,
literal|1000L
argument_list|)
operator|/
literal|100
return|;
if|if
condition|(
name|n
operator|==
literal|3
condition|)
return|return
name|zmodi
argument_list|(
name|z1
argument_list|,
literal|10000L
argument_list|)
operator|/
literal|1000
return|;
name|ztenpow
argument_list|(
name|n
argument_list|,
operator|&
name|tmp1
argument_list|)
expr_stmt|;
name|zquo
argument_list|(
name|z1
argument_list|,
name|tmp1
argument_list|,
operator|&
name|tmp2
argument_list|)
expr_stmt|;
name|res
operator|=
name|zmodi
argument_list|(
name|tmp2
argument_list|,
literal|10L
argument_list|)
expr_stmt|;
name|freeh
argument_list|(
name|tmp1
operator|.
name|v
argument_list|)
expr_stmt|;
name|freeh
argument_list|(
name|tmp2
operator|.
name|v
argument_list|)
expr_stmt|;
return|return
name|res
return|;
block|}
end_function

begin_comment
comment|/*  * Find the square root of a number.  This is the greatest integer whose  * square is less than or equal to the number. Returns TRUE if the  * square root is exact.  */
end_comment

begin_function
name|BOOL
name|zsqrt
parameter_list|(
name|z1
parameter_list|,
name|dest
parameter_list|)
name|ZVALUE
name|z1
decl_stmt|,
decl|*
name|dest
decl_stmt|;
end_function

begin_block
block|{
name|ZVALUE
name|try
decl_stmt|,
name|quo
decl_stmt|,
name|rem
decl_stmt|,
name|old
decl_stmt|,
name|temp
decl_stmt|;
name|FULL
name|iquo
decl_stmt|,
name|val
decl_stmt|;
name|long
name|i
decl_stmt|,
name|j
decl_stmt|;
if|if
condition|(
name|z1
operator|.
name|sign
condition|)
name|error
argument_list|(
literal|"Square root of negative number"
argument_list|)
expr_stmt|;
if|if
condition|(
name|iszero
argument_list|(
name|z1
argument_list|)
condition|)
block|{
operator|*
name|dest
operator|=
name|_zero_
expr_stmt|;
return|return
name|TRUE
return|;
block|}
if|if
condition|(
operator|(
operator|*
name|z1
operator|.
name|v
operator|<
literal|4
operator|)
operator|&&
name|istiny
argument_list|(
name|z1
argument_list|)
condition|)
block|{
operator|*
name|dest
operator|=
name|_one_
expr_stmt|;
return|return
operator|(
operator|*
name|z1
operator|.
name|v
operator|==
literal|1
operator|)
return|;
block|}
comment|/* 	 * Pick the square root of the leading one or two digits as a first guess. 	 */
name|val
operator|=
name|z1
operator|.
name|v
index|[
name|z1
operator|.
name|len
operator|-
literal|1
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|z1
operator|.
name|len
operator|&
literal|0x1
operator|)
operator|==
literal|0
condition|)
name|val
operator|=
operator|(
name|val
operator|*
name|BASE
operator|)
operator|+
name|z1
operator|.
name|v
index|[
name|z1
operator|.
name|len
operator|-
literal|2
index|]
expr_stmt|;
comment|/* 	 * Find the largest power of 2 that when squared 	 * is<= val> 0.  Avoid multiply overflow by doing  	 * a careful check at the BASE boundary. 	 */
name|j
operator|=
literal|1
operator|<<
operator|(
name|BASEB
operator|+
name|BASEB
operator|-
literal|2
operator|)
expr_stmt|;
if|if
condition|(
name|val
operator|>
name|j
condition|)
block|{
name|iquo
operator|=
name|BASE
expr_stmt|;
block|}
else|else
block|{
name|i
operator|=
name|BASEB
operator|-
literal|1
expr_stmt|;
while|while
condition|(
name|j
operator|>
name|val
condition|)
block|{
operator|--
name|i
expr_stmt|;
name|j
operator|>>=
literal|2
expr_stmt|;
block|}
name|iquo
operator|=
name|bitmask
index|[
name|i
index|]
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|8
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
name|iquo
operator|=
operator|(
name|iquo
operator|+
operator|(
name|val
operator|/
name|iquo
operator|)
operator|)
operator|/
literal|2
expr_stmt|;
if|if
condition|(
name|iquo
operator|>
name|BASE1
condition|)
name|iquo
operator|=
name|BASE1
expr_stmt|;
comment|/* 	 * Allocate the numbers to use for the main loop. 	 * The size and high bits of the final result are correctly set here. 	 * Notice that the remainder of the test value is rubbish, but this 	 * is unimportant. 	 */
name|try
operator|.
name|sign
operator|=
literal|0
expr_stmt|;
name|try
operator|.
name|len
operator|=
operator|(
name|z1
operator|.
name|len
operator|+
literal|1
operator|)
operator|/
literal|2
expr_stmt|;
name|try
operator|.
name|v
operator|=
name|alloc
argument_list|(
name|try
operator|.
name|len
argument_list|)
expr_stmt|;
name|try
operator|.
name|v
index|[
name|try
operator|.
name|len
operator|-
literal|1
index|]
operator|=
operator|(
name|HALF
operator|)
name|iquo
expr_stmt|;
name|old
operator|.
name|sign
operator|=
literal|0
expr_stmt|;
name|old
operator|.
name|v
operator|=
name|alloc
argument_list|(
name|try
operator|.
name|len
argument_list|)
expr_stmt|;
name|old
operator|.
name|len
operator|=
literal|1
expr_stmt|;
operator|*
name|old
operator|.
name|v
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Main divide and average loop 	 */
for|for
control|(
init|;
condition|;
control|)
block|{
name|zdiv
argument_list|(
name|z1
argument_list|,
name|try
argument_list|,
operator|&
name|quo
argument_list|,
operator|&
name|rem
argument_list|)
expr_stmt|;
name|i
operator|=
name|zrel
argument_list|(
name|try
argument_list|,
name|quo
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|==
literal|0
operator|)
operator|&&
name|iszero
argument_list|(
name|rem
argument_list|)
condition|)
block|{
comment|/* exact square root */
name|freeh
argument_list|(
name|rem
operator|.
name|v
argument_list|)
expr_stmt|;
name|freeh
argument_list|(
name|quo
operator|.
name|v
argument_list|)
expr_stmt|;
name|freeh
argument_list|(
name|old
operator|.
name|v
argument_list|)
expr_stmt|;
operator|*
name|dest
operator|=
name|try
expr_stmt|;
return|return
name|TRUE
return|;
block|}
name|freeh
argument_list|(
name|rem
operator|.
name|v
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<=
literal|0
condition|)
block|{
comment|/* 			* Current try is less than or equal to the square root since 			* it is less than the quotient.  If the quotient is equal to 			* the try, we are all done.  Also, if the try is equal to the 			* old try value, we are done since no improvement occurred. 			* If not, save the improved value and loop some more. 			*/
if|if
condition|(
operator|(
name|i
operator|==
literal|0
operator|)
operator|||
operator|(
name|zcmp
argument_list|(
name|old
argument_list|,
name|try
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|freeh
argument_list|(
name|quo
operator|.
name|v
argument_list|)
expr_stmt|;
name|freeh
argument_list|(
name|old
operator|.
name|v
argument_list|)
expr_stmt|;
operator|*
name|dest
operator|=
name|try
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|old
operator|.
name|len
operator|=
name|try
operator|.
name|len
expr_stmt|;
name|copyval
argument_list|(
name|try
argument_list|,
name|old
argument_list|)
expr_stmt|;
block|}
comment|/* average current try and quotent for the new try */
name|zadd
argument_list|(
name|try
argument_list|,
name|quo
argument_list|,
operator|&
name|temp
argument_list|)
expr_stmt|;
name|freeh
argument_list|(
name|quo
operator|.
name|v
argument_list|)
expr_stmt|;
name|freeh
argument_list|(
name|try
operator|.
name|v
argument_list|)
expr_stmt|;
name|try
operator|=
name|temp
expr_stmt|;
name|shiftr
argument_list|(
name|try
argument_list|,
literal|1L
argument_list|)
expr_stmt|;
name|quicktrim
argument_list|(
name|try
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  * Take an arbitrary root of a number (to the greatest integer).  * This uses the following iteration to get the Kth root of N:  *	x = ((K-1) * x + N / x^(K-1)) / K  */
end_comment

begin_function
name|void
name|zroot
parameter_list|(
name|z1
parameter_list|,
name|z2
parameter_list|,
name|dest
parameter_list|)
name|ZVALUE
name|z1
decl_stmt|,
name|z2
decl_stmt|,
decl|*
name|dest
decl_stmt|;
end_function

begin_block
block|{
name|ZVALUE
name|try
decl_stmt|,
name|quo
decl_stmt|,
name|old
decl_stmt|,
name|temp
decl_stmt|,
name|temp2
decl_stmt|;
name|ZVALUE
name|k1
decl_stmt|;
comment|/* holds k - 1 */
name|int
name|sign
decl_stmt|;
name|long
name|i
decl_stmt|,
name|k
decl_stmt|,
name|highbit
decl_stmt|;
name|SIUNION
name|sival
decl_stmt|;
name|sign
operator|=
name|z1
operator|.
name|sign
expr_stmt|;
if|if
condition|(
name|sign
operator|&&
name|iseven
argument_list|(
name|z2
argument_list|)
condition|)
name|error
argument_list|(
literal|"Even root of negative number"
argument_list|)
expr_stmt|;
if|if
condition|(
name|iszero
argument_list|(
name|z2
argument_list|)
operator|||
name|isneg
argument_list|(
name|z2
argument_list|)
condition|)
name|error
argument_list|(
literal|"Non-positive root"
argument_list|)
expr_stmt|;
if|if
condition|(
name|iszero
argument_list|(
name|z1
argument_list|)
condition|)
block|{
comment|/* root of zero */
operator|*
name|dest
operator|=
name|_zero_
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|isunit
argument_list|(
name|z2
argument_list|)
condition|)
block|{
comment|/* first root */
name|zcopy
argument_list|(
name|z1
argument_list|,
name|dest
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|isbig
argument_list|(
name|z2
argument_list|)
condition|)
block|{
comment|/* humongous root */
operator|*
name|dest
operator|=
name|_one_
expr_stmt|;
name|dest
operator|->
name|sign
operator|=
operator|(
name|HALF
operator|)
name|sign
expr_stmt|;
return|return;
block|}
name|k
operator|=
operator|(
name|istiny
argument_list|(
name|z2
argument_list|)
condition|?
name|z1tol
argument_list|(
name|z2
argument_list|)
else|:
name|z2tol
argument_list|(
name|z2
argument_list|)
operator|)
expr_stmt|;
name|highbit
operator|=
name|zhighbit
argument_list|(
name|z1
argument_list|)
expr_stmt|;
if|if
condition|(
name|highbit
operator|<
name|k
condition|)
block|{
comment|/* too high a root */
operator|*
name|dest
operator|=
name|_one_
expr_stmt|;
name|dest
operator|->
name|sign
operator|=
operator|(
name|HALF
operator|)
name|sign
expr_stmt|;
return|return;
block|}
name|sival
operator|.
name|ivalue
operator|=
name|k
operator|-
literal|1
expr_stmt|;
name|k1
operator|.
name|v
operator|=
operator|&
name|sival
operator|.
name|silow
expr_stmt|;
name|k1
operator|.
name|len
operator|=
literal|1
operator|+
operator|(
name|sival
operator|.
name|sihigh
operator|!=
literal|0
operator|)
expr_stmt|;
name|k1
operator|.
name|sign
operator|=
literal|0
expr_stmt|;
name|z1
operator|.
name|sign
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Allocate the numbers to use for the main loop. 	 * The size and high bits of the final result are correctly set here. 	 * Notice that the remainder of the test value is rubbish, but this 	 * is unimportant. 	 */
name|highbit
operator|=
operator|(
name|highbit
operator|+
name|k
operator|-
literal|1
operator|)
operator|/
name|k
expr_stmt|;
name|try
operator|.
name|len
operator|=
operator|(
name|highbit
operator|/
name|BASEB
operator|)
operator|+
literal|1
expr_stmt|;
name|try
operator|.
name|v
operator|=
name|alloc
argument_list|(
name|try
operator|.
name|len
argument_list|)
expr_stmt|;
name|try
operator|.
name|v
index|[
name|try
operator|.
name|len
operator|-
literal|1
index|]
operator|=
operator|(
operator|(
name|HALF
operator|)
literal|1
operator|<<
operator|(
name|highbit
operator|%
name|BASEB
operator|)
operator|)
expr_stmt|;
name|try
operator|.
name|sign
operator|=
literal|0
expr_stmt|;
name|old
operator|.
name|v
operator|=
name|alloc
argument_list|(
name|try
operator|.
name|len
argument_list|)
expr_stmt|;
name|old
operator|.
name|len
operator|=
literal|1
expr_stmt|;
operator|*
name|old
operator|.
name|v
operator|=
literal|0
expr_stmt|;
name|old
operator|.
name|sign
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Main divide and average loop 	 */
for|for
control|(
init|;
condition|;
control|)
block|{
name|zpowi
argument_list|(
name|try
argument_list|,
name|k1
argument_list|,
operator|&
name|temp
argument_list|)
expr_stmt|;
name|zquo
argument_list|(
name|z1
argument_list|,
name|temp
argument_list|,
operator|&
name|quo
argument_list|)
expr_stmt|;
name|freeh
argument_list|(
name|temp
operator|.
name|v
argument_list|)
expr_stmt|;
name|i
operator|=
name|zrel
argument_list|(
name|try
argument_list|,
name|quo
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<=
literal|0
condition|)
block|{
comment|/* 			 * Current try is less than or equal to the root since it is 			 * less than the quotient. If the quotient is equal to the try, 			 * we are all done.  Also, if the try is equal to the old value, 			 * we are done since no improvement occurred. 			 * If not, save the improved value and loop some more. 			 */
if|if
condition|(
operator|(
name|i
operator|==
literal|0
operator|)
operator|||
operator|(
name|zcmp
argument_list|(
name|old
argument_list|,
name|try
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|freeh
argument_list|(
name|quo
operator|.
name|v
argument_list|)
expr_stmt|;
name|freeh
argument_list|(
name|old
operator|.
name|v
argument_list|)
expr_stmt|;
name|try
operator|.
name|sign
operator|=
operator|(
name|HALF
operator|)
name|sign
expr_stmt|;
name|quicktrim
argument_list|(
name|try
argument_list|)
expr_stmt|;
operator|*
name|dest
operator|=
name|try
expr_stmt|;
return|return;
block|}
name|old
operator|.
name|len
operator|=
name|try
operator|.
name|len
expr_stmt|;
name|copyval
argument_list|(
name|try
argument_list|,
name|old
argument_list|)
expr_stmt|;
block|}
comment|/* average current try and quotent for the new try */
name|zmul
argument_list|(
name|try
argument_list|,
name|k1
argument_list|,
operator|&
name|temp
argument_list|)
expr_stmt|;
name|freeh
argument_list|(
name|try
operator|.
name|v
argument_list|)
expr_stmt|;
name|zadd
argument_list|(
name|quo
argument_list|,
name|temp
argument_list|,
operator|&
name|temp2
argument_list|)
expr_stmt|;
name|freeh
argument_list|(
name|temp
operator|.
name|v
argument_list|)
expr_stmt|;
name|freeh
argument_list|(
name|quo
operator|.
name|v
argument_list|)
expr_stmt|;
name|zquo
argument_list|(
name|temp2
argument_list|,
name|z2
argument_list|,
operator|&
name|try
argument_list|)
expr_stmt|;
name|freeh
argument_list|(
name|temp2
operator|.
name|v
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  * Test to see if a number is an exact square or not.  */
end_comment

begin_function
name|BOOL
name|zissquare
parameter_list|(
name|z
parameter_list|)
name|ZVALUE
name|z
decl_stmt|;
comment|/* number to be tested */
block|{
name|long
name|n
decl_stmt|,
name|i
decl_stmt|;
name|ZVALUE
name|tmp
decl_stmt|;
if|if
condition|(
name|z
operator|.
name|sign
condition|)
comment|/* negative */
return|return
name|FALSE
return|;
while|while
condition|(
operator|(
name|z
operator|.
name|len
operator|>
literal|1
operator|)
operator|&&
operator|(
operator|*
name|z
operator|.
name|v
operator|==
literal|0
operator|)
condition|)
block|{
comment|/* ignore trailing zero words */
name|z
operator|.
name|len
operator|--
expr_stmt|;
name|z
operator|.
name|v
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|isleone
argument_list|(
name|z
argument_list|)
condition|)
comment|/* zero or one */
return|return
name|TRUE
return|;
name|n
operator|=
operator|*
name|z
operator|.
name|v
operator|&
literal|0xf
expr_stmt|;
comment|/* check mod 16 values */
if|if
condition|(
operator|(
name|n
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|n
operator|!=
literal|1
operator|)
operator|&&
operator|(
name|n
operator|!=
literal|4
operator|)
operator|&&
operator|(
name|n
operator|!=
literal|9
operator|)
condition|)
return|return
name|FALSE
return|;
name|n
operator|=
operator|*
name|z
operator|.
name|v
operator|&
literal|0xff
expr_stmt|;
comment|/* check mod 256 values */
name|i
operator|=
literal|0x80
expr_stmt|;
while|while
condition|(
operator|(
operator|(
name|i
operator|*
name|i
operator|)
operator|&
literal|0xff
operator|)
operator|!=
name|n
condition|)
if|if
condition|(
operator|--
name|i
operator|<=
literal|0
condition|)
return|return
name|FALSE
return|;
name|n
operator|=
name|zsqrt
argument_list|(
name|z
argument_list|,
operator|&
name|tmp
argument_list|)
expr_stmt|;
comment|/* must do full square root test now */
name|freeh
argument_list|(
name|tmp
operator|.
name|v
argument_list|)
expr_stmt|;
return|return
name|n
return|;
block|}
end_function

begin_comment
comment|/* END CODE */
end_comment

end_unit

