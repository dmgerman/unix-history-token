begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_decl_stmt
name|int
name|cmdmsk
init|=
literal|127
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Command-terminal-to-C-Kermit character mask */
end_comment

begin_include
include|#
directive|include
file|"ckcdeb.h"
end_include

begin_comment
comment|/* Formats for debug(), etc. */
end_comment

begin_macro
name|_PROTOTYP
argument_list|(
argument|int unhex
argument_list|,
argument|(char)
argument_list|)
end_macro

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|NOICP
end_ifndef

begin_comment
comment|/* The rest only if interactive command parsing selected */
end_comment

begin_decl_stmt
name|char
modifier|*
name|cmdv
init|=
literal|"Command package 5A(053), 21 Nov 92"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  C K U C M D  --  Interactive command package for Unix  */
end_comment

begin_comment
comment|/*   Author: Frank da Cruz (fdc@columbia.edu, FDCCU@CUVMA.BITNET),   Columbia University Center for Computing Activities.   First released January 1985.   Copyright (C) 1985, 1992, Trustees of Columbia University in the City of New   York.  Permission is granted to any individual or institution to use this   software as long as it is not sold for profit.  This copyright notice must be   retained.  This software may not be included in commercial products without   written permission of Columbia University. */
end_comment

begin_comment
comment|/* Modeled after the DECSYSTEM-20 command parser (the COMND JSYS), RIP. Features: . parses and verifies keywords, filenames, text strings, numbers, other data . displays appropriate menu or help message when user types "?" . does keyword and filename completion when user types ESC or TAB . does partial filename completion . accepts any unique abbreviation for a keyword . allows keywords to have attributes, like "invisible" and "abbreviation" . can supply defaults for fields omitted by user . provides command line editing (character, word, and line deletion) . accepts input from keyboard, command files, or redirected stdin . allows for full or half duplex operation, character or line input . settable prompt, protected from deletion  Functions:  cmsetp - Set prompt (cmprom is prompt string)  cmsavp - Save current prompt  prompt - Issue prompt  cmini - Clear the command buffer (before parsing a new command)  cmres - Reset command buffer pointers (before reparsing)  cmkey - Parse a keyword  cmnum - Parse a number  cmifi - Parse an input file name  cmofi - Parse an output file name  cmdir - Parse a directory name (UNIX only)  cmfld - Parse an arbitrary field  cmtxt - Parse a text string  cmcfm - Parse command confirmation (end of line)  Return codes:  -3: no input provided when required  -2: input was invalid (e.g. not a number when a number was required)  -1: reparse required (user deleted into a preceding field)   0 or greater: success See individual functions for greater detail.  Before using these routines, the caller should #include ckucmd.h, and set the program's prompt by calling cmsetp().  If the file parsing functions cmifi, cmofi, or cmdir are to be used, this module must be linked with a ck?fio file system support module for the appropriate system, e.g. ckufio for Unix.  If the caller puts the terminal in character wakeup ("cbreak") mode with no echo, then these functions will provide line editing -- character, word, and line deletion, as well as keyword and filename completion upon ESC and help strings, keyword, or file menus upon '?'.  If the caller puts the terminal into character wakeup/noecho mode, care should be taken to restore it before exit from or interruption of the program.  If the character wakeup mode is not set, the system's own line editor may be used.  NOTE: Contrary to expectations, many #ifdef's have been added to this module. Any operation requiring an #ifdef (like clear screen, get character from keyboard, erase character from screen, etc) should eventually be turned into a call to a function that is defined in ck?tio.c, but then all the ck?tio.c modules would have to be changed... */
end_comment

begin_escape
end_escape

begin_comment
comment|/* Includes */
end_comment

begin_include
include|#
directive|include
file|"ckcker.h"
end_include

begin_comment
comment|/* (===OS2 addition===) */
end_comment

begin_include
include|#
directive|include
file|"ckcasc.h"
end_include

begin_comment
comment|/* ASCII character symbols */
end_comment

begin_include
include|#
directive|include
file|"ckucmd.h"
end_include

begin_comment
comment|/* Command parsing definitions */
end_comment

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_comment
comment|/* Error number symbols */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|OSK
end_ifdef

begin_define
define|#
directive|define
name|cc
value|ccount
end_define

begin_comment
comment|/* OS-9/68K compiler bug */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* OSK */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|GEMDOS
end_ifdef

begin_comment
comment|/* Atari ST */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|putchar
end_ifdef

begin_undef
undef|#
directive|undef
name|putchar
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* putchar */
end_comment

begin_define
define|#
directive|define
name|putchar
parameter_list|(
name|x
parameter_list|)
value|conoc(x)
end_define

begin_comment
comment|/* Why doesn't everyone do this? */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* GEMDOS */
end_comment

begin_comment
comment|/* Local variables */
end_comment

begin_decl_stmt
specifier|static
name|int
name|psetf
init|=
literal|0
decl_stmt|,
comment|/* Flag that prompt has been set */
name|cc
init|=
literal|0
decl_stmt|,
comment|/* Character count */
name|dpx
init|=
literal|0
decl_stmt|,
comment|/* Duplex (0 = full) */
name|inword
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* In the middle of getting a word */
end_comment

begin_decl_stmt
specifier|static
name|int
name|hw
init|=
name|HLPLW
decl_stmt|,
comment|/* Help line width */
name|hc
init|=
name|HLPCW
decl_stmt|,
comment|/* Help line column width */
name|hh
decl_stmt|,
comment|/* Current help column number */
name|hx
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Current help line position */
end_comment

begin_define
define|#
directive|define
name|PROML
value|160
end_define

begin_comment
comment|/* Maximum length for prompt */
end_comment

begin_decl_stmt
name|char
name|cmprom
index|[
name|PROML
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Program's prompt */
end_comment

begin_decl_stmt
name|char
name|cmprxx
index|[
name|PROML
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Program's prompt, unevaluated */
end_comment

begin_decl_stmt
name|char
modifier|*
name|dfprom
init|=
literal|"Command? "
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Default prompt */
end_comment

begin_decl_stmt
name|int
name|cmflgs
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Command flags */
end_comment

begin_decl_stmt
name|int
name|cmfsav
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* A saved version of them */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|DCMDBUF
end_ifdef

begin_decl_stmt
name|char
modifier|*
name|cmdbuf
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Command buffer */
end_comment

begin_decl_stmt
name|char
modifier|*
name|savbuf
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Help string buffer */
end_comment

begin_decl_stmt
name|char
modifier|*
name|hlpbuf
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Atom buffer */
end_comment

begin_decl_stmt
name|char
modifier|*
name|atmbuf
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* File name buffer */
end_comment

begin_decl_stmt
name|char
modifier|*
name|atxbuf
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* For expanding the atom buffer */
end_comment

begin_decl_stmt
name|int
name|atxn
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Length of expansion buffer */
end_comment

begin_decl_stmt
name|char
modifier|*
name|atybuf
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* For copying atom buffer */
end_comment

begin_decl_stmt
name|char
modifier|*
name|filbuf
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Buffer to save copy of command */
end_comment

begin_else
else|#
directive|else
end_else

begin_decl_stmt
name|char
name|cmdbuf
index|[
name|CMDBL
operator|+
literal|4
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Command buffer */
end_comment

begin_decl_stmt
name|char
name|hlpbuf
index|[
name|HLPBL
operator|+
literal|4
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Help string buffer */
end_comment

begin_decl_stmt
name|char
name|atmbuf
index|[
name|ATMBL
operator|+
literal|4
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Atom buffer */
end_comment

begin_decl_stmt
name|char
name|filbuf
index|[
name|ATMBL
operator|+
literal|4
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* File name buffer */
end_comment

begin_decl_stmt
name|char
name|atxbuf
index|[
name|CMDBL
operator|+
literal|4
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* For expanding the atom buffer */
end_comment

begin_decl_stmt
name|int
name|atxn
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Length of expansion buffer */
end_comment

begin_decl_stmt
name|char
name|atybuf
index|[
name|ATMBL
operator|+
literal|4
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* For copying atom buffer */
end_comment

begin_decl_stmt
name|char
name|savbuf
index|[
name|CMDBL
operator|+
literal|4
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Buffer to save copy of command */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DCMDBUF */
end_comment

begin_comment
comment|/* Command buffer pointers */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|bp
decl_stmt|,
comment|/* Current command buffer position */
modifier|*
name|pp
decl_stmt|,
comment|/* Start of current field */
modifier|*
name|np
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Start of next field */
end_comment

begin_decl_stmt
specifier|static
name|int
name|ungw
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* For ungetting words */
end_comment

begin_macro
name|_PROTOTYP
argument_list|(
argument|VOID addhlp
argument_list|,
argument|(char *)
argument_list|)
end_macro

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_macro
name|_PROTOTYP
argument_list|(
argument|VOID clrhlp
argument_list|,
argument|(void)
argument_list|)
end_macro

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_macro
name|_PROTOTYP
argument_list|(
argument|VOID dmphlp
argument_list|,
argument|(void)
argument_list|)
end_macro

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_macro
name|_PROTOTYP
argument_list|(
argument|int gtword
argument_list|,
argument|(void)
argument_list|)
end_macro

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_macro
name|_PROTOTYP
argument_list|(
argument|int addbuf
argument_list|,
argument|(char *)
argument_list|)
end_macro

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_macro
name|_PROTOTYP
argument_list|(
argument|int setatm
argument_list|,
argument|(char *)
argument_list|)
end_macro

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_macro
name|_PROTOTYP
argument_list|(
argument|int cmdgetc
argument_list|,
argument|(void)
argument_list|)
end_macro

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_macro
name|_PROTOTYP
argument_list|(
argument|VOID cmdnewl
argument_list|,
argument|(char)
argument_list|)
end_macro

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_macro
name|_PROTOTYP
argument_list|(
argument|VOID cmdchardel
argument_list|,
argument|(void)
argument_list|)
end_macro

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_macro
name|_PROTOTYP
argument_list|(
argument|VOID cmdecho
argument_list|,
argument|(char, int)
argument_list|)
end_macro

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_macro
name|_PROTOTYP
argument_list|(
argument|static int test
argument_list|,
argument|(int, int)
argument_list|)
end_macro

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|GEMDOS
end_ifdef

begin_expr_stmt
name|_PROTOTYP
argument_list|(
specifier|extern
name|char
operator|*
name|strchr
argument_list|,
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* GEMDOS */
end_comment

begin_comment
comment|/*  T E S T  --  Bit test  */
end_comment

begin_function
specifier|static
name|int
name|test
parameter_list|(
name|x
parameter_list|,
name|m
parameter_list|)
name|int
name|x
decl_stmt|,
name|m
decl_stmt|;
block|{
comment|/*  Returns 1 if any bits from m are on in x, else 0  */
return|return
operator|(
operator|(
name|x
operator|&
name|m
operator|)
condition|?
literal|1
else|:
literal|0
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  C M S E T U P  --  Set up command buffers  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|DCMDBUF
end_ifdef

begin_function
name|int
name|cmsetup
parameter_list|()
block|{
if|if
condition|(
operator|!
operator|(
name|cmdbuf
operator|=
name|malloc
argument_list|(
name|CMDBL
operator|+
literal|4
argument_list|)
operator|)
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
operator|!
operator|(
name|savbuf
operator|=
name|malloc
argument_list|(
name|CMDBL
operator|+
literal|4
argument_list|)
operator|)
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|savbuf
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|hlpbuf
operator|=
name|malloc
argument_list|(
name|HLPBL
operator|+
literal|4
argument_list|)
operator|)
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
operator|!
operator|(
name|atmbuf
operator|=
name|malloc
argument_list|(
name|ATMBL
operator|+
literal|4
argument_list|)
operator|)
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
operator|!
operator|(
name|atxbuf
operator|=
name|malloc
argument_list|(
name|CMDBL
operator|+
literal|4
argument_list|)
operator|)
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
operator|!
operator|(
name|atybuf
operator|=
name|malloc
argument_list|(
name|ATMBL
operator|+
literal|4
argument_list|)
operator|)
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
operator|!
operator|(
name|filbuf
operator|=
name|malloc
argument_list|(
name|ATMBL
operator|+
literal|4
argument_list|)
operator|)
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DCMDBUF */
end_comment

begin_comment
comment|/*  C M S E T P  --  Set the program prompt.  */
end_comment

begin_function
name|VOID
name|cmsetp
parameter_list|(
name|s
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
block|{
name|strncpy
argument_list|(
name|cmprxx
argument_list|,
name|s
argument_list|,
name|PROML
operator|-
literal|1
argument_list|)
expr_stmt|;
name|cmprxx
index|[
name|PROML
index|]
operator|=
name|NUL
expr_stmt|;
name|psetf
operator|=
literal|1
expr_stmt|;
comment|/* Flag that prompt has been set. */
block|}
end_function

begin_comment
comment|/*  C M S A V P  --  Save a copy of the current prompt.  */
end_comment

begin_function
name|VOID
ifdef|#
directive|ifdef
name|CK_ANSIC
name|cmsavp
parameter_list|(
name|char
name|s
index|[]
parameter_list|,
name|int
name|n
parameter_list|)
else|#
directive|else
function|cmsavp
parameter_list|(
name|s
parameter_list|,
name|n
parameter_list|)
name|char
name|s
index|[]
decl_stmt|;
name|int
name|n
decl_stmt|;
endif|#
directive|endif
comment|/* CK_ANSIC */
comment|/* cmsavp */
block|{
name|strncpy
argument_list|(
name|s
argument_list|,
name|cmprxx
argument_list|,
name|n
operator|-
literal|1
argument_list|)
expr_stmt|;
name|s
index|[
name|n
operator|-
literal|1
index|]
operator|=
name|NUL
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  P R O M P T  --  Issue the program prompt.  */
end_comment

begin_function
name|VOID
name|prompt
parameter_list|(
name|f
parameter_list|)
name|xx_strp
name|f
decl_stmt|;
block|{
name|char
modifier|*
name|sx
decl_stmt|,
modifier|*
name|sy
decl_stmt|;
name|int
name|n
decl_stmt|;
if|if
condition|(
name|psetf
operator|==
literal|0
condition|)
name|cmsetp
argument_list|(
name|dfprom
argument_list|)
expr_stmt|;
comment|/* If no prompt set, set default. */
name|sx
operator|=
name|cmprxx
expr_stmt|;
comment|/* Unevaluated copy */
if|if
condition|(
name|f
condition|)
block|{
comment|/* If conversion function given */
name|sy
operator|=
name|cmprom
expr_stmt|;
comment|/* Evaluate it */
name|n
operator|=
name|PROML
expr_stmt|;
if|if
condition|(
call|(
modifier|*
name|f
call|)
argument_list|(
name|sx
argument_list|,
operator|&
name|sy
argument_list|,
operator|&
name|n
argument_list|)
operator|<
literal|0
condition|)
comment|/* If evaluation failed */
name|sx
operator|=
name|cmprxx
expr_stmt|;
comment|/* revert to unevaluated copy */
else|else
name|sx
operator|=
name|cmprom
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|OSK
name|fputs
argument_list|(
name|sx
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
else|#
directive|else
ifdef|#
directive|ifdef
name|MAC
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|sx
argument_list|)
expr_stmt|;
else|#
directive|else
name|printf
argument_list|(
literal|"\r%s"
argument_list|,
name|sx
argument_list|)
expr_stmt|;
comment|/* Print the prompt. */
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
comment|/* Now! */
endif|#
directive|endif
comment|/* MAC */
endif|#
directive|endif
comment|/* OSK */
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|NOSPL
end_ifndef

begin_function
name|VOID
name|pushcmd
parameter_list|()
block|{
comment|/* For use with IF command. */
name|strcpy
argument_list|(
name|savbuf
argument_list|,
name|np
argument_list|)
expr_stmt|;
comment|/* Save the dependent clause,  */
name|cmres
argument_list|()
expr_stmt|;
comment|/* and clear the command buffer. */
name|debug
argument_list|(
name|F110
argument_list|,
literal|"pushcmd: savbuf:"
argument_list|,
name|savbuf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NOSPL */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|COMMENT
end_ifdef

begin_comment
comment|/* no longer used... */
end_comment

begin_function
name|VOID
name|popcmd
parameter_list|()
block|{
name|strcpy
argument_list|(
name|cmdbuf
argument_list|,
name|savbuf
argument_list|)
expr_stmt|;
comment|/* Put back the saved material */
operator|*
name|savbuf
operator|=
literal|'\0'
expr_stmt|;
comment|/* and clear the save buffer */
name|cmres
argument_list|()
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* COMMENT */
end_comment

begin_comment
comment|/*  C M R E S  --  Reset pointers to beginning of command buffer.  */
end_comment

begin_function
name|VOID
name|cmres
parameter_list|()
block|{
name|inword
operator|=
name|cc
operator|=
literal|0
expr_stmt|;
comment|/* Reset character counter. */
name|pp
operator|=
name|np
operator|=
name|bp
operator|=
name|cmdbuf
expr_stmt|;
comment|/* Point to command buffer. */
name|cmflgs
operator|=
operator|-
literal|5
expr_stmt|;
comment|/* Parse not yet started. */
name|ungw
operator|=
literal|0
expr_stmt|;
comment|/* Don't need to unget a word. */
block|}
end_function

begin_comment
comment|/*  C M I N I  --  Clear the command and atom buffers, reset pointers.  */
end_comment

begin_comment
comment|/* The argument specifies who is to echo the user's typein --   1 means the cmd package echoes   0 somebody else (system, front end, terminal) echoes */
end_comment

begin_function
name|VOID
name|cmini
parameter_list|(
name|d
parameter_list|)
name|int
name|d
decl_stmt|;
block|{
for|for
control|(
name|bp
operator|=
name|cmdbuf
init|;
name|bp
operator|<
name|cmdbuf
operator|+
name|CMDBL
condition|;
name|bp
operator|++
control|)
operator|*
name|bp
operator|=
name|NUL
expr_stmt|;
operator|*
name|atmbuf
operator|=
name|NUL
expr_stmt|;
name|dpx
operator|=
name|d
expr_stmt|;
name|cmres
argument_list|()
expr_stmt|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|NOSPL
end_ifndef

begin_comment
comment|/* The following bits are to allow the command package to call itself */
end_comment

begin_comment
comment|/* in the middle of a parse.  To do this, begin by calling cmpush, and */
end_comment

begin_comment
comment|/* end by calling cmpop. */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|DCMDBUF
end_ifdef

begin_struct
struct|struct
name|cmp
block|{
name|int
name|i
index|[
literal|5
index|]
decl_stmt|;
comment|/* stack for integers */
name|char
modifier|*
name|c
index|[
literal|3
index|]
decl_stmt|;
comment|/* stack for pointers */
name|char
modifier|*
name|b
index|[
literal|8
index|]
decl_stmt|;
comment|/* stack for buffer contents */
block|}
struct|;
end_struct

begin_decl_stmt
name|struct
name|cmp
modifier|*
name|cmp
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_decl_stmt
name|int
name|cmp_i
index|[
name|CMDDEP
operator|+
literal|1
index|]
index|[
literal|5
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Stack for integers */
end_comment

begin_decl_stmt
name|char
modifier|*
name|cmp_c
index|[
name|CMDDEP
operator|+
literal|1
index|]
index|[
literal|5
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* for misc pointers */
end_comment

begin_decl_stmt
name|char
modifier|*
name|cmp_b
index|[
name|CMDDEP
operator|+
literal|1
index|]
index|[
literal|7
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* for buffer contents pointers */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DCMDBUF */
end_comment

begin_decl_stmt
name|int
name|cmddep
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Current stack depth */
end_comment

begin_function
name|int
name|cmpush
parameter_list|()
block|{
comment|/* Save the command environment */
name|char
modifier|*
name|cp
decl_stmt|;
comment|/* Character pointer */
if|if
condition|(
name|cmddep
operator|>=
name|CMDDEP
condition|)
comment|/* Enter a new command depth */
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|cmddep
operator|++
expr_stmt|;
name|debug
argument_list|(
name|F101
argument_list|,
literal|"&cmpush"
argument_list|,
literal|""
argument_list|,
name|cmddep
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DCMDBUF
comment|/* allocate memory for cmp if not already done */
if|if
condition|(
operator|!
name|cmp
operator|&&
operator|!
operator|(
name|cmp
operator|=
operator|(
expr|struct
name|cmp
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|cmp
argument_list|)
operator|*
operator|(
name|CMDDEP
operator|+
literal|1
operator|)
argument_list|)
operator|)
condition|)
name|fatal
argument_list|(
literal|"cmpush: no memory for cmp"
argument_list|)
expr_stmt|;
name|cmp
index|[
name|cmddep
index|]
operator|.
name|i
index|[
literal|0
index|]
operator|=
name|cmflgs
expr_stmt|;
comment|/* First do the global ints */
name|cmp
index|[
name|cmddep
index|]
operator|.
name|i
index|[
literal|1
index|]
operator|=
name|cmfsav
expr_stmt|;
name|cmp
index|[
name|cmddep
index|]
operator|.
name|i
index|[
literal|2
index|]
operator|=
name|atxn
expr_stmt|;
name|cmp
index|[
name|cmddep
index|]
operator|.
name|i
index|[
literal|3
index|]
operator|=
name|ungw
expr_stmt|;
name|cmp
index|[
name|cmddep
index|]
operator|.
name|c
index|[
literal|0
index|]
operator|=
name|bp
expr_stmt|;
comment|/* Then the global pointers */
name|cmp
index|[
name|cmddep
index|]
operator|.
name|c
index|[
literal|1
index|]
operator|=
name|pp
expr_stmt|;
name|cmp
index|[
name|cmddep
index|]
operator|.
name|c
index|[
literal|2
index|]
operator|=
name|np
expr_stmt|;
else|#
directive|else
name|cmp_i
index|[
name|cmddep
index|]
index|[
literal|0
index|]
operator|=
name|cmflgs
expr_stmt|;
comment|/* First do the global ints */
name|cmp_i
index|[
name|cmddep
index|]
index|[
literal|1
index|]
operator|=
name|cmfsav
expr_stmt|;
name|cmp_i
index|[
name|cmddep
index|]
index|[
literal|2
index|]
operator|=
name|atxn
expr_stmt|;
name|cmp_i
index|[
name|cmddep
index|]
index|[
literal|3
index|]
operator|=
name|ungw
expr_stmt|;
name|cmp_c
index|[
name|cmddep
index|]
index|[
literal|0
index|]
operator|=
name|bp
expr_stmt|;
comment|/* Then the global pointers */
name|cmp_c
index|[
name|cmddep
index|]
index|[
literal|1
index|]
operator|=
name|pp
expr_stmt|;
name|cmp_c
index|[
name|cmddep
index|]
index|[
literal|2
index|]
operator|=
name|np
expr_stmt|;
endif|#
directive|endif
comment|/* DCMDBUF */
comment|/* Now the buffers themselves.  A lot of repititious code... */
ifdef|#
directive|ifdef
name|DCMDBUF
name|cp
operator|=
name|malloc
argument_list|(
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|cmdbuf
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* 0: Command buffer */
if|if
condition|(
name|cp
condition|)
name|strcpy
argument_list|(
name|cp
argument_list|,
name|cmdbuf
argument_list|)
expr_stmt|;
name|cmp
index|[
name|cmddep
index|]
operator|.
name|b
index|[
literal|0
index|]
operator|=
name|cp
expr_stmt|;
if|if
condition|(
name|cp
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|cp
operator|=
name|malloc
argument_list|(
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|savbuf
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* 1: Save buffer */
if|if
condition|(
name|cp
condition|)
name|strcpy
argument_list|(
name|cp
argument_list|,
name|savbuf
argument_list|)
expr_stmt|;
name|cmp
index|[
name|cmddep
index|]
operator|.
name|b
index|[
literal|1
index|]
operator|=
name|cp
expr_stmt|;
if|if
condition|(
name|cp
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|cp
operator|=
name|malloc
argument_list|(
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|hlpbuf
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* 2: Help string buffer */
if|if
condition|(
name|cp
condition|)
name|strcpy
argument_list|(
name|cp
argument_list|,
name|hlpbuf
argument_list|)
expr_stmt|;
name|cmp
index|[
name|cmddep
index|]
operator|.
name|b
index|[
literal|2
index|]
operator|=
name|cp
expr_stmt|;
if|if
condition|(
name|cp
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|cp
operator|=
name|malloc
argument_list|(
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|atmbuf
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* 3: Atom buffer */
if|if
condition|(
name|cp
condition|)
name|strcpy
argument_list|(
name|cp
argument_list|,
name|atmbuf
argument_list|)
expr_stmt|;
name|cmp
index|[
name|cmddep
index|]
operator|.
name|b
index|[
literal|3
index|]
operator|=
name|cp
expr_stmt|;
if|if
condition|(
name|cp
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|cp
operator|=
name|malloc
argument_list|(
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|atxbuf
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* 4: Expansion buffer */
if|if
condition|(
name|cp
condition|)
name|strcpy
argument_list|(
name|cp
argument_list|,
name|atxbuf
argument_list|)
expr_stmt|;
name|cmp
index|[
name|cmddep
index|]
operator|.
name|b
index|[
literal|4
index|]
operator|=
name|cp
expr_stmt|;
if|if
condition|(
name|cp
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|cp
operator|=
name|malloc
argument_list|(
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|atybuf
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* 5: Atom buffer copy */
if|if
condition|(
name|cp
condition|)
name|strcpy
argument_list|(
name|cp
argument_list|,
name|atybuf
argument_list|)
expr_stmt|;
name|cmp
index|[
name|cmddep
index|]
operator|.
name|b
index|[
literal|5
index|]
operator|=
name|cp
expr_stmt|;
if|if
condition|(
name|cp
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|cp
operator|=
name|malloc
argument_list|(
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|filbuf
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* 6: File name buffer */
if|if
condition|(
name|cp
condition|)
name|strcpy
argument_list|(
name|cp
argument_list|,
name|filbuf
argument_list|)
expr_stmt|;
name|cmp
index|[
name|cmddep
index|]
operator|.
name|b
index|[
literal|6
index|]
operator|=
name|cp
expr_stmt|;
if|if
condition|(
name|cp
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
else|#
directive|else
name|cp
operator|=
name|malloc
argument_list|(
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|cmdbuf
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* 0: Command buffer */
if|if
condition|(
name|cp
condition|)
name|strcpy
argument_list|(
name|cp
argument_list|,
name|cmdbuf
argument_list|)
expr_stmt|;
name|cmp_b
index|[
name|cmddep
index|]
index|[
literal|0
index|]
operator|=
name|cp
expr_stmt|;
if|if
condition|(
name|cp
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|cp
operator|=
name|malloc
argument_list|(
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|savbuf
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* 1: Save buffer */
if|if
condition|(
name|cp
condition|)
name|strcpy
argument_list|(
name|cp
argument_list|,
name|savbuf
argument_list|)
expr_stmt|;
name|cmp_b
index|[
name|cmddep
index|]
index|[
literal|1
index|]
operator|=
name|cp
expr_stmt|;
if|if
condition|(
name|cp
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|cp
operator|=
name|malloc
argument_list|(
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|hlpbuf
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* 2: Help string buffer */
if|if
condition|(
name|cp
condition|)
name|strcpy
argument_list|(
name|cp
argument_list|,
name|hlpbuf
argument_list|)
expr_stmt|;
name|cmp_b
index|[
name|cmddep
index|]
index|[
literal|2
index|]
operator|=
name|cp
expr_stmt|;
if|if
condition|(
name|cp
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|cp
operator|=
name|malloc
argument_list|(
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|atmbuf
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* 3: Atom buffer */
if|if
condition|(
name|cp
condition|)
name|strcpy
argument_list|(
name|cp
argument_list|,
name|atmbuf
argument_list|)
expr_stmt|;
name|cmp_b
index|[
name|cmddep
index|]
index|[
literal|3
index|]
operator|=
name|cp
expr_stmt|;
if|if
condition|(
name|cp
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|cp
operator|=
name|malloc
argument_list|(
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|atxbuf
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* 4: Expansion buffer */
if|if
condition|(
name|cp
condition|)
name|strcpy
argument_list|(
name|cp
argument_list|,
name|atxbuf
argument_list|)
expr_stmt|;
name|cmp_b
index|[
name|cmddep
index|]
index|[
literal|4
index|]
operator|=
name|cp
expr_stmt|;
if|if
condition|(
name|cp
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|cp
operator|=
name|malloc
argument_list|(
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|atybuf
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* 5: Atom buffer copy */
if|if
condition|(
name|cp
condition|)
name|strcpy
argument_list|(
name|cp
argument_list|,
name|atybuf
argument_list|)
expr_stmt|;
name|cmp_b
index|[
name|cmddep
index|]
index|[
literal|5
index|]
operator|=
name|cp
expr_stmt|;
if|if
condition|(
name|cp
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|cp
operator|=
name|malloc
argument_list|(
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|filbuf
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* 6: File name buffer */
if|if
condition|(
name|cp
condition|)
name|strcpy
argument_list|(
name|cp
argument_list|,
name|filbuf
argument_list|)
expr_stmt|;
name|cmp_b
index|[
name|cmddep
index|]
index|[
literal|6
index|]
operator|=
name|cp
expr_stmt|;
if|if
condition|(
name|cp
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
endif|#
directive|endif
comment|/* DCMDBUF */
name|cmini
argument_list|(
name|dpx
argument_list|)
expr_stmt|;
comment|/* Initize the command parser */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|cmpop
parameter_list|()
block|{
comment|/* Restore the command environment */
name|debug
argument_list|(
name|F101
argument_list|,
literal|"&cmpop"
argument_list|,
literal|""
argument_list|,
name|cmddep
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmddep
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* Don't pop too much! */
ifdef|#
directive|ifdef
name|DCMDBUF
name|cmflgs
operator|=
name|cmp
index|[
name|cmddep
index|]
operator|.
name|i
index|[
literal|0
index|]
expr_stmt|;
comment|/* First do the global ints */
name|cmfsav
operator|=
name|cmp
index|[
name|cmddep
index|]
operator|.
name|i
index|[
literal|1
index|]
expr_stmt|;
name|atxn
operator|=
name|cmp
index|[
name|cmddep
index|]
operator|.
name|i
index|[
literal|2
index|]
expr_stmt|;
name|ungw
operator|=
name|cmp
index|[
name|cmddep
index|]
operator|.
name|i
index|[
literal|3
index|]
expr_stmt|;
name|bp
operator|=
name|cmp
index|[
name|cmddep
index|]
operator|.
name|c
index|[
literal|0
index|]
expr_stmt|;
comment|/* Then the global pointers */
name|pp
operator|=
name|cmp
index|[
name|cmddep
index|]
operator|.
name|c
index|[
literal|1
index|]
expr_stmt|;
name|np
operator|=
name|cmp
index|[
name|cmddep
index|]
operator|.
name|c
index|[
literal|2
index|]
expr_stmt|;
else|#
directive|else
name|cmflgs
operator|=
name|cmp_i
index|[
name|cmddep
index|]
index|[
literal|0
index|]
expr_stmt|;
comment|/* First do the global ints */
name|cmfsav
operator|=
name|cmp_i
index|[
name|cmddep
index|]
index|[
literal|1
index|]
expr_stmt|;
name|atxn
operator|=
name|cmp_i
index|[
name|cmddep
index|]
index|[
literal|2
index|]
expr_stmt|;
name|ungw
operator|=
name|cmp_i
index|[
name|cmddep
index|]
index|[
literal|3
index|]
expr_stmt|;
name|bp
operator|=
name|cmp_c
index|[
name|cmddep
index|]
index|[
literal|0
index|]
expr_stmt|;
comment|/* Then the global pointers */
name|pp
operator|=
name|cmp_c
index|[
name|cmddep
index|]
index|[
literal|1
index|]
expr_stmt|;
name|np
operator|=
name|cmp_c
index|[
name|cmddep
index|]
index|[
literal|2
index|]
expr_stmt|;
endif|#
directive|endif
comment|/* DCMDBUF */
comment|/* Now the buffers themselves. */
ifdef|#
directive|ifdef
name|DCMDBUF
if|if
condition|(
name|cmp
index|[
name|cmddep
index|]
operator|.
name|b
index|[
literal|0
index|]
condition|)
block|{
name|strcpy
argument_list|(
name|cmdbuf
argument_list|,
name|cmp
index|[
name|cmddep
index|]
operator|.
name|b
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
comment|/* 0: Command buffer */
name|free
argument_list|(
name|cmp
index|[
name|cmddep
index|]
operator|.
name|b
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|cmp
index|[
name|cmddep
index|]
operator|.
name|b
index|[
literal|0
index|]
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|cmp
index|[
name|cmddep
index|]
operator|.
name|b
index|[
literal|1
index|]
condition|)
block|{
name|strcpy
argument_list|(
name|savbuf
argument_list|,
name|cmp
index|[
name|cmddep
index|]
operator|.
name|b
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
comment|/* 1: Save buffer */
name|free
argument_list|(
name|cmp
index|[
name|cmddep
index|]
operator|.
name|b
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|cmp
index|[
name|cmddep
index|]
operator|.
name|b
index|[
literal|1
index|]
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|cmp
index|[
name|cmddep
index|]
operator|.
name|b
index|[
literal|2
index|]
condition|)
block|{
name|strcpy
argument_list|(
name|hlpbuf
argument_list|,
name|cmp
index|[
name|cmddep
index|]
operator|.
name|b
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
comment|/* 2: Help buffer */
name|free
argument_list|(
name|cmp
index|[
name|cmddep
index|]
operator|.
name|b
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|cmp
index|[
name|cmddep
index|]
operator|.
name|b
index|[
literal|2
index|]
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|cmp
index|[
name|cmddep
index|]
operator|.
name|b
index|[
literal|3
index|]
condition|)
block|{
name|strcpy
argument_list|(
name|atmbuf
argument_list|,
name|cmp
index|[
name|cmddep
index|]
operator|.
name|b
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
comment|/* 3: Atomic buffer! */
name|free
argument_list|(
name|cmp
index|[
name|cmddep
index|]
operator|.
name|b
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
name|cmp
index|[
name|cmddep
index|]
operator|.
name|b
index|[
literal|3
index|]
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|cmp
index|[
name|cmddep
index|]
operator|.
name|b
index|[
literal|4
index|]
condition|)
block|{
name|strcpy
argument_list|(
name|atxbuf
argument_list|,
name|cmp
index|[
name|cmddep
index|]
operator|.
name|b
index|[
literal|4
index|]
argument_list|)
expr_stmt|;
comment|/* 4: eXpansion buffer */
name|free
argument_list|(
name|cmp
index|[
name|cmddep
index|]
operator|.
name|b
index|[
literal|4
index|]
argument_list|)
expr_stmt|;
name|cmp
index|[
name|cmddep
index|]
operator|.
name|b
index|[
literal|4
index|]
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|cmp
index|[
name|cmddep
index|]
operator|.
name|b
index|[
literal|5
index|]
condition|)
block|{
name|strcpy
argument_list|(
name|atybuf
argument_list|,
name|cmp
index|[
name|cmddep
index|]
operator|.
name|b
index|[
literal|5
index|]
argument_list|)
expr_stmt|;
comment|/* 5: Atom buffer copY */
name|free
argument_list|(
name|cmp
index|[
name|cmddep
index|]
operator|.
name|b
index|[
literal|5
index|]
argument_list|)
expr_stmt|;
name|cmp
index|[
name|cmddep
index|]
operator|.
name|b
index|[
literal|5
index|]
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|cmp
index|[
name|cmddep
index|]
operator|.
name|b
index|[
literal|6
index|]
condition|)
block|{
name|strcpy
argument_list|(
name|filbuf
argument_list|,
name|cmp
index|[
name|cmddep
index|]
operator|.
name|b
index|[
literal|6
index|]
argument_list|)
expr_stmt|;
comment|/* 6: Filename buffer */
name|free
argument_list|(
name|cmp
index|[
name|cmddep
index|]
operator|.
name|b
index|[
literal|6
index|]
argument_list|)
expr_stmt|;
name|cmp
index|[
name|cmddep
index|]
operator|.
name|b
index|[
literal|6
index|]
operator|=
name|NULL
expr_stmt|;
block|}
else|#
directive|else
if|if
condition|(
name|cmp_b
index|[
name|cmddep
index|]
index|[
literal|0
index|]
condition|)
block|{
name|strcpy
argument_list|(
name|cmdbuf
argument_list|,
name|cmp_b
index|[
name|cmddep
index|]
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
comment|/* 0: Command buffer */
name|free
argument_list|(
name|cmp_b
index|[
name|cmddep
index|]
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|cmp_b
index|[
name|cmddep
index|]
index|[
literal|0
index|]
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|cmp_b
index|[
name|cmddep
index|]
index|[
literal|1
index|]
condition|)
block|{
name|strcpy
argument_list|(
name|savbuf
argument_list|,
name|cmp_b
index|[
name|cmddep
index|]
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
comment|/* 1: Save buffer */
name|free
argument_list|(
name|cmp_b
index|[
name|cmddep
index|]
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|cmp_b
index|[
name|cmddep
index|]
index|[
literal|1
index|]
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|cmp_b
index|[
name|cmddep
index|]
index|[
literal|2
index|]
condition|)
block|{
name|strcpy
argument_list|(
name|hlpbuf
argument_list|,
name|cmp_b
index|[
name|cmddep
index|]
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
comment|/* 2: Help buffer */
name|free
argument_list|(
name|cmp_b
index|[
name|cmddep
index|]
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|cmp_b
index|[
name|cmddep
index|]
index|[
literal|2
index|]
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|cmp_b
index|[
name|cmddep
index|]
index|[
literal|3
index|]
condition|)
block|{
name|strcpy
argument_list|(
name|atmbuf
argument_list|,
name|cmp_b
index|[
name|cmddep
index|]
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
comment|/* 3: Atomic buffer! */
name|free
argument_list|(
name|cmp_b
index|[
name|cmddep
index|]
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
name|cmp_b
index|[
name|cmddep
index|]
index|[
literal|3
index|]
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|cmp_b
index|[
name|cmddep
index|]
index|[
literal|4
index|]
condition|)
block|{
name|strcpy
argument_list|(
name|atxbuf
argument_list|,
name|cmp_b
index|[
name|cmddep
index|]
index|[
literal|4
index|]
argument_list|)
expr_stmt|;
comment|/* 4: eXpansion buffer */
name|free
argument_list|(
name|cmp_b
index|[
name|cmddep
index|]
index|[
literal|4
index|]
argument_list|)
expr_stmt|;
name|cmp_b
index|[
name|cmddep
index|]
index|[
literal|4
index|]
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|cmp_b
index|[
name|cmddep
index|]
index|[
literal|5
index|]
condition|)
block|{
name|strcpy
argument_list|(
name|atybuf
argument_list|,
name|cmp_b
index|[
name|cmddep
index|]
index|[
literal|5
index|]
argument_list|)
expr_stmt|;
comment|/* 5: Atom buffer copY */
name|free
argument_list|(
name|cmp_b
index|[
name|cmddep
index|]
index|[
literal|5
index|]
argument_list|)
expr_stmt|;
name|cmp_b
index|[
name|cmddep
index|]
index|[
literal|5
index|]
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|cmp_b
index|[
name|cmddep
index|]
index|[
literal|6
index|]
condition|)
block|{
name|strcpy
argument_list|(
name|filbuf
argument_list|,
name|cmp_b
index|[
name|cmddep
index|]
index|[
literal|6
index|]
argument_list|)
expr_stmt|;
comment|/* 6: Filename buffer */
name|free
argument_list|(
name|cmp_b
index|[
name|cmddep
index|]
index|[
literal|6
index|]
argument_list|)
expr_stmt|;
name|cmp_b
index|[
name|cmddep
index|]
index|[
literal|6
index|]
operator|=
name|NULL
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* DCMDBUF */
name|cmddep
operator|--
expr_stmt|;
comment|/* Rise, rise */
name|debug
argument_list|(
name|F101
argument_list|,
literal|"&cmpop"
argument_list|,
literal|""
argument_list|,
name|cmddep
argument_list|)
expr_stmt|;
return|return
operator|(
name|cmddep
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NOSPL */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|COMMENT
end_ifdef

begin_function
name|VOID
name|stripq
parameter_list|(
name|s
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
block|{
comment|/* Function to strip '\' quotes */
name|char
modifier|*
name|t
decl_stmt|;
while|while
condition|(
operator|*
name|s
condition|)
block|{
if|if
condition|(
operator|*
name|s
operator|==
name|CMDQ
condition|)
block|{
for|for
control|(
name|t
operator|=
name|s
init|;
operator|*
name|t
operator|!=
literal|'\0'
condition|;
name|t
operator|++
control|)
operator|*
name|t
operator|=
operator|*
operator|(
name|t
operator|+
literal|1
operator|)
expr_stmt|;
block|}
name|s
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* COMMENT */
end_comment

begin_comment
comment|/* Convert tabs to spaces, one for one */
end_comment

begin_function
name|VOID
name|untab
parameter_list|(
name|s
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
block|{
while|while
condition|(
operator|*
name|s
condition|)
block|{
if|if
condition|(
operator|*
name|s
operator|==
name|HT
condition|)
operator|*
name|s
operator|=
name|SP
expr_stmt|;
name|s
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  C M N U M  --  Parse a number in the indicated radix  */
end_comment

begin_comment
comment|/*   The only radix allowed in unquoted numbers is 10.  Parses unquoted numeric strings in base 10.  Parses backslash-quoted numbers in the radix indicated by the quote:    \nnn = \dnnn = decimal, \onnn = octal, \xnn = Hexadecimal.  If these fail, then if a preprocessing function is supplied, that is applied   and then a second attempt is made to parse an unquoted decimal string.    Returns:    -3 if no input present when required,    -2 if user typed an illegal number,    -1 if reparse needed,     0 otherwise, with argument n set to the number that was parsed */
end_comment

begin_function
name|int
name|cmnum
parameter_list|(
name|xhlp
parameter_list|,
name|xdef
parameter_list|,
name|radix
parameter_list|,
name|n
parameter_list|,
name|f
parameter_list|)
name|char
modifier|*
name|xhlp
decl_stmt|,
decl|*
name|xdef
decl_stmt|;
end_function

begin_decl_stmt
name|int
name|radix
decl_stmt|,
modifier|*
name|n
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|xx_strp
name|f
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|x
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|,
modifier|*
name|zp
decl_stmt|,
modifier|*
name|zq
decl_stmt|;
if|if
condition|(
name|radix
operator|!=
literal|10
condition|)
block|{
comment|/* Just do base 10 */
name|printf
argument_list|(
literal|"cmnum: illegal radix - %d\n"
argument_list|,
name|radix
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|x
operator|=
name|cmfld
argument_list|(
name|xhlp
argument_list|,
name|xdef
argument_list|,
operator|&
name|s
argument_list|,
operator|(
name|xx_strp
operator|)
literal|0
argument_list|)
expr_stmt|;
name|debug
argument_list|(
name|F101
argument_list|,
literal|"cmnum: cmfld"
argument_list|,
literal|""
argument_list|,
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|<
literal|0
condition|)
return|return
operator|(
name|x
operator|)
return|;
comment|/* Parse a field */
name|zp
operator|=
name|atmbuf
expr_stmt|;
if|if
condition|(
name|chknum
argument_list|(
name|zp
argument_list|)
condition|)
block|{
comment|/* Check for decimal number */
operator|*
name|n
operator|=
name|atoi
argument_list|(
name|zp
argument_list|)
expr_stmt|;
comment|/* Got one, we're done. */
name|debug
argument_list|(
name|F101
argument_list|,
literal|"cmnum 1st chknum ok"
argument_list|,
literal|""
argument_list|,
operator|*
name|n
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
elseif|else
if|if
condition|(
operator|(
name|x
operator|=
name|xxesc
argument_list|(
operator|&
name|zp
argument_list|)
operator|)
operator|>
operator|-
literal|1
condition|)
block|{
comment|/* Check for backslash escape */
ifndef|#
directive|ifndef
name|OS2
operator|*
name|n
operator|=
name|x
expr_stmt|;
else|#
directive|else
operator|*
name|n
operator|=
name|wideresult
expr_stmt|;
endif|#
directive|endif
comment|/* OS2 */
name|debug
argument_list|(
name|F101
argument_list|,
literal|"cmnum xxesc ok"
argument_list|,
literal|""
argument_list|,
operator|*
name|n
argument_list|)
expr_stmt|;
return|return
operator|(
operator|*
name|zp
condition|?
operator|-
literal|2
else|:
literal|0
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|f
condition|)
block|{
comment|/* If conversion function given */
name|zp
operator|=
name|atmbuf
expr_stmt|;
comment|/* Try that */
name|zq
operator|=
name|atxbuf
expr_stmt|;
name|atxn
operator|=
name|CMDBL
expr_stmt|;
call|(
modifier|*
name|f
call|)
argument_list|(
name|zp
argument_list|,
operator|&
name|zq
argument_list|,
operator|&
name|atxn
argument_list|)
expr_stmt|;
comment|/* Convert */
name|zp
operator|=
name|atxbuf
expr_stmt|;
block|}
name|debug
argument_list|(
name|F110
argument_list|,
literal|"cmnum zp"
argument_list|,
name|zp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|chknum
argument_list|(
name|zp
argument_list|)
condition|)
block|{
comment|/* Check again for decimal number */
operator|*
name|n
operator|=
name|atoi
argument_list|(
name|zp
argument_list|)
expr_stmt|;
comment|/* Got one, we're done. */
name|debug
argument_list|(
name|F101
argument_list|,
literal|"cmnum 2nd chknum ok"
argument_list|,
literal|""
argument_list|,
operator|*
name|n
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
else|else
block|{
comment|/* Not numeric */
return|return
operator|(
operator|-
literal|2
operator|)
return|;
block|}
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/*  C M O F I  --  Parse the name of an output file  */
end_comment

begin_comment
comment|/*  Depends on the external function zchko(); if zchko() not available, use  cmfld() to parse output file names.    Returns    -3 if no input present when required,    -2 if permission would be denied to create the file,    -1 if reparse needed,     0 or 1 otherwise, with xp pointing to name. */
end_comment

begin_function
name|int
name|cmofi
parameter_list|(
name|xhlp
parameter_list|,
name|xdef
parameter_list|,
name|xp
parameter_list|,
name|f
parameter_list|)
name|char
modifier|*
name|xhlp
decl_stmt|,
decl|*
name|xdef
decl_stmt|,
modifier|*
modifier|*
name|xp
decl_stmt|;
end_function

begin_decl_stmt
name|xx_strp
name|f
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|x
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|,
modifier|*
name|zq
decl_stmt|;
ifdef|#
directive|ifdef
name|DTILDE
name|_PROTOTYP
argument_list|(
name|char
operator|*
name|tilde_expand
argument_list|,
operator|(
name|char
operator|*
operator|)
argument_list|)
expr_stmt|;
name|char
modifier|*
name|dirp
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|*
name|xhlp
operator|==
name|NUL
condition|)
name|xhlp
operator|=
literal|"Output file"
expr_stmt|;
operator|*
name|xp
operator|=
literal|""
expr_stmt|;
if|if
condition|(
operator|(
name|x
operator|=
name|cmfld
argument_list|(
name|xhlp
argument_list|,
name|xdef
argument_list|,
operator|&
name|s
argument_list|,
operator|(
name|xx_strp
operator|)
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|x
operator|)
return|;
if|if
condition|(
name|f
condition|)
block|{
comment|/* If a conversion function is given */
name|zq
operator|=
name|atxbuf
expr_stmt|;
name|atxn
operator|=
name|CMDBL
expr_stmt|;
if|if
condition|(
operator|(
name|x
operator|=
call|(
modifier|*
name|f
call|)
argument_list|(
name|s
argument_list|,
operator|&
name|zq
argument_list|,
operator|&
name|atxn
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|2
operator|)
return|;
name|s
operator|=
name|atxbuf
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DTILDE
name|dirp
operator|=
name|tilde_expand
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* Expand tilde, if any, */
if|if
condition|(
operator|*
name|dirp
operator|!=
literal|'\0'
condition|)
name|setatm
argument_list|(
name|dirp
argument_list|)
expr_stmt|;
comment|/* right in the atom buffer. */
name|s
operator|=
name|atmbuf
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|iswild
argument_list|(
name|s
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"?Wildcards not allowed - %s\n"
argument_list|,
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|2
operator|)
return|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|s
argument_list|,
name|CTTNAM
argument_list|)
operator|&&
operator|(
name|zchko
argument_list|(
name|s
argument_list|)
operator|<
literal|0
operator|)
condition|)
block|{
comment|/* ok to write to tty */
name|printf
argument_list|(
literal|"?Write permission denied - %s\n"
argument_list|,
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|9
operator|)
return|;
block|}
else|else
block|{
operator|*
name|xp
operator|=
name|s
expr_stmt|;
return|return
operator|(
name|x
operator|)
return|;
block|}
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/*  C M I F I  --  Parse the name of an existing file  */
end_comment

begin_comment
comment|/*  This function depends on the external functions:    zchki()  - Check if input file exists and is readable.    zxpand() - Expand a wild file specification into a list.    znext()  - Return next file name from list.  If these functions aren't available, then use cmfld() to parse filenames. */
end_comment

begin_comment
comment|/*  Returns    -4 EOF    -3 if no input present when required,    -2 if file does not exist or is not readable,    -1 if reparse needed,     0 or 1 otherwise, with:         xp pointing to name,         wild = 1 if name contains '*' or '?', 0 otherwise. */
end_comment

begin_function
name|int
name|cmifi
parameter_list|(
name|xhlp
parameter_list|,
name|xdef
parameter_list|,
name|xp
parameter_list|,
name|wild
parameter_list|,
name|f
parameter_list|)
name|char
modifier|*
name|xhlp
decl_stmt|,
decl|*
name|xdef
decl_stmt|,
modifier|*
modifier|*
name|xp
decl_stmt|;
end_function

begin_decl_stmt
name|int
modifier|*
name|wild
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|xx_strp
name|f
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|i
decl_stmt|,
name|x
decl_stmt|,
name|xc
decl_stmt|;
name|long
name|y
decl_stmt|;
name|char
modifier|*
name|sp
decl_stmt|,
modifier|*
name|zq
decl_stmt|,
modifier|*
name|sv
decl_stmt|;
ifdef|#
directive|ifdef
name|DTILDE
name|char
modifier|*
name|tilde_expand
argument_list|()
decl_stmt|,
modifier|*
name|dirp
decl_stmt|;
endif|#
directive|endif
comment|/* DTILDE */
ifndef|#
directive|ifndef
name|NOPARTIAL
specifier|extern
name|char
modifier|*
name|mtchs
index|[]
decl_stmt|;
endif|#
directive|endif
comment|/* NOPARTIAL */
name|inword
operator|=
name|cc
operator|=
name|xc
operator|=
literal|0
expr_stmt|;
comment|/* Initialize counts& pointers */
operator|*
name|xp
operator|=
literal|""
expr_stmt|;
if|if
condition|(
operator|(
name|x
operator|=
name|cmflgs
operator|)
operator|!=
literal|1
condition|)
block|{
comment|/* Already confirmed? */
name|x
operator|=
name|gtword
argument_list|()
expr_stmt|;
comment|/* No, get a word */
block|}
else|else
block|{
name|setatm
argument_list|(
name|xdef
argument_list|)
expr_stmt|;
comment|/* If so, use default, if any. */
block|}
operator|*
name|xp
operator|=
name|atmbuf
expr_stmt|;
comment|/* Point to result. */
while|while
condition|(
literal|1
condition|)
block|{
name|xc
operator|+=
name|cc
expr_stmt|;
comment|/* Count the characters. */
name|debug
argument_list|(
name|F111
argument_list|,
literal|"cmifi gtword"
argument_list|,
name|atmbuf
argument_list|,
name|xc
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|x
condition|)
block|{
case|case
operator|-
literal|4
case|:
comment|/* EOF */
case|case
operator|-
literal|2
case|:
comment|/* Out of space. */
case|case
operator|-
literal|1
case|:
comment|/* Reparse needed */
return|return
operator|(
name|x
operator|)
return|;
case|case
literal|0
case|:
comment|/* SP or NL */
case|case
literal|1
case|:
if|if
condition|(
name|xc
operator|==
literal|0
condition|)
operator|*
name|xp
operator|=
name|xdef
expr_stmt|;
comment|/* If no input, return default. */
if|if
condition|(
operator|*
operator|*
name|xp
operator|==
name|NUL
condition|)
return|return
operator|(
operator|-
literal|3
operator|)
return|;
comment|/* If field empty, return -3. */
if|if
condition|(
name|f
condition|)
block|{
comment|/* If a conversion function is given */
name|zq
operator|=
name|atxbuf
expr_stmt|;
comment|/* ... */
name|atxn
operator|=
name|CMDBL
expr_stmt|;
if|if
condition|(
operator|(
name|x
operator|=
call|(
modifier|*
name|f
call|)
argument_list|(
operator|*
name|xp
argument_list|,
operator|&
name|zq
argument_list|,
operator|&
name|atxn
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|2
operator|)
return|;
operator|*
name|xp
operator|=
name|atxbuf
expr_stmt|;
block|}
name|debug
argument_list|(
name|F110
argument_list|,
literal|"cmifi atxbuf"
argument_list|,
name|atxbuf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|COMMENT
comment|/* don't need this stuff, zxpand does it now. */
ifdef|#
directive|ifdef
name|DTILDE
name|dirp
operator|=
name|tilde_expand
argument_list|(
operator|*
name|xp
argument_list|)
expr_stmt|;
comment|/* Expand tilde, if any, */
if|if
condition|(
operator|*
name|dirp
operator|!=
literal|'\0'
condition|)
name|setatm
argument_list|(
name|dirp
argument_list|)
expr_stmt|;
comment|/* right in atom buffer. */
operator|*
name|xp
operator|=
name|atmbuf
expr_stmt|;
endif|#
directive|endif
comment|/* DTILDE */
comment|/* If filespec is wild, see if there are any matches */
operator|*
name|wild
operator|=
name|iswild
argument_list|(
operator|*
name|xp
argument_list|)
expr_stmt|;
name|debug
argument_list|(
name|F101
argument_list|,
literal|"cmifi wild"
argument_list|,
literal|""
argument_list|,
operator|*
name|wild
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|wild
operator|!=
literal|0
condition|)
block|{
endif|#
directive|endif
comment|/* COMMENT */
name|sv
operator|=
name|malloc
argument_list|(
operator|(
name|int
operator|)
name|strlen
argument_list|(
operator|*
name|xp
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* Make a safe copy */
if|if
condition|(
operator|!
name|sv
condition|)
block|{
name|printf
argument_list|(
literal|"?malloc error 73, cmifi\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|9
operator|)
return|;
block|}
name|strcpy
argument_list|(
name|sv
argument_list|,
operator|*
name|xp
argument_list|)
expr_stmt|;
name|debug
argument_list|(
name|F110
argument_list|,
literal|"cmifi sv"
argument_list|,
name|sv
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|y
operator|=
name|zxpand
argument_list|(
operator|*
name|xp
argument_list|)
expr_stmt|;
operator|*
name|wild
operator|=
operator|(
name|y
operator|>
literal|1
operator|)
expr_stmt|;
name|debug
argument_list|(
name|F111
argument_list|,
literal|"cmifi sv wild"
argument_list|,
name|sv
argument_list|,
operator|*
name|wild
argument_list|)
expr_stmt|;
if|if
condition|(
name|y
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"?No files match - %s\n"
argument_list|,
operator|*
name|xp
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|9
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|y
operator|<
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"?Too many files match - %s\n"
argument_list|,
operator|*
name|xp
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|9
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|y
operator|>
literal|1
condition|)
return|return
operator|(
name|x
operator|)
return|;
ifdef|#
directive|ifdef
name|COMMENT
block|}
endif|#
directive|endif
comment|/* If not wild, see if it exists and is readable. */
name|debug
argument_list|(
name|F111
argument_list|,
literal|"cmifi sv not wild"
argument_list|,
name|sv
argument_list|,
operator|*
name|wild
argument_list|)
expr_stmt|;
name|znext
argument_list|(
operator|*
name|xp
argument_list|)
expr_stmt|;
comment|/* Get first (only?) matching file */
name|y
operator|=
name|zchki
argument_list|(
operator|*
name|xp
argument_list|)
expr_stmt|;
comment|/* Check its accessibility */
name|zxpand
argument_list|(
name|sv
argument_list|)
expr_stmt|;
comment|/* Rewind so next znext() gets 1st */
name|free
argument_list|(
name|sv
argument_list|)
expr_stmt|;
comment|/* done with this */
if|if
condition|(
name|y
operator|==
operator|-
literal|3
condition|)
block|{
name|printf
argument_list|(
literal|"?Read permission denied - %s\n"
argument_list|,
operator|*
name|xp
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|9
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|y
operator|==
operator|-
literal|2
condition|)
block|{
name|printf
argument_list|(
literal|"?File not readable - %s\n"
argument_list|,
operator|*
name|xp
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|9
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|y
operator|<
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"?File not found - %s\n"
argument_list|,
operator|*
name|xp
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|9
operator|)
return|;
block|}
return|return
operator|(
name|x
operator|)
return|;
ifndef|#
directive|ifndef
name|MAC
case|case
literal|2
case|:
comment|/* ESC */
name|debug
argument_list|(
name|F101
argument_list|,
literal|"cmifi esc, xc"
argument_list|,
literal|""
argument_list|,
name|xc
argument_list|)
expr_stmt|;
if|if
condition|(
name|xc
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|*
name|xdef
operator|!=
literal|'\0'
condition|)
block|{
name|printf
argument_list|(
literal|"%s "
argument_list|,
name|xdef
argument_list|)
expr_stmt|;
comment|/* If at beginning of field, */
ifdef|#
directive|ifdef
name|GEMDOS
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* GEMDOS */
name|inword
operator|=
name|cmflgs
operator|=
literal|0
expr_stmt|;
name|addbuf
argument_list|(
name|xdef
argument_list|)
expr_stmt|;
comment|/* supply default. */
name|setatm
argument_list|(
name|xdef
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* No default */
name|putchar
argument_list|(
name|BEL
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
if|if
condition|(
name|f
condition|)
block|{
comment|/* If a conversion function is given */
name|zq
operator|=
name|atxbuf
expr_stmt|;
comment|/* ... */
name|atxn
operator|=
name|CMDBL
expr_stmt|;
if|if
condition|(
operator|(
name|x
operator|=
call|(
modifier|*
name|f
call|)
argument_list|(
operator|*
name|xp
argument_list|,
operator|&
name|zq
argument_list|,
operator|&
name|atxn
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|2
operator|)
return|;
comment|/* reduce cc by number of \\ consumed by conversion */
comment|/* function (needed for OS/2, where \ is path separator) */
name|cc
operator|-=
operator|(
name|strlen
argument_list|(
operator|*
name|xp
argument_list|)
operator|-
name|strlen
argument_list|(
name|atxbuf
argument_list|)
operator|)
expr_stmt|;
operator|*
name|xp
operator|=
name|atxbuf
expr_stmt|;
block|}
comment|/* #ifdef COMMENT */
ifdef|#
directive|ifdef
name|DTILDE
name|dirp
operator|=
name|tilde_expand
argument_list|(
operator|*
name|xp
argument_list|)
expr_stmt|;
comment|/* Expand tilde, if any, */
if|if
condition|(
operator|*
name|dirp
operator|!=
literal|'\0'
condition|)
name|setatm
argument_list|(
name|dirp
argument_list|)
expr_stmt|;
comment|/* in the atom buffer. */
operator|*
name|xp
operator|=
name|atmbuf
expr_stmt|;
endif|#
directive|endif
comment|/* DTILDE */
comment|/* #endif */
name|sp
operator|=
operator|*
name|xp
operator|+
name|cc
expr_stmt|;
ifdef|#
directive|ifdef
name|datageneral
operator|*
name|sp
operator|++
operator|=
literal|'+'
expr_stmt|;
comment|/* Data General AOS wildcard */
else|#
directive|else
operator|*
name|sp
operator|++
operator|=
literal|'*'
expr_stmt|;
comment|/* Others */
endif|#
directive|endif
comment|/* datageneral */
operator|*
name|sp
operator|--
operator|=
literal|'\0'
expr_stmt|;
ifdef|#
directive|ifdef
name|GEMDOS
if|if
condition|(
operator|!
name|strchr
argument_list|(
operator|*
name|xp
argument_list|,
literal|'.'
argument_list|)
condition|)
comment|/* abde.e -> abcde.e* */
name|strcat
argument_list|(
operator|*
name|xp
argument_list|,
literal|".*"
argument_list|)
expr_stmt|;
comment|/* abc -> abc*.* */
endif|#
directive|endif
comment|/* GEMDOS */
name|y
operator|=
name|zxpand
argument_list|(
operator|*
name|xp
argument_list|)
expr_stmt|;
comment|/* Add wildcard and expand list. */
if|if
condition|(
name|y
operator|>
literal|0
condition|)
name|strcpy
argument_list|(
name|filbuf
argument_list|,
name|mtchs
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
else|else
operator|*
name|filbuf
operator|=
literal|'\0'
expr_stmt|;
operator|*
name|sp
operator|=
literal|'\0'
expr_stmt|;
comment|/* Remove wildcard. */
operator|*
name|wild
operator|=
operator|(
name|y
operator|>
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|y
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"?No files match - %s\n"
argument_list|,
name|atmbuf
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|9
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|y
operator|<
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"?Too many files match - %s\n"
argument_list|,
name|atmbuf
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|9
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|y
operator|>
literal|1
condition|)
block|{
comment|/* Not unique. */
ifndef|#
directive|ifndef
name|NOPARTIAL
comment|/* Partial filename completion */
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|;
name|char
name|c
decl_stmt|;
name|k
operator|=
literal|0
expr_stmt|;
name|debug
argument_list|(
name|F111
argument_list|,
literal|"cmifi partial"
argument_list|,
name|filbuf
argument_list|,
name|cc
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|cc
init|;
operator|(
name|c
operator|=
name|filbuf
index|[
name|i
index|]
operator|)
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|j
operator|=
literal|1
init|;
name|j
operator|<
name|y
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|mtchs
index|[
name|j
index|]
index|[
name|i
index|]
operator|!=
name|c
condition|)
break|break;
if|if
condition|(
name|j
operator|==
name|y
condition|)
name|k
operator|++
expr_stmt|;
else|else
name|filbuf
index|[
name|i
index|]
operator|=
name|filbuf
index|[
name|i
operator|+
literal|1
index|]
operator|=
name|NUL
expr_stmt|;
block|}
name|debug
argument_list|(
name|F111
argument_list|,
literal|"cmifi partial k"
argument_list|,
name|filbuf
argument_list|,
name|k
argument_list|)
expr_stmt|;
if|if
condition|(
name|k
operator|>
literal|0
condition|)
block|{
comment|/* Got more characters */
name|sp
operator|=
name|filbuf
operator|+
name|cc
expr_stmt|;
comment|/* Point to new ones */
ifdef|#
directive|ifdef
name|VMS
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cc
condition|;
name|i
operator|++
control|)
block|{
name|cmdchardel
argument_list|()
expr_stmt|;
comment|/* Back up over old partial spec */
name|bp
operator|--
expr_stmt|;
block|}
name|sp
operator|=
name|filbuf
expr_stmt|;
comment|/* Point to new word start */
name|debug
argument_list|(
name|F100
argument_list|,
literal|"cmifi vms erase ok"
argument_list|,
literal|""
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* VMS */
name|cc
operator|=
name|k
expr_stmt|;
comment|/* How many new ones we just got */
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|sp
argument_list|)
expr_stmt|;
comment|/* Print them */
while|while
condition|(
operator|*
name|bp
operator|++
operator|=
operator|*
name|sp
operator|++
condition|)
empty_stmt|;
comment|/* Copy to command buffer */
name|bp
operator|--
expr_stmt|;
comment|/* Back up over NUL */
name|debug
argument_list|(
name|F110
argument_list|,
literal|"cmifi partial cmdbuf"
argument_list|,
name|cmdbuf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|setatm
argument_list|(
name|filbuf
argument_list|)
expr_stmt|;
name|debug
argument_list|(
name|F111
argument_list|,
literal|"cmifi partial atmbuf"
argument_list|,
name|atmbuf
argument_list|,
name|cc
argument_list|)
expr_stmt|;
operator|*
name|xp
operator|=
name|atmbuf
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* NOPARTIAL */
name|putchar
argument_list|(
name|BEL
argument_list|)
expr_stmt|;
comment|/* Beep because not unique. */
block|}
else|else
block|{
comment|/* Unique, complete it.  */
name|sp
operator|=
name|filbuf
operator|+
name|cc
expr_stmt|;
comment|/* Point past what user typed. */
ifdef|#
directive|ifdef
name|VMS
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cc
condition|;
name|i
operator|++
control|)
block|{
name|cmdchardel
argument_list|()
expr_stmt|;
comment|/* Back up over old partial spec */
name|bp
operator|--
expr_stmt|;
block|}
name|sp
operator|=
name|filbuf
expr_stmt|;
comment|/* Point to new word start */
endif|#
directive|endif
comment|/* VMS */
name|printf
argument_list|(
literal|"%s "
argument_list|,
name|sp
argument_list|)
expr_stmt|;
comment|/* Complete the name. */
ifdef|#
directive|ifdef
name|GEMDOS
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* GEMDOS */
name|addbuf
argument_list|(
name|sp
argument_list|)
expr_stmt|;
comment|/* Add the characters to cmdbuf. */
name|setatm
argument_list|(
name|filbuf
argument_list|)
expr_stmt|;
comment|/* And to atmbuf. */
name|inword
operator|=
name|cmflgs
operator|=
literal|0
expr_stmt|;
operator|*
name|xp
operator|=
name|atmbuf
expr_stmt|;
comment|/* Return pointer to atmbuf. */
return|return
operator|(
literal|0
operator|)
return|;
block|}
break|break;
case|case
literal|3
case|:
comment|/* Question mark */
if|if
condition|(
operator|*
name|xhlp
operator|==
name|NUL
condition|)
name|printf
argument_list|(
literal|" Input file specification"
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|" %s"
argument_list|,
name|xhlp
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|GEMDOS
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* GEMDOS */
if|if
condition|(
name|xc
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|f
condition|)
block|{
comment|/* If a conversion function is given */
name|zq
operator|=
name|atxbuf
expr_stmt|;
comment|/* ... */
name|atxn
operator|=
name|CMDBL
expr_stmt|;
if|if
condition|(
operator|(
name|x
operator|=
call|(
modifier|*
name|f
call|)
argument_list|(
operator|*
name|xp
argument_list|,
operator|&
name|zq
argument_list|,
operator|&
name|atxn
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|2
operator|)
return|;
operator|*
name|xp
operator|=
name|atxbuf
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DTILDE
name|dirp
operator|=
name|tilde_expand
argument_list|(
operator|*
name|xp
argument_list|)
expr_stmt|;
comment|/* Expand tilde, if any */
if|if
condition|(
operator|*
name|dirp
operator|!=
literal|'\0'
condition|)
name|setatm
argument_list|(
name|dirp
argument_list|)
expr_stmt|;
operator|*
name|xp
operator|=
name|atmbuf
expr_stmt|;
endif|#
directive|endif
name|debug
argument_list|(
name|F111
argument_list|,
literal|"cmifi ? *xp, cc"
argument_list|,
operator|*
name|xp
argument_list|,
name|cc
argument_list|)
expr_stmt|;
name|sp
operator|=
operator|*
name|xp
operator|+
name|cc
expr_stmt|;
comment|/* Insert "*" at end */
ifdef|#
directive|ifdef
name|datageneral
operator|*
name|sp
operator|++
operator|=
literal|'+'
expr_stmt|;
comment|/* Insert +, the DG wild card */
else|#
directive|else
operator|*
name|sp
operator|++
operator|=
literal|'*'
expr_stmt|;
endif|#
directive|endif
comment|/* datageneral */
operator|*
name|sp
operator|--
operator|=
literal|'\0'
expr_stmt|;
ifdef|#
directive|ifdef
name|GEMDOS
if|if
condition|(
operator|!
name|strchr
argument_list|(
operator|*
name|xp
argument_list|,
literal|'.'
argument_list|)
condition|)
comment|/* abde.e -> abcde.e* */
name|strcat
argument_list|(
operator|*
name|xp
argument_list|,
literal|".*"
argument_list|)
expr_stmt|;
comment|/* abc -> abc*.* */
endif|#
directive|endif
comment|/* GEMDOS */
name|debug
argument_list|(
name|F110
argument_list|,
literal|"cmifi ? wild"
argument_list|,
operator|*
name|xp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|y
operator|=
name|zxpand
argument_list|(
operator|*
name|xp
argument_list|)
expr_stmt|;
operator|*
name|sp
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|y
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"?No files match - %s\n"
argument_list|,
name|atmbuf
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|9
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|y
operator|<
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"?Too many files match - %s\n"
argument_list|,
name|atmbuf
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|9
operator|)
return|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|", one of the following:\n"
argument_list|)
expr_stmt|;
name|clrhlp
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|y
condition|;
name|i
operator|++
control|)
block|{
name|znext
argument_list|(
name|filbuf
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|VMS
name|printf
argument_list|(
literal|" %s\n"
argument_list|,
name|filbuf
argument_list|)
expr_stmt|;
comment|/* VMS names can be long */
else|#
directive|else
name|addhlp
argument_list|(
name|filbuf
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* VMS */
block|}
name|dmphlp
argument_list|()
expr_stmt|;
block|}
block|}
else|else
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s%s"
argument_list|,
name|cmprom
argument_list|,
name|cmdbuf
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* MAC */
block|}
name|x
operator|=
name|gtword
argument_list|()
expr_stmt|;
operator|*
name|xp
operator|=
name|atmbuf
expr_stmt|;
block|}
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/*  C M D I R  --  Parse a directory specification  */
end_comment

begin_comment
comment|/*  This function depends on the external functions:    zchki()  - Check if input file exists and is readable.  If these functions aren't available, then use cmfld() to parse dir names.  Note: this function quickly cobbled together, mainly by deleting lots of  lines from cmifi().  It seems to work, but various services are missing,  like completion, lists of matching directories on "?", etc. */
end_comment

begin_comment
comment|/*  Returns    -4 EOF    -3 if no input present when required,    -2 if out of space or other internal error,    -1 if reparse needed,     0 or 1, with xp pointing to name, if directory specified,     2 if a wildcard was included. */
end_comment

begin_function
name|int
name|cmdir
parameter_list|(
name|xhlp
parameter_list|,
name|xdef
parameter_list|,
name|xp
parameter_list|,
name|f
parameter_list|)
name|char
modifier|*
name|xhlp
decl_stmt|,
decl|*
name|xdef
decl_stmt|,
modifier|*
modifier|*
name|xp
decl_stmt|;
end_function

begin_decl_stmt
name|xx_strp
name|f
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|x
decl_stmt|,
name|xc
decl_stmt|;
name|char
modifier|*
name|zq
decl_stmt|;
ifdef|#
directive|ifdef
name|DTILDE
name|char
modifier|*
name|tilde_expand
argument_list|()
decl_stmt|,
modifier|*
name|dirp
decl_stmt|;
endif|#
directive|endif
comment|/* DTILDE */
name|inword
operator|=
name|cc
operator|=
name|xc
operator|=
literal|0
expr_stmt|;
comment|/* Initialize counts& pointers */
operator|*
name|xp
operator|=
literal|""
expr_stmt|;
if|if
condition|(
operator|(
name|x
operator|=
name|cmflgs
operator|)
operator|!=
literal|1
condition|)
block|{
comment|/* Already confirmed? */
name|x
operator|=
name|gtword
argument_list|()
expr_stmt|;
comment|/* No, get a word */
block|}
else|else
block|{
name|setatm
argument_list|(
name|xdef
argument_list|)
expr_stmt|;
comment|/* If so, use default, if any. */
block|}
operator|*
name|xp
operator|=
name|atmbuf
expr_stmt|;
comment|/* Point to result. */
while|while
condition|(
literal|1
condition|)
block|{
name|xc
operator|+=
name|cc
expr_stmt|;
comment|/* Count the characters. */
name|debug
argument_list|(
name|F111
argument_list|,
literal|"cmdir gtword"
argument_list|,
name|atmbuf
argument_list|,
name|xc
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|x
condition|)
block|{
case|case
operator|-
literal|4
case|:
comment|/* EOF */
case|case
operator|-
literal|2
case|:
comment|/* Out of space. */
case|case
operator|-
literal|1
case|:
comment|/* Reparse needed */
return|return
operator|(
name|x
operator|)
return|;
case|case
literal|0
case|:
comment|/* SP or NL */
case|case
literal|1
case|:
if|if
condition|(
name|xc
operator|==
literal|0
condition|)
operator|*
name|xp
operator|=
name|xdef
expr_stmt|;
comment|/* If no input, return default. */
else|else
operator|*
name|xp
operator|=
name|atmbuf
expr_stmt|;
if|if
condition|(
operator|*
operator|*
name|xp
operator|==
name|NUL
condition|)
return|return
operator|(
operator|-
literal|3
operator|)
return|;
comment|/* If field empty, return -3. */
if|if
condition|(
name|f
condition|)
block|{
comment|/* If a conversion function is given */
name|zq
operator|=
name|atxbuf
expr_stmt|;
comment|/* ... */
name|atxn
operator|=
name|CMDBL
expr_stmt|;
if|if
condition|(
operator|(
name|x
operator|=
call|(
modifier|*
name|f
call|)
argument_list|(
operator|*
name|xp
argument_list|,
operator|&
name|zq
argument_list|,
operator|&
name|atxn
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|2
operator|)
return|;
operator|*
name|xp
operator|=
name|atxbuf
expr_stmt|;
name|cc
operator|=
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|atxbuf
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DTILDE
comment|/*   This is ugly, and for UNIX only.   Normally, we wouldn't call tilde_expand from a place like this anyway,   but rather let zxpand() take care of it.  But in this case we might want    a hybrid result -- a string with the tilde expanded, but with wildcards   left unexpanded. */
name|dirp
operator|=
name|tilde_expand
argument_list|(
operator|*
name|xp
argument_list|)
expr_stmt|;
comment|/* Expand tilde, if any, */
if|if
condition|(
operator|*
name|dirp
operator|==
literal|'~'
condition|)
block|{
comment|/* Still starts with tilde? */
name|char
modifier|*
name|tp
decl_stmt|;
comment|/* Yes, convert to lowercase */
name|tp
operator|=
operator|*
name|xp
expr_stmt|;
comment|/* and try again. */
while|while
condition|(
operator|*
name|tp
condition|)
block|{
if|if
condition|(
name|isupper
argument_list|(
operator|*
name|tp
argument_list|)
condition|)
operator|*
name|tp
operator|=
name|tolower
argument_list|(
operator|*
name|tp
argument_list|)
expr_stmt|;
name|tp
operator|++
expr_stmt|;
block|}
block|}
name|dirp
operator|=
name|tilde_expand
argument_list|(
operator|*
name|xp
argument_list|)
expr_stmt|;
comment|/* Expand tilde, if any, */
if|if
condition|(
operator|*
name|dirp
operator|!=
literal|'\0'
condition|)
name|setatm
argument_list|(
name|dirp
argument_list|)
expr_stmt|;
comment|/* in the atom buffer. */
operator|*
name|xp
operator|=
name|atmbuf
expr_stmt|;
endif|#
directive|endif
comment|/* DTILDE */
if|if
condition|(
name|iswild
argument_list|(
operator|*
name|xp
argument_list|)
condition|)
return|return
operator|(
literal|2
operator|)
return|;
else|else
return|return
operator|(
name|x
operator|)
return|;
case|case
literal|2
case|:
comment|/* ESC */
name|putchar
argument_list|(
name|BEL
argument_list|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
comment|/* Question mark */
if|if
condition|(
operator|*
name|xhlp
operator|==
name|NUL
condition|)
name|printf
argument_list|(
literal|" Directory name"
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|" %s"
argument_list|,
name|xhlp
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n%s%s"
argument_list|,
name|cmprom
argument_list|,
name|cmdbuf
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
break|break;
block|}
name|x
operator|=
name|gtword
argument_list|()
expr_stmt|;
comment|/*  *xp = atmbuf;  */
block|}
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/*  C M F L D  --  Parse an arbitrary field  */
end_comment

begin_comment
comment|/*  Returns    -3 if no input present when required,    -2 if field too big for buffer,    -1 if reparse needed,     0 otherwise, xp pointing to string result. */
end_comment

begin_function
name|int
name|cmfld
parameter_list|(
name|xhlp
parameter_list|,
name|xdef
parameter_list|,
name|xp
parameter_list|,
name|f
parameter_list|)
name|char
modifier|*
name|xhlp
decl_stmt|,
decl|*
name|xdef
decl_stmt|,
modifier|*
modifier|*
name|xp
decl_stmt|;
end_function

begin_decl_stmt
name|xx_strp
name|f
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|x
decl_stmt|,
name|xc
decl_stmt|;
name|char
modifier|*
name|zq
decl_stmt|;
name|inword
operator|=
name|cc
operator|=
name|xc
operator|=
literal|0
expr_stmt|;
comment|/* Initialize counts& pointers */
operator|*
name|xp
operator|=
literal|""
expr_stmt|;
if|if
condition|(
operator|(
name|x
operator|=
name|cmflgs
operator|)
operator|!=
literal|1
condition|)
block|{
comment|/* Already confirmed? */
name|x
operator|=
name|gtword
argument_list|()
expr_stmt|;
comment|/* No, get a word */
block|}
else|else
block|{
name|setatm
argument_list|(
name|xdef
argument_list|)
expr_stmt|;
comment|/* If so, use default, if any. */
block|}
operator|*
name|xp
operator|=
name|atmbuf
expr_stmt|;
comment|/* Point to result. */
while|while
condition|(
literal|1
condition|)
block|{
name|xc
operator|+=
name|cc
expr_stmt|;
comment|/* Count the characters. */
name|debug
argument_list|(
name|F111
argument_list|,
literal|"cmfld: gtword"
argument_list|,
name|atmbuf
argument_list|,
name|xc
argument_list|)
expr_stmt|;
name|debug
argument_list|(
name|F101
argument_list|,
literal|"cmfld x"
argument_list|,
literal|""
argument_list|,
name|x
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|x
condition|)
block|{
case|case
operator|-
literal|4
case|:
comment|/* EOF */
case|case
operator|-
literal|2
case|:
comment|/* Out of space. */
case|case
operator|-
literal|1
case|:
comment|/* Reparse needed */
return|return
operator|(
name|x
operator|)
return|;
case|case
literal|0
case|:
comment|/* SP or NL */
case|case
literal|1
case|:
if|if
condition|(
name|xc
operator|==
literal|0
condition|)
comment|/* If no input, return default. */
name|setatm
argument_list|(
name|xdef
argument_list|)
expr_stmt|;
operator|*
name|xp
operator|=
name|atmbuf
expr_stmt|;
if|if
condition|(
name|f
condition|)
block|{
comment|/* If a conversion function is given */
name|zq
operator|=
name|atxbuf
expr_stmt|;
comment|/* ... */
name|atxn
operator|=
name|CMDBL
expr_stmt|;
if|if
condition|(
call|(
modifier|*
name|f
call|)
argument_list|(
operator|*
name|xp
argument_list|,
operator|&
name|zq
argument_list|,
operator|&
name|atxn
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|2
operator|)
return|;
name|setatm
argument_list|(
name|atxbuf
argument_list|)
expr_stmt|;
operator|*
name|xp
operator|=
name|atmbuf
expr_stmt|;
block|}
if|if
condition|(
operator|*
operator|*
name|xp
operator|==
name|NUL
condition|)
block|{
comment|/* If variable evaluates to null */
name|setatm
argument_list|(
name|xdef
argument_list|)
expr_stmt|;
comment|/* Stick in the default again. */
if|if
condition|(
operator|*
operator|*
name|xp
operator|==
name|NUL
condition|)
name|x
operator|=
operator|-
literal|3
expr_stmt|;
comment|/* If still empty, return -3. */
block|}
ifdef|#
directive|ifdef
name|COMMENT
comment|/* The following is apparently not necessary. */
comment|/* Remove it if nothing is broken, esp. TAKE file with trailing comments */
name|xx
operator|=
operator|*
name|xp
expr_stmt|;
name|debug
argument_list|(
name|F111
argument_list|,
literal|"cmfld before trim"
argument_list|,
operator|*
name|xp
argument_list|,
name|x
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|xx
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|xx
index|[
name|i
index|]
operator|!=
name|SP
condition|)
comment|/* Trim trailing blanks */
break|break;
else|else
name|xx
index|[
name|i
index|]
operator|=
name|NUL
expr_stmt|;
name|debug
argument_list|(
name|F111
argument_list|,
literal|"cmfld returns"
argument_list|,
operator|*
name|xp
argument_list|,
name|x
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* COMMENT */
name|debug
argument_list|(
name|F101
argument_list|,
literal|"cmfld: returns"
argument_list|,
literal|""
argument_list|,
name|x
argument_list|)
expr_stmt|;
return|return
operator|(
name|x
operator|)
return|;
case|case
literal|2
case|:
comment|/* ESC */
if|if
condition|(
name|xc
operator|==
literal|0
operator|&&
operator|*
name|xdef
operator|!=
name|NUL
condition|)
block|{
name|printf
argument_list|(
literal|"%s "
argument_list|,
name|xdef
argument_list|)
expr_stmt|;
comment|/* If at beginning of field, */
ifdef|#
directive|ifdef
name|GEMDOS
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* GEMDOS */
name|addbuf
argument_list|(
name|xdef
argument_list|)
expr_stmt|;
comment|/* supply default. */
name|inword
operator|=
name|cmflgs
operator|=
literal|0
expr_stmt|;
name|setatm
argument_list|(
name|xdef
argument_list|)
expr_stmt|;
comment|/* Return as if whole field */
return|return
operator|(
literal|0
operator|)
return|;
comment|/* typed, followed by space. */
block|}
else|else
block|{
name|putchar
argument_list|(
name|BEL
argument_list|)
expr_stmt|;
comment|/* Beep if already into field. */
block|}
break|break;
case|case
literal|3
case|:
comment|/* Question mark */
if|if
condition|(
operator|*
name|xhlp
operator|==
name|NUL
condition|)
name|printf
argument_list|(
literal|" Please complete this field"
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|" %s"
argument_list|,
name|xhlp
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n%s%s"
argument_list|,
name|cmprom
argument_list|,
name|cmdbuf
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
break|break;
block|}
name|x
operator|=
name|gtword
argument_list|()
expr_stmt|;
comment|/*  *xp = atmbuf; */
block|}
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/*  C M T X T  --  Get a text string, including confirmation  */
end_comment

begin_comment
comment|/*   Print help message 'xhlp' if ? typed, supply default 'xdef' if null   string typed.  Returns      -1 if reparse needed or buffer overflows.     1 otherwise.     with cmflgs set to return code, and xp pointing to result string. */
end_comment

begin_function
name|int
name|cmtxt
parameter_list|(
name|xhlp
parameter_list|,
name|xdef
parameter_list|,
name|xp
parameter_list|,
name|f
parameter_list|)
name|char
modifier|*
name|xhlp
decl_stmt|;
name|char
modifier|*
name|xdef
decl_stmt|;
name|char
modifier|*
modifier|*
name|xp
decl_stmt|;
name|xx_strp
name|f
decl_stmt|;
block|{
name|int
name|x
decl_stmt|,
name|i
decl_stmt|;
name|char
modifier|*
name|xx
decl_stmt|,
modifier|*
name|zq
decl_stmt|;
specifier|static
name|int
name|xc
decl_stmt|;
name|debug
argument_list|(
name|F101
argument_list|,
literal|"cmtxt, cmflgs"
argument_list|,
literal|""
argument_list|,
name|cmflgs
argument_list|)
expr_stmt|;
name|inword
operator|=
name|cc
operator|=
literal|0
expr_stmt|;
comment|/* Start atmbuf counter off at 0 */
if|if
condition|(
name|cmflgs
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* If reparsing, */
name|xc
operator|=
operator|(
name|int
operator|)
name|strlen
argument_list|(
operator|*
name|xp
argument_list|)
expr_stmt|;
comment|/* get back the total text length, */
block|}
else|else
block|{
comment|/* otherwise, */
operator|*
name|xp
operator|=
literal|""
expr_stmt|;
comment|/* start fresh. */
name|xc
operator|=
literal|0
expr_stmt|;
block|}
operator|*
name|atmbuf
operator|=
name|NUL
expr_stmt|;
comment|/* And empty the atom buffer. */
if|if
condition|(
operator|(
name|x
operator|=
name|cmflgs
operator|)
operator|!=
literal|1
condition|)
block|{
name|x
operator|=
name|gtword
argument_list|()
expr_stmt|;
comment|/* Get first word. */
operator|*
name|xp
operator|=
name|pp
expr_stmt|;
comment|/* Save pointer to it. */
block|}
name|debug
argument_list|(
name|F101
argument_list|,
literal|"cmtxt (*f)"
argument_list|,
literal|""
argument_list|,
name|f
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
comment|/* Loop for each word in text. */
name|xc
operator|+=
name|cc
expr_stmt|;
comment|/* Char count for all words. */
name|debug
argument_list|(
name|F111
argument_list|,
literal|"cmtxt: gtword"
argument_list|,
name|atmbuf
argument_list|,
name|xc
argument_list|)
expr_stmt|;
name|debug
argument_list|(
name|F101
argument_list|,
literal|" x"
argument_list|,
literal|""
argument_list|,
name|x
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|x
condition|)
block|{
case|case
operator|-
literal|9
case|:
comment|/* Buffer overflow */
case|case
operator|-
literal|4
case|:
comment|/* EOF */
ifdef|#
directive|ifdef
name|MAC
case|case
operator|-
literal|3
case|:
comment|/* Quit/Timeout */
endif|#
directive|endif
comment|/* MAC */
case|case
operator|-
literal|2
case|:
comment|/* Overflow */
case|case
operator|-
literal|1
case|:
comment|/* Deletion */
return|return
operator|(
name|x
operator|)
return|;
case|case
literal|0
case|:
comment|/* Space */
name|xc
operator|++
expr_stmt|;
comment|/* Just count it */
break|break;
case|case
literal|1
case|:
comment|/* CR or LF */
if|if
condition|(
name|xc
operator|==
literal|0
condition|)
operator|*
name|xp
operator|=
name|xdef
expr_stmt|;
if|if
condition|(
name|f
condition|)
block|{
comment|/* If a conversion function is given */
name|zq
operator|=
name|atxbuf
expr_stmt|;
comment|/* Point to the expansion buffer */
name|atxn
operator|=
name|CMDBL
expr_stmt|;
comment|/* specify its length */
name|debug
argument_list|(
name|F110
argument_list|,
literal|"cmtxt calling (*f)"
argument_list|,
operator|*
name|xp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|x
operator|=
call|(
modifier|*
name|f
call|)
argument_list|(
operator|*
name|xp
argument_list|,
operator|&
name|zq
argument_list|,
operator|&
name|atxn
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|2
operator|)
return|;
name|cc
operator|=
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|atxbuf
argument_list|)
expr_stmt|;
operator|*
name|xp
operator|=
name|atxbuf
expr_stmt|;
comment|/* and return pointer to it. */
name|debug
argument_list|(
name|F111
argument_list|,
literal|"cmtxt (*f) returns"
argument_list|,
operator|*
name|xp
argument_list|,
name|cc
argument_list|)
expr_stmt|;
block|}
name|xx
operator|=
operator|*
name|xp
expr_stmt|;
for|for
control|(
name|i
operator|=
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|xx
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|xx
index|[
name|i
index|]
operator|!=
name|SP
condition|)
comment|/* Trim trailing blanks */
break|break;
else|else
name|xx
index|[
name|i
index|]
operator|=
name|NUL
expr_stmt|;
return|return
operator|(
name|x
operator|)
return|;
case|case
literal|2
case|:
comment|/* ESC */
if|if
condition|(
name|xc
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"%s "
argument_list|,
name|xdef
argument_list|)
expr_stmt|;
name|inword
operator|=
name|cmflgs
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|GEMDOS
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* GEMDOS */
name|cc
operator|=
name|addbuf
argument_list|(
name|xdef
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|putchar
argument_list|(
name|BEL
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|3
case|:
comment|/* Question Mark */
if|if
condition|(
operator|*
name|xhlp
operator|==
name|NUL
condition|)
name|printf
argument_list|(
literal|" Text string"
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|" %s"
argument_list|,
name|xhlp
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n%s%s"
argument_list|,
name|cmprom
argument_list|,
name|cmdbuf
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"?Unexpected return code from gtword() - %d\n"
argument_list|,
name|x
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|2
operator|)
return|;
block|}
name|x
operator|=
name|gtword
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  C M K E Y  --  Parse a keyword  */
end_comment

begin_comment
comment|/*  Call with:    table    --  keyword table, in 'struct keytab' format;    n        --  number of entries in table;    xhlp     --  pointer to help string;    xdef     --  pointer to default keyword;    Returns:    -3       --  no input supplied and no default available    -2       --  input doesn't uniquely match a keyword in the table    -1       --  user deleted too much, command reparse required     n>= 0  --  value associated with keyword */
end_comment

begin_function
name|int
name|cmkey
parameter_list|(
name|table
parameter_list|,
name|n
parameter_list|,
name|xhlp
parameter_list|,
name|xdef
parameter_list|,
name|f
parameter_list|)
comment|/* cmkey */
name|struct
name|keytab
name|table
index|[]
decl_stmt|;
name|int
name|n
decl_stmt|;
name|char
modifier|*
name|xhlp
decl_stmt|,
decl|*
name|xdef
decl_stmt|;
end_function

begin_decl_stmt
name|xx_strp
name|f
decl_stmt|;
end_decl_stmt

begin_block
block|{
return|return
operator|(
name|cmkey2
argument_list|(
name|table
argument_list|,
name|n
argument_list|,
name|xhlp
argument_list|,
name|xdef
argument_list|,
literal|""
argument_list|,
name|f
argument_list|)
operator|)
return|;
block|}
end_block

begin_function
name|int
name|cmkey2
parameter_list|(
name|table
parameter_list|,
name|n
parameter_list|,
name|xhlp
parameter_list|,
name|xdef
parameter_list|,
name|tok
parameter_list|,
name|f
parameter_list|)
name|struct
name|keytab
name|table
index|[]
decl_stmt|;
name|int
name|n
decl_stmt|;
name|char
modifier|*
name|xhlp
decl_stmt|,
decl|*
name|xdef
decl_stmt|;
end_function

begin_decl_stmt
name|char
modifier|*
name|tok
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|xx_strp
name|f
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|i
decl_stmt|,
name|tl
decl_stmt|,
name|y
decl_stmt|,
name|z
decl_stmt|,
name|zz
decl_stmt|,
name|xc
decl_stmt|;
name|char
modifier|*
name|xp
decl_stmt|,
modifier|*
name|zq
decl_stmt|;
name|tl
operator|=
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|tok
argument_list|)
expr_stmt|;
name|inword
operator|=
name|xc
operator|=
name|cc
operator|=
literal|0
expr_stmt|;
comment|/* Clear character counters. */
if|if
condition|(
operator|(
name|zz
operator|=
name|cmflgs
operator|)
operator|==
literal|1
condition|)
comment|/* Command already entered? */
name|setatm
argument_list|(
name|xdef
argument_list|)
expr_stmt|;
comment|/* Yes, copy default into atom buf */
else|else
name|zz
operator|=
name|gtword
argument_list|()
expr_stmt|;
comment|/* Otherwise get a command word */
name|debug
argument_list|(
name|F101
argument_list|,
literal|"cmkey: table length"
argument_list|,
literal|""
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|debug
argument_list|(
name|F101
argument_list|,
literal|" cmflgs"
argument_list|,
literal|""
argument_list|,
name|cmflgs
argument_list|)
expr_stmt|;
name|debug
argument_list|(
name|F101
argument_list|,
literal|" zz"
argument_list|,
literal|""
argument_list|,
name|zz
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|xc
operator|+=
name|cc
expr_stmt|;
name|debug
argument_list|(
name|F111
argument_list|,
literal|"cmkey: gtword"
argument_list|,
name|atmbuf
argument_list|,
name|xc
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|zz
condition|)
block|{
case|case
operator|-
literal|4
case|:
comment|/* EOF */
ifdef|#
directive|ifdef
name|MAC
case|case
operator|-
literal|3
case|:
comment|/* Quit/Timeout */
endif|#
directive|endif
comment|/* MAC */
case|case
operator|-
literal|2
case|:
comment|/* Buffer overflow */
case|case
operator|-
literal|1
case|:
comment|/* Or user did some deleting. */
return|return
operator|(
name|cmflgs
operator|=
name|zz
operator|)
return|;
case|case
literal|0
case|:
comment|/* User terminated word with space */
case|case
literal|1
case|:
comment|/* or newline */
if|if
condition|(
name|cc
operator|==
literal|0
condition|)
name|setatm
argument_list|(
name|xdef
argument_list|)
expr_stmt|;
comment|/* Supply default if user typed nada */
if|if
condition|(
name|f
condition|)
block|{
comment|/* If a conversion function is given */
name|zq
operator|=
name|atxbuf
expr_stmt|;
comment|/* apply it */
name|atxn
operator|=
name|CMDBL
expr_stmt|;
if|if
condition|(
call|(
modifier|*
name|f
call|)
argument_list|(
name|atmbuf
argument_list|,
operator|&
name|zq
argument_list|,
operator|&
name|atxn
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|2
operator|)
return|;
name|debug
argument_list|(
name|F110
argument_list|,
literal|"cmkey atxbuf after *f"
argument_list|,
name|atxbuf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|setatm
argument_list|(
name|atxbuf
argument_list|)
expr_stmt|;
block|}
name|y
operator|=
name|lookup
argument_list|(
name|table
argument_list|,
name|atmbuf
argument_list|,
name|n
argument_list|,
operator|&
name|z
argument_list|)
expr_stmt|;
comment|/* Look up the word in the table */
switch|switch
condition|(
name|y
condition|)
block|{
case|case
operator|-
literal|2
case|:
comment|/* Ambiguous */
name|printf
argument_list|(
literal|"?Ambiguous - %s\n"
argument_list|,
name|atmbuf
argument_list|)
expr_stmt|;
name|cmflgs
operator|=
operator|-
literal|2
expr_stmt|;
return|return
operator|(
operator|-
literal|9
operator|)
return|;
case|case
operator|-
literal|1
case|:
comment|/* Not found at all */
if|if
condition|(
name|tl
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|tl
condition|;
name|i
operator|++
control|)
comment|/* Check for token */
if|if
condition|(
name|tok
index|[
name|i
index|]
operator|==
operator|*
name|atmbuf
condition|)
block|{
comment|/* Got one */
name|ungword
argument_list|()
expr_stmt|;
comment|/* Put back the following word */
return|return
operator|(
operator|-
literal|5
operator|)
return|;
comment|/* Special return code for token */
block|}
block|}
comment|/* Kludge alert... only print error if */
comment|/* we were called as cmkey2, but not cmkey... */
comment|/* This doesn't seem to always work. */
if|if
condition|(
name|tl
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"?No keywords match - %s\n"
argument_list|,
name|atmbuf
argument_list|)
expr_stmt|;
comment|/* cmkey */
return|return
operator|(
name|cmflgs
operator|=
operator|-
literal|9
operator|)
return|;
block|}
else|else
block|{
if|if
condition|(
name|cmflgs
operator|==
literal|1
condition|)
return|return
operator|(
name|cmflgs
operator|=
operator|-
literal|6
operator|)
return|;
comment|/* cmkey2 */
else|else
return|return
operator|(
name|cmflgs
operator|=
operator|-
literal|2
operator|)
return|;
comment|/* The -6 code is to let caller try another table */
block|}
default|default:
break|break;
block|}
return|return
operator|(
name|y
operator|)
return|;
case|case
literal|2
case|:
comment|/* User terminated word with ESC */
if|if
condition|(
name|cc
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|*
name|xdef
operator|!=
name|NUL
condition|)
block|{
comment|/* Nothing in atmbuf */
name|printf
argument_list|(
literal|"%s "
argument_list|,
name|xdef
argument_list|)
expr_stmt|;
comment|/* Supply default if any */
ifdef|#
directive|ifdef
name|GEMDOS
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* GEMDOS */
name|addbuf
argument_list|(
name|xdef
argument_list|)
expr_stmt|;
name|setatm
argument_list|(
name|xdef
argument_list|)
expr_stmt|;
name|inword
operator|=
name|cmflgs
operator|=
literal|0
expr_stmt|;
name|debug
argument_list|(
name|F111
argument_list|,
literal|"cmkey: default"
argument_list|,
name|atmbuf
argument_list|,
name|cc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|putchar
argument_list|(
name|BEL
argument_list|)
expr_stmt|;
comment|/* No default, just beep */
break|break;
block|}
block|}
if|if
condition|(
name|f
condition|)
block|{
comment|/* If a conversion function is given */
name|zq
operator|=
name|atxbuf
expr_stmt|;
comment|/* apply it */
name|atxn
operator|=
name|CMDBL
expr_stmt|;
if|if
condition|(
call|(
modifier|*
name|f
call|)
argument_list|(
name|atmbuf
argument_list|,
operator|&
name|zq
argument_list|,
operator|&
name|atxn
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|2
operator|)
return|;
name|setatm
argument_list|(
name|atxbuf
argument_list|)
expr_stmt|;
block|}
name|y
operator|=
name|lookup
argument_list|(
name|table
argument_list|,
name|atmbuf
argument_list|,
name|n
argument_list|,
operator|&
name|z
argument_list|)
expr_stmt|;
comment|/* Something in atmbuf */
name|debug
argument_list|(
name|F111
argument_list|,
literal|"cmkey: esc"
argument_list|,
name|atmbuf
argument_list|,
name|y
argument_list|)
expr_stmt|;
if|if
condition|(
name|y
operator|==
operator|-
literal|2
condition|)
block|{
comment|/* Ambiguous */
name|putchar
argument_list|(
name|BEL
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|y
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* Not found */
comment|/* if (tl == 0) */
name|printf
argument_list|(
literal|"?No keywords match - %s\n"
argument_list|,
name|atmbuf
argument_list|)
expr_stmt|;
name|cmflgs
operator|=
operator|-
literal|2
expr_stmt|;
return|return
operator|(
operator|-
literal|9
operator|)
return|;
block|}
comment|/*   See if the keyword just found has the CM_ABR bit set in its flgs field, and   if so, search forwards in the table for a keyword that has the same kwval   but does not have CM_ABR (or CM_INV?) set, and then expand using the full   keyword.  WARNING: This assumes that (a) keywords are in alphabetical order,   and (b) the CM_ABR bit is set only if the the abbreviated keyword is a true   abbreviation (left substring) of the full keyword. */
if|if
condition|(
name|test
argument_list|(
name|table
index|[
name|z
index|]
operator|.
name|flgs
argument_list|,
name|CM_ABR
argument_list|)
condition|)
block|{
name|int
name|zz
decl_stmt|;
for|for
control|(
name|zz
operator|=
name|z
operator|+
literal|1
init|;
name|zz
operator|<
name|n
condition|;
name|zz
operator|++
control|)
if|if
condition|(
operator|(
name|table
index|[
name|zz
index|]
operator|.
name|kwval
operator|==
name|table
index|[
name|z
index|]
operator|.
name|kwval
operator|)
operator|&&
operator|(
operator|!
name|test
argument_list|(
name|table
index|[
name|zz
index|]
operator|.
name|flgs
argument_list|,
name|CM_ABR
argument_list|)
operator|)
condition|)
block|{
name|z
operator|=
name|zz
expr_stmt|;
break|break;
block|}
block|}
name|xp
operator|=
name|table
index|[
name|z
index|]
operator|.
name|kwd
operator|+
name|cc
expr_stmt|;
name|printf
argument_list|(
literal|"%s "
argument_list|,
name|xp
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|GEMDOS
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* GEMDOS */
name|addbuf
argument_list|(
name|xp
argument_list|)
expr_stmt|;
name|inword
operator|=
name|cmflgs
operator|=
literal|0
expr_stmt|;
name|debug
argument_list|(
name|F110
argument_list|,
literal|"cmkey: addbuf"
argument_list|,
name|cmdbuf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|y
operator|)
return|;
case|case
literal|3
case|:
comment|/* User typed "?" */
if|if
condition|(
name|f
condition|)
block|{
comment|/* If a conversion function is given */
name|zq
operator|=
name|atxbuf
expr_stmt|;
comment|/* do the conversion now. */
name|atxn
operator|=
name|CMDBL
expr_stmt|;
if|if
condition|(
call|(
modifier|*
name|f
call|)
argument_list|(
name|atmbuf
argument_list|,
operator|&
name|zq
argument_list|,
operator|&
name|atxn
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|2
operator|)
return|;
name|setatm
argument_list|(
name|atxbuf
argument_list|)
expr_stmt|;
block|}
name|y
operator|=
name|lookup
argument_list|(
name|table
argument_list|,
name|atmbuf
argument_list|,
name|n
argument_list|,
operator|&
name|z
argument_list|)
expr_stmt|;
comment|/* Look up what we have so far. */
if|if
condition|(
name|y
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* if (tl == 0) */
name|printf
argument_list|(
literal|" No keywords match\n"
argument_list|)
expr_stmt|;
name|cmflgs
operator|=
operator|-
literal|2
expr_stmt|;
return|return
operator|(
operator|-
literal|9
operator|)
return|;
block|}
if|if
condition|(
operator|*
name|xhlp
operator|==
name|NUL
condition|)
name|printf
argument_list|(
literal|" One of the following:\n"
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|" %s, one of the following:\n"
argument_list|,
name|xhlp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|y
operator|>
operator|-
literal|1
operator|)
operator|&&
operator|!
name|test
argument_list|(
name|table
index|[
name|z
index|]
operator|.
name|flgs
argument_list|,
name|CM_ABR
argument_list|)
operator|&&
operator|(
operator|(
name|z
operator|>=
name|n
operator|-
literal|1
operator|)
operator|||
name|strncmp
argument_list|(
name|table
index|[
name|z
index|]
operator|.
name|kwd
argument_list|,
name|table
index|[
name|z
operator|+
literal|1
index|]
operator|.
name|kwd
argument_list|,
name|cc
argument_list|)
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|" %s\n"
argument_list|,
name|table
index|[
name|z
index|]
operator|.
name|kwd
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|clrhlp
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|table
index|[
name|i
index|]
operator|.
name|kwd
argument_list|,
name|atmbuf
argument_list|,
name|cc
argument_list|)
operator|&&
operator|!
name|test
argument_list|(
name|table
index|[
name|i
index|]
operator|.
name|flgs
argument_list|,
name|CM_INV
argument_list|)
condition|)
name|addhlp
argument_list|(
name|table
index|[
name|i
index|]
operator|.
name|kwd
argument_list|)
expr_stmt|;
block|}
name|dmphlp
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|atmbuf
operator|==
name|NUL
condition|)
block|{
if|if
condition|(
name|tl
operator|==
literal|1
condition|)
name|printf
argument_list|(
literal|"or the token '%c'\n"
argument_list|,
operator|*
name|tok
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|tl
operator|>
literal|1
condition|)
name|printf
argument_list|(
literal|"or one of the tokens '%s'\n"
argument_list|,
name|tok
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"%s%s"
argument_list|,
name|cmprom
argument_list|,
name|cmdbuf
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"\n%d - Unexpected return code from gtword\n"
argument_list|,
name|zz
argument_list|)
expr_stmt|;
return|return
operator|(
name|cmflgs
operator|=
operator|-
literal|2
operator|)
return|;
block|}
name|zz
operator|=
name|gtword
argument_list|()
expr_stmt|;
block|}
block|}
end_block

begin_function
name|int
name|chktok
parameter_list|(
name|tlist
parameter_list|)
name|char
modifier|*
name|tlist
decl_stmt|;
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|tlist
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|!=
name|NUL
operator|&&
operator|*
name|p
operator|!=
operator|*
name|atmbuf
condition|)
name|p
operator|++
expr_stmt|;
return|return
operator|(
operator|(
operator|*
name|p
operator|)
condition|?
operator|(
name|int
operator|)
operator|*
name|p
else|:
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  C M C F M  --  Parse command confirmation (end of line)  */
end_comment

begin_comment
comment|/*  Returns    -2: User typed anything but whitespace or newline    -1: Reparse needed     0: Confirmation was received */
end_comment

begin_function
name|int
name|cmcfm
parameter_list|()
block|{
name|int
name|x
decl_stmt|,
name|xc
decl_stmt|;
name|debug
argument_list|(
name|F101
argument_list|,
literal|"cmcfm: cmflgs"
argument_list|,
literal|""
argument_list|,
name|cmflgs
argument_list|)
expr_stmt|;
name|debug
argument_list|(
name|F110
argument_list|,
literal|"cmcfm: atmbuf"
argument_list|,
name|atmbuf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|inword
operator|=
name|xc
operator|=
name|cc
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|cmflgs
operator|==
literal|1
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|setatm
argument_list|(
literal|""
argument_list|)
expr_stmt|;
comment|/* (Probably unnecessary) */
while|while
condition|(
literal|1
condition|)
block|{
name|x
operator|=
name|gtword
argument_list|()
expr_stmt|;
name|xc
operator|+=
name|cc
expr_stmt|;
switch|switch
condition|(
name|x
condition|)
block|{
case|case
operator|-
literal|4
case|:
comment|/* EOF */
case|case
operator|-
literal|2
case|:
case|case
operator|-
literal|1
case|:
return|return
operator|(
name|x
operator|)
return|;
case|case
literal|1
case|:
comment|/* End of line */
if|if
condition|(
name|xc
operator|>
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"?Not confirmed - %s\n"
argument_list|,
name|atmbuf
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|9
operator|)
return|;
block|}
else|else
return|return
operator|(
literal|0
operator|)
return|;
case|case
literal|2
case|:
comment|/* ESC */
if|if
condition|(
name|xc
operator|==
literal|0
condition|)
block|{
name|putchar
argument_list|(
name|BEL
argument_list|)
expr_stmt|;
comment|/* beep& continue */
continue|continue;
comment|/* or fall thru. */
block|}
case|case
literal|0
case|:
comment|/* Space */
if|if
condition|(
name|xc
operator|==
literal|0
condition|)
comment|/* If no chars typed, continue, */
continue|continue;
comment|/* else fall thru. */
case|case
literal|3
case|:
comment|/* Question mark */
if|if
condition|(
name|xc
operator|>
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"?Not confirmed - %s\n"
argument_list|,
name|atmbuf
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|9
operator|)
return|;
block|}
name|printf
argument_list|(
literal|"\n Type a carriage return to confirm the command\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s%s"
argument_list|,
name|cmprom
argument_list|,
name|cmdbuf
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Keyword help routines */
end_comment

begin_comment
comment|/*  C L R H L P -- Initialize/Clear the help line buffer  */
end_comment

begin_function
name|VOID
name|clrhlp
parameter_list|()
block|{
comment|/* Clear the help buffer */
name|hlpbuf
index|[
literal|0
index|]
operator|=
name|NUL
expr_stmt|;
name|hh
operator|=
name|hx
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  A D D H L P  --  Add a string to the help line buffer  */
end_comment

begin_function
name|VOID
name|addhlp
parameter_list|(
name|s
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
block|{
comment|/* Add a word to the help buffer */
name|int
name|j
decl_stmt|;
name|hh
operator|++
expr_stmt|;
comment|/* Count this column */
for|for
control|(
name|j
operator|=
literal|0
init|;
operator|(
name|j
operator|<
name|hc
operator|)
operator|&&
operator|(
operator|*
name|s
operator|!=
name|NUL
operator|)
condition|;
name|j
operator|++
control|)
block|{
comment|/* Fill the column */
name|hlpbuf
index|[
name|hx
operator|++
index|]
operator|=
operator|*
name|s
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|s
operator|!=
name|NUL
condition|)
comment|/* Still some chars left in string? */
name|hlpbuf
index|[
name|hx
operator|-
literal|1
index|]
operator|=
literal|'+'
expr_stmt|;
comment|/* Mark as too long for column. */
if|if
condition|(
name|hh
operator|<
operator|(
name|hw
operator|/
name|hc
operator|)
condition|)
block|{
comment|/* Pad col with spaces if necessary */
for|for
control|(
init|;
name|j
operator|<
name|hc
condition|;
name|j
operator|++
control|)
block|{
name|hlpbuf
index|[
name|hx
operator|++
index|]
operator|=
name|SP
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* If last column, */
name|hlpbuf
index|[
name|hx
operator|++
index|]
operator|=
name|NUL
expr_stmt|;
comment|/* no spaces. */
name|dmphlp
argument_list|()
expr_stmt|;
comment|/* Print it. */
return|return;
block|}
block|}
end_function

begin_comment
comment|/*  D M P H L P  --  Dump the help line buffer  */
end_comment

begin_function
name|VOID
name|dmphlp
parameter_list|()
block|{
comment|/* Print the help buffer */
name|hlpbuf
index|[
name|hx
operator|++
index|]
operator|=
name|NUL
expr_stmt|;
name|printf
argument_list|(
literal|" %s\n"
argument_list|,
name|hlpbuf
argument_list|)
expr_stmt|;
name|clrhlp
argument_list|()
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  G T W O R D  --  Gets a "word" from the command input stream  */
end_comment

begin_comment
comment|/* Usage: retcode = gtword();   Returns:  -4 if end of file (e.g. pipe broken)  -2 if command buffer overflows  -1 if user did some deleting   0 if word terminates with SP or tab   1 if ... CR   2 if ... ESC   3 if ... ? (question mark)   With:   pp pointing to beginning of word in buffer   bp pointing to after current position   atmbuf containing a copy of the word   cc containing the number of characters in the word copied to atmbuf */
end_comment

begin_function
name|int
name|ungword
parameter_list|()
block|{
comment|/* unget a word */
if|if
condition|(
name|ungw
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|cmfsav
operator|=
name|cmflgs
expr_stmt|;
name|debug
argument_list|(
name|F101
argument_list|,
literal|"ungword cmflgs"
argument_list|,
literal|""
argument_list|,
name|cmflgs
argument_list|)
expr_stmt|;
name|ungw
operator|=
literal|1
expr_stmt|;
name|cmflgs
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|gtword
parameter_list|()
block|{
name|int
name|c
decl_stmt|;
comment|/* Current char */
name|int
name|quote
init|=
literal|0
decl_stmt|;
comment|/* Flag for quote character */
name|int
name|echof
init|=
literal|0
decl_stmt|;
comment|/* Flag for whether to echo */
name|int
name|chsrc
init|=
literal|0
decl_stmt|;
comment|/* Source of character, 1 = tty */
name|int
name|comment
init|=
literal|0
decl_stmt|;
comment|/* Flag for in comment */
name|char
modifier|*
name|cp
init|=
name|NULL
decl_stmt|;
comment|/* Comment pointer */
ifdef|#
directive|ifdef
name|RTU
specifier|extern
name|int
name|rtu_bug
decl_stmt|;
endif|#
directive|endif
comment|/* RTU */
ifdef|#
directive|ifdef
name|datageneral
specifier|extern
name|int
name|termtype
decl_stmt|;
comment|/* DG terminal type flag */
specifier|extern
name|int
name|con_reads_mt
decl_stmt|;
comment|/* Console read asynch is active */
if|if
condition|(
name|con_reads_mt
condition|)
name|connoi_mt
argument_list|()
expr_stmt|;
comment|/* Task would interfere w/cons read */
endif|#
directive|endif
comment|/* datageneral */
if|if
condition|(
name|ungw
condition|)
block|{
comment|/* Have a word saved? */
name|debug
argument_list|(
name|F110
argument_list|,
literal|"gtword ungetting from pp"
argument_list|,
name|pp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|pp
operator|++
operator|==
name|SP
condition|)
empty_stmt|;
name|setatm
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|ungw
operator|=
literal|0
expr_stmt|;
name|cmflgs
operator|=
name|cmfsav
expr_stmt|;
name|debug
argument_list|(
name|F111
argument_list|,
literal|"gtword returning atmbuf"
argument_list|,
name|atmbuf
argument_list|,
name|cmflgs
argument_list|)
expr_stmt|;
return|return
operator|(
name|cmflgs
operator|)
return|;
block|}
name|pp
operator|=
name|np
expr_stmt|;
comment|/* Start of current field */
name|debug
argument_list|(
name|F111
argument_list|,
literal|"gtword: cmdbuf"
argument_list|,
name|cmdbuf
argument_list|,
name|cmdbuf
argument_list|)
expr_stmt|;
name|debug
argument_list|(
name|F111
argument_list|,
literal|" bp"
argument_list|,
name|bp
argument_list|,
name|bp
argument_list|)
expr_stmt|;
name|debug
argument_list|(
name|F111
argument_list|,
literal|" pp"
argument_list|,
name|pp
argument_list|,
name|pp
argument_list|)
expr_stmt|;
while|while
condition|(
name|bp
operator|<
name|cmdbuf
operator|+
name|CMDBL
condition|)
block|{
comment|/* Big get-a-character loop */
name|echof
operator|=
literal|0
expr_stmt|;
comment|/* Assume we don't echo because */
name|chsrc
operator|=
literal|0
expr_stmt|;
comment|/* character came from reparse buf. */
if|if
condition|(
operator|(
name|c
operator|=
operator|*
name|bp
operator|)
operator|==
name|NUL
condition|)
block|{
comment|/* If no char waiting in reparse buf */
if|if
condition|(
name|dpx
condition|)
name|echof
operator|=
literal|1
expr_stmt|;
comment|/* must get from tty, set echo flag. */
name|c
operator|=
name|cmdgetc
argument_list|()
expr_stmt|;
comment|/* Read a character from the tty. */
name|chsrc
operator|=
literal|1
expr_stmt|;
comment|/* Remember character source is tty. */
ifdef|#
directive|ifdef
name|MAC
if|if
condition|(
name|c
operator|==
operator|-
literal|3
condition|)
comment|/* If null command... */
return|return
operator|(
operator|-
literal|3
operator|)
return|;
endif|#
directive|endif
comment|/* MAC */
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
block|{
comment|/* This can happen if stdin not tty. */
ifdef|#
directive|ifdef
name|EINTR
if|if
condition|(
name|errno
operator|==
name|EINTR
condition|)
comment|/* This is for when bg'd process is */
continue|continue;
comment|/* fg'd again. */
endif|#
directive|endif
comment|/* EINTR */
return|return
operator|(
operator|-
literal|4
operator|)
return|;
block|}
name|c
operator|&=
name|cmdmsk
expr_stmt|;
comment|/* Strip any parity bit */
block|}
comment|/* if desired. */
ifndef|#
directive|ifndef
name|MAC
name|debug
argument_list|(
name|F000
argument_list|,
literal|"gtword char"
argument_list|,
literal|""
argument_list|,
name|c
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* MAC */
comment|/* Now we have the next character */
if|if
condition|(
name|quote
operator|==
literal|0
condition|)
block|{
comment|/* If this is not a quoted character */
if|if
condition|(
name|c
operator|==
name|CMDQ
condition|)
block|{
comment|/* Got the quote character itself */
if|if
condition|(
operator|!
name|comment
condition|)
name|quote
operator|=
literal|1
expr_stmt|;
comment|/* Flag it if not in a comment */
block|}
if|if
condition|(
name|c
operator|==
name|FF
condition|)
block|{
comment|/* Formfeed. */
name|c
operator|=
name|NL
expr_stmt|;
comment|/* Replace with newline */
ifdef|#
directive|ifdef
name|COMMENT
comment|/* No more screen clearing... */
name|cmdclrscn
argument_list|()
expr_stmt|;
comment|/* Clear the screen */
endif|#
directive|endif
comment|/* COMMENT */
block|}
if|if
condition|(
name|c
operator|==
name|HT
condition|)
block|{
comment|/* Tab */
if|if
condition|(
name|comment
condition|)
comment|/* If in comment, */
name|c
operator|=
name|SP
expr_stmt|;
comment|/* substitute space */
else|else
comment|/* otherwise */
name|c
operator|=
name|ESC
expr_stmt|;
comment|/* substitute ESC (for completion) */
block|}
if|if
condition|(
name|c
operator|==
literal|';'
operator|||
name|c
operator|==
literal|'#'
condition|)
block|{
comment|/* Trailing comment */
if|if
condition|(
name|inword
operator|==
literal|0
condition|)
block|{
comment|/* If we're not in a word */
name|comment
operator|=
literal|1
expr_stmt|;
comment|/* start a comment. */
name|cp
operator|=
name|bp
expr_stmt|;
comment|/* remember where it starts. */
block|}
block|}
if|if
condition|(
operator|!
name|comment
operator|&&
name|c
operator|==
name|SP
condition|)
block|{
comment|/* Space */
operator|*
name|bp
operator|++
operator|=
name|c
expr_stmt|;
comment|/* deposit in buffer if not already */
if|if
condition|(
name|echof
condition|)
name|putchar
argument_list|(
name|c
argument_list|)
expr_stmt|;
comment|/* echo it. */
if|if
condition|(
name|inword
operator|==
literal|0
condition|)
block|{
comment|/* If leading, gobble it. */
name|pp
operator|++
expr_stmt|;
continue|continue;
block|}
else|else
block|{
comment|/* If terminating, return. */
name|np
operator|=
name|bp
expr_stmt|;
name|setatm
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|inword
operator|=
name|cmflgs
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
if|if
condition|(
name|c
operator|==
name|NL
operator|||
name|c
operator|==
name|CR
condition|)
block|{
comment|/* CR or LF. */
if|if
condition|(
name|echof
condition|)
name|cmdnewl
argument_list|(
operator|(
name|char
operator|)
name|c
argument_list|)
expr_stmt|;
comment|/* Echo it. */
while|while
condition|(
name|bp
operator|>
name|pp
operator|&&
operator|(
operator|*
operator|(
name|bp
operator|-
literal|1
operator|)
operator|==
name|SP
operator|||
operator|*
operator|(
name|bp
operator|-
literal|1
operator|)
operator|==
name|HT
operator|)
condition|)
comment|/* Trim */
name|bp
operator|--
expr_stmt|;
comment|/* trailing */
operator|*
name|bp
operator|=
name|NUL
expr_stmt|;
comment|/* whitespace */
if|if
condition|(
operator|*
operator|(
name|bp
operator|-
literal|1
operator|)
operator|==
literal|'-'
condition|)
block|{
comment|/* Is this line continued? */
if|if
condition|(
name|chsrc
condition|)
block|{
comment|/* If reading from tty, */
ifdef|#
directive|ifdef
name|COMMENT
name|bp
operator|--
operator|,
name|pp
operator|--
expr_stmt|;
comment|/* back up the buffer pointer, */
else|#
directive|else
name|bp
operator|--
expr_stmt|;
endif|#
directive|endif
comment|/* COMMENT */
operator|*
name|bp
operator|=
name|NUL
expr_stmt|;
comment|/* erase the dash, */
continue|continue;
comment|/* and go back for next char now. */
block|}
block|}
else|else
block|{
comment|/* No, a command has been entered. */
operator|*
name|bp
operator|=
name|NUL
expr_stmt|;
comment|/* Terminate the command string. */
if|if
condition|(
name|comment
condition|)
block|{
comment|/* If we're in a comment, */
name|comment
operator|=
literal|0
expr_stmt|;
comment|/* Say we're not any more, */
operator|*
name|cp
operator|=
name|NUL
expr_stmt|;
comment|/* cut it off. */
block|}
name|np
operator|=
name|bp
expr_stmt|;
comment|/* Where to start next field. */
name|setatm
argument_list|(
name|pp
argument_list|)
expr_stmt|;
comment|/* Copy this field to atom buffer. */
name|inword
operator|=
literal|0
expr_stmt|;
comment|/* Not in a word any more. */
return|return
operator|(
name|cmflgs
operator|=
literal|1
operator|)
return|;
block|}
block|}
if|if
condition|(
operator|!
name|comment
operator|&&
name|echof
operator|&&
operator|(
name|c
operator|==
literal|'?'
operator|)
condition|)
block|{
comment|/* Question mark */
name|putchar
argument_list|(
name|c
argument_list|)
expr_stmt|;
operator|*
name|bp
operator|=
name|NUL
expr_stmt|;
name|setatm
argument_list|(
name|pp
argument_list|)
expr_stmt|;
return|return
operator|(
name|cmflgs
operator|=
literal|3
operator|)
return|;
block|}
if|if
condition|(
name|c
operator|==
name|ESC
condition|)
block|{
comment|/* ESC */
if|if
condition|(
operator|!
name|comment
condition|)
block|{
operator|*
name|bp
operator|=
name|NUL
expr_stmt|;
name|setatm
argument_list|(
name|pp
argument_list|)
expr_stmt|;
return|return
operator|(
name|cmflgs
operator|=
literal|2
operator|)
return|;
block|}
else|else
block|{
name|putchar
argument_list|(
name|BEL
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
if|if
condition|(
name|c
operator|==
name|BS
operator|||
name|c
operator|==
name|RUB
condition|)
block|{
comment|/* Character deletion */
if|if
condition|(
name|bp
operator|>
name|cmdbuf
condition|)
block|{
comment|/* If still in buffer... */
name|cmdchardel
argument_list|()
expr_stmt|;
comment|/* erase it. */
name|bp
operator|--
expr_stmt|;
comment|/* point behind it, */
if|if
condition|(
operator|*
name|bp
operator|==
name|SP
condition|)
name|inword
operator|=
literal|0
expr_stmt|;
comment|/* Flag if current field gone */
operator|*
name|bp
operator|=
name|NUL
expr_stmt|;
comment|/* Erase character from buffer. */
block|}
else|else
block|{
comment|/* Otherwise, */
name|putchar
argument_list|(
name|BEL
argument_list|)
expr_stmt|;
comment|/* beep, */
name|cmres
argument_list|()
expr_stmt|;
comment|/* and start parsing a new command. */
operator|*
name|bp
operator|=
operator|*
name|atmbuf
operator|=
name|NUL
expr_stmt|;
block|}
if|if
condition|(
name|pp
operator|<
name|bp
condition|)
continue|continue;
else|else
return|return
operator|(
name|cmflgs
operator|=
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|c
operator|==
name|LDEL
condition|)
block|{
comment|/* ^U, line deletion */
while|while
condition|(
operator|(
name|bp
operator|--
operator|)
operator|>
name|cmdbuf
condition|)
block|{
name|cmdchardel
argument_list|()
expr_stmt|;
operator|*
name|bp
operator|=
name|NUL
expr_stmt|;
block|}
name|cmres
argument_list|()
expr_stmt|;
comment|/* Restart the command. */
operator|*
name|bp
operator|=
operator|*
name|atmbuf
operator|=
name|NUL
expr_stmt|;
name|inword
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|cmflgs
operator|=
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|c
operator|==
name|WDEL
condition|)
block|{
comment|/* ^W, word deletion */
if|if
condition|(
name|bp
operator|<=
name|cmdbuf
condition|)
block|{
comment|/* Beep if nothing to delete */
name|putchar
argument_list|(
name|BEL
argument_list|)
expr_stmt|;
name|cmres
argument_list|()
expr_stmt|;
operator|*
name|bp
operator|=
operator|*
name|atmbuf
operator|=
name|NUL
expr_stmt|;
return|return
operator|(
name|cmflgs
operator|=
operator|-
literal|1
operator|)
return|;
block|}
name|bp
operator|--
expr_stmt|;
for|for
control|(
init|;
operator|(
name|bp
operator|>=
name|cmdbuf
operator|)
operator|&&
operator|(
operator|*
name|bp
operator|==
name|SP
operator|)
condition|;
name|bp
operator|--
control|)
block|{
name|cmdchardel
argument_list|()
expr_stmt|;
operator|*
name|bp
operator|=
name|NUL
expr_stmt|;
block|}
for|for
control|(
init|;
operator|(
name|bp
operator|>=
name|cmdbuf
operator|)
operator|&&
operator|(
operator|*
name|bp
operator|!=
name|SP
operator|)
condition|;
name|bp
operator|--
control|)
block|{
name|cmdchardel
argument_list|()
expr_stmt|;
operator|*
name|bp
operator|=
name|NUL
expr_stmt|;
block|}
name|bp
operator|++
expr_stmt|;
name|inword
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|cmflgs
operator|=
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|c
operator|==
name|RDIS
condition|)
block|{
comment|/* ^R, redisplay */
ifdef|#
directive|ifdef
name|COMMENT
operator|*
name|bp
operator|=
name|NUL
expr_stmt|;
name|printf
argument_list|(
literal|"\n%s%s"
argument_list|,
name|cmprom
argument_list|,
name|cmdbuf
argument_list|)
expr_stmt|;
else|#
directive|else
name|char
modifier|*
name|cpx
decl_stmt|;
name|char
name|cx
decl_stmt|;
operator|*
name|bp
operator|=
name|NUL
expr_stmt|;
name|printf
argument_list|(
literal|"\n%s"
argument_list|,
name|cmprom
argument_list|)
expr_stmt|;
name|cpx
operator|=
name|cmdbuf
expr_stmt|;
while|while
condition|(
name|cx
operator|=
operator|*
name|cpx
operator|++
condition|)
block|{
ifdef|#
directive|ifdef
name|isprint
name|putchar
argument_list|(
name|isprint
argument_list|(
name|cx
argument_list|)
condition|?
name|cx
else|:
literal|'^'
argument_list|)
expr_stmt|;
else|#
directive|else
name|putchar
argument_list|(
operator|(
name|cx
operator|>=
name|SP
operator|&&
name|cx
operator|<
name|DEL
operator|)
condition|?
name|cx
else|:
literal|'^'
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* isprint */
block|}
endif|#
directive|endif
comment|/* COMMENT */
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|c
operator|<
name|SP
operator|&&
name|quote
operator|==
literal|0
condition|)
block|{
comment|/* Any other unquoted control char */
if|if
condition|(
operator|!
name|chsrc
condition|)
name|bp
operator|++
expr_stmt|;
comment|/* If cmd file, point past it */
else|else
name|putchar
argument_list|(
name|BEL
argument_list|)
expr_stmt|;
comment|/* otherwise just beep and */
continue|continue;
comment|/* continue, don't put in buffer */
block|}
if|if
condition|(
name|echof
condition|)
name|cmdecho
argument_list|(
operator|(
name|char
operator|)
name|c
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Echo what was typed. */
block|}
else|else
block|{
comment|/* This character was quoted. */
name|int
name|qf
init|=
literal|1
decl_stmt|;
name|quote
operator|=
literal|0
expr_stmt|;
comment|/* Unset the quote flag. */
comment|/* Quote character at this level is only for SP, ?, and controls */
comment|/* If anything else was quoted, leave quote in, and let */
comment|/* the command-specific parsing routines handle it, e.g. \007 */
if|if
condition|(
name|c
operator|>
literal|32
operator|&&
name|c
operator|!=
literal|'?'
operator|&&
name|c
operator|!=
name|RUB
operator|&&
name|chsrc
operator|!=
literal|0
condition|)
block|{
operator|*
name|bp
operator|++
operator|=
name|CMDQ
expr_stmt|;
comment|/* Deposit \ if it came from tty */
name|qf
operator|=
literal|0
expr_stmt|;
comment|/* and don't erase it from screen */
block|}
if|if
condition|(
name|echof
condition|)
name|cmdecho
argument_list|(
operator|(
name|char
operator|)
name|c
argument_list|,
name|qf
argument_list|)
expr_stmt|;
comment|/* Now echo quoted character */
name|debug
argument_list|(
name|F000
argument_list|,
literal|"gtword quote"
argument_list|,
name|cmdbuf
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|COMMENT
if|if
condition|(
name|echof
condition|)
name|cmdecho
argument_list|(
operator|(
name|char
operator|)
name|c
argument_list|,
name|quote
argument_list|)
expr_stmt|;
comment|/* Echo what was typed. */
endif|#
directive|endif
comment|/* COMMENT */
if|if
condition|(
operator|!
name|comment
condition|)
name|inword
operator|=
literal|1
expr_stmt|;
comment|/* Flag we're in a word. */
if|if
condition|(
name|quote
condition|)
continue|continue;
comment|/* Don't deposit quote character. */
if|if
condition|(
name|c
operator|!=
name|NL
condition|)
operator|*
name|bp
operator|++
operator|=
name|c
expr_stmt|;
comment|/* Deposit command character. */
block|}
comment|/* End of big while */
name|putchar
argument_list|(
name|BEL
argument_list|)
expr_stmt|;
comment|/* Get here if... */
name|printf
argument_list|(
literal|"?Command too long, maximum length: %d.\n"
argument_list|,
name|CMDBL
argument_list|)
expr_stmt|;
name|cmflgs
operator|=
operator|-
literal|2
expr_stmt|;
return|return
operator|(
operator|-
literal|9
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Utility functions */
end_comment

begin_comment
comment|/* A D D B U F  -- Add the string pointed to by cp to the command buffer  */
end_comment

begin_function
name|int
name|addbuf
parameter_list|(
name|cp
parameter_list|)
name|char
modifier|*
name|cp
decl_stmt|;
block|{
name|int
name|len
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|(
operator|*
name|cp
operator|!=
name|NUL
operator|)
operator|&&
operator|(
name|bp
operator|<
name|cmdbuf
operator|+
name|CMDBL
operator|)
condition|)
block|{
operator|*
name|bp
operator|++
operator|=
operator|*
name|cp
operator|++
expr_stmt|;
comment|/* Copy and */
name|len
operator|++
expr_stmt|;
comment|/* count the characters. */
block|}
operator|*
name|bp
operator|++
operator|=
name|SP
expr_stmt|;
comment|/* Put a space at the end */
operator|*
name|bp
operator|=
name|NUL
expr_stmt|;
comment|/* Terminate with a null */
name|np
operator|=
name|bp
expr_stmt|;
comment|/* Update the next-field pointer */
return|return
operator|(
name|len
operator|)
return|;
comment|/* Return the length */
block|}
end_function

begin_comment
comment|/*  S E T A T M  --  Deposit a token in the atom buffer.  */
end_comment

begin_comment
comment|/*  Break on space, newline, carriage return, or null. */
end_comment

begin_comment
comment|/*  Null-terminate the result. */
end_comment

begin_comment
comment|/*  If the source pointer is the atom buffer itself, do nothing. */
end_comment

begin_comment
comment|/*  Return length of token, and also set global "cc" to this length. */
end_comment

begin_function
name|int
name|setatm
parameter_list|(
name|cp
parameter_list|)
name|char
modifier|*
name|cp
decl_stmt|;
block|{
name|char
modifier|*
name|ap
decl_stmt|,
modifier|*
name|xp
decl_stmt|;
name|cc
operator|=
literal|0
expr_stmt|;
comment|/* Character counter */
name|ap
operator|=
name|atmbuf
expr_stmt|;
comment|/* Address of atom buffer */
if|if
condition|(
name|cp
operator|==
name|ap
condition|)
block|{
comment|/* In case source is atom buffer */
name|xp
operator|=
name|atybuf
expr_stmt|;
comment|/* make a copy */
name|strcpy
argument_list|(
name|xp
argument_list|,
name|ap
argument_list|)
expr_stmt|;
comment|/* so we can copy it back, edited. */
name|cp
operator|=
name|xp
expr_stmt|;
block|}
operator|*
name|ap
operator|=
name|NUL
expr_stmt|;
comment|/* Zero the atom buffer */
while|while
condition|(
operator|*
name|cp
operator|==
name|SP
condition|)
name|cp
operator|++
expr_stmt|;
comment|/* Trim leading spaces */
while|while
condition|(
operator|(
operator|*
name|cp
operator|!=
name|SP
operator|)
operator|&&
operator|(
operator|*
name|cp
operator|!=
name|NL
operator|)
operator|&&
operator|(
operator|*
name|cp
operator|!=
name|NUL
operator|)
operator|&&
operator|(
operator|*
name|cp
operator|!=
name|CR
operator|)
condition|)
block|{
operator|*
name|ap
operator|++
operator|=
operator|*
name|cp
operator|++
expr_stmt|;
comment|/* Copy up to SP, NL, CR, or end */
name|cc
operator|++
expr_stmt|;
comment|/* and count */
block|}
operator|*
name|ap
operator|=
name|NUL
expr_stmt|;
comment|/* Terminate the string. */
return|return
operator|(
name|cc
operator|)
return|;
comment|/* Return length. */
block|}
end_function

begin_comment
comment|/*  R D I G I T S  -- Verify that all the characters in line ARE DIGITS  */
end_comment

begin_function
name|int
name|rdigits
parameter_list|(
name|s
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
block|{
while|while
condition|(
operator|*
name|s
condition|)
block|{
if|if
condition|(
operator|!
name|isdigit
argument_list|(
operator|*
name|s
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|s
operator|++
expr_stmt|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* These functions attempt to hide system dependencies from the mainline */
end_comment

begin_comment
comment|/* code in gtword().  Ultimately they should be moved to ck?tio.c, where */
end_comment

begin_comment
comment|/* ? = each and every system supported by C-Kermit. */
end_comment

begin_function
name|int
name|cmdgetc
parameter_list|()
block|{
comment|/* Get a character from the tty. */
name|int
name|c
decl_stmt|;
ifdef|#
directive|ifdef
name|datageneral
block|{
name|char
name|ch
decl_stmt|;
name|c
operator|=
name|dgncinb
argument_list|(
literal|0
argument_list|,
operator|&
name|ch
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* -1 is EOF, -2 TO,                                           * -c is AOS/VS error */
if|if
condition|(
name|c
operator|==
operator|-
literal|2
condition|)
block|{
comment|/* timeout was enabled? */
name|resto
argument_list|(
name|channel
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
comment|/* reset timeouts */
name|c
operator|=
name|dgncinb
argument_list|(
literal|0
argument_list|,
operator|&
name|ch
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* retry this now! */
block|}
if|if
condition|(
name|c
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|4
operator|)
return|;
comment|/* EOF or some error */
else|else
name|c
operator|=
operator|(
name|int
operator|)
name|ch
operator|&
literal|0177
expr_stmt|;
comment|/* Get char without parity */
comment|/*	echof = 1; */
block|}
else|#
directive|else
comment|/* Not datageneral */
ifdef|#
directive|ifdef
name|GEMDOS
name|c
operator|=
name|isatty
argument_list|(
literal|0
argument_list|)
condition|?
name|coninc
argument_list|(
literal|0
argument_list|)
else|:
name|getchar
argument_list|()
expr_stmt|;
else|#
directive|else
ifdef|#
directive|ifdef
name|OS2
name|c
operator|=
name|isatty
argument_list|(
literal|0
argument_list|)
condition|?
name|coninc
argument_list|(
literal|0
argument_list|)
else|:
name|getchar
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|4
operator|)
return|;
else|#
directive|else
comment|/* Not OS2 */
name|c
operator|=
name|getchar
argument_list|()
expr_stmt|;
comment|/* or from tty. */
ifdef|#
directive|ifdef
name|RTU
if|if
condition|(
name|rtu_bug
condition|)
block|{
name|c
operator|=
name|getchar
argument_list|()
expr_stmt|;
comment|/* RTU doesn't discard the ^Z */
name|rtu_bug
operator|=
literal|0
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* RTU */
endif|#
directive|endif
comment|/* OS2 */
endif|#
directive|endif
comment|/* GEMDOS */
endif|#
directive|endif
comment|/* datageneral */
return|return
operator|(
name|c
operator|)
return|;
comment|/* Return what we got */
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|COMMENT
end_ifdef

begin_comment
comment|/*   No more screen clearing.  If you wanna clear the screen, define a macro   to do it, like "define cls write screen \27[;H\27[2J". */
end_comment

begin_macro
name|cmdclrscn
argument_list|()
end_macro

begin_block
block|{
comment|/* Clear the screen */
ifdef|#
directive|ifdef
name|aegis
name|putchar
argument_list|(
name|FF
argument_list|)
expr_stmt|;
else|#
directive|else
ifdef|#
directive|ifdef
name|AMIGA
name|putchar
argument_list|(
name|FF
argument_list|)
expr_stmt|;
else|#
directive|else
ifdef|#
directive|ifdef
name|OSK
name|putchar
argument_list|(
name|FF
argument_list|)
expr_stmt|;
else|#
directive|else
ifdef|#
directive|ifdef
name|datageneral
name|putchar
argument_list|(
name|FF
argument_list|)
expr_stmt|;
else|#
directive|else
ifdef|#
directive|ifdef
name|OS2
name|zsystem
argument_list|(
literal|"cls"
argument_list|)
expr_stmt|;
else|#
directive|else
name|zsystem
argument_list|(
literal|"clear"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* OS2 */
endif|#
directive|endif
comment|/* datageneral */
endif|#
directive|endif
comment|/* OSK */
endif|#
directive|endif
comment|/* AMIGA */
endif|#
directive|endif
comment|/* aegis */
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* COMMENT */
end_comment

begin_function
name|VOID
comment|/* What to echo at end of command */
ifdef|#
directive|ifdef
name|CK_ANSIC
name|cmdnewl
parameter_list|(
name|char
name|c
parameter_list|)
else|#
directive|else
function|cmdnewl
parameter_list|(
name|c
parameter_list|)
name|char
name|c
decl_stmt|;
endif|#
directive|endif
comment|/* CK_ANSIC */
comment|/* cmdnewl */
block|{
name|putchar
argument_list|(
name|c
argument_list|)
expr_stmt|;
comment|/* c is the terminating character */
ifdef|#
directive|ifdef
name|WINTCP
if|if
condition|(
name|c
operator|==
name|CR
condition|)
name|putchar
argument_list|(
name|NL
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* WINTCP */
ifdef|#
directive|ifdef
name|OS2
if|if
condition|(
name|c
operator|==
name|CR
condition|)
name|putchar
argument_list|(
name|NL
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* OS2 */
ifdef|#
directive|ifdef
name|aegis
if|if
condition|(
name|c
operator|==
name|CR
condition|)
name|putchar
argument_list|(
name|NL
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* aegis */
ifdef|#
directive|ifdef
name|AMIGA
if|if
condition|(
name|c
operator|==
name|CR
condition|)
name|putchar
argument_list|(
name|NL
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* AMIGA */
ifdef|#
directive|ifdef
name|datageneral
if|if
condition|(
name|c
operator|==
name|CR
condition|)
name|putchar
argument_list|(
name|NL
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* datageneral */
ifdef|#
directive|ifdef
name|GEMDOS
if|if
condition|(
name|c
operator|==
name|CR
condition|)
name|putchar
argument_list|(
name|NL
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* GEMDOS */
block|}
end_function

begin_function
name|VOID
name|cmdchardel
parameter_list|()
block|{
comment|/* Erase a character from the screen */
if|if
condition|(
operator|!
name|dpx
condition|)
return|return;
ifdef|#
directive|ifdef
name|datageneral
comment|/* DG '\b' is EM (^y or \031) */
if|if
condition|(
name|termtype
operator|==
literal|1
condition|)
comment|/* Erase a character from non-DG screen, */
name|dgncoub
argument_list|(
literal|1
argument_list|,
literal|"\010 \010"
argument_list|,
literal|3
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
name|printf
argument_list|(
literal|"\b \b"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|GEMDOS
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* GEMDOS */
block|}
end_function

begin_function
name|VOID
ifdef|#
directive|ifdef
name|CK_ANSIC
name|cmdecho
parameter_list|(
name|char
name|c
parameter_list|,
name|int
name|quote
parameter_list|)
else|#
directive|else
function|cmdecho
parameter_list|(
name|c
parameter_list|,
name|quote
parameter_list|)
name|char
name|c
decl_stmt|;
name|int
name|quote
decl_stmt|;
endif|#
directive|endif
comment|/* CK_ANSIC */
block|{
comment|/* cmdecho */
if|if
condition|(
operator|!
name|dpx
condition|)
return|return;
comment|/* Echo tty input character c */
if|if
condition|(
name|quote
condition|)
block|{
name|putchar
argument_list|(
name|BS
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
name|SP
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
name|BS
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|isprint
name|putchar
argument_list|(
name|isprint
argument_list|(
name|c
argument_list|)
condition|?
name|c
else|:
literal|'^'
argument_list|)
expr_stmt|;
else|#
directive|else
name|putchar
argument_list|(
operator|(
name|c
operator|>=
name|SP
operator|&&
name|c
operator|<
name|DEL
operator|)
condition|?
name|c
else|:
literal|'^'
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* isprint */
block|}
else|else
name|putchar
argument_list|(
name|c
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|OS2
if|if
condition|(
name|quote
operator|==
literal|1
operator|&&
name|c
operator|==
name|CR
condition|)
name|putchar
argument_list|(
name|NL
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* OS2 */
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NOICP */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|NOICP
end_ifdef

begin_include
include|#
directive|include
file|"ckcdeb.h"
end_include

begin_include
include|#
directive|include
file|"ckucmd.h"
end_include

begin_include
include|#
directive|include
file|"ckcasc.h"
end_include

begin_comment
comment|/*** #include<ctype.h> (ckcdeb.h already includes this) ***/
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NOICP */
end_comment

begin_comment
comment|/*  X X E S C  --  Interprets backslash codes  */
end_comment

begin_comment
comment|/*  Returns the int value of the backslash code if it is> -1 and< 256 */
end_comment

begin_comment
comment|/*  and updates the string pointer to first character after backslash code. */
end_comment

begin_comment
comment|/*  If the argument is invalid, leaves pointer unchanged and returns -1. */
end_comment

begin_function
name|int
name|xxesc
parameter_list|(
name|s
parameter_list|)
name|char
modifier|*
modifier|*
name|s
decl_stmt|;
block|{
comment|/* Expand backslash escapes */
name|int
name|x
decl_stmt|,
name|y
decl_stmt|,
name|brace
decl_stmt|,
name|radix
decl_stmt|;
comment|/* Returns the int value */
name|char
name|hd
init|=
literal|'9'
decl_stmt|;
comment|/* Highest digit in radix */
name|char
modifier|*
name|p
decl_stmt|;
name|p
operator|=
operator|*
name|s
expr_stmt|;
comment|/* pointer to beginning */
if|if
condition|(
operator|!
name|p
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* watch out for null pointer */
name|x
operator|=
operator|*
name|p
operator|++
expr_stmt|;
comment|/* character at beginning */
if|if
condition|(
name|x
operator|!=
name|CMDQ
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* make sure it's a backslash code */
name|x
operator|=
operator|*
name|p
expr_stmt|;
comment|/* it is, get the next character */
if|if
condition|(
name|x
operator|==
literal|'{'
condition|)
block|{
comment|/* bracketed quantity? */
name|p
operator|++
expr_stmt|;
comment|/* begin past bracket */
name|x
operator|=
operator|*
name|p
expr_stmt|;
name|brace
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|brace
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|x
condition|)
block|{
comment|/* Start interpreting */
case|case
literal|'d'
case|:
comment|/* Decimal radix indicator */
case|case
literal|'D'
case|:
name|p
operator|++
expr_stmt|;
comment|/* Just point past it and fall thru */
case|case
literal|'0'
case|:
comment|/* Starts with digit */
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
name|radix
operator|=
literal|10
expr_stmt|;
comment|/* Decimal */
name|hd
operator|=
literal|'9'
expr_stmt|;
comment|/* highest valid digit */
break|break;
case|case
literal|'o'
case|:
comment|/* Starts with o or O */
case|case
literal|'O'
case|:
name|radix
operator|=
literal|8
expr_stmt|;
comment|/* Octal */
name|hd
operator|=
literal|'7'
expr_stmt|;
comment|/* highest valid digit */
name|p
operator|++
expr_stmt|;
comment|/* point past radix indicator */
break|break;
case|case
literal|'x'
case|:
comment|/* Starts with x or X */
case|case
literal|'X'
case|:
name|radix
operator|=
literal|16
expr_stmt|;
comment|/* Hexadecimal */
name|p
operator|++
expr_stmt|;
comment|/* point past radix indicator */
break|break;
default|default:
comment|/* All others */
ifdef|#
directive|ifdef
name|COMMENT
operator|*
name|s
operator|=
name|p
operator|+
literal|1
expr_stmt|;
comment|/* Treat as quote of next char */
return|return
operator|(
operator|*
name|p
operator|)
return|;
else|#
directive|else
return|return
operator|(
operator|-
literal|1
operator|)
return|;
endif|#
directive|endif
comment|/* COMMENT */
block|}
comment|/* For OS/2, there are "wide" characters required for the keyboard      * binding, i.e \644 and similar codes larger than 255 (byte).      * For this purpose, give up checking for< 256. If someone means      * \266 should result in \26 followed by a "6" character, he should      * always write \{26}6 anyway.  Now, return only the lower byte of      * the result, i.e. 10, but eat up the whole \266 sequence and      * put the wide result 266 into a global variable.  Yes, that's not      * the most beautiful programming style but requires the least      * amount of changes to other routines.      */
if|if
condition|(
name|radix
operator|<=
literal|10
condition|)
block|{
comment|/* Number in radix 8 or 10 */
for|for
control|(
name|x
operator|=
name|y
operator|=
literal|0
init|;
operator|(
operator|*
name|p
operator|)
operator|&&
operator|(
operator|*
name|p
operator|>=
literal|'0'
operator|)
operator|&&
operator|(
operator|*
name|p
operator|<=
name|hd
operator|)
ifdef|#
directive|ifdef
name|OS2
operator|&&
operator|(
name|y
operator|<
literal|4
operator|)
operator|&&
operator|(
name|x
operator|*
name|radix
operator|<
literal|768
operator|)
condition|;
comment|/* the maximum needed value \767 is still only 3 digits long */
comment|/* while as octal it requires \1377, i.e. 4 digits */
else|#
directive|else
operator|&&
operator|(
name|y
operator|<
literal|3
operator|)
operator|&&
operator|(
name|x
operator|*
name|radix
operator|<
literal|256
operator|)
incr|;
endif|#
directive|endif
comment|/* OS2 */
control|p++
operator|,
control|y++)
block|{
name|x
operator|=
name|x
operator|*
name|radix
operator|+
operator|(
name|int
operator|)
operator|*
name|p
operator|-
literal|48
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|OS2
name|wideresult
operator|=
name|x
expr_stmt|;
comment|/* Remember wide result */
name|x
operator|&=
literal|255
expr_stmt|;
endif|#
directive|endif
comment|/* OS2 */
if|if
condition|(
name|y
operator|==
literal|0
operator|||
name|x
operator|>
literal|255
condition|)
block|{
comment|/* No valid digits? */
operator|*
name|s
operator|=
name|p
expr_stmt|;
comment|/* point after it */
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* return failure. */
block|}
block|}
elseif|else
if|if
condition|(
name|radix
operator|==
literal|16
condition|)
block|{
comment|/* Special case for hex */
if|if
condition|(
operator|(
name|x
operator|=
name|unhex
argument_list|(
operator|*
name|p
operator|++
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
operator|*
name|s
operator|=
name|p
operator|-
literal|1
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|y
operator|=
name|unhex
argument_list|(
operator|*
name|p
operator|++
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
operator|*
name|s
operator|=
name|p
operator|-
literal|2
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|x
operator|=
operator|(
operator|(
name|x
operator|<<
literal|4
operator|)
operator|&
literal|0xF0
operator|)
operator||
operator|(
name|y
operator|&
literal|0x0F
operator|)
expr_stmt|;
ifdef|#
directive|ifdef
name|OS2
name|wideresult
operator|=
name|x
expr_stmt|;
if|if
condition|(
operator|(
name|y
operator|=
name|unhex
argument_list|(
operator|*
name|p
argument_list|)
operator|)
operator|>=
literal|0
condition|)
block|{
name|p
operator|++
expr_stmt|;
name|wideresult
operator|=
operator|(
operator|(
name|x
operator|<<
literal|4
operator|)
operator|&
literal|0xFF0
operator|)
operator||
operator|(
name|y
operator|&
literal|0x0F
operator|)
expr_stmt|;
name|x
operator|=
name|wideresult
operator|&
literal|255
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* OS2 */
block|}
else|else
name|x
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|brace
operator|&&
operator|*
name|p
operator|==
literal|'}'
operator|&&
name|x
operator|>
operator|-
literal|1
condition|)
comment|/* Point past closing brace, if any */
name|p
operator|++
expr_stmt|;
operator|*
name|s
operator|=
name|p
expr_stmt|;
comment|/* Point to next char after sequence */
return|return
operator|(
name|x
operator|)
return|;
comment|/* Return value of sequence */
block|}
end_function

begin_function
name|int
comment|/* Convert hex string to int */
ifdef|#
directive|ifdef
name|CK_ANSIC
name|unhex
parameter_list|(
name|char
name|x
parameter_list|)
else|#
directive|else
function|unhex
parameter_list|(
name|x
parameter_list|)
name|char
name|x
decl_stmt|;
endif|#
directive|endif
comment|/* CK_ANSIC */
comment|/* unhex */
block|{
if|if
condition|(
name|x
operator|>=
literal|'0'
operator|&&
name|x
operator|<=
literal|'9'
condition|)
comment|/* 0-9 is offset by hex 30 */
return|return
operator|(
name|x
operator|-
literal|0x30
operator|)
return|;
elseif|else
if|if
condition|(
name|x
operator|>=
literal|'A'
operator|&&
name|x
operator|<=
literal|'F'
condition|)
comment|/* A-F offset by hex 37 */
return|return
operator|(
name|x
operator|-
literal|0x37
operator|)
return|;
elseif|else
if|if
condition|(
name|x
operator|>=
literal|'a'
operator|&&
name|x
operator|<=
literal|'f'
condition|)
comment|/* a-f offset by hex 57 */
return|return
operator|(
name|x
operator|-
literal|0x57
operator|)
return|;
comment|/* (obviously ASCII dependent) */
else|else
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/* See if argument string is numeric */
end_comment

begin_comment
comment|/* Returns 1 if OK, zero if not OK */
end_comment

begin_comment
comment|/* If OK, string should be acceptable to atoi() */
end_comment

begin_comment
comment|/* Allows leading space, sign */
end_comment

begin_function
name|int
name|chknum
parameter_list|(
name|s
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
block|{
comment|/* Check Numeric String */
name|int
name|x
init|=
literal|0
decl_stmt|;
comment|/* Flag for past leading space */
name|int
name|y
init|=
literal|0
decl_stmt|;
comment|/* Flag for digit seen */
name|char
name|c
decl_stmt|;
name|debug
argument_list|(
name|F110
argument_list|,
literal|"chknum"
argument_list|,
name|s
argument_list|,
literal|0
argument_list|)
expr_stmt|;
while|while
condition|(
name|c
operator|=
operator|*
name|s
operator|++
condition|)
block|{
comment|/* For each character in the string */
switch|switch
condition|(
name|c
condition|)
block|{
case|case
name|SP
case|:
comment|/* Allow leading spaces */
case|case
name|HT
case|:
if|if
condition|(
name|x
operator|==
literal|0
condition|)
continue|continue;
else|else
return|return
operator|(
literal|0
operator|)
return|;
case|case
literal|'+'
case|:
comment|/* Allow leading sign */
case|case
literal|'-'
case|:
if|if
condition|(
name|x
operator|==
literal|0
condition|)
name|x
operator|=
literal|1
expr_stmt|;
else|else
return|return
operator|(
literal|0
operator|)
return|;
break|break;
default|default:
comment|/* After that, only decimal digits */
if|if
condition|(
name|c
operator|>=
literal|'0'
operator|&&
name|c
operator|<=
literal|'9'
condition|)
block|{
name|x
operator|=
name|y
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
else|else
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
return|return
operator|(
name|y
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  L O W E R  --  Lowercase a string  */
end_comment

begin_function
name|int
name|lower
parameter_list|(
name|s
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
block|{
name|int
name|n
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|*
name|s
condition|)
block|{
if|if
condition|(
name|isupper
argument_list|(
operator|*
name|s
argument_list|)
condition|)
operator|*
name|s
operator|=
name|tolower
argument_list|(
operator|*
name|s
argument_list|)
expr_stmt|;
name|s
operator|++
operator|,
name|n
operator|++
expr_stmt|;
block|}
return|return
operator|(
name|n
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  L O O K U P  --  Lookup the string in the given array of strings  */
end_comment

begin_comment
comment|/*  Call this way:  v = lookup(table,word,n,&x);      table - a 'struct keytab' table.    word  - the target string to look up in the table.    n     - the number of elements in the table.    x     - address of an integer for returning the table array index.    The keyword table must be arranged in ascending alphabetical order, and  all letters must be lowercase.    Returns the keyword's associated value ( zero or greater ) if found,  with the variable x set to the array index, or:     -3 if nothing to look up (target was null),   -2 if ambiguous,   -1 if not found.    A match is successful if the target matches a keyword exactly, or if  the target is a prefix of exactly one keyword.  It is ambiguous if the  target matches two or more keywords from the table. */
end_comment

begin_function
name|int
name|lookup
parameter_list|(
name|table
parameter_list|,
name|cmd
parameter_list|,
name|n
parameter_list|,
name|x
parameter_list|)
name|char
modifier|*
name|cmd
decl_stmt|;
name|struct
name|keytab
name|table
index|[]
decl_stmt|;
name|int
name|n
decl_stmt|,
decl|*
name|x
decl_stmt|;
end_function

begin_block
block|{
name|int
name|i
decl_stmt|,
name|v
decl_stmt|,
name|cmdlen
decl_stmt|;
comment|/* Lowercase& get length of target, if it's null return code -3. */
if|if
condition|(
operator|(
operator|(
operator|(
name|cmdlen
operator|=
name|lower
argument_list|(
name|cmd
argument_list|)
operator|)
operator|)
operator|==
literal|0
operator|)
operator|||
operator|(
name|n
operator|<
literal|1
operator|)
condition|)
return|return
operator|(
operator|-
literal|3
operator|)
return|;
comment|/* Not null, look it up */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
operator|-
literal|1
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|table
index|[
name|i
index|]
operator|.
name|kwd
argument_list|,
name|cmd
argument_list|)
operator|||
operator|(
operator|(
name|v
operator|=
operator|!
name|strncmp
argument_list|(
name|table
index|[
name|i
index|]
operator|.
name|kwd
argument_list|,
name|cmd
argument_list|,
name|cmdlen
argument_list|)
operator|)
operator|&&
name|strncmp
argument_list|(
name|table
index|[
name|i
operator|+
literal|1
index|]
operator|.
name|kwd
argument_list|,
name|cmd
argument_list|,
name|cmdlen
argument_list|)
operator|)
condition|)
block|{
operator|*
name|x
operator|=
name|i
expr_stmt|;
return|return
operator|(
name|table
index|[
name|i
index|]
operator|.
name|kwval
operator|)
return|;
block|}
if|if
condition|(
name|v
condition|)
return|return
operator|(
operator|-
literal|2
operator|)
return|;
block|}
comment|/* Last (or only) element */
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|table
index|[
name|n
operator|-
literal|1
index|]
operator|.
name|kwd
argument_list|,
name|cmd
argument_list|,
name|cmdlen
argument_list|)
condition|)
block|{
operator|*
name|x
operator|=
name|n
operator|-
literal|1
expr_stmt|;
return|return
operator|(
name|table
index|[
name|n
operator|-
literal|1
index|]
operator|.
name|kwval
operator|)
return|;
block|}
else|else
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_block

end_unit

