begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  C K C F N 2  --  System-independent Kermit protocol support functions... */
end_comment

begin_comment
comment|/*  ...Part 2 (continued from ckcfns.c)  */
end_comment

begin_comment
comment|/*   Author: Frank da Cruz (fdc@watsun.cc.columbia.edu, FDCCU@CUVMA.BITNET),   Columbia University Center for Computing Activities.   First released January 1985.   Copyright (C) 1985, 1992, Trustees of Columbia University in the City of New   York.  Permission is granted to any individual or institution to use this   software as long as it is not sold for profit.  This copyright notice must be   retained.  This software may not be included in commercial products without   written permission of Columbia University. */
end_comment

begin_comment
comment|/*  Note -- if you change this file, please amend the version number and date at  the top of ckcfns.c accordingly. */
end_comment

begin_include
include|#
directive|include
file|"ckcsym.h"
end_include

begin_comment
comment|/* Compilation options */
end_comment

begin_include
include|#
directive|include
file|"ckcdeb.h"
end_include

begin_comment
comment|/* Debugging and other symbols */
end_comment

begin_include
include|#
directive|include
file|"ckcasc.h"
end_include

begin_comment
comment|/* ASCII symbols */
end_comment

begin_include
include|#
directive|include
file|"ckcker.h"
end_include

begin_comment
comment|/* Kermit symbols */
end_comment

begin_include
include|#
directive|include
file|"ckcxla.h"
end_include

begin_comment
comment|/* Translation */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|TCPSOCKET
end_ifdef

begin_comment
comment|/* For TELNET business in spack() */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|NP_TELNET
end_ifndef

begin_define
define|#
directive|define
name|NP_TELNET
value|1
end_define

begin_decl_stmt
specifier|extern
name|int
name|tn_nlm
decl_stmt|,
name|ttnproto
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NP_TELNET */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* TCPSOCKET */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|DYNAMIC
end_ifdef

begin_decl_stmt
specifier|extern
name|struct
name|pktinfo
modifier|*
name|s_pkt
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* array of pktinfo structures */
end_comment

begin_decl_stmt
specifier|extern
name|struct
name|pktinfo
modifier|*
name|r_pkt
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* array of pktinfo structures */
end_comment

begin_else
else|#
directive|else
end_else

begin_decl_stmt
specifier|extern
name|struct
name|pktinfo
name|s_pkt
index|[]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* array of pktinfo structures */
end_comment

begin_decl_stmt
specifier|extern
name|struct
name|pktinfo
name|r_pkt
index|[]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* array of pktinfo structures */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DYNAMIC */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|sseqtbl
index|[]
decl_stmt|,
name|rseqtbl
index|[]
decl_stmt|,
name|sbufuse
index|[]
decl_stmt|,
name|sacktbl
index|[]
decl_stmt|,
name|wslots
decl_stmt|,
name|winlo
decl_stmt|,
name|sbufnum
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|ttprty
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* from ckutio.c */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|autopar
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|spsiz
decl_stmt|,
name|spmax
decl_stmt|,
name|rpsiz
decl_stmt|,
name|timint
decl_stmt|,
name|timef
decl_stmt|,
name|npad
decl_stmt|,
name|ebq
decl_stmt|,
name|ebqflg
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|rpt
decl_stmt|,
name|rptq
decl_stmt|,
name|rptflg
decl_stmt|,
name|capas
decl_stmt|,
name|spsizf
decl_stmt|,
name|en_fin
decl_stmt|,
name|tsecs
decl_stmt|,
name|network
decl_stmt|,
name|flow
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|pktnum
decl_stmt|,
name|sndtyp
decl_stmt|,
name|bctr
decl_stmt|,
name|bctu
decl_stmt|,
name|bctl
decl_stmt|,
name|rsn
decl_stmt|,
name|rln
decl_stmt|,
name|maxtry
decl_stmt|,
name|size
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|osize
decl_stmt|,
name|maxsize
decl_stmt|,
name|spktl
decl_stmt|,
name|rpktl
decl_stmt|,
name|nfils
decl_stmt|,
name|stdouf
decl_stmt|,
name|warn
decl_stmt|,
name|parity
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|turn
decl_stmt|,
name|turnch
decl_stmt|,
name|delay
decl_stmt|,
name|displa
decl_stmt|,
name|pktlog
decl_stmt|,
name|tralog
decl_stmt|,
name|seslog
decl_stmt|,
name|xflg
decl_stmt|,
name|mypadn
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|hcflg
decl_stmt|,
name|local
decl_stmt|,
name|server
decl_stmt|,
name|cxseen
decl_stmt|,
name|czseen
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|nakstate
decl_stmt|,
name|quiet
decl_stmt|,
name|success
decl_stmt|,
name|xitsta
decl_stmt|,
name|what
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|spackets
decl_stmt|,
name|rpackets
decl_stmt|,
name|timeouts
decl_stmt|,
name|retrans
decl_stmt|,
name|crunched
decl_stmt|,
name|urpsiz
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|long
name|filcnt
decl_stmt|,
name|ffc
decl_stmt|,
name|flci
decl_stmt|,
name|flco
decl_stmt|,
name|tlci
decl_stmt|,
name|tlco
decl_stmt|,
name|tfc
decl_stmt|,
name|speed
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|cmarg
decl_stmt|,
modifier|*
name|cmarg2
decl_stmt|,
name|filnam
index|[]
decl_stmt|,
modifier|*
name|hlptxt
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|CHAR
name|padch
decl_stmt|,
name|mypadc
decl_stmt|,
name|eol
decl_stmt|,
name|seol
decl_stmt|,
name|ctlq
decl_stmt|,
name|myctlq
decl_stmt|,
name|sstate
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|CHAR
modifier|*
name|recpkt
decl_stmt|,
modifier|*
name|data
decl_stmt|,
name|encbuf
index|[]
decl_stmt|,
name|myinit
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|CHAR
modifier|*
name|srvptr
decl_stmt|,
name|stchr
decl_stmt|,
name|mystch
decl_stmt|,
modifier|*
name|rdatap
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|CHAR
name|padbuf
index|[]
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|DYNAMIC
end_ifdef

begin_decl_stmt
specifier|extern
name|CHAR
modifier|*
name|srvcmd
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_decl_stmt
specifier|extern
name|CHAR
name|srvcmd
index|[]
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DYNAMIC */
end_comment

begin_decl_stmt
name|int
name|numerrs
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* (PWP) total number packet errors so far */
end_comment

begin_decl_stmt
specifier|static
name|CHAR
name|partab
index|[]
init|=
block|{
comment|/* Even parity table for dopar(). */
operator|(
name|CHAR
operator|)
literal|'\000'
block|,
comment|/* ANSI C casts '\ooo' constants  */
operator|(
name|CHAR
operator|)
literal|'\201'
block|,
comment|/* to signed char, so we have to  */
operator|(
name|CHAR
operator|)
literal|'\202'
block|,
comment|/* cast back to unsigned char...  */
operator|(
name|CHAR
operator|)
literal|'\003'
block|,
operator|(
name|CHAR
operator|)
literal|'\204'
block|,
operator|(
name|CHAR
operator|)
literal|'\005'
block|,
operator|(
name|CHAR
operator|)
literal|'\006'
block|,
operator|(
name|CHAR
operator|)
literal|'\207'
block|,
operator|(
name|CHAR
operator|)
literal|'\210'
block|,
operator|(
name|CHAR
operator|)
literal|'\011'
block|,
operator|(
name|CHAR
operator|)
literal|'\012'
block|,
operator|(
name|CHAR
operator|)
literal|'\213'
block|,
operator|(
name|CHAR
operator|)
literal|'\014'
block|,
operator|(
name|CHAR
operator|)
literal|'\215'
block|,
operator|(
name|CHAR
operator|)
literal|'\216'
block|,
operator|(
name|CHAR
operator|)
literal|'\017'
block|,
operator|(
name|CHAR
operator|)
literal|'\220'
block|,
operator|(
name|CHAR
operator|)
literal|'\021'
block|,
operator|(
name|CHAR
operator|)
literal|'\022'
block|,
operator|(
name|CHAR
operator|)
literal|'\223'
block|,
operator|(
name|CHAR
operator|)
literal|'\024'
block|,
operator|(
name|CHAR
operator|)
literal|'\225'
block|,
operator|(
name|CHAR
operator|)
literal|'\226'
block|,
operator|(
name|CHAR
operator|)
literal|'\027'
block|,
operator|(
name|CHAR
operator|)
literal|'\030'
block|,
operator|(
name|CHAR
operator|)
literal|'\231'
block|,
operator|(
name|CHAR
operator|)
literal|'\232'
block|,
operator|(
name|CHAR
operator|)
literal|'\033'
block|,
operator|(
name|CHAR
operator|)
literal|'\234'
block|,
operator|(
name|CHAR
operator|)
literal|'\035'
block|,
operator|(
name|CHAR
operator|)
literal|'\036'
block|,
operator|(
name|CHAR
operator|)
literal|'\237'
block|,
operator|(
name|CHAR
operator|)
literal|'\240'
block|,
operator|(
name|CHAR
operator|)
literal|'\041'
block|,
operator|(
name|CHAR
operator|)
literal|'\042'
block|,
operator|(
name|CHAR
operator|)
literal|'\243'
block|,
operator|(
name|CHAR
operator|)
literal|'\044'
block|,
operator|(
name|CHAR
operator|)
literal|'\245'
block|,
operator|(
name|CHAR
operator|)
literal|'\246'
block|,
operator|(
name|CHAR
operator|)
literal|'\047'
block|,
operator|(
name|CHAR
operator|)
literal|'\050'
block|,
operator|(
name|CHAR
operator|)
literal|'\251'
block|,
operator|(
name|CHAR
operator|)
literal|'\252'
block|,
operator|(
name|CHAR
operator|)
literal|'\053'
block|,
operator|(
name|CHAR
operator|)
literal|'\254'
block|,
operator|(
name|CHAR
operator|)
literal|'\055'
block|,
operator|(
name|CHAR
operator|)
literal|'\056'
block|,
operator|(
name|CHAR
operator|)
literal|'\257'
block|,
operator|(
name|CHAR
operator|)
literal|'\060'
block|,
operator|(
name|CHAR
operator|)
literal|'\261'
block|,
operator|(
name|CHAR
operator|)
literal|'\262'
block|,
operator|(
name|CHAR
operator|)
literal|'\063'
block|,
operator|(
name|CHAR
operator|)
literal|'\264'
block|,
operator|(
name|CHAR
operator|)
literal|'\065'
block|,
operator|(
name|CHAR
operator|)
literal|'\066'
block|,
operator|(
name|CHAR
operator|)
literal|'\267'
block|,
operator|(
name|CHAR
operator|)
literal|'\270'
block|,
operator|(
name|CHAR
operator|)
literal|'\071'
block|,
operator|(
name|CHAR
operator|)
literal|'\072'
block|,
operator|(
name|CHAR
operator|)
literal|'\273'
block|,
operator|(
name|CHAR
operator|)
literal|'\074'
block|,
operator|(
name|CHAR
operator|)
literal|'\275'
block|,
operator|(
name|CHAR
operator|)
literal|'\276'
block|,
operator|(
name|CHAR
operator|)
literal|'\077'
block|,
operator|(
name|CHAR
operator|)
literal|'\300'
block|,
operator|(
name|CHAR
operator|)
literal|'\101'
block|,
operator|(
name|CHAR
operator|)
literal|'\102'
block|,
operator|(
name|CHAR
operator|)
literal|'\303'
block|,
operator|(
name|CHAR
operator|)
literal|'\104'
block|,
operator|(
name|CHAR
operator|)
literal|'\305'
block|,
operator|(
name|CHAR
operator|)
literal|'\306'
block|,
operator|(
name|CHAR
operator|)
literal|'\107'
block|,
operator|(
name|CHAR
operator|)
literal|'\110'
block|,
operator|(
name|CHAR
operator|)
literal|'\311'
block|,
operator|(
name|CHAR
operator|)
literal|'\312'
block|,
operator|(
name|CHAR
operator|)
literal|'\113'
block|,
operator|(
name|CHAR
operator|)
literal|'\314'
block|,
operator|(
name|CHAR
operator|)
literal|'\115'
block|,
operator|(
name|CHAR
operator|)
literal|'\116'
block|,
operator|(
name|CHAR
operator|)
literal|'\317'
block|,
operator|(
name|CHAR
operator|)
literal|'\120'
block|,
operator|(
name|CHAR
operator|)
literal|'\321'
block|,
operator|(
name|CHAR
operator|)
literal|'\322'
block|,
operator|(
name|CHAR
operator|)
literal|'\123'
block|,
operator|(
name|CHAR
operator|)
literal|'\324'
block|,
operator|(
name|CHAR
operator|)
literal|'\125'
block|,
operator|(
name|CHAR
operator|)
literal|'\126'
block|,
operator|(
name|CHAR
operator|)
literal|'\327'
block|,
operator|(
name|CHAR
operator|)
literal|'\330'
block|,
operator|(
name|CHAR
operator|)
literal|'\131'
block|,
operator|(
name|CHAR
operator|)
literal|'\132'
block|,
operator|(
name|CHAR
operator|)
literal|'\333'
block|,
operator|(
name|CHAR
operator|)
literal|'\134'
block|,
operator|(
name|CHAR
operator|)
literal|'\335'
block|,
operator|(
name|CHAR
operator|)
literal|'\336'
block|,
operator|(
name|CHAR
operator|)
literal|'\137'
block|,
operator|(
name|CHAR
operator|)
literal|'\140'
block|,
operator|(
name|CHAR
operator|)
literal|'\341'
block|,
operator|(
name|CHAR
operator|)
literal|'\342'
block|,
operator|(
name|CHAR
operator|)
literal|'\143'
block|,
operator|(
name|CHAR
operator|)
literal|'\344'
block|,
operator|(
name|CHAR
operator|)
literal|'\145'
block|,
operator|(
name|CHAR
operator|)
literal|'\146'
block|,
operator|(
name|CHAR
operator|)
literal|'\347'
block|,
operator|(
name|CHAR
operator|)
literal|'\350'
block|,
operator|(
name|CHAR
operator|)
literal|'\151'
block|,
operator|(
name|CHAR
operator|)
literal|'\152'
block|,
operator|(
name|CHAR
operator|)
literal|'\353'
block|,
operator|(
name|CHAR
operator|)
literal|'\154'
block|,
operator|(
name|CHAR
operator|)
literal|'\355'
block|,
operator|(
name|CHAR
operator|)
literal|'\356'
block|,
operator|(
name|CHAR
operator|)
literal|'\157'
block|,
operator|(
name|CHAR
operator|)
literal|'\360'
block|,
operator|(
name|CHAR
operator|)
literal|'\161'
block|,
operator|(
name|CHAR
operator|)
literal|'\162'
block|,
operator|(
name|CHAR
operator|)
literal|'\363'
block|,
operator|(
name|CHAR
operator|)
literal|'\164'
block|,
operator|(
name|CHAR
operator|)
literal|'\365'
block|,
operator|(
name|CHAR
operator|)
literal|'\366'
block|,
operator|(
name|CHAR
operator|)
literal|'\167'
block|,
operator|(
name|CHAR
operator|)
literal|'\170'
block|,
operator|(
name|CHAR
operator|)
literal|'\371'
block|,
operator|(
name|CHAR
operator|)
literal|'\372'
block|,
operator|(
name|CHAR
operator|)
literal|'\173'
block|,
operator|(
name|CHAR
operator|)
literal|'\374'
block|,
operator|(
name|CHAR
operator|)
literal|'\175'
block|,
operator|(
name|CHAR
operator|)
literal|'\176'
block|,
operator|(
name|CHAR
operator|)
literal|'\377'
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* CRC generation tables */
end_comment

begin_decl_stmt
specifier|static
name|long
name|crcta
index|[
literal|16
index|]
init|=
block|{
literal|0L
block|,
literal|010201L
block|,
literal|020402L
block|,
literal|030603L
block|,
literal|041004L
block|,
literal|051205L
block|,
literal|061406L
block|,
literal|071607L
block|,
literal|0102010L
block|,
literal|0112211L
block|,
literal|0122412L
block|,
literal|0132613L
block|,
literal|0143014L
block|,
literal|0153215L
block|,
literal|0163416L
block|,
literal|0173617L
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|long
name|crctb
index|[
literal|16
index|]
init|=
block|{
literal|0L
block|,
literal|010611L
block|,
literal|021422L
block|,
literal|031233L
block|,
literal|043044L
block|,
literal|053655L
block|,
literal|062466L
block|,
literal|072277L
block|,
literal|0106110L
block|,
literal|0116701L
block|,
literal|0127532L
block|,
literal|0137323L
block|,
literal|0145154L
block|,
literal|0155745L
block|,
literal|0164576L
block|,
literal|0174367L
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  I N P U T  --  Attempt to read packet number 'pktnum'.  */
end_comment

begin_comment
comment|/*  This is the function that feeds input to Kermit's finite state machine,  in the form of a character in the range 32-126, normally a packet type  (uppercase letter) or pseudo-packet-type (lowercase letter).   If a special start state is in effect, that state is returned as if it were  the type of an incoming packet.  Otherwise:   (fill in...) */
end_comment

begin_function
name|int
name|input
parameter_list|()
block|{
name|int
name|type
decl_stmt|;
name|int
name|x
init|=
literal|0
decl_stmt|,
name|y
decl_stmt|,
name|k
decl_stmt|;
name|debug
argument_list|(
name|F101
argument_list|,
literal|"input sstate"
argument_list|,
literal|""
argument_list|,
name|sstate
argument_list|)
expr_stmt|;
name|debug
argument_list|(
name|F101
argument_list|,
literal|" nakstate"
argument_list|,
literal|""
argument_list|,
name|nakstate
argument_list|)
expr_stmt|;
name|debug
argument_list|(
name|F000
argument_list|,
literal|" sndtyp"
argument_list|,
literal|""
argument_list|,
name|sndtyp
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
comment|/* Big loop... */
if|if
condition|(
name|sstate
operator|!=
literal|0
condition|)
block|{
comment|/* If a start state is in effect, */
name|type
operator|=
name|sstate
expr_stmt|;
comment|/* return it like a packet type, */
name|sstate
operator|=
literal|0
expr_stmt|;
comment|/* and then nullify it. */
name|numerrs
operator|=
literal|0
expr_stmt|;
comment|/* (PWP) no errors so far */
return|return
operator|(
name|type
operator|)
return|;
block|}
if|if
condition|(
name|nakstate
condition|)
block|{
comment|/* This section for file receiver. */
if|if
condition|(
name|wslots
operator|>
literal|1
condition|)
block|{
comment|/* If we're doing windows, */
name|x
operator|=
name|rseqtbl
index|[
name|winlo
index|]
expr_stmt|;
comment|/* see if desired packet already in. */
name|debug
argument_list|(
name|F101
argument_list|,
literal|" winlo"
argument_list|,
literal|""
argument_list|,
name|winlo
argument_list|)
expr_stmt|;
name|debug
argument_list|(
name|F101
argument_list|,
literal|" rseqtbl[winlo]"
argument_list|,
literal|""
argument_list|,
name|rseqtbl
index|[
name|winlo
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|>
operator|-
literal|1
condition|)
block|{
comment|/* Already there? */
if|if
condition|(
name|r_pkt
index|[
name|x
index|]
operator|.
name|pk_seq
operator|==
name|winlo
condition|)
block|{
comment|/* (double check) */
name|rsn
operator|=
name|winlo
expr_stmt|;
comment|/* Yes, return its info */
name|debug
argument_list|(
name|F101
argument_list|,
literal|"input return pre-stashed packet"
argument_list|,
literal|""
argument_list|,
name|rsn
argument_list|)
expr_stmt|;
name|dumprbuf
argument_list|()
expr_stmt|;
name|rdatap
operator|=
name|r_pkt
index|[
name|x
index|]
operator|.
name|pk_adr
expr_stmt|;
comment|/* like rpack would do. */
name|rln
operator|=
operator|(
name|int
operator|)
name|strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|rdatap
argument_list|)
expr_stmt|;
name|type
operator|=
name|r_pkt
index|[
name|x
index|]
operator|.
name|pk_typ
expr_stmt|;
break|break;
block|}
block|}
block|}
name|type
operator|=
name|rpack
argument_list|()
expr_stmt|;
comment|/* Try to read a packet. */
name|debug
argument_list|(
name|F111
argument_list|,
literal|"input recv"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|rdatap
argument_list|,
operator|(
name|int
operator|)
name|type
argument_list|)
expr_stmt|;
while|while
condition|(
name|type
operator|==
literal|'e'
condition|)
block|{
comment|/* Handle echoes */
name|debug
argument_list|(
name|F000
argument_list|,
literal|"echo discarded"
argument_list|,
literal|""
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|type
operator|=
name|rpack
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|type
operator|<
operator|-
literal|1
condition|)
return|return
operator|(
literal|'q'
operator|)
return|;
comment|/* Ctrl-C */
if|if
condition|(
name|type
operator|<
literal|0
condition|)
block|{
comment|/* Receive window full */
comment|/* Another thing to do here would be to delete */
comment|/* the highest packet and NAK winlo.  But that */
comment|/* shouldn't be necessary since the other Kermit */
comment|/* should not have sent a packet outside the window. */
name|debug
argument_list|(
name|F101
argument_list|,
literal|"rpack receive window full"
argument_list|,
literal|""
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|dumprbuf
argument_list|()
expr_stmt|;
name|errpkt
argument_list|(
operator|(
name|CHAR
operator|*
operator|)
literal|"Receive window full."
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|recpkt
argument_list|,
literal|"Receive window full."
argument_list|)
expr_stmt|;
name|type
operator|=
literal|'E'
expr_stmt|;
break|break;
block|}
name|dumprbuf
argument_list|()
expr_stmt|;
if|if
condition|(
name|chkint
argument_list|()
operator|<
literal|0
condition|)
block|{
comment|/* Check for console interrupts. */
name|errpkt
argument_list|(
operator|(
name|CHAR
operator|*
operator|)
literal|"User cancelled."
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|recpkt
argument_list|,
literal|"User cancelled."
argument_list|)
expr_stmt|;
name|type
operator|=
literal|'E'
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|type
operator|==
literal|'E'
condition|)
block|{
name|debug
argument_list|(
name|F101
argument_list|,
literal|"input got E, nakstate"
argument_list|,
literal|""
argument_list|,
name|nakstate
argument_list|)
expr_stmt|;
break|break;
comment|/* Error packet */
block|}
if|if
condition|(
name|type
operator|==
literal|'Q'
condition|)
block|{
comment|/* Crunched packet. */
name|crunched
operator|++
expr_stmt|;
name|numerrs
operator|++
expr_stmt|;
if|if
condition|(
name|nack
argument_list|(
name|winlo
argument_list|)
operator|<
literal|0
condition|)
block|{
comment|/* Request resend of window-low.. */
name|debug
argument_list|(
name|F101
argument_list|,
literal|"input sent too many naks"
argument_list|,
literal|""
argument_list|,
name|winlo
argument_list|)
expr_stmt|;
name|errpkt
argument_list|(
operator|(
name|CHAR
operator|*
operator|)
literal|"Too many retries."
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|recpkt
argument_list|,
literal|"Sent too many NAKs."
argument_list|)
expr_stmt|;
name|type
operator|=
literal|'E'
expr_stmt|;
break|break;
block|}
else|else
continue|continue;
block|}
if|if
condition|(
name|type
operator|==
literal|'T'
condition|)
block|{
comment|/* Timeout */
ifdef|#
directive|ifdef
name|BULKNAKS
name|int
name|z
decl_stmt|;
endif|#
directive|endif
name|timeouts
operator|++
expr_stmt|;
name|debug
argument_list|(
name|F101
argument_list|,
literal|"input receive-state timeout, winlo"
argument_list|,
literal|""
argument_list|,
name|winlo
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|BULKNAKS
name|z
operator|=
name|winlo
operator|+
name|wslots
expr_stmt|;
comment|/* NAK all unACK'd packets */
if|if
condition|(
name|z
operator|>
literal|63
condition|)
name|z
operator|-=
literal|64
expr_stmt|;
name|debug
argument_list|(
name|F101
argument_list|,
literal|"input sending bulk NAKs, winlo"
argument_list|,
literal|""
argument_list|,
name|winlo
argument_list|)
expr_stmt|;
for|for
control|(
name|x
operator|=
name|winlo
init|;
operator|(
name|x
operator|!=
name|z
operator|)
operator|&&
name|ttchk
argument_list|()
operator|==
literal|0
condition|;
name|x
operator|++
control|)
block|{
if|if
condition|(
name|x
operator|<
literal|0
operator|||
name|x
operator|>
literal|63
condition|)
break|break;
if|if
condition|(
name|rseqtbl
index|[
name|x
index|]
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|nack
argument_list|(
name|x
argument_list|)
operator|<
literal|0
condition|)
block|{
name|debug
argument_list|(
name|F101
argument_list|,
literal|"input sent too many naks"
argument_list|,
literal|""
argument_list|,
name|winlo
argument_list|)
expr_stmt|;
name|errpkt
argument_list|(
operator|(
name|CHAR
operator|*
operator|)
literal|"Too many retries."
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|recpkt
argument_list|,
literal|"Sent too many NAKs."
argument_list|)
expr_stmt|;
name|type
operator|=
literal|'E'
expr_stmt|;
break|break;
block|}
block|}
block|}
else|#
directive|else
comment|/* NAK only the packet at window-low */
name|debug
argument_list|(
name|F101
argument_list|,
literal|"input sending NAK for winlo"
argument_list|,
literal|""
argument_list|,
name|winlo
argument_list|)
expr_stmt|;
if|if
condition|(
name|nack
argument_list|(
name|winlo
argument_list|)
operator|<
literal|0
condition|)
block|{
name|debug
argument_list|(
name|F101
argument_list|,
literal|"input sent too many naks"
argument_list|,
literal|""
argument_list|,
name|winlo
argument_list|)
expr_stmt|;
name|errpkt
argument_list|(
operator|(
name|CHAR
operator|*
operator|)
literal|"Too many retries."
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|recpkt
argument_list|,
literal|"Sent too many NAKs."
argument_list|)
expr_stmt|;
name|type
operator|=
literal|'E'
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
comment|/* BULKNAKS */
continue|continue;
block|}
comment|/* Got the packet we want, done. */
if|if
condition|(
name|rsn
operator|==
name|winlo
condition|)
block|{
name|debug
argument_list|(
name|F101
argument_list|,
literal|"input rsn=winlo"
argument_list|,
literal|""
argument_list|,
name|rsn
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Got a packet out of order. */
name|debug
argument_list|(
name|F101
argument_list|,
literal|"input recv got packet out of order"
argument_list|,
literal|""
argument_list|,
name|rsn
argument_list|)
expr_stmt|;
name|k
operator|=
name|rseqtbl
index|[
name|rsn
index|]
expr_stmt|;
comment|/* Get window slot of this packet. */
name|debug
argument_list|(
name|F101
argument_list|,
literal|"input recv rseqtbl[rsn]"
argument_list|,
literal|""
argument_list|,
name|k
argument_list|)
expr_stmt|;
if|if
condition|(
name|k
operator|<
literal|0
condition|)
block|{
name|debug
argument_list|(
name|F101
argument_list|,
literal|"input recv can't find index for rcvd pkt"
argument_list|,
literal|""
argument_list|,
name|rsn
argument_list|)
expr_stmt|;
name|errpkt
argument_list|(
operator|(
name|CHAR
operator|*
operator|)
literal|"internal error number 21"
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|recpkt
argument_list|,
literal|"Sliding windows protocol error."
argument_list|)
expr_stmt|;
name|type
operator|=
literal|'E'
expr_stmt|;
break|break;
block|}
name|y
operator|=
name|chkwin
argument_list|(
name|rsn
argument_list|,
name|winlo
argument_list|,
name|wslots
argument_list|)
expr_stmt|;
comment|/* See what window it's in. */
name|debug
argument_list|(
name|F101
argument_list|,
literal|"input recv chkwin"
argument_list|,
literal|""
argument_list|,
name|y
argument_list|)
expr_stmt|;
if|if
condition|(
name|y
operator|==
literal|1
condition|)
block|{
comment|/* Previous window. */
ifdef|#
directive|ifdef
name|COMMENT
name|ackn
argument_list|(
name|rsn
argument_list|)
expr_stmt|;
comment|/* Send empty ACK */
else|#
directive|else
name|resend
argument_list|(
name|rsn
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* COMMENT */
name|freerpkt
argument_list|(
name|rsn
argument_list|)
expr_stmt|;
comment|/* Get rid of received packet */
continue|continue;
block|}
else|else
block|{
comment|/* In this window or out of range */
if|if
condition|(
name|y
operator|<
literal|0
condition|)
comment|/* If out of range entirely, */
name|freerpkt
argument_list|(
name|rsn
argument_list|)
expr_stmt|;
comment|/* release its buffer */
comment|/*   We have received a packet, but not the one we want.  If we do nothing,   we could be in for a lengthy timeout/retry cycle.  It would seem to   make sense to send a NAK for the most desired packet (winlo).  But   consider this scenario: a packet arrived damaged so we NAK'd it above;   then packets winlo+1, winlo+2, ... winlo+n arrive, each one making us   send a NAK for winlo, so the other Kermit gets n NAKs for winlo, and   either would have to resend it n times, or if n> retry limit, give up   because of too many retries.  So we compromise: If a packet arrives   that is not the most desired packet (winlo), we NAK winlo, BUT ONLY IF   it has not been NAK'd before. */
if|if
condition|(
name|s_pkt
index|[
name|k
index|]
operator|.
name|pk_rtr
operator|==
literal|0
condition|)
block|{
comment|/* Have we been here before? */
if|if
condition|(
name|nack
argument_list|(
name|winlo
argument_list|)
operator|<
literal|0
condition|)
block|{
comment|/* No, NAK winlo. */
name|errpkt
argument_list|(
operator|(
name|CHAR
operator|*
operator|)
literal|"Too many retries."
argument_list|)
expr_stmt|;
comment|/* Too many */
name|strcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|recpkt
argument_list|,
literal|"Timed out."
argument_list|)
expr_stmt|;
comment|/* Give up */
name|type
operator|=
literal|'E'
expr_stmt|;
break|break;
block|}
else|else
continue|continue;
block|}
else|else
continue|continue;
block|}
comment|/*!!!*/
block|}
else|else
block|{
comment|/* Otherwise file sender... */
if|if
condition|(
name|wslots
operator|>
literal|1
condition|)
block|{
comment|/* Packet at winlo already ACK'd? */
if|if
condition|(
name|sacktbl
index|[
name|winlo
index|]
condition|)
block|{
comment|/* If so,  */
name|sacktbl
index|[
name|winlo
index|]
operator|=
literal|0
expr_stmt|;
comment|/* Turn off the ACK'd flag */
name|winlo
operator|=
operator|(
name|winlo
operator|+
literal|1
operator|)
operator|%
literal|64
expr_stmt|;
comment|/* Rotate the window */
name|type
operator|=
literal|'Y'
expr_stmt|;
comment|/* And return ACK */
name|debug
argument_list|(
name|F101
argument_list|,
literal|"input send returning pre-stashed ACK"
argument_list|,
literal|""
argument_list|,
name|winlo
operator|-
literal|1
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|type
operator|=
name|rpack
argument_list|()
expr_stmt|;
comment|/* Try to read an acknowledgement */
name|debug
argument_list|(
name|F111
argument_list|,
literal|"input send"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|rdatap
argument_list|,
operator|(
name|int
operator|)
name|type
argument_list|)
expr_stmt|;
while|while
condition|(
name|type
operator|==
literal|'e'
condition|)
block|{
comment|/* Handle echoes */
name|debug
argument_list|(
name|F000
argument_list|,
literal|"echo discarded"
argument_list|,
literal|""
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|type
operator|=
name|rpack
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|type
operator|==
operator|-
literal|2
condition|)
return|return
operator|(
literal|'q'
operator|)
return|;
if|if
condition|(
name|type
operator|==
operator|-
literal|1
condition|)
block|{
name|errpkt
argument_list|(
operator|(
name|CHAR
operator|*
operator|)
literal|"Internal error number 18"
argument_list|)
expr_stmt|;
name|debug
argument_list|(
name|F101
argument_list|,
literal|" wslots"
argument_list|,
literal|""
argument_list|,
name|wslots
argument_list|)
expr_stmt|;
name|debug
argument_list|(
name|F101
argument_list|,
literal|" winlo"
argument_list|,
literal|""
argument_list|,
name|winlo
argument_list|)
expr_stmt|;
name|debug
argument_list|(
name|F101
argument_list|,
literal|" pktnum"
argument_list|,
literal|""
argument_list|,
name|pktnum
argument_list|)
expr_stmt|;
name|dumprbuf
argument_list|()
expr_stmt|;
name|strcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|recpkt
argument_list|,
literal|"Can't allocate receive buffer"
argument_list|)
expr_stmt|;
name|type
operator|=
literal|'E'
expr_stmt|;
break|break;
block|}
name|dumprbuf
argument_list|()
expr_stmt|;
comment|/* debugging */
if|if
condition|(
name|chkint
argument_list|()
operator|<
literal|0
condition|)
block|{
comment|/* Check for console interrupts. */
name|errpkt
argument_list|(
operator|(
name|CHAR
operator|*
operator|)
literal|"User cancelled."
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|recpkt
argument_list|,
literal|"User cancelled."
argument_list|)
expr_stmt|;
return|return
operator|(
name|type
operator|=
literal|'E'
operator|)
return|;
block|}
comment|/* got a packet */
if|if
condition|(
name|type
operator|==
literal|'E'
condition|)
block|{
name|debug
argument_list|(
name|F101
argument_list|,
literal|"input send got E, nakstate"
argument_list|,
literal|""
argument_list|,
name|nakstate
argument_list|)
expr_stmt|;
break|break;
comment|/* Error packet */
block|}
if|if
condition|(
name|type
operator|==
literal|'Q'
condition|)
block|{
comment|/* Crunched packet */
name|crunched
operator|++
expr_stmt|;
comment|/* For statistics */
name|numerrs
operator|++
expr_stmt|;
comment|/* For packet resizing */
name|x
operator|=
name|resend
argument_list|(
name|winlo
argument_list|)
expr_stmt|;
comment|/* Resend window-low */
if|if
condition|(
name|x
operator|<
literal|0
condition|)
block|{
name|type
operator|=
literal|'E'
expr_stmt|;
name|errpkt
argument_list|(
name|recpkt
argument_list|)
expr_stmt|;
break|break;
block|}
continue|continue;
block|}
if|if
condition|(
name|type
operator|==
literal|'T'
condition|)
block|{
comment|/* Timeout waiting for ACKs. */
name|timeouts
operator|++
expr_stmt|;
comment|/* Count it */
name|numerrs
operator|++
expr_stmt|;
comment|/* Count an error too */
name|debug
argument_list|(
name|F101
argument_list|,
literal|"input send state timeout, winlo"
argument_list|,
literal|""
argument_list|,
name|winlo
argument_list|)
expr_stmt|;
comment|/* Retransmit the oldest un-ACK'd packet. */
name|debug
argument_list|(
name|F101
argument_list|,
literal|"input send resending winlo"
argument_list|,
literal|""
argument_list|,
name|winlo
argument_list|)
expr_stmt|;
if|if
condition|(
name|resend
argument_list|(
name|winlo
argument_list|)
operator|<
literal|0
condition|)
block|{
comment|/* Check retries */
name|debug
argument_list|(
name|F101
argument_list|,
literal|"input send too many resends"
argument_list|,
literal|""
argument_list|,
name|maxtry
argument_list|)
expr_stmt|;
name|errpkt
argument_list|(
name|recpkt
argument_list|)
expr_stmt|;
return|return
operator|(
name|type
operator|=
literal|'E'
operator|)
return|;
block|}
continue|continue;
block|}
comment|/* Got an actual normal packet */
name|y
operator|=
name|chkwin
argument_list|(
name|rsn
argument_list|,
name|winlo
argument_list|,
name|wslots
argument_list|)
expr_stmt|;
comment|/* Is it in the window? */
name|debug
argument_list|(
name|F101
argument_list|,
literal|"input send rsn"
argument_list|,
literal|""
argument_list|,
name|rsn
argument_list|)
expr_stmt|;
name|debug
argument_list|(
name|F101
argument_list|,
literal|"input send winlo"
argument_list|,
literal|""
argument_list|,
name|winlo
argument_list|)
expr_stmt|;
name|debug
argument_list|(
name|F101
argument_list|,
literal|"input send chkwin"
argument_list|,
literal|""
argument_list|,
name|y
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
literal|'Y'
condition|)
block|{
comment|/* Got an ACK */
if|if
condition|(
name|y
operator|==
literal|0
condition|)
block|{
comment|/* In current window */
name|x
operator|=
name|sseqtbl
index|[
name|rsn
index|]
expr_stmt|;
comment|/* Mark the packet as ACK'd */
if|if
condition|(
name|x
operator|>
operator|-
literal|1
condition|)
name|s_pkt
index|[
name|x
index|]
operator|.
name|pk_flg
operator|++
expr_stmt|;
comment|/* (old way) */
name|sacktbl
index|[
name|rsn
index|]
operator|++
expr_stmt|;
comment|/* (new way) */
comment|/*   NOTE: The following statement frees the buffer of the ACK we just got.   But the upper layers still need the data, like if it's the ACK to an I,   S, F, D, Z, or just about any kind of packet.  So for now, freerbuf()   deallocates the buffer, but does not erase the data or destroy the pointer   to it.  There's no other single place where these receive buffers can be   correctly freed (?) ... */
name|freerpkt
argument_list|(
name|rsn
argument_list|)
expr_stmt|;
comment|/* Free the ACK's buffer */
name|freesbuf
argument_list|(
name|rsn
argument_list|)
expr_stmt|;
comment|/* *** Free the sent packet's buffer */
if|if
condition|(
name|rsn
operator|==
name|winlo
condition|)
block|{
comment|/* Got the one we want */
name|sacktbl
index|[
name|winlo
index|]
operator|=
literal|0
expr_stmt|;
name|winlo
operator|=
operator|(
name|winlo
operator|+
literal|1
operator|)
operator|%
literal|64
expr_stmt|;
name|debug
argument_list|(
name|F101
argument_list|,
literal|"input send rotated send window"
argument_list|,
literal|""
argument_list|,
name|winlo
argument_list|)
expr_stmt|;
break|break;
comment|/* Return the ACK */
block|}
else|else
block|{
name|debug
argument_list|(
name|F101
argument_list|,
literal|"input send mark pkt"
argument_list|,
literal|""
argument_list|,
name|rsn
argument_list|)
expr_stmt|;
continue|continue;
comment|/* Otherwise go read another packet */
block|}
block|}
else|else
block|{
comment|/* ACK not in window, ignore */
name|debug
argument_list|(
name|F101
argument_list|,
literal|"input send ACK out of window"
argument_list|,
literal|""
argument_list|,
name|rsn
argument_list|)
expr_stmt|;
name|freerpkt
argument_list|(
name|rsn
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
if|if
condition|(
name|type
operator|==
literal|'N'
condition|)
block|{
comment|/* NAK */
name|numerrs
operator|++
expr_stmt|;
comment|/* Count an error */
name|debug
argument_list|(
name|F101
argument_list|,
literal|"input send NAK"
argument_list|,
literal|""
argument_list|,
name|rsn
argument_list|)
expr_stmt|;
name|freerpkt
argument_list|(
name|rsn
argument_list|)
expr_stmt|;
comment|/* Free buffer where NAK lies. */
if|if
condition|(
name|y
operator|==
literal|0
condition|)
block|{
comment|/* In current window */
name|debug
argument_list|(
name|F100
argument_list|,
literal|" in window"
argument_list|,
literal|""
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|k
operator|=
name|sseqtbl
index|[
name|rsn
index|]
expr_stmt|;
comment|/* Get pointer to NAK'd packet. */
name|x
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|k
operator|<
literal|0
operator|||
operator|(
name|k
operator|>
operator|-
literal|1
operator|&&
name|s_pkt
index|[
name|k
index|]
operator|.
name|pk_typ
operator|==
literal|' '
operator|)
condition|)
block|{
name|x
operator|=
name|resend
argument_list|(
name|winlo
argument_list|)
expr_stmt|;
comment|/* Packet we haven't sent yet. */
block|}
else|else
block|{
name|x
operator|=
name|resend
argument_list|(
name|rsn
argument_list|)
expr_stmt|;
comment|/* Resend requested packet. */
block|}
if|if
condition|(
name|x
operator|<
literal|0
condition|)
block|{
comment|/* Resend error is fatal.  */
name|type
operator|=
literal|'E'
expr_stmt|;
name|errpkt
argument_list|(
name|recpkt
argument_list|)
expr_stmt|;
break|break;
block|}
else|else
continue|continue;
comment|/* Resend ok, go read another packet */
block|}
elseif|else
if|if
condition|(
operator|(
name|rsn
operator|==
operator|(
name|pktnum
operator|+
literal|1
operator|)
operator|%
literal|64
operator|)
condition|)
block|{
comment|/* NAK for next pkt */
if|if
condition|(
name|wslots
operator|>
literal|1
condition|)
block|{
name|debug
argument_list|(
name|F101
argument_list|,
literal|"NAK for next packet, windowing"
argument_list|,
literal|""
argument_list|,
name|rsn
argument_list|)
expr_stmt|;
name|x
operator|=
name|resend
argument_list|(
name|winlo
argument_list|)
expr_stmt|;
comment|/* Resend window-low */
if|if
condition|(
name|x
operator|<
literal|0
condition|)
block|{
name|type
operator|=
literal|'E'
expr_stmt|;
name|errpkt
argument_list|(
name|recpkt
argument_list|)
expr_stmt|;
break|break;
block|}
continue|continue;
comment|/* Go back and read another pkt */
block|}
name|debug
argument_list|(
name|F101
argument_list|,
literal|"NAK for next packet, no windowing"
argument_list|,
literal|""
argument_list|,
name|rsn
argument_list|)
expr_stmt|;
name|x
operator|=
operator|(
name|rsn
operator|==
literal|0
operator|)
condition|?
literal|63
else|:
name|rsn
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|x
operator|==
literal|0
operator|&&
operator|(
name|sndtyp
operator|==
literal|'S'
operator|||
name|sndtyp
operator|==
literal|'I'
operator|)
condition|)
block|{
name|resend
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* ACK for S or I packet missing */
continue|continue;
comment|/* so resend it. */
block|}
comment|/* Else, treat NAK(n+1) as ACK(n) */
if|if
condition|(
operator|(
name|x
operator|=
name|sseqtbl
index|[
name|x
index|]
operator|)
operator|>
operator|-
literal|1
condition|)
block|{
name|sacktbl
index|[
name|x
index|]
operator|++
expr_stmt|;
comment|/* (new way) */
name|s_pkt
index|[
name|x
index|]
operator|.
name|pk_flg
operator|++
expr_stmt|;
comment|/* (old way) */
block|}
name|type
operator|=
literal|'Y'
expr_stmt|;
comment|/* Treat it as ACK for last pkt */
break|break;
block|}
elseif|else
if|if
condition|(
name|y
operator|>
literal|0
condition|)
block|{
comment|/* NAK for pkt we can't resend */
name|debug
argument_list|(
name|F101
argument_list|,
literal|" NAK out of window"
argument_list|,
literal|""
argument_list|,
name|rsn
argument_list|)
expr_stmt|;
comment|/* bad... */
name|type
operator|=
literal|'E'
expr_stmt|;
name|errpkt
argument_list|(
operator|(
name|CHAR
operator|*
operator|)
literal|"NAK out of window"
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|recpkt
argument_list|,
literal|"NAK out of window."
argument_list|)
expr_stmt|;
break|break;
block|}
else|else
continue|continue;
comment|/* Ignore other NAKs */
block|}
comment|/* End of file-sender NAK handler */
if|if
condition|(
name|rsn
operator|==
name|winlo
condition|)
block|{
comment|/* Not ACK, NAK, timeout, etc. */
name|debug
argument_list|(
name|F000
argument_list|,
literal|"input send unexpected type"
argument_list|,
literal|""
argument_list|,
name|type
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
comment|/* End of file-sender section */
block|}
comment|/* End of input() loop */
if|if
condition|(
name|wslots
operator|==
literal|1
condition|)
block|{
name|debug
argument_list|(
name|F100
argument_list|,
literal|"input about to flush"
argument_list|,
literal|""
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ttflui
argument_list|()
expr_stmt|;
comment|/* Got what we want, clear input buffer. */
block|}
if|if
condition|(
operator|!
name|nakstate
condition|)
comment|/* When sending */
name|rcalcpsz
argument_list|()
expr_stmt|;
comment|/* recalculate size every packet */
name|debug
argument_list|(
name|F000
argument_list|,
literal|"input returning type"
argument_list|,
literal|""
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
operator|(
name|type
operator|)
return|;
comment|/* Success, return packet type. */
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  D O P A R  --  Add an appropriate parity bit to a character  */
end_comment

begin_comment
comment|/*   (PWP) this is still used in the Mac terminal emulator, so we have to keep it */
end_comment

begin_function
name|CHAR
ifdef|#
directive|ifdef
name|CK_ANSIC
name|dopar
parameter_list|(
specifier|register
name|CHAR
name|ch
parameter_list|)
else|#
directive|else
function|dopar
parameter_list|(
name|ch
parameter_list|)
specifier|register
name|CHAR
name|ch
decl_stmt|;
endif|#
directive|endif
comment|/* CK_ANSIC */
block|{
specifier|register
name|unsigned
name|int
name|a
decl_stmt|;
if|if
condition|(
operator|!
name|parity
condition|)
return|return
operator|(
call|(
name|CHAR
call|)
argument_list|(
name|ch
operator|&
literal|255
argument_list|)
operator|)
return|;
else|else
name|a
operator|=
name|ch
operator|&
literal|127
expr_stmt|;
switch|switch
condition|(
name|parity
condition|)
block|{
case|case
literal|'e'
case|:
return|return
operator|(
name|partab
index|[
name|a
index|]
operator|)
return|;
comment|/* Even */
case|case
literal|'m'
case|:
return|return
operator|(
call|(
name|CHAR
call|)
argument_list|(
name|a
operator||
literal|128
argument_list|)
operator|)
return|;
comment|/* Mark */
case|case
literal|'o'
case|:
return|return
operator|(
call|(
name|CHAR
call|)
argument_list|(
name|partab
index|[
name|a
index|]
operator|^
literal|128
argument_list|)
operator|)
return|;
comment|/* Odd */
case|case
literal|'s'
case|:
return|return
operator|(
operator|(
name|CHAR
operator|)
name|a
operator|)
return|;
comment|/* Space */
default|default:
return|return
operator|(
operator|(
name|CHAR
operator|)
name|a
operator|)
return|;
comment|/* Something illegal */
block|}
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|PARSENSE
end_ifdef

begin_comment
comment|/*  P A R C H K  --  Check if Kermit packet has parity  */
end_comment

begin_comment
comment|/*   Call with s = pointer to packet, start = packet start character, n = length.   Returns 0 if packet has no parity, -1 on error, or, if packet has parity:     'e' for even, 'o' for odd, 'm' for mark.  Space parity cannot be sensed.   So a return value of 0 really means either space or none.   Returns -2 if parity has already been checked during this protocol operation. */
end_comment

begin_function
name|int
ifdef|#
directive|ifdef
name|CK_ANSIC
name|parchk
parameter_list|(
name|CHAR
modifier|*
name|s
parameter_list|,
name|CHAR
name|start
parameter_list|,
name|int
name|n
parameter_list|)
else|#
directive|else
function|parchk
parameter_list|(
name|s
parameter_list|,
name|start
parameter_list|,
name|n
parameter_list|)
name|CHAR
modifier|*
name|s
decl_stmt|,
name|start
decl_stmt|;
name|int
name|n
decl_stmt|;
endif|#
directive|endif
comment|/* CK_ANSIC */
comment|/* parchk */
block|{
name|CHAR
name|s0
decl_stmt|,
name|s1
decl_stmt|,
name|s2
decl_stmt|,
name|s3
decl_stmt|;
name|debug
argument_list|(
name|F101
argument_list|,
literal|"parchk n"
argument_list|,
literal|""
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|debug
argument_list|(
name|F101
argument_list|,
literal|"parchk start"
argument_list|,
literal|""
argument_list|,
name|start
argument_list|)
expr_stmt|;
name|s0
operator|=
name|s
index|[
literal|0
index|]
operator|&
literal|0x7f
expr_stmt|;
comment|/* Mark field (usually Ctrl-A) */
if|if
condition|(
name|s0
operator|!=
name|start
operator|||
name|n
operator|<
literal|5
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* Not a valid packet */
comment|/* Look at packet control fields, which never have 8th bit set */
comment|/* First check for no parity, most common case. */
if|if
condition|(
operator|(
operator|(
name|s
index|[
literal|0
index|]
operator||
name|s
index|[
literal|1
index|]
operator||
name|s
index|[
literal|2
index|]
operator||
name|s
index|[
literal|3
index|]
operator|)
operator|&
literal|0x80
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* No parity or space parity */
comment|/* Check for mark parity */
if|if
condition|(
operator|(
operator|(
name|s
index|[
literal|0
index|]
operator|&
name|s
index|[
literal|1
index|]
operator|&
name|s
index|[
literal|2
index|]
operator|&
name|s
index|[
literal|3
index|]
operator|)
operator|&
literal|0x80
operator|)
operator|==
literal|0x80
condition|)
return|return
operator|(
literal|'m'
operator|)
return|;
comment|/* Mark parity */
comment|/* Packet has some kind of parity */
comment|/* Make 7-bit copies of control fields */
name|s1
operator|=
name|s
index|[
literal|1
index|]
operator|&
literal|0x7f
expr_stmt|;
comment|/* LEN */
name|s2
operator|=
name|s
index|[
literal|2
index|]
operator|&
literal|0x7f
expr_stmt|;
comment|/* SEQ */
name|s3
operator|=
name|s
index|[
literal|3
index|]
operator|&
literal|0x7f
expr_stmt|;
comment|/* TYPE */
comment|/* Check for even parity */
if|if
condition|(
operator|(
name|s
index|[
literal|0
index|]
operator|==
name|partab
index|[
name|s0
index|]
operator|)
operator|&&
operator|(
name|s
index|[
literal|1
index|]
operator|==
name|partab
index|[
name|s1
index|]
operator|)
operator|&&
operator|(
name|s
index|[
literal|2
index|]
operator|==
name|partab
index|[
name|s2
index|]
operator|)
operator|&&
operator|(
name|s
index|[
literal|3
index|]
operator|==
name|partab
index|[
name|s3
index|]
operator|)
condition|)
return|return
operator|(
literal|'e'
operator|)
return|;
comment|/* Check for odd parity */
if|if
condition|(
operator|(
name|s
index|[
literal|0
index|]
operator|!=
name|partab
index|[
name|s0
index|]
operator|)
operator|&&
operator|(
name|s
index|[
literal|1
index|]
operator|!=
name|partab
index|[
name|s1
index|]
operator|)
operator|&&
operator|(
name|s
index|[
literal|2
index|]
operator|!=
name|partab
index|[
name|s2
index|]
operator|)
operator|&&
operator|(
name|s
index|[
literal|3
index|]
operator|!=
name|partab
index|[
name|s3
index|]
operator|)
condition|)
return|return
operator|(
literal|'o'
operator|)
return|;
comment|/* Otherwise it's probably line noise.  Let checksum calculation catch it. */
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* PARSENSE */
end_comment

begin_escape
end_escape

begin_comment
comment|/*   Check to make sure timeout intervals are long enough to allow maximum   length packets to get through before the timer goes off.  If not, the   timeout interval is adjusted upwards.    This routine is called at the beginning of a transaction, before we   know anything about the delay characteristics of the line.  It works   only for serial communication devices; it trusts the speed reported by   the operating system.    Call with a timout interval.  Returns it, adjusted if necessary. */
end_comment

begin_function
name|int
name|chktimo
parameter_list|(
name|timo
parameter_list|,
name|flag
parameter_list|)
name|int
name|timo
decl_stmt|,
name|flag
decl_stmt|;
block|{
name|long
name|cps
decl_stmt|,
name|z
decl_stmt|;
name|int
name|x
decl_stmt|,
name|y
decl_stmt|;
name|debug
argument_list|(
name|F101
argument_list|,
literal|"chktimo timo"
argument_list|,
literal|""
argument_list|,
name|timo
argument_list|)
expr_stmt|;
comment|/* Timeout before adjustment */
name|debug
argument_list|(
name|F101
argument_list|,
literal|"chktimo flag"
argument_list|,
literal|""
argument_list|,
name|flag
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag
condition|)
comment|/* Don't change timeout if user */
return|return
operator|(
name|timo
operator|)
return|;
comment|/* gave SET SEND TIMEOUT command. */
name|debug
argument_list|(
name|F101
argument_list|,
literal|"chktimo spmax"
argument_list|,
literal|""
argument_list|,
name|spmax
argument_list|)
expr_stmt|;
name|debug
argument_list|(
name|F101
argument_list|,
literal|"chktimo urpsiz"
argument_list|,
literal|""
argument_list|,
name|urpsiz
argument_list|)
expr_stmt|;
name|speed
operator|=
name|ttgspd
argument_list|()
expr_stmt|;
comment|/* Get current speed. */
if|if
condition|(
name|speed
operator|>
literal|0L
operator|&&
operator|!
name|network
condition|)
block|{
name|cps
operator|=
name|speed
operator|/
literal|10L
expr_stmt|;
comment|/* Convert to chars per second */
if|if
condition|(
name|cps
operator|>
literal|0L
condition|)
block|{
name|long
name|plen
decl_stmt|;
comment|/* Maximum of send and rcv pkt size */
name|z
operator|=
name|cps
operator|*
operator|(
name|long
operator|)
name|timo
expr_stmt|;
comment|/* Chars per timeout interval */
name|z
operator|-=
name|z
operator|/
literal|10L
expr_stmt|;
comment|/* Less 10 percent */
name|plen
operator|=
name|spmax
expr_stmt|;
if|if
condition|(
name|urpsiz
operator|>
name|spmax
condition|)
name|plen
operator|=
name|urpsiz
expr_stmt|;
name|debug
argument_list|(
name|F101
argument_list|,
literal|"chktimo plen"
argument_list|,
literal|""
argument_list|,
name|plen
argument_list|)
expr_stmt|;
if|if
condition|(
name|z
operator|<
name|plen
condition|)
block|{
comment|/* Compare with packet size */
name|x
operator|=
call|(
name|int
call|)
argument_list|(
operator|(
name|long
operator|)
name|plen
operator|/
name|cps
argument_list|)
expr_stmt|;
comment|/* Adjust if necessary */
name|y
operator|=
name|x
operator|/
literal|10
expr_stmt|;
comment|/* Add 10 percent for safety */
if|if
condition|(
name|y
operator|<
literal|2
condition|)
name|y
operator|=
literal|2
expr_stmt|;
comment|/* Or 2 seconds, whichever is more */
name|x
operator|+=
name|y
expr_stmt|;
if|if
condition|(
name|x
operator|>
name|timo
condition|)
comment|/* If this is greater than current */
name|timo
operator|=
name|x
expr_stmt|;
comment|/* timeout, change the timeout */
name|debug
argument_list|(
name|F101
argument_list|,
literal|"chktimo new timo"
argument_list|,
literal|""
argument_list|,
name|timo
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
operator|(
name|timo
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  S P A C K  --  Construct and send a packet  */
end_comment

begin_comment
comment|/*   spack() sends a packet of the given type, sequence number n, with len data   characters pointed to by d, in either a regular or extended- length packet,   depending on len.  Returns the number of bytes actually sent, or else -1   upon failure.  Uses global npad, padch, mystch, bctu, data.  Leaves packet    fully built and null-terminated for later retransmission by resend().   Updates global sndpktl (send-packet length).    NOTE: The global pointer "data" is assumed to point into the 7th position   of a character array (presumably in packet buffer for the current packet).   It was used by getpkt() to build the packet data field.  spack() fills in   the header to the left of the data pointer (the data pointer is defined   in getsbuf() in ckcfn3.c).  If the address "d" is the same as "data", then   the packet's data field has been built "in place" and need not be copied. */
end_comment

begin_function
name|int
ifdef|#
directive|ifdef
name|CK_ANSIC
name|spack
parameter_list|(
name|char
name|pkttyp
parameter_list|,
name|int
name|n
parameter_list|,
name|int
name|len
parameter_list|,
name|CHAR
modifier|*
name|d
parameter_list|)
else|#
directive|else
function|spack
parameter_list|(
name|pkttyp
parameter_list|,
name|n
parameter_list|,
name|len
parameter_list|,
name|d
parameter_list|)
name|char
name|pkttyp
decl_stmt|;
name|int
name|n
decl_stmt|,
name|len
decl_stmt|;
name|CHAR
modifier|*
name|d
decl_stmt|;
endif|#
directive|endif
comment|/* CK_ANSIC */
comment|/* spack */
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|int
name|j
decl_stmt|,
name|k
decl_stmt|,
name|lp
decl_stmt|,
name|longpkt
decl_stmt|,
name|copy
decl_stmt|;
specifier|register
name|CHAR
modifier|*
name|cp
decl_stmt|,
modifier|*
name|mydata
decl_stmt|;
name|unsigned
name|crc
decl_stmt|;
name|debug
argument_list|(
name|F101
argument_list|,
literal|"spack n"
argument_list|,
literal|""
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|debug
argument_list|(
name|F111
argument_list|,
literal|" data"
argument_list|,
name|data
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|debug
argument_list|(
name|F101
argument_list|,
literal|" d"
argument_list|,
literal|""
argument_list|,
name|d
argument_list|)
expr_stmt|;
name|debug
argument_list|(
name|F101
argument_list|,
literal|" len"
argument_list|,
literal|""
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|copy
operator|=
operator|(
name|d
operator|!=
name|data
operator|)
expr_stmt|;
comment|/* Flag whether data must be copied  */
name|longpkt
operator|=
operator|(
name|len
operator|+
name|bctl
operator|+
literal|2
operator|)
operator|>
literal|94
expr_stmt|;
comment|/* Decide whether it's a long packet */
name|mydata
operator|=
name|data
operator|-
literal|7
operator|+
operator|(
name|longpkt
condition|?
literal|0
else|:
literal|3
operator|)
expr_stmt|;
comment|/* Starting position of header */
name|debug
argument_list|(
name|F101
argument_list|,
literal|" mydata"
argument_list|,
literal|""
argument_list|,
name|mydata
argument_list|)
expr_stmt|;
name|k
operator|=
name|sseqtbl
index|[
name|n
index|]
expr_stmt|;
comment|/* Packet structure info for pkt n */
name|debug
argument_list|(
name|F101
argument_list|,
literal|" sseqtbl[n]"
argument_list|,
literal|""
argument_list|,
name|k
argument_list|)
expr_stmt|;
if|if
condition|(
name|k
operator|<
literal|0
condition|)
block|{
name|debug
argument_list|(
name|F101
argument_list|,
literal|"spack sending packet out of window"
argument_list|,
literal|""
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Record packet info */
name|s_pkt
index|[
name|k
index|]
operator|.
name|pk_adr
operator|=
name|mydata
expr_stmt|;
comment|/* Remember address of packet. */
name|s_pkt
index|[
name|k
index|]
operator|.
name|pk_seq
operator|=
name|n
expr_stmt|;
comment|/* Record sequence number */
name|s_pkt
index|[
name|k
index|]
operator|.
name|pk_typ
operator|=
name|pkttyp
expr_stmt|;
comment|/* Record packet type */
block|}
name|spktl
operator|=
literal|0
expr_stmt|;
comment|/* Initialize length of this packet */
name|i
operator|=
literal|0
expr_stmt|;
comment|/* and position in packet. */
comment|/* Now fill the packet */
name|mydata
index|[
name|i
operator|++
index|]
operator|=
name|mystch
expr_stmt|;
comment|/* MARK */
name|lp
operator|=
name|i
operator|++
expr_stmt|;
comment|/* Position of LEN, fill in later */
name|mydata
index|[
name|i
operator|++
index|]
operator|=
name|tochar
argument_list|(
name|n
argument_list|)
expr_stmt|;
comment|/* SEQ field */
name|mydata
index|[
name|i
operator|++
index|]
operator|=
name|pkttyp
expr_stmt|;
comment|/* TYPE field */
name|j
operator|=
name|len
operator|+
name|bctl
expr_stmt|;
comment|/* Length of data + block check */
if|if
condition|(
name|longpkt
condition|)
block|{
comment|/* Long packet? */
name|int
name|x
decl_stmt|;
comment|/* Work around SCO Xenix/286 */
name|x
operator|=
literal|95
expr_stmt|;
comment|/* compiler bug... */
name|x
operator|=
name|j
operator|/
literal|95
expr_stmt|;
name|mydata
index|[
name|lp
index|]
operator|=
name|tochar
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* Yes, set LEN to zero */
name|mydata
index|[
name|i
operator|++
index|]
operator|=
name|tochar
argument_list|(
name|x
argument_list|)
expr_stmt|;
comment|/* High part */
name|mydata
index|[
name|i
operator|++
index|]
operator|=
name|tochar
argument_list|(
name|j
operator|%
literal|95
argument_list|)
expr_stmt|;
comment|/* Low part */
name|mydata
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* Header checksum */
name|mydata
index|[
name|i
operator|++
index|]
operator|=
name|tochar
argument_list|(
name|chk1
argument_list|(
name|mydata
operator|+
name|lp
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|mydata
index|[
name|lp
index|]
operator|=
name|tochar
argument_list|(
name|j
operator|+
literal|2
argument_list|)
expr_stmt|;
comment|/* Normal LEN */
if|if
condition|(
name|copy
condition|)
comment|/* Data field built in place? */
for|for
control|(
init|;
name|len
operator|--
condition|;
name|i
operator|++
control|)
name|mydata
index|[
name|i
index|]
operator|=
operator|*
name|d
operator|++
expr_stmt|;
comment|/* No, must copy. */
else|else
comment|/* Otherwise, */
name|i
operator|+=
name|len
expr_stmt|;
comment|/* Just skip past data field. */
name|mydata
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* Null-terminate for checksum calc. */
switch|switch
condition|(
name|bctu
condition|)
block|{
comment|/* Block check */
case|case
literal|1
case|:
comment|/* 1 = 6-bit chksum */
name|mydata
index|[
name|i
operator|++
index|]
operator|=
name|tochar
argument_list|(
name|chk1
argument_list|(
name|mydata
operator|+
name|lp
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
comment|/* 2 = 12-bit chksum */
name|j
operator|=
name|chk2
argument_list|(
name|mydata
operator|+
name|lp
argument_list|)
expr_stmt|;
name|mydata
index|[
name|i
operator|++
index|]
operator|=
operator|(
name|unsigned
operator|)
name|tochar
argument_list|(
operator|(
name|j
operator|>>
literal|6
operator|)
operator|&
literal|077
argument_list|)
expr_stmt|;
name|mydata
index|[
name|i
operator|++
index|]
operator|=
operator|(
name|unsigned
operator|)
name|tochar
argument_list|(
name|j
operator|&
literal|077
argument_list|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
comment|/* 3 = 16-bit CRC */
name|crc
operator|=
name|chk3
argument_list|(
name|mydata
operator|+
name|lp
argument_list|)
expr_stmt|;
name|mydata
index|[
name|i
operator|++
index|]
operator|=
operator|(
name|unsigned
operator|)
name|tochar
argument_list|(
operator|(
operator|(
name|crc
operator|&
literal|0170000
operator|)
operator|)
operator|>>
literal|12
argument_list|)
expr_stmt|;
name|mydata
index|[
name|i
operator|++
index|]
operator|=
operator|(
name|unsigned
operator|)
name|tochar
argument_list|(
operator|(
name|crc
operator|>>
literal|6
operator|)
operator|&
literal|077
argument_list|)
expr_stmt|;
name|mydata
index|[
name|i
operator|++
index|]
operator|=
operator|(
name|unsigned
operator|)
name|tochar
argument_list|(
name|crc
operator|&
literal|077
argument_list|)
expr_stmt|;
break|break;
case|case
literal|4
case|:
comment|/* 2 = 12-bit chksum, blank-free */
name|j
operator|=
name|chk2
argument_list|(
name|mydata
operator|+
name|lp
argument_list|)
expr_stmt|;
name|mydata
index|[
name|i
operator|++
index|]
operator|=
call|(
name|unsigned
call|)
argument_list|(
name|tochar
argument_list|(
call|(
name|unsigned
call|)
argument_list|(
operator|(
operator|(
name|j
operator|>>
literal|6
operator|)
operator|&
literal|077
operator|)
operator|+
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|mydata
index|[
name|i
operator|++
index|]
operator|=
call|(
name|unsigned
call|)
argument_list|(
name|tochar
argument_list|(
call|(
name|unsigned
call|)
argument_list|(
operator|(
name|j
operator|&
literal|077
operator|)
operator|+
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
name|mydata
index|[
name|i
operator|++
index|]
operator|=
name|seol
expr_stmt|;
comment|/* End of line (packet terminator) */
ifdef|#
directive|ifdef
name|TCPSOCKET
comment|/*   If TELNET connection and packet terminator is carriage return,   we must stuff either LF or NUL, according to SET TELNET NEWLINE-MODE   (tn_nlm), to meet the TELNET specification. */
if|if
condition|(
name|network
operator|&&
name|ttnproto
operator|==
name|NP_TELNET
operator|&&
name|seol
operator|==
name|CR
condition|)
name|mydata
index|[
name|i
operator|++
index|]
operator|=
name|tn_nlm
condition|?
name|LF
else|:
name|NUL
expr_stmt|;
endif|#
directive|endif
comment|/* TCPSOCKET */
name|mydata
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* Terminate string */
name|logpkt
argument_list|(
literal|'s'
argument_list|,
name|n
argument_list|,
name|mydata
argument_list|)
expr_stmt|;
comment|/* Log packet */
comment|/* (PWP) add the parity quickly at the end */
switch|switch
condition|(
name|parity
condition|)
block|{
case|case
literal|'e'
case|:
comment|/* Even */
for|for
control|(
name|cp
operator|=
operator|&
name|mydata
index|[
name|i
operator|-
literal|1
index|]
init|;
name|cp
operator|>=
name|mydata
condition|;
name|cp
operator|--
control|)
operator|*
name|cp
operator|=
name|partab
index|[
operator|*
name|cp
index|]
expr_stmt|;
break|break;
case|case
literal|'m'
case|:
comment|/* Mark */
for|for
control|(
name|cp
operator|=
operator|&
name|mydata
index|[
name|i
operator|-
literal|1
index|]
init|;
name|cp
operator|>=
name|mydata
condition|;
name|cp
operator|--
control|)
operator|*
name|cp
operator||=
literal|128
expr_stmt|;
break|break;
case|case
literal|'o'
case|:
comment|/* Odd */
for|for
control|(
name|cp
operator|=
operator|&
name|mydata
index|[
name|i
operator|-
literal|1
index|]
init|;
name|cp
operator|>=
name|mydata
condition|;
name|cp
operator|--
control|)
operator|*
name|cp
operator|=
name|partab
index|[
operator|*
name|cp
index|]
operator|^
literal|128
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
comment|/* Space */
for|for
control|(
name|cp
operator|=
operator|&
name|mydata
index|[
name|i
operator|-
literal|1
index|]
init|;
name|cp
operator|>=
name|mydata
condition|;
name|cp
operator|--
control|)
operator|*
name|cp
operator|&=
literal|127
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|npad
condition|)
name|ttol
argument_list|(
name|padbuf
argument_list|,
name|npad
argument_list|)
expr_stmt|;
comment|/* Send any padding */
name|spktl
operator|=
name|i
expr_stmt|;
comment|/* Remember packet length */
name|s_pkt
index|[
name|k
index|]
operator|.
name|pk_len
operator|=
name|spktl
expr_stmt|;
comment|/* also in packet info structure */
if|if
condition|(
name|ttol
argument_list|(
name|mydata
argument_list|,
name|spktl
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* Send the packet */
name|sndtyp
operator|=
name|pkttyp
expr_stmt|;
comment|/* Remember packet type for echos */
name|spackets
operator|++
expr_stmt|;
comment|/* Count it. */
name|flco
operator|+=
name|spktl
expr_stmt|;
comment|/* Count the characters */
name|tlco
operator|+=
name|spktl
expr_stmt|;
comment|/* for statistics... */
name|dumpsbuf
argument_list|()
expr_stmt|;
comment|/* Dump send buffers to debug log */
name|screen
argument_list|(
name|SCR_PT
argument_list|,
name|pkttyp
argument_list|,
operator|(
name|long
operator|)
name|n
argument_list|,
operator|(
name|char
operator|*
operator|)
name|mydata
argument_list|)
expr_stmt|;
comment|/* Update screen */
return|return
operator|(
name|spktl
operator|)
return|;
comment|/* Return length */
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  C H K 1  --  Compute a type-1 Kermit 6-bit checksum.  */
end_comment

begin_function
name|int
name|chk1
parameter_list|(
name|pkt
parameter_list|)
specifier|register
name|CHAR
modifier|*
name|pkt
decl_stmt|;
block|{
specifier|register
name|unsigned
name|int
name|chk
decl_stmt|;
name|chk
operator|=
name|chk2
argument_list|(
name|pkt
argument_list|)
expr_stmt|;
name|chk
operator|=
operator|(
operator|(
operator|(
name|chk
operator|&
literal|0300
operator|)
operator|>>
literal|6
operator|)
operator|+
name|chk
operator|)
operator|&
literal|077
expr_stmt|;
return|return
operator|(
operator|(
name|int
operator|)
name|chk
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  C H K 2  --  Compute the numeric sum of all the bytes in the packet.  */
end_comment

begin_function
name|unsigned
name|int
name|chk2
parameter_list|(
name|pkt
parameter_list|)
specifier|register
name|CHAR
modifier|*
name|pkt
decl_stmt|;
block|{
specifier|register
name|long
name|chk
decl_stmt|;
specifier|register
name|unsigned
name|int
name|m
decl_stmt|;
name|m
operator|=
operator|(
name|parity
operator|)
condition|?
literal|0177
else|:
literal|0377
expr_stmt|;
for|for
control|(
name|chk
operator|=
literal|0
init|;
operator|*
name|pkt
operator|!=
literal|'\0'
condition|;
name|pkt
operator|++
control|)
name|chk
operator|+=
operator|*
name|pkt
operator|&
name|m
expr_stmt|;
return|return
operator|(
call|(
name|unsigned
name|int
call|)
argument_list|(
name|chk
operator|&
literal|07777
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  C H K 3  --  Compute a type-3 Kermit block check.  */
end_comment

begin_comment
comment|/*  Calculate the 16-bit CRC-CCITT of a null-terminated string using a lookup   table.  Assumes the argument string contains no embedded nulls. */
end_comment

begin_function
name|unsigned
name|int
name|chk3
parameter_list|(
name|pkt
parameter_list|)
specifier|register
name|CHAR
modifier|*
name|pkt
decl_stmt|;
block|{
specifier|register
name|long
name|c
decl_stmt|,
name|crc
decl_stmt|;
specifier|register
name|unsigned
name|int
name|m
decl_stmt|;
name|m
operator|=
operator|(
name|parity
operator|)
condition|?
literal|0177
else|:
literal|0377
expr_stmt|;
for|for
control|(
name|crc
operator|=
literal|0
init|;
operator|*
name|pkt
operator|!=
literal|'\0'
condition|;
name|pkt
operator|++
control|)
block|{
name|c
operator|=
name|crc
operator|^
call|(
name|long
call|)
argument_list|(
operator|*
name|pkt
operator|&
name|m
argument_list|)
expr_stmt|;
name|crc
operator|=
operator|(
name|crc
operator|>>
literal|8
operator|)
operator|^
operator|(
name|crcta
index|[
operator|(
name|c
operator|&
literal|0xF0
operator|)
operator|>>
literal|4
index|]
operator|^
name|crctb
index|[
name|c
operator|&
literal|0x0F
index|]
operator|)
expr_stmt|;
block|}
return|return
operator|(
call|(
name|unsigned
name|int
call|)
argument_list|(
name|crc
operator|&
literal|0xFFFF
argument_list|)
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_function
name|int
name|nxtpkt
parameter_list|()
block|{
comment|/* Called by file sender */
name|int
name|j
decl_stmt|,
name|n
decl_stmt|;
name|debug
argument_list|(
name|F101
argument_list|,
literal|"nxtpkt pktnum"
argument_list|,
literal|""
argument_list|,
name|pktnum
argument_list|)
expr_stmt|;
name|debug
argument_list|(
name|F101
argument_list|,
literal|"nxtpkt winlo "
argument_list|,
literal|""
argument_list|,
name|winlo
argument_list|)
expr_stmt|;
name|n
operator|=
operator|(
name|pktnum
operator|+
literal|1
operator|)
operator|%
literal|64
expr_stmt|;
comment|/* Increment packet number mod 64 */
ifdef|#
directive|ifdef
name|COMMENT
comment|/*   Suggested by Alan Grieg.  A packet can be sent out of window in    circumstances involving acks received out of order, ...  Have to think   about this... */
if|if
condition|(
name|chkwin
argument_list|(
name|n
argument_list|,
name|winlo
argument_list|,
name|wslots
argument_list|)
condition|)
block|{
name|debug
argument_list|(
name|F101
argument_list|,
literal|"nxtpkt n not in window"
argument_list|,
literal|""
argument_list|,
name|n
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
endif|#
directive|endif
name|j
operator|=
name|getsbuf
argument_list|(
name|n
argument_list|)
expr_stmt|;
comment|/* Get a buffer for packet n */
if|if
condition|(
name|j
operator|<
literal|0
condition|)
block|{
name|debug
argument_list|(
name|F101
argument_list|,
literal|"nxtpkt can't getsbuf"
argument_list|,
literal|""
argument_list|,
name|j
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|pktnum
operator|=
name|n
expr_stmt|;
name|debug
argument_list|(
name|F101
argument_list|,
literal|"nxtpkt bumped pktnum to"
argument_list|,
literal|""
argument_list|,
name|pktnum
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Functions for sending ACKs and NAKs */
end_comment

begin_comment
comment|/* Note, we should only ACK the packet at window-low (winlo) */
end_comment

begin_comment
comment|/* However, if an old packet arrives again (e.g. because the ACK we sent */
end_comment

begin_comment
comment|/* earlier was lost), we ACK it again. */
end_comment

begin_function
name|int
name|ack
parameter_list|()
block|{
comment|/* Acknowledge the current packet. */
return|return
operator|(
name|ackns
argument_list|(
name|winlo
argument_list|,
operator|(
name|CHAR
operator|*
operator|)
literal|""
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ackns
parameter_list|(
name|n
parameter_list|,
name|s
parameter_list|)
name|int
name|n
decl_stmt|;
name|CHAR
modifier|*
name|s
decl_stmt|;
block|{
comment|/* Acknowledge packet n */
name|int
name|j
decl_stmt|,
name|k
decl_stmt|;
name|debug
argument_list|(
name|F111
argument_list|,
literal|"ackns"
argument_list|,
name|s
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|k
operator|=
name|rseqtbl
index|[
name|n
index|]
expr_stmt|;
comment|/* First find received packet n. */
name|debug
argument_list|(
name|F101
argument_list|,
literal|"ackns k"
argument_list|,
literal|""
argument_list|,
name|k
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|COMMENT
comment|/* No need to set ACK'd bit, because we're gonna free the buffer now */
if|if
condition|(
name|k
operator|>
operator|-
literal|1
condition|)
comment|/* If in window */
name|s_pkt
index|[
name|k
index|]
operator|.
name|pk_flg
operator|++
expr_stmt|;
comment|/* mark the ack'd bit. */
else|else
name|debug
argument_list|(
name|F101
argument_list|,
literal|"ackns can't set ack'd bit"
argument_list|,
literal|""
argument_list|,
name|k
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|freesbuf
argument_list|(
name|n
argument_list|)
expr_stmt|;
comment|/* Free current send-buffer, if any */
if|if
condition|(
operator|(
name|j
operator|=
name|getsbuf
argument_list|(
name|n
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
comment|/* This can happen if we have to re-ACK an old packet that has */
comment|/* already left the window.  It does no harm. */
name|debug
argument_list|(
name|F101
argument_list|,
literal|"ackns can't getsbuf"
argument_list|,
literal|""
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
name|spack
argument_list|(
literal|'Y'
argument_list|,
name|n
argument_list|,
operator|(
name|int
operator|)
name|strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|s
argument_list|)
argument_list|,
name|s
argument_list|)
expr_stmt|;
comment|/* Now send it. */
name|debug
argument_list|(
name|F101
argument_list|,
literal|"ackns winlo"
argument_list|,
literal|""
argument_list|,
name|winlo
argument_list|)
expr_stmt|;
name|debug
argument_list|(
name|F101
argument_list|,
literal|"ackns n"
argument_list|,
literal|""
argument_list|,
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
name|winlo
condition|)
block|{
comment|/* If we're acking winlo */
if|if
condition|(
name|k
operator|>
operator|-
literal|1
condition|)
name|freerbuf
argument_list|(
name|k
argument_list|)
expr_stmt|;
comment|/* don't need it any more */
if|if
condition|(
name|j
operator|>
operator|-
literal|1
condition|)
name|freesbuf
argument_list|(
name|j
argument_list|)
expr_stmt|;
comment|/* and don't need to keep ACK either */
name|winlo
operator|=
operator|(
name|winlo
operator|+
literal|1
operator|)
operator|%
literal|64
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ackn
parameter_list|(
name|n
parameter_list|)
name|int
name|n
decl_stmt|;
block|{
comment|/* Send ACK for packet number n */
return|return
operator|(
name|ackns
argument_list|(
name|n
argument_list|,
operator|(
name|CHAR
operator|*
operator|)
literal|""
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ack1
parameter_list|(
name|s
parameter_list|)
name|CHAR
modifier|*
name|s
decl_stmt|;
block|{
comment|/* Send an ACK with data. */
name|debug
argument_list|(
name|F110
argument_list|,
literal|"ack1"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|s
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|ackns
argument_list|(
name|winlo
argument_list|,
name|s
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* N A C K  --   Send a Negative ACKnowledgment. */
end_comment

begin_comment
comment|/*  Call with the packet number, n, to be NAK'd.  Returns -1 if that packet has been NAK'd too many times, otherwise 0.  Btw, it is not right to return 0 under error conditions.  This is  done because the -1 code is used for cancelling the file transfer.  More work is needed here. */
end_comment

begin_function
name|int
name|nack
parameter_list|(
name|n
parameter_list|)
name|int
name|n
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
operator|||
name|n
operator|>
literal|63
condition|)
block|{
name|debug
argument_list|(
name|F101
argument_list|,
literal|"nack bad pkt num"
argument_list|,
literal|""
argument_list|,
name|n
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
else|else
name|debug
argument_list|(
name|F101
argument_list|,
literal|"nack"
argument_list|,
literal|""
argument_list|,
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|=
name|sseqtbl
index|[
name|n
index|]
operator|)
operator|<
literal|0
condition|)
block|{
comment|/* If necessary */
if|if
condition|(
name|getsbuf
argument_list|(
name|n
argument_list|)
operator|<
literal|0
condition|)
block|{
comment|/* get a buffer for this NAK */
name|debug
argument_list|(
name|F101
argument_list|,
literal|"nack can't getsbuf"
argument_list|,
literal|""
argument_list|,
name|n
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
else|else
name|i
operator|=
name|sseqtbl
index|[
name|n
index|]
expr_stmt|;
comment|/* New slot number */
block|}
if|if
condition|(
name|s_pkt
index|[
name|i
index|]
operator|.
name|pk_rtr
operator|++
operator|>
name|maxtry
condition|)
comment|/* How many times have we done this? */
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* Too many... */
comment|/* Note, don't free this buffer.  Eventually an ACK will come, and that */
comment|/* will set it free.  If not, well, it's back to ground zero anyway...  */
name|spack
argument_list|(
literal|'N'
argument_list|,
name|n
argument_list|,
literal|0
argument_list|,
operator|(
name|CHAR
operator|*
operator|)
literal|""
argument_list|)
expr_stmt|;
comment|/* NAKs never have data. */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * (PWP) recalculate the optimal packet length in the face of errors.  * This is a modified version of the algorithm by John Chandler in Kermit/370,   * see "Dynamic Packet Size Control", Kermit News, V2 #1, June 1988.  *  * This implementation minimizes the total overhead equation, which is  *  *   Total chars = file_chars + (header_len * num_packs)  *                            + (errors * (header_len + packet_len))  *  * Differentiate with respect to number of chars, solve for packet_len, get:  *  *   packet_len = sqrt (file_chars * header_len / errors)  */
end_comment

begin_comment
comment|/*  (FDC) New super-simple algorithm.  If there was an error in the most recent  packet exchange, cut the send-packet size in half, down to a minimum of 20.  If there was no error, increase the size by 5/4, up to the maximum negotiated  length.  Seems to be much more responsive than previous algorithm, which took  forever to recover the original packet length, and it also went crazy under  certain conditions.   Here's another idea for packet length resizing that keeps a history of the  last n packets.  Push a 1 into the left end of an n-bit shift register if the  current packet is good, otherwise push a zero.  The current n-bit value, w, of  this register is a weighted sum of the noise hits for the last n packets, with  the most recent weighing the most.  The current packet length is some function  of w and the negotiated packet length, like:     (2^n - w) / (2^n) * (negotiated length)   If the present resizing method causes problems, think about this one a little  more. */
end_comment

begin_function
name|VOID
name|rcalcpsz
parameter_list|()
block|{
ifdef|#
directive|ifdef
name|COMMENT
comment|/* Old way */
specifier|register
name|long
name|x
decl_stmt|,
name|q
decl_stmt|;
if|if
condition|(
name|numerrs
operator|==
literal|0
condition|)
return|return;
comment|/* bounds check just in case */
comment|/* overhead on a data packet is npad+5+bctr, plus 3 if extended packet */
comment|/* an ACK is 5+bctr */
comment|/* first set x = per packet overhead */
if|if
condition|(
name|wslots
operator|>
literal|1
condition|)
name|x
operator|=
call|(
name|long
call|)
argument_list|(
name|npad
operator|+
literal|5
operator|+
name|bctr
argument_list|)
expr_stmt|;
comment|/* only the packet, don't count the ack */
else|else
name|x
operator|=
call|(
name|long
call|)
argument_list|(
name|npad
operator|+
literal|5
operator|+
literal|3
operator|+
name|bctr
operator|+
literal|5
operator|+
name|bctr
argument_list|)
expr_stmt|;
comment|/* then set x = packet length ** 2 */
name|x
operator|=
name|x
operator|*
operator|(
name|ffc
operator|/
operator|(
name|long
operator|)
name|numerrs
operator|)
expr_stmt|;
comment|/* careful of overflow */
comment|/* calculate the long integer sqrt(x) quickly */
name|q
operator|=
literal|500
expr_stmt|;
name|q
operator|=
operator|(
name|q
operator|+
name|x
operator|/
name|q
operator|)
operator|>>
literal|1
expr_stmt|;
name|q
operator|=
operator|(
name|q
operator|+
name|x
operator|/
name|q
operator|)
operator|>>
literal|1
expr_stmt|;
name|q
operator|=
operator|(
name|q
operator|+
name|x
operator|/
name|q
operator|)
operator|>>
literal|1
expr_stmt|;
name|q
operator|=
operator|(
name|q
operator|+
name|x
operator|/
name|q
operator|)
operator|>>
literal|1
expr_stmt|;
comment|/* should converge in about 4 steps */
if|if
condition|(
operator|(
name|q
operator|>
literal|94
operator|)
operator|&&
operator|(
name|q
operator|<
literal|130
operator|)
condition|)
comment|/* break-even point for long packets */
name|q
operator|=
literal|94
expr_stmt|;
if|if
condition|(
name|q
operator|>
name|spmax
condition|)
name|q
operator|=
name|spmax
expr_stmt|;
comment|/* maximum bounds */
if|if
condition|(
name|q
operator|<
literal|10
condition|)
name|q
operator|=
literal|10
expr_stmt|;
comment|/* minimum bounds */
name|spsiz
operator|=
name|q
expr_stmt|;
comment|/* set new send packet size */
name|debug
argument_list|(
name|F101
argument_list|,
literal|"rcalcpsiz"
argument_list|,
literal|""
argument_list|,
name|q
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* New way */
if|if
condition|(
name|spackets
operator|<
literal|3
condition|)
return|return;
name|debug
argument_list|(
name|F101
argument_list|,
literal|"rcalcpsiz numerrs"
argument_list|,
literal|""
argument_list|,
name|numerrs
argument_list|)
expr_stmt|;
name|debug
argument_list|(
name|F101
argument_list|,
literal|"rcalcpsiz spsiz"
argument_list|,
literal|""
argument_list|,
name|spsiz
argument_list|)
expr_stmt|;
if|if
condition|(
name|numerrs
condition|)
name|spsiz
operator|=
name|spsiz
operator|/
literal|2
expr_stmt|;
else|else
name|spsiz
operator|=
operator|(
name|spsiz
operator|/
literal|4
operator|)
operator|*
literal|5
expr_stmt|;
if|if
condition|(
name|spsiz
operator|<
literal|20
condition|)
name|spsiz
operator|=
literal|20
expr_stmt|;
if|if
condition|(
name|spsiz
operator|>
name|spmax
condition|)
name|spsiz
operator|=
name|spmax
expr_stmt|;
name|debug
argument_list|(
name|F101
argument_list|,
literal|"rcalcpsiz new spsiz"
argument_list|,
literal|""
argument_list|,
name|spsiz
argument_list|)
expr_stmt|;
name|numerrs
operator|=
literal|0
expr_stmt|;
return|return;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  R E S E N D  --  Retransmit packet n.  */
end_comment

begin_comment
comment|/*   Returns 0 or positive on success (the number of retries for packet n).   On failure, returns a negative number, and an error message is placed   in recpkt. */
end_comment

begin_function
name|int
name|resend
parameter_list|(
name|n
parameter_list|)
name|int
name|n
decl_stmt|;
block|{
comment|/* Send packet n again. */
name|int
name|j
decl_stmt|,
name|k
decl_stmt|;
name|debug
argument_list|(
name|F101
argument_list|,
literal|"resend seq"
argument_list|,
literal|""
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|k
operator|=
name|chkwin
argument_list|(
name|n
argument_list|,
name|winlo
argument_list|,
name|wslots
argument_list|)
expr_stmt|;
comment|/* See if packet in current window */
name|j
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* Assume it's lost */
if|if
condition|(
name|k
operator|==
literal|0
condition|)
name|j
operator|=
name|sseqtbl
index|[
name|n
index|]
expr_stmt|;
comment|/* See if we still have a copy of it */
if|if
condition|(
name|k
operator|!=
literal|0
operator|||
name|j
operator|<
literal|0
condition|)
block|{
comment|/* If not.... */
if|if
condition|(
name|nakstate
operator|&&
name|k
operator|==
literal|1
condition|)
block|{
comment|/*   Packet n is in the previous window and we are the file receiver.   We already sent the ACK and deallocated its buffer so we can't just    retransmit the ACK.  Rather than give up, we try some tricks... */
if|if
condition|(
name|n
operator|==
literal|0
operator|&&
name|spackets
operator|<
literal|63
operator|&&
name|myinit
index|[
literal|0
index|]
condition|)
block|{
comment|/* ACK to Send-Init */
comment|/*   If the packet number is 0, and we're at the beginning of a protocol   operation (spackets< 63), then we have to resend the ACK to an I or S   packet, complete with parameters in the data field.  So we take a chance and   send a copy of the parameters in an ACK packet with block check type 1. */
name|int
name|bctlsav
decl_stmt|;
comment|/* Temporary storage */
name|int
name|bctusav
decl_stmt|;
name|bctlsav
operator|=
name|bctl
expr_stmt|;
comment|/* Save current block check length */
name|bctusav
operator|=
name|bctu
expr_stmt|;
comment|/* and type */
name|bctu
operator|=
name|bctl
operator|=
literal|1
expr_stmt|;
comment|/* Set block check to 1 */
name|spack
argument_list|(
literal|'Y'
argument_list|,
literal|0
argument_list|,
operator|(
name|int
operator|)
name|strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|myinit
argument_list|)
argument_list|,
operator|(
name|CHAR
operator|*
operator|)
name|myinit
argument_list|)
expr_stmt|;
name|logpkt
argument_list|(
literal|'#'
argument_list|,
name|n
argument_list|,
operator|(
name|CHAR
operator|*
operator|)
literal|"<reconstructed>"
argument_list|)
expr_stmt|;
comment|/* Log it */
name|bctu
operator|=
name|bctusav
expr_stmt|;
comment|/* Restore block check type */
name|bctl
operator|=
name|bctlsav
expr_stmt|;
comment|/* and length */
block|}
else|else
block|{
comment|/* Not the first packet */
comment|/*   It's not the first packet of the protocol operation.  It's some other packet   that we have already ACK'd and forgotten about.  So we take a chance and   send an empty ACK using the current block-check type.  Usually this will   work out OK (like when acking Data packets), and no great harm will be done   if it was some other kind of packet (F, etc).  If we are requesting an   interruption of the file transfer, the flags are still set, so we'll catch   up on the next packet. */
name|spack
argument_list|(
literal|'Y'
argument_list|,
name|n
argument_list|,
literal|0
argument_list|,
operator|(
name|CHAR
operator|*
operator|)
literal|""
argument_list|)
expr_stmt|;
name|logpkt
argument_list|(
literal|'#'
argument_list|,
name|n
argument_list|,
operator|(
name|CHAR
operator|*
operator|)
literal|"<faith>"
argument_list|)
expr_stmt|;
comment|/* Log it */
block|}
name|retrans
operator|++
expr_stmt|;
name|screen
argument_list|(
name|SCR_PT
argument_list|,
literal|'%'
argument_list|,
operator|(
name|long
operator|)
name|pktnum
argument_list|,
literal|"(resend)"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
else|else
block|{
comment|/*   Packet number is not in current or previous window.  We seem to hit this   code occasionally at the beginning of a transaction, for apparently no good   reason.  Let's just log it for debugging, send nothing, and try to proceed   with the protocol rather than killing it. */
name|debug
argument_list|(
name|F101
argument_list|,
literal|"RESEND PKT NOT IN WINDOW"
argument_list|,
literal|""
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|debug
argument_list|(
name|F101
argument_list|,
literal|"RESEND k"
argument_list|,
literal|""
argument_list|,
name|k
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|COMMENT
name|sprintf
argument_list|(
operator|(
name|char
operator|*
operator|)
name|recpkt
argument_list|,
literal|"   resend error: NIW, n=%d, k=%d."
argument_list|,
name|n
argument_list|,
name|k
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|2
operator|)
return|;
else|#
directive|else
return|return
operator|(
literal|0
operator|)
return|;
endif|#
directive|endif
comment|/* COMMENT */
block|}
block|}
comment|/* OK, it's in the window and it's not lost. */
name|debug
argument_list|(
name|F101
argument_list|,
literal|"resend pktinfo index"
argument_list|,
literal|""
argument_list|,
name|k
argument_list|)
expr_stmt|;
if|if
condition|(
name|s_pkt
index|[
name|j
index|]
operator|.
name|pk_rtr
operator|++
operator|>
name|maxtry
condition|)
block|{
comment|/* Found it but over retry limit */
name|strcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|recpkt
argument_list|,
literal|"Too many retries."
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|debug
argument_list|(
name|F101
argument_list|,
literal|" retry"
argument_list|,
literal|""
argument_list|,
name|s_pkt
index|[
name|j
index|]
operator|.
name|pk_rtr
argument_list|)
expr_stmt|;
comment|/* OK so far */
name|dumpsbuf
argument_list|()
expr_stmt|;
comment|/* (debugging) */
if|if
condition|(
name|s_pkt
index|[
name|j
index|]
operator|.
name|pk_typ
operator|==
literal|' '
condition|)
block|{
comment|/* Incompletely formed packet */
if|if
condition|(
name|nakstate
condition|)
block|{
comment|/* (This shouldn't happen any more) */
name|nack
argument_list|(
name|n
argument_list|)
expr_stmt|;
name|retrans
operator|++
expr_stmt|;
name|screen
argument_list|(
name|SCR_PT
argument_list|,
literal|'%'
argument_list|,
operator|(
name|long
operator|)
name|pktnum
argument_list|,
literal|"(resend)"
argument_list|)
expr_stmt|;
return|return
operator|(
name|s_pkt
index|[
name|j
index|]
operator|.
name|pk_rtr
operator|)
return|;
block|}
else|else
block|{
comment|/* No packet to resend! */
ifdef|#
directive|ifdef
name|COMMENT
comment|/*   This happened (once) while sending a file with 2 window slots and typing   X to the sender to cancel the file.  But since we're cancelling anyway,   no need to give a scary message. */
name|sprintf
argument_list|(
operator|(
name|char
operator|*
operator|)
name|recpkt
argument_list|,
literal|"resend logic error: NPS, n=%d, j=%d."
argument_list|,
name|n
argument_list|,
name|j
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|2
operator|)
return|;
else|#
directive|else
comment|/* Just ignore it. */
return|return
operator|(
literal|0
operator|)
return|;
endif|#
directive|endif
comment|/* COMMENT */
block|}
block|}
name|ttol
argument_list|(
name|s_pkt
index|[
name|j
index|]
operator|.
name|pk_adr
argument_list|,
name|s_pkt
index|[
name|j
index|]
operator|.
name|pk_len
argument_list|)
expr_stmt|;
comment|/* Everything ok, send the packet */
name|retrans
operator|++
expr_stmt|;
comment|/* Count a retransmission */
name|screen
argument_list|(
name|SCR_PT
argument_list|,
literal|'%'
argument_list|,
operator|(
name|long
operator|)
name|pktnum
argument_list|,
literal|"(resend)"
argument_list|)
expr_stmt|;
comment|/* Tell user about resend */
name|logpkt
argument_list|(
literal|'S'
argument_list|,
name|n
argument_list|,
name|s_pkt
index|[
name|j
index|]
operator|.
name|pk_adr
argument_list|)
expr_stmt|;
comment|/* Log the resent packet */
return|return
operator|(
name|s_pkt
index|[
name|j
index|]
operator|.
name|pk_rtr
operator|)
return|;
comment|/* Return the number of retries. */
block|}
end_function

begin_function
name|int
name|errpkt
parameter_list|(
name|reason
parameter_list|)
name|CHAR
modifier|*
name|reason
decl_stmt|;
block|{
comment|/* Send an error packet. */
name|int
name|x
decl_stmt|,
name|y
decl_stmt|;
name|encstr
argument_list|(
name|reason
argument_list|)
expr_stmt|;
name|y
operator|=
name|spack
argument_list|(
literal|'E'
argument_list|,
name|pktnum
argument_list|,
name|size
argument_list|,
name|encbuf
operator|+
literal|7
argument_list|)
expr_stmt|;
name|x
operator|=
name|quiet
expr_stmt|;
name|quiet
operator|=
literal|1
expr_stmt|;
comment|/* Close files silently. */
name|clsif
argument_list|()
expr_stmt|;
name|clsof
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|quiet
operator|=
name|x
expr_stmt|;
ifdef|#
directive|ifdef
name|COMMENT
name|screen
argument_list|(
name|SCR_TC
argument_list|,
literal|0
argument_list|,
literal|0l
argument_list|,
literal|""
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* COMMENT */
if|if
condition|(
name|what
operator|<
name|W_CONNECT
condition|)
name|xitsta
operator||=
name|what
expr_stmt|;
comment|/* Remember what failed. */
name|success
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|y
operator|)
return|;
block|}
end_function

begin_comment
comment|/* scmd()  --  Send a packet of the given type */
end_comment

begin_function
name|int
ifdef|#
directive|ifdef
name|CK_ANSIC
name|scmd
parameter_list|(
name|char
name|t
parameter_list|,
name|CHAR
modifier|*
name|dat
parameter_list|)
else|#
directive|else
function|scmd
parameter_list|(
name|t
parameter_list|,
name|dat
parameter_list|)
name|char
name|t
decl_stmt|;
name|CHAR
modifier|*
name|dat
decl_stmt|;
endif|#
directive|endif
comment|/* CK_ANSIC */
comment|/* scmd */
block|{
name|encstr
argument_list|(
name|dat
argument_list|)
expr_stmt|;
comment|/* Encode the command string */
name|spack
argument_list|(
name|t
argument_list|,
name|pktnum
argument_list|,
name|size
argument_list|,
operator|(
name|CHAR
operator|*
operator|)
operator|(
name|encbuf
operator|+
literal|7
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|VOID
name|srinit
parameter_list|()
block|{
comment|/* Send R (GET) packet */
name|encstr
argument_list|(
operator|(
name|CHAR
operator|*
operator|)
name|cmarg
argument_list|)
expr_stmt|;
comment|/* Encode the filename. */
name|spack
argument_list|(
literal|'R'
argument_list|,
name|pktnum
argument_list|,
name|size
argument_list|,
name|encbuf
operator|+
literal|7
argument_list|)
expr_stmt|;
comment|/* Send the packet. */
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* R P A C K  --  Read a Packet */
end_comment

begin_comment
comment|/*  rpack reads a packet and returns the packet type, or else Q if the  packet was invalid, or T if a timeout occurred.  Upon successful return, sets  the values of global rsn (received sequence number),  rln (received  data length), and rdatap (pointer to null-terminated data field). */
end_comment

begin_function
name|int
name|rpack
parameter_list|()
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|x
decl_stmt|,
name|lp
decl_stmt|;
comment|/* Local variables */
name|int
name|k
decl_stmt|,
name|type
decl_stmt|,
name|chklen
decl_stmt|;
name|unsigned
name|crc
decl_stmt|;
name|CHAR
name|pbc
index|[
literal|4
index|]
decl_stmt|;
comment|/* Packet block check */
name|CHAR
modifier|*
name|sohp
decl_stmt|;
comment|/* Pointer to SOH */
name|CHAR
name|e
decl_stmt|;
comment|/* Packet end character */
name|debug
argument_list|(
name|F101
argument_list|,
literal|"entering rpack, pktnum"
argument_list|,
literal|""
argument_list|,
name|pktnum
argument_list|)
expr_stmt|;
name|k
operator|=
name|getrbuf
argument_list|()
expr_stmt|;
comment|/* Get a new packet input buffer. */
name|debug
argument_list|(
name|F101
argument_list|,
literal|"rpack getrbuf"
argument_list|,
literal|""
argument_list|,
name|k
argument_list|)
expr_stmt|;
if|if
condition|(
name|k
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* Return like this if none free. */
name|recpkt
operator|=
name|r_pkt
index|[
name|k
index|]
operator|.
name|bf_adr
expr_stmt|;
operator|*
name|recpkt
operator|=
literal|'\0'
expr_stmt|;
comment|/* Clear receive buffer. */
name|sohp
operator|=
name|recpkt
expr_stmt|;
comment|/* Initialize pointers to it. */
name|rdatap
operator|=
name|recpkt
expr_stmt|;
name|rsn
operator|=
name|rln
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* In case of failure. */
name|e
operator|=
operator|(
name|turn
operator|)
condition|?
name|turnch
else|:
name|eol
expr_stmt|;
comment|/* Use any handshake char for eol */
comment|/* Try to get a "line". */
ifdef|#
directive|ifdef
name|PARSENSE
ifdef|#
directive|ifdef
name|UNIX
comment|/*   So far the final turn argument is only for ck[uvd]tio.c.  Should be added   to the others too.  (turn == handshake character.) */
name|j
operator|=
name|ttinl
argument_list|(
name|recpkt
argument_list|,
name|r_pkt
index|[
name|k
index|]
operator|.
name|bf_len
operator|-
literal|1
argument_list|,
name|timint
argument_list|,
name|e
argument_list|,
name|stchr
argument_list|,
name|turn
argument_list|)
expr_stmt|;
else|#
directive|else
ifdef|#
directive|ifdef
name|VMS
name|j
operator|=
name|ttinl
argument_list|(
name|recpkt
argument_list|,
name|r_pkt
index|[
name|k
index|]
operator|.
name|bf_len
operator|-
literal|1
argument_list|,
name|timint
argument_list|,
name|e
argument_list|,
name|stchr
argument_list|,
name|turn
argument_list|)
expr_stmt|;
else|#
directive|else
ifdef|#
directive|ifdef
name|datageneral
name|j
operator|=
name|ttinl
argument_list|(
name|recpkt
argument_list|,
name|r_pkt
index|[
name|k
index|]
operator|.
name|bf_len
operator|-
literal|1
argument_list|,
name|timint
argument_list|,
name|e
argument_list|,
name|stchr
argument_list|,
name|turn
argument_list|)
expr_stmt|;
else|#
directive|else
name|j
operator|=
name|ttinl
argument_list|(
name|recpkt
argument_list|,
name|r_pkt
index|[
name|k
index|]
operator|.
name|bf_len
operator|-
literal|1
argument_list|,
name|timint
argument_list|,
name|e
argument_list|,
name|stchr
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* datageneral */
endif|#
directive|endif
comment|/* VMS */
endif|#
directive|endif
comment|/* UNIX */
if|if
condition|(
name|parity
operator|!=
name|ttprty
condition|)
name|autopar
operator|=
literal|1
expr_stmt|;
name|parity
operator|=
name|ttprty
expr_stmt|;
else|#
directive|else
name|j
operator|=
name|ttinl
argument_list|(
name|recpkt
argument_list|,
name|r_pkt
index|[
name|k
index|]
operator|.
name|bf_len
operator|-
literal|1
argument_list|,
name|timint
argument_list|,
name|e
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* PARSENSE */
if|if
condition|(
name|j
operator|<
literal|0
condition|)
block|{
name|debug
argument_list|(
name|F101
argument_list|,
literal|"rpack: ttinl fails"
argument_list|,
literal|""
argument_list|,
name|j
argument_list|)
expr_stmt|;
comment|/* Otherwise, */
name|freerbuf
argument_list|(
name|k
argument_list|)
expr_stmt|;
comment|/* Free this buffer */
if|if
condition|(
name|j
operator|<
operator|-
literal|1
condition|)
block|{
comment|/* Bail out if ^C^C typed. */
name|debug
argument_list|(
name|F101
argument_list|,
literal|"rpack ^C server"
argument_list|,
literal|""
argument_list|,
name|server
argument_list|)
expr_stmt|;
name|debug
argument_list|(
name|F101
argument_list|,
literal|"rpack ^C en_fin"
argument_list|,
literal|""
argument_list|,
name|en_fin
argument_list|)
expr_stmt|;
if|if
condition|(
name|server
operator|==
literal|0
condition|)
return|return
operator|(
name|j
operator|)
return|;
comment|/* But not if in server mode */
elseif|else
if|if
condition|(
name|en_fin
condition|)
return|return
operator|(
name|j
operator|)
return|;
comment|/* with DISABLE FINISH */
block|}
if|if
condition|(
name|nakstate
condition|)
comment|/* call it a timeout. */
name|screen
argument_list|(
name|SCR_PT
argument_list|,
literal|'T'
argument_list|,
operator|(
name|long
operator|)
name|winlo
argument_list|,
literal|""
argument_list|)
expr_stmt|;
else|else
name|screen
argument_list|(
name|SCR_PT
argument_list|,
literal|'T'
argument_list|,
operator|(
name|long
operator|)
name|pktnum
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|logpkt
argument_list|(
literal|'r'
argument_list|,
operator|-
literal|1
argument_list|,
operator|(
name|CHAR
operator|*
operator|)
literal|"<timeout>"
argument_list|)
expr_stmt|;
if|if
condition|(
name|flow
operator|==
literal|1
condition|)
name|ttoc
argument_list|(
name|XON
argument_list|)
expr_stmt|;
comment|/* In case of Xoff blockage. */
return|return
operator|(
literal|'T'
operator|)
return|;
block|}
name|rpktl
operator|=
name|j
expr_stmt|;
name|tlci
operator|+=
name|j
expr_stmt|;
comment|/* All OK, Count the characters. */
name|flci
operator|+=
name|j
expr_stmt|;
ifndef|#
directive|ifndef
name|PARSENSE
comment|/* THEN eliminate this loop... */
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|recpkt
index|[
name|i
index|]
operator|!=
name|stchr
operator|)
operator|&&
operator|(
name|i
operator|<
name|j
operator|)
condition|;
name|i
operator|++
control|)
name|sohp
operator|++
expr_stmt|;
comment|/* Find mark */
if|if
condition|(
name|i
operator|++
operator|>=
name|j
condition|)
block|{
comment|/* Didn't find it. */
name|logpkt
argument_list|(
literal|'r'
argument_list|,
operator|-
literal|1
argument_list|,
literal|"<timeout>"
argument_list|)
expr_stmt|;
name|freerbuf
argument_list|(
name|k
argument_list|)
expr_stmt|;
return|return
operator|(
literal|'T'
operator|)
return|;
block|}
else|#
directive|else
name|i
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
comment|/* PARSENSE */
name|rpackets
operator|++
expr_stmt|;
name|lp
operator|=
name|i
expr_stmt|;
comment|/* Remember LEN position. */
if|if
condition|(
operator|(
name|j
operator|=
name|xunchar
argument_list|(
name|recpkt
index|[
name|i
operator|++
index|]
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|j
operator|=
name|lp
operator|+
literal|5
operator|)
operator|>
name|MAXRP
condition|)
return|return
operator|(
literal|'Q'
operator|)
return|;
comment|/* Long packet */
name|x
operator|=
name|recpkt
index|[
name|j
index|]
expr_stmt|;
comment|/* Header checksum. */
name|recpkt
index|[
name|j
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* Calculate& compare. */
if|if
condition|(
name|xunchar
argument_list|(
name|x
argument_list|)
operator|!=
name|chk1
argument_list|(
name|recpkt
operator|+
name|lp
argument_list|)
condition|)
block|{
name|freerbuf
argument_list|(
name|k
argument_list|)
expr_stmt|;
name|logpkt
argument_list|(
literal|'r'
argument_list|,
operator|-
literal|1
argument_list|,
operator|(
name|CHAR
operator|*
operator|)
literal|"<crunched:hdr>"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|'Q'
operator|)
return|;
block|}
name|recpkt
index|[
name|j
index|]
operator|=
name|x
expr_stmt|;
comment|/* Checksum ok, put it back. */
name|rln
operator|=
name|xunchar
argument_list|(
name|recpkt
index|[
name|j
operator|-
literal|2
index|]
argument_list|)
operator|*
literal|95
operator|+
name|xunchar
argument_list|(
name|recpkt
index|[
name|j
operator|-
literal|1
index|]
argument_list|)
operator|-
name|bctl
expr_stmt|;
name|j
operator|=
literal|3
expr_stmt|;
comment|/* Data offset. */
block|}
elseif|else
if|if
condition|(
name|j
operator|<
literal|3
condition|)
block|{
name|debug
argument_list|(
name|F101
argument_list|,
literal|"rpack packet length less than 3"
argument_list|,
literal|""
argument_list|,
name|j
argument_list|)
expr_stmt|;
name|freerbuf
argument_list|(
name|k
argument_list|)
expr_stmt|;
name|logpkt
argument_list|(
literal|'r'
argument_list|,
operator|-
literal|1
argument_list|,
operator|(
name|CHAR
operator|*
operator|)
literal|"<crunched:len>"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|'Q'
operator|)
return|;
block|}
else|else
block|{
name|rln
operator|=
name|j
operator|-
name|bctl
operator|-
literal|2
expr_stmt|;
comment|/* Regular packet */
name|j
operator|=
literal|0
expr_stmt|;
comment|/* No extended header */
block|}
name|rsn
operator|=
name|xunchar
argument_list|(
name|recpkt
index|[
name|i
operator|++
index|]
argument_list|)
expr_stmt|;
comment|/* Sequence number */
name|logpkt
argument_list|(
literal|'r'
argument_list|,
name|rsn
argument_list|,
name|sohp
argument_list|)
expr_stmt|;
if|if
condition|(
name|rsn
operator|<
literal|0
operator|||
name|rsn
operator|>
literal|63
condition|)
block|{
name|debug
argument_list|(
name|F101
argument_list|,
literal|"rpack bad sequence number"
argument_list|,
literal|""
argument_list|,
name|rsn
argument_list|)
expr_stmt|;
name|freerbuf
argument_list|(
name|k
argument_list|)
expr_stmt|;
name|logpkt
argument_list|(
literal|'r'
argument_list|,
name|rsn
argument_list|,
operator|(
name|CHAR
operator|*
operator|)
literal|"<crunched:seq>"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|'Q'
operator|)
return|;
block|}
comment|/*   If this packet has the same type as the packet just sent, assume it is   an echo and ignore it.  Don't even bother with the block check calculation:   even if the packet is corrupted, we don't want to NAK an echoed packet.   (And we certainly don't want to NAK an ACK or NAK!) */
name|type
operator|=
name|recpkt
index|[
name|i
operator|++
index|]
expr_stmt|;
comment|/* Get packet's TYPE field */
if|if
condition|(
name|type
operator|==
name|sndtyp
operator|||
operator|(
name|nakstate
operator|&&
operator|(
name|type
operator|==
literal|'N'
comment|/* || type == 'Y' */
operator|)
operator|)
condition|)
block|{
name|debug
argument_list|(
name|F000
argument_list|,
literal|"rpack echo"
argument_list|,
literal|""
argument_list|,
name|type
argument_list|)
expr_stmt|;
comment|/* If it's an echo */
name|freerbuf
argument_list|(
name|k
argument_list|)
expr_stmt|;
comment|/* Free this buffer */
name|logpkt
argument_list|(
literal|'#'
argument_list|,
name|rsn
argument_list|,
operator|(
name|CHAR
operator|*
operator|)
literal|"<echo:ignored>"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|'e'
operator|)
return|;
comment|/* return special (lowercase) code */
block|}
comment|/*   Separate the data from the block check, accounting for the case where       a packet was retransmitted after the block check switched. */
if|if
condition|(
name|type
operator|==
literal|'I'
operator|||
name|type
operator|==
literal|'S'
condition|)
block|{
comment|/* I& S packets always have type 1 */
name|chklen
operator|=
literal|1
expr_stmt|;
name|rln
operator|=
name|rln
operator|+
name|bctl
operator|-
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type
operator|==
literal|'N'
condition|)
block|{
comment|/* A NAK packet never has data */
name|chklen
operator|=
name|xunchar
argument_list|(
name|recpkt
index|[
name|lp
index|]
argument_list|)
operator|-
literal|2
expr_stmt|;
name|rln
operator|=
name|rln
operator|+
name|bctl
operator|-
name|chklen
expr_stmt|;
block|}
else|else
name|chklen
operator|=
name|bctl
expr_stmt|;
name|debug
argument_list|(
name|F101
argument_list|,
literal|"rpack bctl"
argument_list|,
literal|""
argument_list|,
name|bctl
argument_list|)
expr_stmt|;
name|debug
argument_list|(
name|F101
argument_list|,
literal|"rpack chklen"
argument_list|,
literal|""
argument_list|,
name|chklen
argument_list|)
expr_stmt|;
name|i
operator|+=
name|j
expr_stmt|;
comment|/* Buffer index of DATA field */
name|rdatap
operator|=
name|recpkt
operator|+
name|i
expr_stmt|;
comment|/* Pointer to DATA field */
if|if
condition|(
operator|(
name|j
operator|=
name|rln
operator|+
name|i
operator|)
operator|>
name|r_pkt
index|[
name|k
index|]
operator|.
name|bf_len
condition|)
block|{
comment|/* Make sure it fits */
name|debug
argument_list|(
name|F101
argument_list|,
literal|"packet sticks out too far"
argument_list|,
literal|""
argument_list|,
name|j
argument_list|)
expr_stmt|;
name|freerbuf
argument_list|(
name|k
argument_list|)
expr_stmt|;
name|logpkt
argument_list|(
literal|'r'
argument_list|,
name|rsn
argument_list|,
operator|(
name|CHAR
operator|*
operator|)
literal|"<overflow>"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|'Q'
operator|)
return|;
block|}
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|chklen
condition|;
name|x
operator|++
control|)
comment|/* Copy the block check */
name|pbc
index|[
name|x
index|]
operator|=
name|recpkt
index|[
name|j
operator|+
name|x
index|]
expr_stmt|;
name|pbc
index|[
name|x
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* Null-terminate block check string */
name|recpkt
index|[
name|j
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/*  and the packet DATA field. */
if|if
condition|(
name|chklen
operator|==
literal|2
operator|&&
name|bctu
operator|==
literal|4
condition|)
block|{
comment|/* Adjust for Blank-Free-2 */
name|chklen
operator|=
literal|4
expr_stmt|;
comment|/* (chklen is now a misnomer...) */
name|debug
argument_list|(
name|F100
argument_list|,
literal|"rpack block check B"
argument_list|,
literal|""
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|chklen
condition|)
block|{
comment|/* Check the block check */
case|case
literal|1
case|:
comment|/* Type 1, 6-bit checksum */
if|if
condition|(
name|xunchar
argument_list|(
operator|*
name|pbc
argument_list|)
operator|!=
name|chk1
argument_list|(
name|recpkt
operator|+
name|lp
argument_list|)
condition|)
block|{
name|debug
argument_list|(
name|F110
argument_list|,
literal|"checked chars"
argument_list|,
name|recpkt
operator|+
name|lp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|debug
argument_list|(
name|F101
argument_list|,
literal|"block check"
argument_list|,
literal|""
argument_list|,
operator|(
name|int
operator|)
name|xunchar
argument_list|(
operator|*
name|pbc
argument_list|)
argument_list|)
expr_stmt|;
name|debug
argument_list|(
name|F101
argument_list|,
literal|"should be"
argument_list|,
literal|""
argument_list|,
name|chk1
argument_list|(
name|recpkt
operator|+
name|lp
argument_list|)
argument_list|)
expr_stmt|;
name|freerbuf
argument_list|(
name|k
argument_list|)
expr_stmt|;
name|logpkt
argument_list|(
literal|'r'
argument_list|,
operator|-
literal|1
argument_list|,
operator|(
name|CHAR
operator|*
operator|)
literal|"<crunched:chk1>"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|'Q'
operator|)
return|;
block|}
break|break;
case|case
literal|2
case|:
comment|/* Type 2, 12-bit checksum */
name|x
operator|=
name|xunchar
argument_list|(
operator|*
name|pbc
argument_list|)
operator|<<
literal|6
operator||
name|xunchar
argument_list|(
name|pbc
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|!=
name|chk2
argument_list|(
name|recpkt
operator|+
name|lp
argument_list|)
condition|)
block|{
comment|/* No match */
if|if
condition|(
name|type
operator|==
literal|'E'
condition|)
block|{
comment|/* Allow E packets to have type 1 */
name|recpkt
index|[
name|j
operator|++
index|]
operator|=
name|pbc
index|[
literal|0
index|]
expr_stmt|;
name|recpkt
index|[
name|j
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|xunchar
argument_list|(
name|pbc
index|[
literal|1
index|]
argument_list|)
operator|==
name|chk1
argument_list|(
name|recpkt
operator|+
name|lp
argument_list|)
condition|)
break|break;
else|else
name|recpkt
index|[
operator|--
name|j
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
name|debug
argument_list|(
name|F110
argument_list|,
literal|"checked chars"
argument_list|,
name|recpkt
operator|+
name|lp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|debug
argument_list|(
name|F101
argument_list|,
literal|"block check"
argument_list|,
literal|""
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|debug
argument_list|(
name|F101
argument_list|,
literal|"should be"
argument_list|,
literal|""
argument_list|,
operator|(
name|int
operator|)
name|chk2
argument_list|(
name|recpkt
operator|+
name|lp
argument_list|)
argument_list|)
expr_stmt|;
name|freerbuf
argument_list|(
name|k
argument_list|)
expr_stmt|;
name|logpkt
argument_list|(
literal|'r'
argument_list|,
operator|-
literal|1
argument_list|,
operator|(
name|CHAR
operator|*
operator|)
literal|"<crunched:chk2>"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|'Q'
operator|)
return|;
block|}
break|break;
case|case
literal|3
case|:
comment|/* Type 3, 16-bit CRC */
name|crc
operator|=
operator|(
name|xunchar
argument_list|(
name|pbc
index|[
literal|0
index|]
argument_list|)
operator|<<
literal|12
operator|)
operator||
operator|(
name|xunchar
argument_list|(
name|pbc
index|[
literal|1
index|]
argument_list|)
operator|<<
literal|6
operator|)
operator||
operator|(
name|xunchar
argument_list|(
name|pbc
index|[
literal|2
index|]
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|crc
operator|!=
name|chk3
argument_list|(
name|recpkt
operator|+
name|lp
argument_list|)
condition|)
block|{
if|if
condition|(
name|type
operator|==
literal|'E'
condition|)
block|{
comment|/* Allow E packets to have type 1 */
name|recpkt
index|[
name|j
operator|++
index|]
operator|=
name|pbc
index|[
literal|0
index|]
expr_stmt|;
name|recpkt
index|[
name|j
operator|++
index|]
operator|=
name|pbc
index|[
literal|1
index|]
expr_stmt|;
name|recpkt
index|[
name|j
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|xunchar
argument_list|(
name|pbc
index|[
literal|2
index|]
argument_list|)
operator|==
name|chk1
argument_list|(
name|recpkt
operator|+
name|lp
argument_list|)
condition|)
break|break;
else|else
block|{
name|j
operator|-=
literal|2
expr_stmt|;
name|recpkt
index|[
name|j
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
block|}
name|debug
argument_list|(
name|F110
argument_list|,
literal|"checked chars"
argument_list|,
name|recpkt
operator|+
name|lp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|debug
argument_list|(
name|F101
argument_list|,
literal|"block check"
argument_list|,
literal|""
argument_list|,
name|xunchar
argument_list|(
operator|*
name|pbc
argument_list|)
argument_list|)
expr_stmt|;
name|debug
argument_list|(
name|F101
argument_list|,
literal|"should be"
argument_list|,
literal|""
argument_list|,
operator|(
name|int
operator|)
name|chk3
argument_list|(
name|recpkt
operator|+
name|lp
argument_list|)
argument_list|)
expr_stmt|;
name|freerbuf
argument_list|(
name|k
argument_list|)
expr_stmt|;
name|logpkt
argument_list|(
literal|'r'
argument_list|,
operator|-
literal|1
argument_list|,
operator|(
name|CHAR
operator|*
operator|)
literal|"<crunched:chk3>"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|'Q'
operator|)
return|;
block|}
break|break;
case|case
literal|4
case|:
comment|/* Type 4 = Type 2, no blanks. */
name|x
operator|=
call|(
name|unsigned
call|)
argument_list|(
operator|(
name|xunchar
argument_list|(
operator|*
name|pbc
argument_list|)
operator|-
literal|1
operator|)
operator|<<
literal|6
argument_list|)
operator||
call|(
name|unsigned
call|)
argument_list|(
name|xunchar
argument_list|(
name|pbc
index|[
literal|1
index|]
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|!=
name|chk2
argument_list|(
name|recpkt
operator|+
name|lp
argument_list|)
condition|)
block|{
if|if
condition|(
name|type
operator|==
literal|'E'
condition|)
block|{
comment|/* Allow E packets to have type 1 */
name|recpkt
index|[
name|j
operator|++
index|]
operator|=
name|pbc
index|[
literal|0
index|]
expr_stmt|;
name|recpkt
index|[
name|j
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|xunchar
argument_list|(
name|pbc
index|[
literal|1
index|]
argument_list|)
operator|==
name|chk1
argument_list|(
name|recpkt
operator|+
name|lp
argument_list|)
condition|)
break|break;
else|else
name|recpkt
index|[
operator|--
name|j
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
name|debug
argument_list|(
name|F101
argument_list|,
literal|"bad type B block check"
argument_list|,
literal|""
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|freerbuf
argument_list|(
name|k
argument_list|)
expr_stmt|;
name|logpkt
argument_list|(
literal|'r'
argument_list|,
operator|-
literal|1
argument_list|,
operator|(
name|CHAR
operator|*
operator|)
literal|"<crunched:chkb>"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|'Q'
operator|)
return|;
block|}
break|break;
default|default:
comment|/* Shouldn't happen... */
name|freerbuf
argument_list|(
name|k
argument_list|)
expr_stmt|;
name|logpkt
argument_list|(
literal|'r'
argument_list|,
operator|-
literal|1
argument_list|,
operator|(
name|CHAR
operator|*
operator|)
literal|"<crunched:chkx>"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|'Q'
operator|)
return|;
block|}
name|debug
argument_list|(
name|F101
argument_list|,
literal|"rpack block check OK"
argument_list|,
literal|""
argument_list|,
name|rsn
argument_list|)
expr_stmt|;
comment|/* Now we can believe the sequence number, and other fields. */
comment|/* Here we violate strict principles of layering, etc, and look at the  */
comment|/* packet sequence number.  If there's already a packet with the same   */
comment|/* number in the window, we remove this one so that the window will not */
comment|/* fill up. */
if|if
condition|(
operator|(
name|x
operator|=
name|rseqtbl
index|[
name|rsn
index|]
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
comment|/* Already a packet with this number */
name|retrans
operator|++
expr_stmt|;
comment|/* Count it for statistics */
name|debug
argument_list|(
name|F101
argument_list|,
literal|"rpack got dup"
argument_list|,
literal|""
argument_list|,
name|rsn
argument_list|)
expr_stmt|;
name|logpkt
argument_list|(
literal|'r'
argument_list|,
name|rsn
argument_list|,
operator|(
name|CHAR
operator|*
operator|)
literal|"<duplicate>"
argument_list|)
expr_stmt|;
name|freerbuf
argument_list|(
name|x
argument_list|)
expr_stmt|;
comment|/* Free old buffer, keep new packet. */
name|r_pkt
index|[
name|k
index|]
operator|.
name|pk_rtr
operator|++
expr_stmt|;
comment|/* Count this as a retransmission. */
block|}
comment|/* New packet, not seen before, enter it into the receive window. */
name|rseqtbl
index|[
name|rsn
index|]
operator|=
name|k
expr_stmt|;
comment|/* Make back pointer */
name|r_pkt
index|[
name|k
index|]
operator|.
name|pk_seq
operator|=
name|rsn
expr_stmt|;
comment|/* Record in packet info structure */
name|r_pkt
index|[
name|k
index|]
operator|.
name|pk_typ
operator|=
name|type
expr_stmt|;
comment|/* Sequence, type,... */
name|r_pkt
index|[
name|k
index|]
operator|.
name|pk_adr
operator|=
name|rdatap
expr_stmt|;
comment|/* pointer to data buffer */
name|screen
argument_list|(
name|SCR_PT
argument_list|,
operator|(
name|char
operator|)
name|type
argument_list|,
operator|(
name|long
operator|)
name|rsn
argument_list|,
operator|(
name|char
operator|*
operator|)
name|sohp
argument_list|)
expr_stmt|;
comment|/* Update screen */
return|return
operator|(
name|type
operator|)
return|;
comment|/* Return packet type */
block|}
end_function

begin_comment
comment|/*  L O G P K T  --  Log packet number n, pointed to by s.  */
end_comment

begin_comment
comment|/* c = 's' (send) or 'r' (receive) */
end_comment

begin_function
name|VOID
ifdef|#
directive|ifdef
name|CK_ANSIC
name|logpkt
parameter_list|(
name|char
name|c
parameter_list|,
name|int
name|n
parameter_list|,
name|CHAR
modifier|*
name|s
parameter_list|)
else|#
directive|else
function|logpkt
parameter_list|(
name|c
parameter_list|,
name|n
parameter_list|,
name|s
parameter_list|)
name|char
name|c
decl_stmt|;
name|int
name|n
decl_stmt|;
name|CHAR
modifier|*
name|s
decl_stmt|;
endif|#
directive|endif
comment|/* CK_ANSIC */
comment|/* logpkt */
block|{
name|char
name|plog
index|[
literal|20
index|]
decl_stmt|;
if|if
condition|(
name|pktlog
operator|&&
operator|*
name|s
condition|)
block|{
if|if
condition|(
name|n
operator|<
literal|0
condition|)
name|sprintf
argument_list|(
name|plog
argument_list|,
literal|"%c-xx-%02d-"
argument_list|,
name|c
argument_list|,
operator|(
name|gtimer
argument_list|()
operator|%
literal|60
operator|)
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|plog
argument_list|,
literal|"%c-%02d-%02d-"
argument_list|,
name|c
argument_list|,
name|n
argument_list|,
operator|(
name|gtimer
argument_list|()
operator|%
literal|60
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|zsout
argument_list|(
name|ZPFILE
argument_list|,
name|plog
argument_list|)
operator|<
literal|0
condition|)
name|pktlog
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|zsoutl
argument_list|(
name|ZPFILE
argument_list|,
operator|(
name|char
operator|*
operator|)
name|s
argument_list|)
operator|<
literal|0
condition|)
name|pktlog
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|TLOG
end_ifdef

begin_comment
comment|/*  T S T A T S  --  Record statistics in transaction log  */
end_comment

begin_function
name|VOID
name|tstats
parameter_list|()
block|{
name|char
modifier|*
name|tp
decl_stmt|;
name|ztime
argument_list|(
operator|&
name|tp
argument_list|)
expr_stmt|;
comment|/* Get time stamp */
name|tlog
argument_list|(
name|F110
argument_list|,
literal|"End of transaction"
argument_list|,
name|tp
argument_list|,
literal|0L
argument_list|)
expr_stmt|;
comment|/* Record it */
if|if
condition|(
name|filcnt
operator|<
literal|1
condition|)
return|return;
comment|/* If no files, done. */
comment|/* If multiple files, record character totals for all files */
if|if
condition|(
name|filcnt
operator|>
literal|1
condition|)
block|{
name|tlog
argument_list|(
name|F101
argument_list|,
literal|" files"
argument_list|,
literal|""
argument_list|,
name|filcnt
argument_list|)
expr_stmt|;
name|tlog
argument_list|(
name|F101
argument_list|,
literal|" total file characters   "
argument_list|,
literal|""
argument_list|,
name|tfc
argument_list|)
expr_stmt|;
name|tlog
argument_list|(
name|F101
argument_list|,
literal|" communication line in   "
argument_list|,
literal|""
argument_list|,
name|tlci
argument_list|)
expr_stmt|;
name|tlog
argument_list|(
name|F101
argument_list|,
literal|" communication line out  "
argument_list|,
literal|""
argument_list|,
name|tlco
argument_list|)
expr_stmt|;
block|}
comment|/* Record timing info for one or more files */
name|tlog
argument_list|(
name|F101
argument_list|,
literal|" elapsed time (seconds)  "
argument_list|,
literal|""
argument_list|,
operator|(
name|long
operator|)
name|tsecs
argument_list|)
expr_stmt|;
if|if
condition|(
name|tsecs
operator|>
literal|0
condition|)
block|{
name|long
name|lx
decl_stmt|;
name|lx
operator|=
operator|(
name|tfc
operator|*
literal|10L
operator|)
operator|/
operator|(
name|long
operator|)
name|tsecs
expr_stmt|;
name|tlog
argument_list|(
name|F101
argument_list|,
literal|" effective data rate     "
argument_list|,
literal|""
argument_list|,
name|lx
operator|/
literal|10L
argument_list|)
expr_stmt|;
if|if
condition|(
name|speed
operator|<=
literal|0L
condition|)
name|speed
operator|=
name|ttgspd
argument_list|()
expr_stmt|;
if|if
condition|(
name|speed
operator|>
literal|0L
operator|&&
name|speed
operator|!=
literal|8880L
operator|&&
name|network
operator|==
literal|0
condition|)
block|{
name|lx
operator|=
operator|(
name|lx
operator|*
literal|100L
operator|)
operator|/
name|speed
expr_stmt|;
name|tlog
argument_list|(
name|F101
argument_list|,
literal|" efficiency (percent)    "
argument_list|,
literal|""
argument_list|,
name|lx
argument_list|)
expr_stmt|;
block|}
block|}
name|tlog
argument_list|(
name|F100
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|,
literal|0L
argument_list|)
expr_stmt|;
comment|/* Leave a blank line */
block|}
end_function

begin_comment
comment|/*  F S T A T S  --  Record file statistics in transaction log  */
end_comment

begin_function
name|VOID
name|fstats
parameter_list|()
block|{
name|tfc
operator|+=
name|ffc
expr_stmt|;
name|tlog
argument_list|(
name|F100
argument_list|,
literal|" end of file"
argument_list|,
literal|""
argument_list|,
literal|0L
argument_list|)
expr_stmt|;
name|tlog
argument_list|(
name|F101
argument_list|,
literal|"  file characters        "
argument_list|,
literal|""
argument_list|,
name|ffc
argument_list|)
expr_stmt|;
name|tlog
argument_list|(
name|F101
argument_list|,
literal|"  communication line in  "
argument_list|,
literal|""
argument_list|,
name|flci
argument_list|)
expr_stmt|;
name|tlog
argument_list|(
name|F101
argument_list|,
literal|"  communication line out "
argument_list|,
literal|""
argument_list|,
name|flco
argument_list|)
expr_stmt|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* NOTLOG */
end_comment

begin_function
name|VOID
name|tstats
parameter_list|()
block|{}
end_function

begin_function
name|VOID
name|fstats
parameter_list|()
block|{
name|tfc
operator|+=
name|ffc
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* TLOG */
end_comment

end_unit

