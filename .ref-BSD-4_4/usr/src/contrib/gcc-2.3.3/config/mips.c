begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Subroutines for insn-output.c for MIPS    Contributed by A. Lichnewsky, lich@inria.inria.fr.    Changes by     Michael Meissner, meissner@osf.org.    Copyright (C) 1989, 1990, 1991 Free Software Foundation, Inc.  This file is part of GNU CC.  GNU CC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU CC; see the file COPYING.  If not, write to the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"regs.h"
end_include

begin_include
include|#
directive|include
file|"hard-reg-set.h"
end_include

begin_include
include|#
directive|include
file|"real.h"
end_include

begin_include
include|#
directive|include
file|"insn-config.h"
end_include

begin_include
include|#
directive|include
file|"conditions.h"
end_include

begin_include
include|#
directive|include
file|"insn-flags.h"
end_include

begin_include
include|#
directive|include
file|"insn-attr.h"
end_include

begin_include
include|#
directive|include
file|"insn-codes.h"
end_include

begin_include
include|#
directive|include
file|"recog.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_undef
undef|#
directive|undef
name|MAX
end_undef

begin_comment
comment|/* sys/param.h may also define these */
end_comment

begin_undef
undef|#
directive|undef
name|MIN
end_undef

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"expr.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|R_OK
end_ifndef

begin_define
define|#
directive|define
name|R_OK
value|4
end_define

begin_define
define|#
directive|define
name|W_OK
value|2
end_define

begin_define
define|#
directive|define
name|X_OK
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|USG
argument_list|)
operator|||
name|defined
argument_list|(
name|NO_STAB_H
argument_list|)
end_if

begin_include
include|#
directive|include
file|"gstab.h"
end_include

begin_comment
comment|/* If doing DBX on sysV, use our own stab.h.  */
end_comment

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<stab.h>
end_include

begin_comment
comment|/* On BSD, use the system's stab.h.  */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not USG */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__GNU_STAB__
end_ifdef

begin_define
define|#
directive|define
name|STAB_CODE_TYPE
value|enum __stab_debug_code
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|STAB_CODE_TYPE
value|int
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|extern
name|void
name|abort
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|int
name|atoi
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|char
modifier|*
name|getenv
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|char
modifier|*
name|mktemp
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|rtx
name|adj_offsettable_operand
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|rtx
name|copy_to_reg
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|error
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|fatal
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|tree
name|lookup_name
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|pfatal_with_name
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|warning
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|extern
name|tree
name|current_function_decl
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|FILE
modifier|*
name|asm_out_file
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Enumeration for all of the relational tests, so that we can build    arrays indexed by the test type, and not worry about the order    of EQ, NE, etc. */
end_comment

begin_enum
enum|enum
name|internal_test
block|{
name|ITEST_EQ
block|,
name|ITEST_NE
block|,
name|ITEST_GT
block|,
name|ITEST_GE
block|,
name|ITEST_LT
block|,
name|ITEST_LE
block|,
name|ITEST_GTU
block|,
name|ITEST_GEU
block|,
name|ITEST_LTU
block|,
name|ITEST_LEU
block|,
name|ITEST_MAX
block|}
enum|;
end_enum

begin_comment
comment|/* Global variables for machine-dependent things.  */
end_comment

begin_comment
comment|/* Threshold for data being put into the small data/bss area, instead    of the normal data area (references to the small data/bss area take    1 instruction, and use the global pointer, references to the normal    data area takes 2 instructions).  */
end_comment

begin_decl_stmt
name|int
name|mips_section_threshold
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Count the number of .file directives, so that .loc is up to date.  */
end_comment

begin_decl_stmt
name|int
name|num_source_filenames
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Count the number of sdb related labels are generated (to find block    start and end boundaries).  */
end_comment

begin_decl_stmt
name|int
name|sdb_label_count
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Non-zero if inside of a function, because the stupid MIPS asm can't    handle .files inside of functions.  */
end_comment

begin_decl_stmt
name|int
name|inside_function
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Files to separate the text and the data output, so that all of the data    can be emitted before the text, which will mean that the assembler will    generate smaller code, based on the global pointer.  */
end_comment

begin_decl_stmt
name|FILE
modifier|*
name|asm_out_data_file
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE
modifier|*
name|asm_out_text_file
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Linked list of all externals that are to be emitted when optimizing    for the global pointer if they haven't been declared by the end of    the program with an appropriate .comm or initialization.  */
end_comment

begin_struct
struct|struct
name|extern_list
block|{
name|struct
name|extern_list
modifier|*
name|next
decl_stmt|;
comment|/* next external */
name|char
modifier|*
name|name
decl_stmt|;
comment|/* name of the external */
name|int
name|size
decl_stmt|;
comment|/* size in bytes */
block|}
modifier|*
name|extern_head
init|=
literal|0
struct|;
end_struct

begin_comment
comment|/* Name of the file containing the current function.  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|current_function_file
init|=
literal|""
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Warning given that Mips ECOFF can't support changing files    within a function.  */
end_comment

begin_decl_stmt
name|int
name|file_in_function_warning
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Whether to suppress issuing .loc's because the user attempted    to change the filename within a function.  */
end_comment

begin_decl_stmt
name|int
name|ignore_line_number
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of nested .set noreorder, noat, nomacro, and volatile requests.  */
end_comment

begin_decl_stmt
name|int
name|set_noreorder
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|set_noat
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|set_nomacro
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|set_volatile
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The next branch instruction is a branch likely, not branch normal.  */
end_comment

begin_decl_stmt
name|int
name|mips_branch_likely
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Count of delay slots and how many are filled.  */
end_comment

begin_decl_stmt
name|int
name|dslots_load_total
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|dslots_load_filled
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|dslots_jump_total
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|dslots_jump_filled
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* # of nops needed by previous insn */
end_comment

begin_decl_stmt
name|int
name|dslots_number_nops
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of 1/2/3 word references to data items (ie, not jal's).  */
end_comment

begin_decl_stmt
name|int
name|num_refs
index|[
literal|3
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* registers to check for load delay */
end_comment

begin_decl_stmt
name|rtx
name|mips_load_reg
decl_stmt|,
name|mips_load_reg2
decl_stmt|,
name|mips_load_reg3
decl_stmt|,
name|mips_load_reg4
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Cached operands, and operator to compare for use in set/branch on    condition codes.  */
end_comment

begin_decl_stmt
name|rtx
name|branch_cmp
index|[
literal|2
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* what type of branch to use */
end_comment

begin_decl_stmt
name|enum
name|cmp_type
name|branch_type
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of previously seen half-pic pointers and references.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|prev_half_pic_ptrs
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|prev_half_pic_refs
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* which cpu are we scheduling for */
end_comment

begin_decl_stmt
name|enum
name|processor_type
name|mips_cpu
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* which instruction set architecture to use.  */
end_comment

begin_decl_stmt
name|int
name|mips_isa
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Strings to hold which cpu and instruction set architecture to use.  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|mips_cpu_string
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* for -mcpu=<xxx> */
end_comment

begin_decl_stmt
name|char
modifier|*
name|mips_isa_string
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* for -mips{1,2,3} */
end_comment

begin_comment
comment|/* Array to RTX class classification.  At present, we care about    whether the operator is an add-type operator, or a divide/modulus,    and if divide/modulus, whether it is unsigned.  This is for the    peephole code.  */
end_comment

begin_decl_stmt
name|char
name|mips_rtx_classify
index|[
name|NUM_RTX_CODE
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Array giving truth value on whether or not a given hard register    can support a given mode.  */
end_comment

begin_decl_stmt
name|char
name|mips_hard_regno_mode_ok
index|[
operator|(
name|int
operator|)
name|MAX_MACHINE_MODE
index|]
index|[
name|FIRST_PSEUDO_REGISTER
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Current frame information calculated by compute_frame_size.  */
end_comment

begin_decl_stmt
name|struct
name|mips_frame_info
name|current_frame_info
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Zero structure to initialize current_frame_info.  */
end_comment

begin_decl_stmt
name|struct
name|mips_frame_info
name|zero_frame_info
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Temporary filename used to buffer .text until end of program    for -mgpopt.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|temp_filename
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* List of all MIPS punctuation characters used by print_operand.  */
end_comment

begin_decl_stmt
name|char
name|mips_print_operand_punct
index|[
literal|256
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Map GCC register number to debugger register number.  */
end_comment

begin_decl_stmt
name|int
name|mips_dbx_regno
index|[
name|FIRST_PSEUDO_REGISTER
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Buffer to use to enclose a load/store operation with %{ %} to    turn on .set volatile.  */
end_comment

begin_decl_stmt
specifier|static
name|char
name|volatile_buffer
index|[
literal|60
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Hardware names for the registers.  If -mrnames is used, this    will be overwritten with mips_sw_reg_names.  */
end_comment

begin_decl_stmt
name|char
name|mips_reg_names
index|[]
index|[
literal|8
index|]
init|=
block|{
literal|"$0"
block|,
literal|"$1"
block|,
literal|"$2"
block|,
literal|"$3"
block|,
literal|"$4"
block|,
literal|"$5"
block|,
literal|"$6"
block|,
literal|"$7"
block|,
literal|"$8"
block|,
literal|"$9"
block|,
literal|"$10"
block|,
literal|"$11"
block|,
literal|"$12"
block|,
literal|"$13"
block|,
literal|"$14"
block|,
literal|"$15"
block|,
literal|"$16"
block|,
literal|"$17"
block|,
literal|"$18"
block|,
literal|"$19"
block|,
literal|"$20"
block|,
literal|"$21"
block|,
literal|"$22"
block|,
literal|"$23"
block|,
literal|"$24"
block|,
literal|"$25"
block|,
literal|"$26"
block|,
literal|"$27"
block|,
literal|"$28"
block|,
literal|"$sp"
block|,
literal|"$fp"
block|,
literal|"$31"
block|,
literal|"$f0"
block|,
literal|"$f1"
block|,
literal|"$f2"
block|,
literal|"$f3"
block|,
literal|"$f4"
block|,
literal|"$f5"
block|,
literal|"$f6"
block|,
literal|"$f7"
block|,
literal|"$f8"
block|,
literal|"$f9"
block|,
literal|"$f10"
block|,
literal|"$f11"
block|,
literal|"$f12"
block|,
literal|"$f13"
block|,
literal|"$f14"
block|,
literal|"$f15"
block|,
literal|"$f16"
block|,
literal|"$f17"
block|,
literal|"$f18"
block|,
literal|"$f19"
block|,
literal|"$f20"
block|,
literal|"$f21"
block|,
literal|"$f22"
block|,
literal|"$f23"
block|,
literal|"$f24"
block|,
literal|"$f25"
block|,
literal|"$f26"
block|,
literal|"$f27"
block|,
literal|"$f28"
block|,
literal|"$f29"
block|,
literal|"$f30"
block|,
literal|"$f31"
block|,
literal|"hi"
block|,
literal|"lo"
block|,
literal|"$fcr31"
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Mips software names for the registers, used to overwrite the    mips_reg_names array.  */
end_comment

begin_decl_stmt
name|char
name|mips_sw_reg_names
index|[]
index|[
literal|8
index|]
init|=
block|{
literal|"$0"
block|,
literal|"at"
block|,
literal|"v0"
block|,
literal|"v1"
block|,
literal|"a0"
block|,
literal|"a1"
block|,
literal|"a2"
block|,
literal|"a3"
block|,
literal|"t0"
block|,
literal|"t1"
block|,
literal|"t2"
block|,
literal|"t3"
block|,
literal|"t4"
block|,
literal|"t5"
block|,
literal|"t6"
block|,
literal|"t7"
block|,
literal|"s0"
block|,
literal|"s1"
block|,
literal|"s2"
block|,
literal|"s3"
block|,
literal|"s4"
block|,
literal|"s5"
block|,
literal|"s6"
block|,
literal|"s7"
block|,
literal|"t8"
block|,
literal|"t9"
block|,
literal|"k0"
block|,
literal|"k1"
block|,
literal|"gp"
block|,
literal|"sp"
block|,
literal|"$fp"
block|,
literal|"ra"
block|,
literal|"$f0"
block|,
literal|"$f1"
block|,
literal|"$f2"
block|,
literal|"$f3"
block|,
literal|"$f4"
block|,
literal|"$f5"
block|,
literal|"$f6"
block|,
literal|"$f7"
block|,
literal|"$f8"
block|,
literal|"$f9"
block|,
literal|"$f10"
block|,
literal|"$f11"
block|,
literal|"$f12"
block|,
literal|"$f13"
block|,
literal|"$f14"
block|,
literal|"$f15"
block|,
literal|"$f16"
block|,
literal|"$f17"
block|,
literal|"$f18"
block|,
literal|"$f19"
block|,
literal|"$f20"
block|,
literal|"$f21"
block|,
literal|"$f22"
block|,
literal|"$f23"
block|,
literal|"$f24"
block|,
literal|"$f25"
block|,
literal|"$f26"
block|,
literal|"$f27"
block|,
literal|"$f28"
block|,
literal|"$f29"
block|,
literal|"$f30"
block|,
literal|"$f31"
block|,
literal|"hi"
block|,
literal|"lo"
block|,
literal|"$fcr31"
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Map hard register number to register class */
end_comment

begin_decl_stmt
name|enum
name|reg_class
name|mips_regno_to_class
index|[]
init|=
block|{
name|GR_REGS
block|,
name|GR_REGS
block|,
name|GR_REGS
block|,
name|GR_REGS
block|,
name|GR_REGS
block|,
name|GR_REGS
block|,
name|GR_REGS
block|,
name|GR_REGS
block|,
name|GR_REGS
block|,
name|GR_REGS
block|,
name|GR_REGS
block|,
name|GR_REGS
block|,
name|GR_REGS
block|,
name|GR_REGS
block|,
name|GR_REGS
block|,
name|GR_REGS
block|,
name|GR_REGS
block|,
name|GR_REGS
block|,
name|GR_REGS
block|,
name|GR_REGS
block|,
name|GR_REGS
block|,
name|GR_REGS
block|,
name|GR_REGS
block|,
name|GR_REGS
block|,
name|GR_REGS
block|,
name|GR_REGS
block|,
name|GR_REGS
block|,
name|GR_REGS
block|,
name|GR_REGS
block|,
name|GR_REGS
block|,
name|GR_REGS
block|,
name|GR_REGS
block|,
name|FP_REGS
block|,
name|FP_REGS
block|,
name|FP_REGS
block|,
name|FP_REGS
block|,
name|FP_REGS
block|,
name|FP_REGS
block|,
name|FP_REGS
block|,
name|FP_REGS
block|,
name|FP_REGS
block|,
name|FP_REGS
block|,
name|FP_REGS
block|,
name|FP_REGS
block|,
name|FP_REGS
block|,
name|FP_REGS
block|,
name|FP_REGS
block|,
name|FP_REGS
block|,
name|FP_REGS
block|,
name|FP_REGS
block|,
name|FP_REGS
block|,
name|FP_REGS
block|,
name|FP_REGS
block|,
name|FP_REGS
block|,
name|FP_REGS
block|,
name|FP_REGS
block|,
name|FP_REGS
block|,
name|FP_REGS
block|,
name|FP_REGS
block|,
name|FP_REGS
block|,
name|FP_REGS
block|,
name|FP_REGS
block|,
name|FP_REGS
block|,
name|FP_REGS
block|,
name|HI_REG
block|,
name|LO_REG
block|,
name|ST_REGS
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Map register constraint character to register class.  */
end_comment

begin_decl_stmt
name|enum
name|reg_class
name|mips_char_to_class
index|[
literal|256
index|]
init|=
block|{
name|NO_REGS
block|,
name|NO_REGS
block|,
name|NO_REGS
block|,
name|NO_REGS
block|,
name|NO_REGS
block|,
name|NO_REGS
block|,
name|NO_REGS
block|,
name|NO_REGS
block|,
name|NO_REGS
block|,
name|NO_REGS
block|,
name|NO_REGS
block|,
name|NO_REGS
block|,
name|NO_REGS
block|,
name|NO_REGS
block|,
name|NO_REGS
block|,
name|NO_REGS
block|,
name|NO_REGS
block|,
name|NO_REGS
block|,
name|NO_REGS
block|,
name|NO_REGS
block|,
name|NO_REGS
block|,
name|NO_REGS
block|,
name|NO_REGS
block|,
name|NO_REGS
block|,
name|NO_REGS
block|,
name|NO_REGS
block|,
name|NO_REGS
block|,
name|NO_REGS
block|,
name|NO_REGS
block|,
name|NO_REGS
block|,
name|NO_REGS
block|,
name|NO_REGS
block|,
name|NO_REGS
block|,
name|NO_REGS
block|,
name|NO_REGS
block|,
name|NO_REGS
block|,
name|NO_REGS
block|,
name|NO_REGS
block|,
name|NO_REGS
block|,
name|NO_REGS
block|,
name|NO_REGS
block|,
name|NO_REGS
block|,
name|NO_REGS
block|,
name|NO_REGS
block|,
name|NO_REGS
block|,
name|NO_REGS
block|,
name|NO_REGS
block|,
name|NO_REGS
block|,
name|NO_REGS
block|,
name|NO_REGS
block|,
name|NO_REGS
block|,
name|NO_REGS
block|,
name|NO_REGS
block|,
name|NO_REGS
block|,
name|NO_REGS
block|,
name|NO_REGS
block|,
name|NO_REGS
block|,
name|NO_REGS
block|,
name|NO_REGS
block|,
name|NO_REGS
block|,
name|NO_REGS
block|,
name|NO_REGS
block|,
name|NO_REGS
block|,
name|NO_REGS
block|,
name|NO_REGS
block|,
name|NO_REGS
block|,
name|NO_REGS
block|,
name|NO_REGS
block|,
name|NO_REGS
block|,
name|NO_REGS
block|,
name|NO_REGS
block|,
name|NO_REGS
block|,
name|NO_REGS
block|,
name|NO_REGS
block|,
name|NO_REGS
block|,
name|NO_REGS
block|,
name|NO_REGS
block|,
name|NO_REGS
block|,
name|NO_REGS
block|,
name|NO_REGS
block|,
name|NO_REGS
block|,
name|NO_REGS
block|,
name|NO_REGS
block|,
name|NO_REGS
block|,
name|NO_REGS
block|,
name|NO_REGS
block|,
name|NO_REGS
block|,
name|NO_REGS
block|,
name|NO_REGS
block|,
name|NO_REGS
block|,
name|NO_REGS
block|,
name|NO_REGS
block|,
name|NO_REGS
block|,
name|NO_REGS
block|,
name|NO_REGS
block|,
name|NO_REGS
block|,
name|NO_REGS
block|,
name|NO_REGS
block|,
name|NO_REGS
block|,
name|NO_REGS
block|,
name|NO_REGS
block|,
name|NO_REGS
block|,
name|NO_REGS
block|,
name|NO_REGS
block|,
name|NO_REGS
block|,
name|NO_REGS
block|,
name|NO_REGS
block|,
name|NO_REGS
block|,
name|NO_REGS
block|,
name|NO_REGS
block|,
name|NO_REGS
block|,
name|NO_REGS
block|,
name|NO_REGS
block|,
name|NO_REGS
block|,
name|NO_REGS
block|,
name|NO_REGS
block|,
name|NO_REGS
block|,
name|NO_REGS
block|,
name|NO_REGS
block|,
name|NO_REGS
block|,
name|NO_REGS
block|,
name|NO_REGS
block|,
name|NO_REGS
block|,
name|NO_REGS
block|,
name|NO_REGS
block|,
name|NO_REGS
block|,
name|NO_REGS
block|,
name|NO_REGS
block|,
name|NO_REGS
block|,
name|NO_REGS
block|,
name|NO_REGS
block|,
name|NO_REGS
block|,
name|NO_REGS
block|,
name|NO_REGS
block|,
name|NO_REGS
block|,
name|NO_REGS
block|,
name|NO_REGS
block|,
name|NO_REGS
block|,
name|NO_REGS
block|,
name|NO_REGS
block|,
name|NO_REGS
block|,
name|NO_REGS
block|,
name|NO_REGS
block|,
name|NO_REGS
block|,
name|NO_REGS
block|,
name|NO_REGS
block|,
name|NO_REGS
block|,
name|NO_REGS
block|,
name|NO_REGS
block|,
name|NO_REGS
block|,
name|NO_REGS
block|,
name|NO_REGS
block|,
name|NO_REGS
block|,
name|NO_REGS
block|,
name|NO_REGS
block|,
name|NO_REGS
block|,
name|NO_REGS
block|,
name|NO_REGS
block|,
name|NO_REGS
block|,
name|NO_REGS
block|,
name|NO_REGS
block|,
name|NO_REGS
block|,
name|NO_REGS
block|,
name|NO_REGS
block|,
name|NO_REGS
block|,
name|NO_REGS
block|,
name|NO_REGS
block|,
name|NO_REGS
block|,
name|NO_REGS
block|,
name|NO_REGS
block|,
name|NO_REGS
block|,
name|NO_REGS
block|,
name|NO_REGS
block|,
name|NO_REGS
block|,
name|NO_REGS
block|,
name|NO_REGS
block|,
name|NO_REGS
block|,
name|NO_REGS
block|,
name|NO_REGS
block|,
name|NO_REGS
block|,
name|NO_REGS
block|,
name|NO_REGS
block|,
name|NO_REGS
block|,
name|NO_REGS
block|,
name|NO_REGS
block|,
name|NO_REGS
block|,
name|NO_REGS
block|,
name|NO_REGS
block|,
name|NO_REGS
block|,
name|NO_REGS
block|,
name|NO_REGS
block|,
name|NO_REGS
block|,
name|NO_REGS
block|,
name|NO_REGS
block|,
name|NO_REGS
block|,
name|NO_REGS
block|,
name|NO_REGS
block|,
name|NO_REGS
block|,
name|NO_REGS
block|,
name|NO_REGS
block|,
name|NO_REGS
block|,
name|NO_REGS
block|,
name|NO_REGS
block|,
name|NO_REGS
block|,
name|NO_REGS
block|,
name|NO_REGS
block|,
name|NO_REGS
block|,
name|NO_REGS
block|,
name|NO_REGS
block|,
name|NO_REGS
block|,
name|NO_REGS
block|,
name|NO_REGS
block|,
name|NO_REGS
block|,
name|NO_REGS
block|,
name|NO_REGS
block|,
name|NO_REGS
block|,
name|NO_REGS
block|,
name|NO_REGS
block|,
name|NO_REGS
block|,
name|NO_REGS
block|,
name|NO_REGS
block|,
name|NO_REGS
block|,
name|NO_REGS
block|,
name|NO_REGS
block|,
name|NO_REGS
block|,
name|NO_REGS
block|,
name|NO_REGS
block|,
name|NO_REGS
block|,
name|NO_REGS
block|,
name|NO_REGS
block|,
name|NO_REGS
block|,
name|NO_REGS
block|,
name|NO_REGS
block|,
name|NO_REGS
block|,
name|NO_REGS
block|,
name|NO_REGS
block|,
name|NO_REGS
block|,
name|NO_REGS
block|,
name|NO_REGS
block|,
name|NO_REGS
block|,
name|NO_REGS
block|,
name|NO_REGS
block|,
name|NO_REGS
block|,
name|NO_REGS
block|,
name|NO_REGS
block|,
name|NO_REGS
block|,
name|NO_REGS
block|,
name|NO_REGS
block|,
name|NO_REGS
block|,
name|NO_REGS
block|,
name|NO_REGS
block|,
name|NO_REGS
block|,
name|NO_REGS
block|,
name|NO_REGS
block|,
name|NO_REGS
block|,
name|NO_REGS
block|, }
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Return truth value of whether OP can be used as an operands    where a register or 16 bit unsigned integer is needed.  */
end_comment

begin_function
name|int
name|uns_arith_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|SMALL_INT_UNSIGNED
argument_list|(
name|op
argument_list|)
condition|)
return|return
name|TRUE
return|;
return|return
name|register_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return truth value of whether OP can be used as an operands    where a 16 bit integer is needed  */
end_comment

begin_function
name|int
name|arith_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|SMALL_INT
argument_list|(
name|op
argument_list|)
condition|)
return|return
name|TRUE
return|;
return|return
name|register_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return truth value of whether OP can be used as an operand in a two    address arithmetic insn (such as set 123456,%o4) of mode MODE.  */
end_comment

begin_function
name|int
name|arith32_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
condition|)
return|return
name|TRUE
return|;
return|return
name|register_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return truth value of whether OP is a integer which fits in 16 bits  */
end_comment

begin_function
name|int
name|small_int
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
return|return
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|SMALL_INT
argument_list|(
name|op
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return truth value of whether OP is an integer which is too big to    be loaded with one instruction.  */
end_comment

begin_function
name|int
name|large_int
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
name|HOST_WIDE_INT
name|value
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|!=
name|CONST_INT
condition|)
return|return
name|FALSE
return|;
name|value
operator|=
name|INTVAL
argument_list|(
name|op
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|value
operator|&
operator|~
literal|0x0000ffff
operator|)
operator|==
literal|0
condition|)
comment|/* ior reg,$r0,value */
return|return
name|FALSE
return|;
if|if
condition|(
operator|(
call|(
name|unsigned
name|long
call|)
argument_list|(
name|value
operator|+
literal|32768
argument_list|)
operator|)
operator|<=
literal|32767
condition|)
comment|/* subu reg,$r0,value */
return|return
name|FALSE
return|;
if|if
condition|(
operator|(
name|value
operator|&
literal|0xffff0000
operator|)
operator|==
name|value
condition|)
comment|/* lui reg,value>>16 */
return|return
name|FALSE
return|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Return truth value of whether OP is a register or the constant 0.  */
end_comment

begin_function
name|int
name|reg_or_0_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
condition|)
block|{
default|default:
break|break;
case|case
name|CONST_INT
case|:
return|return
operator|(
name|INTVAL
argument_list|(
name|op
argument_list|)
operator|==
literal|0
operator|)
return|;
case|case
name|CONST_DOUBLE
case|:
if|if
condition|(
name|CONST_DOUBLE_HIGH
argument_list|(
name|op
argument_list|)
operator|!=
literal|0
operator|||
name|CONST_DOUBLE_LOW
argument_list|(
name|op
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|FALSE
return|;
return|return
name|TRUE
return|;
case|case
name|REG
case|:
case|case
name|SUBREG
case|:
return|return
name|register_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
return|;
block|}
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/* Return truth value of whether OP is one of the special multiply/divide    registers (hi, lo).  */
end_comment

begin_function
name|int
name|md_register_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
return|return
operator|(
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_INT
operator|&&
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|REG
operator|&&
name|MD_REG_P
argument_list|(
name|REGNO
argument_list|(
name|op
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return truth value of whether OP is the FP status register.  */
end_comment

begin_function
name|int
name|fpsw_register_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
return|return
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|REG
operator|&&
name|ST_REG_P
argument_list|(
name|REGNO
argument_list|(
name|op
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return truth value if a CONST_DOUBLE is ok to be a legitimate constant.  */
end_comment

begin_function
name|int
name|mips_const_double_ok
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|!=
name|CONST_DOUBLE
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|mode
operator|==
name|DImode
condition|)
return|return
name|TRUE
return|;
if|if
condition|(
name|mode
operator|!=
name|SFmode
operator|&&
name|mode
operator|!=
name|DFmode
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|CONST_DOUBLE_HIGH
argument_list|(
name|op
argument_list|)
operator|==
literal|0
operator|&&
name|CONST_DOUBLE_LOW
argument_list|(
name|op
argument_list|)
operator|==
literal|0
condition|)
return|return
name|TRUE
return|;
if|#
directive|if
name|HOST_FLOAT_FORMAT
operator|==
name|TARGET_FLOAT_FORMAT
if|if
condition|(
name|TARGET_MIPS_AS
condition|)
comment|/* gas doesn't like li.d/li.s yet */
block|{
union|union
block|{
name|double
name|d
decl_stmt|;
name|int
name|i
index|[
literal|2
index|]
decl_stmt|;
block|}
name|u
union|;
name|double
name|d
decl_stmt|;
name|u
operator|.
name|i
index|[
literal|0
index|]
operator|=
name|CONST_DOUBLE_LOW
argument_list|(
name|op
argument_list|)
expr_stmt|;
name|u
operator|.
name|i
index|[
literal|1
index|]
operator|=
name|CONST_DOUBLE_HIGH
argument_list|(
name|op
argument_list|)
expr_stmt|;
name|d
operator|=
name|u
operator|.
name|d
expr_stmt|;
if|if
condition|(
name|d
operator|!=
name|d
condition|)
return|return
name|FALSE
return|;
comment|/* NAN */
if|if
condition|(
name|d
operator|<
literal|0.0
condition|)
name|d
operator|=
operator|-
name|d
expr_stmt|;
comment|/* Rather than trying to get the accuracy down to the last bit, 	 just use approximate ranges.  */
if|if
condition|(
name|mode
operator|==
name|DFmode
operator|&&
name|d
operator|>
literal|1.0e-300
operator|&&
name|d
operator|<
literal|1.0e300
condition|)
return|return
name|TRUE
return|;
if|if
condition|(
name|mode
operator|==
name|SFmode
operator|&&
name|d
operator|>
literal|1.0e-38
operator|&&
name|d
operator|<
literal|1.0e+38
condition|)
return|return
name|TRUE
return|;
block|}
endif|#
directive|endif
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/* Return truth value if a memory operand fits in a single instruction    (ie, register + small offset).  */
end_comment

begin_function
name|int
name|simple_memory_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
name|rtx
name|addr
decl_stmt|,
name|plus0
decl_stmt|,
name|plus1
decl_stmt|;
comment|/* Eliminate non-memory operations */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|!=
name|MEM
condition|)
return|return
name|FALSE
return|;
comment|/* dword operations really put out 2 instructions, so eliminate them.  */
if|if
condition|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|op
argument_list|)
argument_list|)
operator|>
operator|(
name|HAVE_64BIT_P
argument_list|()
condition|?
literal|8
else|:
literal|4
operator|)
condition|)
return|return
name|FALSE
return|;
comment|/* Decode the address now.  */
name|addr
operator|=
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
condition|)
block|{
default|default:
break|break;
case|case
name|REG
case|:
return|return
name|TRUE
return|;
case|case
name|CONST_INT
case|:
return|return
name|SMALL_INT
argument_list|(
name|op
argument_list|)
return|;
case|case
name|PLUS
case|:
name|plus0
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|plus1
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|plus0
argument_list|)
operator|==
name|REG
operator|&&
name|GET_CODE
argument_list|(
name|plus1
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|SMALL_INT
argument_list|(
name|plus1
argument_list|)
condition|)
return|return
name|TRUE
return|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|plus1
argument_list|)
operator|==
name|REG
operator|&&
name|GET_CODE
argument_list|(
name|plus0
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|SMALL_INT
argument_list|(
name|plus0
argument_list|)
condition|)
return|return
name|TRUE
return|;
else|else
return|return
name|FALSE
return|;
if|#
directive|if
literal|0
comment|/* We used to allow small symbol refs here (ie, stuff in .sdata 	 or .sbss), but this causes some bugs in G++.  Also, it won't 	 interfere if the MIPS linker rewrites the store instruction 	 because the function is PIC.  */
block|case LABEL_REF:
comment|/* never gp relative */
block|break;      case CONST:
comment|/* If -G 0, we can never have a GP relative memory operation. 	 Also, save some time if not optimizing.  */
block|if (mips_section_threshold == 0 || !optimize || !TARGET_GP_OPT) 	return FALSE;        { 	rtx offset = const0_rtx; 	addr = eliminate_constant_term (addr,&offset); 	if (GET_CODE (op) != SYMBOL_REF) 	  return FALSE;
comment|/* let's be paranoid.... */
block|if (INTVAL (offset)< 0 || INTVAL (offset)> 0xffff) 	  return FALSE;       }
comment|/* fall through */
block|case SYMBOL_REF:       return SYMBOL_REF_FLAG (addr);
endif|#
directive|endif
block|}
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/* Return true if the code of this rtx pattern is EQ or NE.  */
end_comment

begin_function
name|int
name|equality_op
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
if|if
condition|(
name|mode
operator|!=
name|GET_MODE
argument_list|(
name|op
argument_list|)
condition|)
return|return
name|FALSE
return|;
return|return
operator|(
name|classify_op
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
operator|&
name|CLASS_EQUALITY_OP
operator|)
operator|!=
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return true if the code is a relational operations (EQ, LE, etc.) */
end_comment

begin_function
name|int
name|cmp_op
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
if|if
condition|(
name|mode
operator|!=
name|GET_MODE
argument_list|(
name|op
argument_list|)
condition|)
return|return
name|FALSE
return|;
return|return
operator|(
name|classify_op
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
operator|&
name|CLASS_CMP_OP
operator|)
operator|!=
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Genrecog does not take the type of match_operator into consideration,    and would complain about two patterns being the same if the same    function is used, so make it believe they are different.  */
end_comment

begin_function
name|int
name|cmp2_op
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
if|if
condition|(
name|mode
operator|!=
name|GET_MODE
argument_list|(
name|op
argument_list|)
condition|)
return|return
name|FALSE
return|;
return|return
operator|(
name|classify_op
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
operator|&
name|CLASS_CMP_OP
operator|)
operator|!=
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return true if the code is an unsigned relational operations (LEU, etc.) */
end_comment

begin_function
name|int
name|uns_cmp_op
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
if|if
condition|(
name|mode
operator|!=
name|GET_MODE
argument_list|(
name|op
argument_list|)
condition|)
return|return
name|FALSE
return|;
return|return
operator|(
name|classify_op
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
operator|&
name|CLASS_UNS_CMP_OP
operator|)
operator|==
name|CLASS_UNS_CMP_OP
return|;
block|}
end_function

begin_comment
comment|/* Return true if the code is a relational operation FP can use.  */
end_comment

begin_function
name|int
name|fcmp_op
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
if|if
condition|(
name|mode
operator|!=
name|GET_MODE
argument_list|(
name|op
argument_list|)
condition|)
return|return
name|FALSE
return|;
return|return
operator|(
name|classify_op
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
operator|&
name|CLASS_FCMP_OP
operator|)
operator|!=
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return true if the operand is either the PC or a label_ref.  */
end_comment

begin_function
name|int
name|pc_or_label_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
if|if
condition|(
name|op
operator|==
name|pc_rtx
condition|)
return|return
name|TRUE
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|LABEL_REF
condition|)
return|return
name|TRUE
return|;
return|return
name|FALSE
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return an operand string if the given instruction's delay slot or    wrap it in a .set noreorder section.  This is for filling delay    slots on load type instructions under GAS, which does no reordering    on its own.  For the MIPS assembler, all we do is update the filled    delay slot statistics.     We assume that operands[0] is the target register that is set.     In order to check the next insn, most of this functionality is moved    to FINAL_PRESCAN_INSN, and we just set the global variables that    it needs.  */
end_comment

begin_function
name|char
modifier|*
name|mips_fill_delay_slot
parameter_list|(
name|ret
parameter_list|,
name|type
parameter_list|,
name|operands
parameter_list|,
name|cur_insn
parameter_list|)
name|char
modifier|*
name|ret
decl_stmt|;
comment|/* normal string to return */
name|enum
name|delay_type
name|type
decl_stmt|;
comment|/* type of delay */
name|rtx
name|operands
index|[]
decl_stmt|;
comment|/* operands to use */
name|rtx
name|cur_insn
decl_stmt|;
comment|/* current insn */
block|{
specifier|register
name|rtx
name|set_reg
decl_stmt|;
specifier|register
name|enum
name|machine_mode
name|mode
decl_stmt|;
specifier|register
name|rtx
name|next_insn
init|=
operator|(
name|cur_insn
operator|)
condition|?
name|NEXT_INSN
argument_list|(
name|cur_insn
argument_list|)
else|:
operator|(
name|rtx
operator|)
literal|0
decl_stmt|;
specifier|register
name|int
name|num_nops
decl_stmt|;
if|if
condition|(
name|type
operator|==
name|DELAY_LOAD
operator|||
name|type
operator|==
name|DELAY_FCMP
condition|)
name|num_nops
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|type
operator|==
name|DELAY_HILO
condition|)
name|num_nops
operator|=
literal|2
expr_stmt|;
else|else
name|num_nops
operator|=
literal|0
expr_stmt|;
comment|/* Make sure that we don't put nop's after labels.  */
name|next_insn
operator|=
name|NEXT_INSN
argument_list|(
name|cur_insn
argument_list|)
expr_stmt|;
while|while
condition|(
name|next_insn
operator|!=
operator|(
name|rtx
operator|)
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|next_insn
argument_list|)
operator|==
name|NOTE
condition|)
name|next_insn
operator|=
name|NEXT_INSN
argument_list|(
name|next_insn
argument_list|)
expr_stmt|;
name|dslots_load_total
operator|+=
name|num_nops
expr_stmt|;
if|if
condition|(
name|TARGET_DEBUG_F_MODE
operator|||
operator|!
name|optimize
operator|||
name|type
operator|==
name|DELAY_NONE
operator|||
name|operands
operator|==
operator|(
name|rtx
operator|*
operator|)
literal|0
operator|||
name|cur_insn
operator|==
operator|(
name|rtx
operator|)
literal|0
operator|||
name|next_insn
operator|==
operator|(
name|rtx
operator|)
literal|0
operator|||
name|GET_CODE
argument_list|(
name|next_insn
argument_list|)
operator|==
name|CODE_LABEL
operator|||
operator|(
name|set_reg
operator|=
name|operands
index|[
literal|0
index|]
operator|)
operator|==
operator|(
name|rtx
operator|)
literal|0
condition|)
block|{
name|dslots_number_nops
operator|=
literal|0
expr_stmt|;
name|mips_load_reg
operator|=
operator|(
name|rtx
operator|)
literal|0
expr_stmt|;
name|mips_load_reg2
operator|=
operator|(
name|rtx
operator|)
literal|0
expr_stmt|;
name|mips_load_reg3
operator|=
operator|(
name|rtx
operator|)
literal|0
expr_stmt|;
name|mips_load_reg4
operator|=
operator|(
name|rtx
operator|)
literal|0
expr_stmt|;
return|return
name|ret
return|;
block|}
name|set_reg
operator|=
name|operands
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|set_reg
operator|==
operator|(
name|rtx
operator|)
literal|0
condition|)
return|return
name|ret
return|;
while|while
condition|(
name|GET_CODE
argument_list|(
name|set_reg
argument_list|)
operator|==
name|SUBREG
condition|)
name|set_reg
operator|=
name|SUBREG_REG
argument_list|(
name|set_reg
argument_list|)
expr_stmt|;
name|mode
operator|=
name|GET_MODE
argument_list|(
name|set_reg
argument_list|)
expr_stmt|;
name|dslots_number_nops
operator|=
name|num_nops
expr_stmt|;
name|mips_load_reg
operator|=
name|set_reg
expr_stmt|;
name|mips_load_reg2
operator|=
operator|(
name|mode
operator|==
name|DImode
operator|||
name|mode
operator|==
name|DFmode
operator|)
condition|?
name|gen_rtx
argument_list|(
name|REG
argument_list|,
name|SImode
argument_list|,
name|REGNO
argument_list|(
name|set_reg
argument_list|)
operator|+
literal|1
argument_list|)
else|:
operator|(
name|rtx
operator|)
literal|0
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|DELAY_HILO
condition|)
block|{
name|mips_load_reg3
operator|=
name|gen_rtx
argument_list|(
name|REG
argument_list|,
name|SImode
argument_list|,
name|MD_REG_FIRST
argument_list|)
expr_stmt|;
name|mips_load_reg4
operator|=
name|gen_rtx
argument_list|(
name|REG
argument_list|,
name|SImode
argument_list|,
name|MD_REG_FIRST
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|mips_load_reg3
operator|=
literal|0
expr_stmt|;
name|mips_load_reg4
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|TARGET_GAS
operator|&&
name|set_noreorder
operator|++
operator|==
literal|0
condition|)
name|fputs
argument_list|(
literal|"\t.set\tnoreorder\n"
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Determine whether a memory reference takes one (based off of the GP pointer),    two (normal), or three (label + reg) instructions, and bump the appropriate    counter for -mstats.  */
end_comment

begin_function
name|void
name|mips_count_memory_refs
parameter_list|(
name|op
parameter_list|,
name|num
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|int
name|num
decl_stmt|;
block|{
name|int
name|additional
init|=
literal|0
decl_stmt|;
name|int
name|n_words
init|=
literal|0
decl_stmt|;
name|rtx
name|addr
decl_stmt|,
name|plus0
decl_stmt|,
name|plus1
decl_stmt|;
name|enum
name|rtx_code
name|code0
decl_stmt|,
name|code1
decl_stmt|;
name|int
name|looping
decl_stmt|;
if|if
condition|(
name|TARGET_DEBUG_B_MODE
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n========== mips_count_memory_refs:\n"
argument_list|)
expr_stmt|;
name|debug_rtx
argument_list|(
name|op
argument_list|)
expr_stmt|;
block|}
comment|/* Skip MEM if passed, otherwise handle movsi of address.  */
name|addr
operator|=
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|!=
name|MEM
operator|)
condition|?
name|op
else|:
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Loop, going through the address RTL */
do|do
block|{
name|looping
operator|=
name|FALSE
expr_stmt|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
condition|)
block|{
default|default:
break|break;
case|case
name|REG
case|:
case|case
name|CONST_INT
case|:
break|break;
case|case
name|PLUS
case|:
name|plus0
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|plus1
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|code0
operator|=
name|GET_CODE
argument_list|(
name|plus0
argument_list|)
expr_stmt|;
name|code1
operator|=
name|GET_CODE
argument_list|(
name|plus1
argument_list|)
expr_stmt|;
if|if
condition|(
name|code0
operator|==
name|REG
condition|)
block|{
name|additional
operator|++
expr_stmt|;
name|addr
operator|=
name|plus1
expr_stmt|;
name|looping
operator|=
name|TRUE
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|code0
operator|==
name|CONST_INT
condition|)
block|{
name|addr
operator|=
name|plus1
expr_stmt|;
name|looping
operator|=
name|TRUE
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|code1
operator|==
name|REG
condition|)
block|{
name|additional
operator|++
expr_stmt|;
name|addr
operator|=
name|plus0
expr_stmt|;
name|looping
operator|=
name|TRUE
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|code1
operator|==
name|CONST_INT
condition|)
block|{
name|addr
operator|=
name|plus0
expr_stmt|;
name|looping
operator|=
name|TRUE
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|code0
operator|==
name|SYMBOL_REF
operator|||
name|code0
operator|==
name|LABEL_REF
operator|||
name|code0
operator|==
name|CONST
condition|)
block|{
name|addr
operator|=
name|plus0
expr_stmt|;
name|looping
operator|=
name|TRUE
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|code1
operator|==
name|SYMBOL_REF
operator|||
name|code1
operator|==
name|LABEL_REF
operator|||
name|code1
operator|==
name|CONST
condition|)
block|{
name|addr
operator|=
name|plus1
expr_stmt|;
name|looping
operator|=
name|TRUE
expr_stmt|;
continue|continue;
block|}
break|break;
case|case
name|LABEL_REF
case|:
name|n_words
operator|=
literal|2
expr_stmt|;
comment|/* always 2 words */
break|break;
case|case
name|CONST
case|:
name|addr
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|looping
operator|=
name|TRUE
expr_stmt|;
continue|continue;
case|case
name|SYMBOL_REF
case|:
name|n_words
operator|=
name|SYMBOL_REF_FLAG
argument_list|(
name|addr
argument_list|)
condition|?
literal|1
else|:
literal|2
expr_stmt|;
break|break;
block|}
block|}
do|while
condition|(
name|looping
condition|)
do|;
if|if
condition|(
name|n_words
operator|==
literal|0
condition|)
return|return;
name|n_words
operator|+=
name|additional
expr_stmt|;
if|if
condition|(
name|n_words
operator|>
literal|3
condition|)
name|n_words
operator|=
literal|3
expr_stmt|;
name|num_refs
index|[
name|n_words
operator|-
literal|1
index|]
operator|+=
name|num
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return the appropriate instructions to move one operand to another.  */
end_comment

begin_function
name|char
modifier|*
name|mips_move_1word
parameter_list|(
name|operands
parameter_list|,
name|insn
parameter_list|,
name|unsignedp
parameter_list|)
name|rtx
name|operands
index|[]
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
name|int
name|unsignedp
decl_stmt|;
block|{
name|char
modifier|*
name|ret
init|=
literal|0
decl_stmt|;
name|rtx
name|op0
init|=
name|operands
index|[
literal|0
index|]
decl_stmt|;
name|rtx
name|op1
init|=
name|operands
index|[
literal|1
index|]
decl_stmt|;
name|enum
name|rtx_code
name|code0
init|=
name|GET_CODE
argument_list|(
name|op0
argument_list|)
decl_stmt|;
name|enum
name|rtx_code
name|code1
init|=
name|GET_CODE
argument_list|(
name|op1
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|mode
init|=
name|GET_MODE
argument_list|(
name|op0
argument_list|)
decl_stmt|;
name|int
name|subreg_word0
init|=
literal|0
decl_stmt|;
name|int
name|subreg_word1
init|=
literal|0
decl_stmt|;
name|enum
name|delay_type
name|delay
init|=
name|DELAY_NONE
decl_stmt|;
while|while
condition|(
name|code0
operator|==
name|SUBREG
condition|)
block|{
name|subreg_word0
operator|+=
name|SUBREG_WORD
argument_list|(
name|op0
argument_list|)
expr_stmt|;
name|op0
operator|=
name|SUBREG_REG
argument_list|(
name|op0
argument_list|)
expr_stmt|;
name|code0
operator|=
name|GET_CODE
argument_list|(
name|op0
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|code1
operator|==
name|SUBREG
condition|)
block|{
name|subreg_word1
operator|+=
name|SUBREG_WORD
argument_list|(
name|op1
argument_list|)
expr_stmt|;
name|op1
operator|=
name|SUBREG_REG
argument_list|(
name|op1
argument_list|)
expr_stmt|;
name|code1
operator|=
name|GET_CODE
argument_list|(
name|op1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|code0
operator|==
name|REG
condition|)
block|{
name|int
name|regno0
init|=
name|REGNO
argument_list|(
name|op0
argument_list|)
operator|+
name|subreg_word0
decl_stmt|;
if|if
condition|(
name|code1
operator|==
name|REG
condition|)
block|{
name|int
name|regno1
init|=
name|REGNO
argument_list|(
name|op1
argument_list|)
operator|+
name|subreg_word1
decl_stmt|;
comment|/* Just in case, don't do anything for assigning a register 	     to itself, unless we are filling a delay slot.  */
if|if
condition|(
name|regno0
operator|==
name|regno1
operator|&&
name|set_nomacro
operator|==
literal|0
condition|)
name|ret
operator|=
literal|""
expr_stmt|;
elseif|else
if|if
condition|(
name|GP_REG_P
argument_list|(
name|regno0
argument_list|)
condition|)
block|{
if|if
condition|(
name|GP_REG_P
argument_list|(
name|regno1
argument_list|)
condition|)
name|ret
operator|=
literal|"move\t%0,%1"
expr_stmt|;
elseif|else
if|if
condition|(
name|MD_REG_P
argument_list|(
name|regno1
argument_list|)
condition|)
block|{
name|delay
operator|=
name|DELAY_HILO
expr_stmt|;
name|ret
operator|=
literal|"mf%1\t%0"
expr_stmt|;
block|}
else|else
block|{
name|delay
operator|=
name|DELAY_LOAD
expr_stmt|;
if|if
condition|(
name|FP_REG_P
argument_list|(
name|regno1
argument_list|)
condition|)
name|ret
operator|=
literal|"mfc1\t%0,%1"
expr_stmt|;
elseif|else
if|if
condition|(
name|regno1
operator|==
name|FPSW_REGNUM
condition|)
name|ret
operator|=
literal|"cfc1\t%0,$31"
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|FP_REG_P
argument_list|(
name|regno0
argument_list|)
condition|)
block|{
if|if
condition|(
name|GP_REG_P
argument_list|(
name|regno1
argument_list|)
condition|)
block|{
name|delay
operator|=
name|DELAY_LOAD
expr_stmt|;
name|ret
operator|=
literal|"mtc1\t%1,%0"
expr_stmt|;
block|}
if|if
condition|(
name|FP_REG_P
argument_list|(
name|regno1
argument_list|)
condition|)
name|ret
operator|=
literal|"mov.s\t%0,%1"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|MD_REG_P
argument_list|(
name|regno0
argument_list|)
condition|)
block|{
if|if
condition|(
name|GP_REG_P
argument_list|(
name|regno1
argument_list|)
condition|)
block|{
name|delay
operator|=
name|DELAY_HILO
expr_stmt|;
name|ret
operator|=
literal|"mt%0\t%1"
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|regno0
operator|==
name|FPSW_REGNUM
condition|)
block|{
if|if
condition|(
name|GP_REG_P
argument_list|(
name|regno1
argument_list|)
condition|)
block|{
name|delay
operator|=
name|DELAY_LOAD
expr_stmt|;
name|ret
operator|=
literal|"ctc1\t%0,$31"
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|code1
operator|==
name|MEM
condition|)
block|{
name|delay
operator|=
name|DELAY_LOAD
expr_stmt|;
if|if
condition|(
name|TARGET_STATS
condition|)
name|mips_count_memory_refs
argument_list|(
name|op1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|GP_REG_P
argument_list|(
name|regno0
argument_list|)
condition|)
block|{
comment|/* For loads, use the mode of the memory item, instead of the 		 target, so zero/sign extend can use this code as well.  */
switch|switch
condition|(
name|GET_MODE
argument_list|(
name|op1
argument_list|)
condition|)
block|{
default|default:
break|break;
case|case
name|SFmode
case|:
name|ret
operator|=
literal|"lw\t%0,%1"
expr_stmt|;
break|break;
case|case
name|SImode
case|:
name|ret
operator|=
literal|"lw\t%0,%1"
expr_stmt|;
break|break;
case|case
name|HImode
case|:
name|ret
operator|=
operator|(
name|unsignedp
operator|)
condition|?
literal|"lhu\t%0,%1"
else|:
literal|"lh\t%0,%1"
expr_stmt|;
break|break;
case|case
name|QImode
case|:
name|ret
operator|=
operator|(
name|unsignedp
operator|)
condition|?
literal|"lbu\t%0,%1"
else|:
literal|"lb\t%0,%1"
expr_stmt|;
break|break;
block|}
block|}
elseif|else
if|if
condition|(
name|FP_REG_P
argument_list|(
name|regno0
argument_list|)
operator|&&
operator|(
name|mode
operator|==
name|SImode
operator|||
name|mode
operator|==
name|SFmode
operator|)
condition|)
name|ret
operator|=
literal|"l.s\t%0,%1"
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
operator|(
name|char
operator|*
operator|)
literal|0
operator|&&
name|MEM_VOLATILE_P
argument_list|(
name|op1
argument_list|)
condition|)
block|{
name|int
name|i
init|=
name|strlen
argument_list|(
name|ret
argument_list|)
decl_stmt|;
if|if
condition|(
name|i
operator|>
sizeof|sizeof
argument_list|(
name|volatile_buffer
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
literal|"%{%}"
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
name|sprintf
argument_list|(
name|volatile_buffer
argument_list|,
literal|"%%{%s%%}"
argument_list|,
name|ret
argument_list|)
expr_stmt|;
name|ret
operator|=
name|volatile_buffer
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|code1
operator|==
name|CONST_INT
condition|)
block|{
if|if
condition|(
name|INTVAL
argument_list|(
name|op1
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|GP_REG_P
argument_list|(
name|regno0
argument_list|)
condition|)
name|ret
operator|=
literal|"move\t%0,%z1"
expr_stmt|;
elseif|else
if|if
condition|(
name|FP_REG_P
argument_list|(
name|regno0
argument_list|)
condition|)
block|{
name|delay
operator|=
name|DELAY_LOAD
expr_stmt|;
name|ret
operator|=
literal|"mtc1\t%z1,%0"
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|GP_REG_P
argument_list|(
name|regno0
argument_list|)
condition|)
name|ret
operator|=
operator|(
name|INTVAL
argument_list|(
name|op1
argument_list|)
operator|<
literal|0
operator|)
condition|?
literal|"li\t%0,%1\t\t\t# %X1"
else|:
literal|"li\t%0,%X1\t\t# %1"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|code1
operator|==
name|CONST_DOUBLE
operator|&&
name|mode
operator|==
name|SFmode
condition|)
block|{
if|if
condition|(
name|CONST_DOUBLE_HIGH
argument_list|(
name|op1
argument_list|)
operator|==
literal|0
operator|&&
name|CONST_DOUBLE_LOW
argument_list|(
name|op1
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|GP_REG_P
argument_list|(
name|regno0
argument_list|)
condition|)
name|ret
operator|=
literal|"move\t%0,%."
expr_stmt|;
elseif|else
if|if
condition|(
name|FP_REG_P
argument_list|(
name|regno0
argument_list|)
condition|)
block|{
name|delay
operator|=
name|DELAY_LOAD
expr_stmt|;
name|ret
operator|=
literal|"mtc1\t%.,%0"
expr_stmt|;
block|}
block|}
else|else
block|{
name|delay
operator|=
name|DELAY_LOAD
expr_stmt|;
name|ret
operator|=
literal|"li.s\t%0,%1"
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|code1
operator|==
name|LABEL_REF
condition|)
block|{
if|if
condition|(
name|TARGET_STATS
condition|)
name|mips_count_memory_refs
argument_list|(
name|op1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ret
operator|=
literal|"la\t%0,%a1"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|code1
operator|==
name|SYMBOL_REF
operator|||
name|code1
operator|==
name|CONST
condition|)
block|{
if|if
condition|(
name|HALF_PIC_P
argument_list|()
operator|&&
name|CONSTANT_P
argument_list|(
name|op1
argument_list|)
operator|&&
name|HALF_PIC_ADDRESS_P
argument_list|(
name|op1
argument_list|)
condition|)
block|{
name|rtx
name|offset
init|=
name|const0_rtx
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|CONST
condition|)
name|op1
operator|=
name|eliminate_constant_term
argument_list|(
name|XEXP
argument_list|(
name|op1
argument_list|,
literal|0
argument_list|)
argument_list|,
operator|&
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|SYMBOL_REF
condition|)
block|{
name|operands
index|[
literal|2
index|]
operator|=
name|HALF_PIC_PTR
argument_list|(
name|op1
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_STATS
condition|)
name|mips_count_memory_refs
argument_list|(
name|operands
index|[
literal|2
index|]
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|INTVAL
argument_list|(
name|offset
argument_list|)
operator|==
literal|0
condition|)
block|{
name|delay
operator|=
name|DELAY_LOAD
expr_stmt|;
name|ret
operator|=
literal|"lw\t%0,%2"
expr_stmt|;
block|}
else|else
block|{
name|dslots_load_total
operator|++
expr_stmt|;
name|operands
index|[
literal|3
index|]
operator|=
name|offset
expr_stmt|;
name|ret
operator|=
operator|(
name|SMALL_INT
argument_list|(
name|offset
argument_list|)
operator|)
condition|?
literal|"lw\t%0,%2%#\n\tadd\t%0,%0,%3"
else|:
literal|"lw\t%0,%2%#\n\t%[li\t%@,%3\n\tadd\t%0,%0,%@%]"
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
if|if
condition|(
name|TARGET_STATS
condition|)
name|mips_count_memory_refs
argument_list|(
name|op1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ret
operator|=
literal|"la\t%0,%a1"
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|code1
operator|==
name|PLUS
condition|)
block|{
name|rtx
name|add_op0
init|=
name|XEXP
argument_list|(
name|op1
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|rtx
name|add_op1
init|=
name|XEXP
argument_list|(
name|op1
argument_list|,
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op1
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op1
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|add_op0
operator|=
name|XEXP
argument_list|(
name|op1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* reverse operands */
name|add_op1
operator|=
name|XEXP
argument_list|(
name|op1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|operands
index|[
literal|2
index|]
operator|=
name|add_op0
expr_stmt|;
name|operands
index|[
literal|3
index|]
operator|=
name|add_op1
expr_stmt|;
name|ret
operator|=
literal|"add%:\t%0,%2,%3"
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|code0
operator|==
name|MEM
condition|)
block|{
if|if
condition|(
name|TARGET_STATS
condition|)
name|mips_count_memory_refs
argument_list|(
name|op0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|code1
operator|==
name|REG
condition|)
block|{
name|int
name|regno1
init|=
name|REGNO
argument_list|(
name|op1
argument_list|)
operator|+
name|subreg_word1
decl_stmt|;
if|if
condition|(
name|GP_REG_P
argument_list|(
name|regno1
argument_list|)
condition|)
block|{
switch|switch
condition|(
name|mode
condition|)
block|{
default|default:
break|break;
case|case
name|SFmode
case|:
name|ret
operator|=
literal|"sw\t%1,%0"
expr_stmt|;
break|break;
case|case
name|SImode
case|:
name|ret
operator|=
literal|"sw\t%1,%0"
expr_stmt|;
break|break;
case|case
name|HImode
case|:
name|ret
operator|=
literal|"sh\t%1,%0"
expr_stmt|;
break|break;
case|case
name|QImode
case|:
name|ret
operator|=
literal|"sb\t%1,%0"
expr_stmt|;
break|break;
block|}
block|}
elseif|else
if|if
condition|(
name|FP_REG_P
argument_list|(
name|regno1
argument_list|)
operator|&&
operator|(
name|mode
operator|==
name|SImode
operator|||
name|mode
operator|==
name|SFmode
operator|)
condition|)
name|ret
operator|=
literal|"s.s\t%1,%0"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|code1
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|op1
argument_list|)
operator|==
literal|0
condition|)
block|{
switch|switch
condition|(
name|mode
condition|)
block|{
default|default:
break|break;
case|case
name|SFmode
case|:
name|ret
operator|=
literal|"sw\t%z1,%0"
expr_stmt|;
break|break;
case|case
name|SImode
case|:
name|ret
operator|=
literal|"sw\t%z1,%0"
expr_stmt|;
break|break;
case|case
name|HImode
case|:
name|ret
operator|=
literal|"sh\t%z1,%0"
expr_stmt|;
break|break;
case|case
name|QImode
case|:
name|ret
operator|=
literal|"sb\t%z1,%0"
expr_stmt|;
break|break;
block|}
block|}
elseif|else
if|if
condition|(
name|code1
operator|==
name|CONST_DOUBLE
operator|&&
name|CONST_DOUBLE_HIGH
argument_list|(
name|op1
argument_list|)
operator|==
literal|0
operator|&&
name|CONST_DOUBLE_LOW
argument_list|(
name|op1
argument_list|)
operator|==
literal|0
condition|)
block|{
switch|switch
condition|(
name|mode
condition|)
block|{
default|default:
break|break;
case|case
name|SFmode
case|:
name|ret
operator|=
literal|"sw\t%.,%0"
expr_stmt|;
break|break;
case|case
name|SImode
case|:
name|ret
operator|=
literal|"sw\t%.,%0"
expr_stmt|;
break|break;
case|case
name|HImode
case|:
name|ret
operator|=
literal|"sh\t%.,%0"
expr_stmt|;
break|break;
case|case
name|QImode
case|:
name|ret
operator|=
literal|"sb\t%.,%0"
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|ret
operator|!=
operator|(
name|char
operator|*
operator|)
literal|0
operator|&&
name|MEM_VOLATILE_P
argument_list|(
name|op0
argument_list|)
condition|)
block|{
name|int
name|i
init|=
name|strlen
argument_list|(
name|ret
argument_list|)
decl_stmt|;
if|if
condition|(
name|i
operator|>
sizeof|sizeof
argument_list|(
name|volatile_buffer
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
literal|"%{%}"
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
name|sprintf
argument_list|(
name|volatile_buffer
argument_list|,
literal|"%%{%s%%}"
argument_list|,
name|ret
argument_list|)
expr_stmt|;
name|ret
operator|=
name|volatile_buffer
expr_stmt|;
block|}
block|}
if|if
condition|(
name|ret
operator|==
operator|(
name|char
operator|*
operator|)
literal|0
condition|)
block|{
name|abort_with_insn
argument_list|(
name|insn
argument_list|,
literal|"Bad move"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|delay
operator|!=
name|DELAY_NONE
condition|)
return|return
name|mips_fill_delay_slot
argument_list|(
name|ret
argument_list|,
name|delay
argument_list|,
name|operands
argument_list|,
name|insn
argument_list|)
return|;
return|return
name|ret
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return the appropriate instructions to move 2 words */
end_comment

begin_function
name|char
modifier|*
name|mips_move_2words
parameter_list|(
name|operands
parameter_list|,
name|insn
parameter_list|)
name|rtx
name|operands
index|[]
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
block|{
name|char
modifier|*
name|ret
init|=
literal|0
decl_stmt|;
name|rtx
name|op0
init|=
name|operands
index|[
literal|0
index|]
decl_stmt|;
name|rtx
name|op1
init|=
name|operands
index|[
literal|1
index|]
decl_stmt|;
name|enum
name|rtx_code
name|code0
init|=
name|GET_CODE
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
name|enum
name|rtx_code
name|code1
init|=
name|GET_CODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
decl_stmt|;
name|int
name|subreg_word0
init|=
literal|0
decl_stmt|;
name|int
name|subreg_word1
init|=
literal|0
decl_stmt|;
name|enum
name|delay_type
name|delay
init|=
name|DELAY_NONE
decl_stmt|;
while|while
condition|(
name|code0
operator|==
name|SUBREG
condition|)
block|{
name|subreg_word0
operator|+=
name|SUBREG_WORD
argument_list|(
name|op0
argument_list|)
expr_stmt|;
name|op0
operator|=
name|SUBREG_REG
argument_list|(
name|op0
argument_list|)
expr_stmt|;
name|code0
operator|=
name|GET_CODE
argument_list|(
name|op0
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|code1
operator|==
name|SUBREG
condition|)
block|{
name|subreg_word1
operator|+=
name|SUBREG_WORD
argument_list|(
name|op1
argument_list|)
expr_stmt|;
name|op1
operator|=
name|SUBREG_REG
argument_list|(
name|op1
argument_list|)
expr_stmt|;
name|code1
operator|=
name|GET_CODE
argument_list|(
name|op1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|code0
operator|==
name|REG
condition|)
block|{
name|int
name|regno0
init|=
name|REGNO
argument_list|(
name|op0
argument_list|)
operator|+
name|subreg_word0
decl_stmt|;
if|if
condition|(
name|code1
operator|==
name|REG
condition|)
block|{
name|int
name|regno1
init|=
name|REGNO
argument_list|(
name|op1
argument_list|)
operator|+
name|subreg_word1
decl_stmt|;
comment|/* Just in case, don't do anything for assigning a register 	     to itself, unless we are filling a delay slot.  */
if|if
condition|(
name|regno0
operator|==
name|regno1
operator|&&
name|set_nomacro
operator|==
literal|0
condition|)
name|ret
operator|=
literal|""
expr_stmt|;
elseif|else
if|if
condition|(
name|FP_REG_P
argument_list|(
name|regno0
argument_list|)
condition|)
block|{
if|if
condition|(
name|FP_REG_P
argument_list|(
name|regno1
argument_list|)
condition|)
name|ret
operator|=
literal|"mov.d\t%0,%1"
expr_stmt|;
else|else
block|{
name|delay
operator|=
name|DELAY_LOAD
expr_stmt|;
name|ret
operator|=
operator|(
name|TARGET_FLOAT64
operator|)
condition|?
literal|"dmtc1\t%1,%0"
else|:
literal|"mtc1\t%L1,%0\n\tmtc1\t%M1,%D0"
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|FP_REG_P
argument_list|(
name|regno1
argument_list|)
condition|)
block|{
name|delay
operator|=
name|DELAY_LOAD
expr_stmt|;
name|ret
operator|=
operator|(
name|TARGET_FLOAT64
operator|)
condition|?
literal|"dmfc1\t%0,%1"
else|:
literal|"mfc1\t%L0,%1\n\tmfc1\t%M0,%D1"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|MD_REG_P
argument_list|(
name|regno0
argument_list|)
operator|&&
name|GP_REG_P
argument_list|(
name|regno1
argument_list|)
condition|)
block|{
name|delay
operator|=
name|DELAY_HILO
expr_stmt|;
name|ret
operator|=
literal|"mthi\t%M1\n\tmtlo\t%L1"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GP_REG_P
argument_list|(
name|regno0
argument_list|)
operator|&&
name|MD_REG_P
argument_list|(
name|regno1
argument_list|)
condition|)
block|{
name|delay
operator|=
name|DELAY_HILO
expr_stmt|;
name|ret
operator|=
literal|"mfhi\t%M0\n\tmflo\t%L0"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|regno0
operator|!=
operator|(
name|regno1
operator|+
literal|1
operator|)
condition|)
name|ret
operator|=
literal|"move\t%0,%1\n\tmove\t%D0,%D1"
expr_stmt|;
else|else
name|ret
operator|=
literal|"move\t%D0,%D1\n\tmove\t%0,%1"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|code1
operator|==
name|CONST_DOUBLE
condition|)
block|{
if|if
condition|(
name|CONST_DOUBLE_HIGH
argument_list|(
name|op1
argument_list|)
operator|!=
literal|0
operator|||
name|CONST_DOUBLE_LOW
argument_list|(
name|op1
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|GET_MODE
argument_list|(
name|op1
argument_list|)
operator|==
name|DFmode
condition|)
block|{
name|delay
operator|=
name|DELAY_LOAD
expr_stmt|;
name|ret
operator|=
literal|"li.d\t%0,%1"
expr_stmt|;
block|}
else|else
block|{
name|operands
index|[
literal|2
index|]
operator|=
name|GEN_INT
argument_list|(
name|CONST_DOUBLE_LOW
argument_list|(
name|op1
argument_list|)
argument_list|)
expr_stmt|;
name|operands
index|[
literal|3
index|]
operator|=
name|GEN_INT
argument_list|(
name|CONST_DOUBLE_HIGH
argument_list|(
name|op1
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|=
literal|"li\t%M0,%3\n\tli\t%L0,%2"
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|GP_REG_P
argument_list|(
name|regno0
argument_list|)
condition|)
name|ret
operator|=
literal|"move\t%0,%.\n\tmove\t%D0,%."
expr_stmt|;
elseif|else
if|if
condition|(
name|FP_REG_P
argument_list|(
name|regno0
argument_list|)
condition|)
block|{
name|delay
operator|=
name|DELAY_LOAD
expr_stmt|;
name|ret
operator|=
operator|(
name|TARGET_FLOAT64
operator|)
condition|?
literal|"dmtc1\t%.,%0"
else|:
literal|"mtc1\t%.,%0\n\tmtc1\t%.,%D0"
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|code1
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|op1
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|GP_REG_P
argument_list|(
name|regno0
argument_list|)
condition|)
name|ret
operator|=
literal|"move\t%0,%.\n\tmove\t%D0,%."
expr_stmt|;
elseif|else
if|if
condition|(
name|FP_REG_P
argument_list|(
name|regno0
argument_list|)
condition|)
block|{
name|delay
operator|=
name|DELAY_LOAD
expr_stmt|;
name|ret
operator|=
operator|(
name|TARGET_FLOAT64
operator|)
condition|?
literal|"dmtc1\t%.,%0"
else|:
literal|"mtc1\t%.,%0\n\tmtc1\t%.,%D0"
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|code1
operator|==
name|CONST_INT
operator|&&
name|GET_MODE
argument_list|(
name|op0
argument_list|)
operator|==
name|DImode
operator|&&
name|GP_REG_P
argument_list|(
name|regno0
argument_list|)
condition|)
block|{
name|operands
index|[
literal|2
index|]
operator|=
name|GEN_INT
argument_list|(
name|INTVAL
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|>=
literal|0
condition|?
literal|0
else|:
operator|-
literal|1
argument_list|)
expr_stmt|;
name|ret
operator|=
literal|"li\t%M0,%2\n\tli\t%L0,%1"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|code1
operator|==
name|MEM
condition|)
block|{
name|delay
operator|=
name|DELAY_LOAD
expr_stmt|;
if|if
condition|(
name|TARGET_STATS
condition|)
name|mips_count_memory_refs
argument_list|(
name|op1
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|FP_REG_P
argument_list|(
name|regno0
argument_list|)
condition|)
name|ret
operator|=
literal|"l.d\t%0,%1"
expr_stmt|;
elseif|else
if|if
condition|(
name|offsettable_address_p
argument_list|(
literal|1
argument_list|,
name|DFmode
argument_list|,
name|XEXP
argument_list|(
name|op1
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
block|{
name|operands
index|[
literal|2
index|]
operator|=
name|adj_offsettable_operand
argument_list|(
name|op1
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg_mentioned_p
argument_list|(
name|op0
argument_list|,
name|op1
argument_list|)
condition|)
name|ret
operator|=
literal|"lw\t%D0,%2\n\tlw\t%0,%1"
expr_stmt|;
else|else
name|ret
operator|=
literal|"lw\t%0,%1\n\tlw\t%D0,%2"
expr_stmt|;
block|}
if|if
condition|(
name|ret
operator|!=
operator|(
name|char
operator|*
operator|)
literal|0
operator|&&
name|MEM_VOLATILE_P
argument_list|(
name|op1
argument_list|)
condition|)
block|{
name|int
name|i
init|=
name|strlen
argument_list|(
name|ret
argument_list|)
decl_stmt|;
if|if
condition|(
name|i
operator|>
sizeof|sizeof
argument_list|(
name|volatile_buffer
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
literal|"%{%}"
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
name|sprintf
argument_list|(
name|volatile_buffer
argument_list|,
literal|"%%{%s%%}"
argument_list|,
name|ret
argument_list|)
expr_stmt|;
name|ret
operator|=
name|volatile_buffer
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|code0
operator|==
name|MEM
condition|)
block|{
if|if
condition|(
name|code1
operator|==
name|REG
condition|)
block|{
name|int
name|regno1
init|=
name|REGNO
argument_list|(
name|op1
argument_list|)
operator|+
name|subreg_word1
decl_stmt|;
if|if
condition|(
name|FP_REG_P
argument_list|(
name|regno1
argument_list|)
condition|)
name|ret
operator|=
literal|"s.d\t%1,%0"
expr_stmt|;
elseif|else
if|if
condition|(
name|offsettable_address_p
argument_list|(
literal|1
argument_list|,
name|DFmode
argument_list|,
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
block|{
name|operands
index|[
literal|2
index|]
operator|=
name|adj_offsettable_operand
argument_list|(
name|op0
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|ret
operator|=
literal|"sw\t%1,%0\n\tsw\t%D1,%2"
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|code1
operator|==
name|CONST_DOUBLE
operator|&&
name|CONST_DOUBLE_HIGH
argument_list|(
name|op1
argument_list|)
operator|==
literal|0
operator|&&
name|CONST_DOUBLE_LOW
argument_list|(
name|op1
argument_list|)
operator|==
literal|0
operator|&&
name|offsettable_address_p
argument_list|(
literal|1
argument_list|,
name|DFmode
argument_list|,
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|TARGET_FLOAT64
condition|)
name|ret
operator|=
literal|"sd\t%.,%0"
expr_stmt|;
else|else
block|{
name|operands
index|[
literal|2
index|]
operator|=
name|adj_offsettable_operand
argument_list|(
name|op0
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|ret
operator|=
literal|"sw\t%.,%0\n\tsw\t%.,%2"
expr_stmt|;
block|}
block|}
if|if
condition|(
name|TARGET_STATS
condition|)
name|mips_count_memory_refs
argument_list|(
name|op0
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
operator|(
name|char
operator|*
operator|)
literal|0
operator|&&
name|MEM_VOLATILE_P
argument_list|(
name|op0
argument_list|)
condition|)
block|{
name|int
name|i
init|=
name|strlen
argument_list|(
name|ret
argument_list|)
decl_stmt|;
if|if
condition|(
name|i
operator|>
sizeof|sizeof
argument_list|(
name|volatile_buffer
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
literal|"%{%}"
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
name|sprintf
argument_list|(
name|volatile_buffer
argument_list|,
literal|"%%{%s%%}"
argument_list|,
name|ret
argument_list|)
expr_stmt|;
name|ret
operator|=
name|volatile_buffer
expr_stmt|;
block|}
block|}
if|if
condition|(
name|ret
operator|==
operator|(
name|char
operator|*
operator|)
literal|0
condition|)
block|{
name|abort_with_insn
argument_list|(
name|insn
argument_list|,
literal|"Bad move"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|delay
operator|!=
name|DELAY_NONE
condition|)
return|return
name|mips_fill_delay_slot
argument_list|(
name|ret
argument_list|,
name|delay
argument_list|,
name|operands
argument_list|,
name|insn
argument_list|)
return|;
return|return
name|ret
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Provide the costs of an addressing mode that contains ADDR.    If ADDR is not a valid address, its cost is irrelevant.  */
end_comment

begin_function
name|int
name|mips_address_cost
parameter_list|(
name|addr
parameter_list|)
name|rtx
name|addr
decl_stmt|;
block|{
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
condition|)
block|{
default|default:
break|break;
case|case
name|LO_SUM
case|:
case|case
name|HIGH
case|:
return|return
literal|1
return|;
case|case
name|LABEL_REF
case|:
return|return
literal|2
return|;
case|case
name|CONST
case|:
block|{
name|rtx
name|offset
init|=
name|const0_rtx
decl_stmt|;
name|addr
operator|=
name|eliminate_constant_term
argument_list|(
name|addr
argument_list|,
operator|&
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|LABEL_REF
condition|)
return|return
literal|2
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|!=
name|SYMBOL_REF
condition|)
return|return
literal|4
return|;
if|if
condition|(
name|INTVAL
argument_list|(
name|offset
argument_list|)
operator|<
operator|-
literal|32768
operator|||
name|INTVAL
argument_list|(
name|offset
argument_list|)
operator|>
literal|32767
condition|)
return|return
literal|2
return|;
block|}
comment|/* fall through */
case|case
name|SYMBOL_REF
case|:
return|return
name|SYMBOL_REF_FLAG
argument_list|(
name|addr
argument_list|)
condition|?
literal|1
else|:
literal|2
return|;
case|case
name|PLUS
case|:
block|{
specifier|register
name|rtx
name|plus0
init|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
decl_stmt|;
specifier|register
name|rtx
name|plus1
init|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|plus0
argument_list|)
operator|!=
name|REG
operator|&&
name|GET_CODE
argument_list|(
name|plus1
argument_list|)
operator|==
name|REG
condition|)
block|{
name|plus0
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|plus1
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|plus0
argument_list|)
operator|!=
name|REG
condition|)
break|break;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|plus1
argument_list|)
condition|)
block|{
default|default:
break|break;
case|case
name|CONST_INT
case|:
block|{
name|int
name|value
init|=
name|INTVAL
argument_list|(
name|plus1
argument_list|)
decl_stmt|;
return|return
operator|(
name|value
operator|<
operator|-
literal|32768
operator|||
name|value
operator|>
literal|32767
operator|)
condition|?
literal|2
else|:
literal|1
return|;
block|}
case|case
name|CONST
case|:
case|case
name|SYMBOL_REF
case|:
case|case
name|LABEL_REF
case|:
case|case
name|HIGH
case|:
case|case
name|LO_SUM
case|:
return|return
name|mips_address_cost
argument_list|(
name|plus1
argument_list|)
operator|+
literal|1
return|;
block|}
block|}
block|}
return|return
literal|4
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Make normal rtx_code into something we can index from an array */
end_comment

begin_function
specifier|static
name|enum
name|internal_test
name|map_test_to_internal_test
parameter_list|(
name|test_code
parameter_list|)
name|enum
name|rtx_code
name|test_code
decl_stmt|;
block|{
name|enum
name|internal_test
name|test
init|=
name|ITEST_MAX
decl_stmt|;
switch|switch
condition|(
name|test_code
condition|)
block|{
default|default:
break|break;
case|case
name|EQ
case|:
name|test
operator|=
name|ITEST_EQ
expr_stmt|;
break|break;
case|case
name|NE
case|:
name|test
operator|=
name|ITEST_NE
expr_stmt|;
break|break;
case|case
name|GT
case|:
name|test
operator|=
name|ITEST_GT
expr_stmt|;
break|break;
case|case
name|GE
case|:
name|test
operator|=
name|ITEST_GE
expr_stmt|;
break|break;
case|case
name|LT
case|:
name|test
operator|=
name|ITEST_LT
expr_stmt|;
break|break;
case|case
name|LE
case|:
name|test
operator|=
name|ITEST_LE
expr_stmt|;
break|break;
case|case
name|GTU
case|:
name|test
operator|=
name|ITEST_GTU
expr_stmt|;
break|break;
case|case
name|GEU
case|:
name|test
operator|=
name|ITEST_GEU
expr_stmt|;
break|break;
case|case
name|LTU
case|:
name|test
operator|=
name|ITEST_LTU
expr_stmt|;
break|break;
case|case
name|LEU
case|:
name|test
operator|=
name|ITEST_LEU
expr_stmt|;
break|break;
block|}
return|return
name|test
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Generate the code to compare two integer values.  The return value is:    (reg:SI xx)		The pseudo register the comparison is in    (rtx)0	       	No register, generate a simple branch.  */
end_comment

begin_function
name|rtx
name|gen_int_relational
parameter_list|(
name|test_code
parameter_list|,
name|result
parameter_list|,
name|cmp0
parameter_list|,
name|cmp1
parameter_list|,
name|p_invert
parameter_list|)
name|enum
name|rtx_code
name|test_code
decl_stmt|;
comment|/* relational test (EQ, etc) */
name|rtx
name|result
decl_stmt|;
comment|/* result to store comp. or 0 if branch */
name|rtx
name|cmp0
decl_stmt|;
comment|/* first operand to compare */
name|rtx
name|cmp1
decl_stmt|;
comment|/* second operand to compare */
name|int
modifier|*
name|p_invert
decl_stmt|;
comment|/* NULL or ptr to hold whether branch needs */
comment|/* to reverse its test */
block|{
struct|struct
name|cmp_info
block|{
name|enum
name|rtx_code
name|test_code
decl_stmt|;
comment|/* code to use in instruction (LT vs. LTU) */
name|int
name|const_low
decl_stmt|;
comment|/* low bound of constant we can accept */
name|int
name|const_high
decl_stmt|;
comment|/* high bound of constant we can accept */
name|int
name|const_add
decl_stmt|;
comment|/* constant to add (convert LE -> LT) */
name|int
name|reverse_regs
decl_stmt|;
comment|/* reverse registers in test */
name|int
name|invert_const
decl_stmt|;
comment|/* != 0 if invert value if cmp1 is constant */
name|int
name|invert_reg
decl_stmt|;
comment|/* != 0 if invert value if cmp1 is register */
name|int
name|unsignedp
decl_stmt|;
comment|/* != 0 for unsigned comparisons.  */
block|}
struct|;
specifier|static
name|struct
name|cmp_info
name|info
index|[
operator|(
name|int
operator|)
name|ITEST_MAX
index|]
init|=
block|{
block|{
name|XOR
block|,
literal|0
block|,
literal|65535
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* EQ  */
block|{
name|XOR
block|,
literal|0
block|,
literal|65535
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|}
block|,
comment|/* NE  */
block|{
name|LT
block|,
operator|-
literal|32769
block|,
literal|32766
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* GT  */
block|{
name|LT
block|,
operator|-
literal|32768
block|,
literal|32767
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|}
block|,
comment|/* GE  */
block|{
name|LT
block|,
operator|-
literal|32768
block|,
literal|32767
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* LT  */
block|{
name|LT
block|,
operator|-
literal|32769
block|,
literal|32766
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|}
block|,
comment|/* LE  */
block|{
name|LTU
block|,
operator|-
literal|32769
block|,
literal|32766
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|1
block|}
block|,
comment|/* GTU */
block|{
name|LTU
block|,
operator|-
literal|32768
block|,
literal|32767
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|}
block|,
comment|/* GEU */
block|{
name|LTU
block|,
operator|-
literal|32768
block|,
literal|32767
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|}
block|,
comment|/* LTU */
block|{
name|LTU
block|,
operator|-
literal|32769
block|,
literal|32766
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|}
block|,
comment|/* LEU */
block|}
decl_stmt|;
name|enum
name|internal_test
name|test
decl_stmt|;
name|struct
name|cmp_info
modifier|*
name|p_info
decl_stmt|;
name|int
name|branch_p
decl_stmt|;
name|int
name|eqne_p
decl_stmt|;
name|int
name|invert
decl_stmt|;
name|rtx
name|reg
decl_stmt|;
name|rtx
name|reg2
decl_stmt|;
name|test
operator|=
name|map_test_to_internal_test
argument_list|(
name|test_code
argument_list|)
expr_stmt|;
if|if
condition|(
name|test
operator|==
name|ITEST_MAX
condition|)
name|abort
argument_list|()
expr_stmt|;
name|p_info
operator|=
operator|&
name|info
index|[
operator|(
name|int
operator|)
name|test
index|]
expr_stmt|;
name|eqne_p
operator|=
operator|(
name|p_info
operator|->
name|test_code
operator|==
name|XOR
operator|)
expr_stmt|;
comment|/* Eliminate simple branches */
name|branch_p
operator|=
operator|(
name|result
operator|==
operator|(
name|rtx
operator|)
literal|0
operator|)
expr_stmt|;
if|if
condition|(
name|branch_p
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|cmp0
argument_list|)
operator|==
name|REG
operator|||
name|GET_CODE
argument_list|(
name|cmp0
argument_list|)
operator|==
name|SUBREG
condition|)
block|{
comment|/* Comparisons against zero are simple branches */
if|if
condition|(
name|GET_CODE
argument_list|(
name|cmp1
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|cmp1
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|rtx
operator|)
literal|0
return|;
comment|/* Test for beq/bne.  */
if|if
condition|(
name|eqne_p
condition|)
return|return
operator|(
name|rtx
operator|)
literal|0
return|;
block|}
comment|/* allocate a pseudo to calculate the value in.  */
name|result
operator|=
name|gen_reg_rtx
argument_list|(
name|SImode
argument_list|)
expr_stmt|;
block|}
comment|/* Make sure we can handle any constants given to us.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|cmp0
argument_list|)
operator|==
name|CONST_INT
condition|)
name|cmp0
operator|=
name|force_reg
argument_list|(
name|SImode
argument_list|,
name|cmp0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|cmp1
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|HOST_WIDE_INT
name|value
init|=
name|INTVAL
argument_list|(
name|cmp1
argument_list|)
decl_stmt|;
if|if
condition|(
name|value
operator|<
name|p_info
operator|->
name|const_low
operator|||
name|value
operator|>
name|p_info
operator|->
name|const_high
condition|)
name|cmp1
operator|=
name|force_reg
argument_list|(
name|SImode
argument_list|,
name|cmp1
argument_list|)
expr_stmt|;
block|}
comment|/* See if we need to invert the result.  */
name|invert
operator|=
operator|(
name|GET_CODE
argument_list|(
name|cmp1
argument_list|)
operator|==
name|CONST_INT
operator|)
condition|?
name|p_info
operator|->
name|invert_const
else|:
name|p_info
operator|->
name|invert_reg
expr_stmt|;
if|if
condition|(
name|p_invert
operator|!=
operator|(
name|int
operator|*
operator|)
literal|0
condition|)
block|{
operator|*
name|p_invert
operator|=
name|invert
expr_stmt|;
name|invert
operator|=
name|FALSE
expr_stmt|;
block|}
comment|/* Comparison to constants, may involve adding 1 to change a LT into LE.      Comparison between two registers, may involve switching operands.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|cmp1
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
if|if
condition|(
name|p_info
operator|->
name|const_add
operator|!=
literal|0
condition|)
block|{
name|HOST_WIDE_INT
name|new
init|=
name|INTVAL
argument_list|(
name|cmp1
argument_list|)
operator|+
name|p_info
operator|->
name|const_add
decl_stmt|;
comment|/* If modification of cmp1 caused overflow, 	     we would get the wrong answer if we follow the usual path; 	     thus, x> 0xffffffffu would turn into x> 0u.  */
if|if
condition|(
operator|(
name|p_info
operator|->
name|unsignedp
condition|?
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|new
operator|>
name|INTVAL
argument_list|(
name|cmp1
argument_list|)
else|:
name|new
operator|>
name|INTVAL
argument_list|(
name|cmp1
argument_list|)
operator|)
operator|!=
operator|(
name|p_info
operator|->
name|const_add
operator|>
literal|0
operator|)
condition|)
comment|/* 1 is the right value in the LE and LEU case. 	       In the GT and GTU case, *p_invert is already set, 	       so this is effectively 0.  */
return|return
name|force_reg
argument_list|(
name|SImode
argument_list|,
name|const1_rtx
argument_list|)
return|;
else|else
name|cmp1
operator|=
name|GEN_INT
argument_list|(
name|new
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|p_info
operator|->
name|reverse_regs
condition|)
block|{
name|rtx
name|temp
init|=
name|cmp0
decl_stmt|;
name|cmp0
operator|=
name|cmp1
expr_stmt|;
name|cmp1
operator|=
name|temp
expr_stmt|;
block|}
if|if
condition|(
name|test
operator|==
name|ITEST_NE
operator|&&
name|GET_CODE
argument_list|(
name|cmp1
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|cmp1
argument_list|)
operator|==
literal|0
condition|)
name|reg
operator|=
name|cmp0
expr_stmt|;
else|else
block|{
name|reg
operator|=
operator|(
name|invert
operator|||
name|eqne_p
operator|)
condition|?
name|gen_reg_rtx
argument_list|(
name|SImode
argument_list|)
else|:
name|result
expr_stmt|;
name|emit_move_insn
argument_list|(
name|reg
argument_list|,
name|gen_rtx
argument_list|(
name|p_info
operator|->
name|test_code
argument_list|,
name|SImode
argument_list|,
name|cmp0
argument_list|,
name|cmp1
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|test
operator|==
name|ITEST_NE
condition|)
block|{
name|emit_move_insn
argument_list|(
name|result
argument_list|,
name|gen_rtx
argument_list|(
name|GTU
argument_list|,
name|SImode
argument_list|,
name|reg
argument_list|,
name|const0_rtx
argument_list|)
argument_list|)
expr_stmt|;
name|invert
operator|=
name|FALSE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|test
operator|==
name|ITEST_EQ
condition|)
block|{
name|reg2
operator|=
operator|(
name|invert
operator|)
condition|?
name|gen_reg_rtx
argument_list|(
name|SImode
argument_list|)
else|:
name|result
expr_stmt|;
name|emit_move_insn
argument_list|(
name|reg2
argument_list|,
name|gen_rtx
argument_list|(
name|LTU
argument_list|,
name|SImode
argument_list|,
name|reg
argument_list|,
name|const1_rtx
argument_list|)
argument_list|)
expr_stmt|;
name|reg
operator|=
name|reg2
expr_stmt|;
block|}
if|if
condition|(
name|invert
condition|)
name|emit_move_insn
argument_list|(
name|result
argument_list|,
name|gen_rtx
argument_list|(
name|XOR
argument_list|,
name|SImode
argument_list|,
name|reg
argument_list|,
name|const1_rtx
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Emit the common code for doing conditional branches.    operand[0] is the label to jump to.    The comparison operands are saved away by cmp{si,sf,df}.  */
end_comment

begin_function
name|void
name|gen_conditional_branch
parameter_list|(
name|operands
parameter_list|,
name|test_code
parameter_list|)
name|rtx
name|operands
index|[]
decl_stmt|;
name|enum
name|rtx_code
name|test_code
decl_stmt|;
block|{
specifier|static
name|enum
name|machine_mode
name|mode_map
index|[
operator|(
name|int
operator|)
name|CMP_MAX
index|]
index|[
operator|(
name|int
operator|)
name|ITEST_MAX
index|]
init|=
block|{
block|{
comment|/* CMP_SI */
name|SImode
block|,
comment|/* eq  */
name|SImode
block|,
comment|/* ne  */
name|SImode
block|,
comment|/* gt  */
name|SImode
block|,
comment|/* ge  */
name|SImode
block|,
comment|/* lt  */
name|SImode
block|,
comment|/* le  */
name|SImode
block|,
comment|/* gtu */
name|SImode
block|,
comment|/* geu */
name|SImode
block|,
comment|/* ltu */
name|SImode
block|,
comment|/* leu */
block|}
block|,
block|{
comment|/* CMP_SF */
name|CC_FPmode
block|,
comment|/* eq  */
name|CC_REV_FPmode
block|,
comment|/* ne  */
name|CC_FPmode
block|,
comment|/* gt  */
name|CC_FPmode
block|,
comment|/* ge  */
name|CC_FPmode
block|,
comment|/* lt  */
name|CC_FPmode
block|,
comment|/* le  */
name|VOIDmode
block|,
comment|/* gtu */
name|VOIDmode
block|,
comment|/* geu */
name|VOIDmode
block|,
comment|/* ltu */
name|VOIDmode
block|,
comment|/* leu */
block|}
block|,
block|{
comment|/* CMP_DF */
name|CC_FPmode
block|,
comment|/* eq  */
name|CC_REV_FPmode
block|,
comment|/* ne  */
name|CC_FPmode
block|,
comment|/* gt  */
name|CC_FPmode
block|,
comment|/* ge  */
name|CC_FPmode
block|,
comment|/* lt  */
name|CC_FPmode
block|,
comment|/* le  */
name|VOIDmode
block|,
comment|/* gtu */
name|VOIDmode
block|,
comment|/* geu */
name|VOIDmode
block|,
comment|/* ltu */
name|VOIDmode
block|,
comment|/* leu */
block|}
block|,   }
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|enum
name|cmp_type
name|type
init|=
name|branch_type
decl_stmt|;
name|rtx
name|cmp0
init|=
name|branch_cmp
index|[
literal|0
index|]
decl_stmt|;
name|rtx
name|cmp1
init|=
name|branch_cmp
index|[
literal|1
index|]
decl_stmt|;
name|rtx
name|label1
init|=
name|gen_rtx
argument_list|(
name|LABEL_REF
argument_list|,
name|VOIDmode
argument_list|,
name|operands
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
name|rtx
name|label2
init|=
name|pc_rtx
decl_stmt|;
name|rtx
name|reg
init|=
operator|(
name|rtx
operator|)
literal|0
decl_stmt|;
name|int
name|invert
init|=
literal|0
decl_stmt|;
name|enum
name|internal_test
name|test
init|=
name|map_test_to_internal_test
argument_list|(
name|test_code
argument_list|)
decl_stmt|;
if|if
condition|(
name|test
operator|==
name|ITEST_MAX
condition|)
block|{
name|mode
operator|=
name|SImode
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
comment|/* Get the machine mode to use (CCmode, CC_EQmode, CC_FPmode, or CC_REV_FPmode).  */
name|mode
operator|=
name|mode_map
index|[
operator|(
name|int
operator|)
name|type
index|]
index|[
operator|(
name|int
operator|)
name|test
index|]
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|VOIDmode
condition|)
goto|goto
name|fail
goto|;
switch|switch
condition|(
name|branch_type
condition|)
block|{
default|default:
goto|goto
name|fail
goto|;
case|case
name|CMP_SI
case|:
name|reg
operator|=
name|gen_int_relational
argument_list|(
name|test_code
argument_list|,
operator|(
name|rtx
operator|)
literal|0
argument_list|,
name|cmp0
argument_list|,
name|cmp1
argument_list|,
operator|&
name|invert
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg
operator|!=
operator|(
name|rtx
operator|)
literal|0
condition|)
block|{
name|cmp0
operator|=
name|reg
expr_stmt|;
name|cmp1
operator|=
name|const0_rtx
expr_stmt|;
name|test_code
operator|=
name|NE
expr_stmt|;
block|}
comment|/* Make sure not non-zero constant if ==/!= */
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|cmp1
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|cmp1
argument_list|)
operator|!=
literal|0
condition|)
name|cmp1
operator|=
name|force_reg
argument_list|(
name|SImode
argument_list|,
name|cmp1
argument_list|)
expr_stmt|;
break|break;
case|case
name|CMP_DF
case|:
case|case
name|CMP_SF
case|:
block|{
name|rtx
name|reg
init|=
name|gen_rtx
argument_list|(
name|REG
argument_list|,
name|mode
argument_list|,
name|FPSW_REGNUM
argument_list|)
decl_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx
argument_list|(
name|SET
argument_list|,
name|VOIDmode
argument_list|,
name|reg
argument_list|,
name|gen_rtx
argument_list|(
name|test_code
argument_list|,
name|mode
argument_list|,
name|cmp0
argument_list|,
name|cmp1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|cmp0
operator|=
name|reg
expr_stmt|;
name|cmp1
operator|=
name|const0_rtx
expr_stmt|;
name|test_code
operator|=
name|NE
expr_stmt|;
block|}
break|break;
block|}
comment|/* Generate the jump */
if|if
condition|(
name|invert
condition|)
block|{
name|label2
operator|=
name|label1
expr_stmt|;
name|label1
operator|=
name|pc_rtx
expr_stmt|;
block|}
name|emit_jump_insn
argument_list|(
name|gen_rtx
argument_list|(
name|SET
argument_list|,
name|VOIDmode
argument_list|,
name|pc_rtx
argument_list|,
name|gen_rtx
argument_list|(
name|IF_THEN_ELSE
argument_list|,
name|VOIDmode
argument_list|,
name|gen_rtx
argument_list|(
name|test_code
argument_list|,
name|mode
argument_list|,
name|cmp0
argument_list|,
name|cmp1
argument_list|)
argument_list|,
name|label1
argument_list|,
name|label2
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return;
name|fail
label|:
name|abort_with_insn
argument_list|(
name|gen_rtx
argument_list|(
name|test_code
argument_list|,
name|mode
argument_list|,
name|cmp0
argument_list|,
name|cmp1
argument_list|)
argument_list|,
literal|"bad test"
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_define
define|#
directive|define
name|UNITS_PER_SHORT
value|(SHORT_TYPE_SIZE / BITS_PER_UNIT)
end_define

begin_comment
comment|/* Internal code to generate the load and store of one word/short/byte.    The load is emitted directly, and the store insn is returned.  */
end_comment

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
unit|static rtx block_move_load_store (dest_reg, src_reg, p_bytes, p_offset, align, orig_src)      rtx src_reg;
comment|/* register holding source memory address */
end_comment

begin_comment
unit|rtx dest_reg;
comment|/* register holding dest. memory address */
end_comment

begin_comment
unit|int *p_bytes;
comment|/* pointer to # bytes remaining */
end_comment

begin_comment
unit|int *p_offset;
comment|/* pointer to current offset */
end_comment

begin_comment
unit|int align;
comment|/* alignment */
end_comment

begin_comment
unit|rtx orig_src;
comment|/* original source for making a reg note */
end_comment

begin_comment
unit|{   int bytes;
comment|/* # bytes remaining */
end_comment

begin_comment
unit|int offset;
comment|/* offset to use */
end_comment

begin_comment
unit|int size;
comment|/* size in bytes of load/store */
end_comment

begin_comment
unit|enum machine_mode mode;
comment|/* mode to use for load/store */
end_comment

begin_comment
unit|rtx reg;
comment|/* temporary register */
end_comment

begin_comment
unit|rtx src_addr;
comment|/* source address */
end_comment

begin_comment
unit|rtx dest_addr;
comment|/* destination address */
end_comment

begin_comment
unit|rtx insn;
comment|/* insn of the load */
end_comment

begin_comment
unit|rtx orig_src_addr;
comment|/* original source address */
end_comment

begin_comment
unit|rtx (*load_func)();
comment|/* function to generate load insn */
end_comment

begin_comment
unit|rtx (*store_func)();
comment|/* function to generate destination insn */
end_comment

begin_if
unit|bytes = *p_bytes;   if (bytes<= 0 || align<= 0)     abort ();    if (bytes>= UNITS_PER_WORD&& align>= UNITS_PER_WORD)     {       mode = SImode;       size = UNITS_PER_WORD;       load_func = gen_movsi;       store_func = gen_movsi;     }
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* Don't generate unligned moves here, rather defer those to the      general movestrsi_internal pattern.  */
end_comment

begin_endif
unit|else if (bytes>= UNITS_PER_WORD)     {       mode = SImode;       size = UNITS_PER_WORD;       load_func = gen_movsi_ulw;       store_func = gen_movsi_usw;     }
endif|#
directive|endif
end_endif

begin_endif
unit|else if (bytes>= UNITS_PER_SHORT&& align>= UNITS_PER_SHORT)     {       mode = HImode;       size = UNITS_PER_SHORT;       load_func = gen_movhi;       store_func = gen_movhi;     }    else     {       mode = QImode;       size = 1;       load_func = gen_movqi;       store_func = gen_movqi;     }    offset = *p_offset;   *p_offset = offset + size;   *p_bytes = bytes - size;    if (offset == 0)     {       src_addr  = src_reg;       dest_addr = dest_reg;     }   else     {       src_addr  = gen_rtx (PLUS, Pmode, src_reg,  GEN_INT (offset));       dest_addr = gen_rtx (PLUS, Pmode, dest_reg, GEN_INT (offset));     }    reg = gen_reg_rtx (mode);   insn = emit_insn ((*load_func) (reg, gen_rtx (MEM, mode, src_addr)));   orig_src_addr = XEXP (orig_src, 0);   if (CONSTANT_P (orig_src_addr))     REG_NOTES (insn) = gen_rtx (EXPR_LIST, REG_EQUIV, 				plus_constant (orig_src_addr, offset), 				REG_NOTES (insn));    return (*store_func) (gen_rtx (MEM, mode, dest_addr), reg); }
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_comment
comment|/* Write a series of loads/stores to move some bytes.  Generate load/stores as follows:     load  1    load  2    load  3    store 1    load  4    store 2    load  5    store 3    ...     This way, no NOP's are needed, except at the end, and only    two temp registers are needed.  Two delay slots are used    in deference to the R4000.  */
end_comment

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
unit|static void block_move_sequence (dest_reg, src_reg, bytes, align, orig_src)      rtx dest_reg;
comment|/* register holding destination address */
end_comment

begin_comment
unit|rtx src_reg;
comment|/* register holding source address */
end_comment

begin_comment
unit|int bytes;
comment|/* # bytes to move */
end_comment

begin_comment
unit|int align;
comment|/* max alignment to assume */
end_comment

begin_comment
unit|rtx orig_src;
comment|/* original source for making a reg note */
end_comment

begin_comment
unit|{   int offset		= 0;   rtx prev2_store	= (rtx)0;   rtx prev_store	= (rtx)0;   rtx cur_store		= (rtx)0;    while (bytes> 0)     {
comment|/* Is there a store to do? */
end_comment

begin_comment
unit|if (prev2_store) 	emit_insn (prev2_store);        prev2_store = prev_store;       prev_store = cur_store;       cur_store = block_move_load_store (dest_reg, src_reg,&bytes,&offset, 					 align, orig_src);     }
comment|/* Finish up last three stores.  */
end_comment

begin_endif
unit|if (prev2_store)     emit_insn (prev2_store);    if (prev_store)     emit_insn (prev_store);    if (cur_store)     emit_insn (cur_store); }
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_comment
comment|/* Write a loop to move a constant number of bytes.  Generate load/stores as follows:     do {      temp1 = src[0];      temp2 = src[1];      ...      temp<last> = src[MAX_MOVE_REGS-1];      dest[0] = temp1;      dest[1] = temp2;      ...      dest[MAX_MOVE_REGS-1] = temp<last>;      src += MAX_MOVE_REGS;      dest += MAX_MOVE_REGS;    } while (src != final);     This way, no NOP's are needed, and only MAX_MOVE_REGS+3 temp    registers are needed.     Aligned moves move MAX_MOVE_REGS*4 bytes every (2*MAX_MOVE_REGS)+3    cycles, unaligned moves move MAX_MOVE_REGS*4 bytes every    (4*MAX_MOVE_REGS)+3 cycles, assuming no cache misses.  */
end_comment

begin_define
define|#
directive|define
name|MAX_MOVE_REGS
value|4
end_define

begin_define
define|#
directive|define
name|MAX_MOVE_BYTES
value|(MAX_MOVE_REGS * UNITS_PER_WORD)
end_define

begin_function
specifier|static
name|void
name|block_move_loop
parameter_list|(
name|dest_reg
parameter_list|,
name|src_reg
parameter_list|,
name|bytes
parameter_list|,
name|align
parameter_list|,
name|orig_src
parameter_list|)
name|rtx
name|dest_reg
decl_stmt|;
comment|/* register holding destination address */
name|rtx
name|src_reg
decl_stmt|;
comment|/* register holding source address */
name|int
name|bytes
decl_stmt|;
comment|/* # bytes to move */
name|int
name|align
decl_stmt|;
comment|/* alignment */
name|rtx
name|orig_src
decl_stmt|;
comment|/* original source for making a reg note */
block|{
name|rtx
name|dest_mem
init|=
name|gen_rtx
argument_list|(
name|MEM
argument_list|,
name|BLKmode
argument_list|,
name|dest_reg
argument_list|)
decl_stmt|;
name|rtx
name|src_mem
init|=
name|gen_rtx
argument_list|(
name|MEM
argument_list|,
name|BLKmode
argument_list|,
name|src_reg
argument_list|)
decl_stmt|;
name|rtx
name|align_rtx
init|=
name|GEN_INT
argument_list|(
name|align
argument_list|)
decl_stmt|;
name|rtx
name|label
decl_stmt|;
name|rtx
name|final_src
decl_stmt|;
name|rtx
name|bytes_rtx
decl_stmt|;
name|int
name|leftover
decl_stmt|;
if|if
condition|(
name|bytes
operator|<
literal|2
operator|*
name|MAX_MOVE_BYTES
condition|)
name|abort
argument_list|()
expr_stmt|;
name|leftover
operator|=
name|bytes
operator|%
name|MAX_MOVE_BYTES
expr_stmt|;
name|bytes
operator|-=
name|leftover
expr_stmt|;
name|label
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|final_src
operator|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
name|bytes_rtx
operator|=
name|GEN_INT
argument_list|(
name|bytes
argument_list|)
expr_stmt|;
if|if
condition|(
name|bytes
operator|>
literal|0x7fff
condition|)
block|{
name|emit_insn
argument_list|(
name|gen_movsi
argument_list|(
name|final_src
argument_list|,
name|bytes_rtx
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_addsi3
argument_list|(
name|final_src
argument_list|,
name|final_src
argument_list|,
name|src_reg
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|emit_insn
argument_list|(
name|gen_addsi3
argument_list|(
name|final_src
argument_list|,
name|src_reg
argument_list|,
name|bytes_rtx
argument_list|)
argument_list|)
expr_stmt|;
name|emit_label
argument_list|(
name|label
argument_list|)
expr_stmt|;
name|bytes_rtx
operator|=
name|GEN_INT
argument_list|(
name|MAX_MOVE_BYTES
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_movstrsi_internal
argument_list|(
name|dest_mem
argument_list|,
name|src_mem
argument_list|,
name|bytes_rtx
argument_list|,
name|align_rtx
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_addsi3
argument_list|(
name|src_reg
argument_list|,
name|src_reg
argument_list|,
name|bytes_rtx
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_addsi3
argument_list|(
name|dest_reg
argument_list|,
name|dest_reg
argument_list|,
name|bytes_rtx
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_cmpsi
argument_list|(
name|src_reg
argument_list|,
name|final_src
argument_list|)
argument_list|)
expr_stmt|;
name|emit_jump_insn
argument_list|(
name|gen_bne
argument_list|(
name|label
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|leftover
condition|)
name|emit_insn
argument_list|(
name|gen_movstrsi_internal
argument_list|(
name|dest_mem
argument_list|,
name|src_mem
argument_list|,
name|GEN_INT
argument_list|(
name|leftover
argument_list|)
argument_list|,
name|align_rtx
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Use a library function to move some bytes.  */
end_comment

begin_function
specifier|static
name|void
name|block_move_call
parameter_list|(
name|dest_reg
parameter_list|,
name|src_reg
parameter_list|,
name|bytes_rtx
parameter_list|)
name|rtx
name|dest_reg
decl_stmt|;
name|rtx
name|src_reg
decl_stmt|;
name|rtx
name|bytes_rtx
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|TARGET_MEM_FUNCTIONS
name|emit_library_call
argument_list|(
name|gen_rtx
argument_list|(
name|SYMBOL_REF
argument_list|,
name|Pmode
argument_list|,
literal|"memcpy"
argument_list|)
argument_list|,
literal|0
argument_list|,
name|VOIDmode
argument_list|,
literal|3
argument_list|,
name|dest_reg
argument_list|,
name|Pmode
argument_list|,
name|src_reg
argument_list|,
name|Pmode
argument_list|,
name|bytes_rtx
argument_list|,
name|SImode
argument_list|)
expr_stmt|;
else|#
directive|else
name|emit_library_call
argument_list|(
name|gen_rtx
argument_list|(
name|SYMBOL_REF
argument_list|,
name|Pmode
argument_list|,
literal|"bcopy"
argument_list|)
argument_list|,
literal|0
argument_list|,
name|VOIDmode
argument_list|,
literal|3
argument_list|,
name|src_reg
argument_list|,
name|Pmode
argument_list|,
name|dest_reg
argument_list|,
name|Pmode
argument_list|,
name|bytes_rtx
argument_list|,
name|SImode
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Expand string/block move operations.     operands[0] is the pointer to the destination.    operands[1] is the pointer to the source.    operands[2] is the number of bytes to move.    operands[3] is the alignment.  */
end_comment

begin_function
name|void
name|expand_block_move
parameter_list|(
name|operands
parameter_list|)
name|rtx
name|operands
index|[]
decl_stmt|;
block|{
name|rtx
name|bytes_rtx
init|=
name|operands
index|[
literal|2
index|]
decl_stmt|;
name|rtx
name|align_rtx
init|=
name|operands
index|[
literal|3
index|]
decl_stmt|;
name|int
name|constp
init|=
operator|(
name|GET_CODE
argument_list|(
name|bytes_rtx
argument_list|)
operator|==
name|CONST_INT
operator|)
decl_stmt|;
name|int
name|bytes
init|=
operator|(
name|constp
condition|?
name|INTVAL
argument_list|(
name|bytes_rtx
argument_list|)
else|:
literal|0
operator|)
decl_stmt|;
name|int
name|align
init|=
name|INTVAL
argument_list|(
name|align_rtx
argument_list|)
decl_stmt|;
name|rtx
name|orig_src
init|=
name|operands
index|[
literal|1
index|]
decl_stmt|;
name|rtx
name|src_reg
decl_stmt|;
name|rtx
name|dest_reg
decl_stmt|;
if|if
condition|(
name|constp
operator|&&
name|bytes
operator|<=
literal|0
condition|)
return|return;
if|if
condition|(
name|align
operator|>
name|UNITS_PER_WORD
condition|)
name|align
operator|=
name|UNITS_PER_WORD
expr_stmt|;
comment|/* Move the address into scratch registers.  */
name|dest_reg
operator|=
name|copy_addr_to_reg
argument_list|(
name|XEXP
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|src_reg
operator|=
name|copy_addr_to_reg
argument_list|(
name|XEXP
argument_list|(
name|orig_src
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_MEMCPY
condition|)
name|block_move_call
argument_list|(
name|dest_reg
argument_list|,
name|src_reg
argument_list|,
name|bytes_rtx
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
if|else if (constp&& bytes<= 3*align)     block_move_sequence (dest_reg, src_reg, bytes, align, orig_src);
endif|#
directive|endif
elseif|else
if|if
condition|(
name|constp
operator|&&
name|bytes
operator|<=
literal|2
operator|*
name|MAX_MOVE_BYTES
condition|)
name|emit_insn
argument_list|(
name|gen_movstrsi_internal
argument_list|(
name|gen_rtx
argument_list|(
name|MEM
argument_list|,
name|BLKmode
argument_list|,
name|dest_reg
argument_list|)
argument_list|,
name|gen_rtx
argument_list|(
name|MEM
argument_list|,
name|BLKmode
argument_list|,
name|src_reg
argument_list|)
argument_list|,
name|bytes_rtx
argument_list|,
name|align_rtx
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|constp
operator|&&
name|align
operator|>=
name|UNITS_PER_WORD
operator|&&
name|optimize
condition|)
name|block_move_loop
argument_list|(
name|dest_reg
argument_list|,
name|src_reg
argument_list|,
name|bytes
argument_list|,
name|align
argument_list|,
name|orig_src
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|constp
operator|&&
name|optimize
condition|)
block|{
comment|/* If the alignment is not word aligned, generate a test at 	 runtime, to see whether things wound up aligned, and we 	 can use the faster lw/sw instead ulw/usw.  */
name|rtx
name|temp
init|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
decl_stmt|;
name|rtx
name|aligned_label
init|=
name|gen_label_rtx
argument_list|()
decl_stmt|;
name|rtx
name|join_label
init|=
name|gen_label_rtx
argument_list|()
decl_stmt|;
name|int
name|leftover
init|=
name|bytes
operator|%
name|MAX_MOVE_BYTES
decl_stmt|;
name|bytes
operator|-=
name|leftover
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_iorsi3
argument_list|(
name|temp
argument_list|,
name|src_reg
argument_list|,
name|dest_reg
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_andsi3
argument_list|(
name|temp
argument_list|,
name|temp
argument_list|,
name|GEN_INT
argument_list|(
name|UNITS_PER_WORD
operator|-
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_cmpsi
argument_list|(
name|temp
argument_list|,
name|const0_rtx
argument_list|)
argument_list|)
expr_stmt|;
name|emit_jump_insn
argument_list|(
name|gen_beq
argument_list|(
name|aligned_label
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Unaligned loop.  */
name|block_move_loop
argument_list|(
name|dest_reg
argument_list|,
name|src_reg
argument_list|,
name|bytes
argument_list|,
literal|1
argument_list|,
name|orig_src
argument_list|)
expr_stmt|;
name|emit_jump_insn
argument_list|(
name|gen_jump
argument_list|(
name|join_label
argument_list|)
argument_list|)
expr_stmt|;
name|emit_barrier
argument_list|()
expr_stmt|;
comment|/* Aligned loop.  */
name|emit_label
argument_list|(
name|aligned_label
argument_list|)
expr_stmt|;
name|block_move_loop
argument_list|(
name|dest_reg
argument_list|,
name|src_reg
argument_list|,
name|bytes
argument_list|,
name|UNITS_PER_WORD
argument_list|,
name|orig_src
argument_list|)
expr_stmt|;
name|emit_label
argument_list|(
name|join_label
argument_list|)
expr_stmt|;
comment|/* Bytes at the end of the loop.  */
if|if
condition|(
name|leftover
condition|)
block|{
if|#
directive|if
literal|0
block|if (leftover<= 3*align) 	    block_move_sequence (dest_reg, src_reg, leftover, align, orig_src);  	  else
endif|#
directive|endif
name|emit_insn
argument_list|(
name|gen_movstrsi_internal
argument_list|(
name|gen_rtx
argument_list|(
name|MEM
argument_list|,
name|BLKmode
argument_list|,
name|dest_reg
argument_list|)
argument_list|,
name|gen_rtx
argument_list|(
name|MEM
argument_list|,
name|BLKmode
argument_list|,
name|src_reg
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
name|leftover
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
name|align
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|block_move_call
argument_list|(
name|dest_reg
argument_list|,
name|src_reg
argument_list|,
name|bytes_rtx
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Emit load/stores for a small constant block_move.      operands[0] is the memory address of the destination.    operands[1] is the memory address of the source.    operands[2] is the number of bytes to move.    operands[3] is the alignment.    operands[4] is a temp register.    operands[5] is a temp register.    ...    operands[3+num_regs] is the last temp register.     The block move type can be one of the following: 	BLOCK_MOVE_NORMAL	Do all of the block move. 	BLOCK_MOVE_NOT_LAST	Do all but the last store. 	BLOCK_MOVE_LAST		Do just the last store. */
end_comment

begin_function
name|char
modifier|*
name|output_block_move
parameter_list|(
name|insn
parameter_list|,
name|operands
parameter_list|,
name|num_regs
parameter_list|,
name|move_type
parameter_list|)
name|rtx
name|insn
decl_stmt|;
name|rtx
name|operands
index|[]
decl_stmt|;
name|int
name|num_regs
decl_stmt|;
name|enum
name|block_move_type
name|move_type
decl_stmt|;
block|{
name|rtx
name|dest_reg
init|=
name|XEXP
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|rtx
name|src_reg
init|=
name|XEXP
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|int
name|bytes
init|=
name|INTVAL
argument_list|(
name|operands
index|[
literal|2
index|]
argument_list|)
decl_stmt|;
name|int
name|align
init|=
name|INTVAL
argument_list|(
name|operands
index|[
literal|3
index|]
argument_list|)
decl_stmt|;
name|int
name|num
init|=
literal|0
decl_stmt|;
name|int
name|offset
init|=
literal|0
decl_stmt|;
name|int
name|use_lwl_lwr
init|=
name|FALSE
decl_stmt|;
name|int
name|last_operand
init|=
name|num_regs
operator|+
literal|4
decl_stmt|;
name|int
name|i
decl_stmt|;
name|rtx
name|xoperands
index|[
literal|10
index|]
decl_stmt|;
struct|struct
block|{
name|char
modifier|*
name|load
decl_stmt|;
comment|/* load insn without nop */
name|char
modifier|*
name|load_nop
decl_stmt|;
comment|/* load insn with trailing nop */
name|char
modifier|*
name|store
decl_stmt|;
comment|/* store insn */
name|char
modifier|*
name|final
decl_stmt|;
comment|/* if last_store used: NULL or swr */
name|char
modifier|*
name|last_store
decl_stmt|;
comment|/* last store instruction */
name|int
name|offset
decl_stmt|;
comment|/* current offset */
name|enum
name|machine_mode
name|mode
decl_stmt|;
comment|/* mode to use on (MEM) */
block|}
name|load_store
index|[
literal|4
index|]
struct|;
comment|/* Detect a bug in GCC, where it can give us a register      the same as one of the addressing registers.  */
for|for
control|(
name|i
operator|=
literal|4
init|;
name|i
operator|<
name|last_operand
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|reg_mentioned_p
argument_list|(
name|operands
index|[
name|i
index|]
argument_list|,
name|operands
index|[
literal|0
index|]
argument_list|)
operator|||
name|reg_mentioned_p
argument_list|(
name|operands
index|[
name|i
index|]
argument_list|,
name|operands
index|[
literal|1
index|]
argument_list|)
condition|)
block|{
name|abort_with_insn
argument_list|(
name|insn
argument_list|,
literal|"register passed as address and temp register to block move"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* If we are given global or static addresses, and we would be      emitting a few instructions, try to save time by using a      temporary register for the pointer.  */
if|if
condition|(
name|bytes
operator|>
literal|2
operator|*
name|align
operator|||
name|move_type
operator|!=
name|BLOCK_MOVE_NORMAL
condition|)
block|{
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|src_reg
argument_list|)
condition|)
block|{
if|if
condition|(
name|TARGET_STATS
condition|)
name|mips_count_memory_refs
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|src_reg
operator|=
name|operands
index|[
literal|3
operator|+
name|num_regs
operator|--
index|]
expr_stmt|;
if|if
condition|(
name|move_type
operator|!=
name|BLOCK_MOVE_LAST
condition|)
block|{
name|xoperands
index|[
literal|1
index|]
operator|=
name|operands
index|[
literal|1
index|]
expr_stmt|;
name|xoperands
index|[
literal|0
index|]
operator|=
name|src_reg
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"la\t%0,%1"
argument_list|,
name|xoperands
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|dest_reg
argument_list|)
condition|)
block|{
if|if
condition|(
name|TARGET_STATS
condition|)
name|mips_count_memory_refs
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|dest_reg
operator|=
name|operands
index|[
literal|3
operator|+
name|num_regs
operator|--
index|]
expr_stmt|;
if|if
condition|(
name|move_type
operator|!=
name|BLOCK_MOVE_LAST
condition|)
block|{
name|xoperands
index|[
literal|1
index|]
operator|=
name|operands
index|[
literal|0
index|]
expr_stmt|;
name|xoperands
index|[
literal|0
index|]
operator|=
name|dest_reg
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"la\t%0,%1"
argument_list|,
name|xoperands
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|num_regs
operator|>
operator|(
sizeof|sizeof
argument_list|(
name|load_store
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|load_store
index|[
literal|0
index|]
argument_list|)
operator|)
condition|)
name|num_regs
operator|=
operator|(
sizeof|sizeof
argument_list|(
name|load_store
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|load_store
index|[
literal|0
index|]
argument_list|)
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
name|num_regs
operator|<
literal|1
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|TARGET_GAS
operator|&&
name|move_type
operator|!=
name|BLOCK_MOVE_LAST
operator|&&
name|set_noreorder
operator|++
operator|==
literal|0
condition|)
name|output_asm_insn
argument_list|(
literal|".set\tnoreorder"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
while|while
condition|(
name|bytes
operator|>
literal|0
condition|)
block|{
name|load_store
index|[
name|num
index|]
operator|.
name|offset
operator|=
name|offset
expr_stmt|;
if|if
condition|(
name|bytes
operator|>=
name|UNITS_PER_WORD
operator|&&
name|align
operator|>=
name|UNITS_PER_WORD
condition|)
block|{
name|load_store
index|[
name|num
index|]
operator|.
name|load
operator|=
literal|"lw\t%0,%1"
expr_stmt|;
name|load_store
index|[
name|num
index|]
operator|.
name|load_nop
operator|=
literal|"lw\t%0,%1%#"
expr_stmt|;
name|load_store
index|[
name|num
index|]
operator|.
name|store
operator|=
literal|"sw\t%0,%1"
expr_stmt|;
name|load_store
index|[
name|num
index|]
operator|.
name|last_store
operator|=
literal|"sw\t%0,%1"
expr_stmt|;
name|load_store
index|[
name|num
index|]
operator|.
name|final
operator|=
operator|(
name|char
operator|*
operator|)
literal|0
expr_stmt|;
name|load_store
index|[
name|num
index|]
operator|.
name|mode
operator|=
name|SImode
expr_stmt|;
name|offset
operator|+=
name|UNITS_PER_WORD
expr_stmt|;
name|bytes
operator|-=
name|UNITS_PER_WORD
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bytes
operator|>=
name|UNITS_PER_WORD
condition|)
block|{
if|#
directive|if
name|BYTES_BIG_ENDIAN
name|load_store
index|[
name|num
index|]
operator|.
name|load
operator|=
literal|"lwl\t%0,%1\n\tlwr\t%0,%2"
expr_stmt|;
name|load_store
index|[
name|num
index|]
operator|.
name|load_nop
operator|=
literal|"lwl\t%0,%1\n\tlwr\t%0,%2%#"
expr_stmt|;
name|load_store
index|[
name|num
index|]
operator|.
name|store
operator|=
literal|"swl\t%0,%1\n\tswr\t%0,%2"
expr_stmt|;
name|load_store
index|[
name|num
index|]
operator|.
name|last_store
operator|=
literal|"swr\t%0,%2"
expr_stmt|;
name|load_store
index|[
name|num
index|]
operator|.
name|final
operator|=
literal|"swl\t%0,%1"
expr_stmt|;
else|#
directive|else
name|load_store
index|[
name|num
index|]
operator|.
name|load
operator|=
literal|"lwl\t%0,%2\n\tlwr\t%0,%1"
expr_stmt|;
name|load_store
index|[
name|num
index|]
operator|.
name|load_nop
operator|=
literal|"lwl\t%0,%2\n\tlwr\t%0,%1%#"
expr_stmt|;
name|load_store
index|[
name|num
index|]
operator|.
name|store
operator|=
literal|"swl\t%0,%2\n\tswr\t%0,%1"
expr_stmt|;
name|load_store
index|[
name|num
index|]
operator|.
name|last_store
operator|=
literal|"swr\t%0,%1"
expr_stmt|;
name|load_store
index|[
name|num
index|]
operator|.
name|final
operator|=
literal|"swl\t%0,%2"
expr_stmt|;
endif|#
directive|endif
name|load_store
index|[
name|num
index|]
operator|.
name|mode
operator|=
name|SImode
expr_stmt|;
name|offset
operator|+=
name|UNITS_PER_WORD
expr_stmt|;
name|bytes
operator|-=
name|UNITS_PER_WORD
expr_stmt|;
name|use_lwl_lwr
operator|=
name|TRUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bytes
operator|>=
name|UNITS_PER_SHORT
operator|&&
name|align
operator|>=
name|UNITS_PER_SHORT
condition|)
block|{
name|load_store
index|[
name|num
index|]
operator|.
name|load
operator|=
literal|"lh\t%0,%1"
expr_stmt|;
name|load_store
index|[
name|num
index|]
operator|.
name|load_nop
operator|=
literal|"lh\t%0,%1%#"
expr_stmt|;
name|load_store
index|[
name|num
index|]
operator|.
name|store
operator|=
literal|"sh\t%0,%1"
expr_stmt|;
name|load_store
index|[
name|num
index|]
operator|.
name|last_store
operator|=
literal|"sh\t%0,%1"
expr_stmt|;
name|load_store
index|[
name|num
index|]
operator|.
name|final
operator|=
operator|(
name|char
operator|*
operator|)
literal|0
expr_stmt|;
name|load_store
index|[
name|num
index|]
operator|.
name|offset
operator|=
name|offset
expr_stmt|;
name|load_store
index|[
name|num
index|]
operator|.
name|mode
operator|=
name|HImode
expr_stmt|;
name|offset
operator|+=
name|UNITS_PER_SHORT
expr_stmt|;
name|bytes
operator|-=
name|UNITS_PER_SHORT
expr_stmt|;
block|}
else|else
block|{
name|load_store
index|[
name|num
index|]
operator|.
name|load
operator|=
literal|"lb\t%0,%1"
expr_stmt|;
name|load_store
index|[
name|num
index|]
operator|.
name|load_nop
operator|=
literal|"lb\t%0,%1%#"
expr_stmt|;
name|load_store
index|[
name|num
index|]
operator|.
name|store
operator|=
literal|"sb\t%0,%1"
expr_stmt|;
name|load_store
index|[
name|num
index|]
operator|.
name|last_store
operator|=
literal|"sb\t%0,%1"
expr_stmt|;
name|load_store
index|[
name|num
index|]
operator|.
name|final
operator|=
operator|(
name|char
operator|*
operator|)
literal|0
expr_stmt|;
name|load_store
index|[
name|num
index|]
operator|.
name|mode
operator|=
name|QImode
expr_stmt|;
name|offset
operator|++
expr_stmt|;
name|bytes
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|TARGET_STATS
operator|&&
name|move_type
operator|!=
name|BLOCK_MOVE_LAST
condition|)
block|{
name|dslots_load_total
operator|++
expr_stmt|;
name|dslots_load_filled
operator|++
expr_stmt|;
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|src_reg
argument_list|)
condition|)
name|mips_count_memory_refs
argument_list|(
name|src_reg
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|dest_reg
argument_list|)
condition|)
name|mips_count_memory_refs
argument_list|(
name|dest_reg
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Emit load/stores now if we have run out of registers or are 	 at the end of the move.  */
if|if
condition|(
operator|++
name|num
operator|==
name|num_regs
operator|||
name|bytes
operator|==
literal|0
condition|)
block|{
comment|/* If only load/store, we need a NOP after the load.  */
if|if
condition|(
name|num
operator|==
literal|1
condition|)
block|{
name|load_store
index|[
literal|0
index|]
operator|.
name|load
operator|=
name|load_store
index|[
literal|0
index|]
operator|.
name|load_nop
expr_stmt|;
if|if
condition|(
name|TARGET_STATS
operator|&&
name|move_type
operator|!=
name|BLOCK_MOVE_LAST
condition|)
name|dslots_load_filled
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|move_type
operator|!=
name|BLOCK_MOVE_LAST
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num
condition|;
name|i
operator|++
control|)
block|{
name|int
name|offset
decl_stmt|;
if|if
condition|(
operator|!
name|operands
index|[
name|i
operator|+
literal|4
index|]
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|operands
index|[
name|i
operator|+
literal|4
index|]
argument_list|)
operator|!=
name|load_store
index|[
name|i
index|]
operator|.
name|mode
condition|)
name|operands
index|[
name|i
operator|+
literal|4
index|]
operator|=
name|gen_rtx
argument_list|(
name|REG
argument_list|,
name|load_store
index|[
name|i
index|]
operator|.
name|mode
argument_list|,
name|REGNO
argument_list|(
name|operands
index|[
name|i
operator|+
literal|4
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|offset
operator|=
name|load_store
index|[
name|i
index|]
operator|.
name|offset
expr_stmt|;
name|xoperands
index|[
literal|0
index|]
operator|=
name|operands
index|[
name|i
operator|+
literal|4
index|]
expr_stmt|;
name|xoperands
index|[
literal|1
index|]
operator|=
name|gen_rtx
argument_list|(
name|MEM
argument_list|,
name|load_store
index|[
name|i
index|]
operator|.
name|mode
argument_list|,
name|plus_constant
argument_list|(
name|src_reg
argument_list|,
name|offset
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|use_lwl_lwr
condition|)
name|xoperands
index|[
literal|2
index|]
operator|=
name|gen_rtx
argument_list|(
name|MEM
argument_list|,
name|load_store
index|[
name|i
index|]
operator|.
name|mode
argument_list|,
name|plus_constant
argument_list|(
name|src_reg
argument_list|,
name|UNITS_PER_WORD
operator|-
literal|1
operator|+
name|offset
argument_list|)
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
name|load_store
index|[
name|i
index|]
operator|.
name|load
argument_list|,
name|xoperands
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num
condition|;
name|i
operator|++
control|)
block|{
name|int
name|last_p
init|=
operator|(
name|i
operator|==
name|num
operator|-
literal|1
operator|&&
name|bytes
operator|==
literal|0
operator|)
decl_stmt|;
name|int
name|offset
init|=
name|load_store
index|[
name|i
index|]
operator|.
name|offset
decl_stmt|;
name|xoperands
index|[
literal|0
index|]
operator|=
name|operands
index|[
name|i
operator|+
literal|4
index|]
expr_stmt|;
name|xoperands
index|[
literal|1
index|]
operator|=
name|gen_rtx
argument_list|(
name|MEM
argument_list|,
name|load_store
index|[
name|i
index|]
operator|.
name|mode
argument_list|,
name|plus_constant
argument_list|(
name|dest_reg
argument_list|,
name|offset
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|use_lwl_lwr
condition|)
name|xoperands
index|[
literal|2
index|]
operator|=
name|gen_rtx
argument_list|(
name|MEM
argument_list|,
name|load_store
index|[
name|i
index|]
operator|.
name|mode
argument_list|,
name|plus_constant
argument_list|(
name|dest_reg
argument_list|,
name|UNITS_PER_WORD
operator|-
literal|1
operator|+
name|offset
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|move_type
operator|==
name|BLOCK_MOVE_NORMAL
condition|)
name|output_asm_insn
argument_list|(
name|load_store
index|[
name|i
index|]
operator|.
name|store
argument_list|,
name|xoperands
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|move_type
operator|==
name|BLOCK_MOVE_NOT_LAST
condition|)
block|{
if|if
condition|(
operator|!
name|last_p
condition|)
name|output_asm_insn
argument_list|(
name|load_store
index|[
name|i
index|]
operator|.
name|store
argument_list|,
name|xoperands
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|load_store
index|[
name|i
index|]
operator|.
name|final
operator|!=
operator|(
name|char
operator|*
operator|)
literal|0
condition|)
name|output_asm_insn
argument_list|(
name|load_store
index|[
name|i
index|]
operator|.
name|final
argument_list|,
name|xoperands
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|last_p
condition|)
name|output_asm_insn
argument_list|(
name|load_store
index|[
name|i
index|]
operator|.
name|last_store
argument_list|,
name|xoperands
argument_list|)
expr_stmt|;
block|}
name|num
operator|=
literal|0
expr_stmt|;
comment|/* reset load_store */
name|use_lwl_lwr
operator|=
name|FALSE
expr_stmt|;
comment|/* reset whether or not we used lwl/lwr */
block|}
block|}
if|if
condition|(
name|TARGET_GAS
operator|&&
name|move_type
operator|!=
name|BLOCK_MOVE_LAST
operator|&&
operator|--
name|set_noreorder
operator|==
literal|0
condition|)
name|output_asm_insn
argument_list|(
literal|".set\treorder"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
return|return
literal|""
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Argument support functions.  */
end_comment

begin_comment
comment|/* Initialize CUMULATIVE_ARGS for a function.  */
end_comment

begin_function
name|void
name|init_cumulative_args
parameter_list|(
name|cum
parameter_list|,
name|fntype
parameter_list|,
name|libname
parameter_list|)
name|CUMULATIVE_ARGS
modifier|*
name|cum
decl_stmt|;
comment|/* argument info to initialize */
name|tree
name|fntype
decl_stmt|;
comment|/* tree ptr for function decl */
name|rtx
name|libname
decl_stmt|;
comment|/* SYMBOL_REF of library name or 0 */
block|{
specifier|static
name|CUMULATIVE_ARGS
name|zero_cum
decl_stmt|;
name|tree
name|param
decl_stmt|,
name|next_param
decl_stmt|;
if|if
condition|(
name|TARGET_DEBUG_E_MODE
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\ninit_cumulative_args, fntype = 0x%.8lx"
argument_list|,
operator|(
name|long
operator|)
name|fntype
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fntype
condition|)
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
else|else
block|{
name|tree
name|ret_type
init|=
name|TREE_TYPE
argument_list|(
name|fntype
argument_list|)
decl_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|", fntype code = %s, ret code = %s\n"
argument_list|,
name|tree_code_name
index|[
operator|(
name|int
operator|)
name|TREE_CODE
argument_list|(
name|fntype
argument_list|)
index|]
argument_list|,
name|tree_code_name
index|[
operator|(
name|int
operator|)
name|TREE_CODE
argument_list|(
name|ret_type
argument_list|)
index|]
argument_list|)
expr_stmt|;
block|}
block|}
operator|*
name|cum
operator|=
name|zero_cum
expr_stmt|;
comment|/* Determine if this function has variable arguments.  This is      indicated by the last argument being 'void_type_mode' if there      are no variable arguments.  The standard MIPS calling sequence      passes all arguments in the general purpose registers in this      case. */
for|for
control|(
name|param
operator|=
operator|(
name|fntype
operator|)
condition|?
name|TYPE_ARG_TYPES
argument_list|(
name|fntype
argument_list|)
else|:
literal|0
init|;
name|param
operator|!=
operator|(
name|tree
operator|)
literal|0
condition|;
name|param
operator|=
name|next_param
control|)
block|{
name|next_param
operator|=
name|TREE_CHAIN
argument_list|(
name|param
argument_list|)
expr_stmt|;
if|if
condition|(
name|next_param
operator|==
operator|(
name|tree
operator|)
literal|0
operator|&&
name|TREE_VALUE
argument_list|(
name|param
argument_list|)
operator|!=
name|void_type_node
condition|)
name|cum
operator|->
name|gp_reg_found
operator|=
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Advance the argument to the next argument position.  */
end_comment

begin_function
name|void
name|function_arg_advance
parameter_list|(
name|cum
parameter_list|,
name|mode
parameter_list|,
name|type
parameter_list|,
name|named
parameter_list|)
name|CUMULATIVE_ARGS
modifier|*
name|cum
decl_stmt|;
comment|/* current arg information */
name|enum
name|machine_mode
name|mode
decl_stmt|;
comment|/* current arg mode */
name|tree
name|type
decl_stmt|;
comment|/* type of the argument or 0 if lib support */
name|int
name|named
decl_stmt|;
comment|/* whether or not the argument was named */
block|{
if|if
condition|(
name|TARGET_DEBUG_E_MODE
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"function_adv( {gp reg found = %d, arg # = %2d, words = %2d}, %4s, 0x%.8x, %d )\n\n"
argument_list|,
name|cum
operator|->
name|gp_reg_found
argument_list|,
name|cum
operator|->
name|arg_number
argument_list|,
name|cum
operator|->
name|arg_words
argument_list|,
name|GET_MODE_NAME
argument_list|(
name|mode
argument_list|)
argument_list|,
name|type
argument_list|,
name|named
argument_list|)
expr_stmt|;
name|cum
operator|->
name|arg_number
operator|++
expr_stmt|;
switch|switch
condition|(
name|mode
condition|)
block|{
default|default:
name|error
argument_list|(
literal|"Illegal mode given to function_arg_advance"
argument_list|)
expr_stmt|;
break|break;
case|case
name|VOIDmode
case|:
break|break;
case|case
name|BLKmode
case|:
name|cum
operator|->
name|gp_reg_found
operator|=
literal|1
expr_stmt|;
name|cum
operator|->
name|arg_words
operator|+=
operator|(
name|int_size_in_bytes
argument_list|(
name|type
argument_list|)
operator|+
literal|3
operator|)
operator|/
literal|4
expr_stmt|;
break|break;
case|case
name|SFmode
case|:
name|cum
operator|->
name|arg_words
operator|++
expr_stmt|;
break|break;
case|case
name|DFmode
case|:
name|cum
operator|->
name|arg_words
operator|+=
literal|2
expr_stmt|;
break|break;
case|case
name|DImode
case|:
name|cum
operator|->
name|gp_reg_found
operator|=
literal|1
expr_stmt|;
name|cum
operator|->
name|arg_words
operator|+=
literal|2
expr_stmt|;
break|break;
case|case
name|QImode
case|:
case|case
name|HImode
case|:
case|case
name|SImode
case|:
name|cum
operator|->
name|gp_reg_found
operator|=
literal|1
expr_stmt|;
name|cum
operator|->
name|arg_words
operator|++
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/* Return a RTL expression containing the register for the given mode,    or 0 if the argument is too be passed on the stack.  */
end_comment

begin_function
name|struct
name|rtx_def
modifier|*
name|function_arg
parameter_list|(
name|cum
parameter_list|,
name|mode
parameter_list|,
name|type
parameter_list|,
name|named
parameter_list|)
name|CUMULATIVE_ARGS
modifier|*
name|cum
decl_stmt|;
comment|/* current arg information */
name|enum
name|machine_mode
name|mode
decl_stmt|;
comment|/* current arg mode */
name|tree
name|type
decl_stmt|;
comment|/* type of the argument or 0 if lib support */
name|int
name|named
decl_stmt|;
comment|/* != 0 for normal args, == 0 for ... args */
block|{
name|rtx
name|ret
decl_stmt|;
name|int
name|regbase
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|bias
init|=
literal|0
decl_stmt|;
name|int
name|struct_p
init|=
operator|(
operator|(
name|type
operator|!=
operator|(
name|tree
operator|)
literal|0
operator|)
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|RECORD_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|UNION_TYPE
operator|)
operator|)
decl_stmt|;
if|if
condition|(
name|TARGET_DEBUG_E_MODE
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"function_arg( {gp reg found = %d, arg # = %2d, words = %2d}, %4s, 0x%.8x, %d ) = "
argument_list|,
name|cum
operator|->
name|gp_reg_found
argument_list|,
name|cum
operator|->
name|arg_number
argument_list|,
name|cum
operator|->
name|arg_words
argument_list|,
name|GET_MODE_NAME
argument_list|(
name|mode
argument_list|)
argument_list|,
name|type
argument_list|,
name|named
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|mode
condition|)
block|{
default|default:
name|error
argument_list|(
literal|"Illegal mode given to function_arg"
argument_list|)
expr_stmt|;
break|break;
case|case
name|SFmode
case|:
if|if
condition|(
name|cum
operator|->
name|gp_reg_found
operator|||
name|cum
operator|->
name|arg_number
operator|>=
literal|2
condition|)
name|regbase
operator|=
name|GP_ARG_FIRST
expr_stmt|;
else|else
block|{
name|regbase
operator|=
operator|(
name|TARGET_SOFT_FLOAT
operator|)
condition|?
name|GP_ARG_FIRST
else|:
name|FP_ARG_FIRST
expr_stmt|;
if|if
condition|(
name|cum
operator|->
name|arg_words
operator|==
literal|1
condition|)
comment|/* first arg was float */
name|bias
operator|=
literal|1
expr_stmt|;
comment|/* use correct reg */
block|}
break|break;
case|case
name|DFmode
case|:
name|cum
operator|->
name|arg_words
operator|+=
operator|(
name|cum
operator|->
name|arg_words
operator|&
literal|1
operator|)
expr_stmt|;
name|regbase
operator|=
operator|(
name|cum
operator|->
name|gp_reg_found
operator|||
name|TARGET_SOFT_FLOAT
operator|)
condition|?
name|GP_ARG_FIRST
else|:
name|FP_ARG_FIRST
expr_stmt|;
break|break;
case|case
name|BLKmode
case|:
if|if
condition|(
name|type
operator|!=
operator|(
name|tree
operator|)
literal|0
operator|&&
name|TYPE_ALIGN
argument_list|(
name|type
argument_list|)
operator|>
name|BITS_PER_WORD
condition|)
name|cum
operator|->
name|arg_words
operator|+=
operator|(
name|cum
operator|->
name|arg_words
operator|&
literal|1
operator|)
expr_stmt|;
name|regbase
operator|=
name|GP_ARG_FIRST
expr_stmt|;
break|break;
case|case
name|VOIDmode
case|:
case|case
name|QImode
case|:
case|case
name|HImode
case|:
case|case
name|SImode
case|:
name|regbase
operator|=
name|GP_ARG_FIRST
expr_stmt|;
break|break;
case|case
name|DImode
case|:
name|cum
operator|->
name|arg_words
operator|+=
operator|(
name|cum
operator|->
name|arg_words
operator|&
literal|1
operator|)
expr_stmt|;
name|regbase
operator|=
name|GP_ARG_FIRST
expr_stmt|;
block|}
if|if
condition|(
name|cum
operator|->
name|arg_words
operator|>=
name|MAX_ARGS_IN_REGISTERS
condition|)
block|{
if|if
condition|(
name|TARGET_DEBUG_E_MODE
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"<stack>%s\n"
argument_list|,
name|struct_p
condition|?
literal|", [struct]"
else|:
literal|""
argument_list|)
expr_stmt|;
name|ret
operator|=
operator|(
name|rtx
operator|)
literal|0
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|regbase
operator|==
operator|-
literal|1
condition|)
name|abort
argument_list|()
expr_stmt|;
name|ret
operator|=
name|gen_rtx
argument_list|(
name|REG
argument_list|,
name|mode
argument_list|,
name|regbase
operator|+
name|cum
operator|->
name|arg_words
operator|+
name|bias
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_DEBUG_E_MODE
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s%s\n"
argument_list|,
name|reg_names
index|[
name|regbase
operator|+
name|cum
operator|->
name|arg_words
operator|+
name|bias
index|]
argument_list|,
name|struct_p
condition|?
literal|", [struct]"
else|:
literal|""
argument_list|)
expr_stmt|;
comment|/* The following is a hack in order to pass 1 byte structures 	 the same way that the MIPS compiler does (namely by passing 	 the structure in the high byte or half word of the register). 	 This also makes varargs work.  If we have such a structure, 	 we save the adjustment RTL, and the call define expands will 	 emit them.  For the VOIDmode argument (argument after the 	 last real argument, pass back a parallel vector holding each 	 of the adjustments.  */
if|if
condition|(
name|struct_p
operator|&&
operator|(
name|mode
operator|==
name|QImode
operator|||
name|mode
operator|==
name|HImode
operator|)
condition|)
block|{
name|rtx
name|amount
init|=
name|GEN_INT
argument_list|(
name|BITS_PER_WORD
operator|-
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
argument_list|)
decl_stmt|;
name|rtx
name|reg
init|=
name|gen_rtx
argument_list|(
name|REG
argument_list|,
name|SImode
argument_list|,
name|regbase
operator|+
name|cum
operator|->
name|arg_words
operator|+
name|bias
argument_list|)
decl_stmt|;
name|cum
operator|->
name|adjust
index|[
name|cum
operator|->
name|num_adjusts
operator|++
index|]
operator|=
name|gen_ashlsi3
argument_list|(
name|reg
argument_list|,
name|reg
argument_list|,
name|amount
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|mode
operator|==
name|VOIDmode
operator|&&
name|cum
operator|->
name|num_adjusts
operator|>
literal|0
condition|)
name|ret
operator|=
name|gen_rtx
argument_list|(
name|PARALLEL
argument_list|,
name|VOIDmode
argument_list|,
name|gen_rtvec_v
argument_list|(
name|cum
operator|->
name|num_adjusts
argument_list|,
name|cum
operator|->
name|adjust
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
name|int
name|function_arg_partial_nregs
parameter_list|(
name|cum
parameter_list|,
name|mode
parameter_list|,
name|type
parameter_list|,
name|named
parameter_list|)
name|CUMULATIVE_ARGS
modifier|*
name|cum
decl_stmt|;
comment|/* current arg information */
name|enum
name|machine_mode
name|mode
decl_stmt|;
comment|/* current arg mode */
name|tree
name|type
decl_stmt|;
comment|/* type of the argument or 0 if lib support */
name|int
name|named
decl_stmt|;
comment|/* != 0 for normal args, == 0 for ... args */
block|{
if|if
condition|(
name|mode
operator|==
name|BLKmode
operator|&&
name|cum
operator|->
name|arg_words
operator|<
name|MAX_ARGS_IN_REGISTERS
condition|)
block|{
name|int
name|words
init|=
operator|(
name|int_size_in_bytes
argument_list|(
name|type
argument_list|)
operator|+
literal|3
operator|)
operator|/
literal|4
decl_stmt|;
if|if
condition|(
name|words
operator|+
name|cum
operator|->
name|arg_words
operator|<
name|MAX_ARGS_IN_REGISTERS
condition|)
return|return
literal|0
return|;
comment|/* structure fits in registers */
if|if
condition|(
name|TARGET_DEBUG_E_MODE
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"function_arg_partial_nregs = %d\n"
argument_list|,
name|MAX_ARGS_IN_REGISTERS
operator|-
name|cum
operator|->
name|arg_words
argument_list|)
expr_stmt|;
return|return
name|MAX_ARGS_IN_REGISTERS
operator|-
name|cum
operator|->
name|arg_words
return|;
block|}
elseif|else
if|if
condition|(
name|mode
operator|==
name|DImode
operator|&&
name|cum
operator|->
name|arg_words
operator|==
name|MAX_ARGS_IN_REGISTERS
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|TARGET_DEBUG_E_MODE
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"function_arg_partial_nregs = 1\n"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Print the options used in the assembly file.  */
end_comment

begin_struct
specifier|static
struct|struct
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|value
decl_stmt|;
block|}
name|target_switches
index|[]
init|=
name|TARGET_SWITCHES
struct|;
end_struct

begin_function
name|void
name|print_options
parameter_list|(
name|out
parameter_list|)
name|FILE
modifier|*
name|out
decl_stmt|;
block|{
name|int
name|line_len
decl_stmt|;
name|int
name|len
decl_stmt|;
name|int
name|j
decl_stmt|;
name|char
modifier|*
modifier|*
name|p
decl_stmt|;
name|int
name|mask
init|=
name|TARGET_DEFAULT
decl_stmt|;
comment|/* Allow assembly language comparisons with -mdebug eliminating the      compiler version number and switch lists.  */
if|if
condition|(
name|TARGET_DEBUG_MODE
condition|)
return|return;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"\n # %s %s"
argument_list|,
name|language_string
argument_list|,
name|version_string
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|TARGET_VERSION_INTERNAL
name|TARGET_VERSION_INTERNAL
argument_list|(
name|out
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|__GNUC__
name|fprintf
argument_list|(
name|out
argument_list|,
literal|" compiled by GNU C\n\n"
argument_list|)
expr_stmt|;
else|#
directive|else
name|fprintf
argument_list|(
name|out
argument_list|,
literal|" compiled by CC\n\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|fprintf
argument_list|(
name|out
argument_list|,
literal|" # Cc1 defaults:"
argument_list|)
expr_stmt|;
name|line_len
operator|=
literal|32767
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
sizeof|sizeof
name|target_switches
operator|/
sizeof|sizeof
name|target_switches
index|[
literal|0
index|]
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|target_switches
index|[
name|j
index|]
operator|.
name|name
index|[
literal|0
index|]
operator|!=
literal|'\0'
operator|&&
name|target_switches
index|[
name|j
index|]
operator|.
name|value
operator|>
literal|0
operator|&&
operator|(
name|target_switches
index|[
name|j
index|]
operator|.
name|value
operator|&
name|mask
operator|)
operator|==
name|target_switches
index|[
name|j
index|]
operator|.
name|value
condition|)
block|{
name|mask
operator|&=
operator|~
name|target_switches
index|[
name|j
index|]
operator|.
name|value
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|target_switches
index|[
name|j
index|]
operator|.
name|name
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|len
operator|+
name|line_len
operator|>
literal|79
condition|)
block|{
name|line_len
operator|=
literal|2
expr_stmt|;
name|fputs
argument_list|(
literal|"\n #"
argument_list|,
name|out
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|out
argument_list|,
literal|" -m%s"
argument_list|,
name|target_switches
index|[
name|j
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
name|line_len
operator|+=
name|len
expr_stmt|;
block|}
block|}
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"\n\n # Cc1 arguments (-G value = %d, Cpu = %s, ISA = %d):"
argument_list|,
name|mips_section_threshold
argument_list|,
name|mips_cpu_string
argument_list|,
name|mips_isa
argument_list|)
expr_stmt|;
name|line_len
operator|=
literal|32767
expr_stmt|;
for|for
control|(
name|p
operator|=
operator|&
name|save_argv
index|[
literal|1
index|]
init|;
operator|*
name|p
operator|!=
operator|(
name|char
operator|*
operator|)
literal|0
condition|;
name|p
operator|++
control|)
block|{
name|char
modifier|*
name|arg
init|=
operator|*
name|p
decl_stmt|;
if|if
condition|(
operator|*
name|arg
operator|==
literal|'-'
condition|)
block|{
name|len
operator|=
name|strlen
argument_list|(
name|arg
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|len
operator|+
name|line_len
operator|>
literal|79
condition|)
block|{
name|line_len
operator|=
literal|2
expr_stmt|;
name|fputs
argument_list|(
literal|"\n #"
argument_list|,
name|out
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|out
argument_list|,
literal|" %s"
argument_list|,
operator|*
name|p
argument_list|)
expr_stmt|;
name|line_len
operator|+=
name|len
expr_stmt|;
block|}
block|}
name|fputs
argument_list|(
literal|"\n\n"
argument_list|,
name|out
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Abort after printing out a specific insn.  */
end_comment

begin_function
name|void
name|abort_with_insn
parameter_list|(
name|insn
parameter_list|,
name|reason
parameter_list|)
name|rtx
name|insn
decl_stmt|;
name|char
modifier|*
name|reason
decl_stmt|;
block|{
name|error
argument_list|(
name|reason
argument_list|)
expr_stmt|;
name|debug_rtx
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Write a message to stderr (for use in macros expanded in files that do not    include stdio.h).  */
end_comment

begin_function
name|void
name|trace
parameter_list|(
name|s
parameter_list|,
name|s1
parameter_list|,
name|s2
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|,
decl|*
name|s1
decl_stmt|,
modifier|*
name|s2
decl_stmt|;
end_function

begin_block
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|s
argument_list|,
name|s1
argument_list|,
name|s2
argument_list|)
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|SIGINFO
end_ifdef

begin_function
specifier|static
name|void
name|siginfo
parameter_list|(
name|signo
parameter_list|)
name|int
name|signo
decl_stmt|;
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"compiling '%s' in '%s'\n"
argument_list|,
operator|(
name|current_function_name
operator|!=
operator|(
name|char
operator|*
operator|)
literal|0
operator|)
condition|?
name|current_function_name
else|:
literal|"<toplevel>"
argument_list|,
operator|(
name|current_function_file
operator|!=
operator|(
name|char
operator|*
operator|)
literal|0
operator|)
condition|?
name|current_function_file
else|:
literal|"<no file>"
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SIGINFO */
end_comment

begin_escape
end_escape

begin_comment
comment|/* Set up the threshold for data to go into the small data area, instead    of the normal data area, and detect any conflicts in the switches.  */
end_comment

begin_function
name|void
name|override_options
parameter_list|()
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|start
decl_stmt|;
specifier|register
name|int
name|regno
decl_stmt|;
specifier|register
name|enum
name|machine_mode
name|mode
decl_stmt|;
if|if
condition|(
name|g_switch_set
condition|)
name|mips_section_threshold
operator|=
name|g_switch_value
expr_stmt|;
else|else
name|mips_section_threshold
operator|=
operator|(
name|TARGET_MIPS_AS
operator|)
condition|?
literal|8
else|:
literal|0
expr_stmt|;
comment|/* Identify the processor type */
if|if
condition|(
name|mips_cpu_string
operator|==
operator|(
name|char
operator|*
operator|)
literal|0
operator|||
operator|!
name|strcmp
argument_list|(
name|mips_cpu_string
argument_list|,
literal|"default"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|mips_cpu_string
argument_list|,
literal|"DEFAULT"
argument_list|)
condition|)
block|{
name|mips_cpu_string
operator|=
literal|"default"
expr_stmt|;
name|mips_cpu
operator|=
name|PROCESSOR_DEFAULT
expr_stmt|;
block|}
else|else
block|{
name|char
modifier|*
name|p
init|=
name|mips_cpu_string
decl_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'r'
operator|||
operator|*
name|p
operator|==
literal|'R'
condition|)
name|p
operator|++
expr_stmt|;
comment|/* Since there is no difference between a R2000 and R3000 in 	 terms of the scheduler, we collapse them into just an R3000. */
name|mips_cpu
operator|=
name|PROCESSOR_DEFAULT
expr_stmt|;
switch|switch
condition|(
operator|*
name|p
condition|)
block|{
case|case
literal|'2'
case|:
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"2000"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"2k"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"2K"
argument_list|)
condition|)
name|mips_cpu
operator|=
name|PROCESSOR_R3000
expr_stmt|;
break|break;
case|case
literal|'3'
case|:
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"3000"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"3k"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"3K"
argument_list|)
condition|)
name|mips_cpu
operator|=
name|PROCESSOR_R3000
expr_stmt|;
break|break;
case|case
literal|'4'
case|:
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"4000"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"4k"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"4K"
argument_list|)
condition|)
name|mips_cpu
operator|=
name|PROCESSOR_R4000
expr_stmt|;
break|break;
case|case
literal|'6'
case|:
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"6000"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"6k"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"6K"
argument_list|)
condition|)
name|mips_cpu
operator|=
name|PROCESSOR_R6000
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|mips_cpu
operator|==
name|PROCESSOR_DEFAULT
condition|)
block|{
name|error
argument_list|(
literal|"bad value (%s) for -mcpu= switch"
argument_list|,
name|mips_cpu_string
argument_list|)
expr_stmt|;
name|mips_cpu_string
operator|=
literal|"default"
expr_stmt|;
block|}
block|}
comment|/* Now get the architectural level.  */
if|if
condition|(
name|mips_isa_string
operator|==
operator|(
name|char
operator|*
operator|)
literal|0
condition|)
name|mips_isa
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|isdigit
argument_list|(
operator|*
name|mips_isa_string
argument_list|)
condition|)
name|mips_isa
operator|=
name|atoi
argument_list|(
name|mips_isa_string
argument_list|)
expr_stmt|;
else|else
block|{
name|error
argument_list|(
literal|"bad value (%s) for -mips switch"
argument_list|,
name|mips_isa_string
argument_list|)
expr_stmt|;
name|mips_isa
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|mips_isa
operator|<
literal|0
operator|||
name|mips_isa
operator|>
literal|3
condition|)
name|error
argument_list|(
literal|"-mips%d not supported"
argument_list|,
name|mips_isa
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|mips_isa
operator|>
literal|1
operator|&&
operator|(
name|mips_cpu
operator|==
name|PROCESSOR_DEFAULT
operator|||
name|mips_cpu
operator|==
name|PROCESSOR_R3000
operator|)
condition|)
name|error
argument_list|(
literal|"-mcpu=%s does not support -mips%d"
argument_list|,
name|mips_cpu_string
argument_list|,
name|mips_isa
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|mips_cpu
operator|==
name|PROCESSOR_R6000
operator|&&
name|mips_isa
operator|>
literal|2
condition|)
name|error
argument_list|(
literal|"-mcpu=%s does not support -mips%d"
argument_list|,
name|mips_cpu_string
argument_list|,
name|mips_isa
argument_list|)
expr_stmt|;
comment|/* make sure sizes of ints/longs/etc. are ok */
if|if
condition|(
name|mips_isa
operator|<
literal|3
condition|)
block|{
if|if
condition|(
name|TARGET_INT64
condition|)
name|fatal
argument_list|(
literal|"Only the r4000 can support 64 bit ints"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TARGET_LONG64
condition|)
name|fatal
argument_list|(
literal|"Only the r4000 can support 64 bit longs"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TARGET_LLONG128
condition|)
name|fatal
argument_list|(
literal|"Only the r4000 can support 128 bit long longs"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TARGET_FLOAT64
condition|)
name|fatal
argument_list|(
literal|"Only the r4000 can support 64 bit fp registers"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TARGET_INT64
operator|||
name|TARGET_LONG64
operator|||
name|TARGET_LLONG128
operator|||
name|TARGET_FLOAT64
condition|)
name|warning
argument_list|(
literal|"r4000 64/128 bit types not yet supported"
argument_list|)
expr_stmt|;
comment|/* Tell halfpic.c that we have half-pic code if we do.  */
if|if
condition|(
name|TARGET_HALF_PIC
condition|)
name|HALF_PIC_INIT
argument_list|()
expr_stmt|;
comment|/* -mrnames says to use the MIPS software convention for register      names instead of the hardware names (ie, a0 instead of $4).      We do this by switching the names in mips_reg_names, which the      reg_names points into via the REGISTER_NAMES macro.  */
if|if
condition|(
name|TARGET_NAME_REGS
condition|)
block|{
if|if
condition|(
name|TARGET_GAS
condition|)
block|{
name|target_flags
operator|&=
operator|~
name|MASK_NAME_REGS
expr_stmt|;
name|error
argument_list|(
literal|"Gas does not support the MIPS software register name convention."
argument_list|)
expr_stmt|;
block|}
else|else
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|mips_sw_reg_names
argument_list|,
operator|(
name|char
operator|*
operator|)
name|mips_reg_names
argument_list|,
sizeof|sizeof
argument_list|(
name|mips_reg_names
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* If this is OSF/1, set up a SIGINFO handler so we can see what function      is currently being compiled.  */
ifdef|#
directive|ifdef
name|SIGINFO
if|if
condition|(
name|getenv
argument_list|(
literal|"GCC_SIGINFO"
argument_list|)
operator|!=
operator|(
name|char
operator|*
operator|)
literal|0
condition|)
block|{
name|struct
name|sigaction
name|action
decl_stmt|;
name|action
operator|.
name|sa_handler
operator|=
name|siginfo
expr_stmt|;
name|action
operator|.
name|sa_mask
operator|=
literal|0
expr_stmt|;
name|action
operator|.
name|sa_flags
operator|=
name|SA_RESTART
expr_stmt|;
name|sigaction
argument_list|(
name|SIGINFO
argument_list|,
operator|&
name|action
argument_list|,
operator|(
expr|struct
name|sigaction
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|_IOLBF
argument_list|)
if|#
directive|if
name|defined
argument_list|(
name|ultrix
argument_list|)
operator|||
name|defined
argument_list|(
name|__ultrix
argument_list|)
operator|||
name|defined
argument_list|(
name|__OSF1__
argument_list|)
operator|||
name|defined
argument_list|(
name|__osf__
argument_list|)
operator|||
name|defined
argument_list|(
name|osf
argument_list|)
comment|/* If -mstats and -quiet, make stderr line buffered.  */
if|if
condition|(
name|quiet_flag
operator|&&
name|TARGET_STATS
condition|)
name|setvbuf
argument_list|(
name|stderr
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
name|_IOLBF
argument_list|,
name|BUFSIZ
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
comment|/* Set up the classification arrays now.  */
name|mips_rtx_classify
index|[
operator|(
name|int
operator|)
name|PLUS
index|]
operator|=
name|CLASS_ADD_OP
expr_stmt|;
name|mips_rtx_classify
index|[
operator|(
name|int
operator|)
name|MINUS
index|]
operator|=
name|CLASS_ADD_OP
expr_stmt|;
name|mips_rtx_classify
index|[
operator|(
name|int
operator|)
name|DIV
index|]
operator|=
name|CLASS_DIVMOD_OP
expr_stmt|;
name|mips_rtx_classify
index|[
operator|(
name|int
operator|)
name|MOD
index|]
operator|=
name|CLASS_DIVMOD_OP
expr_stmt|;
name|mips_rtx_classify
index|[
operator|(
name|int
operator|)
name|UDIV
index|]
operator|=
name|CLASS_DIVMOD_OP
operator||
name|CLASS_UNSIGNED_OP
expr_stmt|;
name|mips_rtx_classify
index|[
operator|(
name|int
operator|)
name|UMOD
index|]
operator|=
name|CLASS_DIVMOD_OP
operator||
name|CLASS_UNSIGNED_OP
expr_stmt|;
name|mips_rtx_classify
index|[
operator|(
name|int
operator|)
name|EQ
index|]
operator|=
name|CLASS_CMP_OP
operator||
name|CLASS_EQUALITY_OP
operator||
name|CLASS_FCMP_OP
expr_stmt|;
name|mips_rtx_classify
index|[
operator|(
name|int
operator|)
name|NE
index|]
operator|=
name|CLASS_CMP_OP
operator||
name|CLASS_EQUALITY_OP
operator||
name|CLASS_FCMP_OP
expr_stmt|;
name|mips_rtx_classify
index|[
operator|(
name|int
operator|)
name|GT
index|]
operator|=
name|CLASS_CMP_OP
operator||
name|CLASS_FCMP_OP
expr_stmt|;
name|mips_rtx_classify
index|[
operator|(
name|int
operator|)
name|GE
index|]
operator|=
name|CLASS_CMP_OP
operator||
name|CLASS_FCMP_OP
expr_stmt|;
name|mips_rtx_classify
index|[
operator|(
name|int
operator|)
name|LT
index|]
operator|=
name|CLASS_CMP_OP
operator||
name|CLASS_FCMP_OP
expr_stmt|;
name|mips_rtx_classify
index|[
operator|(
name|int
operator|)
name|LE
index|]
operator|=
name|CLASS_CMP_OP
operator||
name|CLASS_FCMP_OP
expr_stmt|;
name|mips_rtx_classify
index|[
operator|(
name|int
operator|)
name|GTU
index|]
operator|=
name|CLASS_CMP_OP
operator||
name|CLASS_UNSIGNED_OP
expr_stmt|;
name|mips_rtx_classify
index|[
operator|(
name|int
operator|)
name|GEU
index|]
operator|=
name|CLASS_CMP_OP
operator||
name|CLASS_UNSIGNED_OP
expr_stmt|;
name|mips_rtx_classify
index|[
operator|(
name|int
operator|)
name|LTU
index|]
operator|=
name|CLASS_CMP_OP
operator||
name|CLASS_UNSIGNED_OP
expr_stmt|;
name|mips_rtx_classify
index|[
operator|(
name|int
operator|)
name|LEU
index|]
operator|=
name|CLASS_CMP_OP
operator||
name|CLASS_UNSIGNED_OP
expr_stmt|;
name|mips_print_operand_punct
index|[
literal|'?'
index|]
operator|=
name|TRUE
expr_stmt|;
name|mips_print_operand_punct
index|[
literal|'#'
index|]
operator|=
name|TRUE
expr_stmt|;
name|mips_print_operand_punct
index|[
literal|'&'
index|]
operator|=
name|TRUE
expr_stmt|;
name|mips_print_operand_punct
index|[
literal|'!'
index|]
operator|=
name|TRUE
expr_stmt|;
name|mips_print_operand_punct
index|[
literal|'*'
index|]
operator|=
name|TRUE
expr_stmt|;
name|mips_print_operand_punct
index|[
literal|'@'
index|]
operator|=
name|TRUE
expr_stmt|;
name|mips_print_operand_punct
index|[
literal|'.'
index|]
operator|=
name|TRUE
expr_stmt|;
name|mips_print_operand_punct
index|[
literal|'('
index|]
operator|=
name|TRUE
expr_stmt|;
name|mips_print_operand_punct
index|[
literal|')'
index|]
operator|=
name|TRUE
expr_stmt|;
name|mips_print_operand_punct
index|[
literal|'['
index|]
operator|=
name|TRUE
expr_stmt|;
name|mips_print_operand_punct
index|[
literal|']'
index|]
operator|=
name|TRUE
expr_stmt|;
name|mips_print_operand_punct
index|[
literal|'<'
index|]
operator|=
name|TRUE
expr_stmt|;
name|mips_print_operand_punct
index|[
literal|'>'
index|]
operator|=
name|TRUE
expr_stmt|;
name|mips_print_operand_punct
index|[
literal|'{'
index|]
operator|=
name|TRUE
expr_stmt|;
name|mips_print_operand_punct
index|[
literal|'}'
index|]
operator|=
name|TRUE
expr_stmt|;
name|mips_char_to_class
index|[
literal|'d'
index|]
operator|=
name|GR_REGS
expr_stmt|;
name|mips_char_to_class
index|[
literal|'f'
index|]
operator|=
operator|(
operator|(
name|TARGET_HARD_FLOAT
operator|)
condition|?
name|FP_REGS
else|:
name|NO_REGS
operator|)
expr_stmt|;
name|mips_char_to_class
index|[
literal|'h'
index|]
operator|=
name|HI_REG
expr_stmt|;
name|mips_char_to_class
index|[
literal|'l'
index|]
operator|=
name|LO_REG
expr_stmt|;
name|mips_char_to_class
index|[
literal|'x'
index|]
operator|=
name|MD_REGS
expr_stmt|;
name|mips_char_to_class
index|[
literal|'y'
index|]
operator|=
name|GR_REGS
expr_stmt|;
name|mips_char_to_class
index|[
literal|'z'
index|]
operator|=
name|ST_REGS
expr_stmt|;
comment|/* Set up array to map GCC register number to debug register number.      Ignore the special purpose register numbers.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|i
operator|++
control|)
name|mips_dbx_regno
index|[
name|i
index|]
operator|=
operator|-
literal|1
expr_stmt|;
name|start
operator|=
name|GP_DBX_FIRST
operator|-
name|GP_REG_FIRST
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GP_REG_FIRST
init|;
name|i
operator|<=
name|GP_REG_LAST
condition|;
name|i
operator|++
control|)
name|mips_dbx_regno
index|[
name|i
index|]
operator|=
name|i
operator|+
name|start
expr_stmt|;
name|start
operator|=
name|FP_DBX_FIRST
operator|-
name|FP_REG_FIRST
expr_stmt|;
for|for
control|(
name|i
operator|=
name|FP_REG_FIRST
init|;
name|i
operator|<=
name|FP_REG_LAST
condition|;
name|i
operator|++
control|)
name|mips_dbx_regno
index|[
name|i
index|]
operator|=
name|i
operator|+
name|start
expr_stmt|;
comment|/* Set up array giving whether a given register can hold a given mode.      At present, restrict ints from being in FP registers, because reload      is a little enthusiastic about storing extra values in FP registers,      and this is not good for things like OS kernels.  Also, due to the      mandatory delay, it is as fast to load from cached memory as to move      from the FP register.  */
for|for
control|(
name|mode
operator|=
name|VOIDmode
init|;
name|mode
operator|!=
name|MAX_MACHINE_MODE
condition|;
name|mode
operator|=
operator|(
expr|enum
name|machine_mode
operator|)
operator|(
operator|(
name|int
operator|)
name|mode
operator|+
literal|1
operator|)
control|)
block|{
specifier|register
name|int
name|size
init|=
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
decl_stmt|;
specifier|register
name|enum
name|mode_class
name|class
init|=
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
decl_stmt|;
for|for
control|(
name|regno
operator|=
literal|0
init|;
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|regno
operator|++
control|)
block|{
specifier|register
name|int
name|temp
decl_stmt|;
if|if
condition|(
name|mode
operator|==
name|CC_FPmode
operator|||
name|mode
operator|==
name|CC_REV_FPmode
condition|)
name|temp
operator|=
operator|(
name|regno
operator|==
name|FPSW_REGNUM
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GP_REG_P
argument_list|(
name|regno
argument_list|)
condition|)
name|temp
operator|=
operator|(
operator|(
name|regno
operator|&
literal|1
operator|)
operator|==
literal|0
operator|||
operator|(
name|size
operator|<=
name|UNITS_PER_WORD
operator|)
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
name|FP_REG_P
argument_list|(
name|regno
argument_list|)
condition|)
name|temp
operator|=
operator|(
operator|(
name|TARGET_FLOAT64
operator|||
operator|(
operator|(
name|regno
operator|&
literal|1
operator|)
operator|==
literal|0
operator|)
operator|)
operator|&&
operator|(
name|class
operator|==
name|MODE_FLOAT
operator|||
name|class
operator|==
name|MODE_COMPLEX_FLOAT
operator|||
operator|(
name|TARGET_DEBUG_H_MODE
operator|&&
name|class
operator|==
name|MODE_INT
operator|)
operator|)
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
name|MD_REG_P
argument_list|(
name|regno
argument_list|)
condition|)
name|temp
operator|=
operator|(
name|mode
operator|==
name|SImode
operator|||
operator|(
name|regno
operator|==
name|MD_REG_FIRST
operator|&&
name|mode
operator|==
name|DImode
operator|)
operator|)
expr_stmt|;
else|else
name|temp
operator|=
name|FALSE
expr_stmt|;
name|mips_hard_regno_mode_ok
index|[
operator|(
name|int
operator|)
name|mode
index|]
index|[
name|regno
index|]
operator|=
name|temp
expr_stmt|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  * The MIPS debug format wants all automatic variables and arguments  * to be in terms of the virtual frame pointer (stack pointer before  * any adjustment in the function), while the MIPS 3.0 linker wants  * the frame pointer to be the stack pointer after the initial  * adjustment.  So, we do the adjustment here.  The arg pointer (which  * is eliminated) points to the virtual frame pointer, while the frame  * pointer (which may be eliminated) points to the stack pointer after  * the initial adjustments.  */
end_comment

begin_function
name|int
name|mips_debugger_offset
parameter_list|(
name|addr
parameter_list|,
name|offset
parameter_list|)
name|rtx
name|addr
decl_stmt|;
name|int
name|offset
decl_stmt|;
block|{
name|rtx
name|offset2
init|=
name|const0_rtx
decl_stmt|;
name|rtx
name|reg
init|=
name|eliminate_constant_term
argument_list|(
name|addr
argument_list|,
operator|&
name|offset2
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|offset
condition|)
name|offset
operator|=
name|INTVAL
argument_list|(
name|offset2
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg
operator|==
name|stack_pointer_rtx
operator|||
name|reg
operator|==
name|frame_pointer_rtx
condition|)
block|{
name|int
name|frame_size
init|=
operator|(
operator|!
name|current_frame_info
operator|.
name|initialized
operator|)
condition|?
name|compute_frame_size
argument_list|(
name|get_frame_size
argument_list|()
argument_list|)
else|:
name|current_frame_info
operator|.
name|total_size
decl_stmt|;
name|offset
operator|=
name|offset
operator|-
name|frame_size
expr_stmt|;
block|}
comment|/* sdbout_parms does not want this to crash for unrecognized cases.  */
if|#
directive|if
literal|0
block|else if (reg != arg_pointer_rtx)     abort_with_insn (addr, "mips_debugger_offset called with non stack/frame/arg pointer.");
endif|#
directive|endif
return|return
name|offset
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* A C compound statement to output to stdio stream STREAM the    assembler syntax for an instruction operand X.  X is an RTL    expression.     CODE is a value that can be used to specify one of several ways    of printing the operand.  It is used when identical operands    must be printed differently depending on the context.  CODE    comes from the `%' specification that was used to request    printing of the operand.  If the specification was just `%DIGIT'    then CODE is 0; if the specification was `%LTR DIGIT' then CODE    is the ASCII code for LTR.     If X is a register, this macro should print the register's name.    The names can be found in an array `reg_names' whose type is    `char *[]'.  `reg_names' is initialized from `REGISTER_NAMES'.     When the machine description has a specification `%PUNCT' (a `%'    followed by a punctuation character), this macro is called with    a null pointer for X and the punctuation character for CODE.     The MIPS specific codes are:     'X'  X is CONST_INT, prints 32 bits in hexadecimal format = "0x%08x",    'x'  X is CONST_INT, prints 16 bits in hexadecimal format = "0x%04x",    'd'  output integer constant in decimal,    'z'	if the operand is 0, use $0 instead of normal operand.    'D'  print second register of double-word register operand.    'L'  print low-order register of double-word register operand.    'M'  print high-order register of double-word register operand.    'C'  print part of opcode for a branch condition.    'N'  print part of opcode for a branch condition, inverted.    '('	Turn on .set noreorder    ')'	Turn on .set reorder    '['	Turn on .set noat    ']'	Turn on .set at    '<'	Turn on .set nomacro    '>'	Turn on .set macro    '{'	Turn on .set volatile (not GAS)    '}'	Turn on .set novolatile (not GAS)    '&'	Turn on .set noreorder if filling delay slots    '*'	Turn on both .set noreorder and .set nomacro if filling delay slots    '!'	Turn on .set nomacro if filling delay slots    '#'	Print nop if in a .set noreorder section.    '?'	Print 'l' if we are to use a branch likely instead of normal branch.    '@'	Print the name of the assembler temporary register (at or $1).    '.'	Print the name of the register with a hard-wired zero (zero or $0).  */
end_comment

begin_function
name|void
name|print_operand
parameter_list|(
name|file
parameter_list|,
name|op
parameter_list|,
name|letter
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
comment|/* file to write to */
name|rtx
name|op
decl_stmt|;
comment|/* operand to print */
name|int
name|letter
decl_stmt|;
comment|/* %<letter> or 0 */
block|{
specifier|register
name|enum
name|rtx_code
name|code
decl_stmt|;
if|if
condition|(
name|PRINT_OPERAND_PUNCT_VALID_P
argument_list|(
name|letter
argument_list|)
condition|)
block|{
switch|switch
condition|(
name|letter
condition|)
block|{
default|default:
name|error
argument_list|(
literal|"PRINT_OPERAND: Unknown punctuation '%c'"
argument_list|,
name|letter
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'?'
case|:
if|if
condition|(
name|mips_branch_likely
condition|)
name|putc
argument_list|(
literal|'l'
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'@'
case|:
name|fputs
argument_list|(
name|reg_names
index|[
name|GP_REG_FIRST
operator|+
literal|1
index|]
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'.'
case|:
name|fputs
argument_list|(
name|reg_names
index|[
name|GP_REG_FIRST
operator|+
literal|0
index|]
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'&'
case|:
if|if
condition|(
name|final_sequence
operator|!=
literal|0
operator|&&
name|set_noreorder
operator|++
operator|==
literal|0
condition|)
name|fputs
argument_list|(
literal|".set\tnoreorder\n\t"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'*'
case|:
if|if
condition|(
name|final_sequence
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|set_noreorder
operator|++
operator|==
literal|0
condition|)
name|fputs
argument_list|(
literal|".set\tnoreorder\n\t"
argument_list|,
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|set_nomacro
operator|++
operator|==
literal|0
condition|)
name|fputs
argument_list|(
literal|".set\tnomacro\n\t"
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'!'
case|:
if|if
condition|(
name|final_sequence
operator|!=
literal|0
operator|&&
name|set_nomacro
operator|++
operator|==
literal|0
condition|)
name|fputs
argument_list|(
literal|"\n\t.set\tnomacro"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'#'
case|:
if|if
condition|(
name|set_noreorder
operator|!=
literal|0
condition|)
name|fputs
argument_list|(
literal|"\n\tnop"
argument_list|,
name|file
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TARGET_GAS
operator|||
name|TARGET_STATS
condition|)
name|fputs
argument_list|(
literal|"\n\t#nop"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'('
case|:
if|if
condition|(
name|set_noreorder
operator|++
operator|==
literal|0
condition|)
name|fputs
argument_list|(
literal|".set\tnoreorder\n\t"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
literal|')'
case|:
if|if
condition|(
name|set_noreorder
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"internal error: %%) found without a %%( in assembler pattern"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|--
name|set_noreorder
operator|==
literal|0
condition|)
name|fputs
argument_list|(
literal|"\n\t.set\treorder"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'['
case|:
if|if
condition|(
name|set_noat
operator|++
operator|==
literal|0
condition|)
name|fputs
argument_list|(
literal|".set\tnoat\n\t"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
literal|']'
case|:
if|if
condition|(
name|set_noat
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"internal error: %%] found without a %%[ in assembler pattern"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|--
name|set_noat
operator|==
literal|0
condition|)
name|fputs
argument_list|(
literal|"\n\t.set\tat"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'<'
case|:
if|if
condition|(
name|set_nomacro
operator|++
operator|==
literal|0
condition|)
name|fputs
argument_list|(
literal|".set\tnomacro\n\t"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'>'
case|:
if|if
condition|(
name|set_nomacro
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"internal error: %%> found without a %%< in assembler pattern"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|--
name|set_nomacro
operator|==
literal|0
condition|)
name|fputs
argument_list|(
literal|"\n\t.set\tmacro"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'{'
case|:
if|if
condition|(
name|set_volatile
operator|++
operator|==
literal|0
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s.set\tvolatile\n\t"
argument_list|,
operator|(
name|TARGET_MIPS_AS
operator|)
condition|?
literal|""
else|:
literal|"#"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'}'
case|:
if|if
condition|(
name|set_volatile
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"internal error: %%} found without a %%{ in assembler pattern"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|--
name|set_volatile
operator|==
literal|0
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\n\t%s.set\tnovolatile"
argument_list|,
operator|(
name|TARGET_MIPS_AS
operator|)
condition|?
literal|""
else|:
literal|"#"
argument_list|)
expr_stmt|;
break|break;
block|}
return|return;
block|}
if|if
condition|(
operator|!
name|op
condition|)
block|{
name|error
argument_list|(
literal|"PRINT_OPERAND null pointer"
argument_list|)
expr_stmt|;
return|return;
block|}
name|code
operator|=
name|GET_CODE
argument_list|(
name|op
argument_list|)
expr_stmt|;
if|if
condition|(
name|letter
operator|==
literal|'C'
condition|)
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|EQ
case|:
name|fputs
argument_list|(
literal|"eq"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
name|NE
case|:
name|fputs
argument_list|(
literal|"ne"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
name|GT
case|:
name|fputs
argument_list|(
literal|"gt"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
name|GE
case|:
name|fputs
argument_list|(
literal|"ge"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
name|LT
case|:
name|fputs
argument_list|(
literal|"lt"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
name|LE
case|:
name|fputs
argument_list|(
literal|"le"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
name|GTU
case|:
name|fputs
argument_list|(
literal|"gtu"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
name|GEU
case|:
name|fputs
argument_list|(
literal|"geu"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
name|LTU
case|:
name|fputs
argument_list|(
literal|"ltu"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
name|LEU
case|:
name|fputs
argument_list|(
literal|"leu"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort_with_insn
argument_list|(
name|op
argument_list|,
literal|"PRINT_OPERAND, illegal insn for %%C"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|letter
operator|==
literal|'N'
condition|)
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|EQ
case|:
name|fputs
argument_list|(
literal|"ne"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
name|NE
case|:
name|fputs
argument_list|(
literal|"eq"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
name|GT
case|:
name|fputs
argument_list|(
literal|"le"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
name|GE
case|:
name|fputs
argument_list|(
literal|"lt"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
name|LT
case|:
name|fputs
argument_list|(
literal|"ge"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
name|LE
case|:
name|fputs
argument_list|(
literal|"gt"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
name|GTU
case|:
name|fputs
argument_list|(
literal|"leu"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
name|GEU
case|:
name|fputs
argument_list|(
literal|"ltu"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
name|LTU
case|:
name|fputs
argument_list|(
literal|"geu"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
name|LEU
case|:
name|fputs
argument_list|(
literal|"gtu"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort_with_insn
argument_list|(
name|op
argument_list|,
literal|"PRINT_OPERAND, illegal insn for %%N"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|code
operator|==
name|REG
condition|)
block|{
specifier|register
name|int
name|regnum
init|=
name|REGNO
argument_list|(
name|op
argument_list|)
decl_stmt|;
if|if
condition|(
name|letter
operator|==
literal|'M'
condition|)
name|regnum
operator|+=
name|MOST_SIGNIFICANT_WORD
expr_stmt|;
elseif|else
if|if
condition|(
name|letter
operator|==
literal|'L'
condition|)
name|regnum
operator|+=
name|LEAST_SIGNIFICANT_WORD
expr_stmt|;
elseif|else
if|if
condition|(
name|letter
operator|==
literal|'D'
condition|)
name|regnum
operator|++
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s"
argument_list|,
name|reg_names
index|[
name|regnum
index|]
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|code
operator|==
name|MEM
condition|)
name|output_address
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|code
operator|==
name|CONST_DOUBLE
condition|)
block|{
if|#
directive|if
name|HOST_FLOAT_FORMAT
operator|==
name|TARGET_FLOAT_FORMAT
union|union
block|{
name|double
name|d
decl_stmt|;
name|int
name|i
index|[
literal|2
index|]
decl_stmt|;
block|}
name|u
union|;
name|u
operator|.
name|i
index|[
literal|0
index|]
operator|=
name|CONST_DOUBLE_LOW
argument_list|(
name|op
argument_list|)
expr_stmt|;
name|u
operator|.
name|i
index|[
literal|1
index|]
operator|=
name|CONST_DOUBLE_HIGH
argument_list|(
name|op
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|==
name|SFmode
condition|)
block|{
name|float
name|f
decl_stmt|;
name|f
operator|=
name|u
operator|.
name|d
expr_stmt|;
name|u
operator|.
name|d
operator|=
name|f
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%.20e"
argument_list|,
name|u
operator|.
name|d
argument_list|)
expr_stmt|;
else|#
directive|else
name|fatal
argument_list|(
literal|"CONST_DOUBLE found in cross compilation"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
operator|(
name|letter
operator|==
literal|'x'
operator|)
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
operator|)
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"0x%04x"
argument_list|,
literal|0xffff
operator|&
operator|(
name|INTVAL
argument_list|(
name|op
argument_list|)
operator|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|letter
operator|==
literal|'X'
operator|)
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
operator|)
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"0x%08x"
argument_list|,
name|INTVAL
argument_list|(
name|op
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|letter
operator|==
literal|'d'
operator|)
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
operator|)
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%d"
argument_list|,
operator|(
name|INTVAL
argument_list|(
name|op
argument_list|)
operator|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|letter
operator|==
literal|'z'
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
operator|)
operator|&&
name|INTVAL
argument_list|(
name|op
argument_list|)
operator|==
literal|0
condition|)
name|fputs
argument_list|(
name|reg_names
index|[
name|GP_REG_FIRST
index|]
argument_list|,
name|file
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|letter
operator|==
literal|'d'
operator|||
name|letter
operator|==
literal|'x'
operator|||
name|letter
operator|==
literal|'X'
condition|)
name|fatal
argument_list|(
literal|"PRINT_OPERAND: letter %c was found& insn was not CONST_INT"
argument_list|,
name|letter
argument_list|)
expr_stmt|;
else|else
name|output_addr_const
argument_list|(
name|file
argument_list|,
name|op
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* A C compound statement to output to stdio stream STREAM the    assembler syntax for an instruction operand that is a memory    reference whose address is ADDR.  ADDR is an RTL expression.     On some machines, the syntax for a symbolic address depends on    the section that the address refers to.  On these machines,    define the macro `ENCODE_SECTION_INFO' to store the information    into the `symbol_ref', and then check for it here.  */
end_comment

begin_function
name|void
name|print_operand_address
parameter_list|(
name|file
parameter_list|,
name|addr
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
name|rtx
name|addr
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|addr
condition|)
name|error
argument_list|(
literal|"PRINT_OPERAND_ADDRESS, null pointer"
argument_list|)
expr_stmt|;
else|else
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
condition|)
block|{
default|default:
name|abort_with_insn
argument_list|(
name|addr
argument_list|,
literal|"PRINT_OPERAND_ADDRESS, illegal insn #1"
argument_list|)
expr_stmt|;
break|break;
case|case
name|REG
case|:
if|if
condition|(
name|REGNO
argument_list|(
name|addr
argument_list|)
operator|==
name|ARG_POINTER_REGNUM
condition|)
name|abort_with_insn
argument_list|(
name|addr
argument_list|,
literal|"Arg pointer not eliminated."
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"0(%s)"
argument_list|,
name|reg_names
index|[
name|REGNO
argument_list|(
name|addr
argument_list|)
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|PLUS
case|:
block|{
specifier|register
name|rtx
name|reg
init|=
operator|(
name|rtx
operator|)
literal|0
decl_stmt|;
specifier|register
name|rtx
name|offset
init|=
operator|(
name|rtx
operator|)
literal|0
decl_stmt|;
specifier|register
name|rtx
name|arg0
init|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
decl_stmt|;
specifier|register
name|rtx
name|arg1
init|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|REG
condition|)
block|{
name|reg
operator|=
name|arg0
expr_stmt|;
name|offset
operator|=
name|arg1
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|offset
argument_list|)
operator|==
name|REG
condition|)
name|abort_with_insn
argument_list|(
name|addr
argument_list|,
literal|"PRINT_OPERAND_ADDRESS, 2 regs"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|REG
condition|)
block|{
name|reg
operator|=
name|arg1
expr_stmt|;
name|offset
operator|=
name|arg0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|arg0
argument_list|)
operator|&&
name|CONSTANT_P
argument_list|(
name|arg1
argument_list|)
condition|)
block|{
name|output_addr_const
argument_list|(
name|file
argument_list|,
name|addr
argument_list|)
expr_stmt|;
break|break;
block|}
else|else
name|abort_with_insn
argument_list|(
name|addr
argument_list|,
literal|"PRINT_OPERAND_ADDRESS, no regs"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|CONSTANT_P
argument_list|(
name|offset
argument_list|)
condition|)
name|abort_with_insn
argument_list|(
name|addr
argument_list|,
literal|"PRINT_OPERAND_ADDRESS, illegal insn #2"
argument_list|)
expr_stmt|;
if|if
condition|(
name|REGNO
argument_list|(
name|reg
argument_list|)
operator|==
name|ARG_POINTER_REGNUM
condition|)
name|abort_with_insn
argument_list|(
name|addr
argument_list|,
literal|"Arg pointer not eliminated."
argument_list|)
expr_stmt|;
name|output_addr_const
argument_list|(
name|file
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"(%s)"
argument_list|,
name|reg_names
index|[
name|REGNO
argument_list|(
name|reg
argument_list|)
index|]
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|LABEL_REF
case|:
case|case
name|SYMBOL_REF
case|:
case|case
name|CONST_INT
case|:
case|case
name|CONST
case|:
name|output_addr_const
argument_list|(
name|file
argument_list|,
name|addr
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* If optimizing for the global pointer, keep track of all of    the externs, so that at the end of the file, we can emit    the appropriate .extern declaration for them, before writing    out the text section.  We assume that all names passed to    us are in the permanent obstack, so that they will be valid    at the end of the compilation.     If we have -G 0, or the extern size is unknown, don't bother    emitting the .externs.  */
end_comment

begin_function
name|int
name|mips_output_external
parameter_list|(
name|file
parameter_list|,
name|decl
parameter_list|,
name|name
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
name|tree
name|decl
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
block|{
specifier|register
name|struct
name|extern_list
modifier|*
name|p
decl_stmt|;
name|int
name|len
decl_stmt|;
if|if
condition|(
name|TARGET_GP_OPT
operator|&&
name|mips_section_threshold
operator|!=
literal|0
operator|&&
operator|(
operator|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|)
operator|!=
name|FUNCTION_DECL
operator|)
operator|&&
operator|(
operator|(
name|len
operator|=
name|int_size_in_bytes
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|)
operator|>
literal|0
operator|)
condition|)
block|{
name|p
operator|=
operator|(
expr|struct
name|extern_list
operator|*
operator|)
name|permalloc
argument_list|(
operator|(
name|long
operator|)
sizeof|sizeof
argument_list|(
expr|struct
name|extern_list
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|->
name|next
operator|=
name|extern_head
expr_stmt|;
name|p
operator|->
name|name
operator|=
name|name
expr_stmt|;
name|p
operator|->
name|size
operator|=
name|len
expr_stmt|;
name|extern_head
operator|=
name|p
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Compute a string to use as a temporary file name.  */
end_comment

begin_function
specifier|static
name|FILE
modifier|*
name|make_temp_file
parameter_list|()
block|{
name|FILE
modifier|*
name|stream
decl_stmt|;
name|char
modifier|*
name|base
init|=
name|getenv
argument_list|(
literal|"TMPDIR"
argument_list|)
decl_stmt|;
name|int
name|len
decl_stmt|;
if|if
condition|(
name|base
operator|==
operator|(
name|char
operator|*
operator|)
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|P_tmpdir
if|if
condition|(
name|access
argument_list|(
name|P_tmpdir
argument_list|,
name|R_OK
operator||
name|W_OK
argument_list|)
operator|==
literal|0
condition|)
name|base
operator|=
name|P_tmpdir
expr_stmt|;
elseif|else
endif|#
directive|endif
if|if
condition|(
name|access
argument_list|(
literal|"/usr/tmp"
argument_list|,
name|R_OK
operator||
name|W_OK
argument_list|)
operator|==
literal|0
condition|)
name|base
operator|=
literal|"/usr/tmp/"
expr_stmt|;
else|else
name|base
operator|=
literal|"/tmp/"
expr_stmt|;
block|}
name|len
operator|=
name|strlen
argument_list|(
name|base
argument_list|)
expr_stmt|;
name|temp_filename
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|len
operator|+
sizeof|sizeof
argument_list|(
literal|"/ccXXXXXX"
argument_list|)
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|temp_filename
argument_list|,
name|base
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>
literal|0
operator|&&
name|temp_filename
index|[
name|len
operator|-
literal|1
index|]
operator|!=
literal|'/'
condition|)
name|temp_filename
index|[
name|len
operator|++
index|]
operator|=
literal|'/'
expr_stmt|;
name|strcpy
argument_list|(
name|temp_filename
operator|+
name|len
argument_list|,
literal|"ccXXXXXX"
argument_list|)
expr_stmt|;
name|mktemp
argument_list|(
name|temp_filename
argument_list|)
expr_stmt|;
name|stream
operator|=
name|fopen
argument_list|(
name|temp_filename
argument_list|,
literal|"w+"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|stream
condition|)
name|pfatal_with_name
argument_list|(
name|temp_filename
argument_list|)
expr_stmt|;
name|unlink
argument_list|(
name|temp_filename
argument_list|)
expr_stmt|;
return|return
name|stream
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Emit a new filename to a stream.  If this is MIPS ECOFF, watch out    for .file's that start within a function.  If we are smuggling stabs, try to    put out a MIPS ECOFF file and a stab.  */
end_comment

begin_function
name|void
name|mips_output_filename
parameter_list|(
name|stream
parameter_list|,
name|name
parameter_list|)
name|FILE
modifier|*
name|stream
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
block|{
specifier|static
name|int
name|first_time
init|=
name|TRUE
decl_stmt|;
name|char
name|ltext_label_name
index|[
literal|100
index|]
decl_stmt|;
if|if
condition|(
name|first_time
condition|)
block|{
name|first_time
operator|=
name|FALSE
expr_stmt|;
name|SET_FILE_NUMBER
argument_list|()
expr_stmt|;
name|current_function_file
operator|=
name|name
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\t.file\t%d \"%s\"\n"
argument_list|,
name|num_source_filenames
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|TARGET_GAS
operator|&&
name|write_symbols
operator|==
name|DBX_DEBUG
condition|)
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\t#@stabs\n"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|write_symbols
operator|==
name|DBX_DEBUG
condition|)
block|{
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|ltext_label_name
argument_list|,
literal|"Ltext"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"%s \"%s\",%d,0,0,%s\n"
argument_list|,
name|ASM_STABS_OP
argument_list|,
name|name
argument_list|,
name|N_SOL
argument_list|,
operator|&
name|ltext_label_name
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|name
operator|!=
name|current_function_file
operator|&&
name|strcmp
argument_list|(
name|name
argument_list|,
name|current_function_file
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|inside_function
operator|&&
operator|!
name|TARGET_GAS
condition|)
block|{
if|if
condition|(
operator|!
name|file_in_function_warning
condition|)
block|{
name|file_in_function_warning
operator|=
name|TRUE
expr_stmt|;
name|ignore_line_number
operator|=
name|TRUE
expr_stmt|;
name|warning
argument_list|(
literal|"MIPS ECOFF format does not allow changing filenames within functions with #line"
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\t#.file\t%d \"%s\"\n"
argument_list|,
name|num_source_filenames
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SET_FILE_NUMBER
argument_list|()
expr_stmt|;
name|current_function_file
operator|=
name|name
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\t.file\t%d \"%s\"\n"
argument_list|,
name|num_source_filenames
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Emit a linenumber.  For encapsulated stabs, we need to put out a stab    as well as a .loc, since it is possible that MIPS ECOFF might not be    able to represent the location for inlines that come from a different    file.  */
end_comment

begin_function
name|void
name|mips_output_lineno
parameter_list|(
name|stream
parameter_list|,
name|line
parameter_list|)
name|FILE
modifier|*
name|stream
decl_stmt|;
name|int
name|line
decl_stmt|;
block|{
if|if
condition|(
name|write_symbols
operator|==
name|DBX_DEBUG
condition|)
block|{
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\t%s %d,0,%d\n"
argument_list|,
name|ASM_STABD_OP
argument_list|,
name|N_SLINE
argument_list|,
name|line
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\n\t%s.loc\t%d %d\n"
argument_list|,
operator|(
name|ignore_line_number
operator|)
condition|?
literal|"#"
else|:
literal|""
argument_list|,
name|num_source_filenames
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|LABEL_AFTER_LOC
argument_list|(
name|stream
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* If defined, a C statement to be executed just prior to the    output of assembler code for INSN, to modify the extracted    operands so they will be output differently.     Here the argument OPVEC is the vector containing the operands    extracted from INSN, and NOPERANDS is the number of elements of    the vector which contain meaningful data for this insn.  The    contents of this vector are what will be used to convert the    insn template into assembler code, so you can change the    assembler output by changing the contents of the vector.     We use it to check if the current insn needs a nop in front of it    because of load delays, and also to update the delay slot    statistics.  */
end_comment

begin_function
name|void
name|final_prescan_insn
parameter_list|(
name|insn
parameter_list|,
name|opvec
parameter_list|,
name|noperands
parameter_list|)
name|rtx
name|insn
decl_stmt|;
name|rtx
name|opvec
index|[]
decl_stmt|;
name|int
name|noperands
decl_stmt|;
block|{
if|if
condition|(
name|dslots_number_nops
operator|>
literal|0
condition|)
block|{
name|rtx
name|pattern
init|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|int
name|length
init|=
name|get_attr_length
argument_list|(
name|insn
argument_list|)
decl_stmt|;
comment|/* Do we need to emit a NOP? */
if|if
condition|(
name|length
operator|==
literal|0
operator|||
operator|(
name|mips_load_reg
operator|!=
operator|(
name|rtx
operator|)
literal|0
operator|&&
name|reg_mentioned_p
argument_list|(
name|mips_load_reg
argument_list|,
name|pattern
argument_list|)
operator|)
operator|||
operator|(
name|mips_load_reg2
operator|!=
operator|(
name|rtx
operator|)
literal|0
operator|&&
name|reg_mentioned_p
argument_list|(
name|mips_load_reg2
argument_list|,
name|pattern
argument_list|)
operator|)
operator|||
operator|(
name|mips_load_reg3
operator|!=
operator|(
name|rtx
operator|)
literal|0
operator|&&
name|reg_mentioned_p
argument_list|(
name|mips_load_reg3
argument_list|,
name|pattern
argument_list|)
operator|)
operator|||
operator|(
name|mips_load_reg4
operator|!=
operator|(
name|rtx
operator|)
literal|0
operator|&&
name|reg_mentioned_p
argument_list|(
name|mips_load_reg4
argument_list|,
name|pattern
argument_list|)
operator|)
condition|)
name|fputs
argument_list|(
operator|(
name|set_noreorder
operator|)
condition|?
literal|"\tnop\n"
else|:
literal|"\t#nop\n"
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
else|else
name|dslots_load_filled
operator|++
expr_stmt|;
while|while
condition|(
operator|--
name|dslots_number_nops
operator|>
literal|0
condition|)
name|fputs
argument_list|(
operator|(
name|set_noreorder
operator|)
condition|?
literal|"\tnop\n"
else|:
literal|"\t#nop\n"
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|mips_load_reg
operator|=
operator|(
name|rtx
operator|)
literal|0
expr_stmt|;
name|mips_load_reg2
operator|=
operator|(
name|rtx
operator|)
literal|0
expr_stmt|;
name|mips_load_reg3
operator|=
operator|(
name|rtx
operator|)
literal|0
expr_stmt|;
name|mips_load_reg4
operator|=
operator|(
name|rtx
operator|)
literal|0
expr_stmt|;
if|if
condition|(
name|set_noreorder
operator|&&
operator|--
name|set_noreorder
operator|==
literal|0
condition|)
name|fputs
argument_list|(
literal|"\t.set\treorder\n"
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TARGET_STATS
condition|)
block|{
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|insn
argument_list|)
decl_stmt|;
if|if
condition|(
name|code
operator|==
name|JUMP_INSN
operator|||
name|code
operator|==
name|CALL_INSN
condition|)
name|dslots_jump_total
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Output at beginning of assembler file.    If we are optimizing to use the global pointer, create a temporary    file to hold all of the text stuff, and write it out to the end.    This is needed because the MIPS assembler is evidently one pass,    and if it hasn't seen the relevant .comm/.lcomm/.extern/.sdata    declaration when the code is processed, it generates a two    instruction sequence.  */
end_comment

begin_function
name|void
name|mips_asm_file_start
parameter_list|(
name|stream
parameter_list|)
name|FILE
modifier|*
name|stream
decl_stmt|;
block|{
name|ASM_OUTPUT_SOURCE_FILENAME
argument_list|(
name|stream
argument_list|,
name|main_input_filename
argument_list|)
expr_stmt|;
comment|/* Versions of the MIPS assembler before 2.20 generate errors      if a branch inside of a .set noreorder section jumps to a      label outside of the .set noreorder section.  Revision 2.20      just set nobopt silently rather than fixing the bug.  */
if|if
condition|(
name|TARGET_MIPS_AS
operator|&&
name|optimize
operator|&&
name|flag_delayed_branch
condition|)
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\t.set\tnobopt\n"
argument_list|)
expr_stmt|;
comment|/* Generate the pseudo ops that the Pyramid based System V.4 wants.  */
if|if
condition|(
name|TARGET_ABICALLS
condition|)
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\t.abicalls\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_GP_OPT
condition|)
block|{
name|asm_out_data_file
operator|=
name|stream
expr_stmt|;
name|asm_out_text_file
operator|=
name|make_temp_file
argument_list|()
expr_stmt|;
block|}
else|else
name|asm_out_data_file
operator|=
name|asm_out_text_file
operator|=
name|stream
expr_stmt|;
if|if
condition|(
name|TARGET_NAME_REGS
condition|)
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"#include<regdef.h>\n"
argument_list|)
expr_stmt|;
name|print_options
argument_list|(
name|stream
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* If we are optimizing the global pointer, emit the text section now    and any small externs which did not have .comm, etc that are    needed.  Also, give a warning if the data area is more than 32K and    -pic because 3 instructions are needed to reference the data    pointers.  */
end_comment

begin_function
name|void
name|mips_asm_file_end
parameter_list|(
name|file
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
block|{
name|char
name|buffer
index|[
literal|8192
index|]
decl_stmt|;
name|tree
name|name_tree
decl_stmt|;
name|struct
name|extern_list
modifier|*
name|p
decl_stmt|;
name|int
name|len
decl_stmt|;
if|if
condition|(
name|HALF_PIC_P
argument_list|()
condition|)
name|HALF_PIC_FINISH
argument_list|(
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_GP_OPT
condition|)
block|{
if|if
condition|(
name|extern_head
condition|)
name|fputs
argument_list|(
literal|"\n"
argument_list|,
name|file
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|extern_head
init|;
name|p
operator|!=
literal|0
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
name|name_tree
operator|=
name|get_identifier
argument_list|(
name|p
operator|->
name|name
argument_list|)
expr_stmt|;
comment|/* Positively ensure only one .extern for any given symbol.  */
if|if
condition|(
operator|!
name|TREE_ASM_WRITTEN
argument_list|(
name|name_tree
argument_list|)
condition|)
block|{
name|TREE_ASM_WRITTEN
argument_list|(
name|name_tree
argument_list|)
operator|=
literal|1
expr_stmt|;
name|fputs
argument_list|(
literal|"\t.extern\t"
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|assemble_name
argument_list|(
name|file
argument_list|,
name|p
operator|->
name|name
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|", %d\n"
argument_list|,
name|p
operator|->
name|size
argument_list|)
expr_stmt|;
block|}
block|}
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\n\t.text\n"
argument_list|)
expr_stmt|;
name|rewind
argument_list|(
name|asm_out_text_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|ferror
argument_list|(
name|asm_out_text_file
argument_list|)
condition|)
name|fatal_io_error
argument_list|(
name|temp_filename
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|len
operator|=
name|fread
argument_list|(
name|buffer
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|buffer
argument_list|)
argument_list|,
name|asm_out_text_file
argument_list|)
operator|)
operator|>
literal|0
condition|)
if|if
condition|(
name|fwrite
argument_list|(
name|buffer
argument_list|,
literal|1
argument_list|,
name|len
argument_list|,
name|file
argument_list|)
operator|!=
name|len
condition|)
name|pfatal_with_name
argument_list|(
name|asm_file_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<
literal|0
condition|)
name|pfatal_with_name
argument_list|(
name|temp_filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|fclose
argument_list|(
name|asm_out_text_file
argument_list|)
operator|!=
literal|0
condition|)
name|pfatal_with_name
argument_list|(
name|temp_filename
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Emit either a label, .comm, or .lcomm directive, and mark    that the symbol is used, so that we don't emit an .extern    for it in mips_asm_file_end.  */
end_comment

begin_function
name|void
name|mips_declare_object
parameter_list|(
name|stream
parameter_list|,
name|name
parameter_list|,
name|init_string
parameter_list|,
name|final_string
parameter_list|,
name|size
parameter_list|)
name|FILE
modifier|*
name|stream
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|char
modifier|*
name|init_string
decl_stmt|;
name|char
modifier|*
name|final_string
decl_stmt|;
name|int
name|size
decl_stmt|;
block|{
name|fputs
argument_list|(
name|init_string
argument_list|,
name|stream
argument_list|)
expr_stmt|;
comment|/* "", "\t.comm\t", or "\t.lcomm\t" */
name|assemble_name
argument_list|(
name|stream
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
name|final_string
argument_list|,
name|size
argument_list|)
expr_stmt|;
comment|/* ":\n", ",%u\n", ",%u\n" */
if|if
condition|(
name|TARGET_GP_OPT
operator|&&
name|mips_section_threshold
operator|!=
literal|0
condition|)
block|{
name|tree
name|name_tree
init|=
name|get_identifier
argument_list|(
name|name
argument_list|)
decl_stmt|;
name|TREE_ASM_WRITTEN
argument_list|(
name|name_tree
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Output a double precision value to the assembler.  If both the    host and target are IEEE, emit the values in hex.  */
end_comment

begin_function
name|void
name|mips_output_double
parameter_list|(
name|stream
parameter_list|,
name|value
parameter_list|)
name|FILE
modifier|*
name|stream
decl_stmt|;
name|REAL_VALUE_TYPE
name|value
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|REAL_VALUE_TO_TARGET_DOUBLE
name|long
name|value_long
index|[
literal|2
index|]
decl_stmt|;
name|REAL_VALUE_TO_TARGET_DOUBLE
argument_list|(
name|value
argument_list|,
name|value_long
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\t.word\t0x%08lx\t\t# %.20g\n\t.word\t0x%08lx\n"
argument_list|,
name|value_long
index|[
literal|0
index|]
argument_list|,
name|value
argument_list|,
name|value_long
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
else|#
directive|else
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\t.double\t%.20g\n"
argument_list|,
name|value
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Output a single precision value to the assembler.  If both the    host and target are IEEE, emit the values in hex.  */
end_comment

begin_function
name|void
name|mips_output_float
parameter_list|(
name|stream
parameter_list|,
name|value
parameter_list|)
name|FILE
modifier|*
name|stream
decl_stmt|;
name|REAL_VALUE_TYPE
name|value
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|REAL_VALUE_TO_TARGET_SINGLE
name|long
name|value_long
decl_stmt|;
name|REAL_VALUE_TO_TARGET_SINGLE
argument_list|(
name|value
argument_list|,
name|value_long
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\t.word\t0x%08lx\t\t# %.12g (float)\n"
argument_list|,
name|value_long
argument_list|,
name|value
argument_list|)
expr_stmt|;
else|#
directive|else
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\t.float\t%.12g\n"
argument_list|,
name|value
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return TRUE if any register used in the epilogue is used.  This to insure    any insn put into the epilogue delay slots is safe.  */
end_comment

begin_function
name|int
name|epilogue_reg_mentioned_p
parameter_list|(
name|insn
parameter_list|)
name|rtx
name|insn
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|fmt
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|enum
name|rtx_code
name|code
decl_stmt|;
specifier|register
name|int
name|regno
decl_stmt|;
if|if
condition|(
name|insn
operator|==
operator|(
name|rtx
operator|)
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|LABEL_REF
condition|)
return|return
literal|0
return|;
name|code
operator|=
name|GET_CODE
argument_list|(
name|insn
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|REG
case|:
name|regno
operator|=
name|REGNO
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|regno
operator|==
name|STACK_POINTER_REGNUM
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|regno
operator|==
name|FRAME_POINTER_REGNUM
operator|&&
name|frame_pointer_needed
condition|)
return|return
literal|1
return|;
if|if
condition|(
operator|!
name|call_used_regs
index|[
name|regno
index|]
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|regno
operator|!=
name|MIPS_TEMP1_REGNUM
operator|&&
name|regno
operator|!=
name|MIPS_TEMP2_REGNUM
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|current_frame_info
operator|.
name|initialized
condition|)
name|compute_frame_size
argument_list|(
name|get_frame_size
argument_list|()
argument_list|)
expr_stmt|;
return|return
operator|(
name|current_frame_info
operator|.
name|total_size
operator|>=
literal|32768
operator|)
return|;
case|case
name|SCRATCH
case|:
case|case
name|CC0
case|:
case|case
name|PC
case|:
case|case
name|CONST_INT
case|:
case|case
name|CONST_DOUBLE
case|:
return|return
literal|0
return|;
block|}
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
block|{
specifier|register
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
name|XVECLEN
argument_list|(
name|insn
argument_list|,
name|i
argument_list|)
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|--
control|)
if|if
condition|(
name|epilogue_reg_mentioned_p
argument_list|(
name|XVECEXP
argument_list|(
name|insn
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
operator|&&
name|epilogue_reg_mentioned_p
argument_list|(
name|XEXP
argument_list|(
name|insn
argument_list|,
name|i
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return the bytes needed to compute the frame pointer from the current    stack pointer.     Mips stack frames look like:               Before call		        After call         +-----------------------+	+-----------------------+    high |			|       |      			|    mem. |		        |	|			|         |  caller's temps.    	|       |  caller's temps.    	| 	|       		|       |       	        |         +-----------------------+	+-----------------------+  	|       		|	|		        |         |  arguments on stack.  |	|  arguments on stack.  | 	|       		|	|			|         +-----------------------+	+-----------------------+  	|  4 words to save     	|	|  4 words to save	| 	|  arguments passed	|	|  arguments passed	| 	|  in registers, even	|	|  in registers, even	|     SP->|  if not passed.       |   FP->|  if not passed.	| 	+-----------------------+       +-----------------------+ 					|			| 					|  GP save for V.4 abi	| 					|			| 					+-----------------------+ 					|		        |                                         |  fp register save     | 					|			| 					+-----------------------+ 					|		        |                                         |  gp register save     |                                         |       		| 					+-----------------------+ 					|			| 					|  local variables	| 					|			| 					+-----------------------+ 					|			|                                         |  alloca allocations   |         				|			| 					+-----------------------+ 					|			|                                         |  arguments on stack   |         				|		        | 					+-----------------------+                                         |  4 words to save      | 					|  arguments passed     |                                         |  in registers, even   |    low                              SP->|  if not passed.       |    memory        			+-----------------------+  */
end_comment

begin_function
name|long
name|compute_frame_size
parameter_list|(
name|size
parameter_list|)
name|int
name|size
decl_stmt|;
comment|/* # of var. bytes allocated */
block|{
name|int
name|regno
decl_stmt|;
name|long
name|total_size
decl_stmt|;
comment|/* # bytes that the entire frame takes up */
name|long
name|var_size
decl_stmt|;
comment|/* # bytes that variables take up */
name|long
name|args_size
decl_stmt|;
comment|/* # bytes that outgoing arguments take up */
name|long
name|extra_size
decl_stmt|;
comment|/* # extra bytes */
name|long
name|gp_reg_rounded
decl_stmt|;
comment|/* # bytes needed to store gp after rounding */
name|long
name|gp_reg_size
decl_stmt|;
comment|/* # bytes needed to store gp regs */
name|long
name|fp_reg_size
decl_stmt|;
comment|/* # bytes needed to store fp regs */
name|long
name|mask
decl_stmt|;
comment|/* mask of saved gp registers */
name|long
name|fmask
decl_stmt|;
comment|/* mask of saved fp registers */
name|int
name|fp_inc
decl_stmt|;
comment|/* 1 or 2 depending on the size of fp regs */
name|long
name|fp_bits
decl_stmt|;
comment|/* bitmask to use for each fp register */
name|gp_reg_size
operator|=
literal|0
expr_stmt|;
name|fp_reg_size
operator|=
literal|0
expr_stmt|;
name|mask
operator|=
literal|0
expr_stmt|;
name|fmask
operator|=
literal|0
expr_stmt|;
name|extra_size
operator|=
name|MIPS_STACK_ALIGN
argument_list|(
operator|(
operator|(
name|TARGET_ABICALLS
operator|)
condition|?
name|UNITS_PER_WORD
else|:
literal|0
operator|)
argument_list|)
expr_stmt|;
name|var_size
operator|=
name|MIPS_STACK_ALIGN
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|args_size
operator|=
name|MIPS_STACK_ALIGN
argument_list|(
name|current_function_outgoing_args_size
argument_list|)
expr_stmt|;
comment|/* The MIPS 3.0 linker does not like functions that dynamically      allocate the stack and have 0 for STACK_DYNAMIC_OFFSET, since it      looks like we are trying to create a second frame pointer to the      function, so allocate some stack space to make it happy.  */
if|if
condition|(
name|args_size
operator|==
literal|0
operator|&&
name|current_function_calls_alloca
condition|)
name|args_size
operator|=
literal|4
operator|*
name|UNITS_PER_WORD
expr_stmt|;
name|total_size
operator|=
name|var_size
operator|+
name|args_size
operator|+
name|extra_size
expr_stmt|;
comment|/* Calculate space needed for gp registers.  */
for|for
control|(
name|regno
operator|=
name|GP_REG_FIRST
init|;
name|regno
operator|<=
name|GP_REG_LAST
condition|;
name|regno
operator|++
control|)
block|{
if|if
condition|(
name|MUST_SAVE_REGISTER
argument_list|(
name|regno
argument_list|)
condition|)
block|{
name|gp_reg_size
operator|+=
name|UNITS_PER_WORD
expr_stmt|;
name|mask
operator||=
literal|1L
operator|<<
operator|(
name|regno
operator|-
name|GP_REG_FIRST
operator|)
expr_stmt|;
block|}
block|}
comment|/* Calculate space needed for fp registers.  */
if|if
condition|(
name|TARGET_FLOAT64
condition|)
block|{
name|fp_inc
operator|=
literal|1
expr_stmt|;
name|fp_bits
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|fp_inc
operator|=
literal|2
expr_stmt|;
name|fp_bits
operator|=
literal|3
expr_stmt|;
block|}
for|for
control|(
name|regno
operator|=
name|FP_REG_FIRST
init|;
name|regno
operator|<=
name|FP_REG_LAST
condition|;
name|regno
operator|+=
name|fp_inc
control|)
block|{
if|if
condition|(
name|regs_ever_live
index|[
name|regno
index|]
operator|&&
operator|!
name|call_used_regs
index|[
name|regno
index|]
condition|)
block|{
name|fp_reg_size
operator|+=
literal|2
operator|*
name|UNITS_PER_WORD
expr_stmt|;
name|fmask
operator||=
name|fp_bits
operator|<<
operator|(
name|regno
operator|-
name|FP_REG_FIRST
operator|)
expr_stmt|;
block|}
block|}
name|gp_reg_rounded
operator|=
name|MIPS_STACK_ALIGN
argument_list|(
name|gp_reg_size
argument_list|)
expr_stmt|;
name|total_size
operator|+=
name|gp_reg_rounded
operator|+
name|fp_reg_size
expr_stmt|;
if|if
condition|(
name|total_size
operator|==
name|extra_size
condition|)
name|total_size
operator|=
name|extra_size
operator|=
literal|0
expr_stmt|;
comment|/* Save other computed information.  */
name|current_frame_info
operator|.
name|total_size
operator|=
name|total_size
expr_stmt|;
name|current_frame_info
operator|.
name|var_size
operator|=
name|var_size
expr_stmt|;
name|current_frame_info
operator|.
name|args_size
operator|=
name|args_size
expr_stmt|;
name|current_frame_info
operator|.
name|extra_size
operator|=
name|extra_size
expr_stmt|;
name|current_frame_info
operator|.
name|gp_reg_size
operator|=
name|gp_reg_size
expr_stmt|;
name|current_frame_info
operator|.
name|fp_reg_size
operator|=
name|fp_reg_size
expr_stmt|;
name|current_frame_info
operator|.
name|mask
operator|=
name|mask
expr_stmt|;
name|current_frame_info
operator|.
name|fmask
operator|=
name|fmask
expr_stmt|;
name|current_frame_info
operator|.
name|initialized
operator|=
name|reload_completed
expr_stmt|;
name|current_frame_info
operator|.
name|num_gp
operator|=
name|gp_reg_size
operator|/
name|UNITS_PER_WORD
expr_stmt|;
name|current_frame_info
operator|.
name|num_fp
operator|=
name|fp_reg_size
operator|/
operator|(
literal|2
operator|*
name|UNITS_PER_WORD
operator|)
expr_stmt|;
if|if
condition|(
name|mask
condition|)
block|{
name|unsigned
name|long
name|offset
init|=
name|args_size
operator|+
name|var_size
operator|+
name|gp_reg_size
operator|-
name|UNITS_PER_WORD
decl_stmt|;
name|current_frame_info
operator|.
name|gp_sp_offset
operator|=
name|offset
expr_stmt|;
name|current_frame_info
operator|.
name|gp_save_offset
operator|=
name|offset
operator|-
name|total_size
expr_stmt|;
block|}
else|else
block|{
name|current_frame_info
operator|.
name|gp_sp_offset
operator|=
literal|0
expr_stmt|;
name|current_frame_info
operator|.
name|gp_save_offset
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|fmask
condition|)
block|{
name|unsigned
name|long
name|offset
init|=
name|args_size
operator|+
name|var_size
operator|+
name|gp_reg_rounded
operator|+
name|fp_reg_size
operator|-
literal|2
operator|*
name|UNITS_PER_WORD
decl_stmt|;
name|current_frame_info
operator|.
name|fp_sp_offset
operator|=
name|offset
expr_stmt|;
name|current_frame_info
operator|.
name|fp_save_offset
operator|=
name|offset
operator|-
name|total_size
operator|+
name|UNITS_PER_WORD
expr_stmt|;
block|}
else|else
block|{
name|current_frame_info
operator|.
name|fp_sp_offset
operator|=
literal|0
expr_stmt|;
name|current_frame_info
operator|.
name|fp_save_offset
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Ok, we're done.  */
return|return
name|total_size
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Common code to emit the insns (or to write the instructions to a file)    to save/restore registers.     Other parts of the code assume that MIPS_TEMP1_REGNUM (aka large_reg)    is not modified within save_restore_insns.  */
end_comment

begin_define
define|#
directive|define
name|BITSET_P
parameter_list|(
name|value
parameter_list|,
name|bit
parameter_list|)
value|(((value)& (1L<< (bit))) != 0)
end_define

begin_function
specifier|static
name|void
name|save_restore_insns
parameter_list|(
name|store_p
parameter_list|,
name|large_reg
parameter_list|,
name|large_offset
parameter_list|,
name|file
parameter_list|)
name|int
name|store_p
decl_stmt|;
comment|/* true if this is prologue */
name|rtx
name|large_reg
decl_stmt|;
comment|/* register holding large offset constant or NULL */
name|long
name|large_offset
decl_stmt|;
comment|/* large constant offset value */
name|FILE
modifier|*
name|file
decl_stmt|;
comment|/* file to write instructions to instead of making RTL */
block|{
name|long
name|mask
init|=
name|current_frame_info
operator|.
name|mask
decl_stmt|;
name|long
name|fmask
init|=
name|current_frame_info
operator|.
name|fmask
decl_stmt|;
name|int
name|regno
decl_stmt|;
name|rtx
name|base_reg_rtx
decl_stmt|;
name|long
name|base_offset
decl_stmt|;
name|long
name|gp_offset
decl_stmt|;
name|long
name|fp_offset
decl_stmt|;
name|long
name|end_offset
decl_stmt|;
if|if
condition|(
name|frame_pointer_needed
operator|&&
operator|!
name|BITSET_P
argument_list|(
name|mask
argument_list|,
name|FRAME_POINTER_REGNUM
operator|-
name|GP_REG_FIRST
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|mask
operator|==
literal|0
operator|&&
name|fmask
operator|==
literal|0
condition|)
return|return;
comment|/* Save registers starting from high to low.  The debuggers prefer      at least the return register be stored at func+4, and also it      allows us not to need a nop in the epilog if at least one      register is reloaded in addition to return address.  */
comment|/* Save GP registers if needed.  */
if|if
condition|(
name|mask
condition|)
block|{
comment|/* Pick which pointer to use as a base register.  For small 	 frames, just use the stack pointer.  Otherwise, use a 	 temporary register.  Save 2 cycles if the save area is near 	 the end of a large frame, by reusing the constant created in 	 the prologue/epilogue to adjust the stack frame.  */
name|gp_offset
operator|=
name|current_frame_info
operator|.
name|gp_sp_offset
expr_stmt|;
name|end_offset
operator|=
name|gp_offset
operator|-
operator|(
name|current_frame_info
operator|.
name|gp_reg_size
operator|-
name|UNITS_PER_WORD
operator|)
expr_stmt|;
if|if
condition|(
name|gp_offset
operator|<
literal|0
operator|||
name|end_offset
operator|<
literal|0
condition|)
name|fatal
argument_list|(
literal|"gp_offset (%ld) or end_offset (%ld) is less than zero."
argument_list|,
name|gp_offset
argument_list|,
name|end_offset
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|gp_offset
operator|<
literal|32768
condition|)
block|{
name|base_reg_rtx
operator|=
name|stack_pointer_rtx
expr_stmt|;
name|base_offset
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|large_reg
operator|!=
operator|(
name|rtx
operator|)
literal|0
operator|&&
operator|(
operator|(
call|(
name|unsigned
name|long
call|)
argument_list|(
name|large_offset
operator|-
name|gp_offset
argument_list|)
operator|)
operator|<
literal|32768
operator|)
operator|&&
operator|(
operator|(
call|(
name|unsigned
name|long
call|)
argument_list|(
name|large_offset
operator|-
name|end_offset
argument_list|)
operator|)
operator|<
literal|32768
operator|)
condition|)
block|{
name|base_reg_rtx
operator|=
name|gen_rtx
argument_list|(
name|REG
argument_list|,
name|Pmode
argument_list|,
name|MIPS_TEMP2_REGNUM
argument_list|)
expr_stmt|;
name|base_offset
operator|=
name|large_offset
expr_stmt|;
if|if
condition|(
name|file
operator|==
operator|(
name|FILE
operator|*
operator|)
literal|0
condition|)
name|emit_insn
argument_list|(
name|gen_addsi3
argument_list|(
name|base_reg_rtx
argument_list|,
name|large_reg
argument_list|,
name|stack_pointer_rtx
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\taddu\t%s,%s,%s\n"
argument_list|,
name|reg_names
index|[
name|MIPS_TEMP2_REGNUM
index|]
argument_list|,
name|reg_names
index|[
name|REGNO
argument_list|(
name|large_reg
argument_list|)
index|]
argument_list|,
name|reg_names
index|[
name|STACK_POINTER_REGNUM
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|base_reg_rtx
operator|=
name|gen_rtx
argument_list|(
name|REG
argument_list|,
name|Pmode
argument_list|,
name|MIPS_TEMP2_REGNUM
argument_list|)
expr_stmt|;
name|base_offset
operator|=
name|gp_offset
expr_stmt|;
if|if
condition|(
name|file
operator|==
operator|(
name|FILE
operator|*
operator|)
literal|0
condition|)
block|{
name|emit_move_insn
argument_list|(
name|base_reg_rtx
argument_list|,
name|GEN_INT
argument_list|(
name|gp_offset
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_addsi3
argument_list|(
name|base_reg_rtx
argument_list|,
name|base_reg_rtx
argument_list|,
name|stack_pointer_rtx
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tli\t%s,0x%.08lx\t# %ld\n\taddu\t%s,%s,%s\n"
argument_list|,
name|reg_names
index|[
name|MIPS_TEMP2_REGNUM
index|]
argument_list|,
operator|(
name|long
operator|)
name|base_offset
argument_list|,
operator|(
name|long
operator|)
name|base_offset
argument_list|,
name|reg_names
index|[
name|MIPS_TEMP2_REGNUM
index|]
argument_list|,
name|reg_names
index|[
name|MIPS_TEMP2_REGNUM
index|]
argument_list|,
name|reg_names
index|[
name|STACK_POINTER_REGNUM
index|]
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|regno
operator|=
name|GP_REG_LAST
init|;
name|regno
operator|>=
name|GP_REG_FIRST
condition|;
name|regno
operator|--
control|)
block|{
if|if
condition|(
name|BITSET_P
argument_list|(
name|mask
argument_list|,
name|regno
operator|-
name|GP_REG_FIRST
argument_list|)
condition|)
block|{
if|if
condition|(
name|file
operator|==
operator|(
name|FILE
operator|*
operator|)
literal|0
condition|)
block|{
name|rtx
name|reg_rtx
init|=
name|gen_rtx
argument_list|(
name|REG
argument_list|,
name|Pmode
argument_list|,
name|regno
argument_list|)
decl_stmt|;
name|rtx
name|mem_rtx
init|=
name|gen_rtx
argument_list|(
name|MEM
argument_list|,
name|Pmode
argument_list|,
name|gen_rtx
argument_list|(
name|PLUS
argument_list|,
name|Pmode
argument_list|,
name|base_reg_rtx
argument_list|,
name|GEN_INT
argument_list|(
name|gp_offset
operator|-
name|base_offset
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|store_p
condition|)
name|emit_move_insn
argument_list|(
name|mem_rtx
argument_list|,
name|reg_rtx
argument_list|)
expr_stmt|;
else|else
name|emit_move_insn
argument_list|(
name|reg_rtx
argument_list|,
name|mem_rtx
argument_list|)
expr_stmt|;
block|}
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t%s\t%s,%ld(%s)\n"
argument_list|,
operator|(
name|store_p
operator|)
condition|?
literal|"sw"
else|:
literal|"lw"
argument_list|,
name|reg_names
index|[
name|regno
index|]
argument_list|,
name|gp_offset
operator|-
name|base_offset
argument_list|,
name|reg_names
index|[
name|REGNO
argument_list|(
name|base_reg_rtx
argument_list|)
index|]
argument_list|)
expr_stmt|;
name|gp_offset
operator|-=
name|UNITS_PER_WORD
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|base_reg_rtx
operator|=
operator|(
name|rtx
operator|)
literal|0
expr_stmt|;
comment|/* Make sure these are initialzed */
name|base_offset
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Save floating point registers if needed.  */
if|if
condition|(
name|fmask
condition|)
block|{
name|int
name|fp_inc
init|=
operator|(
name|TARGET_FLOAT64
operator|)
condition|?
literal|1
else|:
literal|2
decl_stmt|;
comment|/* Pick which pointer to use as a base register.  */
name|fp_offset
operator|=
name|current_frame_info
operator|.
name|fp_sp_offset
expr_stmt|;
name|end_offset
operator|=
name|fp_offset
operator|-
operator|(
name|current_frame_info
operator|.
name|fp_reg_size
operator|-
name|UNITS_PER_WORD
operator|)
expr_stmt|;
if|if
condition|(
name|fp_offset
operator|<
literal|0
operator|||
name|end_offset
operator|<
literal|0
condition|)
name|fatal
argument_list|(
literal|"fp_offset (%ld) or end_offset (%ld) is less than zero."
argument_list|,
name|fp_offset
argument_list|,
name|end_offset
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|fp_offset
operator|<
literal|32768
condition|)
block|{
name|base_reg_rtx
operator|=
name|stack_pointer_rtx
expr_stmt|;
name|base_offset
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|base_reg_rtx
operator|!=
operator|(
name|rtx
operator|)
literal|0
operator|&&
operator|(
operator|(
call|(
name|unsigned
name|long
call|)
argument_list|(
name|base_offset
operator|-
name|fp_offset
argument_list|)
operator|)
operator|<
literal|32768
operator|)
operator|&&
operator|(
operator|(
call|(
name|unsigned
name|long
call|)
argument_list|(
name|base_offset
operator|-
name|end_offset
argument_list|)
operator|)
operator|<
literal|32768
operator|)
condition|)
block|{
empty_stmt|;
comment|/* already set up for gp registers above */
block|}
elseif|else
if|if
condition|(
name|large_reg
operator|!=
operator|(
name|rtx
operator|)
literal|0
operator|&&
operator|(
operator|(
call|(
name|unsigned
name|long
call|)
argument_list|(
name|large_offset
operator|-
name|fp_offset
argument_list|)
operator|)
operator|<
literal|32768
operator|)
operator|&&
operator|(
operator|(
call|(
name|unsigned
name|long
call|)
argument_list|(
name|large_offset
operator|-
name|end_offset
argument_list|)
operator|)
operator|<
literal|32768
operator|)
condition|)
block|{
name|base_reg_rtx
operator|=
name|gen_rtx
argument_list|(
name|REG
argument_list|,
name|Pmode
argument_list|,
name|MIPS_TEMP2_REGNUM
argument_list|)
expr_stmt|;
name|base_offset
operator|=
name|large_offset
expr_stmt|;
if|if
condition|(
name|file
operator|==
operator|(
name|FILE
operator|*
operator|)
literal|0
condition|)
name|emit_insn
argument_list|(
name|gen_addsi3
argument_list|(
name|base_reg_rtx
argument_list|,
name|large_reg
argument_list|,
name|stack_pointer_rtx
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\taddu\t%s,%s,%s\n"
argument_list|,
name|reg_names
index|[
name|MIPS_TEMP2_REGNUM
index|]
argument_list|,
name|reg_names
index|[
name|REGNO
argument_list|(
name|large_reg
argument_list|)
index|]
argument_list|,
name|reg_names
index|[
name|STACK_POINTER_REGNUM
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|base_reg_rtx
operator|=
name|gen_rtx
argument_list|(
name|REG
argument_list|,
name|Pmode
argument_list|,
name|MIPS_TEMP2_REGNUM
argument_list|)
expr_stmt|;
name|base_offset
operator|=
name|fp_offset
expr_stmt|;
if|if
condition|(
name|file
operator|==
operator|(
name|FILE
operator|*
operator|)
literal|0
condition|)
block|{
name|emit_move_insn
argument_list|(
name|base_reg_rtx
argument_list|,
name|GEN_INT
argument_list|(
name|fp_offset
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_addsi3
argument_list|(
name|base_reg_rtx
argument_list|,
name|base_reg_rtx
argument_list|,
name|stack_pointer_rtx
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tli\t%s,0x%.08lx\t# %ld\n\taddu\t%s,%s,%s\n"
argument_list|,
name|reg_names
index|[
name|MIPS_TEMP2_REGNUM
index|]
argument_list|,
operator|(
name|long
operator|)
name|base_offset
argument_list|,
operator|(
name|long
operator|)
name|base_offset
argument_list|,
name|reg_names
index|[
name|MIPS_TEMP2_REGNUM
index|]
argument_list|,
name|reg_names
index|[
name|MIPS_TEMP2_REGNUM
index|]
argument_list|,
name|reg_names
index|[
name|STACK_POINTER_REGNUM
index|]
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|regno
operator|=
name|FP_REG_LAST
operator|-
literal|1
init|;
name|regno
operator|>=
name|FP_REG_FIRST
condition|;
name|regno
operator|-=
name|fp_inc
control|)
block|{
if|if
condition|(
name|BITSET_P
argument_list|(
name|fmask
argument_list|,
name|regno
operator|-
name|FP_REG_FIRST
argument_list|)
condition|)
block|{
if|if
condition|(
name|file
operator|==
operator|(
name|FILE
operator|*
operator|)
literal|0
condition|)
block|{
name|rtx
name|reg_rtx
init|=
name|gen_rtx
argument_list|(
name|REG
argument_list|,
name|DFmode
argument_list|,
name|regno
argument_list|)
decl_stmt|;
name|rtx
name|mem_rtx
init|=
name|gen_rtx
argument_list|(
name|MEM
argument_list|,
name|DFmode
argument_list|,
name|gen_rtx
argument_list|(
name|PLUS
argument_list|,
name|Pmode
argument_list|,
name|base_reg_rtx
argument_list|,
name|GEN_INT
argument_list|(
name|fp_offset
operator|-
name|base_offset
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|store_p
condition|)
name|emit_move_insn
argument_list|(
name|mem_rtx
argument_list|,
name|reg_rtx
argument_list|)
expr_stmt|;
else|else
name|emit_move_insn
argument_list|(
name|reg_rtx
argument_list|,
name|mem_rtx
argument_list|)
expr_stmt|;
block|}
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t%s\t%s,%ld(%s)\n"
argument_list|,
operator|(
name|store_p
operator|)
condition|?
literal|"s.d"
else|:
literal|"l.d"
argument_list|,
name|reg_names
index|[
name|regno
index|]
argument_list|,
name|fp_offset
operator|-
name|base_offset
argument_list|,
name|reg_names
index|[
name|REGNO
argument_list|(
name|base_reg_rtx
argument_list|)
index|]
argument_list|)
expr_stmt|;
name|fp_offset
operator|-=
literal|2
operator|*
name|UNITS_PER_WORD
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Set up the stack and frame (if desired) for the function.  */
end_comment

begin_function
name|void
name|function_prologue
parameter_list|(
name|file
parameter_list|,
name|size
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
name|int
name|size
decl_stmt|;
block|{
name|long
name|tsize
init|=
name|current_frame_info
operator|.
name|total_size
decl_stmt|;
name|ASM_OUTPUT_SOURCE_FILENAME
argument_list|(
name|file
argument_list|,
name|DECL_SOURCE_FILE
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug_info_level
operator|!=
name|DINFO_LEVEL_TERSE
condition|)
name|ASM_OUTPUT_SOURCE_LINE
argument_list|(
name|file
argument_list|,
name|DECL_SOURCE_LINE
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
expr_stmt|;
name|inside_function
operator|=
literal|1
expr_stmt|;
name|fputs
argument_list|(
literal|"\t.ent\t"
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|assemble_name
argument_list|(
name|file
argument_list|,
name|current_function_name
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"\n"
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|assemble_name
argument_list|(
name|file
argument_list|,
name|current_function_name
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|":\n"
argument_list|,
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_ABICALLS
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t.set\tnoreorder\n\t.cpload\t%s\n\t.set\treorder\n"
argument_list|,
name|reg_names
index|[
name|GP_REG_FIRST
operator|+
literal|25
index|]
argument_list|)
expr_stmt|;
name|tsize
operator|=
name|current_frame_info
operator|.
name|total_size
expr_stmt|;
if|if
condition|(
name|tsize
operator|>
literal|0
operator|&&
name|TARGET_ABICALLS
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t.cprestore %d\n"
argument_list|,
name|tsize
operator|+
name|STARTING_FRAME_OFFSET
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t.frame\t%s,%d,%s\t\t# vars= %d, regs= %d/%d, args = %d, extra= %d\n"
argument_list|,
name|reg_names
index|[
operator|(
name|frame_pointer_needed
operator|)
condition|?
name|FRAME_POINTER_REGNUM
else|:
name|STACK_POINTER_REGNUM
index|]
argument_list|,
name|tsize
argument_list|,
name|reg_names
index|[
literal|31
operator|+
name|GP_REG_FIRST
index|]
argument_list|,
name|current_frame_info
operator|.
name|var_size
argument_list|,
name|current_frame_info
operator|.
name|num_gp
argument_list|,
name|current_frame_info
operator|.
name|num_fp
argument_list|,
name|current_function_outgoing_args_size
argument_list|,
name|current_frame_info
operator|.
name|extra_size
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t.mask\t0x%08lx,%d\n\t.fmask\t0x%08lx,%d\n"
argument_list|,
name|current_frame_info
operator|.
name|mask
argument_list|,
name|current_frame_info
operator|.
name|gp_save_offset
argument_list|,
name|current_frame_info
operator|.
name|fmask
argument_list|,
name|current_frame_info
operator|.
name|fp_save_offset
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Expand the prologue into a bunch of separate insns.  */
end_comment

begin_function
name|void
name|mips_expand_prologue
parameter_list|()
block|{
name|int
name|regno
decl_stmt|;
name|long
name|tsize
decl_stmt|;
name|rtx
name|tmp_rtx
init|=
operator|(
name|rtx
operator|)
literal|0
decl_stmt|;
name|char
modifier|*
name|arg_name
init|=
operator|(
name|char
operator|*
operator|)
literal|0
decl_stmt|;
name|tree
name|fndecl
init|=
name|current_function_decl
decl_stmt|;
name|tree
name|fntype
init|=
name|TREE_TYPE
argument_list|(
name|fndecl
argument_list|)
decl_stmt|;
name|tree
name|fnargs
init|=
operator|(
name|TREE_CODE
argument_list|(
name|fntype
argument_list|)
operator|!=
name|METHOD_TYPE
operator|)
condition|?
name|DECL_ARGUMENTS
argument_list|(
name|fndecl
argument_list|)
else|:
literal|0
decl_stmt|;
name|rtx
name|next_arg_reg
decl_stmt|;
name|int
name|i
decl_stmt|;
name|tree
name|next_arg
decl_stmt|;
name|tree
name|cur_arg
decl_stmt|;
name|CUMULATIVE_ARGS
name|args_so_far
decl_stmt|;
comment|/* Determine the last argument, and get its name.  */
name|INIT_CUMULATIVE_ARGS
argument_list|(
name|args_so_far
argument_list|,
name|fntype
argument_list|,
operator|(
name|rtx
operator|)
literal|0
argument_list|)
expr_stmt|;
name|regno
operator|=
name|GP_ARG_FIRST
expr_stmt|;
for|for
control|(
name|cur_arg
operator|=
name|fnargs
init|;
name|cur_arg
operator|!=
operator|(
name|tree
operator|)
literal|0
condition|;
name|cur_arg
operator|=
name|next_arg
control|)
block|{
name|tree
name|type
init|=
name|DECL_ARG_TYPE
argument_list|(
name|cur_arg
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|passed_mode
init|=
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|rtx
name|entry_parm
init|=
name|FUNCTION_ARG
argument_list|(
name|args_so_far
argument_list|,
name|passed_mode
argument_list|,
name|DECL_ARG_TYPE
argument_list|(
name|cur_arg
argument_list|)
argument_list|,
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|entry_parm
condition|)
block|{
name|int
name|words
decl_stmt|;
comment|/* passed in a register, so will get homed automatically */
if|if
condition|(
name|GET_MODE
argument_list|(
name|entry_parm
argument_list|)
operator|==
name|BLKmode
condition|)
name|words
operator|=
operator|(
name|int_size_in_bytes
argument_list|(
name|type
argument_list|)
operator|+
literal|3
operator|)
operator|/
literal|4
expr_stmt|;
else|else
name|words
operator|=
operator|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|entry_parm
argument_list|)
argument_list|)
operator|+
literal|3
operator|)
operator|/
literal|4
expr_stmt|;
name|regno
operator|=
name|REGNO
argument_list|(
name|entry_parm
argument_list|)
operator|+
name|words
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|regno
operator|=
name|GP_ARG_LAST
operator|+
literal|1
expr_stmt|;
break|break;
block|}
name|FUNCTION_ARG_ADVANCE
argument_list|(
name|args_so_far
argument_list|,
name|passed_mode
argument_list|,
name|DECL_ARG_TYPE
argument_list|(
name|cur_arg
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|next_arg
operator|=
name|TREE_CHAIN
argument_list|(
name|cur_arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|next_arg
operator|==
operator|(
name|tree
operator|)
literal|0
condition|)
block|{
if|if
condition|(
name|DECL_NAME
argument_list|(
name|cur_arg
argument_list|)
condition|)
name|arg_name
operator|=
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|cur_arg
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
comment|/* In order to pass small structures by value in registers      compatibly with the MIPS compiler, we need to shift the value      into the high part of the register.  Function_arg has encoded a      PARALLEL rtx, holding a vector of adjustments to be made as the      next_arg_reg variable, so we split up the insns, and emit them      separately.  */
name|next_arg_reg
operator|=
name|FUNCTION_ARG
argument_list|(
name|args_so_far
argument_list|,
name|VOIDmode
argument_list|,
name|void_type_node
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|next_arg_reg
operator|!=
operator|(
name|rtx
operator|)
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|next_arg_reg
argument_list|)
operator|==
name|PARALLEL
condition|)
block|{
name|rtvec
name|adjust
init|=
name|XVEC
argument_list|(
name|next_arg_reg
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|int
name|num
init|=
name|GET_NUM_ELEM
argument_list|(
name|adjust
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num
condition|;
name|i
operator|++
control|)
block|{
name|rtx
name|pattern
init|=
name|RTVEC_ELT
argument_list|(
name|adjust
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|pattern
argument_list|)
operator|!=
name|SET
operator|||
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|pattern
argument_list|)
argument_list|)
operator|!=
name|ASHIFT
condition|)
name|abort_with_insn
argument_list|(
name|pattern
argument_list|,
literal|"Insn is not a shift"
argument_list|)
expr_stmt|;
name|PUT_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|pattern
argument_list|)
argument_list|,
name|ASHIFTRT
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|pattern
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* If this function is a varargs function, store any registers that      would normally hold arguments ($4 - $7) on the stack.  */
if|if
condition|(
operator|(
name|TYPE_ARG_TYPES
argument_list|(
name|fntype
argument_list|)
operator|!=
literal|0
operator|&&
operator|(
name|TREE_VALUE
argument_list|(
name|tree_last
argument_list|(
name|TYPE_ARG_TYPES
argument_list|(
name|fntype
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|void_type_node
operator|)
operator|)
operator|||
operator|(
name|arg_name
operator|!=
operator|(
name|char
operator|*
operator|)
literal|0
operator|&&
operator|(
operator|(
name|arg_name
index|[
literal|0
index|]
operator|==
literal|'_'
operator|&&
name|strcmp
argument_list|(
name|arg_name
argument_list|,
literal|"__builtin_va_alist"
argument_list|)
operator|==
literal|0
operator|)
operator|||
operator|(
name|arg_name
index|[
literal|0
index|]
operator|==
literal|'v'
operator|&&
name|strcmp
argument_list|(
name|arg_name
argument_list|,
literal|"va_alist"
argument_list|)
operator|==
literal|0
operator|)
operator|)
operator|)
condition|)
block|{
for|for
control|(
init|;
name|regno
operator|<=
name|GP_ARG_LAST
condition|;
name|regno
operator|++
control|)
block|{
name|rtx
name|ptr
init|=
name|stack_pointer_rtx
decl_stmt|;
if|if
condition|(
name|regno
operator|!=
name|GP_ARG_FIRST
condition|)
name|ptr
operator|=
name|gen_rtx
argument_list|(
name|PLUS
argument_list|,
name|Pmode
argument_list|,
name|ptr
argument_list|,
name|GEN_INT
argument_list|(
operator|(
name|regno
operator|-
name|GP_ARG_FIRST
operator|)
operator|*
name|UNITS_PER_WORD
argument_list|)
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|gen_rtx
argument_list|(
name|MEM
argument_list|,
name|Pmode
argument_list|,
name|ptr
argument_list|)
argument_list|,
name|gen_rtx
argument_list|(
name|REG
argument_list|,
name|Pmode
argument_list|,
name|regno
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|tsize
operator|=
name|compute_frame_size
argument_list|(
name|get_frame_size
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|tsize
operator|>
literal|0
condition|)
block|{
name|rtx
name|tsize_rtx
init|=
name|GEN_INT
argument_list|(
name|tsize
argument_list|)
decl_stmt|;
if|if
condition|(
name|tsize
operator|>
literal|32767
condition|)
block|{
name|tmp_rtx
operator|=
name|gen_rtx
argument_list|(
name|REG
argument_list|,
name|SImode
argument_list|,
name|MIPS_TEMP1_REGNUM
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|tmp_rtx
argument_list|,
name|tsize_rtx
argument_list|)
expr_stmt|;
name|tsize_rtx
operator|=
name|tmp_rtx
expr_stmt|;
block|}
name|emit_insn
argument_list|(
name|gen_subsi3
argument_list|(
name|stack_pointer_rtx
argument_list|,
name|stack_pointer_rtx
argument_list|,
name|tsize_rtx
argument_list|)
argument_list|)
expr_stmt|;
name|save_restore_insns
argument_list|(
name|TRUE
argument_list|,
name|tmp_rtx
argument_list|,
name|tsize
argument_list|,
operator|(
name|FILE
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|frame_pointer_needed
condition|)
name|emit_insn
argument_list|(
name|gen_movsi
argument_list|(
name|frame_pointer_rtx
argument_list|,
name|stack_pointer_rtx
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* If we are profiling, make sure no instructions are scheduled before      the call to mcount.  */
if|if
condition|(
name|profile_flag
operator|||
name|profile_block_flag
condition|)
name|emit_insn
argument_list|(
name|gen_blockage
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Do any necessary cleanup after a function to restore stack, frame, and regs. */
end_comment

begin_function
name|void
name|function_epilogue
parameter_list|(
name|file
parameter_list|,
name|size
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
name|int
name|size
decl_stmt|;
block|{
name|long
name|tsize
decl_stmt|;
name|char
modifier|*
name|sp_str
init|=
name|reg_names
index|[
name|STACK_POINTER_REGNUM
index|]
decl_stmt|;
name|char
modifier|*
name|t1_str
init|=
name|reg_names
index|[
name|MIPS_TEMP1_REGNUM
index|]
decl_stmt|;
name|rtx
name|epilogue_delay
init|=
name|current_function_epilogue_delay_list
decl_stmt|;
name|int
name|noreorder
init|=
operator|!
name|TARGET_MIPS_AS
operator|||
operator|(
name|epilogue_delay
operator|!=
literal|0
operator|)
decl_stmt|;
name|int
name|noepilogue
init|=
name|FALSE
decl_stmt|;
name|int
name|load_nop
init|=
name|FALSE
decl_stmt|;
name|int
name|load_only_r31
decl_stmt|;
name|rtx
name|tmp_rtx
init|=
operator|(
name|rtx
operator|)
literal|0
decl_stmt|;
name|rtx
name|restore_rtx
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* The epilogue does not depend on any registers, but the stack      registers, so we assume that if we have 1 pending nop, it can be      ignored, and 2 it must be filled (2 nops occur for integer      multiply and divide).  */
if|if
condition|(
name|dslots_number_nops
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|dslots_number_nops
operator|==
literal|1
condition|)
block|{
name|dslots_number_nops
operator|=
literal|0
expr_stmt|;
name|dslots_load_filled
operator|++
expr_stmt|;
block|}
else|else
block|{
while|while
condition|(
operator|--
name|dslots_number_nops
operator|>
literal|0
condition|)
name|fputs
argument_list|(
operator|(
name|set_noreorder
operator|)
condition|?
literal|"\tnop\n"
else|:
literal|"\t#nop\n"
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|set_noreorder
operator|>
literal|0
operator|&&
operator|--
name|set_noreorder
operator|==
literal|0
condition|)
name|fputs
argument_list|(
literal|"\t.set\treorder\n"
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|set_noat
operator|!=
literal|0
condition|)
block|{
name|set_noat
operator|=
literal|0
expr_stmt|;
name|fputs
argument_list|(
literal|"\t.set\tat\n"
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"internal gcc error: .set noat left on in epilogue"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|set_nomacro
operator|!=
literal|0
condition|)
block|{
name|set_nomacro
operator|=
literal|0
expr_stmt|;
name|fputs
argument_list|(
literal|"\t.set\tmacro\n"
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"internal gcc error: .set nomacro left on in epilogue"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|set_noreorder
operator|!=
literal|0
condition|)
block|{
name|set_noreorder
operator|=
literal|0
expr_stmt|;
name|fputs
argument_list|(
literal|"\t.set\treorder\n"
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"internal gcc error: .set noreorder left on in epilogue"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|set_volatile
operator|!=
literal|0
condition|)
block|{
name|set_volatile
operator|=
literal|0
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t#.set\tnovolatile\n"
argument_list|,
operator|(
name|TARGET_MIPS_AS
operator|)
condition|?
literal|""
else|:
literal|"#"
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"internal gcc error: .set volatile left on in epilogue"
argument_list|)
expr_stmt|;
block|}
name|size
operator|=
name|MIPS_STACK_ALIGN
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|tsize
operator|=
operator|(
operator|!
name|current_frame_info
operator|.
name|initialized
operator|)
condition|?
name|compute_frame_size
argument_list|(
name|size
argument_list|)
else|:
name|current_frame_info
operator|.
name|total_size
expr_stmt|;
if|if
condition|(
name|tsize
operator|==
literal|0
operator|&&
name|epilogue_delay
operator|==
literal|0
condition|)
block|{
name|rtx
name|insn
init|=
name|get_last_insn
argument_list|()
decl_stmt|;
comment|/* If the last insn was a BARRIER, we don't have to write any code 	 because a jump (aka return) was put there.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE
condition|)
name|insn
operator|=
name|prev_nonnote_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|insn
operator|&&
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|BARRIER
condition|)
name|noepilogue
operator|=
name|TRUE
expr_stmt|;
name|noreorder
operator|=
name|FALSE
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|noepilogue
condition|)
block|{
comment|/* In the reload sequence, we don't need to fill the load delay 	 slots for most of the loads, also see if we can fill the final 	 delay slot if not otherwise filled by the reload sequence.  */
if|if
condition|(
name|noreorder
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t.set\tnoreorder\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|tsize
operator|>
literal|32767
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tli\t%s,0x%.08lx\t# %ld\n"
argument_list|,
name|t1_str
argument_list|,
operator|(
name|long
operator|)
name|tsize
argument_list|,
operator|(
name|long
operator|)
name|tsize
argument_list|)
expr_stmt|;
name|tmp_rtx
operator|=
name|gen_rtx
argument_list|(
name|REG
argument_list|,
name|Pmode
argument_list|,
name|MIPS_TEMP1_REGNUM
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|frame_pointer_needed
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tmove\t%s,%s\t\t\t# sp not trusted here\n"
argument_list|,
name|sp_str
argument_list|,
name|reg_names
index|[
name|FRAME_POINTER_REGNUM
index|]
argument_list|)
expr_stmt|;
name|save_restore_insns
argument_list|(
name|FALSE
argument_list|,
name|tmp_rtx
argument_list|,
name|tsize
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|load_only_r31
operator|=
operator|(
name|current_frame_info
operator|.
name|mask
operator|==
operator|(
literal|1
operator|<<
literal|31
operator|)
operator|&&
name|current_frame_info
operator|.
name|fmask
operator|==
literal|0
operator|)
expr_stmt|;
if|if
condition|(
name|noreorder
condition|)
block|{
comment|/* If the only register saved is the return address, we need a 	     nop, unless we have an instruction to put into it.  Otherwise 	     we don't since reloading multiple registers doesn't reference 	     the register being loaded.  */
if|if
condition|(
name|load_only_r31
condition|)
block|{
if|if
condition|(
name|epilogue_delay
condition|)
name|final_scan_insn
argument_list|(
name|XEXP
argument_list|(
name|epilogue_delay
argument_list|,
literal|0
argument_list|)
argument_list|,
name|file
argument_list|,
literal|1
argument_list|,
comment|/* optimize */
operator|-
literal|2
argument_list|,
comment|/* prescan */
literal|1
argument_list|)
expr_stmt|;
comment|/* nopeepholes */
else|else
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tnop\n"
argument_list|)
expr_stmt|;
name|load_nop
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tj\t%s\n"
argument_list|,
name|reg_names
index|[
name|GP_REG_FIRST
operator|+
literal|31
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|tsize
operator|>
literal|32767
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\taddu\t%s,%s,%s\n"
argument_list|,
name|sp_str
argument_list|,
name|sp_str
argument_list|,
name|t1_str
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|tsize
operator|>
literal|0
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\taddu\t%s,%s,%d\n"
argument_list|,
name|sp_str
argument_list|,
name|sp_str
argument_list|,
name|tsize
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|load_only_r31
operator|&&
name|epilogue_delay
operator|!=
literal|0
condition|)
name|final_scan_insn
argument_list|(
name|XEXP
argument_list|(
name|epilogue_delay
argument_list|,
literal|0
argument_list|)
argument_list|,
name|file
argument_list|,
literal|1
argument_list|,
comment|/* optimize */
operator|-
literal|2
argument_list|,
comment|/* prescan */
literal|1
argument_list|)
expr_stmt|;
comment|/* nopeepholes */
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t.set\treorder\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|tsize
operator|>
literal|32767
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\taddu\t%s,%s,%s\n"
argument_list|,
name|sp_str
argument_list|,
name|sp_str
argument_list|,
name|t1_str
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|tsize
operator|>
literal|0
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\taddu\t%s,%s,%d\n"
argument_list|,
name|sp_str
argument_list|,
name|sp_str
argument_list|,
name|tsize
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tj\t%s\n"
argument_list|,
name|reg_names
index|[
name|GP_REG_FIRST
operator|+
literal|31
index|]
argument_list|)
expr_stmt|;
block|}
block|}
name|fputs
argument_list|(
literal|"\t.end\t"
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|assemble_name
argument_list|(
name|file
argument_list|,
name|current_function_name
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"\n"
argument_list|,
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_STATS
condition|)
block|{
name|int
name|num_gp_regs
init|=
name|current_frame_info
operator|.
name|gp_reg_size
operator|/
literal|4
decl_stmt|;
name|int
name|num_fp_regs
init|=
name|current_frame_info
operator|.
name|fp_reg_size
operator|/
literal|8
decl_stmt|;
name|int
name|num_regs
init|=
name|num_gp_regs
operator|+
name|num_fp_regs
decl_stmt|;
name|char
modifier|*
name|name
init|=
name|current_function_name
decl_stmt|;
if|if
condition|(
name|name
index|[
literal|0
index|]
operator|==
literal|'*'
condition|)
name|name
operator|++
expr_stmt|;
name|dslots_load_total
operator|+=
name|num_regs
expr_stmt|;
if|if
condition|(
operator|!
name|noepilogue
condition|)
name|dslots_jump_total
operator|++
expr_stmt|;
if|if
condition|(
name|noreorder
condition|)
block|{
name|dslots_load_filled
operator|+=
name|num_regs
expr_stmt|;
comment|/* If the only register saved is the return register, we 	     can't fill this register's delay slot.  */
if|if
condition|(
name|load_only_r31
operator|&&
name|epilogue_delay
operator|==
literal|0
condition|)
name|dslots_load_filled
operator|--
expr_stmt|;
if|if
condition|(
name|tsize
operator|>
literal|0
operator|||
operator|(
operator|!
name|load_only_r31
operator|&&
name|epilogue_delay
operator|!=
literal|0
operator|)
condition|)
name|dslots_jump_filled
operator|++
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%-20s fp=%c leaf=%c alloca=%c setjmp=%c stack=%4ld arg=%3ld reg=%2d/%d delay=%3d/%3dL %3d/%3dJ refs=%3d/%3d/%3d"
argument_list|,
name|name
argument_list|,
operator|(
name|frame_pointer_needed
operator|)
condition|?
literal|'y'
else|:
literal|'n'
argument_list|,
operator|(
operator|(
name|current_frame_info
operator|.
name|mask
operator|&
operator|(
literal|1
operator|<<
literal|31
operator|)
operator|)
operator|!=
literal|0
operator|)
condition|?
literal|'n'
else|:
literal|'y'
argument_list|,
operator|(
name|current_function_calls_alloca
operator|)
condition|?
literal|'y'
else|:
literal|'n'
argument_list|,
operator|(
name|current_function_calls_setjmp
operator|)
condition|?
literal|'y'
else|:
literal|'n'
argument_list|,
operator|(
name|long
operator|)
name|current_frame_info
operator|.
name|total_size
argument_list|,
operator|(
name|long
operator|)
name|current_function_outgoing_args_size
argument_list|,
name|num_gp_regs
argument_list|,
name|num_fp_regs
argument_list|,
name|dslots_load_total
argument_list|,
name|dslots_load_filled
argument_list|,
name|dslots_jump_total
argument_list|,
name|dslots_jump_filled
argument_list|,
name|num_refs
index|[
literal|0
index|]
argument_list|,
name|num_refs
index|[
literal|1
index|]
argument_list|,
name|num_refs
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|HALF_PIC_NUMBER_PTRS
operator|>
name|prev_half_pic_ptrs
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" half-pic=%3d"
argument_list|,
name|HALF_PIC_NUMBER_PTRS
operator|-
name|prev_half_pic_ptrs
argument_list|)
expr_stmt|;
name|prev_half_pic_ptrs
operator|=
name|HALF_PIC_NUMBER_PTRS
expr_stmt|;
block|}
if|if
condition|(
name|HALF_PIC_NUMBER_REFS
operator|>
name|prev_half_pic_refs
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" pic-ref=%3d"
argument_list|,
name|HALF_PIC_NUMBER_REFS
operator|-
name|prev_half_pic_refs
argument_list|)
expr_stmt|;
name|prev_half_pic_refs
operator|=
name|HALF_PIC_NUMBER_REFS
expr_stmt|;
block|}
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
block|}
comment|/* Reset state info for each function.  */
name|inside_function
operator|=
name|FALSE
expr_stmt|;
name|ignore_line_number
operator|=
name|FALSE
expr_stmt|;
name|dslots_load_total
operator|=
literal|0
expr_stmt|;
name|dslots_jump_total
operator|=
literal|0
expr_stmt|;
name|dslots_load_filled
operator|=
literal|0
expr_stmt|;
name|dslots_jump_filled
operator|=
literal|0
expr_stmt|;
name|num_refs
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|num_refs
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|num_refs
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|mips_load_reg
operator|=
operator|(
name|rtx
operator|)
literal|0
expr_stmt|;
name|mips_load_reg2
operator|=
operator|(
name|rtx
operator|)
literal|0
expr_stmt|;
name|current_frame_info
operator|=
name|zero_frame_info
expr_stmt|;
comment|/* Restore the output file if optimizing the GP (optimizing the GP causes      the text to be diverted to a tempfile, so that data decls come before      references to the data).  */
if|if
condition|(
name|TARGET_GP_OPT
condition|)
name|asm_out_file
operator|=
name|asm_out_data_file
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Expand the epilogue into a bunch of separate insns.  */
end_comment

begin_function
name|void
name|mips_expand_epilogue
parameter_list|()
block|{
name|long
name|tsize
init|=
name|current_frame_info
operator|.
name|total_size
decl_stmt|;
name|rtx
name|tsize_rtx
init|=
name|GEN_INT
argument_list|(
name|tsize
argument_list|)
decl_stmt|;
name|rtx
name|tmp_rtx
init|=
operator|(
name|rtx
operator|)
literal|0
decl_stmt|;
if|if
condition|(
name|tsize
operator|>
literal|32767
condition|)
block|{
name|tmp_rtx
operator|=
name|gen_rtx
argument_list|(
name|REG
argument_list|,
name|SImode
argument_list|,
name|MIPS_TEMP1_REGNUM
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|tmp_rtx
argument_list|,
name|tsize_rtx
argument_list|)
expr_stmt|;
name|tsize_rtx
operator|=
name|tmp_rtx
expr_stmt|;
block|}
if|if
condition|(
name|tsize
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|frame_pointer_needed
condition|)
name|emit_insn
argument_list|(
name|gen_movsi
argument_list|(
name|stack_pointer_rtx
argument_list|,
name|frame_pointer_rtx
argument_list|)
argument_list|)
expr_stmt|;
name|save_restore_insns
argument_list|(
name|FALSE
argument_list|,
name|tmp_rtx
argument_list|,
name|tsize
argument_list|,
operator|(
name|FILE
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_addsi3
argument_list|(
name|stack_pointer_rtx
argument_list|,
name|stack_pointer_rtx
argument_list|,
name|tsize_rtx
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|emit_jump_insn
argument_list|(
name|gen_return_internal
argument_list|(
name|gen_rtx
argument_list|(
name|REG
argument_list|,
name|Pmode
argument_list|,
name|GP_REG_FIRST
operator|+
literal|31
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Define the number of delay slots needed for the function epilogue.     On the mips, we need a slot if either no stack has been allocated,    or the only register saved is the return register.  */
end_comment

begin_function
name|int
name|mips_epilogue_delay_slots
parameter_list|()
block|{
if|if
condition|(
operator|!
name|current_frame_info
operator|.
name|initialized
condition|)
operator|(
name|void
operator|)
name|compute_frame_size
argument_list|(
name|get_frame_size
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|current_frame_info
operator|.
name|total_size
operator|==
literal|0
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|current_frame_info
operator|.
name|mask
operator|==
operator|(
literal|1
operator|<<
literal|31
operator|)
operator|&&
name|current_frame_info
operator|.
name|fmask
operator|==
literal|0
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return true if this function is known to have a null epilogue.    This allows the optimizer to omit jumps to jumps if no stack    was created.  */
end_comment

begin_function
name|int
name|simple_epilogue_p
parameter_list|()
block|{
if|if
condition|(
operator|!
name|reload_completed
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|current_frame_info
operator|.
name|initialized
condition|)
return|return
name|current_frame_info
operator|.
name|total_size
operator|==
literal|0
return|;
return|return
operator|(
name|compute_frame_size
argument_list|(
name|get_frame_size
argument_list|()
argument_list|)
operator|)
operator|==
literal|0
return|;
block|}
end_function

end_unit

