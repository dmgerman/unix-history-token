begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Breadth-first and depth-first routines for    searching multiple-inheritance lattice for GNU C++.    Copyright (C) 1987, 1989, 1992 Free Software Foundation, Inc.    Contributed by Michael Tiemann (tiemann@cygnus.com)  This file is part of GNU CC.  GNU CC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU CC; see the file COPYING.  If not, write to the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* Remove before release, should only appear for development and testing. */
end_comment

begin_define
define|#
directive|define
name|CHECK_convert_pointer_to_single_level
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* High-level class interface. */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"cp-tree.h"
end_include

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_define
define|#
directive|define
name|obstack_chunk_alloc
value|xmalloc
end_define

begin_define
define|#
directive|define
name|obstack_chunk_free
value|free
end_define

begin_function_decl
name|void
name|init_search
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|extern
name|struct
name|obstack
modifier|*
name|current_obstack
decl_stmt|;
end_decl_stmt

begin_include
include|#
directive|include
file|"stack.h"
end_include

begin_comment
comment|/* Obstack used for remembering decision points of breadth-first.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|obstack
name|search_obstack
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Obstack used to bridge from one function context to another.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|obstack
name|bridge_obstack
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Methods for pushing and popping objects to and from obstacks.  */
end_comment

begin_function
name|struct
name|stack_level
modifier|*
name|push_stack_level
parameter_list|(
name|obstack
parameter_list|,
name|tp
parameter_list|,
name|size
parameter_list|)
name|struct
name|obstack
modifier|*
name|obstack
decl_stmt|;
name|char
modifier|*
name|tp
decl_stmt|;
comment|/* Sony NewsOS 5.0 compiler doesn't like void * here.  */
name|int
name|size
decl_stmt|;
block|{
name|struct
name|stack_level
modifier|*
name|stack
decl_stmt|;
comment|/* FIXME.  Doesn't obstack_grow, in the case when the current chunk has      insufficient space, move the base so that obstack_next_free is not      valid?  Perhaps obstack_copy should be used rather than obstack_grow,      and its returned value be used.  -- Raeburn    */
name|stack
operator|=
operator|(
expr|struct
name|stack_level
operator|*
operator|)
name|obstack_next_free
argument_list|(
name|obstack
argument_list|)
expr_stmt|;
name|obstack_grow
argument_list|(
name|obstack
argument_list|,
name|tp
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|obstack_finish
argument_list|(
name|obstack
argument_list|)
expr_stmt|;
name|stack
operator|->
name|obstack
operator|=
name|obstack
expr_stmt|;
name|stack
operator|->
name|first
operator|=
operator|(
name|tree
operator|*
operator|)
name|obstack_base
argument_list|(
name|obstack
argument_list|)
expr_stmt|;
name|stack
operator|->
name|limit
operator|=
name|obstack_room
argument_list|(
name|obstack
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|tree
operator|*
argument_list|)
expr_stmt|;
return|return
name|stack
return|;
block|}
end_function

begin_function
name|struct
name|stack_level
modifier|*
name|pop_stack_level
parameter_list|(
name|stack
parameter_list|)
name|struct
name|stack_level
modifier|*
name|stack
decl_stmt|;
block|{
name|struct
name|stack_level
modifier|*
name|tem
init|=
name|stack
decl_stmt|;
name|struct
name|obstack
modifier|*
name|obstack
init|=
name|tem
operator|->
name|obstack
decl_stmt|;
name|stack
operator|=
name|tem
operator|->
name|prev
expr_stmt|;
name|obstack_free
argument_list|(
name|obstack
argument_list|,
name|tem
argument_list|)
expr_stmt|;
return|return
name|stack
return|;
block|}
end_function

begin_define
define|#
directive|define
name|search_level
value|stack_level
end_define

begin_decl_stmt
specifier|static
name|struct
name|search_level
modifier|*
name|search_stack
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|tree
name|lookup_field_1
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|lookup_fnfields_1
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dfs_walk
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|markedp
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dfs_unmark
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dfs_init_vbase_pointers
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|tree
name|vbase_types
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|vbase_decl
decl_stmt|,
name|vbase_decl_ptr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|vbase_decl_ptr_intermediate
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|vbase_init_result
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|saw_first_vbase
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Allocate a level of searching.  */
end_comment

begin_function
specifier|static
name|struct
name|search_level
modifier|*
name|push_search_level
parameter_list|(
name|stack
parameter_list|,
name|obstack
parameter_list|)
name|struct
name|stack_level
modifier|*
name|stack
decl_stmt|;
name|struct
name|obstack
modifier|*
name|obstack
decl_stmt|;
block|{
name|struct
name|search_level
name|tem
decl_stmt|;
name|tem
operator|.
name|prev
operator|=
name|stack
expr_stmt|;
return|return
name|push_stack_level
argument_list|(
name|obstack
argument_list|,
operator|&
name|tem
argument_list|,
sizeof|sizeof
argument_list|(
name|tem
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Discard a level of search allocation.  */
end_comment

begin_define
define|#
directive|define
name|pop_search_level
value|pop_stack_level
end_define

begin_escape
end_escape

begin_comment
comment|/* Search memoization.  */
end_comment

begin_struct
struct|struct
name|type_level
block|{
name|struct
name|stack_level
name|base
decl_stmt|;
comment|/* First object allocated in obstack of entries.  */
name|char
modifier|*
name|entries
decl_stmt|;
comment|/* Number of types memoized in this context.  */
name|int
name|len
decl_stmt|;
comment|/* Type being memoized; save this if we are saving      memoized contexts.  */
name|tree
name|type
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Obstack used for memoizing member and member function lookup.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|obstack
name|type_obstack
decl_stmt|,
name|type_obstack_entries
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|type_level
modifier|*
name|type_stack
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|_vptr_name
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Make things that look like tree nodes, but allocate them    on type_obstack_entries.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|my_tree_node_counter
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|my_tree_cons
argument_list|()
decl_stmt|,
name|my_build_string
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|flag_memoize_lookups
decl_stmt|,
name|flag_save_memoized_contexts
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Variables for gathering statistics.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|my_memoized_entry_counter
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|memoized_fast_finds
index|[
literal|2
index|]
decl_stmt|,
name|memoized_adds
index|[
literal|2
index|]
decl_stmt|,
name|memoized_fast_rejects
index|[
literal|2
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|memoized_fields_searched
index|[
literal|2
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|n_fields_searched
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|n_calls_lookup_field
decl_stmt|,
name|n_calls_lookup_field_1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|n_calls_lookup_fnfields
decl_stmt|,
name|n_calls_lookup_fnfields_1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|n_calls_get_base_type
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|n_outer_fields_searched
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|n_contexts_saved
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Local variables to help save memoization contexts.  */
end_comment

begin_decl_stmt
specifier|static
name|tree
name|prev_type_memoized
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|type_level
modifier|*
name|prev_type_stack
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Allocate a level of type memoization context.  */
end_comment

begin_function
specifier|static
name|struct
name|type_level
modifier|*
name|push_type_level
parameter_list|(
name|stack
parameter_list|,
name|obstack
parameter_list|)
name|struct
name|stack_level
modifier|*
name|stack
decl_stmt|;
name|struct
name|obstack
modifier|*
name|obstack
decl_stmt|;
block|{
name|struct
name|type_level
name|tem
decl_stmt|;
name|tem
operator|.
name|base
operator|.
name|prev
operator|=
name|stack
expr_stmt|;
name|obstack_finish
argument_list|(
operator|&
name|type_obstack_entries
argument_list|)
expr_stmt|;
name|tem
operator|.
name|entries
operator|=
operator|(
name|char
operator|*
operator|)
name|obstack_base
argument_list|(
operator|&
name|type_obstack_entries
argument_list|)
expr_stmt|;
name|tem
operator|.
name|len
operator|=
literal|0
expr_stmt|;
name|tem
operator|.
name|type
operator|=
name|NULL_TREE
expr_stmt|;
return|return
operator|(
expr|struct
name|type_level
operator|*
operator|)
name|push_stack_level
argument_list|(
name|obstack
argument_list|,
operator|&
name|tem
argument_list|,
sizeof|sizeof
argument_list|(
name|tem
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Discard a level of type memoization context.  */
end_comment

begin_function
specifier|static
name|struct
name|type_level
modifier|*
name|pop_type_level
parameter_list|(
name|stack
parameter_list|)
name|struct
name|type_level
modifier|*
name|stack
decl_stmt|;
block|{
name|obstack_free
argument_list|(
operator|&
name|type_obstack_entries
argument_list|,
name|stack
operator|->
name|entries
argument_list|)
expr_stmt|;
return|return
operator|(
expr|struct
name|type_level
operator|*
operator|)
name|pop_stack_level
argument_list|(
operator|(
expr|struct
name|stack_level
operator|*
operator|)
name|stack
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Make something that looks like a TREE_LIST, but    do it on the type_obstack_entries obstack.  */
end_comment

begin_function
specifier|static
name|tree
name|my_tree_cons
parameter_list|(
name|purpose
parameter_list|,
name|value
parameter_list|,
name|chain
parameter_list|)
name|tree
name|purpose
decl_stmt|,
name|value
decl_stmt|,
name|chain
decl_stmt|;
block|{
name|tree
name|p
init|=
operator|(
name|tree
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|type_obstack_entries
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|tree_list
argument_list|)
argument_list|)
decl_stmt|;
operator|++
name|my_tree_node_counter
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|p
argument_list|)
operator|=
literal|0
expr_stmt|;
operator|(
operator|(
name|int
operator|*
operator|)
name|p
operator|)
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
name|TREE_SET_CODE
argument_list|(
name|p
argument_list|,
name|TREE_LIST
argument_list|)
expr_stmt|;
name|TREE_PURPOSE
argument_list|(
name|p
argument_list|)
operator|=
name|purpose
expr_stmt|;
name|TREE_VALUE
argument_list|(
name|p
argument_list|)
operator|=
name|value
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|p
argument_list|)
operator|=
name|chain
expr_stmt|;
return|return
name|p
return|;
block|}
end_function

begin_function
specifier|static
name|tree
name|my_build_string
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|tree
name|p
init|=
operator|(
name|tree
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|type_obstack_entries
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|tree_string
argument_list|)
argument_list|)
decl_stmt|;
operator|++
name|my_tree_node_counter
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|p
argument_list|)
operator|=
literal|0
expr_stmt|;
operator|(
operator|(
name|int
operator|*
operator|)
name|p
operator|)
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
name|TREE_SET_CODE
argument_list|(
name|p
argument_list|,
name|STRING_CST
argument_list|)
expr_stmt|;
name|TREE_STRING_POINTER
argument_list|(
name|p
argument_list|)
operator|=
name|str
expr_stmt|;
name|TREE_STRING_LENGTH
argument_list|(
name|p
argument_list|)
operator|=
name|strlen
argument_list|(
name|str
argument_list|)
expr_stmt|;
return|return
name|p
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Memoizing machinery to make searches for multiple inheritance    reasonably efficient.  */
end_comment

begin_define
define|#
directive|define
name|MEMOIZE_HASHSIZE
value|8
end_define

begin_typedef
typedef|typedef
struct|struct
name|memoized_entry
block|{
name|struct
name|memoized_entry
modifier|*
name|chain
decl_stmt|;
name|int
name|uid
decl_stmt|;
name|tree
name|data_members
index|[
name|MEMOIZE_HASHSIZE
index|]
decl_stmt|;
name|tree
name|function_members
index|[
name|MEMOIZE_HASHSIZE
index|]
decl_stmt|;
block|}
typedef|*
name|ME
typedef|;
end_typedef

begin_define
define|#
directive|define
name|MEMOIZED_CHAIN
parameter_list|(
name|ENTRY
parameter_list|)
value|(((ME)ENTRY)->chain)
end_define

begin_define
define|#
directive|define
name|MEMOIZED_UID
parameter_list|(
name|ENTRY
parameter_list|)
value|(((ME)ENTRY)->uid)
end_define

begin_define
define|#
directive|define
name|MEMOIZED_FIELDS
parameter_list|(
name|ENTRY
parameter_list|,
name|INDEX
parameter_list|)
value|(((ME)ENTRY)->data_members[INDEX])
end_define

begin_define
define|#
directive|define
name|MEMOIZED_FNFIELDS
parameter_list|(
name|ENTRY
parameter_list|,
name|INDEX
parameter_list|)
value|(((ME)ENTRY)->function_members[INDEX])
end_define

begin_comment
comment|/* The following is probably a lousy hash function.  */
end_comment

begin_define
define|#
directive|define
name|MEMOIZED_HASH_FN
parameter_list|(
name|NODE
parameter_list|)
value|(((long)(NODE)>>4)&(MEMOIZE_HASHSIZE - 1))
end_define

begin_function
specifier|static
name|struct
name|memoized_entry
modifier|*
name|my_new_memoized_entry
parameter_list|(
name|chain
parameter_list|)
name|struct
name|memoized_entry
modifier|*
name|chain
decl_stmt|;
block|{
name|struct
name|memoized_entry
modifier|*
name|p
init|=
operator|(
expr|struct
name|memoized_entry
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|type_obstack_entries
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|memoized_entry
argument_list|)
argument_list|)
decl_stmt|;
name|bzero
argument_list|(
name|p
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|memoized_entry
argument_list|)
argument_list|)
expr_stmt|;
name|MEMOIZED_CHAIN
argument_list|(
name|p
argument_list|)
operator|=
name|chain
expr_stmt|;
name|MEMOIZED_UID
argument_list|(
name|p
argument_list|)
operator|=
operator|++
name|my_memoized_entry_counter
expr_stmt|;
return|return
name|p
return|;
block|}
end_function

begin_comment
comment|/* Make an entry in the memoized table for type TYPE    that the entry for NAME is FIELD.  */
end_comment

begin_function
name|tree
name|make_memoized_table_entry
parameter_list|(
name|type
parameter_list|,
name|name
parameter_list|,
name|function_p
parameter_list|)
name|tree
name|type
decl_stmt|,
name|name
decl_stmt|;
name|int
name|function_p
decl_stmt|;
block|{
name|int
name|index
init|=
name|MEMOIZED_HASH_FN
argument_list|(
name|name
argument_list|)
decl_stmt|;
name|tree
name|entry
decl_stmt|,
modifier|*
name|prev_entry
decl_stmt|;
name|memoized_adds
index|[
name|function_p
index|]
operator|+=
literal|1
expr_stmt|;
if|if
condition|(
name|CLASSTYPE_MTABLE_ENTRY
argument_list|(
name|type
argument_list|)
operator|==
literal|0
condition|)
block|{
name|obstack_ptr_grow
argument_list|(
operator|&
name|type_obstack
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|obstack_blank
argument_list|(
operator|&
name|type_obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|memoized_entry
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|CLASSTYPE_MTABLE_ENTRY
argument_list|(
name|type
argument_list|)
operator|=
operator|(
name|char
operator|*
operator|)
name|my_new_memoized_entry
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|type_stack
operator|->
name|len
operator|++
expr_stmt|;
if|if
condition|(
name|type_stack
operator|->
name|len
operator|*
literal|2
operator|>=
name|type_stack
operator|->
name|base
operator|.
name|limit
condition|)
name|my_friendly_abort
argument_list|(
literal|88
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|function_p
condition|)
name|prev_entry
operator|=
operator|&
name|MEMOIZED_FNFIELDS
argument_list|(
name|CLASSTYPE_MTABLE_ENTRY
argument_list|(
name|type
argument_list|)
argument_list|,
name|index
argument_list|)
expr_stmt|;
else|else
name|prev_entry
operator|=
operator|&
name|MEMOIZED_FIELDS
argument_list|(
name|CLASSTYPE_MTABLE_ENTRY
argument_list|(
name|type
argument_list|)
argument_list|,
name|index
argument_list|)
expr_stmt|;
name|entry
operator|=
name|my_tree_cons
argument_list|(
name|name
argument_list|,
literal|0
argument_list|,
operator|*
name|prev_entry
argument_list|)
expr_stmt|;
operator|*
name|prev_entry
operator|=
name|entry
expr_stmt|;
comment|/* Don't know the error message to give yet.  */
name|TREE_TYPE
argument_list|(
name|entry
argument_list|)
operator|=
name|error_mark_node
expr_stmt|;
return|return
name|entry
return|;
block|}
end_function

begin_comment
comment|/* When a new function or class context is entered, we build    a table of types which have been searched for members.    The table is an array (obstack) of types.  When a type is    entered into the obstack, its CLASSTYPE_MTABLE_ENTRY    field is set to point to a new record, of type struct memoized_entry.     A non-NULL TREE_TYPE of the entry contains a visibility error message.     The slots for the data members are arrays of tree nodes.    These tree nodes are lists, with the TREE_PURPOSE    of this list the known member name, and the TREE_VALUE    as the FIELD_DECL for the member.     For member functions, the TREE_PURPOSE is again the    name of the member functions for that class,    and the TREE_VALUE of the list is a pairs    whose TREE_PURPOSE is a member functions of this name,    and whose TREE_VALUE is a list of known argument lists this    member function has been called with.  The TREE_TYPE of the pair,    if non-NULL, is an error message to print.  */
end_comment

begin_comment
comment|/* Tell search machinery that we are entering a new context, and    to update tables appropriately.     TYPE is the type of the context we are entering, which can    be NULL_TREE if we are not in a class's scope.     USE_OLD, if nonzero tries to use previous context.  */
end_comment

begin_function
name|void
name|push_memoized_context
parameter_list|(
name|type
parameter_list|,
name|use_old
parameter_list|)
name|tree
name|type
decl_stmt|;
name|int
name|use_old
decl_stmt|;
block|{
name|int
name|len
decl_stmt|;
name|tree
modifier|*
name|tem
decl_stmt|;
if|if
condition|(
name|prev_type_stack
condition|)
block|{
if|if
condition|(
name|use_old
operator|&&
name|prev_type_memoized
operator|==
name|type
condition|)
block|{
ifdef|#
directive|ifdef
name|GATHER_STATISTICS
name|n_contexts_saved
operator|++
expr_stmt|;
endif|#
directive|endif
name|type_stack
operator|=
name|prev_type_stack
expr_stmt|;
name|prev_type_stack
operator|=
literal|0
expr_stmt|;
name|tem
operator|=
operator|&
name|type_stack
operator|->
name|base
operator|.
name|first
index|[
literal|0
index|]
expr_stmt|;
name|len
operator|=
name|type_stack
operator|->
name|len
expr_stmt|;
while|while
condition|(
name|len
operator|--
condition|)
name|CLASSTYPE_MTABLE_ENTRY
argument_list|(
name|tem
index|[
name|len
operator|*
literal|2
index|]
argument_list|)
operator|=
operator|(
name|char
operator|*
operator|)
name|tem
index|[
name|len
operator|*
literal|2
operator|+
literal|1
index|]
expr_stmt|;
return|return;
block|}
comment|/* Otherwise, need to pop old stack here.  */
name|type_stack
operator|=
name|pop_type_level
argument_list|(
name|prev_type_stack
argument_list|)
expr_stmt|;
name|prev_type_memoized
operator|=
literal|0
expr_stmt|;
name|prev_type_stack
operator|=
literal|0
expr_stmt|;
block|}
name|type_stack
operator|=
name|push_type_level
argument_list|(
operator|(
expr|struct
name|stack_level
operator|*
operator|)
name|type_stack
argument_list|,
operator|&
name|type_obstack
argument_list|)
expr_stmt|;
name|type_stack
operator|->
name|type
operator|=
name|type
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Tell search machinery that we have left a context.    We do not currently save these contexts for later use.    If we wanted to, we could not use pop_search_level, since    poping that level allows the data we have collected to    be clobbered; a stack of obstacks would be needed.  */
end_comment

begin_function
name|void
name|pop_memoized_context
parameter_list|(
name|use_old
parameter_list|)
name|int
name|use_old
decl_stmt|;
block|{
name|int
name|len
decl_stmt|;
name|tree
modifier|*
name|tem
init|=
operator|&
name|type_stack
operator|->
name|base
operator|.
name|first
index|[
literal|0
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|flag_save_memoized_contexts
condition|)
name|use_old
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|use_old
condition|)
block|{
name|len
operator|=
name|type_stack
operator|->
name|len
expr_stmt|;
while|while
condition|(
name|len
operator|--
condition|)
name|tem
index|[
name|len
operator|*
literal|2
operator|+
literal|1
index|]
operator|=
operator|(
name|tree
operator|)
name|CLASSTYPE_MTABLE_ENTRY
argument_list|(
name|tem
index|[
name|len
operator|*
literal|2
index|]
argument_list|)
expr_stmt|;
name|prev_type_stack
operator|=
name|type_stack
expr_stmt|;
name|prev_type_memoized
operator|=
name|type_stack
operator|->
name|type
expr_stmt|;
block|}
if|if
condition|(
name|flag_memoize_lookups
condition|)
block|{
name|len
operator|=
name|type_stack
operator|->
name|len
expr_stmt|;
while|while
condition|(
name|len
operator|--
condition|)
name|CLASSTYPE_MTABLE_ENTRY
argument_list|(
name|tem
index|[
name|len
operator|*
literal|2
index|]
argument_list|)
operator|=
operator|(
name|char
operator|*
operator|)
name|MEMOIZED_CHAIN
argument_list|(
name|CLASSTYPE_MTABLE_ENTRY
argument_list|(
name|tem
index|[
name|len
operator|*
literal|2
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|use_old
condition|)
name|type_stack
operator|=
name|pop_type_level
argument_list|(
name|type_stack
argument_list|)
expr_stmt|;
else|else
name|type_stack
operator|=
operator|(
expr|struct
name|type_level
operator|*
operator|)
name|type_stack
operator|->
name|base
operator|.
name|prev
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Recursively search for a path from PARENT to BINFO.    If RVAL is> 0 and we succeed, update the BINFO_NEXT_BINFO    pointers.    If we find a distinct basetype that's not the one from BINFO,    return -2;    If we don't find any path, return 0.     If we encounter a virtual basetype on the path, return RVAL    and don't change any pointers after that point.  */
end_comment

begin_function
specifier|static
name|int
name|recursive_bounded_basetype_p
parameter_list|(
name|parent
parameter_list|,
name|binfo
parameter_list|,
name|rval
parameter_list|,
name|update_chain
parameter_list|)
name|tree
name|parent
decl_stmt|,
name|binfo
decl_stmt|;
name|int
name|rval
decl_stmt|;
name|int
name|update_chain
decl_stmt|;
block|{
name|tree
name|binfos
decl_stmt|;
if|if
condition|(
name|BINFO_TYPE
argument_list|(
name|parent
argument_list|)
operator|==
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
condition|)
block|{
if|if
condition|(
name|tree_int_cst_equal
argument_list|(
name|BINFO_OFFSET
argument_list|(
name|parent
argument_list|)
argument_list|,
name|BINFO_OFFSET
argument_list|(
name|binfo
argument_list|)
argument_list|)
condition|)
return|return
name|rval
return|;
return|return
operator|-
literal|2
return|;
block|}
if|if
condition|(
name|TREE_VIA_VIRTUAL
argument_list|(
name|binfo
argument_list|)
condition|)
name|update_chain
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|binfos
operator|=
name|BINFO_BASETYPES
argument_list|(
name|binfo
argument_list|)
condition|)
block|{
name|int
name|i
decl_stmt|,
name|nval
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TREE_VEC_LENGTH
argument_list|(
name|binfos
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|nval
operator|=
name|recursive_bounded_basetype_p
argument_list|(
name|parent
argument_list|,
name|TREE_VEC_ELT
argument_list|(
name|binfos
argument_list|,
name|i
argument_list|)
argument_list|,
name|rval
argument_list|,
name|update_chain
argument_list|)
expr_stmt|;
if|if
condition|(
name|nval
operator|<
literal|0
condition|)
return|return
name|nval
return|;
if|if
condition|(
name|nval
operator|>
literal|0
operator|&&
name|update_chain
condition|)
name|BINFO_INHERITANCE_CHAIN
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|binfos
argument_list|,
name|i
argument_list|)
argument_list|)
operator|=
name|binfo
expr_stmt|;
block|}
return|return
name|rval
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Check whether the type given in BINFO is derived from PARENT.  If    it isn't, return 0.  If it is, but the derivation is MI-ambiguous    AND protect != 0, emit an error message and return error_mark_node.     Otherwise, if TYPE is derived from PARENT, return the actual base    information, unless a one of the protection violations below    occurs, in which case emit an error message and return error_mark_node.     The below should be worded better.  It may not be exactly what the code    does, but there should be a lose correlation.  If you understand the code    well, please try and make the comments below more readable.     If PROTECT is 1, then check if access to a public field of PARENT    would be private.     If PROTECT is 2, then check if the given type is derived from    PARENT via private visibility rules.     If PROTECT is 3, then immediately private baseclass is ok,    but deeper than that, check if private.  */
end_comment

begin_function
name|tree
name|get_binfo
parameter_list|(
name|parent
parameter_list|,
name|binfo
parameter_list|,
name|protect
parameter_list|)
specifier|register
name|tree
name|parent
decl_stmt|,
name|binfo
decl_stmt|;
block|{
name|tree
name|xtype
decl_stmt|,
name|type
decl_stmt|;
name|tree
name|otype
decl_stmt|;
name|int
name|head
init|=
literal|0
decl_stmt|,
name|tail
init|=
literal|0
decl_stmt|;
name|int
name|is_private
init|=
literal|0
decl_stmt|;
name|tree
name|rval
init|=
name|NULL_TREE
decl_stmt|;
name|int
name|rval_private
init|=
literal|0
decl_stmt|;
name|tree
name|friends
decl_stmt|;
ifdef|#
directive|ifdef
name|GATHER_STATISTICS
name|n_calls_get_base_type
operator|++
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|TREE_CODE
argument_list|(
name|parent
argument_list|)
operator|==
name|TREE_VEC
condition|)
name|parent
operator|=
name|BINFO_TYPE
argument_list|(
name|parent
argument_list|)
expr_stmt|;
comment|/* unions cannot participate in inheritance relationships */
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|parent
argument_list|)
operator|==
name|UNION_TYPE
condition|)
return|return
literal|0
return|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|parent
argument_list|)
operator|!=
name|RECORD_TYPE
condition|)
name|my_friendly_abort
argument_list|(
literal|89
argument_list|)
expr_stmt|;
name|parent
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|parent
argument_list|)
expr_stmt|;
name|search_stack
operator|=
name|push_search_level
argument_list|(
name|search_stack
argument_list|,
operator|&
name|search_obstack
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|binfo
argument_list|)
operator|==
name|TREE_VEC
condition|)
name|type
operator|=
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|binfo
argument_list|)
operator|==
name|RECORD_TYPE
condition|)
block|{
name|type
operator|=
name|binfo
expr_stmt|;
name|binfo
operator|=
name|TYPE_BINFO
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
else|else
name|my_friendly_abort
argument_list|(
literal|90
argument_list|)
expr_stmt|;
name|xtype
operator|=
name|type
expr_stmt|;
name|friends
operator|=
name|current_class_type
condition|?
name|CLASSTYPE_FRIEND_CLASSES
argument_list|(
name|type
argument_list|)
else|:
name|NULL_TREE
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|tree
name|binfos
init|=
name|BINFO_BASETYPES
argument_list|(
name|binfo
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|,
name|n_baselinks
init|=
name|binfos
condition|?
name|TREE_VEC_LENGTH
argument_list|(
name|binfos
argument_list|)
else|:
literal|0
decl_stmt|;
comment|/* Process and/or queue base types.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_baselinks
condition|;
name|i
operator|++
control|)
block|{
name|tree
name|base_binfo
init|=
name|TREE_VEC_ELT
argument_list|(
name|binfos
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|BINFO_MARKED
argument_list|(
name|base_binfo
argument_list|)
operator|==
literal|0
condition|)
block|{
name|int
name|via_private
init|=
name|is_private
operator|||
operator|!
name|TREE_VIA_PUBLIC
argument_list|(
name|base_binfo
argument_list|)
decl_stmt|;
name|SET_BINFO_MARKED
argument_list|(
name|base_binfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|via_private
operator|==
literal|0
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|protect
operator|==
literal|0
condition|)
name|via_private
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|protect
operator|==
literal|1
operator|&&
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
operator|==
name|current_class_type
condition|)
comment|/* The immediate base class of the class we are in 		   does let its public members through.  */
name|via_private
operator|=
literal|0
expr_stmt|;
ifndef|#
directive|ifndef
name|NOJJG
elseif|else
if|if
condition|(
name|protect
operator|&&
name|friends
operator|!=
name|NULL_TREE
operator|&&
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
operator|==
name|xtype
operator|&&
name|value_member
argument_list|(
name|current_class_type
argument_list|,
name|friends
argument_list|)
condition|)
comment|/* Friend types of the most derived type have access 		   to its baseclass pointers.  */
name|via_private
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
name|otype
operator|=
name|type
expr_stmt|;
name|obstack_ptr_grow
argument_list|(
operator|&
name|search_obstack
argument_list|,
name|base_binfo
argument_list|)
expr_stmt|;
name|obstack_int_grow
argument_list|(
operator|&
name|search_obstack
argument_list|,
name|via_private
argument_list|)
expr_stmt|;
name|tail
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
name|tail
operator|>=
name|search_stack
operator|->
name|limit
condition|)
name|my_friendly_abort
argument_list|(
literal|91
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
literal|0
comment|/* This code cannot possibly be right.  Ambiguities can only be 	     checked by traversing the whole tree, and seeing if it pops 	     up twice. */
block|else if (protect&& ! TREE_VIA_VIRTUAL (base_binfo)) 	    { 	      error_with_aggr_type (parent, "type `%s' is ambiguous base class for type `%s'", 				    TYPE_NAME_STRING (xtype)); 	      error ("(base class for types `%s' and `%s')", 		     TYPE_NAME_STRING (BINFO_TYPE (binfo)), 		     TYPE_NAME_STRING (otype)); 	      rval = error_mark_node; 	      goto cleanup; 	    }
endif|#
directive|endif
block|}
name|dont_queue
label|:
comment|/* Process head of queue, if one exists.  */
if|if
condition|(
name|head
operator|>=
name|tail
condition|)
break|break;
name|binfo
operator|=
name|search_stack
operator|->
name|first
index|[
name|head
operator|++
index|]
expr_stmt|;
name|is_private
operator|=
operator|(
name|HOST_WIDE_INT
operator|)
name|search_stack
operator|->
name|first
index|[
name|head
operator|++
index|]
expr_stmt|;
if|if
condition|(
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
operator|==
name|parent
condition|)
block|{
if|if
condition|(
name|rval
operator|==
literal|0
condition|)
block|{
name|rval
operator|=
name|binfo
expr_stmt|;
name|rval_private
operator|=
name|is_private
expr_stmt|;
block|}
elseif|else
comment|/* I believe it is the case that this error is only an error when 	       used by someone that wants error messages printed.  Routines that 	       call this one, that don't set protect want the first one found, 	       even if there are more.  */
if|if
condition|(
name|protect
condition|)
block|{
comment|/* Found two or more possible return values.  */
name|error_with_aggr_type
argument_list|(
name|parent
argument_list|,
literal|"type `%s' is ambiguous base class for type `%s'"
argument_list|,
name|TYPE_NAME_STRING
argument_list|(
name|xtype
argument_list|)
argument_list|)
expr_stmt|;
name|rval
operator|=
name|error_mark_node
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
goto|goto
name|dont_queue
goto|;
block|}
block|}
name|cleanup
label|:
block|{
name|tree
modifier|*
name|tp
init|=
name|search_stack
operator|->
name|first
decl_stmt|;
name|tree
modifier|*
name|search_tail
init|=
name|tp
operator|+
name|tail
decl_stmt|;
while|while
condition|(
name|tp
operator|<
name|search_tail
condition|)
block|{
name|CLEAR_BINFO_MARKED
argument_list|(
operator|*
name|tp
argument_list|)
expr_stmt|;
name|tp
operator|+=
literal|2
expr_stmt|;
block|}
block|}
name|search_stack
operator|=
name|pop_search_level
argument_list|(
name|search_stack
argument_list|)
expr_stmt|;
if|if
condition|(
name|rval
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
name|rval
operator|&&
name|protect
operator|&&
name|rval_private
condition|)
block|{
if|if
condition|(
name|protect
operator|==
literal|3
condition|)
block|{
name|tree
name|binfos
init|=
name|BINFO_BASETYPES
argument_list|(
name|TYPE_BINFO
argument_list|(
name|xtype
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|,
name|n_baselinks
init|=
name|binfos
condition|?
name|TREE_VEC_LENGTH
argument_list|(
name|binfos
argument_list|)
else|:
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_baselinks
condition|;
name|i
operator|++
control|)
block|{
name|tree
name|base_binfo
init|=
name|TREE_VEC_ELT
argument_list|(
name|binfos
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|parent
operator|==
name|BINFO_TYPE
argument_list|(
name|base_binfo
argument_list|)
condition|)
comment|/* It's ok, since it's immediate.  */
return|return
name|rval
return|;
block|}
block|}
name|error_with_aggr_type
argument_list|(
name|xtype
argument_list|,
literal|"type `%s' is derived from private `%s'"
argument_list|,
name|TYPE_NAME_STRING
argument_list|(
name|parent
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
return|return
name|rval
return|;
block|}
end_function

begin_comment
comment|/* -------------------------------------------------- */
end_comment

begin_comment
comment|/* These two routines are ONLY here to check for ambiguities for    get_base_distance, as it probably cannot check by itself for    all ambiguities.  When get_base_distance is sure to check for all,    these routines can go.  (mrs) */
end_comment

begin_function
name|tree
name|get_binfo2_recursive
parameter_list|(
name|binfo
parameter_list|,
name|parent
parameter_list|,
name|type
parameter_list|)
specifier|register
name|tree
name|binfo
decl_stmt|,
name|parent
decl_stmt|;
name|tree
name|type
decl_stmt|;
block|{
name|tree
name|rval
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|nrval
decl_stmt|;
name|tree
name|binfos
init|=
name|BINFO_BASETYPES
argument_list|(
name|binfo
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|,
name|n_baselinks
init|=
name|binfos
condition|?
name|TREE_VEC_LENGTH
argument_list|(
name|binfos
argument_list|)
else|:
literal|0
decl_stmt|;
if|if
condition|(
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
operator|==
name|parent
condition|)
block|{
return|return
name|binfo
return|;
block|}
comment|/* Process base types.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_baselinks
condition|;
name|i
operator|++
control|)
block|{
name|tree
name|base_binfo
init|=
name|TREE_VEC_ELT
argument_list|(
name|binfos
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|BINFO_MARKED
argument_list|(
name|base_binfo
argument_list|)
operator|==
literal|0
condition|)
block|{
name|SET_BINFO_MARKED
argument_list|(
name|base_binfo
argument_list|)
expr_stmt|;
name|nrval
operator|=
name|get_binfo2_recursive
argument_list|(
name|base_binfo
argument_list|,
name|parent
argument_list|,
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|nrval
operator|==
name|error_mark_node
condition|)
return|return
name|nrval
return|;
if|if
condition|(
name|nrval
condition|)
if|if
condition|(
name|rval
operator|==
literal|0
condition|)
block|{
name|rval
operator|=
name|nrval
expr_stmt|;
block|}
else|else
return|return
name|error_mark_node
return|;
block|}
block|}
return|return
name|rval
return|;
block|}
end_function

begin_function
name|tree
name|get_binfo2
parameter_list|(
name|parent
parameter_list|,
name|binfo
parameter_list|)
specifier|register
name|tree
name|parent
decl_stmt|,
name|binfo
decl_stmt|;
block|{
name|tree
name|type
decl_stmt|;
name|tree
name|rval
init|=
name|NULL_TREE
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|parent
argument_list|)
operator|==
name|TREE_VEC
condition|)
name|parent
operator|=
name|BINFO_TYPE
argument_list|(
name|parent
argument_list|)
expr_stmt|;
comment|/* unions cannot participate in inheritance relationships */
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|parent
argument_list|)
operator|==
name|UNION_TYPE
condition|)
return|return
literal|0
return|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|parent
argument_list|)
operator|!=
name|RECORD_TYPE
condition|)
name|my_friendly_abort
argument_list|(
literal|89
argument_list|)
expr_stmt|;
name|parent
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|parent
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|binfo
argument_list|)
operator|==
name|TREE_VEC
condition|)
name|type
operator|=
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|binfo
argument_list|)
operator|==
name|RECORD_TYPE
condition|)
block|{
name|type
operator|=
name|binfo
expr_stmt|;
name|binfo
operator|=
name|TYPE_BINFO
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
else|else
name|my_friendly_abort
argument_list|(
literal|90
argument_list|)
expr_stmt|;
name|rval
operator|=
name|get_binfo2_recursive
argument_list|(
name|binfo
argument_list|,
name|parent
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|dfs_walk
argument_list|(
name|binfo
argument_list|,
name|dfs_unmark
argument_list|,
name|markedp
argument_list|)
expr_stmt|;
return|return
name|rval
return|;
block|}
end_function

begin_comment
comment|/* -------------------------------------------------- */
end_comment

begin_comment
comment|/* Return the number of levels between type PARENT and the type given    in BINFO, following the leftmost path to PARENT.  If PARENT is its    own main type variant, then if PARENT appears in different places    from TYPE's point of view, the leftmost PARENT will be the one    chosen.     The term `leftmost' should be defined in g++int.texi and the    significance should be explained.  If it is, this message should be    deleted, if not, and you understand the term, please add    documentation for it in g++int.texi.  Also, the part about the    ``PARENT is its own main type variant'' should give reasons when    and why this happens, and why it is important, and a better    explaination of what this routine does both when that is true and    when it is not.     Return -1 if TYPE is not derived from PARENT.    Return -2 if PARENT is an ambiguous base class of TYPE.    Return -3 if PARENT is private to TYPE, and protect is non-zero.     If PATH_PTR is non-NULL, then also build the list of types    from PARENT to TYPE, with TREE_VIA_VIRUAL and TREE_VIA_PUBLIC    set.     It is unclear whether or not the path should be built if -2 and/or    -3 is returned.  Maybe, maybe not.  I suspect that there is code    that relies upon it being built, such as prepare_fresh_vtable.    (mrs)     Also, it would appear that we only sometimes want -2.  The question is    under what exact conditions do we want to see -2, and when do we not    want to see -2.  (mrs)     It is also unlikely that this thing finds all ambiguties, as I    don't trust any deviation from the method used in get_binfo.  It    would be nice to use that method here, as it is simple and straight    forward.  The code here and in recursive_bounded_basetype_p is not.    For now, I shall include an extra call to find ambiguities.  (mrs)    */
end_comment

begin_function
name|int
name|get_base_distance
parameter_list|(
name|parent
parameter_list|,
name|binfo
parameter_list|,
name|protect
parameter_list|,
name|path_ptr
parameter_list|)
specifier|register
name|tree
name|parent
decl_stmt|,
name|binfo
decl_stmt|;
name|int
name|protect
decl_stmt|;
name|tree
modifier|*
name|path_ptr
decl_stmt|;
block|{
name|int
name|head
decl_stmt|,
name|tail
decl_stmt|;
name|int
name|is_private
init|=
literal|0
decl_stmt|;
name|int
name|rval
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|depth
init|=
literal|0
decl_stmt|;
name|int
name|rval_private
init|=
literal|0
decl_stmt|;
name|tree
name|type
decl_stmt|,
name|basetype_path
decl_stmt|;
name|tree
name|friends
decl_stmt|;
name|int
name|use_leftmost
decl_stmt|;
if|if
condition|(
name|TYPE_READONLY
argument_list|(
name|parent
argument_list|)
operator|||
name|TYPE_VOLATILE
argument_list|(
name|parent
argument_list|)
condition|)
name|parent
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|parent
argument_list|)
expr_stmt|;
name|use_leftmost
operator|=
operator|(
name|parent
operator|==
name|TYPE_MAIN_VARIANT
argument_list|(
name|parent
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|binfo
argument_list|)
operator|==
name|TREE_VEC
condition|)
name|type
operator|=
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|binfo
argument_list|)
operator|==
name|RECORD_TYPE
condition|)
block|{
name|type
operator|=
name|binfo
expr_stmt|;
name|binfo
operator|=
name|TYPE_BINFO
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
else|else
name|my_friendly_abort
argument_list|(
literal|92
argument_list|)
expr_stmt|;
name|friends
operator|=
name|current_class_type
condition|?
name|CLASSTYPE_FRIEND_CLASSES
argument_list|(
name|type
argument_list|)
else|:
name|NULL_TREE
expr_stmt|;
if|if
condition|(
name|path_ptr
condition|)
block|{
name|basetype_path
operator|=
name|TYPE_BINFO
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|BINFO_INHERITANCE_CHAIN
argument_list|(
name|basetype_path
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
block|}
if|if
condition|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|parent
argument_list|)
operator|==
name|type
condition|)
block|{
comment|/* If the distance is 0, then we don't really need 	 a path pointer, but we shouldn't let garbage go back.  */
if|if
condition|(
name|path_ptr
condition|)
operator|*
name|path_ptr
operator|=
name|basetype_path
expr_stmt|;
return|return
literal|0
return|;
block|}
name|search_stack
operator|=
name|push_search_level
argument_list|(
name|search_stack
argument_list|,
operator|&
name|search_obstack
argument_list|)
expr_stmt|;
comment|/* Keep space for TYPE.  */
name|obstack_ptr_grow
argument_list|(
operator|&
name|search_obstack
argument_list|,
name|binfo
argument_list|)
expr_stmt|;
name|obstack_int_grow
argument_list|(
operator|&
name|search_obstack
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|obstack_int_grow
argument_list|(
operator|&
name|search_obstack
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|path_ptr
condition|)
block|{
name|obstack_ptr_grow
argument_list|(
operator|&
name|search_obstack
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|head
operator|=
literal|4
expr_stmt|;
block|}
else|else
name|head
operator|=
literal|3
expr_stmt|;
name|tail
operator|=
name|head
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|tree
name|binfos
init|=
name|BINFO_BASETYPES
argument_list|(
name|binfo
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|,
name|n_baselinks
init|=
name|binfos
condition|?
name|TREE_VEC_LENGTH
argument_list|(
name|binfos
argument_list|)
else|:
literal|0
decl_stmt|;
comment|/* Process and/or queue base types.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_baselinks
condition|;
name|i
operator|++
control|)
block|{
name|tree
name|base_binfo
init|=
name|TREE_VEC_ELT
argument_list|(
name|binfos
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|BINFO_MARKED
argument_list|(
name|base_binfo
argument_list|)
operator|==
literal|0
condition|)
block|{
name|int
name|via_private
init|=
name|is_private
operator|||
operator|!
name|TREE_VIA_PUBLIC
argument_list|(
name|base_binfo
argument_list|)
decl_stmt|;
name|SET_BINFO_MARKED
argument_list|(
name|base_binfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|via_private
operator|==
literal|0
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|protect
operator|==
literal|0
condition|)
name|via_private
operator|=
literal|0
expr_stmt|;
name|obstack_ptr_grow
argument_list|(
operator|&
name|search_obstack
argument_list|,
name|base_binfo
argument_list|)
expr_stmt|;
name|obstack_int_grow
argument_list|(
operator|&
name|search_obstack
argument_list|,
name|depth
argument_list|)
expr_stmt|;
name|obstack_int_grow
argument_list|(
operator|&
name|search_obstack
argument_list|,
name|via_private
argument_list|)
expr_stmt|;
name|tail
operator|+=
literal|3
expr_stmt|;
if|if
condition|(
name|path_ptr
condition|)
block|{
name|obstack_ptr_grow
argument_list|(
operator|&
name|search_obstack
argument_list|,
name|basetype_path
argument_list|)
expr_stmt|;
name|tail
operator|+=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|tail
operator|>=
name|search_stack
operator|->
name|limit
condition|)
name|my_friendly_abort
argument_list|(
literal|93
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
literal|0
comment|/* This code cannot possibly be right.  Ambiguities can only be 	     checked by traversing the whole tree, and seeing if it pops 	     up twice. */
block|else if (! TREE_VIA_VIRTUAL (base_binfo)) 	    { 	      rval = -2; 	      goto done; 	    }
endif|#
directive|endif
block|}
comment|/* Process head of queue, if one exists.  */
if|if
condition|(
name|head
operator|>=
name|tail
condition|)
break|break;
name|binfo
operator|=
name|search_stack
operator|->
name|first
index|[
name|head
operator|++
index|]
expr_stmt|;
name|depth
operator|=
operator|(
name|HOST_WIDE_INT
operator|)
name|search_stack
operator|->
name|first
index|[
name|head
operator|++
index|]
operator|+
literal|1
expr_stmt|;
name|is_private
operator|=
operator|(
name|HOST_WIDE_INT
operator|)
name|search_stack
operator|->
name|first
index|[
name|head
operator|++
index|]
expr_stmt|;
if|if
condition|(
name|path_ptr
condition|)
block|{
name|basetype_path
operator|=
name|search_stack
operator|->
name|first
index|[
name|head
operator|++
index|]
expr_stmt|;
name|BINFO_INHERITANCE_CHAIN
argument_list|(
name|binfo
argument_list|)
operator|=
name|basetype_path
expr_stmt|;
name|basetype_path
operator|=
name|binfo
expr_stmt|;
block|}
if|if
condition|(
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
operator|==
name|parent
condition|)
block|{
comment|/* It is wrong to set this and break, the proper thing to do 	     would be to set it only if it has not been set before, 	     and if is has been set, an ambiguity exists, and just 	     continue searching the tree for more of them as is done 	     in get_binfo.  But until the code below can cope, this 	     can't be done. Also, it is not clear what should happen if 	     use_leftmost is set.  */
name|rval
operator|=
name|depth
expr_stmt|;
name|rval_private
operator|=
name|is_private
expr_stmt|;
break|break;
block|}
block|}
if|#
directive|if
literal|0
comment|/* Unneeded now, as we know the above code in the #if 0 is wrong.  */
block|done:
endif|#
directive|endif
block|{
name|int
name|increment
init|=
name|path_ptr
condition|?
literal|4
else|:
literal|3
decl_stmt|;
name|tree
modifier|*
name|tp
init|=
name|search_stack
operator|->
name|first
decl_stmt|;
name|tree
modifier|*
name|search_tail
init|=
name|tp
operator|+
name|tail
decl_stmt|;
comment|/* We can skip the first entry, since it wasn't marked.  */
name|tp
operator|+=
name|increment
expr_stmt|;
name|basetype_path
operator|=
name|binfo
expr_stmt|;
while|while
condition|(
name|tp
operator|<
name|search_tail
condition|)
block|{
name|CLEAR_BINFO_MARKED
argument_list|(
operator|*
name|tp
argument_list|)
expr_stmt|;
name|tp
operator|+=
name|increment
expr_stmt|;
block|}
comment|/* Now, guarantee that we are following the leftmost path in the        chain.  Algorithm: the search stack holds tuples in BFS order.        The last tuple on the search stack contains the tentative binfo        for the basetype we are looking for.  We know that starting        with FIRST, each tuple with only a single basetype must be on        the leftmost path.  Each time we come to a split, we select        the tuple for the leftmost basetype that can reach the ultimate        basetype.  */
if|if
condition|(
name|use_leftmost
operator|&&
name|rval
operator|>
literal|0
operator|&&
operator|(
operator|!
name|BINFO_OFFSET_ZEROP
argument_list|(
name|binfo
argument_list|)
operator|||
name|TREE_VIA_VIRTUAL
argument_list|(
name|binfo
argument_list|)
operator|)
condition|)
block|{
name|tree
name|tp_binfos
decl_stmt|;
comment|/* Farm out the tuples with a single basetype.  */
for|for
control|(
name|tp
operator|=
name|search_stack
operator|->
name|first
init|;
name|tp
operator|<
name|search_tail
condition|;
name|tp
operator|+=
name|increment
control|)
block|{
name|tp_binfos
operator|=
name|BINFO_BASETYPES
argument_list|(
operator|*
name|tp
argument_list|)
expr_stmt|;
if|if
condition|(
name|tp_binfos
operator|&&
name|TREE_VEC_LENGTH
argument_list|(
name|tp_binfos
argument_list|)
operator|>
literal|1
condition|)
break|break;
block|}
if|if
condition|(
name|tp
operator|<
name|search_tail
condition|)
block|{
comment|/* Pick the best path.  */
name|tree
name|base_binfo
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TREE_VEC_LENGTH
argument_list|(
name|tp_binfos
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|base_binfo
operator|=
name|TREE_VEC_ELT
argument_list|(
name|tp_binfos
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|tp
operator|+
operator|(
operator|(
name|i
operator|+
literal|1
operator|)
operator|*
name|increment
operator|)
operator|<
name|search_tail
condition|)
name|my_friendly_assert
argument_list|(
name|base_binfo
operator|==
name|tp
index|[
operator|(
name|i
operator|+
literal|1
operator|)
operator|*
name|increment
index|]
argument_list|,
literal|295
argument_list|)
expr_stmt|;
if|if
condition|(
name|rval
operator|=
name|recursive_bounded_basetype_p
argument_list|(
name|binfo
argument_list|,
name|base_binfo
argument_list|,
name|rval
argument_list|,
literal|1
argument_list|)
condition|)
break|break;
block|}
if|if
condition|(
name|rval
operator|>
literal|0
condition|)
name|BINFO_INHERITANCE_CHAIN
argument_list|(
name|base_binfo
argument_list|)
operator|=
operator|*
name|tp
expr_stmt|;
block|}
comment|/* Because I don't trust recursive_bounded_basetype_p to find 	   all ambiguities, I will just make sure here.  When it is 	   sure that all ambiguities are found, the two routines and 	   this call can be removed.  Not toally sure this should be 	   here, but I think it should. (mrs) */
if|if
condition|(
name|get_binfo2
argument_list|(
name|parent
argument_list|,
name|type
argument_list|)
operator|==
name|error_mark_node
operator|&&
name|rval
operator|!=
operator|-
literal|2
condition|)
block|{
if|#
directive|if
literal|1
comment|/* This warning is here because the code over in 	       prepare_fresh_vtable relies on partial completion 	       offered by recursive_bounded_basetype_p I think, but 	       that behavior is not documented.  It needs to be.  I 	       don't think prepare_fresh_vtable is the only routine 	       that relies upon path_ptr being set to something in a 	       particular way when this routine returns -2.  (mrs) */
name|warning
argument_list|(
literal|"internal consistency check failed, please report, recovering."
argument_list|)
expr_stmt|;
name|rval
operator|=
operator|-
literal|2
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* Visibilities don't count if we found an ambiguous basetype.  */
if|if
condition|(
name|rval
operator|==
operator|-
literal|2
condition|)
name|rval_private
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|search_stack
operator|=
name|pop_search_level
argument_list|(
name|search_stack
argument_list|)
expr_stmt|;
if|if
condition|(
name|rval
operator|&&
name|protect
operator|&&
name|rval_private
condition|)
return|return
operator|-
literal|3
return|;
if|if
condition|(
name|path_ptr
condition|)
operator|*
name|path_ptr
operator|=
name|binfo
expr_stmt|;
return|return
name|rval
return|;
block|}
end_function

begin_comment
comment|/* Search for a member with name NAME in a multiple inheritance lattice    specified by TYPE.  If it does not exist, return NULL_TREE.    If the member is ambiguously referenced, return `error_mark_node'.    Otherwise, return the FIELD_DECL.  */
end_comment

begin_comment
comment|/* Do a 1-level search for NAME as a member of TYPE.  The caller    must figure out whether it has a visible path to this field.    (Since it is only one level, this is reasonable.)  */
end_comment

begin_function
specifier|static
name|tree
name|lookup_field_1
parameter_list|(
name|type
parameter_list|,
name|name
parameter_list|)
name|tree
name|type
decl_stmt|,
name|name
decl_stmt|;
block|{
specifier|register
name|tree
name|field
init|=
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|GATHER_STATISTICS
name|n_calls_lookup_field_1
operator|++
expr_stmt|;
endif|#
directive|endif
while|while
condition|(
name|field
condition|)
block|{
ifdef|#
directive|ifdef
name|GATHER_STATISTICS
name|n_fields_searched
operator|++
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|DECL_NAME
argument_list|(
name|field
argument_list|)
operator|==
name|NULL_TREE
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|)
operator|==
name|UNION_TYPE
condition|)
block|{
name|tree
name|temp
init|=
name|lookup_field_1
argument_list|(
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|,
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|temp
condition|)
return|return
name|temp
return|;
block|}
if|if
condition|(
name|DECL_NAME
argument_list|(
name|field
argument_list|)
operator|==
name|name
condition|)
block|{
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|field
argument_list|)
operator|==
name|VAR_DECL
operator|||
name|TREE_CODE
argument_list|(
name|field
argument_list|)
operator|==
name|CONST_DECL
operator|)
operator|&&
name|DECL_ASSEMBLER_NAME
argument_list|(
name|field
argument_list|)
operator|!=
name|NULL
condition|)
name|GNU_xref_ref
argument_list|(
name|current_function_decl
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|field
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|field
return|;
block|}
name|field
operator|=
name|TREE_CHAIN
argument_list|(
name|field
argument_list|)
expr_stmt|;
block|}
comment|/* Not found.  */
if|if
condition|(
name|name
operator|==
name|_vptr_name
condition|)
block|{
comment|/* Give the user what s/he thinks s/he wants.  */
if|if
condition|(
name|TYPE_VIRTUAL_P
argument_list|(
name|type
argument_list|)
condition|)
return|return
name|CLASSTYPE_VFIELD
argument_list|(
name|type
argument_list|)
return|;
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Compute the visibility of FIELD.  This is done by computing    the visibility available to each type in BASETYPES (which comes    as a list of [via_public/basetype] in reverse order, namely base    class before derived class).  The first one which defines a    visibility defines the visibility for the field.  Otherwise, the    visibility of the field is that which occurs normally.     Uses global variables CURRENT_CLASS_TYPE and    CURRENT_FUNCTION_DECL to use friend relationships    if necessary.     This will be static when lookup_fnfield comes into this file.  */
end_comment

begin_define
define|#
directive|define
name|PUBLIC_RETURN
value|return (DECL_PUBLIC (field) = 1), visibility_public
end_define

begin_define
define|#
directive|define
name|PROTECTED_RETURN
value|return (DECL_PROTECTED (field) = 1), visibility_protected
end_define

begin_define
define|#
directive|define
name|PRIVATE_RETURN
value|return (DECL_PRIVATE (field) = 1), visibility_private
end_define

begin_function
name|enum
name|visibility_type
name|compute_visibility
parameter_list|(
name|basetype_path
parameter_list|,
name|field
parameter_list|)
name|tree
name|basetype_path
decl_stmt|,
name|field
decl_stmt|;
block|{
name|enum
name|visibility_type
name|visibility
init|=
name|visibility_public
decl_stmt|;
name|tree
name|types
decl_stmt|;
name|tree
name|context
init|=
name|DECL_CLASS_CONTEXT
argument_list|(
name|field
argument_list|)
decl_stmt|;
comment|/* Virtual function tables are never private.      But we should know that we are looking for this,      and not even try to hide it.  */
if|if
condition|(
name|DECL_NAME
argument_list|(
name|field
argument_list|)
operator|&&
name|VFIELD_NAME_P
argument_list|(
name|DECL_NAME
argument_list|(
name|field
argument_list|)
argument_list|)
operator|==
literal|1
condition|)
return|return
name|visibility_public
return|;
comment|/* Make these special cases fast.  */
if|if
condition|(
name|BINFO_TYPE
argument_list|(
name|basetype_path
argument_list|)
operator|==
name|current_class_type
condition|)
block|{
if|if
condition|(
name|DECL_PUBLIC
argument_list|(
name|field
argument_list|)
condition|)
return|return
name|visibility_public
return|;
if|if
condition|(
name|DECL_PROTECTED
argument_list|(
name|field
argument_list|)
condition|)
return|return
name|visibility_protected
return|;
if|if
condition|(
name|DECL_PRIVATE
argument_list|(
name|field
argument_list|)
condition|)
return|return
name|visibility_private
return|;
block|}
comment|/* Member function manipulating its own members.  */
if|if
condition|(
name|current_class_type
operator|==
name|context
condition|)
name|PUBLIC_RETURN
expr_stmt|;
comment|/* Member found immediately within object.  */
if|if
condition|(
name|BINFO_INHERITANCE_CHAIN
argument_list|(
name|basetype_path
argument_list|)
operator|==
name|NULL_TREE
condition|)
block|{
comment|/* At object's top level, public members are public.  */
if|if
condition|(
name|TREE_PROTECTED
argument_list|(
name|field
argument_list|)
operator|==
literal|0
operator|&&
name|TREE_PRIVATE
argument_list|(
name|field
argument_list|)
operator|==
literal|0
condition|)
name|PUBLIC_RETURN
expr_stmt|;
comment|/* Friend function manipulating members it gets (for being a friend).  */
if|if
condition|(
name|is_friend
argument_list|(
name|context
argument_list|,
name|current_function_decl
argument_list|)
condition|)
name|PUBLIC_RETURN
expr_stmt|;
comment|/* Inner than that, without special visibility,  	   protected members are ok if type of object is current_class_type 	   is derived therefrom.  This means that if the type of the object 	   is a base type for our current class type, we cannot access 	   protected members.  	   private members are not ok.  */
if|if
condition|(
name|current_class_type
operator|&&
name|DECL_VISIBILITY
argument_list|(
name|field
argument_list|)
operator|==
name|NULL_TREE
condition|)
block|{
if|if
condition|(
name|TREE_PRIVATE
argument_list|(
name|field
argument_list|)
condition|)
name|PRIVATE_RETURN
expr_stmt|;
if|if
condition|(
name|TREE_PROTECTED
argument_list|(
name|field
argument_list|)
condition|)
block|{
if|if
condition|(
name|context
operator|==
name|current_class_type
operator|||
name|UNIQUELY_DERIVED_FROM_P
argument_list|(
name|context
argument_list|,
name|current_class_type
argument_list|)
condition|)
name|PUBLIC_RETURN
expr_stmt|;
else|else
name|PROTECTED_RETURN
expr_stmt|;
block|}
else|else
name|my_friendly_abort
argument_list|(
literal|94
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Friend function manipulating members it gets (for being a friend).  */
if|if
condition|(
name|is_friend
argument_list|(
name|context
argument_list|,
name|current_function_decl
argument_list|)
condition|)
name|PUBLIC_RETURN
expr_stmt|;
comment|/* must reverse more than one element */
name|basetype_path
operator|=
name|reverse_path
argument_list|(
name|basetype_path
argument_list|)
expr_stmt|;
name|types
operator|=
name|basetype_path
expr_stmt|;
while|while
condition|(
name|types
condition|)
block|{
name|tree
name|member
decl_stmt|;
name|tree
name|binfo
init|=
name|types
decl_stmt|;
name|tree
name|type
init|=
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
decl_stmt|;
name|member
operator|=
name|purpose_member
argument_list|(
name|type
argument_list|,
name|DECL_VISIBILITY
argument_list|(
name|field
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|member
condition|)
block|{
name|visibility
operator|=
operator|(
expr|enum
name|visibility_type
operator|)
name|TREE_VALUE
argument_list|(
name|member
argument_list|)
expr_stmt|;
if|if
condition|(
name|visibility
operator|==
name|visibility_public
operator|||
name|is_friend
argument_list|(
name|type
argument_list|,
name|current_function_decl
argument_list|)
operator|||
operator|(
name|visibility
operator|==
name|visibility_protected
operator|&&
name|current_class_type
operator|&&
name|UNIQUELY_DERIVED_FROM_P
argument_list|(
name|context
argument_list|,
name|current_class_type
argument_list|)
operator|)
condition|)
name|visibility
operator|=
name|visibility_public
expr_stmt|;
goto|goto
name|ret
goto|;
block|}
comment|/* Friends inherit the visibility of the class they inherit from.  */
if|if
condition|(
name|is_friend
argument_list|(
name|type
argument_list|,
name|current_function_decl
argument_list|)
condition|)
block|{
if|if
condition|(
name|type
operator|==
name|context
condition|)
block|{
name|visibility
operator|=
name|visibility_public
expr_stmt|;
goto|goto
name|ret
goto|;
block|}
if|if
condition|(
name|TREE_PROTECTED
argument_list|(
name|field
argument_list|)
condition|)
block|{
name|visibility
operator|=
name|visibility_public
expr_stmt|;
goto|goto
name|ret
goto|;
block|}
if|#
directive|if
literal|0
comment|/* This short-cut is too short.  */
block|if (visibility == visibility_public) 	    goto ret;
endif|#
directive|endif
comment|/* else, may be a friend of a deeper base class */
block|}
if|if
condition|(
name|type
operator|==
name|context
condition|)
break|break;
name|types
operator|=
name|BINFO_INHERITANCE_CHAIN
argument_list|(
name|types
argument_list|)
expr_stmt|;
comment|/* If the next type was not VIA_PUBLIC, then fields of all 	 remaining class past that one are private.  */
if|if
condition|(
name|types
condition|)
block|{
if|if
condition|(
name|TREE_VIA_PROTECTED
argument_list|(
name|types
argument_list|)
condition|)
name|visibility
operator|=
name|visibility_protected
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|TREE_VIA_PUBLIC
argument_list|(
name|types
argument_list|)
condition|)
name|visibility
operator|=
name|visibility_private
expr_stmt|;
block|}
block|}
comment|/* No special visibilities apply.  Use normal rules.      No assignment needed for BASETYPEs here from the nreverse.      This is because we use it only for information about the      path to the base.  The code earlier dealt with what      happens when we are at the base level.  */
if|if
condition|(
name|visibility
operator|==
name|visibility_public
condition|)
block|{
name|basetype_path
operator|=
name|reverse_path
argument_list|(
name|basetype_path
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_PRIVATE
argument_list|(
name|field
argument_list|)
condition|)
name|PRIVATE_RETURN
expr_stmt|;
if|if
condition|(
name|TREE_PROTECTED
argument_list|(
name|field
argument_list|)
condition|)
block|{
comment|/* Used to check if the current class type was derived from 	     the type that contains the field.  This is wrong for 	     multiple inheritance because is gives one class reference 	     to protected members via another classes protected path. 	     I.e., if A; B1 : A; B2 : A;  Then B1 and B2 can access 	     their own members which are protected in A, but not 	     those same members in one another.  */
if|if
condition|(
name|current_class_type
operator|&&
name|UNIQUELY_DERIVED_FROM_P
argument_list|(
name|context
argument_list|,
name|current_class_type
argument_list|)
condition|)
name|PUBLIC_RETURN
expr_stmt|;
name|PROTECTED_RETURN
expr_stmt|;
block|}
name|PUBLIC_RETURN
expr_stmt|;
block|}
if|if
condition|(
name|visibility
operator|==
name|visibility_protected
condition|)
block|{
comment|/* reverse_path? */
if|if
condition|(
name|TREE_PRIVATE
argument_list|(
name|field
argument_list|)
condition|)
name|PRIVATE_RETURN
expr_stmt|;
comment|/* We want to make sure that all non-private members in 	 the current class (as derived) are accessible.  */
if|if
condition|(
name|current_class_type
operator|&&
name|UNIQUELY_DERIVED_FROM_P
argument_list|(
name|context
argument_list|,
name|current_class_type
argument_list|)
condition|)
name|PUBLIC_RETURN
expr_stmt|;
name|PROTECTED_RETURN
expr_stmt|;
block|}
if|if
condition|(
name|visibility
operator|==
name|visibility_private
operator|&&
name|current_class_type
operator|!=
name|NULL_TREE
condition|)
block|{
if|if
condition|(
name|TREE_PRIVATE
argument_list|(
name|field
argument_list|)
condition|)
block|{
name|reverse_path
argument_list|(
name|basetype_path
argument_list|)
expr_stmt|;
name|PRIVATE_RETURN
expr_stmt|;
block|}
comment|/* See if the field isn't protected.  */
if|if
condition|(
name|TREE_PROTECTED
argument_list|(
name|field
argument_list|)
condition|)
block|{
name|tree
name|test
init|=
name|basetype_path
decl_stmt|;
while|while
condition|(
name|test
condition|)
block|{
if|if
condition|(
name|BINFO_TYPE
argument_list|(
name|test
argument_list|)
operator|==
name|current_class_type
condition|)
break|break;
name|test
operator|=
name|BINFO_INHERITANCE_CHAIN
argument_list|(
name|test
argument_list|)
expr_stmt|;
block|}
name|reverse_path
argument_list|(
name|basetype_path
argument_list|)
expr_stmt|;
if|if
condition|(
name|test
condition|)
name|PUBLIC_RETURN
expr_stmt|;
name|PROTECTED_RETURN
expr_stmt|;
block|}
comment|/* See if the field isn't a public member of 	 a private base class.  */
name|visibility
operator|=
name|visibility_public
expr_stmt|;
name|types
operator|=
name|BINFO_INHERITANCE_CHAIN
argument_list|(
name|basetype_path
argument_list|)
expr_stmt|;
while|while
condition|(
name|types
condition|)
block|{
if|if
condition|(
operator|!
name|TREE_VIA_PUBLIC
argument_list|(
name|types
argument_list|)
condition|)
block|{
if|if
condition|(
name|visibility
operator|==
name|visibility_private
condition|)
block|{
name|visibility
operator|=
name|visibility_private
expr_stmt|;
goto|goto
name|ret
goto|;
block|}
name|visibility
operator|=
name|visibility_private
expr_stmt|;
block|}
if|if
condition|(
name|BINFO_TYPE
argument_list|(
name|types
argument_list|)
operator|==
name|context
condition|)
block|{
name|visibility
operator|=
name|visibility_public
expr_stmt|;
goto|goto
name|ret
goto|;
block|}
name|types
operator|=
name|BINFO_INHERITANCE_CHAIN
argument_list|(
name|types
argument_list|)
expr_stmt|;
block|}
name|my_friendly_abort
argument_list|(
literal|95
argument_list|)
expr_stmt|;
block|}
name|ret
label|:
name|reverse_path
argument_list|(
name|basetype_path
argument_list|)
expr_stmt|;
if|if
condition|(
name|visibility
operator|==
name|visibility_public
condition|)
name|DECL_PUBLIC
argument_list|(
name|field
argument_list|)
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|visibility
operator|==
name|visibility_protected
condition|)
name|DECL_PROTECTED
argument_list|(
name|field
argument_list|)
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|visibility
operator|==
name|visibility_private
condition|)
name|DECL_PRIVATE
argument_list|(
name|field
argument_list|)
operator|=
literal|1
expr_stmt|;
else|else
name|my_friendly_abort
argument_list|(
literal|96
argument_list|)
expr_stmt|;
return|return
name|visibility
return|;
block|}
end_function

begin_comment
comment|/* Look for a field named NAME in an inheritance lattice dominated by    XBASETYPE.  PROTECT is zero if we can avoid computing visibility    information, otherwise it is 1.  WANT_TYPE is 1 when we should only    return TYPE_DECLs, if no TYPE_DECL can be found return NULL.  */
end_comment

begin_function
name|tree
name|lookup_field
parameter_list|(
name|xbasetype
parameter_list|,
name|name
parameter_list|,
name|protect
parameter_list|,
name|want_type
parameter_list|)
specifier|register
name|tree
name|xbasetype
decl_stmt|,
name|name
decl_stmt|;
name|int
name|protect
decl_stmt|,
name|want_type
decl_stmt|;
block|{
name|int
name|head
init|=
literal|0
decl_stmt|,
name|tail
init|=
literal|0
decl_stmt|;
name|tree
name|rval
decl_stmt|;
name|tree
name|type
decl_stmt|,
name|basetype_chain
decl_stmt|,
name|basetype_path
decl_stmt|;
name|enum
name|visibility_type
name|this_v
init|=
name|visibility_default
decl_stmt|;
name|tree
name|entry
decl_stmt|,
name|binfo
decl_stmt|;
name|enum
name|visibility_type
name|own_visibility
init|=
name|visibility_default
decl_stmt|;
name|int
name|vbase_name_p
init|=
name|VBASE_NAME_P
argument_list|(
name|name
argument_list|)
decl_stmt|;
comment|/* Things for memoization.  */
name|char
modifier|*
name|errstr
init|=
literal|0
decl_stmt|;
comment|/* Set this to nonzero if we don't know how to compute      accurate error messages for visibility.  */
name|int
name|index
init|=
name|MEMOIZED_HASH_FN
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|xbasetype
argument_list|)
operator|==
name|TREE_VEC
condition|)
name|basetype_path
operator|=
name|xbasetype
operator|,
name|type
operator|=
name|BINFO_TYPE
argument_list|(
name|xbasetype
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|IS_AGGR_TYPE_CODE
argument_list|(
name|TREE_CODE
argument_list|(
name|xbasetype
argument_list|)
argument_list|)
condition|)
name|basetype_path
operator|=
name|TYPE_BINFO
argument_list|(
name|xbasetype
argument_list|)
operator|,
name|type
operator|=
name|xbasetype
expr_stmt|;
else|else
name|my_friendly_abort
argument_list|(
literal|97
argument_list|)
expr_stmt|;
if|if
condition|(
name|CLASSTYPE_MTABLE_ENTRY
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|tree
name|tem
init|=
name|MEMOIZED_FIELDS
argument_list|(
name|CLASSTYPE_MTABLE_ENTRY
argument_list|(
name|type
argument_list|)
argument_list|,
name|index
argument_list|)
decl_stmt|;
while|while
condition|(
name|tem
operator|&&
name|TREE_PURPOSE
argument_list|(
name|tem
argument_list|)
operator|!=
name|name
condition|)
block|{
name|memoized_fields_searched
index|[
literal|0
index|]
operator|++
expr_stmt|;
name|tem
operator|=
name|TREE_CHAIN
argument_list|(
name|tem
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tem
condition|)
block|{
if|if
condition|(
name|protect
operator|&&
name|TREE_TYPE
argument_list|(
name|tem
argument_list|)
condition|)
block|{
name|error
argument_list|(
name|TREE_STRING_POINTER
argument_list|(
name|TREE_TYPE
argument_list|(
name|tem
argument_list|)
argument_list|)
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|,
name|TYPE_NAME_STRING
argument_list|(
name|DECL_FIELD_CONTEXT
argument_list|(
name|TREE_VALUE
argument_list|(
name|tem
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|TREE_VALUE
argument_list|(
name|tem
argument_list|)
operator|==
name|NULL_TREE
condition|)
name|memoized_fast_rejects
index|[
literal|0
index|]
operator|+=
literal|1
expr_stmt|;
else|else
name|memoized_fast_finds
index|[
literal|0
index|]
operator|+=
literal|1
expr_stmt|;
return|return
name|TREE_VALUE
argument_list|(
name|tem
argument_list|)
return|;
block|}
block|}
ifdef|#
directive|ifdef
name|GATHER_STATISTICS
name|n_calls_lookup_field
operator|++
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|protect
operator|&&
name|flag_memoize_lookups
operator|&&
operator|!
name|global_bindings_p
argument_list|()
condition|)
name|entry
operator|=
name|make_memoized_table_entry
argument_list|(
name|type
argument_list|,
name|name
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|entry
operator|=
literal|0
expr_stmt|;
name|rval
operator|=
name|lookup_field_1
argument_list|(
name|type
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|rval
operator|&&
name|TREE_CODE
argument_list|(
name|rval
argument_list|)
operator|!=
name|TYPE_DECL
operator|&&
name|want_type
condition|)
name|rval
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
name|rval
condition|)
block|{
if|if
condition|(
name|protect
condition|)
block|{
if|if
condition|(
name|TREE_PRIVATE
argument_list|(
name|rval
argument_list|)
operator||
name|TREE_PROTECTED
argument_list|(
name|rval
argument_list|)
condition|)
name|this_v
operator|=
name|compute_visibility
argument_list|(
name|basetype_path
argument_list|,
name|rval
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|rval
argument_list|)
operator|==
name|CONST_DECL
condition|)
block|{
if|if
condition|(
name|this_v
operator|==
name|visibility_private
condition|)
name|errstr
operator|=
literal|"enum `%s' is a private value of class `%s'"
expr_stmt|;
elseif|else
if|if
condition|(
name|this_v
operator|==
name|visibility_protected
condition|)
name|errstr
operator|=
literal|"enum `%s' is a protected value of class `%s'"
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|this_v
operator|==
name|visibility_private
condition|)
name|errstr
operator|=
literal|"member `%s' is a private member of class `%s'"
expr_stmt|;
elseif|else
if|if
condition|(
name|this_v
operator|==
name|visibility_protected
condition|)
name|errstr
operator|=
literal|"member `%s' is a protected member of class `%s'"
expr_stmt|;
block|}
block|}
if|if
condition|(
name|entry
condition|)
block|{
if|if
condition|(
name|errstr
condition|)
block|{
comment|/* This depends on behavior of lookup_field_1!  */
name|tree
name|error_string
init|=
name|my_build_string
argument_list|(
name|errstr
argument_list|)
decl_stmt|;
name|TREE_TYPE
argument_list|(
name|entry
argument_list|)
operator|=
name|error_string
expr_stmt|;
block|}
else|else
block|{
comment|/* Let entry know there is no problem with this access.  */
name|TREE_TYPE
argument_list|(
name|entry
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
block|}
name|TREE_VALUE
argument_list|(
name|entry
argument_list|)
operator|=
name|rval
expr_stmt|;
block|}
if|if
condition|(
name|errstr
operator|&&
name|protect
condition|)
block|{
name|error
argument_list|(
name|errstr
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|,
name|TYPE_NAME_STRING
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
return|return
name|rval
return|;
block|}
name|basetype_chain
operator|=
name|CLASSTYPE_BINFO_AS_LIST
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|TREE_VIA_PUBLIC
argument_list|(
name|basetype_chain
argument_list|)
operator|=
literal|1
expr_stmt|;
name|search_stack
operator|=
name|push_search_level
argument_list|(
name|search_stack
argument_list|,
operator|&
name|search_obstack
argument_list|)
expr_stmt|;
name|BINFO_VIA_PUBLIC
argument_list|(
name|basetype_path
argument_list|)
operator|=
literal|1
expr_stmt|;
name|BINFO_INHERITANCE_CHAIN
argument_list|(
name|basetype_path
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
name|binfo
operator|=
name|basetype_path
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|tree
name|binfos
init|=
name|BINFO_BASETYPES
argument_list|(
name|binfo
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|,
name|n_baselinks
init|=
name|binfos
condition|?
name|TREE_VEC_LENGTH
argument_list|(
name|binfos
argument_list|)
else|:
literal|0
decl_stmt|;
comment|/* Process and/or queue base types.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_baselinks
condition|;
name|i
operator|++
control|)
block|{
name|tree
name|base_binfo
init|=
name|TREE_VEC_ELT
argument_list|(
name|binfos
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|BINFO_FIELDS_MARKED
argument_list|(
name|base_binfo
argument_list|)
operator|==
literal|0
condition|)
block|{
name|tree
name|btypes
decl_stmt|;
name|SET_BINFO_FIELDS_MARKED
argument_list|(
name|base_binfo
argument_list|)
expr_stmt|;
name|btypes
operator|=
name|my_tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|base_binfo
argument_list|,
name|basetype_chain
argument_list|)
expr_stmt|;
name|TREE_VIA_PUBLIC
argument_list|(
name|btypes
argument_list|)
operator|=
name|TREE_VIA_PUBLIC
argument_list|(
name|base_binfo
argument_list|)
expr_stmt|;
name|TREE_VIA_PROTECTED
argument_list|(
name|btypes
argument_list|)
operator|=
name|TREE_VIA_PROTECTED
argument_list|(
name|base_binfo
argument_list|)
expr_stmt|;
name|TREE_VIA_VIRTUAL
argument_list|(
name|btypes
argument_list|)
operator|=
name|TREE_VIA_VIRTUAL
argument_list|(
name|base_binfo
argument_list|)
expr_stmt|;
name|obstack_ptr_grow
argument_list|(
operator|&
name|search_obstack
argument_list|,
name|btypes
argument_list|)
expr_stmt|;
name|tail
operator|+=
literal|1
expr_stmt|;
if|if
condition|(
name|tail
operator|>=
name|search_stack
operator|->
name|limit
condition|)
name|my_friendly_abort
argument_list|(
literal|98
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Process head of queue, if one exists.  */
if|if
condition|(
name|head
operator|>=
name|tail
condition|)
break|break;
name|basetype_chain
operator|=
name|search_stack
operator|->
name|first
index|[
name|head
operator|++
index|]
expr_stmt|;
name|basetype_path
operator|=
name|TREE_VALUE
argument_list|(
name|basetype_chain
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CHAIN
argument_list|(
name|basetype_chain
argument_list|)
condition|)
name|BINFO_INHERITANCE_CHAIN
argument_list|(
name|basetype_path
argument_list|)
operator|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|basetype_chain
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|BINFO_INHERITANCE_CHAIN
argument_list|(
name|basetype_path
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
name|binfo
operator|=
name|basetype_path
expr_stmt|;
name|type
operator|=
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
expr_stmt|;
comment|/* See if we can find NAME in TYPE.  If RVAL is nonzero, 	 and we do find NAME in TYPE, verify that such a second 	 sighting is in fact legal.  */
if|if
condition|(
name|rval
condition|)
block|{
name|tree
name|context
init|=
name|DECL_FIELD_CONTEXT
argument_list|(
name|rval
argument_list|)
decl_stmt|;
comment|/* Just another way of finding the same member.  */
if|if
condition|(
name|TYPE_BINFO
argument_list|(
name|context
argument_list|)
operator|==
name|binfo
condition|)
block|{
name|enum
name|visibility_type
name|new_v
init|=
name|compute_visibility
argument_list|(
name|basetype_path
argument_list|,
name|rval
argument_list|)
decl_stmt|;
if|if
condition|(
name|this_v
operator|!=
name|new_v
condition|)
name|errstr
operator|=
literal|"conflicting visibilities to member `%s'"
expr_stmt|;
block|}
comment|/* Same baseclass, maybe different places in the lattice.  */
elseif|else
if|if
condition|(
name|context
operator|==
name|type
condition|)
block|{
name|errstr
operator|=
literal|"member `%s' belongs to distinct base classes `%s'"
expr_stmt|;
name|protect
operator|=
literal|2
expr_stmt|;
block|}
else|else
block|{
name|tree
name|nval
init|=
name|lookup_field_1
argument_list|(
name|type
argument_list|,
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|nval
operator|&&
name|TREE_CODE
argument_list|(
name|nval
argument_list|)
operator|!=
name|TYPE_DECL
operator|&&
name|want_type
condition|)
name|nval
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
name|nval
operator|&&
name|binfo
operator|!=
name|get_binfo
argument_list|(
name|type
argument_list|,
name|DECL_FIELD_CONTEXT
argument_list|(
name|rval
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|)
block|{
comment|/* We found it in other than a baseclass of RVAL's.  */
name|errstr
operator|=
literal|"request for member `%s' is ambiguous"
expr_stmt|;
name|protect
operator|=
literal|2
expr_stmt|;
block|}
block|}
if|if
condition|(
name|errstr
operator|&&
name|entry
condition|)
block|{
name|tree
name|error_string
init|=
name|my_build_string
argument_list|(
name|errstr
argument_list|)
decl_stmt|;
name|TREE_TYPE
argument_list|(
name|entry
argument_list|)
operator|=
name|error_string
expr_stmt|;
block|}
if|if
condition|(
name|errstr
operator|&&
name|protect
condition|)
break|break;
block|}
else|else
block|{
name|rval
operator|=
name|lookup_field_1
argument_list|(
name|type
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|rval
operator|&&
name|TREE_CODE
argument_list|(
name|rval
argument_list|)
operator|!=
name|TYPE_DECL
operator|&&
name|want_type
condition|)
name|rval
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
name|rval
condition|)
block|{
if|if
condition|(
name|entry
operator|||
name|protect
condition|)
name|this_v
operator|=
name|compute_visibility
argument_list|(
name|basetype_path
argument_list|,
name|rval
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
condition|)
name|TREE_VALUE
argument_list|(
name|entry
argument_list|)
operator|=
name|rval
expr_stmt|;
comment|/* These may look ambiguous, but they really are not.  */
if|if
condition|(
name|vbase_name_p
condition|)
break|break;
block|}
block|}
block|}
block|{
name|tree
modifier|*
name|tp
init|=
name|search_stack
operator|->
name|first
decl_stmt|;
name|tree
modifier|*
name|search_tail
init|=
name|tp
operator|+
name|tail
decl_stmt|;
comment|/* If this FIELD_DECL defines its own visibility, deal with that.  */
if|if
condition|(
name|rval
operator|&&
name|errstr
operator|==
literal|0
operator|&&
operator|(
operator|(
name|protect
operator|&
literal|1
operator|)
operator|||
name|entry
operator|)
operator|&&
name|DECL_LANG_SPECIFIC
argument_list|(
name|rval
argument_list|)
operator|&&
name|DECL_VISIBILITY
argument_list|(
name|rval
argument_list|)
condition|)
block|{
while|while
condition|(
name|tp
operator|<
name|search_tail
condition|)
block|{
comment|/* If is possible for one of the derived types on the 	       path to have defined special visibility for this 	       field.  Look for such declarations and report an 	       error if a conflict is found.  */
name|enum
name|visibility_type
name|new_v
decl_stmt|;
if|if
condition|(
name|this_v
operator|!=
name|visibility_default
condition|)
name|new_v
operator|=
name|compute_visibility
argument_list|(
name|TREE_VALUE
argument_list|(
operator|*
name|tp
argument_list|)
argument_list|,
name|rval
argument_list|)
expr_stmt|;
if|if
condition|(
name|this_v
operator|!=
name|visibility_default
operator|&&
name|new_v
operator|!=
name|this_v
condition|)
block|{
name|errstr
operator|=
literal|"conflicting visibilities to member `%s'"
expr_stmt|;
name|this_v
operator|=
name|visibility_default
expr_stmt|;
block|}
name|own_visibility
operator|=
name|new_v
expr_stmt|;
name|CLEAR_BINFO_FIELDS_MARKED
argument_list|(
name|TREE_VALUE
argument_list|(
operator|*
name|tp
argument_list|)
argument_list|)
expr_stmt|;
name|tp
operator|+=
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
while|while
condition|(
name|tp
operator|<
name|search_tail
condition|)
block|{
name|CLEAR_BINFO_FIELDS_MARKED
argument_list|(
name|TREE_VALUE
argument_list|(
operator|*
name|tp
argument_list|)
argument_list|)
expr_stmt|;
name|tp
operator|+=
literal|1
expr_stmt|;
block|}
block|}
block|}
name|search_stack
operator|=
name|pop_search_level
argument_list|(
name|search_stack
argument_list|)
expr_stmt|;
if|if
condition|(
name|errstr
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|own_visibility
operator|==
name|visibility_private
condition|)
name|errstr
operator|=
literal|"member `%s' declared private"
expr_stmt|;
elseif|else
if|if
condition|(
name|own_visibility
operator|==
name|visibility_protected
condition|)
name|errstr
operator|=
literal|"member `%s' declared protected"
expr_stmt|;
elseif|else
if|if
condition|(
name|this_v
operator|==
name|visibility_private
condition|)
name|errstr
operator|=
name|TREE_PRIVATE
argument_list|(
name|rval
argument_list|)
condition|?
literal|"member `%s' is private"
else|:
literal|"member `%s' is from private base class"
expr_stmt|;
elseif|else
if|if
condition|(
name|this_v
operator|==
name|visibility_protected
condition|)
name|errstr
operator|=
name|TREE_PROTECTED
argument_list|(
name|rval
argument_list|)
condition|?
literal|"member `%s' is protected"
else|:
literal|"member `%s' is from protected base class"
expr_stmt|;
block|}
if|if
condition|(
name|entry
condition|)
block|{
if|if
condition|(
name|errstr
condition|)
block|{
name|tree
name|error_string
init|=
name|my_build_string
argument_list|(
name|errstr
argument_list|)
decl_stmt|;
comment|/* Save error message with entry.  */
name|TREE_TYPE
argument_list|(
name|entry
argument_list|)
operator|=
name|error_string
expr_stmt|;
block|}
else|else
block|{
comment|/* Mark entry as having no error string.  */
name|TREE_TYPE
argument_list|(
name|entry
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
block|}
block|}
if|if
condition|(
name|errstr
operator|&&
name|protect
condition|)
block|{
name|error
argument_list|(
name|errstr
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|,
name|TYPE_NAME_STRING
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|rval
operator|=
name|error_mark_node
expr_stmt|;
block|}
return|return
name|rval
return|;
block|}
end_function

begin_comment
comment|/* Try to find NAME inside a nested class.  */
end_comment

begin_function
name|tree
name|lookup_nested_field
parameter_list|(
name|name
parameter_list|)
name|tree
name|name
decl_stmt|;
block|{
specifier|register
name|tree
name|t
decl_stmt|;
name|tree
name|id
init|=
name|NULL_TREE
decl_stmt|;
if|if
condition|(
name|TREE_CHAIN
argument_list|(
name|current_class_type
argument_list|)
condition|)
block|{
comment|/* Climb our way up the nested ladder, seeing if we're trying to 	 modify a field in an enclosing class.  If so, we should only 	 be able to modify if it's static.  */
for|for
control|(
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|current_class_type
argument_list|)
init|;
name|t
operator|&&
name|DECL_CONTEXT
argument_list|(
name|t
argument_list|)
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|t
argument_list|)
argument_list|)
control|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|t
argument_list|)
argument_list|)
operator|!=
name|RECORD_TYPE
condition|)
break|break;
comment|/* N.B.: lookup_field will do the visibility checking for us */
name|id
operator|=
name|lookup_field
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|t
argument_list|)
argument_list|,
name|name
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|id
operator|==
name|error_mark_node
condition|)
continue|continue;
if|if
condition|(
name|id
operator|!=
name|NULL_TREE
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|id
argument_list|)
operator|==
name|FIELD_DECL
operator|&&
operator|!
name|TREE_STATIC
argument_list|(
name|id
argument_list|)
operator|&&
name|TREE_TYPE
argument_list|(
name|id
argument_list|)
operator|!=
name|error_mark_node
condition|)
block|{
name|error
argument_list|(
literal|"assignment to non-static member `%s' of enclosing class `%s'"
argument_list|,
name|lang_printable_name
argument_list|(
name|id
argument_list|)
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|TYPE_IDENTIFIER
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|t
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Mark this for do_identifier().  It would otherwise 		     claim that the variable was undeclared.  */
name|TREE_TYPE
argument_list|(
name|id
argument_list|)
operator|=
name|error_mark_node
expr_stmt|;
block|}
break|break;
block|}
block|}
block|}
return|return
name|id
return|;
block|}
end_function

begin_comment
comment|/* TYPE is a class type. Return the index of the fields within    the method vector with name NAME, or -1 is no such field exists.  */
end_comment

begin_function
specifier|static
name|int
name|lookup_fnfields_1
parameter_list|(
name|type
parameter_list|,
name|name
parameter_list|)
name|tree
name|type
decl_stmt|,
name|name
decl_stmt|;
block|{
specifier|register
name|tree
name|method_vec
init|=
name|CLASSTYPE_METHOD_VEC
argument_list|(
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|method_vec
operator|!=
literal|0
condition|)
block|{
specifier|register
name|tree
modifier|*
name|methods
init|=
operator|&
name|TREE_VEC_ELT
argument_list|(
name|method_vec
argument_list|,
literal|0
argument_list|)
decl_stmt|;
specifier|register
name|tree
modifier|*
name|end
init|=
name|TREE_VEC_END
argument_list|(
name|method_vec
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|GATHER_STATISTICS
name|n_calls_lookup_fnfields_1
operator|++
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|*
name|methods
operator|&&
name|name
operator|==
name|constructor_name
argument_list|(
name|type
argument_list|)
condition|)
return|return
literal|0
return|;
while|while
condition|(
operator|++
name|methods
operator|!=
name|end
condition|)
block|{
ifdef|#
directive|ifdef
name|GATHER_STATISTICS
name|n_outer_fields_searched
operator|++
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|DECL_NAME
argument_list|(
operator|*
name|methods
argument_list|)
operator|==
name|name
condition|)
break|break;
block|}
if|if
condition|(
name|methods
operator|!=
name|end
condition|)
return|return
name|methods
operator|-
operator|&
name|TREE_VEC_ELT
argument_list|(
name|method_vec
argument_list|,
literal|0
argument_list|)
return|;
block|}
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Starting from BASETYPE, return a TREE_BASELINK-like object    which gives the following information (in a list):     TREE_TYPE: list of basetypes needed to get to...    TREE_VALUE: list of all functions in of given type    which have name NAME.     No visibility information is computed by this function,    other then to adorn the list of basetypes with    TREE_VIA_PUBLIC.     If FIND_AMBIGUOUS is non-zero, then if we find two ways to get    to the same member function, both those ways are found,    and the caller must know what to do about this.  */
end_comment

begin_function
name|tree
name|lookup_fnfields
parameter_list|(
name|basetype_path
parameter_list|,
name|name
parameter_list|,
name|find_ambiguous
parameter_list|)
name|tree
name|basetype_path
decl_stmt|,
name|name
decl_stmt|;
name|int
name|find_ambiguous
decl_stmt|;
block|{
name|int
name|head
init|=
literal|0
decl_stmt|,
name|tail
init|=
literal|0
decl_stmt|;
name|tree
name|type
decl_stmt|,
name|rval
decl_stmt|,
name|rvals
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|entry
decl_stmt|,
name|binfo
decl_stmt|,
name|basetype_chain
decl_stmt|;
comment|/* For now, don't try this.  */
name|int
name|protect
init|=
name|find_ambiguous
decl_stmt|;
comment|/* Things for memoization.  */
name|char
modifier|*
name|errstr
init|=
literal|0
decl_stmt|;
comment|/* Set this to nonzero if we don't know how to compute      accurate error messages for visibility.  */
name|int
name|index
init|=
name|MEMOIZED_HASH_FN
argument_list|(
name|name
argument_list|)
decl_stmt|;
name|binfo
operator|=
name|basetype_path
expr_stmt|;
name|type
operator|=
name|BINFO_TYPE
argument_list|(
name|basetype_path
argument_list|)
expr_stmt|;
if|if
condition|(
name|CLASSTYPE_MTABLE_ENTRY
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|tree
name|tem
init|=
name|MEMOIZED_FNFIELDS
argument_list|(
name|CLASSTYPE_MTABLE_ENTRY
argument_list|(
name|type
argument_list|)
argument_list|,
name|index
argument_list|)
decl_stmt|;
while|while
condition|(
name|tem
operator|&&
name|TREE_PURPOSE
argument_list|(
name|tem
argument_list|)
operator|!=
name|name
condition|)
block|{
name|memoized_fields_searched
index|[
literal|1
index|]
operator|++
expr_stmt|;
name|tem
operator|=
name|TREE_CHAIN
argument_list|(
name|tem
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tem
condition|)
block|{
if|if
condition|(
name|protect
operator|&&
name|TREE_TYPE
argument_list|(
name|tem
argument_list|)
condition|)
block|{
name|error
argument_list|(
name|TREE_STRING_POINTER
argument_list|(
name|TREE_TYPE
argument_list|(
name|tem
argument_list|)
argument_list|)
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|,
name|TYPE_NAME_STRING
argument_list|(
name|DECL_CLASS_CONTEXT
argument_list|(
name|TREE_VALUE
argument_list|(
name|TREE_VALUE
argument_list|(
name|tem
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|TREE_VALUE
argument_list|(
name|tem
argument_list|)
operator|==
name|NULL_TREE
condition|)
block|{
name|memoized_fast_rejects
index|[
literal|1
index|]
operator|+=
literal|1
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
else|else
block|{
comment|/* Want to return this, but we must make sure 		 that visibility information is consistent.  */
name|tree
name|baselink
init|=
name|TREE_VALUE
argument_list|(
name|tem
argument_list|)
decl_stmt|;
name|tree
name|memoized_basetypes
init|=
name|TREE_PURPOSE
argument_list|(
name|baselink
argument_list|)
decl_stmt|;
name|tree
name|these_basetypes
init|=
name|basetype_path
decl_stmt|;
while|while
condition|(
name|memoized_basetypes
operator|&&
name|these_basetypes
condition|)
block|{
name|memoized_fields_searched
index|[
literal|1
index|]
operator|++
expr_stmt|;
if|if
condition|(
name|TREE_VALUE
argument_list|(
name|memoized_basetypes
argument_list|)
operator|!=
name|these_basetypes
condition|)
break|break;
name|memoized_basetypes
operator|=
name|TREE_CHAIN
argument_list|(
name|memoized_basetypes
argument_list|)
expr_stmt|;
name|these_basetypes
operator|=
name|BINFO_INHERITANCE_CHAIN
argument_list|(
name|these_basetypes
argument_list|)
expr_stmt|;
block|}
comment|/* The following statement is true only when both are NULL.  */
if|if
condition|(
name|memoized_basetypes
operator|==
name|these_basetypes
condition|)
block|{
name|memoized_fast_finds
index|[
literal|1
index|]
operator|+=
literal|1
expr_stmt|;
return|return
name|TREE_VALUE
argument_list|(
name|tem
argument_list|)
return|;
block|}
comment|/* else, we must re-find this field by hand.  */
name|baselink
operator|=
name|tree_cons
argument_list|(
name|basetype_path
argument_list|,
name|TREE_VALUE
argument_list|(
name|baselink
argument_list|)
argument_list|,
name|TREE_CHAIN
argument_list|(
name|baselink
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|baselink
return|;
block|}
block|}
block|}
ifdef|#
directive|ifdef
name|GATHER_STATISTICS
name|n_calls_lookup_fnfields
operator|++
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|protect
operator|&&
name|flag_memoize_lookups
operator|&&
operator|!
name|global_bindings_p
argument_list|()
condition|)
name|entry
operator|=
name|make_memoized_table_entry
argument_list|(
name|type
argument_list|,
name|name
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
name|entry
operator|=
literal|0
expr_stmt|;
name|index
operator|=
name|lookup_fnfields_1
argument_list|(
name|type
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|index
operator|>=
literal|0
condition|)
block|{
name|rval
operator|=
name|TREE_VEC_ELT
argument_list|(
name|CLASSTYPE_METHOD_VEC
argument_list|(
name|type
argument_list|)
argument_list|,
name|index
argument_list|)
expr_stmt|;
name|rvals
operator|=
name|my_tree_cons
argument_list|(
name|basetype_path
argument_list|,
name|rval
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
if|if
condition|(
name|BINFO_BASETYPES
argument_list|(
name|binfo
argument_list|)
operator|&&
name|CLASSTYPE_BASELINK_VEC
argument_list|(
name|type
argument_list|)
condition|)
name|TREE_TYPE
argument_list|(
name|rvals
argument_list|)
operator|=
name|TREE_VEC_ELT
argument_list|(
name|CLASSTYPE_BASELINK_VEC
argument_list|(
name|type
argument_list|)
argument_list|,
name|index
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
condition|)
block|{
name|TREE_VALUE
argument_list|(
name|entry
argument_list|)
operator|=
name|rvals
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|entry
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
block|}
if|if
condition|(
name|errstr
operator|&&
name|protect
condition|)
block|{
name|error
argument_list|(
name|errstr
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|,
name|TYPE_NAME_STRING
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
return|return
name|rvals
return|;
block|}
name|rval
operator|=
name|NULL_TREE
expr_stmt|;
name|basetype_chain
operator|=
name|CLASSTYPE_BINFO_AS_LIST
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|TREE_VIA_PUBLIC
argument_list|(
name|basetype_chain
argument_list|)
operator|=
literal|1
expr_stmt|;
name|search_stack
operator|=
name|push_search_level
argument_list|(
name|search_stack
argument_list|,
operator|&
name|search_obstack
argument_list|)
expr_stmt|;
name|BINFO_VIA_PUBLIC
argument_list|(
name|basetype_path
argument_list|)
operator|=
literal|1
expr_stmt|;
name|BINFO_INHERITANCE_CHAIN
argument_list|(
name|basetype_path
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
name|binfo
operator|=
name|basetype_path
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|tree
name|binfos
init|=
name|BINFO_BASETYPES
argument_list|(
name|binfo
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|,
name|n_baselinks
init|=
name|binfos
condition|?
name|TREE_VEC_LENGTH
argument_list|(
name|binfos
argument_list|)
else|:
literal|0
decl_stmt|;
comment|/* Process and/or queue base types.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_baselinks
condition|;
name|i
operator|++
control|)
block|{
name|tree
name|base_binfo
init|=
name|TREE_VEC_ELT
argument_list|(
name|binfos
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|BINFO_FIELDS_MARKED
argument_list|(
name|base_binfo
argument_list|)
operator|==
literal|0
condition|)
block|{
name|tree
name|btypes
decl_stmt|;
name|SET_BINFO_FIELDS_MARKED
argument_list|(
name|base_binfo
argument_list|)
expr_stmt|;
name|btypes
operator|=
name|my_tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|base_binfo
argument_list|,
name|basetype_chain
argument_list|)
expr_stmt|;
name|TREE_VIA_PUBLIC
argument_list|(
name|btypes
argument_list|)
operator|=
name|TREE_VIA_PUBLIC
argument_list|(
name|base_binfo
argument_list|)
expr_stmt|;
name|TREE_VIA_PROTECTED
argument_list|(
name|btypes
argument_list|)
operator|=
name|TREE_VIA_PROTECTED
argument_list|(
name|base_binfo
argument_list|)
expr_stmt|;
name|TREE_VIA_VIRTUAL
argument_list|(
name|btypes
argument_list|)
operator|=
name|TREE_VIA_VIRTUAL
argument_list|(
name|base_binfo
argument_list|)
expr_stmt|;
name|obstack_ptr_grow
argument_list|(
operator|&
name|search_obstack
argument_list|,
name|btypes
argument_list|)
expr_stmt|;
name|tail
operator|+=
literal|1
expr_stmt|;
if|if
condition|(
name|tail
operator|>=
name|search_stack
operator|->
name|limit
condition|)
name|my_friendly_abort
argument_list|(
literal|99
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Process head of queue, if one exists.  */
if|if
condition|(
name|head
operator|>=
name|tail
condition|)
break|break;
name|basetype_chain
operator|=
name|search_stack
operator|->
name|first
index|[
name|head
operator|++
index|]
expr_stmt|;
name|basetype_path
operator|=
name|TREE_VALUE
argument_list|(
name|basetype_chain
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CHAIN
argument_list|(
name|basetype_chain
argument_list|)
condition|)
name|BINFO_INHERITANCE_CHAIN
argument_list|(
name|basetype_path
argument_list|)
operator|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|basetype_chain
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|BINFO_INHERITANCE_CHAIN
argument_list|(
name|basetype_path
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
name|binfo
operator|=
name|basetype_path
expr_stmt|;
name|type
operator|=
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
expr_stmt|;
comment|/* See if we can find NAME in TYPE.  If RVAL is nonzero, 	 and we do find NAME in TYPE, verify that such a second 	 sighting is in fact legal.  */
if|if
condition|(
name|rval
condition|)
block|{
name|tree
name|context
init|=
name|DECL_CLASS_CONTEXT
argument_list|(
name|rval
argument_list|)
decl_stmt|;
comment|/* Just another way of finding the same member.  */
if|if
condition|(
name|TYPE_BINFO
argument_list|(
name|context
argument_list|)
operator|==
name|binfo
condition|)
empty_stmt|;
comment|/* Same baseclass, maybe different places in the lattice.  */
elseif|else
if|if
condition|(
name|context
operator|==
name|type
condition|)
block|{
if|if
condition|(
name|TREE_VIA_VIRTUAL
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|rvals
argument_list|)
argument_list|)
condition|)
if|if
condition|(
name|TREE_VIA_VIRTUAL
argument_list|(
name|binfo
argument_list|)
condition|)
empty_stmt|;
else|else
name|errstr
operator|=
literal|"member `%s' belongs to virtual and non-virtual baseclasses `%s'"
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_VIA_VIRTUAL
argument_list|(
name|binfo
argument_list|)
condition|)
name|errstr
operator|=
literal|"member `%s' belongs to virtual and non-virtual baseclasses `%s'"
expr_stmt|;
else|else
name|errstr
operator|=
literal|"member `%s' belongs to MI-distinct base classes `%s'"
expr_stmt|;
block|}
else|else
block|{
name|int
name|index
init|=
name|lookup_fnfields_1
argument_list|(
name|type
argument_list|,
name|name
argument_list|)
decl_stmt|;
comment|/* ??? This code is broken.  If CONTEXT is not the leftmost 		 baseclass, it makes all of its baseclasses appear to be 		 unrelated.  */
if|if
condition|(
name|index
operator|>=
literal|0
operator|&&
name|binfo
operator|!=
name|get_binfo
argument_list|(
name|type
argument_list|,
name|context
argument_list|,
literal|0
argument_list|)
condition|)
block|{
comment|/* We found it in other than a baseclass of RVAL's.  */
name|rvals
operator|=
name|my_tree_cons
argument_list|(
name|basetype_path
argument_list|,
name|TREE_VEC_ELT
argument_list|(
name|CLASSTYPE_METHOD_VEC
argument_list|(
name|type
argument_list|)
argument_list|,
name|index
argument_list|)
argument_list|,
name|rvals
argument_list|)
expr_stmt|;
if|if
condition|(
name|CLASSTYPE_BASELINK_VEC
argument_list|(
name|type
argument_list|)
condition|)
name|TREE_TYPE
argument_list|(
name|rvals
argument_list|)
operator|=
name|TREE_VEC_ELT
argument_list|(
name|CLASSTYPE_BASELINK_VEC
argument_list|(
name|type
argument_list|)
argument_list|,
name|index
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|errstr
operator|&&
name|entry
condition|)
block|{
name|tree
name|error_string
init|=
name|my_build_string
argument_list|(
name|errstr
argument_list|)
decl_stmt|;
name|TREE_TYPE
argument_list|(
name|entry
argument_list|)
operator|=
name|error_string
expr_stmt|;
block|}
if|if
condition|(
name|errstr
operator|&&
name|find_ambiguous
condition|)
block|{
name|rvals
operator|=
name|error_mark_node
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
name|int
name|index
init|=
name|lookup_fnfields_1
argument_list|(
name|type
argument_list|,
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|index
operator|>=
literal|0
condition|)
block|{
name|rval
operator|=
name|TREE_VEC_ELT
argument_list|(
name|CLASSTYPE_METHOD_VEC
argument_list|(
name|type
argument_list|)
argument_list|,
name|index
argument_list|)
expr_stmt|;
name|rvals
operator|=
name|my_tree_cons
argument_list|(
name|basetype_path
argument_list|,
name|rval
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_BINFO_BASETYPES
argument_list|(
name|type
argument_list|)
operator|&&
name|CLASSTYPE_BASELINK_VEC
argument_list|(
name|type
argument_list|)
condition|)
name|TREE_TYPE
argument_list|(
name|rvals
argument_list|)
operator|=
name|TREE_VEC_ELT
argument_list|(
name|CLASSTYPE_BASELINK_VEC
argument_list|(
name|type
argument_list|)
argument_list|,
name|index
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
condition|)
name|TREE_VALUE
argument_list|(
name|entry
argument_list|)
operator|=
name|rvals
expr_stmt|;
block|}
else|else
name|rval
operator|=
name|NULL_TREE
expr_stmt|;
block|}
block|}
block|{
name|tree
modifier|*
name|tp
init|=
name|search_stack
operator|->
name|first
decl_stmt|;
name|tree
modifier|*
name|search_tail
init|=
name|tp
operator|+
name|tail
decl_stmt|;
while|while
condition|(
name|tp
operator|<
name|search_tail
condition|)
block|{
name|CLEAR_BINFO_FIELDS_MARKED
argument_list|(
name|TREE_VALUE
argument_list|(
operator|*
name|tp
argument_list|)
argument_list|)
expr_stmt|;
name|tp
operator|+=
literal|1
expr_stmt|;
block|}
block|}
name|search_stack
operator|=
name|pop_search_level
argument_list|(
name|search_stack
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
condition|)
block|{
if|if
condition|(
name|errstr
condition|)
block|{
name|tree
name|error_string
init|=
name|my_build_string
argument_list|(
name|errstr
argument_list|)
decl_stmt|;
comment|/* Save error message with entry.  */
name|TREE_TYPE
argument_list|(
name|entry
argument_list|)
operator|=
name|error_string
expr_stmt|;
block|}
else|else
block|{
comment|/* Mark entry as having no error string.  */
name|TREE_TYPE
argument_list|(
name|entry
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
block|}
block|}
if|if
condition|(
name|errstr
operator|&&
name|protect
condition|)
block|{
name|error
argument_list|(
name|errstr
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|,
name|TYPE_NAME_STRING
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|rvals
operator|=
name|error_mark_node
expr_stmt|;
block|}
return|return
name|rvals
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* BREADTH-FIRST SEARCH ROUTINES.  */
end_comment

begin_comment
comment|/* Search a multiple inheritance hierarchy by breadth-first search.     TYPE is an aggregate type, possibly in a multiple-inheritance hierarchy.    TESTFN is a function, which, if true, means that our condition has been met,    and its return value should be returned.    QFN, if non-NULL, is a predicate dictating whether the type should    even be queued.  */
end_comment

begin_decl_stmt
name|HOST_WIDE_INT
name|breadth_first_search
argument_list|(
name|binfo
argument_list|,
name|testfn
argument_list|,
name|qfn
argument_list|)
name|tree
name|binfo
decl_stmt|;
end_decl_stmt

begin_function_decl
name|int
function_decl|(
modifier|*
name|testfn
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
function_decl|(
modifier|*
name|qfn
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_block
block|{
name|int
name|head
init|=
literal|0
decl_stmt|,
name|tail
init|=
literal|0
decl_stmt|;
name|int
name|rval
init|=
literal|0
decl_stmt|;
name|search_stack
operator|=
name|push_search_level
argument_list|(
name|search_stack
argument_list|,
operator|&
name|search_obstack
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|tree
name|binfos
init|=
name|BINFO_BASETYPES
argument_list|(
name|binfo
argument_list|)
decl_stmt|;
name|int
name|n_baselinks
init|=
name|binfos
condition|?
name|TREE_VEC_LENGTH
argument_list|(
name|binfos
argument_list|)
else|:
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Process and/or queue base types.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_baselinks
condition|;
name|i
operator|++
control|)
block|{
name|tree
name|base_binfo
init|=
name|TREE_VEC_ELT
argument_list|(
name|binfos
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|BINFO_MARKED
argument_list|(
name|base_binfo
argument_list|)
operator|==
literal|0
operator|&&
operator|(
name|qfn
operator|==
literal|0
operator|||
call|(
modifier|*
name|qfn
call|)
argument_list|(
name|binfo
argument_list|,
name|i
argument_list|)
operator|)
condition|)
block|{
name|SET_BINFO_MARKED
argument_list|(
name|base_binfo
argument_list|)
expr_stmt|;
name|obstack_ptr_grow
argument_list|(
operator|&
name|search_obstack
argument_list|,
name|binfo
argument_list|)
expr_stmt|;
name|obstack_int_grow
argument_list|(
operator|&
name|search_obstack
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|tail
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
name|tail
operator|>=
name|search_stack
operator|->
name|limit
condition|)
name|my_friendly_abort
argument_list|(
literal|100
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Process head of queue, if one exists.  */
if|if
condition|(
name|head
operator|>=
name|tail
condition|)
block|{
name|rval
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|binfo
operator|=
name|search_stack
operator|->
name|first
index|[
name|head
operator|++
index|]
expr_stmt|;
name|i
operator|=
operator|(
name|HOST_WIDE_INT
operator|)
name|search_stack
operator|->
name|first
index|[
name|head
operator|++
index|]
expr_stmt|;
if|if
condition|(
name|rval
operator|=
call|(
modifier|*
name|testfn
call|)
argument_list|(
name|binfo
argument_list|,
name|i
argument_list|)
condition|)
break|break;
name|binfo
operator|=
name|BINFO_BASETYPE
argument_list|(
name|binfo
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
block|{
name|tree
modifier|*
name|tp
init|=
name|search_stack
operator|->
name|first
decl_stmt|;
name|tree
modifier|*
name|search_tail
init|=
name|tp
operator|+
name|tail
decl_stmt|;
while|while
condition|(
name|tp
operator|<
name|search_tail
condition|)
block|{
name|tree
name|binfo
init|=
operator|*
name|tp
operator|++
decl_stmt|;
name|int
name|i
init|=
call|(
name|HOST_WIDE_INT
call|)
argument_list|(
operator|*
name|tp
operator|++
argument_list|)
decl_stmt|;
name|CLEAR_BINFO_MARKED
argument_list|(
name|BINFO_BASETYPE
argument_list|(
name|binfo
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|search_stack
operator|=
name|pop_search_level
argument_list|(
name|search_stack
argument_list|)
expr_stmt|;
return|return
name|rval
return|;
block|}
end_block

begin_comment
comment|/* Functions to use in breadth first searches.  */
end_comment

begin_typedef
typedef|typedef
name|tree
function_decl|(
modifier|*
name|pft
function_decl|)
parameter_list|()
function_decl|;
end_typedef

begin_typedef
typedef|typedef
name|int
function_decl|(
modifier|*
name|pfi
function_decl|)
parameter_list|()
function_decl|;
end_typedef

begin_function
name|int
name|tree_needs_constructor_p
parameter_list|(
name|binfo
parameter_list|,
name|i
parameter_list|)
name|tree
name|binfo
decl_stmt|;
name|int
name|i
decl_stmt|;
block|{
name|tree
name|basetype
decl_stmt|;
name|my_friendly_assert
argument_list|(
name|i
operator|!=
literal|0
argument_list|,
literal|296
argument_list|)
expr_stmt|;
name|basetype
operator|=
name|BINFO_TYPE
argument_list|(
name|BINFO_BASETYPE
argument_list|(
name|binfo
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|TYPE_NEEDS_CONSTRUCTOR
argument_list|(
name|basetype
argument_list|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|tree
name|declarator
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|tree
name|get_virtuals_named_this
parameter_list|(
name|binfo
parameter_list|,
name|i
parameter_list|)
name|tree
name|binfo
decl_stmt|;
name|int
name|i
decl_stmt|;
block|{
name|tree
name|fields
decl_stmt|;
name|tree
name|type
init|=
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
decl_stmt|;
if|if
condition|(
name|i
operator|>=
literal|0
condition|)
name|type
operator|=
name|BINFO_TYPE
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|BINFO_BASETYPES
argument_list|(
name|binfo
argument_list|)
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|fields
operator|=
name|lookup_fnfields
argument_list|(
name|binfo
argument_list|,
name|declarator
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|fields
operator|==
literal|0
operator|||
name|fields
operator|==
name|error_mark_node
condition|)
return|return
literal|0
return|;
comment|/* Get to the function decls, and return the first virtual function      with this name, if there is one.  */
while|while
condition|(
name|fields
condition|)
block|{
name|tree
name|fndecl
decl_stmt|;
for|for
control|(
name|fndecl
operator|=
name|TREE_VALUE
argument_list|(
name|fields
argument_list|)
init|;
name|fndecl
condition|;
name|fndecl
operator|=
name|DECL_CHAIN
argument_list|(
name|fndecl
argument_list|)
control|)
if|if
condition|(
name|DECL_VINDEX
argument_list|(
name|fndecl
argument_list|)
condition|)
return|return
name|fields
return|;
name|fields
operator|=
name|next_baselink
argument_list|(
name|fields
argument_list|)
expr_stmt|;
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_function
specifier|static
name|tree
name|get_virtual_destructor
parameter_list|(
name|binfo
parameter_list|,
name|i
parameter_list|)
name|tree
name|binfo
decl_stmt|;
name|int
name|i
decl_stmt|;
block|{
name|tree
name|type
init|=
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
decl_stmt|;
if|if
condition|(
name|i
operator|>=
literal|0
condition|)
name|type
operator|=
name|BINFO_TYPE
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|BINFO_BASETYPES
argument_list|(
name|binfo
argument_list|)
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_HAS_DESTRUCTOR
argument_list|(
name|type
argument_list|)
operator|&&
name|DECL_VINDEX
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|CLASSTYPE_METHOD_VEC
argument_list|(
name|type
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
return|return
name|TREE_VEC_ELT
argument_list|(
name|CLASSTYPE_METHOD_VEC
argument_list|(
name|type
argument_list|)
argument_list|,
literal|0
argument_list|)
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|tree_has_any_destructor_p
parameter_list|(
name|binfo
parameter_list|,
name|i
parameter_list|)
name|tree
name|binfo
decl_stmt|;
name|int
name|i
decl_stmt|;
block|{
name|tree
name|type
init|=
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
decl_stmt|;
if|if
condition|(
name|i
operator|>=
literal|0
condition|)
name|type
operator|=
name|BINFO_TYPE
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|BINFO_BASETYPES
argument_list|(
name|binfo
argument_list|)
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|TYPE_NEEDS_DESTRUCTOR
argument_list|(
name|type
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Given a class type TYPE, and a function decl FNDECL,    look for the first function the TYPE's hierarchy which    FNDECL could match as a virtual function.     DTORP is nonzero if we are looking for a destructor.  Destructors    need special treatment because they do not match by name.  */
end_comment

begin_function
name|tree
name|get_first_matching_virtual
parameter_list|(
name|binfo
parameter_list|,
name|fndecl
parameter_list|,
name|dtorp
parameter_list|)
name|tree
name|binfo
decl_stmt|,
name|fndecl
decl_stmt|;
name|int
name|dtorp
decl_stmt|;
block|{
name|tree
name|tmp
init|=
name|NULL_TREE
decl_stmt|;
comment|/* Breadth first search routines start searching basetypes      of TYPE, so we must perform first ply of search here.  */
if|if
condition|(
name|dtorp
condition|)
block|{
if|if
condition|(
name|tree_has_any_destructor_p
argument_list|(
name|binfo
argument_list|,
operator|-
literal|1
argument_list|)
condition|)
name|tmp
operator|=
name|get_virtual_destructor
argument_list|(
name|binfo
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
condition|)
block|{
if|if
condition|(
name|get_base_distance
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|tmp
argument_list|)
argument_list|,
name|DECL_CONTEXT
argument_list|(
name|fndecl
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|>
literal|0
condition|)
name|DECL_CONTEXT
argument_list|(
name|fndecl
argument_list|)
operator|=
name|DECL_CONTEXT
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
return|return
name|tmp
return|;
block|}
name|tmp
operator|=
operator|(
name|tree
operator|)
name|breadth_first_search
argument_list|(
name|binfo
argument_list|,
operator|(
name|pfi
operator|)
name|get_virtual_destructor
argument_list|,
name|tree_has_any_destructor_p
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
condition|)
name|DECL_CONTEXT
argument_list|(
name|fndecl
argument_list|)
operator|=
name|DECL_CONTEXT
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
return|return
name|tmp
return|;
block|}
else|else
block|{
name|tree
name|drettype
decl_stmt|,
name|dtypes
decl_stmt|,
name|btypes
decl_stmt|,
name|instptr_type
decl_stmt|;
name|tree
name|basetype
init|=
name|DECL_CLASS_CONTEXT
argument_list|(
name|fndecl
argument_list|)
decl_stmt|;
name|tree
name|baselink
decl_stmt|,
name|best
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|name
init|=
name|DECL_ASSEMBLER_NAME
argument_list|(
name|fndecl
argument_list|)
decl_stmt|;
name|declarator
operator|=
name|DECL_NAME
argument_list|(
name|fndecl
argument_list|)
expr_stmt|;
if|if
condition|(
name|IDENTIFIER_VIRTUAL_P
argument_list|(
name|declarator
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|drettype
operator|=
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|fndecl
argument_list|)
argument_list|)
expr_stmt|;
name|dtypes
operator|=
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|fndecl
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_STATIC_FUNCTION_P
argument_list|(
name|fndecl
argument_list|)
condition|)
name|instptr_type
operator|=
name|NULL_TREE
expr_stmt|;
else|else
name|instptr_type
operator|=
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|dtypes
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|baselink
operator|=
name|get_virtuals_named_this
argument_list|(
name|binfo
argument_list|,
operator|-
literal|1
argument_list|)
init|;
name|baselink
condition|;
name|baselink
operator|=
name|next_baselink
argument_list|(
name|baselink
argument_list|)
control|)
block|{
for|for
control|(
name|tmp
operator|=
name|TREE_VALUE
argument_list|(
name|baselink
argument_list|)
init|;
name|tmp
condition|;
name|tmp
operator|=
name|DECL_CHAIN
argument_list|(
name|tmp
argument_list|)
control|)
block|{
if|if
condition|(
operator|!
name|DECL_VINDEX
argument_list|(
name|tmp
argument_list|)
condition|)
continue|continue;
name|btypes
operator|=
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|tmp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|instptr_type
operator|==
name|NULL_TREE
condition|)
block|{
if|if
condition|(
name|compparms
argument_list|(
name|TREE_CHAIN
argument_list|(
name|btypes
argument_list|)
argument_list|,
name|dtypes
argument_list|,
literal|3
argument_list|)
condition|)
comment|/* Caller knows to give error in this case.  */
return|return
name|tmp
return|;
return|return
name|NULL_TREE
return|;
block|}
if|if
condition|(
operator|(
name|TYPE_READONLY
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|btypes
argument_list|)
argument_list|)
argument_list|)
operator|==
name|TYPE_READONLY
argument_list|(
name|instptr_type
argument_list|)
operator|)
operator|&&
name|compparms
argument_list|(
name|TREE_CHAIN
argument_list|(
name|btypes
argument_list|)
argument_list|,
name|TREE_CHAIN
argument_list|(
name|dtypes
argument_list|)
argument_list|,
literal|3
argument_list|)
condition|)
block|{
if|if
condition|(
name|IDENTIFIER_ERROR_LOCUS
argument_list|(
name|name
argument_list|)
operator|==
name|NULL_TREE
operator|&&
operator|!
name|comptypes
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|tmp
argument_list|)
argument_list|)
argument_list|,
name|drettype
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|error_with_decl
argument_list|(
name|fndecl
argument_list|,
literal|"conflicting return type specified for virtual function `%s'"
argument_list|)
expr_stmt|;
name|SET_IDENTIFIER_ERROR_LOCUS
argument_list|(
name|name
argument_list|,
name|basetype
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
if|if
condition|(
name|tmp
condition|)
block|{
comment|/* If this is ambiguous, we will warn about it later.  */
if|if
condition|(
name|best
condition|)
block|{
if|if
condition|(
name|get_base_distance
argument_list|(
name|DECL_CLASS_CONTEXT
argument_list|(
name|best
argument_list|)
argument_list|,
name|DECL_CLASS_CONTEXT
argument_list|(
name|tmp
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|>
literal|0
condition|)
name|best
operator|=
name|tmp
expr_stmt|;
block|}
else|else
name|best
operator|=
name|tmp
expr_stmt|;
block|}
block|}
if|if
condition|(
name|IDENTIFIER_ERROR_LOCUS
argument_list|(
name|name
argument_list|)
operator|==
name|NULL_TREE
operator|&&
name|best
operator|==
name|NULL_TREE
operator|&&
name|warn_overloaded_virtual
condition|)
block|{
name|error_with_decl
argument_list|(
name|fndecl
argument_list|,
literal|"conflicting specification deriving virtual function `%s'"
argument_list|)
expr_stmt|;
name|SET_IDENTIFIER_ERROR_LOCUS
argument_list|(
name|name
argument_list|,
name|basetype
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|best
condition|)
block|{
name|DECL_CONTEXT
argument_list|(
name|fndecl
argument_list|)
operator|=
name|DECL_CONTEXT
argument_list|(
name|best
argument_list|)
expr_stmt|;
block|}
return|return
name|best
return|;
block|}
block|}
end_function

begin_comment
comment|/* Return the list of virtual functions which are abstract in type TYPE.    This information is cached, and so must be built on a    non-temporary obstack.  */
end_comment

begin_function
name|tree
name|get_abstract_virtuals
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
comment|/* For each layer of base class (i.e., the first base class, and each      virtual base class from that one), modify the virtual function table      of the derived class to contain the new virtual function.      A class has as many vfields as it has virtual base classes (total).  */
name|tree
name|vfields
decl_stmt|,
name|vbases
decl_stmt|,
name|base
decl_stmt|,
name|tmp
decl_stmt|;
name|tree
name|vfield
init|=
name|CLASSTYPE_VFIELD
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|tree
name|fcontext
init|=
name|vfield
condition|?
name|DECL_FCONTEXT
argument_list|(
name|vfield
argument_list|)
else|:
name|NULL_TREE
decl_stmt|;
name|tree
name|abstract_virtuals
init|=
name|CLASSTYPE_ABSTRACT_VIRTUALS
argument_list|(
name|type
argument_list|)
decl_stmt|;
for|for
control|(
name|vfields
operator|=
name|CLASSTYPE_VFIELDS
argument_list|(
name|type
argument_list|)
init|;
name|vfields
condition|;
name|vfields
operator|=
name|TREE_CHAIN
argument_list|(
name|vfields
argument_list|)
control|)
block|{
name|int
name|normal
decl_stmt|;
comment|/* Find the right base class for this derived class, call it BASE.  */
name|base
operator|=
name|VF_BASETYPE_VALUE
argument_list|(
name|vfields
argument_list|)
expr_stmt|;
if|if
condition|(
name|base
operator|==
name|type
condition|)
continue|continue;
comment|/* We call this case NORMAL iff this virtual function table 	 pointer field has its storage reserved in this class. 	 This is normally the case without virtual baseclasses 	 or off-center multiple baseclasses.  */
name|normal
operator|=
operator|(
name|base
operator|==
name|fcontext
operator|&&
operator|(
name|VF_BINFO_VALUE
argument_list|(
name|vfields
argument_list|)
operator|==
name|NULL_TREE
operator|||
operator|!
name|TREE_VIA_VIRTUAL
argument_list|(
name|VF_BINFO_VALUE
argument_list|(
name|vfields
argument_list|)
argument_list|)
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|normal
condition|)
name|tmp
operator|=
name|TREE_CHAIN
argument_list|(
name|TYPE_BINFO_VIRTUALS
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* n.b.: VF_BASETYPE_VALUE (vfields) is the first basetype 	     that provides the virtual function table, whereas 	     VF_DERIVED_VALUE (vfields) is an immediate base type of TYPE 	     that dominates VF_BASETYPE_VALUE (vfields).  The list of 	     vfields we want lies between these two values.  */
name|tree
name|binfo
init|=
name|get_binfo
argument_list|(
name|VF_NORMAL_VALUE
argument_list|(
name|vfields
argument_list|)
argument_list|,
name|type
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tmp
operator|=
name|TREE_CHAIN
argument_list|(
name|BINFO_VIRTUALS
argument_list|(
name|binfo
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Get around dossier entry if there is one.  */
if|if
condition|(
name|flag_dossier
condition|)
name|tmp
operator|=
name|TREE_CHAIN
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
while|while
condition|(
name|tmp
condition|)
block|{
name|tree
name|base_pfn
init|=
name|FNADDR_FROM_VTABLE_ENTRY
argument_list|(
name|TREE_VALUE
argument_list|(
name|tmp
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|base_fndecl
init|=
name|TREE_OPERAND
argument_list|(
name|base_pfn
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|DECL_ABSTRACT_VIRTUAL_P
argument_list|(
name|base_fndecl
argument_list|)
condition|)
name|abstract_virtuals
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|base_fndecl
argument_list|,
name|abstract_virtuals
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|TREE_CHAIN
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|vbases
operator|=
name|CLASSTYPE_VBASECLASSES
argument_list|(
name|type
argument_list|)
init|;
name|vbases
condition|;
name|vbases
operator|=
name|TREE_CHAIN
argument_list|(
name|vbases
argument_list|)
control|)
block|{
if|if
condition|(
operator|!
name|BINFO_VIRTUALS
argument_list|(
name|vbases
argument_list|)
condition|)
continue|continue;
name|tmp
operator|=
name|TREE_CHAIN
argument_list|(
name|BINFO_VIRTUALS
argument_list|(
name|vbases
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|tmp
condition|)
block|{
name|tree
name|base_pfn
init|=
name|FNADDR_FROM_VTABLE_ENTRY
argument_list|(
name|TREE_VALUE
argument_list|(
name|tmp
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|base_fndecl
init|=
name|TREE_OPERAND
argument_list|(
name|base_pfn
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|DECL_ABSTRACT_VIRTUAL_P
argument_list|(
name|base_fndecl
argument_list|)
condition|)
name|abstract_virtuals
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|base_fndecl
argument_list|,
name|abstract_virtuals
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|TREE_CHAIN
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|nreverse
argument_list|(
name|abstract_virtuals
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* For the type TYPE, return a list of member functions available from    base classes with name NAME.  The TREE_VALUE of the list is a chain of    member functions with name NAME.  The TREE_PURPOSE of the list is a    basetype, or a list of base types (in reverse order) which were    traversed to reach the chain of member functions.  If we reach a base    type which provides a member function of name NAME, and which has at    most one base type itself, then we can terminate the search.  */
end_comment

begin_function
name|tree
name|get_baselinks
parameter_list|(
name|type_as_binfo_list
parameter_list|,
name|type
parameter_list|,
name|name
parameter_list|)
name|tree
name|type_as_binfo_list
decl_stmt|;
name|tree
name|type
decl_stmt|,
name|name
decl_stmt|;
block|{
name|tree
name|hash_tree_cons
parameter_list|()
function_decl|;
name|int
name|head
init|=
literal|0
decl_stmt|,
name|tail
init|=
literal|0
decl_stmt|,
name|index
decl_stmt|;
name|tree
name|rval
init|=
literal|0
decl_stmt|,
name|nval
init|=
literal|0
decl_stmt|;
name|tree
name|basetypes
init|=
name|type_as_binfo_list
decl_stmt|;
name|tree
name|binfo
init|=
name|TYPE_BINFO
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|search_stack
operator|=
name|push_search_level
argument_list|(
name|search_stack
argument_list|,
operator|&
name|search_obstack
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|tree
name|binfos
init|=
name|BINFO_BASETYPES
argument_list|(
name|binfo
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|,
name|n_baselinks
init|=
name|binfos
condition|?
name|TREE_VEC_LENGTH
argument_list|(
name|binfos
argument_list|)
else|:
literal|0
decl_stmt|;
comment|/* Process and/or queue base types.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_baselinks
condition|;
name|i
operator|++
control|)
block|{
name|tree
name|base_binfo
init|=
name|TREE_VEC_ELT
argument_list|(
name|binfos
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|tree
name|btypes
decl_stmt|;
name|btypes
operator|=
name|hash_tree_cons
argument_list|(
name|TREE_VIA_PUBLIC
argument_list|(
name|base_binfo
argument_list|)
argument_list|,
name|TREE_VIA_VIRTUAL
argument_list|(
name|base_binfo
argument_list|)
argument_list|,
name|TREE_VIA_PROTECTED
argument_list|(
name|base_binfo
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|,
name|base_binfo
argument_list|,
name|basetypes
argument_list|)
expr_stmt|;
name|obstack_ptr_grow
argument_list|(
operator|&
name|search_obstack
argument_list|,
name|btypes
argument_list|)
expr_stmt|;
name|search_stack
operator|->
name|first
operator|=
operator|(
name|tree
operator|*
operator|)
name|obstack_base
argument_list|(
operator|&
name|search_obstack
argument_list|)
expr_stmt|;
name|tail
operator|+=
literal|1
expr_stmt|;
block|}
name|dont_queue
label|:
comment|/* Process head of queue, if one exists.  */
if|if
condition|(
name|head
operator|>=
name|tail
condition|)
break|break;
name|basetypes
operator|=
name|search_stack
operator|->
name|first
index|[
name|head
operator|++
index|]
expr_stmt|;
name|binfo
operator|=
name|TREE_VALUE
argument_list|(
name|basetypes
argument_list|)
expr_stmt|;
name|type
operator|=
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
expr_stmt|;
name|index
operator|=
name|lookup_fnfields_1
argument_list|(
name|type
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|index
operator|>=
literal|0
condition|)
block|{
name|nval
operator|=
name|TREE_VEC_ELT
argument_list|(
name|CLASSTYPE_METHOD_VEC
argument_list|(
name|type
argument_list|)
argument_list|,
name|index
argument_list|)
expr_stmt|;
name|rval
operator|=
name|hash_tree_cons
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|basetypes
argument_list|,
name|nval
argument_list|,
name|rval
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_BINFO_BASETYPES
argument_list|(
name|type
argument_list|)
operator|==
literal|0
condition|)
goto|goto
name|dont_queue
goto|;
elseif|else
if|if
condition|(
name|TREE_VEC_LENGTH
argument_list|(
name|TYPE_BINFO_BASETYPES
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|CLASSTYPE_BASELINK_VEC
argument_list|(
name|type
argument_list|)
condition|)
name|TREE_TYPE
argument_list|(
name|rval
argument_list|)
operator|=
name|TREE_VEC_ELT
argument_list|(
name|CLASSTYPE_BASELINK_VEC
argument_list|(
name|type
argument_list|)
argument_list|,
name|index
argument_list|)
expr_stmt|;
goto|goto
name|dont_queue
goto|;
block|}
block|}
name|nval
operator|=
name|NULL_TREE
expr_stmt|;
block|}
name|search_stack
operator|=
name|pop_search_level
argument_list|(
name|search_stack
argument_list|)
expr_stmt|;
return|return
name|rval
return|;
block|}
end_function

begin_function
name|tree
name|next_baselink
parameter_list|(
name|baselink
parameter_list|)
name|tree
name|baselink
decl_stmt|;
block|{
name|tree
name|tmp
init|=
name|TREE_TYPE
argument_list|(
name|baselink
argument_list|)
decl_stmt|;
name|baselink
operator|=
name|TREE_CHAIN
argument_list|(
name|baselink
argument_list|)
expr_stmt|;
while|while
condition|(
name|tmp
condition|)
block|{
comment|/* @@ does not yet add previous base types.  */
name|baselink
operator|=
name|tree_cons
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|tmp
argument_list|)
argument_list|,
name|TREE_VALUE
argument_list|(
name|tmp
argument_list|)
argument_list|,
name|baselink
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|baselink
argument_list|)
operator|=
name|TREE_TYPE
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|TREE_CHAIN
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
block|}
return|return
name|baselink
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* DEPTH-FIRST SEARCH ROUTINES.  */
end_comment

begin_comment
comment|/* Assign unique numbers to _CLASSTYPE members of the lattice    specified by TYPE.  The root nodes are marked first; the nodes    are marked depth-fisrt, left-right.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|cid
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Matrix implementing a relation from CLASSTYPE X CLASSTYPE => INT.    Relation yields 1 if C1<= C2, 0 otherwise.  */
end_comment

begin_typedef
typedef|typedef
name|char
name|mi_boolean
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|mi_boolean
modifier|*
name|mi_matrix
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Type for which this matrix is defined.  */
end_comment

begin_decl_stmt
specifier|static
name|tree
name|mi_type
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Size of the matrix for indexing purposes.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|mi_size
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Return nonzero if class C2 derives from class C1.  */
end_comment

begin_define
define|#
directive|define
name|BINFO_DERIVES_FROM
parameter_list|(
name|C1
parameter_list|,
name|C2
parameter_list|)
define|\
value|((mi_matrix+mi_size*(BINFO_CID (C1)-1))[BINFO_CID (C2)-1])
end_define

begin_define
define|#
directive|define
name|TYPE_DERIVES_FROM
parameter_list|(
name|C1
parameter_list|,
name|C2
parameter_list|)
define|\
value|((mi_matrix+mi_size*(CLASSTYPE_CID (C1)-1))[CLASSTYPE_CID (C2)-1])
end_define

begin_define
define|#
directive|define
name|BINFO_DERIVES_FROM_STAR
parameter_list|(
name|C
parameter_list|)
define|\
value|(mi_matrix+(BINFO_CID (C)-1))
end_define

begin_comment
comment|/* This routine converts a pointer to be a pointer of an immediate    base class.  The normal convert_pointer_to routine would diagnose    the conversion as ambiguous, under MI code that has the base class    as an ambiguous base class. */
end_comment

begin_function
specifier|static
name|tree
name|convert_pointer_to_single_level
parameter_list|(
name|to_type
parameter_list|,
name|expr
parameter_list|)
name|tree
name|to_type
decl_stmt|,
name|expr
decl_stmt|;
block|{
name|tree
name|binfo_of_derived
decl_stmt|;
name|tree
name|last
decl_stmt|;
name|binfo_of_derived
operator|=
name|TYPE_BINFO
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|last
operator|=
name|get_binfo
argument_list|(
name|to_type
argument_list|,
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|BINFO_INHERITANCE_CHAIN
argument_list|(
name|last
argument_list|)
operator|=
name|binfo_of_derived
expr_stmt|;
name|BINFO_INHERITANCE_CHAIN
argument_list|(
name|binfo_of_derived
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
return|return
name|build_vbase_path
argument_list|(
name|PLUS_EXPR
argument_list|,
name|TYPE_POINTER_TO
argument_list|(
name|to_type
argument_list|)
argument_list|,
name|expr
argument_list|,
name|last
argument_list|,
literal|1
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* The main function which implements depth first search.     This routine has to remember the path it walked up, when    dfs_init_vbase_pointers is the work function, as otherwise there    would be no record. */
end_comment

begin_decl_stmt
specifier|static
name|void
name|dfs_walk
argument_list|(
name|binfo
argument_list|,
name|fn
argument_list|,
name|qfn
argument_list|)
name|tree
name|binfo
decl_stmt|;
end_decl_stmt

begin_function_decl
name|void
function_decl|(
modifier|*
name|fn
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
function_decl|(
modifier|*
name|qfn
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_block
block|{
name|tree
name|binfos
init|=
name|BINFO_BASETYPES
argument_list|(
name|binfo
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|,
name|n_baselinks
init|=
name|binfos
condition|?
name|TREE_VEC_LENGTH
argument_list|(
name|binfos
argument_list|)
else|:
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_baselinks
condition|;
name|i
operator|++
control|)
block|{
name|tree
name|base_binfo
init|=
name|TREE_VEC_ELT
argument_list|(
name|binfos
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
call|(
modifier|*
name|qfn
call|)
argument_list|(
name|base_binfo
argument_list|)
condition|)
block|{
if|if
condition|(
name|fn
operator|==
name|dfs_init_vbase_pointers
condition|)
block|{
comment|/* When traversing an arbitrary MI hierarchy, we need to keep 		 a record of the path we took to get down to the final base 		 type, as otherwise there would be no record of it, and just 		 trying to blindly convert at the bottom would be ambiguous.  		 The easiest way is to do the conversions one step at a time, 		 as we know we want the immediate base class at each step.  		 The only special trick to converting one step at a time, 		 is that when we hit the first virtual base class, we must 		 use the SLOT value for it, and not use the normal convert 		 routine. 		 */
name|tree
name|saved_vbase_decl_ptr_intermediate
init|=
name|vbase_decl_ptr_intermediate
decl_stmt|;
name|int
name|save_saw_first_vbase
init|=
name|saw_first_vbase
decl_stmt|;
if|if
condition|(
operator|!
name|saw_first_vbase
operator|&&
name|TREE_VIA_VIRTUAL
argument_list|(
name|base_binfo
argument_list|)
condition|)
block|{
name|saw_first_vbase
operator|=
literal|1
expr_stmt|;
comment|/* No need for the conversion here, as we know it is the 		     right type.  */
name|vbase_decl_ptr_intermediate
operator|=
operator|(
name|tree
operator|)
name|CLASSTYPE_SEARCH_SLOT
argument_list|(
name|BINFO_TYPE
argument_list|(
name|base_binfo
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|CHECK_convert_pointer_to_single_level
comment|/* This code here introduces a little software fault 		     tolerance It should be that case that the second 		     one always gets the same valid answer that the 		     first one gives, if the first one gives a valid 		     answer.  		     If it doesn't, the second algorithm is at fault 		     and needs to be fixed.  		     The first one is known to be bad and produce 		     error_mark_node when dealing with MI base 		     classes.  It is the only problem supposed to be 		     fixed by the second. */
endif|#
directive|endif
name|tree
name|vdpi1
decl_stmt|,
name|vdpi2
decl_stmt|;
ifdef|#
directive|ifdef
name|CHECK_convert_pointer_to_single_level
name|vdpi1
operator|=
name|convert_pointer_to
argument_list|(
name|BINFO_TYPE
argument_list|(
name|base_binfo
argument_list|)
argument_list|,
name|vbase_decl_ptr_intermediate
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|vdpi2
operator|=
name|convert_pointer_to_single_level
argument_list|(
name|BINFO_TYPE
argument_list|(
name|base_binfo
argument_list|)
argument_list|,
name|vbase_decl_ptr_intermediate
argument_list|)
expr_stmt|;
name|vbase_decl_ptr_intermediate
operator|=
name|vdpi2
expr_stmt|;
ifdef|#
directive|ifdef
name|CHECK_convert_pointer_to_single_level
if|if
condition|(
name|vdpi1
operator|==
name|error_mark_node
operator|&&
name|vdpi2
operator|!=
name|vdpi1
condition|)
block|{
specifier|extern
name|int
name|errorcount
decl_stmt|;
name|errorcount
operator|-=
literal|2
expr_stmt|;
name|warning
argument_list|(
literal|"internal: Don't worry, be happy, I can fix tangs man.  (ignore above error)"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|simple_cst_equal
argument_list|(
name|vdpi1
argument_list|,
name|vdpi2
argument_list|)
operator|!=
literal|1
condition|)
block|{
if|if
condition|(
name|simple_cst_equal
argument_list|(
name|vdpi1
argument_list|,
name|vdpi2
argument_list|)
operator|==
literal|0
condition|)
name|warning
argument_list|(
literal|"internal: convert_pointer_to_single_level: They are not the same, going with old algorithm"
argument_list|)
expr_stmt|;
else|else
name|warning
argument_list|(
literal|"internal: convert_pointer_to_single_level: They might not be the same, going with old algorithm"
argument_list|)
expr_stmt|;
name|vbase_decl_ptr_intermediate
operator|=
name|vdpi1
expr_stmt|;
block|}
endif|#
directive|endif
block|}
name|dfs_walk
argument_list|(
name|base_binfo
argument_list|,
name|fn
argument_list|,
name|qfn
argument_list|)
expr_stmt|;
name|vbase_decl_ptr_intermediate
operator|=
name|saved_vbase_decl_ptr_intermediate
expr_stmt|;
name|saw_first_vbase
operator|=
name|save_saw_first_vbase
expr_stmt|;
block|}
else|else
name|dfs_walk
argument_list|(
name|base_binfo
argument_list|,
name|fn
argument_list|,
name|qfn
argument_list|)
expr_stmt|;
block|}
block|}
name|fn
argument_list|(
name|binfo
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Predicate functions which serve for dfs_walk.  */
end_comment

begin_function
specifier|static
name|int
name|numberedp
parameter_list|(
name|binfo
parameter_list|)
name|tree
name|binfo
decl_stmt|;
block|{
return|return
name|BINFO_CID
argument_list|(
name|binfo
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|unnumberedp
parameter_list|(
name|binfo
parameter_list|)
name|tree
name|binfo
decl_stmt|;
block|{
return|return
name|BINFO_CID
argument_list|(
name|binfo
argument_list|)
operator|==
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|markedp
parameter_list|(
name|binfo
parameter_list|)
name|tree
name|binfo
decl_stmt|;
block|{
return|return
name|BINFO_MARKED
argument_list|(
name|binfo
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bfs_markedp
parameter_list|(
name|binfo
parameter_list|,
name|i
parameter_list|)
name|tree
name|binfo
decl_stmt|;
name|int
name|i
decl_stmt|;
block|{
return|return
name|BINFO_MARKED
argument_list|(
name|BINFO_BASETYPE
argument_list|(
name|binfo
argument_list|,
name|i
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|unmarkedp
parameter_list|(
name|binfo
parameter_list|)
name|tree
name|binfo
decl_stmt|;
block|{
return|return
name|BINFO_MARKED
argument_list|(
name|binfo
argument_list|)
operator|==
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bfs_unmarkedp
parameter_list|(
name|binfo
parameter_list|,
name|i
parameter_list|)
name|tree
name|binfo
decl_stmt|;
name|int
name|i
decl_stmt|;
block|{
return|return
name|BINFO_MARKED
argument_list|(
name|BINFO_BASETYPE
argument_list|(
name|binfo
argument_list|,
name|i
argument_list|)
argument_list|)
operator|==
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|marked_vtable_pathp
parameter_list|(
name|binfo
parameter_list|)
name|tree
name|binfo
decl_stmt|;
block|{
return|return
name|BINFO_VTABLE_PATH_MARKED
argument_list|(
name|binfo
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bfs_marked_vtable_pathp
parameter_list|(
name|binfo
parameter_list|,
name|i
parameter_list|)
name|tree
name|binfo
decl_stmt|;
name|int
name|i
decl_stmt|;
block|{
return|return
name|BINFO_VTABLE_PATH_MARKED
argument_list|(
name|BINFO_BASETYPE
argument_list|(
name|binfo
argument_list|,
name|i
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|unmarked_vtable_pathp
parameter_list|(
name|binfo
parameter_list|)
name|tree
name|binfo
decl_stmt|;
block|{
return|return
name|BINFO_VTABLE_PATH_MARKED
argument_list|(
name|binfo
argument_list|)
operator|==
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bfs_unmarked_vtable_pathp
parameter_list|(
name|binfo
parameter_list|,
name|i
parameter_list|)
name|tree
name|binfo
decl_stmt|;
name|int
name|i
decl_stmt|;
block|{
return|return
name|BINFO_VTABLE_PATH_MARKED
argument_list|(
name|BINFO_BASETYPE
argument_list|(
name|binfo
argument_list|,
name|i
argument_list|)
argument_list|)
operator|==
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|marked_new_vtablep
parameter_list|(
name|binfo
parameter_list|)
name|tree
name|binfo
decl_stmt|;
block|{
return|return
name|BINFO_NEW_VTABLE_MARKED
argument_list|(
name|binfo
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bfs_marked_new_vtablep
parameter_list|(
name|binfo
parameter_list|,
name|i
parameter_list|)
name|tree
name|binfo
decl_stmt|;
name|int
name|i
decl_stmt|;
block|{
return|return
name|BINFO_NEW_VTABLE_MARKED
argument_list|(
name|BINFO_BASETYPE
argument_list|(
name|binfo
argument_list|,
name|i
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|unmarked_new_vtablep
parameter_list|(
name|binfo
parameter_list|)
name|tree
name|binfo
decl_stmt|;
block|{
return|return
name|BINFO_NEW_VTABLE_MARKED
argument_list|(
name|binfo
argument_list|)
operator|==
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bfs_unmarked_new_vtablep
parameter_list|(
name|binfo
parameter_list|,
name|i
parameter_list|)
name|tree
name|binfo
decl_stmt|;
name|int
name|i
decl_stmt|;
block|{
return|return
name|BINFO_NEW_VTABLE_MARKED
argument_list|(
name|BINFO_BASETYPE
argument_list|(
name|binfo
argument_list|,
name|i
argument_list|)
argument_list|)
operator|==
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dfs_search_slot_nonempty_p
parameter_list|(
name|binfo
parameter_list|)
name|tree
name|binfo
decl_stmt|;
block|{
return|return
name|CLASSTYPE_SEARCH_SLOT
argument_list|(
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
argument_list|)
operator|!=
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dfs_debug_unmarkedp
parameter_list|(
name|binfo
parameter_list|)
name|tree
name|binfo
decl_stmt|;
block|{
return|return
name|CLASSTYPE_DEBUG_REQUESTED
argument_list|(
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
argument_list|)
operator|==
literal|0
return|;
block|}
end_function

begin_comment
comment|/* The worker functions for `dfs_walk'.  These do not need to    test anything (vis a vis marking) if they are paired with    a predicate function (above).  */
end_comment

begin_comment
comment|/* Assign each type within the lattice a number which is unique    in the lattice.  The first number assigned is 1.  */
end_comment

begin_function
specifier|static
name|void
name|dfs_number
parameter_list|(
name|binfo
parameter_list|)
name|tree
name|binfo
decl_stmt|;
block|{
name|BINFO_CID
argument_list|(
name|binfo
argument_list|)
operator|=
operator|++
name|cid
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dfs_unnumber
parameter_list|(
name|binfo
parameter_list|)
name|tree
name|binfo
decl_stmt|;
block|{
name|BINFO_CID
argument_list|(
name|binfo
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dfs_mark
parameter_list|(
name|binfo
parameter_list|)
name|tree
name|binfo
decl_stmt|;
block|{
name|SET_BINFO_MARKED
argument_list|(
name|binfo
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dfs_unmark
parameter_list|(
name|binfo
parameter_list|)
name|tree
name|binfo
decl_stmt|;
block|{
name|CLEAR_BINFO_MARKED
argument_list|(
name|binfo
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dfs_mark_vtable_path
parameter_list|(
name|binfo
parameter_list|)
name|tree
name|binfo
decl_stmt|;
block|{
name|SET_BINFO_VTABLE_PATH_MARKED
argument_list|(
name|binfo
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dfs_unmark_vtable_path
parameter_list|(
name|binfo
parameter_list|)
name|tree
name|binfo
decl_stmt|;
block|{
name|CLEAR_BINFO_VTABLE_PATH_MARKED
argument_list|(
name|binfo
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dfs_mark_new_vtable
parameter_list|(
name|binfo
parameter_list|)
name|tree
name|binfo
decl_stmt|;
block|{
name|SET_BINFO_NEW_VTABLE_MARKED
argument_list|(
name|binfo
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dfs_unmark_new_vtable
parameter_list|(
name|binfo
parameter_list|)
name|tree
name|binfo
decl_stmt|;
block|{
name|CLEAR_BINFO_NEW_VTABLE_MARKED
argument_list|(
name|binfo
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dfs_clear_search_slot
parameter_list|(
name|binfo
parameter_list|)
name|tree
name|binfo
decl_stmt|;
block|{
name|CLASSTYPE_SEARCH_SLOT
argument_list|(
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dfs_debug_mark
parameter_list|(
name|binfo
parameter_list|)
name|tree
name|binfo
decl_stmt|;
block|{
name|tree
name|t
init|=
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
decl_stmt|;
comment|/* Use heuristic that if there are virtual functions,      ignore until we see a non-inline virtual function.  */
name|tree
name|methods
init|=
name|CLASSTYPE_METHOD_VEC
argument_list|(
name|t
argument_list|)
decl_stmt|;
name|CLASSTYPE_DEBUG_REQUESTED
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* If interface info is known, the value of (?@@?) is correct.  */
if|if
condition|(
name|methods
operator|==
literal|0
operator|||
operator|!
name|CLASSTYPE_INTERFACE_UNKNOWN
argument_list|(
name|t
argument_list|)
operator|||
operator|(
name|write_virtuals
operator|==
literal|2
operator|&&
name|TYPE_VIRTUAL_P
argument_list|(
name|t
argument_list|)
operator|)
condition|)
return|return;
comment|/* If debug info is requested from this context for this type, supply it.      If debug info is requested from another context for this type,      see if some third context can supply it.  */
if|if
condition|(
name|current_function_decl
operator|==
name|NULL_TREE
operator|||
name|DECL_CLASS_CONTEXT
argument_list|(
name|current_function_decl
argument_list|)
operator|!=
name|t
condition|)
block|{
if|if
condition|(
name|TREE_VEC_ELT
argument_list|(
name|methods
argument_list|,
literal|0
argument_list|)
condition|)
name|methods
operator|=
name|TREE_VEC_ELT
argument_list|(
name|methods
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|methods
operator|=
name|TREE_VEC_ELT
argument_list|(
name|methods
argument_list|,
literal|1
argument_list|)
expr_stmt|;
while|while
condition|(
name|methods
condition|)
block|{
if|if
condition|(
name|DECL_VINDEX
argument_list|(
name|methods
argument_list|)
operator|&&
name|DECL_SAVED_INSNS
argument_list|(
name|methods
argument_list|)
operator|==
literal|0
operator|&&
name|DECL_PENDING_INLINE_INFO
argument_list|(
name|methods
argument_list|)
operator|==
literal|0
operator|&&
name|DECL_ABSTRACT_VIRTUAL_P
argument_list|(
name|methods
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Somebody, somewhere is going to have to define this 		 virtual function.  When they do, they will provide 		 the debugging info.  */
return|return;
block|}
name|methods
operator|=
name|TREE_CHAIN
argument_list|(
name|methods
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* We cannot rely on some alien method to solve our problems,      so we must write out the debug info ourselves.  */
name|DECL_IGNORED_P
argument_list|(
name|TYPE_NAME
argument_list|(
name|t
argument_list|)
argument_list|)
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|TREE_ASM_WRITTEN
argument_list|(
name|TYPE_NAME
argument_list|(
name|t
argument_list|)
argument_list|)
condition|)
name|rest_of_type_compilation
argument_list|(
name|t
argument_list|,
name|global_bindings_p
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  Attach to the type of the virtual base class, the pointer to the     virtual base class, given the global pointer vbase_decl_ptr.  */
end_comment

begin_function
specifier|static
name|void
name|dfs_find_vbases
parameter_list|(
name|binfo
parameter_list|)
name|tree
name|binfo
decl_stmt|;
block|{
name|tree
name|binfos
init|=
name|BINFO_BASETYPES
argument_list|(
name|binfo
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|,
name|n_baselinks
init|=
name|binfos
condition|?
name|TREE_VEC_LENGTH
argument_list|(
name|binfos
argument_list|)
else|:
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
name|n_baselinks
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|tree
name|base_binfo
init|=
name|TREE_VEC_ELT
argument_list|(
name|binfos
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_VIA_VIRTUAL
argument_list|(
name|base_binfo
argument_list|)
operator|&&
name|CLASSTYPE_SEARCH_SLOT
argument_list|(
name|BINFO_TYPE
argument_list|(
name|base_binfo
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
name|tree
name|vbase
init|=
name|BINFO_TYPE
argument_list|(
name|base_binfo
argument_list|)
decl_stmt|;
name|tree
name|binfo
init|=
name|binfo_member
argument_list|(
name|vbase
argument_list|,
name|vbase_types
argument_list|)
decl_stmt|;
name|CLASSTYPE_SEARCH_SLOT
argument_list|(
name|vbase
argument_list|)
operator|=
operator|(
name|char
operator|*
operator|)
name|build
argument_list|(
name|PLUS_EXPR
argument_list|,
name|TYPE_POINTER_TO
argument_list|(
name|vbase
argument_list|)
argument_list|,
name|vbase_decl_ptr
argument_list|,
name|BINFO_OFFSET
argument_list|(
name|binfo
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|SET_BINFO_VTABLE_PATH_MARKED
argument_list|(
name|binfo
argument_list|)
expr_stmt|;
name|SET_BINFO_NEW_VTABLE_MARKED
argument_list|(
name|binfo
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dfs_init_vbase_pointers
parameter_list|(
name|binfo
parameter_list|)
name|tree
name|binfo
decl_stmt|;
block|{
name|tree
name|type
init|=
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
decl_stmt|;
name|tree
name|fields
init|=
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|tree
name|path
decl_stmt|,
name|this_vbase_ptr
decl_stmt|;
name|int
name|distance
decl_stmt|;
name|CLEAR_BINFO_VTABLE_PATH_MARKED
argument_list|(
name|binfo
argument_list|)
expr_stmt|;
comment|/* If there is a dossier, it is the first field, though perhaps from      the base class.  Otherwise, the first fields are virtual base class      pointer fields.  */
if|if
condition|(
name|CLASSTYPE_DOSSIER
argument_list|(
name|type
argument_list|)
operator|&&
name|VFIELD_NAME_P
argument_list|(
name|DECL_NAME
argument_list|(
name|fields
argument_list|)
argument_list|)
condition|)
comment|/* Get past vtable for the object.  */
name|fields
operator|=
name|TREE_CHAIN
argument_list|(
name|fields
argument_list|)
expr_stmt|;
if|if
condition|(
name|fields
operator|==
name|NULL_TREE
operator|||
name|DECL_NAME
argument_list|(
name|fields
argument_list|)
operator|==
name|NULL_TREE
operator|||
operator|!
name|VBASE_NAME_P
argument_list|(
name|DECL_NAME
argument_list|(
name|fields
argument_list|)
argument_list|)
condition|)
return|return;
name|this_vbase_ptr
operator|=
name|vbase_decl_ptr_intermediate
expr_stmt|;
if|if
condition|(
name|TYPE_POINTER_TO
argument_list|(
name|type
argument_list|)
operator|!=
name|TREE_TYPE
argument_list|(
name|this_vbase_ptr
argument_list|)
condition|)
name|my_friendly_abort
argument_list|(
literal|125
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|distance = get_base_distance (type, TREE_TYPE (vbase_decl), 0,&path);   if (distance == -2)     {       error ("inheritance lattice too complex below");     }   while (path)     {       if (TREE_VIA_VIRTUAL (path)) 	break;       distance -= 1;       path = BINFO_INHERITANCE_CHAIN (path);     }    if (distance> 0)     this_vbase_ptr = convert_pointer_to (type, (tree)CLASSTYPE_SEARCH_SLOT (BINFO_TYPE (path)));   else     this_vbase_ptr = convert_pointer_to (type, vbase_decl_ptr);
comment|/* This happens when it is ambiguous. */
block|if (this_vbase_ptr == error_mark_node)     return;
endif|#
directive|endif
while|while
condition|(
name|fields
operator|&&
name|DECL_NAME
argument_list|(
name|fields
argument_list|)
operator|&&
name|VBASE_NAME_P
argument_list|(
name|DECL_NAME
argument_list|(
name|fields
argument_list|)
argument_list|)
condition|)
block|{
name|tree
name|ref
init|=
name|build
argument_list|(
name|COMPONENT_REF
argument_list|,
name|TREE_TYPE
argument_list|(
name|fields
argument_list|)
argument_list|,
name|build_indirect_ref
argument_list|(
name|this_vbase_ptr
argument_list|,
literal|0
argument_list|)
argument_list|,
name|fields
argument_list|)
decl_stmt|;
name|tree
name|init
init|=
operator|(
name|tree
operator|)
name|CLASSTYPE_SEARCH_SLOT
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|fields
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|vbase_init_result
operator|=
name|tree_cons
argument_list|(
name|binfo_member
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|fields
argument_list|)
argument_list|)
argument_list|,
name|vbase_types
argument_list|)
argument_list|,
name|build_modify_expr
argument_list|(
name|ref
argument_list|,
name|NOP_EXPR
argument_list|,
name|init
argument_list|)
argument_list|,
name|vbase_init_result
argument_list|)
expr_stmt|;
name|fields
operator|=
name|TREE_CHAIN
argument_list|(
name|fields
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Sometimes this needs to clear both VTABLE_PATH and NEW_VTABLE.  Other    times, just NEW_VTABLE, but optimizer should make both with equal    efficiency (though it does not currently).  */
end_comment

begin_function
specifier|static
name|void
name|dfs_clear_vbase_slots
parameter_list|(
name|binfo
parameter_list|)
name|tree
name|binfo
decl_stmt|;
block|{
name|tree
name|type
init|=
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
decl_stmt|;
name|CLASSTYPE_SEARCH_SLOT
argument_list|(
name|type
argument_list|)
operator|=
literal|0
expr_stmt|;
name|CLEAR_BINFO_VTABLE_PATH_MARKED
argument_list|(
name|binfo
argument_list|)
expr_stmt|;
name|CLEAR_BINFO_NEW_VTABLE_MARKED
argument_list|(
name|binfo
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|tree
name|init_vbase_pointers
parameter_list|(
name|type
parameter_list|,
name|decl_ptr
parameter_list|)
name|tree
name|type
decl_stmt|;
name|tree
name|decl_ptr
decl_stmt|;
block|{
if|if
condition|(
name|TYPE_USES_VIRTUAL_BASECLASSES
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|int
name|old_flag
init|=
name|flag_this_is_variable
decl_stmt|;
name|tree
name|binfo
init|=
name|TYPE_BINFO
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|flag_this_is_variable
operator|=
operator|-
literal|2
expr_stmt|;
name|vbase_types
operator|=
name|CLASSTYPE_VBASECLASSES
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|vbase_decl_ptr
operator|=
name|decl_ptr
expr_stmt|;
name|vbase_decl
operator|=
name|build_indirect_ref
argument_list|(
name|decl_ptr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|vbase_decl_ptr_intermediate
operator|=
name|vbase_decl_ptr
expr_stmt|;
name|saw_first_vbase
operator|=
literal|0
expr_stmt|;
name|vbase_init_result
operator|=
name|NULL_TREE
expr_stmt|;
name|dfs_walk
argument_list|(
name|binfo
argument_list|,
name|dfs_find_vbases
argument_list|,
name|unmarked_vtable_pathp
argument_list|)
expr_stmt|;
name|dfs_walk
argument_list|(
name|binfo
argument_list|,
name|dfs_init_vbase_pointers
argument_list|,
name|marked_vtable_pathp
argument_list|)
expr_stmt|;
name|dfs_walk
argument_list|(
name|binfo
argument_list|,
name|dfs_clear_vbase_slots
argument_list|,
name|marked_new_vtablep
argument_list|)
expr_stmt|;
name|flag_this_is_variable
operator|=
name|old_flag
expr_stmt|;
return|return
name|vbase_init_result
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Build a COMPOUND_EXPR which when expanded will generate the code    needed to initialize all the virtual function table slots of all    the virtual baseclasses.  FOR_TYPE is the type which determines the    virtual baseclasses to use; TYPE is the type of the object to which    the initialization applies.  TRUE_EXP is the true object we are    initializing, and DECL_PTR is the pointer to the sub-object we    are initializing.     CTOR_P is non-zero if the caller of this function is a top-level    constructor.  It is zero when called from a destructor.  When    non-zero, we can use computed offsets to store the vtables.  When    zero, we must store new vtables through virtual baseclass pointers.  */
end_comment

begin_function
name|tree
name|build_vbase_vtables_init
parameter_list|(
name|main_binfo
parameter_list|,
name|binfo
parameter_list|,
name|true_exp
parameter_list|,
name|decl_ptr
parameter_list|,
name|ctor_p
parameter_list|)
name|tree
name|main_binfo
decl_stmt|,
name|binfo
decl_stmt|;
name|tree
name|true_exp
decl_stmt|,
name|decl_ptr
decl_stmt|;
name|int
name|ctor_p
decl_stmt|;
block|{
name|tree
name|for_type
init|=
name|BINFO_TYPE
argument_list|(
name|main_binfo
argument_list|)
decl_stmt|;
name|tree
name|type
init|=
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
decl_stmt|;
if|if
condition|(
name|TYPE_USES_VIRTUAL_BASECLASSES
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|int
name|old_flag
init|=
name|flag_this_is_variable
decl_stmt|;
name|tree
name|vtable_init_result
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|vbases
init|=
name|CLASSTYPE_VBASECLASSES
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|vbase_types
operator|=
name|CLASSTYPE_VBASECLASSES
argument_list|(
name|for_type
argument_list|)
expr_stmt|;
name|vbase_decl_ptr
operator|=
name|true_exp
condition|?
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|true_exp
argument_list|,
literal|0
argument_list|)
else|:
name|decl_ptr
expr_stmt|;
name|vbase_decl
operator|=
name|true_exp
condition|?
name|true_exp
else|:
name|build_indirect_ref
argument_list|(
name|decl_ptr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctor_p
condition|)
block|{
comment|/* This is an object of type IN_TYPE,  */
name|flag_this_is_variable
operator|=
operator|-
literal|2
expr_stmt|;
name|dfs_walk
argument_list|(
name|main_binfo
argument_list|,
name|dfs_find_vbases
argument_list|,
name|unmarked_new_vtablep
argument_list|)
expr_stmt|;
block|}
comment|/* Initialized with vtables of type TYPE.  */
while|while
condition|(
name|vbases
condition|)
block|{
comment|/* This time through, not every class's vtable 	     is going to be initialized.  That is, we only initialize 	     the "last" vtable pointer.  */
if|if
condition|(
name|CLASSTYPE_VSIZE
argument_list|(
name|BINFO_TYPE
argument_list|(
name|vbases
argument_list|)
argument_list|)
condition|)
block|{
name|tree
name|addr
decl_stmt|;
name|tree
name|vtbl
init|=
name|BINFO_VTABLE
argument_list|(
name|vbases
argument_list|)
decl_stmt|;
name|tree
name|init
init|=
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|vtbl
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|assemble_external
argument_list|(
name|vtbl
argument_list|)
expr_stmt|;
name|TREE_USED
argument_list|(
name|vtbl
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|ctor_p
operator|==
literal|0
condition|)
name|addr
operator|=
name|convert_pointer_to
argument_list|(
name|vbases
argument_list|,
name|vbase_decl_ptr
argument_list|)
expr_stmt|;
else|else
name|addr
operator|=
operator|(
name|tree
operator|)
name|CLASSTYPE_SEARCH_SLOT
argument_list|(
name|BINFO_TYPE
argument_list|(
name|vbases
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|addr
condition|)
block|{
name|tree
name|ref
init|=
name|build_vfield_ref
argument_list|(
name|build_indirect_ref
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
argument_list|,
name|BINFO_TYPE
argument_list|(
name|vbases
argument_list|)
argument_list|)
decl_stmt|;
name|init
operator|=
name|convert_force
argument_list|(
name|TREE_TYPE
argument_list|(
name|ref
argument_list|)
argument_list|,
name|init
argument_list|)
expr_stmt|;
name|vtable_init_result
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|build_modify_expr
argument_list|(
name|ref
argument_list|,
name|NOP_EXPR
argument_list|,
name|init
argument_list|)
argument_list|,
name|vtable_init_result
argument_list|)
expr_stmt|;
block|}
block|}
name|vbases
operator|=
name|TREE_CHAIN
argument_list|(
name|vbases
argument_list|)
expr_stmt|;
block|}
name|dfs_walk
argument_list|(
name|binfo
argument_list|,
name|dfs_clear_vbase_slots
argument_list|,
name|marked_new_vtablep
argument_list|)
expr_stmt|;
name|flag_this_is_variable
operator|=
name|old_flag
expr_stmt|;
if|if
condition|(
name|vtable_init_result
condition|)
return|return
name|build_compound_expr
argument_list|(
name|vtable_init_result
argument_list|)
return|;
block|}
return|return
name|error_mark_node
return|;
block|}
end_function

begin_function
name|void
name|clear_search_slots
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
name|dfs_walk
argument_list|(
name|TYPE_BINFO
argument_list|(
name|type
argument_list|)
argument_list|,
name|dfs_clear_search_slot
argument_list|,
name|dfs_search_slot_nonempty_p
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dfs_get_vbase_types
parameter_list|(
name|binfo
parameter_list|)
name|tree
name|binfo
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|tree
name|binfos
init|=
name|BINFO_BASETYPES
argument_list|(
name|binfo
argument_list|)
decl_stmt|;
name|tree
name|type
init|=
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
decl_stmt|;
name|tree
name|these_vbase_types
init|=
name|CLASSTYPE_VBASECLASSES
argument_list|(
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|these_vbase_types
condition|)
block|{
while|while
condition|(
name|these_vbase_types
condition|)
block|{
name|tree
name|this_type
init|=
name|BINFO_TYPE
argument_list|(
name|these_vbase_types
argument_list|)
decl_stmt|;
comment|/* We really need to start from a fresh copy of this 	     virtual basetype!  CLASSTYPE_MARKED2 is the shortcut 	     for BINFO_VBASE_MARKED.  */
if|if
condition|(
operator|!
name|CLASSTYPE_MARKED2
argument_list|(
name|this_type
argument_list|)
condition|)
block|{
name|vbase_types
operator|=
name|make_binfo
argument_list|(
name|integer_zero_node
argument_list|,
name|this_type
argument_list|,
name|TYPE_BINFO_VTABLE
argument_list|(
name|this_type
argument_list|)
argument_list|,
name|TYPE_BINFO_VIRTUALS
argument_list|(
name|this_type
argument_list|)
argument_list|,
name|vbase_types
argument_list|)
expr_stmt|;
name|TREE_VIA_VIRTUAL
argument_list|(
name|vbase_types
argument_list|)
operator|=
literal|1
expr_stmt|;
name|SET_CLASSTYPE_MARKED2
argument_list|(
name|this_type
argument_list|)
expr_stmt|;
block|}
name|these_vbase_types
operator|=
name|TREE_CHAIN
argument_list|(
name|these_vbase_types
argument_list|)
expr_stmt|;
block|}
block|}
else|else
for|for
control|(
name|i
operator|=
name|binfos
condition|?
name|TREE_VEC_LENGTH
argument_list|(
name|binfos
argument_list|)
operator|-
literal|1
else|:
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|tree
name|base_binfo
init|=
name|TREE_VEC_ELT
argument_list|(
name|binfos
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_VIA_VIRTUAL
argument_list|(
name|base_binfo
argument_list|)
operator|&&
operator|!
name|BINFO_VBASE_MARKED
argument_list|(
name|base_binfo
argument_list|)
condition|)
block|{
name|vbase_types
operator|=
name|make_binfo
argument_list|(
name|integer_zero_node
argument_list|,
name|BINFO_TYPE
argument_list|(
name|base_binfo
argument_list|)
argument_list|,
name|BINFO_VTABLE
argument_list|(
name|base_binfo
argument_list|)
argument_list|,
name|BINFO_VIRTUALS
argument_list|(
name|base_binfo
argument_list|)
argument_list|,
name|vbase_types
argument_list|)
expr_stmt|;
name|TREE_VIA_VIRTUAL
argument_list|(
name|vbase_types
argument_list|)
operator|=
literal|1
expr_stmt|;
name|SET_BINFO_VBASE_MARKED
argument_list|(
name|base_binfo
argument_list|)
expr_stmt|;
block|}
block|}
name|SET_BINFO_MARKED
argument_list|(
name|binfo
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Some virtual baseclasses might be virtual baseclasses for    other virtual baseclasses.  We sort the virtual baseclasses    topologically: in the list returned, the first virtual base    classes have no virtual baseclasses themselves, and any entry    on the list has no dependency on virtual base classes later in the    list.  */
end_comment

begin_function
name|tree
name|get_vbase_types
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
name|tree
name|ordered_vbase_types
init|=
name|NULL_TREE
decl_stmt|,
name|prev
decl_stmt|,
name|next
decl_stmt|;
name|tree
name|vbases
decl_stmt|;
name|vbase_types
operator|=
name|NULL_TREE
expr_stmt|;
name|dfs_walk
argument_list|(
name|TYPE_BINFO
argument_list|(
name|type
argument_list|)
argument_list|,
name|dfs_get_vbase_types
argument_list|,
name|unmarkedp
argument_list|)
expr_stmt|;
name|dfs_walk
argument_list|(
name|TYPE_BINFO
argument_list|(
name|type
argument_list|)
argument_list|,
name|dfs_unmark
argument_list|,
name|markedp
argument_list|)
expr_stmt|;
while|while
condition|(
name|vbase_types
condition|)
block|{
comment|/* Now sort these types.  This is essentially a bubble merge.  */
comment|/* Farm out virtual baseclasses which have no marked ancestors.  */
for|for
control|(
name|vbases
operator|=
name|vbase_types
operator|,
name|prev
operator|=
name|NULL_TREE
init|;
name|vbases
condition|;
name|vbases
operator|=
name|next
control|)
block|{
name|next
operator|=
name|TREE_CHAIN
argument_list|(
name|vbases
argument_list|)
expr_stmt|;
comment|/* If VBASES does not have any vbases itself, or it's 	     topologically safe, it goes into the sorted list.  */
if|if
condition|(
operator|!
name|CLASSTYPE_VBASECLASSES
argument_list|(
name|BINFO_TYPE
argument_list|(
name|vbases
argument_list|)
argument_list|)
operator|||
name|BINFO_VBASE_MARKED
argument_list|(
name|vbases
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|prev
condition|)
name|TREE_CHAIN
argument_list|(
name|prev
argument_list|)
operator|=
name|TREE_CHAIN
argument_list|(
name|vbases
argument_list|)
expr_stmt|;
else|else
name|vbase_types
operator|=
name|TREE_CHAIN
argument_list|(
name|vbases
argument_list|)
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|vbases
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
name|ordered_vbase_types
operator|=
name|chainon
argument_list|(
name|ordered_vbase_types
argument_list|,
name|vbases
argument_list|)
expr_stmt|;
name|CLEAR_BINFO_VBASE_MARKED
argument_list|(
name|vbases
argument_list|)
expr_stmt|;
block|}
else|else
name|prev
operator|=
name|vbases
expr_stmt|;
block|}
comment|/* Now unmark types all of whose ancestors are now on the 	 `ordered_vbase_types' list.  */
for|for
control|(
name|vbases
operator|=
name|vbase_types
init|;
name|vbases
condition|;
name|vbases
operator|=
name|TREE_CHAIN
argument_list|(
name|vbases
argument_list|)
control|)
block|{
comment|/* If all our virtual baseclasses are unmarked, ok.  */
name|tree
name|t
init|=
name|CLASSTYPE_VBASECLASSES
argument_list|(
name|BINFO_TYPE
argument_list|(
name|vbases
argument_list|)
argument_list|)
decl_stmt|;
while|while
condition|(
name|t
operator|&&
operator|(
name|BINFO_VBASE_MARKED
argument_list|(
name|t
argument_list|)
operator|==
literal|0
operator|||
operator|!
name|CLASSTYPE_VBASECLASSES
argument_list|(
name|BINFO_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
operator|)
condition|)
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|==
name|NULL_TREE
condition|)
name|CLEAR_BINFO_VBASE_MARKED
argument_list|(
name|vbases
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|ordered_vbase_types
return|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|void
name|dfs_record_inheritance
parameter_list|(
name|binfo
parameter_list|)
name|tree
name|binfo
decl_stmt|;
block|{
name|tree
name|binfos
init|=
name|BINFO_BASETYPES
argument_list|(
name|binfo
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|,
name|n_baselinks
init|=
name|binfos
condition|?
name|TREE_VEC_LENGTH
argument_list|(
name|binfos
argument_list|)
else|:
literal|0
decl_stmt|;
name|mi_boolean
modifier|*
name|derived_row
init|=
name|BINFO_DERIVES_FROM_STAR
argument_list|(
name|binfo
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|=
name|n_baselinks
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|int
name|j
decl_stmt|;
name|tree
name|base_binfo
init|=
name|TREE_VEC_ELT
argument_list|(
name|binfos
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|tree
name|baseclass
init|=
name|BINFO_TYPE
argument_list|(
name|base_binfo
argument_list|)
decl_stmt|;
name|mi_boolean
modifier|*
name|base_row
init|=
name|BINFO_DERIVES_FROM_STAR
argument_list|(
name|base_binfo
argument_list|)
decl_stmt|;
comment|/* Don't search if there's nothing there!  MI_SIZE can be 	 zero as a result of parse errors.  */
if|if
condition|(
name|TYPE_BINFO_BASETYPES
argument_list|(
name|baseclass
argument_list|)
operator|&&
name|mi_size
operator|>
literal|0
condition|)
for|for
control|(
name|j
operator|=
name|mi_size
operator|*
operator|(
name|CLASSTYPE_CID
argument_list|(
name|baseclass
argument_list|)
operator|-
literal|1
operator|)
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|-=
name|mi_size
control|)
name|derived_row
index|[
name|j
index|]
operator||=
name|base_row
index|[
name|j
index|]
expr_stmt|;
name|TYPE_DERIVES_FROM
argument_list|(
name|baseclass
argument_list|,
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
name|SET_BINFO_MARKED
argument_list|(
name|binfo
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Given a _CLASSTYPE node in a multiple inheritance lattice,    convert the lattice into a simple relation such that,    given to CIDs, C1 and C2, one can determine if C1<= C2    or C2<= C1 or C1<> C2.     Once constructed, we walk the lattice depth fisrt,    applying various functions to elements as they are encountered.     We use xmalloc here, in case we want to randomly free these tables.  */
end_comment

begin_define
define|#
directive|define
name|SAVE_MI_MATRIX
end_define

begin_function
name|void
name|build_mi_matrix
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
name|tree
name|binfo
init|=
name|TYPE_BINFO
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|cid
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|SAVE_MI_MATRIX
if|if
condition|(
name|CLASSTYPE_MI_MATRIX
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|mi_size
operator|=
name|CLASSTYPE_N_SUPERCLASSES
argument_list|(
name|type
argument_list|)
operator|+
name|CLASSTYPE_N_VBASECLASSES
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|mi_matrix
operator|=
name|CLASSTYPE_MI_MATRIX
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|mi_type
operator|=
name|type
expr_stmt|;
name|dfs_walk
argument_list|(
name|binfo
argument_list|,
name|dfs_number
argument_list|,
name|unnumberedp
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
name|mi_size
operator|=
name|CLASSTYPE_N_SUPERCLASSES
argument_list|(
name|type
argument_list|)
operator|+
name|CLASSTYPE_N_VBASECLASSES
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|mi_matrix
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
operator|(
name|mi_size
operator|+
literal|1
operator|)
operator|*
operator|(
name|mi_size
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
name|mi_type
operator|=
name|type
expr_stmt|;
name|bzero
argument_list|(
name|mi_matrix
argument_list|,
name|mi_size
operator|*
name|mi_size
argument_list|)
expr_stmt|;
name|dfs_walk
argument_list|(
name|binfo
argument_list|,
name|dfs_number
argument_list|,
name|unnumberedp
argument_list|)
expr_stmt|;
name|dfs_walk
argument_list|(
name|binfo
argument_list|,
name|dfs_record_inheritance
argument_list|,
name|unmarkedp
argument_list|)
expr_stmt|;
name|dfs_walk
argument_list|(
name|binfo
argument_list|,
name|dfs_unmark
argument_list|,
name|markedp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|free_mi_matrix
parameter_list|()
block|{
name|dfs_walk
argument_list|(
name|TYPE_BINFO
argument_list|(
name|mi_type
argument_list|)
argument_list|,
name|dfs_unnumber
argument_list|,
name|numberedp
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SAVE_MI_MATRIX
name|CLASSTYPE_MI_MATRIX
argument_list|(
name|mi_type
argument_list|)
operator|=
name|mi_matrix
expr_stmt|;
else|#
directive|else
name|free
argument_list|(
name|mi_matrix
argument_list|)
expr_stmt|;
name|mi_size
operator|=
literal|0
expr_stmt|;
name|cid
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Local variables for detecting ambiguities of virtual functions    when two or more classes are joined at a multiple inheritance    seam.  */
end_comment

begin_typedef
typedef|typedef
name|tree
name|mi_ventry
index|[
literal|3
index|]
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|mi_ventry
modifier|*
name|mi_vmatrix
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
modifier|*
name|mi_vmax
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|mi_vrows
decl_stmt|,
name|mi_vcols
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|MI_VMATRIX
parameter_list|(
name|ROW
parameter_list|,
name|COL
parameter_list|)
value|((mi_vmatrix + (ROW)*mi_vcols)[COL])
end_define

begin_comment
comment|/* Build a table of virtual functions for a multiple-inheritance    structure.  Here, there are N base classes, and at most    M entries per class.     This function does nothing if N is 0 or 1.  */
end_comment

begin_function
name|void
name|build_mi_virtuals
parameter_list|(
name|rows
parameter_list|,
name|cols
parameter_list|)
name|int
name|rows
decl_stmt|,
name|cols
decl_stmt|;
block|{
if|if
condition|(
name|rows
operator|<
literal|2
operator|||
name|cols
operator|==
literal|0
condition|)
return|return;
name|mi_vrows
operator|=
name|rows
expr_stmt|;
name|mi_vcols
operator|=
name|cols
expr_stmt|;
name|mi_vmatrix
operator|=
operator|(
name|mi_ventry
operator|*
operator|)
name|xmalloc
argument_list|(
operator|(
name|rows
operator|+
literal|1
operator|)
operator|*
name|cols
operator|*
sizeof|sizeof
argument_list|(
name|mi_ventry
argument_list|)
argument_list|)
expr_stmt|;
name|mi_vmax
operator|=
operator|(
name|int
operator|*
operator|)
name|xmalloc
argument_list|(
operator|(
name|rows
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|mi_vmax
argument_list|,
name|rows
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Row indices start at 1, so adjust this.  */
name|mi_vmatrix
operator|-=
name|cols
expr_stmt|;
name|mi_vmax
operator|-=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Comparison function for ordering virtual function table entries.  */
end_comment

begin_function
specifier|static
name|int
name|rank_mi_virtuals
parameter_list|(
name|v1
parameter_list|,
name|v2
parameter_list|)
name|mi_ventry
modifier|*
name|v1
decl_stmt|,
decl|*
name|v2
decl_stmt|;
end_function

begin_block
block|{
name|tree
name|p1
decl_stmt|,
name|p2
decl_stmt|;
name|int
name|i
decl_stmt|;
name|i
operator|=
operator|(
call|(
name|long
call|)
argument_list|(
name|DECL_NAME
argument_list|(
operator|(
operator|*
name|v1
operator|)
index|[
literal|0
index|]
argument_list|)
argument_list|)
operator|-
call|(
name|long
call|)
argument_list|(
name|DECL_NAME
argument_list|(
operator|(
operator|*
name|v2
operator|)
index|[
literal|0
index|]
argument_list|)
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|i
condition|)
return|return
name|i
return|;
name|p1
operator|=
operator|(
operator|*
name|v1
operator|)
index|[
literal|1
index|]
expr_stmt|;
name|p2
operator|=
operator|(
operator|*
name|v2
operator|)
index|[
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|p1
operator|==
name|p2
condition|)
return|return
literal|0
return|;
while|while
condition|(
name|p1
operator|&&
name|p2
condition|)
block|{
name|i
operator|=
operator|(
call|(
name|long
call|)
argument_list|(
name|TREE_VALUE
argument_list|(
name|p1
argument_list|)
argument_list|)
operator|-
call|(
name|long
call|)
argument_list|(
name|TREE_VALUE
argument_list|(
name|p2
argument_list|)
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|i
condition|)
return|return
name|i
return|;
if|if
condition|(
name|TREE_CHAIN
argument_list|(
name|p1
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|TREE_CHAIN
argument_list|(
name|p2
argument_list|)
condition|)
return|return
literal|1
return|;
name|p1
operator|=
name|TREE_CHAIN
argument_list|(
name|p1
argument_list|)
expr_stmt|;
name|p2
operator|=
name|TREE_CHAIN
argument_list|(
name|p2
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CHAIN
argument_list|(
name|p2
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
else|else
block|{
comment|/* When matches of argument lists occur, pick lowest 	     address to keep searching time to a minimum on 	     later passes--like hashing, only different. 	     *MUST BE STABLE*.  */
if|if
condition|(
call|(
name|long
call|)
argument_list|(
operator|(
operator|*
name|v2
operator|)
index|[
literal|1
index|]
argument_list|)
operator|<
call|(
name|long
call|)
argument_list|(
operator|(
operator|*
name|v1
operator|)
index|[
literal|1
index|]
argument_list|)
condition|)
operator|(
operator|*
name|v1
operator|)
index|[
literal|1
index|]
operator|=
operator|(
operator|*
name|v2
operator|)
index|[
literal|1
index|]
expr_stmt|;
else|else
operator|(
operator|*
name|v2
operator|)
index|[
literal|1
index|]
operator|=
operator|(
operator|*
name|v1
operator|)
index|[
literal|1
index|]
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_block

begin_comment
comment|/* Install the virtuals functions got from the initializer VIRTUALS to    the table at index ROW.  */
end_comment

begin_function
name|void
name|add_mi_virtuals
parameter_list|(
name|row
parameter_list|,
name|virtuals
parameter_list|)
name|int
name|row
decl_stmt|;
name|tree
name|virtuals
decl_stmt|;
block|{
name|int
name|col
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|mi_vmatrix
operator|==
literal|0
condition|)
return|return;
while|while
condition|(
name|virtuals
condition|)
block|{
name|tree
name|decl
init|=
name|TREE_OPERAND
argument_list|(
name|FNADDR_FROM_VTABLE_ENTRY
argument_list|(
name|TREE_VALUE
argument_list|(
name|virtuals
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|MI_VMATRIX
argument_list|(
name|row
argument_list|,
name|col
argument_list|)
index|[
literal|0
index|]
operator|=
name|decl
expr_stmt|;
name|MI_VMATRIX
argument_list|(
name|row
argument_list|,
name|col
argument_list|)
index|[
literal|1
index|]
operator|=
name|FUNCTION_ARG_CHAIN
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|MI_VMATRIX
argument_list|(
name|row
argument_list|,
name|col
argument_list|)
index|[
literal|2
index|]
operator|=
name|TREE_VALUE
argument_list|(
name|virtuals
argument_list|)
expr_stmt|;
name|virtuals
operator|=
name|TREE_CHAIN
argument_list|(
name|virtuals
argument_list|)
expr_stmt|;
name|col
operator|+=
literal|1
expr_stmt|;
block|}
name|mi_vmax
index|[
name|row
index|]
operator|=
name|col
expr_stmt|;
name|qsort
argument_list|(
name|mi_vmatrix
operator|+
name|row
operator|*
name|mi_vcols
argument_list|,
name|col
argument_list|,
sizeof|sizeof
argument_list|(
name|mi_ventry
argument_list|)
argument_list|,
name|rank_mi_virtuals
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* If joining two types results in an ambiguity in the virtual    function table, report such here.  */
end_comment

begin_function
name|void
name|report_ambiguous_mi_virtuals
parameter_list|(
name|rows
parameter_list|,
name|type
parameter_list|)
name|int
name|rows
decl_stmt|;
name|tree
name|type
decl_stmt|;
block|{
name|int
modifier|*
name|mi_vmin
decl_stmt|;
name|int
name|row1
decl_stmt|,
name|col1
decl_stmt|,
name|row
decl_stmt|,
name|col
decl_stmt|;
if|if
condition|(
name|mi_vmatrix
operator|==
literal|0
condition|)
return|return;
comment|/* Now virtuals are all sorted, so we merge to find ambiguous cases.  */
name|mi_vmin
operator|=
operator|(
name|int
operator|*
operator|)
name|alloca
argument_list|(
operator|(
name|rows
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|mi_vmin
argument_list|,
name|rows
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
comment|/* adjust.  */
name|mi_vmin
operator|-=
literal|1
expr_stmt|;
comment|/* For each base class with virtual functions (and this includes views      of the virtual baseclasses from different base classes), see that      each virtual function in that base class has a unique meet.       When the column loop is finished, THIS_DECL is in fact the meet.      If that value does not appear in the virtual function table for      the row, install it.  This happens when that virtual function comes      from a virtual baseclass, or a non-leftmost baseclass.  */
for|for
control|(
name|row1
operator|=
literal|1
init|;
name|row1
operator|<
name|rows
condition|;
name|row1
operator|++
control|)
block|{
name|tree
name|this_decl
init|=
literal|0
decl_stmt|;
for|for
control|(
name|col1
operator|=
name|mi_vmax
index|[
name|row1
index|]
operator|-
literal|1
init|;
name|col1
operator|>=
name|mi_vmin
index|[
name|row1
index|]
condition|;
name|col1
operator|--
control|)
block|{
name|tree
name|these_args
init|=
name|MI_VMATRIX
argument_list|(
name|row1
argument_list|,
name|col1
argument_list|)
index|[
literal|1
index|]
decl_stmt|;
name|tree
name|this_context
decl_stmt|;
name|this_decl
operator|=
name|MI_VMATRIX
argument_list|(
name|row1
argument_list|,
name|col1
argument_list|)
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|this_decl
operator|==
literal|0
condition|)
continue|continue;
name|this_context
operator|=
name|TYPE_BINFO
argument_list|(
name|DECL_CLASS_CONTEXT
argument_list|(
name|this_decl
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|this_context
operator|!=
name|TYPE_BINFO
argument_list|(
name|type
argument_list|)
condition|)
name|this_context
operator|=
name|get_binfo
argument_list|(
name|this_context
argument_list|,
name|type
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|row
operator|=
name|row1
operator|+
literal|1
init|;
name|row
operator|<=
name|rows
condition|;
name|row
operator|++
control|)
for|for
control|(
name|col
operator|=
name|mi_vmax
index|[
name|row
index|]
operator|-
literal|1
init|;
name|col
operator|>=
name|mi_vmin
index|[
name|row
index|]
condition|;
name|col
operator|--
control|)
block|{
name|mi_ventry
name|this_entry
decl_stmt|;
if|if
condition|(
name|MI_VMATRIX
argument_list|(
name|row
argument_list|,
name|col
argument_list|)
index|[
literal|0
index|]
operator|==
literal|0
condition|)
continue|continue;
name|this_entry
index|[
literal|0
index|]
operator|=
name|this_decl
expr_stmt|;
name|this_entry
index|[
literal|1
index|]
operator|=
name|these_args
expr_stmt|;
name|this_entry
index|[
literal|2
index|]
operator|=
name|MI_VMATRIX
argument_list|(
name|row1
argument_list|,
name|col1
argument_list|)
index|[
literal|2
index|]
expr_stmt|;
if|if
condition|(
name|rank_mi_virtuals
argument_list|(
name|this_entry
argument_list|,
name|MI_VMATRIX
argument_list|(
name|row
argument_list|,
name|col
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* They are equal.  There are four possibilities:  		       (1) Derived class is defining this virtual function. 		       (2) Two paths to the same virtual function in the 		       same base class. 		       (3) A path to a virtual function declared in one base 		       class, and another path to a virtual function in a 		       base class of the base class. 		       (4) Two paths to the same virtual function in different 		       base classes.  		       The first three cases are ok (non-ambiguous).  */
name|tree
name|that_context
decl_stmt|,
name|tmp
decl_stmt|;
name|int
name|this_before_that
decl_stmt|;
if|if
condition|(
name|type
operator|==
name|BINFO_TYPE
argument_list|(
name|this_context
argument_list|)
condition|)
comment|/* case 1.  */
goto|goto
name|ok
goto|;
name|that_context
operator|=
name|get_binfo
argument_list|(
name|DECL_CLASS_CONTEXT
argument_list|(
name|MI_VMATRIX
argument_list|(
name|row
argument_list|,
name|col
argument_list|)
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|type
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|that_context
operator|==
name|this_context
condition|)
comment|/* case 2.  */
goto|goto
name|ok
goto|;
if|if
condition|(
name|that_context
operator|!=
name|NULL_TREE
condition|)
block|{
name|tmp
operator|=
name|get_binfo
argument_list|(
name|that_context
argument_list|,
name|this_context
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|this_before_that
operator|=
operator|(
name|that_context
operator|!=
name|tmp
operator|)
expr_stmt|;
if|if
condition|(
name|this_before_that
operator|==
literal|0
condition|)
comment|/* case 3a.  */
goto|goto
name|ok
goto|;
name|tmp
operator|=
name|get_binfo
argument_list|(
name|this_context
argument_list|,
name|that_context
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|this_before_that
operator|=
operator|(
name|this_context
operator|==
name|tmp
operator|)
expr_stmt|;
if|if
condition|(
name|this_before_that
operator|!=
literal|0
condition|)
comment|/* case 3b.  */
goto|goto
name|ok
goto|;
comment|/* case 4.  */
name|error_with_decl
argument_list|(
name|MI_VMATRIX
argument_list|(
name|row
argument_list|,
name|col
argument_list|)
index|[
literal|0
index|]
argument_list|,
literal|"ambiguous virtual function `%s'"
argument_list|)
expr_stmt|;
name|error_with_decl
argument_list|(
name|this_decl
argument_list|,
literal|"ambiguating function `%s' (joined by type `%s')"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|current_class_name
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|ok
label|:
name|MI_VMATRIX
argument_list|(
name|row
argument_list|,
name|col
argument_list|)
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
comment|/* Let zeros propagate.  */
if|if
condition|(
name|col
operator|==
name|mi_vmax
index|[
name|row
index|]
operator|-
literal|1
condition|)
block|{
name|int
name|i
init|=
name|col
decl_stmt|;
while|while
condition|(
name|i
operator|>=
name|mi_vmin
index|[
name|row
index|]
operator|&&
name|MI_VMATRIX
argument_list|(
name|row
argument_list|,
name|i
argument_list|)
index|[
literal|0
index|]
operator|==
literal|0
condition|)
name|i
operator|--
expr_stmt|;
name|mi_vmax
index|[
name|row
index|]
operator|=
name|i
operator|+
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|col
operator|==
name|mi_vmin
index|[
name|row
index|]
condition|)
block|{
name|int
name|i
init|=
name|col
decl_stmt|;
while|while
condition|(
name|i
operator|<
name|mi_vmax
index|[
name|row
index|]
operator|&&
name|MI_VMATRIX
argument_list|(
name|row
argument_list|,
name|i
argument_list|)
index|[
literal|0
index|]
operator|==
literal|0
condition|)
name|i
operator|++
expr_stmt|;
name|mi_vmin
index|[
name|row
index|]
operator|=
name|i
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
name|free
argument_list|(
name|mi_vmatrix
operator|+
name|mi_vcols
argument_list|)
expr_stmt|;
name|mi_vmatrix
operator|=
literal|0
expr_stmt|;
name|free
argument_list|(
name|mi_vmax
operator|+
literal|1
argument_list|)
expr_stmt|;
name|mi_vmax
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* If we want debug info for a type TYPE, make sure all its base types    are also marked as being potentially interesting.  This avoids    the problem of not writing any debug info for intermediate basetypes    that have abstract virtual functions.  */
end_comment

begin_function
name|void
name|note_debug_info_needed
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
name|dfs_walk
argument_list|(
name|TYPE_BINFO
argument_list|(
name|type
argument_list|)
argument_list|,
name|dfs_debug_mark
argument_list|,
name|dfs_debug_unmarkedp
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Subroutines of push_class_decls ().  */
end_comment

begin_comment
comment|/* Add the instance variables which this class contributed to the    current class binding contour.  When a redefinition occurs,    if the redefinition is strictly within a single inheritance path,    we just overwrite (in the case of a data field) or    cons (in the case of a member function) the old declaration with    the new.  If the fields are not within a single inheritance path,    we must cons them in either case.  */
end_comment

begin_function
specifier|static
name|void
name|dfs_pushdecls
parameter_list|(
name|binfo
parameter_list|)
name|tree
name|binfo
decl_stmt|;
block|{
name|tree
name|type
init|=
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
decl_stmt|;
name|tree
name|fields
decl_stmt|,
modifier|*
name|methods
decl_stmt|,
modifier|*
name|end
decl_stmt|;
name|tree
name|method_vec
decl_stmt|;
for|for
control|(
name|fields
operator|=
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
init|;
name|fields
condition|;
name|fields
operator|=
name|TREE_CHAIN
argument_list|(
name|fields
argument_list|)
control|)
block|{
comment|/* Unmark so that if we are in a constructor, and then find that 	 this field was initialized by a base initializer, 	 we can emit an error message.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|fields
argument_list|)
operator|==
name|FIELD_DECL
condition|)
name|TREE_USED
argument_list|(
name|fields
argument_list|)
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|DECL_NAME
argument_list|(
name|fields
argument_list|)
operator|==
name|NULL_TREE
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|fields
argument_list|)
argument_list|)
operator|==
name|UNION_TYPE
condition|)
block|{
name|dfs_pushdecls
argument_list|(
name|TYPE_BINFO
argument_list|(
name|TREE_TYPE
argument_list|(
name|fields
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|fields
argument_list|)
operator|!=
name|TYPE_DECL
condition|)
block|{
name|DECL_PUBLIC
argument_list|(
name|fields
argument_list|)
operator|=
literal|0
expr_stmt|;
name|DECL_PROTECTED
argument_list|(
name|fields
argument_list|)
operator|=
literal|0
expr_stmt|;
name|DECL_PRIVATE
argument_list|(
name|fields
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|DECL_NAME
argument_list|(
name|fields
argument_list|)
condition|)
block|{
name|tree
name|value
init|=
name|IDENTIFIER_CLASS_VALUE
argument_list|(
name|DECL_NAME
argument_list|(
name|fields
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|value
condition|)
block|{
name|tree
name|context
decl_stmt|;
comment|/* Possible ambiguity.  If its defining type(s) 		 is (are all) derived from us, no problem.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|!=
name|TREE_LIST
condition|)
block|{
name|context
operator|=
name|DECL_CLASS_CONTEXT
argument_list|(
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|context
operator|&&
operator|(
name|context
operator|==
name|type
operator|||
name|TYPE_DERIVES_FROM
argument_list|(
name|context
argument_list|,
name|type
argument_list|)
operator|)
condition|)
name|value
operator|=
name|fields
expr_stmt|;
else|else
name|value
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|fields
argument_list|,
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|value
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* All children may derive from us, in which case 		     there is no problem.  Otherwise, we have to 		     keep lists around of what the ambiguities might be.  */
name|tree
name|values
decl_stmt|;
name|int
name|problem
init|=
literal|0
decl_stmt|;
for|for
control|(
name|values
operator|=
name|value
init|;
name|values
condition|;
name|values
operator|=
name|TREE_CHAIN
argument_list|(
name|values
argument_list|)
control|)
block|{
name|tree
name|sub_values
init|=
name|TREE_VALUE
argument_list|(
name|values
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|sub_values
argument_list|)
operator|==
name|TREE_LIST
condition|)
block|{
for|for
control|(
init|;
name|sub_values
condition|;
name|sub_values
operator|=
name|TREE_CHAIN
argument_list|(
name|sub_values
argument_list|)
control|)
block|{
name|context
operator|=
name|DECL_CLASS_CONTEXT
argument_list|(
name|TREE_VALUE
argument_list|(
name|sub_values
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|TYPE_DERIVES_FROM
argument_list|(
name|context
argument_list|,
name|type
argument_list|)
condition|)
block|{
name|value
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|TREE_VALUE
argument_list|(
name|values
argument_list|)
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|problem
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
block|}
else|else
block|{
name|context
operator|=
name|DECL_CLASS_CONTEXT
argument_list|(
name|sub_values
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|TYPE_DERIVES_FROM
argument_list|(
name|context
argument_list|,
name|type
argument_list|)
condition|)
block|{
name|value
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|values
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|problem
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
operator|!
name|problem
condition|)
name|value
operator|=
name|fields
expr_stmt|;
block|}
comment|/* Mark this as a potentially ambiguous member.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|TREE_LIST
condition|)
block|{
comment|/* Leaving TREE_TYPE blank is intentional. 		     We cannot use `error_mark_node' (lookup_name) 		     or `unknown_type_node' (all member functions use this).  */
name|TREE_NONLOCAL_FLAG
argument_list|(
name|value
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
name|IDENTIFIER_CLASS_VALUE
argument_list|(
name|DECL_NAME
argument_list|(
name|fields
argument_list|)
argument_list|)
operator|=
name|value
expr_stmt|;
block|}
else|else
name|IDENTIFIER_CLASS_VALUE
argument_list|(
name|DECL_NAME
argument_list|(
name|fields
argument_list|)
argument_list|)
operator|=
name|fields
expr_stmt|;
block|}
block|}
name|method_vec
operator|=
name|CLASSTYPE_METHOD_VEC
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|method_vec
operator|!=
literal|0
condition|)
block|{
comment|/* Farm out constructors and destructors.  */
name|methods
operator|=
operator|&
name|TREE_VEC_ELT
argument_list|(
name|method_vec
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|end
operator|=
name|TREE_VEC_END
argument_list|(
name|method_vec
argument_list|)
expr_stmt|;
comment|/* This does not work for multiple inheritance yet.  */
while|while
condition|(
name|methods
operator|!=
name|end
condition|)
block|{
comment|/* This will cause lookup_name to return a pointer 	     to the tree_list of possible methods of this name. 	     If the order is a problem, we can nreverse them.  */
name|tree
name|tmp
decl_stmt|;
name|tree
name|old
init|=
name|IDENTIFIER_CLASS_VALUE
argument_list|(
name|DECL_NAME
argument_list|(
operator|*
name|methods
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|old
operator|&&
name|TREE_CODE
argument_list|(
name|old
argument_list|)
operator|==
name|TREE_LIST
condition|)
name|tmp
operator|=
name|tree_cons
argument_list|(
name|DECL_NAME
argument_list|(
operator|*
name|methods
argument_list|)
argument_list|,
operator|*
name|methods
argument_list|,
name|old
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Only complain if we shadow something we can access.  */
if|if
condition|(
name|old
operator|&&
operator|(
name|DECL_CLASS_CONTEXT
argument_list|(
name|old
argument_list|)
operator|==
name|current_class_type
operator|||
operator|!
name|TREE_PRIVATE
argument_list|(
name|old
argument_list|)
operator|)
condition|)
comment|/* Should figure out visibility more accurately.  */
name|warning
argument_list|(
literal|"shadowing member `%s' with member function"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
operator|*
name|methods
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|build_tree_list
argument_list|(
name|DECL_NAME
argument_list|(
operator|*
name|methods
argument_list|)
argument_list|,
operator|*
name|methods
argument_list|)
expr_stmt|;
block|}
name|TREE_TYPE
argument_list|(
name|tmp
argument_list|)
operator|=
name|unknown_type_node
expr_stmt|;
if|#
directive|if
literal|0
block|TREE_OVERLOADED (tmp) = DECL_OVERLOADED (*methods);
endif|#
directive|endif
name|TREE_NONLOCAL_FLAG
argument_list|(
name|tmp
argument_list|)
operator|=
literal|1
expr_stmt|;
name|IDENTIFIER_CLASS_VALUE
argument_list|(
name|DECL_NAME
argument_list|(
operator|*
name|methods
argument_list|)
argument_list|)
operator|=
name|tmp
expr_stmt|;
name|tmp
operator|=
operator|*
name|methods
expr_stmt|;
while|while
condition|(
name|tmp
operator|!=
literal|0
condition|)
block|{
name|DECL_PUBLIC
argument_list|(
name|tmp
argument_list|)
operator|=
literal|0
expr_stmt|;
name|DECL_PROTECTED
argument_list|(
name|tmp
argument_list|)
operator|=
literal|0
expr_stmt|;
name|DECL_PRIVATE
argument_list|(
name|tmp
argument_list|)
operator|=
literal|0
expr_stmt|;
name|tmp
operator|=
name|DECL_CHAIN
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
block|}
name|methods
operator|++
expr_stmt|;
block|}
block|}
name|SET_BINFO_MARKED
argument_list|(
name|binfo
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Consolidate unique (by name) member functions.  */
end_comment

begin_function
specifier|static
name|void
name|dfs_compress_decls
parameter_list|(
name|binfo
parameter_list|)
name|tree
name|binfo
decl_stmt|;
block|{
name|tree
name|type
init|=
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
decl_stmt|;
name|tree
name|method_vec
init|=
name|CLASSTYPE_METHOD_VEC
argument_list|(
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|method_vec
operator|!=
literal|0
condition|)
block|{
comment|/* Farm out constructors and destructors.  */
name|tree
modifier|*
name|methods
init|=
operator|&
name|TREE_VEC_ELT
argument_list|(
name|method_vec
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|tree
modifier|*
name|end
init|=
name|TREE_VEC_END
argument_list|(
name|method_vec
argument_list|)
decl_stmt|;
for|for
control|(
init|;
name|methods
operator|!=
name|end
condition|;
name|methods
operator|++
control|)
block|{
name|tree
name|tmp
init|=
name|IDENTIFIER_CLASS_VALUE
argument_list|(
name|DECL_NAME
argument_list|(
operator|*
name|methods
argument_list|)
argument_list|)
decl_stmt|;
comment|/* This was replaced in scope by somebody else.  Just leave it 	     alone.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|tmp
argument_list|)
operator|!=
name|TREE_LIST
condition|)
continue|continue;
if|if
condition|(
name|TREE_CHAIN
argument_list|(
name|tmp
argument_list|)
operator|==
name|NULL_TREE
operator|&&
name|TREE_VALUE
argument_list|(
name|tmp
argument_list|)
operator|&&
name|DECL_CHAIN
argument_list|(
name|TREE_VALUE
argument_list|(
name|tmp
argument_list|)
argument_list|)
operator|==
name|NULL_TREE
condition|)
block|{
name|IDENTIFIER_CLASS_VALUE
argument_list|(
name|DECL_NAME
argument_list|(
operator|*
name|methods
argument_list|)
argument_list|)
operator|=
name|TREE_VALUE
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|CLEAR_BINFO_MARKED
argument_list|(
name|binfo
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* When entering the scope of a class, we cache all of the    fields that that class provides within its inheritance    lattice.  Where ambiguities result, we mark them    with `error_mark_node' so that if they are encountered    without explicit qualification, we can emit an error    message.  */
end_comment

begin_function
name|void
name|push_class_decls
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
name|tree
name|id
decl_stmt|;
name|struct
name|obstack
modifier|*
name|ambient_obstack
init|=
name|current_obstack
decl_stmt|;
if|#
directive|if
literal|0
block|tree tags = CLASSTYPE_TAGS (type);    while (tags)     {       tree code_type_node;       tree tag;        switch (TREE_CODE (TREE_VALUE (tags))) 	{ 	case ENUMERAL_TYPE: 	  code_type_node = enum_type_node; 	  break; 	case RECORD_TYPE: 	  code_type_node = record_type_node; 	  break; 	case CLASS_TYPE: 	  code_type_node = class_type_node; 	  break; 	case UNION_TYPE: 	  code_type_node = union_type_node; 	  break; 	default: 	  my_friendly_assert (0, 297); 	}       tag = xref_tag (code_type_node, TREE_PURPOSE (tags), 		      TYPE_BINFO_BASETYPE (TREE_VALUE (tags), 0));
if|#
directive|if
literal|0
comment|/* not yet, should get fixed properly later */
block|pushdecl (make_type_decl (TREE_PURPOSE (tags), TREE_VALUE (tags)));
else|#
directive|else
block|pushdecl (build_decl (TYPE_DECL, TREE_PURPOSE (tags), TREE_VALUE (tags)));
endif|#
directive|endif
block|}
endif|#
directive|endif
name|current_obstack
operator|=
operator|&
name|bridge_obstack
expr_stmt|;
name|search_stack
operator|=
name|push_search_level
argument_list|(
name|search_stack
argument_list|,
operator|&
name|bridge_obstack
argument_list|)
expr_stmt|;
name|id
operator|=
name|TYPE_IDENTIFIER
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|IDENTIFIER_TEMPLATE
argument_list|(
name|id
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|#
directive|if
literal|0
block|tree tmpl = IDENTIFIER_TEMPLATE (id);       push_template_decls (DECL_ARGUMENTS (TREE_PURPOSE (tmpl)), 			   TREE_VALUE (tmpl), 1);
endif|#
directive|endif
name|overload_template_name
argument_list|(
name|id
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* Push class fields into CLASS_VALUE scope, and mark.  */
name|dfs_walk
argument_list|(
name|TYPE_BINFO
argument_list|(
name|type
argument_list|)
argument_list|,
name|dfs_pushdecls
argument_list|,
name|unmarkedp
argument_list|)
expr_stmt|;
comment|/* Compress fields which have only a single entry      by a given name, and unmark.  */
name|dfs_walk
argument_list|(
name|TYPE_BINFO
argument_list|(
name|type
argument_list|)
argument_list|,
name|dfs_compress_decls
argument_list|,
name|markedp
argument_list|)
expr_stmt|;
name|current_obstack
operator|=
name|ambient_obstack
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dfs_popdecls
parameter_list|(
name|binfo
parameter_list|)
name|tree
name|binfo
decl_stmt|;
block|{
name|tree
name|type
init|=
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
decl_stmt|;
name|tree
name|fields
init|=
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|tree
name|method_vec
init|=
name|CLASSTYPE_METHOD_VEC
argument_list|(
name|type
argument_list|)
decl_stmt|;
while|while
condition|(
name|fields
condition|)
block|{
if|if
condition|(
name|DECL_NAME
argument_list|(
name|fields
argument_list|)
operator|==
name|NULL_TREE
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|fields
argument_list|)
argument_list|)
operator|==
name|UNION_TYPE
condition|)
block|{
name|dfs_popdecls
argument_list|(
name|TYPE_BINFO
argument_list|(
name|TREE_TYPE
argument_list|(
name|fields
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|DECL_NAME
argument_list|(
name|fields
argument_list|)
condition|)
name|IDENTIFIER_CLASS_VALUE
argument_list|(
name|DECL_NAME
argument_list|(
name|fields
argument_list|)
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
name|fields
operator|=
name|TREE_CHAIN
argument_list|(
name|fields
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|method_vec
operator|!=
literal|0
condition|)
block|{
name|tree
modifier|*
name|methods
init|=
operator|&
name|TREE_VEC_ELT
argument_list|(
name|method_vec
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
modifier|*
name|end
init|=
name|TREE_VEC_END
argument_list|(
name|method_vec
argument_list|)
decl_stmt|;
comment|/* Clear out ctors and dtors.  */
if|if
condition|(
operator|*
name|methods
condition|)
name|IDENTIFIER_CLASS_VALUE
argument_list|(
name|TYPE_IDENTIFIER
argument_list|(
name|type
argument_list|)
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
for|for
control|(
name|methods
operator|+=
literal|1
init|;
name|methods
operator|!=
name|end
condition|;
name|methods
operator|++
control|)
name|IDENTIFIER_CLASS_VALUE
argument_list|(
name|DECL_NAME
argument_list|(
operator|*
name|methods
argument_list|)
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
block|}
name|SET_BINFO_MARKED
argument_list|(
name|binfo
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|pop_class_decls
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
name|tree
name|binfo
init|=
name|TYPE_BINFO
argument_list|(
name|type
argument_list|)
decl_stmt|;
comment|/* Clear out the IDENTIFIER_CLASS_VALUE which this      class may have occupied, and mark.  */
name|dfs_walk
argument_list|(
name|binfo
argument_list|,
name|dfs_popdecls
argument_list|,
name|unmarkedp
argument_list|)
expr_stmt|;
comment|/* Unmark.  */
name|dfs_walk
argument_list|(
name|binfo
argument_list|,
name|dfs_unmark
argument_list|,
name|markedp
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|tmpl = IDENTIFIER_TEMPLATE (TYPE_IDENTIFIER (type));   if (tmpl != 0)     pop_template_decls (DECL_ARGUMENTS (TREE_PURPOSE (tmpl)), 			TREE_VALUE (tmpl), 1);
endif|#
directive|endif
name|search_stack
operator|=
name|pop_search_level
argument_list|(
name|search_stack
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Given a base type PARENT, and a derived type TYPE, build    a name which distinguishes exactly the PARENT member of TYPE's type.     FORMAT is a string which controls how sprintf formats the name    we have generated.     For example, given  	class A; class B; class C : A, B;     it is possible to distinguish "A" from "C's A".  And given  	class L; 	class A : L; class B : L; class C : A, B;     it is possible to distinguish "L" from "A's L", and also from    "C's L from A".     Make sure to use the DECL_ASSEMBLER_NAME of the TYPE_NAME of the    type, as template have DECL_NAMEs like: X<int>, whereas the    DECL_ASSEMBLER_NAME is set to be something the assembler can handle.   */
end_comment

begin_function
name|tree
name|build_type_pathname
parameter_list|(
name|format
parameter_list|,
name|parent
parameter_list|,
name|type
parameter_list|)
name|char
modifier|*
name|format
decl_stmt|;
name|tree
name|parent
decl_stmt|,
name|type
decl_stmt|;
block|{
specifier|extern
name|struct
name|obstack
name|temporary_obstack
decl_stmt|;
name|char
modifier|*
name|first
decl_stmt|,
modifier|*
name|base
decl_stmt|,
modifier|*
name|name
decl_stmt|;
name|int
name|i
decl_stmt|;
name|tree
name|id
decl_stmt|;
name|parent
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|parent
argument_list|)
expr_stmt|;
comment|/* Remember where to cut the obstack to.  */
name|first
operator|=
name|obstack_base
argument_list|(
operator|&
name|temporary_obstack
argument_list|)
expr_stmt|;
comment|/* Put on TYPE+PARENT.  */
name|obstack_grow
argument_list|(
operator|&
name|temporary_obstack
argument_list|,
name|TYPE_ASSEMBLER_NAME_STRING
argument_list|(
name|type
argument_list|)
argument_list|,
name|TYPE_ASSEMBLER_NAME_LENGTH
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|obstack_1grow
argument_list|(
operator|&
name|temporary_obstack
argument_list|,
name|JOINER
argument_list|)
expr_stmt|;
name|obstack_grow0
argument_list|(
operator|&
name|temporary_obstack
argument_list|,
name|TYPE_ASSEMBLER_NAME_STRING
argument_list|(
name|parent
argument_list|)
argument_list|,
name|TYPE_ASSEMBLER_NAME_LENGTH
argument_list|(
name|parent
argument_list|)
argument_list|)
expr_stmt|;
name|i
operator|=
name|obstack_object_size
argument_list|(
operator|&
name|temporary_obstack
argument_list|)
expr_stmt|;
name|base
operator|=
name|obstack_base
argument_list|(
operator|&
name|temporary_obstack
argument_list|)
expr_stmt|;
name|obstack_finish
argument_list|(
operator|&
name|temporary_obstack
argument_list|)
expr_stmt|;
comment|/* Put on FORMAT+TYPE+PARENT.  */
name|obstack_blank
argument_list|(
operator|&
name|temporary_obstack
argument_list|,
name|strlen
argument_list|(
name|format
argument_list|)
operator|+
name|i
operator|+
literal|1
argument_list|)
expr_stmt|;
name|name
operator|=
name|obstack_base
argument_list|(
operator|&
name|temporary_obstack
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|name
argument_list|,
name|format
argument_list|,
name|base
argument_list|)
expr_stmt|;
name|id
operator|=
name|get_identifier
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|obstack_free
argument_list|(
operator|&
name|temporary_obstack
argument_list|,
name|first
argument_list|)
expr_stmt|;
return|return
name|id
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bfs_unmark_finished_struct
parameter_list|(
name|binfo
parameter_list|,
name|i
parameter_list|)
name|tree
name|binfo
decl_stmt|;
name|int
name|i
decl_stmt|;
block|{
if|if
condition|(
name|i
operator|>=
literal|0
condition|)
name|binfo
operator|=
name|BINFO_BASETYPE
argument_list|(
name|binfo
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|BINFO_NEW_VTABLE_MARKED
argument_list|(
name|binfo
argument_list|)
condition|)
block|{
name|tree
name|decl
decl_stmt|,
name|context
decl_stmt|;
if|if
condition|(
name|TREE_VIA_VIRTUAL
argument_list|(
name|binfo
argument_list|)
condition|)
name|binfo
operator|=
name|binfo_member
argument_list|(
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
argument_list|,
name|CLASSTYPE_VBASECLASSES
argument_list|(
name|current_class_type
argument_list|)
argument_list|)
expr_stmt|;
name|decl
operator|=
name|BINFO_VTABLE
argument_list|(
name|binfo
argument_list|)
expr_stmt|;
name|context
operator|=
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|write_virtuals
operator|>=
literal|0
operator|&&
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|!=
name|BINFO_VIRTUALS
argument_list|(
name|binfo
argument_list|)
condition|)
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|=
name|build_nt
argument_list|(
name|CONSTRUCTOR
argument_list|,
name|NULL_TREE
argument_list|,
name|BINFO_VIRTUALS
argument_list|(
name|binfo
argument_list|)
argument_list|)
expr_stmt|;
name|finish_decl
argument_list|(
name|decl
argument_list|,
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
operator|=
name|context
expr_stmt|;
block|}
name|CLEAR_BINFO_VTABLE_PATH_MARKED
argument_list|(
name|binfo
argument_list|)
expr_stmt|;
name|CLEAR_BINFO_NEW_VTABLE_MARKED
argument_list|(
name|binfo
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|unmark_finished_struct
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
name|tree
name|binfo
init|=
name|TYPE_BINFO
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|bfs_unmark_finished_struct
argument_list|(
name|binfo
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|breadth_first_search
argument_list|(
name|binfo
argument_list|,
name|bfs_unmark_finished_struct
argument_list|,
name|bfs_marked_vtable_pathp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|print_search_statistics
parameter_list|()
block|{
ifdef|#
directive|ifdef
name|GATHER_STATISTICS
if|if
condition|(
name|flag_memoize_lookups
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%d memoized contexts saved\n"
argument_list|,
name|n_contexts_saved
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%d local tree nodes made\n"
argument_list|,
name|my_tree_node_counter
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%d local hash nodes made\n"
argument_list|,
name|my_memoized_entry_counter
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"fields statistics:\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"  memoized finds = %d; rejects = %d; (searches = %d)\n"
argument_list|,
name|memoized_fast_finds
index|[
literal|0
index|]
argument_list|,
name|memoized_fast_rejects
index|[
literal|0
index|]
argument_list|,
name|memoized_fields_searched
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"  memoized_adds = %d\n"
argument_list|,
name|memoized_adds
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"fnfields statistics:\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"  memoized finds = %d; rejects = %d; (searches = %d)\n"
argument_list|,
name|memoized_fast_finds
index|[
literal|1
index|]
argument_list|,
name|memoized_fast_rejects
index|[
literal|1
index|]
argument_list|,
name|memoized_fields_searched
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"  memoized_adds = %d\n"
argument_list|,
name|memoized_adds
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%d fields searched in %d[%d] calls to lookup_field[_1]\n"
argument_list|,
name|n_fields_searched
argument_list|,
name|n_calls_lookup_field
argument_list|,
name|n_calls_lookup_field_1
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%d fnfields searched in %d calls to lookup_fnfields\n"
argument_list|,
name|n_outer_fields_searched
argument_list|,
name|n_calls_lookup_fnfields
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%d calls to get_base_type\n"
argument_list|,
name|n_calls_get_base_type
argument_list|)
expr_stmt|;
else|#
directive|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"no search statistics\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
name|void
name|init_search_processing
parameter_list|()
block|{
name|gcc_obstack_init
argument_list|(
operator|&
name|search_obstack
argument_list|)
expr_stmt|;
name|gcc_obstack_init
argument_list|(
operator|&
name|type_obstack
argument_list|)
expr_stmt|;
name|gcc_obstack_init
argument_list|(
operator|&
name|type_obstack_entries
argument_list|)
expr_stmt|;
name|gcc_obstack_init
argument_list|(
operator|&
name|bridge_obstack
argument_list|)
expr_stmt|;
comment|/* This gives us room to build our chains of basetypes,      whether or not we decide to memoize them.  */
name|type_stack
operator|=
name|push_type_level
argument_list|(
literal|0
argument_list|,
operator|&
name|type_obstack
argument_list|)
expr_stmt|;
name|_vptr_name
operator|=
name|get_identifier
argument_list|(
literal|"_vptr"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|reinit_search_statistics
parameter_list|()
block|{
name|my_memoized_entry_counter
operator|=
literal|0
expr_stmt|;
name|memoized_fast_finds
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|memoized_fast_finds
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|memoized_adds
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|memoized_adds
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|memoized_fast_rejects
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|memoized_fast_rejects
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|memoized_fields_searched
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|memoized_fields_searched
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|n_fields_searched
operator|=
literal|0
expr_stmt|;
name|n_calls_lookup_field
operator|=
literal|0
operator|,
name|n_calls_lookup_field_1
operator|=
literal|0
expr_stmt|;
name|n_calls_lookup_fnfields
operator|=
literal|0
operator|,
name|n_calls_lookup_fnfields_1
operator|=
literal|0
expr_stmt|;
name|n_calls_get_base_type
operator|=
literal|0
expr_stmt|;
name|n_outer_fields_searched
operator|=
literal|0
expr_stmt|;
name|n_contexts_saved
operator|=
literal|0
expr_stmt|;
block|}
end_function

end_unit

