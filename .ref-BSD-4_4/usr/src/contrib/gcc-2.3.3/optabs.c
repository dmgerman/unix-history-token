begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Expand the basic unary and binary arithmetic operations, for GNU compiler.    Copyright (C) 1987, 1988, 1992 Free Software Foundation, Inc.  This file is part of GNU CC.  GNU CC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU CC; see the file COPYING.  If not, write to the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"insn-flags.h"
end_include

begin_include
include|#
directive|include
file|"insn-codes.h"
end_include

begin_include
include|#
directive|include
file|"expr.h"
end_include

begin_include
include|#
directive|include
file|"insn-config.h"
end_include

begin_include
include|#
directive|include
file|"recog.h"
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_comment
comment|/* Each optab contains info on how this target machine    can perform a particular operation    for all sizes and kinds of operands.     The operation to be performed is often specified    by passing one of these optabs as an argument.     See expr.h for documentation of these optabs.  */
end_comment

begin_decl_stmt
name|optab
name|add_optab
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|optab
name|sub_optab
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|optab
name|smul_optab
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|optab
name|smul_widen_optab
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|optab
name|umul_widen_optab
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|optab
name|sdiv_optab
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|optab
name|sdivmod_optab
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|optab
name|udiv_optab
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|optab
name|udivmod_optab
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|optab
name|smod_optab
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|optab
name|umod_optab
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|optab
name|flodiv_optab
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|optab
name|ftrunc_optab
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|optab
name|and_optab
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|optab
name|ior_optab
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|optab
name|xor_optab
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|optab
name|ashl_optab
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|optab
name|lshr_optab
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|optab
name|lshl_optab
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|optab
name|ashr_optab
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|optab
name|rotl_optab
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|optab
name|rotr_optab
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|optab
name|smin_optab
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|optab
name|smax_optab
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|optab
name|umin_optab
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|optab
name|umax_optab
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|optab
name|mov_optab
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|optab
name|movstrict_optab
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|optab
name|neg_optab
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|optab
name|abs_optab
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|optab
name|one_cmpl_optab
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|optab
name|ffs_optab
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|optab
name|sqrt_optab
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|optab
name|sin_optab
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|optab
name|cos_optab
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|optab
name|cmp_optab
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|optab
name|ucmp_optab
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Used only for libcalls for unsigned comparisons.  */
end_comment

begin_decl_stmt
name|optab
name|tst_optab
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|optab
name|strlen_optab
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* SYMBOL_REF rtx's for the library functions that are called    implicitly and not via optabs.  */
end_comment

begin_decl_stmt
name|rtx
name|extendsfdf2_libfunc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|rtx
name|extendsfxf2_libfunc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|rtx
name|extendsftf2_libfunc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|rtx
name|extenddfxf2_libfunc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|rtx
name|extenddftf2_libfunc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|rtx
name|truncdfsf2_libfunc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|rtx
name|truncxfsf2_libfunc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|rtx
name|trunctfsf2_libfunc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|rtx
name|truncxfdf2_libfunc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|rtx
name|trunctfdf2_libfunc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|rtx
name|memcpy_libfunc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|rtx
name|bcopy_libfunc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|rtx
name|memcmp_libfunc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|rtx
name|bcmp_libfunc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|rtx
name|memset_libfunc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|rtx
name|bzero_libfunc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|rtx
name|eqsf2_libfunc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|rtx
name|nesf2_libfunc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|rtx
name|gtsf2_libfunc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|rtx
name|gesf2_libfunc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|rtx
name|ltsf2_libfunc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|rtx
name|lesf2_libfunc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|rtx
name|eqdf2_libfunc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|rtx
name|nedf2_libfunc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|rtx
name|gtdf2_libfunc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|rtx
name|gedf2_libfunc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|rtx
name|ltdf2_libfunc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|rtx
name|ledf2_libfunc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|rtx
name|eqxf2_libfunc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|rtx
name|nexf2_libfunc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|rtx
name|gtxf2_libfunc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|rtx
name|gexf2_libfunc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|rtx
name|ltxf2_libfunc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|rtx
name|lexf2_libfunc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|rtx
name|eqtf2_libfunc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|rtx
name|netf2_libfunc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|rtx
name|gttf2_libfunc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|rtx
name|getf2_libfunc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|rtx
name|lttf2_libfunc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|rtx
name|letf2_libfunc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|rtx
name|floatsisf_libfunc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|rtx
name|floatdisf_libfunc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|rtx
name|floattisf_libfunc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|rtx
name|floatsidf_libfunc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|rtx
name|floatdidf_libfunc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|rtx
name|floattidf_libfunc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|rtx
name|floatsixf_libfunc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|rtx
name|floatdixf_libfunc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|rtx
name|floattixf_libfunc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|rtx
name|floatsitf_libfunc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|rtx
name|floatditf_libfunc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|rtx
name|floattitf_libfunc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|rtx
name|fixsfsi_libfunc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|rtx
name|fixsfdi_libfunc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|rtx
name|fixsfti_libfunc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|rtx
name|fixdfsi_libfunc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|rtx
name|fixdfdi_libfunc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|rtx
name|fixdfti_libfunc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|rtx
name|fixxfsi_libfunc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|rtx
name|fixxfdi_libfunc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|rtx
name|fixxfti_libfunc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|rtx
name|fixtfsi_libfunc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|rtx
name|fixtfdi_libfunc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|rtx
name|fixtfti_libfunc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|rtx
name|fixunssfsi_libfunc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|rtx
name|fixunssfdi_libfunc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|rtx
name|fixunssfti_libfunc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|rtx
name|fixunsdfsi_libfunc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|rtx
name|fixunsdfdi_libfunc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|rtx
name|fixunsdfti_libfunc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|rtx
name|fixunsxfsi_libfunc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|rtx
name|fixunsxfdi_libfunc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|rtx
name|fixunsxfti_libfunc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|rtx
name|fixunstfsi_libfunc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|rtx
name|fixunstfdi_libfunc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|rtx
name|fixunstfti_libfunc
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* from emit-rtl.c */
end_comment

begin_function_decl
specifier|extern
name|rtx
name|gen_highpart
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* Indexed by the rtx-code for a conditional (eg. EQ, LT,...)    gives the gen_function to make a branch to test that condition.  */
end_comment

begin_decl_stmt
name|rtxfun
name|bcc_gen_fctn
index|[
name|NUM_RTX_CODE
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Indexed by the rtx-code for a conditional (eg. EQ, LT,...)    gives the insn code to make a store-condition insn    to test that condition.  */
end_comment

begin_decl_stmt
name|enum
name|insn_code
name|setcc_gen_code
index|[
name|NUM_RTX_CODE
index|]
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|emit_float_lib_cmp
parameter_list|()
function_decl|;
end_function_decl

begin_escape
end_escape

begin_comment
comment|/* Add a REG_EQUAL note to the last insn in SEQ.  TARGET is being set to    the result of operation CODE applied to OP0 (and OP1 if it is a binary    operation).     If the last insn does not set TARGET, don't do anything, but return 1.     If a previous insn sets TARGET and TARGET is one of OP0 or OP1,    don't add the REG_EQUAL note but return 0.  Our caller can then try    again, ensuring that TARGET is not one of the operands.  */
end_comment

begin_function
specifier|static
name|int
name|add_equal_note
parameter_list|(
name|seq
parameter_list|,
name|target
parameter_list|,
name|code
parameter_list|,
name|op0
parameter_list|,
name|op1
parameter_list|)
name|rtx
name|seq
decl_stmt|;
name|rtx
name|target
decl_stmt|;
name|enum
name|rtx_code
name|code
decl_stmt|;
name|rtx
name|op0
decl_stmt|,
name|op1
decl_stmt|;
block|{
name|rtx
name|set
decl_stmt|;
name|int
name|i
decl_stmt|;
name|rtx
name|note
decl_stmt|;
if|if
condition|(
operator|(
name|GET_RTX_CLASS
argument_list|(
name|code
argument_list|)
operator|!=
literal|'1'
operator|&&
name|GET_RTX_CLASS
argument_list|(
name|code
argument_list|)
operator|!=
literal|'2'
operator|&&
name|GET_RTX_CLASS
argument_list|(
name|code
argument_list|)
operator|!=
literal|'c'
operator|&&
name|GET_RTX_CLASS
argument_list|(
name|code
argument_list|)
operator|!=
literal|'<'
operator|)
operator|||
name|GET_CODE
argument_list|(
name|seq
argument_list|)
operator|!=
name|SEQUENCE
operator|||
operator|(
name|set
operator|=
name|single_set
argument_list|(
name|XVECEXP
argument_list|(
name|seq
argument_list|,
literal|0
argument_list|,
name|XVECLEN
argument_list|(
name|seq
argument_list|,
literal|0
argument_list|)
operator|-
literal|1
argument_list|)
argument_list|)
operator|)
operator|==
literal|0
operator|||
name|GET_CODE
argument_list|(
name|target
argument_list|)
operator|==
name|ZERO_EXTRACT
operator|||
operator|(
operator|!
name|rtx_equal_p
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|,
name|target
argument_list|)
comment|/* For a STRICT_LOW_PART, the REG_NOTE applies to what is inside the 	     SUBREG.  */
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
operator|!=
name|STRICT_LOW_PART
operator|||
operator|!
name|rtx_equal_p
argument_list|(
name|SUBREG_REG
argument_list|(
name|XEXP
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|target
argument_list|)
operator|)
operator|)
condition|)
return|return
literal|1
return|;
comment|/* If TARGET is in OP0 or OP1, check if anything in SEQ sets TARGET      besides the last insn.  */
if|if
condition|(
name|reg_overlap_mentioned_p
argument_list|(
name|target
argument_list|,
name|op0
argument_list|)
operator|||
operator|(
name|op1
operator|&&
name|reg_overlap_mentioned_p
argument_list|(
name|target
argument_list|,
name|op1
argument_list|)
operator|)
condition|)
for|for
control|(
name|i
operator|=
name|XVECLEN
argument_list|(
name|seq
argument_list|,
literal|0
argument_list|)
operator|-
literal|2
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|reg_set_p
argument_list|(
name|target
argument_list|,
name|XVECEXP
argument_list|(
name|seq
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|code
argument_list|)
operator|==
literal|'1'
condition|)
name|note
operator|=
name|gen_rtx
argument_list|(
name|code
argument_list|,
name|GET_MODE
argument_list|(
name|target
argument_list|)
argument_list|,
name|op0
argument_list|)
expr_stmt|;
else|else
name|note
operator|=
name|gen_rtx
argument_list|(
name|code
argument_list|,
name|GET_MODE
argument_list|(
name|target
argument_list|)
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
expr_stmt|;
name|REG_NOTES
argument_list|(
name|XVECEXP
argument_list|(
name|seq
argument_list|,
literal|0
argument_list|,
name|XVECLEN
argument_list|(
name|seq
argument_list|,
literal|0
argument_list|)
operator|-
literal|1
argument_list|)
argument_list|)
operator|=
name|gen_rtx
argument_list|(
name|EXPR_LIST
argument_list|,
name|REG_EQUAL
argument_list|,
name|note
argument_list|,
name|REG_NOTES
argument_list|(
name|XVECEXP
argument_list|(
name|seq
argument_list|,
literal|0
argument_list|,
name|XVECLEN
argument_list|(
name|seq
argument_list|,
literal|0
argument_list|)
operator|-
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Generate code to perform an operation specified by BINOPTAB    on operands OP0 and OP1, with result having machine-mode MODE.     UNSIGNEDP is for the case where we have to widen the operands    to perform the operation.  It says to use zero-extension.     If TARGET is nonzero, the value    is generated there, if it is convenient to do so.    In all cases an rtx is returned for the locus of the value;    this may or may not be TARGET.  */
end_comment

begin_function
name|rtx
name|expand_binop
parameter_list|(
name|mode
parameter_list|,
name|binoptab
parameter_list|,
name|op0
parameter_list|,
name|op1
parameter_list|,
name|target
parameter_list|,
name|unsignedp
parameter_list|,
name|methods
parameter_list|)
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|optab
name|binoptab
decl_stmt|;
name|rtx
name|op0
decl_stmt|,
name|op1
decl_stmt|;
name|rtx
name|target
decl_stmt|;
name|int
name|unsignedp
decl_stmt|;
name|enum
name|optab_methods
name|methods
decl_stmt|;
block|{
name|enum
name|mode_class
name|class
decl_stmt|;
name|enum
name|machine_mode
name|wider_mode
decl_stmt|;
specifier|register
name|rtx
name|temp
decl_stmt|;
name|int
name|commutative_op
init|=
literal|0
decl_stmt|;
name|int
name|shift_op
init|=
operator|(
name|binoptab
operator|->
name|code
operator|==
name|ASHIFT
operator|||
name|binoptab
operator|->
name|code
operator|==
name|ASHIFTRT
operator|||
name|binoptab
operator|->
name|code
operator|==
name|LSHIFT
operator|||
name|binoptab
operator|->
name|code
operator|==
name|LSHIFTRT
operator|||
name|binoptab
operator|->
name|code
operator|==
name|ROTATE
operator|||
name|binoptab
operator|->
name|code
operator|==
name|ROTATERT
operator|)
decl_stmt|;
name|rtx
name|entry_last
init|=
name|get_last_insn
argument_list|()
decl_stmt|;
name|rtx
name|last
decl_stmt|;
name|class
operator|=
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|op0
operator|=
name|protect_from_queue
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|op1
operator|=
name|protect_from_queue
argument_list|(
name|op1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
condition|)
name|target
operator|=
name|protect_from_queue
argument_list|(
name|target
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_force_mem
condition|)
block|{
name|op0
operator|=
name|force_not_mem
argument_list|(
name|op0
argument_list|)
expr_stmt|;
name|op1
operator|=
name|force_not_mem
argument_list|(
name|op1
argument_list|)
expr_stmt|;
block|}
comment|/* If subtracting an integer constant, convert this into an addition of      the negated constant.  */
if|if
condition|(
name|binoptab
operator|==
name|sub_optab
operator|&&
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|op1
operator|=
name|negate_rtx
argument_list|(
name|mode
argument_list|,
name|op1
argument_list|)
expr_stmt|;
name|binoptab
operator|=
name|add_optab
expr_stmt|;
block|}
comment|/* If we are inside an appropriately-short loop and one operand is an      expensive constant, force it into a register.  */
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|op0
argument_list|)
operator|&&
name|preserve_subexpressions_p
argument_list|()
operator|&&
name|rtx_cost
argument_list|(
name|op0
argument_list|,
name|binoptab
operator|->
name|code
argument_list|)
operator|>
literal|2
condition|)
name|op0
operator|=
name|force_reg
argument_list|(
name|mode
argument_list|,
name|op0
argument_list|)
expr_stmt|;
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|op1
argument_list|)
operator|&&
name|preserve_subexpressions_p
argument_list|()
operator|&&
name|rtx_cost
argument_list|(
name|op1
argument_list|,
name|binoptab
operator|->
name|code
argument_list|)
operator|>
literal|2
condition|)
name|op1
operator|=
name|force_reg
argument_list|(
name|shift_op
condition|?
name|word_mode
else|:
name|mode
argument_list|,
name|op1
argument_list|)
expr_stmt|;
comment|/* Record where to delete back to if we backtrack.  */
name|last
operator|=
name|get_last_insn
argument_list|()
expr_stmt|;
comment|/* If operation is commutative,      try to make the first operand a register.      Even better, try to make it the same as the target.      Also try to make the last operand a constant.  */
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|binoptab
operator|->
name|code
argument_list|)
operator|==
literal|'c'
operator|||
name|binoptab
operator|==
name|smul_widen_optab
operator|||
name|binoptab
operator|==
name|umul_widen_optab
condition|)
block|{
name|commutative_op
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|target
operator|==
literal|0
operator|||
name|GET_CODE
argument_list|(
name|target
argument_list|)
operator|==
name|REG
operator|)
condition|?
operator|(
operator|(
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|REG
operator|&&
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|!=
name|REG
operator|)
operator|||
name|target
operator|==
name|op1
operator|)
else|:
name|rtx_equal_p
argument_list|(
name|op1
argument_list|,
name|target
argument_list|)
operator|)
operator|||
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|temp
operator|=
name|op1
expr_stmt|;
name|op1
operator|=
name|op0
expr_stmt|;
name|op0
operator|=
name|temp
expr_stmt|;
block|}
block|}
comment|/* If we can do it with a three-operand insn, do so.  */
if|if
condition|(
name|methods
operator|!=
name|OPTAB_MUST_WIDEN
operator|&&
name|binoptab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|mode
index|]
operator|.
name|insn_code
operator|!=
name|CODE_FOR_nothing
condition|)
block|{
name|int
name|icode
init|=
operator|(
name|int
operator|)
name|binoptab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|mode
index|]
operator|.
name|insn_code
decl_stmt|;
name|enum
name|machine_mode
name|mode0
init|=
name|insn_operand_mode
index|[
name|icode
index|]
index|[
literal|1
index|]
decl_stmt|;
name|enum
name|machine_mode
name|mode1
init|=
name|insn_operand_mode
index|[
name|icode
index|]
index|[
literal|2
index|]
decl_stmt|;
name|rtx
name|pat
decl_stmt|;
name|rtx
name|xop0
init|=
name|op0
decl_stmt|,
name|xop1
init|=
name|op1
decl_stmt|;
if|if
condition|(
name|target
condition|)
name|temp
operator|=
name|target
expr_stmt|;
else|else
name|temp
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
comment|/* If it is a commutative operator and the modes would match 	 if we would swap the operands, we can save the conversions. */
if|if
condition|(
name|commutative_op
condition|)
block|{
if|if
condition|(
name|GET_MODE
argument_list|(
name|op0
argument_list|)
operator|!=
name|mode0
operator|&&
name|GET_MODE
argument_list|(
name|op1
argument_list|)
operator|!=
name|mode1
operator|&&
name|GET_MODE
argument_list|(
name|op0
argument_list|)
operator|==
name|mode1
operator|&&
name|GET_MODE
argument_list|(
name|op1
argument_list|)
operator|==
name|mode0
condition|)
block|{
specifier|register
name|rtx
name|tmp
decl_stmt|;
name|tmp
operator|=
name|op0
expr_stmt|;
name|op0
operator|=
name|op1
expr_stmt|;
name|op1
operator|=
name|tmp
expr_stmt|;
name|tmp
operator|=
name|xop0
expr_stmt|;
name|xop0
operator|=
name|xop1
expr_stmt|;
name|xop1
operator|=
name|tmp
expr_stmt|;
block|}
block|}
comment|/* In case the insn wants input operands in modes different from 	 the result, convert the operands.  */
if|if
condition|(
name|GET_MODE
argument_list|(
name|op0
argument_list|)
operator|!=
name|VOIDmode
operator|&&
name|GET_MODE
argument_list|(
name|op0
argument_list|)
operator|!=
name|mode0
condition|)
name|xop0
operator|=
name|convert_to_mode
argument_list|(
name|mode0
argument_list|,
name|xop0
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|xop1
argument_list|)
operator|!=
name|VOIDmode
operator|&&
name|GET_MODE
argument_list|(
name|xop1
argument_list|)
operator|!=
name|mode1
condition|)
name|xop1
operator|=
name|convert_to_mode
argument_list|(
name|mode1
argument_list|,
name|xop1
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
comment|/* Now, if insn's predicates don't allow our operands, put them into 	 pseudo regs.  */
if|if
condition|(
operator|!
call|(
modifier|*
name|insn_operand_predicate
index|[
name|icode
index|]
index|[
literal|1
index|]
call|)
argument_list|(
name|xop0
argument_list|,
name|mode0
argument_list|)
condition|)
name|xop0
operator|=
name|copy_to_mode_reg
argument_list|(
name|mode0
argument_list|,
name|xop0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
call|(
modifier|*
name|insn_operand_predicate
index|[
name|icode
index|]
index|[
literal|2
index|]
call|)
argument_list|(
name|xop1
argument_list|,
name|mode1
argument_list|)
condition|)
name|xop1
operator|=
name|copy_to_mode_reg
argument_list|(
name|mode1
argument_list|,
name|xop1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
call|(
modifier|*
name|insn_operand_predicate
index|[
name|icode
index|]
index|[
literal|0
index|]
call|)
argument_list|(
name|temp
argument_list|,
name|mode
argument_list|)
condition|)
name|temp
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|pat
operator|=
name|GEN_FCN
argument_list|(
name|icode
argument_list|)
argument_list|(
name|temp
argument_list|,
name|xop0
argument_list|,
name|xop1
argument_list|)
expr_stmt|;
if|if
condition|(
name|pat
condition|)
block|{
comment|/* If PAT is a multi-insn sequence, try to add an appropriate 	     REG_EQUAL note to it.  If we can't because TEMP conflicts with an 	     operand, call ourselves again, this time without a target.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|==
name|SEQUENCE
operator|&&
operator|!
name|add_equal_note
argument_list|(
name|pat
argument_list|,
name|temp
argument_list|,
name|binoptab
operator|->
name|code
argument_list|,
name|xop0
argument_list|,
name|xop1
argument_list|)
condition|)
block|{
name|delete_insns_since
argument_list|(
name|last
argument_list|)
expr_stmt|;
return|return
name|expand_binop
argument_list|(
name|mode
argument_list|,
name|binoptab
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|,
name|NULL_RTX
argument_list|,
name|unsignedp
argument_list|,
name|methods
argument_list|)
return|;
block|}
name|emit_insn
argument_list|(
name|pat
argument_list|)
expr_stmt|;
return|return
name|temp
return|;
block|}
else|else
name|delete_insns_since
argument_list|(
name|last
argument_list|)
expr_stmt|;
block|}
comment|/* If this is a multiply, see if we can do a widening operation that      takes operands of this mode and makes a wider mode.  */
if|if
condition|(
name|binoptab
operator|==
name|smul_optab
operator|&&
name|GET_MODE_WIDER_MODE
argument_list|(
name|mode
argument_list|)
operator|!=
name|VOIDmode
operator|&&
operator|(
operator|(
operator|(
name|unsignedp
condition|?
name|umul_widen_optab
else|:
name|smul_widen_optab
operator|)
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|GET_MODE_WIDER_MODE
argument_list|(
name|mode
argument_list|)
index|]
operator|.
name|insn_code
operator|)
operator|!=
name|CODE_FOR_nothing
operator|)
condition|)
block|{
name|temp
operator|=
name|expand_binop
argument_list|(
name|GET_MODE_WIDER_MODE
argument_list|(
name|mode
argument_list|)
argument_list|,
name|unsignedp
condition|?
name|umul_widen_optab
else|:
name|smul_widen_optab
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|,
literal|0
argument_list|,
name|unsignedp
argument_list|,
name|OPTAB_DIRECT
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_INT
condition|)
return|return
name|gen_lowpart
argument_list|(
name|mode
argument_list|,
name|temp
argument_list|)
return|;
else|else
return|return
name|convert_to_mode
argument_list|(
name|mode
argument_list|,
name|temp
argument_list|,
name|unsignedp
argument_list|)
return|;
block|}
comment|/* Look for a wider mode of the same class for which we think we      can open-code the operation.  Check for a widening multiply at the      wider mode as well.  */
if|if
condition|(
operator|(
name|class
operator|==
name|MODE_INT
operator|||
name|class
operator|==
name|MODE_FLOAT
operator|||
name|class
operator|==
name|MODE_COMPLEX_FLOAT
operator|)
operator|&&
name|methods
operator|!=
name|OPTAB_DIRECT
operator|&&
name|methods
operator|!=
name|OPTAB_LIB
condition|)
for|for
control|(
name|wider_mode
operator|=
name|GET_MODE_WIDER_MODE
argument_list|(
name|mode
argument_list|)
init|;
name|wider_mode
operator|!=
name|VOIDmode
condition|;
name|wider_mode
operator|=
name|GET_MODE_WIDER_MODE
argument_list|(
name|wider_mode
argument_list|)
control|)
block|{
if|if
condition|(
name|binoptab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|wider_mode
index|]
operator|.
name|insn_code
operator|!=
name|CODE_FOR_nothing
operator|||
operator|(
name|binoptab
operator|==
name|smul_optab
operator|&&
name|GET_MODE_WIDER_MODE
argument_list|(
name|wider_mode
argument_list|)
operator|!=
name|VOIDmode
operator|&&
operator|(
operator|(
operator|(
name|unsignedp
condition|?
name|umul_widen_optab
else|:
name|smul_widen_optab
operator|)
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|GET_MODE_WIDER_MODE
argument_list|(
name|wider_mode
argument_list|)
index|]
operator|.
name|insn_code
operator|)
operator|!=
name|CODE_FOR_nothing
operator|)
operator|)
condition|)
block|{
name|rtx
name|xop0
init|=
name|op0
decl_stmt|,
name|xop1
init|=
name|op1
decl_stmt|;
name|int
name|no_extend
init|=
literal|0
decl_stmt|;
comment|/* For certain integer operations, we need not actually extend 	       the narrow operands, as long as we will truncate 	       the results to the same narrowness.  Don't do this when 	       WIDER_MODE is wider than a word since a paradoxical SUBREG 	       isn't valid for such modes.  */
if|if
condition|(
operator|(
name|binoptab
operator|==
name|ior_optab
operator|||
name|binoptab
operator|==
name|and_optab
operator|||
name|binoptab
operator|==
name|xor_optab
operator|||
name|binoptab
operator|==
name|add_optab
operator|||
name|binoptab
operator|==
name|sub_optab
operator|||
name|binoptab
operator|==
name|smul_optab
operator|||
name|binoptab
operator|==
name|ashl_optab
operator|||
name|binoptab
operator|==
name|lshl_optab
operator|)
operator|&&
name|class
operator|==
name|MODE_INT
operator|&&
name|GET_MODE_SIZE
argument_list|(
name|wider_mode
argument_list|)
operator|<=
name|UNITS_PER_WORD
condition|)
name|no_extend
operator|=
literal|1
expr_stmt|;
comment|/* If an operand is a constant integer, we might as well 	       convert it since that is more efficient than using a SUBREG, 	       unlike the case for other operands.  Similarly for 	       SUBREGs that were made due to promoted objects.  */
if|if
condition|(
name|no_extend
operator|&&
name|GET_MODE
argument_list|(
name|xop0
argument_list|)
operator|!=
name|VOIDmode
operator|&&
operator|!
operator|(
name|GET_CODE
argument_list|(
name|xop0
argument_list|)
operator|==
name|SUBREG
operator|&&
name|SUBREG_PROMOTED_VAR_P
argument_list|(
name|xop0
argument_list|)
operator|)
condition|)
name|xop0
operator|=
name|gen_rtx
argument_list|(
name|SUBREG
argument_list|,
name|wider_mode
argument_list|,
name|force_reg
argument_list|(
name|GET_MODE
argument_list|(
name|xop0
argument_list|)
argument_list|,
name|xop0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|xop0
operator|=
name|convert_to_mode
argument_list|(
name|wider_mode
argument_list|,
name|xop0
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
if|if
condition|(
name|no_extend
operator|&&
name|GET_MODE
argument_list|(
name|xop1
argument_list|)
operator|!=
name|VOIDmode
operator|&&
operator|!
operator|(
name|GET_CODE
argument_list|(
name|xop1
argument_list|)
operator|==
name|SUBREG
operator|&&
name|SUBREG_PROMOTED_VAR_P
argument_list|(
name|xop1
argument_list|)
operator|)
condition|)
name|xop1
operator|=
name|gen_rtx
argument_list|(
name|SUBREG
argument_list|,
name|wider_mode
argument_list|,
name|force_reg
argument_list|(
name|GET_MODE
argument_list|(
name|xop1
argument_list|)
argument_list|,
name|xop1
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|xop1
operator|=
name|convert_to_mode
argument_list|(
name|wider_mode
argument_list|,
name|xop1
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
name|temp
operator|=
name|expand_binop
argument_list|(
name|wider_mode
argument_list|,
name|binoptab
argument_list|,
name|xop0
argument_list|,
name|xop1
argument_list|,
name|NULL_RTX
argument_list|,
name|unsignedp
argument_list|,
name|OPTAB_DIRECT
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
condition|)
block|{
if|if
condition|(
name|class
operator|!=
name|MODE_INT
condition|)
block|{
if|if
condition|(
name|target
operator|==
literal|0
condition|)
name|target
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|convert_move
argument_list|(
name|target
argument_list|,
name|temp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|target
return|;
block|}
else|else
return|return
name|gen_lowpart
argument_list|(
name|mode
argument_list|,
name|temp
argument_list|)
return|;
block|}
else|else
name|delete_insns_since
argument_list|(
name|last
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* These can be done a word at a time.  */
if|if
condition|(
operator|(
name|binoptab
operator|==
name|and_optab
operator|||
name|binoptab
operator|==
name|ior_optab
operator|||
name|binoptab
operator|==
name|xor_optab
operator|)
operator|&&
name|class
operator|==
name|MODE_INT
operator|&&
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|>
name|UNITS_PER_WORD
operator|&&
name|binoptab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|word_mode
index|]
operator|.
name|insn_code
operator|!=
name|CODE_FOR_nothing
condition|)
block|{
name|int
name|i
decl_stmt|;
name|rtx
name|insns
decl_stmt|;
name|rtx
name|equiv_value
decl_stmt|;
comment|/* If TARGET is the same as one of the operands, the REG_EQUAL note 	 won't be accurate, so use a new target.  */
if|if
condition|(
name|target
operator|==
literal|0
operator|||
name|target
operator|==
name|op0
operator|||
name|target
operator|==
name|op1
condition|)
name|target
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|start_sequence
argument_list|()
expr_stmt|;
comment|/* Do the actual arithmetic.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|/
name|BITS_PER_WORD
condition|;
name|i
operator|++
control|)
block|{
name|rtx
name|target_piece
init|=
name|operand_subword
argument_list|(
name|target
argument_list|,
name|i
argument_list|,
literal|1
argument_list|,
name|mode
argument_list|)
decl_stmt|;
name|rtx
name|x
init|=
name|expand_binop
argument_list|(
name|word_mode
argument_list|,
name|binoptab
argument_list|,
name|operand_subword_force
argument_list|(
name|op0
argument_list|,
name|i
argument_list|,
name|mode
argument_list|)
argument_list|,
name|operand_subword_force
argument_list|(
name|op1
argument_list|,
name|i
argument_list|,
name|mode
argument_list|)
argument_list|,
name|target_piece
argument_list|,
name|unsignedp
argument_list|,
name|methods
argument_list|)
decl_stmt|;
if|if
condition|(
name|target_piece
operator|!=
name|x
condition|)
name|emit_move_insn
argument_list|(
name|target_piece
argument_list|,
name|x
argument_list|)
expr_stmt|;
block|}
name|insns
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
if|if
condition|(
name|binoptab
operator|->
name|code
operator|!=
name|UNKNOWN
condition|)
name|equiv_value
operator|=
name|gen_rtx
argument_list|(
name|binoptab
operator|->
name|code
argument_list|,
name|mode
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
expr_stmt|;
else|else
name|equiv_value
operator|=
literal|0
expr_stmt|;
name|emit_no_conflict_block
argument_list|(
name|insns
argument_list|,
name|target
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|,
name|equiv_value
argument_list|)
expr_stmt|;
return|return
name|target
return|;
block|}
comment|/* These can be done a word at a time by propagating carries.  */
if|if
condition|(
operator|(
name|binoptab
operator|==
name|add_optab
operator|||
name|binoptab
operator|==
name|sub_optab
operator|)
operator|&&
name|class
operator|==
name|MODE_INT
operator|&&
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|>=
literal|2
operator|*
name|UNITS_PER_WORD
operator|&&
name|binoptab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|word_mode
index|]
operator|.
name|insn_code
operator|!=
name|CODE_FOR_nothing
condition|)
block|{
name|int
name|i
decl_stmt|;
name|rtx
name|carry_tmp
init|=
name|gen_reg_rtx
argument_list|(
name|word_mode
argument_list|)
decl_stmt|;
name|optab
name|otheroptab
init|=
name|binoptab
operator|==
name|add_optab
condition|?
name|sub_optab
else|:
name|add_optab
decl_stmt|;
name|int
name|nwords
init|=
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|/
name|BITS_PER_WORD
decl_stmt|;
name|rtx
name|carry_in
decl_stmt|,
name|carry_out
decl_stmt|;
name|rtx
name|xop0
decl_stmt|,
name|xop1
decl_stmt|;
comment|/* We can handle either a 1 or -1 value for the carry.  If STORE_FLAG 	 value is one of those, use it.  Otherwise, use 1 since it is the 	 one easiest to get.  */
if|#
directive|if
name|STORE_FLAG_VALUE
operator|==
literal|1
operator|||
name|STORE_FLAG_VALUE
operator|==
operator|-
literal|1
name|int
name|normalizep
init|=
name|STORE_FLAG_VALUE
decl_stmt|;
else|#
directive|else
name|int
name|normalizep
init|=
literal|1
decl_stmt|;
endif|#
directive|endif
comment|/* Prepare the operands.  */
name|xop0
operator|=
name|force_reg
argument_list|(
name|mode
argument_list|,
name|op0
argument_list|)
expr_stmt|;
name|xop1
operator|=
name|force_reg
argument_list|(
name|mode
argument_list|,
name|op1
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
operator|==
literal|0
operator|||
name|GET_CODE
argument_list|(
name|target
argument_list|)
operator|!=
name|REG
operator|||
name|target
operator|==
name|xop0
operator|||
name|target
operator|==
name|xop1
condition|)
name|target
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
comment|/* Do the actual arithmetic.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nwords
condition|;
name|i
operator|++
control|)
block|{
name|int
name|index
init|=
operator|(
name|WORDS_BIG_ENDIAN
condition|?
name|nwords
operator|-
name|i
operator|-
literal|1
else|:
name|i
operator|)
decl_stmt|;
name|rtx
name|target_piece
init|=
name|operand_subword
argument_list|(
name|target
argument_list|,
name|index
argument_list|,
literal|1
argument_list|,
name|mode
argument_list|)
decl_stmt|;
name|rtx
name|op0_piece
init|=
name|operand_subword_force
argument_list|(
name|xop0
argument_list|,
name|index
argument_list|,
name|mode
argument_list|)
decl_stmt|;
name|rtx
name|op1_piece
init|=
name|operand_subword_force
argument_list|(
name|xop1
argument_list|,
name|index
argument_list|,
name|mode
argument_list|)
decl_stmt|;
name|rtx
name|x
decl_stmt|;
comment|/* Main add/subtract of the input operands.  */
name|x
operator|=
name|expand_binop
argument_list|(
name|word_mode
argument_list|,
name|binoptab
argument_list|,
name|op0_piece
argument_list|,
name|op1_piece
argument_list|,
name|target_piece
argument_list|,
name|unsignedp
argument_list|,
name|methods
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|i
operator|+
literal|1
operator|<
name|nwords
condition|)
block|{
comment|/* Store carry from main add/subtract.  */
name|carry_out
operator|=
name|gen_reg_rtx
argument_list|(
name|word_mode
argument_list|)
expr_stmt|;
name|carry_out
operator|=
name|emit_store_flag
argument_list|(
name|carry_out
argument_list|,
name|binoptab
operator|==
name|add_optab
condition|?
name|LTU
else|:
name|GTU
argument_list|,
name|x
argument_list|,
name|op0_piece
argument_list|,
name|word_mode
argument_list|,
literal|1
argument_list|,
name|normalizep
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|carry_out
condition|)
break|break;
block|}
if|if
condition|(
name|i
operator|>
literal|0
condition|)
block|{
comment|/* Add/subtract previous carry to main result.  */
name|x
operator|=
name|expand_binop
argument_list|(
name|word_mode
argument_list|,
name|normalizep
operator|==
literal|1
condition|?
name|binoptab
else|:
name|otheroptab
argument_list|,
name|x
argument_list|,
name|carry_in
argument_list|,
name|target_piece
argument_list|,
literal|1
argument_list|,
name|methods
argument_list|)
expr_stmt|;
if|if
condition|(
name|target_piece
operator|!=
name|x
condition|)
name|emit_move_insn
argument_list|(
name|target_piece
argument_list|,
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|+
literal|1
operator|<
name|nwords
condition|)
block|{
comment|/* THIS CODE HAS NOT BEEN TESTED.  */
comment|/* Get out carry from adding/subtracting carry in.  */
name|carry_tmp
operator|=
name|emit_store_flag
argument_list|(
name|carry_tmp
argument_list|,
name|binoptab
operator|==
name|add_optab
condition|?
name|LTU
else|:
name|GTU
argument_list|,
name|x
argument_list|,
name|carry_in
argument_list|,
name|word_mode
argument_list|,
literal|1
argument_list|,
name|normalizep
argument_list|)
expr_stmt|;
comment|/* Logical-ior the two poss. carry together.  */
name|carry_out
operator|=
name|expand_binop
argument_list|(
name|word_mode
argument_list|,
name|ior_optab
argument_list|,
name|carry_out
argument_list|,
name|carry_tmp
argument_list|,
name|carry_out
argument_list|,
literal|0
argument_list|,
name|methods
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|carry_out
condition|)
break|break;
block|}
block|}
name|carry_in
operator|=
name|carry_out
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|==
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|/
name|BITS_PER_WORD
condition|)
block|{
name|rtx
name|temp
decl_stmt|;
name|temp
operator|=
name|emit_move_insn
argument_list|(
name|target
argument_list|,
name|target
argument_list|)
expr_stmt|;
name|REG_NOTES
argument_list|(
name|temp
argument_list|)
operator|=
name|gen_rtx
argument_list|(
name|EXPR_LIST
argument_list|,
name|REG_EQUAL
argument_list|,
name|gen_rtx
argument_list|(
name|binoptab
operator|->
name|code
argument_list|,
name|mode
argument_list|,
name|xop0
argument_list|,
name|xop1
argument_list|)
argument_list|,
name|REG_NOTES
argument_list|(
name|temp
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|target
return|;
block|}
else|else
name|delete_insns_since
argument_list|(
name|last
argument_list|)
expr_stmt|;
block|}
comment|/* If we want to multiply two two-word values and have normal and widening      multiplies of single-word values, we can do this with three smaller      multiplications.  Note that we do not make a REG_NO_CONFLICT block here      because we are not operating on one word at a time.        The multiplication proceeds as follows: 			         _______________________ 			        [__op0_high_|__op0_low__] 			         _______________________         *			    [__op1_high_|__op1_low__]         _______________________________________________ 			         _______________________     (1)			    [__op0_low__*__op1_low__] 		     _______________________     (2a)		[__op0_low__*__op1_high_] 		     _______________________     (2b)		[__op0_high_*__op1_low__]          _______________________     (3) [__op0_high_*__op1_high_]       This gives a 4-word result.  Since we are only interested in the     lower 2 words, partial result (3) and the upper words of (2a) and     (2b) don't need to be calculated.  Hence (2a) and (2b) can be     calculated using non-widening multiplication.      (1), however, needs to be calculated with an unsigned widening     multiplication.  If this operation is not directly supported we     try using a signed widening multiplication and adjust the result.     This adjustment works as follows:        If both operands are positive then no adjustment is needed.        If the operands have different signs, for example op0_low< 0 and       op1_low>= 0, the instruction treats the most significant bit of       op0_low as a sign bit instead of a bit with significance       2**(BITS_PER_WORD-1), i.e. the instruction multiplies op1_low       with 2**BITS_PER_WORD - op0_low, and two's complements the       result.  Conclusion: We need to add op1_low * 2**BITS_PER_WORD to       the result.        Similarly, if both operands are negative, we need to add       (op0_low + op1_low) * 2**BITS_PER_WORD.        We use a trick to adjust quickly.  We logically shift op0_low right       (op1_low) BITS_PER_WORD-1 steps to get 0 or 1, and add this to       op0_high (op1_high) before it is used to calculate 2b (2a).  If no       logical shift exists, we do an arithmetic right shift and subtract       the 0 or -1.  */
if|if
condition|(
name|binoptab
operator|==
name|smul_optab
operator|&&
name|class
operator|==
name|MODE_INT
operator|&&
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|==
literal|2
operator|*
name|UNITS_PER_WORD
operator|&&
name|smul_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|word_mode
index|]
operator|.
name|insn_code
operator|!=
name|CODE_FOR_nothing
operator|&&
name|add_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|word_mode
index|]
operator|.
name|insn_code
operator|!=
name|CODE_FOR_nothing
operator|&&
operator|(
operator|(
name|umul_widen_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|mode
index|]
operator|.
name|insn_code
operator|!=
name|CODE_FOR_nothing
operator|)
operator|||
operator|(
name|smul_widen_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|mode
index|]
operator|.
name|insn_code
operator|!=
name|CODE_FOR_nothing
operator|)
operator|)
condition|)
block|{
name|int
name|low
init|=
operator|(
name|WORDS_BIG_ENDIAN
condition|?
literal|1
else|:
literal|0
operator|)
decl_stmt|;
name|int
name|high
init|=
operator|(
name|WORDS_BIG_ENDIAN
condition|?
literal|0
else|:
literal|1
operator|)
decl_stmt|;
name|rtx
name|op0_high
init|=
name|operand_subword_force
argument_list|(
name|op0
argument_list|,
name|high
argument_list|,
name|mode
argument_list|)
decl_stmt|;
name|rtx
name|op0_low
init|=
name|operand_subword_force
argument_list|(
name|op0
argument_list|,
name|low
argument_list|,
name|mode
argument_list|)
decl_stmt|;
name|rtx
name|op1_high
init|=
name|operand_subword_force
argument_list|(
name|op1
argument_list|,
name|high
argument_list|,
name|mode
argument_list|)
decl_stmt|;
name|rtx
name|op1_low
init|=
name|operand_subword_force
argument_list|(
name|op1
argument_list|,
name|low
argument_list|,
name|mode
argument_list|)
decl_stmt|;
name|rtx
name|product
init|=
literal|0
decl_stmt|;
name|rtx
name|op0_xhigh
decl_stmt|;
name|rtx
name|op1_xhigh
decl_stmt|;
comment|/* If the target is the same as one of the inputs, don't use it.  This 	 prevents problems with the REG_EQUAL note.  */
if|if
condition|(
name|target
operator|==
name|op0
operator|||
name|target
operator|==
name|op1
condition|)
name|target
operator|=
literal|0
expr_stmt|;
comment|/* Multiply the two lower words to get a double-word product. 	 If unsigned widening multiplication is available, use that; 	 otherwise use the signed form and compensate.  */
if|if
condition|(
name|umul_widen_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|mode
index|]
operator|.
name|insn_code
operator|!=
name|CODE_FOR_nothing
condition|)
block|{
name|product
operator|=
name|expand_binop
argument_list|(
name|mode
argument_list|,
name|umul_widen_optab
argument_list|,
name|op0_low
argument_list|,
name|op1_low
argument_list|,
name|target
argument_list|,
literal|1
argument_list|,
name|OPTAB_DIRECT
argument_list|)
expr_stmt|;
comment|/* If we didn't succeed, delete everything we did so far.  */
if|if
condition|(
name|product
operator|==
literal|0
condition|)
name|delete_insns_since
argument_list|(
name|last
argument_list|)
expr_stmt|;
else|else
name|op0_xhigh
operator|=
name|op0_high
operator|,
name|op1_xhigh
operator|=
name|op1_high
expr_stmt|;
block|}
if|if
condition|(
name|product
operator|==
literal|0
operator|&&
name|smul_widen_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|mode
index|]
operator|.
name|insn_code
operator|!=
name|CODE_FOR_nothing
condition|)
block|{
name|rtx
name|wordm1
init|=
name|GEN_INT
argument_list|(
name|BITS_PER_WORD
operator|-
literal|1
argument_list|)
decl_stmt|;
name|product
operator|=
name|expand_binop
argument_list|(
name|mode
argument_list|,
name|smul_widen_optab
argument_list|,
name|op0_low
argument_list|,
name|op1_low
argument_list|,
name|target
argument_list|,
literal|1
argument_list|,
name|OPTAB_DIRECT
argument_list|)
expr_stmt|;
name|op0_xhigh
operator|=
name|expand_binop
argument_list|(
name|word_mode
argument_list|,
name|lshr_optab
argument_list|,
name|op0_low
argument_list|,
name|wordm1
argument_list|,
name|NULL_RTX
argument_list|,
literal|1
argument_list|,
name|OPTAB_DIRECT
argument_list|)
expr_stmt|;
if|if
condition|(
name|op0_xhigh
condition|)
name|op0_xhigh
operator|=
name|expand_binop
argument_list|(
name|word_mode
argument_list|,
name|add_optab
argument_list|,
name|op0_high
argument_list|,
name|op0_xhigh
argument_list|,
name|op0_xhigh
argument_list|,
literal|0
argument_list|,
name|OPTAB_DIRECT
argument_list|)
expr_stmt|;
else|else
block|{
name|op0_xhigh
operator|=
name|expand_binop
argument_list|(
name|word_mode
argument_list|,
name|ashr_optab
argument_list|,
name|op0_low
argument_list|,
name|wordm1
argument_list|,
name|NULL_RTX
argument_list|,
literal|0
argument_list|,
name|OPTAB_DIRECT
argument_list|)
expr_stmt|;
if|if
condition|(
name|op0_xhigh
condition|)
name|op0_xhigh
operator|=
name|expand_binop
argument_list|(
name|word_mode
argument_list|,
name|sub_optab
argument_list|,
name|op0_high
argument_list|,
name|op0_xhigh
argument_list|,
name|op0_xhigh
argument_list|,
literal|0
argument_list|,
name|OPTAB_DIRECT
argument_list|)
expr_stmt|;
block|}
name|op1_xhigh
operator|=
name|expand_binop
argument_list|(
name|word_mode
argument_list|,
name|lshr_optab
argument_list|,
name|op1_low
argument_list|,
name|wordm1
argument_list|,
name|NULL_RTX
argument_list|,
literal|1
argument_list|,
name|OPTAB_DIRECT
argument_list|)
expr_stmt|;
if|if
condition|(
name|op1_xhigh
condition|)
name|op1_xhigh
operator|=
name|expand_binop
argument_list|(
name|word_mode
argument_list|,
name|add_optab
argument_list|,
name|op1_high
argument_list|,
name|op1_xhigh
argument_list|,
name|op1_xhigh
argument_list|,
literal|0
argument_list|,
name|OPTAB_DIRECT
argument_list|)
expr_stmt|;
else|else
block|{
name|op1_xhigh
operator|=
name|expand_binop
argument_list|(
name|word_mode
argument_list|,
name|ashr_optab
argument_list|,
name|op1_low
argument_list|,
name|wordm1
argument_list|,
name|NULL_RTX
argument_list|,
literal|0
argument_list|,
name|OPTAB_DIRECT
argument_list|)
expr_stmt|;
if|if
condition|(
name|op1_xhigh
condition|)
name|op1_xhigh
operator|=
name|expand_binop
argument_list|(
name|word_mode
argument_list|,
name|sub_optab
argument_list|,
name|op1_high
argument_list|,
name|op1_xhigh
argument_list|,
name|op1_xhigh
argument_list|,
literal|0
argument_list|,
name|OPTAB_DIRECT
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* If we have been able to directly compute the product of the 	 low-order words of the operands and perform any required adjustments 	 of the operands, we proceed by trying two more multiplications 	 and then computing the appropriate sum.  	 We have checked above that the required addition is provided. 	 Full-word addition will normally always succeed, especially if 	 it is provided at all, so we don't worry about its failure.  The 	 multiplication may well fail, however, so we do handle that.  */
if|if
condition|(
name|product
operator|&&
name|op0_xhigh
operator|&&
name|op1_xhigh
condition|)
block|{
name|rtx
name|product_piece
decl_stmt|;
name|rtx
name|product_high
init|=
name|operand_subword
argument_list|(
name|product
argument_list|,
name|high
argument_list|,
literal|1
argument_list|,
name|mode
argument_list|)
decl_stmt|;
name|rtx
name|temp
init|=
name|expand_binop
argument_list|(
name|word_mode
argument_list|,
name|binoptab
argument_list|,
name|op0_low
argument_list|,
name|op1_xhigh
argument_list|,
name|NULL_RTX
argument_list|,
literal|0
argument_list|,
name|OPTAB_DIRECT
argument_list|)
decl_stmt|;
if|if
condition|(
name|temp
condition|)
block|{
name|product_piece
operator|=
name|expand_binop
argument_list|(
name|word_mode
argument_list|,
name|add_optab
argument_list|,
name|temp
argument_list|,
name|product_high
argument_list|,
name|product_high
argument_list|,
literal|0
argument_list|,
name|OPTAB_LIB_WIDEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|product_piece
operator|!=
name|product_high
condition|)
name|emit_move_insn
argument_list|(
name|product_high
argument_list|,
name|product_piece
argument_list|)
expr_stmt|;
name|temp
operator|=
name|expand_binop
argument_list|(
name|word_mode
argument_list|,
name|binoptab
argument_list|,
name|op1_low
argument_list|,
name|op0_xhigh
argument_list|,
name|NULL_RTX
argument_list|,
literal|0
argument_list|,
name|OPTAB_DIRECT
argument_list|)
expr_stmt|;
name|product_piece
operator|=
name|expand_binop
argument_list|(
name|word_mode
argument_list|,
name|add_optab
argument_list|,
name|temp
argument_list|,
name|product_high
argument_list|,
name|product_high
argument_list|,
literal|0
argument_list|,
name|OPTAB_LIB_WIDEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|product_piece
operator|!=
name|product_high
condition|)
name|emit_move_insn
argument_list|(
name|product_high
argument_list|,
name|product_piece
argument_list|)
expr_stmt|;
name|temp
operator|=
name|emit_move_insn
argument_list|(
name|product
argument_list|,
name|product
argument_list|)
expr_stmt|;
name|REG_NOTES
argument_list|(
name|temp
argument_list|)
operator|=
name|gen_rtx
argument_list|(
name|EXPR_LIST
argument_list|,
name|REG_EQUAL
argument_list|,
name|gen_rtx
argument_list|(
name|MULT
argument_list|,
name|mode
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
argument_list|,
name|REG_NOTES
argument_list|(
name|temp
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|product
return|;
block|}
block|}
comment|/* If we get here, we couldn't do it for some reason even though we 	 originally thought we could.  Delete anything we've emitted in 	 trying to do it.  */
name|delete_insns_since
argument_list|(
name|last
argument_list|)
expr_stmt|;
block|}
comment|/* We need to open-code the complex type operations: '+, -, * and /' */
comment|/* At this point we allow operations between two similar complex      numbers, and also if one of the operands is not a complex number      but rather of MODE_FLOAT or MODE_INT. However, the caller      must make sure that the MODE of the non-complex operand matches      the SUBMODE of the complex operand.  */
if|if
condition|(
name|class
operator|==
name|MODE_COMPLEX_FLOAT
operator|||
name|class
operator|==
name|MODE_COMPLEX_INT
condition|)
block|{
name|rtx
name|real0
init|=
operator|(
name|rtx
operator|)
literal|0
decl_stmt|;
name|rtx
name|imag0
init|=
operator|(
name|rtx
operator|)
literal|0
decl_stmt|;
name|rtx
name|real1
init|=
operator|(
name|rtx
operator|)
literal|0
decl_stmt|;
name|rtx
name|imag1
init|=
operator|(
name|rtx
operator|)
literal|0
decl_stmt|;
name|rtx
name|realr
decl_stmt|;
name|rtx
name|imagr
decl_stmt|;
name|rtx
name|res
decl_stmt|;
name|rtx
name|seq
decl_stmt|;
name|rtx
name|equiv_value
decl_stmt|;
comment|/* Find the correct mode for the real and imaginary parts */
name|enum
name|machine_mode
name|submode
init|=
name|mode_for_size
argument_list|(
name|GET_MODE_UNIT_SIZE
argument_list|(
name|mode
argument_list|)
operator|*
name|BITS_PER_UNIT
argument_list|,
name|class
operator|==
name|MODE_COMPLEX_INT
condition|?
name|MODE_INT
else|:
name|MODE_FLOAT
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|submode
operator|==
name|BLKmode
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|target
condition|)
name|target
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|start_sequence
argument_list|()
expr_stmt|;
name|realr
operator|=
name|gen_realpart
argument_list|(
name|submode
argument_list|,
name|target
argument_list|)
expr_stmt|;
name|imagr
operator|=
name|gen_imagpart
argument_list|(
name|submode
argument_list|,
name|target
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|op0
argument_list|)
operator|==
name|mode
condition|)
block|{
name|real0
operator|=
name|gen_realpart
argument_list|(
name|submode
argument_list|,
name|op0
argument_list|)
expr_stmt|;
name|imag0
operator|=
name|gen_imagpart
argument_list|(
name|submode
argument_list|,
name|op0
argument_list|)
expr_stmt|;
block|}
else|else
name|real0
operator|=
name|op0
expr_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|op1
argument_list|)
operator|==
name|mode
condition|)
block|{
name|real1
operator|=
name|gen_realpart
argument_list|(
name|submode
argument_list|,
name|op1
argument_list|)
expr_stmt|;
name|imag1
operator|=
name|gen_imagpart
argument_list|(
name|submode
argument_list|,
name|op1
argument_list|)
expr_stmt|;
block|}
else|else
name|real1
operator|=
name|op1
expr_stmt|;
if|if
condition|(
operator|!
name|real0
operator|||
operator|!
name|real1
operator|||
operator|!
operator|(
name|imag0
operator|||
name|imag1
operator|)
condition|)
name|abort
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|binoptab
operator|->
name|code
condition|)
block|{
case|case
name|PLUS
case|:
case|case
name|MINUS
case|:
name|res
operator|=
name|expand_binop
argument_list|(
name|submode
argument_list|,
name|binoptab
argument_list|,
name|real0
argument_list|,
name|real1
argument_list|,
name|realr
argument_list|,
name|unsignedp
argument_list|,
name|methods
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|!=
name|realr
condition|)
name|emit_move_insn
argument_list|(
name|realr
argument_list|,
name|res
argument_list|)
expr_stmt|;
if|if
condition|(
name|imag0
operator|&&
name|imag1
condition|)
name|res
operator|=
name|expand_binop
argument_list|(
name|submode
argument_list|,
name|binoptab
argument_list|,
name|imag0
argument_list|,
name|imag1
argument_list|,
name|imagr
argument_list|,
name|unsignedp
argument_list|,
name|methods
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|imag0
condition|)
name|res
operator|=
name|imag0
expr_stmt|;
elseif|else
if|if
condition|(
name|binoptab
operator|->
name|code
operator|==
name|MINUS
condition|)
name|res
operator|=
name|expand_unop
argument_list|(
name|submode
argument_list|,
name|neg_optab
argument_list|,
name|imag1
argument_list|,
name|imagr
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
else|else
name|res
operator|=
name|imag1
expr_stmt|;
if|if
condition|(
name|res
operator|!=
name|imagr
condition|)
name|emit_move_insn
argument_list|(
name|imagr
argument_list|,
name|res
argument_list|)
expr_stmt|;
break|break;
case|case
name|MULT
case|:
comment|/* (a+ib) * (c+id) = (ac-bd) + i(ad+cb) */
name|res
operator|=
name|expand_binop
argument_list|(
name|submode
argument_list|,
name|binoptab
argument_list|,
name|real0
argument_list|,
name|real1
argument_list|,
name|realr
argument_list|,
name|unsignedp
argument_list|,
name|methods
argument_list|)
expr_stmt|;
if|if
condition|(
name|imag0
operator|&&
name|imag1
condition|)
block|{
name|rtx
name|temp
init|=
name|expand_binop
argument_list|(
name|submode
argument_list|,
name|sub_optab
argument_list|,
name|res
argument_list|,
name|expand_binop
argument_list|(
name|submode
argument_list|,
name|binoptab
argument_list|,
name|imag0
argument_list|,
name|imag1
argument_list|,
literal|0
argument_list|,
name|unsignedp
argument_list|,
name|methods
argument_list|)
argument_list|,
name|realr
argument_list|,
name|unsignedp
argument_list|,
name|methods
argument_list|)
decl_stmt|;
if|if
condition|(
name|temp
operator|!=
name|realr
condition|)
name|emit_move_insn
argument_list|(
name|realr
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|res
operator|=
name|expand_binop
argument_list|(
name|submode
argument_list|,
name|add_optab
argument_list|,
name|expand_binop
argument_list|(
name|submode
argument_list|,
name|binoptab
argument_list|,
name|real0
argument_list|,
name|imag1
argument_list|,
literal|0
argument_list|,
name|unsignedp
argument_list|,
name|methods
argument_list|)
argument_list|,
name|expand_binop
argument_list|(
name|submode
argument_list|,
name|binoptab
argument_list|,
name|real1
argument_list|,
name|imag0
argument_list|,
literal|0
argument_list|,
name|unsignedp
argument_list|,
name|methods
argument_list|)
argument_list|,
name|imagr
argument_list|,
name|unsignedp
argument_list|,
name|methods
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|!=
name|imagr
condition|)
name|emit_move_insn
argument_list|(
name|imagr
argument_list|,
name|res
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|res
operator|!=
name|realr
condition|)
name|emit_move_insn
argument_list|(
name|realr
argument_list|,
name|res
argument_list|)
expr_stmt|;
if|if
condition|(
name|imag0
condition|)
name|res
operator|=
name|expand_binop
argument_list|(
name|submode
argument_list|,
name|binoptab
argument_list|,
name|real1
argument_list|,
name|imag0
argument_list|,
name|imagr
argument_list|,
name|unsignedp
argument_list|,
name|methods
argument_list|)
expr_stmt|;
else|else
name|res
operator|=
name|expand_binop
argument_list|(
name|submode
argument_list|,
name|binoptab
argument_list|,
name|real0
argument_list|,
name|imag1
argument_list|,
name|imagr
argument_list|,
name|unsignedp
argument_list|,
name|methods
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|!=
name|imagr
condition|)
name|emit_move_insn
argument_list|(
name|imagr
argument_list|,
name|res
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|DIV
case|:
comment|/* (c+id)/(a+ib) == ((c+id)*(a-ib))/(a*a+b*b) */
if|if
condition|(
operator|!
name|imag1
condition|)
block|{
comment|/* Simply divide the real and imaginary parts by `a' */
name|res
operator|=
name|expand_binop
argument_list|(
name|submode
argument_list|,
name|binoptab
argument_list|,
name|real0
argument_list|,
name|real1
argument_list|,
name|realr
argument_list|,
name|unsignedp
argument_list|,
name|methods
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|!=
name|realr
condition|)
name|emit_move_insn
argument_list|(
name|realr
argument_list|,
name|res
argument_list|)
expr_stmt|;
name|res
operator|=
name|expand_binop
argument_list|(
name|submode
argument_list|,
name|binoptab
argument_list|,
name|imag0
argument_list|,
name|real1
argument_list|,
name|imagr
argument_list|,
name|unsignedp
argument_list|,
name|methods
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|!=
name|imagr
condition|)
name|emit_move_insn
argument_list|(
name|imagr
argument_list|,
name|res
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* Divisor is of complex type */
block|{
comment|/* X/(a+ib) */
name|rtx
name|divisor
decl_stmt|;
name|rtx
name|real_t
decl_stmt|;
name|rtx
name|imag_t
decl_stmt|;
name|optab
name|mulopt
init|=
name|unsignedp
condition|?
name|umul_widen_optab
else|:
name|smul_optab
decl_stmt|;
comment|/* Divisor: c*c + d*d */
name|divisor
operator|=
name|expand_binop
argument_list|(
name|submode
argument_list|,
name|add_optab
argument_list|,
name|expand_binop
argument_list|(
name|submode
argument_list|,
name|mulopt
argument_list|,
name|real1
argument_list|,
name|real1
argument_list|,
literal|0
argument_list|,
name|unsignedp
argument_list|,
name|methods
argument_list|)
argument_list|,
name|expand_binop
argument_list|(
name|submode
argument_list|,
name|mulopt
argument_list|,
name|imag1
argument_list|,
name|imag1
argument_list|,
literal|0
argument_list|,
name|unsignedp
argument_list|,
name|methods
argument_list|)
argument_list|,
literal|0
argument_list|,
name|unsignedp
argument_list|,
name|methods
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|imag0
condition|)
comment|/* ((a)(c-id))/divisor */
block|{
comment|/* (a+i0) / (c+id) = (ac/(cc+dd)) + i(-ad/(cc+dd)) */
comment|/* Calculate the dividend */
name|real_t
operator|=
name|expand_binop
argument_list|(
name|submode
argument_list|,
name|mulopt
argument_list|,
name|real0
argument_list|,
name|real1
argument_list|,
literal|0
argument_list|,
name|unsignedp
argument_list|,
name|methods
argument_list|)
expr_stmt|;
name|imag_t
operator|=
name|expand_unop
argument_list|(
name|submode
argument_list|,
name|neg_optab
argument_list|,
name|expand_binop
argument_list|(
name|submode
argument_list|,
name|mulopt
argument_list|,
name|real0
argument_list|,
name|imag1
argument_list|,
literal|0
argument_list|,
name|unsignedp
argument_list|,
name|methods
argument_list|)
argument_list|,
literal|0
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* ((a+ib)(c-id))/divider */
block|{
comment|/* Calculate the dividend */
name|real_t
operator|=
name|expand_binop
argument_list|(
name|submode
argument_list|,
name|add_optab
argument_list|,
name|expand_binop
argument_list|(
name|submode
argument_list|,
name|mulopt
argument_list|,
name|real0
argument_list|,
name|real1
argument_list|,
literal|0
argument_list|,
name|unsignedp
argument_list|,
name|methods
argument_list|)
argument_list|,
name|expand_binop
argument_list|(
name|submode
argument_list|,
name|mulopt
argument_list|,
name|imag0
argument_list|,
name|imag1
argument_list|,
literal|0
argument_list|,
name|unsignedp
argument_list|,
name|methods
argument_list|)
argument_list|,
literal|0
argument_list|,
name|unsignedp
argument_list|,
name|methods
argument_list|)
expr_stmt|;
name|imag_t
operator|=
name|expand_binop
argument_list|(
name|submode
argument_list|,
name|sub_optab
argument_list|,
name|expand_binop
argument_list|(
name|submode
argument_list|,
name|mulopt
argument_list|,
name|imag0
argument_list|,
name|real1
argument_list|,
literal|0
argument_list|,
name|unsignedp
argument_list|,
name|methods
argument_list|)
argument_list|,
name|expand_binop
argument_list|(
name|submode
argument_list|,
name|mulopt
argument_list|,
name|real0
argument_list|,
name|imag1
argument_list|,
literal|0
argument_list|,
name|unsignedp
argument_list|,
name|methods
argument_list|)
argument_list|,
literal|0
argument_list|,
name|unsignedp
argument_list|,
name|methods
argument_list|)
expr_stmt|;
block|}
name|res
operator|=
name|expand_binop
argument_list|(
name|submode
argument_list|,
name|binoptab
argument_list|,
name|real_t
argument_list|,
name|divisor
argument_list|,
name|realr
argument_list|,
name|unsignedp
argument_list|,
name|methods
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|!=
name|realr
condition|)
name|emit_move_insn
argument_list|(
name|realr
argument_list|,
name|res
argument_list|)
expr_stmt|;
name|res
operator|=
name|expand_binop
argument_list|(
name|submode
argument_list|,
name|binoptab
argument_list|,
name|imag_t
argument_list|,
name|divisor
argument_list|,
name|imagr
argument_list|,
name|unsignedp
argument_list|,
name|methods
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|!=
name|imagr
condition|)
name|emit_move_insn
argument_list|(
name|imagr
argument_list|,
name|res
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
name|seq
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
if|if
condition|(
name|binoptab
operator|->
name|code
operator|!=
name|UNKNOWN
condition|)
name|equiv_value
operator|=
name|gen_rtx
argument_list|(
name|binoptab
operator|->
name|code
argument_list|,
name|mode
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
expr_stmt|;
else|else
name|equiv_value
operator|=
literal|0
expr_stmt|;
name|emit_no_conflict_block
argument_list|(
name|seq
argument_list|,
name|target
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|,
name|equiv_value
argument_list|)
expr_stmt|;
return|return
name|target
return|;
block|}
comment|/* It can't be open-coded in this mode.      Use a library call if one is available and caller says that's ok.  */
if|if
condition|(
name|binoptab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|mode
index|]
operator|.
name|libfunc
operator|&&
operator|(
name|methods
operator|==
name|OPTAB_LIB
operator|||
name|methods
operator|==
name|OPTAB_LIB_WIDEN
operator|)
condition|)
block|{
name|rtx
name|insns
decl_stmt|;
name|rtx
name|funexp
init|=
name|binoptab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|mode
index|]
operator|.
name|libfunc
decl_stmt|;
name|rtx
name|op1x
init|=
name|op1
decl_stmt|;
name|enum
name|machine_mode
name|op1_mode
init|=
name|mode
decl_stmt|;
name|start_sequence
argument_list|()
expr_stmt|;
if|if
condition|(
name|shift_op
condition|)
block|{
name|op1_mode
operator|=
name|word_mode
expr_stmt|;
comment|/* Specify unsigned here, 	     since negative shift counts are meaningless.  */
name|op1x
operator|=
name|convert_to_mode
argument_list|(
name|word_mode
argument_list|,
name|op1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Pass 1 for NO_QUEUE so we don't lose any increments 	 if the libcall is cse'd or moved.  */
name|emit_library_call
argument_list|(
name|binoptab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|mode
index|]
operator|.
name|libfunc
argument_list|,
literal|1
argument_list|,
name|mode
argument_list|,
literal|2
argument_list|,
name|op0
argument_list|,
name|mode
argument_list|,
name|op1x
argument_list|,
name|op1_mode
argument_list|)
expr_stmt|;
name|insns
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
name|target
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|emit_libcall_block
argument_list|(
name|insns
argument_list|,
name|target
argument_list|,
name|hard_libcall_value
argument_list|(
name|mode
argument_list|)
argument_list|,
name|gen_rtx
argument_list|(
name|binoptab
operator|->
name|code
argument_list|,
name|mode
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|target
return|;
block|}
name|delete_insns_since
argument_list|(
name|last
argument_list|)
expr_stmt|;
comment|/* It can't be done in this mode.  Can we do it in a wider mode?  */
if|if
condition|(
operator|!
operator|(
name|methods
operator|==
name|OPTAB_WIDEN
operator|||
name|methods
operator|==
name|OPTAB_LIB_WIDEN
operator|||
name|methods
operator|==
name|OPTAB_MUST_WIDEN
operator|)
condition|)
block|{
comment|/* Caller says, don't even try.  */
name|delete_insns_since
argument_list|(
name|entry_last
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* Compute the value of METHODS to pass to recursive calls.      Don't allow widening to be tried recursively.  */
name|methods
operator|=
operator|(
name|methods
operator|==
name|OPTAB_LIB_WIDEN
condition|?
name|OPTAB_LIB
else|:
name|OPTAB_DIRECT
operator|)
expr_stmt|;
comment|/* Look for a wider mode of the same class for which it appears we can do      the operation.  */
if|if
condition|(
name|class
operator|==
name|MODE_INT
operator|||
name|class
operator|==
name|MODE_FLOAT
operator|||
name|class
operator|==
name|MODE_COMPLEX_FLOAT
condition|)
block|{
for|for
control|(
name|wider_mode
operator|=
name|GET_MODE_WIDER_MODE
argument_list|(
name|mode
argument_list|)
init|;
name|wider_mode
operator|!=
name|VOIDmode
condition|;
name|wider_mode
operator|=
name|GET_MODE_WIDER_MODE
argument_list|(
name|wider_mode
argument_list|)
control|)
block|{
if|if
condition|(
operator|(
name|binoptab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|wider_mode
index|]
operator|.
name|insn_code
operator|!=
name|CODE_FOR_nothing
operator|)
operator|||
operator|(
name|methods
operator|==
name|OPTAB_LIB
operator|&&
name|binoptab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|wider_mode
index|]
operator|.
name|libfunc
operator|)
condition|)
block|{
name|rtx
name|xop0
init|=
name|op0
decl_stmt|,
name|xop1
init|=
name|op1
decl_stmt|;
name|int
name|no_extend
init|=
literal|0
decl_stmt|;
comment|/* For certain integer operations, we need not actually extend 		 the narrow operands, as long as we will truncate 		 the results to the same narrowness.  Don't do this when 		 WIDER_MODE is wider than a word since a paradoxical SUBREG 		 isn't valid for such modes.  */
if|if
condition|(
operator|(
name|binoptab
operator|==
name|ior_optab
operator|||
name|binoptab
operator|==
name|and_optab
operator|||
name|binoptab
operator|==
name|xor_optab
operator|||
name|binoptab
operator|==
name|add_optab
operator|||
name|binoptab
operator|==
name|sub_optab
operator|||
name|binoptab
operator|==
name|smul_optab
operator|||
name|binoptab
operator|==
name|ashl_optab
operator|||
name|binoptab
operator|==
name|lshl_optab
operator|)
operator|&&
name|class
operator|==
name|MODE_INT
operator|&&
name|GET_MODE_SIZE
argument_list|(
name|wider_mode
argument_list|)
operator|<=
name|UNITS_PER_WORD
condition|)
name|no_extend
operator|=
literal|1
expr_stmt|;
comment|/* If an operand is a constant integer, we might as well 		 convert it since that is more efficient than using a SUBREG, 		 unlike the case for other operands.  Similarly for 		 SUBREGs that were made due to promoted objects.*/
if|if
condition|(
name|no_extend
operator|&&
name|GET_MODE
argument_list|(
name|xop0
argument_list|)
operator|!=
name|VOIDmode
operator|&&
operator|!
operator|(
name|GET_CODE
argument_list|(
name|xop0
argument_list|)
operator|==
name|SUBREG
operator|&&
name|SUBREG_PROMOTED_VAR_P
argument_list|(
name|xop0
argument_list|)
operator|)
condition|)
name|xop0
operator|=
name|gen_rtx
argument_list|(
name|SUBREG
argument_list|,
name|wider_mode
argument_list|,
name|force_reg
argument_list|(
name|GET_MODE
argument_list|(
name|xop0
argument_list|)
argument_list|,
name|xop0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|xop0
operator|=
name|convert_to_mode
argument_list|(
name|wider_mode
argument_list|,
name|xop0
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
if|if
condition|(
name|no_extend
operator|&&
name|GET_MODE
argument_list|(
name|xop1
argument_list|)
operator|!=
name|VOIDmode
operator|&&
operator|!
operator|(
name|GET_CODE
argument_list|(
name|xop1
argument_list|)
operator|==
name|SUBREG
operator|&&
name|SUBREG_PROMOTED_VAR_P
argument_list|(
name|xop1
argument_list|)
operator|)
condition|)
name|xop1
operator|=
name|gen_rtx
argument_list|(
name|SUBREG
argument_list|,
name|wider_mode
argument_list|,
name|force_reg
argument_list|(
name|GET_MODE
argument_list|(
name|xop1
argument_list|)
argument_list|,
name|xop1
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|xop1
operator|=
name|convert_to_mode
argument_list|(
name|wider_mode
argument_list|,
name|xop1
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
name|temp
operator|=
name|expand_binop
argument_list|(
name|wider_mode
argument_list|,
name|binoptab
argument_list|,
name|xop0
argument_list|,
name|xop1
argument_list|,
name|NULL_RTX
argument_list|,
name|unsignedp
argument_list|,
name|methods
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
condition|)
block|{
if|if
condition|(
name|class
operator|!=
name|MODE_INT
condition|)
block|{
if|if
condition|(
name|target
operator|==
literal|0
condition|)
name|target
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|convert_move
argument_list|(
name|target
argument_list|,
name|temp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|target
return|;
block|}
else|else
return|return
name|gen_lowpart
argument_list|(
name|mode
argument_list|,
name|temp
argument_list|)
return|;
block|}
else|else
name|delete_insns_since
argument_list|(
name|last
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|delete_insns_since
argument_list|(
name|entry_last
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Expand a binary operator which has both signed and unsigned forms.    UOPTAB is the optab for unsigned operations, and SOPTAB is for    signed operations.     If we widen unsigned operands, we may use a signed wider operation instead    of an unsigned wider operation, since the result would be the same.  */
end_comment

begin_function
name|rtx
name|sign_expand_binop
parameter_list|(
name|mode
parameter_list|,
name|uoptab
parameter_list|,
name|soptab
parameter_list|,
name|op0
parameter_list|,
name|op1
parameter_list|,
name|target
parameter_list|,
name|unsignedp
parameter_list|,
name|methods
parameter_list|)
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|optab
name|uoptab
decl_stmt|,
name|soptab
decl_stmt|;
name|rtx
name|op0
decl_stmt|,
name|op1
decl_stmt|,
name|target
decl_stmt|;
name|int
name|unsignedp
decl_stmt|;
name|enum
name|optab_methods
name|methods
decl_stmt|;
block|{
specifier|register
name|rtx
name|temp
decl_stmt|;
name|optab
name|direct_optab
init|=
name|unsignedp
condition|?
name|uoptab
else|:
name|soptab
decl_stmt|;
name|struct
name|optab
name|wide_soptab
decl_stmt|;
comment|/* Do it without widening, if possible.  */
name|temp
operator|=
name|expand_binop
argument_list|(
name|mode
argument_list|,
name|direct_optab
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|,
name|target
argument_list|,
name|unsignedp
argument_list|,
name|OPTAB_DIRECT
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|||
name|methods
operator|==
name|OPTAB_DIRECT
condition|)
return|return
name|temp
return|;
comment|/* Try widening to a signed int.  Make a fake signed optab that      hides any signed insn for direct use.  */
name|wide_soptab
operator|=
operator|*
name|soptab
expr_stmt|;
name|wide_soptab
operator|.
name|handlers
index|[
operator|(
name|int
operator|)
name|mode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_nothing
expr_stmt|;
name|wide_soptab
operator|.
name|handlers
index|[
operator|(
name|int
operator|)
name|mode
index|]
operator|.
name|libfunc
operator|=
literal|0
expr_stmt|;
name|temp
operator|=
name|expand_binop
argument_list|(
name|mode
argument_list|,
operator|&
name|wide_soptab
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|,
name|target
argument_list|,
name|unsignedp
argument_list|,
name|OPTAB_WIDEN
argument_list|)
expr_stmt|;
comment|/* For unsigned operands, try widening to an unsigned int.  */
if|if
condition|(
name|temp
operator|==
literal|0
operator|&&
name|unsignedp
condition|)
name|temp
operator|=
name|expand_binop
argument_list|(
name|mode
argument_list|,
name|uoptab
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|,
name|target
argument_list|,
name|unsignedp
argument_list|,
name|OPTAB_WIDEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|||
name|methods
operator|==
name|OPTAB_WIDEN
condition|)
return|return
name|temp
return|;
comment|/* Use the right width lib call if that exists.  */
name|temp
operator|=
name|expand_binop
argument_list|(
name|mode
argument_list|,
name|direct_optab
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|,
name|target
argument_list|,
name|unsignedp
argument_list|,
name|OPTAB_LIB
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|||
name|methods
operator|==
name|OPTAB_LIB
condition|)
return|return
name|temp
return|;
comment|/* Must widen and use a lib call, use either signed or unsigned.  */
name|temp
operator|=
name|expand_binop
argument_list|(
name|mode
argument_list|,
operator|&
name|wide_soptab
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|,
name|target
argument_list|,
name|unsignedp
argument_list|,
name|methods
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|!=
literal|0
condition|)
return|return
name|temp
return|;
if|if
condition|(
name|unsignedp
condition|)
return|return
name|expand_binop
argument_list|(
name|mode
argument_list|,
name|uoptab
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|,
name|target
argument_list|,
name|unsignedp
argument_list|,
name|methods
argument_list|)
return|;
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Generate code to perform an operation specified by BINOPTAB    on operands OP0 and OP1, with two results to TARG1 and TARG2.    We assume that the order of the operands for the instruction    is TARG0, OP0, OP1, TARG1, which would fit a pattern like    [(set TARG0 (operate OP0 OP1)) (set TARG1 (operate ...))].     Either TARG0 or TARG1 may be zero, but what that means is that    that result is not actually wanted.  We will generate it into    a dummy pseudo-reg and discard it.  They may not both be zero.     Returns 1 if this operation can be performed; 0 if not.  */
end_comment

begin_function
name|int
name|expand_twoval_binop
parameter_list|(
name|binoptab
parameter_list|,
name|op0
parameter_list|,
name|op1
parameter_list|,
name|targ0
parameter_list|,
name|targ1
parameter_list|,
name|unsignedp
parameter_list|)
name|optab
name|binoptab
decl_stmt|;
name|rtx
name|op0
decl_stmt|,
name|op1
decl_stmt|;
name|rtx
name|targ0
decl_stmt|,
name|targ1
decl_stmt|;
name|int
name|unsignedp
decl_stmt|;
block|{
name|enum
name|machine_mode
name|mode
init|=
name|GET_MODE
argument_list|(
name|targ0
condition|?
name|targ0
else|:
name|targ1
argument_list|)
decl_stmt|;
name|enum
name|mode_class
name|class
decl_stmt|;
name|enum
name|machine_mode
name|wider_mode
decl_stmt|;
name|rtx
name|entry_last
init|=
name|get_last_insn
argument_list|()
decl_stmt|;
name|rtx
name|last
decl_stmt|;
name|class
operator|=
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|op0
operator|=
name|protect_from_queue
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|op1
operator|=
name|protect_from_queue
argument_list|(
name|op1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_force_mem
condition|)
block|{
name|op0
operator|=
name|force_not_mem
argument_list|(
name|op0
argument_list|)
expr_stmt|;
name|op1
operator|=
name|force_not_mem
argument_list|(
name|op1
argument_list|)
expr_stmt|;
block|}
comment|/* If we are inside an appropriately-short loop and one operand is an      expensive constant, force it into a register.  */
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|op0
argument_list|)
operator|&&
name|preserve_subexpressions_p
argument_list|()
operator|&&
name|rtx_cost
argument_list|(
name|op0
argument_list|,
name|binoptab
operator|->
name|code
argument_list|)
operator|>
literal|2
condition|)
name|op0
operator|=
name|force_reg
argument_list|(
name|mode
argument_list|,
name|op0
argument_list|)
expr_stmt|;
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|op1
argument_list|)
operator|&&
name|preserve_subexpressions_p
argument_list|()
operator|&&
name|rtx_cost
argument_list|(
name|op1
argument_list|,
name|binoptab
operator|->
name|code
argument_list|)
operator|>
literal|2
condition|)
name|op1
operator|=
name|force_reg
argument_list|(
name|mode
argument_list|,
name|op1
argument_list|)
expr_stmt|;
if|if
condition|(
name|targ0
condition|)
name|targ0
operator|=
name|protect_from_queue
argument_list|(
name|targ0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
name|targ0
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|targ1
condition|)
name|targ1
operator|=
name|protect_from_queue
argument_list|(
name|targ1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
name|targ1
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
comment|/* Record where to go back to if we fail.  */
name|last
operator|=
name|get_last_insn
argument_list|()
expr_stmt|;
if|if
condition|(
name|binoptab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|mode
index|]
operator|.
name|insn_code
operator|!=
name|CODE_FOR_nothing
condition|)
block|{
name|int
name|icode
init|=
operator|(
name|int
operator|)
name|binoptab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|mode
index|]
operator|.
name|insn_code
decl_stmt|;
name|enum
name|machine_mode
name|mode0
init|=
name|insn_operand_mode
index|[
name|icode
index|]
index|[
literal|1
index|]
decl_stmt|;
name|enum
name|machine_mode
name|mode1
init|=
name|insn_operand_mode
index|[
name|icode
index|]
index|[
literal|2
index|]
decl_stmt|;
name|rtx
name|pat
decl_stmt|;
name|rtx
name|xop0
init|=
name|op0
decl_stmt|,
name|xop1
init|=
name|op1
decl_stmt|;
comment|/* In case this insn wants input operands in modes different from the 	 result, convert the operands.  */
if|if
condition|(
name|GET_MODE
argument_list|(
name|op0
argument_list|)
operator|!=
name|VOIDmode
operator|&&
name|GET_MODE
argument_list|(
name|op0
argument_list|)
operator|!=
name|mode0
condition|)
name|xop0
operator|=
name|convert_to_mode
argument_list|(
name|mode0
argument_list|,
name|xop0
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|op1
argument_list|)
operator|!=
name|VOIDmode
operator|&&
name|GET_MODE
argument_list|(
name|op1
argument_list|)
operator|!=
name|mode1
condition|)
name|xop1
operator|=
name|convert_to_mode
argument_list|(
name|mode1
argument_list|,
name|xop1
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
comment|/* Now, if insn doesn't accept these operands, put them into pseudos.  */
if|if
condition|(
operator|!
call|(
modifier|*
name|insn_operand_predicate
index|[
name|icode
index|]
index|[
literal|1
index|]
call|)
argument_list|(
name|xop0
argument_list|,
name|mode0
argument_list|)
condition|)
name|xop0
operator|=
name|copy_to_mode_reg
argument_list|(
name|mode0
argument_list|,
name|xop0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
call|(
modifier|*
name|insn_operand_predicate
index|[
name|icode
index|]
index|[
literal|2
index|]
call|)
argument_list|(
name|xop1
argument_list|,
name|mode1
argument_list|)
condition|)
name|xop1
operator|=
name|copy_to_mode_reg
argument_list|(
name|mode1
argument_list|,
name|xop1
argument_list|)
expr_stmt|;
comment|/* We could handle this, but we should always be called with a pseudo 	 for our targets and all insns should take them as outputs.  */
if|if
condition|(
operator|!
call|(
modifier|*
name|insn_operand_predicate
index|[
name|icode
index|]
index|[
literal|0
index|]
call|)
argument_list|(
name|targ0
argument_list|,
name|mode
argument_list|)
operator|||
operator|!
call|(
modifier|*
name|insn_operand_predicate
index|[
name|icode
index|]
index|[
literal|3
index|]
call|)
argument_list|(
name|targ1
argument_list|,
name|mode
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
name|pat
operator|=
name|GEN_FCN
argument_list|(
name|icode
argument_list|)
argument_list|(
name|targ0
argument_list|,
name|xop0
argument_list|,
name|xop1
argument_list|,
name|targ1
argument_list|)
expr_stmt|;
if|if
condition|(
name|pat
condition|)
block|{
name|emit_insn
argument_list|(
name|pat
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
else|else
name|delete_insns_since
argument_list|(
name|last
argument_list|)
expr_stmt|;
block|}
comment|/* It can't be done in this mode.  Can we do it in a wider mode?  */
if|if
condition|(
name|class
operator|==
name|MODE_INT
operator|||
name|class
operator|==
name|MODE_FLOAT
operator|||
name|class
operator|==
name|MODE_COMPLEX_FLOAT
condition|)
block|{
for|for
control|(
name|wider_mode
operator|=
name|GET_MODE_WIDER_MODE
argument_list|(
name|mode
argument_list|)
init|;
name|wider_mode
operator|!=
name|VOIDmode
condition|;
name|wider_mode
operator|=
name|GET_MODE_WIDER_MODE
argument_list|(
name|wider_mode
argument_list|)
control|)
block|{
if|if
condition|(
name|binoptab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|wider_mode
index|]
operator|.
name|insn_code
operator|!=
name|CODE_FOR_nothing
condition|)
block|{
specifier|register
name|rtx
name|t0
init|=
name|gen_reg_rtx
argument_list|(
name|wider_mode
argument_list|)
decl_stmt|;
specifier|register
name|rtx
name|t1
init|=
name|gen_reg_rtx
argument_list|(
name|wider_mode
argument_list|)
decl_stmt|;
if|if
condition|(
name|expand_twoval_binop
argument_list|(
name|binoptab
argument_list|,
name|convert_to_mode
argument_list|(
name|wider_mode
argument_list|,
name|op0
argument_list|,
name|unsignedp
argument_list|)
argument_list|,
name|convert_to_mode
argument_list|(
name|wider_mode
argument_list|,
name|op1
argument_list|,
name|unsignedp
argument_list|)
argument_list|,
name|t0
argument_list|,
name|t1
argument_list|,
name|unsignedp
argument_list|)
condition|)
block|{
name|convert_move
argument_list|(
name|targ0
argument_list|,
name|t0
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
name|convert_move
argument_list|(
name|targ1
argument_list|,
name|t1
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
else|else
name|delete_insns_since
argument_list|(
name|last
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|delete_insns_since
argument_list|(
name|entry_last
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Generate code to perform an operation specified by UNOPTAB    on operand OP0, with result having machine-mode MODE.     UNSIGNEDP is for the case where we have to widen the operands    to perform the operation.  It says to use zero-extension.     If TARGET is nonzero, the value    is generated there, if it is convenient to do so.    In all cases an rtx is returned for the locus of the value;    this may or may not be TARGET.  */
end_comment

begin_function
name|rtx
name|expand_unop
parameter_list|(
name|mode
parameter_list|,
name|unoptab
parameter_list|,
name|op0
parameter_list|,
name|target
parameter_list|,
name|unsignedp
parameter_list|)
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|optab
name|unoptab
decl_stmt|;
name|rtx
name|op0
decl_stmt|;
name|rtx
name|target
decl_stmt|;
name|int
name|unsignedp
decl_stmt|;
block|{
name|enum
name|mode_class
name|class
decl_stmt|;
name|enum
name|machine_mode
name|wider_mode
decl_stmt|;
specifier|register
name|rtx
name|temp
decl_stmt|;
name|rtx
name|last
init|=
name|get_last_insn
argument_list|()
decl_stmt|;
name|rtx
name|pat
decl_stmt|;
name|class
operator|=
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|op0
operator|=
name|protect_from_queue
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_force_mem
condition|)
block|{
name|op0
operator|=
name|force_not_mem
argument_list|(
name|op0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|target
condition|)
name|target
operator|=
name|protect_from_queue
argument_list|(
name|target
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|unoptab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|mode
index|]
operator|.
name|insn_code
operator|!=
name|CODE_FOR_nothing
condition|)
block|{
name|int
name|icode
init|=
operator|(
name|int
operator|)
name|unoptab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|mode
index|]
operator|.
name|insn_code
decl_stmt|;
name|enum
name|machine_mode
name|mode0
init|=
name|insn_operand_mode
index|[
name|icode
index|]
index|[
literal|1
index|]
decl_stmt|;
name|rtx
name|xop0
init|=
name|op0
decl_stmt|;
if|if
condition|(
name|target
condition|)
name|temp
operator|=
name|target
expr_stmt|;
else|else
name|temp
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|xop0
argument_list|)
operator|!=
name|VOIDmode
operator|&&
name|GET_MODE
argument_list|(
name|xop0
argument_list|)
operator|!=
name|mode0
condition|)
name|xop0
operator|=
name|convert_to_mode
argument_list|(
name|mode0
argument_list|,
name|xop0
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
comment|/* Now, if insn doesn't accept our operand, put it into a pseudo.  */
if|if
condition|(
operator|!
call|(
modifier|*
name|insn_operand_predicate
index|[
name|icode
index|]
index|[
literal|1
index|]
call|)
argument_list|(
name|xop0
argument_list|,
name|mode0
argument_list|)
condition|)
name|xop0
operator|=
name|copy_to_mode_reg
argument_list|(
name|mode0
argument_list|,
name|xop0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
call|(
modifier|*
name|insn_operand_predicate
index|[
name|icode
index|]
index|[
literal|0
index|]
call|)
argument_list|(
name|temp
argument_list|,
name|mode
argument_list|)
condition|)
name|temp
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|pat
operator|=
name|GEN_FCN
argument_list|(
name|icode
argument_list|)
argument_list|(
name|temp
argument_list|,
name|xop0
argument_list|)
expr_stmt|;
if|if
condition|(
name|pat
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|==
name|SEQUENCE
operator|&&
operator|!
name|add_equal_note
argument_list|(
name|pat
argument_list|,
name|temp
argument_list|,
name|unoptab
operator|->
name|code
argument_list|,
name|xop0
argument_list|,
name|NULL_RTX
argument_list|)
condition|)
block|{
name|delete_insns_since
argument_list|(
name|last
argument_list|)
expr_stmt|;
return|return
name|expand_unop
argument_list|(
name|mode
argument_list|,
name|unoptab
argument_list|,
name|op0
argument_list|,
name|NULL_RTX
argument_list|,
name|unsignedp
argument_list|)
return|;
block|}
name|emit_insn
argument_list|(
name|pat
argument_list|)
expr_stmt|;
return|return
name|temp
return|;
block|}
else|else
name|delete_insns_since
argument_list|(
name|last
argument_list|)
expr_stmt|;
block|}
comment|/* It can't be done in this mode.  Can we open-code it in a wider mode?  */
if|if
condition|(
name|class
operator|==
name|MODE_INT
operator|||
name|class
operator|==
name|MODE_FLOAT
operator|||
name|class
operator|==
name|MODE_COMPLEX_FLOAT
condition|)
for|for
control|(
name|wider_mode
operator|=
name|GET_MODE_WIDER_MODE
argument_list|(
name|mode
argument_list|)
init|;
name|wider_mode
operator|!=
name|VOIDmode
condition|;
name|wider_mode
operator|=
name|GET_MODE_WIDER_MODE
argument_list|(
name|wider_mode
argument_list|)
control|)
block|{
if|if
condition|(
name|unoptab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|wider_mode
index|]
operator|.
name|insn_code
operator|!=
name|CODE_FOR_nothing
condition|)
block|{
name|rtx
name|xop0
init|=
name|op0
decl_stmt|;
comment|/* For certain operations, we need not actually extend 	       the narrow operand, as long as we will truncate the 	       results to the same narrowness.  But it is faster to 	       convert a SUBREG due to mode promotion.  */
if|if
condition|(
operator|(
name|unoptab
operator|==
name|neg_optab
operator|||
name|unoptab
operator|==
name|one_cmpl_optab
operator|)
operator|&&
name|GET_MODE_SIZE
argument_list|(
name|wider_mode
argument_list|)
operator|<=
name|UNITS_PER_WORD
operator|&&
name|class
operator|==
name|MODE_INT
operator|&&
operator|!
operator|(
name|GET_CODE
argument_list|(
name|xop0
argument_list|)
operator|==
name|SUBREG
operator|&&
name|SUBREG_PROMOTED_VAR_P
argument_list|(
name|xop0
argument_list|)
operator|)
condition|)
name|xop0
operator|=
name|gen_rtx
argument_list|(
name|SUBREG
argument_list|,
name|wider_mode
argument_list|,
name|force_reg
argument_list|(
name|mode
argument_list|,
name|xop0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|xop0
operator|=
name|convert_to_mode
argument_list|(
name|wider_mode
argument_list|,
name|xop0
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
name|temp
operator|=
name|expand_unop
argument_list|(
name|wider_mode
argument_list|,
name|unoptab
argument_list|,
name|xop0
argument_list|,
name|NULL_RTX
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
condition|)
block|{
if|if
condition|(
name|class
operator|!=
name|MODE_INT
condition|)
block|{
if|if
condition|(
name|target
operator|==
literal|0
condition|)
name|target
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|convert_move
argument_list|(
name|target
argument_list|,
name|temp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|target
return|;
block|}
else|else
return|return
name|gen_lowpart
argument_list|(
name|mode
argument_list|,
name|temp
argument_list|)
return|;
block|}
else|else
name|delete_insns_since
argument_list|(
name|last
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* These can be done a word at a time.  */
if|if
condition|(
name|unoptab
operator|==
name|one_cmpl_optab
operator|&&
name|class
operator|==
name|MODE_INT
operator|&&
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|>
name|UNITS_PER_WORD
operator|&&
name|unoptab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|word_mode
index|]
operator|.
name|insn_code
operator|!=
name|CODE_FOR_nothing
condition|)
block|{
name|int
name|i
decl_stmt|;
name|rtx
name|insns
decl_stmt|;
if|if
condition|(
name|target
operator|==
literal|0
operator|||
name|target
operator|==
name|op0
condition|)
name|target
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|start_sequence
argument_list|()
expr_stmt|;
comment|/* Do the actual arithmetic.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|/
name|BITS_PER_WORD
condition|;
name|i
operator|++
control|)
block|{
name|rtx
name|target_piece
init|=
name|operand_subword
argument_list|(
name|target
argument_list|,
name|i
argument_list|,
literal|1
argument_list|,
name|mode
argument_list|)
decl_stmt|;
name|rtx
name|x
init|=
name|expand_unop
argument_list|(
name|word_mode
argument_list|,
name|unoptab
argument_list|,
name|operand_subword_force
argument_list|(
name|op0
argument_list|,
name|i
argument_list|,
name|mode
argument_list|)
argument_list|,
name|target_piece
argument_list|,
name|unsignedp
argument_list|)
decl_stmt|;
if|if
condition|(
name|target_piece
operator|!=
name|x
condition|)
name|emit_move_insn
argument_list|(
name|target_piece
argument_list|,
name|x
argument_list|)
expr_stmt|;
block|}
name|insns
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
name|emit_no_conflict_block
argument_list|(
name|insns
argument_list|,
name|target
argument_list|,
name|op0
argument_list|,
name|NULL_RTX
argument_list|,
name|gen_rtx
argument_list|(
name|unoptab
operator|->
name|code
argument_list|,
name|mode
argument_list|,
name|op0
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|target
return|;
block|}
comment|/* Open-code the complex negation operation.  */
elseif|else
if|if
condition|(
name|unoptab
operator|==
name|neg_optab
operator|&&
operator|(
name|class
operator|==
name|MODE_COMPLEX_FLOAT
operator|||
name|class
operator|==
name|MODE_COMPLEX_INT
operator|)
condition|)
block|{
name|rtx
name|target_piece
decl_stmt|;
name|rtx
name|x
decl_stmt|;
name|rtx
name|seq
decl_stmt|;
comment|/* Find the correct mode for the real and imaginary parts */
name|enum
name|machine_mode
name|submode
init|=
name|mode_for_size
argument_list|(
name|GET_MODE_UNIT_SIZE
argument_list|(
name|mode
argument_list|)
operator|*
name|BITS_PER_UNIT
argument_list|,
name|class
operator|==
name|MODE_COMPLEX_INT
condition|?
name|MODE_INT
else|:
name|MODE_FLOAT
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|submode
operator|==
name|BLKmode
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|target
operator|==
literal|0
condition|)
name|target
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|start_sequence
argument_list|()
expr_stmt|;
name|target_piece
operator|=
name|gen_imagpart
argument_list|(
name|submode
argument_list|,
name|target
argument_list|)
expr_stmt|;
name|x
operator|=
name|expand_unop
argument_list|(
name|submode
argument_list|,
name|unoptab
argument_list|,
name|gen_imagpart
argument_list|(
name|submode
argument_list|,
name|op0
argument_list|)
argument_list|,
name|target_piece
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
if|if
condition|(
name|target_piece
operator|!=
name|x
condition|)
name|emit_move_insn
argument_list|(
name|target_piece
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|target_piece
operator|=
name|gen_realpart
argument_list|(
name|submode
argument_list|,
name|target
argument_list|)
expr_stmt|;
name|x
operator|=
name|expand_unop
argument_list|(
name|submode
argument_list|,
name|unoptab
argument_list|,
name|gen_realpart
argument_list|(
name|submode
argument_list|,
name|op0
argument_list|)
argument_list|,
name|target_piece
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
if|if
condition|(
name|target_piece
operator|!=
name|x
condition|)
name|emit_move_insn
argument_list|(
name|target_piece
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|seq
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
name|emit_no_conflict_block
argument_list|(
name|seq
argument_list|,
name|target
argument_list|,
name|op0
argument_list|,
literal|0
argument_list|,
name|gen_rtx
argument_list|(
name|unoptab
operator|->
name|code
argument_list|,
name|mode
argument_list|,
name|op0
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|target
return|;
block|}
comment|/* Now try a library call in this mode.  */
if|if
condition|(
name|unoptab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|mode
index|]
operator|.
name|libfunc
condition|)
block|{
name|rtx
name|insns
decl_stmt|;
name|rtx
name|funexp
init|=
name|unoptab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|mode
index|]
operator|.
name|libfunc
decl_stmt|;
name|start_sequence
argument_list|()
expr_stmt|;
comment|/* Pass 1 for NO_QUEUE so we don't lose any increments 	 if the libcall is cse'd or moved.  */
name|emit_library_call
argument_list|(
name|unoptab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|mode
index|]
operator|.
name|libfunc
argument_list|,
literal|1
argument_list|,
name|mode
argument_list|,
literal|1
argument_list|,
name|op0
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|insns
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
name|target
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|emit_libcall_block
argument_list|(
name|insns
argument_list|,
name|target
argument_list|,
name|hard_libcall_value
argument_list|(
name|mode
argument_list|)
argument_list|,
name|gen_rtx
argument_list|(
name|unoptab
operator|->
name|code
argument_list|,
name|mode
argument_list|,
name|op0
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|target
return|;
block|}
comment|/* It can't be done in this mode.  Can we do it in a wider mode?  */
if|if
condition|(
name|class
operator|==
name|MODE_INT
operator|||
name|class
operator|==
name|MODE_FLOAT
operator|||
name|class
operator|==
name|MODE_COMPLEX_FLOAT
condition|)
block|{
for|for
control|(
name|wider_mode
operator|=
name|GET_MODE_WIDER_MODE
argument_list|(
name|mode
argument_list|)
init|;
name|wider_mode
operator|!=
name|VOIDmode
condition|;
name|wider_mode
operator|=
name|GET_MODE_WIDER_MODE
argument_list|(
name|wider_mode
argument_list|)
control|)
block|{
if|if
condition|(
operator|(
name|unoptab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|wider_mode
index|]
operator|.
name|insn_code
operator|!=
name|CODE_FOR_nothing
operator|)
operator|||
name|unoptab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|wider_mode
index|]
operator|.
name|libfunc
condition|)
block|{
name|rtx
name|xop0
init|=
name|op0
decl_stmt|;
comment|/* For certain operations, we need not actually extend 		 the narrow operand, as long as we will truncate the 		 results to the same narrowness.  */
if|if
condition|(
operator|(
name|unoptab
operator|==
name|neg_optab
operator|||
name|unoptab
operator|==
name|one_cmpl_optab
operator|)
operator|&&
name|GET_MODE_SIZE
argument_list|(
name|wider_mode
argument_list|)
operator|<=
name|UNITS_PER_WORD
operator|&&
name|class
operator|==
name|MODE_INT
operator|&&
operator|!
operator|(
name|GET_CODE
argument_list|(
name|xop0
argument_list|)
operator|==
name|SUBREG
operator|&&
name|SUBREG_PROMOTED_VAR_P
argument_list|(
name|xop0
argument_list|)
operator|)
condition|)
name|xop0
operator|=
name|gen_rtx
argument_list|(
name|SUBREG
argument_list|,
name|wider_mode
argument_list|,
name|force_reg
argument_list|(
name|mode
argument_list|,
name|xop0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|xop0
operator|=
name|convert_to_mode
argument_list|(
name|wider_mode
argument_list|,
name|xop0
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
name|temp
operator|=
name|expand_unop
argument_list|(
name|wider_mode
argument_list|,
name|unoptab
argument_list|,
name|xop0
argument_list|,
name|NULL_RTX
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
condition|)
block|{
if|if
condition|(
name|class
operator|!=
name|MODE_INT
condition|)
block|{
if|if
condition|(
name|target
operator|==
literal|0
condition|)
name|target
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|convert_move
argument_list|(
name|target
argument_list|,
name|temp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|target
return|;
block|}
else|else
return|return
name|gen_lowpart
argument_list|(
name|mode
argument_list|,
name|temp
argument_list|)
return|;
block|}
else|else
name|delete_insns_since
argument_list|(
name|last
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Emit code to compute the absolute value of OP0, with result to    TARGET if convenient.  (TARGET may be 0.)  The return value says    where the result actually is to be found.     MODE is the mode of the operand; the mode of the result is    different but can be deduced from MODE.     UNSIGNEDP is relevant for complex integer modes.  */
end_comment

begin_function
name|rtx
name|expand_complex_abs
parameter_list|(
name|mode
parameter_list|,
name|op0
parameter_list|,
name|target
parameter_list|,
name|unsignedp
parameter_list|)
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|rtx
name|op0
decl_stmt|;
name|rtx
name|target
decl_stmt|;
name|int
name|unsignedp
decl_stmt|;
block|{
name|enum
name|mode_class
name|class
init|=
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|wider_mode
decl_stmt|;
specifier|register
name|rtx
name|temp
decl_stmt|;
name|rtx
name|entry_last
init|=
name|get_last_insn
argument_list|()
decl_stmt|;
name|rtx
name|last
decl_stmt|;
name|rtx
name|pat
decl_stmt|;
comment|/* Find the correct mode for the real and imaginary parts.  */
name|enum
name|machine_mode
name|submode
init|=
name|mode_for_size
argument_list|(
name|GET_MODE_UNIT_SIZE
argument_list|(
name|mode
argument_list|)
operator|*
name|BITS_PER_UNIT
argument_list|,
name|class
operator|==
name|MODE_COMPLEX_INT
condition|?
name|MODE_INT
else|:
name|MODE_FLOAT
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|submode
operator|==
name|BLKmode
condition|)
name|abort
argument_list|()
expr_stmt|;
name|op0
operator|=
name|protect_from_queue
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_force_mem
condition|)
block|{
name|op0
operator|=
name|force_not_mem
argument_list|(
name|op0
argument_list|)
expr_stmt|;
block|}
name|last
operator|=
name|get_last_insn
argument_list|()
expr_stmt|;
if|if
condition|(
name|target
condition|)
name|target
operator|=
name|protect_from_queue
argument_list|(
name|target
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|abs_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|mode
index|]
operator|.
name|insn_code
operator|!=
name|CODE_FOR_nothing
condition|)
block|{
name|int
name|icode
init|=
operator|(
name|int
operator|)
name|abs_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|mode
index|]
operator|.
name|insn_code
decl_stmt|;
name|enum
name|machine_mode
name|mode0
init|=
name|insn_operand_mode
index|[
name|icode
index|]
index|[
literal|1
index|]
decl_stmt|;
name|rtx
name|xop0
init|=
name|op0
decl_stmt|;
if|if
condition|(
name|target
condition|)
name|temp
operator|=
name|target
expr_stmt|;
else|else
name|temp
operator|=
name|gen_reg_rtx
argument_list|(
name|submode
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|xop0
argument_list|)
operator|!=
name|VOIDmode
operator|&&
name|GET_MODE
argument_list|(
name|xop0
argument_list|)
operator|!=
name|mode0
condition|)
name|xop0
operator|=
name|convert_to_mode
argument_list|(
name|mode0
argument_list|,
name|xop0
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
comment|/* Now, if insn doesn't accept our operand, put it into a pseudo.  */
if|if
condition|(
operator|!
call|(
modifier|*
name|insn_operand_predicate
index|[
name|icode
index|]
index|[
literal|1
index|]
call|)
argument_list|(
name|xop0
argument_list|,
name|mode0
argument_list|)
condition|)
name|xop0
operator|=
name|copy_to_mode_reg
argument_list|(
name|mode0
argument_list|,
name|xop0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
call|(
modifier|*
name|insn_operand_predicate
index|[
name|icode
index|]
index|[
literal|0
index|]
call|)
argument_list|(
name|temp
argument_list|,
name|submode
argument_list|)
condition|)
name|temp
operator|=
name|gen_reg_rtx
argument_list|(
name|submode
argument_list|)
expr_stmt|;
name|pat
operator|=
name|GEN_FCN
argument_list|(
name|icode
argument_list|)
argument_list|(
name|temp
argument_list|,
name|xop0
argument_list|)
expr_stmt|;
if|if
condition|(
name|pat
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|==
name|SEQUENCE
operator|&&
operator|!
name|add_equal_note
argument_list|(
name|pat
argument_list|,
name|temp
argument_list|,
name|abs_optab
operator|->
name|code
argument_list|,
name|xop0
argument_list|,
name|NULL_RTX
argument_list|)
condition|)
block|{
name|delete_insns_since
argument_list|(
name|last
argument_list|)
expr_stmt|;
return|return
name|expand_unop
argument_list|(
name|mode
argument_list|,
name|abs_optab
argument_list|,
name|op0
argument_list|,
name|NULL_RTX
argument_list|,
name|unsignedp
argument_list|)
return|;
block|}
name|emit_insn
argument_list|(
name|pat
argument_list|)
expr_stmt|;
return|return
name|temp
return|;
block|}
else|else
name|delete_insns_since
argument_list|(
name|last
argument_list|)
expr_stmt|;
block|}
comment|/* It can't be done in this mode.  Can we open-code it in a wider mode?  */
for|for
control|(
name|wider_mode
operator|=
name|GET_MODE_WIDER_MODE
argument_list|(
name|mode
argument_list|)
init|;
name|wider_mode
operator|!=
name|VOIDmode
condition|;
name|wider_mode
operator|=
name|GET_MODE_WIDER_MODE
argument_list|(
name|wider_mode
argument_list|)
control|)
block|{
if|if
condition|(
name|abs_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|wider_mode
index|]
operator|.
name|insn_code
operator|!=
name|CODE_FOR_nothing
condition|)
block|{
name|rtx
name|xop0
init|=
name|op0
decl_stmt|;
name|xop0
operator|=
name|convert_to_mode
argument_list|(
name|wider_mode
argument_list|,
name|xop0
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
name|temp
operator|=
name|expand_complex_abs
argument_list|(
name|wider_mode
argument_list|,
name|xop0
argument_list|,
name|NULL_RTX
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
condition|)
block|{
if|if
condition|(
name|class
operator|!=
name|MODE_COMPLEX_INT
condition|)
block|{
if|if
condition|(
name|target
operator|==
literal|0
condition|)
name|target
operator|=
name|gen_reg_rtx
argument_list|(
name|submode
argument_list|)
expr_stmt|;
name|convert_move
argument_list|(
name|target
argument_list|,
name|temp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|target
return|;
block|}
else|else
return|return
name|gen_lowpart
argument_list|(
name|submode
argument_list|,
name|temp
argument_list|)
return|;
block|}
else|else
name|delete_insns_since
argument_list|(
name|last
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Open-code the complex absolute-value operation      if we can open-code sqrt.  Otherwise it's not worth while.  */
if|if
condition|(
name|sqrt_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|submode
index|]
operator|.
name|insn_code
operator|!=
name|CODE_FOR_nothing
condition|)
block|{
name|rtx
name|real
decl_stmt|,
name|imag
decl_stmt|,
name|total
decl_stmt|;
name|real
operator|=
name|gen_realpart
argument_list|(
name|submode
argument_list|,
name|op0
argument_list|)
expr_stmt|;
name|imag
operator|=
name|gen_imagpart
argument_list|(
name|submode
argument_list|,
name|op0
argument_list|)
expr_stmt|;
comment|/* Square both parts.  */
name|real
operator|=
name|expand_mult
argument_list|(
name|mode
argument_list|,
name|real
argument_list|,
name|real
argument_list|,
name|NULL_RTX
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|imag
operator|=
name|expand_mult
argument_list|(
name|mode
argument_list|,
name|imag
argument_list|,
name|imag
argument_list|,
name|NULL_RTX
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Sum the parts.  */
name|total
operator|=
name|expand_binop
argument_list|(
name|submode
argument_list|,
name|add_optab
argument_list|,
name|real
argument_list|,
name|imag
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|OPTAB_LIB_WIDEN
argument_list|)
expr_stmt|;
comment|/* Get sqrt in TARGET.  Set TARGET to where the result is.  */
name|target
operator|=
name|expand_unop
argument_list|(
name|submode
argument_list|,
name|sqrt_optab
argument_list|,
name|total
argument_list|,
name|target
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
operator|==
literal|0
condition|)
name|delete_insns_since
argument_list|(
name|last
argument_list|)
expr_stmt|;
else|else
return|return
name|target
return|;
block|}
comment|/* Now try a library call in this mode.  */
if|if
condition|(
name|abs_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|mode
index|]
operator|.
name|libfunc
condition|)
block|{
name|rtx
name|insns
decl_stmt|;
name|rtx
name|funexp
init|=
name|abs_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|mode
index|]
operator|.
name|libfunc
decl_stmt|;
name|start_sequence
argument_list|()
expr_stmt|;
comment|/* Pass 1 for NO_QUEUE so we don't lose any increments 	 if the libcall is cse'd or moved.  */
name|emit_library_call
argument_list|(
name|abs_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|mode
index|]
operator|.
name|libfunc
argument_list|,
literal|1
argument_list|,
name|mode
argument_list|,
literal|1
argument_list|,
name|op0
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|insns
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
name|target
operator|=
name|gen_reg_rtx
argument_list|(
name|submode
argument_list|)
expr_stmt|;
name|emit_libcall_block
argument_list|(
name|insns
argument_list|,
name|target
argument_list|,
name|hard_libcall_value
argument_list|(
name|submode
argument_list|)
argument_list|,
name|gen_rtx
argument_list|(
name|abs_optab
operator|->
name|code
argument_list|,
name|mode
argument_list|,
name|op0
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|target
return|;
block|}
comment|/* It can't be done in this mode.  Can we do it in a wider mode?  */
for|for
control|(
name|wider_mode
operator|=
name|GET_MODE_WIDER_MODE
argument_list|(
name|mode
argument_list|)
init|;
name|wider_mode
operator|!=
name|VOIDmode
condition|;
name|wider_mode
operator|=
name|GET_MODE_WIDER_MODE
argument_list|(
name|wider_mode
argument_list|)
control|)
block|{
if|if
condition|(
operator|(
name|abs_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|wider_mode
index|]
operator|.
name|insn_code
operator|!=
name|CODE_FOR_nothing
operator|)
operator|||
name|abs_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|wider_mode
index|]
operator|.
name|libfunc
condition|)
block|{
name|rtx
name|xop0
init|=
name|op0
decl_stmt|;
name|xop0
operator|=
name|convert_to_mode
argument_list|(
name|wider_mode
argument_list|,
name|xop0
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
name|temp
operator|=
name|expand_complex_abs
argument_list|(
name|wider_mode
argument_list|,
name|xop0
argument_list|,
name|NULL_RTX
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
condition|)
block|{
if|if
condition|(
name|class
operator|!=
name|MODE_COMPLEX_INT
condition|)
block|{
if|if
condition|(
name|target
operator|==
literal|0
condition|)
name|target
operator|=
name|gen_reg_rtx
argument_list|(
name|submode
argument_list|)
expr_stmt|;
name|convert_move
argument_list|(
name|target
argument_list|,
name|temp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|target
return|;
block|}
else|else
return|return
name|gen_lowpart
argument_list|(
name|submode
argument_list|,
name|temp
argument_list|)
return|;
block|}
else|else
name|delete_insns_since
argument_list|(
name|last
argument_list|)
expr_stmt|;
block|}
block|}
name|delete_insns_since
argument_list|(
name|entry_last
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Generate an instruction whose insn-code is INSN_CODE,    with two operands: an output TARGET and an input OP0.    TARGET *must* be nonzero, and the output is always stored there.    CODE is an rtx code such that (CODE OP0) is an rtx that describes    the value that is stored into TARGET.  */
end_comment

begin_function
name|void
name|emit_unop_insn
parameter_list|(
name|icode
parameter_list|,
name|target
parameter_list|,
name|op0
parameter_list|,
name|code
parameter_list|)
name|int
name|icode
decl_stmt|;
name|rtx
name|target
decl_stmt|;
name|rtx
name|op0
decl_stmt|;
name|enum
name|rtx_code
name|code
decl_stmt|;
block|{
specifier|register
name|rtx
name|temp
decl_stmt|;
name|enum
name|machine_mode
name|mode0
init|=
name|insn_operand_mode
index|[
name|icode
index|]
index|[
literal|1
index|]
decl_stmt|;
name|rtx
name|pat
decl_stmt|;
name|temp
operator|=
name|target
operator|=
name|protect_from_queue
argument_list|(
name|target
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|op0
operator|=
name|protect_from_queue
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_force_mem
condition|)
name|op0
operator|=
name|force_not_mem
argument_list|(
name|op0
argument_list|)
expr_stmt|;
comment|/* Now, if insn does not accept our operands, put them into pseudos.  */
if|if
condition|(
operator|!
call|(
modifier|*
name|insn_operand_predicate
index|[
name|icode
index|]
index|[
literal|1
index|]
call|)
argument_list|(
name|op0
argument_list|,
name|mode0
argument_list|)
condition|)
name|op0
operator|=
name|copy_to_mode_reg
argument_list|(
name|mode0
argument_list|,
name|op0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
call|(
modifier|*
name|insn_operand_predicate
index|[
name|icode
index|]
index|[
literal|0
index|]
call|)
argument_list|(
name|temp
argument_list|,
name|GET_MODE
argument_list|(
name|temp
argument_list|)
argument_list|)
operator|||
operator|(
name|flag_force_mem
operator|&&
name|GET_CODE
argument_list|(
name|temp
argument_list|)
operator|==
name|MEM
operator|)
condition|)
name|temp
operator|=
name|gen_reg_rtx
argument_list|(
name|GET_MODE
argument_list|(
name|temp
argument_list|)
argument_list|)
expr_stmt|;
name|pat
operator|=
name|GEN_FCN
argument_list|(
name|icode
argument_list|)
argument_list|(
name|temp
argument_list|,
name|op0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|==
name|SEQUENCE
operator|&&
name|code
operator|!=
name|UNKNOWN
condition|)
name|add_equal_note
argument_list|(
name|pat
argument_list|,
name|temp
argument_list|,
name|code
argument_list|,
name|op0
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|pat
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|!=
name|target
condition|)
name|emit_move_insn
argument_list|(
name|target
argument_list|,
name|temp
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Emit code to perform a series of operations on a multi-word quantity, one    word at a time.     Such a block is preceded by a CLOBBER of the output, consists of multiple    insns, each setting one word of the output, and followed by a SET copying    the output to itself.     Each of the insns setting words of the output receives a REG_NO_CONFLICT    note indicating that it doesn't conflict with the (also multi-word)    inputs.  The entire block is surrounded by REG_LIBCALL and REG_RETVAL    notes.     INSNS is a block of code generated to perform the operation, not including    the CLOBBER and final copy.  All insns that compute intermediate values    are first emitted, followed by the block as described above.  Only    INSNs are allowed in the block; no library calls or jumps may be    present.     TARGET, OP0, and OP1 are the output and inputs of the operations,    respectively.  OP1 may be zero for a unary operation.     EQUIV, if non-zero, is an expression to be placed into a REG_EQUAL note    on the last insn.     If TARGET is not a register, INSNS is simply emitted with no special    processing.     The final insn emitted is returned.  */
end_comment

begin_function
name|rtx
name|emit_no_conflict_block
parameter_list|(
name|insns
parameter_list|,
name|target
parameter_list|,
name|op0
parameter_list|,
name|op1
parameter_list|,
name|equiv
parameter_list|)
name|rtx
name|insns
decl_stmt|;
name|rtx
name|target
decl_stmt|;
name|rtx
name|op0
decl_stmt|,
name|op1
decl_stmt|;
name|rtx
name|equiv
decl_stmt|;
block|{
name|rtx
name|prev
decl_stmt|,
name|next
decl_stmt|,
name|first
decl_stmt|,
name|last
decl_stmt|,
name|insn
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|target
argument_list|)
operator|!=
name|REG
operator|||
name|reload_in_progress
condition|)
return|return
name|emit_insns
argument_list|(
name|insns
argument_list|)
return|;
comment|/* First emit all insns that do not store into words of the output and remove      these from the list.  */
for|for
control|(
name|insn
operator|=
name|insns
init|;
name|insn
condition|;
name|insn
operator|=
name|next
control|)
block|{
name|rtx
name|set
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
name|next
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|!=
name|INSN
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|SET
condition|)
name|set
operator|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|PARALLEL
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
operator|==
name|SET
condition|)
block|{
name|set
operator|=
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|set
operator|==
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|reg_overlap_mentioned_p
argument_list|(
name|target
argument_list|,
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
condition|)
name|NEXT_INSN
argument_list|(
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|=
name|next
expr_stmt|;
else|else
name|insns
operator|=
name|next
expr_stmt|;
if|if
condition|(
name|next
condition|)
name|PREV_INSN
argument_list|(
name|next
argument_list|)
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|add_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
block|}
name|prev
operator|=
name|get_last_insn
argument_list|()
expr_stmt|;
comment|/* Now write the CLOBBER of the output, followed by the setting of each      of the words, followed by the final copy.  */
if|if
condition|(
name|target
operator|!=
name|op0
operator|&&
name|target
operator|!=
name|op1
condition|)
name|emit_insn
argument_list|(
name|gen_rtx
argument_list|(
name|CLOBBER
argument_list|,
name|VOIDmode
argument_list|,
name|target
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|insn
operator|=
name|insns
init|;
name|insn
condition|;
name|insn
operator|=
name|next
control|)
block|{
name|next
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|add_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|op1
operator|&&
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|REG
condition|)
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|=
name|gen_rtx
argument_list|(
name|EXPR_LIST
argument_list|,
name|REG_NO_CONFLICT
argument_list|,
name|op1
argument_list|,
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|op0
operator|&&
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|REG
condition|)
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|=
name|gen_rtx
argument_list|(
name|EXPR_LIST
argument_list|,
name|REG_NO_CONFLICT
argument_list|,
name|op0
argument_list|,
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|last
operator|=
name|emit_move_insn
argument_list|(
name|target
argument_list|,
name|target
argument_list|)
expr_stmt|;
if|if
condition|(
name|equiv
condition|)
name|REG_NOTES
argument_list|(
name|last
argument_list|)
operator|=
name|gen_rtx
argument_list|(
name|EXPR_LIST
argument_list|,
name|REG_EQUAL
argument_list|,
name|equiv
argument_list|,
name|REG_NOTES
argument_list|(
name|last
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|prev
operator|==
literal|0
condition|)
name|first
operator|=
name|get_insns
argument_list|()
expr_stmt|;
else|else
name|first
operator|=
name|NEXT_INSN
argument_list|(
name|prev
argument_list|)
expr_stmt|;
comment|/* Encapsulate the block so it gets manipulated as a unit.  */
name|REG_NOTES
argument_list|(
name|first
argument_list|)
operator|=
name|gen_rtx
argument_list|(
name|INSN_LIST
argument_list|,
name|REG_LIBCALL
argument_list|,
name|last
argument_list|,
name|REG_NOTES
argument_list|(
name|first
argument_list|)
argument_list|)
expr_stmt|;
name|REG_NOTES
argument_list|(
name|last
argument_list|)
operator|=
name|gen_rtx
argument_list|(
name|INSN_LIST
argument_list|,
name|REG_RETVAL
argument_list|,
name|first
argument_list|,
name|REG_NOTES
argument_list|(
name|last
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|last
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Emit code to make a call to a constant function or a library call.     INSNS is a list containing all insns emitted in the call.    These insns leave the result in RESULT.  Our block is to copy RESULT    to TARGET, which is logically equivalent to EQUIV.     We first emit any insns that set a pseudo on the assumption that these are    loading constants into registers; doing so allows them to be safely cse'ed    between blocks.  Then we emit all the other insns in the block, followed by    an insn to move RESULT to TARGET.  This last insn will have a REQ_EQUAL    note with an operand of EQUIV.     Moving assignments to pseudos outside of the block is done to improve    the generated code, but is not required to generate correct code,    hence being unable to move an assignment is not grounds for not making    a libcall block.  There are two reasons why it is safe to leave these    insns inside the block: First, we know that these pseudos cannot be    used in generated RTL outside the block since they are created for    temporary purposes within the block.  Second, CSE will not record the    values of anything set inside a libcall block, so we know they must    be dead at the end of the block.     Except for the first group of insns (the ones setting pseudos), the    block is delimited by REG_RETVAL and REG_LIBCALL notes.  */
end_comment

begin_function
name|void
name|emit_libcall_block
parameter_list|(
name|insns
parameter_list|,
name|target
parameter_list|,
name|result
parameter_list|,
name|equiv
parameter_list|)
name|rtx
name|insns
decl_stmt|;
name|rtx
name|target
decl_stmt|;
name|rtx
name|result
decl_stmt|;
name|rtx
name|equiv
decl_stmt|;
block|{
name|rtx
name|prev
decl_stmt|,
name|next
decl_stmt|,
name|first
decl_stmt|,
name|last
decl_stmt|,
name|insn
decl_stmt|;
comment|/* First emit all insns that set pseudos.  Remove them from the list as      we go.  Avoid insns that set pseudo which were referenced in previous      insns.  These can be generated by move_by_pieces, for example,      to update an address.  */
for|for
control|(
name|insn
operator|=
name|insns
init|;
name|insn
condition|;
name|insn
operator|=
name|next
control|)
block|{
name|rtx
name|set
init|=
name|single_set
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|next
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|set
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|&&
operator|(
name|insn
operator|==
name|insns
operator|||
operator|(
operator|!
name|reg_mentioned_p
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|,
name|PATTERN
argument_list|(
name|insns
argument_list|)
argument_list|)
operator|&&
operator|!
name|reg_used_between_p
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|,
name|insns
argument_list|,
name|insn
argument_list|)
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
condition|)
name|NEXT_INSN
argument_list|(
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|=
name|next
expr_stmt|;
else|else
name|insns
operator|=
name|next
expr_stmt|;
if|if
condition|(
name|next
condition|)
name|PREV_INSN
argument_list|(
name|next
argument_list|)
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|add_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
block|}
name|prev
operator|=
name|get_last_insn
argument_list|()
expr_stmt|;
comment|/* Write the remaining insns followed by the final copy.  */
for|for
control|(
name|insn
operator|=
name|insns
init|;
name|insn
condition|;
name|insn
operator|=
name|next
control|)
block|{
name|next
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|add_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
name|last
operator|=
name|emit_move_insn
argument_list|(
name|target
argument_list|,
name|result
argument_list|)
expr_stmt|;
name|REG_NOTES
argument_list|(
name|last
argument_list|)
operator|=
name|gen_rtx
argument_list|(
name|EXPR_LIST
argument_list|,
name|REG_EQUAL
argument_list|,
name|equiv
argument_list|,
name|REG_NOTES
argument_list|(
name|last
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|prev
operator|==
literal|0
condition|)
name|first
operator|=
name|get_insns
argument_list|()
expr_stmt|;
else|else
name|first
operator|=
name|NEXT_INSN
argument_list|(
name|prev
argument_list|)
expr_stmt|;
comment|/* Encapsulate the block so it gets manipulated as a unit.  */
name|REG_NOTES
argument_list|(
name|first
argument_list|)
operator|=
name|gen_rtx
argument_list|(
name|INSN_LIST
argument_list|,
name|REG_LIBCALL
argument_list|,
name|last
argument_list|,
name|REG_NOTES
argument_list|(
name|first
argument_list|)
argument_list|)
expr_stmt|;
name|REG_NOTES
argument_list|(
name|last
argument_list|)
operator|=
name|gen_rtx
argument_list|(
name|INSN_LIST
argument_list|,
name|REG_RETVAL
argument_list|,
name|first
argument_list|,
name|REG_NOTES
argument_list|(
name|last
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Generate code to store zero in X.  */
end_comment

begin_function
name|void
name|emit_clr_insn
parameter_list|(
name|x
parameter_list|)
name|rtx
name|x
decl_stmt|;
block|{
name|emit_move_insn
argument_list|(
name|x
argument_list|,
name|const0_rtx
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Generate code to store 1 in X    assuming it contains zero beforehand.  */
end_comment

begin_function
name|void
name|emit_0_to_1_insn
parameter_list|(
name|x
parameter_list|)
name|rtx
name|x
decl_stmt|;
block|{
name|emit_move_insn
argument_list|(
name|x
argument_list|,
name|const1_rtx
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Generate code to compare X with Y    so that the condition codes are set.     MODE is the mode of the inputs (in case they are const_int).    UNSIGNEDP nonzero says that X and Y are unsigned;    this matters if they need to be widened.     If they have mode BLKmode, then SIZE specifies the size of both X and Y,    and ALIGN specifies the known shared alignment of X and Y.     COMPARISON is the rtl operator to compare with (EQ, NE, GT, etc.).    It is ignored for fixed-point and block comparisons;    it is used only for floating-point comparisons.  */
end_comment

begin_function
name|void
name|emit_cmp_insn
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|,
name|comparison
parameter_list|,
name|size
parameter_list|,
name|mode
parameter_list|,
name|unsignedp
parameter_list|,
name|align
parameter_list|)
name|rtx
name|x
decl_stmt|,
name|y
decl_stmt|;
name|enum
name|rtx_code
name|comparison
decl_stmt|;
name|rtx
name|size
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|int
name|unsignedp
decl_stmt|;
name|int
name|align
decl_stmt|;
block|{
name|enum
name|mode_class
name|class
decl_stmt|;
name|enum
name|machine_mode
name|wider_mode
decl_stmt|;
name|class
operator|=
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
expr_stmt|;
comment|/* They could both be VOIDmode if both args are immediate constants,      but we should fold that at an earlier stage.      With no special code here, this will call abort,      reminding the programmer to implement such folding.  */
if|if
condition|(
name|mode
operator|!=
name|BLKmode
operator|&&
name|flag_force_mem
condition|)
block|{
name|x
operator|=
name|force_not_mem
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|y
operator|=
name|force_not_mem
argument_list|(
name|y
argument_list|)
expr_stmt|;
block|}
comment|/* If we are inside an appropriately-short loop and one operand is an      expensive constant, force it into a register.  */
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|x
argument_list|)
operator|&&
name|preserve_subexpressions_p
argument_list|()
operator|&&
name|rtx_cost
argument_list|(
name|x
argument_list|,
name|COMPARE
argument_list|)
operator|>
literal|2
condition|)
name|x
operator|=
name|force_reg
argument_list|(
name|mode
argument_list|,
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|y
argument_list|)
operator|&&
name|preserve_subexpressions_p
argument_list|()
operator|&&
name|rtx_cost
argument_list|(
name|y
argument_list|,
name|COMPARE
argument_list|)
operator|>
literal|2
condition|)
name|y
operator|=
name|force_reg
argument_list|(
name|mode
argument_list|,
name|y
argument_list|)
expr_stmt|;
comment|/* Don't let both operands fail to indicate the mode.  */
if|if
condition|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|==
name|VOIDmode
operator|&&
name|GET_MODE
argument_list|(
name|y
argument_list|)
operator|==
name|VOIDmode
condition|)
name|x
operator|=
name|force_reg
argument_list|(
name|mode
argument_list|,
name|x
argument_list|)
expr_stmt|;
comment|/* Handle all BLKmode compares.  */
if|if
condition|(
name|mode
operator|==
name|BLKmode
condition|)
block|{
name|emit_queue
argument_list|()
expr_stmt|;
name|x
operator|=
name|protect_from_queue
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|y
operator|=
name|protect_from_queue
argument_list|(
name|y
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|==
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_cmpstrqi
if|if
condition|(
name|HAVE_cmpstrqi
operator|&&
name|GET_CODE
argument_list|(
name|size
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|size
argument_list|)
operator|<
operator|(
literal|1
operator|<<
name|GET_MODE_BITSIZE
argument_list|(
name|QImode
argument_list|)
operator|)
condition|)
block|{
name|enum
name|machine_mode
name|result_mode
init|=
name|insn_operand_mode
index|[
operator|(
name|int
operator|)
name|CODE_FOR_cmpstrqi
index|]
index|[
literal|0
index|]
decl_stmt|;
name|rtx
name|result
init|=
name|gen_reg_rtx
argument_list|(
name|result_mode
argument_list|)
decl_stmt|;
name|emit_insn
argument_list|(
name|gen_cmpstrqi
argument_list|(
name|result
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|size
argument_list|,
name|GEN_INT
argument_list|(
name|align
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_cmp_insn
argument_list|(
name|result
argument_list|,
name|const0_rtx
argument_list|,
name|comparison
argument_list|,
name|NULL_RTX
argument_list|,
name|result_mode
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_cmpstrhi
if|if
condition|(
name|HAVE_cmpstrhi
operator|&&
name|GET_CODE
argument_list|(
name|size
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|size
argument_list|)
operator|<
operator|(
literal|1
operator|<<
name|GET_MODE_BITSIZE
argument_list|(
name|HImode
argument_list|)
operator|)
condition|)
block|{
name|enum
name|machine_mode
name|result_mode
init|=
name|insn_operand_mode
index|[
operator|(
name|int
operator|)
name|CODE_FOR_cmpstrhi
index|]
index|[
literal|0
index|]
decl_stmt|;
name|rtx
name|result
init|=
name|gen_reg_rtx
argument_list|(
name|result_mode
argument_list|)
decl_stmt|;
name|emit_insn
argument_list|(
name|gen_cmpstrhi
argument_list|(
name|result
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|size
argument_list|,
name|GEN_INT
argument_list|(
name|align
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_cmp_insn
argument_list|(
name|result
argument_list|,
name|const0_rtx
argument_list|,
name|comparison
argument_list|,
name|NULL_RTX
argument_list|,
name|result_mode
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_cmpstrsi
if|if
condition|(
name|HAVE_cmpstrsi
condition|)
block|{
name|enum
name|machine_mode
name|result_mode
init|=
name|insn_operand_mode
index|[
operator|(
name|int
operator|)
name|CODE_FOR_cmpstrsi
index|]
index|[
literal|0
index|]
decl_stmt|;
name|rtx
name|result
init|=
name|gen_reg_rtx
argument_list|(
name|result_mode
argument_list|)
decl_stmt|;
name|size
operator|=
name|protect_from_queue
argument_list|(
name|size
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_cmpstrsi
argument_list|(
name|result
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|convert_to_mode
argument_list|(
name|SImode
argument_list|,
name|size
argument_list|,
literal|1
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
name|align
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_cmp_insn
argument_list|(
name|result
argument_list|,
name|const0_rtx
argument_list|,
name|comparison
argument_list|,
name|NULL_RTX
argument_list|,
name|result_mode
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
block|{
ifdef|#
directive|ifdef
name|TARGET_MEM_FUNCTIONS
name|emit_library_call
argument_list|(
name|memcmp_libfunc
argument_list|,
literal|0
argument_list|,
name|TYPE_MODE
argument_list|(
name|integer_type_node
argument_list|)
argument_list|,
literal|3
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|Pmode
argument_list|,
name|XEXP
argument_list|(
name|y
argument_list|,
literal|0
argument_list|)
argument_list|,
name|Pmode
argument_list|,
name|size
argument_list|,
name|Pmode
argument_list|)
expr_stmt|;
else|#
directive|else
name|emit_library_call
argument_list|(
name|bcmp_libfunc
argument_list|,
literal|0
argument_list|,
name|TYPE_MODE
argument_list|(
name|integer_type_node
argument_list|)
argument_list|,
literal|3
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|Pmode
argument_list|,
name|XEXP
argument_list|(
name|y
argument_list|,
literal|0
argument_list|)
argument_list|,
name|Pmode
argument_list|,
name|size
argument_list|,
name|Pmode
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|emit_cmp_insn
argument_list|(
name|hard_libcall_value
argument_list|(
name|TYPE_MODE
argument_list|(
name|integer_type_node
argument_list|)
argument_list|)
argument_list|,
name|const0_rtx
argument_list|,
name|comparison
argument_list|,
name|NULL_RTX
argument_list|,
name|TYPE_MODE
argument_list|(
name|integer_type_node
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
comment|/* Handle some compares against zero.  */
if|if
condition|(
name|y
operator|==
name|CONST0_RTX
argument_list|(
name|mode
argument_list|)
operator|&&
name|tst_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|mode
index|]
operator|.
name|insn_code
operator|!=
name|CODE_FOR_nothing
condition|)
block|{
name|int
name|icode
init|=
operator|(
name|int
operator|)
name|tst_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|mode
index|]
operator|.
name|insn_code
decl_stmt|;
name|emit_queue
argument_list|()
expr_stmt|;
name|x
operator|=
name|protect_from_queue
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|y
operator|=
name|protect_from_queue
argument_list|(
name|y
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Now, if insn does accept these operands, put them into pseudos.  */
if|if
condition|(
operator|!
call|(
modifier|*
name|insn_operand_predicate
index|[
name|icode
index|]
index|[
literal|0
index|]
call|)
argument_list|(
name|x
argument_list|,
name|insn_operand_mode
index|[
name|icode
index|]
index|[
literal|0
index|]
argument_list|)
condition|)
name|x
operator|=
name|copy_to_mode_reg
argument_list|(
name|insn_operand_mode
index|[
name|icode
index|]
index|[
literal|0
index|]
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|GEN_FCN
argument_list|(
name|icode
argument_list|)
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Handle compares for which there is a directly suitable insn.  */
if|if
condition|(
name|cmp_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|mode
index|]
operator|.
name|insn_code
operator|!=
name|CODE_FOR_nothing
condition|)
block|{
name|int
name|icode
init|=
operator|(
name|int
operator|)
name|cmp_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|mode
index|]
operator|.
name|insn_code
decl_stmt|;
name|emit_queue
argument_list|()
expr_stmt|;
name|x
operator|=
name|protect_from_queue
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|y
operator|=
name|protect_from_queue
argument_list|(
name|y
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Now, if insn doesn't accept these operands, put them into pseudos.  */
if|if
condition|(
operator|!
call|(
modifier|*
name|insn_operand_predicate
index|[
name|icode
index|]
index|[
literal|0
index|]
call|)
argument_list|(
name|x
argument_list|,
name|insn_operand_mode
index|[
name|icode
index|]
index|[
literal|0
index|]
argument_list|)
condition|)
name|x
operator|=
name|copy_to_mode_reg
argument_list|(
name|insn_operand_mode
index|[
name|icode
index|]
index|[
literal|0
index|]
argument_list|,
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
call|(
modifier|*
name|insn_operand_predicate
index|[
name|icode
index|]
index|[
literal|1
index|]
call|)
argument_list|(
name|y
argument_list|,
name|insn_operand_mode
index|[
name|icode
index|]
index|[
literal|1
index|]
argument_list|)
condition|)
name|y
operator|=
name|copy_to_mode_reg
argument_list|(
name|insn_operand_mode
index|[
name|icode
index|]
index|[
literal|1
index|]
argument_list|,
name|y
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|GEN_FCN
argument_list|(
name|icode
argument_list|)
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Try widening if we can find a direct insn that way.  */
if|if
condition|(
name|class
operator|==
name|MODE_INT
operator|||
name|class
operator|==
name|MODE_FLOAT
operator|||
name|class
operator|==
name|MODE_COMPLEX_FLOAT
condition|)
block|{
for|for
control|(
name|wider_mode
operator|=
name|GET_MODE_WIDER_MODE
argument_list|(
name|mode
argument_list|)
init|;
name|wider_mode
operator|!=
name|VOIDmode
condition|;
name|wider_mode
operator|=
name|GET_MODE_WIDER_MODE
argument_list|(
name|wider_mode
argument_list|)
control|)
block|{
if|if
condition|(
name|cmp_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|wider_mode
index|]
operator|.
name|insn_code
operator|!=
name|CODE_FOR_nothing
condition|)
block|{
name|x
operator|=
name|protect_from_queue
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|y
operator|=
name|protect_from_queue
argument_list|(
name|y
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|x
operator|=
name|convert_to_mode
argument_list|(
name|wider_mode
argument_list|,
name|x
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
name|y
operator|=
name|convert_to_mode
argument_list|(
name|wider_mode
argument_list|,
name|y
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
name|emit_cmp_insn
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|comparison
argument_list|,
name|NULL_RTX
argument_list|,
name|wider_mode
argument_list|,
name|unsignedp
argument_list|,
name|align
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
block|}
comment|/* Handle a lib call just for the mode we are using.  */
if|if
condition|(
name|cmp_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|mode
index|]
operator|.
name|libfunc
operator|&&
name|class
operator|!=
name|MODE_FLOAT
condition|)
block|{
name|rtx
name|libfunc
init|=
name|cmp_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|mode
index|]
operator|.
name|libfunc
decl_stmt|;
comment|/* If we want unsigned, and this mode has a distinct unsigned 	 comparison routine, use that.  */
if|if
condition|(
name|unsignedp
operator|&&
name|ucmp_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|mode
index|]
operator|.
name|libfunc
condition|)
name|libfunc
operator|=
name|ucmp_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|mode
index|]
operator|.
name|libfunc
expr_stmt|;
name|emit_library_call
argument_list|(
name|libfunc
argument_list|,
literal|1
argument_list|,
name|SImode
argument_list|,
literal|2
argument_list|,
name|x
argument_list|,
name|mode
argument_list|,
name|y
argument_list|,
name|mode
argument_list|)
expr_stmt|;
comment|/* Integer comparison returns a result that must be compared against 1, 	 so that even if we do an unsigned compare afterward, 	 there is still a value that can represent the result "less than".  */
name|emit_cmp_insn
argument_list|(
name|hard_libcall_value
argument_list|(
name|SImode
argument_list|)
argument_list|,
name|const1_rtx
argument_list|,
name|comparison
argument_list|,
name|NULL_RTX
argument_list|,
name|SImode
argument_list|,
name|unsignedp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|class
operator|==
name|MODE_FLOAT
condition|)
name|emit_float_lib_cmp
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|comparison
argument_list|)
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Nonzero if a compare of mode MODE can be done straightforwardly    (without splitting it into pieces).  */
end_comment

begin_function
name|int
name|can_compare_p
parameter_list|(
name|mode
parameter_list|)
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
do|do
block|{
if|if
condition|(
name|cmp_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|mode
index|]
operator|.
name|insn_code
operator|!=
name|CODE_FOR_nothing
condition|)
return|return
literal|1
return|;
name|mode
operator|=
name|GET_MODE_WIDER_MODE
argument_list|(
name|mode
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|mode
operator|!=
name|VOIDmode
condition|)
do|;
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Emit a library call comparison between floating point X and Y.    COMPARISON is the rtl operator to compare with (EQ, NE, GT, etc.).  */
end_comment

begin_function
specifier|static
name|void
name|emit_float_lib_cmp
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|,
name|comparison
parameter_list|)
name|rtx
name|x
decl_stmt|,
name|y
decl_stmt|;
name|enum
name|rtx_code
name|comparison
decl_stmt|;
block|{
name|enum
name|machine_mode
name|mode
init|=
name|GET_MODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|rtx
name|libfunc
decl_stmt|;
if|if
condition|(
name|mode
operator|==
name|SFmode
condition|)
switch|switch
condition|(
name|comparison
condition|)
block|{
case|case
name|EQ
case|:
name|libfunc
operator|=
name|eqsf2_libfunc
expr_stmt|;
break|break;
case|case
name|NE
case|:
name|libfunc
operator|=
name|nesf2_libfunc
expr_stmt|;
break|break;
case|case
name|GT
case|:
name|libfunc
operator|=
name|gtsf2_libfunc
expr_stmt|;
break|break;
case|case
name|GE
case|:
name|libfunc
operator|=
name|gesf2_libfunc
expr_stmt|;
break|break;
case|case
name|LT
case|:
name|libfunc
operator|=
name|ltsf2_libfunc
expr_stmt|;
break|break;
case|case
name|LE
case|:
name|libfunc
operator|=
name|lesf2_libfunc
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|mode
operator|==
name|DFmode
condition|)
switch|switch
condition|(
name|comparison
condition|)
block|{
case|case
name|EQ
case|:
name|libfunc
operator|=
name|eqdf2_libfunc
expr_stmt|;
break|break;
case|case
name|NE
case|:
name|libfunc
operator|=
name|nedf2_libfunc
expr_stmt|;
break|break;
case|case
name|GT
case|:
name|libfunc
operator|=
name|gtdf2_libfunc
expr_stmt|;
break|break;
case|case
name|GE
case|:
name|libfunc
operator|=
name|gedf2_libfunc
expr_stmt|;
break|break;
case|case
name|LT
case|:
name|libfunc
operator|=
name|ltdf2_libfunc
expr_stmt|;
break|break;
case|case
name|LE
case|:
name|libfunc
operator|=
name|ledf2_libfunc
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|mode
operator|==
name|XFmode
condition|)
switch|switch
condition|(
name|comparison
condition|)
block|{
case|case
name|EQ
case|:
name|libfunc
operator|=
name|eqxf2_libfunc
expr_stmt|;
break|break;
case|case
name|NE
case|:
name|libfunc
operator|=
name|nexf2_libfunc
expr_stmt|;
break|break;
case|case
name|GT
case|:
name|libfunc
operator|=
name|gtxf2_libfunc
expr_stmt|;
break|break;
case|case
name|GE
case|:
name|libfunc
operator|=
name|gexf2_libfunc
expr_stmt|;
break|break;
case|case
name|LT
case|:
name|libfunc
operator|=
name|ltxf2_libfunc
expr_stmt|;
break|break;
case|case
name|LE
case|:
name|libfunc
operator|=
name|lexf2_libfunc
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|mode
operator|==
name|TFmode
condition|)
switch|switch
condition|(
name|comparison
condition|)
block|{
case|case
name|EQ
case|:
name|libfunc
operator|=
name|eqtf2_libfunc
expr_stmt|;
break|break;
case|case
name|NE
case|:
name|libfunc
operator|=
name|netf2_libfunc
expr_stmt|;
break|break;
case|case
name|GT
case|:
name|libfunc
operator|=
name|gttf2_libfunc
expr_stmt|;
break|break;
case|case
name|GE
case|:
name|libfunc
operator|=
name|getf2_libfunc
expr_stmt|;
break|break;
case|case
name|LT
case|:
name|libfunc
operator|=
name|lttf2_libfunc
expr_stmt|;
break|break;
case|case
name|LE
case|:
name|libfunc
operator|=
name|letf2_libfunc
expr_stmt|;
break|break;
block|}
else|else
block|{
name|enum
name|machine_mode
name|wider_mode
decl_stmt|;
for|for
control|(
name|wider_mode
operator|=
name|GET_MODE_WIDER_MODE
argument_list|(
name|mode
argument_list|)
init|;
name|wider_mode
operator|!=
name|VOIDmode
condition|;
name|wider_mode
operator|=
name|GET_MODE_WIDER_MODE
argument_list|(
name|wider_mode
argument_list|)
control|)
block|{
if|if
condition|(
operator|(
name|cmp_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|wider_mode
index|]
operator|.
name|insn_code
operator|!=
name|CODE_FOR_nothing
operator|)
operator|||
operator|(
name|cmp_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|wider_mode
index|]
operator|.
name|libfunc
operator|!=
literal|0
operator|)
condition|)
block|{
name|x
operator|=
name|protect_from_queue
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|y
operator|=
name|protect_from_queue
argument_list|(
name|y
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|x
operator|=
name|convert_to_mode
argument_list|(
name|wider_mode
argument_list|,
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|y
operator|=
name|convert_to_mode
argument_list|(
name|wider_mode
argument_list|,
name|y
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emit_float_lib_cmp
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|comparison
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|abort
argument_list|()
expr_stmt|;
block|}
name|emit_library_call
argument_list|(
name|libfunc
argument_list|,
literal|1
argument_list|,
name|SImode
argument_list|,
literal|2
argument_list|,
name|x
argument_list|,
name|mode
argument_list|,
name|y
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|emit_cmp_insn
argument_list|(
name|hard_libcall_value
argument_list|(
name|SImode
argument_list|)
argument_list|,
name|const0_rtx
argument_list|,
name|comparison
argument_list|,
name|NULL_RTX
argument_list|,
name|SImode
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Generate code to indirectly jump to a location given in the rtx LOC.  */
end_comment

begin_function
name|void
name|emit_indirect_jump
parameter_list|(
name|loc
parameter_list|)
name|rtx
name|loc
decl_stmt|;
block|{
if|if
condition|(
operator|!
operator|(
call|(
modifier|*
name|insn_operand_predicate
index|[
operator|(
name|int
operator|)
name|CODE_FOR_indirect_jump
index|]
index|[
literal|0
index|]
call|)
argument_list|(
name|loc
argument_list|,
name|VOIDmode
argument_list|)
operator|)
condition|)
name|loc
operator|=
name|copy_to_mode_reg
argument_list|(
name|insn_operand_mode
index|[
operator|(
name|int
operator|)
name|CODE_FOR_indirect_jump
index|]
index|[
literal|0
index|]
argument_list|,
name|loc
argument_list|)
expr_stmt|;
name|emit_jump_insn
argument_list|(
name|gen_indirect_jump
argument_list|(
name|loc
argument_list|)
argument_list|)
expr_stmt|;
name|emit_barrier
argument_list|()
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* These three functions generate an insn body and return it    rather than emitting the insn.     They do not protect from queued increments,    because they may be used 1) in protect_from_queue itself    and 2) in other passes where there is no queue.  */
end_comment

begin_comment
comment|/* Generate and return an insn body to add Y to X.  */
end_comment

begin_function
name|rtx
name|gen_add2_insn
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
name|rtx
name|x
decl_stmt|,
name|y
decl_stmt|;
block|{
name|int
name|icode
init|=
operator|(
name|int
operator|)
name|add_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|GET_MODE
argument_list|(
name|x
argument_list|)
index|]
operator|.
name|insn_code
decl_stmt|;
if|if
condition|(
operator|!
call|(
modifier|*
name|insn_operand_predicate
index|[
name|icode
index|]
index|[
literal|0
index|]
call|)
argument_list|(
name|x
argument_list|,
name|insn_operand_mode
index|[
name|icode
index|]
index|[
literal|0
index|]
argument_list|)
operator|||
operator|!
call|(
modifier|*
name|insn_operand_predicate
index|[
name|icode
index|]
index|[
literal|1
index|]
call|)
argument_list|(
name|x
argument_list|,
name|insn_operand_mode
index|[
name|icode
index|]
index|[
literal|1
index|]
argument_list|)
operator|||
operator|!
call|(
modifier|*
name|insn_operand_predicate
index|[
name|icode
index|]
index|[
literal|2
index|]
call|)
argument_list|(
name|y
argument_list|,
name|insn_operand_mode
index|[
name|icode
index|]
index|[
literal|2
index|]
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
return|return
operator|(
name|GEN_FCN
argument_list|(
name|icode
argument_list|)
argument_list|(
name|x
argument_list|,
name|x
argument_list|,
name|y
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|have_add2_insn
parameter_list|(
name|mode
parameter_list|)
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
return|return
name|add_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|mode
index|]
operator|.
name|insn_code
operator|!=
name|CODE_FOR_nothing
return|;
block|}
end_function

begin_comment
comment|/* Generate and return an insn body to subtract Y from X.  */
end_comment

begin_function
name|rtx
name|gen_sub2_insn
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
name|rtx
name|x
decl_stmt|,
name|y
decl_stmt|;
block|{
name|int
name|icode
init|=
operator|(
name|int
operator|)
name|sub_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|GET_MODE
argument_list|(
name|x
argument_list|)
index|]
operator|.
name|insn_code
decl_stmt|;
if|if
condition|(
operator|!
call|(
modifier|*
name|insn_operand_predicate
index|[
name|icode
index|]
index|[
literal|0
index|]
call|)
argument_list|(
name|x
argument_list|,
name|insn_operand_mode
index|[
name|icode
index|]
index|[
literal|0
index|]
argument_list|)
operator|||
operator|!
call|(
modifier|*
name|insn_operand_predicate
index|[
name|icode
index|]
index|[
literal|1
index|]
call|)
argument_list|(
name|x
argument_list|,
name|insn_operand_mode
index|[
name|icode
index|]
index|[
literal|1
index|]
argument_list|)
operator|||
operator|!
call|(
modifier|*
name|insn_operand_predicate
index|[
name|icode
index|]
index|[
literal|2
index|]
call|)
argument_list|(
name|y
argument_list|,
name|insn_operand_mode
index|[
name|icode
index|]
index|[
literal|2
index|]
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
return|return
operator|(
name|GEN_FCN
argument_list|(
name|icode
argument_list|)
argument_list|(
name|x
argument_list|,
name|x
argument_list|,
name|y
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|have_sub2_insn
parameter_list|(
name|mode
parameter_list|)
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
return|return
name|sub_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|mode
index|]
operator|.
name|insn_code
operator|!=
name|CODE_FOR_nothing
return|;
block|}
end_function

begin_comment
comment|/* Generate the body of an instruction to copy Y into X.  */
end_comment

begin_function
name|rtx
name|gen_move_insn
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
name|rtx
name|x
decl_stmt|,
name|y
decl_stmt|;
block|{
specifier|register
name|enum
name|machine_mode
name|mode
init|=
name|GET_MODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|enum
name|insn_code
name|insn_code
decl_stmt|;
if|if
condition|(
name|mode
operator|==
name|VOIDmode
condition|)
name|mode
operator|=
name|GET_MODE
argument_list|(
name|y
argument_list|)
expr_stmt|;
name|insn_code
operator|=
name|mov_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|mode
index|]
operator|.
name|insn_code
expr_stmt|;
comment|/* Handle MODE_CC modes:  If we don't have a special move insn for this mode,      find a mode to do it in.  If we have a movcc, use it.  Otherwise,      find the MODE_INT mode of the same width.  */
if|if
condition|(
name|insn_code
operator|==
name|CODE_FOR_nothing
condition|)
block|{
name|enum
name|machine_mode
name|tmode
init|=
name|VOIDmode
decl_stmt|;
name|rtx
name|x1
init|=
name|x
decl_stmt|,
name|y1
init|=
name|y
decl_stmt|;
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_CC
operator|&&
name|mode
operator|!=
name|CCmode
operator|&&
name|mov_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|CCmode
index|]
operator|.
name|insn_code
operator|!=
name|CODE_FOR_nothing
condition|)
name|tmode
operator|=
name|CCmode
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_CC
condition|)
for|for
control|(
name|tmode
operator|=
name|QImode
init|;
name|tmode
operator|!=
name|VOIDmode
condition|;
name|tmode
operator|=
name|GET_MODE_WIDER_MODE
argument_list|(
name|tmode
argument_list|)
control|)
if|if
condition|(
name|GET_MODE_SIZE
argument_list|(
name|tmode
argument_list|)
operator|==
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
condition|)
break|break;
if|if
condition|(
name|tmode
operator|==
name|VOIDmode
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Get X and Y in TMODE.  We can't use gen_lowpart here because it 	 may call change_address which is not appropriate if we were 	 called when a reload was in progress.  We don't have to worry 	 about changing the address since the size in bytes is supposed to 	 be the same.  Copy the MEM to change the mode and move any 	 substitutions from the old MEM to the new one.  */
if|if
condition|(
name|reload_in_progress
condition|)
block|{
name|x
operator|=
name|gen_lowpart_common
argument_list|(
name|tmode
argument_list|,
name|x1
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|==
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|x1
argument_list|)
operator|==
name|MEM
condition|)
block|{
name|x
operator|=
name|gen_rtx
argument_list|(
name|MEM
argument_list|,
name|tmode
argument_list|,
name|XEXP
argument_list|(
name|x1
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|RTX_UNCHANGING_P
argument_list|(
name|x
argument_list|)
operator|=
name|RTX_UNCHANGING_P
argument_list|(
name|x1
argument_list|)
expr_stmt|;
name|MEM_IN_STRUCT_P
argument_list|(
name|x
argument_list|)
operator|=
name|MEM_IN_STRUCT_P
argument_list|(
name|x1
argument_list|)
expr_stmt|;
name|MEM_VOLATILE_P
argument_list|(
name|x
argument_list|)
operator|=
name|MEM_VOLATILE_P
argument_list|(
name|x1
argument_list|)
expr_stmt|;
name|copy_replacements
argument_list|(
name|x1
argument_list|,
name|x
argument_list|)
expr_stmt|;
block|}
name|y
operator|=
name|gen_lowpart_common
argument_list|(
name|tmode
argument_list|,
name|y1
argument_list|)
expr_stmt|;
if|if
condition|(
name|y
operator|==
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|y1
argument_list|)
operator|==
name|MEM
condition|)
block|{
name|y
operator|=
name|gen_rtx
argument_list|(
name|MEM
argument_list|,
name|tmode
argument_list|,
name|XEXP
argument_list|(
name|y1
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|RTX_UNCHANGING_P
argument_list|(
name|y
argument_list|)
operator|=
name|RTX_UNCHANGING_P
argument_list|(
name|y1
argument_list|)
expr_stmt|;
name|MEM_IN_STRUCT_P
argument_list|(
name|y
argument_list|)
operator|=
name|MEM_IN_STRUCT_P
argument_list|(
name|y1
argument_list|)
expr_stmt|;
name|MEM_VOLATILE_P
argument_list|(
name|y
argument_list|)
operator|=
name|MEM_VOLATILE_P
argument_list|(
name|y1
argument_list|)
expr_stmt|;
name|copy_replacements
argument_list|(
name|y1
argument_list|,
name|y
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|x
operator|=
name|gen_lowpart
argument_list|(
name|tmode
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|y
operator|=
name|gen_lowpart
argument_list|(
name|tmode
argument_list|,
name|y
argument_list|)
expr_stmt|;
block|}
name|insn_code
operator|=
name|mov_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|tmode
index|]
operator|.
name|insn_code
expr_stmt|;
block|}
return|return
operator|(
name|GEN_FCN
argument_list|(
name|insn_code
argument_list|)
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Tables of patterns for extending one integer mode to another.  */
end_comment

begin_decl_stmt
specifier|static
name|enum
name|insn_code
name|extendtab
index|[
name|MAX_MACHINE_MODE
index|]
index|[
name|MAX_MACHINE_MODE
index|]
index|[
literal|2
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Return the insn code used to extend FROM_MODE to TO_MODE.    UNSIGNEDP specifies zero-extension instead of sign-extension.  If    no such operation exists, CODE_FOR_nothing will be returned.  */
end_comment

begin_function
name|enum
name|insn_code
name|can_extend_p
parameter_list|(
name|to_mode
parameter_list|,
name|from_mode
parameter_list|,
name|unsignedp
parameter_list|)
name|enum
name|machine_mode
name|to_mode
decl_stmt|,
name|from_mode
decl_stmt|;
name|int
name|unsignedp
decl_stmt|;
block|{
return|return
name|extendtab
index|[
operator|(
name|int
operator|)
name|to_mode
index|]
index|[
operator|(
name|int
operator|)
name|from_mode
index|]
index|[
name|unsignedp
index|]
return|;
block|}
end_function

begin_comment
comment|/* Generate the body of an insn to extend Y (with mode MFROM)    into X (with mode MTO).  Do zero-extension if UNSIGNEDP is nonzero.  */
end_comment

begin_function
name|rtx
name|gen_extend_insn
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|,
name|mto
parameter_list|,
name|mfrom
parameter_list|,
name|unsignedp
parameter_list|)
name|rtx
name|x
decl_stmt|,
name|y
decl_stmt|;
name|enum
name|machine_mode
name|mto
decl_stmt|,
name|mfrom
decl_stmt|;
name|int
name|unsignedp
decl_stmt|;
block|{
return|return
operator|(
name|GEN_FCN
argument_list|(
name|extendtab
index|[
operator|(
name|int
operator|)
name|mto
index|]
index|[
operator|(
name|int
operator|)
name|mfrom
index|]
index|[
name|unsignedp
index|]
argument_list|)
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|init_extends
parameter_list|()
block|{
name|enum
name|insn_code
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|p
operator|=
name|extendtab
index|[
literal|0
index|]
index|[
literal|0
index|]
init|;
name|p
operator|<
name|extendtab
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|+
sizeof|sizeof
name|extendtab
operator|/
sizeof|sizeof
name|extendtab
index|[
literal|0
index|]
index|[
literal|0
index|]
index|[
literal|0
index|]
condition|;
name|p
operator|++
control|)
operator|*
name|p
operator|=
name|CODE_FOR_nothing
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_extendditi2
if|if
condition|(
name|HAVE_extendditi2
condition|)
name|extendtab
index|[
operator|(
name|int
operator|)
name|TImode
index|]
index|[
operator|(
name|int
operator|)
name|DImode
index|]
index|[
literal|0
index|]
operator|=
name|CODE_FOR_extendditi2
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_extendsiti2
if|if
condition|(
name|HAVE_extendsiti2
condition|)
name|extendtab
index|[
operator|(
name|int
operator|)
name|TImode
index|]
index|[
operator|(
name|int
operator|)
name|SImode
index|]
index|[
literal|0
index|]
operator|=
name|CODE_FOR_extendsiti2
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_extendhiti2
if|if
condition|(
name|HAVE_extendhiti2
condition|)
name|extendtab
index|[
operator|(
name|int
operator|)
name|TImode
index|]
index|[
operator|(
name|int
operator|)
name|HImode
index|]
index|[
literal|0
index|]
operator|=
name|CODE_FOR_extendhiti2
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_extendqiti2
if|if
condition|(
name|HAVE_extendqiti2
condition|)
name|extendtab
index|[
operator|(
name|int
operator|)
name|TImode
index|]
index|[
operator|(
name|int
operator|)
name|QImode
index|]
index|[
literal|0
index|]
operator|=
name|CODE_FOR_extendqiti2
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_extendsidi2
if|if
condition|(
name|HAVE_extendsidi2
condition|)
name|extendtab
index|[
operator|(
name|int
operator|)
name|DImode
index|]
index|[
operator|(
name|int
operator|)
name|SImode
index|]
index|[
literal|0
index|]
operator|=
name|CODE_FOR_extendsidi2
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_extendhidi2
if|if
condition|(
name|HAVE_extendhidi2
condition|)
name|extendtab
index|[
operator|(
name|int
operator|)
name|DImode
index|]
index|[
operator|(
name|int
operator|)
name|HImode
index|]
index|[
literal|0
index|]
operator|=
name|CODE_FOR_extendhidi2
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_extendqidi2
if|if
condition|(
name|HAVE_extendqidi2
condition|)
name|extendtab
index|[
operator|(
name|int
operator|)
name|DImode
index|]
index|[
operator|(
name|int
operator|)
name|QImode
index|]
index|[
literal|0
index|]
operator|=
name|CODE_FOR_extendqidi2
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_extendhisi2
if|if
condition|(
name|HAVE_extendhisi2
condition|)
name|extendtab
index|[
operator|(
name|int
operator|)
name|SImode
index|]
index|[
operator|(
name|int
operator|)
name|HImode
index|]
index|[
literal|0
index|]
operator|=
name|CODE_FOR_extendhisi2
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_extendqisi2
if|if
condition|(
name|HAVE_extendqisi2
condition|)
name|extendtab
index|[
operator|(
name|int
operator|)
name|SImode
index|]
index|[
operator|(
name|int
operator|)
name|QImode
index|]
index|[
literal|0
index|]
operator|=
name|CODE_FOR_extendqisi2
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_extendqihi2
if|if
condition|(
name|HAVE_extendqihi2
condition|)
name|extendtab
index|[
operator|(
name|int
operator|)
name|HImode
index|]
index|[
operator|(
name|int
operator|)
name|QImode
index|]
index|[
literal|0
index|]
operator|=
name|CODE_FOR_extendqihi2
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_zero_extendditi2
if|if
condition|(
name|HAVE_zero_extendsiti2
condition|)
name|extendtab
index|[
operator|(
name|int
operator|)
name|TImode
index|]
index|[
operator|(
name|int
operator|)
name|DImode
index|]
index|[
literal|1
index|]
operator|=
name|CODE_FOR_zero_extendditi2
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_zero_extendsiti2
if|if
condition|(
name|HAVE_zero_extendsiti2
condition|)
name|extendtab
index|[
operator|(
name|int
operator|)
name|TImode
index|]
index|[
operator|(
name|int
operator|)
name|SImode
index|]
index|[
literal|1
index|]
operator|=
name|CODE_FOR_zero_extendsiti2
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_zero_extendhiti2
if|if
condition|(
name|HAVE_zero_extendhiti2
condition|)
name|extendtab
index|[
operator|(
name|int
operator|)
name|TImode
index|]
index|[
operator|(
name|int
operator|)
name|HImode
index|]
index|[
literal|1
index|]
operator|=
name|CODE_FOR_zero_extendhiti2
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_zero_extendqiti2
if|if
condition|(
name|HAVE_zero_extendqiti2
condition|)
name|extendtab
index|[
operator|(
name|int
operator|)
name|TImode
index|]
index|[
operator|(
name|int
operator|)
name|QImode
index|]
index|[
literal|1
index|]
operator|=
name|CODE_FOR_zero_extendqiti2
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_zero_extendsidi2
if|if
condition|(
name|HAVE_zero_extendsidi2
condition|)
name|extendtab
index|[
operator|(
name|int
operator|)
name|DImode
index|]
index|[
operator|(
name|int
operator|)
name|SImode
index|]
index|[
literal|1
index|]
operator|=
name|CODE_FOR_zero_extendsidi2
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_zero_extendhidi2
if|if
condition|(
name|HAVE_zero_extendhidi2
condition|)
name|extendtab
index|[
operator|(
name|int
operator|)
name|DImode
index|]
index|[
operator|(
name|int
operator|)
name|HImode
index|]
index|[
literal|1
index|]
operator|=
name|CODE_FOR_zero_extendhidi2
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_zero_extendqidi2
if|if
condition|(
name|HAVE_zero_extendqidi2
condition|)
name|extendtab
index|[
operator|(
name|int
operator|)
name|DImode
index|]
index|[
operator|(
name|int
operator|)
name|QImode
index|]
index|[
literal|1
index|]
operator|=
name|CODE_FOR_zero_extendqidi2
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_zero_extendhisi2
if|if
condition|(
name|HAVE_zero_extendhisi2
condition|)
name|extendtab
index|[
operator|(
name|int
operator|)
name|SImode
index|]
index|[
operator|(
name|int
operator|)
name|HImode
index|]
index|[
literal|1
index|]
operator|=
name|CODE_FOR_zero_extendhisi2
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_zero_extendqisi2
if|if
condition|(
name|HAVE_zero_extendqisi2
condition|)
name|extendtab
index|[
operator|(
name|int
operator|)
name|SImode
index|]
index|[
operator|(
name|int
operator|)
name|QImode
index|]
index|[
literal|1
index|]
operator|=
name|CODE_FOR_zero_extendqisi2
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_zero_extendqihi2
if|if
condition|(
name|HAVE_zero_extendqihi2
condition|)
name|extendtab
index|[
operator|(
name|int
operator|)
name|HImode
index|]
index|[
operator|(
name|int
operator|)
name|QImode
index|]
index|[
literal|1
index|]
operator|=
name|CODE_FOR_zero_extendqihi2
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* can_fix_p and can_float_p say whether the target machine    can directly convert a given fixed point type to    a given floating point type, or vice versa.    The returned value is the CODE_FOR_... value to use,    or CODE_FOR_nothing if these modes cannot be directly converted.  */
end_comment

begin_decl_stmt
specifier|static
name|enum
name|insn_code
name|fixtab
index|[
name|NUM_MACHINE_MODES
index|]
index|[
name|NUM_MACHINE_MODES
index|]
index|[
literal|2
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|enum
name|insn_code
name|fixtrunctab
index|[
name|NUM_MACHINE_MODES
index|]
index|[
name|NUM_MACHINE_MODES
index|]
index|[
literal|2
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|enum
name|insn_code
name|floattab
index|[
name|NUM_MACHINE_MODES
index|]
index|[
name|NUM_MACHINE_MODES
index|]
index|[
literal|2
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* *TRUNCP_PTR is set to 1 if it is necessary to output    an explicit FTRUNC insn before the fix insn; otherwise 0.  */
end_comment

begin_function
specifier|static
name|enum
name|insn_code
name|can_fix_p
parameter_list|(
name|fixmode
parameter_list|,
name|fltmode
parameter_list|,
name|unsignedp
parameter_list|,
name|truncp_ptr
parameter_list|)
name|enum
name|machine_mode
name|fltmode
decl_stmt|,
name|fixmode
decl_stmt|;
name|int
name|unsignedp
decl_stmt|;
name|int
modifier|*
name|truncp_ptr
decl_stmt|;
block|{
operator|*
name|truncp_ptr
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|fixtrunctab
index|[
operator|(
name|int
operator|)
name|fltmode
index|]
index|[
operator|(
name|int
operator|)
name|fixmode
index|]
index|[
name|unsignedp
index|]
operator|!=
name|CODE_FOR_nothing
condition|)
return|return
name|fixtrunctab
index|[
operator|(
name|int
operator|)
name|fltmode
index|]
index|[
operator|(
name|int
operator|)
name|fixmode
index|]
index|[
name|unsignedp
index|]
return|;
if|if
condition|(
name|ftrunc_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|fltmode
index|]
operator|.
name|insn_code
operator|!=
name|CODE_FOR_nothing
condition|)
block|{
operator|*
name|truncp_ptr
operator|=
literal|1
expr_stmt|;
return|return
name|fixtab
index|[
operator|(
name|int
operator|)
name|fltmode
index|]
index|[
operator|(
name|int
operator|)
name|fixmode
index|]
index|[
name|unsignedp
index|]
return|;
block|}
return|return
name|CODE_FOR_nothing
return|;
block|}
end_function

begin_function
specifier|static
name|enum
name|insn_code
name|can_float_p
parameter_list|(
name|fltmode
parameter_list|,
name|fixmode
parameter_list|,
name|unsignedp
parameter_list|)
name|enum
name|machine_mode
name|fixmode
decl_stmt|,
name|fltmode
decl_stmt|;
name|int
name|unsignedp
decl_stmt|;
block|{
return|return
name|floattab
index|[
operator|(
name|int
operator|)
name|fltmode
index|]
index|[
operator|(
name|int
operator|)
name|fixmode
index|]
index|[
name|unsignedp
index|]
return|;
block|}
end_function

begin_function
name|void
name|init_fixtab
parameter_list|()
block|{
name|enum
name|insn_code
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|p
operator|=
name|fixtab
index|[
literal|0
index|]
index|[
literal|0
index|]
init|;
name|p
operator|<
name|fixtab
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|+
sizeof|sizeof
name|fixtab
operator|/
sizeof|sizeof
argument_list|(
name|fixtab
index|[
literal|0
index|]
index|[
literal|0
index|]
index|[
literal|0
index|]
argument_list|)
condition|;
name|p
operator|++
control|)
operator|*
name|p
operator|=
name|CODE_FOR_nothing
expr_stmt|;
for|for
control|(
name|p
operator|=
name|fixtrunctab
index|[
literal|0
index|]
index|[
literal|0
index|]
init|;
name|p
operator|<
name|fixtrunctab
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|+
sizeof|sizeof
name|fixtrunctab
operator|/
sizeof|sizeof
argument_list|(
name|fixtrunctab
index|[
literal|0
index|]
index|[
literal|0
index|]
index|[
literal|0
index|]
argument_list|)
condition|;
name|p
operator|++
control|)
operator|*
name|p
operator|=
name|CODE_FOR_nothing
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_fixsfqi2
if|if
condition|(
name|HAVE_fixsfqi2
condition|)
name|fixtab
index|[
operator|(
name|int
operator|)
name|SFmode
index|]
index|[
operator|(
name|int
operator|)
name|QImode
index|]
index|[
literal|0
index|]
operator|=
name|CODE_FOR_fixsfqi2
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_fixsfhi2
if|if
condition|(
name|HAVE_fixsfhi2
condition|)
name|fixtab
index|[
operator|(
name|int
operator|)
name|SFmode
index|]
index|[
operator|(
name|int
operator|)
name|HImode
index|]
index|[
literal|0
index|]
operator|=
name|CODE_FOR_fixsfhi2
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_fixsfsi2
if|if
condition|(
name|HAVE_fixsfsi2
condition|)
name|fixtab
index|[
operator|(
name|int
operator|)
name|SFmode
index|]
index|[
operator|(
name|int
operator|)
name|SImode
index|]
index|[
literal|0
index|]
operator|=
name|CODE_FOR_fixsfsi2
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_fixsfdi2
if|if
condition|(
name|HAVE_fixsfdi2
condition|)
name|fixtab
index|[
operator|(
name|int
operator|)
name|SFmode
index|]
index|[
operator|(
name|int
operator|)
name|DImode
index|]
index|[
literal|0
index|]
operator|=
name|CODE_FOR_fixsfdi2
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_fixdfqi2
if|if
condition|(
name|HAVE_fixdfqi2
condition|)
name|fixtab
index|[
operator|(
name|int
operator|)
name|DFmode
index|]
index|[
operator|(
name|int
operator|)
name|QImode
index|]
index|[
literal|0
index|]
operator|=
name|CODE_FOR_fixdfqi2
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_fixdfhi2
if|if
condition|(
name|HAVE_fixdfhi2
condition|)
name|fixtab
index|[
operator|(
name|int
operator|)
name|DFmode
index|]
index|[
operator|(
name|int
operator|)
name|HImode
index|]
index|[
literal|0
index|]
operator|=
name|CODE_FOR_fixdfhi2
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_fixdfsi2
if|if
condition|(
name|HAVE_fixdfsi2
condition|)
name|fixtab
index|[
operator|(
name|int
operator|)
name|DFmode
index|]
index|[
operator|(
name|int
operator|)
name|SImode
index|]
index|[
literal|0
index|]
operator|=
name|CODE_FOR_fixdfsi2
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_fixdfdi2
if|if
condition|(
name|HAVE_fixdfdi2
condition|)
name|fixtab
index|[
operator|(
name|int
operator|)
name|DFmode
index|]
index|[
operator|(
name|int
operator|)
name|DImode
index|]
index|[
literal|0
index|]
operator|=
name|CODE_FOR_fixdfdi2
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_fixdfti2
if|if
condition|(
name|HAVE_fixdfti2
condition|)
name|fixtab
index|[
operator|(
name|int
operator|)
name|DFmode
index|]
index|[
operator|(
name|int
operator|)
name|TImode
index|]
index|[
literal|0
index|]
operator|=
name|CODE_FOR_fixdfti2
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_fixxfqi2
if|if
condition|(
name|HAVE_fixxfqi2
condition|)
name|fixtab
index|[
operator|(
name|int
operator|)
name|XFmode
index|]
index|[
operator|(
name|int
operator|)
name|QImode
index|]
index|[
literal|0
index|]
operator|=
name|CODE_FOR_fixxfqi2
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_fixxfhi2
if|if
condition|(
name|HAVE_fixxfhi2
condition|)
name|fixtab
index|[
operator|(
name|int
operator|)
name|XFmode
index|]
index|[
operator|(
name|int
operator|)
name|HImode
index|]
index|[
literal|0
index|]
operator|=
name|CODE_FOR_fixxfhi2
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_fixxfsi2
if|if
condition|(
name|HAVE_fixxfsi2
condition|)
name|fixtab
index|[
operator|(
name|int
operator|)
name|XFmode
index|]
index|[
operator|(
name|int
operator|)
name|SImode
index|]
index|[
literal|0
index|]
operator|=
name|CODE_FOR_fixxfsi2
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_fixxfdi2
if|if
condition|(
name|HAVE_fixxfdi2
condition|)
name|fixtab
index|[
operator|(
name|int
operator|)
name|XFmode
index|]
index|[
operator|(
name|int
operator|)
name|DImode
index|]
index|[
literal|0
index|]
operator|=
name|CODE_FOR_fixxfdi2
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_fixxfti2
if|if
condition|(
name|HAVE_fixxfti2
condition|)
name|fixtab
index|[
operator|(
name|int
operator|)
name|XFmode
index|]
index|[
operator|(
name|int
operator|)
name|TImode
index|]
index|[
literal|0
index|]
operator|=
name|CODE_FOR_fixxfti2
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_fixtfqi2
if|if
condition|(
name|HAVE_fixtfqi2
condition|)
name|fixtab
index|[
operator|(
name|int
operator|)
name|TFmode
index|]
index|[
operator|(
name|int
operator|)
name|QImode
index|]
index|[
literal|0
index|]
operator|=
name|CODE_FOR_fixtfqi2
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_fixtfhi2
if|if
condition|(
name|HAVE_fixtfhi2
condition|)
name|fixtab
index|[
operator|(
name|int
operator|)
name|TFmode
index|]
index|[
operator|(
name|int
operator|)
name|HImode
index|]
index|[
literal|0
index|]
operator|=
name|CODE_FOR_fixtfhi2
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_fixtfsi2
if|if
condition|(
name|HAVE_fixtfsi2
condition|)
name|fixtab
index|[
operator|(
name|int
operator|)
name|TFmode
index|]
index|[
operator|(
name|int
operator|)
name|SImode
index|]
index|[
literal|0
index|]
operator|=
name|CODE_FOR_fixtfsi2
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_fixtfdi2
if|if
condition|(
name|HAVE_fixtfdi2
condition|)
name|fixtab
index|[
operator|(
name|int
operator|)
name|TFmode
index|]
index|[
operator|(
name|int
operator|)
name|DImode
index|]
index|[
literal|0
index|]
operator|=
name|CODE_FOR_fixtfdi2
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_fixtfti2
if|if
condition|(
name|HAVE_fixtfti2
condition|)
name|fixtab
index|[
operator|(
name|int
operator|)
name|TFmode
index|]
index|[
operator|(
name|int
operator|)
name|TImode
index|]
index|[
literal|0
index|]
operator|=
name|CODE_FOR_fixtfti2
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_fixunssfqi2
if|if
condition|(
name|HAVE_fixunssfqi2
condition|)
name|fixtab
index|[
operator|(
name|int
operator|)
name|SFmode
index|]
index|[
operator|(
name|int
operator|)
name|QImode
index|]
index|[
literal|1
index|]
operator|=
name|CODE_FOR_fixunssfqi2
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_fixunssfhi2
if|if
condition|(
name|HAVE_fixunssfhi2
condition|)
name|fixtab
index|[
operator|(
name|int
operator|)
name|SFmode
index|]
index|[
operator|(
name|int
operator|)
name|HImode
index|]
index|[
literal|1
index|]
operator|=
name|CODE_FOR_fixunssfhi2
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_fixunssfsi2
if|if
condition|(
name|HAVE_fixunssfsi2
condition|)
name|fixtab
index|[
operator|(
name|int
operator|)
name|SFmode
index|]
index|[
operator|(
name|int
operator|)
name|SImode
index|]
index|[
literal|1
index|]
operator|=
name|CODE_FOR_fixunssfsi2
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_fixunssfdi2
if|if
condition|(
name|HAVE_fixunssfdi2
condition|)
name|fixtab
index|[
operator|(
name|int
operator|)
name|SFmode
index|]
index|[
operator|(
name|int
operator|)
name|DImode
index|]
index|[
literal|1
index|]
operator|=
name|CODE_FOR_fixunssfdi2
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_fixunsdfqi2
if|if
condition|(
name|HAVE_fixunsdfqi2
condition|)
name|fixtab
index|[
operator|(
name|int
operator|)
name|DFmode
index|]
index|[
operator|(
name|int
operator|)
name|QImode
index|]
index|[
literal|1
index|]
operator|=
name|CODE_FOR_fixunsdfqi2
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_fixunsdfhi2
if|if
condition|(
name|HAVE_fixunsdfhi2
condition|)
name|fixtab
index|[
operator|(
name|int
operator|)
name|DFmode
index|]
index|[
operator|(
name|int
operator|)
name|HImode
index|]
index|[
literal|1
index|]
operator|=
name|CODE_FOR_fixunsdfhi2
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_fixunsdfsi2
if|if
condition|(
name|HAVE_fixunsdfsi2
condition|)
name|fixtab
index|[
operator|(
name|int
operator|)
name|DFmode
index|]
index|[
operator|(
name|int
operator|)
name|SImode
index|]
index|[
literal|1
index|]
operator|=
name|CODE_FOR_fixunsdfsi2
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_fixunsdfdi2
if|if
condition|(
name|HAVE_fixunsdfdi2
condition|)
name|fixtab
index|[
operator|(
name|int
operator|)
name|DFmode
index|]
index|[
operator|(
name|int
operator|)
name|DImode
index|]
index|[
literal|1
index|]
operator|=
name|CODE_FOR_fixunsdfdi2
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_fixunsdfti2
if|if
condition|(
name|HAVE_fixunsdfti2
condition|)
name|fixtab
index|[
operator|(
name|int
operator|)
name|DFmode
index|]
index|[
operator|(
name|int
operator|)
name|TImode
index|]
index|[
literal|1
index|]
operator|=
name|CODE_FOR_fixunsdfti2
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_fixunsxfqi2
if|if
condition|(
name|HAVE_fixunsxfqi2
condition|)
name|fixtab
index|[
operator|(
name|int
operator|)
name|XFmode
index|]
index|[
operator|(
name|int
operator|)
name|QImode
index|]
index|[
literal|1
index|]
operator|=
name|CODE_FOR_fixunsxfqi2
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_fixunsxfhi2
if|if
condition|(
name|HAVE_fixunsxfhi2
condition|)
name|fixtab
index|[
operator|(
name|int
operator|)
name|XFmode
index|]
index|[
operator|(
name|int
operator|)
name|HImode
index|]
index|[
literal|1
index|]
operator|=
name|CODE_FOR_fixunsxfhi2
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_fixunsxfsi2
if|if
condition|(
name|HAVE_fixunsxfsi2
condition|)
name|fixtab
index|[
operator|(
name|int
operator|)
name|XFmode
index|]
index|[
operator|(
name|int
operator|)
name|SImode
index|]
index|[
literal|1
index|]
operator|=
name|CODE_FOR_fixunsxfsi2
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_fixunsxfdi2
if|if
condition|(
name|HAVE_fixunsxfdi2
condition|)
name|fixtab
index|[
operator|(
name|int
operator|)
name|XFmode
index|]
index|[
operator|(
name|int
operator|)
name|DImode
index|]
index|[
literal|1
index|]
operator|=
name|CODE_FOR_fixunsxfdi2
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_fixunsxfti2
if|if
condition|(
name|HAVE_fixunsxfti2
condition|)
name|fixtab
index|[
operator|(
name|int
operator|)
name|XFmode
index|]
index|[
operator|(
name|int
operator|)
name|TImode
index|]
index|[
literal|1
index|]
operator|=
name|CODE_FOR_fixunsxfti2
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_fixunstfqi2
if|if
condition|(
name|HAVE_fixunstfqi2
condition|)
name|fixtab
index|[
operator|(
name|int
operator|)
name|TFmode
index|]
index|[
operator|(
name|int
operator|)
name|QImode
index|]
index|[
literal|1
index|]
operator|=
name|CODE_FOR_fixunstfqi2
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_fixunstfhi2
if|if
condition|(
name|HAVE_fixunstfhi2
condition|)
name|fixtab
index|[
operator|(
name|int
operator|)
name|TFmode
index|]
index|[
operator|(
name|int
operator|)
name|HImode
index|]
index|[
literal|1
index|]
operator|=
name|CODE_FOR_fixunstfhi2
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_fixunstfsi2
if|if
condition|(
name|HAVE_fixunstfsi2
condition|)
name|fixtab
index|[
operator|(
name|int
operator|)
name|TFmode
index|]
index|[
operator|(
name|int
operator|)
name|SImode
index|]
index|[
literal|1
index|]
operator|=
name|CODE_FOR_fixunstfsi2
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_fixunstfdi2
if|if
condition|(
name|HAVE_fixunstfdi2
condition|)
name|fixtab
index|[
operator|(
name|int
operator|)
name|TFmode
index|]
index|[
operator|(
name|int
operator|)
name|DImode
index|]
index|[
literal|1
index|]
operator|=
name|CODE_FOR_fixunstfdi2
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_fixunstfti2
if|if
condition|(
name|HAVE_fixunstfti2
condition|)
name|fixtab
index|[
operator|(
name|int
operator|)
name|TFmode
index|]
index|[
operator|(
name|int
operator|)
name|TImode
index|]
index|[
literal|1
index|]
operator|=
name|CODE_FOR_fixunstfti2
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_fix_truncsfqi2
if|if
condition|(
name|HAVE_fix_truncsfqi2
condition|)
name|fixtrunctab
index|[
operator|(
name|int
operator|)
name|SFmode
index|]
index|[
operator|(
name|int
operator|)
name|QImode
index|]
index|[
literal|0
index|]
operator|=
name|CODE_FOR_fix_truncsfqi2
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_fix_truncsfhi2
if|if
condition|(
name|HAVE_fix_truncsfhi2
condition|)
name|fixtrunctab
index|[
operator|(
name|int
operator|)
name|SFmode
index|]
index|[
operator|(
name|int
operator|)
name|HImode
index|]
index|[
literal|0
index|]
operator|=
name|CODE_FOR_fix_truncsfhi2
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_fix_truncsfsi2
if|if
condition|(
name|HAVE_fix_truncsfsi2
condition|)
name|fixtrunctab
index|[
operator|(
name|int
operator|)
name|SFmode
index|]
index|[
operator|(
name|int
operator|)
name|SImode
index|]
index|[
literal|0
index|]
operator|=
name|CODE_FOR_fix_truncsfsi2
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_fix_truncsfdi2
if|if
condition|(
name|HAVE_fix_truncsfdi2
condition|)
name|fixtrunctab
index|[
operator|(
name|int
operator|)
name|SFmode
index|]
index|[
operator|(
name|int
operator|)
name|DImode
index|]
index|[
literal|0
index|]
operator|=
name|CODE_FOR_fix_truncsfdi2
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_fix_truncdfqi2
if|if
condition|(
name|HAVE_fix_truncdfqi2
condition|)
name|fixtrunctab
index|[
operator|(
name|int
operator|)
name|DFmode
index|]
index|[
operator|(
name|int
operator|)
name|QImode
index|]
index|[
literal|0
index|]
operator|=
name|CODE_FOR_fix_truncdfqi2
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_fix_truncdfhi2
if|if
condition|(
name|HAVE_fix_truncdfhi2
condition|)
name|fixtrunctab
index|[
operator|(
name|int
operator|)
name|DFmode
index|]
index|[
operator|(
name|int
operator|)
name|HImode
index|]
index|[
literal|0
index|]
operator|=
name|CODE_FOR_fix_truncdfhi2
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_fix_truncdfsi2
if|if
condition|(
name|HAVE_fix_truncdfsi2
condition|)
name|fixtrunctab
index|[
operator|(
name|int
operator|)
name|DFmode
index|]
index|[
operator|(
name|int
operator|)
name|SImode
index|]
index|[
literal|0
index|]
operator|=
name|CODE_FOR_fix_truncdfsi2
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_fix_truncdfdi2
if|if
condition|(
name|HAVE_fix_truncdfdi2
condition|)
name|fixtrunctab
index|[
operator|(
name|int
operator|)
name|DFmode
index|]
index|[
operator|(
name|int
operator|)
name|DImode
index|]
index|[
literal|0
index|]
operator|=
name|CODE_FOR_fix_truncdfdi2
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_fix_truncdfti2
if|if
condition|(
name|HAVE_fix_truncdfti2
condition|)
name|fixtrunctab
index|[
operator|(
name|int
operator|)
name|DFmode
index|]
index|[
operator|(
name|int
operator|)
name|TImode
index|]
index|[
literal|0
index|]
operator|=
name|CODE_FOR_fix_truncdfti2
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_fix_truncxfqi2
if|if
condition|(
name|HAVE_fix_truncxfqi2
condition|)
name|fixtrunctab
index|[
operator|(
name|int
operator|)
name|XFmode
index|]
index|[
operator|(
name|int
operator|)
name|QImode
index|]
index|[
literal|0
index|]
operator|=
name|CODE_FOR_fix_truncxfqi2
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_fix_truncxfhi2
if|if
condition|(
name|HAVE_fix_truncxfhi2
condition|)
name|fixtrunctab
index|[
operator|(
name|int
operator|)
name|XFmode
index|]
index|[
operator|(
name|int
operator|)
name|HImode
index|]
index|[
literal|0
index|]
operator|=
name|CODE_FOR_fix_truncxfhi2
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_fix_truncxfsi2
if|if
condition|(
name|HAVE_fix_truncxfsi2
condition|)
name|fixtrunctab
index|[
operator|(
name|int
operator|)
name|XFmode
index|]
index|[
operator|(
name|int
operator|)
name|SImode
index|]
index|[
literal|0
index|]
operator|=
name|CODE_FOR_fix_truncxfsi2
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_fix_truncxfdi2
if|if
condition|(
name|HAVE_fix_truncxfdi2
condition|)
name|fixtrunctab
index|[
operator|(
name|int
operator|)
name|XFmode
index|]
index|[
operator|(
name|int
operator|)
name|DImode
index|]
index|[
literal|0
index|]
operator|=
name|CODE_FOR_fix_truncxfdi2
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_fix_truncxfti2
if|if
condition|(
name|HAVE_fix_truncxfti2
condition|)
name|fixtrunctab
index|[
operator|(
name|int
operator|)
name|XFmode
index|]
index|[
operator|(
name|int
operator|)
name|TImode
index|]
index|[
literal|0
index|]
operator|=
name|CODE_FOR_fix_truncxfti2
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_fix_trunctfqi2
if|if
condition|(
name|HAVE_fix_trunctfqi2
condition|)
name|fixtrunctab
index|[
operator|(
name|int
operator|)
name|TFmode
index|]
index|[
operator|(
name|int
operator|)
name|QImode
index|]
index|[
literal|0
index|]
operator|=
name|CODE_FOR_fix_trunctfqi2
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_fix_trunctfhi2
if|if
condition|(
name|HAVE_fix_trunctfhi2
condition|)
name|fixtrunctab
index|[
operator|(
name|int
operator|)
name|TFmode
index|]
index|[
operator|(
name|int
operator|)
name|HImode
index|]
index|[
literal|0
index|]
operator|=
name|CODE_FOR_fix_trunctfhi2
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_fix_trunctfsi2
if|if
condition|(
name|HAVE_fix_trunctfsi2
condition|)
name|fixtrunctab
index|[
operator|(
name|int
operator|)
name|TFmode
index|]
index|[
operator|(
name|int
operator|)
name|SImode
index|]
index|[
literal|0
index|]
operator|=
name|CODE_FOR_fix_trunctfsi2
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_fix_trunctfdi2
if|if
condition|(
name|HAVE_fix_trunctfdi2
condition|)
name|fixtrunctab
index|[
operator|(
name|int
operator|)
name|TFmode
index|]
index|[
operator|(
name|int
operator|)
name|DImode
index|]
index|[
literal|0
index|]
operator|=
name|CODE_FOR_fix_trunctfdi2
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_fix_trunctfti2
if|if
condition|(
name|HAVE_fix_trunctfti2
condition|)
name|fixtrunctab
index|[
operator|(
name|int
operator|)
name|TFmode
index|]
index|[
operator|(
name|int
operator|)
name|TImode
index|]
index|[
literal|0
index|]
operator|=
name|CODE_FOR_fix_trunctfti2
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_fixuns_truncsfqi2
if|if
condition|(
name|HAVE_fixuns_truncsfqi2
condition|)
name|fixtrunctab
index|[
operator|(
name|int
operator|)
name|SFmode
index|]
index|[
operator|(
name|int
operator|)
name|QImode
index|]
index|[
literal|1
index|]
operator|=
name|CODE_FOR_fixuns_truncsfqi2
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_fixuns_truncsfhi2
if|if
condition|(
name|HAVE_fixuns_truncsfhi2
condition|)
name|fixtrunctab
index|[
operator|(
name|int
operator|)
name|SFmode
index|]
index|[
operator|(
name|int
operator|)
name|HImode
index|]
index|[
literal|1
index|]
operator|=
name|CODE_FOR_fixuns_truncsfhi2
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_fixuns_truncsfsi2
if|if
condition|(
name|HAVE_fixuns_truncsfsi2
condition|)
name|fixtrunctab
index|[
operator|(
name|int
operator|)
name|SFmode
index|]
index|[
operator|(
name|int
operator|)
name|SImode
index|]
index|[
literal|1
index|]
operator|=
name|CODE_FOR_fixuns_truncsfsi2
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_fixuns_truncsfdi2
if|if
condition|(
name|HAVE_fixuns_truncsfdi2
condition|)
name|fixtrunctab
index|[
operator|(
name|int
operator|)
name|SFmode
index|]
index|[
operator|(
name|int
operator|)
name|DImode
index|]
index|[
literal|1
index|]
operator|=
name|CODE_FOR_fixuns_truncsfdi2
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_fixuns_truncdfqi2
if|if
condition|(
name|HAVE_fixuns_truncdfqi2
condition|)
name|fixtrunctab
index|[
operator|(
name|int
operator|)
name|DFmode
index|]
index|[
operator|(
name|int
operator|)
name|QImode
index|]
index|[
literal|1
index|]
operator|=
name|CODE_FOR_fixuns_truncdfqi2
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_fixuns_truncdfhi2
if|if
condition|(
name|HAVE_fixuns_truncdfhi2
condition|)
name|fixtrunctab
index|[
operator|(
name|int
operator|)
name|DFmode
index|]
index|[
operator|(
name|int
operator|)
name|HImode
index|]
index|[
literal|1
index|]
operator|=
name|CODE_FOR_fixuns_truncdfhi2
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_fixuns_truncdfsi2
if|if
condition|(
name|HAVE_fixuns_truncdfsi2
condition|)
name|fixtrunctab
index|[
operator|(
name|int
operator|)
name|DFmode
index|]
index|[
operator|(
name|int
operator|)
name|SImode
index|]
index|[
literal|1
index|]
operator|=
name|CODE_FOR_fixuns_truncdfsi2
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_fixuns_truncdfdi2
if|if
condition|(
name|HAVE_fixuns_truncdfdi2
condition|)
name|fixtrunctab
index|[
operator|(
name|int
operator|)
name|DFmode
index|]
index|[
operator|(
name|int
operator|)
name|DImode
index|]
index|[
literal|1
index|]
operator|=
name|CODE_FOR_fixuns_truncdfdi2
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_fixuns_truncdfti2
if|if
condition|(
name|HAVE_fixuns_truncdfti2
condition|)
name|fixtrunctab
index|[
operator|(
name|int
operator|)
name|DFmode
index|]
index|[
operator|(
name|int
operator|)
name|TImode
index|]
index|[
literal|1
index|]
operator|=
name|CODE_FOR_fixuns_truncdfti2
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_fixuns_truncxfqi2
if|if
condition|(
name|HAVE_fixuns_truncxfqi2
condition|)
name|fixtrunctab
index|[
operator|(
name|int
operator|)
name|XFmode
index|]
index|[
operator|(
name|int
operator|)
name|QImode
index|]
index|[
literal|1
index|]
operator|=
name|CODE_FOR_fixuns_truncxfqi2
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_fixuns_truncxfhi2
if|if
condition|(
name|HAVE_fixuns_truncxfhi2
condition|)
name|fixtrunctab
index|[
operator|(
name|int
operator|)
name|XFmode
index|]
index|[
operator|(
name|int
operator|)
name|HImode
index|]
index|[
literal|1
index|]
operator|=
name|CODE_FOR_fixuns_truncxfhi2
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_fixuns_truncxfsi2
if|if
condition|(
name|HAVE_fixuns_truncxfsi2
condition|)
name|fixtrunctab
index|[
operator|(
name|int
operator|)
name|XFmode
index|]
index|[
operator|(
name|int
operator|)
name|SImode
index|]
index|[
literal|1
index|]
operator|=
name|CODE_FOR_fixuns_truncxfsi2
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_fixuns_truncxfdi2
if|if
condition|(
name|HAVE_fixuns_truncxfdi2
condition|)
name|fixtrunctab
index|[
operator|(
name|int
operator|)
name|XFmode
index|]
index|[
operator|(
name|int
operator|)
name|DImode
index|]
index|[
literal|1
index|]
operator|=
name|CODE_FOR_fixuns_truncxfdi2
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_fixuns_truncxfti2
if|if
condition|(
name|HAVE_fixuns_truncxfti2
condition|)
name|fixtrunctab
index|[
operator|(
name|int
operator|)
name|XFmode
index|]
index|[
operator|(
name|int
operator|)
name|TImode
index|]
index|[
literal|1
index|]
operator|=
name|CODE_FOR_fixuns_truncxfti2
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_fixuns_trunctfqi2
if|if
condition|(
name|HAVE_fixuns_trunctfqi2
condition|)
name|fixtrunctab
index|[
operator|(
name|int
operator|)
name|TFmode
index|]
index|[
operator|(
name|int
operator|)
name|QImode
index|]
index|[
literal|1
index|]
operator|=
name|CODE_FOR_fixuns_trunctfqi2
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_fixuns_trunctfhi2
if|if
condition|(
name|HAVE_fixuns_trunctfhi2
condition|)
name|fixtrunctab
index|[
operator|(
name|int
operator|)
name|TFmode
index|]
index|[
operator|(
name|int
operator|)
name|HImode
index|]
index|[
literal|1
index|]
operator|=
name|CODE_FOR_fixuns_trunctfhi2
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_fixuns_trunctfsi2
if|if
condition|(
name|HAVE_fixuns_trunctfsi2
condition|)
name|fixtrunctab
index|[
operator|(
name|int
operator|)
name|TFmode
index|]
index|[
operator|(
name|int
operator|)
name|SImode
index|]
index|[
literal|1
index|]
operator|=
name|CODE_FOR_fixuns_trunctfsi2
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_fixuns_trunctfdi2
if|if
condition|(
name|HAVE_fixuns_trunctfdi2
condition|)
name|fixtrunctab
index|[
operator|(
name|int
operator|)
name|TFmode
index|]
index|[
operator|(
name|int
operator|)
name|DImode
index|]
index|[
literal|1
index|]
operator|=
name|CODE_FOR_fixuns_trunctfdi2
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_fixuns_trunctfti2
if|if
condition|(
name|HAVE_fixuns_trunctfti2
condition|)
name|fixtrunctab
index|[
operator|(
name|int
operator|)
name|TFmode
index|]
index|[
operator|(
name|int
operator|)
name|TImode
index|]
index|[
literal|1
index|]
operator|=
name|CODE_FOR_fixuns_trunctfti2
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|FIXUNS_TRUNC_LIKE_FIX_TRUNC
comment|/* This flag says the same insns that convert to a signed fixnum      also convert validly to an unsigned one.  */
block|{
name|int
name|i
decl_stmt|;
name|int
name|j
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_MACHINE_MODES
condition|;
name|i
operator|++
control|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|NUM_MACHINE_MODES
condition|;
name|j
operator|++
control|)
name|fixtrunctab
index|[
name|i
index|]
index|[
name|j
index|]
index|[
literal|1
index|]
operator|=
name|fixtrunctab
index|[
name|i
index|]
index|[
name|j
index|]
index|[
literal|0
index|]
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function

begin_function
name|void
name|init_floattab
parameter_list|()
block|{
name|enum
name|insn_code
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|p
operator|=
name|floattab
index|[
literal|0
index|]
index|[
literal|0
index|]
init|;
name|p
operator|<
name|floattab
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|+
sizeof|sizeof
name|floattab
operator|/
sizeof|sizeof
argument_list|(
name|floattab
index|[
literal|0
index|]
index|[
literal|0
index|]
index|[
literal|0
index|]
argument_list|)
condition|;
name|p
operator|++
control|)
operator|*
name|p
operator|=
name|CODE_FOR_nothing
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_floatqisf2
if|if
condition|(
name|HAVE_floatqisf2
condition|)
name|floattab
index|[
operator|(
name|int
operator|)
name|SFmode
index|]
index|[
operator|(
name|int
operator|)
name|QImode
index|]
index|[
literal|0
index|]
operator|=
name|CODE_FOR_floatqisf2
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_floathisf2
if|if
condition|(
name|HAVE_floathisf2
condition|)
name|floattab
index|[
operator|(
name|int
operator|)
name|SFmode
index|]
index|[
operator|(
name|int
operator|)
name|HImode
index|]
index|[
literal|0
index|]
operator|=
name|CODE_FOR_floathisf2
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_floatsisf2
if|if
condition|(
name|HAVE_floatsisf2
condition|)
name|floattab
index|[
operator|(
name|int
operator|)
name|SFmode
index|]
index|[
operator|(
name|int
operator|)
name|SImode
index|]
index|[
literal|0
index|]
operator|=
name|CODE_FOR_floatsisf2
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_floatdisf2
if|if
condition|(
name|HAVE_floatdisf2
condition|)
name|floattab
index|[
operator|(
name|int
operator|)
name|SFmode
index|]
index|[
operator|(
name|int
operator|)
name|DImode
index|]
index|[
literal|0
index|]
operator|=
name|CODE_FOR_floatdisf2
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_floattisf2
if|if
condition|(
name|HAVE_floattisf2
condition|)
name|floattab
index|[
operator|(
name|int
operator|)
name|SFmode
index|]
index|[
operator|(
name|int
operator|)
name|TImode
index|]
index|[
literal|0
index|]
operator|=
name|CODE_FOR_floattisf2
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_floatqidf2
if|if
condition|(
name|HAVE_floatqidf2
condition|)
name|floattab
index|[
operator|(
name|int
operator|)
name|DFmode
index|]
index|[
operator|(
name|int
operator|)
name|QImode
index|]
index|[
literal|0
index|]
operator|=
name|CODE_FOR_floatqidf2
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_floathidf2
if|if
condition|(
name|HAVE_floathidf2
condition|)
name|floattab
index|[
operator|(
name|int
operator|)
name|DFmode
index|]
index|[
operator|(
name|int
operator|)
name|HImode
index|]
index|[
literal|0
index|]
operator|=
name|CODE_FOR_floathidf2
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_floatsidf2
if|if
condition|(
name|HAVE_floatsidf2
condition|)
name|floattab
index|[
operator|(
name|int
operator|)
name|DFmode
index|]
index|[
operator|(
name|int
operator|)
name|SImode
index|]
index|[
literal|0
index|]
operator|=
name|CODE_FOR_floatsidf2
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_floatdidf2
if|if
condition|(
name|HAVE_floatdidf2
condition|)
name|floattab
index|[
operator|(
name|int
operator|)
name|DFmode
index|]
index|[
operator|(
name|int
operator|)
name|DImode
index|]
index|[
literal|0
index|]
operator|=
name|CODE_FOR_floatdidf2
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_floattidf2
if|if
condition|(
name|HAVE_floattidf2
condition|)
name|floattab
index|[
operator|(
name|int
operator|)
name|DFmode
index|]
index|[
operator|(
name|int
operator|)
name|TImode
index|]
index|[
literal|0
index|]
operator|=
name|CODE_FOR_floattidf2
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_floatqixf2
if|if
condition|(
name|HAVE_floatqixf2
condition|)
name|floattab
index|[
operator|(
name|int
operator|)
name|XFmode
index|]
index|[
operator|(
name|int
operator|)
name|QImode
index|]
index|[
literal|0
index|]
operator|=
name|CODE_FOR_floatqixf2
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_floathixf2
if|if
condition|(
name|HAVE_floathixf2
condition|)
name|floattab
index|[
operator|(
name|int
operator|)
name|XFmode
index|]
index|[
operator|(
name|int
operator|)
name|HImode
index|]
index|[
literal|0
index|]
operator|=
name|CODE_FOR_floathixf2
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_floatsixf2
if|if
condition|(
name|HAVE_floatsixf2
condition|)
name|floattab
index|[
operator|(
name|int
operator|)
name|XFmode
index|]
index|[
operator|(
name|int
operator|)
name|SImode
index|]
index|[
literal|0
index|]
operator|=
name|CODE_FOR_floatsixf2
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_floatdixf2
if|if
condition|(
name|HAVE_floatdixf2
condition|)
name|floattab
index|[
operator|(
name|int
operator|)
name|XFmode
index|]
index|[
operator|(
name|int
operator|)
name|DImode
index|]
index|[
literal|0
index|]
operator|=
name|CODE_FOR_floatdixf2
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_floattixf2
if|if
condition|(
name|HAVE_floattixf2
condition|)
name|floattab
index|[
operator|(
name|int
operator|)
name|XFmode
index|]
index|[
operator|(
name|int
operator|)
name|TImode
index|]
index|[
literal|0
index|]
operator|=
name|CODE_FOR_floattixf2
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_floatqitf2
if|if
condition|(
name|HAVE_floatqitf2
condition|)
name|floattab
index|[
operator|(
name|int
operator|)
name|TFmode
index|]
index|[
operator|(
name|int
operator|)
name|QImode
index|]
index|[
literal|0
index|]
operator|=
name|CODE_FOR_floatqitf2
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_floathitf2
if|if
condition|(
name|HAVE_floathitf2
condition|)
name|floattab
index|[
operator|(
name|int
operator|)
name|TFmode
index|]
index|[
operator|(
name|int
operator|)
name|HImode
index|]
index|[
literal|0
index|]
operator|=
name|CODE_FOR_floathitf2
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_floatsitf2
if|if
condition|(
name|HAVE_floatsitf2
condition|)
name|floattab
index|[
operator|(
name|int
operator|)
name|TFmode
index|]
index|[
operator|(
name|int
operator|)
name|SImode
index|]
index|[
literal|0
index|]
operator|=
name|CODE_FOR_floatsitf2
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_floatditf2
if|if
condition|(
name|HAVE_floatditf2
condition|)
name|floattab
index|[
operator|(
name|int
operator|)
name|TFmode
index|]
index|[
operator|(
name|int
operator|)
name|DImode
index|]
index|[
literal|0
index|]
operator|=
name|CODE_FOR_floatditf2
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_floattitf2
if|if
condition|(
name|HAVE_floattitf2
condition|)
name|floattab
index|[
operator|(
name|int
operator|)
name|TFmode
index|]
index|[
operator|(
name|int
operator|)
name|TImode
index|]
index|[
literal|0
index|]
operator|=
name|CODE_FOR_floattitf2
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_floatunsqisf2
if|if
condition|(
name|HAVE_floatunsqisf2
condition|)
name|floattab
index|[
operator|(
name|int
operator|)
name|SFmode
index|]
index|[
operator|(
name|int
operator|)
name|QImode
index|]
index|[
literal|1
index|]
operator|=
name|CODE_FOR_floatunsqisf2
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_floatunshisf2
if|if
condition|(
name|HAVE_floatunshisf2
condition|)
name|floattab
index|[
operator|(
name|int
operator|)
name|SFmode
index|]
index|[
operator|(
name|int
operator|)
name|HImode
index|]
index|[
literal|1
index|]
operator|=
name|CODE_FOR_floatunshisf2
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_floatunssisf2
if|if
condition|(
name|HAVE_floatunssisf2
condition|)
name|floattab
index|[
operator|(
name|int
operator|)
name|SFmode
index|]
index|[
operator|(
name|int
operator|)
name|SImode
index|]
index|[
literal|1
index|]
operator|=
name|CODE_FOR_floatunssisf2
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_floatunsdisf2
if|if
condition|(
name|HAVE_floatunsdisf2
condition|)
name|floattab
index|[
operator|(
name|int
operator|)
name|SFmode
index|]
index|[
operator|(
name|int
operator|)
name|DImode
index|]
index|[
literal|1
index|]
operator|=
name|CODE_FOR_floatunsdisf2
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_floatunstisf2
if|if
condition|(
name|HAVE_floatunstisf2
condition|)
name|floattab
index|[
operator|(
name|int
operator|)
name|SFmode
index|]
index|[
operator|(
name|int
operator|)
name|TImode
index|]
index|[
literal|1
index|]
operator|=
name|CODE_FOR_floatunstisf2
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_floatunsqidf2
if|if
condition|(
name|HAVE_floatunsqidf2
condition|)
name|floattab
index|[
operator|(
name|int
operator|)
name|DFmode
index|]
index|[
operator|(
name|int
operator|)
name|QImode
index|]
index|[
literal|1
index|]
operator|=
name|CODE_FOR_floatunsqidf2
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_floatunshidf2
if|if
condition|(
name|HAVE_floatunshidf2
condition|)
name|floattab
index|[
operator|(
name|int
operator|)
name|DFmode
index|]
index|[
operator|(
name|int
operator|)
name|HImode
index|]
index|[
literal|1
index|]
operator|=
name|CODE_FOR_floatunshidf2
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_floatunssidf2
if|if
condition|(
name|HAVE_floatunssidf2
condition|)
name|floattab
index|[
operator|(
name|int
operator|)
name|DFmode
index|]
index|[
operator|(
name|int
operator|)
name|SImode
index|]
index|[
literal|1
index|]
operator|=
name|CODE_FOR_floatunssidf2
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_floatunsdidf2
if|if
condition|(
name|HAVE_floatunsdidf2
condition|)
name|floattab
index|[
operator|(
name|int
operator|)
name|DFmode
index|]
index|[
operator|(
name|int
operator|)
name|DImode
index|]
index|[
literal|1
index|]
operator|=
name|CODE_FOR_floatunsdidf2
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_floatunstidf2
if|if
condition|(
name|HAVE_floatunstidf2
condition|)
name|floattab
index|[
operator|(
name|int
operator|)
name|DFmode
index|]
index|[
operator|(
name|int
operator|)
name|TImode
index|]
index|[
literal|1
index|]
operator|=
name|CODE_FOR_floatunstidf2
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_floatunsqixf2
if|if
condition|(
name|HAVE_floatunsqixf2
condition|)
name|floattab
index|[
operator|(
name|int
operator|)
name|XFmode
index|]
index|[
operator|(
name|int
operator|)
name|QImode
index|]
index|[
literal|1
index|]
operator|=
name|CODE_FOR_floatunsqixf2
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_floatunshixf2
if|if
condition|(
name|HAVE_floatunshixf2
condition|)
name|floattab
index|[
operator|(
name|int
operator|)
name|XFmode
index|]
index|[
operator|(
name|int
operator|)
name|HImode
index|]
index|[
literal|1
index|]
operator|=
name|CODE_FOR_floatunshixf2
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_floatunssixf2
if|if
condition|(
name|HAVE_floatunssixf2
condition|)
name|floattab
index|[
operator|(
name|int
operator|)
name|XFmode
index|]
index|[
operator|(
name|int
operator|)
name|SImode
index|]
index|[
literal|1
index|]
operator|=
name|CODE_FOR_floatunssixf2
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_floatunsdixf2
if|if
condition|(
name|HAVE_floatunsdixf2
condition|)
name|floattab
index|[
operator|(
name|int
operator|)
name|XFmode
index|]
index|[
operator|(
name|int
operator|)
name|DImode
index|]
index|[
literal|1
index|]
operator|=
name|CODE_FOR_floatunsdixf2
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_floatunstixf2
if|if
condition|(
name|HAVE_floatunstixf2
condition|)
name|floattab
index|[
operator|(
name|int
operator|)
name|XFmode
index|]
index|[
operator|(
name|int
operator|)
name|TImode
index|]
index|[
literal|1
index|]
operator|=
name|CODE_FOR_floatunstixf2
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_floatunsqitf2
if|if
condition|(
name|HAVE_floatunsqitf2
condition|)
name|floattab
index|[
operator|(
name|int
operator|)
name|TFmode
index|]
index|[
operator|(
name|int
operator|)
name|QImode
index|]
index|[
literal|1
index|]
operator|=
name|CODE_FOR_floatunsqitf2
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_floatunshitf2
if|if
condition|(
name|HAVE_floatunshitf2
condition|)
name|floattab
index|[
operator|(
name|int
operator|)
name|TFmode
index|]
index|[
operator|(
name|int
operator|)
name|HImode
index|]
index|[
literal|1
index|]
operator|=
name|CODE_FOR_floatunshitf2
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_floatunssitf2
if|if
condition|(
name|HAVE_floatunssitf2
condition|)
name|floattab
index|[
operator|(
name|int
operator|)
name|TFmode
index|]
index|[
operator|(
name|int
operator|)
name|SImode
index|]
index|[
literal|1
index|]
operator|=
name|CODE_FOR_floatunssitf2
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_floatunsditf2
if|if
condition|(
name|HAVE_floatunsditf2
condition|)
name|floattab
index|[
operator|(
name|int
operator|)
name|TFmode
index|]
index|[
operator|(
name|int
operator|)
name|DImode
index|]
index|[
literal|1
index|]
operator|=
name|CODE_FOR_floatunsditf2
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_floatunstitf2
if|if
condition|(
name|HAVE_floatunstitf2
condition|)
name|floattab
index|[
operator|(
name|int
operator|)
name|TFmode
index|]
index|[
operator|(
name|int
operator|)
name|TImode
index|]
index|[
literal|1
index|]
operator|=
name|CODE_FOR_floatunstitf2
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Generate code to convert FROM to floating point    and store in TO.  FROM must be fixed point and not VOIDmode.    UNSIGNEDP nonzero means regard FROM as unsigned.    Normally this is done by correcting the final value    if it is negative.  */
end_comment

begin_function
name|void
name|expand_float
parameter_list|(
name|to
parameter_list|,
name|from
parameter_list|,
name|unsignedp
parameter_list|)
name|rtx
name|to
decl_stmt|,
name|from
decl_stmt|;
name|int
name|unsignedp
decl_stmt|;
block|{
name|enum
name|insn_code
name|icode
decl_stmt|;
specifier|register
name|rtx
name|target
init|=
name|to
decl_stmt|;
name|enum
name|machine_mode
name|fmode
decl_stmt|,
name|imode
decl_stmt|;
comment|/* Crash now, because we won't be able to decide which mode to use.  */
if|if
condition|(
name|GET_MODE
argument_list|(
name|from
argument_list|)
operator|==
name|VOIDmode
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Look for an insn to do the conversion.  Do it in the specified      modes if possible; otherwise convert either input, output or both to      wider mode.  If the integer mode is wider than the mode of FROM,      we can do the conversion signed even if the input is unsigned.  */
for|for
control|(
name|imode
operator|=
name|GET_MODE
argument_list|(
name|from
argument_list|)
init|;
name|imode
operator|!=
name|VOIDmode
condition|;
name|imode
operator|=
name|GET_MODE_WIDER_MODE
argument_list|(
name|imode
argument_list|)
control|)
for|for
control|(
name|fmode
operator|=
name|GET_MODE
argument_list|(
name|to
argument_list|)
init|;
name|fmode
operator|!=
name|VOIDmode
condition|;
name|fmode
operator|=
name|GET_MODE_WIDER_MODE
argument_list|(
name|fmode
argument_list|)
control|)
block|{
name|int
name|doing_unsigned
init|=
name|unsignedp
decl_stmt|;
name|icode
operator|=
name|can_float_p
argument_list|(
name|fmode
argument_list|,
name|imode
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
if|if
condition|(
name|icode
operator|==
name|CODE_FOR_nothing
operator|&&
name|imode
operator|!=
name|GET_MODE
argument_list|(
name|from
argument_list|)
operator|&&
name|unsignedp
condition|)
name|icode
operator|=
name|can_float_p
argument_list|(
name|fmode
argument_list|,
name|imode
argument_list|,
literal|0
argument_list|)
operator|,
name|doing_unsigned
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|icode
operator|!=
name|CODE_FOR_nothing
condition|)
block|{
name|to
operator|=
name|protect_from_queue
argument_list|(
name|to
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|from
operator|=
name|protect_from_queue
argument_list|(
name|from
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|imode
operator|!=
name|GET_MODE
argument_list|(
name|from
argument_list|)
condition|)
name|from
operator|=
name|convert_to_mode
argument_list|(
name|imode
argument_list|,
name|from
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
if|if
condition|(
name|fmode
operator|!=
name|GET_MODE
argument_list|(
name|to
argument_list|)
condition|)
name|target
operator|=
name|gen_reg_rtx
argument_list|(
name|fmode
argument_list|)
expr_stmt|;
name|emit_unop_insn
argument_list|(
name|icode
argument_list|,
name|target
argument_list|,
name|from
argument_list|,
name|doing_unsigned
condition|?
name|UNSIGNED_FLOAT
else|:
name|FLOAT
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
operator|!=
name|to
condition|)
name|convert_move
argument_list|(
name|to
argument_list|,
name|target
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
if|#
directive|if
operator|!
name|defined
argument_list|(
name|REAL_IS_NOT_DOUBLE
argument_list|)
operator|||
name|defined
argument_list|(
name|REAL_ARITHMETIC
argument_list|)
comment|/* Unsigned integer, and no way to convert directly.      Convert as signed, then conditionally adjust the result.  */
if|if
condition|(
name|unsignedp
condition|)
block|{
name|rtx
name|label
init|=
name|gen_label_rtx
argument_list|()
decl_stmt|;
name|rtx
name|temp
decl_stmt|;
name|REAL_VALUE_TYPE
name|offset
decl_stmt|;
name|emit_queue
argument_list|()
expr_stmt|;
name|to
operator|=
name|protect_from_queue
argument_list|(
name|to
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|from
operator|=
name|protect_from_queue
argument_list|(
name|from
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_force_mem
condition|)
name|from
operator|=
name|force_not_mem
argument_list|(
name|from
argument_list|)
expr_stmt|;
comment|/* If we are about to do some arithmetic to correct for an 	 unsigned operand, do it in a pseudo-register.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|to
argument_list|)
operator|!=
name|REG
operator|||
name|REGNO
argument_list|(
name|to
argument_list|)
operator|<=
name|LAST_VIRTUAL_REGISTER
condition|)
name|target
operator|=
name|gen_reg_rtx
argument_list|(
name|GET_MODE
argument_list|(
name|to
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Convert as signed integer to floating.  */
name|expand_float
argument_list|(
name|target
argument_list|,
name|from
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* If FROM is negative (and therefore TO is negative), 	 correct its value by 2**bitwidth.  */
name|do_pending_stack_adjust
argument_list|()
expr_stmt|;
name|emit_cmp_insn
argument_list|(
name|from
argument_list|,
name|const0_rtx
argument_list|,
name|GE
argument_list|,
name|NULL_RTX
argument_list|,
name|GET_MODE
argument_list|(
name|from
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emit_jump_insn
argument_list|(
name|gen_bge
argument_list|(
name|label
argument_list|)
argument_list|)
expr_stmt|;
comment|/* On SCO 3.2.1, ldexp rejects values outside [0.5, 1). 	 Rather than setting up a dconst_dot_5, let's hope SCO 	 fixes the bug.  */
name|offset
operator|=
name|REAL_VALUE_LDEXP
argument_list|(
name|dconst1
argument_list|,
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|from
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|temp
operator|=
name|expand_binop
argument_list|(
name|GET_MODE
argument_list|(
name|to
argument_list|)
argument_list|,
name|add_optab
argument_list|,
name|target
argument_list|,
name|immed_real_const_1
argument_list|(
name|offset
argument_list|,
name|GET_MODE
argument_list|(
name|to
argument_list|)
argument_list|)
argument_list|,
name|target
argument_list|,
literal|0
argument_list|,
name|OPTAB_LIB_WIDEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|!=
name|target
condition|)
name|emit_move_insn
argument_list|(
name|target
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|do_pending_stack_adjust
argument_list|()
expr_stmt|;
name|emit_label
argument_list|(
name|label
argument_list|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
comment|/* No hardware instruction available; call a library rotine to convert from      SImode, DImode, or TImode into SFmode, DFmode, XFmode, or TFmode.  */
block|{
name|rtx
name|libfcn
decl_stmt|;
name|rtx
name|insns
decl_stmt|;
name|to
operator|=
name|protect_from_queue
argument_list|(
name|to
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|from
operator|=
name|protect_from_queue
argument_list|(
name|from
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|from
argument_list|)
argument_list|)
operator|<
name|GET_MODE_SIZE
argument_list|(
name|SImode
argument_list|)
condition|)
name|from
operator|=
name|convert_to_mode
argument_list|(
name|SImode
argument_list|,
name|from
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_force_mem
condition|)
name|from
operator|=
name|force_not_mem
argument_list|(
name|from
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|to
argument_list|)
operator|==
name|SFmode
condition|)
block|{
if|if
condition|(
name|GET_MODE
argument_list|(
name|from
argument_list|)
operator|==
name|SImode
condition|)
name|libfcn
operator|=
name|floatsisf_libfunc
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_MODE
argument_list|(
name|from
argument_list|)
operator|==
name|DImode
condition|)
name|libfcn
operator|=
name|floatdisf_libfunc
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_MODE
argument_list|(
name|from
argument_list|)
operator|==
name|TImode
condition|)
name|libfcn
operator|=
name|floattisf_libfunc
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_MODE
argument_list|(
name|to
argument_list|)
operator|==
name|DFmode
condition|)
block|{
if|if
condition|(
name|GET_MODE
argument_list|(
name|from
argument_list|)
operator|==
name|SImode
condition|)
name|libfcn
operator|=
name|floatsidf_libfunc
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_MODE
argument_list|(
name|from
argument_list|)
operator|==
name|DImode
condition|)
name|libfcn
operator|=
name|floatdidf_libfunc
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_MODE
argument_list|(
name|from
argument_list|)
operator|==
name|TImode
condition|)
name|libfcn
operator|=
name|floattidf_libfunc
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_MODE
argument_list|(
name|to
argument_list|)
operator|==
name|XFmode
condition|)
block|{
if|if
condition|(
name|GET_MODE
argument_list|(
name|from
argument_list|)
operator|==
name|SImode
condition|)
name|libfcn
operator|=
name|floatsixf_libfunc
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_MODE
argument_list|(
name|from
argument_list|)
operator|==
name|DImode
condition|)
name|libfcn
operator|=
name|floatdixf_libfunc
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_MODE
argument_list|(
name|from
argument_list|)
operator|==
name|TImode
condition|)
name|libfcn
operator|=
name|floattixf_libfunc
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_MODE
argument_list|(
name|to
argument_list|)
operator|==
name|TFmode
condition|)
block|{
if|if
condition|(
name|GET_MODE
argument_list|(
name|from
argument_list|)
operator|==
name|SImode
condition|)
name|libfcn
operator|=
name|floatsitf_libfunc
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_MODE
argument_list|(
name|from
argument_list|)
operator|==
name|DImode
condition|)
name|libfcn
operator|=
name|floatditf_libfunc
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_MODE
argument_list|(
name|from
argument_list|)
operator|==
name|TImode
condition|)
name|libfcn
operator|=
name|floattitf_libfunc
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
block|}
else|else
name|abort
argument_list|()
expr_stmt|;
name|start_sequence
argument_list|()
expr_stmt|;
name|emit_library_call
argument_list|(
name|libfcn
argument_list|,
literal|1
argument_list|,
name|GET_MODE
argument_list|(
name|to
argument_list|)
argument_list|,
literal|1
argument_list|,
name|from
argument_list|,
name|GET_MODE
argument_list|(
name|from
argument_list|)
argument_list|)
expr_stmt|;
name|insns
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
name|emit_libcall_block
argument_list|(
name|insns
argument_list|,
name|target
argument_list|,
name|hard_libcall_value
argument_list|(
name|GET_MODE
argument_list|(
name|to
argument_list|)
argument_list|)
argument_list|,
name|gen_rtx
argument_list|(
name|FLOAT
argument_list|,
name|GET_MODE
argument_list|(
name|to
argument_list|)
argument_list|,
name|from
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Copy result to requested destination      if we have been computing in a temp location.  */
if|if
condition|(
name|target
operator|!=
name|to
condition|)
block|{
if|if
condition|(
name|GET_MODE
argument_list|(
name|target
argument_list|)
operator|==
name|GET_MODE
argument_list|(
name|to
argument_list|)
condition|)
name|emit_move_insn
argument_list|(
name|to
argument_list|,
name|target
argument_list|)
expr_stmt|;
else|else
name|convert_move
argument_list|(
name|to
argument_list|,
name|target
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* expand_fix: generate code to convert FROM to fixed point    and store in TO.  FROM must be floating point.  */
end_comment

begin_function
specifier|static
name|rtx
name|ftruncify
parameter_list|(
name|x
parameter_list|)
name|rtx
name|x
decl_stmt|;
block|{
name|rtx
name|temp
init|=
name|gen_reg_rtx
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
decl_stmt|;
return|return
name|expand_unop
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|ftrunc_optab
argument_list|,
name|x
argument_list|,
name|temp
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_function
name|void
name|expand_fix
parameter_list|(
name|to
parameter_list|,
name|from
parameter_list|,
name|unsignedp
parameter_list|)
specifier|register
name|rtx
name|to
decl_stmt|,
name|from
decl_stmt|;
name|int
name|unsignedp
decl_stmt|;
block|{
name|enum
name|insn_code
name|icode
decl_stmt|;
specifier|register
name|rtx
name|target
init|=
name|to
decl_stmt|;
name|enum
name|machine_mode
name|fmode
decl_stmt|,
name|imode
decl_stmt|;
name|int
name|must_trunc
init|=
literal|0
decl_stmt|;
name|rtx
name|libfcn
init|=
literal|0
decl_stmt|;
comment|/* We first try to find a pair of modes, one real and one integer, at      least as wide as FROM and TO, respectively, in which we can open-code      this conversion.  If the integer mode is wider than the mode of TO,      we can do the conversion either signed or unsigned.  */
for|for
control|(
name|imode
operator|=
name|GET_MODE
argument_list|(
name|to
argument_list|)
init|;
name|imode
operator|!=
name|VOIDmode
condition|;
name|imode
operator|=
name|GET_MODE_WIDER_MODE
argument_list|(
name|imode
argument_list|)
control|)
for|for
control|(
name|fmode
operator|=
name|GET_MODE
argument_list|(
name|from
argument_list|)
init|;
name|fmode
operator|!=
name|VOIDmode
condition|;
name|fmode
operator|=
name|GET_MODE_WIDER_MODE
argument_list|(
name|fmode
argument_list|)
control|)
block|{
name|int
name|doing_unsigned
init|=
name|unsignedp
decl_stmt|;
name|icode
operator|=
name|can_fix_p
argument_list|(
name|imode
argument_list|,
name|fmode
argument_list|,
name|unsignedp
argument_list|,
operator|&
name|must_trunc
argument_list|)
expr_stmt|;
if|if
condition|(
name|icode
operator|==
name|CODE_FOR_nothing
operator|&&
name|imode
operator|!=
name|GET_MODE
argument_list|(
name|to
argument_list|)
operator|&&
name|unsignedp
condition|)
name|icode
operator|=
name|can_fix_p
argument_list|(
name|imode
argument_list|,
name|fmode
argument_list|,
literal|0
argument_list|,
operator|&
name|must_trunc
argument_list|)
operator|,
name|doing_unsigned
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|icode
operator|!=
name|CODE_FOR_nothing
condition|)
block|{
name|to
operator|=
name|protect_from_queue
argument_list|(
name|to
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|from
operator|=
name|protect_from_queue
argument_list|(
name|from
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|fmode
operator|!=
name|GET_MODE
argument_list|(
name|from
argument_list|)
condition|)
name|from
operator|=
name|convert_to_mode
argument_list|(
name|fmode
argument_list|,
name|from
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|must_trunc
condition|)
name|from
operator|=
name|ftruncify
argument_list|(
name|from
argument_list|)
expr_stmt|;
if|if
condition|(
name|imode
operator|!=
name|GET_MODE
argument_list|(
name|to
argument_list|)
condition|)
name|target
operator|=
name|gen_reg_rtx
argument_list|(
name|imode
argument_list|)
expr_stmt|;
name|emit_unop_insn
argument_list|(
name|icode
argument_list|,
name|target
argument_list|,
name|from
argument_list|,
name|doing_unsigned
condition|?
name|UNSIGNED_FIX
else|:
name|FIX
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
operator|!=
name|to
condition|)
name|convert_move
argument_list|(
name|to
argument_list|,
name|target
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
if|#
directive|if
operator|!
name|defined
argument_list|(
name|REAL_IS_NOT_DOUBLE
argument_list|)
operator|||
name|defined
argument_list|(
name|REAL_ARITHMETIC
argument_list|)
comment|/* For an unsigned conversion, there is one more way to do it.      If we have a signed conversion, we generate code that compares      the real value to the largest representable positive number.  If if      is smaller, the conversion is done normally.  Otherwise, subtract      one plus the highest signed number, convert, and add it back.       We only need to check all real modes, since we know we didn't find      anything with a wider integer mode.  */
if|if
condition|(
name|unsignedp
operator|&&
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|to
argument_list|)
argument_list|)
operator|<=
name|HOST_BITS_PER_WIDE_INT
condition|)
for|for
control|(
name|fmode
operator|=
name|GET_MODE
argument_list|(
name|from
argument_list|)
init|;
name|fmode
operator|!=
name|VOIDmode
condition|;
name|fmode
operator|=
name|GET_MODE_WIDER_MODE
argument_list|(
name|fmode
argument_list|)
control|)
comment|/* Make sure we won't lose significant bits doing this.  */
if|if
condition|(
name|GET_MODE_BITSIZE
argument_list|(
name|fmode
argument_list|)
operator|>
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|to
argument_list|)
argument_list|)
operator|&&
name|CODE_FOR_nothing
operator|!=
name|can_fix_p
argument_list|(
name|GET_MODE
argument_list|(
name|to
argument_list|)
argument_list|,
name|fmode
argument_list|,
literal|0
argument_list|,
operator|&
name|must_trunc
argument_list|)
condition|)
block|{
name|int
name|bitsize
init|=
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|to
argument_list|)
argument_list|)
decl_stmt|;
name|REAL_VALUE_TYPE
name|offset
init|=
name|REAL_VALUE_LDEXP
argument_list|(
name|dconst1
argument_list|,
name|bitsize
operator|-
literal|1
argument_list|)
decl_stmt|;
name|rtx
name|limit
init|=
name|immed_real_const_1
argument_list|(
name|offset
argument_list|,
name|fmode
argument_list|)
decl_stmt|;
name|rtx
name|lab1
init|=
name|gen_label_rtx
argument_list|()
decl_stmt|;
name|rtx
name|lab2
init|=
name|gen_label_rtx
argument_list|()
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
name|emit_queue
argument_list|()
expr_stmt|;
name|to
operator|=
name|protect_from_queue
argument_list|(
name|to
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|from
operator|=
name|protect_from_queue
argument_list|(
name|from
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_force_mem
condition|)
name|from
operator|=
name|force_not_mem
argument_list|(
name|from
argument_list|)
expr_stmt|;
if|if
condition|(
name|fmode
operator|!=
name|GET_MODE
argument_list|(
name|from
argument_list|)
condition|)
name|from
operator|=
name|convert_to_mode
argument_list|(
name|fmode
argument_list|,
name|from
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* See if we need to do the subtraction.  */
name|do_pending_stack_adjust
argument_list|()
expr_stmt|;
name|emit_cmp_insn
argument_list|(
name|from
argument_list|,
name|limit
argument_list|,
name|GE
argument_list|,
name|NULL_RTX
argument_list|,
name|GET_MODE
argument_list|(
name|from
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emit_jump_insn
argument_list|(
name|gen_bge
argument_list|(
name|lab1
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If not, do the signed "fix" and branch around fixup code.  */
name|expand_fix
argument_list|(
name|to
argument_list|,
name|from
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emit_jump_insn
argument_list|(
name|gen_jump
argument_list|(
name|lab2
argument_list|)
argument_list|)
expr_stmt|;
name|emit_barrier
argument_list|()
expr_stmt|;
comment|/* Otherwise, subtract 2**(N-1), convert to signed number, 	     then add 2**(N-1).  Do the addition using XOR since this 	     will often generate better code.  */
name|emit_label
argument_list|(
name|lab1
argument_list|)
expr_stmt|;
name|target
operator|=
name|expand_binop
argument_list|(
name|GET_MODE
argument_list|(
name|from
argument_list|)
argument_list|,
name|sub_optab
argument_list|,
name|from
argument_list|,
name|limit
argument_list|,
name|NULL_RTX
argument_list|,
literal|0
argument_list|,
name|OPTAB_LIB_WIDEN
argument_list|)
expr_stmt|;
name|expand_fix
argument_list|(
name|to
argument_list|,
name|target
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|target
operator|=
name|expand_binop
argument_list|(
name|GET_MODE
argument_list|(
name|to
argument_list|)
argument_list|,
name|xor_optab
argument_list|,
name|to
argument_list|,
name|GEN_INT
argument_list|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
operator|(
name|bitsize
operator|-
literal|1
operator|)
argument_list|)
argument_list|,
name|to
argument_list|,
literal|1
argument_list|,
name|OPTAB_LIB_WIDEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
operator|!=
name|to
condition|)
name|emit_move_insn
argument_list|(
name|to
argument_list|,
name|target
argument_list|)
expr_stmt|;
name|emit_label
argument_list|(
name|lab2
argument_list|)
expr_stmt|;
comment|/* Make a place for a REG_NOTE and add it.  */
name|insn
operator|=
name|emit_move_insn
argument_list|(
name|to
argument_list|,
name|to
argument_list|)
expr_stmt|;
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|=
name|gen_rtx
argument_list|(
name|EXPR_LIST
argument_list|,
name|REG_EQUAL
argument_list|,
name|gen_rtx
argument_list|(
name|UNSIGNED_FIX
argument_list|,
name|GET_MODE
argument_list|(
name|to
argument_list|)
argument_list|,
name|from
argument_list|)
argument_list|,
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
comment|/* We can't do it with an insn, so use a library call.  But first ensure      that the mode of TO is at least as wide as SImode, since those are the      only library calls we know about.  */
if|if
condition|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|to
argument_list|)
argument_list|)
operator|<
name|GET_MODE_SIZE
argument_list|(
name|SImode
argument_list|)
condition|)
block|{
name|target
operator|=
name|gen_reg_rtx
argument_list|(
name|SImode
argument_list|)
expr_stmt|;
name|expand_fix
argument_list|(
name|target
argument_list|,
name|from
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_MODE
argument_list|(
name|from
argument_list|)
operator|==
name|SFmode
condition|)
block|{
if|if
condition|(
name|GET_MODE
argument_list|(
name|to
argument_list|)
operator|==
name|SImode
condition|)
name|libfcn
operator|=
name|unsignedp
condition|?
name|fixunssfsi_libfunc
else|:
name|fixsfsi_libfunc
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_MODE
argument_list|(
name|to
argument_list|)
operator|==
name|DImode
condition|)
name|libfcn
operator|=
name|unsignedp
condition|?
name|fixunssfdi_libfunc
else|:
name|fixsfdi_libfunc
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_MODE
argument_list|(
name|to
argument_list|)
operator|==
name|TImode
condition|)
name|libfcn
operator|=
name|unsignedp
condition|?
name|fixunssfti_libfunc
else|:
name|fixsfti_libfunc
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_MODE
argument_list|(
name|from
argument_list|)
operator|==
name|DFmode
condition|)
block|{
if|if
condition|(
name|GET_MODE
argument_list|(
name|to
argument_list|)
operator|==
name|SImode
condition|)
name|libfcn
operator|=
name|unsignedp
condition|?
name|fixunsdfsi_libfunc
else|:
name|fixdfsi_libfunc
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_MODE
argument_list|(
name|to
argument_list|)
operator|==
name|DImode
condition|)
name|libfcn
operator|=
name|unsignedp
condition|?
name|fixunsdfdi_libfunc
else|:
name|fixdfdi_libfunc
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_MODE
argument_list|(
name|to
argument_list|)
operator|==
name|TImode
condition|)
name|libfcn
operator|=
name|unsignedp
condition|?
name|fixunsdfti_libfunc
else|:
name|fixdfti_libfunc
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_MODE
argument_list|(
name|from
argument_list|)
operator|==
name|XFmode
condition|)
block|{
if|if
condition|(
name|GET_MODE
argument_list|(
name|to
argument_list|)
operator|==
name|SImode
condition|)
name|libfcn
operator|=
name|unsignedp
condition|?
name|fixunsxfsi_libfunc
else|:
name|fixxfsi_libfunc
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_MODE
argument_list|(
name|to
argument_list|)
operator|==
name|DImode
condition|)
name|libfcn
operator|=
name|unsignedp
condition|?
name|fixunsxfdi_libfunc
else|:
name|fixxfdi_libfunc
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_MODE
argument_list|(
name|to
argument_list|)
operator|==
name|TImode
condition|)
name|libfcn
operator|=
name|unsignedp
condition|?
name|fixunsxfti_libfunc
else|:
name|fixxfti_libfunc
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_MODE
argument_list|(
name|from
argument_list|)
operator|==
name|TFmode
condition|)
block|{
if|if
condition|(
name|GET_MODE
argument_list|(
name|to
argument_list|)
operator|==
name|SImode
condition|)
name|libfcn
operator|=
name|unsignedp
condition|?
name|fixunstfsi_libfunc
else|:
name|fixtfsi_libfunc
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_MODE
argument_list|(
name|to
argument_list|)
operator|==
name|DImode
condition|)
name|libfcn
operator|=
name|unsignedp
condition|?
name|fixunstfdi_libfunc
else|:
name|fixtfdi_libfunc
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_MODE
argument_list|(
name|to
argument_list|)
operator|==
name|TImode
condition|)
name|libfcn
operator|=
name|unsignedp
condition|?
name|fixunstfti_libfunc
else|:
name|fixtfti_libfunc
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
block|}
else|else
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|libfcn
condition|)
block|{
name|rtx
name|insns
decl_stmt|;
name|to
operator|=
name|protect_from_queue
argument_list|(
name|to
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|from
operator|=
name|protect_from_queue
argument_list|(
name|from
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_force_mem
condition|)
name|from
operator|=
name|force_not_mem
argument_list|(
name|from
argument_list|)
expr_stmt|;
name|start_sequence
argument_list|()
expr_stmt|;
name|emit_library_call
argument_list|(
name|libfcn
argument_list|,
literal|1
argument_list|,
name|GET_MODE
argument_list|(
name|to
argument_list|)
argument_list|,
literal|1
argument_list|,
name|from
argument_list|,
name|GET_MODE
argument_list|(
name|from
argument_list|)
argument_list|)
expr_stmt|;
name|insns
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
name|emit_libcall_block
argument_list|(
name|insns
argument_list|,
name|target
argument_list|,
name|hard_libcall_value
argument_list|(
name|GET_MODE
argument_list|(
name|to
argument_list|)
argument_list|)
argument_list|,
name|gen_rtx
argument_list|(
name|unsignedp
condition|?
name|FIX
else|:
name|UNSIGNED_FIX
argument_list|,
name|GET_MODE
argument_list|(
name|to
argument_list|)
argument_list|,
name|from
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|GET_MODE
argument_list|(
name|to
argument_list|)
operator|==
name|GET_MODE
argument_list|(
name|target
argument_list|)
condition|)
name|emit_move_insn
argument_list|(
name|to
argument_list|,
name|target
argument_list|)
expr_stmt|;
else|else
name|convert_move
argument_list|(
name|to
argument_list|,
name|target
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|optab
name|init_optab
parameter_list|(
name|code
parameter_list|)
name|enum
name|rtx_code
name|code
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|optab
name|op
init|=
operator|(
name|optab
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|optab
argument_list|)
argument_list|)
decl_stmt|;
name|op
operator|->
name|code
operator|=
name|code
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_MACHINE_MODES
condition|;
name|i
operator|++
control|)
block|{
name|op
operator|->
name|handlers
index|[
name|i
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_nothing
expr_stmt|;
name|op
operator|->
name|handlers
index|[
name|i
index|]
operator|.
name|libfunc
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|op
return|;
block|}
end_function

begin_comment
comment|/* Initialize the libfunc fields of an entire group of entries in some    optab.  Each entry is set equal to a string consisting of a leading    pair of underscores followed by a generic operation name followed by    a mode name (downshifted to lower case) followed by a single character    representing the number of operands for the given operation (which is    usually one of the characters '2', '3', or '4').     OPTABLE is the table in which libfunc fields are to be initialized.    FIRST_MODE is the first machine mode index in the given optab to      initialize.    LAST_MODE is the last machine mode index in the given optab to      initialize.    OPNAME is the generic (string) name of the operation.    SUFFIX is the character which specifies the number of operands for      the given generic operation. */
end_comment

begin_function
specifier|static
name|void
name|init_libfuncs
parameter_list|(
name|optable
parameter_list|,
name|first_mode
parameter_list|,
name|last_mode
parameter_list|,
name|opname
parameter_list|,
name|suffix
parameter_list|)
specifier|register
name|optab
name|optable
decl_stmt|;
specifier|register
name|char
modifier|*
name|opname
decl_stmt|;
specifier|register
name|enum
name|machine_mode
name|first_mode
decl_stmt|;
specifier|register
name|enum
name|machine_mode
name|last_mode
decl_stmt|;
specifier|register
name|char
name|suffix
decl_stmt|;
block|{
specifier|register
name|enum
name|machine_mode
name|mode
decl_stmt|;
specifier|register
name|unsigned
name|opname_len
init|=
name|strlen
argument_list|(
name|opname
argument_list|)
decl_stmt|;
for|for
control|(
name|mode
operator|=
name|first_mode
init|;
operator|(
name|int
operator|)
name|mode
operator|<=
operator|(
name|int
operator|)
name|last_mode
condition|;
name|mode
operator|=
operator|(
expr|enum
name|machine_mode
operator|)
operator|(
operator|(
name|int
operator|)
name|mode
operator|+
literal|1
operator|)
control|)
block|{
specifier|register
name|char
modifier|*
name|mname
init|=
name|mode_name
index|[
operator|(
name|int
operator|)
name|mode
index|]
decl_stmt|;
specifier|register
name|unsigned
name|mname_len
init|=
name|strlen
argument_list|(
name|mname
argument_list|)
decl_stmt|;
specifier|register
name|char
modifier|*
name|libfunc_name
init|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
literal|2
operator|+
name|opname_len
operator|+
name|mname_len
operator|+
literal|1
operator|+
literal|1
argument_list|)
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|char
modifier|*
name|q
decl_stmt|;
name|p
operator|=
name|libfunc_name
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|'_'
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|'_'
expr_stmt|;
for|for
control|(
name|q
operator|=
name|opname
init|;
operator|*
name|q
condition|;
control|)
operator|*
name|p
operator|++
operator|=
operator|*
name|q
operator|++
expr_stmt|;
for|for
control|(
name|q
operator|=
name|mname
init|;
operator|*
name|q
condition|;
name|q
operator|++
control|)
operator|*
name|p
operator|++
operator|=
name|tolower
argument_list|(
operator|*
name|q
argument_list|)
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|suffix
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|optable
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|mode
index|]
operator|.
name|libfunc
operator|=
name|gen_rtx
argument_list|(
name|SYMBOL_REF
argument_list|,
name|Pmode
argument_list|,
name|libfunc_name
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Initialize the libfunc fields of an entire group of entries in some    optab which correspond to all integer mode operations.  The parameters    have the same meaning as similarly named ones for the `init_libfuncs'    routine.  (See above).  */
end_comment

begin_function
specifier|static
name|void
name|init_integral_libfuncs
parameter_list|(
name|optable
parameter_list|,
name|opname
parameter_list|,
name|suffix
parameter_list|)
specifier|register
name|optab
name|optable
decl_stmt|;
specifier|register
name|char
modifier|*
name|opname
decl_stmt|;
specifier|register
name|char
name|suffix
decl_stmt|;
block|{
name|init_libfuncs
argument_list|(
name|optable
argument_list|,
name|SImode
argument_list|,
name|TImode
argument_list|,
name|opname
argument_list|,
name|suffix
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Initialize the libfunc fields of an entire group of entries in some    optab which correspond to all real mode operations.  The parameters    have the same meaning as similarly named ones for the `init_libfuncs'    routine.  (See above).  */
end_comment

begin_function
specifier|static
name|void
name|init_floating_libfuncs
parameter_list|(
name|optable
parameter_list|,
name|opname
parameter_list|,
name|suffix
parameter_list|)
specifier|register
name|optab
name|optable
decl_stmt|;
specifier|register
name|char
modifier|*
name|opname
decl_stmt|;
specifier|register
name|char
name|suffix
decl_stmt|;
block|{
name|init_libfuncs
argument_list|(
name|optable
argument_list|,
name|SFmode
argument_list|,
name|TFmode
argument_list|,
name|opname
argument_list|,
name|suffix
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Initialize the libfunc fields of an entire group of entries in some    optab which correspond to all complex floating modes.  The parameters    have the same meaning as similarly named ones for the `init_libfuncs'    routine.  (See above).  */
end_comment

begin_function
specifier|static
name|void
name|init_complex_libfuncs
parameter_list|(
name|optable
parameter_list|,
name|opname
parameter_list|,
name|suffix
parameter_list|)
specifier|register
name|optab
name|optable
decl_stmt|;
specifier|register
name|char
modifier|*
name|opname
decl_stmt|;
specifier|register
name|char
name|suffix
decl_stmt|;
block|{
name|init_libfuncs
argument_list|(
name|optable
argument_list|,
name|SCmode
argument_list|,
name|TCmode
argument_list|,
name|opname
argument_list|,
name|suffix
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Call this once to initialize the contents of the optabs    appropriately for the current target machine.  */
end_comment

begin_function
name|void
name|init_optabs
parameter_list|()
block|{
name|int
name|i
decl_stmt|;
name|init_fixtab
argument_list|()
expr_stmt|;
name|init_floattab
argument_list|()
expr_stmt|;
name|init_extends
argument_list|()
expr_stmt|;
name|add_optab
operator|=
name|init_optab
argument_list|(
name|PLUS
argument_list|)
expr_stmt|;
name|sub_optab
operator|=
name|init_optab
argument_list|(
name|MINUS
argument_list|)
expr_stmt|;
name|smul_optab
operator|=
name|init_optab
argument_list|(
name|MULT
argument_list|)
expr_stmt|;
name|smul_widen_optab
operator|=
name|init_optab
argument_list|(
name|UNKNOWN
argument_list|)
expr_stmt|;
name|umul_widen_optab
operator|=
name|init_optab
argument_list|(
name|UNKNOWN
argument_list|)
expr_stmt|;
name|sdiv_optab
operator|=
name|init_optab
argument_list|(
name|DIV
argument_list|)
expr_stmt|;
name|sdivmod_optab
operator|=
name|init_optab
argument_list|(
name|UNKNOWN
argument_list|)
expr_stmt|;
name|udiv_optab
operator|=
name|init_optab
argument_list|(
name|UDIV
argument_list|)
expr_stmt|;
name|udivmod_optab
operator|=
name|init_optab
argument_list|(
name|UNKNOWN
argument_list|)
expr_stmt|;
name|smod_optab
operator|=
name|init_optab
argument_list|(
name|MOD
argument_list|)
expr_stmt|;
name|umod_optab
operator|=
name|init_optab
argument_list|(
name|UMOD
argument_list|)
expr_stmt|;
name|flodiv_optab
operator|=
name|init_optab
argument_list|(
name|DIV
argument_list|)
expr_stmt|;
name|ftrunc_optab
operator|=
name|init_optab
argument_list|(
name|UNKNOWN
argument_list|)
expr_stmt|;
name|and_optab
operator|=
name|init_optab
argument_list|(
name|AND
argument_list|)
expr_stmt|;
name|ior_optab
operator|=
name|init_optab
argument_list|(
name|IOR
argument_list|)
expr_stmt|;
name|xor_optab
operator|=
name|init_optab
argument_list|(
name|XOR
argument_list|)
expr_stmt|;
name|ashl_optab
operator|=
name|init_optab
argument_list|(
name|ASHIFT
argument_list|)
expr_stmt|;
name|ashr_optab
operator|=
name|init_optab
argument_list|(
name|ASHIFTRT
argument_list|)
expr_stmt|;
name|lshl_optab
operator|=
name|init_optab
argument_list|(
name|LSHIFT
argument_list|)
expr_stmt|;
name|lshr_optab
operator|=
name|init_optab
argument_list|(
name|LSHIFTRT
argument_list|)
expr_stmt|;
name|rotl_optab
operator|=
name|init_optab
argument_list|(
name|ROTATE
argument_list|)
expr_stmt|;
name|rotr_optab
operator|=
name|init_optab
argument_list|(
name|ROTATERT
argument_list|)
expr_stmt|;
name|smin_optab
operator|=
name|init_optab
argument_list|(
name|SMIN
argument_list|)
expr_stmt|;
name|smax_optab
operator|=
name|init_optab
argument_list|(
name|SMAX
argument_list|)
expr_stmt|;
name|umin_optab
operator|=
name|init_optab
argument_list|(
name|UMIN
argument_list|)
expr_stmt|;
name|umax_optab
operator|=
name|init_optab
argument_list|(
name|UMAX
argument_list|)
expr_stmt|;
name|mov_optab
operator|=
name|init_optab
argument_list|(
name|UNKNOWN
argument_list|)
expr_stmt|;
name|movstrict_optab
operator|=
name|init_optab
argument_list|(
name|UNKNOWN
argument_list|)
expr_stmt|;
name|cmp_optab
operator|=
name|init_optab
argument_list|(
name|UNKNOWN
argument_list|)
expr_stmt|;
name|ucmp_optab
operator|=
name|init_optab
argument_list|(
name|UNKNOWN
argument_list|)
expr_stmt|;
name|tst_optab
operator|=
name|init_optab
argument_list|(
name|UNKNOWN
argument_list|)
expr_stmt|;
name|neg_optab
operator|=
name|init_optab
argument_list|(
name|NEG
argument_list|)
expr_stmt|;
name|abs_optab
operator|=
name|init_optab
argument_list|(
name|ABS
argument_list|)
expr_stmt|;
name|one_cmpl_optab
operator|=
name|init_optab
argument_list|(
name|NOT
argument_list|)
expr_stmt|;
name|ffs_optab
operator|=
name|init_optab
argument_list|(
name|FFS
argument_list|)
expr_stmt|;
name|sqrt_optab
operator|=
name|init_optab
argument_list|(
name|SQRT
argument_list|)
expr_stmt|;
name|sin_optab
operator|=
name|init_optab
argument_list|(
name|UNKNOWN
argument_list|)
expr_stmt|;
name|cos_optab
operator|=
name|init_optab
argument_list|(
name|UNKNOWN
argument_list|)
expr_stmt|;
name|strlen_optab
operator|=
name|init_optab
argument_list|(
name|UNKNOWN
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_addqi3
if|if
condition|(
name|HAVE_addqi3
condition|)
name|add_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|QImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_addqi3
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_addhi3
if|if
condition|(
name|HAVE_addhi3
condition|)
name|add_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|HImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_addhi3
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_addpsi3
if|if
condition|(
name|HAVE_addpsi3
condition|)
name|add_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|PSImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_addpsi3
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_addsi3
if|if
condition|(
name|HAVE_addsi3
condition|)
name|add_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|SImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_addsi3
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_adddi3
if|if
condition|(
name|HAVE_adddi3
condition|)
name|add_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|DImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_adddi3
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_addti3
if|if
condition|(
name|HAVE_addti3
condition|)
name|add_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|TImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_addti3
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_addsf3
if|if
condition|(
name|HAVE_addsf3
condition|)
name|add_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|SFmode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_addsf3
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_adddf3
if|if
condition|(
name|HAVE_adddf3
condition|)
name|add_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|DFmode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_adddf3
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_addxf3
if|if
condition|(
name|HAVE_addxf3
condition|)
name|add_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|XFmode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_addxf3
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_addtf3
if|if
condition|(
name|HAVE_addtf3
condition|)
name|add_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|TFmode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_addtf3
expr_stmt|;
endif|#
directive|endif
name|init_integral_libfuncs
argument_list|(
name|add_optab
argument_list|,
literal|"add"
argument_list|,
literal|'3'
argument_list|)
expr_stmt|;
name|init_floating_libfuncs
argument_list|(
name|add_optab
argument_list|,
literal|"add"
argument_list|,
literal|'3'
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_subqi3
if|if
condition|(
name|HAVE_subqi3
condition|)
name|sub_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|QImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_subqi3
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_subhi3
if|if
condition|(
name|HAVE_subhi3
condition|)
name|sub_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|HImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_subhi3
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_subpsi3
if|if
condition|(
name|HAVE_subpsi3
condition|)
name|sub_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|PSImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_subpsi3
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_subsi3
if|if
condition|(
name|HAVE_subsi3
condition|)
name|sub_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|SImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_subsi3
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_subdi3
if|if
condition|(
name|HAVE_subdi3
condition|)
name|sub_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|DImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_subdi3
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_subti3
if|if
condition|(
name|HAVE_subti3
condition|)
name|sub_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|TImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_subti3
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_subsf3
if|if
condition|(
name|HAVE_subsf3
condition|)
name|sub_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|SFmode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_subsf3
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_subdf3
if|if
condition|(
name|HAVE_subdf3
condition|)
name|sub_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|DFmode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_subdf3
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_subxf3
if|if
condition|(
name|HAVE_subxf3
condition|)
name|sub_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|XFmode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_subxf3
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_subtf3
if|if
condition|(
name|HAVE_subtf3
condition|)
name|sub_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|TFmode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_subtf3
expr_stmt|;
endif|#
directive|endif
name|init_integral_libfuncs
argument_list|(
name|sub_optab
argument_list|,
literal|"sub"
argument_list|,
literal|'3'
argument_list|)
expr_stmt|;
name|init_floating_libfuncs
argument_list|(
name|sub_optab
argument_list|,
literal|"sub"
argument_list|,
literal|'3'
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_mulqi3
if|if
condition|(
name|HAVE_mulqi3
condition|)
name|smul_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|QImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_mulqi3
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_mulhi3
if|if
condition|(
name|HAVE_mulhi3
condition|)
name|smul_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|HImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_mulhi3
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_mulpsi3
if|if
condition|(
name|HAVE_mulpsi3
condition|)
name|smul_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|PSImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_mulpsi3
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_mulsi3
if|if
condition|(
name|HAVE_mulsi3
condition|)
name|smul_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|SImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_mulsi3
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_muldi3
if|if
condition|(
name|HAVE_muldi3
condition|)
name|smul_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|DImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_muldi3
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_multi3
if|if
condition|(
name|HAVE_multi3
condition|)
name|smul_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|TImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_multi3
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_mulsf3
if|if
condition|(
name|HAVE_mulsf3
condition|)
name|smul_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|SFmode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_mulsf3
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_muldf3
if|if
condition|(
name|HAVE_muldf3
condition|)
name|smul_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|DFmode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_muldf3
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_mulxf3
if|if
condition|(
name|HAVE_mulxf3
condition|)
name|smul_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|XFmode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_mulxf3
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_multf3
if|if
condition|(
name|HAVE_multf3
condition|)
name|smul_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|TFmode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_multf3
expr_stmt|;
endif|#
directive|endif
name|init_integral_libfuncs
argument_list|(
name|smul_optab
argument_list|,
literal|"mul"
argument_list|,
literal|'3'
argument_list|)
expr_stmt|;
name|init_floating_libfuncs
argument_list|(
name|smul_optab
argument_list|,
literal|"mul"
argument_list|,
literal|'3'
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MULSI3_LIBCALL
name|smul_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|SImode
index|]
operator|.
name|libfunc
operator|=
name|gen_rtx
argument_list|(
name|SYMBOL_REF
argument_list|,
name|Pmode
argument_list|,
name|MULSI3_LIBCALL
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|MULDI3_LIBCALL
name|smul_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|DImode
index|]
operator|.
name|libfunc
operator|=
name|gen_rtx
argument_list|(
name|SYMBOL_REF
argument_list|,
name|Pmode
argument_list|,
name|MULDI3_LIBCALL
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|MULTI3_LIBCALL
name|smul_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|TImode
index|]
operator|.
name|libfunc
operator|=
name|gen_rtx
argument_list|(
name|SYMBOL_REF
argument_list|,
name|Pmode
argument_list|,
name|MULTI3_LIBCALL
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_mulqihi3
if|if
condition|(
name|HAVE_mulqihi3
condition|)
name|smul_widen_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|HImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_mulqihi3
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_mulhisi3
if|if
condition|(
name|HAVE_mulhisi3
condition|)
name|smul_widen_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|SImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_mulhisi3
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_mulsidi3
if|if
condition|(
name|HAVE_mulsidi3
condition|)
name|smul_widen_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|DImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_mulsidi3
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_mulditi3
if|if
condition|(
name|HAVE_mulditi3
condition|)
name|smul_widen_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|TImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_mulditi3
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_umulqihi3
if|if
condition|(
name|HAVE_umulqihi3
condition|)
name|umul_widen_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|HImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_umulqihi3
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_umulhisi3
if|if
condition|(
name|HAVE_umulhisi3
condition|)
name|umul_widen_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|SImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_umulhisi3
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_umulsidi3
if|if
condition|(
name|HAVE_umulsidi3
condition|)
name|umul_widen_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|DImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_umulsidi3
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_umulditi3
if|if
condition|(
name|HAVE_umulditi3
condition|)
name|umul_widen_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|TImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_umulditi3
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_divqi3
if|if
condition|(
name|HAVE_divqi3
condition|)
name|sdiv_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|QImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_divqi3
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_divhi3
if|if
condition|(
name|HAVE_divhi3
condition|)
name|sdiv_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|HImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_divhi3
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_divpsi3
if|if
condition|(
name|HAVE_divpsi3
condition|)
name|sdiv_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|PSImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_divpsi3
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_divsi3
if|if
condition|(
name|HAVE_divsi3
condition|)
name|sdiv_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|SImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_divsi3
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_divdi3
if|if
condition|(
name|HAVE_divdi3
condition|)
name|sdiv_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|DImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_divdi3
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_divti3
if|if
condition|(
name|HAVE_divti3
condition|)
name|sdiv_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|TImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_divti3
expr_stmt|;
endif|#
directive|endif
name|init_integral_libfuncs
argument_list|(
name|sdiv_optab
argument_list|,
literal|"div"
argument_list|,
literal|'3'
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DIVSI3_LIBCALL
name|sdiv_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|SImode
index|]
operator|.
name|libfunc
operator|=
name|gen_rtx
argument_list|(
name|SYMBOL_REF
argument_list|,
name|Pmode
argument_list|,
name|DIVSI3_LIBCALL
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DIVDI3_LIBCALL
name|sdiv_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|DImode
index|]
operator|.
name|libfunc
operator|=
name|gen_rtx
argument_list|(
name|SYMBOL_REF
argument_list|,
name|Pmode
argument_list|,
name|DIVDI3_LIBCALL
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DIVTI3_LIBCALL
name|sdiv_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|TImode
index|]
operator|.
name|libfunc
operator|=
name|gen_rtx
argument_list|(
name|SYMBOL_REF
argument_list|,
name|Pmode
argument_list|,
name|DIVTI3_LIBCALL
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_udivqi3
if|if
condition|(
name|HAVE_udivqi3
condition|)
name|udiv_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|QImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_udivqi3
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_udivhi3
if|if
condition|(
name|HAVE_udivhi3
condition|)
name|udiv_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|HImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_udivhi3
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_udivpsi3
if|if
condition|(
name|HAVE_udivpsi3
condition|)
name|udiv_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|PSImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_udivpsi3
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_udivsi3
if|if
condition|(
name|HAVE_udivsi3
condition|)
name|udiv_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|SImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_udivsi3
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_udivdi3
if|if
condition|(
name|HAVE_udivdi3
condition|)
name|udiv_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|DImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_udivdi3
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_udivti3
if|if
condition|(
name|HAVE_udivti3
condition|)
name|udiv_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|TImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_udivti3
expr_stmt|;
endif|#
directive|endif
name|init_integral_libfuncs
argument_list|(
name|udiv_optab
argument_list|,
literal|"udiv"
argument_list|,
literal|'3'
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|UDIVSI3_LIBCALL
name|udiv_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|SImode
index|]
operator|.
name|libfunc
operator|=
name|gen_rtx
argument_list|(
name|SYMBOL_REF
argument_list|,
name|Pmode
argument_list|,
name|UDIVSI3_LIBCALL
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|UDIVDI3_LIBCALL
name|udiv_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|DImode
index|]
operator|.
name|libfunc
operator|=
name|gen_rtx
argument_list|(
name|SYMBOL_REF
argument_list|,
name|Pmode
argument_list|,
name|UDIVDI3_LIBCALL
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|UDIVTI3_LIBCALL
name|udiv_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|TImode
index|]
operator|.
name|libfunc
operator|=
name|gen_rtx
argument_list|(
name|SYMBOL_REF
argument_list|,
name|Pmode
argument_list|,
name|UDIVTI3_LIBCALL
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_divmodqi4
if|if
condition|(
name|HAVE_divmodqi4
condition|)
name|sdivmod_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|QImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_divmodqi4
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_divmodhi4
if|if
condition|(
name|HAVE_divmodhi4
condition|)
name|sdivmod_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|HImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_divmodhi4
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_divmodsi4
if|if
condition|(
name|HAVE_divmodsi4
condition|)
name|sdivmod_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|SImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_divmodsi4
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_divmoddi4
if|if
condition|(
name|HAVE_divmoddi4
condition|)
name|sdivmod_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|DImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_divmoddi4
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_divmodti4
if|if
condition|(
name|HAVE_divmodti4
condition|)
name|sdivmod_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|TImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_divmodti4
expr_stmt|;
endif|#
directive|endif
name|init_integral_libfuncs
argument_list|(
name|sdivmod_optab
argument_list|,
literal|"divmod"
argument_list|,
literal|'4'
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_udivmodqi4
if|if
condition|(
name|HAVE_udivmodqi4
condition|)
name|udivmod_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|QImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_udivmodqi4
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_udivmodhi4
if|if
condition|(
name|HAVE_udivmodhi4
condition|)
name|udivmod_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|HImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_udivmodhi4
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_udivmodsi4
if|if
condition|(
name|HAVE_udivmodsi4
condition|)
name|udivmod_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|SImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_udivmodsi4
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_udivmoddi4
if|if
condition|(
name|HAVE_udivmoddi4
condition|)
name|udivmod_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|DImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_udivmoddi4
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_udivmodti4
if|if
condition|(
name|HAVE_udivmodti4
condition|)
name|udivmod_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|TImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_udivmodti4
expr_stmt|;
endif|#
directive|endif
name|init_integral_libfuncs
argument_list|(
name|udivmod_optab
argument_list|,
literal|"udivmod"
argument_list|,
literal|'4'
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_modqi3
if|if
condition|(
name|HAVE_modqi3
condition|)
name|smod_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|QImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_modqi3
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_modhi3
if|if
condition|(
name|HAVE_modhi3
condition|)
name|smod_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|HImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_modhi3
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_modpsi3
if|if
condition|(
name|HAVE_modpsi3
condition|)
name|smod_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|PSImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_modpsi3
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_modsi3
if|if
condition|(
name|HAVE_modsi3
condition|)
name|smod_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|SImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_modsi3
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_moddi3
if|if
condition|(
name|HAVE_moddi3
condition|)
name|smod_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|DImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_moddi3
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_modti3
if|if
condition|(
name|HAVE_modti3
condition|)
name|smod_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|TImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_modti3
expr_stmt|;
endif|#
directive|endif
name|init_integral_libfuncs
argument_list|(
name|smod_optab
argument_list|,
literal|"mod"
argument_list|,
literal|'3'
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MODSI3_LIBCALL
name|smod_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|SImode
index|]
operator|.
name|libfunc
operator|=
name|gen_rtx
argument_list|(
name|SYMBOL_REF
argument_list|,
name|Pmode
argument_list|,
name|MODSI3_LIBCALL
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|MODDI3_LIBCALL
name|smod_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|DImode
index|]
operator|.
name|libfunc
operator|=
name|gen_rtx
argument_list|(
name|SYMBOL_REF
argument_list|,
name|Pmode
argument_list|,
name|MODDI3_LIBCALL
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|MODTI3_LIBCALL
name|smod_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|TImode
index|]
operator|.
name|libfunc
operator|=
name|gen_rtx
argument_list|(
name|SYMBOL_REF
argument_list|,
name|Pmode
argument_list|,
name|MODTI3_LIBCALL
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_umodqi3
if|if
condition|(
name|HAVE_umodqi3
condition|)
name|umod_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|QImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_umodqi3
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_umodhi3
if|if
condition|(
name|HAVE_umodhi3
condition|)
name|umod_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|HImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_umodhi3
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_umodpsi3
if|if
condition|(
name|HAVE_umodpsi3
condition|)
name|umod_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|PSImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_umodpsi3
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_umodsi3
if|if
condition|(
name|HAVE_umodsi3
condition|)
name|umod_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|SImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_umodsi3
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_umoddi3
if|if
condition|(
name|HAVE_umoddi3
condition|)
name|umod_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|DImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_umoddi3
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_umodti3
if|if
condition|(
name|HAVE_umodti3
condition|)
name|umod_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|TImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_umodti3
expr_stmt|;
endif|#
directive|endif
name|init_integral_libfuncs
argument_list|(
name|umod_optab
argument_list|,
literal|"umod"
argument_list|,
literal|'3'
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|UMODSI3_LIBCALL
name|umod_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|SImode
index|]
operator|.
name|libfunc
operator|=
name|gen_rtx
argument_list|(
name|SYMBOL_REF
argument_list|,
name|Pmode
argument_list|,
name|UMODSI3_LIBCALL
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|UMODDI3_LIBCALL
name|umod_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|DImode
index|]
operator|.
name|libfunc
operator|=
name|gen_rtx
argument_list|(
name|SYMBOL_REF
argument_list|,
name|Pmode
argument_list|,
name|UMODDI3_LIBCALL
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|UMODTI3_LIBCALL
name|umod_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|TImode
index|]
operator|.
name|libfunc
operator|=
name|gen_rtx
argument_list|(
name|SYMBOL_REF
argument_list|,
name|Pmode
argument_list|,
name|UMODTI3_LIBCALL
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_divsf3
if|if
condition|(
name|HAVE_divsf3
condition|)
name|flodiv_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|SFmode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_divsf3
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_divdf3
if|if
condition|(
name|HAVE_divdf3
condition|)
name|flodiv_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|DFmode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_divdf3
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_divxf3
if|if
condition|(
name|HAVE_divxf3
condition|)
name|flodiv_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|XFmode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_divxf3
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_divtf3
if|if
condition|(
name|HAVE_divtf3
condition|)
name|flodiv_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|TFmode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_divtf3
expr_stmt|;
endif|#
directive|endif
name|init_floating_libfuncs
argument_list|(
name|flodiv_optab
argument_list|,
literal|"div"
argument_list|,
literal|'3'
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_ftruncsf2
if|if
condition|(
name|HAVE_ftruncsf2
condition|)
name|ftrunc_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|SFmode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_ftruncsf2
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_ftruncdf2
if|if
condition|(
name|HAVE_ftruncdf2
condition|)
name|ftrunc_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|DFmode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_ftruncdf2
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_ftruncxf2
if|if
condition|(
name|HAVE_ftruncxf2
condition|)
name|ftrunc_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|XFmode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_ftruncxf2
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_ftrunctf2
if|if
condition|(
name|HAVE_ftrunctf2
condition|)
name|ftrunc_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|TFmode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_ftrunctf2
expr_stmt|;
endif|#
directive|endif
name|init_floating_libfuncs
argument_list|(
name|ftrunc_optab
argument_list|,
literal|"ftrunc"
argument_list|,
literal|'2'
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_andqi3
if|if
condition|(
name|HAVE_andqi3
condition|)
name|and_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|QImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_andqi3
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_andhi3
if|if
condition|(
name|HAVE_andhi3
condition|)
name|and_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|HImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_andhi3
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_andpsi3
if|if
condition|(
name|HAVE_andpsi3
condition|)
name|and_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|PSImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_andpsi3
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_andsi3
if|if
condition|(
name|HAVE_andsi3
condition|)
name|and_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|SImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_andsi3
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_anddi3
if|if
condition|(
name|HAVE_anddi3
condition|)
name|and_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|DImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_anddi3
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_andti3
if|if
condition|(
name|HAVE_andti3
condition|)
name|and_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|TImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_andti3
expr_stmt|;
endif|#
directive|endif
name|init_integral_libfuncs
argument_list|(
name|and_optab
argument_list|,
literal|"and"
argument_list|,
literal|'3'
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_iorqi3
if|if
condition|(
name|HAVE_iorqi3
condition|)
name|ior_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|QImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_iorqi3
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_iorhi3
if|if
condition|(
name|HAVE_iorhi3
condition|)
name|ior_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|HImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_iorhi3
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_iorpsi3
if|if
condition|(
name|HAVE_iorpsi3
condition|)
name|ior_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|PSImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_iorpsi3
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_iorsi3
if|if
condition|(
name|HAVE_iorsi3
condition|)
name|ior_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|SImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_iorsi3
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_iordi3
if|if
condition|(
name|HAVE_iordi3
condition|)
name|ior_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|DImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_iordi3
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_iorti3
if|if
condition|(
name|HAVE_iorti3
condition|)
name|ior_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|TImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_iorti3
expr_stmt|;
endif|#
directive|endif
name|init_integral_libfuncs
argument_list|(
name|ior_optab
argument_list|,
literal|"ior"
argument_list|,
literal|'3'
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_xorqi3
if|if
condition|(
name|HAVE_xorqi3
condition|)
name|xor_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|QImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_xorqi3
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_xorhi3
if|if
condition|(
name|HAVE_xorhi3
condition|)
name|xor_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|HImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_xorhi3
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_xorpsi3
if|if
condition|(
name|HAVE_xorpsi3
condition|)
name|xor_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|PSImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_xorpsi3
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_xorsi3
if|if
condition|(
name|HAVE_xorsi3
condition|)
name|xor_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|SImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_xorsi3
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_xordi3
if|if
condition|(
name|HAVE_xordi3
condition|)
name|xor_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|DImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_xordi3
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_xorti3
if|if
condition|(
name|HAVE_xorti3
condition|)
name|xor_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|TImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_xorti3
expr_stmt|;
endif|#
directive|endif
name|init_integral_libfuncs
argument_list|(
name|xor_optab
argument_list|,
literal|"xor"
argument_list|,
literal|'3'
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_ashlqi3
if|if
condition|(
name|HAVE_ashlqi3
condition|)
name|ashl_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|QImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_ashlqi3
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_ashlhi3
if|if
condition|(
name|HAVE_ashlhi3
condition|)
name|ashl_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|HImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_ashlhi3
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_ashlpsi3
if|if
condition|(
name|HAVE_ashlpsi3
condition|)
name|ashl_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|PSImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_ashlpsi3
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_ashlsi3
if|if
condition|(
name|HAVE_ashlsi3
condition|)
name|ashl_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|SImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_ashlsi3
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_ashldi3
if|if
condition|(
name|HAVE_ashldi3
condition|)
name|ashl_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|DImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_ashldi3
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_ashlti3
if|if
condition|(
name|HAVE_ashlti3
condition|)
name|ashl_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|TImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_ashlti3
expr_stmt|;
endif|#
directive|endif
name|init_integral_libfuncs
argument_list|(
name|ashl_optab
argument_list|,
literal|"ashl"
argument_list|,
literal|'3'
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_ashrqi3
if|if
condition|(
name|HAVE_ashrqi3
condition|)
name|ashr_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|QImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_ashrqi3
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_ashrhi3
if|if
condition|(
name|HAVE_ashrhi3
condition|)
name|ashr_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|HImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_ashrhi3
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_ashrpsi3
if|if
condition|(
name|HAVE_ashrpsi3
condition|)
name|ashr_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|PSImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_ashrpsi3
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_ashrsi3
if|if
condition|(
name|HAVE_ashrsi3
condition|)
name|ashr_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|SImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_ashrsi3
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_ashrdi3
if|if
condition|(
name|HAVE_ashrdi3
condition|)
name|ashr_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|DImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_ashrdi3
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_ashrti3
if|if
condition|(
name|HAVE_ashrti3
condition|)
name|ashr_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|TImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_ashrti3
expr_stmt|;
endif|#
directive|endif
name|init_integral_libfuncs
argument_list|(
name|ashr_optab
argument_list|,
literal|"ashr"
argument_list|,
literal|'3'
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_lshlqi3
if|if
condition|(
name|HAVE_lshlqi3
condition|)
name|lshl_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|QImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_lshlqi3
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_lshlhi3
if|if
condition|(
name|HAVE_lshlhi3
condition|)
name|lshl_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|HImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_lshlhi3
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_lshlpsi3
if|if
condition|(
name|HAVE_lshlpsi3
condition|)
name|lshl_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|PSImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_lshlpsi3
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_lshlsi3
if|if
condition|(
name|HAVE_lshlsi3
condition|)
name|lshl_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|SImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_lshlsi3
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_lshldi3
if|if
condition|(
name|HAVE_lshldi3
condition|)
name|lshl_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|DImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_lshldi3
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_lshlti3
if|if
condition|(
name|HAVE_lshlti3
condition|)
name|lshl_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|TImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_lshlti3
expr_stmt|;
endif|#
directive|endif
name|init_integral_libfuncs
argument_list|(
name|lshl_optab
argument_list|,
literal|"lshl"
argument_list|,
literal|'3'
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_lshrqi3
if|if
condition|(
name|HAVE_lshrqi3
condition|)
name|lshr_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|QImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_lshrqi3
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_lshrhi3
if|if
condition|(
name|HAVE_lshrhi3
condition|)
name|lshr_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|HImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_lshrhi3
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_lshrpsi3
if|if
condition|(
name|HAVE_lshrpsi3
condition|)
name|lshr_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|PSImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_lshrpsi3
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_lshrsi3
if|if
condition|(
name|HAVE_lshrsi3
condition|)
name|lshr_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|SImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_lshrsi3
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_lshrdi3
if|if
condition|(
name|HAVE_lshrdi3
condition|)
name|lshr_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|DImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_lshrdi3
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_lshrti3
if|if
condition|(
name|HAVE_lshrti3
condition|)
name|lshr_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|TImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_lshrti3
expr_stmt|;
endif|#
directive|endif
name|init_integral_libfuncs
argument_list|(
name|lshr_optab
argument_list|,
literal|"lshr"
argument_list|,
literal|'3'
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_rotlqi3
if|if
condition|(
name|HAVE_rotlqi3
condition|)
name|rotl_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|QImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_rotlqi3
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_rotlhi3
if|if
condition|(
name|HAVE_rotlhi3
condition|)
name|rotl_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|HImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_rotlhi3
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_rotlpsi3
if|if
condition|(
name|HAVE_rotlpsi3
condition|)
name|rotl_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|PSImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_rotlpsi3
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_rotlsi3
if|if
condition|(
name|HAVE_rotlsi3
condition|)
name|rotl_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|SImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_rotlsi3
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_rotldi3
if|if
condition|(
name|HAVE_rotldi3
condition|)
name|rotl_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|DImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_rotldi3
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_rotlti3
if|if
condition|(
name|HAVE_rotlti3
condition|)
name|rotl_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|TImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_rotlti3
expr_stmt|;
endif|#
directive|endif
name|init_integral_libfuncs
argument_list|(
name|rotl_optab
argument_list|,
literal|"rotl"
argument_list|,
literal|'3'
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_rotrqi3
if|if
condition|(
name|HAVE_rotrqi3
condition|)
name|rotr_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|QImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_rotrqi3
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_rotrhi3
if|if
condition|(
name|HAVE_rotrhi3
condition|)
name|rotr_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|HImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_rotrhi3
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_rotrpsi3
if|if
condition|(
name|HAVE_rotrpsi3
condition|)
name|rotr_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|PSImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_rotrpsi3
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_rotrsi3
if|if
condition|(
name|HAVE_rotrsi3
condition|)
name|rotr_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|SImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_rotrsi3
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_rotrdi3
if|if
condition|(
name|HAVE_rotrdi3
condition|)
name|rotr_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|DImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_rotrdi3
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_rotrti3
if|if
condition|(
name|HAVE_rotrti3
condition|)
name|rotr_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|TImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_rotrti3
expr_stmt|;
endif|#
directive|endif
name|init_integral_libfuncs
argument_list|(
name|rotr_optab
argument_list|,
literal|"rotr"
argument_list|,
literal|'3'
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_sminqi3
if|if
condition|(
name|HAVE_sminqi3
condition|)
name|smin_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|QImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_sminqi3
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_sminhi3
if|if
condition|(
name|HAVE_sminhi3
condition|)
name|smin_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|HImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_sminhi3
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_sminsi3
if|if
condition|(
name|HAVE_sminsi3
condition|)
name|smin_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|SImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_sminsi3
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_smindi3
if|if
condition|(
name|HAVE_smindi3
condition|)
name|smin_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|DImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_smindi3
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_sminti3
if|if
condition|(
name|HAVE_sminti3
condition|)
name|smin_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|TImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_sminti3
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_minsf3
if|if
condition|(
name|HAVE_minsf3
condition|)
name|smin_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|SFmode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_minsf3
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_mindf3
if|if
condition|(
name|HAVE_mindf3
condition|)
name|smin_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|DFmode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_mindf3
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_minxf3
if|if
condition|(
name|HAVE_minxf3
condition|)
name|smin_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|XFmode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_minxf3
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_mintf3
if|if
condition|(
name|HAVE_mintf3
condition|)
name|smin_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|TFmode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_mintf3
expr_stmt|;
endif|#
directive|endif
name|init_integral_libfuncs
argument_list|(
name|smin_optab
argument_list|,
literal|"min"
argument_list|,
literal|'3'
argument_list|)
expr_stmt|;
name|init_floating_libfuncs
argument_list|(
name|smin_optab
argument_list|,
literal|"min"
argument_list|,
literal|'3'
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_smaxqi3
if|if
condition|(
name|HAVE_smaxqi3
condition|)
name|smax_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|QImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_smaxqi3
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_smaxhi3
if|if
condition|(
name|HAVE_smaxhi3
condition|)
name|smax_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|HImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_smaxhi3
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_smaxsi3
if|if
condition|(
name|HAVE_smaxsi3
condition|)
name|smax_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|SImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_smaxsi3
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_smaxdi3
if|if
condition|(
name|HAVE_smaxdi3
condition|)
name|smax_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|DImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_smaxdi3
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_smaxti3
if|if
condition|(
name|HAVE_smaxti3
condition|)
name|smax_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|TImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_smaxti3
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_maxsf3
if|if
condition|(
name|HAVE_maxsf3
condition|)
name|smax_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|SFmode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_maxsf3
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_maxdf3
if|if
condition|(
name|HAVE_maxdf3
condition|)
name|smax_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|DFmode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_maxdf3
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_maxxf3
if|if
condition|(
name|HAVE_maxxf3
condition|)
name|smax_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|XFmode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_maxxf3
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_maxtf3
if|if
condition|(
name|HAVE_maxtf3
condition|)
name|smax_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|TFmode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_maxtf3
expr_stmt|;
endif|#
directive|endif
name|init_integral_libfuncs
argument_list|(
name|smax_optab
argument_list|,
literal|"max"
argument_list|,
literal|'3'
argument_list|)
expr_stmt|;
name|init_floating_libfuncs
argument_list|(
name|smax_optab
argument_list|,
literal|"max"
argument_list|,
literal|'3'
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_uminqi3
if|if
condition|(
name|HAVE_uminqi3
condition|)
name|umin_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|QImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_uminqi3
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_uminhi3
if|if
condition|(
name|HAVE_uminhi3
condition|)
name|umin_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|HImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_uminhi3
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_uminsi3
if|if
condition|(
name|HAVE_uminsi3
condition|)
name|umin_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|SImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_uminsi3
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_umindi3
if|if
condition|(
name|HAVE_umindi3
condition|)
name|umin_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|DImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_umindi3
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_uminti3
if|if
condition|(
name|HAVE_uminti3
condition|)
name|umin_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|TImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_uminti3
expr_stmt|;
endif|#
directive|endif
name|init_integral_libfuncs
argument_list|(
name|umin_optab
argument_list|,
literal|"umin"
argument_list|,
literal|'3'
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_umaxqi3
if|if
condition|(
name|HAVE_umaxqi3
condition|)
name|umax_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|QImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_umaxqi3
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_umaxhi3
if|if
condition|(
name|HAVE_umaxhi3
condition|)
name|umax_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|HImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_umaxhi3
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_umaxsi3
if|if
condition|(
name|HAVE_umaxsi3
condition|)
name|umax_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|SImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_umaxsi3
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_umaxdi3
if|if
condition|(
name|HAVE_umaxdi3
condition|)
name|umax_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|DImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_umaxdi3
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_umaxti3
if|if
condition|(
name|HAVE_umaxti3
condition|)
name|umax_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|TImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_umaxti3
expr_stmt|;
endif|#
directive|endif
name|init_integral_libfuncs
argument_list|(
name|umax_optab
argument_list|,
literal|"umax"
argument_list|,
literal|'3'
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_negqi2
if|if
condition|(
name|HAVE_negqi2
condition|)
name|neg_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|QImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_negqi2
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_neghi2
if|if
condition|(
name|HAVE_neghi2
condition|)
name|neg_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|HImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_neghi2
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_negpsi2
if|if
condition|(
name|HAVE_negpsi2
condition|)
name|neg_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|PSImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_negpsi2
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_negsi2
if|if
condition|(
name|HAVE_negsi2
condition|)
name|neg_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|SImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_negsi2
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_negdi2
if|if
condition|(
name|HAVE_negdi2
condition|)
name|neg_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|DImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_negdi2
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_negti2
if|if
condition|(
name|HAVE_negti2
condition|)
name|neg_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|TImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_negti2
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_negsf2
if|if
condition|(
name|HAVE_negsf2
condition|)
name|neg_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|SFmode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_negsf2
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_negdf2
if|if
condition|(
name|HAVE_negdf2
condition|)
name|neg_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|DFmode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_negdf2
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_negxf2
if|if
condition|(
name|HAVE_negxf2
condition|)
name|neg_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|XFmode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_negxf2
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_negtf2
if|if
condition|(
name|HAVE_negtf2
condition|)
name|neg_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|TFmode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_negtf2
expr_stmt|;
endif|#
directive|endif
name|init_integral_libfuncs
argument_list|(
name|neg_optab
argument_list|,
literal|"neg"
argument_list|,
literal|'2'
argument_list|)
expr_stmt|;
name|init_floating_libfuncs
argument_list|(
name|neg_optab
argument_list|,
literal|"neg"
argument_list|,
literal|'2'
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_absqi2
if|if
condition|(
name|HAVE_absqi2
condition|)
name|abs_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|QImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_absqi2
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_abshi2
if|if
condition|(
name|HAVE_abshi2
condition|)
name|abs_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|HImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_abshi2
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_abspsi2
if|if
condition|(
name|HAVE_abspsi2
condition|)
name|abs_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|PSImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_abspsi2
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_abssi2
if|if
condition|(
name|HAVE_abssi2
condition|)
name|abs_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|SImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_abssi2
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_absdi2
if|if
condition|(
name|HAVE_absdi2
condition|)
name|abs_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|DImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_absdi2
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_absti2
if|if
condition|(
name|HAVE_absti2
condition|)
name|abs_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|TImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_absti2
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_abssf2
if|if
condition|(
name|HAVE_abssf2
condition|)
name|abs_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|SFmode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_abssf2
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_absdf2
if|if
condition|(
name|HAVE_absdf2
condition|)
name|abs_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|DFmode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_absdf2
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_absxf2
if|if
condition|(
name|HAVE_absxf2
condition|)
name|abs_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|XFmode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_absxf2
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_abstf2
if|if
condition|(
name|HAVE_abstf2
condition|)
name|abs_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|TFmode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_abstf2
expr_stmt|;
endif|#
directive|endif
comment|/* Use cabs for DC complex abs, since systems generally have cabs.      Don't define any libcall for SCmode, so that cabs will be used.  */
name|abs_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|DCmode
index|]
operator|.
name|libfunc
operator|=
name|gen_rtx
argument_list|(
name|SYMBOL_REF
argument_list|,
name|Pmode
argument_list|,
literal|"cabs"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_sqrtqi2
if|if
condition|(
name|HAVE_sqrtqi2
condition|)
name|sqrt_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|QImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_sqrtqi2
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_sqrthi2
if|if
condition|(
name|HAVE_sqrthi2
condition|)
name|sqrt_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|HImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_sqrthi2
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_sqrtpsi2
if|if
condition|(
name|HAVE_sqrtpsi2
condition|)
name|sqrt_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|PSImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_sqrtpsi2
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_sqrtsi2
if|if
condition|(
name|HAVE_sqrtsi2
condition|)
name|sqrt_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|SImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_sqrtsi2
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_sqrtdi2
if|if
condition|(
name|HAVE_sqrtdi2
condition|)
name|sqrt_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|DImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_sqrtdi2
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_sqrtti2
if|if
condition|(
name|HAVE_sqrtti2
condition|)
name|sqrt_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|TImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_sqrtti2
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_sqrtsf2
if|if
condition|(
name|HAVE_sqrtsf2
condition|)
name|sqrt_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|SFmode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_sqrtsf2
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_sqrtdf2
if|if
condition|(
name|HAVE_sqrtdf2
condition|)
name|sqrt_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|DFmode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_sqrtdf2
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_sqrttf2
if|if
condition|(
name|HAVE_sqrttf2
condition|)
name|sqrt_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|TFmode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_sqrttf2
expr_stmt|;
endif|#
directive|endif
comment|/* No library calls here!  If there is no sqrt instruction expand_builtin      should force the library call.  */
ifdef|#
directive|ifdef
name|HAVE_sinsf2
if|if
condition|(
name|HAVE_sinsf2
condition|)
name|sin_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|SFmode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_sinsf2
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_sindf2
if|if
condition|(
name|HAVE_sindf2
condition|)
name|sin_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|DFmode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_sindf2
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_sintf2
if|if
condition|(
name|HAVE_sintf2
condition|)
name|sin_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|TFmode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_sintf2
expr_stmt|;
endif|#
directive|endif
comment|/* No library calls here!  If there is no sin instruction expand_builtin      should force the library call.  */
ifdef|#
directive|ifdef
name|HAVE_cossf2
if|if
condition|(
name|HAVE_cossf2
condition|)
name|cos_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|SFmode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_cossf2
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_cosdf2
if|if
condition|(
name|HAVE_cosdf2
condition|)
name|cos_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|DFmode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_cosdf2
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_costf2
if|if
condition|(
name|HAVE_costf2
condition|)
name|cos_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|TFmode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_costf2
expr_stmt|;
endif|#
directive|endif
comment|/* No library calls here!  If there is no cos instruction expand_builtin      should force the library call.  */
ifdef|#
directive|ifdef
name|HAVE_strlenqi
if|if
condition|(
name|HAVE_strlenqi
condition|)
name|strlen_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|QImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_strlenqi
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_strlenhi
if|if
condition|(
name|HAVE_strlenhi
condition|)
name|strlen_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|HImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_strlenhi
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_strlenpsi
if|if
condition|(
name|HAVE_strlenpsi
condition|)
name|strlen_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|PSImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_strlenpsi
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_strlensi
if|if
condition|(
name|HAVE_strlensi
condition|)
name|strlen_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|SImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_strlensi
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_strlendi
if|if
condition|(
name|HAVE_strlendi
condition|)
name|strlen_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|DImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_strlendi
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_strlenti
if|if
condition|(
name|HAVE_strlenti
condition|)
name|strlen_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|TImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_strlenti
expr_stmt|;
endif|#
directive|endif
comment|/* No library calls here!  If there is no strlen instruction expand_builtin      should force the library call.  */
ifdef|#
directive|ifdef
name|HAVE_one_cmplqi2
if|if
condition|(
name|HAVE_one_cmplqi2
condition|)
name|one_cmpl_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|QImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_one_cmplqi2
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_one_cmplhi2
if|if
condition|(
name|HAVE_one_cmplhi2
condition|)
name|one_cmpl_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|HImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_one_cmplhi2
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_one_cmplpsi2
if|if
condition|(
name|HAVE_one_cmplpsi2
condition|)
name|one_cmpl_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|PSImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_one_cmplpsi2
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_one_cmplsi2
if|if
condition|(
name|HAVE_one_cmplsi2
condition|)
name|one_cmpl_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|SImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_one_cmplsi2
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_one_cmpldi2
if|if
condition|(
name|HAVE_one_cmpldi2
condition|)
name|one_cmpl_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|DImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_one_cmpldi2
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_one_cmplti2
if|if
condition|(
name|HAVE_one_cmplti2
condition|)
name|one_cmpl_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|TImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_one_cmplti2
expr_stmt|;
endif|#
directive|endif
name|init_integral_libfuncs
argument_list|(
name|one_cmpl_optab
argument_list|,
literal|"one_cmpl"
argument_list|,
literal|'2'
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_ffsqi2
if|if
condition|(
name|HAVE_ffsqi2
condition|)
name|ffs_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|QImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_ffsqi2
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_ffshi2
if|if
condition|(
name|HAVE_ffshi2
condition|)
name|ffs_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|HImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_ffshi2
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_ffspsi2
if|if
condition|(
name|HAVE_ffspsi2
condition|)
name|ffs_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|PSImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_ffspsi2
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_ffssi2
if|if
condition|(
name|HAVE_ffssi2
condition|)
name|ffs_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|SImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_ffssi2
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_ffsdi2
if|if
condition|(
name|HAVE_ffsdi2
condition|)
name|ffs_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|DImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_ffsdi2
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_ffsti2
if|if
condition|(
name|HAVE_ffsti2
condition|)
name|ffs_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|TImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_ffsti2
expr_stmt|;
endif|#
directive|endif
name|init_integral_libfuncs
argument_list|(
name|ffs_optab
argument_list|,
literal|"ffs"
argument_list|,
literal|'2'
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_movqi
if|if
condition|(
name|HAVE_movqi
condition|)
name|mov_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|QImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_movqi
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_movhi
if|if
condition|(
name|HAVE_movhi
condition|)
name|mov_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|HImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_movhi
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_movpsi
if|if
condition|(
name|HAVE_movpsi
condition|)
name|mov_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|PSImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_movpsi
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_movsi
if|if
condition|(
name|HAVE_movsi
condition|)
name|mov_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|SImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_movsi
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_movdi
if|if
condition|(
name|HAVE_movdi
condition|)
name|mov_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|DImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_movdi
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_movti
if|if
condition|(
name|HAVE_movti
condition|)
name|mov_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|TImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_movti
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_movsf
if|if
condition|(
name|HAVE_movsf
condition|)
name|mov_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|SFmode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_movsf
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_movdf
if|if
condition|(
name|HAVE_movdf
condition|)
name|mov_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|DFmode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_movdf
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_movxf
if|if
condition|(
name|HAVE_movxf
condition|)
name|mov_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|XFmode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_movxf
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_movtf
if|if
condition|(
name|HAVE_movtf
condition|)
name|mov_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|TFmode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_movtf
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_movcc
if|if
condition|(
name|HAVE_movcc
condition|)
name|mov_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|CCmode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_movcc
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|EXTRA_CC_MODES
name|init_mov_optab
argument_list|()
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_movstrictqi
if|if
condition|(
name|HAVE_movstrictqi
condition|)
name|movstrict_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|QImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_movstrictqi
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_movstricthi
if|if
condition|(
name|HAVE_movstricthi
condition|)
name|movstrict_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|HImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_movstricthi
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_movstrictpsi
if|if
condition|(
name|HAVE_movstrictpsi
condition|)
name|movstrict_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|PSImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_movstrictpsi
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_movstrictsi
if|if
condition|(
name|HAVE_movstrictsi
condition|)
name|movstrict_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|SImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_movstrictsi
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_movstrictdi
if|if
condition|(
name|HAVE_movstrictdi
condition|)
name|movstrict_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|DImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_movstrictdi
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_movstrictti
if|if
condition|(
name|HAVE_movstrictti
condition|)
name|movstrict_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|TImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_movstrictti
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_cmpqi
if|if
condition|(
name|HAVE_cmpqi
condition|)
name|cmp_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|QImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_cmpqi
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_cmphi
if|if
condition|(
name|HAVE_cmphi
condition|)
name|cmp_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|HImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_cmphi
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_cmppsi
if|if
condition|(
name|HAVE_cmppsi
condition|)
name|cmp_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|PSImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_cmppsi
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_cmpsi
if|if
condition|(
name|HAVE_cmpsi
condition|)
name|cmp_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|SImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_cmpsi
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_cmpdi
if|if
condition|(
name|HAVE_cmpdi
condition|)
name|cmp_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|DImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_cmpdi
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_cmpti
if|if
condition|(
name|HAVE_cmpti
condition|)
name|cmp_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|TImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_cmpti
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_cmpsf
if|if
condition|(
name|HAVE_cmpsf
condition|)
name|cmp_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|SFmode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_cmpsf
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_cmpdf
if|if
condition|(
name|HAVE_cmpdf
condition|)
name|cmp_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|DFmode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_cmpdf
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_cmpxf
if|if
condition|(
name|HAVE_cmpxf
condition|)
name|cmp_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|XFmode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_cmpxf
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_cmptf
if|if
condition|(
name|HAVE_cmptf
condition|)
name|cmp_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|TFmode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_cmptf
expr_stmt|;
endif|#
directive|endif
comment|/* Comparison libcalls for integers MUST come in pairs, signed/unsigned.  */
name|init_integral_libfuncs
argument_list|(
name|cmp_optab
argument_list|,
literal|"cmp"
argument_list|,
literal|'2'
argument_list|)
expr_stmt|;
name|init_integral_libfuncs
argument_list|(
name|ucmp_optab
argument_list|,
literal|"ucmp"
argument_list|,
literal|'2'
argument_list|)
expr_stmt|;
name|init_floating_libfuncs
argument_list|(
name|cmp_optab
argument_list|,
literal|"cmp"
argument_list|,
literal|'2'
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_tstqi
if|if
condition|(
name|HAVE_tstqi
condition|)
name|tst_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|QImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_tstqi
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_tsthi
if|if
condition|(
name|HAVE_tsthi
condition|)
name|tst_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|HImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_tsthi
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_tstpsi
if|if
condition|(
name|HAVE_tstpsi
condition|)
name|tst_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|PSImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_tstpsi
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_tstsi
if|if
condition|(
name|HAVE_tstsi
condition|)
name|tst_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|SImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_tstsi
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_tstdi
if|if
condition|(
name|HAVE_tstdi
condition|)
name|tst_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|DImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_tstdi
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_tstti
if|if
condition|(
name|HAVE_tstti
condition|)
name|tst_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|TImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_tstti
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_tstsf
if|if
condition|(
name|HAVE_tstsf
condition|)
name|tst_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|SFmode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_tstsf
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_tstdf
if|if
condition|(
name|HAVE_tstdf
condition|)
name|tst_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|DFmode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_tstdf
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_tstxf
if|if
condition|(
name|HAVE_tstxf
condition|)
name|tst_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|XFmode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_tstxf
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_tsttf
if|if
condition|(
name|HAVE_tsttf
condition|)
name|tst_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|TFmode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_tsttf
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_beq
if|if
condition|(
name|HAVE_beq
condition|)
name|bcc_gen_fctn
index|[
operator|(
name|int
operator|)
name|EQ
index|]
operator|=
name|gen_beq
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_bne
if|if
condition|(
name|HAVE_bne
condition|)
name|bcc_gen_fctn
index|[
operator|(
name|int
operator|)
name|NE
index|]
operator|=
name|gen_bne
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_bgt
if|if
condition|(
name|HAVE_bgt
condition|)
name|bcc_gen_fctn
index|[
operator|(
name|int
operator|)
name|GT
index|]
operator|=
name|gen_bgt
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_bge
if|if
condition|(
name|HAVE_bge
condition|)
name|bcc_gen_fctn
index|[
operator|(
name|int
operator|)
name|GE
index|]
operator|=
name|gen_bge
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_bgtu
if|if
condition|(
name|HAVE_bgtu
condition|)
name|bcc_gen_fctn
index|[
operator|(
name|int
operator|)
name|GTU
index|]
operator|=
name|gen_bgtu
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_bgeu
if|if
condition|(
name|HAVE_bgeu
condition|)
name|bcc_gen_fctn
index|[
operator|(
name|int
operator|)
name|GEU
index|]
operator|=
name|gen_bgeu
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_blt
if|if
condition|(
name|HAVE_blt
condition|)
name|bcc_gen_fctn
index|[
operator|(
name|int
operator|)
name|LT
index|]
operator|=
name|gen_blt
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_ble
if|if
condition|(
name|HAVE_ble
condition|)
name|bcc_gen_fctn
index|[
operator|(
name|int
operator|)
name|LE
index|]
operator|=
name|gen_ble
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_bltu
if|if
condition|(
name|HAVE_bltu
condition|)
name|bcc_gen_fctn
index|[
operator|(
name|int
operator|)
name|LTU
index|]
operator|=
name|gen_bltu
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_bleu
if|if
condition|(
name|HAVE_bleu
condition|)
name|bcc_gen_fctn
index|[
operator|(
name|int
operator|)
name|LEU
index|]
operator|=
name|gen_bleu
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_RTX_CODE
condition|;
name|i
operator|++
control|)
name|setcc_gen_code
index|[
name|i
index|]
operator|=
name|CODE_FOR_nothing
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_seq
if|if
condition|(
name|HAVE_seq
condition|)
name|setcc_gen_code
index|[
operator|(
name|int
operator|)
name|EQ
index|]
operator|=
name|CODE_FOR_seq
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_sne
if|if
condition|(
name|HAVE_sne
condition|)
name|setcc_gen_code
index|[
operator|(
name|int
operator|)
name|NE
index|]
operator|=
name|CODE_FOR_sne
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_sgt
if|if
condition|(
name|HAVE_sgt
condition|)
name|setcc_gen_code
index|[
operator|(
name|int
operator|)
name|GT
index|]
operator|=
name|CODE_FOR_sgt
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_sge
if|if
condition|(
name|HAVE_sge
condition|)
name|setcc_gen_code
index|[
operator|(
name|int
operator|)
name|GE
index|]
operator|=
name|CODE_FOR_sge
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_sgtu
if|if
condition|(
name|HAVE_sgtu
condition|)
name|setcc_gen_code
index|[
operator|(
name|int
operator|)
name|GTU
index|]
operator|=
name|CODE_FOR_sgtu
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_sgeu
if|if
condition|(
name|HAVE_sgeu
condition|)
name|setcc_gen_code
index|[
operator|(
name|int
operator|)
name|GEU
index|]
operator|=
name|CODE_FOR_sgeu
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_slt
if|if
condition|(
name|HAVE_slt
condition|)
name|setcc_gen_code
index|[
operator|(
name|int
operator|)
name|LT
index|]
operator|=
name|CODE_FOR_slt
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_sle
if|if
condition|(
name|HAVE_sle
condition|)
name|setcc_gen_code
index|[
operator|(
name|int
operator|)
name|LE
index|]
operator|=
name|CODE_FOR_sle
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_sltu
if|if
condition|(
name|HAVE_sltu
condition|)
name|setcc_gen_code
index|[
operator|(
name|int
operator|)
name|LTU
index|]
operator|=
name|CODE_FOR_sltu
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_sleu
if|if
condition|(
name|HAVE_sleu
condition|)
name|setcc_gen_code
index|[
operator|(
name|int
operator|)
name|LEU
index|]
operator|=
name|CODE_FOR_sleu
expr_stmt|;
endif|#
directive|endif
name|extendsfdf2_libfunc
operator|=
name|gen_rtx
argument_list|(
name|SYMBOL_REF
argument_list|,
name|Pmode
argument_list|,
literal|"__extendsfdf2"
argument_list|)
expr_stmt|;
name|extendsfxf2_libfunc
operator|=
name|gen_rtx
argument_list|(
name|SYMBOL_REF
argument_list|,
name|Pmode
argument_list|,
literal|"__extendsfxf2"
argument_list|)
expr_stmt|;
name|extendsftf2_libfunc
operator|=
name|gen_rtx
argument_list|(
name|SYMBOL_REF
argument_list|,
name|Pmode
argument_list|,
literal|"__extendsftf2"
argument_list|)
expr_stmt|;
name|extenddfxf2_libfunc
operator|=
name|gen_rtx
argument_list|(
name|SYMBOL_REF
argument_list|,
name|Pmode
argument_list|,
literal|"__extenddfxf2"
argument_list|)
expr_stmt|;
name|extenddftf2_libfunc
operator|=
name|gen_rtx
argument_list|(
name|SYMBOL_REF
argument_list|,
name|Pmode
argument_list|,
literal|"__extenddftf2"
argument_list|)
expr_stmt|;
name|truncdfsf2_libfunc
operator|=
name|gen_rtx
argument_list|(
name|SYMBOL_REF
argument_list|,
name|Pmode
argument_list|,
literal|"__truncdfsf2"
argument_list|)
expr_stmt|;
name|truncxfsf2_libfunc
operator|=
name|gen_rtx
argument_list|(
name|SYMBOL_REF
argument_list|,
name|Pmode
argument_list|,
literal|"__truncxfsf2"
argument_list|)
expr_stmt|;
name|trunctfsf2_libfunc
operator|=
name|gen_rtx
argument_list|(
name|SYMBOL_REF
argument_list|,
name|Pmode
argument_list|,
literal|"__trunctfsf2"
argument_list|)
expr_stmt|;
name|truncxfdf2_libfunc
operator|=
name|gen_rtx
argument_list|(
name|SYMBOL_REF
argument_list|,
name|Pmode
argument_list|,
literal|"__truncxfdf2"
argument_list|)
expr_stmt|;
name|trunctfdf2_libfunc
operator|=
name|gen_rtx
argument_list|(
name|SYMBOL_REF
argument_list|,
name|Pmode
argument_list|,
literal|"__trunctfdf2"
argument_list|)
expr_stmt|;
name|memcpy_libfunc
operator|=
name|gen_rtx
argument_list|(
name|SYMBOL_REF
argument_list|,
name|Pmode
argument_list|,
literal|"memcpy"
argument_list|)
expr_stmt|;
name|bcopy_libfunc
operator|=
name|gen_rtx
argument_list|(
name|SYMBOL_REF
argument_list|,
name|Pmode
argument_list|,
literal|"bcopy"
argument_list|)
expr_stmt|;
name|memcmp_libfunc
operator|=
name|gen_rtx
argument_list|(
name|SYMBOL_REF
argument_list|,
name|Pmode
argument_list|,
literal|"memcmp"
argument_list|)
expr_stmt|;
name|bcmp_libfunc
operator|=
name|gen_rtx
argument_list|(
name|SYMBOL_REF
argument_list|,
name|Pmode
argument_list|,
literal|"__gcc_bcmp"
argument_list|)
expr_stmt|;
name|memset_libfunc
operator|=
name|gen_rtx
argument_list|(
name|SYMBOL_REF
argument_list|,
name|Pmode
argument_list|,
literal|"memset"
argument_list|)
expr_stmt|;
name|bzero_libfunc
operator|=
name|gen_rtx
argument_list|(
name|SYMBOL_REF
argument_list|,
name|Pmode
argument_list|,
literal|"bzero"
argument_list|)
expr_stmt|;
name|eqsf2_libfunc
operator|=
name|gen_rtx
argument_list|(
name|SYMBOL_REF
argument_list|,
name|Pmode
argument_list|,
literal|"__eqsf2"
argument_list|)
expr_stmt|;
name|nesf2_libfunc
operator|=
name|gen_rtx
argument_list|(
name|SYMBOL_REF
argument_list|,
name|Pmode
argument_list|,
literal|"__nesf2"
argument_list|)
expr_stmt|;
name|gtsf2_libfunc
operator|=
name|gen_rtx
argument_list|(
name|SYMBOL_REF
argument_list|,
name|Pmode
argument_list|,
literal|"__gtsf2"
argument_list|)
expr_stmt|;
name|gesf2_libfunc
operator|=
name|gen_rtx
argument_list|(
name|SYMBOL_REF
argument_list|,
name|Pmode
argument_list|,
literal|"__gesf2"
argument_list|)
expr_stmt|;
name|ltsf2_libfunc
operator|=
name|gen_rtx
argument_list|(
name|SYMBOL_REF
argument_list|,
name|Pmode
argument_list|,
literal|"__ltsf2"
argument_list|)
expr_stmt|;
name|lesf2_libfunc
operator|=
name|gen_rtx
argument_list|(
name|SYMBOL_REF
argument_list|,
name|Pmode
argument_list|,
literal|"__lesf2"
argument_list|)
expr_stmt|;
name|eqdf2_libfunc
operator|=
name|gen_rtx
argument_list|(
name|SYMBOL_REF
argument_list|,
name|Pmode
argument_list|,
literal|"__eqdf2"
argument_list|)
expr_stmt|;
name|nedf2_libfunc
operator|=
name|gen_rtx
argument_list|(
name|SYMBOL_REF
argument_list|,
name|Pmode
argument_list|,
literal|"__nedf2"
argument_list|)
expr_stmt|;
name|gtdf2_libfunc
operator|=
name|gen_rtx
argument_list|(
name|SYMBOL_REF
argument_list|,
name|Pmode
argument_list|,
literal|"__gtdf2"
argument_list|)
expr_stmt|;
name|gedf2_libfunc
operator|=
name|gen_rtx
argument_list|(
name|SYMBOL_REF
argument_list|,
name|Pmode
argument_list|,
literal|"__gedf2"
argument_list|)
expr_stmt|;
name|ltdf2_libfunc
operator|=
name|gen_rtx
argument_list|(
name|SYMBOL_REF
argument_list|,
name|Pmode
argument_list|,
literal|"__ltdf2"
argument_list|)
expr_stmt|;
name|ledf2_libfunc
operator|=
name|gen_rtx
argument_list|(
name|SYMBOL_REF
argument_list|,
name|Pmode
argument_list|,
literal|"__ledf2"
argument_list|)
expr_stmt|;
name|eqxf2_libfunc
operator|=
name|gen_rtx
argument_list|(
name|SYMBOL_REF
argument_list|,
name|Pmode
argument_list|,
literal|"__eqxf2"
argument_list|)
expr_stmt|;
name|nexf2_libfunc
operator|=
name|gen_rtx
argument_list|(
name|SYMBOL_REF
argument_list|,
name|Pmode
argument_list|,
literal|"__nexf2"
argument_list|)
expr_stmt|;
name|gtxf2_libfunc
operator|=
name|gen_rtx
argument_list|(
name|SYMBOL_REF
argument_list|,
name|Pmode
argument_list|,
literal|"__gtxf2"
argument_list|)
expr_stmt|;
name|gexf2_libfunc
operator|=
name|gen_rtx
argument_list|(
name|SYMBOL_REF
argument_list|,
name|Pmode
argument_list|,
literal|"__gexf2"
argument_list|)
expr_stmt|;
name|ltxf2_libfunc
operator|=
name|gen_rtx
argument_list|(
name|SYMBOL_REF
argument_list|,
name|Pmode
argument_list|,
literal|"__ltxf2"
argument_list|)
expr_stmt|;
name|lexf2_libfunc
operator|=
name|gen_rtx
argument_list|(
name|SYMBOL_REF
argument_list|,
name|Pmode
argument_list|,
literal|"__lexf2"
argument_list|)
expr_stmt|;
name|eqtf2_libfunc
operator|=
name|gen_rtx
argument_list|(
name|SYMBOL_REF
argument_list|,
name|Pmode
argument_list|,
literal|"__eqtf2"
argument_list|)
expr_stmt|;
name|netf2_libfunc
operator|=
name|gen_rtx
argument_list|(
name|SYMBOL_REF
argument_list|,
name|Pmode
argument_list|,
literal|"__netf2"
argument_list|)
expr_stmt|;
name|gttf2_libfunc
operator|=
name|gen_rtx
argument_list|(
name|SYMBOL_REF
argument_list|,
name|Pmode
argument_list|,
literal|"__gttf2"
argument_list|)
expr_stmt|;
name|getf2_libfunc
operator|=
name|gen_rtx
argument_list|(
name|SYMBOL_REF
argument_list|,
name|Pmode
argument_list|,
literal|"__getf2"
argument_list|)
expr_stmt|;
name|lttf2_libfunc
operator|=
name|gen_rtx
argument_list|(
name|SYMBOL_REF
argument_list|,
name|Pmode
argument_list|,
literal|"__lttf2"
argument_list|)
expr_stmt|;
name|letf2_libfunc
operator|=
name|gen_rtx
argument_list|(
name|SYMBOL_REF
argument_list|,
name|Pmode
argument_list|,
literal|"__letf2"
argument_list|)
expr_stmt|;
name|floatsisf_libfunc
operator|=
name|gen_rtx
argument_list|(
name|SYMBOL_REF
argument_list|,
name|Pmode
argument_list|,
literal|"__floatsisf"
argument_list|)
expr_stmt|;
name|floatdisf_libfunc
operator|=
name|gen_rtx
argument_list|(
name|SYMBOL_REF
argument_list|,
name|Pmode
argument_list|,
literal|"__floatdisf"
argument_list|)
expr_stmt|;
name|floattisf_libfunc
operator|=
name|gen_rtx
argument_list|(
name|SYMBOL_REF
argument_list|,
name|Pmode
argument_list|,
literal|"__floattisf"
argument_list|)
expr_stmt|;
name|floatsidf_libfunc
operator|=
name|gen_rtx
argument_list|(
name|SYMBOL_REF
argument_list|,
name|Pmode
argument_list|,
literal|"__floatsidf"
argument_list|)
expr_stmt|;
name|floatdidf_libfunc
operator|=
name|gen_rtx
argument_list|(
name|SYMBOL_REF
argument_list|,
name|Pmode
argument_list|,
literal|"__floatdidf"
argument_list|)
expr_stmt|;
name|floattidf_libfunc
operator|=
name|gen_rtx
argument_list|(
name|SYMBOL_REF
argument_list|,
name|Pmode
argument_list|,
literal|"__floattidf"
argument_list|)
expr_stmt|;
name|floatsixf_libfunc
operator|=
name|gen_rtx
argument_list|(
name|SYMBOL_REF
argument_list|,
name|Pmode
argument_list|,
literal|"__floatsixf"
argument_list|)
expr_stmt|;
name|floatdixf_libfunc
operator|=
name|gen_rtx
argument_list|(
name|SYMBOL_REF
argument_list|,
name|Pmode
argument_list|,
literal|"__floatdixf"
argument_list|)
expr_stmt|;
name|floattixf_libfunc
operator|=
name|gen_rtx
argument_list|(
name|SYMBOL_REF
argument_list|,
name|Pmode
argument_list|,
literal|"__floattixf"
argument_list|)
expr_stmt|;
name|floatsitf_libfunc
operator|=
name|gen_rtx
argument_list|(
name|SYMBOL_REF
argument_list|,
name|Pmode
argument_list|,
literal|"__floatsitf"
argument_list|)
expr_stmt|;
name|floatditf_libfunc
operator|=
name|gen_rtx
argument_list|(
name|SYMBOL_REF
argument_list|,
name|Pmode
argument_list|,
literal|"__floatditf"
argument_list|)
expr_stmt|;
name|floattitf_libfunc
operator|=
name|gen_rtx
argument_list|(
name|SYMBOL_REF
argument_list|,
name|Pmode
argument_list|,
literal|"__floattitf"
argument_list|)
expr_stmt|;
name|fixsfsi_libfunc
operator|=
name|gen_rtx
argument_list|(
name|SYMBOL_REF
argument_list|,
name|Pmode
argument_list|,
literal|"__fixsfsi"
argument_list|)
expr_stmt|;
name|fixsfdi_libfunc
operator|=
name|gen_rtx
argument_list|(
name|SYMBOL_REF
argument_list|,
name|Pmode
argument_list|,
literal|"__fixsfdi"
argument_list|)
expr_stmt|;
name|fixsfti_libfunc
operator|=
name|gen_rtx
argument_list|(
name|SYMBOL_REF
argument_list|,
name|Pmode
argument_list|,
literal|"__fixsfti"
argument_list|)
expr_stmt|;
name|fixdfsi_libfunc
operator|=
name|gen_rtx
argument_list|(
name|SYMBOL_REF
argument_list|,
name|Pmode
argument_list|,
literal|"__fixdfsi"
argument_list|)
expr_stmt|;
name|fixdfdi_libfunc
operator|=
name|gen_rtx
argument_list|(
name|SYMBOL_REF
argument_list|,
name|Pmode
argument_list|,
literal|"__fixdfdi"
argument_list|)
expr_stmt|;
name|fixdfti_libfunc
operator|=
name|gen_rtx
argument_list|(
name|SYMBOL_REF
argument_list|,
name|Pmode
argument_list|,
literal|"__fixdfti"
argument_list|)
expr_stmt|;
name|fixxfsi_libfunc
operator|=
name|gen_rtx
argument_list|(
name|SYMBOL_REF
argument_list|,
name|Pmode
argument_list|,
literal|"__fixxfsi"
argument_list|)
expr_stmt|;
name|fixxfdi_libfunc
operator|=
name|gen_rtx
argument_list|(
name|SYMBOL_REF
argument_list|,
name|Pmode
argument_list|,
literal|"__fixxfdi"
argument_list|)
expr_stmt|;
name|fixxfti_libfunc
operator|=
name|gen_rtx
argument_list|(
name|SYMBOL_REF
argument_list|,
name|Pmode
argument_list|,
literal|"__fixxfti"
argument_list|)
expr_stmt|;
name|fixtfsi_libfunc
operator|=
name|gen_rtx
argument_list|(
name|SYMBOL_REF
argument_list|,
name|Pmode
argument_list|,
literal|"__fixtfsi"
argument_list|)
expr_stmt|;
name|fixtfdi_libfunc
operator|=
name|gen_rtx
argument_list|(
name|SYMBOL_REF
argument_list|,
name|Pmode
argument_list|,
literal|"__fixtfdi"
argument_list|)
expr_stmt|;
name|fixtfti_libfunc
operator|=
name|gen_rtx
argument_list|(
name|SYMBOL_REF
argument_list|,
name|Pmode
argument_list|,
literal|"__fixtfti"
argument_list|)
expr_stmt|;
name|fixunssfsi_libfunc
operator|=
name|gen_rtx
argument_list|(
name|SYMBOL_REF
argument_list|,
name|Pmode
argument_list|,
literal|"__fixunssfsi"
argument_list|)
expr_stmt|;
name|fixunssfdi_libfunc
operator|=
name|gen_rtx
argument_list|(
name|SYMBOL_REF
argument_list|,
name|Pmode
argument_list|,
literal|"__fixunssfdi"
argument_list|)
expr_stmt|;
name|fixunssfti_libfunc
operator|=
name|gen_rtx
argument_list|(
name|SYMBOL_REF
argument_list|,
name|Pmode
argument_list|,
literal|"__fixunssfti"
argument_list|)
expr_stmt|;
name|fixunsdfsi_libfunc
operator|=
name|gen_rtx
argument_list|(
name|SYMBOL_REF
argument_list|,
name|Pmode
argument_list|,
literal|"__fixunsdfsi"
argument_list|)
expr_stmt|;
name|fixunsdfdi_libfunc
operator|=
name|gen_rtx
argument_list|(
name|SYMBOL_REF
argument_list|,
name|Pmode
argument_list|,
literal|"__fixunsdfdi"
argument_list|)
expr_stmt|;
name|fixunsdfti_libfunc
operator|=
name|gen_rtx
argument_list|(
name|SYMBOL_REF
argument_list|,
name|Pmode
argument_list|,
literal|"__fixunsdfti"
argument_list|)
expr_stmt|;
name|fixunsxfsi_libfunc
operator|=
name|gen_rtx
argument_list|(
name|SYMBOL_REF
argument_list|,
name|Pmode
argument_list|,
literal|"__fixunsxfsi"
argument_list|)
expr_stmt|;
name|fixunsxfdi_libfunc
operator|=
name|gen_rtx
argument_list|(
name|SYMBOL_REF
argument_list|,
name|Pmode
argument_list|,
literal|"__fixunsxfdi"
argument_list|)
expr_stmt|;
name|fixunsxfti_libfunc
operator|=
name|gen_rtx
argument_list|(
name|SYMBOL_REF
argument_list|,
name|Pmode
argument_list|,
literal|"__fixunsxfti"
argument_list|)
expr_stmt|;
name|fixunstfsi_libfunc
operator|=
name|gen_rtx
argument_list|(
name|SYMBOL_REF
argument_list|,
name|Pmode
argument_list|,
literal|"__fixunstfsi"
argument_list|)
expr_stmt|;
name|fixunstfdi_libfunc
operator|=
name|gen_rtx
argument_list|(
name|SYMBOL_REF
argument_list|,
name|Pmode
argument_list|,
literal|"__fixunstfdi"
argument_list|)
expr_stmt|;
name|fixunstfti_libfunc
operator|=
name|gen_rtx
argument_list|(
name|SYMBOL_REF
argument_list|,
name|Pmode
argument_list|,
literal|"__fixunstfti"
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|BROKEN_LDEXP
end_ifdef

begin_comment
comment|/* SCO 3.2 apparently has a broken ldexp. */
end_comment

begin_function
name|double
name|ldexp
parameter_list|(
name|x
parameter_list|,
name|n
parameter_list|)
name|double
name|x
decl_stmt|;
name|int
name|n
decl_stmt|;
block|{
if|if
condition|(
name|n
operator|>
literal|0
condition|)
while|while
condition|(
name|n
operator|--
condition|)
name|x
operator|*=
literal|2
expr_stmt|;
return|return
name|x
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* BROKEN_LDEXP */
end_comment

end_unit

