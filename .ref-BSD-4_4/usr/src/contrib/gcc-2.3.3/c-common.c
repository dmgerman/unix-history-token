begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Subroutines shared by all languages that are variants of C.    Copyright (C) 1992 Free Software Foundation, Inc.  This file is part of GNU CC.  GNU CC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU CC; see the file COPYING.  If not, write to the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"c-lex.h"
end_include

begin_include
include|#
directive|include
file|"c-tree.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_comment
comment|/* Make bindings for __FUNCTION__ and __PRETTY_FUNCTION__.  */
end_comment

begin_function
name|void
name|declare_function_name
parameter_list|()
block|{
name|tree
name|decl
decl_stmt|,
name|init
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|,
modifier|*
name|printable_name
decl_stmt|;
if|if
condition|(
name|current_function_decl
operator|==
name|NULL
condition|)
block|{
name|name
operator|=
literal|""
expr_stmt|;
name|printable_name
operator|=
literal|"top level"
expr_stmt|;
block|}
else|else
block|{
name|char
modifier|*
name|kind
init|=
literal|"function"
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
operator|==
name|METHOD_TYPE
condition|)
name|kind
operator|=
literal|"method"
expr_stmt|;
comment|/* Allow functions to be nameless (such as artificial ones).  */
if|if
condition|(
name|DECL_NAME
argument_list|(
name|current_function_decl
argument_list|)
condition|)
name|name
operator|=
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|name
operator|=
literal|""
expr_stmt|;
name|printable_name
operator|=
call|(
modifier|*
name|decl_printable_name
call|)
argument_list|(
name|current_function_decl
argument_list|,
operator|&
name|kind
argument_list|)
expr_stmt|;
block|}
name|push_obstacks_nochange
argument_list|()
expr_stmt|;
name|decl
operator|=
name|build_decl
argument_list|(
name|VAR_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"__FUNCTION__"
argument_list|)
argument_list|,
name|char_array_type_node
argument_list|)
expr_stmt|;
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_READONLY
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_SOURCE_LINE
argument_list|(
name|decl
argument_list|)
operator|=
literal|0
expr_stmt|;
name|DECL_IN_SYSTEM_HEADER
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_IGNORED_P
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|init
operator|=
name|build_string
argument_list|(
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|1
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|init
argument_list|)
operator|=
name|char_array_type_node
expr_stmt|;
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|=
name|init
expr_stmt|;
name|finish_decl
argument_list|(
name|pushdecl
argument_list|(
name|decl
argument_list|)
argument_list|,
name|init
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|push_obstacks_nochange
argument_list|()
expr_stmt|;
name|decl
operator|=
name|build_decl
argument_list|(
name|VAR_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"__PRETTY_FUNCTION__"
argument_list|)
argument_list|,
name|char_array_type_node
argument_list|)
expr_stmt|;
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_READONLY
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_SOURCE_LINE
argument_list|(
name|decl
argument_list|)
operator|=
literal|0
expr_stmt|;
name|DECL_IN_SYSTEM_HEADER
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_IGNORED_P
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|init
operator|=
name|build_string
argument_list|(
name|strlen
argument_list|(
name|printable_name
argument_list|)
operator|+
literal|1
argument_list|,
name|printable_name
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|init
argument_list|)
operator|=
name|char_array_type_node
expr_stmt|;
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|=
name|init
expr_stmt|;
name|finish_decl
argument_list|(
name|pushdecl
argument_list|(
name|decl
argument_list|)
argument_list|,
name|init
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Given a chain of STRING_CST nodes,    concatenate them into one STRING_CST    and give it a suitable array-of-chars data type.  */
end_comment

begin_function
name|tree
name|combine_strings
parameter_list|(
name|strings
parameter_list|)
name|tree
name|strings
decl_stmt|;
block|{
specifier|register
name|tree
name|value
decl_stmt|,
name|t
decl_stmt|;
specifier|register
name|int
name|length
init|=
literal|1
decl_stmt|;
name|int
name|wide_length
init|=
literal|0
decl_stmt|;
name|int
name|wide_flag
init|=
literal|0
decl_stmt|;
name|int
name|wchar_bytes
init|=
name|TYPE_PRECISION
argument_list|(
name|wchar_type_node
argument_list|)
operator|/
name|BITS_PER_UNIT
decl_stmt|;
name|int
name|nchars
decl_stmt|;
if|if
condition|(
name|TREE_CHAIN
argument_list|(
name|strings
argument_list|)
condition|)
block|{
comment|/* More than one in the chain, so concatenate.  */
specifier|register
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
comment|/* Don't include the \0 at the end of each substring, 	 except for the last one. 	 Count wide strings and ordinary strings separately.  */
for|for
control|(
name|t
operator|=
name|strings
init|;
name|t
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
block|{
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
operator|==
name|wchar_array_type_node
condition|)
block|{
name|wide_length
operator|+=
operator|(
name|TREE_STRING_LENGTH
argument_list|(
name|t
argument_list|)
operator|-
name|wchar_bytes
operator|)
expr_stmt|;
name|wide_flag
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|length
operator|+=
operator|(
name|TREE_STRING_LENGTH
argument_list|(
name|t
argument_list|)
operator|-
literal|1
operator|)
expr_stmt|;
block|}
comment|/* If anything is wide, the non-wides will be converted, 	 which makes them take more space.  */
if|if
condition|(
name|wide_flag
condition|)
name|length
operator|=
name|length
operator|*
name|wchar_bytes
operator|+
name|wide_length
expr_stmt|;
name|p
operator|=
name|savealloc
argument_list|(
name|length
argument_list|)
expr_stmt|;
comment|/* Copy the individual strings into the new combined string. 	 If the combined string is wide, convert the chars to ints 	 for any individual strings that are not wide.  */
name|q
operator|=
name|p
expr_stmt|;
for|for
control|(
name|t
operator|=
name|strings
init|;
name|t
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
block|{
name|int
name|len
init|=
operator|(
name|TREE_STRING_LENGTH
argument_list|(
name|t
argument_list|)
operator|-
operator|(
operator|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
operator|==
name|wchar_array_type_node
operator|)
condition|?
name|wchar_bytes
else|:
literal|1
operator|)
operator|)
decl_stmt|;
if|if
condition|(
operator|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
operator|==
name|wchar_array_type_node
operator|)
operator|==
name|wide_flag
condition|)
block|{
name|bcopy
argument_list|(
name|TREE_STRING_POINTER
argument_list|(
name|t
argument_list|)
argument_list|,
name|q
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|q
operator|+=
name|len
expr_stmt|;
block|}
else|else
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
operator|(
operator|(
name|int
operator|*
operator|)
name|q
operator|)
index|[
name|i
index|]
operator|=
name|TREE_STRING_POINTER
argument_list|(
name|t
argument_list|)
index|[
name|i
index|]
expr_stmt|;
name|q
operator|+=
name|len
operator|*
name|wchar_bytes
expr_stmt|;
block|}
block|}
if|if
condition|(
name|wide_flag
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|wchar_bytes
condition|;
name|i
operator|++
control|)
operator|*
name|q
operator|++
operator|=
literal|0
expr_stmt|;
block|}
else|else
operator|*
name|q
operator|=
literal|0
expr_stmt|;
name|value
operator|=
name|make_node
argument_list|(
name|STRING_CST
argument_list|)
expr_stmt|;
name|TREE_STRING_POINTER
argument_list|(
name|value
argument_list|)
operator|=
name|p
expr_stmt|;
name|TREE_STRING_LENGTH
argument_list|(
name|value
argument_list|)
operator|=
name|length
expr_stmt|;
name|TREE_CONSTANT
argument_list|(
name|value
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|value
operator|=
name|strings
expr_stmt|;
name|length
operator|=
name|TREE_STRING_LENGTH
argument_list|(
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|value
argument_list|)
operator|==
name|wchar_array_type_node
condition|)
name|wide_flag
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Compute the number of elements, for the array type.  */
name|nchars
operator|=
name|wide_flag
condition|?
name|length
operator|/
name|wchar_bytes
else|:
name|length
expr_stmt|;
comment|/* Create the array type for the string constant.      -Wwrite-strings says make the string constant an array of const char      so that copying it to a non-const pointer will get a warning.  */
if|if
condition|(
name|warn_write_strings
operator|&&
operator|(
operator|!
name|flag_traditional
operator|&&
operator|!
name|flag_writable_strings
operator|)
condition|)
block|{
name|tree
name|elements
init|=
name|build_type_variant
argument_list|(
name|wide_flag
condition|?
name|wchar_type_node
else|:
name|char_type_node
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|TREE_TYPE
argument_list|(
name|value
argument_list|)
operator|=
name|build_array_type
argument_list|(
name|elements
argument_list|,
name|build_index_type
argument_list|(
name|build_int_2
argument_list|(
name|nchars
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|TREE_TYPE
argument_list|(
name|value
argument_list|)
operator|=
name|build_array_type
argument_list|(
name|wide_flag
condition|?
name|wchar_type_node
else|:
name|char_type_node
argument_list|,
name|build_index_type
argument_list|(
name|build_int_2
argument_list|(
name|nchars
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_CONSTANT
argument_list|(
name|value
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_STATIC
argument_list|(
name|value
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|value
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Process the attributes listed in ATTRIBUTES    and install them in DECL.  */
end_comment

begin_function
name|void
name|decl_attributes
parameter_list|(
name|decl
parameter_list|,
name|attributes
parameter_list|)
name|tree
name|decl
decl_stmt|,
name|attributes
decl_stmt|;
block|{
name|tree
name|a
decl_stmt|;
for|for
control|(
name|a
operator|=
name|attributes
init|;
name|a
condition|;
name|a
operator|=
name|TREE_CHAIN
argument_list|(
name|a
argument_list|)
control|)
if|if
condition|(
name|TREE_VALUE
argument_list|(
name|a
argument_list|)
operator|==
name|get_identifier
argument_list|(
literal|"packed"
argument_list|)
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FIELD_DECL
condition|)
name|DECL_PACKED
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* We can't set DECL_PACKED for a VAR_DECL, because the bit is 	   used for DECL_REGISTER.  It wouldn't mean anything anyway.  */
block|}
elseif|else
if|if
condition|(
name|TREE_VALUE
argument_list|(
name|a
argument_list|)
operator|!=
literal|0
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_VALUE
argument_list|(
name|a
argument_list|)
argument_list|)
operator|==
name|TREE_LIST
operator|&&
name|TREE_PURPOSE
argument_list|(
name|TREE_VALUE
argument_list|(
name|a
argument_list|)
argument_list|)
operator|==
name|get_identifier
argument_list|(
literal|"mode"
argument_list|)
condition|)
block|{
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|specified_name
init|=
name|IDENTIFIER_POINTER
argument_list|(
name|TREE_VALUE
argument_list|(
name|TREE_VALUE
argument_list|(
name|a
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
comment|/* Give this decl a type with the specified mode.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_MACHINE_MODES
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|specified_name
argument_list|,
name|GET_MODE_NAME
argument_list|(
name|i
argument_list|)
argument_list|)
condition|)
block|{
name|tree
name|type
init|=
name|type_for_mode
argument_list|(
name|i
argument_list|,
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|type
operator|!=
literal|0
condition|)
block|{
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
operator|=
name|type
expr_stmt|;
name|DECL_SIZE
argument_list|(
name|decl
argument_list|)
operator|=
literal|0
expr_stmt|;
name|layout_decl
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
name|error
argument_list|(
literal|"no data type for mode `%s'"
argument_list|,
name|specified_name
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|i
operator|==
name|NUM_MACHINE_MODES
condition|)
name|error
argument_list|(
literal|"unknown machine mode `%s'"
argument_list|,
name|specified_name
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_VALUE
argument_list|(
name|a
argument_list|)
operator|!=
literal|0
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_VALUE
argument_list|(
name|a
argument_list|)
argument_list|)
operator|==
name|TREE_LIST
operator|&&
name|TREE_PURPOSE
argument_list|(
name|TREE_VALUE
argument_list|(
name|a
argument_list|)
argument_list|)
operator|==
name|get_identifier
argument_list|(
literal|"aligned"
argument_list|)
condition|)
block|{
name|int
name|align
init|=
name|TREE_INT_CST_LOW
argument_list|(
name|TREE_VALUE
argument_list|(
name|TREE_VALUE
argument_list|(
name|a
argument_list|)
argument_list|)
argument_list|)
operator|*
name|BITS_PER_UNIT
decl_stmt|;
if|if
condition|(
name|exact_log2
argument_list|(
name|align
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|error_with_decl
argument_list|(
name|decl
argument_list|,
literal|"requested alignment of `%s' is not a power of 2"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|VAR_DECL
operator|&&
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|FIELD_DECL
condition|)
name|error_with_decl
argument_list|(
name|decl
argument_list|,
literal|"alignment specified for `%s'"
argument_list|)
expr_stmt|;
else|else
name|DECL_ALIGN
argument_list|(
name|decl
argument_list|)
operator|=
name|align
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_VALUE
argument_list|(
name|a
argument_list|)
operator|!=
literal|0
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_VALUE
argument_list|(
name|a
argument_list|)
argument_list|)
operator|==
name|TREE_LIST
operator|&&
name|TREE_PURPOSE
argument_list|(
name|TREE_VALUE
argument_list|(
name|a
argument_list|)
argument_list|)
operator|==
name|get_identifier
argument_list|(
literal|"format"
argument_list|)
condition|)
block|{
name|tree
name|list
init|=
name|TREE_VALUE
argument_list|(
name|TREE_VALUE
argument_list|(
name|a
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|format_type
init|=
name|TREE_PURPOSE
argument_list|(
name|list
argument_list|)
decl_stmt|;
name|int
name|format_num
init|=
name|TREE_INT_CST_LOW
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|TREE_VALUE
argument_list|(
name|list
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|first_arg_num
init|=
name|TREE_INT_CST_LOW
argument_list|(
name|TREE_VALUE
argument_list|(
name|TREE_VALUE
argument_list|(
name|list
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|is_scan
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|FUNCTION_DECL
condition|)
block|{
name|error_with_decl
argument_list|(
name|decl
argument_list|,
literal|"argument format specified for non-function `%s'"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|format_type
operator|==
name|get_identifier
argument_list|(
literal|"printf"
argument_list|)
condition|)
name|is_scan
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|format_type
operator|==
name|get_identifier
argument_list|(
literal|"scanf"
argument_list|)
condition|)
name|is_scan
operator|=
literal|1
expr_stmt|;
else|else
block|{
name|error_with_decl
argument_list|(
name|decl
argument_list|,
literal|"unrecognized format specifier for `%s'"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|first_arg_num
operator|!=
literal|0
operator|&&
name|first_arg_num
operator|<=
name|format_num
condition|)
block|{
name|error_with_decl
argument_list|(
name|decl
argument_list|,
literal|"format string arg follows the args to be formatted, for `%s'"
argument_list|)
expr_stmt|;
return|return;
block|}
name|record_format_info
argument_list|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|,
name|is_scan
argument_list|,
name|format_num
argument_list|,
name|first_arg_num
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Print a warning if a constant expression had overflow in folding.  */
end_comment

begin_function
name|void
name|constant_expression_warning
parameter_list|(
name|value
parameter_list|)
name|tree
name|value
decl_stmt|;
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|TREE_CONSTANT_OVERFLOW
argument_list|(
name|value
argument_list|)
condition|)
name|pedwarn
argument_list|(
literal|"overflow in constant expression"
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function
name|void
name|c_expand_expr_stmt
parameter_list|(
name|expr
parameter_list|)
name|tree
name|expr
decl_stmt|;
block|{
comment|/* Do default conversion if safe and possibly important,      in case within ({...}).  */
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
operator|==
name|ARRAY_TYPE
operator|&&
name|lvalue_p
argument_list|(
name|expr
argument_list|)
operator|)
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
name|expr
operator|=
name|default_conversion
argument_list|(
name|expr
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
operator|!=
name|error_mark_node
operator|&&
name|TYPE_SIZE
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
operator|==
literal|0
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
operator|!=
name|ARRAY_TYPE
condition|)
name|error
argument_list|(
literal|"expression statement has incomplete type"
argument_list|)
expr_stmt|;
name|expand_expr_stmt
argument_list|(
name|expr
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Validate the expression after `case' and apply default promotions.  */
end_comment

begin_function
name|tree
name|check_case_value
parameter_list|(
name|value
parameter_list|)
name|tree
name|value
decl_stmt|;
block|{
if|if
condition|(
name|value
operator|==
name|NULL_TREE
condition|)
return|return
name|value
return|;
comment|/* Strip NON_LVALUE_EXPRs since we aren't using as an lvalue.  */
name|STRIP_TYPE_NOPS
argument_list|(
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|!=
name|INTEGER_CST
operator|&&
name|value
operator|!=
name|error_mark_node
condition|)
block|{
name|error
argument_list|(
literal|"case label does not reduce to an integer constant"
argument_list|)
expr_stmt|;
name|value
operator|=
name|error_mark_node
expr_stmt|;
block|}
else|else
comment|/* Promote char or short to int.  */
name|value
operator|=
name|default_conversion
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|constant_expression_warning
argument_list|(
name|value
argument_list|)
expr_stmt|;
return|return
name|value
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return an integer type with BITS bits of precision,    that is unsigned if UNSIGNEDP is nonzero, otherwise signed.  */
end_comment

begin_function
name|tree
name|type_for_size
parameter_list|(
name|bits
parameter_list|,
name|unsignedp
parameter_list|)
name|unsigned
name|bits
decl_stmt|;
name|int
name|unsignedp
decl_stmt|;
block|{
if|if
condition|(
name|bits
operator|==
name|TYPE_PRECISION
argument_list|(
name|signed_char_type_node
argument_list|)
condition|)
return|return
name|unsignedp
condition|?
name|unsigned_char_type_node
else|:
name|signed_char_type_node
return|;
if|if
condition|(
name|bits
operator|==
name|TYPE_PRECISION
argument_list|(
name|short_integer_type_node
argument_list|)
condition|)
return|return
name|unsignedp
condition|?
name|short_unsigned_type_node
else|:
name|short_integer_type_node
return|;
if|if
condition|(
name|bits
operator|==
name|TYPE_PRECISION
argument_list|(
name|integer_type_node
argument_list|)
condition|)
return|return
name|unsignedp
condition|?
name|unsigned_type_node
else|:
name|integer_type_node
return|;
if|if
condition|(
name|bits
operator|==
name|TYPE_PRECISION
argument_list|(
name|long_integer_type_node
argument_list|)
condition|)
return|return
name|unsignedp
condition|?
name|long_unsigned_type_node
else|:
name|long_integer_type_node
return|;
if|if
condition|(
name|bits
operator|==
name|TYPE_PRECISION
argument_list|(
name|long_long_integer_type_node
argument_list|)
condition|)
return|return
operator|(
name|unsignedp
condition|?
name|long_long_unsigned_type_node
else|:
name|long_long_integer_type_node
operator|)
return|;
if|if
condition|(
name|bits
operator|<=
name|TYPE_PRECISION
argument_list|(
name|intQI_type_node
argument_list|)
condition|)
return|return
name|unsignedp
condition|?
name|unsigned_intQI_type_node
else|:
name|intQI_type_node
return|;
if|if
condition|(
name|bits
operator|<=
name|TYPE_PRECISION
argument_list|(
name|intHI_type_node
argument_list|)
condition|)
return|return
name|unsignedp
condition|?
name|unsigned_intHI_type_node
else|:
name|intHI_type_node
return|;
if|if
condition|(
name|bits
operator|<=
name|TYPE_PRECISION
argument_list|(
name|intSI_type_node
argument_list|)
condition|)
return|return
name|unsignedp
condition|?
name|unsigned_intSI_type_node
else|:
name|intSI_type_node
return|;
if|if
condition|(
name|bits
operator|<=
name|TYPE_PRECISION
argument_list|(
name|intDI_type_node
argument_list|)
condition|)
return|return
name|unsignedp
condition|?
name|unsigned_intDI_type_node
else|:
name|intDI_type_node
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return a data type that has machine mode MODE.    If the mode is an integer,    then UNSIGNEDP selects between signed and unsigned types.  */
end_comment

begin_function
name|tree
name|type_for_mode
parameter_list|(
name|mode
parameter_list|,
name|unsignedp
parameter_list|)
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|int
name|unsignedp
decl_stmt|;
block|{
if|if
condition|(
name|mode
operator|==
name|TYPE_MODE
argument_list|(
name|signed_char_type_node
argument_list|)
condition|)
return|return
name|unsignedp
condition|?
name|unsigned_char_type_node
else|:
name|signed_char_type_node
return|;
if|if
condition|(
name|mode
operator|==
name|TYPE_MODE
argument_list|(
name|short_integer_type_node
argument_list|)
condition|)
return|return
name|unsignedp
condition|?
name|short_unsigned_type_node
else|:
name|short_integer_type_node
return|;
if|if
condition|(
name|mode
operator|==
name|TYPE_MODE
argument_list|(
name|integer_type_node
argument_list|)
condition|)
return|return
name|unsignedp
condition|?
name|unsigned_type_node
else|:
name|integer_type_node
return|;
if|if
condition|(
name|mode
operator|==
name|TYPE_MODE
argument_list|(
name|long_integer_type_node
argument_list|)
condition|)
return|return
name|unsignedp
condition|?
name|long_unsigned_type_node
else|:
name|long_integer_type_node
return|;
if|if
condition|(
name|mode
operator|==
name|TYPE_MODE
argument_list|(
name|long_long_integer_type_node
argument_list|)
condition|)
return|return
name|unsignedp
condition|?
name|long_long_unsigned_type_node
else|:
name|long_long_integer_type_node
return|;
if|if
condition|(
name|mode
operator|==
name|TYPE_MODE
argument_list|(
name|intQI_type_node
argument_list|)
condition|)
return|return
name|unsignedp
condition|?
name|unsigned_intQI_type_node
else|:
name|intQI_type_node
return|;
if|if
condition|(
name|mode
operator|==
name|TYPE_MODE
argument_list|(
name|intHI_type_node
argument_list|)
condition|)
return|return
name|unsignedp
condition|?
name|unsigned_intHI_type_node
else|:
name|intHI_type_node
return|;
if|if
condition|(
name|mode
operator|==
name|TYPE_MODE
argument_list|(
name|intSI_type_node
argument_list|)
condition|)
return|return
name|unsignedp
condition|?
name|unsigned_intSI_type_node
else|:
name|intSI_type_node
return|;
if|if
condition|(
name|mode
operator|==
name|TYPE_MODE
argument_list|(
name|intDI_type_node
argument_list|)
condition|)
return|return
name|unsignedp
condition|?
name|unsigned_intDI_type_node
else|:
name|intDI_type_node
return|;
if|if
condition|(
name|mode
operator|==
name|TYPE_MODE
argument_list|(
name|float_type_node
argument_list|)
condition|)
return|return
name|float_type_node
return|;
if|if
condition|(
name|mode
operator|==
name|TYPE_MODE
argument_list|(
name|double_type_node
argument_list|)
condition|)
return|return
name|double_type_node
return|;
if|if
condition|(
name|mode
operator|==
name|TYPE_MODE
argument_list|(
name|long_double_type_node
argument_list|)
condition|)
return|return
name|long_double_type_node
return|;
if|if
condition|(
name|mode
operator|==
name|TYPE_MODE
argument_list|(
name|build_pointer_type
argument_list|(
name|char_type_node
argument_list|)
argument_list|)
condition|)
return|return
name|build_pointer_type
argument_list|(
name|char_type_node
argument_list|)
return|;
if|if
condition|(
name|mode
operator|==
name|TYPE_MODE
argument_list|(
name|build_pointer_type
argument_list|(
name|integer_type_node
argument_list|)
argument_list|)
condition|)
return|return
name|build_pointer_type
argument_list|(
name|integer_type_node
argument_list|)
return|;
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Print an error message for invalid operands to arith operation CODE.    NOP_EXPR is used as a special case (see truthvalue_conversion).  */
end_comment

begin_function
name|void
name|binary_op_error
parameter_list|(
name|code
parameter_list|)
name|enum
name|tree_code
name|code
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|opname
decl_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|NOP_EXPR
case|:
name|error
argument_list|(
literal|"invalid truth-value expression"
argument_list|)
expr_stmt|;
return|return;
case|case
name|PLUS_EXPR
case|:
name|opname
operator|=
literal|"+"
expr_stmt|;
break|break;
case|case
name|MINUS_EXPR
case|:
name|opname
operator|=
literal|"-"
expr_stmt|;
break|break;
case|case
name|MULT_EXPR
case|:
name|opname
operator|=
literal|"*"
expr_stmt|;
break|break;
case|case
name|MAX_EXPR
case|:
name|opname
operator|=
literal|"max"
expr_stmt|;
break|break;
case|case
name|MIN_EXPR
case|:
name|opname
operator|=
literal|"min"
expr_stmt|;
break|break;
case|case
name|EQ_EXPR
case|:
name|opname
operator|=
literal|"=="
expr_stmt|;
break|break;
case|case
name|NE_EXPR
case|:
name|opname
operator|=
literal|"!="
expr_stmt|;
break|break;
case|case
name|LE_EXPR
case|:
name|opname
operator|=
literal|"<="
expr_stmt|;
break|break;
case|case
name|GE_EXPR
case|:
name|opname
operator|=
literal|">="
expr_stmt|;
break|break;
case|case
name|LT_EXPR
case|:
name|opname
operator|=
literal|"<"
expr_stmt|;
break|break;
case|case
name|GT_EXPR
case|:
name|opname
operator|=
literal|">"
expr_stmt|;
break|break;
case|case
name|LSHIFT_EXPR
case|:
name|opname
operator|=
literal|"<<"
expr_stmt|;
break|break;
case|case
name|RSHIFT_EXPR
case|:
name|opname
operator|=
literal|">>"
expr_stmt|;
break|break;
case|case
name|TRUNC_MOD_EXPR
case|:
case|case
name|FLOOR_MOD_EXPR
case|:
name|opname
operator|=
literal|"%"
expr_stmt|;
break|break;
case|case
name|TRUNC_DIV_EXPR
case|:
case|case
name|FLOOR_DIV_EXPR
case|:
name|opname
operator|=
literal|"/"
expr_stmt|;
break|break;
case|case
name|BIT_AND_EXPR
case|:
name|opname
operator|=
literal|"&"
expr_stmt|;
break|break;
case|case
name|BIT_IOR_EXPR
case|:
name|opname
operator|=
literal|"|"
expr_stmt|;
break|break;
case|case
name|TRUTH_ANDIF_EXPR
case|:
name|opname
operator|=
literal|"&&"
expr_stmt|;
break|break;
case|case
name|TRUTH_ORIF_EXPR
case|:
name|opname
operator|=
literal|"||"
expr_stmt|;
break|break;
case|case
name|BIT_XOR_EXPR
case|:
name|opname
operator|=
literal|"^"
expr_stmt|;
break|break;
case|case
name|LROTATE_EXPR
case|:
case|case
name|RROTATE_EXPR
case|:
name|opname
operator|=
literal|"rotate"
expr_stmt|;
break|break;
block|}
name|error
argument_list|(
literal|"invalid operands to binary %s"
argument_list|,
name|opname
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Subroutine of build_binary_op, used for comparison operations.    See if the operands have both been converted from subword integer types    and, if so, perhaps change them both back to their original type.     The arguments of this function are all pointers to local variables    of build_binary_op: OP0_PTR is&OP0, OP1_PTR is&OP1,    RESTYPE_PTR is&RESULT_TYPE and RESCODE_PTR is&RESULTCODE.     If this function returns nonzero, it means that the comparison has    a constant value.  What this function returns is an expression for    that value.  */
end_comment

begin_function
name|tree
name|shorten_compare
parameter_list|(
name|op0_ptr
parameter_list|,
name|op1_ptr
parameter_list|,
name|restype_ptr
parameter_list|,
name|rescode_ptr
parameter_list|)
name|tree
modifier|*
name|op0_ptr
decl_stmt|,
decl|*
name|op1_ptr
decl_stmt|;
end_function

begin_decl_stmt
name|tree
modifier|*
name|restype_ptr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|enum
name|tree_code
modifier|*
name|rescode_ptr
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|tree
name|type
decl_stmt|;
name|tree
name|op0
init|=
operator|*
name|op0_ptr
decl_stmt|;
name|tree
name|op1
init|=
operator|*
name|op1_ptr
decl_stmt|;
name|int
name|unsignedp0
decl_stmt|,
name|unsignedp1
decl_stmt|;
name|int
name|real1
decl_stmt|,
name|real2
decl_stmt|;
name|tree
name|primop0
decl_stmt|,
name|primop1
decl_stmt|;
name|enum
name|tree_code
name|code
init|=
operator|*
name|rescode_ptr
decl_stmt|;
comment|/* Throw away any conversions to wider types      already present in the operands.  */
name|primop0
operator|=
name|get_narrower
argument_list|(
name|op0
argument_list|,
operator|&
name|unsignedp0
argument_list|)
expr_stmt|;
name|primop1
operator|=
name|get_narrower
argument_list|(
name|op1
argument_list|,
operator|&
name|unsignedp1
argument_list|)
expr_stmt|;
comment|/* Handle the case that OP0 does not *contain* a conversion      but it *requires* conversion to FINAL_TYPE.  */
if|if
condition|(
name|op0
operator|==
name|primop0
operator|&&
name|TREE_TYPE
argument_list|(
name|op0
argument_list|)
operator|!=
operator|*
name|restype_ptr
condition|)
name|unsignedp0
operator|=
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|op0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|op1
operator|==
name|primop1
operator|&&
name|TREE_TYPE
argument_list|(
name|op1
argument_list|)
operator|!=
operator|*
name|restype_ptr
condition|)
name|unsignedp1
operator|=
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|op1
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If one of the operands must be floated, we cannot optimize.  */
name|real1
operator|=
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|primop0
argument_list|)
argument_list|)
operator|==
name|REAL_TYPE
expr_stmt|;
name|real2
operator|=
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|primop1
argument_list|)
argument_list|)
operator|==
name|REAL_TYPE
expr_stmt|;
comment|/* If first arg is constant, swap the args (changing operation      so value is preserved), for canonicalization.  */
if|if
condition|(
name|TREE_CONSTANT
argument_list|(
name|primop0
argument_list|)
condition|)
block|{
specifier|register
name|tree
name|tem
init|=
name|primop0
decl_stmt|;
specifier|register
name|int
name|temi
init|=
name|unsignedp0
decl_stmt|;
name|primop0
operator|=
name|primop1
expr_stmt|;
name|primop1
operator|=
name|tem
expr_stmt|;
name|tem
operator|=
name|op0
expr_stmt|;
name|op0
operator|=
name|op1
expr_stmt|;
name|op1
operator|=
name|tem
expr_stmt|;
operator|*
name|op0_ptr
operator|=
name|op0
expr_stmt|;
operator|*
name|op1_ptr
operator|=
name|op1
expr_stmt|;
name|unsignedp0
operator|=
name|unsignedp1
expr_stmt|;
name|unsignedp1
operator|=
name|temi
expr_stmt|;
name|temi
operator|=
name|real1
expr_stmt|;
name|real1
operator|=
name|real2
expr_stmt|;
name|real2
operator|=
name|temi
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|LT_EXPR
case|:
name|code
operator|=
name|GT_EXPR
expr_stmt|;
break|break;
case|case
name|GT_EXPR
case|:
name|code
operator|=
name|LT_EXPR
expr_stmt|;
break|break;
case|case
name|LE_EXPR
case|:
name|code
operator|=
name|GE_EXPR
expr_stmt|;
break|break;
case|case
name|GE_EXPR
case|:
name|code
operator|=
name|LE_EXPR
expr_stmt|;
break|break;
block|}
operator|*
name|rescode_ptr
operator|=
name|code
expr_stmt|;
block|}
comment|/* If comparing an integer against a constant more bits wide,      maybe we can deduce a value of 1 or 0 independent of the data.      Or else truncate the constant now      rather than extend the variable at run time.       This is only interesting if the constant is the wider arg.      Also, it is not safe if the constant is unsigned and the      variable arg is signed, since in this case the variable      would be sign-extended and then regarded as unsigned.      Our technique fails in this case because the lowest/highest      possible unsigned results don't follow naturally from the      lowest/highest possible values of the variable operand.      For just EQ_EXPR and NE_EXPR there is another technique that      could be used: see if the constant can be faithfully represented      in the other operand's type, by truncating it and reextending it      and see if that preserves the constant's value.  */
if|if
condition|(
operator|!
name|real1
operator|&&
operator|!
name|real2
operator|&&
name|TREE_CODE
argument_list|(
name|primop1
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|primop0
argument_list|)
argument_list|)
operator|<
name|TYPE_PRECISION
argument_list|(
operator|*
name|restype_ptr
argument_list|)
condition|)
block|{
name|int
name|min_gt
decl_stmt|,
name|max_gt
decl_stmt|,
name|min_lt
decl_stmt|,
name|max_lt
decl_stmt|;
name|tree
name|maxval
decl_stmt|,
name|minval
decl_stmt|;
comment|/* 1 if comparison is nominally unsigned.  */
name|int
name|unsignedp
init|=
name|TREE_UNSIGNED
argument_list|(
operator|*
name|restype_ptr
argument_list|)
decl_stmt|;
name|tree
name|val
decl_stmt|;
name|type
operator|=
name|signed_or_unsigned_type
argument_list|(
name|unsignedp0
argument_list|,
name|TREE_TYPE
argument_list|(
name|primop0
argument_list|)
argument_list|)
expr_stmt|;
name|maxval
operator|=
name|TYPE_MAX_VALUE
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|minval
operator|=
name|TYPE_MIN_VALUE
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|unsignedp
operator|&&
operator|!
name|unsignedp0
condition|)
operator|*
name|restype_ptr
operator|=
name|signed_type
argument_list|(
operator|*
name|restype_ptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|primop1
argument_list|)
operator|!=
operator|*
name|restype_ptr
condition|)
name|primop1
operator|=
name|convert
argument_list|(
operator|*
name|restype_ptr
argument_list|,
name|primop1
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|!=
operator|*
name|restype_ptr
condition|)
block|{
name|minval
operator|=
name|convert
argument_list|(
operator|*
name|restype_ptr
argument_list|,
name|minval
argument_list|)
expr_stmt|;
name|maxval
operator|=
name|convert
argument_list|(
operator|*
name|restype_ptr
argument_list|,
name|maxval
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|unsignedp
operator|&&
name|unsignedp0
condition|)
block|{
name|min_gt
operator|=
name|INT_CST_LT_UNSIGNED
argument_list|(
name|primop1
argument_list|,
name|minval
argument_list|)
expr_stmt|;
name|max_gt
operator|=
name|INT_CST_LT_UNSIGNED
argument_list|(
name|primop1
argument_list|,
name|maxval
argument_list|)
expr_stmt|;
name|min_lt
operator|=
name|INT_CST_LT_UNSIGNED
argument_list|(
name|minval
argument_list|,
name|primop1
argument_list|)
expr_stmt|;
name|max_lt
operator|=
name|INT_CST_LT_UNSIGNED
argument_list|(
name|maxval
argument_list|,
name|primop1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|min_gt
operator|=
name|INT_CST_LT
argument_list|(
name|primop1
argument_list|,
name|minval
argument_list|)
expr_stmt|;
name|max_gt
operator|=
name|INT_CST_LT
argument_list|(
name|primop1
argument_list|,
name|maxval
argument_list|)
expr_stmt|;
name|min_lt
operator|=
name|INT_CST_LT
argument_list|(
name|minval
argument_list|,
name|primop1
argument_list|)
expr_stmt|;
name|max_lt
operator|=
name|INT_CST_LT
argument_list|(
name|maxval
argument_list|,
name|primop1
argument_list|)
expr_stmt|;
block|}
name|val
operator|=
literal|0
expr_stmt|;
comment|/* This used to be a switch, but Genix compiler can't handle that.  */
if|if
condition|(
name|code
operator|==
name|NE_EXPR
condition|)
block|{
if|if
condition|(
name|max_lt
operator|||
name|min_gt
condition|)
name|val
operator|=
name|integer_one_node
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|code
operator|==
name|EQ_EXPR
condition|)
block|{
if|if
condition|(
name|max_lt
operator|||
name|min_gt
condition|)
name|val
operator|=
name|integer_zero_node
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|code
operator|==
name|LT_EXPR
condition|)
block|{
if|if
condition|(
name|max_lt
condition|)
name|val
operator|=
name|integer_one_node
expr_stmt|;
if|if
condition|(
operator|!
name|min_lt
condition|)
name|val
operator|=
name|integer_zero_node
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|code
operator|==
name|GT_EXPR
condition|)
block|{
if|if
condition|(
name|min_gt
condition|)
name|val
operator|=
name|integer_one_node
expr_stmt|;
if|if
condition|(
operator|!
name|max_gt
condition|)
name|val
operator|=
name|integer_zero_node
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|code
operator|==
name|LE_EXPR
condition|)
block|{
if|if
condition|(
operator|!
name|max_gt
condition|)
name|val
operator|=
name|integer_one_node
expr_stmt|;
if|if
condition|(
name|min_gt
condition|)
name|val
operator|=
name|integer_zero_node
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|code
operator|==
name|GE_EXPR
condition|)
block|{
if|if
condition|(
operator|!
name|min_lt
condition|)
name|val
operator|=
name|integer_one_node
expr_stmt|;
if|if
condition|(
name|max_lt
condition|)
name|val
operator|=
name|integer_zero_node
expr_stmt|;
block|}
comment|/* If primop0 was sign-extended and unsigned comparison specd, 	 we did a signed comparison above using the signed type bounds. 	 But the comparison we output must be unsigned.  	 Also, for inequalities, VAL is no good; but if the signed 	 comparison had *any* fixed result, it follows that the 	 unsigned comparison just tests the sign in reverse 	 (positive values are LE, negative ones GE). 	 So we can generate an unsigned comparison 	 against an extreme value of the signed type.  */
if|if
condition|(
name|unsignedp
operator|&&
operator|!
name|unsignedp0
condition|)
block|{
if|if
condition|(
name|val
operator|!=
literal|0
condition|)
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|LT_EXPR
case|:
case|case
name|GE_EXPR
case|:
name|primop1
operator|=
name|TYPE_MIN_VALUE
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|val
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|LE_EXPR
case|:
case|case
name|GT_EXPR
case|:
name|primop1
operator|=
name|TYPE_MAX_VALUE
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|val
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|type
operator|=
name|unsigned_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|max_gt
operator|&&
operator|!
name|unsignedp0
condition|)
block|{
comment|/* This is the case of (char)x>?< 0x80, which people used to use 	     expecting old C compilers to change the 0x80 into -0x80.  */
if|if
condition|(
name|val
operator|==
name|integer_zero_node
condition|)
name|warning
argument_list|(
literal|"comparison is always 0 due to limited range of data type"
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|==
name|integer_one_node
condition|)
name|warning
argument_list|(
literal|"comparison is always 1 due to limited range of data type"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|min_lt
operator|&&
name|unsignedp0
condition|)
block|{
comment|/* This is the case of (unsigned char)x>?< -1 or< 0.  */
if|if
condition|(
name|val
operator|==
name|integer_zero_node
condition|)
name|warning
argument_list|(
literal|"comparison is always 0 due to limited range of data type"
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|==
name|integer_one_node
condition|)
name|warning
argument_list|(
literal|"comparison is always 1 due to limited range of data type"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|val
operator|!=
literal|0
condition|)
block|{
comment|/* Don't forget to evaluate PRIMOP0 if it has side effects.  */
if|if
condition|(
name|TREE_SIDE_EFFECTS
argument_list|(
name|primop0
argument_list|)
condition|)
return|return
name|build
argument_list|(
name|COMPOUND_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|val
argument_list|)
argument_list|,
name|primop0
argument_list|,
name|val
argument_list|)
return|;
return|return
name|val
return|;
block|}
comment|/* Value is not predetermined, but do the comparison 	 in the type of the operand that is not constant. 	 TYPE is already properly set.  */
block|}
elseif|else
if|if
condition|(
name|real1
operator|&&
name|real2
operator|&&
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|primop0
argument_list|)
argument_list|)
operator|==
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|primop1
argument_list|)
argument_list|)
condition|)
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|primop0
argument_list|)
expr_stmt|;
comment|/* If args' natural types are both narrower than nominal type      and both extend in the same manner, compare them      in the type of the wider arg.      Otherwise must actually extend both to the nominal      common type lest different ways of extending      alter the result.      (eg, (short)-1 == (unsigned short)-1  should be 0.)  */
elseif|else
if|if
condition|(
name|unsignedp0
operator|==
name|unsignedp1
operator|&&
name|real1
operator|==
name|real2
operator|&&
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|primop0
argument_list|)
argument_list|)
operator|<
name|TYPE_PRECISION
argument_list|(
operator|*
name|restype_ptr
argument_list|)
operator|&&
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|primop1
argument_list|)
argument_list|)
operator|<
name|TYPE_PRECISION
argument_list|(
operator|*
name|restype_ptr
argument_list|)
condition|)
block|{
name|type
operator|=
name|common_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|primop0
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|primop1
argument_list|)
argument_list|)
expr_stmt|;
name|type
operator|=
name|signed_or_unsigned_type
argument_list|(
name|unsignedp0
operator|||
name|TREE_UNSIGNED
argument_list|(
operator|*
name|restype_ptr
argument_list|)
argument_list|,
name|type
argument_list|)
expr_stmt|;
comment|/* Make sure shorter operand is extended the right way 	 to match the longer operand.  */
name|primop0
operator|=
name|convert
argument_list|(
name|signed_or_unsigned_type
argument_list|(
name|unsignedp0
argument_list|,
name|TREE_TYPE
argument_list|(
name|primop0
argument_list|)
argument_list|)
argument_list|,
name|primop0
argument_list|)
expr_stmt|;
name|primop1
operator|=
name|convert
argument_list|(
name|signed_or_unsigned_type
argument_list|(
name|unsignedp1
argument_list|,
name|TREE_TYPE
argument_list|(
name|primop1
argument_list|)
argument_list|)
argument_list|,
name|primop1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Here we must do the comparison on the nominal type 	 using the args exactly as we received them.  */
name|type
operator|=
operator|*
name|restype_ptr
expr_stmt|;
name|primop0
operator|=
name|op0
expr_stmt|;
name|primop1
operator|=
name|op1
expr_stmt|;
if|if
condition|(
operator|!
name|real1
operator|&&
operator|!
name|real2
operator|&&
name|integer_zerop
argument_list|(
name|primop1
argument_list|)
operator|&&
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|primop0
argument_list|)
argument_list|)
condition|)
block|{
name|tree
name|value
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|GE_EXPR
case|:
if|if
condition|(
name|extra_warnings
condition|)
name|warning
argument_list|(
literal|"unsigned value>= 0 is always 1"
argument_list|)
expr_stmt|;
name|value
operator|=
name|integer_one_node
expr_stmt|;
break|break;
case|case
name|LT_EXPR
case|:
if|if
condition|(
name|extra_warnings
condition|)
name|warning
argument_list|(
literal|"unsigned value< 0 is always 0"
argument_list|)
expr_stmt|;
name|value
operator|=
name|integer_zero_node
expr_stmt|;
block|}
if|if
condition|(
name|value
operator|!=
literal|0
condition|)
block|{
comment|/* Don't forget to evaluate PRIMOP0 if it has side effects.  */
if|if
condition|(
name|TREE_SIDE_EFFECTS
argument_list|(
name|primop0
argument_list|)
condition|)
return|return
name|build
argument_list|(
name|COMPOUND_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|value
argument_list|)
argument_list|,
name|primop0
argument_list|,
name|value
argument_list|)
return|;
return|return
name|value
return|;
block|}
block|}
block|}
operator|*
name|op0_ptr
operator|=
name|convert
argument_list|(
name|type
argument_list|,
name|primop0
argument_list|)
expr_stmt|;
operator|*
name|op1_ptr
operator|=
name|convert
argument_list|(
name|type
argument_list|,
name|primop1
argument_list|)
expr_stmt|;
operator|*
name|restype_ptr
operator|=
name|integer_type_node
expr_stmt|;
return|return
literal|0
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* Prepare expr to be an argument of a TRUTH_NOT_EXPR,    or validate its data type for an `if' or `while' statement or ?..: exp.     This preparation consists of taking the ordinary    representation of an expression expr and producing a valid tree    boolean expression describing whether expr is nonzero.  We could    simply always do build_binary_op (NE_EXPR, expr, integer_zero_node, 1),    but we optimize comparisons,&&, ||, and !.     The resulting type should always be `integer_type_node'.  */
end_comment

begin_function
name|tree
name|truthvalue_conversion
parameter_list|(
name|expr
parameter_list|)
name|tree
name|expr
decl_stmt|;
block|{
specifier|register
name|enum
name|tree_code
name|code
decl_stmt|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
condition|)
block|{
comment|/* It is simpler and generates better code to have only TRUTH_*_EXPR 	 or comparison expressions as truth values at this level.  */
if|#
directive|if
literal|0
block|case COMPONENT_REF:
comment|/* A one-bit unsigned bit-field is already acceptable.  */
block|if (1 == TREE_INT_CST_LOW (DECL_SIZE (TREE_OPERAND (expr, 1)))&& TREE_UNSIGNED (TREE_OPERAND (expr, 1))) 	return expr;       break;
endif|#
directive|endif
case|case
name|EQ_EXPR
case|:
comment|/* It is simpler and generates better code to have only TRUTH_*_EXPR 	 or comparison expressions as truth values at this level.  */
if|#
directive|if
literal|0
block|if (integer_zerop (TREE_OPERAND (expr, 1))) 	return build_unary_op (TRUTH_NOT_EXPR, TREE_OPERAND (expr, 0), 0);
endif|#
directive|endif
case|case
name|NE_EXPR
case|:
case|case
name|LE_EXPR
case|:
case|case
name|GE_EXPR
case|:
case|case
name|LT_EXPR
case|:
case|case
name|GT_EXPR
case|:
case|case
name|TRUTH_ANDIF_EXPR
case|:
case|case
name|TRUTH_ORIF_EXPR
case|:
case|case
name|TRUTH_AND_EXPR
case|:
case|case
name|TRUTH_OR_EXPR
case|:
case|case
name|ERROR_MARK
case|:
return|return
name|expr
return|;
case|case
name|INTEGER_CST
case|:
return|return
name|integer_zerop
argument_list|(
name|expr
argument_list|)
condition|?
name|integer_zero_node
else|:
name|integer_one_node
return|;
case|case
name|REAL_CST
case|:
return|return
name|real_zerop
argument_list|(
name|expr
argument_list|)
condition|?
name|integer_zero_node
else|:
name|integer_one_node
return|;
case|case
name|ADDR_EXPR
case|:
if|if
condition|(
name|TREE_SIDE_EFFECTS
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
return|return
name|build
argument_list|(
name|COMPOUND_EXPR
argument_list|,
name|integer_type_node
argument_list|,
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
argument_list|,
name|integer_one_node
argument_list|)
return|;
else|else
return|return
name|integer_one_node
return|;
case|case
name|NEGATE_EXPR
case|:
case|case
name|ABS_EXPR
case|:
case|case
name|FLOAT_EXPR
case|:
case|case
name|FFS_EXPR
case|:
comment|/* These don't change whether an object is non-zero or zero.  */
return|return
name|truthvalue_conversion
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
case|case
name|LROTATE_EXPR
case|:
case|case
name|RROTATE_EXPR
case|:
comment|/* These don't change whether an object is zero or non-zero, but 	 we can't ignore them if their second arg has side-effects.  */
if|if
condition|(
name|TREE_SIDE_EFFECTS
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
return|return
name|build
argument_list|(
name|COMPOUND_EXPR
argument_list|,
name|integer_type_node
argument_list|,
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|1
argument_list|)
argument_list|,
name|truthvalue_conversion
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
return|;
else|else
return|return
name|truthvalue_conversion
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
case|case
name|COND_EXPR
case|:
comment|/* Distribute the conversion into the arms of a COND_EXPR.  */
return|return
name|fold
argument_list|(
name|build
argument_list|(
name|COND_EXPR
argument_list|,
name|integer_type_node
argument_list|,
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
argument_list|,
name|truthvalue_conversion
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|,
name|truthvalue_conversion
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|2
argument_list|)
argument_list|)
argument_list|)
argument_list|)
return|;
case|case
name|CONVERT_EXPR
case|:
comment|/* Don't cancel the effect of a CONVERT_EXPR from a REFERENCE_TYPE, 	 since that affects how `default_conversion' will behave.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
operator|==
name|REFERENCE_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
break|break;
comment|/* fall through... */
case|case
name|NOP_EXPR
case|:
comment|/* If this is widening the argument, we can ignore it.  */
if|if
condition|(
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
operator|>=
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
condition|)
return|return
name|truthvalue_conversion
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
break|break;
case|case
name|BIT_XOR_EXPR
case|:
case|case
name|MINUS_EXPR
case|:
comment|/* These can be changed into a comparison of the two objects.  */
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
return|return
name|build_binary_op
argument_list|(
name|NE_EXPR
argument_list|,
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|1
argument_list|)
return|;
return|return
name|build_binary_op
argument_list|(
name|NE_EXPR
argument_list|,
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
argument_list|,
name|fold
argument_list|(
name|build1
argument_list|(
name|NOP_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
argument_list|,
literal|1
argument_list|)
return|;
case|case
name|MODIFY_EXPR
case|:
if|if
condition|(
name|warn_parentheses
operator|&&
name|C_EXP_ORIGINAL_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|MODIFY_EXPR
condition|)
name|warning
argument_list|(
literal|"suggest parentheses around assignment used as truth value"
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
name|build_binary_op
argument_list|(
name|NE_EXPR
argument_list|,
name|expr
argument_list|,
name|integer_zero_node
argument_list|,
literal|1
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Read the rest of a #-directive from input stream FINPUT.    In normal use, the directive name and the white space after it    have already been read, so they won't be included in the result.    We allow for the fact that the directive line may contain    a newline embedded within a character or string literal which forms    a part of the directive.     The value is a string in a reusable buffer.  It remains valid    only until the next time this function is called.  */
end_comment

begin_function
name|char
modifier|*
name|get_directive_line
parameter_list|(
name|finput
parameter_list|)
specifier|register
name|FILE
modifier|*
name|finput
decl_stmt|;
block|{
specifier|static
name|char
modifier|*
name|directive_buffer
init|=
name|NULL
decl_stmt|;
specifier|static
name|unsigned
name|buffer_length
init|=
literal|0
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|char
modifier|*
name|buffer_limit
decl_stmt|;
specifier|register
name|int
name|looking_for
init|=
literal|0
decl_stmt|;
specifier|register
name|int
name|char_escaped
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|buffer_length
operator|==
literal|0
condition|)
block|{
name|directive_buffer
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
literal|128
argument_list|)
expr_stmt|;
name|buffer_length
operator|=
literal|128
expr_stmt|;
block|}
name|buffer_limit
operator|=
operator|&
name|directive_buffer
index|[
name|buffer_length
index|]
expr_stmt|;
for|for
control|(
name|p
operator|=
name|directive_buffer
init|;
condition|;
control|)
block|{
name|int
name|c
decl_stmt|;
comment|/* Make buffer bigger if it is full.  */
if|if
condition|(
name|p
operator|>=
name|buffer_limit
condition|)
block|{
specifier|register
name|unsigned
name|bytes_used
init|=
operator|(
name|p
operator|-
name|directive_buffer
operator|)
decl_stmt|;
name|buffer_length
operator|*=
literal|2
expr_stmt|;
name|directive_buffer
operator|=
operator|(
name|char
operator|*
operator|)
name|xrealloc
argument_list|(
name|directive_buffer
argument_list|,
name|buffer_length
argument_list|)
expr_stmt|;
name|p
operator|=
operator|&
name|directive_buffer
index|[
name|bytes_used
index|]
expr_stmt|;
name|buffer_limit
operator|=
operator|&
name|directive_buffer
index|[
name|buffer_length
index|]
expr_stmt|;
block|}
name|c
operator|=
name|getc
argument_list|(
name|finput
argument_list|)
expr_stmt|;
comment|/* Discard initial whitespace.  */
if|if
condition|(
operator|(
name|c
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'\t'
operator|)
operator|&&
name|p
operator|==
name|directive_buffer
condition|)
continue|continue;
comment|/* Detect the end of the directive.  */
if|if
condition|(
name|c
operator|==
literal|'\n'
operator|&&
name|looking_for
operator|==
literal|0
condition|)
block|{
name|ungetc
argument_list|(
name|c
argument_list|,
name|finput
argument_list|)
expr_stmt|;
name|c
operator|=
literal|'\0'
expr_stmt|;
block|}
operator|*
name|p
operator|++
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|0
condition|)
return|return
name|directive_buffer
return|;
comment|/* Handle string and character constant syntax.  */
if|if
condition|(
name|looking_for
condition|)
block|{
if|if
condition|(
name|looking_for
operator|==
name|c
operator|&&
operator|!
name|char_escaped
condition|)
name|looking_for
operator|=
literal|0
expr_stmt|;
comment|/* Found terminator... stop looking.  */
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'\''
operator|||
name|c
operator|==
literal|'"'
condition|)
name|looking_for
operator|=
name|c
expr_stmt|;
comment|/* Don't stop buffering until we see another 				   another one of these (or an EOF).  */
comment|/* Handle backslash.  */
name|char_escaped
operator|=
operator|(
name|c
operator|==
literal|'\\'
operator|&&
operator|!
name|char_escaped
operator|)
expr_stmt|;
block|}
block|}
end_function

end_unit

