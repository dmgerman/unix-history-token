begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/***************************************************************************  * This program is Copyright (C) 1986, 1987, 1988 by Jonathan Payne.  JOVE *  * is provided to you without charge, and with no warranty.  You may give  *  * away copies of JOVE, including sources, provided that this notice is    *  * included in all the files.                                              *  ***************************************************************************/
end_comment

begin_comment
comment|/* NOTE WELL:  * This file is "included" into iproc.c -- it is not compiled separately!  */
end_comment

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<sgtty.h>
end_include

begin_include
include|#
directive|include
file|"wait.h"
end_include

begin_define
define|#
directive|define
name|DEAD
value|1
end_define

begin_comment
comment|/* Dead but haven't informed user yet */
end_comment

begin_define
define|#
directive|define
name|STOPPED
value|2
end_define

begin_comment
comment|/* Job stopped */
end_comment

begin_define
define|#
directive|define
name|RUNNING
value|3
end_define

begin_comment
comment|/* Just running */
end_comment

begin_define
define|#
directive|define
name|NEW
value|4
end_define

begin_comment
comment|/* This process is brand new */
end_comment

begin_comment
comment|/* If process is dead, flags says how. */
end_comment

begin_define
define|#
directive|define
name|EXITED
value|1
end_define

begin_define
define|#
directive|define
name|KILLED
value|2
end_define

begin_define
define|#
directive|define
name|isdead
parameter_list|(
name|p
parameter_list|)
value|((p) == NULL || proc_state((p)) == DEAD || (p)->p_toproc == -1)
end_define

begin_define
define|#
directive|define
name|makedead
parameter_list|(
name|p
parameter_list|)
value|{ proc_state((p)) = DEAD; }
end_define

begin_define
define|#
directive|define
name|proc_buf
parameter_list|(
name|p
parameter_list|)
value|((p)->p_buffer->b_name)
end_define

begin_define
define|#
directive|define
name|proc_cmd
parameter_list|(
name|p
parameter_list|)
value|((p)->p_name)
end_define

begin_define
define|#
directive|define
name|proc_state
parameter_list|(
name|p
parameter_list|)
value|((p)->p_state)
end_define

begin_decl_stmt
name|private
name|Process
modifier|*
name|procs
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|File
modifier|*
name|ProcInput
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|ProcOutput
decl_stmt|,
name|kbd_pid
init|=
literal|0
decl_stmt|,
name|NumProcs
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
name|private
name|Process
modifier|*
name|proc_pid
parameter_list|(
name|pid
parameter_list|)
name|int
name|pid
decl_stmt|;
block|{
specifier|register
name|Process
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|p
operator|=
name|procs
init|;
name|p
operator|!=
name|NULL
condition|;
name|p
operator|=
name|p
operator|->
name|p_next
control|)
if|if
condition|(
name|p
operator|->
name|p_portpid
operator|==
name|pid
condition|)
break|break;
return|return
name|p
return|;
block|}
end_function

begin_function
name|void
name|read_proc
parameter_list|(
name|pid
parameter_list|,
name|nbytes
parameter_list|)
name|int
name|pid
decl_stmt|;
specifier|register
name|int
name|nbytes
decl_stmt|;
block|{
specifier|register
name|Process
modifier|*
name|p
decl_stmt|;
name|char
name|ibuf
index|[
literal|512
index|]
decl_stmt|;
if|if
condition|(
operator|(
name|p
operator|=
name|proc_pid
argument_list|(
name|pid
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|writef
argument_list|(
literal|"\riproc: unknown pid (%d)"
argument_list|,
name|pid
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|proc_state
argument_list|(
name|p
argument_list|)
operator|==
name|NEW
condition|)
block|{
name|int
name|rpid
decl_stmt|;
comment|/* pid of real child, not of portsrv */
operator|(
name|void
operator|)
name|f_readn
argument_list|(
name|ProcInput
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|rpid
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|->
name|p_pid
operator|=
name|rpid
expr_stmt|;
name|p
operator|->
name|p_state
operator|=
name|RUNNING
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|nbytes
operator|==
name|EOF
condition|)
block|{
comment|/* okay to clean up this process */
name|union
name|wait
name|status
decl_stmt|;
name|int
name|pid
decl_stmt|;
operator|(
name|void
operator|)
name|f_readn
argument_list|(
name|ProcInput
argument_list|,
operator|&
name|status
operator|.
name|w_status
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
do|do
block|{
name|pid
operator|=
name|wait
argument_list|(
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|pid
operator|<
literal|0
condition|)
break|break;
name|kill_off
argument_list|(
name|pid
argument_list|,
name|status
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|pid
operator|!=
name|p
operator|->
name|p_portpid
condition|)
do|;
name|proc_close
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|makedead
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return;
block|}
while|while
condition|(
name|nbytes
operator|>
literal|0
condition|)
block|{
name|size_t
name|n
init|=
name|f_readn
argument_list|(
name|ProcInput
argument_list|,
name|ibuf
argument_list|,
name|min
argument_list|(
operator|(
sizeof|sizeof
name|ibuf
operator|)
operator|-
literal|1
argument_list|,
name|nbytes
argument_list|)
argument_list|)
decl_stmt|;
name|ibuf
index|[
name|n
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* Null terminate for convenience */
name|nbytes
operator|-=
name|n
expr_stmt|;
name|proc_rec
argument_list|(
name|p
argument_list|,
name|ibuf
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|ProcKill
parameter_list|()
block|{
name|proc_kill
argument_list|(
name|curbuf
operator|->
name|b_process
argument_list|,
name|SIGKILL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ProcInt
parameter_list|()
block|{
name|proc_kill
argument_list|(
name|curbuf
operator|->
name|b_process
argument_list|,
name|SIGINT
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ProcQuit
parameter_list|()
block|{
name|proc_kill
argument_list|(
name|curbuf
operator|->
name|b_process
argument_list|,
name|SIGQUIT
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|private
name|void
name|proc_close
parameter_list|(
name|p
parameter_list|)
name|Process
modifier|*
name|p
decl_stmt|;
block|{
if|if
condition|(
name|p
operator|->
name|p_toproc
operator|>=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|close
argument_list|(
name|p
operator|->
name|p_toproc
argument_list|)
expr_stmt|;
name|p
operator|->
name|p_toproc
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* writes will fail */
name|NumProcs
operator|-=
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|proc_write
parameter_list|(
name|p
parameter_list|,
name|buf
parameter_list|,
name|nbytes
parameter_list|)
name|Process
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
name|size_t
name|nbytes
decl_stmt|;
block|{
operator|(
name|void
operator|)
name|write
argument_list|(
name|p
operator|->
name|p_toproc
argument_list|,
name|buf
argument_list|,
name|nbytes
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|STDARGS
end_ifdef

begin_decl_stmt
name|private
name|void
name|proc_strt
argument_list|(
name|char
operator|*
name|bufname
argument_list|,
name|int
name|clobber
argument_list|,
operator|...
argument_list|)
else|#
directive|else
name|private
comment|/*VARARGS3*/
name|void
name|proc_strt
argument_list|(
name|bufname
argument_list|,
name|clobber
argument_list|,
name|va_alist
argument_list|)
name|char
modifier|*
name|bufname
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|clobber
decl_stmt|;
end_decl_stmt

begin_macro
name|va_dcl
end_macro

begin_endif
endif|#
directive|endif
end_endif

begin_block
block|{
name|Window
modifier|*
name|owind
init|=
name|curwind
decl_stmt|;
name|int
name|toproc
index|[
literal|2
index|]
decl_stmt|,
name|pid
decl_stmt|;
name|Process
modifier|*
name|newp
decl_stmt|;
name|Buffer
modifier|*
name|newbuf
decl_stmt|;
name|char
modifier|*
name|argv
index|[
literal|32
index|]
decl_stmt|,
modifier|*
name|cp
decl_stmt|,
name|foo
index|[
literal|10
index|]
decl_stmt|,
name|cmdbuf
index|[
name|LBSIZE
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
name|va_list
name|ap
decl_stmt|;
name|isprocbuf
argument_list|(
name|bufname
argument_list|)
expr_stmt|;
comment|/* make sure BUFNAME is either nonexistant 				   or is of type B_PROCESS */
if|if
condition|(
name|access
argument_list|(
name|Portsrv
argument_list|,
name|X_OK
argument_list|)
operator|<
literal|0
condition|)
block|{
name|complain
argument_list|(
literal|"[Couldn't access %s: %s]"
argument_list|,
name|Portsrv
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
name|dopipe
argument_list|(
name|toproc
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|pid
operator|=
name|fork
argument_list|()
condition|)
block|{
case|case
operator|-
literal|1
case|:
name|pipeclose
argument_list|(
name|toproc
argument_list|)
expr_stmt|;
name|complain
argument_list|(
literal|"[Fork failed: %s]"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
case|case
literal|0
case|:
name|argv
index|[
literal|0
index|]
operator|=
literal|"portsrv"
expr_stmt|;
name|va_init
argument_list|(
name|ap
argument_list|,
name|clobber
argument_list|)
expr_stmt|;
name|make_argv
argument_list|(
operator|&
name|argv
index|[
literal|1
index|]
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|dup2
argument_list|(
name|toproc
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|dup2
argument_list|(
name|ProcOutput
argument_list|,
literal|1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|dup2
argument_list|(
name|ProcOutput
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|pipeclose
argument_list|(
name|toproc
argument_list|)
expr_stmt|;
name|jcloseall
argument_list|()
expr_stmt|;
name|execv
argument_list|(
name|Portsrv
argument_list|,
name|argv
argument_list|)
expr_stmt|;
name|raw_complain
argument_list|(
literal|"execl failed: %s\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|_exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|newp
operator|=
operator|(
name|Process
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
expr|*
name|newp
argument_list|)
expr_stmt|;
comment|/* ??? better check for newp == NULL -- DHR */
name|newp
operator|->
name|p_next
operator|=
name|procs
expr_stmt|;
name|newp
operator|->
name|p_state
operator|=
name|NEW
expr_stmt|;
name|cmdbuf
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|va_init
argument_list|(
name|ap
argument_list|,
name|clobber
argument_list|)
expr_stmt|;
while|while
condition|(
name|cp
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|char
operator|*
argument_list|)
condition|)
block|{
name|size_t
name|pl
init|=
name|strlen
argument_list|(
name|cmdbuf
argument_list|)
decl_stmt|;
name|swritef
argument_list|(
operator|&
name|cmdbuf
index|[
name|pl
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|cmdbuf
argument_list|)
operator|-
name|pl
argument_list|,
literal|"%s "
argument_list|,
name|cp
argument_list|)
expr_stmt|;
block|}
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|va_init
argument_list|(
name|ap
argument_list|,
name|clobber
argument_list|)
expr_stmt|;
name|newp
operator|->
name|p_name
operator|=
name|copystr
argument_list|(
name|cmdbuf
argument_list|)
expr_stmt|;
name|procs
operator|=
name|newp
expr_stmt|;
name|newp
operator|->
name|p_portpid
operator|=
name|pid
expr_stmt|;
name|newp
operator|->
name|p_pid
operator|=
operator|-
literal|1
expr_stmt|;
name|newbuf
operator|=
name|do_select
argument_list|(
operator|(
name|Window
operator|*
operator|)
name|NULL
argument_list|,
name|bufname
argument_list|)
expr_stmt|;
name|newbuf
operator|->
name|b_type
operator|=
name|B_PROCESS
expr_stmt|;
name|newp
operator|->
name|p_buffer
operator|=
name|newbuf
expr_stmt|;
name|newbuf
operator|->
name|b_process
operator|=
name|newp
expr_stmt|;
comment|/* sorta circular, eh? */
name|pop_wind
argument_list|(
name|bufname
argument_list|,
name|clobber
argument_list|,
name|B_PROCESS
argument_list|)
expr_stmt|;
name|ToLast
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|bolp
argument_list|()
condition|)
name|LineInsert
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* Pop_wind() after everything is set up; important! 	   Bindings won't work right unless newbuf->b_process is already 	   set up BEFORE NEWBUF is first SetBuf()'d. */
name|newp
operator|->
name|p_mark
operator|=
name|MakeMark
argument_list|(
name|curline
argument_list|,
name|curchar
argument_list|,
name|M_FLOATER
argument_list|)
expr_stmt|;
name|newp
operator|->
name|p_dbx_mode
operator|=
name|NO
expr_stmt|;
name|newp
operator|->
name|p_toproc
operator|=
name|toproc
index|[
literal|1
index|]
expr_stmt|;
name|newp
operator|->
name|p_reason
operator|=
literal|0
expr_stmt|;
name|NumProcs
operator|+=
literal|1
expr_stmt|;
if|if
condition|(
name|NumProcs
operator|==
literal|1
condition|)
operator|(
name|void
operator|)
name|kbd_strt
argument_list|()
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|toproc
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|SetWind
argument_list|(
name|owind
argument_list|)
expr_stmt|;
block|}
end_block

begin_function
name|void
name|pinit
parameter_list|()
block|{
name|int
name|p
index|[
literal|2
index|]
decl_stmt|;
operator|(
name|void
operator|)
name|pipe
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|ProcInput
operator|=
name|fd_open
argument_list|(
literal|"process-input"
argument_list|,
name|F_READ
operator||
name|F_LOCKED
argument_list|,
name|p
index|[
literal|0
index|]
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
literal|512
argument_list|)
expr_stmt|;
name|ProcOutput
operator|=
name|p
index|[
literal|1
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|kbd_pid
operator|=
name|fork
argument_list|()
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
name|raw_complain
argument_list|(
literal|"Cannot fork kbd process! %s\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|finish
argument_list|(
name|SIGHUP
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|kbd_pid
operator|==
literal|0
condition|)
block|{
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGALRM
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
name|close
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|dup
argument_list|(
name|ProcOutput
argument_list|)
expr_stmt|;
name|jcloseall
argument_list|()
expr_stmt|;
name|execl
argument_list|(
name|Kbd_Proc
argument_list|,
literal|"kbd"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|raw_complain
argument_list|(
literal|"kbd exec failed: %s\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_decl_stmt
name|private
name|int
name|kbd_state
init|=
name|OFF
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* kbd_strt() and kbd_stop() return true if they changed the state    of the keyboard process.  E.g., kbd_strt() returns TRUE if the    kbd process was previously stopped.  This is so kbd starting and    stopping in pairs works - see finish() in jove.c. */
end_comment

begin_macro
name|kbd_strt
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|kbd_state
operator|==
name|OFF
condition|)
block|{
name|kbd_state
operator|=
name|ON
expr_stmt|;
name|kill
argument_list|(
name|kbd_pid
argument_list|,
name|KBDSIG
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
return|return
name|FALSE
return|;
block|}
end_block

begin_macro
name|kbd_stop
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|kbd_state
operator|==
name|ON
condition|)
block|{
name|kbd_state
operator|=
name|OFF
expr_stmt|;
name|kill
argument_list|(
name|kbd_pid
argument_list|,
name|KBDSIG
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
return|return
name|FALSE
return|;
block|}
end_block

begin_macro
name|kbd_kill
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|kbd_pid
operator|!=
literal|0
condition|)
block|{
name|kill
argument_list|(
name|kbd_pid
argument_list|,
name|SIGKILL
argument_list|)
expr_stmt|;
name|kbd_pid
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_block

end_unit

