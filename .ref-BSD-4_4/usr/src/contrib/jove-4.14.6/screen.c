begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/***************************************************************************  * This program is Copyright (C) 1986, 1987, 1988 by Jonathan Payne.  JOVE *  * is provided to you without charge, and with no warranty.  You may give  *  * away copies of JOVE, including sources, provided that this notice is    *  * included in all the files.                                              *  ***************************************************************************/
end_comment

begin_include
include|#
directive|include
file|"jove.h"
end_include

begin_include
include|#
directive|include
file|"fp.h"
end_include

begin_include
include|#
directive|include
file|"ctype.h"
end_include

begin_include
include|#
directive|include
file|"termcap.h"
end_include

begin_include
include|#
directive|include
file|"disp.h"
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|MSDOS
end_ifdef

begin_define
define|#
directive|define
name|SIGHUP
value|99
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|int
name|AbortCnt
decl_stmt|,
name|tabstop
init|=
literal|8
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|bool
name|CanScroll
init|=
name|NO
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|TERMCAP
end_ifdef

begin_decl_stmt
name|private
name|void
argument_list|(
operator|*
name|TTins_line
argument_list|)
name|proto
argument_list|(
operator|(
name|int
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|,
argument_list|(
operator|*
name|TTdel_line
argument_list|)
name|proto
argument_list|(
operator|(
name|int
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* TERMCAP */
end_comment

begin_decl_stmt
name|struct
name|scrimage
modifier|*
name|DesiredScreen
init|=
name|NULL
decl_stmt|,
modifier|*
name|PhysScreen
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|screenline
modifier|*
name|Screen
init|=
name|NULL
decl_stmt|,
comment|/* the screen (a bunch of screenline) */
modifier|*
name|Curline
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* current line */
end_comment

begin_decl_stmt
name|private
name|struct
name|screenline
modifier|*
name|Savelines
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* another bunch (LI of them) */
end_comment

begin_decl_stmt
name|private
name|char
modifier|*
name|cursor
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* offset into current Line */
end_comment

begin_decl_stmt
name|char
modifier|*
name|cursend
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|CapCol
decl_stmt|,
name|CapLine
decl_stmt|,
name|i_line
decl_stmt|,
name|i_col
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|IBMPC
end_ifdef

begin_decl_stmt
specifier|extern
name|unsigned
name|char
name|CHPL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|near
name|normfun
argument_list|()
decl_stmt|,
name|near
name|scr_win
argument_list|()
decl_stmt|,
name|near
name|clr_page
argument_list|()
decl_stmt|,
name|near
name|clr_eoln
argument_list|()
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|void
name|make_scr
parameter_list|()
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|struct
name|screenline
modifier|*
name|ns
decl_stmt|;
specifier|register
name|char
modifier|*
name|nsp
decl_stmt|;
comment|/* In case we are RESHAPING the window! */
if|if
condition|(
name|DesiredScreen
operator|!=
name|NULL
condition|)
name|free
argument_list|(
operator|(
name|UnivPtr
operator|)
name|DesiredScreen
argument_list|)
expr_stmt|;
if|if
condition|(
name|PhysScreen
operator|!=
name|NULL
condition|)
name|free
argument_list|(
operator|(
name|UnivPtr
operator|)
name|PhysScreen
argument_list|)
expr_stmt|;
if|if
condition|(
name|Savelines
operator|!=
name|NULL
condition|)
name|free
argument_list|(
operator|(
name|UnivPtr
operator|)
name|Savelines
argument_list|)
expr_stmt|;
if|if
condition|(
name|Screen
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
operator|(
name|UnivPtr
operator|)
name|Screen
operator|->
name|s_line
argument_list|)
expr_stmt|;
comment|/* free all the screen data */
name|free
argument_list|(
operator|(
name|UnivPtr
operator|)
name|Screen
argument_list|)
expr_stmt|;
block|}
name|DesiredScreen
operator|=
operator|(
expr|struct
name|scrimage
operator|*
operator|)
name|malloc
argument_list|(
operator|(
name|unsigned
operator|)
name|LI
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|scrimage
argument_list|)
argument_list|)
expr_stmt|;
name|PhysScreen
operator|=
operator|(
expr|struct
name|scrimage
operator|*
operator|)
name|malloc
argument_list|(
operator|(
name|unsigned
operator|)
name|LI
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|scrimage
argument_list|)
argument_list|)
expr_stmt|;
name|Savelines
operator|=
operator|(
expr|struct
name|screenline
operator|*
operator|)
name|malloc
argument_list|(
operator|(
name|unsigned
operator|)
name|LI
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|screenline
argument_list|)
argument_list|)
expr_stmt|;
name|ns
operator|=
name|Screen
operator|=
operator|(
expr|struct
name|screenline
operator|*
operator|)
name|malloc
argument_list|(
operator|(
name|unsigned
operator|)
name|LI
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|screenline
argument_list|)
argument_list|)
expr_stmt|;
name|nsp
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
operator|(
name|unsigned
operator|)
name|CO
operator|*
name|LI
argument_list|)
expr_stmt|;
if|if
condition|(
name|DesiredScreen
operator|==
name|NULL
operator|||
name|PhysScreen
operator|==
name|NULL
operator|||
name|Savelines
operator|==
name|NULL
operator|||
name|ns
operator|==
name|NULL
operator|||
name|nsp
operator|==
name|NULL
condition|)
block|{
name|writef
argument_list|(
literal|"\n\rCannot malloc screen!\n"
argument_list|)
expr_stmt|;
name|finish
argument_list|(
name|SIGHUP
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|LI
condition|;
name|i
operator|++
control|)
block|{
name|ns
operator|->
name|s_line
operator|=
name|nsp
expr_stmt|;
name|nsp
operator|+=
name|CO
expr_stmt|;
name|ns
operator|->
name|s_length
operator|=
name|nsp
operator|-
literal|1
expr_stmt|;
comment|/* End of Line */
name|ns
operator|+=
literal|1
expr_stmt|;
block|}
name|cl_scr
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|clrline
parameter_list|(
name|cp1
parameter_list|,
name|cp2
parameter_list|)
specifier|register
name|char
modifier|*
name|cp1
decl_stmt|,
decl|*
name|cp2
decl_stmt|;
end_function

begin_block
block|{
while|while
condition|(
name|cp1
operator|<=
name|cp2
condition|)
operator|*
name|cp1
operator|++
operator|=
literal|' '
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Output one character (if necessary) at the current position */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|MAC
end_ifdef

begin_comment
comment|/* Character output to bit-mapped screen is very expensive. It makes    much more sense to write the entire line at once. So, we print all    the characters, whether already there or not, once the line is    complete.  */
end_comment

begin_decl_stmt
name|private
name|char
name|sput_buf
index|[
literal|256
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|int
name|sput_len
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
name|private
name|void
name|sput_start
parameter_list|()
block|{
comment|/*	if (i_line != CapLine || i_col != CapCol) */
name|NPlacur
argument_list|(
name|i_line
argument_list|,
name|i_col
argument_list|)
expr_stmt|;
name|sput_len
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|private
name|void
name|sput_end
parameter_list|()
block|{
name|sput_buf
index|[
literal|0
index|]
operator|=
operator|(
name|unsigned
name|char
operator|)
name|sput_len
expr_stmt|;
name|writechr
argument_list|(
name|sput_buf
argument_list|)
expr_stmt|;
name|sput_len
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|private
name|void
name|sputc
parameter_list|(
name|c
parameter_list|)
specifier|register
name|int
name|c
decl_stmt|;
block|{
if|if
condition|(
name|sput_len
operator|<
sizeof|sizeof
argument_list|(
name|sput_buf
argument_list|)
condition|)
block|{
operator|*
name|cursor
operator|++
operator|=
name|c
expr_stmt|;
name|sput_buf
index|[
operator|++
name|sput_len
index|]
operator|=
operator|(
name|c
operator|==
literal|'0'
operator|)
condition|?
literal|0xAF
comment|/* slashed zero */
else|:
name|c
expr_stmt|;
name|CapCol
operator|++
expr_stmt|;
name|i_col
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* !MAC */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|IBMPC
end_ifdef

begin_decl_stmt
name|private
name|bool
name|force
init|=
name|NO
decl_stmt|;
end_decl_stmt

begin_function
name|private
name|void
name|sputc
parameter_list|(
name|c
parameter_list|)
specifier|register
name|int
name|c
decl_stmt|;
block|{
if|if
condition|(
name|force
operator|||
operator|(
operator|*
name|cursor
operator|!=
name|c
operator|)
condition|)
block|{
if|if
condition|(
name|i_line
operator|!=
name|CapLine
operator|||
name|i_col
operator|!=
name|CapCol
condition|)
name|Placur
argument_list|(
name|i_line
argument_list|,
name|i_col
argument_list|)
expr_stmt|;
operator|*
name|cursor
operator|++
operator|=
name|c
expr_stmt|;
name|normfun
argument_list|(
operator|(
name|char
operator|)
name|c
argument_list|)
expr_stmt|;
name|AbortCnt
operator|-=
literal|1
expr_stmt|;
name|CapCol
operator|+=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|cursor
operator|+=
literal|1
expr_stmt|;
block|}
name|i_col
operator|+=
literal|1
expr_stmt|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* !IBMPC */
end_comment

begin_define
define|#
directive|define
name|sputc
parameter_list|(
name|c
parameter_list|)
value|{ \ 	if (*cursor != (char) (c)) { \ 		do_sputc(c); \ 	} else { \ 		cursor++; \ 		i_col++; \ 	} \ }
end_define

begin_function
name|private
name|void
name|do_sputc
parameter_list|(
name|c
parameter_list|)
specifier|register
name|int
name|c
decl_stmt|;
block|{
if|if
condition|(
operator|*
name|cursor
operator|!=
name|c
condition|)
block|{
ifdef|#
directive|ifdef
name|ID_CHAR
if|if
condition|(
name|IN_INSmode
condition|)
name|INSmode
argument_list|(
name|OFF
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|i_line
operator|!=
name|CapLine
operator|||
name|i_col
operator|!=
name|CapCol
condition|)
name|Placur
argument_list|(
name|i_line
argument_list|,
name|i_col
argument_list|)
expr_stmt|;
if|if
condition|(
name|UL
operator|&&
operator|(
name|c
operator|&
name|CHARMASK
operator|)
operator|==
literal|'_'
operator|&&
operator|(
operator|*
name|cursor
operator|&
name|CHARMASK
operator|)
operator|!=
literal|' '
condition|)
name|putstr
argument_list|(
literal|" \b"
argument_list|)
expr_stmt|;
comment|/* Erase so '_' looks right. */
operator|*
name|cursor
operator|++
operator|=
name|c
expr_stmt|;
name|jputchar
argument_list|(
name|c
operator|&
name|CHARMASK
argument_list|)
expr_stmt|;
name|AbortCnt
operator|-=
literal|1
expr_stmt|;
name|CapCol
operator|+=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|cursor
operator|+=
literal|1
expr_stmt|;
block|}
name|i_col
operator|+=
literal|1
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !IBMPC */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !MAC */
end_comment

begin_function
name|void
name|cl_eol
parameter_list|()
block|{
if|if
condition|(
name|cursor
operator|>
name|cursend
condition|)
return|return;
if|if
condition|(
name|cursor
operator|<
name|Curline
operator|->
name|s_length
condition|)
block|{
ifdef|#
directive|ifdef
name|TERMCAP
if|if
condition|(
name|CE
condition|)
block|{
name|Placur
argument_list|(
name|i_line
argument_list|,
name|i_col
argument_list|)
expr_stmt|;
name|putpad
argument_list|(
name|CE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|clrline
argument_list|(
name|cursor
argument_list|,
name|Curline
operator|->
name|s_length
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Ugh.  The slow way for dumb terminals. */
specifier|register
name|char
modifier|*
name|savecp
init|=
name|cursor
decl_stmt|;
while|while
condition|(
name|cursor
operator|<=
name|Curline
operator|->
name|s_length
condition|)
name|sputc
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|cursor
operator|=
name|savecp
expr_stmt|;
block|}
else|#
directive|else
comment|/* !TERMCAP */
name|Placur
argument_list|(
name|i_line
argument_list|,
name|i_col
argument_list|)
expr_stmt|;
name|clr_eoln
argument_list|()
expr_stmt|;
name|clrline
argument_list|(
name|cursor
argument_list|,
name|Curline
operator|->
name|s_length
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* !TERMCAP */
name|Curline
operator|->
name|s_length
operator|=
name|cursor
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|cl_scr
parameter_list|(
name|doit
parameter_list|)
name|bool
name|doit
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|struct
name|screenline
modifier|*
name|sp
init|=
name|Screen
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|LI
condition|;
name|i
operator|++
operator|,
name|sp
operator|++
control|)
block|{
name|clrline
argument_list|(
name|sp
operator|->
name|s_line
argument_list|,
name|sp
operator|->
name|s_length
argument_list|)
expr_stmt|;
name|sp
operator|->
name|s_length
operator|=
name|sp
operator|->
name|s_line
expr_stmt|;
name|PhysScreen
index|[
name|i
index|]
operator|.
name|s_id
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|doit
condition|)
block|{
ifdef|#
directive|ifdef
name|TERMCAP
name|putpad
argument_list|(
name|CL
argument_list|,
name|LI
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* !TERMCAP */
name|clr_page
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* !TERMCAP */
name|CapCol
operator|=
name|CapLine
operator|=
literal|0
expr_stmt|;
name|UpdMesg
operator|=
name|YES
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Write `line' at the current position of `cursor'.  Stop when we    reach the end of the screen.  Aborts if there is a character    waiting.  */
end_comment

begin_function
name|bool
name|swrite
parameter_list|(
name|line
parameter_list|,
name|inversep
parameter_list|,
name|abortable
parameter_list|)
specifier|register
name|char
modifier|*
name|line
decl_stmt|;
name|bool
name|inversep
decl_stmt|;
name|bool
name|abortable
decl_stmt|;
block|{
specifier|register
name|int
name|n
init|=
name|cursend
operator|-
name|cursor
decl_stmt|;
name|bool
name|aborted
init|=
name|NO
decl_stmt|;
if|if
condition|(
name|n
operator|>
literal|0
condition|)
block|{
specifier|register
name|int
name|c
decl_stmt|;
name|int
name|col
init|=
name|i_col
decl_stmt|;
ifdef|#
directive|ifdef
name|MAC
define|#
directive|define
name|spit
parameter_list|(
name|c
parameter_list|)
value|sputc(c)
else|#
directive|else
comment|/* !MAC */
ifdef|#
directive|ifdef
name|IBMPC
define|#
directive|define
name|spit
parameter_list|(
name|c
parameter_list|)
value|sputc(c)
else|#
directive|else
comment|/* !IBMPC */
name|int
name|or_byte
init|=
name|inversep
condition|?
literal|0200
else|:
literal|0
decl_stmt|;
define|#
directive|define
name|spit
parameter_list|(
name|c
parameter_list|)
value|{ int temp = (c) | or_byte; sputc(temp); }
endif|#
directive|endif
comment|/* !IBMPC */
endif|#
directive|endif
comment|/* !MAC */
ifdef|#
directive|ifdef
name|MAC
name|sput_start
argument_list|()
expr_stmt|;
comment|/* Okay, because no interruption possible */
endif|#
directive|endif
comment|/* MAC */
ifdef|#
directive|ifdef
name|IBMPC
name|force
operator|=
name|inversep
expr_stmt|;
comment|/* to force a redraw of the modeline */
endif|#
directive|endif
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|line
operator|++
operator|)
operator|!=
literal|'\0'
condition|)
block|{
define|#
directive|define
name|spot
parameter_list|(
name|c
parameter_list|)
value|{ if (--n<= 0) break; spit(c); col += 1; }
if|if
condition|(
name|abortable
operator|&&
name|AbortCnt
operator|<
literal|0
condition|)
block|{
name|AbortCnt
operator|=
name|BufSize
expr_stmt|;
if|if
condition|(
operator|(
name|InputPending
operator|=
name|charp
argument_list|()
operator|)
operator|!=
name|NO
condition|)
block|{
name|aborted
operator|=
name|YES
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|c
operator|==
literal|'\t'
condition|)
block|{
name|int
name|nchars
decl_stmt|;
name|nchars
operator|=
operator|(
name|tabstop
operator|-
operator|(
name|col
operator|%
name|tabstop
operator|)
operator|)
expr_stmt|;
while|while
condition|(
operator|--
name|nchars
operator|>
literal|0
condition|)
name|spot
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|c
operator|=
literal|' '
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|jiscntrl
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|spot
argument_list|(
literal|'^'
argument_list|)
expr_stmt|;
name|c
operator|=
operator|(
name|c
operator|==
literal|'\177'
operator|)
condition|?
literal|'?'
else|:
name|c
operator|+
literal|'@'
expr_stmt|;
ifdef|#
directive|ifdef
name|TERMCAP
block|}
elseif|else
if|if
condition|(
name|Hazeltine
operator|&&
name|c
operator|==
literal|'~'
condition|)
block|{
name|c
operator|=
literal|'`'
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|IBMPC
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|255
condition|)
block|{
name|c
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|' '
operator|&&
name|inversep
condition|)
block|{
name|c
operator|=
literal|255
expr_stmt|;
endif|#
directive|endif
comment|/* IBMPC */
block|}
name|spot
argument_list|(
name|c
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|spot
block|}
if|if
condition|(
name|n
operator|<=
literal|0
condition|)
name|spit
argument_list|(
operator|(
operator|(
operator|*
name|line
operator|==
literal|'\0'
operator|)
operator|&&
operator|(
name|c
operator|!=
literal|'\t'
operator|)
operator|&&
operator|!
name|jiscntrl
argument_list|(
name|c
argument_list|)
operator|)
condition|?
name|c
else|:
literal|'!'
argument_list|)
expr_stmt|;
if|if
condition|(
name|cursor
operator|>
name|Curline
operator|->
name|s_length
condition|)
name|Curline
operator|->
name|s_length
operator|=
name|cursor
expr_stmt|;
ifdef|#
directive|ifdef
name|MAC
name|sput_end
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* MAC */
ifdef|#
directive|ifdef
name|IBMPC
name|force
operator|=
name|NO
expr_stmt|;
endif|#
directive|endif
undef|#
directive|undef
name|spit
block|}
return|return
operator|!
name|aborted
return|;
block|}
end_function

begin_comment
comment|/* This is for writing a buffer line to the screen.  This is to    minimize the amount of copying from one buffer to another buffer.    This gets the info directly from the disk buffers. */
end_comment

begin_function
name|bool
name|BufSwrite
parameter_list|(
name|linenum
parameter_list|)
name|int
name|linenum
decl_stmt|;
block|{
specifier|register
name|int
name|n
init|=
name|cursend
operator|-
name|cursor
decl_stmt|,
name|col
init|=
literal|0
decl_stmt|,
name|c
init|=
operator|-
literal|1
decl_stmt|;
specifier|register
name|char
modifier|*
name|bp
decl_stmt|;
name|int
name|StartCol
init|=
name|DesiredScreen
index|[
name|linenum
index|]
operator|.
name|s_offset
decl_stmt|,
name|visspace
init|=
name|DesiredScreen
index|[
name|linenum
index|]
operator|.
name|s_window
operator|->
name|w_flags
operator|&
name|W_VISSPACE
decl_stmt|;
name|bool
name|aborted
init|=
name|NO
decl_stmt|;
name|bp
operator|=
name|lcontents
argument_list|(
name|DesiredScreen
index|[
name|linenum
index|]
operator|.
name|s_lp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|bp
condition|)
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|col
operator|>=
name|StartCol
condition|)
block|{
name|DesiredScreen
index|[
name|linenum
index|]
operator|.
name|s_offset
operator|=
name|col
expr_stmt|;
break|break;
block|}
name|c
operator|=
operator|*
name|bp
operator|++
operator|&
name|CHARMASK
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\0'
condition|)
break|break;
if|if
condition|(
name|c
operator|==
literal|'\t'
condition|)
name|col
operator|+=
operator|(
name|tabstop
operator|-
operator|(
name|col
operator|%
name|tabstop
operator|)
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
name|jiscntrl
argument_list|(
name|c
argument_list|)
condition|)
name|col
operator|+=
literal|2
expr_stmt|;
else|else
name|col
operator|+=
literal|1
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|MAC
name|sput_start
argument_list|()
expr_stmt|;
comment|/* Okay because we can't be interrupted */
endif|#
directive|endif
if|if
condition|(
name|c
operator|!=
literal|'\0'
condition|)
block|{
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|bp
operator|++
operator|)
operator|!=
literal|'\0'
condition|)
block|{
define|#
directive|define
name|spot
parameter_list|(
name|c
parameter_list|)
value|{ if (--n<= 0) break; sputc(c); col += 1; }
if|if
condition|(
name|AbortCnt
operator|<
literal|0
condition|)
block|{
name|AbortCnt
operator|=
name|BufSize
expr_stmt|;
if|if
condition|(
operator|(
name|InputPending
operator|=
name|charp
argument_list|()
operator|)
operator|!=
name|NO
condition|)
block|{
name|aborted
operator|=
name|YES
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|c
operator|==
literal|'\t'
condition|)
block|{
name|int
name|nchars
init|=
operator|(
name|tabstop
operator|-
operator|(
name|col
operator|%
name|tabstop
operator|)
operator|)
decl_stmt|;
if|if
condition|(
name|visspace
condition|)
block|{
name|spot
argument_list|(
literal|'>'
argument_list|)
expr_stmt|;
name|nchars
operator|-=
literal|1
expr_stmt|;
block|}
while|while
condition|(
operator|--
name|nchars
operator|>
literal|0
condition|)
name|spot
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|c
operator|=
literal|' '
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|jiscntrl
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|spot
argument_list|(
literal|'^'
argument_list|)
expr_stmt|;
name|c
operator|=
operator|(
name|c
operator|==
literal|'\177'
operator|)
condition|?
literal|'?'
else|:
name|c
operator|+
literal|'@'
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|' '
operator|&&
name|visspace
condition|)
block|{
name|c
operator|=
literal|'_'
expr_stmt|;
ifdef|#
directive|ifdef
name|TERMCAP
block|}
elseif|else
if|if
condition|(
name|Hazeltine
operator|&&
name|c
operator|==
literal|'~'
condition|)
block|{
name|c
operator|=
literal|'`'
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|IBMPC
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|255
condition|)
block|{
name|c
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
comment|/* IBMPC */
block|}
name|spot
argument_list|(
name|c
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|spot
block|}
block|}
if|if
condition|(
name|n
operator|<=
literal|0
condition|)
name|sputc
argument_list|(
operator|(
operator|(
operator|*
name|bp
operator|==
literal|'\0'
operator|)
operator|&&
operator|(
name|c
operator|!=
literal|'\t'
operator|)
operator|&&
operator|!
name|jiscntrl
argument_list|(
name|c
argument_list|)
operator|)
condition|?
name|c
else|:
literal|'!'
argument_list|)
expr_stmt|;
if|if
condition|(
name|cursor
operator|>
name|Curline
operator|->
name|s_length
condition|)
name|Curline
operator|->
name|s_length
operator|=
name|cursor
expr_stmt|;
ifdef|#
directive|ifdef
name|MAC
name|sput_end
argument_list|()
expr_stmt|;
endif|#
directive|endif
return|return
operator|!
name|aborted
return|;
comment|/* Didn't abort */
block|}
end_function

begin_function
name|void
name|i_set
parameter_list|(
name|nline
parameter_list|,
name|ncol
parameter_list|)
specifier|register
name|int
name|nline
decl_stmt|,
name|ncol
decl_stmt|;
block|{
name|Curline
operator|=
operator|&
name|Screen
index|[
name|nline
index|]
expr_stmt|;
name|cursor
operator|=
name|Curline
operator|->
name|s_line
operator|+
name|ncol
expr_stmt|;
name|cursend
operator|=
operator|&
name|Curline
operator|->
name|s_line
index|[
name|CO
operator|-
literal|1
index|]
expr_stmt|;
name|i_line
operator|=
name|nline
expr_stmt|;
name|i_col
operator|=
name|ncol
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|TERMCAP
end_ifdef

begin_function
name|void
name|SO_on
parameter_list|()
block|{
comment|/* If there are magic cookies, then WHERE the SO string is 	   printed decides where the SO actually starts on the screen. 	   So it's important to make sure the cursor is positioned there 	   anyway.  I think this is right. */
if|if
condition|(
name|SG
operator|!=
literal|0
condition|)
block|{
name|Placur
argument_list|(
name|i_line
argument_list|,
name|i_col
argument_list|)
expr_stmt|;
name|i_col
operator|+=
name|SG
expr_stmt|;
name|CapCol
operator|+=
name|SG
expr_stmt|;
block|}
name|putpad
argument_list|(
name|SO
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|SO_off
parameter_list|()
block|{
comment|/* see comment in SO_on() */
if|if
condition|(
name|SG
operator|!=
literal|0
condition|)
block|{
name|Placur
argument_list|(
name|i_line
argument_list|,
name|i_col
argument_list|)
expr_stmt|;
name|i_col
operator|+=
name|SG
expr_stmt|;
name|CapCol
operator|+=
name|SG
expr_stmt|;
block|}
name|putpad
argument_list|(
name|SE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* TERMCAP */
end_comment

begin_comment
comment|/* Insert `num' lines a top, but leave all the lines BELOW `bottom'    alone (at least they won't look any different when we are done).    This changes the screen array AND does the physical changes. */
end_comment

begin_function
name|void
name|v_ins_line
parameter_list|(
name|num
parameter_list|,
name|top
parameter_list|,
name|bottom
parameter_list|)
name|int
name|num
decl_stmt|,
name|top
decl_stmt|,
name|bottom
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
comment|/* Save the screen pointers. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num
operator|&&
name|top
operator|+
name|i
operator|<=
name|bottom
condition|;
name|i
operator|++
control|)
name|Savelines
index|[
name|i
index|]
operator|=
name|Screen
index|[
name|bottom
operator|-
name|i
index|]
expr_stmt|;
comment|/* Num number of bottom lines will be lost. 	   Copy everything down num number of times. */
for|for
control|(
name|i
operator|=
name|bottom
init|;
name|i
operator|>
name|top
operator|&&
name|i
operator|-
name|num
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
name|Screen
index|[
name|i
index|]
operator|=
name|Screen
index|[
name|i
operator|-
name|num
index|]
expr_stmt|;
comment|/* Restore the saved ones, making them blank. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num
condition|;
name|i
operator|++
control|)
block|{
name|Screen
index|[
name|top
operator|+
name|i
index|]
operator|=
name|Savelines
index|[
name|i
index|]
expr_stmt|;
name|clrline
argument_list|(
name|Screen
index|[
name|top
operator|+
name|i
index|]
operator|.
name|s_line
argument_list|,
name|Screen
index|[
name|top
operator|+
name|i
index|]
operator|.
name|s_length
argument_list|)
expr_stmt|;
name|Screen
index|[
name|top
operator|+
name|i
index|]
operator|.
name|s_length
operator|=
name|Screen
index|[
name|top
operator|+
name|i
index|]
operator|.
name|s_line
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|IBMPC
name|scr_win
argument_list|(
operator|(
name|int
operator|)
operator|-
name|num
argument_list|,
operator|(
name|unsigned
name|char
operator|)
name|top
argument_list|,
literal|0
argument_list|,
operator|(
name|unsigned
name|char
operator|)
name|bottom
argument_list|,
name|CHPL
operator|-
literal|1
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* !IBMPC */
ifdef|#
directive|ifdef
name|MAC
name|i_lines
argument_list|(
name|top
argument_list|,
name|bottom
argument_list|,
name|num
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* !MAC */
call|(
modifier|*
name|TTins_line
call|)
argument_list|(
name|top
argument_list|,
name|bottom
argument_list|,
name|num
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* !MAC */
endif|#
directive|endif
comment|/* !IBMPC */
block|}
end_function

begin_comment
comment|/* Delete `num' lines starting at `top' leaving the lines below `bottom'    alone.  This updates the internal image as well as the physical image.  */
end_comment

begin_function
name|void
name|v_del_line
parameter_list|(
name|num
parameter_list|,
name|top
parameter_list|,
name|bottom
parameter_list|)
name|int
name|num
decl_stmt|,
name|top
decl_stmt|,
name|bottom
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|bot
decl_stmt|;
name|bot
operator|=
name|bottom
expr_stmt|;
comment|/* Save the lost lines. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num
operator|&&
name|top
operator|+
name|i
operator|<=
name|bottom
condition|;
name|i
operator|++
control|)
name|Savelines
index|[
name|i
index|]
operator|=
name|Screen
index|[
name|top
operator|+
name|i
index|]
expr_stmt|;
comment|/* Copy everything up num number of lines. */
for|for
control|(
name|i
operator|=
name|top
init|;
name|num
operator|+
name|i
operator|<=
name|bottom
condition|;
name|i
operator|++
control|)
name|Screen
index|[
name|i
index|]
operator|=
name|Screen
index|[
name|i
operator|+
name|num
index|]
expr_stmt|;
comment|/* Restore the lost ones, clearing them. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num
condition|;
name|i
operator|++
control|)
block|{
name|Screen
index|[
name|bottom
operator|-
name|i
index|]
operator|=
name|Savelines
index|[
name|i
index|]
expr_stmt|;
name|clrline
argument_list|(
name|Screen
index|[
name|bot
index|]
operator|.
name|s_line
argument_list|,
name|Screen
index|[
name|bot
index|]
operator|.
name|s_length
argument_list|)
expr_stmt|;
name|Screen
index|[
name|bot
index|]
operator|.
name|s_length
operator|=
name|Screen
index|[
name|bot
index|]
operator|.
name|s_line
expr_stmt|;
name|bot
operator|-=
literal|1
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|IBMPC
name|scr_win
argument_list|(
name|num
argument_list|,
operator|(
name|unsigned
name|char
operator|)
name|top
argument_list|,
literal|0
argument_list|,
operator|(
name|unsigned
name|char
operator|)
name|bottom
argument_list|,
name|CHPL
operator|-
literal|1
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* !IBMPC */
ifdef|#
directive|ifdef
name|MAC
name|d_lines
argument_list|(
name|top
argument_list|,
name|bottom
argument_list|,
name|num
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* !MAC */
call|(
modifier|*
name|TTdel_line
call|)
argument_list|(
name|top
argument_list|,
name|bottom
argument_list|,
name|num
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* !MAC */
endif|#
directive|endif
comment|/* !IBMPC */
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|TERMCAP
end_ifdef

begin_comment
comment|/* remainder of this file */
end_comment

begin_comment
comment|/* The cursor optimization happens here.  You may decide that this    is going too far with cursor optimization, or perhaps it should    limit the amount of checking to when the output speed is slow.    What ever turns you on ...   */
end_comment

begin_struct
struct|struct
name|cursaddr
block|{
name|int
name|cm_numchars
decl_stmt|;
name|void
function_decl|(
modifier|*
name|cm_proc
function_decl|)
parameter_list|()
function_decl|;
block|}
struct|;
end_struct

begin_decl_stmt
name|private
name|char
modifier|*
name|Cmstr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|struct
name|cursaddr
modifier|*
name|HorMin
decl_stmt|,
modifier|*
name|VertMin
decl_stmt|,
modifier|*
name|DirectMin
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|void
name|GENi_lines
name|proto
argument_list|(
operator|(
name|int
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|,
name|GENd_lines
name|proto
argument_list|(
operator|(
name|int
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|,
name|ForMotion
name|proto
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|,
name|ForTab
name|proto
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|,
name|BackMotion
name|proto
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|,
name|RetTab
name|proto
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|,
name|DownMotion
name|proto
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|,
name|UpMotion
name|proto
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|,
name|GoDirect
name|proto
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|,
name|HomeGo
name|proto
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|,
name|BottomUp
name|proto
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|struct
name|cursaddr
name|WarpHor
index|[]
init|=
block|{
literal|0
block|,
name|ForMotion
block|,
literal|0
block|,
name|ForTab
block|,
literal|0
block|,
name|BackMotion
block|,
literal|0
block|,
name|RetTab
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|struct
name|cursaddr
name|WarpVert
index|[]
init|=
block|{
literal|0
block|,
name|DownMotion
block|,
literal|0
block|,
name|UpMotion
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|struct
name|cursaddr
name|WarpDirect
index|[]
init|=
block|{
literal|0
block|,
name|GoDirect
block|,
literal|0
block|,
name|HomeGo
block|,
literal|0
block|,
name|BottomUp
block|}
decl_stmt|;
end_decl_stmt

begin_undef
undef|#
directive|undef
name|FORWARD
end_undef

begin_define
define|#
directive|define
name|FORWARD
value|0
end_define

begin_comment
comment|/* Move forward */
end_comment

begin_define
define|#
directive|define
name|FORTAB
value|1
end_define

begin_comment
comment|/* Forward using tabs */
end_comment

begin_undef
undef|#
directive|undef
name|BACKWARD
end_undef

begin_define
define|#
directive|define
name|BACKWARD
value|2
end_define

begin_comment
comment|/* Move backward */
end_comment

begin_define
define|#
directive|define
name|RETFORWARD
value|3
end_define

begin_comment
comment|/* Beginning of line and then tabs */
end_comment

begin_define
define|#
directive|define
name|NUMHOR
value|4
end_define

begin_define
define|#
directive|define
name|DOWN
value|0
end_define

begin_comment
comment|/* Move down */
end_comment

begin_define
define|#
directive|define
name|UPMOVE
value|1
end_define

begin_comment
comment|/* Move up */
end_comment

begin_define
define|#
directive|define
name|NUMVERT
value|2
end_define

begin_define
define|#
directive|define
name|DIRECT
value|0
end_define

begin_comment
comment|/* Using CM */
end_comment

begin_define
define|#
directive|define
name|HOME
value|1
end_define

begin_comment
comment|/* HOME	*/
end_comment

begin_define
define|#
directive|define
name|LOWER
value|2
end_define

begin_comment
comment|/* Lower Line */
end_comment

begin_define
define|#
directive|define
name|NUMDIRECT
value|3
end_define

begin_define
define|#
directive|define
name|home
parameter_list|()
value|Placur(0, 0)
end_define

begin_define
define|#
directive|define
name|LowLine
parameter_list|()
value|{ putpad(LL, 1); CapLine = ILI; CapCol = 0; }
end_define

begin_define
define|#
directive|define
name|PrintHo
parameter_list|()
value|{ putpad(HO, 1); CapLine = CapCol = 0; }
end_define

begin_decl_stmt
name|int
name|phystab
init|=
literal|8
decl_stmt|;
end_decl_stmt

begin_function
name|private
name|void
name|GoDirect
parameter_list|(
name|line
parameter_list|,
name|col
parameter_list|)
specifier|register
name|int
name|line
decl_stmt|,
name|col
decl_stmt|;
block|{
name|putpad
argument_list|(
name|Cmstr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|CapLine
operator|=
name|line
expr_stmt|;
name|CapCol
operator|=
name|col
expr_stmt|;
block|}
end_function

begin_function
name|private
name|void
name|RetTab
parameter_list|(
name|col
parameter_list|)
specifier|register
name|int
name|col
decl_stmt|;
block|{
name|jputchar
argument_list|(
literal|'\r'
argument_list|)
expr_stmt|;
name|CapCol
operator|=
literal|0
expr_stmt|;
name|ForTab
argument_list|(
name|col
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|private
name|void
name|HomeGo
parameter_list|(
name|line
parameter_list|,
name|col
parameter_list|)
name|int
name|line
decl_stmt|,
name|col
decl_stmt|;
block|{
name|PrintHo
argument_list|()
expr_stmt|;
name|DownMotion
argument_list|(
name|line
argument_list|)
expr_stmt|;
name|ForTab
argument_list|(
name|col
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|private
name|void
name|BottomUp
parameter_list|(
name|line
parameter_list|,
name|col
parameter_list|)
specifier|register
name|int
name|line
decl_stmt|,
name|col
decl_stmt|;
block|{
name|LowLine
argument_list|()
expr_stmt|;
name|UpMotion
argument_list|(
name|line
argument_list|)
expr_stmt|;
name|ForTab
argument_list|(
name|col
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Tries to move forward using tabs (if possible).  It tabs to the    closest tabstop which means it may go past 'destcol' and backspace    to it. */
end_comment

begin_function
name|private
name|void
name|ForTab
parameter_list|(
name|destcol
parameter_list|)
name|int
name|destcol
decl_stmt|;
block|{
specifier|register
name|int
name|tabgoal
decl_stmt|,
name|ntabs
decl_stmt|,
name|tabstp
init|=
name|phystab
decl_stmt|;
if|if
condition|(
name|TABS
operator|&&
operator|(
name|tabstp
operator|>
literal|0
operator|)
condition|)
block|{
name|tabgoal
operator|=
name|destcol
operator|+
operator|(
name|tabstp
operator|/
literal|2
operator|)
expr_stmt|;
name|tabgoal
operator|-=
operator|(
name|tabgoal
operator|%
name|tabstp
operator|)
expr_stmt|;
comment|/* Don't tab to last place or else it is likely to screw up. */
if|if
condition|(
name|tabgoal
operator|>=
name|CO
condition|)
name|tabgoal
operator|-=
name|tabstp
expr_stmt|;
name|ntabs
operator|=
operator|(
name|tabgoal
operator|/
name|tabstp
operator|)
operator|-
operator|(
name|CapCol
operator|/
name|tabstp
operator|)
expr_stmt|;
while|while
condition|(
operator|--
name|ntabs
operator|>=
literal|0
condition|)
name|jputchar
argument_list|(
literal|'\t'
argument_list|)
expr_stmt|;
name|CapCol
operator|=
name|tabgoal
expr_stmt|;
block|}
if|if
condition|(
name|CapCol
operator|>
name|destcol
condition|)
name|BackMotion
argument_list|(
name|destcol
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|CapCol
operator|<
name|destcol
condition|)
name|ForMotion
argument_list|(
name|destcol
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|private
name|void
name|ForMotion
parameter_list|(
name|destcol
parameter_list|)
specifier|register
name|int
name|destcol
decl_stmt|;
block|{
specifier|register
name|int
name|nchars
init|=
name|destcol
operator|-
name|CapCol
decl_stmt|;
specifier|register
name|char
modifier|*
name|cp
init|=
operator|&
name|Screen
index|[
name|CapLine
index|]
operator|.
name|s_line
index|[
name|CapCol
index|]
decl_stmt|;
while|while
condition|(
operator|--
name|nchars
operator|>=
literal|0
condition|)
name|jputchar
argument_list|(
operator|*
name|cp
operator|++
operator|&
name|CHARMASK
argument_list|)
expr_stmt|;
name|CapCol
operator|=
name|destcol
expr_stmt|;
block|}
end_function

begin_function
name|private
name|void
name|BackMotion
parameter_list|(
name|destcol
parameter_list|)
specifier|register
name|int
name|destcol
decl_stmt|;
block|{
specifier|register
name|int
name|nchars
init|=
name|CapCol
operator|-
name|destcol
decl_stmt|;
if|if
condition|(
name|BC
condition|)
while|while
condition|(
operator|--
name|nchars
operator|>=
literal|0
condition|)
name|putpad
argument_list|(
name|BC
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
while|while
condition|(
operator|--
name|nchars
operator|>=
literal|0
condition|)
name|jputchar
argument_list|(
literal|'\b'
argument_list|)
expr_stmt|;
name|CapCol
operator|=
name|destcol
expr_stmt|;
block|}
end_function

begin_function
name|private
name|void
name|DownMotion
parameter_list|(
name|destline
parameter_list|)
specifier|register
name|int
name|destline
decl_stmt|;
block|{
specifier|register
name|int
name|nlines
init|=
name|destline
operator|-
name|CapLine
decl_stmt|;
while|while
condition|(
operator|--
name|nlines
operator|>=
literal|0
condition|)
name|putpad
argument_list|(
name|DO
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|CapLine
operator|=
name|destline
expr_stmt|;
block|}
end_function

begin_function
name|private
name|void
name|UpMotion
parameter_list|(
name|destline
parameter_list|)
specifier|register
name|int
name|destline
decl_stmt|;
block|{
specifier|register
name|int
name|nchars
init|=
name|CapLine
operator|-
name|destline
decl_stmt|;
while|while
condition|(
operator|--
name|nchars
operator|>=
literal|0
condition|)
name|putpad
argument_list|(
name|UP
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|CapLine
operator|=
name|destline
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|ID_CHAR
end_ifdef

begin_decl_stmt
specifier|static
name|int
name|EIlen
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|void
name|InitCM
parameter_list|()
block|{
name|HOlen
operator|=
name|HO
condition|?
name|strlen
argument_list|(
name|HO
argument_list|)
else|:
literal|1000
expr_stmt|;
name|LLlen
operator|=
name|LL
condition|?
name|strlen
argument_list|(
name|LL
argument_list|)
else|:
literal|1000
expr_stmt|;
name|UPlen
operator|=
name|UP
condition|?
name|strlen
argument_list|(
name|UP
argument_list|)
else|:
literal|1000
expr_stmt|;
ifdef|#
directive|ifdef
name|ID_CHAR
if|if
condition|(
name|EI
condition|)
name|EIlen
operator|=
name|strlen
argument_list|(
name|EI
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_decl_stmt
name|private
name|int
name|ForNum
name|proto
argument_list|(
operator|(
name|int
name|from
operator|,
name|int
name|to
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|Placur
parameter_list|(
name|line
parameter_list|,
name|col
parameter_list|)
name|int
name|line
decl_stmt|,
name|col
decl_stmt|;
block|{
name|int
name|dline
decl_stmt|,
comment|/* Number of lines to move */
name|dcol
decl_stmt|;
comment|/* Number of columns to move */
specifier|register
name|int
name|best
decl_stmt|,
name|i
decl_stmt|;
specifier|register
name|struct
name|cursaddr
modifier|*
name|cp
decl_stmt|;
name|int
name|xtracost
init|=
literal|0
decl_stmt|;
comment|/* Misc addition to cost. */
define|#
directive|define
name|CursMin
parameter_list|(
name|which
parameter_list|,
name|addrs
parameter_list|,
name|max
parameter_list|)
value|{ \ 	for (best = 0, cp =&(addrs)[1], i = 1; i< (max); i++, cp++) \ 		if (cp->cm_numchars< (addrs)[best].cm_numchars) \ 			best = i; \ 	(which) =&(addrs)[best]; \ }
if|if
condition|(
name|line
operator|==
name|CapLine
operator|&&
name|col
operator|==
name|CapCol
condition|)
return|return;
comment|/* We are already there. */
name|dline
operator|=
name|line
operator|-
name|CapLine
expr_stmt|;
name|dcol
operator|=
name|col
operator|-
name|CapCol
expr_stmt|;
ifdef|#
directive|ifdef
name|ID_CHAR
if|if
condition|(
name|IN_INSmode
operator|&&
name|MI
condition|)
name|xtracost
operator|=
name|EIlen
operator|+
name|IMlen
expr_stmt|;
comment|/* If we're already in insert mode, it is likely that we will 	   want to be in insert mode again, after the insert. */
endif|#
directive|endif
comment|/* Number of characters to move horizontally for each case. 	   1: Just move forward by typing the right character on the screen. 	   2: Print the correct number of back spaces. 	   3: Try tabbing to the correct place. 	   4: Try going to the beginning of the line, and then tab. */
if|if
condition|(
name|dcol
operator|==
literal|1
operator|||
name|dcol
operator|==
literal|0
condition|)
block|{
comment|/* Most common case. */
name|HorMin
operator|=
operator|&
name|WarpHor
index|[
name|FORWARD
index|]
expr_stmt|;
name|HorMin
operator|->
name|cm_numchars
operator|=
name|dcol
operator|+
name|xtracost
expr_stmt|;
block|}
else|else
block|{
name|WarpHor
index|[
name|FORWARD
index|]
operator|.
name|cm_numchars
operator|=
name|dcol
operator|>=
literal|0
condition|?
name|dcol
operator|+
name|xtracost
else|:
literal|1000
expr_stmt|;
name|WarpHor
index|[
name|BACKWARD
index|]
operator|.
name|cm_numchars
operator|=
name|dcol
operator|<
literal|0
condition|?
operator|-
operator|(
name|dcol
operator|+
name|xtracost
operator|)
else|:
literal|1000
expr_stmt|;
name|WarpHor
index|[
name|FORTAB
index|]
operator|.
name|cm_numchars
operator|=
name|dcol
operator|>=
literal|0
operator|&&
name|TABS
condition|?
name|ForNum
argument_list|(
name|CapCol
argument_list|,
name|col
argument_list|)
operator|+
name|xtracost
else|:
literal|1000
expr_stmt|;
name|WarpHor
index|[
name|RETFORWARD
index|]
operator|.
name|cm_numchars
operator|=
operator|(
name|xtracost
operator|+
literal|1
operator|+
operator|(
name|TABS
condition|?
name|ForNum
argument_list|(
literal|0
argument_list|,
name|col
argument_list|)
else|:
name|col
operator|)
operator|)
expr_stmt|;
comment|/* Which is the shortest of the bunch */
name|CursMin
argument_list|(
name|HorMin
argument_list|,
name|WarpHor
argument_list|,
name|NUMHOR
argument_list|)
expr_stmt|;
block|}
comment|/* Moving vertically is more simple. */
name|WarpVert
index|[
name|DOWN
index|]
operator|.
name|cm_numchars
operator|=
name|dline
operator|>=
literal|0
condition|?
name|dline
else|:
literal|1000
expr_stmt|;
name|WarpVert
index|[
name|UPMOVE
index|]
operator|.
name|cm_numchars
operator|=
name|dline
operator|<
literal|0
condition|?
operator|(
operator|(
operator|-
name|dline
operator|)
operator|*
name|UPlen
operator|)
else|:
literal|1000
expr_stmt|;
comment|/* Which of these is simpler */
name|CursMin
argument_list|(
name|VertMin
argument_list|,
name|WarpVert
argument_list|,
name|NUMVERT
argument_list|)
expr_stmt|;
comment|/* Homing first and lowering first are considered 	   direct motions. 	   Homing first's total is the sum of the cost of homing 	   and the sum of tabbing (if possible) to the right. */
if|if
condition|(
name|VertMin
operator|->
name|cm_numchars
operator|+
name|HorMin
operator|->
name|cm_numchars
operator|<=
literal|3
condition|)
block|{
name|DirectMin
operator|=
operator|&
name|WarpDirect
index|[
name|DIRECT
index|]
expr_stmt|;
comment|/* A dummy ... */
name|DirectMin
operator|->
name|cm_numchars
operator|=
literal|100
expr_stmt|;
block|}
else|else
block|{
name|WarpDirect
index|[
name|DIRECT
index|]
operator|.
name|cm_numchars
operator|=
name|CM
condition|?
name|strlen
argument_list|(
name|Cmstr
operator|=
name|tgoto
argument_list|(
name|CM
argument_list|,
name|col
argument_list|,
name|line
argument_list|)
argument_list|)
else|:
literal|1000
expr_stmt|;
name|WarpDirect
index|[
name|HOME
index|]
operator|.
name|cm_numchars
operator|=
name|HOlen
operator|+
name|line
operator|+
name|WarpHor
index|[
name|RETFORWARD
index|]
operator|.
name|cm_numchars
expr_stmt|;
name|WarpDirect
index|[
name|LOWER
index|]
operator|.
name|cm_numchars
operator|=
name|LLlen
operator|+
operator|(
operator|(
name|ILI
operator|-
name|line
operator|)
operator|*
name|UPlen
operator|)
operator|+
name|WarpHor
index|[
name|RETFORWARD
index|]
operator|.
name|cm_numchars
expr_stmt|;
name|CursMin
argument_list|(
name|DirectMin
argument_list|,
name|WarpDirect
argument_list|,
name|NUMDIRECT
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|HorMin
operator|->
name|cm_numchars
operator|+
name|VertMin
operator|->
name|cm_numchars
operator|<
name|DirectMin
operator|->
name|cm_numchars
condition|)
block|{
if|if
condition|(
name|line
operator|!=
name|CapLine
condition|)
operator|(
operator|*
operator|(
name|void
argument_list|(
argument|*
argument_list|)
name|ptrproto
argument_list|(
operator|(
name|int
operator|)
argument_list|)
operator|)
name|VertMin
operator|->
name|cm_proc
operator|)
operator|(
name|line
operator|)
expr_stmt|;
if|if
condition|(
name|col
operator|!=
name|CapCol
condition|)
block|{
ifdef|#
directive|ifdef
name|ID_CHAR
if|if
condition|(
name|IN_INSmode
condition|)
comment|/* We may use real characters ... */
name|INSmode
argument_list|(
name|OFF
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|(
operator|*
operator|(
name|void
argument_list|(
argument|*
argument_list|)
name|ptrproto
argument_list|(
operator|(
name|int
operator|)
argument_list|)
operator|)
name|HorMin
operator|->
name|cm_proc
operator|)
operator|(
name|col
operator|)
expr_stmt|;
block|}
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|ID_CHAR
if|if
condition|(
name|IN_INSmode
operator|&&
operator|!
name|MI
condition|)
name|INSmode
argument_list|(
name|OFF
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|(
operator|*
operator|(
name|void
argument_list|(
argument|*
argument_list|)
name|ptrproto
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
operator|)
name|DirectMin
operator|->
name|cm_proc
operator|)
operator|(
name|line
operator|,
name|col
operator|)
expr_stmt|;
block|}
block|}
end_function

begin_define
define|#
directive|define
name|abs
parameter_list|(
name|x
parameter_list|)
value|((x)>= 0 ? (x) : -(x))
end_define

begin_function
name|private
name|int
name|ForNum
parameter_list|(
name|from
parameter_list|,
name|to
parameter_list|)
specifier|register
name|int
name|from
decl_stmt|;
name|int
name|to
decl_stmt|;
block|{
specifier|register
name|int
name|tabgoal
decl_stmt|,
name|tabstp
init|=
name|phystab
decl_stmt|;
name|int
name|numchars
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|from
operator|>=
name|to
condition|)
return|return
name|from
operator|-
name|to
return|;
if|if
condition|(
name|TABS
operator|&&
operator|(
name|tabstp
operator|>
literal|0
operator|)
condition|)
block|{
name|tabgoal
operator|=
name|to
operator|+
operator|(
name|tabstp
operator|/
literal|2
operator|)
expr_stmt|;
name|tabgoal
operator|-=
operator|(
name|tabgoal
operator|%
name|tabstp
operator|)
expr_stmt|;
if|if
condition|(
name|tabgoal
operator|>=
name|CO
condition|)
name|tabgoal
operator|-=
name|tabstp
expr_stmt|;
name|numchars
operator|=
operator|(
name|tabgoal
operator|/
name|tabstop
operator|)
operator|-
operator|(
name|from
operator|/
name|tabstp
operator|)
expr_stmt|;
name|from
operator|=
name|tabgoal
expr_stmt|;
block|}
return|return
name|numchars
operator|+
name|abs
argument_list|(
name|from
operator|-
name|to
argument_list|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|WIRED_TERMS
end_ifdef

begin_function
name|private
name|void
name|BGi_lines
parameter_list|(
name|top
parameter_list|,
name|bottom
parameter_list|,
name|num
parameter_list|)
name|int
name|top
decl_stmt|,
name|bottom
decl_stmt|,
name|num
decl_stmt|;
block|{
name|writef
argument_list|(
literal|"\033[%d;%dr\033[%dL\033[r"
argument_list|,
name|top
operator|+
literal|1
argument_list|,
name|bottom
operator|+
literal|1
argument_list|,
name|num
argument_list|)
expr_stmt|;
name|CapCol
operator|=
name|CapLine
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|private
name|void
name|SUNi_lines
parameter_list|(
name|top
parameter_list|,
name|bottom
parameter_list|,
name|num
parameter_list|)
name|int
name|top
decl_stmt|,
name|bottom
decl_stmt|,
name|num
decl_stmt|;
block|{
name|Placur
argument_list|(
name|bottom
operator|-
name|num
operator|+
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|writef
argument_list|(
literal|"\033[%dM"
argument_list|,
name|num
argument_list|)
expr_stmt|;
name|Placur
argument_list|(
name|top
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|writef
argument_list|(
literal|"\033[%dL"
argument_list|,
name|num
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|private
name|void
name|C100i_lines
parameter_list|(
name|top
parameter_list|,
name|bottom
parameter_list|,
name|num
parameter_list|)
name|int
name|top
decl_stmt|,
name|bottom
decl_stmt|,
name|num
decl_stmt|;
block|{
if|if
condition|(
name|num
operator|<=
literal|1
condition|)
block|{
name|GENi_lines
argument_list|(
name|top
argument_list|,
name|bottom
argument_list|,
name|num
argument_list|)
expr_stmt|;
return|return;
block|}
name|writef
argument_list|(
literal|"\033v%c%c%c%c"
argument_list|,
literal|' '
argument_list|,
literal|' '
argument_list|,
literal|' '
operator|+
name|bottom
operator|+
literal|1
argument_list|,
literal|' '
operator|+
name|CO
argument_list|)
expr_stmt|;
name|CapLine
operator|=
name|CapCol
operator|=
literal|0
expr_stmt|;
name|Placur
argument_list|(
name|top
argument_list|,
literal|0
argument_list|)
expr_stmt|;
while|while
condition|(
name|num
operator|--
condition|)
name|putpad
argument_list|(
name|AL
argument_list|,
name|ILI
operator|-
name|CapLine
argument_list|)
expr_stmt|;
name|writef
argument_list|(
literal|"\033v%c%c%c%c"
argument_list|,
literal|' '
argument_list|,
literal|' '
argument_list|,
literal|' '
operator|+
name|LI
argument_list|,
literal|' '
operator|+
name|CO
argument_list|)
expr_stmt|;
name|CapLine
operator|=
name|CapCol
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* WIRED_TERMS */
end_comment

begin_function
name|private
name|void
name|GENi_lines
parameter_list|(
name|top
parameter_list|,
name|bottom
parameter_list|,
name|num
parameter_list|)
name|int
name|top
decl_stmt|,
name|bottom
decl_stmt|,
name|num
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
if|if
condition|(
name|CS
condition|)
block|{
name|putpad
argument_list|(
name|tgoto
argument_list|(
name|CS
argument_list|,
name|bottom
argument_list|,
name|top
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|CapCol
operator|=
name|CapLine
operator|=
literal|0
expr_stmt|;
name|Placur
argument_list|(
name|top
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|M_SR
operator|&&
operator|(
name|num
operator|>
literal|1
operator|)
condition|)
block|{
name|char
name|minibuf
index|[
literal|16
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|minibuf
argument_list|,
name|M_SR
argument_list|,
name|num
argument_list|)
expr_stmt|;
name|putpad
argument_list|(
name|minibuf
argument_list|,
name|bottom
operator|-
name|top
argument_list|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num
condition|;
name|i
operator|++
control|)
name|putpad
argument_list|(
name|SR
argument_list|,
name|bottom
operator|-
name|top
argument_list|)
expr_stmt|;
block|}
name|putpad
argument_list|(
name|tgoto
argument_list|(
name|CS
argument_list|,
name|ILI
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|CapCol
operator|=
name|CapLine
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|Placur
argument_list|(
name|bottom
operator|-
name|num
operator|+
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|M_DL
operator|&&
operator|(
name|num
operator|>
literal|1
operator|)
condition|)
block|{
name|putargpad
argument_list|(
name|M_DL
argument_list|,
name|num
argument_list|,
name|ILI
operator|-
name|CapLine
argument_list|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num
condition|;
name|i
operator|++
control|)
name|putpad
argument_list|(
name|DL
argument_list|,
name|ILI
operator|-
name|CapLine
argument_list|)
expr_stmt|;
block|}
name|Placur
argument_list|(
name|top
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|M_AL
operator|&&
operator|(
name|num
operator|>
literal|1
operator|)
condition|)
block|{
name|putargpad
argument_list|(
name|M_AL
argument_list|,
name|num
argument_list|,
name|ILI
operator|-
name|CapLine
argument_list|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num
condition|;
name|i
operator|++
control|)
name|putpad
argument_list|(
name|AL
argument_list|,
name|ILI
operator|-
name|CapLine
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|WIRED_TERMS
end_ifdef

begin_function
name|private
name|void
name|BGd_lines
parameter_list|(
name|top
parameter_list|,
name|bottom
parameter_list|,
name|num
parameter_list|)
name|int
name|top
decl_stmt|,
name|bottom
decl_stmt|,
name|num
decl_stmt|;
block|{
name|writef
argument_list|(
literal|"\033[%d;%dr\033[%dM\033[r"
argument_list|,
name|top
operator|+
literal|1
argument_list|,
name|bottom
operator|+
literal|1
argument_list|,
name|num
argument_list|)
expr_stmt|;
name|CapCol
operator|=
name|CapLine
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|private
name|void
name|SUNd_lines
parameter_list|(
name|top
parameter_list|,
name|bottom
parameter_list|,
name|num
parameter_list|)
name|int
name|top
decl_stmt|,
name|bottom
decl_stmt|,
name|num
decl_stmt|;
block|{
name|Placur
argument_list|(
name|top
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|writef
argument_list|(
literal|"\033[%dM"
argument_list|,
name|num
argument_list|)
expr_stmt|;
name|Placur
argument_list|(
name|bottom
operator|+
literal|1
operator|-
name|num
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|writef
argument_list|(
literal|"\033[%dL"
argument_list|,
name|num
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|private
name|void
name|C100d_lines
parameter_list|(
name|top
parameter_list|,
name|bottom
parameter_list|,
name|num
parameter_list|)
name|int
name|top
decl_stmt|,
name|bottom
decl_stmt|,
name|num
decl_stmt|;
block|{
if|if
condition|(
name|num
operator|<=
literal|1
condition|)
block|{
name|GENd_lines
argument_list|(
name|top
argument_list|,
name|bottom
argument_list|,
name|num
argument_list|)
expr_stmt|;
return|return;
block|}
name|writef
argument_list|(
literal|"\033v%c%c%c%c"
argument_list|,
literal|' '
argument_list|,
literal|' '
argument_list|,
literal|' '
operator|+
name|bottom
operator|+
literal|1
argument_list|,
literal|' '
operator|+
name|CO
argument_list|)
expr_stmt|;
name|CapLine
operator|=
name|CapCol
operator|=
literal|0
expr_stmt|;
name|Placur
argument_list|(
name|top
argument_list|,
literal|0
argument_list|)
expr_stmt|;
while|while
condition|(
name|num
operator|--
condition|)
name|putpad
argument_list|(
name|DL
argument_list|,
name|ILI
operator|-
name|CapLine
argument_list|)
expr_stmt|;
name|writef
argument_list|(
literal|"\033v%c%c%c%c"
argument_list|,
literal|' '
argument_list|,
literal|' '
argument_list|,
literal|' '
operator|+
name|LI
argument_list|,
literal|' '
operator|+
name|CO
argument_list|)
expr_stmt|;
name|CapLine
operator|=
name|CapCol
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* WIRED_TERMS */
end_comment

begin_function
name|private
name|void
name|GENd_lines
parameter_list|(
name|top
parameter_list|,
name|bottom
parameter_list|,
name|num
parameter_list|)
name|int
name|top
decl_stmt|,
name|bottom
decl_stmt|,
name|num
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
if|if
condition|(
name|CS
condition|)
block|{
name|putpad
argument_list|(
name|tgoto
argument_list|(
name|CS
argument_list|,
name|bottom
argument_list|,
name|top
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|CapCol
operator|=
name|CapLine
operator|=
literal|0
expr_stmt|;
name|Placur
argument_list|(
name|bottom
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|M_SF
operator|&&
operator|(
name|num
operator|>
literal|1
operator|)
condition|)
block|{
name|char
name|minibuf
index|[
literal|16
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|minibuf
argument_list|,
name|M_SF
argument_list|,
name|num
argument_list|)
expr_stmt|;
name|putpad
argument_list|(
name|minibuf
argument_list|,
name|bottom
operator|-
name|top
argument_list|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num
condition|;
name|i
operator|++
control|)
name|putpad
argument_list|(
name|SF
argument_list|,
name|bottom
operator|-
name|top
argument_list|)
expr_stmt|;
block|}
name|putpad
argument_list|(
name|tgoto
argument_list|(
name|CS
argument_list|,
name|ILI
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|CapCol
operator|=
name|CapLine
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|Placur
argument_list|(
name|top
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|M_DL
operator|&&
operator|(
name|num
operator|>
literal|1
operator|)
condition|)
block|{
name|putargpad
argument_list|(
name|M_DL
argument_list|,
name|num
argument_list|,
name|ILI
operator|-
name|top
argument_list|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num
condition|;
name|i
operator|++
control|)
name|putpad
argument_list|(
name|DL
argument_list|,
name|ILI
operator|-
name|top
argument_list|)
expr_stmt|;
block|}
name|Placur
argument_list|(
name|bottom
operator|+
literal|1
operator|-
name|num
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|M_AL
operator|&&
operator|(
name|num
operator|>
literal|1
operator|)
condition|)
block|{
name|putargpad
argument_list|(
name|M_AL
argument_list|,
name|num
argument_list|,
name|ILI
operator|-
name|CapLine
argument_list|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num
condition|;
name|i
operator|++
control|)
name|putpad
argument_list|(
name|AL
argument_list|,
name|ILI
operator|-
name|CapLine
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_expr_stmt
name|private
specifier|const
expr|struct
name|ID_lookup
block|{
name|char
operator|*
name|ID_name
block|;
name|void
argument_list|(
argument|*I_proc
argument_list|)
name|proto
argument_list|(
operator|(
name|int
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
block|;
comment|/* proc to insert lines */
name|void
argument_list|(
argument|*D_proc
argument_list|)
name|proto
argument_list|(
operator|(
name|int
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
block|;
comment|/* proc to delete lines */
block|}
name|ID_trms
index|[]
operator|=
block|{
literal|"generic"
block|,
name|GENi_lines
block|,
name|GENd_lines
block|,
comment|/* This should stay here */
ifdef|#
directive|ifdef
name|WIRED_TERMS
literal|"sun"
block|,
name|SUNi_lines
block|,
name|SUNd_lines
block|,
literal|"bg"
block|,
name|BGi_lines
block|,
name|BGd_lines
block|,
literal|"c1"
block|,
name|C100i_lines
block|,
name|C100d_lines
block|,
endif|#
directive|endif
comment|/* WIRED_TERMS */
name|NULL
block|,
literal|0
block|,
literal|0
block|}
expr_stmt|;
end_expr_stmt

begin_function
name|void
name|IDline_setup
parameter_list|(
name|tname
parameter_list|)
name|char
modifier|*
name|tname
decl_stmt|;
block|{
specifier|register
specifier|const
name|struct
name|ID_lookup
modifier|*
name|idp
decl_stmt|;
for|for
control|(
name|idp
operator|=
operator|&
name|ID_trms
index|[
literal|1
index|]
init|;
name|idp
operator|->
name|ID_name
condition|;
name|idp
operator|++
control|)
if|if
condition|(
name|strncmp
argument_list|(
name|idp
operator|->
name|ID_name
argument_list|,
name|tname
argument_list|,
name|strlen
argument_list|(
name|idp
operator|->
name|ID_name
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|idp
operator|->
name|ID_name
operator|==
name|NULL
condition|)
name|idp
operator|=
operator|&
name|ID_trms
index|[
literal|0
index|]
expr_stmt|;
name|TTins_line
operator|=
name|idp
operator|->
name|I_proc
expr_stmt|;
name|TTdel_line
operator|=
name|idp
operator|->
name|D_proc
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* TERMCAP */
end_comment

end_unit

