begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/***************************************************************************  * This program is Copyright (C) 1986, 1987, 1988 by Jonathan Payne.  JOVE *  * is provided to you without charge, and with no warranty.  You may give  *  * away copies of JOVE, including sources, provided that this notice is    *  * included in all the files.                                              *  ***************************************************************************/
end_comment

begin_include
include|#
directive|include
file|"jove.h"
end_include

begin_include
include|#
directive|include
file|"list.h"
end_include

begin_include
include|#
directive|include
file|"fp.h"
end_include

begin_include
include|#
directive|include
file|"termcap.h"
end_include

begin_include
include|#
directive|include
file|"chars.h"
end_include

begin_include
include|#
directive|include
file|"disp.h"
end_include

begin_include
include|#
directive|include
file|"re.h"
end_include

begin_comment
comment|/* Up until now a keymap was an array of pointers to    data_obj's.  A data_obj was either a pointer to a built-in    command or a keyboard macro.  Now a data_obj can be a    pointer to a keymap as well, which is how prefix keys will    be handled.     There will be a way to build keymaps and give them names,    and to look those keymaps up by name, attach them to keys.    There will be a way to specify a string of key strokes and    have a series of keymaps built automatically for those    sequences. */
end_comment

begin_decl_stmt
name|private
name|void
name|fb_aux
name|proto
argument_list|(
operator|(
name|data_obj
operator|*
operator|,
expr|struct
name|keymap
operator|*
operator|,
name|char
operator|*
operator|,
name|char
operator|*
operator|,
name|size_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|List
modifier|*
name|keymaps
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* list of all keymaps */
end_comment

begin_decl_stmt
name|private
name|struct
name|keymap
modifier|*
name|mainmap
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|IPROCS
end_ifdef

begin_decl_stmt
name|private
name|struct
name|keymap
modifier|*
name|procsmap
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* make a new keymap, give it name NAME, initialize the keys array    to keys, if nonzero, or make an empty one, otherwise */
end_comment

begin_function
name|private
name|struct
name|keymap
modifier|*
name|km_new
parameter_list|(
name|name
parameter_list|,
name|keys
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
name|data_obj
modifier|*
modifier|*
name|keys
decl_stmt|;
block|{
name|struct
name|keymap
modifier|*
name|km
decl_stmt|;
name|km
operator|=
operator|(
expr|struct
name|keymap
operator|*
operator|)
name|emalloc
argument_list|(
sizeof|sizeof
expr|*
name|km
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|list_push
argument_list|(
operator|&
name|keymaps
argument_list|,
operator|(
name|UnivPtr
operator|)
name|km
argument_list|)
expr_stmt|;
name|km
operator|->
name|Type
operator|=
name|KEYMAP
expr_stmt|;
name|km
operator|->
name|Name
operator|=
name|name
expr_stmt|;
if|if
condition|(
name|keys
operator|!=
name|NULL
condition|)
block|{
name|km
operator|->
name|k_keys
operator|=
name|keys
expr_stmt|;
name|km
operator|->
name|k_alloc_p
operator|=
name|NO
expr_stmt|;
block|}
else|else
block|{
name|km
operator|->
name|k_keys
operator|=
operator|(
name|data_obj
operator|*
operator|*
operator|)
name|emalloc
argument_list|(
name|NCHARS
operator|*
sizeof|sizeof
argument_list|(
name|data_obj
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|byte_zero
argument_list|(
operator|(
name|UnivPtr
operator|)
name|km
operator|->
name|k_keys
argument_list|,
name|NCHARS
operator|*
sizeof|sizeof
argument_list|(
name|data_obj
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|km
operator|->
name|k_alloc_p
operator|=
name|YES
expr_stmt|;
block|}
return|return
name|km
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|NEVER
end_ifdef

begin_comment
comment|/* free up a keymap */
end_comment

begin_function
name|private
name|void
name|km_destroy
parameter_list|(
name|km
parameter_list|)
name|struct
name|keymap
modifier|*
name|km
decl_stmt|;
block|{
if|if
condition|(
name|km
operator|->
name|k_alloc_p
operator|==
name|YES
condition|)
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|km
operator|->
name|k_keys
argument_list|)
expr_stmt|;
name|km
operator|->
name|k_keys
operator|=
name|NULL
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|km
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* lookup a keymap by name */
end_comment

begin_function
name|private
name|struct
name|keymap
modifier|*
name|km_lookup
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|List
modifier|*
name|lp
decl_stmt|;
for|for
control|(
name|lp
operator|=
name|keymaps
init|;
name|lp
operator|!=
name|NULL
condition|;
name|lp
operator|=
name|list_next
argument_list|(
name|lp
argument_list|)
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
operator|(
operator|(
expr|struct
name|keymap
operator|*
operator|)
name|list_data
argument_list|(
name|lp
argument_list|)
operator|)
operator|->
name|Name
argument_list|)
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|lp
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
return|return
operator|(
expr|struct
name|keymap
operator|*
operator|)
name|list_data
argument_list|(
name|lp
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* given a map and a key, return the object bound to that key */
end_comment

begin_define
define|#
directive|define
name|km_getkey
parameter_list|(
name|m
parameter_list|,
name|c
parameter_list|)
value|((m)->k_keys[(c)& CHARMASK])
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|km_getkey
end_ifndef

begin_function
name|data_obj
modifier|*
name|km_getkey
parameter_list|(
name|m
parameter_list|,
name|c
parameter_list|)
name|struct
name|keymap
modifier|*
name|m
decl_stmt|;
name|int
name|c
decl_stmt|;
block|{
return|return
operator|(
name|m
operator|->
name|k_keys
index|[
name|c
operator|&
name|CHARMASK
index|]
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|private
name|void
name|km_setkey
parameter_list|(
name|m
parameter_list|,
name|c
parameter_list|,
name|d
parameter_list|)
name|struct
name|keymap
modifier|*
name|m
decl_stmt|;
name|int
name|c
decl_stmt|;
name|data_obj
modifier|*
name|d
decl_stmt|;
block|{
name|m
operator|->
name|k_keys
index|[
name|c
operator|&
name|CHARMASK
index|]
operator|=
name|d
expr_stmt|;
block|}
end_function

begin_comment
comment|/* get the currently active keymaps into km_buf */
end_comment

begin_function
name|private
name|int
name|get_keymaps
parameter_list|(
name|km_buf
parameter_list|)
name|struct
name|keymap
modifier|*
modifier|*
name|km_buf
decl_stmt|;
block|{
name|int
name|nmaps
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|IPROCS
if|if
condition|(
name|curbuf
operator|->
name|b_process
operator|!=
name|NULL
condition|)
name|km_buf
index|[
name|nmaps
operator|++
index|]
operator|=
name|procsmap
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|curbuf
operator|->
name|b_map
operator|!=
name|NULL
condition|)
name|km_buf
index|[
name|nmaps
operator|++
index|]
operator|=
name|curbuf
operator|->
name|b_map
expr_stmt|;
name|km_buf
index|[
name|nmaps
operator|++
index|]
operator|=
name|mainmap
expr_stmt|;
return|return
name|nmaps
return|;
block|}
end_function

begin_function
name|private
name|struct
name|keymap
modifier|*
name|IsPrefix
parameter_list|(
name|cp
parameter_list|)
name|data_obj
modifier|*
name|cp
decl_stmt|;
block|{
if|if
condition|(
name|cp
operator|==
name|NULL
operator|||
operator|(
name|cp
operator|->
name|Type
operator|&
name|TYPEMASK
operator|)
operator|!=
name|KEYMAP
condition|)
return|return
name|NULL
return|;
return|return
operator|(
expr|struct
name|keymap
operator|*
operator|)
name|cp
return|;
block|}
end_function

begin_comment
comment|/* Is `c' a prefix character */
end_comment

begin_function
name|int
name|PrefChar
parameter_list|(
name|c
parameter_list|)
name|int
name|c
decl_stmt|;
block|{
return|return
operator|(
name|int
operator|)
name|IsPrefix
argument_list|(
name|km_getkey
argument_list|(
name|mainmap
argument_list|,
name|c
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|void
name|UnbindC
parameter_list|()
block|{
name|char
modifier|*
name|keys
decl_stmt|;
name|struct
name|keymap
modifier|*
name|map
init|=
name|mainmap
decl_stmt|;
name|keys
operator|=
name|ask
argument_list|(
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|ProcFmt
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|keys
index|[
literal|1
index|]
operator|==
literal|'\0'
condition|)
break|break;
if|if
condition|(
operator|(
name|map
operator|=
name|IsPrefix
argument_list|(
name|km_getkey
argument_list|(
name|map
argument_list|,
operator|*
name|keys
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
break|break;
name|keys
operator|+=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|keys
index|[
literal|1
index|]
operator|!=
literal|'\0'
condition|)
name|complain
argument_list|(
literal|"That's not a legitimate key sequence."
argument_list|)
expr_stmt|;
name|km_setkey
argument_list|(
name|map
argument_list|,
name|keys
index|[
literal|0
index|]
argument_list|,
operator|(
name|data_obj
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|private
name|void
name|BindWMap
parameter_list|(
name|map
parameter_list|,
name|lastkey
parameter_list|,
name|cmd
parameter_list|)
name|struct
name|keymap
modifier|*
name|map
decl_stmt|;
name|int
name|lastkey
decl_stmt|;
name|data_obj
modifier|*
name|cmd
decl_stmt|;
block|{
name|struct
name|keymap
modifier|*
name|nextmap
decl_stmt|;
name|int
name|c
decl_stmt|;
name|c
operator|=
name|addgetc
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
block|{
if|if
condition|(
name|lastkey
operator|==
name|EOF
condition|)
name|complain
argument_list|(
literal|"[Empty key sequence]"
argument_list|)
expr_stmt|;
name|complain
argument_list|(
literal|"[Premature end of key sequence]"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|nextmap
operator|=
name|IsPrefix
argument_list|(
name|km_getkey
argument_list|(
name|map
argument_list|,
name|c
argument_list|)
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|BindWMap
argument_list|(
name|nextmap
argument_list|,
name|c
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
else|else
block|{
name|km_setkey
argument_list|(
name|map
argument_list|,
name|c
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MAC
operator|(
operator|(
expr|struct
name|cmd
operator|*
operator|)
name|cmd
operator|)
operator|->
name|c_key
operator|=
name|c
expr_stmt|;
comment|/* see about_j() in mac.c */
if|if
condition|(
name|map
operator|->
name|k_keys
operator|==
name|MainKeys
condition|)
operator|(
operator|(
expr|struct
name|cmd
operator|*
operator|)
name|cmd
operator|)
operator|->
name|c_map
operator|=
name|F_MAINMAP
expr_stmt|;
elseif|else
if|if
condition|(
name|map
operator|->
name|k_keys
operator|==
name|EscKeys
condition|)
operator|(
operator|(
expr|struct
name|cmd
operator|*
operator|)
name|cmd
operator|)
operator|->
name|c_map
operator|=
name|F_PREF1MAP
expr_stmt|;
elseif|else
if|if
condition|(
name|map
operator|==
operator|(
expr|struct
name|keymap
operator|*
operator|)
name|CtlxKeys
condition|)
operator|(
operator|(
expr|struct
name|cmd
operator|*
operator|)
name|cmd
operator|)
operator|->
name|c_map
operator|=
name|F_PREF2MAP
expr_stmt|;
endif|#
directive|endif
block|}
block|}
block|}
end_function

begin_decl_stmt
name|private
name|void
name|BindSomething
argument_list|(
name|proc
argument_list|,
name|map
argument_list|)
name|data_obj
modifier|*
argument_list|(
operator|*
name|proc
argument_list|)
name|ptrproto
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|keymap
modifier|*
name|map
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|data_obj
modifier|*
name|d
decl_stmt|;
if|if
condition|(
operator|(
name|d
operator|=
call|(
modifier|*
name|proc
call|)
argument_list|(
name|ProcFmt
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return;
name|s_mess
argument_list|(
literal|": %f %s "
argument_list|,
name|d
operator|->
name|Name
argument_list|)
expr_stmt|;
name|BindWMap
argument_list|(
name|map
argument_list|,
name|EOF
argument_list|,
name|d
argument_list|)
expr_stmt|;
block|}
end_block

begin_function
name|void
name|BindAKey
parameter_list|()
block|{
name|BindSomething
argument_list|(
name|findcom
argument_list|,
name|mainmap
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|BindMac
parameter_list|()
block|{
name|BindSomething
argument_list|(
name|findmac
argument_list|,
name|mainmap
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|private
name|void
name|DescWMap
parameter_list|(
name|map
parameter_list|,
name|key
parameter_list|)
name|struct
name|keymap
modifier|*
name|map
decl_stmt|;
name|int
name|key
decl_stmt|;
block|{
name|data_obj
modifier|*
name|cp
init|=
name|km_getkey
argument_list|(
name|map
argument_list|,
name|key
argument_list|)
decl_stmt|;
name|struct
name|keymap
modifier|*
name|prefp
decl_stmt|;
if|if
condition|(
name|cp
operator|==
name|NULL
condition|)
name|add_mess
argument_list|(
literal|"is unbound."
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|prefp
operator|=
name|IsPrefix
argument_list|(
name|cp
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|DescWMap
argument_list|(
name|prefp
argument_list|,
name|addgetc
argument_list|()
argument_list|)
expr_stmt|;
else|else
name|add_mess
argument_list|(
literal|"is bound to %s."
argument_list|,
name|cp
operator|->
name|Name
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|KeyDesc
parameter_list|()
block|{
name|s_mess
argument_list|(
name|ProcFmt
argument_list|)
expr_stmt|;
name|DescWMap
argument_list|(
name|mainmap
argument_list|,
name|addgetc
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|private
name|void
name|DescMap
parameter_list|(
name|map
parameter_list|,
name|pref
parameter_list|)
name|struct
name|keymap
modifier|*
name|map
decl_stmt|;
name|char
modifier|*
name|pref
decl_stmt|;
block|{
name|int
name|c1
decl_stmt|,
name|c2
decl_stmt|;
name|char
name|keydescbuf
index|[
literal|40
index|]
decl_stmt|;
name|struct
name|keymap
modifier|*
name|prefp
decl_stmt|;
for|for
control|(
name|c1
operator|=
literal|0
init|;
name|c1
operator|<
name|NCHARS
condition|;
name|c1
operator|=
name|c2
operator|+
literal|1
control|)
block|{
name|c2
operator|=
name|c1
expr_stmt|;
if|if
condition|(
name|km_getkey
argument_list|(
name|map
argument_list|,
name|c1
argument_list|)
operator|==
literal|0
condition|)
continue|continue;
do|do
empty_stmt|;
do|while
condition|(
operator|++
name|c2
operator|<
name|NCHARS
operator|&&
name|km_getkey
argument_list|(
name|map
argument_list|,
name|c1
argument_list|)
operator|==
name|km_getkey
argument_list|(
name|map
argument_list|,
name|c2
argument_list|)
condition|)
do|;
name|c2
operator|-=
literal|1
expr_stmt|;
name|swritef
argument_list|(
name|keydescbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|keydescbuf
argument_list|)
argument_list|,
name|c1
operator|==
name|c2
condition|?
literal|"%s %p"
else|:
name|c1
operator|==
name|c2
operator|+
literal|1
condition|?
literal|"%s {%p,%p}"
else|:
literal|"%s [%p-%p]"
argument_list|,
name|pref
argument_list|,
name|c1
argument_list|,
name|c2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|prefp
operator|=
name|IsPrefix
argument_list|(
name|km_getkey
argument_list|(
name|map
argument_list|,
name|c1
argument_list|)
argument_list|)
operator|)
operator|!=
name|NULL
operator|&&
operator|(
name|prefp
operator|!=
name|map
operator|)
condition|)
name|DescMap
argument_list|(
name|prefp
argument_list|,
name|keydescbuf
argument_list|)
expr_stmt|;
else|else
name|Typeout
argument_list|(
literal|"%-18s%s"
argument_list|,
name|keydescbuf
argument_list|,
name|km_getkey
argument_list|(
name|map
argument_list|,
name|c1
argument_list|)
operator|->
name|Name
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|DescBindings
parameter_list|()
block|{
name|TOstart
argument_list|(
literal|"Key Bindings"
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|DescMap
argument_list|(
name|mainmap
argument_list|,
name|NullStr
argument_list|)
expr_stmt|;
name|TOstop
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|private
name|void
name|find_binds
parameter_list|(
name|dp
parameter_list|,
name|buf
parameter_list|,
name|size
parameter_list|)
name|data_obj
modifier|*
name|dp
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
name|size_t
name|size
decl_stmt|;
block|{
name|char
modifier|*
name|endp
decl_stmt|;
name|buf
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|fb_aux
argument_list|(
name|dp
argument_list|,
name|mainmap
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|buf
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|endp
operator|=
name|buf
operator|+
name|strlen
argument_list|(
name|buf
argument_list|)
operator|-
literal|2
expr_stmt|;
if|if
condition|(
operator|(
name|endp
operator|>
name|buf
operator|)
operator|&&
operator|(
name|strcmp
argument_list|(
name|endp
argument_list|,
literal|", "
argument_list|)
operator|==
literal|0
operator|)
condition|)
operator|*
name|endp
operator|=
literal|'\0'
expr_stmt|;
block|}
end_function

begin_function
name|private
name|void
name|fb_aux
parameter_list|(
name|cp
parameter_list|,
name|map
parameter_list|,
name|prefix
parameter_list|,
name|buf
parameter_list|,
name|size
parameter_list|)
specifier|register
name|data_obj
modifier|*
name|cp
decl_stmt|;
name|struct
name|keymap
modifier|*
name|map
decl_stmt|;
name|char
modifier|*
name|prefix
decl_stmt|,
decl|*
name|buf
decl_stmt|;
end_function

begin_decl_stmt
name|size_t
name|size
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|c1
decl_stmt|,
name|c2
decl_stmt|;
name|char
modifier|*
name|bufp
init|=
name|buf
operator|+
name|strlen
argument_list|(
name|buf
argument_list|)
decl_stmt|,
name|prefbuf
index|[
literal|20
index|]
decl_stmt|;
name|struct
name|keymap
modifier|*
name|prefp
decl_stmt|;
for|for
control|(
name|c1
operator|=
literal|0
init|;
name|c1
operator|<
name|NCHARS
condition|;
name|c1
operator|=
name|c2
operator|+
literal|1
control|)
block|{
name|c2
operator|=
name|c1
expr_stmt|;
if|if
condition|(
name|km_getkey
argument_list|(
name|map
argument_list|,
name|c1
argument_list|)
operator|==
name|cp
condition|)
block|{
do|do
empty_stmt|;
do|while
condition|(
operator|++
name|c2
operator|<
name|NCHARS
operator|&&
name|km_getkey
argument_list|(
name|map
argument_list|,
name|c1
argument_list|)
operator|==
name|km_getkey
argument_list|(
name|map
argument_list|,
name|c2
argument_list|)
condition|)
do|;
name|c2
operator|-=
literal|1
expr_stmt|;
if|if
condition|(
name|prefix
condition|)
name|swritef
argument_list|(
name|bufp
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
operator|-
operator|(
name|bufp
operator|-
name|buf
operator|)
argument_list|,
literal|"%s "
argument_list|,
name|prefix
argument_list|)
expr_stmt|;
name|bufp
operator|+=
name|strlen
argument_list|(
name|bufp
argument_list|)
expr_stmt|;
name|swritef
argument_list|(
name|bufp
argument_list|,
name|size
operator|-
operator|(
name|bufp
operator|-
name|buf
operator|)
argument_list|,
name|c1
operator|==
name|c2
condition|?
literal|"%p"
else|:
name|c1
operator|==
name|c2
operator|+
literal|1
condition|?
literal|"{%p,%p}"
else|:
literal|"[%p-%p]"
argument_list|,
name|c1
argument_list|,
name|c2
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|prefp
operator|=
name|IsPrefix
argument_list|(
name|km_getkey
argument_list|(
name|map
argument_list|,
name|c1
argument_list|)
argument_list|)
operator|)
operator|!=
name|NULL
operator|&&
operator|(
name|prefp
operator|!=
name|map
operator|)
condition|)
block|{
name|swritef
argument_list|(
name|prefbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|prefbuf
argument_list|)
argument_list|,
literal|"%p"
argument_list|,
name|c1
argument_list|)
expr_stmt|;
name|fb_aux
argument_list|(
name|cp
argument_list|,
name|prefp
argument_list|,
name|prefbuf
argument_list|,
name|bufp
argument_list|,
name|size
operator|-
operator|(
name|bufp
operator|-
name|buf
operator|)
argument_list|)
expr_stmt|;
block|}
name|bufp
operator|+=
name|strlen
argument_list|(
name|bufp
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_function
name|void
name|DescCom
parameter_list|()
block|{
name|data_obj
modifier|*
name|dp
decl_stmt|;
name|char
name|pattern
index|[
literal|100
index|]
decl_stmt|,
modifier|*
name|file
init|=
name|CmdDb
decl_stmt|;
specifier|const
name|char
modifier|*
name|doc_type
decl_stmt|;
specifier|static
specifier|const
name|char
name|var_type
index|[]
init|=
literal|"Variable"
decl_stmt|;
specifier|static
specifier|const
name|char
name|cmd_type
index|[]
init|=
literal|"Command"
decl_stmt|;
name|File
modifier|*
name|fp
decl_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|LastCmd
operator|->
name|Name
argument_list|,
literal|"describe-variable"
argument_list|)
condition|)
block|{
name|doc_type
operator|=
name|var_type
expr_stmt|;
name|dp
operator|=
operator|(
name|data_obj
operator|*
operator|)
name|findvar
argument_list|(
name|ProcFmt
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|doc_type
operator|=
name|cmd_type
expr_stmt|;
name|dp
operator|=
operator|(
name|data_obj
operator|*
operator|)
name|findcom
argument_list|(
name|ProcFmt
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dp
operator|==
name|NULL
condition|)
return|return;
name|fp
operator|=
name|open_file
argument_list|(
name|file
argument_list|,
name|iobuff
argument_list|,
name|F_READ
argument_list|,
name|YES
argument_list|,
name|YES
argument_list|)
expr_stmt|;
name|Placur
argument_list|(
name|ILI
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|flushscreen
argument_list|()
expr_stmt|;
name|swritef
argument_list|(
name|pattern
argument_list|,
sizeof|sizeof
argument_list|(
name|pattern
argument_list|)
argument_list|,
literal|"^:entry \"%s\" \"%s\"$"
argument_list|,
name|dp
operator|->
name|Name
argument_list|,
name|doc_type
argument_list|)
expr_stmt|;
name|TOstart
argument_list|(
literal|"Help"
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|f_gets
argument_list|(
name|fp
argument_list|,
name|genbuf
argument_list|,
operator|(
name|size_t
operator|)
name|LBSIZE
argument_list|)
condition|)
block|{
name|Typeout
argument_list|(
literal|"There is no documentation for \"%s\"."
argument_list|,
name|dp
operator|->
name|Name
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|genbuf
index|[
literal|0
index|]
operator|==
literal|':'
operator|&&
name|LookingAt
argument_list|(
name|pattern
argument_list|,
name|genbuf
argument_list|,
literal|0
argument_list|)
condition|)
block|{
comment|/* found it ... let's print it */
if|if
condition|(
name|doc_type
operator|==
name|var_type
condition|)
name|Typeout
argument_list|(
name|dp
operator|->
name|Name
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|doc_type
operator|==
name|cmd_type
condition|)
block|{
name|char
name|binding
index|[
literal|128
index|]
decl_stmt|;
name|find_binds
argument_list|(
name|dp
argument_list|,
name|binding
argument_list|,
sizeof|sizeof
argument_list|(
name|binding
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|blnkp
argument_list|(
name|binding
argument_list|)
condition|)
name|Typeout
argument_list|(
literal|"To invoke %s, type \"ESC X %s<cr>\"."
argument_list|,
name|dp
operator|->
name|Name
argument_list|,
name|dp
operator|->
name|Name
argument_list|)
expr_stmt|;
else|else
name|Typeout
argument_list|(
literal|"Type \"%s\" to invoke %s."
argument_list|,
name|binding
argument_list|,
name|dp
operator|->
name|Name
argument_list|)
expr_stmt|;
block|}
name|Typeout
argument_list|(
literal|""
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|f_gets
argument_list|(
name|fp
argument_list|,
name|genbuf
argument_list|,
operator|(
name|size_t
operator|)
name|LBSIZE
argument_list|)
operator|&&
name|strncmp
argument_list|(
name|genbuf
argument_list|,
literal|":entry"
argument_list|,
operator|(
name|size_t
operator|)
literal|6
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|Typeout
argument_list|(
literal|"%s"
argument_list|,
name|genbuf
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
name|f_close
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|TOstop
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|Apropos
parameter_list|()
block|{
specifier|register
specifier|const
name|struct
name|cmd
modifier|*
name|cp
decl_stmt|;
specifier|register
name|struct
name|macro
modifier|*
name|m
decl_stmt|;
specifier|register
specifier|const
name|struct
name|variable
modifier|*
name|v
decl_stmt|;
name|char
modifier|*
name|ans
decl_stmt|;
name|bool
name|anyfs
init|=
name|NO
decl_stmt|,
name|anyvs
init|=
name|NO
decl_stmt|,
name|anyms
init|=
name|NO
decl_stmt|;
name|char
name|buf
index|[
literal|256
index|]
decl_stmt|;
name|ans
operator|=
name|ask
argument_list|(
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
literal|": %f (keyword) "
argument_list|)
expr_stmt|;
name|TOstart
argument_list|(
literal|"Help"
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
for|for
control|(
name|cp
operator|=
name|commands
init|;
name|cp
operator|->
name|Name
operator|!=
name|NULL
condition|;
name|cp
operator|++
control|)
if|if
condition|(
name|sindex
argument_list|(
name|ans
argument_list|,
name|cp
operator|->
name|Name
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|anyfs
condition|)
block|{
name|Typeout
argument_list|(
literal|"Commands"
argument_list|)
expr_stmt|;
name|Typeout
argument_list|(
literal|"--------"
argument_list|)
expr_stmt|;
block|}
name|find_binds
argument_list|(
operator|(
name|data_obj
operator|*
operator|)
name|cp
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
index|[
literal|0
index|]
condition|)
name|Typeout
argument_list|(
literal|": %-35s (%s)"
argument_list|,
name|cp
operator|->
name|Name
argument_list|,
name|buf
argument_list|)
expr_stmt|;
else|else
name|Typeout
argument_list|(
literal|": %s"
argument_list|,
name|cp
operator|->
name|Name
argument_list|)
expr_stmt|;
name|anyfs
operator|=
name|YES
expr_stmt|;
block|}
if|if
condition|(
name|anyfs
condition|)
name|Typeout
argument_list|(
name|NullStr
argument_list|)
expr_stmt|;
for|for
control|(
name|v
operator|=
name|variables
init|;
name|v
operator|->
name|Name
operator|!=
name|NULL
condition|;
name|v
operator|++
control|)
if|if
condition|(
name|sindex
argument_list|(
name|ans
argument_list|,
name|v
operator|->
name|Name
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|anyvs
condition|)
block|{
name|Typeout
argument_list|(
literal|"Variables"
argument_list|)
expr_stmt|;
name|Typeout
argument_list|(
literal|"---------"
argument_list|)
expr_stmt|;
block|}
name|anyvs
operator|=
name|YES
expr_stmt|;
name|vpr_aux
argument_list|(
name|v
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|Typeout
argument_list|(
literal|": set %-26s %s"
argument_list|,
name|v
operator|->
name|Name
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|anyvs
condition|)
name|Typeout
argument_list|(
name|NullStr
argument_list|)
expr_stmt|;
for|for
control|(
name|m
operator|=
name|macros
init|;
name|m
operator|!=
name|NULL
condition|;
name|m
operator|=
name|m
operator|->
name|m_nextm
control|)
if|if
condition|(
name|sindex
argument_list|(
name|ans
argument_list|,
name|m
operator|->
name|Name
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|anyms
condition|)
block|{
name|Typeout
argument_list|(
literal|"Macros"
argument_list|)
expr_stmt|;
name|Typeout
argument_list|(
literal|"------"
argument_list|)
expr_stmt|;
block|}
name|anyms
operator|=
name|YES
expr_stmt|;
name|find_binds
argument_list|(
operator|(
name|data_obj
operator|*
operator|)
name|m
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
index|[
literal|0
index|]
condition|)
name|Typeout
argument_list|(
literal|": %-35s (%s)"
argument_list|,
name|m
operator|->
name|Name
argument_list|,
name|buf
argument_list|)
expr_stmt|;
else|else
name|Typeout
argument_list|(
literal|": %-35s %s"
argument_list|,
literal|"execute-macro"
argument_list|,
name|m
operator|->
name|Name
argument_list|)
expr_stmt|;
block|}
name|TOstop
argument_list|()
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|NEVER
end_ifdef

begin_function
name|private
name|char
modifier|*
name|km_newname
parameter_list|()
block|{
name|char
name|buffer
index|[
literal|128
index|]
decl_stmt|;
specifier|static
name|int
name|km_count
init|=
literal|1
decl_stmt|;
name|swritef
argument_list|(
name|buffer
argument_list|,
sizeof|sizeof
argument_list|(
name|buffer
argument_list|)
argument_list|,
literal|"keymap-%d"
argument_list|,
name|km_count
operator|++
argument_list|)
expr_stmt|;
return|return
name|copystr
argument_list|(
name|buffer
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|void
name|InitKeymaps
parameter_list|()
block|{
name|struct
name|keymap
modifier|*
name|km
decl_stmt|;
name|mainmap
operator|=
name|km_new
argument_list|(
name|copystr
argument_list|(
literal|"mainmap"
argument_list|)
argument_list|,
name|MainKeys
argument_list|)
expr_stmt|;
comment|/* setup ESC map */
name|km
operator|=
name|km_new
argument_list|(
name|copystr
argument_list|(
literal|"ESC-map"
argument_list|)
argument_list|,
name|EscKeys
argument_list|)
expr_stmt|;
name|km_setkey
argument_list|(
name|mainmap
argument_list|,
name|ESC
argument_list|,
operator|(
name|data_obj
operator|*
operator|)
name|km
argument_list|)
expr_stmt|;
comment|/* setup Ctlx map */
name|km
operator|=
name|km_new
argument_list|(
name|copystr
argument_list|(
literal|"CTLX-map"
argument_list|)
argument_list|,
name|CtlxKeys
argument_list|)
expr_stmt|;
name|km_setkey
argument_list|(
name|mainmap
argument_list|,
name|CTL
argument_list|(
literal|'X'
argument_list|)
argument_list|,
operator|(
name|data_obj
operator|*
operator|)
name|km
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|MakeKMap
parameter_list|()
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|name
operator|=
name|ask
argument_list|(
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|ProcFmt
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|km_new
argument_list|(
name|copystr
argument_list|(
name|name
argument_list|)
argument_list|,
operator|(
name|data_obj
operator|*
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|private
name|data_obj
modifier|*
name|findmap
parameter_list|(
name|fmt
parameter_list|)
specifier|const
name|char
modifier|*
name|fmt
decl_stmt|;
block|{
name|List
modifier|*
name|lp
decl_stmt|;
name|char
modifier|*
name|strings
index|[
literal|128
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|lp
operator|=
name|keymaps
operator|,
name|i
operator|=
literal|0
init|;
name|lp
operator|!=
name|NULL
condition|;
name|lp
operator|=
name|list_next
argument_list|(
name|lp
argument_list|)
control|)
name|strings
index|[
name|i
operator|++
index|]
operator|=
operator|(
operator|(
expr|struct
name|keymap
operator|*
operator|)
name|list_data
argument_list|(
name|lp
argument_list|)
operator|)
operator|->
name|Name
expr_stmt|;
name|strings
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
name|i
operator|=
name|complete
argument_list|(
name|strings
argument_list|,
name|fmt
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
return|return
name|NULL
return|;
name|lp
operator|=
name|keymaps
expr_stmt|;
while|while
condition|(
operator|--
name|i
operator|>=
literal|0
condition|)
name|lp
operator|=
name|list_next
argument_list|(
name|lp
argument_list|)
expr_stmt|;
return|return
operator|(
name|data_obj
operator|*
operator|)
name|list_data
argument_list|(
name|lp
argument_list|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|IPROCS
end_ifdef

begin_function
name|private
name|void
name|mk_proc_km
parameter_list|()
block|{
name|procsmap
operator|=
name|km_new
argument_list|(
literal|"process-keymap"
argument_list|,
operator|(
name|data_obj
operator|*
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ProcBind
parameter_list|()
block|{
name|data_obj
modifier|*
name|d
decl_stmt|;
if|if
condition|(
name|procsmap
operator|==
name|NULL
condition|)
name|mk_proc_km
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|d
operator|=
name|findcom
argument_list|(
name|ProcFmt
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return;
name|s_mess
argument_list|(
literal|": %f %s "
argument_list|,
name|d
operator|->
name|Name
argument_list|)
expr_stmt|;
name|BindWMap
argument_list|(
name|procsmap
argument_list|,
name|EOF
argument_list|,
name|d
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ProcKmBind
parameter_list|()
block|{
name|data_obj
modifier|*
name|d
decl_stmt|;
if|if
condition|(
name|procsmap
operator|==
name|NULL
condition|)
name|mk_proc_km
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|d
operator|=
name|findmap
argument_list|(
name|ProcFmt
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return;
name|s_mess
argument_list|(
literal|": %f %s "
argument_list|,
name|d
operator|->
name|Name
argument_list|)
expr_stmt|;
name|BindWMap
argument_list|(
name|procsmap
argument_list|,
name|EOF
argument_list|,
name|d
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|void
name|KmBind
parameter_list|()
block|{
name|BindSomething
argument_list|(
name|findmap
argument_list|,
name|mainmap
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|dispatch
parameter_list|(
name|c
parameter_list|)
specifier|register
name|int
name|c
decl_stmt|;
block|{
name|data_obj
modifier|*
name|cp
decl_stmt|;
name|struct
name|keymap
modifier|*
name|maps
index|[
literal|10
index|]
decl_stmt|;
comment|/* never more than 10 active 					   maps at a time, I promise */
name|int
name|nmaps
decl_stmt|;
name|this_cmd
operator|=
literal|0
expr_stmt|;
name|nmaps
operator|=
name|get_keymaps
argument_list|(
name|maps
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|int
name|i
decl_stmt|,
name|nvalid
decl_stmt|,
name|slow
init|=
name|NO
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|nvalid
operator|=
literal|0
init|;
name|i
operator|<
name|nmaps
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|maps
index|[
name|i
index|]
operator|==
name|NULL
condition|)
continue|continue;
name|cp
operator|=
name|km_getkey
argument_list|(
name|maps
index|[
name|i
index|]
argument_list|,
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|obj_type
argument_list|(
name|cp
argument_list|)
operator|!=
name|KEYMAP
condition|)
block|{
name|ExecCmd
argument_list|(
name|cp
argument_list|)
expr_stmt|;
return|return;
block|}
name|nvalid
operator|+=
literal|1
expr_stmt|;
block|}
name|maps
index|[
name|i
index|]
operator|=
operator|(
expr|struct
name|keymap
operator|*
operator|)
name|cp
expr_stmt|;
block|}
if|if
condition|(
name|nvalid
operator|==
literal|0
condition|)
block|{
name|char
name|strokes
index|[
literal|128
index|]
decl_stmt|;
name|pp_key_strokes
argument_list|(
name|strokes
argument_list|,
sizeof|sizeof
argument_list|(
name|strokes
argument_list|)
argument_list|)
expr_stmt|;
name|s_mess
argument_list|(
literal|"[%sunbound]"
argument_list|,
name|strokes
argument_list|)
expr_stmt|;
name|rbell
argument_list|()
expr_stmt|;
name|clr_arg_value
argument_list|()
expr_stmt|;
name|errormsg
operator|=
name|NO
expr_stmt|;
return|return;
block|}
name|c
operator|=
name|waitchar
argument_list|(
operator|&
name|slow
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|AbortChar
condition|)
block|{
name|message
argument_list|(
literal|"[Aborted]"
argument_list|)
expr_stmt|;
name|rbell
argument_list|()
expr_stmt|;
return|return;
block|}
block|}
block|}
end_function

end_unit

