begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/***************************************************************************  * This program is Copyright (C) 1986, 1987, 1988 by Jonathan Payne.  JOVE *  * is provided to you without charge, and with no warranty.  You may give  *  * away copies of JOVE, including sources, provided that this notice is    *  * included in all the files.                                              *  ***************************************************************************/
end_comment

begin_include
include|#
directive|include
file|"jove.h"
end_include

begin_include
include|#
directive|include
file|"termcap.h"
end_include

begin_include
include|#
directive|include
file|"ctype.h"
end_include

begin_include
include|#
directive|include
file|"chars.h"
end_include

begin_include
include|#
directive|include
file|"disp.h"
end_include

begin_include
include|#
directive|include
file|"fp.h"
end_include

begin_include
include|#
directive|include
file|"scandir.h"
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|MAC
end_ifdef

begin_include
include|#
directive|include
file|"mac.h"
end_include

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* !MAC */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|STDARGS
end_ifdef

begin_include
include|#
directive|include
file|<stdarg.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<varargs.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|F_COMPLETION
end_ifdef

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !MAC */
end_comment

begin_decl_stmt
name|int
name|AbortChar
init|=
name|CTL
argument_list|(
literal|'G'
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|bool
name|DoEVexpand
init|=
name|NO
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* should we expand evironment variables? */
end_comment

begin_decl_stmt
name|bool
name|Asking
init|=
name|NO
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|AskingWidth
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|Minibuf
index|[
name|LBSIZE
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|Line
modifier|*
name|CurAskPtr
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* points at some line in mini-buffer */
end_comment

begin_decl_stmt
name|private
name|Buffer
modifier|*
name|AskBuffer
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Askbuffer points to actual structure */
end_comment

begin_comment
comment|/* The way the mini-buffer works is this:  The first line of the mini-buffer    is where the user does his stuff.  The rest of the buffer contains    strings that the user often wants to use, for instance, file names, or    common search strings, etc.  If he types C-N or C-P while in ask(), we    bump the point up or down a line and extract the contents (we make sure    is somewhere in the mini-buffer). */
end_comment

begin_function
name|private
name|Buffer
modifier|*
name|get_minibuf
parameter_list|()
block|{
if|if
condition|(
name|AskBuffer
condition|)
block|{
comment|/* make sure ut still exists */
specifier|register
name|Buffer
modifier|*
name|b
decl_stmt|;
for|for
control|(
name|b
operator|=
name|world
init|;
name|b
operator|!=
name|NULL
condition|;
name|b
operator|=
name|b
operator|->
name|b_next
control|)
if|if
condition|(
name|b
operator|==
name|AskBuffer
condition|)
return|return
name|b
return|;
block|}
name|AskBuffer
operator|=
name|do_select
argument_list|(
operator|(
name|Window
operator|*
operator|)
name|NULL
argument_list|,
literal|"*minibuf*"
argument_list|)
expr_stmt|;
name|AskBuffer
operator|->
name|b_type
operator|=
name|B_SCRATCH
expr_stmt|;
return|return
name|AskBuffer
return|;
block|}
end_function

begin_comment
comment|/* Add a string to the mini-buffer. */
end_comment

begin_function
name|void
name|minib_add
parameter_list|(
name|str
parameter_list|,
name|movedown
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
name|bool
name|movedown
decl_stmt|;
block|{
specifier|register
name|Buffer
modifier|*
name|saveb
init|=
name|curbuf
decl_stmt|;
name|SetBuf
argument_list|(
name|get_minibuf
argument_list|()
argument_list|)
expr_stmt|;
name|LineInsert
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|ins_str
argument_list|(
name|str
argument_list|,
name|NO
argument_list|)
expr_stmt|;
if|if
condition|(
name|movedown
condition|)
name|CurAskPtr
operator|=
name|curline
expr_stmt|;
name|SetBuf
argument_list|(
name|saveb
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* look for any substrings of the form $foo in linebuf, and expand    them according to their value in the environment (if possible) -    this munges all over curchar and linebuf without giving it a second    thought (I must be getting lazy in my old age) */
end_comment

begin_function
name|private
name|void
name|EVexpand
parameter_list|()
block|{
specifier|register
name|int
name|c
decl_stmt|;
specifier|register
name|char
modifier|*
name|lp
init|=
name|linebuf
decl_stmt|,
modifier|*
name|ep
decl_stmt|;
name|char
name|varname
index|[
literal|128
index|]
decl_stmt|,
modifier|*
name|vp
decl_stmt|,
modifier|*
name|lp_start
decl_stmt|;
name|Mark
modifier|*
name|m
init|=
name|MakeMark
argument_list|(
name|curline
argument_list|,
name|curchar
argument_list|,
name|M_FLOATER
argument_list|)
decl_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|lp
operator|++
operator|)
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
name|c
operator|!=
literal|'$'
condition|)
continue|continue;
name|lp_start
operator|=
name|lp
operator|-
literal|1
expr_stmt|;
comment|/* the $ */
name|vp
operator|=
name|varname
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|lp
operator|++
operator|)
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
operator|!
name|jisword
argument_list|(
name|c
argument_list|)
condition|)
break|break;
operator|*
name|vp
operator|++
operator|=
name|c
expr_stmt|;
block|}
operator|*
name|vp
operator|=
literal|'\0'
expr_stmt|;
comment|/* if we find an env. variable with the right 		   name, we insert it in linebuf, and then delete 		   the variable name that we're replacing - and 		   then we continue in case there are others ... */
if|if
condition|(
operator|(
name|ep
operator|=
name|getenv
argument_list|(
name|varname
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|curchar
operator|=
name|lp_start
operator|-
name|linebuf
expr_stmt|;
name|ins_str
argument_list|(
name|ep
argument_list|,
name|NO
argument_list|)
expr_stmt|;
name|del_char
argument_list|(
name|FORWARD
argument_list|,
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|varname
argument_list|)
operator|+
literal|1
argument_list|,
name|NO
argument_list|)
expr_stmt|;
name|lp
operator|=
name|linebuf
operator|+
name|curchar
expr_stmt|;
block|}
block|}
name|ToMark
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|DelMark
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
name|bool
name|InRealAsk
init|=
name|NO
decl_stmt|;
end_decl_stmt

begin_function_decl
name|private
name|char
modifier|*
name|real_ask
parameter_list|(
name|delim
parameter_list|,
name|d_proc
parameter_list|,
name|def
parameter_list|,
name|prompt
parameter_list|)
name|char
modifier|*
name|delim
decl_stmt|,
decl|*
name|def
decl_stmt|,
modifier|*
name|prompt
decl_stmt|;
end_function_decl

begin_macro
name|bool
argument_list|(
argument|*d_proc
argument_list|)
end_macro

begin_expr_stmt
name|proto
argument_list|(
operator|(
name|int
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|jmp_buf
name|savejmp
decl_stmt|;
name|int
name|c
decl_stmt|,
name|prompt_len
decl_stmt|;
name|Buffer
modifier|*
name|saveb
init|=
name|curbuf
decl_stmt|;
specifier|volatile
name|int
name|aborted
init|=
name|NO
decl_stmt|;
name|int
name|no_typed
init|=
name|NO
decl_stmt|;
name|data_obj
modifier|*
name|push_cmd
init|=
name|LastCmd
decl_stmt|;
name|int
name|o_a_v
init|=
name|arg_value
argument_list|()
decl_stmt|,
name|o_i_an_a
init|=
name|is_an_arg
argument_list|()
decl_stmt|;
ifdef|#
directive|ifdef
name|MAC
name|menus_off
argument_list|()
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|InRealAsk
condition|)
name|complain
argument_list|(
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|push_env
argument_list|(
name|savejmp
argument_list|)
expr_stmt|;
name|InRealAsk
operator|=
name|YES
expr_stmt|;
name|SetBuf
argument_list|(
name|get_minibuf
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|inlist
argument_list|(
name|AskBuffer
operator|->
name|b_first
argument_list|,
name|CurAskPtr
argument_list|)
condition|)
name|CurAskPtr
operator|=
name|curline
expr_stmt|;
name|prompt_len
operator|=
name|strlen
argument_list|(
name|prompt
argument_list|)
expr_stmt|;
name|ToFirst
argument_list|()
expr_stmt|;
comment|/* Beginning of buffer. */
name|linebuf
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|modify
argument_list|()
expr_stmt|;
name|makedirty
argument_list|(
name|curline
argument_list|)
expr_stmt|;
if|if
condition|(
name|setjmp
argument_list|(
name|mainjmp
argument_list|)
condition|)
block|{
if|if
condition|(
name|InJoverc
condition|)
block|{
comment|/* this is a kludge */
name|aborted
operator|=
name|YES
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
block|}
for|for
control|(
init|;
condition|;
control|)
block|{
name|clr_arg_value
argument_list|()
expr_stmt|;
name|last_cmd
operator|=
name|this_cmd
expr_stmt|;
name|init_strokes
argument_list|()
expr_stmt|;
name|cont
label|:
name|s_mess
argument_list|(
literal|"%s%s"
argument_list|,
name|prompt
argument_list|,
name|linebuf
argument_list|)
expr_stmt|;
name|Asking
operator|=
name|YES
expr_stmt|;
name|AskingWidth
operator|=
name|curchar
operator|+
name|prompt_len
expr_stmt|;
name|c
operator|=
name|getch
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|==
name|EOF
operator|)
operator|||
operator|(
name|c
operator|!=
literal|'\0'
operator|&&
name|strchr
argument_list|(
name|delim
argument_list|,
name|c
argument_list|)
operator|!=
name|NULL
operator|)
condition|)
block|{
if|if
condition|(
name|DoEVexpand
condition|)
name|EVexpand
argument_list|()
expr_stmt|;
if|if
condition|(
name|d_proc
operator|==
operator|(
name|bool
argument_list|(
argument|*
argument_list|)
name|proto
argument_list|(
operator|(
name|int
operator|)
argument_list|)
operator|)
name|NULL
operator|||
operator|!
call|(
modifier|*
name|d_proc
call|)
argument_list|(
name|c
argument_list|)
condition|)
break|break;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
name|AbortChar
condition|)
block|{
name|message
argument_list|(
literal|"[Aborted]"
argument_list|)
expr_stmt|;
name|aborted
operator|=
name|YES
expr_stmt|;
break|break;
block|}
else|else
switch|switch
condition|(
name|c
condition|)
block|{
case|case
name|CTL
argument_list|(
literal|'N'
argument_list|)
case|:
case|case
name|CTL
argument_list|(
literal|'P'
argument_list|)
case|:
case|case
name|CTL
argument_list|(
literal|'U'
argument_list|)
case|:
comment|/* Allow ^U as a synonym for ^P */
if|if
condition|(
name|CurAskPtr
operator|!=
name|NULL
condition|)
block|{
name|int
name|n
init|=
operator|(
name|c
operator|==
name|CTL
argument_list|(
literal|'P'
argument_list|)
condition|?
operator|-
name|arg_value
argument_list|()
else|:
name|arg_value
argument_list|()
operator|)
decl_stmt|;
name|CurAskPtr
operator|=
name|next_line
argument_list|(
name|CurAskPtr
argument_list|,
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|CurAskPtr
operator|==
name|curbuf
operator|->
name|b_first
operator|&&
name|CurAskPtr
operator|->
name|l_next
operator|!=
name|NULL
condition|)
name|CurAskPtr
operator|=
name|CurAskPtr
operator|->
name|l_next
expr_stmt|;
operator|(
name|void
operator|)
name|ltobuf
argument_list|(
name|CurAskPtr
argument_list|,
name|linebuf
argument_list|)
expr_stmt|;
name|modify
argument_list|()
expr_stmt|;
name|makedirty
argument_list|(
name|curline
argument_list|)
expr_stmt|;
name|Eol
argument_list|()
expr_stmt|;
name|this_cmd
operator|=
literal|0
expr_stmt|;
block|}
break|break;
case|case
name|CTL
argument_list|(
literal|'R'
argument_list|)
case|:
if|if
condition|(
name|def
condition|)
name|ins_str
argument_list|(
name|def
argument_list|,
name|NO
argument_list|)
expr_stmt|;
else|else
name|rbell
argument_list|()
expr_stmt|;
break|break;
default|default:
name|dispatch
argument_list|(
name|c
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|curbuf
operator|!=
name|AskBuffer
condition|)
name|SetBuf
argument_list|(
name|AskBuffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|curline
operator|!=
name|curbuf
operator|->
name|b_first
condition|)
block|{
name|CurAskPtr
operator|=
name|curline
expr_stmt|;
name|curline
operator|=
name|curbuf
operator|->
name|b_first
expr_stmt|;
comment|/* with whatever is in linebuf */
block|}
if|if
condition|(
name|this_cmd
operator|==
name|ARG_CMD
condition|)
goto|goto
name|cont
goto|;
block|}
name|cleanup
label|:
name|pop_env
argument_list|(
name|savejmp
argument_list|)
expr_stmt|;
name|LastCmd
operator|=
name|push_cmd
expr_stmt|;
name|set_arg_value
argument_list|(
name|o_a_v
argument_list|)
expr_stmt|;
name|set_is_an_arg
argument_list|(
name|o_i_an_a
argument_list|)
expr_stmt|;
name|no_typed
operator|=
operator|(
name|linebuf
index|[
literal|0
index|]
operator|==
literal|'\0'
operator|)
expr_stmt|;
name|strcpy
argument_list|(
name|Minibuf
argument_list|,
name|linebuf
argument_list|)
expr_stmt|;
name|SetBuf
argument_list|(
name|saveb
argument_list|)
expr_stmt|;
name|InRealAsk
operator|=
name|Asking
operator|=
name|Interactive
operator|=
name|NO
expr_stmt|;
if|if
condition|(
operator|!
name|aborted
condition|)
block|{
if|if
condition|(
operator|!
name|charp
argument_list|()
condition|)
block|{
name|Placur
argument_list|(
name|ILI
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|flushscreen
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|no_typed
condition|)
return|return
name|NULL
return|;
block|}
else|else
name|complain
argument_list|(
name|mesgbuf
argument_list|)
expr_stmt|;
return|return
name|Minibuf
return|;
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|STDARGS
end_ifdef

begin_function
name|char
modifier|*
name|ask
parameter_list|(
name|char
modifier|*
name|def
parameter_list|,
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
else|#
directive|else
comment|/*VARARGS2*/
function|char * ask
parameter_list|(
name|def
parameter_list|,
name|fmt
parameter_list|,
name|va_alist
parameter_list|)
name|char
modifier|*
name|def
decl_stmt|,
decl|*
name|fmt
decl_stmt|;
end_function

begin_macro
name|va_dcl
end_macro

begin_endif
endif|#
directive|endif
end_endif

begin_block
block|{
name|char
name|prompt
index|[
literal|128
index|]
decl_stmt|;
name|char
modifier|*
name|ans
decl_stmt|;
name|va_list
name|ap
decl_stmt|;
name|va_init
argument_list|(
name|ap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|format
argument_list|(
name|prompt
argument_list|,
sizeof|sizeof
name|prompt
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|ans
operator|=
name|real_ask
argument_list|(
literal|"\r\n"
argument_list|,
operator|(
name|bool
argument_list|(
argument|*
argument_list|)
name|proto
argument_list|(
operator|(
name|int
operator|)
argument_list|)
operator|)
name|NULL
argument_list|,
name|def
argument_list|,
name|prompt
argument_list|)
expr_stmt|;
if|if
condition|(
name|ans
operator|==
name|NULL
condition|)
block|{
comment|/* Typed nothing. */
if|if
condition|(
name|def
operator|==
name|NULL
condition|)
name|complain
argument_list|(
literal|"[No default]"
argument_list|)
expr_stmt|;
return|return
name|def
return|;
block|}
return|return
name|ans
return|;
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|STDARGS
end_ifdef

begin_decl_stmt
name|char
modifier|*
name|do_ask
argument_list|(
name|char
operator|*
name|delim
argument_list|,
name|bool
argument_list|(
argument|*d_proc
argument_list|)
name|proto
argument_list|(
operator|(
name|int
operator|)
argument_list|)
argument_list|,
name|char
operator|*
name|def
argument_list|,
specifier|const
name|char
operator|*
name|fmt
argument_list|,
operator|...
argument_list|)
else|#
directive|else
comment|/*VARARGS4*/
name|char
modifier|*
name|do_ask
argument_list|(
name|delim
argument_list|,
name|d_proc
argument_list|,
name|def
argument_list|,
name|fmt
argument_list|,
name|va_alist
argument_list|)
name|char
modifier|*
name|delim
decl_stmt|,
modifier|*
name|def
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
modifier|*
name|fmt
decl_stmt|;
end_decl_stmt

begin_macro
name|bool
argument_list|(
argument|*d_proc
argument_list|)
end_macro

begin_expr_stmt
name|proto
argument_list|(
operator|(
name|int
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_macro
name|va_dcl
end_macro

begin_endif
endif|#
directive|endif
end_endif

begin_block
block|{
name|char
name|prompt
index|[
literal|128
index|]
decl_stmt|;
name|va_list
name|ap
decl_stmt|;
name|va_init
argument_list|(
name|ap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|format
argument_list|(
name|prompt
argument_list|,
sizeof|sizeof
name|prompt
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
return|return
name|real_ask
argument_list|(
name|delim
argument_list|,
name|d_proc
argument_list|,
name|def
argument_list|,
name|prompt
argument_list|)
return|;
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|STDARGS
end_ifdef

begin_function
name|int
name|yes_or_no_p
parameter_list|(
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
else|#
directive|else
comment|/*VARARGS1*/
function|int yes_or_no_p
parameter_list|(
name|fmt
parameter_list|,
name|va_alist
parameter_list|)
name|char
modifier|*
name|fmt
decl_stmt|;
function|va_dcl
endif|#
directive|endif
block|{
name|char
name|prompt
index|[
literal|128
index|]
decl_stmt|;
name|int
name|c
decl_stmt|;
name|va_list
name|ap
decl_stmt|;
name|va_init
argument_list|(
name|ap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|format
argument_list|(
name|prompt
argument_list|,
sizeof|sizeof
name|prompt
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|message
argument_list|(
name|prompt
argument_list|)
expr_stmt|;
name|Asking
operator|=
name|YES
expr_stmt|;
comment|/* so redisplay works */
name|AskingWidth
operator|=
name|strlen
argument_list|(
name|prompt
argument_list|)
expr_stmt|;
name|c
operator|=
name|getch
argument_list|()
expr_stmt|;
name|Asking
operator|=
name|NO
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|AbortChar
condition|)
name|complain
argument_list|(
literal|"[Aborted]"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|CharUpcase
argument_list|(
name|c
argument_list|)
condition|)
block|{
case|case
literal|'Y'
case|:
return|return
name|YES
return|;
case|case
literal|'N'
case|:
return|return
name|NO
return|;
default|default:
name|add_mess
argument_list|(
literal|"[Type Y or N]"
argument_list|)
expr_stmt|;
name|SitFor
argument_list|(
literal|10
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* NOTREACHED */
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|F_COMPLETION
end_ifdef

begin_decl_stmt
name|private
name|char
modifier|*
name|fc_filebase
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|bool
name|DispBadFs
init|=
name|YES
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* display bad file names? */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|MSDOS
end_ifndef

begin_decl_stmt
name|char
name|BadExtensions
index|[
literal|128
index|]
init|=
literal|".o"
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* MSDOS */
end_comment

begin_decl_stmt
name|char
name|BadExtensions
index|[
literal|128
index|]
init|=
literal|".obj .exe .com .bak .arc .lib .zoo"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* MSDOS */
end_comment

begin_function
name|private
name|int
name|bad_extension
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|char
modifier|*
name|ip
decl_stmt|,
modifier|*
name|bads
decl_stmt|;
name|size_t
name|namelen
init|=
name|strlen
argument_list|(
name|name
argument_list|)
decl_stmt|,
name|ext_len
decl_stmt|;
ifdef|#
directive|ifdef
name|UNIX
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"."
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".."
argument_list|)
operator|==
literal|0
condition|)
return|return
name|YES
return|;
endif|#
directive|endif
for|for
control|(
name|ip
operator|=
name|bads
operator|=
name|BadExtensions
init|;
operator|*
name|ip
operator|!=
literal|'\0'
condition|;
name|bads
operator|=
name|ip
operator|+
literal|1
control|)
block|{
if|if
condition|(
operator|(
name|ip
operator|=
name|strchr
argument_list|(
name|bads
argument_list|,
literal|' '
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|ip
operator|=
name|bads
operator|+
name|strlen
argument_list|(
name|bads
argument_list|)
expr_stmt|;
name|ext_len
operator|=
name|ip
operator|-
name|bads
expr_stmt|;
if|if
condition|(
name|ext_len
operator|!=
literal|0
operator|&&
name|ext_len
operator|<
name|namelen
operator|&&
operator|(
name|strncmp
argument_list|(
operator|&
name|name
index|[
name|namelen
operator|-
name|ext_len
index|]
argument_list|,
name|bads
argument_list|,
name|ext_len
argument_list|)
operator|==
literal|0
operator|)
condition|)
return|return
name|YES
return|;
block|}
return|return
name|NO
return|;
block|}
end_function

begin_function
name|private
name|int
name|f_match
parameter_list|(
name|file
parameter_list|)
name|char
modifier|*
name|file
decl_stmt|;
block|{
name|int
name|len
init|=
name|strlen
argument_list|(
name|fc_filebase
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|DispBadFs
operator|&&
name|bad_extension
argument_list|(
name|file
argument_list|)
condition|)
return|return
name|NO
return|;
return|return
operator|(
operator|(
name|len
operator|==
literal|0
operator|)
operator|||
ifdef|#
directive|ifdef
name|MSDOS
operator|(
name|casencmp
argument_list|(
name|file
argument_list|,
name|fc_filebase
argument_list|,
name|strlen
argument_list|(
name|fc_filebase
argument_list|)
argument_list|)
operator|==
literal|0
operator|)
else|#
directive|else
operator|(
name|strncmp
argument_list|(
name|file
argument_list|,
name|fc_filebase
argument_list|,
name|strlen
argument_list|(
name|fc_filebase
argument_list|)
argument_list|)
operator|==
literal|0
operator|)
endif|#
directive|endif
operator|)
return|;
block|}
end_function

begin_function
name|private
name|int
name|isdir
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|struct
name|stat
name|stbuf
decl_stmt|;
name|char
name|filebuf
index|[
name|FILESIZE
index|]
decl_stmt|;
name|PathParse
argument_list|(
name|name
argument_list|,
name|filebuf
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|stat
argument_list|(
name|filebuf
argument_list|,
operator|&
name|stbuf
argument_list|)
operator|!=
operator|-
literal|1
operator|)
operator|&&
operator|(
name|stbuf
operator|.
name|st_mode
operator|&
name|S_IFDIR
operator|)
operator|==
name|S_IFDIR
operator|)
return|;
block|}
end_function

begin_function
name|private
name|void
name|fill_in
parameter_list|(
name|dir_vec
parameter_list|,
name|n
parameter_list|)
specifier|register
name|char
modifier|*
modifier|*
name|dir_vec
decl_stmt|;
name|int
name|n
decl_stmt|;
block|{
name|int
name|minmatch
init|=
literal|0
decl_stmt|,
name|numfound
init|=
literal|0
decl_stmt|,
name|lastmatch
init|=
operator|-
literal|1
decl_stmt|,
name|i
decl_stmt|,
name|the_same
init|=
name|TRUE
decl_stmt|,
comment|/* After filling in, are we the same 				    as when we were called? */
name|is_ntdir
decl_stmt|;
comment|/* Is Newly Typed Directory name */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
comment|/* if it's no, then we have already filtered them out 		   in f_match() so there's no point in doing it again */
if|if
condition|(
name|DispBadFs
operator|&&
name|bad_extension
argument_list|(
name|dir_vec
index|[
name|i
index|]
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|numfound
condition|)
name|minmatch
operator|=
name|min
argument_list|(
name|minmatch
argument_list|,
name|numcomp
argument_list|(
name|dir_vec
index|[
name|lastmatch
index|]
argument_list|,
name|dir_vec
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|minmatch
operator|=
name|strlen
argument_list|(
name|dir_vec
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|lastmatch
operator|=
name|i
expr_stmt|;
name|numfound
operator|+=
literal|1
expr_stmt|;
block|}
comment|/* Ugh.  Beware--this is hard to get right in a reasonable 	   manner.  Please excuse this code--it's past my bedtime. */
if|if
condition|(
name|numfound
operator|==
literal|0
condition|)
block|{
name|rbell
argument_list|()
expr_stmt|;
return|return;
block|}
name|Eol
argument_list|()
expr_stmt|;
if|if
condition|(
name|minmatch
operator|>
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|fc_filebase
argument_list|)
condition|)
block|{
name|the_same
operator|=
name|FALSE
expr_stmt|;
name|null_ncpy
argument_list|(
name|fc_filebase
argument_list|,
name|dir_vec
index|[
name|lastmatch
index|]
argument_list|,
operator|(
name|size_t
operator|)
name|minmatch
argument_list|)
expr_stmt|;
name|Eol
argument_list|()
expr_stmt|;
name|makedirty
argument_list|(
name|curline
argument_list|)
expr_stmt|;
block|}
name|is_ntdir
operator|=
operator|(
operator|(
name|numfound
operator|==
literal|1
operator|)
operator|&&
operator|(
name|curchar
operator|>
literal|0
operator|)
operator|&&
operator|(
name|linebuf
index|[
name|curchar
operator|-
literal|1
index|]
operator|!=
literal|'/'
operator|)
operator|&&
operator|(
name|isdir
argument_list|(
name|linebuf
argument_list|)
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|the_same
operator|&&
operator|!
name|is_ntdir
condition|)
block|{
name|add_mess
argument_list|(
operator|(
name|n
operator|==
literal|1
operator|)
condition|?
literal|" [Unique]"
else|:
literal|" [Ambiguous]"
argument_list|)
expr_stmt|;
name|SitFor
argument_list|(
literal|7
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|is_ntdir
condition|)
name|insert_c
argument_list|(
literal|'/'
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* called from do_ask() when one of "\r\n ?" is typed.  Does the right    thing, depending on which. */
end_comment

begin_function
name|private
name|bool
name|f_complete
parameter_list|(
name|c
parameter_list|)
name|int
name|c
decl_stmt|;
block|{
name|char
name|dir
index|[
name|FILESIZE
index|]
decl_stmt|,
modifier|*
modifier|*
name|dir_vec
decl_stmt|;
name|int
name|nentries
decl_stmt|,
name|i
decl_stmt|;
if|if
condition|(
name|c
operator|==
name|CR
operator|||
name|c
operator|==
name|LF
condition|)
return|return
name|FALSE
return|;
comment|/* tells ask to return now */
name|fc_filebase
operator|=
name|strrchr
argument_list|(
name|linebuf
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MSDOS
if|if
condition|(
name|fc_filebase
operator|==
name|NULL
condition|)
block|{
name|fc_filebase
operator|=
name|strrchr
argument_list|(
name|linebuf
argument_list|,
literal|'\\'
argument_list|)
expr_stmt|;
if|if
condition|(
name|fc_filebase
operator|==
name|NULL
condition|)
name|fc_filebase
operator|=
name|strrchr
argument_list|(
name|linebuf
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* MSDOS */
if|if
condition|(
name|fc_filebase
operator|!=
name|NULL
condition|)
block|{
name|char
name|tmp
index|[
name|FILESIZE
index|]
decl_stmt|;
name|fc_filebase
operator|+=
literal|1
expr_stmt|;
name|null_ncpy
argument_list|(
name|tmp
argument_list|,
name|linebuf
argument_list|,
call|(
name|size_t
call|)
argument_list|(
name|fc_filebase
operator|-
name|linebuf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
name|strcpy
argument_list|(
name|tmp
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
name|PathParse
argument_list|(
name|tmp
argument_list|,
name|dir
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fc_filebase
operator|=
name|linebuf
expr_stmt|;
name|strcpy
argument_list|(
name|dir
argument_list|,
literal|"."
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|nentries
operator|=
name|jscandir
argument_list|(
name|dir
argument_list|,
operator|&
name|dir_vec
argument_list|,
name|f_match
argument_list|,
name|alphacomp
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
name|add_mess
argument_list|(
literal|" [Unknown directory: %s]"
argument_list|,
name|dir
argument_list|)
expr_stmt|;
name|SitFor
argument_list|(
literal|7
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
if|if
condition|(
name|nentries
operator|==
literal|0
condition|)
block|{
name|add_mess
argument_list|(
literal|" [No match]"
argument_list|)
expr_stmt|;
name|SitFor
argument_list|(
literal|7
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'\t'
condition|)
name|fill_in
argument_list|(
name|dir_vec
argument_list|,
name|nentries
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* we're a '?' */
name|int
name|maxlen
init|=
literal|0
decl_stmt|,
name|ncols
decl_stmt|,
name|col
decl_stmt|,
name|lines
decl_stmt|,
name|linespercol
decl_stmt|;
name|TOstart
argument_list|(
literal|"Completion"
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
comment|/* false means newline only on request */
name|Typeout
argument_list|(
literal|"(! means file will not be chosen unless typed explicitly)"
argument_list|)
expr_stmt|;
name|Typeout
argument_list|(
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|Typeout
argument_list|(
literal|"Possible completions (in %s):"
argument_list|,
name|dir
argument_list|)
expr_stmt|;
name|Typeout
argument_list|(
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nentries
condition|;
name|i
operator|++
control|)
name|maxlen
operator|=
name|max
argument_list|(
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|dir_vec
index|[
name|i
index|]
argument_list|)
argument_list|,
name|maxlen
argument_list|)
expr_stmt|;
name|maxlen
operator|+=
literal|4
expr_stmt|;
comment|/* pad each column with at least 4 spaces */
name|ncols
operator|=
operator|(
name|CO
operator|-
literal|2
operator|)
operator|/
name|maxlen
expr_stmt|;
name|linespercol
operator|=
literal|1
operator|+
operator|(
name|nentries
operator|/
name|ncols
operator|)
expr_stmt|;
for|for
control|(
name|lines
operator|=
literal|0
init|;
name|lines
operator|<
name|linespercol
condition|;
name|lines
operator|++
control|)
block|{
for|for
control|(
name|col
operator|=
literal|0
init|;
name|col
operator|<
name|ncols
condition|;
name|col
operator|++
control|)
block|{
name|bool
name|isbad
decl_stmt|;
name|int
name|which
decl_stmt|;
name|which
operator|=
operator|(
name|col
operator|*
name|linespercol
operator|)
operator|+
name|lines
expr_stmt|;
if|if
condition|(
name|which
operator|>=
name|nentries
condition|)
break|break;
if|if
condition|(
name|DispBadFs
condition|)
name|isbad
operator|=
name|bad_extension
argument_list|(
name|dir_vec
index|[
name|which
index|]
argument_list|)
expr_stmt|;
else|else
name|isbad
operator|=
name|NO
expr_stmt|;
name|Typeout
argument_list|(
literal|"%s%-*s"
argument_list|,
name|isbad
condition|?
literal|"!"
else|:
name|NullStr
argument_list|,
name|maxlen
operator|-
name|isbad
argument_list|,
name|dir_vec
index|[
name|which
index|]
argument_list|)
expr_stmt|;
block|}
name|Typeout
argument_list|(
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
name|TOstop
argument_list|()
expr_stmt|;
block|}
name|freedir
argument_list|(
operator|&
name|dir_vec
argument_list|,
name|nentries
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* F_COMPLETION */
end_comment

begin_function
name|char
modifier|*
name|ask_file
parameter_list|(
name|prmt
parameter_list|,
name|def
parameter_list|,
name|buf
parameter_list|)
specifier|const
name|char
modifier|*
name|prmt
decl_stmt|;
name|char
modifier|*
name|def
decl_stmt|,
decl|*
name|buf
decl_stmt|;
end_function

begin_block
block|{
name|char
modifier|*
name|ans
decl_stmt|,
name|prompt
index|[
literal|128
index|]
decl_stmt|,
modifier|*
name|pretty_name
init|=
name|pr_name
argument_list|(
name|def
argument_list|,
name|YES
argument_list|)
decl_stmt|;
if|if
condition|(
name|prmt
condition|)
block|{
name|strcpy
argument_list|(
name|prompt
argument_list|,
name|prmt
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|def
operator|!=
name|NULL
operator|&&
operator|*
name|def
operator|!=
literal|'\0'
condition|)
block|{
name|swritef
argument_list|(
name|prompt
argument_list|,
sizeof|sizeof
argument_list|(
name|prompt
argument_list|)
argument_list|,
literal|": %f (default %s) "
argument_list|,
name|pretty_name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|prompt
argument_list|)
operator|*
literal|2
operator|>=
name|CO
condition|)
name|swritef
argument_list|(
name|prompt
argument_list|,
sizeof|sizeof
argument_list|(
name|prompt
argument_list|)
argument_list|,
name|ProcFmt
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|swritef
argument_list|(
name|prompt
argument_list|,
sizeof|sizeof
argument_list|(
name|prompt
argument_list|)
argument_list|,
name|ProcFmt
argument_list|)
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|F_COMPLETION
name|ans
operator|=
name|real_ask
argument_list|(
literal|"\r\n \t?"
argument_list|,
name|f_complete
argument_list|,
name|pretty_name
argument_list|,
name|prompt
argument_list|)
expr_stmt|;
if|if
condition|(
name|ans
operator|==
name|NULL
operator|&&
operator|(
name|ans
operator|=
name|pretty_name
operator|)
operator|==
name|NULL
condition|)
name|complain
argument_list|(
literal|"[No default file name]"
argument_list|)
expr_stmt|;
else|#
directive|else
name|ans
operator|=
name|ask
argument_list|(
name|pretty_name
argument_list|,
name|prompt
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|PathParse
argument_list|(
name|ans
argument_list|,
name|buf
argument_list|)
expr_stmt|;
return|return
name|buf
return|;
block|}
end_block

end_unit

