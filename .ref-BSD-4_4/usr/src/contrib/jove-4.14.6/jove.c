begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/***************************************************************************  * This program is Copyright (C) 1986, 1987, 1988 by Jonathan Payne.  JOVE *  * is provided to you without charge, and with no warranty.  You may give  *  * away copies of JOVE, including sources, provided that this notice is    *  * included in all the files.                                              *  ***************************************************************************/
end_comment

begin_comment
comment|/* Contains the main loop initializations, and some system dependent    type things, e.g. putting terminal in CBREAK mode, etc. */
end_comment

begin_include
include|#
directive|include
file|"jove.h"
end_include

begin_include
include|#
directive|include
file|"fp.h"
end_include

begin_include
include|#
directive|include
file|"termcap.h"
end_include

begin_include
include|#
directive|include
file|"ctype.h"
end_include

begin_include
include|#
directive|include
file|"chars.h"
end_include

begin_include
include|#
directive|include
file|"disp.h"
end_include

begin_include
include|#
directive|include
file|"re.h"
end_include

begin_comment
comment|/* for find_tag() */
end_comment

begin_include
include|#
directive|include
file|"rec.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|IPROCS
end_ifdef

begin_include
include|#
directive|include
file|"iproc.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|UNIX
end_ifdef

begin_include
include|#
directive|include
file|"ttystate.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|SCO
end_ifdef

begin_undef
undef|#
directive|undef
name|TIOCGWINSZ
end_undef

begin_include
include|#
directive|include
file|<sys/stream.h>
end_include

begin_include
include|#
directive|include
file|<sys/ptem.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|MAC
end_ifdef

begin_include
include|#
directive|include
file|"mac.h"
end_include

begin_else
else|#
directive|else
end_else

begin_ifdef
ifdef|#
directive|ifdef
name|STDARGS
end_ifdef

begin_include
include|#
directive|include
file|<stdarg.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<varargs.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|MSDOS
end_ifdef

begin_include
include|#
directive|include
file|<process.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* MSDOS */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|MAC
end_ifndef

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|MSDOS
end_ifdef

begin_decl_stmt
name|private
name|void
name|break_off
name|proto
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|,
name|break_rst
name|proto
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|MAC
end_ifdef

begin_define
define|#
directive|define
name|WINRESIZE
value|1
end_define

begin_else
else|#
directive|else
end_else

begin_ifdef
ifdef|#
directive|ifdef
name|TIOCGWINSZ
end_ifdef

begin_ifdef
ifdef|#
directive|ifdef
name|SIGWINCH
end_ifdef

begin_define
define|#
directive|define
name|WINRESIZE
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|private
name|void
name|DoKeys
name|proto
argument_list|(
operator|(
name|bool
name|firsttime
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|MSDOS
end_ifdef

begin_decl_stmt
specifier|extern
else|#
directive|else
name|private
endif|#
directive|endif
name|void
name|UnsetTerm
name|proto
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|,
name|do_sgtty
name|proto
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Various tty state structures.  * Each is an array, subscripted by one of "OFF" or "ON".  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|UNIX
end_ifdef

begin_ifdef
ifdef|#
directive|ifdef
name|TIOCSLTC
end_ifdef

begin_decl_stmt
name|struct
name|ltchars
name|ls
index|[
literal|2
index|]
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* TIOCSLTC */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|TIOCGETC
end_ifdef

begin_decl_stmt
name|struct
name|tchars
name|tc
index|[
literal|2
index|]
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|PASS8
end_ifdef

begin_comment
comment|/* use pass8 instead of raw for meta-key */
end_comment

begin_decl_stmt
name|private
name|int
name|lmword
index|[
literal|2
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* local mode word */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|BRLUNIX
end_ifdef

begin_decl_stmt
name|struct
name|sg_brl
name|sg
index|[
literal|2
index|]
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|TERMIO
end_ifdef

begin_decl_stmt
name|struct
name|termio
name|sg
index|[
literal|2
index|]
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|TERMIOS
end_ifdef

begin_decl_stmt
name|struct
name|termios
name|sg
index|[
literal|2
index|]
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|SGTTY
end_ifdef

begin_decl_stmt
name|struct
name|sgttyb
name|sg
index|[
literal|2
index|]
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|BIFF
end_ifdef

begin_decl_stmt
name|private
name|struct
name|stat
name|tt_stat
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* for biff */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|BSD4_2
end_ifndef

begin_decl_stmt
name|private
name|char
modifier|*
name|tt_name
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* name of the control tty */
end_comment

begin_function_decl
specifier|extern
name|char
modifier|*
name|ttyname
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* for systems w/o fchmod ... */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|private
name|bool
name|dw_biff
init|=
name|NO
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* whether or not to fotz at all */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* BIFF */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* UNIX */
end_comment

begin_decl_stmt
name|bool
name|errormsg
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|NullStr
index|[]
init|=
literal|""
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|jmp_buf
name|mainjmp
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|MSDOS
end_ifdef

begin_define
define|#
directive|define
name|SIGHUP
value|99
end_define

begin_define
define|#
directive|define
name|SIGIOT
value|99
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* MSDOS */
end_comment

begin_comment
comment|/* finish() does not return, so it is funny that it returns a non-void  * result.  This is because most systems claim that signal(2) deals  * with functions of type int ().  ANSI changes this: the function  * type must be void (int).  This bridge must soon be crossed.  */
end_comment

begin_function
name|SIGRESULT
name|finish
parameter_list|(
name|code
parameter_list|)
name|int
name|code
decl_stmt|;
block|{
name|int
name|save_errno
init|=
name|errno
decl_stmt|;
comment|/* Subtle, but necessary! */
specifier|static
name|int
name|Crashing
init|=
literal|0
decl_stmt|;
comment|/* we are in the middle of crashing */
name|bool
name|CoreDump
init|=
operator|(
name|code
operator|!=
literal|0
operator|&&
name|code
operator|!=
name|SIGHUP
operator|)
decl_stmt|,
name|DelTmps
init|=
name|YES
decl_stmt|;
comment|/* Usually we delete them. */
if|if
condition|(
name|code
operator|==
name|SIGINT
condition|)
block|{
name|char
name|c
decl_stmt|;
ifdef|#
directive|ifdef
name|PIPEPROCS
name|int
name|started
decl_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|MENLO_JCL
operator|(
name|void
operator|)
name|signal
argument_list|(
name|code
argument_list|,
name|finish
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|f_mess
argument_list|(
literal|"Abort (Type 'n' if you're not sure)? "
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|MSDOS
ifdef|#
directive|ifdef
name|PIPEPROCS
name|started
operator|=
name|kbd_stop
argument_list|()
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SYSV
if|if
condition|(
name|read
argument_list|(
literal|0
argument_list|,
operator|(
name|UnivPtr
operator|)
operator|&
name|c
argument_list|,
operator|(
name|size_t
operator|)
literal|1
argument_list|)
operator|!=
literal|1
condition|)
endif|#
directive|endif
operator|(
name|void
operator|)
name|read
argument_list|(
literal|0
argument_list|,
operator|(
name|UnivPtr
operator|)
operator|&
name|c
argument_list|,
operator|(
name|size_t
operator|)
literal|1
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PIPEPROCS
if|if
condition|(
name|started
condition|)
operator|(
name|void
operator|)
name|kbd_strt
argument_list|()
expr_stmt|;
endif|#
directive|endif
else|#
directive|else
comment|/* MSDOS */
name|c
operator|=
name|getrawinchar
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* MSDOS */
name|message
argument_list|(
name|NullStr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|&
literal|0377
operator|)
operator|!=
literal|'y'
condition|)
block|{
name|redisplay
argument_list|()
expr_stmt|;
name|errno
operator|=
name|save_errno
expr_stmt|;
name|SIGRETURN
expr_stmt|;
block|}
block|}
name|DisabledRedisplay
operator|=
name|YES
expr_stmt|;
ifndef|#
directive|ifndef
name|MAC
name|UnsetTerm
argument_list|(
name|NullStr
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PIPEPROCS
name|kbd_kill
argument_list|()
expr_stmt|;
comment|/* kill the keyboard process */
endif|#
directive|endif
ifndef|#
directive|ifndef
name|MSDOS
if|if
condition|(
name|code
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|Crashing
condition|)
block|{
name|Crashing
operator|=
name|YES
expr_stmt|;
name|lsave
argument_list|()
expr_stmt|;
name|SyncRec
argument_list|()
expr_stmt|;
name|writef
argument_list|(
literal|"JOVE CRASH!! (code %d): %s\n"
argument_list|,
name|code
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ModBufs
argument_list|(
name|YES
argument_list|)
condition|)
block|{
name|writef
argument_list|(
literal|"Your buffers have been saved.\n"
argument_list|)
expr_stmt|;
name|writef
argument_list|(
literal|"Use \"jove -r\" to have a look at them.\n"
argument_list|)
expr_stmt|;
name|DelTmps
operator|=
name|NO
expr_stmt|;
comment|/* Don't delete anymore. */
block|}
else|else
name|writef
argument_list|(
literal|"You didn't lose any work.\n"
argument_list|)
expr_stmt|;
block|}
else|else
name|writef
argument_list|(
literal|"\r\nYou may have lost your work!\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* MSDOS */
name|flushscreen
argument_list|()
expr_stmt|;
if|if
condition|(
name|DelTmps
condition|)
block|{
ifdef|#
directive|ifdef
name|PTYPROCS
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGCHLD
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|tmpremove
argument_list|()
expr_stmt|;
ifndef|#
directive|ifndef
name|MSDOS
name|recremove
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* MSDOS */
block|}
ifdef|#
directive|ifdef
name|UNIX
if|if
condition|(
name|CoreDump
condition|)
name|abort
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|PROFILING
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
else|#
directive|else
name|_exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
else|#
directive|else
comment|/* !UNIX */
ifdef|#
directive|ifdef
name|MSDOS
name|break_rst
argument_list|()
expr_stmt|;
comment|/* restore previous ctrl-c handling */
endif|#
directive|endif
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* !UNIX */
comment|/*NOTREACHED*/
block|}
end_function

begin_decl_stmt
name|private
name|char
name|smbuf
index|[
literal|20
index|]
decl_stmt|,
modifier|*
name|bp
init|=
name|smbuf
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|int
name|nchars
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|char
name|peekbuf
index|[
literal|10
index|]
decl_stmt|,
modifier|*
name|peekp
init|=
name|peekbuf
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|defined
argument_list|(
name|SYSV
argument_list|)
operator|||
name|defined
argument_list|(
name|M_XENIX
argument_list|)
end_if

begin_define
define|#
directive|define
name|NONBLOCKINGREAD
value|1
end_define

begin_function
name|private
name|void
name|setblock
parameter_list|(
name|fd
parameter_list|,
name|on
parameter_list|)
comment|/* turn blocking on or off */
specifier|register
name|int
name|fd
decl_stmt|;
name|bool
name|on
decl_stmt|;
block|{
specifier|static
name|int
name|blockf
decl_stmt|,
name|nonblockf
decl_stmt|;
specifier|static
name|bool
name|first
init|=
name|TRUE
decl_stmt|;
if|if
condition|(
name|first
condition|)
block|{
name|int
name|flags
decl_stmt|;
name|first
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|=
name|fcntl
argument_list|(
name|fd
argument_list|,
name|F_GETFL
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
name|finish
argument_list|(
name|SIGHUP
argument_list|)
expr_stmt|;
name|blockf
operator|=
name|flags
operator|&
operator|~
name|O_NDELAY
expr_stmt|;
comment|/* make sure O_NDELAY is off */
name|nonblockf
operator|=
name|flags
operator||
name|O_NDELAY
expr_stmt|;
comment|/* make sure O_NDELAY is on */
block|}
if|if
condition|(
name|fcntl
argument_list|(
name|fd
argument_list|,
name|F_SETFL
argument_list|,
name|on
condition|?
name|blockf
else|:
name|nonblockf
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|finish
argument_list|(
name|SIGHUP
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* defined(SYSV) || defined(M_XENIX) */
end_comment

begin_function
name|private
name|int
name|Peekc
parameter_list|()
block|{
return|return
name|peekp
operator|==
name|peekbuf
condition|?
name|EOF
else|:
operator|*
operator|--
name|peekp
operator|&
literal|0377
return|;
block|}
end_function

begin_function
name|void
name|Ungetc
parameter_list|(
name|c
parameter_list|)
name|int
name|c
decl_stmt|;
block|{
if|if
condition|(
name|peekp
operator|!=
operator|&
name|peekbuf
index|[
operator|(
sizeof|sizeof
name|peekbuf
operator|)
operator|-
literal|1
index|]
condition|)
operator|*
name|peekp
operator|++
operator|=
name|c
expr_stmt|;
block|}
end_function

begin_decl_stmt
name|bool
name|InputPending
init|=
name|NO
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|Inputp
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|PTYPROCS
end_ifdef

begin_function
name|int
name|jgetchar
parameter_list|()
block|{
name|fd_set
name|reads
decl_stmt|;
specifier|register
name|int
name|max
init|=
name|getdtablesize
argument_list|()
decl_stmt|;
specifier|register
name|int
name|tmp
decl_stmt|,
name|nfds
decl_stmt|;
name|int
name|c
decl_stmt|;
if|if
condition|(
name|nchars
operator|<=
literal|0
condition|)
block|{
comment|/* Get a character from the keyboard, first checking for 		   any input from a process.  Handle that first, and then 		   deal with the terminal input. */
do|do
block|{
do|do
block|{
name|reads
operator|=
name|global_fd
expr_stmt|;
name|nfds
operator|=
name|select
argument_list|(
name|max
argument_list|,
operator|&
name|reads
argument_list|,
operator|(
name|fd_set
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|fd_set
operator|*
operator|)
literal|0
argument_list|,
operator|(
expr|struct
name|timeval
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|nfds
operator|<
literal|0
operator|&&
name|errno
operator|==
name|EINTR
condition|)
do|;
if|if
condition|(
name|nfds
operator|==
operator|-
literal|1
condition|)
name|complain
argument_list|(
literal|"\rerror in select %ld: %s"
argument_list|,
name|global_fd
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|FD_ISSET
argument_list|(
literal|0
argument_list|,
operator|&
name|reads
argument_list|)
condition|)
block|{
name|nchars
operator|=
name|read
argument_list|(
literal|0
argument_list|,
operator|(
name|UnivPtr
operator|)
name|smbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|smbuf
argument_list|)
argument_list|)
expr_stmt|;
name|FD_CLR
argument_list|(
literal|0
argument_list|,
operator|&
name|reads
argument_list|)
expr_stmt|;
name|nfds
operator|--
expr_stmt|;
block|}
for|for
control|(
name|tmp
operator|=
literal|1
init|;
name|tmp
operator|<
name|max
condition|;
name|tmp
operator|++
control|)
block|{
if|if
condition|(
name|FD_ISSET
argument_list|(
name|tmp
argument_list|,
operator|&
name|reads
argument_list|)
condition|)
block|{
name|read_proc
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
name|FD_CLR
argument_list|(
name|tmp
argument_list|,
operator|&
name|reads
argument_list|)
expr_stmt|;
if|if
condition|(
operator|--
name|nfds
operator|==
literal|0
condition|)
break|break;
block|}
block|}
block|}
block|}
do|while
condition|(
name|nchars
operator|<=
literal|0
condition|)
do|;
if|if
condition|(
name|nchars
operator|<=
literal|0
condition|)
name|finish
argument_list|(
name|SIGHUP
argument_list|)
expr_stmt|;
name|bp
operator|=
name|smbuf
expr_stmt|;
name|InputPending
operator|=
operator|(
name|nchars
operator|>
literal|1
operator|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
operator|(
name|c
operator|=
operator|*
name|bp
operator|)
operator|&
literal|0200
operator|)
operator|&&
name|MetaKey
condition|)
block|{
operator|*
name|bp
operator|=
operator|(
name|c
operator|&
name|CHARMASK
operator|)
expr_stmt|;
return|return
literal|'\033'
return|;
block|}
name|nchars
operator|-=
literal|1
expr_stmt|;
return|return
operator|*
name|bp
operator|++
operator|&
literal|0377
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* !PTYPROCS */
end_comment

begin_function
name|int
name|jgetchar
parameter_list|()
block|{
specifier|register
name|int
name|c
decl_stmt|;
struct|struct
name|header
block|{
name|int
name|pid
decl_stmt|;
name|int
name|nbytes
decl_stmt|;
block|}
name|header
struct|;
name|normal
label|:
if|if
condition|(
name|nchars
operator|<=
literal|0
condition|)
block|{
name|bp
operator|=
name|smbuf
expr_stmt|;
ifdef|#
directive|ifdef
name|MSDOS
operator|*
name|bp
operator|=
name|getrawinchar
argument_list|()
expr_stmt|;
name|nchars
operator|=
literal|1
expr_stmt|;
else|#
directive|else
comment|/* !MSDOS */
ifdef|#
directive|ifdef
name|IPROCS
if|if
condition|(
name|NumProcs
operator|>
literal|0
condition|)
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
name|size_t
name|n
init|=
name|f_readn
argument_list|(
name|ProcInput
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|header
argument_list|,
sizeof|sizeof
argument_list|(
name|header
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|n
operator|!=
sizeof|sizeof
argument_list|(
name|header
argument_list|)
condition|)
block|{
name|raw_complain
argument_list|(
literal|"\r\nError reading kbd process, expected %d, got %d bytes\r\n"
argument_list|,
sizeof|sizeof
name|header
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|finish
argument_list|(
name|SIGHUP
argument_list|)
expr_stmt|;
block|}
comment|/* data is from the keyboard process */
if|if
condition|(
name|header
operator|.
name|pid
operator|==
name|kbd_pid
condition|)
block|{
name|nchars
operator|=
name|f_readn
argument_list|(
name|ProcInput
argument_list|,
name|smbuf
argument_list|,
name|header
operator|.
name|nbytes
argument_list|)
expr_stmt|;
if|if
condition|(
name|nchars
operator|!=
name|header
operator|.
name|nbytes
condition|)
block|{
name|raw_complain
argument_list|(
literal|"\r\nError reading kbd process, expected %d, got %d bytes.\r\n"
argument_list|,
name|header
operator|.
name|nbytes
argument_list|,
name|nchars
argument_list|)
expr_stmt|;
name|finish
argument_list|(
name|SIGHUP
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
name|read_proc
argument_list|(
name|header
operator|.
name|pid
argument_list|,
name|header
operator|.
name|nbytes
argument_list|)
expr_stmt|;
if|if
condition|(
name|NumProcs
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|kbd_stop
argument_list|()
expr_stmt|;
goto|goto
name|normal
goto|;
block|}
block|}
block|}
else|else
comment|/*...*/
endif|#
directive|endif
comment|/*...*/
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
name|nchars
operator|=
name|read
argument_list|(
literal|0
argument_list|,
operator|(
name|UnivPtr
operator|)
name|smbuf
argument_list|,
sizeof|sizeof
name|smbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|nchars
operator|>
literal|0
condition|)
break|break;
ifdef|#
directive|ifdef
name|SYSV
comment|/* System V seems to allow zero-length results */
if|if
condition|(
name|nchars
operator|==
literal|0
condition|)
continue|continue;
endif|#
directive|endif
comment|/* SYSV */
comment|/* retry on interrupt */
if|if
condition|(
operator|!
operator|(
name|nchars
operator|<
literal|0
operator|&&
name|errno
operator|==
name|EINTR
operator|)
condition|)
name|finish
argument_list|(
name|SIGHUP
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* !MSDOS */
name|InputPending
operator|=
name|nchars
operator|>
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|(
operator|(
name|c
operator|=
operator|*
name|bp
operator|)
operator|&
literal|0200
operator|)
operator|&&
name|MetaKey
condition|)
block|{
operator|*
name|bp
operator|=
operator|(
name|c
operator|&
name|CHARMASK
operator|)
expr_stmt|;
return|return
literal|'\033'
return|;
block|}
name|nchars
operator|-=
literal|1
expr_stmt|;
return|return
operator|(
operator|*
name|bp
operator|++
operator|&
name|CHARMASK
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !PTYPROCS */
end_comment

begin_comment
comment|/* Returns non-zero if a character waiting */
end_comment

begin_function
name|bool
name|charp
parameter_list|()
block|{
name|bool
name|some
init|=
name|NO
decl_stmt|;
if|if
condition|(
name|InJoverc
operator|!=
literal|0
operator|||
name|nchars
operator|>
literal|0
operator|||
name|Inputp
operator|!=
name|NULL
condition|)
return|return
name|YES
return|;
ifdef|#
directive|ifdef
name|BRLUNIX
block|{
specifier|static
name|struct
name|sg_brl
name|gttyBuf
decl_stmt|;
name|gtty
argument_list|(
literal|0
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|gttyBuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|gttyBuf
operator|.
name|sg_xflags
operator|&
name|INWAIT
condition|)
name|some
operator|=
name|YES
expr_stmt|;
block|}
else|#
directive|else
ifdef|#
directive|ifdef
name|FIONREAD
block|{
name|long
name|c
decl_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
literal|0
argument_list|,
name|FIONREAD
argument_list|,
operator|(
name|UnivPtr
operator|)
operator|&
name|c
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|c
operator|=
literal|0
expr_stmt|;
name|some
operator|=
operator|(
name|c
operator|>
literal|0
operator|)
expr_stmt|;
block|}
else|#
directive|else
ifdef|#
directive|ifdef
name|NONBLOCKINGREAD
name|setblock
argument_list|(
literal|0
argument_list|,
name|OFF
argument_list|)
expr_stmt|;
comment|/* turn blocking off */
name|nchars
operator|=
name|read
argument_list|(
literal|0
argument_list|,
operator|(
name|UnivPtr
operator|)
name|smbuf
argument_list|,
sizeof|sizeof
name|smbuf
argument_list|)
expr_stmt|;
comment|/* Is anything there? */
name|setblock
argument_list|(
literal|0
argument_list|,
name|ON
argument_list|)
expr_stmt|;
comment|/* turn blocking on */
if|if
condition|(
name|nchars
operator|>
literal|0
condition|)
comment|/* something was there */
name|bp
operator|=
name|smbuf
expr_stmt|;
comment|/* make sure bp points to it */
name|some
operator|=
operator|(
name|nchars
operator|>
literal|0
operator|)
expr_stmt|;
comment|/* just say we found something */
else|#
directive|else
ifdef|#
directive|ifdef
name|c70
name|some
operator|=
operator|!
name|empty
argument_list|(
literal|0
argument_list|)
expr_stmt|;
else|#
directive|else
ifdef|#
directive|ifdef
name|MSDOS
name|some
operator|=
name|rawkey_ready
argument_list|()
expr_stmt|;
else|#
directive|else
ifdef|#
directive|ifdef
name|MAC
name|some
operator|=
name|rawchkc
argument_list|()
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
endif|#
directive|endif
endif|#
directive|endif
endif|#
directive|endif
endif|#
directive|endif
return|return
name|some
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|BIFF
end_ifdef

begin_decl_stmt
name|private
name|void
name|biff_init
name|proto
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|TERMCAP
end_ifdef

begin_function
name|private
name|void
name|ResetTerm
parameter_list|()
block|{
name|do_sgtty
argument_list|()
expr_stmt|;
comment|/* this is so if you change baudrate or stuff 				   like that, JOVE will notice. */
name|ttyset
argument_list|(
name|ON
argument_list|)
expr_stmt|;
name|putpad
argument_list|(
name|TI
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|putpad
argument_list|(
name|VS
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|putpad
argument_list|(
name|KS
argument_list|,
literal|1
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|UNIX
operator|(
name|void
operator|)
name|chkmail
argument_list|(
name|YES
argument_list|)
expr_stmt|;
comment|/* force it to check to we can be accurate */
endif|#
directive|endif
ifdef|#
directive|ifdef
name|BIFF
if|if
condition|(
name|BiffChk
operator|!=
name|dw_biff
condition|)
name|biff_init
argument_list|()
expr_stmt|;
comment|/* just in case we changed our minds about whether to deal with 	   biff */
endif|#
directive|endif
block|}
end_function

begin_function
name|private
name|void
name|UnsetTerm
parameter_list|(
name|mesg
parameter_list|)
name|char
modifier|*
name|mesg
decl_stmt|;
block|{
name|ttyset
argument_list|(
name|OFF
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ID_CHAR
name|INSmode
argument_list|(
name|NO
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|putpad
argument_list|(
name|KE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|putpad
argument_list|(
name|VE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|Placur
argument_list|(
name|ILI
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|putpad
argument_list|(
name|CE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|TE
condition|)
name|putpad
argument_list|(
name|TE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|mesg
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
name|writef
argument_list|(
literal|"%s\n"
argument_list|,
name|mesg
argument_list|)
expr_stmt|;
name|flushscreen
argument_list|()
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* TERMCAP */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|JOB_CONTROL
end_ifdef

begin_function
name|void
name|PauseJove
parameter_list|()
block|{
name|UnsetTerm
argument_list|(
name|ModBufs
argument_list|(
name|NO
argument_list|)
condition|?
literal|"[There are modified buffers]"
else|:
name|NullStr
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|kill
argument_list|(
literal|0
argument_list|,
name|SIGTSTP
argument_list|)
expr_stmt|;
name|ResetTerm
argument_list|()
expr_stmt|;
name|ClAndRedraw
argument_list|()
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|MAC
end_ifndef

begin_function
name|void
name|jcloseall
parameter_list|()
block|{
name|tmpclose
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|UNIX
name|recclose
argument_list|()
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|LOAD_AV
name|closekmem
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* LOAD_AV */
block|}
end_function

begin_function
name|void
name|Push
parameter_list|()
block|{
ifndef|#
directive|ifndef
name|MSDOS
name|int
name|pid
decl_stmt|;
name|SIGRESULT
argument_list|(
argument|*old_quit
argument_list|)
name|ptrproto
argument_list|(
operator|(
name|int
operator|)
argument_list|)
operator|=
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* !MSDOS */
name|SIGRESULT
argument_list|(
argument|*old_int
argument_list|)
name|ptrproto
argument_list|(
operator|(
name|int
operator|)
argument_list|)
operator|=
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PIPEPROCS
name|int
name|started
decl_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|MSDOS
ifdef|#
directive|ifdef
name|IPROCS
name|SigHold
argument_list|(
name|SIGCHLD
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|WINRESIZE
name|SigHold
argument_list|(
name|SIGWINCH
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|alarm
argument_list|(
operator|(
name|unsigned
operator|)
literal|0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PIPEPROCS
name|started
operator|=
name|kbd_stop
argument_list|()
expr_stmt|;
endif|#
directive|endif
switch|switch
condition|(
name|pid
operator|=
name|fork
argument_list|()
condition|)
block|{
case|case
operator|-
literal|1
case|:
ifdef|#
directive|ifdef
name|PIPEPROCS
if|if
condition|(
name|started
condition|)
operator|(
name|void
operator|)
name|kbd_strt
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|complain
argument_list|(
literal|"[Fork failed: %s]"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
case|case
literal|0
case|:
name|UnsetTerm
argument_list|(
name|ModBufs
argument_list|(
name|NO
argument_list|)
condition|?
literal|"[There are modified buffers]"
else|:
name|NullStr
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|WINRESIZE
name|SigRelse
argument_list|(
name|SIGWINCH
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|IPROCS
name|SigRelse
argument_list|(
name|SIGCHLD
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGTERM
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* MSDOS */
name|UnsetTerm
argument_list|(
name|ModBufs
argument_list|(
name|NO
argument_list|)
condition|?
literal|"[There are modified buffers]"
else|:
name|NullStr
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* MSDOS */
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|UNIX
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
name|jcloseall
argument_list|()
expr_stmt|;
comment|/* note that curbuf->bfname may be NULL */
name|execl
argument_list|(
name|Shell
argument_list|,
name|basename
argument_list|(
name|Shell
argument_list|)
argument_list|,
literal|"-is"
argument_list|,
name|pr_name
argument_list|(
name|curbuf
operator|->
name|b_fname
argument_list|,
name|NO
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|raw_complain
argument_list|(
literal|"[Execl failed: %s]"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|_exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|IPROCS
name|SigRelse
argument_list|(
name|SIGCHLD
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|dowait
argument_list|(
name|pid
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* UNIX */
ifdef|#
directive|ifdef
name|MSDOS
name|break_rst
argument_list|()
expr_stmt|;
if|if
condition|(
name|spawnl
argument_list|(
literal|0
argument_list|,
name|Shell
argument_list|,
name|basename
argument_list|(
name|Shell
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|message
argument_list|(
literal|"[Spawn failed]"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* MSDOS */
ifndef|#
directive|ifndef
name|MAC
name|ResetTerm
argument_list|()
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|WINRESIZE
name|SigRelse
argument_list|(
name|SIGWINCH
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ClAndRedraw
argument_list|()
expr_stmt|;
ifndef|#
directive|ifndef
name|MSDOS
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|old_quit
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* MSDOS */
name|break_off
argument_list|()
expr_stmt|;
name|getCWD
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* MSDOS */
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|old_int
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|UNIX
if|if
condition|(
name|UpdFreq
operator|!=
literal|0
condition|)
operator|(
name|void
operator|)
name|alarm
argument_list|(
call|(
name|unsigned
call|)
argument_list|(
name|UpdFreq
operator|-
operator|(
name|time
argument_list|(
operator|(
name|time_t
operator|*
operator|)
name|NULL
argument_list|)
operator|%
name|UpdFreq
operator|)
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PIPEPROCS
if|if
condition|(
name|started
condition|)
operator|(
name|void
operator|)
name|kbd_strt
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* MAC */
end_comment

begin_decl_stmt
name|bool
name|OKXonXoff
init|=
name|OFF
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ^S and ^Q initially DON'T work */
end_comment

begin_decl_stmt
name|int
name|IntChar
init|=
name|CTL
argument_list|(
literal|']'
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
name|private
name|void
name|ttsize
parameter_list|()
block|{
ifdef|#
directive|ifdef
name|UNIX
ifdef|#
directive|ifdef
name|TIOCGWINSZ
name|struct
name|winsize
name|win
decl_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
literal|0
argument_list|,
name|TIOCGWINSZ
argument_list|,
operator|(
name|UnivPtr
operator|)
operator|&
name|win
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|win
operator|.
name|ws_col
condition|)
name|CO
operator|=
name|win
operator|.
name|ws_col
expr_stmt|;
if|if
condition|(
name|win
operator|.
name|ws_row
condition|)
name|LI
operator|=
name|win
operator|.
name|ws_row
expr_stmt|;
block|}
else|#
directive|else
comment|/* !TIOCGWINSZ */
ifdef|#
directive|ifdef
name|BTL_BLIT
include|#
directive|include
file|<sys/jioctl.h>
name|struct
name|jwinsize
name|jwin
decl_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
literal|0
argument_list|,
name|JWINSIZE
argument_list|,
operator|&
name|jwin
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|jwin
operator|.
name|bytesx
condition|)
name|CO
operator|=
name|jwin
operator|.
name|bytesx
expr_stmt|;
if|if
condition|(
name|jwin
operator|.
name|bytesy
condition|)
name|LI
operator|=
name|jwin
operator|.
name|bytesy
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* BTL_BLIT */
endif|#
directive|endif
comment|/* !TIOCGWINSZ */
endif|#
directive|endif
comment|/* UNIX */
ifdef|#
directive|ifdef
name|MAC
name|CO
operator|=
name|getCO
argument_list|()
expr_stmt|;
comment|/* see mac.c */
name|LI
operator|=
name|getLI
argument_list|()
expr_stmt|;
name|Windchange
operator|=
name|YES
expr_stmt|;
name|clr_page
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|ILI
operator|=
name|LI
operator|-
literal|1
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|BIFF
end_ifdef

begin_function
name|private
name|void
name|biff_init
parameter_list|()
block|{
name|dw_biff
operator|=
operator|(
operator|(
name|BiffChk
operator|)
operator|&&
ifndef|#
directive|ifndef
name|BSD4_2
operator|(
operator|(
name|tt_name
operator|!=
name|NULL
operator|)
operator|||
operator|(
name|tt_name
operator|=
name|ttyname
argument_list|(
literal|0
argument_list|)
operator|)
operator|)
operator|&&
operator|(
name|stat
argument_list|(
name|tt_name
argument_list|,
operator|&
name|tt_stat
argument_list|)
operator|!=
operator|-
literal|1
operator|)
operator|&&
else|#
directive|else
operator|(
name|fstat
argument_list|(
literal|0
argument_list|,
operator|&
name|tt_stat
argument_list|)
operator|!=
operator|-
literal|1
operator|)
operator|&&
endif|#
directive|endif
operator|(
name|tt_stat
operator|.
name|st_mode
operator|&
name|S_IEXEC
operator|)
operator|)
expr_stmt|;
comment|/* he's using biff */
block|}
end_function

begin_function
name|private
name|void
name|biff
parameter_list|(
name|on
parameter_list|)
name|int
name|on
decl_stmt|;
block|{
if|if
condition|(
name|dw_biff
operator|==
name|NO
condition|)
return|return;
ifndef|#
directive|ifndef
name|BSD4_2
operator|(
name|void
operator|)
name|chmod
argument_list|(
name|tt_name
argument_list|,
name|on
condition|?
name|tt_stat
operator|.
name|st_mode
else|:
operator|(
name|tt_stat
operator|.
name|st_mode
operator|&
operator|~
name|S_IEXEC
operator|)
argument_list|)
expr_stmt|;
else|#
directive|else
operator|(
name|void
operator|)
name|fchmod
argument_list|(
literal|0
argument_list|,
name|on
condition|?
name|tt_stat
operator|.
name|st_mode
else|:
operator|(
name|tt_stat
operator|.
name|st_mode
operator|&
operator|~
name|S_IEXEC
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* BIFF */
end_comment

begin_function
name|private
name|void
name|ttinit
parameter_list|()
block|{
ifdef|#
directive|ifdef
name|BIFF
name|biff_init
argument_list|()
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|TIOCSLTC
operator|(
name|void
operator|)
name|ioctl
argument_list|(
literal|0
argument_list|,
name|TIOCGLTC
argument_list|,
operator|(
name|UnivPtr
operator|)
operator|&
name|ls
index|[
name|OFF
index|]
argument_list|)
expr_stmt|;
name|ls
index|[
name|ON
index|]
operator|=
name|ls
index|[
name|OFF
index|]
expr_stmt|;
name|ls
index|[
name|ON
index|]
operator|.
name|t_suspc
operator|=
operator|(
name|char
operator|)
operator|-
literal|1
expr_stmt|;
name|ls
index|[
name|ON
index|]
operator|.
name|t_dsuspc
operator|=
operator|(
name|char
operator|)
operator|-
literal|1
expr_stmt|;
name|ls
index|[
name|ON
index|]
operator|.
name|t_flushc
operator|=
operator|(
name|char
operator|)
operator|-
literal|1
expr_stmt|;
name|ls
index|[
name|ON
index|]
operator|.
name|t_lnextc
operator|=
operator|(
name|char
operator|)
operator|-
literal|1
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|TIOCGETC
comment|/* Change interupt and quit. */
operator|(
name|void
operator|)
name|ioctl
argument_list|(
literal|0
argument_list|,
name|TIOCGETC
argument_list|,
operator|(
name|UnivPtr
operator|)
operator|&
name|tc
index|[
name|OFF
index|]
argument_list|)
expr_stmt|;
name|tc
index|[
name|ON
index|]
operator|=
name|tc
index|[
name|OFF
index|]
expr_stmt|;
name|tc
index|[
name|ON
index|]
operator|.
name|t_intrc
operator|=
name|IntChar
expr_stmt|;
name|tc
index|[
name|ON
index|]
operator|.
name|t_quitc
operator|=
operator|(
name|char
operator|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|OKXonXoff
condition|)
block|{
name|tc
index|[
name|ON
index|]
operator|.
name|t_stopc
operator|=
operator|(
name|char
operator|)
operator|-
literal|1
expr_stmt|;
name|tc
index|[
name|ON
index|]
operator|.
name|t_startc
operator|=
operator|(
name|char
operator|)
operator|-
literal|1
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* TIOCGETC */
name|do_sgtty
argument_list|()
expr_stmt|;
block|}
end_function

begin_decl_stmt
name|private
name|int
name|done_ttinit
init|=
name|NO
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|MSDOS
end_ifndef

begin_function
name|private
endif|#
directive|endif
name|void
name|do_sgtty
parameter_list|()
block|{
ifdef|#
directive|ifdef
name|UNIX
ifdef|#
directive|ifdef
name|TERMIO
operator|(
name|void
operator|)
name|ioctl
argument_list|(
literal|0
argument_list|,
name|TCGETA
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|sg
index|[
name|OFF
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|TERMIOS
operator|(
name|void
operator|)
name|tcgetattr
argument_list|(
literal|0
argument_list|,
operator|&
name|sg
index|[
name|OFF
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SGTTY
operator|(
name|void
operator|)
name|gtty
argument_list|(
literal|0
argument_list|,
operator|&
name|sg
index|[
name|OFF
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* SYSV */
name|sg
index|[
name|ON
index|]
operator|=
name|sg
index|[
name|OFF
index|]
expr_stmt|;
ifdef|#
directive|ifdef
name|LPASS8
operator|(
name|void
operator|)
name|ioctl
argument_list|(
literal|0
argument_list|,
name|TIOCLGET
argument_list|,
operator|(
name|UnivPtr
operator|)
operator|&
name|lmword
index|[
name|OFF
index|]
argument_list|)
expr_stmt|;
name|lmword
index|[
name|ON
index|]
operator|=
name|lmword
index|[
name|OFF
index|]
expr_stmt|;
if|if
condition|(
name|MetaKey
condition|)
name|lmword
index|[
name|ON
index|]
operator||=
name|LPASS8
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|LTILDE
if|if
condition|(
name|Hazeltine
condition|)
name|lmword
index|[
name|ON
index|]
operator|&=
operator|~
name|LTILDE
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|TERMIO
argument_list|)
operator|||
name|defined
argument_list|(
name|TERMIOS
argument_list|)
ifdef|#
directive|ifdef
name|TAB3
name|TABS
operator|=
operator|!
operator|(
operator|(
name|sg
index|[
name|OFF
index|]
operator|.
name|c_oflag
operator|&
name|TAB3
operator|)
operator|==
name|TAB3
operator|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|CBAUD
name|ospeed
operator|=
name|sg
index|[
name|OFF
index|]
operator|.
name|c_cflag
operator|&
name|CBAUD
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|OKXonXoff
condition|)
name|sg
index|[
name|ON
index|]
operator|.
name|c_iflag
operator|&=
operator|~
operator|(
name|IXON
operator||
name|IXOFF
operator|)
expr_stmt|;
name|sg
index|[
name|ON
index|]
operator|.
name|c_iflag
operator|&=
operator|~
operator|(
name|INLCR
operator||
name|ICRNL
operator||
name|IGNCR
operator||
name|ISTRIP
operator|)
expr_stmt|;
comment|/* sg[ON].c_lflag&= ~(ICANON|ECHO); */
name|sg
index|[
name|ON
index|]
operator|.
name|c_cflag
operator|&=
operator|~
operator|(
name|CSIZE
operator||
name|PARENB
operator|)
expr_stmt|;
name|sg
index|[
name|ON
index|]
operator|.
name|c_cflag
operator||=
name|CS8
expr_stmt|;
name|sg
index|[
name|ON
index|]
operator|.
name|c_lflag
operator|&=
operator|~
operator|(
name|ISIG
operator||
name|ICANON
operator||
name|ECHO
operator||
name|IEXTEN
operator|)
expr_stmt|;
ifndef|#
directive|ifndef
name|OCRNL
define|#
directive|define
name|OCRNL
value|0
endif|#
directive|endif
name|sg
index|[
name|ON
index|]
operator|.
name|c_oflag
operator|&=
operator|~
operator|(
name|OCRNL
operator||
name|ONLCR
operator|)
expr_stmt|;
ifdef|#
directive|ifdef
name|_POSIX_VDISABLE
comment|/* The following characters cause signals in System Vr4. 	 * We should perhaps handle them; for now, we suppress them. 	 */
name|sg
index|[
name|ON
index|]
operator|.
name|c_cc
index|[
name|VQUIT
index|]
operator|=
name|_POSIX_VDISABLE
expr_stmt|;
ifdef|#
directive|ifdef
name|VSWTCH
name|sg
index|[
name|ON
index|]
operator|.
name|c_cc
index|[
name|VSWTCH
index|]
operator|=
name|_POSIX_VDISABLE
expr_stmt|;
endif|#
directive|endif
name|sg
index|[
name|ON
index|]
operator|.
name|c_cc
index|[
name|VSUSP
index|]
operator|=
name|_POSIX_VDISABLE
expr_stmt|;
name|sg
index|[
name|ON
index|]
operator|.
name|c_cc
index|[
name|VDSUSP
index|]
operator|=
name|_POSIX_VDISABLE
expr_stmt|;
else|#
directive|else
name|sg
index|[
name|ON
index|]
operator|.
name|c_cc
index|[
name|VINTR
index|]
operator|=
name|IntChar
expr_stmt|;
name|sg
index|[
name|ON
index|]
operator|.
name|c_cc
index|[
name|VQUIT
index|]
operator|=
operator|(
name|char
operator|)
operator|-
literal|1
expr_stmt|;
endif|#
directive|endif
comment|/* _POSIX_VDISABLE */
name|sg
index|[
name|ON
index|]
operator|.
name|c_cc
index|[
name|VMIN
index|]
operator|=
literal|1
expr_stmt|;
name|sg
index|[
name|ON
index|]
operator|.
name|c_cc
index|[
name|VTIME
index|]
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
comment|/* TERMIO || TERMIOS */
if|#
directive|if
name|defined
argument_list|(
name|SGTTY
argument_list|)
operator|||
name|defined
argument_list|(
name|BRLUNIX
argument_list|)
name|TABS
operator|=
operator|!
operator|(
name|sg
index|[
name|OFF
index|]
operator|.
name|sg_flags
operator|&
name|XTABS
operator|)
expr_stmt|;
name|sg
index|[
name|ON
index|]
operator|.
name|sg_flags
operator|&=
operator|~
name|XTABS
expr_stmt|;
name|ospeed
operator|=
name|sg
index|[
name|OFF
index|]
operator|.
name|sg_ospeed
expr_stmt|;
ifdef|#
directive|ifdef
name|BRLUNIX
name|sg
index|[
name|ON
index|]
operator|.
name|sg_flags
operator|&=
operator|~
operator|(
name|ECHO
operator||
name|CRMOD
operator|)
expr_stmt|;
name|sg
index|[
name|ON
index|]
operator|.
name|sg_flags
operator||=
name|CBREAK
expr_stmt|;
comment|/* VT100 Kludge: leave STALL on for flow control if DC3DC1 (Yuck.) */
name|sg
index|[
name|ON
index|]
operator|.
name|sg_xflags
operator|&=
operator|~
operator|(
operator|(
name|sg
index|[
name|ON
index|]
operator|.
name|sg_xflags
operator|&
name|DC3DC1
condition|?
literal|0
else|:
name|STALL
operator|)
operator||
name|PAGE
operator|)
expr_stmt|;
else|#
directive|else
name|sg
index|[
name|ON
index|]
operator|.
name|sg_flags
operator|&=
operator|~
operator|(
name|ECHO
operator||
name|CRMOD
operator|)
expr_stmt|;
endif|#
directive|endif
comment|/* BRLUNIX */
ifdef|#
directive|ifdef
name|LPASS8
name|sg
index|[
name|ON
index|]
operator|.
name|sg_flags
operator||=
name|CBREAK
expr_stmt|;
else|#
directive|else
name|sg
index|[
name|ON
index|]
operator|.
name|sg_flags
operator||=
operator|(
name|MetaKey
condition|?
name|RAW
else|:
name|CBREAK
operator|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
comment|/* SGTTY */
endif|#
directive|endif
comment|/* UNIX */
ifdef|#
directive|ifdef
name|MSDOS
ifndef|#
directive|ifndef
name|IBMPC
name|setmode
argument_list|(
literal|1
argument_list|,
literal|0x8000
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* IBMPC */
name|TABS
operator|=
name|NO
expr_stmt|;
endif|#
directive|endif
comment|/* MSDOS */
block|}
end_function

begin_function
name|void
name|tty_reset
parameter_list|()
block|{
if|if
condition|(
operator|!
name|done_ttinit
condition|)
return|return;
name|ttyset
argument_list|(
name|OFF
argument_list|)
expr_stmt|;
comment|/* go back to original modes */
name|ttinit
argument_list|()
expr_stmt|;
name|ttyset
argument_list|(
name|ON
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* If n is OFF reset to original modes */
end_comment

begin_function
name|void
name|ttyset
parameter_list|(
name|n
parameter_list|)
name|bool
name|n
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|done_ttinit
operator|&&
operator|!
name|n
condition|)
comment|/* Try to reset before we've set! */
return|return;
ifdef|#
directive|ifdef
name|UNIX
ifdef|#
directive|ifdef
name|TERMIO
operator|(
name|void
operator|)
name|ioctl
argument_list|(
literal|0
argument_list|,
name|TCSETAW
argument_list|,
operator|(
name|UnivPtr
operator|)
operator|&
name|sg
index|[
name|n
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* TERMIO */
ifdef|#
directive|ifdef
name|TERMIOS
operator|(
name|void
operator|)
name|tcsetattr
argument_list|(
literal|0
argument_list|,
name|TCSADRAIN
argument_list|,
operator|&
name|sg
index|[
name|n
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* TERMIOS */
ifdef|#
directive|ifdef
name|SGTTY
ifdef|#
directive|ifdef
name|TIOCSETN
operator|(
name|void
operator|)
name|ioctl
argument_list|(
literal|0
argument_list|,
name|TIOCSETN
argument_list|,
operator|(
name|UnivPtr
operator|)
operator|&
name|sg
index|[
name|n
index|]
argument_list|)
expr_stmt|;
else|#
directive|else
operator|(
name|void
operator|)
name|stty
argument_list|(
literal|0
argument_list|,
operator|&
name|sg
index|[
name|n
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
ifdef|#
directive|ifdef
name|TIOCGETC
operator|(
name|void
operator|)
name|ioctl
argument_list|(
literal|0
argument_list|,
name|TIOCSETC
argument_list|,
operator|(
name|UnivPtr
operator|)
operator|&
name|tc
index|[
name|n
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* TIOCSETC */
ifdef|#
directive|ifdef
name|TIOCSLTC
operator|(
name|void
operator|)
name|ioctl
argument_list|(
literal|0
argument_list|,
name|TIOCSLTC
argument_list|,
operator|(
name|UnivPtr
operator|)
operator|&
name|ls
index|[
name|n
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* TIOCSLTC */
ifdef|#
directive|ifdef
name|LPASS8
operator|(
name|void
operator|)
name|ioctl
argument_list|(
literal|0
argument_list|,
name|TIOCLSET
argument_list|,
operator|(
name|UnivPtr
operator|)
operator|&
name|lmword
index|[
name|n
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
comment|/* UNIX */
ifdef|#
directive|ifdef
name|MSDOS
ifndef|#
directive|ifndef
name|IBMPC
name|setmode
argument_list|(
literal|1
argument_list|,
name|n
condition|?
literal|0x8000
else|:
literal|0x4000
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
comment|/* MSDOS */
name|done_ttinit
operator|=
name|YES
expr_stmt|;
ifdef|#
directive|ifdef
name|BIFF
name|biff
argument_list|(
operator|!
name|n
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_decl_stmt
name|int
name|this_cmd
decl_stmt|,
name|last_cmd
decl_stmt|,
name|LastKeyStruck
decl_stmt|,
name|MetaKey
init|=
name|OFF
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|getch
parameter_list|()
block|{
specifier|register
name|int
name|c
decl_stmt|,
name|peekc
decl_stmt|;
if|if
condition|(
name|Inputp
condition|)
block|{
if|if
condition|(
operator|(
name|c
operator|=
operator|*
name|Inputp
operator|++
operator|)
operator|!=
literal|'\0'
condition|)
return|return
name|LastKeyStruck
operator|=
name|c
return|;
name|Inputp
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|InJoverc
condition|)
return|return
name|EOF
return|;
comment|/* somethings wrong if Inputp runs out while 				   we're reading a .joverc file. */
ifndef|#
directive|ifndef
name|MSDOS
if|if
condition|(
name|ModCount
operator|>=
name|SyncFreq
condition|)
block|{
name|ModCount
operator|=
literal|0
expr_stmt|;
name|SyncRec
argument_list|()
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* MSDOS */
comment|/* If there are no ungetc'd characters, 	   AND we're interactive or we're not executing a macro, 	   we read from the terminal (i.e., jgetchar()). 	   Note: characters only get put in macros from inside this if. */
if|if
condition|(
operator|(
operator|(
name|peekc
operator|=
name|c
operator|=
name|Peekc
argument_list|()
operator|)
operator|==
name|EOF
operator|)
operator|&&
operator|(
name|Interactive
operator|||
operator|(
operator|(
name|c
operator|=
name|mac_getc
argument_list|()
operator|)
operator|==
name|EOF
operator|)
operator|)
condition|)
block|{
comment|/* So messages that aren't error messages don't 		 * hang around forever. 		 * Note: this code is duplicated in SitFor()! 		 */
if|if
condition|(
operator|!
name|UpdMesg
operator|&&
operator|!
name|Asking
operator|&&
name|mesgbuf
index|[
literal|0
index|]
operator|!=
literal|'\0'
operator|&&
operator|!
name|errormsg
condition|)
name|message
argument_list|(
name|NullStr
argument_list|)
expr_stmt|;
name|redisplay
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|UNIX
name|inIOread
operator|=
name|YES
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|c
operator|=
name|jgetchar
argument_list|()
operator|)
operator|==
name|EOF
condition|)
name|finish
argument_list|(
name|SIGHUP
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|UNIX
name|inIOread
operator|=
name|NO
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|Interactive
operator|&&
name|InMacDefine
condition|)
name|mac_putc
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|peekc
operator|==
name|EOF
condition|)
comment|/* don't add_stroke peekc's */
name|add_stroke
argument_list|(
name|c
argument_list|)
expr_stmt|;
return|return
name|LastKeyStruck
operator|=
name|c
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|UNIX
end_ifdef

begin_function
name|private
name|void
name|dorecover
parameter_list|()
block|{
comment|/* Since recover is a normal cooked mode program, reset the terminal */
name|UnsetTerm
argument_list|(
name|NullStr
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PIPEPROCS
name|kbd_kill
argument_list|()
expr_stmt|;
comment|/* kill the keyboard process */
endif|#
directive|endif
name|execl
argument_list|(
name|Recover
argument_list|,
literal|"recover"
argument_list|,
literal|"-d"
argument_list|,
name|TmpFilePath
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|writef
argument_list|(
literal|"%s: execl failed! %s\n"
argument_list|,
name|Recover
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|flushscreen
argument_list|()
expr_stmt|;
name|_exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* UNIX */
end_comment

begin_function
name|void
name|ShowVersion
parameter_list|()
block|{
name|s_mess
argument_list|(
literal|"Jonathan's Own Version of Emacs (%s)"
argument_list|,
name|version
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|private
name|void
name|UNIX_cmdline
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
name|argv
index|[]
decl_stmt|;
block|{
name|int
name|lineno
init|=
literal|0
decl_stmt|,
name|nwinds
init|=
literal|1
decl_stmt|;
name|Buffer
modifier|*
name|b
decl_stmt|;
name|ShowVersion
argument_list|()
expr_stmt|;
while|while
condition|(
name|argc
operator|>
literal|1
condition|)
block|{
if|if
condition|(
name|argv
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|!=
literal|'-'
operator|&&
name|argv
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|!=
literal|'+'
condition|)
block|{
name|bool
name|force
init|=
operator|(
name|nwinds
operator|>
literal|0
operator|||
name|lineno
operator|!=
literal|0
operator|)
decl_stmt|;
ifdef|#
directive|ifdef
name|MSDOS
name|strlwr
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|minib_add
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
name|force
argument_list|)
expr_stmt|;
name|b
operator|=
name|do_find
argument_list|(
name|nwinds
operator|>
literal|0
condition|?
name|curwind
else|:
operator|(
name|Window
operator|*
operator|)
name|NULL
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|,
name|force
argument_list|)
expr_stmt|;
if|if
condition|(
name|force
condition|)
block|{
name|SetABuf
argument_list|(
name|curbuf
argument_list|)
expr_stmt|;
name|SetBuf
argument_list|(
name|b
argument_list|)
expr_stmt|;
if|if
condition|(
name|lineno
operator|>=
literal|0
condition|)
name|SetLine
argument_list|(
name|next_line
argument_list|(
name|curbuf
operator|->
name|b_first
argument_list|,
name|lineno
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|SetLine
argument_list|(
name|curbuf
operator|->
name|b_last
argument_list|)
expr_stmt|;
if|if
condition|(
name|nwinds
operator|>
literal|1
condition|)
name|NextWindow
argument_list|()
expr_stmt|;
if|if
condition|(
name|nwinds
condition|)
name|nwinds
operator|-=
literal|1
expr_stmt|;
block|}
name|lineno
operator|=
literal|0
expr_stmt|;
block|}
else|else
switch|switch
condition|(
name|argv
index|[
literal|1
index|]
index|[
literal|1
index|]
condition|)
block|{
case|case
literal|'d'
case|:
name|argv
operator|+=
literal|1
expr_stmt|;
name|argc
operator|-=
literal|1
expr_stmt|;
break|break;
case|case
literal|'j'
case|:
comment|/* Ignore .joverc in HOME */
break|break;
ifndef|#
directive|ifndef
name|MAC
case|case
literal|'p'
case|:
name|argv
operator|+=
literal|1
expr_stmt|;
name|argc
operator|-=
literal|1
expr_stmt|;
if|if
condition|(
name|argv
index|[
literal|1
index|]
operator|!=
name|NULL
condition|)
block|{
name|SetBuf
argument_list|(
name|do_find
argument_list|(
name|curwind
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|,
name|NO
argument_list|)
argument_list|)
expr_stmt|;
name|ErrParse
argument_list|()
expr_stmt|;
name|nwinds
operator|=
literal|0
expr_stmt|;
block|}
break|break;
endif|#
directive|endif
case|case
literal|'t'
case|:
comment|/* check if syntax is -tTag or -t Tag */
if|if
condition|(
name|argv
index|[
literal|1
index|]
index|[
literal|2
index|]
operator|!=
literal|'\0'
condition|)
block|{
name|find_tag
argument_list|(
operator|&
operator|(
name|argv
index|[
literal|1
index|]
index|[
literal|2
index|]
operator|)
argument_list|,
name|YES
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|argv
operator|+=
literal|1
expr_stmt|;
name|argc
operator|-=
literal|1
expr_stmt|;
if|if
condition|(
name|argv
index|[
literal|1
index|]
operator|!=
name|NULL
condition|)
name|find_tag
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
name|YES
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'w'
case|:
if|if
condition|(
name|argv
index|[
literal|1
index|]
index|[
literal|2
index|]
operator|==
literal|'\0'
condition|)
name|nwinds
operator|+=
literal|1
expr_stmt|;
else|else
block|{
name|int
name|n
decl_stmt|;
operator|(
name|void
operator|)
name|chr_to_int
argument_list|(
operator|&
name|argv
index|[
literal|1
index|]
index|[
literal|2
index|]
argument_list|,
literal|10
argument_list|,
name|NO
argument_list|,
operator|&
name|n
argument_list|)
expr_stmt|;
name|nwinds
operator|+=
operator|-
literal|1
operator|+
name|n
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|div_wind
argument_list|(
name|curwind
argument_list|,
name|nwinds
operator|-
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
operator|(
name|void
operator|)
name|chr_to_int
argument_list|(
operator|&
name|argv
index|[
literal|1
index|]
index|[
literal|1
index|]
argument_list|,
literal|10
argument_list|,
name|NO
argument_list|,
operator|&
name|lineno
argument_list|)
expr_stmt|;
name|lineno
operator|-=
literal|1
expr_stmt|;
break|break;
case|case
literal|'\0'
case|:
name|lineno
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* goto end of file ... */
break|break;
comment|/* just like some people's */
block|}
comment|/* favourite editor */
name|argv
operator|+=
literal|1
expr_stmt|;
name|argc
operator|-=
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|raw_scream
parameter_list|(
name|m
parameter_list|)
specifier|const
name|char
modifier|*
name|m
decl_stmt|;
block|{
name|write
argument_list|(
literal|2
argument_list|,
operator|(
name|UnivConstPtr
operator|)
name|m
argument_list|,
name|strlen
argument_list|(
name|m
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|STDARGS
end_ifdef

begin_decl_stmt
name|void
name|error
argument_list|(
specifier|const
name|char
operator|*
name|fmt
argument_list|,
operator|...
argument_list|)
else|#
directive|else
comment|/*VARARGS1*/
name|void
name|error
argument_list|(
name|fmt
argument_list|,
name|va_alist
argument_list|)
decl|const
name|char
modifier|*
name|fmt
decl_stmt|;
end_decl_stmt

begin_macro
name|va_dcl
end_macro

begin_endif
endif|#
directive|endif
end_endif

begin_block
block|{
name|va_list
name|ap
decl_stmt|;
if|if
condition|(
name|fmt
condition|)
block|{
name|va_init
argument_list|(
name|ap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|format
argument_list|(
name|mesgbuf
argument_list|,
sizeof|sizeof
name|mesgbuf
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|UpdMesg
operator|=
name|YES
expr_stmt|;
block|}
name|rbell
argument_list|()
expr_stmt|;
name|longjmp
argument_list|(
name|mainjmp
argument_list|,
name|ERROR
argument_list|)
expr_stmt|;
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|STDARGS
end_ifdef

begin_decl_stmt
name|void
name|complain
argument_list|(
specifier|const
name|char
operator|*
name|fmt
argument_list|,
operator|...
argument_list|)
else|#
directive|else
comment|/*VARARGS1*/
name|void
name|complain
argument_list|(
name|fmt
argument_list|,
name|va_alist
argument_list|)
decl|const
name|char
modifier|*
name|fmt
decl_stmt|;
end_decl_stmt

begin_macro
name|va_dcl
end_macro

begin_endif
endif|#
directive|endif
end_endif

begin_block
block|{
name|va_list
name|ap
decl_stmt|;
if|if
condition|(
name|fmt
condition|)
block|{
name|va_init
argument_list|(
name|ap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|format
argument_list|(
name|mesgbuf
argument_list|,
sizeof|sizeof
name|mesgbuf
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|UpdMesg
operator|=
name|YES
expr_stmt|;
block|}
name|rbell
argument_list|()
expr_stmt|;
name|longjmp
argument_list|(
name|mainjmp
argument_list|,
name|COMPLAIN
argument_list|)
expr_stmt|;
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|STDARGS
end_ifdef

begin_decl_stmt
name|void
name|raw_complain
argument_list|(
specifier|const
name|char
operator|*
name|fmt
argument_list|,
operator|...
argument_list|)
else|#
directive|else
comment|/*VARARGS1*/
name|void
name|raw_complain
argument_list|(
name|fmt
argument_list|,
name|va_alist
argument_list|)
decl|const
name|char
modifier|*
name|fmt
decl_stmt|;
end_decl_stmt

begin_macro
name|va_dcl
end_macro

begin_endif
endif|#
directive|endif
end_endif

begin_block
block|{
name|va_list
name|ap
decl_stmt|;
if|if
condition|(
name|fmt
condition|)
block|{
name|va_init
argument_list|(
name|ap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|format
argument_list|(
name|mesgbuf
argument_list|,
sizeof|sizeof
name|mesgbuf
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|raw_scream
argument_list|(
name|mesgbuf
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|STDARGS
end_ifdef

begin_decl_stmt
name|void
name|confirm
argument_list|(
specifier|const
name|char
operator|*
name|fmt
argument_list|,
operator|...
argument_list|)
else|#
directive|else
comment|/*VARARGS1*/
name|void
name|confirm
argument_list|(
name|fmt
argument_list|,
name|va_alist
argument_list|)
decl|const
name|char
modifier|*
name|fmt
decl_stmt|;
end_decl_stmt

begin_macro
name|va_dcl
end_macro

begin_endif
endif|#
directive|endif
end_endif

begin_block
block|{
name|char
modifier|*
name|yorn
decl_stmt|;
name|va_list
name|ap
decl_stmt|;
name|va_init
argument_list|(
name|ap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|format
argument_list|(
name|mesgbuf
argument_list|,
sizeof|sizeof
name|mesgbuf
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|yorn
operator|=
name|ask
argument_list|(
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|mesgbuf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|yorn
operator|!=
literal|'Y'
operator|&&
operator|*
name|yorn
operator|!=
literal|'y'
condition|)
name|longjmp
argument_list|(
name|mainjmp
argument_list|,
name|COMPLAIN
argument_list|)
expr_stmt|;
block|}
end_block

begin_decl_stmt
name|int
name|RecDepth
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|Recur
parameter_list|()
block|{
name|char
name|bname
index|[
literal|128
index|]
decl_stmt|;
name|Mark
modifier|*
name|m
decl_stmt|;
name|swritef
argument_list|(
name|bname
argument_list|,
sizeof|sizeof
argument_list|(
name|bname
argument_list|)
argument_list|,
literal|"%s"
argument_list|,
name|curbuf
operator|->
name|b_name
argument_list|)
expr_stmt|;
name|m
operator|=
name|MakeMark
argument_list|(
name|curline
argument_list|,
name|curchar
argument_list|,
name|M_FLOATER
argument_list|)
expr_stmt|;
name|RecDepth
operator|+=
literal|1
expr_stmt|;
name|UpdModLine
operator|=
name|YES
expr_stmt|;
name|DoKeys
argument_list|(
name|NO
argument_list|)
expr_stmt|;
comment|/* NO means not first time */
name|UpdModLine
operator|=
name|YES
expr_stmt|;
name|RecDepth
operator|-=
literal|1
expr_stmt|;
name|SetBuf
argument_list|(
name|do_select
argument_list|(
name|curwind
argument_list|,
name|bname
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|is_an_arg
argument_list|()
condition|)
name|ToMark
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|DelMark
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|MAC
end_ifdef

begin_decl_stmt
name|jmp_buf
name|auxjmp
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|private
name|int
name|iniargc
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* main sets these for DoKeys() */
end_comment

begin_decl_stmt
name|private
name|char
modifier|*
modifier|*
name|iniargv
decl_stmt|;
end_decl_stmt

begin_function
name|private
name|void
name|DoKeys
parameter_list|(
name|firsttime
parameter_list|)
name|bool
name|firsttime
decl_stmt|;
block|{
name|int
name|c
decl_stmt|;
name|jmp_buf
name|savejmp
decl_stmt|;
name|push_env
argument_list|(
name|savejmp
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|setjmp
argument_list|(
name|mainjmp
argument_list|)
condition|)
block|{
case|case
literal|0
case|:
if|if
condition|(
name|firsttime
condition|)
name|UNIX_cmdline
argument_list|(
name|iniargc
argument_list|,
name|iniargv
argument_list|)
expr_stmt|;
break|break;
case|case
name|QUIT
case|:
if|if
condition|(
name|RecDepth
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|ModMacs
argument_list|()
condition|)
block|{
name|rbell
argument_list|()
expr_stmt|;
if|if
condition|(
name|CharUpcase
argument_list|(
operator|*
name|ask
argument_list|(
literal|"No"
argument_list|,
literal|"Some MACROS haven't been saved; leave anyway? "
argument_list|)
argument_list|)
operator|!=
literal|'Y'
condition|)
break|break;
block|}
if|if
condition|(
name|ModBufs
argument_list|(
name|NO
argument_list|)
condition|)
block|{
name|rbell
argument_list|()
expr_stmt|;
if|if
condition|(
name|CharUpcase
argument_list|(
operator|*
name|ask
argument_list|(
literal|"No"
argument_list|,
literal|"Some buffers haven't been saved; leave anyway? "
argument_list|)
argument_list|)
operator|!=
literal|'Y'
condition|)
break|break;
block|}
ifdef|#
directive|ifdef
name|IPROCS
name|KillProcs
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
name|pop_env
argument_list|(
name|savejmp
argument_list|)
expr_stmt|;
return|return;
case|case
name|ERROR
case|:
name|getDOT
argument_list|()
expr_stmt|;
comment|/* God knows what state linebuf was in */
comment|/*FALLTHROUGH*/
case|case
name|COMPLAIN
case|:
block|{
name|gc_openfiles
argument_list|()
expr_stmt|;
comment|/* close any files we left open */
name|errormsg
operator|=
name|YES
expr_stmt|;
name|unwind_macro_stack
argument_list|()
expr_stmt|;
name|Asking
operator|=
name|NO
expr_stmt|;
name|curwind
operator|->
name|w_bufp
operator|=
name|curbuf
expr_stmt|;
name|DisabledRedisplay
operator|=
name|NO
expr_stmt|;
name|redisplay
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
name|this_cmd
operator|=
name|last_cmd
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
ifdef|#
directive|ifdef
name|MAC
name|setjmp
argument_list|(
name|auxjmp
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|this_cmd
operator|!=
name|ARG_CMD
condition|)
block|{
name|clr_arg_value
argument_list|()
expr_stmt|;
name|last_cmd
operator|=
name|this_cmd
expr_stmt|;
name|init_strokes
argument_list|()
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|MAC
name|HiliteMenu
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|EventCmd
operator|=
name|NO
expr_stmt|;
name|menus_on
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|c
operator|=
name|getch
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
continue|continue;
name|dispatch
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|private
name|char
modifier|*
modifier|*
name|scanvec
parameter_list|(
name|args
parameter_list|,
name|str
parameter_list|)
specifier|register
name|char
modifier|*
modifier|*
name|args
decl_stmt|,
decl|*
name|str
decl_stmt|;
end_function

begin_block
block|{
while|while
condition|(
operator|*
name|args
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
operator|*
name|args
argument_list|,
name|str
argument_list|)
operator|==
literal|0
condition|)
return|return
name|args
return|;
name|args
operator|+=
literal|1
expr_stmt|;
block|}
return|return
name|NULL
return|;
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|UNIX
end_ifdef

begin_decl_stmt
name|int
name|UpdFreq
init|=
literal|30
decl_stmt|,
name|inIOread
init|=
name|NO
decl_stmt|;
end_decl_stmt

begin_function
name|private
name|SIGRESULT
name|updmode
parameter_list|(
name|junk
parameter_list|)
name|int
name|junk
decl_stmt|;
comment|/* passed in on signal; of no interest */
block|{
name|int
name|save_errno
init|=
name|errno
decl_stmt|;
comment|/* Subtle, but necessary! */
name|UpdModLine
operator|=
name|YES
expr_stmt|;
if|if
condition|(
name|inIOread
condition|)
name|redisplay
argument_list|()
expr_stmt|;
ifndef|#
directive|ifndef
name|BSD_SIGS
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGALRM
argument_list|,
name|updmode
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|UpdFreq
operator|!=
literal|0
condition|)
operator|(
name|void
operator|)
name|alarm
argument_list|(
call|(
name|unsigned
call|)
argument_list|(
name|UpdFreq
operator|-
operator|(
name|time
argument_list|(
operator|(
name|time_t
operator|*
operator|)
name|NULL
argument_list|)
operator|%
name|UpdFreq
operator|)
argument_list|)
argument_list|)
expr_stmt|;
name|errno
operator|=
name|save_errno
expr_stmt|;
name|SIGRETURN
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* UNIX */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|MSDOS
end_ifdef

begin_ifndef
ifndef|#
directive|ifndef
name|IBMPC
end_ifndef

begin_decl_stmt
name|char
name|ttbuf
index|[
name|JBUFSIZ
index|]
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* IBMPC */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* MSDOS */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|WINRESIZE
end_ifdef

begin_ifndef
ifndef|#
directive|ifndef
name|MAC
end_ifndef

begin_function
name|private
endif|#
directive|endif
name|SIGRESULT
name|win_reshape
parameter_list|(
name|junk
parameter_list|)
name|int
name|junk
decl_stmt|;
comment|/* passed in when invoked by a signal; of no interest */
block|{
name|int
name|save_errno
init|=
name|errno
decl_stmt|;
comment|/* Subtle, but necessary! */
specifier|register
name|int
name|oldLI
decl_stmt|;
specifier|register
name|int
name|newsize
decl_stmt|,
name|total
decl_stmt|;
specifier|register
name|Window
modifier|*
name|wp
decl_stmt|;
ifdef|#
directive|ifdef
name|UNIX
operator|(
name|void
operator|)
name|SigHold
argument_list|(
name|SIGWINCH
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Save old number of lines. 	 */
name|oldLI
operator|=
name|LI
expr_stmt|;
comment|/* 	 * Get new line/col info. 	 */
name|ttsize
argument_list|()
expr_stmt|;
comment|/* 	 * LI has changed, and now holds the 	 * new value. 	 */
comment|/* 	 *  Go through the window list, changing each window size in 	 *  proportion to the resize. If a window becomes too small, 	 *  delete it. We keep track of all the excess lines (caused by 	 *  roundoff!), and give them to the current window, as a sop - 	 *  can't be more than one or two lines anyway. This seems fairer 	 *  than just resizing the current window. 	 */
name|wp
operator|=
name|fwind
expr_stmt|;
name|total
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|newsize
operator|=
name|LI
operator|*
name|wp
operator|->
name|w_height
operator|/
name|oldLI
expr_stmt|;
if|if
condition|(
name|newsize
operator|<
literal|2
condition|)
block|{
name|total
operator|+=
name|wp
operator|->
name|w_height
expr_stmt|;
name|wp
operator|=
name|wp
operator|->
name|w_next
expr_stmt|;
name|del_wind
argument_list|(
name|wp
operator|->
name|w_prev
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|wp
operator|->
name|w_height
operator|=
name|newsize
expr_stmt|;
name|total
operator|+=
name|newsize
expr_stmt|;
name|wp
operator|=
name|wp
operator|->
name|w_next
expr_stmt|;
block|}
block|}
do|while
condition|(
name|wp
operator|!=
name|fwind
condition|)
do|;
name|curwind
operator|->
name|w_height
operator|+=
name|LI
operator|-
name|total
operator|-
literal|1
expr_stmt|;
comment|/* Make a new screen structure */
name|make_scr
argument_list|()
expr_stmt|;
comment|/* Do a 'hard' update on the screen - clear and redraw */
name|cl_scr
argument_list|(
name|YES
argument_list|)
expr_stmt|;
name|flushscreen
argument_list|()
expr_stmt|;
name|redisplay
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|UNIX
operator|(
name|void
operator|)
name|SigRelse
argument_list|(
name|SIGWINCH
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGWINCH
argument_list|,
name|win_reshape
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|errno
operator|=
name|save_errno
expr_stmt|;
name|SIGRETURN
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|void
ifdef|#
directive|ifdef
name|MAC
comment|/* will get args from user, if option key held during launch */
name|main
parameter_list|()
block|{
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
else|#
directive|else
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
name|argv
index|[]
decl_stmt|;
block|{
endif|#
directive|endif
comment|/* MAC */
name|char
modifier|*
name|cp
decl_stmt|;
name|char
name|ttbuf
index|[
name|MAXTTYBUF
index|]
decl_stmt|;
ifdef|#
directive|ifdef
name|pdp11
comment|/* On the PDP-11, UNIX allocates at least 8K. 	 * In order not to waste this space, we allocate 	 * a bunch of buffers as autos. 	 */
name|char
name|s_iobuff
index|[
name|LBSIZE
index|]
decl_stmt|,
name|s_genbuf
index|[
name|LBSIZE
index|]
decl_stmt|,
name|s_linebuf
index|[
name|LBSIZE
index|]
decl_stmt|;
name|iobuff
operator|=
name|s_iobuff
expr_stmt|;
name|genbuf
operator|=
name|s_genbuf
expr_stmt|;
name|linebuf
operator|=
name|s_linebuf
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|MAC
name|MacInit
argument_list|()
expr_stmt|;
comment|/* initializes all */
block|{
specifier|extern
name|bool
name|make_cache
name|proto
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|make_cache
argument_list|()
condition|)
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|argc
operator|=
name|getArgs
argument_list|(
operator|&
name|argv
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* MAC */
name|iniargc
operator|=
name|argc
expr_stmt|;
name|iniargv
operator|=
name|argv
expr_stmt|;
if|if
condition|(
name|setjmp
argument_list|(
name|mainjmp
argument_list|)
condition|)
block|{
name|writef
argument_list|(
literal|"\rAck! I can't deal with error \"%s\" now.\n\r"
argument_list|,
name|mesgbuf
argument_list|)
expr_stmt|;
name|finish
argument_list|(
name|SIGIOT
argument_list|)
expr_stmt|;
comment|/* some bad signal (not SIGHUP) */
block|}
ifdef|#
directive|ifdef
name|MSDOS
comment|/* import the temporary file path from the environment and 	   fix the string, so that we can append a slash safely	*/
if|if
condition|(
operator|(
operator|(
name|cp
operator|=
name|getenv
argument_list|(
literal|"TMP"
argument_list|)
operator|)
operator|||
operator|(
name|cp
operator|=
name|getenv
argument_list|(
literal|"TMPDIR"
argument_list|)
operator|)
operator|)
operator|&&
operator|(
operator|*
name|cp
operator|!=
literal|'\0'
operator|)
condition|)
block|{
name|strcpy
argument_list|(
name|TmpFilePath
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|cp
operator|=
operator|&
name|TmpFilePath
index|[
name|strlen
argument_list|(
name|TmpFilePath
argument_list|)
operator|-
literal|1
index|]
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|cp
operator|==
literal|'/'
operator|)
operator|||
operator|(
operator|*
name|cp
operator|==
literal|'\\'
operator|)
condition|)
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
block|}
name|ShFlags
index|[
literal|0
index|]
operator|=
name|switchar
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* MSDOS */
name|getTERM
argument_list|()
expr_stmt|;
comment|/* Get terminal. */
if|if
condition|(
name|getenv
argument_list|(
literal|"METAKEY"
argument_list|)
condition|)
name|MetaKey
operator|=
name|ON
expr_stmt|;
name|ttsize
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|MAC
name|InitEvents
argument_list|()
expr_stmt|;
else|#
directive|else
name|InitCM
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|d_cache_init
argument_list|()
expr_stmt|;
comment|/* initialize the disk buffer cache */
ifdef|#
directive|ifdef
name|MSDOS
if|if
condition|(
operator|(
name|cp
operator|=
name|getenv
argument_list|(
literal|"COMSPEC"
argument_list|)
operator|)
operator|&&
operator|(
operator|*
name|cp
operator|!=
literal|'\0'
operator|)
condition|)
block|{
name|strcpy
argument_list|(
name|Shell
argument_list|,
name|cp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|cp
operator|=
name|getenv
argument_list|(
literal|"DESCRIBE"
argument_list|)
operator|)
operator|&&
operator|(
operator|*
name|cp
operator|!=
literal|'\0'
operator|)
condition|)
name|strcpy
argument_list|(
name|CmdDb
argument_list|,
name|cp
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* !MSDOS */
ifndef|#
directive|ifndef
name|MAC
if|if
condition|(
operator|(
name|cp
operator|=
name|getenv
argument_list|(
literal|"SHELL"
argument_list|)
operator|)
operator|!=
name|NULL
operator|&&
operator|(
operator|*
name|cp
operator|!=
literal|'\0'
operator|)
condition|)
block|{
name|strcpy
argument_list|(
name|Shell
argument_list|,
name|cp
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
endif|#
directive|endif
comment|/* !MSDOS */
name|make_scr
argument_list|()
expr_stmt|;
name|mac_init
argument_list|()
expr_stmt|;
comment|/* Initialize Macros */
name|winit
argument_list|()
expr_stmt|;
comment|/* Initialize Window */
ifdef|#
directive|ifdef
name|IPROCS
name|pinit
argument_list|()
expr_stmt|;
comment|/* Pipes/process initialization */
endif|#
directive|endif
name|buf_init
argument_list|()
expr_stmt|;
block|{
name|char
modifier|*
modifier|*
name|argp
decl_stmt|;
if|if
condition|(
operator|(
name|argp
operator|=
name|scanvec
argument_list|(
name|argv
argument_list|,
literal|"-d"
argument_list|)
operator|)
operator|!=
name|NULL
ifdef|#
directive|ifdef
name|UNIX
operator|&&
name|chkCWD
argument_list|(
name|argp
index|[
literal|1
index|]
argument_list|)
endif|#
directive|endif
condition|)
name|setCWD
argument_list|(
name|argp
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
else|else
name|getCWD
argument_list|()
expr_stmt|;
comment|/* After we setup curbuf in case we have to getwd() */
block|}
name|HomeDir
operator|=
name|getenv
argument_list|(
literal|"HOME"
argument_list|)
expr_stmt|;
if|if
condition|(
name|HomeDir
operator|==
name|NULL
condition|)
name|HomeDir
operator|=
literal|"/"
expr_stmt|;
name|HomeLen
operator|=
name|strlen
argument_list|(
name|HomeDir
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|UNIX
if|if
condition|(
operator|(
name|cp
operator|=
name|getenv
argument_list|(
literal|"MAIL"
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|strcpy
argument_list|(
name|Mailbox
argument_list|,
name|cp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|swritef
argument_list|(
name|Mailbox
argument_list|,
sizeof|sizeof
argument_list|(
name|Mailbox
argument_list|)
argument_list|,
literal|"%s/%s"
argument_list|,
name|MAILSPOOL
argument_list|,
name|getenv
argument_list|(
literal|"LOGNAME"
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|InitKeymaps
argument_list|()
expr_stmt|;
name|ttinit
argument_list|()
expr_stmt|;
comment|/* initialize terminal (before ~/.joverc) */
name|settout
argument_list|(
name|ttbuf
argument_list|)
expr_stmt|;
comment|/* not until we know baudrate */
ifndef|#
directive|ifndef
name|MAC
name|ResetTerm
argument_list|()
expr_stmt|;
endif|#
directive|endif
operator|(
name|void
operator|)
name|joverc
argument_list|(
name|Joverc
argument_list|)
expr_stmt|;
comment|/* system wide .joverc */
name|cp
operator|=
name|NULL
expr_stmt|;
ifndef|#
directive|ifndef
name|MAC
comment|/* If a JOVERC environment variable is set, then use that instead */
if|if
condition|(
operator|(
name|cp
operator|=
name|getenv
argument_list|(
literal|"JOVERC"
argument_list|)
operator|)
operator|!=
name|NULL
operator|&&
operator|(
operator|*
name|cp
operator|!=
literal|'\0'
operator|)
condition|)
operator|(
name|void
operator|)
name|joverc
argument_list|(
name|cp
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* !MAC */
if|if
condition|(
operator|!
name|scanvec
argument_list|(
name|argv
argument_list|,
literal|"-j"
argument_list|)
operator|&&
operator|(
operator|!
name|cp
operator|||
operator|*
name|cp
operator|==
literal|'\0'
operator|)
condition|)
block|{
name|char
name|tmpbuf
index|[
literal|100
index|]
decl_stmt|;
name|swritef
argument_list|(
name|tmpbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|tmpbuf
argument_list|)
argument_list|,
literal|"%s/.joverc"
argument_list|,
name|HomeDir
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|joverc
argument_list|(
name|tmpbuf
argument_list|)
expr_stmt|;
comment|/* .joverc in home directory */
block|}
ifndef|#
directive|ifndef
name|MSDOS
if|if
condition|(
name|scanvec
argument_list|(
name|argv
argument_list|,
literal|"-r"
argument_list|)
condition|)
name|dorecover
argument_list|()
expr_stmt|;
if|if
condition|(
name|scanvec
argument_list|(
name|argv
argument_list|,
literal|"-rc"
argument_list|)
condition|)
name|FullRecover
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* MSDOS */
ifdef|#
directive|ifdef
name|MSDOS
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
name|break_off
argument_list|()
expr_stmt|;
comment|/* disable ctrl-c checking */
endif|#
directive|endif
comment|/* MSDOS */
ifdef|#
directive|ifdef
name|UNIX
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGHUP
argument_list|,
name|finish
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|finish
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGBUS
argument_list|,
name|finish
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGSEGV
argument_list|,
name|finish
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGPIPE
argument_list|,
name|finish
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGTERM
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|WINRESIZE
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGWINCH
argument_list|,
name|win_reshape
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* set things up to update the modeline every UpdFreq seconds */
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGALRM
argument_list|,
name|updmode
argument_list|)
expr_stmt|;
if|if
condition|(
name|UpdFreq
operator|!=
literal|0
condition|)
operator|(
name|void
operator|)
name|alarm
argument_list|(
call|(
name|unsigned
call|)
argument_list|(
name|UpdFreq
operator|-
operator|(
name|time
argument_list|(
operator|(
name|time_t
operator|*
operator|)
name|NULL
argument_list|)
operator|%
name|UpdFreq
operator|)
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* UNIX */
name|cl_scr
argument_list|(
name|YES
argument_list|)
expr_stmt|;
name|flushscreen
argument_list|()
expr_stmt|;
name|RedrawDisplay
argument_list|()
expr_stmt|;
comment|/* start the redisplay process. */
name|DoKeys
argument_list|(
name|YES
argument_list|)
expr_stmt|;
name|finish
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|MSDOS
include|#
directive|include
file|<dos.h>
name|private
name|char
name|break_state
decl_stmt|;
comment|/* set the break state to off */
name|private
name|void
name|break_off
parameter_list|()
block|{
name|union
name|REGS
name|regs
decl_stmt|;
name|regs
operator|.
name|h
operator|.
name|ah
operator|=
literal|0x33
expr_stmt|;
comment|/* break status */
name|regs
operator|.
name|h
operator|.
name|al
operator|=
literal|0x00
expr_stmt|;
comment|/* request current state */
name|intdos
argument_list|(
operator|&
name|regs
argument_list|,
operator|&
name|regs
argument_list|)
expr_stmt|;
name|break_state
operator|=
name|regs
operator|.
name|h
operator|.
name|dl
expr_stmt|;
name|bdos
argument_list|(
literal|0x33
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* turn off break */
block|}
comment|/* reset the break state */
name|private
name|void
name|break_rst
parameter_list|()
block|{
name|bdos
argument_list|(
literal|0x33
argument_list|,
name|break_state
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

