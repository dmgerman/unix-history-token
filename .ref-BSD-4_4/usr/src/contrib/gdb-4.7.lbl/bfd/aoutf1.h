begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* A.out "format 1" file handling code for BFD.    Copyright 1990, 1991, 1992 Free Software Foundation, Inc.    Written by Cygnus Support.  This file is part of BFD, the Binary File Descriptor library.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"sysdep.h"
end_include

begin_include
include|#
directive|include
file|"libbfd.h"
end_include

begin_include
include|#
directive|include
file|"aout/sun4.h"
end_include

begin_include
include|#
directive|include
file|"libaout.h"
end_include

begin_comment
comment|/* BFD a.out internal data structures */
end_comment

begin_include
include|#
directive|include
file|"aout/aout64.h"
end_include

begin_include
include|#
directive|include
file|"aout/stab_gnu.h"
end_include

begin_include
include|#
directive|include
file|"aout/ar.h"
end_include

begin_comment
comment|/* The file @code{aoutf1.h} contains the code for BFD's a.out back end. Control over the generated back end is given by these two preprocessor names: @table @code @item ARCH_SIZE This value should be either 32 or 64, depending upon the size of an int in the target format. It changes the sizes of the structs which perform the memory/disk mapping of structures.  The 64 bit backend may only be used if the host compiler supports 64 ints (eg long long with gcc), by defining the name @code{HOST_64_BIT} in @code{bfd.h}. With this name defined, @emph{all} bfd operations are performed with 64bit arithmetic, not just those to a 64bit target.  @item TARGETNAME The name put into the target vector. @item @end table  */
end_comment

begin_function_decl
name|void
function_decl|(
modifier|*
name|bfd_error_trap
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/*SUPPRESS558*/
end_comment

begin_comment
comment|/*SUPPRESS529*/
end_comment

begin_decl_stmt
name|void
name|DEFUN
argument_list|(
name|NAME
argument_list|(
name|sunos
argument_list|,
name|set_arch_mach
argument_list|)
argument_list|,
operator|(
name|abfd
operator|,
name|machtype
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
name|AND
name|int
name|machtype
argument_list|)
block|{
comment|/* Determine the architecture and machine type of the object file.  */
name|enum
name|bfd_architecture
name|arch
decl_stmt|;
name|long
name|machine
decl_stmt|;
switch|switch
condition|(
name|machtype
condition|)
block|{
case|case
name|M_UNKNOWN
case|:
comment|/* Some Sun3s make magic numbers without cpu types in them, so 	 we'll default to the 68020. */
name|arch
operator|=
name|bfd_arch_m68k
expr_stmt|;
name|machine
operator|=
literal|68020
expr_stmt|;
break|break;
case|case
name|M_68010
case|:
case|case
name|M_HP200
case|:
name|arch
operator|=
name|bfd_arch_m68k
expr_stmt|;
name|machine
operator|=
literal|68010
expr_stmt|;
break|break;
case|case
name|M_68020
case|:
case|case
name|M_HP300
case|:
name|arch
operator|=
name|bfd_arch_m68k
expr_stmt|;
name|machine
operator|=
literal|68020
expr_stmt|;
break|break;
case|case
name|M_SPARC
case|:
name|arch
operator|=
name|bfd_arch_sparc
expr_stmt|;
name|machine
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|M_386
case|:
name|arch
operator|=
name|bfd_arch_i386
expr_stmt|;
name|machine
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|M_29K
case|:
name|arch
operator|=
name|bfd_arch_a29k
expr_stmt|;
name|machine
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|M_HPUX
case|:
name|arch
operator|=
name|bfd_arch_m68k
expr_stmt|;
name|machine
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
name|arch
operator|=
name|bfd_arch_obscure
expr_stmt|;
name|machine
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|bfd_set_arch_mach
argument_list|(
name|abfd
argument_list|,
name|arch
argument_list|,
name|machine
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_define
define|#
directive|define
name|SET_ARCH_MACH
parameter_list|(
name|ABFD
parameter_list|,
name|EXEC
parameter_list|)
define|\
value|NAME(sunos,set_arch_mach)(ABFD, N_MACHTYPE (EXEC)); \   choose_reloc_size(ABFD);
end_define

begin_comment
comment|/* Determine the size of a relocation entry, based on the architecture */
end_comment

begin_decl_stmt
specifier|static
name|void
name|DEFUN
argument_list|(
name|choose_reloc_size
argument_list|,
operator|(
name|abfd
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
argument_list|)
block|{
switch|switch
condition|(
name|bfd_get_arch
argument_list|(
name|abfd
argument_list|)
condition|)
block|{
case|case
name|bfd_arch_sparc
case|:
case|case
name|bfd_arch_a29k
case|:
name|obj_reloc_entry_size
argument_list|(
name|abfd
argument_list|)
operator|=
name|RELOC_EXT_SIZE
expr_stmt|;
break|break;
default|default:
name|obj_reloc_entry_size
argument_list|(
name|abfd
argument_list|)
operator|=
name|RELOC_STD_SIZE
expr_stmt|;
break|break;
block|}
block|}
end_decl_stmt

begin_comment
comment|/* Write an object file in SunOS format.   Section contents have already been written.  We write the   file header, symbols, and relocation.  */
end_comment

begin_decl_stmt
specifier|static
name|boolean
name|DEFUN
argument_list|(
name|NAME
argument_list|(
name|aout
argument_list|,
name|sunos4_write_object_contents
argument_list|)
argument_list|,
operator|(
name|abfd
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
argument_list|)
block|{
name|struct
name|external_exec
name|exec_bytes
decl_stmt|;
name|struct
name|internal_exec
modifier|*
name|execp
init|=
name|exec_hdr
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
comment|/* Magic number, maestro, please!  */
switch|switch
condition|(
name|bfd_get_arch
argument_list|(
name|abfd
argument_list|)
condition|)
block|{
case|case
name|bfd_arch_m68k
case|:
switch|switch
condition|(
name|bfd_get_mach
argument_list|(
name|abfd
argument_list|)
condition|)
block|{
case|case
literal|68010
case|:
name|N_SET_MACHTYPE
argument_list|(
operator|*
name|execp
argument_list|,
name|M_68010
argument_list|)
expr_stmt|;
break|break;
default|default:
case|case
literal|68020
case|:
name|N_SET_MACHTYPE
argument_list|(
operator|*
name|execp
argument_list|,
name|M_68020
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|bfd_arch_sparc
case|:
name|N_SET_MACHTYPE
argument_list|(
operator|*
name|execp
argument_list|,
name|M_SPARC
argument_list|)
expr_stmt|;
break|break;
case|case
name|bfd_arch_i386
case|:
name|N_SET_MACHTYPE
argument_list|(
operator|*
name|execp
argument_list|,
name|M_386
argument_list|)
expr_stmt|;
break|break;
case|case
name|bfd_arch_a29k
case|:
name|N_SET_MACHTYPE
argument_list|(
operator|*
name|execp
argument_list|,
name|M_29K
argument_list|)
expr_stmt|;
break|break;
default|default:
name|N_SET_MACHTYPE
argument_list|(
operator|*
name|execp
argument_list|,
name|M_UNKNOWN
argument_list|)
expr_stmt|;
block|}
name|choose_reloc_size
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
comment|/* FIXME */
name|N_SET_FLAGS
argument_list|(
operator|*
name|execp
argument_list|,
literal|0x1
argument_list|)
expr_stmt|;
name|WRITE_HEADERS
argument_list|(
name|abfd
argument_list|,
name|execp
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* core files */
end_comment

begin_define
define|#
directive|define
name|CORE_MAGIC
value|0x080456
end_define

begin_define
define|#
directive|define
name|CORE_NAMELEN
value|16
end_define

begin_comment
comment|/* The core structure is taken from the Sun documentation.   Unfortunately, they don't document the FPA structure, or at least I   can't find it easily.  Fortunately the core header contains its own   length.  So this shouldn't cause problems, except for c_ucode, which   so far we don't use but is easy to find with a little arithmetic. */
end_comment

begin_comment
comment|/* But the reg structure can be gotten from the SPARC processor handbook.   This really should be in a GNU include file though so that gdb can use   the same info. */
end_comment

begin_struct
struct|struct
name|regs
block|{
name|int
name|r_psr
decl_stmt|;
name|int
name|r_pc
decl_stmt|;
name|int
name|r_npc
decl_stmt|;
name|int
name|r_y
decl_stmt|;
name|int
name|r_g1
decl_stmt|;
name|int
name|r_g2
decl_stmt|;
name|int
name|r_g3
decl_stmt|;
name|int
name|r_g4
decl_stmt|;
name|int
name|r_g5
decl_stmt|;
name|int
name|r_g6
decl_stmt|;
name|int
name|r_g7
decl_stmt|;
name|int
name|r_o0
decl_stmt|;
name|int
name|r_o1
decl_stmt|;
name|int
name|r_o2
decl_stmt|;
name|int
name|r_o3
decl_stmt|;
name|int
name|r_o4
decl_stmt|;
name|int
name|r_o5
decl_stmt|;
name|int
name|r_o6
decl_stmt|;
name|int
name|r_o7
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Taken from Sun documentation: */
end_comment

begin_comment
comment|/* FIXME:  It's worse than we expect.  This struct contains TWO substructs   neither of whose size we know, WITH STUFF IN BETWEEN THEM!  We can't   even portably access the stuff in between!  */
end_comment

begin_struct
struct|struct
name|external_sparc_core
block|{
name|int
name|c_magic
decl_stmt|;
comment|/* Corefile magic number */
name|int
name|c_len
decl_stmt|;
comment|/* Sizeof (struct core) */
define|#
directive|define
name|SPARC_CORE_LEN
value|432
name|int
name|c_regs
index|[
literal|19
index|]
decl_stmt|;
comment|/* General purpose registers -- MACHDEP SIZE */
name|struct
name|external_exec
name|c_aouthdr
decl_stmt|;
comment|/* A.out header */
name|int
name|c_signo
decl_stmt|;
comment|/* Killing signal, if any */
name|int
name|c_tsize
decl_stmt|;
comment|/* Text size (bytes) */
name|int
name|c_dsize
decl_stmt|;
comment|/* Data size (bytes) */
name|int
name|c_ssize
decl_stmt|;
comment|/* Stack size (bytes) */
name|char
name|c_cmdname
index|[
name|CORE_NAMELEN
operator|+
literal|1
index|]
decl_stmt|;
comment|/* Command name */
name|double
name|fp_stuff
index|[
literal|1
index|]
decl_stmt|;
comment|/* external FPU state (size unknown by us) */
comment|/* The type "double" is critical here, for alignment.     SunOS declares a struct here, but the struct's alignment       is double since it contains doubles.  */
name|int
name|c_ucode
decl_stmt|;
comment|/* Exception no. from u_code */
comment|/* (this member is not accessible by name since we don't     portably know the size of fp_stuff.) */
block|}
struct|;
end_struct

begin_struct
struct|struct
name|external_sun3_core
block|{
name|int
name|c_magic
decl_stmt|;
comment|/* Corefile magic number */
name|int
name|c_len
decl_stmt|;
comment|/* Sizeof (struct core) */
define|#
directive|define
name|SUN3_CORE_LEN
value|826
comment|/* As of SunOS 4.1.1 */
name|int
name|c_regs
index|[
literal|18
index|]
decl_stmt|;
comment|/* General purpose registers -- MACHDEP SIZE */
name|struct
name|external_exec
name|c_aouthdr
decl_stmt|;
comment|/* A.out header */
name|int
name|c_signo
decl_stmt|;
comment|/* Killing signal, if any */
name|int
name|c_tsize
decl_stmt|;
comment|/* Text size (bytes) */
name|int
name|c_dsize
decl_stmt|;
comment|/* Data size (bytes) */
name|int
name|c_ssize
decl_stmt|;
comment|/* Stack size (bytes) */
name|char
name|c_cmdname
index|[
name|CORE_NAMELEN
operator|+
literal|1
index|]
decl_stmt|;
comment|/* Command name */
name|double
name|fp_stuff
index|[
literal|1
index|]
decl_stmt|;
comment|/* external FPU state (size unknown by us) */
comment|/* The type "double" is critical here, for alignment.     SunOS declares a struct here, but the struct's alignment       is double since it contains doubles.  */
name|int
name|c_ucode
decl_stmt|;
comment|/* Exception no. from u_code */
comment|/* (this member is not accessible by name since we don't     portably know the size of fp_stuff.) */
block|}
struct|;
end_struct

begin_struct
struct|struct
name|internal_sunos_core
block|{
name|int
name|c_magic
decl_stmt|;
comment|/* Corefile magic number */
name|int
name|c_len
decl_stmt|;
comment|/* Sizeof (struct core) */
name|long
name|c_regs_pos
decl_stmt|;
comment|/* file offset of General purpose registers */
name|int
name|c_regs_size
decl_stmt|;
comment|/* size of General purpose registers */
name|struct
name|internal_exec
name|c_aouthdr
decl_stmt|;
comment|/* A.out header */
name|int
name|c_signo
decl_stmt|;
comment|/* Killing signal, if any */
name|int
name|c_tsize
decl_stmt|;
comment|/* Text size (bytes) */
name|int
name|c_dsize
decl_stmt|;
comment|/* Data size (bytes) */
name|int
name|c_ssize
decl_stmt|;
comment|/* Stack size (bytes) */
name|long
name|c_stacktop
decl_stmt|;
comment|/* Stack top (address) */
name|char
name|c_cmdname
index|[
name|CORE_NAMELEN
operator|+
literal|1
index|]
decl_stmt|;
comment|/* Command name */
name|long
name|fp_stuff_pos
decl_stmt|;
comment|/* file offset of external FPU state (regs) */
name|int
name|fp_stuff_size
decl_stmt|;
comment|/* Size of it */
name|int
name|c_ucode
decl_stmt|;
comment|/* Exception no. from u_code */
block|}
struct|;
end_struct

begin_comment
comment|/* byte-swap in the Sun-3 core structure */
end_comment

begin_decl_stmt
specifier|static
name|void
name|DEFUN
argument_list|(
name|swapcore_sun3
argument_list|,
operator|(
name|abfd
operator|,
name|ext
operator|,
name|intcore
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
name|AND
name|char
operator|*
name|ext
name|AND
expr|struct
name|internal_sunos_core
operator|*
name|intcore
argument_list|)
block|{
name|struct
name|external_sun3_core
modifier|*
name|extcore
init|=
operator|(
expr|struct
name|external_sun3_core
operator|*
operator|)
name|ext
decl_stmt|;
name|intcore
operator|->
name|c_magic
operator|=
name|bfd_h_get_32
argument_list|(
name|abfd
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|&
name|extcore
operator|->
name|c_magic
argument_list|)
expr_stmt|;
name|intcore
operator|->
name|c_len
operator|=
name|bfd_h_get_32
argument_list|(
name|abfd
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|&
name|extcore
operator|->
name|c_len
argument_list|)
expr_stmt|;
name|intcore
operator|->
name|c_regs_pos
operator|=
call|(
name|long
call|)
argument_list|(
operator|(
operator|(
expr|struct
name|external_sun3_core
operator|*
operator|)
literal|0
operator|)
operator|->
name|c_regs
argument_list|)
expr_stmt|;
name|intcore
operator|->
name|c_regs_size
operator|=
sizeof|sizeof
argument_list|(
name|extcore
operator|->
name|c_regs
argument_list|)
expr_stmt|;
name|NAME
argument_list|(
name|aout
argument_list|,
name|swap_exec_header_in
argument_list|)
argument_list|(
name|abfd
argument_list|,
operator|&
name|extcore
operator|->
name|c_aouthdr
argument_list|,
operator|&
name|intcore
operator|->
name|c_aouthdr
argument_list|)
expr_stmt|;
name|intcore
operator|->
name|c_signo
operator|=
name|bfd_h_get_32
argument_list|(
name|abfd
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|&
name|extcore
operator|->
name|c_signo
argument_list|)
expr_stmt|;
name|intcore
operator|->
name|c_tsize
operator|=
name|bfd_h_get_32
argument_list|(
name|abfd
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|&
name|extcore
operator|->
name|c_tsize
argument_list|)
expr_stmt|;
name|intcore
operator|->
name|c_dsize
operator|=
name|bfd_h_get_32
argument_list|(
name|abfd
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|&
name|extcore
operator|->
name|c_dsize
argument_list|)
expr_stmt|;
name|intcore
operator|->
name|c_ssize
operator|=
name|bfd_h_get_32
argument_list|(
name|abfd
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|&
name|extcore
operator|->
name|c_ssize
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|intcore
operator|->
name|c_cmdname
argument_list|,
name|extcore
operator|->
name|c_cmdname
argument_list|,
sizeof|sizeof
argument_list|(
name|intcore
operator|->
name|c_cmdname
argument_list|)
argument_list|)
expr_stmt|;
name|intcore
operator|->
name|fp_stuff_pos
operator|=
call|(
name|long
call|)
argument_list|(
operator|(
operator|(
expr|struct
name|external_sun3_core
operator|*
operator|)
literal|0
operator|)
operator|->
name|fp_stuff
argument_list|)
expr_stmt|;
comment|/* FP stuff takes up whole rest of struct, except c_ucode. */
name|intcore
operator|->
name|fp_stuff_size
operator|=
name|intcore
operator|->
name|c_len
operator|-
operator|(
sizeof|sizeof
name|extcore
operator|->
name|c_ucode
operator|)
operator|-
call|(
name|file_ptr
call|)
argument_list|(
operator|(
operator|(
expr|struct
name|external_sun3_core
operator|*
operator|)
literal|0
operator|)
operator|->
name|fp_stuff
argument_list|)
expr_stmt|;
comment|/* Ucode is the last thing in the struct -- just before the end */
name|intcore
operator|->
name|c_ucode
operator|=
name|bfd_h_get_32
argument_list|(
name|abfd
argument_list|,
name|intcore
operator|->
name|c_len
operator|-
sizeof|sizeof
argument_list|(
name|extcore
operator|->
name|c_ucode
argument_list|)
operator|+
operator|(
name|unsigned
name|char
operator|*
operator|)
name|extcore
argument_list|)
expr_stmt|;
name|intcore
operator|->
name|c_stacktop
operator|=
literal|0x0E000000
expr_stmt|;
comment|/* By experimentation */
block|}
end_decl_stmt

begin_comment
comment|/* byte-swap in the Sparc core structure */
end_comment

begin_decl_stmt
specifier|static
name|void
name|DEFUN
argument_list|(
name|swapcore_sparc
argument_list|,
operator|(
name|abfd
operator|,
name|ext
operator|,
name|intcore
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
name|AND
name|char
operator|*
name|ext
name|AND
expr|struct
name|internal_sunos_core
operator|*
name|intcore
argument_list|)
block|{
name|struct
name|external_sparc_core
modifier|*
name|extcore
init|=
operator|(
expr|struct
name|external_sparc_core
operator|*
operator|)
name|ext
decl_stmt|;
name|intcore
operator|->
name|c_magic
operator|=
name|bfd_h_get_32
argument_list|(
name|abfd
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|&
name|extcore
operator|->
name|c_magic
argument_list|)
expr_stmt|;
name|intcore
operator|->
name|c_len
operator|=
name|bfd_h_get_32
argument_list|(
name|abfd
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|&
name|extcore
operator|->
name|c_len
argument_list|)
expr_stmt|;
name|intcore
operator|->
name|c_regs_pos
operator|=
call|(
name|long
call|)
argument_list|(
operator|(
operator|(
expr|struct
name|external_sparc_core
operator|*
operator|)
literal|0
operator|)
operator|->
name|c_regs
argument_list|)
expr_stmt|;
name|intcore
operator|->
name|c_regs_size
operator|=
sizeof|sizeof
argument_list|(
name|extcore
operator|->
name|c_regs
argument_list|)
expr_stmt|;
name|NAME
argument_list|(
name|aout
argument_list|,
name|swap_exec_header_in
argument_list|)
argument_list|(
name|abfd
argument_list|,
operator|&
name|extcore
operator|->
name|c_aouthdr
argument_list|,
operator|&
name|intcore
operator|->
name|c_aouthdr
argument_list|)
expr_stmt|;
name|intcore
operator|->
name|c_signo
operator|=
name|bfd_h_get_32
argument_list|(
name|abfd
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|&
name|extcore
operator|->
name|c_signo
argument_list|)
expr_stmt|;
name|intcore
operator|->
name|c_tsize
operator|=
name|bfd_h_get_32
argument_list|(
name|abfd
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|&
name|extcore
operator|->
name|c_tsize
argument_list|)
expr_stmt|;
name|intcore
operator|->
name|c_dsize
operator|=
name|bfd_h_get_32
argument_list|(
name|abfd
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|&
name|extcore
operator|->
name|c_dsize
argument_list|)
expr_stmt|;
name|intcore
operator|->
name|c_ssize
operator|=
name|bfd_h_get_32
argument_list|(
name|abfd
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|&
name|extcore
operator|->
name|c_ssize
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|intcore
operator|->
name|c_cmdname
argument_list|,
name|extcore
operator|->
name|c_cmdname
argument_list|,
sizeof|sizeof
argument_list|(
name|intcore
operator|->
name|c_cmdname
argument_list|)
argument_list|)
expr_stmt|;
name|intcore
operator|->
name|fp_stuff_pos
operator|=
call|(
name|long
call|)
argument_list|(
operator|(
operator|(
expr|struct
name|external_sparc_core
operator|*
operator|)
literal|0
operator|)
operator|->
name|fp_stuff
argument_list|)
expr_stmt|;
comment|/* FP stuff takes up whole rest of struct, except c_ucode. */
name|intcore
operator|->
name|fp_stuff_size
operator|=
name|intcore
operator|->
name|c_len
operator|-
operator|(
sizeof|sizeof
name|extcore
operator|->
name|c_ucode
operator|)
operator|-
call|(
name|file_ptr
call|)
argument_list|(
operator|(
operator|(
expr|struct
name|external_sparc_core
operator|*
operator|)
literal|0
operator|)
operator|->
name|fp_stuff
argument_list|)
expr_stmt|;
comment|/* Ucode is the last thing in the struct -- just before the end */
name|intcore
operator|->
name|c_ucode
operator|=
name|bfd_h_get_32
argument_list|(
name|abfd
argument_list|,
name|intcore
operator|->
name|c_len
operator|-
sizeof|sizeof
argument_list|(
name|extcore
operator|->
name|c_ucode
argument_list|)
operator|+
operator|(
name|unsigned
name|char
operator|*
operator|)
name|extcore
argument_list|)
expr_stmt|;
comment|/* Supposedly the user stack grows downward from the bottom of kernel memory.      Presuming that this remains true, this definition will work. */
define|#
directive|define
name|SPARC_USRSTACK
value|(-(128*1024*1024))
name|intcore
operator|->
name|c_stacktop
operator|=
name|SPARC_USRSTACK
expr_stmt|;
comment|/* By experimentation */
block|}
end_decl_stmt

begin_comment
comment|/* need this cast because ptr is really void * */
end_comment

begin_define
define|#
directive|define
name|core_hdr
parameter_list|(
name|bfd
parameter_list|)
value|((bfd)->tdata.sun_core_data)
end_define

begin_define
define|#
directive|define
name|core_datasec
parameter_list|(
name|bfd
parameter_list|)
value|(core_hdr(bfd)->data_section)
end_define

begin_define
define|#
directive|define
name|core_stacksec
parameter_list|(
name|bfd
parameter_list|)
value|(core_hdr(bfd)->stack_section)
end_define

begin_define
define|#
directive|define
name|core_regsec
parameter_list|(
name|bfd
parameter_list|)
value|(core_hdr(bfd)->reg_section)
end_define

begin_define
define|#
directive|define
name|core_reg2sec
parameter_list|(
name|bfd
parameter_list|)
value|(core_hdr(bfd)->reg2_section)
end_define

begin_comment
comment|/* These are stored in the bfd's tdata */
end_comment

begin_struct
struct|struct
name|sun_core_struct
block|{
name|struct
name|internal_sunos_core
modifier|*
name|hdr
decl_stmt|;
comment|/* core file header */
name|asection
modifier|*
name|data_section
decl_stmt|;
name|asection
modifier|*
name|stack_section
decl_stmt|;
name|asection
modifier|*
name|reg_section
decl_stmt|;
name|asection
modifier|*
name|reg2_section
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|bfd_target
modifier|*
name|DEFUN
argument_list|(
name|sunos4_core_file_p
argument_list|,
operator|(
name|abfd
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
argument_list|)
block|{
name|unsigned
name|char
name|longbuf
index|[
literal|4
index|]
decl_stmt|;
comment|/* Raw bytes of various header fields */
name|int
name|core_size
decl_stmt|;
name|int
name|core_mag
decl_stmt|;
name|struct
name|internal_sunos_core
modifier|*
name|core
decl_stmt|;
name|char
modifier|*
name|extcore
decl_stmt|;
struct|struct
name|mergem
block|{
name|struct
name|sun_core_struct
name|suncoredata
decl_stmt|;
name|struct
name|internal_sunos_core
name|internal_sunos_core
decl_stmt|;
name|char
name|external_core
index|[
literal|1
index|]
decl_stmt|;
block|}
modifier|*
name|mergem
struct|;
name|bfd_error
operator|=
name|system_call_error
expr_stmt|;
if|if
condition|(
name|bfd_read
argument_list|(
operator|(
name|PTR
operator|)
name|longbuf
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|longbuf
argument_list|)
argument_list|,
name|abfd
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|longbuf
argument_list|)
condition|)
return|return
literal|0
return|;
name|core_mag
operator|=
name|bfd_h_get_32
argument_list|(
name|abfd
argument_list|,
name|longbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|core_mag
operator|!=
name|CORE_MAGIC
condition|)
return|return
literal|0
return|;
comment|/* SunOS core headers can vary in length; second word is size; */
if|if
condition|(
name|bfd_read
argument_list|(
operator|(
name|PTR
operator|)
name|longbuf
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|longbuf
argument_list|)
argument_list|,
name|abfd
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|longbuf
argument_list|)
condition|)
return|return
literal|0
return|;
name|core_size
operator|=
name|bfd_h_get_32
argument_list|(
name|abfd
argument_list|,
name|longbuf
argument_list|)
expr_stmt|;
comment|/* Sanity check */
if|if
condition|(
name|core_size
operator|>
literal|20000
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
operator|(
name|file_ptr
operator|)
literal|0
argument_list|,
name|SEEK_SET
argument_list|)
operator|<
literal|0
condition|)
return|return
literal|0
return|;
name|mergem
operator|=
operator|(
expr|struct
name|mergem
operator|*
operator|)
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
name|core_size
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|mergem
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|mergem
operator|==
name|NULL
condition|)
block|{
name|bfd_error
operator|=
name|no_memory
expr_stmt|;
return|return
literal|0
return|;
block|}
name|extcore
operator|=
name|mergem
operator|->
name|external_core
expr_stmt|;
if|if
condition|(
operator|(
name|bfd_read
argument_list|(
operator|(
name|PTR
operator|)
name|extcore
argument_list|,
literal|1
argument_list|,
name|core_size
argument_list|,
name|abfd
argument_list|)
operator|)
operator|!=
name|core_size
condition|)
block|{
name|bfd_error
operator|=
name|system_call_error
expr_stmt|;
name|bfd_release
argument_list|(
name|abfd
argument_list|,
operator|(
name|char
operator|*
operator|)
name|mergem
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* Validate that it's a core file we know how to handle, due to sun      botching the positioning of registers and other fields in a machine      dependent way.  */
name|core
operator|=
operator|&
name|mergem
operator|->
name|internal_sunos_core
expr_stmt|;
switch|switch
condition|(
name|core_size
condition|)
block|{
case|case
name|SPARC_CORE_LEN
case|:
name|swapcore_sparc
argument_list|(
name|abfd
argument_list|,
name|extcore
argument_list|,
name|core
argument_list|)
expr_stmt|;
break|break;
case|case
name|SUN3_CORE_LEN
case|:
name|swapcore_sun3
argument_list|(
name|abfd
argument_list|,
name|extcore
argument_list|,
name|core
argument_list|)
expr_stmt|;
break|break;
default|default:
name|bfd_error
operator|=
name|system_call_error
expr_stmt|;
comment|/* FIXME */
name|bfd_release
argument_list|(
name|abfd
argument_list|,
operator|(
name|char
operator|*
operator|)
name|mergem
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|abfd
operator|->
name|tdata
operator|.
name|sun_core_data
operator|=
operator|&
name|mergem
operator|->
name|suncoredata
expr_stmt|;
name|abfd
operator|->
name|tdata
operator|.
name|sun_core_data
operator|->
name|hdr
operator|=
name|core
expr_stmt|;
comment|/* create the sections.  This is raunchy, but bfd_close wants to reclaim      them */
name|core_stacksec
argument_list|(
name|abfd
argument_list|)
operator|=
operator|(
name|asection
operator|*
operator|)
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
sizeof|sizeof
argument_list|(
name|asection
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|core_stacksec
argument_list|(
name|abfd
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|loser
label|:
name|bfd_error
operator|=
name|no_memory
expr_stmt|;
name|bfd_release
argument_list|(
name|abfd
argument_list|,
operator|(
name|char
operator|*
operator|)
name|mergem
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|core_datasec
argument_list|(
name|abfd
argument_list|)
operator|=
operator|(
name|asection
operator|*
operator|)
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
sizeof|sizeof
argument_list|(
name|asection
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|core_datasec
argument_list|(
name|abfd
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|loser1
label|:
name|bfd_release
argument_list|(
name|abfd
argument_list|,
name|core_stacksec
argument_list|(
name|abfd
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|loser
goto|;
block|}
name|core_regsec
argument_list|(
name|abfd
argument_list|)
operator|=
operator|(
name|asection
operator|*
operator|)
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
sizeof|sizeof
argument_list|(
name|asection
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|core_regsec
argument_list|(
name|abfd
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|loser2
label|:
name|bfd_release
argument_list|(
name|abfd
argument_list|,
name|core_datasec
argument_list|(
name|abfd
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|loser1
goto|;
block|}
name|core_reg2sec
argument_list|(
name|abfd
argument_list|)
operator|=
operator|(
name|asection
operator|*
operator|)
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
sizeof|sizeof
argument_list|(
name|asection
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|core_reg2sec
argument_list|(
name|abfd
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|bfd_release
argument_list|(
name|abfd
argument_list|,
name|core_regsec
argument_list|(
name|abfd
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|loser2
goto|;
block|}
name|core_stacksec
argument_list|(
name|abfd
argument_list|)
operator|->
name|name
operator|=
literal|".stack"
expr_stmt|;
name|core_datasec
argument_list|(
name|abfd
argument_list|)
operator|->
name|name
operator|=
literal|".data"
expr_stmt|;
name|core_regsec
argument_list|(
name|abfd
argument_list|)
operator|->
name|name
operator|=
literal|".reg"
expr_stmt|;
name|core_reg2sec
argument_list|(
name|abfd
argument_list|)
operator|->
name|name
operator|=
literal|".reg2"
expr_stmt|;
name|core_stacksec
argument_list|(
name|abfd
argument_list|)
operator|->
name|flags
operator|=
name|SEC_ALLOC
operator|+
name|SEC_LOAD
operator|+
name|SEC_HAS_CONTENTS
expr_stmt|;
name|core_datasec
argument_list|(
name|abfd
argument_list|)
operator|->
name|flags
operator|=
name|SEC_ALLOC
operator|+
name|SEC_LOAD
operator|+
name|SEC_HAS_CONTENTS
expr_stmt|;
name|core_regsec
argument_list|(
name|abfd
argument_list|)
operator|->
name|flags
operator|=
name|SEC_ALLOC
operator|+
name|SEC_HAS_CONTENTS
expr_stmt|;
name|core_reg2sec
argument_list|(
name|abfd
argument_list|)
operator|->
name|flags
operator|=
name|SEC_ALLOC
operator|+
name|SEC_HAS_CONTENTS
expr_stmt|;
name|core_stacksec
argument_list|(
name|abfd
argument_list|)
operator|->
name|_raw_size
operator|=
name|core
operator|->
name|c_ssize
expr_stmt|;
name|core_datasec
argument_list|(
name|abfd
argument_list|)
operator|->
name|_raw_size
operator|=
name|core
operator|->
name|c_dsize
expr_stmt|;
name|core_regsec
argument_list|(
name|abfd
argument_list|)
operator|->
name|_raw_size
operator|=
name|core
operator|->
name|c_regs_size
expr_stmt|;
name|core_reg2sec
argument_list|(
name|abfd
argument_list|)
operator|->
name|_raw_size
operator|=
name|core
operator|->
name|fp_stuff_size
expr_stmt|;
name|core_stacksec
argument_list|(
name|abfd
argument_list|)
operator|->
name|vma
operator|=
operator|(
name|core
operator|->
name|c_stacktop
operator|-
name|core
operator|->
name|c_ssize
operator|)
expr_stmt|;
name|core_datasec
argument_list|(
name|abfd
argument_list|)
operator|->
name|vma
operator|=
name|N_DATADDR
argument_list|(
name|core
operator|->
name|c_aouthdr
argument_list|)
expr_stmt|;
name|core_regsec
argument_list|(
name|abfd
argument_list|)
operator|->
name|vma
operator|=
literal|0
expr_stmt|;
name|core_reg2sec
argument_list|(
name|abfd
argument_list|)
operator|->
name|vma
operator|=
literal|0
expr_stmt|;
name|core_stacksec
argument_list|(
name|abfd
argument_list|)
operator|->
name|filepos
operator|=
name|core
operator|->
name|c_len
operator|+
name|core
operator|->
name|c_dsize
expr_stmt|;
name|core_datasec
argument_list|(
name|abfd
argument_list|)
operator|->
name|filepos
operator|=
name|core
operator|->
name|c_len
expr_stmt|;
comment|/* We'll access the regs afresh in the core file, like any section: */
name|core_regsec
argument_list|(
name|abfd
argument_list|)
operator|->
name|filepos
operator|=
operator|(
name|file_ptr
operator|)
name|core
operator|->
name|c_regs_pos
expr_stmt|;
name|core_reg2sec
argument_list|(
name|abfd
argument_list|)
operator|->
name|filepos
operator|=
operator|(
name|file_ptr
operator|)
name|core
operator|->
name|fp_stuff_pos
expr_stmt|;
comment|/* Align to word at least */
name|core_stacksec
argument_list|(
name|abfd
argument_list|)
operator|->
name|alignment_power
operator|=
literal|2
expr_stmt|;
name|core_datasec
argument_list|(
name|abfd
argument_list|)
operator|->
name|alignment_power
operator|=
literal|2
expr_stmt|;
name|core_regsec
argument_list|(
name|abfd
argument_list|)
operator|->
name|alignment_power
operator|=
literal|2
expr_stmt|;
name|core_reg2sec
argument_list|(
name|abfd
argument_list|)
operator|->
name|alignment_power
operator|=
literal|2
expr_stmt|;
name|abfd
operator|->
name|sections
operator|=
name|core_stacksec
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|core_stacksec
argument_list|(
name|abfd
argument_list|)
operator|->
name|next
operator|=
name|core_datasec
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|core_datasec
argument_list|(
name|abfd
argument_list|)
operator|->
name|next
operator|=
name|core_regsec
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|core_regsec
argument_list|(
name|abfd
argument_list|)
operator|->
name|next
operator|=
name|core_reg2sec
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|abfd
operator|->
name|section_count
operator|=
literal|4
expr_stmt|;
return|return
name|abfd
operator|->
name|xvec
return|;
block|}
end_decl_stmt

begin_function
specifier|static
name|char
modifier|*
name|sunos4_core_file_failing_command
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
return|return
name|core_hdr
argument_list|(
name|abfd
argument_list|)
operator|->
name|hdr
operator|->
name|c_cmdname
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|int
name|DEFUN
argument_list|(
name|sunos4_core_file_failing_signal
argument_list|,
operator|(
name|abfd
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
argument_list|)
block|{
return|return
name|core_hdr
argument_list|(
name|abfd
argument_list|)
operator|->
name|hdr
operator|->
name|c_signo
return|;
block|}
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|DEFUN
argument_list|(
name|sunos4_core_file_matches_executable_p
argument_list|,
operator|(
name|core_bfd
operator|,
name|exec_bfd
operator|)
argument_list|,
name|bfd
operator|*
name|core_bfd
name|AND
name|bfd
operator|*
name|exec_bfd
argument_list|)
block|{
if|if
condition|(
name|core_bfd
operator|->
name|xvec
operator|!=
name|exec_bfd
operator|->
name|xvec
condition|)
block|{
name|bfd_error
operator|=
name|system_call_error
expr_stmt|;
return|return
name|false
return|;
block|}
return|return
operator|(
name|memcmp
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
operator|(
operator|(
name|core_hdr
argument_list|(
name|core_bfd
argument_list|)
operator|->
name|hdr
operator|)
operator|->
name|c_aouthdr
operator|)
argument_list|,
operator|(
name|char
operator|*
operator|)
name|exec_hdr
argument_list|(
name|exec_bfd
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|internal_exec
argument_list|)
argument_list|)
operator|==
literal|0
operator|)
condition|?
name|true
else|:
name|false
return|;
block|}
end_decl_stmt

begin_decl_stmt
specifier|extern
name|reloc_howto_type
name|aout_32_ext_howto_table
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|reloc_howto_type
modifier|*
name|DEFUN
argument_list|(
name|sunos4_reloc_type_lookup
argument_list|,
operator|(
name|abfd
operator|,
name|code
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
name|AND
name|bfd_reloc_code_real_type
name|code
argument_list|)
block|{
switch|switch
condition|(
name|bfd_get_arch
argument_list|(
name|abfd
argument_list|)
condition|)
block|{
default|default:
return|return
literal|0
return|;
case|case
name|bfd_arch_sparc
case|:
switch|switch
condition|(
name|code
condition|)
block|{
default|default:
return|return
literal|0
return|;
define|#
directive|define
name|IDX
parameter_list|(
name|i
parameter_list|,
name|j
parameter_list|)
value|case i: return&aout_32_ext_howto_table[j]
name|IDX
argument_list|(
name|BFD_RELOC_CTOR
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|IDX
argument_list|(
name|BFD_RELOC_32
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|IDX
argument_list|(
name|BFD_RELOC_HI22
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|IDX
argument_list|(
name|BFD_RELOC_LO10
argument_list|,
literal|11
argument_list|)
expr_stmt|;
name|IDX
argument_list|(
name|BFD_RELOC_32_PCREL_S2
argument_list|,
literal|6
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|DEFUN
argument_list|(
name|sunos4_set_sizes
argument_list|,
operator|(
name|abfd
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
argument_list|)
block|{
switch|switch
condition|(
name|bfd_get_arch
argument_list|(
name|abfd
argument_list|)
condition|)
block|{
default|default:
return|return
name|false
return|;
case|case
name|bfd_arch_sparc
case|:
name|adata
argument_list|(
name|abfd
argument_list|)
operator|.
name|page_size
operator|=
literal|0x2000
expr_stmt|;
name|adata
argument_list|(
name|abfd
argument_list|)
operator|.
name|segment_size
operator|=
literal|0x2000
expr_stmt|;
name|adata
argument_list|(
name|abfd
argument_list|)
operator|.
name|exec_bytes_size
operator|=
name|EXEC_BYTES_SIZE
expr_stmt|;
return|return
name|true
return|;
case|case
name|bfd_arch_m68k
case|:
name|adata
argument_list|(
name|abfd
argument_list|)
operator|.
name|page_size
operator|=
literal|0x2000
expr_stmt|;
name|adata
argument_list|(
name|abfd
argument_list|)
operator|.
name|segment_size
operator|=
literal|0x20000
expr_stmt|;
name|adata
argument_list|(
name|abfd
argument_list|)
operator|.
name|exec_bytes_size
operator|=
name|EXEC_BYTES_SIZE
expr_stmt|;
return|return
name|true
return|;
block|}
block|}
end_decl_stmt

begin_expr_stmt
specifier|static
name|CONST
expr|struct
name|aout_backend_data
name|sunos4_aout_backend
operator|=
block|{
literal|0
block|,
literal|1
block|,
literal|0
block|,
name|sunos4_set_sizes
block|,
literal|0
block|, }
expr_stmt|;
end_expr_stmt

begin_escape
end_escape

begin_define
define|#
directive|define
name|MY_core_file_failing_command
value|sunos4_core_file_failing_command
end_define

begin_define
define|#
directive|define
name|MY_core_file_failing_signal
value|sunos4_core_file_failing_signal
end_define

begin_define
define|#
directive|define
name|MY_core_file_matches_executable_p
value|sunos4_core_file_matches_executable_p
end_define

begin_define
define|#
directive|define
name|MY_bfd_debug_info_start
value|bfd_void
end_define

begin_define
define|#
directive|define
name|MY_bfd_debug_info_end
value|bfd_void
end_define

begin_define
define|#
directive|define
name|MY_bfd_debug_info_accumulate
value|(PROTO(void,(*),(bfd*, struct sec *))) bfd_void
end_define

begin_define
define|#
directive|define
name|MY_core_file_p
value|sunos4_core_file_p
end_define

begin_define
define|#
directive|define
name|MY_write_object_contents
value|NAME(aout,sunos4_write_object_contents)
end_define

begin_define
define|#
directive|define
name|MY_backend_data
value|&sunos4_aout_backend
end_define

begin_define
define|#
directive|define
name|TARGET_IS_BIG_ENDIAN_P
end_define

begin_include
include|#
directive|include
file|"aout-target.h"
end_include

end_unit

