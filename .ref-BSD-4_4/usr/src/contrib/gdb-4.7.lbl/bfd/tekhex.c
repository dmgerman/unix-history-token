begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* BFD backend for Extended Tektronix Hex Format  objects.    Copyright (C) 1992 Free Software Foundation, Inc.     Written by Steve Chamberlain of Cygnus Support<sac@cygnus.com>.  This file is part of BFD, the Binary File Descriptor library.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_comment
comment|/* SUBSECTION 	Tektronix Hex Format handling  DESCRIPTION 	 	Tek Hex records can hold symbols and data, but not 	relocations. Their main application is communication with 	devices like PROM programmers and ICE equipment. 	 	It seems that the sections are descibed as being really big,         the example I have says that the text section is 0..ffffffff. 	BFD would barf with this, many apps would try to alloc 4GB to 	read in the file.   	Tex Hex may contain many sections, but the data which comes in 	has no tag saying which section it belongs to, so we create 	one section for each block of data, called "blknnnn" which we 	stick all the data into.  	TekHex may come out of 	order and there is no header, so an 	initial scan is required  to discover the minimum and maximum 	addresses used to create the vma and size of the sections we 	create.   	We read in the data into pages of CHUNK_MASK+1 size and read 	them out from that whenever we need to.  	Any number of sections may be created for output, we save them 	up and output them when it's time to close the bfd.   	A TekHex record looks like: EXAMPLE 	%<block length><type><checksum><stuff><cr> 	 DESCRIPTION 	Where 	o length 	is the number of bytes in the record not including the % sign. 	o type 	is one of: 	3) symbol record 	6) data record 	8) termination record 	  The data can come out of order, and may be discontigous. This is a serial protocol, so big files are unlikely, so we keep a list of 8k chunks */
end_comment

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"sysdep.h"
end_include

begin_include
include|#
directive|include
file|"libbfd.h"
end_include

begin_typedef
typedef|typedef
struct|struct
block|{
name|bfd_vma
name|low
decl_stmt|;
name|bfd_vma
name|high
decl_stmt|;
block|}
name|addr_range_type
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
name|tekhex_symbol_struct
block|{
name|asymbol
name|symbol
decl_stmt|;
name|struct
name|tekhex_symbol_struct
modifier|*
name|prev
decl_stmt|;
block|}
name|tekhex_symbol_type
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|char
name|digs
index|[]
init|=
literal|"0123456789ABCDEF"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|sum_block
index|[
literal|256
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Horrible ascii dependent macros for converting between hex and    binary */
end_comment

begin_define
define|#
directive|define
name|CHARS_IN_SET
value|256
end_define

begin_decl_stmt
specifier|static
name|char
name|hex_value
index|[
name|CHARS_IN_SET
index|]
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|NOT_HEX
value|20
end_define

begin_define
define|#
directive|define
name|NIBBLE
parameter_list|(
name|x
parameter_list|)
value|hex_value[x]
end_define

begin_define
define|#
directive|define
name|HEX
parameter_list|(
name|buffer
parameter_list|)
value|((NIBBLE((buffer)[0])<<4) + NIBBLE((buffer)[1]))
end_define

begin_define
define|#
directive|define
name|TOHEX
parameter_list|(
name|d
parameter_list|,
name|x
parameter_list|)
define|\
value|(d)[1] = digs[(x)& 0xf]; \ (d)[0] = digs[((x)>>4)&0xf];
end_define

begin_define
define|#
directive|define
name|ISHEX
parameter_list|(
name|x
parameter_list|)
value|(hex_value[x] != NOT_HEX)
end_define

begin_comment
comment|/* Here's an example %3A6C6480004E56FFFC4E717063B0AEFFFC6D0652AEFFFC60F24E5E4E75 %1B3709T_SEGMENT1108FFFFFFFF %2B3AB9T_SEGMENT7Dgcc_compiled$1087hello$c10 %373829T_SEGMENT80int$t1$r1$$214741080char$t2$r2$0$12710 %373769T_SEGMENT80long$int$t3$r1$$1080unsigned$int$t4$10 %373CA9T_SEGMENT80long$unsigned$in1080short$int$t6$r1$10 %373049T_SEGMENT80long$long$int$t71080short$unsigned$i10 %373A29T_SEGMENT80long$long$unsign1080signed$char$t10$10 %373D69T_SEGMENT80unsigned$char$t11080float$t12$r1$4$010 %373D19T_SEGMENT80double$t13$r1$8$1080long$double$t14$10 %2734D9T_SEGMENT8Bvoid$t15$151035_main10 %2F3CA9T_SEGMENT81$1081$1681$1E81$21487main$F110 %2832F9T_SEGMENT83i$18FFFFFFFC81$1481$214 %07 8 10 10  explanation: %3A6C6480004E56FFFC4E717063B0AEFFFC6D0652AEFFFC60F24E5E4E75  ^ ^^ ^     ^-data  | || +------ 4 char integer 0x8000  | |+-------- checksum  | +--------- type 6 (data record)  +----------- length 3a chars<---------------------- 3a (58 chars) ------------------->  %1B3709T_SEGMENT1108FFFFFFFF       ^         ^^ ^- 8 character integer 0xffffffff       |         |+-   1 character integer 0       |         +--   type 1 symbol (section definition)       +------------   9 char symbol T_SEGMENT  %2B3AB9T_SEGMENT7Dgcc_compiled$1087hello$c10 %373829T_SEGMENT80int$t1$r1$$214741080char$t2$r2$0$12710 %373769T_SEGMENT80long$int$t3$r1$$1080unsigned$int$t4$10 %373CA9T_SEGMENT80long$unsigned$in1080short$int$t6$r1$10 %373049T_SEGMENT80long$long$int$t71080short$unsigned$i10 %373A29T_SEGMENT80long$long$unsign1080signed$char$t10$10 %373D69T_SEGMENT80unsigned$char$t11080float$t12$r1$4$010 %373D19T_SEGMENT80double$t13$r1$8$1080long$double$t14$10 %2734D9T_SEGMENT8Bvoid$t15$151035_main10 %2F3CA9T_SEGMENT81$1081$1681$1E81$21487main$F110 %2832F9T_SEGMENT83i$18FFFFFFFC81$1481$214 %0781010  Turns into  sac@thepub$ ./objdump -dx -m m68k f  f:     file format tekhex -----x--- 9/55728 -134219416 Sep 29 15:13 1995 f architecture: UNKNOWN!, flags 0x00000010: HAS_SYMS start address 0x00000000 SECTION 0 [D00000000]	: size 00020000 vma 00000000 align 2**0  ALLOC, LOAD SECTION 1 [D00008000]	: size 00002001 vma 00008000 align 2**0   SECTION 2 [T_SEGMENT]	: size ffffffff vma 00000000 align 2**0   SYMBOL TABLE: 00000000  g       T_SEGMENT gcc_compiled$ 00000000  g       T_SEGMENT hello$c 00000000  g       T_SEGMENT int$t1$r1$$21474 00000000  g       T_SEGMENT char$t2$r2$0$127 00000000  g       T_SEGMENT long$int$t3$r1$$ 00000000  g       T_SEGMENT unsigned$int$t4$ 00000000  g       T_SEGMENT long$unsigned$in 00000000  g       T_SEGMENT short$int$t6$r1$ 00000000  g       T_SEGMENT long$long$int$t7 00000000  g       T_SEGMENT short$unsigned$i 00000000  g       T_SEGMENT long$long$unsign 00000000  g       T_SEGMENT signed$char$t10$ 00000000  g       T_SEGMENT unsigned$char$t1 00000000  g       T_SEGMENT float$t12$r1$4$0 00000000  g       T_SEGMENT double$t13$r1$8$ 00000000  g       T_SEGMENT long$double$t14$ 00000000  g       T_SEGMENT void$t15$15 00000000  g       T_SEGMENT _main 00000000  g       T_SEGMENT $ 00000000  g       T_SEGMENT $ 00000000  g       T_SEGMENT $ 00000010  g       T_SEGMENT $ 00000000  g       T_SEGMENT main$F1 fcffffff  g       T_SEGMENT i$1 00000000  g       T_SEGMENT $ 00000010  g       T_SEGMENT $   RELOCATION RECORDS FOR [D00000000]: (none)  RELOCATION RECORDS FOR [D00008000]: (none)  RELOCATION RECORDS FOR [T_SEGMENT]: (none)  Disassembly of section D00000000: ... 00008000 ($+)7ff0 linkw fp,#-4 00008004 ($+)7ff4 nop 00008006 ($+)7ff6 movel #99,d0 00008008 ($+)7ff8 cmpl fp@(-4),d0 0000800c ($+)7ffc blts 00008014 ($+)8004 0000800e ($+)7ffe addql #1,fp@(-4) 00008012 ($+)8002 bras 00008006 ($+)7ff6 00008014 ($+)8004 unlk fp 00008016 ($+)8006 rts ...  */
end_comment

begin_function
specifier|static
name|void
name|DEFUN_VOID
parameter_list|(
name|tekhex_init
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
specifier|static
name|boolean
name|inited
init|=
name|false
decl_stmt|;
name|int
name|val
decl_stmt|;
if|if
condition|(
name|inited
operator|==
name|false
condition|)
block|{
name|inited
operator|=
name|true
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|CHARS_IN_SET
condition|;
name|i
operator|++
control|)
block|{
name|hex_value
index|[
name|i
index|]
operator|=
name|NOT_HEX
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|10
condition|;
name|i
operator|++
control|)
block|{
name|hex_value
index|[
name|i
operator|+
literal|'0'
index|]
operator|=
name|i
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|6
condition|;
name|i
operator|++
control|)
block|{
name|hex_value
index|[
name|i
operator|+
literal|'a'
index|]
operator|=
name|i
operator|+
literal|10
expr_stmt|;
name|hex_value
index|[
name|i
operator|+
literal|'A'
index|]
operator|=
name|i
operator|+
literal|10
expr_stmt|;
block|}
name|val
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|10
condition|;
name|i
operator|++
control|)
block|{
name|sum_block
index|[
name|i
operator|+
literal|'0'
index|]
operator|=
name|val
operator|++
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|'A'
init|;
name|i
operator|<=
literal|'Z'
condition|;
name|i
operator|++
control|)
block|{
name|sum_block
index|[
name|i
index|]
operator|=
name|val
operator|++
expr_stmt|;
block|}
name|sum_block
index|[
literal|'$'
index|]
operator|=
name|val
operator|++
expr_stmt|;
name|sum_block
index|[
literal|'%'
index|]
operator|=
name|val
operator|++
expr_stmt|;
name|sum_block
index|[
literal|'.'
index|]
operator|=
name|val
operator|++
expr_stmt|;
name|sum_block
index|[
literal|'_'
index|]
operator|=
name|val
operator|++
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|'a'
init|;
name|i
operator|<=
literal|'z'
condition|;
name|i
operator|++
control|)
block|{
name|sum_block
index|[
name|i
index|]
operator|=
name|val
operator|++
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* The maximum number of bytes on a line is FF */
end_comment

begin_define
define|#
directive|define
name|MAXCHUNK
value|0xff
end_define

begin_comment
comment|/* The number of bytes we fit onto a line on output */
end_comment

begin_define
define|#
directive|define
name|CHUNK
value|21
end_define

begin_comment
comment|/* We cannot output our tekhexords as we see them, we have to glue them    together, this is done in this structure : */
end_comment

begin_struct
struct|struct
name|tekhex_data_list_struct
block|{
name|unsigned
name|char
modifier|*
name|data
decl_stmt|;
name|bfd_vma
name|where
decl_stmt|;
name|bfd_size_type
name|size
decl_stmt|;
name|struct
name|tekhex_data_list_struct
modifier|*
name|next
decl_stmt|;
block|}
struct|;
end_struct

begin_typedef
typedef|typedef
name|struct
name|tekhex_data_list_struct
name|tekhex_data_list_type
typedef|;
end_typedef

begin_define
define|#
directive|define
name|CHUNK_MASK
value|0x1fff
end_define

begin_struct
struct|struct
name|data_struct
block|{
name|char
name|chunk_data
index|[
name|CHUNK_MASK
operator|+
literal|1
index|]
decl_stmt|;
name|char
name|chunk_init
index|[
name|CHUNK_MASK
operator|+
literal|1
index|]
decl_stmt|;
name|bfd_vma
name|vma
decl_stmt|;
name|struct
name|data_struct
modifier|*
name|next
decl_stmt|;
block|}
struct|;
end_struct

begin_typedef
typedef|typedef
struct|struct
name|tekhex_data_struct
block|{
name|tekhex_data_list_type
modifier|*
name|head
decl_stmt|;
name|unsigned
name|int
name|type
decl_stmt|;
name|struct
name|tekhex_symbol_struct
modifier|*
name|symbols
decl_stmt|;
name|struct
name|data_struct
modifier|*
name|data
decl_stmt|;
block|}
name|tdata_type
typedef|;
end_typedef

begin_define
define|#
directive|define
name|enda
parameter_list|(
name|x
parameter_list|)
value|(x->vma + x->size)
end_define

begin_decl_stmt
specifier|static
name|bfd_vma
name|DEFUN
argument_list|(
name|getvalue
argument_list|,
operator|(
name|srcp
operator|)
argument_list|,
name|char
operator|*
operator|*
name|srcp
argument_list|)
block|{
name|char
modifier|*
name|src
init|=
operator|*
name|srcp
decl_stmt|;
name|bfd_vma
name|value
init|=
literal|0
decl_stmt|;
name|unsigned
name|int
name|len
init|=
name|hex_value
index|[
operator|*
name|src
operator|++
index|]
decl_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
condition|)
name|len
operator|=
literal|16
expr_stmt|;
while|while
condition|(
name|len
operator|--
condition|)
block|{
name|value
operator|=
name|value
operator|<<
literal|4
operator||
name|hex_value
index|[
operator|*
name|src
operator|++
index|]
expr_stmt|;
block|}
operator|*
name|srcp
operator|=
name|src
expr_stmt|;
return|return
name|value
return|;
block|}
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|DEFUN
argument_list|(
name|getsym
argument_list|,
operator|(
name|dstp
operator|,
name|srcp
operator|)
argument_list|,
name|char
operator|*
name|dstp
name|AND
name|char
operator|*
operator|*
name|srcp
argument_list|)
block|{
name|char
modifier|*
name|src
init|=
operator|*
name|srcp
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|unsigned
name|int
name|len
init|=
name|hex_value
index|[
operator|*
name|src
operator|++
index|]
decl_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
condition|)
name|len
operator|=
literal|16
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
name|dstp
index|[
name|i
index|]
operator|=
name|src
index|[
name|i
index|]
expr_stmt|;
name|dstp
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
operator|*
name|srcp
operator|=
name|src
operator|+
name|i
expr_stmt|;
return|return
name|len
return|;
block|}
end_decl_stmt

begin_decl_stmt
name|struct
name|data_struct
modifier|*
name|DEFUN
argument_list|(
name|find_chunk
argument_list|,
operator|(
name|abfd
operator|,
name|vma
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
name|AND
name|bfd_vma
name|vma
argument_list|)
block|{
name|struct
name|data_struct
modifier|*
name|d
init|=
name|abfd
operator|->
name|tdata
operator|.
name|tekhex_data
operator|->
name|data
decl_stmt|;
name|vma
operator|&=
operator|~
name|CHUNK_MASK
expr_stmt|;
while|while
condition|(
name|d
operator|&&
operator|(
name|d
operator|->
name|vma
operator|)
operator|!=
name|vma
condition|)
block|{
name|d
operator|=
name|d
operator|->
name|next
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|d
condition|)
block|{
name|char
modifier|*
name|sname
init|=
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
literal|12
argument_list|)
decl_stmt|;
name|asection
modifier|*
name|s
decl_stmt|;
comment|/* No chunk for this address, so make one up */
name|d
operator|=
operator|(
expr|struct
name|data_struct
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|data_struct
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|d
operator|->
name|chunk_init
argument_list|,
literal|0
argument_list|,
name|CHUNK_MASK
operator|+
literal|1
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|d
operator|->
name|chunk_data
argument_list|,
literal|0
argument_list|,
name|CHUNK_MASK
operator|+
literal|1
argument_list|)
expr_stmt|;
name|d
operator|->
name|next
operator|=
name|abfd
operator|->
name|tdata
operator|.
name|tekhex_data
operator|->
name|data
expr_stmt|;
name|d
operator|->
name|vma
operator|=
name|vma
expr_stmt|;
name|abfd
operator|->
name|tdata
operator|.
name|tekhex_data
operator|->
name|data
operator|=
name|d
expr_stmt|;
block|}
return|return
name|d
return|;
block|}
end_decl_stmt

begin_macro
name|DEFUN
argument_list|(
argument|insert_byte
argument_list|,
argument|(abfd, value, addr)
argument_list|,
argument|bfd *abfd AND       int value AND       bfd_vma addr
argument_list|)
end_macro

begin_block
block|{
comment|/* Find the chunk that this byte needs and put it in */
name|struct
name|data_struct
modifier|*
name|d
init|=
name|find_chunk
argument_list|(
name|abfd
argument_list|,
name|addr
argument_list|)
decl_stmt|;
name|d
operator|->
name|chunk_data
index|[
name|addr
operator|&
name|CHUNK_MASK
index|]
operator|=
name|value
expr_stmt|;
name|d
operator|->
name|chunk_init
index|[
name|addr
operator|&
name|CHUNK_MASK
index|]
operator|=
literal|1
expr_stmt|;
block|}
end_block

begin_comment
comment|/* The first pass is to find the names of all the sections, and see    how big the data is */
end_comment

begin_decl_stmt
specifier|static
name|void
name|DEFUN
argument_list|(
name|first_phase
argument_list|,
operator|(
name|abfd
operator|,
name|type
operator|,
name|src
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
name|AND
name|char
name|type
name|AND
name|char
operator|*
name|src
argument_list|)
block|{
name|asection
modifier|*
name|section
init|=
operator|&
name|bfd_abs_section
decl_stmt|;
name|int
name|len
decl_stmt|;
name|char
name|sym
index|[
literal|17
index|]
decl_stmt|;
comment|/* A symbol can only be 16chars long */
switch|switch
condition|(
name|type
condition|)
block|{
case|case
literal|'6'
case|:
comment|/* Data record - read it and store it */
block|{
name|bfd_vma
name|addr
init|=
name|getvalue
argument_list|(
operator|&
name|src
argument_list|)
decl_stmt|;
while|while
condition|(
operator|*
name|src
condition|)
block|{
name|insert_byte
argument_list|(
name|abfd
argument_list|,
name|HEX
argument_list|(
name|src
argument_list|)
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|src
operator|+=
literal|2
expr_stmt|;
name|addr
operator|++
expr_stmt|;
block|}
block|}
return|return;
case|case
literal|'3'
case|:
comment|/* Symbol record, read the segment */
name|len
operator|=
name|getsym
argument_list|(
name|sym
argument_list|,
operator|&
name|src
argument_list|)
expr_stmt|;
name|section
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
name|sym
argument_list|)
expr_stmt|;
if|if
condition|(
name|section
operator|==
operator|(
name|asection
operator|*
operator|)
name|NULL
condition|)
block|{
name|char
modifier|*
name|n
init|=
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|len
operator|+
literal|1
argument_list|)
decl_stmt|;
name|memcpy
argument_list|(
name|n
argument_list|,
name|sym
argument_list|,
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|section
operator|=
name|bfd_make_section
argument_list|(
name|abfd
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
operator|*
name|src
condition|)
block|{
switch|switch
condition|(
operator|*
name|src
condition|)
block|{
name|asection
modifier|*
name|s
decl_stmt|;
case|case
literal|'1'
case|:
comment|/* section range */
name|src
operator|++
expr_stmt|;
name|section
operator|->
name|vma
operator|=
name|getvalue
argument_list|(
operator|&
name|src
argument_list|)
expr_stmt|;
name|section
operator|->
name|_raw_size
operator|=
name|getvalue
argument_list|(
operator|&
name|src
argument_list|)
operator|-
name|section
operator|->
name|vma
expr_stmt|;
name|section
operator|->
name|flags
operator|=
name|SEC_HAS_CONTENTS
operator||
name|SEC_LOAD
operator||
name|SEC_ALLOC
expr_stmt|;
break|break;
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
comment|/* Symbols, add to section */
block|{
name|tekhex_symbol_type
modifier|*
name|new
init|=
operator|(
name|tekhex_symbol_type
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
sizeof|sizeof
argument_list|(
name|tekhex_symbol_type
argument_list|)
argument_list|)
decl_stmt|;
name|char
name|type
init|=
operator|(
operator|*
name|src
operator|)
decl_stmt|;
name|new
operator|->
name|symbol
operator|.
name|the_bfd
operator|=
name|abfd
expr_stmt|;
name|src
operator|++
expr_stmt|;
name|abfd
operator|->
name|symcount
operator|++
expr_stmt|;
name|abfd
operator|->
name|flags
operator||=
name|HAS_SYMS
expr_stmt|;
name|new
operator|->
name|prev
operator|=
name|abfd
operator|->
name|tdata
operator|.
name|tekhex_data
operator|->
name|symbols
expr_stmt|;
name|abfd
operator|->
name|tdata
operator|.
name|tekhex_data
operator|->
name|symbols
operator|=
name|new
expr_stmt|;
name|len
operator|=
name|getsym
argument_list|(
name|sym
argument_list|,
operator|&
name|src
argument_list|)
expr_stmt|;
name|new
operator|->
name|symbol
operator|.
name|name
operator|=
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|(
name|new
operator|->
name|symbol
operator|.
name|name
operator|)
argument_list|,
name|sym
argument_list|,
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|new
operator|->
name|symbol
operator|.
name|section
operator|=
name|section
expr_stmt|;
if|if
condition|(
name|type
operator|<=
literal|'4'
condition|)
name|new
operator|->
name|symbol
operator|.
name|flags
operator|=
operator|(
name|BSF_GLOBAL
operator||
name|BSF_EXPORT
operator|)
expr_stmt|;
else|else
name|new
operator|->
name|symbol
operator|.
name|flags
operator|=
name|BSF_LOCAL
expr_stmt|;
name|new
operator|->
name|symbol
operator|.
name|value
operator|=
name|getvalue
argument_list|(
operator|&
name|src
argument_list|)
operator|-
name|section
operator|->
name|vma
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
end_decl_stmt

begin_comment
comment|/* Pass over an tekhex, calling one of the above functions on each    record.  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|DEFUN
argument_list|(
name|pass_over
argument_list|,
operator|(
name|abfd
operator|,
name|func
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
name|AND
name|void
name|EXFUN
argument_list|(
operator|(
operator|*
name|func
operator|)
argument_list|,
operator|(
name|bfd
operator|*
operator|,
name|char
operator|,
name|char
operator|*
operator|)
argument_list|)
argument_list|)
block|{
name|unsigned
name|int
name|chars_on_line
decl_stmt|;
name|boolean
name|eof
init|=
name|false
decl_stmt|;
comment|/* To the front of the file */
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
operator|(
name|file_ptr
operator|)
literal|0
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
while|while
condition|(
name|eof
operator|==
name|false
condition|)
block|{
name|char
name|buffer
index|[
name|MAXCHUNK
index|]
decl_stmt|;
name|char
modifier|*
name|src
init|=
name|buffer
decl_stmt|;
name|char
name|type
decl_stmt|;
name|bfd_vma
name|address
init|=
literal|0
decl_stmt|;
comment|/* Find first '%' */
name|eof
operator|=
call|(
name|boolean
call|)
argument_list|(
name|bfd_read
argument_list|(
name|src
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
name|abfd
argument_list|)
operator|!=
literal|1
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|src
operator|!=
literal|'%'
operator|&&
operator|!
name|eof
condition|)
block|{
name|eof
operator|=
call|(
name|boolean
call|)
argument_list|(
name|bfd_read
argument_list|(
name|src
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
name|abfd
argument_list|)
operator|!=
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|eof
condition|)
break|break;
name|src
operator|++
expr_stmt|;
comment|/* Fetch the type and the length and the checksum */
name|bfd_read
argument_list|(
name|src
argument_list|,
literal|1
argument_list|,
literal|5
argument_list|,
name|abfd
argument_list|)
expr_stmt|;
name|type
operator|=
name|src
index|[
literal|2
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|ISHEX
argument_list|(
name|src
index|[
literal|0
index|]
argument_list|)
operator|||
operator|!
name|ISHEX
argument_list|(
name|src
index|[
literal|1
index|]
argument_list|)
condition|)
break|break;
name|chars_on_line
operator|=
name|HEX
argument_list|(
name|src
argument_list|)
operator|-
literal|5
expr_stmt|;
comment|/* Already read five char */
name|bfd_read
argument_list|(
name|src
argument_list|,
literal|1
argument_list|,
name|chars_on_line
argument_list|,
name|abfd
argument_list|)
expr_stmt|;
name|src
index|[
name|chars_on_line
index|]
operator|=
literal|0
expr_stmt|;
comment|/* put a null at the end */
name|func
argument_list|(
name|abfd
argument_list|,
name|type
argument_list|,
name|src
argument_list|)
expr_stmt|;
block|}
block|}
end_decl_stmt

begin_decl_stmt
name|unsigned
name|int
name|DEFUN
argument_list|(
name|tekhex_get_symtab
argument_list|,
operator|(
name|abfd
operator|,
name|table
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
name|AND
name|asymbol
operator|*
operator|*
name|table
argument_list|)
block|{
name|tekhex_symbol_type
modifier|*
name|p
init|=
name|abfd
operator|->
name|tdata
operator|.
name|tekhex_data
operator|->
name|symbols
decl_stmt|;
name|unsigned
name|int
name|c
init|=
name|bfd_get_symcount
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
name|table
index|[
name|c
index|]
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|p
condition|)
block|{
name|table
index|[
operator|--
name|c
index|]
operator|=
operator|&
operator|(
name|p
operator|->
name|symbol
operator|)
expr_stmt|;
name|p
operator|=
name|p
operator|->
name|prev
expr_stmt|;
block|}
return|return
name|bfd_get_symcount
argument_list|(
name|abfd
argument_list|)
return|;
block|}
end_decl_stmt

begin_decl_stmt
name|unsigned
name|int
name|DEFUN
argument_list|(
name|tekhex_get_symtab_upper_bound
argument_list|,
operator|(
name|abfd
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
argument_list|)
block|{
return|return
operator|(
name|abfd
operator|->
name|symcount
operator|+
literal|1
operator|)
operator|*
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|tekhex_asymbol_struct
operator|*
argument_list|)
operator|)
return|;
block|}
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|DEFUN
argument_list|(
name|tekhex_mkobject
argument_list|,
operator|(
name|abfd
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
argument_list|)
block|{
name|tdata_type
modifier|*
name|tdata
init|=
operator|(
name|tdata_type
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
sizeof|sizeof
argument_list|(
name|tdata_type
argument_list|)
argument_list|)
decl_stmt|;
name|abfd
operator|->
name|tdata
operator|.
name|tekhex_data
operator|=
name|tdata
expr_stmt|;
name|tdata
operator|->
name|type
operator|=
literal|1
expr_stmt|;
name|tdata
operator|->
name|head
operator|=
operator|(
name|tekhex_data_list_type
operator|*
operator|)
name|NULL
expr_stmt|;
name|tdata
operator|->
name|symbols
operator|=
operator|(
expr|struct
name|tekhex_symbol_struct
operator|*
operator|)
name|NULL
expr_stmt|;
name|tdata
operator|->
name|data
operator|=
operator|(
expr|struct
name|data_struct
operator|*
operator|)
name|NULL
expr_stmt|;
return|return
name|true
return|;
block|}
end_decl_stmt

begin_comment
comment|/*    Return true if the file looks like it's in TekHex format. Just look   for a percent sign and some hex digits */
end_comment

begin_decl_stmt
specifier|static
name|bfd_target
modifier|*
name|DEFUN
argument_list|(
name|tekhex_object_p
argument_list|,
operator|(
name|abfd
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
argument_list|)
block|{
name|char
name|b
index|[
literal|4
index|]
decl_stmt|;
name|asection
modifier|*
name|section
decl_stmt|;
name|tekhex_init
argument_list|()
expr_stmt|;
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
operator|(
name|file_ptr
operator|)
literal|0
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
name|bfd_read
argument_list|(
name|b
argument_list|,
literal|1
argument_list|,
literal|4
argument_list|,
name|abfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|b
index|[
literal|0
index|]
operator|!=
literal|'%'
operator|||
operator|!
name|ISHEX
argument_list|(
name|b
index|[
literal|1
index|]
argument_list|)
operator|||
operator|!
name|ISHEX
argument_list|(
name|b
index|[
literal|2
index|]
argument_list|)
operator|||
operator|!
name|ISHEX
argument_list|(
name|b
index|[
literal|3
index|]
argument_list|)
condition|)
return|return
operator|(
name|bfd_target
operator|*
operator|)
name|NULL
return|;
name|tekhex_mkobject
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|pass_over
argument_list|(
name|abfd
argument_list|,
name|first_phase
argument_list|)
expr_stmt|;
return|return
name|abfd
operator|->
name|xvec
return|;
block|}
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|DEFUN
argument_list|(
name|move_section_contents
argument_list|,
operator|(
name|abfd
operator|,
name|section
operator|,
name|locationp
operator|,
name|offset
operator|,
name|count
operator|,
name|get
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
name|AND
name|asection
operator|*
name|section
name|AND
name|PTR
name|locationp
name|AND
name|file_ptr
name|offset
name|AND
name|bfd_size_type
name|count
name|AND
name|boolean
name|get
argument_list|)
block|{
name|bfd_vma
name|addr
decl_stmt|;
name|char
modifier|*
name|location
init|=
operator|(
name|char
operator|*
operator|)
name|locationp
decl_stmt|;
name|bfd_vma
name|prev_number
init|=
literal|1
decl_stmt|;
comment|/* Nothing can have this as a high bit*/
name|struct
name|data_struct
modifier|*
name|d
init|=
operator|(
expr|struct
name|data_struct
operator|*
operator|)
name|NULL
decl_stmt|;
for|for
control|(
name|addr
operator|=
name|section
operator|->
name|vma
init|;
name|count
operator|!=
literal|0
condition|;
name|count
operator|--
operator|,
name|addr
operator|++
control|)
block|{
name|bfd_vma
name|chunk_number
init|=
name|addr
operator|&
operator|~
name|CHUNK_MASK
decl_stmt|;
comment|/* Get high bits of address */
name|bfd_vma
name|low_bits
init|=
name|addr
operator|&
name|CHUNK_MASK
decl_stmt|;
if|if
condition|(
name|chunk_number
operator|!=
name|prev_number
condition|)
block|{
comment|/* Different chunk, so move pointer */
name|d
operator|=
name|find_chunk
argument_list|(
name|abfd
argument_list|,
name|chunk_number
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|get
condition|)
block|{
if|if
condition|(
name|d
operator|->
name|chunk_init
index|[
name|low_bits
index|]
condition|)
block|{
operator|*
name|location
operator|=
name|d
operator|->
name|chunk_data
index|[
name|low_bits
index|]
expr_stmt|;
block|}
else|else
block|{
operator|*
name|location
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
name|d
operator|->
name|chunk_data
index|[
name|low_bits
index|]
operator|=
operator|*
name|location
expr_stmt|;
name|d
operator|->
name|chunk_init
index|[
name|low_bits
index|]
operator|=
operator|(
operator|*
name|location
operator|!=
literal|0
operator|)
expr_stmt|;
block|}
name|location
operator|++
expr_stmt|;
block|}
block|}
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|DEFUN
argument_list|(
name|tekhex_get_section_contents
argument_list|,
operator|(
name|abfd
operator|,
name|section
operator|,
name|locationp
operator|,
name|offset
operator|,
name|count
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
name|AND
name|asection
operator|*
name|section
name|AND
name|PTR
name|locationp
name|AND
name|file_ptr
name|offset
name|AND
name|bfd_size_type
name|count
argument_list|)
block|{
if|if
condition|(
name|section
operator|->
name|flags
operator|&
operator|(
name|SEC_LOAD
operator||
name|SEC_ALLOC
operator|)
condition|)
block|{
name|move_section_contents
argument_list|(
name|abfd
argument_list|,
name|section
argument_list|,
name|locationp
argument_list|,
name|offset
argument_list|,
name|count
argument_list|,
name|true
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
else|else
return|return
name|false
return|;
block|}
end_decl_stmt

begin_decl_stmt
name|boolean
name|DEFUN
argument_list|(
name|tekhex_set_arch_mach
argument_list|,
operator|(
name|abfd
operator|,
name|arch
operator|,
name|machine
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
name|AND
expr|enum
name|bfd_architecture
name|arch
name|AND
name|unsigned
name|long
name|machine
argument_list|)
block|{
return|return
name|bfd_default_set_arch_mach
argument_list|(
name|abfd
argument_list|,
name|arch
argument_list|,
name|machine
argument_list|)
return|;
block|}
end_decl_stmt

begin_comment
comment|/* we have to save up all the Tekhexords for a splurge before output,     */
end_comment

begin_decl_stmt
specifier|static
name|boolean
name|DEFUN
argument_list|(
name|tekhex_set_section_contents
argument_list|,
operator|(
name|abfd
operator|,
name|section
operator|,
name|locationp
operator|,
name|offset
operator|,
name|bytes_to_do
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
name|AND
name|sec_ptr
name|section
name|AND
name|PTR
name|locationp
name|AND
name|file_ptr
name|offset
name|AND
name|bfd_size_type
name|bytes_to_do
argument_list|)
block|{
if|if
condition|(
name|abfd
operator|->
name|output_has_begun
operator|==
name|false
condition|)
block|{
comment|/* The first time around, allocate enough sections to hold all the chunks */
name|asection
modifier|*
name|s
init|=
name|abfd
operator|->
name|sections
decl_stmt|;
name|bfd_vma
name|vma
decl_stmt|;
for|for
control|(
name|s
operator|=
name|abfd
operator|->
name|sections
init|;
name|s
condition|;
name|s
operator|=
name|s
operator|->
name|next
control|)
block|{
if|if
condition|(
name|s
operator|->
name|flags
operator|&
name|SEC_LOAD
condition|)
block|{
for|for
control|(
name|vma
operator|=
name|s
operator|->
name|vma
operator|&
operator|~
name|CHUNK_MASK
init|;
name|vma
operator|<
name|s
operator|->
name|vma
operator|+
name|s
operator|->
name|_raw_size
condition|;
name|vma
operator|+=
name|CHUNK_MASK
control|)
name|find_chunk
argument_list|(
name|abfd
argument_list|,
name|vma
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|section
operator|->
name|flags
operator|&
operator|(
name|SEC_LOAD
operator||
name|SEC_ALLOC
operator|)
condition|)
block|{
name|move_section_contents
argument_list|(
name|abfd
argument_list|,
name|section
argument_list|,
name|locationp
argument_list|,
name|offset
argument_list|,
name|bytes_to_do
argument_list|,
name|false
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
else|else
return|return
name|false
return|;
block|}
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|DEFUN
argument_list|(
name|writevalue
argument_list|,
operator|(
name|dst
operator|,
name|value
operator|)
argument_list|,
name|char
operator|*
operator|*
name|dst
name|AND
name|bfd_vma
name|value
argument_list|)
block|{
name|char
modifier|*
name|p
init|=
operator|*
name|dst
decl_stmt|;
name|int
name|len
decl_stmt|;
name|int
name|shift
decl_stmt|;
for|for
control|(
name|len
operator|=
literal|8
operator|,
name|shift
operator|=
literal|28
init|;
name|shift
condition|;
name|shift
operator|-=
literal|4
operator|,
name|len
operator|--
control|)
block|{
if|if
condition|(
operator|(
name|value
operator|>>
name|shift
operator|)
operator|&
literal|0xf
condition|)
block|{
operator|*
name|p
operator|++
operator|=
name|len
operator|+
literal|'0'
expr_stmt|;
while|while
condition|(
name|len
condition|)
block|{
operator|*
name|p
operator|++
operator|=
name|digs
index|[
operator|(
name|value
operator|>>
name|shift
operator|)
operator|&
literal|0xf
index|]
expr_stmt|;
name|shift
operator|-=
literal|4
expr_stmt|;
name|len
operator|--
expr_stmt|;
block|}
operator|*
name|dst
operator|=
name|p
expr_stmt|;
return|return;
block|}
block|}
operator|*
name|p
operator|++
operator|=
literal|'1'
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|'0'
expr_stmt|;
operator|*
name|dst
operator|=
name|p
expr_stmt|;
block|}
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|DEFUN
argument_list|(
name|writesym
argument_list|,
operator|(
name|dst
operator|,
name|sym
operator|)
argument_list|,
name|char
operator|*
operator|*
name|dst
name|AND
name|CONST
name|char
operator|*
name|sym
argument_list|)
block|{
name|char
modifier|*
name|p
init|=
operator|*
name|dst
decl_stmt|;
name|int
name|len
init|=
operator|(
name|sym
condition|?
name|strlen
argument_list|(
name|sym
argument_list|)
else|:
literal|0
operator|)
decl_stmt|;
if|if
condition|(
name|len
operator|>=
literal|16
condition|)
block|{
operator|*
name|p
operator|++
operator|=
literal|'0'
expr_stmt|;
name|len
operator|=
literal|16
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|len
operator|==
literal|0
condition|)
block|{
operator|*
name|p
operator|++
operator|=
literal|'1'
expr_stmt|;
name|sym
operator|=
literal|"$"
expr_stmt|;
name|len
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
operator|*
name|p
operator|++
operator|=
name|digs
index|[
name|len
index|]
expr_stmt|;
block|}
block|}
while|while
condition|(
name|len
operator|--
condition|)
block|{
operator|*
name|p
operator|++
operator|=
operator|*
name|sym
operator|++
expr_stmt|;
block|}
operator|*
name|dst
operator|=
name|p
expr_stmt|;
block|}
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|DEFUN
argument_list|(
name|out
argument_list|,
operator|(
name|abfd
operator|,
name|type
operator|,
name|start
operator|,
name|end
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
name|AND
name|char
name|type
name|AND
name|char
operator|*
name|start
name|AND
name|char
operator|*
name|end
argument_list|)
block|{
name|int
name|sum
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
name|char
name|front
index|[
literal|6
index|]
decl_stmt|;
name|front
index|[
literal|0
index|]
operator|=
literal|'%'
expr_stmt|;
name|TOHEX
argument_list|(
name|front
operator|+
literal|1
argument_list|,
name|end
operator|-
name|start
operator|+
literal|5
argument_list|)
expr_stmt|;
name|front
index|[
literal|3
index|]
operator|=
name|type
expr_stmt|;
for|for
control|(
name|s
operator|=
name|start
init|;
name|s
operator|<
name|end
condition|;
name|s
operator|++
control|)
block|{
name|sum
operator|+=
name|sum_block
index|[
operator|*
name|s
index|]
expr_stmt|;
block|}
name|sum
operator|+=
name|sum_block
index|[
name|front
index|[
literal|1
index|]
index|]
expr_stmt|;
comment|/*  length */
name|sum
operator|+=
name|sum_block
index|[
name|front
index|[
literal|2
index|]
index|]
expr_stmt|;
name|sum
operator|+=
name|sum_block
index|[
name|front
index|[
literal|3
index|]
index|]
expr_stmt|;
comment|/* type */
name|TOHEX
argument_list|(
name|front
operator|+
literal|4
argument_list|,
name|sum
argument_list|)
expr_stmt|;
name|bfd_write
argument_list|(
name|front
argument_list|,
literal|1
argument_list|,
literal|6
argument_list|,
name|abfd
argument_list|)
expr_stmt|;
name|end
index|[
literal|0
index|]
operator|=
literal|'\n'
expr_stmt|;
name|bfd_write
argument_list|(
name|start
argument_list|,
literal|1
argument_list|,
name|end
operator|-
name|start
operator|+
literal|1
argument_list|,
name|abfd
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|DEFUN
argument_list|(
name|tekhex_write_object_contents
argument_list|,
operator|(
name|abfd
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
argument_list|)
block|{
name|int
name|bytes_written
decl_stmt|;
name|char
name|buffer
index|[
literal|100
index|]
decl_stmt|;
name|asymbol
modifier|*
modifier|*
name|p
decl_stmt|;
name|tdata_type
modifier|*
name|tdata
init|=
name|abfd
operator|->
name|tdata
operator|.
name|tekhex_data
decl_stmt|;
name|tekhex_data_list_type
modifier|*
name|list
decl_stmt|;
name|asection
modifier|*
name|s
decl_stmt|;
name|struct
name|data_struct
modifier|*
name|d
decl_stmt|;
name|bytes_written
operator|=
literal|0
expr_stmt|;
comment|/* And the raw data */
for|for
control|(
name|d
operator|=
name|abfd
operator|->
name|tdata
operator|.
name|tekhex_data
operator|->
name|data
init|;
name|d
operator|!=
operator|(
expr|struct
name|data_struct
operator|*
operator|)
name|NULL
condition|;
name|d
operator|=
name|d
operator|->
name|next
control|)
block|{
name|int
name|low
decl_stmt|;
name|CONST
name|int
name|span
init|=
literal|32
decl_stmt|;
name|int
name|addr
decl_stmt|;
comment|/* Write it in blocks of 32 bytes */
for|for
control|(
name|addr
operator|=
literal|0
init|;
name|addr
operator|<
name|CHUNK_MASK
operator|+
literal|1
condition|;
name|addr
operator|+=
name|span
control|)
block|{
name|int
name|need
init|=
literal|0
decl_stmt|;
comment|/* Check to see if necessary */
for|for
control|(
name|low
operator|=
literal|0
init|;
operator|!
name|need
operator|&&
name|low
operator|<
name|span
condition|;
name|low
operator|++
control|)
block|{
if|if
condition|(
name|d
operator|->
name|chunk_init
index|[
name|addr
operator|+
name|low
index|]
condition|)
name|need
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|need
condition|)
block|{
name|char
modifier|*
name|dst
init|=
name|buffer
decl_stmt|;
name|writevalue
argument_list|(
operator|&
name|dst
argument_list|,
name|addr
operator|+
name|d
operator|->
name|vma
argument_list|)
expr_stmt|;
for|for
control|(
name|low
operator|=
literal|0
init|;
name|low
operator|<
name|span
condition|;
name|low
operator|++
control|)
block|{
name|TOHEX
argument_list|(
name|dst
argument_list|,
name|d
operator|->
name|chunk_data
index|[
name|addr
operator|+
name|low
index|]
argument_list|)
expr_stmt|;
name|dst
operator|+=
literal|2
expr_stmt|;
block|}
name|out
argument_list|(
name|abfd
argument_list|,
literal|'6'
argument_list|,
name|buffer
argument_list|,
name|dst
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* write all the section headers for the sections */
for|for
control|(
name|s
operator|=
name|abfd
operator|->
name|sections
init|;
name|s
operator|!=
operator|(
name|asection
operator|*
operator|)
name|NULL
condition|;
name|s
operator|=
name|s
operator|->
name|next
control|)
block|{
name|char
modifier|*
name|dst
init|=
name|buffer
decl_stmt|;
name|writesym
argument_list|(
operator|&
name|dst
argument_list|,
name|s
operator|->
name|name
argument_list|)
expr_stmt|;
operator|*
name|dst
operator|++
operator|=
literal|'1'
expr_stmt|;
name|writevalue
argument_list|(
operator|&
name|dst
argument_list|,
name|s
operator|->
name|vma
argument_list|)
expr_stmt|;
name|writevalue
argument_list|(
operator|&
name|dst
argument_list|,
name|s
operator|->
name|vma
operator|+
name|s
operator|->
name|_raw_size
argument_list|)
expr_stmt|;
name|out
argument_list|(
name|abfd
argument_list|,
literal|'3'
argument_list|,
name|buffer
argument_list|,
name|dst
argument_list|)
expr_stmt|;
block|}
comment|/* And the symbols */
for|for
control|(
name|p
operator|=
name|abfd
operator|->
name|outsymbols
init|;
operator|*
name|p
condition|;
name|p
operator|++
control|)
block|{
name|int
name|section_code
init|=
name|bfd_decode_symclass
argument_list|(
operator|*
name|p
argument_list|)
decl_stmt|;
if|if
condition|(
name|section_code
operator|!=
literal|'?'
condition|)
block|{
comment|/* do not include debug symbols */
name|asymbol
modifier|*
name|s
init|=
operator|*
name|p
decl_stmt|;
name|char
modifier|*
name|dst
init|=
name|buffer
decl_stmt|;
name|writesym
argument_list|(
operator|&
name|dst
argument_list|,
name|s
operator|->
name|section
operator|->
name|name
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|section_code
condition|)
block|{
case|case
literal|'A'
case|:
operator|*
name|dst
operator|++
operator|=
literal|'2'
expr_stmt|;
break|break;
case|case
literal|'a'
case|:
operator|*
name|dst
operator|++
operator|=
literal|'6'
expr_stmt|;
break|break;
case|case
literal|'D'
case|:
case|case
literal|'B'
case|:
case|case
literal|'O'
case|:
operator|*
name|dst
operator|++
operator|=
literal|'4'
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
case|case
literal|'b'
case|:
case|case
literal|'o'
case|:
operator|*
name|dst
operator|++
operator|=
literal|'8'
expr_stmt|;
break|break;
case|case
literal|'T'
case|:
operator|*
name|dst
operator|++
operator|=
literal|'3'
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
operator|*
name|dst
operator|++
operator|=
literal|'7'
expr_stmt|;
break|break;
case|case
literal|'C'
case|:
case|case
literal|'U'
case|:
name|bfd_error
operator|=
name|wrong_format
expr_stmt|;
return|return
name|false
return|;
block|}
name|writesym
argument_list|(
operator|&
name|dst
argument_list|,
name|s
operator|->
name|name
argument_list|)
expr_stmt|;
name|writevalue
argument_list|(
operator|&
name|dst
argument_list|,
name|s
operator|->
name|value
operator|+
name|s
operator|->
name|section
operator|->
name|vma
argument_list|)
expr_stmt|;
name|out
argument_list|(
name|abfd
argument_list|,
literal|'3'
argument_list|,
name|buffer
argument_list|,
name|dst
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* And the terminator */
name|bfd_write
argument_list|(
literal|"%7081010\n"
argument_list|,
literal|1
argument_list|,
literal|9
argument_list|,
name|abfd
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|DEFUN
argument_list|(
name|tekhex_sizeof_headers
argument_list|,
operator|(
name|abfd
operator|,
name|exec
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
name|AND
name|boolean
name|exec
argument_list|)
block|{
return|return
literal|0
return|;
block|}
end_decl_stmt

begin_decl_stmt
specifier|static
name|asymbol
modifier|*
name|DEFUN
argument_list|(
name|tekhex_make_empty_symbol
argument_list|,
operator|(
name|abfd
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
argument_list|)
block|{
name|tekhex_symbol_type
modifier|*
name|new
init|=
operator|(
name|tekhex_symbol_type
operator|*
operator|)
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|tekhex_symbol_struct
argument_list|)
argument_list|)
decl_stmt|;
name|new
operator|->
name|symbol
operator|.
name|the_bfd
operator|=
name|abfd
expr_stmt|;
name|new
operator|->
name|prev
operator|=
operator|(
expr|struct
name|tekhex_symbol_struct
operator|*
operator|)
name|NULL
expr_stmt|;
return|return
operator|&
operator|(
name|new
operator|->
name|symbol
operator|)
return|;
block|}
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|DEFUN
argument_list|(
name|tekhex_print_symbol
argument_list|,
operator|(
name|ignore_abfd
operator|,
name|filep
operator|,
name|symbol
operator|,
name|how
operator|)
argument_list|,
name|bfd
operator|*
name|ignore_abfd
name|AND
name|PTR
name|filep
name|AND
name|asymbol
operator|*
name|symbol
name|AND
name|bfd_print_symbol_type
name|how
argument_list|)
block|{
name|FILE
modifier|*
name|file
init|=
operator|(
name|FILE
operator|*
operator|)
name|filep
decl_stmt|;
switch|switch
condition|(
name|how
condition|)
block|{
case|case
name|bfd_print_symbol_name
case|:
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s"
argument_list|,
name|symbol
operator|->
name|name
argument_list|)
expr_stmt|;
break|break;
case|case
name|bfd_print_symbol_more
case|:
break|break;
case|case
name|bfd_print_symbol_nm
case|:
block|{
name|int
name|section_code
init|=
name|bfd_decode_symclass
argument_list|(
name|symbol
argument_list|)
decl_stmt|;
if|if
condition|(
name|section_code
operator|==
literal|'U'
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"        "
argument_list|)
expr_stmt|;
name|fprintf_vma
argument_list|(
name|file
argument_list|,
name|symbol
operator|->
name|value
operator|+
name|symbol
operator|->
name|section
operator|->
name|vma
argument_list|)
expr_stmt|;
if|if
condition|(
name|section_code
operator|==
literal|'?'
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" ?"
argument_list|)
expr_stmt|;
block|}
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" %c"
argument_list|,
name|section_code
argument_list|)
expr_stmt|;
if|if
condition|(
name|symbol
operator|->
name|name
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" %s"
argument_list|,
name|symbol
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|bfd_print_symbol_all
case|:
block|{
name|CONST
name|char
modifier|*
name|section_name
init|=
name|symbol
operator|->
name|section
operator|->
name|name
decl_stmt|;
name|bfd_print_symbol_vandf
argument_list|(
operator|(
name|PTR
operator|)
name|file
argument_list|,
name|symbol
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" %-5s %s"
argument_list|,
name|section_name
argument_list|,
name|symbol
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_decl_stmt

begin_define
define|#
directive|define
name|FOO
value|PROTO
end_define

begin_define
define|#
directive|define
name|tekhex_new_section_hook
value|(FOO(boolean, (*), (bfd *, asection *)))bfd_true
end_define

begin_define
define|#
directive|define
name|tekhex_get_reloc_upper_bound
value|(FOO(unsigned int, (*),(bfd*, asection *)))bfd_false
end_define

begin_define
define|#
directive|define
name|tekhex_canonicalize_reloc
value|(FOO(unsigned int, (*),(bfd*,asection *, arelent **, asymbol **))) bfd_0
end_define

begin_define
define|#
directive|define
name|tekhex_openr_next_archived_file
value|(FOO(bfd *, (*), (bfd*,bfd*))) bfd_nullvoidptr
end_define

begin_define
define|#
directive|define
name|tekhex_find_nearest_line
value|(FOO(boolean, (*),(bfd*,asection*,asymbol**,bfd_vma, CONST char**, CONST char**, unsigned int *))) bfd_false
end_define

begin_define
define|#
directive|define
name|tekhex_generic_stat_arch_elt
value|(FOO(int, (*), (bfd *,struct stat *))) bfd_0
end_define

begin_define
define|#
directive|define
name|tekhex_core_file_failing_command
value|(char *(*)())(bfd_nullvoidptr)
end_define

begin_define
define|#
directive|define
name|tekhex_core_file_failing_signal
value|(int (*)())bfd_0
end_define

begin_define
define|#
directive|define
name|tekhex_core_file_matches_executable_p
value|(FOO(boolean, (*),(bfd*, bfd*)))bfd_false
end_define

begin_define
define|#
directive|define
name|tekhex_slurp_armap
value|bfd_true
end_define

begin_define
define|#
directive|define
name|tekhex_slurp_extended_name_table
value|bfd_true
end_define

begin_define
define|#
directive|define
name|tekhex_truncate_arname
value|(void (*)())bfd_nullvoidptr
end_define

begin_define
define|#
directive|define
name|tekhex_write_armap
value|(FOO( boolean, (*),(bfd *, unsigned int, struct orl *, unsigned int, int))) bfd_nullvoidptr
end_define

begin_define
define|#
directive|define
name|tekhex_get_lineno
value|(struct lineno_cache_entry *(*)())bfd_nullvoidptr
end_define

begin_define
define|#
directive|define
name|tekhex_close_and_cleanup
value|bfd_generic_close_and_cleanup
end_define

begin_define
define|#
directive|define
name|tekhex_bfd_debug_info_start
value|bfd_void
end_define

begin_define
define|#
directive|define
name|tekhex_bfd_debug_info_end
value|bfd_void
end_define

begin_define
define|#
directive|define
name|tekhex_bfd_debug_info_accumulate
value|(FOO(void, (*), (bfd *,	 asection *))) bfd_void
end_define

begin_define
define|#
directive|define
name|tekhex_bfd_get_relocated_section_contents
value|bfd_generic_get_relocated_section_contents
end_define

begin_define
define|#
directive|define
name|tekhex_bfd_relax_section
value|bfd_generic_relax_section
end_define

begin_decl_stmt
name|bfd_target
name|tekhex_vec
init|=
block|{
literal|"tekhex"
block|,
comment|/* name */
name|bfd_target_tekhex_flavour
block|,
name|true
block|,
comment|/* target byte order */
name|true
block|,
comment|/* target headers byte order */
operator|(
name|EXEC_P
operator||
comment|/* object flags */
name|HAS_SYMS
operator||
name|HAS_LOCALS
operator||
name|DYNAMIC
operator||
name|WP_TEXT
operator||
name|D_PAGED
operator|)
block|,
operator|(
name|SEC_CODE
operator||
name|SEC_DATA
operator||
name|SEC_ROM
operator||
name|SEC_HAS_CONTENTS
operator||
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_RELOC
operator|)
block|,
comment|/* section flags */
literal|' '
block|,
comment|/* ar_pad_char */
literal|16
block|,
comment|/* ar_max_namelen */
literal|1
block|,
comment|/* minimum alignment */
name|_do_getb64
block|,
name|_do_putb64
block|,
name|_do_getb32
block|,
name|_do_putb32
block|,
name|_do_getb16
block|,
name|_do_putb16
block|,
comment|/* data */
name|_do_getb64
block|,
name|_do_putb64
block|,
name|_do_getb32
block|,
name|_do_putb32
block|,
name|_do_getb16
block|,
name|_do_putb16
block|,
comment|/* hdrs */
block|{
name|_bfd_dummy_target
block|,
name|tekhex_object_p
block|,
comment|/* bfd_check_format */
operator|(
expr|struct
name|bfd_target
operator|*
call|(
modifier|*
call|)
argument_list|()
operator|)
name|bfd_nullvoidptr
block|,
operator|(
expr|struct
name|bfd_target
operator|*
call|(
modifier|*
call|)
argument_list|()
operator|)
name|bfd_nullvoidptr
block|,   }
block|,
block|{
name|bfd_false
block|,
name|tekhex_mkobject
block|,
name|_bfd_generic_mkarchive
block|,
name|bfd_false
block|,   }
block|,
block|{
comment|/* bfd_write_contents */
name|bfd_false
block|,
name|tekhex_write_object_contents
block|,
name|_bfd_write_archive_contents
block|,
name|bfd_false
block|,   }
block|,
name|JUMP_TABLE
argument_list|(
argument|tekhex
argument_list|)
block|}
decl_stmt|;
end_decl_stmt

end_unit

