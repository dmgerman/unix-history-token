begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Top level `main' program for GDB, the GNU debugger.    Copyright 1986, 1987, 1988, 1989, 1990, 1991, 1992    Free Software Foundation, Inc.  This file is part of GDB.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_function_decl
name|int
name|fclose
parameter_list|()
function_decl|;
end_function_decl

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"gdbcmd.h"
end_include

begin_include
include|#
directive|include
file|"call-cmds.h"
end_include

begin_include
include|#
directive|include
file|"gdbcore.h"
end_include

begin_include
include|#
directive|include
file|"symtab.h"
end_include

begin_include
include|#
directive|include
file|"inferior.h"
end_include

begin_include
include|#
directive|include
file|"signals.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"breakpoint.h"
end_include

begin_include
include|#
directive|include
file|"gdbtypes.h"
end_include

begin_include
include|#
directive|include
file|"expression.h"
end_include

begin_include
include|#
directive|include
file|"language.h"
end_include

begin_include
include|#
directive|include
file|"getopt.h"
end_include

begin_comment
comment|/* readline include files */
end_comment

begin_include
include|#
directive|include
file|"readline.h"
end_include

begin_include
include|#
directive|include
file|"history.h"
end_include

begin_comment
comment|/* readline defines these.  */
end_comment

begin_undef
undef|#
directive|undef
name|savestring
end_undef

begin_undef
undef|#
directive|undef
name|CTRL
end_undef

begin_ifdef
ifdef|#
directive|ifdef
name|USG
end_ifdef

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|NO_SYS_FILE
end_ifndef

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<setjmp.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|SET_STACK_LIMIT_HUGE
end_ifdef

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/resource.h>
end_include

begin_decl_stmt
name|int
name|original_stack_limit
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Prototypes for local functions */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|symbol_completion_function
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|command_loop
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|command_loop_marker
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|print_gdb_version
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|quit_command
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|initialize_main
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|initialize_history
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|initialize_cmd_lists
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|float_handler
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|source_command
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|cd_command
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|print_gnu_advertisement
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|init_signals
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|read_command_file
name|PARAMS
argument_list|(
operator|(
name|FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|set_verbose
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|,
expr|struct
name|cmd_list_element
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|show_history
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|set_history
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|set_history_size_command
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|,
expr|struct
name|cmd_list_element
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|show_commands
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|echo_command
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|pwd_command
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|show_version
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|document_command
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|define_command
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|validate_comname
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|help_command
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|show_command
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|info_command
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_nothing
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|quit_cover
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|disconnect
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|source_cleanup
name|PARAMS
argument_list|(
operator|(
name|FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If this definition isn't overridden by the header files, assume    that isatty and fileno exist on this system.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|ISATTY
end_ifndef

begin_define
define|#
directive|define
name|ISATTY
parameter_list|(
name|FP
parameter_list|)
value|(isatty (fileno (FP)))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Initialization file name for gdb.  This is overridden in some configs.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|GDBINIT_FILENAME
end_ifndef

begin_define
define|#
directive|define
name|GDBINIT_FILENAME
value|".gdbinit"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|char
name|gdbinit
index|[]
init|=
name|GDBINIT_FILENAME
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|ALL_CLEANUPS
value|((struct cleanup *)0)
end_define

begin_comment
comment|/* Version number of GDB, as a string.  */
end_comment

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|version
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Message to be printed before the error message, when an error occurs.  */
end_comment

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|error_pre_print
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Message to be printed before the warning message, when a warning occurs.  */
end_comment

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|warning_pre_print
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
name|lang_frame_mismatch_warn
index|[]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* language.c */
end_comment

begin_comment
comment|/* Whether GDB's stdin is on a terminal.  */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|gdb_has_a_terminal
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* inflow.c */
end_comment

begin_comment
comment|/* Flag for whether we want all the "from_tty" gubbish printed.  */
end_comment

begin_decl_stmt
name|int
name|caution
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Default is yes, sigh. */
end_comment

begin_comment
comment|/*  * Define all cmd_list_element's  */
end_comment

begin_comment
comment|/* Chain containing all defined commands.  */
end_comment

begin_decl_stmt
name|struct
name|cmd_list_element
modifier|*
name|cmdlist
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Chain containing all defined info subcommands.  */
end_comment

begin_decl_stmt
name|struct
name|cmd_list_element
modifier|*
name|infolist
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Chain containing all defined enable subcommands. */
end_comment

begin_decl_stmt
name|struct
name|cmd_list_element
modifier|*
name|enablelist
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Chain containing all defined disable subcommands. */
end_comment

begin_decl_stmt
name|struct
name|cmd_list_element
modifier|*
name|disablelist
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Chain containing all defined delete subcommands. */
end_comment

begin_decl_stmt
name|struct
name|cmd_list_element
modifier|*
name|deletelist
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Chain containing all defined "enable breakpoint" subcommands. */
end_comment

begin_decl_stmt
name|struct
name|cmd_list_element
modifier|*
name|enablebreaklist
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Chain containing all defined set subcommands */
end_comment

begin_decl_stmt
name|struct
name|cmd_list_element
modifier|*
name|setlist
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Chain containing all defined unset subcommands */
end_comment

begin_decl_stmt
name|struct
name|cmd_list_element
modifier|*
name|unsetlist
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Chain containing all defined show subcommands.  */
end_comment

begin_decl_stmt
name|struct
name|cmd_list_element
modifier|*
name|showlist
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Chain containing all defined \"set history\".  */
end_comment

begin_decl_stmt
name|struct
name|cmd_list_element
modifier|*
name|sethistlist
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Chain containing all defined \"show history\".  */
end_comment

begin_decl_stmt
name|struct
name|cmd_list_element
modifier|*
name|showhistlist
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Chain containing all defined \"unset history\".  */
end_comment

begin_decl_stmt
name|struct
name|cmd_list_element
modifier|*
name|unsethistlist
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Chain containing all defined maintenance subcommands. */
end_comment

begin_if
if|#
directive|if
name|MAINTENANCE_CMDS
end_if

begin_decl_stmt
name|struct
name|cmd_list_element
modifier|*
name|maintenancelist
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Chain containing all defined "maintenance info" subcommands. */
end_comment

begin_if
if|#
directive|if
name|MAINTENANCE_CMDS
end_if

begin_decl_stmt
name|struct
name|cmd_list_element
modifier|*
name|maintenanceinfolist
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Chain containing all defined "maintenance print" subcommands. */
end_comment

begin_if
if|#
directive|if
name|MAINTENANCE_CMDS
end_if

begin_decl_stmt
name|struct
name|cmd_list_element
modifier|*
name|maintenanceprintlist
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|struct
name|cmd_list_element
modifier|*
name|setprintlist
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|cmd_list_element
modifier|*
name|showprintlist
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|cmd_list_element
modifier|*
name|setchecklist
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|cmd_list_element
modifier|*
name|showchecklist
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* stdio stream that command input is being read from.  */
end_comment

begin_decl_stmt
name|FILE
modifier|*
name|instream
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Current working directory.  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|current_directory
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The directory name is actually stored here (usually).  */
end_comment

begin_decl_stmt
specifier|static
name|char
name|dirbuf
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|KERNELDEBUG
end_ifdef

begin_comment
comment|/* Nonzero if we're debugging /dev/kmem or a kernel crash dump */
end_comment

begin_decl_stmt
name|int
name|kernel_debugging
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Function to call before reading a command, if nonzero.    The function receives two args: an input stream,    and a prompt string.  */
end_comment

begin_macro
name|void
argument_list|(
argument|*window_hook
argument_list|)
end_macro

begin_expr_stmt
name|PARAMS
argument_list|(
operator|(
name|FILE
operator|*
operator|,
name|char
operator|*
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|extern
name|int
name|frame_file_full_name
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|mapped_symbol_files
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|readnow_symbol_files
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero to inhibit confirmation of quitting or restarting    a stopped inferior. */
end_comment

begin_decl_stmt
name|int
name|inhibit_confirm
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The number of lines on a page */
end_comment

begin_decl_stmt
name|int
name|pagesize
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if we should refrain from using an X window.  */
end_comment

begin_decl_stmt
name|int
name|inhibit_windows
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|frame_file_full_name
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|epoch_interface
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|xgdb_verbose
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Buffer used for reading command lines, and the size    allocated for it so far.  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|line
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|linesize
init|=
literal|100
decl_stmt|;
end_decl_stmt

begin_function_decl
name|char
modifier|*
name|getenv
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* gdb prints this when reading a command interactively */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|masterprompt
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Baud rate specified for talking to serial target systems.  Default    is left as a zero pointer, so targets can choose their own defaults.  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|baud_rate
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Signal to catch ^Z typed while reading a command: SIGTSTP or SIGCONT.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|STOP_SIGNAL
end_ifndef

begin_ifdef
ifdef|#
directive|ifdef
name|SIGTSTP
end_ifdef

begin_define
define|#
directive|define
name|STOP_SIGNAL
value|SIGTSTP
end_define

begin_decl_stmt
specifier|static
name|void
name|stop_sig
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Some System V have job control but not sigsetmask(). */
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|HAVE_SIGSETMASK
argument_list|)
end_if

begin_define
define|#
directive|define
name|HAVE_SIGSETMASK
value|!defined (USG)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
literal|0
operator|==
operator|(
name|HAVE_SIGSETMASK
operator|)
end_if

begin_define
define|#
directive|define
name|sigsetmask
parameter_list|(
name|n
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_comment
comment|/* This is how `error' returns to command level.  */
end_comment

begin_decl_stmt
name|jmp_buf
name|to_top_level
decl_stmt|;
end_decl_stmt

begin_function
name|NORETURN
name|void
name|return_to_top_level
parameter_list|()
block|{
name|quit_flag
operator|=
literal|0
expr_stmt|;
name|immediate_quit
operator|=
literal|0
expr_stmt|;
name|bpstat_clear_actions
argument_list|(
name|stop_bpstat
argument_list|)
expr_stmt|;
comment|/* Clear queued breakpoint commands */
name|disable_current_display
argument_list|()
expr_stmt|;
name|do_cleanups
argument_list|(
name|ALL_CLEANUPS
argument_list|)
expr_stmt|;
operator|(
name|NORETURN
name|void
operator|)
name|longjmp
argument_list|(
name|to_top_level
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Call FUNC with arg ARGS, catching any errors.    If there is no error, return the value returned by FUNC.    If there is an error, print ERRSTRING, print the specific error message, 		         then return zero.  */
end_comment

begin_function_decl
name|int
name|catch_errors
parameter_list|(
name|func
parameter_list|,
name|args
parameter_list|,
name|errstring
parameter_list|)
function_decl|int
parameter_list|(
function_decl|*func
end_function_decl

begin_expr_stmt
unit|)
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|char
modifier|*
name|args
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|errstring
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|jmp_buf
name|saved
decl_stmt|;
name|int
name|val
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|saved_cleanup_chain
decl_stmt|;
name|char
modifier|*
name|saved_error_pre_print
decl_stmt|;
name|saved_cleanup_chain
operator|=
name|save_cleanups
argument_list|()
expr_stmt|;
name|saved_error_pre_print
operator|=
name|error_pre_print
expr_stmt|;
name|memcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|saved
argument_list|,
operator|(
name|char
operator|*
operator|)
name|to_top_level
argument_list|,
sizeof|sizeof
argument_list|(
name|jmp_buf
argument_list|)
argument_list|)
expr_stmt|;
name|error_pre_print
operator|=
name|errstring
expr_stmt|;
if|if
condition|(
name|setjmp
argument_list|(
name|to_top_level
argument_list|)
operator|==
literal|0
condition|)
name|val
operator|=
call|(
modifier|*
name|func
call|)
argument_list|(
name|args
argument_list|)
expr_stmt|;
else|else
name|val
operator|=
literal|0
expr_stmt|;
name|restore_cleanups
argument_list|(
name|saved_cleanup_chain
argument_list|)
expr_stmt|;
name|error_pre_print
operator|=
name|saved_error_pre_print
expr_stmt|;
name|memcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|to_top_level
argument_list|,
operator|(
name|char
operator|*
operator|)
name|saved
argument_list|,
sizeof|sizeof
argument_list|(
name|jmp_buf
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|val
return|;
block|}
end_block

begin_comment
comment|/* Handler for SIGHUP.  */
end_comment

begin_function
specifier|static
name|void
name|disconnect
parameter_list|(
name|signo
parameter_list|)
name|int
name|signo
decl_stmt|;
block|{
name|catch_errors
argument_list|(
name|quit_cover
argument_list|,
name|NULL
argument_list|,
literal|"Could not kill inferior process"
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGHUP
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
name|kill
argument_list|(
name|getpid
argument_list|()
argument_list|,
name|SIGHUP
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Just a little helper function for disconnect().  */
end_comment

begin_function
specifier|static
name|int
name|quit_cover
parameter_list|(
name|s
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
block|{
name|caution
operator|=
literal|0
expr_stmt|;
comment|/* Throw caution to the wind -- we're exiting. 			   This prevents asking the user dumb questions.  */
name|quit_command
argument_list|(
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  * Source an init file if it exists.  */
end_comment

begin_function
name|void
name|sourcefile
parameter_list|(
name|file
parameter_list|)
name|char
modifier|*
name|file
decl_stmt|;
block|{
if|if
condition|(
name|access
argument_list|(
name|file
argument_list|,
name|R_OK
argument_list|)
operator|==
literal|0
condition|)
if|if
condition|(
operator|!
name|setjmp
argument_list|(
name|to_top_level
argument_list|)
condition|)
name|source_command
argument_list|(
name|file
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|do_cleanups
argument_list|(
name|ALL_CLEANUPS
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Source $HOME/.gdbinit and $cwd/.gdbinit.  * If X is enabled, also $HOME/.xgdbinit and $cwd/.xgdbinit.source  */
end_comment

begin_function
name|void
name|source_init_files
parameter_list|()
block|{
name|char
modifier|*
name|homedir
decl_stmt|,
name|initfile
index|[
literal|256
index|]
decl_stmt|;
name|int
name|samedir
init|=
literal|0
decl_stmt|;
comment|/* Read init file, if it exists in home directory  */
name|homedir
operator|=
name|getenv
argument_list|(
literal|"HOME"
argument_list|)
expr_stmt|;
if|if
condition|(
name|homedir
condition|)
block|{
name|struct
name|stat
name|homebuf
decl_stmt|,
name|cwdbuf
decl_stmt|;
name|sprintf
argument_list|(
name|initfile
argument_list|,
literal|"%s/%s"
argument_list|,
name|homedir
argument_list|,
name|gdbinit
argument_list|)
expr_stmt|;
name|sourcefile
argument_list|(
name|initfile
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|inhibit_windows
condition|)
block|{
name|sprintf
argument_list|(
name|initfile
argument_list|,
literal|"%s/.xgdbinit"
argument_list|,
name|homedir
argument_list|)
expr_stmt|;
name|sourcefile
argument_list|(
name|initfile
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|KERNELDEBUG
if|if
condition|(
name|kernel_debugging
condition|)
block|{
name|sprintf
argument_list|(
name|initfile
argument_list|,
literal|"%s/.kgdbinit"
argument_list|,
name|homedir
argument_list|)
expr_stmt|;
name|sourcefile
argument_list|(
name|initfile
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* Determine if current directory is the same as the home 		   directory, so we don't source the same file twice. */
name|bzero
argument_list|(
operator|&
name|homebuf
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|stat
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|cwdbuf
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|stat
argument_list|)
argument_list|)
expr_stmt|;
name|stat
argument_list|(
name|homedir
argument_list|,
operator|&
name|homebuf
argument_list|)
expr_stmt|;
name|stat
argument_list|(
literal|"."
argument_list|,
operator|&
name|cwdbuf
argument_list|)
expr_stmt|;
name|samedir
operator|=
name|bcmp
argument_list|(
operator|&
name|homebuf
argument_list|,
operator|&
name|cwdbuf
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|stat
argument_list|)
argument_list|)
operator|==
literal|0
expr_stmt|;
block|}
comment|/* Read the input file in the current directory, *if* it isn't 	   the same file (it should exist, also).  */
if|if
condition|(
operator|!
name|samedir
condition|)
block|{
name|sourcefile
argument_list|(
name|gdbinit
argument_list|)
expr_stmt|;
name|sourcefile
argument_list|(
literal|".xgdbinit"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|KERNELDEBUG
if|if
condition|(
name|kernel_debugging
condition|)
name|sourcefile
argument_list|(
literal|".kgdbinit"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
end_function

begin_comment
comment|/* Clean up on error during a "source" command (or execution of a    user-defined command).  */
end_comment

begin_function
name|void
name|source_cleanup
parameter_list|(
name|stream
parameter_list|)
name|FILE
modifier|*
name|stream
decl_stmt|;
block|{
comment|/* Restore the previous input stream.  */
name|instream
operator|=
name|stream
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Read commands from STREAM.  */
end_comment

begin_function
specifier|static
name|void
name|read_command_file
parameter_list|(
name|stream
parameter_list|)
name|FILE
modifier|*
name|stream
decl_stmt|;
block|{
name|struct
name|cleanup
modifier|*
name|cleanups
decl_stmt|;
name|cleanups
operator|=
name|make_cleanup
argument_list|(
name|source_cleanup
argument_list|,
name|instream
argument_list|)
expr_stmt|;
name|instream
operator|=
name|stream
expr_stmt|;
name|command_loop
argument_list|()
expr_stmt|;
name|do_cleanups
argument_list|(
name|cleanups
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Process the core file argument.  * We infer (lexically) from the name and (semantically) from the  * corresponding file type what the target is.  It's one of a live  * user process (pid), a user process core dump (core), a kernel  * crash dump (vmcore), a live kernel (/dev/mem), a remote kernel (/dev/ttya)  * or a remote internet host (@127.0.0.1).  */
end_comment

begin_function
name|void
name|do_core_arg
parameter_list|(
name|corefile
parameter_list|,
name|batch
parameter_list|)
name|char
modifier|*
name|corefile
decl_stmt|;
name|int
name|batch
decl_stmt|;
block|{
name|struct
name|stat
name|stb
decl_stmt|;
if|if
condition|(
name|setjmp
argument_list|(
name|to_top_level
argument_list|)
condition|)
return|return;
if|if
condition|(
name|corefile
index|[
literal|0
index|]
operator|==
literal|'@'
condition|)
comment|/* Internet host -- we're remote debugging. */
name|remote_open
argument_list|(
name|corefile
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|stat
argument_list|(
name|corefile
argument_list|,
operator|&
name|stb
argument_list|)
operator|==
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|KERNELDEBUG
if|if
condition|(
name|S_ISCHR
argument_list|(
name|stb
operator|.
name|st_mode
argument_list|)
condition|)
block|{
comment|/* 			 * character device -- either we're debugging a live 			 * kernel (/dev/mem, /dev/kmem) or a remote kernel 			 * over a serial link.  Use the heuristic that 			 * /dev/mem has a "small" major device number. 			 */
if|if
condition|(
name|major
argument_list|(
name|stb
operator|.
name|st_rdev
argument_list|)
operator|<=
literal|4
condition|)
comment|/* kernel memory */
name|kernel_core_open
argument_list|(
name|corefile
argument_list|,
operator|!
name|batch
argument_list|)
expr_stmt|;
else|else
name|remote_open
argument_list|(
name|corefile
argument_list|,
operator|!
name|batch
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|kernel_debugging
condition|)
comment|/* a kernel crash dump */
name|kernel_core_open
argument_list|(
name|corefile
argument_list|,
operator|!
name|batch
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
name|core_file_command
argument_list|(
name|corefile
argument_list|,
operator|!
name|batch
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|isdigit
argument_list|(
name|corefile
index|[
literal|0
index|]
argument_list|)
condition|)
name|attach_command
argument_list|(
name|corefile
argument_list|,
operator|!
name|batch
argument_list|)
expr_stmt|;
else|else
comment|/* 		 * stat() failed and arg isn't a pid 		 */
name|perror
argument_list|(
name|corefile
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|int
name|count
decl_stmt|;
specifier|static
name|int
name|inhibit_gdbinit
init|=
literal|0
decl_stmt|;
specifier|static
name|int
name|quiet
init|=
literal|1
decl_stmt|;
specifier|static
name|int
name|batch
init|=
literal|0
decl_stmt|;
comment|/* Pointers to various arguments from command line.  */
name|char
modifier|*
name|symarg
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|execarg
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|corearg
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|cdarg
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|ttyarg
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
comment|/* Pointers to all arguments of +command option.  */
name|char
modifier|*
modifier|*
name|cmdarg
decl_stmt|;
comment|/* Allocated size of cmdarg.  */
name|int
name|cmdsize
decl_stmt|;
comment|/* Number of elements of cmdarg used.  */
name|int
name|ncmd
decl_stmt|;
comment|/* Indices of all arguments of +directory option.  */
name|char
modifier|*
modifier|*
name|dirarg
decl_stmt|;
comment|/* Allocated size.  */
name|int
name|dirsize
decl_stmt|;
comment|/* Number of elements used.  */
name|int
name|ndir
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
comment|/* XXX Windows only for xgdb. */
name|char
modifier|*
name|strrchr
parameter_list|()
function_decl|;
if|if
condition|(
name|cp
operator|=
name|strrchr
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|'/'
argument_list|)
condition|)
operator|++
name|cp
expr_stmt|;
else|else
name|cp
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
operator|*
name|cp
operator|!=
literal|'x'
condition|)
name|inhibit_windows
operator|=
literal|1
expr_stmt|;
comment|/* This needs to happen before the first use of malloc.  */
name|init_malloc
argument_list|(
operator|(
name|PTR
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|ALIGN_STACK_ON_STARTUP
argument_list|)
name|i
operator|=
operator|(
name|int
operator|)
operator|&
name|count
operator|&
literal|0x3
expr_stmt|;
if|if
condition|(
name|i
operator|!=
literal|0
condition|)
name|alloca
argument_list|(
literal|4
operator|-
name|i
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* If error() is called from initialization code, just exit */
if|if
condition|(
name|setjmp
argument_list|(
name|to_top_level
argument_list|)
condition|)
block|{
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|cmdsize
operator|=
literal|1
expr_stmt|;
name|cmdarg
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
name|cmdsize
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|cmdarg
argument_list|)
argument_list|)
expr_stmt|;
name|ncmd
operator|=
literal|0
expr_stmt|;
name|dirsize
operator|=
literal|1
expr_stmt|;
name|dirarg
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
name|dirsize
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|dirarg
argument_list|)
argument_list|)
expr_stmt|;
name|ndir
operator|=
literal|0
expr_stmt|;
name|quit_flag
operator|=
literal|0
expr_stmt|;
name|instream
operator|=
name|stdin
expr_stmt|;
name|getcwd
argument_list|(
name|dirbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|dirbuf
argument_list|)
argument_list|)
expr_stmt|;
name|current_directory
operator|=
name|dirbuf
expr_stmt|;
ifdef|#
directive|ifdef
name|SET_STACK_LIMIT_HUGE
block|{
name|struct
name|rlimit
name|rlim
decl_stmt|;
comment|/* Set the stack limit huge so that alloca (particularly stringtab      * in dbxread.c) does not fail. */
name|getrlimit
argument_list|(
name|RLIMIT_STACK
argument_list|,
operator|&
name|rlim
argument_list|)
expr_stmt|;
name|original_stack_limit
operator|=
name|rlim
operator|.
name|rlim_cur
expr_stmt|;
name|rlim
operator|.
name|rlim_cur
operator|=
name|rlim
operator|.
name|rlim_max
expr_stmt|;
name|setrlimit
argument_list|(
name|RLIMIT_STACK
argument_list|,
operator|&
name|rlim
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* SET_STACK_LIMIT_HUGE */
comment|/* Parse arguments and options.  */
block|{
name|int
name|c
decl_stmt|;
specifier|static
name|int
name|print_help
decl_stmt|;
comment|/* When var field is 0, use flag field to record the equivalent        short option (or arbitrary numbers starting at 10 for those        with no equivalent).  */
specifier|static
name|struct
name|option
name|long_options
index|[]
init|=
block|{
block|{
literal|"readnow"
block|,
name|no_argument
block|,
operator|&
name|readnow_symbol_files
block|,
literal|1
block|}
block|,
block|{
literal|"r"
block|,
name|no_argument
block|,
operator|&
name|readnow_symbol_files
block|,
literal|1
block|}
block|,
block|{
literal|"mapped"
block|,
name|no_argument
block|,
operator|&
name|mapped_symbol_files
block|,
literal|1
block|}
block|,
block|{
literal|"m"
block|,
name|no_argument
block|,
operator|&
name|mapped_symbol_files
block|,
literal|1
block|}
block|,
block|{
literal|"quiet"
block|,
name|no_argument
block|,
operator|&
name|quiet
block|,
literal|1
block|}
block|,
block|{
literal|"q"
block|,
name|no_argument
block|,
operator|&
name|quiet
block|,
literal|1
block|}
block|,
block|{
literal|"version"
block|,
name|no_argument
block|,
operator|&
name|quiet
block|,
literal|0
block|}
block|,
block|{
literal|"nc"
block|,
name|no_argument
block|,
operator|&
name|inhibit_confirm
block|,
literal|1
block|}
block|,
block|{
literal|"nx"
block|,
name|no_argument
block|,
operator|&
name|inhibit_gdbinit
block|,
literal|1
block|}
block|,
block|{
literal|"nw"
block|,
name|no_argument
block|,
operator|&
name|inhibit_windows
block|,
literal|1
block|}
block|,
block|{
literal|"n"
block|,
name|no_argument
block|,
operator|&
name|inhibit_gdbinit
block|,
literal|1
block|}
block|,
block|{
literal|"batch"
block|,
name|no_argument
block|,
operator|&
name|batch
block|,
literal|1
block|}
block|,
block|{
literal|"epoch"
block|,
name|no_argument
block|,
operator|&
name|epoch_interface
block|,
literal|1
block|}
block|,
block|{
literal|"fullname"
block|,
name|no_argument
block|,
operator|&
name|frame_file_full_name
block|,
literal|1
block|}
block|,
block|{
literal|"f"
block|,
name|no_argument
block|,
operator|&
name|frame_file_full_name
block|,
literal|1
block|}
block|,
block|{
literal|"help"
block|,
name|no_argument
block|,
operator|&
name|print_help
block|,
literal|1
block|}
block|,
block|{
literal|"se"
block|,
name|required_argument
block|,
literal|0
block|,
literal|10
block|}
block|,
block|{
literal|"symbols"
block|,
name|required_argument
block|,
literal|0
block|,
literal|'s'
block|}
block|,
block|{
literal|"s"
block|,
name|required_argument
block|,
literal|0
block|,
literal|'s'
block|}
block|,
block|{
literal|"exec"
block|,
name|required_argument
block|,
literal|0
block|,
literal|'e'
block|}
block|,
block|{
literal|"e"
block|,
name|required_argument
block|,
literal|0
block|,
literal|'e'
block|}
block|,
block|{
literal|"core"
block|,
name|required_argument
block|,
literal|0
block|,
literal|'c'
block|}
block|,
block|{
literal|"c"
block|,
name|required_argument
block|,
literal|0
block|,
literal|'c'
block|}
block|,
block|{
literal|"command"
block|,
name|required_argument
block|,
literal|0
block|,
literal|'x'
block|}
block|,
block|{
literal|"x"
block|,
name|required_argument
block|,
literal|0
block|,
literal|'x'
block|}
block|,
block|{
literal|"directory"
block|,
name|required_argument
block|,
literal|0
block|,
literal|'d'
block|}
block|,
block|{
literal|"cd"
block|,
name|required_argument
block|,
literal|0
block|,
literal|11
block|}
block|,
block|{
literal|"tty"
block|,
name|required_argument
block|,
literal|0
block|,
literal|'t'
block|}
block|,
block|{
literal|"baud"
block|,
name|required_argument
block|,
literal|0
block|,
literal|'b'
block|}
block|,
block|{
literal|"b"
block|,
name|required_argument
block|,
literal|0
block|,
literal|'b'
block|}
block|,
block|{
literal|"w"
block|,
name|no_argument
block|,
operator|&
name|write_files
block|,
literal|1
block|}
block|,
ifdef|#
directive|ifdef
name|KERNELDEBUG
block|{
literal|"k"
block|,
name|no_argument
block|,
operator|&
name|kernel_debugging
block|,
literal|1
block|}
block|,
endif|#
directive|endif
comment|/* Allow machine descriptions to add more options... */
ifdef|#
directive|ifdef
name|ADDITIONAL_OPTIONS
name|ADDITIONAL_OPTIONS
endif|#
directive|endif
block|{
literal|0
block|,
name|no_argument
block|,
literal|0
block|,
literal|0
block|}
block|,       }
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|int
name|option_index
decl_stmt|;
name|c
operator|=
name|getopt_long_only
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|""
argument_list|,
name|long_options
argument_list|,
operator|&
name|option_index
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
break|break;
comment|/* Long option that takes an argument.  */
if|if
condition|(
name|c
operator|==
literal|0
operator|&&
name|long_options
index|[
name|option_index
index|]
operator|.
name|flag
operator|==
literal|0
condition|)
name|c
operator|=
name|long_options
index|[
name|option_index
index|]
operator|.
name|val
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|0
case|:
comment|/* Long option that just sets a flag.  */
break|break;
case|case
literal|10
case|:
name|symarg
operator|=
name|optarg
expr_stmt|;
name|execarg
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|11
case|:
name|cdarg
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
name|symarg
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
name|execarg
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
name|corearg
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
name|cmdarg
index|[
name|ncmd
operator|++
index|]
operator|=
name|optarg
expr_stmt|;
if|if
condition|(
name|ncmd
operator|>=
name|cmdsize
condition|)
block|{
name|cmdsize
operator|*=
literal|2
expr_stmt|;
name|cmdarg
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xrealloc
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cmdarg
argument_list|,
name|cmdsize
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|cmdarg
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'d'
case|:
name|dirarg
index|[
name|ndir
operator|++
index|]
operator|=
name|optarg
expr_stmt|;
if|if
condition|(
name|ndir
operator|>=
name|dirsize
condition|)
block|{
name|dirsize
operator|*=
literal|2
expr_stmt|;
name|dirarg
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xrealloc
argument_list|(
operator|(
name|char
operator|*
operator|)
name|dirarg
argument_list|,
name|dirsize
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|dirarg
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'t'
case|:
name|ttyarg
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'q'
case|:
name|quiet
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
name|baud_rate
operator|=
name|optarg
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|ADDITIONAL_OPTION_CASES
name|ADDITIONAL_OPTION_CASES
endif|#
directive|endif
case|case
literal|'?'
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Use `%s +help' for a complete list of options.\n"
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|print_help
condition|)
block|{
name|fputs
argument_list|(
literal|"\ This is GDB, the GNU debugger.  Use the command\n\     gdb [options] [executable [core-file]]\n\ to enter the debugger.\n\ \n\ Options available are:\n\   -help             Print this message.\n\   -quiet            Do not print version number on startup.\n\   -fullname         Output information used by emacs-GDB interface.\n\   -epoch            Output information used by epoch emacs-GDB interface.\n\   -batch            Exit after processing options.\n\   -nx               Do not read .gdbinit file.\n\   -tty=TTY          Use TTY for input/output by the program being debugged.\n\   -cd=DIR           Change current directory to DIR.\n\   -directory=DIR    Search for source files in DIR.\n\   -command=FILE     Execute GDB commands from FILE.\n\   -symbols=SYMFILE  Read symbols from SYMFILE.\n\   -exec=EXECFILE    Use EXECFILE as the executable.\n\   -se=FILE          Use FILE as symbol file and executable file.\n\   -core=COREFILE    Analyze the core dump COREFILE.\n\   -b BAUDRATE       Set serial port baud rate used for remote debugging.\n\   -mapped           Use mapped symbol files if supported on this system.\n\   -readnow          Fully read symbol files on first access.\n\   -k                Kernel debugging.\n\   -w                Writeable text.\n\   -version          Print GNU message and version number on startup.\n\   -nc               Don't confirm quit or run commands.\n\ "
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ADDITIONAL_OPTION_HELP
name|fputs
argument_list|(
name|ADDITIONAL_OPTION_HELP
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|fputs
argument_list|(
literal|"\n\ For more information, type \"help\" from within GDB, or consult the\n\ GDB manual (available as on-line info or a printed manual).\n"
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
comment|/* Exiting after printing this message seems like 	   the most useful thing to do.  */
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* OK, that's all the options.  The other arguments are filenames.  */
name|count
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
name|optind
operator|<
name|argc
condition|;
name|optind
operator|++
control|)
switch|switch
condition|(
operator|++
name|count
condition|)
block|{
case|case
literal|1
case|:
name|symarg
operator|=
name|argv
index|[
name|optind
index|]
expr_stmt|;
name|execarg
operator|=
name|argv
index|[
name|optind
index|]
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|corearg
operator|=
name|argv
index|[
name|optind
index|]
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Excess command line arguments ignored. (%s%s)\n"
argument_list|,
name|argv
index|[
name|optind
index|]
argument_list|,
operator|(
name|optind
operator|==
name|argc
operator|-
literal|1
operator|)
condition|?
literal|""
else|:
literal|" ..."
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|batch
condition|)
name|quiet
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Run the init function of each source file */
name|initialize_cmd_lists
argument_list|()
expr_stmt|;
comment|/* This needs to be done first */
name|initialize_all_files
argument_list|()
expr_stmt|;
name|initialize_main
argument_list|()
expr_stmt|;
comment|/* But that omits this file!  Do it now */
name|init_signals
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|quiet
condition|)
block|{
comment|/* Print all the junk at the top, with trailing "..." if we are about 	 to read a symbol file (possibly slowly).  */
name|print_gnu_advertisement
argument_list|()
expr_stmt|;
name|print_gdb_version
argument_list|()
expr_stmt|;
if|if
condition|(
name|symarg
condition|)
name|printf_filtered
argument_list|(
literal|".."
argument_list|)
expr_stmt|;
name|wrap_here
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
comment|/* Force to screen during slow operations */
block|}
name|error_pre_print
operator|=
literal|"\n\n"
expr_stmt|;
comment|/* We may get more than one warning, don't double space all of them... */
name|warning_pre_print
operator|=
literal|"\nwarning: "
expr_stmt|;
comment|/* We need a default language for parsing expressions, so simple things like      "set width 0" won't fail if no language is explicitly set in a config file      or implicitly set by reading an executable during startup. */
name|set_language
argument_list|(
name|language_c
argument_list|)
expr_stmt|;
name|expected_language
operator|=
name|current_language
expr_stmt|;
comment|/* don't warn about the change.  */
comment|/* Now perform all the actions indicated by the arguments.  */
if|if
condition|(
name|cdarg
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|setjmp
argument_list|(
name|to_top_level
argument_list|)
condition|)
block|{
name|cd_command
argument_list|(
name|cdarg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|init_source_path
argument_list|()
expr_stmt|;
block|}
block|}
name|do_cleanups
argument_list|(
name|ALL_CLEANUPS
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ndir
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|setjmp
argument_list|(
name|to_top_level
argument_list|)
condition|)
name|directory_command
argument_list|(
name|dirarg
index|[
name|i
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|PTR
operator|)
name|dirarg
argument_list|)
expr_stmt|;
name|do_cleanups
argument_list|(
name|ALL_CLEANUPS
argument_list|)
expr_stmt|;
if|if
condition|(
name|execarg
operator|!=
name|NULL
operator|&&
name|symarg
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
name|execarg
argument_list|,
name|symarg
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* The exec file and the symbol-file are the same.  If we can't open 	 it, better only print one error message.  */
if|if
condition|(
operator|!
name|setjmp
argument_list|(
name|to_top_level
argument_list|)
condition|)
block|{
name|exec_file_command
argument_list|(
name|execarg
argument_list|,
operator|!
name|batch
argument_list|)
expr_stmt|;
name|symbol_file_command
argument_list|(
name|symarg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|execarg
operator|!=
name|NULL
condition|)
if|if
condition|(
operator|!
name|setjmp
argument_list|(
name|to_top_level
argument_list|)
condition|)
name|exec_file_command
argument_list|(
name|execarg
argument_list|,
operator|!
name|batch
argument_list|)
expr_stmt|;
if|if
condition|(
name|symarg
operator|!=
name|NULL
condition|)
if|if
condition|(
operator|!
name|setjmp
argument_list|(
name|to_top_level
argument_list|)
condition|)
name|symbol_file_command
argument_list|(
name|symarg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|do_cleanups
argument_list|(
name|ALL_CLEANUPS
argument_list|)
expr_stmt|;
comment|/* After the symbol file has been read, print a newline to get us      beyond the copyright line...  But errors should still set off      the error message with a (single) blank line.  */
if|if
condition|(
operator|!
name|quiet
condition|)
name|printf_filtered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|error_pre_print
operator|=
literal|"\n"
expr_stmt|;
name|warning_pre_print
operator|=
literal|"\nwarning: "
expr_stmt|;
if|if
condition|(
name|corearg
operator|!=
name|NULL
condition|)
name|do_core_arg
argument_list|(
name|corearg
argument_list|,
name|batch
argument_list|)
expr_stmt|;
name|do_cleanups
argument_list|(
name|ALL_CLEANUPS
argument_list|)
expr_stmt|;
if|if
condition|(
name|ttyarg
operator|!=
name|NULL
condition|)
if|if
condition|(
operator|!
name|setjmp
argument_list|(
name|to_top_level
argument_list|)
condition|)
name|tty_command
argument_list|(
name|ttyarg
argument_list|,
operator|!
name|batch
argument_list|)
expr_stmt|;
name|do_cleanups
argument_list|(
name|ALL_CLEANUPS
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ADDITIONAL_OPTION_HANDLER
name|ADDITIONAL_OPTION_HANDLER
expr_stmt|;
endif|#
directive|endif
comment|/* Error messages should no longer be distinguished with extra output. */
name|error_pre_print
operator|=
literal|0
expr_stmt|;
name|warning_pre_print
operator|=
literal|"warning: "
expr_stmt|;
if|if
condition|(
operator|!
name|inhibit_gdbinit
condition|)
name|source_init_files
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ncmd
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|setjmp
argument_list|(
name|to_top_level
argument_list|)
condition|)
block|{
if|if
condition|(
name|cmdarg
index|[
name|i
index|]
index|[
literal|0
index|]
operator|==
literal|'-'
operator|&&
name|cmdarg
index|[
name|i
index|]
index|[
literal|1
index|]
operator|==
literal|'\0'
condition|)
name|read_command_file
argument_list|(
name|stdin
argument_list|)
expr_stmt|;
else|else
name|source_command
argument_list|(
name|cmdarg
index|[
name|i
index|]
argument_list|,
operator|!
name|batch
argument_list|)
expr_stmt|;
name|do_cleanups
argument_list|(
name|ALL_CLEANUPS
argument_list|)
expr_stmt|;
block|}
block|}
name|free
argument_list|(
operator|(
name|PTR
operator|)
name|cmdarg
argument_list|)
expr_stmt|;
comment|/* Read in the old history after all the command files have been read. */
name|initialize_history
argument_list|()
expr_stmt|;
if|if
condition|(
name|batch
condition|)
block|{
comment|/* We have hit the end of the batch file.  */
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* Do any host- or target-specific hacks.  This is used for i960 targets      to force the user to set a nindy target and spec its parameters.  */
ifdef|#
directive|ifdef
name|BEFORE_MAIN_LOOP_HOOK
name|BEFORE_MAIN_LOOP_HOOK
expr_stmt|;
endif|#
directive|endif
comment|/* The command loop.  */
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
operator|!
name|setjmp
argument_list|(
name|to_top_level
argument_list|)
condition|)
block|{
name|do_cleanups
argument_list|(
name|ALL_CLEANUPS
argument_list|)
expr_stmt|;
comment|/* Do complete cleanup */
name|command_loop
argument_list|()
expr_stmt|;
name|quit_command
argument_list|(
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
name|instream
operator|==
name|stdin
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* No exit -- exit is through quit_command.  */
block|}
end_function

begin_function
name|void
name|execute_user_command
parameter_list|(
name|c
parameter_list|,
name|args
parameter_list|)
name|struct
name|cmd_list_element
modifier|*
name|c
decl_stmt|;
name|char
modifier|*
name|args
decl_stmt|;
block|{
specifier|register
name|struct
name|command_line
modifier|*
name|cmdlines
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|old_chain
decl_stmt|;
if|if
condition|(
name|args
condition|)
name|error
argument_list|(
literal|"User-defined commands cannot take arguments."
argument_list|)
expr_stmt|;
name|cmdlines
operator|=
name|c
operator|->
name|user_commands
expr_stmt|;
if|if
condition|(
name|cmdlines
operator|==
literal|0
condition|)
comment|/* Null command */
return|return;
comment|/* Set the instream to 0, indicating execution of a      user-defined function.  */
name|old_chain
operator|=
name|make_cleanup
argument_list|(
name|source_cleanup
argument_list|,
name|instream
argument_list|)
expr_stmt|;
name|instream
operator|=
operator|(
name|FILE
operator|*
operator|)
literal|0
expr_stmt|;
while|while
condition|(
name|cmdlines
condition|)
block|{
name|execute_command
argument_list|(
name|cmdlines
operator|->
name|line
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cmdlines
operator|=
name|cmdlines
operator|->
name|next
expr_stmt|;
block|}
name|do_cleanups
argument_list|(
name|old_chain
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|void
name|command_loop_marker
parameter_list|(
name|foo
parameter_list|)
name|int
name|foo
decl_stmt|;
block|{ }
end_function

begin_comment
comment|/* Read commands from `instream' and execute them    until end of file or error reading instream.  */
end_comment

begin_function
specifier|static
name|void
name|command_loop
parameter_list|()
block|{
name|struct
name|cleanup
modifier|*
name|old_chain
decl_stmt|;
specifier|register
name|int
name|toplevel
init|=
operator|(
name|instream
operator|==
name|stdin
operator|)
decl_stmt|;
specifier|register
name|int
name|interactive
init|=
operator|(
name|toplevel
operator|&&
name|ISATTY
argument_list|(
name|stdin
argument_list|)
operator|)
decl_stmt|;
while|while
condition|(
operator|!
name|feof
argument_list|(
name|instream
argument_list|)
condition|)
block|{
specifier|register
name|char
modifier|*
name|cmd_line
decl_stmt|;
name|quit_flag
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|interactive
condition|)
name|reinitialize_more_filter
argument_list|()
expr_stmt|;
name|old_chain
operator|=
name|make_cleanup
argument_list|(
name|command_loop_marker
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cmd_line
operator|=
name|command_line_input
argument_list|(
name|toplevel
condition|?
name|masterprompt
else|:
literal|0
argument_list|,
name|toplevel
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmd_line
operator|==
literal|0
condition|)
block|{
name|do_cleanups
argument_list|(
name|old_chain
argument_list|)
expr_stmt|;
return|return;
block|}
name|execute_command
argument_list|(
name|cmd_line
argument_list|,
name|toplevel
argument_list|)
expr_stmt|;
comment|/* Do any commands attached to breakpoint we stopped at.  */
name|bpstat_do_actions
argument_list|(
operator|&
name|stop_bpstat
argument_list|)
expr_stmt|;
name|do_cleanups
argument_list|(
name|old_chain
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Read a line from the stream "instream" without command line editing.     It prints PROMPT once at the start.    Action is compatible with "readline", e.g. space for the result is     malloc'd and should be freed by the caller.     A NULL return means end of file.  */
end_comment

begin_function
name|char
modifier|*
name|gdb_readline
parameter_list|(
name|prompt
parameter_list|)
name|char
modifier|*
name|prompt
decl_stmt|;
block|{
name|int
name|c
decl_stmt|;
name|char
modifier|*
name|result
decl_stmt|;
name|int
name|input_index
init|=
literal|0
decl_stmt|;
name|int
name|result_size
init|=
literal|80
decl_stmt|;
if|if
condition|(
name|prompt
condition|)
block|{
comment|/* Don't use a _filtered function here.  It causes the assumed 	 character position to be off, since the newline we read from 	 the user is not accounted for.  */
name|fputs
argument_list|(
name|prompt
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
name|result
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|result_size
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
comment|/* Read from stdin if we are executing a user defined command. 	 This is the right thing for prompt_for_continue, at least.  */
name|c
operator|=
name|fgetc
argument_list|(
name|instream
condition|?
name|instream
else|:
name|stdin
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
block|{
name|free
argument_list|(
name|result
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
break|break;
name|result
index|[
name|input_index
operator|++
index|]
operator|=
name|c
expr_stmt|;
while|while
condition|(
name|input_index
operator|>=
name|result_size
condition|)
block|{
name|result_size
operator|*=
literal|2
expr_stmt|;
name|result
operator|=
operator|(
name|char
operator|*
operator|)
name|xrealloc
argument_list|(
name|result
argument_list|,
name|result_size
argument_list|)
expr_stmt|;
block|}
block|}
name|result
index|[
name|input_index
operator|++
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Variables which control command line editing and history    substitution.  These variables are given default values at the end    of this file.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|write_history_p
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|history_size
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|history_filename
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Variables which are necessary for fancy command line editing.  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|gdb_completer_word_break_characters
init|=
literal|" \t\n!@#$%^&*()+=|~`}{[]\"';?/>.<,-"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* When completing on command names, we remove '-' from the list of    word break characters, since we use it in command names.  If the    readline library sees one in any of the current completion strings,    it thinks that the string needs to be quoted and automatically supplies    a leading quote. */
end_comment

begin_decl_stmt
name|char
modifier|*
name|gdb_completer_command_word_break_characters
init|=
literal|" \t\n!@#$%^&*()+=|~`}{[]\"';?/>.<,"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Characters that can be used to quote completion strings.  Note that we    can't include '"' because the gdb C parser treats such quoted sequences    as strings. */
end_comment

begin_decl_stmt
name|char
modifier|*
name|gdb_completer_quote_characters
init|=
literal|"'"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Functions that are used as part of the fancy command line editing.  */
end_comment

begin_comment
comment|/* This can be used for functions which don't want to complete on symbols    but don't want to complete on anything else either.  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|char
modifier|*
modifier|*
name|noop_completer
parameter_list|(
name|text
parameter_list|)
name|char
modifier|*
name|text
decl_stmt|;
block|{
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Generate symbol names one by one for the completer.  Each time we are    called return another potential completion to the caller.     TEXT is what we expect the symbol to start with.     MATCHES is the number of matches that have currently been collected from    calling this completion function.  When zero, then we need to initialize,    otherwise the initialization has already taken place and we can just    return the next potential completion string.     Returns NULL if there are no more completions, else a pointer to a string    which is a possible completion.     RL_LINE_BUFFER is available to be looked at; it contains the entire text    of the line.  RL_POINT is the offset in that line of the cursor.  You    should pretend that the line ends at RL_POINT. */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|symbol_completion_function
parameter_list|(
name|text
parameter_list|,
name|matches
parameter_list|)
name|char
modifier|*
name|text
decl_stmt|;
name|int
name|matches
decl_stmt|;
block|{
specifier|static
name|char
modifier|*
modifier|*
name|list
init|=
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
decl_stmt|;
comment|/* Cache of completions */
specifier|static
name|int
name|index
decl_stmt|;
comment|/* Next cached completion */
name|char
modifier|*
name|output
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|tmp_command
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|struct
name|cmd_list_element
modifier|*
name|c
decl_stmt|,
modifier|*
name|result_list
decl_stmt|;
specifier|extern
name|char
modifier|*
name|rl_line_buffer
decl_stmt|;
specifier|extern
name|int
name|rl_point
decl_stmt|;
if|if
condition|(
name|matches
operator|==
literal|0
condition|)
block|{
comment|/* The caller is beginning to accumulate a new set of completions, so 	 we need to find all of them now, and cache them for returning one at 	 a time on future calls. */
if|if
condition|(
name|list
condition|)
block|{
comment|/* Free the storage used by LIST, but not by the strings inside. 	     This is because rl_complete_internal () frees the strings. */
name|free
argument_list|(
operator|(
name|PTR
operator|)
name|list
argument_list|)
expr_stmt|;
block|}
name|list
operator|=
literal|0
expr_stmt|;
name|index
operator|=
literal|0
expr_stmt|;
comment|/* Choose the default set of word break characters to break completions. 	 If we later find out that we are doing completions on command strings 	 (as opposed to strings supplied by the individual command completer 	 functions, which can be any string) then we will switch to the 	 special word break set for command strings, which leaves out the 	 '-' character used in some commands. */
name|rl_completer_word_break_characters
operator|=
name|gdb_completer_word_break_characters
expr_stmt|;
comment|/* Decide whether to complete on a list of gdb commands or on symbols. */
name|tmp_command
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|rl_point
operator|+
literal|1
argument_list|)
expr_stmt|;
name|p
operator|=
name|tmp_command
expr_stmt|;
name|strncpy
argument_list|(
name|tmp_command
argument_list|,
name|rl_line_buffer
argument_list|,
name|rl_point
argument_list|)
expr_stmt|;
name|tmp_command
index|[
name|rl_point
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|rl_point
operator|==
literal|0
condition|)
block|{
comment|/* An empty line we want to consider ambiguous; that is, it 	     could be any command.  */
name|c
operator|=
operator|(
expr|struct
name|cmd_list_element
operator|*
operator|)
operator|-
literal|1
expr_stmt|;
name|result_list
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|c
operator|=
name|lookup_cmd_1
argument_list|(
operator|&
name|p
argument_list|,
name|cmdlist
argument_list|,
operator|&
name|result_list
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Move p up to the next interesting thing.  */
while|while
condition|(
operator|*
name|p
operator|==
literal|' '
operator|||
operator|*
name|p
operator|==
literal|'\t'
condition|)
block|{
name|p
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|c
condition|)
block|{
comment|/* He's typed something unrecognizable.  Sigh.  */
name|list
operator|=
name|NULL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
operator|(
expr|struct
name|cmd_list_element
operator|*
operator|)
operator|-
literal|1
condition|)
block|{
comment|/* If we didn't recognize everything up to the thing that 	     needs completing, and we don't know what command it is 	     yet, we are in trouble. */
if|if
condition|(
name|p
operator|+
name|strlen
argument_list|(
name|text
argument_list|)
operator|!=
name|tmp_command
operator|+
name|rl_point
condition|)
block|{
comment|/* This really should not produce an error.  Better would 		 be to pretend to hit RETURN here; this would produce a 		 response like "Ambiguous command: foo, foobar, etc", 		 and leave the line available for re-entry with ^P. 		 Instead, this error blows away the user's typed input 		 without any way to get it back.  */
name|error
argument_list|(
literal|"  Unrecognized command."
argument_list|)
expr_stmt|;
block|}
comment|/* He's typed something ambiguous.  This is easier.  */
if|if
condition|(
name|result_list
condition|)
block|{
name|list
operator|=
name|complete_on_cmdlist
argument_list|(
operator|*
name|result_list
operator|->
name|prefixlist
argument_list|,
name|text
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|list
operator|=
name|complete_on_cmdlist
argument_list|(
name|cmdlist
argument_list|,
name|text
argument_list|)
expr_stmt|;
block|}
name|rl_completer_word_break_characters
operator|=
name|gdb_completer_command_word_break_characters
expr_stmt|;
block|}
else|else
block|{
comment|/* If we've gotten this far, gdb has recognized a full 	     command.  There are several possibilities:  	     1) We need to complete on the command. 	     2) We need to complete on the possibilities coming after 	     the command. 	     2) We need to complete the text of what comes after the 	     command.   */
if|if
condition|(
operator|!
operator|*
name|p
operator|&&
operator|*
name|text
condition|)
block|{
comment|/* Always (might be longer versions of thie command).  */
name|list
operator|=
name|complete_on_cmdlist
argument_list|(
name|result_list
argument_list|,
name|text
argument_list|)
expr_stmt|;
name|rl_completer_word_break_characters
operator|=
name|gdb_completer_command_word_break_characters
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
operator|*
name|p
operator|&&
operator|!
operator|*
name|text
condition|)
block|{
if|if
condition|(
name|c
operator|->
name|prefixlist
condition|)
block|{
name|list
operator|=
name|complete_on_cmdlist
argument_list|(
operator|*
name|c
operator|->
name|prefixlist
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|rl_completer_word_break_characters
operator|=
name|gdb_completer_command_word_break_characters
expr_stmt|;
block|}
else|else
block|{
name|list
operator|=
call|(
modifier|*
name|c
operator|->
name|completer
call|)
argument_list|(
literal|""
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|c
operator|->
name|prefixlist
operator|&&
operator|!
name|c
operator|->
name|allow_unknown
condition|)
block|{
comment|/* Something like "info adsfkdj".  But error() is not the 		     proper response; just return no completions instead. */
name|list
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|list
operator|=
call|(
modifier|*
name|c
operator|->
name|completer
call|)
argument_list|(
name|text
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/* If we found a list of potential completions during initialization then      dole them out one at a time.  The vector of completions is NULL      terminated, so after returning the last one, return NULL (and continue      to do so) each time we are called after that, until a new list is      available. */
if|if
condition|(
name|list
condition|)
block|{
name|output
operator|=
name|list
index|[
name|index
index|]
expr_stmt|;
if|if
condition|(
name|output
condition|)
block|{
name|index
operator|++
expr_stmt|;
block|}
block|}
return|return
operator|(
name|output
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Skip over a possibly quoted word (as defined by the quote characters    and word break characters the completer uses).  Returns pointer to the    location after the "word". */
end_comment

begin_function
name|char
modifier|*
name|skip_quoted
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|char
name|quote_char
init|=
literal|'\0'
decl_stmt|;
name|char
modifier|*
name|scan
decl_stmt|;
for|for
control|(
name|scan
operator|=
name|str
init|;
operator|*
name|scan
operator|!=
literal|'\0'
condition|;
name|scan
operator|++
control|)
block|{
if|if
condition|(
name|quote_char
operator|!=
literal|'\0'
condition|)
block|{
comment|/* Ignore everything until the matching close quote char */
if|if
condition|(
operator|*
name|scan
operator|==
name|quote_char
condition|)
block|{
comment|/* Found matching close quote. */
name|scan
operator|++
expr_stmt|;
break|break;
block|}
block|}
elseif|else
if|if
condition|(
name|strchr
argument_list|(
name|gdb_completer_quote_characters
argument_list|,
operator|*
name|scan
argument_list|)
condition|)
block|{
comment|/* Found start of a quoted string. */
name|quote_char
operator|=
operator|*
name|scan
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strchr
argument_list|(
name|gdb_completer_word_break_characters
argument_list|,
operator|*
name|scan
argument_list|)
condition|)
block|{
break|break;
block|}
block|}
return|return
operator|(
name|scan
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|STOP_SIGNAL
end_ifdef

begin_function
specifier|static
name|void
name|stop_sig
parameter_list|(
name|signo
parameter_list|)
name|int
name|signo
decl_stmt|;
block|{
if|#
directive|if
name|STOP_SIGNAL
operator|==
name|SIGTSTP
name|signal
argument_list|(
name|SIGTSTP
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
name|sigsetmask
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|kill
argument_list|(
name|getpid
argument_list|()
argument_list|,
name|SIGTSTP
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGTSTP
argument_list|,
name|stop_sig
argument_list|)
expr_stmt|;
else|#
directive|else
name|signal
argument_list|(
name|STOP_SIGNAL
argument_list|,
name|stop_sig
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|masterprompt
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
comment|/* Forget about any previous command -- null line now will do nothing.  */
name|dont_repeat
argument_list|()
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* STOP_SIGNAL */
end_comment

begin_comment
comment|/* Initialize signal handlers. */
end_comment

begin_function
specifier|static
name|void
name|do_nothing
parameter_list|(
name|signo
parameter_list|)
name|int
name|signo
decl_stmt|;
block|{ }
end_function

begin_function_decl
specifier|static
name|void
name|suspend_sig
parameter_list|()
function_decl|;
end_function_decl

begin_function
specifier|static
name|void
name|init_signals
parameter_list|()
block|{
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|request_quit
argument_list|)
expr_stmt|;
comment|/* If we initialize SIGQUIT to SIG_IGN, then the SIG_IGN will get      passed to the inferior, which we don't want.  It would be      possible to do a "signal (SIGQUIT, SIG_DFL)" after we fork, but      on BSD4.3 systems using vfork, that will (apparently) affect the      GDB process as well as the inferior (the signal handling tables      being shared between the two, apparently).  Since we establish      a handler for SIGQUIT, when we call exec it will set the signal      to SIG_DFL for us.  */
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|do_nothing
argument_list|)
expr_stmt|;
if|if
condition|(
name|signal
argument_list|(
name|SIGHUP
argument_list|,
name|do_nothing
argument_list|)
operator|!=
name|SIG_IGN
condition|)
name|signal
argument_list|(
name|SIGHUP
argument_list|,
name|disconnect
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGFPE
argument_list|,
name|float_handler
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|SIGWINCH
argument_list|)
operator|&&
name|defined
argument_list|(
name|SIGWINCH_HANDLER
argument_list|)
name|signal
argument_list|(
name|SIGWINCH
argument_list|,
name|SIGWINCH_HANDLER
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|init_term
argument_list|(
name|fileno
argument_list|(
name|stdin
argument_list|)
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGTSTP
argument_list|,
name|suspend_sig
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Execute the line P as a command.    Pass FROM_TTY as second argument to the defining function.  */
end_comment

begin_function
name|void
name|execute_command
parameter_list|(
name|p
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
specifier|register
name|struct
name|cmd_list_element
modifier|*
name|c
decl_stmt|;
specifier|register
name|struct
name|command_line
modifier|*
name|cmdlines
decl_stmt|;
specifier|register
name|enum
name|language
name|flang
decl_stmt|;
specifier|static
specifier|const
name|struct
name|language_defn
modifier|*
name|saved_language
init|=
literal|0
decl_stmt|;
specifier|static
name|int
name|warned
init|=
literal|0
decl_stmt|;
name|free_all_values
argument_list|()
expr_stmt|;
comment|/* This can happen when command_line_input hits end of file.  */
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
return|return;
while|while
condition|(
operator|*
name|p
operator|==
literal|' '
operator|||
operator|*
name|p
operator|==
literal|'\t'
condition|)
name|p
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|p
condition|)
block|{
name|char
modifier|*
name|arg
decl_stmt|;
name|c
operator|=
name|lookup_cmd
argument_list|(
operator|&
name|p
argument_list|,
name|cmdlist
argument_list|,
literal|""
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Pass null arg rather than an empty one.  */
name|arg
operator|=
operator|*
name|p
condition|?
name|p
else|:
literal|0
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|function
operator|.
name|cfunc
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"That is not a command, just a help topic."
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|->
name|class
operator|==
operator|(
name|int
operator|)
name|class_user
condition|)
block|{
specifier|extern
name|struct
name|cleanup
modifier|*
name|setup_user_args
parameter_list|()
function_decl|;
name|struct
name|cleanup
modifier|*
name|old_chain
init|=
name|setup_user_args
argument_list|(
name|p
argument_list|)
decl_stmt|;
if|if
condition|(
name|c
operator|->
name|user_commands
operator|!=
literal|0
condition|)
operator|(
name|void
operator|)
name|execute_command_lines
argument_list|(
name|c
operator|->
name|user_commands
argument_list|)
expr_stmt|;
name|do_cleanups
argument_list|(
name|old_chain
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|->
name|type
operator|==
name|set_cmd
operator|||
name|c
operator|->
name|type
operator|==
name|show_cmd
condition|)
name|do_setshow_command
argument_list|(
name|arg
argument_list|,
name|from_tty
operator|&
name|caution
argument_list|,
name|c
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|->
name|function
operator|.
name|cfunc
operator|==
name|NO_FUNCTION
condition|)
name|error
argument_list|(
literal|"That is not a command, just a help topic."
argument_list|)
expr_stmt|;
else|else
call|(
modifier|*
name|c
operator|->
name|function
operator|.
name|cfunc
call|)
argument_list|(
name|arg
argument_list|,
name|from_tty
operator|&
name|caution
argument_list|)
expr_stmt|;
block|}
comment|/* Tell the user if the language has changed (except first time).  */
if|if
condition|(
name|current_language
operator|!=
name|saved_language
condition|)
block|{
if|if
condition|(
name|language_mode
operator|==
name|language_mode_auto
condition|)
block|{
if|if
condition|(
name|saved_language
condition|)
name|language_info
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|saved_language
operator|=
name|current_language
expr_stmt|;
name|warned
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Warn the user if the working language does not match the      language of the current frame.  Only warn the user if we are      actually running the program, i.e. there is a stack. */
comment|/* FIXME:  This should be cacheing the frame and only running when      the frame changes.  */
if|if
condition|(
name|target_has_stack
condition|)
block|{
name|flang
operator|=
name|get_frame_language
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|warned
operator|&&
name|flang
operator|!=
name|language_unknown
operator|&&
name|flang
operator|!=
name|current_language
operator|->
name|la_language
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"%s\n"
argument_list|,
name|lang_frame_mismatch_warn
argument_list|)
expr_stmt|;
name|warned
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Add an element to the list of info subcommands.  */
end_comment

begin_function_decl
name|void
name|add_info
parameter_list|(
name|name
parameter_list|,
name|fun
parameter_list|,
name|doc
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
function_decl|void
parameter_list|(
function_decl|*fun
end_function_decl

begin_expr_stmt
unit|)
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|char
modifier|*
name|doc
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|add_cmd
argument_list|(
name|name
argument_list|,
name|no_class
argument_list|,
name|fun
argument_list|,
name|doc
argument_list|,
operator|&
name|infolist
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Add an alias to the list of info subcommands.  */
end_comment

begin_function
name|void
name|add_info_alias
parameter_list|(
name|name
parameter_list|,
name|oldname
parameter_list|,
name|abbrev_flag
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
name|char
modifier|*
name|oldname
decl_stmt|;
name|int
name|abbrev_flag
decl_stmt|;
block|{
name|add_alias_cmd
argument_list|(
name|name
argument_list|,
name|oldname
argument_list|,
literal|0
argument_list|,
name|abbrev_flag
argument_list|,
operator|&
name|infolist
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The "info" command is defined as a prefix, with allow_unknown = 0.    Therefore, its own definition is called only for "info" with no args.  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|void
name|info_command
parameter_list|(
name|arg
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|printf
argument_list|(
literal|"\"info\" must be followed by the name of an info command.\n"
argument_list|)
expr_stmt|;
name|help_list
argument_list|(
name|infolist
argument_list|,
literal|"info "
argument_list|,
operator|-
literal|1
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The "show" command with no arguments shows all the settings.  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|void
name|show_command
parameter_list|(
name|arg
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|cmd_show_list
argument_list|(
name|showlist
argument_list|,
name|from_tty
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Add an element to the list of commands.  */
end_comment

begin_function_decl
name|void
name|add_com
parameter_list|(
name|name
parameter_list|,
name|class
parameter_list|,
name|fun
parameter_list|,
name|doc
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
name|enum
name|command_class
name|class
decl_stmt|;
function_decl|void
parameter_list|(
function_decl|*fun
end_function_decl

begin_expr_stmt
unit|)
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|char
modifier|*
name|doc
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|add_cmd
argument_list|(
name|name
argument_list|,
name|class
argument_list|,
name|fun
argument_list|,
name|doc
argument_list|,
operator|&
name|cmdlist
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Add an alias or abbreviation command to the list of commands.  */
end_comment

begin_function
name|void
name|add_com_alias
parameter_list|(
name|name
parameter_list|,
name|oldname
parameter_list|,
name|class
parameter_list|,
name|abbrev_flag
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
name|char
modifier|*
name|oldname
decl_stmt|;
name|enum
name|command_class
name|class
decl_stmt|;
name|int
name|abbrev_flag
decl_stmt|;
block|{
name|add_alias_cmd
argument_list|(
name|name
argument_list|,
name|oldname
argument_list|,
name|class
argument_list|,
name|abbrev_flag
argument_list|,
operator|&
name|cmdlist
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|error_no_arg
parameter_list|(
name|why
parameter_list|)
name|char
modifier|*
name|why
decl_stmt|;
block|{
name|error
argument_list|(
literal|"Argument required (%s)."
argument_list|,
name|why
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|void
name|help_command
parameter_list|(
name|command
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|command
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
comment|/* Ignored */
block|{
name|help_cmd
argument_list|(
name|command
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|void
name|validate_comname
parameter_list|(
name|comname
parameter_list|)
name|char
modifier|*
name|comname
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|comname
operator|==
literal|0
condition|)
name|error_no_arg
argument_list|(
literal|"name of command to define"
argument_list|)
expr_stmt|;
name|p
operator|=
name|comname
expr_stmt|;
while|while
condition|(
operator|*
name|p
condition|)
block|{
if|if
condition|(
operator|!
name|isalnum
argument_list|(
operator|*
name|p
argument_list|)
operator|&&
operator|*
name|p
operator|!=
literal|'-'
condition|)
name|error
argument_list|(
literal|"Junk in argument list: \"%s\""
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|p
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* This is just a placeholder in the command data structures.  */
end_comment

begin_function
specifier|static
name|void
name|user_defined_command
parameter_list|(
name|ignore
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|ignore
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{ }
end_function

begin_function
specifier|static
name|void
name|define_command
parameter_list|(
name|comname
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|comname
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
specifier|register
name|struct
name|command_line
modifier|*
name|cmds
decl_stmt|;
specifier|register
name|struct
name|cmd_list_element
modifier|*
name|c
decl_stmt|,
modifier|*
name|newc
decl_stmt|,
modifier|*
name|hookc
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|tem
init|=
name|comname
decl_stmt|;
define|#
directive|define
name|HOOK_STRING
value|"hook-"
define|#
directive|define
name|HOOK_LEN
value|5
name|validate_comname
argument_list|(
name|comname
argument_list|)
expr_stmt|;
comment|/* Look it up, and verify that we got an exact match.  */
name|c
operator|=
name|lookup_cmd
argument_list|(
operator|&
name|tem
argument_list|,
name|cmdlist
argument_list|,
literal|""
argument_list|,
operator|-
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|&&
literal|0
operator|!=
name|strcmp
argument_list|(
name|comname
argument_list|,
name|c
operator|->
name|name
argument_list|)
condition|)
name|c
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|c
condition|)
block|{
if|if
condition|(
name|c
operator|->
name|class
operator|==
name|class_user
operator|||
name|c
operator|->
name|class
operator|==
name|class_alias
condition|)
name|tem
operator|=
literal|"Redefine command \"%s\"? "
expr_stmt|;
else|else
name|tem
operator|=
literal|"Really redefine built-in command \"%s\"? "
expr_stmt|;
if|if
condition|(
operator|!
name|query
argument_list|(
name|tem
argument_list|,
name|c
operator|->
name|name
argument_list|)
condition|)
name|error
argument_list|(
literal|"Command \"%s\" not redefined."
argument_list|,
name|c
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
comment|/* If this new command is a hook, then mark the command which it      is hooking.  Note that we allow hooking `help' commands, so that      we can hook the `stop' pseudo-command.  */
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|comname
argument_list|,
name|HOOK_STRING
argument_list|,
name|HOOK_LEN
argument_list|)
condition|)
block|{
comment|/* Look up cmd it hooks, and verify that we got an exact match.  */
name|tem
operator|=
name|comname
operator|+
name|HOOK_LEN
expr_stmt|;
name|hookc
operator|=
name|lookup_cmd
argument_list|(
operator|&
name|tem
argument_list|,
name|cmdlist
argument_list|,
literal|""
argument_list|,
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|hookc
operator|&&
literal|0
operator|!=
name|strcmp
argument_list|(
name|comname
operator|+
name|HOOK_LEN
argument_list|,
name|hookc
operator|->
name|name
argument_list|)
condition|)
name|hookc
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|hookc
condition|)
block|{
name|warning
argument_list|(
literal|"Your new `%s' command does not hook any existing command."
argument_list|,
name|comname
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|query
argument_list|(
literal|"Proceed? "
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
condition|)
name|error
argument_list|(
literal|"Not confirmed."
argument_list|)
expr_stmt|;
block|}
block|}
name|comname
operator|=
name|savestring
argument_list|(
name|comname
argument_list|,
name|strlen
argument_list|(
name|comname
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If the rest of the commands will be case insensitive, this one       should behave in the same manner. */
for|for
control|(
name|tem
operator|=
name|comname
init|;
operator|*
name|tem
condition|;
name|tem
operator|++
control|)
if|if
condition|(
name|isupper
argument_list|(
operator|*
name|tem
argument_list|)
condition|)
operator|*
name|tem
operator|=
name|tolower
argument_list|(
operator|*
name|tem
argument_list|)
expr_stmt|;
if|if
condition|(
name|from_tty
condition|)
block|{
name|printf
argument_list|(
literal|"Type commands for definition of \"%s\".\n\ End with a line saying just \"end\".\n"
argument_list|,
name|comname
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
name|cmds
operator|=
name|read_command_lines
argument_list|(
name|from_tty
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|&&
name|c
operator|->
name|class
operator|==
name|class_user
condition|)
name|free_command_lines
argument_list|(
name|c
operator|->
name|user_commands
argument_list|)
expr_stmt|;
name|newc
operator|=
name|add_cmd
argument_list|(
name|comname
argument_list|,
name|class_user
argument_list|,
name|user_defined_command
argument_list|,
operator|(
name|c
operator|&&
name|c
operator|->
name|class
operator|==
name|class_user
operator|)
condition|?
name|c
operator|->
name|doc
else|:
name|savestring
argument_list|(
literal|"User-defined."
argument_list|,
literal|13
argument_list|)
argument_list|,
operator|&
name|cmdlist
argument_list|)
expr_stmt|;
name|newc
operator|->
name|user_commands
operator|=
name|cmds
expr_stmt|;
comment|/* If this new command is a hook, then mark both commands as being      tied.  */
if|if
condition|(
name|hookc
condition|)
block|{
name|hookc
operator|->
name|hook
operator|=
name|newc
expr_stmt|;
comment|/* Target gets hooked.  */
name|newc
operator|->
name|hookee
operator|=
name|hookc
expr_stmt|;
comment|/* We are marked as hooking target cmd.  */
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|document_command
parameter_list|(
name|comname
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|comname
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|struct
name|command_line
modifier|*
name|doclines
decl_stmt|;
specifier|register
name|struct
name|cmd_list_element
modifier|*
name|c
decl_stmt|;
name|char
modifier|*
name|tem
init|=
name|comname
decl_stmt|;
name|validate_comname
argument_list|(
name|comname
argument_list|)
expr_stmt|;
name|c
operator|=
name|lookup_cmd
argument_list|(
operator|&
name|tem
argument_list|,
name|cmdlist
argument_list|,
literal|""
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|class
operator|!=
name|class_user
condition|)
name|error
argument_list|(
literal|"Command \"%s\" is built-in."
argument_list|,
name|comname
argument_list|)
expr_stmt|;
if|if
condition|(
name|from_tty
condition|)
name|printf
argument_list|(
literal|"Type documentation for \"%s\".\n\ End with a line saying just \"end\".\n"
argument_list|,
name|comname
argument_list|)
expr_stmt|;
name|doclines
operator|=
name|read_command_lines
argument_list|(
name|from_tty
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|doc
condition|)
name|free
argument_list|(
name|c
operator|->
name|doc
argument_list|)
expr_stmt|;
block|{
specifier|register
name|struct
name|command_line
modifier|*
name|cl1
decl_stmt|;
specifier|register
name|int
name|len
init|=
literal|0
decl_stmt|;
for|for
control|(
name|cl1
operator|=
name|doclines
init|;
name|cl1
condition|;
name|cl1
operator|=
name|cl1
operator|->
name|next
control|)
name|len
operator|+=
name|strlen
argument_list|(
name|cl1
operator|->
name|line
argument_list|)
operator|+
literal|1
expr_stmt|;
name|c
operator|->
name|doc
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
operator|*
name|c
operator|->
name|doc
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|cl1
operator|=
name|doclines
init|;
name|cl1
condition|;
name|cl1
operator|=
name|cl1
operator|->
name|next
control|)
block|{
name|strcat
argument_list|(
name|c
operator|->
name|doc
argument_list|,
name|cl1
operator|->
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
name|cl1
operator|->
name|next
condition|)
name|strcat
argument_list|(
name|c
operator|->
name|doc
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
name|free_command_lines
argument_list|(
name|doclines
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|void
name|print_gnu_advertisement
parameter_list|()
block|{
name|printf
argument_list|(
literal|"\ GDB is free software and you are welcome to distribute copies of it\n\  under certain conditions; type \"show copying\" to see the conditions.\n\ There is absolutely no warranty for GDB; type \"show warranty\" for details.\n\ "
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|print_gdb_version
parameter_list|()
block|{
name|printf_filtered
argument_list|(
literal|"\ GDB %s, Copyright 1992 Free Software Foundation, Inc."
argument_list|,
name|version
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|void
name|show_version
parameter_list|(
name|args
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|immediate_quit
operator|++
expr_stmt|;
name|print_gnu_advertisement
argument_list|()
expr_stmt|;
name|print_gdb_version
argument_list|()
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|immediate_quit
operator|--
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* xgdb calls this to reprint the usual GDB prompt.  */
end_comment

begin_function
name|void
name|print_prompt
parameter_list|()
block|{
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|masterprompt
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_TERMIO
end_ifdef

begin_include
include|#
directive|include
file|<termio.h>
end_include

begin_decl_stmt
specifier|static
name|struct
name|termio
name|norm_tty
decl_stmt|;
end_decl_stmt

begin_macro
name|init_term
argument_list|(
argument|tty
argument_list|)
end_macro

begin_block
block|{
name|ioctl
argument_list|(
name|tty
argument_list|,
name|TCGETA
argument_list|,
operator|&
name|norm_tty
argument_list|)
expr_stmt|;
block|}
end_block

begin_function
specifier|static
name|void
name|suspend_sig
parameter_list|()
block|{
name|int
name|tty
init|=
name|fileno
argument_list|(
name|stdin
argument_list|)
decl_stmt|;
name|struct
name|termio
name|cur_tty
decl_stmt|;
name|ioctl
argument_list|(
name|tty
argument_list|,
name|TCGETA
argument_list|,
operator|&
name|cur_tty
argument_list|)
expr_stmt|;
name|ioctl
argument_list|(
name|tty
argument_list|,
name|TCSETAW
argument_list|,
operator|&
name|norm_tty
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sigsetmask
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGTSTP
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
name|kill
argument_list|(
literal|0
argument_list|,
name|SIGTSTP
argument_list|)
expr_stmt|;
comment|/* 	 * we've just been resumed -- current tty params become new 	 * 'normal' params (in case tset/stty was done while we were 	 * suspended).  Merge values that readline might have changed 	 * into new params, then restore term mode. 	 */
name|ioctl
argument_list|(
name|tty
argument_list|,
name|TCGETA
argument_list|,
operator|&
name|norm_tty
argument_list|)
expr_stmt|;
name|cur_tty
operator|.
name|c_lflag
operator|=
operator|(
name|cur_tty
operator|.
name|c_lflag
operator|&
operator|(
name|ICANON
operator||
name|ECHO
operator||
name|ISIG
operator|)
operator|)
operator||
operator|(
name|norm_tty
operator|.
name|c_lflag
operator|&
operator|~
operator|(
name|ICANON
operator||
name|ECHO
operator||
name|ISIG
operator|)
operator|)
expr_stmt|;
name|cur_tty
operator|.
name|c_iflag
operator|=
operator|(
name|cur_tty
operator|.
name|c_iflag
operator|&
operator|(
name|IXON
operator||
name|ISTRIP
operator||
name|INPCK
operator|)
operator|)
operator||
operator|(
name|norm_tty
operator|.
name|c_iflag
operator|&
operator|~
operator|(
name|IXON
operator||
name|ISTRIP
operator||
name|INPCK
operator|)
operator|)
expr_stmt|;
name|ioctl
argument_list|(
name|tty
argument_list|,
name|TCSETAW
argument_list|,
operator|&
name|cur_tty
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGTSTP
argument_list|,
name|suspend_sig
argument_list|)
expr_stmt|;
name|print_prompt
argument_list|()
expr_stmt|;
comment|/* 	 * Forget about any previous command -- null line now will do 	 * nothing. 	 */
name|dont_repeat
argument_list|()
expr_stmt|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<sgtty.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_comment
comment|/* XXX BSD: must follow sgtty.h for compat to kick in */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|sgttyb
name|norm_tty
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|tchars
name|norm_tchars
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|ltchars
name|norm_ltchars
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|norm_lflags
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|PASS8
end_ifdef

begin_define
define|#
directive|define
name|RL_TFLAGS
value|(RAW|CRMOD|ECHO|CBREAK|PASS8)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|RL_TFLAGS
value|(RAW|CRMOD|ECHO|CBREAK)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_macro
name|init_term
argument_list|(
argument|tty
argument_list|)
end_macro

begin_decl_stmt
name|int
name|tty
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|ioctl
argument_list|(
name|tty
argument_list|,
name|TIOCGETP
argument_list|,
operator|&
name|norm_tty
argument_list|)
expr_stmt|;
name|ioctl
argument_list|(
name|tty
argument_list|,
name|TIOCLGET
argument_list|,
operator|&
name|norm_lflags
argument_list|)
expr_stmt|;
name|ioctl
argument_list|(
name|tty
argument_list|,
name|TIOCGETC
argument_list|,
operator|&
name|norm_tchars
argument_list|)
expr_stmt|;
name|ioctl
argument_list|(
name|tty
argument_list|,
name|TIOCGLTC
argument_list|,
operator|&
name|norm_ltchars
argument_list|)
expr_stmt|;
block|}
end_block

begin_function
specifier|static
name|void
name|suspend_sig
parameter_list|()
block|{
name|int
name|tty
init|=
name|fileno
argument_list|(
name|stdin
argument_list|)
decl_stmt|;
name|struct
name|sgttyb
name|cur_tty
decl_stmt|;
name|struct
name|tchars
name|cur_tchars
decl_stmt|;
name|struct
name|ltchars
name|cur_ltchars
decl_stmt|;
name|int
name|cur_lflags
decl_stmt|;
name|int
name|cur_flags
decl_stmt|;
name|ioctl
argument_list|(
name|tty
argument_list|,
name|TIOCGETP
argument_list|,
operator|&
name|cur_tty
argument_list|)
expr_stmt|;
name|ioctl
argument_list|(
name|tty
argument_list|,
name|TIOCGETC
argument_list|,
operator|&
name|cur_tchars
argument_list|)
expr_stmt|;
name|ioctl
argument_list|(
name|tty
argument_list|,
name|TIOCLGET
argument_list|,
operator|&
name|cur_lflags
argument_list|)
expr_stmt|;
name|ioctl
argument_list|(
name|tty
argument_list|,
name|TIOCGLTC
argument_list|,
operator|&
name|cur_ltchars
argument_list|)
expr_stmt|;
name|ioctl
argument_list|(
name|tty
argument_list|,
name|TIOCSETP
argument_list|,
operator|&
name|norm_tty
argument_list|)
expr_stmt|;
name|ioctl
argument_list|(
name|tty
argument_list|,
name|TIOCSETC
argument_list|,
operator|&
name|norm_tchars
argument_list|)
expr_stmt|;
name|ioctl
argument_list|(
name|tty
argument_list|,
name|TIOCLSET
argument_list|,
operator|&
name|norm_lflags
argument_list|)
expr_stmt|;
name|ioctl
argument_list|(
name|tty
argument_list|,
name|TIOCSLTC
argument_list|,
operator|&
name|norm_ltchars
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sigsetmask
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGTSTP
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
name|kill
argument_list|(
literal|0
argument_list|,
name|SIGTSTP
argument_list|)
expr_stmt|;
comment|/* 	 * we've just been resumed -- current tty params become new 	 * 'normal' params (in case tset/stty was done while we were 	 * suspended).  Merge values that readline might have changed 	 * into new params, then restore term mode. 	 */
name|ioctl
argument_list|(
name|tty
argument_list|,
name|TIOCGETP
argument_list|,
operator|&
name|norm_tty
argument_list|)
expr_stmt|;
name|cur_flags
operator|=
name|cur_tty
operator|.
name|sg_flags
expr_stmt|;
name|cur_tty
operator|=
name|norm_tty
expr_stmt|;
name|cur_tty
operator|.
name|sg_flags
operator|=
operator|(
name|cur_tty
operator|.
name|sg_flags
operator|&
operator|~
name|RL_TFLAGS
operator|)
operator||
operator|(
name|cur_flags
operator|&
name|RL_TFLAGS
operator|)
expr_stmt|;
name|ioctl
argument_list|(
name|tty
argument_list|,
name|TIOCLGET
argument_list|,
operator|&
name|norm_lflags
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|LPASS8
name|cur_lflags
operator|=
operator|(
name|cur_lflags
operator|&
operator|~
name|LPASS8
operator|)
operator||
operator|(
name|cur_flags
operator|&
name|LPASS8
operator|)
expr_stmt|;
endif|#
directive|endif
name|ioctl
argument_list|(
name|tty
argument_list|,
name|TIOCGETC
argument_list|,
operator|&
name|norm_tchars
argument_list|)
expr_stmt|;
name|ioctl
argument_list|(
name|tty
argument_list|,
name|TIOCGLTC
argument_list|,
operator|&
name|norm_ltchars
argument_list|)
expr_stmt|;
name|ioctl
argument_list|(
name|tty
argument_list|,
name|TIOCSETP
argument_list|,
operator|&
name|cur_tty
argument_list|)
expr_stmt|;
name|ioctl
argument_list|(
name|tty
argument_list|,
name|TIOCSETC
argument_list|,
operator|&
name|cur_tchars
argument_list|)
expr_stmt|;
name|ioctl
argument_list|(
name|tty
argument_list|,
name|TIOCLSET
argument_list|,
operator|&
name|cur_lflags
argument_list|)
expr_stmt|;
name|ioctl
argument_list|(
name|tty
argument_list|,
name|TIOCSLTC
argument_list|,
operator|&
name|cur_ltchars
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGTSTP
argument_list|,
name|suspend_sig
argument_list|)
expr_stmt|;
name|print_prompt
argument_list|()
expr_stmt|;
comment|/* 	 * Forget about any previous command -- null line now will do 	 * nothing. 	 */
name|dont_repeat
argument_list|()
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_TERMIO */
end_comment

begin_function
specifier|static
name|void
name|quit_command
parameter_list|(
name|args
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
comment|/*    * Don't bother checking if the inferior_pid is 0 because the remote    * module doesn't muck with it (for pid 0, target_kill should be a nop     * in the ptrace case anyway -- moreover, inferior_pid should be private    * to infptrace.c)    */
if|if
condition|(
name|target_has_execution
condition|)
block|{
if|if
condition|(
name|inhibit_confirm
operator|||
name|query
argument_list|(
literal|"The program is running.  Quit anyway? "
argument_list|)
condition|)
block|{
if|if
condition|(
name|attach_flag
condition|)
name|target_detach
argument_list|(
name|args
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
else|else
name|target_kill
argument_list|()
expr_stmt|;
block|}
else|else
name|error
argument_list|(
literal|"Not confirmed."
argument_list|)
expr_stmt|;
block|}
comment|/* Save the history information if it is appropriate to do so.  */
if|if
condition|(
name|write_history_p
operator|&&
name|history_filename
condition|)
name|write_history
argument_list|(
name|history_filename
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Returns whether GDB is running on a terminal and whether the user    desires that questions be asked of them on that terminal.  */
end_comment

begin_function
name|int
name|input_from_terminal_p
parameter_list|()
block|{
return|return
name|gdb_has_a_terminal
operator|&&
operator|(
name|instream
operator|==
name|stdin
operator|)
operator|&
name|caution
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|void
name|pwd_command
parameter_list|(
name|args
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
if|if
condition|(
name|args
condition|)
name|error
argument_list|(
literal|"The \"pwd\" command does not take an argument: %s"
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|getcwd
argument_list|(
name|dirbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|dirbuf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|dirbuf
argument_list|,
name|current_directory
argument_list|)
condition|)
name|printf
argument_list|(
literal|"Working directory %s\n (canonically %s).\n"
argument_list|,
name|current_directory
argument_list|,
name|dirbuf
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"Working directory %s.\n"
argument_list|,
name|current_directory
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|cd_command
parameter_list|(
name|dir
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|dir
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|int
name|len
decl_stmt|;
name|int
name|change
decl_stmt|;
comment|/* If the new directory is absolute, repeat is a no-op; if relative,      repeat might be useful but is more likely to be a mistake.  */
name|dont_repeat
argument_list|()
expr_stmt|;
if|if
condition|(
name|dir
operator|==
literal|0
condition|)
name|error_no_arg
argument_list|(
literal|"new working directory"
argument_list|)
expr_stmt|;
name|dir
operator|=
name|tilde_expand
argument_list|(
name|dir
argument_list|)
expr_stmt|;
name|make_cleanup
argument_list|(
name|free
argument_list|,
name|dir
argument_list|)
expr_stmt|;
if|if
condition|(
name|chdir
argument_list|(
name|dir
argument_list|)
operator|<
literal|0
condition|)
name|perror_with_name
argument_list|(
name|dir
argument_list|)
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|dir
argument_list|)
expr_stmt|;
name|dir
operator|=
name|savestring
argument_list|(
name|dir
argument_list|,
name|len
operator|-
operator|(
name|len
operator|>
literal|1
operator|&&
name|dir
index|[
name|len
operator|-
literal|1
index|]
operator|==
literal|'/'
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dir
index|[
literal|0
index|]
operator|==
literal|'/'
condition|)
name|current_directory
operator|=
name|dir
expr_stmt|;
else|else
block|{
name|current_directory
operator|=
name|concat
argument_list|(
name|current_directory
argument_list|,
literal|"/"
argument_list|,
name|dir
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|dir
argument_list|)
expr_stmt|;
block|}
comment|/* Now simplify any occurrences of `.' and `..' in the pathname.  */
name|change
operator|=
literal|1
expr_stmt|;
while|while
condition|(
name|change
condition|)
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|change
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|p
operator|=
name|current_directory
init|;
operator|*
name|p
condition|;
control|)
block|{
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|p
argument_list|,
literal|"/./"
argument_list|,
literal|2
argument_list|)
operator|&&
operator|(
name|p
index|[
literal|2
index|]
operator|==
literal|0
operator|||
name|p
index|[
literal|2
index|]
operator|==
literal|'/'
operator|)
condition|)
name|strcpy
argument_list|(
name|p
argument_list|,
name|p
operator|+
literal|2
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|p
argument_list|,
literal|"/.."
argument_list|,
literal|3
argument_list|)
operator|&&
operator|(
name|p
index|[
literal|3
index|]
operator|==
literal|0
operator|||
name|p
index|[
literal|3
index|]
operator|==
literal|'/'
operator|)
operator|&&
name|p
operator|!=
name|current_directory
condition|)
block|{
name|char
modifier|*
name|q
init|=
name|p
decl_stmt|;
while|while
condition|(
name|q
operator|!=
name|current_directory
operator|&&
name|q
index|[
operator|-
literal|1
index|]
operator|!=
literal|'/'
condition|)
name|q
operator|--
expr_stmt|;
if|if
condition|(
name|q
operator|!=
name|current_directory
condition|)
block|{
name|strcpy
argument_list|(
name|q
operator|-
literal|1
argument_list|,
name|p
operator|+
literal|3
argument_list|)
expr_stmt|;
name|p
operator|=
name|q
operator|-
literal|1
expr_stmt|;
block|}
block|}
else|else
name|p
operator|++
expr_stmt|;
block|}
block|}
name|forget_cached_source_info
argument_list|()
expr_stmt|;
if|if
condition|(
name|from_tty
condition|)
name|pwd_command
argument_list|(
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|void
name|source_command
parameter_list|(
name|args
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|FILE
modifier|*
name|stream
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|cleanups
decl_stmt|;
name|char
modifier|*
name|file
init|=
name|args
decl_stmt|;
if|if
condition|(
name|file
operator|==
literal|0
condition|)
comment|/* Let source without arguments read .gdbinit.  */
name|file
operator|=
name|gdbinit
expr_stmt|;
name|file
operator|=
name|tilde_expand
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|make_cleanup
argument_list|(
name|free
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|stream
operator|=
name|fopen
argument_list|(
name|file
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|stream
operator|==
literal|0
condition|)
block|{
name|char
modifier|*
name|cp
init|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|file
argument_list|)
operator|+
literal|5
argument_list|)
decl_stmt|;
name|sprintf
argument_list|(
name|cp
argument_list|,
literal|"%s.gdb"
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|make_cleanup
argument_list|(
name|free
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|stream
operator|=
name|fopen
argument_list|(
name|cp
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|stream
operator|==
literal|0
condition|)
name|perror_with_name
argument_list|(
name|file
argument_list|)
expr_stmt|;
block|}
name|cleanups
operator|=
name|make_cleanup
argument_list|(
name|fclose
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|read_command_file
argument_list|(
name|stream
argument_list|)
expr_stmt|;
name|do_cleanups
argument_list|(
name|cleanups
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|void
name|echo_command
parameter_list|(
name|text
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|text
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|char
modifier|*
name|p
init|=
name|text
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
if|if
condition|(
name|text
condition|)
while|while
condition|(
name|c
operator|=
operator|*
name|p
operator|++
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'\\'
condition|)
block|{
comment|/* \ at end of argument is used after spaces 	       so they won't be lost.  */
if|if
condition|(
operator|*
name|p
operator|==
literal|0
condition|)
return|return;
name|c
operator|=
name|parse_escape
argument_list|(
operator|&
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|>=
literal|0
condition|)
name|printf_filtered
argument_list|(
literal|"%c"
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
else|else
name|printf_filtered
argument_list|(
literal|"%c"
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
comment|/* Force this output to appear now.  */
name|wrap_here
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Functions to manipulate command line editing control variables.  */
end_comment

begin_comment
comment|/* Number of commands to print in each call to show_commands.  */
end_comment

begin_define
define|#
directive|define
name|Hist_print
value|10
end_define

begin_function
specifier|static
name|void
name|show_commands
parameter_list|(
name|args
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
comment|/* Index for history commands.  Relative to history_base.  */
name|int
name|offset
decl_stmt|;
comment|/* Number of the history entry which we are planning to display next.      Relative to history_base.  */
specifier|static
name|int
name|num
init|=
literal|0
decl_stmt|;
comment|/* The first command in the history which doesn't exist (i.e. one more      than the number of the last command).  Relative to history_base.  */
name|int
name|hist_len
decl_stmt|;
specifier|extern
name|struct
name|_hist_entry
modifier|*
name|history_get
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|history_base
decl_stmt|;
comment|/* Print out some of the commands from the command history.  */
comment|/* First determine the length of the history list.  */
name|hist_len
operator|=
name|history_size
expr_stmt|;
for|for
control|(
name|offset
operator|=
literal|0
init|;
name|offset
operator|<
name|history_size
condition|;
name|offset
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|history_get
argument_list|(
name|history_base
operator|+
name|offset
argument_list|)
condition|)
block|{
name|hist_len
operator|=
name|offset
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|args
condition|)
block|{
if|if
condition|(
name|args
index|[
literal|0
index|]
operator|==
literal|'+'
operator|&&
name|args
index|[
literal|1
index|]
operator|==
literal|'\0'
condition|)
comment|/* "info editing +" should print from the stored position.  */
empty_stmt|;
else|else
comment|/* "info editing<exp>" should print around command number<exp>.  */
name|num
operator|=
operator|(
name|parse_and_eval_address
argument_list|(
name|args
argument_list|)
operator|-
name|history_base
operator|)
operator|-
name|Hist_print
operator|/
literal|2
expr_stmt|;
block|}
comment|/* "show commands" means print the last Hist_print commands.  */
else|else
block|{
name|num
operator|=
name|hist_len
operator|-
name|Hist_print
expr_stmt|;
block|}
if|if
condition|(
name|num
operator|<
literal|0
condition|)
name|num
operator|=
literal|0
expr_stmt|;
comment|/* If there are at least Hist_print commands, we want to display the last      Hist_print rather than, say, the last 6.  */
if|if
condition|(
name|hist_len
operator|-
name|num
operator|<
name|Hist_print
condition|)
block|{
name|num
operator|=
name|hist_len
operator|-
name|Hist_print
expr_stmt|;
if|if
condition|(
name|num
operator|<
literal|0
condition|)
name|num
operator|=
literal|0
expr_stmt|;
block|}
for|for
control|(
name|offset
operator|=
name|num
init|;
name|offset
operator|<
name|num
operator|+
name|Hist_print
operator|&&
name|offset
operator|<
name|hist_len
condition|;
name|offset
operator|++
control|)
block|{
name|printf_filtered
argument_list|(
literal|"%5d  %s\n"
argument_list|,
name|history_base
operator|+
name|offset
argument_list|,
operator|(
name|history_get
argument_list|(
name|history_base
operator|+
name|offset
argument_list|)
operator|)
operator|->
name|line
argument_list|)
expr_stmt|;
block|}
comment|/* The next command we want to display is the next one that we haven't      displayed yet.  */
name|num
operator|+=
name|Hist_print
expr_stmt|;
comment|/* If the user repeats this command with return, it should do what      "show commands +" does.  This is unnecessary if arg is null,      because "show commands +" is not useful after "show commands".  */
if|if
condition|(
name|from_tty
operator|&&
name|args
condition|)
block|{
name|args
index|[
literal|0
index|]
operator|=
literal|'+'
expr_stmt|;
name|args
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Called by do_setshow_command.  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|void
name|set_history_size_command
parameter_list|(
name|args
parameter_list|,
name|from_tty
parameter_list|,
name|c
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
name|struct
name|cmd_list_element
modifier|*
name|c
decl_stmt|;
block|{
if|if
condition|(
name|history_size
operator|==
name|UINT_MAX
condition|)
name|unstifle_history
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
name|history_size
operator|>=
literal|0
condition|)
name|stifle_history
argument_list|(
name|history_size
argument_list|)
expr_stmt|;
else|else
block|{
name|history_size
operator|=
name|UINT_MAX
expr_stmt|;
name|error
argument_list|(
literal|"History size must be non-negative"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|void
name|set_history
parameter_list|(
name|args
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|printf
argument_list|(
literal|"\"set history\" must be followed by the name of a history subcommand.\n"
argument_list|)
expr_stmt|;
name|help_list
argument_list|(
name|sethistlist
argument_list|,
literal|"set history "
argument_list|,
operator|-
literal|1
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|void
name|show_history
parameter_list|(
name|args
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|cmd_show_list
argument_list|(
name|showhistlist
argument_list|,
name|from_tty
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
name|int
name|info_verbose
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Default verbose msgs off */
end_comment

begin_comment
comment|/* Called by do_setshow_command.  An elaborate joke.  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|void
name|set_verbose
parameter_list|(
name|args
parameter_list|,
name|from_tty
parameter_list|,
name|c
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
name|struct
name|cmd_list_element
modifier|*
name|c
decl_stmt|;
block|{
name|char
modifier|*
name|cmdname
init|=
literal|"verbose"
decl_stmt|;
name|struct
name|cmd_list_element
modifier|*
name|showcmd
decl_stmt|;
name|showcmd
operator|=
name|lookup_cmd_1
argument_list|(
operator|&
name|cmdname
argument_list|,
name|showlist
argument_list|,
name|NULL
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|info_verbose
condition|)
block|{
name|c
operator|->
name|doc
operator|=
literal|"Set verbose printing of informational messages."
expr_stmt|;
name|showcmd
operator|->
name|doc
operator|=
literal|"Show verbose printing of informational messages."
expr_stmt|;
block|}
else|else
block|{
name|c
operator|->
name|doc
operator|=
literal|"Set verbosity."
expr_stmt|;
name|showcmd
operator|->
name|doc
operator|=
literal|"Show verbosity."
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|float_handler
parameter_list|(
name|signo
parameter_list|)
name|int
name|signo
decl_stmt|;
block|{
comment|/* This message is based on ANSI C, section 4.7.  Note that integer      divide by zero causes this, so "float" is a misnomer.  */
name|error
argument_list|(
literal|"Erroneous arithmetic operation."
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return whether we are running a batch file or from terminal.  */
end_comment

begin_function
name|int
name|batch_mode
parameter_list|()
block|{
return|return
operator|!
operator|(
name|instream
operator|==
name|stdin
operator|&&
name|ISATTY
argument_list|(
name|stdin
argument_list|)
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|void
name|initialize_cmd_lists
parameter_list|()
block|{
name|cmdlist
operator|=
name|NULL
expr_stmt|;
name|infolist
operator|=
name|NULL
expr_stmt|;
name|enablelist
operator|=
name|NULL
expr_stmt|;
name|disablelist
operator|=
name|NULL
expr_stmt|;
name|deletelist
operator|=
name|NULL
expr_stmt|;
name|enablebreaklist
operator|=
name|NULL
expr_stmt|;
name|setlist
operator|=
name|NULL
expr_stmt|;
name|unsetlist
operator|=
name|NULL
expr_stmt|;
name|showlist
operator|=
name|NULL
expr_stmt|;
name|sethistlist
operator|=
name|NULL
expr_stmt|;
name|showhistlist
operator|=
name|NULL
expr_stmt|;
name|unsethistlist
operator|=
name|NULL
expr_stmt|;
if|#
directive|if
name|MAINTENANCE_CMDS
name|maintenancelist
operator|=
name|NULL
expr_stmt|;
name|maintenanceinfolist
operator|=
name|NULL
expr_stmt|;
name|maintenanceprintlist
operator|=
name|NULL
expr_stmt|;
endif|#
directive|endif
name|setprintlist
operator|=
name|NULL
expr_stmt|;
name|showprintlist
operator|=
name|NULL
expr_stmt|;
name|setchecklist
operator|=
name|NULL
expr_stmt|;
name|showchecklist
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Init the history buffer.  Note that we are called after the init file(s)  * have been read so that the user can change the history file via his  * .gdbinit file (for instance).  The GDBHISTFILE environment variable  * overrides all of this.  */
end_comment

begin_function
specifier|static
name|void
name|initialize_history
parameter_list|()
block|{
name|char
modifier|*
name|tmpenv
decl_stmt|;
name|tmpenv
operator|=
name|getenv
argument_list|(
literal|"HISTSIZE"
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmpenv
condition|)
name|history_size
operator|=
name|atoi
argument_list|(
name|tmpenv
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|history_size
condition|)
name|history_size
operator|=
literal|256
expr_stmt|;
name|stifle_history
argument_list|(
name|history_size
argument_list|)
expr_stmt|;
name|tmpenv
operator|=
name|getenv
argument_list|(
literal|"GDBHISTFILE"
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmpenv
condition|)
name|history_filename
operator|=
name|savestring
argument_list|(
name|tmpenv
argument_list|,
name|strlen
argument_list|(
name|tmpenv
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|history_filename
condition|)
block|{
comment|/* We include the current directory so that if the user changes        directories the file written will be the same as the one        that was read.  */
name|history_filename
operator|=
name|concat
argument_list|(
name|current_directory
argument_list|,
literal|"/.gdb_history"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
name|read_history
argument_list|(
name|history_filename
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|set_prompt
parameter_list|(
name|s
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
block|{
if|if
condition|(
name|masterprompt
operator|!=
literal|0
condition|)
name|free
argument_list|(
name|masterprompt
argument_list|)
expr_stmt|;
name|masterprompt
operator|=
name|strsave
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|initialize_main
parameter_list|()
block|{
name|struct
name|cmd_list_element
modifier|*
name|c
decl_stmt|;
ifdef|#
directive|ifdef
name|DEFAULT_PROMPT
name|set_prompt
argument_list|(
name|DEFAULT_PROMPT
argument_list|)
expr_stmt|;
else|#
directive|else
ifdef|#
directive|ifdef
name|KERNELDEBUG
if|if
condition|(
name|kernel_debugging
condition|)
name|set_prompt
argument_list|(
literal|"(kgdb) "
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
name|set_prompt
argument_list|(
literal|"(gdb) "
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Set the important stuff up for command editing.  */
name|write_history_p
operator|=
literal|0
expr_stmt|;
comment|/* Setup important stuff for command line editing.  */
name|rl_completion_entry_function
operator|=
operator|(
name|int
argument_list|(
operator|*
argument_list|)
argument_list|()
operator|)
name|symbol_completion_function
expr_stmt|;
name|rl_completer_word_break_characters
operator|=
name|gdb_completer_word_break_characters
expr_stmt|;
name|rl_completer_quote_characters
operator|=
name|gdb_completer_quote_characters
expr_stmt|;
name|rl_readline_name
operator|=
literal|"gdb"
expr_stmt|;
comment|/* Define the classes of commands.      They will appear in the help list in the reverse of this order.  */
name|add_cmd
argument_list|(
literal|"internals"
argument_list|,
name|class_maintenance
argument_list|,
name|NO_FUNCTION
argument_list|,
literal|"Maintenance commands.\n\ Some gdb commands are provided just for use by gdb maintainers.\n\ These commands are subject to frequent change, and may not be as\n\ well documented as user commands."
argument_list|,
operator|&
name|cmdlist
argument_list|)
expr_stmt|;
name|add_cmd
argument_list|(
literal|"obscure"
argument_list|,
name|class_obscure
argument_list|,
name|NO_FUNCTION
argument_list|,
literal|"Obscure features."
argument_list|,
operator|&
name|cmdlist
argument_list|)
expr_stmt|;
name|add_cmd
argument_list|(
literal|"aliases"
argument_list|,
name|class_alias
argument_list|,
name|NO_FUNCTION
argument_list|,
literal|"Aliases of other commands."
argument_list|,
operator|&
name|cmdlist
argument_list|)
expr_stmt|;
name|add_cmd
argument_list|(
literal|"user-defined"
argument_list|,
name|class_user
argument_list|,
name|NO_FUNCTION
argument_list|,
literal|"User-defined commands.\n\ The commands in this class are those defined by the user.\n\ Use the \"define\" command to define a command."
argument_list|,
operator|&
name|cmdlist
argument_list|)
expr_stmt|;
name|add_cmd
argument_list|(
literal|"support"
argument_list|,
name|class_support
argument_list|,
name|NO_FUNCTION
argument_list|,
literal|"Support facilities."
argument_list|,
operator|&
name|cmdlist
argument_list|)
expr_stmt|;
name|add_cmd
argument_list|(
literal|"status"
argument_list|,
name|class_info
argument_list|,
name|NO_FUNCTION
argument_list|,
literal|"Status inquiries."
argument_list|,
operator|&
name|cmdlist
argument_list|)
expr_stmt|;
name|add_cmd
argument_list|(
literal|"files"
argument_list|,
name|class_files
argument_list|,
name|NO_FUNCTION
argument_list|,
literal|"Specifying and examining files."
argument_list|,
operator|&
name|cmdlist
argument_list|)
expr_stmt|;
name|add_cmd
argument_list|(
literal|"breakpoints"
argument_list|,
name|class_breakpoint
argument_list|,
name|NO_FUNCTION
argument_list|,
literal|"Making program stop at certain points."
argument_list|,
operator|&
name|cmdlist
argument_list|)
expr_stmt|;
name|add_cmd
argument_list|(
literal|"data"
argument_list|,
name|class_vars
argument_list|,
name|NO_FUNCTION
argument_list|,
literal|"Examining data."
argument_list|,
operator|&
name|cmdlist
argument_list|)
expr_stmt|;
name|add_cmd
argument_list|(
literal|"stack"
argument_list|,
name|class_stack
argument_list|,
name|NO_FUNCTION
argument_list|,
literal|"Examining the stack.\n\ The stack is made up of stack frames.  Gdb assigns numbers to stack frames\n\ counting from zero for the innermost (currently executing) frame.\n\n\ At any time gdb identifies one frame as the \"selected\" frame.\n\ Variable lookups are done with respect to the selected frame.\n\ When the program being debugged stops, gdb selects the innermost frame.\n\ The commands below can be used to select other frames by number or address."
argument_list|,
operator|&
name|cmdlist
argument_list|)
expr_stmt|;
name|add_cmd
argument_list|(
literal|"running"
argument_list|,
name|class_run
argument_list|,
name|NO_FUNCTION
argument_list|,
literal|"Running the program."
argument_list|,
operator|&
name|cmdlist
argument_list|)
expr_stmt|;
name|add_com
argument_list|(
literal|"pwd"
argument_list|,
name|class_files
argument_list|,
name|pwd_command
argument_list|,
literal|"Print working directory.  This is used for your program as well."
argument_list|)
expr_stmt|;
name|add_com
argument_list|(
literal|"cd"
argument_list|,
name|class_files
argument_list|,
name|cd_command
argument_list|,
literal|"Set working directory to DIR for debugger and program being debugged.\n\ The change does not take effect for the program being debugged\n\ until the next time it is started."
argument_list|)
expr_stmt|;
name|add_show_from_set
argument_list|(
name|add_set_cmd
argument_list|(
literal|"prompt"
argument_list|,
name|class_support
argument_list|,
name|var_string
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|masterprompt
argument_list|,
literal|"Set gdb's prompt"
argument_list|,
operator|&
name|setlist
argument_list|)
argument_list|,
operator|&
name|showlist
argument_list|)
expr_stmt|;
name|add_com
argument_list|(
literal|"echo"
argument_list|,
name|class_support
argument_list|,
name|echo_command
argument_list|,
literal|"Print a constant string.  Give string as argument.\n\ C escape sequences may be used in the argument.\n\ No newline is added at the end of the argument;\n\ use \"\\n\" if you want a newline to be printed.\n\ Since leading and trailing whitespace are ignored in command arguments,\n\ if you want to print some you must use \"\\\" before leading whitespace\n\ to be printed or after trailing whitespace."
argument_list|)
expr_stmt|;
name|add_com
argument_list|(
literal|"document"
argument_list|,
name|class_support
argument_list|,
name|document_command
argument_list|,
literal|"Document a user-defined command.\n\ Give command name as argument.  Give documentation on following lines.\n\ End with a line of just \"end\"."
argument_list|)
expr_stmt|;
name|add_com
argument_list|(
literal|"define"
argument_list|,
name|class_support
argument_list|,
name|define_command
argument_list|,
literal|"Define a new command name.  Command name is argument.\n\ Definition appears on following lines, one command per line.\n\ End with a line of just \"end\".\n\ Use the \"document\" command to give documentation for the new command.\n\ Commands defined in this way do not take arguments."
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|__STDC__
name|add_com
argument_list|(
literal|"source"
argument_list|,
name|class_support
argument_list|,
name|source_command
argument_list|,
literal|"Read commands from a file named FILE.\n\ Note that the file \""
name|GDBINIT_FILENAME
literal|"\" is read automatically in this way\n\ when gdb is started."
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* Punt file name, we can't help it easily.  */
name|add_com
argument_list|(
literal|"source"
argument_list|,
name|class_support
argument_list|,
name|source_command
argument_list|,
literal|"Read commands from a file named FILE.\n\ Note that the file \".gdbinit\" is read automatically in this way\n\ when gdb is started."
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|add_com
argument_list|(
literal|"quit"
argument_list|,
name|class_support
argument_list|,
name|quit_command
argument_list|,
literal|"Exit gdb."
argument_list|)
expr_stmt|;
name|add_com
argument_list|(
literal|"help"
argument_list|,
name|class_support
argument_list|,
name|help_command
argument_list|,
literal|"Print list of commands."
argument_list|)
expr_stmt|;
name|add_com_alias
argument_list|(
literal|"q"
argument_list|,
literal|"quit"
argument_list|,
name|class_support
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|add_com_alias
argument_list|(
literal|"h"
argument_list|,
literal|"help"
argument_list|,
name|class_support
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|c
operator|=
name|add_set_cmd
argument_list|(
literal|"verbose"
argument_list|,
name|class_support
argument_list|,
name|var_boolean
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|info_verbose
argument_list|,
literal|"Set "
argument_list|,
operator|&
name|setlist
argument_list|)
operator|,
name|add_show_from_set
argument_list|(
name|c
argument_list|,
operator|&
name|showlist
argument_list|)
expr_stmt|;
name|c
operator|->
name|function
operator|.
name|sfunc
operator|=
name|set_verbose
expr_stmt|;
name|set_verbose
argument_list|(
name|NULL
argument_list|,
literal|0
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|add_prefix_cmd
argument_list|(
literal|"history"
argument_list|,
name|class_support
argument_list|,
name|set_history
argument_list|,
literal|"Generic command for setting command history parameters."
argument_list|,
operator|&
name|sethistlist
argument_list|,
literal|"set history "
argument_list|,
literal|0
argument_list|,
operator|&
name|setlist
argument_list|)
expr_stmt|;
name|add_prefix_cmd
argument_list|(
literal|"history"
argument_list|,
name|class_support
argument_list|,
name|show_history
argument_list|,
literal|"Generic command for showing command history parameters."
argument_list|,
operator|&
name|showhistlist
argument_list|,
literal|"show history "
argument_list|,
literal|0
argument_list|,
operator|&
name|showlist
argument_list|)
expr_stmt|;
name|add_show_from_set
argument_list|(
name|add_set_cmd
argument_list|(
literal|"save"
argument_list|,
name|no_class
argument_list|,
name|var_boolean
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|write_history_p
argument_list|,
literal|"Set saving of the history record on exit.\n\ Use \"on\" to enable to enable the saving, and \"off\" to disable it.\n\ Without an argument, saving is enabled."
argument_list|,
operator|&
name|sethistlist
argument_list|)
argument_list|,
operator|&
name|showhistlist
argument_list|)
expr_stmt|;
name|c
operator|=
name|add_set_cmd
argument_list|(
literal|"size"
argument_list|,
name|no_class
argument_list|,
name|var_uinteger
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|history_size
argument_list|,
literal|"Set the size of the command history, \n\ ie. the number of previous commands to keep a record of."
argument_list|,
operator|&
name|sethistlist
argument_list|)
expr_stmt|;
name|add_show_from_set
argument_list|(
name|c
argument_list|,
operator|&
name|showhistlist
argument_list|)
expr_stmt|;
name|c
operator|->
name|function
operator|.
name|sfunc
operator|=
name|set_history_size_command
expr_stmt|;
name|add_show_from_set
argument_list|(
name|add_set_cmd
argument_list|(
literal|"filename"
argument_list|,
name|no_class
argument_list|,
name|var_filename
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|history_filename
argument_list|,
literal|"Set the filename in which to record the command history\n\  (the list of previous commands of which a record is kept)."
argument_list|,
operator|&
name|sethistlist
argument_list|)
argument_list|,
operator|&
name|showhistlist
argument_list|)
expr_stmt|;
name|add_show_from_set
argument_list|(
name|add_set_cmd
argument_list|(
literal|"confirm"
argument_list|,
name|class_support
argument_list|,
name|var_boolean
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|caution
argument_list|,
literal|"Set whether to confirm potentially dangerous operations."
argument_list|,
operator|&
name|setlist
argument_list|)
argument_list|,
operator|&
name|showlist
argument_list|)
expr_stmt|;
name|add_prefix_cmd
argument_list|(
literal|"info"
argument_list|,
name|class_info
argument_list|,
name|info_command
argument_list|,
literal|"Generic command for showing things about the program being debugged."
argument_list|,
operator|&
name|infolist
argument_list|,
literal|"info "
argument_list|,
literal|0
argument_list|,
operator|&
name|cmdlist
argument_list|)
expr_stmt|;
name|add_com_alias
argument_list|(
literal|"i"
argument_list|,
literal|"info"
argument_list|,
name|class_info
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|add_prefix_cmd
argument_list|(
literal|"show"
argument_list|,
name|class_info
argument_list|,
name|show_command
argument_list|,
literal|"Generic command for showing things about the debugger."
argument_list|,
operator|&
name|showlist
argument_list|,
literal|"show "
argument_list|,
literal|0
argument_list|,
operator|&
name|cmdlist
argument_list|)
expr_stmt|;
comment|/* Another way to get at the same thing.  */
name|add_info
argument_list|(
literal|"set"
argument_list|,
name|show_command
argument_list|,
literal|"Show all GDB settings."
argument_list|)
expr_stmt|;
name|add_cmd
argument_list|(
literal|"commands"
argument_list|,
name|no_class
argument_list|,
name|show_commands
argument_list|,
literal|"Show the the history of commands you typed.\n\ You can supply a command number to start with, or a `+' to start after\n\ the previous command number shown."
argument_list|,
operator|&
name|showlist
argument_list|)
expr_stmt|;
name|add_cmd
argument_list|(
literal|"version"
argument_list|,
name|no_class
argument_list|,
name|show_version
argument_list|,
literal|"Show what version of GDB this is."
argument_list|,
operator|&
name|showlist
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

