begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Print instructions for Tahoe target machines, for GDB.    Copyright 1986, 1989, 1991, 1992 Free Software Foundation, Inc.    Contributed by the State University of New York at Buffalo, by the    Distributed Computer Systems Lab, Department of Computer Science, 1991.  This file is part of GDB.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"symtab.h"
end_include

begin_include
include|#
directive|include
file|"opcode/tahoe.h"
end_include

begin_comment
comment|/* Tahoe instructions are never longer than this.  */
end_comment

begin_define
define|#
directive|define
name|MAXLEN
value|62
end_define

begin_comment
comment|/* Number of elements in the opcode table.  */
end_comment

begin_define
define|#
directive|define
name|NOPCODES
value|(sizeof votstrs / sizeof votstrs[0])
end_define

begin_function_decl
specifier|static
name|unsigned
name|char
modifier|*
name|print_insn_arg
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* Print the Tahoe instruction at address MEMADDR in debugged memory,    on STREAM.  Returns length of the instruction, in bytes.  */
end_comment

begin_function
name|int
name|print_insn
parameter_list|(
name|memaddr
parameter_list|,
name|stream
parameter_list|)
name|CORE_ADDR
name|memaddr
decl_stmt|;
name|FILE
modifier|*
name|stream
decl_stmt|;
block|{
name|unsigned
name|char
name|buffer
index|[
name|MAXLEN
index|]
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|unsigned
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|char
modifier|*
name|d
decl_stmt|;
name|read_memory
argument_list|(
name|memaddr
argument_list|,
name|buffer
argument_list|,
name|MAXLEN
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NOPCODES
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|votstrs
index|[
name|i
index|]
operator|.
name|detail
operator|.
name|code
operator|==
name|buffer
index|[
literal|0
index|]
operator|||
name|votstrs
index|[
name|i
index|]
operator|.
name|detail
operator|.
name|code
operator|==
operator|*
operator|(
name|unsigned
name|short
operator|*
operator|)
name|buffer
condition|)
break|break;
comment|/* Handle undefined instructions.  */
if|if
condition|(
name|i
operator|==
name|NOPCODES
condition|)
block|{
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"0%o"
argument_list|,
name|buffer
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"%s"
argument_list|,
name|votstrs
index|[
name|i
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
comment|/* Point at first byte of argument data,      and at descriptor for first argument.  */
name|p
operator|=
name|buffer
operator|+
literal|1
operator|+
operator|(
name|votstrs
index|[
name|i
index|]
operator|.
name|detail
operator|.
name|code
operator|>=
literal|0x100
operator|)
expr_stmt|;
name|d
operator|=
name|votstrs
index|[
name|i
index|]
operator|.
name|detail
operator|.
name|args
expr_stmt|;
if|if
condition|(
operator|*
name|d
condition|)
name|fputc
argument_list|(
literal|'\t'
argument_list|,
name|stream
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|d
condition|)
block|{
name|p
operator|=
name|print_insn_arg
argument_list|(
name|d
argument_list|,
name|p
argument_list|,
name|memaddr
operator|+
operator|(
name|p
operator|-
name|buffer
operator|)
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|d
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
operator|*
name|d
condition|)
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|","
argument_list|)
expr_stmt|;
block|}
return|return
name|p
operator|-
name|buffer
return|;
block|}
end_function

begin_comment
comment|/*******************************************************************/
end_comment

begin_function
specifier|static
name|unsigned
name|char
modifier|*
name|print_insn_arg
parameter_list|(
name|d
parameter_list|,
name|p
parameter_list|,
name|addr
parameter_list|,
name|stream
parameter_list|)
name|char
modifier|*
name|d
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|CORE_ADDR
name|addr
decl_stmt|;
name|FILE
modifier|*
name|stream
decl_stmt|;
block|{
name|int
name|temp1
init|=
literal|0
decl_stmt|;
specifier|register
name|int
name|regnum
init|=
operator|*
name|p
operator|&
literal|0xf
decl_stmt|;
name|float
name|floatlitbuf
decl_stmt|;
if|if
condition|(
operator|*
name|d
operator|==
literal|'b'
condition|)
block|{
if|if
condition|(
name|d
index|[
literal|1
index|]
operator|==
literal|'b'
condition|)
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"0x%x"
argument_list|,
name|addr
operator|+
operator|*
name|p
operator|++
operator|+
literal|1
argument_list|)
expr_stmt|;
else|else
block|{
name|temp1
operator|=
operator|*
name|p
expr_stmt|;
name|temp1
operator|<<=
literal|8
expr_stmt|;
name|temp1
operator||=
operator|*
operator|(
name|p
operator|+
literal|1
operator|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"0x%x"
argument_list|,
name|addr
operator|+
name|temp1
operator|+
literal|2
argument_list|)
expr_stmt|;
name|p
operator|+=
literal|2
expr_stmt|;
block|}
block|}
else|else
switch|switch
condition|(
operator|(
operator|*
name|p
operator|++
operator|>>
literal|4
operator|)
operator|&
literal|0xf
condition|)
block|{
case|case
literal|0
case|:
case|case
literal|1
case|:
case|case
literal|2
case|:
case|case
literal|3
case|:
comment|/* Literal (short immediate byte) mode */
if|if
condition|(
name|d
index|[
literal|1
index|]
operator|==
literal|'d'
operator|||
name|d
index|[
literal|1
index|]
operator|==
literal|'f'
operator|||
name|d
index|[
literal|1
index|]
operator|==
literal|'g'
operator|||
name|d
index|[
literal|1
index|]
operator|==
literal|'h'
condition|)
block|{
operator|*
operator|(
name|int
operator|*
operator|)
operator|&
name|floatlitbuf
operator|=
literal|0x4000
operator|+
operator|(
operator|(
name|p
index|[
operator|-
literal|1
index|]
operator|&
literal|0x3f
operator|)
operator|<<
literal|4
operator|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"$%f"
argument_list|,
name|floatlitbuf
argument_list|)
expr_stmt|;
block|}
else|else
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"$%d"
argument_list|,
name|p
index|[
operator|-
literal|1
index|]
operator|&
literal|0x3f
argument_list|)
expr_stmt|;
break|break;
case|case
literal|4
case|:
comment|/* Indexed */
name|p
operator|=
operator|(
name|char
operator|*
operator|)
name|print_insn_arg
argument_list|(
name|d
argument_list|,
name|p
argument_list|,
name|addr
operator|+
literal|1
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"[%s]"
argument_list|,
name|reg_names
index|[
name|regnum
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
literal|5
case|:
comment|/* Register */
name|fprintf
argument_list|(
name|stream
argument_list|,
name|reg_names
index|[
name|regnum
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
literal|7
case|:
comment|/* Autodecrement */
name|fputc
argument_list|(
literal|'-'
argument_list|,
name|stream
argument_list|)
expr_stmt|;
case|case
literal|6
case|:
comment|/* Register deferred */
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"(%s)"
argument_list|,
name|reg_names
index|[
name|regnum
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
literal|9
case|:
comment|/* Absolute Address& Autoincrement deferred */
name|fputc
argument_list|(
literal|'*'
argument_list|,
name|stream
argument_list|)
expr_stmt|;
if|if
condition|(
name|regnum
operator|==
name|PC_REGNUM
condition|)
block|{
name|temp1
operator|=
operator|*
name|p
expr_stmt|;
name|temp1
operator|<<=
literal|8
expr_stmt|;
name|temp1
operator||=
operator|*
operator|(
name|p
operator|+
literal|1
operator|)
expr_stmt|;
name|fputc
argument_list|(
literal|'$'
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|print_address
argument_list|(
name|temp1
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|p
operator|+=
literal|4
expr_stmt|;
break|break;
block|}
case|case
literal|8
case|:
comment|/*Immediate& Autoincrement SP */
if|if
condition|(
name|regnum
operator|==
literal|8
condition|)
comment|/*88 is Immediate Byte Mode*/
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"$%d"
argument_list|,
operator|*
name|p
operator|++
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|regnum
operator|==
literal|9
condition|)
comment|/*89 is Immediate Word Mode*/
block|{
name|temp1
operator|=
operator|*
name|p
expr_stmt|;
name|temp1
operator|<<=
literal|8
expr_stmt|;
name|temp1
operator||=
operator|*
operator|(
name|p
operator|+
literal|1
operator|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"$%d"
argument_list|,
name|temp1
argument_list|)
expr_stmt|;
name|p
operator|+=
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|regnum
operator|==
name|PC_REGNUM
condition|)
comment|/*8F is Immediate Long Mode*/
block|{
name|temp1
operator|=
operator|*
name|p
expr_stmt|;
name|temp1
operator|<<=
literal|8
expr_stmt|;
name|temp1
operator||=
operator|*
operator|(
name|p
operator|+
literal|1
operator|)
expr_stmt|;
name|temp1
operator|<<=
literal|8
expr_stmt|;
name|temp1
operator||=
operator|*
operator|(
name|p
operator|+
literal|2
operator|)
expr_stmt|;
name|temp1
operator|<<=
literal|8
expr_stmt|;
name|temp1
operator||=
operator|*
operator|(
name|p
operator|+
literal|3
operator|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"$%d"
argument_list|,
name|temp1
argument_list|)
expr_stmt|;
name|p
operator|+=
literal|4
expr_stmt|;
block|}
else|else
comment|/*8E is Autoincrement SP Mode*/
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"(%s)+"
argument_list|,
name|reg_names
index|[
name|regnum
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
literal|11
case|:
comment|/* Register + Byte Displacement Deferred Mode*/
name|fputc
argument_list|(
literal|'*'
argument_list|,
name|stream
argument_list|)
expr_stmt|;
case|case
literal|10
case|:
comment|/* Register + Byte Displacement Mode*/
if|if
condition|(
name|regnum
operator|==
name|PC_REGNUM
condition|)
name|print_address
argument_list|(
name|addr
operator|+
operator|*
name|p
operator|+
literal|2
argument_list|,
name|stream
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"%d(%s)"
argument_list|,
operator|*
name|p
argument_list|,
name|reg_names
index|[
name|regnum
index|]
argument_list|)
expr_stmt|;
name|p
operator|+=
literal|1
expr_stmt|;
break|break;
case|case
literal|13
case|:
comment|/* Register + Word Displacement Deferred Mode*/
name|fputc
argument_list|(
literal|'*'
argument_list|,
name|stream
argument_list|)
expr_stmt|;
case|case
literal|12
case|:
comment|/* Register + Word Displacement Mode*/
name|temp1
operator|=
operator|*
name|p
expr_stmt|;
name|temp1
operator|<<=
literal|8
expr_stmt|;
name|temp1
operator||=
operator|*
operator|(
name|p
operator|+
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|regnum
operator|==
name|PC_REGNUM
condition|)
name|print_address
argument_list|(
name|addr
operator|+
name|temp1
operator|+
literal|3
argument_list|,
name|stream
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"%d(%s)"
argument_list|,
name|temp1
argument_list|,
name|reg_names
index|[
name|regnum
index|]
argument_list|)
expr_stmt|;
name|p
operator|+=
literal|2
expr_stmt|;
break|break;
case|case
literal|15
case|:
comment|/* Register + Long Displacement Deferred Mode*/
name|fputc
argument_list|(
literal|'*'
argument_list|,
name|stream
argument_list|)
expr_stmt|;
case|case
literal|14
case|:
comment|/* Register + Long Displacement Mode*/
name|temp1
operator|=
operator|*
name|p
expr_stmt|;
name|temp1
operator|<<=
literal|8
expr_stmt|;
name|temp1
operator||=
operator|*
operator|(
name|p
operator|+
literal|1
operator|)
expr_stmt|;
name|temp1
operator|<<=
literal|8
expr_stmt|;
name|temp1
operator||=
operator|*
operator|(
name|p
operator|+
literal|2
operator|)
expr_stmt|;
name|temp1
operator|<<=
literal|8
expr_stmt|;
name|temp1
operator||=
operator|*
operator|(
name|p
operator|+
literal|3
operator|)
expr_stmt|;
if|if
condition|(
name|regnum
operator|==
name|PC_REGNUM
condition|)
name|print_address
argument_list|(
name|addr
operator|+
name|temp1
operator|+
literal|5
argument_list|,
name|stream
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"%d(%s)"
argument_list|,
name|temp1
argument_list|,
name|reg_names
index|[
name|regnum
index|]
argument_list|)
expr_stmt|;
name|p
operator|+=
literal|4
expr_stmt|;
block|}
return|return
operator|(
name|unsigned
name|char
operator|*
operator|)
name|p
return|;
block|}
end_function

end_unit

