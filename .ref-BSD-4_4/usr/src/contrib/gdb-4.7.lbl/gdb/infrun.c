begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Target-struct-independent code to start (run) and stop an inferior process.    Copyright 1986, 1987, 1988, 1989, 1991, 1992 Free Software Foundation, Inc.  This file is part of GDB.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_comment
comment|/* Notes on the algorithm used in wait_for_inferior to determine if we    just did a subroutine call when stepping.  We have the following    information at that point:                    Current and previous (just before this step) pc. 		  Current and previous sp. 		  Current and previous start of current function.     If the starts of the functions don't match, then     	a) We did a subroutine call.     In this case, the pc will be at the beginning of a function.  	b) We did a subroutine return.     Otherwise.  	c) We did a longjmp.     If we did a longjump, we were doing "nexti", since a next would    have attempted to skip over the assembly language routine in which    the longjmp is coded and would have simply been the equivalent of a    continue.  I consider this ok behaivior.  We'd like one of two    things to happen if we are doing a nexti through the longjmp()    routine: 1) It behaves as a stepi, or 2) It acts like a continue as    above.  Given that this is a special case, and that anybody who    thinks that the concept of sub calls is meaningful in the context    of a longjmp, I'll take either one.  Let's see what happens.       Acts like a subroutine return.  I can handle that with no problem    at all.     -->So: If the current and previous beginnings of the current    function don't match, *and* the pc is at the start of a function,    we've done a subroutine call.  If the pc is not at the start of a    function, we *didn't* do a subroutine call.       -->If the beginnings of the current and previous function do match,    either:      	a) We just did a recursive call.  	   In this case, we would be at the very beginning of a 	   function and 1) it will have a prologue (don't jump to 	   before prologue, or 2) (we assume here that it doesn't have 	   a prologue) there will have been a change in the stack 	   pointer over the last instruction.  (Ie. it's got to put 	   the saved pc somewhere.  The stack is the usual place.  In 	   a recursive call a register is only an option if there's a 	   prologue to do something with it.  This is even true on 	   register window machines; the prologue sets up the new 	   window.  It might not be true on a register window machine 	   where the call instruction moved the register window 	   itself.  Hmmm.  One would hope that the stack pointer would 	   also change.  If it doesn't, somebody send me a note, and 	   I'll work out a more general theory. 	   bug-gdb@prep.ai.mit.edu).  This is true (albeit slipperly 	   so) on all machines I'm aware of:  	      m68k:	Call changes stack pointer.  Regular jumps don't.  	      sparc:	Recursive calls must have frames and therefor, 	                prologues.  	      vax:	All calls have frames and hence change the 	                stack pointer.  	b) We did a return from a recursive call.  I don't see that we 	   have either the ability or the need to distinguish this 	   from an ordinary jump.  The stack frame will be printed 	   when and if the frame pointer changes; if we are in a 	   function without a frame pointer, it's the users own 	   lookout.  	c) We did a jump within a function.  We assume that this is 	   true if we didn't do a recursive call.  	d) We are in no-man's land ("I see no symbols here").  We 	   don't worry about this; it will make calls look like simple 	   jumps (and the stack frames will be printed when the frame 	   pointer moves), which is a reasonably non-violent response. */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|"symtab.h"
end_include

begin_include
include|#
directive|include
file|"frame.h"
end_include

begin_include
include|#
directive|include
file|"inferior.h"
end_include

begin_include
include|#
directive|include
file|"breakpoint.h"
end_include

begin_include
include|#
directive|include
file|"wait.h"
end_include

begin_include
include|#
directive|include
file|"gdbcore.h"
end_include

begin_include
include|#
directive|include
file|"gdbcmd.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_comment
comment|/* unistd.h is needed to #define X_OK */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|USG
end_ifdef

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Prototypes for local functions */
end_comment

begin_decl_stmt
specifier|static
name|void
name|signals_info
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|handle_command
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|sig_print_info
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|sig_print_header
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|remove_step_breakpoint
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|insert_step_breakpoint
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|resume_cleanups
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|hook_stop_stub
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Sigtramp is a routine that the kernel calls (which then calls the    signal handler).  On most machines it is a library routine that    is linked into the executable.     This macro, given a program counter value and the name of the    function in which that PC resides (which can be null if the    name is not known), returns nonzero if the PC and name show    that we are in sigtramp.     On most machines just see if the name is sigtramp (and if we have    no name, assume we are not in sigtramp).  */
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|IN_SIGTRAMP
argument_list|)
end_if

begin_define
define|#
directive|define
name|IN_SIGTRAMP
parameter_list|(
name|pc
parameter_list|,
name|name
parameter_list|)
define|\
value|(name&& !strcmp ("_sigtramp", name))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* GET_LONGJMP_TARGET returns the PC at which longjmp() will resume the    program.  It needs to examine the jmp_buf argument and extract the PC    from it.  The return value is non-zero on success, zero otherwise. */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|GET_LONGJMP_TARGET
end_ifndef

begin_define
define|#
directive|define
name|GET_LONGJMP_TARGET
parameter_list|(
name|PC_ADDR
parameter_list|)
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Some machines have trampoline code that sits between function callers    and the actual functions themselves.  If this machine doesn't have    such things, disable their processing.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|SKIP_TRAMPOLINE_CODE
end_ifndef

begin_define
define|#
directive|define
name|SKIP_TRAMPOLINE_CODE
parameter_list|(
name|pc
parameter_list|)
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* For SVR4 shared libraries, each call goes through a small piece of    trampoline code in the ".init" section.  IN_SOLIB_TRAMPOLINE evaluates    to nonzero if we are current stopped in one of these. */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|IN_SOLIB_TRAMPOLINE
end_ifndef

begin_define
define|#
directive|define
name|IN_SOLIB_TRAMPOLINE
parameter_list|(
name|pc
parameter_list|,
name|name
parameter_list|)
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|TDESC
end_ifdef

begin_include
include|#
directive|include
file|"tdesc.h"
end_include

begin_decl_stmt
name|int
name|safe_to_init_tdesc_context
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|dc_dcontext_t
name|current_context
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Tables of how to react to signals; the user sets them.  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|char
modifier|*
name|signal_stop
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|char
modifier|*
name|signal_print
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|char
modifier|*
name|signal_program
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|SET_SIGS
parameter_list|(
name|nsigs
parameter_list|,
name|sigs
parameter_list|,
name|flags
parameter_list|)
define|\
value|do { \     int signum = (nsigs); \     while (signum--> 0) \       if ((sigs)[signum]) \ 	(flags)[signum] = 1; \   } while (0)
end_define

begin_define
define|#
directive|define
name|UNSET_SIGS
parameter_list|(
name|nsigs
parameter_list|,
name|sigs
parameter_list|,
name|flags
parameter_list|)
define|\
value|do { \     int signum = (nsigs); \     while (signum--> 0) \       if ((sigs)[signum]) \ 	(flags)[signum] = 0; \   } while (0)
end_define

begin_comment
comment|/* Command list pointer for the "stop" placeholder.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|cmd_list_element
modifier|*
name|stop_command
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if breakpoints are now inserted in the inferior.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|breakpoints_inserted
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Function inferior was in as of last step command.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|symbol
modifier|*
name|step_start_function
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero => address for special breakpoint for resuming stepping.  */
end_comment

begin_decl_stmt
specifier|static
name|CORE_ADDR
name|step_resume_break_address
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Pointer to orig contents of the byte where the special breakpoint is.  */
end_comment

begin_decl_stmt
specifier|static
name|char
name|step_resume_break_shadow
index|[
name|BREAKPOINT_MAX
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means the special breakpoint is a duplicate    so it has not itself been inserted.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|step_resume_break_duplicate
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if we are expecting a trace trap and should proceed from it.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|trap_expected
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if the next time we try to continue the inferior, it will    step one instruction and generate a spurious trace trap.    This is used to compensate for a bug in HP-UX.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|trap_expected_after_continue
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means expecting a trace trap    and should stop the inferior and return silently when it happens.  */
end_comment

begin_decl_stmt
name|int
name|stop_after_trap
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means expecting a trap and caller will handle it themselves.    It is used after attach, due to attaching to a process;    when running in the shell before the child program has been exec'd;    and when running some kinds of remote stuff (FIXME?).  */
end_comment

begin_decl_stmt
name|int
name|stop_soon_quietly
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if pc has been changed by the debugger    since the inferior stopped.  */
end_comment

begin_decl_stmt
name|int
name|pc_changed
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if program stopped due to error trying to insert breakpoints.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|breakpoints_failed
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero after stop if current stack frame should be printed.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|stop_print_frame
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|NO_SINGLE_STEP
end_ifdef

begin_decl_stmt
specifier|extern
name|int
name|one_stepped
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* From machine dependent code */
end_comment

begin_function_decl
specifier|extern
name|void
name|single_step
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* Same. */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NO_SINGLE_STEP */
end_comment

begin_escape
end_escape

begin_comment
comment|/* Things to clean up if we QUIT out of resume ().  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|void
name|resume_cleanups
parameter_list|(
name|arg
parameter_list|)
name|int
name|arg
decl_stmt|;
block|{
name|normal_stop
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Resume the inferior, but allow a QUIT.  This is useful if the user    wants to interrupt some lengthy single-stepping operation    (for child processes, the SIGINT goes to the inferior, and so    we get a SIGINT random_signal, but for remote debugging and perhaps    other targets, that's not true).     STEP nonzero if we should step (zero to continue instead).    SIG is the signal to give the inferior (zero for none).  */
end_comment

begin_function
name|void
name|resume
parameter_list|(
name|step
parameter_list|,
name|sig
parameter_list|)
name|int
name|step
decl_stmt|;
name|int
name|sig
decl_stmt|;
block|{
name|struct
name|cleanup
modifier|*
name|old_cleanups
init|=
name|make_cleanup
argument_list|(
name|resume_cleanups
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|QUIT
expr_stmt|;
ifdef|#
directive|ifdef
name|NO_SINGLE_STEP
if|if
condition|(
name|step
condition|)
block|{
name|single_step
argument_list|(
name|sig
argument_list|)
expr_stmt|;
comment|/* Do it the hard way, w/temp breakpoints */
name|step
operator|=
literal|0
expr_stmt|;
comment|/* ...and don't ask hardware to do it.  */
block|}
endif|#
directive|endif
comment|/* Handle any optimized stores to the inferior NOW...  */
ifdef|#
directive|ifdef
name|DO_DEFERRED_STORES
name|DO_DEFERRED_STORES
expr_stmt|;
endif|#
directive|endif
name|target_resume
argument_list|(
name|step
argument_list|,
name|sig
argument_list|)
expr_stmt|;
name|discard_cleanups
argument_list|(
name|old_cleanups
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Clear out all variables saying what to do when inferior is continued.    First do this, then set the ones you want, then call `proceed'.  */
end_comment

begin_function
name|void
name|clear_proceed_status
parameter_list|()
block|{
name|trap_expected
operator|=
literal|0
expr_stmt|;
name|step_range_start
operator|=
literal|0
expr_stmt|;
name|step_range_end
operator|=
literal|0
expr_stmt|;
name|step_frame_address
operator|=
literal|0
expr_stmt|;
name|step_over_calls
operator|=
operator|-
literal|1
expr_stmt|;
name|step_resume_break_address
operator|=
literal|0
expr_stmt|;
name|stop_after_trap
operator|=
literal|0
expr_stmt|;
name|stop_soon_quietly
operator|=
literal|0
expr_stmt|;
name|breakpoint_proceeded
operator|=
literal|1
expr_stmt|;
comment|/* We're about to proceed... */
comment|/* Discard any remaining commands or status from previous stop.  */
name|bpstat_clear
argument_list|(
operator|&
name|stop_bpstat
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Basic routine for continuing the program in various fashions.     ADDR is the address to resume at, or -1 for resume where stopped.    SIGGNAL is the signal to give it, or 0 for none,      or -1 for act according to how it stopped.    STEP is nonzero if should trap after one instruction.      -1 means return after that and print nothing.      You should probably set various step_... variables      before calling here, if you are stepping.     You should call clear_proceed_status before calling proceed.  */
end_comment

begin_function
name|void
name|proceed
parameter_list|(
name|addr
parameter_list|,
name|siggnal
parameter_list|,
name|step
parameter_list|)
name|CORE_ADDR
name|addr
decl_stmt|;
name|int
name|siggnal
decl_stmt|;
name|int
name|step
decl_stmt|;
block|{
name|int
name|oneproc
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|step
operator|>
literal|0
condition|)
name|step_start_function
operator|=
name|find_pc_function
argument_list|(
name|read_pc
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|step
operator|<
literal|0
condition|)
name|stop_after_trap
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|addr
operator|==
operator|(
name|CORE_ADDR
operator|)
operator|-
literal|1
condition|)
block|{
comment|/* If there is a breakpoint at the address we will resume at, 	 step one instruction before inserting breakpoints 	 so that we do not stop right away.  */
if|if
condition|(
operator|!
name|pc_changed
operator|&&
name|breakpoint_here_p
argument_list|(
name|read_pc
argument_list|()
argument_list|)
condition|)
name|oneproc
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|write_register
argument_list|(
name|PC_REGNUM
argument_list|,
name|addr
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|NPC_REGNUM
name|write_register
argument_list|(
name|NPC_REGNUM
argument_list|,
name|addr
operator|+
literal|4
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|NNPC_REGNUM
name|write_register
argument_list|(
name|NNPC_REGNUM
argument_list|,
name|addr
operator|+
literal|8
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
block|}
if|if
condition|(
name|trap_expected_after_continue
condition|)
block|{
comment|/* If (step == 0), a trap will be automatically generated after 	 the first instruction is executed.  Force step one 	 instruction to clear this condition.  This should not occur 	 if step is nonzero, but it is harmless in that case.  */
name|oneproc
operator|=
literal|1
expr_stmt|;
name|trap_expected_after_continue
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|oneproc
condition|)
comment|/* We will get a trace trap after one instruction.        Continue it automatically and insert breakpoints then.  */
name|trap_expected
operator|=
literal|1
expr_stmt|;
else|else
block|{
name|int
name|temp
init|=
name|insert_breakpoints
argument_list|()
decl_stmt|;
if|if
condition|(
name|temp
condition|)
block|{
name|print_sys_errmsg
argument_list|(
literal|"ptrace"
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"Cannot insert breakpoints.\n\ The same program may be running in another process."
argument_list|)
expr_stmt|;
block|}
name|breakpoints_inserted
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Install inferior's terminal modes.  */
name|target_terminal_inferior
argument_list|()
expr_stmt|;
if|if
condition|(
name|siggnal
operator|>=
literal|0
condition|)
name|stop_signal
operator|=
name|siggnal
expr_stmt|;
comment|/* If this signal should not be seen by program,      give it zero.  Used for debugging signals.  */
elseif|else
if|if
condition|(
name|stop_signal
operator|<
name|NSIG
operator|&&
operator|!
name|signal_program
index|[
name|stop_signal
index|]
condition|)
name|stop_signal
operator|=
literal|0
expr_stmt|;
comment|/* Resume inferior.  */
name|resume
argument_list|(
name|oneproc
operator|||
name|step
operator|||
name|bpstat_should_step
argument_list|()
argument_list|,
name|stop_signal
argument_list|)
expr_stmt|;
comment|/* Wait for it to stop (if not standalone)      and in any case decode why it stopped, and act accordingly.  */
name|wait_for_inferior
argument_list|()
expr_stmt|;
name|normal_stop
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Record the pc and sp of the program the last time it stopped.    These are just used internally by wait_for_inferior, but need    to be preserved over calls to it and cleared when the inferior    is started.  */
end_comment

begin_decl_stmt
specifier|static
name|CORE_ADDR
name|prev_pc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|CORE_ADDR
name|prev_sp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|CORE_ADDR
name|prev_func_start
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|prev_func_name
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|init_wait_for_inferior_keep_brkpts
parameter_list|()
block|{
comment|/* These are meaningless until the first time through wait_for_inferior.  */
name|prev_pc
operator|=
literal|0
expr_stmt|;
name|prev_sp
operator|=
literal|0
expr_stmt|;
name|prev_func_start
operator|=
literal|0
expr_stmt|;
name|prev_func_name
operator|=
name|NULL
expr_stmt|;
name|trap_expected_after_continue
operator|=
literal|0
expr_stmt|;
name|stop_signal
operator|=
literal|0
expr_stmt|;
comment|/* Don't confuse first call to proceed(). */
block|}
end_function

begin_comment
comment|/* Initialize static vars when a new inferior begins.  */
end_comment

begin_function
name|void
name|init_wait_for_inferior
parameter_list|()
block|{
name|init_wait_for_inferior_keep_brkpts
argument_list|()
expr_stmt|;
name|breakpoints_inserted
operator|=
literal|0
expr_stmt|;
name|mark_breakpoints_out
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|remote_go
parameter_list|()
block|{
name|clear_proceed_status
argument_list|()
expr_stmt|;
name|stop_soon_quietly
operator|=
literal|1
expr_stmt|;
name|trap_expected
operator|=
literal|0
expr_stmt|;
name|wait_for_inferior
argument_list|()
expr_stmt|;
name|normal_stop
argument_list|()
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Wait for control to return from inferior to debugger.    If inferior gets a signal, we may decide to start it up again    instead of returning.  That is why there is a loop in this function.    When this function actually returns it means the inferior    should be left stopped and GDB should read more commands.  */
end_comment

begin_function
name|void
name|wait_for_inferior
parameter_list|()
block|{
name|WAITTYPE
name|w
decl_stmt|;
name|int
name|another_trap
decl_stmt|;
name|int
name|random_signal
decl_stmt|;
name|CORE_ADDR
name|stop_sp
decl_stmt|;
name|CORE_ADDR
name|stop_func_start
decl_stmt|;
name|char
modifier|*
name|stop_func_name
decl_stmt|;
name|CORE_ADDR
name|prologue_pc
decl_stmt|,
name|tmp
decl_stmt|;
name|int
name|stop_step_resume_break
decl_stmt|;
name|struct
name|symtab_and_line
name|sal
decl_stmt|;
name|int
name|remove_breakpoints_on_following_step
init|=
literal|0
decl_stmt|;
name|int
name|current_line
decl_stmt|;
name|int
name|handling_longjmp
init|=
literal|0
decl_stmt|;
comment|/* FIXME */
name|sal
operator|=
name|find_pc_line
argument_list|(
name|prev_pc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|current_line
operator|=
name|sal
operator|.
name|line
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
comment|/* Clean up saved state that will become invalid.  */
name|pc_changed
operator|=
literal|0
expr_stmt|;
name|flush_cached_frames
argument_list|()
expr_stmt|;
name|registers_changed
argument_list|()
expr_stmt|;
name|target_wait
argument_list|(
operator|&
name|w
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SIGTRAP_STOP_AFTER_LOAD
comment|/* Somebody called load(2), and it gave us a "trap signal after load".          Ignore it gracefully. */
name|SIGTRAP_STOP_AFTER_LOAD
argument_list|(
name|w
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* See if the process still exists; clean up if it doesn't.  */
if|if
condition|(
name|WIFEXITED
argument_list|(
name|w
argument_list|)
condition|)
block|{
name|target_terminal_ours
argument_list|()
expr_stmt|;
comment|/* Must do this before mourn anyway */
if|if
condition|(
name|WEXITSTATUS
argument_list|(
name|w
argument_list|)
condition|)
name|printf_filtered
argument_list|(
literal|"\nProgram exited with code 0%o.\n"
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|WEXITSTATUS
argument_list|(
name|w
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|batch_mode
argument_list|()
condition|)
name|printf_filtered
argument_list|(
literal|"\nProgram exited normally.\n"
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|target_mourn_inferior
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|NO_SINGLE_STEP
name|one_stepped
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
name|stop_print_frame
operator|=
literal|0
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
operator|!
name|WIFSTOPPED
argument_list|(
name|w
argument_list|)
condition|)
block|{
name|stop_print_frame
operator|=
literal|0
expr_stmt|;
name|stop_signal
operator|=
name|WTERMSIG
argument_list|(
name|w
argument_list|)
expr_stmt|;
name|target_terminal_ours
argument_list|()
expr_stmt|;
comment|/* Must do this before mourn anyway */
name|target_kill
argument_list|()
expr_stmt|;
comment|/* kill mourns as well */
ifdef|#
directive|ifdef
name|PRINT_RANDOM_SIGNAL
name|printf_filtered
argument_list|(
literal|"\nProgram terminated: "
argument_list|)
expr_stmt|;
name|PRINT_RANDOM_SIGNAL
argument_list|(
name|stop_signal
argument_list|)
expr_stmt|;
else|#
directive|else
name|printf_filtered
argument_list|(
literal|"\nProgram terminated with signal %d, %s\n"
argument_list|,
name|stop_signal
argument_list|,
name|safe_strsignal
argument_list|(
name|stop_signal
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|printf_filtered
argument_list|(
literal|"The inferior process no longer exists.\n"
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|NO_SINGLE_STEP
name|one_stepped
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
break|break;
block|}
ifdef|#
directive|ifdef
name|NO_SINGLE_STEP
if|if
condition|(
name|one_stepped
condition|)
name|single_step
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* This actually cleans up the ss */
endif|#
directive|endif
comment|/* NO_SINGLE_STEP */
name|stop_pc
operator|=
name|read_pc
argument_list|()
expr_stmt|;
name|set_current_frame
argument_list|(
name|create_new_frame
argument_list|(
name|read_register
argument_list|(
name|FP_REGNUM
argument_list|)
argument_list|,
name|read_pc
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|stop_frame_address
operator|=
name|FRAME_FP
argument_list|(
name|get_current_frame
argument_list|()
argument_list|)
expr_stmt|;
name|stop_sp
operator|=
name|read_register
argument_list|(
name|SP_REGNUM
argument_list|)
expr_stmt|;
name|stop_func_start
operator|=
literal|0
expr_stmt|;
name|stop_func_name
operator|=
literal|0
expr_stmt|;
comment|/* Don't care about return value; stop_func_start and stop_func_name 	 will both be 0 if it doesn't work.  */
name|find_pc_partial_function
argument_list|(
name|stop_pc
argument_list|,
operator|&
name|stop_func_name
argument_list|,
operator|&
name|stop_func_start
argument_list|)
expr_stmt|;
name|stop_func_start
operator|+=
name|FUNCTION_START_OFFSET
expr_stmt|;
name|another_trap
operator|=
literal|0
expr_stmt|;
name|bpstat_clear
argument_list|(
operator|&
name|stop_bpstat
argument_list|)
expr_stmt|;
name|stop_step
operator|=
literal|0
expr_stmt|;
name|stop_stack_dummy
operator|=
literal|0
expr_stmt|;
name|stop_print_frame
operator|=
literal|1
expr_stmt|;
name|stop_step_resume_break
operator|=
literal|0
expr_stmt|;
name|random_signal
operator|=
literal|0
expr_stmt|;
name|stopped_by_random_signal
operator|=
literal|0
expr_stmt|;
name|breakpoints_failed
operator|=
literal|0
expr_stmt|;
comment|/* Look at the cause of the stop, and decide what to do. 	 The alternatives are: 	 1) break; to really stop and return to the debugger, 	 2) drop through to start up again 	 (set another_trap to 1 to single step once) 	 3) set random_signal to 1, and the decision between 1 and 2 	 will be made according to the signal handling tables.  */
name|stop_signal
operator|=
name|WSTOPSIG
argument_list|(
name|w
argument_list|)
expr_stmt|;
comment|/* First, distinguish signals caused by the debugger from signals 	 that have to do with the program's own actions. 	 Note that breakpoint insns may cause SIGTRAP or SIGILL 	 or SIGEMT, depending on the operating system version. 	 Here we detect when a SIGILL or SIGEMT is really a breakpoint 	 and change it to SIGTRAP.  */
if|if
condition|(
name|stop_signal
operator|==
name|SIGTRAP
operator|||
operator|(
name|breakpoints_inserted
operator|&&
operator|(
name|stop_signal
operator|==
name|SIGILL
ifdef|#
directive|ifdef
name|SIGEMT
operator|||
name|stop_signal
operator|==
name|SIGEMT
endif|#
directive|endif
operator|)
operator|)
operator|||
name|stop_soon_quietly
condition|)
block|{
if|if
condition|(
name|stop_signal
operator|==
name|SIGTRAP
operator|&&
name|stop_after_trap
condition|)
block|{
name|stop_print_frame
operator|=
literal|0
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|stop_soon_quietly
condition|)
break|break;
comment|/* Don't even think about breakpoints 	     if just proceeded over a breakpoint.  	     However, if we are trying to proceed over a breakpoint 	     and end up in sigtramp, then step_resume_break_address 	     will be set and we should check whether we've hit the 	     step breakpoint.  */
if|if
condition|(
name|stop_signal
operator|==
name|SIGTRAP
operator|&&
name|trap_expected
operator|&&
name|step_resume_break_address
operator|==
literal|0
condition|)
name|bpstat_clear
argument_list|(
operator|&
name|stop_bpstat
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* See if there is a breakpoint at the current PC.  */
if|#
directive|if
name|DECR_PC_AFTER_BREAK
comment|/* Notice the case of stepping through a jump 		 that lands just after a breakpoint. 		 Don't confuse that with hitting the breakpoint. 		 What we check for is that 1) stepping is going on 		 and 2) the pc before the last insn does not match 		 the address of the breakpoint before the current pc.  */
if|if
condition|(
name|prev_pc
operator|==
name|stop_pc
operator|-
name|DECR_PC_AFTER_BREAK
operator|||
operator|!
name|step_range_end
operator|||
name|step_resume_break_address
operator|||
name|handling_longjmp
comment|/* FIXME */
condition|)
endif|#
directive|endif
comment|/* DECR_PC_AFTER_BREAK not zero */
block|{
comment|/* See if we stopped at the special breakpoint for 		     stepping over a subroutine call.  If both are zero, 		     this wasn't the reason for the stop.  */
if|if
condition|(
name|step_resume_break_address
operator|&&
name|stop_pc
operator|-
name|DECR_PC_AFTER_BREAK
operator|==
name|step_resume_break_address
condition|)
block|{
name|stop_step_resume_break
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|DECR_PC_AFTER_BREAK
condition|)
block|{
name|stop_pc
operator|-=
name|DECR_PC_AFTER_BREAK
expr_stmt|;
name|write_register
argument_list|(
name|PC_REGNUM
argument_list|,
name|stop_pc
argument_list|)
expr_stmt|;
name|pc_changed
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
name|stop_bpstat
operator|=
name|bpstat_stop_status
argument_list|(
operator|&
name|stop_pc
argument_list|,
name|stop_frame_address
argument_list|)
expr_stmt|;
comment|/* Following in case break condition called a 			 function.  */
name|stop_print_frame
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|stop_signal
operator|==
name|SIGTRAP
condition|)
name|random_signal
operator|=
operator|!
operator|(
name|bpstat_explains_signal
argument_list|(
name|stop_bpstat
argument_list|)
operator|||
name|trap_expected
operator|||
name|stop_step_resume_break
operator|||
name|PC_IN_CALL_DUMMY
argument_list|(
name|stop_pc
argument_list|,
name|stop_sp
argument_list|,
name|stop_frame_address
argument_list|)
operator|||
operator|(
name|step_range_end
operator|&&
operator|!
name|step_resume_break_address
operator|)
operator|)
expr_stmt|;
else|else
block|{
name|random_signal
operator|=
operator|!
operator|(
name|bpstat_explains_signal
argument_list|(
name|stop_bpstat
argument_list|)
operator|||
name|stop_step_resume_break
comment|/* End of a stack dummy.  Some systems (e.g. Sony 		       news) give another signal besides SIGTRAP, 		       so check here as well as above.  */
operator|||
name|PC_IN_CALL_DUMMY
argument_list|(
name|stop_pc
argument_list|,
name|stop_sp
argument_list|,
name|stop_frame_address
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|random_signal
condition|)
name|stop_signal
operator|=
name|SIGTRAP
expr_stmt|;
block|}
block|}
else|else
name|random_signal
operator|=
literal|1
expr_stmt|;
comment|/* For the program's own signals, act according to 	 the signal handling tables.  */
if|if
condition|(
name|random_signal
condition|)
block|{
comment|/* Signal not for debugging purposes.  */
name|int
name|printed
init|=
literal|0
decl_stmt|;
name|stopped_by_random_signal
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|stop_signal
operator|>=
name|NSIG
operator|||
name|signal_print
index|[
name|stop_signal
index|]
condition|)
block|{
name|printed
operator|=
literal|1
expr_stmt|;
name|target_terminal_ours_for_output
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|PRINT_RANDOM_SIGNAL
name|PRINT_RANDOM_SIGNAL
argument_list|(
name|stop_signal
argument_list|)
expr_stmt|;
else|#
directive|else
name|printf_filtered
argument_list|(
literal|"\nProgram received signal %d, %s\n"
argument_list|,
name|stop_signal
argument_list|,
name|safe_strsignal
argument_list|(
name|stop_signal
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* PRINT_RANDOM_SIGNAL */
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|stop_signal
operator|>=
name|NSIG
operator|||
name|signal_stop
index|[
name|stop_signal
index|]
condition|)
break|break;
comment|/* If not going to stop, give terminal back 	     if we took it away.  */
elseif|else
if|if
condition|(
name|printed
condition|)
name|target_terminal_inferior
argument_list|()
expr_stmt|;
comment|/* Note that virtually all the code below does `if !random_signal'. 	     Perhaps this code should end with a goto or continue.  At least 	     one (now fixed) bug was caused by this -- a !random_signal was 	     missing in one of the tests below.  */
block|}
comment|/* Handle cases caused by hitting a breakpoint.  */
if|if
condition|(
operator|!
name|random_signal
condition|)
if|if
condition|(
name|bpstat_explains_signal
argument_list|(
name|stop_bpstat
argument_list|)
condition|)
block|{
name|CORE_ADDR
name|jmp_buf_pc
decl_stmt|;
switch|switch
condition|(
name|stop_bpstat
operator|->
name|breakpoint_at
operator|->
name|type
condition|)
comment|/* FIXME */
block|{
comment|/* If we hit the breakpoint at longjmp, disable it for the 		   duration of this command.  Then, install a temporary 		   breakpoint at the target of the jmp_buf. */
case|case
name|bp_longjmp
case|:
name|disable_longjmp_breakpoint
argument_list|()
expr_stmt|;
name|remove_breakpoints
argument_list|()
expr_stmt|;
name|breakpoints_inserted
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|GET_LONGJMP_TARGET
argument_list|(
operator|&
name|jmp_buf_pc
argument_list|)
condition|)
goto|goto
name|keep_going
goto|;
comment|/* Need to blow away step-resume breakpoint, as it 		   interferes with us */
name|remove_step_breakpoint
argument_list|()
expr_stmt|;
name|step_resume_break_address
operator|=
literal|0
expr_stmt|;
name|stop_step_resume_break
operator|=
literal|0
expr_stmt|;
if|#
directive|if
literal|0
comment|/* FIXME - Need to implement nested temporary breakpoints */
block|if (step_over_calls> 0) 		  set_longjmp_resume_breakpoint(jmp_buf_pc, 						get_current_frame()); 		else
endif|#
directive|endif
comment|/* 0 */
name|set_longjmp_resume_breakpoint
argument_list|(
name|jmp_buf_pc
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|handling_longjmp
operator|=
literal|1
expr_stmt|;
comment|/* FIXME */
goto|goto
name|keep_going
goto|;
case|case
name|bp_longjmp_resume
case|:
name|remove_breakpoints
argument_list|()
expr_stmt|;
name|breakpoints_inserted
operator|=
literal|0
expr_stmt|;
if|#
directive|if
literal|0
comment|/* FIXME - Need to implement nested temporary breakpoints */
block|if (step_over_calls&& (stop_frame_address 			INNER_THAN step_frame_address)) 		  { 		    another_trap = 1; 		    goto keep_going; 		  }
endif|#
directive|endif
comment|/* 0 */
name|disable_longjmp_breakpoint
argument_list|()
expr_stmt|;
name|handling_longjmp
operator|=
literal|0
expr_stmt|;
comment|/* FIXME */
break|break;
default|default:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Unknown breakpoint type %d\n"
argument_list|,
name|stop_bpstat
operator|->
name|breakpoint_at
operator|->
name|type
argument_list|)
expr_stmt|;
case|case
name|bp_watchpoint
case|:
case|case
name|bp_breakpoint
case|:
case|case
name|bp_until
case|:
case|case
name|bp_finish
case|:
comment|/* Does a breakpoint want us to stop?  */
if|if
condition|(
name|bpstat_stop
argument_list|(
name|stop_bpstat
argument_list|)
condition|)
block|{
name|stop_print_frame
operator|=
name|bpstat_should_print
argument_list|(
name|stop_bpstat
argument_list|)
expr_stmt|;
goto|goto
name|stop_stepping
goto|;
block|}
comment|/* Otherwise, must remove breakpoints and single-step 		   to get us past the one we hit.  */
else|else
block|{
name|remove_breakpoints
argument_list|()
expr_stmt|;
name|remove_step_breakpoint
argument_list|()
expr_stmt|;
name|breakpoints_inserted
operator|=
literal|0
expr_stmt|;
name|another_trap
operator|=
literal|1
expr_stmt|;
block|}
break|break;
block|}
block|}
elseif|else
if|if
condition|(
name|stop_step_resume_break
condition|)
block|{
comment|/* But if we have hit the step-resumption breakpoint, 	       remove it.  It has done its job getting us here. 	       The sp test is to make sure that we don't get hung 	       up in recursive calls in functions without frame 	       pointers.  If the stack pointer isn't outside of 	       where the breakpoint was set (within a routine to be 	       stepped over), we're in the middle of a recursive 	       call. Not true for reg window machines (sparc) 	       because the must change frames to call things and 	       the stack pointer doesn't have to change if it 	       the bp was set in a routine without a frame (pc can 	       be stored in some other window). 	        	       The removal of the sp test is to allow calls to 	       alloca.  Nasty things were happening.  Oh, well, 	       gdb can only handle one level deep of lack of 	       frame pointer. */
comment|/* 	      Disable test for step_frame_address match so that we always stop even if the 	      frames don't match.  Reason: if we hit the step_resume_breakpoint, there is 	      no way to temporarily disable it so that we can step past it.  If we leave 	      the breakpoint in, then we loop forever repeatedly hitting, but never 	      getting past the breakpoint.  This change keeps nexting over recursive 	      function calls from hanging gdb. 	      */
if|#
directive|if
literal|0
block|if (* step_frame_address == 0 		|| (step_frame_address == stop_frame_address))
endif|#
directive|endif
block|{
name|remove_step_breakpoint
argument_list|()
expr_stmt|;
name|step_resume_break_address
operator|=
literal|0
expr_stmt|;
comment|/* If were waiting for a trap, hitting the step_resume_break 		   doesn't count as getting it.  */
if|if
condition|(
name|trap_expected
condition|)
name|another_trap
operator|=
literal|1
expr_stmt|;
block|}
block|}
comment|/* We come here if we hit a breakpoint but should not 	 stop for it.  Possibly we also were stepping 	 and should stop for that.  So fall through and 	 test for stepping.  But, if not stepping, 	 do not stop.  */
comment|/* If this is the breakpoint at the end of a stack dummy, 	 just stop silently.  */
if|if
condition|(
operator|!
name|random_signal
operator|&&
name|PC_IN_CALL_DUMMY
argument_list|(
name|stop_pc
argument_list|,
name|stop_sp
argument_list|,
name|stop_frame_address
argument_list|)
condition|)
block|{
name|stop_print_frame
operator|=
literal|0
expr_stmt|;
name|stop_stack_dummy
operator|=
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|HP_OS_BUG
name|trap_expected_after_continue
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
break|break;
block|}
if|if
condition|(
name|step_resume_break_address
condition|)
comment|/* Having a step-resume breakpoint overrides anything 	   else having to do with stepping commands until 	   that breakpoint is reached.  */
empty_stmt|;
comment|/* If stepping through a line, keep going if still within it.  */
elseif|else
if|if
condition|(
operator|!
name|random_signal
operator|&&
name|step_range_end
operator|&&
name|stop_pc
operator|>=
name|step_range_start
operator|&&
name|stop_pc
operator|<
name|step_range_end
comment|/* The step range might include the start of the 		  function, so if we are at the start of the 		  step range and either the stack or frame pointers 		  just changed, we've stepped outside */
operator|&&
operator|!
operator|(
name|stop_pc
operator|==
name|step_range_start
operator|&&
name|stop_frame_address
operator|&&
operator|(
name|stop_sp
name|INNER_THAN
name|prev_sp
operator|||
name|stop_frame_address
operator|!=
name|step_frame_address
operator|)
operator|)
condition|)
block|{
empty_stmt|;
block|}
comment|/* We stepped out of the stepping range.  See if that was due 	 to a subroutine call that we should proceed to the end of.  */
elseif|else
if|if
condition|(
operator|!
name|random_signal
operator|&&
name|step_range_end
condition|)
block|{
if|if
condition|(
name|stop_func_start
condition|)
block|{
name|prologue_pc
operator|=
name|stop_func_start
expr_stmt|;
name|SKIP_PROLOGUE
argument_list|(
name|prologue_pc
argument_list|)
expr_stmt|;
block|}
comment|/* Did we just take a signal?  */
if|if
condition|(
name|IN_SIGTRAMP
argument_list|(
name|stop_pc
argument_list|,
name|stop_func_name
argument_list|)
operator|&&
operator|!
name|IN_SIGTRAMP
argument_list|(
name|prev_pc
argument_list|,
name|prev_func_name
argument_list|)
condition|)
block|{
comment|/* This code is needed at least in the following case: 		 The user types "next" and then a signal arrives (before 		 the "next" is done).  */
comment|/* We've just taken a signal; go until we are back to 		 the point where we took it and one more.  */
name|step_resume_break_address
operator|=
name|prev_pc
expr_stmt|;
name|step_resume_break_duplicate
operator|=
name|breakpoint_here_p
argument_list|(
name|step_resume_break_address
argument_list|)
expr_stmt|;
if|if
condition|(
name|breakpoints_inserted
condition|)
name|insert_step_breakpoint
argument_list|()
expr_stmt|;
comment|/* Make sure that the stepping range gets us past 		 that instruction.  */
if|if
condition|(
name|step_range_end
operator|==
literal|1
condition|)
name|step_range_end
operator|=
operator|(
name|step_range_start
operator|=
name|prev_pc
operator|)
operator|+
literal|1
expr_stmt|;
name|remove_breakpoints_on_following_step
operator|=
literal|1
expr_stmt|;
goto|goto
name|save_pc
goto|;
block|}
comment|/* ==> See comments at top of file on this algorithm.<==*/
if|if
condition|(
operator|(
name|stop_pc
operator|==
name|stop_func_start
operator|||
name|IN_SOLIB_TRAMPOLINE
argument_list|(
name|stop_pc
argument_list|,
name|stop_func_name
argument_list|)
operator|)
operator|&&
operator|(
name|stop_func_start
operator|!=
name|prev_func_start
operator|||
name|prologue_pc
operator|!=
name|stop_func_start
operator|||
name|stop_sp
operator|!=
name|prev_sp
operator|)
condition|)
block|{
comment|/* It's a subroutine call. 		 (0)  If we are not stepping over any calls ("stepi"), we 		      just stop. 		 (1)  If we're doing a "next", we want to continue through 		      the call ("step over the call"). 		 (2)  If we are in a function-call trampoline (a stub between 		      the calling routine and the real function), locate 		      the real function and change stop_func_start. 		 (3)  If we're doing a "step", and there are no debug symbols 		      at the target of the call, we want to continue through 		      it ("step over the call"). 		 (4)  Otherwise, we want to stop soon, after the function 		      prologue ("step into the call"). */
if|if
condition|(
name|step_over_calls
operator|==
literal|0
condition|)
block|{
comment|/* I presume that step_over_calls is only 0 when we're 		     supposed to be stepping at the assembly language level. */
name|stop_step
operator|=
literal|1
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|step_over_calls
operator|>
literal|0
condition|)
goto|goto
name|step_over_function
goto|;
name|tmp
operator|=
name|SKIP_TRAMPOLINE_CODE
argument_list|(
name|stop_pc
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|!=
literal|0
condition|)
name|stop_func_start
operator|=
name|tmp
expr_stmt|;
if|if
condition|(
name|find_pc_function
argument_list|(
name|stop_func_start
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|step_into_function
goto|;
name|step_over_function
label|:
comment|/* A subroutine call has happened.  */
comment|/* Set a special breakpoint after the return */
name|step_resume_break_address
operator|=
name|ADDR_BITS_REMOVE
argument_list|(
name|SAVED_PC_AFTER_CALL
argument_list|(
name|get_current_frame
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|step_resume_break_duplicate
operator|=
name|breakpoint_here_p
argument_list|(
name|step_resume_break_address
argument_list|)
expr_stmt|;
if|if
condition|(
name|breakpoints_inserted
condition|)
name|insert_step_breakpoint
argument_list|()
expr_stmt|;
goto|goto
name|save_pc
goto|;
name|step_into_function
label|:
comment|/* Subroutine call with source code we should not step over. 		 Do step to the first line of code in it.  */
name|SKIP_PROLOGUE
argument_list|(
name|stop_func_start
argument_list|)
expr_stmt|;
name|sal
operator|=
name|find_pc_line
argument_list|(
name|stop_func_start
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Use the step_resume_break to step until 		 the end of the prologue, even if that involves jumps 		 (as it seems to on the vax under 4.2).  */
comment|/* If the prologue ends in the middle of a source line, 		 continue to the end of that source line. 		 Otherwise, just go to end of prologue.  */
ifdef|#
directive|ifdef
name|PROLOGUE_FIRSTLINE_OVERLAP
comment|/* no, don't either.  It skips any code that's 		 legitimately on the first line.  */
else|#
directive|else
if|if
condition|(
name|sal
operator|.
name|end
operator|&&
name|sal
operator|.
name|pc
operator|!=
name|stop_func_start
condition|)
name|stop_func_start
operator|=
name|sal
operator|.
name|end
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|stop_func_start
operator|==
name|stop_pc
condition|)
block|{
comment|/* We are already there: stop now.  */
name|stop_step
operator|=
literal|1
expr_stmt|;
break|break;
block|}
else|else
comment|/* Put the step-breakpoint there and go until there. */
block|{
name|step_resume_break_address
operator|=
name|stop_func_start
expr_stmt|;
name|step_resume_break_duplicate
operator|=
name|breakpoint_here_p
argument_list|(
name|step_resume_break_address
argument_list|)
expr_stmt|;
if|if
condition|(
name|breakpoints_inserted
condition|)
name|insert_step_breakpoint
argument_list|()
expr_stmt|;
comment|/* Do not specify what the fp should be when we stop 		     since on some machines the prologue 		     is where the new fp value is established.  */
name|step_frame_address
operator|=
literal|0
expr_stmt|;
comment|/* And make sure stepping stops right away then.  */
name|step_range_end
operator|=
name|step_range_start
expr_stmt|;
block|}
goto|goto
name|save_pc
goto|;
block|}
comment|/* We've wandered out of the step range (but haven't done a 	     subroutine call or return).  */
name|sal
operator|=
name|find_pc_line
argument_list|(
name|stop_pc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|step_range_end
operator|==
literal|1
operator|||
comment|/* stepi or nexti */
name|sal
operator|.
name|line
operator|==
literal|0
operator|||
comment|/* ...or no line # info */
operator|(
name|stop_pc
operator|==
name|sal
operator|.
name|pc
comment|/* ...or we're at the start */
operator|&&
name|current_line
operator|!=
name|sal
operator|.
name|line
operator|)
condition|)
block|{
comment|/* of a different line */
comment|/* Stop because we're done stepping.  */
name|stop_step
operator|=
literal|1
expr_stmt|;
break|break;
block|}
else|else
block|{
comment|/* We aren't done stepping, and we have line number info for $pc. 	       Optimize by setting the step_range for the line.   	       (We might not be in the original line, but if we entered a 	       new line in mid-statement, we continue stepping.  This makes  	       things like for(;;) statements work better.)  */
name|step_range_start
operator|=
name|sal
operator|.
name|pc
expr_stmt|;
name|step_range_end
operator|=
name|sal
operator|.
name|end
expr_stmt|;
goto|goto
name|save_pc
goto|;
block|}
comment|/* We never fall through here */
block|}
if|if
condition|(
name|trap_expected
operator|&&
name|IN_SIGTRAMP
argument_list|(
name|stop_pc
argument_list|,
name|stop_func_name
argument_list|)
operator|&&
operator|!
name|IN_SIGTRAMP
argument_list|(
name|prev_pc
argument_list|,
name|prev_func_name
argument_list|)
condition|)
block|{
comment|/* What has happened here is that we have just stepped the inferior 	     with a signal (because it is a signal which shouldn't make 	     us stop), thus stepping into sigtramp.  	     So we need to set a step_resume_break_address breakpoint 	     and continue until we hit it, and then step.  */
name|step_resume_break_address
operator|=
name|prev_pc
expr_stmt|;
comment|/* Always 1, I think, but it's probably easier to have 	     the step_resume_break as usual rather than trying to 	     re-use the breakpoint which is already there.  */
name|step_resume_break_duplicate
operator|=
name|breakpoint_here_p
argument_list|(
name|step_resume_break_address
argument_list|)
expr_stmt|;
if|if
condition|(
name|breakpoints_inserted
condition|)
name|insert_step_breakpoint
argument_list|()
expr_stmt|;
name|remove_breakpoints_on_following_step
operator|=
literal|1
expr_stmt|;
name|another_trap
operator|=
literal|1
expr_stmt|;
block|}
comment|/* My apologies to the gods of structured programming. */
comment|/* Come to this label when you need to resume the inferior.  It's really much    cleaner at this time to do a goto than to try and figure out what the    if-else chain ought to look like!! */
name|keep_going
label|:
name|save_pc
label|:
comment|/* Save the pc before execution, to compare with pc after stop.  */
name|prev_pc
operator|=
name|read_pc
argument_list|()
expr_stmt|;
comment|/* Might have been DECR_AFTER_BREAK */
name|prev_func_start
operator|=
name|stop_func_start
expr_stmt|;
comment|/* Ok, since if DECR_PC_AFTER 					  BREAK is defined, the 					  original pc would not have 					  been at the start of a 					  function. */
name|prev_func_name
operator|=
name|stop_func_name
expr_stmt|;
name|prev_sp
operator|=
name|stop_sp
expr_stmt|;
comment|/* If we did not do break;, it means we should keep 	 running the inferior and not return to debugger.  */
if|if
condition|(
name|trap_expected
operator|&&
name|stop_signal
operator|!=
name|SIGTRAP
condition|)
block|{
comment|/* We took a signal (which we are supposed to pass through to 	     the inferior, else we'd have done a break above) and we 	     haven't yet gotten our trap.  Simply continue.  */
name|resume
argument_list|(
operator|(
name|step_range_end
operator|&&
operator|!
name|step_resume_break_address
operator|)
operator|||
operator|(
name|trap_expected
operator|&&
operator|!
name|step_resume_break_address
operator|)
operator|||
name|bpstat_should_step
argument_list|()
argument_list|,
name|stop_signal
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Either the trap was not expected, but we are continuing 	     anyway (the user asked that this signal be passed to the 	     child) 	       -- or -- 	     The signal was SIGTRAP, e.g. it was our signal, but we 	     decided we should resume from it.  	     We're going to run this baby now!  	     Insert breakpoints now, unless we are trying 	     to one-proceed past a breakpoint.  */
comment|/* If we've just finished a special step resume and we don't 	     want to hit a breakpoint, pull em out.  */
if|if
condition|(
operator|!
name|step_resume_break_address
operator|&&
name|remove_breakpoints_on_following_step
condition|)
block|{
name|remove_breakpoints_on_following_step
operator|=
literal|0
expr_stmt|;
name|remove_breakpoints
argument_list|()
expr_stmt|;
name|breakpoints_inserted
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|breakpoints_inserted
operator|&&
operator|(
name|step_resume_break_address
operator|!=
literal|0
operator|||
operator|!
name|another_trap
operator|)
condition|)
block|{
name|insert_step_breakpoint
argument_list|()
expr_stmt|;
name|breakpoints_failed
operator|=
name|insert_breakpoints
argument_list|()
expr_stmt|;
if|if
condition|(
name|breakpoints_failed
condition|)
break|break;
name|breakpoints_inserted
operator|=
literal|1
expr_stmt|;
block|}
name|trap_expected
operator|=
name|another_trap
expr_stmt|;
if|if
condition|(
name|stop_signal
operator|==
name|SIGTRAP
condition|)
name|stop_signal
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|SHIFT_INST_REGS
comment|/* I'm not sure when this following segment applies.  I do know, now, 	     that we shouldn't rewrite the regs when we were stopped by a 	     random signal from the inferior process.  */
if|if
condition|(
operator|!
name|bpstat_explains_signal
argument_list|(
name|stop_bpstat
argument_list|)
operator|&&
operator|(
name|stop_signal
operator|!=
name|SIGCLD
operator|)
operator|&&
operator|!
name|stopped_by_random_signal
condition|)
block|{
name|CORE_ADDR
name|pc_contents
init|=
name|read_register
argument_list|(
name|PC_REGNUM
argument_list|)
decl_stmt|;
name|CORE_ADDR
name|npc_contents
init|=
name|read_register
argument_list|(
name|NPC_REGNUM
argument_list|)
decl_stmt|;
if|if
condition|(
name|pc_contents
operator|!=
name|npc_contents
condition|)
block|{
name|write_register
argument_list|(
name|NNPC_REGNUM
argument_list|,
name|npc_contents
argument_list|)
expr_stmt|;
name|write_register
argument_list|(
name|NPC_REGNUM
argument_list|,
name|pc_contents
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* SHIFT_INST_REGS */
name|resume
argument_list|(
operator|(
operator|!
name|step_resume_break_address
operator|&&
operator|!
name|handling_longjmp
operator|&&
operator|(
name|step_range_end
operator|||
name|trap_expected
operator|)
operator|)
operator|||
name|bpstat_should_step
argument_list|()
argument_list|,
name|stop_signal
argument_list|)
expr_stmt|;
block|}
block|}
name|stop_stepping
label|:
if|if
condition|(
name|target_has_execution
condition|)
block|{
comment|/* Assuming the inferior still exists, set these up for next 	 time, just like we did above if we didn't break out of the 	 loop.  */
name|prev_pc
operator|=
name|read_pc
argument_list|()
expr_stmt|;
name|prev_func_start
operator|=
name|stop_func_start
expr_stmt|;
name|prev_func_name
operator|=
name|stop_func_name
expr_stmt|;
name|prev_sp
operator|=
name|stop_sp
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Here to return control to GDB when the inferior stops for real.    Print appropriate messages, remove breakpoints, give terminal our modes.     STOP_PRINT_FRAME nonzero means print the executing frame    (pc, function, args, file, line number and line text).    BREAKPOINTS_FAILED nonzero means stop was due to error    attempting to insert breakpoints.  */
end_comment

begin_function
name|void
name|normal_stop
parameter_list|()
block|{
name|char
modifier|*
name|tem
decl_stmt|;
name|struct
name|cmd_list_element
modifier|*
name|c
decl_stmt|;
comment|/* Make sure that the current_frame's pc is correct.  This      is a correction for setting up the frame info before doing      DECR_PC_AFTER_BREAK */
if|if
condition|(
name|target_has_execution
condition|)
operator|(
name|get_current_frame
argument_list|()
operator|)
operator|->
name|pc
operator|=
name|read_pc
argument_list|()
expr_stmt|;
if|if
condition|(
name|breakpoints_failed
condition|)
block|{
name|target_terminal_ours_for_output
argument_list|()
expr_stmt|;
name|print_sys_errmsg
argument_list|(
literal|"ptrace"
argument_list|,
name|breakpoints_failed
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"Stopped; cannot insert breakpoints.\n\ The same program may be running in another process.\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|target_has_execution
condition|)
name|remove_step_breakpoint
argument_list|()
expr_stmt|;
if|if
condition|(
name|target_has_execution
operator|&&
name|breakpoints_inserted
condition|)
if|if
condition|(
name|remove_breakpoints
argument_list|()
condition|)
block|{
name|target_terminal_ours_for_output
argument_list|()
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"Cannot remove breakpoints because program is no longer writable.\n\ It might be running in another process.\n\ Further execution is probably impossible.\n"
argument_list|)
expr_stmt|;
block|}
name|breakpoints_inserted
operator|=
literal|0
expr_stmt|;
comment|/* Delete the breakpoint we stopped at, if it wants to be deleted.      Delete any breakpoint that is to be deleted at the next stop.  */
name|breakpoint_auto_delete
argument_list|(
name|stop_bpstat
argument_list|)
expr_stmt|;
comment|/* If an auto-display called a function and that got a signal,      delete that auto-display to avoid an infinite recursion.  */
if|if
condition|(
name|stopped_by_random_signal
condition|)
name|disable_current_display
argument_list|()
expr_stmt|;
if|if
condition|(
name|step_multi
operator|&&
name|stop_step
condition|)
return|return;
name|target_terminal_ours
argument_list|()
expr_stmt|;
comment|/* Look up the hook_stop and run it if it exists.  */
if|if
condition|(
name|stop_command
operator|->
name|hook
condition|)
block|{
name|catch_errors
argument_list|(
name|hook_stop_stub
argument_list|,
operator|(
name|char
operator|*
operator|)
name|stop_command
operator|->
name|hook
argument_list|,
literal|"Error while running hook_stop:\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|target_has_stack
condition|)
return|return;
comment|/* Select innermost stack frame except on return from a stack dummy routine,      or if the program has exited.  Print it without a level number if      we have changed functions or hit a breakpoint.  Print source line      if we have one.  */
if|if
condition|(
operator|!
name|stop_stack_dummy
condition|)
block|{
name|select_frame
argument_list|(
name|get_current_frame
argument_list|()
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|stop_print_frame
condition|)
block|{
name|int
name|source_only
decl_stmt|;
name|source_only
operator|=
name|bpstat_print
argument_list|(
name|stop_bpstat
argument_list|)
expr_stmt|;
name|source_only
operator|=
name|source_only
operator|||
operator|(
name|stop_step
operator|&&
name|step_frame_address
operator|==
name|stop_frame_address
operator|&&
name|step_start_function
operator|==
name|find_pc_function
argument_list|(
name|stop_pc
argument_list|)
operator|)
expr_stmt|;
name|print_stack_frame
argument_list|(
name|selected_frame
argument_list|,
operator|-
literal|1
argument_list|,
name|source_only
condition|?
operator|-
literal|1
else|:
literal|1
argument_list|)
expr_stmt|;
comment|/* Display the auto-display expressions.  */
name|do_displays
argument_list|()
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Pop the empty frame that contains the stack dummy.          POP_FRAME ends with a setting of the current frame, so we 	 can use that next. */
ifndef|#
directive|ifndef
name|NEW_CALL_FUNCTION
name|POP_FRAME
expr_stmt|;
endif|#
directive|endif
name|select_frame
argument_list|(
name|get_current_frame
argument_list|()
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|hook_stop_stub
parameter_list|(
name|cmd
parameter_list|)
name|char
modifier|*
name|cmd
decl_stmt|;
block|{
name|execute_user_command
argument_list|(
operator|(
expr|struct
name|cmd_list_element
operator|*
operator|)
name|cmd
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|void
name|insert_step_breakpoint
parameter_list|()
block|{
if|if
condition|(
name|step_resume_break_address
operator|&&
operator|!
name|step_resume_break_duplicate
condition|)
name|target_insert_breakpoint
argument_list|(
name|step_resume_break_address
argument_list|,
name|step_resume_break_shadow
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|remove_step_breakpoint
parameter_list|()
block|{
if|if
condition|(
name|step_resume_break_address
operator|&&
operator|!
name|step_resume_break_duplicate
condition|)
name|target_remove_breakpoint
argument_list|(
name|step_resume_break_address
argument_list|,
name|step_resume_break_shadow
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function
name|int
name|signal_stop_state
parameter_list|(
name|signo
parameter_list|)
name|int
name|signo
decl_stmt|;
block|{
return|return
operator|(
operator|(
name|signo
operator|>=
literal|0
operator|&&
name|signo
operator|<
name|NSIG
operator|)
condition|?
name|signal_stop
index|[
name|signo
index|]
else|:
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|signal_print_state
parameter_list|(
name|signo
parameter_list|)
name|int
name|signo
decl_stmt|;
block|{
return|return
operator|(
operator|(
name|signo
operator|>=
literal|0
operator|&&
name|signo
operator|<
name|NSIG
operator|)
condition|?
name|signal_print
index|[
name|signo
index|]
else|:
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|signal_pass_state
parameter_list|(
name|signo
parameter_list|)
name|int
name|signo
decl_stmt|;
block|{
return|return
operator|(
operator|(
name|signo
operator|>=
literal|0
operator|&&
name|signo
operator|<
name|NSIG
operator|)
condition|?
name|signal_program
index|[
name|signo
index|]
else|:
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|sig_print_header
parameter_list|()
block|{
name|printf_filtered
argument_list|(
literal|"Signal\t\tStop\tPrint\tPass to program\tDescription\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|sig_print_info
parameter_list|(
name|number
parameter_list|)
name|int
name|number
decl_stmt|;
block|{
name|char
modifier|*
name|name
decl_stmt|;
if|if
condition|(
operator|(
name|name
operator|=
name|strsigno
argument_list|(
name|number
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|printf_filtered
argument_list|(
literal|"%d\t\t"
argument_list|,
name|number
argument_list|)
expr_stmt|;
else|else
name|printf_filtered
argument_list|(
literal|"%s (%d)\t"
argument_list|,
name|name
argument_list|,
name|number
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"%s\t"
argument_list|,
name|signal_stop
index|[
name|number
index|]
condition|?
literal|"Yes"
else|:
literal|"No"
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"%s\t"
argument_list|,
name|signal_print
index|[
name|number
index|]
condition|?
literal|"Yes"
else|:
literal|"No"
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"%s\t\t"
argument_list|,
name|signal_program
index|[
name|number
index|]
condition|?
literal|"Yes"
else|:
literal|"No"
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"%s\n"
argument_list|,
name|safe_strsignal
argument_list|(
name|number
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Specify how various signals in the inferior should be handled.  */
end_comment

begin_function
specifier|static
name|void
name|handle_command
parameter_list|(
name|args
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
name|int
name|digits
decl_stmt|,
name|wordlen
decl_stmt|;
name|int
name|sigfirst
decl_stmt|,
name|signum
decl_stmt|,
name|siglast
decl_stmt|;
name|int
name|allsigs
decl_stmt|;
name|int
name|nsigs
decl_stmt|;
name|unsigned
name|char
modifier|*
name|sigs
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|old_chain
decl_stmt|;
if|if
condition|(
name|args
operator|==
name|NULL
condition|)
block|{
name|error_no_arg
argument_list|(
literal|"signal to handle"
argument_list|)
expr_stmt|;
block|}
comment|/* Allocate and zero an array of flags for which signals to handle. */
name|nsigs
operator|=
name|signo_max
argument_list|()
operator|+
literal|1
expr_stmt|;
name|sigs
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|nsigs
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|sigs
argument_list|,
literal|0
argument_list|,
name|nsigs
argument_list|)
expr_stmt|;
comment|/* Break the command line up into args. */
name|argv
operator|=
name|buildargv
argument_list|(
name|args
argument_list|)
expr_stmt|;
if|if
condition|(
name|argv
operator|==
name|NULL
condition|)
block|{
name|nomem
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
name|old_chain
operator|=
name|make_cleanup
argument_list|(
name|freeargv
argument_list|,
operator|(
name|char
operator|*
operator|)
name|argv
argument_list|)
expr_stmt|;
comment|/* Walk through the args, looking for signal numbers, signal names, and      actions.  Signal numbers and signal names may be interspersed with      actions, with the actions being performed for all signals cumulatively      specified.  Signal ranges can be specified as<LOW>-<HIGH>. */
while|while
condition|(
operator|*
name|argv
operator|!=
name|NULL
condition|)
block|{
name|wordlen
operator|=
name|strlen
argument_list|(
operator|*
name|argv
argument_list|)
expr_stmt|;
for|for
control|(
name|digits
operator|=
literal|0
init|;
name|isdigit
argument_list|(
operator|(
operator|*
name|argv
operator|)
index|[
name|digits
index|]
argument_list|)
condition|;
name|digits
operator|++
control|)
block|{
empty_stmt|;
block|}
name|allsigs
operator|=
literal|0
expr_stmt|;
name|sigfirst
operator|=
name|siglast
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|wordlen
operator|>=
literal|1
operator|&&
operator|!
name|strncmp
argument_list|(
operator|*
name|argv
argument_list|,
literal|"all"
argument_list|,
name|wordlen
argument_list|)
condition|)
block|{
comment|/* Apply action to all signals except those used by the 	     debugger.  Silently skip those. */
name|allsigs
operator|=
literal|1
expr_stmt|;
name|sigfirst
operator|=
literal|0
expr_stmt|;
name|siglast
operator|=
name|nsigs
operator|-
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|wordlen
operator|>=
literal|1
operator|&&
operator|!
name|strncmp
argument_list|(
operator|*
name|argv
argument_list|,
literal|"stop"
argument_list|,
name|wordlen
argument_list|)
condition|)
block|{
name|SET_SIGS
argument_list|(
name|nsigs
argument_list|,
name|sigs
argument_list|,
name|signal_stop
argument_list|)
expr_stmt|;
name|SET_SIGS
argument_list|(
name|nsigs
argument_list|,
name|sigs
argument_list|,
name|signal_print
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|wordlen
operator|>=
literal|1
operator|&&
operator|!
name|strncmp
argument_list|(
operator|*
name|argv
argument_list|,
literal|"ignore"
argument_list|,
name|wordlen
argument_list|)
condition|)
block|{
name|UNSET_SIGS
argument_list|(
name|nsigs
argument_list|,
name|sigs
argument_list|,
name|signal_program
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|wordlen
operator|>=
literal|2
operator|&&
operator|!
name|strncmp
argument_list|(
operator|*
name|argv
argument_list|,
literal|"print"
argument_list|,
name|wordlen
argument_list|)
condition|)
block|{
name|SET_SIGS
argument_list|(
name|nsigs
argument_list|,
name|sigs
argument_list|,
name|signal_print
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|wordlen
operator|>=
literal|2
operator|&&
operator|!
name|strncmp
argument_list|(
operator|*
name|argv
argument_list|,
literal|"pass"
argument_list|,
name|wordlen
argument_list|)
condition|)
block|{
name|SET_SIGS
argument_list|(
name|nsigs
argument_list|,
name|sigs
argument_list|,
name|signal_program
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|wordlen
operator|>=
literal|3
operator|&&
operator|!
name|strncmp
argument_list|(
operator|*
name|argv
argument_list|,
literal|"nostop"
argument_list|,
name|wordlen
argument_list|)
condition|)
block|{
name|UNSET_SIGS
argument_list|(
name|nsigs
argument_list|,
name|sigs
argument_list|,
name|signal_stop
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|wordlen
operator|>=
literal|3
operator|&&
operator|!
name|strncmp
argument_list|(
operator|*
name|argv
argument_list|,
literal|"noignore"
argument_list|,
name|wordlen
argument_list|)
condition|)
block|{
name|SET_SIGS
argument_list|(
name|nsigs
argument_list|,
name|sigs
argument_list|,
name|signal_program
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|wordlen
operator|>=
literal|4
operator|&&
operator|!
name|strncmp
argument_list|(
operator|*
name|argv
argument_list|,
literal|"noprint"
argument_list|,
name|wordlen
argument_list|)
condition|)
block|{
name|UNSET_SIGS
argument_list|(
name|nsigs
argument_list|,
name|sigs
argument_list|,
name|signal_print
argument_list|)
expr_stmt|;
name|UNSET_SIGS
argument_list|(
name|nsigs
argument_list|,
name|sigs
argument_list|,
name|signal_stop
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|wordlen
operator|>=
literal|4
operator|&&
operator|!
name|strncmp
argument_list|(
operator|*
name|argv
argument_list|,
literal|"nopass"
argument_list|,
name|wordlen
argument_list|)
condition|)
block|{
name|UNSET_SIGS
argument_list|(
name|nsigs
argument_list|,
name|sigs
argument_list|,
name|signal_program
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|digits
operator|>
literal|0
condition|)
block|{
name|sigfirst
operator|=
name|siglast
operator|=
name|atoi
argument_list|(
operator|*
name|argv
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|argv
operator|)
index|[
name|digits
index|]
operator|==
literal|'-'
condition|)
block|{
name|siglast
operator|=
name|atoi
argument_list|(
operator|(
operator|*
name|argv
operator|)
operator|+
name|digits
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sigfirst
operator|>
name|siglast
condition|)
block|{
comment|/* Bet he didn't figure we'd think of this case... */
name|signum
operator|=
name|sigfirst
expr_stmt|;
name|sigfirst
operator|=
name|siglast
expr_stmt|;
name|siglast
operator|=
name|signum
expr_stmt|;
block|}
if|if
condition|(
name|sigfirst
operator|<
literal|0
operator|||
name|sigfirst
operator|>=
name|nsigs
condition|)
block|{
name|error
argument_list|(
literal|"Signal %d not in range 0-%d"
argument_list|,
name|sigfirst
argument_list|,
name|nsigs
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|siglast
operator|<
literal|0
operator|||
name|siglast
operator|>=
name|nsigs
condition|)
block|{
name|error
argument_list|(
literal|"Signal %d not in range 0-%d"
argument_list|,
name|siglast
argument_list|,
name|nsigs
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|signum
operator|=
name|strtosigno
argument_list|(
operator|*
name|argv
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|sigfirst
operator|=
name|siglast
operator|=
name|signum
expr_stmt|;
block|}
else|else
block|{
comment|/* Not a number and not a recognized flag word => complain.  */
name|error
argument_list|(
literal|"Unrecognized or ambiguous flag word: \"%s\"."
argument_list|,
operator|*
name|argv
argument_list|)
expr_stmt|;
block|}
comment|/* If any signal numbers or symbol names were found, set flags for 	 which signals to apply actions to. */
for|for
control|(
name|signum
operator|=
name|sigfirst
init|;
name|signum
operator|>=
literal|0
operator|&&
name|signum
operator|<=
name|siglast
condition|;
name|signum
operator|++
control|)
block|{
switch|switch
condition|(
name|signum
condition|)
block|{
case|case
name|SIGTRAP
case|:
case|case
name|SIGINT
case|:
if|if
condition|(
operator|!
name|allsigs
operator|&&
operator|!
name|sigs
index|[
name|signum
index|]
condition|)
block|{
if|if
condition|(
name|query
argument_list|(
literal|"%s is used by the debugger.\nAre you sure you want to change it? "
argument_list|,
name|strsigno
argument_list|(
name|signum
argument_list|)
argument_list|)
condition|)
block|{
name|sigs
index|[
name|signum
index|]
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"Not confirmed, unchanged.\n"
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
default|default:
name|sigs
index|[
name|signum
index|]
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
name|argv
operator|++
expr_stmt|;
block|}
name|target_notice_signals
argument_list|()
expr_stmt|;
if|if
condition|(
name|from_tty
condition|)
block|{
comment|/* Show the results.  */
name|sig_print_header
argument_list|()
expr_stmt|;
for|for
control|(
name|signum
operator|=
literal|0
init|;
name|signum
operator|<
name|nsigs
condition|;
name|signum
operator|++
control|)
block|{
if|if
condition|(
name|sigs
index|[
name|signum
index|]
condition|)
block|{
name|sig_print_info
argument_list|(
name|signum
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|do_cleanups
argument_list|(
name|old_chain
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print current contents of the tables set by the handle command.  */
end_comment

begin_function
specifier|static
name|void
name|signals_info
parameter_list|(
name|signum_exp
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|signum_exp
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|sig_print_header
argument_list|()
expr_stmt|;
if|if
condition|(
name|signum_exp
condition|)
block|{
comment|/* First see if this is a symbol name.  */
name|i
operator|=
name|strtosigno
argument_list|(
name|signum_exp
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
comment|/* Nope, maybe it's an address which evaluates to a signal 	     number.  */
name|i
operator|=
name|parse_and_eval_address
argument_list|(
name|signum_exp
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|>=
name|NSIG
operator|||
name|i
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|"Signal number out of bounds."
argument_list|)
expr_stmt|;
block|}
name|sig_print_info
argument_list|(
name|i
argument_list|)
expr_stmt|;
return|return;
block|}
name|printf_filtered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NSIG
condition|;
name|i
operator|++
control|)
block|{
name|QUIT
expr_stmt|;
name|sig_print_info
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
name|printf_filtered
argument_list|(
literal|"\nUse the \"handle\" command to change these tables.\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Save all of the information associated with the inferior<==>gdb    connection.  INF_STATUS is a pointer to a "struct inferior_status"    (defined in inferior.h).  */
end_comment

begin_function
name|void
name|save_inferior_status
parameter_list|(
name|inf_status
parameter_list|,
name|restore_stack_info
parameter_list|)
name|struct
name|inferior_status
modifier|*
name|inf_status
decl_stmt|;
name|int
name|restore_stack_info
decl_stmt|;
block|{
name|inf_status
operator|->
name|pc_changed
operator|=
name|pc_changed
expr_stmt|;
name|inf_status
operator|->
name|stop_signal
operator|=
name|stop_signal
expr_stmt|;
name|inf_status
operator|->
name|stop_pc
operator|=
name|stop_pc
expr_stmt|;
name|inf_status
operator|->
name|stop_frame_address
operator|=
name|stop_frame_address
expr_stmt|;
name|inf_status
operator|->
name|stop_step
operator|=
name|stop_step
expr_stmt|;
name|inf_status
operator|->
name|stop_stack_dummy
operator|=
name|stop_stack_dummy
expr_stmt|;
name|inf_status
operator|->
name|stopped_by_random_signal
operator|=
name|stopped_by_random_signal
expr_stmt|;
name|inf_status
operator|->
name|trap_expected
operator|=
name|trap_expected
expr_stmt|;
name|inf_status
operator|->
name|step_range_start
operator|=
name|step_range_start
expr_stmt|;
name|inf_status
operator|->
name|step_range_end
operator|=
name|step_range_end
expr_stmt|;
name|inf_status
operator|->
name|step_frame_address
operator|=
name|step_frame_address
expr_stmt|;
name|inf_status
operator|->
name|step_over_calls
operator|=
name|step_over_calls
expr_stmt|;
name|inf_status
operator|->
name|step_resume_break_address
operator|=
name|step_resume_break_address
expr_stmt|;
name|inf_status
operator|->
name|stop_after_trap
operator|=
name|stop_after_trap
expr_stmt|;
name|inf_status
operator|->
name|stop_soon_quietly
operator|=
name|stop_soon_quietly
expr_stmt|;
comment|/* Save original bpstat chain here; replace it with copy of chain.       If caller's caller is walking the chain, they'll be happier if we      hand them back the original chain when restore_i_s is called.  */
name|inf_status
operator|->
name|stop_bpstat
operator|=
name|stop_bpstat
expr_stmt|;
name|stop_bpstat
operator|=
name|bpstat_copy
argument_list|(
name|stop_bpstat
argument_list|)
expr_stmt|;
name|inf_status
operator|->
name|breakpoint_proceeded
operator|=
name|breakpoint_proceeded
expr_stmt|;
name|inf_status
operator|->
name|restore_stack_info
operator|=
name|restore_stack_info
expr_stmt|;
name|read_register_bytes
argument_list|(
literal|0
argument_list|,
name|inf_status
operator|->
name|register_context
argument_list|,
name|REGISTER_BYTES
argument_list|)
expr_stmt|;
name|record_selected_frame
argument_list|(
operator|&
operator|(
name|inf_status
operator|->
name|selected_frame_address
operator|)
argument_list|,
operator|&
operator|(
name|inf_status
operator|->
name|selected_level
operator|)
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
name|void
name|restore_inferior_status
parameter_list|(
name|inf_status
parameter_list|)
name|struct
name|inferior_status
modifier|*
name|inf_status
decl_stmt|;
block|{
name|FRAME
name|fid
decl_stmt|;
name|int
name|level
init|=
name|inf_status
operator|->
name|selected_level
decl_stmt|;
name|pc_changed
operator|=
name|inf_status
operator|->
name|pc_changed
expr_stmt|;
name|stop_signal
operator|=
name|inf_status
operator|->
name|stop_signal
expr_stmt|;
name|stop_pc
operator|=
name|inf_status
operator|->
name|stop_pc
expr_stmt|;
name|stop_frame_address
operator|=
name|inf_status
operator|->
name|stop_frame_address
expr_stmt|;
name|stop_step
operator|=
name|inf_status
operator|->
name|stop_step
expr_stmt|;
name|stop_stack_dummy
operator|=
name|inf_status
operator|->
name|stop_stack_dummy
expr_stmt|;
name|stopped_by_random_signal
operator|=
name|inf_status
operator|->
name|stopped_by_random_signal
expr_stmt|;
name|trap_expected
operator|=
name|inf_status
operator|->
name|trap_expected
expr_stmt|;
name|step_range_start
operator|=
name|inf_status
operator|->
name|step_range_start
expr_stmt|;
name|step_range_end
operator|=
name|inf_status
operator|->
name|step_range_end
expr_stmt|;
name|step_frame_address
operator|=
name|inf_status
operator|->
name|step_frame_address
expr_stmt|;
name|step_over_calls
operator|=
name|inf_status
operator|->
name|step_over_calls
expr_stmt|;
name|step_resume_break_address
operator|=
name|inf_status
operator|->
name|step_resume_break_address
expr_stmt|;
name|stop_after_trap
operator|=
name|inf_status
operator|->
name|stop_after_trap
expr_stmt|;
name|stop_soon_quietly
operator|=
name|inf_status
operator|->
name|stop_soon_quietly
expr_stmt|;
name|bpstat_clear
argument_list|(
operator|&
name|stop_bpstat
argument_list|)
expr_stmt|;
name|stop_bpstat
operator|=
name|inf_status
operator|->
name|stop_bpstat
expr_stmt|;
name|breakpoint_proceeded
operator|=
name|inf_status
operator|->
name|breakpoint_proceeded
expr_stmt|;
name|write_register_bytes
argument_list|(
literal|0
argument_list|,
name|inf_status
operator|->
name|register_context
argument_list|,
name|REGISTER_BYTES
argument_list|)
expr_stmt|;
comment|/* The inferior can be gone if the user types "print exit(0)"      (and perhaps other times).  */
if|if
condition|(
name|target_has_stack
operator|&&
name|inf_status
operator|->
name|restore_stack_info
condition|)
block|{
name|fid
operator|=
name|find_relative_frame
argument_list|(
name|get_current_frame
argument_list|()
argument_list|,
operator|&
name|level
argument_list|)
expr_stmt|;
comment|/* If inf_status->selected_frame_address is NULL, there was no 	 previously selected frame.  */
if|if
condition|(
name|fid
operator|==
literal|0
operator|||
name|FRAME_FP
argument_list|(
name|fid
argument_list|)
operator|!=
name|inf_status
operator|->
name|selected_frame_address
operator|||
name|level
operator|!=
literal|0
condition|)
block|{
if|#
directive|if
literal|1
comment|/* I'm not sure this error message is a good idea.  I have 	     only seen it occur after "Can't continue previously 	     requested operation" (we get called from do_cleanups), in 	     which case it just adds insult to injury (one confusing 	     error message after another.  Besides which, does the 	     user really care if we can't restore the previously 	     selected frame?  */
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Unable to restore previously selected frame.\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|select_frame
argument_list|(
name|get_current_frame
argument_list|()
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
name|select_frame
argument_list|(
name|fid
argument_list|,
name|inf_status
operator|->
name|selected_level
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_function
name|void
name|_initialize_infrun
parameter_list|()
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|int
name|numsigs
decl_stmt|;
name|add_info
argument_list|(
literal|"signals"
argument_list|,
name|signals_info
argument_list|,
literal|"What debugger does when program gets various signals.\n\ Specify a signal number as argument to print info on that signal only."
argument_list|)
expr_stmt|;
name|add_info_alias
argument_list|(
literal|"handle"
argument_list|,
literal|"signals"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|add_com
argument_list|(
literal|"handle"
argument_list|,
name|class_run
argument_list|,
name|handle_command
argument_list|,
literal|"Specify how to handle a signal.\n\ Args are signal numbers and actions to apply to those signals.\n\ Signal numbers may be numeric (ex. 11) or symbolic (ex. SIGSEGV).\n\ Numeric ranges may be specified with the form LOW-HIGH (ex. 14-21).\n\ The special arg \"all\" is recognized to mean all signals except those\n\ used by the debugger, typically SIGTRAP and SIGINT.\n\ Recognized actions include \"stop\", \"nostop\", \"print\", \"noprint\",\n\ \"pass\", \"nopass\", \"ignore\", or \"noignore\".\n\ Stop means reenter debugger if this signal happens (implies print).\n\ Print means print a message if this signal happens.\n\ Pass means let program see this signal; otherwise program doesn't know.\n\ Ignore is a synonym for nopass and noignore is a synonym for pass.\n\ Pass and Stop may be combined."
argument_list|)
expr_stmt|;
name|stop_command
operator|=
name|add_cmd
argument_list|(
literal|"stop"
argument_list|,
name|class_obscure
argument_list|,
name|not_just_help_class_command
argument_list|,
literal|"There is no `stop' command, but you can set a hook on `stop'.\n\ This allows you to set a list of commands to be run each time execution\n\ of the inferior program stops."
argument_list|,
operator|&
name|cmdlist
argument_list|)
expr_stmt|;
name|numsigs
operator|=
name|signo_max
argument_list|()
operator|+
literal|1
expr_stmt|;
name|signal_stop
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|signal_stop
index|[
literal|0
index|]
argument_list|)
operator|*
name|numsigs
argument_list|)
expr_stmt|;
name|signal_print
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|signal_print
index|[
literal|0
index|]
argument_list|)
operator|*
name|numsigs
argument_list|)
expr_stmt|;
name|signal_program
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|signal_program
index|[
literal|0
index|]
argument_list|)
operator|*
name|numsigs
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numsigs
condition|;
name|i
operator|++
control|)
block|{
name|signal_stop
index|[
name|i
index|]
operator|=
literal|1
expr_stmt|;
name|signal_print
index|[
name|i
index|]
operator|=
literal|1
expr_stmt|;
name|signal_program
index|[
name|i
index|]
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Signals caused by debugger's own actions      should not be given to the program afterwards.  */
name|signal_program
index|[
name|SIGTRAP
index|]
operator|=
literal|0
expr_stmt|;
name|signal_program
index|[
name|SIGINT
index|]
operator|=
literal|0
expr_stmt|;
comment|/* Signals that are not errors should not normally enter the debugger.  */
ifdef|#
directive|ifdef
name|SIGALRM
name|signal_stop
index|[
name|SIGALRM
index|]
operator|=
literal|0
expr_stmt|;
name|signal_print
index|[
name|SIGALRM
index|]
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
comment|/* SIGALRM */
ifdef|#
directive|ifdef
name|SIGVTALRM
name|signal_stop
index|[
name|SIGVTALRM
index|]
operator|=
literal|0
expr_stmt|;
name|signal_print
index|[
name|SIGVTALRM
index|]
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
comment|/* SIGVTALRM */
ifdef|#
directive|ifdef
name|SIGPROF
name|signal_stop
index|[
name|SIGPROF
index|]
operator|=
literal|0
expr_stmt|;
name|signal_print
index|[
name|SIGPROF
index|]
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
comment|/* SIGPROF */
ifdef|#
directive|ifdef
name|SIGCHLD
name|signal_stop
index|[
name|SIGCHLD
index|]
operator|=
literal|0
expr_stmt|;
name|signal_print
index|[
name|SIGCHLD
index|]
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
comment|/* SIGCHLD */
ifdef|#
directive|ifdef
name|SIGCLD
name|signal_stop
index|[
name|SIGCLD
index|]
operator|=
literal|0
expr_stmt|;
name|signal_print
index|[
name|SIGCLD
index|]
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
comment|/* SIGCLD */
ifdef|#
directive|ifdef
name|SIGIO
name|signal_stop
index|[
name|SIGIO
index|]
operator|=
literal|0
expr_stmt|;
name|signal_print
index|[
name|SIGIO
index|]
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
comment|/* SIGIO */
ifdef|#
directive|ifdef
name|SIGURG
name|signal_stop
index|[
name|SIGURG
index|]
operator|=
literal|0
expr_stmt|;
name|signal_print
index|[
name|SIGURG
index|]
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
comment|/* SIGURG */
block|}
end_function

end_unit

