begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Everything about breakpoints, for GDB.    Copyright 1986, 1987, 1989, 1990, 1991, 1992 Free Software Foundation, Inc.  This file is part of GDB.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|"symtab.h"
end_include

begin_include
include|#
directive|include
file|"frame.h"
end_include

begin_include
include|#
directive|include
file|"breakpoint.h"
end_include

begin_include
include|#
directive|include
file|"gdbtypes.h"
end_include

begin_include
include|#
directive|include
file|"expression.h"
end_include

begin_include
include|#
directive|include
file|"gdbcore.h"
end_include

begin_include
include|#
directive|include
file|"gdbcmd.h"
end_include

begin_include
include|#
directive|include
file|"value.h"
end_include

begin_include
include|#
directive|include
file|"ctype.h"
end_include

begin_include
include|#
directive|include
file|"command.h"
end_include

begin_include
include|#
directive|include
file|"inferior.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"language.h"
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|"demangle.h"
end_include

begin_comment
comment|/* local function prototypes */
end_comment

begin_decl_stmt
specifier|static
name|void
name|catch_command_1
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|enable_delete_command
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|enable_delete_breakpoint
name|PARAMS
argument_list|(
operator|(
expr|struct
name|breakpoint
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|enable_once_command
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|enable_once_breakpoint
name|PARAMS
argument_list|(
operator|(
expr|struct
name|breakpoint
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|disable_command
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|disable_breakpoint
name|PARAMS
argument_list|(
operator|(
expr|struct
name|breakpoint
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|enable_command
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|enable_breakpoint
name|PARAMS
argument_list|(
operator|(
expr|struct
name|breakpoint
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|map_breakpoint_numbers
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|void
argument_list|(
operator|*
argument_list|)
argument_list|(
expr|struct
name|breakpoint
operator|*
argument_list|)
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ignore_command
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|breakpoint_re_set_one
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|delete_command
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|clear_command
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|catch_command
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|symtabs_and_lines
name|get_catch_sals
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|watch_command
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|tbreak_command
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|break_command_1
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|mention
name|PARAMS
argument_list|(
operator|(
expr|struct
name|breakpoint
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|breakpoint
modifier|*
name|set_raw_breakpoint
name|PARAMS
argument_list|(
operator|(
expr|struct
name|symtab_and_line
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|check_duplicates
name|PARAMS
argument_list|(
operator|(
name|CORE_ADDR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|describe_other_breakpoints
name|PARAMS
argument_list|(
operator|(
name|CORE_ADDR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|breakpoints_info
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|breakpoint_1
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bpstat
name|bpstat_alloc
name|PARAMS
argument_list|(
operator|(
expr|struct
name|breakpoint
operator|*
operator|,
name|bpstat
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|breakpoint_cond_eval
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|cleanup_executing_breakpoints
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|commands_command
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|condition_command
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|get_number
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|set_breakpoint_count
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|addressprint
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Print machine addresses? */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|demangle
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Print de-mangled symbol names? */
end_comment

begin_comment
comment|/* Are we executing breakpoint commands?  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|executing_breakpoint_commands
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Walk the following statement or block through all breakpoints.    ALL_BREAKPOINTS_SAFE does so even if the statment deletes the current    breakpoint.  */
end_comment

begin_define
define|#
directive|define
name|ALL_BREAKPOINTS
parameter_list|(
name|b
parameter_list|)
value|for (b = breakpoint_chain; b; b = b->next)
end_define

begin_define
define|#
directive|define
name|ALL_BREAKPOINTS_SAFE
parameter_list|(
name|b
parameter_list|,
name|tmp
parameter_list|)
define|\
value|for (b = breakpoint_chain;	\ 	     b? (tmp=b->next, 1): 0;	\ 	     b = tmp)
end_define

begin_comment
comment|/* Chain of all breakpoints defined.  */
end_comment

begin_decl_stmt
name|struct
name|breakpoint
modifier|*
name|breakpoint_chain
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of last breakpoint made.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|breakpoint_count
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Set breakpoint count to NUM.  */
end_comment

begin_function
specifier|static
name|void
name|set_breakpoint_count
parameter_list|(
name|num
parameter_list|)
name|int
name|num
decl_stmt|;
block|{
name|breakpoint_count
operator|=
name|num
expr_stmt|;
name|set_internalvar
argument_list|(
name|lookup_internalvar
argument_list|(
literal|"bpnum"
argument_list|)
argument_list|,
name|value_from_longest
argument_list|(
name|builtin_type_int
argument_list|,
operator|(
name|LONGEST
operator|)
name|num
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Default address, symtab and line to put a breakpoint at    for "break" command with no arg.    if default_breakpoint_valid is zero, the other three are    not valid, and "break" with no arg is an error.     This set by print_stack_frame, which calls set_default_breakpoint.  */
end_comment

begin_decl_stmt
name|int
name|default_breakpoint_valid
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|CORE_ADDR
name|default_breakpoint_address
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|symtab
modifier|*
name|default_breakpoint_symtab
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|default_breakpoint_line
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Flag indicating extra verbosity for xgdb.  */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|xgdb_verbose
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* *PP is a string denoting a breakpoint.  Get the number of the breakpoint.    Advance *PP after the string and any trailing whitespace.     Currently the string can either be a number or "$" followed by the name    of a convenience variable.  Making it an expression wouldn't work well    for map_breakpoint_numbers (e.g. "4 + 5 + 6").  */
end_comment

begin_function
specifier|static
name|int
name|get_number
parameter_list|(
name|pp
parameter_list|)
name|char
modifier|*
modifier|*
name|pp
decl_stmt|;
block|{
name|int
name|retval
decl_stmt|;
name|char
modifier|*
name|p
init|=
operator|*
name|pp
decl_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
comment|/* Empty line means refer to the last breakpoint.  */
return|return
name|breakpoint_count
return|;
elseif|else
if|if
condition|(
operator|*
name|p
operator|==
literal|'$'
condition|)
block|{
comment|/* Make a copy of the name, so we can null-terminate it 	 to pass to lookup_internalvar().  */
name|char
modifier|*
name|varname
decl_stmt|;
name|char
modifier|*
name|start
init|=
operator|++
name|p
decl_stmt|;
name|value
name|val
decl_stmt|;
while|while
condition|(
name|isalnum
argument_list|(
operator|*
name|p
argument_list|)
operator|||
operator|*
name|p
operator|==
literal|'_'
condition|)
name|p
operator|++
expr_stmt|;
name|varname
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|p
operator|-
name|start
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|varname
argument_list|,
name|start
argument_list|,
name|p
operator|-
name|start
argument_list|)
expr_stmt|;
name|varname
index|[
name|p
operator|-
name|start
index|]
operator|=
literal|'\0'
expr_stmt|;
name|val
operator|=
name|value_of_internalvar
argument_list|(
name|lookup_internalvar
argument_list|(
name|varname
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|VALUE_TYPE
argument_list|(
name|val
argument_list|)
argument_list|)
operator|!=
name|TYPE_CODE_INT
condition|)
name|error
argument_list|(
literal|"Convenience variables used to specify breakpoints must have integer values."
argument_list|)
expr_stmt|;
name|retval
operator|=
operator|(
name|int
operator|)
name|value_as_long
argument_list|(
name|val
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|'-'
condition|)
operator|++
name|p
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|>=
literal|'0'
operator|&&
operator|*
name|p
operator|<=
literal|'9'
condition|)
operator|++
name|p
expr_stmt|;
if|if
condition|(
name|p
operator|==
operator|*
name|pp
condition|)
comment|/* There is no number here.  (e.g. "cond a == b").  */
name|error_no_arg
argument_list|(
literal|"breakpoint number"
argument_list|)
expr_stmt|;
name|retval
operator|=
name|atoi
argument_list|(
operator|*
name|pp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|isspace
argument_list|(
operator|*
name|p
argument_list|)
operator|||
operator|*
name|p
operator|==
literal|'\0'
operator|)
condition|)
name|error
argument_list|(
literal|"breakpoint number expected"
argument_list|)
expr_stmt|;
while|while
condition|(
name|isspace
argument_list|(
operator|*
name|p
argument_list|)
condition|)
name|p
operator|++
expr_stmt|;
operator|*
name|pp
operator|=
name|p
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* condition N EXP -- set break condition of breakpoint N to EXP.  */
end_comment

begin_function
specifier|static
name|void
name|condition_command
parameter_list|(
name|arg
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
specifier|register
name|struct
name|breakpoint
modifier|*
name|b
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|int
name|bnum
decl_stmt|;
if|if
condition|(
name|arg
operator|==
literal|0
condition|)
name|error_no_arg
argument_list|(
literal|"breakpoint number"
argument_list|)
expr_stmt|;
name|p
operator|=
name|arg
expr_stmt|;
name|bnum
operator|=
name|get_number
argument_list|(
operator|&
name|p
argument_list|)
expr_stmt|;
name|ALL_BREAKPOINTS
argument_list|(
argument|b
argument_list|)
if|if
condition|(
name|b
operator|->
name|number
operator|==
name|bnum
condition|)
block|{
if|if
condition|(
name|b
operator|->
name|cond
condition|)
block|{
name|free
argument_list|(
operator|(
name|PTR
operator|)
name|b
operator|->
name|cond
argument_list|)
expr_stmt|;
name|b
operator|->
name|cond
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|b
operator|->
name|cond_string
operator|!=
name|NULL
condition|)
name|free
argument_list|(
operator|(
name|PTR
operator|)
name|b
operator|->
name|cond_string
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|0
condition|)
block|{
name|b
operator|->
name|cond
operator|=
literal|0
expr_stmt|;
name|b
operator|->
name|cond_string
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|from_tty
condition|)
name|printf_filtered
argument_list|(
literal|"Breakpoint %d now unconditional.\n"
argument_list|,
name|bnum
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|arg
operator|=
name|p
expr_stmt|;
comment|/* I don't know if it matters whether this is the string the user 	       typed in or the decompiled expression.  */
name|b
operator|->
name|cond_string
operator|=
name|savestring
argument_list|(
name|arg
argument_list|,
name|strlen
argument_list|(
name|arg
argument_list|)
argument_list|)
expr_stmt|;
name|b
operator|->
name|cond
operator|=
name|parse_exp_1
argument_list|(
operator|&
name|arg
argument_list|,
name|block_for_pc
argument_list|(
name|b
operator|->
name|address
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|arg
condition|)
name|error
argument_list|(
literal|"Junk at end of expression"
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
name|error
argument_list|(
literal|"No breakpoint number %d."
argument_list|,
name|bnum
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|void
name|commands_command
parameter_list|(
name|arg
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
specifier|register
name|struct
name|breakpoint
modifier|*
name|b
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|int
name|bnum
decl_stmt|;
name|struct
name|command_line
modifier|*
name|l
decl_stmt|;
comment|/* If we allowed this, we would have problems with when to      free the storage, if we change the commands currently      being read from.  */
if|if
condition|(
name|executing_breakpoint_commands
condition|)
name|error
argument_list|(
literal|"Can't use the \"commands\" command among a breakpoint's commands."
argument_list|)
expr_stmt|;
name|p
operator|=
name|arg
expr_stmt|;
name|bnum
operator|=
name|get_number
argument_list|(
operator|&
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|&&
operator|*
name|p
condition|)
name|error
argument_list|(
literal|"Unexpected extra arguments following breakpoint number."
argument_list|)
expr_stmt|;
name|ALL_BREAKPOINTS
argument_list|(
argument|b
argument_list|)
if|if
condition|(
name|b
operator|->
name|number
operator|==
name|bnum
condition|)
block|{
if|if
condition|(
name|from_tty
operator|&&
name|input_from_terminal_p
argument_list|()
condition|)
name|printf_filtered
argument_list|(
literal|"Type commands for when breakpoint %d is hit, one per line.\n\ End with a line saying just \"end\".\n"
argument_list|,
name|bnum
argument_list|)
expr_stmt|;
name|l
operator|=
name|read_command_lines
argument_list|(
name|from_tty
argument_list|)
expr_stmt|;
name|free_command_lines
argument_list|(
name|b
operator|->
name|commands
argument_list|)
expr_stmt|;
name|b
operator|->
name|commands
operator|=
name|l
expr_stmt|;
return|return;
block|}
name|error
argument_list|(
literal|"No breakpoint number %d."
argument_list|,
name|bnum
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_decl_stmt
specifier|extern
name|int
name|memory_breakpoint_size
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* from mem-break.c */
end_comment

begin_comment
comment|/* Like target_read_memory() but if breakpoints are inserted, return    the shadow contents instead of the breakpoints themselves.     Read "memory data" from whatever target or inferior we have.     Returns zero if successful, errno value if not.  EIO is used    for address out of bounds.  If breakpoints are inserted, returns    shadow contents, not the breakpoints themselves.  From breakpoint.c.  */
end_comment

begin_function
name|int
name|read_memory_nobpt
parameter_list|(
name|memaddr
parameter_list|,
name|myaddr
parameter_list|,
name|len
parameter_list|)
name|CORE_ADDR
name|memaddr
decl_stmt|;
name|char
modifier|*
name|myaddr
decl_stmt|;
name|unsigned
name|len
decl_stmt|;
block|{
name|int
name|status
decl_stmt|;
name|struct
name|breakpoint
modifier|*
name|b
decl_stmt|;
if|if
condition|(
name|memory_breakpoint_size
operator|<
literal|0
condition|)
comment|/* No breakpoints on this machine.  */
return|return
name|target_read_memory
argument_list|(
name|memaddr
argument_list|,
name|myaddr
argument_list|,
name|len
argument_list|)
return|;
name|ALL_BREAKPOINTS
argument_list|(
argument|b
argument_list|)
block|{
if|if
condition|(
name|b
operator|->
name|type
operator|==
name|bp_watchpoint
operator|||
operator|!
name|b
operator|->
name|inserted
condition|)
continue|continue;
elseif|else
if|if
condition|(
name|b
operator|->
name|address
operator|+
name|memory_breakpoint_size
operator|<=
name|memaddr
condition|)
comment|/* The breakpoint is entirely before the chunk of memory 	   we are reading.  */
continue|continue;
elseif|else
if|if
condition|(
name|b
operator|->
name|address
operator|>=
name|memaddr
operator|+
name|len
condition|)
comment|/* The breakpoint is entirely after the chunk of memory we 	   are reading.  */
continue|continue;
else|else
block|{
comment|/* Copy the breakpoint from the shadow contents, and recurse 	     for the things before and after.  */
comment|/* Addresses and length of the part of the breakpoint that 	     we need to copy.  */
name|CORE_ADDR
name|membpt
init|=
name|b
operator|->
name|address
decl_stmt|;
name|unsigned
name|int
name|bptlen
init|=
name|memory_breakpoint_size
decl_stmt|;
comment|/* Offset within shadow_contents.  */
name|int
name|bptoffset
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|membpt
operator|<
name|memaddr
condition|)
block|{
comment|/* Only copy the second part of the breakpoint.  */
name|bptlen
operator|-=
name|memaddr
operator|-
name|membpt
expr_stmt|;
name|bptoffset
operator|=
name|memaddr
operator|-
name|membpt
expr_stmt|;
name|membpt
operator|=
name|memaddr
expr_stmt|;
block|}
if|if
condition|(
name|membpt
operator|+
name|bptlen
operator|>
name|memaddr
operator|+
name|len
condition|)
block|{
comment|/* Only copy the first part of the breakpoint.  */
name|bptlen
operator|-=
operator|(
name|membpt
operator|+
name|bptlen
operator|)
operator|-
operator|(
name|memaddr
operator|+
name|len
operator|)
expr_stmt|;
block|}
name|memcpy
argument_list|(
name|myaddr
operator|+
name|membpt
operator|-
name|memaddr
argument_list|,
name|b
operator|->
name|shadow_contents
operator|+
name|bptoffset
argument_list|,
name|bptlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|membpt
operator|>
name|memaddr
condition|)
block|{
comment|/* Copy the section of memory before the breakpoint.  */
name|status
operator|=
name|read_memory_nobpt
argument_list|(
name|memaddr
argument_list|,
name|myaddr
argument_list|,
name|membpt
operator|-
name|memaddr
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
return|return
name|status
return|;
block|}
if|if
condition|(
name|membpt
operator|+
name|bptlen
operator|<
name|memaddr
operator|+
name|len
condition|)
block|{
comment|/* Copy the section of memory after the breakpoint.  */
name|status
operator|=
name|read_memory_nobpt
argument_list|(
name|membpt
operator|+
name|bptlen
argument_list|,
name|myaddr
operator|+
name|membpt
operator|+
name|bptlen
operator|-
name|memaddr
argument_list|,
name|memaddr
operator|+
name|len
operator|-
operator|(
name|membpt
operator|+
name|bptlen
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
return|return
name|status
return|;
block|}
return|return
literal|0
return|;
block|}
block|}
comment|/* Nothing overlaps.  Just call read_memory_noerr.  */
return|return
name|target_read_memory
argument_list|(
name|memaddr
argument_list|,
name|myaddr
argument_list|,
name|len
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* insert_breakpoints is used when starting or continuing the program.    remove_breakpoints is used when the program stops.    Both return zero if successful,    or an `errno' value if could not write the inferior.  */
end_comment

begin_function
name|int
name|insert_breakpoints
parameter_list|()
block|{
specifier|register
name|struct
name|breakpoint
modifier|*
name|b
decl_stmt|;
name|int
name|val
init|=
literal|0
decl_stmt|;
name|int
name|disabled_breaks
init|=
literal|0
decl_stmt|;
name|ALL_BREAKPOINTS
argument_list|(
argument|b
argument_list|)
if|if
condition|(
name|b
operator|->
name|type
operator|!=
name|bp_watchpoint
operator|&&
name|b
operator|->
name|enable
operator|!=
name|disabled
operator|&&
operator|!
name|b
operator|->
name|inserted
operator|&&
operator|!
name|b
operator|->
name|duplicate
condition|)
block|{
name|val
operator|=
name|target_insert_breakpoint
argument_list|(
name|b
operator|->
name|address
argument_list|,
name|b
operator|->
name|shadow_contents
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
condition|)
block|{
comment|/* Can't set the breakpoint.  */
if|#
directive|if
name|defined
argument_list|(
name|DISABLE_UNSETTABLE_BREAK
argument_list|)
if|if
condition|(
name|DISABLE_UNSETTABLE_BREAK
argument_list|(
name|b
operator|->
name|address
argument_list|)
condition|)
block|{
name|val
operator|=
literal|0
expr_stmt|;
name|b
operator|->
name|enable
operator|=
name|disabled
expr_stmt|;
if|if
condition|(
operator|!
name|disabled_breaks
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Cannot insert breakpoint %d:\n"
argument_list|,
name|b
operator|->
name|number
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"Disabling shared library breakpoints:\n"
argument_list|)
expr_stmt|;
block|}
name|disabled_breaks
operator|=
literal|1
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"%d "
argument_list|,
name|b
operator|->
name|number
argument_list|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Cannot insert breakpoint %d:\n"
argument_list|,
name|b
operator|->
name|number
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ONE_PROCESS_WRITETEXT
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"The same program may be running in another process.\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|memory_error
argument_list|(
name|val
argument_list|,
name|b
operator|->
name|address
argument_list|)
expr_stmt|;
comment|/* which bombs us out */
block|}
block|}
else|else
name|b
operator|->
name|inserted
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|disabled_breaks
condition|)
name|printf_filtered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
return|return
name|val
return|;
block|}
end_function

begin_function
name|int
name|remove_breakpoints
parameter_list|()
block|{
specifier|register
name|struct
name|breakpoint
modifier|*
name|b
decl_stmt|;
name|int
name|val
decl_stmt|;
ifdef|#
directive|ifdef
name|BREAKPOINT_DEBUG
name|printf
argument_list|(
literal|"Removing breakpoints.\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* BREAKPOINT_DEBUG */
name|ALL_BREAKPOINTS
argument_list|(
argument|b
argument_list|)
if|if
condition|(
name|b
operator|->
name|type
operator|!=
name|bp_watchpoint
operator|&&
name|b
operator|->
name|inserted
condition|)
block|{
name|val
operator|=
name|target_remove_breakpoint
argument_list|(
name|b
operator|->
name|address
argument_list|,
name|b
operator|->
name|shadow_contents
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
condition|)
return|return
name|val
return|;
name|b
operator|->
name|inserted
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|BREAKPOINT_DEBUG
name|printf
argument_list|(
literal|"Removed breakpoint at %s"
argument_list|,
name|local_hex_string
argument_list|(
name|b
operator|->
name|address
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|", shadow %s"
argument_list|,
name|local_hex_string
argument_list|(
name|b
operator|->
name|shadow_contents
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|", %s.\n"
argument_list|,
name|local_hex_string
argument_list|(
name|b
operator|->
name|shadow_contents
index|[
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* BREAKPOINT_DEBUG */
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Clear the "inserted" flag in all breakpoints.    This is done when the inferior is loaded.  */
end_comment

begin_function
name|void
name|mark_breakpoints_out
parameter_list|()
block|{
specifier|register
name|struct
name|breakpoint
modifier|*
name|b
decl_stmt|;
name|ALL_BREAKPOINTS
argument_list|(
argument|b
argument_list|)
name|b
operator|->
name|inserted
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* breakpoint_here_p (PC) returns 1 if an enabled breakpoint exists at PC.    When continuing from a location with a breakpoint,    we actually single step once before calling insert_breakpoints.  */
end_comment

begin_function
name|int
name|breakpoint_here_p
parameter_list|(
name|pc
parameter_list|)
name|CORE_ADDR
name|pc
decl_stmt|;
block|{
specifier|register
name|struct
name|breakpoint
modifier|*
name|b
decl_stmt|;
name|ALL_BREAKPOINTS
argument_list|(
argument|b
argument_list|)
if|if
condition|(
name|b
operator|->
name|enable
operator|!=
name|disabled
operator|&&
name|b
operator|->
name|address
operator|==
name|pc
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* bpstat stuff.  External routines' interfaces are documented    in breakpoint.h.  */
end_comment

begin_comment
comment|/* Clear a bpstat so that it says we are not at any breakpoint.    Also free any storage that is part of a bpstat.  */
end_comment

begin_function
name|void
name|bpstat_clear
parameter_list|(
name|bsp
parameter_list|)
name|bpstat
modifier|*
name|bsp
decl_stmt|;
block|{
name|bpstat
name|p
decl_stmt|;
name|bpstat
name|q
decl_stmt|;
if|if
condition|(
name|bsp
operator|==
literal|0
condition|)
return|return;
name|p
operator|=
operator|*
name|bsp
expr_stmt|;
while|while
condition|(
name|p
operator|!=
name|NULL
condition|)
block|{
name|q
operator|=
name|p
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|old_val
operator|!=
name|NULL
condition|)
name|value_free
argument_list|(
name|p
operator|->
name|old_val
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|PTR
operator|)
name|p
argument_list|)
expr_stmt|;
name|p
operator|=
name|q
expr_stmt|;
block|}
operator|*
name|bsp
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return a copy of a bpstat.  Like "bs1 = bs2" but all storage that    is part of the bpstat is copied as well.  */
end_comment

begin_function
name|bpstat
name|bpstat_copy
parameter_list|(
name|bs
parameter_list|)
name|bpstat
name|bs
decl_stmt|;
block|{
name|bpstat
name|p
init|=
name|NULL
decl_stmt|;
name|bpstat
name|tmp
decl_stmt|;
name|bpstat
name|retval
decl_stmt|;
if|if
condition|(
name|bs
operator|==
name|NULL
condition|)
return|return
name|bs
return|;
for|for
control|(
init|;
name|bs
operator|!=
name|NULL
condition|;
name|bs
operator|=
name|bs
operator|->
name|next
control|)
block|{
name|tmp
operator|=
operator|(
name|bpstat
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|tmp
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|tmp
argument_list|,
name|bs
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|tmp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
comment|/* This is the first thing in the chain.  */
name|retval
operator|=
name|tmp
expr_stmt|;
else|else
name|p
operator|->
name|next
operator|=
name|tmp
expr_stmt|;
name|p
operator|=
name|tmp
expr_stmt|;
block|}
name|p
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function

begin_comment
comment|/* Find the bpstat associated with this breakpoint */
end_comment

begin_function
name|bpstat
name|bpstat_find_breakpoint
parameter_list|(
name|bsp
parameter_list|,
name|breakpoint
parameter_list|)
name|bpstat
name|bsp
decl_stmt|;
name|struct
name|breakpoint
modifier|*
name|breakpoint
decl_stmt|;
block|{
if|if
condition|(
name|bsp
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
for|for
control|(
init|;
name|bsp
operator|!=
name|NULL
condition|;
name|bsp
operator|=
name|bsp
operator|->
name|next
control|)
block|{
if|if
condition|(
name|bsp
operator|->
name|breakpoint_at
operator|==
name|breakpoint
condition|)
return|return
name|bsp
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Return the breakpoint number of the first breakpoint we are stopped    at.  *BSP upon return is a bpstat which points to the remaining    breakpoints stopped at (but which is not guaranteed to be good for    anything but further calls to bpstat_num).    Return 0 if passed a bpstat which does not indicate any breakpoints.  */
end_comment

begin_function
name|int
name|bpstat_num
parameter_list|(
name|bsp
parameter_list|)
name|bpstat
modifier|*
name|bsp
decl_stmt|;
block|{
name|struct
name|breakpoint
modifier|*
name|b
decl_stmt|;
if|if
condition|(
operator|(
operator|*
name|bsp
operator|)
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
comment|/* No more breakpoint values */
else|else
block|{
name|b
operator|=
operator|(
operator|*
name|bsp
operator|)
operator|->
name|breakpoint_at
expr_stmt|;
operator|*
name|bsp
operator|=
operator|(
operator|*
name|bsp
operator|)
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|b
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
comment|/* breakpoint that's been deleted since */
else|else
return|return
name|b
operator|->
name|number
return|;
comment|/* We have its number */
block|}
block|}
end_function

begin_comment
comment|/* Modify BS so that the actions will not be performed.  */
end_comment

begin_function
name|void
name|bpstat_clear_actions
parameter_list|(
name|bs
parameter_list|)
name|bpstat
name|bs
decl_stmt|;
block|{
for|for
control|(
init|;
name|bs
operator|!=
name|NULL
condition|;
name|bs
operator|=
name|bs
operator|->
name|next
control|)
block|{
name|bs
operator|->
name|commands
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|bs
operator|->
name|old_val
operator|!=
name|NULL
condition|)
block|{
name|value_free
argument_list|(
name|bs
operator|->
name|old_val
argument_list|)
expr_stmt|;
name|bs
operator|->
name|old_val
operator|=
name|NULL
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Stub for cleaning up our state if we error-out of a breakpoint command */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|void
name|cleanup_executing_breakpoints
parameter_list|(
name|ignore
parameter_list|)
name|int
name|ignore
decl_stmt|;
block|{
name|executing_breakpoint_commands
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Execute all the commands associated with all the breakpoints at this    location.  Any of these commands could cause the process to proceed    beyond this point, etc.  We look out for such changes by checking    the global "breakpoint_proceeded" after each command.  */
end_comment

begin_function
name|void
name|bpstat_do_actions
parameter_list|(
name|bsp
parameter_list|)
name|bpstat
modifier|*
name|bsp
decl_stmt|;
block|{
name|bpstat
name|bs
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|old_chain
decl_stmt|;
name|executing_breakpoint_commands
operator|=
literal|1
expr_stmt|;
name|old_chain
operator|=
name|make_cleanup
argument_list|(
name|cleanup_executing_breakpoints
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|top
label|:
name|bs
operator|=
operator|*
name|bsp
expr_stmt|;
name|breakpoint_proceeded
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
name|bs
operator|!=
name|NULL
condition|;
name|bs
operator|=
name|bs
operator|->
name|next
control|)
block|{
while|while
condition|(
name|bs
operator|->
name|commands
condition|)
block|{
name|char
modifier|*
name|line
init|=
name|bs
operator|->
name|commands
operator|->
name|line
decl_stmt|;
name|bs
operator|->
name|commands
operator|=
name|bs
operator|->
name|commands
operator|->
name|next
expr_stmt|;
name|execute_command
argument_list|(
name|line
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* If the inferior is proceeded by the command, bomb out now. 	     The bpstat chain has been blown away by wait_for_inferior. 	     But since execution has stopped again, there is a new bpstat 	     to look at, so start over.  */
if|if
condition|(
name|breakpoint_proceeded
condition|)
goto|goto
name|top
goto|;
block|}
block|}
name|executing_breakpoint_commands
operator|=
literal|0
expr_stmt|;
name|discard_cleanups
argument_list|(
name|old_chain
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print a message indicating what happened.  Returns nonzero to    say that only the source line should be printed after this (zero    return means print the frame as well as the source line).  */
end_comment

begin_function
name|int
name|bpstat_print
parameter_list|(
name|bs
parameter_list|)
name|bpstat
name|bs
decl_stmt|;
block|{
comment|/* bs->breakpoint_at can be NULL if it was a momentary breakpoint      which has since been deleted.  */
if|if
condition|(
name|bs
operator|==
name|NULL
operator|||
name|bs
operator|->
name|breakpoint_at
operator|==
name|NULL
operator|||
operator|(
name|bs
operator|->
name|breakpoint_at
operator|->
name|type
operator|!=
name|bp_breakpoint
operator|&&
name|bs
operator|->
name|breakpoint_at
operator|->
name|type
operator|!=
name|bp_watchpoint
operator|)
condition|)
return|return
literal|0
return|;
comment|/* If bpstat_stop_status says don't print, OK, we won't.  An example      circumstance is when we single-stepped for both a watchpoint and      for a "stepi" instruction.  The bpstat says that the watchpoint      explains the stop, but we shouldn't print because the watchpoint's      value didn't change -- and the real reason we are stopping here      rather than continuing to step (as the watchpoint would've had us do)      is because of the "stepi".  */
if|if
condition|(
operator|!
name|bs
operator|->
name|print
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|bs
operator|->
name|breakpoint_at
operator|->
name|type
operator|==
name|bp_breakpoint
condition|)
block|{
comment|/* I think the user probably only wants to see one breakpoint 	 number, not all of them.  */
name|printf_filtered
argument_list|(
literal|"\nBreakpoint %d, "
argument_list|,
name|bs
operator|->
name|breakpoint_at
operator|->
name|number
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|bs
operator|->
name|old_val
operator|!=
name|NULL
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"\nWatchpoint %d, "
argument_list|,
name|bs
operator|->
name|breakpoint_at
operator|->
name|number
argument_list|)
expr_stmt|;
name|print_expression
argument_list|(
name|bs
operator|->
name|breakpoint_at
operator|->
name|exp
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"\nOld value = "
argument_list|)
expr_stmt|;
name|value_print
argument_list|(
name|bs
operator|->
name|old_val
argument_list|,
name|stdout
argument_list|,
literal|0
argument_list|,
name|Val_pretty_default
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"\nNew value = "
argument_list|)
expr_stmt|;
name|value_print
argument_list|(
name|bs
operator|->
name|breakpoint_at
operator|->
name|val
argument_list|,
name|stdout
argument_list|,
literal|0
argument_list|,
name|Val_pretty_default
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|value_free
argument_list|(
name|bs
operator|->
name|old_val
argument_list|)
expr_stmt|;
name|bs
operator|->
name|old_val
operator|=
name|NULL
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/* Maybe another breakpoint in the chain caused us to stop.      (Currently all watchpoints go on the bpstat whether hit or      not.  That probably could (should) be changed, provided care is taken      with respect to bpstat_explains_signal).  */
if|if
condition|(
name|bs
operator|->
name|next
condition|)
return|return
name|bpstat_print
argument_list|(
name|bs
operator|->
name|next
argument_list|)
return|;
name|fprintf_filtered
argument_list|(
name|stderr
argument_list|,
literal|"gdb internal error: in bpstat_print\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Evaluate the expression EXP and return 1 if value is zero.    This is used inside a catch_errors to evaluate the breakpoint condition.     The argument is a "struct expression *" that has been cast to char * to     make it pass through catch_errors.  */
end_comment

begin_function
specifier|static
name|int
name|breakpoint_cond_eval
parameter_list|(
name|exp
parameter_list|)
name|char
modifier|*
name|exp
decl_stmt|;
block|{
return|return
operator|!
name|value_true
argument_list|(
name|evaluate_expression
argument_list|(
operator|(
expr|struct
name|expression
operator|*
operator|)
name|exp
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Allocate a new bpstat and chain it to the current one.  */
end_comment

begin_function
specifier|static
name|bpstat
name|bpstat_alloc
parameter_list|(
name|b
parameter_list|,
name|cbs
parameter_list|)
specifier|register
name|struct
name|breakpoint
modifier|*
name|b
decl_stmt|;
name|bpstat
name|cbs
decl_stmt|;
comment|/* Current "bs" value */
block|{
name|bpstat
name|bs
decl_stmt|;
name|bs
operator|=
operator|(
name|bpstat
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|bs
argument_list|)
argument_list|)
expr_stmt|;
name|cbs
operator|->
name|next
operator|=
name|bs
expr_stmt|;
name|bs
operator|->
name|breakpoint_at
operator|=
name|b
expr_stmt|;
comment|/* If the condition is false, etc., don't do the commands.  */
name|bs
operator|->
name|commands
operator|=
name|NULL
expr_stmt|;
name|bs
operator|->
name|momentary
operator|=
name|b
operator|->
name|disposition
operator|==
name|delete
expr_stmt|;
name|bs
operator|->
name|old_val
operator|=
name|NULL
expr_stmt|;
return|return
name|bs
return|;
block|}
end_function

begin_comment
comment|/* Determine whether we stopped at a breakpoint, etc, or whether we    don't understand this stop.  Result is a chain of bpstat's such that:  	if we don't understand the stop, the result is a null pointer.  	if we understand why we stopped, the result is not null, and 	the first element of the chain contains summary "stop" and 	"print" flags for the whole chain.  	Each element of the chain refers to a particular breakpoint or 	watchpoint at which we have stopped.  (We may have stopped for 	several reasons concurrently.)  	Each element of the chain has valid next, breakpoint_at, 	commands, FIXME??? fields.   */
end_comment

begin_function
name|bpstat
name|bpstat_stop_status
parameter_list|(
name|pc
parameter_list|,
name|frame_address
parameter_list|)
name|CORE_ADDR
modifier|*
name|pc
decl_stmt|;
name|FRAME_ADDR
name|frame_address
decl_stmt|;
block|{
specifier|register
name|struct
name|breakpoint
modifier|*
name|b
decl_stmt|;
name|int
name|stop
init|=
literal|0
decl_stmt|;
name|int
name|print
init|=
literal|0
decl_stmt|;
name|CORE_ADDR
name|bp_addr
decl_stmt|;
if|#
directive|if
name|DECR_PC_AFTER_BREAK
operator|!=
literal|0
operator|||
name|defined
argument_list|(
name|SHIFT_INST_REGS
argument_list|)
comment|/* True if we've hit a breakpoint (as opposed to a watchpoint).  */
name|int
name|real_breakpoint
init|=
literal|0
decl_stmt|;
endif|#
directive|endif
comment|/* Root of the chain of bpstat's */
name|struct
name|bpstat
name|root_bs
index|[
literal|1
index|]
decl_stmt|;
comment|/* Pointer to the last thing in the chain currently.  */
name|bpstat
name|bs
init|=
name|root_bs
decl_stmt|;
comment|/* Get the address where the breakpoint would have been.  */
name|bp_addr
operator|=
operator|*
name|pc
operator|-
name|DECR_PC_AFTER_BREAK
expr_stmt|;
name|ALL_BREAKPOINTS
argument_list|(
argument|b
argument_list|)
block|{
name|int
name|this_bp_stop
decl_stmt|;
name|int
name|this_bp_print
decl_stmt|;
if|if
condition|(
name|b
operator|->
name|enable
operator|==
name|disabled
condition|)
continue|continue;
if|if
condition|(
name|b
operator|->
name|type
operator|!=
name|bp_watchpoint
operator|&&
name|b
operator|->
name|address
operator|!=
name|bp_addr
condition|)
continue|continue;
comment|/* Come here if it's a watchpoint, or if the break address matches */
name|bs
operator|=
name|bpstat_alloc
argument_list|(
name|b
argument_list|,
name|bs
argument_list|)
expr_stmt|;
comment|/* Alloc a bpstat to explain stop */
name|this_bp_stop
operator|=
literal|1
expr_stmt|;
name|this_bp_print
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|b
operator|->
name|type
operator|==
name|bp_watchpoint
condition|)
block|{
name|int
name|within_current_scope
decl_stmt|;
if|if
condition|(
name|b
operator|->
name|exp_valid_block
operator|!=
name|NULL
condition|)
name|within_current_scope
operator|=
name|contained_in
argument_list|(
name|get_selected_block
argument_list|()
argument_list|,
name|b
operator|->
name|exp_valid_block
argument_list|)
expr_stmt|;
else|else
name|within_current_scope
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|within_current_scope
condition|)
block|{
comment|/* We use value_{,free_to_}mark because it could be a 		 *long* time before we return to the command level and 		 call free_all_values.  */
name|value
name|mark
init|=
name|value_mark
argument_list|()
decl_stmt|;
name|value
name|new_val
init|=
name|evaluate_expression
argument_list|(
name|b
operator|->
name|exp
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|value_equal
argument_list|(
name|b
operator|->
name|val
argument_list|,
name|new_val
argument_list|)
condition|)
block|{
name|release_value
argument_list|(
name|new_val
argument_list|)
expr_stmt|;
name|value_free_to_mark
argument_list|(
name|mark
argument_list|)
expr_stmt|;
name|bs
operator|->
name|old_val
operator|=
name|b
operator|->
name|val
expr_stmt|;
name|b
operator|->
name|val
operator|=
name|new_val
expr_stmt|;
comment|/* We will stop here */
block|}
else|else
block|{
comment|/* Nothing changed, don't do anything.  */
name|value_free_to_mark
argument_list|(
name|mark
argument_list|)
expr_stmt|;
continue|continue;
comment|/* We won't stop here */
block|}
block|}
else|else
block|{
comment|/* This seems like the only logical thing to do because 		 if we temporarily ignored the watchpoint, then when 		 we reenter the block in which it is valid it contains 		 garbage (in the case of a function, it may have two 		 garbage values, one before and one after the prologue). 		 So we can't even detect the first assignment to it and 		 watch after that (since the garbage may or may not equal 		 the first value assigned).  */
name|b
operator|->
name|enable
operator|=
name|disabled
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"\ Watchpoint %d disabled because the program has left the block in\n\ which its expression is valid.\n"
argument_list|,
name|b
operator|->
name|number
argument_list|)
expr_stmt|;
comment|/* We won't stop here */
comment|/* FIXME, maybe we should stop here!!! */
continue|continue;
block|}
block|}
if|#
directive|if
name|DECR_PC_AFTER_BREAK
operator|!=
literal|0
operator|||
name|defined
argument_list|(
name|SHIFT_INST_REGS
argument_list|)
else|else
name|real_breakpoint
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|b
operator|->
name|frame
operator|&&
name|b
operator|->
name|frame
operator|!=
name|frame_address
condition|)
name|this_bp_stop
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|int
name|value_is_zero
decl_stmt|;
if|if
condition|(
name|b
operator|->
name|cond
condition|)
block|{
comment|/* Need to select the frame, with all that implies 		 so that the conditions will have the right context.  */
name|select_frame
argument_list|(
name|get_current_frame
argument_list|()
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|value_is_zero
operator|=
name|catch_errors
argument_list|(
name|breakpoint_cond_eval
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|(
name|b
operator|->
name|cond
operator|)
argument_list|,
literal|"Error in testing breakpoint condition:\n"
argument_list|)
expr_stmt|;
comment|/* FIXME-someday, should give breakpoint # */
name|free_all_values
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|b
operator|->
name|cond
operator|&&
name|value_is_zero
condition|)
block|{
name|this_bp_stop
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|b
operator|->
name|ignore_count
operator|>
literal|0
condition|)
block|{
name|b
operator|->
name|ignore_count
operator|--
expr_stmt|;
name|this_bp_stop
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* We will stop here */
if|if
condition|(
name|b
operator|->
name|disposition
operator|==
name|disable
condition|)
name|b
operator|->
name|enable
operator|=
name|disabled
expr_stmt|;
name|bs
operator|->
name|commands
operator|=
name|b
operator|->
name|commands
expr_stmt|;
if|if
condition|(
name|b
operator|->
name|silent
condition|)
name|this_bp_print
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|bs
operator|->
name|commands
operator|&&
operator|!
name|strcmp
argument_list|(
literal|"silent"
argument_list|,
name|bs
operator|->
name|commands
operator|->
name|line
argument_list|)
condition|)
block|{
name|bs
operator|->
name|commands
operator|=
name|bs
operator|->
name|commands
operator|->
name|next
expr_stmt|;
name|this_bp_print
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|this_bp_stop
condition|)
name|stop
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|this_bp_print
condition|)
name|print
operator|=
literal|1
expr_stmt|;
block|}
name|bs
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
comment|/* Terminate the chain */
name|bs
operator|=
name|root_bs
operator|->
name|next
expr_stmt|;
comment|/* Re-grab the head of the chain */
if|if
condition|(
name|bs
condition|)
block|{
name|bs
operator|->
name|stop
operator|=
name|stop
expr_stmt|;
name|bs
operator|->
name|print
operator|=
name|print
expr_stmt|;
if|#
directive|if
name|DECR_PC_AFTER_BREAK
operator|!=
literal|0
operator|||
name|defined
argument_list|(
name|SHIFT_INST_REGS
argument_list|)
if|if
condition|(
name|real_breakpoint
condition|)
block|{
operator|*
name|pc
operator|=
name|bp_addr
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|SHIFT_INST_REGS
argument_list|)
block|{
name|CORE_ADDR
name|pc
init|=
name|read_register
argument_list|(
name|PC_REGNUM
argument_list|)
decl_stmt|;
name|CORE_ADDR
name|npc
init|=
name|read_register
argument_list|(
name|NPC_REGNUM
argument_list|)
decl_stmt|;
if|if
condition|(
name|pc
operator|!=
name|npc
condition|)
block|{
name|write_register
argument_list|(
name|NNPC_REGNUM
argument_list|,
name|npc
argument_list|)
expr_stmt|;
name|write_register
argument_list|(
name|NPC_REGNUM
argument_list|,
name|pc
argument_list|)
expr_stmt|;
block|}
block|}
else|#
directive|else
comment|/* No SHIFT_INST_REGS.  */
name|write_pc
argument_list|(
name|bp_addr
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* No SHIFT_INST_REGS.  */
block|}
endif|#
directive|endif
comment|/* DECR_PC_AFTER_BREAK != 0.  */
block|}
return|return
name|bs
return|;
block|}
end_function

begin_comment
comment|/* Nonzero if we should step constantly (e.g. watchpoints on machines    without hardware support).  This isn't related to a specific bpstat,    just to things like whether watchpoints are set.  */
end_comment

begin_function
name|int
name|bpstat_should_step
parameter_list|()
block|{
name|struct
name|breakpoint
modifier|*
name|b
decl_stmt|;
name|ALL_BREAKPOINTS
argument_list|(
argument|b
argument_list|)
if|if
condition|(
name|b
operator|->
name|enable
operator|==
name|enabled
operator|&&
name|b
operator|->
name|type
operator|==
name|bp_watchpoint
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Print information on breakpoint number BNUM, or -1 if all.    If WATCHPOINTS is zero, process only breakpoints; if WATCHPOINTS    is nonzero, process only watchpoints.  */
end_comment

begin_function
specifier|static
name|void
name|breakpoint_1
parameter_list|(
name|bnum
parameter_list|,
name|allflag
parameter_list|)
name|int
name|bnum
decl_stmt|;
name|int
name|allflag
decl_stmt|;
block|{
specifier|register
name|struct
name|breakpoint
modifier|*
name|b
decl_stmt|;
specifier|register
name|struct
name|command_line
modifier|*
name|l
decl_stmt|;
specifier|register
name|struct
name|symbol
modifier|*
name|sym
decl_stmt|;
name|CORE_ADDR
name|last_addr
init|=
operator|(
name|CORE_ADDR
operator|)
operator|-
literal|1
decl_stmt|;
name|int
name|found_a_breakpoint
init|=
literal|0
decl_stmt|;
specifier|static
name|char
modifier|*
name|bptypes
index|[]
init|=
block|{
literal|"breakpoint"
block|,
literal|"until"
block|,
literal|"finish"
block|,
literal|"watchpoint"
block|,
literal|"longjmp"
block|,
literal|"longjmp resume"
block|}
decl_stmt|;
specifier|static
name|char
modifier|*
name|bpdisps
index|[]
init|=
block|{
literal|"del"
block|,
literal|"dis"
block|,
literal|"keep"
block|}
decl_stmt|;
specifier|static
name|char
name|bpenables
index|[]
init|=
literal|"ny"
decl_stmt|;
if|if
condition|(
operator|!
name|breakpoint_chain
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"No breakpoints or watchpoints.\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|ALL_BREAKPOINTS
argument_list|(
argument|b
argument_list|)
if|if
condition|(
name|bnum
operator|==
operator|-
literal|1
operator|||
name|bnum
operator|==
name|b
operator|->
name|number
condition|)
block|{
comment|/*  We only print out user settable breakpoints unless the allflag is set. */
if|if
condition|(
operator|!
name|allflag
operator|&&
name|b
operator|->
name|type
operator|!=
name|bp_breakpoint
operator|&&
name|b
operator|->
name|type
operator|!=
name|bp_watchpoint
condition|)
continue|continue;
if|if
condition|(
operator|!
name|found_a_breakpoint
operator|++
condition|)
name|printf_filtered
argument_list|(
literal|"Num Type           Disp Enb %sWhat\n"
argument_list|,
name|addressprint
condition|?
literal|"Address    "
else|:
literal|""
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"%-3d %-14s %-4s %-3c "
argument_list|,
name|b
operator|->
name|number
argument_list|,
name|bptypes
index|[
operator|(
name|int
operator|)
name|b
operator|->
name|type
index|]
argument_list|,
name|bpdisps
index|[
operator|(
name|int
operator|)
name|b
operator|->
name|disposition
index|]
argument_list|,
name|bpenables
index|[
operator|(
name|int
operator|)
name|b
operator|->
name|enable
index|]
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|b
operator|->
name|type
condition|)
block|{
case|case
name|bp_watchpoint
case|:
name|print_expression
argument_list|(
name|b
operator|->
name|exp
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
break|break;
case|case
name|bp_breakpoint
case|:
case|case
name|bp_until
case|:
case|case
name|bp_finish
case|:
case|case
name|bp_longjmp
case|:
case|case
name|bp_longjmp_resume
case|:
if|if
condition|(
name|addressprint
condition|)
name|printf_filtered
argument_list|(
literal|"%s "
argument_list|,
name|local_hex_string_custom
argument_list|(
name|b
operator|->
name|address
argument_list|,
literal|"08"
argument_list|)
argument_list|)
expr_stmt|;
name|last_addr
operator|=
name|b
operator|->
name|address
expr_stmt|;
if|if
condition|(
name|b
operator|->
name|symtab
condition|)
block|{
name|sym
operator|=
name|find_pc_function
argument_list|(
name|b
operator|->
name|address
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym
condition|)
block|{
name|fputs_filtered
argument_list|(
literal|"in "
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|fputs_demangled
argument_list|(
name|SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
argument_list|,
name|stdout
argument_list|,
name|DMGL_ANSI
operator||
name|DMGL_PARAMS
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
literal|" at "
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
block|}
name|fputs_filtered
argument_list|(
name|b
operator|->
name|symtab
operator|->
name|filename
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|":%d"
argument_list|,
name|b
operator|->
name|line_number
argument_list|)
expr_stmt|;
block|}
else|else
name|print_address_symbolic
argument_list|(
name|b
operator|->
name|address
argument_list|,
name|stdout
argument_list|,
name|demangle
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
block|}
name|printf_filtered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|b
operator|->
name|frame
condition|)
name|printf_filtered
argument_list|(
literal|"\tstop only in stack frame at %s\n"
argument_list|,
name|local_hex_string
argument_list|(
name|b
operator|->
name|frame
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|b
operator|->
name|cond
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"\tstop only if "
argument_list|)
expr_stmt|;
name|print_expression
argument_list|(
name|b
operator|->
name|cond
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|b
operator|->
name|ignore_count
condition|)
name|printf_filtered
argument_list|(
literal|"\tignore next %d hits\n"
argument_list|,
name|b
operator|->
name|ignore_count
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|l
operator|=
name|b
operator|->
name|commands
operator|)
condition|)
while|while
condition|(
name|l
condition|)
block|{
name|fputs_filtered
argument_list|(
literal|"\t"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
name|l
operator|->
name|line
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
literal|"\n"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|l
operator|=
name|l
operator|->
name|next
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|found_a_breakpoint
operator|&&
name|bnum
operator|!=
operator|-
literal|1
condition|)
name|printf_filtered
argument_list|(
literal|"No breakpoint or watchpoint number %d.\n"
argument_list|,
name|bnum
argument_list|)
expr_stmt|;
elseif|else
comment|/* Compare against (CORE_ADDR)-1 in case some compiler decides        that a comparison of an unsigned with -1 is always false.  */
if|if
condition|(
name|last_addr
operator|!=
operator|(
name|CORE_ADDR
operator|)
operator|-
literal|1
condition|)
name|set_next_address
argument_list|(
name|last_addr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|void
name|breakpoints_info
parameter_list|(
name|bnum_exp
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|bnum_exp
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|int
name|bnum
init|=
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|bnum_exp
condition|)
name|bnum
operator|=
name|parse_and_eval_address
argument_list|(
name|bnum_exp
argument_list|)
expr_stmt|;
name|breakpoint_1
argument_list|(
name|bnum
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
name|MAINTENANCE_CMDS
end_if

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|void
name|maintenance_info_breakpoints
parameter_list|(
name|bnum_exp
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|bnum_exp
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|int
name|bnum
init|=
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|bnum_exp
condition|)
name|bnum
operator|=
name|parse_and_eval_address
argument_list|(
name|bnum_exp
argument_list|)
expr_stmt|;
name|breakpoint_1
argument_list|(
name|bnum
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Print a message describing any breakpoints set at PC.  */
end_comment

begin_function
specifier|static
name|void
name|describe_other_breakpoints
parameter_list|(
name|pc
parameter_list|)
specifier|register
name|CORE_ADDR
name|pc
decl_stmt|;
block|{
specifier|register
name|int
name|others
init|=
literal|0
decl_stmt|;
specifier|register
name|struct
name|breakpoint
modifier|*
name|b
decl_stmt|;
name|ALL_BREAKPOINTS
argument_list|(
argument|b
argument_list|)
if|if
condition|(
name|b
operator|->
name|address
operator|==
name|pc
condition|)
name|others
operator|++
expr_stmt|;
if|if
condition|(
name|others
operator|>
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"Note: breakpoint%s "
argument_list|,
operator|(
name|others
operator|>
literal|1
operator|)
condition|?
literal|"s"
else|:
literal|""
argument_list|)
expr_stmt|;
name|ALL_BREAKPOINTS
argument_list|(
argument|b
argument_list|)
if|if
condition|(
name|b
operator|->
name|address
operator|==
name|pc
condition|)
block|{
name|others
operator|--
expr_stmt|;
name|printf
argument_list|(
literal|"%d%s%s "
argument_list|,
name|b
operator|->
name|number
argument_list|,
operator|(
name|b
operator|->
name|enable
operator|==
name|disabled
operator|)
condition|?
literal|" (disabled)"
else|:
literal|""
argument_list|,
operator|(
name|others
operator|>
literal|1
operator|)
condition|?
literal|","
else|:
operator|(
operator|(
name|others
operator|==
literal|1
operator|)
condition|?
literal|" and"
else|:
literal|""
operator|)
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"also set at pc %s.\n"
argument_list|,
name|local_hex_string
argument_list|(
name|pc
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Set the default place to put a breakpoint    for the `break' command with no arguments.  */
end_comment

begin_function
name|void
name|set_default_breakpoint
parameter_list|(
name|valid
parameter_list|,
name|addr
parameter_list|,
name|symtab
parameter_list|,
name|line
parameter_list|)
name|int
name|valid
decl_stmt|;
name|CORE_ADDR
name|addr
decl_stmt|;
name|struct
name|symtab
modifier|*
name|symtab
decl_stmt|;
name|int
name|line
decl_stmt|;
block|{
name|default_breakpoint_valid
operator|=
name|valid
expr_stmt|;
name|default_breakpoint_address
operator|=
name|addr
expr_stmt|;
name|default_breakpoint_symtab
operator|=
name|symtab
expr_stmt|;
name|default_breakpoint_line
operator|=
name|line
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Rescan breakpoints at address ADDRESS,    marking the first one as "first" and any others as "duplicates".    This is so that the bpt instruction is only inserted once.  */
end_comment

begin_function
specifier|static
name|void
name|check_duplicates
parameter_list|(
name|address
parameter_list|)
name|CORE_ADDR
name|address
decl_stmt|;
block|{
specifier|register
name|struct
name|breakpoint
modifier|*
name|b
decl_stmt|;
specifier|register
name|int
name|count
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|address
operator|==
literal|0
condition|)
comment|/* Watchpoints are uninteresting */
return|return;
name|ALL_BREAKPOINTS
argument_list|(
argument|b
argument_list|)
if|if
condition|(
name|b
operator|->
name|enable
operator|!=
name|disabled
operator|&&
name|b
operator|->
name|address
operator|==
name|address
condition|)
block|{
name|count
operator|++
expr_stmt|;
name|b
operator|->
name|duplicate
operator|=
name|count
operator|>
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Low level routine to set a breakpoint.    Takes as args the three things that every breakpoint must have.    Returns the breakpoint object so caller can set other things.    Does not set the breakpoint number!    Does not print anything.     ==> This routine should not be called if there is a chance of later    error(); otherwise it leaves a bogus breakpoint on the chain.  Validate    your arguments BEFORE calling this routine!  */
end_comment

begin_function
specifier|static
name|struct
name|breakpoint
modifier|*
name|set_raw_breakpoint
parameter_list|(
name|sal
parameter_list|)
name|struct
name|symtab_and_line
name|sal
decl_stmt|;
block|{
specifier|register
name|struct
name|breakpoint
modifier|*
name|b
decl_stmt|,
modifier|*
name|b1
decl_stmt|;
name|b
operator|=
operator|(
expr|struct
name|breakpoint
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|breakpoint
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|b
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|b
argument_list|)
argument_list|)
expr_stmt|;
name|b
operator|->
name|address
operator|=
name|sal
operator|.
name|pc
expr_stmt|;
name|b
operator|->
name|symtab
operator|=
name|sal
operator|.
name|symtab
expr_stmt|;
name|b
operator|->
name|line_number
operator|=
name|sal
operator|.
name|line
expr_stmt|;
name|b
operator|->
name|enable
operator|=
name|enabled
expr_stmt|;
name|b
operator|->
name|next
operator|=
literal|0
expr_stmt|;
name|b
operator|->
name|silent
operator|=
literal|0
expr_stmt|;
name|b
operator|->
name|ignore_count
operator|=
literal|0
expr_stmt|;
name|b
operator|->
name|commands
operator|=
name|NULL
expr_stmt|;
name|b
operator|->
name|frame
operator|=
literal|0
expr_stmt|;
comment|/* Add this breakpoint to the end of the chain      so that a list of breakpoints will come out in order      of increasing numbers.  */
name|b1
operator|=
name|breakpoint_chain
expr_stmt|;
if|if
condition|(
name|b1
operator|==
literal|0
condition|)
name|breakpoint_chain
operator|=
name|b
expr_stmt|;
else|else
block|{
while|while
condition|(
name|b1
operator|->
name|next
condition|)
name|b1
operator|=
name|b1
operator|->
name|next
expr_stmt|;
name|b1
operator|->
name|next
operator|=
name|b
expr_stmt|;
block|}
name|check_duplicates
argument_list|(
name|sal
operator|.
name|pc
argument_list|)
expr_stmt|;
return|return
name|b
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|create_longjmp_breakpoint
parameter_list|(
name|func_name
parameter_list|)
name|char
modifier|*
name|func_name
decl_stmt|;
block|{
name|struct
name|symtab_and_line
name|sal
decl_stmt|;
name|struct
name|breakpoint
modifier|*
name|b
decl_stmt|;
specifier|static
name|int
name|internal_breakpoint_number
init|=
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|func_name
operator|!=
name|NULL
condition|)
block|{
name|struct
name|minimal_symbol
modifier|*
name|m
decl_stmt|;
name|m
operator|=
name|lookup_minimal_symbol
argument_list|(
name|func_name
argument_list|,
operator|(
expr|struct
name|objfile
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
condition|)
name|sal
operator|.
name|pc
operator|=
name|m
operator|->
name|address
expr_stmt|;
else|else
return|return;
block|}
else|else
name|sal
operator|.
name|pc
operator|=
literal|0
expr_stmt|;
name|sal
operator|.
name|symtab
operator|=
name|NULL
expr_stmt|;
name|sal
operator|.
name|line
operator|=
literal|0
expr_stmt|;
name|b
operator|=
name|set_raw_breakpoint
argument_list|(
name|sal
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|b
condition|)
return|return;
name|b
operator|->
name|type
operator|=
name|func_name
operator|!=
name|NULL
condition|?
name|bp_longjmp
else|:
name|bp_longjmp_resume
expr_stmt|;
name|b
operator|->
name|disposition
operator|=
name|donttouch
expr_stmt|;
name|b
operator|->
name|enable
operator|=
name|disabled
expr_stmt|;
name|b
operator|->
name|silent
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|func_name
condition|)
name|b
operator|->
name|addr_string
operator|=
name|strsave
argument_list|(
name|func_name
argument_list|)
expr_stmt|;
name|b
operator|->
name|number
operator|=
name|internal_breakpoint_number
operator|--
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Call this routine when stepping and nexting to enable a breakpoint if we do    a longjmp().  When we hit that breakpoint, call    set_longjmp_resume_breakpoint() to figure out where we are going. */
end_comment

begin_function
name|void
name|enable_longjmp_breakpoint
parameter_list|()
block|{
specifier|register
name|struct
name|breakpoint
modifier|*
name|b
decl_stmt|;
name|ALL_BREAKPOINTS
argument_list|(
argument|b
argument_list|)
if|if
condition|(
name|b
operator|->
name|type
operator|==
name|bp_longjmp
condition|)
block|{
name|b
operator|->
name|enable
operator|=
name|enabled
expr_stmt|;
name|check_duplicates
argument_list|(
name|b
operator|->
name|address
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|disable_longjmp_breakpoint
parameter_list|()
block|{
specifier|register
name|struct
name|breakpoint
modifier|*
name|b
decl_stmt|;
name|ALL_BREAKPOINTS
argument_list|(
argument|b
argument_list|)
if|if
condition|(
name|b
operator|->
name|type
operator|==
name|bp_longjmp
operator|||
name|b
operator|->
name|type
operator|==
name|bp_longjmp_resume
condition|)
block|{
name|b
operator|->
name|enable
operator|=
name|disabled
expr_stmt|;
name|check_duplicates
argument_list|(
name|b
operator|->
name|address
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Call this after hitting the longjmp() breakpoint.  Use this to set a new    breakpoint at the target of the jmp_buf.     FIXME - This ought to be done by setting a temporary breakpoint that gets    deleted automatically... */
end_comment

begin_function
name|void
name|set_longjmp_resume_breakpoint
parameter_list|(
name|pc
parameter_list|,
name|frame
parameter_list|)
name|CORE_ADDR
name|pc
decl_stmt|;
name|FRAME
name|frame
decl_stmt|;
block|{
specifier|register
name|struct
name|breakpoint
modifier|*
name|b
decl_stmt|;
name|ALL_BREAKPOINTS
argument_list|(
argument|b
argument_list|)
if|if
condition|(
name|b
operator|->
name|type
operator|==
name|bp_longjmp_resume
condition|)
block|{
name|b
operator|->
name|address
operator|=
name|pc
expr_stmt|;
name|b
operator|->
name|enable
operator|=
name|enabled
expr_stmt|;
if|if
condition|(
name|frame
operator|!=
name|NULL
condition|)
name|b
operator|->
name|frame
operator|=
name|FRAME_FP
argument_list|(
name|frame
argument_list|)
expr_stmt|;
else|else
name|b
operator|->
name|frame
operator|=
literal|0
expr_stmt|;
name|check_duplicates
argument_list|(
name|b
operator|->
name|address
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
end_function

begin_comment
comment|/* Set a breakpoint that will evaporate an end of command    at address specified by SAL.    Restrict it to frame FRAME if FRAME is nonzero.  */
end_comment

begin_function
name|struct
name|breakpoint
modifier|*
name|set_momentary_breakpoint
parameter_list|(
name|sal
parameter_list|,
name|frame
parameter_list|,
name|type
parameter_list|)
name|struct
name|symtab_and_line
name|sal
decl_stmt|;
name|FRAME
name|frame
decl_stmt|;
name|enum
name|bptype
name|type
decl_stmt|;
block|{
specifier|register
name|struct
name|breakpoint
modifier|*
name|b
decl_stmt|;
name|b
operator|=
name|set_raw_breakpoint
argument_list|(
name|sal
argument_list|)
expr_stmt|;
name|b
operator|->
name|type
operator|=
name|type
expr_stmt|;
name|b
operator|->
name|enable
operator|=
name|enabled
expr_stmt|;
name|b
operator|->
name|disposition
operator|=
name|donttouch
expr_stmt|;
name|b
operator|->
name|frame
operator|=
operator|(
name|frame
condition|?
name|FRAME_FP
argument_list|(
name|frame
argument_list|)
else|:
literal|0
operator|)
expr_stmt|;
return|return
name|b
return|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|void clear_momentary_breakpoints () {   register struct breakpoint *b;   ALL_BREAKPOINTS (b)     if (b->disposition == delete)       { 	delete_breakpoint (b); 	break;       } }
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_comment
comment|/* Tell the user we have just set a breakpoint B.  */
end_comment

begin_function
specifier|static
name|void
name|mention
parameter_list|(
name|b
parameter_list|)
name|struct
name|breakpoint
modifier|*
name|b
decl_stmt|;
block|{
switch|switch
condition|(
name|b
operator|->
name|type
condition|)
block|{
case|case
name|bp_watchpoint
case|:
name|printf_filtered
argument_list|(
literal|"Watchpoint %d: "
argument_list|,
name|b
operator|->
name|number
argument_list|)
expr_stmt|;
name|print_expression
argument_list|(
name|b
operator|->
name|exp
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
break|break;
case|case
name|bp_breakpoint
case|:
name|printf_filtered
argument_list|(
literal|"Breakpoint %d at %s"
argument_list|,
name|b
operator|->
name|number
argument_list|,
name|local_hex_string
argument_list|(
name|b
operator|->
name|address
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|b
operator|->
name|symtab
condition|)
name|printf_filtered
argument_list|(
literal|": file %s, line %d."
argument_list|,
name|b
operator|->
name|symtab
operator|->
name|filename
argument_list|,
name|b
operator|->
name|line_number
argument_list|)
expr_stmt|;
break|break;
case|case
name|bp_until
case|:
case|case
name|bp_finish
case|:
case|case
name|bp_longjmp
case|:
case|case
name|bp_longjmp_resume
case|:
break|break;
block|}
name|printf_filtered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* Nobody calls this currently. */
end_comment

begin_comment
comment|/* Set a breakpoint from a symtab and line.    If TEMPFLAG is nonzero, it is a temporary breakpoint.    ADDR_STRING is a malloc'd string holding the name of where we are    setting the breakpoint.  This is used later to re-set it after the    program is relinked and symbols are reloaded.    Print the same confirmation messages that the breakpoint command prints.  */
end_comment

begin_comment
unit|void set_breakpoint (s, line, tempflag, addr_string)      struct symtab *s;      int line;      int tempflag;      char *addr_string; {   register struct breakpoint *b;   struct symtab_and_line sal;      sal.symtab = s;   sal.line = line;   sal.pc = 0;   resolve_sal_pc (&sal);
comment|/* Might error out */
end_comment

begin_endif
unit|describe_other_breakpoints (sal.pc);    b = set_raw_breakpoint (sal);   set_breakpoint_count (breakpoint_count + 1);   b->number = breakpoint_count;   b->type = bp_breakpoint;   b->cond = 0;   b->addr_string = addr_string;   b->enable = enabled;   b->disposition = tempflag ? delete : donttouch;    mention (b); }
endif|#
directive|endif
end_endif

begin_comment
comment|/* 0 */
end_comment

begin_escape
end_escape

begin_comment
comment|/* Set a breakpoint according to ARG (function, linenum or *address)    and make it temporary if TEMPFLAG is nonzero. */
end_comment

begin_function
specifier|static
name|void
name|break_command_1
parameter_list|(
name|arg
parameter_list|,
name|tempflag
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
name|int
name|tempflag
decl_stmt|,
name|from_tty
decl_stmt|;
block|{
name|struct
name|symtabs_and_lines
name|sals
decl_stmt|;
name|struct
name|symtab_and_line
name|sal
decl_stmt|;
specifier|register
name|struct
name|expression
modifier|*
name|cond
init|=
literal|0
decl_stmt|;
specifier|register
name|struct
name|breakpoint
modifier|*
name|b
decl_stmt|;
comment|/* Pointers in arg to the start, and one past the end, of the condition.  */
name|char
modifier|*
name|cond_start
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|cond_end
decl_stmt|;
comment|/* Pointers in arg to the start, and one past the end,      of the address part.  */
name|char
modifier|*
name|addr_start
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|addr_end
decl_stmt|;
name|int
name|i
decl_stmt|;
name|sals
operator|.
name|sals
operator|=
name|NULL
expr_stmt|;
name|sals
operator|.
name|nelts
operator|=
literal|0
expr_stmt|;
name|sal
operator|.
name|line
operator|=
name|sal
operator|.
name|pc
operator|=
name|sal
operator|.
name|end
operator|=
literal|0
expr_stmt|;
name|sal
operator|.
name|symtab
operator|=
literal|0
expr_stmt|;
comment|/* If no arg given, or if first arg is 'if ', use the default breakpoint. */
if|if
condition|(
operator|!
name|arg
operator|||
operator|(
name|arg
index|[
literal|0
index|]
operator|==
literal|'i'
operator|&&
name|arg
index|[
literal|1
index|]
operator|==
literal|'f'
operator|&&
operator|(
name|arg
index|[
literal|2
index|]
operator|==
literal|' '
operator|||
name|arg
index|[
literal|2
index|]
operator|==
literal|'\t'
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|default_breakpoint_valid
condition|)
block|{
name|sals
operator|.
name|sals
operator|=
operator|(
expr|struct
name|symtab_and_line
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|symtab_and_line
argument_list|)
argument_list|)
expr_stmt|;
name|sal
operator|.
name|pc
operator|=
name|default_breakpoint_address
expr_stmt|;
name|sal
operator|.
name|line
operator|=
name|default_breakpoint_line
expr_stmt|;
name|sal
operator|.
name|symtab
operator|=
name|default_breakpoint_symtab
expr_stmt|;
name|sals
operator|.
name|sals
index|[
literal|0
index|]
operator|=
name|sal
expr_stmt|;
name|sals
operator|.
name|nelts
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|error
argument_list|(
literal|"No default breakpoint address now."
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|addr_start
operator|=
name|arg
expr_stmt|;
comment|/* Force almost all breakpoints to be in terms of the 	 current_source_symtab (which is decode_line_1's default).  This 	 should produce the results we want almost all of the time while 	 leaving default_breakpoint_* alone.  */
if|if
condition|(
name|default_breakpoint_valid
operator|&&
operator|(
operator|!
name|current_source_symtab
operator|||
operator|(
name|arg
operator|&&
operator|(
operator|*
name|arg
operator|==
literal|'+'
operator|||
operator|*
name|arg
operator|==
literal|'-'
operator|)
operator|)
operator|)
condition|)
name|sals
operator|=
name|decode_line_1
argument_list|(
operator|&
name|arg
argument_list|,
literal|1
argument_list|,
name|default_breakpoint_symtab
argument_list|,
name|default_breakpoint_line
argument_list|)
expr_stmt|;
else|else
name|sals
operator|=
name|decode_line_1
argument_list|(
operator|&
name|arg
argument_list|,
literal|1
argument_list|,
operator|(
expr|struct
name|symtab
operator|*
operator|)
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|addr_end
operator|=
name|arg
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|sals
operator|.
name|nelts
condition|)
return|return;
comment|/* Resolve all line numbers to PC's, and verify that conditions      can be parsed, before setting any breakpoints.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sals
operator|.
name|nelts
condition|;
name|i
operator|++
control|)
block|{
name|resolve_sal_pc
argument_list|(
operator|&
name|sals
operator|.
name|sals
index|[
name|i
index|]
argument_list|)
expr_stmt|;
while|while
condition|(
name|arg
operator|&&
operator|*
name|arg
condition|)
block|{
if|if
condition|(
name|arg
index|[
literal|0
index|]
operator|==
literal|'i'
operator|&&
name|arg
index|[
literal|1
index|]
operator|==
literal|'f'
operator|&&
operator|(
name|arg
index|[
literal|2
index|]
operator|==
literal|' '
operator|||
name|arg
index|[
literal|2
index|]
operator|==
literal|'\t'
operator|)
condition|)
block|{
name|arg
operator|+=
literal|2
expr_stmt|;
name|cond_start
operator|=
name|arg
expr_stmt|;
name|cond
operator|=
name|parse_exp_1
argument_list|(
operator|&
name|arg
argument_list|,
name|block_for_pc
argument_list|(
name|sals
operator|.
name|sals
index|[
name|i
index|]
operator|.
name|pc
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cond_end
operator|=
name|arg
expr_stmt|;
block|}
else|else
name|error
argument_list|(
literal|"Junk at end of arguments."
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Now set all the breakpoints.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sals
operator|.
name|nelts
condition|;
name|i
operator|++
control|)
block|{
name|sal
operator|=
name|sals
operator|.
name|sals
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|from_tty
condition|)
name|describe_other_breakpoints
argument_list|(
name|sal
operator|.
name|pc
argument_list|)
expr_stmt|;
name|b
operator|=
name|set_raw_breakpoint
argument_list|(
name|sal
argument_list|)
expr_stmt|;
name|set_breakpoint_count
argument_list|(
name|breakpoint_count
operator|+
literal|1
argument_list|)
expr_stmt|;
name|b
operator|->
name|number
operator|=
name|breakpoint_count
expr_stmt|;
name|b
operator|->
name|type
operator|=
name|bp_breakpoint
expr_stmt|;
name|b
operator|->
name|cond
operator|=
name|cond
expr_stmt|;
if|if
condition|(
name|addr_start
condition|)
name|b
operator|->
name|addr_string
operator|=
name|savestring
argument_list|(
name|addr_start
argument_list|,
name|addr_end
operator|-
name|addr_start
argument_list|)
expr_stmt|;
if|if
condition|(
name|cond_start
condition|)
name|b
operator|->
name|cond_string
operator|=
name|savestring
argument_list|(
name|cond_start
argument_list|,
name|cond_end
operator|-
name|cond_start
argument_list|)
expr_stmt|;
name|b
operator|->
name|enable
operator|=
name|enabled
expr_stmt|;
name|b
operator|->
name|disposition
operator|=
name|tempflag
condition|?
name|delete
else|:
name|donttouch
expr_stmt|;
name|mention
argument_list|(
name|b
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sals
operator|.
name|nelts
operator|>
literal|1
condition|)
block|{
name|printf
argument_list|(
literal|"Multiple breakpoints were set.\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Use the \"delete\" command to delete unwanted breakpoints.\n"
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
operator|(
name|PTR
operator|)
name|sals
operator|.
name|sals
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Helper function for break_command_1 and disassemble_command.  */
end_comment

begin_function
name|void
name|resolve_sal_pc
parameter_list|(
name|sal
parameter_list|)
name|struct
name|symtab_and_line
modifier|*
name|sal
decl_stmt|;
block|{
name|CORE_ADDR
name|pc
decl_stmt|;
if|if
condition|(
name|sal
operator|->
name|pc
operator|==
literal|0
operator|&&
name|sal
operator|->
name|symtab
operator|!=
literal|0
condition|)
block|{
name|pc
operator|=
name|find_line_pc
argument_list|(
name|sal
operator|->
name|symtab
argument_list|,
name|sal
operator|->
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
name|pc
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"No line %d in file \"%s\"."
argument_list|,
name|sal
operator|->
name|line
argument_list|,
name|sal
operator|->
name|symtab
operator|->
name|filename
argument_list|)
expr_stmt|;
name|sal
operator|->
name|pc
operator|=
name|pc
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|break_command
parameter_list|(
name|arg
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|break_command_1
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|tbreak_command
parameter_list|(
name|arg
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|break_command_1
argument_list|(
name|arg
argument_list|,
literal|1
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|void
name|watch_command
parameter_list|(
name|arg
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|struct
name|breakpoint
modifier|*
name|b
decl_stmt|;
name|struct
name|symtab_and_line
name|sal
decl_stmt|;
name|struct
name|expression
modifier|*
name|exp
decl_stmt|;
name|struct
name|block
modifier|*
name|exp_valid_block
decl_stmt|;
name|struct
name|value
modifier|*
name|val
decl_stmt|;
name|sal
operator|.
name|pc
operator|=
literal|0
expr_stmt|;
name|sal
operator|.
name|symtab
operator|=
name|NULL
expr_stmt|;
name|sal
operator|.
name|line
operator|=
literal|0
expr_stmt|;
comment|/* Parse arguments.  */
name|innermost_block
operator|=
name|NULL
expr_stmt|;
name|exp
operator|=
name|parse_expression
argument_list|(
name|arg
argument_list|)
expr_stmt|;
name|exp_valid_block
operator|=
name|innermost_block
expr_stmt|;
name|val
operator|=
name|evaluate_expression
argument_list|(
name|exp
argument_list|)
expr_stmt|;
name|release_value
argument_list|(
name|val
argument_list|)
expr_stmt|;
comment|/* Now set up the breakpoint.  */
name|b
operator|=
name|set_raw_breakpoint
argument_list|(
name|sal
argument_list|)
expr_stmt|;
name|set_breakpoint_count
argument_list|(
name|breakpoint_count
operator|+
literal|1
argument_list|)
expr_stmt|;
name|b
operator|->
name|number
operator|=
name|breakpoint_count
expr_stmt|;
name|b
operator|->
name|type
operator|=
name|bp_watchpoint
expr_stmt|;
name|b
operator|->
name|disposition
operator|=
name|donttouch
expr_stmt|;
name|b
operator|->
name|exp
operator|=
name|exp
expr_stmt|;
name|b
operator|->
name|exp_valid_block
operator|=
name|exp_valid_block
expr_stmt|;
name|b
operator|->
name|val
operator|=
name|val
expr_stmt|;
name|b
operator|->
name|cond
operator|=
literal|0
expr_stmt|;
name|b
operator|->
name|cond_string
operator|=
name|NULL
expr_stmt|;
name|mention
argument_list|(
name|b
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  * Helper routine for the until_command routine in infcmd.c.  Here  * because it uses the mechanisms of breakpoints.  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|void
name|until_break_command
parameter_list|(
name|arg
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|struct
name|symtabs_and_lines
name|sals
decl_stmt|;
name|struct
name|symtab_and_line
name|sal
decl_stmt|;
name|FRAME
name|prev_frame
init|=
name|get_prev_frame
argument_list|(
name|selected_frame
argument_list|)
decl_stmt|;
name|struct
name|breakpoint
modifier|*
name|breakpoint
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|old_chain
decl_stmt|;
name|clear_proceed_status
argument_list|()
expr_stmt|;
comment|/* Set a breakpoint where the user wants it and at return from      this function */
if|if
condition|(
name|default_breakpoint_valid
condition|)
name|sals
operator|=
name|decode_line_1
argument_list|(
operator|&
name|arg
argument_list|,
literal|1
argument_list|,
name|default_breakpoint_symtab
argument_list|,
name|default_breakpoint_line
argument_list|)
expr_stmt|;
else|else
name|sals
operator|=
name|decode_line_1
argument_list|(
operator|&
name|arg
argument_list|,
literal|1
argument_list|,
operator|(
expr|struct
name|symtab
operator|*
operator|)
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|sals
operator|.
name|nelts
operator|!=
literal|1
condition|)
name|error
argument_list|(
literal|"Couldn't get information on specified line."
argument_list|)
expr_stmt|;
name|sal
operator|=
name|sals
operator|.
name|sals
index|[
literal|0
index|]
expr_stmt|;
name|free
argument_list|(
operator|(
name|PTR
operator|)
name|sals
operator|.
name|sals
argument_list|)
expr_stmt|;
comment|/* malloc'd, so freed */
if|if
condition|(
operator|*
name|arg
condition|)
name|error
argument_list|(
literal|"Junk at end of arguments."
argument_list|)
expr_stmt|;
name|resolve_sal_pc
argument_list|(
operator|&
name|sal
argument_list|)
expr_stmt|;
name|breakpoint
operator|=
name|set_momentary_breakpoint
argument_list|(
name|sal
argument_list|,
name|selected_frame
argument_list|,
name|bp_until
argument_list|)
expr_stmt|;
name|old_chain
operator|=
name|make_cleanup
argument_list|(
name|delete_breakpoint
argument_list|,
name|breakpoint
argument_list|)
expr_stmt|;
comment|/* Keep within the current frame */
if|if
condition|(
name|prev_frame
condition|)
block|{
name|struct
name|frame_info
modifier|*
name|fi
decl_stmt|;
name|fi
operator|=
name|get_frame_info
argument_list|(
name|prev_frame
argument_list|)
expr_stmt|;
name|sal
operator|=
name|find_pc_line
argument_list|(
name|fi
operator|->
name|pc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sal
operator|.
name|pc
operator|=
name|fi
operator|->
name|pc
expr_stmt|;
name|breakpoint
operator|=
name|set_momentary_breakpoint
argument_list|(
name|sal
argument_list|,
name|prev_frame
argument_list|,
name|bp_until
argument_list|)
expr_stmt|;
name|make_cleanup
argument_list|(
name|delete_breakpoint
argument_list|,
name|breakpoint
argument_list|)
expr_stmt|;
block|}
name|proceed
argument_list|(
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|do_cleanups
argument_list|(
name|old_chain
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* These aren't used; I don't konw what they were for.  */
end_comment

begin_comment
comment|/* Set a breakpoint at the catch clause for NAME.  */
end_comment

begin_endif
unit|static int catch_breakpoint (name)      char *name; { }  static int disable_catch_breakpoint () { }  static int delete_catch_breakpoint () { }  static int enable_catch_breakpoint () { }
endif|#
directive|endif
end_endif

begin_comment
comment|/* 0 */
end_comment

begin_struct
struct|struct
name|sal_chain
block|{
name|struct
name|sal_chain
modifier|*
name|next
decl_stmt|;
name|struct
name|symtab_and_line
name|sal
decl_stmt|;
block|}
struct|;
end_struct

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* This isn't used; I don't know what it was for.  */
end_comment

begin_comment
comment|/* For each catch clause identified in ARGS, run FUNCTION    with that clause as an argument.  */
end_comment

begin_if
unit|static struct symtabs_and_lines map_catch_names (args, function)      char *args;      int (*function)(); {   register char *p = args;   register char *p1;   struct symtabs_and_lines sals;
if|#
directive|if
literal|0
end_if

begin_endif
unit|struct sal_chain *sal_chain = 0;
endif|#
directive|endif
end_endif

begin_comment
unit|if (p == 0)     error_no_arg ("one or more catch names");    sals.nelts = 0;   sals.sals = NULL;    while (*p)     {       p1 = p;
comment|/* Don't swallow conditional part.  */
end_comment

begin_if
unit|if (p1[0] == 'i'&& p1[1] == 'f'&& (p1[2] == ' ' || p1[2] == '\t')) 	break;        if (isalpha (*p1)) 	{ 	  p1++; 	  while (isalnum (*p1) || *p1 == '_' || *p1 == '$') 	    p1++; 	}        if (*p1&& *p1 != ' '&& *p1 != '\t') 	error ("Arguments must be catch names.");        *p1 = 0;
if|#
directive|if
literal|0
end_if

begin_endif
unit|if (function (p)) 	{ 	  struct sal_chain *next 	    = (struct sal_chain *)alloca (sizeof (struct sal_chain)); 	  next->next = sal_chain; 	  next->sal = get_catch_sal (p); 	  sal_chain = next; 	  goto win; 	}
endif|#
directive|endif
end_endif

begin_if
unit|printf ("No catch clause for exception %s.\n", p);
if|#
directive|if
literal|0
end_if

begin_endif
unit|win:
endif|#
directive|endif
end_endif

begin_endif
unit|p = p1;       while (*p == ' ' || *p == '\t') p++;     } }
endif|#
directive|endif
end_endif

begin_comment
comment|/* 0 */
end_comment

begin_comment
comment|/* This shares a lot of code with `print_frame_label_vars' from stack.c.  */
end_comment

begin_function
specifier|static
name|struct
name|symtabs_and_lines
name|get_catch_sals
parameter_list|(
name|this_level_only
parameter_list|)
name|int
name|this_level_only
decl_stmt|;
block|{
specifier|register
name|struct
name|blockvector
modifier|*
name|bl
decl_stmt|;
specifier|register
name|struct
name|block
modifier|*
name|block
decl_stmt|;
name|int
name|index
decl_stmt|,
name|have_default
init|=
literal|0
decl_stmt|;
name|struct
name|frame_info
modifier|*
name|fi
decl_stmt|;
name|CORE_ADDR
name|pc
decl_stmt|;
name|struct
name|symtabs_and_lines
name|sals
decl_stmt|;
name|struct
name|sal_chain
modifier|*
name|sal_chain
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|blocks_searched
decl_stmt|;
comment|/* Not sure whether an error message is always the correct response,      but it's better than a core dump.  */
if|if
condition|(
name|selected_frame
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|"No selected frame."
argument_list|)
expr_stmt|;
name|block
operator|=
name|get_frame_block
argument_list|(
name|selected_frame
argument_list|)
expr_stmt|;
name|fi
operator|=
name|get_frame_info
argument_list|(
name|selected_frame
argument_list|)
expr_stmt|;
name|pc
operator|=
name|fi
operator|->
name|pc
expr_stmt|;
name|sals
operator|.
name|nelts
operator|=
literal|0
expr_stmt|;
name|sals
operator|.
name|sals
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|block
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"No symbol table info available.\n"
argument_list|)
expr_stmt|;
name|bl
operator|=
name|blockvector_for_pc
argument_list|(
name|BLOCK_END
argument_list|(
name|block
argument_list|)
operator|-
literal|4
argument_list|,
operator|&
name|index
argument_list|)
expr_stmt|;
name|blocks_searched
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|BLOCKVECTOR_NBLOCKS
argument_list|(
name|bl
argument_list|)
operator|*
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|blocks_searched
argument_list|,
literal|0
argument_list|,
name|BLOCKVECTOR_NBLOCKS
argument_list|(
name|bl
argument_list|)
operator|*
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|block
operator|!=
literal|0
condition|)
block|{
name|CORE_ADDR
name|end
init|=
name|BLOCK_END
argument_list|(
name|block
argument_list|)
operator|-
literal|4
decl_stmt|;
name|int
name|last_index
decl_stmt|;
if|if
condition|(
name|bl
operator|!=
name|blockvector_for_pc
argument_list|(
name|end
argument_list|,
operator|&
name|index
argument_list|)
condition|)
name|error
argument_list|(
literal|"blockvector blotch"
argument_list|)
expr_stmt|;
if|if
condition|(
name|BLOCKVECTOR_BLOCK
argument_list|(
name|bl
argument_list|,
name|index
argument_list|)
operator|!=
name|block
condition|)
name|error
argument_list|(
literal|"blockvector botch"
argument_list|)
expr_stmt|;
name|last_index
operator|=
name|BLOCKVECTOR_NBLOCKS
argument_list|(
name|bl
argument_list|)
expr_stmt|;
name|index
operator|+=
literal|1
expr_stmt|;
comment|/* Don't print out blocks that have gone by.  */
while|while
condition|(
name|index
operator|<
name|last_index
operator|&&
name|BLOCK_END
argument_list|(
name|BLOCKVECTOR_BLOCK
argument_list|(
name|bl
argument_list|,
name|index
argument_list|)
argument_list|)
operator|<
name|pc
condition|)
name|index
operator|++
expr_stmt|;
while|while
condition|(
name|index
operator|<
name|last_index
operator|&&
name|BLOCK_END
argument_list|(
name|BLOCKVECTOR_BLOCK
argument_list|(
name|bl
argument_list|,
name|index
argument_list|)
argument_list|)
operator|<
name|end
condition|)
block|{
if|if
condition|(
name|blocks_searched
index|[
name|index
index|]
operator|==
literal|0
condition|)
block|{
name|struct
name|block
modifier|*
name|b
init|=
name|BLOCKVECTOR_BLOCK
argument_list|(
name|bl
argument_list|,
name|index
argument_list|)
decl_stmt|;
name|int
name|nsyms
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|struct
name|symbol
modifier|*
name|sym
decl_stmt|;
name|nsyms
operator|=
name|BLOCK_NSYMS
argument_list|(
name|b
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nsyms
condition|;
name|i
operator|++
control|)
block|{
name|sym
operator|=
name|BLOCK_SYM
argument_list|(
name|b
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
argument_list|,
literal|"default"
argument_list|)
condition|)
block|{
if|if
condition|(
name|have_default
condition|)
continue|continue;
name|have_default
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|==
name|LOC_LABEL
condition|)
block|{
name|struct
name|sal_chain
modifier|*
name|next
init|=
operator|(
expr|struct
name|sal_chain
operator|*
operator|)
name|alloca
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sal_chain
argument_list|)
argument_list|)
decl_stmt|;
name|next
operator|->
name|next
operator|=
name|sal_chain
expr_stmt|;
name|next
operator|->
name|sal
operator|=
name|find_pc_line
argument_list|(
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|sym
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sal_chain
operator|=
name|next
expr_stmt|;
block|}
block|}
name|blocks_searched
index|[
name|index
index|]
operator|=
literal|1
expr_stmt|;
block|}
name|index
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|have_default
condition|)
break|break;
if|if
condition|(
name|sal_chain
operator|&&
name|this_level_only
condition|)
break|break;
comment|/* After handling the function's top-level block, stop. 	 Don't continue to its superblock, the block of 	 per-file symbols.  */
if|if
condition|(
name|BLOCK_FUNCTION
argument_list|(
name|block
argument_list|)
condition|)
break|break;
name|block
operator|=
name|BLOCK_SUPERBLOCK
argument_list|(
name|block
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sal_chain
condition|)
block|{
name|struct
name|sal_chain
modifier|*
name|tmp_chain
decl_stmt|;
comment|/* Count the number of entries.  */
for|for
control|(
name|index
operator|=
literal|0
operator|,
name|tmp_chain
operator|=
name|sal_chain
init|;
name|tmp_chain
condition|;
name|tmp_chain
operator|=
name|tmp_chain
operator|->
name|next
control|)
name|index
operator|++
expr_stmt|;
name|sals
operator|.
name|nelts
operator|=
name|index
expr_stmt|;
name|sals
operator|.
name|sals
operator|=
operator|(
expr|struct
name|symtab_and_line
operator|*
operator|)
name|xmalloc
argument_list|(
name|index
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|symtab_and_line
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|index
operator|=
literal|0
init|;
name|sal_chain
condition|;
name|sal_chain
operator|=
name|sal_chain
operator|->
name|next
operator|,
name|index
operator|++
control|)
name|sals
operator|.
name|sals
index|[
name|index
index|]
operator|=
name|sal_chain
operator|->
name|sal
expr_stmt|;
block|}
return|return
name|sals
return|;
block|}
end_function

begin_comment
comment|/* Commands to deal with catching exceptions.  */
end_comment

begin_function
specifier|static
name|void
name|catch_command_1
parameter_list|(
name|arg
parameter_list|,
name|tempflag
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
name|int
name|tempflag
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
comment|/* First, translate ARG into something we can deal with in terms      of breakpoints.  */
name|struct
name|symtabs_and_lines
name|sals
decl_stmt|;
name|struct
name|symtab_and_line
name|sal
decl_stmt|;
specifier|register
name|struct
name|expression
modifier|*
name|cond
init|=
literal|0
decl_stmt|;
specifier|register
name|struct
name|breakpoint
modifier|*
name|b
decl_stmt|;
name|char
modifier|*
name|save_arg
decl_stmt|;
name|int
name|i
decl_stmt|;
name|sal
operator|.
name|line
operator|=
name|sal
operator|.
name|pc
operator|=
name|sal
operator|.
name|end
operator|=
literal|0
expr_stmt|;
name|sal
operator|.
name|symtab
operator|=
literal|0
expr_stmt|;
comment|/* If no arg given, or if first arg is 'if ', all active catch clauses      are breakpointed. */
if|if
condition|(
operator|!
name|arg
operator|||
operator|(
name|arg
index|[
literal|0
index|]
operator|==
literal|'i'
operator|&&
name|arg
index|[
literal|1
index|]
operator|==
literal|'f'
operator|&&
operator|(
name|arg
index|[
literal|2
index|]
operator|==
literal|' '
operator|||
name|arg
index|[
literal|2
index|]
operator|==
literal|'\t'
operator|)
operator|)
condition|)
block|{
comment|/* Grab all active catch clauses.  */
name|sals
operator|=
name|get_catch_sals
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Grab selected catch clauses.  */
name|error
argument_list|(
literal|"catch NAME not implemeneted"
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* This isn't used; I don't know what it was for.  */
block|sals = map_catch_names (arg, catch_breakpoint);
endif|#
directive|endif
block|}
if|if
condition|(
operator|!
name|sals
operator|.
name|nelts
condition|)
return|return;
name|save_arg
operator|=
name|arg
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sals
operator|.
name|nelts
condition|;
name|i
operator|++
control|)
block|{
name|resolve_sal_pc
argument_list|(
operator|&
name|sals
operator|.
name|sals
index|[
name|i
index|]
argument_list|)
expr_stmt|;
while|while
condition|(
name|arg
operator|&&
operator|*
name|arg
condition|)
block|{
if|if
condition|(
name|arg
index|[
literal|0
index|]
operator|==
literal|'i'
operator|&&
name|arg
index|[
literal|1
index|]
operator|==
literal|'f'
operator|&&
operator|(
name|arg
index|[
literal|2
index|]
operator|==
literal|' '
operator|||
name|arg
index|[
literal|2
index|]
operator|==
literal|'\t'
operator|)
condition|)
name|cond
operator|=
name|parse_exp_1
argument_list|(
operator|(
name|arg
operator|+=
literal|2
operator|,
operator|&
name|arg
operator|)
argument_list|,
name|block_for_pc
argument_list|(
name|sals
operator|.
name|sals
index|[
name|i
index|]
operator|.
name|pc
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"Junk at end of arguments."
argument_list|)
expr_stmt|;
block|}
name|arg
operator|=
name|save_arg
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sals
operator|.
name|nelts
condition|;
name|i
operator|++
control|)
block|{
name|sal
operator|=
name|sals
operator|.
name|sals
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|from_tty
condition|)
name|describe_other_breakpoints
argument_list|(
name|sal
operator|.
name|pc
argument_list|)
expr_stmt|;
name|b
operator|=
name|set_raw_breakpoint
argument_list|(
name|sal
argument_list|)
expr_stmt|;
name|set_breakpoint_count
argument_list|(
name|breakpoint_count
operator|+
literal|1
argument_list|)
expr_stmt|;
name|b
operator|->
name|number
operator|=
name|breakpoint_count
expr_stmt|;
name|b
operator|->
name|type
operator|=
name|bp_breakpoint
expr_stmt|;
name|b
operator|->
name|cond
operator|=
name|cond
expr_stmt|;
name|b
operator|->
name|enable
operator|=
name|enabled
expr_stmt|;
name|b
operator|->
name|disposition
operator|=
name|tempflag
condition|?
name|delete
else|:
name|donttouch
expr_stmt|;
name|printf
argument_list|(
literal|"Breakpoint %d at %s"
argument_list|,
name|b
operator|->
name|number
argument_list|,
name|local_hex_string
argument_list|(
name|b
operator|->
name|address
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|b
operator|->
name|symtab
condition|)
name|printf
argument_list|(
literal|": file %s, line %d."
argument_list|,
name|b
operator|->
name|symtab
operator|->
name|filename
argument_list|,
name|b
operator|->
name|line_number
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sals
operator|.
name|nelts
operator|>
literal|1
condition|)
block|{
name|printf
argument_list|(
literal|"Multiple breakpoints were set.\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Use the \"delete\" command to delete unwanted breakpoints.\n"
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
operator|(
name|PTR
operator|)
name|sals
operator|.
name|sals
argument_list|)
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* These aren't used; I don't know what they were for.  */
end_comment

begin_comment
comment|/* Disable breakpoints on all catch clauses described in ARGS.  */
end_comment

begin_comment
unit|static void disable_catch (args)      char *args; {
comment|/* Map the disable command to catch clauses described in ARGS.  */
end_comment

begin_comment
unit|}
comment|/* Enable breakpoints on all catch clauses described in ARGS.  */
end_comment

begin_comment
unit|static void enable_catch (args)      char *args; {
comment|/* Map the disable command to catch clauses described in ARGS.  */
end_comment

begin_comment
unit|}
comment|/* Delete breakpoints on all catch clauses in the active scope.  */
end_comment

begin_comment
unit|static void delete_catch (args)      char *args; {
comment|/* Map the delete command to catch clauses described in ARGS.  */
end_comment

begin_endif
unit|}
endif|#
directive|endif
end_endif

begin_comment
comment|/* 0 */
end_comment

begin_function
specifier|static
name|void
name|catch_command
parameter_list|(
name|arg
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|catch_command_1
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|void
name|clear_command
parameter_list|(
name|arg
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
specifier|register
name|struct
name|breakpoint
modifier|*
name|b
decl_stmt|,
modifier|*
name|b1
decl_stmt|;
name|struct
name|symtabs_and_lines
name|sals
decl_stmt|;
name|struct
name|symtab_and_line
name|sal
decl_stmt|;
specifier|register
name|struct
name|breakpoint
modifier|*
name|found
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|arg
condition|)
block|{
name|sals
operator|=
name|decode_line_spec
argument_list|(
name|arg
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sals
operator|.
name|sals
operator|=
operator|(
expr|struct
name|symtab_and_line
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|symtab_and_line
argument_list|)
argument_list|)
expr_stmt|;
name|sal
operator|.
name|line
operator|=
name|default_breakpoint_line
expr_stmt|;
name|sal
operator|.
name|symtab
operator|=
name|default_breakpoint_symtab
expr_stmt|;
name|sal
operator|.
name|pc
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sal
operator|.
name|symtab
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"No source file specified."
argument_list|)
expr_stmt|;
name|sals
operator|.
name|sals
index|[
literal|0
index|]
operator|=
name|sal
expr_stmt|;
name|sals
operator|.
name|nelts
operator|=
literal|1
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sals
operator|.
name|nelts
condition|;
name|i
operator|++
control|)
block|{
comment|/* If exact pc given, clear bpts at that pc. 	 But if sal.pc is zero, clear all bpts on specified line.  */
name|sal
operator|=
name|sals
operator|.
name|sals
index|[
name|i
index|]
expr_stmt|;
name|found
operator|=
operator|(
expr|struct
name|breakpoint
operator|*
operator|)
literal|0
expr_stmt|;
while|while
condition|(
name|breakpoint_chain
operator|&&
operator|(
name|sal
operator|.
name|pc
condition|?
name|breakpoint_chain
operator|->
name|address
operator|==
name|sal
operator|.
name|pc
else|:
operator|(
name|breakpoint_chain
operator|->
name|symtab
operator|==
name|sal
operator|.
name|symtab
operator|&&
name|breakpoint_chain
operator|->
name|line_number
operator|==
name|sal
operator|.
name|line
operator|)
operator|)
condition|)
block|{
name|b1
operator|=
name|breakpoint_chain
expr_stmt|;
name|breakpoint_chain
operator|=
name|b1
operator|->
name|next
expr_stmt|;
name|b1
operator|->
name|next
operator|=
name|found
expr_stmt|;
name|found
operator|=
name|b1
expr_stmt|;
block|}
name|ALL_BREAKPOINTS
argument_list|(
argument|b
argument_list|)
while|while
condition|(
name|b
operator|->
name|next
operator|&&
name|b
operator|->
name|next
operator|->
name|type
operator|!=
name|bp_watchpoint
operator|&&
operator|(
name|sal
operator|.
name|pc
condition|?
name|b
operator|->
name|next
operator|->
name|address
operator|==
name|sal
operator|.
name|pc
else|:
operator|(
name|b
operator|->
name|next
operator|->
name|symtab
operator|==
name|sal
operator|.
name|symtab
operator|&&
name|b
operator|->
name|next
operator|->
name|line_number
operator|==
name|sal
operator|.
name|line
operator|)
operator|)
condition|)
block|{
name|b1
operator|=
name|b
operator|->
name|next
expr_stmt|;
name|b
operator|->
name|next
operator|=
name|b1
operator|->
name|next
expr_stmt|;
name|b1
operator|->
name|next
operator|=
name|found
expr_stmt|;
name|found
operator|=
name|b1
expr_stmt|;
block|}
if|if
condition|(
name|found
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|arg
condition|)
name|error
argument_list|(
literal|"No breakpoint at %s."
argument_list|,
name|arg
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"No breakpoint at this line."
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|found
operator|->
name|next
condition|)
name|from_tty
operator|=
literal|1
expr_stmt|;
comment|/* Always report if deleted more than one */
if|if
condition|(
name|from_tty
condition|)
name|printf
argument_list|(
literal|"Deleted breakpoint%s "
argument_list|,
name|found
operator|->
name|next
condition|?
literal|"s"
else|:
literal|""
argument_list|)
expr_stmt|;
while|while
condition|(
name|found
condition|)
block|{
if|if
condition|(
name|from_tty
condition|)
name|printf
argument_list|(
literal|"%d "
argument_list|,
name|found
operator|->
name|number
argument_list|)
expr_stmt|;
name|b1
operator|=
name|found
operator|->
name|next
expr_stmt|;
name|delete_breakpoint
argument_list|(
name|found
argument_list|)
expr_stmt|;
name|found
operator|=
name|b1
expr_stmt|;
block|}
if|if
condition|(
name|from_tty
condition|)
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
operator|(
name|PTR
operator|)
name|sals
operator|.
name|sals
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Delete breakpoint in BS if they are `delete' breakpoints.    This is called after any breakpoint is hit, or after errors.  */
end_comment

begin_function
name|void
name|breakpoint_auto_delete
parameter_list|(
name|bs
parameter_list|)
name|bpstat
name|bs
decl_stmt|;
block|{
for|for
control|(
init|;
name|bs
condition|;
name|bs
operator|=
name|bs
operator|->
name|next
control|)
if|if
condition|(
name|bs
operator|->
name|breakpoint_at
operator|&&
name|bs
operator|->
name|breakpoint_at
operator|->
name|disposition
operator|==
name|delete
condition|)
name|delete_breakpoint
argument_list|(
name|bs
operator|->
name|breakpoint_at
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Delete a breakpoint and clean up all traces of it in the data structures. */
end_comment

begin_function
name|void
name|delete_breakpoint
parameter_list|(
name|bpt
parameter_list|)
name|struct
name|breakpoint
modifier|*
name|bpt
decl_stmt|;
block|{
specifier|register
name|struct
name|breakpoint
modifier|*
name|b
decl_stmt|;
specifier|register
name|bpstat
name|bs
decl_stmt|;
if|if
condition|(
name|bpt
operator|->
name|inserted
condition|)
name|target_remove_breakpoint
argument_list|(
name|bpt
operator|->
name|address
argument_list|,
name|bpt
operator|->
name|shadow_contents
argument_list|)
expr_stmt|;
if|if
condition|(
name|breakpoint_chain
operator|==
name|bpt
condition|)
name|breakpoint_chain
operator|=
name|bpt
operator|->
name|next
expr_stmt|;
name|ALL_BREAKPOINTS
argument_list|(
argument|b
argument_list|)
if|if
condition|(
name|b
operator|->
name|next
operator|==
name|bpt
condition|)
block|{
name|b
operator|->
name|next
operator|=
name|bpt
operator|->
name|next
expr_stmt|;
break|break;
block|}
name|check_duplicates
argument_list|(
name|bpt
operator|->
name|address
argument_list|)
expr_stmt|;
name|free_command_lines
argument_list|(
name|bpt
operator|->
name|commands
argument_list|)
expr_stmt|;
if|if
condition|(
name|bpt
operator|->
name|cond
condition|)
name|free
argument_list|(
operator|(
name|PTR
operator|)
name|bpt
operator|->
name|cond
argument_list|)
expr_stmt|;
if|if
condition|(
name|bpt
operator|->
name|cond_string
operator|!=
name|NULL
condition|)
name|free
argument_list|(
operator|(
name|PTR
operator|)
name|bpt
operator|->
name|cond_string
argument_list|)
expr_stmt|;
if|if
condition|(
name|bpt
operator|->
name|addr_string
operator|!=
name|NULL
condition|)
name|free
argument_list|(
operator|(
name|PTR
operator|)
name|bpt
operator|->
name|addr_string
argument_list|)
expr_stmt|;
if|if
condition|(
name|xgdb_verbose
operator|&&
name|bpt
operator|->
name|type
operator|==
name|bp_breakpoint
condition|)
name|printf
argument_list|(
literal|"breakpoint #%d deleted\n"
argument_list|,
name|bpt
operator|->
name|number
argument_list|)
expr_stmt|;
comment|/* Be sure no bpstat's are pointing at it after it's been freed.  */
comment|/* FIXME, how can we find all bpstat's?  We just check stop_bpstat for now. */
for|for
control|(
name|bs
operator|=
name|stop_bpstat
init|;
name|bs
condition|;
name|bs
operator|=
name|bs
operator|->
name|next
control|)
if|if
condition|(
name|bs
operator|->
name|breakpoint_at
operator|==
name|bpt
condition|)
name|bs
operator|->
name|breakpoint_at
operator|=
name|NULL
expr_stmt|;
name|free
argument_list|(
operator|(
name|PTR
operator|)
name|bpt
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|delete_command
parameter_list|(
name|arg
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
if|if
condition|(
name|arg
operator|==
literal|0
condition|)
block|{
comment|/* Ask user only if there are some breakpoints to delete.  */
if|if
condition|(
operator|!
name|from_tty
operator|||
operator|(
name|breakpoint_chain
operator|&&
name|query
argument_list|(
literal|"Delete all breakpoints? "
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|)
condition|)
block|{
comment|/* No arg; clear all breakpoints.  */
while|while
condition|(
name|breakpoint_chain
condition|)
name|delete_breakpoint
argument_list|(
name|breakpoint_chain
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|map_breakpoint_numbers
argument_list|(
name|arg
argument_list|,
name|delete_breakpoint
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Reset a breakpoint given it's struct breakpoint * BINT.    The value we return ends up being the return value from catch_errors.    Unused in this case.  */
end_comment

begin_function
specifier|static
name|int
name|breakpoint_re_set_one
parameter_list|(
name|bint
parameter_list|)
name|char
modifier|*
name|bint
decl_stmt|;
block|{
name|struct
name|breakpoint
modifier|*
name|b
init|=
operator|(
expr|struct
name|breakpoint
operator|*
operator|)
name|bint
decl_stmt|;
comment|/* get past catch_errs */
name|int
name|i
decl_stmt|;
name|struct
name|symtabs_and_lines
name|sals
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
name|enum
name|enable
name|save_enable
decl_stmt|;
switch|switch
condition|(
name|b
operator|->
name|type
condition|)
block|{
case|case
name|bp_breakpoint
case|:
if|if
condition|(
name|b
operator|->
name|addr_string
operator|==
name|NULL
condition|)
block|{
comment|/* Anything without a string can't be re-set. */
name|delete_breakpoint
argument_list|(
name|b
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* In case we have a problem, disable this breakpoint.  We'll restore 	 its status if we succeed.  */
name|save_enable
operator|=
name|b
operator|->
name|enable
expr_stmt|;
name|b
operator|->
name|enable
operator|=
name|disabled
expr_stmt|;
name|s
operator|=
name|b
operator|->
name|addr_string
expr_stmt|;
name|sals
operator|=
name|decode_line_1
argument_list|(
operator|&
name|s
argument_list|,
literal|1
argument_list|,
operator|(
expr|struct
name|symtab
operator|*
operator|)
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sals
operator|.
name|nelts
condition|;
name|i
operator|++
control|)
block|{
name|resolve_sal_pc
argument_list|(
operator|&
name|sals
operator|.
name|sals
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|b
operator|->
name|symtab
operator|!=
name|sals
operator|.
name|sals
index|[
name|i
index|]
operator|.
name|symtab
operator|||
name|b
operator|->
name|line_number
operator|!=
name|sals
operator|.
name|sals
index|[
name|i
index|]
operator|.
name|line
operator|||
name|b
operator|->
name|address
operator|!=
name|sals
operator|.
name|sals
index|[
name|i
index|]
operator|.
name|pc
condition|)
block|{
name|b
operator|->
name|symtab
operator|=
name|sals
operator|.
name|sals
index|[
name|i
index|]
operator|.
name|symtab
expr_stmt|;
name|b
operator|->
name|line_number
operator|=
name|sals
operator|.
name|sals
index|[
name|i
index|]
operator|.
name|line
expr_stmt|;
name|b
operator|->
name|address
operator|=
name|sals
operator|.
name|sals
index|[
name|i
index|]
operator|.
name|pc
expr_stmt|;
if|if
condition|(
name|b
operator|->
name|cond_string
operator|!=
name|NULL
condition|)
block|{
name|s
operator|=
name|b
operator|->
name|cond_string
expr_stmt|;
name|b
operator|->
name|cond
operator|=
name|parse_exp_1
argument_list|(
operator|&
name|s
argument_list|,
name|block_for_pc
argument_list|(
name|sals
operator|.
name|sals
index|[
name|i
index|]
operator|.
name|pc
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|check_duplicates
argument_list|(
name|b
operator|->
name|address
argument_list|)
expr_stmt|;
name|mention
argument_list|(
name|b
argument_list|)
expr_stmt|;
block|}
name|b
operator|->
name|enable
operator|=
name|save_enable
expr_stmt|;
comment|/* Restore it, this worked. */
block|}
name|free
argument_list|(
operator|(
name|PTR
operator|)
name|sals
operator|.
name|sals
argument_list|)
expr_stmt|;
break|break;
case|case
name|bp_watchpoint
case|:
break|break;
default|default:
name|printf_filtered
argument_list|(
literal|"Deleting unknown breakpoint type %d\n"
argument_list|,
name|b
operator|->
name|type
argument_list|)
expr_stmt|;
case|case
name|bp_until
case|:
case|case
name|bp_finish
case|:
case|case
name|bp_longjmp
case|:
case|case
name|bp_longjmp_resume
case|:
name|delete_breakpoint
argument_list|(
name|b
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Re-set all breakpoints after symbols have been re-loaded.  */
end_comment

begin_function
name|void
name|breakpoint_re_set
parameter_list|()
block|{
name|struct
name|breakpoint
modifier|*
name|b
decl_stmt|,
modifier|*
name|temp
decl_stmt|;
specifier|static
name|char
name|message1
index|[]
init|=
literal|"Error in re-setting breakpoint %d:\n"
decl_stmt|;
name|char
name|message
index|[
sizeof|sizeof
argument_list|(
name|message1
argument_list|)
operator|+
literal|30
comment|/* slop */
index|]
decl_stmt|;
comment|/* If we have no current source symtab, and we have any breakpoints,      go through the work of making a source context.  */
if|if
condition|(
name|current_source_symtab
operator|==
name|NULL
operator|&&
name|breakpoint_chain
operator|!=
literal|0
condition|)
block|{
name|select_source_symtab
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
block|}
name|ALL_BREAKPOINTS_SAFE
argument_list|(
argument|b
argument_list|,
argument|temp
argument_list|)
block|{
name|sprintf
argument_list|(
name|message
argument_list|,
name|message1
argument_list|,
name|b
operator|->
name|number
argument_list|)
expr_stmt|;
comment|/* Format possible error msg */
name|catch_errors
argument_list|(
name|breakpoint_re_set_one
argument_list|,
operator|(
name|char
operator|*
operator|)
name|b
argument_list|,
name|message
argument_list|)
expr_stmt|;
block|}
name|create_longjmp_breakpoint
argument_list|(
literal|"longjmp"
argument_list|)
expr_stmt|;
name|create_longjmp_breakpoint
argument_list|(
literal|"_longjmp"
argument_list|)
expr_stmt|;
name|create_longjmp_breakpoint
argument_list|(
literal|"siglongjmp"
argument_list|)
expr_stmt|;
name|create_longjmp_breakpoint
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* Took this out (temporaliy at least), since it produces an extra       blank line at startup. This messes up the gdbtests. -PB */
comment|/* Blank line to finish off all those mention() messages we just printed.  */
block|printf_filtered ("\n");
endif|#
directive|endif
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Set ignore-count of breakpoint number BPTNUM to COUNT.    If from_tty is nonzero, it prints a message to that effect,    which ends with a period (no newline).  */
end_comment

begin_function
name|void
name|set_ignore_count
parameter_list|(
name|bptnum
parameter_list|,
name|count
parameter_list|,
name|from_tty
parameter_list|)
name|int
name|bptnum
decl_stmt|,
name|count
decl_stmt|,
name|from_tty
decl_stmt|;
block|{
specifier|register
name|struct
name|breakpoint
modifier|*
name|b
decl_stmt|;
if|if
condition|(
name|count
operator|<
literal|0
condition|)
name|count
operator|=
literal|0
expr_stmt|;
name|ALL_BREAKPOINTS
argument_list|(
argument|b
argument_list|)
if|if
condition|(
name|b
operator|->
name|number
operator|==
name|bptnum
condition|)
block|{
name|b
operator|->
name|ignore_count
operator|=
name|count
expr_stmt|;
if|if
condition|(
operator|!
name|from_tty
condition|)
return|return;
elseif|else
if|if
condition|(
name|count
operator|==
literal|0
condition|)
name|printf_filtered
argument_list|(
literal|"Will stop next time breakpoint %d is reached."
argument_list|,
name|bptnum
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|count
operator|==
literal|1
condition|)
name|printf_filtered
argument_list|(
literal|"Will ignore next crossing of breakpoint %d."
argument_list|,
name|bptnum
argument_list|)
expr_stmt|;
else|else
name|printf_filtered
argument_list|(
literal|"Will ignore next %d crossings of breakpoint %d."
argument_list|,
name|count
argument_list|,
name|bptnum
argument_list|)
expr_stmt|;
return|return;
block|}
name|error
argument_list|(
literal|"No breakpoint number %d."
argument_list|,
name|bptnum
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Clear the ignore counts of all breakpoints.  */
end_comment

begin_function
name|void
name|breakpoint_clear_ignore_counts
parameter_list|()
block|{
name|struct
name|breakpoint
modifier|*
name|b
decl_stmt|;
name|ALL_BREAKPOINTS
argument_list|(
argument|b
argument_list|)
name|b
operator|->
name|ignore_count
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Command to set ignore-count of breakpoint N to COUNT.  */
end_comment

begin_function
specifier|static
name|void
name|ignore_command
parameter_list|(
name|args
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|char
modifier|*
name|p
init|=
name|args
decl_stmt|;
specifier|register
name|int
name|num
decl_stmt|;
if|if
condition|(
name|p
operator|==
literal|0
condition|)
name|error_no_arg
argument_list|(
literal|"a breakpoint number"
argument_list|)
expr_stmt|;
name|num
operator|=
name|get_number
argument_list|(
operator|&
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"Second argument (specified ignore-count) is missing."
argument_list|)
expr_stmt|;
name|set_ignore_count
argument_list|(
name|num
argument_list|,
name|longest_to_int
argument_list|(
name|value_as_long
argument_list|(
name|parse_and_eval
argument_list|(
name|p
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Call FUNCTION on each of the breakpoints    whose numbers are given in ARGS.  */
end_comment

begin_function_decl
specifier|static
name|void
name|map_breakpoint_numbers
parameter_list|(
name|args
parameter_list|,
name|function
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
function_decl|void
parameter_list|(
function_decl|*function
end_function_decl

begin_expr_stmt
unit|)
name|PARAMS
argument_list|(
operator|(
expr|struct
name|breakpoint
operator|*
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|p
init|=
name|args
decl_stmt|;
name|char
modifier|*
name|p1
decl_stmt|;
specifier|register
name|int
name|num
decl_stmt|;
specifier|register
name|struct
name|breakpoint
modifier|*
name|b
decl_stmt|;
if|if
condition|(
name|p
operator|==
literal|0
condition|)
name|error_no_arg
argument_list|(
literal|"one or more breakpoint numbers"
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|p
condition|)
block|{
name|p1
operator|=
name|p
expr_stmt|;
name|num
operator|=
name|get_number
argument_list|(
operator|&
name|p1
argument_list|)
expr_stmt|;
name|ALL_BREAKPOINTS
argument_list|(
argument|b
argument_list|)
if|if
condition|(
name|b
operator|->
name|number
operator|==
name|num
condition|)
block|{
name|function
argument_list|(
name|b
argument_list|)
expr_stmt|;
goto|goto
name|win
goto|;
block|}
name|printf
argument_list|(
literal|"No breakpoint number %d.\n"
argument_list|,
name|num
argument_list|)
expr_stmt|;
name|win
label|:
name|p
operator|=
name|p1
expr_stmt|;
block|}
block|}
end_block

begin_function
specifier|static
name|void
name|enable_breakpoint
parameter_list|(
name|bpt
parameter_list|)
name|struct
name|breakpoint
modifier|*
name|bpt
decl_stmt|;
block|{
name|bpt
operator|->
name|enable
operator|=
name|enabled
expr_stmt|;
if|if
condition|(
name|xgdb_verbose
operator|&&
name|bpt
operator|->
name|type
operator|==
name|bp_breakpoint
condition|)
name|printf
argument_list|(
literal|"breakpoint #%d enabled\n"
argument_list|,
name|bpt
operator|->
name|number
argument_list|)
expr_stmt|;
name|check_duplicates
argument_list|(
name|bpt
operator|->
name|address
argument_list|)
expr_stmt|;
if|if
condition|(
name|bpt
operator|->
name|type
operator|==
name|bp_watchpoint
condition|)
block|{
if|if
condition|(
name|bpt
operator|->
name|exp_valid_block
operator|!=
name|NULL
operator|&&
operator|!
name|contained_in
argument_list|(
name|get_selected_block
argument_list|()
argument_list|,
name|bpt
operator|->
name|exp_valid_block
argument_list|)
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"\ Cannot enable watchpoint %d because the block in which its expression\n\ is valid is not currently in scope.\n"
argument_list|,
name|bpt
operator|->
name|number
argument_list|)
expr_stmt|;
return|return;
block|}
name|value_free
argument_list|(
name|bpt
operator|->
name|val
argument_list|)
expr_stmt|;
name|bpt
operator|->
name|val
operator|=
name|evaluate_expression
argument_list|(
name|bpt
operator|->
name|exp
argument_list|)
expr_stmt|;
name|release_value
argument_list|(
name|bpt
operator|->
name|val
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|void
name|enable_command
parameter_list|(
name|args
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|struct
name|breakpoint
modifier|*
name|bpt
decl_stmt|;
if|if
condition|(
name|args
operator|==
literal|0
condition|)
name|ALL_BREAKPOINTS
argument_list|(
argument|bpt
argument_list|)
switch|switch
condition|(
name|bpt
operator|->
name|type
condition|)
block|{
case|case
name|bp_breakpoint
case|:
case|case
name|bp_watchpoint
case|:
name|enable_breakpoint
argument_list|(
name|bpt
argument_list|)
expr_stmt|;
default|default:
continue|continue;
block|}
else|else
name|map_breakpoint_numbers
argument_list|(
name|args
argument_list|,
name|enable_breakpoint
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|disable_breakpoint
parameter_list|(
name|bpt
parameter_list|)
name|struct
name|breakpoint
modifier|*
name|bpt
decl_stmt|;
block|{
name|bpt
operator|->
name|enable
operator|=
name|disabled
expr_stmt|;
if|if
condition|(
name|xgdb_verbose
operator|&&
name|bpt
operator|->
name|type
operator|==
name|bp_breakpoint
condition|)
name|printf_filtered
argument_list|(
literal|"breakpoint #%d disabled\n"
argument_list|,
name|bpt
operator|->
name|number
argument_list|)
expr_stmt|;
name|check_duplicates
argument_list|(
name|bpt
operator|->
name|address
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|void
name|disable_command
parameter_list|(
name|args
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
specifier|register
name|struct
name|breakpoint
modifier|*
name|bpt
decl_stmt|;
if|if
condition|(
name|args
operator|==
literal|0
condition|)
name|ALL_BREAKPOINTS
argument_list|(
argument|bpt
argument_list|)
switch|switch
condition|(
name|bpt
operator|->
name|type
condition|)
block|{
case|case
name|bp_breakpoint
case|:
case|case
name|bp_watchpoint
case|:
name|disable_breakpoint
argument_list|(
name|bpt
argument_list|)
expr_stmt|;
default|default:
continue|continue;
block|}
else|else
name|map_breakpoint_numbers
argument_list|(
name|args
argument_list|,
name|disable_breakpoint
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|enable_once_breakpoint
parameter_list|(
name|bpt
parameter_list|)
name|struct
name|breakpoint
modifier|*
name|bpt
decl_stmt|;
block|{
name|bpt
operator|->
name|enable
operator|=
name|enabled
expr_stmt|;
name|bpt
operator|->
name|disposition
operator|=
name|disable
expr_stmt|;
name|check_duplicates
argument_list|(
name|bpt
operator|->
name|address
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|void
name|enable_once_command
parameter_list|(
name|args
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|map_breakpoint_numbers
argument_list|(
name|args
argument_list|,
name|enable_once_breakpoint
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|enable_delete_breakpoint
parameter_list|(
name|bpt
parameter_list|)
name|struct
name|breakpoint
modifier|*
name|bpt
decl_stmt|;
block|{
name|bpt
operator|->
name|enable
operator|=
name|enabled
expr_stmt|;
name|bpt
operator|->
name|disposition
operator|=
name|delete
expr_stmt|;
name|check_duplicates
argument_list|(
name|bpt
operator|->
name|address
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|void
name|enable_delete_command
parameter_list|(
name|args
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|map_breakpoint_numbers
argument_list|(
name|args
argument_list|,
name|enable_delete_breakpoint
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|clear_breakpoints
parameter_list|()
block|{
name|delete_command
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  * Use default_breakpoint_'s, or nothing if they aren't valid.  */
end_comment

begin_function
name|struct
name|symtabs_and_lines
name|decode_line_spec_1
parameter_list|(
name|string
parameter_list|,
name|funfirstline
parameter_list|)
name|char
modifier|*
name|string
decl_stmt|;
name|int
name|funfirstline
decl_stmt|;
block|{
name|struct
name|symtabs_and_lines
name|sals
decl_stmt|;
if|if
condition|(
name|string
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"Empty line specification."
argument_list|)
expr_stmt|;
if|if
condition|(
name|default_breakpoint_valid
condition|)
name|sals
operator|=
name|decode_line_1
argument_list|(
operator|&
name|string
argument_list|,
name|funfirstline
argument_list|,
name|default_breakpoint_symtab
argument_list|,
name|default_breakpoint_line
argument_list|)
expr_stmt|;
else|else
name|sals
operator|=
name|decode_line_1
argument_list|(
operator|&
name|string
argument_list|,
name|funfirstline
argument_list|,
operator|(
expr|struct
name|symtab
operator|*
operator|)
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|string
condition|)
name|error
argument_list|(
literal|"Junk at end of line specification: %s"
argument_list|,
name|string
argument_list|)
expr_stmt|;
return|return
name|sals
return|;
block|}
end_function

begin_escape
end_escape

begin_function
name|void
name|_initialize_breakpoint
parameter_list|()
block|{
specifier|extern
name|char
modifier|*
modifier|*
name|make_function_completion_list
parameter_list|()
function_decl|;
name|breakpoint_chain
operator|=
literal|0
expr_stmt|;
comment|/* Don't bother to call set_breakpoint_count.  $bpnum isn't useful      before a breakpoint is set.  */
name|breakpoint_count
operator|=
literal|0
expr_stmt|;
name|add_com
argument_list|(
literal|"ignore"
argument_list|,
name|class_breakpoint
argument_list|,
name|ignore_command
argument_list|,
literal|"Set ignore-count of breakpoint number N to COUNT."
argument_list|)
expr_stmt|;
name|add_com
argument_list|(
literal|"commands"
argument_list|,
name|class_breakpoint
argument_list|,
name|commands_command
argument_list|,
literal|"Set commands to be executed when a breakpoint is hit.\n\ Give breakpoint number as argument after \"commands\".\n\ With no argument, the targeted breakpoint is the last one set.\n\ The commands themselves follow starting on the next line.\n\ Type a line containing \"end\" to indicate the end of them.\n\ Give \"silent\" as the first line to make the breakpoint silent;\n\ then no output is printed when it is hit, except what the commands print."
argument_list|)
expr_stmt|;
name|add_com
argument_list|(
literal|"condition"
argument_list|,
name|class_breakpoint
argument_list|,
name|condition_command
argument_list|,
literal|"Specify breakpoint number N to break only if COND is true.\n\ N is an integer; COND is an expression to be evaluated whenever\n\ breakpoint N is reached.  "
argument_list|)
expr_stmt|;
name|add_cmd
argument_list|(
literal|"tbreak"
argument_list|,
name|class_breakpoint
argument_list|,
name|tbreak_command
argument_list|,
literal|"Set a temporary breakpoint.  Args like \"break\" command.\n\ Like \"break\" except the breakpoint is only enabled temporarily,\n\ so it will be disabled when hit.  Equivalent to \"break\" followed\n\ by using \"enable once\" on the breakpoint number."
argument_list|,
operator|&
name|cmdlist
argument_list|)
operator|->
name|completer
operator|=
name|make_function_completion_list
expr_stmt|;
name|add_prefix_cmd
argument_list|(
literal|"enable"
argument_list|,
name|class_breakpoint
argument_list|,
name|enable_command
argument_list|,
literal|"Enable some breakpoints.\n\ Give breakpoint numbers (separated by spaces) as arguments.\n\ With no subcommand, breakpoints are enabled until you command otherwise.\n\ This is used to cancel the effect of the \"disable\" command.\n\ With a subcommand you can enable temporarily."
argument_list|,
operator|&
name|enablelist
argument_list|,
literal|"enable "
argument_list|,
literal|1
argument_list|,
operator|&
name|cmdlist
argument_list|)
expr_stmt|;
name|add_abbrev_prefix_cmd
argument_list|(
literal|"breakpoints"
argument_list|,
name|class_breakpoint
argument_list|,
name|enable_command
argument_list|,
literal|"Enable some breakpoints.\n\ Give breakpoint numbers (separated by spaces) as arguments.\n\ This is used to cancel the effect of the \"disable\" command.\n\ May be abbreviated to simply \"enable\".\n"
argument_list|,
operator|&
name|enablebreaklist
argument_list|,
literal|"enable breakpoints "
argument_list|,
literal|1
argument_list|,
operator|&
name|enablelist
argument_list|)
expr_stmt|;
name|add_cmd
argument_list|(
literal|"once"
argument_list|,
name|no_class
argument_list|,
name|enable_once_command
argument_list|,
literal|"Enable breakpoints for one hit.  Give breakpoint numbers.\n\ If a breakpoint is hit while enabled in this fashion, it becomes disabled.\n\ See the \"tbreak\" command which sets a breakpoint and enables it once."
argument_list|,
operator|&
name|enablebreaklist
argument_list|)
expr_stmt|;
name|add_cmd
argument_list|(
literal|"delete"
argument_list|,
name|no_class
argument_list|,
name|enable_delete_command
argument_list|,
literal|"Enable breakpoints and delete when hit.  Give breakpoint numbers.\n\ If a breakpoint is hit while enabled in this fashion, it is deleted."
argument_list|,
operator|&
name|enablebreaklist
argument_list|)
expr_stmt|;
name|add_cmd
argument_list|(
literal|"delete"
argument_list|,
name|no_class
argument_list|,
name|enable_delete_command
argument_list|,
literal|"Enable breakpoints and delete when hit.  Give breakpoint numbers.\n\ If a breakpoint is hit while enabled in this fashion, it is deleted."
argument_list|,
operator|&
name|enablelist
argument_list|)
expr_stmt|;
name|add_cmd
argument_list|(
literal|"once"
argument_list|,
name|no_class
argument_list|,
name|enable_once_command
argument_list|,
literal|"Enable breakpoints for one hit.  Give breakpoint numbers.\n\ If a breakpoint is hit while enabled in this fashion, it becomes disabled.\n\ See the \"tbreak\" command which sets a breakpoint and enables it once."
argument_list|,
operator|&
name|enablelist
argument_list|)
expr_stmt|;
name|add_prefix_cmd
argument_list|(
literal|"disable"
argument_list|,
name|class_breakpoint
argument_list|,
name|disable_command
argument_list|,
literal|"Disable some breakpoints.\n\ Arguments are breakpoint numbers with spaces in between.\n\ To disable all breakpoints, give no argument.\n\ A disabled breakpoint is not forgotten, but has no effect until reenabled."
argument_list|,
operator|&
name|disablelist
argument_list|,
literal|"disable "
argument_list|,
literal|1
argument_list|,
operator|&
name|cmdlist
argument_list|)
expr_stmt|;
name|add_com_alias
argument_list|(
literal|"dis"
argument_list|,
literal|"disable"
argument_list|,
name|class_breakpoint
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|add_com_alias
argument_list|(
literal|"disa"
argument_list|,
literal|"disable"
argument_list|,
name|class_breakpoint
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|add_cmd
argument_list|(
literal|"breakpoints"
argument_list|,
name|class_alias
argument_list|,
name|disable_command
argument_list|,
literal|"Disable some breakpoints.\n\ Arguments are breakpoint numbers with spaces in between.\n\ To disable all breakpoints, give no argument.\n\ A disabled breakpoint is not forgotten, but has no effect until reenabled.\n\ This command may be abbreviated \"disable\"."
argument_list|,
operator|&
name|disablelist
argument_list|)
expr_stmt|;
name|add_prefix_cmd
argument_list|(
literal|"delete"
argument_list|,
name|class_breakpoint
argument_list|,
name|delete_command
argument_list|,
literal|"Delete some breakpoints or auto-display expressions.\n\ Arguments are breakpoint numbers with spaces in between.\n\ To delete all breakpoints, give no argument.\n\ \n\ Also a prefix command for deletion of other GDB objects.\n\ The \"unset\" command is also an alias for \"delete\"."
argument_list|,
operator|&
name|deletelist
argument_list|,
literal|"delete "
argument_list|,
literal|1
argument_list|,
operator|&
name|cmdlist
argument_list|)
expr_stmt|;
name|add_com_alias
argument_list|(
literal|"d"
argument_list|,
literal|"delete"
argument_list|,
name|class_breakpoint
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|add_cmd
argument_list|(
literal|"breakpoints"
argument_list|,
name|class_alias
argument_list|,
name|delete_command
argument_list|,
literal|"Delete some breakpoints or auto-display expressions.\n\ Arguments are breakpoint numbers with spaces in between.\n\ To delete all breakpoints, give no argument.\n\ This command may be abbreviated \"delete\"."
argument_list|,
operator|&
name|deletelist
argument_list|)
expr_stmt|;
name|add_cmd
argument_list|(
literal|"clear"
argument_list|,
name|class_breakpoint
argument_list|,
name|clear_command
argument_list|,
literal|"Clear breakpoint at specified line or function.\n\ Argument may be line number, function name, or \"*\" and an address.\n\ If line number is specified, all breakpoints in that line are cleared.\n\ If function is specified, breakpoints at beginning of function are cleared.\n\ If an address is specified, breakpoints at that address are cleared.\n\n\ With no argument, clears all breakpoints in the line that the selected frame\n\ is executing in.\n\ \n\ See also the \"delete\" command which clears breakpoints by number."
argument_list|,
operator|&
name|cmdlist
argument_list|)
operator|->
name|completer
operator|=
name|make_function_completion_list
expr_stmt|;
name|add_cmd
argument_list|(
literal|"break"
argument_list|,
name|class_breakpoint
argument_list|,
name|break_command
argument_list|,
literal|"Set breakpoint at specified line or function.\n\ Argument may be line number, function name, or \"*\" and an address.\n\ If line number is specified, break at start of code for that line.\n\ If function is specified, break at start of code for that function.\n\ If an address is specified, break at that exact address.\n\ With no arg, uses current execution address of selected stack frame.\n\ This is useful for breaking on return to a stack frame.\n\ \n\ Multiple breakpoints at one place are permitted, and useful if conditional.\n\ \n\ Do \"help breakpoints\" for info on other commands dealing with breakpoints."
argument_list|,
operator|&
name|cmdlist
argument_list|)
operator|->
name|completer
operator|=
name|make_function_completion_list
expr_stmt|;
name|add_com_alias
argument_list|(
literal|"b"
argument_list|,
literal|"break"
argument_list|,
name|class_run
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|add_com_alias
argument_list|(
literal|"br"
argument_list|,
literal|"break"
argument_list|,
name|class_run
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|add_com_alias
argument_list|(
literal|"bre"
argument_list|,
literal|"break"
argument_list|,
name|class_run
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|add_com_alias
argument_list|(
literal|"brea"
argument_list|,
literal|"break"
argument_list|,
name|class_run
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|add_info
argument_list|(
literal|"breakpoints"
argument_list|,
name|breakpoints_info
argument_list|,
literal|"Status of user-settable breakpoints, or breakpoint number NUMBER.\n\ The \"Type\" column indicates one of:\n\ \tbreakpoint     - normal breakpoint\n\ \twatchpoint     - watchpoint\n\ The \"Disp\" column contains one of \"keep\", \"del\", or \"dis\" to indicate\n\ the disposition of the breakpoint after it gets hit.  \"dis\" means that the\n\ breakpoint will be disabled.  The \"Address\" and \"What\" columns indicate the\n\ address and file/line number respectively.\n\n\ Convenience variable \"$_\" and default examine address for \"x\"\n\ are set to the address of the last breakpoint listed.\n\n\ Convenience variable \"$bpnum\" contains the number of the last\n\ breakpoint set."
argument_list|)
expr_stmt|;
if|#
directive|if
name|MAINTENANCE_CMDS
name|add_cmd
argument_list|(
literal|"breakpoints"
argument_list|,
name|class_maintenance
argument_list|,
name|maintenance_info_breakpoints
argument_list|,
literal|"Status of all breakpoints, or breakpoint number NUMBER.\n\ The \"Type\" column indicates one of:\n\ \tbreakpoint     - normal breakpoint\n\ \twatchpoint     - watchpoint\n\ \tlongjmp        - internal breakpoint used to step through longjmp()\n\ \tlongjmp resume - internal breakpoint at the target of longjmp()\n\ \tuntil          - internal breakpoint used by the \"until\" command\n\ \tfinish         - internal breakpoint used by the \"finish\" command\n\ The \"Disp\" column contains one of \"keep\", \"del\", or \"dis\" to indicate\n\ the disposition of the breakpoint after it gets hit.  \"dis\" means that the\n\ breakpoint will be disabled.  The \"Address\" and \"What\" columns indicate the\n\ address and file/line number respectively.\n\n\ Convenience variable \"$_\" and default examine address for \"x\"\n\ are set to the address of the last breakpoint listed.\n\n\ Convenience variable \"$bpnum\" contains the number of the last\n\ breakpoint set."
argument_list|,
operator|&
name|maintenanceinfolist
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* MAINTENANCE_CMDS */
name|add_com
argument_list|(
literal|"catch"
argument_list|,
name|class_breakpoint
argument_list|,
name|catch_command
argument_list|,
literal|"Set breakpoints to catch exceptions that are raised.\n\ Argument may be a single exception to catch, multiple exceptions\n\ to catch, or the default exception \"default\".  If no arguments\n\ are given, breakpoints are set at all exception handlers catch clauses\n\ within the current scope.\n\ \n\ A condition specified for the catch applies to all breakpoints set\n\ with this command\n\ \n\ Do \"help breakpoints\" for info on other commands dealing with breakpoints."
argument_list|)
expr_stmt|;
name|add_com
argument_list|(
literal|"watch"
argument_list|,
name|class_breakpoint
argument_list|,
name|watch_command
argument_list|,
literal|"Set a watchpoint for an expression.\n\ A watchpoint stops execution of your program whenever the value of\n\ an expression changes."
argument_list|)
expr_stmt|;
name|add_info
argument_list|(
literal|"watchpoints"
argument_list|,
name|breakpoints_info
argument_list|,
literal|"Synonym for ``info breakpoints''."
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|IBM6000_TARGET
end_ifdef

begin_comment
comment|/* Where should this function go? It is used by AIX only. FIXME. */
end_comment

begin_comment
comment|/* Breakpoint address relocation used to be done in breakpoint_re_set(). That    approach the following problem:       before running the program, if a file is list, then a breakpoint is      set (just the line number), then if we switch into another file and run      the program, just a line number as a breakpoint address was not      descriptive enough and breakpoint was ending up in a different file's      similar line.     I don't think any other platform has this breakpoint relocation problem, so this   is not an issue for other platforms. */
end_comment

begin_function
name|void
name|fixup_breakpoints
parameter_list|(
name|low
parameter_list|,
name|high
parameter_list|,
name|delta
parameter_list|)
name|CORE_ADDR
name|low
decl_stmt|;
name|CORE_ADDR
name|high
decl_stmt|;
name|CORE_ADDR
name|delta
decl_stmt|;
block|{
name|struct
name|breakpoint
modifier|*
name|b
decl_stmt|;
name|ALL_BREAKPOINTS
argument_list|(
argument|b
argument_list|)
block|{
if|if
condition|(
name|b
operator|->
name|address
operator|>=
name|low
operator|&&
name|b
operator|->
name|address
operator|<=
name|high
condition|)
name|b
operator|->
name|address
operator|+=
name|delta
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

