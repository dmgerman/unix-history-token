begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Print and select stack frames for GDB, the GNU debugger.    Copyright (C) 1986, 1987, 1989, 1991 Free Software Foundation, Inc.  This file is part of GDB.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"value.h"
end_include

begin_include
include|#
directive|include
file|"symtab.h"
end_include

begin_include
include|#
directive|include
file|"gdbtypes.h"
end_include

begin_include
include|#
directive|include
file|"expression.h"
end_include

begin_include
include|#
directive|include
file|"language.h"
end_include

begin_include
include|#
directive|include
file|"frame.h"
end_include

begin_include
include|#
directive|include
file|"gdbcmd.h"
end_include

begin_include
include|#
directive|include
file|"gdbcore.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"breakpoint.h"
end_include

begin_include
include|#
directive|include
file|"demangle.h"
end_include

begin_decl_stmt
specifier|static
name|void
name|return_command
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|down_command
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|down_silently_command
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|up_command
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|up_silently_command
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|frame_command
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|select_frame_command
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|args_info
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|print_frame_arg_vars
name|PARAMS
argument_list|(
operator|(
name|FRAME
operator|,
name|FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|catch_info
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|locals_info
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|print_frame_label_vars
name|PARAMS
argument_list|(
operator|(
name|FRAME
operator|,
name|int
operator|,
name|FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|print_frame_local_vars
name|PARAMS
argument_list|(
operator|(
name|FRAME
operator|,
name|FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|print_block_frame_labels
name|PARAMS
argument_list|(
operator|(
expr|struct
name|block
operator|*
operator|,
name|int
operator|*
operator|,
name|FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|print_block_frame_locals
name|PARAMS
argument_list|(
operator|(
expr|struct
name|block
operator|*
operator|,
name|FRAME
operator|,
name|FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|backtrace_command
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|FRAME
name|parse_frame_specification
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|frame_info
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|addressprint
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Print addresses, or stay symbolic only? */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|info_verbose
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Verbosity of symbol reading msgs */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|lines_to_list
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* # of lines "list" command shows by default */
end_comment

begin_comment
comment|/* The "selected" stack frame is used by default for local and arg access.    May be zero, for no selected frame.  */
end_comment

begin_decl_stmt
name|FRAME
name|selected_frame
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Level of the selected frame:    0 for innermost, 1 for its caller, ...    or -1 for frame specified by address with no defined level.  */
end_comment

begin_decl_stmt
name|int
name|selected_frame_level
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means print the full filename and linenumber    when a frame is printed, and do so in a format programs can parse.  */
end_comment

begin_decl_stmt
name|int
name|frame_file_full_name
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Negative says don't print source line in print_frame_info if    SOURCE argument is -1.  (Useful for a 'stepi' replacement that    does "x/i $pc" or when running xgdb.) */
end_comment

begin_decl_stmt
name|int
name|print_source_at_stop
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|info_printsource
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Print a stack frame briefly.  FRAME should be the frame id    and LEVEL should be its level in the stack (or -1 for level not defined).    This prints the level, the function executing, the arguments,    and the file name and line number.    If the pc is not at the beginning of the source line,    the actual pc is printed at the beginning.     If SOURCE is 1, print the source line as well.    If SOURCE is -1, print ONLY the source line.  */
end_comment

begin_function
name|void
name|print_stack_frame
parameter_list|(
name|frame
parameter_list|,
name|level
parameter_list|,
name|source
parameter_list|)
name|FRAME
name|frame
decl_stmt|;
name|int
name|level
decl_stmt|;
name|int
name|source
decl_stmt|;
block|{
name|struct
name|frame_info
modifier|*
name|fi
decl_stmt|;
name|fi
operator|=
name|get_frame_info
argument_list|(
name|frame
argument_list|)
expr_stmt|;
name|print_frame_info
argument_list|(
name|fi
argument_list|,
name|level
argument_list|,
name|source
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|print_frame_info
parameter_list|(
name|fi
parameter_list|,
name|level
parameter_list|,
name|source
parameter_list|,
name|args
parameter_list|)
name|struct
name|frame_info
modifier|*
name|fi
decl_stmt|;
specifier|register
name|int
name|level
decl_stmt|;
name|int
name|source
decl_stmt|;
name|int
name|args
decl_stmt|;
block|{
name|struct
name|symtab_and_line
name|sal
decl_stmt|;
name|struct
name|symbol
modifier|*
name|func
decl_stmt|;
specifier|register
name|char
modifier|*
name|funname
init|=
literal|0
decl_stmt|;
name|int
name|numargs
decl_stmt|;
if|#
directive|if
literal|0
comment|/* Symbol reading is fast enough now */
block|struct partial_symtab *pst;
comment|/* Don't give very much information if we haven't readin the      symbol table yet.  */
block|pst = find_pc_psymtab (fi->pc);   if (pst&& !pst->readin)     {
comment|/* Abbreviated information.  */
block|char *fname;        if (!find_pc_partial_function (fi->pc,&fname, 0)) 	fname = "??"; 	       printf_filtered ("#%-2d ", level);       if (addressprint)         printf_filtered ("%s in ", local_hex_string(fi->pc));        fputs_demangled (fname, stdout, 0);       fputs_filtered (" (...)\n", stdout);              return;     }
endif|#
directive|endif
ifdef|#
directive|ifdef
name|CORE_NEEDS_RELOCATION
name|CORE_NEEDS_RELOCATION
argument_list|(
name|fi
operator|->
name|pc
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|sal
operator|=
name|find_pc_line
argument_list|(
name|fi
operator|->
name|pc
argument_list|,
name|fi
operator|->
name|next_frame
argument_list|)
expr_stmt|;
name|func
operator|=
name|find_pc_function
argument_list|(
name|fi
operator|->
name|pc
argument_list|)
expr_stmt|;
if|if
condition|(
name|func
condition|)
block|{
comment|/* In certain pathological cases, the symtabs give the wrong 	 function (when we are in the first function in a file which 	 is compiled without debugging symbols, the previous function 	 is compiled with debugging symbols, and the "foo.o" symbol 	 that is supposed to tell us where the file with debugging symbols 	 ends has been truncated by ar because it is longer than 15 	 characters).  	 So look in the minimal symbol tables as well, and if it comes 	 up with a larger address for the function use that instead. 	 I don't think this can ever cause any problems; there shouldn't 	 be any minimal symbols in the middle of a function. 	 FIXME:  (Not necessarily true.  What about text labels) */
name|struct
name|minimal_symbol
modifier|*
name|msymbol
init|=
name|lookup_minimal_symbol_by_pc
argument_list|(
name|fi
operator|->
name|pc
argument_list|)
decl_stmt|;
if|if
condition|(
name|msymbol
operator|!=
name|NULL
operator|&&
operator|(
name|msymbol
operator|->
name|address
operator|>
name|BLOCK_START
argument_list|(
name|SYMBOL_BLOCK_VALUE
argument_list|(
name|func
argument_list|)
argument_list|)
operator|)
condition|)
block|{
comment|/* In this case we have no way of knowing the source file 	     and line number, so don't print them.  */
name|sal
operator|.
name|symtab
operator|=
literal|0
expr_stmt|;
comment|/* We also don't know anything about the function besides 	     its address and name.  */
name|func
operator|=
literal|0
expr_stmt|;
name|funname
operator|=
name|msymbol
operator|->
name|name
expr_stmt|;
block|}
else|else
name|funname
operator|=
name|SYMBOL_NAME
argument_list|(
name|func
argument_list|)
expr_stmt|;
block|}
else|else
block|{
specifier|register
name|struct
name|minimal_symbol
modifier|*
name|msymbol
init|=
name|lookup_minimal_symbol_by_pc
argument_list|(
name|fi
operator|->
name|pc
argument_list|)
decl_stmt|;
if|if
condition|(
name|msymbol
operator|!=
name|NULL
condition|)
name|funname
operator|=
name|msymbol
operator|->
name|name
expr_stmt|;
block|}
if|if
condition|(
name|source
operator|>=
literal|0
operator|||
operator|!
name|sal
operator|.
name|symtab
condition|)
block|{
if|if
condition|(
name|level
operator|>=
literal|0
condition|)
name|printf_filtered
argument_list|(
literal|"#%-2d "
argument_list|,
name|level
argument_list|)
expr_stmt|;
if|if
condition|(
name|addressprint
condition|)
if|if
condition|(
name|fi
operator|->
name|pc
operator|!=
name|sal
operator|.
name|pc
operator|||
operator|!
name|sal
operator|.
name|symtab
condition|)
name|printf_filtered
argument_list|(
literal|"%s in "
argument_list|,
name|local_hex_string
argument_list|(
name|fi
operator|->
name|pc
argument_list|)
argument_list|)
expr_stmt|;
name|fputs_demangled
argument_list|(
name|funname
condition|?
name|funname
else|:
literal|"??"
argument_list|,
name|stdout
argument_list|,
literal|0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|notdef
comment|/* Steve McCanne doesn't like this. */
name|wrap_here
argument_list|(
literal|"   "
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|fputs_filtered
argument_list|(
literal|" ("
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
name|args
condition|)
block|{
name|FRAME_NUM_ARGS
argument_list|(
name|numargs
argument_list|,
name|fi
argument_list|)
expr_stmt|;
name|print_frame_args
argument_list|(
name|func
argument_list|,
name|fi
argument_list|,
name|numargs
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
block|}
name|printf_filtered
argument_list|(
literal|")"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sal
operator|.
name|symtab
operator|&&
name|sal
operator|.
name|symtab
operator|->
name|filename
condition|)
block|{
name|wrap_here
argument_list|(
literal|"   "
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|" at %s:%d"
argument_list|,
name|sal
operator|.
name|symtab
operator|->
name|filename
argument_list|,
name|sal
operator|.
name|line
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|PC_LOAD_SEGMENT
comment|/* If we couldn't print out function name but if can figure out what         load segment this pc value is from, at least print out some info 	about its load segment. */
if|if
condition|(
operator|!
name|funname
condition|)
block|{
name|wrap_here
argument_list|(
literal|"  "
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|" from %s"
argument_list|,
name|PC_LOAD_SEGMENT
argument_list|(
name|fi
operator|->
name|pc
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|printf_filtered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|source
operator|!=
literal|0
operator|)
operator|&&
name|sal
operator|.
name|symtab
condition|)
block|{
if|if
condition|(
name|source
operator|>
literal|0
operator|||
name|print_source_at_stop
operator|>=
literal|0
condition|)
block|{
name|int
name|done
init|=
literal|0
decl_stmt|;
name|int
name|mid_statement
init|=
name|source
operator|<
literal|0
operator|&&
name|fi
operator|->
name|pc
operator|!=
name|sal
operator|.
name|pc
decl_stmt|;
if|if
condition|(
name|frame_file_full_name
condition|)
name|done
operator|=
name|identify_source_line
argument_list|(
name|sal
operator|.
name|symtab
argument_list|,
name|sal
operator|.
name|line
argument_list|,
name|mid_statement
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|done
condition|)
block|{
if|if
condition|(
name|addressprint
operator|&&
name|mid_statement
condition|)
name|printf_filtered
argument_list|(
literal|"%s\t"
argument_list|,
name|local_hex_string
argument_list|(
name|fi
operator|->
name|pc
argument_list|)
argument_list|)
expr_stmt|;
name|print_source_lines
argument_list|(
name|sal
operator|.
name|symtab
argument_list|,
name|sal
operator|.
name|line
argument_list|,
name|sal
operator|.
name|line
operator|+
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
name|current_source_line
operator|=
name|max
argument_list|(
name|sal
operator|.
name|line
operator|-
name|lines_to_list
operator|/
literal|2
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|source
operator|!=
literal|0
condition|)
name|set_default_breakpoint
argument_list|(
literal|1
argument_list|,
name|fi
operator|->
name|pc
argument_list|,
name|sal
operator|.
name|symtab
argument_list|,
name|sal
operator|.
name|line
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|FRAME_SPECIFICATION_DYADIC
end_ifdef

begin_function_decl
specifier|extern
name|FRAME
name|setup_arbitrary_frame
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Read a frame specification in whatever the appropriate format is.  * Call error() if the specification is in any way invalid (i.e.  * this function never returns NULL).  */
end_comment

begin_function
specifier|static
name|FRAME
name|parse_frame_specification
parameter_list|(
name|frame_exp
parameter_list|)
name|char
modifier|*
name|frame_exp
decl_stmt|;
block|{
name|int
name|numargs
init|=
literal|0
decl_stmt|;
name|int
name|arg1
decl_stmt|,
name|arg2
decl_stmt|;
if|if
condition|(
name|frame_exp
condition|)
block|{
name|char
modifier|*
name|addr_string
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|tmp_cleanup
decl_stmt|;
while|while
condition|(
operator|*
name|frame_exp
operator|==
literal|' '
condition|)
name|frame_exp
operator|++
expr_stmt|;
for|for
control|(
name|p
operator|=
name|frame_exp
init|;
operator|*
name|p
operator|&&
operator|*
name|p
operator|!=
literal|' '
condition|;
name|p
operator|++
control|)
empty_stmt|;
if|if
condition|(
operator|*
name|frame_exp
condition|)
block|{
name|numargs
operator|=
literal|1
expr_stmt|;
name|addr_string
operator|=
name|savestring
argument_list|(
name|frame_exp
argument_list|,
name|p
operator|-
name|frame_exp
argument_list|)
expr_stmt|;
block|{
name|tmp_cleanup
operator|=
name|make_cleanup
argument_list|(
name|free
argument_list|,
name|addr_string
argument_list|)
expr_stmt|;
name|arg1
operator|=
name|parse_and_eval_address
argument_list|(
name|addr_string
argument_list|)
expr_stmt|;
name|do_cleanups
argument_list|(
name|tmp_cleanup
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
operator|*
name|p
operator|==
literal|' '
condition|)
name|p
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|p
condition|)
block|{
name|numargs
operator|=
literal|2
expr_stmt|;
name|arg2
operator|=
name|parse_and_eval_address
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
block|}
block|}
switch|switch
condition|(
name|numargs
condition|)
block|{
case|case
literal|0
case|:
if|if
condition|(
name|selected_frame
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|"No selected frame."
argument_list|)
expr_stmt|;
return|return
name|selected_frame
return|;
comment|/* NOTREACHED */
case|case
literal|1
case|:
block|{
name|int
name|level
init|=
name|arg1
decl_stmt|;
name|FRAME
name|fid
init|=
name|find_relative_frame
argument_list|(
name|get_current_frame
argument_list|()
argument_list|,
operator|&
name|level
argument_list|)
decl_stmt|;
name|FRAME
name|tfid
decl_stmt|;
if|if
condition|(
name|level
operator|==
literal|0
condition|)
comment|/* find_relative_frame was successful */
return|return
name|fid
return|;
comment|/* If (s)he specifies the frame with an address, he deserves what 	   (s)he gets.  Still, give the highest one that matches.  */
for|for
control|(
name|fid
operator|=
name|get_current_frame
argument_list|()
init|;
name|fid
operator|&&
name|FRAME_FP
argument_list|(
name|fid
argument_list|)
operator|!=
name|arg1
condition|;
name|fid
operator|=
name|get_prev_frame
argument_list|(
name|fid
argument_list|)
control|)
empty_stmt|;
if|if
condition|(
name|fid
condition|)
while|while
condition|(
operator|(
name|tfid
operator|=
name|get_prev_frame
argument_list|(
name|fid
argument_list|)
operator|)
operator|&&
operator|(
name|FRAME_FP
argument_list|(
name|tfid
argument_list|)
operator|==
name|arg1
operator|)
condition|)
name|fid
operator|=
name|tfid
expr_stmt|;
ifdef|#
directive|ifdef
name|FRAME_SPECIFICATION_DYADIC
if|if
condition|(
operator|!
name|fid
condition|)
name|error
argument_list|(
literal|"Incorrect number of args in frame specification"
argument_list|)
expr_stmt|;
return|return
name|fid
return|;
else|#
directive|else
return|return
name|create_new_frame
argument_list|(
name|arg1
argument_list|,
literal|0
argument_list|)
return|;
endif|#
directive|endif
block|}
comment|/* NOTREACHED */
case|case
literal|2
case|:
comment|/* Must be addresses */
ifndef|#
directive|ifndef
name|FRAME_SPECIFICATION_DYADIC
name|error
argument_list|(
literal|"Incorrect number of args in frame specification"
argument_list|)
expr_stmt|;
else|#
directive|else
return|return
name|setup_arbitrary_frame
argument_list|(
name|arg1
argument_list|,
name|arg2
argument_list|)
return|;
endif|#
directive|endif
comment|/* NOTREACHED */
block|}
name|fatal
argument_list|(
literal|"Internal: Error in parsing in parse_frame_specification"
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
end_function

begin_comment
comment|/* FRAME_ARGS_ADDRESS_CORRECT is just like FRAME_ARGS_ADDRESS except    that if it is unsure about the answer, it returns 0    instead of guessing (this happens on the VAX and i960, for example).     On most machines, we never have to guess about the args address,    so FRAME_ARGS_ADDRESS{,_CORRECT} are the same.  */
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|FRAME_ARGS_ADDRESS_CORRECT
argument_list|)
end_if

begin_define
define|#
directive|define
name|FRAME_ARGS_ADDRESS_CORRECT
value|FRAME_ARGS_ADDRESS
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Print verbosely the selected frame or the frame at address ADDR.    This means absolutely all information in the frame is printed.  */
end_comment

begin_function
specifier|static
name|void
name|frame_info
parameter_list|(
name|addr_exp
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|addr_exp
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|FRAME
name|frame
decl_stmt|;
name|struct
name|frame_info
modifier|*
name|fi
decl_stmt|;
name|struct
name|frame_saved_regs
name|fsr
decl_stmt|;
name|struct
name|symtab_and_line
name|sal
decl_stmt|;
name|struct
name|symbol
modifier|*
name|func
decl_stmt|;
name|struct
name|symtab
modifier|*
name|s
decl_stmt|;
name|FRAME
name|calling_frame
decl_stmt|;
name|int
name|i
decl_stmt|,
name|count
decl_stmt|;
name|char
modifier|*
name|funname
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|target_has_stack
condition|)
name|error
argument_list|(
literal|"No inferior or core file."
argument_list|)
expr_stmt|;
name|frame
operator|=
name|parse_frame_specification
argument_list|(
name|addr_exp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|frame
condition|)
name|error
argument_list|(
literal|"Invalid frame specified."
argument_list|)
expr_stmt|;
name|fi
operator|=
name|get_frame_info
argument_list|(
name|frame
argument_list|)
expr_stmt|;
name|sal
operator|=
name|find_pc_line
argument_list|(
name|fi
operator|->
name|pc
argument_list|,
name|fi
operator|->
name|next_frame
argument_list|)
expr_stmt|;
name|func
operator|=
name|get_frame_function
argument_list|(
name|frame
argument_list|)
expr_stmt|;
name|s
operator|=
name|find_pc_symtab
argument_list|(
name|fi
operator|->
name|pc
argument_list|)
expr_stmt|;
if|if
condition|(
name|func
condition|)
name|funname
operator|=
name|SYMBOL_NAME
argument_list|(
name|func
argument_list|)
expr_stmt|;
else|else
block|{
specifier|register
name|struct
name|minimal_symbol
modifier|*
name|msymbol
init|=
name|lookup_minimal_symbol_by_pc
argument_list|(
name|fi
operator|->
name|pc
argument_list|)
decl_stmt|;
if|if
condition|(
name|msymbol
operator|!=
name|NULL
condition|)
name|funname
operator|=
name|msymbol
operator|->
name|name
expr_stmt|;
block|}
name|calling_frame
operator|=
name|get_prev_frame
argument_list|(
name|frame
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|addr_exp
operator|&&
name|selected_frame_level
operator|>=
literal|0
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"Stack level %d, frame at %s:\n"
argument_list|,
name|selected_frame_level
argument_list|,
name|local_hex_string
argument_list|(
name|FRAME_FP
argument_list|(
name|frame
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf_filtered
argument_list|(
literal|"Stack frame at %s:\n"
argument_list|,
name|local_hex_string
argument_list|(
name|FRAME_FP
argument_list|(
name|frame
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|printf_filtered
argument_list|(
literal|" %s = %s"
argument_list|,
name|reg_names
index|[
name|PC_REGNUM
index|]
argument_list|,
name|local_hex_string
argument_list|(
name|fi
operator|->
name|pc
argument_list|)
argument_list|)
expr_stmt|;
name|wrap_here
argument_list|(
literal|"   "
argument_list|)
expr_stmt|;
if|if
condition|(
name|funname
condition|)
block|{
name|printf_filtered
argument_list|(
literal|" in "
argument_list|)
expr_stmt|;
name|fputs_demangled
argument_list|(
name|funname
argument_list|,
name|stdout
argument_list|,
name|DMGL_ANSI
operator||
name|DMGL_PARAMS
argument_list|)
expr_stmt|;
block|}
name|wrap_here
argument_list|(
literal|"   "
argument_list|)
expr_stmt|;
if|if
condition|(
name|sal
operator|.
name|symtab
condition|)
name|printf_filtered
argument_list|(
literal|" (%s:%d)"
argument_list|,
name|sal
operator|.
name|symtab
operator|->
name|filename
argument_list|,
name|sal
operator|.
name|line
argument_list|)
expr_stmt|;
name|puts_filtered
argument_list|(
literal|"; "
argument_list|)
expr_stmt|;
name|wrap_here
argument_list|(
literal|"    "
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"saved %s %s\n"
argument_list|,
name|reg_names
index|[
name|PC_REGNUM
index|]
argument_list|,
name|local_hex_string
argument_list|(
name|FRAME_SAVED_PC
argument_list|(
name|frame
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|{
name|int
name|frameless
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|FRAMELESS_FUNCTION_INVOCATION
name|FRAMELESS_FUNCTION_INVOCATION
argument_list|(
name|fi
argument_list|,
name|frameless
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|frameless
condition|)
name|printf_filtered
argument_list|(
literal|" (FRAMELESS),"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|calling_frame
condition|)
name|printf_filtered
argument_list|(
literal|" called by frame at %s"
argument_list|,
name|local_hex_string
argument_list|(
name|FRAME_FP
argument_list|(
name|calling_frame
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fi
operator|->
name|next_frame
operator|&&
name|calling_frame
condition|)
name|puts_filtered
argument_list|(
literal|","
argument_list|)
expr_stmt|;
name|wrap_here
argument_list|(
literal|"   "
argument_list|)
expr_stmt|;
if|if
condition|(
name|fi
operator|->
name|next_frame
condition|)
name|printf_filtered
argument_list|(
literal|" caller of frame at %s"
argument_list|,
name|local_hex_string
argument_list|(
name|fi
operator|->
name|next_frame
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fi
operator|->
name|next_frame
operator|||
name|calling_frame
condition|)
name|puts_filtered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
condition|)
name|printf_filtered
argument_list|(
literal|" source language %s.\n"
argument_list|,
name|language_str
argument_list|(
name|s
operator|->
name|language
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PRINT_EXTRA_FRAME_INFO
name|PRINT_EXTRA_FRAME_INFO
argument_list|(
name|fi
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|{
comment|/* Address of the argument list for this frame, or 0.  */
name|CORE_ADDR
name|arg_list
init|=
name|FRAME_ARGS_ADDRESS_CORRECT
argument_list|(
name|fi
argument_list|)
decl_stmt|;
comment|/* Number of args for this frame, or -1 if unknown.  */
name|int
name|numargs
decl_stmt|;
if|if
condition|(
name|arg_list
operator|==
literal|0
condition|)
name|printf_filtered
argument_list|(
literal|" Arglist at unknown address.\n"
argument_list|)
expr_stmt|;
else|else
block|{
name|printf_filtered
argument_list|(
literal|" Arglist at %s,"
argument_list|,
name|local_hex_string
argument_list|(
name|arg_list
argument_list|)
argument_list|)
expr_stmt|;
name|FRAME_NUM_ARGS
argument_list|(
name|numargs
argument_list|,
name|fi
argument_list|)
expr_stmt|;
if|if
condition|(
name|numargs
operator|<
literal|0
condition|)
name|puts_filtered
argument_list|(
literal|" args: "
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|numargs
operator|==
literal|0
condition|)
name|puts_filtered
argument_list|(
literal|" no args."
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|numargs
operator|==
literal|1
condition|)
name|puts_filtered
argument_list|(
literal|" 1 arg: "
argument_list|)
expr_stmt|;
else|else
name|printf_filtered
argument_list|(
literal|" %d args: "
argument_list|,
name|numargs
argument_list|)
expr_stmt|;
name|print_frame_args
argument_list|(
name|func
argument_list|,
name|fi
argument_list|,
name|numargs
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|puts_filtered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
block|{
comment|/* Address of the local variables for this frame, or 0.  */
name|CORE_ADDR
name|arg_list
init|=
name|FRAME_LOCALS_ADDRESS
argument_list|(
name|fi
argument_list|)
decl_stmt|;
if|if
condition|(
name|arg_list
operator|==
literal|0
condition|)
name|printf_filtered
argument_list|(
literal|" Locals at unknown address,"
argument_list|)
expr_stmt|;
else|else
name|printf_filtered
argument_list|(
literal|" Locals at %s,"
argument_list|,
name|local_hex_string
argument_list|(
name|arg_list
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|FRAME_FIND_SAVED_REGS
argument_list|)
name|get_frame_saved_regs
argument_list|(
name|fi
argument_list|,
operator|&
name|fsr
argument_list|)
expr_stmt|;
comment|/* The sp is special; what's returned isn't the save address, but      actually the value of the previous frame's sp.  */
name|printf_filtered
argument_list|(
literal|" Previous frame's sp is %s\n"
argument_list|,
name|local_hex_string
argument_list|(
name|fsr
operator|.
name|regs
index|[
name|SP_REGNUM
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_REGS
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|fsr
operator|.
name|regs
index|[
name|i
index|]
operator|&&
name|i
operator|!=
name|SP_REGNUM
condition|)
block|{
if|if
condition|(
name|count
operator|==
literal|0
condition|)
name|puts_filtered
argument_list|(
literal|" Saved registers:\n "
argument_list|)
expr_stmt|;
else|else
name|puts_filtered
argument_list|(
literal|","
argument_list|)
expr_stmt|;
name|wrap_here
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|" %s at %s"
argument_list|,
name|reg_names
index|[
name|i
index|]
argument_list|,
name|local_hex_string
argument_list|(
name|fsr
operator|.
name|regs
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|count
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|count
condition|)
name|puts_filtered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Have FRAME_FIND_SAVED_REGS.  */
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* Set a limit on the number of frames printed by default in a    backtrace.  */
end_comment

begin_endif
unit|static int backtrace_limit;  static void set_backtrace_limit_command (count_exp, from_tty)      char *count_exp;      int from_tty; {   int count = parse_and_eval_address (count_exp);    if (count< 0)     error ("Negative argument not meaningful as backtrace limit.");    backtrace_limit = count; }  static void backtrace_limit_info (arg, from_tty)      char *arg;      int from_tty; {   if (arg)     error ("\"Info backtrace-limit\" takes no arguments.");    printf ("Backtrace limit: %d.\n", backtrace_limit); }
endif|#
directive|endif
end_endif

begin_comment
comment|/* Print briefly all stack frames or just the innermost COUNT frames.  */
end_comment

begin_function
specifier|static
name|void
name|backtrace_command
parameter_list|(
name|count_exp
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|count_exp
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|struct
name|frame_info
modifier|*
name|fi
decl_stmt|;
specifier|register
name|int
name|count
decl_stmt|;
specifier|register
name|FRAME
name|frame
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|FRAME
name|trailing
decl_stmt|;
specifier|register
name|int
name|trailing_level
decl_stmt|;
if|if
condition|(
operator|!
name|target_has_stack
condition|)
name|error
argument_list|(
literal|"No stack."
argument_list|)
expr_stmt|;
comment|/* The following code must do two things.  First, it must      set the variable TRAILING to the frame from which we should start      printing.  Second, it must set the variable count to the number      of frames which we should print, or -1 if all of them.  */
name|trailing
operator|=
name|get_current_frame
argument_list|()
expr_stmt|;
name|trailing_level
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|count_exp
condition|)
block|{
name|count
operator|=
name|parse_and_eval_address
argument_list|(
name|count_exp
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|<
literal|0
condition|)
block|{
name|FRAME
name|current
decl_stmt|;
name|count
operator|=
operator|-
name|count
expr_stmt|;
name|current
operator|=
name|trailing
expr_stmt|;
while|while
condition|(
name|current
operator|&&
name|count
operator|--
condition|)
block|{
name|QUIT
expr_stmt|;
name|current
operator|=
name|get_prev_frame
argument_list|(
name|current
argument_list|)
expr_stmt|;
block|}
comment|/* Will stop when CURRENT reaches the top of the stack.  TRAILING 	     will be COUNT below it.  */
while|while
condition|(
name|current
condition|)
block|{
name|QUIT
expr_stmt|;
name|trailing
operator|=
name|get_prev_frame
argument_list|(
name|trailing
argument_list|)
expr_stmt|;
name|current
operator|=
name|get_prev_frame
argument_list|(
name|current
argument_list|)
expr_stmt|;
name|trailing_level
operator|++
expr_stmt|;
block|}
name|count
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
else|else
name|count
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|info_verbose
condition|)
block|{
name|struct
name|partial_symtab
modifier|*
name|ps
decl_stmt|;
comment|/* Read in symbols for all of the frames.  Need to do this in 	 a separate pass so that "Reading in symbols for xxx" messages 	 don't screw up the appearance of the backtrace.  Also 	 if people have strong opinions against reading symbols for 	 backtrace this may have to be an option.  */
name|i
operator|=
name|count
expr_stmt|;
for|for
control|(
name|frame
operator|=
name|trailing
init|;
name|frame
operator|!=
name|NULL
operator|&&
name|i
operator|--
condition|;
name|frame
operator|=
name|get_prev_frame
argument_list|(
name|frame
argument_list|)
control|)
block|{
name|QUIT
expr_stmt|;
name|fi
operator|=
name|get_frame_info
argument_list|(
name|frame
argument_list|)
expr_stmt|;
name|ps
operator|=
name|find_pc_psymtab
argument_list|(
name|fi
operator|->
name|pc
argument_list|)
expr_stmt|;
if|if
condition|(
name|ps
condition|)
name|PSYMTAB_TO_SYMTAB
argument_list|(
name|ps
argument_list|)
expr_stmt|;
comment|/* Force syms to come in */
block|}
block|}
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|frame
operator|=
name|trailing
init|;
name|frame
operator|&&
name|count
operator|--
condition|;
name|i
operator|++
operator|,
name|frame
operator|=
name|get_prev_frame
argument_list|(
name|frame
argument_list|)
control|)
block|{
name|QUIT
expr_stmt|;
name|fi
operator|=
name|get_frame_info
argument_list|(
name|frame
argument_list|)
expr_stmt|;
name|print_frame_info
argument_list|(
name|fi
argument_list|,
name|trailing_level
operator|+
name|i
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* If we've stopped before the end, mention that.  */
if|if
condition|(
name|frame
operator|&&
name|from_tty
condition|)
name|printf_filtered
argument_list|(
literal|"(More stack frames follow...)\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Print the local variables of a block B active in FRAME.    Return 1 if any variables were printed; 0 otherwise.  */
end_comment

begin_function
specifier|static
name|int
name|print_block_frame_locals
parameter_list|(
name|b
parameter_list|,
name|frame
parameter_list|,
name|stream
parameter_list|)
name|struct
name|block
modifier|*
name|b
decl_stmt|;
specifier|register
name|FRAME
name|frame
decl_stmt|;
specifier|register
name|FILE
modifier|*
name|stream
decl_stmt|;
block|{
name|int
name|nsyms
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|struct
name|symbol
modifier|*
name|sym
decl_stmt|;
specifier|register
name|int
name|values_printed
init|=
literal|0
decl_stmt|;
name|nsyms
operator|=
name|BLOCK_NSYMS
argument_list|(
name|b
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nsyms
condition|;
name|i
operator|++
control|)
block|{
name|sym
operator|=
name|BLOCK_SYM
argument_list|(
name|b
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|==
name|LOC_LOCAL
operator|||
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|==
name|LOC_REGISTER
operator|||
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|==
name|LOC_STATIC
condition|)
block|{
name|values_printed
operator|=
literal|1
expr_stmt|;
name|fprint_symbol
argument_list|(
name|stream
argument_list|,
name|SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
literal|" = "
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|print_variable_value
argument_list|(
name|sym
argument_list|,
name|frame
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|values_printed
return|;
block|}
end_function

begin_comment
comment|/* Same, but print labels.  */
end_comment

begin_function
specifier|static
name|int
name|print_block_frame_labels
parameter_list|(
name|b
parameter_list|,
name|have_default
parameter_list|,
name|stream
parameter_list|)
name|struct
name|block
modifier|*
name|b
decl_stmt|;
name|int
modifier|*
name|have_default
decl_stmt|;
specifier|register
name|FILE
modifier|*
name|stream
decl_stmt|;
block|{
name|int
name|nsyms
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|struct
name|symbol
modifier|*
name|sym
decl_stmt|;
specifier|register
name|int
name|values_printed
init|=
literal|0
decl_stmt|;
name|nsyms
operator|=
name|BLOCK_NSYMS
argument_list|(
name|b
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nsyms
condition|;
name|i
operator|++
control|)
block|{
name|sym
operator|=
name|BLOCK_SYM
argument_list|(
name|b
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
argument_list|,
literal|"default"
argument_list|)
condition|)
block|{
if|if
condition|(
operator|*
name|have_default
condition|)
continue|continue;
operator|*
name|have_default
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|==
name|LOC_LABEL
condition|)
block|{
name|struct
name|symtab_and_line
name|sal
decl_stmt|;
name|sal
operator|=
name|find_pc_line
argument_list|(
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|sym
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|values_printed
operator|=
literal|1
expr_stmt|;
name|fputs_demangled
argument_list|(
name|SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
argument_list|,
name|stream
argument_list|,
name|DMGL_ANSI
operator||
name|DMGL_PARAMS
argument_list|)
expr_stmt|;
if|if
condition|(
name|addressprint
condition|)
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|" %s"
argument_list|,
name|local_hex_string
argument_list|(
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|sym
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|" in file %s, line %d\n"
argument_list|,
name|sal
operator|.
name|symtab
operator|->
name|filename
argument_list|,
name|sal
operator|.
name|line
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|values_printed
return|;
block|}
end_function

begin_comment
comment|/* Print on STREAM all the local variables in frame FRAME,    including all the blocks active in that frame    at its current pc.     Returns 1 if the job was done,    or 0 if nothing was printed because we have no info    on the function running in FRAME.  */
end_comment

begin_function
specifier|static
name|void
name|print_frame_local_vars
parameter_list|(
name|frame
parameter_list|,
name|stream
parameter_list|)
specifier|register
name|FRAME
name|frame
decl_stmt|;
specifier|register
name|FILE
modifier|*
name|stream
decl_stmt|;
block|{
specifier|register
name|struct
name|block
modifier|*
name|block
init|=
name|get_frame_block
argument_list|(
name|frame
argument_list|)
decl_stmt|;
specifier|register
name|int
name|values_printed
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|block
operator|==
literal|0
condition|)
block|{
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"No symbol table info available.\n"
argument_list|)
expr_stmt|;
return|return;
block|}
while|while
condition|(
name|block
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|print_block_frame_locals
argument_list|(
name|block
argument_list|,
name|frame
argument_list|,
name|stream
argument_list|)
condition|)
name|values_printed
operator|=
literal|1
expr_stmt|;
comment|/* After handling the function's top-level block, stop. 	 Don't continue to its superblock, the block of 	 per-file symbols.  */
if|if
condition|(
name|BLOCK_FUNCTION
argument_list|(
name|block
argument_list|)
condition|)
break|break;
name|block
operator|=
name|BLOCK_SUPERBLOCK
argument_list|(
name|block
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|values_printed
condition|)
block|{
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"No locals.\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Same, but print labels.  */
end_comment

begin_function
specifier|static
name|void
name|print_frame_label_vars
parameter_list|(
name|frame
parameter_list|,
name|this_level_only
parameter_list|,
name|stream
parameter_list|)
specifier|register
name|FRAME
name|frame
decl_stmt|;
name|int
name|this_level_only
decl_stmt|;
specifier|register
name|FILE
modifier|*
name|stream
decl_stmt|;
block|{
specifier|register
name|struct
name|blockvector
modifier|*
name|bl
decl_stmt|;
specifier|register
name|struct
name|block
modifier|*
name|block
init|=
name|get_frame_block
argument_list|(
name|frame
argument_list|)
decl_stmt|;
specifier|register
name|int
name|values_printed
init|=
literal|0
decl_stmt|;
name|int
name|index
decl_stmt|,
name|have_default
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|blocks_printed
decl_stmt|;
name|struct
name|frame_info
modifier|*
name|fi
init|=
name|get_frame_info
argument_list|(
name|frame
argument_list|)
decl_stmt|;
name|CORE_ADDR
name|pc
init|=
name|fi
operator|->
name|pc
decl_stmt|;
if|if
condition|(
name|block
operator|==
literal|0
condition|)
block|{
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"No symbol table info available.\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|bl
operator|=
name|blockvector_for_pc
argument_list|(
name|BLOCK_END
argument_list|(
name|block
argument_list|)
operator|-
literal|4
argument_list|,
operator|&
name|index
argument_list|)
expr_stmt|;
name|blocks_printed
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|BLOCKVECTOR_NBLOCKS
argument_list|(
name|bl
argument_list|)
operator|*
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|blocks_printed
argument_list|,
literal|0
argument_list|,
name|BLOCKVECTOR_NBLOCKS
argument_list|(
name|bl
argument_list|)
operator|*
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|block
operator|!=
literal|0
condition|)
block|{
name|CORE_ADDR
name|end
init|=
name|BLOCK_END
argument_list|(
name|block
argument_list|)
operator|-
literal|4
decl_stmt|;
name|int
name|last_index
decl_stmt|;
if|if
condition|(
name|bl
operator|!=
name|blockvector_for_pc
argument_list|(
name|end
argument_list|,
operator|&
name|index
argument_list|)
condition|)
name|error
argument_list|(
literal|"blockvector blotch"
argument_list|)
expr_stmt|;
if|if
condition|(
name|BLOCKVECTOR_BLOCK
argument_list|(
name|bl
argument_list|,
name|index
argument_list|)
operator|!=
name|block
condition|)
name|error
argument_list|(
literal|"blockvector botch"
argument_list|)
expr_stmt|;
name|last_index
operator|=
name|BLOCKVECTOR_NBLOCKS
argument_list|(
name|bl
argument_list|)
expr_stmt|;
name|index
operator|+=
literal|1
expr_stmt|;
comment|/* Don't print out blocks that have gone by.  */
while|while
condition|(
name|index
operator|<
name|last_index
operator|&&
name|BLOCK_END
argument_list|(
name|BLOCKVECTOR_BLOCK
argument_list|(
name|bl
argument_list|,
name|index
argument_list|)
argument_list|)
operator|<
name|pc
condition|)
name|index
operator|++
expr_stmt|;
while|while
condition|(
name|index
operator|<
name|last_index
operator|&&
name|BLOCK_END
argument_list|(
name|BLOCKVECTOR_BLOCK
argument_list|(
name|bl
argument_list|,
name|index
argument_list|)
argument_list|)
operator|<
name|end
condition|)
block|{
if|if
condition|(
name|blocks_printed
index|[
name|index
index|]
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|print_block_frame_labels
argument_list|(
name|BLOCKVECTOR_BLOCK
argument_list|(
name|bl
argument_list|,
name|index
argument_list|)
argument_list|,
operator|&
name|have_default
argument_list|,
name|stream
argument_list|)
condition|)
name|values_printed
operator|=
literal|1
expr_stmt|;
name|blocks_printed
index|[
name|index
index|]
operator|=
literal|1
expr_stmt|;
block|}
name|index
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|have_default
condition|)
return|return;
if|if
condition|(
name|values_printed
operator|&&
name|this_level_only
condition|)
return|return;
comment|/* After handling the function's top-level block, stop. 	 Don't continue to its superblock, the block of 	 per-file symbols.  */
if|if
condition|(
name|BLOCK_FUNCTION
argument_list|(
name|block
argument_list|)
condition|)
break|break;
name|block
operator|=
name|BLOCK_SUPERBLOCK
argument_list|(
name|block
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|values_printed
operator|&&
operator|!
name|this_level_only
condition|)
block|{
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"No catches.\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|void
name|locals_info
parameter_list|(
name|args
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|selected_frame
condition|)
name|error
argument_list|(
literal|"No frame selected."
argument_list|)
expr_stmt|;
name|print_frame_local_vars
argument_list|(
name|selected_frame
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|catch_info
parameter_list|(
name|ignore
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|ignore
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|selected_frame
condition|)
name|error
argument_list|(
literal|"No frame selected."
argument_list|)
expr_stmt|;
name|print_frame_label_vars
argument_list|(
name|selected_frame
argument_list|,
literal|0
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|print_frame_arg_vars
parameter_list|(
name|frame
parameter_list|,
name|stream
parameter_list|)
specifier|register
name|FRAME
name|frame
decl_stmt|;
specifier|register
name|FILE
modifier|*
name|stream
decl_stmt|;
block|{
name|struct
name|symbol
modifier|*
name|func
init|=
name|get_frame_function
argument_list|(
name|frame
argument_list|)
decl_stmt|;
specifier|register
name|struct
name|block
modifier|*
name|b
decl_stmt|;
name|int
name|nsyms
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|struct
name|symbol
modifier|*
name|sym
decl_stmt|,
modifier|*
name|sym2
decl_stmt|;
specifier|register
name|int
name|values_printed
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|func
operator|==
literal|0
condition|)
block|{
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"No symbol table info available.\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|b
operator|=
name|SYMBOL_BLOCK_VALUE
argument_list|(
name|func
argument_list|)
expr_stmt|;
name|nsyms
operator|=
name|BLOCK_NSYMS
argument_list|(
name|b
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nsyms
condition|;
name|i
operator|++
control|)
block|{
name|sym
operator|=
name|BLOCK_SYM
argument_list|(
name|b
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|==
name|LOC_ARG
operator|||
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|==
name|LOC_LOCAL_ARG
operator|||
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|==
name|LOC_REF_ARG
operator|||
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|==
name|LOC_REGPARM
condition|)
block|{
name|values_printed
operator|=
literal|1
expr_stmt|;
name|fprint_symbol
argument_list|(
name|stream
argument_list|,
name|SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
literal|" = "
argument_list|,
name|stream
argument_list|)
expr_stmt|;
comment|/* We have to look up the symbol because arguments often have 	     two entries (one a parameter, one a register) and the one 	     we want is the register, which lookup_symbol will find for 	     us.  */
name|sym2
operator|=
name|lookup_symbol
argument_list|(
name|SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
argument_list|,
name|b
argument_list|,
name|VAR_NAMESPACE
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|,
operator|(
expr|struct
name|symtab
operator|*
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|print_variable_value
argument_list|(
name|sym2
argument_list|,
name|frame
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|values_printed
condition|)
block|{
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"No arguments.\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|args_info
parameter_list|(
name|ignore
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|ignore
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|selected_frame
condition|)
name|error
argument_list|(
literal|"No frame selected."
argument_list|)
expr_stmt|;
name|print_frame_arg_vars
argument_list|(
name|selected_frame
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Select frame FRAME, and note that its stack level is LEVEL.    LEVEL may be -1 if an actual level number is not known.  */
end_comment

begin_function
name|void
name|select_frame
parameter_list|(
name|frame
parameter_list|,
name|level
parameter_list|)
name|FRAME
name|frame
decl_stmt|;
name|int
name|level
decl_stmt|;
block|{
specifier|register
name|struct
name|symtab
modifier|*
name|s
decl_stmt|;
name|selected_frame
operator|=
name|frame
expr_stmt|;
name|selected_frame_level
operator|=
name|level
expr_stmt|;
comment|/* Ensure that symbols for this frame are read in.  Also, determine the      source language of this frame, and switch to it if desired.  */
if|if
condition|(
name|frame
condition|)
block|{
name|s
operator|=
name|find_pc_symtab
argument_list|(
name|get_frame_info
argument_list|(
name|frame
argument_list|)
operator|->
name|pc
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|&&
name|s
operator|->
name|language
operator|!=
name|current_language
operator|->
name|la_language
operator|&&
name|s
operator|->
name|language
operator|!=
name|language_unknown
operator|&&
name|language_mode
operator|==
name|language_mode_auto
condition|)
block|{
name|set_language
argument_list|(
name|s
operator|->
name|language
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Store the selected frame and its level into *FRAMEP and *LEVELP.    If there is no selected frame, *FRAMEP is set to NULL.  */
end_comment

begin_function
name|void
name|record_selected_frame
parameter_list|(
name|frameaddrp
parameter_list|,
name|levelp
parameter_list|)
name|FRAME_ADDR
modifier|*
name|frameaddrp
decl_stmt|;
name|int
modifier|*
name|levelp
decl_stmt|;
block|{
operator|*
name|frameaddrp
operator|=
name|selected_frame
condition|?
name|FRAME_FP
argument_list|(
name|selected_frame
argument_list|)
else|:
literal|0
expr_stmt|;
operator|*
name|levelp
operator|=
name|selected_frame_level
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return the symbol-block in which the selected frame is executing.    Can return zero under various legitimate circumstances.  */
end_comment

begin_function
name|struct
name|block
modifier|*
name|get_selected_block
parameter_list|()
block|{
if|if
condition|(
operator|!
name|target_has_stack
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|selected_frame
condition|)
return|return
name|get_current_block
argument_list|()
return|;
return|return
name|get_frame_block
argument_list|(
name|selected_frame
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Find a frame a certain number of levels away from FRAME.    LEVEL_OFFSET_PTR points to an int containing the number of levels.    Positive means go to earlier frames (up); negative, the reverse.    The int that contains the number of levels is counted toward    zero as the frames for those levels are found.    If the top or bottom frame is reached, that frame is returned,    but the final value of *LEVEL_OFFSET_PTR is nonzero and indicates    how much farther the original request asked to go.  */
end_comment

begin_function
name|FRAME
name|find_relative_frame
parameter_list|(
name|frame
parameter_list|,
name|level_offset_ptr
parameter_list|)
specifier|register
name|FRAME
name|frame
decl_stmt|;
specifier|register
name|int
modifier|*
name|level_offset_ptr
decl_stmt|;
block|{
specifier|register
name|FRAME
name|prev
decl_stmt|;
specifier|register
name|FRAME
name|frame1
decl_stmt|;
comment|/* Going up is simple: just do get_prev_frame enough times      or until initial frame is reached.  */
while|while
condition|(
operator|*
name|level_offset_ptr
operator|>
literal|0
condition|)
block|{
name|prev
operator|=
name|get_prev_frame
argument_list|(
name|frame
argument_list|)
expr_stmt|;
if|if
condition|(
name|prev
operator|==
literal|0
condition|)
break|break;
operator|(
operator|*
name|level_offset_ptr
operator|)
operator|--
expr_stmt|;
name|frame
operator|=
name|prev
expr_stmt|;
block|}
comment|/* Going down is just as simple.  */
if|if
condition|(
operator|*
name|level_offset_ptr
operator|<
literal|0
condition|)
block|{
while|while
condition|(
operator|*
name|level_offset_ptr
operator|<
literal|0
condition|)
block|{
name|frame1
operator|=
name|get_next_frame
argument_list|(
name|frame
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|frame1
condition|)
break|break;
name|frame
operator|=
name|frame1
expr_stmt|;
operator|(
operator|*
name|level_offset_ptr
operator|)
operator|++
expr_stmt|;
block|}
block|}
return|return
name|frame
return|;
block|}
end_function

begin_comment
comment|/* The "select_frame" command.  With no arg, NOP.    With arg LEVEL_EXP, select the frame at level LEVEL if it is a    valid level.  Otherwise, treat level_exp as an address expression    and select it.  See parse_frame_specification for more info on proper    frame expressions. */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|void
name|select_frame_command
parameter_list|(
name|level_exp
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|level_exp
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
specifier|register
name|FRAME
name|frame
decl_stmt|,
name|frame1
decl_stmt|;
name|unsigned
name|int
name|level
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|target_has_stack
condition|)
name|error
argument_list|(
literal|"No stack."
argument_list|)
expr_stmt|;
name|frame
operator|=
name|parse_frame_specification
argument_list|(
name|level_exp
argument_list|)
expr_stmt|;
comment|/* Try to figure out what level this frame is.  But if there is      no current stack, don't error out -- let the user set one.  */
name|frame1
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|get_current_frame
argument_list|()
condition|)
block|{
for|for
control|(
name|frame1
operator|=
name|get_prev_frame
argument_list|(
literal|0
argument_list|)
init|;
name|frame1
operator|&&
name|frame1
operator|!=
name|frame
condition|;
name|frame1
operator|=
name|get_prev_frame
argument_list|(
name|frame1
argument_list|)
control|)
name|level
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|frame1
condition|)
name|level
operator|=
literal|0
expr_stmt|;
name|select_frame
argument_list|(
name|frame
argument_list|,
name|level
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The "frame" command.  With no arg, print selected frame briefly.    With arg, behaves like select_frame and then prints the selected    frame.  */
end_comment

begin_function
specifier|static
name|void
name|frame_command
parameter_list|(
name|level_exp
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|level_exp
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|select_frame_command
argument_list|(
name|level_exp
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
name|print_stack_frame
argument_list|(
name|selected_frame
argument_list|,
name|selected_frame_level
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Select the frame up one or COUNT stack levels    from the previously selected frame, and print it briefly.  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|void
name|up_silently_command
parameter_list|(
name|count_exp
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|count_exp
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
specifier|register
name|FRAME
name|frame
decl_stmt|;
name|int
name|count
init|=
literal|1
decl_stmt|,
name|count1
decl_stmt|;
if|if
condition|(
name|count_exp
condition|)
name|count
operator|=
name|parse_and_eval_address
argument_list|(
name|count_exp
argument_list|)
expr_stmt|;
name|count1
operator|=
name|count
expr_stmt|;
if|if
condition|(
name|target_has_stack
operator|==
literal|0
operator|||
name|selected_frame
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"No stack."
argument_list|)
expr_stmt|;
name|frame
operator|=
name|find_relative_frame
argument_list|(
name|selected_frame
argument_list|,
operator|&
name|count1
argument_list|)
expr_stmt|;
if|if
condition|(
name|count1
operator|!=
literal|0
operator|&&
name|count_exp
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"Initial frame selected; you cannot go up."
argument_list|)
expr_stmt|;
name|select_frame
argument_list|(
name|frame
argument_list|,
name|selected_frame_level
operator|+
name|count
operator|-
name|count1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|up_command
parameter_list|(
name|count_exp
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|count_exp
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|up_silently_command
argument_list|(
name|count_exp
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
name|print_stack_frame
argument_list|(
name|selected_frame
argument_list|,
name|selected_frame_level
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Select the frame down one or COUNT stack levels    from the previously selected frame, and print it briefly.  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|void
name|down_silently_command
parameter_list|(
name|count_exp
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|count_exp
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
specifier|register
name|FRAME
name|frame
decl_stmt|;
name|int
name|count
init|=
operator|-
literal|1
decl_stmt|,
name|count1
decl_stmt|;
if|if
condition|(
name|count_exp
condition|)
name|count
operator|=
operator|-
name|parse_and_eval_address
argument_list|(
name|count_exp
argument_list|)
expr_stmt|;
name|count1
operator|=
name|count
expr_stmt|;
if|if
condition|(
name|target_has_stack
operator|==
literal|0
operator|||
name|selected_frame
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"No stack."
argument_list|)
expr_stmt|;
name|frame
operator|=
name|find_relative_frame
argument_list|(
name|selected_frame
argument_list|,
operator|&
name|count1
argument_list|)
expr_stmt|;
if|if
condition|(
name|count1
operator|!=
literal|0
operator|&&
name|count_exp
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"Bottom (i.e., innermost) frame selected; you cannot go down."
argument_list|)
expr_stmt|;
name|select_frame
argument_list|(
name|frame
argument_list|,
name|selected_frame_level
operator|+
name|count
operator|-
name|count1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|down_command
parameter_list|(
name|count_exp
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|count_exp
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|down_silently_command
argument_list|(
name|count_exp
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
name|print_stack_frame
argument_list|(
name|selected_frame
argument_list|,
name|selected_frame_level
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|void
name|return_command
parameter_list|(
name|retval_exp
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|retval_exp
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|struct
name|symbol
modifier|*
name|thisfun
decl_stmt|;
name|FRAME_ADDR
name|selected_frame_addr
decl_stmt|;
name|CORE_ADDR
name|selected_frame_pc
decl_stmt|;
name|FRAME
name|frame
decl_stmt|;
name|char
modifier|*
name|funcname
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|back_to
decl_stmt|;
name|value
name|return_value
decl_stmt|;
if|if
condition|(
name|selected_frame
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|"No selected frame."
argument_list|)
expr_stmt|;
name|thisfun
operator|=
name|get_frame_function
argument_list|(
name|selected_frame
argument_list|)
expr_stmt|;
name|selected_frame_addr
operator|=
name|FRAME_FP
argument_list|(
name|selected_frame
argument_list|)
expr_stmt|;
name|selected_frame_pc
operator|=
operator|(
name|get_frame_info
argument_list|(
name|selected_frame
argument_list|)
operator|)
operator|->
name|pc
expr_stmt|;
comment|/* Compute the return value (if any -- possibly getting errors here).      Call VALUE_CONTENTS to make sure we have fully evaluated it, since      it might live in the stack frame we're about to pop.  */
if|if
condition|(
name|retval_exp
condition|)
block|{
name|return_value
operator|=
name|parse_and_eval
argument_list|(
name|retval_exp
argument_list|)
expr_stmt|;
name|VALUE_CONTENTS
argument_list|(
name|return_value
argument_list|)
expr_stmt|;
block|}
comment|/* If interactive, require confirmation.  */
if|if
condition|(
name|from_tty
condition|)
block|{
if|if
condition|(
name|thisfun
operator|!=
literal|0
condition|)
block|{
name|funcname
operator|=
name|strdup_demangled
argument_list|(
name|SYMBOL_NAME
argument_list|(
name|thisfun
argument_list|)
argument_list|)
expr_stmt|;
name|back_to
operator|=
name|make_cleanup
argument_list|(
name|free
argument_list|,
name|funcname
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|query
argument_list|(
literal|"Make %s return now? "
argument_list|,
name|funcname
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"Not confirmed."
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
name|do_cleanups
argument_list|(
name|back_to
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|query
argument_list|(
literal|"Make selected stack frame return now? "
argument_list|)
condition|)
name|error
argument_list|(
literal|"Not confirmed."
argument_list|)
expr_stmt|;
block|}
comment|/* Do the real work.  Pop until the specified frame is current.  We      use this method because the selected_frame is not valid after      a POP_FRAME.  The pc comparison makes this work even if the      selected frame shares its fp with another frame.  */
while|while
condition|(
name|selected_frame_addr
operator|!=
name|FRAME_FP
argument_list|(
name|frame
operator|=
name|get_current_frame
argument_list|()
argument_list|)
operator|||
name|selected_frame_pc
operator|!=
operator|(
name|get_frame_info
argument_list|(
name|frame
argument_list|)
operator|)
operator|->
name|pc
condition|)
name|POP_FRAME
expr_stmt|;
comment|/* Then pop that frame.  */
name|POP_FRAME
expr_stmt|;
comment|/* Compute the return value (if any) and store in the place      for return values.  */
if|if
condition|(
name|retval_exp
condition|)
name|set_return_value
argument_list|(
name|return_value
argument_list|)
expr_stmt|;
comment|/* If interactive, print the frame that is now current.  */
if|if
condition|(
name|from_tty
condition|)
name|frame_command
argument_list|(
literal|"0"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Gets the language of the current frame. */
end_comment

begin_function
name|enum
name|language
name|get_frame_language
parameter_list|()
block|{
specifier|register
name|struct
name|symtab
modifier|*
name|s
decl_stmt|;
name|FRAME
name|fr
decl_stmt|;
name|enum
name|language
name|flang
decl_stmt|;
comment|/* The language of the current frame */
name|fr
operator|=
name|get_frame_info
argument_list|(
name|selected_frame
argument_list|)
expr_stmt|;
if|if
condition|(
name|fr
condition|)
block|{
name|s
operator|=
name|find_pc_symtab
argument_list|(
name|fr
operator|->
name|pc
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
condition|)
name|flang
operator|=
name|s
operator|->
name|language
expr_stmt|;
else|else
name|flang
operator|=
name|language_unknown
expr_stmt|;
block|}
else|else
name|flang
operator|=
name|language_unknown
expr_stmt|;
return|return
name|flang
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|printsource_command
parameter_list|(
name|retval_exp
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|retval_exp
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
if|if
condition|(
name|info_printsource
condition|)
operator|++
name|print_source_at_stop
expr_stmt|;
else|else
operator|--
name|print_source_at_stop
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function
name|void
name|_initialize_stack
parameter_list|()
block|{
name|struct
name|cmd_list_element
modifier|*
name|c
decl_stmt|;
if|#
directive|if
literal|0
block|backtrace_limit = 30;
endif|#
directive|endif
name|add_com
argument_list|(
literal|"return"
argument_list|,
name|class_stack
argument_list|,
name|return_command
argument_list|,
literal|"Make selected stack frame return to its caller.\n\ Control remains in the debugger, but when you continue\n\ execution will resume in the frame above the one now selected.\n\ If an argument is given, it is an expression for the value to return."
argument_list|)
expr_stmt|;
name|add_com
argument_list|(
literal|"up"
argument_list|,
name|class_stack
argument_list|,
name|up_command
argument_list|,
literal|"Select and print stack frame that called this one.\n\ An argument says how many frames up to go."
argument_list|)
expr_stmt|;
name|add_com
argument_list|(
literal|"up-silently"
argument_list|,
name|class_support
argument_list|,
name|up_silently_command
argument_list|,
literal|"Same as the `up' command, but does not print anything.\n\ This is useful in command scripts."
argument_list|)
expr_stmt|;
name|add_com
argument_list|(
literal|"down"
argument_list|,
name|class_stack
argument_list|,
name|down_command
argument_list|,
literal|"Select and print stack frame called by this one.\n\ An argument says how many frames down to go."
argument_list|)
expr_stmt|;
name|add_com_alias
argument_list|(
literal|"do"
argument_list|,
literal|"down"
argument_list|,
name|class_stack
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|add_com_alias
argument_list|(
literal|"dow"
argument_list|,
literal|"down"
argument_list|,
name|class_stack
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|add_com
argument_list|(
literal|"down-silently"
argument_list|,
name|class_support
argument_list|,
name|down_silently_command
argument_list|,
literal|"Same as the `down' command, but does not print anything.\n\ This is useful in command scripts."
argument_list|)
expr_stmt|;
name|add_com
argument_list|(
literal|"frame"
argument_list|,
name|class_stack
argument_list|,
name|frame_command
argument_list|,
literal|"Select and print a stack frame.\n\ With no argument, print the selected stack frame.  (See also \"info frame\").\n\ An argument specifies the frame to select.\n\ It can be a stack frame number or the address of the frame.\n\ With argument, nothing is printed if input is coming from\n\ a command file or a user-defined command."
argument_list|)
expr_stmt|;
name|add_com_alias
argument_list|(
literal|"f"
argument_list|,
literal|"frame"
argument_list|,
name|class_stack
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|add_com
argument_list|(
literal|"select-frame"
argument_list|,
name|class_stack
argument_list|,
name|select_frame_command
argument_list|,
literal|"Select a stack frame without printing anything.\n\ An argument specifies the frame to select.\n\ It can be a stack frame number or the address of the frame.\n"
argument_list|)
expr_stmt|;
name|add_com
argument_list|(
literal|"backtrace"
argument_list|,
name|class_stack
argument_list|,
name|backtrace_command
argument_list|,
literal|"Print backtrace of all stack frames, or innermost COUNT frames.\n\ With a negative argument, print outermost -COUNT frames."
argument_list|)
expr_stmt|;
name|add_com_alias
argument_list|(
literal|"bt"
argument_list|,
literal|"backtrace"
argument_list|,
name|class_stack
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|add_com_alias
argument_list|(
literal|"where"
argument_list|,
literal|"backtrace"
argument_list|,
name|class_alias
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|add_info
argument_list|(
literal|"stack"
argument_list|,
name|backtrace_command
argument_list|,
literal|"Backtrace of the stack, or innermost COUNT frames."
argument_list|)
expr_stmt|;
name|add_info_alias
argument_list|(
literal|"s"
argument_list|,
literal|"stack"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|add_info
argument_list|(
literal|"frame"
argument_list|,
name|frame_info
argument_list|,
literal|"All about selected stack frame, or frame at ADDR."
argument_list|)
expr_stmt|;
name|add_info_alias
argument_list|(
literal|"f"
argument_list|,
literal|"frame"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|add_info
argument_list|(
literal|"locals"
argument_list|,
name|locals_info
argument_list|,
literal|"Local variables of current stack frame."
argument_list|)
expr_stmt|;
name|add_info
argument_list|(
literal|"args"
argument_list|,
name|args_info
argument_list|,
literal|"Argument variables of current stack frame."
argument_list|)
expr_stmt|;
name|add_info
argument_list|(
literal|"catch"
argument_list|,
name|catch_info
argument_list|,
literal|"Exceptions that can be caught in the current stack frame."
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|add_cmd ("backtrace-limit", class_stack, set_backtrace_limit_command,  	   "Specify maximum number of frames for \"backtrace\" to print by default.",&setlist);   add_info ("backtrace-limit", backtrace_limit_info, 	    "The maximum number of frames for \"backtrace\" to print by default.");
endif|#
directive|endif
name|c
operator|=
name|add_set_cmd
argument_list|(
literal|"printsource"
argument_list|,
name|class_stack
argument_list|,
name|var_boolean
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|info_printsource
argument_list|,
literal|"Set auto print of source lines at step/breakpoint."
argument_list|,
operator|&
name|setlist
argument_list|)
operator|,
name|add_show_from_set
argument_list|(
name|c
argument_list|,
operator|&
name|showlist
argument_list|)
expr_stmt|;
name|c
operator|->
name|function
operator|.
name|sfunc
operator|=
name|printsource_command
expr_stmt|;
block|}
end_function

end_unit

