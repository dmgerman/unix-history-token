begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Target-dependent code for the MIPS architecture, for GDB, the GNU Debugger.    Copyright 1988, 1989, 1990, 1991, 1992 Free Software Foundation, Inc.    Contributed by Alessandro Forin(af@cs.cmu.edu) at CMU    and by Per Bothner(bothner@cs.wisc.edu) at U.Wisconsin.  This file is part of GDB.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"frame.h"
end_include

begin_include
include|#
directive|include
file|"inferior.h"
end_include

begin_include
include|#
directive|include
file|"symtab.h"
end_include

begin_include
include|#
directive|include
file|"value.h"
end_include

begin_include
include|#
directive|include
file|"gdbcmd.h"
end_include

begin_include
include|#
directive|include
file|"language.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|USG
end_ifdef

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/dir.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_include
include|#
directive|include
file|"gdbcore.h"
end_include

begin_include
include|#
directive|include
file|"symfile.h"
end_include

begin_include
include|#
directive|include
file|"objfiles.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|MIPSMAGIC
end_ifndef

begin_ifdef
ifdef|#
directive|ifdef
name|MIPSEL
end_ifdef

begin_define
define|#
directive|define
name|MIPSMAGIC
value|MIPSELMAGIC
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|MIPSMAGIC
value|MIPSEBMAGIC
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|VM_MIN_ADDRESS
value|(unsigned)0x400000
end_define

begin_include
include|#
directive|include
file|<sys/user.h>
end_include

begin_comment
comment|/* After a.out.h  */
end_comment

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|KERNELDEBUG
end_ifdef

begin_decl_stmt
specifier|extern
name|int
name|kernel_debugging
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * The MIPS architecture does not provide a trace bit.  However, most  * (if not all) OS's that run on the MIPS emulate single stepping in  * the kernel.  This unfortunately does not work for the kernel debugger.  * Thus, we duplicate the functionality here.  */
end_comment

begin_comment
comment|/*  * For the instruction INSN at PC, if it is a control transfer, return the  * target address, otherwise return 0.  *  * Instruction decoding per "MIPS RISC Architecture" by Gerry Kane  * and Joe Heinrich, Prentice Hall, 1992.  Fig. A-3, Page A-143.  */
end_comment

begin_function
name|CORE_ADDR
name|branchtarget
parameter_list|(
name|insn
parameter_list|,
name|pc
parameter_list|)
name|u_long
name|insn
decl_stmt|;
name|CORE_ADDR
name|pc
decl_stmt|;
block|{
name|int
name|opcode
init|=
operator|(
name|insn
operator|>>
literal|26
operator|)
operator|&
literal|0x3f
decl_stmt|;
name|u_long
name|v
decl_stmt|;
switch|switch
condition|(
name|opcode
condition|)
block|{
case|case
literal|0x00
case|:
comment|/* SPECIAL */
name|v
operator|=
name|insn
operator|&
literal|0x3f
expr_stmt|;
if|if
condition|(
name|v
operator|==
literal|8
operator|||
name|v
operator|==
literal|9
condition|)
block|{
name|int
name|rs
init|=
operator|(
name|insn
operator|>>
literal|21
operator|)
operator|&
literal|0x1f
decl_stmt|;
return|return
operator|(
name|read_register
argument_list|(
name|rs
argument_list|)
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
case|case
literal|0x01
case|:
comment|/* REGIMM */
name|v
operator|=
operator|(
name|insn
operator|>>
literal|16
operator|)
operator|&
literal|0x1f
expr_stmt|;
switch|switch
condition|(
name|v
condition|)
block|{
default|default:
return|return
operator|(
literal|0
operator|)
return|;
case|case
literal|0x00
case|:
comment|/* BLTZ */
case|case
literal|0x01
case|:
comment|/* BGEZ */
case|case
literal|0x02
case|:
comment|/* BLTZL */
case|case
literal|0x03
case|:
comment|/* BGEZL */
case|case
literal|0x10
case|:
comment|/* BLTZAL */
case|case
literal|0x11
case|:
comment|/* BGEZAL */
case|case
literal|0x12
case|:
comment|/* BLTZALL */
case|case
literal|0x13
case|:
comment|/* BGEZALL */
break|break;
block|}
comment|/* fall through */
case|case
literal|0x04
case|:
comment|/* BEQ */
case|case
literal|0x05
case|:
comment|/* BNE */
case|case
literal|0x06
case|:
comment|/* BLEZ */
case|case
literal|0x07
case|:
comment|/* GTRZ */
name|v
operator|=
name|insn
operator|&
literal|0xffff
expr_stmt|;
if|if
condition|(
name|v
operator|&
literal|0x8000
condition|)
name|v
operator||=
literal|0xffff0000
expr_stmt|;
name|v
operator|<<=
literal|2
expr_stmt|;
return|return
operator|(
name|pc
operator|+
literal|4
operator|+
name|v
operator|)
return|;
case|case
literal|0x02
case|:
comment|/* J */
case|case
literal|0x03
case|:
comment|/* JAL */
name|v
operator|=
operator|(
name|insn
operator|&
literal|0x03ffffff
operator|)
operator|<<
literal|2
expr_stmt|;
return|return
operator|(
operator|(
operator|(
name|pc
operator|+
literal|4
operator|)
operator|&
literal|0xf0000000
operator|)
operator||
name|v
operator|)
return|;
case|case
literal|0x10
case|:
comment|/* COP0 */
case|case
literal|0x11
case|:
comment|/* COP1 */
case|case
literal|0x12
case|:
comment|/* COP2 */
case|case
literal|0x13
case|:
comment|/* COP3 */
name|v
operator|=
operator|(
name|insn
operator|>>
literal|21
operator|)
operator|&
literal|0x1f
expr_stmt|;
if|if
condition|(
name|v
operator|==
literal|8
condition|)
block|{
name|v
operator|=
name|insn
operator|&
literal|0xffff
expr_stmt|;
if|if
condition|(
name|v
operator|&
literal|0x8000
condition|)
name|v
operator||=
literal|0xffff0000
expr_stmt|;
name|v
operator|<<=
literal|2
expr_stmt|;
return|return
operator|(
name|pc
operator|+
literal|4
operator|+
name|v
operator|)
return|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|is_call_insn
parameter_list|(
name|insn
parameter_list|)
name|u_long
name|insn
decl_stmt|;
block|{
name|int
name|opcode
init|=
operator|(
name|insn
operator|>>
literal|26
operator|)
operator|&
literal|0x3f
decl_stmt|;
if|if
condition|(
name|opcode
operator|==
literal|3
condition|)
comment|/* JAL */
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|opcode
operator|==
literal|0
condition|)
block|{
comment|/* SPECIAL */
name|int
name|v
init|=
name|insn
operator|&
literal|0x3f
decl_stmt|;
comment|/* JALR */
return|return
operator|(
name|v
operator|==
literal|9
operator|)
return|;
block|}
if|if
condition|(
name|opcode
operator|==
literal|1
condition|)
block|{
comment|/* REGIMM */
name|int
name|v
init|=
operator|(
name|insn
operator|>>
literal|19
operator|)
operator|&
literal|3
decl_stmt|;
comment|/* BLTZAL etc. */
return|return
operator|(
name|v
operator|==
literal|2
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Non-zero if we just simulated a single-step ptrace call.  This is  * needed because we cannot remove the breakpoints in the inferior  * process until after the `wait' in `wait_for_inferior'.   * Used for sun4.  */
end_comment

begin_decl_stmt
name|int
name|one_stepped
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * single_step() is called just before we want to resume the inferior,  * if we want to single-step it but there is no hardware or kernel single-step  * support (as on all SPARCs).  We find all the possible targets of the  * coming instruction and breakpoint them.  *  * single_step is also called just after the inferior stops.  If we had  * set up a simulated single-step, we undo our damage.  *  * Code written by Gary Beihl (beihl@mcc.com); modified by Steven McCanne  * (mccanne@ee.lbl.gov).  */
end_comment

begin_function
name|void
name|single_step
parameter_list|(
name|signal
parameter_list|)
name|int
name|signal
decl_stmt|;
block|{
name|CORE_ADDR
name|pc
decl_stmt|;
name|u_long
name|insn
decl_stmt|;
comment|/* 	 * Storage for temporary breakpoints.  XXX There should be a uniform 	 * interface for breakpoints, so that we could just set one then  	 * clear it.  Note that we need only two outstanding breakpoints, 	 * since there can be at most two possiblilities for control flow. 	 */
specifier|static
name|CORE_ADDR
name|target0
decl_stmt|;
specifier|static
name|CORE_ADDR
name|target1
decl_stmt|;
specifier|static
name|char
name|shadow0
index|[
literal|4
index|]
decl_stmt|;
specifier|static
name|char
name|shadow1
index|[
literal|4
index|]
decl_stmt|;
name|pc
operator|=
name|read_register
argument_list|(
name|PC_REGNUM
argument_list|)
expr_stmt|;
name|insn
operator|=
name|read_memory_integer
argument_list|(
name|pc
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|one_stepped
condition|)
block|{
comment|/* 		 * This is a hack to special case call instructions. 		 * If we are stepping over subroutines, find each call 		 * and trap on return, rather than single step until 		 * wait_for_inferior() discovers that we hit a new routine. 		 * The reason is that stepping over functions in a remote  		 * kernel can have bad results when the function being  		 * stepped over is used by the kernel in between traps. 		 * (i.e., a trap instruction gets poked into the function 		 * being stepped over). 		 */
if|if
condition|(
name|step_over_calls
operator|>
literal|0
operator|&&
name|is_call_insn
argument_list|(
name|insn
argument_list|)
condition|)
block|{
name|target0
operator|=
name|pc
operator|+
literal|8
expr_stmt|;
name|target1
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|target0
operator|=
name|pc
operator|+
literal|4
expr_stmt|;
name|target1
operator|=
name|branchtarget
argument_list|(
name|insn
argument_list|,
name|pc
argument_list|)
expr_stmt|;
if|if
condition|(
name|target1
operator|!=
literal|0
condition|)
block|{
comment|/* 				 * Punt on stepping through delay slot. 				 * On the sparc, this is easy because of 				 * npc; on the mips, it's trickier 				 * because we'd have to keep track 				 * of when we're in the delay slot (and 				 * gdb will get confused because the 				 * cpu leaves the epc pointing to the 				 * previous instruction).  Moreover, the 				 * architecture would require that we 				 * interpret the branch intruction if 				 * we want to set a breakpoint in the 				 * delay slot. 				 */
name|target0
operator|+=
literal|4
expr_stmt|;
block|}
if|if
condition|(
name|target1
operator|==
name|target0
condition|)
name|target1
operator|=
literal|0
expr_stmt|;
block|}
name|target_insert_breakpoint
argument_list|(
name|target0
argument_list|,
name|shadow0
argument_list|)
expr_stmt|;
if|if
condition|(
name|target1
condition|)
name|target_insert_breakpoint
argument_list|(
name|target1
argument_list|,
name|shadow1
argument_list|)
expr_stmt|;
name|one_stepped
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* Remove breakpoints */
if|if
condition|(
name|target1
condition|)
name|target_remove_breakpoint
argument_list|(
name|target1
argument_list|,
name|shadow1
argument_list|)
expr_stmt|;
name|target_remove_breakpoint
argument_list|(
name|target0
argument_list|,
name|shadow0
argument_list|)
expr_stmt|;
name|one_stepped
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_define
define|#
directive|define
name|PROC_LOW_ADDR
parameter_list|(
name|proc
parameter_list|)
value|((proc)->pdr.adr)
end_define

begin_comment
comment|/* least address */
end_comment

begin_define
define|#
directive|define
name|PROC_HIGH_ADDR
parameter_list|(
name|proc
parameter_list|)
value|((proc)->pdr.iline)
end_define

begin_comment
comment|/* upper address bound */
end_comment

begin_define
define|#
directive|define
name|PROC_FRAME_OFFSET
parameter_list|(
name|proc
parameter_list|)
value|((proc)->pdr.frameoffset)
end_define

begin_define
define|#
directive|define
name|PROC_FRAME_REG
parameter_list|(
name|proc
parameter_list|)
value|((proc)->pdr.framereg)
end_define

begin_define
define|#
directive|define
name|PROC_REG_MASK
parameter_list|(
name|proc
parameter_list|)
value|((proc)->pdr.regmask)
end_define

begin_define
define|#
directive|define
name|PROC_FREG_MASK
parameter_list|(
name|proc
parameter_list|)
value|((proc)->pdr.fregmask)
end_define

begin_define
define|#
directive|define
name|PROC_REG_OFFSET
parameter_list|(
name|proc
parameter_list|)
value|((proc)->pdr.regoffset)
end_define

begin_define
define|#
directive|define
name|PROC_FREG_OFFSET
parameter_list|(
name|proc
parameter_list|)
value|((proc)->pdr.fregoffset)
end_define

begin_define
define|#
directive|define
name|PROC_PC_REG
parameter_list|(
name|proc
parameter_list|)
value|((proc)->pdr.pcreg)
end_define

begin_define
define|#
directive|define
name|PROC_SYMBOL
parameter_list|(
name|proc
parameter_list|)
value|(*(struct symbol**)&(proc)->pdr.isym)
end_define

begin_define
define|#
directive|define
name|_PROC_MAGIC_
value|0x0F0F0F0F
end_define

begin_define
define|#
directive|define
name|PROC_DESC_IS_DUMMY
parameter_list|(
name|proc
parameter_list|)
value|((proc)->pdr.isym == _PROC_MAGIC_)
end_define

begin_define
define|#
directive|define
name|SET_PROC_DESC_IS_DUMMY
parameter_list|(
name|proc
parameter_list|)
value|((proc)->pdr.isym = _PROC_MAGIC_)
end_define

begin_struct
struct|struct
name|linked_proc_info
block|{
name|struct
name|mips_extra_func_info
name|info
decl_stmt|;
name|struct
name|linked_proc_info
modifier|*
name|next
decl_stmt|;
block|}
modifier|*
name|linked_proc_desc_table
init|=
name|NULL
struct|;
end_struct

begin_escape
end_escape

begin_define
define|#
directive|define
name|READ_FRAME_REG
parameter_list|(
name|fi
parameter_list|,
name|regno
parameter_list|)
value|read_next_frame_reg((fi)->next, regno)
end_define

begin_function
specifier|static
name|int
name|read_next_frame_reg
parameter_list|(
name|fi
parameter_list|,
name|regno
parameter_list|)
name|FRAME
name|fi
decl_stmt|;
name|int
name|regno
decl_stmt|;
block|{
define|#
directive|define
name|SIGFRAME_BASE
value|sizeof(struct sigcontext)
define|#
directive|define
name|SIGFRAME_PC_OFF
value|(-SIGFRAME_BASE+ 2*sizeof(int))
define|#
directive|define
name|SIGFRAME_SP_OFF
value|(-SIGFRAME_BASE+32*sizeof(int))
define|#
directive|define
name|SIGFRAME_RA_OFF
value|(-SIGFRAME_BASE+34*sizeof(int))
for|for
control|(
init|;
name|fi
condition|;
name|fi
operator|=
name|fi
operator|->
name|next
control|)
block|{
ifdef|#
directive|ifdef
name|KERNELDEBUG
if|if
condition|(
name|kernel_debugging
operator|&&
name|in_trap_handler
argument_list|(
name|fi
operator|->
name|pc
argument_list|)
condition|)
block|{
name|int
name|offset
decl_stmt|;
if|if
condition|(
name|regno
operator|==
name|PC_REGNUM
condition|)
name|offset
operator|=
literal|40
expr_stmt|;
elseif|else
if|if
condition|(
name|regno
operator|==
name|RA_REGNUM
condition|)
name|offset
operator|=
literal|34
expr_stmt|;
elseif|else
if|if
condition|(
name|regno
operator|==
name|SP_REGNUM
condition|)
name|offset
operator|=
literal|32
expr_stmt|;
else|else
return|return
literal|0
return|;
return|return
name|read_memory_integer
argument_list|(
name|fi
operator|->
name|frame
operator|+
literal|4
operator|*
name|offset
argument_list|,
literal|4
argument_list|)
return|;
block|}
endif|#
directive|endif
if|if
condition|(
name|in_sigtramp
argument_list|(
name|fi
operator|->
name|pc
argument_list|,
literal|0
argument_list|)
condition|)
block|{
comment|/* No idea if this code works. --PB. */
name|int
name|offset
decl_stmt|;
if|if
condition|(
name|regno
operator|==
name|PC_REGNUM
condition|)
name|offset
operator|=
name|SIGFRAME_PC_OFF
expr_stmt|;
elseif|else
if|if
condition|(
name|regno
operator|==
name|RA_REGNUM
condition|)
name|offset
operator|=
name|SIGFRAME_RA_OFF
expr_stmt|;
elseif|else
if|if
condition|(
name|regno
operator|==
name|SP_REGNUM
condition|)
name|offset
operator|=
name|SIGFRAME_SP_OFF
expr_stmt|;
else|else
return|return
literal|0
return|;
return|return
name|read_memory_integer
argument_list|(
name|fi
operator|->
name|frame
operator|+
name|offset
argument_list|,
literal|4
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|regno
operator|==
name|SP_REGNUM
condition|)
return|return
name|fi
operator|->
name|frame
return|;
elseif|else
if|if
condition|(
name|fi
operator|->
name|saved_regs
operator|->
name|regs
index|[
name|regno
index|]
condition|)
return|return
name|read_memory_integer
argument_list|(
name|fi
operator|->
name|saved_regs
operator|->
name|regs
index|[
name|regno
index|]
argument_list|,
literal|4
argument_list|)
return|;
block|}
return|return
name|read_register
argument_list|(
name|regno
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|mips_frame_saved_pc
parameter_list|(
name|frame
parameter_list|)
name|FRAME
name|frame
decl_stmt|;
block|{
name|mips_extra_func_info_t
name|proc_desc
init|=
name|frame
operator|->
name|proc_desc
decl_stmt|;
name|int
name|pcreg
init|=
name|proc_desc
condition|?
name|PROC_PC_REG
argument_list|(
name|proc_desc
argument_list|)
else|:
name|RA_REGNUM
decl_stmt|;
ifdef|#
directive|ifdef
name|KERNELDEBUG
if|if
condition|(
name|kernel_debugging
operator|&&
name|in_trap_handler
argument_list|(
name|frame
operator|->
name|pc
argument_list|)
condition|)
return|return
name|read_memory_integer
argument_list|(
name|frame
operator|->
name|frame
operator|+
literal|4
operator|*
literal|40
argument_list|,
literal|4
argument_list|)
return|;
endif|#
directive|endif
if|if
condition|(
name|proc_desc
operator|&&
name|PROC_DESC_IS_DUMMY
argument_list|(
name|proc_desc
argument_list|)
condition|)
return|return
name|read_memory_integer
argument_list|(
name|frame
operator|->
name|frame
operator|-
literal|4
argument_list|,
literal|4
argument_list|)
return|;
return|return
name|read_next_frame_reg
argument_list|(
name|frame
argument_list|,
name|pcreg
argument_list|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|struct
name|mips_extra_func_info
name|temp_proc_desc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|frame_saved_regs
name|temp_saved_regs
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|CORE_ADDR
name|heuristic_proc_start
parameter_list|(
name|pc
parameter_list|)
name|CORE_ADDR
name|pc
decl_stmt|;
block|{
name|CORE_ADDR
name|start_pc
init|=
name|pc
decl_stmt|;
name|CORE_ADDR
name|fence
init|=
name|start_pc
operator|-
literal|200
decl_stmt|;
if|if
condition|(
name|start_pc
operator|==
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|fence
operator|<
name|VM_MIN_ADDRESS
condition|)
name|fence
operator|=
name|VM_MIN_ADDRESS
expr_stmt|;
comment|/* search back for previous return */
for|for
control|(
name|start_pc
operator|-=
literal|4
init|;
condition|;
name|start_pc
operator|-=
literal|4
control|)
if|if
condition|(
name|start_pc
operator|<
name|fence
condition|)
return|return
literal|0
return|;
elseif|else
if|if
condition|(
name|ABOUT_TO_RETURN
argument_list|(
name|start_pc
argument_list|)
condition|)
break|break;
name|start_pc
operator|+=
literal|8
expr_stmt|;
comment|/* skip return, and its delay slot */
if|#
directive|if
literal|0
comment|/* skip nops (usually 1) 0 - is this */
block|while (start_pc< pc&& read_memory_integer (start_pc, 4) == 0) 	start_pc += 4;
endif|#
directive|endif
return|return
name|start_pc
return|;
block|}
end_function

begin_function
specifier|static
name|mips_extra_func_info_t
name|heuristic_proc_desc
parameter_list|(
name|start_pc
parameter_list|,
name|limit_pc
parameter_list|,
name|next_frame
parameter_list|)
name|CORE_ADDR
name|start_pc
decl_stmt|,
name|limit_pc
decl_stmt|;
name|FRAME
name|next_frame
decl_stmt|;
block|{
name|CORE_ADDR
name|sp
init|=
name|next_frame
condition|?
name|next_frame
operator|->
name|frame
else|:
name|read_register
argument_list|(
name|SP_REGNUM
argument_list|)
decl_stmt|;
name|CORE_ADDR
name|cur_pc
decl_stmt|;
name|int
name|frame_size
decl_stmt|;
name|int
name|has_frame_reg
init|=
literal|0
decl_stmt|;
name|int
name|reg30
decl_stmt|;
comment|/* Value of $r30. Used by gcc for frame-pointer */
name|unsigned
name|long
name|reg_mask
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|start_pc
operator|==
literal|0
condition|)
return|return
name|NULL
return|;
name|bzero
argument_list|(
operator|&
name|temp_proc_desc
argument_list|,
sizeof|sizeof
argument_list|(
name|temp_proc_desc
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|temp_saved_regs
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|frame_saved_regs
argument_list|)
argument_list|)
expr_stmt|;
name|PROC_LOW_ADDR
argument_list|(
operator|&
name|temp_proc_desc
argument_list|)
operator|=
name|start_pc
expr_stmt|;
if|if
condition|(
name|start_pc
operator|+
literal|200
operator|<
name|limit_pc
condition|)
name|limit_pc
operator|=
name|start_pc
operator|+
literal|200
expr_stmt|;
name|restart
label|:
name|frame_size
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|cur_pc
operator|=
name|start_pc
init|;
name|cur_pc
operator|<
name|limit_pc
condition|;
name|cur_pc
operator|+=
literal|4
control|)
block|{
name|unsigned
name|long
name|word
decl_stmt|;
name|int
name|status
decl_stmt|;
name|status
operator|=
name|read_memory_nobpt
argument_list|(
name|cur_pc
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|word
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
name|memory_error
argument_list|(
name|status
argument_list|,
name|cur_pc
argument_list|)
expr_stmt|;
name|SWAP_TARGET_AND_HOST
argument_list|(
operator|&
name|word
argument_list|,
sizeof|sizeof
argument_list|(
name|word
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|word
operator|&
literal|0xFFFF0000
operator|)
operator|==
literal|0x27bd0000
condition|)
comment|/* addiu $sp,$sp,-i */
name|frame_size
operator|+=
operator|(
operator|-
name|word
operator|)
operator|&
literal|0xFFFF
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|word
operator|&
literal|0xFFFF0000
operator|)
operator|==
literal|0x23bd0000
condition|)
comment|/* addu $sp,$sp,-i */
name|frame_size
operator|+=
operator|(
operator|-
name|word
operator|)
operator|&
literal|0xFFFF
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|word
operator|&
literal|0xFFE00000
operator|)
operator|==
literal|0xafa00000
condition|)
block|{
comment|/* sw reg,offset($sp) */
name|int
name|reg
init|=
operator|(
name|word
operator|&
literal|0x001F0000
operator|)
operator|>>
literal|16
decl_stmt|;
name|reg_mask
operator||=
literal|1
operator|<<
name|reg
expr_stmt|;
name|temp_saved_regs
operator|.
name|regs
index|[
name|reg
index|]
operator|=
name|sp
operator|+
operator|(
name|short
operator|)
name|word
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|word
operator|&
literal|0xFFFF0000
operator|)
operator|==
literal|0x27be0000
condition|)
block|{
comment|/* addiu $30,$sp,size */
if|if
condition|(
operator|(
name|unsigned
name|short
operator|)
name|word
operator|!=
name|frame_size
condition|)
name|reg30
operator|=
name|sp
operator|+
operator|(
name|unsigned
name|short
operator|)
name|word
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|has_frame_reg
condition|)
block|{
name|int
name|alloca_adjust
decl_stmt|;
name|has_frame_reg
operator|=
literal|1
expr_stmt|;
name|reg30
operator|=
name|read_next_frame_reg
argument_list|(
name|next_frame
argument_list|,
literal|30
argument_list|)
expr_stmt|;
name|alloca_adjust
operator|=
name|reg30
operator|-
operator|(
name|sp
operator|+
operator|(
name|unsigned
name|short
operator|)
name|word
operator|)
expr_stmt|;
if|if
condition|(
name|alloca_adjust
operator|>
literal|0
condition|)
block|{
comment|/* FP> SP + frame_size. This may be because 		    /* of an alloca or somethings similar. 		     * Fix sp to "pre-alloca" value, and try again. 		     */
name|sp
operator|+=
name|alloca_adjust
expr_stmt|;
goto|goto
name|restart
goto|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|word
operator|&
literal|0xFFE00000
operator|)
operator|==
literal|0xafc00000
condition|)
block|{
comment|/* sw reg,offset($30) */
name|int
name|reg
init|=
operator|(
name|word
operator|&
literal|0x001F0000
operator|)
operator|>>
literal|16
decl_stmt|;
name|reg_mask
operator||=
literal|1
operator|<<
name|reg
expr_stmt|;
name|temp_saved_regs
operator|.
name|regs
index|[
name|reg
index|]
operator|=
name|reg30
operator|+
operator|(
name|short
operator|)
name|word
expr_stmt|;
block|}
block|}
if|if
condition|(
name|has_frame_reg
condition|)
block|{
name|PROC_FRAME_REG
argument_list|(
operator|&
name|temp_proc_desc
argument_list|)
operator|=
literal|30
expr_stmt|;
name|PROC_FRAME_OFFSET
argument_list|(
operator|&
name|temp_proc_desc
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|PROC_FRAME_REG
argument_list|(
operator|&
name|temp_proc_desc
argument_list|)
operator|=
name|SP_REGNUM
expr_stmt|;
name|PROC_FRAME_OFFSET
argument_list|(
operator|&
name|temp_proc_desc
argument_list|)
operator|=
name|frame_size
expr_stmt|;
block|}
name|PROC_REG_MASK
argument_list|(
operator|&
name|temp_proc_desc
argument_list|)
operator|=
name|reg_mask
expr_stmt|;
name|PROC_PC_REG
argument_list|(
operator|&
name|temp_proc_desc
argument_list|)
operator|=
name|RA_REGNUM
expr_stmt|;
return|return
operator|&
name|temp_proc_desc
return|;
block|}
end_function

begin_function
specifier|static
name|mips_extra_func_info_t
name|find_proc_desc
parameter_list|(
name|pc
parameter_list|,
name|next_frame
parameter_list|)
name|CORE_ADDR
name|pc
decl_stmt|;
name|FRAME
name|next_frame
decl_stmt|;
block|{
name|mips_extra_func_info_t
name|proc_desc
decl_stmt|;
name|struct
name|block
modifier|*
name|b
init|=
name|block_for_pc
argument_list|(
name|pc
argument_list|)
decl_stmt|;
name|struct
name|symbol
modifier|*
name|sym
init|=
name|b
condition|?
name|lookup_symbol
argument_list|(
name|MIPS_EFI_SYMBOL_NAME
argument_list|,
name|b
argument_list|,
name|LABEL_NAMESPACE
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
else|:
name|NULL
decl_stmt|;
if|if
condition|(
name|sym
condition|)
block|{
comment|/* IF this is the topmost frame AND 	 * (this proc does not have debugging information OR 	 * the PC is in the procedure prologue) 	 * THEN create a "heuristic" proc_desc (by analyzing 	 * the actual code) to replace the "official" proc_desc. 	 */
name|proc_desc
operator|=
operator|(
name|mips_extra_func_info_t
operator|)
name|SYMBOL_VALUE
argument_list|(
name|sym
argument_list|)
expr_stmt|;
if|if
condition|(
name|next_frame
operator|==
name|NULL
condition|)
block|{
name|struct
name|symtab_and_line
name|val
decl_stmt|;
name|struct
name|symbol
modifier|*
name|proc_symbol
init|=
name|PROC_DESC_IS_DUMMY
argument_list|(
name|proc_desc
argument_list|)
condition|?
literal|0
else|:
name|PROC_SYMBOL
argument_list|(
name|proc_desc
argument_list|)
decl_stmt|;
if|if
condition|(
name|proc_symbol
condition|)
block|{
name|val
operator|=
name|find_pc_line
argument_list|(
name|BLOCK_START
argument_list|(
name|SYMBOL_BLOCK_VALUE
argument_list|(
name|proc_symbol
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|val
operator|.
name|pc
operator|=
name|val
operator|.
name|end
condition|?
name|val
operator|.
name|end
else|:
name|pc
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|proc_symbol
operator|||
name|pc
operator|<
name|val
operator|.
name|pc
condition|)
block|{
name|mips_extra_func_info_t
name|found_heuristic
init|=
name|heuristic_proc_desc
argument_list|(
name|PROC_LOW_ADDR
argument_list|(
name|proc_desc
argument_list|)
argument_list|,
name|pc
argument_list|,
name|next_frame
argument_list|)
decl_stmt|;
if|if
condition|(
name|found_heuristic
condition|)
name|proc_desc
operator|=
name|found_heuristic
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
comment|/* Is linked_proc_desc_table really necessary?  It only seems to be used 	 by procedure call dummys.  However, the procedures being called ought 	 to have their own proc_descs, and even if they don't, 	 heuristic_proc_desc knows how to create them! */
specifier|register
name|struct
name|linked_proc_info
modifier|*
name|link
decl_stmt|;
for|for
control|(
name|link
operator|=
name|linked_proc_desc_table
init|;
name|link
condition|;
name|link
operator|=
name|link
operator|->
name|next
control|)
if|if
condition|(
name|PROC_LOW_ADDR
argument_list|(
operator|&
name|link
operator|->
name|info
argument_list|)
operator|<=
name|pc
operator|&&
name|PROC_HIGH_ADDR
argument_list|(
operator|&
name|link
operator|->
name|info
argument_list|)
operator|>
name|pc
condition|)
return|return
operator|&
name|link
operator|->
name|info
return|;
name|proc_desc
operator|=
name|heuristic_proc_desc
argument_list|(
name|heuristic_proc_start
argument_list|(
name|pc
argument_list|)
argument_list|,
name|pc
argument_list|,
name|next_frame
argument_list|)
expr_stmt|;
block|}
return|return
name|proc_desc
return|;
block|}
end_function

begin_comment
comment|/* XXX this is not a cache (i.e., you don't invalidate it) */
end_comment

begin_decl_stmt
name|mips_extra_func_info_t
name|cached_proc_desc
decl_stmt|;
end_decl_stmt

begin_function
name|FRAME_ADDR
name|mips_frame_chain
parameter_list|(
name|frame
parameter_list|)
name|FRAME
name|frame
decl_stmt|;
block|{
name|mips_extra_func_info_t
name|proc_desc
decl_stmt|;
name|CORE_ADDR
name|saved_pc
init|=
name|FRAME_SAVED_PC
argument_list|(
name|frame
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|KERNELDEBUG
if|if
condition|(
name|kernel_debugging
condition|)
block|{
if|if
condition|(
operator|!
name|inside_kernstack
argument_list|(
name|frame
operator|->
name|frame
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|in_trap_handler
argument_list|(
name|saved_pc
argument_list|)
condition|)
block|{
comment|/* XXX this works? */
name|cached_proc_desc
operator|=
name|find_proc_desc
argument_list|(
name|saved_pc
argument_list|,
name|frame
argument_list|)
expr_stmt|;
comment|/*XXX need to lookup frame of parent */
return|return
name|read_memory_integer
argument_list|(
name|frame
operator|->
name|frame
operator|+
literal|4
operator|*
literal|32
argument_list|,
literal|4
argument_list|)
return|;
block|}
block|}
elseif|else
endif|#
directive|endif
if|if
condition|(
name|saved_pc
operator|==
literal|0
operator|||
name|inside_entry_file
argument_list|(
name|saved_pc
argument_list|)
condition|)
return|return
literal|0
return|;
name|proc_desc
operator|=
name|find_proc_desc
argument_list|(
name|saved_pc
argument_list|,
name|frame
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|proc_desc
condition|)
return|return
literal|0
return|;
name|cached_proc_desc
operator|=
name|proc_desc
expr_stmt|;
return|return
name|read_next_frame_reg
argument_list|(
name|frame
argument_list|,
name|PROC_FRAME_REG
argument_list|(
name|proc_desc
argument_list|)
argument_list|)
operator|+
name|PROC_FRAME_OFFSET
argument_list|(
name|proc_desc
argument_list|)
return|;
block|}
end_function

begin_function
name|void
name|init_extra_frame_info
parameter_list|(
name|fci
parameter_list|)
name|struct
name|frame_info
modifier|*
name|fci
decl_stmt|;
block|{
specifier|extern
name|struct
name|obstack
name|frame_cache_obstack
decl_stmt|;
comment|/* Use proc_desc calculated in frame_chain */
name|mips_extra_func_info_t
name|proc_desc
init|=
name|fci
operator|->
name|next
condition|?
name|cached_proc_desc
else|:
name|find_proc_desc
argument_list|(
name|fci
operator|->
name|pc
argument_list|,
name|fci
operator|->
name|next
argument_list|)
decl_stmt|;
name|fci
operator|->
name|saved_regs
operator|=
operator|(
expr|struct
name|frame_saved_regs
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|frame_cache_obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|frame_saved_regs
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|fci
operator|->
name|saved_regs
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|frame_saved_regs
argument_list|)
argument_list|)
expr_stmt|;
name|fci
operator|->
name|proc_desc
operator|=
name|proc_desc
operator|==
operator|&
name|temp_proc_desc
condition|?
literal|0
else|:
name|proc_desc
expr_stmt|;
ifdef|#
directive|ifdef
name|KERNELDEBUG
if|if
condition|(
name|kernel_debugging
operator|&&
name|in_trap_handler
argument_list|(
name|fci
operator|->
name|pc
argument_list|)
condition|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|fci
operator|->
name|next
operator|!=
literal|0
condition|)
name|fci
operator|->
name|frame
operator|=
name|READ_FRAME_REG
argument_list|(
name|fci
argument_list|,
name|SP_REGNUM
argument_list|)
expr_stmt|;
else|else
name|fci
operator|->
name|frame
operator|=
name|read_register
argument_list|(
name|SP_REGNUM
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
literal|32
condition|;
operator|++
name|i
control|)
name|fci
operator|->
name|saved_regs
operator|->
name|regs
index|[
name|i
index|]
operator|=
name|fci
operator|->
name|frame
operator|+
literal|4
operator|*
operator|(
literal|3
operator|+
name|i
operator|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
if|if
condition|(
name|proc_desc
condition|)
block|{
name|int
name|ireg
decl_stmt|;
name|CORE_ADDR
name|reg_position
decl_stmt|;
name|unsigned
name|long
name|mask
decl_stmt|;
comment|/* r0 bit means kernel trap */
name|int
name|kernel_trap
init|=
name|PROC_REG_MASK
argument_list|(
name|proc_desc
argument_list|)
operator|&
literal|1
decl_stmt|;
comment|/* Fixup frame-pointer - only needed for top frame */
comment|/* This may not be quite right, if proc has a real frame register */
if|if
condition|(
name|fci
operator|->
name|pc
operator|==
name|PROC_LOW_ADDR
argument_list|(
name|proc_desc
argument_list|)
condition|)
name|fci
operator|->
name|frame
operator|=
name|read_register
argument_list|(
name|SP_REGNUM
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|fci
operator|->
name|next
operator|==
literal|0
condition|)
name|fci
operator|->
name|frame
operator|=
name|read_register
argument_list|(
name|SP_REGNUM
argument_list|)
operator|+
name|PROC_FRAME_OFFSET
argument_list|(
name|proc_desc
argument_list|)
expr_stmt|;
else|else
name|fci
operator|->
name|frame
operator|=
name|READ_FRAME_REG
argument_list|(
name|fci
argument_list|,
name|PROC_FRAME_REG
argument_list|(
name|proc_desc
argument_list|)
argument_list|)
operator|+
name|PROC_FRAME_OFFSET
argument_list|(
name|proc_desc
argument_list|)
expr_stmt|;
if|if
condition|(
name|proc_desc
operator|==
operator|&
name|temp_proc_desc
condition|)
operator|*
name|fci
operator|->
name|saved_regs
operator|=
name|temp_saved_regs
expr_stmt|;
else|else
block|{
comment|/* find which general-purpose registers were saved */
name|reg_position
operator|=
name|fci
operator|->
name|frame
operator|+
name|PROC_REG_OFFSET
argument_list|(
name|proc_desc
argument_list|)
expr_stmt|;
name|mask
operator|=
name|kernel_trap
condition|?
literal|0xFFFFFFFF
else|:
name|PROC_REG_MASK
argument_list|(
name|proc_desc
argument_list|)
expr_stmt|;
for|for
control|(
name|ireg
operator|=
literal|31
init|;
name|mask
condition|;
operator|--
name|ireg
operator|,
name|mask
operator|<<=
literal|1
control|)
if|if
condition|(
name|mask
operator|&
literal|0x80000000
condition|)
block|{
name|fci
operator|->
name|saved_regs
operator|->
name|regs
index|[
name|ireg
index|]
operator|=
name|reg_position
expr_stmt|;
name|reg_position
operator|-=
literal|4
expr_stmt|;
block|}
comment|/* find which floating-point registers were saved */
name|reg_position
operator|=
name|fci
operator|->
name|frame
operator|+
name|PROC_FREG_OFFSET
argument_list|(
name|proc_desc
argument_list|)
expr_stmt|;
comment|/* The freg_offset points to where the first *double* register is saved. 	   * So skip to the high-order word. */
name|reg_position
operator|+=
literal|4
expr_stmt|;
name|mask
operator|=
name|kernel_trap
condition|?
literal|0xFFFFFFFF
else|:
name|PROC_FREG_MASK
argument_list|(
name|proc_desc
argument_list|)
expr_stmt|;
for|for
control|(
name|ireg
operator|=
literal|31
init|;
name|mask
condition|;
operator|--
name|ireg
operator|,
name|mask
operator|<<=
literal|1
control|)
if|if
condition|(
name|mask
operator|&
literal|0x80000000
condition|)
block|{
name|fci
operator|->
name|saved_regs
operator|->
name|regs
index|[
name|FP0_REGNUM
operator|+
name|ireg
index|]
operator|=
name|reg_position
expr_stmt|;
name|reg_position
operator|-=
literal|4
expr_stmt|;
block|}
block|}
comment|/* hack: if argument regs are saved, guess these contain args */
if|if
condition|(
operator|(
name|PROC_REG_MASK
argument_list|(
name|proc_desc
argument_list|)
operator|&
literal|0xF0
operator|)
operator|==
literal|0
condition|)
name|fci
operator|->
name|num_args
operator|=
operator|-
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|PROC_REG_MASK
argument_list|(
name|proc_desc
argument_list|)
operator|&
literal|0x80
operator|)
operator|==
literal|0
condition|)
name|fci
operator|->
name|num_args
operator|=
literal|4
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|PROC_REG_MASK
argument_list|(
name|proc_desc
argument_list|)
operator|&
literal|0x40
operator|)
operator|==
literal|0
condition|)
name|fci
operator|->
name|num_args
operator|=
literal|3
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|PROC_REG_MASK
argument_list|(
name|proc_desc
argument_list|)
operator|&
literal|0x20
operator|)
operator|==
literal|0
condition|)
name|fci
operator|->
name|num_args
operator|=
literal|2
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|PROC_REG_MASK
argument_list|(
name|proc_desc
argument_list|)
operator|&
literal|0x10
operator|)
operator|==
literal|0
condition|)
name|fci
operator|->
name|num_args
operator|=
literal|1
expr_stmt|;
name|fci
operator|->
name|saved_regs
operator|->
name|regs
index|[
name|PC_REGNUM
index|]
operator|=
name|fci
operator|->
name|saved_regs
operator|->
name|regs
index|[
name|RA_REGNUM
index|]
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* MIPS stack frames are almost impenetrable.  When execution stops,    we basically have to look at symbol information for the function    that we stopped in, which tells us *which* register (if any) is    the base of the frame pointer, and what offset from that register    the frame itself is at.       This presents a problem when trying to examine a stack in memory    (that isn't executing at the moment), using the "frame" command.  We    don't have a PC, nor do we have any registers except SP.     This routine takes two arguments, SP and PC, and tries to make the    cached frames look as if these two arguments defined a frame on the    cache.  This allows the rest of info frame to extract the important    arguments without difficulty.  */
end_comment

begin_function
name|FRAME
name|setup_arbitrary_frame
parameter_list|(
name|stack
parameter_list|,
name|pc
parameter_list|)
name|FRAME_ADDR
name|stack
decl_stmt|;
name|CORE_ADDR
name|pc
decl_stmt|;
block|{
return|return
name|create_new_frame
argument_list|(
name|stack
argument_list|,
name|pc
argument_list|)
return|;
block|}
end_function

begin_function
name|CORE_ADDR
name|mips_push_arguments
parameter_list|(
name|nargs
parameter_list|,
name|args
parameter_list|,
name|sp
parameter_list|,
name|struct_return
parameter_list|,
name|struct_addr
parameter_list|)
name|int
name|nargs
decl_stmt|;
name|value
modifier|*
name|args
decl_stmt|;
name|CORE_ADDR
name|sp
decl_stmt|;
name|int
name|struct_return
decl_stmt|;
name|CORE_ADDR
name|struct_addr
decl_stmt|;
block|{
name|CORE_ADDR
name|buf
decl_stmt|;
specifier|register
name|i
expr_stmt|;
name|int
name|accumulate_size
init|=
name|struct_return
condition|?
literal|4
else|:
literal|0
decl_stmt|;
struct|struct
name|mips_arg
block|{
name|char
modifier|*
name|contents
decl_stmt|;
name|int
name|len
decl_stmt|;
name|int
name|offset
decl_stmt|;
block|}
struct|;
name|struct
name|mips_arg
modifier|*
name|mips_args
init|=
operator|(
expr|struct
name|mips_arg
operator|*
operator|)
name|alloca
argument_list|(
name|nargs
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|mips_arg
argument_list|)
argument_list|)
decl_stmt|;
specifier|register
name|struct
name|mips_arg
modifier|*
name|m_arg
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|m_arg
operator|=
name|mips_args
init|;
name|i
operator|<
name|nargs
condition|;
name|i
operator|++
operator|,
name|m_arg
operator|++
control|)
block|{
specifier|extern
name|value
name|value_arg_coerce
parameter_list|()
function_decl|;
name|value
name|arg
init|=
name|value_arg_coerce
argument_list|(
name|args
index|[
name|i
index|]
argument_list|)
decl_stmt|;
name|m_arg
operator|->
name|len
operator|=
name|TYPE_LENGTH
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|)
expr_stmt|;
comment|/* This entire mips-specific routine is because doubles must be aligned      * on 8-byte boundaries. It still isn't quite right, because MIPS decided      * to align 'struct {int a, b}' on 4-byte boundaries (even though this      * breaks their varargs implementation...). A correct solution      * requires an simulation of gcc's 'alignof' (and use of 'alignof'      * in stdarg.h/varargs.h).      */
if|if
condition|(
name|m_arg
operator|->
name|len
operator|>
literal|4
condition|)
name|accumulate_size
operator|=
operator|(
name|accumulate_size
operator|+
literal|7
operator|)
operator|&
operator|-
literal|8
expr_stmt|;
name|m_arg
operator|->
name|offset
operator|=
name|accumulate_size
expr_stmt|;
name|accumulate_size
operator|=
operator|(
name|accumulate_size
operator|+
name|m_arg
operator|->
name|len
operator|+
literal|3
operator|)
operator|&
operator|-
literal|4
expr_stmt|;
name|m_arg
operator|->
name|contents
operator|=
name|VALUE_CONTENTS
argument_list|(
name|arg
argument_list|)
expr_stmt|;
block|}
name|accumulate_size
operator|=
operator|(
name|accumulate_size
operator|+
literal|7
operator|)
operator|&
operator|(
operator|-
literal|8
operator|)
expr_stmt|;
if|if
condition|(
name|accumulate_size
operator|<
literal|16
condition|)
name|accumulate_size
operator|=
literal|16
expr_stmt|;
name|sp
operator|-=
name|accumulate_size
expr_stmt|;
for|for
control|(
name|i
operator|=
name|nargs
init|;
name|m_arg
operator|--
operator|,
operator|--
name|i
operator|>=
literal|0
condition|;
control|)
name|write_memory
argument_list|(
name|sp
operator|+
name|m_arg
operator|->
name|offset
argument_list|,
name|m_arg
operator|->
name|contents
argument_list|,
name|m_arg
operator|->
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|struct_return
condition|)
block|{
name|buf
operator|=
name|struct_addr
expr_stmt|;
name|write_memory
argument_list|(
name|sp
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|CORE_ADDR
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|sp
return|;
block|}
end_function

begin_comment
comment|/* MASK(i,j) == (1<<i) + (1<<(i+1)) + ... + (1<<j)). Assume i<=j<31. */
end_comment

begin_define
define|#
directive|define
name|MASK
parameter_list|(
name|i
parameter_list|,
name|j
parameter_list|)
value|((1<< (j)+1)-1 ^ (1<< (i))-1)
end_define

begin_function
name|void
name|mips_push_dummy_frame
parameter_list|()
block|{
name|int
name|ireg
decl_stmt|;
name|struct
name|linked_proc_info
modifier|*
name|link
init|=
operator|(
expr|struct
name|linked_proc_info
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|linked_proc_info
argument_list|)
argument_list|)
decl_stmt|;
name|mips_extra_func_info_t
name|proc_desc
init|=
operator|&
name|link
operator|->
name|info
decl_stmt|;
name|CORE_ADDR
name|sp
init|=
name|read_register
argument_list|(
name|SP_REGNUM
argument_list|)
decl_stmt|;
name|CORE_ADDR
name|save_address
decl_stmt|;
name|REGISTER_TYPE
name|buffer
decl_stmt|;
name|link
operator|->
name|next
operator|=
name|linked_proc_desc_table
expr_stmt|;
name|linked_proc_desc_table
operator|=
name|link
expr_stmt|;
define|#
directive|define
name|PUSH_FP_REGNUM
value|16
comment|/* must be a register preserved across calls */
define|#
directive|define
name|GEN_REG_SAVE_MASK
value|MASK(1,16)|MASK(24,28)|(1<<31)
define|#
directive|define
name|GEN_REG_SAVE_COUNT
value|22
define|#
directive|define
name|FLOAT_REG_SAVE_MASK
value|MASK(0,19)
define|#
directive|define
name|FLOAT_REG_SAVE_COUNT
value|20
define|#
directive|define
name|SPECIAL_REG_SAVE_COUNT
value|4
comment|/*    * The registers we must save are all those not preserved across    * procedure calls. Dest_Reg (see tm-mips.h) must also be saved.    * In addition, we must save the PC, and PUSH_FP_REGNUM.    * (Ideally, we should also save MDLO/-HI and FP Control/Status reg.)    *    * Dummy frame layout:    *  (high memory)    * 	Saved PC    *	Saved MMHI, MMLO, FPC_CSR    *	Saved R31    *	Saved R28    *	...    *	Saved R1    *    Saved D18 (i.e. F19, F18)    *    ...    *    Saved D0 (i.e. F1, F0)    *	CALL_DUMMY (subroutine stub; see tm-mips.h)    *	Parameter build area (not yet implemented)    *  (low memory)    */
name|PROC_REG_MASK
argument_list|(
name|proc_desc
argument_list|)
operator|=
name|GEN_REG_SAVE_MASK
expr_stmt|;
name|PROC_FREG_MASK
argument_list|(
name|proc_desc
argument_list|)
operator|=
name|FLOAT_REG_SAVE_MASK
expr_stmt|;
name|PROC_REG_OFFSET
argument_list|(
name|proc_desc
argument_list|)
operator|=
comment|/* offset of (Saved R31) from FP */
operator|-
sizeof|sizeof
argument_list|(
name|long
argument_list|)
operator|-
literal|4
operator|*
name|SPECIAL_REG_SAVE_COUNT
expr_stmt|;
name|PROC_FREG_OFFSET
argument_list|(
name|proc_desc
argument_list|)
operator|=
comment|/* offset of (Saved D18) from FP */
operator|-
sizeof|sizeof
argument_list|(
name|double
argument_list|)
operator|-
literal|4
operator|*
operator|(
name|SPECIAL_REG_SAVE_COUNT
operator|+
name|GEN_REG_SAVE_COUNT
operator|)
expr_stmt|;
comment|/* save general registers */
name|save_address
operator|=
name|sp
operator|+
name|PROC_REG_OFFSET
argument_list|(
name|proc_desc
argument_list|)
expr_stmt|;
for|for
control|(
name|ireg
operator|=
literal|32
init|;
operator|--
name|ireg
operator|>=
literal|0
condition|;
control|)
if|if
condition|(
name|PROC_REG_MASK
argument_list|(
name|proc_desc
argument_list|)
operator|&
operator|(
literal|1
operator|<<
name|ireg
operator|)
condition|)
block|{
name|buffer
operator|=
name|read_register
argument_list|(
name|ireg
argument_list|)
expr_stmt|;
name|write_memory
argument_list|(
name|save_address
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|buffer
argument_list|,
sizeof|sizeof
argument_list|(
name|REGISTER_TYPE
argument_list|)
argument_list|)
expr_stmt|;
name|save_address
operator|-=
literal|4
expr_stmt|;
block|}
comment|/* save floating-points registers */
name|save_address
operator|=
name|sp
operator|+
name|PROC_FREG_OFFSET
argument_list|(
name|proc_desc
argument_list|)
expr_stmt|;
for|for
control|(
name|ireg
operator|=
literal|32
init|;
operator|--
name|ireg
operator|>=
literal|0
condition|;
control|)
if|if
condition|(
name|PROC_FREG_MASK
argument_list|(
name|proc_desc
argument_list|)
operator|&
operator|(
literal|1
operator|<<
name|ireg
operator|)
condition|)
block|{
name|buffer
operator|=
name|read_register
argument_list|(
name|ireg
operator|+
name|FP0_REGNUM
argument_list|)
expr_stmt|;
name|write_memory
argument_list|(
name|save_address
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|buffer
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|save_address
operator|-=
literal|4
expr_stmt|;
block|}
name|write_register
argument_list|(
name|PUSH_FP_REGNUM
argument_list|,
name|sp
argument_list|)
expr_stmt|;
name|PROC_FRAME_REG
argument_list|(
name|proc_desc
argument_list|)
operator|=
name|PUSH_FP_REGNUM
expr_stmt|;
name|PROC_FRAME_OFFSET
argument_list|(
name|proc_desc
argument_list|)
operator|=
literal|0
expr_stmt|;
name|buffer
operator|=
name|read_register
argument_list|(
name|PC_REGNUM
argument_list|)
expr_stmt|;
name|write_memory
argument_list|(
name|sp
operator|-
literal|4
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|buffer
argument_list|,
sizeof|sizeof
argument_list|(
name|REGISTER_TYPE
argument_list|)
argument_list|)
expr_stmt|;
name|buffer
operator|=
name|read_register
argument_list|(
name|HI_REGNUM
argument_list|)
expr_stmt|;
name|write_memory
argument_list|(
name|sp
operator|-
literal|8
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|buffer
argument_list|,
sizeof|sizeof
argument_list|(
name|REGISTER_TYPE
argument_list|)
argument_list|)
expr_stmt|;
name|buffer
operator|=
name|read_register
argument_list|(
name|LO_REGNUM
argument_list|)
expr_stmt|;
name|write_memory
argument_list|(
name|sp
operator|-
literal|12
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|buffer
argument_list|,
sizeof|sizeof
argument_list|(
name|REGISTER_TYPE
argument_list|)
argument_list|)
expr_stmt|;
name|buffer
operator|=
name|read_register
argument_list|(
name|FCRCS_REGNUM
argument_list|)
expr_stmt|;
name|write_memory
argument_list|(
name|sp
operator|-
literal|16
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|buffer
argument_list|,
sizeof|sizeof
argument_list|(
name|REGISTER_TYPE
argument_list|)
argument_list|)
expr_stmt|;
name|sp
operator|-=
literal|4
operator|*
operator|(
name|GEN_REG_SAVE_COUNT
operator|+
name|FLOAT_REG_SAVE_COUNT
operator|+
name|SPECIAL_REG_SAVE_COUNT
operator|)
expr_stmt|;
name|write_register
argument_list|(
name|SP_REGNUM
argument_list|,
name|sp
argument_list|)
expr_stmt|;
name|PROC_LOW_ADDR
argument_list|(
name|proc_desc
argument_list|)
operator|=
name|sp
operator|-
name|CALL_DUMMY_SIZE
operator|+
name|CALL_DUMMY_START_OFFSET
expr_stmt|;
name|PROC_HIGH_ADDR
argument_list|(
name|proc_desc
argument_list|)
operator|=
name|sp
expr_stmt|;
name|SET_PROC_DESC_IS_DUMMY
argument_list|(
name|proc_desc
argument_list|)
expr_stmt|;
name|PROC_PC_REG
argument_list|(
name|proc_desc
argument_list|)
operator|=
name|RA_REGNUM
expr_stmt|;
block|}
end_function

begin_function
name|void
name|mips_pop_frame
parameter_list|()
block|{
specifier|register
name|int
name|regnum
decl_stmt|;
name|FRAME
name|frame
init|=
name|get_current_frame
argument_list|()
decl_stmt|;
name|CORE_ADDR
name|new_sp
init|=
name|frame
operator|->
name|frame
decl_stmt|;
name|mips_extra_func_info_t
name|proc_desc
init|=
name|frame
operator|->
name|proc_desc
decl_stmt|;
name|write_register
argument_list|(
name|PC_REGNUM
argument_list|,
name|FRAME_SAVED_PC
argument_list|(
name|frame
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|proc_desc
condition|)
block|{
for|for
control|(
name|regnum
operator|=
literal|32
init|;
operator|--
name|regnum
operator|>=
literal|0
condition|;
control|)
if|if
condition|(
name|PROC_REG_MASK
argument_list|(
name|proc_desc
argument_list|)
operator|&
operator|(
literal|1
operator|<<
name|regnum
operator|)
condition|)
name|write_register
argument_list|(
name|regnum
argument_list|,
name|read_memory_integer
argument_list|(
name|frame
operator|->
name|saved_regs
operator|->
name|regs
index|[
name|regnum
index|]
argument_list|,
literal|4
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|regnum
operator|=
literal|32
init|;
operator|--
name|regnum
operator|>=
literal|0
condition|;
control|)
if|if
condition|(
name|PROC_FREG_MASK
argument_list|(
name|proc_desc
argument_list|)
operator|&
operator|(
literal|1
operator|<<
name|regnum
operator|)
condition|)
name|write_register
argument_list|(
name|regnum
operator|+
name|FP0_REGNUM
argument_list|,
name|read_memory_integer
argument_list|(
name|frame
operator|->
name|saved_regs
operator|->
name|regs
index|[
name|regnum
operator|+
name|FP0_REGNUM
index|]
argument_list|,
literal|4
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|write_register
argument_list|(
name|SP_REGNUM
argument_list|,
name|new_sp
argument_list|)
expr_stmt|;
name|flush_cached_frames
argument_list|()
expr_stmt|;
comment|/* We let mips_init_extra_frame_info figure out the frame pointer */
name|set_current_frame
argument_list|(
name|create_new_frame
argument_list|(
literal|0
argument_list|,
name|read_pc
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|PROC_DESC_IS_DUMMY
argument_list|(
name|proc_desc
argument_list|)
condition|)
block|{
name|struct
name|linked_proc_info
modifier|*
name|pi_ptr
decl_stmt|,
modifier|*
name|prev_ptr
decl_stmt|;
for|for
control|(
name|pi_ptr
operator|=
name|linked_proc_desc_table
operator|,
name|prev_ptr
operator|=
name|NULL
init|;
name|pi_ptr
operator|!=
name|NULL
condition|;
name|prev_ptr
operator|=
name|pi_ptr
operator|,
name|pi_ptr
operator|=
name|pi_ptr
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|&
name|pi_ptr
operator|->
name|info
operator|==
name|proc_desc
condition|)
break|break;
block|}
if|if
condition|(
name|pi_ptr
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|"Can't locate dummy extra frame info\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|prev_ptr
operator|!=
name|NULL
condition|)
name|prev_ptr
operator|->
name|next
operator|=
name|pi_ptr
operator|->
name|next
expr_stmt|;
else|else
name|linked_proc_desc_table
operator|=
name|pi_ptr
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|pi_ptr
argument_list|)
expr_stmt|;
name|write_register
argument_list|(
name|HI_REGNUM
argument_list|,
name|read_memory_integer
argument_list|(
name|new_sp
operator|-
literal|8
argument_list|,
literal|4
argument_list|)
argument_list|)
expr_stmt|;
name|write_register
argument_list|(
name|LO_REGNUM
argument_list|,
name|read_memory_integer
argument_list|(
name|new_sp
operator|-
literal|12
argument_list|,
literal|4
argument_list|)
argument_list|)
expr_stmt|;
name|write_register
argument_list|(
name|FCRCS_REGNUM
argument_list|,
name|read_memory_integer
argument_list|(
name|new_sp
operator|-
literal|16
argument_list|,
literal|4
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|mips_print_register
parameter_list|(
name|regnum
parameter_list|,
name|all
parameter_list|)
name|int
name|regnum
decl_stmt|,
name|all
decl_stmt|;
block|{
name|unsigned
name|char
name|raw_buffer
index|[
name|MAX_REGISTER_RAW_SIZE
operator|*
literal|2
index|]
decl_stmt|;
comment|/* *2 for doubles */
name|REGISTER_TYPE
name|val
decl_stmt|;
comment|/* Get the data in raw format.  */
if|if
condition|(
name|read_relative_register_raw_bytes
argument_list|(
name|regnum
argument_list|,
name|raw_buffer
argument_list|)
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"%s: [Invalid]"
argument_list|,
name|reg_names
index|[
name|regnum
index|]
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* If an even floating pointer register, also print as double. */
if|if
condition|(
name|regnum
operator|>=
name|FP0_REGNUM
operator|&&
name|regnum
operator|<
name|FP0_REGNUM
operator|+
literal|32
operator|&&
operator|!
operator|(
operator|(
name|regnum
operator|-
name|FP0_REGNUM
operator|)
operator|&
literal|1
operator|)
condition|)
block|{
name|read_relative_register_raw_bytes
argument_list|(
name|regnum
operator|+
literal|1
argument_list|,
name|raw_buffer
operator|+
literal|4
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"(d%d: "
argument_list|,
name|regnum
operator|-
name|FP0_REGNUM
argument_list|)
expr_stmt|;
name|val_print
argument_list|(
name|builtin_type_double
argument_list|,
name|raw_buffer
argument_list|,
literal|0
argument_list|,
name|stdout
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|Val_pretty_default
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"); "
argument_list|)
expr_stmt|;
block|}
name|fputs_filtered
argument_list|(
name|reg_names
index|[
name|regnum
index|]
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|NUMERIC_REG_NAMES
if|if
condition|(
name|regnum
operator|<
literal|32
condition|)
name|printf_filtered
argument_list|(
literal|"(r%d): "
argument_list|,
name|regnum
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
name|printf_filtered
argument_list|(
literal|": "
argument_list|)
expr_stmt|;
comment|/* If virtual format is floating, print it that way.  */
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|REGISTER_VIRTUAL_TYPE
argument_list|(
name|regnum
argument_list|)
argument_list|)
operator|==
name|TYPE_CODE_FLT
operator|&&
operator|!
name|INVALID_FLOAT
argument_list|(
name|raw_buffer
argument_list|,
name|REGISTER_VIRTUAL_SIZE
argument_list|(
name|regnum
argument_list|)
argument_list|)
condition|)
block|{
name|val_print
argument_list|(
name|REGISTER_VIRTUAL_TYPE
argument_list|(
name|regnum
argument_list|)
argument_list|,
name|raw_buffer
argument_list|,
literal|0
argument_list|,
name|stdout
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|Val_pretty_default
argument_list|)
expr_stmt|;
block|}
comment|/* Else print as integer in hex.  */
else|else
block|{
name|long
name|val
decl_stmt|;
name|bcopy
argument_list|(
name|raw_buffer
argument_list|,
operator|&
name|val
argument_list|,
sizeof|sizeof
argument_list|(
name|long
argument_list|)
argument_list|)
expr_stmt|;
name|SWAP_TARGET_AND_HOST
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|val
argument_list|,
sizeof|sizeof
argument_list|(
name|long
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|==
literal|0
condition|)
name|printf_filtered
argument_list|(
literal|"0"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|all
condition|)
name|printf_filtered
argument_list|(
name|local_hex_format
argument_list|()
argument_list|,
name|val
argument_list|)
expr_stmt|;
else|else
name|printf_filtered
argument_list|(
literal|"%s=%d"
argument_list|,
name|local_hex_string
argument_list|(
name|val
argument_list|)
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Replacement for generic do_registers_info.  */
end_comment

begin_function
name|void
name|mips_do_registers_info
parameter_list|(
name|regnum
parameter_list|,
name|fpregs
parameter_list|)
name|int
name|regnum
decl_stmt|;
name|int
name|fpregs
decl_stmt|;
block|{
if|if
condition|(
name|regnum
operator|!=
operator|-
literal|1
condition|)
block|{
name|mips_print_register
argument_list|(
name|regnum
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|regnum
operator|=
literal|0
init|;
name|regnum
operator|<
name|NUM_REGS
condition|;
control|)
block|{
if|if
condition|(
operator|(
operator|!
name|fpregs
operator|)
operator|&&
name|regnum
operator|>=
name|FP0_REGNUM
operator|&&
name|regnum
operator|<=
name|FCRIR_REGNUM
condition|)
block|{
name|regnum
operator|++
expr_stmt|;
continue|continue;
block|}
name|mips_print_register
argument_list|(
name|regnum
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|regnum
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|regnum
operator|&
literal|3
operator|)
operator|==
literal|0
operator|||
name|regnum
operator|==
name|NUM_REGS
condition|)
name|printf_filtered
argument_list|(
literal|";\n"
argument_list|)
expr_stmt|;
else|else
name|printf_filtered
argument_list|(
literal|"; "
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Return number of args passed to a frame. described by FIP.    Can return -1, meaning no way to tell.  */
end_comment

begin_function
name|int
name|mips_frame_num_args
parameter_list|(
name|fip
parameter_list|)
name|FRAME
name|fip
decl_stmt|;
block|{
if|#
directive|if
literal|0
block|struct chain_info_t *p;  	p = mips_find_cached_frame(FRAME_FP(fip)); 	if (p->valid) 		return p->the_info.numargs;
endif|#
directive|endif
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Bad floats: Returns 0 if P points to a valid IEEE floating point number,    1 if P points to a denormalized number or a NaN. LEN says whether this is    a single-precision or double-precision float */
end_comment

begin_define
define|#
directive|define
name|SINGLE_EXP_BITS
value|8
end_define

begin_define
define|#
directive|define
name|DOUBLE_EXP_BITS
value|11
end_define

begin_function
name|int
name|isa_NAN
parameter_list|(
name|p
parameter_list|,
name|len
parameter_list|)
name|int
modifier|*
name|p
decl_stmt|,
name|len
decl_stmt|;
block|{
name|int
name|exponent
decl_stmt|;
if|if
condition|(
name|len
operator|==
literal|4
condition|)
block|{
name|exponent
operator|=
operator|*
name|p
expr_stmt|;
name|exponent
operator|=
name|exponent
operator|<<
literal|1
operator|>>
operator|(
literal|32
operator|-
name|SINGLE_EXP_BITS
operator|-
literal|1
operator|)
expr_stmt|;
return|return
operator|(
operator|(
name|exponent
operator|==
operator|-
literal|1
operator|)
operator|||
operator|(
operator|!
name|exponent
operator|&&
operator|*
name|p
operator|)
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|len
operator|==
literal|8
condition|)
block|{
name|exponent
operator|=
operator|*
operator|(
name|p
operator|+
literal|1
operator|)
expr_stmt|;
name|exponent
operator|=
name|exponent
operator|<<
literal|1
operator|>>
operator|(
literal|32
operator|-
name|DOUBLE_EXP_BITS
operator|-
literal|1
operator|)
expr_stmt|;
return|return
operator|(
operator|(
name|exponent
operator|==
operator|-
literal|1
operator|)
operator|||
operator|(
operator|!
name|exponent
operator|&&
operator|*
name|p
operator|*
operator|*
operator|(
name|p
operator|+
literal|1
operator|)
operator|)
operator|)
return|;
block|}
else|else
return|return
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* To skip prologues, I use this predicate. Returns either PC    itself if the code at PC does not look like a function prologue,    PC+4 if it does (our caller does not need anything more fancy). */
end_comment

begin_function
name|CORE_ADDR
name|mips_skip_prologue
parameter_list|(
name|pc
parameter_list|)
name|CORE_ADDR
name|pc
decl_stmt|;
block|{
name|struct
name|symbol
modifier|*
name|f
decl_stmt|;
name|struct
name|block
modifier|*
name|b
decl_stmt|;
name|unsigned
name|long
name|inst
decl_stmt|;
name|int
name|offset
decl_stmt|;
comment|/* For -g modules and most functions anyways the        first instruction adjusts the stack.        But we allow some number of stores before the stack adjustment.        (These are emitted by varags functions compiled by gcc-2.0. */
for|for
control|(
name|offset
operator|=
literal|0
init|;
name|offset
operator|<
literal|100
condition|;
name|offset
operator|+=
literal|4
control|)
block|{
name|inst
operator|=
name|read_memory_integer
argument_list|(
name|pc
operator|+
name|offset
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|inst
operator|&
literal|0xffff0000
operator|)
operator|==
literal|0x27bd0000
condition|)
comment|/* addiu $sp,$sp,offset */
return|return
name|pc
operator|+
name|offset
operator|+
literal|4
return|;
if|if
condition|(
operator|(
name|inst
operator|&
literal|0xFFE00000
operator|)
operator|!=
literal|0xAFA00000
condition|)
comment|/* sw reg,n($sp) */
break|break;
block|}
comment|/* Well, it looks like a frameless. Let's make sure.        Note that we are not called on the current PC,        but on the function`s start PC, and I have definitely        seen optimized code that adjusts the SP quite later */
name|b
operator|=
name|block_for_pc
argument_list|(
name|pc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|b
condition|)
return|return
name|pc
return|;
name|f
operator|=
name|lookup_symbol
argument_list|(
name|MIPS_EFI_SYMBOL_NAME
argument_list|,
name|b
argument_list|,
name|LABEL_NAMESPACE
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|f
condition|)
return|return
name|pc
return|;
comment|/* Ideally, I would like to use the adjusted info        from mips_frame_info(), but for all practical        purposes it will not matter (and it would require        a different definition of SKIP_PROLOGUE())         Actually, it would not hurt to skip the storing        of arguments on the stack as well. */
if|if
condition|(
operator|(
operator|(
name|mips_extra_func_info_t
operator|)
name|SYMBOL_VALUE
argument_list|(
name|f
argument_list|)
operator|)
operator|->
name|pdr
operator|.
name|frameoffset
condition|)
return|return
name|pc
operator|+
literal|4
return|;
return|return
name|pc
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|KERNELDEBUG
end_ifdef

begin_comment
comment|/*XXX*/
end_comment

begin_decl_stmt
name|CORE_ADDR
name|intstack_top
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|CORE_ADDR
name|intstack_bottom
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|CORE_ADDR
name|kernstack_top
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|CORE_ADDR
name|kernstack_bottom
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|CORE_ADDR
name|trap_pc_start
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|CORE_ADDR
name|trap_pc_end
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|in_trap_handler
parameter_list|(
name|pc
parameter_list|)
name|CORE_ADDR
name|pc
decl_stmt|;
block|{
return|return
operator|(
name|pc
operator|>=
name|trap_pc_start
operator|&&
name|pc
operator|<=
name|trap_pc_end
operator|)
return|;
block|}
end_function

begin_function
name|int
name|inside_kernstack
parameter_list|(
name|addr
parameter_list|)
name|CORE_ADDR
name|addr
decl_stmt|;
block|{
return|return
operator|(
name|addr
operator|<
name|kernstack_top
operator|&&
name|addr
operator|>=
name|kernstack_bottom
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * (re-)set the variables that make inside_kernstack() work.  */
end_comment

begin_function
name|void
name|set_kernel_boundaries
parameter_list|()
block|{
if|if
condition|(
name|trap_pc_start
operator|==
literal|0
condition|)
block|{
name|trap_pc_start
operator|=
name|ksym_lookup
argument_list|(
literal|"trap_handler_start"
argument_list|)
expr_stmt|;
name|trap_pc_end
operator|=
name|ksym_lookup
argument_list|(
literal|"trap_handler_end"
argument_list|)
expr_stmt|;
block|}
name|kernstack_bottom
operator|=
name|UADDR
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|user
argument_list|)
expr_stmt|;
name|kernstack_top
operator|=
name|KERNELSTACK
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Called from remote_wait, after the remote kernel has stopped.  * Look up the current proc, and set up boundaries.  * This is for active kernels only.  */
end_comment

begin_function
name|void
name|set_curproc
parameter_list|()
block|{
ifdef|#
directive|ifdef
name|notdef
name|cpudata
operator|=
name|fetch_cpudata
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|set_kernel_boundaries
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Fetch registers from a crashdump or /dev/kmem.  */
end_comment

begin_function
name|void
name|kvm_fetch_registers
parameter_list|(
name|uaddr
parameter_list|)
name|CORE_ADDR
name|uaddr
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|u_long
name|cps
decl_stmt|,
name|reg
decl_stmt|,
name|sp
decl_stmt|;
name|float
name|freg
decl_stmt|;
name|struct
name|pcb
name|pcb
decl_stmt|;
if|if
condition|(
name|target_read_memory
argument_list|(
name|uaddr
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|pcb
argument_list|,
sizeof|sizeof
argument_list|(
name|pcb
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
name|error
argument_list|(
literal|"cannot read pcb at 0x%x"
argument_list|,
name|uaddr
argument_list|)
expr_stmt|;
comment|/* 	 * Invalidate all the registers then fill in the ones we know about. 	 */
name|registers_changed
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|32
condition|;
operator|++
name|i
control|)
name|supply_register
argument_list|(
name|i
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|pcb
operator|.
name|pcb_regs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|supply_register
argument_list|(
name|PC_REGNUM
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|pcb
operator|.
name|pcb_pc
argument_list|)
expr_stmt|;
name|supply_register
argument_list|(
name|PS_REGNUM
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|pcb
operator|.
name|pcb_sr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Set the process context to that of the proc structure at  * system address paddr.  Read in the register state.  */
end_comment

begin_function
name|int
name|set_procaddr
parameter_list|(
name|addr
parameter_list|)
name|CORE_ADDR
name|addr
decl_stmt|;
block|{
if|if
condition|(
name|addr
operator|==
literal|0
condition|)
name|addr
operator|=
name|ksym_lookup
argument_list|(
literal|"u"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|notdef
if|if
condition|(
name|addr
operator|<
name|KERNELBASE
condition|)
return|return
operator|(
literal|1
operator|)
return|;
endif|#
directive|endif
name|set_kernel_boundaries
argument_list|()
expr_stmt|;
name|kvm_fetch_registers
argument_list|(
name|addr
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Get the registers out of a crashdump or /dev/kmem.  * XXX This somehow belongs in kcore.c.  *  * We just get all the registers, so we don't use regno.  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|void
name|kernel_core_registers
parameter_list|(
name|regno
parameter_list|)
name|int
name|regno
decl_stmt|;
block|{
comment|/* 	 * Need to find current u area to get kernel stack and pcb 	 * where "panic" saved registers. 	 * (libkvm also needs to know current u area to get user 	 * address space mapping). 	 */
comment|/* XXX */
operator|(
name|void
operator|)
name|set_procaddr
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

