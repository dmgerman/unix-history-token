begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Print Motorola 68k instructions for GDB, the GNU debugger.    Copyright 1986, 1987, 1989, 1991, 1992 Free Software Foundation, Inc.  This file is part of GDB.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"symtab.h"
end_include

begin_include
include|#
directive|include
file|"opcode/m68k.h"
end_include

begin_include
include|#
directive|include
file|"gdbcore.h"
end_include

begin_include
include|#
directive|include
file|"ieee-float.h"
end_include

begin_comment
comment|/* Local function prototypes */
end_comment

begin_decl_stmt
specifier|static
name|int
name|fetch_arg
name|PARAMS
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|print_base
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|int
operator|,
name|FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|char
modifier|*
name|print_indexed
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|unsigned
name|char
operator|*
operator|,
name|CORE_ADDR
operator|,
name|FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|char
modifier|*
name|print_insn_arg
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|unsigned
name|char
operator|*
operator|,
name|unsigned
name|char
operator|*
operator|,
name|CORE_ADDR
operator|,
name|FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 68k instructions are never longer than this many bytes.  */
end_comment

begin_define
define|#
directive|define
name|MAXLEN
value|22
end_define

begin_comment
comment|/* Number of elements in the opcode table.  */
end_comment

begin_define
define|#
directive|define
name|NOPCODES
value|(sizeof m68k_opcodes / sizeof m68k_opcodes[0])
end_define

begin_decl_stmt
specifier|const
name|char
modifier|*
specifier|const
name|fpcr_names
index|[]
init|=
block|{
literal|""
block|,
literal|"fpiar"
block|,
literal|"fpsr"
block|,
literal|"fpiar/fpsr"
block|,
literal|"fpcr"
block|,
literal|"fpiar/fpcr"
block|,
literal|"fpsr/fpcr"
block|,
literal|"fpiar/fpsr/fpcr"
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Define accessors for 68K's 1, 2, and 4-byte signed quantities.    The _SHIFT values move the quantity to the high order end of an    `int' value, so it will sign-extend.  Probably a few more casts    are needed to make it compile without warnings on finicky systems.  */
end_comment

begin_define
define|#
directive|define
name|BITS_PER_BYTE
value|8
end_define

begin_define
define|#
directive|define
name|BYTE_SHIFT
value|(BITS_PER_BYTE * ((sizeof (int)) - 1))
end_define

begin_define
define|#
directive|define
name|WORD_SHIFT
value|(BITS_PER_BYTE * ((sizeof (int)) - 2))
end_define

begin_define
define|#
directive|define
name|LONG_SHIFT
value|(BITS_PER_BYTE * ((sizeof (int)) - 4))
end_define

begin_define
define|#
directive|define
name|NEXTBYTE
parameter_list|(
name|p
parameter_list|)
value|(p += 2, ((int)(p[-1])<< BYTE_SHIFT)>> BYTE_SHIFT)
end_define

begin_define
define|#
directive|define
name|NEXTWORD
parameter_list|(
name|p
parameter_list|)
define|\
value|(p += 2, (((int)((p[-2]<< 8) + p[-1]))<< WORD_SHIFT)>> WORD_SHIFT)
end_define

begin_define
define|#
directive|define
name|NEXTLONG
parameter_list|(
name|p
parameter_list|)
define|\
value|(p += 4, (((int)((((((p[-4]<< 8) + p[-3])<< 8) + p[-2])<< 8) + p[-1])) \<< LONG_SHIFT)>> LONG_SHIFT)
end_define

begin_comment
comment|/* Ecch -- assumes host == target float formats.  FIXME.  */
end_comment

begin_define
define|#
directive|define
name|NEXTSINGLE
parameter_list|(
name|p
parameter_list|)
define|\
value|(p += 4, *((float *)(p - 4)))
end_define

begin_define
define|#
directive|define
name|NEXTDOUBLE
parameter_list|(
name|p
parameter_list|)
define|\
value|(p += 8, *((double *)(p - 8)))
end_define

begin_escape
end_escape

begin_comment
comment|/* Print the m68k instruction at address MEMADDR in debugged memory,    on STREAM.  Returns length of the instruction, in bytes.  */
end_comment

begin_function
name|int
name|print_insn
parameter_list|(
name|memaddr
parameter_list|,
name|stream
parameter_list|)
name|CORE_ADDR
name|memaddr
decl_stmt|;
name|FILE
modifier|*
name|stream
decl_stmt|;
block|{
name|unsigned
name|char
name|buffer
index|[
name|MAXLEN
index|]
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|unsigned
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|char
modifier|*
name|d
decl_stmt|;
specifier|register
name|int
name|bestmask
decl_stmt|;
name|int
name|best
decl_stmt|;
name|read_memory
argument_list|(
name|memaddr
argument_list|,
operator|(
name|char
operator|*
operator|)
name|buffer
argument_list|,
name|MAXLEN
argument_list|)
expr_stmt|;
name|bestmask
operator|=
literal|0
expr_stmt|;
name|best
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NOPCODES
condition|;
name|i
operator|++
control|)
block|{
specifier|register
name|unsigned
name|int
name|opcode
init|=
name|m68k_opcodes
index|[
name|i
index|]
operator|.
name|opcode
decl_stmt|;
specifier|register
name|unsigned
name|int
name|match
init|=
name|m68k_opcodes
index|[
name|i
index|]
operator|.
name|match
decl_stmt|;
if|if
condition|(
operator|(
operator|(
literal|0xff
operator|&
name|buffer
index|[
literal|0
index|]
operator|&
operator|(
name|match
operator|>>
literal|24
operator|)
operator|)
operator|==
operator|(
literal|0xff
operator|&
operator|(
name|opcode
operator|>>
literal|24
operator|)
operator|)
operator|)
operator|&&
operator|(
operator|(
literal|0xff
operator|&
name|buffer
index|[
literal|1
index|]
operator|&
operator|(
name|match
operator|>>
literal|16
operator|)
operator|)
operator|==
operator|(
literal|0xff
operator|&
operator|(
name|opcode
operator|>>
literal|16
operator|)
operator|)
operator|)
operator|&&
operator|(
operator|(
literal|0xff
operator|&
name|buffer
index|[
literal|2
index|]
operator|&
operator|(
name|match
operator|>>
literal|8
operator|)
operator|)
operator|==
operator|(
literal|0xff
operator|&
operator|(
name|opcode
operator|>>
literal|8
operator|)
operator|)
operator|)
operator|&&
operator|(
operator|(
literal|0xff
operator|&
name|buffer
index|[
literal|3
index|]
operator|&
name|match
operator|)
operator|==
operator|(
literal|0xff
operator|&
name|opcode
operator|)
operator|)
condition|)
block|{
comment|/* Don't use for printout the variants of divul and divsl 	     that have the same register number in two places. 	     The more general variants will match instead.  */
for|for
control|(
name|d
operator|=
name|m68k_opcodes
index|[
name|i
index|]
operator|.
name|args
init|;
operator|*
name|d
condition|;
name|d
operator|+=
literal|2
control|)
if|if
condition|(
name|d
index|[
literal|1
index|]
operator|==
literal|'D'
condition|)
break|break;
comment|/* Don't use for printout the variants of most floating 	     point coprocessor instructions which use the same 	     register number in two places, as above. */
if|if
condition|(
operator|*
name|d
operator|==
literal|0
condition|)
for|for
control|(
name|d
operator|=
name|m68k_opcodes
index|[
name|i
index|]
operator|.
name|args
init|;
operator|*
name|d
condition|;
name|d
operator|+=
literal|2
control|)
if|if
condition|(
name|d
index|[
literal|1
index|]
operator|==
literal|'t'
condition|)
break|break;
if|if
condition|(
operator|*
name|d
operator|==
literal|0
operator|&&
name|match
operator|>
name|bestmask
condition|)
block|{
name|best
operator|=
name|i
expr_stmt|;
name|bestmask
operator|=
name|match
expr_stmt|;
block|}
block|}
block|}
comment|/* Handle undefined instructions.  */
if|if
condition|(
name|best
operator|<
literal|0
condition|)
block|{
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"0%o"
argument_list|,
operator|(
name|buffer
index|[
literal|0
index|]
operator|<<
literal|8
operator|)
operator|+
name|buffer
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
literal|2
return|;
block|}
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"%s"
argument_list|,
name|m68k_opcodes
index|[
name|best
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
comment|/* Point at first word of argument data,      and at descriptor for first argument.  */
name|p
operator|=
name|buffer
operator|+
literal|2
expr_stmt|;
comment|/* Why do this this way? -MelloN */
for|for
control|(
name|d
operator|=
name|m68k_opcodes
index|[
name|best
index|]
operator|.
name|args
init|;
operator|*
name|d
condition|;
name|d
operator|+=
literal|2
control|)
block|{
if|if
condition|(
name|d
index|[
literal|0
index|]
operator|==
literal|'#'
condition|)
block|{
if|if
condition|(
name|d
index|[
literal|1
index|]
operator|==
literal|'l'
operator|&&
name|p
operator|-
name|buffer
operator|<
literal|6
condition|)
name|p
operator|=
name|buffer
operator|+
literal|6
expr_stmt|;
elseif|else
if|if
condition|(
name|p
operator|-
name|buffer
operator|<
literal|4
operator|&&
name|d
index|[
literal|1
index|]
operator|!=
literal|'C'
operator|&&
name|d
index|[
literal|1
index|]
operator|!=
literal|'8'
condition|)
name|p
operator|=
name|buffer
operator|+
literal|4
expr_stmt|;
block|}
if|if
condition|(
name|d
index|[
literal|1
index|]
operator|>=
literal|'1'
operator|&&
name|d
index|[
literal|1
index|]
operator|<=
literal|'3'
operator|&&
name|p
operator|-
name|buffer
operator|<
literal|4
condition|)
name|p
operator|=
name|buffer
operator|+
literal|4
expr_stmt|;
if|if
condition|(
name|d
index|[
literal|1
index|]
operator|>=
literal|'4'
operator|&&
name|d
index|[
literal|1
index|]
operator|<=
literal|'6'
operator|&&
name|p
operator|-
name|buffer
operator|<
literal|6
condition|)
name|p
operator|=
name|buffer
operator|+
literal|6
expr_stmt|;
if|if
condition|(
operator|(
name|d
index|[
literal|0
index|]
operator|==
literal|'L'
operator|||
name|d
index|[
literal|0
index|]
operator|==
literal|'l'
operator|)
operator|&&
name|d
index|[
literal|1
index|]
operator|==
literal|'w'
operator|&&
name|p
operator|-
name|buffer
operator|<
literal|4
condition|)
name|p
operator|=
name|buffer
operator|+
literal|4
expr_stmt|;
block|}
name|d
operator|=
name|m68k_opcodes
index|[
name|best
index|]
operator|.
name|args
expr_stmt|;
if|if
condition|(
operator|*
name|d
condition|)
name|fputs_filtered
argument_list|(
literal|" "
argument_list|,
name|stream
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|d
condition|)
block|{
name|p
operator|=
name|print_insn_arg
argument_list|(
name|d
argument_list|,
name|buffer
argument_list|,
name|p
argument_list|,
name|memaddr
operator|+
name|p
operator|-
name|buffer
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|d
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
operator|*
name|d
operator|&&
operator|*
operator|(
name|d
operator|-
literal|2
operator|)
operator|!=
literal|'I'
operator|&&
operator|*
name|d
operator|!=
literal|'k'
condition|)
name|fputs_filtered
argument_list|(
literal|","
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
return|return
name|p
operator|-
name|buffer
return|;
block|}
end_function

begin_function
specifier|static
name|unsigned
name|char
modifier|*
name|print_insn_arg
parameter_list|(
name|d
parameter_list|,
name|buffer
parameter_list|,
name|p
parameter_list|,
name|addr
parameter_list|,
name|stream
parameter_list|)
name|char
modifier|*
name|d
decl_stmt|;
name|unsigned
name|char
modifier|*
name|buffer
decl_stmt|;
specifier|register
name|unsigned
name|char
modifier|*
name|p
decl_stmt|;
name|CORE_ADDR
name|addr
decl_stmt|;
comment|/* PC for this arg to be relative to */
name|FILE
modifier|*
name|stream
decl_stmt|;
block|{
specifier|register
name|int
name|val
decl_stmt|;
specifier|register
name|int
name|place
init|=
name|d
index|[
literal|1
index|]
decl_stmt|;
name|int
name|regno
decl_stmt|;
specifier|register
specifier|const
name|char
modifier|*
name|regname
decl_stmt|;
specifier|register
name|unsigned
name|char
modifier|*
name|p1
decl_stmt|;
name|double
name|flval
decl_stmt|;
name|int
name|flt_p
decl_stmt|;
switch|switch
condition|(
operator|*
name|d
condition|)
block|{
case|case
literal|'c'
case|:
comment|/* cache identifier */
block|{
specifier|static
name|char
modifier|*
name|cacheFieldName
index|[]
init|=
block|{
literal|"NOP"
block|,
literal|"dc"
block|,
literal|"ic"
block|,
literal|"bc"
block|}
decl_stmt|;
name|val
operator|=
name|fetch_arg
argument_list|(
name|buffer
argument_list|,
name|place
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
name|cacheFieldName
index|[
name|val
index|]
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
literal|'a'
case|:
comment|/* address register indirect only. Cf. case '+'. */
block|{
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"%s@"
argument_list|,
name|reg_names
index|[
name|fetch_arg
argument_list|(
name|buffer
argument_list|,
name|place
argument_list|,
literal|3
argument_list|)
operator|+
literal|8
index|]
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
literal|'_'
case|:
comment|/* 32-bit absolute address for move16. */
block|{
name|val
operator|=
name|NEXTLONG
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"@#"
argument_list|)
expr_stmt|;
name|print_address
argument_list|(
name|val
argument_list|,
name|stream
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
literal|'C'
case|:
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"ccr"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'S'
case|:
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"sr"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'U'
case|:
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"usp"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'J'
case|:
block|{
specifier|static
struct|struct
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|value
decl_stmt|;
block|}
name|names
index|[]
init|=
block|{
block|{
literal|"sfc"
block|,
literal|0x000
block|}
block|,
block|{
literal|"dfc"
block|,
literal|0x001
block|}
block|,
block|{
literal|"cacr"
block|,
literal|0x002
block|}
block|,
block|{
literal|"tc"
block|,
literal|0x003
block|}
block|,
block|{
literal|"itt0"
block|,
literal|0x004
block|}
block|,
block|{
literal|"itt1"
block|,
literal|0x005
block|}
block|,
block|{
literal|"dtt0"
block|,
literal|0x006
block|}
block|,
block|{
literal|"dtt1"
block|,
literal|0x007
block|}
block|,
block|{
literal|"usp"
block|,
literal|0x800
block|}
block|,
block|{
literal|"vbr"
block|,
literal|0x801
block|}
block|,
block|{
literal|"caar"
block|,
literal|0x802
block|}
block|,
block|{
literal|"msp"
block|,
literal|0x803
block|}
block|,
block|{
literal|"isp"
block|,
literal|0x804
block|}
block|,
block|{
literal|"mmusr"
block|,
literal|0x805
block|}
block|,
block|{
literal|"urp"
block|,
literal|0x806
block|}
block|,
block|{
literal|"srp"
block|,
literal|0x807
block|}
block|}
struct|;
name|val
operator|=
name|fetch_arg
argument_list|(
name|buffer
argument_list|,
name|place
argument_list|,
literal|12
argument_list|)
expr_stmt|;
for|for
control|(
name|regno
operator|=
sizeof|sizeof
name|names
operator|/
sizeof|sizeof
name|names
index|[
literal|0
index|]
operator|-
literal|1
init|;
name|regno
operator|>=
literal|0
condition|;
name|regno
operator|--
control|)
if|if
condition|(
name|names
index|[
name|regno
index|]
operator|.
name|value
operator|==
name|val
condition|)
block|{
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
name|names
index|[
name|regno
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|regno
operator|<
literal|0
condition|)
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"%d"
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'Q'
case|:
name|val
operator|=
name|fetch_arg
argument_list|(
name|buffer
argument_list|,
name|place
argument_list|,
literal|3
argument_list|)
expr_stmt|;
comment|/* 0 means 8, except for the bkpt instruction... */
if|if
condition|(
name|val
operator|==
literal|0
operator|&&
name|d
index|[
literal|1
index|]
operator|!=
literal|'s'
condition|)
name|val
operator|=
literal|8
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"#%d"
argument_list|,
name|val
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'M'
case|:
name|val
operator|=
name|fetch_arg
argument_list|(
name|buffer
argument_list|,
name|place
argument_list|,
literal|8
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|&
literal|0x80
condition|)
name|val
operator|=
name|val
operator|-
literal|0x100
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"#%d"
argument_list|,
name|val
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'T'
case|:
name|val
operator|=
name|fetch_arg
argument_list|(
name|buffer
argument_list|,
name|place
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"#%d"
argument_list|,
name|val
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'D'
case|:
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"%s"
argument_list|,
name|reg_names
index|[
name|fetch_arg
argument_list|(
name|buffer
argument_list|,
name|place
argument_list|,
literal|3
argument_list|)
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'A'
case|:
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"%s"
argument_list|,
name|reg_names
index|[
name|fetch_arg
argument_list|(
name|buffer
argument_list|,
name|place
argument_list|,
literal|3
argument_list|)
operator|+
literal|010
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'R'
case|:
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"%s"
argument_list|,
name|reg_names
index|[
name|fetch_arg
argument_list|(
name|buffer
argument_list|,
name|place
argument_list|,
literal|4
argument_list|)
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"%s@"
argument_list|,
name|reg_names
index|[
name|fetch_arg
argument_list|(
name|buffer
argument_list|,
name|place
argument_list|,
literal|4
argument_list|)
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'F'
case|:
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"fp%d"
argument_list|,
name|fetch_arg
argument_list|(
name|buffer
argument_list|,
name|place
argument_list|,
literal|3
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'O'
case|:
name|val
operator|=
name|fetch_arg
argument_list|(
name|buffer
argument_list|,
name|place
argument_list|,
literal|6
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|&
literal|0x20
condition|)
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"%s"
argument_list|,
name|reg_names
index|[
name|val
operator|&
literal|7
index|]
argument_list|)
expr_stmt|;
else|else
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"%d"
argument_list|,
name|val
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'+'
case|:
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"%s@+"
argument_list|,
name|reg_names
index|[
name|fetch_arg
argument_list|(
name|buffer
argument_list|,
name|place
argument_list|,
literal|3
argument_list|)
operator|+
literal|8
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'-'
case|:
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"%s@-"
argument_list|,
name|reg_names
index|[
name|fetch_arg
argument_list|(
name|buffer
argument_list|,
name|place
argument_list|,
literal|3
argument_list|)
operator|+
literal|8
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'k'
case|:
if|if
condition|(
name|place
operator|==
literal|'k'
condition|)
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"{%s}"
argument_list|,
name|reg_names
index|[
name|fetch_arg
argument_list|(
name|buffer
argument_list|,
name|place
argument_list|,
literal|3
argument_list|)
index|]
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|place
operator|==
literal|'C'
condition|)
block|{
name|val
operator|=
name|fetch_arg
argument_list|(
name|buffer
argument_list|,
name|place
argument_list|,
literal|7
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|>
literal|63
condition|)
comment|/* This is a signed constant. */
name|val
operator|-=
literal|128
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"{#%d}"
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
else|else
name|error
argument_list|(
literal|"Invalid arg format in opcode table: \"%c%c\"."
argument_list|,
operator|*
name|d
argument_list|,
name|place
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'#'
case|:
case|case
literal|'^'
case|:
name|p1
operator|=
name|buffer
operator|+
operator|(
operator|*
name|d
operator|==
literal|'#'
condition|?
literal|2
else|:
literal|4
operator|)
expr_stmt|;
if|if
condition|(
name|place
operator|==
literal|'s'
condition|)
name|val
operator|=
name|fetch_arg
argument_list|(
name|buffer
argument_list|,
name|place
argument_list|,
literal|4
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|place
operator|==
literal|'C'
condition|)
name|val
operator|=
name|fetch_arg
argument_list|(
name|buffer
argument_list|,
name|place
argument_list|,
literal|7
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|place
operator|==
literal|'8'
condition|)
name|val
operator|=
name|fetch_arg
argument_list|(
name|buffer
argument_list|,
name|place
argument_list|,
literal|3
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|place
operator|==
literal|'3'
condition|)
name|val
operator|=
name|fetch_arg
argument_list|(
name|buffer
argument_list|,
name|place
argument_list|,
literal|8
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|place
operator|==
literal|'b'
condition|)
name|val
operator|=
name|NEXTBYTE
argument_list|(
name|p1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|place
operator|==
literal|'w'
condition|)
name|val
operator|=
name|NEXTWORD
argument_list|(
name|p1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|place
operator|==
literal|'l'
condition|)
name|val
operator|=
name|NEXTLONG
argument_list|(
name|p1
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"Invalid arg format in opcode table: \"%c%c\"."
argument_list|,
operator|*
name|d
argument_list|,
name|place
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"#%d"
argument_list|,
name|val
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'B'
case|:
if|if
condition|(
name|place
operator|==
literal|'b'
condition|)
name|val
operator|=
name|NEXTBYTE
argument_list|(
name|p
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|place
operator|==
literal|'B'
condition|)
name|val
operator|=
name|NEXTBYTE
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
comment|/* from the opcode word */
elseif|else
if|if
condition|(
name|place
operator|==
literal|'w'
operator|||
name|place
operator|==
literal|'W'
condition|)
name|val
operator|=
name|NEXTWORD
argument_list|(
name|p
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|place
operator|==
literal|'l'
operator|||
name|place
operator|==
literal|'L'
condition|)
name|val
operator|=
name|NEXTLONG
argument_list|(
name|p
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|place
operator|==
literal|'g'
condition|)
block|{
name|val
operator|=
name|NEXTBYTE
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|==
literal|0
condition|)
name|val
operator|=
name|NEXTWORD
argument_list|(
name|p
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|val
operator|==
operator|-
literal|1
condition|)
name|val
operator|=
name|NEXTLONG
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|place
operator|==
literal|'c'
condition|)
block|{
if|if
condition|(
name|buffer
index|[
literal|1
index|]
operator|&
literal|0x40
condition|)
comment|/* If bit six is one, long offset */
name|val
operator|=
name|NEXTLONG
argument_list|(
name|p
argument_list|)
expr_stmt|;
else|else
name|val
operator|=
name|NEXTWORD
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
else|else
name|error
argument_list|(
literal|"Invalid arg format in opcode table: \"%c%c\"."
argument_list|,
operator|*
name|d
argument_list|,
name|place
argument_list|)
expr_stmt|;
name|print_address
argument_list|(
name|addr
operator|+
name|val
argument_list|,
name|stream
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|val
operator|=
name|NEXTWORD
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"%s@(%d)"
argument_list|,
name|reg_names
index|[
name|fetch_arg
argument_list|(
name|buffer
argument_list|,
name|place
argument_list|,
literal|3
argument_list|)
index|]
argument_list|,
name|val
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"%s"
argument_list|,
name|fpcr_names
index|[
name|fetch_arg
argument_list|(
name|buffer
argument_list|,
name|place
argument_list|,
literal|3
argument_list|)
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'I'
case|:
name|val
operator|=
name|fetch_arg
argument_list|(
name|buffer
argument_list|,
literal|'d'
argument_list|,
literal|3
argument_list|)
expr_stmt|;
comment|/* Get coprocessor ID... */
if|if
condition|(
name|val
operator|!=
literal|1
condition|)
comment|/* Unusual coprocessor ID? */
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"(cpid=%d) "
argument_list|,
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|place
operator|==
literal|'i'
condition|)
name|p
operator|+=
literal|2
expr_stmt|;
comment|/* Skip coprocessor extended operands */
break|break;
case|case
literal|'*'
case|:
case|case
literal|'~'
case|:
case|case
literal|'%'
case|:
case|case
literal|';'
case|:
case|case
literal|'@'
case|:
case|case
literal|'!'
case|:
case|case
literal|'$'
case|:
case|case
literal|'?'
case|:
case|case
literal|'/'
case|:
case|case
literal|'&'
case|:
case|case
literal|'`'
case|:
if|if
condition|(
name|place
operator|==
literal|'d'
condition|)
block|{
name|val
operator|=
name|fetch_arg
argument_list|(
name|buffer
argument_list|,
literal|'x'
argument_list|,
literal|6
argument_list|)
expr_stmt|;
name|val
operator|=
operator|(
operator|(
name|val
operator|&
literal|7
operator|)
operator|<<
literal|3
operator|)
operator|+
operator|(
operator|(
name|val
operator|>>
literal|3
operator|)
operator|&
literal|7
operator|)
expr_stmt|;
block|}
else|else
name|val
operator|=
name|fetch_arg
argument_list|(
name|buffer
argument_list|,
literal|'s'
argument_list|,
literal|6
argument_list|)
expr_stmt|;
comment|/* Get register number assuming address register.  */
name|regno
operator|=
operator|(
name|val
operator|&
literal|7
operator|)
operator|+
literal|8
expr_stmt|;
name|regname
operator|=
name|reg_names
index|[
name|regno
index|]
expr_stmt|;
switch|switch
condition|(
name|val
operator|>>
literal|3
condition|)
block|{
case|case
literal|0
case|:
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"%s"
argument_list|,
name|reg_names
index|[
name|val
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"%s"
argument_list|,
name|regname
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"%s@"
argument_list|,
name|regname
argument_list|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"%s@+"
argument_list|,
name|regname
argument_list|)
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"%s@-"
argument_list|,
name|regname
argument_list|)
expr_stmt|;
break|break;
case|case
literal|5
case|:
name|val
operator|=
name|NEXTWORD
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"%s@(%d)"
argument_list|,
name|regname
argument_list|,
name|val
argument_list|)
expr_stmt|;
break|break;
case|case
literal|6
case|:
name|p
operator|=
name|print_indexed
argument_list|(
name|regno
argument_list|,
name|p
argument_list|,
name|addr
argument_list|,
name|stream
argument_list|)
expr_stmt|;
break|break;
case|case
literal|7
case|:
switch|switch
condition|(
name|val
operator|&
literal|7
condition|)
block|{
case|case
literal|0
case|:
name|val
operator|=
name|NEXTWORD
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"@#"
argument_list|)
expr_stmt|;
name|print_address
argument_list|(
name|val
argument_list|,
name|stream
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|val
operator|=
name|NEXTLONG
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"@#"
argument_list|)
expr_stmt|;
name|print_address
argument_list|(
name|val
argument_list|,
name|stream
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|val
operator|=
name|NEXTWORD
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|print_address
argument_list|(
name|addr
operator|+
name|val
argument_list|,
name|stream
argument_list|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|p
operator|=
name|print_indexed
argument_list|(
operator|-
literal|1
argument_list|,
name|p
argument_list|,
name|addr
argument_list|,
name|stream
argument_list|)
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|flt_p
operator|=
literal|1
expr_stmt|;
comment|/* Assume it's a float... */
switch|switch
condition|(
name|place
condition|)
block|{
case|case
literal|'b'
case|:
name|val
operator|=
name|NEXTBYTE
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|flt_p
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'w'
case|:
name|val
operator|=
name|NEXTWORD
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|flt_p
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
name|val
operator|=
name|NEXTLONG
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|flt_p
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
name|flval
operator|=
name|NEXTSINGLE
argument_list|(
name|p
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'F'
case|:
name|flval
operator|=
name|NEXTDOUBLE
argument_list|(
name|p
argument_list|)
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|HAVE_68881
case|case
literal|'x'
case|:
name|ieee_extended_to_double
argument_list|(
operator|&
name|ext_format_68881
argument_list|,
name|p
argument_list|,
operator|&
name|flval
argument_list|)
expr_stmt|;
name|p
operator|+=
literal|12
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
literal|'p'
case|:
name|p
operator|+=
literal|12
expr_stmt|;
name|flval
operator|=
literal|0
expr_stmt|;
comment|/* FIXME, handle packed decimal someday.  */
break|break;
default|default:
name|error
argument_list|(
literal|"Invalid arg format in opcode table: \"%c%c\"."
argument_list|,
operator|*
name|d
argument_list|,
name|place
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|flt_p
condition|)
comment|/* Print a float? */
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"#%g"
argument_list|,
name|flval
argument_list|)
expr_stmt|;
else|else
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"#%d"
argument_list|,
name|val
argument_list|)
expr_stmt|;
break|break;
default|default:
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"<invalid address mode 0%o>"
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
literal|'L'
case|:
case|case
literal|'l'
case|:
if|if
condition|(
name|place
operator|==
literal|'w'
condition|)
block|{
name|char
name|doneany
decl_stmt|;
name|p1
operator|=
name|buffer
operator|+
literal|2
expr_stmt|;
name|val
operator|=
name|NEXTWORD
argument_list|(
name|p1
argument_list|)
expr_stmt|;
comment|/* Move the pointer ahead if this point is farther ahead 	       than the last.  */
name|p
operator|=
name|p1
operator|>
name|p
condition|?
name|p1
else|:
name|p
expr_stmt|;
if|if
condition|(
name|val
operator|==
literal|0
condition|)
block|{
name|fputs_filtered
argument_list|(
literal|"#0"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|*
name|d
operator|==
literal|'l'
condition|)
block|{
specifier|register
name|int
name|newval
init|=
literal|0
decl_stmt|;
for|for
control|(
name|regno
operator|=
literal|0
init|;
name|regno
operator|<
literal|16
condition|;
operator|++
name|regno
control|)
if|if
condition|(
name|val
operator|&
operator|(
literal|0x8000
operator|>>
name|regno
operator|)
condition|)
name|newval
operator||=
literal|1
operator|<<
name|regno
expr_stmt|;
name|val
operator|=
name|newval
expr_stmt|;
block|}
name|val
operator|&=
literal|0xffff
expr_stmt|;
name|doneany
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|regno
operator|=
literal|0
init|;
name|regno
operator|<
literal|16
condition|;
operator|++
name|regno
control|)
if|if
condition|(
name|val
operator|&
operator|(
literal|1
operator|<<
name|regno
operator|)
condition|)
block|{
name|int
name|first_regno
decl_stmt|;
if|if
condition|(
name|doneany
condition|)
name|fputs_filtered
argument_list|(
literal|"/"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|doneany
operator|=
literal|1
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"%s"
argument_list|,
name|reg_names
index|[
name|regno
index|]
argument_list|)
expr_stmt|;
name|first_regno
operator|=
name|regno
expr_stmt|;
while|while
condition|(
name|val
operator|&
operator|(
literal|1
operator|<<
operator|(
name|regno
operator|+
literal|1
operator|)
operator|)
condition|)
operator|++
name|regno
expr_stmt|;
if|if
condition|(
name|regno
operator|>
name|first_regno
condition|)
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"-%s"
argument_list|,
name|reg_names
index|[
name|regno
index|]
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|place
operator|==
literal|'3'
condition|)
block|{
comment|/* `fmovem' insn.  */
name|char
name|doneany
decl_stmt|;
name|val
operator|=
name|fetch_arg
argument_list|(
name|buffer
argument_list|,
name|place
argument_list|,
literal|8
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|==
literal|0
condition|)
block|{
name|fputs_filtered
argument_list|(
literal|"#0"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|*
name|d
operator|==
literal|'l'
condition|)
block|{
specifier|register
name|int
name|newval
init|=
literal|0
decl_stmt|;
for|for
control|(
name|regno
operator|=
literal|0
init|;
name|regno
operator|<
literal|8
condition|;
operator|++
name|regno
control|)
if|if
condition|(
name|val
operator|&
operator|(
literal|0x80
operator|>>
name|regno
operator|)
condition|)
name|newval
operator||=
literal|1
operator|<<
name|regno
expr_stmt|;
name|val
operator|=
name|newval
expr_stmt|;
block|}
name|val
operator|&=
literal|0xff
expr_stmt|;
name|doneany
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|regno
operator|=
literal|0
init|;
name|regno
operator|<
literal|8
condition|;
operator|++
name|regno
control|)
if|if
condition|(
name|val
operator|&
operator|(
literal|1
operator|<<
name|regno
operator|)
condition|)
block|{
name|int
name|first_regno
decl_stmt|;
if|if
condition|(
name|doneany
condition|)
name|fputs_filtered
argument_list|(
literal|"/"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|doneany
operator|=
literal|1
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"fp%d"
argument_list|,
name|regno
argument_list|)
expr_stmt|;
name|first_regno
operator|=
name|regno
expr_stmt|;
while|while
condition|(
name|val
operator|&
operator|(
literal|1
operator|<<
operator|(
name|regno
operator|+
literal|1
operator|)
operator|)
condition|)
operator|++
name|regno
expr_stmt|;
if|if
condition|(
name|regno
operator|>
name|first_regno
condition|)
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"-fp%d"
argument_list|,
name|regno
argument_list|)
expr_stmt|;
block|}
block|}
else|else
goto|goto
name|de_fault
goto|;
break|break;
default|default:
name|de_fault
label|:
name|error
argument_list|(
literal|"Invalid arg format in opcode table: \"%c\"."
argument_list|,
operator|*
name|d
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|unsigned
name|char
operator|*
operator|)
name|p
return|;
block|}
end_function

begin_comment
comment|/* Fetch BITS bits from a position in the instruction specified by CODE.    CODE is a "place to put an argument", or 'x' for a destination    that is a general address (mode and register).    BUFFER contains the instruction.  */
end_comment

begin_function
specifier|static
name|int
name|fetch_arg
parameter_list|(
name|buffer
parameter_list|,
name|code
parameter_list|,
name|bits
parameter_list|)
name|unsigned
name|char
modifier|*
name|buffer
decl_stmt|;
name|int
name|code
decl_stmt|;
name|int
name|bits
decl_stmt|;
block|{
specifier|register
name|int
name|val
decl_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
literal|'s'
case|:
name|val
operator|=
name|buffer
index|[
literal|1
index|]
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
comment|/* Destination, for register or quick.  */
name|val
operator|=
operator|(
name|buffer
index|[
literal|0
index|]
operator|<<
literal|8
operator|)
operator|+
name|buffer
index|[
literal|1
index|]
expr_stmt|;
name|val
operator|>>=
literal|9
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
comment|/* Destination, for general arg */
name|val
operator|=
operator|(
name|buffer
index|[
literal|0
index|]
operator|<<
literal|8
operator|)
operator|+
name|buffer
index|[
literal|1
index|]
expr_stmt|;
name|val
operator|>>=
literal|6
expr_stmt|;
break|break;
case|case
literal|'k'
case|:
name|val
operator|=
operator|(
name|buffer
index|[
literal|3
index|]
operator|>>
literal|4
operator|)
expr_stmt|;
break|break;
case|case
literal|'C'
case|:
name|val
operator|=
name|buffer
index|[
literal|3
index|]
expr_stmt|;
break|break;
case|case
literal|'1'
case|:
name|val
operator|=
operator|(
name|buffer
index|[
literal|2
index|]
operator|<<
literal|8
operator|)
operator|+
name|buffer
index|[
literal|3
index|]
expr_stmt|;
name|val
operator|>>=
literal|12
expr_stmt|;
break|break;
case|case
literal|'2'
case|:
name|val
operator|=
operator|(
name|buffer
index|[
literal|2
index|]
operator|<<
literal|8
operator|)
operator|+
name|buffer
index|[
literal|3
index|]
expr_stmt|;
name|val
operator|>>=
literal|6
expr_stmt|;
break|break;
case|case
literal|'3'
case|:
case|case
literal|'j'
case|:
name|val
operator|=
operator|(
name|buffer
index|[
literal|2
index|]
operator|<<
literal|8
operator|)
operator|+
name|buffer
index|[
literal|3
index|]
expr_stmt|;
break|break;
case|case
literal|'4'
case|:
name|val
operator|=
operator|(
name|buffer
index|[
literal|4
index|]
operator|<<
literal|8
operator|)
operator|+
name|buffer
index|[
literal|5
index|]
expr_stmt|;
name|val
operator|>>=
literal|12
expr_stmt|;
break|break;
case|case
literal|'5'
case|:
name|val
operator|=
operator|(
name|buffer
index|[
literal|4
index|]
operator|<<
literal|8
operator|)
operator|+
name|buffer
index|[
literal|5
index|]
expr_stmt|;
name|val
operator|>>=
literal|6
expr_stmt|;
break|break;
case|case
literal|'6'
case|:
name|val
operator|=
operator|(
name|buffer
index|[
literal|4
index|]
operator|<<
literal|8
operator|)
operator|+
name|buffer
index|[
literal|5
index|]
expr_stmt|;
break|break;
case|case
literal|'7'
case|:
name|val
operator|=
operator|(
name|buffer
index|[
literal|2
index|]
operator|<<
literal|8
operator|)
operator|+
name|buffer
index|[
literal|3
index|]
expr_stmt|;
name|val
operator|>>=
literal|7
expr_stmt|;
break|break;
case|case
literal|'8'
case|:
name|val
operator|=
operator|(
name|buffer
index|[
literal|2
index|]
operator|<<
literal|8
operator|)
operator|+
name|buffer
index|[
literal|3
index|]
expr_stmt|;
name|val
operator|>>=
literal|10
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
name|val
operator|=
operator|(
name|buffer
index|[
literal|1
index|]
operator|>>
literal|6
operator|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
switch|switch
condition|(
name|bits
condition|)
block|{
case|case
literal|2
case|:
return|return
name|val
operator|&
literal|3
return|;
case|case
literal|3
case|:
return|return
name|val
operator|&
literal|7
return|;
case|case
literal|4
case|:
return|return
name|val
operator|&
literal|017
return|;
case|case
literal|5
case|:
return|return
name|val
operator|&
literal|037
return|;
case|case
literal|6
case|:
return|return
name|val
operator|&
literal|077
return|;
case|case
literal|7
case|:
return|return
name|val
operator|&
literal|0177
return|;
case|case
literal|8
case|:
return|return
name|val
operator|&
literal|0377
return|;
case|case
literal|12
case|:
return|return
name|val
operator|&
literal|07777
return|;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Print an indexed argument.  The base register is BASEREG (-1 for pc).    P points to extension word, in buffer.    ADDR is the nominal core address of that extension word.  */
end_comment

begin_function
specifier|static
name|unsigned
name|char
modifier|*
name|print_indexed
parameter_list|(
name|basereg
parameter_list|,
name|p
parameter_list|,
name|addr
parameter_list|,
name|stream
parameter_list|)
name|int
name|basereg
decl_stmt|;
name|unsigned
name|char
modifier|*
name|p
decl_stmt|;
name|CORE_ADDR
name|addr
decl_stmt|;
name|FILE
modifier|*
name|stream
decl_stmt|;
block|{
specifier|register
name|int
name|word
decl_stmt|;
specifier|static
name|char
modifier|*
name|scales
index|[]
init|=
block|{
literal|""
block|,
literal|"*2"
block|,
literal|"*4"
block|,
literal|"*8"
block|}
decl_stmt|;
specifier|register
name|int
name|base_disp
decl_stmt|;
specifier|register
name|int
name|outer_disp
decl_stmt|;
name|char
name|buf
index|[
literal|40
index|]
decl_stmt|;
name|word
operator|=
name|NEXTWORD
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/* Generate the text for the index register.      Where this will be output is not yet determined.  */
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"[%s.%c%s]"
argument_list|,
name|reg_names
index|[
operator|(
name|word
operator|>>
literal|12
operator|)
operator|&
literal|0xf
index|]
argument_list|,
operator|(
name|word
operator|&
literal|0x800
operator|)
condition|?
literal|'l'
else|:
literal|'w'
argument_list|,
name|scales
index|[
operator|(
name|word
operator|>>
literal|9
operator|)
operator|&
literal|3
index|]
argument_list|)
expr_stmt|;
comment|/* Handle the 68000 style of indexing.  */
if|if
condition|(
operator|(
name|word
operator|&
literal|0x100
operator|)
operator|==
literal|0
condition|)
block|{
name|print_base
argument_list|(
name|basereg
argument_list|,
operator|(
operator|(
name|word
operator|&
literal|0x80
operator|)
condition|?
name|word
operator||
literal|0xff00
else|:
name|word
operator|&
literal|0xff
operator|)
operator|+
operator|(
operator|(
name|basereg
operator|==
operator|-
literal|1
operator|)
condition|?
name|addr
else|:
literal|0
operator|)
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
name|buf
argument_list|,
name|stream
argument_list|)
expr_stmt|;
return|return
name|p
return|;
block|}
comment|/* Handle the generalized kind.  */
comment|/* First, compute the displacement to add to the base register.  */
if|if
condition|(
name|word
operator|&
literal|0200
condition|)
name|basereg
operator|=
operator|-
literal|2
expr_stmt|;
if|if
condition|(
name|word
operator|&
literal|0100
condition|)
name|buf
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|base_disp
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
operator|(
name|word
operator|>>
literal|4
operator|)
operator|&
literal|3
condition|)
block|{
case|case
literal|2
case|:
name|base_disp
operator|=
name|NEXTWORD
argument_list|(
name|p
argument_list|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|base_disp
operator|=
name|NEXTLONG
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|basereg
operator|==
operator|-
literal|1
condition|)
name|base_disp
operator|+=
name|addr
expr_stmt|;
comment|/* Handle single-level case (not indirect) */
if|if
condition|(
operator|(
name|word
operator|&
literal|7
operator|)
operator|==
literal|0
condition|)
block|{
name|print_base
argument_list|(
name|basereg
argument_list|,
name|base_disp
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
name|buf
argument_list|,
name|stream
argument_list|)
expr_stmt|;
return|return
name|p
return|;
block|}
comment|/* Two level.  Compute displacement to add after indirection.  */
name|outer_disp
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|word
operator|&
literal|3
condition|)
block|{
case|case
literal|2
case|:
name|outer_disp
operator|=
name|NEXTWORD
argument_list|(
name|p
argument_list|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|outer_disp
operator|=
name|NEXTLONG
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"%d("
argument_list|,
name|outer_disp
argument_list|)
expr_stmt|;
name|print_base
argument_list|(
name|basereg
argument_list|,
name|base_disp
argument_list|,
name|stream
argument_list|)
expr_stmt|;
comment|/* If postindexed, print the closeparen before the index.  */
if|if
condition|(
name|word
operator|&
literal|4
condition|)
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|")%s"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
comment|/* If preindexed, print the closeparen after the index.  */
else|else
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"%s)"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
return|return
name|p
return|;
block|}
end_function

begin_comment
comment|/* Print a base register REGNO and displacement DISP, on STREAM.    REGNO = -1 for pc, -2 for none (suppressed).  */
end_comment

begin_function
specifier|static
name|void
name|print_base
parameter_list|(
name|regno
parameter_list|,
name|disp
parameter_list|,
name|stream
parameter_list|)
name|int
name|regno
decl_stmt|;
name|int
name|disp
decl_stmt|;
name|FILE
modifier|*
name|stream
decl_stmt|;
block|{
if|if
condition|(
name|regno
operator|==
operator|-
literal|2
condition|)
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"%d"
argument_list|,
name|disp
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|regno
operator|==
operator|-
literal|1
condition|)
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"0x%x"
argument_list|,
name|disp
argument_list|)
expr_stmt|;
else|else
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"%d(%s)"
argument_list|,
name|disp
argument_list|,
name|reg_names
index|[
name|regno
index|]
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

