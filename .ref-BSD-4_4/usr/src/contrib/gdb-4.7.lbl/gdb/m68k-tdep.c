begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Target dependent code for the Motorola 68000 series.    Copyright (C) 1990, 1992 Free Software Foundation, Inc.  This file is part of GDB.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"ieee-float.h"
end_include

begin_include
include|#
directive|include
file|"frame.h"
end_include

begin_include
include|#
directive|include
file|"symtab.h"
end_include

begin_decl_stmt
specifier|const
name|struct
name|ext_format
name|ext_format_68881
init|=
block|{
comment|/* tot sbyte smask expbyte manbyte */
literal|12
block|,
literal|0
block|,
literal|0x80
block|,
literal|0
block|,
literal|1
block|,
literal|4
block|,
literal|8
comment|/* mc68881 */
block|}
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Things needed for making the inferior call functions.    It seems like every m68k based machine has almost identical definitions    in the individual machine's configuration files.  Most other cpu types    (mips, i386, etc) have routines in their *-tdep.c files to handle this    for most configurations.  The m68k family should be able to do this as    well.  These macros can still be overridden when necessary.  */
end_comment

begin_comment
comment|/* Push an empty stack frame, to record the current PC, etc.  */
end_comment

begin_function
name|void
name|m68k_push_dummy_frame
parameter_list|()
block|{
specifier|register
name|CORE_ADDR
name|sp
init|=
name|read_register
argument_list|(
name|SP_REGNUM
argument_list|)
decl_stmt|;
specifier|register
name|int
name|regnum
decl_stmt|;
name|char
name|raw_buffer
index|[
literal|12
index|]
decl_stmt|;
name|sp
operator|=
name|push_word
argument_list|(
name|sp
argument_list|,
name|read_register
argument_list|(
name|PC_REGNUM
argument_list|)
argument_list|)
expr_stmt|;
name|sp
operator|=
name|push_word
argument_list|(
name|sp
argument_list|,
name|read_register
argument_list|(
name|FP_REGNUM
argument_list|)
argument_list|)
expr_stmt|;
name|write_register
argument_list|(
name|FP_REGNUM
argument_list|,
name|sp
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|HAVE_68881
argument_list|)
for|for
control|(
name|regnum
operator|=
name|FP0_REGNUM
operator|+
literal|7
init|;
name|regnum
operator|>=
name|FP0_REGNUM
condition|;
name|regnum
operator|--
control|)
block|{
name|read_register_bytes
argument_list|(
name|REGISTER_BYTE
argument_list|(
name|regnum
argument_list|)
argument_list|,
name|raw_buffer
argument_list|,
literal|12
argument_list|)
expr_stmt|;
name|sp
operator|=
name|push_bytes
argument_list|(
name|sp
argument_list|,
name|raw_buffer
argument_list|,
literal|12
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
for|for
control|(
name|regnum
operator|=
name|FP_REGNUM
operator|-
literal|1
init|;
name|regnum
operator|>=
literal|0
condition|;
name|regnum
operator|--
control|)
block|{
name|sp
operator|=
name|push_word
argument_list|(
name|sp
argument_list|,
name|read_register
argument_list|(
name|regnum
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|sp
operator|=
name|push_word
argument_list|(
name|sp
argument_list|,
name|read_register
argument_list|(
name|PS_REGNUM
argument_list|)
argument_list|)
expr_stmt|;
name|write_register
argument_list|(
name|SP_REGNUM
argument_list|,
name|sp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Discard from the stack the innermost frame,    restoring all saved registers.  */
end_comment

begin_function
name|void
name|m68k_pop_frame
parameter_list|()
block|{
specifier|register
name|FRAME
name|frame
init|=
name|get_current_frame
argument_list|()
decl_stmt|;
specifier|register
name|CORE_ADDR
name|fp
decl_stmt|;
specifier|register
name|int
name|regnum
decl_stmt|;
name|struct
name|frame_saved_regs
name|fsr
decl_stmt|;
name|struct
name|frame_info
modifier|*
name|fi
decl_stmt|;
name|char
name|raw_buffer
index|[
literal|12
index|]
decl_stmt|;
name|fi
operator|=
name|get_frame_info
argument_list|(
name|frame
argument_list|)
expr_stmt|;
name|fp
operator|=
name|fi
operator|->
name|frame
expr_stmt|;
name|get_frame_saved_regs
argument_list|(
name|fi
argument_list|,
operator|&
name|fsr
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|HAVE_68881
argument_list|)
for|for
control|(
name|regnum
operator|=
name|FP0_REGNUM
operator|+
literal|7
init|;
name|regnum
operator|>=
name|FP0_REGNUM
condition|;
name|regnum
operator|--
control|)
block|{
if|if
condition|(
name|fsr
operator|.
name|regs
index|[
name|regnum
index|]
condition|)
block|{
name|read_memory
argument_list|(
name|fsr
operator|.
name|regs
index|[
name|regnum
index|]
argument_list|,
name|raw_buffer
argument_list|,
literal|12
argument_list|)
expr_stmt|;
name|write_register_bytes
argument_list|(
name|REGISTER_BYTE
argument_list|(
name|regnum
argument_list|)
argument_list|,
name|raw_buffer
argument_list|,
literal|12
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
for|for
control|(
name|regnum
operator|=
name|FP_REGNUM
operator|-
literal|1
init|;
name|regnum
operator|>=
literal|0
condition|;
name|regnum
operator|--
control|)
block|{
if|if
condition|(
name|fsr
operator|.
name|regs
index|[
name|regnum
index|]
condition|)
block|{
name|write_register
argument_list|(
name|regnum
argument_list|,
name|read_memory_integer
argument_list|(
name|fsr
operator|.
name|regs
index|[
name|regnum
index|]
argument_list|,
literal|4
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|fsr
operator|.
name|regs
index|[
name|PS_REGNUM
index|]
condition|)
block|{
name|write_register
argument_list|(
name|PS_REGNUM
argument_list|,
name|read_memory_integer
argument_list|(
name|fsr
operator|.
name|regs
index|[
name|PS_REGNUM
index|]
argument_list|,
literal|4
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|write_register
argument_list|(
name|FP_REGNUM
argument_list|,
name|read_memory_integer
argument_list|(
name|fp
argument_list|,
literal|4
argument_list|)
argument_list|)
expr_stmt|;
name|write_register
argument_list|(
name|PC_REGNUM
argument_list|,
name|read_memory_integer
argument_list|(
name|fp
operator|+
literal|4
argument_list|,
literal|4
argument_list|)
argument_list|)
expr_stmt|;
name|write_register
argument_list|(
name|SP_REGNUM
argument_list|,
name|fp
operator|+
literal|8
argument_list|)
expr_stmt|;
name|flush_cached_frames
argument_list|()
expr_stmt|;
name|set_current_frame
argument_list|(
name|create_new_frame
argument_list|(
name|read_register
argument_list|(
name|FP_REGNUM
argument_list|)
argument_list|,
name|read_pc
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Given an ip value corresponding to the start of a function,    return the ip of the first instruction after the function     prologue.  This is the generic m68k support.  Machines which    require something different can override the SKIP_PROLOGUE    macro to point elsewhere.     Some instructions which typically may appear in a function    prologue include:     A link instruction, word form:  	link.w	%a6,&0			4e56  XXXX     A link instruction, long form:  	link.l  %fp,&F%1		480e  XXXX  XXXX     A movm instruction to preserve integer regs:  	movm.l&M%1,(4,%sp)		48ef  XXXX  XXXX     A fmovm instruction to preserve float regs:  	fmovm&FPM%1,(FPO%1,%sp)	f237  XXXX  XXXX  XXXX  XXXX     Some profiling setup code (FIXME, not recognized yet):  	lea.l   (.L3,%pc),%a1		43fb  XXXX  XXXX  XXXX 	bsr     _mcount			61ff  XXXX  XXXX    */
end_comment

begin_define
define|#
directive|define
name|P_LINK_L
value|0x480e
end_define

begin_define
define|#
directive|define
name|P_LINK_W
value|0x4e56
end_define

begin_define
define|#
directive|define
name|P_MOV_L
value|0x207c
end_define

begin_define
define|#
directive|define
name|P_JSR
value|0x4eb9
end_define

begin_define
define|#
directive|define
name|P_BSR
value|0x61ff
end_define

begin_define
define|#
directive|define
name|P_LEA_L
value|0x43fb
end_define

begin_define
define|#
directive|define
name|P_MOVM_L
value|0x48ef
end_define

begin_define
define|#
directive|define
name|P_FMOVM
value|0xf237
end_define

begin_define
define|#
directive|define
name|P_TRAP
value|0x4e40
end_define

begin_function
name|CORE_ADDR
name|m68k_skip_prologue
parameter_list|(
name|ip
parameter_list|)
name|CORE_ADDR
name|ip
decl_stmt|;
block|{
specifier|register
name|CORE_ADDR
name|limit
decl_stmt|;
name|struct
name|symtab_and_line
name|sal
decl_stmt|;
specifier|register
name|int
name|op
decl_stmt|;
comment|/* Find out if there is a known limit for the extent of the prologue.      If so, ensure we don't go past it.  If not, assume "infinity". */
name|sal
operator|=
name|find_pc_line
argument_list|(
name|ip
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|limit
operator|=
operator|(
name|sal
operator|.
name|end
operator|)
condition|?
name|sal
operator|.
name|end
else|:
operator|(
name|CORE_ADDR
operator|)
operator|~
literal|0
expr_stmt|;
while|while
condition|(
name|ip
operator|<
name|limit
condition|)
block|{
name|op
operator|=
name|read_memory_integer
argument_list|(
name|ip
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|op
operator|&=
literal|0xFFFF
expr_stmt|;
if|if
condition|(
name|op
operator|==
name|P_LINK_W
condition|)
block|{
name|ip
operator|+=
literal|4
expr_stmt|;
comment|/* Skip link.w */
block|}
elseif|else
if|if
condition|(
name|op
operator|==
name|P_LINK_L
condition|)
block|{
name|ip
operator|+=
literal|6
expr_stmt|;
comment|/* Skip link.l */
block|}
elseif|else
if|if
condition|(
name|op
operator|==
name|P_MOVM_L
condition|)
block|{
name|ip
operator|+=
literal|6
expr_stmt|;
comment|/* Skip movm.l */
block|}
elseif|else
if|if
condition|(
name|op
operator|==
name|P_FMOVM
condition|)
block|{
name|ip
operator|+=
literal|10
expr_stmt|;
comment|/* Skip fmovm */
block|}
else|else
block|{
break|break;
comment|/* Found unknown code, bail out. */
block|}
block|}
return|return
operator|(
name|ip
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|USE_PROC_FS
end_ifdef

begin_comment
comment|/* Target dependent support for /proc */
end_comment

begin_include
include|#
directive|include
file|<sys/procfs.h>
end_include

begin_comment
comment|/*  The /proc interface divides the target machine's register set up into     two different sets, the general register set (gregset) and the floating     point register set (fpregset).  For each set, there is an ioctl to get     the current register set and another ioctl to set the current values.      The actual structure passed through the ioctl interface is, of course,     naturally machine dependent, and is different for each set of registers.     For the m68k for example, the general register set is typically defined     by:  	typedef int gregset_t[18];  	#define	R_D0	0 	... 	#define	R_PS	17      and the floating point set by:      	typedef	struct fpregset { 	  int	f_pcr; 	  int	f_psr; 	  int	f_fpiaddr; 	  int	f_fpregs[8][3];		(8 regs, 96 bits each) 	} fpregset_t;      These routines provide the packing and unpacking of gregset_t and     fpregset_t formatted data.   */
end_comment

begin_comment
comment|/*  Given a pointer to a general register set in /proc format (gregset_t *),     unpack the register contents and supply them as gdb's idea of the current     register values. */
end_comment

begin_function
name|void
name|supply_gregset
parameter_list|(
name|gregsetp
parameter_list|)
name|gregset_t
modifier|*
name|gregsetp
decl_stmt|;
block|{
specifier|register
name|int
name|regi
decl_stmt|;
specifier|register
name|greg_t
modifier|*
name|regp
init|=
operator|(
name|greg_t
operator|*
operator|)
name|gregsetp
decl_stmt|;
for|for
control|(
name|regi
operator|=
literal|0
init|;
name|regi
operator|<
name|R_PC
condition|;
name|regi
operator|++
control|)
block|{
name|supply_register
argument_list|(
name|regi
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|(
name|regp
operator|+
name|regi
operator|)
argument_list|)
expr_stmt|;
block|}
name|supply_register
argument_list|(
name|PS_REGNUM
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|(
name|regp
operator|+
name|R_PS
operator|)
argument_list|)
expr_stmt|;
name|supply_register
argument_list|(
name|PC_REGNUM
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|(
name|regp
operator|+
name|R_PC
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|fill_gregset
parameter_list|(
name|gregsetp
parameter_list|,
name|regno
parameter_list|)
name|gregset_t
modifier|*
name|gregsetp
decl_stmt|;
name|int
name|regno
decl_stmt|;
block|{
specifier|register
name|int
name|regi
decl_stmt|;
specifier|register
name|greg_t
modifier|*
name|regp
init|=
operator|(
name|greg_t
operator|*
operator|)
name|gregsetp
decl_stmt|;
specifier|extern
name|char
name|registers
index|[]
decl_stmt|;
for|for
control|(
name|regi
operator|=
literal|0
init|;
name|regi
operator|<
name|R_PC
condition|;
name|regi
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|regno
operator|==
operator|-
literal|1
operator|)
operator|||
operator|(
name|regno
operator|==
name|regi
operator|)
condition|)
block|{
operator|*
operator|(
name|regp
operator|+
name|regi
operator|)
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
name|regi
argument_list|)
index|]
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|regno
operator|==
operator|-
literal|1
operator|)
operator|||
operator|(
name|regno
operator|==
name|PS_REGNUM
operator|)
condition|)
block|{
operator|*
operator|(
name|regp
operator|+
name|R_PS
operator|)
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
name|PS_REGNUM
argument_list|)
index|]
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|regno
operator|==
operator|-
literal|1
operator|)
operator|||
operator|(
name|regno
operator|==
name|PC_REGNUM
operator|)
condition|)
block|{
operator|*
operator|(
name|regp
operator|+
name|R_PC
operator|)
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
name|PC_REGNUM
argument_list|)
index|]
expr_stmt|;
block|}
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|FP0_REGNUM
argument_list|)
end_if

begin_comment
comment|/*  Given a pointer to a floating point register set in /proc format     (fpregset_t *), unpack the register contents and supply them as gdb's     idea of the current floating point register values. */
end_comment

begin_function
name|void
name|supply_fpregset
parameter_list|(
name|fpregsetp
parameter_list|)
name|fpregset_t
modifier|*
name|fpregsetp
decl_stmt|;
block|{
specifier|register
name|int
name|regi
decl_stmt|;
name|char
modifier|*
name|from
decl_stmt|;
for|for
control|(
name|regi
operator|=
name|FP0_REGNUM
init|;
name|regi
operator|<
name|FPC_REGNUM
condition|;
name|regi
operator|++
control|)
block|{
name|from
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
operator|(
name|fpregsetp
operator|->
name|f_fpregs
index|[
name|regi
operator|-
name|FP0_REGNUM
index|]
index|[
literal|0
index|]
operator|)
expr_stmt|;
name|supply_register
argument_list|(
name|regi
argument_list|,
name|from
argument_list|)
expr_stmt|;
block|}
name|supply_register
argument_list|(
name|FPC_REGNUM
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
operator|(
name|fpregsetp
operator|->
name|f_pcr
operator|)
argument_list|)
expr_stmt|;
name|supply_register
argument_list|(
name|FPS_REGNUM
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
operator|(
name|fpregsetp
operator|->
name|f_psr
operator|)
argument_list|)
expr_stmt|;
name|supply_register
argument_list|(
name|FPI_REGNUM
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
operator|(
name|fpregsetp
operator|->
name|f_fpiaddr
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  Given a pointer to a floating point register set in /proc format     (fpregset_t *), update the register specified by REGNO from gdb's idea     of the current floating point register set.  If REGNO is -1, update     them all. */
end_comment

begin_function
name|void
name|fill_fpregset
parameter_list|(
name|fpregsetp
parameter_list|,
name|regno
parameter_list|)
name|fpregset_t
modifier|*
name|fpregsetp
decl_stmt|;
name|int
name|regno
decl_stmt|;
block|{
name|int
name|regi
decl_stmt|;
name|char
modifier|*
name|to
decl_stmt|;
name|char
modifier|*
name|from
decl_stmt|;
specifier|extern
name|char
name|registers
index|[]
decl_stmt|;
for|for
control|(
name|regi
operator|=
name|FP0_REGNUM
init|;
name|regi
operator|<
name|FPC_REGNUM
condition|;
name|regi
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|regno
operator|==
operator|-
literal|1
operator|)
operator|||
operator|(
name|regno
operator|==
name|regi
operator|)
condition|)
block|{
name|from
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
name|regi
argument_list|)
index|]
expr_stmt|;
name|to
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
operator|(
name|fpregsetp
operator|->
name|f_fpregs
index|[
name|regi
operator|-
name|FP0_REGNUM
index|]
index|[
literal|0
index|]
operator|)
expr_stmt|;
name|bcopy
argument_list|(
name|from
argument_list|,
name|to
argument_list|,
name|REGISTER_RAW_SIZE
argument_list|(
name|regi
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|regno
operator|==
operator|-
literal|1
operator|)
operator|||
operator|(
name|regno
operator|==
name|FPC_REGNUM
operator|)
condition|)
block|{
name|fpregsetp
operator|->
name|f_pcr
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
name|FPC_REGNUM
argument_list|)
index|]
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|regno
operator|==
operator|-
literal|1
operator|)
operator|||
operator|(
name|regno
operator|==
name|FPS_REGNUM
operator|)
condition|)
block|{
name|fpregsetp
operator|->
name|f_psr
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
name|FPS_REGNUM
argument_list|)
index|]
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|regno
operator|==
operator|-
literal|1
operator|)
operator|||
operator|(
name|regno
operator|==
name|FPI_REGNUM
operator|)
condition|)
block|{
name|fpregsetp
operator|->
name|f_fpiaddr
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
name|FPI_REGNUM
argument_list|)
index|]
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* defined (FP0_REGNUM) */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* USE_PROC_FS */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|GET_LONGJMP_TARGET
end_ifdef

begin_comment
comment|/* Figure out where the longjmp will land.  Slurp the args out of the stack.    We expect the first arg to be a pointer to the jmp_buf structure from which    we extract the pc (JB_PC) that we will land at.  The pc is copied into PC.    This routine returns true on success. */
end_comment

begin_function
name|int
name|get_longjmp_target
parameter_list|(
name|pc
parameter_list|)
name|CORE_ADDR
modifier|*
name|pc
decl_stmt|;
block|{
name|CORE_ADDR
name|sp
decl_stmt|,
name|jb_addr
decl_stmt|;
name|sp
operator|=
name|read_register
argument_list|(
name|SP_REGNUM
argument_list|)
expr_stmt|;
if|if
condition|(
name|target_read_memory
argument_list|(
name|sp
operator|+
name|SP_ARG0
argument_list|,
comment|/* Offset of first arg on stack */
operator|&
name|jb_addr
argument_list|,
sizeof|sizeof
argument_list|(
name|CORE_ADDR
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
name|SWAP_TARGET_AND_HOST
argument_list|(
operator|&
name|jb_addr
argument_list|,
sizeof|sizeof
argument_list|(
name|CORE_ADDR
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|target_read_memory
argument_list|(
name|jb_addr
operator|+
name|JB_PC
operator|*
name|JB_ELEMENT_SIZE
argument_list|,
name|pc
argument_list|,
sizeof|sizeof
argument_list|(
name|CORE_ADDR
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
name|SWAP_TARGET_AND_HOST
argument_list|(
name|pc
argument_list|,
sizeof|sizeof
argument_list|(
name|CORE_ADDR
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* GET_LONGJMP_TARGET */
end_comment

begin_comment
comment|/* Immediately after a function call, return the saved pc before the frame    is setup.  For sun3's, we check for the common case of being inside of a    system call, and if so, we know that Sun pushes the call # on the stack    prior to doing the trap. */
end_comment

begin_function
name|CORE_ADDR
name|m68k_saved_pc_after_call
parameter_list|(
name|frame
parameter_list|)
name|struct
name|frame_info
modifier|*
name|frame
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|GDB_TARGET_IS_SUN3
name|int
name|op
decl_stmt|;
name|op
operator|=
name|read_memory_integer
argument_list|(
name|frame
operator|->
name|pc
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|op
operator|&=
literal|0xFFFF
expr_stmt|;
if|if
condition|(
name|op
operator|==
name|P_TRAP
condition|)
return|return
name|read_memory_integer
argument_list|(
name|read_register
argument_list|(
name|SP_REGNUM
argument_list|)
operator|+
literal|4
argument_list|,
literal|4
argument_list|)
return|;
else|else
endif|#
directive|endif
comment|/* GDB_TARGET_IS_SUN3 */
return|return
name|read_memory_integer
argument_list|(
name|read_register
argument_list|(
name|SP_REGNUM
argument_list|)
argument_list|,
literal|4
argument_list|)
return|;
block|}
end_function

begin_function
name|FRAME_ADDR
name|m68k_frame_chain
parameter_list|(
name|p
parameter_list|)
name|FRAME
name|p
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|KERNELDEBUG
specifier|extern
name|int
name|kernel_debugging
decl_stmt|;
comment|/* XXX check for last kernel frame here */
else|#
directive|else
if|if
condition|(
name|inside_entry_file
argument_list|(
name|p
operator|->
name|pc
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
endif|#
directive|endif
return|return
operator|(
name|read_memory_integer
argument_list|(
name|p
operator|->
name|frame
argument_list|,
literal|4
argument_list|)
operator|)
return|;
block|}
end_function

end_unit

