begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Instruction printing code for the AMD 29000    Copyright (C) 1990 Free Software Foundation, Inc.    Contributed by Cygnus Support.  Written by Jim Kingdon.  This file is part of GDB.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"opcode/a29k.h"
end_include

begin_comment
comment|/* Print a symbolic representation of a general-purpose    register number NUM on STREAM.    NUM is a number as found in the instruction, not as found in    debugging symbols; it must be in the range 0-255.  */
end_comment

begin_function
specifier|static
name|void
name|print_general
parameter_list|(
name|num
parameter_list|,
name|stream
parameter_list|)
name|int
name|num
decl_stmt|;
name|FILE
modifier|*
name|stream
decl_stmt|;
block|{
if|if
condition|(
name|num
operator|<
literal|128
condition|)
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"gr%d"
argument_list|,
name|num
argument_list|)
expr_stmt|;
else|else
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"lr%d"
argument_list|,
name|num
operator|-
literal|128
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Like print_general but a special-purpose register.        The mnemonics used by the AMD assembler are not quite the same    as the ones in the User's Manual.  We use the ones that the    assembler uses.  */
end_comment

begin_function
specifier|static
name|void
name|print_special
parameter_list|(
name|num
parameter_list|,
name|stream
parameter_list|)
name|int
name|num
decl_stmt|;
name|FILE
modifier|*
name|stream
decl_stmt|;
block|{
comment|/* Register names of registers 0-SPEC0_NUM-1.  */
specifier|static
name|char
modifier|*
name|spec0_names
index|[]
init|=
block|{
literal|"vab"
block|,
literal|"ops"
block|,
literal|"cps"
block|,
literal|"cfg"
block|,
literal|"cha"
block|,
literal|"chd"
block|,
literal|"chc"
block|,
literal|"rbp"
block|,
literal|"tmc"
block|,
literal|"tmr"
block|,
literal|"pc0"
block|,
literal|"pc1"
block|,
literal|"pc2"
block|,
literal|"mmu"
block|,
literal|"lru"
block|}
decl_stmt|;
define|#
directive|define
name|SPEC0_NUM
value|((sizeof spec0_names) / (sizeof spec0_names[0]))
comment|/* Register names of registers 128-128+SPEC128_NUM-1.  */
specifier|static
name|char
modifier|*
name|spec128_names
index|[]
init|=
block|{
literal|"ipc"
block|,
literal|"ipa"
block|,
literal|"ipb"
block|,
literal|"q"
block|,
literal|"alu"
block|,
literal|"bp"
block|,
literal|"fc"
block|,
literal|"cr"
block|}
decl_stmt|;
define|#
directive|define
name|SPEC128_NUM
value|((sizeof spec128_names) / (sizeof spec128_names[0]))
comment|/* Register names of registers 160-160+SPEC160_NUM-1.  */
specifier|static
name|char
modifier|*
name|spec160_names
index|[]
init|=
block|{
literal|"fpe"
block|,
literal|"inte"
block|,
literal|"fps"
block|,
literal|"sr163"
block|,
literal|"exop"
block|}
decl_stmt|;
define|#
directive|define
name|SPEC160_NUM
value|((sizeof spec160_names) / (sizeof spec160_names[0]))
if|if
condition|(
name|num
operator|<
name|SPEC0_NUM
condition|)
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
name|spec0_names
index|[
name|num
index|]
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|num
operator|>=
literal|128
operator|&&
name|num
operator|<
literal|128
operator|+
name|SPEC128_NUM
condition|)
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
name|spec128_names
index|[
name|num
operator|-
literal|128
index|]
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|num
operator|>=
literal|160
operator|&&
name|num
operator|<
literal|160
operator|+
name|SPEC160_NUM
condition|)
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
name|spec160_names
index|[
name|num
operator|-
literal|160
index|]
argument_list|)
expr_stmt|;
else|else
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"sr%d"
argument_list|,
name|num
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Is an instruction with OPCODE a delayed branch?  */
end_comment

begin_function
specifier|static
name|int
name|is_delayed_branch
parameter_list|(
name|opcode
parameter_list|)
name|int
name|opcode
decl_stmt|;
block|{
return|return
operator|(
name|opcode
operator|==
literal|0xa8
operator|||
name|opcode
operator|==
literal|0xa9
operator|||
name|opcode
operator|==
literal|0xa0
operator|||
name|opcode
operator|==
literal|0xa1
operator|||
name|opcode
operator|==
literal|0xa4
operator|||
name|opcode
operator|==
literal|0xa5
operator|||
name|opcode
operator|==
literal|0xb4
operator|||
name|opcode
operator|==
literal|0xb5
operator|||
name|opcode
operator|==
literal|0xc4
operator|||
name|opcode
operator|==
literal|0xc0
operator|||
name|opcode
operator|==
literal|0xac
operator|||
name|opcode
operator|==
literal|0xad
operator|||
name|opcode
operator|==
literal|0xcc
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Now find the four bytes of INSN and put them in *INSN{0,8,16,24}.    Note that the amd can be set up as either    big or little-endian (the tm file says which) and we can't assume    the host machine is the same.  */
end_comment

begin_function
specifier|static
name|void
name|find_bytes
parameter_list|(
name|insn
parameter_list|,
name|insn0
parameter_list|,
name|insn8
parameter_list|,
name|insn16
parameter_list|,
name|insn24
parameter_list|)
name|char
modifier|*
name|insn
decl_stmt|;
name|unsigned
name|char
modifier|*
name|insn0
decl_stmt|;
name|unsigned
name|char
modifier|*
name|insn8
decl_stmt|;
name|unsigned
name|char
modifier|*
name|insn16
decl_stmt|;
name|unsigned
name|char
modifier|*
name|insn24
decl_stmt|;
block|{
if|#
directive|if
name|TARGET_BYTE_ORDER
operator|==
name|BIG_ENDIAN
operator|*
name|insn24
operator|=
name|insn
index|[
literal|0
index|]
expr_stmt|;
operator|*
name|insn16
operator|=
name|insn
index|[
literal|1
index|]
expr_stmt|;
operator|*
name|insn8
operator|=
name|insn
index|[
literal|2
index|]
expr_stmt|;
operator|*
name|insn0
operator|=
name|insn
index|[
literal|3
index|]
expr_stmt|;
else|#
directive|else
comment|/* Little-endian.  */
operator|*
name|insn24
operator|=
name|insn
index|[
literal|3
index|]
expr_stmt|;
operator|*
name|insn16
operator|=
name|insn
index|[
literal|2
index|]
expr_stmt|;
operator|*
name|insn8
operator|=
name|insn
index|[
literal|1
index|]
expr_stmt|;
operator|*
name|insn0
operator|=
name|insn
index|[
literal|0
index|]
expr_stmt|;
endif|#
directive|endif
comment|/* Little-endian.  */
block|}
end_function

begin_comment
comment|/* Print one instruction from MEMADDR on STREAM.    Return the size of the instruction (always 4 on am29k).  */
end_comment

begin_function
name|int
name|print_insn
parameter_list|(
name|memaddr
parameter_list|,
name|stream
parameter_list|)
name|CORE_ADDR
name|memaddr
decl_stmt|;
name|FILE
modifier|*
name|stream
decl_stmt|;
block|{
comment|/* The raw instruction.  */
name|char
name|insn
index|[
literal|4
index|]
decl_stmt|;
comment|/* The four bytes of the instruction.  */
name|unsigned
name|char
name|insn24
decl_stmt|,
name|insn16
decl_stmt|,
name|insn8
decl_stmt|,
name|insn0
decl_stmt|;
name|struct
name|a29k_opcode
modifier|*
name|opcode
decl_stmt|;
name|read_memory
argument_list|(
name|memaddr
argument_list|,
operator|&
name|insn
index|[
literal|0
index|]
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|find_bytes
argument_list|(
name|insn
argument_list|,
operator|&
name|insn0
argument_list|,
operator|&
name|insn8
argument_list|,
operator|&
name|insn16
argument_list|,
operator|&
name|insn24
argument_list|)
expr_stmt|;
comment|/* Handle the nop (aseq 0x40,gr1,gr1) specially */
if|if
condition|(
operator|(
name|insn24
operator|==
literal|0x70
operator|)
operator|&&
operator|(
name|insn16
operator|==
literal|0x40
operator|)
operator|&&
operator|(
name|insn8
operator|==
literal|0x01
operator|)
operator|&&
operator|(
name|insn0
operator|==
literal|0x01
operator|)
condition|)
block|{
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"nop"
argument_list|)
expr_stmt|;
return|return
literal|4
return|;
block|}
comment|/* The opcode is always in insn24.  */
for|for
control|(
name|opcode
operator|=
operator|&
name|a29k_opcodes
index|[
literal|0
index|]
init|;
name|opcode
operator|<
operator|&
name|a29k_opcodes
index|[
name|num_opcodes
index|]
condition|;
operator|++
name|opcode
control|)
block|{
if|if
condition|(
operator|(
name|insn24
operator|<<
literal|24
operator|)
operator|==
name|opcode
operator|->
name|opcode
condition|)
block|{
name|char
modifier|*
name|s
decl_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"%s "
argument_list|,
name|opcode
operator|->
name|name
argument_list|)
expr_stmt|;
for|for
control|(
name|s
operator|=
name|opcode
operator|->
name|args
init|;
operator|*
name|s
operator|!=
literal|'\0'
condition|;
operator|++
name|s
control|)
block|{
switch|switch
condition|(
operator|*
name|s
condition|)
block|{
case|case
literal|'a'
case|:
name|print_general
argument_list|(
name|insn8
argument_list|,
name|stream
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
name|print_general
argument_list|(
name|insn0
argument_list|,
name|stream
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
name|print_general
argument_list|(
name|insn16
argument_list|,
name|stream
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"%d"
argument_list|,
name|insn0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"%d"
argument_list|,
operator|(
name|insn16
operator|<<
literal|8
operator|)
operator|+
name|insn0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'h'
case|:
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"0x%x"
argument_list|,
operator|(
name|insn16
operator|<<
literal|24
operator|)
operator|+
operator|(
name|insn0
operator|<<
literal|16
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'X'
case|:
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"%d"
argument_list|,
operator|(
operator|(
name|insn16
operator|<<
literal|8
operator|)
operator|+
name|insn0
operator|)
operator||
literal|0xffff0000
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'P'
case|:
comment|/* This output looks just like absolute addressing, but 		     maybe that's OK (it's what the GDB 68k and EBMON 		     29k disassemblers do).  */
comment|/* All the shifting is to sign-extend it.  p*/
name|print_address
argument_list|(
name|memaddr
operator|+
operator|(
operator|(
call|(
name|int
call|)
argument_list|(
operator|(
name|insn16
operator|<<
literal|10
operator|)
operator|+
operator|(
name|insn0
operator|<<
literal|2
operator|)
argument_list|)
operator|<<
literal|14
operator|)
operator|>>
literal|14
operator|)
argument_list|,
name|stream
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'A'
case|:
name|print_address
argument_list|(
operator|(
name|insn16
operator|<<
literal|10
operator|)
operator|+
operator|(
name|insn0
operator|<<
literal|2
operator|)
argument_list|,
name|stream
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"%d"
argument_list|,
name|insn16
operator|>>
literal|7
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"0x%x"
argument_list|,
name|insn16
operator|&
literal|0x7f
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"0x%x"
argument_list|,
name|insn16
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
name|print_special
argument_list|(
name|insn8
argument_list|,
name|stream
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'u'
case|:
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"%d"
argument_list|,
name|insn0
operator|>>
literal|7
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"%d"
argument_list|,
operator|(
name|insn0
operator|>>
literal|4
operator|)
operator|&
literal|7
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"%d"
argument_list|,
operator|(
name|insn0
operator|>>
literal|2
operator|)
operator|&
literal|3
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"%d"
argument_list|,
name|insn0
operator|&
literal|3
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'F'
case|:
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"%d"
argument_list|,
operator|(
name|insn16
operator|>>
literal|2
operator|)
operator|&
literal|15
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'C'
case|:
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"%d"
argument_list|,
name|insn16
operator|&
literal|3
argument_list|)
expr_stmt|;
break|break;
default|default:
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"%c"
argument_list|,
operator|*
name|s
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Now we look for a const,consth pair of instructions, 	     in which case we try to print the symbolic address.  */
if|if
condition|(
name|insn24
operator|==
literal|2
condition|)
comment|/* consth */
block|{
name|int
name|errcode
decl_stmt|;
name|char
name|prev_insn
index|[
literal|4
index|]
decl_stmt|;
name|unsigned
name|char
name|prev_insn0
decl_stmt|,
name|prev_insn8
decl_stmt|,
name|prev_insn16
decl_stmt|,
name|prev_insn24
decl_stmt|;
name|errcode
operator|=
name|target_read_memory
argument_list|(
name|memaddr
operator|-
literal|4
argument_list|,
operator|&
name|prev_insn
index|[
literal|0
index|]
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|errcode
operator|==
literal|0
condition|)
block|{
comment|/* If it is a delayed branch, we need to look at the 		     instruction before the delayed brach to handle 		     things like 		      		     const _foo 		     call _printf 		     consth _foo 		     */
name|find_bytes
argument_list|(
name|prev_insn
argument_list|,
operator|&
name|prev_insn0
argument_list|,
operator|&
name|prev_insn8
argument_list|,
operator|&
name|prev_insn16
argument_list|,
operator|&
name|prev_insn24
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_delayed_branch
argument_list|(
name|prev_insn24
argument_list|)
condition|)
block|{
name|errcode
operator|=
name|target_read_memory
argument_list|(
name|memaddr
operator|-
literal|8
argument_list|,
operator|&
name|prev_insn
index|[
literal|0
index|]
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|find_bytes
argument_list|(
name|prev_insn
argument_list|,
operator|&
name|prev_insn0
argument_list|,
operator|&
name|prev_insn8
argument_list|,
operator|&
name|prev_insn16
argument_list|,
operator|&
name|prev_insn24
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* If there was a problem reading memory, then assume 		 the previous instruction was not const.  */
if|if
condition|(
name|errcode
operator|==
literal|0
condition|)
block|{
comment|/* Is it const to the same register?  */
if|if
condition|(
name|prev_insn24
operator|==
literal|3
operator|&&
name|prev_insn8
operator|==
name|insn8
condition|)
block|{
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"\t; "
argument_list|)
expr_stmt|;
name|print_address
argument_list|(
operator|(
operator|(
name|insn16
operator|<<
literal|24
operator|)
operator|+
operator|(
name|insn0
operator|<<
literal|16
operator|)
operator|+
operator|(
name|prev_insn16
operator|<<
literal|8
operator|)
operator|+
operator|(
name|prev_insn0
operator|)
operator|)
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
literal|4
return|;
block|}
block|}
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|".word 0x%8x"
argument_list|,
operator|(
name|insn24
operator|<<
literal|24
operator|)
operator|+
operator|(
name|insn16
operator|<<
literal|16
operator|)
operator|+
operator|(
name|insn8
operator|<<
literal|8
operator|)
operator|+
name|insn0
argument_list|)
expr_stmt|;
return|return
literal|4
return|;
block|}
end_function

end_unit

