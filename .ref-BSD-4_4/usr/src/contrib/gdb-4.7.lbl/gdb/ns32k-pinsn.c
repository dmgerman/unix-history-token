begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Print National Semiconductor 32000 instructions for GDB, the GNU debugger.    Copyright 1986, 1988, 1991, 1992 Free Software Foundation, Inc.  This file is part of GDB.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"symtab.h"
end_include

begin_include
include|#
directive|include
file|"ns32k-opcode.h"
end_include

begin_include
include|#
directive|include
file|"gdbcore.h"
end_include

begin_comment
comment|/* 32000 instructions are never longer than this.  */
end_comment

begin_define
define|#
directive|define
name|MAXLEN
value|62
end_define

begin_comment
comment|/* Number of elements in the opcode table.  */
end_comment

begin_define
define|#
directive|define
name|NOPCODES
value|(sizeof notstrs / sizeof notstrs[0])
end_define

begin_define
define|#
directive|define
name|NEXT_IS_ADDR
value|'|'
end_define

begin_comment
comment|/*  * extract "count" bits starting "offset" bits  * into buffer  */
end_comment

begin_function
name|int
name|bit_extract
parameter_list|(
name|buffer
parameter_list|,
name|offset
parameter_list|,
name|count
parameter_list|)
name|char
modifier|*
name|buffer
decl_stmt|;
name|int
name|offset
decl_stmt|;
name|int
name|count
decl_stmt|;
block|{
name|int
name|result
decl_stmt|;
name|int
name|mask
decl_stmt|;
name|int
name|bit
decl_stmt|;
name|buffer
operator|+=
name|offset
operator|>>
literal|3
expr_stmt|;
name|offset
operator|&=
literal|7
expr_stmt|;
name|bit
operator|=
literal|1
expr_stmt|;
name|result
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|count
operator|--
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|buffer
operator|&
operator|(
literal|1
operator|<<
name|offset
operator|)
operator|)
condition|)
name|result
operator||=
name|bit
expr_stmt|;
if|if
condition|(
operator|++
name|offset
operator|==
literal|8
condition|)
block|{
name|offset
operator|=
literal|0
expr_stmt|;
name|buffer
operator|++
expr_stmt|;
block|}
name|bit
operator|<<=
literal|1
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function

begin_function
name|float
name|fbit_extract
parameter_list|(
name|buffer
parameter_list|,
name|offset
parameter_list|,
name|count
parameter_list|)
block|{
union|union
block|{
name|int
name|ival
decl_stmt|;
name|float
name|fval
decl_stmt|;
block|}
name|foo
union|;
name|foo
operator|.
name|ival
operator|=
name|bit_extract
argument_list|(
name|buffer
argument_list|,
name|offset
argument_list|,
literal|32
argument_list|)
expr_stmt|;
return|return
name|foo
operator|.
name|fval
return|;
block|}
end_function

begin_function
name|double
name|dbit_extract
parameter_list|(
name|buffer
parameter_list|,
name|offset
parameter_list|,
name|count
parameter_list|)
block|{
union|union
block|{
struct|struct
block|{
name|int
name|low
decl_stmt|,
name|high
decl_stmt|;
block|}
name|ival
struct|;
name|double
name|dval
decl_stmt|;
block|}
name|foo
union|;
name|foo
operator|.
name|ival
operator|.
name|low
operator|=
name|bit_extract
argument_list|(
name|buffer
argument_list|,
name|offset
argument_list|,
literal|32
argument_list|)
expr_stmt|;
name|foo
operator|.
name|ival
operator|.
name|high
operator|=
name|bit_extract
argument_list|(
name|buffer
argument_list|,
name|offset
operator|+
literal|32
argument_list|,
literal|32
argument_list|)
expr_stmt|;
return|return
name|foo
operator|.
name|dval
return|;
block|}
end_function

begin_macro
name|sign_extend
argument_list|(
argument|value
argument_list|,
argument|bits
argument_list|)
end_macro

begin_block
block|{
name|value
operator|=
name|value
operator|&
operator|(
operator|(
literal|1
operator|<<
name|bits
operator|)
operator|-
literal|1
operator|)
expr_stmt|;
return|return
operator|(
name|value
operator|&
operator|(
literal|1
operator|<<
operator|(
name|bits
operator|-
literal|1
operator|)
operator|)
condition|?
name|value
operator||
operator|(
operator|~
operator|(
operator|(
literal|1
operator|<<
name|bits
operator|)
operator|-
literal|1
operator|)
operator|)
else|:
name|value
operator|)
return|;
block|}
end_block

begin_macro
name|flip_bytes
argument_list|(
argument|ptr
argument_list|,
argument|count
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|ptr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|count
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
name|tmp
decl_stmt|;
while|while
condition|(
name|count
operator|>
literal|0
condition|)
block|{
name|tmp
operator|=
operator|*
name|ptr
expr_stmt|;
name|ptr
index|[
literal|0
index|]
operator|=
name|ptr
index|[
name|count
operator|-
literal|1
index|]
expr_stmt|;
name|ptr
index|[
name|count
operator|-
literal|1
index|]
operator|=
name|tmp
expr_stmt|;
name|ptr
operator|++
expr_stmt|;
name|count
operator|-=
literal|2
expr_stmt|;
block|}
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* Given a character C, does it represent a general addressing mode?  */
end_comment

begin_define
define|#
directive|define
name|Is_gen
parameter_list|(
name|c
parameter_list|)
define|\
value|((c) == 'F' || (c) == 'L' || (c) == 'B' \    || (c) == 'W' || (c) == 'D' || (c) == 'A')
end_define

begin_comment
comment|/* Adressing modes.  */
end_comment

begin_define
define|#
directive|define
name|Adrmod_index_byte
value|0x1c
end_define

begin_define
define|#
directive|define
name|Adrmod_index_word
value|0x1d
end_define

begin_define
define|#
directive|define
name|Adrmod_index_doubleword
value|0x1e
end_define

begin_define
define|#
directive|define
name|Adrmod_index_quadword
value|0x1f
end_define

begin_comment
comment|/* Is MODE an indexed addressing mode?  */
end_comment

begin_define
define|#
directive|define
name|Adrmod_is_index
parameter_list|(
name|mode
parameter_list|)
define|\
value|(mode == Adrmod_index_byte \    || mode == Adrmod_index_word \    || mode == Adrmod_index_doubleword \    || mode == Adrmod_index_quadword)
end_define

begin_escape
end_escape

begin_comment
comment|/* Print the 32000 instruction at address MEMADDR in debugged memory,    on STREAM.  Returns length of the instruction, in bytes.  */
end_comment

begin_function
name|int
name|print_insn
parameter_list|(
name|memaddr
parameter_list|,
name|stream
parameter_list|)
name|CORE_ADDR
name|memaddr
decl_stmt|;
name|FILE
modifier|*
name|stream
decl_stmt|;
block|{
name|unsigned
name|char
name|buffer
index|[
name|MAXLEN
index|]
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|unsigned
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|char
modifier|*
name|d
decl_stmt|;
name|unsigned
name|short
name|first_word
decl_stmt|;
name|int
name|gen
decl_stmt|,
name|disp
decl_stmt|;
name|int
name|ioffset
decl_stmt|;
comment|/* bits into instruction */
name|int
name|aoffset
decl_stmt|;
comment|/* bits into arguments */
name|char
name|arg_bufs
index|[
name|MAX_ARGS
operator|+
literal|1
index|]
index|[
name|ARG_LEN
index|]
decl_stmt|;
name|int
name|argnum
decl_stmt|;
name|int
name|maxarg
decl_stmt|;
name|read_memory
argument_list|(
name|memaddr
argument_list|,
name|buffer
argument_list|,
name|MAXLEN
argument_list|)
expr_stmt|;
name|first_word
operator|=
operator|*
operator|(
name|unsigned
name|short
operator|*
operator|)
name|buffer
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NOPCODES
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|(
name|first_word
operator|&
operator|(
operator|(
literal|1
operator|<<
name|notstrs
index|[
name|i
index|]
operator|.
name|detail
operator|.
name|obits
operator|)
operator|-
literal|1
operator|)
operator|)
operator|==
name|notstrs
index|[
name|i
index|]
operator|.
name|detail
operator|.
name|code
condition|)
break|break;
comment|/* Handle undefined instructions.  */
if|if
condition|(
name|i
operator|==
name|NOPCODES
condition|)
block|{
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"0%o"
argument_list|,
name|buffer
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"%s"
argument_list|,
name|notstrs
index|[
name|i
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
name|ioffset
operator|=
name|notstrs
index|[
name|i
index|]
operator|.
name|detail
operator|.
name|ibits
expr_stmt|;
name|aoffset
operator|=
name|notstrs
index|[
name|i
index|]
operator|.
name|detail
operator|.
name|ibits
expr_stmt|;
name|d
operator|=
name|notstrs
index|[
name|i
index|]
operator|.
name|detail
operator|.
name|args
expr_stmt|;
if|if
condition|(
operator|*
name|d
condition|)
block|{
comment|/* Offset in bits of the first thing beyond each index byte. 	 Element 0 is for operand A and element 1 is for operand B. 	 The rest are irrelevant, but we put them here so we don't 	 index outside the array.  */
name|int
name|index_offset
index|[
name|MAX_ARGS
index|]
decl_stmt|;
comment|/* 0 for operand A, 1 for operand B, greater for other args.  */
name|int
name|whicharg
init|=
literal|0
decl_stmt|;
name|fputc
argument_list|(
literal|'\t'
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|maxarg
operator|=
literal|0
expr_stmt|;
comment|/* First we have to find and keep track of the index bytes, 	 if we are using scaled indexed addressing mode, since the index 	 bytes occur right after the basic instruction, not as part 	 of the addressing extension.  */
if|if
condition|(
name|Is_gen
argument_list|(
name|d
index|[
literal|1
index|]
argument_list|)
condition|)
block|{
name|int
name|addr_mode
init|=
name|bit_extract
argument_list|(
name|buffer
argument_list|,
name|ioffset
operator|-
literal|5
argument_list|,
literal|5
argument_list|)
decl_stmt|;
if|if
condition|(
name|Adrmod_is_index
argument_list|(
name|addr_mode
argument_list|)
condition|)
block|{
name|aoffset
operator|+=
literal|8
expr_stmt|;
name|index_offset
index|[
literal|0
index|]
operator|=
name|aoffset
expr_stmt|;
block|}
block|}
if|if
condition|(
name|d
index|[
literal|2
index|]
operator|&&
name|Is_gen
argument_list|(
name|d
index|[
literal|3
index|]
argument_list|)
condition|)
block|{
name|int
name|addr_mode
init|=
name|bit_extract
argument_list|(
name|buffer
argument_list|,
name|ioffset
operator|-
literal|10
argument_list|,
literal|5
argument_list|)
decl_stmt|;
if|if
condition|(
name|Adrmod_is_index
argument_list|(
name|addr_mode
argument_list|)
condition|)
block|{
name|aoffset
operator|+=
literal|8
expr_stmt|;
name|index_offset
index|[
literal|1
index|]
operator|=
name|aoffset
expr_stmt|;
block|}
block|}
while|while
condition|(
operator|*
name|d
condition|)
block|{
name|argnum
operator|=
operator|*
name|d
operator|-
literal|'1'
expr_stmt|;
name|d
operator|++
expr_stmt|;
if|if
condition|(
name|argnum
operator|>
name|maxarg
operator|&&
name|argnum
operator|<
name|MAX_ARGS
condition|)
name|maxarg
operator|=
name|argnum
expr_stmt|;
name|ioffset
operator|=
name|print_insn_arg
argument_list|(
operator|*
name|d
argument_list|,
name|ioffset
argument_list|,
operator|&
name|aoffset
argument_list|,
name|buffer
argument_list|,
name|memaddr
argument_list|,
name|arg_bufs
index|[
name|argnum
index|]
argument_list|,
name|index_offset
index|[
name|whicharg
index|]
argument_list|)
expr_stmt|;
name|d
operator|++
expr_stmt|;
name|whicharg
operator|++
expr_stmt|;
block|}
for|for
control|(
name|argnum
operator|=
literal|0
init|;
name|argnum
operator|<=
name|maxarg
condition|;
name|argnum
operator|++
control|)
block|{
name|CORE_ADDR
name|addr
decl_stmt|;
name|char
modifier|*
name|ch
decl_stmt|,
modifier|*
name|index
argument_list|()
decl_stmt|;
for|for
control|(
name|ch
operator|=
name|arg_bufs
index|[
name|argnum
index|]
init|;
operator|*
name|ch
condition|;
control|)
block|{
if|if
condition|(
operator|*
name|ch
operator|==
name|NEXT_IS_ADDR
condition|)
block|{
operator|++
name|ch
expr_stmt|;
name|addr
operator|=
name|atoi
argument_list|(
name|ch
argument_list|)
expr_stmt|;
name|print_address
argument_list|(
name|addr
argument_list|,
name|stream
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|ch
operator|&&
operator|*
name|ch
operator|!=
name|NEXT_IS_ADDR
condition|)
operator|++
name|ch
expr_stmt|;
if|if
condition|(
operator|*
name|ch
condition|)
operator|++
name|ch
expr_stmt|;
block|}
else|else
name|putc
argument_list|(
operator|*
name|ch
operator|++
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|argnum
operator|<
name|maxarg
condition|)
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|", "
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|aoffset
operator|/
literal|8
return|;
block|}
end_function

begin_comment
comment|/* Print an instruction operand of category given by d.  IOFFSET is    the bit position below which small (<1 byte) parts of the operand can    be found (usually in the basic instruction, but for indexed    addressing it can be in the index byte).  AOFFSETP is a pointer to the    bit position of the addressing extension.  BUFFER contains the    instruction.  ADDR is where BUFFER was read from.  Put the disassembled    version of the operand in RESULT.  INDEX_OFFSET is the bit position    of the index byte (it contains garbage if this operand is not a    general operand using scaled indexed addressing mode).  */
end_comment

begin_macro
name|print_insn_arg
argument_list|(
argument|d
argument_list|,
argument|ioffset
argument_list|,
argument|aoffsetp
argument_list|,
argument|buffer
argument_list|,
argument|addr
argument_list|,
argument|result
argument_list|,
argument|index_offset
argument_list|)
end_macro

begin_decl_stmt
name|char
name|d
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|ioffset
decl_stmt|,
modifier|*
name|aoffsetp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|buffer
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|CORE_ADDR
name|addr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|result
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|index_offset
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|addr_mode
decl_stmt|;
name|float
name|Fvalue
decl_stmt|;
name|double
name|Lvalue
decl_stmt|;
name|int
name|Ivalue
decl_stmt|;
name|int
name|disp1
decl_stmt|,
name|disp2
decl_stmt|;
name|int
name|index
decl_stmt|;
switch|switch
condition|(
name|d
condition|)
block|{
case|case
literal|'F'
case|:
case|case
literal|'L'
case|:
case|case
literal|'B'
case|:
case|case
literal|'W'
case|:
case|case
literal|'D'
case|:
case|case
literal|'A'
case|:
name|addr_mode
operator|=
name|bit_extract
argument_list|(
name|buffer
argument_list|,
name|ioffset
operator|-
literal|5
argument_list|,
literal|5
argument_list|)
expr_stmt|;
name|ioffset
operator|-=
literal|5
expr_stmt|;
switch|switch
condition|(
name|addr_mode
condition|)
block|{
case|case
literal|0x0
case|:
case|case
literal|0x1
case|:
case|case
literal|0x2
case|:
case|case
literal|0x3
case|:
case|case
literal|0x4
case|:
case|case
literal|0x5
case|:
case|case
literal|0x6
case|:
case|case
literal|0x7
case|:
switch|switch
condition|(
name|d
condition|)
block|{
case|case
literal|'F'
case|:
case|case
literal|'L'
case|:
name|sprintf
argument_list|(
name|result
argument_list|,
literal|"f%d"
argument_list|,
name|addr_mode
argument_list|)
expr_stmt|;
break|break;
default|default:
name|sprintf
argument_list|(
name|result
argument_list|,
literal|"r%d"
argument_list|,
name|addr_mode
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|0x8
case|:
case|case
literal|0x9
case|:
case|case
literal|0xa
case|:
case|case
literal|0xb
case|:
case|case
literal|0xc
case|:
case|case
literal|0xd
case|:
case|case
literal|0xe
case|:
case|case
literal|0xf
case|:
name|disp1
operator|=
name|get_displacement
argument_list|(
name|buffer
argument_list|,
name|aoffsetp
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|result
argument_list|,
literal|"%d(r%d)"
argument_list|,
name|disp1
argument_list|,
name|addr_mode
operator|&
literal|7
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x10
case|:
case|case
literal|0x11
case|:
case|case
literal|0x12
case|:
name|disp1
operator|=
name|get_displacement
argument_list|(
name|buffer
argument_list|,
name|aoffsetp
argument_list|)
expr_stmt|;
name|disp2
operator|=
name|get_displacement
argument_list|(
name|buffer
argument_list|,
name|aoffsetp
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|result
argument_list|,
literal|"%d(%d(%s))"
argument_list|,
name|disp2
argument_list|,
name|disp1
argument_list|,
name|addr_mode
operator|==
literal|0x10
condition|?
literal|"fp"
else|:
name|addr_mode
operator|==
literal|0x11
condition|?
literal|"sp"
else|:
literal|"sb"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x13
case|:
name|sprintf
argument_list|(
name|result
argument_list|,
literal|"reserved"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x14
case|:
switch|switch
condition|(
name|d
condition|)
block|{
case|case
literal|'B'
case|:
name|Ivalue
operator|=
name|bit_extract
argument_list|(
name|buffer
argument_list|,
operator|*
name|aoffsetp
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|Ivalue
operator|=
name|sign_extend
argument_list|(
name|Ivalue
argument_list|,
literal|8
argument_list|)
expr_stmt|;
operator|*
name|aoffsetp
operator|+=
literal|8
expr_stmt|;
name|sprintf
argument_list|(
name|result
argument_list|,
literal|"$%d"
argument_list|,
name|Ivalue
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'W'
case|:
name|Ivalue
operator|=
name|bit_extract
argument_list|(
name|buffer
argument_list|,
operator|*
name|aoffsetp
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|flip_bytes
argument_list|(
operator|&
name|Ivalue
argument_list|,
literal|2
argument_list|)
expr_stmt|;
operator|*
name|aoffsetp
operator|+=
literal|16
expr_stmt|;
name|Ivalue
operator|=
name|sign_extend
argument_list|(
name|Ivalue
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|result
argument_list|,
literal|"$%d"
argument_list|,
name|Ivalue
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'D'
case|:
name|Ivalue
operator|=
name|bit_extract
argument_list|(
name|buffer
argument_list|,
operator|*
name|aoffsetp
argument_list|,
literal|32
argument_list|)
expr_stmt|;
name|flip_bytes
argument_list|(
operator|&
name|Ivalue
argument_list|,
literal|4
argument_list|)
expr_stmt|;
operator|*
name|aoffsetp
operator|+=
literal|32
expr_stmt|;
name|sprintf
argument_list|(
name|result
argument_list|,
literal|"$%d"
argument_list|,
name|Ivalue
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'A'
case|:
name|Ivalue
operator|=
name|bit_extract
argument_list|(
name|buffer
argument_list|,
operator|*
name|aoffsetp
argument_list|,
literal|32
argument_list|)
expr_stmt|;
name|flip_bytes
argument_list|(
operator|&
name|Ivalue
argument_list|,
literal|4
argument_list|)
expr_stmt|;
operator|*
name|aoffsetp
operator|+=
literal|32
expr_stmt|;
name|sprintf
argument_list|(
name|result
argument_list|,
literal|"$|%d|"
argument_list|,
name|Ivalue
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'F'
case|:
name|Fvalue
operator|=
name|fbit_extract
argument_list|(
name|buffer
argument_list|,
operator|*
name|aoffsetp
argument_list|,
literal|32
argument_list|)
expr_stmt|;
name|flip_bytes
argument_list|(
operator|&
name|Fvalue
argument_list|,
literal|4
argument_list|)
expr_stmt|;
operator|*
name|aoffsetp
operator|+=
literal|32
expr_stmt|;
name|sprintf
argument_list|(
name|result
argument_list|,
literal|"$%g"
argument_list|,
name|Fvalue
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'L'
case|:
name|Lvalue
operator|=
name|dbit_extract
argument_list|(
name|buffer
argument_list|,
operator|*
name|aoffsetp
argument_list|,
literal|64
argument_list|)
expr_stmt|;
name|flip_bytes
argument_list|(
operator|&
name|Lvalue
argument_list|,
literal|8
argument_list|)
expr_stmt|;
operator|*
name|aoffsetp
operator|+=
literal|64
expr_stmt|;
name|sprintf
argument_list|(
name|result
argument_list|,
literal|"$%g"
argument_list|,
name|Lvalue
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
literal|0x15
case|:
name|disp1
operator|=
name|get_displacement
argument_list|(
name|buffer
argument_list|,
name|aoffsetp
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|result
argument_list|,
literal|"@|%d|"
argument_list|,
name|disp1
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x16
case|:
name|disp1
operator|=
name|get_displacement
argument_list|(
name|buffer
argument_list|,
name|aoffsetp
argument_list|)
expr_stmt|;
name|disp2
operator|=
name|get_displacement
argument_list|(
name|buffer
argument_list|,
name|aoffsetp
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|result
argument_list|,
literal|"EXT(%d) + %d"
argument_list|,
name|disp1
argument_list|,
name|disp2
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x17
case|:
name|sprintf
argument_list|(
name|result
argument_list|,
literal|"tos"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x18
case|:
name|disp1
operator|=
name|get_displacement
argument_list|(
name|buffer
argument_list|,
name|aoffsetp
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|result
argument_list|,
literal|"%d(fp)"
argument_list|,
name|disp1
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x19
case|:
name|disp1
operator|=
name|get_displacement
argument_list|(
name|buffer
argument_list|,
name|aoffsetp
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|result
argument_list|,
literal|"%d(sp)"
argument_list|,
name|disp1
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x1a
case|:
name|disp1
operator|=
name|get_displacement
argument_list|(
name|buffer
argument_list|,
name|aoffsetp
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|result
argument_list|,
literal|"%d(sb)"
argument_list|,
name|disp1
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x1b
case|:
name|disp1
operator|=
name|get_displacement
argument_list|(
name|buffer
argument_list|,
name|aoffsetp
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|result
argument_list|,
literal|"|%d|"
argument_list|,
name|addr
operator|+
name|disp1
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x1c
case|:
case|case
literal|0x1d
case|:
case|case
literal|0x1e
case|:
case|case
literal|0x1f
case|:
name|index
operator|=
name|bit_extract
argument_list|(
name|buffer
argument_list|,
name|index_offset
operator|-
literal|8
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|print_insn_arg
argument_list|(
name|d
argument_list|,
name|index_offset
argument_list|,
name|aoffsetp
argument_list|,
name|buffer
argument_list|,
name|addr
argument_list|,
name|result
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|{
specifier|static
name|char
modifier|*
name|ind
index|[]
init|=
block|{
literal|"b"
block|,
literal|"w"
block|,
literal|"d"
block|,
literal|"q"
block|}
decl_stmt|;
name|char
modifier|*
name|off
decl_stmt|;
name|off
operator|=
name|result
operator|+
name|strlen
argument_list|(
name|result
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|off
argument_list|,
literal|"[r%d:%s]"
argument_list|,
name|index
argument_list|,
name|ind
index|[
name|addr_mode
operator|&
literal|3
index|]
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
break|break;
case|case
literal|'q'
case|:
name|Ivalue
operator|=
name|bit_extract
argument_list|(
name|buffer
argument_list|,
name|ioffset
operator|-
literal|4
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|Ivalue
operator|=
name|sign_extend
argument_list|(
name|Ivalue
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|result
argument_list|,
literal|"%d"
argument_list|,
name|Ivalue
argument_list|)
expr_stmt|;
name|ioffset
operator|-=
literal|4
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
name|Ivalue
operator|=
name|bit_extract
argument_list|(
name|buffer
argument_list|,
name|ioffset
operator|-
literal|3
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|result
argument_list|,
literal|"r%d"
argument_list|,
name|Ivalue
operator|&
literal|7
argument_list|)
expr_stmt|;
name|ioffset
operator|-=
literal|3
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|sprintf
argument_list|(
name|result
argument_list|,
literal|"%d"
argument_list|,
name|get_displacement
argument_list|(
name|buffer
argument_list|,
name|aoffsetp
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
name|sprintf
argument_list|(
name|result
argument_list|,
literal|"%c%d%c"
argument_list|,
name|NEXT_IS_ADDR
argument_list|,
name|addr
operator|+
name|get_displacement
argument_list|(
name|buffer
argument_list|,
name|aoffsetp
argument_list|)
argument_list|,
name|NEXT_IS_ADDR
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
name|Ivalue
operator|=
name|bit_extract
argument_list|(
name|buffer
argument_list|,
operator|*
name|aoffsetp
argument_list|,
literal|8
argument_list|)
expr_stmt|;
operator|*
name|aoffsetp
operator|+=
literal|8
expr_stmt|;
name|sprintf
argument_list|(
name|result
argument_list|,
literal|"0x%x"
argument_list|,
name|Ivalue
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
name|ioffset
return|;
block|}
end_block

begin_macro
name|get_displacement
argument_list|(
argument|buffer
argument_list|,
argument|aoffsetp
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|buffer
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
modifier|*
name|aoffsetp
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|Ivalue
decl_stmt|;
name|Ivalue
operator|=
name|bit_extract
argument_list|(
name|buffer
argument_list|,
operator|*
name|aoffsetp
argument_list|,
literal|8
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|Ivalue
operator|&
literal|0xc0
condition|)
block|{
case|case
literal|0x00
case|:
case|case
literal|0x40
case|:
name|Ivalue
operator|=
name|sign_extend
argument_list|(
name|Ivalue
argument_list|,
literal|7
argument_list|)
expr_stmt|;
operator|*
name|aoffsetp
operator|+=
literal|8
expr_stmt|;
break|break;
case|case
literal|0x80
case|:
name|Ivalue
operator|=
name|bit_extract
argument_list|(
name|buffer
argument_list|,
operator|*
name|aoffsetp
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|flip_bytes
argument_list|(
operator|&
name|Ivalue
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|Ivalue
operator|=
name|sign_extend
argument_list|(
name|Ivalue
argument_list|,
literal|14
argument_list|)
expr_stmt|;
operator|*
name|aoffsetp
operator|+=
literal|16
expr_stmt|;
break|break;
case|case
literal|0xc0
case|:
name|Ivalue
operator|=
name|bit_extract
argument_list|(
name|buffer
argument_list|,
operator|*
name|aoffsetp
argument_list|,
literal|32
argument_list|)
expr_stmt|;
name|flip_bytes
argument_list|(
operator|&
name|Ivalue
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|Ivalue
operator|=
name|sign_extend
argument_list|(
name|Ivalue
argument_list|,
literal|30
argument_list|)
expr_stmt|;
operator|*
name|aoffsetp
operator|+=
literal|32
expr_stmt|;
break|break;
block|}
return|return
name|Ivalue
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* Return the number of locals in the current frame given a pc    pointing to the enter instruction.  This is used in the macro    FRAME_FIND_SAVED_REGS.  */
end_comment

begin_macro
name|ns32k_localcount
argument_list|(
argument|enter_pc
argument_list|)
end_macro

begin_decl_stmt
name|CORE_ADDR
name|enter_pc
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|unsigned
name|char
name|localtype
decl_stmt|;
name|int
name|localcount
decl_stmt|;
name|localtype
operator|=
name|read_memory_integer
argument_list|(
name|enter_pc
operator|+
literal|2
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|localtype
operator|&
literal|0x80
operator|)
operator|==
literal|0
condition|)
name|localcount
operator|=
name|localtype
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|localtype
operator|&
literal|0xc0
operator|)
operator|==
literal|0x80
condition|)
name|localcount
operator|=
operator|(
operator|(
operator|(
name|localtype
operator|&
literal|0x3f
operator|)
operator|<<
literal|8
operator|)
operator||
operator|(
name|read_memory_integer
argument_list|(
name|enter_pc
operator|+
literal|3
argument_list|,
literal|1
argument_list|)
operator|&
literal|0xff
operator|)
operator|)
expr_stmt|;
else|else
name|localcount
operator|=
operator|(
operator|(
operator|(
name|localtype
operator|&
literal|0x3f
operator|)
operator|<<
literal|24
operator|)
operator||
operator|(
operator|(
name|read_memory_integer
argument_list|(
name|enter_pc
operator|+
literal|3
argument_list|,
literal|1
argument_list|)
operator|&
literal|0xff
operator|)
operator|<<
literal|16
operator|)
operator||
operator|(
operator|(
name|read_memory_integer
argument_list|(
name|enter_pc
operator|+
literal|4
argument_list|,
literal|1
argument_list|)
operator|&
literal|0xff
operator|)
operator|<<
literal|8
operator|)
operator||
operator|(
name|read_memory_integer
argument_list|(
name|enter_pc
operator|+
literal|5
argument_list|,
literal|1
argument_list|)
operator|&
literal|0xff
operator|)
operator|)
expr_stmt|;
return|return
name|localcount
return|;
block|}
end_block

begin_comment
comment|/*  * Get the address of the enter opcode for the function  * containing PC, if there is an enter for the function,  * and if the pc is between the enter and exit.  * Returns positive address if pc is between enter/exit,  * 1 if pc before enter or after exit, 0 otherwise.  */
end_comment

begin_function
name|CORE_ADDR
name|ns32k_get_enter_addr
parameter_list|(
name|pc
parameter_list|)
name|CORE_ADDR
name|pc
decl_stmt|;
block|{
name|CORE_ADDR
name|enter_addr
decl_stmt|;
name|unsigned
name|char
name|op
decl_stmt|;
if|if
condition|(
name|ABOUT_TO_RETURN
argument_list|(
name|pc
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* after exit */
name|enter_addr
operator|=
name|get_pc_function_start
argument_list|(
name|pc
argument_list|)
expr_stmt|;
if|if
condition|(
name|pc
operator|==
name|enter_addr
condition|)
return|return
literal|1
return|;
comment|/* before enter */
name|op
operator|=
name|read_memory_integer
argument_list|(
name|enter_addr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|op
operator|!=
literal|0x82
condition|)
return|return
literal|0
return|;
comment|/* function has no enter/exit */
return|return
name|enter_addr
return|;
comment|/* pc is between enter and exit */
block|}
end_function

end_unit

