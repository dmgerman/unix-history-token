begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* mhlsbr.c - implement the "nifty" message lister */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|ident
index|[]
init|=
literal|"@(#)$Id: mhlsbr.c,v 1.28 1992/12/15 00:20:22 jromine Exp $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* lint */
end_comment

begin_include
include|#
directive|include
file|"../h/mh.h"
end_include

begin_include
include|#
directive|include
file|"../h/addrsbr.h"
end_include

begin_include
include|#
directive|include
file|"../h/formatsbr.h"
end_include

begin_include
include|#
directive|include
file|"../zotnet/tws.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|SVR4
end_ifdef

begin_undef
undef|#
directive|undef
name|NULLVP
end_undef

begin_comment
comment|/* XXX  */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|SYS5
argument_list|)
operator|&&
name|defined
argument_list|(
name|AUX
argument_list|)
end_if

begin_define
define|#
directive|define
name|u_short
value|ushort
end_define

begin_define
define|#
directive|define
name|u_long
value|ulong
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<setjmp.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_comment
comment|/* MAJOR BUG:    for a component containing addresses, ADDRFMT, if COMPRESS is also    set, then addresses get split wrong (not at the spaces between commas).    To fix this correctly, putstr() should know about "atomic" strings that    must NOT be broken across lines.  That's too difficult for right now    (it turns out that there are a number of degernate cases), so in    oneline(), instead of  		     (*onelp == '\n'&& !onelp[1])     being a terminating condition,  	 (*onelp == '\n'&& (!onelp[1] || (flags& ADDRFMT)))     is used instead.  This cuts the line prematurely, and gives us a much    better chance of getting things right.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|SYS5
end_ifdef

begin_define
define|#
directive|define
name|u_short
value|ushort
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SYS5 */
end_comment

begin_define
define|#
directive|define
name|ONECOMP
value|0
end_define

begin_define
define|#
directive|define
name|TWOCOMP
value|1
end_define

begin_define
define|#
directive|define
name|BODYCOMP
value|2
end_define

begin_define
define|#
directive|define
name|adios
value|mhladios
end_define

begin_define
define|#
directive|define
name|done
value|mhldone
end_define

begin_define
define|#
directive|define
name|QUOTE
value|'\\'
end_define

begin_comment
comment|/*
comment|*/
end_comment

begin_decl_stmt
specifier|static
name|struct
name|swit
name|mhlswitches
index|[]
init|=
block|{
define|#
directive|define
name|BELLSW
value|0
literal|"bell"
block|,
literal|0
block|,
define|#
directive|define
name|NBELLSW
value|1
literal|"nobell"
block|,
literal|0
block|,
define|#
directive|define
name|CLRSW
value|2
literal|"clear"
block|,
literal|0
block|,
define|#
directive|define
name|NCLRSW
value|3
literal|"noclear"
block|,
literal|0
block|,
define|#
directive|define
name|FACESW
value|4
literal|"faceproc program"
block|,
literal|0
block|,
define|#
directive|define
name|NFACESW
value|5
literal|"nofaceproc"
block|,
literal|0
block|,
define|#
directive|define
name|FOLDSW
value|6
literal|"folder +folder"
block|,
literal|0
block|,
define|#
directive|define
name|FORMSW
value|7
literal|"form formfile"
block|,
literal|0
block|,
define|#
directive|define
name|PROGSW
value|8
literal|"moreproc program"
block|,
literal|0
block|,
define|#
directive|define
name|NPROGSW
value|9
literal|"nomoreproc"
block|,
literal|0
block|,
define|#
directive|define
name|LENSW
value|10
literal|"length lines"
block|,
literal|0
block|,
define|#
directive|define
name|WIDSW
value|11
literal|"width columns"
block|,
literal|0
block|,
define|#
directive|define
name|SLEEPSW
value|12
literal|"sleep seconds"
block|,
literal|0
block|,
define|#
directive|define
name|DASHSW
value|13
literal|"dashmunging"
block|,
operator|-
literal|4
block|,
define|#
directive|define
name|NDASHSW
value|14
literal|"nodashmunging"
block|,
operator|-
literal|6
block|,
define|#
directive|define
name|HELPSW
value|15
literal|"help"
block|,
literal|4
block|,
define|#
directive|define
name|FORW1SW
value|16
literal|"forward"
block|,
operator|-
literal|7
block|,
comment|/* interface from forw */
define|#
directive|define
name|FORW2SW
value|17
literal|"forwall"
block|,
operator|-
literal|7
block|,
comment|/*   .. */
define|#
directive|define
name|DGSTSW
value|18
literal|"digest list"
block|,
operator|-
literal|6
block|,
define|#
directive|define
name|VOLUMSW
value|19
literal|"volume number"
block|,
operator|-
literal|6
block|,
define|#
directive|define
name|ISSUESW
value|20
literal|"issue number"
block|,
operator|-
literal|5
block|,
define|#
directive|define
name|NBODYSW
value|21
literal|"nobody"
block|,
operator|-
literal|6
block|,
name|NULL
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*
comment|*/
end_comment

begin_struct
struct|struct
name|mcomp
block|{
name|char
modifier|*
name|c_name
decl_stmt|;
comment|/* component name			*/
name|char
modifier|*
name|c_text
decl_stmt|;
comment|/* component text			*/
name|char
modifier|*
name|c_ovtxt
decl_stmt|;
comment|/* text overflow indicator		*/
name|char
modifier|*
name|c_nfs
decl_stmt|;
comment|/* iff FORMAT				*/
name|struct
name|format
modifier|*
name|c_fmt
decl_stmt|;
comment|/*   ..					*/
name|char
modifier|*
name|c_face
decl_stmt|;
comment|/* face designator			*/
name|int
name|c_offset
decl_stmt|;
comment|/* left margin indentation		*/
name|int
name|c_ovoff
decl_stmt|;
comment|/* overflow indentation			*/
name|int
name|c_width
decl_stmt|;
comment|/* width of field			*/
name|int
name|c_cwidth
decl_stmt|;
comment|/* width of component			*/
name|int
name|c_length
decl_stmt|;
comment|/* length in lines			*/
name|long
name|c_flags
decl_stmt|;
define|#
directive|define
name|NOCOMPONENT
value|0x000001
comment|/* don't show component name            */
define|#
directive|define
name|UPPERCASE
value|0x000002
comment|/* display in all upper case            */
define|#
directive|define
name|CENTER
value|0x000004
comment|/* center line				*/
define|#
directive|define
name|CLEARTEXT
value|0x000008
comment|/* cleartext				*/
define|#
directive|define
name|EXTRA
value|0x000010
comment|/* an "extra" component			*/
define|#
directive|define
name|HDROUTPUT
value|0x000020
comment|/* already output			*/
define|#
directive|define
name|CLEARSCR
value|0x000040
comment|/* clear screen				*/
define|#
directive|define
name|LEFTADJUST
value|0x000080
comment|/* left justify multiple lines		*/
define|#
directive|define
name|COMPRESS
value|0x000100
comment|/* compress text			*/
define|#
directive|define
name|ADDRFMT
value|0x000200
comment|/* contains addresses			*/
define|#
directive|define
name|BELL
value|0x000400
comment|/* sound bell at EOP			*/
define|#
directive|define
name|DATEFMT
value|0x000800
comment|/* contains dates			*/
define|#
directive|define
name|FORMAT
value|0x001000
comment|/* parse address/date			*/
define|#
directive|define
name|INIT
value|0x002000
comment|/* initialize component			*/
define|#
directive|define
name|FACEFMT
value|0x004000
comment|/* contains face			*/
define|#
directive|define
name|FACEDFLT
value|0x008000
comment|/* default for face			*/
define|#
directive|define
name|SPLIT
value|0x010000
comment|/* split headers (don't concatenate)	*/
define|#
directive|define
name|NONEWLINE
value|0x020000
comment|/* don't write trailing newline		*/
define|#
directive|define
name|LBITS
value|"\020\01NOCOMPONENT\02UPPERCASE\03CENTER\04CLEARTEXT\05EXTRA\06HDROUTPUT\07CLEARSCR\010LEFTADJUST\011COMPRESS\012ADDRFMT\013BELL\014DATEFMT\015FORMAT\016INIT\017FACEFMT\020FACEDFLT\021SPLIT\022NONEWLINE"
define|#
directive|define
name|GFLAGS
value|(NOCOMPONENT | UPPERCASE | CENTER | LEFTADJUST | COMPRESS \ 			| SPLIT)
name|struct
name|mcomp
modifier|*
name|c_next
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|mcomp
modifier|*
name|msghd
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|mcomp
modifier|*
name|msgtl
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|mcomp
modifier|*
name|fmthd
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|mcomp
modifier|*
name|fmttl
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|mcomp
name|global
init|=
block|{
name|NULL
block|,
name|NULL
block|,
literal|""
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
operator|-
literal|1
block|,
literal|80
block|,
operator|-
literal|1
block|,
literal|40
block|,
name|BELL
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|mcomp
name|holder
init|=
block|{
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|NOCOMPONENT
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_struct
specifier|static
struct|struct
name|pair
block|{
name|char
modifier|*
name|p_name
decl_stmt|;
name|long
name|p_flags
decl_stmt|;
block|}
name|pairs
index|[]
init|=
block|{
literal|"Date"
block|,
name|DATEFMT
block|,
literal|"From"
block|,
name|ADDRFMT
operator||
name|FACEDFLT
block|,
literal|"Sender"
block|,
name|ADDRFMT
block|,
literal|"Reply-To"
block|,
name|ADDRFMT
block|,
literal|"To"
block|,
name|ADDRFMT
block|,
literal|"cc"
block|,
name|ADDRFMT
block|,
literal|"Bcc"
block|,
name|ADDRFMT
block|,
literal|"Resent-Date"
block|,
name|DATEFMT
block|,
literal|"Resent-From"
block|,
name|ADDRFMT
block|,
literal|"Resent-Sender"
block|,
name|ADDRFMT
block|,
literal|"Resent-Reply-To"
block|,
name|ADDRFMT
block|,
literal|"Resent-To"
block|,
name|ADDRFMT
block|,
literal|"Resent-cc"
block|,
name|ADDRFMT
block|,
literal|"Resent-Bcc"
block|,
name|ADDRFMT
block|,
literal|"Face"
block|,
name|FACEFMT
block|,
name|NULL
block|}
struct|;
end_struct

begin_struct
specifier|static
struct|struct
name|triple
block|{
name|char
modifier|*
name|t_name
decl_stmt|;
name|long
name|t_on
decl_stmt|;
name|long
name|t_off
decl_stmt|;
block|}
name|triples
index|[]
init|=
block|{
literal|"nocomponent"
block|,
name|NOCOMPONENT
block|,
literal|0
block|,
literal|"uppercase"
block|,
name|UPPERCASE
block|,
literal|0
block|,
literal|"nouppercase"
block|,
literal|0
block|,
name|UPPERCASE
block|,
literal|"center"
block|,
name|CENTER
block|,
literal|0
block|,
literal|"nocenter"
block|,
literal|0
block|,
name|CENTER
block|,
literal|"clearscreen"
block|,
name|CLEARSCR
block|,
literal|0
block|,
literal|"noclearscreen"
block|,
literal|0
block|,
name|CLEARSCR
block|,
literal|"noclear"
block|,
literal|0
block|,
name|CLEARSCR
block|,
literal|"leftadjust"
block|,
name|LEFTADJUST
block|,
literal|0
block|,
literal|"noleftadjust"
block|,
literal|0
block|,
name|LEFTADJUST
block|,
literal|"compress"
block|,
name|COMPRESS
block|,
literal|0
block|,
literal|"nocompress"
block|,
literal|0
block|,
name|COMPRESS
block|,
literal|"split"
block|,
name|SPLIT
block|,
literal|0
block|,
literal|"nosplit"
block|,
literal|0
block|,
name|SPLIT
block|,
literal|"addrfield"
block|,
name|ADDRFMT
block|,
name|DATEFMT
block|,
literal|"bell"
block|,
name|BELL
block|,
literal|0
block|,
literal|"nobell"
block|,
literal|0
block|,
name|BELL
block|,
literal|"datefield"
block|,
name|DATEFMT
block|,
name|ADDRFMT
block|,
literal|"newline"
block|,
literal|0
block|,
name|NONEWLINE
block|,
literal|"nonewline"
block|,
name|NONEWLINE
block|,
literal|0
block|,
name|NULL
block|}
struct|;
end_struct

begin_comment
comment|/*
comment|*/
end_comment

begin_decl_stmt
specifier|static
name|int
name|bellflg
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|clearflg
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|dashflg
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|dobody
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|forwflg
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|forwall
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|sleepsw
init|=
name|NOTOK
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|digest
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|volume
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|issue
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|exitstat
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|mhldebug
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|PITTY
value|(-1)
end_define

begin_define
define|#
directive|define
name|NOTTY
value|0
end_define

begin_define
define|#
directive|define
name|ISTTY
value|1
end_define

begin_decl_stmt
specifier|static
name|int
name|ontty
init|=
name|NOTTY
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|row
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|column
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|lm
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|llim
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ovoff
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|term
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|wid
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|ovtxt
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|onelp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|parptr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|ignores
index|[
name|MAXARGS
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|jmp_buf
name|env
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|jmp_buf
name|mhlenv
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|delim3
index|[]
init|=
comment|/* from forw.c */
literal|"\n----------------------------------------------------------------------\n\n"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|delim4
index|[]
init|=
literal|"\n------------------------------\n\n"
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|FP
function_decl|(
modifier|*
name|mhl_action
function_decl|)
parameter_list|()
init|=
operator|(
name|FP
argument_list|(
operator|*
argument_list|)
operator|(
operator|)
operator|)
literal|0
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|void
name|mhladios
argument_list|()
decl_stmt|,
name|mhldone
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|TYPESIG
name|intrser
argument_list|()
decl_stmt|,
name|pipeser
argument_list|()
decl_stmt|,
name|quitser
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|mcomp_add
argument_list|()
decl_stmt|,
modifier|*
name|oneline
argument_list|()
decl_stmt|,
modifier|*
name|parse
argument_list|()
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|struct
name|mcomp
modifier|*
name|add_queue
parameter_list|()
function_decl|;
end_function_decl

begin_expr_stmt
specifier|static
name|mhl_format
argument_list|()
operator|,
name|evalvar
argument_list|()
operator|,
name|process
argument_list|()
operator|,
name|mhlfile
argument_list|()
operator|,
name|free_queue
argument_list|()
operator|,
name|putcomp
argument_list|()
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|putstr
argument_list|()
operator|,
name|putch
argument_list|()
operator|,
name|face_format
argument_list|()
operator|,
name|m_popen
argument_list|()
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|ptoi
argument_list|()
decl_stmt|,
name|ptos
argument_list|()
decl_stmt|,
name|doface
argument_list|()
decl_stmt|;
end_decl_stmt

begin_function_decl
name|void
name|clear_screen
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/*
comment|*/
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|int
name|mhl
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
name|argv
index|[]
decl_stmt|;
block|{
name|int
name|length
init|=
literal|0
decl_stmt|,
name|nomore
init|=
literal|0
decl_stmt|,
name|width
init|=
literal|0
decl_stmt|,
name|vecp
init|=
literal|0
decl_stmt|,
name|i
decl_stmt|;
specifier|register
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|folder
init|=
name|NULL
decl_stmt|,
modifier|*
name|form
init|=
name|NULL
decl_stmt|,
modifier|*
modifier|*
name|ap
decl_stmt|,
modifier|*
modifier|*
name|argp
decl_stmt|;
name|char
name|buf
index|[
literal|80
index|]
decl_stmt|,
modifier|*
name|arguments
index|[
name|MAXARGS
index|]
decl_stmt|,
modifier|*
name|files
index|[
name|MAXARGS
index|]
decl_stmt|;
name|invo_name
operator|=
name|r1bindex
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cp
operator|=
name|getenv
argument_list|(
literal|"MHLDEBUG"
argument_list|)
operator|)
operator|&&
operator|*
name|cp
condition|)
name|mhldebug
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|cp
operator|=
name|m_find
argument_list|(
name|invo_name
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|ap
operator|=
name|brkstring
argument_list|(
name|getcpy
argument_list|(
name|cp
argument_list|)
argument_list|,
literal|" "
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|ap
operator|=
name|copyip
argument_list|(
name|ap
argument_list|,
name|arguments
argument_list|)
expr_stmt|;
block|}
else|else
name|ap
operator|=
name|arguments
expr_stmt|;
operator|(
name|void
operator|)
name|copyip
argument_list|(
name|argv
operator|+
literal|1
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|argp
operator|=
name|arguments
expr_stmt|;
comment|/*
comment|*/
if|if
condition|(
name|cp
operator|=
name|getenv
argument_list|(
literal|"FACEPROC"
argument_list|)
condition|)
name|faceproc
operator|=
name|cp
expr_stmt|;
name|vecp
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|cp
operator|=
operator|*
name|argp
operator|++
condition|)
block|{
if|if
condition|(
operator|*
name|cp
operator|==
literal|'-'
condition|)
switch|switch
condition|(
name|smatch
argument_list|(
operator|++
name|cp
argument_list|,
name|mhlswitches
argument_list|)
condition|)
block|{
case|case
name|AMBIGSW
case|:
name|ambigsw
argument_list|(
name|cp
argument_list|,
name|mhlswitches
argument_list|)
expr_stmt|;
name|done
argument_list|(
literal|1
argument_list|)
expr_stmt|;
case|case
name|UNKWNSW
case|:
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"-%s unknown\n"
argument_list|,
name|cp
argument_list|)
expr_stmt|;
case|case
name|HELPSW
case|:
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%s [switches] [files ...]"
argument_list|,
name|invo_name
argument_list|)
expr_stmt|;
name|help
argument_list|(
name|buf
argument_list|,
name|mhlswitches
argument_list|)
expr_stmt|;
name|done
argument_list|(
literal|1
argument_list|)
expr_stmt|;
case|case
name|BELLSW
case|:
name|bellflg
operator|=
literal|1
expr_stmt|;
continue|continue;
case|case
name|NBELLSW
case|:
name|bellflg
operator|=
operator|-
literal|1
expr_stmt|;
continue|continue;
case|case
name|CLRSW
case|:
name|clearflg
operator|=
literal|1
expr_stmt|;
continue|continue;
case|case
name|NCLRSW
case|:
name|clearflg
operator|=
operator|-
literal|1
expr_stmt|;
continue|continue;
case|case
name|FOLDSW
case|:
if|if
condition|(
operator|!
operator|(
name|folder
operator|=
operator|*
name|argp
operator|++
operator|)
operator|||
operator|*
name|folder
operator|==
literal|'-'
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"missing argument to %s"
argument_list|,
name|argp
index|[
operator|-
literal|2
index|]
argument_list|)
expr_stmt|;
continue|continue;
case|case
name|FORMSW
case|:
if|if
condition|(
operator|!
operator|(
name|form
operator|=
operator|*
name|argp
operator|++
operator|)
operator|||
operator|*
name|form
operator|==
literal|'-'
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"missing argument to %s"
argument_list|,
name|argp
index|[
operator|-
literal|2
index|]
argument_list|)
expr_stmt|;
continue|continue;
case|case
name|FACESW
case|:
if|if
condition|(
operator|!
operator|(
name|faceproc
operator|=
operator|*
name|argp
operator|++
operator|)
operator|||
operator|*
name|faceproc
operator|==
literal|'-'
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"missing argument to %s"
argument_list|,
name|argp
index|[
operator|-
literal|2
index|]
argument_list|)
expr_stmt|;
continue|continue;
case|case
name|NFACESW
case|:
name|faceproc
operator|=
name|NULL
expr_stmt|;
continue|continue;
case|case
name|SLEEPSW
case|:
if|if
condition|(
operator|!
operator|(
name|cp
operator|=
operator|*
name|argp
operator|++
operator|)
operator|||
operator|*
name|cp
operator|==
literal|'-'
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"missing argument to %s"
argument_list|,
name|argp
index|[
operator|-
literal|2
index|]
argument_list|)
expr_stmt|;
name|sleepsw
operator|=
name|atoi
argument_list|(
name|cp
argument_list|)
expr_stmt|;
comment|/* ZERO ok! */
continue|continue;
case|case
name|PROGSW
case|:
if|if
condition|(
operator|!
operator|(
name|moreproc
operator|=
operator|*
name|argp
operator|++
operator|)
operator|||
operator|*
name|moreproc
operator|==
literal|'-'
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"missing argument to %s"
argument_list|,
name|argp
index|[
operator|-
literal|2
index|]
argument_list|)
expr_stmt|;
continue|continue;
case|case
name|NPROGSW
case|:
name|nomore
operator|++
expr_stmt|;
continue|continue;
case|case
name|LENSW
case|:
if|if
condition|(
operator|!
operator|(
name|cp
operator|=
operator|*
name|argp
operator|++
operator|)
operator|||
operator|*
name|cp
operator|==
literal|'-'
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"missing argument to %s"
argument_list|,
name|argp
index|[
operator|-
literal|2
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|length
operator|=
name|atoi
argument_list|(
name|cp
argument_list|)
operator|)
operator|<
literal|1
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"bad argument %s %s"
argument_list|,
name|argp
index|[
operator|-
literal|2
index|]
argument_list|,
name|cp
argument_list|)
expr_stmt|;
continue|continue;
case|case
name|WIDSW
case|:
if|if
condition|(
operator|!
operator|(
name|cp
operator|=
operator|*
name|argp
operator|++
operator|)
operator|||
operator|*
name|cp
operator|==
literal|'-'
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"missing argument to %s"
argument_list|,
name|argp
index|[
operator|-
literal|2
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|width
operator|=
name|atoi
argument_list|(
name|cp
argument_list|)
operator|)
operator|<
literal|1
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"bad argument %s %s"
argument_list|,
name|argp
index|[
operator|-
literal|2
index|]
argument_list|,
name|cp
argument_list|)
expr_stmt|;
continue|continue;
case|case
name|DGSTSW
case|:
if|if
condition|(
operator|!
operator|(
name|digest
operator|=
operator|*
name|argp
operator|++
operator|)
operator|||
operator|*
name|digest
operator|==
literal|'-'
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"missing argument to %s"
argument_list|,
name|argp
index|[
operator|-
literal|2
index|]
argument_list|)
expr_stmt|;
continue|continue;
case|case
name|ISSUESW
case|:
if|if
condition|(
operator|!
operator|(
name|cp
operator|=
operator|*
name|argp
operator|++
operator|)
operator|||
operator|*
name|cp
operator|==
literal|'-'
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"missing argument to %s"
argument_list|,
name|argp
index|[
operator|-
literal|2
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|issue
operator|=
name|atoi
argument_list|(
name|cp
argument_list|)
operator|)
operator|<
literal|1
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"bad argument %s %s"
argument_list|,
name|argp
index|[
operator|-
literal|2
index|]
argument_list|,
name|cp
argument_list|)
expr_stmt|;
continue|continue;
case|case
name|VOLUMSW
case|:
if|if
condition|(
operator|!
operator|(
name|cp
operator|=
operator|*
name|argp
operator|++
operator|)
operator|||
operator|*
name|cp
operator|==
literal|'-'
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"missing argument to %s"
argument_list|,
name|argp
index|[
operator|-
literal|2
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|volume
operator|=
name|atoi
argument_list|(
name|cp
argument_list|)
operator|)
operator|<
literal|1
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"bad argument %s %s"
argument_list|,
name|argp
index|[
operator|-
literal|2
index|]
argument_list|,
name|cp
argument_list|)
expr_stmt|;
continue|continue;
case|case
name|FORW2SW
case|:
name|forwall
operator|++
expr_stmt|;
comment|/* fall */
case|case
name|FORW1SW
case|:
name|forwflg
operator|++
expr_stmt|;
name|clearflg
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* XXX */
continue|continue;
case|case
name|DASHSW
case|:
name|dashflg
operator|++
expr_stmt|;
continue|continue;
case|case
name|NDASHSW
case|:
name|dashflg
operator|=
literal|0
expr_stmt|;
continue|continue;
case|case
name|NBODYSW
case|:
name|dobody
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
name|files
index|[
name|vecp
operator|++
index|]
operator|=
name|cp
expr_stmt|;
block|}
comment|/*
comment|*/
if|if
condition|(
operator|!
name|folder
condition|)
name|folder
operator|=
name|getenv
argument_list|(
literal|"mhfolder"
argument_list|)
expr_stmt|;
if|if
condition|(
name|isatty
argument_list|(
name|fileno
argument_list|(
name|stdout
argument_list|)
argument_list|)
condition|)
if|if
condition|(
operator|!
name|nomore
operator|&&
operator|!
name|sc_hardcopy
argument_list|()
operator|&&
name|moreproc
operator|&&
operator|*
name|moreproc
condition|)
block|{
if|if
condition|(
name|mhl_action
condition|)
block|{
name|setsig
argument_list|(
name|SIGINT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
name|setsig
argument_list|(
name|SIGQUIT
argument_list|,
name|quitser
argument_list|)
expr_stmt|;
block|}
name|m_popen
argument_list|(
name|moreproc
argument_list|)
expr_stmt|;
name|ontty
operator|=
name|PITTY
expr_stmt|;
block|}
else|else
block|{
name|setsig
argument_list|(
name|SIGINT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
name|setsig
argument_list|(
name|SIGQUIT
argument_list|,
name|quitser
argument_list|)
expr_stmt|;
name|ontty
operator|=
name|ISTTY
expr_stmt|;
block|}
else|else
name|ontty
operator|=
name|NOTTY
expr_stmt|;
name|mhl_format
argument_list|(
name|form
condition|?
name|form
else|:
name|mhlformat
argument_list|,
name|length
argument_list|,
name|width
argument_list|)
expr_stmt|;
if|if
condition|(
name|vecp
operator|==
literal|0
condition|)
name|process
argument_list|(
name|folder
argument_list|,
name|NULLCP
argument_list|,
literal|1
argument_list|,
name|vecp
operator|=
literal|1
argument_list|)
expr_stmt|;
else|else
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|vecp
condition|;
name|i
operator|++
control|)
name|process
argument_list|(
name|folder
argument_list|,
name|files
index|[
name|i
index|]
argument_list|,
name|i
operator|+
literal|1
argument_list|,
name|vecp
argument_list|)
expr_stmt|;
if|if
condition|(
name|forwall
condition|)
block|{
if|if
condition|(
name|digest
condition|)
block|{
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|delim4
argument_list|)
expr_stmt|;
if|if
condition|(
name|volume
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"End of %s Digest\n"
argument_list|,
name|digest
argument_list|)
expr_stmt|;
block|}
else|else
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"End of %s Digest [Volume %d Issue %d]\n"
argument_list|,
name|digest
argument_list|,
name|volume
argument_list|,
name|issue
argument_list|)
expr_stmt|;
name|i
operator|=
name|strlen
argument_list|(
name|buf
argument_list|)
expr_stmt|;
for|for
control|(
name|cp
operator|=
name|buf
operator|+
name|i
init|;
name|i
operator|>
literal|1
condition|;
name|i
operator|--
control|)
operator|*
name|cp
operator|++
operator|=
literal|'*'
expr_stmt|;
operator|*
name|cp
operator|++
operator|=
literal|'\n'
expr_stmt|;
operator|*
name|cp
operator|=
literal|0
expr_stmt|;
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
else|else
name|printf
argument_list|(
literal|"\n------- End of Forwarded Message%s\n\n"
argument_list|,
name|vecp
operator|>
literal|1
condition|?
literal|"s"
else|:
literal|""
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|clearflg
operator|>
literal|0
operator|&&
name|ontty
operator|==
name|NOTTY
condition|)
name|clear_screen
argument_list|()
expr_stmt|;
if|if
condition|(
name|ontty
operator|==
name|PITTY
condition|)
name|m_pclose
argument_list|()
expr_stmt|;
return|return
name|exitstat
return|;
block|}
end_function

begin_comment
comment|/*
comment|*/
end_comment

begin_expr_stmt
specifier|static
name|mhl_format
argument_list|(
name|file
argument_list|,
name|length
argument_list|,
name|width
argument_list|)
specifier|register
name|char
operator|*
name|file
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|length
decl_stmt|,
name|width
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|i
decl_stmt|;
specifier|register
name|char
modifier|*
name|bp
decl_stmt|,
modifier|*
name|cp
decl_stmt|,
modifier|*
modifier|*
name|ip
decl_stmt|;
name|char
modifier|*
name|ap
decl_stmt|,
name|buffer
index|[
name|BUFSIZ
index|]
decl_stmt|,
name|name
index|[
name|NAMESZ
index|]
decl_stmt|;
specifier|register
name|struct
name|mcomp
modifier|*
name|c1
decl_stmt|;
name|struct
name|stat
name|st
decl_stmt|;
specifier|register
name|FILE
modifier|*
name|fp
decl_stmt|;
specifier|static
name|dev_t
name|dev
init|=
literal|0
decl_stmt|;
specifier|static
name|ino_t
name|ino
init|=
literal|0
decl_stmt|;
specifier|static
name|time_t
name|mtime
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|fmthd
operator|!=
name|NULL
condition|)
if|if
condition|(
name|stat
argument_list|(
name|libpath
argument_list|(
name|file
argument_list|)
argument_list|,
operator|&
name|st
argument_list|)
operator|!=
name|NOTOK
operator|&&
name|mtime
operator|==
name|st
operator|.
name|st_mtime
operator|&&
name|dev
operator|==
name|st
operator|.
name|st_dev
operator|&&
name|ino
operator|==
name|st
operator|.
name|st_ino
condition|)
goto|goto
name|out
goto|;
else|else
name|free_queue
argument_list|(
operator|&
name|fmthd
argument_list|,
operator|&
name|fmttl
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fp
operator|=
name|fopen
argument_list|(
name|libpath
argument_list|(
name|file
argument_list|)
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|adios
argument_list|(
name|file
argument_list|,
literal|"unable to open format file"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fstat
argument_list|(
name|fileno
argument_list|(
name|fp
argument_list|)
argument_list|,
operator|&
name|st
argument_list|)
operator|!=
name|NOTOK
condition|)
name|mtime
operator|=
name|st
operator|.
name|st_mtime
operator|,
name|dev
operator|=
name|st
operator|.
name|st_dev
operator|,
name|ino
operator|=
name|st
operator|.
name|st_ino
expr_stmt|;
name|global
operator|.
name|c_ovtxt
operator|=
name|global
operator|.
name|c_nfs
operator|=
name|NULL
expr_stmt|;
name|global
operator|.
name|c_fmt
operator|=
name|NULL
expr_stmt|;
name|global
operator|.
name|c_offset
operator|=
literal|0
expr_stmt|;
name|global
operator|.
name|c_ovoff
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|=
name|sc_width
argument_list|()
operator|)
operator|>
literal|5
condition|)
name|global
operator|.
name|c_width
operator|=
name|i
expr_stmt|;
name|global
operator|.
name|c_cwidth
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|=
name|sc_length
argument_list|()
operator|)
operator|>
literal|5
condition|)
name|global
operator|.
name|c_length
operator|=
name|i
operator|-
literal|1
expr_stmt|;
name|global
operator|.
name|c_flags
operator|=
name|BELL
expr_stmt|;
comment|/* BELL is default */
operator|*
operator|(
name|ip
operator|=
name|ignores
operator|)
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
name|vfgets
argument_list|(
name|fp
argument_list|,
operator|&
name|ap
argument_list|)
operator|==
name|OK
condition|)
block|{
name|bp
operator|=
name|ap
expr_stmt|;
if|if
condition|(
operator|*
name|bp
operator|==
literal|';'
condition|)
continue|continue;
if|if
condition|(
name|cp
operator|=
name|index
argument_list|(
name|bp
argument_list|,
literal|'\n'
argument_list|)
condition|)
operator|*
name|cp
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|*
name|bp
operator|==
literal|':'
condition|)
block|{
name|c1
operator|=
name|add_queue
argument_list|(
operator|&
name|fmthd
argument_list|,
operator|&
name|fmttl
argument_list|,
name|NULLCP
argument_list|,
name|bp
operator|+
literal|1
argument_list|,
name|CLEARTEXT
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|parptr
operator|=
name|bp
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|name
argument_list|,
name|parse
argument_list|()
argument_list|)
expr_stmt|;
switch|switch
condition|(
operator|*
name|parptr
condition|)
block|{
case|case
literal|'\0'
case|:
case|case
literal|','
case|:
case|case
literal|'='
case|:
if|if
condition|(
name|uleq
argument_list|(
name|name
argument_list|,
literal|"ignores"
argument_list|)
condition|)
block|{
name|ip
operator|=
name|copyip
argument_list|(
name|brkstring
argument_list|(
name|getcpy
argument_list|(
operator|++
name|parptr
argument_list|)
argument_list|,
literal|","
argument_list|,
name|NULLCP
argument_list|)
argument_list|,
name|ip
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|parptr
operator|=
name|bp
expr_stmt|;
while|while
condition|(
operator|*
name|parptr
condition|)
block|{
if|if
condition|(
name|evalvar
argument_list|(
operator|&
name|global
argument_list|)
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"format file syntax error: %s"
argument_list|,
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|parptr
condition|)
name|parptr
operator|++
expr_stmt|;
block|}
continue|continue;
case|case
literal|':'
case|:
name|c1
operator|=
name|add_queue
argument_list|(
operator|&
name|fmthd
argument_list|,
operator|&
name|fmttl
argument_list|,
name|name
argument_list|,
name|NULLCP
argument_list|,
name|INIT
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|parptr
operator|==
literal|':'
operator|||
operator|*
name|parptr
operator|==
literal|','
condition|)
block|{
name|parptr
operator|++
expr_stmt|;
if|if
condition|(
name|evalvar
argument_list|(
name|c1
argument_list|)
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"format file syntax error: %s"
argument_list|,
name|bp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|c1
operator|->
name|c_nfs
operator|&&
name|global
operator|.
name|c_nfs
condition|)
if|if
condition|(
name|c1
operator|->
name|c_flags
operator|&
name|DATEFMT
condition|)
block|{
if|if
condition|(
name|global
operator|.
name|c_flags
operator|&
name|DATEFMT
condition|)
name|c1
operator|->
name|c_nfs
operator|=
name|getcpy
argument_list|(
name|global
operator|.
name|c_nfs
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c1
operator|->
name|c_flags
operator|&
name|ADDRFMT
condition|)
block|{
if|if
condition|(
name|global
operator|.
name|c_flags
operator|&
name|ADDRFMT
condition|)
name|c1
operator|->
name|c_nfs
operator|=
name|getcpy
argument_list|(
name|global
operator|.
name|c_nfs
argument_list|)
expr_stmt|;
block|}
continue|continue;
default|default:
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"format file syntax error: %s"
argument_list|,
name|bp
argument_list|)
expr_stmt|;
block|}
block|}
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|mhldebug
condition|)
for|for
control|(
name|c1
operator|=
name|fmthd
init|;
name|c1
condition|;
name|c1
operator|=
name|c1
operator|->
name|c_next
control|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"c1: name=\"%s\" text=\"%s\" ovtxt=\"%s\"\n"
argument_list|,
name|c1
operator|->
name|c_name
argument_list|,
name|c1
operator|->
name|c_text
argument_list|,
name|c1
operator|->
name|c_ovtxt
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\tnfs=0x%x fmt=0x%x\n"
argument_list|,
name|c1
operator|->
name|c_nfs
argument_list|,
name|c1
operator|->
name|c_fmt
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\toffset=%d ovoff=%d width=%d cwidth=%d length=%d\n"
argument_list|,
name|c1
operator|->
name|c_offset
argument_list|,
name|c1
operator|->
name|c_ovoff
argument_list|,
name|c1
operator|->
name|c_width
argument_list|,
name|c1
operator|->
name|c_cwidth
argument_list|,
name|c1
operator|->
name|c_length
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\tflags=%s\n"
argument_list|,
name|sprintb
argument_list|(
name|buffer
argument_list|,
operator|(
name|unsigned
operator|)
name|c1
operator|->
name|c_flags
argument_list|,
name|LBITS
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|out
label|:
empty_stmt|;
if|if
condition|(
name|clearflg
operator|==
literal|1
condition|)
name|global
operator|.
name|c_flags
operator||=
name|CLEARSCR
expr_stmt|;
elseif|else
if|if
condition|(
name|clearflg
operator|==
operator|-
literal|1
condition|)
name|global
operator|.
name|c_flags
operator|&=
operator|~
name|CLEARSCR
expr_stmt|;
switch|switch
condition|(
name|bellflg
condition|)
block|{
comment|/* command line may override format file */
case|case
literal|1
case|:
name|global
operator|.
name|c_flags
operator||=
name|BELL
expr_stmt|;
break|break;
case|case
operator|-
literal|1
case|:
name|global
operator|.
name|c_flags
operator|&=
operator|~
name|BELL
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|length
condition|)
name|global
operator|.
name|c_length
operator|=
name|length
expr_stmt|;
if|if
condition|(
name|width
condition|)
name|global
operator|.
name|c_width
operator|=
name|width
expr_stmt|;
if|if
condition|(
name|global
operator|.
name|c_length
operator|<
literal|5
condition|)
name|global
operator|.
name|c_length
operator|=
literal|10000
expr_stmt|;
if|if
condition|(
name|global
operator|.
name|c_width
operator|<
literal|5
condition|)
name|global
operator|.
name|c_width
operator|=
literal|10000
expr_stmt|;
block|}
end_block

begin_comment
comment|/*
comment|*/
end_comment

begin_expr_stmt
specifier|static
name|evalvar
argument_list|(
name|c1
argument_list|)
specifier|register
expr|struct
name|mcomp
operator|*
name|c1
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|char
modifier|*
name|cp
decl_stmt|,
name|name
index|[
name|NAMESZ
index|]
decl_stmt|;
specifier|register
name|struct
name|triple
modifier|*
name|ap
decl_stmt|;
if|if
condition|(
operator|!
operator|*
name|parptr
condition|)
return|return
literal|0
return|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|name
argument_list|,
name|parse
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|uleq
argument_list|(
name|name
argument_list|,
literal|"component"
argument_list|)
condition|)
block|{
if|if
condition|(
name|ptos
argument_list|(
name|name
argument_list|,
operator|&
name|c1
operator|->
name|c_text
argument_list|)
condition|)
return|return
literal|1
return|;
name|c1
operator|->
name|c_flags
operator|&=
operator|~
name|NOCOMPONENT
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|uleq
argument_list|(
name|name
argument_list|,
literal|"overflowtext"
argument_list|)
condition|)
return|return
name|ptos
argument_list|(
name|name
argument_list|,
operator|&
name|c1
operator|->
name|c_ovtxt
argument_list|)
return|;
if|if
condition|(
name|uleq
argument_list|(
name|name
argument_list|,
literal|"formatfield"
argument_list|)
condition|)
block|{
if|if
condition|(
name|ptos
argument_list|(
name|name
argument_list|,
operator|&
name|cp
argument_list|)
condition|)
return|return
literal|1
return|;
name|c1
operator|->
name|c_nfs
operator|=
name|getcpy
argument_list|(
name|new_fs
argument_list|(
name|NULLCP
argument_list|,
name|NULLCP
argument_list|,
name|cp
argument_list|)
argument_list|)
expr_stmt|;
name|c1
operator|->
name|c_flags
operator||=
name|FORMAT
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|uleq
argument_list|(
name|name
argument_list|,
literal|"offset"
argument_list|)
condition|)
return|return
name|ptoi
argument_list|(
name|name
argument_list|,
operator|&
name|c1
operator|->
name|c_offset
argument_list|)
return|;
if|if
condition|(
name|uleq
argument_list|(
name|name
argument_list|,
literal|"overflowoffset"
argument_list|)
condition|)
return|return
name|ptoi
argument_list|(
name|name
argument_list|,
operator|&
name|c1
operator|->
name|c_ovoff
argument_list|)
return|;
if|if
condition|(
name|uleq
argument_list|(
name|name
argument_list|,
literal|"width"
argument_list|)
condition|)
return|return
name|ptoi
argument_list|(
name|name
argument_list|,
operator|&
name|c1
operator|->
name|c_width
argument_list|)
return|;
if|if
condition|(
name|uleq
argument_list|(
name|name
argument_list|,
literal|"compwidth"
argument_list|)
condition|)
return|return
name|ptoi
argument_list|(
name|name
argument_list|,
operator|&
name|c1
operator|->
name|c_cwidth
argument_list|)
return|;
if|if
condition|(
name|uleq
argument_list|(
name|name
argument_list|,
literal|"length"
argument_list|)
condition|)
return|return
name|ptoi
argument_list|(
name|name
argument_list|,
operator|&
name|c1
operator|->
name|c_length
argument_list|)
return|;
if|if
condition|(
name|uleq
argument_list|(
name|name
argument_list|,
literal|"nodashmunging"
argument_list|)
condition|)
return|return
operator|(
name|dashflg
operator|=
literal|0
operator|)
return|;
for|for
control|(
name|ap
operator|=
name|triples
init|;
name|ap
operator|->
name|t_name
condition|;
name|ap
operator|++
control|)
if|if
condition|(
name|uleq
argument_list|(
name|ap
operator|->
name|t_name
argument_list|,
name|name
argument_list|)
condition|)
block|{
name|c1
operator|->
name|c_flags
operator||=
name|ap
operator|->
name|t_on
expr_stmt|;
name|c1
operator|->
name|c_flags
operator|&=
operator|~
name|ap
operator|->
name|t_off
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_block

begin_comment
comment|/*
comment|*/
end_comment

begin_function
specifier|static
name|int
name|ptoi
parameter_list|(
name|name
parameter_list|,
name|i
parameter_list|)
specifier|register
name|char
modifier|*
name|name
decl_stmt|;
specifier|register
name|int
modifier|*
name|i
decl_stmt|;
block|{
name|char
modifier|*
name|cp
decl_stmt|;
if|if
condition|(
operator|*
name|parptr
operator|++
operator|!=
literal|'='
operator|||
operator|!
operator|*
operator|(
name|cp
operator|=
name|parse
argument_list|()
operator|)
condition|)
block|{
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"missing argument to variable %s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
operator|*
name|i
operator|=
name|atoi
argument_list|(
name|cp
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ptos
parameter_list|(
name|name
parameter_list|,
name|s
parameter_list|)
specifier|register
name|char
modifier|*
name|name
decl_stmt|,
decl|*
modifier|*
name|s
decl_stmt|;
end_function

begin_block
block|{
name|char
name|c
decl_stmt|,
modifier|*
name|cp
decl_stmt|;
if|if
condition|(
operator|*
name|parptr
operator|++
operator|!=
literal|'='
condition|)
block|{
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"missing argument to variable %s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
operator|*
name|parptr
operator|!=
literal|'"'
condition|)
for|for
control|(
name|cp
operator|=
name|parptr
init|;
operator|*
name|parptr
operator|&&
operator|*
name|parptr
operator|!=
literal|':'
operator|&&
operator|*
name|parptr
operator|!=
literal|','
condition|;
name|parptr
operator|++
control|)
continue|continue;
else|else
for|for
control|(
name|cp
operator|=
operator|++
name|parptr
init|;
operator|*
name|parptr
operator|&&
operator|*
name|parptr
operator|!=
literal|'"'
condition|;
name|parptr
operator|++
control|)
if|if
condition|(
operator|*
name|parptr
operator|==
name|QUOTE
condition|)
if|if
condition|(
operator|!
operator|*
operator|++
name|parptr
condition|)
name|parptr
operator|--
expr_stmt|;
name|c
operator|=
operator|*
name|parptr
expr_stmt|;
operator|*
name|parptr
operator|=
literal|0
expr_stmt|;
operator|*
name|s
operator|=
name|getcpy
argument_list|(
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|parptr
operator|=
name|c
operator|)
operator|==
literal|'"'
condition|)
name|parptr
operator|++
expr_stmt|;
return|return
literal|0
return|;
block|}
end_block

begin_comment
comment|/*
comment|*/
end_comment

begin_function
specifier|static
name|char
modifier|*
name|parse
parameter_list|()
block|{
name|int
name|c
decl_stmt|;
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
specifier|static
name|char
name|result
index|[
name|NAMESZ
index|]
decl_stmt|;
for|for
control|(
name|cp
operator|=
name|result
init|;
name|c
operator|=
operator|*
name|parptr
condition|;
name|parptr
operator|++
control|)
if|if
condition|(
name|isalnum
argument_list|(
name|c
argument_list|)
operator|||
name|c
operator|==
literal|'.'
operator|||
name|c
operator|==
literal|'-'
operator|||
name|c
operator|==
literal|'_'
operator|||
name|c
operator|==
literal|'['
operator|||
name|c
operator|==
literal|']'
condition|)
operator|*
name|cp
operator|++
operator|=
name|c
expr_stmt|;
else|else
break|break;
operator|*
name|cp
operator|=
literal|0
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/*
comment|*/
end_comment

begin_expr_stmt
specifier|static
name|process
argument_list|(
argument|folder
argument_list|,
argument|fname
argument_list|,
argument|ofilen
argument_list|,
argument|ofilec
argument_list|)
name|char
operator|*
name|folder
operator|,
operator|*
name|fname
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|ofilen
decl_stmt|,
name|ofilec
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
modifier|*
name|cp
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
name|struct
name|mcomp
modifier|*
name|c1
decl_stmt|;
switch|switch
condition|(
name|setjmp
argument_list|(
name|env
argument_list|)
condition|)
block|{
case|case
name|OK
case|:
if|if
condition|(
name|fname
condition|)
block|{
name|fp
operator|=
name|mhl_action
condition|?
call|(
modifier|*
name|mhl_action
call|)
argument_list|(
name|fname
argument_list|)
else|:
name|fopen
argument_list|(
name|fname
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|==
name|NULL
condition|)
block|{
name|advise
argument_list|(
name|fname
argument_list|,
literal|"unable to open"
argument_list|)
expr_stmt|;
name|exitstat
operator|++
expr_stmt|;
return|return;
block|}
block|}
else|else
block|{
name|fname
operator|=
literal|"(stdin)"
expr_stmt|;
name|fp
operator|=
name|stdin
expr_stmt|;
block|}
name|cp
operator|=
name|folder
condition|?
name|concat
argument_list|(
name|folder
argument_list|,
literal|":"
argument_list|,
name|fname
argument_list|,
name|NULLCP
argument_list|)
else|:
name|getcpy
argument_list|(
name|fname
argument_list|)
expr_stmt|;
if|if
condition|(
name|ontty
operator|!=
name|PITTY
condition|)
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|intrser
argument_list|)
expr_stmt|;
name|mhlfile
argument_list|(
name|fp
argument_list|,
name|cp
argument_list|,
name|ofilen
argument_list|,
name|ofilec
argument_list|)
expr_stmt|;
comment|/* fall */
default|default:
if|if
condition|(
name|ontty
operator|!=
name|PITTY
condition|)
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
if|if
condition|(
name|mhl_action
operator|==
name|NULL
operator|&&
name|fp
operator|!=
name|stdin
condition|)
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
name|holder
operator|.
name|c_text
condition|)
block|{
name|free
argument_list|(
name|holder
operator|.
name|c_text
argument_list|)
expr_stmt|;
name|holder
operator|.
name|c_text
operator|=
name|NULL
expr_stmt|;
block|}
name|free_queue
argument_list|(
operator|&
name|msghd
argument_list|,
operator|&
name|msgtl
argument_list|)
expr_stmt|;
for|for
control|(
name|c1
operator|=
name|fmthd
init|;
name|c1
condition|;
name|c1
operator|=
name|c1
operator|->
name|c_next
control|)
name|c1
operator|->
name|c_flags
operator|&=
operator|~
name|HDROUTPUT
expr_stmt|;
break|break;
block|}
block|}
end_block

begin_comment
comment|/*
comment|*/
end_comment

begin_expr_stmt
specifier|static
name|mhlfile
argument_list|(
name|fp
argument_list|,
name|mname
argument_list|,
name|ofilen
argument_list|,
name|ofilec
argument_list|)
specifier|register
name|FILE
operator|*
name|fp
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|char
modifier|*
name|mname
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|ofilen
decl_stmt|,
name|ofilec
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|state
decl_stmt|;
specifier|register
name|struct
name|mcomp
modifier|*
name|c1
decl_stmt|,
modifier|*
name|c2
decl_stmt|,
modifier|*
name|c3
decl_stmt|;
specifier|register
name|char
modifier|*
modifier|*
name|ip
decl_stmt|;
name|char
name|name
index|[
name|NAMESZ
index|]
decl_stmt|,
name|buf
index|[
name|BUFSIZ
index|]
decl_stmt|;
if|if
condition|(
name|forwall
condition|)
block|{
if|if
condition|(
name|digest
condition|)
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|ofilen
operator|==
literal|1
condition|?
name|delim3
else|:
name|delim4
argument_list|)
expr_stmt|;
else|else
block|{
name|printf
argument_list|(
literal|"\n-------"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ofilen
operator|==
literal|1
condition|)
name|printf
argument_list|(
literal|" Forwarded Message%s"
argument_list|,
name|ofilec
operator|>
literal|1
condition|?
literal|"s"
else|:
literal|""
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|" Message %d"
argument_list|,
name|ofilen
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n\n"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
switch|switch
condition|(
name|ontty
condition|)
block|{
case|case
name|PITTY
case|:
if|if
condition|(
name|ofilec
operator|>
literal|1
condition|)
block|{
if|if
condition|(
name|ofilen
operator|>
literal|1
condition|)
block|{
if|if
condition|(
operator|(
name|global
operator|.
name|c_flags
operator|&
name|CLEARSCR
operator|)
condition|)
name|clear_screen
argument_list|()
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"\n\n\n"
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|">>> %s\n\n"
argument_list|,
name|mname
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|ISTTY
case|:
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|buf
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ofilec
operator|>
literal|1
condition|)
block|{
if|if
condition|(
name|SOprintf
argument_list|(
literal|"Press<return> to list \"%s\"..."
argument_list|,
name|mname
argument_list|)
condition|)
block|{
if|if
condition|(
name|ofilen
operator|>
literal|1
condition|)
name|printf
argument_list|(
literal|"\n\n\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Press<return> to list \"%s\"..."
argument_list|,
name|mname
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|buf
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
operator|(
name|void
operator|)
name|read
argument_list|(
name|fileno
argument_list|(
name|stdout
argument_list|)
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|index
argument_list|(
name|buf
argument_list|,
literal|'\n'
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|global
operator|.
name|c_flags
operator|&
name|CLEARSCR
operator|)
condition|)
name|clear_screen
argument_list|()
expr_stmt|;
block|}
else|else
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|ofilec
operator|>
literal|1
condition|)
block|{
if|if
condition|(
name|ofilen
operator|>
literal|1
condition|)
block|{
name|printf
argument_list|(
literal|"\n\n\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|clearflg
operator|>
literal|0
condition|)
name|clear_screen
argument_list|()
expr_stmt|;
block|}
name|printf
argument_list|(
literal|">>> %s\n\n"
argument_list|,
name|mname
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
comment|/*
comment|*/
for|for
control|(
name|state
operator|=
name|FLD
init|;
condition|;
control|)
switch|switch
condition|(
name|state
operator|=
name|m_getfld
argument_list|(
name|state
argument_list|,
name|name
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
name|fp
argument_list|)
condition|)
block|{
case|case
name|FLD
case|:
case|case
name|FLDPLUS
case|:
for|for
control|(
name|ip
operator|=
name|ignores
init|;
operator|*
name|ip
condition|;
name|ip
operator|++
control|)
if|if
condition|(
name|uleq
argument_list|(
name|name
argument_list|,
operator|*
name|ip
argument_list|)
condition|)
block|{
while|while
condition|(
name|state
operator|==
name|FLDPLUS
condition|)
name|state
operator|=
name|m_getfld
argument_list|(
name|state
argument_list|,
name|name
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
name|fp
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|*
name|ip
condition|)
continue|continue;
for|for
control|(
name|c2
operator|=
name|fmthd
init|;
name|c2
condition|;
name|c2
operator|=
name|c2
operator|->
name|c_next
control|)
if|if
condition|(
name|uleq
argument_list|(
name|c2
operator|->
name|c_name
argument_list|,
name|name
argument_list|)
condition|)
break|break;
name|c1
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|(
name|c3
operator|=
name|c2
condition|?
name|c2
else|:
operator|&
name|global
operator|)
operator|->
name|c_flags
operator|&
name|SPLIT
operator|)
condition|)
for|for
control|(
name|c1
operator|=
name|msghd
init|;
name|c1
condition|;
name|c1
operator|=
name|c1
operator|->
name|c_next
control|)
if|if
condition|(
name|uleq
argument_list|(
name|c1
operator|->
name|c_name
argument_list|,
name|c3
operator|->
name|c_name
argument_list|)
condition|)
block|{
name|c1
operator|->
name|c_text
operator|=
name|mcomp_add
argument_list|(
name|c1
operator|->
name|c_flags
argument_list|,
name|buf
argument_list|,
name|c1
operator|->
name|c_text
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|c1
operator|==
name|NULL
condition|)
name|c1
operator|=
name|add_queue
argument_list|(
operator|&
name|msghd
argument_list|,
operator|&
name|msgtl
argument_list|,
name|name
argument_list|,
name|buf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
while|while
condition|(
name|state
operator|==
name|FLDPLUS
condition|)
block|{
name|state
operator|=
name|m_getfld
argument_list|(
name|state
argument_list|,
name|name
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|c1
operator|->
name|c_text
operator|=
name|add
argument_list|(
name|buf
argument_list|,
name|c1
operator|->
name|c_text
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|c2
operator|==
name|NULL
condition|)
name|c1
operator|->
name|c_flags
operator||=
name|EXTRA
expr_stmt|;
continue|continue;
case|case
name|BODY
case|:
case|case
name|FILEEOF
case|:
name|row
operator|=
name|column
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|c1
operator|=
name|fmthd
init|;
name|c1
condition|;
name|c1
operator|=
name|c1
operator|->
name|c_next
control|)
block|{
if|if
condition|(
name|c1
operator|->
name|c_flags
operator|&
name|CLEARTEXT
condition|)
block|{
name|putcomp
argument_list|(
name|c1
argument_list|,
name|c1
argument_list|,
name|ONECOMP
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|uleq
argument_list|(
name|c1
operator|->
name|c_name
argument_list|,
literal|"messagename"
argument_list|)
condition|)
block|{
name|holder
operator|.
name|c_text
operator|=
name|concat
argument_list|(
literal|"(Message "
argument_list|,
name|mname
argument_list|,
literal|")\n"
argument_list|,
name|NULLCP
argument_list|)
expr_stmt|;
name|putcomp
argument_list|(
name|c1
argument_list|,
operator|&
name|holder
argument_list|,
name|ONECOMP
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|holder
operator|.
name|c_text
argument_list|)
expr_stmt|;
name|holder
operator|.
name|c_text
operator|=
name|NULL
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|uleq
argument_list|(
name|c1
operator|->
name|c_name
argument_list|,
literal|"extras"
argument_list|)
condition|)
block|{
for|for
control|(
name|c2
operator|=
name|msghd
init|;
name|c2
condition|;
name|c2
operator|=
name|c2
operator|->
name|c_next
control|)
if|if
condition|(
name|c2
operator|->
name|c_flags
operator|&
name|EXTRA
condition|)
name|putcomp
argument_list|(
name|c1
argument_list|,
name|c2
argument_list|,
name|TWOCOMP
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|dobody
operator|&&
name|uleq
argument_list|(
name|c1
operator|->
name|c_name
argument_list|,
literal|"body"
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|holder
operator|.
name|c_text
operator|=
name|malloc
argument_list|(
sizeof|sizeof
name|buf
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"unable to allocate buffer memory"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|holder
operator|.
name|c_text
argument_list|,
name|buf
argument_list|)
expr_stmt|;
while|while
condition|(
name|state
operator|==
name|BODY
condition|)
block|{
name|putcomp
argument_list|(
name|c1
argument_list|,
operator|&
name|holder
argument_list|,
name|BODYCOMP
argument_list|)
expr_stmt|;
name|state
operator|=
name|m_getfld
argument_list|(
name|state
argument_list|,
name|name
argument_list|,
name|holder
operator|.
name|c_text
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
name|fp
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|holder
operator|.
name|c_text
argument_list|)
expr_stmt|;
name|holder
operator|.
name|c_text
operator|=
name|NULL
expr_stmt|;
continue|continue;
block|}
for|for
control|(
name|c2
operator|=
name|msghd
init|;
name|c2
condition|;
name|c2
operator|=
name|c2
operator|->
name|c_next
control|)
if|if
condition|(
name|uleq
argument_list|(
name|c2
operator|->
name|c_name
argument_list|,
name|c1
operator|->
name|c_name
argument_list|)
condition|)
block|{
name|putcomp
argument_list|(
name|c1
argument_list|,
name|c2
argument_list|,
name|ONECOMP
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|c1
operator|->
name|c_flags
operator|&
name|SPLIT
operator|)
condition|)
break|break;
block|}
if|if
condition|(
name|faceproc
operator|&&
name|c2
operator|==
name|NULL
operator|&&
operator|(
name|c1
operator|->
name|c_flags
operator|&
name|FACEFMT
operator|)
condition|)
for|for
control|(
name|c2
operator|=
name|msghd
init|;
name|c2
condition|;
name|c2
operator|=
name|c2
operator|->
name|c_next
control|)
if|if
condition|(
name|c2
operator|->
name|c_flags
operator|&
name|FACEDFLT
condition|)
block|{
if|if
condition|(
name|c2
operator|->
name|c_face
operator|==
name|NULL
condition|)
name|face_format
argument_list|(
name|c2
argument_list|)
expr_stmt|;
if|if
condition|(
name|holder
operator|.
name|c_text
operator|=
name|c2
operator|->
name|c_face
condition|)
block|{
name|putcomp
argument_list|(
name|c1
argument_list|,
operator|&
name|holder
argument_list|,
name|ONECOMP
argument_list|)
expr_stmt|;
name|holder
operator|.
name|c_text
operator|=
name|NULL
expr_stmt|;
block|}
break|break;
block|}
block|}
return|return;
case|case
name|LENERR
case|:
case|case
name|FMTERR
case|:
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"format error in message %s"
argument_list|,
name|mname
argument_list|)
expr_stmt|;
name|exitstat
operator|++
expr_stmt|;
return|return;
default|default:
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"getfld() returned %d"
argument_list|,
name|state
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*
comment|*/
end_comment

begin_function
specifier|static
name|int
name|mcomp_flags
parameter_list|(
name|name
parameter_list|)
specifier|register
name|char
modifier|*
name|name
decl_stmt|;
block|{
specifier|register
name|struct
name|pair
modifier|*
name|ap
decl_stmt|;
for|for
control|(
name|ap
operator|=
name|pairs
init|;
name|ap
operator|->
name|p_name
condition|;
name|ap
operator|++
control|)
if|if
condition|(
name|uleq
argument_list|(
name|ap
operator|->
name|p_name
argument_list|,
name|name
argument_list|)
condition|)
return|return
operator|(
name|ap
operator|->
name|p_flags
operator|)
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|mcomp_add
parameter_list|(
name|flags
parameter_list|,
name|s1
parameter_list|,
name|s2
parameter_list|)
name|long
name|flags
decl_stmt|;
specifier|register
name|char
modifier|*
name|s1
decl_stmt|,
decl|*
name|s2
decl_stmt|;
end_function

begin_block
block|{
specifier|register
name|char
modifier|*
name|dp
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|ADDRFMT
operator|)
condition|)
return|return
name|add
argument_list|(
name|s1
argument_list|,
name|s2
argument_list|)
return|;
if|if
condition|(
name|s2
operator|&&
operator|*
operator|(
name|dp
operator|=
name|s2
operator|+
name|strlen
argument_list|(
name|s2
argument_list|)
operator|-
literal|1
operator|)
operator|==
literal|'\n'
condition|)
operator|*
name|dp
operator|=
literal|0
expr_stmt|;
return|return
name|add
argument_list|(
name|s1
argument_list|,
name|add
argument_list|(
literal|",\n"
argument_list|,
name|s2
argument_list|)
argument_list|)
return|;
block|}
end_block

begin_comment
comment|/*
comment|*/
end_comment

begin_struct
struct|struct
name|pqpair
block|{
name|char
modifier|*
name|pq_text
decl_stmt|;
name|char
modifier|*
name|pq_error
decl_stmt|;
name|struct
name|pqpair
modifier|*
name|pq_next
decl_stmt|;
block|}
struct|;
end_struct

begin_expr_stmt
specifier|static
name|mcomp_format
argument_list|(
name|c1
argument_list|,
name|c2
argument_list|)
specifier|register
expr|struct
name|mcomp
operator|*
name|c1
operator|,
operator|*
name|c2
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|int
name|dat
index|[
literal|5
index|]
decl_stmt|;
specifier|register
name|char
modifier|*
name|ap
decl_stmt|,
modifier|*
name|cp
decl_stmt|;
name|char
name|buffer
index|[
name|BUFSIZ
index|]
decl_stmt|,
name|error
index|[
name|BUFSIZ
index|]
decl_stmt|;
specifier|register
name|struct
name|comp
modifier|*
name|cptr
decl_stmt|;
specifier|register
name|struct
name|pqpair
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
name|struct
name|pqpair
name|pq
decl_stmt|;
specifier|register
name|struct
name|mailname
modifier|*
name|mp
decl_stmt|;
name|ap
operator|=
name|c2
operator|->
name|c_text
expr_stmt|;
name|c2
operator|->
name|c_text
operator|=
name|NULL
expr_stmt|;
name|dat
index|[
literal|0
index|]
operator|=
name|dat
index|[
literal|1
index|]
operator|=
name|dat
index|[
literal|2
index|]
operator|=
name|dat
index|[
literal|4
index|]
operator|=
literal|0
expr_stmt|;
name|dat
index|[
literal|3
index|]
operator|=
sizeof|sizeof
name|buffer
operator|-
literal|1
expr_stmt|;
operator|(
name|void
operator|)
name|fmt_compile
argument_list|(
name|c1
operator|->
name|c_nfs
argument_list|,
operator|&
name|c1
operator|->
name|c_fmt
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|c1
operator|->
name|c_flags
operator|&
name|ADDRFMT
operator|)
condition|)
block|{
name|FINDCOMP
argument_list|(
name|cptr
argument_list|,
literal|"text"
argument_list|)
expr_stmt|;
if|if
condition|(
name|cptr
condition|)
name|cptr
operator|->
name|c_text
operator|=
name|ap
expr_stmt|;
if|if
condition|(
name|cp
operator|=
name|rindex
argument_list|(
name|ap
argument_list|,
literal|'\n'
argument_list|)
condition|)
comment|/* drop ending newline */
if|if
condition|(
operator|!
name|cp
index|[
literal|1
index|]
condition|)
operator|*
name|cp
operator|=
literal|0
expr_stmt|;
operator|(
name|void
operator|)
name|fmtscan
argument_list|(
name|c1
operator|->
name|c_fmt
argument_list|,
name|buffer
argument_list|,
sizeof|sizeof
name|buffer
operator|-
literal|1
argument_list|,
name|dat
argument_list|)
expr_stmt|;
comment|/* Don't need to append a newline, dctime() already did */
name|c2
operator|->
name|c_text
operator|=
name|getcpy
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ap
argument_list|)
expr_stmt|;
return|return;
block|}
operator|(
name|q
operator|=
operator|&
name|pq
operator|)
operator|->
name|pq_next
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
name|cp
operator|=
name|getname
argument_list|(
name|ap
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|p
operator|=
operator|(
expr|struct
name|pqpair
operator|*
operator|)
name|calloc
argument_list|(
operator|(
name|unsigned
operator|)
literal|1
argument_list|,
sizeof|sizeof
expr|*
name|p
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"unable to allocate pqpair memory"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|mp
operator|=
name|getm
argument_list|(
name|cp
argument_list|,
name|NULLCP
argument_list|,
literal|0
argument_list|,
name|AD_NAME
argument_list|,
name|error
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|p
operator|->
name|pq_text
operator|=
name|getcpy
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|p
operator|->
name|pq_error
operator|=
name|getcpy
argument_list|(
name|error
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|c1
operator|->
name|c_flags
operator|&
name|FACEDFLT
operator|)
operator|&&
name|c2
operator|->
name|c_face
operator|==
name|NULL
condition|)
block|{
name|char
modifier|*
name|h
decl_stmt|,
modifier|*
name|o
decl_stmt|;
if|if
condition|(
operator|(
name|h
operator|=
name|mp
operator|->
name|m_host
operator|)
operator|==
name|NULL
condition|)
name|h
operator|=
name|LocalName
argument_list|()
expr_stmt|;
if|if
condition|(
name|o
operator|=
name|OfficialName
argument_list|(
name|h
argument_list|)
condition|)
name|h
operator|=
name|o
expr_stmt|;
name|c2
operator|->
name|c_face
operator|=
name|concat
argument_list|(
literal|"address "
argument_list|,
name|h
argument_list|,
literal|" "
argument_list|,
name|mp
operator|->
name|m_mbox
argument_list|,
name|NULLCP
argument_list|)
expr_stmt|;
block|}
name|p
operator|->
name|pq_text
operator|=
name|getcpy
argument_list|(
name|mp
operator|->
name|m_text
argument_list|)
expr_stmt|;
name|mnfree
argument_list|(
name|mp
argument_list|)
expr_stmt|;
block|}
name|q
operator|=
operator|(
name|q
operator|->
name|pq_next
operator|=
name|p
operator|)
expr_stmt|;
block|}
for|for
control|(
name|p
operator|=
name|pq
operator|.
name|pq_next
init|;
name|p
condition|;
name|p
operator|=
name|q
control|)
block|{
name|FINDCOMP
argument_list|(
name|cptr
argument_list|,
literal|"text"
argument_list|)
expr_stmt|;
if|if
condition|(
name|cptr
condition|)
name|cptr
operator|->
name|c_text
operator|=
name|p
operator|->
name|pq_text
expr_stmt|;
name|FINDCOMP
argument_list|(
name|cptr
argument_list|,
literal|"error"
argument_list|)
expr_stmt|;
if|if
condition|(
name|cptr
condition|)
name|cptr
operator|->
name|c_text
operator|=
name|p
operator|->
name|pq_error
expr_stmt|;
operator|(
name|void
operator|)
name|fmtscan
argument_list|(
name|c1
operator|->
name|c_fmt
argument_list|,
name|buffer
argument_list|,
sizeof|sizeof
name|buffer
operator|-
literal|1
argument_list|,
name|dat
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|buffer
condition|)
block|{
if|if
condition|(
name|c2
operator|->
name|c_text
condition|)
name|c2
operator|->
name|c_text
operator|=
name|add
argument_list|(
literal|",\n"
argument_list|,
name|c2
operator|->
name|c_text
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
operator|(
name|cp
operator|=
name|buffer
operator|+
name|strlen
argument_list|(
name|buffer
argument_list|)
operator|-
literal|1
operator|)
operator|==
literal|'\n'
condition|)
operator|*
name|cp
operator|=
literal|0
expr_stmt|;
name|c2
operator|->
name|c_text
operator|=
name|add
argument_list|(
name|buffer
argument_list|,
name|c2
operator|->
name|c_text
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|p
operator|->
name|pq_text
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|pq_error
condition|)
name|free
argument_list|(
name|p
operator|->
name|pq_error
argument_list|)
expr_stmt|;
name|q
operator|=
name|p
operator|->
name|pq_next
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|p
argument_list|)
expr_stmt|;
block|}
name|c2
operator|->
name|c_text
operator|=
name|add
argument_list|(
literal|"\n"
argument_list|,
name|c2
operator|->
name|c_text
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ap
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*
comment|*/
end_comment

begin_function
specifier|static
name|struct
name|mcomp
modifier|*
name|add_queue
parameter_list|(
name|head
parameter_list|,
name|tail
parameter_list|,
name|name
parameter_list|,
name|text
parameter_list|,
name|flags
parameter_list|)
specifier|register
name|struct
name|mcomp
modifier|*
modifier|*
name|head
decl_stmt|,
decl|*
modifier|*
name|tail
decl_stmt|;
end_function

begin_decl_stmt
specifier|register
name|char
modifier|*
name|name
decl_stmt|,
modifier|*
name|text
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|flags
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|mcomp
modifier|*
name|c1
decl_stmt|;
if|if
condition|(
operator|(
name|c1
operator|=
operator|(
expr|struct
name|mcomp
operator|*
operator|)
name|calloc
argument_list|(
operator|(
name|unsigned
operator|)
literal|1
argument_list|,
sizeof|sizeof
expr|*
name|c1
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"unable to allocate comp memory"
argument_list|)
expr_stmt|;
name|c1
operator|->
name|c_flags
operator|=
name|flags
operator|&
operator|~
name|INIT
expr_stmt|;
if|if
condition|(
name|c1
operator|->
name|c_name
operator|=
name|name
condition|?
name|getcpy
argument_list|(
name|name
argument_list|)
else|:
name|NULL
condition|)
name|c1
operator|->
name|c_flags
operator||=
name|mcomp_flags
argument_list|(
name|c1
operator|->
name|c_name
argument_list|)
expr_stmt|;
name|c1
operator|->
name|c_text
operator|=
name|text
condition|?
name|getcpy
argument_list|(
name|text
argument_list|)
else|:
name|NULL
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|INIT
condition|)
block|{
if|if
condition|(
name|global
operator|.
name|c_ovtxt
condition|)
name|c1
operator|->
name|c_ovtxt
operator|=
name|getcpy
argument_list|(
name|global
operator|.
name|c_ovtxt
argument_list|)
expr_stmt|;
name|c1
operator|->
name|c_offset
operator|=
name|global
operator|.
name|c_offset
expr_stmt|;
name|c1
operator|->
name|c_ovoff
operator|=
name|global
operator|.
name|c_ovoff
expr_stmt|;
name|c1
operator|->
name|c_width
operator|=
name|c1
operator|->
name|c_length
operator|=
literal|0
expr_stmt|;
name|c1
operator|->
name|c_cwidth
operator|=
name|global
operator|.
name|c_cwidth
expr_stmt|;
name|c1
operator|->
name|c_flags
operator||=
name|global
operator|.
name|c_flags
operator|&
name|GFLAGS
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|head
operator|==
name|NULL
condition|)
operator|*
name|head
operator|=
name|c1
expr_stmt|;
if|if
condition|(
operator|*
name|tail
operator|!=
name|NULL
condition|)
operator|(
operator|*
name|tail
operator|)
operator|->
name|c_next
operator|=
name|c1
expr_stmt|;
operator|*
name|tail
operator|=
name|c1
expr_stmt|;
return|return
name|c1
return|;
block|}
end_block

begin_expr_stmt
specifier|static
name|free_queue
argument_list|(
name|head
argument_list|,
name|tail
argument_list|)
specifier|register
expr|struct
name|mcomp
operator|*
operator|*
name|head
operator|,
operator|*
operator|*
name|tail
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|mcomp
modifier|*
name|c1
decl_stmt|,
modifier|*
name|c2
decl_stmt|;
for|for
control|(
name|c1
operator|=
operator|*
name|head
init|;
name|c1
condition|;
name|c1
operator|=
name|c2
control|)
block|{
name|c2
operator|=
name|c1
operator|->
name|c_next
expr_stmt|;
if|if
condition|(
name|c1
operator|->
name|c_name
condition|)
name|free
argument_list|(
name|c1
operator|->
name|c_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|c1
operator|->
name|c_text
condition|)
name|free
argument_list|(
name|c1
operator|->
name|c_text
argument_list|)
expr_stmt|;
if|if
condition|(
name|c1
operator|->
name|c_ovtxt
condition|)
name|free
argument_list|(
name|c1
operator|->
name|c_ovtxt
argument_list|)
expr_stmt|;
if|if
condition|(
name|c1
operator|->
name|c_nfs
condition|)
name|free
argument_list|(
name|c1
operator|->
name|c_nfs
argument_list|)
expr_stmt|;
if|if
condition|(
name|c1
operator|->
name|c_fmt
condition|)
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|c1
operator|->
name|c_fmt
argument_list|)
expr_stmt|;
if|if
condition|(
name|c1
operator|->
name|c_face
condition|)
name|free
argument_list|(
name|c1
operator|->
name|c_face
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|c1
argument_list|)
expr_stmt|;
block|}
operator|*
name|head
operator|=
operator|*
name|tail
operator|=
name|NULL
expr_stmt|;
block|}
end_block

begin_comment
comment|/*
comment|*/
end_comment

begin_expr_stmt
specifier|static
name|putcomp
argument_list|(
name|c1
argument_list|,
name|c2
argument_list|,
name|flag
argument_list|)
specifier|register
expr|struct
name|mcomp
operator|*
name|c1
operator|,
operator|*
name|c2
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|flag
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|count
decl_stmt|,
name|cchdr
decl_stmt|;
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
name|cchdr
operator|=
literal|0
expr_stmt|;
name|lm
operator|=
literal|0
expr_stmt|;
name|llim
operator|=
name|c1
operator|->
name|c_length
condition|?
name|c1
operator|->
name|c_length
else|:
operator|-
literal|1
expr_stmt|;
name|wid
operator|=
name|c1
operator|->
name|c_width
condition|?
name|c1
operator|->
name|c_width
else|:
name|global
operator|.
name|c_width
expr_stmt|;
name|ovoff
operator|=
operator|(
name|c1
operator|->
name|c_ovoff
operator|>=
literal|0
condition|?
name|c1
operator|->
name|c_ovoff
else|:
name|global
operator|.
name|c_ovoff
operator|)
operator|+
name|c1
operator|->
name|c_offset
expr_stmt|;
if|if
condition|(
operator|(
name|ovtxt
operator|=
name|c1
operator|->
name|c_ovtxt
condition|?
name|c1
operator|->
name|c_ovtxt
else|:
name|global
operator|.
name|c_ovtxt
operator|)
operator|==
name|NULL
condition|)
name|ovtxt
operator|=
literal|""
expr_stmt|;
if|if
condition|(
name|wid
operator|<
name|ovoff
operator|+
name|strlen
argument_list|(
name|ovtxt
argument_list|)
operator|+
literal|5
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"component: %s width(%d) too small for overflow(%d)"
argument_list|,
name|c1
operator|->
name|c_name
argument_list|,
name|wid
argument_list|,
name|ovoff
operator|+
name|strlen
argument_list|(
name|ovtxt
argument_list|)
operator|+
literal|5
argument_list|)
expr_stmt|;
name|onelp
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|c1
operator|->
name|c_flags
operator|&
name|CLEARTEXT
condition|)
block|{
name|putstr
argument_list|(
name|c1
operator|->
name|c_text
argument_list|)
expr_stmt|;
name|putstr
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|c1
operator|->
name|c_flags
operator|&
name|FACEFMT
condition|)
switch|switch
condition|(
name|doface
argument_list|(
name|c2
argument_list|)
condition|)
block|{
case|case
name|NOTOK
case|:
comment|/* error */
case|case
name|OK
case|:
comment|/* async faceproc */
return|return;
default|default:
comment|/* sync faceproc */
break|break;
block|}
if|if
condition|(
name|c1
operator|->
name|c_nfs
operator|&&
operator|(
name|c1
operator|->
name|c_flags
operator|&
operator|(
name|ADDRFMT
operator||
name|DATEFMT
operator||
name|FORMAT
operator|)
operator|)
condition|)
name|mcomp_format
argument_list|(
name|c1
argument_list|,
name|c2
argument_list|)
expr_stmt|;
if|if
condition|(
name|c1
operator|->
name|c_flags
operator|&
name|CENTER
condition|)
block|{
name|count
operator|=
operator|(
name|c1
operator|->
name|c_width
condition|?
name|c1
operator|->
name|c_width
else|:
name|global
operator|.
name|c_width
operator|)
operator|-
name|c1
operator|->
name|c_offset
operator|-
name|strlen
argument_list|(
name|c2
operator|->
name|c_text
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|c1
operator|->
name|c_flags
operator|&
name|HDROUTPUT
operator|)
operator|&&
operator|!
operator|(
name|c1
operator|->
name|c_flags
operator|&
name|NOCOMPONENT
operator|)
condition|)
name|count
operator|-=
name|strlen
argument_list|(
name|c1
operator|->
name|c_text
condition|?
name|c1
operator|->
name|c_text
else|:
name|c1
operator|->
name|c_name
argument_list|)
operator|+
literal|2
expr_stmt|;
name|lm
operator|=
name|c1
operator|->
name|c_offset
operator|+
operator|(
name|count
operator|/
literal|2
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c1
operator|->
name|c_offset
condition|)
name|lm
operator|=
name|c1
operator|->
name|c_offset
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|c1
operator|->
name|c_flags
operator|&
name|HDROUTPUT
operator|)
operator|&&
operator|!
operator|(
name|c1
operator|->
name|c_flags
operator|&
name|NOCOMPONENT
operator|)
condition|)
block|{
if|if
condition|(
name|c1
operator|->
name|c_flags
operator|&
name|UPPERCASE
condition|)
comment|/* uppercase component also */
for|for
control|(
name|cp
operator|=
operator|(
name|c1
operator|->
name|c_text
condition|?
name|c1
operator|->
name|c_text
else|:
name|c1
operator|->
name|c_name
operator|)
init|;
operator|*
name|cp
condition|;
name|cp
operator|++
control|)
if|if
condition|(
name|islower
argument_list|(
operator|*
name|cp
argument_list|)
condition|)
operator|*
name|cp
operator|=
name|toupper
argument_list|(
operator|*
name|cp
argument_list|)
expr_stmt|;
name|putstr
argument_list|(
name|c1
operator|->
name|c_text
condition|?
name|c1
operator|->
name|c_text
else|:
name|c1
operator|->
name|c_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag
operator|!=
name|BODYCOMP
condition|)
block|{
name|putstr
argument_list|(
literal|": "
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|c1
operator|->
name|c_flags
operator|&
name|SPLIT
operator|)
condition|)
name|c1
operator|->
name|c_flags
operator||=
name|HDROUTPUT
expr_stmt|;
name|cchdr
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|count
operator|=
name|c1
operator|->
name|c_cwidth
operator|-
name|strlen
argument_list|(
name|c1
operator|->
name|c_text
condition|?
name|c1
operator|->
name|c_text
else|:
name|c1
operator|->
name|c_name
argument_list|)
operator|-
literal|2
operator|)
operator|>
literal|0
condition|)
while|while
condition|(
name|count
operator|--
condition|)
name|putstr
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
block|}
else|else
name|c1
operator|->
name|c_flags
operator||=
name|HDROUTPUT
expr_stmt|;
comment|/* for BODYCOMP */
block|}
if|if
condition|(
name|flag
operator|==
name|TWOCOMP
operator|&&
operator|!
operator|(
name|c2
operator|->
name|c_flags
operator|&
name|HDROUTPUT
operator|)
operator|&&
operator|!
operator|(
name|c2
operator|->
name|c_flags
operator|&
name|NOCOMPONENT
operator|)
condition|)
block|{
if|if
condition|(
name|c1
operator|->
name|c_flags
operator|&
name|UPPERCASE
condition|)
for|for
control|(
name|cp
operator|=
name|c2
operator|->
name|c_name
init|;
operator|*
name|cp
condition|;
name|cp
operator|++
control|)
if|if
condition|(
name|islower
argument_list|(
operator|*
name|cp
argument_list|)
condition|)
operator|*
name|cp
operator|=
name|toupper
argument_list|(
operator|*
name|cp
argument_list|)
expr_stmt|;
name|putstr
argument_list|(
name|c2
operator|->
name|c_name
argument_list|)
expr_stmt|;
name|putstr
argument_list|(
literal|": "
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|c1
operator|->
name|c_flags
operator|&
name|SPLIT
operator|)
condition|)
name|c2
operator|->
name|c_flags
operator||=
name|HDROUTPUT
expr_stmt|;
name|cchdr
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|count
operator|=
name|c1
operator|->
name|c_cwidth
operator|-
name|strlen
argument_list|(
name|c2
operator|->
name|c_name
argument_list|)
operator|-
literal|2
operator|)
operator|>
literal|0
condition|)
while|while
condition|(
name|count
operator|--
condition|)
name|putstr
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|c1
operator|->
name|c_flags
operator|&
name|UPPERCASE
condition|)
for|for
control|(
name|cp
operator|=
name|c2
operator|->
name|c_text
init|;
operator|*
name|cp
condition|;
name|cp
operator|++
control|)
if|if
condition|(
name|islower
argument_list|(
operator|*
name|cp
argument_list|)
condition|)
operator|*
name|cp
operator|=
name|toupper
argument_list|(
operator|*
name|cp
argument_list|)
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|cchdr
condition|)
if|if
condition|(
name|flag
operator|==
name|TWOCOMP
condition|)
name|count
operator|=
operator|(
name|c1
operator|->
name|c_cwidth
operator|>=
literal|0
operator|)
condition|?
name|c1
operator|->
name|c_cwidth
else|:
name|strlen
argument_list|(
name|c2
operator|->
name|c_name
argument_list|)
operator|+
literal|2
expr_stmt|;
else|else
name|count
operator|=
operator|(
name|c1
operator|->
name|c_cwidth
operator|>=
literal|0
operator|)
condition|?
name|c1
operator|->
name|c_cwidth
else|:
name|strlen
argument_list|(
name|c1
operator|->
name|c_text
condition|?
name|c1
operator|->
name|c_text
else|:
name|c1
operator|->
name|c_name
argument_list|)
operator|+
literal|2
expr_stmt|;
name|count
operator|+=
name|c1
operator|->
name|c_offset
expr_stmt|;
if|if
condition|(
name|cp
operator|=
name|oneline
argument_list|(
name|c2
operator|->
name|c_text
argument_list|,
name|c1
operator|->
name|c_flags
argument_list|)
condition|)
name|putstr
argument_list|(
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
name|term
operator|==
literal|'\n'
condition|)
name|putstr
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
while|while
condition|(
name|cp
operator|=
name|oneline
argument_list|(
name|c2
operator|->
name|c_text
argument_list|,
name|c1
operator|->
name|c_flags
argument_list|)
condition|)
block|{
name|lm
operator|=
name|count
expr_stmt|;
if|if
condition|(
name|flag
operator|==
name|BODYCOMP
operator|&&
operator|!
operator|(
name|c1
operator|->
name|c_flags
operator|&
name|NOCOMPONENT
operator|)
condition|)
name|putstr
argument_list|(
name|c1
operator|->
name|c_text
condition|?
name|c1
operator|->
name|c_text
else|:
name|c1
operator|->
name|c_name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|cp
condition|)
name|putstr
argument_list|(
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
name|term
operator|==
literal|'\n'
condition|)
name|putstr
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*
comment|*/
end_comment

begin_function
specifier|static
name|char
modifier|*
name|oneline
parameter_list|(
name|stuff
parameter_list|,
name|flags
parameter_list|)
specifier|register
name|char
modifier|*
name|stuff
decl_stmt|;
name|long
name|flags
decl_stmt|;
block|{
name|int
name|spc
decl_stmt|;
specifier|register
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|ret
decl_stmt|;
if|if
condition|(
name|onelp
operator|==
name|NULL
condition|)
name|onelp
operator|=
name|stuff
expr_stmt|;
if|if
condition|(
operator|*
name|onelp
operator|==
literal|0
condition|)
return|return
operator|(
name|onelp
operator|=
name|NULL
operator|)
return|;
name|ret
operator|=
name|onelp
expr_stmt|;
name|term
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|COMPRESS
condition|)
block|{
for|for
control|(
name|spc
operator|=
literal|1
operator|,
name|cp
operator|=
name|ret
init|;
operator|*
name|onelp
condition|;
name|onelp
operator|++
control|)
if|if
condition|(
name|isspace
argument_list|(
operator|*
name|onelp
argument_list|)
condition|)
block|{
if|if
condition|(
operator|*
name|onelp
operator|==
literal|'\n'
operator|&&
operator|(
operator|!
name|onelp
index|[
literal|1
index|]
operator|||
operator|(
name|flags
operator|&
name|ADDRFMT
operator|)
operator|)
condition|)
block|{
name|term
operator|=
literal|'\n'
expr_stmt|;
operator|*
name|onelp
operator|++
operator|=
literal|0
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
operator|!
name|spc
condition|)
block|{
operator|*
name|cp
operator|++
operator|=
literal|' '
expr_stmt|;
name|spc
operator|++
expr_stmt|;
block|}
block|}
else|else
block|{
operator|*
name|cp
operator|++
operator|=
operator|*
name|onelp
expr_stmt|;
name|spc
operator|=
literal|0
expr_stmt|;
block|}
operator|*
name|cp
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
while|while
condition|(
operator|*
name|onelp
operator|&&
operator|*
name|onelp
operator|!=
literal|'\n'
condition|)
name|onelp
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|onelp
operator|==
literal|'\n'
condition|)
block|{
name|term
operator|=
literal|'\n'
expr_stmt|;
operator|*
name|onelp
operator|++
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|flags
operator|&
name|LEFTADJUST
condition|)
while|while
condition|(
operator|*
name|ret
operator|==
literal|' '
operator|||
operator|*
name|ret
operator|==
literal|'\t'
condition|)
name|ret
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|onelp
operator|==
literal|0
operator|&&
name|term
operator|==
literal|'\n'
operator|&&
operator|(
name|flags
operator|&
name|NONEWLINE
operator|)
condition|)
name|term
operator|=
literal|0
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/*
comment|*/
end_comment

begin_expr_stmt
specifier|static
name|putstr
argument_list|(
name|string
argument_list|)
specifier|register
name|char
operator|*
name|string
expr_stmt|;
end_expr_stmt

begin_block
block|{
if|if
condition|(
operator|!
name|column
operator|&&
name|lm
operator|>
literal|0
condition|)
while|while
condition|(
name|lm
operator|>
literal|0
condition|)
if|if
condition|(
name|lm
operator|>=
literal|8
condition|)
block|{
name|putch
argument_list|(
literal|'\t'
argument_list|)
expr_stmt|;
name|lm
operator|-=
literal|8
expr_stmt|;
block|}
else|else
block|{
name|putch
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|lm
operator|--
expr_stmt|;
block|}
name|lm
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|*
name|string
condition|)
name|putch
argument_list|(
operator|*
name|string
operator|++
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*
comment|*/
end_comment

begin_expr_stmt
specifier|static
name|putch
argument_list|(
name|ch
argument_list|)
specifier|register
name|char
name|ch
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|char
name|buf
index|[
name|BUFSIZ
index|]
decl_stmt|;
if|if
condition|(
name|llim
operator|==
literal|0
condition|)
return|return;
switch|switch
condition|(
name|ch
condition|)
block|{
case|case
literal|'\n'
case|:
if|if
condition|(
name|llim
operator|>
literal|0
condition|)
name|llim
operator|--
expr_stmt|;
name|column
operator|=
literal|0
expr_stmt|;
name|row
operator|++
expr_stmt|;
if|if
condition|(
name|ontty
operator|!=
name|ISTTY
operator|||
name|row
operator|!=
name|global
operator|.
name|c_length
condition|)
break|break;
if|if
condition|(
name|global
operator|.
name|c_flags
operator|&
name|BELL
condition|)
operator|(
name|void
operator|)
name|putchar
argument_list|(
literal|'\007'
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|buf
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
operator|(
name|void
operator|)
name|read
argument_list|(
name|fileno
argument_list|(
name|stdout
argument_list|)
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|index
argument_list|(
name|buf
argument_list|,
literal|'\n'
argument_list|)
condition|)
block|{
if|if
condition|(
name|global
operator|.
name|c_flags
operator|&
name|CLEARSCR
condition|)
name|clear_screen
argument_list|()
expr_stmt|;
name|row
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|row
operator|=
name|global
operator|.
name|c_length
operator|/
literal|3
expr_stmt|;
block|}
return|return;
case|case
literal|'\t'
case|:
name|column
operator||=
literal|07
expr_stmt|;
name|column
operator|++
expr_stmt|;
break|break;
case|case
literal|'\b'
case|:
name|column
operator|--
expr_stmt|;
break|break;
case|case
literal|'\r'
case|:
name|column
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|column
operator|==
literal|0
operator|&&
name|forwflg
operator|&&
name|dashflg
operator|&&
name|ch
operator|==
literal|'-'
condition|)
operator|(
name|void
operator|)
name|putchar
argument_list|(
literal|'-'
argument_list|)
operator|,
name|putchar
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
if|if
condition|(
name|ch
operator|>=
literal|' '
condition|)
name|column
operator|++
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|column
operator|>=
name|wid
condition|)
block|{
name|putch
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
if|if
condition|(
name|ovoff
operator|>
literal|0
condition|)
name|lm
operator|=
name|ovoff
expr_stmt|;
name|putstr
argument_list|(
name|ovtxt
condition|?
name|ovtxt
else|:
literal|""
argument_list|)
expr_stmt|;
name|putch
argument_list|(
name|ch
argument_list|)
expr_stmt|;
return|return;
block|}
operator|(
name|void
operator|)
name|putchar
argument_list|(
name|ch
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*
comment|*/
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|TYPESIG
name|intrser
parameter_list|(
name|i
parameter_list|)
name|int
name|i
decl_stmt|;
block|{
ifndef|#
directive|ifndef
name|BSD42
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|intrser
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* BSD42 */
name|discard
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|longjmp
argument_list|(
name|env
argument_list|,
name|DONE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|TYPESIG
name|pipeser
parameter_list|(
name|i
parameter_list|)
name|int
name|i
decl_stmt|;
block|{
ifndef|#
directive|ifndef
name|BSD42
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGPIPE
argument_list|,
name|pipeser
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* BSD42 */
name|done
argument_list|(
name|NOTOK
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|TYPESIG
name|quitser
parameter_list|(
name|i
parameter_list|)
name|int
name|i
decl_stmt|;
block|{
ifndef|#
directive|ifndef
name|BSD42
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|quitser
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* BSD42 */
operator|(
name|void
operator|)
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|done
argument_list|(
name|NOTOK
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*
comment|*/
end_comment

begin_expr_stmt
specifier|static
name|face_format
argument_list|(
name|c1
argument_list|)
specifier|register
expr|struct
name|mcomp
operator|*
name|c1
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
specifier|register
name|struct
name|mailname
modifier|*
name|mp
decl_stmt|;
if|if
condition|(
operator|(
name|cp
operator|=
name|c1
operator|->
name|c_text
operator|)
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
name|cp
operator|=
name|getname
argument_list|(
name|cp
argument_list|)
condition|)
block|{
if|if
condition|(
name|mp
operator|=
name|getm
argument_list|(
name|cp
argument_list|,
name|NULLCP
argument_list|,
literal|0
argument_list|,
name|AD_NAME
argument_list|,
name|NULLCP
argument_list|)
condition|)
block|{
name|char
modifier|*
name|h
decl_stmt|,
modifier|*
name|o
decl_stmt|;
if|if
condition|(
operator|(
name|h
operator|=
name|mp
operator|->
name|m_host
operator|)
operator|==
name|NULL
condition|)
name|h
operator|=
name|LocalName
argument_list|()
expr_stmt|;
if|if
condition|(
name|o
operator|=
name|OfficialName
argument_list|(
name|h
argument_list|)
condition|)
name|h
operator|=
name|o
expr_stmt|;
name|c1
operator|->
name|c_face
operator|=
name|concat
argument_list|(
literal|"address "
argument_list|,
name|h
argument_list|,
literal|" "
argument_list|,
name|mp
operator|->
name|m_mbox
argument_list|,
name|NULLCP
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|cp
operator|=
name|getname
argument_list|(
name|cp
argument_list|)
condition|)
continue|continue;
block|}
block|}
end_block

begin_comment
comment|/*
comment|*/
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|BSD42
argument_list|)
operator|||
name|defined
argument_list|(
name|SOCKETS
argument_list|)
end_if

begin_comment
comment|/* faceproc is two elements defining the image agent's location: 	Internet host 	UDP port  */
end_comment

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netdb.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|hpux
end_ifndef

begin_include
include|#
directive|include
file|<arpa/inet.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|int
name|doface
parameter_list|(
name|c1
parameter_list|)
specifier|register
name|struct
name|mcomp
modifier|*
name|c1
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|result
decl_stmt|,
name|sd
decl_stmt|;
name|struct
name|sockaddr_in
name|in_socket
decl_stmt|;
specifier|register
name|struct
name|sockaddr_in
modifier|*
name|isock
init|=
operator|&
name|in_socket
decl_stmt|;
specifier|static
name|int
name|inited
init|=
name|OK
decl_stmt|;
specifier|static
name|int
name|addrlen
decl_stmt|;
specifier|static
name|struct
name|in_addr
name|addr
decl_stmt|;
specifier|static
name|u_short
name|portno
decl_stmt|;
if|if
condition|(
name|inited
operator|==
name|OK
condition|)
block|{
name|u_long
name|iaddr
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
name|char
modifier|*
modifier|*
name|ap
init|=
name|brkstring
argument_list|(
name|cp
operator|=
name|getcpy
argument_list|(
name|faceproc
argument_list|)
argument_list|,
literal|" "
argument_list|,
literal|"\n"
argument_list|)
decl_stmt|;
name|struct
name|hostent
modifier|*
name|hp
decl_stmt|;
if|if
condition|(
name|ap
index|[
literal|0
index|]
operator|==
name|NULL
operator|||
name|ap
index|[
literal|1
index|]
operator|==
name|NULL
condition|)
block|{
name|bad_faceproc
label|:
empty_stmt|;
name|free
argument_list|(
name|cp
argument_list|)
expr_stmt|;
return|return
operator|(
name|inited
operator|=
name|NOTOK
operator|)
return|;
block|}
if|if
condition|(
name|hp
operator|=
name|gethostbyname
argument_list|(
name|ap
index|[
literal|0
index|]
argument_list|)
condition|)
name|bcopy
argument_list|(
name|hp
operator|->
name|h_addr
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|addr
argument_list|,
name|addrlen
operator|=
name|hp
operator|->
name|h_length
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|iaddr
operator|=
name|inet_addr
argument_list|(
name|ap
index|[
literal|0
index|]
argument_list|)
condition|)
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|iaddr
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|addr
argument_list|,
name|addrlen
operator|=
sizeof|sizeof
name|iaddr
argument_list|)
expr_stmt|;
else|else
goto|goto
name|bad_faceproc
goto|;
name|portno
operator|=
name|htons
argument_list|(
operator|(
name|u_short
operator|)
name|atoi
argument_list|(
name|ap
index|[
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|inited
operator|=
name|DONE
expr_stmt|;
block|}
if|if
condition|(
name|inited
operator|==
name|NOTOK
condition|)
return|return
name|NOTOK
return|;
name|isock
operator|->
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|isock
operator|->
name|sin_port
operator|=
name|portno
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|addr
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|isock
operator|->
name|sin_addr
argument_list|,
name|addrlen
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sd
operator|=
name|socket
argument_list|(
name|AF_INET
argument_list|,
name|SOCK_DGRAM
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
name|NOTOK
condition|)
return|return
name|NOTOK
return|;
name|result
operator|=
name|sendto
argument_list|(
name|sd
argument_list|,
name|c1
operator|->
name|c_text
argument_list|,
name|strlen
argument_list|(
name|c1
operator|->
name|c_text
argument_list|)
argument_list|,
literal|0
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
name|isock
argument_list|,
sizeof|sizeof
expr|*
name|isock
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|sd
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|!=
name|NOTOK
condition|?
name|OK
else|:
name|NOTOK
operator|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* not BSD42 and not SOCKETS */
end_comment

begin_function
specifier|static
name|int
name|doface
parameter_list|(
name|c1
parameter_list|)
specifier|register
name|struct
name|mcomp
modifier|*
name|c1
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|len
decl_stmt|,
name|vecp
decl_stmt|;
name|int
name|child_id
decl_stmt|,
name|result
decl_stmt|,
name|pdi
index|[
literal|2
index|]
decl_stmt|,
name|pdo
index|[
literal|2
index|]
decl_stmt|;
specifier|register
name|char
modifier|*
name|bp
decl_stmt|,
modifier|*
name|cp
decl_stmt|;
name|char
name|buffer
index|[
name|BUFSIZ
index|]
decl_stmt|,
modifier|*
name|vec
index|[
literal|10
index|]
decl_stmt|;
if|if
condition|(
name|pipe
argument_list|(
name|pdi
argument_list|)
operator|==
name|NOTOK
condition|)
return|return
name|NOTOK
return|;
if|if
condition|(
name|pipe
argument_list|(
name|pdo
argument_list|)
operator|==
name|NOTOK
condition|)
block|{
operator|(
name|void
operator|)
name|close
argument_list|(
name|pdi
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|pdi
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|child_id
operator|=
name|vfork
argument_list|()
operator|)
operator|==
name|NOTOK
operator|&&
name|i
operator|<
literal|5
condition|;
name|i
operator|++
control|)
name|sleep
argument_list|(
literal|5
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|child_id
condition|)
block|{
case|case
name|NOTOK
case|:
return|return
name|NOTOK
return|;
case|case
name|OK
case|:
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
if|if
condition|(
name|pdi
index|[
literal|0
index|]
operator|!=
name|fileno
argument_list|(
name|stdin
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|dup2
argument_list|(
name|pdi
index|[
literal|0
index|]
argument_list|,
name|fileno
argument_list|(
name|stdin
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|pdi
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|close
argument_list|(
name|pdi
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|pdo
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|pdo
index|[
literal|1
index|]
operator|!=
name|fileno
argument_list|(
name|stdout
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|dup2
argument_list|(
name|pdo
index|[
literal|1
index|]
argument_list|,
name|fileno
argument_list|(
name|stdout
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|pdo
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
name|vecp
operator|=
literal|0
expr_stmt|;
name|vec
index|[
name|vecp
operator|++
index|]
operator|=
name|r1bindex
argument_list|(
name|faceproc
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
name|vec
index|[
name|vecp
operator|++
index|]
operator|=
literal|"-e"
expr_stmt|;
if|if
condition|(
name|sleepsw
operator|!=
name|NOTOK
condition|)
block|{
name|vec
index|[
name|vecp
operator|++
index|]
operator|=
literal|"-s"
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|"%d"
argument_list|,
name|sleepsw
argument_list|)
expr_stmt|;
name|vec
index|[
name|vecp
operator|++
index|]
operator|=
name|buffer
expr_stmt|;
block|}
name|vec
index|[
name|vecp
index|]
operator|=
name|NULL
expr_stmt|;
name|execvp
argument_list|(
name|faceproc
argument_list|,
name|vec
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"unable to exec "
argument_list|)
expr_stmt|;
name|perror
argument_list|(
name|faceproc
argument_list|)
expr_stmt|;
name|_exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
default|default:
operator|(
name|void
operator|)
name|close
argument_list|(
name|pdi
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|i
operator|=
name|strlen
argument_list|(
name|c1
operator|->
name|c_text
argument_list|)
expr_stmt|;
if|if
condition|(
name|write
argument_list|(
name|pdi
index|[
literal|1
index|]
argument_list|,
name|c1
operator|->
name|c_text
argument_list|,
name|i
argument_list|)
operator|!=
name|i
condition|)
name|adios
argument_list|(
literal|"pipe"
argument_list|,
literal|"error writing to"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|c1
operator|->
name|c_text
argument_list|)
operator|,
name|c1
operator|->
name|c_text
operator|=
name|NULL
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|pdi
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|pdo
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|cp
operator|=
name|NULL
operator|,
name|len
operator|=
literal|0
expr_stmt|;
name|result
operator|=
name|DONE
expr_stmt|;
while|while
condition|(
operator|(
name|i
operator|=
name|read
argument_list|(
name|pdo
index|[
literal|0
index|]
argument_list|,
name|buffer
argument_list|,
name|strlen
argument_list|(
name|buffer
argument_list|)
argument_list|)
operator|)
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|cp
condition|)
block|{
specifier|register
name|int
name|j
decl_stmt|;
specifier|register
name|char
modifier|*
name|dp
decl_stmt|;
if|if
condition|(
operator|(
name|dp
operator|=
name|realloc
argument_list|(
name|cp
argument_list|,
call|(
name|unsigned
call|)
argument_list|(
name|j
operator|=
name|len
operator|+
name|i
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"unable to allocate face storage"
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|buffer
argument_list|,
name|dp
operator|+
name|len
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|cp
operator|=
name|dp
operator|,
name|len
operator|=
name|j
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|cp
operator|=
name|malloc
argument_list|(
operator|(
name|unsigned
operator|)
name|i
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"unable to allocate face storage"
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|buffer
argument_list|,
name|cp
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|len
operator|=
name|i
expr_stmt|;
block|}
if|if
condition|(
name|result
operator|==
name|DONE
condition|)
for|for
control|(
name|bp
operator|=
name|buffer
operator|+
name|i
operator|-
literal|1
init|;
name|bp
operator|>=
name|buffer
condition|;
name|bp
operator|--
control|)
if|if
condition|(
operator|!
name|isascii
argument_list|(
operator|*
name|bp
argument_list|)
operator|||
name|iscntrl
argument_list|(
operator|*
name|bp
argument_list|)
condition|)
block|{
name|result
operator|=
name|OK
expr_stmt|;
break|break;
block|}
block|}
operator|(
name|void
operator|)
name|close
argument_list|(
name|pdo
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
comment|/* no waiting for child... */
if|if
condition|(
name|result
operator|==
name|OK
condition|)
block|{
comment|/* binary */
if|if
condition|(
name|write
argument_list|(
literal|1
argument_list|,
name|cp
argument_list|,
name|len
argument_list|)
operator|!=
name|len
condition|)
name|adios
argument_list|(
literal|"writing"
argument_list|,
literal|"error"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|cp
argument_list|)
expr_stmt|;
block|}
elseif|else
comment|/* empty */
if|if
condition|(
operator|(
name|c1
operator|->
name|c_text
operator|=
name|cp
operator|)
operator|==
name|NULL
condition|)
name|result
operator|=
name|OK
expr_stmt|;
break|break;
block|}
return|return
name|result
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not BSD42 and not SOCKETS */
end_comment

begin_comment
comment|/*
comment|*/
end_comment

begin_undef
undef|#
directive|undef
name|adios
end_undef

begin_undef
undef|#
directive|undef
name|done
end_undef

begin_decl_stmt
name|int
name|mhlsbr
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|action
argument_list|)
name|int
name|argc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
end_decl_stmt

begin_function_decl
name|FP
function_decl|(
modifier|*
name|action
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_block
block|{
name|TYPESIG
argument_list|(
operator|*
name|istat
argument_list|)
argument_list|()
decl_stmt|,
argument_list|(
operator|*
name|pstat
argument_list|)
argument_list|()
decl_stmt|,
argument_list|(
operator|*
name|qstat
argument_list|)
argument_list|()
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
name|struct
name|mcomp
modifier|*
name|c1
decl_stmt|;
switch|switch
condition|(
name|setjmp
argument_list|(
name|mhlenv
argument_list|)
condition|)
block|{
case|case
name|OK
case|:
name|cp
operator|=
name|invo_name
expr_stmt|;
name|sleepsw
operator|=
literal|0
expr_stmt|;
comment|/* XXX */
name|bellflg
operator|=
name|clearflg
operator|=
name|forwflg
operator|=
name|forwall
operator|=
name|exitstat
operator|=
literal|0
expr_stmt|;
name|digest
operator|=
name|NULL
expr_stmt|;
name|ontty
operator|=
name|NOTTY
expr_stmt|;
name|mhl_action
operator|=
name|action
expr_stmt|;
if|if
condition|(
operator|(
name|istat
operator|=
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_IGN
argument_list|)
operator|)
operator|!=
name|SIG_DFL
condition|)
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|istat
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|qstat
operator|=
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|SIG_IGN
argument_list|)
operator|)
operator|!=
name|SIG_DFL
condition|)
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|qstat
argument_list|)
expr_stmt|;
name|pstat
operator|=
name|signal
argument_list|(
name|SIGPIPE
argument_list|,
name|pipeser
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|mhl
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
expr_stmt|;
comment|/* fall */
default|default:
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|istat
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|qstat
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGPIPE
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
comment|/* XXX */
if|if
condition|(
name|ontty
operator|==
name|PITTY
condition|)
name|m_pclose
argument_list|()
expr_stmt|;
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGPIPE
argument_list|,
name|pstat
argument_list|)
expr_stmt|;
name|invo_name
operator|=
name|cp
expr_stmt|;
if|if
condition|(
name|holder
operator|.
name|c_text
condition|)
block|{
name|free
argument_list|(
name|holder
operator|.
name|c_text
argument_list|)
expr_stmt|;
name|holder
operator|.
name|c_text
operator|=
name|NULL
expr_stmt|;
block|}
name|free_queue
argument_list|(
operator|&
name|msghd
argument_list|,
operator|&
name|msgtl
argument_list|)
expr_stmt|;
for|for
control|(
name|c1
operator|=
name|fmthd
init|;
name|c1
condition|;
name|c1
operator|=
name|c1
operator|->
name|c_next
control|)
name|c1
operator|->
name|c_flags
operator|&=
operator|~
name|HDROUTPUT
expr_stmt|;
return|return
name|exitstat
return|;
block|}
block|}
end_block

begin_comment
comment|/*
comment|*/
end_comment

begin_comment
comment|/* VARARGS2 */
end_comment

begin_function
specifier|static
name|void
name|mhladios
parameter_list|(
name|what
parameter_list|,
name|fmt
parameter_list|,
name|a
parameter_list|,
name|b
parameter_list|,
name|c
parameter_list|,
name|d
parameter_list|,
name|e
parameter_list|,
name|f
parameter_list|)
name|char
modifier|*
name|what
decl_stmt|,
decl|*
name|fmt
decl_stmt|,
modifier|*
name|a
decl_stmt|,
modifier|*
name|b
decl_stmt|,
modifier|*
name|c
decl_stmt|,
modifier|*
name|d
decl_stmt|,
modifier|*
name|e
decl_stmt|,
modifier|*
name|f
decl_stmt|;
end_function

begin_block
block|{
name|advise
argument_list|(
name|what
argument_list|,
name|fmt
argument_list|,
name|a
argument_list|,
name|b
argument_list|,
name|c
argument_list|,
name|d
argument_list|,
name|e
argument_list|,
name|f
argument_list|)
expr_stmt|;
name|mhldone
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

begin_function
specifier|static
name|void
name|mhldone
parameter_list|(
name|status
parameter_list|)
name|int
name|status
decl_stmt|;
block|{
name|exitstat
operator|=
name|status
expr_stmt|;
if|if
condition|(
name|mhl_action
condition|)
name|longjmp
argument_list|(
name|mhlenv
argument_list|,
name|DONE
argument_list|)
expr_stmt|;
else|else
name|done
argument_list|(
name|exitstat
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*
comment|*/
end_comment

begin_decl_stmt
specifier|static
name|int
name|m_pid
init|=
name|NOTOK
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|sd
init|=
name|NOTOK
decl_stmt|;
end_decl_stmt

begin_expr_stmt
specifier|static
name|m_popen
argument_list|(
argument|name
argument_list|)
name|char
operator|*
name|name
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|int
name|pd
index|[
literal|2
index|]
decl_stmt|;
if|if
condition|(
name|mhl_action
operator|&&
operator|(
name|sd
operator|=
name|dup
argument_list|(
name|fileno
argument_list|(
name|stdout
argument_list|)
argument_list|)
operator|)
operator|==
name|NOTOK
condition|)
name|adios
argument_list|(
literal|"standard output"
argument_list|,
literal|"unable to dup()"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pipe
argument_list|(
name|pd
argument_list|)
operator|==
name|NOTOK
condition|)
name|adios
argument_list|(
literal|"pipe"
argument_list|,
literal|"unable to"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|m_pid
operator|=
name|vfork
argument_list|()
condition|)
block|{
case|case
name|NOTOK
case|:
name|adios
argument_list|(
literal|"fork"
argument_list|,
literal|"unable to"
argument_list|)
expr_stmt|;
case|case
name|OK
case|:
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|pd
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|pd
index|[
literal|0
index|]
operator|!=
name|fileno
argument_list|(
name|stdin
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|dup2
argument_list|(
name|pd
index|[
literal|0
index|]
argument_list|,
name|fileno
argument_list|(
name|stdin
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|pd
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
name|execlp
argument_list|(
name|name
argument_list|,
name|r1bindex
argument_list|(
name|name
argument_list|,
literal|'/'
argument_list|)
argument_list|,
name|NULLCP
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"unable to exec "
argument_list|)
expr_stmt|;
name|perror
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|_exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
default|default:
operator|(
name|void
operator|)
name|close
argument_list|(
name|pd
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|pd
index|[
literal|1
index|]
operator|!=
name|fileno
argument_list|(
name|stdout
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|dup2
argument_list|(
name|pd
index|[
literal|1
index|]
argument_list|,
name|fileno
argument_list|(
name|stdout
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|pd
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_block

begin_macro
name|m_pclose
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|m_pid
operator|==
name|NOTOK
condition|)
return|return;
if|if
condition|(
name|sd
operator|!=
name|NOTOK
condition|)
block|{
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
name|dup2
argument_list|(
name|sd
argument_list|,
name|fileno
argument_list|(
name|stdout
argument_list|)
argument_list|)
operator|==
name|NOTOK
condition|)
name|adios
argument_list|(
literal|"standard output"
argument_list|,
literal|"unable to dup2()"
argument_list|)
expr_stmt|;
name|clearerr
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|sd
argument_list|)
expr_stmt|;
name|sd
operator|=
name|NOTOK
expr_stmt|;
block|}
else|else
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|pidwait
argument_list|(
name|m_pid
argument_list|,
name|OK
argument_list|)
expr_stmt|;
name|m_pid
operator|=
name|NOTOK
expr_stmt|;
block|}
end_block

end_unit

