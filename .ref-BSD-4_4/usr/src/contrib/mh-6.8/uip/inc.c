begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* inc.c - incorporate messages from a maildrop into a folder */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|ident
index|[]
init|=
literal|"@(#)$Id: inc.c,v 1.20 1992/12/15 00:20:22 jromine Exp $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* lint */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|MAILGROUP
end_ifdef

begin_comment
comment|/* Revised: Sat Apr 14 17:08:17 PDT 1990 (marvit@hplabs)  *    Added hpux hacks to set and reset gid to be "mail" as needed. The reset  *    is necessary so inc'ed mail is the group of the inc'er, rather than  *    "mail". We setgid to egid only when [un]locking the mail file. This  *    is also a major security precaution which will not be explained here.  *  * Fri Feb  7 16:04:57 PST 1992		John Romine<bug-mh@ics.uci.edu>  *   NB: I'm not 100% sure that this setgid stuff is secure even now.  */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"../h/mh.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|POP
end_ifdef

begin_include
include|#
directive|include
file|"../h/dropsbr.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|KPOP
end_ifdef

begin_include
include|#
directive|include
file|<krb.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HESIOD
end_ifdef

begin_include
include|#
directive|include
file|<hesiod.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"../h/formatsbr.h"
end_include

begin_include
include|#
directive|include
file|"../h/scansbr.h"
end_include

begin_include
include|#
directive|include
file|"../zotnet/tws.h"
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"../zotnet/mts.h"
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|LOCALE
end_ifdef

begin_include
include|#
directive|include
file|<locale.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*
comment|*/
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|MF
end_ifndef

begin_define
define|#
directive|define
name|MFminc
parameter_list|(
name|a
parameter_list|)
value|(a)
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* MF */
end_comment

begin_define
define|#
directive|define
name|MFminc
parameter_list|(
name|a
parameter_list|)
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* MF */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|POP
end_ifndef

begin_define
define|#
directive|define
name|POPminc
parameter_list|(
name|a
parameter_list|)
value|(a)
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* POP */
end_comment

begin_define
define|#
directive|define
name|POPminc
parameter_list|(
name|a
parameter_list|)
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* POP */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|RPOP
end_ifndef

begin_define
define|#
directive|define
name|RPOPminc
parameter_list|(
name|a
parameter_list|)
value|(a)
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* RPOP */
end_comment

begin_define
define|#
directive|define
name|RPOPminc
parameter_list|(
name|a
parameter_list|)
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* RPOP */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|APOP
end_ifndef

begin_define
define|#
directive|define
name|APOPminc
parameter_list|(
name|a
parameter_list|)
value|(a)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|APOPminc
parameter_list|(
name|a
parameter_list|)
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* APOP */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|TMA
end_ifndef

begin_define
define|#
directive|define
name|TMAminc
parameter_list|(
name|a
parameter_list|)
value|(a)
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* TMA */
end_comment

begin_define
define|#
directive|define
name|TMAminc
parameter_list|(
name|a
parameter_list|)
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* TMA */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|swit
name|switches
index|[]
init|=
block|{
define|#
directive|define
name|AUDSW
value|0
literal|"audit audit-file"
block|,
literal|0
block|,
define|#
directive|define
name|NAUDSW
value|1
literal|"noaudit"
block|,
literal|0
block|,
define|#
directive|define
name|CHGSW
value|2
literal|"changecur"
block|,
literal|0
block|,
define|#
directive|define
name|NCHGSW
value|3
literal|"nochangecur"
block|,
literal|0
block|,
define|#
directive|define
name|DECRSW
value|4
literal|"decrypt"
block|,
name|TMAminc
argument_list|(
operator|-
literal|7
argument_list|)
block|,
define|#
directive|define
name|NDECRSW
value|5
literal|"nodecrypt"
block|,
name|TMAminc
argument_list|(
operator|-
literal|9
argument_list|)
block|,
define|#
directive|define
name|MSW
value|6
literal|"file name"
block|,
literal|0
block|,
define|#
directive|define
name|FORMSW
value|7
literal|"form formatfile"
block|,
literal|0
block|,
define|#
directive|define
name|FMTSW
value|8
literal|"format string"
block|,
literal|5
block|,
define|#
directive|define
name|HOSTSW
value|9
literal|"host host"
block|,
name|POPminc
argument_list|(
operator|-
literal|4
argument_list|)
block|,
define|#
directive|define
name|USERSW
value|10
literal|"user user"
block|,
name|POPminc
argument_list|(
operator|-
literal|4
argument_list|)
block|,
define|#
directive|define
name|PACKSW
value|11
literal|"pack file"
block|,
name|POPminc
argument_list|(
operator|-
literal|4
argument_list|)
block|,
define|#
directive|define
name|NPACKSW
value|12
literal|"nopack"
block|,
name|POPminc
argument_list|(
operator|-
literal|6
argument_list|)
block|,
define|#
directive|define
name|APOPSW
value|13
literal|"apop"
block|,
name|APOPminc
argument_list|(
operator|-
literal|4
argument_list|)
block|,
define|#
directive|define
name|NAPOPSW
value|14
literal|"noapop"
block|,
name|APOPminc
argument_list|(
operator|-
literal|6
argument_list|)
block|,
define|#
directive|define
name|RPOPSW
value|15
literal|"rpop"
block|,
name|RPOPminc
argument_list|(
operator|-
literal|4
argument_list|)
block|,
define|#
directive|define
name|NRPOPSW
value|16
literal|"norpop"
block|,
name|RPOPminc
argument_list|(
operator|-
literal|6
argument_list|)
block|,
define|#
directive|define
name|SILSW
value|17
literal|"silent"
block|,
literal|0
block|,
define|#
directive|define
name|NSILSW
value|18
literal|"nosilent"
block|,
literal|0
block|,
define|#
directive|define
name|TRNCSW
value|19
literal|"truncate"
block|,
literal|0
block|,
define|#
directive|define
name|NTRNCSW
value|20
literal|"notruncate"
block|,
literal|0
block|,
define|#
directive|define
name|UUCPSW
value|21
literal|"uucp"
block|,
name|MFminc
argument_list|(
operator|-
literal|4
argument_list|)
block|,
define|#
directive|define
name|NUUCPSW
value|22
literal|"nouucp"
block|,
name|MFminc
argument_list|(
operator|-
literal|6
argument_list|)
block|,
define|#
directive|define
name|WIDSW
value|23
literal|"width columns"
block|,
literal|0
block|,
define|#
directive|define
name|HELPSW
value|24
literal|"help"
block|,
literal|4
block|,
name|NULL
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*
comment|*/
end_comment

begin_decl_stmt
specifier|extern
name|int
name|errno
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|POP
end_ifdef

begin_decl_stmt
name|int
name|snoop
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
name|response
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|file
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|size
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|long
name|pos
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|long
name|start
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|long
name|stop
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|pd
init|=
name|NOTOK
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|FILE
modifier|*
name|pf
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|pop_action
argument_list|()
decl_stmt|,
name|pop_pack
argument_list|()
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|int
name|map_count
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* POP */
end_comment

begin_comment
comment|/*
comment|* /  /* ARGSUSED */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|MAILGROUP
end_ifdef

begin_comment
comment|/* For setting and returning to "mail" gid */
end_comment

begin_decl_stmt
specifier|static
name|int
name|return_gid
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* MAILGROUP */
end_comment

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
name|argv
index|[]
decl_stmt|;
block|{
name|int
name|chgflag
init|=
literal|1
decl_stmt|,
name|trnflag
init|=
literal|1
decl_stmt|,
name|decflag
init|=
literal|1
decl_stmt|,
name|noisy
init|=
literal|1
decl_stmt|,
name|width
init|=
literal|0
decl_stmt|,
ifdef|#
directive|ifdef
name|MF
name|uucp
init|=
literal|1
decl_stmt|,
endif|#
directive|endif
comment|/* MF */
name|locked
init|=
literal|0
decl_stmt|,
ifdef|#
directive|ifdef
name|POP
name|nmsgs
decl_stmt|,
name|nbytes
decl_stmt|,
name|p
init|=
literal|0
decl_stmt|,
endif|#
directive|endif
comment|/* POP */
name|rpop
init|=
literal|1
decl_stmt|,
name|i
decl_stmt|,
name|hghnum
decl_stmt|,
name|msgnum
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|maildir
decl_stmt|,
modifier|*
name|folder
init|=
name|NULL
decl_stmt|,
modifier|*
name|form
init|=
name|NULL
decl_stmt|,
modifier|*
name|format
init|=
name|NULL
decl_stmt|,
modifier|*
name|audfile
init|=
name|NULL
decl_stmt|,
modifier|*
name|from
init|=
name|NULL
decl_stmt|,
modifier|*
name|host
init|=
name|NULL
decl_stmt|,
ifdef|#
directive|ifdef
name|POP
modifier|*
name|pass
init|=
name|NULL
decl_stmt|,
endif|#
directive|endif
comment|/* POP */
modifier|*
name|newmail
decl_stmt|,
name|buf
index|[
literal|100
index|]
decl_stmt|,
modifier|*
modifier|*
name|ap
decl_stmt|,
modifier|*
modifier|*
name|argp
decl_stmt|,
modifier|*
name|nfs
decl_stmt|,
modifier|*
name|arguments
index|[
name|MAXARGS
index|]
decl_stmt|;
name|char
modifier|*
name|user
init|=
name|NULL
decl_stmt|;
name|struct
name|msgs
modifier|*
name|mp
decl_stmt|;
name|struct
name|stat
name|st
decl_stmt|,
name|s1
decl_stmt|;
name|FILE
modifier|*
name|in
decl_stmt|,
modifier|*
name|aud
init|=
name|NULL
decl_stmt|;
ifdef|#
directive|ifdef
name|MHE
name|FILE
modifier|*
name|mhe
init|=
name|NULL
decl_stmt|;
endif|#
directive|endif
comment|/* MHE */
ifdef|#
directive|ifdef
name|HESIOD
name|struct
name|hes_postoffice
modifier|*
name|po
decl_stmt|;
name|char
modifier|*
name|tmphost
decl_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|LOCALE
name|setlocale
argument_list|(
name|LC_ALL
argument_list|,
literal|""
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|invo_name
operator|=
name|r1bindex
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
name|mts_init
argument_list|(
name|invo_name
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|POP
if|if
condition|(
operator|(
name|cp
operator|=
name|getenv
argument_list|(
literal|"MHPOPDEBUG"
argument_list|)
operator|)
operator|&&
operator|*
name|cp
condition|)
name|snoop
operator|++
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|cp
operator|=
name|m_find
argument_list|(
name|invo_name
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|ap
operator|=
name|brkstring
argument_list|(
name|cp
operator|=
name|getcpy
argument_list|(
name|cp
argument_list|)
argument_list|,
literal|" "
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|ap
operator|=
name|copyip
argument_list|(
name|ap
argument_list|,
name|arguments
argument_list|)
expr_stmt|;
block|}
else|else
name|ap
operator|=
name|arguments
expr_stmt|;
operator|(
name|void
operator|)
name|copyip
argument_list|(
name|argv
operator|+
literal|1
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|argp
operator|=
name|arguments
expr_stmt|;
comment|/*
comment|*/
while|while
condition|(
name|cp
operator|=
operator|*
name|argp
operator|++
condition|)
block|{
if|if
condition|(
operator|*
name|cp
operator|==
literal|'-'
condition|)
switch|switch
condition|(
name|smatch
argument_list|(
operator|++
name|cp
argument_list|,
name|switches
argument_list|)
condition|)
block|{
case|case
name|AMBIGSW
case|:
name|ambigsw
argument_list|(
name|cp
argument_list|,
name|switches
argument_list|)
expr_stmt|;
name|done
argument_list|(
literal|1
argument_list|)
expr_stmt|;
case|case
name|UNKWNSW
case|:
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"-%s unknown"
argument_list|,
name|cp
argument_list|)
expr_stmt|;
case|case
name|HELPSW
case|:
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%s [+folder] [switches]"
argument_list|,
name|invo_name
argument_list|)
expr_stmt|;
name|help
argument_list|(
name|buf
argument_list|,
name|switches
argument_list|)
expr_stmt|;
name|done
argument_list|(
literal|1
argument_list|)
expr_stmt|;
case|case
name|AUDSW
case|:
if|if
condition|(
operator|!
operator|(
name|cp
operator|=
operator|*
name|argp
operator|++
operator|)
operator|||
operator|*
name|cp
operator|==
literal|'-'
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"missing argument to %s"
argument_list|,
name|argp
index|[
operator|-
literal|2
index|]
argument_list|)
expr_stmt|;
name|audfile
operator|=
name|getcpy
argument_list|(
name|m_maildir
argument_list|(
name|cp
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
case|case
name|NAUDSW
case|:
name|audfile
operator|=
name|NULL
expr_stmt|;
continue|continue;
case|case
name|CHGSW
case|:
name|chgflag
operator|++
expr_stmt|;
continue|continue;
case|case
name|NCHGSW
case|:
name|chgflag
operator|=
literal|0
expr_stmt|;
continue|continue;
case|case
name|TRNCSW
case|:
name|trnflag
operator|++
expr_stmt|;
continue|continue;
case|case
name|MSW
case|:
if|if
condition|(
operator|!
operator|(
name|cp
operator|=
operator|*
name|argp
operator|++
operator|)
operator|||
operator|*
name|cp
operator|==
literal|'-'
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"missing argument to %s"
argument_list|,
name|argp
index|[
operator|-
literal|2
index|]
argument_list|)
expr_stmt|;
name|from
operator|=
name|path
argument_list|(
name|cp
argument_list|,
name|TFILE
argument_list|)
expr_stmt|;
comment|/* fall */
case|case
name|NTRNCSW
case|:
name|trnflag
operator|=
literal|0
expr_stmt|;
continue|continue;
case|case
name|SILSW
case|:
name|noisy
operator|=
literal|0
expr_stmt|;
continue|continue;
case|case
name|NSILSW
case|:
name|noisy
operator|++
expr_stmt|;
continue|continue;
case|case
name|FORMSW
case|:
if|if
condition|(
operator|!
operator|(
name|form
operator|=
operator|*
name|argp
operator|++
operator|)
operator|||
operator|*
name|form
operator|==
literal|'-'
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"missing argument to %s"
argument_list|,
name|argp
index|[
operator|-
literal|2
index|]
argument_list|)
expr_stmt|;
name|format
operator|=
name|NULL
expr_stmt|;
continue|continue;
case|case
name|FMTSW
case|:
if|if
condition|(
operator|!
operator|(
name|format
operator|=
operator|*
name|argp
operator|++
operator|)
operator|||
operator|*
name|format
operator|==
literal|'-'
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"missing argument to %s"
argument_list|,
name|argp
index|[
operator|-
literal|2
index|]
argument_list|)
expr_stmt|;
name|form
operator|=
name|NULL
expr_stmt|;
continue|continue;
case|case
name|WIDSW
case|:
if|if
condition|(
operator|!
operator|(
name|cp
operator|=
operator|*
name|argp
operator|++
operator|)
operator|||
operator|*
name|cp
operator|==
literal|'-'
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"missing argument to %s"
argument_list|,
name|argp
index|[
operator|-
literal|2
index|]
argument_list|)
expr_stmt|;
name|width
operator|=
name|atoi
argument_list|(
name|cp
argument_list|)
expr_stmt|;
continue|continue;
case|case
name|DECRSW
case|:
name|decflag
operator|++
expr_stmt|;
continue|continue;
case|case
name|NDECRSW
case|:
name|decflag
operator|=
literal|0
expr_stmt|;
continue|continue;
case|case
name|UUCPSW
case|:
ifdef|#
directive|ifdef
name|MF
name|uucp
operator|++
expr_stmt|;
endif|#
directive|endif
comment|/* MF */
continue|continue;
case|case
name|NUUCPSW
case|:
ifdef|#
directive|ifdef
name|MF
name|uucp
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
comment|/* MF */
continue|continue;
case|case
name|HOSTSW
case|:
if|if
condition|(
operator|!
operator|(
name|host
operator|=
operator|*
name|argp
operator|++
operator|)
operator|||
operator|*
name|host
operator|==
literal|'-'
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"missing argument to %s"
argument_list|,
name|argp
index|[
operator|-
literal|2
index|]
argument_list|)
expr_stmt|;
continue|continue;
case|case
name|USERSW
case|:
if|if
condition|(
operator|!
operator|(
name|user
operator|=
operator|*
name|argp
operator|++
operator|)
operator|||
operator|*
name|user
operator|==
literal|'-'
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"missing argument to %s"
argument_list|,
name|argp
index|[
operator|-
literal|2
index|]
argument_list|)
expr_stmt|;
continue|continue;
case|case
name|PACKSW
case|:
ifndef|#
directive|ifndef
name|POP
if|if
condition|(
operator|!
operator|(
name|cp
operator|=
operator|*
name|argp
operator|++
operator|)
operator|||
operator|*
name|cp
operator|==
literal|'-'
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"missing argument to %s"
argument_list|,
name|argp
index|[
operator|-
literal|2
index|]
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* POP */
if|if
condition|(
operator|!
operator|(
name|file
operator|=
operator|*
name|argp
operator|++
operator|)
operator|||
operator|*
name|file
operator|==
literal|'-'
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"missing argument to %s"
argument_list|,
name|argp
index|[
operator|-
literal|2
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* POP */
continue|continue;
case|case
name|NPACKSW
case|:
ifdef|#
directive|ifdef
name|POP
name|file
operator|=
name|NULLCP
expr_stmt|;
endif|#
directive|endif
comment|/* POP */
continue|continue;
case|case
name|APOPSW
case|:
name|rpop
operator|=
operator|-
literal|1
expr_stmt|;
continue|continue;
case|case
name|RPOPSW
case|:
name|rpop
operator|=
literal|1
expr_stmt|;
continue|continue;
case|case
name|NAPOPSW
case|:
case|case
name|NRPOPSW
case|:
name|rpop
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|*
name|cp
operator|==
literal|'+'
operator|||
operator|*
name|cp
operator|==
literal|'@'
condition|)
block|{
if|if
condition|(
name|folder
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"only one folder at a time!"
argument_list|)
expr_stmt|;
else|else
name|folder
operator|=
name|path
argument_list|(
name|cp
operator|+
literal|1
argument_list|,
operator|*
name|cp
operator|==
literal|'+'
condition|?
name|TFOLDER
else|:
name|TSUBCWF
argument_list|)
expr_stmt|;
block|}
else|else
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"usage: %s [+folder] [switches]"
argument_list|,
name|invo_name
argument_list|)
expr_stmt|;
block|}
comment|/*
comment|*/
ifdef|#
directive|ifdef
name|MAILGROUP
name|return_gid
operator|=
name|getegid
argument_list|()
expr_stmt|;
comment|/* Save effective gid, assuming we'll use it */
name|setgid
argument_list|(
name|getgid
argument_list|()
argument_list|)
expr_stmt|;
comment|/* Turn off extraordinary privileges */
endif|#
directive|endif
comment|/* MAILGROUP */
ifdef|#
directive|ifdef
name|POP
ifdef|#
directive|ifdef
name|HESIOD
comment|/*      * Scheme is:      *        use MAILHOST environment variable if present,      *  else try Hesiod.      *  If that fails, use the default (if any)      *  provided by mtstailor in mts_init()      */
if|if
condition|(
name|pophost
operator|==
name|NULL
operator|||
name|pophost
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
block|{
if|if
condition|(
operator|(
name|tmphost
operator|=
name|getenv
argument_list|(
literal|"MAILHOST"
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|pophost
operator|=
name|tmphost
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|po
operator|=
name|hes_getmailhost
argument_list|(
name|getusr
argument_list|()
argument_list|)
operator|)
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
name|po
operator|->
name|po_type
argument_list|,
literal|"POP"
argument_list|)
operator|==
literal|0
condition|)
name|pophost
operator|=
name|po
operator|->
name|po_host
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* HESIOD */
if|if
condition|(
name|pophost
operator|&&
operator|*
name|pophost
condition|)
name|host
operator|=
name|pophost
expr_stmt|;
if|if
condition|(
name|host
operator|&&
operator|!
operator|*
name|host
condition|)
name|host
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|from
operator|||
operator|!
name|host
operator|||
name|rpop
operator|<=
literal|0
condition|)
operator|(
name|void
operator|)
name|setuid
argument_list|(
name|getuid
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* POP */
if|if
condition|(
name|from
condition|)
block|{
name|newmail
operator|=
name|from
expr_stmt|;
ifdef|#
directive|ifdef
name|POP
name|host
operator|=
name|NULL
expr_stmt|;
endif|#
directive|endif
comment|/* POP */
if|if
condition|(
name|stat
argument_list|(
name|newmail
argument_list|,
operator|&
name|s1
argument_list|)
operator|==
name|NOTOK
operator|||
name|s1
operator|.
name|st_size
operator|==
literal|0
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"no mail to incorporate"
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|POP
elseif|else
if|if
condition|(
name|host
condition|)
block|{
if|if
condition|(
name|rpop
condition|)
block|{
if|if
condition|(
name|user
operator|==
name|NULL
condition|)
name|user
operator|=
name|getusr
argument_list|()
expr_stmt|;
name|pass
operator|=
name|getusr
argument_list|()
expr_stmt|;
block|}
else|else
name|ruserpass
argument_list|(
name|host
argument_list|,
operator|&
name|user
argument_list|,
operator|&
name|pass
argument_list|)
expr_stmt|;
if|if
condition|(
name|pop_init
argument_list|(
name|host
argument_list|,
name|user
argument_list|,
name|pass
argument_list|,
name|snoop
argument_list|,
name|rpop
argument_list|)
operator|==
name|NOTOK
operator|||
name|pop_stat
argument_list|(
operator|&
name|nmsgs
argument_list|,
operator|&
name|nbytes
argument_list|)
operator|==
name|NOTOK
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"%s"
argument_list|,
name|response
argument_list|)
expr_stmt|;
if|if
condition|(
name|rpop
condition|)
operator|(
name|void
operator|)
name|setuid
argument_list|(
name|getuid
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|nmsgs
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|pop_quit
argument_list|()
expr_stmt|;
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"no mail to incorporate"
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* POP */
else|else
block|{
if|if
condition|(
operator|(
operator|(
name|newmail
operator|=
name|getenv
argument_list|(
literal|"MAILDROP"
argument_list|)
operator|)
operator|&&
operator|*
name|newmail
operator|)
operator|||
operator|(
operator|(
name|newmail
operator|=
name|m_find
argument_list|(
literal|"maildrop"
argument_list|)
operator|)
operator|&&
operator|*
name|newmail
operator|)
condition|)
name|newmail
operator|=
name|m_mailpath
argument_list|(
name|newmail
argument_list|)
expr_stmt|;
else|else
block|{
ifdef|#
directive|ifdef
name|MF
if|if
condition|(
name|uucp
operator|&&
name|umincproc
operator|&&
operator|*
name|umincproc
condition|)
name|get_uucp_mail
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* MF */
name|newmail
operator|=
name|concat
argument_list|(
name|MAILDIR
argument_list|,
literal|"/"
argument_list|,
name|MAILFIL
argument_list|,
name|NULLCP
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|stat
argument_list|(
name|newmail
argument_list|,
operator|&
name|s1
argument_list|)
operator|==
name|NOTOK
operator|||
name|s1
operator|.
name|st_size
operator|==
literal|0
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"no mail to incorporate"
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|POP
if|if
condition|(
name|host
operator|&&
name|file
condition|)
goto|goto
name|go_to_it
goto|;
endif|#
directive|endif
comment|/* POP */
if|if
condition|(
operator|!
name|m_find
argument_list|(
literal|"path"
argument_list|)
condition|)
name|free
argument_list|(
name|path
argument_list|(
literal|"./"
argument_list|,
name|TFOLDER
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|folder
operator|&&
operator|!
operator|(
name|folder
operator|=
name|m_find
argument_list|(
name|inbox
argument_list|)
operator|)
condition|)
name|folder
operator|=
name|defalt
expr_stmt|;
name|maildir
operator|=
name|m_maildir
argument_list|(
name|folder
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|maildir
argument_list|,
operator|&
name|st
argument_list|)
operator|==
name|NOTOK
condition|)
block|{
if|if
condition|(
name|errno
operator|!=
name|ENOENT
condition|)
name|adios
argument_list|(
name|maildir
argument_list|,
literal|"error on folder"
argument_list|)
expr_stmt|;
name|cp
operator|=
name|concat
argument_list|(
literal|"Create folder \""
argument_list|,
name|maildir
argument_list|,
literal|"\"? "
argument_list|,
name|NULLCP
argument_list|)
expr_stmt|;
if|if
condition|(
name|noisy
operator|&&
operator|!
name|getanswer
argument_list|(
name|cp
argument_list|)
condition|)
name|done
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|makedir
argument_list|(
name|maildir
argument_list|)
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"unable to create folder %s"
argument_list|,
name|maildir
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|chdir
argument_list|(
name|maildir
argument_list|)
operator|==
name|NOTOK
condition|)
name|adios
argument_list|(
name|maildir
argument_list|,
literal|"unable to change directory to"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|mp
operator|=
name|m_gmsg
argument_list|(
name|folder
argument_list|)
operator|)
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"unable to read folder %s"
argument_list|,
name|folder
argument_list|)
expr_stmt|;
comment|/*
comment|*/
ifdef|#
directive|ifdef
name|POP
name|go_to_it
label|:
empty_stmt|;
if|if
condition|(
name|host
operator|==
name|NULL
condition|)
endif|#
directive|endif
comment|/* POP */
if|if
condition|(
name|access
argument_list|(
name|newmail
argument_list|,
literal|02
argument_list|)
operator|==
name|NOTOK
condition|)
block|{
name|trnflag
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|in
operator|=
name|fopen
argument_list|(
name|newmail
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|adios
argument_list|(
name|newmail
argument_list|,
literal|"unable to read"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|locked
operator|++
expr_stmt|;
if|if
condition|(
name|trnflag
condition|)
block|{
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGHUP
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGTERM
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|MAILGROUP
name|setgid
argument_list|(
name|return_gid
argument_list|)
expr_stmt|;
comment|/* Reset gid to lock mail file */
endif|#
directive|endif
comment|/* MAILGROUP */
if|if
condition|(
operator|(
name|in
operator|=
name|lkfopen
argument_list|(
name|newmail
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"unable to lock and fopen %s"
argument_list|,
name|newmail
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MAILGROUP
name|setgid
argument_list|(
name|getgid
argument_list|()
argument_list|)
expr_stmt|;
comment|/* Return us to normal privileges */
endif|#
directive|endif
comment|/* MAILGROUP */
operator|(
name|void
operator|)
name|fstat
argument_list|(
name|fileno
argument_list|(
name|in
argument_list|)
argument_list|,
operator|&
name|s1
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|MAILGROUP
name|setgid
argument_list|(
name|getgid
argument_list|()
argument_list|)
expr_stmt|;
comment|/* Return us to normal privileges */
endif|#
directive|endif
comment|/* MAILGROUP */
if|if
condition|(
name|audfile
condition|)
block|{
if|if
condition|(
operator|(
name|i
operator|=
name|stat
argument_list|(
name|audfile
argument_list|,
operator|&
name|st
argument_list|)
operator|)
operator|==
name|NOTOK
condition|)
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"Creating Receive-Audit: %s"
argument_list|,
name|audfile
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|aud
operator|=
name|fopen
argument_list|(
name|audfile
argument_list|,
literal|"a"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|adios
argument_list|(
name|audfile
argument_list|,
literal|"unable to append to"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|i
operator|==
name|NOTOK
condition|)
operator|(
name|void
operator|)
name|chmod
argument_list|(
name|audfile
argument_list|,
name|m_gmprot
argument_list|()
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|POP
name|fprintf
argument_list|(
name|aud
argument_list|,
name|from
condition|?
literal|"<<inc>> %s  -ms %s\n"
else|:
literal|"<<inc>> %s\n"
argument_list|,
name|dtimenow
argument_list|()
argument_list|,
name|from
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* POP */
name|fprintf
argument_list|(
name|aud
argument_list|,
name|from
condition|?
literal|"<<inc>> %s -ms %s\n"
else|:
name|host
condition|?
literal|"<<inc>> %s -host %s -user %s%s\n"
else|:
literal|"<<inc>> %s\n"
argument_list|,
name|dtimenow
argument_list|()
argument_list|,
name|from
condition|?
name|from
else|:
name|host
argument_list|,
name|user
argument_list|,
name|rpop
operator|<
literal|0
condition|?
literal|" -apop"
else|:
name|rpop
operator|>
literal|0
condition|?
literal|" -rpop"
else|:
literal|""
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* POP */
block|}
ifdef|#
directive|ifdef
name|MHE
if|if
condition|(
name|m_find
argument_list|(
literal|"mhe"
argument_list|)
condition|)
block|{
name|cp
operator|=
name|concat
argument_list|(
name|maildir
argument_list|,
literal|"/++"
argument_list|,
name|NULLCP
argument_list|)
expr_stmt|;
name|i
operator|=
name|stat
argument_list|(
name|cp
argument_list|,
operator|&
name|st
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|mhe
operator|=
name|fopen
argument_list|(
name|cp
argument_list|,
literal|"a"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|admonish
argument_list|(
name|cp
argument_list|,
literal|"unable to append to"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|i
operator|==
name|NOTOK
condition|)
operator|(
name|void
operator|)
name|chmod
argument_list|(
name|cp
argument_list|,
name|m_gmprot
argument_list|()
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|cp
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* MHE */
name|nfs
operator|=
name|new_fs
argument_list|(
name|form
argument_list|,
name|format
argument_list|,
name|FORMAT
argument_list|)
expr_stmt|;
if|if
condition|(
name|noisy
condition|)
block|{
name|printf
argument_list|(
literal|"Incorporating new mail into %s...\n\n"
argument_list|,
name|folder
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
comment|/*
comment|*/
ifdef|#
directive|ifdef
name|POP
if|if
condition|(
name|host
condition|)
block|{
if|if
condition|(
name|file
condition|)
block|{
name|file
operator|=
name|path
argument_list|(
name|file
argument_list|,
name|TFILE
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|file
argument_list|,
operator|&
name|st
argument_list|)
operator|==
name|NOTOK
condition|)
block|{
if|if
condition|(
name|errno
operator|!=
name|ENOENT
condition|)
name|adios
argument_list|(
name|file
argument_list|,
literal|"error on file"
argument_list|)
expr_stmt|;
name|cp
operator|=
name|concat
argument_list|(
literal|"Create file \""
argument_list|,
name|file
argument_list|,
literal|"\"? "
argument_list|,
name|NULLCP
argument_list|)
expr_stmt|;
if|if
condition|(
name|noisy
operator|&&
operator|!
name|getanswer
argument_list|(
name|cp
argument_list|)
condition|)
name|done
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|cp
argument_list|)
expr_stmt|;
block|}
name|msgnum
operator|=
name|map_count
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|pd
operator|=
name|mbx_open
argument_list|(
name|file
argument_list|,
name|getuid
argument_list|()
argument_list|,
name|getgid
argument_list|()
argument_list|,
name|m_gmprot
argument_list|()
argument_list|)
operator|)
operator|==
name|NOTOK
condition|)
name|adios
argument_list|(
name|file
argument_list|,
literal|"unable to open"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|pf
operator|=
name|fdopen
argument_list|(
name|pd
argument_list|,
literal|"w+"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"unable to fdopen %s"
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|hghnum
operator|=
name|msgnum
operator|=
name|mp
operator|->
name|hghmsg
expr_stmt|;
if|if
condition|(
operator|(
name|mp
operator|=
name|m_remsg
argument_list|(
name|mp
argument_list|,
literal|0
argument_list|,
name|mp
operator|->
name|hghmsg
operator|+
name|nmsgs
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"unable to allocate folder storage"
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|nmsgs
condition|;
name|i
operator|++
control|)
block|{
name|msgnum
operator|++
expr_stmt|;
if|if
condition|(
name|file
condition|)
block|{
operator|(
name|void
operator|)
name|fseek
argument_list|(
name|pf
argument_list|,
literal|0L
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|pos
operator|=
name|ftell
argument_list|(
name|pf
argument_list|)
expr_stmt|;
name|size
operator|=
literal|0
expr_stmt|;
operator|(
name|void
operator|)
name|fwrite
argument_list|(
name|mmdlm1
argument_list|,
literal|1
argument_list|,
name|strlen
argument_list|(
name|mmdlm1
argument_list|)
argument_list|,
name|pf
argument_list|)
expr_stmt|;
name|start
operator|=
name|ftell
argument_list|(
name|pf
argument_list|)
expr_stmt|;
if|if
condition|(
name|pop_retr
argument_list|(
name|i
argument_list|,
name|pop_pack
argument_list|)
operator|==
name|NOTOK
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"%s"
argument_list|,
name|response
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fseek
argument_list|(
name|pf
argument_list|,
literal|0L
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|stop
operator|=
name|ftell
argument_list|(
name|pf
argument_list|)
expr_stmt|;
if|if
condition|(
name|fflush
argument_list|(
name|pf
argument_list|)
condition|)
name|adios
argument_list|(
name|file
argument_list|,
literal|"write error on"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fseek
argument_list|(
name|pf
argument_list|,
name|start
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|cp
operator|=
name|getcpy
argument_list|(
name|m_name
argument_list|(
name|msgnum
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|pf
operator|=
name|fopen
argument_list|(
name|cp
argument_list|,
literal|"w+"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|adios
argument_list|(
name|cp
argument_list|,
literal|"unable to write"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|chmod
argument_list|(
name|cp
argument_list|,
name|m_gmprot
argument_list|()
argument_list|)
expr_stmt|;
name|start
operator|=
name|stop
operator|=
literal|0L
expr_stmt|;
if|if
condition|(
name|pop_retr
argument_list|(
name|i
argument_list|,
name|pop_action
argument_list|)
operator|==
name|NOTOK
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"%s"
argument_list|,
name|response
argument_list|)
expr_stmt|;
if|if
condition|(
name|fflush
argument_list|(
name|pf
argument_list|)
condition|)
name|adios
argument_list|(
name|cp
argument_list|,
literal|"write error on"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fseek
argument_list|(
name|pf
argument_list|,
literal|0L
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|p
operator|=
name|scan
argument_list|(
name|pf
argument_list|,
name|msgnum
argument_list|,
literal|0
argument_list|,
name|nfs
argument_list|,
name|width
argument_list|,
name|file
condition|?
literal|0
else|:
name|msgnum
operator|==
name|mp
operator|->
name|hghmsg
operator|+
literal|1
operator|&&
name|chgflag
argument_list|,
literal|1
argument_list|,
comment|/* check UNSEEN? */
literal|0
argument_list|,
name|stop
operator|-
name|start
argument_list|,
name|noisy
argument_list|)
condition|)
block|{
case|case
name|SCNEOF
case|:
name|printf
argument_list|(
literal|"%*d  empty\n"
argument_list|,
name|DMAXFOLDER
argument_list|,
name|msgnum
argument_list|)
expr_stmt|;
break|break;
case|case
name|SCNFAT
case|:
name|trnflag
operator|=
literal|0
expr_stmt|;
name|noisy
operator|++
expr_stmt|;
comment|/* advise (cp, "unable to read"); already advised */
comment|/* fall thru */
case|case
name|SCNERR
case|:
case|case
name|SCNNUM
case|:
break|break;
case|case
name|SCNMSG
case|:
case|case
name|SCNENC
case|:
default|default:
if|if
condition|(
name|aud
condition|)
name|fputs
argument_list|(
name|scanl
argument_list|,
name|aud
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MHE
if|if
condition|(
name|mhe
condition|)
name|fputs
argument_list|(
name|scanl
argument_list|,
name|mhe
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* MHE */
if|if
condition|(
name|noisy
condition|)
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|file
condition|)
block|{
name|mp
operator|->
name|msgstats
index|[
name|msgnum
index|]
operator|=
name|EXISTS
expr_stmt|;
ifdef|#
directive|ifdef
name|TMA
if|if
condition|(
name|p
operator|==
name|SCNENC
condition|)
block|{
if|if
condition|(
name|mp
operator|->
name|lowsel
operator|==
literal|0
operator|||
name|msgnum
operator|<
name|mp
operator|->
name|lowsel
condition|)
name|mp
operator|->
name|lowsel
operator|=
name|msgnum
expr_stmt|;
if|if
condition|(
name|mp
operator|->
name|hghsel
operator|==
literal|0
operator|||
name|msgnum
operator|>
name|mp
operator|->
name|hghsel
condition|)
name|mp
operator|->
name|hghsel
operator|=
name|msgnum
expr_stmt|;
name|mp
operator|->
name|numsel
operator|++
expr_stmt|;
name|mp
operator|->
name|msgstats
index|[
name|msgnum
index|]
operator||=
name|SELECTED
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* TMA */
name|mp
operator|->
name|msgstats
index|[
name|msgnum
index|]
operator||=
name|UNSEEN
expr_stmt|;
name|mp
operator|->
name|msgflags
operator||=
name|SEQMOD
expr_stmt|;
block|}
break|break;
block|}
if|if
condition|(
name|file
condition|)
block|{
operator|(
name|void
operator|)
name|fseek
argument_list|(
name|pf
argument_list|,
name|stop
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fwrite
argument_list|(
name|mmdlm2
argument_list|,
literal|1
argument_list|,
name|strlen
argument_list|(
name|mmdlm2
argument_list|)
argument_list|,
name|pf
argument_list|)
expr_stmt|;
if|if
condition|(
name|fflush
argument_list|(
name|pf
argument_list|)
operator|||
name|ferror
argument_list|(
name|pf
argument_list|)
condition|)
block|{
name|int
name|e
init|=
name|errno
decl_stmt|;
operator|(
name|void
operator|)
name|pop_quit
argument_list|()
expr_stmt|;
name|errno
operator|=
name|e
expr_stmt|;
name|adios
argument_list|(
name|file
argument_list|,
literal|"write error on"
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|map_write
argument_list|(
name|file
argument_list|,
name|pd
argument_list|,
literal|0
argument_list|,
literal|0L
argument_list|,
name|start
argument_list|,
name|stop
argument_list|,
name|pos
argument_list|,
name|size
argument_list|,
name|noisy
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|ferror
argument_list|(
name|pf
argument_list|)
operator|||
name|fclose
argument_list|(
name|pf
argument_list|)
condition|)
block|{
name|int
name|e
init|=
name|errno
decl_stmt|;
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|cp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|pop_quit
argument_list|()
expr_stmt|;
name|errno
operator|=
name|e
expr_stmt|;
name|adios
argument_list|(
name|cp
argument_list|,
literal|"write error on"
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|cp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|trnflag
operator|&&
name|pop_dele
argument_list|(
name|i
argument_list|)
operator|==
name|NOTOK
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"%s"
argument_list|,
name|response
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pop_quit
argument_list|()
operator|==
name|NOTOK
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"%s"
argument_list|,
name|response
argument_list|)
expr_stmt|;
if|if
condition|(
name|file
condition|)
block|{
operator|(
name|void
operator|)
name|mbx_close
argument_list|(
name|file
argument_list|,
name|pd
argument_list|)
expr_stmt|;
name|pd
operator|=
name|NOTOK
expr_stmt|;
block|}
block|}
else|else
block|{
endif|#
directive|endif
comment|/* POP */
comment|/*
comment|*/
name|m_unknown
argument_list|(
name|in
argument_list|)
expr_stmt|;
comment|/* the MAGIC invocation... */
name|hghnum
operator|=
name|msgnum
operator|=
name|mp
operator|->
name|hghmsg
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
condition|;
control|)
block|{
if|if
condition|(
name|msgnum
operator|>=
name|mp
operator|->
name|hghoff
condition|)
if|if
condition|(
operator|(
name|mp
operator|=
name|m_remsg
argument_list|(
name|mp
argument_list|,
literal|0
argument_list|,
name|mp
operator|->
name|hghoff
operator|+
name|MAXFOLDER
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"unable to allocate folder storage"
argument_list|)
expr_stmt|;
name|i
operator|=
name|NOTOK
expr_stmt|;
break|break;
block|}
switch|switch
condition|(
name|i
operator|=
name|scan
argument_list|(
name|in
argument_list|,
name|msgnum
operator|+
literal|1
argument_list|,
name|msgnum
operator|+
literal|1
argument_list|,
name|nfs
argument_list|,
name|width
argument_list|,
name|msgnum
operator|==
name|hghnum
operator|&&
name|chgflag
argument_list|,
literal|1
argument_list|,
comment|/* check UNSEEN? */
literal|0
argument_list|,
literal|0L
argument_list|,
name|noisy
argument_list|)
condition|)
block|{
case|case
name|SCNFAT
case|:
case|case
name|SCNEOF
case|:
break|break;
case|case
name|SCNERR
case|:
if|if
condition|(
name|aud
condition|)
name|fputs
argument_list|(
literal|"inc aborted!\n"
argument_list|,
name|aud
argument_list|)
expr_stmt|;
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"aborted!"
argument_list|)
expr_stmt|;
comment|/* doesn't clean up locks! */
break|break;
case|case
name|SCNNUM
case|:
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"more than %d messages in folder %s, %s not zero'd"
argument_list|,
name|MAXFOLDER
argument_list|,
name|folder
argument_list|,
name|newmail
argument_list|)
expr_stmt|;
break|break;
default|default:
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"scan() botch (%d)"
argument_list|,
name|i
argument_list|)
expr_stmt|;
break|break;
case|case
name|SCNMSG
case|:
case|case
name|SCNENC
case|:
if|if
condition|(
name|aud
condition|)
name|fputs
argument_list|(
name|scanl
argument_list|,
name|aud
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MHE
if|if
condition|(
name|mhe
condition|)
name|fputs
argument_list|(
name|scanl
argument_list|,
name|mhe
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* MHE */
if|if
condition|(
name|noisy
condition|)
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|msgnum
operator|++
operator|,
name|mp
operator|->
name|hghmsg
operator|++
expr_stmt|;
name|mp
operator|->
name|msgstats
index|[
name|msgnum
index|]
operator|=
name|EXISTS
expr_stmt|;
ifdef|#
directive|ifdef
name|TMA
if|if
condition|(
name|i
operator|==
name|SCNENC
condition|)
block|{
if|if
condition|(
name|mp
operator|->
name|lowsel
operator|==
literal|0
operator|||
name|mp
operator|->
name|lowsel
operator|>
name|msgnum
condition|)
name|mp
operator|->
name|lowsel
operator|=
name|msgnum
expr_stmt|;
if|if
condition|(
name|mp
operator|->
name|hghsel
operator|==
literal|0
operator|||
name|mp
operator|->
name|hghsel
operator|<
name|msgnum
condition|)
name|mp
operator|->
name|hghsel
operator|=
name|msgnum
expr_stmt|;
name|mp
operator|->
name|numsel
operator|++
expr_stmt|;
name|mp
operator|->
name|msgstats
index|[
name|msgnum
index|]
operator||=
name|SELECTED
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* TMA */
name|mp
operator|->
name|msgstats
index|[
name|msgnum
index|]
operator||=
name|UNSEEN
expr_stmt|;
name|mp
operator|->
name|msgflags
operator||=
name|SEQMOD
expr_stmt|;
continue|continue;
block|}
break|break;
block|}
ifdef|#
directive|ifdef
name|POP
block|}
endif|#
directive|endif
comment|/* POP */
ifndef|#
directive|ifndef
name|POP
if|if
condition|(
name|i
operator|<
literal|0
condition|)
block|{
comment|/* error } */
else|#
directive|else
if|if
condition|(
name|p
operator|<
literal|0
condition|)
block|{
comment|/* error */
endif|#
directive|endif
if|if
condition|(
name|locked
condition|)
ifdef|#
directive|ifdef
name|MAILGROUP
block|{
name|setgid
argument_list|(
name|return_gid
argument_list|)
expr_stmt|;
comment|/* Be sure we can unlock mail file */
endif|#
directive|endif
comment|/* MAILGROUP */
operator|(
name|void
operator|)
name|lkfclose
argument_list|(
name|in
argument_list|,
name|newmail
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MAILGROUP
name|setgid
argument_list|(
name|getgid
argument_list|()
argument_list|)
expr_stmt|;
comment|/* And then return us to normal privileges */
block|}
endif|#
directive|endif
comment|/* MAILGROUP */
else|else
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|in
argument_list|)
expr_stmt|;
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"failed"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|aud
condition|)
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|aud
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MHE
if|if
condition|(
name|mhe
condition|)
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|mhe
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* MHE */
if|if
condition|(
name|noisy
condition|)
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|POP
if|if
condition|(
name|host
operator|&&
name|file
condition|)
name|done
argument_list|(
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* POP */
comment|/*
comment|*/
ifdef|#
directive|ifdef
name|POP
if|if
condition|(
name|host
operator|==
name|NULL
condition|)
endif|#
directive|endif
comment|/* POP */
if|if
condition|(
name|trnflag
condition|)
block|{
if|if
condition|(
name|stat
argument_list|(
name|newmail
argument_list|,
operator|&
name|st
argument_list|)
operator|!=
name|NOTOK
operator|&&
name|s1
operator|.
name|st_mtime
operator|!=
name|st
operator|.
name|st_mtime
condition|)
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"new messages have arrived!\007"
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|(
name|i
operator|=
name|creat
argument_list|(
name|newmail
argument_list|,
literal|0600
argument_list|)
operator|)
operator|!=
name|NOTOK
condition|)
operator|(
name|void
operator|)
name|close
argument_list|(
name|i
argument_list|)
expr_stmt|;
else|else
name|admonish
argument_list|(
name|newmail
argument_list|,
literal|"error zero'ing"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|map_name
argument_list|(
name|newmail
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|noisy
condition|)
name|printf
argument_list|(
literal|"%s not zero'd\n"
argument_list|,
name|newmail
argument_list|)
expr_stmt|;
if|if
condition|(
name|msgnum
operator|==
name|hghnum
condition|)
name|admonish
argument_list|(
name|NULLCP
argument_list|,
literal|"no messages incorporated"
argument_list|)
expr_stmt|;
else|else
block|{
name|m_replace
argument_list|(
name|pfolder
argument_list|,
name|folder
argument_list|)
expr_stmt|;
if|if
condition|(
name|chgflag
condition|)
name|mp
operator|->
name|curmsg
operator|=
name|hghnum
operator|+
literal|1
expr_stmt|;
name|mp
operator|->
name|hghmsg
operator|=
name|msgnum
expr_stmt|;
if|if
condition|(
name|mp
operator|->
name|lowmsg
operator|==
literal|0
condition|)
name|mp
operator|->
name|lowmsg
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|chgflag
condition|)
comment|/* sigh... */
name|m_setcur
argument_list|(
name|mp
argument_list|,
name|mp
operator|->
name|curmsg
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|POP
if|if
condition|(
name|host
operator|==
name|NULL
condition|)
endif|#
directive|endif
comment|/* POP */
if|if
condition|(
name|locked
condition|)
ifdef|#
directive|ifdef
name|MAILGROUP
block|{
name|setgid
argument_list|(
name|return_gid
argument_list|)
expr_stmt|;
comment|/* Be sure we can unlock mail file */
endif|#
directive|endif
comment|/* MAILGROUP */
operator|(
name|void
operator|)
name|lkfclose
argument_list|(
name|in
argument_list|,
name|newmail
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MAILGROUP
name|setgid
argument_list|(
name|getgid
argument_list|()
argument_list|)
expr_stmt|;
comment|/* And then return us to normal privileges */
block|}
endif|#
directive|endif
comment|/* MAILGROUP */
else|else
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|in
argument_list|)
expr_stmt|;
name|m_setvis
argument_list|(
name|mp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|m_sync
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|m_update
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|TMA
if|if
condition|(
name|decflag
operator|&&
name|mp
operator|->
name|numsel
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|noisy
condition|)
block|{
name|printf
argument_list|(
literal|"\nIncorporating encrypted mail into %s...\n\n"
argument_list|,
name|folder
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
name|tmastart
argument_list|(
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|msgnum
operator|=
name|mp
operator|->
name|lowsel
init|;
name|msgnum
operator|<=
name|mp
operator|->
name|hghsel
condition|;
name|msgnum
operator|++
control|)
if|if
condition|(
name|mp
operator|->
name|msgstats
index|[
name|msgnum
index|]
operator|&
name|SELECTED
operator|&&
name|decipher
argument_list|(
name|msgnum
argument_list|)
operator|==
name|OK
condition|)
block|{
if|if
condition|(
operator|(
name|in
operator|=
name|fopen
argument_list|(
name|cp
operator|=
name|m_name
argument_list|(
name|msgnum
argument_list|)
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|admonish
argument_list|(
name|cp
argument_list|,
literal|"unable to open message"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|cp
argument_list|)
expr_stmt|;
continue|continue;
block|}
switch|switch
condition|(
name|scan
argument_list|(
name|in
argument_list|,
name|msgnum
argument_list|,
literal|0
argument_list|,
name|nfs
argument_list|,
name|width
argument_list|,
name|msgnum
operator|==
name|mp
operator|->
name|curmsg
argument_list|,
literal|1
argument_list|,
comment|/* check UNSEEN? */
literal|0
argument_list|,
name|fstat
argument_list|(
name|fileno
argument_list|(
name|in
argument_list|)
argument_list|,
operator|&
name|st
argument_list|)
operator|!=
name|NOTOK
condition|?
operator|(
name|long
operator|)
name|st
operator|.
name|st_size
else|:
literal|0L
argument_list|,
name|noisy
argument_list|)
condition|)
block|{
case|case
name|SCNEOF
case|:
name|printf
argument_list|(
literal|"%*d  empty\n"
argument_list|,
name|DMAXFOLDER
argument_list|,
name|msgnum
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|in
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|cp
argument_list|)
expr_stmt|;
block|}
name|tmastop
argument_list|()
expr_stmt|;
if|if
condition|(
name|noisy
condition|)
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* TMA */
name|done
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/*
comment|*/
ifdef|#
directive|ifdef
name|POP
name|void
name|done
parameter_list|(
name|status
parameter_list|)
name|int
name|status
decl_stmt|;
block|{
if|if
condition|(
name|file
operator|&&
name|pd
operator|!=
name|NOTOK
condition|)
operator|(
name|void
operator|)
name|mbx_close
argument_list|(
name|file
argument_list|,
name|pd
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|status
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* POP */
comment|/*
comment|*/
ifdef|#
directive|ifdef
name|MF
name|get_uucp_mail
argument_list|()
block|{
name|int
name|child_id
decl_stmt|;
name|char
name|buffer
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|struct
name|stat
name|st
decl_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|"%s/%s"
argument_list|,
name|UUCPDIR
argument_list|,
name|UUCPFIL
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|buffer
argument_list|,
operator|&
name|st
argument_list|)
operator|==
name|NOTOK
operator|||
name|st
operator|.
name|st_size
operator|==
literal|0
condition|)
return|return;
switch|switch
condition|(
name|child_id
operator|=
name|vfork
argument_list|()
condition|)
block|{
case|case
name|NOTOK
case|:
name|admonish
argument_list|(
literal|"fork"
argument_list|,
literal|"unable to"
argument_list|)
expr_stmt|;
break|break;
case|case
name|OK
case|:
name|execlp
argument_list|(
name|umincproc
argument_list|,
name|r1bindex
argument_list|(
name|umincproc
argument_list|,
literal|'/'
argument_list|)
argument_list|,
name|NULLCP
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"unable to exec "
argument_list|)
expr_stmt|;
name|perror
argument_list|(
name|umincproc
argument_list|)
expr_stmt|;
name|_exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
default|default:
operator|(
name|void
operator|)
name|pidXwait
argument_list|(
name|child_id
argument_list|,
name|umincproc
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
endif|#
directive|endif
comment|/* MF */
comment|/*
comment|*/
ifdef|#
directive|ifdef
name|POP
specifier|static
name|int
name|pop_action
parameter_list|(
name|s
parameter_list|)
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
block|{
name|fprintf
argument_list|(
name|pf
argument_list|,
literal|"%s\n"
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|stop
operator|+=
name|strlen
argument_list|(
name|s
argument_list|)
operator|+
literal|1
expr_stmt|;
block|}
specifier|static
name|int
name|pop_pack
parameter_list|(
name|s
parameter_list|)
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
block|{
specifier|register
name|int
name|j
decl_stmt|;
name|char
name|buffer
index|[
name|BUFSIZ
index|]
decl_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|"%s\n"
argument_list|,
name|s
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
operator|(
name|j
operator|=
name|stringdex
argument_list|(
name|mmdlm1
argument_list|,
name|buffer
argument_list|)
operator|)
operator|>=
literal|0
condition|;
name|buffer
index|[
name|j
index|]
operator|++
control|)
continue|continue;
for|for
control|(
name|j
operator|=
literal|0
init|;
operator|(
name|j
operator|=
name|stringdex
argument_list|(
name|mmdlm2
argument_list|,
name|buffer
argument_list|)
operator|)
operator|>=
literal|0
condition|;
name|buffer
index|[
name|j
index|]
operator|++
control|)
continue|continue;
name|fputs
argument_list|(
name|buffer
argument_list|,
name|pf
argument_list|)
expr_stmt|;
name|size
operator|+=
name|strlen
argument_list|(
name|buffer
argument_list|)
operator|+
literal|1
expr_stmt|;
block|}
specifier|static
name|int
name|map_count
parameter_list|()
block|{
name|int
name|md
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
name|struct
name|drop
name|d
decl_stmt|;
name|struct
name|stat
name|st
decl_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|file
argument_list|,
operator|&
name|st
argument_list|)
operator|==
name|NOTOK
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|(
name|md
operator|=
name|open
argument_list|(
name|cp
operator|=
name|map_name
argument_list|(
name|file
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
name|NOTOK
operator|||
name|map_chk
argument_list|(
name|cp
argument_list|,
name|md
argument_list|,
operator|&
name|d
argument_list|,
operator|(
name|long
operator|)
name|st
operator|.
name|st_size
argument_list|,
literal|1
argument_list|)
condition|)
block|{
if|if
condition|(
name|md
operator|!=
name|NOTOK
condition|)
operator|(
name|void
operator|)
name|close
argument_list|(
name|md
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
operator|(
name|void
operator|)
name|close
argument_list|(
name|md
argument_list|)
expr_stmt|;
return|return
operator|(
name|d
operator|.
name|d_id
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* POP */
end_comment

end_unit

