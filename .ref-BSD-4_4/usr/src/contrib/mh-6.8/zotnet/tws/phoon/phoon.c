begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* phoon - show the phase of the moon  ver  date   who remarks --- ------- --- ------------------------------------------------------------- 01A 08nov86 JP  Translated from the ratfor version of 12nov85, which itself                   was translated from the Pascal version of 05apr79.  Copyright (C) 1986 by Jeffrey A. Poskanzer.  Permission to use, copy, modify, and distribute this software and its documentation for any purpose and without fee is hereby granted, provided that this copyright notice appear in all copies and in all supporting documentation.  No representation is made about the suitability of this software for any purpose.  It is provided "as is" without express or implied warranty.  */
end_comment

begin_decl_stmt
specifier|static
name|char
name|copyright
index|[]
init|=
literal|"\nCopyright (C) 1986 by Jeffrey A. Poskanzer.\n"
decl_stmt|;
end_decl_stmt

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<math.h>
end_include

begin_include
include|#
directive|include
file|"tws.h"
end_include

begin_comment
comment|/* Global defines and declarations. */
end_comment

begin_define
define|#
directive|define
name|SECSPERMINUTE
value|60
end_define

begin_define
define|#
directive|define
name|SECSPERHOUR
value|(60 * SECSPERMINUTE)
end_define

begin_define
define|#
directive|define
name|SECSPERDAY
value|(24 * SECSPERHOUR)
end_define

begin_define
define|#
directive|define
name|PI
value|3.14159
end_define

begin_define
define|#
directive|define
name|NUMLINES
value|23
end_define

begin_define
define|#
directive|define
name|ASPECTRATIO
value|0.5
end_define

begin_define
define|#
directive|define
name|MOONSTARTCOL
value|18
end_define

begin_define
define|#
directive|define
name|QUARTERLITLEN
value|16
end_define

begin_define
define|#
directive|define
name|QUARTERLITLENPLUSONE
value|17
end_define

begin_comment
comment|/* Main program. */
end_comment

begin_expr_stmt
expr|main
operator|(
name|argc
operator|,
name|argv
operator|,
name|envp
operator|)
name|int
name|argc
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|char
modifier|*
name|argv
index|[]
decl_stmt|,
modifier|*
name|envp
index|[]
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|tws
name|t
decl_stmt|,
modifier|*
name|twp
decl_stmt|;
name|char
name|buf
index|[
literal|100
index|]
decl_stmt|;
comment|/* Figure out what date and time to use. */
if|if
condition|(
name|argc
operator|==
literal|1
condition|)
block|{
comment|/* No arguments present - use the current date and time. */
name|twscopy
argument_list|(
operator|&
name|t
argument_list|,
name|dtwstime
argument_list|( )
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|argc
operator|==
literal|2
operator|||
name|argc
operator|==
literal|3
operator|||
name|argc
operator|==
literal|4
condition|)
block|{
comment|/* One, two, or three args - use them. */
name|strcpy
argument_list|(
name|buf
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|argc
operator|>
literal|2
condition|)
block|{
name|strcat
argument_list|(
name|buf
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|buf
argument_list|,
name|argv
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|argc
operator|>
literal|3
condition|)
block|{
name|strcat
argument_list|(
name|buf
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|buf
argument_list|,
name|argv
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
block|}
block|}
name|twp
operator|=
name|dparsetime
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|twp
operator|==
name|NULL
operator|||
name|twp
operator|->
name|tw_flags
operator|&
name|TW_JUNK
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"illegal date/time: %s\n"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|twscopy
argument_list|(
operator|&
name|t
argument_list|,
name|twp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Too many args! */
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"usage:  %s  [<date/time> ]\n"
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Pseudo-randomly decide what the moon is made of, and print it. */
if|if
condition|(
name|twclock
argument_list|(
name|dtwstime
argument_list|( )
argument_list|)
operator|%
literal|17
operator|==
literal|3
condition|)
name|putmoon
argument_list|(
operator|&
name|t
argument_list|,
literal|"GREENCHEESE"
argument_list|)
expr_stmt|;
else|else
name|putmoon
argument_list|(
operator|&
name|t
argument_list|,
literal|"@"
argument_list|)
expr_stmt|;
comment|/* All done. */
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|putmoon
argument_list|(
argument|t
argument_list|,
argument|atfiller
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|tws
modifier|*
name|t
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|atfiller
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|tws
name|twsanewmoon
decl_stmt|;
name|long
name|secsynodic
init|=
literal|29
operator|*
name|SECSPERDAY
operator|+
literal|12
operator|*
name|SECSPERHOUR
operator|+
literal|44
operator|*
name|SECSPERMINUTE
operator|+
literal|3
decl_stmt|;
name|long
name|secdiff
decl_stmt|,
name|secphase
decl_stmt|;
name|int
name|atflrlen
decl_stmt|,
name|atflridx
decl_stmt|,
name|lin
decl_stmt|,
name|col
decl_stmt|,
name|midlin
decl_stmt|,
name|qlitidx
decl_stmt|;
name|float
name|angphase
decl_stmt|,
name|mcap
decl_stmt|,
name|yrad
decl_stmt|,
name|xrad
decl_stmt|,
name|y
decl_stmt|,
name|xright
decl_stmt|,
name|xleft
decl_stmt|;
name|int
name|colright
decl_stmt|,
name|colleft
decl_stmt|,
name|i
decl_stmt|;
name|char
name|c
decl_stmt|;
specifier|static
name|char
name|background
index|[
name|NUMLINES
index|]
index|[
literal|47
index|]
init|=
block|{
literal|"                 .------------.                "
block|,
literal|"             .--'  o     . .   `--.            "
block|,
literal|"          .-'   .    O   .       . `-.         "
block|,
literal|"       .-'@   @@@@@@@   .  @@@@@      `-.      "
block|,
literal|"      /@@@  @@@@@@@@@@@   @@@@@@@   .    \\     "
block|,
literal|"    ./    o @@@@@@@@@@@   @@@@@@@       . \\.   "
block|,
literal|"   /@@  o   @@@@@@@@@@@.   @@@@@@@   O      \\  "
block|,
literal|"  /@@@@   .   @@@@@@@o    @@@@@@@@@@     @@@ \\ "
block|,
literal|"  |@@@@@               . @@@@@@@@@@@@@ o @@@@| "
block|,
literal|" /@@@@@  O  `.-./  .      @@@@@@@@@@@@    @@  \\"
block|,
literal|" | @@@@    --`-'       o     @@@@@@@@ @@@@    |"
block|,
literal|" |@ @@@        `    o      .  @@   . @@@@@@@  |"
block|,
literal|" |       @@            .-.     @@@   @@@@@@@  |"
block|,
literal|" \\  . o        @@@     `-'   . @@@@   @@@@  o /"
block|,
literal|"  |      @@   @@@@@ .           @@   .       | "
block|,
literal|"  \\     @@@@  @\\@@    /  .  O    .     o   . / "
block|,
literal|"   \\  o  @@     \\ \\  /         .    .       /  "
block|,
literal|"    `\\     .    .\\.-.___   .      .   .-. /'   "
block|,
literal|"      \\           `-'                `-' /     "
block|,
literal|"       `-.   o   / |     o    O   .   .-'      "
block|,
literal|"          `-.   /     .       .    .-'         "
block|,
literal|"             `--.       .      .--'            "
block|,
literal|"                 `------------'                "
block|}
decl_stmt|;
specifier|static
name|char
name|qlits
index|[
literal|8
index|]
index|[
literal|16
index|]
init|=
block|{
literal|"New Moon +     "
block|,
literal|"First Quarter +"
block|,
literal|"Full Moon +    "
block|,
literal|"Last Quarter + "
block|,
literal|"First Quarter -"
block|,
literal|"Full Moon -    "
block|,
literal|"Last Quarter - "
block|,
literal|"New Moon -     "
block|}
decl_stmt|;
comment|/* Find the length of the atfiller string. */
name|atflrlen
operator|=
name|strlen
argument_list|(
name|atfiller
argument_list|)
expr_stmt|;
comment|/* Convert a new moon date from a string to a tws. */
name|twscopy
argument_list|(
operator|&
name|twsanewmoon
argument_list|,
name|dparsetime
argument_list|(
literal|"05jan81 23:24:00 PST"
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Subtract the new moon date from the desired date to get the interval        since the new moon. */
name|secdiff
operator|=
name|twsubtract
argument_list|(
name|t
argument_list|,
operator|&
name|twsanewmoon
argument_list|)
expr_stmt|;
comment|/* Figure out the phase - the interval since the last new moon. */
name|secphase
operator|=
name|secdiff
operator|%
name|secsynodic
expr_stmt|;
if|if
condition|(
name|secphase
operator|<
literal|0L
condition|)
name|secphase
operator|+=
name|secsynodic
expr_stmt|;
comment|/* fucking mathematician language designers */
name|angphase
operator|=
operator|(
name|float
operator|)
name|secphase
operator|/
operator|(
name|float
operator|)
name|secsynodic
operator|*
literal|2.0
operator|*
name|PI
expr_stmt|;
name|mcap
operator|=
operator|-
name|cos
argument_list|(
name|angphase
argument_list|)
expr_stmt|;
comment|/* Figure out how big the moon is. */
name|yrad
operator|=
name|NUMLINES
operator|/
literal|2.0
expr_stmt|;
name|xrad
operator|=
name|yrad
operator|/
name|ASPECTRATIO
expr_stmt|;
comment|/* Figure out some other random stuff. */
name|midlin
operator|=
name|NUMLINES
operator|/
literal|2
expr_stmt|;
name|qlitidx
operator|=
name|angphase
operator|/
name|PI
operator|*
literal|2.0
expr_stmt|;
comment|/* Now output the moon, a slice at a time. */
name|atflridx
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|lin
operator|=
literal|0
init|;
name|lin
operator|<
name|NUMLINES
condition|;
name|lin
operator|=
name|lin
operator|+
literal|1
control|)
block|{
comment|/* Compute the edges of this slice. */
name|y
operator|=
name|lin
operator|+
literal|0.5
operator|-
name|yrad
expr_stmt|;
name|xright
operator|=
name|xrad
operator|*
name|sqrt
argument_list|(
literal|1.0
operator|-
operator|(
name|y
operator|*
name|y
operator|)
operator|/
operator|(
name|yrad
operator|*
name|yrad
operator|)
argument_list|)
expr_stmt|;
name|xleft
operator|=
operator|-
name|xright
expr_stmt|;
if|if
condition|(
name|angphase
operator|>=
literal|0.0
operator|&&
name|angphase
operator|<
name|PI
condition|)
name|xleft
operator|=
name|mcap
operator|*
name|xleft
expr_stmt|;
else|else
name|xright
operator|=
name|mcap
operator|*
name|xright
expr_stmt|;
name|colleft
operator|=
call|(
name|int
call|)
argument_list|(
name|xrad
operator|+
literal|0.5
argument_list|)
operator|+
call|(
name|int
call|)
argument_list|(
name|xleft
operator|+
literal|0.5
argument_list|)
expr_stmt|;
name|colright
operator|=
call|(
name|int
call|)
argument_list|(
name|xrad
operator|+
literal|0.5
argument_list|)
operator|+
call|(
name|int
call|)
argument_list|(
name|xright
operator|+
literal|0.5
argument_list|)
expr_stmt|;
comment|/* Now output the slice. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|colleft
condition|;
name|i
operator|++
control|)
name|putchar
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
for|for
control|(
name|col
operator|=
name|colleft
init|;
name|col
operator|<=
name|colright
condition|;
name|col
operator|=
name|col
operator|+
literal|1
control|)
if|if
condition|(
operator|(
name|c
operator|=
name|background
index|[
name|lin
index|]
index|[
name|col
index|]
operator|)
operator|!=
literal|'@'
condition|)
name|putchar
argument_list|(
name|c
argument_list|)
expr_stmt|;
else|else
block|{
name|putchar
argument_list|(
name|atfiller
index|[
name|atflridx
index|]
argument_list|)
expr_stmt|;
name|atflridx
operator|=
operator|(
name|atflridx
operator|+
literal|1
operator|)
operator|%
name|atflrlen
expr_stmt|;
block|}
comment|/* Output the end-of-line information, if any. */
if|if
condition|(
name|lin
operator|==
name|midlin
operator|-
literal|2
condition|)
block|{
name|putchar
argument_list|(
literal|'\t'
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'\t'
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|qlits
index|[
name|qlitidx
index|]
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|lin
operator|==
name|midlin
operator|-
literal|1
condition|)
block|{
name|putchar
argument_list|(
literal|'\t'
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'\t'
argument_list|)
expr_stmt|;
name|putseconds
argument_list|(
name|secphase
operator|%
operator|(
name|secsynodic
operator|/
literal|4
operator|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|lin
operator|==
name|midlin
condition|)
block|{
name|putchar
argument_list|(
literal|'\t'
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'\t'
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|qlits
index|[
name|qlitidx
operator|+
literal|4
index|]
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|lin
operator|==
name|midlin
operator|+
literal|1
condition|)
block|{
name|putchar
argument_list|(
literal|'\t'
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'\t'
argument_list|)
expr_stmt|;
name|putseconds
argument_list|(
operator|(
name|secsynodic
operator|-
name|secphase
operator|)
operator|%
operator|(
name|secsynodic
operator|/
literal|4
operator|)
argument_list|)
expr_stmt|;
block|}
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|putseconds
argument_list|(
argument|secs
argument_list|)
end_macro

begin_decl_stmt
name|long
name|secs
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|long
name|days
decl_stmt|,
name|hours
decl_stmt|,
name|minutes
decl_stmt|;
name|days
operator|=
name|secs
operator|/
name|SECSPERDAY
expr_stmt|;
name|secs
operator|=
name|secs
operator|-
name|days
operator|*
name|SECSPERDAY
expr_stmt|;
name|hours
operator|=
name|secs
operator|/
name|SECSPERHOUR
expr_stmt|;
name|secs
operator|=
name|secs
operator|-
name|hours
operator|*
name|SECSPERHOUR
expr_stmt|;
name|minutes
operator|=
name|secs
operator|/
name|SECSPERMINUTE
expr_stmt|;
name|secs
operator|=
name|secs
operator|-
name|minutes
operator|*
name|SECSPERMINUTE
expr_stmt|;
name|printf
argument_list|(
literal|"%ld %2ld:%02ld:%02ld"
argument_list|,
name|days
argument_list|,
name|hours
argument_list|,
name|minutes
argument_list|,
name|secs
argument_list|)
expr_stmt|;
block|}
end_block

end_unit

