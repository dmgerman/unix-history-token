begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* C Compatible Compiler Preprocessor (CCCP) Copyright (C) 1986, Free Software Foundation, Inc.                     Written by Paul Rubin, June 1986  		       NO WARRANTY    BECAUSE THIS PROGRAM IS LICENSED FREE OF CHARGE, WE PROVIDE ABSOLUTELY NO WARRANTY, TO THE EXTENT PERMITTED BY APPLICABLE STATE LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING, FREE SOFTWARE FOUNDATION, INC, RICHARD M. STALLMAN AND/OR OTHER PARTIES PROVIDE THIS PROGRAM "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING, REPAIR OR CORRECTION.   IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW WILL RICHARD M. STALLMAN, THE FREE SOFTWARE FOUNDATION, INC., AND/OR ANY OTHER PARTY WHO MAY MODIFY AND REDISTRIBUTE THIS PROGRAM AS PERMITTED BELOW, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY LOST PROFITS, LOST MONIES, OR OTHER SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS) THIS PROGRAM, EVEN IF YOU HAVE BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES, OR FOR ANY CLAIM BY ANY OTHER PARTY.  		GENERAL PUBLIC LICENSE TO COPY    1. You may copy and distribute verbatim copies of this source file as you receive it, in any medium, provided that you conspicuously and appropriately publish on each copy a valid copyright notice "Copyright (C) 1986 Free Software Foundation"; and include following the copyright notice a verbatim copy of the above disclaimer of warranty and of this License.    2. You may modify your copy or copies of this source file or any portion of it, and copy and distribute such modifications under the terms of Paragraph 1 above, provided that you also do the following:      a) cause the modified files to carry prominent notices stating     that you changed the files and the date of any change; and      b) cause the whole of any work that you distribute or publish,     that in whole or in part contains or is a derivative of this     program or any part thereof, to be licensed at no charge to all     third parties on terms identical to those contained in this     License Agreement (except that you may choose to grant more extensive     warranty protection to some or all third parties, at your option).      c) You may charge a distribution fee for the physical act of     transferring a copy, and you may at your option offer warranty     protection in exchange for a fee.  Mere aggregation of another unrelated program with this program (or its derivative) on a volume of a storage or distribution medium does not bring the other program under the scope of these terms.    3. You may copy and distribute this program (or a portion or derivative of it, under Paragraph 2) in object code or executable form under the terms of Paragraphs 1 and 2 above provided that you also do one of the following:      a) accompany it with the complete corresponding machine-readable     source code, which must be distributed under the terms of     Paragraphs 1 and 2 above; or,      b) accompany it with a written offer, valid for at least three     years, to give any third party free (except for a nominal     shipping charge) a complete machine-readable copy of the     corresponding source code, to be distributed under the terms of     Paragraphs 1 and 2 above; or,      c) accompany it with the information you received as to where the     corresponding source code may be obtained.  (This alternative is     allowed only for noncommercial distribution and only if you     received the program in object code or executable form alone.)  For an executable file, complete source code means all the source code for all modules it contains; but, as a special exception, it need not include source code for modules which are standard libraries that accompany the operating system on which the executable file runs.    4. You may not copy, sublicense, distribute or transfer this program except as expressly provided under this License Agreement.  Any attempt otherwise to copy, sublicense, distribute or transfer this program is void and your rights to use the program under this License agreement shall be automatically terminated.  However, parties who have received computer software programs from you with this License Agreement will not have their licenses terminated so long as such parties remain in full compliance.   In other words, you are welcome to use, share and improve this program.  You are forbidden to forbid anyone else to use, share and improve  what you give them.   Help stamp out software-hoarding!  */
end_comment

begin_typedef
typedef|typedef
name|unsigned
name|char
name|U_CHAR
typedef|;
end_typedef

begin_ifdef
ifdef|#
directive|ifdef
name|EMACS
end_ifdef

begin_define
define|#
directive|define
name|NO_SHORTNAMES
end_define

begin_include
include|#
directive|include
file|"../src/config.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|static
end_ifdef

begin_undef
undef|#
directive|undef
name|static
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|open
end_ifdef

begin_undef
undef|#
directive|undef
name|open
end_undef

begin_undef
undef|#
directive|undef
name|close
end_undef

begin_undef
undef|#
directive|undef
name|read
end_undef

begin_undef
undef|#
directive|undef
name|write
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* open */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* EMACS */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|USG
end_ifndef

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_comment
comment|/* for __DATE__ and __TIME__ */
end_comment

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|index
value|strchr
end_define

begin_define
define|#
directive|define
name|rindex
value|strrchr
end_define

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* USG */
end_comment

begin_decl_stmt
name|void
name|bcopy
argument_list|()
decl_stmt|,
name|bzero
argument_list|()
decl_stmt|;
end_decl_stmt

begin_function_decl
name|int
name|bcmp
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|char
modifier|*
name|xmalloc
argument_list|()
decl_stmt|,
modifier|*
name|xrealloc
argument_list|()
decl_stmt|,
modifier|*
name|xcalloc
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|fatal
argument_list|()
decl_stmt|,
name|pfatal_with_name
argument_list|()
decl_stmt|,
name|perror_with_name
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|progname
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|FATAL_EXIT_CODE
value|33
end_define

begin_comment
comment|/* gnu cc command understands this */
end_comment

begin_struct
struct|struct
name|directory_stack
block|{
name|struct
name|directory_stack
modifier|*
name|next
decl_stmt|;
name|char
modifier|*
name|fname
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* #include "file" starts with the first entry in the stack */
end_comment

begin_comment
comment|/* #include<file> starts with the second. */
end_comment

begin_comment
comment|/* -I directories are added after the first */
end_comment

begin_decl_stmt
name|struct
name|directory_stack
name|default_includes
index|[
literal|2
index|]
init|=
block|{
block|{
operator|&
name|default_includes
index|[
literal|1
index|]
block|,
literal|"."
block|}
block|,
block|{
literal|0
block|,
literal|"/usr/include"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|directory_stack
modifier|*
name|include
init|=
operator|&
name|default_includes
index|[
literal|0
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|max_include_len
init|=
literal|14
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* strlen (default_include) + 2 							(for / and null) */
end_comment

begin_decl_stmt
name|char
name|STDIN_FILE
index|[]
init|=
literal|""
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Empty, like real cpp */
end_comment

begin_decl_stmt
name|int
name|put_out_comments
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* JF non-zero means leave comments in the 				   output file.  Used by lint */
end_comment

begin_comment
comment|/* table to tell if char can be part of a C identifier. */
end_comment

begin_decl_stmt
name|U_CHAR
name|is_idchar
index|[
literal|256
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* table to tell if char can be first char of a c identifier. */
end_comment

begin_decl_stmt
name|U_CHAR
name|is_idstart
index|[
literal|256
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* table to tell if c is horizontal space.  isspace() thinks that    newline is space; this is not a good idea for this program. */
end_comment

begin_decl_stmt
name|U_CHAR
name|is_hor_space
index|[
literal|256
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* I/O buffer structure.  Ought to be used for the output file too.    These are also used when there is no file present, for example,    when rescanning a definition.  Then, the fname field is null. */
end_comment

begin_define
define|#
directive|define
name|INPUT_STACK_MAX
value|100
end_define

begin_struct
struct|struct
name|file_buf
block|{
name|struct
name|infile
modifier|*
name|next
decl_stmt|;
comment|/* for making stacks of file ptrs */
name|char
modifier|*
name|fname
decl_stmt|;
name|int
name|lineno
decl_stmt|;
name|int
name|length
decl_stmt|;
name|U_CHAR
modifier|*
name|buf
decl_stmt|;
name|U_CHAR
modifier|*
name|bufp
decl_stmt|;
block|}
name|instack
index|[
name|INPUT_STACK_MAX
index|]
struct|;
end_struct

begin_decl_stmt
name|int
name|indepth
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_typedef
typedef|typedef
name|struct
name|file_buf
name|FILE_BUF
typedef|;
end_typedef

begin_comment
comment|/* The output buffer.  Its LENGTH field is the amount of room allocated    for the buffer, not the number of chars actually present.  To get    that, subtract outbuf.buf from outbuf.bufp. */
end_comment

begin_define
define|#
directive|define
name|OUTBUF_SIZE
value|10
end_define

begin_comment
comment|/* initial size of output buffer */
end_comment

begin_decl_stmt
name|FILE_BUF
name|outbuf
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Structure allocated for every #define.  For a simple replacement    such as    	#define foo bar ,    nargs = -1, the `pattern' list is null, and the expansion is just    the replacement text.  Nargs = 0 means a real macro with no args,    e.g.,        #define getchar() getc(stdin) .    When there are args, the expansion is the replacement text with the    args squashed out, and the reflist is a list describing how to    build the output from the input: e.g., "3 chars, then the 1st arg,    then 9 chars, then the 3rd arg, then 0 chars, then the 2nd arg".    The chars here come from the expansion.  Thus, for any definition    d , strlen(d->expansion) should equal the sum of all the    d->pattern->nchars.  Note that the list can be arbitrarily long---    its length depends on the number of times the arguements appear in    the replacement text, not how many args there are.  Example:    #define f(x) x+x+x+x+x+x+x would have replacement text "++++++" and    pattern list      { (0, 1), (1, 1), (1, 1), ..., (1, 1), NULL }    where (x, y) means (nchars, argno). */
end_comment

begin_typedef
typedef|typedef
name|struct
name|definition
name|DEFINITION
typedef|;
end_typedef

begin_struct
struct|struct
name|definition
block|{
name|int
name|nargs
decl_stmt|;
name|int
name|length
decl_stmt|;
comment|/* length of expansion string */
name|U_CHAR
modifier|*
name|expansion
decl_stmt|;
struct|struct
name|reflist
block|{
name|struct
name|reflist
modifier|*
name|next
decl_stmt|;
name|int
name|nchars
decl_stmt|;
name|int
name|argno
decl_stmt|;
block|}
modifier|*
name|pattern
struct|;
block|}
struct|;
end_struct

begin_comment
comment|/* different kinds of things that can appear in the value field    of a hash node.  Actually, this may be useless now. */
end_comment

begin_union
union|union
name|hashval
block|{
name|int
name|ival
decl_stmt|;
name|char
modifier|*
name|cpval
decl_stmt|;
name|DEFINITION
modifier|*
name|defn
decl_stmt|;
block|}
union|;
end_union

begin_comment
comment|/* The structure of a node in the hash table.  The hash table    has entries for all tokens defined by #define commands (type T_MACRO),    plus some special tokens like __LINE__ (these each have their own    type, and the appropriate code is run when that type of node is seen.    It does not contain control words like "#define", which are recognized    by a separate piece of code. */
end_comment

begin_typedef
typedef|typedef
name|struct
name|hashnode
name|HASHNODE
typedef|;
end_typedef

begin_struct
struct|struct
name|hashnode
block|{
name|HASHNODE
modifier|*
name|next
decl_stmt|;
comment|/* double links for easy deletion */
name|HASHNODE
modifier|*
name|prev
decl_stmt|;
name|HASHNODE
modifier|*
modifier|*
name|bucket_hdr
decl_stmt|;
comment|/* also, a back pointer to this node's hash 				   chain is kept, in case the node is the head 				   of the chain and gets deleted. */
name|int
name|type
decl_stmt|;
comment|/* type of special token */
name|int
name|length
decl_stmt|;
comment|/* length of token, for quick comparison */
name|U_CHAR
modifier|*
name|name
decl_stmt|;
comment|/* the actual name */
name|union
name|hashval
name|value
decl_stmt|;
comment|/* pointer to expansion, or whatever */
block|}
struct|;
end_struct

begin_function_decl
name|HASHNODE
modifier|*
name|install
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* different flavors of hash nodes --- also used in keyword table */
end_comment

begin_define
define|#
directive|define
name|T_DEFINE
value|1
end_define

begin_comment
comment|/* the "#define" keyword */
end_comment

begin_define
define|#
directive|define
name|T_INCLUDE
value|2
end_define

begin_comment
comment|/* the "#include" keyword */
end_comment

begin_define
define|#
directive|define
name|T_IFDEF
value|3
end_define

begin_comment
comment|/* the "#ifdef" keyword */
end_comment

begin_define
define|#
directive|define
name|T_IF
value|4
end_define

begin_comment
comment|/* the "#if" keyword */
end_comment

begin_define
define|#
directive|define
name|T_EXPAND
value|5
end_define

begin_comment
comment|/* argument to be expanded (now unused) */
end_comment

begin_define
define|#
directive|define
name|T_MACRO
value|6
end_define

begin_comment
comment|/* macro defined by "#define" */
end_comment

begin_define
define|#
directive|define
name|T_ELSE
value|7
end_define

begin_comment
comment|/* "#else" */
end_comment

begin_define
define|#
directive|define
name|T_PRAGMA
value|8
end_define

begin_comment
comment|/* "#pragma" */
end_comment

begin_define
define|#
directive|define
name|T_ELIF
value|9
end_define

begin_comment
comment|/* "#else" */
end_comment

begin_define
define|#
directive|define
name|T_UNDEF
value|10
end_define

begin_comment
comment|/* "#undef" */
end_comment

begin_define
define|#
directive|define
name|T_LINE
value|11
end_define

begin_comment
comment|/* "#line" */
end_comment

begin_define
define|#
directive|define
name|T_ERROR
value|12
end_define

begin_comment
comment|/* "#error" */
end_comment

begin_define
define|#
directive|define
name|T_IFNDEF
value|13
end_define

begin_comment
comment|/* "#ifndef"; forgot this earlier */
end_comment

begin_define
define|#
directive|define
name|T_ENDIF
value|14
end_define

begin_comment
comment|/* "#endif" */
end_comment

begin_define
define|#
directive|define
name|T_SPECLINE
value|15
end_define

begin_comment
comment|/* special symbol "__LINE__" */
end_comment

begin_define
define|#
directive|define
name|T_DATE
value|16
end_define

begin_comment
comment|/* "__DATE__" */
end_comment

begin_define
define|#
directive|define
name|T_FILE
value|17
end_define

begin_comment
comment|/* "__FILE__" */
end_comment

begin_define
define|#
directive|define
name|T_TIME
value|18
end_define

begin_comment
comment|/* "__TIME__" */
end_comment

begin_define
define|#
directive|define
name|T_SPEC_DEFINED
value|19
end_define

begin_comment
comment|/* special macro for use in #if statements */
end_comment

begin_comment
comment|/* some more different types will be needed --- no longer bloody likely */
end_comment

begin_decl_stmt
name|int
name|do_define
argument_list|()
decl_stmt|,
name|do_line
argument_list|()
decl_stmt|,
name|do_include
argument_list|()
decl_stmt|,
name|do_undef
argument_list|()
decl_stmt|,
name|do_error
argument_list|()
decl_stmt|,
name|do_pragma
argument_list|()
decl_stmt|,
name|do_if
argument_list|()
decl_stmt|,
name|do_xifdef
argument_list|()
decl_stmt|,
name|do_else
argument_list|()
decl_stmt|,
name|do_elif
argument_list|()
decl_stmt|,
name|do_endif
argument_list|()
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* table of control words, along with code to execute when the keyword    is seen.  For now, it is searched linearly, so put the most frequently    found keywords at the beginning of the list. */
end_comment

begin_struct
struct|struct
name|keyword_table
block|{
name|int
name|length
decl_stmt|;
name|int
function_decl|(
modifier|*
name|func
function_decl|)
parameter_list|()
function_decl|;
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|type
decl_stmt|;
block|}
name|keyword_table
index|[]
init|=
block|{
block|{
literal|6
block|,
name|do_define
block|,
literal|"define"
block|,
name|T_DEFINE
block|}
block|,
block|{
literal|4
block|,
name|do_line
block|,
literal|"line"
block|,
name|T_LINE
block|}
block|,
block|{
literal|7
block|,
name|do_include
block|,
literal|"include"
block|,
name|T_INCLUDE
block|}
block|,
block|{
literal|5
block|,
name|do_undef
block|,
literal|"undef"
block|,
name|T_UNDEF
block|}
block|,
block|{
literal|5
block|,
name|do_error
block|,
literal|"error"
block|,
name|T_ERROR
block|}
block|,
block|{
literal|2
block|,
name|do_if
block|,
literal|"if"
block|,
name|T_IF
block|}
block|,
block|{
literal|5
block|,
name|do_xifdef
block|,
literal|"ifdef"
block|,
name|T_IFDEF
block|}
block|,
block|{
literal|6
block|,
name|do_xifdef
block|,
literal|"ifndef"
block|,
name|T_IFNDEF
block|}
block|,
block|{
literal|4
block|,
name|do_else
block|,
literal|"else"
block|,
name|T_ELSE
block|}
block|,
block|{
literal|4
block|,
name|do_elif
block|,
literal|"elif"
block|,
name|T_ELIF
block|}
block|,
block|{
literal|5
block|,
name|do_endif
block|,
literal|"endif"
block|,
name|T_ENDIF
block|}
block|,
block|{
literal|6
block|,
name|do_pragma
block|,
literal|"pragma"
block|,
name|T_PRAGMA
block|}
block|,
block|{
operator|-
literal|1
block|,
literal|0
block|,
literal|""
block|,
operator|-
literal|1
block|}
block|, }
struct|;
end_struct

begin_comment
comment|/* Some definitions for the hash table.  The hash function MUST be    computed as shown in hashf() below.  That is because the rescan    loop computes the hash value `on the fly' for most tokens,    in order to avoid the overhead of a lot of procedure calls to    the hashf() function.  Hashf() only exists for the sake of    politeness, for use when speed isn't so important. */
end_comment

begin_define
define|#
directive|define
name|HASHSIZE
value|1009
end_define

begin_decl_stmt
name|HASHNODE
modifier|*
name|hashtab
index|[
name|HASHSIZE
index|]
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|HASHSTEP
parameter_list|(
name|old
parameter_list|,
name|c
parameter_list|)
value|((old<< 1) + c)
end_define

begin_define
define|#
directive|define
name|MAKE_POS
parameter_list|(
name|v
parameter_list|)
value|(v& ~0x80000000)
end_define

begin_comment
comment|/* make number positive */
end_comment

begin_define
define|#
directive|define
name|SKIP_WHITE_SPACE
parameter_list|(
name|p
parameter_list|)
value|{ while (is_hor_space[*p]) p++; }
end_define

begin_escape
end_escape

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|struct
name|stat
name|sbuf
decl_stmt|;
name|char
modifier|*
name|in_fname
decl_stmt|,
modifier|*
name|out_fname
decl_stmt|;
name|int
name|out_fd
init|=
literal|1
decl_stmt|;
comment|/* default to stdout */
name|int
name|f
decl_stmt|,
name|i
decl_stmt|;
name|FILE_BUF
modifier|*
name|fp
decl_stmt|;
name|progname
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
name|in_fname
operator|=
name|NULL
expr_stmt|;
name|out_fname
operator|=
name|NULL
expr_stmt|;
name|initialize_random_junk
argument_list|()
expr_stmt|;
name|fp
operator|=
operator|&
name|instack
index|[
name|indepth
operator|++
index|]
expr_stmt|;
comment|/*  if (argc< 2)		JF no args means work as filter     return FATAL_EXIT_CODE; */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|argv
index|[
name|i
index|]
index|[
literal|0
index|]
operator|!=
literal|'-'
condition|)
block|{
if|if
condition|(
name|out_fname
operator|!=
name|NULL
condition|)
name|fatal
argument_list|(
literal|"Usage: %s [switches] input output\n"
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|in_fname
operator|!=
name|NULL
condition|)
block|{
name|out_fname
operator|=
name|argv
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|out_fd
operator|=
name|creat
argument_list|(
name|out_fname
argument_list|,
literal|0666
argument_list|)
operator|)
operator|<
literal|0
condition|)
name|pfatal_with_name
argument_list|(
name|out_fname
argument_list|)
expr_stmt|;
block|}
else|else
name|in_fname
operator|=
name|argv
index|[
name|i
index|]
expr_stmt|;
block|}
else|else
block|{
switch|switch
condition|(
name|argv
index|[
name|i
index|]
index|[
literal|1
index|]
condition|)
block|{
name|U_CHAR
modifier|*
name|p
decl_stmt|;
name|struct
name|directory_stack
modifier|*
name|dirtmp
decl_stmt|;
case|case
literal|'D'
case|:
if|if
condition|(
operator|(
name|p
operator|=
operator|(
name|U_CHAR
operator|*
operator|)
name|index
argument_list|(
name|argv
index|[
name|i
index|]
operator|+
literal|2
argument_list|,
literal|'='
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
operator|*
name|p
operator|=
literal|' '
expr_stmt|;
name|make_definition
argument_list|(
name|argv
index|[
name|i
index|]
operator|+
literal|2
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'U'
case|:
comment|/* JF #undef something */
name|make_undef
argument_list|(
name|argv
index|[
name|i
index|]
operator|+
literal|2
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'C'
case|:
comment|/* JF do later -C means leave comments alone! */
name|put_out_comments
operator|++
expr_stmt|;
break|break;
case|case
literal|'E'
case|:
comment|/* -E comes from cc -E; ignore it.  */
break|break;
case|case
literal|'M'
case|:
comment|/* Makefile dependencies or something like 				   that.  Not implimented yet */
break|break;
case|case
literal|'I'
case|:
comment|/* JF handle directory path right */
name|dirtmp
operator|=
operator|(
expr|struct
name|directory_stack
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|directory_stack
argument_list|)
argument_list|)
expr_stmt|;
name|dirtmp
operator|->
name|next
operator|=
name|include
operator|->
name|next
expr_stmt|;
name|include
operator|->
name|next
operator|=
name|dirtmp
expr_stmt|;
name|dirtmp
operator|->
name|fname
operator|=
name|argv
index|[
name|i
index|]
operator|+
literal|2
expr_stmt|;
name|include
operator|=
name|dirtmp
expr_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|)
operator|>
name|max_include_len
condition|)
name|max_include_len
operator|=
name|strlen
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\0'
case|:
comment|/* JF handle '-' as file name meaning stdin or stdout */
if|if
condition|(
name|in_fname
operator|==
name|NULL
condition|)
block|{
name|in_fname
operator|=
name|STDIN_FILE
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|out_fname
operator|==
name|NULL
condition|)
block|{
name|out_fname
operator|=
literal|"stdout"
expr_stmt|;
break|break;
block|}
comment|/* else fall through into error */
default|default:
name|fatal
argument_list|(
literal|"Illegal option %s\n"
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* JF check for stdin */
if|if
condition|(
name|in_fname
operator|==
name|STDIN_FILE
operator|||
name|in_fname
operator|==
name|NULL
condition|)
name|f
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|f
operator|=
name|open
argument_list|(
name|in_fname
argument_list|,
name|O_RDONLY
argument_list|)
operator|)
operator|<
literal|0
condition|)
goto|goto
name|perror
goto|;
name|fstat
argument_list|(
name|f
argument_list|,
operator|&
name|sbuf
argument_list|)
expr_stmt|;
name|fp
operator|->
name|fname
operator|=
name|in_fname
expr_stmt|;
name|fp
operator|->
name|lineno
operator|=
literal|1
expr_stmt|;
comment|/* JF all this is mine about reading pipes and ttys */
if|if
condition|(
operator|(
name|sbuf
operator|.
name|st_mode
operator|&
name|S_IFMT
operator|)
operator|!=
name|S_IFREG
condition|)
block|{
name|int
name|size
decl_stmt|;
name|int
name|bsize
decl_stmt|;
name|int
name|cnt
decl_stmt|;
name|U_CHAR
modifier|*
name|bufp
decl_stmt|;
name|bsize
operator|=
literal|2000
expr_stmt|;
name|size
operator|=
literal|0
expr_stmt|;
name|fp
operator|->
name|buf
operator|=
operator|(
name|U_CHAR
operator|*
operator|)
name|xmalloc
argument_list|(
name|bsize
operator|+
literal|1
argument_list|)
expr_stmt|;
name|bufp
operator|=
name|fp
operator|->
name|buf
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|cnt
operator|=
name|read
argument_list|(
name|f
argument_list|,
name|bufp
argument_list|,
name|bsize
operator|-
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|cnt
operator|<
literal|0
condition|)
goto|goto
name|perror
goto|;
comment|/* error! */
if|if
condition|(
name|cnt
operator|==
literal|0
condition|)
break|break;
comment|/* End of file */
name|size
operator|+=
name|cnt
expr_stmt|;
name|bufp
operator|+=
name|cnt
expr_stmt|;
if|if
condition|(
name|bsize
operator|-
name|size
operator|==
literal|0
condition|)
block|{
comment|/* Buffer is full! */
name|bsize
operator|*=
literal|2
expr_stmt|;
name|fp
operator|->
name|buf
operator|=
operator|(
name|U_CHAR
operator|*
operator|)
name|xrealloc
argument_list|(
name|fp
operator|->
name|buf
argument_list|,
name|bsize
operator|+
literal|1
argument_list|)
expr_stmt|;
name|bufp
operator|=
name|fp
operator|->
name|buf
operator|+
name|size
expr_stmt|;
comment|/* May have moved */
block|}
block|}
name|fp
operator|->
name|buf
index|[
name|size
index|]
operator|=
literal|'\0'
expr_stmt|;
name|fp
operator|->
name|length
operator|=
name|size
expr_stmt|;
block|}
else|else
block|{
name|fp
operator|->
name|length
operator|=
name|sbuf
operator|.
name|st_size
expr_stmt|;
name|fp
operator|->
name|buf
operator|=
operator|(
name|U_CHAR
operator|*
operator|)
name|alloca
argument_list|(
name|sbuf
operator|.
name|st_size
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|read
argument_list|(
name|f
argument_list|,
name|fp
operator|->
name|buf
argument_list|,
name|sbuf
operator|.
name|st_size
argument_list|)
operator|!=
name|sbuf
operator|.
name|st_size
condition|)
goto|goto
name|perror
goto|;
name|fp
operator|->
name|buf
index|[
name|sbuf
operator|.
name|st_size
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
comment|/* initialize output buffer */
name|outbuf
operator|.
name|buf
operator|=
operator|(
name|U_CHAR
operator|*
operator|)
name|xmalloc
argument_list|(
name|OUTBUF_SIZE
argument_list|)
expr_stmt|;
name|outbuf
operator|.
name|bufp
operator|=
name|outbuf
operator|.
name|buf
expr_stmt|;
name|outbuf
operator|.
name|length
operator|=
name|OUTBUF_SIZE
expr_stmt|;
name|output_line_command
argument_list|(
name|fp
argument_list|,
operator|&
name|outbuf
argument_list|)
expr_stmt|;
name|rescan
argument_list|(
name|fp
argument_list|,
operator|&
name|outbuf
argument_list|)
expr_stmt|;
comment|/* do something different than this later */
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|write
argument_list|(
name|out_fd
argument_list|,
name|outbuf
operator|.
name|buf
argument_list|,
name|outbuf
operator|.
name|bufp
operator|-
name|outbuf
operator|.
name|buf
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|perror
label|:
name|pfatal_with_name
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  * The main loop of the program.  Try to examine and move past most  * ordinary input chars as fast as possible.  Call appropriate routines  * when something special (such as a macro expansion) has to happen.  IP is the source of input to scan. OP is the place to put input. */
end_comment

begin_macro
name|rescan
argument_list|(
argument|ip
argument_list|,
argument|op
argument_list|)
end_macro

begin_decl_stmt
name|FILE_BUF
modifier|*
name|ip
decl_stmt|,
modifier|*
name|op
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|c
decl_stmt|;
specifier|register
name|int
name|ident_length
init|=
literal|0
decl_stmt|,
name|hash
init|=
literal|0
decl_stmt|;
specifier|register
name|U_CHAR
modifier|*
name|limit
decl_stmt|;
name|U_CHAR
modifier|*
name|check_expand
parameter_list|()
function_decl|;
name|struct
name|keyword_table
modifier|*
name|handle_directive
parameter_list|()
function_decl|;
name|int
name|excess_newlines
init|=
literal|0
decl_stmt|;
name|int
name|escaped
init|=
literal|0
decl_stmt|;
name|U_CHAR
modifier|*
name|bp
decl_stmt|;
name|check_expand
argument_list|(
name|op
argument_list|,
name|ip
operator|->
name|length
argument_list|)
expr_stmt|;
name|ip
operator|->
name|bufp
operator|=
name|ip
operator|->
name|buf
expr_stmt|;
name|limit
operator|=
name|ip
operator|->
name|buf
operator|+
name|ip
operator|->
name|length
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|ip
operator|->
name|bufp
operator|<
name|limit
condition|)
block|{
name|c
operator|=
operator|*
name|ip
operator|->
name|bufp
operator|++
expr_stmt|;
operator|*
name|op
operator|->
name|bufp
operator|++
operator|=
name|c
expr_stmt|;
block|}
else|else
block|{
name|c
operator|=
operator|-
literal|1
expr_stmt|;
block|}
operator|--
name|escaped
expr_stmt|;
comment|/* Now ESCAPED is 0 if and only if this character is escaped.  */
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'\\'
case|:
if|if
condition|(
name|escaped
operator|==
literal|0
condition|)
goto|goto
name|randomchar
goto|;
if|if
condition|(
operator|*
name|ip
operator|->
name|bufp
operator|!=
literal|'\n'
condition|)
block|{
name|escaped
operator|=
literal|1
expr_stmt|;
goto|goto
name|randomchar
goto|;
block|}
comment|/* always merge lines ending with backslash-newline */
operator|++
name|ip
operator|->
name|bufp
expr_stmt|;
operator|++
name|ip
operator|->
name|lineno
expr_stmt|;
operator|++
name|excess_newlines
expr_stmt|;
operator|--
name|op
operator|->
name|bufp
expr_stmt|;
comment|/* remove backslash from obuf */
continue|continue;
comment|/* back to top of while loop */
case|case
literal|'#'
case|:
comment|/* # keyword: a # must be first nonblank char on the line */
for|for
control|(
name|bp
operator|=
name|ip
operator|->
name|bufp
operator|-
literal|1
init|;
name|bp
operator|>=
name|ip
operator|->
name|buf
condition|;
name|bp
operator|--
control|)
if|if
condition|(
operator|*
name|bp
operator|==
literal|'\n'
condition|)
break|break;
name|bp
operator|++
expr_stmt|;
comment|/* skip nl or move back into buffer */
name|SKIP_WHITE_SPACE
argument_list|(
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|bp
operator|!=
literal|'#'
condition|)
goto|goto
name|randomchar
goto|;
name|ident_length
operator|=
name|hash
operator|=
literal|0
expr_stmt|;
operator|--
name|op
operator|->
name|bufp
expr_stmt|;
comment|/* don't copy the '#' */
if|if
condition|(
name|handle_directive
argument_list|(
name|ip
argument_list|,
name|op
argument_list|,
operator|&
name|excess_newlines
argument_list|)
operator|==
name|NULL
condition|)
block|{
operator|++
name|op
operator|->
name|bufp
expr_stmt|;
comment|/* copy the '#' after all */
goto|goto
name|randomchar
goto|;
block|}
break|break;
case|case
literal|'\"'
case|:
comment|/* skip quoted string */
case|case
literal|'\''
case|:
comment|/* a single quoted string is treated like a double -- some 	 programs (e.g., troff) are perverse this way */
if|if
condition|(
name|escaped
operator|==
literal|0
condition|)
goto|goto
name|randomchar
goto|;
comment|/* false alarm-- it's escaped. */
comment|/* skip ahead to a matching quote.  */
name|bp
operator|=
name|ip
operator|->
name|bufp
expr_stmt|;
while|while
condition|(
name|bp
operator|<
name|limit
condition|)
block|{
operator|*
name|op
operator|->
name|bufp
operator|++
operator|=
operator|*
name|bp
expr_stmt|;
switch|switch
condition|(
operator|*
name|bp
operator|++
condition|)
block|{
case|case
literal|'\n'
case|:
operator|++
name|ip
operator|->
name|lineno
expr_stmt|;
break|break;
case|case
literal|'\\'
case|:
if|if
condition|(
name|bp
operator|>=
name|limit
condition|)
break|break;
if|if
condition|(
operator|*
name|bp
operator|==
literal|'\n'
condition|)
block|{
comment|/* backslash newline is replaced by nothing at all, 		 but remember that the source line count is out of synch.  */
operator|--
name|op
operator|->
name|bufp
expr_stmt|;
operator|++
name|bp
expr_stmt|;
operator|++
name|excess_newlines
expr_stmt|;
operator|++
name|ip
operator|->
name|lineno
expr_stmt|;
block|}
else|else
operator|*
name|op
operator|->
name|bufp
operator|++
operator|=
operator|*
name|bp
operator|++
expr_stmt|;
break|break;
case|case
literal|'\"'
case|:
case|case
literal|'\''
case|:
if|if
condition|(
name|bp
index|[
operator|-
literal|1
index|]
operator|==
name|c
condition|)
goto|goto
name|while2end
goto|;
break|break;
block|}
block|}
name|while2end
label|:
name|ip
operator|->
name|bufp
operator|=
name|bp
expr_stmt|;
break|break;
case|case
literal|'/'
case|:
comment|/* possible comment */
if|if
condition|(
operator|*
name|ip
operator|->
name|bufp
operator|!=
literal|'*'
condition|)
goto|goto
name|randomchar
goto|;
if|if
condition|(
name|put_out_comments
condition|)
block|{
name|bp
operator|=
name|ip
operator|->
name|bufp
expr_stmt|;
operator|*
name|op
operator|->
name|bufp
operator|++
operator|=
operator|*
name|bp
operator|++
expr_stmt|;
block|}
else|else
block|{
name|bp
operator|=
name|ip
operator|->
name|bufp
operator|+
literal|1
expr_stmt|;
operator|--
name|op
operator|->
name|bufp
expr_stmt|;
comment|/* don't leave initial slash in buffer */
block|}
for|for
control|(
init|;
condition|;
control|)
block|{
while|while
condition|(
name|bp
operator|<
name|limit
condition|)
block|{
if|if
condition|(
name|put_out_comments
condition|)
operator|*
name|op
operator|->
name|bufp
operator|++
operator|=
operator|*
name|bp
expr_stmt|;
switch|switch
condition|(
operator|*
name|bp
operator|++
condition|)
block|{
case|case
literal|'*'
case|:
goto|goto
name|whileend
goto|;
case|case
literal|'\n'
case|:
comment|/* copy the newline into the output buffer, in order to 	       avoid the pain of a #line every time a multiline comment 	       is seen.  This means keywords with embedded comments 	       that contain newlines (blucch!) will lose.  By making 	       sure that excess_newlines is not just a flag, but really 	       an accurate count, it might be possible to get around this. */
if|if
condition|(
operator|!
name|put_out_comments
condition|)
operator|*
name|op
operator|->
name|bufp
operator|++
operator|=
literal|'\n'
expr_stmt|;
operator|++
name|ip
operator|->
name|lineno
expr_stmt|;
block|}
block|}
name|whileend
label|:
if|if
condition|(
name|bp
operator|>=
name|limit
condition|)
block|{
name|error
argument_list|(
literal|"unterminated comment"
argument_list|)
expr_stmt|;
break|break;
comment|/* causes eof condition */
block|}
if|if
condition|(
operator|*
name|bp
operator|==
literal|'/'
condition|)
break|break;
block|}
if|if
condition|(
name|put_out_comments
condition|)
operator|*
name|op
operator|->
name|bufp
operator|++
operator|=
literal|'/'
expr_stmt|;
name|ip
operator|->
name|bufp
operator|=
name|bp
operator|+
literal|1
expr_stmt|;
break|break;
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
comment|/* if digit is not part of identifier, it is random */
if|if
condition|(
name|ident_length
operator|==
literal|0
condition|)
goto|goto
name|randomchar
goto|;
comment|/* fall through */
case|case
literal|'_'
case|:
case|case
literal|'a'
case|:
case|case
literal|'b'
case|:
case|case
literal|'c'
case|:
case|case
literal|'d'
case|:
case|case
literal|'e'
case|:
case|case
literal|'f'
case|:
case|case
literal|'g'
case|:
case|case
literal|'h'
case|:
case|case
literal|'i'
case|:
case|case
literal|'j'
case|:
case|case
literal|'k'
case|:
case|case
literal|'l'
case|:
case|case
literal|'m'
case|:
case|case
literal|'n'
case|:
case|case
literal|'o'
case|:
case|case
literal|'p'
case|:
case|case
literal|'q'
case|:
case|case
literal|'r'
case|:
case|case
literal|'s'
case|:
case|case
literal|'t'
case|:
case|case
literal|'u'
case|:
case|case
literal|'v'
case|:
case|case
literal|'w'
case|:
case|case
literal|'x'
case|:
case|case
literal|'y'
case|:
case|case
literal|'z'
case|:
case|case
literal|'A'
case|:
case|case
literal|'B'
case|:
case|case
literal|'C'
case|:
case|case
literal|'D'
case|:
case|case
literal|'E'
case|:
case|case
literal|'F'
case|:
case|case
literal|'G'
case|:
case|case
literal|'H'
case|:
case|case
literal|'I'
case|:
case|case
literal|'J'
case|:
case|case
literal|'K'
case|:
case|case
literal|'L'
case|:
case|case
literal|'M'
case|:
case|case
literal|'N'
case|:
case|case
literal|'O'
case|:
case|case
literal|'P'
case|:
case|case
literal|'Q'
case|:
case|case
literal|'R'
case|:
case|case
literal|'S'
case|:
case|case
literal|'T'
case|:
case|case
literal|'U'
case|:
case|case
literal|'V'
case|:
case|case
literal|'W'
case|:
case|case
literal|'X'
case|:
case|case
literal|'Y'
case|:
case|case
literal|'Z'
case|:
name|ident_length
operator|++
expr_stmt|;
comment|/* compute step of hash function, to avoid a proc call on every token */
name|hash
operator|=
name|HASHSTEP
argument_list|(
name|hash
argument_list|,
name|c
argument_list|)
expr_stmt|;
break|break;
default|default:
name|randomchar
label|:
if|if
condition|(
name|ident_length
operator|>
literal|0
condition|)
block|{
specifier|register
name|HASHNODE
modifier|*
name|hp
decl_stmt|;
for|for
control|(
name|hp
operator|=
name|hashtab
index|[
name|MAKE_POS
argument_list|(
name|hash
argument_list|)
operator|%
name|HASHSIZE
index|]
init|;
name|hp
operator|!=
name|NULL
condition|;
name|hp
operator|=
name|hp
operator|->
name|next
control|)
block|{
name|U_CHAR
modifier|*
name|save_ibufp
decl_stmt|;
comment|/* kludge, see below */
if|if
condition|(
name|hp
operator|->
name|length
operator|==
name|ident_length
condition|)
block|{
specifier|register
name|int
name|i
init|=
name|ident_length
decl_stmt|;
specifier|register
name|U_CHAR
modifier|*
name|p
init|=
name|hp
operator|->
name|name
decl_stmt|;
specifier|register
name|U_CHAR
modifier|*
name|q
init|=
name|op
operator|->
name|bufp
operator|-
name|i
decl_stmt|;
if|if
condition|(
name|c
operator|!=
operator|(
name|U_CHAR
operator|)
operator|-
literal|1
condition|)
name|q
operator|--
expr_stmt|;
do|do
block|{
comment|/* all this to avoid a strncmp() */
if|if
condition|(
operator|*
name|p
operator|++
operator|!=
operator|*
name|q
operator|++
condition|)
goto|goto
name|hashcollision
goto|;
block|}
do|while
condition|(
operator|--
name|i
condition|)
do|;
name|save_ibufp
operator|=
name|ip
operator|->
name|bufp
expr_stmt|;
comment|/* back up over identifier, then expand token */
name|op
operator|->
name|bufp
operator|-=
name|ident_length
expr_stmt|;
if|if
condition|(
name|c
operator|!=
operator|(
name|U_CHAR
operator|)
operator|-
literal|1
condition|)
name|op
operator|->
name|bufp
operator|--
expr_stmt|;
name|macroexpand
argument_list|(
name|hp
argument_list|,
name|ip
argument_list|,
name|op
argument_list|,
operator|&
name|excess_newlines
argument_list|)
expr_stmt|;
name|check_expand
argument_list|(
name|op
argument_list|,
name|ip
operator|->
name|length
operator|-
operator|(
name|ip
operator|->
name|bufp
operator|-
name|ip
operator|->
name|buf
operator|)
argument_list|)
expr_stmt|;
comment|/* If we just processed an identifier at end of input, 	       return right away.  */
if|if
condition|(
name|c
operator|==
operator|(
name|U_CHAR
operator|)
operator|-
literal|1
condition|)
return|return;
comment|/* if the expansion routine has not moved the input 	       pointer, put back the char that ended the token. 	       This is a kludge because there might be a different 	       reason to put it back or not put it back. */
if|if
condition|(
name|ip
operator|->
name|bufp
operator|==
name|save_ibufp
condition|)
operator|*
name|op
operator|->
name|bufp
operator|++
operator|=
name|c
expr_stmt|;
break|break;
comment|/* out of for loop */
block|}
name|hashcollision
label|:
empty_stmt|;
block|}
comment|/* end for loop */
name|ident_length
operator|=
name|hash
operator|=
literal|0
expr_stmt|;
comment|/* stop collecting identifier */
block|}
comment|/* If we just processed an identifier at end of input, 	 return right away.  */
if|if
condition|(
name|c
operator|==
operator|-
literal|1
condition|)
return|return;
comment|/* count the newline, if it was one.  The reason this is 	 done down here instead of as a case in the switch is 	 that some expansions might want to look at the line 	 number, and if they happen right before the newline, 	 we don't want them to get the wrong one.  So the newline 	 must be counted AFTER any expansions happen. */
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
block|{
operator|++
name|ip
operator|->
name|lineno
expr_stmt|;
if|if
condition|(
name|excess_newlines
operator|>
literal|0
condition|)
block|{
name|output_line_command
argument_list|(
name|ip
argument_list|,
name|op
argument_list|)
expr_stmt|;
name|check_expand
argument_list|(
name|op
argument_list|,
name|ip
operator|->
name|length
operator|-
operator|(
name|ip
operator|->
name|bufp
operator|-
name|ip
operator|->
name|buf
operator|)
argument_list|)
expr_stmt|;
name|excess_newlines
operator|=
literal|0
expr_stmt|;
block|}
block|}
break|break;
comment|/* from switch */
block|}
block|}
block|}
end_block

begin_comment
comment|/*  * Process a # directive.  Expects ip->bufp to point to the '#', as in  * "#define foo bar".  Bumps *excess_newlines counter as necessary if  * the command is several lines long (and also updates ip->lineno).  * The main reason for this is that the comments could contain  * newlines, which would be confusing.  Passes to the command handler  * (do_define, do_include, etc.): the addresses of the 1st and  * last chars of the command (starting immediately after the #  * keyword), plus op and the keyword table pointer.  If the line  * contains comments the command is copied into a temporary buffer  * (sans comments) and the temporary buffer is passed to the command  * handler instead.  */
end_comment

begin_function
name|struct
name|keyword_table
modifier|*
name|handle_directive
parameter_list|(
name|ip
parameter_list|,
name|op
parameter_list|,
name|excess_newlines
parameter_list|)
name|FILE_BUF
modifier|*
name|ip
decl_stmt|,
decl|*
name|op
decl_stmt|;
end_function

begin_decl_stmt
name|int
modifier|*
name|excess_newlines
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|U_CHAR
modifier|*
name|bp
decl_stmt|,
modifier|*
name|cp
decl_stmt|;
specifier|register
name|struct
name|keyword_table
modifier|*
name|kt
decl_stmt|;
specifier|register
name|int
name|ident_length
decl_stmt|;
comment|/* Nonzero means we must copy the entire command      to get rid of comments or backslash-newlines.  */
name|int
name|copy_command
init|=
literal|0
decl_stmt|;
name|bp
operator|=
name|ip
operator|->
name|bufp
expr_stmt|;
name|SKIP_WHITE_SPACE
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|cp
operator|=
name|bp
expr_stmt|;
while|while
condition|(
name|is_idchar
index|[
operator|*
name|cp
index|]
condition|)
name|cp
operator|++
expr_stmt|;
name|ident_length
operator|=
name|cp
operator|-
name|bp
expr_stmt|;
comment|/*    * Decode the keyword and call the appropriate expansion    * routine, after moving the input pointer up to the next line.    * If the keyword is not a legitimate control word, return NULL.    * Otherwise, return ptr to the keyword structure matched.    */
for|for
control|(
name|kt
operator|=
name|keyword_table
init|;
name|kt
operator|->
name|length
operator|>
literal|0
condition|;
name|kt
operator|++
control|)
block|{
if|if
condition|(
name|kt
operator|->
name|length
operator|==
name|ident_length
operator|&&
operator|!
name|strncmp
argument_list|(
name|kt
operator|->
name|name
argument_list|,
name|bp
argument_list|,
name|ident_length
argument_list|)
condition|)
block|{
specifier|register
name|U_CHAR
modifier|*
name|buf
decl_stmt|;
specifier|register
name|U_CHAR
modifier|*
name|limit
init|=
name|ip
operator|->
name|buf
operator|+
name|ip
operator|->
name|length
decl_stmt|;
name|U_CHAR
modifier|*
name|skip_to_end_of_comment
parameter_list|()
function_decl|;
name|buf
operator|=
name|bp
operator|=
name|bp
operator|+
name|ident_length
expr_stmt|;
while|while
condition|(
name|bp
operator|<
name|limit
condition|)
block|{
if|if
condition|(
operator|*
name|bp
operator|==
literal|'\''
operator|||
operator|*
name|bp
operator|==
literal|'\"'
condition|)
block|{
comment|/* JF handle quotes right  */
name|U_CHAR
name|quotec
decl_stmt|;
for|for
control|(
name|quotec
operator|=
operator|*
name|bp
operator|++
init|;
name|bp
operator|<
name|limit
operator|&&
operator|*
name|bp
operator|!=
name|quotec
condition|;
name|bp
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|bp
operator|==
literal|'\\'
condition|)
name|bp
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|bp
operator|==
literal|'\n'
condition|)
block|{
if|if
condition|(
name|bp
index|[
operator|-
literal|1
index|]
operator|==
literal|'\\'
condition|)
name|copy_command
operator|++
expr_stmt|;
else|else
block|{
comment|/* --bp; */
break|break;
comment|/* JF ugly, but might work */
block|}
block|}
block|}
continue|continue;
block|}
if|if
condition|(
operator|*
name|bp
operator|==
literal|'/'
operator|&&
name|bp
index|[
literal|1
index|]
operator|==
literal|'*'
condition|)
block|{
name|copy_command
operator|++
expr_stmt|;
name|ip
operator|->
name|bufp
operator|=
name|bp
operator|+
literal|2
expr_stmt|;
name|skip_to_end_of_comment
argument_list|(
name|ip
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|bp
operator|=
name|ip
operator|->
name|bufp
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|*
name|bp
operator|++
operator|==
literal|'\n'
condition|)
block|{
if|if
condition|(
operator|*
operator|(
name|bp
operator|-
literal|2
operator|)
operator|==
literal|'\\'
condition|)
name|copy_command
operator|++
expr_stmt|;
else|else
block|{
operator|--
name|bp
expr_stmt|;
comment|/* point to the newline */
break|break;
block|}
block|}
block|}
if|if
condition|(
name|copy_command
condition|)
block|{
comment|/* need to copy entire command into temp buffer before dispatching */
name|cp
operator|=
operator|(
name|U_CHAR
operator|*
operator|)
name|alloca
argument_list|(
name|bp
operator|-
name|buf
operator|+
literal|5
argument_list|)
expr_stmt|;
comment|/* room for cmd plus 						  some slop */
name|bp
operator|=
name|buf
expr_stmt|;
name|buf
operator|=
name|cp
expr_stmt|;
while|while
condition|(
name|bp
operator|<
name|limit
condition|)
block|{
if|if
condition|(
operator|*
name|bp
operator|==
literal|'\''
operator|||
operator|*
name|bp
operator|==
literal|'\"'
condition|)
block|{
comment|/* JF handle quotes right  */
name|U_CHAR
name|quotec
decl_stmt|;
operator|*
name|cp
operator|++
operator|=
operator|*
name|bp
expr_stmt|;
for|for
control|(
name|quotec
operator|=
operator|*
name|bp
operator|++
init|;
name|bp
operator|<
name|limit
operator|&&
operator|*
name|bp
operator|!=
name|quotec
condition|;
operator|*
name|cp
operator|++
operator|=
operator|*
name|bp
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|bp
operator|==
literal|'\\'
condition|)
operator|*
name|cp
operator|++
operator|=
operator|*
name|bp
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|bp
operator|==
literal|'\n'
condition|)
block|{
if|if
condition|(
name|bp
index|[
operator|-
literal|1
index|]
operator|==
literal|'\\'
condition|)
block|{
operator|++
name|ip
operator|->
name|lineno
expr_stmt|;
operator|++
operator|*
name|excess_newlines
expr_stmt|;
block|}
else|else
break|break;
comment|/* JF ugly, but might work */
block|}
block|}
continue|continue;
block|}
if|if
condition|(
operator|*
name|bp
operator|==
literal|'/'
operator|&&
name|bp
index|[
literal|1
index|]
operator|==
literal|'*'
condition|)
block|{
name|int
name|newlines_found
init|=
literal|0
decl_stmt|;
name|ip
operator|->
name|bufp
operator|=
name|bp
operator|+
literal|2
expr_stmt|;
name|skip_to_end_of_comment
argument_list|(
name|ip
argument_list|,
operator|&
name|newlines_found
argument_list|)
expr_stmt|;
operator|*
name|excess_newlines
operator|+=
name|newlines_found
expr_stmt|;
name|ip
operator|->
name|lineno
operator|+=
name|newlines_found
expr_stmt|;
name|bp
operator|=
name|ip
operator|->
name|bufp
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|*
name|bp
operator|==
literal|'\n'
condition|)
block|{
if|if
condition|(
name|bp
index|[
operator|-
literal|1
index|]
operator|==
literal|'\\'
condition|)
block|{
operator|++
name|ip
operator|->
name|lineno
expr_stmt|;
operator|++
operator|*
name|excess_newlines
expr_stmt|;
block|}
else|else
break|break;
block|}
operator|*
name|cp
operator|++
operator|=
operator|*
name|bp
operator|++
expr_stmt|;
block|}
block|}
else|else
name|cp
operator|=
name|bp
expr_stmt|;
name|ip
operator|->
name|bufp
operator|=
name|bp
expr_stmt|;
comment|/* skip to the end of the command */
comment|/* call the appropriate command handler.  Buf now points to 	 either the appropriate place in the input buffer, or to 	 the temp buffer if it was necessary to make one.  Cp 	 points to the first char after the contents of the (possibly 	 copied) command, in either case. */
call|(
modifier|*
name|kt
operator|->
name|func
call|)
argument_list|(
name|buf
argument_list|,
name|cp
argument_list|,
name|op
argument_list|,
name|kt
argument_list|)
expr_stmt|;
name|check_expand
argument_list|(
name|op
argument_list|,
name|ip
operator|->
name|length
operator|-
operator|(
name|ip
operator|->
name|bufp
operator|-
name|ip
operator|->
name|buf
operator|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|kt
operator|->
name|length
operator|<=
literal|0
condition|)
name|kt
operator|=
name|NULL
expr_stmt|;
return|return
name|kt
return|;
block|}
end_block

begin_escape
end_escape

begin_decl_stmt
specifier|static
name|char
modifier|*
name|monthnames
index|[]
init|=
block|{
literal|"Jan"
block|,
literal|"Feb"
block|,
literal|"Mar"
block|,
literal|"Apr"
block|,
literal|"May"
block|,
literal|"Jun"
block|,
literal|"Jul"
block|,
literal|"Aug"
block|,
literal|"Sep"
block|,
literal|"Oct"
block|,
literal|"Nov"
block|,
literal|"Dec"
block|, 			    }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * expand things like __FILE__.  Place the expansion into the output  * buffer *without* rescanning.  */
end_comment

begin_macro
name|expand_special_symbol
argument_list|(
argument|hp
argument_list|,
argument|ip
argument_list|,
argument|op
argument_list|)
end_macro

begin_decl_stmt
name|HASHNODE
modifier|*
name|hp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE_BUF
modifier|*
name|ip
decl_stmt|,
modifier|*
name|op
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
modifier|*
name|buf
decl_stmt|;
name|int
name|i
decl_stmt|,
name|len
decl_stmt|;
name|FILE_BUF
modifier|*
name|last_ip
init|=
name|NULL
decl_stmt|;
specifier|static
name|struct
name|tm
modifier|*
name|timebuf
init|=
name|NULL
decl_stmt|;
name|struct
name|tm
modifier|*
name|localtime
parameter_list|()
function_decl|;
name|int
name|paren
init|=
literal|0
decl_stmt|;
comment|/* for special `defined' keyword */
name|HASHNODE
modifier|*
name|lookup
parameter_list|()
function_decl|;
for|for
control|(
name|i
operator|=
name|indepth
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|instack
index|[
name|i
index|]
operator|.
name|fname
operator|!=
name|NULL
condition|)
block|{
name|last_ip
operator|=
operator|&
name|instack
index|[
name|i
index|]
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|last_ip
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
literal|"CCCP error: not in any file?!"
argument_list|)
expr_stmt|;
return|return;
comment|/* the show must go on */
block|}
switch|switch
condition|(
name|hp
operator|->
name|type
condition|)
block|{
case|case
name|T_FILE
case|:
name|buf
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
literal|3
operator|+
name|strlen
argument_list|(
name|last_ip
operator|->
name|fname
argument_list|)
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"\"%s\""
argument_list|,
name|last_ip
operator|->
name|fname
argument_list|)
expr_stmt|;
break|break;
case|case
name|T_SPECLINE
case|:
name|buf
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%d"
argument_list|,
name|last_ip
operator|->
name|lineno
argument_list|)
expr_stmt|;
break|break;
case|case
name|T_DATE
case|:
case|case
name|T_TIME
case|:
if|if
condition|(
name|timebuf
operator|==
name|NULL
condition|)
block|{
name|i
operator|=
name|time
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|timebuf
operator|=
name|localtime
argument_list|(
operator|&
name|i
argument_list|)
expr_stmt|;
block|}
name|buf
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
literal|20
argument_list|)
expr_stmt|;
if|if
condition|(
name|hp
operator|->
name|type
operator|==
name|T_DATE
condition|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"\"%s %2d %4d\""
argument_list|,
name|monthnames
index|[
name|timebuf
operator|->
name|tm_mon
operator|-
literal|1
index|]
argument_list|,
name|timebuf
operator|->
name|tm_mday
argument_list|,
name|timebuf
operator|->
name|tm_year
operator|+
literal|1900
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"\"%02d:%02d:%02d\""
argument_list|,
name|timebuf
operator|->
name|tm_hour
argument_list|,
name|timebuf
operator|->
name|tm_min
argument_list|,
name|timebuf
operator|->
name|tm_sec
argument_list|)
expr_stmt|;
break|break;
case|case
name|T_SPEC_DEFINED
case|:
name|buf
operator|=
literal|" 0 "
expr_stmt|;
comment|/* assume symbol is not defined */
if|if
condition|(
name|is_hor_space
index|[
operator|*
operator|(
name|ip
operator|->
name|bufp
operator|-
literal|1
operator|)
index|]
condition|)
block|{
name|SKIP_WHITE_SPACE
argument_list|(
name|ip
operator|->
name|bufp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|ip
operator|->
name|bufp
operator|==
literal|'('
condition|)
block|{
name|paren
operator|++
expr_stmt|;
name|ip
operator|->
name|bufp
operator|++
expr_stmt|;
comment|/* skip over the paren */
block|}
block|}
elseif|else
if|if
condition|(
operator|*
operator|(
name|ip
operator|->
name|bufp
operator|-
literal|1
operator|)
operator|==
literal|'('
condition|)
name|paren
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|is_idstart
index|[
operator|*
name|ip
operator|->
name|bufp
index|]
condition|)
goto|goto
name|oops
goto|;
if|if
condition|(
name|lookup
argument_list|(
name|ip
operator|->
name|bufp
argument_list|)
condition|)
name|buf
operator|=
literal|" 1 "
expr_stmt|;
while|while
condition|(
name|is_idchar
index|[
operator|*
name|ip
operator|->
name|bufp
index|]
condition|)
operator|++
name|ip
operator|->
name|bufp
expr_stmt|;
name|SKIP_WHITE_SPACE
argument_list|(
name|ip
operator|->
name|bufp
argument_list|)
expr_stmt|;
if|if
condition|(
name|paren
condition|)
block|{
if|if
condition|(
operator|*
name|ip
operator|->
name|bufp
operator|!=
literal|')'
condition|)
goto|goto
name|oops
goto|;
operator|++
name|ip
operator|->
name|bufp
expr_stmt|;
block|}
break|break;
name|oops
label|:
name|error
argument_list|(
literal|"`defined' must be followed by IDENT or (IDENT)"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
argument_list|(
literal|"CCCP error: illegal special hash type"
argument_list|)
expr_stmt|;
comment|/* time for gdb */
name|abort
argument_list|()
expr_stmt|;
block|}
name|len
operator|=
name|strlen
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|check_expand
argument_list|(
name|op
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|buf
argument_list|,
name|op
operator|->
name|bufp
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|op
operator|->
name|bufp
operator|+=
name|len
expr_stmt|;
return|return;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* routines to handle #directives */
end_comment

begin_comment
comment|/*  * process include file by reading it in and calling rescan.  * expects to see "fname" or<fname> on the input.  * add error checking and -I option later.  */
end_comment

begin_macro
name|do_include
argument_list|(
argument|buf
argument_list|,
argument|limit
argument_list|,
argument|op
argument_list|,
argument|keyword
argument_list|)
end_macro

begin_decl_stmt
name|U_CHAR
modifier|*
name|buf
decl_stmt|,
modifier|*
name|limit
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE_BUF
modifier|*
name|op
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|keyword_table
modifier|*
name|keyword
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
modifier|*
name|fname
decl_stmt|;
comment|/* dynamically allocated fname buffer */
name|U_CHAR
modifier|*
name|fbeg
decl_stmt|,
modifier|*
name|fend
decl_stmt|;
comment|/* beginning and end of fname */
name|U_CHAR
name|term
decl_stmt|;
comment|/* terminator for fname */
name|int
name|err
init|=
literal|0
decl_stmt|;
comment|/* some error has happened */
name|struct
name|stat
name|sbuf
decl_stmt|;
comment|/* to stat the include file */
name|FILE_BUF
modifier|*
name|fp
decl_stmt|;
comment|/* for input stack frame */
name|struct
name|directory_stack
modifier|*
name|stackp
decl_stmt|;
name|int
name|flen
decl_stmt|;
name|int
name|save_indepth
init|=
name|indepth
decl_stmt|;
comment|/* in case of errors */
name|int
name|f
decl_stmt|;
comment|/* file number */
name|char
modifier|*
name|other_dir
decl_stmt|;
comment|/* JF */
name|f
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* JF we iz PARANOID! */
name|fbeg
operator|=
name|buf
expr_stmt|;
name|SKIP_WHITE_SPACE
argument_list|(
name|fbeg
argument_list|)
expr_stmt|;
switch|switch
condition|(
operator|*
name|fbeg
operator|++
condition|)
block|{
case|case
literal|'\"'
case|:
name|term
operator|=
literal|'\"'
expr_stmt|;
name|stackp
operator|=
name|include
expr_stmt|;
break|break;
case|case
literal|'<'
case|:
name|term
operator|=
literal|'>'
expr_stmt|;
name|stackp
operator|=
name|include
operator|->
name|next
expr_stmt|;
break|break;
default|default:
name|error
argument_list|(
literal|"#include expects \"fname\" or<fname>"
argument_list|)
expr_stmt|;
name|fbeg
operator|--
expr_stmt|;
comment|/* so person can see whole fname */
name|err
operator|++
expr_stmt|;
name|term
operator|=
literal|'\n'
expr_stmt|;
break|break;
block|}
for|for
control|(
name|fend
operator|=
name|fbeg
init|;
operator|*
name|fend
operator|!=
name|term
condition|;
name|fend
operator|++
control|)
block|{
if|if
condition|(
name|fend
operator|>=
name|limit
condition|)
block|{
name|error
argument_list|(
literal|"illegal or unterminated include file name"
argument_list|)
expr_stmt|;
goto|goto
name|nope
goto|;
block|}
block|}
name|flen
operator|=
name|fend
operator|-
name|fbeg
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|nope
goto|;
name|other_dir
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|stackp
operator|==
name|include
condition|)
block|{
name|fp
operator|=
operator|&
name|instack
index|[
name|indepth
index|]
expr_stmt|;
while|while
condition|(
operator|--
name|fp
operator|>=
operator|&
name|instack
index|[
literal|0
index|]
condition|)
block|{
name|int
name|n
decl_stmt|;
name|char
modifier|*
name|ep
decl_stmt|,
modifier|*
name|nam
decl_stmt|;
specifier|extern
name|char
modifier|*
name|rindex
parameter_list|()
function_decl|;
if|if
condition|(
operator|(
name|nam
operator|=
name|fp
operator|->
name|fname
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|ep
operator|=
name|rindex
argument_list|(
name|nam
argument_list|,
literal|'/'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|n
operator|=
name|ep
operator|-
name|nam
expr_stmt|;
name|other_dir
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|n
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|other_dir
argument_list|,
name|nam
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|other_dir
index|[
name|n
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
break|break;
block|}
block|}
block|}
comment|/* JF search directory path */
name|fname
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|max_include_len
operator|+
name|flen
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|stackp
condition|;
name|stackp
operator|=
name|stackp
operator|->
name|next
control|)
block|{
if|if
condition|(
name|other_dir
condition|)
block|{
name|strcpy
argument_list|(
name|fname
argument_list|,
name|other_dir
argument_list|)
expr_stmt|;
name|other_dir
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|strcpy
argument_list|(
name|fname
argument_list|,
name|stackp
operator|->
name|fname
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|fname
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
name|strncat
argument_list|(
name|fname
argument_list|,
name|fbeg
argument_list|,
name|flen
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|f
operator|=
name|open
argument_list|(
name|fname
argument_list|,
name|O_RDONLY
argument_list|)
operator|)
operator|>=
literal|0
condition|)
break|break;
block|}
if|if
condition|(
name|f
operator|<
literal|0
condition|)
block|{
name|err
operator|++
expr_stmt|;
goto|goto
name|nope
goto|;
block|}
if|if
condition|(
name|fstat
argument_list|(
name|f
argument_list|,
operator|&
name|sbuf
argument_list|)
operator|<
literal|0
condition|)
block|{
name|perror_with_name
argument_list|(
name|fname
argument_list|)
expr_stmt|;
goto|goto
name|nope
goto|;
comment|/* impossible? */
block|}
name|fp
operator|=
operator|&
name|instack
index|[
name|indepth
operator|++
index|]
expr_stmt|;
name|fp
operator|->
name|buf
operator|=
operator|(
name|U_CHAR
operator|*
operator|)
name|alloca
argument_list|(
name|sbuf
operator|.
name|st_size
operator|+
literal|1
argument_list|)
expr_stmt|;
name|fp
operator|->
name|fname
operator|=
name|fname
expr_stmt|;
name|fp
operator|->
name|length
operator|=
name|sbuf
operator|.
name|st_size
expr_stmt|;
name|fp
operator|->
name|lineno
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|read
argument_list|(
name|f
argument_list|,
name|fp
operator|->
name|buf
argument_list|,
name|sbuf
operator|.
name|st_size
argument_list|)
operator|!=
name|sbuf
operator|.
name|st_size
condition|)
goto|goto
name|nope
goto|;
name|fp
operator|->
name|buf
index|[
name|sbuf
operator|.
name|st_size
index|]
operator|=
literal|'\0'
expr_stmt|;
name|output_line_command
argument_list|(
name|fp
argument_list|,
name|op
argument_list|)
expr_stmt|;
name|rescan
argument_list|(
name|fp
argument_list|,
name|op
argument_list|)
expr_stmt|;
name|nope
label|:
if|if
condition|(
name|f
operator|>
literal|0
condition|)
name|close
argument_list|(
name|f
argument_list|)
expr_stmt|;
name|indepth
operator|=
name|save_indepth
expr_stmt|;
name|output_line_command
argument_list|(
operator|&
name|instack
index|[
name|indepth
operator|-
literal|1
index|]
argument_list|,
name|op
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|strncpy
argument_list|(
name|fname
argument_list|,
name|fbeg
argument_list|,
name|flen
argument_list|)
expr_stmt|;
name|fname
index|[
name|flen
index|]
operator|=
literal|'\0'
expr_stmt|;
name|perror_with_name
argument_list|(
name|fname
argument_list|)
expr_stmt|;
block|}
return|return
name|err
return|;
block|}
end_block

begin_comment
comment|/* the arglist structure is built by do_define to tell    collect_definition where the argument names begin.  That    is, for a define like "#define f(x,y,z) foo+x-bar*y", the arglist    would contain pointers to the strings x, y, and z.    Collect_definition would then build a DEFINITION node,    with reflist nodes pointing to the places x, y, and z had    appeared.  So the arglist is just convenience data passed    between these two routines.  It is not kept around after    the current #define has been processed and entered into the    hash table. */
end_comment

begin_struct
struct|struct
name|arglist
block|{
name|struct
name|arglist
modifier|*
name|next
decl_stmt|;
name|U_CHAR
modifier|*
name|name
decl_stmt|;
name|int
name|length
decl_stmt|;
name|int
name|argno
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Process a #define command. BUF points to the contents of the #define command, as a continguous string. LIMIT points to the first character past the end of the definition. KEYWORD is the keyword-table entry for #define.  */
end_comment

begin_macro
name|do_define
argument_list|(
argument|buf
argument_list|,
argument|limit
argument_list|,
argument|op
argument_list|,
argument|keyword
argument_list|)
end_macro

begin_decl_stmt
name|U_CHAR
modifier|*
name|buf
decl_stmt|,
modifier|*
name|limit
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE_BUF
modifier|*
name|op
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|keyword_table
modifier|*
name|keyword
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|U_CHAR
modifier|*
name|bp
decl_stmt|;
comment|/* temp ptr into input buffer */
name|U_CHAR
modifier|*
name|symname
decl_stmt|;
comment|/* remember where symbol name starts */
name|int
name|sym_length
decl_stmt|;
comment|/* and how long it is */
name|U_CHAR
modifier|*
name|def
decl_stmt|;
comment|/* beginning of expansion */
name|DEFINITION
modifier|*
name|defn
decl_stmt|,
modifier|*
name|collect_expansion
argument_list|()
decl_stmt|;
name|bp
operator|=
name|buf
expr_stmt|;
while|while
condition|(
name|is_hor_space
index|[
operator|*
name|bp
index|]
condition|)
name|bp
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|is_idstart
index|[
operator|*
name|bp
index|]
condition|)
block|{
name|error
argument_list|(
literal|"illegal macro name: must start with an alphabetic or '_'"
argument_list|)
expr_stmt|;
goto|goto
name|nope
goto|;
block|}
name|symname
operator|=
name|bp
expr_stmt|;
comment|/* remember where it starts */
while|while
condition|(
name|is_idchar
index|[
operator|*
name|bp
index|]
operator|&&
name|bp
operator|<
name|limit
condition|)
name|bp
operator|++
expr_stmt|;
name|sym_length
operator|=
name|bp
operator|-
name|symname
expr_stmt|;
comment|/* lossage will occur if identifiers or control keywords are broken      across lines using backslash.  This is not the right place to take      care of that. */
if|if
condition|(
name|is_hor_space
index|[
operator|*
name|bp
index|]
operator|||
operator|*
name|bp
operator|==
literal|'\n'
operator|||
name|bp
operator|>=
name|limit
condition|)
block|{
comment|/* simple expansion or empty definition; gobble it */
if|if
condition|(
name|is_hor_space
index|[
operator|*
name|bp
index|]
condition|)
name|def
operator|=
operator|++
name|bp
expr_stmt|;
comment|/* skip exactly one blank/tab char */
else|else
name|def
operator|=
name|bp
expr_stmt|;
comment|/* empty definition */
name|defn
operator|=
operator|(
name|DEFINITION
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|DEFINITION
argument_list|)
operator|+
name|limit
operator|-
name|def
argument_list|)
expr_stmt|;
name|defn
operator|->
name|nargs
operator|=
operator|-
literal|1
expr_stmt|;
name|defn
operator|->
name|pattern
operator|=
name|NULL
expr_stmt|;
name|defn
operator|->
name|expansion
operator|=
operator|(
operator|(
name|U_CHAR
operator|*
operator|)
name|defn
operator|)
operator|+
sizeof|sizeof
argument_list|(
name|DEFINITION
argument_list|)
expr_stmt|;
name|defn
operator|->
name|length
operator|=
name|limit
operator|-
name|def
expr_stmt|;
if|if
condition|(
name|defn
operator|->
name|length
operator|>
literal|0
condition|)
name|bcopy
argument_list|(
name|def
argument_list|,
name|defn
operator|->
name|expansion
argument_list|,
name|defn
operator|->
name|length
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|bp
operator|==
literal|'('
condition|)
block|{
name|struct
name|arglist
modifier|*
name|arg_ptrs
init|=
name|NULL
decl_stmt|;
name|int
name|argno
init|=
literal|0
decl_stmt|;
name|bp
operator|++
expr_stmt|;
comment|/* skip '(' */
name|SKIP_WHITE_SPACE
argument_list|(
name|bp
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|bp
operator|!=
literal|')'
condition|)
block|{
name|struct
name|arglist
modifier|*
name|temp
decl_stmt|;
name|temp
operator|=
operator|(
expr|struct
name|arglist
operator|*
operator|)
name|alloca
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|arglist
argument_list|)
argument_list|)
expr_stmt|;
name|temp
operator|->
name|name
operator|=
name|bp
expr_stmt|;
name|temp
operator|->
name|next
operator|=
name|arg_ptrs
expr_stmt|;
name|temp
operator|->
name|argno
operator|=
operator|++
name|argno
expr_stmt|;
name|arg_ptrs
operator|=
name|temp
expr_stmt|;
while|while
condition|(
name|is_idchar
index|[
operator|*
name|bp
index|]
condition|)
name|bp
operator|++
expr_stmt|;
name|temp
operator|->
name|length
operator|=
name|bp
operator|-
name|temp
operator|->
name|name
expr_stmt|;
name|SKIP_WHITE_SPACE
argument_list|(
name|bp
argument_list|)
expr_stmt|;
comment|/* there should not be spaces here, 				   but let it slide if there are. */
if|if
condition|(
name|temp
operator|->
name|length
operator|==
literal|0
operator|||
operator|(
operator|*
name|bp
operator|!=
literal|','
operator|&&
operator|*
name|bp
operator|!=
literal|')'
operator|)
condition|)
block|{
name|error
argument_list|(
literal|"illegal parameter to macro"
argument_list|)
expr_stmt|;
goto|goto
name|nope
goto|;
block|}
if|if
condition|(
operator|*
name|bp
operator|==
literal|','
condition|)
block|{
name|bp
operator|++
expr_stmt|;
name|SKIP_WHITE_SPACE
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bp
operator|>=
name|limit
condition|)
block|{
name|error
argument_list|(
literal|"unterminated format parameter list in #define"
argument_list|)
expr_stmt|;
goto|goto
name|nope
goto|;
block|}
block|}
operator|++
name|bp
expr_stmt|;
comment|/* skip paren */
comment|/* Skip exactly one space or tab if any.  */
if|if
condition|(
name|bp
operator|<
name|limit
operator|&&
operator|(
operator|*
name|bp
operator|==
literal|' '
operator|||
operator|*
name|bp
operator|==
literal|'\t'
operator|)
condition|)
operator|++
name|bp
expr_stmt|;
comment|/* now everything from bp before limit is the definition. */
name|defn
operator|=
name|collect_expansion
argument_list|(
name|bp
argument_list|,
name|limit
operator|-
name|bp
argument_list|,
name|arg_ptrs
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|error
argument_list|(
literal|"#define symbol name not followed by SPC, TAB, or '('"
argument_list|)
expr_stmt|;
goto|goto
name|nope
goto|;
block|}
block|{
name|HASHNODE
modifier|*
name|hp
decl_stmt|,
modifier|*
name|lookup
argument_list|()
decl_stmt|;
name|DEFINITION
modifier|*
name|old_def
decl_stmt|;
if|if
condition|(
operator|(
name|hp
operator|=
name|lookup
argument_list|(
name|symname
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|old_def
operator|=
name|hp
operator|->
name|value
operator|.
name|defn
expr_stmt|;
if|if
condition|(
name|compare_defs
argument_list|(
name|defn
argument_list|,
name|old_def
argument_list|)
condition|)
block|{
name|U_CHAR
modifier|*
name|msg
decl_stmt|;
comment|/* what pain... */
name|msg
operator|=
operator|(
name|U_CHAR
operator|*
operator|)
name|alloca
argument_list|(
name|sym_length
operator|+
literal|20
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|symname
argument_list|,
name|msg
argument_list|,
name|sym_length
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|msg
operator|+
name|sym_length
argument_list|,
literal|" redefined"
argument_list|)
expr_stmt|;
name|error
argument_list|(
name|msg
argument_list|)
expr_stmt|;
comment|/* flush the most recent old definition */
name|delete
argument_list|(
name|hp
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|install
argument_list|(
name|symname
argument_list|,
name|T_MACRO
argument_list|,
name|defn
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
name|nope
label|:
return|return
literal|1
return|;
block|}
end_block

begin_comment
comment|/*  * return zero if two DEFINITIONs are isomorphic  */
end_comment

begin_expr_stmt
specifier|static
name|compare_defs
argument_list|(
argument|d1
argument_list|,
argument|d2
argument_list|)
name|DEFINITION
operator|*
name|d1
operator|,
operator|*
name|d2
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|struct
name|reflist
modifier|*
name|a1
decl_stmt|,
modifier|*
name|a2
decl_stmt|;
if|if
condition|(
name|d1
operator|->
name|nargs
operator|!=
name|d2
operator|->
name|nargs
operator|||
name|d1
operator|->
name|length
operator|!=
name|d2
operator|->
name|length
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|strncmp
argument_list|(
name|d1
operator|->
name|expansion
argument_list|,
name|d2
operator|->
name|expansion
argument_list|,
name|d1
operator|->
name|length
argument_list|)
operator|!=
literal|0
condition|)
return|return
literal|1
return|;
for|for
control|(
name|a1
operator|=
name|d1
operator|->
name|pattern
operator|,
name|a2
operator|=
name|d2
operator|->
name|pattern
init|;
name|a1
operator|&&
name|a2
condition|;
name|a1
operator|=
name|a1
operator|->
name|next
operator|,
name|a2
operator|=
name|a2
operator|->
name|next
control|)
if|if
condition|(
name|a1
operator|->
name|nchars
operator|!=
name|a2
operator|->
name|nchars
operator|||
name|a1
operator|->
name|argno
operator|!=
name|a2
operator|->
name|argno
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_block

begin_comment
comment|/* Read a macro definition for a macro with parameters.    Build the DEFINITION structure.    Reads SIZE characters of text starting at BUF.    ARGLIST specifies the formal parameters to look for    in the text of the definition.  */
end_comment

begin_function
specifier|static
name|DEFINITION
modifier|*
name|collect_expansion
parameter_list|(
name|buf
parameter_list|,
name|size
parameter_list|,
name|arglist
parameter_list|)
name|U_CHAR
modifier|*
name|buf
decl_stmt|;
name|int
name|size
decl_stmt|;
name|struct
name|arglist
modifier|*
name|arglist
decl_stmt|;
block|{
name|DEFINITION
modifier|*
name|defn
decl_stmt|;
name|U_CHAR
modifier|*
name|p
decl_stmt|,
modifier|*
name|lastp
decl_stmt|,
modifier|*
name|exp_p
decl_stmt|;
name|int
name|id_len
decl_stmt|;
name|struct
name|arglist
modifier|*
name|arg
decl_stmt|;
name|struct
name|reflist
modifier|*
name|endpat
init|=
name|NULL
decl_stmt|;
comment|/* scan thru the macro definition, ignoring comments and quoted    strings, picking up on the macro calls.  It does a linear search    thru the arg list on every potential symbol.  Profiling might say    that something smarter should happen. */
if|if
condition|(
name|size
operator|<
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
name|defn
operator|=
operator|(
name|DEFINITION
operator|*
operator|)
name|xcalloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|DEFINITION
argument_list|)
argument_list|)
expr_stmt|;
comment|/* watch out!  the arg count here depends on the order in which      arglist was built.  you might have to count the args if      you change something. */
if|if
condition|(
name|arglist
operator|!=
name|NULL
condition|)
name|defn
operator|->
name|nargs
operator|=
name|arglist
operator|->
name|argno
expr_stmt|;
else|else
name|defn
operator|->
name|nargs
operator|=
literal|0
expr_stmt|;
name|exp_p
operator|=
name|defn
operator|->
name|expansion
operator|=
operator|(
name|U_CHAR
operator|*
operator|)
name|xmalloc
argument_list|(
name|size
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* write comment and quote handling      and speed this loop up later; this is a stripped version */
comment|/* On the other hand, is it really worth doing that here?      comments will get taken care of on rescan.  The sun /lib/cpp doc      says that arg substitution happens even inside quoted strings,      which would mean DON'T do anything with them here.  Check the      standard on this. */
name|lastp
operator|=
name|p
operator|=
name|buf
expr_stmt|;
while|while
condition|(
name|p
operator|<
name|buf
operator|+
name|size
condition|)
block|{
name|int
name|skipped_arg
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|is_idstart
index|[
operator|*
name|p
index|]
operator|&&
operator|(
name|p
operator|==
name|buf
operator|||
operator|!
name|is_idchar
index|[
operator|*
operator|(
name|p
operator|-
literal|1
operator|)
index|]
operator|)
condition|)
block|{
for|for
control|(
name|id_len
operator|=
literal|0
init|;
name|is_idchar
index|[
name|p
index|[
name|id_len
index|]
index|]
condition|;
name|id_len
operator|++
control|)
empty_stmt|;
for|for
control|(
name|arg
operator|=
name|arglist
init|;
name|arg
operator|!=
name|NULL
condition|;
name|arg
operator|=
name|arg
operator|->
name|next
control|)
block|{
name|struct
name|reflist
modifier|*
name|tpat
decl_stmt|;
if|if
condition|(
name|arg
operator|->
name|length
operator|==
name|id_len
operator|&&
name|strncmp
argument_list|(
name|arg
operator|->
name|name
argument_list|,
name|p
argument_list|,
name|id_len
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* make a pat node for this arg and append it to the end of 	     the pat list */
name|tpat
operator|=
operator|(
expr|struct
name|reflist
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|reflist
argument_list|)
argument_list|)
expr_stmt|;
name|tpat
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|endpat
operator|==
name|NULL
condition|)
name|defn
operator|->
name|pattern
operator|=
name|tpat
expr_stmt|;
else|else
name|endpat
operator|->
name|next
operator|=
name|tpat
expr_stmt|;
name|endpat
operator|=
name|tpat
expr_stmt|;
name|tpat
operator|->
name|argno
operator|=
name|arg
operator|->
name|argno
expr_stmt|;
name|tpat
operator|->
name|nchars
operator|=
name|p
operator|-
name|lastp
expr_stmt|;
name|p
operator|+=
name|id_len
expr_stmt|;
name|lastp
operator|=
name|p
expr_stmt|;
comment|/* place to start copying from next time */
name|skipped_arg
operator|++
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
name|skipped_arg
operator|==
literal|0
condition|)
operator|*
name|exp_p
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
block|}
operator|*
name|exp_p
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|defn
operator|->
name|length
operator|=
name|exp_p
operator|-
name|defn
operator|->
name|expansion
operator|-
literal|1
expr_stmt|;
comment|/* give back excess storage */
name|defn
operator|->
name|expansion
operator|=
operator|(
name|U_CHAR
operator|*
operator|)
name|xrealloc
argument_list|(
name|defn
operator|->
name|expansion
argument_list|,
name|defn
operator|->
name|length
operator|+
literal|1
argument_list|)
expr_stmt|;
return|return
name|defn
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_comment
comment|/*  * debugging routine ---- return a ptr to a string containing  *   first n chars of s.  Returns a ptr to a static object  *   since I happen to know it will fit.  */
end_comment

begin_function
specifier|static
name|U_CHAR
modifier|*
name|prefix
parameter_list|(
name|s
parameter_list|,
name|n
parameter_list|)
name|U_CHAR
modifier|*
name|s
decl_stmt|;
name|int
name|n
decl_stmt|;
block|{
specifier|static
name|U_CHAR
name|buf
index|[
literal|1000
index|]
decl_stmt|;
name|bcopy
argument_list|(
name|s
argument_list|,
name|buf
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|buf
index|[
name|n
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* this should not be necessary! */
return|return
name|buf
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * interpret #line command.  Remembers previously seen fnames  * in its very own hash table.  */
end_comment

begin_define
define|#
directive|define
name|FNAME_HASHSIZE
value|37
end_define

begin_macro
name|do_line
argument_list|(
argument|buf
argument_list|,
argument|limit
argument_list|,
argument|op
argument_list|,
argument|keyword
argument_list|)
end_macro

begin_decl_stmt
name|U_CHAR
modifier|*
name|buf
decl_stmt|,
modifier|*
name|limit
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE_BUF
modifier|*
name|op
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|keyword_table
modifier|*
name|keyword
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|U_CHAR
modifier|*
name|bp
decl_stmt|;
name|FILE_BUF
modifier|*
name|ip
init|=
operator|&
name|instack
index|[
name|indepth
operator|-
literal|1
index|]
decl_stmt|;
name|bp
operator|=
name|buf
expr_stmt|;
name|ip
operator|->
name|lineno
operator|=
name|atoi
argument_list|(
name|bp
argument_list|)
expr_stmt|;
comment|/* this time, skip to the end of the line WITHOUT      bumping lineno.  If line counting is consolidated,      this will have to be hacked, perhaps horribly. */
comment|/* skip over blanks, optional sign, digits, blanks. */
name|SKIP_WHITE_SPACE
argument_list|(
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|bp
operator|==
literal|'-'
operator|||
operator|*
name|bp
operator|==
literal|'+'
condition|)
name|bp
operator|++
expr_stmt|;
while|while
condition|(
name|isdigit
argument_list|(
operator|*
name|bp
argument_list|)
condition|)
name|bp
operator|++
expr_stmt|;
name|SKIP_WHITE_SPACE
argument_list|(
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|bp
operator|!=
literal|'\n'
condition|)
block|{
comment|/* if eol, then don't hack fname */
specifier|static
name|HASHNODE
modifier|*
name|fname_table
index|[
name|FNAME_HASHSIZE
index|]
decl_stmt|;
name|HASHNODE
modifier|*
name|hp
decl_stmt|,
modifier|*
modifier|*
name|hash_bucket
decl_stmt|;
name|U_CHAR
modifier|*
name|fname
decl_stmt|;
name|int
name|fname_length
decl_stmt|;
if|if
condition|(
operator|*
name|bp
operator|!=
literal|'"'
condition|)
block|{
name|error
argument_list|(
literal|"#line directive must be #line NNN [\"fname\"]"
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|fname
operator|=
operator|++
name|bp
expr_stmt|;
while|while
condition|(
operator|*
name|bp
operator|!=
literal|'"'
operator|&&
name|bp
operator|<
name|limit
condition|)
name|bp
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|bp
operator|!=
literal|'"'
condition|)
block|{
name|error
argument_list|(
literal|"Unterminated fname in #line command"
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|fname_length
operator|=
name|bp
operator|-
name|fname
expr_stmt|;
name|hash_bucket
operator|=
operator|&
name|fname_table
index|[
name|hashf
argument_list|(
name|fname
argument_list|,
name|fname_length
argument_list|,
name|FNAME_HASHSIZE
argument_list|)
index|]
expr_stmt|;
for|for
control|(
name|hp
operator|=
operator|*
name|hash_bucket
init|;
name|hp
operator|!=
name|NULL
condition|;
name|hp
operator|=
name|hp
operator|->
name|next
control|)
if|if
condition|(
name|hp
operator|->
name|length
operator|==
name|fname_length
operator|&&
name|strncmp
argument_list|(
name|hp
operator|->
name|value
operator|.
name|cpval
argument_list|,
name|fname
argument_list|,
name|fname_length
argument_list|)
operator|==
literal|0
condition|)
block|{
name|ip
operator|->
name|fname
operator|=
name|hp
operator|->
name|value
operator|.
name|cpval
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* didn't find it, cons up a new one */
name|hp
operator|=
operator|(
name|HASHNODE
operator|*
operator|)
name|xcalloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|HASHNODE
argument_list|)
operator|+
name|fname_length
operator|+
literal|1
argument_list|)
expr_stmt|;
name|hp
operator|->
name|next
operator|=
operator|*
name|hash_bucket
expr_stmt|;
operator|*
name|hash_bucket
operator|=
name|hp
expr_stmt|;
name|hp
operator|->
name|length
operator|=
name|fname_length
expr_stmt|;
name|ip
operator|->
name|fname
operator|=
name|hp
operator|->
name|value
operator|.
name|cpval
operator|=
operator|(
operator|(
name|char
operator|*
operator|)
name|hp
operator|)
operator|+
sizeof|sizeof
argument_list|(
name|HASHNODE
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|fname
argument_list|,
name|hp
operator|->
name|value
operator|.
name|cpval
argument_list|,
name|fname_length
argument_list|)
expr_stmt|;
block|}
name|done
label|:
name|output_line_command
argument_list|(
name|ip
argument_list|,
name|op
argument_list|)
expr_stmt|;
name|check_expand
argument_list|(
name|op
argument_list|,
name|ip
operator|->
name|length
operator|-
operator|(
name|ip
operator|->
name|bufp
operator|-
name|ip
operator|->
name|buf
operator|)
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * remove all definitions of symbol from symbol table.  * according to un*x /lib/cpp, it is not an error to undef  * something that has no definitions, so it isn't one here either.  */
end_comment

begin_macro
name|do_undef
argument_list|(
argument|buf
argument_list|,
argument|limit
argument_list|,
argument|op
argument_list|,
argument|keyword
argument_list|)
end_macro

begin_decl_stmt
name|U_CHAR
modifier|*
name|buf
decl_stmt|,
modifier|*
name|limit
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE_BUF
modifier|*
name|op
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|keyword_table
modifier|*
name|keyword
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|U_CHAR
modifier|*
name|bp
decl_stmt|;
name|HASHNODE
modifier|*
name|hp
decl_stmt|,
modifier|*
name|lookup
argument_list|()
decl_stmt|;
name|SKIP_WHITE_SPACE
argument_list|(
name|buf
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|hp
operator|=
name|lookup
argument_list|(
name|buf
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|delete
argument_list|(
name|hp
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* handle #error command later */
end_comment

begin_macro
name|do_error
argument_list|()
end_macro

begin_block
block|{ }
end_block

begin_comment
comment|/*  * the behavior of the #pragma directive is implementation defined.  * this implementation defines it as follows.  */
end_comment

begin_macro
name|do_pragma
argument_list|()
end_macro

begin_block
block|{
name|close
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|open
argument_list|(
literal|"/dev/tty"
argument_list|,
name|O_RDONLY
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|nope
goto|;
name|close
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|open
argument_list|(
literal|"/dev/tty"
argument_list|,
name|O_WRONLY
argument_list|)
operator|!=
literal|1
condition|)
goto|goto
name|nope
goto|;
name|execl
argument_list|(
literal|"/usr/games/rogue"
argument_list|,
literal|"#pragma"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|execl
argument_list|(
literal|"/usr/games/hack"
argument_list|,
literal|"#pragma"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|execl
argument_list|(
literal|"/usr/new/emacs -f hanoi 9 -kill"
argument_list|,
literal|"#pragma"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|nope
label|:
name|fatal
argument_list|(
literal|"You are in a maze of twisty compiler features, all different"
argument_list|)
expr_stmt|;
block|}
end_block

begin_typedef
typedef|typedef
struct|struct
name|if_stack
block|{
name|struct
name|if_stack
modifier|*
name|next
decl_stmt|;
comment|/* for chaining to the next stack frame */
name|char
modifier|*
name|fname
decl_stmt|;
comment|/* copied from input when frame is made */
name|int
name|lineno
decl_stmt|;
comment|/* similarly */
name|int
name|if_succeeded
decl_stmt|;
comment|/* true if a leg of this if-group 				    has been passed through rescan */
name|int
name|type
decl_stmt|;
comment|/* type of last directive seen in this group */
block|}
empty_stmt|;
end_typedef

begin_typedef
typedef|typedef
name|struct
name|if_stack
name|IF_STACK_FRAME
typedef|;
end_typedef

begin_decl_stmt
name|IF_STACK_FRAME
modifier|*
name|if_stack
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * handle #if command by  *   1) inserting special `defined' keyword into the hash table  *	that gets turned into 0 or 1 by expand_special_symbol (thus,  *	if the luser has a symbol called `defined' already, it won't  *      work inside the #if command)  *   2) rescan the input into a temporary output buffer  *   3) pass the output buffer to the yacc parser and collect a value  *   4) clean up the mess left from steps 1 and 2.  *   5) call conditional_skip to skip til the next #endif (etc.),  *      or not, depending on the value from step 3.  */
end_comment

begin_macro
name|do_if
argument_list|(
argument|buf
argument_list|,
argument|limit
argument_list|,
argument|op
argument_list|,
argument|keyword
argument_list|)
end_macro

begin_decl_stmt
name|U_CHAR
modifier|*
name|buf
decl_stmt|,
modifier|*
name|limit
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE_BUF
modifier|*
name|op
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|keyword_table
modifier|*
name|keyword
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|value
decl_stmt|;
name|FILE_BUF
modifier|*
name|ip
init|=
operator|&
name|instack
index|[
name|indepth
operator|-
literal|1
index|]
decl_stmt|;
name|value
operator|=
name|eval_if_expression
argument_list|(
name|buf
argument_list|,
name|limit
operator|-
name|buf
argument_list|)
expr_stmt|;
name|conditional_skip
argument_list|(
name|ip
argument_list|,
name|value
operator|==
literal|0
argument_list|,
name|T_IF
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * handle a #elif directive by not changing  if_stack  either.  * see the comment above do_else.  */
end_comment

begin_macro
name|do_elif
argument_list|(
argument|buf
argument_list|,
argument|limit
argument_list|,
argument|op
argument_list|,
argument|keyword
argument_list|)
end_macro

begin_decl_stmt
name|U_CHAR
modifier|*
name|buf
decl_stmt|,
modifier|*
name|limit
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE_BUF
modifier|*
name|op
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|keyword_table
modifier|*
name|keyword
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|value
decl_stmt|;
name|FILE_BUF
modifier|*
name|ip
init|=
operator|&
name|instack
index|[
name|indepth
operator|-
literal|1
index|]
decl_stmt|;
if|if
condition|(
name|if_stack
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|"if-less #elif"
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|if_stack
operator|->
name|type
operator|!=
name|T_IF
operator|&&
name|if_stack
operator|->
name|type
operator|!=
name|T_ELIF
condition|)
block|{
name|error
argument_list|(
literal|"#elif after #else"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" (matches line %d"
argument_list|,
name|if_stack
operator|->
name|lineno
argument_list|)
expr_stmt|;
if|if
condition|(
name|if_stack
operator|->
name|fname
operator|!=
name|NULL
operator|&&
name|ip
operator|->
name|fname
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
name|if_stack
operator|->
name|fname
argument_list|,
name|ip
operator|->
name|fname
argument_list|)
operator|!=
literal|0
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|", file %s"
argument_list|,
name|if_stack
operator|->
name|fname
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|")\n"
argument_list|)
expr_stmt|;
block|}
name|if_stack
operator|->
name|type
operator|=
name|T_ELIF
expr_stmt|;
block|}
name|value
operator|=
name|eval_if_expression
argument_list|(
name|buf
argument_list|,
name|limit
operator|-
name|buf
argument_list|)
expr_stmt|;
name|conditional_skip
argument_list|(
name|ip
argument_list|,
name|value
operator|==
literal|0
argument_list|,
name|T_ELIF
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * evaluate a #if expression in BUF, of length LENGTH,  * making careful arrangements to handle `defined' and  * prepare for calling the yacc parser.  */
end_comment

begin_function
specifier|static
name|int
name|eval_if_expression
parameter_list|(
name|buf
parameter_list|,
name|length
parameter_list|)
name|U_CHAR
modifier|*
name|buf
decl_stmt|;
name|int
name|length
decl_stmt|;
block|{
name|FILE_BUF
name|temp_ibuf
decl_stmt|,
name|temp_obuf
decl_stmt|;
name|HASHNODE
modifier|*
name|save_defined
decl_stmt|;
name|int
name|value
decl_stmt|;
name|bzero
argument_list|(
operator|&
name|temp_ibuf
argument_list|,
sizeof|sizeof
name|temp_ibuf
argument_list|)
expr_stmt|;
comment|/* paranoia */
name|temp_ibuf
operator|.
name|length
operator|=
name|length
expr_stmt|;
name|temp_ibuf
operator|.
name|buf
operator|=
name|temp_ibuf
operator|.
name|bufp
operator|=
name|buf
expr_stmt|;
name|temp_obuf
operator|.
name|length
operator|=
name|length
expr_stmt|;
name|temp_obuf
operator|.
name|bufp
operator|=
name|temp_obuf
operator|.
name|buf
operator|=
operator|(
name|U_CHAR
operator|*
operator|)
name|xmalloc
argument_list|(
name|length
argument_list|)
expr_stmt|;
name|save_defined
operator|=
name|install
argument_list|(
literal|"defined"
argument_list|,
name|T_SPEC_DEFINED
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|rescan
argument_list|(
operator|&
name|temp_ibuf
argument_list|,
operator|&
name|temp_obuf
argument_list|)
expr_stmt|;
operator|*
name|temp_obuf
operator|.
name|bufp
operator|=
literal|'\0'
expr_stmt|;
name|value
operator|=
name|parse_c_expression
argument_list|(
name|temp_obuf
operator|.
name|buf
argument_list|)
expr_stmt|;
name|delete
argument_list|(
name|save_defined
argument_list|)
expr_stmt|;
comment|/* clean up special symbol */
name|free
argument_list|(
name|temp_obuf
operator|.
name|buf
argument_list|)
expr_stmt|;
return|return
name|value
return|;
block|}
end_function

begin_comment
comment|/*  * routine to handle ifdef/ifndef.  Try to look up the symbol,  * then do or don't skip to the #endif/#else/#elif depending  * on what directive is actually being processed.  */
end_comment

begin_macro
name|do_xifdef
argument_list|(
argument|buf
argument_list|,
argument|limit
argument_list|,
argument|op
argument_list|,
argument|keyword
argument_list|)
end_macro

begin_decl_stmt
name|U_CHAR
modifier|*
name|buf
decl_stmt|,
modifier|*
name|limit
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE_BUF
modifier|*
name|op
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|keyword_table
modifier|*
name|keyword
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|HASHNODE
modifier|*
name|lookup
parameter_list|()
function_decl|;
name|int
name|skip
decl_stmt|;
name|FILE_BUF
modifier|*
name|ip
init|=
operator|&
name|instack
index|[
name|indepth
operator|-
literal|1
index|]
decl_stmt|;
name|SKIP_WHITE_SPACE
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|skip
operator|=
operator|(
name|lookup
argument_list|(
name|buf
argument_list|)
operator|==
name|NULL
operator|)
operator|^
operator|(
name|keyword
operator|->
name|type
operator|==
name|T_IFNDEF
operator|)
expr_stmt|;
name|conditional_skip
argument_list|(
name|ip
argument_list|,
name|skip
argument_list|,
name|T_IF
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * push TYPE on stack; then, if SKIP is nonzero, skip ahead.  */
end_comment

begin_expr_stmt
specifier|static
name|conditional_skip
argument_list|(
argument|ip
argument_list|,
argument|skip
argument_list|,
argument|type
argument_list|)
name|FILE_BUF
operator|*
name|ip
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|skip
decl_stmt|,
name|type
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|IF_STACK_FRAME
modifier|*
name|temp
decl_stmt|;
name|temp
operator|=
operator|(
name|IF_STACK_FRAME
operator|*
operator|)
name|xcalloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|IF_STACK_FRAME
argument_list|)
argument_list|)
expr_stmt|;
name|temp
operator|->
name|fname
operator|=
name|ip
operator|->
name|fname
expr_stmt|;
name|temp
operator|->
name|lineno
operator|=
name|ip
operator|->
name|lineno
expr_stmt|;
name|temp
operator|->
name|next
operator|=
name|if_stack
expr_stmt|;
name|if_stack
operator|=
name|temp
expr_stmt|;
name|if_stack
operator|->
name|type
operator|=
name|type
expr_stmt|;
if|if
condition|(
name|skip
operator|!=
literal|0
condition|)
block|{
name|skip_if_group
argument_list|(
name|ip
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
block|{
operator|++
name|if_stack
operator|->
name|if_succeeded
expr_stmt|;
name|output_line_command
argument_list|(
name|ip
argument_list|,
operator|&
name|outbuf
argument_list|)
expr_stmt|;
comment|/* JF */
block|}
block|}
end_block

begin_comment
comment|/*  * skip to #endif, #else, or #elif.  adjust line numbers, etc.  * leaves input ptr at the sharp sign found.  */
end_comment

begin_expr_stmt
specifier|static
name|skip_if_group
argument_list|(
argument|ip
argument_list|)
name|FILE_BUF
operator|*
name|ip
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|U_CHAR
modifier|*
name|bp
init|=
name|ip
operator|->
name|bufp
decl_stmt|,
modifier|*
name|cp
decl_stmt|;
specifier|register
name|U_CHAR
modifier|*
name|endb
init|=
name|ip
operator|->
name|buf
operator|+
name|ip
operator|->
name|length
decl_stmt|;
name|struct
name|keyword_table
modifier|*
name|kt
decl_stmt|;
name|U_CHAR
modifier|*
name|save_sharp
decl_stmt|,
modifier|*
name|skip_to_end_of_comment
argument_list|()
decl_stmt|,
modifier|*
name|skip_quoted_string
argument_list|()
decl_stmt|;
name|IF_STACK_FRAME
modifier|*
name|save_if_stack
init|=
name|if_stack
decl_stmt|;
comment|/* don't pop past here */
while|while
condition|(
name|bp
operator|<=
name|endb
condition|)
block|{
switch|switch
condition|(
operator|*
name|bp
operator|++
condition|)
block|{
case|case
literal|'/'
case|:
comment|/* possible comment */
if|if
condition|(
operator|*
name|bp
operator|==
literal|'*'
condition|)
block|{
name|ip
operator|->
name|bufp
operator|=
operator|++
name|bp
expr_stmt|;
name|bp
operator|=
name|skip_to_end_of_comment
argument_list|(
name|ip
argument_list|,
operator|&
name|ip
operator|->
name|lineno
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'\"'
case|:
case|case
literal|'\''
case|:
name|ip
operator|->
name|bufp
operator|=
name|bp
operator|-
literal|1
expr_stmt|;
name|bp
operator|=
name|skip_quoted_string
argument_list|(
name|ip
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* JF was (ip) */
break|break;
case|case
literal|'\n'
case|:
operator|++
name|ip
operator|->
name|lineno
expr_stmt|;
break|break;
case|case
literal|'#'
case|:
comment|/* # keyword: the # must be first nonblank char on the line */
for|for
control|(
name|cp
operator|=
name|bp
operator|-
literal|1
init|;
name|cp
operator|>=
name|ip
operator|->
name|buf
condition|;
name|cp
operator|--
control|)
if|if
condition|(
operator|*
name|cp
operator|==
literal|'\n'
condition|)
break|break;
name|cp
operator|++
expr_stmt|;
comment|/* skip nl or move back into buffer */
name|SKIP_WHITE_SPACE
argument_list|(
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|!=
name|bp
operator|-
literal|1
condition|)
comment|/* ????? */
break|break;
name|save_sharp
operator|=
name|cp
expr_stmt|;
comment|/* point at '#' */
name|SKIP_WHITE_SPACE
argument_list|(
name|bp
argument_list|)
expr_stmt|;
for|for
control|(
name|kt
operator|=
name|keyword_table
init|;
name|kt
operator|->
name|length
operator|>=
literal|0
condition|;
name|kt
operator|++
control|)
block|{
name|IF_STACK_FRAME
modifier|*
name|temp
decl_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|bp
argument_list|,
name|kt
operator|->
name|name
argument_list|,
name|kt
operator|->
name|length
argument_list|)
operator|==
literal|0
operator|&&
operator|!
name|is_idchar
index|[
name|bp
index|[
name|kt
operator|->
name|length
index|]
index|]
condition|)
block|{
switch|switch
condition|(
name|kt
operator|->
name|type
condition|)
block|{
case|case
name|T_IF
case|:
case|case
name|T_IFDEF
case|:
case|case
name|T_IFNDEF
case|:
name|temp
operator|=
operator|(
name|IF_STACK_FRAME
operator|*
operator|)
name|xcalloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|IF_STACK_FRAME
argument_list|)
argument_list|)
expr_stmt|;
name|temp
operator|->
name|next
operator|=
name|if_stack
expr_stmt|;
name|if_stack
operator|=
name|temp
expr_stmt|;
name|temp
operator|->
name|lineno
operator|=
name|ip
operator|->
name|lineno
expr_stmt|;
name|temp
operator|->
name|fname
operator|=
name|ip
operator|->
name|fname
expr_stmt|;
name|temp
operator|->
name|type
operator|=
name|kt
operator|->
name|type
expr_stmt|;
break|break;
case|case
name|T_ELSE
case|:
case|case
name|T_ELIF
case|:
case|case
name|T_ENDIF
case|:
name|ip
operator|->
name|bufp
operator|=
name|save_sharp
expr_stmt|;
if|if
condition|(
name|if_stack
operator|==
name|NULL
condition|)
block|{
name|U_CHAR
name|msg
index|[
literal|50
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|msg
argument_list|,
literal|"if-less #%s"
argument_list|,
name|kt
operator|->
name|name
argument_list|)
expr_stmt|;
name|error
argument_list|(
name|msg
argument_list|)
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|if_stack
operator|==
name|save_if_stack
condition|)
return|return;
comment|/* found what we came for */
if|if
condition|(
name|kt
operator|->
name|type
operator|!=
name|T_ENDIF
condition|)
block|{
if|if
condition|(
name|if_stack
operator|->
name|type
operator|==
name|T_ELSE
condition|)
name|error
argument_list|(
literal|"#else or #elif after #else"
argument_list|)
expr_stmt|;
name|if_stack
operator|->
name|type
operator|=
name|kt
operator|->
name|type
expr_stmt|;
break|break;
block|}
name|temp
operator|=
name|if_stack
expr_stmt|;
name|if_stack
operator|=
name|if_stack
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|temp
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
block|}
name|ip
operator|->
name|bufp
operator|=
name|bp
expr_stmt|;
name|ip
operator|->
name|lineno
operator|=
name|instack
operator|->
name|lineno
expr_stmt|;
comment|/* bufp won't be right, though */
name|error
argument_list|(
literal|"unterminated #if/#ifdef/#ifndef conditional"
argument_list|)
expr_stmt|;
comment|/* after this returns, the main loop will exit because ip->bufp      now points to the end of the buffer.  I am not sure whether      this is dirty or not. */
return|return;
block|}
end_block

begin_comment
comment|/*  * handle a #else directive.  Do this by just continuing processing  * without changing  if_stack ;  this is so that the error message  * for missing #endif's etc. will point to the original #if.  It  * is possible that something different would be better.  */
end_comment

begin_macro
name|do_else
argument_list|(
argument|buf
argument_list|,
argument|limit
argument_list|,
argument|op
argument_list|,
argument|keyword
argument_list|)
end_macro

begin_decl_stmt
name|U_CHAR
modifier|*
name|buf
decl_stmt|,
modifier|*
name|limit
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE_BUF
modifier|*
name|op
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|keyword_table
modifier|*
name|keyword
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|U_CHAR
modifier|*
name|bp
decl_stmt|;
name|FILE_BUF
modifier|*
name|ip
init|=
operator|&
name|instack
index|[
name|indepth
operator|-
literal|1
index|]
decl_stmt|;
if|if
condition|(
name|if_stack
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
literal|"if-less #else"
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
block|{
if|if
condition|(
name|if_stack
operator|->
name|type
operator|!=
name|T_IF
operator|&&
name|if_stack
operator|->
name|type
operator|!=
name|T_ELIF
condition|)
block|{
name|error
argument_list|(
literal|"#else after #else"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" (matches line %d"
argument_list|,
name|if_stack
operator|->
name|lineno
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|if_stack
operator|->
name|fname
argument_list|,
name|ip
operator|->
name|fname
argument_list|)
operator|!=
literal|0
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|", file %s"
argument_list|,
name|if_stack
operator|->
name|fname
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|")\n"
argument_list|)
expr_stmt|;
block|}
name|if_stack
operator|->
name|type
operator|=
name|T_ELSE
expr_stmt|;
block|}
if|if
condition|(
name|if_stack
operator|->
name|if_succeeded
condition|)
name|skip_if_group
argument_list|(
name|ip
argument_list|)
expr_stmt|;
else|else
block|{
operator|++
name|if_stack
operator|->
name|if_succeeded
expr_stmt|;
comment|/* continue processing input */
name|output_line_command
argument_list|(
name|ip
argument_list|,
name|op
argument_list|)
expr_stmt|;
comment|/* JF try to keep line #s right? */
block|}
block|}
end_block

begin_comment
comment|/*  * unstack after #endif command  */
end_comment

begin_macro
name|do_endif
argument_list|(
argument|buf
argument_list|,
argument|limit
argument_list|,
argument|op
argument_list|,
argument|keyword
argument_list|)
end_macro

begin_decl_stmt
name|U_CHAR
modifier|*
name|buf
decl_stmt|,
modifier|*
name|limit
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE_BUF
modifier|*
name|op
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|keyword_table
modifier|*
name|keyword
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|U_CHAR
modifier|*
name|bp
decl_stmt|;
if|if
condition|(
name|if_stack
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|"if-less #endif"
argument_list|)
expr_stmt|;
else|else
block|{
name|IF_STACK_FRAME
modifier|*
name|temp
init|=
name|if_stack
decl_stmt|;
name|if_stack
operator|=
name|if_stack
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|temp
argument_list|)
expr_stmt|;
comment|/* JF try to keep line #s right? */
name|output_line_command
argument_list|(
operator|&
name|instack
index|[
name|indepth
operator|-
literal|1
index|]
argument_list|,
name|op
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/*  * Skip a comment, assuming the input ptr immediately follows the  * initial slash-star.  Bump line counter as necessary.  * (The canonical line counter is&ip->lineno).  * Don't use this routine (or the next one) if bumping the line  * counter is not sufficient to deal with newlines in the string.  */
end_comment

begin_function
name|U_CHAR
modifier|*
name|skip_to_end_of_comment
parameter_list|(
name|ip
parameter_list|,
name|line_counter
parameter_list|)
specifier|register
name|FILE_BUF
modifier|*
name|ip
decl_stmt|;
name|int
modifier|*
name|line_counter
decl_stmt|;
comment|/* place to remember newlines, or NULL */
block|{
specifier|register
name|U_CHAR
modifier|*
name|limit
init|=
name|ip
operator|->
name|buf
operator|+
name|ip
operator|->
name|length
decl_stmt|;
specifier|register
name|U_CHAR
modifier|*
name|bp
init|=
name|ip
operator|->
name|bufp
decl_stmt|;
name|FILE_BUF
modifier|*
name|op
init|=
operator|&
name|outbuf
decl_stmt|;
comment|/* JF */
comment|/* JF this line_counter stuff is a crock to make sure the 	   comment is only put out once, no matter how many times 	   the comment is skipped.  It almost works */
if|if
condition|(
name|put_out_comments
operator|&&
operator|!
name|line_counter
condition|)
block|{
operator|*
name|op
operator|->
name|bufp
operator|++
operator|=
literal|'/'
expr_stmt|;
operator|*
name|op
operator|->
name|bufp
operator|++
operator|=
literal|'*'
expr_stmt|;
block|}
while|while
condition|(
name|bp
operator|<
name|limit
condition|)
block|{
if|if
condition|(
name|put_out_comments
operator|&&
operator|!
name|line_counter
condition|)
operator|*
name|op
operator|->
name|bufp
operator|++
operator|=
operator|*
name|bp
expr_stmt|;
switch|switch
condition|(
operator|*
name|bp
operator|++
condition|)
block|{
case|case
literal|'\n'
case|:
if|if
condition|(
name|line_counter
operator|!=
name|NULL
condition|)
operator|++
operator|*
name|line_counter
expr_stmt|;
break|break;
case|case
literal|'*'
case|:
if|if
condition|(
operator|*
name|bp
operator|==
literal|'/'
condition|)
block|{
if|if
condition|(
name|put_out_comments
operator|&&
operator|!
name|line_counter
condition|)
operator|*
name|op
operator|->
name|bufp
operator|++
operator|=
literal|'/'
expr_stmt|;
name|ip
operator|->
name|bufp
operator|=
operator|++
name|bp
expr_stmt|;
return|return
name|bp
return|;
block|}
break|break;
block|}
block|}
name|ip
operator|->
name|bufp
operator|=
name|bp
expr_stmt|;
return|return
name|bp
return|;
block|}
end_function

begin_comment
comment|/*  * skip over a quoted string.  Unlike skip_to_end_of_comment, this  * wants ip->bufp at the beginning quote, not after it.  this is so we  * can tell what kind of quote to match.  return if unescaped eol is  * encountered --- it is probably some sort of error in the input.  */
end_comment

begin_function
name|U_CHAR
modifier|*
name|skip_quoted_string
parameter_list|(
name|ip
parameter_list|,
name|count_newlines
parameter_list|)
specifier|register
name|FILE_BUF
modifier|*
name|ip
decl_stmt|;
name|int
name|count_newlines
decl_stmt|;
block|{
specifier|register
name|U_CHAR
modifier|*
name|limit
init|=
name|ip
operator|->
name|buf
operator|+
name|ip
operator|->
name|length
decl_stmt|;
specifier|register
name|U_CHAR
modifier|*
name|bp
init|=
name|ip
operator|->
name|bufp
decl_stmt|;
specifier|register
name|U_CHAR
name|c
decl_stmt|,
name|match
decl_stmt|;
name|match
operator|=
operator|*
name|bp
operator|++
expr_stmt|;
while|while
condition|(
name|bp
operator|<
name|limit
condition|)
block|{
name|c
operator|=
operator|*
name|bp
operator|++
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\\'
condition|)
block|{
if|if
condition|(
operator|*
name|bp
operator|++
operator|==
literal|'\n'
operator|&&
name|count_newlines
condition|)
operator|++
name|ip
operator|->
name|lineno
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
block|{
name|bp
operator|-=
literal|2
expr_stmt|;
comment|/* whoa!  back up to eol and punt. */
break|break;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
name|match
condition|)
break|break;
block|}
name|ip
operator|->
name|bufp
operator|=
name|bp
expr_stmt|;
return|return
name|bp
return|;
block|}
end_function

begin_comment
comment|/*  * write out a #line command, for instance, after an #include file.  */
end_comment

begin_expr_stmt
specifier|static
name|output_line_command
argument_list|(
argument|ip
argument_list|,
argument|op
argument_list|)
name|FILE_BUF
operator|*
name|ip
operator|,
operator|*
name|op
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|int
name|len
decl_stmt|,
name|line_cmd_buf
index|[
literal|500
index|]
decl_stmt|;
if|if
condition|(
name|ip
operator|->
name|fname
operator|==
name|NULL
condition|)
return|return;
ifdef|#
directive|ifdef
name|OUTPUT_LINE_COMMANDS
name|sprintf
argument_list|(
name|line_cmd_buf
argument_list|,
literal|"#line %d \"%s\"\n"
argument_list|,
name|ip
operator|->
name|lineno
argument_list|,
name|ip
operator|->
name|fname
argument_list|)
expr_stmt|;
else|#
directive|else
name|sprintf
argument_list|(
name|line_cmd_buf
argument_list|,
literal|"# %d \"%s\"\n"
argument_list|,
name|ip
operator|->
name|lineno
argument_list|,
name|ip
operator|->
name|fname
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|len
operator|=
name|strlen
argument_list|(
name|line_cmd_buf
argument_list|)
expr_stmt|;
name|check_expand
argument_list|(
name|op
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|op
operator|->
name|bufp
operator|>
name|op
operator|->
name|buf
operator|&&
name|op
operator|->
name|bufp
index|[
operator|-
literal|1
index|]
operator|!=
literal|'\n'
condition|)
comment|/* JF make sure */
operator|*
name|op
operator|->
name|bufp
operator|++
operator|=
literal|'\n'
expr_stmt|;
name|bcopy
argument_list|(
name|line_cmd_buf
argument_list|,
name|op
operator|->
name|bufp
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|op
operator|->
name|bufp
operator|+=
name|len
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Expand a macro call.    HP points to the symbol that is the macro being called.    IP is the input source for reading the arguments of the macro.    Send the result of the expansion to OP.    EXCESS_NEWLINES_PTR points to an integer;    we increment that integer once for each newline swallowed    in the process of reading this macro call.  */
end_comment

begin_macro
name|macroexpand
argument_list|(
argument|hp
argument_list|,
argument|ip
argument_list|,
argument|op
argument_list|,
argument|excess_newlines_ptr
argument_list|)
end_macro

begin_decl_stmt
name|HASHNODE
modifier|*
name|hp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE_BUF
modifier|*
name|ip
decl_stmt|,
modifier|*
name|op
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
modifier|*
name|excess_newlines_ptr
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|FILE_BUF
modifier|*
name|ip2
decl_stmt|;
name|int
name|nargs
decl_stmt|;
name|DEFINITION
modifier|*
name|defn
init|=
name|hp
operator|->
name|value
operator|.
name|defn
decl_stmt|;
name|int
name|newlines_found
init|=
literal|0
decl_stmt|;
comment|/* it might not actually be a macro.  */
if|if
condition|(
name|hp
operator|->
name|type
operator|!=
name|T_MACRO
condition|)
return|return
name|expand_special_symbol
argument_list|(
name|hp
argument_list|,
name|ip
argument_list|,
name|op
argument_list|)
return|;
name|ip2
operator|=
operator|&
name|instack
index|[
name|indepth
operator|++
index|]
expr_stmt|;
name|bzero
argument_list|(
name|ip2
argument_list|,
sizeof|sizeof
argument_list|(
name|FILE_BUF
argument_list|)
argument_list|)
expr_stmt|;
comment|/* paranoia */
name|nargs
operator|=
name|defn
operator|->
name|nargs
expr_stmt|;
if|if
condition|(
name|nargs
operator|>=
literal|0
condition|)
block|{
specifier|register
name|U_CHAR
modifier|*
name|bp
decl_stmt|,
modifier|*
name|xbuf
decl_stmt|;
name|U_CHAR
modifier|*
name|skip_macro_argument
parameter_list|()
function_decl|;
specifier|register
name|int
name|i
decl_stmt|;
name|int
name|xbuf_len
decl_stmt|;
name|int
name|offset
decl_stmt|;
comment|/* offset in expansion, 				   copied a piece at a time */
name|int
name|totlen
decl_stmt|;
comment|/* total amount of exp buffer filled so far */
specifier|register
name|struct
name|reflist
modifier|*
name|ap
decl_stmt|;
struct|struct
name|argptrs
block|{
name|U_CHAR
modifier|*
name|argstart
decl_stmt|;
name|int
name|length
decl_stmt|;
block|}
modifier|*
name|args
struct|;
name|args
operator|=
operator|(
expr|struct
name|argptrs
operator|*
operator|)
name|alloca
argument_list|(
operator|(
name|nargs
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|argptrs
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ip
operator|->
name|bufp
operator|>=
name|ip
operator|->
name|buf
operator|+
name|ip
operator|->
name|length
condition|)
block|{
comment|/* JF evil magic to make things work! */
name|ip
operator|=
operator|&
name|instack
index|[
name|indepth
operator|-
literal|3
index|]
expr_stmt|;
block|}
name|bp
operator|=
name|ip
operator|->
name|bufp
expr_stmt|;
comment|/* make sure it really was a macro call. */
if|if
condition|(
name|isspace
argument_list|(
name|bp
index|[
operator|-
literal|1
index|]
argument_list|)
condition|)
block|{
while|while
condition|(
name|isspace
argument_list|(
operator|*
name|bp
argument_list|)
condition|)
block|{
if|if
condition|(
operator|*
name|bp
operator|==
literal|'\n'
condition|)
operator|++
name|newlines_found
expr_stmt|;
name|bp
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|bp
operator|!=
literal|'('
condition|)
goto|goto
name|nope
goto|;
name|bp
operator|++
expr_stmt|;
comment|/* skip over the paren */
block|}
elseif|else
if|if
condition|(
operator|*
operator|(
name|bp
operator|-
literal|1
operator|)
operator|!=
literal|'('
condition|)
goto|goto
name|nope
goto|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nargs
condition|;
name|i
operator|++
control|)
block|{
name|args
index|[
name|i
index|]
operator|.
name|argstart
operator|=
name|bp
expr_stmt|;
name|bp
operator|=
name|skip_macro_argument
argument_list|(
name|bp
argument_list|,
name|ip
argument_list|,
operator|&
name|newlines_found
argument_list|)
expr_stmt|;
name|args
index|[
name|i
index|]
operator|.
name|length
operator|=
name|bp
operator|-
name|args
index|[
name|i
index|]
operator|.
name|argstart
expr_stmt|;
if|if
condition|(
operator|*
name|bp
operator|==
literal|','
condition|)
name|bp
operator|++
expr_stmt|;
block|}
name|args
index|[
name|nargs
index|]
operator|.
name|argstart
operator|=
name|bp
expr_stmt|;
if|if
condition|(
operator|*
name|bp
operator|++
operator|!=
literal|')'
condition|)
goto|goto
name|nope
goto|;
comment|/* make a rescan buffer with enough room for the pattern plus 	 all the arg strings. */
name|xbuf_len
operator|=
name|defn
operator|->
name|length
operator|+
literal|1
expr_stmt|;
for|for
control|(
name|ap
operator|=
name|defn
operator|->
name|pattern
init|;
name|ap
operator|!=
name|NULL
condition|;
name|ap
operator|=
name|ap
operator|->
name|next
control|)
name|xbuf_len
operator|+=
name|args
index|[
name|ap
operator|->
name|argno
operator|-
literal|1
index|]
operator|.
name|length
expr_stmt|;
name|xbuf
operator|=
operator|(
name|U_CHAR
operator|*
operator|)
name|alloca
argument_list|(
name|xbuf_len
argument_list|)
expr_stmt|;
name|offset
operator|=
name|totlen
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|ap
operator|=
name|defn
operator|->
name|pattern
init|;
name|ap
operator|!=
name|NULL
condition|;
name|ap
operator|=
name|ap
operator|->
name|next
control|)
block|{
name|bcopy
argument_list|(
name|defn
operator|->
name|expansion
operator|+
name|offset
argument_list|,
name|xbuf
operator|+
name|totlen
argument_list|,
name|ap
operator|->
name|nchars
argument_list|)
expr_stmt|;
name|totlen
operator|+=
name|ap
operator|->
name|nchars
expr_stmt|;
name|offset
operator|+=
name|ap
operator|->
name|nchars
expr_stmt|;
if|if
condition|(
name|ap
operator|->
name|argno
operator|>
literal|0
condition|)
block|{
name|bcopy
argument_list|(
name|args
index|[
name|ap
operator|->
name|argno
operator|-
literal|1
index|]
operator|.
name|argstart
argument_list|,
name|xbuf
operator|+
name|totlen
argument_list|,
name|args
index|[
name|ap
operator|->
name|argno
operator|-
literal|1
index|]
operator|.
name|length
argument_list|)
expr_stmt|;
name|totlen
operator|+=
name|args
index|[
name|ap
operator|->
name|argno
operator|-
literal|1
index|]
operator|.
name|length
expr_stmt|;
block|}
if|if
condition|(
name|totlen
operator|>
name|xbuf_len
condition|)
block|{
comment|/* impossible */
name|error
argument_list|(
literal|"cpp impossible internal error: expansion too large"
argument_list|)
expr_stmt|;
goto|goto
name|nope
goto|;
comment|/* this can't happen??? */
block|}
block|}
comment|/* if there is anything left after handling the arg list, 	 copy that in too. */
if|if
condition|(
name|offset
operator|<
name|defn
operator|->
name|length
condition|)
block|{
name|bcopy
argument_list|(
name|defn
operator|->
name|expansion
operator|+
name|offset
argument_list|,
name|xbuf
operator|+
name|totlen
argument_list|,
name|defn
operator|->
name|length
operator|-
name|offset
argument_list|)
expr_stmt|;
name|totlen
operator|+=
name|defn
operator|->
name|length
operator|-
name|offset
expr_stmt|;
block|}
name|ip2
operator|->
name|buf
operator|=
name|xbuf
expr_stmt|;
name|ip2
operator|->
name|length
operator|=
name|totlen
expr_stmt|;
comment|/* skip the input over the whole macro call. */
name|ip
operator|->
name|bufp
operator|=
name|bp
expr_stmt|;
block|}
else|else
block|{
name|ip2
operator|->
name|buf
operator|=
name|ip2
operator|->
name|bufp
operator|=
name|defn
operator|->
name|expansion
expr_stmt|;
name|ip2
operator|->
name|length
operator|=
name|defn
operator|->
name|length
expr_stmt|;
block|}
name|rescan
argument_list|(
name|ip2
argument_list|,
name|op
argument_list|)
expr_stmt|;
operator|--
name|indepth
expr_stmt|;
operator|*
name|excess_newlines_ptr
operator|+=
name|newlines_found
expr_stmt|;
name|ip
operator|->
name|lineno
operator|+=
name|newlines_found
expr_stmt|;
return|return
literal|0
return|;
name|nope
label|:
name|error
argument_list|(
literal|"argument mismatch"
argument_list|)
expr_stmt|;
operator|--
name|indepth
expr_stmt|;
return|return
literal|1
return|;
block|}
end_block

begin_comment
comment|/*  * skip a balanced paren string up to the next comma.  */
end_comment

begin_function
name|U_CHAR
modifier|*
name|skip_macro_argument
parameter_list|(
name|bp
parameter_list|,
name|ip
parameter_list|,
name|newlines
parameter_list|)
name|U_CHAR
modifier|*
name|bp
decl_stmt|;
name|FILE_BUF
modifier|*
name|ip
decl_stmt|;
name|int
modifier|*
name|newlines
decl_stmt|;
block|{
name|int
name|paren
init|=
literal|0
decl_stmt|;
name|int
name|quotec
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|bp
operator|<
name|ip
operator|->
name|buf
operator|+
name|ip
operator|->
name|length
condition|)
block|{
switch|switch
condition|(
operator|*
name|bp
condition|)
block|{
case|case
literal|'('
case|:
name|paren
operator|++
expr_stmt|;
break|break;
case|case
literal|')'
case|:
if|if
condition|(
operator|--
name|paren
operator|<
literal|0
condition|)
return|return
name|bp
return|;
break|break;
case|case
literal|'\n'
case|:
operator|++
operator|*
name|newlines
expr_stmt|;
break|break;
case|case
literal|'/'
case|:
if|if
condition|(
name|bp
index|[
literal|1
index|]
operator|!=
literal|'*'
operator|||
name|bp
operator|+
literal|1
operator|>=
name|ip
operator|->
name|buf
operator|+
name|ip
operator|->
name|length
condition|)
break|break;
name|bp
operator|+=
literal|2
expr_stmt|;
while|while
condition|(
operator|(
name|bp
index|[
literal|0
index|]
operator|!=
literal|'*'
operator|||
name|bp
index|[
literal|1
index|]
operator|!=
literal|'/'
operator|)
operator|&&
name|bp
operator|+
literal|1
operator|<
name|ip
operator|->
name|buf
operator|+
name|ip
operator|->
name|length
condition|)
block|{
if|if
condition|(
operator|*
name|bp
operator|==
literal|'\n'
condition|)
operator|++
operator|*
name|newlines
expr_stmt|;
name|bp
operator|++
expr_stmt|;
block|}
break|break;
case|case
literal|'\''
case|:
comment|/* JF handle quotes right  */
case|case
literal|'\"'
case|:
for|for
control|(
name|quotec
operator|=
operator|*
name|bp
operator|++
init|;
name|bp
operator|<
name|ip
operator|->
name|buf
operator|+
name|ip
operator|->
name|length
operator|&&
operator|*
name|bp
operator|!=
name|quotec
condition|;
name|bp
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|bp
operator|==
literal|'\\'
condition|)
name|bp
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|bp
operator|==
literal|'\n'
condition|)
operator|++
operator|*
name|newlines
expr_stmt|;
block|}
break|break;
case|case
literal|','
case|:
if|if
condition|(
name|paren
operator|==
literal|0
condition|)
return|return
name|bp
return|;
break|break;
block|}
name|bp
operator|++
expr_stmt|;
block|}
return|return
name|bp
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  * error - print out message.  also make print on stderr.  Uses stdout  * now for debugging convenience.  */
end_comment

begin_macro
name|error
argument_list|(
argument|msg
argument_list|)
end_macro

begin_decl_stmt
name|U_CHAR
modifier|*
name|msg
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|i
decl_stmt|;
name|FILE_BUF
modifier|*
name|ip
init|=
name|NULL
decl_stmt|;
for|for
control|(
name|i
operator|=
name|indepth
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|instack
index|[
name|i
index|]
operator|.
name|fname
operator|!=
name|NULL
condition|)
block|{
name|ip
operator|=
operator|&
name|instack
index|[
name|i
index|]
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|ip
operator|!=
name|NULL
condition|)
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"file %s, offset %d (line %d): "
argument_list|,
name|ip
operator|->
name|fname
argument_list|,
name|ip
operator|->
name|bufp
operator|-
name|ip
operator|->
name|buf
argument_list|,
name|ip
operator|->
name|lineno
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"%s\n"
argument_list|,
name|msg
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_block

begin_comment
comment|/*  * if OBUF doesn't have NEEDED bytes after OPTR, make it bigger  *    this should be a macro, for speed.  * The "expand" in the name of this routine means buffer expansion,  * not macro expansion.  It may become necessary to have some hacky  * mechanism for flushing out the output buffer if it gets too big.  *  * As things stand, nothing is ever placed in the output buffer to be  * removed again except when it's KNOWN to be part of an identifier,  * so flushing and moving down everything left, instead of expanding,  * should work ok.  */
end_comment

begin_function
name|U_CHAR
modifier|*
name|check_expand
parameter_list|(
name|obuf
parameter_list|,
name|needed
parameter_list|)
specifier|register
name|FILE_BUF
modifier|*
name|obuf
decl_stmt|;
specifier|register
name|int
name|needed
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|U_CHAR
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|obuf
operator|->
name|length
operator|-
operator|(
name|obuf
operator|->
name|bufp
operator|-
name|obuf
operator|->
name|buf
operator|)
operator|>
name|needed
condition|)
return|return
name|obuf
operator|->
name|buf
return|;
name|i
operator|=
literal|2
operator|*
name|obuf
operator|->
name|length
expr_stmt|;
if|if
condition|(
name|needed
operator|>=
name|i
condition|)
name|i
operator|+=
operator|(
literal|3
operator|*
name|needed
operator|)
operator|/
literal|2
expr_stmt|;
if|if
condition|(
operator|(
name|p
operator|=
operator|(
name|U_CHAR
operator|*
operator|)
name|xrealloc
argument_list|(
name|obuf
operator|->
name|buf
argument_list|,
name|i
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|obuf
operator|->
name|bufp
operator|=
name|p
operator|+
operator|(
name|obuf
operator|->
name|bufp
operator|-
name|obuf
operator|->
name|buf
operator|)
expr_stmt|;
name|obuf
operator|->
name|buf
operator|=
name|p
expr_stmt|;
name|obuf
operator|->
name|length
operator|=
name|i
expr_stmt|;
return|return
name|p
return|;
block|}
end_function

begin_comment
comment|/*  * install a name in the main hash table, even if it is already there.  *   name stops with first non alphanumeric, except leading '#'.  * caller must check against redefinition if that is desired.  * delete() removes things installed by install() in fifo order.  * this is important because of the `defined' special symbol used  * in #if, and also if pushdef/popdef directives are ever implemented.  */
end_comment

begin_function
name|HASHNODE
modifier|*
name|install
parameter_list|(
name|name
parameter_list|,
name|type
parameter_list|,
name|value
parameter_list|)
name|U_CHAR
modifier|*
name|name
decl_stmt|;
name|int
name|type
decl_stmt|;
name|int
name|value
decl_stmt|;
comment|/* watch out here if sizeof(U_CHAR *) != sizeof (int) */
block|{
name|HASHNODE
modifier|*
name|hp
decl_stmt|;
name|int
name|i
decl_stmt|,
name|len
init|=
literal|0
decl_stmt|,
name|bucket
decl_stmt|;
specifier|register
name|U_CHAR
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|name
expr_stmt|;
while|while
condition|(
name|is_idchar
index|[
operator|*
name|p
index|]
condition|)
name|p
operator|++
expr_stmt|;
name|len
operator|=
name|p
operator|-
name|name
expr_stmt|;
name|i
operator|=
sizeof|sizeof
argument_list|(
name|HASHNODE
argument_list|)
operator|+
name|len
operator|+
literal|1
expr_stmt|;
name|hp
operator|=
operator|(
name|HASHNODE
operator|*
operator|)
name|xmalloc
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|bucket
operator|=
name|hashf
argument_list|(
name|name
argument_list|,
name|len
argument_list|,
name|HASHSIZE
argument_list|)
expr_stmt|;
name|hp
operator|->
name|bucket_hdr
operator|=
operator|&
name|hashtab
index|[
name|bucket
index|]
expr_stmt|;
name|hp
operator|->
name|next
operator|=
name|hashtab
index|[
name|bucket
index|]
expr_stmt|;
name|hashtab
index|[
name|bucket
index|]
operator|=
name|hp
expr_stmt|;
name|hp
operator|->
name|prev
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|hp
operator|->
name|next
operator|!=
name|NULL
condition|)
name|hp
operator|->
name|next
operator|->
name|prev
operator|=
name|hp
expr_stmt|;
name|hp
operator|->
name|type
operator|=
name|type
expr_stmt|;
name|hp
operator|->
name|length
operator|=
name|len
expr_stmt|;
name|hp
operator|->
name|value
operator|.
name|ival
operator|=
name|value
expr_stmt|;
name|hp
operator|->
name|name
operator|=
operator|(
operator|(
name|U_CHAR
operator|*
operator|)
name|hp
operator|)
operator|+
sizeof|sizeof
argument_list|(
name|HASHNODE
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|name
argument_list|,
name|hp
operator|->
name|name
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
name|hp
return|;
block|}
end_function

begin_comment
comment|/*  * find the most recent hash node for name name (ending with first  * non-identifier char) installed by install  */
end_comment

begin_function
name|HASHNODE
modifier|*
name|lookup
parameter_list|(
name|name
parameter_list|)
name|U_CHAR
modifier|*
name|name
decl_stmt|;
block|{
specifier|register
name|U_CHAR
modifier|*
name|bp
decl_stmt|;
specifier|register
name|HASHNODE
modifier|*
name|bucket
decl_stmt|;
name|int
name|len
decl_stmt|;
for|for
control|(
name|bp
operator|=
name|name
init|;
name|is_idchar
index|[
operator|*
name|bp
index|]
condition|;
name|bp
operator|++
control|)
empty_stmt|;
name|len
operator|=
name|bp
operator|-
name|name
expr_stmt|;
name|bucket
operator|=
name|hashtab
index|[
name|hashf
argument_list|(
name|name
argument_list|,
name|len
argument_list|,
name|HASHSIZE
argument_list|)
index|]
expr_stmt|;
while|while
condition|(
name|bucket
condition|)
block|{
if|if
condition|(
name|bucket
operator|->
name|length
operator|==
name|len
operator|&&
name|strncmp
argument_list|(
name|bucket
operator|->
name|name
argument_list|,
name|name
argument_list|,
name|len
argument_list|)
operator|==
literal|0
condition|)
return|return
name|bucket
return|;
name|bucket
operator|=
name|bucket
operator|->
name|next
expr_stmt|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/*  * Delete a hash node.  Some weirdness to free junk from macros.  * More such weirdness will have to be added if you define more hash  * types that need it.  */
end_comment

begin_macro
name|delete
argument_list|(
argument|hp
argument_list|)
end_macro

begin_decl_stmt
name|HASHNODE
modifier|*
name|hp
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|hp
operator|->
name|prev
operator|!=
name|NULL
condition|)
name|hp
operator|->
name|prev
operator|->
name|next
operator|=
name|hp
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|hp
operator|->
name|next
operator|!=
name|NULL
condition|)
name|hp
operator|->
name|next
operator|->
name|prev
operator|=
name|hp
operator|->
name|prev
expr_stmt|;
comment|/* make sure that the bucket chain header that      the deleted guy was on points to the right thing afterwards. */
if|if
condition|(
name|hp
operator|==
operator|*
name|hp
operator|->
name|bucket_hdr
condition|)
operator|*
name|hp
operator|->
name|bucket_hdr
operator|=
name|hp
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|hp
operator|->
name|type
operator|==
name|T_MACRO
condition|)
block|{
name|DEFINITION
modifier|*
name|d
init|=
name|hp
operator|->
name|value
operator|.
name|defn
decl_stmt|;
name|struct
name|reflist
modifier|*
name|ap
decl_stmt|,
modifier|*
name|nextap
decl_stmt|;
for|for
control|(
name|ap
operator|=
name|d
operator|->
name|pattern
init|;
name|ap
operator|!=
name|NULL
condition|;
name|ap
operator|=
name|nextap
control|)
block|{
name|nextap
operator|=
name|ap
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|ap
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|d
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  * return hash function on name.  must be compatible with the one  * computed a step at a time, elsewhere  */
end_comment

begin_function
name|int
name|hashf
parameter_list|(
name|name
parameter_list|,
name|len
parameter_list|,
name|hashsize
parameter_list|)
specifier|register
name|U_CHAR
modifier|*
name|name
decl_stmt|;
specifier|register
name|int
name|len
decl_stmt|;
name|int
name|hashsize
decl_stmt|;
block|{
specifier|register
name|int
name|r
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|len
operator|--
condition|)
name|r
operator|=
name|HASHSTEP
argument_list|(
name|r
argument_list|,
operator|*
name|name
operator|++
argument_list|)
expr_stmt|;
return|return
name|MAKE_POS
argument_list|(
name|r
argument_list|)
operator|%
name|hashsize
return|;
block|}
end_function

begin_comment
comment|/*  * initialize random junk in the hash table and maybe other places  */
end_comment

begin_macro
name|initialize_random_junk
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
comment|/*    * Set up is_idchar and is_idstart tables.  These should be    * faster than saying (is_alpha(c) || c == '_'), etc.    * Must do set up these things before calling any routines tthat    * refer to them.    */
for|for
control|(
name|i
operator|=
literal|'a'
init|;
name|i
operator|<=
literal|'z'
condition|;
name|i
operator|++
control|)
block|{
operator|++
name|is_idchar
index|[
name|i
operator|-
literal|'a'
operator|+
literal|'A'
index|]
expr_stmt|;
operator|++
name|is_idchar
index|[
name|i
index|]
expr_stmt|;
operator|++
name|is_idstart
index|[
name|i
operator|-
literal|'a'
operator|+
literal|'A'
index|]
expr_stmt|;
operator|++
name|is_idstart
index|[
name|i
index|]
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|'0'
init|;
name|i
operator|<=
literal|'9'
condition|;
name|i
operator|++
control|)
operator|++
name|is_idchar
index|[
name|i
index|]
expr_stmt|;
operator|++
name|is_idchar
index|[
literal|'_'
index|]
expr_stmt|;
operator|++
name|is_idstart
index|[
literal|'_'
index|]
expr_stmt|;
comment|/* horizontal space table */
operator|++
name|is_hor_space
index|[
literal|' '
index|]
expr_stmt|;
operator|++
name|is_hor_space
index|[
literal|'\t'
index|]
expr_stmt|;
name|install
argument_list|(
literal|"__LINE__"
argument_list|,
name|T_SPECLINE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|install
argument_list|(
literal|"__DATE__"
argument_list|,
name|T_DATE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|install
argument_list|(
literal|"__FILE__"
argument_list|,
name|T_FILE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|install
argument_list|(
literal|"__TIME__"
argument_list|,
name|T_TIME
argument_list|,
literal|0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|vax
name|make_definition
argument_list|(
literal|"vax 1"
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|unix
name|make_definition
argument_list|(
literal|"unix 1"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* is there more? */
block|}
end_block

begin_comment
comment|/*  * process a given definition string, for initialization  */
end_comment

begin_macro
name|make_definition
argument_list|(
argument|str
argument_list|)
end_macro

begin_decl_stmt
name|U_CHAR
modifier|*
name|str
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|FILE_BUF
modifier|*
name|ip
decl_stmt|;
name|struct
name|keyword_table
modifier|*
name|kt
decl_stmt|;
name|ip
operator|=
operator|&
name|instack
index|[
name|indepth
operator|++
index|]
expr_stmt|;
name|ip
operator|->
name|fname
operator|=
literal|"*Initialization*"
expr_stmt|;
name|ip
operator|->
name|buf
operator|=
name|ip
operator|->
name|bufp
operator|=
name|str
expr_stmt|;
name|ip
operator|->
name|length
operator|=
name|strlen
argument_list|(
name|str
argument_list|)
expr_stmt|;
name|ip
operator|->
name|lineno
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|kt
operator|=
name|keyword_table
init|;
name|kt
operator|->
name|type
operator|!=
name|T_DEFINE
condition|;
name|kt
operator|++
control|)
empty_stmt|;
comment|/* pass NULL as output ptr to do_define since we KNOW it never      does any output.... */
name|do_define
argument_list|(
name|str
argument_list|,
name|str
operator|+
name|strlen
argument_list|(
name|str
argument_list|)
comment|/* - 1 JF */
argument_list|,
name|NULL
argument_list|,
name|kt
argument_list|)
expr_stmt|;
operator|--
name|indepth
expr_stmt|;
block|}
end_block

begin_comment
comment|/* JF, this does the work for the -U option */
end_comment

begin_macro
name|make_undef
argument_list|(
argument|str
argument_list|)
end_macro

begin_decl_stmt
name|U_CHAR
modifier|*
name|str
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|FILE_BUF
modifier|*
name|ip
decl_stmt|;
name|struct
name|keyword_table
modifier|*
name|kt
decl_stmt|;
name|ip
operator|=
operator|&
name|instack
index|[
name|indepth
operator|++
index|]
expr_stmt|;
name|ip
operator|->
name|fname
operator|=
literal|"*undef*"
expr_stmt|;
name|ip
operator|->
name|buf
operator|=
name|ip
operator|->
name|bufp
operator|=
name|str
expr_stmt|;
name|ip
operator|->
name|length
operator|=
name|strlen
argument_list|(
name|str
argument_list|)
expr_stmt|;
name|ip
operator|->
name|lineno
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|kt
operator|=
name|keyword_table
init|;
name|kt
operator|->
name|type
operator|!=
name|T_UNDEF
condition|;
name|kt
operator|++
control|)
empty_stmt|;
name|do_undef
argument_list|(
name|str
argument_list|,
name|str
operator|+
name|strlen
argument_list|(
name|str
argument_list|)
operator|-
literal|1
argument_list|,
name|NULL
argument_list|,
name|kt
argument_list|)
expr_stmt|;
operator|--
name|indepth
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_ifndef
ifndef|#
directive|ifndef
name|BSD
end_ifndef

begin_ifndef
ifndef|#
directive|ifndef
name|BSTRING
end_ifndef

begin_function
name|void
name|bzero
parameter_list|(
name|b
parameter_list|,
name|length
parameter_list|)
specifier|register
name|char
modifier|*
name|b
decl_stmt|;
specifier|register
name|int
name|length
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|VMS
name|short
name|zero
init|=
literal|0
decl_stmt|;
name|long
name|max_str
init|=
literal|65535
decl_stmt|;
while|while
condition|(
name|length
operator|>
name|max_str
condition|)
block|{
operator|(
name|void
operator|)
name|LIB$MOVC5
argument_list|(
operator|&
name|zero
argument_list|,
operator|&
name|zero
argument_list|,
operator|&
name|zero
argument_list|,
operator|&
name|max_str
argument_list|,
name|b
argument_list|)
expr_stmt|;
name|length
operator|-=
name|max_str
expr_stmt|;
name|b
operator|+=
name|max_str
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|LIB$MOVC5
argument_list|(
operator|&
name|zero
argument_list|,
operator|&
name|zero
argument_list|,
operator|&
name|zero
argument_list|,
operator|&
name|length
argument_list|,
name|b
argument_list|)
expr_stmt|;
else|#
directive|else
while|while
condition|(
name|length
operator|--
operator|>
literal|0
condition|)
operator|*
name|b
operator|++
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
comment|/* not VMS */
block|}
end_function

begin_function
name|void
name|bcopy
parameter_list|(
name|b1
parameter_list|,
name|b2
parameter_list|,
name|length
parameter_list|)
specifier|register
name|char
modifier|*
name|b1
decl_stmt|;
specifier|register
name|char
modifier|*
name|b2
decl_stmt|;
specifier|register
name|int
name|length
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|VMS
name|long
name|max_str
init|=
literal|65535
decl_stmt|;
while|while
condition|(
name|length
operator|>
name|max_str
condition|)
block|{
operator|(
name|void
operator|)
name|LIB$MOVC3
argument_list|(
operator|&
name|max_str
argument_list|,
name|b1
argument_list|,
name|b2
argument_list|)
expr_stmt|;
name|length
operator|-=
name|max_str
expr_stmt|;
name|b1
operator|+=
name|max_str
expr_stmt|;
name|b2
operator|+=
name|max_str
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|LIB$MOVC3
argument_list|(
operator|&
name|length
argument_list|,
name|b1
argument_list|,
name|b2
argument_list|)
expr_stmt|;
else|#
directive|else
while|while
condition|(
name|length
operator|--
operator|>
literal|0
condition|)
operator|*
name|b2
operator|++
operator|=
operator|*
name|b1
operator|++
expr_stmt|;
endif|#
directive|endif
comment|/* not VMS */
block|}
end_function

begin_function
name|int
name|bcmp
parameter_list|(
name|b1
parameter_list|,
name|b2
parameter_list|,
name|length
parameter_list|)
comment|/* This could be a macro! */
specifier|register
name|char
modifier|*
name|b1
decl_stmt|;
specifier|register
name|char
modifier|*
name|b2
decl_stmt|;
specifier|register
name|int
name|length
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|VMS
name|struct
name|dsc$descriptor_s
name|src1
init|=
block|{
name|length
block|,
name|DSC$K_DTYPE_T
block|,
name|DSC$K_CLASS_S
block|,
name|b1
block|}
decl_stmt|;
name|struct
name|dsc$descriptor_s
name|src2
init|=
block|{
name|length
block|,
name|DSC$K_DTYPE_T
block|,
name|DSC$K_CLASS_S
block|,
name|b2
block|}
decl_stmt|;
return|return
name|STR$COMPARE
argument_list|(
operator|&
name|src1
argument_list|,
operator|&
name|src2
argument_list|)
return|;
else|#
directive|else
while|while
condition|(
name|length
operator|--
operator|>
literal|0
condition|)
if|if
condition|(
operator|*
name|b1
operator|++
operator|!=
operator|*
name|b2
operator|++
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
endif|#
directive|endif
comment|/* not VMS */
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not BSTRING */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not BSD */
end_comment

begin_escape
end_escape

begin_function
name|void
name|fatal
parameter_list|(
name|str
parameter_list|,
name|arg
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|,
decl|*
name|arg
decl_stmt|;
end_function

begin_block
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: "
argument_list|,
name|progname
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|str
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|FATAL_EXIT_CODE
argument_list|)
expr_stmt|;
block|}
end_block

begin_function
name|void
name|perror_with_name
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
specifier|extern
name|int
name|errno
decl_stmt|,
name|sys_nerr
decl_stmt|;
specifier|extern
name|char
modifier|*
name|sys_errlist
index|[]
decl_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: "
argument_list|,
name|progname
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
operator|<
name|sys_nerr
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s for %s\n"
argument_list|,
name|sys_errlist
index|[
name|errno
index|]
argument_list|,
name|name
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"cannot open %s\n"
argument_list|,
name|sys_errlist
index|[
name|errno
index|]
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|pfatal_with_name
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|perror_with_name
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|FATAL_EXIT_CODE
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|void
name|memory_full
parameter_list|()
block|{
name|fatal
argument_list|(
literal|"Memory exhausted."
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|char
modifier|*
name|xmalloc
parameter_list|(
name|size
parameter_list|)
name|int
name|size
decl_stmt|;
block|{
specifier|extern
name|char
modifier|*
name|malloc
parameter_list|()
function_decl|;
specifier|register
name|char
modifier|*
name|ptr
init|=
name|malloc
argument_list|(
name|size
argument_list|)
decl_stmt|;
if|if
condition|(
name|ptr
operator|!=
literal|0
condition|)
return|return
operator|(
name|ptr
operator|)
return|;
name|memory_full
argument_list|()
expr_stmt|;
comment|/*NOTREACHED*/
block|}
end_function

begin_function
name|char
modifier|*
name|xrealloc
parameter_list|(
name|old
parameter_list|,
name|size
parameter_list|)
name|char
modifier|*
name|old
decl_stmt|;
name|int
name|size
decl_stmt|;
block|{
specifier|extern
name|char
modifier|*
name|realloc
parameter_list|()
function_decl|;
specifier|register
name|char
modifier|*
name|ptr
init|=
name|realloc
argument_list|(
name|old
argument_list|,
name|size
argument_list|)
decl_stmt|;
if|if
condition|(
name|ptr
operator|!=
literal|0
condition|)
return|return
operator|(
name|ptr
operator|)
return|;
name|memory_full
argument_list|()
expr_stmt|;
comment|/*NOTREACHED*/
block|}
end_function

begin_function
name|char
modifier|*
name|xcalloc
parameter_list|(
name|number
parameter_list|,
name|size
parameter_list|)
name|int
name|number
decl_stmt|,
name|size
decl_stmt|;
block|{
specifier|extern
name|char
modifier|*
name|malloc
parameter_list|()
function_decl|;
specifier|register
name|int
name|total
init|=
name|number
operator|*
name|size
decl_stmt|;
specifier|register
name|char
modifier|*
name|ptr
init|=
name|malloc
argument_list|(
name|total
argument_list|)
decl_stmt|;
if|if
condition|(
name|ptr
operator|!=
literal|0
condition|)
block|{
name|bzero
argument_list|(
name|ptr
argument_list|,
name|total
argument_list|)
expr_stmt|;
return|return
operator|(
name|ptr
operator|)
return|;
block|}
name|memory_full
argument_list|()
expr_stmt|;
comment|/*NOTREACHED*/
block|}
end_function

end_unit

