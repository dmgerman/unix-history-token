begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Copyright (C) 1985, 1986, 1987, 1988 Free Software Foundation, Inc.      This program is free software; you can redistribute it and/or modify     it under the terms of the GNU General Public License as published by     the Free Software Foundation; either version 1, or (at your option)     any later version.      This program is distributed in the hope that it will be useful,     but WITHOUT ANY WARRANTY; without even the implied warranty of     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the     GNU General Public License for more details.      You should have received a copy of the GNU General Public License     along with this program; if not, write to the Free Software     Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  In other words, you are welcome to use, share and improve this program. You are forbidden to forbid anyone else to use, share and improve what you give them.   Help stamp out software-hoarding!  */
end_comment

begin_comment
comment|/*  * unexec.c - Convert a running program into an a.out file.  *  * Author:	Spencer W. Thomas  * 		Computer Science Dept.  * 		University of Utah  * Date:	Tue Mar  2 1982  * Modified heavily since then.  *  * Synopsis:  *	unexec (new_name, a_name, data_start, bss_start, entry_address)  *	char *new_name, *a_name;  *	unsigned data_start, bss_start, entry_address;  *  * Takes a snapshot of the program and makes an a.out format file in the  * file named by the string argument new_name.  * If a_name is non-NULL, the symbol table will be taken from the given file.  * On some machines, an existing a_name file is required.  *  * The boundaries within the a.out file may be adjusted with the data_start  * and bss_start arguments.  Either or both may be given as 0 for defaults.  *  * Data_start gives the boundary between the text segment and the data  * segment of the program.  The text segment can contain shared, read-only  * program code and literal data, while the data segment is always unshared  * and unprotected.  Data_start gives the lowest unprotected address.  * The value you specify may be rounded down to a suitable boundary  * as required by the machine you are using.  *  * Specifying zero for data_start means the boundary between text and data  * should not be the same as when the program was loaded.  * If NO_REMAP is defined, the argument data_start is ignored and the  * segment boundaries are never changed.  *  * Bss_start indicates how much of the data segment is to be saved in the  * a.out file and restored when the program is executed.  It gives the lowest  * unsaved address, and is rounded up to a page boundary.  The default when 0  * is given assumes that the entire data segment is to be stored, including  * the previous data and bss as well as any additional storage allocated with  * break (2).  *  * The new file is set up to start at entry_address.  *  * If you make improvements I'd like to get them too.  * harpo!utah-cs!thomas, thomas@Utah-20  *  */
end_comment

begin_comment
comment|/* Even more heavily modified by james@bigtex.cactus.org of Dell Computer Co.  * ELF support added.  *  * Basic theory: the data space of the running process needs to be  * dumped to the output file.  Normally we would just enlarge the size  * of .data, scooting everything down.  But we can't do that in ELF,  * because there is often something between the .data space and the  * .bss space.  *  * In the temacs dump below, notice that the Global Offset Table  * (.got) and the Dynamic link data (.dynamic) come between .data1 and  * .bss.  It does not work to overlap .data with these fields.  *  * The solution is to create a new .data segment.  This segment is  * filled with data from the current process.  Since the contents of  * various sections refer to sections by index, the new .data segment  * is made the last in the table to avoid changing any existing index.   * This is an example of how the section headers are changed.  "Addr"  * is a process virtual address.  "Offset" is a file offset.  raid:/nfs/raid/src/dist-18.56/src> dump -h temacs  temacs:             **** SECTION HEADER TABLE **** [No]    Type    Flags   Addr         Offset       Size          Name         Link    Info    Adralgn      Entsize  [1]     1       2       0x80480d4    0xd4         0x13          .interp         0       0       0x1          0              [2]     5       2       0x80480e8    0xe8         0x388         .hash         3       0       0x4          0x4            [3]     11      2       0x8048470    0x470        0x7f0         .dynsym         4       1       0x4          0x10           [4]     3       2       0x8048c60    0xc60        0x3ad         .dynstr         0       0       0x1          0              [5]     9       2       0x8049010    0x1010       0x338         .rel.plt         3       7       0x4          0x8            [6]     1       6       0x8049348    0x1348       0x3           .init         0       0       0x4          0              [7]     1       6       0x804934c    0x134c       0x680         .plt         0       0       0x4          0x4            [8]     1       6       0x80499cc    0x19cc       0x3c56f       .text         0       0       0x4          0              [9]     1       6       0x8085f3c    0x3df3c      0x3           .fini         0       0       0x4          0              [10]    1       2       0x8085f40    0x3df40      0x69c         .rodata         0       0       0x4          0              [11]    1       2       0x80865dc    0x3e5dc      0xd51         .rodata1         0       0       0x4          0              [12]    1       3       0x8088330    0x3f330      0x20afc       .data         0       0       0x4          0              [13]    1       3       0x80a8e2c    0x5fe2c      0x89d         .data1         0       0       0x4          0              [14]    1       3       0x80a96cc    0x606cc      0x1a8         .got         0       0       0x4          0x4            [15]    6       3       0x80a9874    0x60874      0x80          .dynamic         4       0       0x4          0x8            [16]    8       3       0x80a98f4    0x608f4      0x449c        .bss         0       0       0x4          0              [17]    2       0       0            0x608f4      0x9b90        .symtab         18      371     0x4          0x10           [18]    3       0       0            0x6a484      0x8526        .strtab         0       0       0x1          0              [19]    3       0       0            0x729aa      0x93          .shstrtab         0       0       0x1          0              [20]    1       0       0            0x72a3d      0x68b7        .comment         0       0       0x1          0              raid:/nfs/raid/src/dist-18.56/src> dump -h xemacs  xemacs:             **** SECTION HEADER TABLE **** [No]    Type    Flags   Addr         Offset       Size          Name         Link    Info    Adralgn      Entsize  [1]     1       2       0x80480d4    0xd4         0x13          .interp         0       0       0x1          0              [2]     5       2       0x80480e8    0xe8         0x388         .hash         3       0       0x4          0x4            [3]     11      2       0x8048470    0x470        0x7f0         .dynsym         4       1       0x4          0x10           [4]     3       2       0x8048c60    0xc60        0x3ad         .dynstr         0       0       0x1          0              [5]     9       2       0x8049010    0x1010       0x338         .rel.plt         3       7       0x4          0x8            [6]     1       6       0x8049348    0x1348       0x3           .init         0       0       0x4          0              [7]     1       6       0x804934c    0x134c       0x680         .plt         0       0       0x4          0x4            [8]     1       6       0x80499cc    0x19cc       0x3c56f       .text         0       0       0x4          0              [9]     1       6       0x8085f3c    0x3df3c      0x3           .fini         0       0       0x4          0              [10]    1       2       0x8085f40    0x3df40      0x69c         .rodata         0       0       0x4          0              [11]    1       2       0x80865dc    0x3e5dc      0xd51         .rodata1         0       0       0x4          0              [12]    1       3       0x8088330    0x3f330      0x20afc       .data         0       0       0x4          0              [13]    1       3       0x80a8e2c    0x5fe2c      0x89d         .data1         0       0       0x4          0              [14]    1       3       0x80a96cc    0x606cc      0x1a8         .got         0       0       0x4          0x4            [15]    6       3       0x80a9874    0x60874      0x80          .dynamic         4       0       0x4          0x8            [16]    8       3       0x80c6800    0x7d800      0             .bss         0       0       0x4          0              [17]    2       0       0            0x7d800      0x9b90        .symtab         18      371     0x4          0x10           [18]    3       0       0            0x87390      0x8526        .strtab         0       0       0x1          0              [19]    3       0       0            0x8f8b6      0x93          .shstrtab         0       0       0x1          0              [20]    1       0       0            0x8f949      0x68b7        .comment         0       0       0x1          0              [21]    1       3       0x80a98f4    0x608f4      0x1cf0c       .data         0       0       0x4          0               * This is an example of how the file header is changed.  "Shoff" is  * the section header offset within the file.  Since that table is  * after the new .data section, it is moved.  "Shnum" is the number of  * sections, which we increment.  *  * "Phoff" is the file offset to the program header.  "Phentsize" and  * "Shentsz" are the program and section header entries sizes respectively.  * These can be larger than the apparent struct sizes.  raid:/nfs/raid/src/dist-18.56/src> dump -f temacs  temacs:                      **** ELF HEADER **** Class        Data       Type         Machine     Version Entry        Phoff      Shoff        Flags       Ehsize Phentsize    Phnum      Shentsz      Shnum       Shstrndx  1            1          2            3           1 0x80499cc    0x34       0x792f4      0           0x34 0x20         5          0x28         21          19  raid:/nfs/raid/src/dist-18.56/src> dump -f xemacs  xemacs:                      **** ELF HEADER **** Class        Data       Type         Machine     Version Entry        Phoff      Shoff        Flags       Ehsize Phentsize    Phnum      Shentsz      Shnum       Shstrndx  1            1          2            3           1 0x80499cc    0x34       0x96200      0           0x34 0x20         5          0x28         22          19   * These are the program headers.  "Offset" is the file offset to the  * segment.  "Vaddr" is the memory load address.  "Filesz" is the  * segment size as it appears in the file, and "Memsz" is the size in  * memory.  Below, the third segment is the code and the fourth is the  * data: the difference between Filesz and Memsz is .bss  raid:/nfs/raid/src/dist-18.56/src> dump -o temacs  temacs:  ***** PROGRAM EXECUTION HEADER ***** Type        Offset      Vaddr       Paddr Filesz      Memsz       Flags       Align  6           0x34        0x8048034   0            0xa0        0xa0        5           0             3           0xd4        0           0            0x13        0           4           0             1           0x34        0x8048034   0            0x3f2f9     0x3f2f9     5           0x1000        1           0x3f330     0x8088330   0            0x215c4     0x25a60     7           0x1000        2           0x60874     0x80a9874   0            0x80        0           7           0             raid:/nfs/raid/src/dist-18.56/src> dump -o xemacs  xemacs:  ***** PROGRAM EXECUTION HEADER ***** Type        Offset      Vaddr       Paddr Filesz      Memsz       Flags       Align  6           0x34        0x8048034   0            0xa0        0xa0        5           0             3           0xd4        0           0            0x13        0           4           0             1           0x34        0x8048034   0            0x3f2f9     0x3f2f9     5           0x1000        1           0x3f330     0x8088330   0            0x3e4d0     0x3e4d0     7           0x1000        2           0x60874     0x80a9874   0            0x80        0           7           0               */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<memory.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<elf.h>
end_include

begin_include
include|#
directive|include
file|<sys/mman.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|emacs
end_ifndef

begin_define
define|#
directive|define
name|fatal
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|,
name|c
parameter_list|)
value|fprintf(stderr, a, b, c), exit(1)
end_define

begin_else
else|#
directive|else
end_else

begin_function_decl
specifier|extern
name|void
name|fatal
parameter_list|(
name|char
modifier|*
parameter_list|,
modifier|...
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Get the address of a particular section or program header entry,  * accounting for the size of the entries.  */
end_comment

begin_define
define|#
directive|define
name|OLD_SECTION_H
parameter_list|(
name|n
parameter_list|)
define|\
value|(*(Elf32_Shdr *) ((byte *) old_section_h + old_file_h->e_shentsize * (n)))
end_define

begin_define
define|#
directive|define
name|NEW_SECTION_H
parameter_list|(
name|n
parameter_list|)
define|\
value|(*(Elf32_Shdr *) ((byte *) new_section_h + new_file_h->e_shentsize * (n)))
end_define

begin_define
define|#
directive|define
name|OLD_PROGRAM_H
parameter_list|(
name|n
parameter_list|)
define|\
value|(*(Elf32_Phdr *) ((byte *) old_program_h + old_file_h->e_phentsize * (n)))
end_define

begin_define
define|#
directive|define
name|NEW_PROGRAM_H
parameter_list|(
name|n
parameter_list|)
define|\
value|(*(Elf32_Phdr *) ((byte *) new_program_h + new_file_h->e_phentsize * (n)))
end_define

begin_typedef
typedef|typedef
name|unsigned
name|char
name|byte
typedef|;
end_typedef

begin_comment
comment|/* ****************************************************************  * unexec  *  * driving logic.  *  * In ELF, this works by replacing the old .bss section with a new  * .data section, and inserting an empty .bss immediately afterwards.  *  */
end_comment

begin_function
name|void
name|unexec
parameter_list|(
name|new_name
parameter_list|,
name|old_name
parameter_list|,
name|data_start
parameter_list|,
name|bss_start
parameter_list|,
name|entry_address
parameter_list|)
name|char
modifier|*
name|new_name
decl_stmt|,
decl|*
name|old_name
decl_stmt|;
end_function

begin_decl_stmt
name|unsigned
name|data_start
decl_stmt|,
name|bss_start
decl_stmt|,
name|entry_address
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|extern
name|unsigned
name|int
name|bss_end
decl_stmt|;
name|int
name|new_file
decl_stmt|,
name|old_file
decl_stmt|,
name|new_file_size
decl_stmt|;
comment|/* Pointers to the base of the image of the two files. */
name|caddr_t
name|old_base
decl_stmt|,
name|new_base
decl_stmt|;
comment|/* Pointers to the file, program and section headers for the old and new    * files.    */
name|Elf32_Ehdr
modifier|*
name|old_file_h
decl_stmt|,
modifier|*
name|new_file_h
decl_stmt|;
name|Elf32_Phdr
modifier|*
name|old_program_h
decl_stmt|,
modifier|*
name|new_program_h
decl_stmt|;
name|Elf32_Shdr
modifier|*
name|old_section_h
decl_stmt|,
modifier|*
name|new_section_h
decl_stmt|;
comment|/* Point to the section name table in the old file */
name|char
modifier|*
name|old_section_names
decl_stmt|;
name|Elf32_Addr
name|old_bss_addr
decl_stmt|,
name|new_bss_addr
decl_stmt|;
name|Elf32_Word
name|old_bss_size
decl_stmt|,
name|new_data2_size
decl_stmt|;
name|Elf32_Off
name|new_data2_offset
decl_stmt|;
name|Elf32_Addr
name|new_data2_addr
decl_stmt|;
name|int
name|n
decl_stmt|,
name|old_bss_index
decl_stmt|,
name|old_data_index
decl_stmt|,
name|new_data2_index
decl_stmt|;
name|struct
name|stat
name|stat_buf
decl_stmt|;
comment|/* Open the old file& map it into the address space. */
name|old_file
operator|=
name|open
argument_list|(
name|old_name
argument_list|,
name|O_RDONLY
argument_list|)
expr_stmt|;
if|if
condition|(
name|old_file
operator|<
literal|0
condition|)
name|fatal
argument_list|(
literal|"Can't open %s for reading: errno %d\n"
argument_list|,
name|old_name
argument_list|,
name|errno
argument_list|)
expr_stmt|;
if|if
condition|(
name|fstat
argument_list|(
name|old_file
argument_list|,
operator|&
name|stat_buf
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|fatal
argument_list|(
literal|"Can't fstat(%s): errno %d\n"
argument_list|,
name|old_name
argument_list|,
name|errno
argument_list|)
expr_stmt|;
name|old_base
operator|=
name|mmap
argument_list|(
literal|0
argument_list|,
name|stat_buf
operator|.
name|st_size
argument_list|,
name|PROT_READ
argument_list|,
name|MAP_SHARED
argument_list|,
name|old_file
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|old_base
operator|==
operator|(
name|caddr_t
operator|)
operator|-
literal|1
condition|)
name|fatal
argument_list|(
literal|"Can't mmap(%s): errno %d\n"
argument_list|,
name|old_name
argument_list|,
name|errno
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"mmap(%s, %x) -> %x\n"
argument_list|,
name|old_name
argument_list|,
name|stat_buf
operator|.
name|st_size
argument_list|,
name|old_base
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Get pointers to headers& section names */
name|old_file_h
operator|=
operator|(
name|Elf32_Ehdr
operator|*
operator|)
name|old_base
expr_stmt|;
name|old_program_h
operator|=
operator|(
name|Elf32_Phdr
operator|*
operator|)
operator|(
operator|(
name|byte
operator|*
operator|)
name|old_base
operator|+
name|old_file_h
operator|->
name|e_phoff
operator|)
expr_stmt|;
name|old_section_h
operator|=
operator|(
name|Elf32_Shdr
operator|*
operator|)
operator|(
operator|(
name|byte
operator|*
operator|)
name|old_base
operator|+
name|old_file_h
operator|->
name|e_shoff
operator|)
expr_stmt|;
name|old_section_names
operator|=
operator|(
name|char
operator|*
operator|)
name|old_base
operator|+
name|OLD_SECTION_H
argument_list|(
name|old_file_h
operator|->
name|e_shstrndx
argument_list|)
operator|.
name|sh_offset
expr_stmt|;
comment|/* Find the old .bss section.  Figure out parameters of the new    * data2 and bss sections.    */
for|for
control|(
name|old_bss_index
operator|=
literal|1
init|;
name|old_bss_index
operator|<
name|old_file_h
operator|->
name|e_shnum
condition|;
name|old_bss_index
operator|++
control|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Looking for .bss - found %s\n"
argument_list|,
name|old_section_names
operator|+
name|OLD_SECTION_H
argument_list|(
name|old_bss_index
argument_list|)
operator|.
name|sh_name
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|old_section_names
operator|+
name|OLD_SECTION_H
argument_list|(
name|old_bss_index
argument_list|)
operator|.
name|sh_name
argument_list|,
literal|".bss"
argument_list|)
condition|)
break|break;
block|}
if|if
condition|(
name|old_bss_index
operator|==
name|old_file_h
operator|->
name|e_shnum
condition|)
name|fatal
argument_list|(
literal|"Can't find .bss in %s.\n"
argument_list|,
name|old_name
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|old_bss_addr
operator|=
name|OLD_SECTION_H
argument_list|(
name|old_bss_index
argument_list|)
operator|.
name|sh_addr
expr_stmt|;
name|old_bss_size
operator|=
name|OLD_SECTION_H
argument_list|(
name|old_bss_index
argument_list|)
operator|.
name|sh_size
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|emacs
argument_list|)
operator|||
operator|!
name|defined
argument_list|(
name|DEBUG
argument_list|)
name|bss_end
operator|=
operator|(
name|unsigned
name|int
operator|)
name|sbrk
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|new_bss_addr
operator|=
operator|(
name|Elf32_Addr
operator|)
name|bss_end
expr_stmt|;
else|#
directive|else
name|new_bss_addr
operator|=
name|old_bss_addr
operator|+
name|old_bss_size
operator|+
literal|0x1234
expr_stmt|;
endif|#
directive|endif
name|new_data2_addr
operator|=
name|old_bss_addr
expr_stmt|;
name|new_data2_size
operator|=
name|new_bss_addr
operator|-
name|old_bss_addr
expr_stmt|;
name|new_data2_offset
operator|=
name|OLD_SECTION_H
argument_list|(
name|old_bss_index
argument_list|)
operator|.
name|sh_offset
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"old_bss_index %d\n"
argument_list|,
name|old_bss_index
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"old_bss_addr %x\n"
argument_list|,
name|old_bss_addr
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"old_bss_size %x\n"
argument_list|,
name|old_bss_size
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"new_bss_addr %x\n"
argument_list|,
name|new_bss_addr
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"new_data2_addr %x\n"
argument_list|,
name|new_data2_addr
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"new_data2_size %x\n"
argument_list|,
name|new_data2_size
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"new_data2_offset %x\n"
argument_list|,
name|new_data2_offset
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|unsigned
operator|)
name|new_bss_addr
operator|<
operator|(
name|unsigned
operator|)
name|old_bss_addr
operator|+
name|old_bss_size
condition|)
name|fatal
argument_list|(
literal|".bss shrank when undumping???\n"
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Set the output file to the right size and mmap(2) it.  Set    * pointers to various interesting objects.  stat_buf still has    * old_file data.    */
name|new_file
operator|=
name|open
argument_list|(
name|new_name
argument_list|,
name|O_RDWR
operator||
name|O_CREAT
argument_list|,
literal|0666
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_file
operator|<
literal|0
condition|)
name|fatal
argument_list|(
literal|"Can't creat(%s): errno %d\n"
argument_list|,
name|new_name
argument_list|,
name|errno
argument_list|)
expr_stmt|;
name|new_file_size
operator|=
name|stat_buf
operator|.
name|st_size
operator|+
name|old_file_h
operator|->
name|e_shentsize
operator|+
name|new_data2_size
expr_stmt|;
if|if
condition|(
name|ftruncate
argument_list|(
name|new_file
argument_list|,
name|new_file_size
argument_list|)
condition|)
name|fatal
argument_list|(
literal|"Can't ftruncate(%s): errno %d\n"
argument_list|,
name|new_name
argument_list|,
name|errno
argument_list|)
expr_stmt|;
name|new_base
operator|=
name|mmap
argument_list|(
literal|0
argument_list|,
name|new_file_size
argument_list|,
name|PROT_READ
operator||
name|PROT_WRITE
argument_list|,
name|MAP_SHARED
argument_list|,
name|new_file
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_base
operator|==
operator|(
name|caddr_t
operator|)
operator|-
literal|1
condition|)
name|fatal
argument_list|(
literal|"Can't mmap(%s): errno %d\n"
argument_list|,
name|new_name
argument_list|,
name|errno
argument_list|)
expr_stmt|;
name|new_file_h
operator|=
operator|(
name|Elf32_Ehdr
operator|*
operator|)
name|new_base
expr_stmt|;
name|new_program_h
operator|=
operator|(
name|Elf32_Phdr
operator|*
operator|)
operator|(
operator|(
name|byte
operator|*
operator|)
name|new_base
operator|+
name|old_file_h
operator|->
name|e_phoff
operator|)
expr_stmt|;
name|new_section_h
operator|=
operator|(
name|Elf32_Shdr
operator|*
operator|)
operator|(
operator|(
name|byte
operator|*
operator|)
name|new_base
operator|+
name|old_file_h
operator|->
name|e_shoff
operator|+
name|new_data2_size
operator|)
expr_stmt|;
comment|/* Make our new file, program and section headers as copies of the    * originals.    */
name|memcpy
argument_list|(
name|new_file_h
argument_list|,
name|old_file_h
argument_list|,
name|old_file_h
operator|->
name|e_ehsize
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|new_program_h
argument_list|,
name|old_program_h
argument_list|,
name|old_file_h
operator|->
name|e_phnum
operator|*
name|old_file_h
operator|->
name|e_phentsize
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|new_section_h
argument_list|,
name|old_section_h
argument_list|,
name|old_file_h
operator|->
name|e_shnum
operator|*
name|old_file_h
operator|->
name|e_shentsize
argument_list|)
expr_stmt|;
comment|/* Fix up file header.  We'll add one section.  Section header is    * further away now.    */
name|new_file_h
operator|->
name|e_shoff
operator|+=
name|new_data2_size
expr_stmt|;
name|new_file_h
operator|->
name|e_shnum
operator|+=
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Old section offset %x\n"
argument_list|,
name|old_file_h
operator|->
name|e_shoff
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Old section count %d\n"
argument_list|,
name|old_file_h
operator|->
name|e_shnum
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"New section offset %x\n"
argument_list|,
name|new_file_h
operator|->
name|e_shoff
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"New section count %d\n"
argument_list|,
name|new_file_h
operator|->
name|e_shnum
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Fix up a new program header.  Extend the writable data segment so    * that the bss area is covered too. Find that segment by looking    * for a segment that ends just before the .bss area.  Make sure    * that no segments are above the new .data2.  Put a loop at the end    * to adjust the offset and address of any segment that is above    * data2, just in case we decide to allow this later.    */
for|for
control|(
name|n
operator|=
name|new_file_h
operator|->
name|e_phnum
operator|-
literal|1
init|;
name|n
operator|>=
literal|0
condition|;
name|n
operator|--
control|)
block|{
if|if
condition|(
name|NEW_PROGRAM_H
argument_list|(
name|n
argument_list|)
operator|.
name|p_vaddr
operator|+
name|NEW_PROGRAM_H
argument_list|(
name|n
argument_list|)
operator|.
name|p_filesz
operator|>
name|old_bss_addr
condition|)
name|fatal
argument_list|(
literal|"Program segment above .bss in %s\n"
argument_list|,
name|old_name
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|NEW_PROGRAM_H
argument_list|(
name|n
argument_list|)
operator|.
name|p_type
operator|==
name|PT_LOAD
operator|&&
operator|(
name|NEW_PROGRAM_H
argument_list|(
name|n
argument_list|)
operator|.
name|p_vaddr
operator|+
name|NEW_PROGRAM_H
argument_list|(
name|n
argument_list|)
operator|.
name|p_filesz
operator|==
name|old_bss_addr
operator|)
condition|)
break|break;
block|}
if|if
condition|(
name|n
operator|<
literal|0
condition|)
name|fatal
argument_list|(
literal|"Couldn't find segment next to .bss in %s\n"
argument_list|,
name|old_name
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|NEW_PROGRAM_H
argument_list|(
name|n
argument_list|)
operator|.
name|p_filesz
operator|+=
name|new_data2_size
expr_stmt|;
name|NEW_PROGRAM_H
argument_list|(
name|n
argument_list|)
operator|.
name|p_memsz
operator|=
name|NEW_PROGRAM_H
argument_list|(
name|n
argument_list|)
operator|.
name|p_filesz
expr_stmt|;
if|#
directive|if
literal|0
comment|/* Maybe allow section after data2 - does this ever happen? */
block|for (n = new_file_h->e_phnum - 1; n>= 0; n--)     {       if (NEW_PROGRAM_H(n).p_vaddr&& NEW_PROGRAM_H(n).p_vaddr>= new_data2_addr) 	NEW_PROGRAM_H(n).p_vaddr += new_data2_size - old_bss_size;        if (NEW_PROGRAM_H(n).p_offset>= new_data2_offset) 	NEW_PROGRAM_H(n).p_offset += new_data2_size;     }
endif|#
directive|endif
comment|/* Fix up section headers based on new .data2 section.  Any section    * whose offset or virtual address is after the new .data2 section    * gets its value adjusted.  .bss size becomes zero and new address    * is set.  data2 section header gets added by copying the existing    * .data header and modifying the offset, address and size.    */
for|for
control|(
name|n
operator|=
literal|1
init|;
name|n
operator|<
name|new_file_h
operator|->
name|e_shnum
condition|;
name|n
operator|++
control|)
block|{
if|if
condition|(
name|NEW_SECTION_H
argument_list|(
name|n
argument_list|)
operator|.
name|sh_offset
operator|>=
name|new_data2_offset
condition|)
name|NEW_SECTION_H
argument_list|(
name|n
argument_list|)
operator|.
name|sh_offset
operator|+=
name|new_data2_size
expr_stmt|;
if|if
condition|(
name|NEW_SECTION_H
argument_list|(
name|n
argument_list|)
operator|.
name|sh_addr
operator|&&
name|NEW_SECTION_H
argument_list|(
name|n
argument_list|)
operator|.
name|sh_addr
operator|>=
name|new_data2_addr
condition|)
name|NEW_SECTION_H
argument_list|(
name|n
argument_list|)
operator|.
name|sh_addr
operator|+=
name|new_data2_size
operator|-
name|old_bss_size
expr_stmt|;
block|}
name|new_data2_index
operator|=
name|old_file_h
operator|->
name|e_shnum
expr_stmt|;
for|for
control|(
name|old_data_index
operator|=
literal|1
init|;
name|old_data_index
operator|<
name|old_file_h
operator|->
name|e_shnum
condition|;
name|old_data_index
operator|++
control|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|old_section_names
operator|+
name|OLD_SECTION_H
argument_list|(
name|old_data_index
argument_list|)
operator|.
name|sh_name
argument_list|,
literal|".data"
argument_list|)
condition|)
break|break;
if|if
condition|(
name|old_data_index
operator|==
name|old_file_h
operator|->
name|e_shnum
condition|)
name|fatal
argument_list|(
literal|"Can't find .data in %s.\n"
argument_list|,
name|old_name
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|NEW_SECTION_H
argument_list|(
name|new_data2_index
argument_list|)
argument_list|,
operator|&
name|OLD_SECTION_H
argument_list|(
name|old_data_index
argument_list|)
argument_list|,
name|new_file_h
operator|->
name|e_shentsize
argument_list|)
expr_stmt|;
name|NEW_SECTION_H
argument_list|(
name|new_data2_index
argument_list|)
operator|.
name|sh_addr
operator|=
name|new_data2_addr
expr_stmt|;
name|NEW_SECTION_H
argument_list|(
name|new_data2_index
argument_list|)
operator|.
name|sh_offset
operator|=
name|new_data2_offset
expr_stmt|;
name|NEW_SECTION_H
argument_list|(
name|new_data2_index
argument_list|)
operator|.
name|sh_size
operator|=
name|new_data2_size
expr_stmt|;
name|NEW_SECTION_H
argument_list|(
name|old_bss_index
argument_list|)
operator|.
name|sh_size
operator|=
literal|0
expr_stmt|;
name|NEW_SECTION_H
argument_list|(
name|old_bss_index
argument_list|)
operator|.
name|sh_addr
operator|=
name|new_data2_addr
operator|+
name|new_data2_size
expr_stmt|;
comment|/* Write out the sections. .data and .data1 (and data2, called    * ".data" in the strings table) get copied from the current process    * instead of the old file.    */
for|for
control|(
name|n
operator|=
name|new_file_h
operator|->
name|e_shnum
operator|-
literal|1
init|;
name|n
condition|;
name|n
operator|--
control|)
block|{
name|caddr_t
name|src
decl_stmt|;
if|if
condition|(
name|NEW_SECTION_H
argument_list|(
name|n
argument_list|)
operator|.
name|sh_type
operator|==
name|SHT_NULL
operator|||
name|NEW_SECTION_H
argument_list|(
name|n
argument_list|)
operator|.
name|sh_type
operator|==
name|SHT_NOBITS
condition|)
continue|continue;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|old_section_names
operator|+
name|NEW_SECTION_H
argument_list|(
name|n
argument_list|)
operator|.
name|sh_name
argument_list|,
literal|".data"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
operator|(
name|old_section_names
operator|+
name|NEW_SECTION_H
argument_list|(
name|n
argument_list|)
operator|.
name|sh_name
operator|)
argument_list|,
literal|".data1"
argument_list|)
condition|)
name|src
operator|=
operator|(
name|caddr_t
operator|)
name|NEW_SECTION_H
argument_list|(
name|n
argument_list|)
operator|.
name|sh_addr
expr_stmt|;
else|else
name|src
operator|=
name|old_base
operator|+
name|OLD_SECTION_H
argument_list|(
name|n
argument_list|)
operator|.
name|sh_offset
expr_stmt|;
name|memcpy
argument_list|(
name|NEW_SECTION_H
argument_list|(
name|n
argument_list|)
operator|.
name|sh_offset
operator|+
name|new_base
argument_list|,
name|src
argument_list|,
name|NEW_SECTION_H
argument_list|(
name|n
argument_list|)
operator|.
name|sh_size
argument_list|)
expr_stmt|;
block|}
comment|/* Close the files and make the new file executable */
if|if
condition|(
name|close
argument_list|(
name|old_file
argument_list|)
condition|)
name|fatal
argument_list|(
literal|"Can't close(%s): errno %d\n"
argument_list|,
name|old_name
argument_list|,
name|errno
argument_list|)
expr_stmt|;
if|if
condition|(
name|close
argument_list|(
name|new_file
argument_list|)
condition|)
name|fatal
argument_list|(
literal|"Can't close(%s): errno %d\n"
argument_list|,
name|new_name
argument_list|,
name|errno
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|new_name
argument_list|,
operator|&
name|stat_buf
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|fatal
argument_list|(
literal|"Can't stat(%s): errno %d\n"
argument_list|,
name|new_name
argument_list|,
name|errno
argument_list|)
expr_stmt|;
name|n
operator|=
name|umask
argument_list|(
literal|777
argument_list|)
expr_stmt|;
name|umask
argument_list|(
name|n
argument_list|)
expr_stmt|;
name|stat_buf
operator|.
name|st_mode
operator||=
literal|0111
operator|&
operator|~
name|n
expr_stmt|;
if|if
condition|(
name|chmod
argument_list|(
name|new_name
argument_list|,
name|stat_buf
operator|.
name|st_mode
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|fatal
argument_list|(
literal|"Can't chmod(%s): errno %d\n"
argument_list|,
name|new_name
argument_list|,
name|errno
argument_list|)
expr_stmt|;
block|}
end_block

end_unit

