begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Primitives for word-abbrev mode.    Copyright (C) 1985, 1986 Free Software Foundation, Inc.  This file is part of GNU Emacs.  GNU Emacs is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 1, or (at your option) any later version.  GNU Emacs is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU Emacs; see the file COPYING.  If not, write to the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_undef
undef|#
directive|undef
name|NULL
end_undef

begin_include
include|#
directive|include
file|"lisp.h"
end_include

begin_include
include|#
directive|include
file|"commands.h"
end_include

begin_include
include|#
directive|include
file|"buffer.h"
end_include

begin_include
include|#
directive|include
file|"window.h"
end_include

begin_comment
comment|/* An abbrev table is an obarray.  Each defined abbrev is represented by a symbol in that obarray  whose print name is the abbreviation.  The symbol's value is a string which is the expansion.  If its function definition is non-nil, it is called   after the expansion is done.  The plist slot of the abbrev symbol is its usage count. */
end_comment

begin_comment
comment|/* List of all abbrev-table name symbols:  symbols whose values are abbrev tables.  */
end_comment

begin_decl_stmt
name|Lisp_Object
name|Vabbrev_table_name_list
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The table of global abbrevs.  These are in effect  in any buffer in which abbrev mode is turned on. */
end_comment

begin_decl_stmt
name|Lisp_Object
name|Vglobal_abbrev_table
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The local abbrev table used by default (in Fundamental Mode buffers) */
end_comment

begin_decl_stmt
name|Lisp_Object
name|Vfundamental_mode_abbrev_table
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Set nonzero when an abbrev definition is changed */
end_comment

begin_decl_stmt
name|int
name|abbrevs_changed
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|abbrev_all_caps
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Non-nil => use this location as the start of abbrev to expand  (rather than taking the word before point as the abbrev) */
end_comment

begin_decl_stmt
name|Lisp_Object
name|Vabbrev_start_location
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Buffer that Vabbrev_start_location applies to */
end_comment

begin_decl_stmt
name|Lisp_Object
name|Vabbrev_start_location_buffer
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The symbol representing the abbrev most recently expanded */
end_comment

begin_decl_stmt
name|Lisp_Object
name|Vlast_abbrev
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* A string for the actual text of the abbrev most recently expanded.    This has more info than Vlast_abbrev since case is significant.  */
end_comment

begin_decl_stmt
name|Lisp_Object
name|Vlast_abbrev_text
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Character address of start of last abbrev expanded */
end_comment

begin_decl_stmt
name|int
name|last_abbrev_point
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|extern
name|Lisp_Object
name|oblookup
parameter_list|()
function_decl|;
end_function_decl

begin_escape
end_escape

begin_macro
name|DEFUN
argument_list|(
literal|"make-abbrev-table"
argument_list|,
argument|Fmake_abbrev_table
argument_list|,
argument|Smake_abbrev_table
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|"Create a new, empty abbrev table object."
argument_list|)
end_macro

begin_expr_stmt
operator|(
operator|)
block|{
return|return
name|Fmake_vector
argument_list|(
name|make_number
argument_list|(
literal|59
argument_list|)
argument_list|,
name|make_number
argument_list|(
literal|0
argument_list|)
argument_list|)
return|;
block|}
end_expr_stmt

begin_macro
name|DEFUN
argument_list|(
literal|"clear-abbrev-table"
argument_list|,
argument|Fclear_abbrev_table
argument_list|,
argument|Sclear_abbrev_table
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|"Undefine all abbrevs in abbrev table TABLE, leaving it empty."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|table
operator|)
name|Lisp_Object
name|table
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|int
name|i
decl_stmt|,
name|size
decl_stmt|;
name|CHECK_VECTOR
argument_list|(
name|table
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|size
operator|=
name|XVECTOR
argument_list|(
name|table
argument_list|)
operator|->
name|size
expr_stmt|;
name|abbrevs_changed
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|size
condition|;
name|i
operator|++
control|)
name|XVECTOR
argument_list|(
name|table
argument_list|)
operator|->
name|contents
index|[
name|i
index|]
operator|=
name|make_number
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
name|Qnil
return|;
block|}
end_block

begin_escape
end_escape

begin_macro
name|DEFUN
argument_list|(
literal|"define-abbrev"
argument_list|,
argument|Fdefine_abbrev
argument_list|,
argument|Sdefine_abbrev
argument_list|,
literal|3
argument_list|,
literal|5
argument_list|,
literal|0
argument_list|,
literal|"Define an abbrev in TABLE named NAME, to expand to EXPANSION or call HOOK.\n\ NAME and EXPANSION are strings.  HOOK is a function or nil.\n\ To undefine an abbrev, define it with EXPANSION = nil"
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|table
operator|,
name|name
operator|,
name|expansion
operator|,
name|hook
operator|,
name|count
operator|)
name|Lisp_Object
name|table
operator|,
name|name
operator|,
name|expansion
operator|,
name|hook
operator|,
name|count
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|Lisp_Object
name|sym
decl_stmt|,
name|oexp
decl_stmt|,
name|ohook
decl_stmt|,
name|tem
decl_stmt|;
name|CHECK_VECTOR
argument_list|(
name|table
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CHECK_STRING
argument_list|(
name|name
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|CHECK_STRING
argument_list|(
name|expansion
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
argument_list|(
name|count
argument_list|)
condition|)
name|count
operator|=
name|make_number
argument_list|(
literal|0
argument_list|)
expr_stmt|;
else|else
name|CHECK_NUMBER
argument_list|(
name|count
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sym
operator|=
name|Fintern
argument_list|(
name|name
argument_list|,
name|table
argument_list|)
expr_stmt|;
name|oexp
operator|=
name|XSYMBOL
argument_list|(
name|sym
argument_list|)
operator|->
name|value
expr_stmt|;
name|ohook
operator|=
name|XSYMBOL
argument_list|(
name|sym
argument_list|)
operator|->
name|function
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|(
name|EQ
argument_list|(
name|oexp
argument_list|,
name|expansion
argument_list|)
operator|||
operator|(
name|XTYPE
argument_list|(
name|oexp
argument_list|)
operator|==
name|Lisp_String
operator|&&
name|XTYPE
argument_list|(
name|expansion
argument_list|)
operator|==
name|Lisp_String
operator|&&
operator|(
name|tem
operator|=
name|Fstring_equal
argument_list|(
name|oexp
argument_list|,
name|expansion
argument_list|)
operator|,
operator|!
name|NULL
argument_list|(
name|tem
argument_list|)
operator|)
operator|)
operator|)
operator|&&
operator|(
name|EQ
argument_list|(
name|ohook
argument_list|,
name|hook
argument_list|)
operator|||
operator|(
name|tem
operator|=
name|Fequal
argument_list|(
name|ohook
argument_list|,
name|hook
argument_list|)
operator|,
operator|!
name|NULL
argument_list|(
name|tem
argument_list|)
operator|)
operator|)
operator|)
condition|)
name|abbrevs_changed
operator|=
literal|1
expr_stmt|;
name|Fset
argument_list|(
name|sym
argument_list|,
name|expansion
argument_list|)
expr_stmt|;
name|Ffset
argument_list|(
name|sym
argument_list|,
name|hook
argument_list|)
expr_stmt|;
name|Fsetplist
argument_list|(
name|sym
argument_list|,
name|count
argument_list|)
expr_stmt|;
return|return
name|name
return|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"define-global-abbrev"
argument_list|,
argument|Fdefine_global_abbrev
argument_list|,
argument|Sdefine_global_abbrev
argument_list|,
literal|2
argument_list|,
literal|2
argument_list|,
literal|"sDefine global abbrev: \nsExpansion for %s: "
argument_list|,
literal|"Define ABBREV as a global abbreviation for EXPANSION."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|name
operator|,
name|expansion
operator|)
name|Lisp_Object
name|name
operator|,
name|expansion
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|Fdefine_abbrev
argument_list|(
name|Vglobal_abbrev_table
argument_list|,
name|Fdowncase
argument_list|(
name|name
argument_list|)
argument_list|,
name|expansion
argument_list|,
name|Qnil
argument_list|,
name|make_number
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|name
return|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"define-mode-abbrev"
argument_list|,
argument|Fdefine_mode_abbrev
argument_list|,
argument|Sdefine_mode_abbrev
argument_list|,
literal|2
argument_list|,
literal|2
argument_list|,
literal|"sDefine mode abbrev: \nsExpansion for %s: "
argument_list|,
literal|"Define ABBREV as a mode-specific abbreviation for EXPANSION."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|name
operator|,
name|expansion
operator|)
name|Lisp_Object
name|name
operator|,
name|expansion
expr_stmt|;
end_expr_stmt

begin_block
block|{
if|if
condition|(
name|NULL
argument_list|(
name|current_buffer
operator|->
name|abbrev_table
argument_list|)
condition|)
name|error
argument_list|(
literal|"Major mode has no abbrev table"
argument_list|)
expr_stmt|;
name|Fdefine_abbrev
argument_list|(
name|current_buffer
operator|->
name|abbrev_table
argument_list|,
name|Fdowncase
argument_list|(
name|name
argument_list|)
argument_list|,
name|expansion
argument_list|,
name|Qnil
argument_list|,
name|make_number
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|name
return|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"abbrev-symbol"
argument_list|,
argument|Fabbrev_symbol
argument_list|,
argument|Sabbrev_symbol
argument_list|,
literal|1
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
literal|"Return the symbol representing abbrev named ABBREV.\n\ Value is nil if that abbrev is not defined.\n\ Optional second arg TABLE is abbrev table to look it up in.\n\ Default is try buffer's mode-specific abbrev table, then global table."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|abbrev
operator|,
name|table
operator|)
name|Lisp_Object
name|abbrev
operator|,
name|table
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|Lisp_Object
name|sym
decl_stmt|;
name|CHECK_STRING
argument_list|(
name|abbrev
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|NULL
argument_list|(
name|table
argument_list|)
condition|)
name|sym
operator|=
name|Fintern_soft
argument_list|(
name|abbrev
argument_list|,
name|table
argument_list|)
expr_stmt|;
else|else
block|{
name|sym
operator|=
name|Qnil
expr_stmt|;
if|if
condition|(
operator|!
name|NULL
argument_list|(
name|current_buffer
operator|->
name|abbrev_table
argument_list|)
condition|)
name|sym
operator|=
name|Fintern_soft
argument_list|(
name|abbrev
argument_list|,
name|current_buffer
operator|->
name|abbrev_table
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
argument_list|(
name|XSYMBOL
argument_list|(
name|sym
argument_list|)
operator|->
name|value
argument_list|)
condition|)
name|sym
operator|=
name|Qnil
expr_stmt|;
if|if
condition|(
name|NULL
argument_list|(
name|sym
argument_list|)
condition|)
name|sym
operator|=
name|Fintern_soft
argument_list|(
name|abbrev
argument_list|,
name|Vglobal_abbrev_table
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|NULL
argument_list|(
name|XSYMBOL
argument_list|(
name|sym
argument_list|)
operator|->
name|value
argument_list|)
condition|)
return|return
name|Qnil
return|;
return|return
name|sym
return|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"abbrev-expansion"
argument_list|,
argument|Fabbrev_expansion
argument_list|,
argument|Sabbrev_expansion
argument_list|,
literal|1
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
literal|"Return the string that ABBREV expands into in the current buffer.\n\ Optionally specify an abbrev table; then ABBREV is looked up in that table only."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|abbrev
operator|,
name|table
operator|)
name|Lisp_Object
name|abbrev
operator|,
name|table
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|Lisp_Object
name|sym
decl_stmt|;
name|sym
operator|=
name|Fabbrev_symbol
argument_list|(
name|abbrev
argument_list|,
name|table
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
argument_list|(
name|sym
argument_list|)
condition|)
return|return
name|sym
return|;
return|return
name|Fsymbol_value
argument_list|(
name|sym
argument_list|)
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* Expand the word before point, if it is an abbrev.   Returns 1 if an expansion is done. */
end_comment

begin_macro
name|DEFUN
argument_list|(
literal|"expand-abbrev"
argument_list|,
argument|Fexpand_abbrev
argument_list|,
argument|Sexpand_abbrev
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|,
literal|"Expand the abbrev before point, if it is an abbrev.\n\ Effective when explicitly called even when abbrev-mode is not enabled.\n\ Returns t if expansion took place."
argument_list|)
end_macro

begin_expr_stmt
operator|(
operator|)
block|{
name|char
name|buffer
index|[
literal|200
index|]
block|;
specifier|register
name|char
operator|*
name|p
operator|=
name|buffer
block|;
specifier|register
name|int
name|wordstart
block|,
name|idx
block|;
name|int
name|uccount
operator|=
literal|0
block|,
name|lccount
operator|=
literal|0
block|;
specifier|register
name|Lisp_Object
name|sym
block|;
name|Lisp_Object
name|expansion
block|,
name|hook
block|,
name|tem
block|;
if|if
condition|(
name|XBUFFER
argument_list|(
name|Vabbrev_start_location_buffer
argument_list|)
operator|!=
name|current_buffer
condition|)
name|Vabbrev_start_location
operator|=
name|Qnil
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
operator|!
name|NULL
argument_list|(
name|Vabbrev_start_location
argument_list|)
condition|)
block|{
name|tem
operator|=
name|Vabbrev_start_location
expr_stmt|;
name|CHECK_NUMBER_COERCE_MARKER
argument_list|(
name|tem
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|wordstart
operator|=
name|XINT
argument_list|(
name|tem
argument_list|)
expr_stmt|;
name|Vabbrev_start_location
operator|=
name|Qnil
expr_stmt|;
if|if
condition|(
name|FETCH_CHAR
argument_list|(
name|wordstart
argument_list|)
operator|==
literal|'-'
condition|)
name|del_range
argument_list|(
name|wordstart
argument_list|,
name|wordstart
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
name|wordstart
operator|=
name|scan_words
argument_list|(
name|point
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
end_if

begin_if
if|if
condition|(
operator|!
name|wordstart
operator|||
name|point
operator|-
name|wordstart
operator|>=
sizeof|sizeof
name|buffer
operator|||
name|point
operator|<=
name|wordstart
condition|)
return|return
name|Qnil
return|;
end_if

begin_for
for|for
control|(
name|idx
operator|=
name|wordstart
init|;
name|idx
operator|<
name|point
condition|;
name|idx
operator|++
control|)
block|{
specifier|register
name|int
name|c
init|=
name|FETCH_CHAR
argument_list|(
name|idx
argument_list|)
decl_stmt|;
if|if
condition|(
name|UPPERCASEP
argument_list|(
name|c
argument_list|)
condition|)
name|c
operator|=
name|DOWNCASE
argument_list|(
name|c
argument_list|)
operator|,
name|uccount
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|NOCASEP
argument_list|(
name|c
argument_list|)
condition|)
name|lccount
operator|++
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|c
expr_stmt|;
block|}
end_for

begin_if
if|if
condition|(
name|XTYPE
argument_list|(
name|current_buffer
operator|->
name|abbrev_table
argument_list|)
operator|==
name|Lisp_Vector
condition|)
name|sym
operator|=
name|oblookup
argument_list|(
name|current_buffer
operator|->
name|abbrev_table
argument_list|,
name|buffer
argument_list|,
name|p
operator|-
name|buffer
argument_list|)
expr_stmt|;
else|else
name|XFASTINT
argument_list|(
name|sym
argument_list|)
operator|=
literal|0
expr_stmt|;
end_if

begin_if
if|if
condition|(
name|XTYPE
argument_list|(
name|sym
argument_list|)
operator|==
name|Lisp_Int
operator|||
name|NULL
argument_list|(
name|XSYMBOL
argument_list|(
name|sym
argument_list|)
operator|->
name|value
argument_list|)
condition|)
name|sym
operator|=
name|oblookup
argument_list|(
name|Vglobal_abbrev_table
argument_list|,
name|buffer
argument_list|,
name|p
operator|-
name|buffer
argument_list|)
expr_stmt|;
end_if

begin_if
if|if
condition|(
name|XTYPE
argument_list|(
name|sym
argument_list|)
operator|==
name|Lisp_Int
operator|||
name|NULL
argument_list|(
name|XSYMBOL
argument_list|(
name|sym
argument_list|)
operator|->
name|value
argument_list|)
condition|)
return|return
name|Qnil
return|;
end_if

begin_if
if|if
condition|(
name|FROM_KBD
operator|&&
operator|!
name|EQ
argument_list|(
name|minibuf_window
argument_list|,
name|selected_window
argument_list|)
condition|)
block|{
name|SET_PT
argument_list|(
name|wordstart
operator|+
name|p
operator|-
name|buffer
argument_list|)
expr_stmt|;
name|Fundo_boundary
argument_list|()
expr_stmt|;
block|}
end_if

begin_expr_stmt
name|SET_PT
argument_list|(
name|wordstart
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|Vlast_abbrev_text
operator|=
name|Fbuffer_substring
argument_list|(
name|make_number
argument_list|(
name|point
argument_list|)
argument_list|,
name|make_number
argument_list|(
name|point
operator|+
operator|(
name|p
operator|-
name|buffer
operator|)
argument_list|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|del_range
argument_list|(
name|point
argument_list|,
name|point
operator|+
operator|(
name|p
operator|-
name|buffer
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Now sym is the abbrev symbol. */
end_comment

begin_expr_stmt
name|Vlast_abbrev
operator|=
name|sym
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|last_abbrev_point
operator|=
name|point
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|XTYPE
argument_list|(
name|XSYMBOL
argument_list|(
name|sym
argument_list|)
operator|->
name|plist
argument_list|)
operator|==
name|Lisp_Int
condition|)
name|XSETINT
argument_list|(
name|XSYMBOL
argument_list|(
name|sym
argument_list|)
operator|->
name|plist
argument_list|,
name|XINT
argument_list|(
name|XSYMBOL
argument_list|(
name|sym
argument_list|)
operator|->
name|plist
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
end_if

begin_comment
comment|/* Increment use count */
end_comment

begin_expr_stmt
name|expansion
operator|=
name|XSYMBOL
argument_list|(
name|sym
argument_list|)
operator|->
name|value
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|insert
argument_list|(
name|XSTRING
argument_list|(
name|expansion
argument_list|)
operator|->
name|data
argument_list|,
name|XSTRING
argument_list|(
name|expansion
argument_list|)
operator|->
name|size
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|uccount
operator|&&
operator|!
name|lccount
condition|)
block|{
comment|/* Abbrev was all caps */
comment|/* If expansion is multiple words, normally capitalize each word */
comment|/* This used to be if (!...&& ...>= ...) Fcapitalize; else Fupcase 	 but Megatest 68000 compiler can't handle that */
if|if
condition|(
operator|!
name|abbrev_all_caps
condition|)
if|if
condition|(
name|scan_words
argument_list|(
name|point
argument_list|,
operator|-
literal|1
argument_list|)
operator|>
name|scan_words
argument_list|(
name|wordstart
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|upcase_initials_region
argument_list|(
name|make_number
argument_list|(
name|wordstart
argument_list|)
argument_list|,
name|make_number
argument_list|(
name|point
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|caped
goto|;
block|}
comment|/* If expansion is one word, or if user says so, upcase it all. */
name|Fupcase_region
argument_list|(
name|make_number
argument_list|(
name|wordstart
argument_list|)
argument_list|,
name|make_number
argument_list|(
name|point
argument_list|)
argument_list|)
expr_stmt|;
name|caped
label|:
empty_stmt|;
block|}
elseif|else
if|if
condition|(
name|uccount
condition|)
block|{
comment|/* Abbrev included some caps.  Cap first initial of expansion */
name|idx
operator|=
name|point
expr_stmt|;
name|SET_PT
argument_list|(
name|wordstart
argument_list|)
expr_stmt|;
name|Fcapitalize_word
argument_list|(
name|make_number
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|SET_PT
argument_list|(
name|idx
argument_list|)
expr_stmt|;
block|}
end_if

begin_expr_stmt
name|hook
operator|=
name|XSYMBOL
argument_list|(
name|sym
argument_list|)
operator|->
name|function
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
operator|!
name|NULL
argument_list|(
name|hook
argument_list|)
condition|)
name|call0
argument_list|(
name|hook
argument_list|)
expr_stmt|;
end_if

begin_return
return|return
name|Qt
return|;
end_return

begin_expr_stmt
unit|}  DEFUN
operator|(
literal|"unexpand-abbrev"
operator|,
name|Funexpand_abbrev
operator|,
name|Sunexpand_abbrev
operator|,
literal|0
operator|,
literal|0
operator|,
literal|""
operator|,
literal|"Undo the expansion of the last abbrev that expanded."
operator|)
operator|(
operator|)
block|{
name|int
name|opoint
operator|=
name|point
block|;
name|int
name|adjust
operator|=
literal|0
block|;
if|if
condition|(
name|last_abbrev_point
operator|<
name|BEGV
operator|||
name|last_abbrev_point
operator|>=
name|ZV
condition|)
return|return
name|Qnil
return|;
name|SET_PT
argument_list|(
name|last_abbrev_point
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|XTYPE
argument_list|(
name|Vlast_abbrev_text
argument_list|)
operator|==
name|Lisp_String
condition|)
block|{
comment|/* This isn't correct if Vlast_abbrev->function was used          to do the expansion */
name|Lisp_Object
name|val
decl_stmt|;
name|XSET
argument_list|(
name|val
argument_list|,
name|Lisp_String
argument_list|,
name|XSYMBOL
argument_list|(
name|Vlast_abbrev
argument_list|)
operator|->
name|value
argument_list|)
expr_stmt|;
name|adjust
operator|=
name|XSTRING
argument_list|(
name|val
argument_list|)
operator|->
name|size
expr_stmt|;
name|del_range
argument_list|(
name|point
argument_list|,
name|point
operator|+
name|adjust
argument_list|)
expr_stmt|;
name|insert
argument_list|(
name|XSTRING
argument_list|(
name|Vlast_abbrev_text
argument_list|)
operator|->
name|data
argument_list|,
name|XSTRING
argument_list|(
name|Vlast_abbrev_text
argument_list|)
operator|->
name|size
argument_list|)
expr_stmt|;
name|adjust
operator|-=
name|XSTRING
argument_list|(
name|Vlast_abbrev_text
argument_list|)
operator|->
name|size
expr_stmt|;
name|Vlast_abbrev_text
operator|=
name|Qnil
expr_stmt|;
block|}
end_if

begin_expr_stmt
name|SET_PT
argument_list|(
name|last_abbrev_point
operator|<
name|opoint
condition|?
name|opoint
operator|-
name|adjust
else|:
name|opoint
argument_list|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|Qnil
return|;
end_return

begin_escape
unit|}
end_escape

begin_macro
unit|static
name|write_abbrev
argument_list|(
argument|sym
argument_list|,
argument|stream
argument_list|)
end_macro

begin_decl_stmt
name|Lisp_Object
name|sym
decl_stmt|,
name|stream
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|Lisp_Object
name|name
decl_stmt|;
if|if
condition|(
name|NULL
argument_list|(
name|XSYMBOL
argument_list|(
name|sym
argument_list|)
operator|->
name|value
argument_list|)
condition|)
return|return;
name|insert
argument_list|(
literal|"    ("
argument_list|,
literal|5
argument_list|)
expr_stmt|;
name|XSET
argument_list|(
name|name
argument_list|,
name|Lisp_String
argument_list|,
name|XSYMBOL
argument_list|(
name|sym
argument_list|)
operator|->
name|name
argument_list|)
expr_stmt|;
name|Fprin1
argument_list|(
name|name
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|insert
argument_list|(
literal|" "
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|Fprin1
argument_list|(
name|XSYMBOL
argument_list|(
name|sym
argument_list|)
operator|->
name|value
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|insert
argument_list|(
literal|" "
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|Fprin1
argument_list|(
name|XSYMBOL
argument_list|(
name|sym
argument_list|)
operator|->
name|function
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|insert
argument_list|(
literal|" "
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|Fprin1
argument_list|(
name|XSYMBOL
argument_list|(
name|sym
argument_list|)
operator|->
name|plist
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|insert
argument_list|(
literal|")\n"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
specifier|static
name|describe_abbrev
argument_list|(
argument|sym
argument_list|,
argument|stream
argument_list|)
name|Lisp_Object
name|sym
operator|,
name|stream
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|Lisp_Object
name|one
decl_stmt|;
if|if
condition|(
name|NULL
argument_list|(
name|XSYMBOL
argument_list|(
name|sym
argument_list|)
operator|->
name|value
argument_list|)
condition|)
return|return;
name|one
operator|=
name|make_number
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|Fprin1
argument_list|(
name|Fsymbol_name
argument_list|(
name|sym
argument_list|)
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|Findent_to
argument_list|(
name|make_number
argument_list|(
literal|15
argument_list|)
argument_list|,
name|one
argument_list|)
expr_stmt|;
name|Fprin1
argument_list|(
name|XSYMBOL
argument_list|(
name|sym
argument_list|)
operator|->
name|plist
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|Findent_to
argument_list|(
name|make_number
argument_list|(
literal|20
argument_list|)
argument_list|,
name|one
argument_list|)
expr_stmt|;
name|Fprin1
argument_list|(
name|XSYMBOL
argument_list|(
name|sym
argument_list|)
operator|->
name|value
argument_list|,
name|stream
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|NULL
argument_list|(
name|XSYMBOL
argument_list|(
name|sym
argument_list|)
operator|->
name|function
argument_list|)
condition|)
block|{
name|Findent_to
argument_list|(
name|make_number
argument_list|(
literal|45
argument_list|)
argument_list|,
name|one
argument_list|)
expr_stmt|;
name|Fprin1
argument_list|(
name|XSYMBOL
argument_list|(
name|sym
argument_list|)
operator|->
name|function
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
name|Fterpri
argument_list|(
name|stream
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"insert-abbrev-table-description"
argument_list|,
argument|Finsert_abbrev_table_description
argument_list|,
argument|Sinsert_abbrev_table_description
argument_list|,
literal|2
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
literal|"Insert before point a description of abbrev table named NAME.\n\ NAME is a symbol whose value is an abbrev table.\n\ If 2nd arg READABLE is non-nil, a readable description is inserted.\n\ Otherwise description is an expression,\n\ a call to define-abbrev-table which would\n\ define NAME exactly as it is currently defined."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|name
operator|,
name|readable
operator|)
name|Lisp_Object
name|name
operator|,
name|readable
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|Lisp_Object
name|table
decl_stmt|;
name|Lisp_Object
name|stream
decl_stmt|;
name|CHECK_SYMBOL
argument_list|(
name|name
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|table
operator|=
name|Fsymbol_value
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|CHECK_VECTOR
argument_list|(
name|table
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|XSET
argument_list|(
name|stream
argument_list|,
name|Lisp_Buffer
argument_list|,
name|current_buffer
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|NULL
argument_list|(
name|readable
argument_list|)
condition|)
block|{
name|InsStr
argument_list|(
literal|"("
argument_list|)
expr_stmt|;
name|Fprin1
argument_list|(
name|name
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|InsStr
argument_list|(
literal|")\n\n"
argument_list|)
expr_stmt|;
name|map_obarray
argument_list|(
name|table
argument_list|,
name|describe_abbrev
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|InsStr
argument_list|(
literal|"\n\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|InsStr
argument_list|(
literal|"(define-abbrev-table '"
argument_list|)
expr_stmt|;
name|Fprin1
argument_list|(
name|name
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|InsStr
argument_list|(
literal|" '(\n"
argument_list|)
expr_stmt|;
name|map_obarray
argument_list|(
name|table
argument_list|,
name|write_abbrev
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|InsStr
argument_list|(
literal|"    ))\n\n"
argument_list|)
expr_stmt|;
block|}
return|return
name|Qnil
return|;
block|}
end_block

begin_escape
end_escape

begin_macro
name|DEFUN
argument_list|(
literal|"define-abbrev-table"
argument_list|,
argument|Fdefine_abbrev_table
argument_list|,
argument|Sdefine_abbrev_table
argument_list|,
literal|2
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
literal|"Define TABNAME (a symbol) as an abbrev table name.\n\ Define abbrevs in it according to DEFINITIONS, a list of elements\n\ of the form (ABBREVNAME EXPANSION HOOK USECOUNT)."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|tabname
operator|,
name|defns
operator|)
name|Lisp_Object
name|tabname
operator|,
name|defns
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|Lisp_Object
name|name
decl_stmt|,
name|exp
decl_stmt|,
name|hook
decl_stmt|,
name|count
decl_stmt|;
name|Lisp_Object
name|table
decl_stmt|,
name|elt
decl_stmt|;
name|CHECK_SYMBOL
argument_list|(
name|tabname
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|table
operator|=
name|Fboundp
argument_list|(
name|tabname
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
argument_list|(
name|table
argument_list|)
operator|||
operator|(
name|table
operator|=
name|Fsymbol_value
argument_list|(
name|tabname
argument_list|)
operator|,
name|NULL
argument_list|(
name|table
argument_list|)
operator|)
condition|)
block|{
name|table
operator|=
name|Fmake_abbrev_table
argument_list|()
expr_stmt|;
name|Fset
argument_list|(
name|tabname
argument_list|,
name|table
argument_list|)
expr_stmt|;
name|Vabbrev_table_name_list
operator|=
name|Fcons
argument_list|(
name|tabname
argument_list|,
name|Vabbrev_table_name_list
argument_list|)
expr_stmt|;
block|}
name|CHECK_VECTOR
argument_list|(
name|table
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
init|;
operator|!
name|NULL
argument_list|(
name|defns
argument_list|)
condition|;
name|defns
operator|=
name|Fcdr
argument_list|(
name|defns
argument_list|)
control|)
block|{
name|elt
operator|=
name|Fcar
argument_list|(
name|defns
argument_list|)
expr_stmt|;
name|name
operator|=
name|Fcar
argument_list|(
name|elt
argument_list|)
expr_stmt|;
name|elt
operator|=
name|Fcdr
argument_list|(
name|elt
argument_list|)
expr_stmt|;
name|exp
operator|=
name|Fcar
argument_list|(
name|elt
argument_list|)
expr_stmt|;
name|elt
operator|=
name|Fcdr
argument_list|(
name|elt
argument_list|)
expr_stmt|;
name|hook
operator|=
name|Fcar
argument_list|(
name|elt
argument_list|)
expr_stmt|;
name|elt
operator|=
name|Fcdr
argument_list|(
name|elt
argument_list|)
expr_stmt|;
name|count
operator|=
name|Fcar
argument_list|(
name|elt
argument_list|)
expr_stmt|;
name|Fdefine_abbrev
argument_list|(
name|table
argument_list|,
name|name
argument_list|,
name|exp
argument_list|,
name|hook
argument_list|,
name|count
argument_list|)
expr_stmt|;
block|}
return|return
name|Qnil
return|;
block|}
end_block

begin_escape
end_escape

begin_macro
name|syms_of_abbrev
argument_list|()
end_macro

begin_block
block|{
name|DEFVAR_LISP
argument_list|(
literal|"abbrev-table-name-list"
argument_list|,
operator|&
name|Vabbrev_table_name_list
argument_list|,
literal|"List of symbols whose values are  abbrev tables."
argument_list|)
expr_stmt|;
name|Vabbrev_table_name_list
operator|=
name|Fcons
argument_list|(
name|intern
argument_list|(
literal|"fundamental-mode-abbrev-table"
argument_list|)
argument_list|,
name|Fcons
argument_list|(
name|intern
argument_list|(
literal|"global-abbrev-table"
argument_list|)
argument_list|,
name|Qnil
argument_list|)
argument_list|)
expr_stmt|;
name|DEFVAR_LISP
argument_list|(
literal|"global-abbrev-table"
argument_list|,
operator|&
name|Vglobal_abbrev_table
argument_list|,
literal|"The abbrev table whose abbrevs affect all buffers.\n\ Each buffer may also have a local abbrev table.\n\ If it does, the local table overrides the global one\n\ for any particular abbrev defined in both."
argument_list|)
expr_stmt|;
name|Vglobal_abbrev_table
operator|=
name|Fmake_abbrev_table
argument_list|()
expr_stmt|;
name|DEFVAR_LISP
argument_list|(
literal|"fundamental-mode-abbrev-table"
argument_list|,
operator|&
name|Vfundamental_mode_abbrev_table
argument_list|,
literal|"The abbrev table of mode-specific abbrevs for Fundamental Mode."
argument_list|)
expr_stmt|;
name|Vfundamental_mode_abbrev_table
operator|=
name|Fmake_abbrev_table
argument_list|()
expr_stmt|;
name|current_buffer
operator|->
name|abbrev_table
operator|=
name|Vfundamental_mode_abbrev_table
expr_stmt|;
name|DEFVAR_LISP
argument_list|(
literal|"last-abbrev"
argument_list|,
operator|&
name|Vlast_abbrev
argument_list|,
literal|"The abbrev-symbol of the last abbrev expanded."
argument_list|)
expr_stmt|;
name|DEFVAR_LISP
argument_list|(
literal|"last-abbrev-text"
argument_list|,
operator|&
name|Vlast_abbrev_text
argument_list|,
literal|"The exact text of the last abbrev expanded.\n\ nil if the abbrev has already been unexpanded."
argument_list|)
expr_stmt|;
name|DEFVAR_INT
argument_list|(
literal|"last-abbrev-location"
argument_list|,
operator|&
name|last_abbrev_point
argument_list|,
literal|"The location of the last abbrev expanded."
argument_list|)
expr_stmt|;
name|Vlast_abbrev
operator|=
name|Qnil
expr_stmt|;
name|Vlast_abbrev_text
operator|=
name|Qnil
expr_stmt|;
name|last_abbrev_point
operator|=
literal|0
expr_stmt|;
name|DEFVAR_LISP
argument_list|(
literal|"abbrev-start-location"
argument_list|,
operator|&
name|Vabbrev_start_location
argument_list|,
literal|"Buffer position for expand-abbrev to use as the start of the abbrev.\n\ nil means use the word before point as the abbrev.\n\ Set to nil each time expand-abbrev is called."
argument_list|)
expr_stmt|;
name|Vabbrev_start_location
operator|=
name|Qnil
expr_stmt|;
name|DEFVAR_LISP
argument_list|(
literal|"abbrev-start-location-buffer"
argument_list|,
operator|&
name|Vabbrev_start_location_buffer
argument_list|,
literal|"Buffer that abbrev-start-location has been set for.\n\ Trying to expand an abbrev in any other buffer clears abbrev-start-location."
argument_list|)
expr_stmt|;
name|Vabbrev_start_location_buffer
operator|=
name|Qnil
expr_stmt|;
name|DEFVAR_PER_BUFFER
argument_list|(
literal|"local-abbrev-table"
argument_list|,
operator|&
name|current_buffer
operator|->
name|abbrev_table
argument_list|,
literal|"Local (mode-specific) abbrev table of current buffer."
argument_list|)
expr_stmt|;
name|DEFVAR_BOOL
argument_list|(
literal|"abbrevs-changed"
argument_list|,
operator|&
name|abbrevs_changed
argument_list|,
literal|"Set non-nil by defining or altering any word abbrevs."
argument_list|)
expr_stmt|;
name|abbrevs_changed
operator|=
literal|0
expr_stmt|;
name|DEFVAR_BOOL
argument_list|(
literal|"abbrev-all-caps"
argument_list|,
operator|&
name|abbrev_all_caps
argument_list|,
literal|"*Set non-nil means expand multi-word abbrevs all caps if abbrev was so."
argument_list|)
expr_stmt|;
name|abbrev_all_caps
operator|=
literal|0
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Smake_abbrev_table
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sclear_abbrev_table
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sdefine_abbrev
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sdefine_global_abbrev
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sdefine_mode_abbrev
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sabbrev_expansion
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sabbrev_symbol
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sexpand_abbrev
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sunexpand_abbrev
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sinsert_abbrev_table_description
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sdefine_abbrev_table
argument_list|)
expr_stmt|;
block|}
end_block

end_unit

