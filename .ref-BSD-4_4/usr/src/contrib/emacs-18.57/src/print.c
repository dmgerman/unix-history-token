begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Lisp object printing and output streams.    Copyright (C) 1985, 1986, 1990 Free Software Foundation, Inc.  This file is part of GNU Emacs.  GNU Emacs is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 1, or (at your option) any later version.  GNU Emacs is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU Emacs; see the file COPYING.  If not, write to the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_undef
undef|#
directive|undef
name|NULL
end_undef

begin_include
include|#
directive|include
file|"lisp.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|standalone
end_ifndef

begin_include
include|#
directive|include
file|"buffer.h"
end_include

begin_include
include|#
directive|include
file|"window.h"
end_include

begin_include
include|#
directive|include
file|"process.h"
end_include

begin_include
include|#
directive|include
file|"dispextern.h"
end_include

begin_include
include|#
directive|include
file|"termchar.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not standalone */
end_comment

begin_decl_stmt
name|Lisp_Object
name|Vstandard_output
decl_stmt|,
name|Qstandard_output
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Avoid actual stack overflow in print.  */
end_comment

begin_decl_stmt
name|int
name|print_depth
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Maximum length of list to print in full; noninteger means    effectively infinity */
end_comment

begin_decl_stmt
name|Lisp_Object
name|Vprint_length
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means print newlines in strings as \n.  */
end_comment

begin_decl_stmt
name|int
name|print_escape_newlines
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means print newline before next minibuffer message.    Defined in xdisp.c */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|noninteractive_need_newline
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|MAX_PRINT_CHARS
end_ifdef

begin_decl_stmt
specifier|static
name|int
name|print_chars
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|max_print
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* MAX_PRINT_CHARS */
end_comment

begin_escape
end_escape

begin_comment
comment|/* Low level output routines for charaters and strings */
end_comment

begin_comment
comment|/* Lisp functions to do output using a stream  must have the stream in a variable called printcharfun  and must start with PRINTPREPARE and end with PRINTFINISH.  Use PRINTCHAR to output one character,  or call strout to output a block of characters.  Also, each one must have the declarations    struct buffer *old = current_buffer;    int old_point = -1, start_point;    Lisp_Object original; */
end_comment

begin_define
define|#
directive|define
name|PRINTPREPARE
define|\
value|original = printcharfun; \    if (NULL (printcharfun)) printcharfun = Qt; \    if (XTYPE (printcharfun) == Lisp_Buffer) \      { if (XBUFFER (printcharfun) != current_buffer) Fset_buffer (printcharfun); \        printcharfun = Qnil;}\    if (XTYPE (printcharfun) == Lisp_Marker) \      { if (XMARKER (original)->buffer != current_buffer) \          set_buffer_internal (XMARKER (original)->buffer); \        old_point = point; \        SET_PT (marker_position (printcharfun)); \        start_point = point; \        printcharfun = Qnil;}
end_define

begin_define
define|#
directive|define
name|PRINTFINISH
define|\
value|if (XTYPE (original) == Lisp_Marker) \      Fset_marker (original, make_number (point), Qnil); \    if (old_point>= 0) \      SET_PT ((old_point>= start_point ? point - start_point : 0) + old_point); \    if (old != current_buffer) \      set_buffer_internal (old)
end_define

begin_define
define|#
directive|define
name|PRINTCHAR
parameter_list|(
name|ch
parameter_list|)
value|printchar (ch, printcharfun)
end_define

begin_comment
comment|/* Index of first unused element of message_buf.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|printbufidx
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|printchar
parameter_list|(
name|ch
parameter_list|,
name|fun
parameter_list|)
name|unsigned
name|char
name|ch
decl_stmt|;
name|Lisp_Object
name|fun
decl_stmt|;
block|{
name|Lisp_Object
name|ch1
decl_stmt|;
ifdef|#
directive|ifdef
name|MAX_PRINT_CHARS
if|if
condition|(
name|max_print
condition|)
name|print_chars
operator|++
expr_stmt|;
endif|#
directive|endif
comment|/* MAX_PRINT_CHARS */
ifndef|#
directive|ifndef
name|standalone
if|if
condition|(
name|EQ
argument_list|(
name|fun
argument_list|,
name|Qnil
argument_list|)
condition|)
block|{
name|QUIT
expr_stmt|;
name|insert
argument_list|(
operator|&
name|ch
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|EQ
argument_list|(
name|fun
argument_list|,
name|Qt
argument_list|)
condition|)
block|{
if|if
condition|(
name|noninteractive
condition|)
block|{
name|putchar
argument_list|(
name|ch
argument_list|)
expr_stmt|;
name|noninteractive_need_newline
operator|=
literal|1
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|echo_area_contents
operator|!=
name|message_buf
condition|)
name|echo_area_contents
operator|=
name|message_buf
operator|,
name|printbufidx
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|printbufidx
operator|<
name|screen_width
condition|)
name|message_buf
index|[
name|printbufidx
operator|++
index|]
operator|=
name|ch
expr_stmt|;
name|message_buf
index|[
name|printbufidx
index|]
operator|=
literal|0
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
comment|/* not standalone */
name|XFASTINT
argument_list|(
name|ch1
argument_list|)
operator|=
name|ch
expr_stmt|;
name|call1
argument_list|(
name|fun
argument_list|,
name|ch1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|strout
parameter_list|(
name|ptr
parameter_list|,
name|size
parameter_list|,
name|printcharfun
parameter_list|)
name|char
modifier|*
name|ptr
decl_stmt|;
name|int
name|size
decl_stmt|;
name|Lisp_Object
name|printcharfun
decl_stmt|;
block|{
name|int
name|i
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|EQ
argument_list|(
name|printcharfun
argument_list|,
name|Qnil
argument_list|)
condition|)
block|{
name|insert
argument_list|(
name|ptr
argument_list|,
name|size
operator|>=
literal|0
condition|?
name|size
else|:
name|strlen
argument_list|(
name|ptr
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MAX_PRINT_CHARS
if|if
condition|(
name|max_print
condition|)
name|print_chars
operator|+=
name|size
operator|>=
literal|0
condition|?
name|size
else|:
name|strlen
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* MAX_PRINT_CHARS */
return|return;
block|}
if|if
condition|(
name|EQ
argument_list|(
name|printcharfun
argument_list|,
name|Qt
argument_list|)
condition|)
block|{
name|i
operator|=
name|size
operator|>=
literal|0
condition|?
name|size
else|:
name|strlen
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MAX_PRINT_CHARS
if|if
condition|(
name|max_print
condition|)
name|print_chars
operator|+=
name|i
expr_stmt|;
endif|#
directive|endif
comment|/* MAX_PRINT_CHARS */
if|if
condition|(
name|noninteractive
condition|)
block|{
name|fwrite
argument_list|(
name|ptr
argument_list|,
literal|1
argument_list|,
name|i
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|noninteractive_need_newline
operator|=
literal|1
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|echo_area_contents
operator|!=
name|message_buf
condition|)
name|echo_area_contents
operator|=
name|message_buf
operator|,
name|printbufidx
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|i
operator|>
name|screen_width
operator|-
name|printbufidx
condition|)
name|i
operator|=
name|screen_width
operator|-
name|printbufidx
expr_stmt|;
name|bcopy
argument_list|(
name|ptr
argument_list|,
operator|&
name|message_buf
index|[
name|printbufidx
index|]
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|printbufidx
operator|+=
name|i
expr_stmt|;
name|message_buf
index|[
name|printbufidx
index|]
operator|=
literal|0
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|size
operator|>=
literal|0
condition|)
while|while
condition|(
name|i
operator|<
name|size
condition|)
name|PRINTCHAR
argument_list|(
name|ptr
index|[
name|i
operator|++
index|]
argument_list|)
expr_stmt|;
else|else
while|while
condition|(
name|ptr
index|[
name|i
index|]
condition|)
name|PRINTCHAR
argument_list|(
name|ptr
index|[
name|i
operator|++
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_macro
name|DEFUN
argument_list|(
literal|"write-char"
argument_list|,
argument|Fwrite_char
argument_list|,
argument|Swrite_char
argument_list|,
literal|1
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
literal|"Output character CHAR to stream STREAM.\n\ STREAM defaults to the value of `standard-output' (which see)."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|ch
operator|,
name|printcharfun
operator|)
name|Lisp_Object
name|ch
operator|,
name|printcharfun
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|struct
name|buffer
modifier|*
name|old
init|=
name|current_buffer
decl_stmt|;
name|int
name|old_point
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|start_point
decl_stmt|;
name|Lisp_Object
name|original
decl_stmt|;
if|if
condition|(
name|NULL
argument_list|(
name|printcharfun
argument_list|)
condition|)
name|printcharfun
operator|=
name|Vstandard_output
expr_stmt|;
name|CHECK_NUMBER
argument_list|(
name|ch
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|PRINTPREPARE
expr_stmt|;
name|PRINTCHAR
argument_list|(
name|XINT
argument_list|(
name|ch
argument_list|)
argument_list|)
expr_stmt|;
name|PRINTFINISH
expr_stmt|;
return|return
name|ch
return|;
block|}
end_block

begin_macro
name|write_string
argument_list|(
argument|data
argument_list|,
argument|size
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|data
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|size
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|buffer
modifier|*
name|old
init|=
name|current_buffer
decl_stmt|;
name|Lisp_Object
name|printcharfun
decl_stmt|;
name|int
name|old_point
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|start_point
decl_stmt|;
name|Lisp_Object
name|original
decl_stmt|;
name|printcharfun
operator|=
name|Vstandard_output
expr_stmt|;
name|PRINTPREPARE
expr_stmt|;
name|strout
argument_list|(
name|data
argument_list|,
name|size
argument_list|,
name|printcharfun
argument_list|)
expr_stmt|;
name|PRINTFINISH
expr_stmt|;
block|}
end_block

begin_macro
name|write_string_1
argument_list|(
argument|data
argument_list|,
argument|size
argument_list|,
argument|printcharfun
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|data
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|size
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Lisp_Object
name|printcharfun
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|buffer
modifier|*
name|old
init|=
name|current_buffer
decl_stmt|;
name|int
name|old_point
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|start_point
decl_stmt|;
name|Lisp_Object
name|original
decl_stmt|;
name|PRINTPREPARE
expr_stmt|;
name|strout
argument_list|(
name|data
argument_list|,
name|size
argument_list|,
name|printcharfun
argument_list|)
expr_stmt|;
name|PRINTFINISH
expr_stmt|;
block|}
end_block

begin_ifndef
ifndef|#
directive|ifndef
name|standalone
end_ifndef

begin_macro
name|temp_output_buffer_setup
argument_list|(
argument|bufname
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|bufname
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|buffer
modifier|*
name|old
init|=
name|current_buffer
decl_stmt|;
specifier|register
name|Lisp_Object
name|buf
decl_stmt|;
name|Fset_buffer
argument_list|(
name|Fget_buffer_create
argument_list|(
name|build_string
argument_list|(
name|bufname
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|current_buffer
operator|->
name|read_only
operator|=
name|Qnil
expr_stmt|;
name|Ferase_buffer
argument_list|()
expr_stmt|;
name|XSET
argument_list|(
name|buf
argument_list|,
name|Lisp_Buffer
argument_list|,
name|current_buffer
argument_list|)
expr_stmt|;
name|specbind
argument_list|(
name|Qstandard_output
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|set_buffer_internal
argument_list|(
name|old
argument_list|)
expr_stmt|;
block|}
end_block

begin_decl_stmt
name|Lisp_Object
name|internal_with_output_to_temp_buffer
argument_list|(
name|bufname
argument_list|,
name|function
argument_list|,
name|args
argument_list|)
name|char
modifier|*
name|bufname
decl_stmt|;
end_decl_stmt

begin_function_decl
name|Lisp_Object
function_decl|(
modifier|*
name|function
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|Lisp_Object
name|args
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|count
init|=
name|specpdl_ptr
operator|-
name|specpdl
decl_stmt|;
name|Lisp_Object
name|buf
decl_stmt|,
name|val
decl_stmt|;
name|record_unwind_protect
argument_list|(
name|Fset_buffer
argument_list|,
name|Fcurrent_buffer
argument_list|()
argument_list|)
expr_stmt|;
name|temp_output_buffer_setup
argument_list|(
name|bufname
argument_list|)
expr_stmt|;
name|buf
operator|=
name|Vstandard_output
expr_stmt|;
name|val
operator|=
call|(
modifier|*
name|function
call|)
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|temp_output_buffer_show
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|unbind_to
argument_list|(
name|count
argument_list|)
expr_stmt|;
return|return
name|val
return|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"with-output-to-temp-buffer"
argument_list|,
argument|Fwith_output_to_temp_buffer
argument_list|,
argument|Swith_output_to_temp_buffer
argument_list|,
literal|1
argument_list|,
argument|UNEVALLED
argument_list|,
literal|0
argument_list|,
literal|"Binding `standard-output' to buffer named BUFNAME, execute BODY then display that buffer.\n\ The buffer is cleared out initially, and marked as unmodified when done.\n\ All output done by BODY is inserted in that buffer by default.\n\ It is displayed in another window, but not selected.\n\ The value of the last form in BODY is returned.\n\ If variable `temp-buffer-show-hook' is non-nil, call it at the end\n\ to get the buffer displayed.  It gets one argument, the buffer to display."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|args
operator|)
name|Lisp_Object
name|args
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|struct
name|gcpro
name|gcpro1
decl_stmt|;
name|Lisp_Object
name|name
decl_stmt|;
name|int
name|count
init|=
name|specpdl_ptr
operator|-
name|specpdl
decl_stmt|;
name|Lisp_Object
name|buf
decl_stmt|,
name|val
decl_stmt|;
name|GCPRO1
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|name
operator|=
name|Feval
argument_list|(
name|Fcar
argument_list|(
name|args
argument_list|)
argument_list|)
expr_stmt|;
name|UNGCPRO
expr_stmt|;
name|CHECK_STRING
argument_list|(
name|name
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|temp_output_buffer_setup
argument_list|(
name|XSTRING
argument_list|(
name|name
argument_list|)
operator|->
name|data
argument_list|)
expr_stmt|;
name|buf
operator|=
name|Vstandard_output
expr_stmt|;
name|val
operator|=
name|Fprogn
argument_list|(
name|Fcdr
argument_list|(
name|args
argument_list|)
argument_list|)
expr_stmt|;
name|temp_output_buffer_show
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|unbind_to
argument_list|(
name|count
argument_list|)
expr_stmt|;
return|return
name|val
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not standalone */
end_comment

begin_escape
end_escape

begin_function_decl
specifier|static
name|void
name|print
parameter_list|()
function_decl|;
end_function_decl

begin_macro
name|DEFUN
argument_list|(
literal|"terpri"
argument_list|,
argument|Fterpri
argument_list|,
argument|Sterpri
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|"Output a newline to STREAM (or value of standard-output)."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|printcharfun
operator|)
name|Lisp_Object
name|printcharfun
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|struct
name|buffer
modifier|*
name|old
init|=
name|current_buffer
decl_stmt|;
name|int
name|old_point
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|start_point
decl_stmt|;
name|Lisp_Object
name|original
decl_stmt|;
if|if
condition|(
name|NULL
argument_list|(
name|printcharfun
argument_list|)
condition|)
name|printcharfun
operator|=
name|Vstandard_output
expr_stmt|;
name|PRINTPREPARE
expr_stmt|;
name|PRINTCHAR
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|PRINTFINISH
expr_stmt|;
return|return
name|Qt
return|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"prin1"
argument_list|,
argument|Fprin1
argument_list|,
argument|Sprin1
argument_list|,
literal|1
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
literal|"Output the printed representation of OBJECT, any Lisp object.\n\ Quoting characters are printed when needed to make output that `read'\n\ can handle, whenever this is possible.\n\ Output stream is STREAM, or value of `standard-output' (which see)."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|obj
operator|,
name|printcharfun
operator|)
name|Lisp_Object
name|obj
operator|,
name|printcharfun
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|struct
name|buffer
modifier|*
name|old
init|=
name|current_buffer
decl_stmt|;
name|int
name|old_point
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|start_point
decl_stmt|;
name|Lisp_Object
name|original
decl_stmt|;
ifdef|#
directive|ifdef
name|MAX_PRINT_CHARS
name|max_print
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
comment|/* MAX_PRINT_CHARS */
if|if
condition|(
name|NULL
argument_list|(
name|printcharfun
argument_list|)
condition|)
name|printcharfun
operator|=
name|Vstandard_output
expr_stmt|;
name|PRINTPREPARE
expr_stmt|;
name|print_depth
operator|=
literal|0
expr_stmt|;
name|print
argument_list|(
name|obj
argument_list|,
name|printcharfun
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|PRINTFINISH
expr_stmt|;
return|return
name|obj
return|;
block|}
end_block

begin_comment
comment|/* a buffer which is used to hold output being built by prin1-to-string */
end_comment

begin_decl_stmt
name|Lisp_Object
name|Vprin1_to_string_buffer
decl_stmt|;
end_decl_stmt

begin_macro
name|DEFUN
argument_list|(
literal|"prin1-to-string"
argument_list|,
argument|Fprin1_to_string
argument_list|,
argument|Sprin1_to_string
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|"Return a string containing the printed representation of OBJECT,\n\ any Lisp object.  Quoting characters are used when needed to make output\n\ that `read' can handle, whenever this is possible."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|obj
operator|)
name|Lisp_Object
name|obj
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|struct
name|buffer
modifier|*
name|old
init|=
name|current_buffer
decl_stmt|;
name|int
name|old_point
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|start_point
decl_stmt|;
name|Lisp_Object
name|original
decl_stmt|,
name|printcharfun
decl_stmt|;
name|struct
name|gcpro
name|gcpro1
decl_stmt|;
name|printcharfun
operator|=
name|Vprin1_to_string_buffer
expr_stmt|;
name|PRINTPREPARE
expr_stmt|;
name|print_depth
operator|=
literal|0
expr_stmt|;
name|print
argument_list|(
name|obj
argument_list|,
name|printcharfun
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Make Vprin1_to_string_buffer be the default buffer after PRINTFINSH */
name|PRINTFINISH
expr_stmt|;
name|set_buffer_internal
argument_list|(
name|XBUFFER
argument_list|(
name|Vprin1_to_string_buffer
argument_list|)
argument_list|)
expr_stmt|;
name|obj
operator|=
name|Fbuffer_string
argument_list|()
expr_stmt|;
name|GCPRO1
argument_list|(
name|obj
argument_list|)
expr_stmt|;
name|Ferase_buffer
argument_list|()
expr_stmt|;
name|set_buffer_internal
argument_list|(
name|old
argument_list|)
expr_stmt|;
name|UNGCPRO
expr_stmt|;
return|return
name|obj
return|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"princ"
argument_list|,
argument|Fprinc
argument_list|,
argument|Sprinc
argument_list|,
literal|1
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
literal|"Output the printed representation of OBJECT, any Lisp object.\n\ No quoting characters are used; no delimiters are printed around\n\ the contents of strings.\n\ Output stream is STREAM, or value of standard-output (which see)."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|obj
operator|,
name|printcharfun
operator|)
name|Lisp_Object
name|obj
operator|,
name|printcharfun
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|struct
name|buffer
modifier|*
name|old
init|=
name|current_buffer
decl_stmt|;
name|int
name|old_point
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|start_point
decl_stmt|;
name|Lisp_Object
name|original
decl_stmt|;
if|if
condition|(
name|NULL
argument_list|(
name|printcharfun
argument_list|)
condition|)
name|printcharfun
operator|=
name|Vstandard_output
expr_stmt|;
name|PRINTPREPARE
expr_stmt|;
name|print_depth
operator|=
literal|0
expr_stmt|;
name|print
argument_list|(
name|obj
argument_list|,
name|printcharfun
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|PRINTFINISH
expr_stmt|;
return|return
name|obj
return|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"print"
argument_list|,
argument|Fprint
argument_list|,
argument|Sprint
argument_list|,
literal|1
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
literal|"Output the printed representation of OBJECT, with newlines around it.\n\ Quoting characters are printed when needed to make output that `read'\n\ can handle, whenever this is possible.\n\ Output stream is STREAM, or value of `standard-output' (which see)."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|obj
operator|,
name|printcharfun
operator|)
name|Lisp_Object
name|obj
operator|,
name|printcharfun
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|struct
name|buffer
modifier|*
name|old
init|=
name|current_buffer
decl_stmt|;
name|int
name|old_point
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|start_point
decl_stmt|;
name|Lisp_Object
name|original
decl_stmt|;
name|struct
name|gcpro
name|gcpro1
decl_stmt|;
ifdef|#
directive|ifdef
name|MAX_PRINT_CHARS
name|print_chars
operator|=
literal|0
expr_stmt|;
name|max_print
operator|=
name|MAX_PRINT_CHARS
expr_stmt|;
endif|#
directive|endif
comment|/* MAX_PRINT_CHARS */
if|if
condition|(
name|NULL
argument_list|(
name|printcharfun
argument_list|)
condition|)
name|printcharfun
operator|=
name|Vstandard_output
expr_stmt|;
name|GCPRO1
argument_list|(
name|obj
argument_list|)
expr_stmt|;
name|PRINTPREPARE
expr_stmt|;
name|print_depth
operator|=
literal|0
expr_stmt|;
name|PRINTCHAR
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|print
argument_list|(
name|obj
argument_list|,
name|printcharfun
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|PRINTCHAR
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|PRINTFINISH
expr_stmt|;
ifdef|#
directive|ifdef
name|MAX_PRINT_CHARS
name|max_print
operator|=
literal|0
expr_stmt|;
name|print_chars
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
comment|/* MAX_PRINT_CHARS */
name|UNGCPRO
expr_stmt|;
return|return
name|obj
return|;
block|}
end_block

begin_escape
end_escape

begin_function
specifier|static
name|void
name|print
parameter_list|(
name|obj
parameter_list|,
name|printcharfun
parameter_list|,
name|escapeflag
parameter_list|)
ifndef|#
directive|ifndef
name|RTPC_REGISTER_BUG
specifier|register
name|Lisp_Object
name|obj
decl_stmt|;
else|#
directive|else
name|Lisp_Object
name|obj
decl_stmt|;
endif|#
directive|endif
specifier|register
name|Lisp_Object
name|printcharfun
decl_stmt|;
name|int
name|escapeflag
decl_stmt|;
block|{
name|char
name|buf
index|[
literal|30
index|]
decl_stmt|;
name|QUIT
expr_stmt|;
name|print_depth
operator|++
expr_stmt|;
if|if
condition|(
name|print_depth
operator|>
literal|200
condition|)
name|error
argument_list|(
literal|"Apparently circular structure being printed"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MAX_PRINT_CHARS
if|if
condition|(
name|max_print
operator|&&
name|print_chars
operator|>
name|max_print
condition|)
block|{
name|PRINTCHAR
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|print_chars
operator|=
literal|0
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* MAX_PRINT_CHARS */
ifdef|#
directive|ifdef
name|SWITCH_ENUM_BUG
switch|switch
condition|(
operator|(
name|int
operator|)
name|XTYPE
argument_list|(
name|obj
argument_list|)
condition|)
else|#
directive|else
switch|switch
condition|(
name|XTYPE
argument_list|(
name|obj
argument_list|)
condition|)
endif|#
directive|endif
block|{
default|default:
comment|/* We're in trouble if this happens! 	 Probably should just abort () */
name|strout
argument_list|(
literal|"#<EMACS BUG: INVALID DATATYPE "
argument_list|,
operator|-
literal|1
argument_list|,
name|printcharfun
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"(#o%3o)"
argument_list|,
operator|(
name|int
operator|)
name|XTYPE
argument_list|(
name|obj
argument_list|)
argument_list|)
expr_stmt|;
name|strout
argument_list|(
name|buf
argument_list|,
operator|-
literal|1
argument_list|,
name|printcharfun
argument_list|)
expr_stmt|;
name|strout
argument_list|(
literal|" Save your buffers immediately and please report this bug>"
argument_list|,
operator|-
literal|1
argument_list|,
name|printcharfun
argument_list|)
expr_stmt|;
break|break;
case|case
name|Lisp_Int
case|:
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%d"
argument_list|,
name|XINT
argument_list|(
name|obj
argument_list|)
argument_list|)
expr_stmt|;
name|strout
argument_list|(
name|buf
argument_list|,
operator|-
literal|1
argument_list|,
name|printcharfun
argument_list|)
expr_stmt|;
break|break;
case|case
name|Lisp_String
case|:
if|if
condition|(
operator|!
name|escapeflag
condition|)
name|strout
argument_list|(
name|XSTRING
argument_list|(
name|obj
argument_list|)
operator|->
name|data
argument_list|,
name|XSTRING
argument_list|(
name|obj
argument_list|)
operator|->
name|size
argument_list|,
name|printcharfun
argument_list|)
expr_stmt|;
else|else
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|unsigned
name|char
modifier|*
name|p
init|=
name|XSTRING
argument_list|(
name|obj
argument_list|)
operator|->
name|data
decl_stmt|;
specifier|register
name|unsigned
name|char
name|c
decl_stmt|;
name|PRINTCHAR
argument_list|(
literal|'\"'
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|XSTRING
argument_list|(
name|obj
argument_list|)
operator|->
name|size
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|QUIT
expr_stmt|;
name|c
operator|=
operator|*
name|p
operator|++
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\n'
operator|&&
name|print_escape_newlines
condition|)
block|{
name|PRINTCHAR
argument_list|(
literal|'\\'
argument_list|)
expr_stmt|;
name|PRINTCHAR
argument_list|(
literal|'n'
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|c
operator|==
literal|'\"'
operator|||
name|c
operator|==
literal|'\\'
condition|)
name|PRINTCHAR
argument_list|(
literal|'\\'
argument_list|)
expr_stmt|;
name|PRINTCHAR
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
block|}
name|PRINTCHAR
argument_list|(
literal|'\"'
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|Lisp_Symbol
case|:
block|{
specifier|register
name|int
name|confusing
decl_stmt|;
specifier|register
name|unsigned
name|char
modifier|*
name|p
init|=
name|XSYMBOL
argument_list|(
name|obj
argument_list|)
operator|->
name|name
operator|->
name|data
decl_stmt|;
specifier|register
name|unsigned
name|char
modifier|*
name|end
init|=
name|p
operator|+
name|XSYMBOL
argument_list|(
name|obj
argument_list|)
operator|->
name|name
operator|->
name|size
decl_stmt|;
specifier|register
name|unsigned
name|char
name|c
decl_stmt|;
if|if
condition|(
name|p
operator|!=
name|end
operator|&&
operator|(
operator|*
name|p
operator|==
literal|'-'
operator|||
operator|*
name|p
operator|==
literal|'+'
operator|)
condition|)
name|p
operator|++
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|end
condition|)
name|confusing
operator|=
literal|0
expr_stmt|;
else|else
block|{
while|while
condition|(
name|p
operator|!=
name|end
operator|&&
operator|*
name|p
operator|>=
literal|'0'
operator|&&
operator|*
name|p
operator|<=
literal|'9'
condition|)
name|p
operator|++
expr_stmt|;
name|confusing
operator|=
operator|(
name|end
operator|==
name|p
operator|)
expr_stmt|;
block|}
name|p
operator|=
name|XSYMBOL
argument_list|(
name|obj
argument_list|)
operator|->
name|name
operator|->
name|data
expr_stmt|;
while|while
condition|(
name|p
operator|!=
name|end
condition|)
block|{
name|QUIT
expr_stmt|;
name|c
operator|=
operator|*
name|p
operator|++
expr_stmt|;
if|if
condition|(
name|escapeflag
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'\"'
operator|||
name|c
operator|==
literal|'\\'
operator|||
name|c
operator|==
literal|'\''
operator|||
name|c
operator|==
literal|';'
operator|||
name|c
operator|==
literal|'#'
operator|||
name|c
operator|==
literal|'('
operator|||
name|c
operator|==
literal|')'
operator|||
name|c
operator|==
literal|','
operator|||
name|c
operator|==
literal|'.'
operator|||
name|c
operator|==
literal|'`'
operator|||
name|c
operator|==
literal|'['
operator|||
name|c
operator|==
literal|']'
operator|||
name|c
operator|==
literal|'?'
operator|||
name|c
operator|<=
literal|040
operator|||
name|confusing
condition|)
name|PRINTCHAR
argument_list|(
literal|'\\'
argument_list|)
operator|,
name|confusing
operator|=
literal|0
expr_stmt|;
block|}
name|PRINTCHAR
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|Lisp_Cons
case|:
name|PRINTCHAR
argument_list|(
literal|'('
argument_list|)
expr_stmt|;
block|{
specifier|register
name|int
name|i
init|=
literal|0
decl_stmt|;
specifier|register
name|int
name|max
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|XTYPE
argument_list|(
name|Vprint_length
argument_list|)
operator|==
name|Lisp_Int
condition|)
name|max
operator|=
name|XINT
argument_list|(
name|Vprint_length
argument_list|)
expr_stmt|;
while|while
condition|(
name|CONSP
argument_list|(
name|obj
argument_list|)
condition|)
block|{
if|if
condition|(
name|i
operator|++
condition|)
name|PRINTCHAR
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
if|if
condition|(
name|max
operator|&&
name|i
operator|>
name|max
condition|)
block|{
name|strout
argument_list|(
literal|"..."
argument_list|,
literal|3
argument_list|,
name|printcharfun
argument_list|)
expr_stmt|;
break|break;
block|}
name|print
argument_list|(
name|Fcar
argument_list|(
name|obj
argument_list|)
argument_list|,
name|printcharfun
argument_list|,
name|escapeflag
argument_list|)
expr_stmt|;
name|obj
operator|=
name|Fcdr
argument_list|(
name|obj
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|NULL
argument_list|(
name|obj
argument_list|)
operator|&&
operator|!
name|CONSP
argument_list|(
name|obj
argument_list|)
condition|)
block|{
name|strout
argument_list|(
literal|" . "
argument_list|,
literal|3
argument_list|,
name|printcharfun
argument_list|)
expr_stmt|;
name|print
argument_list|(
name|obj
argument_list|,
name|printcharfun
argument_list|,
name|escapeflag
argument_list|)
expr_stmt|;
block|}
name|PRINTCHAR
argument_list|(
literal|')'
argument_list|)
expr_stmt|;
break|break;
case|case
name|Lisp_Vector
case|:
name|PRINTCHAR
argument_list|(
literal|'['
argument_list|)
expr_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|Lisp_Object
name|tem
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XVECTOR
argument_list|(
name|obj
argument_list|)
operator|->
name|size
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
condition|)
name|PRINTCHAR
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|tem
operator|=
name|XVECTOR
argument_list|(
name|obj
argument_list|)
operator|->
name|contents
index|[
name|i
index|]
expr_stmt|;
name|print
argument_list|(
name|tem
argument_list|,
name|printcharfun
argument_list|,
name|escapeflag
argument_list|)
expr_stmt|;
block|}
block|}
name|PRINTCHAR
argument_list|(
literal|']'
argument_list|)
expr_stmt|;
break|break;
ifndef|#
directive|ifndef
name|standalone
case|case
name|Lisp_Buffer
case|:
if|if
condition|(
name|NULL
argument_list|(
name|XBUFFER
argument_list|(
name|obj
argument_list|)
operator|->
name|name
argument_list|)
condition|)
name|strout
argument_list|(
literal|"#<killed buffer>"
argument_list|,
operator|-
literal|1
argument_list|,
name|printcharfun
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|escapeflag
condition|)
block|{
name|strout
argument_list|(
literal|"#<buffer "
argument_list|,
operator|-
literal|1
argument_list|,
name|printcharfun
argument_list|)
expr_stmt|;
name|strout
argument_list|(
name|XSTRING
argument_list|(
name|XBUFFER
argument_list|(
name|obj
argument_list|)
operator|->
name|name
argument_list|)
operator|->
name|data
argument_list|,
operator|-
literal|1
argument_list|,
name|printcharfun
argument_list|)
expr_stmt|;
name|PRINTCHAR
argument_list|(
literal|'>'
argument_list|)
expr_stmt|;
block|}
else|else
name|strout
argument_list|(
name|XSTRING
argument_list|(
name|XBUFFER
argument_list|(
name|obj
argument_list|)
operator|->
name|name
argument_list|)
operator|->
name|data
argument_list|,
operator|-
literal|1
argument_list|,
name|printcharfun
argument_list|)
expr_stmt|;
break|break;
case|case
name|Lisp_Process
case|:
if|if
condition|(
name|escapeflag
condition|)
block|{
name|strout
argument_list|(
literal|"#<process "
argument_list|,
operator|-
literal|1
argument_list|,
name|printcharfun
argument_list|)
expr_stmt|;
name|strout
argument_list|(
name|XSTRING
argument_list|(
name|XPROCESS
argument_list|(
name|obj
argument_list|)
operator|->
name|name
argument_list|)
operator|->
name|data
argument_list|,
operator|-
literal|1
argument_list|,
name|printcharfun
argument_list|)
expr_stmt|;
name|PRINTCHAR
argument_list|(
literal|'>'
argument_list|)
expr_stmt|;
block|}
else|else
name|strout
argument_list|(
name|XSTRING
argument_list|(
name|XPROCESS
argument_list|(
name|obj
argument_list|)
operator|->
name|name
argument_list|)
operator|->
name|data
argument_list|,
operator|-
literal|1
argument_list|,
name|printcharfun
argument_list|)
expr_stmt|;
break|break;
case|case
name|Lisp_Window
case|:
name|strout
argument_list|(
literal|"#<window "
argument_list|,
operator|-
literal|1
argument_list|,
name|printcharfun
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%d"
argument_list|,
name|XFASTINT
argument_list|(
name|XWINDOW
argument_list|(
name|obj
argument_list|)
operator|->
name|sequence_number
argument_list|)
argument_list|)
expr_stmt|;
name|strout
argument_list|(
name|buf
argument_list|,
operator|-
literal|1
argument_list|,
name|printcharfun
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|NULL
argument_list|(
name|XWINDOW
argument_list|(
name|obj
argument_list|)
operator|->
name|buffer
argument_list|)
condition|)
block|{
name|unsigned
name|char
modifier|*
name|p
init|=
name|XSTRING
argument_list|(
name|XBUFFER
argument_list|(
name|XWINDOW
argument_list|(
name|obj
argument_list|)
operator|->
name|buffer
argument_list|)
operator|->
name|name
argument_list|)
operator|->
name|data
decl_stmt|;
name|strout
argument_list|(
literal|" on "
argument_list|,
operator|-
literal|1
argument_list|,
name|printcharfun
argument_list|)
expr_stmt|;
name|strout
argument_list|(
name|p
argument_list|,
operator|-
literal|1
argument_list|,
name|printcharfun
argument_list|)
expr_stmt|;
block|}
name|PRINTCHAR
argument_list|(
literal|'>'
argument_list|)
expr_stmt|;
break|break;
case|case
name|Lisp_Window_Configuration
case|:
name|strout
argument_list|(
literal|"#<window-configuration>"
argument_list|,
operator|-
literal|1
argument_list|,
name|printcharfun
argument_list|)
expr_stmt|;
break|break;
case|case
name|Lisp_Marker
case|:
name|strout
argument_list|(
literal|"#<marker "
argument_list|,
operator|-
literal|1
argument_list|,
name|printcharfun
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|XMARKER
argument_list|(
name|obj
argument_list|)
operator|->
name|buffer
operator|)
condition|)
name|strout
argument_list|(
literal|"in no buffer"
argument_list|,
operator|-
literal|1
argument_list|,
name|printcharfun
argument_list|)
expr_stmt|;
else|else
block|{
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"at %d"
argument_list|,
name|marker_position
argument_list|(
name|obj
argument_list|)
argument_list|)
expr_stmt|;
name|strout
argument_list|(
name|buf
argument_list|,
operator|-
literal|1
argument_list|,
name|printcharfun
argument_list|)
expr_stmt|;
name|strout
argument_list|(
literal|" in "
argument_list|,
operator|-
literal|1
argument_list|,
name|printcharfun
argument_list|)
expr_stmt|;
name|strout
argument_list|(
name|XSTRING
argument_list|(
name|XMARKER
argument_list|(
name|obj
argument_list|)
operator|->
name|buffer
operator|->
name|name
argument_list|)
operator|->
name|data
argument_list|,
operator|-
literal|1
argument_list|,
name|printcharfun
argument_list|)
expr_stmt|;
block|}
name|PRINTCHAR
argument_list|(
literal|'>'
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* standalone */
case|case
name|Lisp_Subr
case|:
name|strout
argument_list|(
literal|"#<subr "
argument_list|,
operator|-
literal|1
argument_list|,
name|printcharfun
argument_list|)
expr_stmt|;
name|strout
argument_list|(
name|XSUBR
argument_list|(
name|obj
argument_list|)
operator|->
name|symbol_name
argument_list|,
operator|-
literal|1
argument_list|,
name|printcharfun
argument_list|)
expr_stmt|;
name|PRINTCHAR
argument_list|(
literal|'>'
argument_list|)
expr_stmt|;
break|break;
block|}
name|print_depth
operator|--
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function
name|void
name|syms_of_print
parameter_list|()
block|{
name|DEFVAR_LISP
argument_list|(
literal|"standard-output"
argument_list|,
operator|&
name|Vstandard_output
argument_list|,
literal|"Function print uses by default for outputting a character.\n\ This may be any function of one argument.\n\ It may also be a buffer (output is inserted before point)\n\ or a marker (output is inserted and the marker is advanced)\n\ or the symbol t (output appears in the minibuffer line)."
argument_list|)
expr_stmt|;
name|Vstandard_output
operator|=
name|Qt
expr_stmt|;
name|Qstandard_output
operator|=
name|intern
argument_list|(
literal|"standard-output"
argument_list|)
expr_stmt|;
name|staticpro
argument_list|(
operator|&
name|Qstandard_output
argument_list|)
expr_stmt|;
name|DEFVAR_LISP
argument_list|(
literal|"print-length"
argument_list|,
operator|&
name|Vprint_length
argument_list|,
literal|"Maximum length of list to print before abbreviating.\ `nil' means no limit."
argument_list|)
expr_stmt|;
name|Vprint_length
operator|=
name|Qnil
expr_stmt|;
name|DEFVAR_BOOL
argument_list|(
literal|"print-escape-newlines"
argument_list|,
operator|&
name|print_escape_newlines
argument_list|,
literal|"Non-nil means print newlines in strings as backslash-n."
argument_list|)
expr_stmt|;
name|print_escape_newlines
operator|=
literal|0
expr_stmt|;
comment|/* prin1_to_string_buffer initialized in init_buffer_once in buffer.c */
name|staticpro
argument_list|(
operator|&
name|Vprin1_to_string_buffer
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sprin1
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sprin1_to_string
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sprinc
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sprint
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sterpri
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Swrite_char
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|standalone
name|defsubr
argument_list|(
operator|&
name|Swith_output_to_temp_buffer
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* not standalone */
block|}
end_function

end_unit

