begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
name|char
name|rcsid
index|[]
init|=
literal|"$Id: dnslex.c,v 2.0 90/09/11 11:07:31 hakanson Rel $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* lint */
end_comment

begin_comment
comment|/*  * A lexical analyzer for DNS master files.  *   Marion Hakanson (hakanson@cse.ogi.edu)  *   Oregon Graduate Institute of Science and Technology  *  * Copyright (c) 1990, Marion Hakanson.  *  * You may distribute under the terms of the GNU General Public License  * as specified in the README file that comes with the dnsparse kit.  *  * This program accepts as input DNS master files, as described  * in RFC-1035.  It breaks up the input in such a way that a single  * resource record (RR) is output on a single line, with a delimiter  * character between each token (or field) of the RR.  *  * The output format was designed for consumption by programs such  * as awk or perl, so the delimiter character can be used to quickly  * split the RR into its components.  *  * It is likely that one could change the add_*char, end_word, and  * end_line macros to put chars into a separate buffer or perform  * some other function, and thus use do_dblex() inside a full parser  * program (such as a DNS server).  *  * One other thing.  This program could probably have been written  * in lex instead of C, but lex has a number of builtin limits to  * the length of expressions (where RFC-1035 does not, in all cases).  * I probably should have used flex instead, but the simple state  * machine below was not that tough to implement, and it's also  * pretty quick and pretty small.  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_define
define|#
directive|define
name|strchr
value|index
end_define

begin_comment
comment|/* system dependent */
end_comment

begin_define
define|#
directive|define
name|strrchr
value|index
end_define

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|strchr
argument_list|()
decl_stmt|,
modifier|*
name|strrchr
argument_list|()
decl_stmt|;
end_decl_stmt

begin_extern
extern|extern getopt(
end_extern

begin_operator
unit|)
operator|,
end_operator

begin_expr_stmt
name|optind
operator|,
name|opterr
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|optarg
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|FALSE
value|0
end_define

begin_define
define|#
directive|define
name|TRUE
value|1
end_define

begin_comment
comment|/* Globals */
end_comment

begin_decl_stmt
name|char
modifier|*
name|prog
decl_stmt|;
end_decl_stmt

begin_macro
name|usage_and_die
argument_list|()
end_macro

begin_block
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"usage: %s [-d<char>]\n"
argument_list|,
name|prog
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Special (to DNS) chars we output in printed (non-decimal-escaped) form */
end_comment

begin_define
define|#
directive|define
name|SPECS
value|" \t\n;()\\.@"
end_define

begin_comment
comment|/* for consumption by strchr() */
end_comment

begin_define
define|#
directive|define
name|SPECP
value|" \\t\\n;()\\.@"
end_define

begin_comment
comment|/* for consumption by fprintf() */
end_comment

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|int
name|opt
decl_stmt|;
comment|/* Defaults */
specifier|register
name|FILE
modifier|*
name|ifile
init|=
name|stdin
decl_stmt|,
modifier|*
name|ofile
init|=
name|stdout
decl_stmt|;
name|char
name|delim
init|=
literal|':'
decl_stmt|;
if|if
condition|(
name|prog
operator|=
name|strrchr
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|'/'
argument_list|)
condition|)
name|prog
operator|++
expr_stmt|;
else|else
name|prog
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
comment|/* Parse the arguments */
name|opterr
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|opt
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"d:"
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
switch|switch
condition|(
operator|(
name|char
operator|)
name|opt
condition|)
block|{
case|case
literal|'?'
case|:
name|usage_and_die
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|delim
operator|=
operator|*
name|optarg
expr_stmt|;
break|break;
default|default:
comment|/* Not supposed to happen. */
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: Hey getopt(3)!  Wake up!\n"
argument_list|,
name|prog
argument_list|)
expr_stmt|;
name|usage_and_die
argument_list|()
expr_stmt|;
break|break;
block|}
comment|/* This saves checking every char output against delim */
if|if
condition|(
name|strchr
argument_list|(
name|SPECS
argument_list|,
name|delim
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: delimiter '%c' cannot be one of '%s'.\n"
argument_list|,
name|prog
argument_list|,
name|delim
argument_list|,
name|SPECP
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|do_dblex
argument_list|(
name|ifile
argument_list|,
name|ofile
argument_list|,
name|delim
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|do_dblex
parameter_list|(
name|ifile
parameter_list|,
name|ofile
parameter_list|,
name|delim
parameter_list|)
specifier|register
name|FILE
modifier|*
name|ifile
decl_stmt|,
decl|*
name|ofile
decl_stmt|;
end_function

begin_decl_stmt
name|char
name|delim
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|c
decl_stmt|;
specifier|register
name|int
name|newword
init|=
name|FALSE
decl_stmt|;
specifier|register
name|int
name|wordlen
init|=
literal|0
decl_stmt|;
specifier|register
name|int
name|linelen
init|=
literal|0
decl_stmt|;
name|int
name|inbrackets
init|=
name|FALSE
decl_stmt|;
name|int
name|inquotes
init|=
name|FALSE
decl_stmt|;
comment|/* no delim after last word on a line */
define|#
directive|define
name|add_char
parameter_list|(
name|c
parameter_list|)
define|\
value|( \     (newword ? (newword = FALSE, putc(delim,ofile)) : 0), \     putc((c),ofile), \     wordlen++ \ )
comment|/* don't count the backslash, but do check for delim */
define|#
directive|define
name|add_esc_char
parameter_list|(
name|c
parameter_list|)
value|( add_char('\\'), putc((c),ofile) )
define|#
directive|define
name|add_dec_char
parameter_list|(
name|c
parameter_list|)
value|( add_char('\\'), fprintf(ofile,"%3.3d",(char)(c)) )
comment|/* ignore empty words except at beginning of a line */
define|#
directive|define
name|end_word
parameter_list|()
define|\
value|( \     (wordlen> 0 || linelen == 0) ? ( \ 	newword = TRUE, \ 	wordlen = 0, \ 	linelen++ \     ) : (0) \ )
comment|/* no delim at beginning of line; ignore empty lines */
define|#
directive|define
name|end_line
parameter_list|()
define|\
value|( \     (wordlen> 0) ? linelen++ : (0), \     newword = FALSE, \     wordlen = 0, \     (linelen> 0) ? ( \ 	putc('\n', ofile), \ 	linelen = 0 \     ) : (0) \ )
while|while
condition|(
operator|!
name|feof
argument_list|(
name|ifile
argument_list|)
condition|)
block|{
name|c
operator|=
name|getc
argument_list|(
name|ifile
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
name|EOF
case|:
break|break;
case|case
literal|' '
case|:
case|case
literal|'\t'
case|:
if|if
condition|(
name|inquotes
condition|)
name|add_esc_char
argument_list|(
name|c
argument_list|)
expr_stmt|;
else|else
block|{
name|end_word
argument_list|()
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|ifile
argument_list|)
operator|)
operator|!=
name|EOF
operator|&&
operator|(
name|c
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'\t'
operator|)
condition|)
empty_stmt|;
name|ungetc
argument_list|(
name|c
argument_list|,
name|ifile
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'\n'
case|:
if|if
condition|(
name|inquotes
condition|)
empty_stmt|;
comment|/* do nothing */
elseif|else
if|if
condition|(
name|inbrackets
condition|)
name|end_word
argument_list|()
expr_stmt|;
else|else
name|end_line
argument_list|()
expr_stmt|;
break|break;
case|case
literal|';'
case|:
if|if
condition|(
name|inquotes
condition|)
name|add_esc_char
argument_list|(
name|c
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|!
name|inbrackets
condition|)
name|end_line
argument_list|()
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|ifile
argument_list|)
operator|)
operator|!=
name|EOF
operator|&&
name|c
operator|!=
literal|'\n'
condition|)
empty_stmt|;
comment|/* skip */
block|}
break|break;
case|case
literal|'"'
case|:
if|if
condition|(
name|inquotes
condition|)
name|inquotes
operator|=
name|FALSE
expr_stmt|;
else|else
name|inquotes
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'('
case|:
if|if
condition|(
name|inbrackets
operator|||
name|inquotes
condition|)
name|add_esc_char
argument_list|(
name|c
argument_list|)
expr_stmt|;
else|else
block|{
name|inbrackets
operator|=
name|TRUE
expr_stmt|;
name|end_word
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
literal|')'
case|:
if|if
condition|(
name|inbrackets
operator|&&
operator|(
operator|!
name|inquotes
operator|)
condition|)
block|{
name|inbrackets
operator|=
name|FALSE
expr_stmt|;
name|end_word
argument_list|()
expr_stmt|;
block|}
else|else
name|add_esc_char
argument_list|(
name|c
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\\'
case|:
if|if
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|ifile
argument_list|)
operator|)
operator|==
name|EOF
condition|)
block|{
name|add_esc_char
argument_list|(
literal|'\\'
argument_list|)
expr_stmt|;
name|end_line
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
block|{
if|if
condition|(
operator|!
name|inquotes
condition|)
name|end_word
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
name|delim
condition|)
name|add_dec_char
argument_list|(
name|c
argument_list|)
expr_stmt|;
comment|/* no delims inside fields */
else|else
name|add_esc_char
argument_list|(
name|c
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'.'
case|:
case|case
literal|'@'
case|:
if|if
condition|(
name|inquotes
condition|)
name|add_esc_char
argument_list|(
name|c
argument_list|)
expr_stmt|;
else|else
name|add_char
argument_list|(
name|c
argument_list|)
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|c
operator|==
name|delim
condition|)
name|add_dec_char
argument_list|(
name|c
argument_list|)
expr_stmt|;
comment|/* no delims inside fields */
else|else
name|add_char
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_block

end_unit

