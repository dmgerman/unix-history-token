begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* rcsclean - clean up working files */
end_comment

begin_comment
comment|/* Copyright 1991 by Paul Eggert    Distributed under license by the Free Software Foundation, Inc.  This file is part of RCS.  RCS is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  RCS is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with RCS; see the file COPYING.  If not, write to the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  Report problems and direct all questions to:  	rcs-bugs@cs.purdue.edu  */
end_comment

begin_include
include|#
directive|include
file|"rcsbase.h"
end_include

begin_if
if|#
directive|if
name|has_dirent
end_if

begin_decl_stmt
specifier|static
name|int
name|get_directory
name|P
argument_list|(
operator|(
name|char
specifier|const
operator|*
operator|,
name|char
operator|*
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|int
name|unlock
name|P
argument_list|(
operator|(
expr|struct
name|hshentry
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|cleanup
name|P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|RILE
modifier|*
name|workptr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|exitstatus
decl_stmt|;
end_decl_stmt

begin_macro
name|mainProg
argument_list|(
argument|rcscleanId
argument_list|,
literal|"rcsclean"
argument_list|,
literal|"$Id: rcsclean.c,v 5.1 1991/11/03 01:11:44 eggert Exp $"
argument_list|)
end_macro

begin_block
block|{
specifier|static
name|char
specifier|const
name|usage
index|[]
init|=
literal|"\nrcsclean: usage: rcsclean [-ksubst] [-{nqru}[rev]] [-Vn] [-xsuffixes] [file ...]"
decl_stmt|;
specifier|static
name|struct
name|buf
name|revision
decl_stmt|;
name|char
modifier|*
name|a
decl_stmt|,
modifier|*
modifier|*
name|newargv
decl_stmt|;
name|char
specifier|const
modifier|*
name|rev
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|int
name|changelock
decl_stmt|,
name|expmode
decl_stmt|,
name|perform
decl_stmt|,
name|unlocked
decl_stmt|,
name|unlockflag
decl_stmt|,
name|waslocked
decl_stmt|;
name|struct
name|hshentries
modifier|*
name|deltas
decl_stmt|;
name|struct
name|hshentry
modifier|*
name|delta
decl_stmt|;
name|struct
name|stat
name|workstat
decl_stmt|;
name|setrid
argument_list|()
expr_stmt|;
name|expmode
operator|=
operator|-
literal|1
expr_stmt|;
name|rev
operator|=
name|nil
expr_stmt|;
name|suffixes
operator|=
name|X_DEFAULT
expr_stmt|;
name|perform
operator|=
name|true
expr_stmt|;
name|unlockflag
operator|=
name|false
expr_stmt|;
name|argc
operator|=
name|getRCSINIT
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
operator|&
name|newargv
argument_list|)
expr_stmt|;
name|argv
operator|=
name|newargv
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
operator|--
name|argc
operator|<=
literal|0
condition|)
block|{
if|#
directive|if
name|has_dirent
name|argc
operator|=
name|get_directory
argument_list|(
literal|"."
argument_list|,
operator|&
name|newargv
argument_list|)
expr_stmt|;
name|argv
operator|=
name|newargv
expr_stmt|;
break|break;
else|#
directive|else
name|faterror
argument_list|(
literal|"no file names specified"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|a
operator|=
operator|*
operator|++
name|argv
expr_stmt|;
if|if
condition|(
operator|*
name|a
operator|++
operator|!=
literal|'-'
condition|)
break|break;
switch|switch
condition|(
operator|*
name|a
operator|++
condition|)
block|{
case|case
literal|'k'
case|:
if|if
condition|(
literal|0
operator|<=
name|expmode
condition|)
name|redefined
argument_list|(
literal|'k'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|expmode
operator|=
name|str2expmode
argument_list|(
name|a
argument_list|)
operator|)
operator|<
literal|0
condition|)
goto|goto
name|unknown
goto|;
break|break;
case|case
literal|'n'
case|:
name|perform
operator|=
name|false
expr_stmt|;
goto|goto
name|handle_revision
goto|;
case|case
literal|'q'
case|:
name|quietflag
operator|=
name|true
expr_stmt|;
comment|/* fall into */
case|case
literal|'r'
case|:
name|handle_revision
label|:
if|if
condition|(
operator|*
name|a
condition|)
block|{
if|if
condition|(
name|rev
condition|)
name|warn
argument_list|(
literal|"redefinition of revision number"
argument_list|)
expr_stmt|;
name|rev
operator|=
name|a
expr_stmt|;
block|}
break|break;
case|case
literal|'u'
case|:
name|unlockflag
operator|=
name|true
expr_stmt|;
goto|goto
name|handle_revision
goto|;
case|case
literal|'V'
case|:
name|setRCSversion
argument_list|(
operator|*
name|argv
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
name|suffixes
operator|=
name|a
expr_stmt|;
break|break;
default|default:
name|unknown
label|:
name|faterror
argument_list|(
literal|"unknown option: %s%s"
argument_list|,
operator|*
name|argv
argument_list|,
name|usage
argument_list|)
expr_stmt|;
block|}
block|}
do|do
block|{
name|ffree
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
operator|(
literal|0
operator|<
name|pairfilenames
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|unlockflag
operator|&
name|perform
condition|?
name|rcswriteopen
else|:
name|rcsreadopen
argument_list|,
name|true
argument_list|,
name|true
argument_list|)
operator|&&
operator|(
name|workptr
operator|=
name|Iopen
argument_list|(
name|workfilename
argument_list|,
name|FOPEN_R_WORK
argument_list|,
operator|&
name|workstat
argument_list|)
operator|)
operator|)
condition|)
continue|continue;
name|gettree
argument_list|()
expr_stmt|;
name|p
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|rev
condition|)
block|{
if|if
condition|(
operator|!
name|fexpandsym
argument_list|(
name|rev
argument_list|,
operator|&
name|revision
argument_list|,
name|workptr
argument_list|)
condition|)
continue|continue;
name|p
operator|=
name|revision
operator|.
name|string
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|Head
condition|)
switch|switch
condition|(
name|unlockflag
condition|?
name|findlock
argument_list|(
name|false
argument_list|,
operator|&
name|delta
argument_list|)
else|:
literal|0
condition|)
block|{
default|default:
continue|continue;
case|case
literal|0
case|:
name|p
operator|=
name|Dbranch
condition|?
name|Dbranch
else|:
literal|""
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|p
operator|=
name|delta
operator|->
name|num
expr_stmt|;
break|break;
block|}
name|delta
operator|=
literal|0
expr_stmt|;
name|deltas
operator|=
literal|0
expr_stmt|;
comment|/* Keep lint happy.  */
if|if
condition|(
name|p
operator|&&
operator|!
operator|(
name|delta
operator|=
name|genrevs
argument_list|(
name|p
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
operator|&
name|deltas
argument_list|)
operator|)
condition|)
continue|continue;
name|waslocked
operator|=
name|delta
operator|&&
name|delta
operator|->
name|lockedby
expr_stmt|;
name|locker_expansion
operator|=
name|unlock
argument_list|(
name|delta
argument_list|)
expr_stmt|;
name|unlocked
operator|=
name|locker_expansion
operator|&
name|unlockflag
expr_stmt|;
name|changelock
operator|=
name|unlocked
operator|&
name|perform
expr_stmt|;
if|if
condition|(
name|unlocked
operator|<
name|waslocked
operator|&&
name|workstat
operator|.
name|st_mode
operator|&
operator|(
name|S_IWUSR
operator||
name|S_IWGRP
operator||
name|S_IWOTH
operator|)
condition|)
continue|continue;
if|if
condition|(
operator|!
name|dorewrite
argument_list|(
name|unlockflag
argument_list|,
name|changelock
argument_list|)
condition|)
continue|continue;
if|if
condition|(
literal|0
operator|<=
name|expmode
condition|)
name|Expand
operator|=
name|expmode
expr_stmt|;
elseif|else
if|if
condition|(
name|waslocked
operator|&&
name|Expand
operator|==
name|KEYVAL_EXPAND
operator|&&
name|WORKMODE
argument_list|(
name|RCSstat
operator|.
name|st_mode
argument_list|,
name|true
argument_list|)
operator|==
name|workstat
operator|.
name|st_mode
condition|)
name|Expand
operator|=
name|KEYVALLOCK_EXPAND
expr_stmt|;
name|getdesc
argument_list|(
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|delta
condition|?
name|workstat
operator|.
name|st_size
operator|!=
literal|0
else|:
literal|0
operator|<
name|rcsfcmp
argument_list|(
name|workptr
argument_list|,
operator|&
name|workstat
argument_list|,
name|buildrevision
argument_list|(
name|deltas
argument_list|,
name|delta
argument_list|,
operator|(
name|FILE
operator|*
operator|)
literal|0
argument_list|,
name|false
argument_list|)
argument_list|,
name|delta
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|quietflag
operator|<
name|unlocked
condition|)
name|aprintf
argument_list|(
name|stdout
argument_list|,
literal|"rcs -u%s %s\n"
argument_list|,
name|delta
operator|->
name|num
argument_list|,
name|RCSfilename
argument_list|)
expr_stmt|;
name|if_advise_access
argument_list|(
name|changelock
operator|&&
name|deltas
operator|->
name|first
operator|!=
name|delta
argument_list|,
name|finptr
argument_list|,
name|MADV_SEQUENTIAL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|donerewrite
argument_list|(
name|changelock
argument_list|)
condition|)
continue|continue;
if|if
condition|(
operator|!
name|quietflag
condition|)
name|aprintf
argument_list|(
name|stdout
argument_list|,
literal|"rm -f %s\n"
argument_list|,
name|workfilename
argument_list|)
expr_stmt|;
name|Izclose
argument_list|(
operator|&
name|workptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|perform
operator|&&
name|un_link
argument_list|(
name|workfilename
argument_list|)
operator|!=
literal|0
condition|)
name|eerror
argument_list|(
name|workfilename
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|cleanup
argument_list|()
operator|,
operator|++
name|argv
operator|,
literal|0
operator|<
operator|--
name|argc
condition|)
do|;
name|tempunlink
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|quietflag
condition|)
name|Ofclose
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|exitmain
argument_list|(
name|exitstatus
argument_list|)
expr_stmt|;
block|}
end_block

begin_function
specifier|static
name|void
name|cleanup
parameter_list|()
block|{
if|if
condition|(
name|nerror
condition|)
name|exitstatus
operator|=
name|EXIT_FAILURE
expr_stmt|;
name|Izclose
argument_list|(
operator|&
name|finptr
argument_list|)
expr_stmt|;
name|Izclose
argument_list|(
operator|&
name|workptr
argument_list|)
expr_stmt|;
name|Ozclose
argument_list|(
operator|&
name|fcopy
argument_list|)
expr_stmt|;
name|Ozclose
argument_list|(
operator|&
name|frewrite
argument_list|)
expr_stmt|;
name|dirtempunlink
argument_list|()
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
name|lint
end_if

begin_define
define|#
directive|define
name|exiterr
value|rcscleanExit
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|exiting
name|void
name|exiterr
parameter_list|()
block|{
name|dirtempunlink
argument_list|()
expr_stmt|;
name|tempunlink
argument_list|()
expr_stmt|;
name|_exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|unlock
parameter_list|(
name|delta
parameter_list|)
name|struct
name|hshentry
modifier|*
name|delta
decl_stmt|;
block|{
specifier|register
name|struct
name|lock
modifier|*
modifier|*
name|al
decl_stmt|,
modifier|*
name|l
decl_stmt|;
if|if
condition|(
name|delta
operator|&&
name|delta
operator|->
name|lockedby
operator|&&
name|strcmp
argument_list|(
name|getcaller
argument_list|()
argument_list|,
name|delta
operator|->
name|lockedby
argument_list|)
operator|==
literal|0
condition|)
for|for
control|(
name|al
operator|=
operator|&
name|Locks
init|;
operator|(
name|l
operator|=
operator|*
name|al
operator|)
condition|;
name|al
operator|=
operator|&
name|l
operator|->
name|nextlock
control|)
if|if
condition|(
name|l
operator|->
name|delta
operator|==
name|delta
condition|)
block|{
operator|*
name|al
operator|=
name|l
operator|->
name|nextlock
expr_stmt|;
name|delta
operator|->
name|lockedby
operator|=
literal|0
expr_stmt|;
return|return
name|true
return|;
block|}
return|return
name|false
return|;
block|}
end_function

begin_if
if|#
directive|if
name|has_dirent
end_if

begin_function
specifier|static
name|int
name|get_directory
parameter_list|(
name|dirname
parameter_list|,
name|aargv
parameter_list|)
name|char
specifier|const
modifier|*
name|dirname
decl_stmt|;
name|char
modifier|*
modifier|*
modifier|*
name|aargv
decl_stmt|;
comment|/*  * Put a vector of all DIRNAME's directory entries names into *AARGV.  * Ignore names of RCS files.  * Yield the number of entries found.  Terminate the vector with 0.  * Allocate the storage for the vector and entry names.  * Do not sort the names.  Do not include '.' and '..'.  */
block|{
name|int
name|i
decl_stmt|,
name|entries
init|=
literal|0
decl_stmt|,
name|entries_max
init|=
literal|64
decl_stmt|;
name|size_t
name|chars
init|=
literal|0
decl_stmt|,
name|chars_max
init|=
literal|1024
decl_stmt|;
name|size_t
modifier|*
name|offset
init|=
name|tnalloc
argument_list|(
name|size_t
argument_list|,
name|entries_max
argument_list|)
decl_stmt|;
name|char
modifier|*
name|a
init|=
name|tnalloc
argument_list|(
name|char
argument_list|,
name|chars_max
argument_list|)
decl_stmt|,
modifier|*
modifier|*
name|p
decl_stmt|;
name|DIR
modifier|*
name|d
decl_stmt|;
name|struct
name|dirent
modifier|*
name|e
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|d
operator|=
name|opendir
argument_list|(
name|dirname
argument_list|)
operator|)
condition|)
name|efaterror
argument_list|(
name|dirname
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|errno
operator|=
literal|0
operator|,
name|e
operator|=
name|readdir
argument_list|(
name|d
argument_list|)
operator|)
condition|)
block|{
name|char
specifier|const
modifier|*
name|en
init|=
name|e
operator|->
name|d_name
decl_stmt|;
name|size_t
name|s
init|=
name|strlen
argument_list|(
name|en
argument_list|)
operator|+
literal|1
decl_stmt|;
if|if
condition|(
name|en
index|[
literal|0
index|]
operator|==
literal|'.'
operator|&&
operator|(
operator|!
name|en
index|[
literal|1
index|]
operator|||
name|en
index|[
literal|1
index|]
operator|==
literal|'.'
operator|&&
operator|!
name|en
index|[
literal|2
index|]
operator|)
condition|)
continue|continue;
if|if
condition|(
name|rcssuffix
argument_list|(
name|en
argument_list|)
condition|)
continue|continue;
while|while
condition|(
name|chars_max
operator|<
name|s
operator|+
name|chars
condition|)
name|a
operator|=
name|trealloc
argument_list|(
name|char
argument_list|,
name|a
argument_list|,
name|chars_max
operator|<<=
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|entries
operator|==
name|entries_max
condition|)
name|offset
operator|=
name|trealloc
argument_list|(
name|size_t
argument_list|,
name|offset
argument_list|,
name|entries_max
operator|<<=
literal|1
argument_list|)
expr_stmt|;
name|offset
index|[
name|entries
operator|++
index|]
operator|=
name|chars
expr_stmt|;
name|VOID
name|strcpy
argument_list|(
name|a
operator|+
name|chars
argument_list|,
name|en
argument_list|)
decl_stmt|;
name|chars
operator|+=
name|s
expr_stmt|;
block|}
if|if
condition|(
name|errno
operator|||
name|closedir
argument_list|(
name|d
argument_list|)
operator|!=
literal|0
condition|)
name|efaterror
argument_list|(
name|dirname
argument_list|)
expr_stmt|;
if|if
condition|(
name|chars
condition|)
name|a
operator|=
name|trealloc
argument_list|(
name|char
argument_list|,
name|a
argument_list|,
name|chars
argument_list|)
expr_stmt|;
else|else
name|tfree
argument_list|(
name|a
argument_list|)
expr_stmt|;
operator|*
name|aargv
operator|=
name|p
operator|=
name|tnalloc
argument_list|(
name|char
operator|*
argument_list|,
name|entries
operator|+
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|entries
condition|;
name|i
operator|++
control|)
operator|*
name|p
operator|++
operator|=
name|a
operator|+
name|offset
index|[
name|i
index|]
expr_stmt|;
operator|*
name|p
operator|=
literal|0
expr_stmt|;
name|tfree
argument_list|(
name|offset
argument_list|)
expr_stmt|;
return|return
name|entries
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

