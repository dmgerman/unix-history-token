begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1980, 1993  *	The Regents of the University of California.  All rights reserved.  *  * This module is believed to contain source code proprietary to AT&T.  * Use and redistribution is subject to the Berkeley Software License  * Agreement and your Software Agreement with AT&T (Western Electric).  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)ex_vput.c	8.1 (Berkeley) 6/9/93"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_include
include|#
directive|include
file|"ex.h"
end_include

begin_include
include|#
directive|include
file|"ex_tty.h"
end_include

begin_include
include|#
directive|include
file|"ex_vis.h"
end_include

begin_comment
comment|/*  * Deal with the screen, clearing, cursor positioning, putting characters  * into the screen image, and deleting characters.  * Really hard stuff here is utilizing insert character operations  * on intelligent terminals which differs widely from terminal to terminal.  */
end_comment

begin_macro
name|vclear
argument_list|()
end_macro

begin_block
block|{
ifdef|#
directive|ifdef
name|ADEBUG
if|if
condition|(
name|trace
condition|)
name|tfixnl
argument_list|()
operator|,
name|fprintf
argument_list|(
name|trace
argument_list|,
literal|"------\nvclear\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|tputs
argument_list|(
name|CL
argument_list|,
name|LINES
argument_list|,
name|putch
argument_list|)
expr_stmt|;
name|destcol
operator|=
literal|0
expr_stmt|;
name|outcol
operator|=
literal|0
expr_stmt|;
name|destline
operator|=
literal|0
expr_stmt|;
name|outline
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|inopen
condition|)
name|vclrbyte
argument_list|(
name|vtube0
argument_list|,
name|WCOLS
operator|*
operator|(
name|WECHO
operator|-
name|ex_ZERO
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Clear memory.  */
end_comment

begin_expr_stmt
name|vclrbyte
argument_list|(
name|cp
argument_list|,
name|i
argument_list|)
specifier|register
name|char
operator|*
name|cp
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|int
name|i
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|i
operator|>
literal|0
condition|)
do|do
operator|*
name|cp
operator|++
operator|=
literal|0
expr_stmt|;
do|while
condition|(
operator|--
name|i
operator|!=
literal|0
condition|)
do|;
block|}
end_block

begin_comment
comment|/*  * Clear a physical display line, high level.  */
end_comment

begin_macro
name|vclrlin
argument_list|(
argument|l
argument_list|,
argument|tp
argument_list|)
end_macro

begin_decl_stmt
name|int
name|l
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|line
modifier|*
name|tp
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|vigoto
argument_list|(
name|l
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|hold
operator|&
name|HOLDAT
operator|)
operator|==
literal|0
condition|)
name|ex_putchar
argument_list|(
name|tp
operator|>
name|dol
condition|?
operator|(
operator|(
name|UPPERCASE
operator|||
name|HZ
operator|)
condition|?
literal|'^'
else|:
literal|'~'
operator|)
else|:
literal|'@'
argument_list|)
expr_stmt|;
if|if
condition|(
name|state
operator|==
name|HARDOPEN
condition|)
name|sethard
argument_list|()
expr_stmt|;
name|vclreol
argument_list|()
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Clear to the end of the current physical line  */
end_comment

begin_macro
name|vclreol
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
specifier|register
name|char
modifier|*
name|tp
decl_stmt|;
if|if
condition|(
name|destcol
operator|==
name|WCOLS
condition|)
return|return;
name|destline
operator|+=
name|destcol
operator|/
name|WCOLS
expr_stmt|;
name|destcol
operator|%=
name|WCOLS
expr_stmt|;
if|if
condition|(
name|destline
operator|<
literal|0
operator|||
name|destline
operator|>
name|WECHO
condition|)
name|error
argument_list|(
literal|"Internal error: vclreol"
argument_list|)
expr_stmt|;
name|i
operator|=
name|WCOLS
operator|-
name|destcol
expr_stmt|;
name|tp
operator|=
name|vtube
index|[
name|destline
index|]
operator|+
name|destcol
expr_stmt|;
if|if
condition|(
name|CE
condition|)
block|{
if|if
condition|(
name|IN
operator|&&
operator|*
name|tp
operator|||
operator|!
name|ateopr
argument_list|()
condition|)
block|{
name|vcsync
argument_list|()
expr_stmt|;
name|vputp
argument_list|(
name|CE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|vclrbyte
argument_list|(
name|tp
argument_list|,
name|i
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|*
name|tp
operator|==
literal|0
condition|)
return|return;
while|while
condition|(
name|i
operator|>
literal|0
operator|&&
operator|(
name|j
operator|=
operator|*
name|tp
operator|&
operator|(
name|QUOTE
operator||
name|TRIM
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|j
operator|!=
literal|' '
operator|&&
operator|(
name|j
operator|&
name|QUOTE
operator|)
operator|==
literal|0
condition|)
block|{
name|destcol
operator|=
name|WCOLS
operator|-
name|i
expr_stmt|;
name|vputchar
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
block|}
operator|--
name|i
operator|,
operator|*
name|tp
operator|++
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  * Clear the echo line.  * If didphys then its been cleared physically (as  * a side effect of a clear to end of display, e.g.)  * so just do it logically.  * If work here is being held off, just remember, in  * heldech, if work needs to be done, don't do anything.  */
end_comment

begin_macro
name|vclrech
argument_list|(
argument|didphys
argument_list|)
end_macro

begin_decl_stmt
name|bool
name|didphys
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|Peek_key
operator|==
name|ATTN
condition|)
return|return;
if|if
condition|(
name|hold
operator|&
name|HOLDECH
condition|)
block|{
name|heldech
operator|=
operator|!
name|didphys
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|didphys
operator|&&
operator|(
name|CD
operator|||
name|CE
operator|)
condition|)
block|{
name|splitw
operator|++
expr_stmt|;
comment|/* 		 * If display is retained below, then MUST use CD or CE 		 * since we don't really know whats out there. 		 * Vigoto might decide (incorrectly) to do nothing. 		 */
if|if
condition|(
name|DB
condition|)
block|{
name|vgoto
argument_list|(
name|WECHO
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|vputp
argument_list|(
name|CD
condition|?
name|CD
else|:
name|CE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|XT
condition|)
block|{
comment|/* 				 * This code basically handles the t1061 				 * where positioning at (0, 0) won't work 				 * because the terminal won't let you put 				 * the cursor on it's magic cookie. 				 * 				 * Should probably be XS above, or even a 				 * new X? glitch, but right now t1061 is the 				 * only terminal with XT. 				 */
name|vgoto
argument_list|(
name|WECHO
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|vputp
argument_list|(
name|DL
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|vigoto
argument_list|(
name|WECHO
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|vclreol
argument_list|()
expr_stmt|;
block|}
block|}
name|splitw
operator|=
literal|0
expr_stmt|;
name|didphys
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|didphys
condition|)
name|vclrbyte
argument_list|(
name|vtube
index|[
name|WECHO
index|]
argument_list|,
name|WCOLS
argument_list|)
expr_stmt|;
name|heldech
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Fix the echo area for use, setting  * the state variable splitw so we wont rollup  * when we move the cursor there.  */
end_comment

begin_macro
name|fixech
argument_list|()
end_macro

begin_block
block|{
name|splitw
operator|++
expr_stmt|;
if|if
condition|(
name|state
operator|!=
name|VISUAL
operator|&&
name|state
operator|!=
name|CRTOPEN
condition|)
block|{
name|vclean
argument_list|()
expr_stmt|;
name|vcnt
operator|=
literal|0
expr_stmt|;
block|}
name|vgoto
argument_list|(
name|WECHO
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|flusho
argument_list|()
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Put the cursor ``before'' cp.  */
end_comment

begin_expr_stmt
name|vcursbef
argument_list|(
name|cp
argument_list|)
specifier|register
name|char
operator|*
name|cp
expr_stmt|;
end_expr_stmt

begin_block
block|{
if|if
condition|(
name|cp
operator|<=
name|linebuf
condition|)
name|vgotoCL
argument_list|(
name|value
argument_list|(
name|NUMBER
argument_list|)
operator|<<
literal|3
argument_list|)
expr_stmt|;
else|else
name|vgotoCL
argument_list|(
name|column
argument_list|(
name|cp
operator|-
literal|1
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Put the cursor ``at'' cp.  */
end_comment

begin_expr_stmt
name|vcursat
argument_list|(
name|cp
argument_list|)
specifier|register
name|char
operator|*
name|cp
expr_stmt|;
end_expr_stmt

begin_block
block|{
if|if
condition|(
name|cp
operator|<=
name|linebuf
operator|&&
name|linebuf
index|[
literal|0
index|]
operator|==
literal|0
condition|)
name|vgotoCL
argument_list|(
name|value
argument_list|(
name|NUMBER
argument_list|)
operator|<<
literal|3
argument_list|)
expr_stmt|;
else|else
name|vgotoCL
argument_list|(
name|column
argument_list|(
name|cp
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Put the cursor ``after'' cp.  */
end_comment

begin_expr_stmt
name|vcursaft
argument_list|(
name|cp
argument_list|)
specifier|register
name|char
operator|*
name|cp
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|vgotoCL
argument_list|(
name|column
argument_list|(
name|cp
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Fix the cursor to be positioned in the correct place  * to accept a command.  */
end_comment

begin_macro
name|vfixcurs
argument_list|()
end_macro

begin_block
block|{
name|vsetcurs
argument_list|(
name|cursor
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Compute the column position implied by the cursor at ``nc'',  * and move the cursor there.  */
end_comment

begin_expr_stmt
name|vsetcurs
argument_list|(
name|nc
argument_list|)
specifier|register
name|char
operator|*
name|nc
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|col
decl_stmt|;
name|col
operator|=
name|column
argument_list|(
name|nc
argument_list|)
expr_stmt|;
if|if
condition|(
name|linebuf
index|[
literal|0
index|]
condition|)
name|col
operator|--
expr_stmt|;
name|vgotoCL
argument_list|(
name|col
argument_list|)
expr_stmt|;
name|cursor
operator|=
name|nc
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Move the cursor invisibly, i.e. only remember to do it.  */
end_comment

begin_macro
name|vigoto
argument_list|(
argument|y
argument_list|,
argument|x
argument_list|)
end_macro

begin_decl_stmt
name|int
name|y
decl_stmt|,
name|x
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|destline
operator|=
name|y
expr_stmt|;
name|destcol
operator|=
name|x
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Move the cursor to the position implied by any previous  * vigoto (or low level hacking with destcol/destline as in readecho).  */
end_comment

begin_macro
name|vcsync
argument_list|()
end_macro

begin_block
block|{
name|vgoto
argument_list|(
name|destline
argument_list|,
name|destcol
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Goto column x of the current line.  */
end_comment

begin_expr_stmt
name|vgotoCL
argument_list|(
name|x
argument_list|)
specifier|register
name|int
name|x
expr_stmt|;
end_expr_stmt

begin_block
block|{
if|if
condition|(
name|splitw
condition|)
name|vgoto
argument_list|(
name|WECHO
argument_list|,
name|x
argument_list|)
expr_stmt|;
else|else
name|vgoto
argument_list|(
name|LINE
argument_list|(
name|vcline
argument_list|)
argument_list|,
name|x
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Invisible goto column x of current line.  */
end_comment

begin_expr_stmt
name|vigotoCL
argument_list|(
name|x
argument_list|)
specifier|register
name|int
name|x
expr_stmt|;
end_expr_stmt

begin_block
block|{
if|if
condition|(
name|splitw
condition|)
name|vigoto
argument_list|(
name|WECHO
argument_list|,
name|x
argument_list|)
expr_stmt|;
else|else
name|vigoto
argument_list|(
name|LINE
argument_list|(
name|vcline
argument_list|)
argument_list|,
name|x
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Move cursor to line y, column x, handling wraparound and scrolling.  */
end_comment

begin_expr_stmt
name|vgoto
argument_list|(
name|y
argument_list|,
name|x
argument_list|)
specifier|register
name|int
name|y
operator|,
name|x
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|tp
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
comment|/* 	 * Fold the possibly too large value of x. 	 */
if|if
condition|(
name|x
operator|>=
name|WCOLS
condition|)
block|{
name|y
operator|+=
name|x
operator|/
name|WCOLS
expr_stmt|;
name|x
operator|%=
name|WCOLS
expr_stmt|;
block|}
if|if
condition|(
name|y
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|"Internal error: vgoto"
argument_list|)
expr_stmt|;
if|if
condition|(
name|outcol
operator|>=
name|WCOLS
condition|)
block|{
if|if
condition|(
name|AM
condition|)
block|{
name|outline
operator|+=
name|outcol
operator|/
name|WCOLS
expr_stmt|;
name|outcol
operator|%=
name|WCOLS
expr_stmt|;
block|}
else|else
name|outcol
operator|=
name|WCOLS
operator|-
literal|1
expr_stmt|;
block|}
comment|/* 	 * In a hardcopy or glass crt open, print the stuff 	 * implied by a motion, or backspace. 	 */
if|if
condition|(
name|state
operator|==
name|HARDOPEN
operator|||
name|state
operator|==
name|ONEOPEN
condition|)
block|{
if|if
condition|(
name|y
operator|!=
name|outline
condition|)
name|error
argument_list|(
literal|"Line too long for open"
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|+
literal|1
operator|<
name|outcol
operator|-
name|x
operator|||
operator|(
name|outcol
operator|>
name|x
operator|&&
operator|!
name|BS
operator|)
condition|)
name|destcol
operator|=
literal|0
operator|,
name|fgoto
argument_list|()
expr_stmt|;
name|tp
operator|=
name|vtube
index|[
name|WBOT
index|]
operator|+
name|outcol
expr_stmt|;
while|while
condition|(
name|outcol
operator|!=
name|x
condition|)
if|if
condition|(
name|outcol
operator|<
name|x
condition|)
block|{
if|if
condition|(
operator|*
name|tp
operator|==
literal|0
condition|)
operator|*
name|tp
operator|=
literal|' '
expr_stmt|;
name|c
operator|=
operator|*
name|tp
operator|++
operator|&
name|TRIM
expr_stmt|;
name|vputc
argument_list|(
name|c
operator|&&
operator|(
operator|!
name|OS
operator|||
name|EO
operator|)
condition|?
name|c
else|:
literal|' '
argument_list|)
operator|,
name|outcol
operator|++
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|BC
condition|)
name|vputp
argument_list|(
name|BC
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|vputc
argument_list|(
literal|'\b'
argument_list|)
expr_stmt|;
name|outcol
operator|--
expr_stmt|;
block|}
name|destcol
operator|=
name|outcol
operator|=
name|x
expr_stmt|;
name|destline
operator|=
name|outline
expr_stmt|;
return|return;
block|}
comment|/* 	 * If the destination position implies a scroll, do it. 	 */
name|destline
operator|=
name|y
expr_stmt|;
if|if
condition|(
name|destline
operator|>
name|WBOT
operator|&&
operator|(
operator|!
name|splitw
operator|||
name|destline
operator|>
name|WECHO
operator|)
condition|)
block|{
name|endim
argument_list|()
expr_stmt|;
name|vrollup
argument_list|(
name|destline
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * If there really is a motion involved, do it. 	 * The check here is an optimization based on profiling. 	 */
name|destcol
operator|=
name|x
expr_stmt|;
if|if
condition|(
operator|(
name|destline
operator|-
name|outline
operator|)
operator|*
name|WCOLS
operator|!=
name|destcol
operator|-
name|outcol
condition|)
block|{
if|if
condition|(
operator|!
name|MI
condition|)
name|endim
argument_list|()
expr_stmt|;
name|fgoto
argument_list|()
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  * This is the hardest code in the editor, and deals with insert modes  * on different kinds of intelligent terminals.  The complexity is due  * to the cross product of three factors:  *  *	1. Lines may display as more than one segment on the screen.  *	2. There are 2 kinds of intelligent terminal insert modes.  *	3. Tabs squash when you insert characters in front of them,  *	   in a way in which current intelligent terminals don't handle.  *  * The two kinds of terminals are typified by the DM2500 or HP2645 for  * one and the CONCEPT-100 or the FOX for the other.  *  * The first (HP2645) kind has an insert mode where the characters  * fall off the end of the line and the screen is shifted rigidly  * no matter how the display came about.  *  * The second (CONCEPT-100) kind comes from terminals which are designed  * for forms editing and which distinguish between blanks and ``spaces''  * on the screen, spaces being like blank, but never having had  * and data typed into that screen position (since, e.g. a clear operation  * like clear screen).  On these terminals, when you insert a character,  * the characters from where you are to the end of the screen shift  * over till a ``space'' is found, and the null character there gets  * eaten up.  *  *  * The code here considers the line as consisting of several parts  * the first part is the ``doomed'' part, i.e. a part of the line  * which is being typed over.  Next comes some text up to the first  * following tab.  The tab is the next segment of the line, and finally  * text after the tab.  *  * We have to consider each of these segments and the effect of the  * insertion of a character on them.  On terminals like HP2645's we  * must simulate a multi-line insert mode using the primitive one  * line insert mode.  If we are inserting in front of a tab, we have  * to either delete characters from the tab or insert white space  * (when the tab reaches a new spot where it gets larger) before we  * insert the new character.  *  * On a terminal like a CONCEPT our strategy is to make all  * blanks be displayed, while trying to keep the screen having ``spaces''  * for portions of tabs.  In this way the terminal hardward does some  * of the hacking for compression of tabs, although this tends to  * disappear as you work on the line and spaces change into blanks.  *  * There are a number of boundary conditions (like typing just before  * the first following tab) where we can avoid a lot of work.  Most  * of them have to be dealt with explicitly because performance is  * much, much worse if we don't.  *  * A final thing which is hacked here is two flavors of insert mode.  * Datamedia's do this by an insert mode which you enter and leave  * and by having normal motion character operate differently in this  * mode, notably by having a newline insert a line on the screen in  * this mode.  This generally means it is unsafe to move around  * the screen ignoring the fact that we are in this mode.  * This is possible on some terminals, and wins big (e.g. HP), so  * we encode this as a ``can move in insert capability'' mi,  * and terminals which have it can do insert mode with much less  * work when tabs are present following the cursor on the current line.  */
end_comment

begin_comment
comment|/*  * Routine to expand a tab, calling the normal Outchar routine  * to put out each implied character.  Note that we call outchar  * with a QUOTE.  We use QUOTE internally to represent a position  * which is part of the expansion of a tab.  */
end_comment

begin_macro
name|vgotab
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|i
init|=
name|tabcol
argument_list|(
name|destcol
argument_list|,
name|value
argument_list|(
name|TABSTOP
argument_list|)
argument_list|)
operator|-
name|destcol
decl_stmt|;
do|do
call|(
modifier|*
name|Outchar
call|)
argument_list|(
name|QUOTE
argument_list|)
expr_stmt|;
do|while
condition|(
operator|--
name|i
condition|)
do|;
block|}
end_block

begin_comment
comment|/*  * Variables for insert mode.  */
end_comment

begin_decl_stmt
name|int
name|linend
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The column position of end of line */
end_comment

begin_decl_stmt
name|int
name|tabstart
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Column of start of first following tab */
end_comment

begin_decl_stmt
name|int
name|tabend
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Column of end of following tabs */
end_comment

begin_decl_stmt
name|int
name|tabsize
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Size of the following tabs */
end_comment

begin_decl_stmt
name|int
name|tabslack
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of ``spaces'' in following tabs */
end_comment

begin_decl_stmt
name|int
name|inssiz
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of characters to be inserted */
end_comment

begin_decl_stmt
name|int
name|inscol
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Column where insertion is taking place */
end_comment

begin_decl_stmt
name|int
name|shft
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Amount tab expansion shifted rest of line */
end_comment

begin_decl_stmt
name|int
name|slakused
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This much of tabslack will be used up */
end_comment

begin_comment
comment|/*  * This routine MUST be called before insert mode is run,  * and brings all segments of the current line to the top  * of the screen image buffer so it is easier for us to  * maniuplate them.  */
end_comment

begin_macro
name|vprepins
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|char
modifier|*
name|cp
init|=
name|vtube0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|DEPTH
argument_list|(
name|vcline
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|vmaktop
argument_list|(
name|LINE
argument_list|(
name|vcline
argument_list|)
operator|+
name|i
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|WCOLS
expr_stmt|;
block|}
block|}
end_block

begin_expr_stmt
name|vmaktop
argument_list|(
name|p
argument_list|,
name|cp
argument_list|)
specifier|register
name|int
name|p
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|char
modifier|*
name|cp
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|char
name|temp
index|[
name|TUBECOLS
index|]
decl_stmt|;
if|if
condition|(
name|p
operator|<
literal|0
operator|||
name|vtube
index|[
name|p
index|]
operator|==
name|cp
condition|)
return|return;
for|for
control|(
name|i
operator|=
name|ex_ZERO
init|;
name|i
operator|<=
name|WECHO
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|vtube
index|[
name|i
index|]
operator|==
name|cp
condition|)
block|{
name|copy
argument_list|(
name|temp
argument_list|,
name|vtube
index|[
name|i
index|]
argument_list|,
name|WCOLS
argument_list|)
expr_stmt|;
name|copy
argument_list|(
name|vtube
index|[
name|i
index|]
argument_list|,
name|vtube
index|[
name|p
index|]
argument_list|,
name|WCOLS
argument_list|)
expr_stmt|;
name|copy
argument_list|(
name|vtube
index|[
name|p
index|]
argument_list|,
name|temp
argument_list|,
name|WCOLS
argument_list|)
expr_stmt|;
name|vtube
index|[
name|i
index|]
operator|=
name|vtube
index|[
name|p
index|]
expr_stmt|;
name|vtube
index|[
name|p
index|]
operator|=
name|cp
expr_stmt|;
return|return;
block|}
name|error
argument_list|(
literal|"Line too long"
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Insert character c at current cursor position.  * Multi-character inserts occur only as a result  * of expansion of tabs (i.e. inssize == 1 except  * for tabs) and code assumes this in several place  * to make life simpler.  */
end_comment

begin_macro
name|vinschar
argument_list|(
argument|c
argument_list|)
end_macro

begin_decl_stmt
name|int
name|c
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* mjm: char --> int */
end_comment

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|char
modifier|*
name|tp
decl_stmt|;
if|if
condition|(
operator|(
operator|!
name|IM
operator|||
operator|!
name|EI
operator|)
operator|&&
operator|(
operator|(
name|hold
operator|&
name|HOLDQIK
operator|)
operator|||
operator|!
name|value
argument_list|(
name|REDRAW
argument_list|)
operator|||
name|value
argument_list|(
name|SLOWOPEN
argument_list|)
operator|)
condition|)
block|{
comment|/* 		 * Don't want to try to use terminal 		 * insert mode, or to try to fake it. 		 * Just put the character out; the screen 		 * will probably be wrong but we will fix it later. 		 */
if|if
condition|(
name|c
operator|==
literal|'\t'
condition|)
block|{
name|vgotab
argument_list|()
expr_stmt|;
return|return;
block|}
name|vputchar
argument_list|(
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|DEPTH
argument_list|(
name|vcline
argument_list|)
operator|*
name|WCOLS
operator|+
operator|!
name|value
argument_list|(
name|REDRAW
argument_list|)
operator|>
operator|(
name|destline
operator|-
name|LINE
argument_list|(
name|vcline
argument_list|)
operator|)
operator|*
name|WCOLS
operator|+
name|destcol
condition|)
return|return;
comment|/* 		 * The next line is about to be clobbered 		 * make space for another segment of this line 		 * (on an intelligent terminal) or just remember 		 * that next line was clobbered (on a dumb one 		 * if we don't care to redraw the tail. 		 */
if|if
condition|(
name|AL
condition|)
block|{
name|vnpins
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|c
operator|=
name|LINE
argument_list|(
name|vcline
argument_list|)
operator|+
name|DEPTH
argument_list|(
name|vcline
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|<
name|LINE
argument_list|(
name|vcline
operator|+
literal|1
argument_list|)
operator|||
name|c
operator|>
name|WBOT
condition|)
return|return;
name|i
operator|=
name|destcol
expr_stmt|;
name|vinslin
argument_list|(
name|c
argument_list|,
literal|1
argument_list|,
name|vcline
argument_list|)
expr_stmt|;
name|DEPTH
argument_list|(
name|vcline
argument_list|)
operator|++
expr_stmt|;
name|vigoto
argument_list|(
name|c
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|vprepins
argument_list|()
expr_stmt|;
block|}
return|return;
block|}
comment|/* 	 * Compute the number of positions in the line image of the 	 * current line.  This is done from the physical image 	 * since that is faster.  Note that we have no memory 	 * from insertion to insertion so that routines which use 	 * us don't have to worry about moving the cursor around. 	 */
if|if
condition|(
operator|*
name|vtube0
operator|==
literal|0
condition|)
name|linend
operator|=
literal|0
expr_stmt|;
else|else
block|{
comment|/* 		 * Search backwards for a non-null character 		 * from the end of the displayed line. 		 */
name|i
operator|=
name|WCOLS
operator|*
name|DEPTH
argument_list|(
name|vcline
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
name|i
operator|=
name|WCOLS
expr_stmt|;
name|tp
operator|=
name|vtube0
operator|+
name|i
expr_stmt|;
while|while
condition|(
operator|*
operator|--
name|tp
operator|==
literal|0
condition|)
if|if
condition|(
operator|--
name|i
operator|==
literal|0
condition|)
break|break;
name|linend
operator|=
name|i
expr_stmt|;
block|}
comment|/* 	 * We insert at a position based on the physical location 	 * of the output cursor. 	 */
name|inscol
operator|=
name|destcol
operator|+
operator|(
name|destline
operator|-
name|LINE
argument_list|(
name|vcline
argument_list|)
operator|)
operator|*
name|WCOLS
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\t'
condition|)
block|{
comment|/* 		 * Characters inserted from a tab must be 		 * remembered as being part of a tab, but we can't 		 * use QUOTE here since we really need to print blanks. 		 * QUOTE|' ' is the representation of this. 		 */
name|inssiz
operator|=
name|tabcol
argument_list|(
name|inscol
argument_list|,
name|value
argument_list|(
name|TABSTOP
argument_list|)
argument_list|)
operator|-
name|inscol
expr_stmt|;
name|c
operator|=
literal|' '
operator||
name|QUOTE
expr_stmt|;
block|}
else|else
name|inssiz
operator|=
literal|1
expr_stmt|;
comment|/* 	 * If the text to be inserted is less than the number 	 * of doomed positions, then we don't need insert mode, 	 * rather we can just typeover. 	 */
if|if
condition|(
name|inssiz
operator|<=
name|doomed
condition|)
block|{
name|endim
argument_list|()
expr_stmt|;
if|if
condition|(
name|inscol
operator|!=
name|linend
condition|)
name|doomed
operator|-=
name|inssiz
expr_stmt|;
do|do
name|vputchar
argument_list|(
name|c
argument_list|)
expr_stmt|;
do|while
condition|(
operator|--
name|inssiz
condition|)
do|;
return|return;
block|}
comment|/* 	 * Have to really do some insertion, thus 	 * stake out the bounds of the first following 	 * group of tabs, computing starting position, 	 * ending position, and the number of ``spaces'' therein 	 * so we can tell how much it will squish. 	 */
name|tp
operator|=
name|vtube0
operator|+
name|inscol
expr_stmt|;
for|for
control|(
name|i
operator|=
name|inscol
init|;
name|i
operator|<
name|linend
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|*
name|tp
operator|++
operator|&
name|QUOTE
condition|)
block|{
operator|--
name|tp
expr_stmt|;
break|break;
block|}
name|tabstart
operator|=
name|tabend
operator|=
name|i
expr_stmt|;
name|tabslack
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|tabend
operator|<
name|linend
condition|)
block|{
name|i
operator|=
operator|*
name|tp
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|&
name|QUOTE
operator|)
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
operator|(
name|i
operator|&
name|TRIM
operator|)
operator|==
literal|0
condition|)
name|tabslack
operator|++
expr_stmt|;
name|tabsize
operator|++
expr_stmt|;
name|tabend
operator|++
expr_stmt|;
block|}
name|tabsize
operator|=
name|tabend
operator|-
name|tabstart
expr_stmt|;
comment|/* 	 * For HP's and DM's, e.g. tabslack has no meaning. 	 */
if|if
condition|(
operator|!
name|IN
condition|)
name|tabslack
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|IDEBUG
if|if
condition|(
name|trace
condition|)
block|{
name|fprintf
argument_list|(
name|trace
argument_list|,
literal|"inscol %d, inssiz %d, tabstart %d, "
argument_list|,
name|inscol
argument_list|,
name|inssiz
argument_list|,
name|tabstart
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|trace
argument_list|,
literal|"tabend %d, tabslack %d, linend %d\n"
argument_list|,
name|tabend
argument_list|,
name|tabslack
argument_list|,
name|linend
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* 	 * The real work begins. 	 */
name|slakused
operator|=
literal|0
expr_stmt|;
name|shft
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|tabsize
condition|)
block|{
comment|/* 		 * There are tabs on this line. 		 * If they need to expand, then the rest of the line 		 * will have to be shifted over.  In this case, 		 * we will need to make sure there are no ``spaces'' 		 * in the rest of the line (on e.g. CONCEPT-100) 		 * and then grab another segment on the screen if this 		 * line is now deeper.  We then do the shift 		 * implied by the insertion. 		 */
if|if
condition|(
name|inssiz
operator|>=
name|doomed
operator|+
name|tabcol
argument_list|(
name|tabstart
argument_list|,
name|value
argument_list|(
name|TABSTOP
argument_list|)
argument_list|)
operator|-
name|tabstart
condition|)
block|{
if|if
condition|(
name|IN
condition|)
name|vrigid
argument_list|()
expr_stmt|;
name|vneedpos
argument_list|(
name|value
argument_list|(
name|TABSTOP
argument_list|)
argument_list|)
expr_stmt|;
name|vishft
argument_list|()
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|inssiz
operator|>
name|doomed
condition|)
comment|/* 		 * No tabs, but line may still get deeper. 		 */
name|vneedpos
argument_list|(
name|inssiz
operator|-
name|doomed
argument_list|)
expr_stmt|;
comment|/* 	 * Now put in the inserted characters. 	 */
name|viin
argument_list|(
name|c
argument_list|)
expr_stmt|;
comment|/* 	 * Now put the cursor in its final resting place. 	 */
name|destline
operator|=
name|LINE
argument_list|(
name|vcline
argument_list|)
expr_stmt|;
name|destcol
operator|=
name|inscol
operator|+
name|inssiz
expr_stmt|;
name|vcsync
argument_list|()
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Rigidify the rest of the line after the first  * group of following tabs, typing blanks over ``spaces''.  */
end_comment

begin_macro
name|vrigid
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|col
decl_stmt|;
specifier|register
name|char
modifier|*
name|tp
init|=
name|vtube0
operator|+
name|tabend
decl_stmt|;
for|for
control|(
name|col
operator|=
name|tabend
init|;
name|col
operator|<
name|linend
condition|;
name|col
operator|++
control|)
if|if
condition|(
operator|(
operator|*
name|tp
operator|++
operator|&
name|TRIM
operator|)
operator|==
literal|0
condition|)
block|{
name|endim
argument_list|()
expr_stmt|;
name|vgotoCL
argument_list|(
name|col
argument_list|)
expr_stmt|;
name|vputchar
argument_list|(
literal|' '
operator||
name|QUOTE
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  * We need cnt more positions on this line.  * Open up new space on the screen (this may in fact be a  * screen rollup).  *  * On a dumb terminal we may infact redisplay the rest of the  * screen here brute force to keep it pretty.  */
end_comment

begin_macro
name|vneedpos
argument_list|(
argument|cnt
argument_list|)
end_macro

begin_decl_stmt
name|int
name|cnt
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|d
init|=
name|DEPTH
argument_list|(
name|vcline
argument_list|)
decl_stmt|;
specifier|register
name|int
name|rmdr
init|=
name|d
operator|*
name|WCOLS
operator|-
name|linend
decl_stmt|;
if|if
condition|(
name|cnt
operator|<=
name|rmdr
operator|-
name|IN
condition|)
return|return;
name|endim
argument_list|()
expr_stmt|;
name|vnpins
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|vnpins
argument_list|(
argument|dosync
argument_list|)
end_macro

begin_decl_stmt
name|int
name|dosync
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|d
init|=
name|DEPTH
argument_list|(
name|vcline
argument_list|)
decl_stmt|;
specifier|register
name|int
name|e
decl_stmt|;
name|e
operator|=
name|LINE
argument_list|(
name|vcline
argument_list|)
operator|+
name|DEPTH
argument_list|(
name|vcline
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|<
name|LINE
argument_list|(
name|vcline
operator|+
literal|1
argument_list|)
condition|)
block|{
name|vigoto
argument_list|(
name|e
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|vclreol
argument_list|()
expr_stmt|;
return|return;
block|}
name|DEPTH
argument_list|(
name|vcline
argument_list|)
operator|++
expr_stmt|;
if|if
condition|(
name|e
operator|<
name|WECHO
condition|)
block|{
name|e
operator|=
name|vglitchup
argument_list|(
name|vcline
argument_list|,
name|d
argument_list|)
expr_stmt|;
name|vigoto
argument_list|(
name|e
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|vclreol
argument_list|()
expr_stmt|;
if|if
condition|(
name|dosync
condition|)
block|{
name|int
function_decl|(
modifier|*
name|Ooutchar
function_decl|)
parameter_list|()
init|=
name|Outchar
function_decl|;
name|Outchar
operator|=
name|vputchar
expr_stmt|;
name|vsync
argument_list|(
name|e
operator|+
literal|1
argument_list|)
expr_stmt|;
name|Outchar
operator|=
name|Ooutchar
expr_stmt|;
block|}
block|}
else|else
block|{
name|vup1
argument_list|()
expr_stmt|;
name|vigoto
argument_list|(
name|WBOT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|vclreol
argument_list|()
expr_stmt|;
block|}
name|vprepins
argument_list|()
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Do the shift of the next tabstop implied by  * insertion so it expands.  */
end_comment

begin_macro
name|vishft
argument_list|()
end_macro

begin_block
block|{
name|int
name|tshft
init|=
literal|0
decl_stmt|;
name|int
name|j
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|char
modifier|*
name|tp
init|=
name|vtube0
decl_stmt|;
specifier|register
name|char
modifier|*
name|up
decl_stmt|;
name|short
name|oldhold
init|=
name|hold
decl_stmt|;
name|shft
operator|=
name|value
argument_list|(
name|TABSTOP
argument_list|)
expr_stmt|;
name|hold
operator||=
name|HOLDPUPD
expr_stmt|;
if|if
condition|(
operator|!
name|IM
operator|&&
operator|!
name|EI
condition|)
block|{
comment|/* 		 * Dumb terminals are easy, we just have 		 * to retype the text. 		 */
name|vigotoCL
argument_list|(
name|tabend
operator|+
name|shft
argument_list|)
expr_stmt|;
name|up
operator|=
name|tp
operator|+
name|tabend
expr_stmt|;
for|for
control|(
name|i
operator|=
name|tabend
init|;
name|i
operator|<
name|linend
condition|;
name|i
operator|++
control|)
name|vputchar
argument_list|(
operator|*
name|up
operator|++
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|IN
condition|)
block|{
comment|/* 		 * CONCEPT-like terminals do most of the work for us, 		 * we don't have to muck with simulation of multi-line 		 * insert mode.  Some of the shifting may come for free 		 * also if the tabs don't have enough slack to take up 		 * all the inserted characters. 		 */
name|i
operator|=
name|shft
expr_stmt|;
name|slakused
operator|=
name|inssiz
operator|-
name|doomed
expr_stmt|;
if|if
condition|(
name|slakused
operator|>
name|tabslack
condition|)
block|{
name|i
operator|-=
name|slakused
operator|-
name|tabslack
expr_stmt|;
name|slakused
operator|-=
name|tabslack
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|>
literal|0
operator|&&
name|tabend
operator|!=
name|linend
condition|)
block|{
name|tshft
operator|=
name|i
expr_stmt|;
name|vgotoCL
argument_list|(
name|tabend
argument_list|)
expr_stmt|;
name|goim
argument_list|()
expr_stmt|;
do|do
name|vputchar
argument_list|(
literal|' '
operator||
name|QUOTE
argument_list|)
expr_stmt|;
do|while
condition|(
operator|--
name|i
condition|)
do|;
block|}
block|}
else|else
block|{
comment|/* 		 * HP and Datamedia type terminals have to have multi-line 		 * insert faked.  Hack each segment after where we are 		 * (going backwards to where we are.)  We then can 		 * hack the segment where the end of the first following 		 * tab group is. 		 */
for|for
control|(
name|j
operator|=
name|DEPTH
argument_list|(
name|vcline
argument_list|)
operator|-
literal|1
init|;
name|j
operator|>
operator|(
name|tabend
operator|+
name|shft
operator|)
operator|/
name|WCOLS
condition|;
name|j
operator|--
control|)
block|{
name|vgotoCL
argument_list|(
name|j
operator|*
name|WCOLS
argument_list|)
expr_stmt|;
name|goim
argument_list|()
expr_stmt|;
name|up
operator|=
name|tp
operator|+
name|j
operator|*
name|WCOLS
operator|-
name|shft
expr_stmt|;
name|i
operator|=
name|shft
expr_stmt|;
do|do
block|{
if|if
condition|(
operator|*
name|up
condition|)
name|vputchar
argument_list|(
operator|*
name|up
operator|++
argument_list|)
expr_stmt|;
else|else
break|break;
block|}
do|while
condition|(
operator|--
name|i
condition|)
do|;
block|}
name|vigotoCL
argument_list|(
name|tabstart
argument_list|)
expr_stmt|;
name|i
operator|=
name|shft
operator|-
operator|(
name|inssiz
operator|-
name|doomed
operator|)
expr_stmt|;
if|if
condition|(
name|i
operator|>
literal|0
condition|)
block|{
name|tabslack
operator|=
name|inssiz
operator|-
name|doomed
expr_stmt|;
name|vcsync
argument_list|()
expr_stmt|;
name|goim
argument_list|()
expr_stmt|;
do|do
name|vputchar
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
do|while
condition|(
operator|--
name|i
condition|)
do|;
block|}
block|}
comment|/* 	 * Now do the data moving in the internal screen 	 * image which is common to all three cases. 	 */
name|tp
operator|+=
name|linend
expr_stmt|;
name|up
operator|=
name|tp
operator|+
name|shft
expr_stmt|;
name|i
operator|=
name|linend
operator|-
name|tabend
expr_stmt|;
if|if
condition|(
name|i
operator|>
literal|0
condition|)
do|do
operator|*
operator|--
name|up
operator|=
operator|*
operator|--
name|tp
expr_stmt|;
do|while
condition|(
operator|--
name|i
condition|)
do|;
if|if
condition|(
name|IN
operator|&&
name|tshft
condition|)
block|{
name|i
operator|=
name|tshft
expr_stmt|;
do|do
operator|*
operator|--
name|up
operator|=
literal|' '
operator||
name|QUOTE
expr_stmt|;
do|while
condition|(
operator|--
name|i
condition|)
do|;
block|}
name|hold
operator|=
name|oldhold
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Now do the insert of the characters (finally).  */
end_comment

begin_macro
name|viin
argument_list|(
argument|c
argument_list|)
end_macro

begin_decl_stmt
name|int
name|c
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* mjm: char --> int */
end_comment

begin_block
block|{
specifier|register
name|char
modifier|*
name|tp
decl_stmt|,
modifier|*
name|up
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
specifier|register
name|bool
name|noim
init|=
literal|0
decl_stmt|;
name|int
name|remdoom
decl_stmt|;
name|short
name|oldhold
init|=
name|hold
decl_stmt|;
name|hold
operator||=
name|HOLDPUPD
expr_stmt|;
if|if
condition|(
name|tabsize
operator|&&
operator|(
name|IM
operator|&&
name|EI
operator|)
operator|&&
name|inssiz
operator|-
name|doomed
operator|>
name|tabslack
condition|)
comment|/* 		 * There is a tab out there which will be affected 		 * by the insertion since there aren't enough doomed 		 * characters to take up all the insertion and we do 		 * have insert mode capability. 		 */
if|if
condition|(
name|inscol
operator|+
name|doomed
operator|==
name|tabstart
condition|)
block|{
comment|/* 			 * The end of the doomed characters sits right at the 			 * start of the tabs, then we don't need to use insert 			 * mode; unless the tab has already been expanded 			 * in which case we MUST use insert mode. 			 */
name|slakused
operator|=
literal|0
expr_stmt|;
name|noim
operator|=
operator|!
name|shft
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * The last really special case to handle is case 			 * where the tab is just sitting there and doesn't 			 * have enough slack to let the insertion take 			 * place without shifting the rest of the line 			 * over.  In this case we have to go out and 			 * delete some characters of the tab before we start 			 * or the answer will be wrong, as the rest of the 			 * line will have been shifted.  This code means 			 * that terminals with only insert chracter (no 			 * delete character) won't work correctly. 			 */
name|i
operator|=
name|inssiz
operator|-
name|doomed
operator|-
name|tabslack
operator|-
name|slakused
expr_stmt|;
name|i
operator|%=
name|value
argument_list|(
name|TABSTOP
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|>
literal|0
condition|)
block|{
name|vgotoCL
argument_list|(
name|tabstart
argument_list|)
expr_stmt|;
name|godm
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
name|inssiz
operator|-
name|doomed
operator|-
name|tabslack
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
name|vputp
argument_list|(
name|DC
argument_list|,
name|DEPTH
argument_list|(
name|vcline
argument_list|)
argument_list|)
expr_stmt|;
name|enddm
argument_list|()
expr_stmt|;
block|}
block|}
comment|/*  	 * Now put out the characters of the actual insertion. 	 */
name|vigotoCL
argument_list|(
name|inscol
argument_list|)
expr_stmt|;
name|remdoom
operator|=
name|doomed
expr_stmt|;
for|for
control|(
name|i
operator|=
name|inssiz
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|remdoom
operator|>
literal|0
condition|)
block|{
name|remdoom
operator|--
expr_stmt|;
name|endim
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|noim
condition|)
name|endim
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
name|IM
operator|&&
name|EI
condition|)
block|{
name|vcsync
argument_list|()
expr_stmt|;
name|goim
argument_list|()
expr_stmt|;
block|}
name|vputchar
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|IM
operator|||
operator|!
name|EI
condition|)
block|{
comment|/* 		 * We are a dumb terminal; brute force update 		 * the rest of the line; this is very much an n^^2 process, 		 * and totally unreasonable at low speed. 		 * 		 * You asked for it, you get it. 		 */
name|tp
operator|=
name|vtube0
operator|+
name|inscol
operator|+
name|doomed
expr_stmt|;
for|for
control|(
name|i
operator|=
name|inscol
operator|+
name|doomed
init|;
name|i
operator|<
name|tabstart
condition|;
name|i
operator|++
control|)
name|vputchar
argument_list|(
operator|*
name|tp
operator|++
argument_list|)
expr_stmt|;
name|hold
operator|=
name|oldhold
expr_stmt|;
name|vigotoCL
argument_list|(
name|tabstart
operator|+
name|inssiz
operator|-
name|doomed
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|tabsize
operator|-
operator|(
name|inssiz
operator|-
name|doomed
operator|)
operator|+
name|shft
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
name|vputchar
argument_list|(
literal|' '
operator||
name|QUOTE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|IN
condition|)
block|{
comment|/* 			 * On terminals without multi-line 			 * insert in the hardware, we must go fix the segments 			 * between the inserted text and the following 			 * tabs, if they are on different lines. 			 * 			 * Aaargh. 			 */
name|tp
operator|=
name|vtube0
expr_stmt|;
for|for
control|(
name|j
operator|=
operator|(
name|inscol
operator|+
name|inssiz
operator|-
literal|1
operator|)
operator|/
name|WCOLS
operator|+
literal|1
init|;
name|j
operator|<=
operator|(
name|tabstart
operator|+
name|inssiz
operator|-
name|doomed
operator|-
literal|1
operator|)
operator|/
name|WCOLS
condition|;
name|j
operator|++
control|)
block|{
name|vgotoCL
argument_list|(
name|j
operator|*
name|WCOLS
argument_list|)
expr_stmt|;
name|i
operator|=
name|inssiz
operator|-
name|doomed
expr_stmt|;
name|up
operator|=
name|tp
operator|+
name|j
operator|*
name|WCOLS
operator|-
name|i
expr_stmt|;
name|goim
argument_list|()
expr_stmt|;
do|do
name|vputchar
argument_list|(
operator|*
name|up
operator|++
argument_list|)
expr_stmt|;
do|while
condition|(
operator|--
name|i
operator|&&
operator|*
name|up
condition|)
do|;
block|}
block|}
else|else
block|{
comment|/* 			 * On terminals with multi line inserts, 			 * life is simpler, just reflect eating of 			 * the slack. 			 */
name|tp
operator|=
name|vtube0
operator|+
name|tabend
expr_stmt|;
for|for
control|(
name|i
operator|=
name|tabsize
operator|-
operator|(
name|inssiz
operator|-
name|doomed
operator|)
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
operator|(
operator|*
operator|--
name|tp
operator|&
operator|(
name|QUOTE
operator||
name|TRIM
operator|)
operator|)
operator|==
name|QUOTE
condition|)
block|{
operator|--
name|tabslack
expr_stmt|;
if|if
condition|(
name|tabslack
operator|>=
name|slakused
condition|)
continue|continue;
block|}
operator|*
name|tp
operator|=
literal|' '
operator||
name|QUOTE
expr_stmt|;
block|}
block|}
comment|/* 		 * Blank out the shifted positions to be tab positions. 		 */
if|if
condition|(
name|shft
condition|)
block|{
name|tp
operator|=
name|vtube0
operator|+
name|tabend
operator|+
name|shft
expr_stmt|;
for|for
control|(
name|i
operator|=
name|tabsize
operator|-
operator|(
name|inssiz
operator|-
name|doomed
operator|)
operator|+
name|shft
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
operator|(
operator|*
operator|--
name|tp
operator|&
name|QUOTE
operator|)
operator|==
literal|0
condition|)
operator|*
name|tp
operator|=
literal|' '
operator||
name|QUOTE
expr_stmt|;
block|}
block|}
comment|/* 	 * Finally, complete the screen image update 	 * to reflect the insertion. 	 */
name|hold
operator|=
name|oldhold
expr_stmt|;
name|tp
operator|=
name|vtube0
operator|+
name|tabstart
expr_stmt|;
name|up
operator|=
name|tp
operator|+
name|inssiz
operator|-
name|doomed
expr_stmt|;
for|for
control|(
name|i
operator|=
name|tabstart
init|;
name|i
operator|>
name|inscol
operator|+
name|doomed
condition|;
name|i
operator|--
control|)
operator|*
operator|--
name|up
operator|=
operator|*
operator|--
name|tp
expr_stmt|;
for|for
control|(
name|i
operator|=
name|inssiz
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
operator|*
operator|--
name|up
operator|=
name|c
expr_stmt|;
name|doomed
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Go into ``delete mode''.  If the  * sequence which goes into delete mode  * is the same as that which goes into insert  * mode, then we are in delete mode already.  */
end_comment

begin_macro
name|godm
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|insmode
condition|)
block|{
if|if
condition|(
name|eq
argument_list|(
name|DM
argument_list|,
name|IM
argument_list|)
condition|)
return|return;
name|endim
argument_list|()
expr_stmt|;
block|}
name|vputp
argument_list|(
name|DM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * If we are coming out of delete mode, but  * delete and insert mode end with the same sequence,  * it wins to pretend we are now in insert mode,  * since we will likely want to be there again soon  * if we just moved over to delete space from part of  * a tab (above).  */
end_comment

begin_macro
name|enddm
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|eq
argument_list|(
name|DM
argument_list|,
name|IM
argument_list|)
condition|)
block|{
name|insmode
operator|=
literal|1
expr_stmt|;
return|return;
block|}
name|vputp
argument_list|(
name|ED
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * In and out of insert mode.  * Note that the code here demands that there be  * a string for insert mode (the null string) even  * if the terminal does all insertions a single character  * at a time, since it branches based on whether IM is null.  */
end_comment

begin_macro
name|goim
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
operator|!
name|insmode
condition|)
name|vputp
argument_list|(
name|IM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|insmode
operator|=
literal|1
expr_stmt|;
block|}
end_block

begin_macro
name|endim
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|insmode
condition|)
block|{
name|vputp
argument_list|(
name|EI
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|insmode
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  * Put the character c on the screen at the current cursor position.  * This routine handles wraparound and scrolling and understands not  * to roll when splitw is set, i.e. we are working in the echo area.  * There is a bunch of hacking here dealing with the difference between  * QUOTE, QUOTE|' ', and ' ' for CONCEPT-100 like terminals, and also  * code to deal with terminals which overstrike, including CRT's where  * you can erase overstrikes with some work.  CRT's which do underlining  * implicitly which has to be erased (like CONCEPTS) are also handled.  */
end_comment

begin_expr_stmt
name|vputchar
argument_list|(
name|c
argument_list|)
specifier|register
name|int
name|c
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|tp
decl_stmt|;
specifier|register
name|int
name|d
decl_stmt|;
name|c
operator|&=
operator|(
name|QUOTE
operator||
name|TRIM
operator|)
expr_stmt|;
ifdef|#
directive|ifdef
name|TRACE
if|if
condition|(
name|trace
condition|)
name|tracec
argument_list|(
name|c
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Fix problem of>79 chars on echo line. */
if|if
condition|(
name|destcol
operator|>=
name|WCOLS
operator|-
literal|1
operator|&&
name|splitw
operator|&&
name|destline
operator|==
name|WECHO
condition|)
name|pofix
argument_list|()
expr_stmt|;
if|if
condition|(
name|destcol
operator|>=
name|WCOLS
condition|)
block|{
name|destline
operator|+=
name|destcol
operator|/
name|WCOLS
expr_stmt|;
name|destcol
operator|%=
name|WCOLS
expr_stmt|;
block|}
if|if
condition|(
name|destline
operator|>
name|WBOT
operator|&&
operator|(
operator|!
name|splitw
operator|||
name|destline
operator|>
name|WECHO
operator|)
condition|)
name|vrollup
argument_list|(
name|destline
argument_list|)
expr_stmt|;
name|tp
operator|=
name|vtube
index|[
name|destline
index|]
operator|+
name|destcol
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'\t'
case|:
name|vgotab
argument_list|()
expr_stmt|;
return|return;
case|case
literal|' '
case|:
comment|/* 		 * We can get away without printing a space in a number 		 * of cases, but not always.  We get away with doing nothing 		 * if we are not in insert mode, and not on a CONCEPT-100 		 * like terminal, and either not in hardcopy open or in hardcopy 		 * open on a terminal with no overstriking, provided, 		 * in all cases, that nothing has ever been displayed 		 * at this position.  Ugh. 		 */
if|if
condition|(
operator|!
name|insmode
operator|&&
operator|!
name|IN
operator|&&
operator|(
name|state
operator|!=
name|HARDOPEN
operator|||
name|OS
operator|)
operator|&&
operator|(
operator|*
name|tp
operator|&
name|TRIM
operator|)
operator|==
literal|0
condition|)
block|{
operator|*
name|tp
operator|=
literal|' '
expr_stmt|;
name|destcol
operator|++
expr_stmt|;
return|return;
block|}
goto|goto
name|def
goto|;
case|case
name|QUOTE
case|:
if|if
condition|(
name|insmode
condition|)
block|{
comment|/* 			 * When in insert mode, tabs have to expand 			 * to real, printed blanks. 			 */
name|c
operator|=
literal|' '
operator||
name|QUOTE
expr_stmt|;
goto|goto
name|def
goto|;
block|}
if|if
condition|(
operator|*
name|tp
operator|==
literal|0
condition|)
block|{
comment|/* 			 * A ``space''. 			 */
if|if
condition|(
operator|(
name|hold
operator|&
name|HOLDPUPD
operator|)
operator|==
literal|0
condition|)
operator|*
name|tp
operator|=
name|QUOTE
expr_stmt|;
name|destcol
operator|++
expr_stmt|;
return|return;
block|}
comment|/* 		 * A ``space'' ontop of a part of a tab. 		 */
if|if
condition|(
operator|*
name|tp
operator|&
name|QUOTE
condition|)
block|{
name|destcol
operator|++
expr_stmt|;
return|return;
block|}
name|c
operator|=
literal|' '
operator||
name|QUOTE
expr_stmt|;
comment|/* fall into ... */
name|def
label|:
default|default:
name|d
operator|=
operator|*
name|tp
operator|&
name|TRIM
expr_stmt|;
comment|/* 		 * Now get away with doing nothing if the characters 		 * are the same, provided we are not in insert mode 		 * and if we are in hardopen, that the terminal has overstrike. 		 */
if|if
condition|(
name|d
operator|==
operator|(
name|c
operator|&
name|TRIM
operator|)
operator|&&
operator|!
name|insmode
operator|&&
operator|(
name|state
operator|!=
name|HARDOPEN
operator|||
name|OS
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|hold
operator|&
name|HOLDPUPD
operator|)
operator|==
literal|0
condition|)
operator|*
name|tp
operator|=
name|c
expr_stmt|;
name|destcol
operator|++
expr_stmt|;
return|return;
block|}
comment|/* 		 * Backwards looking optimization. 		 * The low level cursor motion routines will use 		 * a cursor motion right sequence to step 1 character 		 * right.  On, e.g., a DM3025A this is 2 characters 		 * and printing is noticeably slower at 300 baud. 		 * Since the low level routines are not allowed to use 		 * spaces for positioning, we discover the common 		 * case of a single space here and force a space 		 * to be printed. 		 */
if|if
condition|(
name|destcol
operator|==
name|outcol
operator|+
literal|1
operator|&&
name|tp
index|[
operator|-
literal|1
index|]
operator|==
literal|' '
operator|&&
name|outline
operator|==
name|destline
condition|)
block|{
name|vputc
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|outcol
operator|++
expr_stmt|;
block|}
comment|/* 		 * This is an inline expansion a call to vcsync() dictated 		 * by high frequency in a profile. 		 */
if|if
condition|(
name|outcol
operator|!=
name|destcol
operator|||
name|outline
operator|!=
name|destline
condition|)
name|vgoto
argument_list|(
name|destline
argument_list|,
name|destcol
argument_list|)
expr_stmt|;
comment|/* 		 * Deal with terminals which have overstrike. 		 * We handle erasing general overstrikes, erasing 		 * underlines on terminals (such as CONCEPTS) which 		 * do underlining correctly automatically (e.g. on nroff 		 * output), and remembering, in hardcopy mode, 		 * that we have overstruct something. 		 */
if|if
condition|(
operator|!
name|insmode
operator|&&
name|d
operator|&&
name|d
operator|!=
literal|' '
operator|&&
name|d
operator|!=
operator|(
name|c
operator|&
name|TRIM
operator|)
condition|)
block|{
if|if
condition|(
name|EO
operator|&&
operator|(
name|OS
operator|||
name|UL
operator|&&
operator|(
name|c
operator|==
literal|'_'
operator|||
name|d
operator|==
literal|'_'
operator|)
operator|)
condition|)
block|{
name|vputc
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|outcol
operator|++
operator|,
name|destcol
operator|++
expr_stmt|;
name|back1
argument_list|()
expr_stmt|;
block|}
else|else
name|rubble
operator|=
literal|1
expr_stmt|;
block|}
comment|/* 		 * Unless we are just bashing characters around for 		 * inner working of insert mode, update the display. 		 */
if|if
condition|(
operator|(
name|hold
operator|&
name|HOLDPUPD
operator|)
operator|==
literal|0
condition|)
operator|*
name|tp
operator|=
name|c
expr_stmt|;
comment|/* 		 * In insert mode, put out the IC sequence, padded 		 * based on the depth of the current line. 		 * A terminal which had no real insert mode, rather 		 * opening a character position at a time could do this. 		 * Actually should use depth to end of current line 		 * but this rarely matters. 		 */
if|if
condition|(
name|insmode
condition|)
name|vputp
argument_list|(
name|IC
argument_list|,
name|DEPTH
argument_list|(
name|vcline
argument_list|)
argument_list|)
expr_stmt|;
name|vputc
argument_list|(
name|c
operator|&
name|TRIM
argument_list|)
expr_stmt|;
comment|/* 		 * In insert mode, IP is a post insert pad. 		 */
if|if
condition|(
name|insmode
condition|)
name|vputp
argument_list|(
name|IP
argument_list|,
name|DEPTH
argument_list|(
name|vcline
argument_list|)
argument_list|)
expr_stmt|;
name|destcol
operator|++
operator|,
name|outcol
operator|++
expr_stmt|;
comment|/* 		 * CONCEPT braindamage in early models:  after a wraparound 		 * the next newline is eaten.  It's hungry so we just 		 * feed it now rather than worrying about it. 		 * Fixed to use	return linefeed to work right 		 * on vt100/tab132 as well as concept. 		 */
if|if
condition|(
name|XN
operator|&&
name|outcol
operator|%
name|WCOLS
operator|==
literal|0
condition|)
block|{
name|vputc
argument_list|(
literal|'\r'
argument_list|)
expr_stmt|;
name|vputc
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_block

begin_comment
comment|/*  * Delete display positions stcol through endcol.  * Amount of use of special terminal features here is limited.  */
end_comment

begin_macro
name|physdc
argument_list|(
argument|stcol
argument_list|,
argument|endcol
argument_list|)
end_macro

begin_decl_stmt
name|int
name|stcol
decl_stmt|,
name|endcol
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|tp
decl_stmt|,
modifier|*
name|up
decl_stmt|;
name|char
modifier|*
name|tpe
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|int
name|nc
init|=
name|endcol
operator|-
name|stcol
decl_stmt|;
ifdef|#
directive|ifdef
name|IDEBUG
if|if
condition|(
name|trace
condition|)
name|tfixnl
argument_list|()
operator|,
name|fprintf
argument_list|(
name|trace
argument_list|,
literal|"physdc(%d, %d)\n"
argument_list|,
name|stcol
argument_list|,
name|endcol
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|DC
operator|||
name|nc
operator|<=
literal|0
condition|)
return|return;
if|if
condition|(
name|IN
condition|)
block|{
comment|/* 		 * CONCEPT-100 like terminal. 		 * If there are any ``spaces'' in the material to be 		 * deleted, then this is too hard, just retype. 		 */
name|vprepins
argument_list|()
expr_stmt|;
name|up
operator|=
name|vtube0
operator|+
name|stcol
expr_stmt|;
name|i
operator|=
name|nc
expr_stmt|;
do|do
if|if
condition|(
operator|(
operator|*
name|up
operator|++
operator|&
operator|(
name|QUOTE
operator||
name|TRIM
operator|)
operator|)
operator|==
name|QUOTE
condition|)
return|return;
do|while
condition|(
operator|--
name|i
condition|)
do|;
name|i
operator|=
literal|2
operator|*
name|nc
expr_stmt|;
do|do
if|if
condition|(
operator|*
name|up
operator|==
literal|0
operator|||
operator|(
operator|*
name|up
operator|++
operator|&
name|QUOTE
operator|)
operator|==
name|QUOTE
condition|)
return|return;
do|while
condition|(
operator|--
name|i
condition|)
do|;
name|vgotoCL
argument_list|(
name|stcol
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * HP like delete mode. 		 * Compute how much text we are moving over by deleting. 		 * If it appears to be faster to just retype 		 * the line, do nothing and that will be done later. 		 * We are assuming 2 output characters per deleted 		 * characters and that clear to end of line is available. 		 */
name|i
operator|=
name|stcol
operator|/
name|WCOLS
expr_stmt|;
if|if
condition|(
name|i
operator|!=
name|endcol
operator|/
name|WCOLS
condition|)
return|return;
name|i
operator|+=
name|LINE
argument_list|(
name|vcline
argument_list|)
expr_stmt|;
name|stcol
operator|%=
name|WCOLS
expr_stmt|;
name|endcol
operator|%=
name|WCOLS
expr_stmt|;
name|up
operator|=
name|vtube
index|[
name|i
index|]
expr_stmt|;
name|tp
operator|=
name|up
operator|+
name|endcol
expr_stmt|;
name|tpe
operator|=
name|up
operator|+
name|WCOLS
expr_stmt|;
while|while
condition|(
name|tp
operator|<
name|tpe
operator|&&
operator|*
name|tp
condition|)
name|tp
operator|++
expr_stmt|;
if|if
condition|(
name|tp
operator|-
operator|(
name|up
operator|+
name|stcol
operator|)
operator|<
literal|2
operator|*
name|nc
condition|)
return|return;
name|vgoto
argument_list|(
name|i
argument_list|,
name|stcol
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Go into delete mode and do the actual delete. 	 * Padding is on DC itself. 	 */
name|godm
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
name|nc
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
name|vputp
argument_list|(
name|DC
argument_list|,
name|DEPTH
argument_list|(
name|vcline
argument_list|)
argument_list|)
expr_stmt|;
name|vputp
argument_list|(
name|ED
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * Straighten up. 	 * With CONCEPT like terminals, characters are pulled left 	 * from first following null.  HP like terminals shift rest of 	 * this (single physical) line rigidly. 	 */
if|if
condition|(
name|IN
condition|)
block|{
name|up
operator|=
name|vtube0
operator|+
name|stcol
expr_stmt|;
name|tp
operator|=
name|vtube0
operator|+
name|endcol
expr_stmt|;
while|while
condition|(
name|i
operator|=
operator|*
name|tp
operator|++
condition|)
block|{
if|if
condition|(
operator|(
name|i
operator|&
operator|(
name|QUOTE
operator||
name|TRIM
operator|)
operator|)
operator|==
name|QUOTE
condition|)
break|break;
operator|*
name|up
operator|++
operator|=
name|i
expr_stmt|;
block|}
do|do
operator|*
name|up
operator|++
operator|=
name|i
expr_stmt|;
do|while
condition|(
operator|--
name|nc
condition|)
do|;
block|}
else|else
block|{
name|copy
argument_list|(
name|up
operator|+
name|stcol
argument_list|,
name|up
operator|+
name|endcol
argument_list|,
name|WCOLS
operator|-
name|endcol
argument_list|)
expr_stmt|;
name|vclrbyte
argument_list|(
name|tpe
operator|-
name|nc
argument_list|,
name|nc
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|TRACE
end_ifdef

begin_macro
name|tfixnl
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|trubble
operator|||
name|techoin
condition|)
name|fprintf
argument_list|(
name|trace
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|trubble
operator|=
literal|0
operator|,
name|techoin
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_macro
name|tvliny
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|trace
condition|)
return|return;
name|tfixnl
argument_list|()
expr_stmt|;
name|fprintf
argument_list|(
name|trace
argument_list|,
literal|"vcnt = %d, vcline = %d, vliny = "
argument_list|,
name|vcnt
argument_list|,
name|vcline
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|vcnt
condition|;
name|i
operator|++
control|)
block|{
name|fprintf
argument_list|(
name|trace
argument_list|,
literal|"%d"
argument_list|,
name|LINE
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|FLAGS
argument_list|(
name|i
argument_list|)
operator|&
name|VDIRT
condition|)
name|fprintf
argument_list|(
name|trace
argument_list|,
literal|"*"
argument_list|)
expr_stmt|;
if|if
condition|(
name|DEPTH
argument_list|(
name|i
argument_list|)
operator|!=
literal|1
condition|)
name|fprintf
argument_list|(
name|trace
argument_list|,
literal|"<%d>"
argument_list|,
name|DEPTH
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
name|vcnt
condition|)
name|fprintf
argument_list|(
name|trace
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|trace
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|tracec
argument_list|(
argument|c
argument_list|)
end_macro

begin_decl_stmt
name|int
name|c
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* mjm: char --> int */
end_comment

begin_block
block|{
if|if
condition|(
operator|!
name|techoin
condition|)
name|trubble
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|ESCAPE
condition|)
name|fprintf
argument_list|(
name|trace
argument_list|,
literal|"$"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|&
name|QUOTE
condition|)
comment|/* mjm: for 3B (no sign extension) */
name|fprintf
argument_list|(
name|trace
argument_list|,
literal|"~%c"
argument_list|,
name|ctlof
argument_list|(
name|c
operator|&
name|TRIM
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|<
literal|' '
operator|||
name|c
operator|==
name|DELETE
condition|)
name|fprintf
argument_list|(
name|trace
argument_list|,
literal|"^%c"
argument_list|,
name|ctlof
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|trace
argument_list|,
literal|"%c"
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Put a character with possible tracing.  */
end_comment

begin_macro
name|vputch
argument_list|(
argument|c
argument_list|)
end_macro

begin_decl_stmt
name|int
name|c
decl_stmt|;
end_decl_stmt

begin_block
block|{
ifdef|#
directive|ifdef
name|TRACE
if|if
condition|(
name|trace
condition|)
name|tracec
argument_list|(
name|c
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|vputc
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
end_block

end_unit

