begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * $Source: /mit/kerberos/src/lib/des/RCS/make_key_perm.c,v $  * $Author: jtkohl $  * $Locker:  $  *  * Copyright 1988 by the Massachusetts Institute of Technology.  *  * For copying and distribution information, please see the file  *<mit-copyright.h>.  *  * This routine calculates an effective Key schedule set of  * permutations for des.  Beginning with the pre-defined key schedule  * algorithm, it reduces it to a set of 16 permutations upon the  * initial key.  Only needs to execute once to produce a header file.  * Note that we subtract one from the values ouput to fix up for C  * subscripts starting at 0.  */
end_comment

begin_include
include|#
directive|include
file|<mit-copyright.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|"des_internal.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|rcsid
index|[]
init|=
literal|"$Header: make_key_perm.c,v 4.9 88/11/15 11:29:40 jtkohl Exp $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* lint */
end_comment

begin_decl_stmt
name|char
modifier|*
name|progname
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|extern
name|char
modifier|*
name|errmsg
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|extern
name|int
name|errno
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|extern
name|long
name|swap_bit_pos_1
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|long
name|swap_bit_pos_0
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|int
name|sflag
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|vflag
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|dflag
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|pid
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|child_status
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|key_position
index|[
literal|64
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|C
index|[
literal|28
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|D
index|[
literal|28
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|C_temp
decl_stmt|,
name|D_temp
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  *  CONVENTIONS for numbering the bits  *  bit 0 ==> lsb  *  L starts at bit 0  *  R starts at bit 64  *  *  BEWARE-- some stuff starts at 0, some at 1;  perhaps some bugs still?  */
end_comment

begin_comment
comment|/*  * Sequence of shifts used for the key schedule.  */
end_comment

begin_decl_stmt
name|int
specifier|const
name|shift
index|[
literal|16
operator|+
literal|1
index|]
init|=
block|{
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|1
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|1
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
specifier|const
name|pc_1
index|[
literal|64
operator|+
literal|1
index|]
init|=
block|{
literal|0
block|,
literal|57
block|,
literal|49
block|,
literal|41
block|,
literal|33
block|,
literal|25
block|,
literal|17
block|,
literal|9
block|,
literal|1
block|,
literal|58
block|,
literal|50
block|,
literal|42
block|,
literal|34
block|,
literal|26
block|,
literal|18
block|,
literal|10
block|,
literal|2
block|,
literal|59
block|,
literal|51
block|,
literal|43
block|,
literal|35
block|,
literal|27
block|,
literal|19
block|,
literal|11
block|,
literal|3
block|,
literal|60
block|,
literal|52
block|,
literal|44
block|,
literal|36
block|,
literal|63
block|,
literal|55
block|,
literal|47
block|,
literal|39
block|,
literal|31
block|,
literal|23
block|,
literal|15
block|,
literal|7
block|,
literal|62
block|,
literal|54
block|,
literal|46
block|,
literal|38
block|,
literal|30
block|,
literal|22
block|,
literal|14
block|,
literal|6
block|,
literal|61
block|,
literal|53
block|,
literal|45
block|,
literal|37
block|,
literal|29
block|,
literal|21
block|,
literal|13
block|,
literal|5
block|,
literal|28
block|,
literal|20
block|,
literal|12
block|,
literal|4
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Permuted-choice 2, to pick out the bits from  * the CD array that generate the key schedule.  */
end_comment

begin_decl_stmt
name|int
specifier|const
name|pc_2
index|[
literal|48
operator|+
literal|1
index|]
init|=
block|{
literal|0
block|,
literal|14
block|,
literal|17
block|,
literal|11
block|,
literal|24
block|,
literal|1
block|,
literal|5
block|,
literal|3
block|,
literal|28
block|,
literal|15
block|,
literal|6
block|,
literal|21
block|,
literal|10
block|,
literal|23
block|,
literal|19
block|,
literal|12
block|,
literal|4
block|,
literal|26
block|,
literal|8
block|,
literal|16
block|,
literal|7
block|,
literal|27
block|,
literal|20
block|,
literal|13
block|,
literal|2
block|,
literal|41
block|,
literal|52
block|,
literal|31
block|,
literal|37
block|,
literal|47
block|,
literal|55
block|,
literal|30
block|,
literal|40
block|,
literal|51
block|,
literal|45
block|,
literal|33
block|,
literal|48
block|,
literal|44
block|,
literal|49
block|,
literal|39
block|,
literal|56
block|,
literal|34
block|,
literal|53
block|,
literal|46
block|,
literal|42
block|,
literal|50
block|,
literal|36
block|,
literal|29
block|,
literal|32
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|ks_perm
index|[
literal|16
operator|+
literal|1
index|]
index|[
literal|48
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|des_debug
decl_stmt|;
end_decl_stmt

begin_macro
name|gen
argument_list|(
argument|stream
argument_list|)
end_macro

begin_decl_stmt
name|FILE
modifier|*
name|stream
decl_stmt|;
end_decl_stmt

begin_block
block|{
comment|/*  Local Declarations */
specifier|register
name|i
operator|,
name|j
operator|,
name|iter
expr_stmt|;
comment|/*      * initialize the key_position array s.t. key_position[i] = i;      * that is, each element is equal to its starting position.      *      * Also adjust for the bit order within bytes.      */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|65
condition|;
name|i
operator|++
control|)
name|key_position
index|[
name|i
index|]
operator|=
name|swap_bit_pos_1
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"static int const key_perm[16][48] = {\n"
argument_list|)
expr_stmt|;
comment|/*      * apply pc_1 to initial key_position to create C[0] and D[0]      * Start at pc_1[1], not pc_1[0]      */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
literal|28
condition|;
name|i
operator|++
control|)
block|{
name|C
index|[
name|i
index|]
operator|=
name|key_position
index|[
name|pc_1
index|[
name|i
index|]
index|]
expr_stmt|;
name|D
index|[
name|i
index|]
operator|=
name|key_position
index|[
name|pc_1
index|[
name|i
operator|+
literal|28
index|]
index|]
expr_stmt|;
block|}
comment|/*      * major loop over the 16 iterations      * start at iter = 1, not zero.      */
for|for
control|(
name|iter
operator|=
literal|1
init|;
name|iter
operator|<=
literal|16
condition|;
name|iter
operator|++
control|)
block|{
if|if
condition|(
name|des_debug
condition|)
block|{
comment|/*  for debugging */
name|printf
argument_list|(
literal|"/* DEBUG-- start iteration = %d  shifts = %d"
argument_list|,
name|iter
argument_list|,
name|shift
index|[
name|iter
index|]
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\nC array"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
literal|4
condition|;
name|i
operator|++
control|)
block|{
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|1
init|;
name|j
operator|<=
literal|7
condition|;
name|j
operator|++
control|)
name|printf
argument_list|(
literal|"%d, "
argument_list|,
name|C
index|[
operator|(
name|i
operator|-
literal|1
operator|)
operator|*
literal|7
operator|+
name|j
index|]
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n\nD array"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
literal|4
condition|;
name|i
operator|++
control|)
block|{
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|1
init|;
name|j
operator|<=
literal|7
condition|;
name|j
operator|++
control|)
name|printf
argument_list|(
literal|"%d, "
argument_list|,
name|D
index|[
operator|(
name|i
operator|-
literal|1
operator|)
operator|*
literal|7
operator|+
name|j
index|]
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n */"
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
comment|/* apply the appropriate left shifts */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|shift
index|[
name|iter
index|]
condition|;
name|i
operator|++
control|)
block|{
name|C_temp
operator|=
name|C
index|[
literal|1
index|]
expr_stmt|;
name|D_temp
operator|=
name|D
index|[
literal|1
index|]
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|1
init|;
name|j
operator|<=
literal|27
condition|;
name|j
operator|++
control|)
block|{
name|C
index|[
name|j
index|]
operator|=
name|C
index|[
name|j
operator|+
literal|1
index|]
expr_stmt|;
name|D
index|[
name|j
index|]
operator|=
name|D
index|[
name|j
operator|+
literal|1
index|]
expr_stmt|;
block|}
name|C
index|[
name|j
index|]
operator|=
name|C_temp
expr_stmt|;
name|D
index|[
name|j
index|]
operator|=
name|D_temp
expr_stmt|;
block|}
if|if
condition|(
name|des_debug
condition|)
block|{
comment|/* for debugging */
name|printf
argument_list|(
literal|"/* DEBUG:\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" * after shifts, iteration = %d  shifts = %d"
argument_list|,
name|iter
argument_list|,
name|shift
index|[
name|iter
index|]
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\nC array"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
literal|4
condition|;
name|i
operator|++
control|)
block|{
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|1
init|;
name|j
operator|<=
literal|7
condition|;
name|j
operator|++
control|)
name|printf
argument_list|(
literal|"%d, "
argument_list|,
name|C
index|[
operator|(
name|i
operator|-
literal|1
operator|)
operator|*
literal|7
operator|+
name|j
index|]
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n\nD array"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
literal|4
condition|;
name|i
operator|++
control|)
block|{
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|1
init|;
name|j
operator|<=
literal|7
condition|;
name|j
operator|++
control|)
name|printf
argument_list|(
literal|"%d, "
argument_list|,
name|D
index|[
operator|(
name|i
operator|-
literal|1
operator|)
operator|*
literal|7
operator|+
name|j
index|]
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n */"
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
comment|/*          * apply pc_2          * Start at pc_2[1], not pc_2[0]          *          * Start stuffing ks_perm[1][1], not ks_perm[0][0]          *          * Adjust ks_perm for bit order if needed.          */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
literal|48
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|pc_2
index|[
name|i
index|]
operator|<=
literal|28
condition|)
name|ks_perm
index|[
name|iter
index|]
index|[
operator|(
name|i
operator|)
index|]
operator|=
name|C
index|[
name|pc_2
index|[
name|i
index|]
index|]
expr_stmt|;
else|else
name|ks_perm
index|[
name|iter
index|]
index|[
operator|(
name|i
operator|)
index|]
operator|=
name|D
index|[
name|pc_2
index|[
name|i
index|]
operator|-
literal|28
index|]
expr_stmt|;
block|}
comment|/* now output the resulting key permutation */
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"    /* ks permutation iteration = %2d */"
argument_list|,
name|iter
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
literal|6
condition|;
name|i
operator|++
control|)
block|{
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\n    "
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|1
init|;
name|j
operator|<=
literal|8
condition|;
name|j
operator|++
control|)
block|{
comment|/*                  * IMPORTANT -- subtract one from value to adjust to a                  * zero-based subscript for key                  */
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"%d"
argument_list|,
name|ks_perm
index|[
name|iter
index|]
index|[
operator|(
name|i
operator|-
literal|1
operator|)
operator|*
literal|8
operator|+
name|j
index|]
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* omit last comma */
if|if
condition|(
operator|(
name|j
operator|!=
literal|8
operator|)
operator|||
operator|(
name|i
operator|!=
literal|6
operator|)
operator|||
operator|(
name|iter
operator|!=
literal|16
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|", "
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\n};\n"
argument_list|)
expr_stmt|;
block|}
end_block

end_unit

