begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1982, 1986, 1989, 1993  *	The Regents of the University of California.  All rights reserved.  *  * This software was developed by the Computer Systems Engineering group  * at Lawrence Berkeley Laboratory under DARPA contract BG 91-66 and  * contributed to Berkeley.  *  * All advertising materials mentioning features or use of this software  * must display the following acknowledgement:  *	This product includes software developed by the University of  *	California, Lawrence Berkeley Laboratory.  *  * This module is believed to contain source code proprietary to AT&T.  * Use and redistribution is subject to the Berkeley Software License  * Agreement and your Software Agreement with AT&T (Western Electric).  *  *	@(#)sys_process.c	8.1 (Berkeley) 6/11/93  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/vnode.h>
end_include

begin_include
include|#
directive|include
file|<sys/buf.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/ptrace.h>
end_include

begin_include
include|#
directive|include
file|<sys/user.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_page.h>
end_include

begin_include
include|#
directive|include
file|<machine/psl.h>
end_include

begin_include
include|#
directive|include
file|<machine/reg.h>
end_include

begin_comment
comment|/*  * Priority for tracing  */
end_comment

begin_define
define|#
directive|define
name|IPCPRI
value|PZERO
end_define

begin_comment
comment|/*  * Tracing variables.  * Used to pass trace command from  * parent to child being traced.  * This data base cannot be  * shared and is locked  * per user.  */
end_comment

begin_struct
struct|struct
block|{
name|int
name|ip_lock
decl_stmt|;
name|int
name|ip_req
decl_stmt|;
name|int
name|ip_error
decl_stmt|;
union|union
block|{
name|char
name|un_any
index|[
literal|4
index|]
decl_stmt|;
struct|struct
block|{
name|int
name|wd_data
decl_stmt|;
name|caddr_t
name|wd_addr
decl_stmt|;
block|}
name|un_wd
struct|;
name|struct
name|trapframe
name|un_tf
decl_stmt|;
name|struct
name|fpstate
name|un_f
decl_stmt|;
block|}
name|ip_un
union|;
block|}
name|ipc
struct|;
end_struct

begin_define
define|#
directive|define
name|ip_any
value|ip_un.un_any
end_define

begin_define
define|#
directive|define
name|ip_data
value|ip_un.un_wd.wd_data
end_define

begin_define
define|#
directive|define
name|ip_addr
value|ip_un.un_wd.wd_addr
end_define

begin_define
define|#
directive|define
name|ip_tf
value|ip_un.un_tf
end_define

begin_define
define|#
directive|define
name|ip_f
value|ip_un.un_f
end_define

begin_comment
comment|/*  * Process debugging system call.  */
end_comment

begin_struct
struct|struct
name|ptrace_args
block|{
name|int
name|req
decl_stmt|;
name|int
name|pid
decl_stmt|;
name|caddr_t
name|addr
decl_stmt|;
name|int
name|data
decl_stmt|;
block|}
struct|;
end_struct

begin_macro
name|ptrace
argument_list|(
argument|curp
argument_list|,
argument|uap
argument_list|,
argument|retval
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|proc
modifier|*
name|curp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|struct
name|ptrace_args
modifier|*
name|uap
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
modifier|*
name|retval
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
specifier|register
enum|enum
block|{
name|t_oneword
block|,
name|t_regin
block|,
name|t_regout
block|}
name|type
enum|;
specifier|register
name|size_t
name|size
decl_stmt|;
specifier|register
name|int
name|error
decl_stmt|;
if|if
condition|(
name|uap
operator|->
name|req
operator|==
name|PT_TRACE_ME
condition|)
block|{
name|curp
operator|->
name|p_flag
operator||=
name|STRC
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|p
operator|=
name|pfind
argument_list|(
name|uap
operator|->
name|pid
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|ESRCH
operator|)
return|;
switch|switch
condition|(
name|uap
operator|->
name|req
condition|)
block|{
case|case
name|PT_READ_I
case|:
case|case
name|PT_READ_D
case|:
case|case
name|PT_WRITE_I
case|:
case|case
name|PT_WRITE_D
case|:
case|case
name|PT_CONTINUE
case|:
case|case
name|PT_KILL
case|:
case|case
name|PT_DETACH
case|:
name|type
operator|=
name|t_oneword
expr_stmt|;
name|size
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|PT_ATTACH
case|:
comment|/* 		 * Must be root if the process has used set user or group 		 * privileges or does not belong to the real user.  Must 		 * not be already traced.  Can't attach to ourselves. 		 */
if|if
condition|(
operator|(
name|p
operator|->
name|p_flag
operator|&
name|SUGID
operator|||
name|p
operator|->
name|p_cred
operator|->
name|p_ruid
operator|!=
name|curp
operator|->
name|p_cred
operator|->
name|p_ruid
operator|)
operator|&&
operator|(
name|error
operator|=
name|suser
argument_list|(
name|p
operator|->
name|p_ucred
argument_list|,
operator|&
name|p
operator|->
name|p_acflag
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|p
operator|->
name|p_flag
operator|&
name|STRC
condition|)
return|return
operator|(
name|EALREADY
operator|)
return|;
comment|/* ??? */
if|if
condition|(
name|p
operator|==
name|curp
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* 		 * It would be nice if the tracing relationship was separate 		 * from the parent relationship but that would require 		 * another set of links in the proc struct or for "wait" 		 * to scan the entire proc table.  To make life easier, 		 * we just re-parent the process we're trying to trace. 		 * The old parent is remembered so we can put things back 		 * on a "detach". 		 */
name|p
operator|->
name|p_flag
operator||=
name|STRC
expr_stmt|;
name|p
operator|->
name|p_oppid
operator|=
name|p
operator|->
name|p_pptr
operator|->
name|p_pid
expr_stmt|;
name|proc_reparent
argument_list|(
name|p
argument_list|,
name|curp
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|p_stat
operator|==
name|SSTOP
condition|)
name|setrun
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/* long enough to stop */
name|psignal
argument_list|(
name|p
argument_list|,
name|SIGSTOP
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|PT_GETREGS
case|:
name|type
operator|=
name|t_regout
expr_stmt|;
name|size
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|trapframe
argument_list|)
expr_stmt|;
break|break;
case|case
name|PT_SETREGS
case|:
name|type
operator|=
name|t_regin
expr_stmt|;
name|size
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|trapframe
argument_list|)
expr_stmt|;
break|break;
case|case
name|PT_GETFPREGS
case|:
name|type
operator|=
name|t_regout
expr_stmt|;
name|size
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|fpstate
argument_list|)
expr_stmt|;
break|break;
case|case
name|PT_SETFPREGS
case|:
name|type
operator|=
name|t_regin
expr_stmt|;
name|size
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|fpstate
argument_list|)
expr_stmt|;
break|break;
default|default:
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
name|p
operator|->
name|p_stat
operator|!=
name|SSTOP
operator|||
name|p
operator|->
name|p_pptr
operator|!=
name|curp
operator|||
operator|!
operator|(
name|p
operator|->
name|p_flag
operator|&
name|STRC
operator|)
condition|)
return|return
operator|(
name|ESRCH
operator|)
return|;
while|while
condition|(
name|ipc
operator|.
name|ip_lock
condition|)
name|sleep
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|ipc
argument_list|,
name|IPCPRI
argument_list|)
expr_stmt|;
name|ipc
operator|.
name|ip_lock
operator|=
name|p
operator|->
name|p_pid
expr_stmt|;
name|ipc
operator|.
name|ip_req
operator|=
name|uap
operator|->
name|req
expr_stmt|;
name|ipc
operator|.
name|ip_error
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|t_oneword
case|:
name|ipc
operator|.
name|ip_addr
operator|=
name|uap
operator|->
name|addr
expr_stmt|;
name|ipc
operator|.
name|ip_data
operator|=
name|uap
operator|->
name|data
expr_stmt|;
break|break;
case|case
name|t_regin
case|:
if|if
condition|(
operator|(
name|error
operator|=
name|copyin
argument_list|(
name|uap
operator|->
name|addr
argument_list|,
name|ipc
operator|.
name|ip_any
argument_list|,
name|size
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
break|break;
case|case
name|t_regout
case|:
break|break;
default|default:
name|panic
argument_list|(
literal|"ptrace"
argument_list|)
expr_stmt|;
block|}
name|p
operator|->
name|p_flag
operator|&=
operator|~
name|SWTED
expr_stmt|;
do|do
block|{
if|if
condition|(
name|p
operator|->
name|p_stat
operator|==
name|SSTOP
condition|)
name|setrun
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|sleep
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|ipc
argument_list|,
name|IPCPRI
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|ipc
operator|.
name|ip_req
operator|>
literal|0
condition|)
do|;
if|if
condition|(
operator|(
name|error
operator|=
name|ipc
operator|.
name|ip_error
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|type
operator|==
name|t_oneword
condition|)
operator|*
name|retval
operator|=
name|ipc
operator|.
name|ip_data
expr_stmt|;
elseif|else
if|if
condition|(
name|type
operator|==
name|t_regout
condition|)
name|error
operator|=
name|copyout
argument_list|(
name|ipc
operator|.
name|ip_any
argument_list|,
name|uap
operator|->
name|addr
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
name|ipc
operator|.
name|ip_lock
operator|=
literal|0
expr_stmt|;
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|ipc
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Write text space by unprotecting, writing, and reprotecting.  */
end_comment

begin_function
specifier|static
name|int
name|writetext
parameter_list|(
name|p
parameter_list|,
name|addr
parameter_list|,
name|data
parameter_list|,
name|len
parameter_list|)
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|caddr_t
name|addr
decl_stmt|,
name|data
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
name|vm_offset_t
name|sa
decl_stmt|,
name|ea
decl_stmt|;
name|vm_map_t
name|map
decl_stmt|;
name|int
name|error
decl_stmt|;
name|map
operator|=
operator|&
name|p
operator|->
name|p_vmspace
operator|->
name|vm_map
expr_stmt|;
name|sa
operator|=
name|trunc_page
argument_list|(
operator|(
name|vm_offset_t
operator|)
name|addr
argument_list|)
expr_stmt|;
name|ea
operator|=
name|round_page
argument_list|(
operator|(
name|vm_offset_t
operator|)
name|addr
operator|+
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|vm_map_protect
argument_list|(
name|map
argument_list|,
name|sa
argument_list|,
name|ea
argument_list|,
name|VM_PROT_DEFAULT
argument_list|,
literal|0
argument_list|)
operator|!=
name|KERN_SUCCESS
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|error
operator|=
name|copyout
argument_list|(
name|data
argument_list|,
name|addr
argument_list|,
name|len
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|vm_map_protect
argument_list|(
name|map
argument_list|,
name|sa
argument_list|,
name|ea
argument_list|,
name|VM_PROT_READ
operator||
name|VM_PROT_EXECUTE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Transmit a tracing request from the parent to the child process  * being debugged.  This code runs in the context of the child process  * to fulfill the command requested by the parent.  */
end_comment

begin_expr_stmt
name|procxmt
argument_list|(
name|p
argument_list|)
specifier|register
expr|struct
name|proc
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|req
decl_stmt|,
name|error
decl_stmt|,
name|sig
decl_stmt|,
name|pc
decl_stmt|,
name|psr
decl_stmt|;
specifier|register
name|caddr_t
name|addr
decl_stmt|;
specifier|register
name|struct
name|trapframe
modifier|*
name|tf
decl_stmt|,
modifier|*
name|utf
decl_stmt|;
specifier|register
name|struct
name|fpstate
modifier|*
name|fs
decl_stmt|,
modifier|*
name|oldfs
decl_stmt|;
specifier|extern
name|struct
name|fpstate
name|initfpstate
decl_stmt|;
if|if
condition|(
name|ipc
operator|.
name|ip_lock
operator|!=
name|p
operator|->
name|p_pid
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|p
operator|->
name|p_slptime
operator|=
literal|0
expr_stmt|;
name|req
operator|=
name|ipc
operator|.
name|ip_req
expr_stmt|;
name|ipc
operator|.
name|ip_req
operator|=
literal|0
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|req
condition|)
block|{
case|case
name|PT_READ_I
case|:
comment|/* read the child's text space */
case|case
name|PT_READ_D
case|:
comment|/* read the child's data space */
name|write_user_windows
argument_list|()
expr_stmt|;
operator|(
name|void
operator|)
name|rwindow_save
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/* ignore unwritable windows */
name|error
operator|=
name|copyin
argument_list|(
name|ipc
operator|.
name|ip_addr
argument_list|,
name|ipc
operator|.
name|ip_any
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|PT_WRITE_I
case|:
comment|/* write the child's text space */
case|case
name|PT_WRITE_D
case|:
comment|/* write the child's data space */
name|addr
operator|=
name|ipc
operator|.
name|ip_addr
expr_stmt|;
name|write_user_windows
argument_list|()
expr_stmt|;
operator|(
name|void
operator|)
name|rwindow_save
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|error
operator|=
name|copyout
argument_list|(
name|ipc
operator|.
name|ip_any
argument_list|,
name|addr
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|&&
name|req
operator|==
name|PT_WRITE_I
condition|)
name|error
operator|=
name|writetext
argument_list|(
name|p
argument_list|,
name|addr
argument_list|,
name|ipc
operator|.
name|ip_any
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|PT_CONTINUE
case|:
comment|/* continue the child */
name|sig
operator|=
name|ipc
operator|.
name|ip_data
expr_stmt|;
if|if
condition|(
operator|(
name|unsigned
operator|)
name|sig
operator|>=
name|NSIG
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|pc
operator|=
operator|(
name|int
operator|)
name|ipc
operator|.
name|ip_addr
expr_stmt|;
if|if
condition|(
name|pc
operator|&
literal|3
condition|)
block|{
if|if
condition|(
name|pc
operator|!=
literal|1
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
name|tf
operator|=
name|p
operator|->
name|p_md
operator|.
name|md_tf
expr_stmt|;
name|tf
operator|->
name|tf_pc
operator|=
name|pc
expr_stmt|;
name|tf
operator|->
name|tf_npc
operator|=
name|pc
operator|+
literal|4
expr_stmt|;
block|}
name|p
operator|->
name|p_xstat
operator|=
name|sig
expr_stmt|;
comment|/* see issig */
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|ipc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
case|case
name|PT_KILL
case|:
comment|/* kill the child process */
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|ipc
argument_list|)
expr_stmt|;
name|exit1
argument_list|(
name|p
argument_list|,
operator|(
name|int
operator|)
name|p
operator|->
name|p_xstat
argument_list|)
expr_stmt|;
case|case
name|PT_DETACH
case|:
comment|/* stop tracing the child */
name|sig
operator|=
name|ipc
operator|.
name|ip_data
expr_stmt|;
if|if
condition|(
operator|(
name|unsigned
operator|)
name|sig
operator|>=
name|NSIG
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|pc
operator|=
operator|(
name|int
operator|)
name|ipc
operator|.
name|ip_addr
expr_stmt|;
if|if
condition|(
name|pc
operator|&
literal|3
condition|)
block|{
if|if
condition|(
name|pc
operator|!=
literal|1
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
name|tf
operator|=
name|p
operator|->
name|p_md
operator|.
name|md_tf
expr_stmt|;
name|tf
operator|->
name|tf_pc
operator|=
name|pc
expr_stmt|;
name|tf
operator|->
name|tf_npc
operator|=
name|pc
operator|+
literal|4
expr_stmt|;
block|}
name|p
operator|->
name|p_xstat
operator|=
name|sig
expr_stmt|;
comment|/* see issig */
name|p
operator|->
name|p_flag
operator|&=
operator|~
name|STRC
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|p_oppid
operator|!=
name|p
operator|->
name|p_pptr
operator|->
name|p_pid
condition|)
block|{
specifier|register
name|struct
name|proc
modifier|*
name|pp
init|=
name|pfind
argument_list|(
name|p
operator|->
name|p_oppid
argument_list|)
decl_stmt|;
if|if
condition|(
name|pp
condition|)
name|proc_reparent
argument_list|(
name|p
argument_list|,
name|pp
argument_list|)
expr_stmt|;
block|}
name|p
operator|->
name|p_oppid
operator|=
literal|0
expr_stmt|;
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|ipc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
case|case
name|PT_GETREGS
case|:
name|copywords
argument_list|(
operator|(
name|caddr_t
operator|)
name|p
operator|->
name|p_md
operator|.
name|md_tf
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|ipc
operator|.
name|ip_tf
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|trapframe
argument_list|)
argument_list|)
expr_stmt|;
name|ipc
operator|.
name|ip_tf
operator|.
name|tf_global
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
comment|/* XXX */
break|break;
case|case
name|PT_SETREGS
case|:
name|tf
operator|=
name|p
operator|->
name|p_md
operator|.
name|md_tf
expr_stmt|;
name|utf
operator|=
operator|&
name|ipc
operator|.
name|ip_tf
expr_stmt|;
if|if
condition|(
operator|(
name|utf
operator|->
name|tf_pc
operator||
name|utf
operator|->
name|tf_npc
operator|)
operator|&
literal|3
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|psr
operator|=
operator|(
name|tf
operator|->
name|tf_psr
operator|&
operator|~
name|PSR_ICC
operator|)
operator||
operator|(
name|utf
operator|->
name|tf_psr
operator|&
name|PSR_ICC
operator|)
expr_stmt|;
name|copywords
argument_list|(
operator|(
name|caddr_t
operator|)
name|utf
argument_list|,
operator|(
name|caddr_t
operator|)
name|tf
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|tf
argument_list|)
argument_list|)
expr_stmt|;
name|tf
operator|->
name|tf_psr
operator|=
name|psr
expr_stmt|;
break|break;
case|case
name|PT_GETFPREGS
case|:
if|if
condition|(
operator|(
name|fs
operator|=
name|p
operator|->
name|p_md
operator|.
name|md_fpstate
operator|)
operator|==
name|NULL
condition|)
name|fs
operator|=
operator|&
name|initfpstate
expr_stmt|;
elseif|else
if|if
condition|(
name|p
operator|==
name|fpproc
condition|)
name|savefpstate
argument_list|(
name|fs
argument_list|)
expr_stmt|;
name|copywords
argument_list|(
operator|(
name|caddr_t
operator|)
name|fs
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|ipc
operator|.
name|ip_f
argument_list|,
sizeof|sizeof
expr|*
name|fs
argument_list|)
expr_stmt|;
break|break;
case|case
name|PT_SETFPREGS
case|:
name|fs
operator|=
operator|&
name|ipc
operator|.
name|ip_f
expr_stmt|;
if|if
condition|(
operator|(
name|fs
operator|->
name|fs_fsr
operator|&
name|FSR_MBZ
operator|)
operator|!=
literal|0
operator|||
name|fs
operator|->
name|fs_qsize
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|oldfs
operator|=
name|p
operator|->
name|p_md
operator|.
name|md_fpstate
expr_stmt|;
if|if
condition|(
name|oldfs
operator|==
name|NULL
condition|)
name|p
operator|->
name|p_md
operator|.
name|md_fpstate
operator|=
name|oldfs
operator|=
name|malloc
argument_list|(
sizeof|sizeof
expr|*
name|oldfs
argument_list|,
name|M_SUBPROC
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|p
operator|==
name|fpproc
condition|)
block|{
name|savefpstate
argument_list|(
name|oldfs
argument_list|)
expr_stmt|;
name|fpproc
operator|=
name|NULL
expr_stmt|;
name|p
operator|->
name|p_md
operator|.
name|md_tf
operator|->
name|tf_psr
operator|&=
operator|~
name|PSR_EF
expr_stmt|;
block|}
name|copywords
argument_list|(
operator|(
name|caddr_t
operator|)
name|fs
argument_list|,
operator|(
name|caddr_t
operator|)
name|oldfs
argument_list|,
sizeof|sizeof
expr|*
name|oldfs
argument_list|)
expr_stmt|;
break|break;
default|default:
name|panic
argument_list|(
literal|"procxmt"
argument_list|)
expr_stmt|;
block|}
name|ipc
operator|.
name|ip_error
operator|=
name|error
expr_stmt|;
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|ipc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

end_unit

