begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1992, 1993  *	The Regents of the University of California.  All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * Sony Corp. and Kazumasa Utashiro of Software Research Associates, Inc.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by the University of  *	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * from: $Hdr: sd.c,v 4.300 91/06/27 20:42:56 root Rel41 $ SONY  *  *	@(#)sd.c	8.1 (Berkeley) 6/11/93  */
end_comment

begin_define
define|#
directive|define
name|dkblock
parameter_list|(
name|bp
parameter_list|)
value|bp->b_blkno
end_define

begin_comment
comment|/*  * Copyright (c) 1987-1991 by SONY Corporation.  */
end_comment

begin_include
include|#
directive|include
file|"sd.h"
end_include

begin_if
if|#
directive|if
name|NSD
operator|>
literal|0
end_if

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/buf.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/user.h>
end_include

begin_include
include|#
directive|include
file|<sys/dkstat.h>
end_include

begin_include
include|#
directive|include
file|<sys/uio.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/reboot.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/mtio.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/disklabel.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<sys/syslog.h>
end_include

begin_include
include|#
directive|include
file|<ufs/ffs/fs.h>
end_include

begin_include
include|#
directive|include
file|<machine/cpu.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|IPC_MRX
end_ifdef

begin_include
include|#
directive|include
file|"../iop/iopvar.h"
end_include

begin_include
include|#
directive|include
file|"../ipc/newsipc.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|CPU_SINGLE
end_ifdef

begin_include
include|#
directive|include
file|<news3400/hbdev/hbvar.h>
end_include

begin_include
include|#
directive|include
file|<news3400/iodev/ioptohb.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<news3400/iodev/scsireg.h>
end_include

begin_include
include|#
directive|include
file|<news3400/iodev/scu.h>
end_include

begin_include
include|#
directive|include
file|<news3400/iodev/dkio.h>
end_include

begin_include
include|#
directive|include
file|<news3400/iodev/sdreg.h>
end_include

begin_define
define|#
directive|define
name|sce_sdecode
value|sce_hdecode
end_define

begin_define
define|#
directive|define
name|dev2unit
parameter_list|(
name|x
parameter_list|)
value|((minor(x)& ~0x80)>> 3)
end_define

begin_define
define|#
directive|define
name|dev2part
parameter_list|(
name|x
parameter_list|)
value|(minor(x)& 0x7)
end_define

begin_comment
comment|/* /sys/sys/file.h */
end_comment

begin_define
define|#
directive|define
name|FREAD
value|00001
end_define

begin_comment
comment|/* descriptor read/receive'able */
end_comment

begin_define
define|#
directive|define
name|FWRITE
value|00002
end_define

begin_comment
comment|/* descriptor write/send'able */
end_comment

begin_define
define|#
directive|define
name|PART_A
value|0
end_define

begin_define
define|#
directive|define
name|PART_B
value|1
end_define

begin_define
define|#
directive|define
name|PART_C
value|2
end_define

begin_define
define|#
directive|define
name|PART_D
value|3
end_define

begin_define
define|#
directive|define
name|PART_E
value|4
end_define

begin_define
define|#
directive|define
name|PART_F
value|5
end_define

begin_define
define|#
directive|define
name|PART_G
value|6
end_define

begin_define
define|#
directive|define
name|PART_H
value|7
end_define

begin_define
define|#
directive|define
name|MAXPROBERETRY
value|100
end_define

begin_define
define|#
directive|define
name|NRETRY
value|10
end_define

begin_define
define|#
directive|define
name|MAXHRDERR
value|100
end_define

begin_define
define|#
directive|define
name|MAXRETRYCNT
value|16
end_define

begin_define
define|#
directive|define
name|SDBSIZE1K
value|(DEV_BSIZE * 2)
end_define

begin_define
define|#
directive|define
name|MAXSDPHYS
value|((NSCMAP - 1) * NBPG)
end_define

begin_define
define|#
directive|define
name|D100MSEC
value|100000
end_define

begin_if
if|#
directive|if
name|OD_STOPTIME
operator|<
literal|1
end_if

begin_define
define|#
directive|define
name|OD_STOPTIME
value|5
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* OD_STOPTIME< 1 */
end_comment

begin_define
define|#
directive|define
name|FORMAT_MODE_CORRUPTED
value|0x31
end_define

begin_define
define|#
directive|define
name|ONLY_ONE
value|1
end_define

begin_comment
comment|/************** PARTITIONS *************************************/
end_comment

begin_define
define|#
directive|define
name|PART_UNUSED
value|(0)
end_define

begin_define
define|#
directive|define
name|PART_SPEC
value|(-1)
end_define

begin_define
define|#
directive|define
name|PART_CALCF
value|(-2)
end_define

begin_define
define|#
directive|define
name|PART_CALCG
value|(-3)
end_define

begin_struct
struct|struct
name|defpart
block|{
name|int
name|range_min
decl_stmt|;
name|int
name|range_max
decl_stmt|;
name|int
name|partsize
index|[
name|PNUM
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
name|struct
name|defpart
name|defpart_std
index|[]
init|=
block|{
block|{
literal|0
block|,
comment|/* range_min */
literal|20
block|,
comment|/* range_max */
name|PART_SPEC
block|,
comment|/* A: */
name|PART_UNUSED
block|,
comment|/* B: */
name|PART_SPEC
block|,
comment|/* C: */
name|PART_UNUSED
block|,
comment|/* D: */
name|PART_UNUSED
block|,
comment|/* E: */
name|PART_UNUSED
block|,
comment|/* F: */
name|PART_UNUSED
block|,
comment|/* G: */
name|PART_UNUSED
block|,
comment|/* H: */
block|}
block|,
block|{
literal|20
block|,
comment|/* range_min */
literal|61
block|,
comment|/* range_max */
literal|15884
block|,
comment|/* A: */
literal|10032
block|,
comment|/* B: */
name|PART_SPEC
block|,
comment|/* C: */
literal|15884
block|,
comment|/* D: */
name|PART_UNUSED
block|,
comment|/* E: */
name|PART_CALCF
block|,
comment|/* F: */
name|PART_CALCG
block|,
comment|/* G: */
name|PART_UNUSED
block|,
comment|/* H: */
block|}
block|,
block|{
literal|61
block|,
comment|/* range_min */
literal|206
block|,
comment|/* range_max */
literal|15884
block|,
comment|/* A: */
literal|33440
block|,
comment|/* B: */
name|PART_SPEC
block|,
comment|/* C: */
literal|15884
block|,
comment|/* D: */
literal|55936
block|,
comment|/* E: */
name|PART_CALCF
block|,
comment|/* F: */
name|PART_CALCG
block|,
comment|/* G: */
name|PART_UNUSED
block|,
comment|/* H: */
block|}
block|,
block|{
literal|206
block|,
comment|/* range_min */
literal|356
block|,
comment|/* range_max */
literal|15884
block|,
comment|/* A: */
literal|33440
block|,
comment|/* B: */
name|PART_SPEC
block|,
comment|/* C: */
literal|15884
block|,
comment|/* D: */
literal|55936
block|,
comment|/* E: */
name|PART_CALCF
block|,
comment|/* F: */
name|PART_CALCG
block|,
comment|/* G: */
literal|291346
block|,
comment|/* H: */
block|}
block|,
block|{
literal|356
block|,
comment|/* range_min */
literal|99999999
block|,
comment|/* range_max */
literal|15884
block|,
comment|/* A: */
literal|66880
block|,
comment|/* B: */
name|PART_SPEC
block|,
comment|/* C: */
literal|15884
block|,
comment|/* D: */
literal|307200
block|,
comment|/* E: */
name|PART_CALCF
block|,
comment|/* F: */
name|PART_CALCG
block|,
comment|/* G: */
literal|291346
block|,
comment|/* H: */
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/************* ADDITIONAL SENSE ERROR CODES *************************/
end_comment

begin_struct
struct|struct
name|msg_list
block|{
name|int
name|ml_code
decl_stmt|;
comment|/* message code */
name|int
name|ml_msglvl
decl_stmt|;
comment|/* message level */
name|char
modifier|*
name|ml_msgstr
decl_stmt|;
comment|/* message string */
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|sdskeylist
value|skeylist
end_define

begin_decl_stmt
name|struct
name|msg_list
name|ecodelist_mo
index|[]
init|=
block|{
block|{
literal|0x80
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
literal|0x81
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
literal|0x82
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
literal|0x83
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
operator|-
literal|1
block|,
literal|0
block|,
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/************** Ref. sd_var.c ********************************/
end_comment

begin_decl_stmt
specifier|extern
name|struct
name|iop
comment|/**/
name|_ctlr
modifier|*
name|sdminfo
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|iop
comment|/**/
name|_device
modifier|*
name|sddinfo
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|iop
comment|/**/
name|_device
modifier|*
name|sdip
index|[]
index|[
name|MAXSLAVE
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|buf
name|rsdbuf
index|[]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* buffer for raw I/O */
end_comment

begin_decl_stmt
specifier|extern
name|struct
name|buf
name|csdbuf
index|[]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* buffer for controll */
end_comment

begin_decl_stmt
specifier|extern
name|struct
name|buf
name|sdutab
index|[]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* per drive buffers */
end_comment

begin_decl_stmt
specifier|extern
name|struct
name|sdc_softc
name|sdc_softc
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|sdd_softc
name|sdd_softc
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|u_char
name|sd_b_openf
index|[]
index|[
name|PNUM
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|u_char
name|sd_c_openf
index|[]
index|[
name|PNUM
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|scsi
name|kernscsi
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|sdst
name|sdstdrv
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|disklabel
name|sdlabel
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|size
name|sdsizedrv
index|[]
index|[
name|PNUM
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|u_char
name|sdc_rsense
index|[]
index|[
name|RSEN_CNT
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|sync_param
name|sd_sync_param
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|nsd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|nsdc
decl_stmt|;
end_decl_stmt

begin_comment
comment|/************** Ref. sddefs.c *********************************/
end_comment

begin_decl_stmt
specifier|extern
name|struct
name|sddevinfo
name|sddevinfo
index|[]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/**************************************************************/
end_comment

begin_decl_stmt
specifier|extern
name|struct
name|msg_list
name|skeylist
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|msg_list
name|ecodelist
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|boothowto
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|rsense_msg_disp
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* RSENSE-message display flag */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|mo_disp_format
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* MO format mode display flag */
end_comment

begin_decl_stmt
name|int
name|sd_ignore_error
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|re_init_done
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_char
name|sdwork
index|[
literal|2340
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* buffer for error recovery */
end_comment

begin_decl_stmt
specifier|static
name|u_char
name|sdtmp
index|[
name|DEV_BSIZE
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* buffer for temporary */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|mips
end_ifdef

begin_decl_stmt
specifier|volatile
specifier|static
name|int
name|sdtmp_stat
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* status of sdtmp */
end_comment

begin_else
else|#
directive|else
end_else

begin_decl_stmt
specifier|static
name|int
name|sdtmp_stat
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* status of sdtmp */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|char
name|pname
index|[]
init|=
literal|"abcdefgh"
decl_stmt|;
end_decl_stmt

begin_function_decl
name|struct
name|scsi
modifier|*
name|get_scsi
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|struct
name|sc_map
modifier|*
name|get_sc_map
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|struct
name|sc_inq
modifier|*
name|get_sc_inq
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|int
name|sdprobe
argument_list|()
decl_stmt|,
name|sdslave
argument_list|()
decl_stmt|,
name|sdattach
argument_list|()
decl_stmt|,
name|sddgo
argument_list|()
decl_stmt|,
name|sdintr
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|sdwstart
decl_stmt|,
name|sdwatch
argument_list|()
decl_stmt|,
name|sdstop
argument_list|()
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Have started guardian */
end_comment

begin_function_decl
name|void
name|sdexec
parameter_list|()
function_decl|;
end_function_decl

begin_expr_stmt
specifier|static
name|sd_check
argument_list|()
operator|,
name|sd_tstdrv
argument_list|()
operator|,
name|sd_other_pages
argument_list|()
operator|,
name|sd_err_rcv
argument_list|()
operator|,
name|sd_synctr_on
argument_list|()
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|disklabel2sdst
argument_list|()
operator|,
name|sdst2disklabel
argument_list|()
operator|,
name|sd_scu_exec
argument_list|()
expr_stmt|;
end_expr_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|CPU_SINGLE
end_ifdef

begin_decl_stmt
name|struct
name|hb_driver
name|sdcdriver
init|=
block|{
name|sdprobe
block|,
name|sdslave
block|,
name|sdattach
block|,
name|sddgo
block|,
name|sdintr
block|,
literal|"sd"
block|,
name|sddinfo
block|,
literal|"sdc"
block|,
name|sdminfo
block|}
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_decl_stmt
name|struct
name|iop_driver
name|sdcdriver
init|=
block|{
name|sdprobe
block|,
name|sdslave
block|,
name|sdattach
block|,
name|sddgo
block|,
literal|"sd"
block|,
name|sddinfo
block|,
literal|"sdc"
block|,
name|sdminfo
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_macro
name|sdprobe
argument_list|(
argument|im
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|iop
comment|/**/
name|_ctlr
modifier|*
name|im
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|static
name|int
name|sdd_init
init|=
literal|0
decl_stmt|;
specifier|register
name|struct
name|sc_inq
modifier|*
name|sci
decl_stmt|;
specifier|register
name|int
name|ctlr
decl_stmt|;
specifier|register
name|int
name|fw
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|sdd_init
operator|==
literal|0
condition|)
block|{
name|sdd_init
operator|++
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nsd
condition|;
name|i
operator|++
control|)
name|sdd_softc
index|[
name|i
index|]
operator|.
name|sdd_start
operator|=
operator|-
literal|2
expr_stmt|;
block|}
name|sci
operator|=
name|get_sc_inq
argument_list|(
name|im
operator|->
name|im_intr
argument_list|)
expr_stmt|;
name|ctlr
operator|=
name|im
operator|->
name|im_ctlr
expr_stmt|;
comment|/* 	 * Check device type 	 *	0x00: Direct access device. 	 *	0x01: Sequential access device. 	 *	0x04: Write-once read-multiple device. 	 *	0x05: Read-only Direct-access device. 	 *	0x7f: Specified device is nonexistent. 	 */
name|fw
operator|=
name|sdc_softc
index|[
name|ctlr
index|]
operator|.
name|sdc_firmware
operator|&
operator|~
name|SDCFW_DEVMASK
expr_stmt|;
switch|switch
condition|(
name|sci
operator|->
name|sci_devtype
condition|)
block|{
case|case
literal|0x00
case|:
comment|/* 		 * Assumed that the device is HD. 		 *	Later, distinguish MO from HD. 		 */
name|sdc_softc
index|[
name|ctlr
index|]
operator|.
name|sdc_firmware
operator|=
name|fw
operator||
name|SDCFW_HD
expr_stmt|;
break|break;
default|default:
comment|/* 		 * device type mis-match 		 */
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * Set interrupt handler routine 	 */
if|if
condition|(
name|set_inthandler
argument_list|(
name|im
argument_list|,
name|sdintr
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_expr_stmt
name|sdslave
argument_list|(
name|ii
argument_list|,
name|reg
argument_list|,
name|intr
argument_list|)
specifier|register
expr|struct
name|iop
comment|/**/
name|_device
operator|*
name|ii
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|caddr_t
name|reg
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|intr
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|scsi
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
name|get_scsi
argument_list|(
name|intr
argument_list|)
expr_stmt|;
name|sdip
index|[
name|ii
operator|->
name|ii_ctlr
index|]
index|[
name|ii
operator|->
name|ii_slave
index|]
operator|=
name|ii
expr_stmt|;
name|ii
operator|->
name|ii_intr
operator|=
name|intr
expr_stmt|;
comment|/* 	 * check what the device is. 	 */
if|if
condition|(
operator|(
name|ii
operator|->
name|ii_type
operator|=
name|sd_check
argument_list|(
name|ii
argument_list|,
name|sc
argument_list|)
operator|)
operator|<
literal|0
condition|)
goto|goto
name|bad_slave
goto|;
comment|/* 	 * set up ERROR RECOVERY PARAMETERS 	 */
if|if
condition|(
name|sd_err_rcv
argument_list|(
name|ii
argument_list|,
name|sc
argument_list|)
operator|<
literal|0
condition|)
goto|goto
name|bad_slave
goto|;
comment|/* 	 * set up OTHER PARAMETERS 	 */
if|if
condition|(
name|sd_other_pages
argument_list|(
name|ii
argument_list|,
name|sc
argument_list|)
operator|<
literal|0
condition|)
goto|goto
name|bad_slave
goto|;
comment|/* 	 * set up Synchronous Transfer 	 */
name|sd_synctr_on
argument_list|(
name|ii
argument_list|,
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
name|bad_slave
label|:
comment|/* 	 * no such slave 	 */
name|ii
operator|->
name|ii_intr
operator|=
operator|-
literal|1
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_expr_stmt
name|identity_check
argument_list|(
name|sci
argument_list|,
name|capacity
argument_list|,
name|unit
argument_list|)
specifier|register
expr|struct
name|sc_inq
operator|*
name|sci
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|capacity
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|unit
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|sddevinfo
modifier|*
name|sdi
decl_stmt|;
specifier|register
name|u_char
modifier|*
name|id_name
decl_stmt|;
specifier|register
name|int
name|index
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|int
name|id_pass
decl_stmt|;
name|id_name
operator|=
name|sci
operator|->
name|sci_vendid
expr_stmt|;
while|while
condition|(
operator|*
name|id_name
operator|==
literal|' '
condition|)
name|id_name
operator|++
expr_stmt|;
name|index
operator|=
name|UNKNOWN_DISK
expr_stmt|;
name|id_pass
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|sdi
operator|=
name|sddevinfo
init|;
name|sdi
operator|->
name|id_len
operator|>=
literal|0
condition|;
name|sdi
operator|++
control|)
block|{
comment|/* 		 * check vendor& product ID 		 */
if|if
condition|(
name|strncmp
argument_list|(
name|id_name
argument_list|,
name|sdi
operator|->
name|id_name
argument_list|,
name|sdi
operator|->
name|id_len
argument_list|)
operator|!=
literal|0
condition|)
continue|continue;
name|id_pass
operator|=
name|sdi
operator|-
name|sddevinfo
expr_stmt|;
comment|/* 		 * check revision 		 */
if|if
condition|(
name|strncmp
argument_list|(
name|sdi
operator|->
name|revs
argument_list|,
name|sci
operator|->
name|sci_revision
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
name|index
operator|=
name|id_pass
expr_stmt|;
else|else
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|*
operator|(
name|sdi
operator|->
name|revs
operator|+
name|i
operator|)
operator|==
literal|'?'
condition|)
continue|continue;
if|if
condition|(
operator|*
operator|(
name|sdi
operator|->
name|revs
operator|+
name|i
operator|)
operator|!=
name|sci
operator|->
name|sci_revision
index|[
name|i
index|]
condition|)
break|break;
block|}
if|if
condition|(
name|i
operator|<
literal|4
condition|)
continue|continue;
block|}
comment|/* 		 * check capacity 		 */
if|if
condition|(
name|capacity
operator|==
operator|-
literal|1
condition|)
break|break;
if|if
condition|(
name|sdi
operator|->
name|capacity
operator|==
operator|-
literal|1
condition|)
block|{
name|printf
argument_list|(
literal|"sd%d: capacity=0x%x(%d)\n"
argument_list|,
name|unit
argument_list|,
name|capacity
argument_list|,
name|capacity
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|capacity
operator|==
name|sdi
operator|->
name|capacity
condition|)
break|break;
block|}
if|if
condition|(
name|index
operator|==
literal|0
condition|)
name|index
operator|=
name|id_pass
expr_stmt|;
return|return
operator|(
name|index
operator|)
return|;
block|}
end_block

begin_expr_stmt
name|search_index
argument_list|(
name|type
argument_list|)
specifier|register
name|int
name|type
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|sddevinfo
modifier|*
name|sdi
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|int
name|index
decl_stmt|;
name|index
operator|=
name|UNKNOWN_DISK
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|sdi
operator|=
name|sddevinfo
init|;
name|sdi
operator|->
name|id_len
operator|>
literal|0
condition|;
name|sdi
operator|++
control|)
block|{
if|if
condition|(
name|sdi
operator|->
name|type
operator|==
name|type
condition|)
block|{
name|index
operator|=
name|i
expr_stmt|;
break|break;
block|}
name|i
operator|++
expr_stmt|;
block|}
return|return
operator|(
name|index
operator|)
return|;
block|}
end_block

begin_expr_stmt
specifier|static
name|sd_check
argument_list|(
name|ii
argument_list|,
name|sc
argument_list|)
specifier|register
expr|struct
name|iop
comment|/**/
name|_device
operator|*
name|ii
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|struct
name|scsi
modifier|*
name|sc
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|sc_inq
modifier|*
name|sci
decl_stmt|;
specifier|register
name|struct
name|sc_rcap
modifier|*
name|scr
decl_stmt|;
specifier|register
name|int
name|intr
decl_stmt|;
specifier|register
name|int
name|slave
decl_stmt|;
specifier|register
name|int
name|unit
decl_stmt|;
name|struct
name|sdc_softc
modifier|*
name|sdc
decl_stmt|;
name|struct
name|sdd_softc
modifier|*
name|sdd
decl_stmt|;
name|struct
name|sc_extnd
modifier|*
name|sce
decl_stmt|;
name|int
name|retrycnt
decl_stmt|;
name|int
name|index
decl_stmt|;
name|int
name|media_in
decl_stmt|;
name|intr
operator|=
name|ii
operator|->
name|ii_intr
expr_stmt|;
name|slave
operator|=
name|ii
operator|->
name|ii_slave
expr_stmt|;
name|unit
operator|=
name|ii
operator|->
name|ii_unit
expr_stmt|;
name|sdc
operator|=
operator|&
name|sdc_softc
index|[
name|ii
operator|->
name|ii_ctlr
index|]
expr_stmt|;
name|sdd
operator|=
operator|&
name|sdd_softc
index|[
name|unit
index|]
expr_stmt|;
name|scr
operator|=
operator|(
expr|struct
name|sc_rcap
operator|*
operator|)
name|sc
operator|->
name|sc_param
expr_stmt|;
name|sce
operator|=
operator|(
expr|struct
name|sc_extnd
operator|*
operator|)
operator|&
name|sdc_rsense
index|[
name|ii
operator|->
name|ii_ctlr
index|]
index|[
literal|0
index|]
expr_stmt|;
comment|/* 	 * check if the logical unit is ready. 	 *	(by TEST UNIT READY command) 	 */
name|media_in
operator|=
name|sd_tstdrv
argument_list|(
name|ii
argument_list|,
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|media_in
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|3
operator|)
return|;
comment|/* 	 * Get controller and drive information. 	 *	(by INQUIRY command) 	 */
name|retrycnt
operator|=
literal|0
expr_stmt|;
name|sci
operator|=
name|get_sc_inq
argument_list|(
name|intr
argument_list|)
expr_stmt|;
name|loop_inq
label|:
if|if
condition|(
name|retrycnt
operator|++
operator|>
name|MAXPROBERETRY
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|scop_inquiry
argument_list|(
name|intr
argument_list|,
name|sc
argument_list|,
name|slave
argument_list|,
name|SCSI_INTDIS
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sc_inq
argument_list|)
argument_list|,
name|sci
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_tstatus
operator|&=
name|TGSTMASK
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_istatus
operator|!=
name|INST_EP
operator|||
name|sc
operator|->
name|sc_tstatus
operator|!=
name|TGST_GOOD
condition|)
block|{
name|bzero
argument_list|(
operator|(
name|caddr_t
operator|)
name|sce
argument_list|,
name|RSEN_CNT
argument_list|)
expr_stmt|;
name|scop_rsense
argument_list|(
name|intr
argument_list|,
name|sc
argument_list|,
name|slave
argument_list|,
name|SCSI_INTDIS
argument_list|,
name|RSEN_CNT
argument_list|,
operator|(
name|caddr_t
operator|)
name|sce
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_tstatus
operator|&=
name|TGSTMASK
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_istatus
operator|!=
name|INST_EP
operator|||
name|sc
operator|->
name|sc_tstatus
operator|!=
name|TGST_GOOD
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|sce
operator|->
name|sce_extend
operator|!=
literal|0x70
condition|)
goto|goto
name|loop_inq
goto|;
switch|switch
condition|(
name|sce
operator|->
name|sce_sdecode
condition|)
block|{
case|case
literal|0x04
case|:
comment|/* Drive Not Ready */
case|case
literal|0x28
case|:
comment|/* Medium Changed */
case|case
literal|0x29
case|:
comment|/* Power On or Reset or Bus Device Reset */
case|case
literal|0x2a
case|:
comment|/* Mode Select Parameter Changed */
break|break;
default|default:
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|DELAY
argument_list|(
name|D100MSEC
argument_list|)
expr_stmt|;
comment|/* wait 100 ms. */
goto|goto
name|loop_inq
goto|;
block|}
name|index
operator|=
name|identity_check
argument_list|(
name|sci
argument_list|,
operator|-
literal|1
argument_list|,
name|unit
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|sddevinfo
index|[
name|index
index|]
operator|.
name|type
condition|)
block|{
case|case
name|SMO_S501
case|:
case|case
name|SMO_S501_ISO
case|:
case|case
name|SMO_S501_ISO2
case|:
name|sdc
operator|->
name|sdc_firmware
operator|=
name|SDCFW_MO
operator||
operator|(
name|sdc
operator|->
name|sdc_firmware
operator|&
operator|~
name|SDCFW_DEVMASK
operator|)
expr_stmt|;
break|break;
name|defaults
label|:
break|break;
block|}
if|if
condition|(
name|sci
operator|->
name|sci_qual
operator|&
literal|0x80
condition|)
block|{
comment|/* 		 * removable medium device 		 */
name|sdc
operator|->
name|sdc_firmware
operator||=
name|SDCFW_RMB
expr_stmt|;
if|if
condition|(
operator|(
name|media_in
operator|==
literal|0
operator|)
operator|||
operator|(
operator|(
name|sdc
operator|->
name|sdc_firmware
operator|&
name|SDCFW_MO
operator|)
operator|==
literal|0
operator|)
condition|)
return|return
operator|(
name|index
operator|)
return|;
block|}
comment|/****************/
comment|/* HD& MO only */
comment|/****************/
comment|/* 	 * Get drive capacity 	 *	(by READ CAPACITY command) 	 */
name|retrycnt
operator|=
literal|0
expr_stmt|;
name|loop_rcap
label|:
if|if
condition|(
name|retrycnt
operator|++
operator|>
name|MAXPROBERETRY
condition|)
return|return
operator|(
operator|-
literal|4
operator|)
return|;
name|scop_rcap
argument_list|(
name|intr
argument_list|,
name|sc
argument_list|,
name|slave
argument_list|,
name|SCSI_INTDIS
argument_list|,
literal|8
argument_list|,
operator|(
name|caddr_t
operator|)
literal|0
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_tstatus
operator|&=
name|TGSTMASK
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_istatus
operator|!=
name|INST_EP
condition|)
return|return
operator|(
operator|-
literal|5
operator|)
return|;
if|if
condition|(
name|sc
operator|->
name|sc_tstatus
operator|==
name|TGST_CC
condition|)
block|{
name|bzero
argument_list|(
operator|(
name|caddr_t
operator|)
name|sce
argument_list|,
name|RSEN_CNT
argument_list|)
expr_stmt|;
name|scop_rsense
argument_list|(
name|intr
argument_list|,
name|sc
argument_list|,
name|slave
argument_list|,
name|SCSI_INTDIS
argument_list|,
name|RSEN_CNT
argument_list|,
operator|(
name|caddr_t
operator|)
name|sce
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_tstatus
operator|&=
name|TGSTMASK
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_istatus
operator|!=
name|INST_EP
operator|||
name|sc
operator|->
name|sc_tstatus
operator|!=
name|TGST_GOOD
condition|)
return|return
operator|(
operator|-
literal|6
operator|)
return|;
if|if
condition|(
name|sderrordisp
argument_list|(
operator|(
name|caddr_t
operator|)
name|sce
argument_list|,
name|ii
argument_list|)
operator|==
name|FORMAT_MODE_CORRUPTED
condition|)
block|{
name|scr
operator|->
name|scr_nblock
operator|=
literal|0
expr_stmt|;
name|scr
operator|->
name|scr_blocklen
operator|=
name|DEV_BSIZE
expr_stmt|;
name|sdd
operator|->
name|sdd_flags
operator||=
name|SDDF_NONFMT
expr_stmt|;
block|}
else|else
block|{
name|DELAY
argument_list|(
name|D100MSEC
argument_list|)
expr_stmt|;
comment|/* wait 100 ms. */
goto|goto
name|loop_rcap
goto|;
block|}
block|}
elseif|else
if|if
condition|(
name|sc
operator|->
name|sc_tstatus
operator|!=
name|TGST_GOOD
condition|)
block|{
name|DELAY
argument_list|(
name|D100MSEC
argument_list|)
expr_stmt|;
comment|/* wait 100 ms. */
goto|goto
name|loop_rcap
goto|;
block|}
name|sdd
operator|->
name|sdd_nsect
operator|=
name|scr
operator|->
name|scr_nblock
operator|+
literal|1
expr_stmt|;
name|sdd
operator|->
name|sdd_sectsize
operator|=
name|scr
operator|->
name|scr_blocklen
expr_stmt|;
name|index
operator|=
name|identity_check
argument_list|(
name|sci
argument_list|,
name|scr
operator|->
name|scr_nblock
operator|+
literal|1
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return
operator|(
name|index
operator|)
return|;
block|}
end_block

begin_expr_stmt
specifier|static
name|sd_tstdrv
argument_list|(
name|ii
argument_list|,
name|sc
argument_list|)
specifier|register
expr|struct
name|iop
comment|/**/
name|_device
operator|*
name|ii
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|struct
name|scsi
modifier|*
name|sc
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|sc_extnd
modifier|*
name|sce
decl_stmt|;
specifier|register
name|int
name|intr
decl_stmt|;
specifier|register
name|int
name|slave
decl_stmt|;
specifier|register
name|int
name|retrycnt
decl_stmt|;
name|struct
name|sdc_softc
modifier|*
name|sdc
decl_stmt|;
name|struct
name|sdd_softc
modifier|*
name|sdd
decl_stmt|;
name|sdc
operator|=
operator|&
name|sdc_softc
index|[
name|ii
operator|->
name|ii_ctlr
index|]
expr_stmt|;
name|sdd
operator|=
operator|&
name|sdd_softc
index|[
name|ii
operator|->
name|ii_unit
index|]
expr_stmt|;
name|intr
operator|=
name|ii
operator|->
name|ii_intr
expr_stmt|;
name|slave
operator|=
name|ii
operator|->
name|ii_slave
expr_stmt|;
name|sce
operator|=
operator|(
expr|struct
name|sc_extnd
operator|*
operator|)
operator|&
name|sdc_rsense
index|[
name|ii
operator|->
name|ii_ctlr
index|]
index|[
literal|0
index|]
expr_stmt|;
name|retrycnt
operator|=
literal|0
expr_stmt|;
name|loop_tst
label|:
if|if
condition|(
name|retrycnt
operator|++
operator|>
name|MAXPROBERETRY
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|scop_tst
argument_list|(
name|intr
argument_list|,
name|sc
argument_list|,
name|slave
argument_list|,
name|SCSI_INTDIS
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_tstatus
operator|&=
name|TGSTMASK
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_istatus
operator|!=
name|INST_EP
condition|)
block|{
name|DELAY
argument_list|(
name|D100MSEC
argument_list|)
expr_stmt|;
comment|/* wait 100 ms. */
goto|goto
name|loop_tst
goto|;
block|}
switch|switch
condition|(
name|sc
operator|->
name|sc_tstatus
condition|)
block|{
case|case
name|TGST_CC
case|:
comment|/* Get error code */
name|bzero
argument_list|(
operator|(
name|caddr_t
operator|)
name|sce
argument_list|,
name|RSEN_CNT
argument_list|)
expr_stmt|;
name|scop_rsense
argument_list|(
name|intr
argument_list|,
name|sc
argument_list|,
name|slave
argument_list|,
name|SCSI_INTDIS
argument_list|,
name|RSEN_CNT
argument_list|,
operator|(
name|caddr_t
operator|)
name|sce
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_tstatus
operator|&=
name|TGSTMASK
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_istatus
operator|!=
name|INST_EP
operator|||
name|sc
operator|->
name|sc_tstatus
operator|!=
name|TGST_GOOD
condition|)
block|{
name|DELAY
argument_list|(
name|D100MSEC
argument_list|)
expr_stmt|;
comment|/* wait 100 ms. */
goto|goto
name|loop_tst
goto|;
block|}
if|if
condition|(
name|sce
operator|->
name|sce_extend
operator|!=
literal|0x70
condition|)
goto|goto
name|loop_tst
goto|;
switch|switch
condition|(
name|sce
operator|->
name|sce_skey
condition|)
block|{
case|case
literal|0x0
case|:
comment|/* No Sense */
case|case
literal|0x4
case|:
comment|/* Hardware error */
case|case
literal|0x6
case|:
comment|/* Unit attention */
goto|goto
name|loop_tst
goto|;
case|case
literal|0x2
case|:
comment|/* Not ready */
switch|switch
condition|(
name|sce
operator|->
name|sce_sdecode
condition|)
block|{
case|case
literal|0x04
case|:
comment|/* Not ready */
comment|/* 				 * Drive not ready... so start.. 				 */
name|scop_stst
argument_list|(
name|intr
argument_list|,
name|sc
argument_list|,
name|slave
argument_list|,
name|SCSI_INTDIS
argument_list|,
name|SDSS_START
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
name|D100MSEC
operator|*
literal|10
argument_list|)
expr_stmt|;
comment|/* wait 1 sec. */
goto|goto
name|loop_tst
goto|;
case|case
literal|0x0a
case|:
comment|/* No Disk */
comment|/*MO*/
default|default:
name|DELAY
argument_list|(
name|D100MSEC
argument_list|)
expr_stmt|;
goto|goto
name|loop_tst
goto|;
block|}
break|break;
case|case
literal|0x03
case|:
if|if
condition|(
name|sce
operator|->
name|sce_sdecode
operator|==
name|FORMAT_MODE_CORRUPTED
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* ignore error */
comment|/* fall through */
default|default:
return|return
operator|(
operator|-
literal|2
operator|)
return|;
block|}
break|break;
case|case
name|TGST_BUSY
case|:
goto|goto
name|loop_tst
goto|;
case|case
name|TGST_GOOD
case|:
break|break;
default|default:
return|return
operator|(
operator|-
literal|3
operator|)
return|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_expr_stmt
specifier|static
name|sd_other_pages
argument_list|(
name|ii
argument_list|,
name|sc
argument_list|)
specifier|register
expr|struct
name|iop
comment|/**/
name|_device
operator|*
name|ii
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|struct
name|scsi
modifier|*
name|sc
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|sddevinfo
modifier|*
name|sdi
decl_stmt|;
name|char
modifier|*
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|page
decl_stmt|;
name|int
name|length
decl_stmt|;
name|int
name|retrycnt
decl_stmt|;
name|int
name|len
decl_stmt|;
name|sdi
operator|=
operator|&
name|sddevinfo
index|[
name|ii
operator|->
name|ii_type
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|p
operator|=
name|sdi
operator|->
name|other_pages
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 	 * set other parameters 	 */
while|while
condition|(
name|page
operator|=
operator|*
name|p
operator|++
condition|)
block|{
name|retrycnt
operator|=
literal|0
expr_stmt|;
name|loop_other_pages
label|:
name|bzero
argument_list|(
operator|(
name|caddr_t
operator|)
name|sdtmp
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|length
operator|=
operator|*
operator|(
name|page
operator|+
literal|1
operator|)
operator|+
literal|2
expr_stmt|;
name|bcopy
argument_list|(
name|page
argument_list|,
operator|&
name|sdtmp
index|[
literal|4
index|]
argument_list|,
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|retrycnt
operator|++
operator|>
name|MAXPROBERETRY
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|scop_mselect
argument_list|(
name|ii
operator|->
name|ii_intr
argument_list|,
name|sc
argument_list|,
name|ii
operator|->
name|ii_slave
argument_list|,
name|SCSI_INTDIS
argument_list|,
operator|(
name|SDM_PF
operator|<<
literal|24
operator|)
operator|+
name|length
operator|+
literal|4
argument_list|,
operator|(
name|caddr_t
operator|)
name|sdtmp
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_tstatus
operator|&=
name|TGSTMASK
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_istatus
operator|!=
name|INST_EP
operator|)
operator|||
operator|(
name|sc
operator|->
name|sc_tstatus
operator|!=
name|TGST_GOOD
operator|)
condition|)
block|{
name|struct
name|sc_extnd
modifier|*
name|sce
decl_stmt|;
name|sce
operator|=
operator|(
expr|struct
name|sc_extnd
operator|*
operator|)
operator|&
name|sdc_rsense
index|[
name|ii
operator|->
name|ii_ctlr
index|]
index|[
literal|0
index|]
expr_stmt|;
name|scop_rsense
argument_list|(
name|ii
operator|->
name|ii_intr
argument_list|,
name|sc
argument_list|,
name|ii
operator|->
name|ii_slave
argument_list|,
name|SCSI_INTDIS
argument_list|,
name|RSEN_CNT
argument_list|,
operator|(
name|caddr_t
operator|)
name|sce
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|sce
operator|->
name|sce_skey
condition|)
block|{
case|case
literal|0x00
case|:
case|case
literal|0x02
case|:
case|case
literal|0x04
case|:
case|case
literal|0x06
case|:
name|DELAY
argument_list|(
name|D100MSEC
argument_list|)
expr_stmt|;
comment|/* 100 ms. */
goto|goto
name|loop_other_pages
goto|;
default|default:
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
block|}
if|if
condition|(
name|sdi
operator|->
name|firm_flags
operator|&
name|FIRM_CACHE_ON
condition|)
name|sdc_softc
index|[
name|ii
operator|->
name|ii_ctlr
index|]
operator|.
name|sdc_firmware
operator||=
name|SDCFW_CACHE
expr_stmt|;
else|else
name|sdc_softc
index|[
name|ii
operator|->
name|ii_ctlr
index|]
operator|.
name|sdc_firmware
operator|&=
operator|~
name|SDCFW_CACHE
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_expr_stmt
specifier|static
name|sd_err_rcv
argument_list|(
name|ii
argument_list|,
name|sc
argument_list|)
specifier|register
expr|struct
name|iop
comment|/**/
name|_device
operator|*
name|ii
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|struct
name|scsi
modifier|*
name|sc
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|sdc_softc
modifier|*
name|sdc
decl_stmt|;
specifier|register
name|int
name|intr
decl_stmt|;
specifier|register
name|int
name|slave
decl_stmt|;
specifier|register
name|int
name|len
decl_stmt|;
name|struct
name|sc_extnd
modifier|*
name|sce
decl_stmt|;
name|struct
name|sdd_softc
modifier|*
name|sdd
decl_stmt|;
name|struct
name|sddevinfo
modifier|*
name|sdi
decl_stmt|;
name|int
name|retrycnt
decl_stmt|;
name|char
modifier|*
name|erp_page
decl_stmt|;
name|intr
operator|=
name|ii
operator|->
name|ii_intr
expr_stmt|;
name|slave
operator|=
name|ii
operator|->
name|ii_slave
expr_stmt|;
name|sdc
operator|=
operator|&
name|sdc_softc
index|[
name|ii
operator|->
name|ii_ctlr
index|]
expr_stmt|;
name|sdd
operator|=
operator|&
name|sdd_softc
index|[
name|ii
operator|->
name|ii_unit
index|]
expr_stmt|;
name|sdi
operator|=
operator|&
name|sddevinfo
index|[
name|ii
operator|->
name|ii_type
index|]
expr_stmt|;
name|sce
operator|=
operator|(
expr|struct
name|sc_extnd
operator|*
operator|)
operator|&
name|sdc_rsense
index|[
name|ii
operator|->
name|ii_ctlr
index|]
index|[
literal|0
index|]
expr_stmt|;
comment|/* 	 * set Default DISK sector size 	 */
if|if
condition|(
name|sdd
operator|->
name|sdd_sectsize
operator|==
literal|0
condition|)
name|sdd
operator|->
name|sdd_sectsize
operator|=
name|DEV_BSIZE
expr_stmt|;
if|if
condition|(
name|sdi
operator|->
name|ERP_page
operator|==
name|NULL
condition|)
block|{
comment|/* 		 * use default error recovery parameters 		 */
name|sdc
operator|->
name|sdc_firmware
operator||=
name|SDCFW_DEFMODE
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|sdi
operator|->
name|firm_flags
operator|&
name|FIRM_AWRE
condition|)
name|sdc
operator|->
name|sdc_firmware
operator||=
name|SDCFW_AWRE
expr_stmt|;
if|if
condition|(
name|sdi
operator|->
name|firm_flags
operator|&
name|FIRM_ARRE
condition|)
name|sdc
operator|->
name|sdc_firmware
operator||=
name|SDCFW_ARRE
expr_stmt|;
comment|/* 	 * set ERROR RECOVERY PARAMETERS 	 */
name|loop_err_rcv
label|:
name|bzero
argument_list|(
operator|(
name|caddr_t
operator|)
name|sdtmp
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|erp_page
operator|=
name|sdi
operator|->
name|ERP_page
expr_stmt|;
name|len
operator|=
operator|*
operator|(
name|erp_page
operator|+
literal|1
operator|)
operator|+
literal|2
expr_stmt|;
name|bcopy
argument_list|(
name|erp_page
argument_list|,
operator|&
name|sdtmp
index|[
literal|4
index|]
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|scop_mselect
argument_list|(
name|intr
argument_list|,
name|sc
argument_list|,
name|slave
argument_list|,
name|SCSI_INTDIS
argument_list|,
operator|(
name|SDM_PF
operator|<<
literal|24
operator|)
operator|+
name|len
operator|+
literal|4
argument_list|,
operator|(
name|caddr_t
operator|)
name|sdtmp
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_tstatus
operator|&=
name|TGSTMASK
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_istatus
operator|!=
name|INST_EP
operator|||
name|sc
operator|->
name|sc_tstatus
operator|!=
name|TGST_GOOD
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|sc_tstatus
operator|==
name|TGST_CC
condition|)
block|{
name|bzero
argument_list|(
operator|(
name|caddr_t
operator|)
name|sce
argument_list|,
name|RSEN_CNT
argument_list|)
expr_stmt|;
name|scop_rsense
argument_list|(
name|intr
argument_list|,
name|sc
argument_list|,
name|slave
argument_list|,
name|SCSI_INTDIS
argument_list|,
name|RSEN_CNT
argument_list|,
operator|(
name|caddr_t
operator|)
name|sce
argument_list|)
expr_stmt|;
if|if
condition|(
name|sce
operator|->
name|sce_sdecode
operator|==
literal|0x2a
condition|)
block|{
comment|/* mode select parameter changed */
goto|goto
name|ercv_done
goto|;
block|}
elseif|else
if|if
condition|(
name|sce
operator|->
name|sce_skey
operator|==
literal|0x6
condition|)
block|{
comment|/* unit attention */
goto|goto
name|loop_err_rcv
goto|;
block|}
block|}
comment|/* 		 * use default ERROR RECOVERY mode 		 */
name|sdc
operator|->
name|sdc_firmware
operator||=
name|SDCFW_DEFMODE
expr_stmt|;
name|sdc
operator|->
name|sdc_firmware
operator|&=
operator|~
operator|(
name|SDCFW_AWRE
operator||
name|SDCFW_ARRE
operator|)
expr_stmt|;
block|}
name|ercv_done
label|:
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_expr_stmt
specifier|static
name|sd_synctr_on
argument_list|(
name|ii
argument_list|,
name|sc
argument_list|)
specifier|register
expr|struct
name|iop
comment|/**/
name|_device
operator|*
name|ii
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|struct
name|scsi
modifier|*
name|sc
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|sddevinfo
modifier|*
name|sdi
decl_stmt|;
specifier|register
name|struct
name|sync_param
modifier|*
name|syncp
decl_stmt|;
name|sdi
operator|=
operator|&
name|sddevinfo
index|[
name|ii
operator|->
name|ii_type
index|]
expr_stmt|;
if|if
condition|(
name|sdi
operator|->
name|firm_flags
operator|&
name|FIRM_SYNCTR
condition|)
block|{
name|scinit
argument_list|(
name|sc
argument_list|,
name|ii
operator|->
name|ii_slave
argument_list|,
name|DEV_BSIZE
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_opcode
operator|=
name|SCOP_TST
expr_stmt|;
name|sc
operator|->
name|sc_message
operator|=
name|MSG_EXTND
expr_stmt|;
comment|/* extended message */
name|sc
operator|->
name|sc_param
index|[
literal|0
index|]
operator|=
name|MSG_EXTND
expr_stmt|;
name|sc
operator|->
name|sc_param
index|[
literal|1
index|]
operator|=
literal|0x03
expr_stmt|;
name|sc
operator|->
name|sc_param
index|[
literal|2
index|]
operator|=
literal|0x01
expr_stmt|;
comment|/* synchronous transfer */
name|sc
operator|->
name|sc_param
index|[
literal|3
index|]
operator|=
name|sdi
operator|->
name|tr_period
expr_stmt|;
comment|/* transfer period */
name|sc
operator|->
name|sc_param
index|[
literal|4
index|]
operator|=
name|sdi
operator|->
name|tr_offset
expr_stmt|;
comment|/* REQ offset */
if|if
condition|(
name|sdc_softc
index|[
name|ii
operator|->
name|ii_ctlr
index|]
operator|.
name|sdc_firmware
operator|&
name|SDCFW_CACHE
condition|)
name|sc
operator|->
name|sc_tstatus
operator||=
name|TS_CONTR_ON
expr_stmt|;
comment|/* contiguous TR ON */
else|else
name|sc
operator|->
name|sc_tstatus
operator||=
name|TS_CONTR_OFF
expr_stmt|;
comment|/* contiguous TR OFF */
ifdef|#
directive|ifdef
name|news1800
if|if
condition|(
name|scsi_berr_bug
argument_list|()
operator|!=
literal|0
condition|)
block|{
name|sc
operator|->
name|sc_tstatus
operator|&=
operator|~
name|TS_CONTR_ON
expr_stmt|;
name|sc
operator|->
name|sc_tstatus
operator||=
name|TS_CONTR_OFF
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|sc
operator|->
name|sc_tstatus
operator|&
name|TS_CONTR_OFF
condition|)
name|sdc_softc
index|[
name|ii
operator|->
name|ii_ctlr
index|]
operator|.
name|sdc_firmware
operator|&=
operator|~
name|SDCFW_CONTR
expr_stmt|;
else|else
name|sdc_softc
index|[
name|ii
operator|->
name|ii_ctlr
index|]
operator|.
name|sdc_firmware
operator||=
name|SDCFW_CONTR
expr_stmt|;
name|sc_go
argument_list|(
name|ii
operator|->
name|ii_intr
argument_list|,
name|sc
argument_list|,
name|SCSI_INTDIS
argument_list|)
expr_stmt|;
name|syncp
operator|=
operator|&
name|sd_sync_param
index|[
name|ii
operator|->
name|ii_unit
index|]
expr_stmt|;
name|syncp
operator|->
name|tr_period
operator|=
name|sc
operator|->
name|sc_param
index|[
literal|3
index|]
expr_stmt|;
name|syncp
operator|->
name|tr_offset
operator|=
name|sc
operator|->
name|sc_param
index|[
literal|4
index|]
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_param
index|[
literal|4
index|]
condition|)
name|sdd_softc
index|[
name|ii
operator|->
name|ii_unit
index|]
operator|.
name|sdd_flags
operator||=
name|SDDF_SYNCTR
expr_stmt|;
block|}
block|}
end_block

begin_expr_stmt
name|sdattach
argument_list|(
name|ii
argument_list|)
specifier|register
expr|struct
name|iop
comment|/**/
name|_device
operator|*
name|ii
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|unit
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|struct
name|sdc_softc
modifier|*
name|sdc
decl_stmt|;
name|struct
name|sdd_softc
modifier|*
name|sdd
decl_stmt|;
name|int
name|dummy
decl_stmt|;
name|sdc
operator|=
operator|&
name|sdc_softc
index|[
name|ii
operator|->
name|ii_ctlr
index|]
expr_stmt|;
name|sdc
operator|->
name|sdc_timeo
operator|=
literal|60
expr_stmt|;
comment|/* timeout 60 sec */
name|unit
operator|=
name|ii
operator|->
name|ii_unit
expr_stmt|;
name|sdd
operator|=
operator|&
name|sdd_softc
index|[
name|unit
index|]
expr_stmt|;
name|sdd
operator|->
name|sdd_stoptime
operator|=
name|OD_STOPTIME
expr_stmt|;
comment|/* REMOVABLE MEDIA */
name|sdd
operator|->
name|sdd_start
operator|=
operator|-
literal|2
expr_stmt|;
name|sdmaptype
argument_list|(
name|ii
argument_list|)
expr_stmt|;
if|if
condition|(
name|sdwstart
operator|==
literal|0
condition|)
block|{
name|sdwstart
operator|++
expr_stmt|;
name|timeout
argument_list|(
name|sdwatch
argument_list|,
operator|(
name|caddr_t
operator|)
literal|0
argument_list|,
name|hz
argument_list|)
expr_stmt|;
name|timeout
argument_list|(
name|sdstop
argument_list|,
operator|(
name|caddr_t
operator|)
literal|0
argument_list|,
name|hz
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * initialize open flag 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|PNUM
condition|;
name|i
operator|++
control|)
block|{
name|sd_b_openf
index|[
name|unit
index|]
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|sd_c_openf
index|[
name|unit
index|]
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|re_init_done
operator|>
literal|0
condition|)
return|return;
if|if
condition|(
name|sdc
operator|->
name|sdc_firmware
operator|&
name|SDCFW_HD
condition|)
block|{
comment|/* 		 * If device is Hard Disk, 		 *	then get partition information. 		 */
name|sdrpartinfo
argument_list|(
name|ii
argument_list|)
expr_stmt|;
name|dummy
operator|=
name|DEV_BSIZE
operator|*
name|sdstdrv
index|[
name|unit
index|]
operator|.
name|rps
operator|*
name|sdstdrv
index|[
name|unit
index|]
operator|.
name|nsect
expr_stmt|;
block|}
else|else
name|dummy
operator|=
name|DEV_BSIZE
operator|*
literal|40
operator|*
literal|31
expr_stmt|;
if|if
condition|(
name|ii
operator|->
name|ii_dk
operator|>=
literal|0
operator|&&
name|dummy
condition|)
name|dk_wpms
index|[
name|ii
operator|->
name|ii_dk
index|]
operator|=
name|dummy
operator|/
operator|(
literal|2
operator|*
literal|1000000
operator|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|sdmaptype
argument_list|(
name|ii
argument_list|)
specifier|register
expr|struct
name|iop
comment|/**/
name|_device
operator|*
name|ii
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|printf
argument_list|(
literal|"sd%d: %s\n"
argument_list|,
name|ii
operator|->
name|ii_unit
argument_list|,
name|sddevinfo
index|[
name|ii
operator|->
name|ii_type
index|]
operator|.
name|call_name
argument_list|)
expr_stmt|;
block|}
end_block

begin_decl_stmt
name|int
name|sd_b_major
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_macro
name|sd_b_open
argument_list|(
argument|dev
argument_list|,
argument|flag
argument_list|)
end_macro

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|flag
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|sd_b_major
operator|=
name|major
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
operator|(
name|_sdopen
argument_list|(
name|dev
argument_list|,
name|flag
argument_list|,
name|S_IFBLK
argument_list|)
operator|)
return|;
block|}
end_block

begin_decl_stmt
name|int
name|sd_c_major
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_macro
name|sd_c_open
argument_list|(
argument|dev
argument_list|,
argument|flag
argument_list|)
end_macro

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|flag
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|sd_c_major
operator|=
name|major
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
operator|(
name|_sdopen
argument_list|(
name|dev
argument_list|,
name|flag
argument_list|,
name|S_IFCHR
argument_list|)
operator|)
return|;
block|}
end_block

begin_expr_stmt
name|_sdopen
argument_list|(
name|dev
argument_list|,
name|flag
argument_list|,
name|fmt
argument_list|)
specifier|register
name|dev_t
name|dev
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|flag
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|fmt
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|iop
comment|/**/
name|_device
modifier|*
name|ii
decl_stmt|;
specifier|register
name|struct
name|sdd_softc
modifier|*
name|sdd
decl_stmt|;
specifier|register
name|struct
name|sdc_softc
modifier|*
name|sdc
decl_stmt|;
specifier|register
name|struct
name|sddevinfo
modifier|*
name|sdi
decl_stmt|;
specifier|register
name|int
name|unit
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|u_char
modifier|*
name|sdopfp
decl_stmt|;
name|u_char
name|old_sdopf
decl_stmt|;
name|int
name|media_changed
decl_stmt|;
name|int
name|s
decl_stmt|;
name|int
name|stat
decl_stmt|;
name|struct
name|scsi
name|uscsi
decl_stmt|;
name|unit
operator|=
name|dev2unit
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|unit
operator|>=
name|nsd
operator|||
operator|(
name|ii
operator|=
name|sddinfo
index|[
name|unit
index|]
operator|)
operator|==
literal|0
operator|||
name|ii
operator|->
name|ii_alive
operator|==
literal|0
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|sdd
operator|=
operator|&
name|sdd_softc
index|[
name|unit
index|]
expr_stmt|;
name|sdc
operator|=
operator|&
name|sdc_softc
index|[
name|ii
operator|->
name|ii_ctlr
index|]
expr_stmt|;
name|sdi
operator|=
operator|&
name|sddevinfo
index|[
name|ii
operator|->
name|ii_type
index|]
expr_stmt|;
if|if
condition|(
name|sdd
operator|->
name|sdd_flags
operator|&
name|SDDF_XUSE
condition|)
return|return
operator|(
name|EBUSY
operator|)
return|;
comment|/* 	 * LOCK while sdstop() running. 	 */
name|s
operator|=
name|splclock
argument_list|()
expr_stmt|;
while|while
condition|(
name|sdc
operator|->
name|sdc_state
operator|&
name|SDCS_SCUNLOCK
condition|)
block|{
name|sdc
operator|->
name|sdc_state
operator||=
name|SDCS_OPEN_WAIT
expr_stmt|;
name|sleep
argument_list|(
operator|(
name|caddr_t
operator|)
name|sdc
argument_list|,
name|PRIBIO
argument_list|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* 	 * LOCK sdtmp buffer 	 */
name|s
operator|=
name|splclock
argument_list|()
expr_stmt|;
while|while
condition|(
name|sdtmp_stat
operator|&
name|B_BUSY
condition|)
block|{
name|sdtmp_stat
operator||=
name|B_WANTED
expr_stmt|;
name|sleep
argument_list|(
operator|(
name|caddr_t
operator|)
name|sdtmp
argument_list|,
name|PRIBIO
argument_list|)
expr_stmt|;
block|}
name|sdtmp_stat
operator||=
name|B_BUSY
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|sdd
operator|->
name|sdd_flags
operator||=
name|SDDF_GETTMP
expr_stmt|;
if|if
condition|(
operator|(
name|fmt
operator|&
name|S_IFMT
operator|)
operator|==
name|S_IFBLK
condition|)
name|sdopfp
operator|=
operator|&
name|sd_b_openf
index|[
name|unit
index|]
index|[
name|dev2part
argument_list|(
name|dev
argument_list|)
index|]
expr_stmt|;
else|else
name|sdopfp
operator|=
operator|&
name|sd_c_openf
index|[
name|unit
index|]
index|[
name|dev2part
argument_list|(
name|dev
argument_list|)
index|]
expr_stmt|;
name|old_sdopf
operator|=
operator|*
name|sdopfp
expr_stmt|;
if|if
condition|(
name|old_sdopf
operator|<=
literal|1
condition|)
operator|*
name|sdopfp
operator|+=
literal|1
expr_stmt|;
comment|/* 1: 1st open (ONLY_ONE) */
comment|/* 2: already opened */
name|stat
operator|=
literal|0
expr_stmt|;
name|media_changed
operator|=
literal|0
expr_stmt|;
comment|/* 	 * From here on until pre_open_done is only for removable devices 	 */
if|if
condition|(
operator|(
name|sdc
operator|->
name|sdc_firmware
operator|&
name|SDCFW_RMB
operator|)
operator|==
literal|0
condition|)
goto|goto
name|pre_open_done
goto|;
if|if
condition|(
operator|(
name|minor
argument_list|(
name|dev
argument_list|)
operator|&
literal|0x80
operator|)
operator|||
operator|(
name|dev
operator|==
name|rootdev
operator|)
condition|)
name|sdd
operator|->
name|sdd_stoptime
operator|=
literal|0x7fffffff
expr_stmt|;
comment|/*XXX*/
comment|/* 	 * Start Unit 	 */
name|s
operator|=
name|splclock
argument_list|()
expr_stmt|;
comment|/* inhibit clock interrupt */
name|i
operator|=
name|sdd
operator|->
name|sdd_start
expr_stmt|;
name|sdd
operator|->
name|sdd_start
operator|=
name|sdd
operator|->
name|sdd_stoptime
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<=
literal|0
condition|)
block|{
name|scinit
argument_list|(
operator|&
name|uscsi
argument_list|,
name|ii
operator|->
name|ii_slave
argument_list|,
name|sdd
operator|->
name|sdd_sectsize
argument_list|)
expr_stmt|;
name|uscsi
operator|.
name|sc_opcode
operator|=
name|SCOP_STST
expr_stmt|;
name|uscsi
operator|.
name|sc_count
operator|=
name|SDSS_START
expr_stmt|;
if|if
condition|(
name|sdcmd
argument_list|(
name|dev
argument_list|,
operator|&
name|uscsi
argument_list|)
condition|)
block|{
name|sdd
operator|->
name|sdd_start
operator|=
name|i
expr_stmt|;
if|if
condition|(
operator|(
name|flag
operator|&
name|FWRITE
operator|)
operator|==
literal|0
condition|)
goto|goto
name|sdopen_setup
goto|;
name|stat
operator|=
name|EIO
expr_stmt|;
goto|goto
name|pre_open_done
goto|;
block|}
block|}
comment|/* 	 * prevent medium removal 	 */
name|scinit
argument_list|(
operator|&
name|uscsi
argument_list|,
name|ii
operator|->
name|ii_slave
argument_list|,
name|sdd
operator|->
name|sdd_sectsize
argument_list|)
expr_stmt|;
name|uscsi
operator|.
name|sc_opcode
operator|=
name|SCOP_MEDRMV
expr_stmt|;
name|uscsi
operator|.
name|sc_count
operator|=
name|SDRMV_PREV
expr_stmt|;
if|if
condition|(
name|sdcmd
argument_list|(
name|dev
argument_list|,
operator|&
name|uscsi
argument_list|)
condition|)
block|{
name|stat
operator|=
name|EIO
expr_stmt|;
goto|goto
name|pre_open_done
goto|;
block|}
name|sdd
operator|->
name|sdd_flags
operator||=
name|SDDF_INHRMV
expr_stmt|;
name|sdopen_setup
label|:
if|if
condition|(
operator|(
name|sdd
operator|->
name|sdd_flags
operator|&
name|SDDF_SAMEDSK
operator|)
operator|==
name|SDDF_DSKCHGD
condition|)
block|{
name|sdd
operator|->
name|sdd_flags
operator||=
name|SDDF_SAMEDSK
expr_stmt|;
name|media_changed
operator|=
literal|1
expr_stmt|;
comment|/* 		 * From here on until mo_check_done is only for MO device 		 */
if|if
condition|(
operator|(
name|sdc
operator|->
name|sdc_firmware
operator|&
name|SDCFW_MO
operator|)
operator|==
literal|0
condition|)
goto|goto
name|mo_check_done
goto|;
comment|/* 		 * Mode Sense 		 */
name|bzero
argument_list|(
name|sdtmp
argument_list|,
literal|36
argument_list|)
expr_stmt|;
name|scinit
argument_list|(
operator|&
name|uscsi
argument_list|,
name|ii
operator|->
name|ii_slave
argument_list|,
name|sdd
operator|->
name|sdd_sectsize
argument_list|)
expr_stmt|;
name|uscsi
operator|.
name|sc_cpoint
operator|=
name|sdtmp
expr_stmt|;
name|uscsi
operator|.
name|sc_ctrnscnt
operator|=
literal|36
expr_stmt|;
name|uscsi
operator|.
name|sc_opcode
operator|=
name|SCOP_MSENSE
expr_stmt|;
name|uscsi
operator|.
name|sc_lad
operator|=
operator|(
name|SDM_PF
operator|<<
literal|16
operator|)
operator||
operator|(
operator|(
name|SDM_PC_CUR
operator||
name|SDM_PCODE_ALL
operator|)
operator|<<
literal|8
operator|)
expr_stmt|;
name|uscsi
operator|.
name|sc_count
operator|=
literal|36
expr_stmt|;
if|if
condition|(
name|sdcmd
argument_list|(
name|dev
argument_list|,
operator|&
name|uscsi
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* 			 * check Write Protect mode 			 */
if|if
condition|(
name|sdtmp
index|[
literal|2
index|]
operator|&
literal|0x80
condition|)
name|sdd
operator|->
name|sdd_flags
operator||=
name|SDDF_WPROTECT
expr_stmt|;
else|else
name|sdd
operator|->
name|sdd_flags
operator|&=
operator|~
name|SDDF_WPROTECT
expr_stmt|;
comment|/* 			 * check Format Mode 			 */
if|if
condition|(
name|sdtmp
index|[
literal|26
index|]
operator|==
literal|2
condition|)
block|{
name|ii
operator|->
name|ii_type
operator|=
name|search_index
argument_list|(
name|SMO_S501
argument_list|)
expr_stmt|;
if|if
condition|(
name|mo_disp_format
condition|)
name|printf
argument_list|(
literal|"sd%d: format mode 2 (original format)\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sdtmp
index|[
literal|26
index|]
operator|==
literal|3
condition|)
block|{
name|int
name|spare
decl_stmt|;
name|spare
operator|=
operator|*
operator|(
name|short
operator|*
operator|)
operator|&
name|sdtmp
index|[
literal|32
index|]
expr_stmt|;
if|if
condition|(
name|spare
operator|==
literal|2048
condition|)
name|ii
operator|->
name|ii_type
operator|=
name|search_index
argument_list|(
name|SMO_S501_ISO2
argument_list|)
expr_stmt|;
else|else
name|ii
operator|->
name|ii_type
operator|=
name|search_index
argument_list|(
name|SMO_S501_ISO
argument_list|)
expr_stmt|;
if|if
condition|(
name|mo_disp_format
condition|)
name|printf
argument_list|(
literal|"sd%d: format mode 3 (ISO format) spare=%d\n"
argument_list|,
name|unit
argument_list|,
name|spare
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sdd
operator|->
name|sdd_flags
operator||=
name|SDDF_NONFMT
expr_stmt|;
if|if
condition|(
name|mo_disp_format
condition|)
name|printf
argument_list|(
literal|"sd%d: Non format\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
block|}
name|sdi
operator|=
operator|&
name|sddevinfo
index|[
name|ii
operator|->
name|ii_type
index|]
expr_stmt|;
block|}
comment|/* 		 * Mode Select 		 *	Error Recovery Parameters set 		 */
name|i
operator|=
operator|*
operator|(
name|sdi
operator|->
name|ERP_page
operator|+
literal|1
operator|)
operator|+
literal|2
expr_stmt|;
comment|/* page length */
name|bzero
argument_list|(
name|sdtmp
argument_list|,
name|i
operator|+
literal|4
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|sdi
operator|->
name|ERP_page
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|sdtmp
index|[
literal|4
index|]
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|scinit
argument_list|(
operator|&
name|uscsi
argument_list|,
name|ii
operator|->
name|ii_slave
argument_list|,
name|sdd
operator|->
name|sdd_sectsize
argument_list|)
expr_stmt|;
name|uscsi
operator|.
name|sc_cpoint
operator|=
name|sdtmp
expr_stmt|;
name|uscsi
operator|.
name|sc_ctrnscnt
operator|=
name|i
operator|+
literal|4
expr_stmt|;
name|uscsi
operator|.
name|sc_opcode
operator|=
name|SCOP_MSELECT
expr_stmt|;
name|uscsi
operator|.
name|sc_lad
operator|=
operator|(
name|SDM_PF
operator|<<
literal|16
operator|)
expr_stmt|;
name|uscsi
operator|.
name|sc_count
operator|=
name|i
operator|+
literal|4
expr_stmt|;
operator|(
name|void
operator|)
name|sdcmd
argument_list|(
name|dev
argument_list|,
operator|&
name|uscsi
argument_list|)
expr_stmt|;
comment|/* 		 * Read Grown Defect list 		 */
name|scinit
argument_list|(
operator|&
name|uscsi
argument_list|,
name|ii
operator|->
name|ii_slave
argument_list|,
name|sdd
operator|->
name|sdd_sectsize
argument_list|)
expr_stmt|;
name|uscsi
operator|.
name|sc_cpoint
operator|=
name|sdtmp
expr_stmt|;
name|uscsi
operator|.
name|sc_ctrnscnt
operator|=
literal|4
expr_stmt|;
name|uscsi
operator|.
name|sc_opcode
operator|=
name|SCOP_RDL
expr_stmt|;
name|uscsi
operator|.
name|sc_cdb
operator|.
name|un_type1
operator|.
name|t1_ladhi
operator|=
operator|(
name|SDDL_GLIST
operator||
name|SDDL_PHYSFMT
operator|)
operator|<<
literal|8
expr_stmt|;
name|uscsi
operator|.
name|sc_cdb
operator|.
name|un_type1
operator|.
name|t1_p3
operator|=
literal|4
expr_stmt|;
operator|(
name|void
operator|)
name|sdcmd
argument_list|(
name|dev
argument_list|,
operator|&
name|uscsi
argument_list|)
expr_stmt|;
name|i
operator|=
operator|*
operator|(
name|short
operator|*
operator|)
operator|&
name|sdtmp
index|[
literal|2
index|]
operator|/
literal|8
expr_stmt|;
if|if
condition|(
name|i
operator|>
operator|(
literal|1024
operator|*
literal|9
operator|/
literal|10
operator|)
condition|)
name|printf
argument_list|(
literal|"sd%d: WARNING: DEFECT SPARE LOCATION< 10%\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|mo_check_done
label|:
comment|/* 		 * Read Capacity 		 */
name|bzero
argument_list|(
operator|(
name|caddr_t
operator|)
name|sdtmp
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|scinit
argument_list|(
operator|&
name|uscsi
argument_list|,
name|ii
operator|->
name|ii_slave
argument_list|,
name|sdd
operator|->
name|sdd_sectsize
argument_list|)
expr_stmt|;
name|uscsi
operator|.
name|sc_cpoint
operator|=
name|sdtmp
expr_stmt|;
name|uscsi
operator|.
name|sc_ctrnscnt
operator|=
literal|8
expr_stmt|;
name|uscsi
operator|.
name|sc_opcode
operator|=
name|SCOP_RCAP
expr_stmt|;
operator|(
name|void
operator|)
name|sdcmd
argument_list|(
name|dev
argument_list|,
operator|&
name|uscsi
argument_list|)
expr_stmt|;
name|sdd
operator|->
name|sdd_nsect
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
operator|&
name|sdtmp
index|[
literal|0
index|]
operator|+
literal|1
expr_stmt|;
name|sdd
operator|->
name|sdd_sectsize
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
operator|&
name|sdtmp
index|[
literal|4
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|sdd
operator|->
name|sdd_sectsize
operator|!=
name|DEV_BSIZE
operator|)
operator|&&
operator|(
name|sdd
operator|->
name|sdd_sectsize
operator|!=
name|SDBSIZE1K
operator|)
condition|)
name|sdd
operator|->
name|sdd_sectsize
operator|=
name|DEV_BSIZE
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|sdd
operator|->
name|sdd_flags
operator|&
name|SDDF_WPROTECT
operator|)
operator|&&
operator|(
name|flag
operator|&
name|FWRITE
operator|)
condition|)
name|stat
operator|=
name|EROFS
expr_stmt|;
name|pre_open_done
label|:
if|if
condition|(
name|stat
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|isalone
argument_list|(
name|unit
argument_list|)
operator|==
name|ONLY_ONE
operator|)
operator|||
name|media_changed
condition|)
block|{
comment|/* 			 * read partition information from sector zero. 			 */
name|sdrpartinfo
argument_list|(
name|ii
argument_list|)
expr_stmt|;
if|if
condition|(
name|ii
operator|->
name|ii_dk
operator|>=
literal|0
condition|)
block|{
name|dk_wpms
index|[
name|ii
operator|->
name|ii_dk
index|]
operator|=
name|sdd
operator|->
name|sdd_sectsize
operator|*
name|sdstdrv
index|[
name|unit
index|]
operator|.
name|rps
operator|*
name|sdstdrv
index|[
name|unit
index|]
operator|.
name|nsect
operator|/
operator|(
literal|2
operator|*
literal|1000000
operator|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
comment|/* 		 * open error 		 */
operator|*
name|sdopfp
operator|=
name|old_sdopf
expr_stmt|;
if|if
condition|(
operator|(
name|sdd
operator|->
name|sdd_flags
operator|&
name|SDDF_INHRMV
operator|)
operator|&&
operator|(
name|isalone
argument_list|(
name|unit
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|sdd
operator|->
name|sdd_flags
operator|&=
operator|~
name|SDDF_INHRMV
expr_stmt|;
name|scinit
argument_list|(
operator|&
name|uscsi
argument_list|,
name|ii
operator|->
name|ii_slave
argument_list|,
name|sdd
operator|->
name|sdd_sectsize
argument_list|)
expr_stmt|;
name|uscsi
operator|.
name|sc_opcode
operator|=
name|SCOP_MEDRMV
expr_stmt|;
name|uscsi
operator|.
name|sc_count
operator|=
name|SDRMV_ALLOW
expr_stmt|;
operator|(
name|void
operator|)
name|sdcmd
argument_list|(
name|dev
argument_list|,
operator|&
name|uscsi
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * UNLOCK open 	 */
name|s
operator|=
name|splclock
argument_list|()
expr_stmt|;
name|sdd
operator|->
name|sdd_flags
operator|&=
operator|~
name|SDDF_GETTMP
expr_stmt|;
if|if
condition|(
name|sdtmp_stat
operator|&
name|B_WANTED
condition|)
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
name|sdtmp
argument_list|)
expr_stmt|;
name|sdtmp_stat
operator|&=
operator|~
operator|(
name|B_BUSY
operator||
name|B_WANTED
operator|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|stat
operator|)
return|;
block|}
end_block

begin_decl_stmt
name|int
name|sd_access_check_on
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Common flags for sd_access_check() */
end_comment

begin_expr_stmt
name|sd_access_check
argument_list|(
name|bp
argument_list|)
specifier|register
expr|struct
name|buf
operator|*
name|bp
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|iop
comment|/**/
name|_device
modifier|*
name|ii
decl_stmt|;
specifier|register
name|struct
name|sdd_softc
modifier|*
name|sdd
decl_stmt|;
name|int
name|unit
decl_stmt|;
name|int
name|check_part
decl_stmt|;
name|int
name|limit
decl_stmt|;
name|int
name|over
decl_stmt|;
specifier|register
name|struct
name|size
modifier|*
name|sizes
decl_stmt|;
specifier|register
name|int
name|lba
decl_stmt|;
comment|/* logical block address */
specifier|register
name|int
name|sz
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|check_part
operator|=
literal|0
expr_stmt|;
name|unit
operator|=
name|dev2unit
argument_list|(
name|bp
operator|->
name|b_dev
argument_list|)
expr_stmt|;
name|ii
operator|=
name|sddinfo
index|[
name|unit
index|]
expr_stmt|;
name|sdd
operator|=
operator|&
name|sdd_softc
index|[
name|unit
index|]
expr_stmt|;
name|sizes
operator|=
name|sdstdrv
index|[
name|unit
index|]
operator|.
name|sizes
expr_stmt|;
name|lba
operator|=
name|sizes
index|[
name|dev2part
argument_list|(
name|bp
operator|->
name|b_dev
argument_list|)
index|]
operator|.
name|sd_blkoff
operator|+
name|dkblock
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|sz
operator|=
name|howmany
argument_list|(
name|bp
operator|->
name|b_bcount
argument_list|,
name|sdd
operator|->
name|sdd_sectsize
argument_list|)
expr_stmt|;
comment|/* 	 * When block device is used, 	 *	inhibit raw device write operation. 	 */
if|if
condition|(
operator|(
name|major
argument_list|(
name|bp
operator|->
name|b_dev
argument_list|)
operator|==
name|sd_c_major
operator|)
comment|/* RAW I/O */
operator|&&
operator|(
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|B_READ
operator|)
operator|==
literal|0
operator|)
comment|/* WRITE */
operator|&&
operator|(
operator|(
name|ii
operator|->
name|ii_flags
operator|&
name|SD_F_ENW
operator|)
operator|==
literal|0
operator|)
comment|/* INHIBIT */
operator|&&
operator|(
operator|(
name|sd_access_check_on
operator|&
name|SD_F_ENW
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|PNUM
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|sd_b_openf
index|[
name|unit
index|]
index|[
name|i
index|]
operator|==
literal|0
condition|)
continue|continue;
comment|/* 			 *   |----|========|---|======|-------| 			 * 1 |---+++--------------------------| CUT OFF 			 * 2 |---++++++++++++-----------------| CUT OFF 			 * 3 |---++++++++++++++++-------------| CUT OFF 			 * 4 |---++++++++++++++++++++++++-----| CUT OFF 			 * 5 |-------+++----------------------| ERROR 			 * 6 |------------+++-----------------| ERROR 			 * 7 |------------+++++++-------------| ERROR 			 * 8 |------------+++++++++++++++-----| ERROR 			 */
if|if
condition|(
operator|(
name|lba
operator|<
operator|(
name|sizes
index|[
name|i
index|]
operator|.
name|sd_blkoff
operator|+
name|sizes
index|[
name|i
index|]
operator|.
name|sd_nblocks
operator|)
operator|)
operator|&&
operator|(
operator|(
name|lba
operator|+
name|sz
operator|)
operator|>
name|sizes
index|[
name|i
index|]
operator|.
name|sd_blkoff
operator|)
condition|)
name|check_part
operator||=
operator|(
literal|1
operator|<<
name|i
operator|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|check_part
condition|)
block|{
name|limit
operator|=
literal|0x7fffffff
expr_stmt|;
comment|/* XXX */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|PNUM
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|check_part
operator|&
operator|(
literal|1
operator|<<
name|i
operator|)
operator|)
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|lba
operator|>=
name|sizes
index|[
name|i
index|]
operator|.
name|sd_blkoff
condition|)
block|{
name|bp
operator|->
name|b_flags
operator||=
name|B_ERROR
expr_stmt|;
name|bp
operator|->
name|b_error
operator|=
name|EIO
expr_stmt|;
name|bp
operator|->
name|b_resid
operator|=
name|bp
operator|->
name|b_bcount
expr_stmt|;
name|printf
argument_list|(
literal|"sd%d%c: RAW DEVICE WRITE PROTECTED: "
argument_list|,
name|unit
argument_list|,
name|pname
index|[
name|dev2part
argument_list|(
name|bp
operator|->
name|b_dev
argument_list|)
index|]
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"sn = 0x%x(%d), off = 0x%x(%d)\n"
argument_list|,
name|dkblock
argument_list|(
name|bp
argument_list|)
operator|*
name|DEV_BSIZE
operator|/
name|sdd
operator|->
name|sdd_sectsize
argument_list|,
name|dkblock
argument_list|(
name|bp
argument_list|)
operator|*
name|DEV_BSIZE
operator|/
name|sdd
operator|->
name|sdd_sectsize
argument_list|,
name|sizes
index|[
name|dev2part
argument_list|(
name|bp
operator|->
name|b_dev
argument_list|)
index|]
operator|.
name|sd_blkoff
argument_list|,
name|sizes
index|[
name|dev2part
argument_list|(
name|bp
operator|->
name|b_dev
argument_list|)
index|]
operator|.
name|sd_blkoff
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|sizes
index|[
name|i
index|]
operator|.
name|sd_blkoff
operator|<
name|limit
condition|)
name|limit
operator|=
name|sizes
index|[
name|i
index|]
operator|.
name|sd_blkoff
expr_stmt|;
block|}
block|}
else|else
block|{
name|limit
operator|=
name|sizes
index|[
name|dev2part
argument_list|(
name|bp
operator|->
name|b_dev
argument_list|)
index|]
operator|.
name|sd_blkoff
operator|+
name|sizes
index|[
name|dev2part
argument_list|(
name|bp
operator|->
name|b_dev
argument_list|)
index|]
operator|.
name|sd_nblocks
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|over
operator|=
operator|(
name|lba
operator|+
name|sz
operator|)
operator|-
name|limit
operator|)
operator|>
literal|0
condition|)
block|{
comment|/* 		 * Logical Block Address is outside the valid area. 		 */
if|if
condition|(
operator|(
operator|(
name|ii
operator|->
name|ii_flags
operator|&
name|SD_F_EOLBA
operator|)
operator|!=
literal|0
operator|)
operator|||
operator|(
operator|(
name|sd_access_check_on
operator|&
name|SD_F_EOLBA
operator|)
operator|!=
literal|0
operator|)
condition|)
block|{
comment|/* 			 * error if outside LBA 			 */
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|bp
operator|->
name|b_resid
operator|=
name|bp
operator|->
name|b_bcount
operator|-
operator|(
name|sz
operator|-
name|over
operator|)
operator|*
name|sdd
operator|->
name|sdd_sectsize
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|b_resid
operator|>=
name|bp
operator|->
name|b_bcount
condition|)
block|{
name|bp
operator|->
name|b_resid
operator|=
name|bp
operator|->
name|b_bcount
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_macro
name|sd_b_close
argument_list|(
argument|dev
argument_list|,
argument|flag
argument_list|)
end_macro

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|flag
decl_stmt|;
end_decl_stmt

begin_block
block|{
return|return
operator|(
name|_sdclose
argument_list|(
name|dev
argument_list|,
name|flag
argument_list|,
name|S_IFBLK
argument_list|)
operator|)
return|;
block|}
end_block

begin_macro
name|sd_c_close
argument_list|(
argument|dev
argument_list|,
argument|flag
argument_list|)
end_macro

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|flag
decl_stmt|;
end_decl_stmt

begin_block
block|{
return|return
operator|(
name|_sdclose
argument_list|(
name|dev
argument_list|,
name|flag
argument_list|,
name|S_IFCHR
argument_list|)
operator|)
return|;
block|}
end_block

begin_expr_stmt
name|_sdclose
argument_list|(
name|dev
argument_list|,
name|flag
argument_list|,
name|fmt
argument_list|)
specifier|register
name|dev_t
name|dev
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|flag
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|fmt
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|iop
comment|/**/
name|_device
modifier|*
name|ii
decl_stmt|;
specifier|register
name|struct
name|sdd_softc
modifier|*
name|sdd
decl_stmt|;
specifier|register
name|int
name|unit
decl_stmt|;
name|struct
name|sdc_softc
modifier|*
name|sdc
decl_stmt|;
name|struct
name|scsi
name|uscsi
decl_stmt|;
name|struct
name|sc_extnd
modifier|*
name|sce
decl_stmt|;
name|unit
operator|=
name|dev2unit
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|unit
operator|>=
name|nsd
operator|||
operator|(
name|ii
operator|=
name|sddinfo
index|[
name|unit
index|]
operator|)
operator|==
literal|0
operator|||
name|ii
operator|->
name|ii_alive
operator|==
literal|0
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|sdd
operator|=
operator|&
name|sdd_softc
index|[
name|unit
index|]
expr_stmt|;
name|sdc
operator|=
operator|&
name|sdc_softc
index|[
name|ii
operator|->
name|ii_ctlr
index|]
expr_stmt|;
name|sce
operator|=
operator|(
expr|struct
name|sc_extnd
operator|*
operator|)
operator|&
name|sdc_rsense
index|[
name|ii
operator|->
name|ii_ctlr
index|]
index|[
literal|0
index|]
expr_stmt|;
comment|/* 	 * still remain jobs 	 *	sleep about 10ms -> 1sec 	 */
while|while
condition|(
name|ii
operator|->
name|ii_mi
operator|->
name|im_tab
operator|.
name|b_actf
operator|!=
name|NULL
condition|)
name|sleep
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|lbolt
argument_list|,
name|PRIBIO
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fmt
operator|&
name|S_IFMT
operator|)
operator|==
name|S_IFBLK
condition|)
name|sd_b_openf
index|[
name|unit
index|]
index|[
name|dev2part
argument_list|(
name|dev
argument_list|)
index|]
operator|=
literal|0
expr_stmt|;
else|else
name|sd_c_openf
index|[
name|unit
index|]
index|[
name|dev2part
argument_list|(
name|dev
argument_list|)
index|]
operator|=
literal|0
expr_stmt|;
name|sdd
operator|->
name|sdd_flags
operator|&=
operator|~
name|SDDF_XUSE
expr_stmt|;
if|if
condition|(
operator|(
name|sdc
operator|->
name|sdc_firmware
operator|&
name|SDCFW_RMB
operator|)
operator|&&
operator|(
name|isalone
argument_list|(
name|unit
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|sdd
operator|->
name|sdd_flags
operator|&=
operator|~
name|SDDF_INHRMV
expr_stmt|;
name|scinit
argument_list|(
operator|&
name|uscsi
argument_list|,
name|ii
operator|->
name|ii_slave
argument_list|,
name|sdd
operator|->
name|sdd_sectsize
argument_list|)
expr_stmt|;
name|uscsi
operator|.
name|sc_opcode
operator|=
name|SCOP_MEDRMV
expr_stmt|;
name|uscsi
operator|.
name|sc_count
operator|=
name|SDRMV_ALLOW
expr_stmt|;
operator|(
name|void
operator|)
name|sdcmd
argument_list|(
name|dev
argument_list|,
operator|&
name|uscsi
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_macro
name|sdcmd
argument_list|(
argument|dev
argument_list|,
argument|usc
argument_list|)
end_macro

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|scsi
modifier|*
name|usc
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
specifier|register
name|struct
name|scsi
modifier|*
name|ksc
decl_stmt|;
specifier|register
name|u_char
modifier|*
name|point
decl_stmt|;
specifier|register
name|int
name|unit
decl_stmt|;
name|int
name|error
decl_stmt|;
name|int
name|s
decl_stmt|;
name|int
name|cnt
decl_stmt|;
if|if
condition|(
name|usc
operator|==
literal|0
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|error
operator|=
literal|0
expr_stmt|;
name|unit
operator|=
name|dev2unit
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|bp
operator|=
operator|&
name|csdbuf
index|[
name|unit
index|]
expr_stmt|;
comment|/* 	 * LOCK csdbuf 	 */
name|s
operator|=
name|splclock
argument_list|()
expr_stmt|;
while|while
condition|(
name|bp
operator|->
name|b_flags
operator|&
name|B_BUSY
condition|)
block|{
name|bp
operator|->
name|b_flags
operator||=
name|B_WANTED
expr_stmt|;
name|sleep
argument_list|(
operator|(
name|caddr_t
operator|)
name|bp
argument_list|,
name|PRIBIO
argument_list|)
expr_stmt|;
block|}
name|bzero
argument_list|(
operator|(
name|caddr_t
operator|)
name|bp
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_flags
operator|=
name|B_BUSY
operator||
name|B_READ
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|ksc
operator|=
operator|&
name|kernscsi
index|[
name|unit
index|]
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
name|usc
argument_list|,
operator|(
name|caddr_t
operator|)
name|ksc
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|scsi
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * setup command buffer 	 */
name|bp
operator|->
name|b_dev
operator|=
name|dev
expr_stmt|;
name|bp
operator|->
name|b_proc
operator|=
name|curproc
expr_stmt|;
name|cnt
operator|=
name|ksc
operator|->
name|sc_ctrnscnt
expr_stmt|;
name|bp
operator|->
name|b_bcount
operator|=
name|cnt
expr_stmt|;
name|point
operator|=
name|ksc
operator|->
name|sc_cpoint
expr_stmt|;
name|bp
operator|->
name|b_un
operator|.
name|b_addr
operator|=
operator|(
name|caddr_t
operator|)
name|point
expr_stmt|;
if|if
condition|(
name|cnt
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|point
operator|==
name|NULL
condition|)
block|{
name|ksc
operator|->
name|sc_cpoint
operator|=
name|point
operator|=
name|get_scsi
argument_list|(
name|unit
argument_list|)
operator|->
name|sc_param
expr_stmt|;
if|if
condition|(
name|cnt
operator|>
literal|20
condition|)
block|{
name|error
operator|=
name|EFAULT
expr_stmt|;
goto|goto
name|done
goto|;
block|}
block|}
if|if
condition|(
name|point
operator|<
operator|(
name|u_char
operator|*
operator|)
name|KERNBASE
condition|)
block|{
if|if
condition|(
name|useracc
argument_list|(
name|point
argument_list|,
name|cnt
argument_list|,
name|B_WRITE
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|EFAULT
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|curproc
operator|->
name|p_flag
operator||=
name|SPHYSIO
expr_stmt|;
name|vslock
argument_list|(
name|point
argument_list|,
name|cnt
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_flags
operator||=
name|B_PHYS
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|mips
else|else
block|{
if|if
condition|(
name|kernacc
argument_list|(
name|point
argument_list|,
name|cnt
argument_list|,
name|B_WRITE
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|EFAULT
expr_stmt|;
goto|goto
name|done
goto|;
block|}
block|}
endif|#
directive|endif
name|ksc
operator|->
name|sc_tstatus
operator|=
name|TS_MAPPED_PIO
expr_stmt|;
comment|/* XXX */
block|}
comment|/* 	 * call strategy entry, and wait command done. 	 */
name|sdstrategy
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|iowait
argument_list|(
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cnt
operator|>
literal|0
operator|)
operator|&&
operator|(
name|point
operator|<
operator|(
name|u_char
operator|*
operator|)
name|KERNBASE
operator|)
condition|)
block|{
name|vsunlock
argument_list|(
name|point
argument_list|,
name|cnt
argument_list|,
name|B_READ
argument_list|)
expr_stmt|;
name|curproc
operator|->
name|p_flag
operator|&=
operator|~
name|SPHYSIO
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|B_ERROR
operator|)
operator|==
literal|0
condition|)
name|error
operator|=
literal|0
expr_stmt|;
else|else
block|{
if|if
condition|(
name|bp
operator|->
name|b_error
condition|)
name|error
operator|=
name|bp
operator|->
name|b_error
expr_stmt|;
else|else
name|error
operator|=
name|EIO
expr_stmt|;
block|}
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
name|ksc
argument_list|,
operator|(
name|caddr_t
operator|)
name|usc
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|scsi
argument_list|)
argument_list|)
expr_stmt|;
name|done
label|:
comment|/* 	 * UNLOCK csdbuf 	 */
name|s
operator|=
name|splclock
argument_list|()
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|b_flags
operator|&
name|B_WANTED
condition|)
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
name|bp
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_flags
operator|=
literal|0
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * read partition information from sector zero.  */
end_comment

begin_expr_stmt
name|sdrpartinfo
argument_list|(
name|ii
argument_list|)
specifier|register
expr|struct
name|iop
comment|/**/
name|_device
operator|*
name|ii
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|disklabel
modifier|*
name|dlp
decl_stmt|;
specifier|register
name|struct
name|sdst
modifier|*
name|hsp
decl_stmt|;
specifier|register
name|struct
name|sdst
modifier|*
name|st
decl_stmt|;
specifier|register
name|int
name|unit
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|struct
name|firstsector
modifier|*
name|fsp
decl_stmt|;
name|struct
name|sdc_softc
modifier|*
name|sdc
decl_stmt|;
name|struct
name|sdd_softc
modifier|*
name|sdd
decl_stmt|;
name|struct
name|sddevinfo
modifier|*
name|sdi
decl_stmt|;
name|struct
name|scsi
name|uscsi
decl_stmt|;
name|int
name|s
decl_stmt|;
name|sdi
operator|=
operator|&
name|sddevinfo
index|[
name|ii
operator|->
name|ii_type
index|]
expr_stmt|;
name|unit
operator|=
name|ii
operator|->
name|ii_unit
expr_stmt|;
name|sdd
operator|=
operator|&
name|sdd_softc
index|[
name|unit
index|]
expr_stmt|;
name|sdc
operator|=
operator|&
name|sdc_softc
index|[
name|ii
operator|->
name|ii_ctlr
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|sdd
operator|->
name|sdd_flags
operator|&
operator|(
name|SDDF_NONFMT
operator||
name|SDDF_FMTDONE
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
specifier|register
name|struct
name|sc_rcap
modifier|*
name|scr
init|=
operator|(
expr|struct
name|sc_rcap
operator|*
operator|)
name|sdtmp
decl_stmt|;
name|sdd
operator|->
name|sdd_flags
operator||=
name|SDDF_FMTDONE
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|caddr_t
operator|)
name|sdtmp
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|scinit
argument_list|(
operator|&
name|uscsi
argument_list|,
name|ii
operator|->
name|ii_slave
argument_list|,
name|sdd
operator|->
name|sdd_sectsize
argument_list|)
expr_stmt|;
name|uscsi
operator|.
name|sc_cpoint
operator|=
operator|(
name|u_char
operator|*
operator|)
name|scr
expr_stmt|;
name|uscsi
operator|.
name|sc_ctrnscnt
operator|=
literal|8
expr_stmt|;
name|uscsi
operator|.
name|sc_opcode
operator|=
name|SCOP_RCAP
expr_stmt|;
operator|(
name|void
operator|)
name|sdcmd
argument_list|(
name|unit
operator|<<
literal|3
argument_list|,
operator|&
name|uscsi
argument_list|)
expr_stmt|;
name|sdd
operator|->
name|sdd_nsect
operator|=
name|scr
operator|->
name|scr_nblock
operator|+
literal|1
expr_stmt|;
name|sdd
operator|->
name|sdd_sectsize
operator|=
name|scr
operator|->
name|scr_blocklen
expr_stmt|;
if|if
condition|(
name|sdd
operator|->
name|sdd_sectsize
operator|==
literal|0
condition|)
name|sdd
operator|->
name|sdd_sectsize
operator|=
name|SDBSIZE1K
expr_stmt|;
block|}
name|bzero
argument_list|(
name|sdtmp
argument_list|,
name|DEV_BSIZE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sdd
operator|->
name|sdd_flags
operator|&
name|SDDF_NONFMT
operator|)
operator|==
literal|0
condition|)
block|{
name|scinit
argument_list|(
operator|&
name|uscsi
argument_list|,
name|ii
operator|->
name|ii_slave
argument_list|,
name|sdd
operator|->
name|sdd_sectsize
argument_list|)
expr_stmt|;
name|uscsi
operator|.
name|sc_cpoint
operator|=
name|sdtmp
expr_stmt|;
name|uscsi
operator|.
name|sc_ctrnscnt
operator|=
name|DEV_BSIZE
expr_stmt|;
name|uscsi
operator|.
name|sc_opcode
operator|=
name|SCOP_READ
expr_stmt|;
name|uscsi
operator|.
name|sc_lad
operator|=
literal|0
expr_stmt|;
name|uscsi
operator|.
name|sc_count
operator|=
literal|1
expr_stmt|;
operator|(
name|void
operator|)
name|sdcmd
argument_list|(
name|unit
operator|<<
literal|3
argument_list|,
operator|&
name|uscsi
argument_list|)
expr_stmt|;
name|sdd
operator|->
name|sdd_flags
operator|&=
operator|~
name|SDDF_SKIPCHECK
expr_stmt|;
block|}
name|fsp
operator|=
operator|(
expr|struct
name|firstsector
operator|*
operator|)
name|sdtmp
expr_stmt|;
name|dlp
operator|=
operator|(
expr|struct
name|disklabel
operator|*
operator|)
operator|(
name|sdtmp
operator|+
name|LABELOFFSET
operator|)
expr_stmt|;
name|s
operator|=
name|splclock
argument_list|()
expr_stmt|;
name|hsp
operator|=
operator|&
name|sdstdrv
index|[
name|unit
index|]
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|caddr_t
operator|)
name|hsp
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sdst
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|sdlabel
index|[
name|unit
index|]
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|disklabel
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|dlp
operator|->
name|d_magic
operator|==
name|DISKMAGIC
operator|)
operator|&&
operator|(
operator|(
name|ii
operator|->
name|ii_flags
operator|&
name|SD_F_IGNLABEL
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
name|sdlabel
index|[
name|unit
index|]
operator|=
operator|*
name|dlp
expr_stmt|;
name|disklabel2sdst
argument_list|(
name|unit
argument_list|,
name|dlp
argument_list|,
name|hsp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|ii
operator|->
name|ii_type
operator|==
name|UNKNOWN_DISK
operator|)
operator|||
operator|(
name|sdi
operator|->
name|sdstp
operator|->
name|sizes
operator|==
name|calc_disk_sizes
operator|)
condition|)
block|{
comment|/* 			 * If device is UNKNOWN PARTITION SIZE, 			 *	calculate default partition from capacity. 			 */
name|st
operator|=
name|sdi
operator|->
name|sdstp
expr_stmt|;
name|hsp
operator|->
name|nsect
operator|=
name|st
operator|->
name|nsect
expr_stmt|;
comment|/* # sectors/track */
name|hsp
operator|->
name|ntrak
operator|=
name|st
operator|->
name|ntrak
expr_stmt|;
comment|/* # tracks/cylinder */
name|hsp
operator|->
name|nspc
operator|=
name|st
operator|->
name|nspc
expr_stmt|;
comment|/* # sectors/cylinder */
name|hsp
operator|->
name|ncyl
operator|=
name|st
operator|->
name|ncyl
expr_stmt|;
comment|/* # cylinders */
name|hsp
operator|->
name|rps
operator|=
name|st
operator|->
name|rps
expr_stmt|;
comment|/* # revolutions/sec */
name|hsp
operator|->
name|sizes
operator|=
name|sdsizedrv
index|[
name|unit
index|]
expr_stmt|;
comment|/* partition table */
name|sd_calcpart
argument_list|(
name|ii
argument_list|,
name|hsp
operator|->
name|sizes
argument_list|,
name|sdd
operator|->
name|sdd_nsect
argument_list|,
name|sdd
operator|->
name|sdd_sectsize
argument_list|)
expr_stmt|;
name|sdst2disklabel
argument_list|(
name|unit
argument_list|,
name|hsp
argument_list|,
operator|&
name|sdlabel
index|[
name|unit
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * If device is support disk, 			 *	copy default partition from size table. 			 */
name|st
operator|=
name|sdi
operator|->
name|sdstp
expr_stmt|;
name|hsp
operator|->
name|nsect
operator|=
name|st
operator|->
name|nsect
expr_stmt|;
comment|/* # sectors/track */
name|hsp
operator|->
name|ntrak
operator|=
name|st
operator|->
name|ntrak
expr_stmt|;
comment|/* # tracks/cylinder */
name|hsp
operator|->
name|nspc
operator|=
name|st
operator|->
name|nspc
expr_stmt|;
comment|/* # sectors/cylinder */
name|hsp
operator|->
name|ncyl
operator|=
name|st
operator|->
name|ncyl
expr_stmt|;
comment|/* # cylinders */
name|hsp
operator|->
name|rps
operator|=
name|st
operator|->
name|rps
expr_stmt|;
comment|/* # revolutions / second */
name|hsp
operator|->
name|sizes
operator|=
name|sdsizedrv
index|[
name|unit
index|]
expr_stmt|;
comment|/* partition table */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|PNUM
condition|;
name|i
operator|++
control|)
block|{
name|hsp
operator|->
name|sizes
index|[
name|i
index|]
operator|.
name|sd_nblocks
operator|=
name|st
operator|->
name|sizes
index|[
name|i
index|]
operator|.
name|sd_nblocks
expr_stmt|;
name|hsp
operator|->
name|sizes
index|[
name|i
index|]
operator|.
name|sd_blkoff
operator|=
name|st
operator|->
name|sizes
index|[
name|i
index|]
operator|.
name|sd_blkoff
expr_stmt|;
block|}
name|sdst2disklabel
argument_list|(
name|unit
argument_list|,
name|hsp
argument_list|,
operator|&
name|sdlabel
index|[
name|unit
index|]
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* BEGIN XXX*/
if|if
condition|(
name|hsp
operator|->
name|rps
operator|==
literal|0
condition|)
block|{
comment|/* 		 * If device is support disk, 		 *	copy default partition from size table. 		 */
name|st
operator|=
name|sdi
operator|->
name|sdstp
expr_stmt|;
name|hsp
operator|->
name|nsect
operator|=
name|st
operator|->
name|nsect
expr_stmt|;
comment|/* # sectors/track */
name|hsp
operator|->
name|ntrak
operator|=
name|st
operator|->
name|ntrak
expr_stmt|;
comment|/* # tracks/cylinder */
name|hsp
operator|->
name|nspc
operator|=
name|st
operator|->
name|nspc
expr_stmt|;
comment|/* # sectors/cylinder */
name|hsp
operator|->
name|ncyl
operator|=
name|st
operator|->
name|ncyl
expr_stmt|;
comment|/* # cylinders */
name|hsp
operator|->
name|rps
operator|=
name|st
operator|->
name|rps
expr_stmt|;
comment|/* # revolutions / second */
name|sdst2disklabel
argument_list|(
name|unit
argument_list|,
name|hsp
argument_list|,
operator|&
name|sdlabel
index|[
name|unit
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* END XXX*/
operator|(
name|void
operator|)
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_block

begin_decl_stmt
specifier|static
name|char
name|Warn_Part
index|[]
init|=
literal|"sd%d: PARTITION TABLE CHANGED\n"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|Pr_Part_Fmt
index|[]
init|=
literal|"sd%d%c: nblk=%d, off=%d\n"
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|stsz
parameter_list|(
name|N
parameter_list|)
value|st->sizes[(N)].sd_nblocks
end_define

begin_define
define|#
directive|define
name|stof
parameter_list|(
name|N
parameter_list|)
value|st->sizes[(N)].sd_blkoff
end_define

begin_define
define|#
directive|define
name|dlsz
parameter_list|(
name|N
parameter_list|)
value|dlp->d_partitions[(N)].p_size
end_define

begin_define
define|#
directive|define
name|dlof
parameter_list|(
name|N
parameter_list|)
value|dlp->d_partitions[(N)].p_offset
end_define

begin_define
define|#
directive|define
name|disz
parameter_list|(
name|N
parameter_list|)
value|dip->di_part[(N)].dp_nblocks
end_define

begin_define
define|#
directive|define
name|diof
parameter_list|(
name|N
parameter_list|)
value|dip->di_part[(N)].dp_blkoff
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|BBSIZE
end_ifndef

begin_define
define|#
directive|define
name|BBSIZE
value|8192
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_expr_stmt
specifier|static
name|check_sdst
argument_list|(
argument|unit
argument_list|,
argument|st
argument_list|)
name|int
name|unit
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|struct
name|sdst
modifier|*
name|st
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|st
operator|->
name|nsect
operator|==
literal|0
condition|)
block|{
name|st
operator|->
name|nsect
operator|=
literal|1
expr_stmt|;
name|printf
argument_list|(
literal|"sd%d: nsect SHOULD BE != 0, 1 assumed\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|st
operator|->
name|rps
operator|==
literal|0
condition|)
block|{
name|st
operator|->
name|rps
operator|=
literal|60
expr_stmt|;
name|printf
argument_list|(
literal|"sd%d: rps SHOULD BE != 0, 60 assumed\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_expr_stmt
specifier|static
name|disklabel2sdst
argument_list|(
argument|unit
argument_list|,
argument|dlp
argument_list|,
argument|st
argument_list|)
name|int
name|unit
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|struct
name|disklabel
modifier|*
name|dlp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|struct
name|sdst
modifier|*
name|st
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|int
name|msg_header_printed
decl_stmt|;
name|msg_header_printed
operator|=
literal|0
expr_stmt|;
name|st
operator|->
name|nsect
operator|=
name|dlp
operator|->
name|d_nsectors
expr_stmt|;
comment|/* # sectors/track */
name|st
operator|->
name|ntrak
operator|=
name|dlp
operator|->
name|d_ntracks
expr_stmt|;
comment|/* # tracks/cylinder */
name|st
operator|->
name|nspc
operator|=
name|dlp
operator|->
name|d_secpercyl
expr_stmt|;
comment|/* # sectors/cylinder */
name|st
operator|->
name|ncyl
operator|=
name|dlp
operator|->
name|d_ncylinders
expr_stmt|;
comment|/* # cylinders */
name|st
operator|->
name|rps
operator|=
name|dlp
operator|->
name|d_rpm
operator|/
literal|60
expr_stmt|;
comment|/* # revolutions / second */
name|st
operator|->
name|sizes
operator|=
name|sdsizedrv
index|[
name|unit
index|]
expr_stmt|;
comment|/* partition table */
name|check_sdst
argument_list|(
name|unit
argument_list|,
name|st
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|PNUM
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|msg_header_printed
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
operator|(
name|stsz
argument_list|(
name|i
argument_list|)
operator|!=
literal|0
operator|)
operator|||
operator|(
name|stof
argument_list|(
name|i
argument_list|)
operator|!=
literal|0
operator|)
operator|)
operator|&&
operator|(
operator|(
name|stsz
argument_list|(
name|i
argument_list|)
operator|!=
name|dlsz
argument_list|(
name|i
argument_list|)
operator|)
operator|||
operator|(
name|stof
argument_list|(
name|i
argument_list|)
operator|!=
name|dlof
argument_list|(
name|i
argument_list|)
operator|)
operator|)
condition|)
block|{
name|msg_header_printed
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|PNUM
condition|;
name|i
operator|++
control|)
block|{
name|stsz
argument_list|(
name|i
argument_list|)
operator|=
name|dlsz
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|stof
argument_list|(
name|i
argument_list|)
operator|=
name|dlof
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|msg_header_printed
condition|)
block|{
name|printf
argument_list|(
name|Warn_Part
argument_list|,
name|unit
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|PNUM
condition|;
name|i
operator|++
control|)
name|printf
argument_list|(
name|Pr_Part_Fmt
argument_list|,
name|unit
argument_list|,
name|pname
index|[
name|i
index|]
argument_list|,
name|stsz
argument_list|(
name|i
argument_list|)
argument_list|,
name|stof
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_expr_stmt
specifier|static
name|sdst2disklabel
argument_list|(
argument|unit
argument_list|,
argument|st
argument_list|,
argument|dlp
argument_list|)
name|int
name|unit
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*XXX*/
end_comment

begin_decl_stmt
specifier|register
name|struct
name|sdst
modifier|*
name|st
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|struct
name|disklabel
modifier|*
name|dlp
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|dlp
operator|->
name|d_type
operator|=
name|DTYPE_SCSI
expr_stmt|;
comment|/* drive type */
name|dlp
operator|->
name|d_secsize
operator|=
name|sdd_softc
index|[
name|unit
index|]
operator|.
name|sdd_sectsize
expr_stmt|;
comment|/* # of bytes per sector */
name|dlp
operator|->
name|d_nsectors
operator|=
name|st
operator|->
name|nsect
expr_stmt|;
comment|/* # sectors/track */
name|dlp
operator|->
name|d_ntracks
operator|=
name|st
operator|->
name|ntrak
expr_stmt|;
comment|/* # tracks/cylinder */
name|dlp
operator|->
name|d_ncylinders
operator|=
name|st
operator|->
name|ncyl
expr_stmt|;
comment|/* # cylinders */
name|dlp
operator|->
name|d_secpercyl
operator|=
name|st
operator|->
name|nspc
expr_stmt|;
comment|/* # sectors/cylinder */
name|dlp
operator|->
name|d_rpm
operator|=
name|st
operator|->
name|rps
operator|*
literal|60
expr_stmt|;
comment|/* # revolutions / minute */
name|dlp
operator|->
name|d_bbsize
operator|=
name|BBSIZE
expr_stmt|;
comment|/*XXX*/
comment|/* size of boot area at sn0, bytes */
name|dlp
operator|->
name|d_sbsize
operator|=
name|SBSIZE
expr_stmt|;
comment|/*XXX*/
comment|/* max size of fs superblock, bytes */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|PNUM
condition|;
name|i
operator|++
control|)
block|{
name|dlsz
argument_list|(
name|i
argument_list|)
operator|=
name|stsz
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|dlof
argument_list|(
name|i
argument_list|)
operator|=
name|stof
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_undef
undef|#
directive|undef
name|stsz
end_undef

begin_undef
undef|#
directive|undef
name|stof
end_undef

begin_undef
undef|#
directive|undef
name|dlsz
end_undef

begin_undef
undef|#
directive|undef
name|dlof
end_undef

begin_undef
undef|#
directive|undef
name|disz
end_undef

begin_undef
undef|#
directive|undef
name|diof
end_undef

begin_expr_stmt
name|sd_calcpart
argument_list|(
name|ii
argument_list|,
name|disk_sizes
argument_list|,
name|nsect
argument_list|,
name|sectsize
argument_list|)
specifier|register
expr|struct
name|iop
comment|/**/
name|_device
operator|*
name|ii
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|struct
name|size
name|disk_sizes
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|nsect
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|sectsize
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|defpart
modifier|*
name|dp
decl_stmt|;
specifier|register
name|int
name|size_mb
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|int
name|psize
decl_stmt|;
name|size_mb
operator|=
name|nsect
operator|*
name|sectsize
operator|/
operator|(
literal|1024
operator|*
literal|1024
operator|)
expr_stmt|;
for|for
control|(
name|dp
operator|=
name|defpart_std
init|;
name|dp
operator|->
name|range_max
condition|;
name|dp
operator|++
control|)
if|if
condition|(
operator|(
name|dp
operator|->
name|range_min
operator|<=
name|size_mb
operator|)
operator|&&
operator|(
name|size_mb
operator|<
name|dp
operator|->
name|range_max
operator|)
condition|)
break|break;
comment|/* PASS1 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|PNUM
condition|;
name|i
operator|++
control|)
block|{
name|psize
operator|=
name|dp
operator|->
name|partsize
index|[
name|i
index|]
expr_stmt|;
switch|switch
condition|(
name|psize
condition|)
block|{
case|case
name|PART_UNUSED
case|:
name|disk_sizes
index|[
name|i
index|]
operator|.
name|sd_nblocks
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|PART_SPEC
case|:
name|disk_sizes
index|[
name|i
index|]
operator|.
name|sd_nblocks
operator|=
name|nsect
operator|*
name|sectsize
operator|/
name|DEV_BSIZE
expr_stmt|;
break|break;
case|case
name|PART_CALCF
case|:
case|case
name|PART_CALCG
case|:
break|break;
default|default:
name|disk_sizes
index|[
name|i
index|]
operator|.
name|sd_nblocks
operator|=
name|psize
expr_stmt|;
break|break;
block|}
block|}
comment|/* PASS2 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|PNUM
condition|;
name|i
operator|++
control|)
block|{
name|psize
operator|=
name|dp
operator|->
name|partsize
index|[
name|i
index|]
expr_stmt|;
switch|switch
condition|(
name|psize
condition|)
block|{
case|case
name|PART_UNUSED
case|:
case|case
name|PART_SPEC
case|:
break|break;
case|case
name|PART_CALCF
case|:
name|disk_sizes
index|[
name|i
index|]
operator|.
name|sd_nblocks
operator|=
name|disk_sizes
index|[
name|PART_C
index|]
operator|.
name|sd_nblocks
operator|-
operator|(
name|disk_sizes
index|[
name|PART_A
index|]
operator|.
name|sd_nblocks
operator|+
name|disk_sizes
index|[
name|PART_B
index|]
operator|.
name|sd_nblocks
operator|+
name|disk_sizes
index|[
name|PART_D
index|]
operator|.
name|sd_nblocks
operator|+
name|disk_sizes
index|[
name|PART_E
index|]
operator|.
name|sd_nblocks
operator|+
name|disk_sizes
index|[
name|PART_H
index|]
operator|.
name|sd_nblocks
operator|)
expr_stmt|;
break|break;
case|case
name|PART_CALCG
case|:
name|disk_sizes
index|[
name|i
index|]
operator|.
name|sd_nblocks
operator|=
name|disk_sizes
index|[
name|PART_C
index|]
operator|.
name|sd_nblocks
operator|-
operator|(
name|disk_sizes
index|[
name|PART_A
index|]
operator|.
name|sd_nblocks
operator|+
name|disk_sizes
index|[
name|PART_B
index|]
operator|.
name|sd_nblocks
operator|+
name|disk_sizes
index|[
name|PART_H
index|]
operator|.
name|sd_nblocks
operator|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
comment|/* OFFSET */
name|disk_sizes
index|[
name|PART_A
index|]
operator|.
name|sd_blkoff
operator|=
literal|0
expr_stmt|;
name|disk_sizes
index|[
name|PART_B
index|]
operator|.
name|sd_blkoff
operator|=
name|disk_sizes
index|[
name|PART_A
index|]
operator|.
name|sd_nblocks
expr_stmt|;
name|disk_sizes
index|[
name|PART_C
index|]
operator|.
name|sd_blkoff
operator|=
literal|0
expr_stmt|;
name|disk_sizes
index|[
name|PART_D
index|]
operator|.
name|sd_blkoff
operator|=
name|disk_sizes
index|[
name|PART_A
index|]
operator|.
name|sd_nblocks
operator|+
name|disk_sizes
index|[
name|PART_B
index|]
operator|.
name|sd_nblocks
operator|+
name|disk_sizes
index|[
name|PART_H
index|]
operator|.
name|sd_nblocks
expr_stmt|;
name|disk_sizes
index|[
name|PART_E
index|]
operator|.
name|sd_blkoff
operator|=
name|disk_sizes
index|[
name|PART_D
index|]
operator|.
name|sd_blkoff
operator|+
name|disk_sizes
index|[
name|PART_D
index|]
operator|.
name|sd_nblocks
expr_stmt|;
name|disk_sizes
index|[
name|PART_F
index|]
operator|.
name|sd_blkoff
operator|=
name|disk_sizes
index|[
name|PART_E
index|]
operator|.
name|sd_blkoff
operator|+
name|disk_sizes
index|[
name|PART_E
index|]
operator|.
name|sd_nblocks
expr_stmt|;
name|disk_sizes
index|[
name|PART_G
index|]
operator|.
name|sd_blkoff
operator|=
name|disk_sizes
index|[
name|PART_D
index|]
operator|.
name|sd_blkoff
expr_stmt|;
if|if
condition|(
name|disk_sizes
index|[
name|PART_H
index|]
operator|.
name|sd_nblocks
operator|==
literal|0
condition|)
name|disk_sizes
index|[
name|PART_H
index|]
operator|.
name|sd_blkoff
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|disk_sizes
index|[
name|PART_H
index|]
operator|.
name|sd_blkoff
operator|=
name|disk_sizes
index|[
name|PART_A
index|]
operator|.
name|sd_nblocks
operator|+
name|disk_sizes
index|[
name|PART_B
index|]
operator|.
name|sd_nblocks
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|PNUM
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|disk_sizes
index|[
name|i
index|]
operator|.
name|sd_nblocks
operator|==
literal|0
condition|)
name|disk_sizes
index|[
name|i
index|]
operator|.
name|sd_blkoff
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_decl_stmt
name|int
name|sd_str_pr
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|sdstrategy
argument_list|(
name|bp
argument_list|)
specifier|register
expr|struct
name|buf
operator|*
name|bp
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|iop
comment|/**/
name|_device
modifier|*
name|ii
decl_stmt|;
specifier|register
name|struct
name|sdst
modifier|*
name|st
decl_stmt|;
specifier|register
name|struct
name|buf
modifier|*
name|dp
decl_stmt|;
specifier|register
name|int
name|unit
decl_stmt|;
specifier|register
name|int
name|ssize
decl_stmt|;
name|struct
name|sdd_softc
modifier|*
name|sdd
decl_stmt|;
name|struct
name|sdc_softc
modifier|*
name|sdc
decl_stmt|;
name|long
name|bn
decl_stmt|;
name|int
name|xunit
decl_stmt|;
name|int
name|s
decl_stmt|;
name|xunit
operator|=
name|dev2part
argument_list|(
name|bp
operator|->
name|b_dev
argument_list|)
expr_stmt|;
name|unit
operator|=
name|dev2unit
argument_list|(
name|bp
operator|->
name|b_dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|unit
operator|>=
name|nsd
operator|||
operator|(
name|ii
operator|=
name|sddinfo
index|[
name|unit
index|]
operator|)
operator|==
literal|0
operator|||
name|ii
operator|->
name|ii_alive
operator|==
literal|0
condition|)
goto|goto
name|bad
goto|;
if|if
condition|(
name|bp
operator|!=
operator|&
name|csdbuf
index|[
name|unit
index|]
condition|)
block|{
comment|/* 		 * READ / WRITE command 		 */
name|sdd
operator|=
operator|&
name|sdd_softc
index|[
name|unit
index|]
expr_stmt|;
if|if
condition|(
name|sdd
operator|->
name|sdd_flags
operator|&
name|SDDF_NONFMT
condition|)
goto|goto
name|bad
goto|;
name|sdc
operator|=
operator|&
name|sdc_softc
index|[
name|ii
operator|->
name|ii_ctlr
index|]
expr_stmt|;
name|ssize
operator|=
name|sdd
operator|->
name|sdd_sectsize
expr_stmt|;
if|if
condition|(
operator|(
name|ssize
operator|!=
name|DEV_BSIZE
operator|)
operator|&&
operator|(
operator|(
operator|(
operator|(
name|dkblock
argument_list|(
name|bp
argument_list|)
operator|*
name|DEV_BSIZE
operator|)
operator|%
name|ssize
operator|)
operator|!=
literal|0
operator|)
operator|||
operator|(
operator|(
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|B_READ
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|(
operator|(
name|bp
operator|->
name|b_bcount
operator|%
name|ssize
operator|)
operator|!=
literal|0
operator|)
operator|)
operator|)
condition|)
block|{
goto|goto
name|bad
goto|;
block|}
name|st
operator|=
operator|&
name|sdstdrv
index|[
name|unit
index|]
expr_stmt|;
name|bn
operator|=
name|dkblock
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_resid
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|bn
operator|<
literal|0
operator|)
operator|||
operator|(
name|bn
operator|>=
name|st
operator|->
name|sizes
index|[
name|xunit
index|]
operator|.
name|sd_nblocks
operator|)
condition|)
goto|goto
name|bad2
goto|;
if|if
condition|(
name|sd_access_check
argument_list|(
name|bp
argument_list|)
operator|<
literal|0
condition|)
goto|goto
name|bad2
goto|;
ifdef|#
directive|ifdef
name|notdef
comment|/* KU: XXX */
name|bp
operator|->
name|b_cylin
operator|=
operator|(
name|bn
operator|+
name|st
operator|->
name|sizes
index|[
name|xunit
index|]
operator|.
name|sd_blkoff
operator|)
operator|/
name|st
operator|->
name|nspc
expr_stmt|;
block|}
else|else
block|{
name|bp
operator|->
name|b_cylin
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
block|}
name|s
operator|=
name|splsc
argument_list|()
expr_stmt|;
name|dp
operator|=
operator|&
name|sdutab
index|[
name|ii
operator|->
name|ii_unit
index|]
expr_stmt|;
name|disksort
argument_list|(
name|dp
argument_list|,
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|dp
operator|->
name|b_active
operator|==
literal|0
condition|)
block|{
name|sdustart
argument_list|(
name|ii
argument_list|)
expr_stmt|;
name|bp
operator|=
operator|&
name|ii
operator|->
name|ii_mi
operator|->
name|im_tab
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|b_actf
operator|&&
name|bp
operator|->
name|b_active
operator|==
literal|0
condition|)
name|sdstart
argument_list|(
name|ii
operator|->
name|ii_mi
argument_list|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
name|bad
label|:
name|bp
operator|->
name|b_flags
operator||=
name|B_ERROR
expr_stmt|;
goto|goto
name|done
goto|;
name|bad2
label|:
name|bp
operator|->
name|b_resid
operator|=
name|bp
operator|->
name|b_bcount
expr_stmt|;
name|done
label|:
name|iodone
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Unit start routine.  */
end_comment

begin_expr_stmt
name|sdustart
argument_list|(
name|ii
argument_list|)
specifier|register
expr|struct
name|iop
comment|/**/
name|_device
operator|*
name|ii
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|iop
comment|/**/
name|_ctlr
modifier|*
name|im
decl_stmt|;
specifier|register
name|struct
name|buf
modifier|*
name|dp
decl_stmt|;
if|if
condition|(
name|ii
operator|==
name|NULL
condition|)
return|return;
name|im
operator|=
name|ii
operator|->
name|ii_mi
expr_stmt|;
name|dk_busy
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|ii
operator|->
name|ii_dk
operator|)
expr_stmt|;
name|dp
operator|=
operator|&
name|sdutab
index|[
name|ii
operator|->
name|ii_unit
index|]
expr_stmt|;
if|if
condition|(
name|dp
operator|->
name|b_actf
operator|==
name|NULL
condition|)
return|return;
comment|/* 	 * If the controller is active, just remember 	 * that this device would like to be positioned ... 	 * if we tried to position now we would confuse the SD. 	 */
if|if
condition|(
name|im
operator|->
name|im_tab
operator|.
name|b_active
condition|)
block|{
name|sdc_softc
index|[
name|im
operator|->
name|im_ctlr
index|]
operator|.
name|sdc_softas
operator||=
operator|(
literal|1
operator|<<
name|ii
operator|->
name|ii_slave
operator|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * If we have already positioned this drive, 	 * then just put it on the ready queue. 	 */
if|if
condition|(
name|dp
operator|->
name|b_active
operator|==
literal|0
condition|)
name|dp
operator|->
name|b_active
operator|=
literal|1
expr_stmt|;
comment|/* 	 * Device is ready to go 	 * put it on the ready queue for the controller 	 * (unless its already there.) 	 */
if|if
condition|(
name|dp
operator|->
name|b_active
operator|!=
literal|2
condition|)
block|{
name|im
operator|->
name|im_tab
operator|.
name|b_actf
operator|=
name|dp
expr_stmt|;
name|dp
operator|->
name|b_active
operator|=
literal|2
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  * Start up a transfer on a drive.  */
end_comment

begin_expr_stmt
name|sdstart
argument_list|(
name|im
argument_list|)
specifier|register
expr|struct
name|iop
comment|/**/
name|_ctlr
operator|*
name|im
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
specifier|register
name|struct
name|buf
modifier|*
name|dp
decl_stmt|;
specifier|register
name|struct
name|sdc_softc
modifier|*
name|sdc
decl_stmt|;
name|loop
label|:
comment|/* 	 * Pull a request off the controller queue. 	 */
if|if
condition|(
operator|(
name|dp
operator|=
name|im
operator|->
name|im_tab
operator|.
name|b_actf
operator|)
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
operator|(
name|bp
operator|=
name|dp
operator|->
name|b_actf
operator|)
operator|==
name|NULL
condition|)
return|return;
comment|/* 	 * Mark controller busy, and 	 * determine destination of this request. 	 */
name|im
operator|->
name|im_tab
operator|.
name|b_active
operator|++
expr_stmt|;
name|sdexec
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
end_block

begin_function
name|void
name|sdexec
parameter_list|(
name|bp
parameter_list|)
specifier|register
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
block|{
specifier|register
name|struct
name|iop
comment|/**/
name|_device
modifier|*
name|ii
decl_stmt|;
specifier|register
name|struct
name|buf_stat
modifier|*
name|bs
decl_stmt|;
specifier|register
name|struct
name|scsi
modifier|*
name|sc
decl_stmt|;
specifier|register
name|int
name|ssize
decl_stmt|;
specifier|register
name|int
name|unit
decl_stmt|;
specifier|register
name|int
name|intr
decl_stmt|;
specifier|register
name|int
name|bn
decl_stmt|;
name|struct
name|sdc_softc
modifier|*
name|sdc
decl_stmt|;
name|struct
name|sdd_softc
modifier|*
name|sdd
decl_stmt|;
name|struct
name|sdst
modifier|*
name|st
decl_stmt|;
name|int
name|sz
decl_stmt|;
name|int
name|over
decl_stmt|;
name|struct
name|sc_map
modifier|*
name|map
decl_stmt|;
name|unit
operator|=
name|dev2unit
argument_list|(
name|bp
operator|->
name|b_dev
argument_list|)
expr_stmt|;
name|ii
operator|=
name|sddinfo
index|[
name|unit
index|]
expr_stmt|;
name|intr
operator|=
name|ii
operator|->
name|ii_intr
expr_stmt|;
name|sdd
operator|=
operator|&
name|sdd_softc
index|[
name|unit
index|]
expr_stmt|;
name|sdc
operator|=
operator|&
name|sdc_softc
index|[
name|ii
operator|->
name|ii_ctlr
index|]
expr_stmt|;
name|sc
operator|=
name|get_scsi
argument_list|(
name|intr
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
operator|==
operator|&
name|csdbuf
index|[
name|unit
index|]
condition|)
block|{
comment|/* do sdcmd() */
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|kernscsi
index|[
name|unit
index|]
argument_list|,
operator|(
name|caddr_t
operator|)
name|sc
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|scsi
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|b_un
operator|.
name|b_addr
operator|==
name|NULL
condition|)
block|{
name|map
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|map
operator|=
name|get_sc_map
argument_list|(
name|intr
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_map
operator|=
operator|(
expr|struct
name|sc_map
operator|*
operator|)
name|ipc_phys
argument_list|(
name|map
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* R/W */
name|ssize
operator|=
name|sdd
operator|->
name|sdd_sectsize
expr_stmt|;
name|st
operator|=
operator|&
name|sdstdrv
index|[
name|unit
index|]
expr_stmt|;
name|bn
operator|=
name|dkblock
argument_list|(
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|sdd
operator|->
name|sdd_lastblk
operator|/
name|st
operator|->
name|nspc
operator|!=
name|bn
operator|/
name|st
operator|->
name|nspc
condition|)
name|dk_seek
index|[
name|ii
operator|->
name|ii_dk
index|]
operator|++
expr_stmt|;
name|st
operator|=
operator|&
name|sdstdrv
index|[
name|unit
index|]
expr_stmt|;
name|bn
operator|=
name|dkblock
argument_list|(
name|bp
argument_list|)
expr_stmt|;
comment|/* 		 * Setup for the transfer, and get in the IOP queue. 		 */
name|scinit
argument_list|(
name|sc
argument_list|,
name|ii
operator|->
name|ii_slave
argument_list|,
name|ssize
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_ctrnscnt
operator|=
name|bp
operator|->
name|b_bcount
operator|-
name|bp
operator|->
name|b_resid
expr_stmt|;
name|map
operator|=
name|get_sc_map
argument_list|(
name|intr
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_map
operator|=
operator|(
expr|struct
name|sc_map
operator|*
operator|)
name|ipc_phys
argument_list|(
name|map
argument_list|)
expr_stmt|;
comment|/* cdb */
name|sc
operator|->
name|sc_cdb
operator|.
name|un_type1
operator|.
name|t1_opcode
operator|=
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|B_READ
operator|)
condition|?
name|SCOP_EREAD
else|:
operator|(
name|ii
operator|->
name|ii_flags
operator|&
name|SD_F_WRTVRFY
operator|)
condition|?
name|SCOP_WRTVRFY
else|:
name|SCOP_EWRITE
expr_stmt|;
ifdef|#
directive|ifdef
name|mips
block|{
name|int
name|v
decl_stmt|;
name|v
operator|=
operator|(
name|bn
operator|+
name|st
operator|->
name|sizes
index|[
name|dev2part
argument_list|(
name|bp
operator|->
name|b_dev
argument_list|)
index|]
operator|.
name|sd_blkoff
operator|)
operator|*
name|DEV_BSIZE
operator|/
name|sdd
operator|->
name|sdd_sectsize
expr_stmt|;
name|sc
operator|->
name|sc_ladhi
operator|=
name|v
operator|>>
literal|16
expr_stmt|;
name|sc
operator|->
name|sc_ladlo
operator|=
name|v
expr_stmt|;
name|v
operator|=
operator|(
name|sc
operator|->
name|sc_ctrnscnt
operator|+
name|ssize
operator|-
literal|1
operator|)
operator|/
name|ssize
expr_stmt|;
name|sc
operator|->
name|sc_cdb
operator|.
name|un_type1
operator|.
name|t1_p2
operator|=
name|v
operator|>>
literal|8
expr_stmt|;
name|sc
operator|->
name|sc_cdb
operator|.
name|un_type1
operator|.
name|t1_p3
operator|=
name|v
expr_stmt|;
block|}
else|#
directive|else
operator|*
operator|(
name|u_int
operator|*
operator|)
operator|(
operator|&
name|sc
operator|->
name|sc_cdb
operator|.
name|un_type1
operator|.
name|t1_ladhi
operator|)
operator|=
operator|(
name|bn
operator|+
name|st
operator|->
name|sizes
index|[
name|dev2part
argument_list|(
name|bp
operator|->
name|b_dev
argument_list|)
index|]
operator|.
name|sd_blkoff
operator|)
operator|*
name|DEV_BSIZE
operator|/
name|sdd
operator|->
name|sdd_sectsize
expr_stmt|;
operator|*
operator|(
name|u_short
operator|*
operator|)
operator|(
operator|&
name|sc
operator|->
name|sc_cdb
operator|.
name|un_type1
operator|.
name|t1_p2
operator|)
operator|=
operator|(
name|sc
operator|->
name|sc_ctrnscnt
operator|+
name|ssize
operator|-
literal|1
operator|)
operator|/
name|ssize
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|sdd
operator|->
name|sdd_flags
operator|&
name|SDDF_ERASEOFF
operator|)
operator|&&
operator|(
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|B_READ
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
name|sc
operator|->
name|sc_ctrl
operator|=
literal|0x40
expr_stmt|;
block|}
block|}
name|sdc
operator|->
name|sdc_firmware
operator||=
name|SDCFW_BUSY
expr_stmt|;
name|iop
comment|/**/
name|go
argument_list|(
name|ii
argument_list|,
name|map
argument_list|)
decl_stmt|;
block|}
end_function

begin_comment
comment|/*  * Now all ready to go.  */
end_comment

begin_expr_stmt
name|sddgo
argument_list|(
name|im
argument_list|)
specifier|register
expr|struct
name|iop
comment|/**/
name|_ctlr
operator|*
name|im
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|intr
decl_stmt|;
name|im
operator|->
name|im_tab
operator|.
name|b_active
operator|=
literal|2
expr_stmt|;
name|intr
operator|=
name|im
operator|->
name|im_intr
expr_stmt|;
name|sc_go
argument_list|(
name|intr
argument_list|,
name|get_scsi
argument_list|(
name|intr
argument_list|)
argument_list|,
name|SCSI_INTEN
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * copyin(), copyout() can't use in the interrupt routine.  *	because user process is changed.  */
end_comment

begin_comment
comment|/*  * Handle a disk interrupt.  *	d: controller number  */
end_comment

begin_macro
name|sdintr
argument_list|(
argument|d
argument_list|)
end_macro

begin_decl_stmt
name|int
name|d
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|iop
comment|/**/
name|_ctlr
modifier|*
name|im
decl_stmt|;
specifier|register
name|struct
name|sdc_softc
modifier|*
name|sdc
decl_stmt|;
specifier|register
name|struct
name|sdd_softc
modifier|*
name|sdd
decl_stmt|;
specifier|register
name|struct
name|scsi
modifier|*
name|sc
decl_stmt|;
specifier|register
name|int
name|intr
decl_stmt|;
specifier|register
name|int
name|unit
decl_stmt|;
specifier|register
name|int
name|slave
decl_stmt|;
specifier|register
name|int
name|as
decl_stmt|;
name|struct
name|iop
comment|/**/
name|_device
modifier|*
name|ii
decl_stmt|;
name|struct
name|sddevinfo
modifier|*
name|sdi
decl_stmt|;
name|struct
name|sc_extnd
modifier|*
name|sce
decl_stmt|;
name|struct
name|sdst
modifier|*
name|st
decl_stmt|;
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
name|struct
name|buf
modifier|*
name|dp
decl_stmt|;
name|char
modifier|*
name|erp_page
decl_stmt|;
name|int
name|code
decl_stmt|;
name|int
name|len
decl_stmt|;
name|int
name|tstatus
decl_stmt|;
name|int
name|delay_start
parameter_list|()
function_decl|;
name|int
name|delay_medrmv
parameter_list|()
function_decl|;
name|int
name|wait_re_init_done
parameter_list|()
function_decl|;
name|im
operator|=
name|sdminfo
index|[
name|d
index|]
expr_stmt|;
name|sdc
operator|=
operator|&
name|sdc_softc
index|[
name|im
operator|->
name|im_ctlr
index|]
expr_stmt|;
name|intr
operator|=
name|im
operator|->
name|im_intr
expr_stmt|;
name|as
operator|=
name|sdc
operator|->
name|sdc_softas
expr_stmt|;
name|sdc
operator|->
name|sdc_wticks
operator|=
literal|0
expr_stmt|;
name|sc
operator|=
name|get_scsi
argument_list|(
name|intr
argument_list|)
expr_stmt|;
comment|/* 	 * If SDCS_IOCTL bit is set, then don't check error. 	 */
if|if
condition|(
name|sdc
operator|->
name|sdc_state
operator|&
name|SDCS_IOCTL
condition|)
block|{
name|sdc
operator|->
name|sdc_state
operator|&=
operator|~
name|SDCS_IOCTL
expr_stmt|;
name|sdd
operator|=
operator|&
name|sdd_softc
index|[
operator|(
name|sdip
index|[
name|d
index|]
index|[
name|sc
operator|->
name|sc_identify
operator|&
name|IDT_DRMASK
index|]
operator|)
operator|->
name|ii_unit
index|]
expr_stmt|;
if|if
condition|(
name|sdc
operator|->
name|sdc_state
operator|&
name|SDCS_SCUNLOCK
condition|)
block|{
name|int
name|s
decl_stmt|;
name|sdc
operator|->
name|sdc_state
operator|&=
operator|~
name|SDCS_SCUNLOCK
expr_stmt|;
name|s
operator|=
name|splclock
argument_list|()
expr_stmt|;
if|if
condition|(
name|sdc
operator|->
name|sdc_state
operator|&
name|SDCS_OPEN_WAIT
condition|)
block|{
name|sdc
operator|->
name|sdc_state
operator|&=
operator|~
name|SDCS_OPEN_WAIT
expr_stmt|;
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
name|sdc
argument_list|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* 			 * UNLOCK SCSI access 			 */
name|sdc
operator|->
name|sdc_firmware
operator|&=
operator|~
name|SDCFW_BUSY
expr_stmt|;
block|}
return|return;
block|}
name|im
operator|->
name|im_tab
operator|.
name|b_active
operator|=
literal|1
expr_stmt|;
comment|/* 	 * Get device and block structures, and a pointer 	 * to the iop_device for the drive. 	 */
name|dp
operator|=
name|im
operator|->
name|im_tab
operator|.
name|b_actf
expr_stmt|;
name|bp
operator|=
name|dp
operator|->
name|b_actf
expr_stmt|;
name|unit
operator|=
name|dev2unit
argument_list|(
name|bp
operator|->
name|b_dev
argument_list|)
expr_stmt|;
name|ii
operator|=
name|sddinfo
index|[
name|unit
index|]
expr_stmt|;
name|slave
operator|=
name|ii
operator|->
name|ii_slave
expr_stmt|;
name|st
operator|=
operator|&
name|sdstdrv
index|[
name|unit
index|]
expr_stmt|;
name|dk_busy
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|ii
operator|->
name|ii_dk
operator|)
expr_stmt|;
name|sdd
operator|=
operator|&
name|sdd_softc
index|[
name|unit
index|]
expr_stmt|;
name|sdi
operator|=
operator|&
name|sddevinfo
index|[
name|ii
operator|->
name|ii_type
index|]
expr_stmt|;
name|sce
operator|=
operator|(
expr|struct
name|sc_extnd
operator|*
operator|)
operator|&
name|sdc_rsense
index|[
name|ii
operator|->
name|ii_ctlr
index|]
index|[
literal|0
index|]
expr_stmt|;
comment|/* 	 * Check error on the drive. 	 */
name|tstatus
operator|=
name|sc
operator|->
name|sc_tstatus
operator|&
name|TGSTMASK
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_istatus
operator|!=
name|INST_EP
condition|)
block|{
comment|/* 		 * initiator status is bad. 		 *	check& retry !! 		 */
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_istatus
operator|&
operator|(
name|INST_EP
operator||
name|INST_PRE
operator|)
operator|)
operator|==
operator|(
name|INST_EP
operator||
name|INST_PRE
operator|)
condition|)
block|{
comment|/* detect parity error or abnormal terminate */
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_istatus
operator|&
name|INST_LB
operator|)
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"sd%d: SCSI bus parity error\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|sdc
operator|->
name|sdc_countcc
operator|--
expr_stmt|;
goto|goto
name|sdintr_exec
goto|;
block|}
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_istatus
operator|&
name|INST_EP
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|sc_istatus
operator|&
operator|(
name|INST_WAIT
operator||
name|INST_IP
operator||
name|INST_WR
operator|)
condition|)
block|{
if|if
condition|(
operator|++
name|sdc
operator|->
name|sdc_retrycnt
operator|<
name|NRETRY
condition|)
block|{
name|im
operator|->
name|im_tab
operator|.
name|b_active
operator|=
literal|2
expr_stmt|;
comment|/* 					 * Konomama return sitemo, 					 * lost interrupt ni narudake deha 					 * naidarou ka ? 					 * Isso error ni sitahou ga 					 * ii nodeha naidarou ka ? 					 */
return|return;
block|}
block|}
name|printf
argument_list|(
literal|"SCSI%d: abnormal termination\n"
argument_list|,
name|intr
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"ISTAT = 0x%x, TSTAT = 0x%x\n"
argument_list|,
name|sc
operator|->
name|sc_istatus
argument_list|,
name|sc
operator|->
name|sc_tstatus
argument_list|)
expr_stmt|;
if|if
condition|(
operator|++
name|sdc
operator|->
name|sdc_nhrderr
operator|>=
name|MAXHRDERR
condition|)
block|{
name|printf
argument_list|(
literal|"SCSI%d: too many hard errors\n"
argument_list|,
name|intr
argument_list|)
expr_stmt|;
name|sdc
operator|->
name|sdc_nhrderr
operator|=
literal|0
expr_stmt|;
goto|goto
name|sdintr_error
goto|;
block|}
name|screset
argument_list|(
name|intr
argument_list|)
expr_stmt|;
goto|goto
name|sdintr_exec
goto|;
block|}
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_istatus
operator|&
operator|(
name|INST_TO
operator||
name|INST_HE
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|sc_istatus
operator|&
name|INST_HE
condition|)
block|{
comment|/* 				 * SCSI bus reset is occured. 				 *	to be continue --> hdreset() 				 */
name|re_init_done
operator|=
literal|0
expr_stmt|;
name|timeout
argument_list|(
name|wait_re_init_done
argument_list|,
name|bp
argument_list|,
literal|10
operator|*
name|hz
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|++
name|sdc
operator|->
name|sdc_nhrderr
operator|>=
name|MAXHRDERR
condition|)
block|{
name|printf
argument_list|(
literal|"SCSI%d: too many hard errors (ISTAT=0x%x)\n"
argument_list|,
name|intr
argument_list|,
name|sc
operator|->
name|sc_istatus
argument_list|)
expr_stmt|;
name|sdc
operator|->
name|sdc_nhrderr
operator|=
literal|0
expr_stmt|;
goto|goto
name|sdintr_error
goto|;
block|}
if|if
condition|(
operator|++
name|sdc
operator|->
name|sdc_retrycnt
operator|>=
name|NRETRY
condition|)
block|{
name|printf
argument_list|(
literal|"SCSI%d: too many initiator errors (ISTAT=0x%x)\n"
argument_list|,
name|intr
argument_list|,
name|sc
operator|->
name|sc_istatus
argument_list|)
expr_stmt|;
goto|goto
name|sdintr_error
goto|;
block|}
name|DELAY
argument_list|(
name|D100MSEC
operator|*
literal|10
argument_list|)
expr_stmt|;
goto|goto
name|sdintr_exec
goto|;
block|}
block|}
if|if
condition|(
name|sdd
operator|->
name|sdd_flags
operator|&
name|SDDF_SKIPCHECK
condition|)
goto|goto
name|sdintr_done
goto|;
name|check_target_status
label|:
comment|/* 	 * check target status 	 */
switch|switch
condition|(
name|sdc
operator|->
name|sdc_state
condition|)
block|{
comment|/********************************/
comment|/*				*/
comment|/*	NORMAL OPERATION	*/
comment|/*				*/
comment|/********************************/
case|case
name|SDCS_NORMAL
case|:
switch|switch
condition|(
name|tstatus
condition|)
block|{
case|case
name|TGST_GOOD
case|:
break|break;
case|case
name|TGST_CC
case|:
name|sdc
operator|->
name|sdc_state
operator||=
name|SDCS_RSENSE
expr_stmt|;
name|sdintr_rsense
label|:
name|im
operator|->
name|im_tab
operator|.
name|b_active
operator|=
literal|2
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|caddr_t
operator|)
name|sce
argument_list|,
name|RSEN_CNT
argument_list|)
expr_stmt|;
name|scop_rsense
argument_list|(
name|intr
argument_list|,
name|sc
argument_list|,
name|slave
argument_list|,
name|SCSI_INTEN
argument_list|,
name|RSEN_CNT
argument_list|,
operator|(
name|caddr_t
operator|)
name|sce
argument_list|)
expr_stmt|;
return|return;
case|case
name|TGST_BUSY
case|:
if|if
condition|(
operator|++
name|sdc
operator|->
name|sdc_retrycnt
operator|>
name|MAXRETRYCNT
condition|)
block|{
goto|goto
name|sdintr_error
goto|;
block|}
name|timeout
argument_list|(
name|sdexec
argument_list|,
operator|(
name|caddr_t
operator|)
name|bp
argument_list|,
name|hz
argument_list|)
expr_stmt|;
return|return;
default|default:
name|printf
argument_list|(
literal|"sd%d: bad target status 0x%x\n"
argument_list|,
name|unit
argument_list|,
name|sc
operator|->
name|sc_tstatus
argument_list|)
expr_stmt|;
goto|goto
name|sdintr_error
goto|;
block|}
break|break;
comment|/****************************************/
comment|/*					*/
comment|/*	REQUEST SENSE analysis		*/
comment|/*					*/
comment|/****************************************/
case|case
name|SDCS_RSENSE
case|:
case|case
name|SDCS_PREVRMB
operator||
name|SDCS_RSENSE
case|:
case|case
name|SDCS_ECC
operator||
name|SDCS_RASREAD
operator||
name|SDCS_RSENSE
case|:
case|case
name|SDCS_ECC
operator||
name|SDCS_RASWRITE
operator||
name|SDCS_RSENSE
case|:
case|case
name|SDCS_ECCOFF
operator||
name|SDCS_RSENSE
case|:
case|case
name|SDCS_ECCOFF
operator||
name|SDCS_RASBLK
operator||
name|SDCS_RSENSE
case|:
case|case
name|SDCS_ECCOFF
operator||
name|SDCS_RASBLK
operator||
name|SDCS_LOSTDATA
operator||
name|SDCS_RSENSE
case|:
case|case
name|SDCS_ECC
operator||
name|SDCS_RASBLK
operator||
name|SDCS_RSENSE
case|:
case|case
name|SDCS_ECC
operator||
name|SDCS_RASBLK
operator||
name|SDCS_LOSTDATA
operator||
name|SDCS_RSENSE
case|:
if|if
condition|(
name|tstatus
operator|!=
name|TGST_GOOD
condition|)
block|{
name|printf
argument_list|(
literal|"sd%d: bad target status 0x%x\n"
argument_list|,
name|unit
argument_list|,
name|sc
operator|->
name|sc_tstatus
argument_list|)
expr_stmt|;
goto|goto
name|sdintr_error
goto|;
block|}
comment|/* 		 * error message print out 		 */
name|code
operator|=
name|sderrordisp
argument_list|(
name|sce
argument_list|,
name|ii
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sdc
operator|->
name|sdc_state
operator|==
operator|(
name|SDCS_ECC
operator||
name|SDCS_RASBLK
operator||
name|SDCS_RSENSE
operator|)
operator|)
operator|||
operator|(
name|sdc
operator|->
name|sdc_state
operator|==
operator|(
name|SDCS_ECC
operator||
name|SDCS_RASBLK
operator||
name|SDCS_LOSTDATA
operator||
name|SDCS_RSENSE
operator|)
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"sd%d: cannot reassign block %d\n"
argument_list|,
name|unit
argument_list|,
name|sdd
operator|->
name|sdd_badsect
argument_list|)
expr_stmt|;
goto|goto
name|sdintr_error
goto|;
block|}
if|if
condition|(
name|sdc
operator|->
name|sdc_state
operator|==
operator|(
name|SDCS_PREVRMB
operator||
name|SDCS_RSENSE
operator|)
condition|)
block|{
if|if
condition|(
name|sce
operator|->
name|sce_skey
operator|==
literal|0x2
condition|)
block|{
comment|/* 				 * Not ready 				 */
name|sdc
operator|->
name|sdc_state
operator|=
name|SDCS_PREVRMB
expr_stmt|;
name|timeout
argument_list|(
name|delay_medrmv
argument_list|,
operator|(
name|caddr_t
operator|)
name|ii
argument_list|,
name|hz
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|/*			*/
comment|/* RSENSE error handler	*/
comment|/*			*/
switch|switch
condition|(
name|code
condition|)
block|{
comment|/********************************/
comment|/*	continue		*/
comment|/********************************/
comment|/* NO SENSE */
case|case
literal|0x00
case|:
comment|/* No Additional Sense Information */
comment|/* RECOVERED ERROR */
case|case
literal|0x38
case|:
comment|/* Recovered with Auto-Reallocation */
name|sdc
operator|->
name|sdc_state
operator|&=
operator|~
name|SDCS_RSENSE
expr_stmt|;
goto|goto
name|check_target_status
goto|;
comment|/********************************/
comment|/*	continue or error	*/
comment|/********************************/
comment|/* ILLEGAL REQUEST */
case|case
literal|0x21
case|:
comment|/* illegal Logical Block Address */
if|if
condition|(
operator|&
name|st
operator|->
name|sizes
index|[
name|dev2part
argument_list|(
name|bp
operator|->
name|b_dev
argument_list|)
index|]
operator|==
name|NULL
condition|)
goto|goto
name|sdintr_error
goto|;
if|if
condition|(
name|bp
operator|->
name|b_bcount
operator|>
literal|0
condition|)
block|{
name|bp
operator|->
name|b_resid
operator|=
name|bp
operator|->
name|b_bcount
operator|-
operator|(
name|sdd
operator|->
name|sdd_badsect
operator|*
name|sdd
operator|->
name|sdd_sectsize
operator|-
operator|(
name|st
operator|->
name|sizes
index|[
name|dev2part
argument_list|(
name|bp
operator|->
name|b_dev
argument_list|)
index|]
operator|.
name|sd_blkoff
operator|+
name|dkblock
argument_list|(
name|bp
argument_list|)
operator|)
operator|*
name|DEV_BSIZE
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|bp
operator|->
name|b_resid
operator|>=
name|bp
operator|->
name|b_bcount
operator|||
name|bp
operator|->
name|b_resid
operator|<=
literal|0
condition|)
block|{
comment|/* 				 * all I/O failure 				 */
name|bp
operator|->
name|b_resid
operator|=
name|bp
operator|->
name|b_bcount
expr_stmt|;
goto|goto
name|sdintr_error
goto|;
block|}
comment|/* Ignore error */
break|break;
comment|/* MEDIUM ERROR */
case|case
literal|0x31
case|:
comment|/* Medium Format Corrupted */
name|sdd
operator|->
name|sdd_flags
operator||=
name|SDDF_NONFMT
expr_stmt|;
comment|/* Ignore error */
break|break;
comment|/********************************/
comment|/*	more retry		*/
comment|/********************************/
comment|/* MEDIUM or RECOVERED ERROR */
case|case
literal|0x10
case|:
comment|/* ID CRC Error */
case|case
literal|0x12
case|:
comment|/* No Address Mark found in ID field */
case|case
literal|0x13
case|:
comment|/* No Address Mark found in Data field */
case|case
literal|0x14
case|:
comment|/* No recode found */
comment|/* H/W or MEDIUM or RECOVERED ERROR */
case|case
literal|0x15
case|:
comment|/* Seek Positioning Error */
if|if
condition|(
name|sd_ignore_error
condition|)
block|{
name|sdc
operator|->
name|sdc_state
operator|=
name|SDCS_NORMAL
expr_stmt|;
goto|goto
name|check_target_status
goto|;
block|}
comment|/* fall through */
comment|/* H/W ERROR */
case|case
literal|0x01
case|:
comment|/* No Index/Address Mark Found signal */
case|case
literal|0x02
case|:
comment|/* No Seek Complete */
case|case
literal|0x06
case|:
comment|/* No Track Zero found */
comment|/* H/W ERROR or RECOVERED ERROR */
case|case
literal|0x03
case|:
comment|/* Write Fault */
case|case
literal|0x08
case|:
comment|/* Logical Unit Communication Failure */
case|case
literal|0x09
case|:
comment|/* Track Following Error */
case|case
literal|0x0b
case|:
comment|/* Load/Unload Failure */
case|case
literal|0x0c
case|:
comment|/* Spindle Failure */
case|case
literal|0x0d
case|:
comment|/* Focus Failure */
case|case
literal|0x0e
case|:
comment|/* Tracking Failure */
case|case
literal|0x0f
case|:
comment|/* Drive Initialization Failure */
name|sdc
operator|->
name|sdc_state
operator|=
name|SDCS_ECC
operator||
name|SDCS_ECC_HOLD
operator||
name|SDCS_REZERO
expr_stmt|;
name|scinit
argument_list|(
name|sc
argument_list|,
name|slave
argument_list|,
name|sdd
operator|->
name|sdd_sectsize
argument_list|)
expr_stmt|;
comment|/* sc_cdb */
name|sc
operator|->
name|sc_opcode
operator|=
name|SCOP_REZERO
expr_stmt|;
name|sddgo
argument_list|(
name|im
argument_list|)
expr_stmt|;
return|return;
comment|/********************************/
comment|/*	re-allocate& retry	*/
comment|/********************************/
comment|/* MEDIUM or RECOVERED ERROR */
case|case
literal|0x11
case|:
comment|/* Unrecovered Read Error */
if|if
condition|(
name|sdc
operator|->
name|sdc_state
operator|&
name|SDCS_RASREAD
condition|)
block|{
name|sdintr_lostdata
label|:
name|sdc
operator|->
name|sdc_state
operator|=
name|SDCS_ECC
operator||
name|SDCS_RASBLK
operator||
name|SDCS_LOSTDATA
expr_stmt|;
name|im
operator|->
name|im_tab
operator|.
name|b_active
operator|=
literal|2
expr_stmt|;
name|scop_rasblk
argument_list|(
name|intr
argument_list|,
name|sc
argument_list|,
name|slave
argument_list|,
name|SCSI_INTEN
argument_list|,
name|sdd
operator|->
name|sdd_badsect
argument_list|)
expr_stmt|;
name|sdd
operator|->
name|sdd_flags
operator|&=
operator|~
name|SDDF_VBADSECT
expr_stmt|;
return|return;
block|}
comment|/* fall through */
comment|/* RECOVERED ERROR */
case|case
literal|0x17
case|:
comment|/* Recovered read data with retries */
case|case
literal|0x18
case|:
comment|/* Recovered read data with ECC */
comment|/* 			 * set ECC ON& more retry 			 */
if|if
condition|(
name|sdc
operator|->
name|sdc_firmware
operator|&
name|SDCFW_DEFMODE
condition|)
goto|goto
name|sdintr_ecc
goto|;
if|if
condition|(
name|sdc
operator|->
name|sdc_state
operator|&
name|SDCS_RASREAD
condition|)
goto|goto
name|sdintr_rasblk
goto|;
name|sdc
operator|->
name|sdc_state
operator|=
name|SDCS_ECC
expr_stmt|;
goto|goto
name|sdintr_msel_set
goto|;
comment|/********************************/
comment|/*	unit start& retry	*/
comment|/********************************/
comment|/* NOT READY */
case|case
literal|0x04
case|:
comment|/* Drive Not Ready */
if|if
condition|(
name|sdc
operator|->
name|sdc_state
operator|&
name|SDCS_ECC
condition|)
name|sdc
operator|->
name|sdc_state
operator|=
name|SDCS_ECCOFF
operator||
name|SDCS_RETRY
expr_stmt|;
else|else
name|sdc
operator|->
name|sdc_state
operator|=
name|SDCS_RETRY
expr_stmt|;
goto|goto
name|sdintr_stst
goto|;
comment|/********************************/
comment|/*	retry			*/
comment|/********************************/
comment|/* UNIT ATTENTION */
case|case
literal|0x28
case|:
comment|/* Medium Changed */
name|sdd
operator|->
name|sdd_flags
operator|&=
operator|~
operator|(
name|SDDF_NONFMT
operator||
name|SDDF_SAMEDSK
operator||
name|SDDF_REQ_EJECT
operator||
name|SDDF_XUSE
operator||
name|SDDF_INHRMV
operator||
name|SDDF_ERASEOFF
operator|)
expr_stmt|;
comment|/* fall through */
case|case
literal|0x29
case|:
comment|/* Power On or Reset or Bus Device Reset */
if|if
condition|(
name|sdc
operator|->
name|sdc_firmware
operator|&
name|SDCFW_RMB
condition|)
block|{
comment|/***************************/
comment|/* medium removable device */
comment|/***************************/
name|sdc
operator|->
name|sdc_state
operator|=
name|SDCS_PREVRMB
expr_stmt|;
name|im
operator|->
name|im_tab
operator|.
name|b_active
operator|=
literal|2
expr_stmt|;
name|scop_medrmv
argument_list|(
name|intr
argument_list|,
name|sc
argument_list|,
name|slave
argument_list|,
name|SCSI_INTEN
argument_list|,
name|SDRMV_PREV
argument_list|)
expr_stmt|;
return|return;
block|}
case|case
literal|0x2a
case|:
comment|/* Mode Select Parameter Changed */
case|case
literal|0x47
case|:
comment|/* SCSI interface bus parity error */
if|if
condition|(
name|sdc
operator|->
name|sdc_state
operator|&
name|SDCS_ECC
condition|)
block|{
name|sdc
operator|->
name|sdc_state
operator|=
name|SDCS_RETRY
expr_stmt|;
goto|goto
name|sdintr_msel_reset
goto|;
block|}
name|sdc
operator|->
name|sdc_state
operator|=
name|SDCS_NORMAL
expr_stmt|;
goto|goto
name|sdintr_exec
goto|;
comment|/********************************/
comment|/*	set error flag		*/
comment|/********************************/
case|case
literal|0x40
case|:
comment|/* RAM failure */
case|case
literal|0x41
case|:
comment|/* Data Path diagnostic failure */
case|case
literal|0x42
case|:
comment|/* Power On diagnostic failure */
case|case
literal|0xb2
case|:
comment|/* Caddy load/eject failed */
case|case
literal|0xb4
case|:
comment|/* Focus servo failure */
case|case
literal|0xb5
case|:
comment|/* Spindle servo failure */
case|case
literal|0xb6
case|:
comment|/* Caddy load mechanism failed */
goto|goto
name|sdintr_error
goto|;
comment|/*MO*/
case|case
literal|0x80
case|:
comment|/* Limit Laser Life */
comment|/*MO*/
case|case
literal|0x81
case|:
comment|/* Focus Coil Over-current Failure */
comment|/*MO*/
case|case
literal|0x82
case|:
comment|/* Tracking Coil Over-current Failure */
comment|/*MO*/
case|case
literal|0x83
case|:
comment|/* Temperature Alarm */
comment|/*CD*/
comment|/*	case 0x80: */
comment|/* Prevent bit is set */
comment|/*CD*/
comment|/*	case 0x81: */
comment|/* Logical unit is reserved */
comment|/*CD*/
comment|/*	case 0x82: */
comment|/* End of usr area encountered */
comment|/*CD*/
comment|/*	case 0x83: */
comment|/* Overlapped commands attempted */
goto|goto
name|sdintr_error
goto|;
default|default:
comment|/* 			 *	error detect, but what shall we do ? 			 */
comment|/*	case 0x05: */
comment|/* Drive Not Selected */
comment|/*	case 0x07: */
comment|/* Multiple Drives Selected */
comment|/*	case 0x0a: */
comment|/* No disk */
comment|/*	case 0x1a: */
comment|/* Parameter overrun */
comment|/*	case 0x1b: */
comment|/* Synchronous transfer error */
comment|/*	case 0x1d: */
comment|/* Compare error */
comment|/*	case 0x22: */
comment|/* Illegal function for device type */
comment|/*	case 0x23: */
comment|/* Illegal function for Medium type */
comment|/*	case 0x25: */
comment|/* Illegal LUN */
comment|/*	case 0x27: */
comment|/* Write Protected */
comment|/*	case 0x2b: */
comment|/* Firmware has been downloaded */
comment|/*	case 0x39: */
comment|/* Automatic Reallocation Failure */
comment|/*	case 0x43: */
comment|/* Message Reject Error */
comment|/*	case 0x45: */
comment|/* Selection/Reselection failure */
comment|/*	case 0x48: */
comment|/* Initiator detected error */
comment|/*	case 0x49: */
comment|/* Inappropriate/illegal message */
comment|/*	case 0x60: */
comment|/* COPY: STATUS error */
comment|/*	case 0x85: */
comment|/* Audio address not valid */
comment|/*	case 0xb0: */
comment|/* Caddy not inserted in drive */
comment|/*	case 0xb1: */
comment|/* Unable to recover TOC */
comment|/*	case 0xb3: */
comment|/* CIRC unrecovered data error(L-EC off) */
comment|/*	case 0xc3: */
comment|/* COPY: Illegale CDB length */
comment|/*	case 0xc5: */
comment|/* COPY: Catastrophic error */
comment|/*	case 0xc6: */
comment|/* COPY: Illegal phase change */
comment|/*	case 0xfc: */
comment|/* COPY: MODE SENSE failed */
comment|/* 			 *	medium error 			 */
comment|/*	case 0x19: */
comment|/* Defect list error */
comment|/*	case 0x1c: */
comment|/* Primary Defect List not found */
comment|/*	case 0x30: */
comment|/* Incompatible Cartridge */
comment|/*	case 0x32: */
comment|/* No Spare Defect Location Available */
comment|/*	case 0x3a: */
comment|/* Defect List Update Failure */
comment|/*	case 0x3d: */
comment|/* Defect List Not Available */
goto|goto
name|sdintr_error
goto|;
block|}
comment|/* 		 * No error detected or ignored. 		 */
break|break;
comment|/************************************************/
comment|/*						*/
comment|/*	PREVENT MEDIUM REMOVABLE COMMAND	*/
comment|/*						*/
comment|/************************************************/
case|case
name|SDCS_PREVRMB
case|:
if|if
condition|(
name|tstatus
operator|==
name|TGST_CC
condition|)
block|{
name|sdc
operator|->
name|sdc_state
operator|=
name|SDCS_PREVRMB
operator||
name|SDCS_RSENSE
expr_stmt|;
goto|goto
name|sdintr_rsense
goto|;
block|}
name|sdd
operator|->
name|sdd_flags
operator||=
name|SDDF_INHRMV
expr_stmt|;
if|if
condition|(
name|sdc
operator|->
name|sdc_state
operator|&
name|SDCS_ECC
condition|)
block|{
name|sdc
operator|->
name|sdc_state
operator|=
name|SDCS_RETRY
expr_stmt|;
goto|goto
name|sdintr_msel_reset
goto|;
block|}
name|sdc
operator|->
name|sdc_state
operator|=
name|SDCS_NORMAL
expr_stmt|;
goto|goto
name|sdintr_exec
goto|;
break|break;
comment|/****************************************/
comment|/*					*/
comment|/*	REZERO done& RETRY COMMAND	*/
comment|/*					*/
comment|/****************************************/
case|case
name|SDCS_ECC
operator||
name|SDCS_ECC_HOLD
operator||
name|SDCS_REZERO
case|:
if|if
condition|(
name|sdc
operator|->
name|sdc_firmware
operator|&
name|SDCFW_DEFMODE
condition|)
block|{
name|sdc
operator|->
name|sdc_state
operator|=
name|SDCS_ECC
operator||
name|SDCS_ECC_HOLD
operator||
name|SDCS_RETRY
expr_stmt|;
goto|goto
name|sdintr_stst
goto|;
block|}
name|sdc
operator|->
name|sdc_state
operator|=
name|SDCS_ECC
operator||
name|SDCS_ECC_HOLD
expr_stmt|;
goto|goto
name|sdintr_msel_set
goto|;
comment|/********************************/
comment|/*				*/
comment|/*	RETRY COMMAND		*/
comment|/*				*/
comment|/********************************/
case|case
name|SDCS_RETRY
case|:
name|sdc
operator|->
name|sdc_state
operator|=
name|SDCS_NORMAL
expr_stmt|;
goto|goto
name|sdintr_exec
goto|;
comment|/************************************************/
comment|/*						*/
comment|/*	ERROR CORRECTION ON MODE SELECT result	*/
comment|/*						*/
comment|/************************************************/
case|case
name|SDCS_ECC
case|:
if|if
condition|(
name|tstatus
operator|!=
name|TGST_GOOD
condition|)
block|{
name|printf
argument_list|(
literal|"sd%d: bad target status 0x%x\n"
argument_list|,
name|unit
argument_list|,
name|sc
operator|->
name|sc_tstatus
argument_list|)
expr_stmt|;
goto|goto
name|sdintr_error
goto|;
block|}
name|sdintr_ecc
label|:
if|if
condition|(
name|bp
operator|->
name|b_flags
operator|&
name|B_READ
condition|)
block|{
name|sdc
operator|->
name|sdc_state
operator|=
name|SDCS_ECC
operator||
name|SDCS_RASREAD
expr_stmt|;
name|im
operator|->
name|im_tab
operator|.
name|b_active
operator|=
literal|2
expr_stmt|;
name|scop_rdwr
argument_list|(
name|intr
argument_list|,
name|sc
argument_list|,
name|slave
argument_list|,
name|SCSI_INTEN
argument_list|,
name|B_READ
argument_list|,
name|sdwork
argument_list|,
name|sdd
operator|->
name|sdd_badsect
argument_list|,
name|sdd
operator|->
name|sdd_sectsize
argument_list|)
expr_stmt|;
return|return;
block|}
goto|goto
name|sdintr_rasblk
goto|;
comment|/************************************************/
comment|/*						*/
comment|/*	READ DATA from BAD BLOCK result		*/
comment|/*						*/
comment|/************************************************/
case|case
name|SDCS_ECC
operator||
name|SDCS_RASREAD
case|:
if|if
condition|(
name|tstatus
operator|==
name|TGST_CC
condition|)
block|{
name|sdc
operator|->
name|sdc_state
operator|=
name|SDCS_ECC
operator||
name|SDCS_RASREAD
operator||
name|SDCS_RSENSE
expr_stmt|;
goto|goto
name|sdintr_rsense
goto|;
block|}
elseif|else
if|if
condition|(
name|tstatus
operator|!=
name|TGST_GOOD
condition|)
block|{
name|printf
argument_list|(
literal|"sd%d: bad target status 0x%x\n"
argument_list|,
name|unit
argument_list|,
name|sc
operator|->
name|sc_tstatus
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"sd%d: cannot read block\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
goto|goto
name|sdintr_error
goto|;
block|}
name|sdintr_rasblk
label|:
if|if
condition|(
name|sdd
operator|->
name|sdd_flags
operator|&
name|SDDF_WPROTECT
condition|)
goto|goto
name|sdintr_error
goto|;
name|sdc
operator|->
name|sdc_state
operator|=
name|SDCS_ECC
operator||
name|SDCS_RASBLK
expr_stmt|;
name|im
operator|->
name|im_tab
operator|.
name|b_active
operator|=
literal|2
expr_stmt|;
name|scop_rasblk
argument_list|(
name|intr
argument_list|,
name|sc
argument_list|,
name|slave
argument_list|,
name|SCSI_INTEN
argument_list|,
name|sdd
operator|->
name|sdd_badsect
argument_list|)
expr_stmt|;
name|sdd
operator|->
name|sdd_flags
operator|&=
operator|~
name|SDDF_VBADSECT
expr_stmt|;
return|return;
comment|/****************************************/
comment|/*					*/
comment|/*	REASSIGN BLOCK result		*/
comment|/*					*/
comment|/****************************************/
case|case
name|SDCS_ECC
operator||
name|SDCS_RASBLK
case|:
if|if
condition|(
name|tstatus
operator|==
name|TGST_CC
condition|)
block|{
name|sdc
operator|->
name|sdc_state
operator|=
name|SDCS_ECC
operator||
name|SDCS_RASBLK
operator||
name|SDCS_RSENSE
expr_stmt|;
goto|goto
name|sdintr_rsense
goto|;
block|}
elseif|else
if|if
condition|(
name|tstatus
operator|!=
name|TGST_GOOD
condition|)
block|{
name|printf
argument_list|(
literal|"sd%d: bad target status 0x%x\n"
argument_list|,
name|unit
argument_list|,
name|sc
operator|->
name|sc_tstatus
argument_list|)
expr_stmt|;
goto|goto
name|sdintr_error
goto|;
block|}
name|printf
argument_list|(
literal|"sd%d: block %d is reassigned\n"
argument_list|,
name|unit
argument_list|,
name|sdd
operator|->
name|sdd_badsect
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|b_flags
operator|&
name|B_READ
condition|)
block|{
name|sdintr_raswrite
label|:
name|sdc
operator|->
name|sdc_state
operator|=
name|SDCS_ECC
operator||
name|SDCS_RASWRITE
expr_stmt|;
name|im
operator|->
name|im_tab
operator|.
name|b_active
operator|=
literal|2
expr_stmt|;
name|scop_rdwr
argument_list|(
name|intr
argument_list|,
name|sc
argument_list|,
name|slave
argument_list|,
name|SCSI_INTEN
argument_list|,
name|B_WRITE
argument_list|,
name|sdwork
argument_list|,
name|sdd
operator|->
name|sdd_badsect
argument_list|,
name|sdd
operator|->
name|sdd_sectsize
argument_list|)
expr_stmt|;
return|return;
block|}
name|sdc
operator|->
name|sdc_state
operator|=
name|SDCS_RETRY
expr_stmt|;
goto|goto
name|sdintr_msel_reset
goto|;
comment|/************************************************/
comment|/*						*/
comment|/*	WRITE DATA to REASSIGNED BLOCK result	*/
comment|/*						*/
comment|/************************************************/
case|case
name|SDCS_ECC
operator||
name|SDCS_RASWRITE
case|:
if|if
condition|(
name|tstatus
operator|==
name|TGST_CC
condition|)
block|{
name|sdc
operator|->
name|sdc_state
operator|=
name|SDCS_ECC
operator||
name|SDCS_RASWRITE
operator||
name|SDCS_RSENSE
expr_stmt|;
goto|goto
name|sdintr_rsense
goto|;
block|}
elseif|else
if|if
condition|(
name|tstatus
operator|!=
name|TGST_GOOD
condition|)
block|{
name|printf
argument_list|(
literal|"sd%d: bad target status 0x%x\n"
argument_list|,
name|unit
argument_list|,
name|sc
operator|->
name|sc_tstatus
argument_list|)
expr_stmt|;
goto|goto
name|sdintr_error
goto|;
block|}
name|sdc
operator|->
name|sdc_state
operator|=
name|SDCS_RETRY
expr_stmt|;
goto|goto
name|sdintr_msel_reset
goto|;
comment|/****************************************/
comment|/*					*/
comment|/*	reset ECC& RETRY TIMES		*/
comment|/*					*/
comment|/****************************************/
case|case
name|SDCS_ECCOFF
operator||
name|SDCS_RETRY
case|:
name|sdc
operator|->
name|sdc_state
operator|=
name|SDCS_RETRY
expr_stmt|;
goto|goto
name|sdintr_msel_reset
goto|;
comment|/********************************************************/
comment|/*							*/
comment|/*	READ DATA from BAD BLOCK result in faliure	*/
comment|/*							*/
comment|/********************************************************/
case|case
name|SDCS_ECC
operator||
name|SDCS_RASBLK
operator||
name|SDCS_LOSTDATA
case|:
if|if
condition|(
name|tstatus
operator|==
name|TGST_CC
condition|)
block|{
name|sdc
operator|->
name|sdc_state
operator|=
name|SDCS_ECC
operator||
name|SDCS_RASBLK
operator||
name|SDCS_LOSTDATA
operator||
name|SDCS_RSENSE
expr_stmt|;
goto|goto
name|sdintr_rsense
goto|;
block|}
elseif|else
if|if
condition|(
name|tstatus
operator|!=
name|TGST_GOOD
condition|)
block|{
name|printf
argument_list|(
literal|"sd%d: rasblk: bad target status 0x%x\n"
argument_list|,
name|unit
argument_list|,
name|sc
operator|->
name|sc_tstatus
argument_list|)
expr_stmt|;
goto|goto
name|sdintr_error
goto|;
block|}
name|bzero
argument_list|(
name|sdwork
argument_list|,
name|sdd
operator|->
name|sdd_sectsize
argument_list|)
expr_stmt|;
name|scop_rdwr
argument_list|(
name|intr
argument_list|,
name|sc
argument_list|,
name|slave
argument_list|,
name|SCSI_INTDIS
argument_list|,
name|B_WRITE
argument_list|,
name|sdwork
argument_list|,
name|sdd
operator|->
name|sdd_badsect
argument_list|,
name|sdd
operator|->
name|sdd_sectsize
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"sd%d: block %d is reassigned (lost data)\n"
argument_list|,
name|unit
argument_list|,
name|sdd
operator|->
name|sdd_badsect
argument_list|)
expr_stmt|;
goto|goto
name|sdintr_error
goto|;
comment|/****************************************/
comment|/*					*/
comment|/*	issue START UNIT command	*/
comment|/*					*/
comment|/****************************************/
case|case
name|SDCS_ECC
operator||
name|SDCS_ECC_HOLD
case|:
comment|/* 		 * Drive not ready... so start.. 		 */
name|sdc
operator|->
name|sdc_state
operator|=
name|SDCS_ECC
operator||
name|SDCS_ECC_HOLD
operator||
name|SDCS_RETRY
expr_stmt|;
name|sdintr_stst
label|:
name|timeout
argument_list|(
name|delay_start
argument_list|,
operator|(
name|caddr_t
operator|)
name|ii
argument_list|,
name|hz
argument_list|)
expr_stmt|;
return|return;
comment|/****************************************/
comment|/*					*/
comment|/*	RETRY with ECC& more RETRYS	*/
comment|/*					*/
comment|/****************************************/
case|case
name|SDCS_ECC
operator||
name|SDCS_ECC_HOLD
operator||
name|SDCS_RETRY
case|:
name|sdc
operator|->
name|sdc_state
operator|=
name|SDCS_ECCOFF
expr_stmt|;
name|sdintr_exec
label|:
if|if
condition|(
name|sdc
operator|->
name|sdc_countcc
operator|++
operator|>
name|MAXRETRYCNT
condition|)
goto|goto
name|sdintr_error
goto|;
name|sdexec
argument_list|(
name|bp
argument_list|)
expr_stmt|;
return|return;
comment|/****************************************/
comment|/*					*/
comment|/*	reset ECC& RETRY TIMES		*/
comment|/*					*/
comment|/****************************************/
case|case
name|SDCS_ECCOFF
case|:
if|if
condition|(
name|tstatus
operator|==
name|TGST_CC
condition|)
block|{
name|sdc
operator|->
name|sdc_state
operator|=
name|SDCS_ECCOFF
operator||
name|SDCS_RSENSE
expr_stmt|;
goto|goto
name|sdintr_rsense
goto|;
block|}
elseif|else
if|if
condition|(
name|tstatus
operator|!=
name|TGST_GOOD
condition|)
block|{
name|printf
argument_list|(
literal|"sd%d: bad target status 0x%x\n"
argument_list|,
name|unit
argument_list|,
name|sc
operator|->
name|sc_tstatus
argument_list|)
expr_stmt|;
goto|goto
name|sdintr_error
goto|;
block|}
name|sdc
operator|->
name|sdc_state
operator|=
name|SDCS_NORMAL
expr_stmt|;
goto|goto
name|sdintr_msel_reset
goto|;
name|sdintr_msel_set
label|:
comment|/* 		 * set more ERROR RECOVERY PARAMETERS 		 */
if|if
condition|(
operator|(
name|erp_page
operator|=
name|sdi
operator|->
name|max_ERP_page
operator|)
operator|==
name|NULL
condition|)
goto|goto
name|check_target_status
goto|;
name|bzero
argument_list|(
operator|(
name|caddr_t
operator|)
name|sc
operator|->
name|sc_param
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|len
operator|=
operator|*
operator|(
name|erp_page
operator|+
literal|1
operator|)
operator|+
literal|2
expr_stmt|;
name|bcopy
argument_list|(
name|erp_page
argument_list|,
operator|&
name|sc
operator|->
name|sc_param
index|[
literal|4
index|]
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|im
operator|->
name|im_tab
operator|.
name|b_active
operator|=
literal|2
expr_stmt|;
name|scop_mselect
argument_list|(
name|intr
argument_list|,
name|sc
argument_list|,
name|slave
argument_list|,
name|SCSI_INTEN
argument_list|,
operator|(
name|SDM_PF
operator|<<
literal|24
operator|)
operator|+
name|len
operator|+
literal|4
argument_list|,
operator|(
name|caddr_t
operator|)
literal|0
argument_list|)
expr_stmt|;
return|return;
name|sdintr_msel_reset
label|:
if|if
condition|(
name|sdc
operator|->
name|sdc_firmware
operator|&
name|SDCFW_DEFMODE
condition|)
goto|goto
name|sdintr_exec
goto|;
comment|/* 		 * set normal ERROR RECOVERY PARAMETERS 		 */
name|erp_page
operator|=
name|sdi
operator|->
name|ERP_page
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|caddr_t
operator|)
name|sc
operator|->
name|sc_param
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|len
operator|=
operator|*
operator|(
name|erp_page
operator|+
literal|1
operator|)
operator|+
literal|2
expr_stmt|;
name|bcopy
argument_list|(
name|erp_page
argument_list|,
operator|&
name|sc
operator|->
name|sc_param
index|[
literal|4
index|]
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|im
operator|->
name|im_tab
operator|.
name|b_active
operator|=
literal|2
expr_stmt|;
name|scop_mselect
argument_list|(
name|intr
argument_list|,
name|sc
argument_list|,
name|slave
argument_list|,
name|SCSI_INTEN
argument_list|,
operator|(
name|SDM_PF
operator|<<
literal|24
operator|)
operator|+
name|len
operator|+
literal|4
argument_list|,
operator|(
name|caddr_t
operator|)
literal|0
argument_list|)
expr_stmt|;
return|return;
name|sdintr_error
label|:
name|bp
operator|->
name|b_flags
operator||=
name|B_ERROR
expr_stmt|;
if|if
condition|(
name|sdc
operator|->
name|sdc_state
operator|&
name|SDCS_ECC
condition|)
block|{
name|sdc
operator|->
name|sdc_state
operator|=
name|SDCS_NORMAL
expr_stmt|;
goto|goto
name|sdintr_msel_reset
goto|;
block|}
break|break;
comment|/* 	 * UNKNOWN STATUS 	 */
default|default:
name|printf
argument_list|(
literal|"sd%d: unknown status (0x%x)\n"
argument_list|,
name|unit
argument_list|,
name|sdc
operator|->
name|sdc_state
argument_list|)
expr_stmt|;
goto|goto
name|sdintr_error
goto|;
block|}
name|sdintr_done
label|:
if|if
condition|(
name|bp
operator|->
name|b_flags
operator|&
name|B_ERROR
condition|)
block|{
name|printf
argument_list|(
literal|"%s%d%c: hard error sn%d "
argument_list|,
literal|"sd"
argument_list|,
name|minor
argument_list|(
name|bp
operator|->
name|b_dev
argument_list|)
operator|>>
literal|3
argument_list|,
literal|'a'
operator|+
operator|(
name|minor
argument_list|(
name|bp
operator|->
name|b_dev
argument_list|)
operator|&
literal|07
operator|)
argument_list|,
name|bp
operator|->
name|b_blkno
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|sdd
operator|->
name|sdd_lastblk
operator|=
name|dkblock
argument_list|(
name|bp
argument_list|)
operator|+
name|btodb
argument_list|(
name|bp
operator|->
name|b_bcount
operator|-
name|bp
operator|->
name|b_resid
argument_list|)
expr_stmt|;
name|sdc
operator|->
name|sdc_countcc
operator|=
literal|0
expr_stmt|;
name|sdc
operator|->
name|sdc_retrycnt
operator|=
literal|0
expr_stmt|;
name|sdd
operator|->
name|sdd_flags
operator|&=
operator|~
name|SDDF_VBADSECT
expr_stmt|;
if|if
condition|(
name|im
operator|->
name|im_tab
operator|.
name|b_active
condition|)
block|{
name|im
operator|->
name|im_tab
operator|.
name|b_active
operator|=
literal|0
expr_stmt|;
name|im
operator|->
name|im_tab
operator|.
name|b_errcnt
operator|=
literal|0
expr_stmt|;
name|im
operator|->
name|im_tab
operator|.
name|b_actf
operator|=
literal|0
expr_stmt|;
name|dp
operator|->
name|b_active
operator|=
literal|0
expr_stmt|;
name|dp
operator|->
name|b_errcnt
operator|=
literal|0
expr_stmt|;
name|dp
operator|->
name|b_actf
operator|=
name|bp
operator|->
name|b_actf
expr_stmt|;
if|if
condition|(
name|bp
operator|==
operator|&
name|csdbuf
index|[
name|unit
index|]
condition|)
block|{
specifier|register
name|struct
name|scsi
modifier|*
name|ksc
init|=
operator|&
name|kernscsi
index|[
name|unit
index|]
decl_stmt|;
comment|/* copy result */
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
name|sc
argument_list|,
operator|(
name|caddr_t
operator|)
name|ksc
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|scsi
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|iodone
argument_list|(
name|bp
argument_list|)
expr_stmt|;
comment|/* 		 * If this unit has more work to do, 		 * then start it up right away. 		 */
if|if
condition|(
name|dp
operator|->
name|b_actf
condition|)
name|sdustart
argument_list|(
name|ii
argument_list|)
expr_stmt|;
block|}
name|as
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|slave
operator|)
expr_stmt|;
name|sdc
operator|->
name|sdc_state
operator|=
name|SDCS_NORMAL
expr_stmt|;
comment|/* 	 * UNLOCK SCSI access 	 */
name|sdc
operator|->
name|sdc_firmware
operator|&=
operator|~
name|SDCFW_BUSY
expr_stmt|;
name|start
label|:
comment|/* 	 * Process other units which need attention. 	 * For each unit which needs attention, call 	 * the unit start routine to place the slave 	 * on the controller device queue. 	 */
name|sdc
operator|->
name|sdc_softas
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|unit
operator|=
name|ffs
argument_list|(
name|as
argument_list|)
condition|)
block|{
name|unit
operator|--
expr_stmt|;
name|as
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|unit
operator|)
expr_stmt|;
name|sdustart
argument_list|(
name|sdip
index|[
name|im
operator|->
name|im_ctlr
index|]
index|[
name|unit
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * If the controller is not transferring, 	 * but there are devices ready to transfer, 	 * start the controller. 	 */
if|if
condition|(
name|im
operator|->
name|im_tab
operator|.
name|b_actf
operator|&&
name|im
operator|->
name|im_tab
operator|.
name|b_active
operator|==
literal|0
condition|)
operator|(
name|void
operator|)
name|sdstart
argument_list|(
name|im
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|wait_re_init_done
argument_list|(
name|bp
argument_list|)
specifier|register
expr|struct
name|buf
operator|*
name|bp
expr_stmt|;
end_expr_stmt

begin_block
block|{
if|if
condition|(
name|re_init_done
operator|>=
literal|2
condition|)
name|sdexec
argument_list|(
name|bp
argument_list|)
expr_stmt|;
else|else
name|timeout
argument_list|(
name|wait_re_init_done
argument_list|,
name|bp
argument_list|,
literal|10
operator|*
name|hz
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|delay_start
argument_list|(
argument|ii
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|iop
comment|/**/
name|_device
modifier|*
name|ii
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|ii
operator|->
name|ii_mi
operator|->
name|im_tab
operator|.
name|b_active
operator|=
literal|2
expr_stmt|;
name|scop_stst
argument_list|(
name|ii
operator|->
name|ii_intr
argument_list|,
name|get_scsi
argument_list|(
name|ii
operator|->
name|ii_intr
argument_list|)
argument_list|,
name|ii
operator|->
name|ii_slave
argument_list|,
name|SCSI_INTEN
argument_list|,
name|SDSS_START
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|delay_medrmv
argument_list|(
argument|ii
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|iop
comment|/**/
name|_device
modifier|*
name|ii
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|ii
operator|->
name|ii_mi
operator|->
name|im_tab
operator|.
name|b_active
operator|=
literal|2
expr_stmt|;
name|scop_medrmv
argument_list|(
name|ii
operator|->
name|ii_intr
argument_list|,
name|get_scsi
argument_list|(
name|ii
operator|->
name|ii_intr
argument_list|)
argument_list|,
name|ii
operator|->
name|ii_slave
argument_list|,
name|SCSI_INTEN
argument_list|,
name|SDRMV_PREV
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|sderrordisp
argument_list|(
argument|rsen_data
argument_list|,
argument|ii
argument_list|)
end_macro

begin_decl_stmt
name|u_char
modifier|*
name|rsen_data
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|iop
comment|/**/
name|_device
modifier|*
name|ii
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|sc_extnd
modifier|*
name|sce
decl_stmt|;
specifier|register
name|struct
name|sdc_softc
modifier|*
name|sdc
decl_stmt|;
specifier|register
name|struct
name|sdd_softc
modifier|*
name|sdd
decl_stmt|;
specifier|register
name|int
name|unit
decl_stmt|;
specifier|register
name|int
name|code
decl_stmt|;
name|struct
name|sc_nextnd
modifier|*
name|scn
decl_stmt|;
name|struct
name|msg_list
modifier|*
name|ml
decl_stmt|;
name|unit
operator|=
name|ii
operator|->
name|ii_unit
expr_stmt|;
name|sdc
operator|=
operator|&
name|sdc_softc
index|[
name|ii
operator|->
name|ii_ctlr
index|]
expr_stmt|;
name|sdd
operator|=
operator|&
name|sdd_softc
index|[
name|unit
index|]
expr_stmt|;
name|sce
operator|=
operator|(
expr|struct
name|sc_extnd
operator|*
operator|)
name|rsen_data
expr_stmt|;
if|if
condition|(
name|sce
operator|->
name|sce_extend
operator|==
literal|0x70
condition|)
block|{
comment|/* 		 * Extended Sense data 		 */
name|code
operator|=
name|sce
operator|->
name|sce_sdecode
expr_stmt|;
if|if
condition|(
name|code
operator|&
literal|0x80
condition|)
name|ml
operator|=
name|ecodelist_mo
expr_stmt|;
else|else
name|ml
operator|=
name|ecodelist
expr_stmt|;
if|if
condition|(
name|sce
operator|->
name|sce_advalid
condition|)
block|{
if|if
condition|(
operator|(
name|sdd
operator|->
name|sdd_flags
operator|&
name|SDDF_VBADSECT
operator|)
operator|==
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|mips
name|sdd
operator|->
name|sdd_badsect
operator|=
operator|(
name|sce
operator|->
name|sce_infob1
operator|<<
literal|24
operator|)
operator|+
operator|(
name|sce
operator|->
name|sce_infob2
operator|<<
literal|16
operator|)
operator|+
operator|(
name|sce
operator|->
name|sce_infob3
operator|<<
literal|8
operator|)
operator|+
operator|(
name|sce
operator|->
name|sce_infob4
operator|)
expr_stmt|;
else|#
directive|else
name|sdd
operator|->
name|sdd_badsect
operator|=
operator|*
operator|(
operator|(
name|int
operator|*
operator|)
operator|&
name|sce
operator|->
name|sce_infob1
operator|)
expr_stmt|;
endif|#
directive|endif
name|sdd
operator|->
name|sdd_flags
operator||=
name|SDDF_VBADSECT
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|rsense_msg_disp
operator|&&
operator|!
name|isdispmsg
argument_list|(
name|code
argument_list|,
name|ml
argument_list|,
name|sdc
operator|->
name|sdc_countcc
argument_list|)
condition|)
return|return
operator|(
name|code
operator|)
return|;
if|if
condition|(
name|sce
operator|->
name|sce_advalid
condition|)
block|{
name|int
name|sn
decl_stmt|;
ifdef|#
directive|ifdef
name|mips
name|sn
operator|=
operator|(
name|sce
operator|->
name|sce_infob1
operator|<<
literal|24
operator|)
operator|+
operator|(
name|sce
operator|->
name|sce_infob2
operator|<<
literal|16
operator|)
operator|+
operator|(
name|sce
operator|->
name|sce_infob3
operator|<<
literal|8
operator|)
operator|+
operator|(
name|sce
operator|->
name|sce_infob4
operator|)
expr_stmt|;
else|#
directive|else
name|sn
operator|=
operator|*
operator|(
operator|(
name|int
operator|*
operator|)
operator|&
name|sce
operator|->
name|sce_infob1
operator|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|sce
operator|->
name|sce_addlen
operator|>=
literal|5
condition|)
block|{
name|printf
argument_list|(
literal|"sd%d(sn %d): skey=0x%x, code=0x%x\n"
argument_list|,
name|unit
argument_list|,
name|sn
argument_list|,
name|sce
operator|->
name|sce_skey
argument_list|,
name|code
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"sd%d(sn %d): skey=0x%x\n"
argument_list|,
name|unit
argument_list|,
name|sn
argument_list|,
name|sce
operator|->
name|sce_skey
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|sce
operator|->
name|sce_addlen
operator|>=
literal|5
condition|)
name|printf
argument_list|(
literal|"sd%d: skey=0x%x, code=0x%x\n"
argument_list|,
name|unit
argument_list|,
name|sce
operator|->
name|sce_skey
argument_list|,
name|code
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"sd%d: skey=0x%x\n"
argument_list|,
name|unit
argument_list|,
name|sce
operator|->
name|sce_skey
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sce
operator|->
name|sce_addlen
operator|>=
literal|6
condition|)
name|printf
argument_list|(
literal|"sd%d: ASCQ=0x%x\n"
argument_list|,
name|unit
argument_list|,
name|sce
operator|->
name|sce_ascq
argument_list|)
expr_stmt|;
block|{
name|u_char
modifier|*
name|p
decl_stmt|;
name|int
name|len
decl_stmt|;
name|len
operator|=
literal|8
operator|+
name|sce
operator|->
name|sce_addlen
expr_stmt|;
if|if
condition|(
name|len
operator|>
name|RSEN_CNT
condition|)
name|len
operator|=
name|RSEN_CNT
expr_stmt|;
name|p
operator|=
operator|(
name|u_char
operator|*
operator|)
name|sce
expr_stmt|;
name|printf
argument_list|(
literal|"sd%d: "
argument_list|,
name|unit
argument_list|)
expr_stmt|;
while|while
condition|(
name|len
operator|--
condition|)
name|printf
argument_list|(
literal|"%x "
argument_list|,
operator|*
name|p
operator|++
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 		 * Non-extended Sense data 		 */
name|scn
operator|=
operator|(
expr|struct
name|sc_nextnd
operator|*
operator|)
name|rsen_data
expr_stmt|;
name|code
operator|=
name|scn
operator|->
name|scn_ecode
expr_stmt|;
name|ml
operator|=
name|ecodelist
expr_stmt|;
if|if
condition|(
name|sce
operator|->
name|sce_advalid
condition|)
block|{
if|if
condition|(
operator|(
name|sdd
operator|->
name|sdd_flags
operator|&
name|SDDF_VBADSECT
operator|)
operator|==
literal|0
condition|)
block|{
name|sdd
operator|->
name|sdd_badsect
operator|=
name|scn
operator|->
name|scn_secno
expr_stmt|;
name|sdd
operator|->
name|sdd_flags
operator||=
name|SDDF_VBADSECT
expr_stmt|;
block|}
block|}
if|if
condition|(
name|rsense_msg_disp
operator|||
name|isdispmsg
argument_list|(
name|code
argument_list|,
name|ml
argument_list|,
name|sdc
operator|->
name|sdc_countcc
argument_list|)
condition|)
block|{
if|if
condition|(
name|sce
operator|->
name|sce_advalid
condition|)
name|printf
argument_list|(
literal|"sd%d(sn %d): code=0x%x\n"
argument_list|,
name|unit
argument_list|,
name|scn
operator|->
name|scn_secno
argument_list|,
name|code
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"sd%d: code=0x%x\n"
argument_list|,
name|unit
argument_list|,
name|code
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|code
operator|)
return|;
block|}
end_block

begin_function
name|void
name|sdminphys
parameter_list|(
name|bp
parameter_list|)
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
block|{
if|if
condition|(
name|bp
operator|->
name|b_bcount
operator|>
name|MAXSDPHYS
condition|)
name|bp
operator|->
name|b_bcount
operator|=
name|MAXSDPHYS
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|sdphysio
value|physio
end_define

begin_expr_stmt
name|sdread
argument_list|(
name|dev
argument_list|,
name|uio
argument_list|,
name|flag
argument_list|)
specifier|register
name|dev_t
name|dev
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|struct
name|uio
modifier|*
name|uio
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|flag
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|iop
comment|/**/
name|_device
modifier|*
name|ii
decl_stmt|;
specifier|register
name|int
name|unit
decl_stmt|;
name|unit
operator|=
name|dev2unit
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|unit
operator|>=
name|nsd
operator|||
operator|(
name|ii
operator|=
name|sddinfo
index|[
name|unit
index|]
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
return|return
operator|(
name|sdphysio
argument_list|(
name|sdstrategy
argument_list|,
operator|&
name|rsdbuf
index|[
name|unit
index|]
argument_list|,
name|dev
argument_list|,
name|B_READ
argument_list|,
name|sdminphys
argument_list|,
name|uio
argument_list|)
operator|)
return|;
block|}
end_block

begin_expr_stmt
name|sdwrite
argument_list|(
name|dev
argument_list|,
name|uio
argument_list|,
name|flag
argument_list|)
specifier|register
name|dev_t
name|dev
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|struct
name|uio
modifier|*
name|uio
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|flag
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|iop
comment|/**/
name|_device
modifier|*
name|ii
decl_stmt|;
specifier|register
name|int
name|unit
decl_stmt|;
name|unit
operator|=
name|dev2unit
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|unit
operator|>=
name|nsd
operator|||
operator|(
name|ii
operator|=
name|sddinfo
index|[
name|unit
index|]
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
return|return
operator|(
name|sdphysio
argument_list|(
name|sdstrategy
argument_list|,
operator|&
name|rsdbuf
index|[
name|unit
index|]
argument_list|,
name|dev
argument_list|,
name|B_WRITE
argument_list|,
name|sdminphys
argument_list|,
name|uio
argument_list|)
operator|)
return|;
block|}
end_block

begin_define
define|#
directive|define
name|MAXBL
value|256
end_define

begin_struct
struct|struct
name|Partinfo
block|{
comment|/*00*/
name|daddr_t
name|dp_nblocks
decl_stmt|;
comment|/* partition size (sector #) */
comment|/*04*/
name|daddr_t
name|dp_blkoff
decl_stmt|;
comment|/* partition start block */
comment|/*08*/
block|}
struct|;
end_struct

begin_struct
struct|struct
name|dkst
block|{
comment|/*00*/
name|int
name|dks_ncyl
decl_stmt|;
comment|/* # cylinders / drive */
comment|/*04*/
name|int
name|dks_ntrak
decl_stmt|;
comment|/* # tracks / cylinder */
comment|/*08*/
name|int
name|dks_nsect
decl_stmt|;
comment|/* # sectors / track */
comment|/*0c*/
name|int
name|dks_rps
decl_stmt|;
comment|/* # revolutions / second */
comment|/*10*/
block|}
struct|;
end_struct

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_macro
name|sdioctl
argument_list|(
argument|dev
argument_list|,
argument|cmd
argument_list|,
argument|data
argument_list|,
argument|flag
argument_list|)
end_macro

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|cmd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|caddr_t
name|data
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|flag
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|iop
comment|/**/
name|_device
modifier|*
name|ii
decl_stmt|;
specifier|register
name|struct
name|sc_ureq
modifier|*
name|scu
decl_stmt|;
specifier|register
name|struct
name|sdst
modifier|*
name|st
decl_stmt|;
specifier|register
name|struct
name|scsi
modifier|*
name|sc
decl_stmt|;
specifier|register
name|int
name|unit
decl_stmt|;
specifier|register
name|int
name|ctlr
decl_stmt|;
specifier|register
name|int
name|slave
decl_stmt|;
name|struct
name|sdc_softc
modifier|*
name|sdc
decl_stmt|;
name|struct
name|sdd_softc
modifier|*
name|sdd
decl_stmt|;
name|struct
name|Partinfo
modifier|*
name|pi
decl_stmt|;
name|struct
name|dkst
modifier|*
name|di
decl_stmt|;
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
name|struct
name|sddevinfo
modifier|*
name|sdi
decl_stmt|;
name|struct
name|sdst
modifier|*
name|stp
decl_stmt|;
name|struct
name|scsi
name|uscsi
decl_stmt|;
name|int
name|error
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|s
decl_stmt|;
name|int
name|tstatus
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|blkno
decl_stmt|,
name|count
decl_stmt|;
name|unit
operator|=
name|dev2unit
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|unit
operator|>=
name|nsd
operator|||
operator|(
name|ii
operator|=
name|sddinfo
index|[
name|unit
index|]
operator|)
operator|==
literal|0
operator|||
name|ii
operator|->
name|ii_alive
operator|==
literal|0
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|slave
operator|=
name|ii
operator|->
name|ii_slave
expr_stmt|;
name|ctlr
operator|=
name|ii
operator|->
name|ii_ctlr
expr_stmt|;
name|sdc
operator|=
operator|&
name|sdc_softc
index|[
name|ctlr
index|]
expr_stmt|;
name|sdd
operator|=
operator|&
name|sdd_softc
index|[
name|unit
index|]
expr_stmt|;
name|sc
operator|=
operator|&
name|uscsi
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|DIOCWLABEL
case|:
if|if
condition|(
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|&
name|SD_F_ENW
condition|)
name|ii
operator|->
name|ii_flags
operator||=
name|SD_F_ENW
expr_stmt|;
else|else
name|ii
operator|->
name|ii_flags
operator|&=
operator|~
name|SD_F_ENW
expr_stmt|;
break|break;
case|case
name|DIOCGDINFO
case|:
operator|*
operator|(
expr|struct
name|disklabel
operator|*
operator|)
name|data
operator|=
name|sdlabel
index|[
name|unit
index|]
expr_stmt|;
break|break;
case|case
name|DIOCSDINFO
case|:
name|sdlabel
index|[
name|unit
index|]
operator|=
operator|*
operator|(
expr|struct
name|disklabel
operator|*
operator|)
name|data
expr_stmt|;
name|disklabel2sdst
argument_list|(
name|unit
argument_list|,
operator|&
name|sdlabel
index|[
name|unit
index|]
argument_list|,
operator|&
name|sdstdrv
index|[
name|unit
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|DIOCWDINFO
case|:
case|case
name|DKIOCRGEOM
case|:
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|DKIOCRGEOM
case|:
name|st
operator|=
operator|&
name|sdstdrv
index|[
name|unit
index|]
expr_stmt|;
name|sdi
operator|=
operator|&
name|sddevinfo
index|[
name|ii
operator|->
name|ii_type
index|]
expr_stmt|;
name|stp
operator|=
name|sdi
operator|->
name|sdstp
expr_stmt|;
name|st
operator|->
name|ncyl
operator|=
name|stp
operator|->
name|ncyl
expr_stmt|;
comment|/* # cylinders / drive */
name|st
operator|->
name|ntrak
operator|=
name|stp
operator|->
name|ntrak
expr_stmt|;
comment|/* # tracks / cylinder */
name|st
operator|->
name|nsect
operator|=
name|stp
operator|->
name|nsect
expr_stmt|;
comment|/* # sectors / track */
name|st
operator|->
name|rps
operator|=
name|stp
operator|->
name|rps
expr_stmt|;
comment|/* # revolutions / second */
name|sdst2disklabel
argument_list|(
name|unit
argument_list|,
name|st
argument_list|,
operator|&
name|sdlabel
index|[
name|unit
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|==
name|RGEOM_SDINFO
condition|)
goto|goto
name|done
goto|;
break|break;
case|case
name|DIOCWDINFO
case|:
name|sdlabel
index|[
name|unit
index|]
operator|=
operator|*
operator|(
expr|struct
name|disklabel
operator|*
operator|)
name|data
expr_stmt|;
break|break;
block|}
comment|/* 		 * Common code for DIOCWDINFO and DKIOCRGEOM 		 */
comment|/**** READ sector 0 ****/
comment|/* 		 * LOCK sdtmp buffer 		 */
name|s
operator|=
name|splclock
argument_list|()
expr_stmt|;
while|while
condition|(
name|sdtmp_stat
operator|&
name|B_BUSY
condition|)
block|{
name|sdtmp_stat
operator||=
name|B_WANTED
expr_stmt|;
name|sleep
argument_list|(
operator|(
name|caddr_t
operator|)
name|sdtmp
argument_list|,
name|PRIBIO
argument_list|)
expr_stmt|;
block|}
name|sdtmp_stat
operator||=
name|B_BUSY
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|sdtmp
argument_list|,
name|DEV_BSIZE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sdd
operator|->
name|sdd_flags
operator|&
name|SDDF_NONFMT
operator|)
operator|==
literal|0
condition|)
block|{
name|scinit
argument_list|(
operator|&
name|uscsi
argument_list|,
name|ii
operator|->
name|ii_slave
argument_list|,
name|sdd
operator|->
name|sdd_sectsize
argument_list|)
expr_stmt|;
name|uscsi
operator|.
name|sc_cpoint
operator|=
name|sdtmp
expr_stmt|;
name|uscsi
operator|.
name|sc_ctrnscnt
operator|=
name|DEV_BSIZE
expr_stmt|;
name|uscsi
operator|.
name|sc_opcode
operator|=
name|SCOP_READ
expr_stmt|;
name|uscsi
operator|.
name|sc_lad
operator|=
literal|0
expr_stmt|;
name|uscsi
operator|.
name|sc_count
operator|=
literal|1
expr_stmt|;
name|error
operator|=
name|sdcmd
argument_list|(
name|dev
argument_list|,
operator|&
name|uscsi
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
name|EIO
expr_stmt|;
block|}
if|if
condition|(
name|error
condition|)
block|{
comment|/* 			 * UNLOCK sdtmp buffer 			 */
name|s
operator|=
name|splclock
argument_list|()
expr_stmt|;
if|if
condition|(
name|sdtmp_stat
operator|&
name|B_WANTED
condition|)
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
name|sdtmp
argument_list|)
expr_stmt|;
name|sdtmp_stat
operator|&=
operator|~
operator|(
name|B_BUSY
operator||
name|B_WANTED
operator|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
break|break;
block|}
operator|*
operator|(
expr|struct
name|disklabel
operator|*
operator|)
operator|(
name|sdtmp
operator|+
name|LABELOFFSET
operator|)
operator|=
name|sdlabel
index|[
name|unit
index|]
expr_stmt|;
comment|/**** WRITE sector 0 ****/
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|sdd
operator|->
name|sdd_flags
operator|&
name|SDDF_NONFMT
operator|)
operator|==
literal|0
condition|)
block|{
name|scinit
argument_list|(
operator|&
name|uscsi
argument_list|,
name|ii
operator|->
name|ii_slave
argument_list|,
name|sdd
operator|->
name|sdd_sectsize
argument_list|)
expr_stmt|;
name|uscsi
operator|.
name|sc_cpoint
operator|=
name|sdtmp
expr_stmt|;
name|uscsi
operator|.
name|sc_ctrnscnt
operator|=
name|DEV_BSIZE
expr_stmt|;
name|uscsi
operator|.
name|sc_opcode
operator|=
name|SCOP_WRITE
expr_stmt|;
name|uscsi
operator|.
name|sc_lad
operator|=
literal|0
expr_stmt|;
name|uscsi
operator|.
name|sc_count
operator|=
literal|1
expr_stmt|;
name|error
operator|=
name|sdcmd
argument_list|(
name|dev
argument_list|,
operator|&
name|uscsi
argument_list|)
expr_stmt|;
block|}
else|else
name|error
operator|=
name|EIO
expr_stmt|;
block|}
comment|/* 		 * UNLOCK sdtmp buffer 		 */
name|s
operator|=
name|splclock
argument_list|()
expr_stmt|;
if|if
condition|(
name|sdtmp_stat
operator|&
name|B_WANTED
condition|)
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
name|sdtmp
argument_list|)
expr_stmt|;
name|sdtmp_stat
operator|&=
operator|~
operator|(
name|B_BUSY
operator||
name|B_WANTED
operator|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|disklabel2sdst
argument_list|(
name|unit
argument_list|,
operator|&
name|sdlabel
index|[
name|unit
index|]
argument_list|,
operator|&
name|sdstdrv
index|[
name|unit
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|DKIOCGGEOM
case|:
name|st
operator|=
operator|&
name|sdstdrv
index|[
name|unit
index|]
expr_stmt|;
name|di
operator|=
operator|(
expr|struct
name|dkst
operator|*
operator|)
name|data
expr_stmt|;
name|di
operator|->
name|dks_ncyl
operator|=
name|st
operator|->
name|ncyl
expr_stmt|;
comment|/* # cylinders / drive */
name|di
operator|->
name|dks_ntrak
operator|=
name|st
operator|->
name|ntrak
expr_stmt|;
comment|/* # tracks / cylinder */
name|di
operator|->
name|dks_nsect
operator|=
name|st
operator|->
name|nsect
expr_stmt|;
comment|/* # sectors / track */
name|di
operator|->
name|dks_rps
operator|=
name|st
operator|->
name|rps
expr_stmt|;
comment|/* # revolutions / second */
break|break;
case|case
name|DKIOCSGEOM
case|:
name|st
operator|=
operator|&
name|sdstdrv
index|[
name|unit
index|]
expr_stmt|;
name|di
operator|=
operator|(
expr|struct
name|dkst
operator|*
operator|)
name|data
expr_stmt|;
name|st
operator|->
name|ncyl
operator|=
name|di
operator|->
name|dks_ncyl
expr_stmt|;
comment|/* # cylinders / drive */
name|st
operator|->
name|ntrak
operator|=
name|di
operator|->
name|dks_ntrak
expr_stmt|;
comment|/* # tracks / cylinder */
name|st
operator|->
name|nsect
operator|=
name|di
operator|->
name|dks_nsect
expr_stmt|;
comment|/* # sectors / track */
name|st
operator|->
name|rps
operator|=
name|di
operator|->
name|dks_rps
expr_stmt|;
comment|/* # revolutions / second */
name|sdst2disklabel
argument_list|(
name|unit
argument_list|,
name|st
argument_list|,
operator|&
name|sdlabel
index|[
name|unit
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|DKIOCGPART
case|:
case|case
name|DKIOCSPART
case|:
comment|/* 		 * partition information 		 */
name|st
operator|=
operator|&
name|sdstdrv
index|[
name|unit
index|]
expr_stmt|;
name|pi
operator|=
operator|(
expr|struct
name|Partinfo
operator|*
operator|)
name|data
expr_stmt|;
if|if
condition|(
name|cmd
operator|==
name|DKIOCGPART
condition|)
block|{
name|pi
operator|->
name|dp_nblocks
operator|=
name|st
operator|->
name|sizes
index|[
name|dev2part
argument_list|(
name|dev
argument_list|)
index|]
operator|.
name|sd_nblocks
expr_stmt|;
name|pi
operator|->
name|dp_blkoff
operator|=
name|st
operator|->
name|sizes
index|[
name|dev2part
argument_list|(
name|dev
argument_list|)
index|]
operator|.
name|sd_blkoff
expr_stmt|;
block|}
else|else
block|{
name|st
operator|->
name|sizes
index|[
name|dev2part
argument_list|(
name|dev
argument_list|)
index|]
operator|.
name|sd_nblocks
operator|=
name|pi
operator|->
name|dp_nblocks
expr_stmt|;
name|st
operator|->
name|sizes
index|[
name|dev2part
argument_list|(
name|dev
argument_list|)
index|]
operator|.
name|sd_blkoff
operator|=
name|pi
operator|->
name|dp_blkoff
expr_stmt|;
name|sdst2disklabel
argument_list|(
name|unit
argument_list|,
name|st
argument_list|,
operator|&
name|sdlabel
index|[
name|unit
index|]
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|DKIOCGUNIT
case|:
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
name|slave
expr_stmt|;
break|break;
case|case
name|DKIOCGCHAN
case|:
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
name|ii
operator|->
name|ii_intr
expr_stmt|;
break|break;
case|case
name|DKIOCSEEK
case|:
name|scinit
argument_list|(
name|sc
argument_list|,
name|slave
argument_list|,
name|sdd
operator|->
name|sdd_sectsize
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_opcode
operator|=
name|SCOP_SEEK
expr_stmt|;
name|sc
operator|->
name|sc_lad
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
name|data
expr_stmt|;
operator|(
name|void
operator|)
name|sdcmd
argument_list|(
name|dev
argument_list|,
name|sc
argument_list|)
expr_stmt|;
name|tstatus
operator|=
name|sc
operator|->
name|sc_tstatus
operator|&
name|TGSTMASK
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_istatus
operator|!=
name|INST_EP
operator|)
operator|||
operator|(
name|tstatus
operator|!=
name|TGST_GOOD
operator|)
condition|)
name|error
operator|=
name|ESPIPE
expr_stmt|;
break|break;
case|case
name|DKIOCRSEC0
case|:
case|case
name|DKIOCRBOOT1
case|:
case|case
name|DKIOCRBOOT
case|:
if|if
condition|(
name|sdd
operator|->
name|sdd_flags
operator|&
name|SDDF_NONFMT
condition|)
block|{
name|error
operator|=
name|EIO
expr_stmt|;
break|break;
block|}
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|DKIOCRSEC0
case|:
name|blkno
operator|=
literal|0
expr_stmt|;
name|count
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|DKIOCRBOOT1
case|:
name|blkno
operator|=
literal|1
expr_stmt|;
name|count
operator|=
literal|15
expr_stmt|;
break|break;
default|default:
name|blkno
operator|=
literal|0
expr_stmt|;
name|count
operator|=
literal|16
expr_stmt|;
block|}
name|p
operator|=
operator|(
name|char
operator|*
operator|)
operator|*
operator|(
name|int
operator|*
operator|)
name|data
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|!
name|error
operator|&&
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|s
operator|=
name|splclock
argument_list|()
expr_stmt|;
while|while
condition|(
name|sdtmp_stat
operator|&
name|B_BUSY
condition|)
block|{
name|sdtmp_stat
operator||=
name|B_WANTED
expr_stmt|;
name|sleep
argument_list|(
operator|(
name|caddr_t
operator|)
name|sdtmp
argument_list|,
name|PRIBIO
argument_list|)
expr_stmt|;
block|}
name|sdtmp_stat
operator||=
name|B_BUSY
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|scinit
argument_list|(
operator|&
name|uscsi
argument_list|,
name|ii
operator|->
name|ii_slave
argument_list|,
name|sdd
operator|->
name|sdd_sectsize
argument_list|)
expr_stmt|;
name|uscsi
operator|.
name|sc_cpoint
operator|=
name|sdtmp
expr_stmt|;
name|uscsi
operator|.
name|sc_ctrnscnt
operator|=
name|DEV_BSIZE
expr_stmt|;
name|uscsi
operator|.
name|sc_opcode
operator|=
name|SCOP_READ
expr_stmt|;
name|uscsi
operator|.
name|sc_lad
operator|=
name|blkno
expr_stmt|;
name|uscsi
operator|.
name|sc_count
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|error
operator|=
name|sdcmd
argument_list|(
name|dev
argument_list|,
operator|&
name|uscsi
argument_list|)
condition|)
goto|goto
name|dkior_done
goto|;
if|if
condition|(
name|error
operator|=
name|copyout
argument_list|(
name|sdtmp
argument_list|,
name|p
argument_list|,
name|DEV_BSIZE
argument_list|)
condition|)
goto|goto
name|dkior_done
goto|;
name|blkno
operator|++
expr_stmt|;
name|p
operator|+=
name|DEV_BSIZE
expr_stmt|;
name|dkior_done
label|:
name|s
operator|=
name|splclock
argument_list|()
expr_stmt|;
if|if
condition|(
name|sdtmp_stat
operator|&
name|B_WANTED
condition|)
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
name|sdtmp
argument_list|)
expr_stmt|;
name|sdtmp_stat
operator|&=
operator|~
operator|(
name|B_BUSY
operator||
name|B_WANTED
operator|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|DKIOCWSEC0
case|:
case|case
name|DKIOCWBOOT1
case|:
case|case
name|DKIOCWBOOT
case|:
if|if
condition|(
name|sdd
operator|->
name|sdd_flags
operator|&
name|SDDF_NONFMT
condition|)
block|{
name|error
operator|=
name|EIO
expr_stmt|;
break|break;
block|}
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|DKIOCWSEC0
case|:
name|blkno
operator|=
literal|0
expr_stmt|;
name|count
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|DKIOCWBOOT1
case|:
name|blkno
operator|=
literal|1
expr_stmt|;
name|count
operator|=
literal|15
expr_stmt|;
break|break;
default|default:
name|blkno
operator|=
literal|0
expr_stmt|;
name|count
operator|=
literal|16
expr_stmt|;
block|}
name|p
operator|=
operator|(
name|char
operator|*
operator|)
operator|*
operator|(
name|int
operator|*
operator|)
name|data
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|!
name|error
operator|&&
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|s
operator|=
name|splclock
argument_list|()
expr_stmt|;
while|while
condition|(
name|sdtmp_stat
operator|&
name|B_BUSY
condition|)
block|{
name|sdtmp_stat
operator||=
name|B_WANTED
expr_stmt|;
name|sleep
argument_list|(
name|sdtmp
argument_list|,
name|PRIBIO
argument_list|)
expr_stmt|;
block|}
name|sdtmp_stat
operator||=
name|B_BUSY
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|=
name|copyin
argument_list|(
name|p
argument_list|,
name|sdtmp
argument_list|,
name|DEV_BSIZE
argument_list|)
condition|)
goto|goto
name|dkiow_done
goto|;
name|scinit
argument_list|(
operator|&
name|uscsi
argument_list|,
name|ii
operator|->
name|ii_slave
argument_list|,
name|sdd
operator|->
name|sdd_sectsize
argument_list|)
expr_stmt|;
name|uscsi
operator|.
name|sc_cpoint
operator|=
name|sdtmp
expr_stmt|;
name|uscsi
operator|.
name|sc_ctrnscnt
operator|=
name|DEV_BSIZE
expr_stmt|;
name|uscsi
operator|.
name|sc_opcode
operator|=
name|SCOP_WRITE
expr_stmt|;
name|uscsi
operator|.
name|sc_lad
operator|=
name|blkno
expr_stmt|;
name|uscsi
operator|.
name|sc_count
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|error
operator|=
name|sdcmd
argument_list|(
name|dev
argument_list|,
operator|&
name|uscsi
argument_list|)
condition|)
goto|goto
name|dkiow_done
goto|;
name|blkno
operator|++
expr_stmt|;
name|p
operator|+=
name|DEV_BSIZE
expr_stmt|;
name|dkiow_done
label|:
name|s
operator|=
name|splclock
argument_list|()
expr_stmt|;
if|if
condition|(
name|sdtmp_stat
operator|&
name|B_WANTED
condition|)
name|wakeup
argument_list|(
name|sdtmp
argument_list|)
expr_stmt|;
name|sdtmp_stat
operator|&=
operator|~
operator|(
name|B_BUSY
operator||
name|B_WANTED
operator|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SDIOC_PRVRMV
case|:
case|case
name|SDIOC_ALWRMV
case|:
comment|/* 		 * prevent/allow medium removal 		 */
name|scinit
argument_list|(
name|sc
argument_list|,
name|ii
operator|->
name|ii_slave
argument_list|,
name|sdd
operator|->
name|sdd_sectsize
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_opcode
operator|=
name|SCOP_MEDRMV
expr_stmt|;
name|sc
operator|->
name|sc_count
operator|=
operator|(
name|cmd
operator|==
name|SDIOC_PRVRMV
operator|)
condition|?
name|SDRMV_PREV
else|:
name|SDRMV_ALLOW
expr_stmt|;
if|if
condition|(
name|cmd
operator|==
name|SDIOC_PRVRMV
condition|)
name|sdd
operator|->
name|sdd_flags
operator||=
name|SDDF_INHRMV
expr_stmt|;
else|else
name|sdd
operator|->
name|sdd_flags
operator|&=
operator|~
name|SDDF_INHRMV
expr_stmt|;
name|error
operator|=
name|sdcmd
argument_list|(
name|dev
argument_list|,
name|sc
argument_list|)
expr_stmt|;
break|break;
case|case
name|SDIOC_SXUSE
case|:
if|if
condition|(
name|isalone
argument_list|(
name|unit
argument_list|)
operator|!=
name|ONLY_ONE
condition|)
return|return
operator|(
name|EBUSY
operator|)
return|;
name|sdd
operator|->
name|sdd_flags
operator||=
name|SDDF_XUSE
expr_stmt|;
break|break;
case|case
name|SDIOC_RXUSE
case|:
name|sdd
operator|->
name|sdd_flags
operator|&=
operator|~
name|SDDF_XUSE
expr_stmt|;
break|break;
case|case
name|SDIOC_ERSON
case|:
name|sdd
operator|->
name|sdd_flags
operator|&=
operator|~
name|SDDF_ERASEOFF
expr_stmt|;
break|break;
case|case
name|SDIOC_ERSOFF
case|:
if|if
condition|(
operator|(
name|sdd
operator|->
name|sdd_flags
operator|&
name|SDDF_XUSE
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|EBUSY
operator|)
return|;
name|sdd
operator|->
name|sdd_flags
operator||=
name|SDDF_ERASEOFF
expr_stmt|;
name|sdd
operator|->
name|sdd_flags
operator|&=
operator|~
name|SDDF_NONFMT
expr_stmt|;
break|break;
case|case
name|SDIOC_FORMAT
case|:
comment|/* 		 * format unit 		 */
if|if
condition|(
operator|(
name|flag
operator|&
name|FWRITE
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|isalone
argument_list|(
name|unit
argument_list|)
operator|!=
name|ONLY_ONE
condition|)
return|return
operator|(
name|EBUSY
operator|)
return|;
name|sdd
operator|->
name|sdd_flags
operator||=
name|SDDF_XUSE
expr_stmt|;
name|sdd
operator|->
name|sdd_flags
operator|&=
operator|~
operator|(
name|SDDF_NONFMT
operator||
name|SDDF_FMTDONE
operator||
name|SDDF_SAMEDSK
operator|)
expr_stmt|;
name|scinit
argument_list|(
name|sc
argument_list|,
name|ii
operator|->
name|ii_slave
argument_list|,
name|sdd
operator|->
name|sdd_sectsize
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_ctrnscnt
operator|=
literal|4
expr_stmt|;
name|sc
operator|->
name|sc_opcode
operator|=
name|SCOP_FMT
expr_stmt|;
name|sc
operator|->
name|sc_lad
operator|=
operator|(
operator|(
name|sddevinfo
index|[
name|ii
operator|->
name|ii_type
index|]
operator|.
name|fmt_opts
operator|&
name|FMT_DLFMT
operator|)
operator||
name|SDF_FMTDAT
operator|)
operator|<<
literal|16
expr_stmt|;
switch|switch
condition|(
name|sddevinfo
index|[
name|ii
operator|->
name|ii_type
index|]
operator|.
name|type
condition|)
block|{
case|case
name|SMO_S501
case|:
case|case
name|SMO_S501_ISO
case|:
case|case
name|SMO_S501_ISO2
case|:
name|sc
operator|->
name|sc_lad
operator||=
operator|(
operator|(
name|SDF_MKCDA
operator||
name|SDF_MKPLST
operator|)
operator|<<
literal|8
operator|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|{
name|struct
name|fmt_data
modifier|*
name|fdata
init|=
operator|(
expr|struct
name|fmt_data
operator|*
operator|)
name|data
decl_stmt|;
name|error
operator|=
name|copyin
argument_list|(
operator|(
name|caddr_t
operator|)
name|fdata
operator|->
name|dlh
argument_list|,
name|sc
operator|->
name|sc_param
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|sdd
operator|->
name|sdd_flags
operator|&=
operator|~
name|SDDF_XUSE
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|fdata
operator|->
name|noglist
condition|)
name|sc
operator|->
name|sc_lad
operator||=
operator|(
name|SDF_CMPLST
operator|<<
literal|16
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|sdd
operator|->
name|sdd_flags
operator|&
name|SDDF_ERASEOFF
condition|)
name|sc
operator|->
name|sc_ctrl
operator|=
literal|0x40
expr_stmt|;
name|error
operator|=
name|sdcmd
argument_list|(
name|dev
argument_list|,
name|sc
argument_list|)
expr_stmt|;
name|sdd
operator|->
name|sdd_flags
operator|&=
operator|~
name|SDDF_XUSE
expr_stmt|;
break|break;
case|case
name|SDIOC_FORMAT2
case|:
comment|/* 		 * format unit 		 */
if|if
condition|(
operator|(
name|flag
operator|&
name|FWRITE
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|isalone
argument_list|(
name|unit
argument_list|)
operator|!=
name|ONLY_ONE
condition|)
return|return
operator|(
name|EBUSY
operator|)
return|;
name|sdd
operator|->
name|sdd_flags
operator||=
name|SDDF_XUSE
expr_stmt|;
name|sdd
operator|->
name|sdd_flags
operator|&=
operator|~
operator|(
name|SDDF_NONFMT
operator||
name|SDDF_FMTDONE
operator||
name|SDDF_SAMEDSK
operator|)
expr_stmt|;
name|scu
operator|=
operator|(
expr|struct
name|sc_ureq
operator|*
operator|)
name|data
expr_stmt|;
name|error
operator|=
name|sd_scu_exec
argument_list|(
name|dev
argument_list|,
name|scu
argument_list|,
name|sc
argument_list|)
expr_stmt|;
name|sdd
operator|->
name|sdd_flags
operator|&=
operator|~
name|SDDF_XUSE
expr_stmt|;
break|break;
case|case
name|SDIOC_GSTOPT
case|:
case|case
name|SDIOC_SSTOPT
case|:
comment|/* 		 * get/set stop-unit timer 		 */
if|if
condition|(
name|cmd
operator|==
name|SDIOC_GSTOPT
condition|)
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
name|sdd
operator|->
name|sdd_stoptime
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|==
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|sdd
operator|->
name|sdd_stoptime
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
name|data
expr_stmt|;
block|}
break|break;
case|case
name|SDIOC_SEJECT
case|:
comment|/* 		 * set auto eject flag 		 */
name|sdd
operator|->
name|sdd_flags
operator||=
name|SDDF_REQ_EJECT
expr_stmt|;
break|break;
case|case
name|SDIOC_GFLAGS
case|:
comment|/* 		 * get ii->ii_flags 		 */
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
name|ii
operator|->
name|ii_flags
expr_stmt|;
break|break;
case|case
name|SDIOC_SFLAGS
case|:
comment|/* 		 * set ii->ii_flags 		 */
name|ii
operator|->
name|ii_flags
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
name|data
expr_stmt|;
break|break;
case|case
name|SDIOC_RASBLK
case|:
comment|/* 		 * reassign block 		 */
block|{
name|struct
name|sc_rab
modifier|*
name|sca
init|=
operator|(
expr|struct
name|sc_rab
operator|*
operator|)
name|sc
operator|->
name|sc_param
decl_stmt|;
name|scinit
argument_list|(
name|sc
argument_list|,
name|ii
operator|->
name|ii_slave
argument_list|,
name|sdd
operator|->
name|sdd_sectsize
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_opcode
operator|=
name|SCOP_RASBLK
expr_stmt|;
name|sc
operator|->
name|sc_ctrnscnt
operator|=
literal|8
expr_stmt|;
name|sca
operator|->
name|sca_dllen
operator|=
literal|4
expr_stmt|;
name|sca
operator|->
name|sca_dlad
index|[
literal|0
index|]
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
name|data
expr_stmt|;
name|error
operator|=
name|sdcmd
argument_list|(
name|dev
argument_list|,
name|sc
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SDIOC_GNICKNAME
case|:
block|{
name|int
name|len
decl_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|sddevinfo
index|[
name|ii
operator|->
name|ii_type
index|]
operator|.
name|call_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>
name|IOCPARM_MASK
condition|)
name|len
operator|=
name|IOCPARM_MASK
expr_stmt|;
name|error
operator|=
name|copyout
argument_list|(
operator|(
name|caddr_t
operator|)
name|sddevinfo
index|[
name|ii
operator|->
name|ii_type
index|]
operator|.
name|call_name
argument_list|,
operator|(
name|caddr_t
operator|)
operator|*
operator|(
name|int
operator|*
operator|)
name|data
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SDIOC_GTYPINDEX
case|:
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
operator|(
name|int
operator|)
name|ii
operator|->
name|ii_type
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|SDIOC_SSYNCPARAM
case|case
name|SDIOC_SSYNCPARAM
case|:
block|{
name|struct
name|sync_param
modifier|*
name|syncp
decl_stmt|;
name|syncp
operator|=
operator|(
expr|struct
name|sync_param
operator|*
operator|)
name|data
expr_stmt|;
name|scinit
argument_list|(
name|sc
argument_list|,
name|ii
operator|->
name|ii_slave
argument_list|,
name|sdd
operator|->
name|sdd_sectsize
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_opcode
operator|=
name|SCOP_TST
expr_stmt|;
name|sc
operator|->
name|sc_message
operator|=
name|MSG_EXTND
expr_stmt|;
comment|/* extended message */
name|sc
operator|->
name|sc_param
index|[
literal|0
index|]
operator|=
name|MSG_EXTND
expr_stmt|;
name|sc
operator|->
name|sc_param
index|[
literal|1
index|]
operator|=
literal|0x03
expr_stmt|;
name|sc
operator|->
name|sc_param
index|[
literal|2
index|]
operator|=
literal|0x01
expr_stmt|;
comment|/* synchronous transfer */
name|sc
operator|->
name|sc_param
index|[
literal|3
index|]
operator|=
name|syncp
operator|->
name|tr_period
expr_stmt|;
comment|/* transfer period */
name|sc
operator|->
name|sc_param
index|[
literal|4
index|]
operator|=
name|syncp
operator|->
name|tr_offset
expr_stmt|;
comment|/* REQ offset */
operator|(
name|void
operator|)
name|sdcmd
argument_list|(
name|dev
argument_list|,
name|sc
argument_list|)
expr_stmt|;
name|syncp
operator|=
operator|&
name|sd_sync_param
index|[
name|unit
index|]
expr_stmt|;
name|syncp
operator|->
name|tr_period
operator|=
name|sc
operator|->
name|sc_param
index|[
literal|3
index|]
expr_stmt|;
name|syncp
operator|->
name|tr_offset
operator|=
name|sc
operator|->
name|sc_param
index|[
literal|4
index|]
expr_stmt|;
if|if
condition|(
name|syncp
operator|->
name|tr_offset
condition|)
name|sdd
operator|->
name|sdd_flags
operator||=
name|SDDF_SYNCTR
expr_stmt|;
else|else
name|sdd
operator|->
name|sdd_flags
operator|&=
operator|~
name|SDDF_SYNCTR
expr_stmt|;
block|}
break|break;
case|case
name|SDIOC_GSYNCPARAM
case|:
block|{
name|struct
name|sync_param
modifier|*
name|syncp
init|=
operator|(
expr|struct
name|sync_param
operator|*
operator|)
name|data
decl_stmt|;
name|syncp
operator|->
name|tr_period
operator|=
name|sd_sync_param
index|[
name|unit
index|]
operator|.
name|tr_period
expr_stmt|;
name|syncp
operator|->
name|tr_offset
operator|=
name|sd_sync_param
index|[
name|unit
index|]
operator|.
name|tr_offset
expr_stmt|;
block|}
break|break;
endif|#
directive|endif
comment|/* SDIOC_SSYNCPARAM */
case|case
name|MTIOCTOP
case|:
block|{
specifier|register
name|struct
name|mtop
modifier|*
name|mtop
init|=
operator|(
expr|struct
name|mtop
operator|*
operator|)
name|data
decl_stmt|;
specifier|register
name|int
name|lba
decl_stmt|;
name|int
name|rest
decl_stmt|;
name|int
name|blength
decl_stmt|;
switch|switch
condition|(
name|mtop
operator|->
name|mt_op
condition|)
block|{
case|case
name|MTOFFL
case|:
comment|/* 				 * set auto eject flag 				 */
name|sdd
operator|->
name|sdd_flags
operator||=
name|SDDF_REQ_EJECT
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|MTERASE
case|case
name|MTERASE
case|:
if|if
condition|(
name|isalone
argument_list|(
name|unit
argument_list|)
operator|!=
name|ONLY_ONE
condition|)
return|return
operator|(
name|EBUSY
operator|)
return|;
name|sdd
operator|->
name|sdd_flags
operator||=
name|SDDF_XUSE
expr_stmt|;
name|st
operator|=
operator|&
name|sdstdrv
index|[
name|unit
index|]
expr_stmt|;
comment|/* 				 * MO disk erase 				 *	block 0 to end (C partition) 				 */
name|lba
operator|=
literal|0
expr_stmt|;
name|rest
operator|=
name|sdd
operator|->
name|sdd_nsect
expr_stmt|;
comment|/* C part size */
while|while
condition|(
name|rest
operator|>
literal|0
condition|)
block|{
name|blength
operator|=
operator|(
name|rest
operator|>
name|MAXBL
operator|)
condition|?
name|MAXBL
else|:
name|rest
expr_stmt|;
name|scinit
argument_list|(
name|sc
argument_list|,
name|ii
operator|->
name|ii_slave
argument_list|,
name|sdd
operator|->
name|sdd_sectsize
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_opcode
operator|=
name|SCOP_MOERASE
expr_stmt|;
name|sc
operator|->
name|sc_lad
operator|=
name|lba
expr_stmt|;
name|sc
operator|->
name|sc_count
operator|=
operator|(
name|blength
operator|%
name|MAXBL
operator|)
expr_stmt|;
operator|(
name|void
operator|)
name|sdcmd
argument_list|(
name|dev
argument_list|,
name|sc
argument_list|)
expr_stmt|;
name|lba
operator|+=
name|blength
expr_stmt|;
name|rest
operator|-=
name|blength
expr_stmt|;
block|}
name|sdd
operator|->
name|sdd_flags
operator|&=
operator|~
name|SDDF_XUSE
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* MTERASE */
default|default:
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
block|}
break|break;
case|case
name|SCSIIOCCMD
case|:
name|scu
operator|=
operator|(
expr|struct
name|sc_ureq
operator|*
operator|)
name|data
expr_stmt|;
if|if
condition|(
operator|(
name|scu
operator|->
name|scu_count
operator|>
literal|0
operator|)
operator|&&
name|scu
operator|->
name|scu_addr
condition|)
block|{
if|if
condition|(
name|useracc
argument_list|(
name|scu
operator|->
name|scu_addr
argument_list|,
name|scu
operator|->
name|scu_count
argument_list|,
name|B_WRITE
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|EFAULT
expr_stmt|;
break|break;
block|}
block|}
name|error
operator|=
name|sd_scu_exec
argument_list|(
name|dev
argument_list|,
name|scu
argument_list|,
name|sc
argument_list|)
expr_stmt|;
break|break;
case|case
name|SDIOC_INQUIRY
case|:
comment|/* 		 * LOCK sdtmp buffer 		 */
name|s
operator|=
name|splclock
argument_list|()
expr_stmt|;
while|while
condition|(
name|sdtmp_stat
operator|&
name|B_BUSY
condition|)
block|{
name|sdtmp_stat
operator||=
name|B_WANTED
expr_stmt|;
name|sleep
argument_list|(
operator|(
name|caddr_t
operator|)
name|sdtmp
argument_list|,
name|PRIBIO
argument_list|)
expr_stmt|;
block|}
name|sdtmp_stat
operator||=
name|B_BUSY
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|caddr_t
operator|)
name|sdtmp
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sc_inq
argument_list|)
argument_list|)
expr_stmt|;
name|scinit
argument_list|(
operator|&
name|uscsi
argument_list|,
name|ii
operator|->
name|ii_slave
argument_list|,
name|sdd
operator|->
name|sdd_sectsize
argument_list|)
expr_stmt|;
name|uscsi
operator|.
name|sc_cpoint
operator|=
name|sdtmp
expr_stmt|;
name|uscsi
operator|.
name|sc_ctrnscnt
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sc_inq
argument_list|)
expr_stmt|;
name|uscsi
operator|.
name|sc_opcode
operator|=
name|SCOP_INQUIRY
expr_stmt|;
name|uscsi
operator|.
name|sc_count
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sc_inq
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|sdcmd
argument_list|(
name|dev
argument_list|,
operator|&
name|uscsi
argument_list|)
operator|)
operator|==
literal|0
condition|)
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
name|sdtmp
argument_list|,
name|data
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sc_inq
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 		 * UNLOCK open 		 */
name|s
operator|=
name|splclock
argument_list|()
expr_stmt|;
if|if
condition|(
name|sdtmp_stat
operator|&
name|B_WANTED
condition|)
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
name|sdtmp
argument_list|)
expr_stmt|;
name|sdtmp_stat
operator|&=
operator|~
operator|(
name|B_BUSY
operator||
name|B_WANTED
operator|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
break|break;
case|case
name|SCSIIOCGTIMEO
case|:
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
name|sdc
operator|->
name|sdc_timeo
expr_stmt|;
break|break;
case|case
name|SCSIIOCSTIMEO
case|:
if|if
condition|(
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|==
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|sdc
operator|->
name|sdc_timeo
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
name|data
expr_stmt|;
name|sdc
operator|->
name|sdc_wticks
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|done
label|:
return|return
operator|(
name|error
operator|)
return|;
block|}
end_block

begin_expr_stmt
specifier|static
name|sd_scu_exec
argument_list|(
argument|dev
argument_list|,
argument|scu
argument_list|,
argument|sc
argument_list|)
name|dev_t
name|dev
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|struct
name|sc_ureq
modifier|*
name|scu
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|struct
name|scsi
modifier|*
name|sc
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|sdd_softc
modifier|*
name|sdd
decl_stmt|;
name|int
name|error
decl_stmt|;
name|sdd
operator|=
operator|&
name|sdd_softc
index|[
name|dev2unit
argument_list|(
name|dev
argument_list|)
index|]
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|scu
operator|->
name|scu_identify
operator|&
name|MSG_IDENT
operator|)
operator|==
literal|0
operator|)
operator|||
operator|(
name|scu
operator|->
name|scu_identify
operator|&
operator|~
operator|(
name|MSG_IDENT
operator||
name|IDT_DISCON
operator||
name|IDT_DRMASK
operator|)
operator|)
operator|||
operator|(
name|scu
operator|->
name|scu_addr
operator|&&
operator|(
name|scu
operator|->
name|scu_bytesec
operator|==
literal|0
operator|)
operator|)
condition|)
block|{
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|bzero
argument_list|(
operator|(
name|caddr_t
operator|)
name|sc
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|scsi
argument_list|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_tstatus
operator|=
name|scu
operator|->
name|scu_tstatus
expr_stmt|;
name|sc
operator|->
name|sc_identify
operator|=
name|scu
operator|->
name|scu_identify
expr_stmt|;
name|sc
operator|->
name|sc_message
operator|=
name|scu
operator|->
name|scu_message
expr_stmt|;
name|sc
operator|->
name|sc_bytesec
operator|=
name|scu
operator|->
name|scu_bytesec
expr_stmt|;
name|sc
operator|->
name|sc_cpoint
operator|=
name|scu
operator|->
name|scu_addr
expr_stmt|;
name|sc
operator|->
name|sc_ctrnscnt
operator|=
name|scu
operator|->
name|scu_count
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
name|scu
operator|->
name|scu_cdb
argument_list|,
operator|&
name|sc
operator|->
name|sc_cdb
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|sc_cdb
argument_list|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
name|scu
operator|->
name|scu_param
argument_list|,
operator|(
name|caddr_t
operator|)
name|sc
operator|->
name|sc_param
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|sc_param
argument_list|)
argument_list|)
expr_stmt|;
name|sdd
operator|->
name|sdd_flags
operator||=
name|SDDF_SKIPCHECK
expr_stmt|;
name|error
operator|=
name|sdcmd
argument_list|(
name|dev
argument_list|,
name|sc
argument_list|)
expr_stmt|;
name|sdd
operator|->
name|sdd_flags
operator|&=
operator|~
name|SDDF_SKIPCHECK
expr_stmt|;
name|scu
operator|->
name|scu_istatus
operator|=
name|sc
operator|->
name|sc_istatus
expr_stmt|;
name|scu
operator|->
name|scu_tstatus
operator|=
name|sc
operator|->
name|sc_tstatus
expr_stmt|;
name|scu
operator|->
name|scu_message
operator|=
name|sc
operator|->
name|sc_message
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
name|sc
operator|->
name|sc_param
argument_list|,
operator|(
name|caddr_t
operator|)
name|scu
operator|->
name|scu_param
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|sc_param
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_block

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_macro
name|sddump
argument_list|(
argument|dev
argument_list|)
end_macro

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_block
block|{
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
end_block

begin_expr_stmt
name|sdsize
argument_list|(
name|dev
argument_list|)
specifier|register
name|dev_t
name|dev
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|iop
comment|/**/
name|_device
modifier|*
name|ii
decl_stmt|;
specifier|register
name|struct
name|sdd_softc
modifier|*
name|sdd
decl_stmt|;
specifier|register
name|struct
name|sdst
modifier|*
name|st
decl_stmt|;
specifier|register
name|int
name|unit
decl_stmt|;
name|int
name|i
decl_stmt|;
name|unit
operator|=
name|dev2unit
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|unit
operator|>=
name|nsd
operator|||
operator|(
name|ii
operator|=
name|sddinfo
index|[
name|unit
index|]
operator|)
operator|==
literal|0
operator|||
name|ii
operator|->
name|ii_alive
operator|==
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|sdd
operator|=
operator|&
name|sdd_softc
index|[
name|unit
index|]
expr_stmt|;
switch|switch
condition|(
name|sdc_softc
index|[
name|ii
operator|->
name|ii_ctlr
index|]
operator|.
name|sdc_firmware
operator|&
name|SDCFW_DEVMASK
condition|)
block|{
case|case
name|SDCFW_HD
case|:
comment|/* Hard Disk */
name|st
operator|=
operator|&
name|sdstdrv
index|[
name|unit
index|]
expr_stmt|;
break|break;
case|case
name|SDCFW_MO
case|:
comment|/* MO only */
if|if
condition|(
operator|(
name|sdd
operator|->
name|sdd_flags
operator|&
name|SDDF_SAMEDSK
operator|)
operator|==
name|SDDF_DSKCHGD
condition|)
block|{
comment|/* 			 * read partition information, 			 *	and set up sdstdrv[unit] 			 */
if|if
condition|(
name|sd_b_open
argument_list|(
name|dev
argument_list|,
name|FREAD
operator||
name|FWRITE
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* 				 * block device open error  				 */
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
else|else
block|{
comment|/* 				 * use disk partition information 				 */
name|st
operator|=
operator|&
name|sdstdrv
index|[
name|unit
index|]
expr_stmt|;
if|if
condition|(
name|isalone
argument_list|(
name|unit
argument_list|)
operator|==
name|ONLY_ONE
condition|)
name|sd_b_close
argument_list|(
name|dev
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|sdd
operator|->
name|sdd_flags
operator|&
name|SDDF_NONFMT
condition|)
block|{
comment|/* 			 * medium is not initialized. 			 */
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
else|else
block|{
name|st
operator|=
operator|&
name|sdstdrv
index|[
name|unit
index|]
expr_stmt|;
block|}
break|break;
default|default:
comment|/*  case SDCFW_CD: */
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|st
operator|->
name|sizes
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* XXX */
else|else
return|return
operator|(
name|st
operator|->
name|sizes
index|[
name|dev2part
argument_list|(
name|dev
argument_list|)
index|]
operator|.
name|sd_nblocks
operator|)
return|;
comment|/* XXX */
block|}
end_block

begin_comment
comment|/*  * Reset driver.  * Cancel software state of all pending transfers,  * and restart all units and the controller.  */
end_comment

begin_macro
name|sdreset
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|struct
name|iop
comment|/**/
name|_ctlr
modifier|*
name|im
decl_stmt|;
specifier|register
name|struct
name|iop
comment|/**/
name|_device
modifier|*
name|ii
decl_stmt|;
specifier|register
name|struct
name|sdc_softc
modifier|*
name|sdc
decl_stmt|;
specifier|register
name|struct
name|sdd_softc
modifier|*
name|sdd
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|int
name|unit
decl_stmt|;
name|re_init_done
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nsdc
condition|;
name|i
operator|++
control|)
block|{
name|im
operator|=
name|sdminfo
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|im
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|im
operator|->
name|im_alive
operator|==
literal|0
condition|)
continue|continue;
name|printf
argument_list|(
literal|" sdc%d: "
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|sdc
operator|=
operator|&
name|sdc_softc
index|[
name|i
index|]
expr_stmt|;
name|sdc
operator|->
name|sdc_wticks
operator|=
literal|0
expr_stmt|;
comment|/* scop_init() is already called by screset() */
name|sdtmp_stat
operator|&=
operator|~
name|B_BUSY
expr_stmt|;
for|for
control|(
name|unit
operator|=
literal|0
init|;
name|unit
operator|<
name|nsd
condition|;
name|unit
operator|++
control|)
block|{
name|ii
operator|=
name|sddinfo
index|[
name|unit
index|]
expr_stmt|;
if|if
condition|(
name|ii
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|ii
operator|->
name|ii_alive
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|ii
operator|->
name|ii_mi
operator|!=
name|im
condition|)
continue|continue;
name|csdbuf
index|[
name|unit
index|]
operator|.
name|b_flags
operator|&=
operator|~
name|B_BUSY
expr_stmt|;
name|sdd
operator|=
operator|&
name|sdd_softc
index|[
name|unit
index|]
expr_stmt|;
name|sdd
operator|->
name|sdd_flags
operator|=
literal|0
expr_stmt|;
comment|/* 			 * UNLOCK SCSI access 			 */
name|sdc
operator|->
name|sdc_firmware
operator|&=
operator|~
name|SDCFW_BUSY
expr_stmt|;
if|if
condition|(
name|sdslave
argument_list|(
name|ii
argument_list|,
name|ii
operator|->
name|ii_addr
argument_list|,
name|im
operator|->
name|im_intr
argument_list|)
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"sd%d: not ready\n"
argument_list|,
name|ii
operator|->
name|ii_slave
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|sdattach
argument_list|(
name|ii
argument_list|)
expr_stmt|;
block|}
block|}
name|re_init_done
operator|=
literal|2
expr_stmt|;
block|}
end_block

begin_decl_stmt
name|int
name|sd_long_timeout
init|=
literal|24
operator|*
literal|60
operator|*
literal|60
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 24 hours */
end_comment

begin_define
define|#
directive|define
name|max
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|(((a)>(b))?(a):(b))
end_define

begin_comment
comment|/*  * Wake up every second and if interrupt is pending  * but nothing has happened increment a counter.  * If nothing happens for sdc_timeo seconds, reset the IOP  * and begin anew.  */
end_comment

begin_macro
name|sdwatch
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|struct
name|iop
comment|/**/
name|_ctlr
modifier|*
name|im
decl_stmt|;
specifier|register
name|struct
name|sdc_softc
modifier|*
name|sdc
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|int
name|unit
decl_stmt|;
name|int
name|timeo
decl_stmt|;
specifier|extern
name|int
name|Scsi_Disconnect
decl_stmt|;
name|timeout
argument_list|(
name|sdwatch
argument_list|,
operator|(
name|caddr_t
operator|)
literal|0
argument_list|,
name|hz
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nsdc
condition|;
name|i
operator|++
control|)
block|{
name|im
operator|=
name|sdminfo
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|im
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|im
operator|->
name|im_alive
operator|==
literal|0
condition|)
continue|continue;
name|sdc
operator|=
operator|&
name|sdc_softc
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|im
operator|->
name|im_tab
operator|.
name|b_active
condition|)
goto|goto
name|active
goto|;
for|for
control|(
name|unit
operator|=
literal|0
init|;
name|unit
operator|<
name|nsd
condition|;
name|unit
operator|++
control|)
if|if
condition|(
name|sdutab
index|[
name|unit
index|]
operator|.
name|b_active
operator|&&
name|sddinfo
index|[
name|unit
index|]
operator|->
name|ii_mi
operator|==
name|im
condition|)
goto|goto
name|active
goto|;
name|sdc
operator|->
name|sdc_wticks
operator|=
literal|0
expr_stmt|;
continue|continue;
name|active
label|:
if|if
condition|(
name|Scsi_Disconnect
condition|)
name|timeo
operator|=
name|sdc
operator|->
name|sdc_timeo
expr_stmt|;
else|else
name|timeo
operator|=
name|max
argument_list|(
name|sdc
operator|->
name|sdc_timeo
argument_list|,
name|sd_long_timeout
argument_list|)
expr_stmt|;
if|if
condition|(
name|sdc
operator|->
name|sdc_wticks
operator|++
operator|>=
name|timeo
condition|)
block|{
specifier|register
name|struct
name|scsi
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
name|get_scsi
argument_list|(
name|im
operator|->
name|im_intr
argument_list|)
expr_stmt|;
name|sdc
operator|->
name|sdc_wticks
operator|=
literal|0
expr_stmt|;
name|printf
argument_list|(
literal|"sdc%d: lost interrupt\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|screset
argument_list|(
name|im
operator|->
name|im_intr
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_block

begin_comment
comment|/*  * sdstop() is timer interrupt routine.  *	So, can't use sleep().  */
end_comment

begin_macro
name|sdstop
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|struct
name|iop
comment|/**/
name|_ctlr
modifier|*
name|im
decl_stmt|;
specifier|register
name|struct
name|iop
comment|/**/
name|_device
modifier|*
name|ii
decl_stmt|;
specifier|register
name|struct
name|sdc_softc
modifier|*
name|sdc
decl_stmt|;
specifier|register
name|struct
name|sdd_softc
modifier|*
name|sdd
decl_stmt|;
specifier|register
name|int
name|unit
decl_stmt|;
specifier|register
name|int
name|intr
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|struct
name|scsi
modifier|*
name|sc
decl_stmt|;
name|int
name|eject_sw
decl_stmt|;
name|timeout
argument_list|(
name|sdstop
argument_list|,
operator|(
name|caddr_t
operator|)
literal|0
argument_list|,
name|hz
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nsdc
condition|;
name|i
operator|++
control|)
block|{
name|im
operator|=
name|sdminfo
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|im
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|im
operator|->
name|im_alive
operator|==
literal|0
condition|)
continue|continue;
for|for
control|(
name|unit
operator|=
literal|0
init|;
name|unit
operator|<
name|nsd
condition|;
name|unit
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|ii
operator|=
name|sddinfo
index|[
name|unit
index|]
operator|)
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|ii
operator|->
name|ii_mi
operator|!=
name|im
condition|)
continue|continue;
name|sdc
operator|=
operator|&
name|sdc_softc
index|[
name|ii
operator|->
name|ii_ctlr
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|sdc
operator|->
name|sdc_firmware
operator|&
name|SDCFW_RMB
operator|)
operator|==
literal|0
condition|)
continue|continue;
name|intr
operator|=
name|ii
operator|->
name|ii_intr
expr_stmt|;
if|if
condition|(
name|isalone
argument_list|(
name|unit
argument_list|)
condition|)
continue|continue;
comment|/**********************/
comment|/*    MO& CD-ROM     */
comment|/**********************/
comment|/* 			 * there is no process which open the unit. 			 */
name|sdd
operator|=
operator|&
name|sdd_softc
index|[
name|unit
index|]
expr_stmt|;
name|sc
operator|=
name|get_scsi
argument_list|(
name|intr
argument_list|)
expr_stmt|;
if|if
condition|(
name|sdd
operator|->
name|sdd_start
operator|>
literal|0
condition|)
name|sdd
operator|->
name|sdd_start
operator|--
expr_stmt|;
elseif|else
if|if
condition|(
name|sdd
operator|->
name|sdd_start
operator|==
literal|0
condition|)
block|{
comment|/* 				 * Now stop the unit. 				 * check SCSI access 				 */
if|if
condition|(
name|sdc
operator|->
name|sdc_firmware
operator|&
name|SDCFW_BUSY
condition|)
continue|continue;
name|sdc
operator|->
name|sdc_firmware
operator||=
name|SDCFW_BUSY
expr_stmt|;
name|sdc
operator|->
name|sdc_state
operator||=
name|SDCS_IOCTL
operator||
name|SDCS_SCUNLOCK
expr_stmt|;
name|eject_sw
operator|=
operator|(
name|sdd
operator|->
name|sdd_flags
operator|&
name|SDDF_REQ_EJECT
operator|)
condition|?
name|SDSS_EJECT
else|:
name|SDSS_STOP
expr_stmt|;
name|scop_stst
argument_list|(
name|intr
argument_list|,
name|sc
argument_list|,
name|ii
operator|->
name|ii_slave
argument_list|,
name|SCSI_INTEN
argument_list|,
name|eject_sw
argument_list|)
expr_stmt|;
name|sdd
operator|->
name|sdd_start
operator|=
operator|-
literal|2
expr_stmt|;
block|}
block|}
block|}
block|}
end_block

begin_expr_stmt
name|isalone
argument_list|(
name|unit
argument_list|)
specifier|register
name|int
name|unit
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|n
decl_stmt|;
name|n
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|PNUM
condition|;
name|i
operator|++
control|)
name|n
operator|+=
operator|(
name|sd_b_openf
index|[
name|unit
index|]
index|[
name|i
index|]
operator|+
name|sd_c_openf
index|[
name|unit
index|]
index|[
name|i
index|]
operator|)
expr_stmt|;
return|return
operator|(
name|n
operator|)
return|;
block|}
end_block

begin_comment
comment|/************************************************  * Convert Hex and RS code table definition	*  ************************************************/
end_comment

begin_define
define|#
directive|define
name|X8_L
value|0x001d
end_define

begin_define
define|#
directive|define
name|X8_H
value|0x1d00
end_define

begin_define
define|#
directive|define
name|hextors
parameter_list|(
name|data
parameter_list|)
value|hxtable[(int)((data)& 0xff)]
end_define

begin_define
define|#
directive|define
name|XORMASK
parameter_list|(
name|code
parameter_list|)
value|xortable[(unsigned int)(code)]
end_define

begin_decl_stmt
name|int
name|hxtable
index|[
literal|256
index|]
init|=
block|{
literal|0x00
block|,
literal|0x00
block|,
literal|0x01
block|,
literal|0x19
block|,
literal|0x02
block|,
literal|0x32
block|,
literal|0x1a
block|,
literal|0xc6
block|,
literal|0x03
block|,
literal|0xdf
block|,
literal|0x33
block|,
literal|0xee
block|,
literal|0x1b
block|,
literal|0x68
block|,
literal|0xc7
block|,
literal|0x4b
block|,
literal|0x04
block|,
literal|0x64
block|,
literal|0xe0
block|,
literal|0x0e
block|,
literal|0x34
block|,
literal|0x8d
block|,
literal|0xef
block|,
literal|0x81
block|,
literal|0x1c
block|,
literal|0xc1
block|,
literal|0x69
block|,
literal|0xf8
block|,
literal|0xc8
block|,
literal|0x08
block|,
literal|0x4c
block|,
literal|0x71
block|,
literal|0x05
block|,
literal|0x8a
block|,
literal|0x65
block|,
literal|0x2f
block|,
literal|0xe1
block|,
literal|0x24
block|,
literal|0x0f
block|,
literal|0x21
block|,
literal|0x35
block|,
literal|0x93
block|,
literal|0x8e
block|,
literal|0xda
block|,
literal|0xf0
block|,
literal|0x12
block|,
literal|0x82
block|,
literal|0x45
block|,
literal|0x1d
block|,
literal|0xb5
block|,
literal|0xc2
block|,
literal|0x7d
block|,
literal|0x6a
block|,
literal|0x27
block|,
literal|0xf9
block|,
literal|0xb9
block|,
literal|0xc9
block|,
literal|0x9a
block|,
literal|0x09
block|,
literal|0x78
block|,
literal|0x4d
block|,
literal|0xe4
block|,
literal|0x72
block|,
literal|0xa6
block|,
literal|0x06
block|,
literal|0xbf
block|,
literal|0x8b
block|,
literal|0x62
block|,
literal|0x66
block|,
literal|0xdd
block|,
literal|0x30
block|,
literal|0xfd
block|,
literal|0xe2
block|,
literal|0x98
block|,
literal|0x25
block|,
literal|0xb3
block|,
literal|0x10
block|,
literal|0x91
block|,
literal|0x22
block|,
literal|0x88
block|,
literal|0x36
block|,
literal|0xd0
block|,
literal|0x94
block|,
literal|0xce
block|,
literal|0x8f
block|,
literal|0x96
block|,
literal|0xdb
block|,
literal|0xbd
block|,
literal|0xf1
block|,
literal|0xd2
block|,
literal|0x13
block|,
literal|0x5c
block|,
literal|0x83
block|,
literal|0x38
block|,
literal|0x46
block|,
literal|0x40
block|,
literal|0x1e
block|,
literal|0x42
block|,
literal|0xb6
block|,
literal|0xa3
block|,
literal|0xc3
block|,
literal|0x48
block|,
literal|0x7e
block|,
literal|0x6e
block|,
literal|0x6b
block|,
literal|0x3a
block|,
literal|0x28
block|,
literal|0x54
block|,
literal|0xfa
block|,
literal|0x85
block|,
literal|0xba
block|,
literal|0x3d
block|,
literal|0xca
block|,
literal|0x5e
block|,
literal|0x9b
block|,
literal|0x9f
block|,
literal|0x0a
block|,
literal|0x15
block|,
literal|0x79
block|,
literal|0x2b
block|,
literal|0x4e
block|,
literal|0xd4
block|,
literal|0xe5
block|,
literal|0xac
block|,
literal|0x73
block|,
literal|0xf3
block|,
literal|0xa7
block|,
literal|0x57
block|,
literal|0x07
block|,
literal|0x70
block|,
literal|0xc0
block|,
literal|0xf7
block|,
literal|0x8c
block|,
literal|0x80
block|,
literal|0x63
block|,
literal|0x0d
block|,
literal|0x67
block|,
literal|0x4a
block|,
literal|0xde
block|,
literal|0xed
block|,
literal|0x31
block|,
literal|0xc5
block|,
literal|0xfe
block|,
literal|0x18
block|,
literal|0xe3
block|,
literal|0xa5
block|,
literal|0x99
block|,
literal|0x77
block|,
literal|0x26
block|,
literal|0xb8
block|,
literal|0xb4
block|,
literal|0x7c
block|,
literal|0x11
block|,
literal|0x44
block|,
literal|0x92
block|,
literal|0xd9
block|,
literal|0x23
block|,
literal|0x20
block|,
literal|0x89
block|,
literal|0x2e
block|,
literal|0x37
block|,
literal|0x3f
block|,
literal|0xd1
block|,
literal|0x5b
block|,
literal|0x95
block|,
literal|0xbc
block|,
literal|0xcf
block|,
literal|0xcd
block|,
literal|0x90
block|,
literal|0x87
block|,
literal|0x97
block|,
literal|0xb2
block|,
literal|0xdc
block|,
literal|0xfc
block|,
literal|0xbe
block|,
literal|0x61
block|,
literal|0xf2
block|,
literal|0x56
block|,
literal|0xd3
block|,
literal|0xab
block|,
literal|0x14
block|,
literal|0x2a
block|,
literal|0x5d
block|,
literal|0x9e
block|,
literal|0x84
block|,
literal|0x3c
block|,
literal|0x39
block|,
literal|0x53
block|,
literal|0x47
block|,
literal|0x6d
block|,
literal|0x41
block|,
literal|0xa2
block|,
literal|0x1f
block|,
literal|0x2d
block|,
literal|0x43
block|,
literal|0xd8
block|,
literal|0xb7
block|,
literal|0x7b
block|,
literal|0xa4
block|,
literal|0x76
block|,
literal|0xc4
block|,
literal|0x17
block|,
literal|0x49
block|,
literal|0xec
block|,
literal|0x7f
block|,
literal|0x0c
block|,
literal|0x6f
block|,
literal|0xf6
block|,
literal|0x6c
block|,
literal|0xa1
block|,
literal|0x3b
block|,
literal|0x52
block|,
literal|0x29
block|,
literal|0x9d
block|,
literal|0x55
block|,
literal|0xaa
block|,
literal|0xfb
block|,
literal|0x60
block|,
literal|0x86
block|,
literal|0xb1
block|,
literal|0xbb
block|,
literal|0xcc
block|,
literal|0x3e
block|,
literal|0x5a
block|,
literal|0xcb
block|,
literal|0x59
block|,
literal|0x5f
block|,
literal|0xb0
block|,
literal|0x9c
block|,
literal|0xa9
block|,
literal|0xa0
block|,
literal|0x51
block|,
literal|0x0b
block|,
literal|0xf5
block|,
literal|0x16
block|,
literal|0xeb
block|,
literal|0x7a
block|,
literal|0x75
block|,
literal|0x2c
block|,
literal|0xd7
block|,
literal|0x4f
block|,
literal|0xae
block|,
literal|0xd5
block|,
literal|0xe9
block|,
literal|0xe6
block|,
literal|0xe7
block|,
literal|0xad
block|,
literal|0xe8
block|,
literal|0x74
block|,
literal|0xd6
block|,
literal|0xf4
block|,
literal|0xea
block|,
literal|0xa8
block|,
literal|0x50
block|,
literal|0x58
block|,
literal|0xaf
block|,  }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|xortable
index|[
literal|256
index|]
init|=
block|{
literal|0x00000000
block|,
literal|0x90910101
block|,
literal|0x91210201
block|,
literal|0x01b00300
block|,
literal|0x92410401
block|,
literal|0x02d00500
block|,
literal|0x03600600
block|,
literal|0x93f10701
block|,
literal|0x94810801
block|,
literal|0x04100900
block|,
literal|0x05a00a00
block|,
literal|0x95310b01
block|,
literal|0x06c00c00
block|,
literal|0x96510d01
block|,
literal|0x97e10e01
block|,
literal|0x07700f00
block|,
literal|0x99011001
block|,
literal|0x09901100
block|,
literal|0x08201200
block|,
literal|0x98b11301
block|,
literal|0x0b401400
block|,
literal|0x9bd11501
block|,
literal|0x9a611601
block|,
literal|0x0af01700
block|,
literal|0x0d801800
block|,
literal|0x9d111901
block|,
literal|0x9ca11a01
block|,
literal|0x0c301b00
block|,
literal|0x9fc11c01
block|,
literal|0x0f501d00
block|,
literal|0x0ee01e00
block|,
literal|0x9e711f01
block|,
literal|0x82012001
block|,
literal|0x12902100
block|,
literal|0x13202200
block|,
literal|0x83b12301
block|,
literal|0x10402400
block|,
literal|0x80d12501
block|,
literal|0x81612601
block|,
literal|0x11f02700
block|,
literal|0x16802800
block|,
literal|0x86112901
block|,
literal|0x87a12a01
block|,
literal|0x17302b00
block|,
literal|0x84c12c01
block|,
literal|0x14502d00
block|,
literal|0x15e02e00
block|,
literal|0x85712f01
block|,
literal|0x1b003000
block|,
literal|0x8b913101
block|,
literal|0x8a213201
block|,
literal|0x1ab03300
block|,
literal|0x89413401
block|,
literal|0x19d03500
block|,
literal|0x18603600
block|,
literal|0x88f13701
block|,
literal|0x8f813801
block|,
literal|0x1f103900
block|,
literal|0x1ea03a00
block|,
literal|0x8e313b01
block|,
literal|0x1dc03c00
block|,
literal|0x8d513d01
block|,
literal|0x8ce13e01
block|,
literal|0x1c703f00
block|,
literal|0xb4014001
block|,
literal|0x24904100
block|,
literal|0x25204200
block|,
literal|0xb5b14301
block|,
literal|0x26404400
block|,
literal|0xb6d14501
block|,
literal|0xb7614601
block|,
literal|0x27f04700
block|,
literal|0x20804800
block|,
literal|0xb0114901
block|,
literal|0xb1a14a01
block|,
literal|0x21304b00
block|,
literal|0xb2c14c01
block|,
literal|0x22504d00
block|,
literal|0x23e04e00
block|,
literal|0xb3714f01
block|,
literal|0x2d005000
block|,
literal|0xbd915101
block|,
literal|0xbc215201
block|,
literal|0x2cb05300
block|,
literal|0xbf415401
block|,
literal|0x2fd05500
block|,
literal|0x2e605600
block|,
literal|0xbef15701
block|,
literal|0xb9815801
block|,
literal|0x29105900
block|,
literal|0x28a05a00
block|,
literal|0xb8315b01
block|,
literal|0x2bc05c00
block|,
literal|0xbb515d01
block|,
literal|0xbae15e01
block|,
literal|0x2a705f00
block|,
literal|0x36006000
block|,
literal|0xa6916101
block|,
literal|0xa7216201
block|,
literal|0x37b06300
block|,
literal|0xa4416401
block|,
literal|0x34d06500
block|,
literal|0x35606600
block|,
literal|0xa5f16701
block|,
literal|0xa2816801
block|,
literal|0x32106900
block|,
literal|0x33a06a00
block|,
literal|0xa3316b01
block|,
literal|0x30c06c00
block|,
literal|0xa0516d01
block|,
literal|0xa1e16e01
block|,
literal|0x31706f00
block|,
literal|0xaf017001
block|,
literal|0x3f907100
block|,
literal|0x3e207200
block|,
literal|0xaeb17301
block|,
literal|0x3d407400
block|,
literal|0xadd17501
block|,
literal|0xac617601
block|,
literal|0x3cf07700
block|,
literal|0x3b807800
block|,
literal|0xab117901
block|,
literal|0xaaa17a01
block|,
literal|0x3a307b00
block|,
literal|0xa9c17c01
block|,
literal|0x39507d00
block|,
literal|0x38e07e00
block|,
literal|0xa8717f01
block|,
literal|0xd8018001
block|,
literal|0x48908100
block|,
literal|0x49208200
block|,
literal|0xd9b18301
block|,
literal|0x4a408400
block|,
literal|0xdad18501
block|,
literal|0xdb618601
block|,
literal|0x4bf08700
block|,
literal|0x4c808800
block|,
literal|0xdc118901
block|,
literal|0xdda18a01
block|,
literal|0x4d308b00
block|,
literal|0xdec18c01
block|,
literal|0x4e508d00
block|,
literal|0x4fe08e00
block|,
literal|0xdf718f01
block|,
literal|0x41009000
block|,
literal|0xd1919101
block|,
literal|0xd0219201
block|,
literal|0x40b09300
block|,
literal|0xd3419401
block|,
literal|0x43d09500
block|,
literal|0x42609600
block|,
literal|0xd2f19701
block|,
literal|0xd5819801
block|,
literal|0x45109900
block|,
literal|0x44a09a00
block|,
literal|0xd4319b01
block|,
literal|0x47c09c00
block|,
literal|0xd7519d01
block|,
literal|0xd6e19e01
block|,
literal|0x46709f00
block|,
literal|0x5a00a000
block|,
literal|0xca91a101
block|,
literal|0xcb21a201
block|,
literal|0x5bb0a300
block|,
literal|0xc841a401
block|,
literal|0x58d0a500
block|,
literal|0x5960a600
block|,
literal|0xc9f1a701
block|,
literal|0xce81a801
block|,
literal|0x5e10a900
block|,
literal|0x5fa0aa00
block|,
literal|0xcf31ab01
block|,
literal|0x5cc0ac00
block|,
literal|0xcc51ad01
block|,
literal|0xcde1ae01
block|,
literal|0x5d70af00
block|,
literal|0xc301b001
block|,
literal|0x5390b100
block|,
literal|0x5220b200
block|,
literal|0xc2b1b301
block|,
literal|0x5140b400
block|,
literal|0xc1d1b501
block|,
literal|0xc061b601
block|,
literal|0x50f0b700
block|,
literal|0x5780b800
block|,
literal|0xc711b901
block|,
literal|0xc6a1ba01
block|,
literal|0x5630bb00
block|,
literal|0xc5c1bc01
block|,
literal|0x5550bd00
block|,
literal|0x54e0be00
block|,
literal|0xc471bf01
block|,
literal|0x6c00c000
block|,
literal|0xfc91c101
block|,
literal|0xfd21c201
block|,
literal|0x6db0c300
block|,
literal|0xfe41c401
block|,
literal|0x6ed0c500
block|,
literal|0x6f60c600
block|,
literal|0xfff1c701
block|,
literal|0xf881c801
block|,
literal|0x6810c900
block|,
literal|0x69a0ca00
block|,
literal|0xf931cb01
block|,
literal|0x6ac0cc00
block|,
literal|0xfa51cd01
block|,
literal|0xfbe1ce01
block|,
literal|0x6b70cf00
block|,
literal|0xf501d001
block|,
literal|0x6590d100
block|,
literal|0x6420d200
block|,
literal|0xf4b1d301
block|,
literal|0x6740d400
block|,
literal|0xf7d1d501
block|,
literal|0xf661d601
block|,
literal|0x66f0d700
block|,
literal|0x6180d800
block|,
literal|0xf111d901
block|,
literal|0xf0a1da01
block|,
literal|0x6030db00
block|,
literal|0xf3c1dc01
block|,
literal|0x6350dd00
block|,
literal|0x62e0de00
block|,
literal|0xf271df01
block|,
literal|0xee01e001
block|,
literal|0x7e90e100
block|,
literal|0x7f20e200
block|,
literal|0xefb1e301
block|,
literal|0x7c40e400
block|,
literal|0xecd1e501
block|,
literal|0xed61e601
block|,
literal|0x7df0e700
block|,
literal|0x7a80e800
block|,
literal|0xea11e901
block|,
literal|0xeba1ea01
block|,
literal|0x7b30eb00
block|,
literal|0xe8c1ec01
block|,
literal|0x7850ed00
block|,
literal|0x79e0ee00
block|,
literal|0xe971ef01
block|,
literal|0x7700f000
block|,
literal|0xe791f101
block|,
literal|0xe621f201
block|,
literal|0x76b0f300
block|,
literal|0xe541f401
block|,
literal|0x75d0f500
block|,
literal|0x7460f600
block|,
literal|0xe4f1f701
block|,
literal|0xe381f801
block|,
literal|0x7310f900
block|,
literal|0x72a0fa00
block|,
literal|0xe231fb01
block|,
literal|0x71c0fc00
block|,
literal|0xe151fd01
block|,
literal|0xe0e1fe01
block|,
literal|0x7070ff00
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/********************************************************  * EDC (Error Detection Code) check			*  *			(using CRC code)		*  *	MODE 1 : Sync + Header + User data + edc	*  *	MODE 2 : Sub header + User data + edc		*  ********************************************************/
end_comment

begin_define
define|#
directive|define
name|SYNC_EDC
value|0x908eff4e
end_define

begin_comment
comment|/* sector sync EDC value	*/
end_comment

begin_define
define|#
directive|define
name|HEADER
value|4
end_define

begin_comment
comment|/* header length 4 bytes	*/
end_comment

begin_define
define|#
directive|define
name|SUB_H
value|8
end_define

begin_comment
comment|/* Subheader length 8 bytes	*/
end_comment

begin_define
define|#
directive|define
name|USER_DATA
value|2048
end_define

begin_comment
comment|/* User data length 2048 bytes	*/
end_comment

begin_define
define|#
directive|define
name|EDC_LEN
value|4
end_define

begin_comment
comment|/* EDC code length 4 bytes	*/
end_comment

begin_expr_stmt
name|cal_edc1
argument_list|(
name|db
argument_list|,
name|mode
argument_list|)
specifier|register
name|unsigned
name|char
operator|*
name|db
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|mode
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|j
decl_stmt|;
specifier|register
name|unsigned
name|int
name|work
decl_stmt|;
name|j
operator|=
name|USER_DATA
operator|+
name|EDC_LEN
expr_stmt|;
if|if
condition|(
name|mode
operator|==
literal|2
condition|)
block|{
name|j
operator|+=
name|SUB_H
expr_stmt|;
name|work
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|j
operator|+=
name|HEADER
expr_stmt|;
name|work
operator|=
name|SYNC_EDC
expr_stmt|;
block|}
while|while
condition|(
operator|--
name|j
operator|>=
literal|0
condition|)
name|work
operator|=
operator|(
operator|(
name|work
operator|>>
literal|8
operator|)
operator||
operator|(
operator|*
name|db
operator|++
operator|<<
literal|24
operator|)
operator|)
operator|^
name|XORMASK
argument_list|(
name|work
operator|&
literal|0xff
argument_list|)
expr_stmt|;
return|return
operator|(
name|work
operator|)
return|;
block|}
end_block

begin_comment
comment|/************************************************/
end_comment

begin_comment
comment|/*	error detection& correction		*/
end_comment

begin_comment
comment|/*	if form 1				*/
end_comment

begin_comment
comment|/*	    header area should be zero		*/
end_comment

begin_comment
comment|/************************************************/
end_comment

begin_comment
comment|/*  *	error detection& correction  P-direction  */
end_comment

begin_expr_stmt
name|p_dir
argument_list|(
name|dbuf
argument_list|)
specifier|register
name|unsigned
name|short
operator|*
name|dbuf
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|unsigned
name|short
name|s0
decl_stmt|,
name|s1
decl_stmt|,
name|d
decl_stmt|;
specifier|register
name|int
name|col
decl_stmt|,
name|row
decl_stmt|;
specifier|register
name|int
name|x
decl_stmt|;
name|unsigned
name|char
name|s0l
decl_stmt|,
name|s0h
decl_stmt|,
name|s1l
decl_stmt|,
name|s1h
decl_stmt|;
comment|/* 	 * calculate syndrome S0 S1 	 */
for|for
control|(
name|col
operator|=
literal|0
init|;
name|col
operator|<
literal|43
condition|;
name|col
operator|++
control|)
block|{
name|s0
operator|=
name|s1
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|row
operator|=
literal|0
init|;
name|row
operator|<
literal|26
condition|;
name|row
operator|++
control|)
block|{
name|d
operator|=
name|dbuf
index|[
literal|43
operator|*
name|row
operator|+
name|col
index|]
expr_stmt|;
name|s0
operator|^=
name|d
expr_stmt|;
name|s1
operator|=
name|rsshift
argument_list|(
name|s1
argument_list|)
operator|^
name|d
expr_stmt|;
block|}
name|s0h
operator|=
name|s0
operator|&
literal|0x00ff
expr_stmt|;
name|s1h
operator|=
name|s1
operator|&
literal|0x00ff
expr_stmt|;
name|s0l
operator|=
operator|(
name|s0
operator|>>
literal|8
operator|)
operator|&
literal|0x00ff
expr_stmt|;
name|s1l
operator|=
operator|(
name|s1
operator|>>
literal|8
operator|)
operator|&
literal|0x00ff
expr_stmt|;
comment|/* 		 * calculate error position& correction 		 */
if|if
condition|(
name|s0l
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|x
operator|=
name|hextors
argument_list|(
name|s1l
argument_list|)
operator|-
name|hextors
argument_list|(
name|s0l
argument_list|)
operator|)
operator|<
literal|0
condition|)
name|x
operator|+=
literal|255
expr_stmt|;
if|if
condition|(
operator|(
name|x
operator|>=
literal|0
operator|)
operator|&&
operator|(
name|x
operator|<
literal|26
operator|)
condition|)
block|{
name|x
operator|=
literal|25
operator|-
name|x
expr_stmt|;
comment|/* 				 * correction 				 */
name|dbuf
index|[
literal|43
operator|*
name|x
operator|+
name|col
index|]
operator|^=
operator|(
name|s0
operator|&
literal|0xff00
operator|)
expr_stmt|;
block|}
block|}
comment|/* 		 * calculate error position& correction 		 */
if|if
condition|(
name|s0h
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|x
operator|=
name|hextors
argument_list|(
name|s1h
argument_list|)
operator|-
name|hextors
argument_list|(
name|s0h
argument_list|)
operator|)
operator|<
literal|0
condition|)
name|x
operator|+=
literal|255
expr_stmt|;
if|if
condition|(
operator|(
name|x
operator|>=
literal|0
operator|)
operator|&&
operator|(
name|x
operator|<
literal|26
operator|)
condition|)
block|{
name|x
operator|=
literal|25
operator|-
name|x
expr_stmt|;
comment|/* 				 * correction 				 */
name|dbuf
index|[
literal|43
operator|*
name|x
operator|+
name|col
index|]
operator|^=
operator|(
name|s0
operator|&
literal|0x00ff
operator|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_block

begin_comment
comment|/*  * error detection& correction  Q-direction  */
end_comment

begin_expr_stmt
name|q_dir
argument_list|(
name|dbuf
argument_list|)
specifier|register
name|unsigned
name|short
operator|*
name|dbuf
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|unsigned
name|short
name|s0
decl_stmt|,
name|s1
decl_stmt|,
name|d
decl_stmt|;
specifier|register
name|int
name|col
decl_stmt|,
name|row
decl_stmt|;
specifier|register
name|int
name|x
decl_stmt|;
name|unsigned
name|char
name|s0l
decl_stmt|,
name|s0h
decl_stmt|,
name|s1l
decl_stmt|,
name|s1h
decl_stmt|;
comment|/* 	 * calculate syndrome S0 S1 	 */
for|for
control|(
name|row
operator|=
literal|0
init|;
name|row
operator|<
literal|26
condition|;
name|row
operator|++
control|)
block|{
name|s0
operator|=
name|s1
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|col
operator|=
literal|0
init|;
name|col
operator|<
literal|45
condition|;
name|col
operator|++
control|)
block|{
if|if
condition|(
name|col
operator|<
literal|43
condition|)
name|d
operator|=
name|dbuf
index|[
operator|(
literal|44
operator|*
name|col
operator|+
literal|43
operator|*
name|row
operator|)
operator|%
literal|1118
index|]
expr_stmt|;
elseif|else
if|if
condition|(
name|col
operator|==
literal|43
condition|)
name|d
operator|=
name|dbuf
index|[
literal|43
operator|*
literal|26
operator|+
name|row
index|]
expr_stmt|;
else|else
name|d
operator|=
name|dbuf
index|[
literal|44
operator|*
literal|26
operator|+
name|row
index|]
expr_stmt|;
name|s0
operator|^=
name|d
expr_stmt|;
name|s1
operator|=
name|rsshift
argument_list|(
name|s1
argument_list|)
operator|^
name|d
expr_stmt|;
block|}
name|s0h
operator|=
name|s0
operator|&
literal|0x00ff
expr_stmt|;
name|s1h
operator|=
name|s1
operator|&
literal|0x00ff
expr_stmt|;
name|s0l
operator|=
operator|(
name|s0
operator|>>
literal|8
operator|)
operator|&
literal|0x00ff
expr_stmt|;
name|s1l
operator|=
operator|(
name|s1
operator|>>
literal|8
operator|)
operator|&
literal|0x00ff
expr_stmt|;
comment|/* 		 * calculate error position& correction 		 */
if|if
condition|(
name|s0l
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|x
operator|=
name|hextors
argument_list|(
name|s1l
argument_list|)
operator|-
name|hextors
argument_list|(
name|s0l
argument_list|)
operator|)
operator|<
literal|0
condition|)
name|x
operator|+=
literal|255
expr_stmt|;
if|if
condition|(
name|x
operator|>=
literal|0
operator|&&
name|x
operator|<
literal|45
condition|)
block|{
name|x
operator|=
literal|44
operator|-
name|x
expr_stmt|;
comment|/* 				 * correction 				 */
if|if
condition|(
name|x
operator|<
literal|43
condition|)
name|dbuf
index|[
operator|(
literal|44
operator|*
name|x
operator|+
literal|43
operator|*
name|row
operator|)
operator|%
literal|1118
index|]
operator|^=
name|s0
operator|&
literal|0xff00
expr_stmt|;
elseif|else
if|if
condition|(
name|x
operator|==
literal|43
condition|)
name|dbuf
index|[
literal|43
operator|*
literal|26
operator|+
name|row
index|]
operator|^=
name|s0
operator|&
literal|0xff00
expr_stmt|;
else|else
name|dbuf
index|[
literal|44
operator|*
literal|26
operator|+
name|row
index|]
operator|^=
name|s0
operator|&
literal|0xff00
expr_stmt|;
block|}
block|}
comment|/* 		 * calculate error position& correction 		 */
if|if
condition|(
name|s0h
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|x
operator|=
name|hextors
argument_list|(
name|s1h
argument_list|)
operator|-
name|hextors
argument_list|(
name|s0h
argument_list|)
operator|)
operator|<
literal|0
condition|)
name|x
operator|+=
literal|255
expr_stmt|;
if|if
condition|(
operator|(
name|x
operator|>=
literal|0
operator|)
operator|&&
operator|(
name|x
operator|<
literal|45
operator|)
condition|)
block|{
name|x
operator|=
literal|44
operator|-
name|x
expr_stmt|;
comment|/* 				 * correction 				 */
if|if
condition|(
name|x
operator|<
literal|43
condition|)
name|dbuf
index|[
operator|(
literal|44
operator|*
name|x
operator|+
literal|43
operator|*
name|row
operator|)
operator|%
literal|1118
index|]
operator|^=
name|s0
operator|&
literal|0x00ff
expr_stmt|;
elseif|else
if|if
condition|(
name|x
operator|==
literal|43
condition|)
name|dbuf
index|[
literal|43
operator|*
literal|26
operator|+
name|row
index|]
operator|^=
name|s0
operator|&
literal|0x00ff
expr_stmt|;
else|else
name|dbuf
index|[
literal|44
operator|*
literal|26
operator|+
name|row
index|]
operator|^=
name|s0
operator|&
literal|0x00ff
expr_stmt|;
block|}
block|}
block|}
block|}
end_block

begin_comment
comment|/*  *	shift high& low byte at the same time  */
end_comment

begin_macro
name|rsshift
argument_list|(
argument|d
argument_list|)
end_macro

begin_decl_stmt
name|unsigned
name|short
name|d
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|x
decl_stmt|;
specifier|register
name|int
name|dmy
decl_stmt|;
comment|/* This way is faster */
name|dmy
operator|=
operator|(
name|int
operator|)
name|d
expr_stmt|;
name|x
operator|=
operator|(
name|dmy
operator|<<
literal|1
operator|)
operator|&
literal|0xfefe
expr_stmt|;
comment|/* clear LSB of high& low byte */
if|if
condition|(
operator|(
name|dmy
operator|&
literal|0x0080
operator|)
operator|!=
literal|0
condition|)
name|x
operator|^=
name|X8_L
expr_stmt|;
if|if
condition|(
operator|(
name|dmy
operator|&
literal|0x8000
operator|)
operator|!=
literal|0
condition|)
name|x
operator|^=
name|X8_H
expr_stmt|;
return|return
operator|(
name|x
operator|)
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NSD> 0 */
end_comment

end_unit

