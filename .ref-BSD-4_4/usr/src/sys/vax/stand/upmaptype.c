begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1982, 1986 Regents of the University of California.  * All rights reserved.  The Berkeley software License Agreement  * specifies the terms and conditions for redistribution.  *  *	@(#)upmaptype.c	7.6 (Berkeley) 12/16/90  */
end_comment

begin_comment
comment|/*  * UNIBUS peripheral standalone  * driver: drive type mapping routine.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|COMPAT_42
end_ifdef

begin_include
include|#
directive|include
file|"sys/param.h"
end_include

begin_include
include|#
directive|include
file|"sys/dkbad.h"
end_include

begin_include
include|#
directive|include
file|"sys/disklabel.h"
end_include

begin_include
include|#
directive|include
file|"sys/vmmac.h"
end_include

begin_include
include|#
directive|include
file|"../include/pte.h"
end_include

begin_include
include|#
directive|include
file|"../uba/upreg.h"
end_include

begin_include
include|#
directive|include
file|"../uba/ubareg.h"
end_include

begin_include
include|#
directive|include
file|"stand/saio.h"
end_include

begin_include
include|#
directive|include
file|"savax.h"
end_include

begin_decl_stmt
specifier|static
name|short
name|up9300_off
index|[]
init|=
block|{
literal|0
block|,
literal|27
block|,
literal|0
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
literal|562
block|,
literal|82
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|short
name|fj_off
index|[]
init|=
block|{
literal|0
block|,
literal|50
block|,
literal|0
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
literal|155
block|,
operator|-
literal|1
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|short
name|upam_off
index|[]
init|=
block|{
literal|0
block|,
literal|32
block|,
literal|0
block|,
literal|668
block|,
literal|723
block|,
literal|778
block|,
literal|668
block|,
literal|98
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|short
name|up980_off
index|[]
init|=
block|{
literal|0
block|,
literal|100
block|,
literal|0
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
literal|309
block|,
operator|-
literal|1
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|short
name|eagle_off
index|[]
init|=
block|{
literal|0
block|,
literal|17
block|,
literal|0
block|,
literal|391
block|,
literal|408
block|,
literal|728
block|,
literal|391
block|,
literal|87
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|st
name|upst
index|[]
init|=
block|{
literal|32
block|,
literal|19
block|,
literal|32
operator|*
literal|19
block|,
literal|815
block|,
name|up9300_off
block|,
comment|/* 9300 */
literal|32
block|,
literal|19
block|,
literal|32
operator|*
literal|19
block|,
literal|823
block|,
name|up9300_off
block|,
comment|/* 9766 */
literal|32
block|,
literal|10
block|,
literal|32
operator|*
literal|10
block|,
literal|823
block|,
name|fj_off
block|,
comment|/* Fuji 160 */
literal|32
block|,
literal|16
block|,
literal|32
operator|*
literal|16
block|,
literal|1024
block|,
name|upam_off
block|,
comment|/* Capricorn */
literal|32
block|,
literal|5
block|,
literal|32
operator|*
literal|5
block|,
literal|823
block|,
name|up980_off
block|,
comment|/* DM980 */
literal|48
block|,
literal|20
block|,
literal|48
operator|*
literal|20
block|,
literal|842
block|,
name|eagle_off
block|,
comment|/* Fuji Eagle */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|, }
decl_stmt|;
end_decl_stmt

begin_macro
name|upmaptype
argument_list|(
argument|unit
argument_list|,
argument|upaddr
argument_list|,
argument|lp
argument_list|)
end_macro

begin_decl_stmt
name|int
name|unit
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|struct
name|updevice
modifier|*
name|upaddr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|struct
name|disklabel
modifier|*
name|lp
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|st
modifier|*
name|st
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|int
name|type
init|=
operator|-
literal|1
decl_stmt|;
name|upaddr
operator|->
name|upcs1
operator|=
literal|0
expr_stmt|;
name|upaddr
operator|->
name|upcs2
operator|=
name|unit
operator|%
literal|8
expr_stmt|;
name|upaddr
operator|->
name|uphr
operator|=
name|UPHR_MAXTRAK
expr_stmt|;
for|for
control|(
name|st
operator|=
name|upst
init|;
condition|;
operator|++
name|st
control|)
block|{
if|if
condition|(
operator|!
name|st
operator|->
name|ntrak
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|upaddr
operator|->
name|uphr
operator|==
name|st
operator|->
name|ntrak
operator|-
literal|1
condition|)
block|{
name|type
operator|=
name|st
operator|-
name|upst
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|type
operator|==
literal|0
condition|)
block|{
name|upaddr
operator|->
name|uphr
operator|=
name|UPHR_MAXCYL
expr_stmt|;
if|if
condition|(
name|upaddr
operator|->
name|uphr
operator|==
literal|822
condition|)
comment|/* CDC 9766 */
operator|++
name|type
expr_stmt|;
block|}
name|upaddr
operator|->
name|upcs2
operator|=
name|UPCS2_CLR
expr_stmt|;
name|st
operator|=
operator|&
name|upst
index|[
name|type
index|]
expr_stmt|;
comment|/* set up a minimal disk label */
name|lp
operator|->
name|d_nsectors
operator|=
name|st
operator|->
name|nsect
expr_stmt|;
name|lp
operator|->
name|d_ntracks
operator|=
name|st
operator|->
name|ntrak
expr_stmt|;
name|lp
operator|->
name|d_secpercyl
operator|=
name|st
operator|->
name|nspc
expr_stmt|;
name|lp
operator|->
name|d_ncylinders
operator|=
name|st
operator|->
name|ncyl
expr_stmt|;
name|lp
operator|->
name|d_secperunit
operator|=
name|st
operator|->
name|nspc
operator|*
name|st
operator|->
name|ncyl
expr_stmt|;
name|lp
operator|->
name|d_npartitions
operator|=
literal|8
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|st
operator|->
name|off
index|[
name|i
index|]
operator|==
operator|-
literal|1
condition|)
name|lp
operator|->
name|d_partitions
index|[
name|i
index|]
operator|.
name|p_size
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|lp
operator|->
name|d_partitions
index|[
name|i
index|]
operator|.
name|p_offset
operator|=
name|st
operator|->
name|off
index|[
name|i
index|]
operator|*
name|lp
operator|->
name|d_secpercyl
expr_stmt|;
name|lp
operator|->
name|d_partitions
index|[
name|i
index|]
operator|.
name|p_size
operator|=
name|lp
operator|->
name|d_secperunit
expr_stmt|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* COMPAT_42 */
end_comment

end_unit

