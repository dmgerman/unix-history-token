begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1980, 1988, 1991, 1993  *	The Regents of the University of California.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by the University of  *	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)traverse.c	8.1 (Berkeley) 6/5/93"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|sunos
end_ifdef

begin_include
include|#
directive|include
file|<sys/vnode.h>
end_include

begin_include
include|#
directive|include
file|<ufs/fs.h>
end_include

begin_include
include|#
directive|include
file|<ufs/fsdir.h>
end_include

begin_include
include|#
directive|include
file|<ufs/inode.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<ufs/ffs/fs.h>
end_include

begin_include
include|#
directive|include
file|<ufs/ufs/dir.h>
end_include

begin_include
include|#
directive|include
file|<ufs/ufs/dinode.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<protocols/dumprestore.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|__STDC__
end_ifdef

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"dump.h"
end_include

begin_define
define|#
directive|define
name|HASDUMPEDFILE
value|0x1
end_define

begin_define
define|#
directive|define
name|HASSUBDIRS
value|0x2
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|FS_44INODEFMT
end_ifdef

begin_typedef
typedef|typedef
name|quad_t
name|fsizeT
typedef|;
end_typedef

begin_else
else|#
directive|else
end_else

begin_typedef
typedef|typedef
name|long
name|fsizeT
typedef|;
end_typedef

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|int
name|dirindir
name|__P
argument_list|(
operator|(
name|ino_t
name|ino
operator|,
name|daddr_t
name|blkno
operator|,
name|int
name|level
operator|,
name|long
operator|*
name|size
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dmpindir
name|__P
argument_list|(
operator|(
name|ino_t
name|ino
operator|,
name|daddr_t
name|blk
operator|,
name|int
name|level
operator|,
name|fsizeT
operator|*
name|size
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|searchdir
name|__P
argument_list|(
operator|(
name|ino_t
name|ino
operator|,
name|daddr_t
name|blkno
operator|,
name|long
name|size
operator|,
name|long
name|filesize
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * This is an estimation of the number of TP_BSIZE blocks in the file.  * It estimates the number of blocks in files with holes by assuming  * that all of the blocks accounted for by di_blocks are data blocks  * (when some of the blocks are usually used for indirect pointers);  * hence the estimate may be high.  */
end_comment

begin_function
name|long
name|blockest
parameter_list|(
name|dp
parameter_list|)
specifier|register
name|struct
name|dinode
modifier|*
name|dp
decl_stmt|;
block|{
name|long
name|blkest
decl_stmt|,
name|sizeest
decl_stmt|;
comment|/* 	 * dp->di_size is the size of the file in bytes. 	 * dp->di_blocks stores the number of sectors actually in the file. 	 * If there are more sectors than the size would indicate, this just 	 *	means that there are indirect blocks in the file or unused 	 *	sectors in the last file block; we can safely ignore these 	 *	(blkest = sizeest below). 	 * If the file is bigger than the number of sectors would indicate, 	 *	then the file has holes in it.	In this case we must use the 	 *	block count to estimate the number of data blocks used, but 	 *	we use the actual size for estimating the number of indirect 	 *	dump blocks (sizeest vs. blkest in the indirect block 	 *	calculation). 	 */
name|blkest
operator|=
name|howmany
argument_list|(
name|dbtob
argument_list|(
name|dp
operator|->
name|di_blocks
argument_list|)
argument_list|,
name|TP_BSIZE
argument_list|)
expr_stmt|;
name|sizeest
operator|=
name|howmany
argument_list|(
name|dp
operator|->
name|di_size
argument_list|,
name|TP_BSIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|blkest
operator|>
name|sizeest
condition|)
name|blkest
operator|=
name|sizeest
expr_stmt|;
if|if
condition|(
name|dp
operator|->
name|di_size
operator|>
name|sblock
operator|->
name|fs_bsize
operator|*
name|NDADDR
condition|)
block|{
comment|/* calculate the number of indirect blocks on the dump tape */
name|blkest
operator|+=
name|howmany
argument_list|(
name|sizeest
operator|-
name|NDADDR
operator|*
name|sblock
operator|->
name|fs_bsize
operator|/
name|TP_BSIZE
argument_list|,
name|TP_NINDIR
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|blkest
operator|+
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Auxiliary macro to pick up files changed since previous dump. */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|FS_44INODEFMT
end_ifdef

begin_define
define|#
directive|define
name|CHANGEDSINCE
parameter_list|(
name|dp
parameter_list|,
name|t
parameter_list|)
define|\
value|((dp)->di_mtime.ts_sec>= (t) || (dp)->di_ctime.ts_sec>= (t))
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CHANGEDSINCE
parameter_list|(
name|dp
parameter_list|,
name|t
parameter_list|)
define|\
value|((dp)->di_mtime>= (t) || (dp)->di_ctime>= (t))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* The WANTTODUMP macro decides whether a file should be dumped. */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|UF_NODUMP
end_ifdef

begin_define
define|#
directive|define
name|WANTTODUMP
parameter_list|(
name|dp
parameter_list|)
define|\
value|(CHANGEDSINCE(dp, spcl.c_ddate)&& \ 	 (nonodump || ((dp)->di_flags& UF_NODUMP) != UF_NODUMP))
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|WANTTODUMP
parameter_list|(
name|dp
parameter_list|)
value|CHANGEDSINCE(dp, spcl.c_ddate)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Dump pass 1.  *  * Walk the inode list for a filesystem to find all allocated inodes  * that have been modified since the previous dump time. Also, find all  * the directories in the filesystem.  */
end_comment

begin_function
name|int
name|mapfiles
parameter_list|(
name|maxino
parameter_list|,
name|tapesize
parameter_list|)
name|ino_t
name|maxino
decl_stmt|;
name|long
modifier|*
name|tapesize
decl_stmt|;
block|{
specifier|register
name|int
name|mode
decl_stmt|;
specifier|register
name|ino_t
name|ino
decl_stmt|;
specifier|register
name|struct
name|dinode
modifier|*
name|dp
decl_stmt|;
name|int
name|anydirskipped
init|=
literal|0
decl_stmt|;
for|for
control|(
name|ino
operator|=
name|ROOTINO
init|;
name|ino
operator|<
name|maxino
condition|;
name|ino
operator|++
control|)
block|{
name|dp
operator|=
name|getino
argument_list|(
name|ino
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|mode
operator|=
operator|(
name|dp
operator|->
name|di_mode
operator|&
name|IFMT
operator|)
operator|)
operator|==
literal|0
condition|)
continue|continue;
name|SETINO
argument_list|(
name|ino
argument_list|,
name|usedinomap
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|IFDIR
condition|)
name|SETINO
argument_list|(
name|ino
argument_list|,
name|dumpdirmap
argument_list|)
expr_stmt|;
if|if
condition|(
name|WANTTODUMP
argument_list|(
name|dp
argument_list|)
condition|)
block|{
name|SETINO
argument_list|(
name|ino
argument_list|,
name|dumpinomap
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|!=
name|IFREG
operator|&&
name|mode
operator|!=
name|IFDIR
operator|&&
name|mode
operator|!=
name|IFLNK
condition|)
operator|*
name|tapesize
operator|+=
literal|1
expr_stmt|;
else|else
operator|*
name|tapesize
operator|+=
name|blockest
argument_list|(
name|dp
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|mode
operator|==
name|IFDIR
condition|)
name|anydirskipped
operator|=
literal|1
expr_stmt|;
block|}
comment|/* 	 * Restore gets very upset if the root is not dumped, 	 * so ensure that it always is dumped. 	 */
name|SETINO
argument_list|(
name|ROOTINO
argument_list|,
name|dumpinomap
argument_list|)
expr_stmt|;
return|return
operator|(
name|anydirskipped
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Dump pass 2.  *  * Scan each directory on the filesystem to see if it has any modified  * files in it. If it does, and has not already been added to the dump  * list (because it was itself modified), then add it. If a directory  * has not been modified itself, contains no modified files and has no  * subdirectories, then it can be deleted from the dump list and from  * the list of directories. By deleting it from the list of directories,  * its parent may now qualify for the same treatment on this or a later  * pass using this algorithm.  */
end_comment

begin_function
name|int
name|mapdirs
parameter_list|(
name|maxino
parameter_list|,
name|tapesize
parameter_list|)
name|ino_t
name|maxino
decl_stmt|;
name|long
modifier|*
name|tapesize
decl_stmt|;
block|{
specifier|register
name|struct
name|dinode
modifier|*
name|dp
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|,
name|isdir
decl_stmt|;
specifier|register
name|char
modifier|*
name|map
decl_stmt|;
specifier|register
name|ino_t
name|ino
decl_stmt|;
name|long
name|filesize
decl_stmt|;
name|int
name|ret
decl_stmt|,
name|change
init|=
literal|0
decl_stmt|;
name|isdir
operator|=
literal|0
expr_stmt|;
comment|/* XXX just to get gcc to shut up */
for|for
control|(
name|map
operator|=
name|dumpdirmap
operator|,
name|ino
operator|=
literal|1
init|;
name|ino
operator|<
name|maxino
condition|;
name|ino
operator|++
control|)
block|{
if|if
condition|(
operator|(
operator|(
name|ino
operator|-
literal|1
operator|)
operator|%
name|NBBY
operator|)
operator|==
literal|0
condition|)
comment|/* map is offset by 1 */
name|isdir
operator|=
operator|*
name|map
operator|++
expr_stmt|;
else|else
name|isdir
operator|>>=
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|isdir
operator|&
literal|1
operator|)
operator|==
literal|0
operator|||
name|TSTINO
argument_list|(
name|ino
argument_list|,
name|dumpinomap
argument_list|)
condition|)
continue|continue;
name|dp
operator|=
name|getino
argument_list|(
name|ino
argument_list|)
expr_stmt|;
name|filesize
operator|=
name|dp
operator|->
name|di_size
expr_stmt|;
for|for
control|(
name|ret
operator|=
literal|0
operator|,
name|i
operator|=
literal|0
init|;
name|filesize
operator|>
literal|0
operator|&&
name|i
operator|<
name|NDADDR
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|dp
operator|->
name|di_db
index|[
name|i
index|]
operator|!=
literal|0
condition|)
name|ret
operator||=
name|searchdir
argument_list|(
name|ino
argument_list|,
name|dp
operator|->
name|di_db
index|[
name|i
index|]
argument_list|,
operator|(
name|long
operator|)
name|dblksize
argument_list|(
name|sblock
argument_list|,
name|dp
argument_list|,
name|i
argument_list|)
argument_list|,
name|filesize
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|&
name|HASDUMPEDFILE
condition|)
name|filesize
operator|=
literal|0
expr_stmt|;
else|else
name|filesize
operator|-=
name|sblock
operator|->
name|fs_bsize
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|filesize
operator|>
literal|0
operator|&&
name|i
operator|<
name|NIADDR
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|dp
operator|->
name|di_ib
index|[
name|i
index|]
operator|==
literal|0
condition|)
continue|continue;
name|ret
operator||=
name|dirindir
argument_list|(
name|ino
argument_list|,
name|dp
operator|->
name|di_ib
index|[
name|i
index|]
argument_list|,
name|i
argument_list|,
operator|&
name|filesize
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ret
operator|&
name|HASDUMPEDFILE
condition|)
block|{
name|SETINO
argument_list|(
name|ino
argument_list|,
name|dumpinomap
argument_list|)
expr_stmt|;
operator|*
name|tapesize
operator|+=
name|blockest
argument_list|(
name|dp
argument_list|)
expr_stmt|;
name|change
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|(
name|ret
operator|&
name|HASSUBDIRS
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|TSTINO
argument_list|(
name|ino
argument_list|,
name|dumpinomap
argument_list|)
condition|)
block|{
name|CLRINO
argument_list|(
name|ino
argument_list|,
name|dumpdirmap
argument_list|)
expr_stmt|;
name|change
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
return|return
operator|(
name|change
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Read indirect blocks, and pass the data blocks to be searched  * as directories. Quit as soon as any entry is found that will  * require the directory to be dumped.  */
end_comment

begin_function
specifier|static
name|int
name|dirindir
parameter_list|(
name|ino
parameter_list|,
name|blkno
parameter_list|,
name|ind_level
parameter_list|,
name|filesize
parameter_list|)
name|ino_t
name|ino
decl_stmt|;
name|daddr_t
name|blkno
decl_stmt|;
name|int
name|ind_level
decl_stmt|;
name|long
modifier|*
name|filesize
decl_stmt|;
block|{
name|int
name|ret
init|=
literal|0
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|daddr_t
name|idblk
index|[
name|MAXNINDIR
index|]
decl_stmt|;
name|bread
argument_list|(
name|fsbtodb
argument_list|(
name|sblock
argument_list|,
name|blkno
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
name|idblk
argument_list|,
operator|(
name|int
operator|)
name|sblock
operator|->
name|fs_bsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|ind_level
operator|<=
literal|0
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|*
name|filesize
operator|>
literal|0
operator|&&
name|i
operator|<
name|NINDIR
argument_list|(
name|sblock
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|blkno
operator|=
name|idblk
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|blkno
operator|!=
literal|0
condition|)
name|ret
operator||=
name|searchdir
argument_list|(
name|ino
argument_list|,
name|blkno
argument_list|,
name|sblock
operator|->
name|fs_bsize
argument_list|,
operator|*
name|filesize
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|&
name|HASDUMPEDFILE
condition|)
operator|*
name|filesize
operator|=
literal|0
expr_stmt|;
else|else
operator|*
name|filesize
operator|-=
name|sblock
operator|->
name|fs_bsize
expr_stmt|;
block|}
return|return
operator|(
name|ret
operator|)
return|;
block|}
name|ind_level
operator|--
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|*
name|filesize
operator|>
literal|0
operator|&&
name|i
operator|<
name|NINDIR
argument_list|(
name|sblock
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|blkno
operator|=
name|idblk
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|blkno
operator|!=
literal|0
condition|)
name|ret
operator||=
name|dirindir
argument_list|(
name|ino
argument_list|,
name|blkno
argument_list|,
name|ind_level
argument_list|,
name|filesize
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Scan a disk block containing directory information looking to see if  * any of the entries are on the dump list and to see if the directory  * contains any subdirectories.  */
end_comment

begin_function
specifier|static
name|int
name|searchdir
parameter_list|(
name|ino
parameter_list|,
name|blkno
parameter_list|,
name|size
parameter_list|,
name|filesize
parameter_list|)
name|ino_t
name|ino
decl_stmt|;
name|daddr_t
name|blkno
decl_stmt|;
specifier|register
name|long
name|size
decl_stmt|;
name|long
name|filesize
decl_stmt|;
block|{
specifier|register
name|struct
name|direct
modifier|*
name|dp
decl_stmt|;
specifier|register
name|long
name|loc
decl_stmt|,
name|ret
init|=
literal|0
decl_stmt|;
name|char
name|dblk
index|[
name|MAXBSIZE
index|]
decl_stmt|;
name|bread
argument_list|(
name|fsbtodb
argument_list|(
name|sblock
argument_list|,
name|blkno
argument_list|)
argument_list|,
name|dblk
argument_list|,
operator|(
name|int
operator|)
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|filesize
operator|<
name|size
condition|)
name|size
operator|=
name|filesize
expr_stmt|;
for|for
control|(
name|loc
operator|=
literal|0
init|;
name|loc
operator|<
name|size
condition|;
control|)
block|{
name|dp
operator|=
operator|(
expr|struct
name|direct
operator|*
operator|)
operator|(
name|dblk
operator|+
name|loc
operator|)
expr_stmt|;
if|if
condition|(
name|dp
operator|->
name|d_reclen
operator|==
literal|0
condition|)
block|{
name|msg
argument_list|(
literal|"corrupted directory, inumber %d\n"
argument_list|,
name|ino
argument_list|)
expr_stmt|;
break|break;
block|}
name|loc
operator|+=
name|dp
operator|->
name|d_reclen
expr_stmt|;
if|if
condition|(
name|dp
operator|->
name|d_ino
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|dp
operator|->
name|d_name
index|[
literal|0
index|]
operator|==
literal|'.'
condition|)
block|{
if|if
condition|(
name|dp
operator|->
name|d_name
index|[
literal|1
index|]
operator|==
literal|'\0'
condition|)
continue|continue;
if|if
condition|(
name|dp
operator|->
name|d_name
index|[
literal|1
index|]
operator|==
literal|'.'
operator|&&
name|dp
operator|->
name|d_name
index|[
literal|2
index|]
operator|==
literal|'\0'
condition|)
continue|continue;
block|}
if|if
condition|(
name|TSTINO
argument_list|(
name|dp
operator|->
name|d_ino
argument_list|,
name|dumpinomap
argument_list|)
condition|)
block|{
name|ret
operator||=
name|HASDUMPEDFILE
expr_stmt|;
if|if
condition|(
name|ret
operator|&
name|HASSUBDIRS
condition|)
break|break;
block|}
if|if
condition|(
name|TSTINO
argument_list|(
name|dp
operator|->
name|d_ino
argument_list|,
name|dumpdirmap
argument_list|)
condition|)
block|{
name|ret
operator||=
name|HASSUBDIRS
expr_stmt|;
if|if
condition|(
name|ret
operator|&
name|HASDUMPEDFILE
condition|)
break|break;
block|}
block|}
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Dump passes 3 and 4.  *  * Dump the contents of an inode to tape.  */
end_comment

begin_function
name|void
name|dumpino
parameter_list|(
name|dp
parameter_list|,
name|ino
parameter_list|)
specifier|register
name|struct
name|dinode
modifier|*
name|dp
decl_stmt|;
name|ino_t
name|ino
decl_stmt|;
block|{
name|int
name|ind_level
decl_stmt|,
name|cnt
decl_stmt|;
name|fsizeT
name|size
decl_stmt|;
name|char
name|buf
index|[
name|TP_BSIZE
index|]
decl_stmt|;
if|if
condition|(
name|newtape
condition|)
block|{
name|newtape
operator|=
literal|0
expr_stmt|;
name|dumpmap
argument_list|(
name|dumpinomap
argument_list|,
name|TS_BITS
argument_list|,
name|ino
argument_list|)
expr_stmt|;
block|}
name|CLRINO
argument_list|(
name|ino
argument_list|,
name|dumpinomap
argument_list|)
expr_stmt|;
name|spcl
operator|.
name|c_dinode
operator|=
operator|*
name|dp
expr_stmt|;
name|spcl
operator|.
name|c_type
operator|=
name|TS_INODE
expr_stmt|;
name|spcl
operator|.
name|c_count
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|dp
operator|->
name|di_mode
operator|&
name|S_IFMT
condition|)
block|{
case|case
literal|0
case|:
comment|/* 		 * Freed inode. 		 */
return|return;
case|case
name|S_IFLNK
case|:
comment|/* 		 * Check for short symbolic link. 		 */
ifdef|#
directive|ifdef
name|FS_44INODEFMT
if|if
condition|(
name|dp
operator|->
name|di_size
operator|>
literal|0
operator|&&
name|dp
operator|->
name|di_size
operator|<
name|sblock
operator|->
name|fs_maxsymlinklen
condition|)
block|{
name|spcl
operator|.
name|c_addr
index|[
literal|0
index|]
operator|=
literal|1
expr_stmt|;
name|spcl
operator|.
name|c_count
operator|=
literal|1
expr_stmt|;
name|writeheader
argument_list|(
name|ino
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
name|dp
operator|->
name|di_shortlink
argument_list|,
name|buf
argument_list|,
operator|(
name|u_long
operator|)
name|dp
operator|->
name|di_size
argument_list|)
expr_stmt|;
name|buf
index|[
name|dp
operator|->
name|di_size
index|]
operator|=
literal|'\0'
expr_stmt|;
name|writerec
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
comment|/* fall through */
case|case
name|S_IFDIR
case|:
case|case
name|S_IFREG
case|:
if|if
condition|(
name|dp
operator|->
name|di_size
operator|>
literal|0
condition|)
break|break;
comment|/* fall through */
case|case
name|S_IFIFO
case|:
case|case
name|S_IFSOCK
case|:
case|case
name|S_IFCHR
case|:
case|case
name|S_IFBLK
case|:
name|writeheader
argument_list|(
name|ino
argument_list|)
expr_stmt|;
return|return;
default|default:
name|msg
argument_list|(
literal|"Warning: undefined file type 0%o\n"
argument_list|,
name|dp
operator|->
name|di_mode
operator|&
name|IFMT
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|dp
operator|->
name|di_size
operator|>
name|NDADDR
operator|*
name|sblock
operator|->
name|fs_bsize
condition|)
name|cnt
operator|=
name|NDADDR
operator|*
name|sblock
operator|->
name|fs_frag
expr_stmt|;
else|else
name|cnt
operator|=
name|howmany
argument_list|(
name|dp
operator|->
name|di_size
argument_list|,
name|sblock
operator|->
name|fs_fsize
argument_list|)
expr_stmt|;
name|blksout
argument_list|(
operator|&
name|dp
operator|->
name|di_db
index|[
literal|0
index|]
argument_list|,
name|cnt
argument_list|,
name|ino
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|size
operator|=
name|dp
operator|->
name|di_size
operator|-
name|NDADDR
operator|*
name|sblock
operator|->
name|fs_bsize
operator|)
operator|<=
literal|0
condition|)
return|return;
for|for
control|(
name|ind_level
operator|=
literal|0
init|;
name|ind_level
operator|<
name|NIADDR
condition|;
name|ind_level
operator|++
control|)
block|{
name|dmpindir
argument_list|(
name|ino
argument_list|,
name|dp
operator|->
name|di_ib
index|[
name|ind_level
index|]
argument_list|,
name|ind_level
argument_list|,
operator|&
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|<=
literal|0
condition|)
return|return;
block|}
block|}
end_function

begin_comment
comment|/*  * Read indirect blocks, and pass the data blocks to be dumped.  */
end_comment

begin_function
specifier|static
name|void
name|dmpindir
parameter_list|(
name|ino
parameter_list|,
name|blk
parameter_list|,
name|ind_level
parameter_list|,
name|size
parameter_list|)
name|ino_t
name|ino
decl_stmt|;
name|daddr_t
name|blk
decl_stmt|;
name|int
name|ind_level
decl_stmt|;
name|fsizeT
modifier|*
name|size
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|cnt
decl_stmt|;
name|daddr_t
name|idblk
index|[
name|MAXNINDIR
index|]
decl_stmt|;
if|if
condition|(
name|blk
operator|!=
literal|0
condition|)
name|bread
argument_list|(
name|fsbtodb
argument_list|(
name|sblock
argument_list|,
name|blk
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
name|idblk
argument_list|,
operator|(
name|int
operator|)
name|sblock
operator|->
name|fs_bsize
argument_list|)
expr_stmt|;
else|else
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|idblk
argument_list|,
operator|(
name|int
operator|)
name|sblock
operator|->
name|fs_bsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|ind_level
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
operator|*
name|size
operator|<
name|NINDIR
argument_list|(
name|sblock
argument_list|)
operator|*
name|sblock
operator|->
name|fs_bsize
condition|)
name|cnt
operator|=
name|howmany
argument_list|(
operator|*
name|size
argument_list|,
name|sblock
operator|->
name|fs_fsize
argument_list|)
expr_stmt|;
else|else
name|cnt
operator|=
name|NINDIR
argument_list|(
name|sblock
argument_list|)
operator|*
name|sblock
operator|->
name|fs_frag
expr_stmt|;
operator|*
name|size
operator|-=
name|NINDIR
argument_list|(
name|sblock
argument_list|)
operator|*
name|sblock
operator|->
name|fs_bsize
expr_stmt|;
name|blksout
argument_list|(
operator|&
name|idblk
index|[
literal|0
index|]
argument_list|,
name|cnt
argument_list|,
name|ino
argument_list|)
expr_stmt|;
return|return;
block|}
name|ind_level
operator|--
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NINDIR
argument_list|(
name|sblock
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|dmpindir
argument_list|(
name|ino
argument_list|,
name|idblk
index|[
name|i
index|]
argument_list|,
name|ind_level
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|size
operator|<=
literal|0
condition|)
return|return;
block|}
block|}
end_function

begin_comment
comment|/*  * Collect up the data into tape record sized buffers and output them.  */
end_comment

begin_function
name|void
name|blksout
parameter_list|(
name|blkp
parameter_list|,
name|frags
parameter_list|,
name|ino
parameter_list|)
name|daddr_t
modifier|*
name|blkp
decl_stmt|;
name|int
name|frags
decl_stmt|;
name|ino_t
name|ino
decl_stmt|;
block|{
specifier|register
name|daddr_t
modifier|*
name|bp
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|count
decl_stmt|,
name|blks
decl_stmt|,
name|tbperdb
decl_stmt|;
name|blks
operator|=
name|howmany
argument_list|(
name|frags
operator|*
name|sblock
operator|->
name|fs_fsize
argument_list|,
name|TP_BSIZE
argument_list|)
expr_stmt|;
name|tbperdb
operator|=
name|sblock
operator|->
name|fs_bsize
operator|>>
name|tp_bshift
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|blks
condition|;
name|i
operator|+=
name|TP_NINDIR
control|)
block|{
if|if
condition|(
name|i
operator|+
name|TP_NINDIR
operator|>
name|blks
condition|)
name|count
operator|=
name|blks
expr_stmt|;
else|else
name|count
operator|=
name|i
operator|+
name|TP_NINDIR
expr_stmt|;
for|for
control|(
name|j
operator|=
name|i
init|;
name|j
operator|<
name|count
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|blkp
index|[
name|j
operator|/
name|tbperdb
index|]
operator|!=
literal|0
condition|)
name|spcl
operator|.
name|c_addr
index|[
name|j
operator|-
name|i
index|]
operator|=
literal|1
expr_stmt|;
else|else
name|spcl
operator|.
name|c_addr
index|[
name|j
operator|-
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|spcl
operator|.
name|c_count
operator|=
name|count
operator|-
name|i
expr_stmt|;
name|writeheader
argument_list|(
name|ino
argument_list|)
expr_stmt|;
name|bp
operator|=
operator|&
name|blkp
index|[
name|i
operator|/
name|tbperdb
index|]
expr_stmt|;
for|for
control|(
name|j
operator|=
name|i
init|;
name|j
operator|<
name|count
condition|;
name|j
operator|+=
name|tbperdb
operator|,
name|bp
operator|++
control|)
if|if
condition|(
operator|*
name|bp
operator|!=
literal|0
condition|)
if|if
condition|(
name|j
operator|+
name|tbperdb
operator|<=
name|count
condition|)
name|dumpblock
argument_list|(
operator|*
name|bp
argument_list|,
operator|(
name|int
operator|)
name|sblock
operator|->
name|fs_bsize
argument_list|)
expr_stmt|;
else|else
name|dumpblock
argument_list|(
operator|*
name|bp
argument_list|,
operator|(
name|count
operator|-
name|j
operator|)
operator|*
name|TP_BSIZE
argument_list|)
expr_stmt|;
name|spcl
operator|.
name|c_type
operator|=
name|TS_ADDR
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Dump a map to the tape.  */
end_comment

begin_function
name|void
name|dumpmap
parameter_list|(
name|map
parameter_list|,
name|type
parameter_list|,
name|ino
parameter_list|)
name|char
modifier|*
name|map
decl_stmt|;
name|int
name|type
decl_stmt|;
name|ino_t
name|ino
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
name|spcl
operator|.
name|c_type
operator|=
name|type
expr_stmt|;
name|spcl
operator|.
name|c_count
operator|=
name|howmany
argument_list|(
name|mapsize
operator|*
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|,
name|TP_BSIZE
argument_list|)
expr_stmt|;
name|writeheader
argument_list|(
name|ino
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|cp
operator|=
name|map
init|;
name|i
operator|<
name|spcl
operator|.
name|c_count
condition|;
name|i
operator|++
operator|,
name|cp
operator|+=
name|TP_BSIZE
control|)
name|writerec
argument_list|(
name|cp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Write a header record to the dump tape.  */
end_comment

begin_function
name|void
name|writeheader
parameter_list|(
name|ino
parameter_list|)
name|ino_t
name|ino
decl_stmt|;
block|{
specifier|register
name|long
name|sum
decl_stmt|,
name|cnt
decl_stmt|,
modifier|*
name|lp
decl_stmt|;
name|spcl
operator|.
name|c_inumber
operator|=
name|ino
expr_stmt|;
name|spcl
operator|.
name|c_magic
operator|=
name|NFS_MAGIC
expr_stmt|;
name|spcl
operator|.
name|c_checksum
operator|=
literal|0
expr_stmt|;
name|lp
operator|=
operator|(
name|long
operator|*
operator|)
operator|&
name|spcl
expr_stmt|;
name|sum
operator|=
literal|0
expr_stmt|;
name|cnt
operator|=
sizeof|sizeof
argument_list|(
expr|union
name|u_spcl
argument_list|)
operator|/
operator|(
literal|4
operator|*
sizeof|sizeof
argument_list|(
name|long
argument_list|)
operator|)
expr_stmt|;
while|while
condition|(
operator|--
name|cnt
operator|>=
literal|0
condition|)
block|{
name|sum
operator|+=
operator|*
name|lp
operator|++
expr_stmt|;
name|sum
operator|+=
operator|*
name|lp
operator|++
expr_stmt|;
name|sum
operator|+=
operator|*
name|lp
operator|++
expr_stmt|;
name|sum
operator|+=
operator|*
name|lp
operator|++
expr_stmt|;
block|}
name|spcl
operator|.
name|c_checksum
operator|=
name|CHECKSUM
operator|-
name|sum
expr_stmt|;
name|writerec
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|spcl
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|struct
name|dinode
modifier|*
name|getino
parameter_list|(
name|inum
parameter_list|)
name|ino_t
name|inum
decl_stmt|;
block|{
specifier|static
name|daddr_t
name|minino
decl_stmt|,
name|maxino
decl_stmt|;
specifier|static
name|struct
name|dinode
name|inoblock
index|[
name|MAXINOPB
index|]
decl_stmt|;
name|curino
operator|=
name|inum
expr_stmt|;
if|if
condition|(
name|inum
operator|>=
name|minino
operator|&&
name|inum
operator|<
name|maxino
condition|)
return|return
operator|(
operator|&
name|inoblock
index|[
name|inum
operator|-
name|minino
index|]
operator|)
return|;
name|bread
argument_list|(
name|fsbtodb
argument_list|(
name|sblock
argument_list|,
name|itod
argument_list|(
name|sblock
argument_list|,
name|inum
argument_list|)
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
name|inoblock
argument_list|,
operator|(
name|int
operator|)
name|sblock
operator|->
name|fs_bsize
argument_list|)
expr_stmt|;
name|minino
operator|=
name|inum
operator|-
operator|(
name|inum
operator|%
name|INOPB
argument_list|(
name|sblock
argument_list|)
operator|)
expr_stmt|;
name|maxino
operator|=
name|minino
operator|+
name|INOPB
argument_list|(
name|sblock
argument_list|)
expr_stmt|;
return|return
operator|(
operator|&
name|inoblock
index|[
name|inum
operator|-
name|minino
index|]
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Read a chunk of data from the disk.  * Try to recover from hard errors by reading in sector sized pieces.  * Error recovery is attempted at most BREADEMAX times before seeking  * consent from the operator to continue.  */
end_comment

begin_decl_stmt
name|int
name|breaderrors
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|BREADEMAX
value|32
end_define

begin_function
name|void
name|bread
parameter_list|(
name|blkno
parameter_list|,
name|buf
parameter_list|,
name|size
parameter_list|)
name|daddr_t
name|blkno
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
name|int
name|size
decl_stmt|;
block|{
name|int
name|cnt
decl_stmt|,
name|i
decl_stmt|;
specifier|extern
name|int
name|errno
decl_stmt|;
name|loop
label|:
if|if
condition|(
operator|(
name|int
operator|)
name|lseek
argument_list|(
name|diskfd
argument_list|,
operator|(
operator|(
name|off_t
operator|)
name|blkno
operator|<<
name|dev_bshift
operator|)
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
name|msg
argument_list|(
literal|"bread: lseek fails\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cnt
operator|=
name|read
argument_list|(
name|diskfd
argument_list|,
name|buf
argument_list|,
name|size
argument_list|)
operator|)
operator|==
name|size
condition|)
return|return;
if|if
condition|(
name|blkno
operator|+
operator|(
name|size
operator|/
name|dev_bsize
operator|)
operator|>
name|fsbtodb
argument_list|(
name|sblock
argument_list|,
name|sblock
operator|->
name|fs_size
argument_list|)
condition|)
block|{
comment|/* 		 * Trying to read the final fragment. 		 * 		 * NB - dump only works in TP_BSIZE blocks, hence 		 * rounds `dev_bsize' fragments up to TP_BSIZE pieces. 		 * It should be smarter about not actually trying to 		 * read more than it can get, but for the time being 		 * we punt and scale back the read only when it gets 		 * us into trouble. (mkm 9/25/83) 		 */
name|size
operator|-=
name|dev_bsize
expr_stmt|;
goto|goto
name|loop
goto|;
block|}
if|if
condition|(
name|cnt
operator|==
operator|-
literal|1
condition|)
name|msg
argument_list|(
literal|"read error from %s: %s: [block %d]: count=%d\n"
argument_list|,
name|disk
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|,
name|blkno
argument_list|,
name|size
argument_list|)
expr_stmt|;
else|else
name|msg
argument_list|(
literal|"short read error from %s: [block %d]: count=%d, got=%d\n"
argument_list|,
name|disk
argument_list|,
name|blkno
argument_list|,
name|size
argument_list|,
name|cnt
argument_list|)
expr_stmt|;
if|if
condition|(
operator|++
name|breaderrors
operator|>
name|BREADEMAX
condition|)
block|{
name|msg
argument_list|(
literal|"More than %d block read errors from %d\n"
argument_list|,
name|BREADEMAX
argument_list|,
name|disk
argument_list|)
expr_stmt|;
name|broadcast
argument_list|(
literal|"DUMP IS AILING!\n"
argument_list|)
expr_stmt|;
name|msg
argument_list|(
literal|"This is an unrecoverable error.\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|query
argument_list|(
literal|"Do you want to attempt to continue?"
argument_list|)
condition|)
block|{
name|dumpabort
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
block|}
else|else
name|breaderrors
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 	 * Zero buffer, then try to read each sector of buffer separately. 	 */
name|bzero
argument_list|(
name|buf
argument_list|,
name|size
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|size
condition|;
name|i
operator|+=
name|dev_bsize
operator|,
name|buf
operator|+=
name|dev_bsize
operator|,
name|blkno
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|int
operator|)
name|lseek
argument_list|(
name|diskfd
argument_list|,
operator|(
operator|(
name|off_t
operator|)
name|blkno
operator|<<
name|dev_bshift
operator|)
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
name|msg
argument_list|(
literal|"bread: lseek2 fails!\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cnt
operator|=
name|read
argument_list|(
name|diskfd
argument_list|,
name|buf
argument_list|,
operator|(
name|int
operator|)
name|dev_bsize
argument_list|)
operator|)
operator|==
name|dev_bsize
condition|)
continue|continue;
if|if
condition|(
name|cnt
operator|==
operator|-
literal|1
condition|)
block|{
name|msg
argument_list|(
literal|"read error from %s: %s: [sector %d]: count=%d\n"
argument_list|,
name|disk
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|,
name|blkno
argument_list|,
name|dev_bsize
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|msg
argument_list|(
literal|"short read error from %s: [sector %d]: count=%d, got=%d\n"
argument_list|,
name|disk
argument_list|,
name|blkno
argument_list|,
name|dev_bsize
argument_list|,
name|cnt
argument_list|)
expr_stmt|;
block|}
block|}
end_function

end_unit

