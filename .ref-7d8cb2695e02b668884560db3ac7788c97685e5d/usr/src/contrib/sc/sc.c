begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	SC	A Spreadsheet Calculator  *		Main driver  *  *		original by James Gosling, September 1982  *		modifications by Mark Weiser and Bruce Israel,  *			University of Maryland  *  *              More mods Robert Bond, 12/86  *		More mods by Alan Silverstein, 3-4/88, see list of changes.  *		Currently supported by pur-phy!sawmill!buhrt (Jeff Buhrt)  *		$Revision: 6.8 $  *  */
end_comment

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<curses.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|BSD42
end_ifdef

begin_include
include|#
directive|include
file|<strings.h>
end_include

begin_else
else|#
directive|else
end_else

begin_ifndef
ifndef|#
directive|ifndef
name|SYSIII
end_ifndef

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"sc.h"
end_include

begin_function_decl
name|char
modifier|*
name|getenv
parameter_list|()
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|SYSV3
end_ifdef

begin_function_decl
name|void
name|exit
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|DFLT_PAGER
end_ifndef

begin_define
define|#
directive|define
name|DFLT_PAGER
value|"more"
end_define

begin_comment
comment|/* more is probably more widespread than less */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DFLT_PAGER */
end_comment

begin_define
define|#
directive|define
name|MAXCMD
value|160
end_define

begin_comment
comment|/* for ! command below */
end_comment

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|rev
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Globals defined in sc.h */
end_comment

begin_decl_stmt
name|struct
name|ent
modifier|*
modifier|*
modifier|*
name|tbl
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|strow
decl_stmt|,
name|stcol
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|currow
decl_stmt|,
name|curcol
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|savedrow
decl_stmt|,
name|savedcol
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|FullUpdate
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|maxrow
decl_stmt|,
name|maxcol
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|maxrows
decl_stmt|,
name|maxcols
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
modifier|*
name|fwidth
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
modifier|*
name|precision
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|col_hidden
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|row_hidden
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|line
index|[
name|FBUFLEN
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|changed
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|ent
modifier|*
name|to_fix
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|modflg
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|numeric
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|mdir
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|showsc
decl_stmt|,
name|showsr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Starting cell for highlighted range */
end_comment

begin_decl_stmt
name|char
name|mode_ind
init|=
literal|'.'
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|curfile
index|[
name|PATHLEN
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|revmsg
index|[
literal|80
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|linelim
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|showtop
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Causes current cell value display in top line  */
end_comment

begin_decl_stmt
name|int
name|showcell
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Causes current cell to be highlighted	  */
end_comment

begin_decl_stmt
name|int
name|showrange
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Causes ranges to be highlighted		  */
end_comment

begin_decl_stmt
name|int
name|showneed
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Causes cells needing values to be highlighted  */
end_comment

begin_decl_stmt
name|int
name|showexpr
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Causes cell exprs to be displayed, highlighted */
end_comment

begin_decl_stmt
name|int
name|autocalc
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 1 to calculate after each update */
end_comment

begin_decl_stmt
name|int
name|calc_order
init|=
name|BYROWS
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|tbl_style
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* headers for T command output */
end_comment

begin_decl_stmt
name|int
name|lastmx
decl_stmt|,
name|lastmy
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Screen address of the cursor */
end_comment

begin_decl_stmt
name|int
name|lastcol
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Spreadsheet Column the cursor was in last */
end_comment

begin_decl_stmt
name|char
name|under_cursor
index|[]
init|=
literal|" "
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Data under the< cursor */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|VMS
end_ifdef

begin_decl_stmt
name|int
name|VMS_read_raw
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|int
name|seenerr
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|yyerror
parameter_list|(
name|err
parameter_list|)
name|char
modifier|*
name|err
decl_stmt|;
block|{
if|if
condition|(
name|seenerr
condition|)
return|return;
name|seenerr
operator|++
expr_stmt|;
operator|(
name|void
operator|)
name|move
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|clrtoeol
argument_list|()
expr_stmt|;
operator|(
name|void
operator|)
name|printw
argument_list|(
literal|"%s: %.*s<=%s"
argument_list|,
name|err
argument_list|,
name|linelim
argument_list|,
name|line
argument_list|,
name|line
operator|+
name|linelim
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|struct
name|ent
modifier|*
name|lookat
parameter_list|(
name|row
parameter_list|,
name|col
parameter_list|)
name|int
name|row
decl_stmt|,
name|col
decl_stmt|;
block|{
specifier|register
name|struct
name|ent
modifier|*
modifier|*
name|pp
decl_stmt|;
name|checkbounds
argument_list|(
operator|&
name|row
argument_list|,
operator|&
name|col
argument_list|)
expr_stmt|;
name|pp
operator|=
name|ATBL
argument_list|(
name|tbl
argument_list|,
name|row
argument_list|,
name|col
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|pp
operator|==
operator|(
expr|struct
name|ent
operator|*
operator|)
literal|0
condition|)
block|{
operator|*
name|pp
operator|=
operator|(
expr|struct
name|ent
operator|*
operator|)
name|xmalloc
argument_list|(
operator|(
name|unsigned
operator|)
sizeof|sizeof
argument_list|(
expr|struct
name|ent
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|row
operator|>
name|maxrow
condition|)
name|maxrow
operator|=
name|row
expr_stmt|;
if|if
condition|(
name|col
operator|>
name|maxcol
condition|)
name|maxcol
operator|=
name|col
expr_stmt|;
operator|(
operator|*
name|pp
operator|)
operator|->
name|label
operator|=
operator|(
name|char
operator|*
operator|)
literal|0
expr_stmt|;
operator|(
operator|*
name|pp
operator|)
operator|->
name|row
operator|=
name|row
expr_stmt|;
operator|(
operator|*
name|pp
operator|)
operator|->
name|col
operator|=
name|col
expr_stmt|;
operator|(
operator|*
name|pp
operator|)
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
operator|(
operator|*
name|pp
operator|)
operator|->
name|expr
operator|=
operator|(
expr|struct
name|enode
operator|*
operator|)
literal|0
expr_stmt|;
operator|(
operator|*
name|pp
operator|)
operator|->
name|v
operator|=
operator|(
name|double
operator|)
literal|0.0
expr_stmt|;
operator|(
operator|*
name|pp
operator|)
operator|->
name|evnext
operator|=
operator|(
expr|struct
name|ent
operator|*
operator|)
literal|0
expr_stmt|;
block|}
return|return
operator|*
name|pp
return|;
block|}
end_function

begin_comment
comment|/*  * This structure is used to keep ent structs around before they  * are deleted to allow the sync_refs routine a chance to fix the  * variable references.  * We also use it as a last-deleted buffer for the 'p' command.  */
end_comment

begin_function
name|void
name|free_ent
parameter_list|(
name|p
parameter_list|)
specifier|register
name|struct
name|ent
modifier|*
name|p
decl_stmt|;
block|{
name|p
operator|->
name|next
operator|=
name|to_fix
expr_stmt|;
name|to_fix
operator|=
name|p
expr_stmt|;
name|p
operator|->
name|flags
operator||=
name|is_deleted
expr_stmt|;
block|}
end_function

begin_function
name|void
name|flush_saved
parameter_list|()
block|{
specifier|register
name|struct
name|ent
modifier|*
name|p
decl_stmt|;
specifier|register
name|struct
name|ent
modifier|*
name|q
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|p
operator|=
name|to_fix
operator|)
condition|)
return|return;
while|while
condition|(
name|p
condition|)
block|{
operator|(
name|void
operator|)
name|clearent
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|q
operator|=
name|p
operator|->
name|next
expr_stmt|;
name|xfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|p
argument_list|)
expr_stmt|;
name|p
operator|=
name|q
expr_stmt|;
block|}
name|to_fix
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * standout last time in update()?  *	At this point we will let curses do work  */
end_comment

begin_decl_stmt
name|int
name|standlast
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|update
parameter_list|(
name|anychanged
parameter_list|)
name|int
name|anychanged
decl_stmt|;
comment|/* did any cell really change in value? */
block|{
specifier|register
name|row
operator|,
name|col
expr_stmt|;
specifier|register
name|struct
name|ent
modifier|*
modifier|*
name|pp
decl_stmt|;
name|int
name|mxcol
decl_stmt|;
name|int
name|mxrow
decl_stmt|;
name|int
name|rows
decl_stmt|;
name|int
name|cols
decl_stmt|;
name|int
name|minsr
decl_stmt|,
name|minsc
decl_stmt|,
name|maxsr
decl_stmt|,
name|maxsc
decl_stmt|;
specifier|register
name|r
expr_stmt|;
specifier|register
name|i
expr_stmt|;
while|while
condition|(
name|row_hidden
index|[
name|currow
index|]
condition|)
comment|/* You can't hide the last row or col */
name|currow
operator|++
expr_stmt|;
while|while
condition|(
name|col_hidden
index|[
name|curcol
index|]
condition|)
name|curcol
operator|++
expr_stmt|;
comment|/* First see if the last display still covers curcol */
if|if
condition|(
name|stcol
operator|<=
name|curcol
condition|)
block|{
for|for
control|(
name|i
operator|=
name|stcol
operator|,
name|cols
operator|=
literal|0
operator|,
name|col
operator|=
name|RESCOL
init|;
operator|(
name|col
operator|+
name|fwidth
index|[
name|i
index|]
operator|)
operator|<
name|COLS
operator|-
literal|1
operator|&&
name|i
operator|<
name|maxcols
condition|;
name|i
operator|++
control|)
block|{
name|cols
operator|++
expr_stmt|;
if|if
condition|(
name|col_hidden
index|[
name|i
index|]
condition|)
continue|continue;
name|col
operator|+=
name|fwidth
index|[
name|i
index|]
expr_stmt|;
block|}
block|}
while|while
condition|(
name|stcol
operator|+
name|cols
operator|-
literal|1
operator|<
name|curcol
operator|||
name|curcol
operator|<
name|stcol
condition|)
block|{
name|FullUpdate
operator|++
expr_stmt|;
if|if
condition|(
name|stcol
operator|-
literal|1
operator|==
name|curcol
condition|)
block|{
comment|/* How about back one? */
name|stcol
operator|--
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|stcol
operator|+
name|cols
operator|==
name|curcol
condition|)
block|{
comment|/* Forward one? */
name|stcol
operator|++
expr_stmt|;
block|}
else|else
block|{
comment|/* Try to put the cursor in the center of the screen */
name|col
operator|=
operator|(
name|COLS
operator|-
name|RESCOL
operator|-
name|fwidth
index|[
name|curcol
index|]
operator|)
operator|/
literal|2
operator|+
name|RESCOL
expr_stmt|;
name|stcol
operator|=
name|curcol
expr_stmt|;
for|for
control|(
name|i
operator|=
name|curcol
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
operator|&&
name|col
operator|-
name|fwidth
index|[
name|i
index|]
operator|>
name|RESCOL
condition|;
name|i
operator|--
control|)
block|{
name|stcol
operator|--
expr_stmt|;
if|if
condition|(
name|col_hidden
index|[
name|i
index|]
condition|)
continue|continue;
name|col
operator|-=
name|fwidth
index|[
name|i
index|]
expr_stmt|;
block|}
block|}
comment|/* Now pick up the counts again */
for|for
control|(
name|i
operator|=
name|stcol
operator|,
name|cols
operator|=
literal|0
operator|,
name|col
operator|=
name|RESCOL
init|;
operator|(
name|col
operator|+
name|fwidth
index|[
name|i
index|]
operator|)
operator|<
name|COLS
operator|-
literal|1
operator|&&
name|i
operator|<
name|maxcols
condition|;
name|i
operator|++
control|)
block|{
name|cols
operator|++
expr_stmt|;
if|if
condition|(
name|col_hidden
index|[
name|i
index|]
condition|)
continue|continue;
name|col
operator|+=
name|fwidth
index|[
name|i
index|]
expr_stmt|;
block|}
block|}
comment|/* Now - same process on the rows */
if|if
condition|(
name|strow
operator|<=
name|currow
condition|)
block|{
for|for
control|(
name|i
operator|=
name|strow
operator|,
name|rows
operator|=
literal|0
operator|,
name|row
operator|=
name|RESROW
init|;
name|row
operator|<
name|LINES
operator|&&
name|i
operator|<
name|maxrows
condition|;
name|i
operator|++
control|)
block|{
name|rows
operator|++
expr_stmt|;
if|if
condition|(
name|row_hidden
index|[
name|i
index|]
condition|)
continue|continue;
name|row
operator|++
expr_stmt|;
block|}
block|}
while|while
condition|(
name|strow
operator|+
name|rows
operator|-
literal|1
operator|<
name|currow
operator|||
name|currow
operator|<
name|strow
condition|)
block|{
name|FullUpdate
operator|++
expr_stmt|;
if|if
condition|(
name|strow
operator|-
literal|1
operator|==
name|currow
condition|)
block|{
comment|/* How about up one? */
name|strow
operator|--
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strow
operator|+
name|rows
operator|==
name|currow
condition|)
block|{
comment|/* Down one? */
name|strow
operator|++
expr_stmt|;
block|}
else|else
block|{
comment|/* Try to put the cursor in the center of the screen */
name|row
operator|=
operator|(
name|LINES
operator|-
name|RESROW
operator|)
operator|/
literal|2
operator|+
name|RESROW
expr_stmt|;
name|strow
operator|=
name|currow
expr_stmt|;
for|for
control|(
name|i
operator|=
name|currow
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
operator|&&
name|row
operator|-
literal|1
operator|>
name|RESROW
condition|;
name|i
operator|--
control|)
block|{
name|strow
operator|--
expr_stmt|;
if|if
condition|(
name|row_hidden
index|[
name|i
index|]
condition|)
continue|continue;
name|row
operator|--
expr_stmt|;
block|}
block|}
comment|/* Now pick up the counts again */
for|for
control|(
name|i
operator|=
name|strow
operator|,
name|rows
operator|=
literal|0
operator|,
name|row
operator|=
name|RESROW
init|;
name|row
operator|<
name|LINES
operator|&&
name|i
operator|<
name|maxrows
condition|;
name|i
operator|++
control|)
block|{
name|rows
operator|++
expr_stmt|;
if|if
condition|(
name|row_hidden
index|[
name|i
index|]
condition|)
continue|continue;
name|row
operator|++
expr_stmt|;
block|}
block|}
name|mxcol
operator|=
name|stcol
operator|+
name|cols
operator|-
literal|1
expr_stmt|;
name|mxrow
operator|=
name|strow
operator|+
name|rows
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|FullUpdate
operator|||
name|standlast
condition|)
block|{
operator|(
name|void
operator|)
name|move
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|clrtobot
argument_list|()
expr_stmt|;
operator|(
name|void
operator|)
name|standout
argument_list|()
expr_stmt|;
for|for
control|(
name|row
operator|=
name|RESROW
operator|,
name|i
operator|=
name|strow
init|;
name|i
operator|<=
name|mxrow
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|row_hidden
index|[
name|i
index|]
condition|)
continue|continue;
operator|(
name|void
operator|)
name|move
argument_list|(
name|row
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|maxrows
operator|<
literal|1000
condition|)
operator|(
name|void
operator|)
name|printw
argument_list|(
literal|"%-*d"
argument_list|,
name|RESCOL
operator|-
literal|1
argument_list|,
name|i
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|printw
argument_list|(
literal|"%-*d"
argument_list|,
name|RESCOL
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|row
operator|++
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|move
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printw
argument_list|(
literal|"%*s"
argument_list|,
name|RESCOL
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
for|for
control|(
name|col
operator|=
name|RESCOL
operator|,
name|i
operator|=
name|stcol
init|;
name|i
operator|<=
name|mxcol
condition|;
name|i
operator|++
control|)
block|{
specifier|register
name|int
name|k
decl_stmt|;
if|if
condition|(
name|col_hidden
index|[
name|i
index|]
condition|)
continue|continue;
operator|(
name|void
operator|)
name|move
argument_list|(
literal|2
argument_list|,
name|col
argument_list|)
expr_stmt|;
name|k
operator|=
name|fwidth
index|[
name|i
index|]
operator|/
literal|2
expr_stmt|;
if|if
condition|(
name|k
operator|==
literal|0
condition|)
operator|(
name|void
operator|)
name|printw
argument_list|(
literal|"%1s"
argument_list|,
name|coltoa
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|printw
argument_list|(
literal|"%*s%-*s"
argument_list|,
name|k
argument_list|,
literal|" "
argument_list|,
name|fwidth
index|[
name|i
index|]
operator|-
name|k
argument_list|,
name|coltoa
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|col
operator|+=
name|fwidth
index|[
name|i
index|]
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|standend
argument_list|()
expr_stmt|;
block|}
comment|/* Get rid of cursor standout on the cell at previous cursor position */
if|if
condition|(
name|showcell
condition|)
block|{
operator|(
name|void
operator|)
name|move
argument_list|(
name|lastmx
argument_list|,
name|lastmy
argument_list|)
expr_stmt|;
name|repaint
argument_list|(
name|lastmx
argument_list|,
name|lastmy
argument_list|,
name|fwidth
index|[
name|lastcol
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|showrange
condition|)
block|{
name|minsr
operator|=
name|showsr
operator|<
name|currow
condition|?
name|showsr
else|:
name|currow
expr_stmt|;
name|minsc
operator|=
name|showsc
operator|<
name|curcol
condition|?
name|showsc
else|:
name|curcol
expr_stmt|;
name|maxsr
operator|=
name|showsr
operator|>
name|currow
condition|?
name|showsr
else|:
name|currow
expr_stmt|;
name|maxsc
operator|=
name|showsc
operator|>
name|curcol
condition|?
name|showsc
else|:
name|curcol
expr_stmt|;
if|if
condition|(
name|showtop
condition|)
block|{
operator|(
name|void
operator|)
name|move
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|clrtoeol
argument_list|()
expr_stmt|;
operator|(
name|void
operator|)
name|printw
argument_list|(
literal|"Default range:  %s"
argument_list|,
name|r_name
argument_list|(
name|minsr
argument_list|,
name|minsc
argument_list|,
name|maxsr
argument_list|,
name|maxsc
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Repaint the visible screen */
if|if
condition|(
name|showrange
operator|||
name|anychanged
operator|||
name|FullUpdate
operator|||
name|standlast
condition|)
block|{
comment|/* may be reset in loop, if not next time we will do a FullUpdate */
if|if
condition|(
name|standlast
condition|)
block|{
name|FullUpdate
operator|=
name|TRUE
expr_stmt|;
name|standlast
operator|=
name|FALSE
expr_stmt|;
block|}
for|for
control|(
name|row
operator|=
name|strow
operator|,
name|r
operator|=
name|RESROW
init|;
name|row
operator|<=
name|mxrow
condition|;
name|row
operator|++
control|)
block|{
specifier|register
name|c
operator|=
name|RESCOL
expr_stmt|;
name|int
name|do_stand
init|=
literal|0
decl_stmt|;
name|int
name|fieldlen
decl_stmt|;
name|int
name|nextcol
decl_stmt|;
if|if
condition|(
name|row_hidden
index|[
name|row
index|]
condition|)
continue|continue;
for|for
control|(
name|pp
operator|=
name|ATBL
argument_list|(
name|tbl
argument_list|,
name|row
argument_list|,
name|col
operator|=
name|stcol
argument_list|)
init|;
name|col
operator|<=
name|mxcol
condition|;
name|pp
operator|+=
name|nextcol
operator|-
name|col
operator|,
name|col
operator|=
name|nextcol
operator|,
name|c
operator|+=
name|fieldlen
control|)
block|{
name|nextcol
operator|=
name|col
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|col_hidden
index|[
name|col
index|]
condition|)
block|{
name|fieldlen
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
name|fieldlen
operator|=
name|fwidth
index|[
name|col
index|]
expr_stmt|;
comment|/* 	     * Set standout if: 	     * 	     * - showing ranges, and not showing cells which need to be filled 	     *	 in, and not showing cell expressions, and in a range, OR 	     * 	     * - if showing cells which need to be filled in and this one is 	     *	 of that type (has a value and doesn't have an expression, 	     *	 or it is a string expression), OR 	     * 	     * - if showing cells which have expressions and this one does. 	     */
if|if
condition|(
operator|(
name|showrange
operator|&&
operator|(
operator|!
name|showneed
operator|)
operator|&&
operator|(
operator|!
name|showexpr
operator|)
operator|&&
operator|(
name|row
operator|>=
name|minsr
operator|)
operator|&&
operator|(
name|row
operator|<=
name|maxsr
operator|)
operator|&&
operator|(
name|col
operator|>=
name|minsc
operator|)
operator|&&
operator|(
name|col
operator|<=
name|maxsc
operator|)
operator|)
operator|||
operator|(
name|showneed
operator|&&
operator|(
operator|*
name|pp
operator|)
operator|&&
operator|(
operator|(
operator|*
name|pp
operator|)
operator|->
name|flags
operator|&
name|is_valid
operator|)
operator|&&
operator|(
operator|(
operator|(
operator|*
name|pp
operator|)
operator|->
name|flags
operator|&
name|is_strexpr
operator|)
operator|||
operator|!
operator|(
operator|(
operator|*
name|pp
operator|)
operator|->
name|expr
operator|)
operator|)
operator|)
operator|||
operator|(
name|showexpr
operator|&&
operator|(
operator|*
name|pp
operator|)
operator|&&
operator|(
operator|(
operator|*
name|pp
operator|)
operator|->
name|expr
operator|)
operator|)
condition|)
block|{
operator|(
name|void
operator|)
name|move
argument_list|(
name|r
argument_list|,
name|c
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|standout
argument_list|()
expr_stmt|;
name|standlast
operator|++
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|pp
condition|)
comment|/* no cell, but standing out */
block|{
operator|(
name|void
operator|)
name|printw
argument_list|(
literal|"%*s"
argument_list|,
name|fwidth
index|[
name|col
index|]
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|standend
argument_list|()
expr_stmt|;
continue|continue;
block|}
else|else
name|do_stand
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|do_stand
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|pp
operator|)
operator|&&
operator|(
operator|(
operator|*
name|pp
operator|)
operator|->
name|flags
operator|&
name|is_changed
operator|||
name|FullUpdate
operator|)
operator|||
name|do_stand
condition|)
block|{
if|if
condition|(
name|do_stand
condition|)
block|{
operator|(
operator|*
name|pp
operator|)
operator|->
name|flags
operator||=
name|is_changed
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|move
argument_list|(
name|r
argument_list|,
name|c
argument_list|)
expr_stmt|;
operator|(
operator|*
name|pp
operator|)
operator|->
name|flags
operator|&=
operator|~
name|is_changed
expr_stmt|;
block|}
comment|/* 		 * Show expression; takes priority over other displays: 		 */
if|if
condition|(
name|showexpr
operator|&&
operator|(
operator|(
operator|*
name|pp
operator|)
operator|->
name|expr
operator|)
condition|)
block|{
name|linelim
operator|=
literal|0
expr_stmt|;
name|editexp
argument_list|(
name|row
argument_list|,
name|col
argument_list|)
expr_stmt|;
comment|/* set line to expr */
name|linelim
operator|=
operator|-
literal|1
expr_stmt|;
name|showstring
argument_list|(
name|line
argument_list|,
comment|/* leftflush = */
literal|1
argument_list|,
comment|/* hasvalue = */
literal|0
argument_list|,
name|row
argument_list|,
name|col
argument_list|,
operator|&
name|nextcol
argument_list|,
name|mxcol
argument_list|,
operator|&
name|fieldlen
argument_list|,
name|r
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		     * Show cell's numeric value: 		     */
if|if
condition|(
operator|(
operator|*
name|pp
operator|)
operator|->
name|flags
operator|&
name|is_valid
condition|)
block|{
name|char
name|field
index|[
name|FBUFLEN
index|]
decl_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|field
argument_list|,
literal|"%*.*f"
argument_list|,
name|fwidth
index|[
name|col
index|]
argument_list|,
name|precision
index|[
name|col
index|]
argument_list|,
operator|(
operator|*
name|pp
operator|)
operator|->
name|v
argument_list|)
expr_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|field
argument_list|)
operator|>
name|fwidth
index|[
name|col
index|]
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|fwidth
index|[
name|col
index|]
condition|;
name|i
operator|++
control|)
operator|(
name|void
operator|)
name|addch
argument_list|(
literal|'*'
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|addstr
argument_list|(
name|field
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 		     * Show cell's label string: 		     */
if|if
condition|(
operator|(
operator|*
name|pp
operator|)
operator|->
name|label
condition|)
block|{
name|showstring
argument_list|(
operator|(
operator|*
name|pp
operator|)
operator|->
name|label
argument_list|,
operator|(
operator|*
name|pp
operator|)
operator|->
name|flags
operator|&
name|is_leftflush
argument_list|,
operator|(
operator|*
name|pp
operator|)
operator|->
name|flags
operator|&
name|is_valid
argument_list|,
name|row
argument_list|,
name|col
argument_list|,
operator|&
name|nextcol
argument_list|,
name|mxcol
argument_list|,
operator|&
name|fieldlen
argument_list|,
name|r
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
elseif|else
comment|/* repaint a blank cell: */
if|if
condition|(
operator|(
name|do_stand
operator|||
operator|!
name|FullUpdate
operator|)
operator|&&
operator|(
operator|(
operator|*
name|pp
operator|)
operator|->
name|flags
operator|&
name|is_changed
operator|)
operator|&&
operator|!
operator|(
operator|(
operator|*
name|pp
operator|)
operator|->
name|flags
operator|&
name|is_valid
operator|)
operator|&&
operator|!
operator|(
operator|*
name|pp
operator|)
operator|->
name|label
condition|)
block|{
operator|(
name|void
operator|)
name|printw
argument_list|(
literal|"%*s"
argument_list|,
name|fwidth
index|[
name|col
index|]
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* else */
if|if
condition|(
name|do_stand
condition|)
block|{
operator|(
name|void
operator|)
name|standend
argument_list|()
expr_stmt|;
name|do_stand
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
name|r
operator|++
expr_stmt|;
block|}
block|}
operator|(
name|void
operator|)
name|move
argument_list|(
name|lastmy
argument_list|,
name|lastmx
operator|+
name|fwidth
index|[
name|lastcol
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|inch
argument_list|()
operator|&
name|A_CHARTEXT
operator|)
operator|==
literal|'<'
condition|)
operator|(
name|void
operator|)
name|addstr
argument_list|(
name|under_cursor
argument_list|)
expr_stmt|;
name|lastmy
operator|=
name|RESROW
expr_stmt|;
for|for
control|(
name|row
operator|=
name|strow
init|;
name|row
operator|<
name|currow
condition|;
name|row
operator|++
control|)
if|if
condition|(
operator|!
name|row_hidden
index|[
name|row
index|]
condition|)
name|lastmy
operator|+=
literal|1
expr_stmt|;
name|lastmx
operator|=
name|RESCOL
expr_stmt|;
for|for
control|(
name|col
operator|=
name|stcol
init|;
name|col
operator|<
name|curcol
condition|;
name|col
operator|++
control|)
if|if
condition|(
operator|!
name|col_hidden
index|[
name|col
index|]
condition|)
name|lastmx
operator|+=
name|fwidth
index|[
name|col
index|]
expr_stmt|;
name|lastcol
operator|=
name|curcol
expr_stmt|;
if|if
condition|(
name|showcell
operator|&&
operator|(
operator|!
name|showneed
operator|)
operator|&&
operator|(
operator|!
name|showexpr
operator|)
condition|)
block|{
operator|(
name|void
operator|)
name|move
argument_list|(
name|lastmy
argument_list|,
name|lastmx
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|standout
argument_list|()
expr_stmt|;
name|repaint
argument_list|(
name|lastmx
argument_list|,
name|lastmy
argument_list|,
name|fwidth
index|[
name|lastcol
index|]
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|standend
argument_list|()
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|move
argument_list|(
name|lastmy
argument_list|,
name|lastmx
operator|+
name|fwidth
index|[
name|lastcol
index|]
argument_list|)
expr_stmt|;
operator|*
name|under_cursor
operator|=
operator|(
name|inch
argument_list|()
operator|&
name|A_CHARTEXT
operator|)
expr_stmt|;
operator|(
name|void
operator|)
name|addstr
argument_list|(
literal|"<"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|move
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|clrtoeol
argument_list|()
expr_stmt|;
if|if
condition|(
name|linelim
operator|>=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|addch
argument_list|(
name|mode_ind
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|addstr
argument_list|(
literal|"> "
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|addstr
argument_list|(
name|line
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|move
argument_list|(
literal|0
argument_list|,
name|linelim
operator|+
literal|3
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|showtop
condition|)
block|{
comment|/* show top line */
specifier|register
name|struct
name|ent
modifier|*
name|p1
decl_stmt|;
name|int
name|printed
init|=
literal|0
decl_stmt|;
comment|/* printed something? */
operator|(
name|void
operator|)
name|printw
argument_list|(
literal|"%s%d "
argument_list|,
name|coltoa
argument_list|(
name|curcol
argument_list|)
argument_list|,
name|currow
argument_list|)
expr_stmt|;
if|if
condition|(
name|p1
operator|=
operator|*
name|ATBL
argument_list|(
name|tbl
argument_list|,
name|currow
argument_list|,
name|curcol
argument_list|)
condition|)
block|{
if|if
condition|(
name|p1
operator|->
name|expr
condition|)
block|{
comment|/* has expr of some type */
name|linelim
operator|=
literal|0
expr_stmt|;
name|editexp
argument_list|(
name|currow
argument_list|,
name|curcol
argument_list|)
expr_stmt|;
comment|/* set line to expr */
name|linelim
operator|=
operator|-
literal|1
expr_stmt|;
block|}
comment|/* 		 * Display string part of cell: 		 */
if|if
condition|(
operator|(
name|p1
operator|->
name|expr
operator|)
operator|&&
operator|(
name|p1
operator|->
name|flags
operator|&
name|is_strexpr
operator|)
condition|)
block|{
operator|(
name|void
operator|)
name|addstr
argument_list|(
operator|(
name|p1
operator|->
name|flags
operator|&
name|is_leftflush
operator|)
condition|?
literal|"<{"
else|:
literal|">{"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|addstr
argument_list|(
name|line
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|addstr
argument_list|(
literal|"} "
argument_list|)
expr_stmt|;
comment|/* and this '}' is for vi % */
name|printed
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|p1
operator|->
name|label
condition|)
block|{
comment|/* has constant label only */
operator|(
name|void
operator|)
name|addstr
argument_list|(
operator|(
name|p1
operator|->
name|flags
operator|&
name|is_leftflush
operator|)
condition|?
literal|"<\""
else|:
literal|">\""
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|addstr
argument_list|(
name|p1
operator|->
name|label
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|addstr
argument_list|(
literal|"\" "
argument_list|)
expr_stmt|;
name|printed
operator|=
literal|1
expr_stmt|;
block|}
comment|/* 		 * Display value part of cell: 		 */
if|if
condition|(
name|p1
operator|->
name|flags
operator|&
name|is_valid
condition|)
block|{
comment|/* has value or num expr */
if|if
condition|(
operator|(
operator|!
operator|(
name|p1
operator|->
name|expr
operator|)
operator|)
operator|||
operator|(
name|p1
operator|->
name|flags
operator|&
name|is_strexpr
operator|)
condition|)
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|line
argument_list|,
literal|"%.15g"
argument_list|,
name|p1
operator|->
name|v
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|addstr
argument_list|(
literal|"["
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|addstr
argument_list|(
name|line
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|addstr
argument_list|(
literal|"]"
argument_list|)
expr_stmt|;
name|printed
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|printed
condition|)
operator|(
name|void
operator|)
name|addstr
argument_list|(
literal|"[]"
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|move
argument_list|(
name|lastmy
argument_list|,
name|lastmx
operator|+
name|fwidth
index|[
name|lastcol
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|revmsg
index|[
literal|0
index|]
condition|)
block|{
operator|(
name|void
operator|)
name|move
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|clrtoeol
argument_list|()
expr_stmt|;
comment|/* get rid of topline display */
operator|(
name|void
operator|)
name|printw
argument_list|(
name|revmsg
argument_list|)
expr_stmt|;
name|revmsg
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* don't show it again */
operator|(
name|void
operator|)
name|move
argument_list|(
name|lastmy
argument_list|,
name|lastmx
operator|+
name|fwidth
index|[
name|lastcol
index|]
argument_list|)
expr_stmt|;
block|}
name|FullUpdate
operator|=
name|FALSE
expr_stmt|;
block|}
end_function

begin_function
name|void
name|repaint
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|,
name|len
parameter_list|)
name|int
name|x
decl_stmt|,
name|y
decl_stmt|,
name|len
decl_stmt|;
block|{
name|int
name|c
decl_stmt|;
while|while
condition|(
name|len
operator|--
operator|>
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|move
argument_list|(
name|y
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|c
operator|=
name|inch
argument_list|()
operator|&
name|A_CHARTEXT
expr_stmt|;
operator|(
name|void
operator|)
name|addch
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|x
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_decl_stmt
name|char
modifier|*
name|progname
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|int
name|inloop
init|=
literal|1
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
name|int
name|edistate
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|arg
init|=
literal|1
decl_stmt|;
name|int
name|narg
decl_stmt|;
name|int
name|nedistate
decl_stmt|;
name|int
name|running
decl_stmt|;
name|char
modifier|*
name|revi
decl_stmt|;
name|int
name|anychanged
init|=
name|FALSE
decl_stmt|;
comment|/*      * Keep command line options around until the file is read so the      * command line overrides file options      */
name|int
name|Mopt
init|=
literal|0
decl_stmt|;
name|int
name|Nopt
init|=
literal|0
decl_stmt|;
name|int
name|Copt
init|=
literal|0
decl_stmt|;
name|int
name|Ropt
init|=
literal|0
decl_stmt|;
name|int
name|tempx
decl_stmt|,
name|tempy
decl_stmt|;
comment|/* Temp versions of curx, cury */
if|if
condition|(
operator|(
name|revi
operator|=
name|strrchr
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|'/'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|progname
operator|=
name|revi
operator|+
literal|1
expr_stmt|;
else|else
name|progname
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
while|while
condition|(
name|argc
operator|>
literal|1
operator|&&
name|argv
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|==
literal|'-'
condition|)
block|{
name|argv
operator|++
expr_stmt|;
name|argc
operator|--
expr_stmt|;
switch|switch
condition|(
name|argv
index|[
literal|0
index|]
index|[
literal|1
index|]
condition|)
block|{
case|case
literal|'x'
case|:
ifdef|#
directive|ifdef
name|VMS
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Crypt not available for VMS\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
else|#
directive|else
name|Crypt
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
literal|'m'
case|:
name|Mopt
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
name|Nopt
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
name|Copt
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
name|Ropt
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: unrecognized option: \"%c\"\n"
argument_list|,
name|progname
argument_list|,
name|argv
index|[
literal|0
index|]
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
operator|*
name|curfile
operator|=
literal|'\0'
expr_stmt|;
name|signals
argument_list|()
expr_stmt|;
operator|(
name|void
operator|)
name|initscr
argument_list|()
expr_stmt|;
comment|/* setup the spreadsheet arrays, initscr() will get the screen size */
if|if
condition|(
operator|!
name|growtbl
argument_list|(
name|GROWNEW
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|endwin
argument_list|()
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|clear
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|VMS
name|VMS_read_raw
operator|=
literal|1
expr_stmt|;
else|#
directive|else
name|nonl
argument_list|()
expr_stmt|;
name|noecho
argument_list|()
expr_stmt|;
name|cbreak
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|initkbd
argument_list|()
expr_stmt|;
name|scrollok
argument_list|(
name|stdscr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/*      * Build revision message for later use:      */
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|revmsg
argument_list|,
name|progname
argument_list|)
expr_stmt|;
for|for
control|(
name|revi
operator|=
name|rev
init|;
operator|(
operator|*
name|revi
operator|++
operator|)
operator|!=
literal|':'
condition|;
control|)
empty_stmt|;
comment|/* copy after colon */
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|revmsg
argument_list|,
name|revi
argument_list|)
expr_stmt|;
name|revmsg
index|[
name|strlen
argument_list|(
name|revmsg
argument_list|)
operator|-
literal|2
index|]
operator|=
literal|0
expr_stmt|;
comment|/* erase last character */
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|revmsg
argument_list|,
literal|":  Type '?' for help."
argument_list|)
expr_stmt|;
if|if
condition|(
name|argc
operator|>
literal|1
condition|)
block|{
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|curfile
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|readfile
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|Mopt
condition|)
name|autocalc
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|Nopt
condition|)
name|numeric
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|Copt
condition|)
name|calc_order
operator|=
name|BYCOLS
expr_stmt|;
if|if
condition|(
name|Ropt
condition|)
name|calc_order
operator|=
name|BYROWS
expr_stmt|;
name|modflg
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|VENIX
name|setbuf
argument_list|(
name|stdin
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|FullUpdate
operator|++
expr_stmt|;
while|while
condition|(
name|inloop
condition|)
block|{
name|running
operator|=
literal|1
expr_stmt|;
while|while
condition|(
name|running
condition|)
block|{
name|nedistate
operator|=
operator|-
literal|1
expr_stmt|;
name|narg
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|edistate
operator|<
literal|0
operator|&&
name|linelim
operator|<
literal|0
operator|&&
name|autocalc
operator|&&
operator|(
name|changed
operator|||
name|FullUpdate
operator|)
condition|)
block|{
name|EvalAll
argument_list|()
expr_stmt|;
if|if
condition|(
name|changed
condition|)
comment|/* if EvalAll changed or was before */
name|anychanged
operator|=
name|TRUE
expr_stmt|;
name|changed
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
comment|/* any cells change? */
if|if
condition|(
name|changed
condition|)
name|anychanged
operator|=
name|TRUE
expr_stmt|;
name|update
argument_list|(
name|anychanged
argument_list|)
expr_stmt|;
name|anychanged
operator|=
name|FALSE
expr_stmt|;
ifndef|#
directive|ifndef
name|SYSV3
operator|(
name|void
operator|)
name|refresh
argument_list|()
expr_stmt|;
comment|/* 5.3 does a refresh in getch */
endif|#
directive|endif
name|c
operator|=
name|nmgetch
argument_list|()
expr_stmt|;
name|getyx
argument_list|(
name|stdscr
argument_list|,
name|tempy
argument_list|,
name|tempx
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|move
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|clrtoeol
argument_list|()
expr_stmt|;
operator|(
name|void
operator|)
name|move
argument_list|(
name|tempy
argument_list|,
name|tempx
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|seenerr
operator|=
literal|0
expr_stmt|;
name|showneed
operator|=
literal|0
expr_stmt|;
comment|/* reset after each update */
name|showexpr
operator|=
literal|0
expr_stmt|;
comment|/* if ((c< ' ') || ( c == DEL ))   how about international here ? PB */
if|if
condition|(
name|iscntrl
argument_list|(
name|c
argument_list|)
condition|)
switch|switch
condition|(
name|c
condition|)
block|{
ifdef|#
directive|ifdef
name|SIGTSTP
case|case
name|ctl
argument_list|(
literal|'z'
argument_list|)
case|:
operator|(
name|void
operator|)
name|deraw
argument_list|()
expr_stmt|;
operator|(
name|void
operator|)
name|kill
argument_list|(
literal|0
argument_list|,
name|SIGTSTP
argument_list|)
expr_stmt|;
comment|/* Nail process group */
comment|/* the pc stops here */
operator|(
name|void
operator|)
name|goraw
argument_list|()
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
name|ctl
argument_list|(
literal|'r'
argument_list|)
case|:
name|showneed
operator|=
literal|1
expr_stmt|;
case|case
name|ctl
argument_list|(
literal|'l'
argument_list|)
case|:
name|FullUpdate
operator|++
expr_stmt|;
operator|(
name|void
operator|)
name|clearok
argument_list|(
name|stdscr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|ctl
argument_list|(
literal|'x'
argument_list|)
case|:
name|FullUpdate
operator|++
expr_stmt|;
name|showexpr
operator|=
literal|1
expr_stmt|;
operator|(
name|void
operator|)
name|clearok
argument_list|(
name|stdscr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
argument_list|(
literal|"No such command (^%c)"
argument_list|,
name|c
operator|+
literal|0100
argument_list|)
expr_stmt|;
break|break;
case|case
name|ctl
argument_list|(
literal|'b'
argument_list|)
case|:
name|backcol
argument_list|(
name|arg
argument_list|)
expr_stmt|;
break|break;
case|case
name|ctl
argument_list|(
literal|'c'
argument_list|)
case|:
name|running
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|ctl
argument_list|(
literal|'e'
argument_list|)
case|:
switch|switch
condition|(
name|nmgetch
argument_list|()
condition|)
block|{
case|case
name|ctl
argument_list|(
literal|'p'
argument_list|)
case|:
case|case
literal|'k'
case|:
name|doend
argument_list|(
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|ctl
argument_list|(
literal|'n'
argument_list|)
case|:
case|case
literal|'j'
case|:
name|doend
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|ctl
argument_list|(
literal|'b'
argument_list|)
case|:
case|case
literal|'h'
case|:
case|case
name|ctl
argument_list|(
literal|'h'
argument_list|)
case|:
name|doend
argument_list|(
literal|0
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|ctl
argument_list|(
literal|'f'
argument_list|)
case|:
case|case
literal|'l'
case|:
case|case
name|ctl
argument_list|(
literal|'i'
argument_list|)
case|:
case|case
literal|' '
case|:
name|doend
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|ESC
case|:
case|case
name|ctl
argument_list|(
literal|'g'
argument_list|)
case|:
break|break;
default|default:
name|error
argument_list|(
literal|"Invalid ^E command"
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|ctl
argument_list|(
literal|'f'
argument_list|)
case|:
name|forwcol
argument_list|(
name|arg
argument_list|)
expr_stmt|;
break|break;
case|case
name|ctl
argument_list|(
literal|'g'
argument_list|)
case|:
name|showrange
operator|=
literal|0
expr_stmt|;
name|linelim
operator|=
operator|-
literal|1
expr_stmt|;
operator|(
name|void
operator|)
name|move
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|clrtoeol
argument_list|()
expr_stmt|;
break|break;
case|case
name|ESC
case|:
comment|/* ctl('[') */
name|write_line
argument_list|(
name|ESC
argument_list|)
expr_stmt|;
break|break;
case|case
name|ctl
argument_list|(
literal|'d'
argument_list|)
case|:
name|write_line
argument_list|(
name|ctl
argument_list|(
literal|'d'
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|DEL
case|:
case|case
name|ctl
argument_list|(
literal|'h'
argument_list|)
case|:
if|if
condition|(
name|linelim
operator|<
literal|0
condition|)
block|{
comment|/* not editing line */
name|backcol
argument_list|(
name|arg
argument_list|)
expr_stmt|;
comment|/* treat like ^B    */
break|break;
block|}
name|write_line
argument_list|(
name|ctl
argument_list|(
literal|'h'
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|ctl
argument_list|(
literal|'i'
argument_list|)
case|:
comment|/* tab */
if|if
condition|(
name|linelim
operator|<
literal|0
condition|)
block|{
comment|/* not editing line */
name|forwcol
argument_list|(
name|arg
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|showrange
condition|)
block|{
name|startshow
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|showdr
argument_list|()
expr_stmt|;
name|linelim
operator|=
name|strlen
argument_list|(
name|line
argument_list|)
expr_stmt|;
name|line
index|[
name|linelim
operator|++
index|]
operator|=
literal|' '
expr_stmt|;
name|line
index|[
name|linelim
index|]
operator|=
literal|0
expr_stmt|;
name|showrange
operator|=
literal|0
expr_stmt|;
block|}
name|linelim
operator|=
name|strlen
argument_list|(
name|line
argument_list|)
expr_stmt|;
break|break;
case|case
name|ctl
argument_list|(
literal|'m'
argument_list|)
case|:
case|case
name|ctl
argument_list|(
literal|'j'
argument_list|)
case|:
name|write_line
argument_list|(
name|ctl
argument_list|(
literal|'m'
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|ctl
argument_list|(
literal|'n'
argument_list|)
case|:
name|forwrow
argument_list|(
name|arg
argument_list|)
expr_stmt|;
break|break;
case|case
name|ctl
argument_list|(
literal|'p'
argument_list|)
case|:
name|backrow
argument_list|(
name|arg
argument_list|)
expr_stmt|;
break|break;
case|case
name|ctl
argument_list|(
literal|'q'
argument_list|)
case|:
break|break;
comment|/* ignore flow control */
case|case
name|ctl
argument_list|(
literal|'s'
argument_list|)
case|:
break|break;
comment|/* ignore flow control */
case|case
name|ctl
argument_list|(
literal|'t'
argument_list|)
case|:
name|error
argument_list|(
literal|"Toggle:  a:auto  c:cell  e:ext funcs  n:numeric  t:top  x:encrypt  $:pre-scale"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|refresh
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|nmgetch
argument_list|()
condition|)
block|{
case|case
literal|'a'
case|:
case|case
literal|'A'
case|:
case|case
literal|'m'
case|:
case|case
literal|'M'
case|:
name|autocalc
operator|^=
literal|1
expr_stmt|;
name|error
argument_list|(
literal|"Automatic recalculation %sabled."
argument_list|,
name|autocalc
condition|?
literal|"en"
else|:
literal|"dis"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
case|case
literal|'N'
case|:
name|numeric
operator|=
operator|(
operator|!
name|numeric
operator|)
expr_stmt|;
name|error
argument_list|(
literal|"Numeric input %sabled."
argument_list|,
name|numeric
condition|?
literal|"en"
else|:
literal|"dis"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
case|case
literal|'T'
case|:
name|showtop
operator|=
operator|(
operator|!
name|showtop
operator|)
expr_stmt|;
name|repaint
argument_list|(
name|lastmx
argument_list|,
name|lastmy
argument_list|,
name|fwidth
index|[
name|lastcol
index|]
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"Top line %sabled."
argument_list|,
name|showtop
condition|?
literal|"en"
else|:
literal|"dis"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
case|case
literal|'C'
case|:
name|showcell
operator|=
operator|(
operator|!
name|showcell
operator|)
expr_stmt|;
name|repaint
argument_list|(
name|lastmx
argument_list|,
name|lastmy
argument_list|,
name|fwidth
index|[
name|lastcol
index|]
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"Cell highlighting %sabled."
argument_list|,
name|showcell
condition|?
literal|"en"
else|:
literal|"dis"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
case|case
literal|'X'
case|:
name|Crypt
operator|=
operator|(
operator|!
name|Crypt
operator|)
expr_stmt|;
name|error
argument_list|(
literal|"Encryption %sabled."
argument_list|,
name|Crypt
condition|?
literal|"en"
else|:
literal|"dis"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'$'
case|:
if|if
condition|(
name|prescale
operator|==
literal|1.0
condition|)
block|{
name|error
argument_list|(
literal|"Prescale enabled."
argument_list|)
expr_stmt|;
name|prescale
operator|=
literal|0.01
expr_stmt|;
block|}
else|else
block|{
name|prescale
operator|=
literal|1.0
expr_stmt|;
name|error
argument_list|(
literal|"Prescale disabled."
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'e'
case|:
case|case
literal|'E'
case|:
name|extfunc
operator|=
operator|(
operator|!
name|extfunc
operator|)
expr_stmt|;
name|error
argument_list|(
literal|"External functions %sabled."
argument_list|,
name|extfunc
condition|?
literal|"en"
else|:
literal|"dis"
argument_list|)
expr_stmt|;
break|break;
case|case
name|ESC
case|:
case|case
name|ctl
argument_list|(
literal|'g'
argument_list|)
case|:
operator|--
name|modflg
expr_stmt|;
comment|/* negate the modflg++ */
break|break;
default|default:
name|error
argument_list|(
literal|"Invalid toggle command"
argument_list|)
expr_stmt|;
operator|--
name|modflg
expr_stmt|;
comment|/* negate the modflg++ */
block|}
name|FullUpdate
operator|++
expr_stmt|;
name|modflg
operator|++
expr_stmt|;
break|break;
case|case
name|ctl
argument_list|(
literal|'u'
argument_list|)
case|:
name|narg
operator|=
name|arg
operator|*
literal|4
expr_stmt|;
name|nedistate
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|ctl
argument_list|(
literal|'v'
argument_list|)
case|:
comment|/* insert variable name */
if|if
condition|(
name|linelim
operator|>
literal|0
condition|)
name|ins_string
argument_list|(
name|v_name
argument_list|(
name|currow
argument_list|,
name|curcol
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|ctl
argument_list|(
literal|'w'
argument_list|)
case|:
comment|/* insert variable expression */
if|if
condition|(
name|linelim
operator|>
literal|0
condition|)
block|{
name|char
modifier|*
name|temp
decl_stmt|,
modifier|*
name|temp1
decl_stmt|;
name|int
name|templim
decl_stmt|;
name|temp
operator|=
name|strcpy
argument_list|(
name|xmalloc
argument_list|(
call|(
name|unsigned
call|)
argument_list|(
name|strlen
argument_list|(
name|line
argument_list|)
operator|+
literal|1
argument_list|)
argument_list|)
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|templim
operator|=
name|linelim
expr_stmt|;
name|editexp
argument_list|(
name|currow
argument_list|,
name|curcol
argument_list|)
expr_stmt|;
name|temp1
operator|=
name|strcpy
argument_list|(
name|xmalloc
argument_list|(
call|(
name|unsigned
call|)
argument_list|(
name|strlen
argument_list|(
name|line
argument_list|)
operator|+
literal|1
argument_list|)
argument_list|)
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|line
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|linelim
operator|=
name|templim
expr_stmt|;
name|ins_string
argument_list|(
name|temp1
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
name|temp1
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|ctl
argument_list|(
literal|'a'
argument_list|)
case|:
comment|/* insert variable value */
if|if
condition|(
name|linelim
operator|>
literal|0
condition|)
block|{
name|struct
name|ent
modifier|*
name|p
init|=
operator|*
name|ATBL
argument_list|(
name|tbl
argument_list|,
name|currow
argument_list|,
name|curcol
argument_list|)
decl_stmt|;
name|char
name|temp
index|[
literal|100
index|]
decl_stmt|;
if|if
condition|(
name|p
operator|&&
name|p
operator|->
name|flags
operator|&
name|is_valid
condition|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|temp
argument_list|,
literal|"%.*f"
argument_list|,
name|precision
index|[
name|curcol
index|]
argument_list|,
name|p
operator|->
name|v
argument_list|)
expr_stmt|;
name|ins_string
argument_list|(
name|temp
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
block|}
comment|/* End of the control char switch stmt */
elseif|else
if|if
condition|(
name|isdigit
argument_list|(
name|c
argument_list|)
operator|&&
operator|(
operator|(
name|numeric
operator|&&
name|edistate
operator|>=
literal|0
operator|)
operator|||
operator|(
operator|!
name|numeric
operator|&&
operator|(
name|linelim
operator|<
literal|0
operator|||
name|edistate
operator|>=
literal|0
operator|)
operator|)
operator|)
condition|)
block|{
comment|/* we got a leading number */
if|if
condition|(
name|edistate
operator|!=
literal|0
condition|)
block|{
comment|/* First char of the count */
if|if
condition|(
name|c
operator|==
literal|'0'
condition|)
comment|/* just a '0' goes to left col */
name|curcol
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|nedistate
operator|=
literal|0
expr_stmt|;
name|narg
operator|=
name|c
operator|-
literal|'0'
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Succeeding count chars */
name|nedistate
operator|=
literal|0
expr_stmt|;
name|narg
operator|=
name|arg
operator|*
literal|10
operator|+
operator|(
name|c
operator|-
literal|'0'
operator|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|linelim
operator|>=
literal|0
condition|)
block|{
comment|/* Editing line */
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|')'
case|:
if|if
condition|(
name|showrange
condition|)
block|{
name|showdr
argument_list|()
expr_stmt|;
name|showrange
operator|=
literal|0
expr_stmt|;
name|linelim
operator|=
name|strlen
argument_list|(
name|line
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
break|break;
block|}
name|write_line
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|numeric
operator|&&
operator|(
name|c
operator|==
literal|'+'
operator|||
name|c
operator|==
literal|'-'
operator|)
condition|)
block|{
comment|/* increment/decrement ops */
specifier|register
name|struct
name|ent
modifier|*
name|p
init|=
operator|*
name|ATBL
argument_list|(
name|tbl
argument_list|,
name|currow
argument_list|,
name|curcol
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|p
condition|)
continue|continue;
if|if
condition|(
name|p
operator|->
name|expr
operator|&&
operator|!
operator|(
name|p
operator|->
name|flags
operator|&
name|is_strexpr
operator|)
condition|)
block|{
name|error
argument_list|(
literal|"Can't increment/decrement a formula\n"
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|FullUpdate
operator|++
expr_stmt|;
name|modflg
operator|++
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'+'
condition|)
name|p
operator|->
name|v
operator|+=
operator|(
name|double
operator|)
name|arg
expr_stmt|;
else|else
name|p
operator|->
name|v
operator|-=
operator|(
name|double
operator|)
name|arg
expr_stmt|;
block|}
else|else
comment|/* switch on a normal command character */
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|':'
case|:
break|break;
comment|/* Be nice to vi users */
case|case
literal|'@'
case|:
name|EvalAll
argument_list|()
expr_stmt|;
name|changed
operator|=
literal|0
expr_stmt|;
name|anychanged
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
case|case
literal|'-'
case|:
case|case
literal|'.'
case|:
case|case
literal|'+'
case|:
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|line
argument_list|,
literal|"let %s = %c"
argument_list|,
name|v_name
argument_list|(
name|currow
argument_list|,
name|curcol
argument_list|)
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|linelim
operator|=
name|strlen
argument_list|(
name|line
argument_list|)
expr_stmt|;
name|insert_mode
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'='
case|:
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|line
argument_list|,
literal|"let %s = "
argument_list|,
name|v_name
argument_list|(
name|currow
argument_list|,
name|curcol
argument_list|)
argument_list|)
expr_stmt|;
name|linelim
operator|=
name|strlen
argument_list|(
name|line
argument_list|)
expr_stmt|;
name|insert_mode
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'!'
case|:
block|{
comment|/* 		     *  "! command"  executes command 		     *  "!"	forks a shell 		     *  "!!" repeats last command 		     */
ifdef|#
directive|ifdef
name|VMS
name|error
argument_list|(
literal|"Not implemented on VMS"
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* VMS */
name|char
modifier|*
name|shl
decl_stmt|;
name|int
name|pid
decl_stmt|,
name|temp
decl_stmt|;
name|char
name|cmd
index|[
name|MAXCMD
index|]
decl_stmt|;
specifier|static
name|char
name|lastcmd
index|[
name|MAXCMD
index|]
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|shl
operator|=
name|getenv
argument_list|(
literal|"SHELL"
argument_list|)
operator|)
condition|)
name|shl
operator|=
literal|"/bin/sh"
expr_stmt|;
name|deraw
argument_list|()
expr_stmt|;
operator|(
name|void
operator|)
name|fputs
argument_list|(
literal|"! "
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fgets
argument_list|(
name|cmd
argument_list|,
name|MAXCMD
argument_list|,
name|stdin
argument_list|)
expr_stmt|;
name|cmd
index|[
name|strlen
argument_list|(
name|cmd
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* clobber \n */
if|if
condition|(
name|strcmp
argument_list|(
name|cmd
argument_list|,
literal|"!"
argument_list|)
operator|==
literal|0
condition|)
comment|/* repeat? */
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|cmd
argument_list|,
name|lastcmd
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|lastcmd
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
if|if
condition|(
name|modflg
condition|)
block|{
operator|(
name|void
operator|)
name|puts
argument_list|(
literal|"[No write since last change]"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|pid
operator|=
name|fork
argument_list|()
operator|)
condition|)
block|{
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
comment|/* reset */
if|if
condition|(
name|strlen
argument_list|(
name|cmd
argument_list|)
condition|)
operator|(
name|void
operator|)
name|execl
argument_list|(
name|shl
argument_list|,
name|shl
argument_list|,
literal|"-c"
argument_list|,
name|cmd
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|execl
argument_list|(
name|shl
argument_list|,
name|shl
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|127
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|pid
operator|!=
name|wait
argument_list|(
operator|&
name|temp
argument_list|)
condition|)
empty_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"Press RETURN to continue "
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|nmgetch
argument_list|()
expr_stmt|;
name|goraw
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* VMS */
break|break;
block|}
comment|/* 		 * Range commands: 		 */
case|case
literal|'/'
case|:
name|error
argument_list|(
literal|"Range:  x:erase  v:value  c:copy  f:fill  d:define  s:show  u:undefine"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|refresh
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|nmgetch
argument_list|()
condition|)
block|{
case|case
literal|'c'
case|:
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|line
argument_list|,
literal|"copy [dest_range src_range] "
argument_list|)
expr_stmt|;
name|linelim
operator|=
name|strlen
argument_list|(
name|line
argument_list|)
expr_stmt|;
name|startshow
argument_list|()
expr_stmt|;
name|insert_mode
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|line
argument_list|,
literal|"erase [range] "
argument_list|)
expr_stmt|;
name|linelim
operator|=
name|strlen
argument_list|(
name|line
argument_list|)
expr_stmt|;
name|startshow
argument_list|()
expr_stmt|;
name|insert_mode
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|line
argument_list|,
literal|"value [range] "
argument_list|)
expr_stmt|;
name|linelim
operator|=
name|strlen
argument_list|(
name|line
argument_list|)
expr_stmt|;
name|startshow
argument_list|()
expr_stmt|;
name|insert_mode
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|line
argument_list|,
literal|"fill [range start inc] "
argument_list|)
expr_stmt|;
name|linelim
operator|=
name|strlen
argument_list|(
name|line
argument_list|)
expr_stmt|;
name|startshow
argument_list|()
expr_stmt|;
name|insert_mode
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|line
argument_list|,
literal|"define [string range] \""
argument_list|)
expr_stmt|;
name|linelim
operator|=
name|strlen
argument_list|(
name|line
argument_list|)
expr_stmt|;
name|startshow
argument_list|()
expr_stmt|;
name|insert_mode
argument_list|()
expr_stmt|;
name|modflg
operator|++
expr_stmt|;
break|break;
case|case
literal|'u'
case|:
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|line
argument_list|,
literal|"undefine [range] "
argument_list|)
expr_stmt|;
name|linelim
operator|=
name|strlen
argument_list|(
name|line
argument_list|)
expr_stmt|;
name|insert_mode
argument_list|()
expr_stmt|;
name|modflg
operator|++
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
if|if
condition|(
name|are_ranges
argument_list|()
condition|)
block|{
name|FILE
modifier|*
name|f
decl_stmt|;
name|int
name|pid
decl_stmt|;
name|char
name|px
index|[
name|MAXCMD
index|]
decl_stmt|;
name|char
modifier|*
name|pager
decl_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|px
argument_list|,
literal|"| sort | "
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|pager
operator|=
name|getenv
argument_list|(
literal|"PAGER"
argument_list|)
operator|)
condition|)
name|pager
operator|=
name|DFLT_PAGER
expr_stmt|;
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|px
argument_list|,
name|pager
argument_list|)
expr_stmt|;
name|f
operator|=
name|openout
argument_list|(
name|px
argument_list|,
operator|&
name|pid
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|f
condition|)
block|{
name|error
argument_list|(
literal|"Can't open pipe to sort"
argument_list|)
expr_stmt|;
break|break;
block|}
name|list_range
argument_list|(
name|f
argument_list|)
expr_stmt|;
name|closeout
argument_list|(
name|f
argument_list|,
name|pid
argument_list|)
expr_stmt|;
block|}
else|else
name|error
argument_list|(
literal|"No ranges defined"
argument_list|)
expr_stmt|;
break|break;
case|case
name|ESC
case|:
case|case
name|ctl
argument_list|(
literal|'g'
argument_list|)
case|:
break|break;
default|default:
name|error
argument_list|(
literal|"Invalid region command"
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
comment|/* 		 * Row/column commands: 		 */
case|case
literal|'i'
case|:
case|case
literal|'a'
case|:
case|case
literal|'d'
case|:
case|case
literal|'p'
case|:
case|case
literal|'v'
case|:
case|case
literal|'z'
case|:
case|case
literal|'s'
case|:
block|{
specifier|register
name|rcqual
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|rcqual
operator|=
name|get_rcqual
argument_list|(
name|c
argument_list|)
operator|)
condition|)
block|{
name|error
argument_list|(
literal|"Invalid row/column command"
argument_list|)
expr_stmt|;
break|break;
block|}
name|error
argument_list|(
literal|""
argument_list|)
expr_stmt|;
comment|/* clear line */
if|if
condition|(
name|rcqual
operator|==
name|ESC
operator|||
name|rcqual
operator|==
name|ctl
argument_list|(
literal|'g'
argument_list|)
condition|)
break|break;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'i'
case|:
if|if
condition|(
name|rcqual
operator|==
literal|'r'
condition|)
name|insertrow
argument_list|(
name|arg
argument_list|)
expr_stmt|;
else|else
name|opencol
argument_list|(
name|curcol
argument_list|,
name|arg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'a'
case|:
if|if
condition|(
name|rcqual
operator|==
literal|'r'
condition|)
while|while
condition|(
name|arg
operator|--
condition|)
name|duprow
argument_list|()
expr_stmt|;
else|else
while|while
condition|(
name|arg
operator|--
condition|)
name|dupcol
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
if|if
condition|(
name|rcqual
operator|==
literal|'r'
condition|)
name|deleterow
argument_list|(
name|arg
argument_list|)
expr_stmt|;
else|else
name|closecol
argument_list|(
name|curcol
argument_list|,
name|arg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
while|while
condition|(
name|arg
operator|--
condition|)
name|pullcells
argument_list|(
name|rcqual
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
if|if
condition|(
name|rcqual
operator|==
literal|'r'
condition|)
name|rowvalueize
argument_list|(
name|arg
argument_list|)
expr_stmt|;
else|else
name|colvalueize
argument_list|(
name|arg
argument_list|)
expr_stmt|;
name|modflg
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'z'
case|:
if|if
condition|(
name|rcqual
operator|==
literal|'r'
condition|)
name|hiderow
argument_list|(
name|arg
argument_list|)
expr_stmt|;
else|else
name|hidecol
argument_list|(
name|arg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
comment|/* special case; no repeat count */
if|if
condition|(
name|rcqual
operator|==
literal|'r'
condition|)
name|rowshow_op
argument_list|()
expr_stmt|;
else|else
name|colshow_op
argument_list|()
expr_stmt|;
break|break;
block|}
break|break;
block|}
case|case
literal|'$'
case|:
block|{
specifier|register
name|struct
name|ent
modifier|*
name|p
decl_stmt|;
name|curcol
operator|=
name|maxcols
operator|-
literal|1
expr_stmt|;
while|while
condition|(
operator|!
name|VALID_CELL
argument_list|(
name|p
argument_list|,
name|currow
argument_list|,
name|curcol
argument_list|)
operator|&&
name|curcol
operator|>
literal|0
condition|)
name|curcol
operator|--
expr_stmt|;
break|break;
block|}
case|case
literal|'#'
case|:
block|{
specifier|register
name|struct
name|ent
modifier|*
name|p
decl_stmt|;
name|currow
operator|=
name|maxrows
operator|-
literal|1
expr_stmt|;
while|while
condition|(
operator|!
name|VALID_CELL
argument_list|(
name|p
argument_list|,
name|currow
argument_list|,
name|curcol
argument_list|)
operator|&&
name|currow
operator|>
literal|0
condition|)
name|currow
operator|--
expr_stmt|;
break|break;
block|}
case|case
literal|'w'
case|:
block|{
specifier|register
name|struct
name|ent
modifier|*
name|p
decl_stmt|;
while|while
condition|(
operator|--
name|arg
operator|>=
literal|0
condition|)
block|{
do|do
block|{
if|if
condition|(
name|curcol
operator|<
name|maxcols
operator|-
literal|1
condition|)
name|curcol
operator|++
expr_stmt|;
else|else
block|{
if|if
condition|(
name|currow
operator|<
name|maxrows
operator|-
literal|1
condition|)
block|{
while|while
condition|(
operator|++
name|currow
operator|<
name|maxrows
operator|-
literal|1
operator|&&
name|row_hidden
index|[
name|currow
index|]
condition|)
comment|/* */
empty_stmt|;
name|curcol
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|error
argument_list|(
literal|"At end of table"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
do|while
condition|(
name|col_hidden
index|[
name|curcol
index|]
operator|||
operator|!
name|VALID_CELL
argument_list|(
name|p
argument_list|,
name|currow
argument_list|,
name|curcol
argument_list|)
condition|)
do|;
block|}
break|break;
block|}
case|case
literal|'b'
case|:
block|{
specifier|register
name|struct
name|ent
modifier|*
name|p
decl_stmt|;
while|while
condition|(
operator|--
name|arg
operator|>=
literal|0
condition|)
block|{
do|do
block|{
if|if
condition|(
name|curcol
condition|)
name|curcol
operator|--
expr_stmt|;
else|else
block|{
if|if
condition|(
name|currow
condition|)
block|{
while|while
condition|(
operator|--
name|currow
operator|&&
name|row_hidden
index|[
name|currow
index|]
condition|)
comment|/* */
empty_stmt|;
name|curcol
operator|=
name|maxcols
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|error
argument_list|(
literal|"At start of table"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
do|while
condition|(
name|col_hidden
index|[
name|curcol
index|]
operator|||
operator|!
name|VALID_CELL
argument_list|(
name|p
argument_list|,
name|currow
argument_list|,
name|curcol
argument_list|)
condition|)
do|;
block|}
break|break;
block|}
case|case
literal|'^'
case|:
name|currow
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'?'
case|:
name|help
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'"'
case|:
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|line
argument_list|,
literal|"label %s = \""
argument_list|,
name|v_name
argument_list|(
name|currow
argument_list|,
name|curcol
argument_list|)
argument_list|)
expr_stmt|;
name|linelim
operator|=
name|strlen
argument_list|(
name|line
argument_list|)
expr_stmt|;
name|insert_mode
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'<'
case|:
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|line
argument_list|,
literal|"leftstring %s = \""
argument_list|,
name|v_name
argument_list|(
name|currow
argument_list|,
name|curcol
argument_list|)
argument_list|)
expr_stmt|;
name|linelim
operator|=
name|strlen
argument_list|(
name|line
argument_list|)
expr_stmt|;
name|insert_mode
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'>'
case|:
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|line
argument_list|,
literal|"rightstring %s = \""
argument_list|,
name|v_name
argument_list|(
name|currow
argument_list|,
name|curcol
argument_list|)
argument_list|)
expr_stmt|;
name|linelim
operator|=
name|strlen
argument_list|(
name|line
argument_list|)
expr_stmt|;
name|insert_mode
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
name|editv
argument_list|(
name|currow
argument_list|,
name|curcol
argument_list|)
expr_stmt|;
name|edit_mode
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'E'
case|:
name|edits
argument_list|(
name|currow
argument_list|,
name|curcol
argument_list|)
expr_stmt|;
name|edit_mode
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
if|if
condition|(
name|arg
operator|==
literal|1
condition|)
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|line
argument_list|,
literal|"format [for column] %s "
argument_list|,
name|coltoa
argument_list|(
name|curcol
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|line
argument_list|,
literal|"format [for columns] %s:"
argument_list|,
name|coltoa
argument_list|(
name|curcol
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|line
operator|+
name|strlen
argument_list|(
name|line
argument_list|)
argument_list|,
literal|"%s "
argument_list|,
name|coltoa
argument_list|(
name|curcol
operator|+
name|arg
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|error
argument_list|(
literal|"Current format is %d %d"
argument_list|,
name|fwidth
index|[
name|curcol
index|]
argument_list|,
name|precision
index|[
name|curcol
index|]
argument_list|)
expr_stmt|;
name|linelim
operator|=
name|strlen
argument_list|(
name|line
argument_list|)
expr_stmt|;
name|insert_mode
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'g'
case|:
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|line
argument_list|,
literal|"goto [v] "
argument_list|)
expr_stmt|;
name|linelim
operator|=
name|strlen
argument_list|(
name|line
argument_list|)
expr_stmt|;
name|insert_mode
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'P'
case|:
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|line
argument_list|,
literal|"put [\"dest\" range] \""
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|curfile
condition|)
name|error
argument_list|(
literal|"Default path is \"%s\""
argument_list|,
name|curfile
argument_list|)
expr_stmt|;
name|linelim
operator|=
name|strlen
argument_list|(
name|line
argument_list|)
expr_stmt|;
name|insert_mode
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'M'
case|:
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|line
argument_list|,
literal|"merge [\"source\"] \""
argument_list|)
expr_stmt|;
name|linelim
operator|=
name|strlen
argument_list|(
name|line
argument_list|)
expr_stmt|;
name|insert_mode
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'R'
case|:
if|if
condition|(
name|mdir
condition|)
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|line
argument_list|,
literal|"merge [\"macro_file\"] \"%s/"
argument_list|,
name|mdir
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|line
argument_list|,
literal|"merge [\"macro_file\"] \""
argument_list|)
expr_stmt|;
name|linelim
operator|=
name|strlen
argument_list|(
name|line
argument_list|)
expr_stmt|;
name|insert_mode
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'D'
case|:
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|line
argument_list|,
literal|"mdir [\"macro_directory\"] \""
argument_list|)
expr_stmt|;
name|linelim
operator|=
name|strlen
argument_list|(
name|line
argument_list|)
expr_stmt|;
name|insert_mode
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'G'
case|:
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|line
argument_list|,
literal|"get [\"source\"] \""
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|curfile
condition|)
name|error
argument_list|(
literal|"Default file is \"%s\""
argument_list|,
name|curfile
argument_list|)
expr_stmt|;
name|linelim
operator|=
name|strlen
argument_list|(
name|line
argument_list|)
expr_stmt|;
name|insert_mode
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'W'
case|:
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|line
argument_list|,
literal|"write [\"dest\" range] \""
argument_list|)
expr_stmt|;
name|linelim
operator|=
name|strlen
argument_list|(
name|line
argument_list|)
expr_stmt|;
name|insert_mode
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'S'
case|:
comment|/* set options */
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|line
argument_list|,
literal|"set "
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"Options: byrows, bycols, iterations=n, tblstyle=(0|tbl|latex|tex)"
argument_list|)
expr_stmt|;
name|linelim
operator|=
name|strlen
argument_list|(
name|line
argument_list|)
expr_stmt|;
name|insert_mode
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'T'
case|:
comment|/* tbl output */
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|line
argument_list|,
literal|"tbl [\"dest\" range] \""
argument_list|)
expr_stmt|;
name|linelim
operator|=
name|strlen
argument_list|(
name|line
argument_list|)
expr_stmt|;
name|insert_mode
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
block|{
specifier|register
name|struct
name|ent
modifier|*
modifier|*
name|pp
decl_stmt|;
specifier|register
name|int
name|c1
decl_stmt|;
name|flush_saved
argument_list|()
expr_stmt|;
if|if
condition|(
name|calc_order
operator|==
name|BYROWS
condition|)
block|{
for|for
control|(
name|c1
operator|=
name|curcol
init|;
name|arg
operator|--
operator|&&
name|c1
operator|<
name|maxcols
condition|;
name|c1
operator|++
control|)
block|{
name|pp
operator|=
name|ATBL
argument_list|(
name|tbl
argument_list|,
name|currow
argument_list|,
name|c1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|pp
condition|)
block|{
name|free_ent
argument_list|(
operator|*
name|pp
argument_list|)
expr_stmt|;
operator|*
name|pp
operator|=
operator|(
expr|struct
name|ent
operator|*
operator|)
literal|0
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
for|for
control|(
name|c1
operator|=
name|currow
init|;
name|arg
operator|--
operator|&&
name|c1
operator|<
name|maxrows
condition|;
name|c1
operator|++
control|)
block|{
name|pp
operator|=
name|ATBL
argument_list|(
name|tbl
argument_list|,
name|c1
argument_list|,
name|curcol
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|pp
condition|)
block|{
name|free_ent
argument_list|(
operator|*
name|pp
argument_list|)
expr_stmt|;
operator|*
name|pp
operator|=
operator|(
expr|struct
name|ent
operator|*
operator|)
literal|0
expr_stmt|;
block|}
block|}
block|}
name|sync_refs
argument_list|()
expr_stmt|;
name|modflg
operator|++
expr_stmt|;
name|FullUpdate
operator|++
expr_stmt|;
block|}
break|break;
case|case
literal|'Q'
case|:
case|case
literal|'q'
case|:
name|running
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'h'
case|:
name|backcol
argument_list|(
name|arg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'j'
case|:
name|forwrow
argument_list|(
name|arg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'k'
case|:
name|backrow
argument_list|(
name|arg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|' '
case|:
case|case
literal|'l'
case|:
name|forwcol
argument_list|(
name|arg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'m'
case|:
name|savedrow
operator|=
name|currow
expr_stmt|;
name|savedcol
operator|=
name|curcol
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
block|{
specifier|register
name|struct
name|ent
modifier|*
name|p
init|=
operator|*
name|ATBL
argument_list|(
name|tbl
argument_list|,
name|savedrow
argument_list|,
name|savedcol
argument_list|)
decl_stmt|;
specifier|register
name|c1
expr_stmt|;
specifier|register
name|struct
name|ent
modifier|*
name|n
decl_stmt|;
if|if
condition|(
operator|!
name|p
condition|)
break|break;
name|FullUpdate
operator|++
expr_stmt|;
name|modflg
operator|++
expr_stmt|;
for|for
control|(
name|c1
operator|=
name|curcol
init|;
name|arg
operator|--
operator|&&
name|c1
operator|<
name|maxcols
condition|;
name|c1
operator|++
control|)
block|{
name|n
operator|=
name|lookat
argument_list|(
name|currow
argument_list|,
name|c1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|clearent
argument_list|(
name|n
argument_list|)
expr_stmt|;
name|copyent
argument_list|(
name|n
argument_list|,
name|p
argument_list|,
name|currow
operator|-
name|savedrow
argument_list|,
name|c1
operator|-
name|savedcol
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
default|default:
if|if
condition|(
operator|(
name|toascii
argument_list|(
name|c
argument_list|)
operator|)
operator|!=
name|c
condition|)
name|error
argument_list|(
literal|"Weird character, decimal %d\n"
argument_list|,
operator|(
name|int
operator|)
name|c
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"No such command (%c)"
argument_list|,
name|c
argument_list|)
expr_stmt|;
break|break;
block|}
name|edistate
operator|=
name|nedistate
expr_stmt|;
name|arg
operator|=
name|narg
expr_stmt|;
block|}
comment|/* while (running) */
name|inloop
operator|=
name|modcheck
argument_list|(
literal|" before exiting"
argument_list|)
expr_stmt|;
block|}
comment|/*  while (inloop) */
name|deraw
argument_list|()
expr_stmt|;
name|endwin
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|VMS
comment|/* Unit VMS "fixes" exit we should say 1 here */
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
else|#
directive|else
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*NOTREACHED*/
block|}
end_function

begin_function
name|void
name|startshow
parameter_list|()
block|{
name|showrange
operator|=
literal|1
expr_stmt|;
name|showsr
operator|=
name|currow
expr_stmt|;
name|showsc
operator|=
name|curcol
expr_stmt|;
block|}
end_function

begin_function
name|void
name|showdr
parameter_list|()
block|{
name|int
name|minsr
decl_stmt|,
name|minsc
decl_stmt|,
name|maxsr
decl_stmt|,
name|maxsc
decl_stmt|;
name|minsr
operator|=
name|showsr
operator|<
name|currow
condition|?
name|showsr
else|:
name|currow
expr_stmt|;
name|minsc
operator|=
name|showsc
operator|<
name|curcol
condition|?
name|showsc
else|:
name|curcol
expr_stmt|;
name|maxsr
operator|=
name|showsr
operator|>
name|currow
condition|?
name|showsr
else|:
name|currow
expr_stmt|;
name|maxsc
operator|=
name|showsc
operator|>
name|curcol
condition|?
name|showsc
else|:
name|curcol
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|line
operator|+
name|linelim
argument_list|,
literal|"%s"
argument_list|,
name|r_name
argument_list|(
name|minsr
argument_list|,
name|minsc
argument_list|,
name|maxsr
argument_list|,
name|maxsc
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|setorder
parameter_list|(
name|i
parameter_list|)
name|int
name|i
decl_stmt|;
block|{
if|if
condition|(
operator|(
name|i
operator|==
name|BYROWS
operator|)
operator|||
operator|(
name|i
operator|==
name|BYCOLS
operator|)
condition|)
name|calc_order
operator|=
name|i
expr_stmt|;
else|else
name|error
argument_list|(
literal|"Not yet implemented"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|setauto
parameter_list|(
name|i
parameter_list|)
name|int
name|i
decl_stmt|;
block|{
name|autocalc
operator|=
name|i
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|VMS
end_ifdef

begin_macro
name|goraw
argument_list|()
end_macro

begin_block
block|{
name|VMS_read_raw
operator|=
literal|1
expr_stmt|;
name|FullUpdate
operator|++
expr_stmt|;
block|}
end_block

begin_macro
name|deraw
argument_list|()
end_macro

begin_block
block|{
operator|(
name|void
operator|)
name|move
argument_list|(
name|LINES
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|clrtoeol
argument_list|()
expr_stmt|;
operator|(
name|void
operator|)
name|refresh
argument_list|()
expr_stmt|;
name|VMS_read_raw
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* VMS */
end_comment

begin_function
name|void
name|goraw
parameter_list|()
block|{
if|#
directive|if
name|SYSV2
operator|||
name|SYSV3
name|fixterm
argument_list|()
expr_stmt|;
else|#
directive|else
comment|/* SYSV2 || SYSV3 */
name|cbreak
argument_list|()
expr_stmt|;
name|nonl
argument_list|()
expr_stmt|;
name|noecho
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* SYSV2 || SYSV3 */
name|kbd_again
argument_list|()
expr_stmt|;
operator|(
name|void
operator|)
name|clear
argument_list|()
expr_stmt|;
name|FullUpdate
operator|++
expr_stmt|;
block|}
end_function

begin_function
name|void
name|deraw
parameter_list|()
block|{
operator|(
name|void
operator|)
name|move
argument_list|(
name|LINES
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|clrtoeol
argument_list|()
expr_stmt|;
operator|(
name|void
operator|)
name|refresh
argument_list|()
expr_stmt|;
if|#
directive|if
name|SYSV2
operator|||
name|SYSV3
name|resetterm
argument_list|()
expr_stmt|;
else|#
directive|else
name|nocbreak
argument_list|()
expr_stmt|;
name|nl
argument_list|()
expr_stmt|;
name|echo
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|resetkbd
argument_list|()
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* VMS */
end_comment

begin_function
name|void
name|signals
parameter_list|()
block|{
ifdef|#
directive|ifdef
name|SIGVOID
name|void
name|quit
parameter_list|()
function_decl|;
name|void
name|time_out
parameter_list|()
function_decl|;
name|void
name|dump_me
parameter_list|()
function_decl|;
else|#
directive|else
name|int
name|quit
parameter_list|()
function_decl|;
name|int
name|time_out
parameter_list|()
function_decl|;
name|int
name|dump_me
parameter_list|()
function_decl|;
endif|#
directive|endif
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|dump_me
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGPIPE
argument_list|,
name|quit
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGTERM
argument_list|,
name|quit
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGALRM
argument_list|,
name|time_out
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGFPE
argument_list|,
name|quit
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGBUS
argument_list|,
name|quit
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|SIGVOID
end_ifdef

begin_function
name|void
endif|#
directive|endif
name|quit
parameter_list|()
block|{
name|diesave
argument_list|()
expr_stmt|;
name|deraw
argument_list|()
expr_stmt|;
name|resetkbd
argument_list|()
expr_stmt|;
name|endwin
argument_list|()
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|SIGVOID
end_ifdef

begin_function
name|void
endif|#
directive|endif
name|dump_me
parameter_list|()
block|{
name|diesave
argument_list|()
expr_stmt|;
name|deraw
argument_list|()
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* try to save the current spreadsheet if we can */
end_comment

begin_macro
name|diesave
argument_list|()
end_macro

begin_block
block|{
name|char
name|path
index|[
name|PATHLEN
index|]
decl_stmt|;
if|if
condition|(
name|modcheck
argument_list|(
literal|" before Spreadsheet dies"
argument_list|)
operator|==
literal|1
condition|)
block|{
name|sprintf
argument_list|(
name|path
argument_list|,
literal|"~/SC.SAVE"
argument_list|)
expr_stmt|;
if|if
condition|(
name|writefile
argument_list|(
name|path
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|maxrow
argument_list|,
name|maxcol
argument_list|)
operator|<
literal|0
condition|)
if|if
condition|(
name|writefile
argument_list|(
literal|"/tmp/SC.SAVE"
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|maxrow
argument_list|,
name|maxcol
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|"Couldn't save current spreadsheet, Sorry"
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_function
name|int
name|modcheck
parameter_list|(
name|endstr
parameter_list|)
name|char
modifier|*
name|endstr
decl_stmt|;
block|{
if|if
condition|(
name|modflg
operator|&&
name|curfile
index|[
literal|0
index|]
condition|)
block|{
name|int
name|yn_ans
decl_stmt|;
name|char
name|lin
index|[
literal|100
index|]
decl_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|lin
argument_list|,
literal|"File \"%s\" is modified, save%s? "
argument_list|,
name|curfile
argument_list|,
name|endstr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|yn_ans
operator|=
name|yn_ask
argument_list|(
name|lin
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
elseif|else
if|if
condition|(
name|yn_ans
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|writefile
argument_list|(
name|curfile
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|maxrow
argument_list|,
name|maxcol
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|modflg
condition|)
block|{
name|int
name|yn_ans
decl_stmt|;
if|if
condition|(
operator|(
name|yn_ans
operator|=
name|yn_ask
argument_list|(
literal|"Do you want a chance to save the data? "
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
else|else
return|return
operator|(
name|yn_ans
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

end_unit

