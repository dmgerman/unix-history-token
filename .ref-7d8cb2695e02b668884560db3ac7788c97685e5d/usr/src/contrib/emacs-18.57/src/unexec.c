begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Copyright (C) 1985, 1986, 1987, 1988 Free Software Foundation, Inc.      This program is free software; you can redistribute it and/or modify     it under the terms of the GNU General Public License as published by     the Free Software Foundation; either version 1, or (at your option)     any later version.      This program is distributed in the hope that it will be useful,     but WITHOUT ANY WARRANTY; without even the implied warranty of     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the     GNU General Public License for more details.      You should have received a copy of the GNU General Public License     along with this program; if not, write to the Free Software     Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  In other words, you are welcome to use, share and improve this program. You are forbidden to forbid anyone else to use, share and improve what you give them.   Help stamp out software-hoarding!  */
end_comment

begin_comment
comment|/*  * unexec.c - Convert a running program into an a.out file.  *  * Author:	Spencer W. Thomas  * 		Computer Science Dept.  * 		University of Utah  * Date:	Tue Mar  2 1982  * Modified heavily since then.  *  * Synopsis:  *	unexec (new_name, a_name, data_start, bss_start, entry_address)  *	char *new_name, *a_name;  *	unsigned data_start, bss_start, entry_address;  *  * Takes a snapshot of the program and makes an a.out format file in the  * file named by the string argument new_name.  * If a_name is non-NULL, the symbol table will be taken from the given file.  * On some machines, an existing a_name file is required.  *  * The boundaries within the a.out file may be adjusted with the data_start  * and bss_start arguments.  Either or both may be given as 0 for defaults.  *  * Data_start gives the boundary between the text segment and the data  * segment of the program.  The text segment can contain shared, read-only  * program code and literal data, while the data segment is always unshared  * and unprotected.  Data_start gives the lowest unprotected address.  * The value you specify may be rounded down to a suitable boundary  * as required by the machine you are using.  *  * Specifying zero for data_start means the boundary between text and data  * should not be the same as when the program was loaded.  * If NO_REMAP is defined, the argument data_start is ignored and the  * segment boundaries are never changed.  *  * Bss_start indicates how much of the data segment is to be saved in the  * a.out file and restored when the program is executed.  It gives the lowest  * unsaved address, and is rounded up to a page boundary.  The default when 0  * is given assumes that the entire data segment is to be stored, including  * the previous data and bss as well as any additional storage allocated with  * break (2).  *  * The new file is set up to start at entry_address.  *  * If you make improvements I'd like to get them too.  * harpo!utah-cs!thomas, thomas@Utah-20  *  */
end_comment

begin_comment
comment|/* Modified to support SysVr3 shared libraries by James Van Artsdalen  * of Dell Computer Corporation.  james@bigtex.cactus.org.  */
end_comment

begin_comment
comment|/* There are several compilation parameters affecting unexec:  * COFF  Define this if your system uses COFF for executables. Otherwise we assume you use Berkeley format.  * NO_REMAP  Define this if you do not want to try to save Emacs's pure data areas as part of the text segment.  Saving them as text is good because it allows users to share more.  However, on machines that locate the text area far from the data area, the boundary cannot feasibly be moved.  Such machines require NO_REMAP.  Also, remapping can cause trouble with the built-in startup routine /lib/crt0.o, which defines `environ' as an initialized variable. Dumping `environ' as pure does not work!  So, to use remapping, you must write a startup routine for your machine in Emacs's crt0.c. If NO_REMAP is defined, Emacs uses the system's crt0.o.  * SECTION_ALIGNMENT  Some machines that use COFF executables require that each section start on a certain boundary *in the COFF file*.  Such machines should define SECTION_ALIGNMENT to a mask of the low-order bits that must be zero on such a boundary.  This mask is used to control padding between segments in the COFF file.  If SECTION_ALIGNMENT is not defined, the segments are written consecutively with no attempt at alignment.  This is right for unmodified system V.  * SEGMENT_MASK  Some machines require that the beginnings and ends of segments *in core* be on certain boundaries.  For most machines, a page boundary is sufficient.  That is the default.  When a larger boundary is needed, define SEGMENT_MASK to a mask of the bits that must be zero on such a boundary.  * A_TEXT_OFFSET(HDR)  Some machines count the a.out header as part of the size of the text segment (a_text); they may actually load the header into core as the first data in the text segment.  Some have additional padding between the header and the real text of the program that is counted in a_text.  For these machines, define A_TEXT_OFFSET(HDR) to examine the header structure HDR and return the number of bytes to add to `a_text' before writing it (above and beyond the number of bytes of actual program text).  HDR's standard fields are already correct, except that this adjustment to the `a_text' field has not yet been made; thus, the amount of offset can depend on the data in the file.    * A_TEXT_SEEK(HDR)  If defined, this macro specifies the number of bytes to seek into the a.out file before starting to write the text segment.a  * EXEC_MAGIC  For machines using COFF, this macro, if defined, is a value stored into the magic number field of the output file.  * ADJUST_EXEC_HEADER  This macro can be used to generate statements to adjust or initialize nonstandard fields in the file header  * ADDR_CORRECT(ADDR)  Macro to correct an int which is the bit pattern of a pointer to a byte into an int which is the number of a byte.  This macro has a default definition which is usually right. This default definition is a no-op on most machines (where a pointer looks like an int) but not on all machines.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|emacs
end_ifndef

begin_define
define|#
directive|define
name|PERROR
parameter_list|(
name|arg
parameter_list|)
value|perror (arg); return -1
end_define

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_define
define|#
directive|define
name|PERROR
parameter_list|(
name|file
parameter_list|)
value|report_error (file, new)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|CANNOT_DUMP
end_ifndef

begin_comment
comment|/* all rest of file!  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|CANNOT_UNEXEC
end_ifndef

begin_comment
comment|/* most of rest of file */
end_comment

begin_include
include|#
directive|include
file|<a.out.h>
end_include

begin_comment
comment|/* Define getpagesize () if the system does not.    Note that this may depend on symbols defined in a.out.h  */
end_comment

begin_include
include|#
directive|include
file|"getpagesize.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|makedev
end_ifndef

begin_comment
comment|/* Try to detect types.h already loaded */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_function_decl
specifier|extern
name|char
modifier|*
name|start_of_text
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* Start of text */
end_comment

begin_function_decl
specifier|extern
name|char
modifier|*
name|start_of_data
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* Start of initialized data */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|COFF
end_ifdef

begin_ifndef
ifndef|#
directive|ifndef
name|USG
end_ifndef

begin_ifndef
ifndef|#
directive|ifndef
name|STRIDE
end_ifndef

begin_ifndef
ifndef|#
directive|ifndef
name|UMAX
end_ifndef

begin_ifndef
ifndef|#
directive|ifndef
name|sun386
end_ifndef

begin_comment
comment|/* I have a suspicion that these are turned off on all systems    and can be deleted.  Try it in version 19.  */
end_comment

begin_include
include|#
directive|include
file|<filehdr.h>
end_include

begin_include
include|#
directive|include
file|<aouthdr.h>
end_include

begin_include
include|#
directive|include
file|<scnhdr.h>
end_include

begin_include
include|#
directive|include
file|<syms.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not sun386 */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not UMAX */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Not STRIDE */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not USG */
end_comment

begin_decl_stmt
specifier|static
name|long
name|block_copy_start
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Old executable start point */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|filehdr
name|f_hdr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* File header */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|aouthdr
name|f_ohdr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Optional file header (a.out) */
end_comment

begin_decl_stmt
name|long
name|bias
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Bias to add for growth */
end_comment

begin_decl_stmt
name|long
name|lnnoptr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Pointer to line-number info within file */
end_comment

begin_define
define|#
directive|define
name|SYMS_START
value|block_copy_start
end_define

begin_decl_stmt
specifier|static
name|long
name|text_scnptr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|long
name|data_scnptr
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* not COFF */
end_comment

begin_function_decl
specifier|extern
name|char
modifier|*
name|sbrk
parameter_list|()
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|SYMS_START
value|((long) N_SYMOFF (ohdr))
end_define

begin_comment
comment|/* Some machines override the structure name for an a.out header.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|EXEC_HDR_TYPE
end_ifndef

begin_define
define|#
directive|define
name|EXEC_HDR_TYPE
value|struct exec
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HPUX
end_ifdef

begin_ifdef
ifdef|#
directive|ifdef
name|HP9000S200_ID
end_ifdef

begin_define
define|#
directive|define
name|MY_ID
value|HP9000S200_ID
end_define

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<model.h>
end_include

begin_define
define|#
directive|define
name|MY_ID
value|MYSYS
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* no HP9000S200_ID */
end_comment

begin_decl_stmt
specifier|static
name|MAGIC
name|OLDMAGIC
init|=
block|{
name|MY_ID
block|,
name|SHARE_MAGIC
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|MAGIC
name|NEWMAGIC
init|=
block|{
name|MY_ID
block|,
name|DEMAND_MAGIC
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|N_TXTOFF
parameter_list|(
name|x
parameter_list|)
value|TEXT_OFFSET(x)
end_define

begin_define
define|#
directive|define
name|N_SYMOFF
parameter_list|(
name|x
parameter_list|)
value|LESYM_OFFSET(x)
end_define

begin_decl_stmt
specifier|static
name|EXEC_HDR_TYPE
name|hdr
decl_stmt|,
name|ohdr
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* not HPUX */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|USG
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|IBMRTAIX
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|IRIS
argument_list|)
end_if

begin_decl_stmt
specifier|static
name|struct
name|bhdr
name|hdr
decl_stmt|,
name|ohdr
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|a_magic
value|fmagic
end_define

begin_define
define|#
directive|define
name|a_text
value|tsize
end_define

begin_define
define|#
directive|define
name|a_data
value|dsize
end_define

begin_define
define|#
directive|define
name|a_bss
value|bsize
end_define

begin_define
define|#
directive|define
name|a_syms
value|ssize
end_define

begin_define
define|#
directive|define
name|a_trsize
value|rtsize
end_define

begin_define
define|#
directive|define
name|a_drsize
value|rdsize
end_define

begin_define
define|#
directive|define
name|a_entry
value|entry
end_define

begin_define
define|#
directive|define
name|N_BADMAG
parameter_list|(
name|x
parameter_list|)
define|\
value|(((x).fmagic)!=OMAGIC&& ((x).fmagic)!=NMAGIC&&\      ((x).fmagic)!=FMAGIC&& ((x).fmagic)!=IMAGIC)
end_define

begin_define
define|#
directive|define
name|NEWMAGIC
value|FMAGIC
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* IRIS or IBMRTAIX or not USG */
end_comment

begin_decl_stmt
specifier|static
name|EXEC_HDR_TYPE
name|hdr
decl_stmt|,
name|ohdr
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|NEWMAGIC
value|ZMAGIC
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* IRIS or IBMRTAIX not USG */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not HPUX */
end_comment

begin_decl_stmt
specifier|static
name|int
name|unexec_text_start
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|unexec_data_start
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not COFF */
end_comment

begin_decl_stmt
specifier|static
name|int
name|pagemask
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Correct an int which is the bit pattern of a pointer to a byte    into an int which is the number of a byte.    This is a no-op on ordinary machines, but not on all.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|ADDR_CORRECT
end_ifndef

begin_comment
comment|/* Let m-*.h files override this definition */
end_comment

begin_define
define|#
directive|define
name|ADDR_CORRECT
parameter_list|(
name|x
parameter_list|)
value|((char *)(x) - (char*)0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|emacs
end_ifdef

begin_expr_stmt
specifier|static
name|report_error
argument_list|(
argument|file
argument_list|,
argument|fd
argument_list|)
name|char
operator|*
name|file
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|fd
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|fd
condition|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"Failure operating on %s"
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* emacs */
end_comment

begin_define
define|#
directive|define
name|ERROR0
parameter_list|(
name|msg
parameter_list|)
value|report_error_1 (new, msg, 0, 0); return -1
end_define

begin_define
define|#
directive|define
name|ERROR1
parameter_list|(
name|msg
parameter_list|,
name|x
parameter_list|)
value|report_error_1 (new, msg, x, 0); return -1
end_define

begin_define
define|#
directive|define
name|ERROR2
parameter_list|(
name|msg
parameter_list|,
name|x
parameter_list|,
name|y
parameter_list|)
value|report_error_1 (new, msg, x, y); return -1
end_define

begin_expr_stmt
specifier|static
name|report_error_1
argument_list|(
argument|fd
argument_list|,
argument|msg
argument_list|,
argument|a1
argument_list|,
argument|a2
argument_list|)
name|int
name|fd
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|char
modifier|*
name|msg
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|a1
decl_stmt|,
name|a2
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|emacs
name|error
argument_list|(
name|msg
argument_list|,
name|a1
argument_list|,
name|a2
argument_list|)
expr_stmt|;
else|#
directive|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|msg
argument_list|,
name|a1
argument_list|,
name|a2
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* ****************************************************************  * unexec  *  * driving logic.  */
end_comment

begin_macro
name|unexec
argument_list|(
argument|new_name
argument_list|,
argument|a_name
argument_list|,
argument|data_start
argument_list|,
argument|bss_start
argument_list|,
argument|entry_address
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|new_name
decl_stmt|,
modifier|*
name|a_name
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|data_start
decl_stmt|,
name|bss_start
decl_stmt|,
name|entry_address
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|new
decl_stmt|,
name|a_out
init|=
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|a_name
operator|&&
operator|(
name|a_out
operator|=
name|open
argument_list|(
name|a_name
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|PERROR
argument_list|(
name|a_name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|new
operator|=
name|creat
argument_list|(
name|new_name
argument_list|,
literal|0666
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|PERROR
argument_list|(
name|new_name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|make_hdr
argument_list|(
name|new
argument_list|,
name|a_out
argument_list|,
name|data_start
argument_list|,
name|bss_start
argument_list|,
name|entry_address
argument_list|,
name|a_name
argument_list|,
name|new_name
argument_list|)
operator|<
literal|0
operator|||
name|copy_text_and_data
argument_list|(
name|new
argument_list|,
name|a_out
argument_list|)
operator|<
literal|0
operator|||
name|copy_sym
argument_list|(
name|new
argument_list|,
name|a_out
argument_list|,
name|a_name
argument_list|,
name|new_name
argument_list|)
operator|<
literal|0
ifdef|#
directive|ifdef
name|COFF
operator|||
name|adjust_lnnoptrs
argument_list|(
name|new
argument_list|,
name|a_out
argument_list|,
name|new_name
argument_list|)
operator|<
literal|0
endif|#
directive|endif
condition|)
block|{
name|close
argument_list|(
name|new
argument_list|)
expr_stmt|;
comment|/* unlink (new_name);	    	/* Failed, unlink new a.out */
return|return
operator|-
literal|1
return|;
block|}
name|close
argument_list|(
name|new
argument_list|)
expr_stmt|;
if|if
condition|(
name|a_out
operator|>=
literal|0
condition|)
name|close
argument_list|(
name|a_out
argument_list|)
expr_stmt|;
name|mark_x
argument_list|(
name|new_name
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_block

begin_comment
comment|/* ****************************************************************  * make_hdr  *  * Make the header in the new a.out from the header in core.  * Modify the text and data sizes.  */
end_comment

begin_function
specifier|static
name|int
name|make_hdr
parameter_list|(
name|new
parameter_list|,
name|a_out
parameter_list|,
name|data_start
parameter_list|,
name|bss_start
parameter_list|,
name|entry_address
parameter_list|,
name|a_name
parameter_list|,
name|new_name
parameter_list|)
name|int
name|new
decl_stmt|,
name|a_out
decl_stmt|;
name|unsigned
name|data_start
decl_stmt|,
name|bss_start
decl_stmt|,
name|entry_address
decl_stmt|;
name|char
modifier|*
name|a_name
decl_stmt|;
name|char
modifier|*
name|new_name
decl_stmt|;
block|{
name|int
name|tem
decl_stmt|;
ifdef|#
directive|ifdef
name|COFF
specifier|auto
type|struct
name|scnhdr
name|f_thdr
decl_stmt|;
comment|/* Text section header */
specifier|auto
type|struct
name|scnhdr
name|f_dhdr
decl_stmt|;
comment|/* Data section header */
specifier|auto
type|struct
name|scnhdr
name|f_bhdr
decl_stmt|;
comment|/* Bss section header */
specifier|auto
type|struct
name|scnhdr
name|scntemp
decl_stmt|;
comment|/* Temporary section header */
specifier|register
name|int
name|scns
decl_stmt|;
endif|#
directive|endif
comment|/* COFF */
ifdef|#
directive|ifdef
name|USG_SHARED_LIBRARIES
specifier|extern
name|unsigned
name|int
name|bss_end
decl_stmt|;
else|#
directive|else
name|unsigned
name|int
name|bss_end
decl_stmt|;
endif|#
directive|endif
name|pagemask
operator|=
name|getpagesize
argument_list|()
operator|-
literal|1
expr_stmt|;
comment|/* Adjust text/data boundary. */
ifdef|#
directive|ifdef
name|NO_REMAP
name|data_start
operator|=
operator|(
name|int
operator|)
name|start_of_data
argument_list|()
expr_stmt|;
else|#
directive|else
comment|/* not NO_REMAP */
if|if
condition|(
operator|!
name|data_start
condition|)
name|data_start
operator|=
operator|(
name|int
operator|)
name|start_of_data
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* not NO_REMAP */
name|data_start
operator|=
name|ADDR_CORRECT
argument_list|(
name|data_start
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SEGMENT_MASK
name|data_start
operator|=
name|data_start
operator|&
operator|~
name|SEGMENT_MASK
expr_stmt|;
comment|/* (Down) to segment boundary. */
else|#
directive|else
name|data_start
operator|=
name|data_start
operator|&
operator|~
name|pagemask
expr_stmt|;
comment|/* (Down) to page boundary. */
endif|#
directive|endif
name|bss_end
operator|=
name|ADDR_CORRECT
argument_list|(
name|sbrk
argument_list|(
literal|0
argument_list|)
argument_list|)
operator|+
name|pagemask
expr_stmt|;
name|bss_end
operator|&=
operator|~
name|pagemask
expr_stmt|;
comment|/* Adjust data/bss boundary. */
if|if
condition|(
name|bss_start
operator|!=
literal|0
condition|)
block|{
name|bss_start
operator|=
operator|(
name|ADDR_CORRECT
argument_list|(
name|bss_start
argument_list|)
operator|+
name|pagemask
operator|)
expr_stmt|;
comment|/* (Up) to page bdry. */
name|bss_start
operator|&=
operator|~
name|pagemask
expr_stmt|;
if|if
condition|(
name|bss_start
operator|>
name|bss_end
condition|)
block|{
name|ERROR1
argument_list|(
literal|"unexec: Specified bss_start (%u) is past end of program"
argument_list|,
name|bss_start
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|bss_start
operator|=
name|bss_end
expr_stmt|;
if|if
condition|(
name|data_start
operator|>
name|bss_start
condition|)
comment|/* Can't have negative data size. */
block|{
name|ERROR2
argument_list|(
literal|"unexec: data_start (%u) can't be greater than bss_start (%u)"
argument_list|,
name|data_start
argument_list|,
name|bss_start
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|COFF
comment|/* Salvage as much info from the existing file as possible */
if|if
condition|(
name|a_out
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|read
argument_list|(
name|a_out
argument_list|,
operator|&
name|f_hdr
argument_list|,
sizeof|sizeof
argument_list|(
name|f_hdr
argument_list|)
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|f_hdr
argument_list|)
condition|)
block|{
name|PERROR
argument_list|(
name|a_name
argument_list|)
expr_stmt|;
block|}
name|block_copy_start
operator|+=
sizeof|sizeof
argument_list|(
name|f_hdr
argument_list|)
expr_stmt|;
if|if
condition|(
name|f_hdr
operator|.
name|f_opthdr
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|read
argument_list|(
name|a_out
argument_list|,
operator|&
name|f_ohdr
argument_list|,
sizeof|sizeof
argument_list|(
name|f_ohdr
argument_list|)
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|f_ohdr
argument_list|)
condition|)
block|{
name|PERROR
argument_list|(
name|a_name
argument_list|)
expr_stmt|;
block|}
name|block_copy_start
operator|+=
sizeof|sizeof
argument_list|(
name|f_ohdr
argument_list|)
expr_stmt|;
block|}
comment|/* Loop through section headers, copying them in */
for|for
control|(
name|scns
operator|=
name|f_hdr
operator|.
name|f_nscns
init|;
name|scns
operator|>
literal|0
condition|;
name|scns
operator|--
control|)
block|{
if|if
condition|(
name|read
argument_list|(
name|a_out
argument_list|,
operator|&
name|scntemp
argument_list|,
sizeof|sizeof
argument_list|(
name|scntemp
argument_list|)
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|scntemp
argument_list|)
condition|)
block|{
name|PERROR
argument_list|(
name|a_name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|scntemp
operator|.
name|s_scnptr
operator|>
literal|0L
condition|)
block|{
if|if
condition|(
name|block_copy_start
operator|<
name|scntemp
operator|.
name|s_scnptr
operator|+
name|scntemp
operator|.
name|s_size
condition|)
name|block_copy_start
operator|=
name|scntemp
operator|.
name|s_scnptr
operator|+
name|scntemp
operator|.
name|s_size
expr_stmt|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|scntemp
operator|.
name|s_name
argument_list|,
literal|".text"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|f_thdr
operator|=
name|scntemp
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|scntemp
operator|.
name|s_name
argument_list|,
literal|".data"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|f_dhdr
operator|=
name|scntemp
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|scntemp
operator|.
name|s_name
argument_list|,
literal|".bss"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|f_bhdr
operator|=
name|scntemp
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|ERROR0
argument_list|(
literal|"can't build a COFF file from scratch yet"
argument_list|)
expr_stmt|;
block|}
comment|/* Now we alter the contents of all the f_*hdr variables      to correspond to what we want to dump.  */
ifdef|#
directive|ifdef
name|USG_SHARED_LIBRARIES
comment|/* The amount of data we're adding to the file is distance from the    * end of the original .data space to the current end of the .data    * space.    */
name|bias
operator|=
name|bss_end
operator|-
operator|(
name|f_ohdr
operator|.
name|data_start
operator|+
name|f_dhdr
operator|.
name|s_size
operator|)
expr_stmt|;
endif|#
directive|endif
name|f_hdr
operator|.
name|f_flags
operator||=
operator|(
name|F_RELFLG
operator||
name|F_EXEC
operator|)
expr_stmt|;
ifdef|#
directive|ifdef
name|EXEC_MAGIC
name|f_ohdr
operator|.
name|magic
operator|=
name|EXEC_MAGIC
expr_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|NO_REMAP
name|f_ohdr
operator|.
name|text_start
operator|=
operator|(
name|long
operator|)
name|start_of_text
argument_list|()
expr_stmt|;
name|f_ohdr
operator|.
name|tsize
operator|=
name|data_start
operator|-
name|f_ohdr
operator|.
name|text_start
expr_stmt|;
name|f_ohdr
operator|.
name|data_start
operator|=
name|data_start
expr_stmt|;
endif|#
directive|endif
comment|/* NO_REMAP */
name|f_ohdr
operator|.
name|dsize
operator|=
name|bss_start
operator|-
name|f_ohdr
operator|.
name|data_start
expr_stmt|;
name|f_ohdr
operator|.
name|bsize
operator|=
name|bss_end
operator|-
name|bss_start
expr_stmt|;
name|f_thdr
operator|.
name|s_size
operator|=
name|f_ohdr
operator|.
name|tsize
expr_stmt|;
name|f_thdr
operator|.
name|s_scnptr
operator|=
sizeof|sizeof
argument_list|(
name|f_hdr
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|f_ohdr
argument_list|)
expr_stmt|;
name|f_thdr
operator|.
name|s_scnptr
operator|+=
operator|(
name|f_hdr
operator|.
name|f_nscns
operator|)
operator|*
operator|(
sizeof|sizeof
argument_list|(
name|f_thdr
argument_list|)
operator|)
expr_stmt|;
name|lnnoptr
operator|=
name|f_thdr
operator|.
name|s_lnnoptr
expr_stmt|;
ifdef|#
directive|ifdef
name|SECTION_ALIGNMENT
comment|/* Some systems require special alignment      of the sections in the file itself.  */
name|f_thdr
operator|.
name|s_scnptr
operator|=
operator|(
name|f_thdr
operator|.
name|s_scnptr
operator|+
name|SECTION_ALIGNMENT
operator|)
operator|&
operator|~
name|SECTION_ALIGNMENT
expr_stmt|;
endif|#
directive|endif
comment|/* SECTION_ALIGNMENT */
name|text_scnptr
operator|=
name|f_thdr
operator|.
name|s_scnptr
expr_stmt|;
name|f_dhdr
operator|.
name|s_paddr
operator|=
name|f_ohdr
operator|.
name|data_start
expr_stmt|;
name|f_dhdr
operator|.
name|s_vaddr
operator|=
name|f_ohdr
operator|.
name|data_start
expr_stmt|;
name|f_dhdr
operator|.
name|s_size
operator|=
name|f_ohdr
operator|.
name|dsize
expr_stmt|;
name|f_dhdr
operator|.
name|s_scnptr
operator|=
name|f_thdr
operator|.
name|s_scnptr
operator|+
name|f_thdr
operator|.
name|s_size
expr_stmt|;
ifdef|#
directive|ifdef
name|SECTION_ALIGNMENT
comment|/* Some systems require special alignment      of the sections in the file itself.  */
name|f_dhdr
operator|.
name|s_scnptr
operator|=
operator|(
name|f_dhdr
operator|.
name|s_scnptr
operator|+
name|SECTION_ALIGNMENT
operator|)
operator|&
operator|~
name|SECTION_ALIGNMENT
expr_stmt|;
endif|#
directive|endif
comment|/* SECTION_ALIGNMENT */
ifdef|#
directive|ifdef
name|DATA_SECTION_ALIGNMENT
comment|/* Some systems require special alignment      of the data section only.  */
name|f_dhdr
operator|.
name|s_scnptr
operator|=
operator|(
name|f_dhdr
operator|.
name|s_scnptr
operator|+
name|DATA_SECTION_ALIGNMENT
operator|)
operator|&
operator|~
name|DATA_SECTION_ALIGNMENT
expr_stmt|;
endif|#
directive|endif
comment|/* DATA_SECTION_ALIGNMENT */
name|data_scnptr
operator|=
name|f_dhdr
operator|.
name|s_scnptr
expr_stmt|;
name|f_bhdr
operator|.
name|s_paddr
operator|=
name|f_ohdr
operator|.
name|data_start
operator|+
name|f_ohdr
operator|.
name|dsize
expr_stmt|;
name|f_bhdr
operator|.
name|s_vaddr
operator|=
name|f_ohdr
operator|.
name|data_start
operator|+
name|f_ohdr
operator|.
name|dsize
expr_stmt|;
name|f_bhdr
operator|.
name|s_size
operator|=
name|f_ohdr
operator|.
name|bsize
expr_stmt|;
name|f_bhdr
operator|.
name|s_scnptr
operator|=
literal|0L
expr_stmt|;
ifndef|#
directive|ifndef
name|USG_SHARED_LIBRARIES
name|bias
operator|=
name|f_dhdr
operator|.
name|s_scnptr
operator|+
name|f_dhdr
operator|.
name|s_size
operator|-
name|block_copy_start
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|f_hdr
operator|.
name|f_symptr
operator|>
literal|0L
condition|)
block|{
name|f_hdr
operator|.
name|f_symptr
operator|+=
name|bias
expr_stmt|;
block|}
if|if
condition|(
name|f_thdr
operator|.
name|s_lnnoptr
operator|>
literal|0L
condition|)
block|{
name|f_thdr
operator|.
name|s_lnnoptr
operator|+=
name|bias
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|ADJUST_EXEC_HEADER
name|ADJUST_EXEC_HEADER
endif|#
directive|endif
comment|/* ADJUST_EXEC_HEADER */
if|if
condition|(
name|write
argument_list|(
name|new
argument_list|,
operator|&
name|f_hdr
argument_list|,
sizeof|sizeof
argument_list|(
name|f_hdr
argument_list|)
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|f_hdr
argument_list|)
condition|)
block|{
name|PERROR
argument_list|(
name|new_name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|write
argument_list|(
name|new
argument_list|,
operator|&
name|f_ohdr
argument_list|,
sizeof|sizeof
argument_list|(
name|f_ohdr
argument_list|)
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|f_ohdr
argument_list|)
condition|)
block|{
name|PERROR
argument_list|(
name|new_name
argument_list|)
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|USG_SHARED_LIBRARIES
if|if
condition|(
name|write
argument_list|(
name|new
argument_list|,
operator|&
name|f_thdr
argument_list|,
sizeof|sizeof
argument_list|(
name|f_thdr
argument_list|)
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|f_thdr
argument_list|)
condition|)
block|{
name|PERROR
argument_list|(
name|new_name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|write
argument_list|(
name|new
argument_list|,
operator|&
name|f_dhdr
argument_list|,
sizeof|sizeof
argument_list|(
name|f_dhdr
argument_list|)
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|f_dhdr
argument_list|)
condition|)
block|{
name|PERROR
argument_list|(
name|new_name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|write
argument_list|(
name|new
argument_list|,
operator|&
name|f_bhdr
argument_list|,
sizeof|sizeof
argument_list|(
name|f_bhdr
argument_list|)
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|f_bhdr
argument_list|)
condition|)
block|{
name|PERROR
argument_list|(
name|new_name
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
comment|/* USG_SHARED_LIBRARIES */
comment|/* The purpose of this code is to write out the new file's section    * header table.    *    * Scan through the original file's sections.  If the encountered    * section is one we know (.text, .data or .bss), write out the    * correct header.  If it is a section we do not know (such as    * .lib), adjust the address of where the section data is in the    * file, and write out the header.    *    * If any section preceeds .text or .data in the file, this code    * will not adjust the file pointer for that section correctly.    */
name|lseek
argument_list|(
name|a_out
argument_list|,
operator|(
name|off_t
operator|)
sizeof|sizeof
argument_list|(
name|f_hdr
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|f_ohdr
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|scns
operator|=
name|f_hdr
operator|.
name|f_nscns
init|;
name|scns
operator|>
literal|0
condition|;
name|scns
operator|--
control|)
block|{
if|if
condition|(
name|read
argument_list|(
name|a_out
argument_list|,
operator|&
name|scntemp
argument_list|,
sizeof|sizeof
argument_list|(
name|scntemp
argument_list|)
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|scntemp
argument_list|)
condition|)
name|PERROR
argument_list|(
name|a_name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|scntemp
operator|.
name|s_name
argument_list|,
name|f_thdr
operator|.
name|s_name
argument_list|)
condition|)
comment|/* .text */
block|{
if|if
condition|(
name|write
argument_list|(
name|new
argument_list|,
operator|&
name|f_thdr
argument_list|,
sizeof|sizeof
argument_list|(
name|f_thdr
argument_list|)
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|f_thdr
argument_list|)
condition|)
name|PERROR
argument_list|(
name|new_name
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|scntemp
operator|.
name|s_name
argument_list|,
name|f_dhdr
operator|.
name|s_name
argument_list|)
condition|)
comment|/* .data */
block|{
if|if
condition|(
name|write
argument_list|(
name|new
argument_list|,
operator|&
name|f_dhdr
argument_list|,
sizeof|sizeof
argument_list|(
name|f_dhdr
argument_list|)
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|f_dhdr
argument_list|)
condition|)
name|PERROR
argument_list|(
name|new_name
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|scntemp
operator|.
name|s_name
argument_list|,
name|f_bhdr
operator|.
name|s_name
argument_list|)
condition|)
comment|/* .bss */
block|{
if|if
condition|(
name|write
argument_list|(
name|new
argument_list|,
operator|&
name|f_bhdr
argument_list|,
sizeof|sizeof
argument_list|(
name|f_bhdr
argument_list|)
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|f_bhdr
argument_list|)
condition|)
name|PERROR
argument_list|(
name|new_name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|scntemp
operator|.
name|s_scnptr
condition|)
name|scntemp
operator|.
name|s_scnptr
operator|+=
name|bias
expr_stmt|;
if|if
condition|(
name|write
argument_list|(
name|new
argument_list|,
operator|&
name|scntemp
argument_list|,
sizeof|sizeof
argument_list|(
name|scntemp
argument_list|)
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|scntemp
argument_list|)
condition|)
name|PERROR
argument_list|(
name|new_name
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* USG_SHARED_LIBRARIES */
return|return
operator|(
literal|0
operator|)
return|;
else|#
directive|else
comment|/* if not COFF */
comment|/* Get symbol table info from header of a.out file if given one. */
if|if
condition|(
name|a_out
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|read
argument_list|(
name|a_out
argument_list|,
operator|&
name|ohdr
argument_list|,
sizeof|sizeof
name|hdr
argument_list|)
operator|!=
sizeof|sizeof
name|hdr
condition|)
block|{
name|PERROR
argument_list|(
name|a_name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|N_BADMAG
argument_list|(
name|ohdr
argument_list|)
condition|)
block|{
name|ERROR1
argument_list|(
literal|"invalid magic number in %s"
argument_list|,
name|a_name
argument_list|)
expr_stmt|;
block|}
name|hdr
operator|=
name|ohdr
expr_stmt|;
block|}
else|else
block|{
name|bzero
argument_list|(
name|hdr
argument_list|,
sizeof|sizeof
name|hdr
argument_list|)
expr_stmt|;
block|}
name|unexec_text_start
operator|=
operator|(
name|long
operator|)
name|start_of_text
argument_list|()
expr_stmt|;
name|unexec_data_start
operator|=
name|data_start
expr_stmt|;
comment|/* Machine-dependent fixup for header, or maybe for unexec_text_start */
ifdef|#
directive|ifdef
name|ADJUST_EXEC_HEADER
name|ADJUST_EXEC_HEADER
expr_stmt|;
endif|#
directive|endif
comment|/* ADJUST_EXEC_HEADER */
name|hdr
operator|.
name|a_trsize
operator|=
literal|0
expr_stmt|;
name|hdr
operator|.
name|a_drsize
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|entry_address
operator|!=
literal|0
condition|)
name|hdr
operator|.
name|a_entry
operator|=
name|entry_address
expr_stmt|;
name|hdr
operator|.
name|a_bss
operator|=
name|bss_end
operator|-
name|bss_start
expr_stmt|;
name|hdr
operator|.
name|a_data
operator|=
name|bss_start
operator|-
name|data_start
expr_stmt|;
ifdef|#
directive|ifdef
name|NO_REMAP
name|hdr
operator|.
name|a_text
operator|=
name|ohdr
operator|.
name|a_text
expr_stmt|;
else|#
directive|else
comment|/* not NO_REMAP */
name|hdr
operator|.
name|a_text
operator|=
name|data_start
operator|-
name|unexec_text_start
expr_stmt|;
ifdef|#
directive|ifdef
name|A_TEXT_OFFSET
name|hdr
operator|.
name|a_text
operator|+=
name|A_TEXT_OFFSET
argument_list|(
name|ohdr
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
comment|/* not NO_REMAP */
if|if
condition|(
name|write
argument_list|(
name|new
argument_list|,
operator|&
name|hdr
argument_list|,
sizeof|sizeof
name|hdr
argument_list|)
operator|!=
sizeof|sizeof
name|hdr
condition|)
block|{
name|PERROR
argument_list|(
name|new_name
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|A_TEXT_OFFSET
name|hdr
operator|.
name|a_text
operator|-=
name|A_TEXT_OFFSET
argument_list|(
name|ohdr
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
literal|0
return|;
endif|#
directive|endif
comment|/* not COFF */
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* ****************************************************************  * copy_text_and_data  *  * Copy the text and data segments from memory to the new a.out  */
end_comment

begin_function
specifier|static
name|int
name|copy_text_and_data
parameter_list|(
name|new
parameter_list|,
name|a_out
parameter_list|)
name|int
name|new
decl_stmt|,
name|a_out
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|end
decl_stmt|;
specifier|register
name|char
modifier|*
name|ptr
decl_stmt|;
ifdef|#
directive|ifdef
name|COFF
ifdef|#
directive|ifdef
name|USG_SHARED_LIBRARIES
name|int
name|scns
decl_stmt|;
name|struct
name|scnhdr
name|scntemp
decl_stmt|;
comment|/* Temporary section header */
comment|/* The purpose of this code is to write out the new file's section    * contents.    *    * Step through the section table.  If we know the section (.text,    * .data) do the appropriate thing.  Otherwise, if the section has    * no allocated space in the file (.bss), do nothing.  Otherwise,    * the section has space allocated in the file, and is not a section    * we know.  So just copy it.    */
name|lseek
argument_list|(
name|a_out
argument_list|,
operator|(
name|off_t
operator|)
sizeof|sizeof
argument_list|(
expr|struct
name|filehdr
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|aouthdr
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|scns
operator|=
name|f_hdr
operator|.
name|f_nscns
init|;
name|scns
operator|>
literal|0
condition|;
name|scns
operator|--
control|)
block|{
if|if
condition|(
name|read
argument_list|(
name|a_out
argument_list|,
operator|&
name|scntemp
argument_list|,
sizeof|sizeof
argument_list|(
name|scntemp
argument_list|)
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|scntemp
argument_list|)
condition|)
name|PERROR
argument_list|(
literal|"temacs"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|scntemp
operator|.
name|s_name
argument_list|,
literal|".text"
argument_list|)
condition|)
block|{
name|lseek
argument_list|(
name|new
argument_list|,
operator|(
name|off_t
operator|)
name|text_scnptr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ptr
operator|=
operator|(
name|char
operator|*
operator|)
name|f_ohdr
operator|.
name|text_start
expr_stmt|;
name|end
operator|=
name|ptr
operator|+
name|f_ohdr
operator|.
name|tsize
expr_stmt|;
name|write_segment
argument_list|(
name|new
argument_list|,
name|ptr
argument_list|,
name|end
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|scntemp
operator|.
name|s_name
argument_list|,
literal|".data"
argument_list|)
condition|)
block|{
name|lseek
argument_list|(
name|new
argument_list|,
operator|(
name|off_t
operator|)
name|data_scnptr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ptr
operator|=
operator|(
name|char
operator|*
operator|)
name|f_ohdr
operator|.
name|data_start
expr_stmt|;
name|end
operator|=
name|ptr
operator|+
name|f_ohdr
operator|.
name|dsize
expr_stmt|;
name|write_segment
argument_list|(
name|new
argument_list|,
name|ptr
argument_list|,
name|end
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|scntemp
operator|.
name|s_scnptr
condition|)
empty_stmt|;
comment|/* do nothing - no data for this section */
else|else
block|{
name|char
name|page
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|int
name|size
decl_stmt|,
name|n
decl_stmt|;
name|long
name|old_a_out_ptr
init|=
name|lseek
argument_list|(
name|a_out
argument_list|,
operator|(
name|off_t
operator|)
literal|0
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|lseek
argument_list|(
name|a_out
argument_list|,
operator|(
name|off_t
operator|)
name|scntemp
operator|.
name|s_scnptr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|size
operator|=
name|scntemp
operator|.
name|s_size
init|;
name|size
operator|>
literal|0
condition|;
name|size
operator|-=
sizeof|sizeof
argument_list|(
name|page
argument_list|)
control|)
block|{
name|n
operator|=
name|size
operator|>
sizeof|sizeof
argument_list|(
name|page
argument_list|)
condition|?
sizeof|sizeof
argument_list|(
name|page
argument_list|)
else|:
name|size
expr_stmt|;
if|if
condition|(
name|read
argument_list|(
name|a_out
argument_list|,
name|page
argument_list|,
name|n
argument_list|)
operator|!=
name|n
operator|||
name|write
argument_list|(
name|new
argument_list|,
name|page
argument_list|,
name|n
argument_list|)
operator|!=
name|n
condition|)
name|PERROR
argument_list|(
literal|"xemacs"
argument_list|)
expr_stmt|;
block|}
name|lseek
argument_list|(
name|a_out
argument_list|,
operator|(
name|off_t
operator|)
name|old_a_out_ptr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
else|#
directive|else
comment|/* COFF, but not USG_SHARED_LIBRARIES */
name|lseek
argument_list|(
name|new
argument_list|,
operator|(
name|off_t
operator|)
name|text_scnptr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ptr
operator|=
operator|(
name|char
operator|*
operator|)
name|f_ohdr
operator|.
name|text_start
expr_stmt|;
name|end
operator|=
name|ptr
operator|+
name|f_ohdr
operator|.
name|tsize
expr_stmt|;
name|write_segment
argument_list|(
name|new
argument_list|,
name|ptr
argument_list|,
name|end
argument_list|)
expr_stmt|;
name|lseek
argument_list|(
name|new
argument_list|,
operator|(
name|off_t
operator|)
name|data_scnptr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ptr
operator|=
operator|(
name|char
operator|*
operator|)
name|f_ohdr
operator|.
name|data_start
expr_stmt|;
name|end
operator|=
name|ptr
operator|+
name|f_ohdr
operator|.
name|dsize
expr_stmt|;
name|write_segment
argument_list|(
name|new
argument_list|,
name|ptr
argument_list|,
name|end
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* USG_SHARED_LIBRARIES */
else|#
directive|else
comment|/* if not COFF */
comment|/* Some machines count the header as part of the text segment.    That is to say, the header appears in core    just before the address that start_of_text () returns.    For them, N_TXTOFF is the place where the header goes.    We must adjust the seek to the place after the header.    Note that at this point hdr.a_text does *not* count    the extra A_TEXT_OFFSET bytes, only the actual bytes of code.  */
ifdef|#
directive|ifdef
name|A_TEXT_SEEK
name|lseek
argument_list|(
name|new
argument_list|,
operator|(
name|off_t
operator|)
name|A_TEXT_SEEK
argument_list|(
name|hdr
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|#
directive|else
ifdef|#
directive|ifdef
name|A_TEXT_OFFSET
comment|/* Note that on the Sequent machine A_TEXT_OFFSET != sizeof (hdr)      and sizeof (hdr) is the correct amount to add here.  */
comment|/* In version 19, eliminate this case and use A_TEXT_SEEK whenever      N_TXTOFF is not right.  */
name|lseek
argument_list|(
name|new
argument_list|,
operator|(
name|off_t
operator|)
name|N_TXTOFF
argument_list|(
name|hdr
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|hdr
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|#
directive|else
name|lseek
argument_list|(
name|new
argument_list|,
operator|(
name|off_t
operator|)
name|N_TXTOFF
argument_list|(
name|hdr
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* no A_TEXT_OFFSET */
endif|#
directive|endif
comment|/* no A_TEXT_SEEK */
name|ptr
operator|=
operator|(
name|char
operator|*
operator|)
name|unexec_text_start
expr_stmt|;
name|end
operator|=
name|ptr
operator|+
name|hdr
operator|.
name|a_text
expr_stmt|;
name|write_segment
argument_list|(
name|new
argument_list|,
name|ptr
argument_list|,
name|end
argument_list|)
expr_stmt|;
name|ptr
operator|=
operator|(
name|char
operator|*
operator|)
name|unexec_data_start
expr_stmt|;
name|end
operator|=
name|ptr
operator|+
name|hdr
operator|.
name|a_data
expr_stmt|;
comment|/*  This lseek is certainly incorrect when A_TEXT_OFFSET     and I believe it is a no-op otherwise.     Let's see if its absence ever fails.  */
comment|/*  lseek (new, (off_t) N_TXTOFF (hdr) + hdr.a_text, 0); */
name|write_segment
argument_list|(
name|new
argument_list|,
name|ptr
argument_list|,
name|end
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* not COFF */
return|return
literal|0
return|;
block|}
end_function

begin_macro
name|write_segment
argument_list|(
argument|new
argument_list|,
argument|ptr
argument_list|,
argument|end
argument_list|)
end_macro

begin_decl_stmt
name|int
name|new
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|char
modifier|*
name|ptr
decl_stmt|,
modifier|*
name|end
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|nwrite
decl_stmt|,
name|ret
decl_stmt|;
name|char
name|buf
index|[
literal|80
index|]
decl_stmt|;
specifier|extern
name|int
name|errno
decl_stmt|;
name|char
name|zeros
index|[
literal|128
index|]
decl_stmt|;
name|bzero
argument_list|(
name|zeros
argument_list|,
sizeof|sizeof
name|zeros
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|ptr
operator|<
name|end
condition|;
control|)
block|{
comment|/* distance to next multiple of 128.  */
name|nwrite
operator|=
operator|(
operator|(
operator|(
name|int
operator|)
name|ptr
operator|+
literal|128
operator|)
operator|&
operator|-
literal|128
operator|)
operator|-
operator|(
name|int
operator|)
name|ptr
expr_stmt|;
comment|/* But not beyond specified end.  */
if|if
condition|(
name|nwrite
operator|>
name|end
operator|-
name|ptr
condition|)
name|nwrite
operator|=
name|end
operator|-
name|ptr
expr_stmt|;
name|ret
operator|=
name|write
argument_list|(
name|new
argument_list|,
name|ptr
argument_list|,
name|nwrite
argument_list|)
expr_stmt|;
comment|/* If write gets a page fault, it means we reached 	 a gap between the old text segment and the old data segment. 	 This gap has probably been remapped into part of the text segment. 	 So write zeros for it.  */
if|if
condition|(
name|ret
operator|==
operator|-
literal|1
operator|&&
name|errno
operator|==
name|EFAULT
condition|)
name|write
argument_list|(
name|new
argument_list|,
name|zeros
argument_list|,
name|nwrite
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|nwrite
operator|!=
name|ret
condition|)
block|{
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"unexec write failure: addr 0x%x, fileno %d, size 0x%x, wrote 0x%x, errno %d"
argument_list|,
name|ptr
argument_list|,
name|new
argument_list|,
name|nwrite
argument_list|,
name|ret
argument_list|,
name|errno
argument_list|)
expr_stmt|;
name|PERROR
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
name|i
operator|+=
name|nwrite
expr_stmt|;
name|ptr
operator|+=
name|nwrite
expr_stmt|;
block|}
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* ****************************************************************  * copy_sym  *  * Copy the relocation information and symbol table from the a.out to the new  */
end_comment

begin_function
specifier|static
name|int
name|copy_sym
parameter_list|(
name|new
parameter_list|,
name|a_out
parameter_list|,
name|a_name
parameter_list|,
name|new_name
parameter_list|)
name|int
name|new
decl_stmt|,
name|a_out
decl_stmt|;
name|char
modifier|*
name|a_name
decl_stmt|,
decl|*
name|new_name
decl_stmt|;
end_function

begin_block
block|{
name|char
name|page
index|[
literal|1024
index|]
decl_stmt|;
name|int
name|n
decl_stmt|;
if|if
condition|(
name|a_out
operator|<
literal|0
condition|)
return|return
literal|0
return|;
ifdef|#
directive|ifdef
name|COFF
if|if
condition|(
name|SYMS_START
operator|==
literal|0L
condition|)
return|return
literal|0
return|;
endif|#
directive|endif
comment|/* COFF */
ifdef|#
directive|ifdef
name|COFF
if|if
condition|(
name|lnnoptr
condition|)
comment|/* if there is line number info */
name|lseek
argument_list|(
name|a_out
argument_list|,
operator|(
name|off_t
operator|)
name|lnnoptr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* start copying from there */
else|else
endif|#
directive|endif
comment|/* COFF */
name|lseek
argument_list|(
name|a_out
argument_list|,
operator|(
name|off_t
operator|)
name|SYMS_START
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Position a.out to symtab. */
while|while
condition|(
operator|(
name|n
operator|=
name|read
argument_list|(
name|a_out
argument_list|,
name|page
argument_list|,
sizeof|sizeof
name|page
argument_list|)
operator|)
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|write
argument_list|(
name|new
argument_list|,
name|page
argument_list|,
name|n
argument_list|)
operator|!=
name|n
condition|)
block|{
name|PERROR
argument_list|(
name|new_name
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
name|PERROR
argument_list|(
name|a_name
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* ****************************************************************  * mark_x  *  * After succesfully building the new a.out, mark it executable  */
end_comment

begin_expr_stmt
specifier|static
name|mark_x
argument_list|(
argument|name
argument_list|)
name|char
operator|*
name|name
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|struct
name|stat
name|sbuf
decl_stmt|;
name|int
name|um
decl_stmt|;
name|int
name|new
init|=
literal|0
decl_stmt|;
comment|/* for PERROR */
name|um
operator|=
name|umask
argument_list|(
literal|777
argument_list|)
expr_stmt|;
name|umask
argument_list|(
name|um
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|name
argument_list|,
operator|&
name|sbuf
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|PERROR
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
name|sbuf
operator|.
name|st_mode
operator||=
literal|0111
operator|&
operator|~
name|um
expr_stmt|;
if|if
condition|(
name|chmod
argument_list|(
name|name
argument_list|,
name|sbuf
operator|.
name|st_mode
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|PERROR
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/*  *	If the COFF file contains a symbol table and a line number section,  *	then any auxiliary entries that have values for x_lnnoptr must  *	be adjusted by the amount that the line number section has moved  *	in the file (bias computed in make_hdr).  The #@$%&* designers of  *	the auxiliary entry structures used the absolute file offsets for  *	the line number entry rather than an offset from the start of the  *	line number section!  *  *	When I figure out how to scan through the symbol table and pick out  *	the auxiliary entries that need adjustment, this routine will  *	be fixed.  As it is now, all such entries are wrong and sdb  *	will complain.   Fred Fish, UniSoft Systems Inc.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|COFF
end_ifdef

begin_comment
comment|/* This function is probably very slow.  Instead of reopening the new    file for input and output it should copy from the old to the new    using the two descriptors already open (WRITEDESC and READDESC).    Instead of reading one small structure at a time it should use    a reasonable size buffer.  But I don't have time to work on such    things, so I am installing it as submitted to me.  -- RMS.  */
end_comment

begin_macro
name|adjust_lnnoptrs
argument_list|(
argument|writedesc
argument_list|,
argument|readdesc
argument_list|,
argument|new_name
argument_list|)
end_macro

begin_decl_stmt
name|int
name|writedesc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|readdesc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|new_name
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|nsyms
decl_stmt|;
specifier|register
name|int
name|new
decl_stmt|;
ifdef|#
directive|ifdef
name|amdahl_uts
name|SYMENT
name|symentry
decl_stmt|;
name|AUXENT
name|auxentry
decl_stmt|;
else|#
directive|else
name|struct
name|syment
name|symentry
decl_stmt|;
name|union
name|auxent
name|auxentry
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|lnnoptr
operator|||
operator|!
name|f_hdr
operator|.
name|f_symptr
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|(
name|new
operator|=
name|open
argument_list|(
name|new_name
argument_list|,
literal|2
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|PERROR
argument_list|(
name|new_name
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|lseek
argument_list|(
name|new
argument_list|,
operator|(
name|off_t
operator|)
name|f_hdr
operator|.
name|f_symptr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|nsyms
operator|=
literal|0
init|;
name|nsyms
operator|<
name|f_hdr
operator|.
name|f_nsyms
condition|;
name|nsyms
operator|++
control|)
block|{
name|read
argument_list|(
name|new
argument_list|,
operator|&
name|symentry
argument_list|,
name|SYMESZ
argument_list|)
expr_stmt|;
if|if
condition|(
name|symentry
operator|.
name|n_numaux
condition|)
block|{
name|read
argument_list|(
name|new
argument_list|,
operator|&
name|auxentry
argument_list|,
name|AUXESZ
argument_list|)
expr_stmt|;
name|nsyms
operator|++
expr_stmt|;
if|if
condition|(
name|ISFCN
argument_list|(
name|symentry
operator|.
name|n_type
argument_list|)
condition|)
block|{
name|auxentry
operator|.
name|x_sym
operator|.
name|x_fcnary
operator|.
name|x_fcn
operator|.
name|x_lnnoptr
operator|+=
name|bias
expr_stmt|;
name|lseek
argument_list|(
name|new
argument_list|,
operator|(
name|off_t
operator|)
operator|-
name|AUXESZ
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|write
argument_list|(
name|new
argument_list|,
operator|&
name|auxentry
argument_list|,
name|AUXESZ
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|close
argument_list|(
name|new
argument_list|)
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* COFF */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not CANNOT_UNEXEC */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not CANNOT_DUMP */
end_comment

end_unit

