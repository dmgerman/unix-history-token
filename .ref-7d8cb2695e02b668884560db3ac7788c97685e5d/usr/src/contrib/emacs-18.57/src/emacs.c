begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Fully extensible Emacs, running on Unix, intended for GNU.    Copyright (C) 1985, 1986, 1987, 1990 Free Software Foundation, Inc.  This file is part of GNU Emacs.  GNU Emacs is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 1, or (at your option) any later version.  GNU Emacs is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU Emacs; see the file COPYING.  If not, write to the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_undef
undef|#
directive|undef
name|NULL
end_undef

begin_include
include|#
directive|include
file|"lisp.h"
end_include

begin_include
include|#
directive|include
file|"commands.h"
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|VMS
end_ifdef

begin_include
include|#
directive|include
file|<ssdef.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|USG5
end_ifdef

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|BSD
end_ifdef

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|APOLLO
end_ifdef

begin_ifndef
ifndef|#
directive|ifndef
name|APOLLO_SR10
end_ifndef

begin_include
include|#
directive|include
file|<default_acl.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|O_RDWR
end_ifndef

begin_define
define|#
directive|define
name|O_RDWR
value|2
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|PRIO_PROCESS
value|0
end_define

begin_comment
comment|/* Command line args from shell, as list of strings */
end_comment

begin_decl_stmt
name|Lisp_Object
name|Vcommand_line_args
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Hook run by `kill-emacs' before it does really anything.  */
end_comment

begin_decl_stmt
name|Lisp_Object
name|Vkill_emacs_hook
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Set nonzero after Emacs has started up the first time.   Prevents reinitialization of the Lisp world and keymaps   on subsequent starts.  */
end_comment

begin_decl_stmt
name|int
name|initialized
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Variable whose value is symbol giving operating system type */
end_comment

begin_decl_stmt
name|Lisp_Object
name|Vsystem_type
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If non-zero, emacs should not attempt to use an window-specific code,    but instead should use the virtual terminal under which it was started */
end_comment

begin_decl_stmt
name|int
name|inhibit_window_system
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_X_WINDOWS
end_ifdef

begin_comment
comment|/* If -d option is used, this variable points to the name of    the display to use.  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|alternate_display
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
modifier|*
name|xargv
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|xargc
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_X_WINDOWS */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|USG_SHARED_LIBRARIES
end_ifdef

begin_comment
comment|/* If nonzero, this is the place to put the end of the writable segment    at startup.  */
end_comment

begin_decl_stmt
name|unsigned
name|int
name|bss_end
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Nonzero means running Emacs without interactive terminal.  */
end_comment

begin_decl_stmt
name|int
name|noninteractive
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Value of Lisp variable `noninteractive'.    Normally same as C variable `noninteractive'    but nothing terrible happens if user sets this one.  */
end_comment

begin_decl_stmt
name|int
name|noninteractive1
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Signal code for the fatal signal that was received */
end_comment

begin_decl_stmt
name|int
name|fatal_error_code
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if handling a fatal error already */
end_comment

begin_decl_stmt
name|int
name|fatal_error_in_progress
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Handle bus errors, illegal instruction, etc. */
end_comment

begin_macro
name|fatal_error_signal
argument_list|(
argument|sig
argument_list|)
end_macro

begin_decl_stmt
name|int
name|sig
decl_stmt|;
end_decl_stmt

begin_block
block|{
ifdef|#
directive|ifdef
name|BSD
name|int
name|tpgrp
decl_stmt|;
endif|#
directive|endif
comment|/* BSD */
name|fatal_error_code
operator|=
name|sig
expr_stmt|;
name|signal
argument_list|(
name|sig
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
comment|/* If fatal error occurs in code below, avoid infinite recursion.  */
if|if
condition|(
name|fatal_error_in_progress
condition|)
name|kill
argument_list|(
name|getpid
argument_list|()
argument_list|,
name|fatal_error_code
argument_list|)
expr_stmt|;
name|fatal_error_in_progress
operator|=
literal|1
expr_stmt|;
comment|/* If we are controlling the terminal, reset terminal modes */
ifdef|#
directive|ifdef
name|BSD
if|if
condition|(
name|ioctl
argument_list|(
literal|0
argument_list|,
name|TIOCGPGRP
argument_list|,
operator|&
name|tpgrp
argument_list|)
operator|==
literal|0
operator|&&
name|tpgrp
operator|==
name|getpgrp
argument_list|(
literal|0
argument_list|)
condition|)
endif|#
directive|endif
comment|/* BSD */
block|{
name|reset_sys_modes
argument_list|()
expr_stmt|;
if|if
condition|(
name|sig
operator|!=
name|SIGTERM
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Fatal error (%d)."
argument_list|,
name|sig
argument_list|)
expr_stmt|;
block|}
comment|/* Clean up */
ifdef|#
directive|ifdef
name|subprocesses
name|kill_buffer_processes
argument_list|(
name|Qnil
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|Fdo_auto_save
argument_list|(
name|Qt
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|CLASH_DETECTION
name|unlock_all_files
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* CLASH_DETECTION */
ifdef|#
directive|ifdef
name|VMS
name|kill_vms_processes
argument_list|()
expr_stmt|;
name|LIB$STOP
argument_list|(
name|SS$_ABORT
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* Signal the same code; this time it will really be fatal.  */
name|kill
argument_list|(
name|getpid
argument_list|()
argument_list|,
name|fatal_error_code
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* not VMS */
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* Code for dealing with Lisp access to the Unix command line */
end_comment

begin_expr_stmt
specifier|static
name|init_cmdargs
argument_list|(
argument|argc
argument_list|,
argument|argv
argument_list|,
argument|skip_args
argument_list|)
name|int
name|argc
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|skip_args
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|Vcommand_line_args
operator|=
name|Qnil
expr_stmt|;
for|for
control|(
name|i
operator|=
name|argc
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|i
operator|==
literal|0
operator|||
name|i
operator|>
name|skip_args
condition|)
name|Vcommand_line_args
operator|=
name|Fcons
argument_list|(
name|build_string
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|)
argument_list|,
name|Vcommand_line_args
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|VMS
end_ifdef

begin_ifdef
ifdef|#
directive|ifdef
name|LINK_CRTL_SHARE
end_ifdef

begin_ifdef
ifdef|#
directive|ifdef
name|SHAREABLE_LIB_BUG
end_ifdef

begin_decl_stmt
specifier|extern
name|noshare
name|char
modifier|*
modifier|*
name|environ
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SHAREABLE_LIB_BUG */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* LINK_CRTL_SHARE */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* VMS */
end_comment

begin_comment
comment|/* We don't include crtbegin.o and crtend.o in the link,    so these functions and variables might be missed.    Provide dummy definitions to avoid error.    (We don't have any real constructors or destructors.)  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__GNUC__
end_ifdef

begin_ifndef
ifndef|#
directive|ifndef
name|ORDINARY_LINK
end_ifndef

begin_macro
name|__do_clobal_ctors
argument_list|()
end_macro

begin_block
block|{}
end_block

begin_macro
name|__do_clobal_ctors_aux
argument_list|()
end_macro

begin_block
block|{}
end_block

begin_macro
name|__do_global_dtors
argument_list|()
end_macro

begin_block
block|{}
end_block

begin_decl_stmt
name|char
modifier|*
name|__CTOR_LIST__
index|[
literal|2
index|]
init|=
block|{
operator|(
name|char
operator|*
operator|)
operator|(
operator|-
literal|1
operator|)
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|__DTOR_LIST__
index|[
literal|2
index|]
init|=
block|{
operator|(
name|char
operator|*
operator|)
operator|(
operator|-
literal|1
operator|)
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_macro
name|__main
argument_list|()
end_macro

begin_block
block|{}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not ORDINARY_LINK */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* __GNUC__ */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|,
name|envp
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
name|char
modifier|*
modifier|*
name|envp
decl_stmt|;
block|{
name|int
name|skip_args
init|=
literal|0
decl_stmt|;
specifier|extern
name|int
name|errno
decl_stmt|;
specifier|extern
name|void
name|malloc_warning
parameter_list|()
function_decl|;
comment|/* Map in shared memory, if we are using that.  */
ifdef|#
directive|ifdef
name|HAVE_SHM
if|if
condition|(
name|argc
operator|>
literal|1
operator|&&
operator|!
name|strcmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"-nl"
argument_list|)
condition|)
block|{
name|map_in_data
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* The shared momory was just restored, which clobbered this.  */
name|skip_args
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|map_in_data
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* The shared momory was just restored, which clobbered this.  */
name|skip_args
operator|=
literal|0
expr_stmt|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|VMS
comment|/* If -map specified, map the data file in */
if|if
condition|(
name|argc
operator|>
literal|2
operator|&&
operator|!
name|strcmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"-map"
argument_list|)
condition|)
block|{
name|skip_args
operator|=
literal|2
expr_stmt|;
name|mapin_data
argument_list|(
name|argv
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|LINK_CRTL_SHARE
ifdef|#
directive|ifdef
name|SHAREABLE_LIB_BUG
comment|/* Bletcherous shared libraries! */
if|if
condition|(
operator|!
name|stdin
condition|)
name|stdin
operator|=
name|fdopen
argument_list|(
literal|0
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|stdout
condition|)
name|stdout
operator|=
name|fdopen
argument_list|(
literal|1
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|stderr
condition|)
name|stderr
operator|=
name|fdopen
argument_list|(
literal|2
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|environ
condition|)
name|environ
operator|=
name|envp
expr_stmt|;
endif|#
directive|endif
comment|/* SHAREABLE_LIB_BUG */
endif|#
directive|endif
comment|/* LINK_CRTL_SHARE */
endif|#
directive|endif
comment|/* VMS */
ifdef|#
directive|ifdef
name|USG_SHARED_LIBRARIES
if|if
condition|(
name|bss_end
condition|)
name|brk
argument_list|(
name|bss_end
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|clearerr
argument_list|(
name|stdin
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|APOLLO
ifndef|#
directive|ifndef
name|APOLLO_SR10
comment|/* If USE_DOMAIN_ACLS environment variable exists,      use ACLs rather than UNIX modes. */
if|if
condition|(
name|egetenv
argument_list|(
literal|"USE_DOMAIN_ACLS"
argument_list|)
condition|)
name|default_acl
argument_list|(
name|USE_DEFACL
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
comment|/* APOLLO */
ifndef|#
directive|ifndef
name|SYSTEM_MALLOC
comment|/* Arrange for warnings when nearly out of space.  */
name|malloc_init
argument_list|(
literal|0
argument_list|,
name|malloc_warning
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HIGHPRI
name|setpriority
argument_list|(
name|PRIO_PROCESS
argument_list|,
name|getpid
argument_list|()
argument_list|,
name|HIGHPRI
argument_list|)
expr_stmt|;
name|setuid
argument_list|(
name|getuid
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|HIGHPRI
name|inhibit_window_system
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_X_WINDOWS
name|xargv
operator|=
name|argv
expr_stmt|;
name|xargc
operator|=
name|argc
expr_stmt|;
endif|#
directive|endif
comment|/* Handle the -t switch, which specifies filename to use as terminal */
if|if
condition|(
name|skip_args
operator|+
literal|2
operator|<
name|argc
operator|&&
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|skip_args
operator|+
literal|1
index|]
argument_list|,
literal|"-t"
argument_list|)
condition|)
block|{
name|skip_args
operator|+=
literal|2
expr_stmt|;
name|close
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|close
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|open
argument_list|(
name|argv
index|[
name|skip_args
index|]
argument_list|,
name|O_RDWR
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|dup
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Using %s\n"
argument_list|,
name|argv
index|[
name|skip_args
index|]
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_X_WINDOWS
name|inhibit_window_system
operator|=
literal|1
expr_stmt|;
comment|/* -t => -nw */
endif|#
directive|endif
block|}
ifdef|#
directive|ifdef
name|HAVE_X_WINDOWS
comment|/* Handle the -d switch, which means use a different display for X */
if|if
condition|(
name|skip_args
operator|+
literal|2
operator|<
name|argc
operator|&&
operator|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|skip_args
operator|+
literal|1
index|]
argument_list|,
literal|"-d"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|skip_args
operator|+
literal|1
index|]
argument_list|,
literal|"-display"
argument_list|)
operator|)
condition|)
block|{
name|skip_args
operator|+=
literal|2
expr_stmt|;
name|alternate_display
operator|=
name|argv
index|[
name|skip_args
index|]
expr_stmt|;
block|}
else|else
name|alternate_display
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
comment|/* HAVE_X_WINDOWS */
if|if
condition|(
name|skip_args
operator|+
literal|1
operator|<
name|argc
operator|&&
operator|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|skip_args
operator|+
literal|1
index|]
argument_list|,
literal|"-nw"
argument_list|)
operator|)
condition|)
block|{
name|skip_args
operator|+=
literal|1
expr_stmt|;
name|inhibit_window_system
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Handle the -batch switch, which means don't do interactive display.  */
name|noninteractive
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|skip_args
operator|+
literal|1
operator|<
name|argc
operator|&&
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|skip_args
operator|+
literal|1
index|]
argument_list|,
literal|"-batch"
argument_list|)
condition|)
block|{
name|skip_args
operator|+=
literal|1
expr_stmt|;
name|noninteractive
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
ifndef|#
directive|ifndef
name|CANNOT_DUMP
operator|!
name|noninteractive
operator|||
name|initialized
else|#
directive|else
literal|1
endif|#
directive|endif
condition|)
block|{
comment|/* Don't catch these signals in batch mode if not initialized. 	 On some machines, this sets static data that would make 	 signal fail to work right when the dumped Emacs is run.  */
name|signal
argument_list|(
name|SIGHUP
argument_list|,
name|fatal_error_signal
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|fatal_error_signal
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGILL
argument_list|,
name|fatal_error_signal
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGTRAP
argument_list|,
name|fatal_error_signal
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGIOT
argument_list|,
name|fatal_error_signal
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SIGEMT
name|signal
argument_list|(
name|SIGEMT
argument_list|,
name|fatal_error_signal
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|signal
argument_list|(
name|SIGFPE
argument_list|,
name|fatal_error_signal
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGBUS
argument_list|,
name|fatal_error_signal
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGSEGV
argument_list|,
name|fatal_error_signal
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGSYS
argument_list|,
name|fatal_error_signal
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGTERM
argument_list|,
name|fatal_error_signal
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SIGXCPU
name|signal
argument_list|(
name|SIGXCPU
argument_list|,
name|fatal_error_signal
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGXFSZ
name|signal
argument_list|(
name|SIGXFSZ
argument_list|,
name|fatal_error_signal
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|SIGXFSZ
ifdef|#
directive|ifdef
name|AIX
name|signal
argument_list|(
name|SIGDANGER
argument_list|,
name|fatal_error_signal
argument_list|)
expr_stmt|;
name|signal
argument_list|(
literal|20
argument_list|,
name|fatal_error_signal
argument_list|)
expr_stmt|;
name|signal
argument_list|(
literal|21
argument_list|,
name|fatal_error_signal
argument_list|)
expr_stmt|;
name|signal
argument_list|(
literal|22
argument_list|,
name|fatal_error_signal
argument_list|)
expr_stmt|;
name|signal
argument_list|(
literal|23
argument_list|,
name|fatal_error_signal
argument_list|)
expr_stmt|;
name|signal
argument_list|(
literal|24
argument_list|,
name|fatal_error_signal
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGAIO
argument_list|,
name|fatal_error_signal
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGPTY
argument_list|,
name|fatal_error_signal
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGIOINT
argument_list|,
name|fatal_error_signal
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGGRANT
argument_list|,
name|fatal_error_signal
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGRETRACT
argument_list|,
name|fatal_error_signal
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGSOUND
argument_list|,
name|fatal_error_signal
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGMSG
argument_list|,
name|fatal_error_signal
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* AIX */
block|}
name|noninteractive1
operator|=
name|noninteractive
expr_stmt|;
comment|/* Perform basic initializations (not merely interning symbols) */
if|if
condition|(
operator|!
name|initialized
condition|)
block|{
name|init_alloc_once
argument_list|()
expr_stmt|;
name|init_obarray
argument_list|()
expr_stmt|;
name|init_eval_once
argument_list|()
expr_stmt|;
name|init_syntax_once
argument_list|()
expr_stmt|;
comment|/* Create standard syntax table.  */
comment|/* Must be done before init_buffer */
name|init_buffer_once
argument_list|()
expr_stmt|;
comment|/* Create buffer table and some buffers */
name|init_minibuf_once
argument_list|()
expr_stmt|;
comment|/* Create list of minibuffers */
comment|/* Must precede init_window_once */
name|init_window_once
argument_list|()
expr_stmt|;
comment|/* Init the window system */
block|}
name|init_alloc
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|MAINTAIN_ENVIRONMENT
name|init_environ
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|init_eval
argument_list|()
expr_stmt|;
name|init_data
argument_list|()
expr_stmt|;
name|init_read
argument_list|()
expr_stmt|;
name|init_cmdargs
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|skip_args
argument_list|)
expr_stmt|;
comment|/* Create list Vcommand_line_args */
name|init_buffer
argument_list|()
expr_stmt|;
comment|/* Init default directory of main buffer */
if|if
condition|(
operator|!
name|noninteractive
condition|)
block|{
ifdef|#
directive|ifdef
name|VMS
name|init_vms_input
argument_list|()
expr_stmt|;
comment|/* init_display calls get_screen_size, that needs this */
endif|#
directive|endif
comment|/* VMS */
name|init_display
argument_list|()
expr_stmt|;
comment|/* Determine terminal type.  init_sys_modes uses results */
block|}
name|init_keyboard
argument_list|()
expr_stmt|;
comment|/* This too must precede init_sys_modes */
name|init_callproc
argument_list|()
expr_stmt|;
comment|/* And this too. */
name|init_sys_modes
argument_list|()
expr_stmt|;
comment|/* Init system terminal modes (RAW or CBREAK, etc.) */
name|init_xdisp
argument_list|()
expr_stmt|;
name|init_macros
argument_list|()
expr_stmt|;
name|init_editfns
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|VMS
name|init_vmsfns
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* VMS */
ifdef|#
directive|ifdef
name|subprocesses
name|init_process
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* subprocesses */
comment|/* Intern the names of all standard functions and variables; define standard keys */
if|if
condition|(
operator|!
name|initialized
condition|)
block|{
comment|/* The basic levels of Lisp must come first */
comment|/* And data must come first of all 	 for the sake of symbols like error-message */
name|syms_of_data
argument_list|()
expr_stmt|;
name|syms_of_alloc
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|MAINTAIN_ENVIRONMENT
name|syms_of_environ
argument_list|()
expr_stmt|;
endif|#
directive|endif
endif|MAINTAIN_ENVIRONMENT
name|syms_of_read
argument_list|()
expr_stmt|;
name|syms_of_print
argument_list|()
expr_stmt|;
name|syms_of_eval
argument_list|()
expr_stmt|;
name|syms_of_fns
argument_list|()
expr_stmt|;
name|syms_of_abbrev
argument_list|()
expr_stmt|;
name|syms_of_buffer
argument_list|()
expr_stmt|;
name|syms_of_bytecode
argument_list|()
expr_stmt|;
name|syms_of_callint
argument_list|()
expr_stmt|;
name|syms_of_casefiddle
argument_list|()
expr_stmt|;
name|syms_of_callproc
argument_list|()
expr_stmt|;
name|syms_of_cmds
argument_list|()
expr_stmt|;
ifndef|#
directive|ifndef
name|NO_DIR_LIBRARY
name|syms_of_dired
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* not NO_DIR_LIBRARY */
name|syms_of_display
argument_list|()
expr_stmt|;
name|syms_of_doc
argument_list|()
expr_stmt|;
name|syms_of_editfns
argument_list|()
expr_stmt|;
name|syms_of_emacs
argument_list|()
expr_stmt|;
name|syms_of_fileio
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|CLASH_DETECTION
name|syms_of_filelock
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* CLASH_DETECTION */
name|syms_of_indent
argument_list|()
expr_stmt|;
name|syms_of_keyboard
argument_list|()
expr_stmt|;
name|syms_of_keymap
argument_list|()
expr_stmt|;
name|syms_of_macros
argument_list|()
expr_stmt|;
name|syms_of_marker
argument_list|()
expr_stmt|;
name|syms_of_minibuf
argument_list|()
expr_stmt|;
name|syms_of_mocklisp
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|subprocesses
name|syms_of_process
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* subprocesses */
name|syms_of_search
argument_list|()
expr_stmt|;
name|syms_of_syntax
argument_list|()
expr_stmt|;
name|syms_of_undo
argument_list|()
expr_stmt|;
name|syms_of_window
argument_list|()
expr_stmt|;
name|syms_of_xdisp
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_X_WINDOWS
name|syms_of_xfns
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_X_MENU
name|syms_of_xmenu
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* HAVE_X_MENU */
endif|#
directive|endif
comment|/* HAVE_X_WINDOWS */
ifdef|#
directive|ifdef
name|SYMS_SYSTEM
name|SYMS_SYSTEM
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SYMS_MACHINE
name|SYMS_MACHINE
expr_stmt|;
endif|#
directive|endif
name|keys_of_casefiddle
argument_list|()
expr_stmt|;
name|keys_of_cmds
argument_list|()
expr_stmt|;
name|keys_of_buffer
argument_list|()
expr_stmt|;
name|keys_of_keyboard
argument_list|()
expr_stmt|;
name|keys_of_keymap
argument_list|()
expr_stmt|;
name|keys_of_macros
argument_list|()
expr_stmt|;
name|keys_of_minibuf
argument_list|()
expr_stmt|;
name|keys_of_window
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|initialized
condition|)
block|{
comment|/* Handle -l loadup-and-dump, args passed by Makefile. */
if|if
condition|(
name|argc
operator|>
literal|2
operator|+
name|skip_args
operator|&&
operator|!
name|strcmp
argument_list|(
name|argv
index|[
literal|1
operator|+
name|skip_args
index|]
argument_list|,
literal|"-l"
argument_list|)
condition|)
name|Vtop_level
operator|=
name|Fcons
argument_list|(
name|intern
argument_list|(
literal|"load"
argument_list|)
argument_list|,
name|Fcons
argument_list|(
name|build_string
argument_list|(
name|argv
index|[
literal|2
operator|+
name|skip_args
index|]
argument_list|)
argument_list|,
name|Qnil
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|CANNOT_DUMP
comment|/* Unless next switch is -nl, load "loadup.el" first thing.  */
if|if
condition|(
operator|!
operator|(
name|argc
operator|>
literal|1
operator|+
name|skip_args
operator|&&
operator|!
name|strcmp
argument_list|(
name|argv
index|[
literal|1
operator|+
name|skip_args
index|]
argument_list|,
literal|"-nl"
argument_list|)
operator|)
condition|)
name|Vtop_level
operator|=
name|Fcons
argument_list|(
name|intern
argument_list|(
literal|"load"
argument_list|)
argument_list|,
name|Fcons
argument_list|(
name|build_string
argument_list|(
literal|"loadup.el"
argument_list|)
argument_list|,
name|Qnil
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* CANNOT_DUMP */
block|}
name|initialized
operator|=
literal|1
expr_stmt|;
comment|/* Enter editor command loop.  This never returns.  */
name|Frecursive_edit
argument_list|()
expr_stmt|;
comment|/* NOTREACHED */
block|}
end_function

begin_escape
end_escape

begin_macro
name|DEFUN
argument_list|(
literal|"kill-emacs"
argument_list|,
argument|Fkill_emacs
argument_list|,
argument|Skill_emacs
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|"P"
argument_list|,
literal|"Exit the Emacs job and kill it.  ARG means no query.\n\ If emacs is running noninteractively and ARG is an integer,\n\ return ARG as the exit program code."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|arg
operator|)
name|Lisp_Object
name|arg
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|Lisp_Object
name|answer
decl_stmt|;
name|int
name|i
decl_stmt|;
name|struct
name|gcpro
name|gcpro1
decl_stmt|;
name|GCPRO1
argument_list|(
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|NULL
argument_list|(
name|Vkill_emacs_hook
argument_list|)
condition|)
name|call0
argument_list|(
name|Vkill_emacs_hook
argument_list|)
expr_stmt|;
if|if
condition|(
name|feof
argument_list|(
name|stdin
argument_list|)
condition|)
name|arg
operator|=
name|Qt
expr_stmt|;
ifdef|#
directive|ifdef
name|subprocesses
name|kill_buffer_processes
argument_list|(
name|Qnil
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* subprocesses */
ifdef|#
directive|ifdef
name|VMS
name|kill_vms_processes
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* VMS */
name|Fdo_auto_save
argument_list|(
name|Qt
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|CLASH_DETECTION
name|unlock_all_files
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* CLASH_DETECTION */
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|reset_sys_modes
argument_list|()
expr_stmt|;
name|UNGCPRO
expr_stmt|;
comment|/* Is it really necessary to do this deassign    when we are going to exit anyway?  */
comment|/* #ifdef VMS   stop_vms_input ();  #endif  */
name|stuff_buffered_input
argument_list|(
name|arg
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SIGIO
comment|/* There is a tendency for a SIGIO signal to arrive within exit,      and cause a SIGHUP because the input descriptor is already closed.  */
name|unrequest_sigio
argument_list|()
expr_stmt|;
name|signal
argument_list|(
name|SIGIO
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|exit
argument_list|(
operator|(
name|XTYPE
argument_list|(
name|arg
argument_list|)
operator|==
name|Lisp_Int
operator|)
condition|?
name|XINT
argument_list|(
name|arg
argument_list|)
ifdef|#
directive|ifdef
name|VMS
else|:
literal|1
else|#
directive|else
operator|:
literal|0
endif|#
directive|endif
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
end_block

begin_escape
end_escape

begin_ifndef
ifndef|#
directive|ifndef
name|CANNOT_DUMP
end_ifndef

begin_comment
comment|/* Nothing like this can be implemented on an Apollo.    What a loss!  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SHM
end_ifdef

begin_macro
name|DEFUN
argument_list|(
literal|"dump-emacs-data"
argument_list|,
argument|Fdump_emacs_data
argument_list|,
argument|Sdump_emacs_data
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|"Dump current state of Emacs into data file FILENAME.\n\ This function exists on systems that use HAVE_SHM."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|intoname
operator|)
name|Lisp_Object
name|intoname
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|extern
name|int
name|my_edata
decl_stmt|;
name|Lisp_Object
name|tem
decl_stmt|;
specifier|extern
name|void
name|malloc_warning
parameter_list|()
function_decl|;
name|CHECK_STRING
argument_list|(
name|intoname
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|intoname
operator|=
name|Fexpand_file_name
argument_list|(
name|intoname
argument_list|,
name|Qnil
argument_list|)
expr_stmt|;
name|tem
operator|=
name|Vpurify_flag
expr_stmt|;
name|Vpurify_flag
operator|=
name|Qnil
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
comment|/* Tell malloc where start of impure now is */
comment|/* Also arrange for warnings when nearly out of space.  */
ifndef|#
directive|ifndef
name|SYSTEM_MALLOC
name|malloc_init
argument_list|(
operator|&
name|my_edata
argument_list|,
name|malloc_warning
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|map_out_data
argument_list|(
name|XSTRING
argument_list|(
name|intoname
argument_list|)
operator|->
name|data
argument_list|)
expr_stmt|;
name|Vpurify_flag
operator|=
name|tem
expr_stmt|;
return|return
name|Qnil
return|;
block|}
end_block

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* not HAVE_SHM */
end_comment

begin_macro
name|DEFUN
argument_list|(
literal|"dump-emacs"
argument_list|,
argument|Fdump_emacs
argument_list|,
argument|Sdump_emacs
argument_list|,
literal|2
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
literal|"Dump current state of Emacs into executable file FILENAME.\n\ Take symbols from SYMFILE (presumably the file you executed to run Emacs)."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|intoname
operator|,
name|symname
operator|)
name|Lisp_Object
name|intoname
operator|,
name|symname
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|extern
name|int
name|my_edata
decl_stmt|;
name|Lisp_Object
name|tem
decl_stmt|;
specifier|extern
name|void
name|malloc_warning
parameter_list|()
function_decl|;
name|CHECK_STRING
argument_list|(
name|intoname
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|intoname
operator|=
name|Fexpand_file_name
argument_list|(
name|intoname
argument_list|,
name|Qnil
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|NULL
argument_list|(
name|symname
argument_list|)
condition|)
block|{
name|CHECK_STRING
argument_list|(
name|symname
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|XSTRING
argument_list|(
name|symname
argument_list|)
operator|->
name|size
condition|)
name|symname
operator|=
name|Fexpand_file_name
argument_list|(
name|symname
argument_list|,
name|Qnil
argument_list|)
expr_stmt|;
block|}
name|tem
operator|=
name|Vpurify_flag
expr_stmt|;
name|Vpurify_flag
operator|=
name|Qnil
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|VMS
name|mapout_data
argument_list|(
name|XSTRING
argument_list|(
name|intoname
argument_list|)
operator|->
name|data
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* Tell malloc where start of impure now is */
comment|/* Also arrange for warnings when nearly out of space.  */
ifndef|#
directive|ifndef
name|SYSTEM_MALLOC
name|malloc_init
argument_list|(
operator|&
name|my_edata
argument_list|,
name|malloc_warning
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|unexec
argument_list|(
name|XSTRING
argument_list|(
name|intoname
argument_list|)
operator|->
name|data
argument_list|,
operator|!
name|NULL
argument_list|(
name|symname
argument_list|)
condition|?
name|XSTRING
argument_list|(
name|symname
argument_list|)
operator|->
name|data
else|:
literal|0
argument_list|,
operator|&
name|my_edata
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* not VMS */
name|Vpurify_flag
operator|=
name|tem
expr_stmt|;
return|return
name|Qnil
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not HAVE_SHM */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not CANNOT_DUMP */
end_comment

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|VMS
end_ifdef

begin_define
define|#
directive|define
name|SEPCHAR
value|','
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|SEPCHAR
value|':'
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|Lisp_Object
name|decode_env_path
parameter_list|(
name|evarname
parameter_list|,
name|defalt
parameter_list|)
name|char
modifier|*
name|evarname
decl_stmt|,
decl|*
name|defalt
decl_stmt|;
end_function

begin_block
block|{
specifier|register
name|char
modifier|*
name|path
decl_stmt|,
modifier|*
name|p
decl_stmt|;
specifier|extern
name|char
modifier|*
name|index
parameter_list|()
function_decl|;
name|Lisp_Object
name|lpath
decl_stmt|;
name|path
operator|=
operator|(
name|char
operator|*
operator|)
name|egetenv
argument_list|(
name|evarname
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|path
condition|)
name|path
operator|=
name|defalt
expr_stmt|;
name|lpath
operator|=
name|Qnil
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|p
operator|=
name|index
argument_list|(
name|path
argument_list|,
name|SEPCHAR
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p
condition|)
name|p
operator|=
name|path
operator|+
name|strlen
argument_list|(
name|path
argument_list|)
expr_stmt|;
name|lpath
operator|=
name|Fcons
argument_list|(
name|p
operator|-
name|path
condition|?
name|make_string
argument_list|(
name|path
argument_list|,
name|p
operator|-
name|path
argument_list|)
else|:
name|Qnil
argument_list|,
name|lpath
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|p
condition|)
name|path
operator|=
name|p
operator|+
literal|1
expr_stmt|;
else|else
break|break;
block|}
return|return
name|Fnreverse
argument_list|(
name|lpath
argument_list|)
return|;
block|}
end_block

begin_macro
name|syms_of_emacs
argument_list|()
end_macro

begin_block
block|{
ifndef|#
directive|ifndef
name|CANNOT_DUMP
ifdef|#
directive|ifdef
name|HAVE_SHM
name|defsubr
argument_list|(
operator|&
name|Sdump_emacs_data
argument_list|)
expr_stmt|;
else|#
directive|else
name|defsubr
argument_list|(
operator|&
name|Sdump_emacs
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
comment|/* not CANNOT_DUMP */
name|defsubr
argument_list|(
operator|&
name|Skill_emacs
argument_list|)
expr_stmt|;
name|DEFVAR_LISP
argument_list|(
literal|"command-line-args"
argument_list|,
operator|&
name|Vcommand_line_args
argument_list|,
literal|"Args passed by shell to Emacs, as a list of strings."
argument_list|)
expr_stmt|;
name|DEFVAR_LISP
argument_list|(
literal|"system-type"
argument_list|,
operator|&
name|Vsystem_type
argument_list|,
literal|"Symbol indicating type of operating system you are using."
argument_list|)
expr_stmt|;
name|Vsystem_type
operator|=
name|intern
argument_list|(
name|SYSTEM_TYPE
argument_list|)
expr_stmt|;
name|DEFVAR_BOOL
argument_list|(
literal|"noninteractive"
argument_list|,
operator|&
name|noninteractive1
argument_list|,
literal|"Non-nil means Emacs is running without interactive terminal."
argument_list|)
expr_stmt|;
name|Vkill_emacs_hook
operator|=
name|Qnil
expr_stmt|;
name|DEFVAR_LISP
argument_list|(
literal|"kill-emacs-hook"
argument_list|,
operator|&
name|Vkill_emacs_hook
argument_list|,
literal|"Function called, if non-nil, whenever kill-emacs is called."
argument_list|)
expr_stmt|;
block|}
end_block

end_unit

