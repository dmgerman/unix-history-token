begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Asynchronous subprocess control for GNU Emacs.    Copyright (C) 1985, 1986, 1987, 1988, 1990 Free Software Foundation, Inc.  This file is part of GNU Emacs.  GNU Emacs is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 1, or (at your option) any later version.  GNU Emacs is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU Emacs; see the file COPYING.  If not, write to the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|subprocesses
end_ifdef

begin_comment
comment|/* The entire file is within this conditional */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<setjmp.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_comment
comment|/* some typedefs are used in sys/file.h */
end_comment

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SOCKETS
end_ifdef

begin_comment
comment|/* TCP connection support, if kernel can do it */
end_comment

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<netdb.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_SOCKETS */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|BSD
argument_list|)
operator|||
name|defined
argument_list|(
name|STRIDE
argument_list|)
end_if

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|O_NDELAY
argument_list|)
operator|&&
name|defined
argument_list|(
name|HAVE_PTYS
argument_list|)
end_if

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_PTYS and no O_NDELAY */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* BSD or STRIDE */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|USG
end_ifdef

begin_include
include|#
directive|include
file|<termio.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* USG */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|NEED_BSDTTY
end_ifdef

begin_include
include|#
directive|include
file|<sys/bsdtty.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HPUX
end_ifdef

begin_undef
undef|#
directive|undef
name|TIOCGPGRP
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|IRIS
end_ifdef

begin_include
include|#
directive|include
file|<sys/sysmacros.h>
end_include

begin_comment
comment|/* for "minor" */
end_comment

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_else
else|#
directive|else
end_else

begin_ifdef
ifdef|#
directive|ifdef
name|UNIPLUS
end_ifdef

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* not IRIS, not UNIPLUS */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_TIMEVAL
end_ifdef

begin_comment
comment|/* _h_BSDTYPES is checked because on ISC unix, socket.h includes    both time.h and sys/time.h, and the latter file is protected    from repeated inclusion.  */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|USG
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|AIX
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|_h_BSDTYPES
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|USG_SYS_TIME
argument_list|)
end_if

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* AIX or USG_SYS_TIME, or not USG */
end_comment

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* AIX or USG_SYS_TIME, or not USG */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_TIMEVAL */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not UNIPLUS */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not IRIS */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HPUX
argument_list|)
operator|&&
name|defined
argument_list|(
name|HAVE_PTYS
argument_list|)
end_if

begin_include
include|#
directive|include
file|<sys/ptyio.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|AIX
end_ifdef

begin_include
include|#
directive|include
file|<sys/pty.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* AIX */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|SYSV_PTYS
end_ifdef

begin_include
include|#
directive|include
file|<sys/tty.h>
end_include

begin_include
include|#
directive|include
file|<sys/pty.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_undef
undef|#
directive|undef
name|NULL
end_undef

begin_include
include|#
directive|include
file|"lisp.h"
end_include

begin_include
include|#
directive|include
file|"window.h"
end_include

begin_include
include|#
directive|include
file|"buffer.h"
end_include

begin_include
include|#
directive|include
file|"process.h"
end_include

begin_include
include|#
directive|include
file|"termhooks.h"
end_include

begin_include
include|#
directive|include
file|"termopts.h"
end_include

begin_include
include|#
directive|include
file|"commands.h"
end_include

begin_decl_stmt
name|Lisp_Object
name|Qrun
decl_stmt|,
name|Qstop
decl_stmt|,
name|Qsignal
decl_stmt|,
name|Qexit
decl_stmt|,
name|Qopen
decl_stmt|,
name|Qclosed
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* a process object is a network connection when its childp field is neither    Qt nor Qnil but is instead a string (name of foreign host we    are connected to + name of port we are connected to) */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SOCKETS
end_ifdef

begin_define
define|#
directive|define
name|NETCONN_P
parameter_list|(
name|p
parameter_list|)
value|(XGCTYPE (XPROCESS (p)->childp) == Lisp_String)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|NETCONN_P
parameter_list|(
name|p
parameter_list|)
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_SOCKETS */
end_comment

begin_comment
comment|/* Define SIGCHLD as an alias for SIGCLD.  There are many conditionals    testing SIGCHLD.  */
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|SIGCHLD
argument_list|)
operator|&&
name|defined
argument_list|(
name|SIGCLD
argument_list|)
end_if

begin_define
define|#
directive|define
name|SIGCHLD
value|SIGCLD
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SIGCLD */
end_comment

begin_comment
comment|/* Define the structure that the wait system call stores.    On many systems, there is a structure defined for this.    But on vanilla-ish USG systems there is not.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|WAITTYPE
end_ifndef

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|BSD
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|UNIPLUS
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|STRIDE
argument_list|)
operator|&&
operator|!
operator|(
name|defined
argument_list|(
name|HPUX
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|NOMULTIPLEJOBS
argument_list|)
operator|)
operator|&&
operator|!
name|defined
argument_list|(
name|HAVE_WAIT_HEADER
argument_list|)
end_if

begin_define
define|#
directive|define
name|WAITTYPE
value|int
end_define

begin_define
define|#
directive|define
name|WIFSTOPPED
parameter_list|(
name|w
parameter_list|)
value|((w&0377) == 0177)
end_define

begin_define
define|#
directive|define
name|WIFSIGNALED
parameter_list|(
name|w
parameter_list|)
value|((w&0377) != 0177&& (w&~0377) == 0)
end_define

begin_define
define|#
directive|define
name|WIFEXITED
parameter_list|(
name|w
parameter_list|)
value|((w&0377) == 0)
end_define

begin_define
define|#
directive|define
name|WRETCODE
parameter_list|(
name|w
parameter_list|)
value|(w>> 8)
end_define

begin_define
define|#
directive|define
name|WSTOPSIG
parameter_list|(
name|w
parameter_list|)
value|(w>> 8)
end_define

begin_define
define|#
directive|define
name|WTERMSIG
parameter_list|(
name|w
parameter_list|)
value|(w& 0377)
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|WCOREDUMP
end_ifndef

begin_define
define|#
directive|define
name|WCOREDUMP
parameter_list|(
name|w
parameter_list|)
value|((w&0200) != 0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_else
else|#
directive|else
end_else

begin_ifdef
ifdef|#
directive|ifdef
name|BSD4_1
end_ifdef

begin_include
include|#
directive|include
file|<wait.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<sys/wait.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not BSD 4.1 */
end_comment

begin_define
define|#
directive|define
name|WAITTYPE
value|union wait
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|WRETCODE
end_ifndef

begin_define
define|#
directive|define
name|WRETCODE
parameter_list|(
name|w
parameter_list|)
value|w.w_retcode
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|WCOREDUMP
end_ifndef

begin_define
define|#
directive|define
name|WCOREDUMP
parameter_list|(
name|w
parameter_list|)
value|w.w_coredump
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HPUX
end_ifdef

begin_comment
comment|/* HPUX version 7 has broken definitions of these.  */
end_comment

begin_undef
undef|#
directive|undef
name|WTERMSIG
end_undef

begin_undef
undef|#
directive|undef
name|WSTOPSIG
end_undef

begin_undef
undef|#
directive|undef
name|WIFSTOPPED
end_undef

begin_undef
undef|#
directive|undef
name|WIFSIGNALED
end_undef

begin_undef
undef|#
directive|undef
name|WIFEXITED
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|WTERMSIG
end_ifndef

begin_define
define|#
directive|define
name|WTERMSIG
parameter_list|(
name|w
parameter_list|)
value|w.w_termsig
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|WSTOPSIG
end_ifndef

begin_define
define|#
directive|define
name|WSTOPSIG
parameter_list|(
name|w
parameter_list|)
value|w.w_stopsig
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|WIFSTOPPED
end_ifndef

begin_define
define|#
directive|define
name|WIFSTOPPED
parameter_list|(
name|w
parameter_list|)
value|(WTERMSIG (w) == 0177)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|WIFSIGNALED
end_ifndef

begin_define
define|#
directive|define
name|WIFSIGNALED
parameter_list|(
name|w
parameter_list|)
value|(WTERMSIG (w) != 0177&& (WSTOPSIG (w)) == 0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|WIFEXITED
end_ifndef

begin_define
define|#
directive|define
name|WIFEXITED
parameter_list|(
name|w
parameter_list|)
value|(WTERMSIG (w) == 0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* BSD or UNIPLUS or STRIDE */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* no WAITTYPE */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|BSD4_4
end_ifndef

begin_extern
extern|extern errno;
end_extern

begin_extern
extern|extern sys_nerr;
end_extern

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|sys_errlist
index|[]
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|BSD4_1
end_ifndef

begin_ifndef
ifndef|#
directive|ifndef
name|BSD4_4
end_ifndef

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|sys_siglist
index|[]
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_else
else|#
directive|else
end_else

begin_decl_stmt
name|char
modifier|*
name|sys_siglist
index|[]
init|=
block|{
literal|"bum signal!!"
block|,
literal|"hangup"
block|,
literal|"interrupt"
block|,
literal|"quit"
block|,
literal|"illegal instruction"
block|,
literal|"trace trap"
block|,
literal|"iot instruction"
block|,
literal|"emt instruction"
block|,
literal|"floating point exception"
block|,
literal|"kill"
block|,
literal|"bus error"
block|,
literal|"segmentation violation"
block|,
literal|"bad argument to system call"
block|,
literal|"write on a pipe with no one to read it"
block|,
literal|"alarm clock"
block|,
literal|"software termination signal from kill"
block|,
literal|"status signal"
block|,
literal|"sendable stop signal not from tty"
block|,
literal|"stop signal from tty"
block|,
literal|"continue a stopped process"
block|,
literal|"child status has changed"
block|,
literal|"background read attempted from control tty"
block|,
literal|"background write attempted from control tty"
block|,
literal|"input record available at control tty"
block|,
literal|"exceeded CPU time limit"
block|,
literal|"exceeded file size limit"
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|vipc
end_ifdef

begin_include
include|#
directive|include
file|"vipc.h"
end_include

begin_decl_stmt
specifier|extern
name|int
name|comm_server
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|net_listen_address
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* vipc */
end_comment

begin_comment
comment|/* t means use pty, nil means use a pipe,    maybe other values to come.  */
end_comment

begin_decl_stmt
name|Lisp_Object
name|Vprocess_connection_type
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|SKTPAIR
end_ifdef

begin_ifndef
ifndef|#
directive|ifndef
name|HAVE_SOCKETS
end_ifndef

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SKTPAIR */
end_comment

begin_comment
comment|/* Number of events of change of status of a process.  */
end_comment

begin_decl_stmt
name|int
name|process_tick
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of events for which the user or sentinel has been notified.  */
end_comment

begin_decl_stmt
name|int
name|update_tick
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|delete_exited_processes
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|FD_SET
end_ifdef

begin_comment
comment|/* We could get this from param.h, but better not to depend on finding that.    And better not to risk that it might define other symbols used in this    file.  */
end_comment

begin_define
define|#
directive|define
name|MAXDESC
value|64
end_define

begin_define
define|#
directive|define
name|SELECT_TYPE
value|fd_set
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* no FD_SET */
end_comment

begin_define
define|#
directive|define
name|MAXDESC
value|32
end_define

begin_define
define|#
directive|define
name|SELECT_TYPE
value|int
end_define

begin_comment
comment|/* Define the macros to access a single-int bitmap of descriptors.  */
end_comment

begin_define
define|#
directive|define
name|FD_SET
parameter_list|(
name|n
parameter_list|,
name|p
parameter_list|)
value|(*(p) |= (1<< (n)))
end_define

begin_define
define|#
directive|define
name|FD_CLR
parameter_list|(
name|n
parameter_list|,
name|p
parameter_list|)
value|(*(p)&= ~(1<< (n)))
end_define

begin_define
define|#
directive|define
name|FD_ISSET
parameter_list|(
name|n
parameter_list|,
name|p
parameter_list|)
value|(*(p)& (1<< (n)))
end_define

begin_define
define|#
directive|define
name|FD_ZERO
parameter_list|(
name|p
parameter_list|)
value|(*(p) = 0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* no FD_SET */
end_comment

begin_comment
comment|/* Mask of bits indicating the descriptors that we wait for input on */
end_comment

begin_decl_stmt
name|SELECT_TYPE
name|input_wait_mask
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Indexed by descriptor, gives the process (if any) for that descriptor */
end_comment

begin_decl_stmt
name|Lisp_Object
name|chan_process
index|[
name|MAXDESC
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Alist of elements (NAME . PROCESS) */
end_comment

begin_decl_stmt
name|Lisp_Object
name|Vprocess_alist
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Lisp_Object
name|Qprocessp
decl_stmt|;
end_decl_stmt

begin_function_decl
name|Lisp_Object
name|get_process
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* Buffered-ahead input char from process, indexed by channel.    -1 means empty (no char is buffered).    Used on sys V where the only way to tell if there is any    output from the process is to read at least one char.    Always -1 on systems that support FIONREAD.  */
end_comment

begin_decl_stmt
name|int
name|proc_buffered_char
index|[
name|MAXDESC
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* These variables hold the filter about to be run, and its args,    between read_process_output and run_filter.    Also used in exec_sentinel for sentinels.  */
end_comment

begin_decl_stmt
name|Lisp_Object
name|this_filter
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Lisp_Object
name|filter_process
decl_stmt|,
name|filter_string
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Compute the Lisp form of the process status, p->status,    from the numeric status that was returned by `wait'.  */
end_comment

begin_macro
name|update_status
argument_list|(
argument|p
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|Lisp_Process
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_block
block|{
union|union
block|{
name|int
name|i
decl_stmt|;
name|WAITTYPE
name|wt
decl_stmt|;
block|}
name|u
union|;
name|u
operator|.
name|i
operator|=
name|XFASTINT
argument_list|(
name|p
operator|->
name|raw_status_low
argument_list|)
operator|+
operator|(
name|XFASTINT
argument_list|(
name|p
operator|->
name|raw_status_high
argument_list|)
operator|<<
literal|16
operator|)
expr_stmt|;
name|p
operator|->
name|status
operator|=
name|status_convert
argument_list|(
name|u
operator|.
name|wt
argument_list|)
expr_stmt|;
name|p
operator|->
name|raw_status_low
operator|=
name|Qnil
expr_stmt|;
name|p
operator|->
name|raw_status_high
operator|=
name|Qnil
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Convert a process status word in Unix format    to the list that we use internally.  */
end_comment

begin_function
name|Lisp_Object
name|status_convert
parameter_list|(
name|w
parameter_list|)
name|WAITTYPE
name|w
decl_stmt|;
block|{
if|if
condition|(
name|WIFSTOPPED
argument_list|(
name|w
argument_list|)
condition|)
return|return
name|Fcons
argument_list|(
name|Qstop
argument_list|,
name|Fcons
argument_list|(
name|make_number
argument_list|(
name|WSTOPSIG
argument_list|(
name|w
argument_list|)
argument_list|)
argument_list|,
name|Qnil
argument_list|)
argument_list|)
return|;
elseif|else
if|if
condition|(
name|WIFEXITED
argument_list|(
name|w
argument_list|)
condition|)
return|return
name|Fcons
argument_list|(
name|Qexit
argument_list|,
name|Fcons
argument_list|(
name|make_number
argument_list|(
name|WRETCODE
argument_list|(
name|w
argument_list|)
argument_list|)
argument_list|,
name|WCOREDUMP
argument_list|(
name|w
argument_list|)
condition|?
name|Qt
else|:
name|Qnil
argument_list|)
argument_list|)
return|;
elseif|else
if|if
condition|(
name|WIFSIGNALED
argument_list|(
name|w
argument_list|)
condition|)
return|return
name|Fcons
argument_list|(
name|Qsignal
argument_list|,
name|Fcons
argument_list|(
name|make_number
argument_list|(
name|WTERMSIG
argument_list|(
name|w
argument_list|)
argument_list|)
argument_list|,
name|WCOREDUMP
argument_list|(
name|w
argument_list|)
condition|?
name|Qt
else|:
name|Qnil
argument_list|)
argument_list|)
return|;
else|else
return|return
name|Qrun
return|;
block|}
end_function

begin_comment
comment|/* Given a status-list, extract the three pieces of information    and store them individually through the three pointers.  */
end_comment

begin_function
name|void
name|decode_status
parameter_list|(
name|l
parameter_list|,
name|symbol
parameter_list|,
name|code
parameter_list|,
name|coredump
parameter_list|)
name|Lisp_Object
name|l
decl_stmt|;
name|Lisp_Object
modifier|*
name|symbol
decl_stmt|;
name|int
modifier|*
name|code
decl_stmt|;
name|int
modifier|*
name|coredump
decl_stmt|;
block|{
name|Lisp_Object
name|tem
decl_stmt|;
if|if
condition|(
name|XTYPE
argument_list|(
name|l
argument_list|)
operator|==
name|Lisp_Symbol
condition|)
block|{
operator|*
name|symbol
operator|=
name|l
expr_stmt|;
operator|*
name|code
operator|=
literal|0
expr_stmt|;
operator|*
name|coredump
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
operator|*
name|symbol
operator|=
name|XCONS
argument_list|(
name|l
argument_list|)
operator|->
name|car
expr_stmt|;
name|tem
operator|=
name|XCONS
argument_list|(
name|l
argument_list|)
operator|->
name|cdr
expr_stmt|;
operator|*
name|code
operator|=
name|XFASTINT
argument_list|(
name|XCONS
argument_list|(
name|tem
argument_list|)
operator|->
name|car
argument_list|)
expr_stmt|;
name|tem
operator|=
name|XFASTINT
argument_list|(
name|XCONS
argument_list|(
name|tem
argument_list|)
operator|->
name|cdr
argument_list|)
expr_stmt|;
operator|*
name|coredump
operator|=
operator|!
name|NULL
argument_list|(
name|tem
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Return a string describing a process status list.  */
end_comment

begin_function
name|Lisp_Object
name|status_message
parameter_list|(
name|status
parameter_list|)
name|Lisp_Object
name|status
decl_stmt|;
block|{
name|Lisp_Object
name|symbol
decl_stmt|;
name|int
name|code
decl_stmt|,
name|coredump
decl_stmt|;
name|Lisp_Object
name|string
decl_stmt|,
name|string2
decl_stmt|;
name|decode_status
argument_list|(
name|status
argument_list|,
operator|&
name|symbol
argument_list|,
operator|&
name|code
argument_list|,
operator|&
name|coredump
argument_list|)
expr_stmt|;
if|if
condition|(
name|EQ
argument_list|(
name|symbol
argument_list|,
name|Qsignal
argument_list|)
operator|||
name|EQ
argument_list|(
name|symbol
argument_list|,
name|Qstop
argument_list|)
condition|)
block|{
name|string
operator|=
name|build_string
argument_list|(
name|code
operator|<
name|NSIG
condition|?
name|sys_siglist
index|[
name|code
index|]
else|:
literal|"unknown"
argument_list|)
expr_stmt|;
name|string2
operator|=
name|build_string
argument_list|(
name|coredump
condition|?
literal|" (core dumped)\n"
else|:
literal|"\n"
argument_list|)
expr_stmt|;
name|XSTRING
argument_list|(
name|string
argument_list|)
operator|->
name|data
index|[
literal|0
index|]
operator|=
name|DOWNCASE
argument_list|(
name|XSTRING
argument_list|(
name|string
argument_list|)
operator|->
name|data
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
return|return
name|concat2
argument_list|(
name|string
argument_list|,
name|string2
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|EQ
argument_list|(
name|symbol
argument_list|,
name|Qexit
argument_list|)
condition|)
block|{
if|if
condition|(
name|code
operator|==
literal|0
condition|)
return|return
name|build_string
argument_list|(
literal|"finished\n"
argument_list|)
return|;
name|string
operator|=
name|Fint_to_string
argument_list|(
name|make_number
argument_list|(
name|code
argument_list|)
argument_list|)
expr_stmt|;
name|string2
operator|=
name|build_string
argument_list|(
name|coredump
condition|?
literal|" (core dumped)\n"
else|:
literal|"\n"
argument_list|)
expr_stmt|;
return|return
name|concat2
argument_list|(
name|build_string
argument_list|(
literal|"exited abnormally with code "
argument_list|)
argument_list|,
name|concat2
argument_list|(
name|string
argument_list|,
name|string2
argument_list|)
argument_list|)
return|;
block|}
else|else
return|return
name|Fcopy_sequence
argument_list|(
name|Fsymbol_name
argument_list|(
name|symbol
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_PTYS
end_ifdef

begin_comment
comment|/* Open an available pty, returning a file descriptor.    Return -1 on failure.    The file name of the terminal corresponding to the pty    is left in the variable pty_name.  */
end_comment

begin_decl_stmt
name|char
name|pty_name
index|[
literal|24
index|]
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|allocate_pty
parameter_list|()
block|{
name|struct
name|stat
name|stb
decl_stmt|;
specifier|register
name|c
operator|,
name|i
expr_stmt|;
name|int
name|fd
decl_stmt|;
ifdef|#
directive|ifdef
name|PTY_ITERATION
name|PTY_ITERATION
else|#
directive|else
for|for
control|(
name|c
operator|=
name|FIRST_PTY_LETTER
init|;
name|c
operator|<=
literal|'z'
condition|;
name|c
operator|++
control|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
endif|#
directive|endif
block|{
ifdef|#
directive|ifdef
name|PTY_NAME_SPRINTF
name|PTY_NAME_SPRINTF
else|#
directive|else
ifdef|#
directive|ifdef
name|HPUX
name|sprintf
argument_list|(
name|pty_name
argument_list|,
literal|"/dev/ptym/pty%c%x"
argument_list|,
name|c
argument_list|,
name|i
argument_list|)
decl_stmt|;
else|#
directive|else
ifdef|#
directive|ifdef
name|RTU
name|sprintf
argument_list|(
name|pty_name
argument_list|,
literal|"/dev/pty%x"
argument_list|,
name|i
argument_list|)
expr_stmt|;
else|#
directive|else
name|sprintf
argument_list|(
name|pty_name
argument_list|,
literal|"/dev/pty%c%x"
argument_list|,
name|c
argument_list|,
name|i
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* not RTU */
endif|#
directive|endif
comment|/* not HPUX */
endif|#
directive|endif
comment|/* no PTY_NAME_SPRINTF */
ifndef|#
directive|ifndef
name|IRIS
if|if
condition|(
name|stat
argument_list|(
name|pty_name
argument_list|,
operator|&
name|stb
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
ifdef|#
directive|ifdef
name|O_NONBLOCK
name|fd
operator|=
name|open
argument_list|(
name|pty_name
argument_list|,
name|O_RDWR
operator||
name|O_NONBLOCK
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|#
directive|else
name|fd
operator|=
name|open
argument_list|(
name|pty_name
argument_list|,
name|O_RDWR
operator||
name|O_NDELAY
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
else|#
directive|else
comment|/* Unusual IRIS code */
name|fd
operator|=
name|open
argument_list|(
literal|"/dev/ptc"
argument_list|,
name|O_RDWR
operator||
name|O_NDELAY
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|fstat
argument_list|(
name|fd
argument_list|,
operator|&
name|stb
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
endif|#
directive|endif
comment|/* IRIS */
if|if
condition|(
name|fd
operator|>=
literal|0
condition|)
block|{
comment|/* check to make certain that both sides are available 	       this avoids a nasty yet stupid bug in rlogins */
ifdef|#
directive|ifdef
name|PTY_TTY_NAME_SPRINTF
name|PTY_TTY_NAME_SPRINTF
else|#
directive|else
comment|/* In version 19, make these special cases use the macro above.  */
ifdef|#
directive|ifdef
name|HPUX
name|sprintf
argument_list|(
name|pty_name
argument_list|,
literal|"/dev/pty/tty%c%x"
argument_list|,
name|c
argument_list|,
name|i
argument_list|)
decl_stmt|;
else|#
directive|else
ifdef|#
directive|ifdef
name|RTU
name|sprintf
argument_list|(
name|pty_name
argument_list|,
literal|"/dev/ttyp%x"
argument_list|,
name|i
argument_list|)
expr_stmt|;
else|#
directive|else
ifdef|#
directive|ifdef
name|IRIS
name|sprintf
argument_list|(
name|pty_name
argument_list|,
literal|"/dev/ttyq%d"
argument_list|,
name|minor
argument_list|(
name|stb
operator|.
name|st_rdev
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|sprintf
argument_list|(
name|pty_name
argument_list|,
literal|"/dev/tty%c%x"
argument_list|,
name|c
argument_list|,
name|i
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* not IRIS */
endif|#
directive|endif
comment|/* not RTU */
endif|#
directive|endif
comment|/* not HPUX */
endif|#
directive|endif
comment|/* no PTY_TTY_NAME_SPRINTF */
ifndef|#
directive|ifndef
name|UNIPLUS
if|if
condition|(
name|access
argument_list|(
name|pty_name
argument_list|,
literal|6
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|IRIS
continue|continue;
else|#
directive|else
return|return
operator|-
literal|1
return|;
endif|#
directive|endif
comment|/* IRIS */
block|}
endif|#
directive|endif
comment|/* not UNIPLUS */
name|setup_pty
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
name|fd
return|;
block|}
block|}
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_PTYS */
end_comment

begin_escape
end_escape

begin_function
name|Lisp_Object
name|make_process
parameter_list|(
name|name
parameter_list|)
name|Lisp_Object
name|name
decl_stmt|;
block|{
specifier|register
name|Lisp_Object
name|val
decl_stmt|,
name|tem
decl_stmt|,
name|name1
decl_stmt|;
specifier|register
name|struct
name|Lisp_Process
modifier|*
name|p
decl_stmt|;
name|char
name|suffix
index|[
literal|10
index|]
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
comment|/* size of process structure includes the vector header,      so deduct for that.  But struct Lisp_Vector includes the first      element, thus deducts too much, so add it back.  */
name|val
operator|=
name|Fmake_vector
argument_list|(
name|make_number
argument_list|(
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|Lisp_Process
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|Lisp_Vector
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|Lisp_Object
argument_list|)
operator|)
operator|/
sizeof|sizeof
argument_list|(
name|Lisp_Object
argument_list|)
argument_list|)
argument_list|,
name|Qnil
argument_list|)
expr_stmt|;
name|XSETTYPE
argument_list|(
name|val
argument_list|,
name|Lisp_Process
argument_list|)
expr_stmt|;
name|p
operator|=
name|XPROCESS
argument_list|(
name|val
argument_list|)
expr_stmt|;
name|XFASTINT
argument_list|(
name|p
operator|->
name|infd
argument_list|)
operator|=
literal|0
expr_stmt|;
name|XFASTINT
argument_list|(
name|p
operator|->
name|outfd
argument_list|)
operator|=
literal|0
expr_stmt|;
name|XFASTINT
argument_list|(
name|p
operator|->
name|pid
argument_list|)
operator|=
literal|0
expr_stmt|;
name|XFASTINT
argument_list|(
name|p
operator|->
name|tick
argument_list|)
operator|=
literal|0
expr_stmt|;
name|XFASTINT
argument_list|(
name|p
operator|->
name|update_tick
argument_list|)
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|raw_status_low
operator|=
name|Qnil
expr_stmt|;
name|p
operator|->
name|raw_status_high
operator|=
name|Qnil
expr_stmt|;
name|p
operator|->
name|status
operator|=
name|Qrun
expr_stmt|;
name|p
operator|->
name|mark
operator|=
name|Fmake_marker
argument_list|()
expr_stmt|;
comment|/* If name is already in use, modify it until it is unused.  */
name|name1
operator|=
name|name
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
condition|;
name|i
operator|++
control|)
block|{
name|tem
operator|=
name|Fget_process
argument_list|(
name|name1
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
argument_list|(
name|tem
argument_list|)
condition|)
break|break;
name|sprintf
argument_list|(
name|suffix
argument_list|,
literal|"<%d>"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|name1
operator|=
name|concat2
argument_list|(
name|name
argument_list|,
name|build_string
argument_list|(
name|suffix
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|name
operator|=
name|name1
expr_stmt|;
name|p
operator|->
name|name
operator|=
name|name
expr_stmt|;
name|Vprocess_alist
operator|=
name|Fcons
argument_list|(
name|Fcons
argument_list|(
name|name
argument_list|,
name|val
argument_list|)
argument_list|,
name|Vprocess_alist
argument_list|)
expr_stmt|;
return|return
name|val
return|;
block|}
end_function

begin_expr_stmt
name|remove_process
argument_list|(
name|proc
argument_list|)
specifier|register
name|Lisp_Object
name|proc
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|Lisp_Object
name|pair
decl_stmt|;
name|pair
operator|=
name|Frassq
argument_list|(
name|proc
argument_list|,
name|Vprocess_alist
argument_list|)
expr_stmt|;
name|Vprocess_alist
operator|=
name|Fdelq
argument_list|(
name|pair
argument_list|,
name|Vprocess_alist
argument_list|)
expr_stmt|;
name|Fset_marker
argument_list|(
name|XPROCESS
argument_list|(
name|proc
argument_list|)
operator|->
name|mark
argument_list|,
name|Qnil
argument_list|,
name|Qnil
argument_list|)
expr_stmt|;
name|deactivate_process
argument_list|(
name|proc
argument_list|)
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_macro
name|DEFUN
argument_list|(
literal|"processp"
argument_list|,
argument|Fprocessp
argument_list|,
argument|Sprocessp
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|"Return t if OBJECT is a process."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|obj
operator|)
name|Lisp_Object
name|obj
expr_stmt|;
end_expr_stmt

begin_block
block|{
return|return
name|XTYPE
argument_list|(
name|obj
argument_list|)
operator|==
name|Lisp_Process
condition|?
name|Qt
else|:
name|Qnil
return|;
block|}
end_block

begin_expr_stmt
name|DEFUN
argument_list|(
literal|"get-process"
argument_list|,
name|Fget_process
argument_list|,
name|Sget_process
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|"Return the process named NAME, or nil if there is none."
argument_list|)
argument_list|(
name|name
argument_list|)
specifier|register
name|Lisp_Object
name|name
expr_stmt|;
end_expr_stmt

begin_block
block|{
if|if
condition|(
name|XTYPE
argument_list|(
name|name
argument_list|)
operator|==
name|Lisp_Process
condition|)
return|return
name|name
return|;
name|CHECK_STRING
argument_list|(
name|name
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|Fcdr
argument_list|(
name|Fassoc
argument_list|(
name|name
argument_list|,
name|Vprocess_alist
argument_list|)
argument_list|)
return|;
block|}
end_block

begin_expr_stmt
name|DEFUN
argument_list|(
literal|"get-buffer-process"
argument_list|,
name|Fget_buffer_process
argument_list|,
name|Sget_buffer_process
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|"Return the (or, a) process associated with BUFFER.\n\ BUFFER may be a buffer or the name of one."
argument_list|)
argument_list|(
name|name
argument_list|)
specifier|register
name|Lisp_Object
name|name
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|Lisp_Object
name|buf
decl_stmt|,
name|tail
decl_stmt|,
name|proc
decl_stmt|;
if|if
condition|(
name|NULL
argument_list|(
name|name
argument_list|)
condition|)
return|return
name|Qnil
return|;
name|buf
operator|=
name|Fget_buffer
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
argument_list|(
name|buf
argument_list|)
condition|)
return|return
name|Qnil
return|;
for|for
control|(
name|tail
operator|=
name|Vprocess_alist
init|;
operator|!
name|NULL
argument_list|(
name|tail
argument_list|)
condition|;
name|tail
operator|=
name|Fcdr
argument_list|(
name|tail
argument_list|)
control|)
block|{
name|proc
operator|=
name|Fcdr
argument_list|(
name|Fcar
argument_list|(
name|tail
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|XTYPE
argument_list|(
name|proc
argument_list|)
operator|==
name|Lisp_Process
operator|&&
name|EQ
argument_list|(
name|XPROCESS
argument_list|(
name|proc
argument_list|)
operator|->
name|buffer
argument_list|,
name|buf
argument_list|)
condition|)
return|return
name|proc
return|;
block|}
return|return
name|Qnil
return|;
block|}
end_block

begin_comment
comment|/* This is how commands for the user decode process arguments */
end_comment

begin_function
name|Lisp_Object
name|get_process
parameter_list|(
name|name
parameter_list|)
specifier|register
name|Lisp_Object
name|name
decl_stmt|;
block|{
specifier|register
name|Lisp_Object
name|proc
decl_stmt|;
if|if
condition|(
name|NULL
argument_list|(
name|name
argument_list|)
condition|)
name|proc
operator|=
name|Fget_buffer_process
argument_list|(
name|Fcurrent_buffer
argument_list|()
argument_list|)
expr_stmt|;
else|else
block|{
name|proc
operator|=
name|Fget_process
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
argument_list|(
name|proc
argument_list|)
condition|)
name|proc
operator|=
name|Fget_buffer_process
argument_list|(
name|Fget_buffer
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|NULL
argument_list|(
name|proc
argument_list|)
condition|)
return|return
name|proc
return|;
if|if
condition|(
name|NULL
argument_list|(
name|name
argument_list|)
condition|)
name|error
argument_list|(
literal|"Current buffer has no process"
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"Process %s does not exist"
argument_list|,
name|XSTRING
argument_list|(
name|name
argument_list|)
operator|->
name|data
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
end_function

begin_expr_stmt
name|DEFUN
argument_list|(
literal|"delete-process"
argument_list|,
name|Fdelete_process
argument_list|,
name|Sdelete_process
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|"Delete PROCESS: kill it and forget about it immediately.\n\ PROCESS may be a process or the name of one, or a buffer name."
argument_list|)
argument_list|(
name|proc
argument_list|)
specifier|register
name|Lisp_Object
name|proc
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|proc
operator|=
name|get_process
argument_list|(
name|proc
argument_list|)
expr_stmt|;
name|XPROCESS
argument_list|(
name|proc
argument_list|)
operator|->
name|raw_status_low
operator|=
name|Qnil
expr_stmt|;
name|XPROCESS
argument_list|(
name|proc
argument_list|)
operator|->
name|raw_status_high
operator|=
name|Qnil
expr_stmt|;
if|if
condition|(
name|NETCONN_P
argument_list|(
name|proc
argument_list|)
condition|)
block|{
name|XPROCESS
argument_list|(
name|proc
argument_list|)
operator|->
name|status
operator|=
name|Fcons
argument_list|(
name|Qexit
argument_list|,
name|Fcons
argument_list|(
name|make_number
argument_list|(
literal|0
argument_list|)
argument_list|,
name|Qnil
argument_list|)
argument_list|)
expr_stmt|;
name|XSETINT
argument_list|(
name|XPROCESS
argument_list|(
name|proc
argument_list|)
operator|->
name|tick
argument_list|,
operator|++
name|process_tick
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|XFASTINT
argument_list|(
name|XPROCESS
argument_list|(
name|proc
argument_list|)
operator|->
name|infd
argument_list|)
condition|)
block|{
name|Fkill_process
argument_list|(
name|proc
argument_list|,
name|Qnil
argument_list|)
expr_stmt|;
comment|/* Do this now, since remove_process will make sigchld_handler do nothing.  */
name|XPROCESS
argument_list|(
name|proc
argument_list|)
operator|->
name|status
operator|=
name|Fcons
argument_list|(
name|Qsignal
argument_list|,
name|Fcons
argument_list|(
name|make_number
argument_list|(
name|SIGKILL
argument_list|)
argument_list|,
name|Qnil
argument_list|)
argument_list|)
expr_stmt|;
name|XSETINT
argument_list|(
name|XPROCESS
argument_list|(
name|proc
argument_list|)
operator|->
name|tick
argument_list|,
operator|++
name|process_tick
argument_list|)
expr_stmt|;
name|status_notify
argument_list|()
expr_stmt|;
block|}
name|remove_process
argument_list|(
name|proc
argument_list|)
expr_stmt|;
return|return
name|Qnil
return|;
block|}
end_block

begin_escape
end_escape

begin_expr_stmt
name|DEFUN
argument_list|(
literal|"process-status"
argument_list|,
name|Fprocess_status
argument_list|,
name|Sprocess_status
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|"Return the status of PROCESS: a symbol, one of these:\n\ run  -- for a process that is running.\n\ stop -- for a process stopped but continuable.\n\ exit -- for a process that has exited.\n\ signal -- for a process that has got a fatal signal.\n\ open -- for a network stream connection that is open.\n\ closed -- for a network stream connection that is closed.\n\ nil -- if arg is a process name and no such process exists."
argument_list|)
comment|/* command -- for a command channel opened to Emacs by another process.\n\    external -- for an i/o channel opened to Emacs by another process.\n\  */
argument_list|(
name|proc
argument_list|)
specifier|register
name|Lisp_Object
name|proc
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|Lisp_Process
modifier|*
name|p
decl_stmt|;
name|proc
operator|=
name|Fget_process
argument_list|(
name|proc
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
argument_list|(
name|proc
argument_list|)
condition|)
return|return
name|proc
return|;
name|p
operator|=
name|XPROCESS
argument_list|(
name|proc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|NULL
argument_list|(
name|p
operator|->
name|raw_status_low
argument_list|)
condition|)
name|update_status
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|XTYPE
argument_list|(
name|p
operator|->
name|status
argument_list|)
operator|==
name|Lisp_Cons
condition|)
return|return
name|XCONS
argument_list|(
name|p
operator|->
name|status
argument_list|)
operator|->
name|car
return|;
return|return
name|p
operator|->
name|status
return|;
block|}
end_block

begin_expr_stmt
name|DEFUN
argument_list|(
literal|"process-exit-status"
argument_list|,
name|Fprocess_exit_status
argument_list|,
name|Sprocess_exit_status
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|"Return the exit status of PROCESS or the signal number that killed it.\n\ If PROCESS has not yet exited or died, return 0."
argument_list|)
argument_list|(
name|proc
argument_list|)
specifier|register
name|Lisp_Object
name|proc
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|CHECK_PROCESS
argument_list|(
name|proc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|NULL
argument_list|(
name|XPROCESS
argument_list|(
name|proc
argument_list|)
operator|->
name|raw_status_low
argument_list|)
condition|)
name|update_status
argument_list|(
name|XPROCESS
argument_list|(
name|proc
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|XTYPE
argument_list|(
name|XPROCESS
argument_list|(
name|proc
argument_list|)
operator|->
name|status
argument_list|)
operator|==
name|Lisp_Cons
condition|)
return|return
name|XCONS
argument_list|(
name|XCONS
argument_list|(
name|XPROCESS
argument_list|(
name|proc
argument_list|)
operator|->
name|status
argument_list|)
operator|->
name|cdr
argument_list|)
operator|->
name|car
return|;
return|return
name|make_number
argument_list|(
literal|0
argument_list|)
return|;
block|}
end_block

begin_expr_stmt
name|DEFUN
argument_list|(
literal|"process-id"
argument_list|,
name|Fprocess_id
argument_list|,
name|Sprocess_id
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|"Return the process id of PROCESS.\n\ This is the pid of the Unix process which PROCESS uses or talks to.\n\ For a network connection, this value is nil."
argument_list|)
argument_list|(
name|proc
argument_list|)
specifier|register
name|Lisp_Object
name|proc
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|CHECK_PROCESS
argument_list|(
name|proc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|XPROCESS
argument_list|(
name|proc
argument_list|)
operator|->
name|pid
return|;
block|}
end_block

begin_expr_stmt
name|DEFUN
argument_list|(
literal|"process-name"
argument_list|,
name|Fprocess_name
argument_list|,
name|Sprocess_name
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|"Return the name of PROCESS, as a string.\n\ This is the name of the program invoked in PROCESS,\n\ possibly modified to make it unique among process names."
argument_list|)
argument_list|(
name|proc
argument_list|)
specifier|register
name|Lisp_Object
name|proc
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|CHECK_PROCESS
argument_list|(
name|proc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|XPROCESS
argument_list|(
name|proc
argument_list|)
operator|->
name|name
return|;
block|}
end_block

begin_expr_stmt
name|DEFUN
argument_list|(
literal|"process-command"
argument_list|,
name|Fprocess_command
argument_list|,
name|Sprocess_command
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|"Return the command that was executed to start PROCESS.\n\ This is a list of strings, the first string being the program executed\n\ and the rest of the strings being the arguments given to it.\n\ For a non-child channel, this is nil."
argument_list|)
argument_list|(
name|proc
argument_list|)
specifier|register
name|Lisp_Object
name|proc
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|CHECK_PROCESS
argument_list|(
name|proc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|XPROCESS
argument_list|(
name|proc
argument_list|)
operator|->
name|command
return|;
block|}
end_block

begin_expr_stmt
name|DEFUN
argument_list|(
literal|"set-process-buffer"
argument_list|,
name|Fset_process_buffer
argument_list|,
name|Sset_process_buffer
argument_list|,
literal|2
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
literal|"Set buffer associated with PROCESS to BUFFER (a buffer, or nil)."
argument_list|)
argument_list|(
name|proc
argument_list|,
name|buffer
argument_list|)
specifier|register
name|Lisp_Object
name|proc
operator|,
name|buffer
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|CHECK_PROCESS
argument_list|(
name|proc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|NULL
argument_list|(
name|buffer
argument_list|)
condition|)
name|CHECK_BUFFER
argument_list|(
name|buffer
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|XPROCESS
argument_list|(
name|proc
argument_list|)
operator|->
name|buffer
operator|=
name|buffer
expr_stmt|;
return|return
name|buffer
return|;
block|}
end_block

begin_expr_stmt
name|DEFUN
argument_list|(
literal|"process-buffer"
argument_list|,
name|Fprocess_buffer
argument_list|,
name|Sprocess_buffer
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|"Return the buffer PROCESS is associated with.\n\ Output from PROCESS is inserted in this buffer\n\ unless PROCESS has a filter."
argument_list|)
argument_list|(
name|proc
argument_list|)
specifier|register
name|Lisp_Object
name|proc
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|CHECK_PROCESS
argument_list|(
name|proc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|XPROCESS
argument_list|(
name|proc
argument_list|)
operator|->
name|buffer
return|;
block|}
end_block

begin_expr_stmt
name|DEFUN
argument_list|(
literal|"process-mark"
argument_list|,
name|Fprocess_mark
argument_list|,
name|Sprocess_mark
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|"Return the marker for the end of the last output from PROCESS."
argument_list|)
argument_list|(
name|proc
argument_list|)
specifier|register
name|Lisp_Object
name|proc
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|CHECK_PROCESS
argument_list|(
name|proc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|XPROCESS
argument_list|(
name|proc
argument_list|)
operator|->
name|mark
return|;
block|}
end_block

begin_expr_stmt
name|DEFUN
argument_list|(
literal|"set-process-filter"
argument_list|,
name|Fset_process_filter
argument_list|,
name|Sset_process_filter
argument_list|,
literal|2
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
literal|"Give PROCESS the filter function FILTER; nil means no filter.\n\ When a process has a filter, each time it does output\n\ the entire string of output is passed to the filter.\n\ The filter gets two arguments: the process and the string of output.\n\ If the process has a filter, its buffer is not used for output."
argument_list|)
argument_list|(
name|proc
argument_list|,
name|filter
argument_list|)
specifier|register
name|Lisp_Object
name|proc
operator|,
name|filter
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|CHECK_PROCESS
argument_list|(
name|proc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|XPROCESS
argument_list|(
name|proc
argument_list|)
operator|->
name|filter
operator|=
name|filter
expr_stmt|;
return|return
name|filter
return|;
block|}
end_block

begin_expr_stmt
name|DEFUN
argument_list|(
literal|"process-filter"
argument_list|,
name|Fprocess_filter
argument_list|,
name|Sprocess_filter
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|"Returns the filter function of PROCESS; nil if none.\n\ See set-process-filter for more info on filter functions."
argument_list|)
argument_list|(
name|proc
argument_list|)
specifier|register
name|Lisp_Object
name|proc
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|CHECK_PROCESS
argument_list|(
name|proc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|XPROCESS
argument_list|(
name|proc
argument_list|)
operator|->
name|filter
return|;
block|}
end_block

begin_expr_stmt
name|DEFUN
argument_list|(
literal|"set-process-sentinel"
argument_list|,
name|Fset_process_sentinel
argument_list|,
name|Sset_process_sentinel
argument_list|,
literal|2
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
literal|"Give PROCESS the sentinel SENTINEL; nil for none.\n\ The sentinel is called as a function when the process changes state.\n\ It gets two arguments: the process, and a string describing the change."
argument_list|)
argument_list|(
name|proc
argument_list|,
name|sentinel
argument_list|)
specifier|register
name|Lisp_Object
name|proc
operator|,
name|sentinel
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|CHECK_PROCESS
argument_list|(
name|proc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|XPROCESS
argument_list|(
name|proc
argument_list|)
operator|->
name|sentinel
operator|=
name|sentinel
expr_stmt|;
return|return
name|sentinel
return|;
block|}
end_block

begin_expr_stmt
name|DEFUN
argument_list|(
literal|"process-sentinel"
argument_list|,
name|Fprocess_sentinel
argument_list|,
name|Sprocess_sentinel
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|"Return the sentinel of PROCESS; nil if none.\n\ See set-process-sentinel for more info on sentinels."
argument_list|)
argument_list|(
name|proc
argument_list|)
specifier|register
name|Lisp_Object
name|proc
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|CHECK_PROCESS
argument_list|(
name|proc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|XPROCESS
argument_list|(
name|proc
argument_list|)
operator|->
name|sentinel
return|;
block|}
end_block

begin_expr_stmt
name|DEFUN
argument_list|(
literal|"process-kill-without-query"
argument_list|,
name|Fprocess_kill_without_query
argument_list|,
name|Sprocess_kill_without_query
argument_list|,
literal|1
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
literal|"Say no query needed if PROCESS is running when Emacs is exited.\n\ Optional second argument if non-nil says to require a query.\n\ Value is t if a query was formerly required."
argument_list|)
argument_list|(
name|proc
argument_list|,
name|value
argument_list|)
specifier|register
name|Lisp_Object
name|proc
operator|,
name|value
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|Lisp_Object
name|tem
decl_stmt|;
name|CHECK_PROCESS
argument_list|(
name|proc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tem
operator|=
name|XPROCESS
argument_list|(
name|proc
argument_list|)
operator|->
name|kill_without_query
expr_stmt|;
name|XPROCESS
argument_list|(
name|proc
argument_list|)
operator|->
name|kill_without_query
operator|=
name|Fnull
argument_list|(
name|value
argument_list|)
expr_stmt|;
return|return
name|Fnull
argument_list|(
name|tem
argument_list|)
return|;
block|}
end_block

begin_escape
end_escape

begin_function
name|Lisp_Object
name|list_processes_1
parameter_list|()
block|{
specifier|register
name|Lisp_Object
name|tail
decl_stmt|,
name|tem
decl_stmt|;
name|Lisp_Object
name|proc
decl_stmt|,
name|minspace
decl_stmt|,
name|tem1
decl_stmt|;
specifier|register
name|struct
name|buffer
modifier|*
name|old
init|=
name|current_buffer
decl_stmt|;
specifier|register
name|struct
name|Lisp_Process
modifier|*
name|p
decl_stmt|;
specifier|register
name|int
name|state
decl_stmt|;
name|char
name|tembuf
index|[
literal|80
index|]
decl_stmt|;
name|XFASTINT
argument_list|(
name|minspace
argument_list|)
operator|=
literal|1
expr_stmt|;
name|set_buffer_internal
argument_list|(
name|XBUFFER
argument_list|(
name|Vstandard_output
argument_list|)
argument_list|)
expr_stmt|;
name|Fbuffer_flush_undo
argument_list|(
name|Vstandard_output
argument_list|)
expr_stmt|;
name|current_buffer
operator|->
name|truncate_lines
operator|=
name|Qt
expr_stmt|;
name|write_string
argument_list|(
literal|"\ Proc         Status   Buffer         Command\n\ ----         ------   ------         -------\n"
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|tail
operator|=
name|Vprocess_alist
init|;
operator|!
name|NULL
argument_list|(
name|tail
argument_list|)
condition|;
name|tail
operator|=
name|Fcdr
argument_list|(
name|tail
argument_list|)
control|)
block|{
name|Lisp_Object
name|symbol
decl_stmt|;
name|proc
operator|=
name|Fcdr
argument_list|(
name|Fcar
argument_list|(
name|tail
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|=
name|XPROCESS
argument_list|(
name|proc
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
argument_list|(
name|p
operator|->
name|childp
argument_list|)
condition|)
continue|continue;
name|Finsert
argument_list|(
literal|1
argument_list|,
operator|&
name|p
operator|->
name|name
argument_list|)
expr_stmt|;
name|Findent_to
argument_list|(
name|make_number
argument_list|(
literal|13
argument_list|)
argument_list|,
name|minspace
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|NULL
argument_list|(
name|p
operator|->
name|raw_status_low
argument_list|)
condition|)
name|update_status
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|symbol
operator|=
name|p
operator|->
name|status
expr_stmt|;
if|if
condition|(
name|XTYPE
argument_list|(
name|p
operator|->
name|status
argument_list|)
operator|==
name|Lisp_Cons
condition|)
name|symbol
operator|=
name|XCONS
argument_list|(
name|p
operator|->
name|status
argument_list|)
operator|->
name|car
expr_stmt|;
if|if
condition|(
name|EQ
argument_list|(
name|symbol
argument_list|,
name|Qsignal
argument_list|)
condition|)
block|{
name|Lisp_Object
name|tem
decl_stmt|;
name|tem
operator|=
name|Fcar
argument_list|(
name|Fcdr
argument_list|(
name|p
operator|->
name|status
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|XINT
argument_list|(
name|tem
argument_list|)
operator|<
name|NSIG
condition|)
name|write_string
argument_list|(
name|sys_siglist
index|[
name|XINT
argument_list|(
name|tem
argument_list|)
index|]
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
else|else
name|Fprinc
argument_list|(
name|symbol
argument_list|,
name|Qnil
argument_list|)
expr_stmt|;
block|}
else|else
name|Fprinc
argument_list|(
name|symbol
argument_list|,
name|Qnil
argument_list|)
expr_stmt|;
if|if
condition|(
name|EQ
argument_list|(
name|symbol
argument_list|,
name|Qexit
argument_list|)
condition|)
block|{
name|Lisp_Object
name|tem
decl_stmt|;
name|tem
operator|=
name|Fcar
argument_list|(
name|Fcdr
argument_list|(
name|p
operator|->
name|status
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|XFASTINT
argument_list|(
name|tem
argument_list|)
condition|)
block|{
name|sprintf
argument_list|(
name|tembuf
argument_list|,
literal|" %d"
argument_list|,
name|XFASTINT
argument_list|(
name|tem
argument_list|)
argument_list|)
expr_stmt|;
name|write_string
argument_list|(
name|tembuf
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|EQ
argument_list|(
name|symbol
argument_list|,
name|Qsignal
argument_list|)
operator|||
name|EQ
argument_list|(
name|symbol
argument_list|,
name|Qexit
argument_list|)
condition|)
name|remove_process
argument_list|(
name|proc
argument_list|)
expr_stmt|;
name|Findent_to
argument_list|(
name|make_number
argument_list|(
literal|22
argument_list|)
argument_list|,
name|minspace
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
argument_list|(
name|p
operator|->
name|buffer
argument_list|)
condition|)
name|InsStr
argument_list|(
literal|"(none)"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|NULL
argument_list|(
name|XBUFFER
argument_list|(
name|p
operator|->
name|buffer
argument_list|)
operator|->
name|name
argument_list|)
condition|)
name|InsStr
argument_list|(
literal|"(Killed)"
argument_list|)
expr_stmt|;
else|else
name|Finsert
argument_list|(
literal|1
argument_list|,
operator|&
name|XBUFFER
argument_list|(
name|p
operator|->
name|buffer
argument_list|)
operator|->
name|name
argument_list|)
expr_stmt|;
name|Findent_to
argument_list|(
name|make_number
argument_list|(
literal|37
argument_list|)
argument_list|,
name|minspace
argument_list|)
expr_stmt|;
if|if
condition|(
name|NETCONN_P
argument_list|(
name|proc
argument_list|)
condition|)
block|{
name|sprintf
argument_list|(
name|tembuf
argument_list|,
literal|"(network stream connection to %s)\n"
argument_list|,
name|XSTRING
argument_list|(
name|p
operator|->
name|childp
argument_list|)
operator|->
name|data
argument_list|)
expr_stmt|;
name|InsStr
argument_list|(
name|tembuf
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tem
operator|=
name|p
operator|->
name|command
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|tem1
operator|=
name|Fcar
argument_list|(
name|tem
argument_list|)
expr_stmt|;
name|Finsert
argument_list|(
literal|1
argument_list|,
operator|&
name|tem1
argument_list|)
expr_stmt|;
name|tem
operator|=
name|Fcdr
argument_list|(
name|tem
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
argument_list|(
name|tem
argument_list|)
condition|)
break|break;
name|InsStr
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
block|}
name|InsStr
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|Qnil
return|;
block|}
end_function

begin_macro
name|DEFUN
argument_list|(
literal|"list-processes"
argument_list|,
argument|Flist_processes
argument_list|,
argument|Slist_processes
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|,
literal|"Display a list of all processes.\n\ \(Any processes listed as Exited or Signaled are actually eliminated\n\ after the listing is made.)"
argument_list|)
end_macro

begin_expr_stmt
operator|(
operator|)
block|{
name|internal_with_output_to_temp_buffer
argument_list|(
literal|"*Process List*"
argument_list|,
name|list_processes_1
argument_list|,
name|Qnil
argument_list|)
block|;
return|return
name|Qnil
return|;
block|}
end_expr_stmt

begin_macro
name|DEFUN
argument_list|(
literal|"process-list"
argument_list|,
argument|Fprocess_list
argument_list|,
argument|Sprocess_list
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|"Return a list of all processes."
argument_list|)
end_macro

begin_expr_stmt
operator|(
operator|)
block|{
return|return
name|Fmapcar
argument_list|(
name|Qcdr
argument_list|,
name|Vprocess_alist
argument_list|)
return|;
block|}
end_expr_stmt

begin_escape
end_escape

begin_macro
name|DEFUN
argument_list|(
literal|"start-process"
argument_list|,
argument|Fstart_process
argument_list|,
argument|Sstart_process
argument_list|,
literal|3
argument_list|,
argument|MANY
argument_list|,
literal|0
argument_list|,
literal|"Start a program in a subprocess.  Return the process object for it.\n\ Args are NAME BUFFER PROGRAM&rest PROGRAM-ARGS\n\ NAME is name for process.  It is modified if necessary to make it unique.\n\ BUFFER is the buffer or (buffer-name) to associate with the process.\n\  Process output goes at end of that buffer, unless you specify\n\  an output stream or filter function to handle the output.\n\  BUFFER may be also nil, meaning that this process is not associated\n\  with any buffer\n\ Third arg is program file name.  It is searched for as in the shell.\n\ Remaining arguments are strings to give program as arguments."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|nargs
operator|,
name|args
operator|)
name|int
name|nargs
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|Lisp_Object
modifier|*
name|args
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|Lisp_Object
name|buffer
decl_stmt|,
name|name
decl_stmt|,
name|program
decl_stmt|,
name|proc
decl_stmt|,
name|tem
decl_stmt|;
specifier|register
name|unsigned
name|char
modifier|*
modifier|*
name|new_argv
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|buffer
operator|=
name|args
index|[
literal|1
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|NULL
argument_list|(
name|buffer
argument_list|)
condition|)
name|buffer
operator|=
name|Fget_buffer_create
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
name|name
operator|=
name|args
index|[
literal|0
index|]
expr_stmt|;
name|CHECK_STRING
argument_list|(
name|name
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|program
operator|=
name|args
index|[
literal|2
index|]
expr_stmt|;
name|CHECK_STRING
argument_list|(
name|program
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|new_argv
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|*
operator|)
name|alloca
argument_list|(
operator|(
name|nargs
operator|-
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|3
init|;
name|i
operator|<
name|nargs
condition|;
name|i
operator|++
control|)
block|{
name|tem
operator|=
name|args
index|[
name|i
index|]
expr_stmt|;
name|CHECK_STRING
argument_list|(
name|tem
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|new_argv
index|[
name|i
operator|-
literal|2
index|]
operator|=
name|XSTRING
argument_list|(
name|tem
argument_list|)
operator|->
name|data
expr_stmt|;
block|}
name|new_argv
index|[
name|i
operator|-
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|new_argv
index|[
literal|0
index|]
operator|=
name|XSTRING
argument_list|(
name|program
argument_list|)
operator|->
name|data
expr_stmt|;
comment|/* If program file name is not absolute, search our path for it */
if|if
condition|(
name|new_argv
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|!=
literal|'/'
condition|)
block|{
name|tem
operator|=
name|Qnil
expr_stmt|;
name|openp
argument_list|(
name|Vexec_path
argument_list|,
name|program
argument_list|,
literal|""
argument_list|,
operator|&
name|tem
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
argument_list|(
name|tem
argument_list|)
condition|)
name|report_file_error
argument_list|(
literal|"Searching for program"
argument_list|,
name|Fcons
argument_list|(
name|program
argument_list|,
name|Qnil
argument_list|)
argument_list|)
expr_stmt|;
name|new_argv
index|[
literal|0
index|]
operator|=
name|XSTRING
argument_list|(
name|tem
argument_list|)
operator|->
name|data
expr_stmt|;
block|}
name|proc
operator|=
name|make_process
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|XPROCESS
argument_list|(
name|proc
argument_list|)
operator|->
name|childp
operator|=
name|Qt
expr_stmt|;
name|XPROCESS
argument_list|(
name|proc
argument_list|)
operator|->
name|command_channel_p
operator|=
name|Qnil
expr_stmt|;
name|XPROCESS
argument_list|(
name|proc
argument_list|)
operator|->
name|buffer
operator|=
name|buffer
expr_stmt|;
name|XPROCESS
argument_list|(
name|proc
argument_list|)
operator|->
name|sentinel
operator|=
name|Qnil
expr_stmt|;
name|XPROCESS
argument_list|(
name|proc
argument_list|)
operator|->
name|filter
operator|=
name|Qnil
expr_stmt|;
name|XPROCESS
argument_list|(
name|proc
argument_list|)
operator|->
name|command
operator|=
name|Flist
argument_list|(
name|nargs
operator|-
literal|2
argument_list|,
name|args
operator|+
literal|2
argument_list|)
expr_stmt|;
name|create_process
argument_list|(
name|proc
argument_list|,
name|new_argv
argument_list|)
expr_stmt|;
return|return
name|proc
return|;
block|}
end_block

begin_macro
name|create_process_1
argument_list|(
argument|signo
argument_list|)
end_macro

begin_decl_stmt
name|int
name|signo
decl_stmt|;
end_decl_stmt

begin_block
block|{
ifdef|#
directive|ifdef
name|USG
comment|/* USG systems forget handlers when they are used;      must reestablish each time */
name|signal
argument_list|(
name|signo
argument_list|,
name|create_process_1
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* USG */
block|}
end_block

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* This doesn't work; see the note before sigchld_handler.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|USG
end_ifdef

begin_ifdef
ifdef|#
directive|ifdef
name|SIGCHLD
end_ifdef

begin_comment
comment|/* Mimic blocking of signals on system V, which doesn't really have it.  */
end_comment

begin_comment
comment|/* Nonzero means we got a SIGCHLD when it was supposed to be blocked.  */
end_comment

begin_endif
unit|int sigchld_deferred;  create_process_sigchld () {   signal (SIGCHLD, create_process_sigchld);    sigchld_deferred = 1; }
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_macro
name|create_process
argument_list|(
argument|process
argument_list|,
argument|new_argv
argument_list|)
end_macro

begin_decl_stmt
name|Lisp_Object
name|process
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
modifier|*
name|new_argv
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|pid
decl_stmt|,
name|inchannel
decl_stmt|,
name|outchannel
decl_stmt|,
name|forkin
decl_stmt|,
name|forkout
decl_stmt|;
name|int
name|sv
index|[
literal|2
index|]
decl_stmt|;
ifdef|#
directive|ifdef
name|SIGCHLD
name|int
function_decl|(
modifier|*
name|sigchld
function_decl|)
parameter_list|()
function_decl|;
endif|#
directive|endif
name|char
modifier|*
modifier|*
name|env
decl_stmt|;
name|int
name|pty_flag
init|=
literal|0
decl_stmt|;
specifier|extern
name|char
modifier|*
modifier|*
name|environ
decl_stmt|;
ifdef|#
directive|ifdef
name|MAINTAIN_ENVIRONMENT
name|env
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|alloca
argument_list|(
name|size_of_current_environ
argument_list|()
argument_list|)
expr_stmt|;
name|get_current_environ
argument_list|(
name|env
argument_list|)
expr_stmt|;
else|#
directive|else
name|env
operator|=
name|environ
expr_stmt|;
endif|#
directive|endif
comment|/* MAINTAIN_ENVIRONMENT */
name|inchannel
operator|=
name|outchannel
operator|=
operator|-
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_PTYS
if|if
condition|(
name|EQ
argument_list|(
name|Vprocess_connection_type
argument_list|,
name|Qt
argument_list|)
condition|)
name|outchannel
operator|=
name|inchannel
operator|=
name|allocate_pty
argument_list|()
expr_stmt|;
if|if
condition|(
name|inchannel
operator|>=
literal|0
condition|)
block|{
ifndef|#
directive|ifndef
name|USG
comment|/* On USG systems it does not work to open 	 the pty's tty here and then close and reopen it in the child.  */
name|forkout
operator|=
name|forkin
operator|=
name|open
argument_list|(
name|pty_name
argument_list|,
name|O_RDWR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|forkin
operator|<
literal|0
condition|)
name|report_file_error
argument_list|(
literal|"Opening pty"
argument_list|,
name|Qnil
argument_list|)
expr_stmt|;
else|#
directive|else
name|forkin
operator|=
name|forkout
operator|=
operator|-
literal|1
expr_stmt|;
endif|#
directive|endif
name|pty_flag
operator|=
literal|1
expr_stmt|;
block|}
else|else
endif|#
directive|endif
comment|/* HAVE_PTYS */
ifdef|#
directive|ifdef
name|SKTPAIR
block|{
if|if
condition|(
name|socketpair
argument_list|(
name|AF_UNIX
argument_list|,
name|SOCK_STREAM
argument_list|,
literal|0
argument_list|,
name|sv
argument_list|)
operator|<
literal|0
condition|)
name|report_file_error
argument_list|(
literal|"Opening socketpair"
argument_list|,
name|Qnil
argument_list|)
expr_stmt|;
name|outchannel
operator|=
name|inchannel
operator|=
name|sv
index|[
literal|0
index|]
expr_stmt|;
name|forkout
operator|=
name|forkin
operator|=
name|sv
index|[
literal|1
index|]
expr_stmt|;
block|}
else|#
directive|else
comment|/* not SKTPAIR */
block|{
name|pipe
argument_list|(
name|sv
argument_list|)
expr_stmt|;
name|inchannel
operator|=
name|sv
index|[
literal|0
index|]
expr_stmt|;
name|forkout
operator|=
name|sv
index|[
literal|1
index|]
expr_stmt|;
name|pipe
argument_list|(
name|sv
argument_list|)
expr_stmt|;
name|outchannel
operator|=
name|sv
index|[
literal|1
index|]
expr_stmt|;
name|forkin
operator|=
name|sv
index|[
literal|0
index|]
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* not SKTPAIR */
if|#
directive|if
literal|0
comment|/* Replaced by close_process_descs */
block|set_exclusive_use (inchannel);   set_exclusive_use (outchannel);
endif|#
directive|endif
comment|/* Stride people say it's a mystery why this is needed    as well as the O_NDELAY, but that it fails without this.  */
ifdef|#
directive|ifdef
name|STRIDE
block|{
name|int
name|one
init|=
literal|1
decl_stmt|;
name|ioctl
argument_list|(
name|inchannel
argument_list|,
name|FIONBIO
argument_list|,
operator|&
name|one
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|O_NONBLOCK
name|fcntl
argument_list|(
name|inchannel
argument_list|,
name|F_SETFL
argument_list|,
name|O_NONBLOCK
argument_list|)
expr_stmt|;
else|#
directive|else
ifdef|#
directive|ifdef
name|O_NDELAY
name|fcntl
argument_list|(
name|inchannel
argument_list|,
name|F_SETFL
argument_list|,
name|O_NDELAY
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
comment|/* Record this as an active process, with its channels.      As a result, child_setup will close Emacs's side of the pipes.  */
name|chan_process
index|[
name|inchannel
index|]
operator|=
name|process
expr_stmt|;
name|XFASTINT
argument_list|(
name|XPROCESS
argument_list|(
name|process
argument_list|)
operator|->
name|infd
argument_list|)
operator|=
name|inchannel
expr_stmt|;
name|XFASTINT
argument_list|(
name|XPROCESS
argument_list|(
name|process
argument_list|)
operator|->
name|outfd
argument_list|)
operator|=
name|outchannel
expr_stmt|;
name|XPROCESS
argument_list|(
name|process
argument_list|)
operator|->
name|pty_flag
operator|=
operator|(
name|pty_flag
condition|?
name|Qt
else|:
name|Qnil
operator|)
expr_stmt|;
name|XPROCESS
argument_list|(
name|process
argument_list|)
operator|->
name|status
operator|=
name|Qrun
expr_stmt|;
comment|/* Delay interrupts until we have a chance to store      the new fork's pid in its process structure */
ifdef|#
directive|ifdef
name|SIGCHLD
ifdef|#
directive|ifdef
name|BSD4_1
name|sighold
argument_list|(
name|SIGCHLD
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* not BSD4_1 */
ifdef|#
directive|ifdef
name|HPUX
name|sigsetmask
argument_list|(
literal|1
operator|<<
operator|(
name|SIGCHLD
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* not HPUX */
if|#
directive|if
name|defined
argument_list|(
name|BSD
argument_list|)
operator|||
name|defined
argument_list|(
name|UNIPLUS
argument_list|)
name|sigsetmask
argument_list|(
literal|1
operator|<<
operator|(
name|SIGCHLD
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* ordinary USG */
if|#
directive|if
literal|0
block|sigchld_deferred = 0;   sigchld = (int (*)()) signal (SIGCHLD, create_process_sigchld);
endif|#
directive|endif
endif|#
directive|endif
comment|/* ordinary USG */
endif|#
directive|endif
comment|/* not HPUX */
endif|#
directive|endif
comment|/* not BSD4_1 */
endif|#
directive|endif
comment|/* SIGCHLD */
comment|/* Until we store the proper pid, enable sigchld_handler      to recognize an unknown pid as standing for this process.  */
name|XSETINT
argument_list|(
name|XPROCESS
argument_list|(
name|process
argument_list|)
operator|->
name|pid
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|{
comment|/* child_setup must clobber environ on systems with true vfork.        Protect it from permanent change.  */
name|char
modifier|*
modifier|*
name|save_environ
init|=
name|environ
decl_stmt|;
name|pid
operator|=
name|vfork
argument_list|()
expr_stmt|;
if|if
condition|(
name|pid
operator|==
literal|0
condition|)
block|{
name|int
name|xforkin
init|=
name|forkin
decl_stmt|;
name|int
name|xforkout
init|=
name|forkout
decl_stmt|;
if|#
directive|if
literal|0
comment|/* This was probably a mistake--it duplicates code later on, 	 but fails to handle all the cases.  */
comment|/* Make SIGCHLD work again in the child.  */
block|sigsetmask (0);
endif|#
directive|endif
comment|/* Make the pty be the controlling terminal of the process.  */
ifdef|#
directive|ifdef
name|HAVE_PTYS
comment|/* First, disconnect its current controlling terminal.  */
ifdef|#
directive|ifdef
name|HAVE_SETSID
name|setsid
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|TIOCSCTTY
comment|/* Make the pty's terminal the controlling terminal.  */
if|if
condition|(
name|pty_flag
operator|&&
operator|(
name|ioctl
argument_list|(
name|xforkin
argument_list|,
name|TIOCSCTTY
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
operator|)
condition|)
name|abort
argument_list|()
expr_stmt|;
endif|#
directive|endif
else|#
directive|else
comment|/* not HAVE_SETSID */
ifdef|#
directive|ifdef
name|USG
comment|/* It's very important to call setpgrp() here and no time 	   afterwards.  Otherwise, we lose our controlling tty which 	   is set when we open the pty. */
name|setpgrp
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* USG */
endif|#
directive|endif
comment|/* not HAVE_SETSID */
ifdef|#
directive|ifdef
name|TIOCNOTTY
comment|/* In 4.3BSD, the TIOCSPGRP bug has been fixed, and now you 	   can do TIOCSPGRP only to the process's controlling tty.  */
if|if
condition|(
name|pty_flag
condition|)
block|{
comment|/* I wonder: would just ioctl (0, TIOCNOTTY, 0) work here?  	       I can't test it since I don't have 4.3.  */
name|int
name|j
init|=
name|open
argument_list|(
literal|"/dev/tty"
argument_list|,
name|O_RDWR
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|ioctl
argument_list|(
name|j
argument_list|,
name|TIOCNOTTY
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|j
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|USG
comment|/* In order to get a controlling terminal on some versions 	       of BSD, it is necessary to put the process in pgrp 0 	       before it opens the terminal.  */
name|setpgrp
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
endif|#
directive|endif
comment|/* TIOCNOTTY */
if|#
directive|if
operator|!
name|defined
argument_list|(
name|RTU
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|UNIPLUS
argument_list|)
comment|/*** There is a suggestion that this ought to be a      conditional on TIOCSPGRP.  */
comment|/* Now close the pty (if we had it open) and reopen it. 	   This makes the pty the controlling terminal of the subprocess.  */
if|if
condition|(
name|pty_flag
condition|)
block|{
comment|/* I wonder if close (open (pty_name, ...)) would work?  */
if|if
condition|(
name|xforkin
operator|>=
literal|0
condition|)
name|close
argument_list|(
name|xforkin
argument_list|)
expr_stmt|;
name|xforkout
operator|=
name|xforkin
operator|=
name|open
argument_list|(
name|pty_name
argument_list|,
name|O_RDWR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|xforkin
operator|<
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* not UNIPLUS and not RTU */
ifdef|#
directive|ifdef
name|SETUP_SLAVE_PTY
name|SETUP_SLAVE_PTY
expr_stmt|;
endif|#
directive|endif
comment|/* SETUP_SLAVE_PTY */
ifdef|#
directive|ifdef
name|AIX
comment|/* On AIX, we've disabled SIGHUP above once we start a child on a pty. 	   Now reenable it in the child, so it will die when we want it to.  */
if|if
condition|(
name|pty_flag
condition|)
name|signal
argument_list|(
name|SIGHUP
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
comment|/* HAVE_PTYS */
ifdef|#
directive|ifdef
name|SIGCHLD
ifdef|#
directive|ifdef
name|BSD4_1
name|sigrelse
argument_list|(
name|SIGCHLD
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* not BSD4_1 */
if|#
directive|if
name|defined
argument_list|(
name|BSD
argument_list|)
operator|||
name|defined
argument_list|(
name|UNIPLUS
argument_list|)
operator|||
name|defined
argument_list|(
name|HPUX
argument_list|)
name|sigsetmask
argument_list|(
literal|0
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* ordinary USG */
name|signal
argument_list|(
name|SIGCHLD
argument_list|,
name|sigchld
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* ordinary USG */
endif|#
directive|endif
comment|/* not BSD4_1 */
endif|#
directive|endif
comment|/* SIGCHLD */
name|child_setup_tty
argument_list|(
name|xforkout
argument_list|)
expr_stmt|;
name|child_setup
argument_list|(
name|xforkin
argument_list|,
name|xforkout
argument_list|,
name|xforkout
argument_list|,
name|new_argv
argument_list|,
name|env
argument_list|)
expr_stmt|;
block|}
name|environ
operator|=
name|save_environ
expr_stmt|;
block|}
if|if
condition|(
name|pid
operator|<
literal|0
condition|)
block|{
name|remove_process
argument_list|(
name|process
argument_list|)
expr_stmt|;
name|report_file_error
argument_list|(
literal|"Doing vfork"
argument_list|,
name|Qnil
argument_list|)
expr_stmt|;
block|}
name|XFASTINT
argument_list|(
name|XPROCESS
argument_list|(
name|process
argument_list|)
operator|->
name|pid
argument_list|)
operator|=
name|pid
expr_stmt|;
name|FD_SET
argument_list|(
name|inchannel
argument_list|,
operator|&
name|input_wait_mask
argument_list|)
expr_stmt|;
comment|/* If the subfork execv fails, and it exits,      this close hangs.  I don't know why.      So have an interrupt jar it loose.  */
name|stop_polling
argument_list|()
expr_stmt|;
name|signal
argument_list|(
name|SIGALRM
argument_list|,
name|create_process_1
argument_list|)
expr_stmt|;
name|alarm
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|forkin
operator|>=
literal|0
condition|)
name|close
argument_list|(
name|forkin
argument_list|)
expr_stmt|;
name|alarm
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|start_polling
argument_list|()
expr_stmt|;
if|if
condition|(
name|forkin
operator|!=
name|forkout
operator|&&
name|forkout
operator|>=
literal|0
condition|)
name|close
argument_list|(
name|forkout
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SIGCHLD
ifdef|#
directive|ifdef
name|BSD4_1
name|sigrelse
argument_list|(
name|SIGCHLD
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* not BSD4_1 */
if|#
directive|if
name|defined
argument_list|(
name|BSD
argument_list|)
operator|||
name|defined
argument_list|(
name|UNIPLUS
argument_list|)
operator|||
name|defined
argument_list|(
name|HPUX
argument_list|)
name|sigsetmask
argument_list|(
literal|0
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* ordinary USG */
if|#
directive|if
literal|0
block|signal (SIGCHLD, sigchld);
comment|/* Now really handle any of these signals      that came in during this function.  */
block|if (sigchld_deferred)     kill (getpid (), SIGCHLD);
endif|#
directive|endif
endif|#
directive|endif
comment|/* ordinary USG */
endif|#
directive|endif
comment|/* not BSD4_1 */
endif|#
directive|endif
comment|/* SIGCHLD */
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SOCKETS
end_ifdef

begin_comment
comment|/* open a TCP network connection to a given HOST/SERVICE.  Treated    exactly like a normal process when reading and writing.  Only    differences are in status display and process deletion.  A network    connection has no PID; you cannot signal it.  All you can do is    deactivate and close it via delete-process */
end_comment

begin_macro
name|DEFUN
argument_list|(
literal|"open-network-stream"
argument_list|,
argument|Fopen_network_stream
argument_list|,
argument|Sopen_network_stream
argument_list|,
literal|4
argument_list|,
literal|4
argument_list|,
literal|0
argument_list|,
literal|"Open a TCP connection for a service to a host.\n\ Returns a subprocess-object to represent the connection.\n\ Input and output work as for subprocesses; `delete-process' closes it.\n\ Args are NAME BUFFER HOST SERVICE.\n\ NAME is name for process.  It is modified if necessary to make it unique.\n\ BUFFER is the buffer (or buffer-name) to associate with the process.\n\  Process output goes at end of that buffer, unless you specify\n\  an output stream or filter function to handle the output.\n\  BUFFER may be also nil, meaning that this process is not associated\n\  with any buffer\n\ Third arg is name of the host to connect to.\n\ Fourth arg SERVICE is name of the service desired, or an integer\n\  specifying a port number to connect to."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|name
operator|,
name|buffer
operator|,
name|host
operator|,
name|service
operator|)
name|Lisp_Object
name|name
operator|,
name|buffer
operator|,
name|host
operator|,
name|service
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|Lisp_Object
name|proc
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|struct
name|sockaddr_in
name|address
decl_stmt|;
name|struct
name|servent
modifier|*
name|svc_info
decl_stmt|;
name|struct
name|hostent
modifier|*
name|host_info
decl_stmt|;
name|int
name|s
decl_stmt|,
name|outch
decl_stmt|,
name|inch
decl_stmt|;
name|char
name|errstring
index|[
literal|80
index|]
decl_stmt|;
name|int
name|port
decl_stmt|;
name|struct
name|gcpro
name|gcpro1
decl_stmt|,
name|gcpro2
decl_stmt|,
name|gcpro3
decl_stmt|,
name|gcpro4
decl_stmt|;
name|GCPRO4
argument_list|(
name|name
argument_list|,
name|buffer
argument_list|,
name|host
argument_list|,
name|service
argument_list|)
expr_stmt|;
name|CHECK_STRING
argument_list|(
name|name
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CHECK_STRING
argument_list|(
name|host
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|XTYPE
argument_list|(
name|service
argument_list|)
operator|==
name|Lisp_Int
condition|)
name|port
operator|=
name|htons
argument_list|(
operator|(
name|unsigned
name|short
operator|)
name|XINT
argument_list|(
name|service
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|CHECK_STRING
argument_list|(
name|service
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|svc_info
operator|=
name|getservbyname
argument_list|(
name|XSTRING
argument_list|(
name|service
argument_list|)
operator|->
name|data
argument_list|,
literal|"tcp"
argument_list|)
expr_stmt|;
if|if
condition|(
name|svc_info
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"Unknown service \"%s\""
argument_list|,
name|XSTRING
argument_list|(
name|service
argument_list|)
operator|->
name|data
argument_list|)
expr_stmt|;
name|port
operator|=
name|svc_info
operator|->
name|s_port
expr_stmt|;
block|}
name|host_info
operator|=
name|gethostbyname
argument_list|(
name|XSTRING
argument_list|(
name|host
argument_list|)
operator|->
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|host_info
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"Unknown host \"%s\""
argument_list|,
name|XSTRING
argument_list|(
name|host
argument_list|)
operator|->
name|data
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|address
argument_list|,
sizeof|sizeof
name|address
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|host_info
operator|->
name|h_addr
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|address
operator|.
name|sin_addr
argument_list|,
name|host_info
operator|->
name|h_length
argument_list|)
expr_stmt|;
name|address
operator|.
name|sin_family
operator|=
name|host_info
operator|->
name|h_addrtype
expr_stmt|;
name|address
operator|.
name|sin_port
operator|=
name|port
expr_stmt|;
name|s
operator|=
name|socket
argument_list|(
name|host_info
operator|->
name|h_addrtype
argument_list|,
name|SOCK_STREAM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|<
literal|0
condition|)
name|report_file_error
argument_list|(
literal|"error creating socket"
argument_list|,
name|Fcons
argument_list|(
name|name
argument_list|,
name|Qnil
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|connect
argument_list|(
name|s
argument_list|,
operator|&
name|address
argument_list|,
sizeof|sizeof
name|address
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|close
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"Host \"%s\" not responding"
argument_list|,
name|XSTRING
argument_list|(
name|host
argument_list|)
operator|->
name|data
argument_list|)
expr_stmt|;
block|}
name|inch
operator|=
name|s
expr_stmt|;
name|outch
operator|=
name|dup
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|outch
operator|<
literal|0
condition|)
name|report_file_error
argument_list|(
literal|"error duplicating socket"
argument_list|,
name|Fcons
argument_list|(
name|name
argument_list|,
name|Qnil
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|NULL
argument_list|(
name|buffer
argument_list|)
condition|)
name|buffer
operator|=
name|Fget_buffer_create
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
name|proc
operator|=
name|make_process
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|chan_process
index|[
name|inch
index|]
operator|=
name|proc
expr_stmt|;
ifdef|#
directive|ifdef
name|O_NONBLOCK
name|fcntl
argument_list|(
name|inch
argument_list|,
name|F_SETFL
argument_list|,
name|O_NONBLOCK
argument_list|)
expr_stmt|;
else|#
directive|else
ifdef|#
directive|ifdef
name|O_NDELAY
name|fcntl
argument_list|(
name|inch
argument_list|,
name|F_SETFL
argument_list|,
name|O_NDELAY
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
name|XPROCESS
argument_list|(
name|proc
argument_list|)
operator|->
name|childp
operator|=
name|host
expr_stmt|;
name|XPROCESS
argument_list|(
name|proc
argument_list|)
operator|->
name|command_channel_p
operator|=
name|Qnil
expr_stmt|;
name|XPROCESS
argument_list|(
name|proc
argument_list|)
operator|->
name|buffer
operator|=
name|buffer
expr_stmt|;
name|XPROCESS
argument_list|(
name|proc
argument_list|)
operator|->
name|sentinel
operator|=
name|Qnil
expr_stmt|;
name|XPROCESS
argument_list|(
name|proc
argument_list|)
operator|->
name|filter
operator|=
name|Qnil
expr_stmt|;
name|XPROCESS
argument_list|(
name|proc
argument_list|)
operator|->
name|command
operator|=
name|Qnil
expr_stmt|;
name|XPROCESS
argument_list|(
name|proc
argument_list|)
operator|->
name|pid
operator|=
name|Qnil
expr_stmt|;
name|XPROCESS
argument_list|(
name|proc
argument_list|)
operator|->
name|kill_without_query
operator|=
name|Qt
expr_stmt|;
name|XFASTINT
argument_list|(
name|XPROCESS
argument_list|(
name|proc
argument_list|)
operator|->
name|infd
argument_list|)
operator|=
name|s
expr_stmt|;
name|XFASTINT
argument_list|(
name|XPROCESS
argument_list|(
name|proc
argument_list|)
operator|->
name|outfd
argument_list|)
operator|=
name|outch
expr_stmt|;
name|XPROCESS
argument_list|(
name|proc
argument_list|)
operator|->
name|status
operator|=
name|Qrun
expr_stmt|;
name|FD_SET
argument_list|(
name|inch
argument_list|,
operator|&
name|input_wait_mask
argument_list|)
expr_stmt|;
name|UNGCPRO
expr_stmt|;
return|return
name|proc
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_SOCKETS */
end_comment

begin_macro
name|deactivate_process
argument_list|(
argument|proc
argument_list|)
end_macro

begin_decl_stmt
name|Lisp_Object
name|proc
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|inchannel
decl_stmt|,
name|outchannel
decl_stmt|;
specifier|register
name|struct
name|Lisp_Process
modifier|*
name|p
init|=
name|XPROCESS
argument_list|(
name|proc
argument_list|)
decl_stmt|;
name|inchannel
operator|=
name|XFASTINT
argument_list|(
name|p
operator|->
name|infd
argument_list|)
expr_stmt|;
name|outchannel
operator|=
name|XFASTINT
argument_list|(
name|p
operator|->
name|outfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|inchannel
condition|)
block|{
comment|/* Beware SIGCHLD hereabouts. */
name|flush_pending_output
argument_list|(
name|inchannel
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|inchannel
argument_list|)
expr_stmt|;
if|if
condition|(
name|outchannel
operator|&&
name|outchannel
operator|!=
name|inchannel
condition|)
name|close
argument_list|(
name|outchannel
argument_list|)
expr_stmt|;
name|XFASTINT
argument_list|(
name|p
operator|->
name|infd
argument_list|)
operator|=
literal|0
expr_stmt|;
name|XFASTINT
argument_list|(
name|p
operator|->
name|outfd
argument_list|)
operator|=
literal|0
expr_stmt|;
name|chan_process
index|[
name|inchannel
index|]
operator|=
name|Qnil
expr_stmt|;
name|FD_CLR
argument_list|(
name|inchannel
argument_list|,
operator|&
name|input_wait_mask
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/* Close all descriptors currently in use for communication    with subprocess.  This is used in a newly-forked subprocess    to get rid of irrelevant descriptors.  */
end_comment

begin_macro
name|close_process_descs
argument_list|()
end_macro

begin_block
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAXDESC
condition|;
name|i
operator|++
control|)
block|{
name|Lisp_Object
name|process
decl_stmt|;
name|process
operator|=
name|chan_process
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|NULL
argument_list|(
name|process
argument_list|)
condition|)
block|{
name|int
name|in
init|=
name|XFASTINT
argument_list|(
name|XPROCESS
argument_list|(
name|process
argument_list|)
operator|->
name|infd
argument_list|)
decl_stmt|;
name|int
name|out
init|=
name|XFASTINT
argument_list|(
name|XPROCESS
argument_list|(
name|process
argument_list|)
operator|->
name|outfd
argument_list|)
decl_stmt|;
name|close
argument_list|(
name|in
argument_list|)
expr_stmt|;
if|if
condition|(
name|in
operator|!=
name|out
condition|)
name|close
argument_list|(
name|out
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_block

begin_escape
end_escape

begin_expr_stmt
name|DEFUN
argument_list|(
literal|"accept-process-output"
argument_list|,
name|Faccept_process_output
argument_list|,
name|Saccept_process_output
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|"Allow any pending output from subprocesses to be read by Emacs.\n\ It is read into the process' buffers or given to their filter functions.\n\ Non-nil arg PROCESS means do not return until some output has been received\n\ from PROCESS."
argument_list|)
argument_list|(
name|proc
argument_list|)
specifier|register
name|Lisp_Object
name|proc
expr_stmt|;
end_expr_stmt

begin_block
block|{
if|if
condition|(
name|NULL
argument_list|(
name|proc
argument_list|)
condition|)
name|wait_reading_process_input
argument_list|(
operator|-
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
block|{
name|proc
operator|=
name|get_process
argument_list|(
name|proc
argument_list|)
expr_stmt|;
name|wait_reading_process_input
argument_list|(
literal|0
argument_list|,
name|XPROCESS
argument_list|(
name|proc
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
return|return
name|Qnil
return|;
block|}
end_block

begin_comment
comment|/* This variable is different from waiting_for_input in keyboard.c.    It is used to communicate to a lisp process-filter/sentinel (via the    function Fwaiting_for_user_input_p below) whether emacs was waiting    for user-input when that process-filter was called.    waiting_for_input cannot be used as that is by definition 0 when    lisp code is being evalled */
end_comment

begin_decl_stmt
specifier|static
name|int
name|waiting_for_user_input_p
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Read and dispose of subprocess output  while waiting for timeout to elapse and/or keyboard input to be available.   time_limit is the timeout in seconds, or zero for no limit.  -1 means gobble data available immediately but don't wait for any.   read_kbd is 1 to return when input is available.  -1 means caller will actually read the input.  A pointer to a struct Lisp_Process means wait until  something arrives from that process.   do_display means redisplay should be done to show  subprocess output that arrives.  */
end_comment

begin_macro
name|wait_reading_process_input
argument_list|(
argument|time_limit
argument_list|,
argument|read_kbd
argument_list|,
argument|do_display
argument_list|)
end_macro

begin_decl_stmt
name|int
name|time_limit
decl_stmt|,
name|read_kbd
decl_stmt|,
name|do_display
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|channel
decl_stmt|,
name|nfds
decl_stmt|,
name|m
decl_stmt|;
name|SELECT_TYPE
name|Available
decl_stmt|;
name|SELECT_TYPE
name|Exception
decl_stmt|;
name|int
name|xerrno
decl_stmt|;
name|Lisp_Object
name|proc
decl_stmt|;
ifdef|#
directive|ifdef
name|HAVE_TIMEVAL
name|struct
name|timeval
name|timeout
decl_stmt|,
name|end_time
decl_stmt|,
name|garbage
decl_stmt|;
else|#
directive|else
name|long
name|timeout
decl_stmt|,
name|end_time
decl_stmt|,
name|temp
decl_stmt|;
endif|#
directive|endif
comment|/* not HAVE_TIMEVAL */
name|SELECT_TYPE
name|Atemp
decl_stmt|;
name|int
name|wait_channel
init|=
literal|0
decl_stmt|;
name|struct
name|Lisp_Process
modifier|*
name|wait_proc
init|=
literal|0
decl_stmt|;
extern|extern kbd_count;
comment|/* Detect when read_kbd is really the address of a Lisp_Process.  */
if|if
condition|(
name|read_kbd
operator|>
literal|10
operator|||
name|read_kbd
operator|<
operator|-
literal|1
condition|)
block|{
name|wait_proc
operator|=
operator|(
expr|struct
name|Lisp_Process
operator|*
operator|)
name|read_kbd
expr_stmt|;
name|wait_channel
operator|=
name|XFASTINT
argument_list|(
name|wait_proc
operator|->
name|infd
argument_list|)
expr_stmt|;
name|read_kbd
operator|=
literal|0
expr_stmt|;
block|}
name|waiting_for_user_input_p
operator|=
name|read_kbd
expr_stmt|;
comment|/* Since we may need to wait several times,      compute the absolute time to return at.  */
if|if
condition|(
name|time_limit
condition|)
block|{
ifdef|#
directive|ifdef
name|HAVE_TIMEVAL
name|gettimeofday
argument_list|(
operator|&
name|end_time
argument_list|,
operator|&
name|garbage
argument_list|)
expr_stmt|;
name|end_time
operator|.
name|tv_sec
operator|+=
name|time_limit
expr_stmt|;
else|#
directive|else
comment|/* not HAVE_TIMEVAL */
name|time
argument_list|(
operator|&
name|end_time
argument_list|)
expr_stmt|;
name|end_time
operator|+=
name|time_limit
expr_stmt|;
endif|#
directive|endif
comment|/* not HAVE_TIMEVAL */
block|}
if|#
directive|if
literal|0
comment|/* Select emulator claims to preserve alarms. 	  And there are many ways to get out of this function by longjmp.  */
comment|/* Turn off periodic alarms (in case they are in use)      because the select emulator uses alarms.  */
block|stop_polling ();
endif|#
directive|endif
while|while
condition|(
literal|1
condition|)
block|{
comment|/* If calling from keyboard input, do not quit 	 since we want to return C-g as an input character. 	 Otherwise, do pending quit if requested.  */
if|if
condition|(
name|read_kbd
operator|>=
literal|0
condition|)
block|{
if|#
directive|if
literal|0
comment|/* This is the same condition tested by QUIT. 	     We need to resume polling if we are going to quit.  */
block|if (!NULL (Vquit_flag)&& NULL (Vinhibit_quit)) 	    { 	      start_polling (); 	      QUIT; 	    }
endif|#
directive|endif
name|QUIT
expr_stmt|;
block|}
comment|/* If status of something has changed, and no input is available, 	 notify the user of the change right away */
if|if
condition|(
name|update_tick
operator|!=
name|process_tick
operator|&&
name|do_display
condition|)
block|{
name|Atemp
operator|=
name|input_wait_mask
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_TIMEVAL
name|timeout
operator|.
name|tv_sec
operator|=
literal|0
expr_stmt|;
name|timeout
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
else|#
directive|else
comment|/* not HAVE_TIMEVAL */
name|timeout
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
comment|/* not HAVE_TIMEVAL */
if|if
condition|(
name|select
argument_list|(
name|MAXDESC
argument_list|,
operator|&
name|Atemp
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|&
name|timeout
argument_list|)
operator|<=
literal|0
condition|)
name|status_notify
argument_list|()
expr_stmt|;
block|}
comment|/* Don't wait for output from a non-running process.  */
if|if
condition|(
name|wait_proc
operator|!=
literal|0
operator|&&
operator|!
name|NULL
argument_list|(
name|wait_proc
operator|->
name|raw_status_low
argument_list|)
condition|)
name|update_status
argument_list|(
name|wait_proc
argument_list|)
expr_stmt|;
if|if
condition|(
name|wait_proc
operator|!=
literal|0
operator|&&
operator|!
name|EQ
argument_list|(
name|wait_proc
operator|->
name|status
argument_list|,
name|Qrun
argument_list|)
condition|)
break|break;
if|if
condition|(
name|fix_screen_hook
condition|)
call|(
modifier|*
name|fix_screen_hook
call|)
argument_list|()
expr_stmt|;
comment|/* Compute time from now till when time limit is up */
comment|/* Exit if already run out */
if|if
condition|(
name|time_limit
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* -1 specified for timeout means 	     gobble output available now 	     but don't wait at all. */
ifdef|#
directive|ifdef
name|HAVE_TIMEVAL
name|timeout
operator|.
name|tv_sec
operator|=
literal|0
expr_stmt|;
name|timeout
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
else|#
directive|else
name|timeout
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
comment|/* not HAVE_TIMEVAL */
block|}
elseif|else
if|if
condition|(
name|time_limit
condition|)
block|{
ifdef|#
directive|ifdef
name|HAVE_TIMEVAL
name|gettimeofday
argument_list|(
operator|&
name|timeout
argument_list|,
operator|&
name|garbage
argument_list|)
expr_stmt|;
name|timeout
operator|.
name|tv_sec
operator|=
name|end_time
operator|.
name|tv_sec
operator|-
name|timeout
operator|.
name|tv_sec
expr_stmt|;
name|timeout
operator|.
name|tv_usec
operator|=
name|end_time
operator|.
name|tv_usec
operator|-
name|timeout
operator|.
name|tv_usec
expr_stmt|;
if|if
condition|(
name|timeout
operator|.
name|tv_usec
operator|<
literal|0
condition|)
name|timeout
operator|.
name|tv_usec
operator|+=
literal|1000000
operator|,
name|timeout
operator|.
name|tv_sec
operator|--
expr_stmt|;
if|if
condition|(
name|timeout
operator|.
name|tv_sec
operator|<
literal|0
condition|)
break|break;
else|#
directive|else
comment|/* not HAVE_TIMEVAL */
name|time
argument_list|(
operator|&
name|temp
argument_list|)
expr_stmt|;
name|timeout
operator|=
name|end_time
operator|-
name|temp
expr_stmt|;
if|if
condition|(
name|timeout
operator|<
literal|0
condition|)
break|break;
endif|#
directive|endif
comment|/* not HAVE_TIMEVAL */
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|HAVE_TIMEVAL
comment|/* If no real timeout, loop sleeping with a big timeout 	     so that input interrupt can wake us up by zeroing it  */
name|timeout
operator|.
name|tv_sec
operator|=
literal|100
expr_stmt|;
name|timeout
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
else|#
directive|else
comment|/* not HAVE_TIMEVAL */
name|timeout
operator|=
literal|100000
expr_stmt|;
comment|/* 100000 recognized by the select emulator */
endif|#
directive|endif
comment|/* not HAVE_TIMEVAL */
block|}
comment|/* Cause quitting and alarm signals to take immediate action, 	 and cause input available signals to zero out timeout */
if|if
condition|(
name|read_kbd
operator|<
literal|0
condition|)
name|set_waiting_for_input
argument_list|(
operator|&
name|timeout
argument_list|)
expr_stmt|;
comment|/* Wait till there is something to do */
name|Available
operator|=
name|Exception
operator|=
name|input_wait_mask
expr_stmt|;
if|if
condition|(
operator|!
name|read_kbd
condition|)
name|FD_CLR
argument_list|(
literal|0
argument_list|,
operator|&
name|Available
argument_list|)
expr_stmt|;
if|if
condition|(
name|read_kbd
operator|&&
name|kbd_count
condition|)
name|nfds
operator|=
literal|0
expr_stmt|;
else|else
ifdef|#
directive|ifdef
name|IBMRTAIX
name|nfds
operator|=
name|select
argument_list|(
name|MAXDESC
argument_list|,
operator|&
name|Available
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|&
name|timeout
argument_list|)
expr_stmt|;
else|#
directive|else
ifdef|#
directive|ifdef
name|HPUX
name|nfds
operator|=
name|select
argument_list|(
name|MAXDESC
argument_list|,
operator|&
name|Available
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|&
name|timeout
argument_list|)
expr_stmt|;
else|#
directive|else
name|nfds
operator|=
name|select
argument_list|(
name|MAXDESC
argument_list|,
operator|&
name|Available
argument_list|,
literal|0
argument_list|,
operator|&
name|Exception
argument_list|,
operator|&
name|timeout
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
name|xerrno
operator|=
name|errno
expr_stmt|;
if|if
condition|(
name|fix_screen_hook
condition|)
call|(
modifier|*
name|fix_screen_hook
call|)
argument_list|()
expr_stmt|;
comment|/* Make C-g and alarm signals set flags again */
name|clear_waiting_for_input
argument_list|()
expr_stmt|;
comment|/* If we woke up due to SIGWINCH, actually change size now.  */
name|do_pending_window_change
argument_list|()
expr_stmt|;
if|if
condition|(
name|time_limit
operator|&&
name|nfds
operator|==
literal|0
condition|)
comment|/* timeout elapsed */
break|break;
if|if
condition|(
name|nfds
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|xerrno
operator|==
name|EINTR
condition|)
name|FD_ZERO
argument_list|(
operator|&
name|Available
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ALLIANT
comment|/* This happens for no known reason on ALLIANT. 	     I am guessing that this is the right response. -- RMS.  */
elseif|else
if|if
condition|(
name|xerrno
operator|==
name|EFAULT
condition|)
name|FD_ZERO
argument_list|(
operator|&
name|Available
argument_list|)
expr_stmt|;
endif|#
directive|endif
elseif|else
if|if
condition|(
name|xerrno
operator|==
name|EBADF
condition|)
ifdef|#
directive|ifdef
name|AIX
comment|/* AIX will return EBADF on a call to select involving a ptc if the 	     associated pts isn't open.  Since this will only happen just as 	     a child is dying, just ignore the situation -- SIGCHLD will come 	     along quite quickly, and after cleanup the ptc will no longer be 	     checked, so this error will stop recurring.  */
name|FD_ZERO
argument_list|(
operator|&
name|Available
argument_list|)
expr_stmt|;
comment|/* Cannot depend on values returned.  */
else|#
directive|else
comment|/* not AIX */
name|abort
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* not AIX */
else|else
name|error
argument_list|(
literal|"select error: %s"
argument_list|,
name|sys_errlist
index|[
name|xerrno
index|]
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|sun
elseif|else
if|if
condition|(
name|nfds
operator|>
literal|0
operator|&&
name|FD_ISSET
argument_list|(
literal|0
argument_list|,
operator|&
name|Available
argument_list|)
operator|&&
name|interrupt_input
condition|)
comment|/* System sometimes fails to deliver SIGIO.  */
name|kill
argument_list|(
name|getpid
argument_list|()
argument_list|,
name|SIGIO
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Check for keyboard input */
comment|/* If there is any, return immediately 	 to give it higher priority than subprocesses */
if|if
condition|(
name|read_kbd
operator|&&
name|detect_input_pending
argument_list|()
condition|)
break|break;
ifdef|#
directive|ifdef
name|vipc
comment|/* Check for connection from other process */
if|if
condition|(
name|FD_ISSET
argument_list|(
name|comm_server
argument_list|,
operator|&
name|Available
argument_list|)
condition|)
block|{
name|FD_CLR
argument_list|(
name|comm_server
argument_list|,
operator|&
name|Available
argument_list|)
expr_stmt|;
name|create_commchan
argument_list|()
expr_stmt|;
block|}
endif|#
directive|endif
endif|vipc
comment|/* Check for data from a process or a command channel */
for|for
control|(
name|channel
operator|=
literal|3
init|;
name|channel
operator|<
name|MAXDESC
condition|;
name|channel
operator|++
control|)
block|{
if|if
condition|(
name|FD_ISSET
argument_list|(
name|channel
argument_list|,
operator|&
name|Available
argument_list|)
condition|)
block|{
name|int
name|nread
decl_stmt|;
name|FD_CLR
argument_list|(
name|channel
argument_list|,
operator|&
name|Available
argument_list|)
expr_stmt|;
comment|/* If waiting for this channel, 		 arrange to return as soon as no more input 		 to be processed.  No more waiting.  */
if|if
condition|(
name|wait_channel
operator|==
name|channel
condition|)
block|{
name|wait_channel
operator|=
literal|0
expr_stmt|;
name|time_limit
operator|=
operator|-
literal|1
expr_stmt|;
block|}
name|proc
operator|=
name|chan_process
index|[
name|channel
index|]
expr_stmt|;
if|if
condition|(
name|NULL
argument_list|(
name|proc
argument_list|)
condition|)
continue|continue;
ifdef|#
directive|ifdef
name|vipc
comment|/* It's a command channel */
if|if
condition|(
operator|!
name|NULL
argument_list|(
name|XPROCESS
argument_list|(
name|proc
argument_list|)
operator|->
name|command_channel_p
argument_list|)
condition|)
block|{
name|ProcessCommChan
argument_list|(
name|channel
argument_list|,
name|proc
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
argument_list|(
name|XPROCESS
argument_list|(
name|proc
argument_list|)
operator|->
name|command_channel_p
argument_list|)
condition|)
block|{
comment|/* It has ceased to be a command channel! */
name|int
name|bytes_available
decl_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|channel
argument_list|,
name|FIONREAD
argument_list|,
operator|&
name|bytes_available
argument_list|)
operator|<
literal|0
condition|)
name|bytes_available
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|bytes_available
condition|)
name|FD_SET
argument_list|(
name|channel
argument_list|,
operator|&
name|Available
argument_list|)
expr_stmt|;
block|}
continue|continue;
block|}
endif|#
directive|endif
endif|vipc
comment|/* Read data from the process, starting with our 		 buffered-ahead character if we have one.  */
name|nread
operator|=
name|read_process_output
argument_list|(
name|proc
argument_list|,
name|channel
argument_list|)
expr_stmt|;
if|if
condition|(
name|nread
operator|>
literal|0
condition|)
block|{
comment|/* Since read_process_output can run a filter, 		     which can call accept-process-output, 		     don't try to read from any other processes 		     before doing the select again.  */
name|FD_ZERO
argument_list|(
operator|&
name|Available
argument_list|)
expr_stmt|;
if|if
condition|(
name|do_display
condition|)
name|redisplay_preserve_echo_area
argument_list|()
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|EWOULDBLOCK
elseif|else
if|if
condition|(
name|nread
operator|==
operator|-
literal|1
operator|&&
name|errno
operator|==
name|EWOULDBLOCK
condition|)
empty_stmt|;
else|#
directive|else
ifdef|#
directive|ifdef
name|O_NONBLOCK
elseif|else
if|if
condition|(
name|nread
operator|==
operator|-
literal|1
operator|&&
name|errno
operator|==
name|EAGAIN
condition|)
empty_stmt|;
else|#
directive|else
ifdef|#
directive|ifdef
name|O_NDELAY
elseif|else
if|if
condition|(
name|nread
operator|==
operator|-
literal|1
operator|&&
name|errno
operator|==
name|EAGAIN
condition|)
empty_stmt|;
comment|/* Note that we cannot distinguish between no input 		 available now and a closed pipe. 		 With luck, a closed pipe will be accompanied by 		 subprocess termination and SIGCHLD.  */
elseif|else
if|if
condition|(
name|nread
operator|==
literal|0
condition|)
empty_stmt|;
endif|#
directive|endif
comment|/* O_NDELAY */
endif|#
directive|endif
comment|/* O_NONBLOCK */
endif|#
directive|endif
comment|/* EWOULDBLOCK */
ifdef|#
directive|ifdef
name|HAVE_PTYS
comment|/* On some OSs with ptys, when the process on one end of 		 a pty exits, the other end gets an error reading with 		 errno = EIO instead of getting an EOF (0 bytes read). 		 Therefore, if we get an error reading and errno = 		 EIO, just continue, because the child process has 		 exited and should clean itself up soon (e.g. when we 		 get a SIGCHLD). */
elseif|else
if|if
condition|(
name|nread
operator|==
operator|-
literal|1
operator|&&
name|errno
operator|==
name|EIO
condition|)
empty_stmt|;
endif|#
directive|endif
comment|/* HAVE_PTYS */
comment|/* If we can detect process termination, don't consider the process    gone just because its pipe is closed.  */
ifdef|#
directive|ifdef
name|SIGCHLD
elseif|else
if|if
condition|(
name|nread
operator|==
literal|0
condition|)
empty_stmt|;
endif|#
directive|endif
else|else
block|{
comment|/* Preserve status of processes already terminated.  */
name|XSETINT
argument_list|(
name|XPROCESS
argument_list|(
name|proc
argument_list|)
operator|->
name|tick
argument_list|,
operator|++
name|process_tick
argument_list|)
expr_stmt|;
name|deactivate_process
argument_list|(
name|proc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|NULL
argument_list|(
name|XPROCESS
argument_list|(
name|proc
argument_list|)
operator|->
name|raw_status_low
argument_list|)
condition|)
name|update_status
argument_list|(
name|XPROCESS
argument_list|(
name|proc
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|EQ
argument_list|(
name|XPROCESS
argument_list|(
name|proc
argument_list|)
operator|->
name|status
argument_list|,
name|Qrun
argument_list|)
condition|)
name|XPROCESS
argument_list|(
name|proc
argument_list|)
operator|->
name|status
operator|=
name|Fcons
argument_list|(
name|Qexit
argument_list|,
name|Fcons
argument_list|(
name|make_number
argument_list|(
literal|256
argument_list|)
argument_list|,
name|Qnil
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* end for */
block|}
comment|/* end while */
if|#
directive|if
literal|0
comment|/* Resume periodic signals to poll for input, if necessary.  */
block|start_polling ();
endif|#
directive|endif
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* Actually call the filter.  This gets the information via variables    because internal_condition_case won't pass arguments.  */
end_comment

begin_function
name|Lisp_Object
name|run_filter
parameter_list|()
block|{
return|return
name|call2
argument_list|(
name|this_filter
argument_list|,
name|filter_process
argument_list|,
name|filter_string
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Read pending output from the process channel,    starting with our buffered-ahead character if we have one.    Yield number of characters read.     This function reads at most 1024 characters.    If you want to read all available subprocess output,    you must call it repeatedly until it returns zero.  */
end_comment

begin_macro
name|read_process_output
argument_list|(
argument|proc
argument_list|,
argument|channel
argument_list|)
end_macro

begin_decl_stmt
name|Lisp_Object
name|proc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|int
name|channel
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|nchars
decl_stmt|;
name|char
name|chars
index|[
literal|1024
index|]
decl_stmt|;
specifier|register
name|Lisp_Object
name|outstream
decl_stmt|;
specifier|register
name|struct
name|buffer
modifier|*
name|old
init|=
name|current_buffer
decl_stmt|;
specifier|register
name|struct
name|Lisp_Process
modifier|*
name|p
init|=
name|XPROCESS
argument_list|(
name|proc
argument_list|)
decl_stmt|;
specifier|register
name|int
name|opoint
decl_stmt|;
if|if
condition|(
name|proc_buffered_char
index|[
name|channel
index|]
operator|<
literal|0
condition|)
name|nchars
operator|=
name|read
argument_list|(
name|channel
argument_list|,
name|chars
argument_list|,
sizeof|sizeof
name|chars
argument_list|)
expr_stmt|;
else|else
block|{
name|chars
index|[
literal|0
index|]
operator|=
name|proc_buffered_char
index|[
name|channel
index|]
expr_stmt|;
name|proc_buffered_char
index|[
name|channel
index|]
operator|=
operator|-
literal|1
expr_stmt|;
name|nchars
operator|=
name|read
argument_list|(
name|channel
argument_list|,
name|chars
operator|+
literal|1
argument_list|,
sizeof|sizeof
name|chars
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|nchars
operator|<
literal|0
condition|)
name|nchars
operator|=
literal|1
expr_stmt|;
else|else
name|nchars
operator|=
name|nchars
operator|+
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|nchars
operator|<=
literal|0
condition|)
return|return
name|nchars
return|;
name|outstream
operator|=
name|p
operator|->
name|filter
expr_stmt|;
if|if
condition|(
operator|!
name|NULL
argument_list|(
name|outstream
argument_list|)
condition|)
block|{
name|int
name|count
init|=
name|specpdl_ptr
operator|-
name|specpdl
decl_stmt|;
name|specbind
argument_list|(
name|Qinhibit_quit
argument_list|,
name|Qt
argument_list|)
expr_stmt|;
name|this_filter
operator|=
name|outstream
expr_stmt|;
name|filter_process
operator|=
name|proc
expr_stmt|;
name|filter_string
operator|=
name|make_string
argument_list|(
name|chars
argument_list|,
name|nchars
argument_list|)
expr_stmt|;
name|call2
argument_list|(
name|this_filter
argument_list|,
name|filter_process
argument_list|,
name|filter_string
argument_list|)
expr_stmt|;
comment|/*   internal_condition_case (run_filter, Qerror, Fidentity);  */
name|unbind_to
argument_list|(
name|count
argument_list|)
expr_stmt|;
return|return
name|nchars
return|;
block|}
comment|/* If no filter, write into buffer if it isn't dead.  */
if|if
condition|(
operator|!
name|NULL
argument_list|(
name|p
operator|->
name|buffer
argument_list|)
operator|&&
operator|!
name|NULL
argument_list|(
name|XBUFFER
argument_list|(
name|p
operator|->
name|buffer
argument_list|)
operator|->
name|name
argument_list|)
condition|)
block|{
name|Lisp_Object
name|tem
decl_stmt|;
name|Fset_buffer
argument_list|(
name|p
operator|->
name|buffer
argument_list|)
expr_stmt|;
name|opoint
operator|=
name|point
expr_stmt|;
comment|/* Insert new output into buffer 	 at the current end-of-output marker, 	 thus preserving logical ordering of input and output.  */
if|if
condition|(
name|XMARKER
argument_list|(
name|p
operator|->
name|mark
argument_list|)
operator|->
name|buffer
condition|)
name|SET_PT
argument_list|(
name|marker_position
argument_list|(
name|p
operator|->
name|mark
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|SET_PT
argument_list|(
name|ZV
argument_list|)
expr_stmt|;
if|if
condition|(
name|point
operator|<=
name|opoint
condition|)
name|opoint
operator|+=
name|nchars
expr_stmt|;
name|tem
operator|=
name|current_buffer
operator|->
name|read_only
expr_stmt|;
name|current_buffer
operator|->
name|read_only
operator|=
name|Qnil
expr_stmt|;
name|insert
argument_list|(
name|chars
argument_list|,
name|nchars
argument_list|)
expr_stmt|;
name|current_buffer
operator|->
name|read_only
operator|=
name|tem
expr_stmt|;
name|Fset_marker
argument_list|(
name|p
operator|->
name|mark
argument_list|,
name|make_number
argument_list|(
name|point
argument_list|)
argument_list|,
name|p
operator|->
name|buffer
argument_list|)
expr_stmt|;
name|update_mode_lines
operator|++
expr_stmt|;
name|SET_PT
argument_list|(
name|opoint
argument_list|)
expr_stmt|;
name|set_buffer_internal
argument_list|(
name|old
argument_list|)
expr_stmt|;
block|}
return|return
name|nchars
return|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"waiting-for-user-input-p"
argument_list|,
argument|Fwaiting_for_user_input_p
argument_list|,
argument|Swaiting_for_user_input_p
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|"Returns non-NIL if emacs is waiting for input from the user.\n\ This is intended for use by asynchronous process output filters and sentinels."
argument_list|)
end_macro

begin_expr_stmt
operator|(
operator|)
block|{
return|return
operator|(
operator|(
name|waiting_for_user_input_p
operator|)
operator|?
name|Qt
operator|:
name|Qnil
operator|)
return|;
block|}
end_expr_stmt

begin_escape
end_escape

begin_comment
comment|/* Sending data to subprocess */
end_comment

begin_decl_stmt
name|jmp_buf
name|send_process_frame
decl_stmt|;
end_decl_stmt

begin_macro
name|send_process_trap
argument_list|()
end_macro

begin_block
block|{
ifdef|#
directive|ifdef
name|BSD4_1
name|sigrelse
argument_list|(
name|SIGPIPE
argument_list|)
expr_stmt|;
name|sigrelse
argument_list|(
name|SIGALRM
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* BSD4_1 */
name|longjmp
argument_list|(
name|send_process_frame
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|send_process
argument_list|(
argument|proc
argument_list|,
argument|buf
argument_list|,
argument|len
argument_list|)
end_macro

begin_decl_stmt
name|Lisp_Object
name|proc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|buf
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|len
decl_stmt|;
end_decl_stmt

begin_block
block|{
comment|/* Don't use register vars; longjmp can lose them.  */
name|int
name|rv
decl_stmt|;
name|unsigned
name|char
modifier|*
name|procname
init|=
name|XSTRING
argument_list|(
name|XPROCESS
argument_list|(
name|proc
argument_list|)
operator|->
name|name
argument_list|)
operator|->
name|data
decl_stmt|;
if|if
condition|(
operator|!
name|NULL
argument_list|(
name|XPROCESS
argument_list|(
name|proc
argument_list|)
operator|->
name|raw_status_low
argument_list|)
condition|)
name|update_status
argument_list|(
name|XPROCESS
argument_list|(
name|proc
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|EQ
argument_list|(
name|XPROCESS
argument_list|(
name|proc
argument_list|)
operator|->
name|status
argument_list|,
name|Qrun
argument_list|)
condition|)
name|error
argument_list|(
literal|"Process %s not running"
argument_list|,
name|procname
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|setjmp
argument_list|(
name|send_process_frame
argument_list|)
condition|)
while|while
condition|(
name|len
operator|>
literal|0
condition|)
block|{
name|signal
argument_list|(
name|SIGPIPE
argument_list|,
name|send_process_trap
argument_list|)
expr_stmt|;
name|rv
operator|=
name|write
argument_list|(
name|XFASTINT
argument_list|(
name|XPROCESS
argument_list|(
name|proc
argument_list|)
operator|->
name|outfd
argument_list|)
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGPIPE
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|<
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|EWOULDBLOCK
if|if
condition|(
name|errno
operator|==
name|EWOULDBLOCK
condition|)
block|{
comment|/* It would be nice to accept process output here, 		   but that is difficult.  For example, it could 		   garbage what we are sending if that is from a buffer.  */
name|immediate_quit
operator|=
literal|1
expr_stmt|;
name|QUIT
expr_stmt|;
name|sleep
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|immediate_quit
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
endif|#
directive|endif
name|report_file_error
argument_list|(
literal|"writing to process"
argument_list|,
name|Fcons
argument_list|(
name|proc
argument_list|,
name|Qnil
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|buf
operator|+=
name|rv
expr_stmt|;
name|len
operator|-=
name|rv
expr_stmt|;
block|}
else|else
block|{
name|XPROCESS
argument_list|(
name|proc
argument_list|)
operator|->
name|raw_status_low
operator|=
name|Qnil
expr_stmt|;
name|XPROCESS
argument_list|(
name|proc
argument_list|)
operator|->
name|raw_status_high
operator|=
name|Qnil
expr_stmt|;
name|XPROCESS
argument_list|(
name|proc
argument_list|)
operator|->
name|status
operator|=
name|Fcons
argument_list|(
name|Qexit
argument_list|,
name|Fcons
argument_list|(
name|make_number
argument_list|(
literal|256
argument_list|)
argument_list|,
name|Qnil
argument_list|)
argument_list|)
expr_stmt|;
name|XSETINT
argument_list|(
name|XPROCESS
argument_list|(
name|proc
argument_list|)
operator|->
name|tick
argument_list|,
operator|++
name|process_tick
argument_list|)
expr_stmt|;
name|deactivate_process
argument_list|(
name|proc
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"SIGPIPE raised on process %s; closed it"
argument_list|,
name|procname
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"process-send-region"
argument_list|,
argument|Fprocess_send_region
argument_list|,
argument|Sprocess_send_region
argument_list|,
literal|3
argument_list|,
literal|3
argument_list|,
literal|0
argument_list|,
literal|"Send current contents of region as input to PROCESS.\n\ PROCESS may be a process name.\n\ Called from program, takes three arguments, PROCESS, START and END."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|process
operator|,
name|start
operator|,
name|end
operator|)
name|Lisp_Object
name|process
operator|,
name|start
operator|,
name|end
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|Lisp_Object
name|proc
decl_stmt|;
name|int
name|start1
decl_stmt|;
name|proc
operator|=
name|get_process
argument_list|(
name|process
argument_list|)
expr_stmt|;
name|validate_region
argument_list|(
operator|&
name|start
argument_list|,
operator|&
name|end
argument_list|)
expr_stmt|;
if|if
condition|(
name|XINT
argument_list|(
name|start
argument_list|)
operator|<
name|GPT
operator|&&
name|XINT
argument_list|(
name|end
argument_list|)
operator|>
name|GPT
condition|)
name|move_gap
argument_list|(
name|start
argument_list|)
expr_stmt|;
name|start1
operator|=
name|XINT
argument_list|(
name|start
argument_list|)
expr_stmt|;
name|send_process
argument_list|(
name|proc
argument_list|,
operator|&
name|FETCH_CHAR
argument_list|(
name|start1
argument_list|)
argument_list|,
name|XINT
argument_list|(
name|end
argument_list|)
operator|-
name|XINT
argument_list|(
name|start
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|Qnil
return|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"process-send-string"
argument_list|,
argument|Fprocess_send_string
argument_list|,
argument|Sprocess_send_string
argument_list|,
literal|2
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
literal|"Send PROCESS the contents of STRING as input.\n\ PROCESS may be a process name."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|process
operator|,
name|string
operator|)
name|Lisp_Object
name|process
operator|,
name|string
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|Lisp_Object
name|proc
decl_stmt|;
name|CHECK_STRING
argument_list|(
name|string
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|proc
operator|=
name|get_process
argument_list|(
name|process
argument_list|)
expr_stmt|;
name|send_process
argument_list|(
name|proc
argument_list|,
name|XSTRING
argument_list|(
name|string
argument_list|)
operator|->
name|data
argument_list|,
name|XSTRING
argument_list|(
name|string
argument_list|)
operator|->
name|size
argument_list|)
expr_stmt|;
return|return
name|Qnil
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* send a signal number SIGNO to PROCESS.    CURRENT_GROUP means send to the process group that currently owns    the terminal being used to communicate with PROCESS.    This is used for various commands in shell mode.    If NOMSG is zero, insert signal-announcements into process's buffers    right away.  */
end_comment

begin_macro
name|process_send_signal
argument_list|(
argument|process
argument_list|,
argument|signo
argument_list|,
argument|current_group
argument_list|,
argument|nomsg
argument_list|)
end_macro

begin_decl_stmt
name|Lisp_Object
name|process
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|signo
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Lisp_Object
name|current_group
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|nomsg
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|Lisp_Object
name|proc
decl_stmt|;
specifier|register
name|struct
name|Lisp_Process
modifier|*
name|p
decl_stmt|;
name|int
name|gid
decl_stmt|;
name|proc
operator|=
name|get_process
argument_list|(
name|process
argument_list|)
expr_stmt|;
name|p
operator|=
name|XPROCESS
argument_list|(
name|proc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|EQ
argument_list|(
name|p
operator|->
name|childp
argument_list|,
name|Qt
argument_list|)
condition|)
name|error
argument_list|(
literal|"Process %s is not a subprocess"
argument_list|,
name|XSTRING
argument_list|(
name|p
operator|->
name|name
argument_list|)
operator|->
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|XFASTINT
argument_list|(
name|p
operator|->
name|infd
argument_list|)
condition|)
name|error
argument_list|(
literal|"Process %s is not active"
argument_list|,
name|XSTRING
argument_list|(
name|p
operator|->
name|name
argument_list|)
operator|->
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
argument_list|(
name|p
operator|->
name|pty_flag
argument_list|)
condition|)
name|current_group
operator|=
name|Qnil
expr_stmt|;
ifdef|#
directive|ifdef
name|TIOCGPGRP
comment|/* Not sure about this! (fnf) */
comment|/* If we are using pgrps, get a pgrp number and make it negative.  */
if|if
condition|(
operator|!
name|NULL
argument_list|(
name|current_group
argument_list|)
condition|)
block|{
name|ioctl
argument_list|(
name|XFASTINT
argument_list|(
name|p
operator|->
name|infd
argument_list|)
argument_list|,
name|TIOCGPGRP
argument_list|,
operator|&
name|gid
argument_list|)
expr_stmt|;
name|gid
operator|=
operator|-
name|gid
expr_stmt|;
block|}
else|else
name|gid
operator|=
operator|-
name|XFASTINT
argument_list|(
name|p
operator|->
name|pid
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* not using pgrps */
comment|/* Can't select pgrps on this system, so we know that      the child itself heads the pgrp.  */
name|gid
operator|=
operator|-
name|XFASTINT
argument_list|(
name|p
operator|->
name|pid
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* not using pgrps */
switch|switch
condition|(
name|signo
condition|)
block|{
ifdef|#
directive|ifdef
name|SIGCONT
case|case
name|SIGCONT
case|:
name|p
operator|->
name|raw_status_low
operator|=
name|Qnil
expr_stmt|;
name|p
operator|->
name|raw_status_high
operator|=
name|Qnil
expr_stmt|;
name|p
operator|->
name|status
operator|=
name|Qrun
expr_stmt|;
name|XSETINT
argument_list|(
name|p
operator|->
name|tick
argument_list|,
operator|++
name|process_tick
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|nomsg
condition|)
name|status_notify
argument_list|()
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
name|SIGINT
case|:
case|case
name|SIGQUIT
case|:
case|case
name|SIGKILL
case|:
name|flush_pending_output
argument_list|(
name|XFASTINT
argument_list|(
name|p
operator|->
name|infd
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* gid may be a pid, or minus a pgrp's number */
ifdef|#
directive|ifdef
name|TIOCSIGSEND
if|if
condition|(
operator|!
name|NULL
argument_list|(
name|current_group
argument_list|)
condition|)
name|ioctl
argument_list|(
name|XFASTINT
argument_list|(
name|p
operator|->
name|infd
argument_list|)
argument_list|,
name|TIOCSIGSEND
argument_list|,
name|signo
argument_list|)
expr_stmt|;
else|else
block|{
name|gid
operator|=
operator|-
name|XFASTINT
argument_list|(
name|p
operator|->
name|pid
argument_list|)
expr_stmt|;
name|kill
argument_list|(
name|gid
argument_list|,
name|signo
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
comment|/* no TIOCSIGSEND */
ifdef|#
directive|ifdef
name|BSD
comment|/* On bsd, [man says] kill does not accept a negative number to kill a pgrp.      Must do that differently.  */
name|killpg
argument_list|(
operator|-
name|gid
argument_list|,
name|signo
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* Not BSD.  */
name|kill
argument_list|(
name|gid
argument_list|,
name|signo
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Not BSD.  */
endif|#
directive|endif
comment|/* no TIOCSIGSEND */
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"interrupt-process"
argument_list|,
argument|Finterrupt_process
argument_list|,
argument|Sinterrupt_process
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
literal|"Interrupt process PROCESS.  May be process or name of one.\n\ Nil or no arg means current buffer's process.\n\ Second arg CURRENT-GROUP non-nil means send signal to\n\ the current process-group of the process's controlling terminal\n\ rather than to the process's own process group.\n\ If the process is a shell, this means interrupt current subjob\n\ rather than the shell."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|process
operator|,
name|current_group
operator|)
name|Lisp_Object
name|process
operator|,
name|current_group
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|process_send_signal
argument_list|(
name|process
argument_list|,
name|SIGINT
argument_list|,
name|current_group
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|process
return|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"kill-process"
argument_list|,
argument|Fkill_process
argument_list|,
argument|Skill_process
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
literal|"Kill process PROCESS.  May be process or name of one.\n\ See function interrupt-process for more details on usage."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|process
operator|,
name|current_group
operator|)
name|Lisp_Object
name|process
operator|,
name|current_group
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|process_send_signal
argument_list|(
name|process
argument_list|,
name|SIGKILL
argument_list|,
name|current_group
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|process
return|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"quit-process"
argument_list|,
argument|Fquit_process
argument_list|,
argument|Squit_process
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
literal|"Send QUIT signal to process PROCESS.  May be process or name of one.\n\ See function interrupt-process for more details on usage."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|process
operator|,
name|current_group
operator|)
name|Lisp_Object
name|process
operator|,
name|current_group
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|process_send_signal
argument_list|(
name|process
argument_list|,
name|SIGQUIT
argument_list|,
name|current_group
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|process
return|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"stop-process"
argument_list|,
argument|Fstop_process
argument_list|,
argument|Sstop_process
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
literal|"Stop process PROCESS.  May be process or name of one.\n\ See function interrupt-process for more details on usage."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|process
operator|,
name|current_group
operator|)
name|Lisp_Object
name|process
operator|,
name|current_group
expr_stmt|;
end_expr_stmt

begin_block
block|{
ifndef|#
directive|ifndef
name|SIGTSTP
name|error
argument_list|(
literal|"no SIGTSTP support"
argument_list|)
expr_stmt|;
else|#
directive|else
name|process_send_signal
argument_list|(
name|process
argument_list|,
name|SIGTSTP
argument_list|,
name|current_group
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|process
return|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"continue-process"
argument_list|,
argument|Fcontinue_process
argument_list|,
argument|Scontinue_process
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
literal|"Continue process PROCESS.  May be process or name of one.\n\ See function interrupt-process for more details on usage."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|process
operator|,
name|current_group
operator|)
name|Lisp_Object
name|process
operator|,
name|current_group
expr_stmt|;
end_expr_stmt

begin_block
block|{
ifdef|#
directive|ifdef
name|SIGCONT
name|process_send_signal
argument_list|(
name|process
argument_list|,
name|SIGCONT
argument_list|,
name|current_group
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|#
directive|else
name|error
argument_list|(
literal|"no SIGCONT support"
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|process
return|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"process-send-eof"
argument_list|,
argument|Fprocess_send_eof
argument_list|,
argument|Sprocess_send_eof
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|"Make PROCESS see end-of-file in its input.\n\ Eof comes after any text already sent to it.\n\ nil or no arg means current buffer's process."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|process
operator|)
name|Lisp_Object
name|process
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|Lisp_Object
name|proc
decl_stmt|;
name|proc
operator|=
name|get_process
argument_list|(
name|process
argument_list|)
expr_stmt|;
comment|/* Sending a zero-length record is supposed to mean eof      when TIOCREMOTE is turned on.  */
ifdef|#
directive|ifdef
name|DID_REMOTE
block|{
name|char
name|buf
index|[
literal|1
index|]
decl_stmt|;
name|write
argument_list|(
name|XFASTINT
argument_list|(
name|XPROCESS
argument_list|(
name|proc
argument_list|)
operator|->
name|outfd
argument_list|)
argument_list|,
name|buf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
comment|/* did not do TOICREMOTE */
name|send_process
argument_list|(
name|proc
argument_list|,
literal|"\004"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* did not do TOICREMOTE */
return|return
name|process
return|;
block|}
end_block

begin_comment
comment|/* Kill all processes associated with `buffer'.  If `buffer' is nil, kill all processes  */
end_comment

begin_macro
name|kill_buffer_processes
argument_list|(
argument|buffer
argument_list|)
end_macro

begin_decl_stmt
name|Lisp_Object
name|buffer
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|Lisp_Object
name|tail
decl_stmt|,
name|proc
decl_stmt|;
for|for
control|(
name|tail
operator|=
name|Vprocess_alist
init|;
name|XGCTYPE
argument_list|(
name|tail
argument_list|)
operator|==
name|Lisp_Cons
condition|;
name|tail
operator|=
name|XCONS
argument_list|(
name|tail
argument_list|)
operator|->
name|cdr
control|)
block|{
name|proc
operator|=
name|XCONS
argument_list|(
name|XCONS
argument_list|(
name|tail
argument_list|)
operator|->
name|car
argument_list|)
operator|->
name|cdr
expr_stmt|;
if|if
condition|(
name|XGCTYPE
argument_list|(
name|proc
argument_list|)
operator|==
name|Lisp_Process
operator|&&
operator|(
name|NULL
argument_list|(
name|buffer
argument_list|)
operator|||
name|EQ
argument_list|(
name|XPROCESS
argument_list|(
name|proc
argument_list|)
operator|->
name|buffer
argument_list|,
name|buffer
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|NETCONN_P
argument_list|(
name|proc
argument_list|)
condition|)
name|deactivate_process
argument_list|(
name|proc
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|XFASTINT
argument_list|(
name|XPROCESS
argument_list|(
name|proc
argument_list|)
operator|->
name|infd
argument_list|)
condition|)
name|process_send_signal
argument_list|(
name|proc
argument_list|,
name|SIGHUP
argument_list|,
name|Qnil
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* On receipt of a signal that a child status has changed,  loop asking about children with changed statuses until  the system says there are no more.    All we do is change the status;  we do not run sentinels or print notifications.  That is saved for the next time keyboard input is done,  in order to avoid timing errors.  */
end_comment

begin_comment
comment|/** WARNING: this can be called during garbage collection.  Therefore, it must not be fooled by the presence of mark bits in  Lisp objects.  */
end_comment

begin_comment
comment|/** USG WARNING:  Although it is not obvious from the documentation  in signal(2), on a USG system the SIGCLD handler MUST NOT call  signal() before executing at least one wait(), otherwise the handler  will be called again, resulting in an infinite loop.  The relevant  portion of the documentation reads "SIGCLD signals will be queued  and the signal-catching function will be continually reentered until  the queue is empty".  Invoking signal() causes the kernel to reexamine  the SIGCLD queue.   Fred Fish, UniSoft Systems Inc. */
end_comment

begin_macro
name|sigchld_handler
argument_list|(
argument|signo
argument_list|)
end_macro

begin_decl_stmt
name|int
name|signo
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|old_errno
init|=
name|errno
decl_stmt|;
name|Lisp_Object
name|proc
decl_stmt|;
specifier|register
name|struct
name|Lisp_Process
modifier|*
name|p
decl_stmt|;
ifdef|#
directive|ifdef
name|BSD4_1
specifier|extern
name|int
name|synch_process_pid
decl_stmt|;
specifier|extern
name|int
name|sigheld
decl_stmt|;
name|sigheld
operator||=
name|sigbit
argument_list|(
name|SIGCHLD
argument_list|)
expr_stmt|;
endif|#
directive|endif
while|while
condition|(
literal|1
condition|)
block|{
specifier|register
name|int
name|pid
decl_stmt|;
name|WAITTYPE
name|w
decl_stmt|;
name|Lisp_Object
name|tail
decl_stmt|;
ifdef|#
directive|ifdef
name|WNOHANG
ifndef|#
directive|ifndef
name|WUNTRACED
define|#
directive|define
name|WUNTRACED
value|0
endif|#
directive|endif
comment|/* no WUNTRACED */
comment|/* Keep trying to get a status until we get a definitive result.  */
do|do
block|{
name|errno
operator|=
literal|0
expr_stmt|;
name|pid
operator|=
name|wait3
argument_list|(
operator|&
name|w
argument_list|,
name|WNOHANG
operator||
name|WUNTRACED
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|pid
operator|<=
literal|0
operator|&&
name|errno
operator|==
name|EINTR
condition|)
do|;
if|if
condition|(
name|pid
operator|<=
literal|0
condition|)
block|{
comment|/* A real failure.  We have done all our job, so return.  */
comment|/* USG systems forget handlers when they are used; 	     must reestablish each time */
ifdef|#
directive|ifdef
name|USG
name|signal
argument_list|(
name|signo
argument_list|,
name|sigchld_handler
argument_list|)
expr_stmt|;
comment|/* WARNING - must come after wait3() */
endif|#
directive|endif
ifdef|#
directive|ifdef
name|BSD4_1
name|sigheld
operator|&=
operator|~
name|sigbit
argument_list|(
name|SIGCHLD
argument_list|)
expr_stmt|;
name|sigrelse
argument_list|(
name|SIGCHLD
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|errno
operator|=
name|old_errno
expr_stmt|;
return|return;
block|}
else|#
directive|else
name|pid
operator|=
name|wait
argument_list|(
operator|&
name|w
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* no WNOHANG */
ifdef|#
directive|ifdef
name|BSD4_1
if|if
condition|(
name|synch_process_pid
operator|==
name|pid
condition|)
name|synch_process_pid
operator|=
literal|0
expr_stmt|;
comment|/* Zero it to show process has died. */
endif|#
directive|endif
comment|/* Find the process that signaled us, and record its status.  */
name|p
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|tail
operator|=
name|Vprocess_alist
init|;
name|XSYMBOL
argument_list|(
name|tail
argument_list|)
operator|!=
name|XSYMBOL
argument_list|(
name|Qnil
argument_list|)
condition|;
name|tail
operator|=
name|XCONS
argument_list|(
name|tail
argument_list|)
operator|->
name|cdr
control|)
block|{
name|proc
operator|=
name|XCONS
argument_list|(
name|XCONS
argument_list|(
name|tail
argument_list|)
operator|->
name|car
argument_list|)
operator|->
name|cdr
expr_stmt|;
name|p
operator|=
name|XPROCESS
argument_list|(
name|proc
argument_list|)
expr_stmt|;
if|if
condition|(
name|EQ
argument_list|(
name|p
operator|->
name|childp
argument_list|,
name|Qt
argument_list|)
operator|&&
name|XFASTINT
argument_list|(
name|p
operator|->
name|pid
argument_list|)
operator|==
name|pid
condition|)
break|break;
name|p
operator|=
literal|0
expr_stmt|;
block|}
comment|/* If we don't recognize the pid number, 	 look for a process being created.  */
if|if
condition|(
name|p
operator|==
literal|0
condition|)
for|for
control|(
name|tail
operator|=
name|Vprocess_alist
init|;
name|XSYMBOL
argument_list|(
name|tail
argument_list|)
operator|!=
name|XSYMBOL
argument_list|(
name|Qnil
argument_list|)
condition|;
name|tail
operator|=
name|XCONS
argument_list|(
name|tail
argument_list|)
operator|->
name|cdr
control|)
block|{
name|proc
operator|=
name|XCONS
argument_list|(
name|XCONS
argument_list|(
name|tail
argument_list|)
operator|->
name|car
argument_list|)
operator|->
name|cdr
expr_stmt|;
name|p
operator|=
name|XPROCESS
argument_list|(
name|proc
argument_list|)
expr_stmt|;
if|if
condition|(
name|XINT
argument_list|(
name|p
operator|->
name|pid
argument_list|)
operator|==
operator|-
literal|1
condition|)
break|break;
name|p
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Change the status of the process that was found.  */
if|if
condition|(
name|p
operator|!=
literal|0
condition|)
block|{
union|union
block|{
name|int
name|i
decl_stmt|;
name|WAITTYPE
name|wt
decl_stmt|;
block|}
name|u
union|;
name|XSETINT
argument_list|(
name|p
operator|->
name|tick
argument_list|,
operator|++
name|process_tick
argument_list|)
expr_stmt|;
name|u
operator|.
name|wt
operator|=
name|w
expr_stmt|;
name|XFASTINT
argument_list|(
name|p
operator|->
name|raw_status_low
argument_list|)
operator|=
name|u
operator|.
name|i
operator|&
literal|0xffff
expr_stmt|;
name|XFASTINT
argument_list|(
name|p
operator|->
name|raw_status_high
argument_list|)
operator|=
name|u
operator|.
name|i
operator|>>
literal|16
expr_stmt|;
comment|/* If process has terminated, stop waiting for its output.  */
if|if
condition|(
name|WIFSIGNALED
argument_list|(
name|w
argument_list|)
operator|||
name|WIFEXITED
argument_list|(
name|w
argument_list|)
condition|)
if|if
condition|(
name|p
operator|->
name|infd
condition|)
name|FD_CLR
argument_list|(
name|p
operator|->
name|infd
argument_list|,
operator|&
name|input_wait_mask
argument_list|)
expr_stmt|;
block|}
comment|/* On some systems, we must return right away. 	 If any more processes want to signal us, we will 	 get another signal. 	 Otherwise (on systems that have WNOHANG), loop around 	 to use up all the processes that have something to tell us.  */
if|#
directive|if
name|defined
argument_list|(
name|USG
argument_list|)
operator|&&
operator|!
operator|(
name|defined
argument_list|(
name|HPUX
argument_list|)
operator|&&
name|defined
argument_list|(
name|WNOHANG
argument_list|)
operator|)
ifdef|#
directive|ifdef
name|USG
name|signal
argument_list|(
name|signo
argument_list|,
name|sigchld_handler
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|errno
operator|=
name|old_errno
expr_stmt|;
return|return;
endif|#
directive|endif
comment|/* USG, but not HPUX with WNOHANG */
block|}
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* Report all recent events of a change in process status    (either run the sentinel or output a message).    This is done while Emacs is waiting for keyboard input.  */
end_comment

begin_macro
name|status_notify
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|Lisp_Object
name|tail
decl_stmt|,
name|proc
decl_stmt|,
name|buffer
decl_stmt|;
for|for
control|(
name|tail
operator|=
name|Vprocess_alist
init|;
operator|!
name|NULL
argument_list|(
name|tail
argument_list|)
condition|;
name|tail
operator|=
name|Fcdr
argument_list|(
name|tail
argument_list|)
control|)
block|{
name|Lisp_Object
name|symbol
decl_stmt|,
name|msg
decl_stmt|;
specifier|register
name|struct
name|Lisp_Process
modifier|*
name|p
decl_stmt|;
name|proc
operator|=
name|Fcdr
argument_list|(
name|Fcar
argument_list|(
name|tail
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|=
name|XPROCESS
argument_list|(
name|proc
argument_list|)
expr_stmt|;
if|if
condition|(
name|XINT
argument_list|(
name|p
operator|->
name|tick
argument_list|)
operator|!=
name|XINT
argument_list|(
name|p
operator|->
name|update_tick
argument_list|)
condition|)
block|{
name|struct
name|gcpro
name|gcpro1
decl_stmt|;
name|XSETINT
argument_list|(
name|p
operator|->
name|update_tick
argument_list|,
name|XINT
argument_list|(
name|p
operator|->
name|tick
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If process is still active, read any output that remains.  */
if|if
condition|(
name|XFASTINT
argument_list|(
name|p
operator|->
name|infd
argument_list|)
condition|)
while|while
condition|(
name|read_process_output
argument_list|(
name|proc
argument_list|,
name|XFASTINT
argument_list|(
name|p
operator|->
name|infd
argument_list|)
argument_list|)
operator|>
literal|0
condition|)
empty_stmt|;
name|buffer
operator|=
name|p
operator|->
name|buffer
expr_stmt|;
comment|/* Get the text to use for the message.  */
if|if
condition|(
operator|!
name|NULL
argument_list|(
name|p
operator|->
name|raw_status_low
argument_list|)
condition|)
name|update_status
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|msg
operator|=
name|status_message
argument_list|(
name|p
operator|->
name|status
argument_list|)
expr_stmt|;
name|GCPRO1
argument_list|(
name|msg
argument_list|)
expr_stmt|;
comment|/* If process is terminated, deactivate it or delete it.  */
name|symbol
operator|=
name|p
operator|->
name|status
expr_stmt|;
if|if
condition|(
name|XTYPE
argument_list|(
name|p
operator|->
name|status
argument_list|)
operator|==
name|Lisp_Cons
condition|)
name|symbol
operator|=
name|XCONS
argument_list|(
name|p
operator|->
name|status
argument_list|)
operator|->
name|car
expr_stmt|;
if|if
condition|(
name|EQ
argument_list|(
name|symbol
argument_list|,
name|Qsignal
argument_list|)
operator|||
name|EQ
argument_list|(
name|symbol
argument_list|,
name|Qexit
argument_list|)
operator|||
name|EQ
argument_list|(
name|symbol
argument_list|,
name|Qclosed
argument_list|)
condition|)
block|{
if|if
condition|(
name|delete_exited_processes
condition|)
name|remove_process
argument_list|(
name|proc
argument_list|)
expr_stmt|;
else|else
name|deactivate_process
argument_list|(
name|proc
argument_list|)
expr_stmt|;
block|}
name|UNGCPRO
expr_stmt|;
comment|/* Now output the message suitably.  */
if|if
condition|(
operator|!
name|NULL
argument_list|(
name|p
operator|->
name|sentinel
argument_list|)
condition|)
name|exec_sentinel
argument_list|(
name|proc
argument_list|,
name|msg
argument_list|)
expr_stmt|;
comment|/* Don't bother with a message in the buffer 	     when a process becomes runnable.  */
elseif|else
if|if
condition|(
operator|!
name|EQ
argument_list|(
name|symbol
argument_list|,
name|Qrun
argument_list|)
operator|&&
operator|!
name|NULL
argument_list|(
name|buffer
argument_list|)
condition|)
block|{
name|Lisp_Object
name|ro
init|=
name|XBUFFER
argument_list|(
name|buffer
argument_list|)
operator|->
name|read_only
decl_stmt|;
name|Lisp_Object
name|tem
decl_stmt|;
name|struct
name|buffer
modifier|*
name|old
init|=
name|current_buffer
decl_stmt|;
name|int
name|opoint
decl_stmt|;
comment|/* Avoid error if buffer is deleted 		 (probably that's why the process is dead, too) */
if|if
condition|(
name|NULL
argument_list|(
name|XBUFFER
argument_list|(
name|buffer
argument_list|)
operator|->
name|name
argument_list|)
condition|)
continue|continue;
name|Fset_buffer
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
name|opoint
operator|=
name|point
expr_stmt|;
comment|/* Insert new output into buffer 		 at the current end-of-output marker, 		 thus preserving logical ordering of input and output.  */
if|if
condition|(
name|XMARKER
argument_list|(
name|p
operator|->
name|mark
argument_list|)
operator|->
name|buffer
condition|)
name|SET_PT
argument_list|(
name|marker_position
argument_list|(
name|p
operator|->
name|mark
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|SET_PT
argument_list|(
name|ZV
argument_list|)
expr_stmt|;
if|if
condition|(
name|point
operator|<=
name|opoint
condition|)
name|opoint
operator|+=
name|XSTRING
argument_list|(
name|msg
argument_list|)
operator|->
name|size
operator|+
name|XSTRING
argument_list|(
name|p
operator|->
name|name
argument_list|)
operator|->
name|size
operator|+
literal|10
expr_stmt|;
name|tem
operator|=
name|current_buffer
operator|->
name|read_only
expr_stmt|;
name|current_buffer
operator|->
name|read_only
operator|=
name|Qnil
expr_stmt|;
name|GCPRO1
argument_list|(
name|msg
argument_list|)
expr_stmt|;
name|InsStr
argument_list|(
literal|"\nProcess "
argument_list|)
expr_stmt|;
name|Finsert
argument_list|(
literal|1
argument_list|,
operator|&
name|p
operator|->
name|name
argument_list|)
expr_stmt|;
name|InsStr
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
name|Finsert
argument_list|(
literal|1
argument_list|,
operator|&
name|msg
argument_list|)
expr_stmt|;
name|current_buffer
operator|->
name|read_only
operator|=
name|tem
expr_stmt|;
name|Fset_marker
argument_list|(
name|p
operator|->
name|mark
argument_list|,
name|make_number
argument_list|(
name|point
argument_list|)
argument_list|,
name|p
operator|->
name|buffer
argument_list|)
expr_stmt|;
name|UNGCPRO
expr_stmt|;
name|SET_PT
argument_list|(
name|opoint
argument_list|)
expr_stmt|;
name|set_buffer_internal
argument_list|(
name|old
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* end for */
name|update_mode_lines
operator|++
expr_stmt|;
comment|/* in case buffers use %s in mode-line-format */
name|redisplay_preserve_echo_area
argument_list|()
expr_stmt|;
name|update_tick
operator|=
name|process_tick
expr_stmt|;
block|}
end_block

begin_macro
name|exec_sentinel
argument_list|(
argument|proc
argument_list|,
argument|reason
argument_list|)
end_macro

begin_decl_stmt
name|Lisp_Object
name|proc
decl_stmt|,
name|reason
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|Lisp_Object
name|sentinel
decl_stmt|;
specifier|register
name|struct
name|Lisp_Process
modifier|*
name|p
init|=
name|XPROCESS
argument_list|(
name|proc
argument_list|)
decl_stmt|;
name|int
name|count
init|=
name|specpdl_ptr
operator|-
name|specpdl
decl_stmt|;
name|sentinel
operator|=
name|p
operator|->
name|sentinel
expr_stmt|;
if|if
condition|(
name|NULL
argument_list|(
name|sentinel
argument_list|)
condition|)
return|return;
name|p
operator|->
name|sentinel
operator|=
name|Qnil
expr_stmt|;
name|specbind
argument_list|(
name|Qinhibit_quit
argument_list|,
name|Qt
argument_list|)
expr_stmt|;
name|this_filter
operator|=
name|sentinel
expr_stmt|;
name|filter_process
operator|=
name|proc
expr_stmt|;
name|filter_string
operator|=
name|reason
expr_stmt|;
name|call2
argument_list|(
name|this_filter
argument_list|,
name|filter_process
argument_list|,
name|filter_string
argument_list|)
expr_stmt|;
comment|/*   internal_condition_case (run_filter, Qerror, Fidentity);  */
name|unbind_to
argument_list|(
name|count
argument_list|)
expr_stmt|;
name|p
operator|->
name|sentinel
operator|=
name|sentinel
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_macro
name|init_process
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
ifdef|#
directive|ifdef
name|SIGCHLD
ifndef|#
directive|ifndef
name|CANNOT_DUMP
if|if
condition|(
operator|!
name|noninteractive
operator|||
name|initialized
condition|)
endif|#
directive|endif
name|signal
argument_list|(
name|SIGCHLD
argument_list|,
name|sigchld_handler
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|FD_ZERO
argument_list|(
operator|&
name|input_wait_mask
argument_list|)
expr_stmt|;
name|FD_SET
argument_list|(
literal|0
argument_list|,
operator|&
name|input_wait_mask
argument_list|)
expr_stmt|;
name|Vprocess_alist
operator|=
name|Qnil
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAXDESC
condition|;
name|i
operator|++
control|)
block|{
name|chan_process
index|[
name|i
index|]
operator|=
name|Qnil
expr_stmt|;
name|proc_buffered_char
index|[
name|i
index|]
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|syms_of_process
argument_list|()
end_macro

begin_block
block|{
name|Qprocessp
operator|=
name|intern
argument_list|(
literal|"processp"
argument_list|)
expr_stmt|;
name|staticpro
argument_list|(
operator|&
name|Qprocessp
argument_list|)
expr_stmt|;
name|Qrun
operator|=
name|intern
argument_list|(
literal|"run"
argument_list|)
expr_stmt|;
name|staticpro
argument_list|(
operator|&
name|Qrun
argument_list|)
expr_stmt|;
name|Qstop
operator|=
name|intern
argument_list|(
literal|"stop"
argument_list|)
expr_stmt|;
name|staticpro
argument_list|(
operator|&
name|Qstop
argument_list|)
expr_stmt|;
name|Qsignal
operator|=
name|intern
argument_list|(
literal|"signal"
argument_list|)
expr_stmt|;
name|staticpro
argument_list|(
operator|&
name|Qsignal
argument_list|)
expr_stmt|;
name|Qexit
operator|=
name|intern
argument_list|(
literal|"exit"
argument_list|)
expr_stmt|;
name|staticpro
argument_list|(
operator|&
name|Qexit
argument_list|)
expr_stmt|;
name|Qopen
operator|=
name|intern
argument_list|(
literal|"open"
argument_list|)
expr_stmt|;
name|staticpro
argument_list|(
operator|&
name|Qopen
argument_list|)
expr_stmt|;
name|Qclosed
operator|=
name|intern
argument_list|(
literal|"closed"
argument_list|)
expr_stmt|;
name|staticpro
argument_list|(
operator|&
name|Qclosed
argument_list|)
expr_stmt|;
name|staticpro
argument_list|(
operator|&
name|Vprocess_alist
argument_list|)
expr_stmt|;
name|DEFVAR_BOOL
argument_list|(
literal|"delete-exited-processes"
argument_list|,
operator|&
name|delete_exited_processes
argument_list|,
literal|"*Non-nil means delete processes immediately when they exit.\n\ nil means don't delete them until `list-processes' is run."
argument_list|)
expr_stmt|;
name|delete_exited_processes
operator|=
literal|1
expr_stmt|;
name|DEFVAR_LISP
argument_list|(
literal|"process-connection-type"
argument_list|,
operator|&
name|Vprocess_connection_type
argument_list|,
literal|"Control type of device used to communicate with subprocesses.\n\ Values are nil to use a pipe, t for a pty (or pipe if ptys not supported).\n\ Value takes effect when `start-process' is called."
argument_list|)
expr_stmt|;
name|Vprocess_connection_type
operator|=
name|Qt
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sprocessp
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sget_process
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sget_buffer_process
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sdelete_process
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sprocess_status
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sprocess_exit_status
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sprocess_id
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sprocess_name
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sprocess_command
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sset_process_buffer
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sprocess_buffer
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sprocess_mark
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sset_process_filter
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sprocess_filter
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sset_process_sentinel
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sprocess_sentinel
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sprocess_kill_without_query
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Slist_processes
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sprocess_list
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sstart_process
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_SOCKETS
name|defsubr
argument_list|(
operator|&
name|Sopen_network_stream
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* HAVE_SOCKETS */
name|defsubr
argument_list|(
operator|&
name|Saccept_process_output
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sprocess_send_region
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sprocess_send_string
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sinterrupt_process
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Skill_process
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Squit_process
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sstop_process
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Scontinue_process
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sprocess_send_eof
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Swaiting_for_user_input_p
argument_list|)
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
endif|subprocesses
end_endif

end_unit

