begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * This code is derived from software copyrighted by the Free Software  * Foundation.  *  * Modified 1991 by Donn Seeley at UUNET Technologies, Inc.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)read.c	6.4 (Berkeley) %G%"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_comment
comment|/* read.c - read a source file -    Copyright (C) 1986,1987 Free Software Foundation, Inc.  This file is part of GAS, the GNU Assembler.  GAS is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 1, or (at your option) any later version.  GAS is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GAS; see the file COPYING.  If not, write to the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_define
define|#
directive|define
name|MASK_CHAR
value|(0xFF)
end_define

begin_comment
comment|/* If your chars aren't 8 bits, you will 				   change this a bit.  But then, GNU isn't 				   spozed to run on your machine anyway. 				   (RMS is so shortsighted sometimes.) 				 */
end_comment

begin_define
define|#
directive|define
name|MAXIMUM_NUMBER_OF_CHARS_FOR_FLOAT
value|(16)
end_define

begin_comment
comment|/* This is the largest known floating point */
end_comment

begin_comment
comment|/* format (for now). It will grow when we */
end_comment

begin_comment
comment|/* do 4361 style flonums. */
end_comment

begin_comment
comment|/* Routines that read assembler source text to build spagetti in memory. */
end_comment

begin_comment
comment|/* Another group of these functions is in the as-expr.c module */
end_comment

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|"as.h"
end_include

begin_include
include|#
directive|include
file|"read.h"
end_include

begin_include
include|#
directive|include
file|"md.h"
end_include

begin_include
include|#
directive|include
file|"hash.h"
end_include

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_include
include|#
directive|include
file|"frags.h"
end_include

begin_include
include|#
directive|include
file|"flonum.h"
end_include

begin_include
include|#
directive|include
file|"struc-symbol.h"
end_include

begin_include
include|#
directive|include
file|"expr.h"
end_include

begin_include
include|#
directive|include
file|"symbols.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|SPARC
end_ifdef

begin_include
include|#
directive|include
file|"sparc.h"
end_include

begin_define
define|#
directive|define
name|OTHER_ALIGN
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|I860
end_ifdef

begin_include
include|#
directive|include
file|"i860.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|char
modifier|*
name|input_line_pointer
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -> next char of source file to parse. */
end_comment

begin_if
if|#
directive|if
name|BITS_PER_CHAR
operator|!=
literal|8
end_if

begin_expr_stmt
name|The
name|following
name|table
name|is
name|indexed
name|by
index|[
operator|(
name|char
operator|)
index|]
name|and
name|will
end_expr_stmt

begin_break
break|break if
name|a
name|char
name|does
name|not
name|have
name|exactly
break|256
name|states
break|(
name|hopefully
break|0:255!
end_break

begin_expr_stmt
unit|)
operator|!
endif|#
directive|endif
specifier|const
name|char
comment|/* used by is_... macros. our ctype[] */
name|lex_type
index|[
literal|256
index|]
operator|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* @ABCDEFGHIJKLMNO */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* PQRSTUVWXYZ[\]^_ */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|3
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|3
block|,
literal|0
block|,
comment|/* _!"#$%&'()*+,-./ */
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* 0123456789:;<=>? */
literal|0
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
comment|/* @ABCDEFGHIJKLMNO */
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|3
block|,
comment|/* PQRSTUVWXYZ[\]^_ */
literal|0
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
comment|/* `abcdefghijklmno */
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* pqrstuvwxyz{|}~. */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * In: a character.  * Out: TRUE if this character ends a line.  */
end_comment

begin_define
define|#
directive|define
name|_
value|(0)
end_define

begin_decl_stmt
specifier|const
name|char
name|is_end_of_line
index|[
literal|256
index|]
init|=
block|{
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
literal|99
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
comment|/* @abcdefghijklmno */
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
comment|/*                  */
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
comment|/*                  */
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
literal|99
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
comment|/* 0123456789:;<=>? */
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
comment|/*                  */
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
comment|/*                  */
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
comment|/*                  */
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
comment|/*                  */
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
comment|/*                  */
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
comment|/*                  */
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
comment|/*                  */
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
comment|/*                  */
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
comment|/*                  */
block|}
decl_stmt|;
end_decl_stmt

begin_undef
undef|#
directive|undef
name|_
end_undef

begin_comment
comment|/* Functions private to this file. */
end_comment

begin_function_decl
name|void
name|equals
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|big_cons
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|cons
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|demand_copy_C_string
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|demand_copy_string
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|demand_empty_rest_of_line
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|float_cons
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|long
name|int
name|get_absolute_expression
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
name|get_absolute_expression_and_terminator
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|segT
name|get_known_segmented_expression
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|ignore_rest_of_line
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|is_it_end_of_statement
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pobegin
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pseudo_set
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|stab
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|stringer
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|extern
name|char
name|line_comment_chars
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|buffer_limit
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -> 1 + last char in buffer. */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|bignum_low
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Lowest char of bignum. */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|bignum_limit
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 1st illegal address of bignum. */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|bignum_high
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Highest char of bignum. */
end_comment

begin_comment
comment|/* May point to (bignum_start-1). */
end_comment

begin_comment
comment|/* Never>= bignum_limit. */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|old_buffer
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* JF a hack */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|old_input
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|old_limit
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|WORKING_DOT_WORD
end_ifndef

begin_decl_stmt
name|struct
name|broken_word
modifier|*
name|broken_words
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|new_broken_words
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|void
name|grow_bignum
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|next_char_of_string
parameter_list|()
function_decl|;
end_function_decl

begin_escape
end_escape

begin_function
name|void
name|read_begin
parameter_list|()
block|{
name|pobegin
argument_list|()
expr_stmt|;
name|obstack_begin
argument_list|(
operator|&
name|notes
argument_list|,
literal|5000
argument_list|)
expr_stmt|;
define|#
directive|define
name|BIGNUM_BEGIN_SIZE
value|(16)
name|bignum_low
operator|=
name|xmalloc
argument_list|(
operator|(
name|long
operator|)
name|BIGNUM_BEGIN_SIZE
argument_list|)
expr_stmt|;
name|bignum_limit
operator|=
name|bignum_low
operator|+
name|BIGNUM_BEGIN_SIZE
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* set up pseudo-op tables */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|hash_control
modifier|*
name|po_hash
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* use before set up: NULL-> address error */
end_comment

begin_decl_stmt
name|void
name|s_abort
argument_list|()
decl_stmt|,
name|s_align
argument_list|()
decl_stmt|,
name|s_comm
argument_list|()
decl_stmt|,
name|s_data
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|s_desc
argument_list|()
decl_stmt|,
name|s_even
argument_list|()
decl_stmt|,
name|s_file
argument_list|()
decl_stmt|,
name|s_fill
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|s_globl
argument_list|()
decl_stmt|,
name|s_lcomm
argument_list|()
decl_stmt|,
name|s_line
argument_list|()
decl_stmt|,
name|s_lsym
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|s_org
argument_list|()
decl_stmt|,
name|s_set
argument_list|()
decl_stmt|,
name|s_space
argument_list|()
decl_stmt|,
name|s_text
argument_list|()
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|VMS
end_ifdef

begin_decl_stmt
name|char
name|const_flag
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function_decl
name|void
name|s_const
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|DONTDEF
end_ifdef

begin_decl_stmt
name|void
name|s_gdbline
argument_list|()
decl_stmt|,
name|s_gdblinetab
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|s_gdbbeg
argument_list|()
decl_stmt|,
name|s_gdbblock
argument_list|()
decl_stmt|,
name|s_gdbend
argument_list|()
decl_stmt|,
name|s_gdbsym
argument_list|()
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
name|void
name|stringer
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|cons
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|float_cons
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|big_cons
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|stab
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
specifier|const
name|pseudo_typeS
name|potable
index|[]
init|=
block|{
block|{
literal|"abort"
block|,
name|s_abort
block|,
literal|0
block|}
block|,
block|{
literal|"align"
block|,
name|s_align
block|,
literal|0
block|}
block|,
block|{
literal|"ascii"
block|,
name|stringer
block|,
literal|0
block|}
block|,
block|{
literal|"asciz"
block|,
name|stringer
block|,
literal|1
block|}
block|,
block|{
literal|"byte"
block|,
name|cons
block|,
literal|1
block|}
block|,
block|{
literal|"comm"
block|,
name|s_comm
block|,
literal|0
block|}
block|,
ifdef|#
directive|ifdef
name|VMS
block|{
literal|"const"
block|,
name|s_const
block|,
literal|0
block|}
block|,
endif|#
directive|endif
block|{
literal|"data"
block|,
name|s_data
block|,
literal|0
block|}
block|,
block|{
literal|"desc"
block|,
name|s_desc
block|,
literal|0
block|}
block|,
block|{
literal|"double"
block|,
name|float_cons
block|,
literal|'d'
block|}
block|,
block|{
literal|"file"
block|,
name|s_file
block|,
literal|0
block|}
block|,
block|{
literal|"fill"
block|,
name|s_fill
block|,
literal|0
block|}
block|,
block|{
literal|"float"
block|,
name|float_cons
block|,
literal|'f'
block|}
block|,
ifdef|#
directive|ifdef
name|DONTDEF
block|{
literal|"gdbbeg"
block|,
name|s_gdbbeg
block|,
literal|0
block|}
block|,
block|{
literal|"gdbblock"
block|,
name|s_gdbblock
block|,
literal|0
block|}
block|,
block|{
literal|"gdbend"
block|,
name|s_gdbend
block|,
literal|0
block|}
block|,
block|{
literal|"gdbsym"
block|,
name|s_gdbsym
block|,
literal|0
block|}
block|,
block|{
literal|"gdbline"
block|,
name|s_gdbline
block|,
literal|0
block|}
block|,
block|{
literal|"gdblinetab"
block|,
name|s_gdblinetab
block|,
literal|0
block|}
block|,
endif|#
directive|endif
block|{
literal|"globl"
block|,
name|s_globl
block|,
literal|0
block|}
block|,
block|{
literal|"int"
block|,
name|cons
block|,
literal|4
block|}
block|,
block|{
literal|"lcomm"
block|,
name|s_lcomm
block|,
literal|0
block|}
block|,
block|{
literal|"line"
block|,
name|s_line
block|,
literal|0
block|}
block|,
block|{
literal|"long"
block|,
name|cons
block|,
literal|4
block|}
block|,
block|{
literal|"lsym"
block|,
name|s_lsym
block|,
literal|0
block|}
block|,
block|{
literal|"octa"
block|,
name|big_cons
block|,
literal|16
block|}
block|,
block|{
literal|"org"
block|,
name|s_org
block|,
literal|0
block|}
block|,
block|{
literal|"quad"
block|,
name|big_cons
block|,
literal|8
block|}
block|,
block|{
literal|"set"
block|,
name|s_set
block|,
literal|0
block|}
block|,
block|{
literal|"short"
block|,
name|cons
block|,
literal|2
block|}
block|,
block|{
literal|"single"
block|,
name|float_cons
block|,
literal|'f'
block|}
block|,
block|{
literal|"space"
block|,
name|s_space
block|,
literal|0
block|}
block|,
block|{
literal|"stabd"
block|,
name|stab
block|,
literal|'d'
block|}
block|,
block|{
literal|"stabn"
block|,
name|stab
block|,
literal|'n'
block|}
block|,
block|{
literal|"stabs"
block|,
name|stab
block|,
literal|'s'
block|}
block|,
block|{
literal|"text"
block|,
name|s_text
block|,
literal|0
block|}
block|,
ifndef|#
directive|ifndef
name|SPARC
block|{
literal|"word"
block|,
name|cons
block|,
literal|2
block|}
block|,
endif|#
directive|endif
block|{
name|NULL
block|}
comment|/* end sentinel */
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|pobegin
parameter_list|()
block|{
name|char
modifier|*
name|errtxt
decl_stmt|;
comment|/* error text */
specifier|const
name|pseudo_typeS
modifier|*
name|pop
decl_stmt|;
name|po_hash
operator|=
name|hash_new
argument_list|()
expr_stmt|;
name|errtxt
operator|=
literal|""
expr_stmt|;
comment|/* OK so far */
for|for
control|(
name|pop
operator|=
name|potable
init|;
name|pop
operator|->
name|poc_name
operator|&&
operator|!
operator|*
name|errtxt
condition|;
name|pop
operator|++
control|)
block|{
name|errtxt
operator|=
name|hash_insert
argument_list|(
name|po_hash
argument_list|,
name|pop
operator|->
name|poc_name
argument_list|,
operator|(
name|char
operator|*
operator|)
name|pop
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|pop
operator|=
name|md_pseudo_table
init|;
name|pop
operator|->
name|poc_name
operator|&&
operator|!
operator|*
name|errtxt
condition|;
name|pop
operator|++
control|)
name|errtxt
operator|=
name|hash_insert
argument_list|(
name|po_hash
argument_list|,
name|pop
operator|->
name|poc_name
argument_list|,
operator|(
name|char
operator|*
operator|)
name|pop
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|errtxt
condition|)
block|{
name|as_fatal
argument_list|(
literal|"error constructing pseudo-op table"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* pobegin() */
end_comment

begin_escape
end_escape

begin_comment
comment|/*			read_a_source_file()  *  * File has already been opened, and will be closed by our caller.  *  * We read the file, putting things into a web that  * represents what we have been reading.  */
end_comment

begin_function
name|void
name|read_a_source_file
parameter_list|(
name|buffer
parameter_list|)
name|char
modifier|*
name|buffer
decl_stmt|;
comment|/* 1st character of each buffer of lines is here. */
block|{
specifier|register
name|char
name|c
decl_stmt|;
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
comment|/* string of symbol, '\0' appended */
specifier|register
name|int
name|temp
decl_stmt|;
comment|/* register struct frag * fragP; JF unused */
comment|/* a frag we just made */
name|pseudo_typeS
modifier|*
name|pop
decl_stmt|;
ifdef|#
directive|ifdef
name|DONTDEF
name|void
name|gdb_block_beg
parameter_list|()
function_decl|;
name|void
name|gdb_block_position
parameter_list|()
function_decl|;
name|void
name|gdb_block_end
parameter_list|()
function_decl|;
name|void
name|gdb_symbols_fixup
parameter_list|()
function_decl|;
endif|#
directive|endif
name|subseg_new
argument_list|(
name|SEG_TEXT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
while|while
condition|(
name|buffer_limit
operator|=
name|input_scrub_next_buffer
argument_list|(
operator|&
name|buffer
argument_list|)
condition|)
block|{
comment|/* We have another line to parse. */
name|know
argument_list|(
name|buffer_limit
index|[
operator|-
literal|1
index|]
operator|==
literal|'\n'
argument_list|)
expr_stmt|;
comment|/* Must have a sentinel. */
name|input_line_pointer
operator|=
name|buffer
expr_stmt|;
name|contin
label|:
comment|/* JF this goto is my fault I admit it.  Someone brave please re-write 		   the whole input section here?  Pleeze??? */
while|while
condition|(
name|input_line_pointer
operator|<
name|buffer_limit
condition|)
block|{
comment|/* We have more of this buffer to parse. */
comment|/* 	   * We now have input_line_pointer -> 1st char of next line. 	   * If input_line_pointer [-1] == '\n' then we just 	   * scanned another line: so bump line counters. 	   */
if|if
condition|(
name|input_line_pointer
index|[
operator|-
literal|1
index|]
operator|==
literal|'\n'
condition|)
block|{
name|bump_line_counters
argument_list|()
expr_stmt|;
block|}
comment|/* 	   * We are at the begining of a line, or similar place. 	   * We expect a well-formed assembler statement. 	   * A "symbol-name:" is a statement. 	   * 	   * Depending on what compiler is used, the order of these tests 	   * may vary to catch most common case 1st. 	   * Each test is independent of all other tests at the (top) level. 	   * PLEASE make a compiler that doesn't use this assembler. 	   * It is crufty to waste a compiler's time encoding things for this 	   * assembler, which then wastes more time decoding it. 	   * (And communicating via (linear) files is silly! 	   * If you must pass stuff, please pass a tree!) 	   */
if|if
condition|(
operator|(
name|c
operator|=
operator|*
name|input_line_pointer
operator|++
operator|)
operator|==
literal|'\t'
operator|||
name|c
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'\f'
condition|)
block|{
name|c
operator|=
operator|*
name|input_line_pointer
operator|++
expr_stmt|;
block|}
name|know
argument_list|(
name|c
operator|!=
literal|' '
argument_list|)
expr_stmt|;
comment|/* No further leading whitespace. */
comment|/* 	   * C is the 1st significant character. 	   * Input_line_pointer points after that character. 	   */
if|if
condition|(
name|is_name_beginner
argument_list|(
name|c
argument_list|)
condition|)
block|{
comment|/* want user-defined label or pseudo/opcode */
name|s
operator|=
operator|--
name|input_line_pointer
expr_stmt|;
name|c
operator|=
name|get_symbol_end
argument_list|()
expr_stmt|;
comment|/* name's delimiter */
comment|/* 	       * C is character after symbol. 	       * That character's place in the input line is now '\0'. 	       * S points to the beginning of the symbol. 	       *   [In case of pseudo-op, s -> '.'.] 	       * Input_line_pointer -> '\0' where c was. 	       */
if|if
condition|(
name|c
operator|==
literal|':'
condition|)
block|{
if|if
condition|(
name|flagseen
index|[
literal|'g'
index|]
condition|)
comment|/* set line number for function definition */
name|funcstab
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|colon
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* user-defined label */
operator|*
name|input_line_pointer
operator|++
operator|=
literal|':'
expr_stmt|;
comment|/* Put ':' back for error messages' sake. */
comment|/* Input_line_pointer -> after ':'. */
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'='
operator|||
name|input_line_pointer
index|[
literal|1
index|]
operator|==
literal|'='
condition|)
comment|/* JF deal with FOO=BAR */
block|{
name|equals
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|/* expect pseudo-op or machine instruction */
if|if
condition|(
operator|*
name|s
operator|==
literal|'.'
condition|)
block|{
comment|/* 		       * PSEUDO - OP. 		       * 		       * WARNING: c has next char, which may be end-of-line. 		       * We lookup the pseudo-op table with s+1 because we 		       * already know that the pseudo-op begins with a '.'. 		       */
name|pop
operator|=
operator|(
name|pseudo_typeS
operator|*
operator|)
name|hash_find
argument_list|(
name|po_hash
argument_list|,
name|s
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* Print the error msg now, while we still can */
if|if
condition|(
operator|!
name|pop
condition|)
name|as_bad
argument_list|(
literal|"Unknown pseudo-op:  '%s'"
argument_list|,
name|s
argument_list|)
expr_stmt|;
comment|/* Put it back for error messages etc. */
operator|*
name|input_line_pointer
operator|=
name|c
expr_stmt|;
comment|/* The following skip of whitespace is compulsory. */
comment|/* A well shaped space is sometimes all that seperates keyword from operands. */
if|if
condition|(
name|c
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'\t'
condition|)
block|{
comment|/* Skip seperator after keyword. */
name|input_line_pointer
operator|++
expr_stmt|;
block|}
comment|/* 		       * Input_line is restored. 		       * Input_line_pointer -> 1st non-blank char 		       * after pseudo-operation. 		       */
if|if
condition|(
operator|!
name|pop
condition|)
block|{
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
break|break;
block|}
else|else
call|(
modifier|*
name|pop
operator|->
name|poc_handler
call|)
argument_list|(
name|pop
operator|->
name|poc_val
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* machine instruction */
comment|/* If source file debugging, emit a stab. */
if|if
condition|(
name|flagseen
index|[
literal|'g'
index|]
condition|)
name|linestab
argument_list|()
expr_stmt|;
comment|/* WARNING: c has char, which may be end-of-line. */
comment|/* Also: input_line_pointer -> `\0` where c was. */
operator|*
name|input_line_pointer
operator|=
name|c
expr_stmt|;
while|while
condition|(
operator|!
name|is_end_of_line
index|[
operator|*
name|input_line_pointer
index|]
condition|)
block|{
name|input_line_pointer
operator|++
expr_stmt|;
block|}
name|c
operator|=
operator|*
name|input_line_pointer
expr_stmt|;
operator|*
name|input_line_pointer
operator|=
literal|'\0'
expr_stmt|;
name|md_assemble
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* Assemble 1 instruction. */
operator|*
name|input_line_pointer
operator|++
operator|=
name|c
expr_stmt|;
comment|/* We resume loop AFTER the end-of-line from this instruction */
block|}
comment|/* if (*s=='.') */
block|}
comment|/* if c==':' */
continue|continue;
block|}
comment|/* if (is_name_beginner(c) */
if|if
condition|(
name|is_end_of_line
index|[
name|c
index|]
condition|)
block|{
comment|/* empty statement */
continue|continue;
block|}
if|if
condition|(
name|isdigit
argument_list|(
name|c
argument_list|)
condition|)
block|{
comment|/* local label  ("4:") */
name|temp
operator|=
name|c
operator|-
literal|'0'
expr_stmt|;
ifdef|#
directive|ifdef
name|SUN_ASM_SYNTAX
if|if
condition|(
operator|*
name|input_line_pointer
operator|==
literal|'$'
condition|)
name|input_line_pointer
operator|++
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|*
name|input_line_pointer
operator|++
operator|==
literal|':'
condition|)
block|{
name|local_colon
argument_list|(
name|temp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|as_bad
argument_list|(
literal|"Spurious digit %d."
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|input_line_pointer
operator|--
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
block|}
continue|continue;
block|}
if|if
condition|(
name|c
operator|&&
name|index
argument_list|(
name|line_comment_chars
argument_list|,
name|c
argument_list|)
condition|)
block|{
comment|/* Its a comment.  Better say APP or NO_APP */
name|char
modifier|*
name|ends
decl_stmt|;
name|char
modifier|*
name|strstr
parameter_list|()
function_decl|;
name|char
modifier|*
name|new_buf
decl_stmt|;
name|char
modifier|*
name|new_tmp
decl_stmt|;
name|int
name|new_length
decl_stmt|;
name|char
modifier|*
name|tmp_buf
init|=
literal|0
decl_stmt|;
specifier|extern
name|char
modifier|*
name|scrub_string
decl_stmt|,
modifier|*
name|scrub_last_string
decl_stmt|;
name|int
name|scrub_from_string
parameter_list|()
function_decl|;
name|void
name|scrub_to_string
parameter_list|()
function_decl|;
name|bump_line_counters
argument_list|()
expr_stmt|;
name|s
operator|=
name|input_line_pointer
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|s
argument_list|,
literal|"APP\n"
argument_list|,
literal|4
argument_list|)
condition|)
continue|continue;
comment|/* We ignore it */
name|s
operator|+=
literal|4
expr_stmt|;
name|ends
operator|=
name|strstr
argument_list|(
name|s
argument_list|,
literal|"#NO_APP\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ends
condition|)
block|{
name|int
name|tmp_len
decl_stmt|;
name|int
name|num
decl_stmt|;
comment|/* The end of the #APP wasn't in this buffer.  We 			   keep reading in buffers until we find the #NO_APP 			   that goes with this #APP  There is one.  The specs  			   guarentee it. . .*/
name|tmp_len
operator|=
name|buffer_limit
operator|-
name|s
expr_stmt|;
name|tmp_buf
operator|=
name|xmalloc
argument_list|(
name|tmp_len
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|s
argument_list|,
name|tmp_buf
argument_list|,
name|tmp_len
argument_list|)
expr_stmt|;
do|do
block|{
name|new_tmp
operator|=
name|input_scrub_next_buffer
argument_list|(
operator|&
name|buffer
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|new_tmp
condition|)
break|break;
else|else
name|buffer_limit
operator|=
name|new_tmp
expr_stmt|;
name|input_line_pointer
operator|=
name|buffer
expr_stmt|;
name|ends
operator|=
name|strstr
argument_list|(
name|buffer
argument_list|,
literal|"#NO_APP\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ends
condition|)
name|num
operator|=
name|ends
operator|-
name|buffer
expr_stmt|;
else|else
name|num
operator|=
name|buffer_limit
operator|-
name|buffer
expr_stmt|;
name|tmp_buf
operator|=
name|xrealloc
argument_list|(
name|tmp_buf
argument_list|,
name|tmp_len
operator|+
name|num
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|buffer
argument_list|,
name|tmp_buf
operator|+
name|tmp_len
argument_list|,
name|num
argument_list|)
expr_stmt|;
name|tmp_len
operator|+=
name|num
expr_stmt|;
block|}
do|while
condition|(
operator|!
name|ends
condition|)
do|;
name|input_line_pointer
operator|=
name|ends
condition|?
name|ends
operator|+
literal|8
else|:
name|NULL
expr_stmt|;
name|s
operator|=
name|tmp_buf
expr_stmt|;
name|ends
operator|=
name|s
operator|+
name|tmp_len
expr_stmt|;
block|}
else|else
block|{
name|input_line_pointer
operator|=
name|ends
operator|+
literal|8
expr_stmt|;
block|}
name|new_buf
operator|=
name|xmalloc
argument_list|(
literal|100
argument_list|)
expr_stmt|;
name|new_length
operator|=
literal|100
expr_stmt|;
name|new_tmp
operator|=
name|new_buf
expr_stmt|;
name|scrub_string
operator|=
name|s
expr_stmt|;
name|scrub_last_string
operator|=
name|ends
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|int
name|ch
decl_stmt|;
name|ch
operator|=
name|do_scrub_next_char
argument_list|(
name|scrub_from_string
argument_list|,
name|scrub_to_string
argument_list|)
expr_stmt|;
if|if
condition|(
name|ch
operator|==
name|EOF
condition|)
break|break;
operator|*
name|new_tmp
operator|++
operator|=
name|ch
expr_stmt|;
if|if
condition|(
name|new_tmp
operator|==
name|new_buf
operator|+
name|new_length
condition|)
block|{
name|new_buf
operator|=
name|xrealloc
argument_list|(
name|new_buf
argument_list|,
name|new_length
operator|+
literal|100
argument_list|)
expr_stmt|;
name|new_tmp
operator|=
name|new_buf
operator|+
name|new_length
expr_stmt|;
name|new_length
operator|+=
literal|100
expr_stmt|;
block|}
block|}
if|if
condition|(
name|tmp_buf
condition|)
name|free
argument_list|(
name|tmp_buf
argument_list|)
expr_stmt|;
name|old_buffer
operator|=
name|buffer
expr_stmt|;
name|old_input
operator|=
name|input_line_pointer
expr_stmt|;
name|old_limit
operator|=
name|buffer_limit
expr_stmt|;
name|buffer
operator|=
name|new_buf
expr_stmt|;
name|input_line_pointer
operator|=
name|new_buf
expr_stmt|;
name|buffer_limit
operator|=
name|new_tmp
expr_stmt|;
continue|continue;
block|}
name|as_bad
argument_list|(
literal|"Junk character %d."
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
block|}
comment|/* while (input_line_pointer<buffer_limit )*/
if|if
condition|(
name|old_buffer
condition|)
block|{
name|bump_line_counters
argument_list|()
expr_stmt|;
if|if
condition|(
name|old_input
operator|==
literal|0
condition|)
return|return;
name|buffer
operator|=
name|old_buffer
expr_stmt|;
name|input_line_pointer
operator|=
name|old_input
expr_stmt|;
name|buffer_limit
operator|=
name|old_limit
expr_stmt|;
name|old_buffer
operator|=
literal|0
expr_stmt|;
goto|goto
name|contin
goto|;
block|}
block|}
comment|/* while (more bufrers to scan) */
block|}
end_function

begin_comment
comment|/* read_a_source_file() */
end_comment

begin_function
name|void
name|s_abort
parameter_list|()
block|{
name|as_fatal
argument_list|(
literal|".abort detected.  Abandoning ship."
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|OTHER_ALIGN
end_ifdef

begin_function
specifier|static
name|void
name|s_align
parameter_list|()
block|{
specifier|register
name|unsigned
name|int
name|temp
decl_stmt|;
specifier|register
name|long
name|int
name|temp_fill
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|temp
operator|=
name|get_absolute_expression
argument_list|()
expr_stmt|;
define|#
directive|define
name|MAX_ALIGNMENT
value|(1<< 15)
if|if
condition|(
name|temp
operator|>
name|MAX_ALIGNMENT
condition|)
block|{
name|as_bad
argument_list|(
literal|"Alignment too large: %d. assumed."
argument_list|,
name|temp
operator|=
name|MAX_ALIGNMENT
argument_list|)
expr_stmt|;
block|}
comment|/*      * For the sparc, `.align (1<<n)' actually means `.align n'      * so we have to convert it.      */
if|if
condition|(
name|temp
operator|!=
literal|0
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|temp
operator|&
literal|1
operator|)
operator|==
literal|0
condition|;
name|temp
operator|>>=
literal|1
operator|,
operator|++
name|i
control|)
empty_stmt|;
block|}
if|if
condition|(
name|temp
operator|!=
literal|1
condition|)
name|as_bad
argument_list|(
literal|"Alignment not a power of 2"
argument_list|)
expr_stmt|;
name|temp
operator|=
name|i
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|==
literal|','
condition|)
block|{
name|input_line_pointer
operator|++
expr_stmt|;
name|temp_fill
operator|=
name|get_absolute_expression
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|temp_fill
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Only make a frag if we HAVE to. . . */
if|if
condition|(
name|temp
operator|&&
operator|!
name|need_pass_2
condition|)
name|frag_align
argument_list|(
name|temp
argument_list|,
operator|(
name|int
operator|)
name|temp_fill
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_function
name|void
name|s_align
parameter_list|()
block|{
specifier|register
name|int
name|temp
decl_stmt|;
specifier|register
name|long
name|int
name|temp_fill
decl_stmt|;
name|temp
operator|=
name|get_absolute_expression
argument_list|()
expr_stmt|;
define|#
directive|define
name|MAX_ALIGNMENT
value|(15)
if|if
condition|(
name|temp
operator|>
name|MAX_ALIGNMENT
condition|)
name|as_bad
argument_list|(
literal|"Alignment too large: %d. assumed."
argument_list|,
name|temp
operator|=
name|MAX_ALIGNMENT
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|temp
operator|<
literal|0
condition|)
block|{
name|as_bad
argument_list|(
literal|"Alignment negative. 0 assumed."
argument_list|)
expr_stmt|;
name|temp
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|input_line_pointer
operator|==
literal|','
condition|)
block|{
name|input_line_pointer
operator|++
expr_stmt|;
name|temp_fill
operator|=
name|get_absolute_expression
argument_list|()
expr_stmt|;
block|}
else|else
name|temp_fill
operator|=
literal|0
expr_stmt|;
comment|/* Only make a frag if we HAVE to. . . */
if|if
condition|(
name|temp
operator|&&
operator|!
name|need_pass_2
condition|)
name|frag_align
argument_list|(
name|temp
argument_list|,
operator|(
name|int
operator|)
name|temp_fill
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|void
name|s_comm
parameter_list|()
block|{
specifier|register
name|char
modifier|*
name|name
decl_stmt|;
specifier|register
name|char
name|c
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|int
name|temp
decl_stmt|;
specifier|register
name|symbolS
modifier|*
name|symbolP
decl_stmt|;
name|name
operator|=
name|input_line_pointer
expr_stmt|;
name|c
operator|=
name|get_symbol_end
argument_list|()
expr_stmt|;
comment|/* just after name is now '\0' */
name|p
operator|=
name|input_line_pointer
expr_stmt|;
operator|*
name|p
operator|=
name|c
expr_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|!=
literal|','
condition|)
block|{
name|as_bad
argument_list|(
literal|"Expected comma after symbol-name"
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
name|input_line_pointer
operator|++
expr_stmt|;
comment|/* skip ',' */
if|if
condition|(
operator|(
name|temp
operator|=
name|get_absolute_expression
argument_list|()
operator|)
operator|<
literal|0
condition|)
block|{
name|as_warn
argument_list|(
literal|".COMMon length (%d.)<0! Ignored."
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
operator|*
name|p
operator|=
literal|0
expr_stmt|;
name|symbolP
operator|=
name|symbol_find_or_make
argument_list|(
name|name
argument_list|)
expr_stmt|;
operator|*
name|p
operator|=
name|c
expr_stmt|;
if|if
condition|(
operator|(
name|symbolP
operator|->
name|sy_type
operator|&
name|N_TYPE
operator|)
operator|!=
name|N_UNDF
operator|||
name|symbolP
operator|->
name|sy_other
operator|!=
literal|0
operator|||
name|symbolP
operator|->
name|sy_desc
operator|!=
literal|0
condition|)
block|{
name|as_warn
argument_list|(
literal|"Ignoring attempt to re-define symbol"
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|symbolP
operator|->
name|sy_value
condition|)
block|{
if|if
condition|(
name|symbolP
operator|->
name|sy_value
operator|!=
name|temp
condition|)
name|as_warn
argument_list|(
literal|"Length of .comm \"%s\" is already %d. Not changed to %d."
argument_list|,
name|symbolP
operator|->
name|sy_name
argument_list|,
name|symbolP
operator|->
name|sy_value
argument_list|,
name|temp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|symbolP
operator|->
name|sy_value
operator|=
name|temp
expr_stmt|;
name|symbolP
operator|->
name|sy_type
operator||=
name|N_EXT
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|VMS
if|if
condition|(
operator|!
name|temp
condition|)
name|symbolP
operator|->
name|sy_other
operator|=
name|const_flag
expr_stmt|;
endif|#
directive|endif
name|know
argument_list|(
name|symbolP
operator|->
name|sy_frag
operator|==
operator|&
name|zero_address_frag
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|VMS
end_ifdef

begin_function
name|void
name|s_const
parameter_list|()
block|{
specifier|register
name|int
name|temp
decl_stmt|;
name|temp
operator|=
name|get_absolute_expression
argument_list|()
expr_stmt|;
name|subseg_new
argument_list|(
name|SEG_DATA
argument_list|,
operator|(
name|subsegT
operator|)
name|temp
argument_list|)
expr_stmt|;
name|const_flag
operator|=
literal|1
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|void
name|s_data
parameter_list|()
block|{
specifier|register
name|int
name|temp
decl_stmt|;
name|temp
operator|=
name|get_absolute_expression
argument_list|()
expr_stmt|;
name|subseg_new
argument_list|(
name|SEG_DATA
argument_list|,
operator|(
name|subsegT
operator|)
name|temp
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|VMS
name|const_flag
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|s_desc
parameter_list|()
block|{
specifier|register
name|char
modifier|*
name|name
decl_stmt|;
specifier|register
name|char
name|c
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|symbolS
modifier|*
name|symbolP
decl_stmt|;
specifier|register
name|int
name|temp
decl_stmt|;
comment|/* 	 * Frob invented at RMS' request. Set the n_desc of a symbol. 	 */
name|name
operator|=
name|input_line_pointer
expr_stmt|;
name|c
operator|=
name|get_symbol_end
argument_list|()
expr_stmt|;
name|p
operator|=
name|input_line_pointer
expr_stmt|;
name|symbolP
operator|=
name|symbol_table_lookup
argument_list|(
name|name
argument_list|)
expr_stmt|;
operator|*
name|p
operator|=
name|c
expr_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|!=
literal|','
condition|)
block|{
operator|*
name|p
operator|=
literal|0
expr_stmt|;
name|as_bad
argument_list|(
literal|"Expected comma after name \"%s\""
argument_list|,
name|name
argument_list|)
expr_stmt|;
operator|*
name|p
operator|=
name|c
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|input_line_pointer
operator|++
expr_stmt|;
name|temp
operator|=
name|get_absolute_expression
argument_list|()
expr_stmt|;
operator|*
name|p
operator|=
literal|0
expr_stmt|;
name|symbolP
operator|=
name|symbol_find_or_make
argument_list|(
name|name
argument_list|)
expr_stmt|;
operator|*
name|p
operator|=
name|c
expr_stmt|;
name|symbolP
operator|->
name|sy_desc
operator|=
name|temp
expr_stmt|;
block|}
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|s_file
parameter_list|()
block|{
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
name|int
name|length
decl_stmt|;
comment|/* Some assemblers tolerate immediately following '"' */
if|if
condition|(
name|s
operator|=
name|demand_copy_string
argument_list|(
operator|&
name|length
argument_list|)
condition|)
block|{
name|new_logical_line
argument_list|(
name|s
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|s_fill
parameter_list|()
block|{
name|long
name|int
name|temp_repeat
decl_stmt|;
name|long
name|int
name|temp_size
decl_stmt|;
specifier|register
name|long
name|int
name|temp_fill
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|get_absolute_expression_and_terminator
argument_list|(
operator|&
name|temp_repeat
argument_list|)
operator|!=
literal|','
condition|)
block|{
name|input_line_pointer
operator|--
expr_stmt|;
comment|/* Backup over what was not a ','. */
name|as_warn
argument_list|(
literal|"Expect comma after rep-size in .fill"
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|get_absolute_expression_and_terminator
argument_list|(
operator|&
name|temp_size
argument_list|)
operator|!=
literal|','
condition|)
block|{
name|input_line_pointer
operator|--
expr_stmt|;
comment|/* Backup over what was not a ','. */
name|as_warn
argument_list|(
literal|"Expected comma after size in .fill"
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
comment|/* 	 * This is to be compatible with BSD 4.2 AS, not for any rational reason. 	 */
define|#
directive|define
name|BSD_FILL_SIZE_CROCK_8
value|(8)
if|if
condition|(
name|temp_size
operator|>
name|BSD_FILL_SIZE_CROCK_8
condition|)
block|{
name|as_bad
argument_list|(
literal|".fill size clamped to %d."
argument_list|,
name|BSD_FILL_SIZE_CROCK_8
argument_list|)
expr_stmt|;
name|temp_size
operator|=
name|BSD_FILL_SIZE_CROCK_8
expr_stmt|;
block|}
if|if
condition|(
name|temp_size
operator|<
literal|0
condition|)
block|{
name|as_warn
argument_list|(
literal|"Size negative: .fill ignored."
argument_list|)
expr_stmt|;
name|temp_size
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|temp_repeat
operator|<=
literal|0
condition|)
block|{
name|as_warn
argument_list|(
literal|"Repeat< 0, .fill ignored"
argument_list|)
expr_stmt|;
name|temp_size
operator|=
literal|0
expr_stmt|;
block|}
name|temp_fill
operator|=
name|get_absolute_expression
argument_list|()
expr_stmt|;
if|if
condition|(
name|temp_size
operator|&&
operator|!
name|need_pass_2
condition|)
block|{
name|p
operator|=
name|frag_var
argument_list|(
name|rs_fill
argument_list|,
operator|(
name|int
operator|)
name|temp_size
argument_list|,
operator|(
name|int
operator|)
name|temp_size
argument_list|,
operator|(
name|relax_substateT
operator|)
literal|0
argument_list|,
operator|(
name|symbolS
operator|*
operator|)
literal|0
argument_list|,
name|temp_repeat
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|p
argument_list|,
operator|(
name|int
operator|)
name|temp_size
argument_list|)
expr_stmt|;
comment|/*  * The magic number BSD_FILL_SIZE_CROCK_4 is from BSD 4.2 VAX flavoured AS.  * The following bizzare behaviour is to be compatible with above.  * I guess they tried to take up to 8 bytes from a 4-byte expression  * and they forgot to sign extend. Un*x Sux.  */
define|#
directive|define
name|BSD_FILL_SIZE_CROCK_4
value|(4)
name|md_number_to_chars
argument_list|(
name|p
argument_list|,
name|temp_fill
argument_list|,
name|temp_size
operator|>
name|BSD_FILL_SIZE_CROCK_4
condition|?
name|BSD_FILL_SIZE_CROCK_4
else|:
operator|(
name|int
operator|)
name|temp_size
argument_list|)
expr_stmt|;
comment|/*  * Note: .fill (),0 emits no frag (since we are asked to .fill 0 bytes)  * but emits no error message because it seems a legal thing to do.  * It is a degenerate case of .fill but could be emitted by a compiler.  */
block|}
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|DONTDEF
end_ifdef

begin_function
name|void
name|s_gdbbeg
parameter_list|()
block|{
specifier|register
name|int
name|temp
decl_stmt|;
name|temp
operator|=
name|get_absolute_expression
argument_list|()
expr_stmt|;
if|if
condition|(
name|temp
operator|<
literal|0
condition|)
name|as_warn
argument_list|(
literal|"Block number<0. Ignored."
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|flagseen
index|[
literal|'G'
index|]
condition|)
name|gdb_block_beg
argument_list|(
operator|(
name|long
name|int
operator|)
name|temp
argument_list|,
name|frag_now
argument_list|,
call|(
name|long
name|int
call|)
argument_list|(
name|obstack_next_free
argument_list|(
operator|&
name|frags
argument_list|)
operator|-
name|frag_now
operator|->
name|fr_literal
argument_list|)
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|s_gdbblock
parameter_list|()
block|{
specifier|register
name|int
name|position
decl_stmt|;
name|int
name|temp
decl_stmt|;
if|if
condition|(
name|get_absolute_expression_and_terminator
argument_list|(
operator|&
name|temp
argument_list|)
operator|!=
literal|','
condition|)
block|{
name|as_warn
argument_list|(
literal|"expected comma before position in .gdbblock"
argument_list|)
expr_stmt|;
operator|--
name|input_line_pointer
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
name|position
operator|=
name|get_absolute_expression
argument_list|()
expr_stmt|;
if|if
condition|(
name|flagseen
index|[
literal|'G'
index|]
condition|)
name|gdb_block_position
argument_list|(
operator|(
name|long
name|int
operator|)
name|temp
argument_list|,
operator|(
name|long
name|int
operator|)
name|position
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|s_gdbend
parameter_list|()
block|{
specifier|register
name|int
name|temp
decl_stmt|;
name|temp
operator|=
name|get_absolute_expression
argument_list|()
expr_stmt|;
if|if
condition|(
name|temp
operator|<
literal|0
condition|)
name|as_warn
argument_list|(
literal|"Block number<0. Ignored."
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|flagseen
index|[
literal|'G'
index|]
condition|)
name|gdb_block_end
argument_list|(
operator|(
name|long
name|int
operator|)
name|temp
argument_list|,
name|frag_now
argument_list|,
call|(
name|long
name|int
call|)
argument_list|(
name|obstack_next_free
argument_list|(
operator|&
name|frags
argument_list|)
operator|-
name|frag_now
operator|->
name|fr_literal
argument_list|)
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|s_gdbsym
parameter_list|()
block|{
specifier|register
name|char
modifier|*
name|name
decl_stmt|,
modifier|*
name|p
decl_stmt|;
specifier|register
name|char
name|c
decl_stmt|;
specifier|register
name|symbolS
modifier|*
name|symbolP
decl_stmt|;
specifier|register
name|int
name|temp
decl_stmt|;
name|name
operator|=
name|input_line_pointer
expr_stmt|;
name|c
operator|=
name|get_symbol_end
argument_list|()
expr_stmt|;
name|p
operator|=
name|input_line_pointer
expr_stmt|;
name|symbolP
operator|=
name|symbol_find_or_make
argument_list|(
name|name
argument_list|)
expr_stmt|;
operator|*
name|p
operator|=
name|c
expr_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|!=
literal|','
condition|)
block|{
name|as_warn
argument_list|(
literal|"Expected comma after name"
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
name|input_line_pointer
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|temp
operator|=
name|get_absolute_expression
argument_list|()
operator|)
operator|<
literal|0
condition|)
block|{
name|as_warn
argument_list|(
literal|"Bad GDB symbol file offset (%d.)<0! Ignored."
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|flagseen
index|[
literal|'G'
index|]
condition|)
name|gdb_symbols_fixup
argument_list|(
name|symbolP
argument_list|,
operator|(
name|long
name|int
operator|)
name|temp
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|s_gdbline
parameter_list|()
block|{
name|int
name|file_number
decl_stmt|,
name|lineno
decl_stmt|;
if|if
condition|(
name|get_absolute_expression_and_terminator
argument_list|(
operator|&
name|file_number
argument_list|)
operator|!=
literal|','
condition|)
block|{
name|as_warn
argument_list|(
literal|"expected comman after filenum in .gdbline"
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
name|lineno
operator|=
name|get_absolute_expression
argument_list|()
expr_stmt|;
if|if
condition|(
name|flagseen
index|[
literal|'G'
index|]
condition|)
name|gdb_line
argument_list|(
name|file_number
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|s_gdblinetab
parameter_list|()
block|{
name|int
name|file_number
decl_stmt|,
name|offset
decl_stmt|;
if|if
condition|(
name|get_absolute_expression_and_terminator
argument_list|(
operator|&
name|file_number
argument_list|)
operator|!=
literal|','
condition|)
block|{
name|as_warn
argument_list|(
literal|"expected comman after filenum in .gdblinetab"
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
name|offset
operator|=
name|get_absolute_expression
argument_list|()
expr_stmt|;
if|if
condition|(
name|flagseen
index|[
literal|'G'
index|]
condition|)
name|gdb_line_tab
argument_list|(
name|file_number
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|void
name|s_globl
parameter_list|()
block|{
specifier|register
name|char
modifier|*
name|name
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
specifier|register
name|symbolS
modifier|*
name|symbolP
decl_stmt|;
do|do
block|{
name|name
operator|=
name|input_line_pointer
expr_stmt|;
name|c
operator|=
name|get_symbol_end
argument_list|()
expr_stmt|;
name|symbolP
operator|=
name|symbol_find_or_make
argument_list|(
name|name
argument_list|)
expr_stmt|;
operator|*
name|input_line_pointer
operator|=
name|c
expr_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
name|symbolP
operator|->
name|sy_type
operator||=
name|N_EXT
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|','
condition|)
block|{
name|input_line_pointer
operator|++
expr_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|==
literal|'\n'
condition|)
name|c
operator|=
literal|'\n'
expr_stmt|;
block|}
block|}
do|while
condition|(
name|c
operator|==
literal|','
condition|)
do|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|s_lcomm
parameter_list|()
block|{
specifier|register
name|char
modifier|*
name|name
decl_stmt|;
specifier|register
name|char
name|c
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|int
name|temp
decl_stmt|;
specifier|register
name|symbolS
modifier|*
name|symbolP
decl_stmt|;
name|name
operator|=
name|input_line_pointer
expr_stmt|;
name|c
operator|=
name|get_symbol_end
argument_list|()
expr_stmt|;
name|p
operator|=
name|input_line_pointer
expr_stmt|;
operator|*
name|p
operator|=
name|c
expr_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|!=
literal|','
condition|)
block|{
name|as_warn
argument_list|(
literal|"Expected comma after name"
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
name|input_line_pointer
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|temp
operator|=
name|get_absolute_expression
argument_list|()
operator|)
operator|<
literal|0
condition|)
block|{
name|as_warn
argument_list|(
literal|"BSS length (%d.)<0! Ignored."
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
operator|*
name|p
operator|=
literal|0
expr_stmt|;
name|symbolP
operator|=
name|symbol_find_or_make
argument_list|(
name|name
argument_list|)
expr_stmt|;
operator|*
name|p
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|symbolP
operator|->
name|sy_other
operator|==
literal|0
operator|&&
name|symbolP
operator|->
name|sy_desc
operator|==
literal|0
operator|&&
operator|(
operator|(
name|symbolP
operator|->
name|sy_type
operator|==
name|N_BSS
operator|&&
name|symbolP
operator|->
name|sy_value
operator|==
name|local_bss_counter
operator|)
operator|||
operator|(
operator|(
name|symbolP
operator|->
name|sy_type
operator|&
name|N_TYPE
operator|)
operator|==
name|N_UNDF
operator|&&
name|symbolP
operator|->
name|sy_value
operator|==
literal|0
operator|)
operator|)
condition|)
block|{
name|symbolP
operator|->
name|sy_value
operator|=
name|local_bss_counter
expr_stmt|;
name|symbolP
operator|->
name|sy_type
operator|=
name|N_BSS
expr_stmt|;
name|symbolP
operator|->
name|sy_frag
operator|=
operator|&
name|bss_address_frag
expr_stmt|;
name|local_bss_counter
operator|+=
name|temp
expr_stmt|;
block|}
else|else
name|as_warn
argument_list|(
literal|"Ignoring attempt to re-define symbol from %d. to %d."
argument_list|,
name|symbolP
operator|->
name|sy_value
argument_list|,
name|local_bss_counter
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|s_line
parameter_list|()
block|{
comment|/* Assume delimiter is part of expression. */
comment|/* BSD4.2 as fails with delightful bug, so we */
comment|/* are not being incompatible here. */
name|new_logical_line
argument_list|(
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
call|(
name|int
call|)
argument_list|(
name|get_absolute_expression
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|s_long
parameter_list|()
block|{
name|cons
argument_list|(
literal|4
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|s_int
parameter_list|()
block|{
name|cons
argument_list|(
literal|4
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|s_lsym
parameter_list|()
block|{
specifier|register
name|char
modifier|*
name|name
decl_stmt|;
specifier|register
name|char
name|c
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|segT
name|segment
decl_stmt|;
name|expressionS
name|exp
decl_stmt|;
specifier|register
name|symbolS
modifier|*
name|symbolP
decl_stmt|;
comment|/* we permit ANY expression: BSD4.2 demands constants */
name|name
operator|=
name|input_line_pointer
expr_stmt|;
name|c
operator|=
name|get_symbol_end
argument_list|()
expr_stmt|;
name|p
operator|=
name|input_line_pointer
expr_stmt|;
operator|*
name|p
operator|=
name|c
expr_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|!=
literal|','
condition|)
block|{
operator|*
name|p
operator|=
literal|0
expr_stmt|;
name|as_warn
argument_list|(
literal|"Expected comma after name \"%s\""
argument_list|,
name|name
argument_list|)
expr_stmt|;
operator|*
name|p
operator|=
name|c
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
name|input_line_pointer
operator|++
expr_stmt|;
name|segment
operator|=
name|expression
argument_list|(
operator|&
name|exp
argument_list|)
expr_stmt|;
if|if
condition|(
name|segment
operator|!=
name|SEG_ABSOLUTE
operator|&&
name|segment
operator|!=
name|SEG_DATA
operator|&&
name|segment
operator|!=
name|SEG_TEXT
operator|&&
name|segment
operator|!=
name|SEG_BSS
condition|)
block|{
name|as_bad
argument_list|(
literal|"Bad expression: %s"
argument_list|,
name|seg_name
index|[
operator|(
name|int
operator|)
name|segment
index|]
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
name|know
argument_list|(
name|segment
operator|==
name|SEG_ABSOLUTE
operator|||
name|segment
operator|==
name|SEG_DATA
operator|||
name|segment
operator|==
name|SEG_TEXT
operator|||
name|segment
operator|==
name|SEG_BSS
argument_list|)
expr_stmt|;
operator|*
name|p
operator|=
literal|0
expr_stmt|;
name|symbolP
operator|=
name|symbol_new
argument_list|(
name|name
argument_list|,
call|(
name|unsigned
name|char
call|)
argument_list|(
name|seg_N_TYPE
index|[
operator|(
name|int
operator|)
name|segment
index|]
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
call|(
name|valueT
call|)
argument_list|(
name|exp
operator|.
name|X_add_number
argument_list|)
argument_list|,
operator|&
name|zero_address_frag
argument_list|)
expr_stmt|;
operator|*
name|p
operator|=
name|c
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|s_org
parameter_list|()
block|{
specifier|register
name|segT
name|segment
decl_stmt|;
name|expressionS
name|exp
decl_stmt|;
specifier|register
name|long
name|int
name|temp_fill
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
comment|/*  * Don't believe the documentation of BSD 4.2 AS.  * There is no such thing as a sub-segment-relative origin.  * Any absolute origin is given a warning, then assumed to be segment-relative.  * Any segmented origin expression ("foo+42") had better be in the right  * segment or the .org is ignored.  *  * BSD 4.2 AS warns if you try to .org backwards. We cannot because we  * never know sub-segment sizes when we are reading code.  * BSD will crash trying to emit -ve numbers of filler bytes in certain  * .orgs. We don't crash, but see as-write for that code.  */
comment|/*  * Don't make frag if need_pass_2==TRUE.  */
name|segment
operator|=
name|get_known_segmented_expression
argument_list|(
operator|&
name|exp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|==
literal|','
condition|)
block|{
name|input_line_pointer
operator|++
expr_stmt|;
name|temp_fill
operator|=
name|get_absolute_expression
argument_list|()
expr_stmt|;
block|}
else|else
name|temp_fill
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|need_pass_2
condition|)
block|{
if|if
condition|(
name|segment
operator|!=
name|now_seg
operator|&&
name|segment
operator|!=
name|SEG_ABSOLUTE
condition|)
name|as_warn
argument_list|(
literal|"Illegal segment \"%s\". Segment \"%s\" assumed."
argument_list|,
name|seg_name
index|[
operator|(
name|int
operator|)
name|segment
index|]
argument_list|,
name|seg_name
index|[
operator|(
name|int
operator|)
name|now_seg
index|]
argument_list|)
expr_stmt|;
name|p
operator|=
name|frag_var
argument_list|(
name|rs_org
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
operator|(
name|relax_substateT
operator|)
literal|0
argument_list|,
name|exp
operator|.
name|X_add_symbol
argument_list|,
name|exp
operator|.
name|X_add_number
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
operator|*
name|p
operator|=
name|temp_fill
expr_stmt|;
block|}
comment|/* if (ok to make frag) */
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|s_set
parameter_list|()
block|{
specifier|register
name|char
modifier|*
name|name
decl_stmt|;
specifier|register
name|char
name|delim
decl_stmt|;
specifier|register
name|char
modifier|*
name|end_name
decl_stmt|;
specifier|register
name|symbolS
modifier|*
name|symbolP
decl_stmt|;
comment|/* 	 * Especial apologies for the random logic: 	 * this just grew, and could be parsed much more simply! 	 * Dean in haste. 	 */
name|name
operator|=
name|input_line_pointer
expr_stmt|;
name|delim
operator|=
name|get_symbol_end
argument_list|()
expr_stmt|;
name|end_name
operator|=
name|input_line_pointer
expr_stmt|;
operator|*
name|end_name
operator|=
name|delim
expr_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|!=
literal|','
condition|)
block|{
operator|*
name|end_name
operator|=
literal|0
expr_stmt|;
name|as_warn
argument_list|(
literal|"Expected comma after name \"%s\""
argument_list|,
name|name
argument_list|)
expr_stmt|;
operator|*
name|end_name
operator|=
name|delim
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
name|input_line_pointer
operator|++
expr_stmt|;
operator|*
name|end_name
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|name
index|[
literal|0
index|]
operator|==
literal|'.'
operator|&&
name|name
index|[
literal|1
index|]
operator|==
literal|'\0'
condition|)
block|{
comment|/* Turn '. = mumble' into a .org mumble */
specifier|register
name|segT
name|segment
decl_stmt|;
name|expressionS
name|exp
decl_stmt|;
specifier|register
name|char
modifier|*
name|ptr
decl_stmt|;
name|segment
operator|=
name|get_known_segmented_expression
argument_list|(
operator|&
name|exp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|need_pass_2
condition|)
block|{
if|if
condition|(
name|segment
operator|!=
name|now_seg
operator|&&
name|segment
operator|!=
name|SEG_ABSOLUTE
condition|)
name|as_warn
argument_list|(
literal|"Illegal segment \"%s\". Segment \"%s\" assumed."
argument_list|,
name|seg_name
index|[
operator|(
name|int
operator|)
name|segment
index|]
argument_list|,
name|seg_name
index|[
operator|(
name|int
operator|)
name|now_seg
index|]
argument_list|)
expr_stmt|;
name|ptr
operator|=
name|frag_var
argument_list|(
name|rs_org
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
operator|(
name|relax_substateT
operator|)
literal|0
argument_list|,
name|exp
operator|.
name|X_add_symbol
argument_list|,
name|exp
operator|.
name|X_add_number
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
operator|*
name|ptr
operator|=
literal|0
expr_stmt|;
block|}
comment|/* if (ok to make frag) */
operator|*
name|end_name
operator|=
name|delim
expr_stmt|;
return|return;
block|}
name|symbolP
operator|=
name|symbol_find_or_make
argument_list|(
name|name
argument_list|)
expr_stmt|;
operator|*
name|end_name
operator|=
name|delim
expr_stmt|;
name|pseudo_set
argument_list|(
name|symbolP
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|s_space
parameter_list|()
block|{
name|long
name|int
name|temp_repeat
decl_stmt|;
specifier|register
name|long
name|int
name|temp_fill
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
comment|/* Just like .fill, but temp_size = 1 */
if|if
condition|(
name|get_absolute_expression_and_terminator
argument_list|(
operator|&
name|temp_repeat
argument_list|)
operator|==
literal|','
condition|)
block|{
name|temp_fill
operator|=
name|get_absolute_expression
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|input_line_pointer
operator|--
expr_stmt|;
comment|/* Backup over what was not a ','. */
name|temp_fill
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|temp_repeat
operator|<=
literal|0
condition|)
block|{
name|as_warn
argument_list|(
literal|"Repeat< 0, .space ignored"
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|need_pass_2
condition|)
block|{
name|p
operator|=
name|frag_var
argument_list|(
name|rs_fill
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
operator|(
name|relax_substateT
operator|)
literal|0
argument_list|,
operator|(
name|symbolS
operator|*
operator|)
literal|0
argument_list|,
name|temp_repeat
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
operator|*
name|p
operator|=
name|temp_fill
expr_stmt|;
block|}
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|s_text
parameter_list|()
block|{
specifier|register
name|int
name|temp
decl_stmt|;
name|temp
operator|=
name|get_absolute_expression
argument_list|()
expr_stmt|;
name|subseg_new
argument_list|(
name|SEG_TEXT
argument_list|,
operator|(
name|subsegT
operator|)
name|temp
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*( JF was static, but can't be if machine dependent pseudo-ops are to use it */
end_comment

begin_function
name|void
name|demand_empty_rest_of_line
parameter_list|()
block|{
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
if|if
condition|(
name|is_end_of_line
index|[
operator|*
name|input_line_pointer
index|]
condition|)
block|{
name|input_line_pointer
operator|++
expr_stmt|;
block|}
else|else
block|{
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
block|}
comment|/* Return having already swallowed end-of-line. */
block|}
end_function

begin_comment
comment|/* Return pointing just after end-of-line. */
end_comment

begin_function
name|void
name|ignore_rest_of_line
parameter_list|()
comment|/* For suspect lines: gives warning. */
block|{
if|if
condition|(
operator|!
name|is_end_of_line
index|[
operator|*
name|input_line_pointer
index|]
condition|)
block|{
name|as_warn
argument_list|(
literal|"Rest of line ignored. 1st junk character valued %d (%c)."
argument_list|,
operator|*
name|input_line_pointer
argument_list|,
operator|*
name|input_line_pointer
argument_list|)
expr_stmt|;
while|while
condition|(
name|input_line_pointer
operator|<
name|buffer_limit
operator|&&
operator|!
name|is_end_of_line
index|[
operator|*
name|input_line_pointer
index|]
condition|)
block|{
name|input_line_pointer
operator|++
expr_stmt|;
block|}
block|}
name|input_line_pointer
operator|++
expr_stmt|;
comment|/* Return pointing just after end-of-line. */
name|know
argument_list|(
name|is_end_of_line
index|[
name|input_line_pointer
index|[
operator|-
literal|1
index|]
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *			stab()  *  * Handle .stabX directives, which used to be open-coded.  * So much creeping featurism overloaded the semantics that we decided  * to put all .stabX thinking in one place. Here.  *  * We try to make any .stabX directive legal. Other people's AS will often  * do assembly-time consistency checks: eg assigning meaning to n_type bits  * and "protecting" you from setting them to certain values. (They also zero  * certain bits before emitting symbols. Tut tut.)  *  * If an expression is not absolute we either gripe or use the relocation  * information. Other people's assemblers silently forget information they  * don't need and invent information they need that you didn't supply.  *  * .stabX directives always make a symbol table entry. It may be junk if  * the rest of your .stabX directive is malformed.  */
end_comment

begin_function
specifier|static
name|void
name|stab
parameter_list|(
name|what
parameter_list|)
name|int
name|what
decl_stmt|;
block|{
specifier|register
name|symbolS
modifier|*
name|symbolP
decl_stmt|;
specifier|register
name|char
modifier|*
name|string
decl_stmt|;
name|int
name|saved_type
decl_stmt|;
name|int
name|length
decl_stmt|;
name|int
name|goof
decl_stmt|;
comment|/* TRUE if we have aborted. */
name|long
name|int
name|longint
decl_stmt|;
comment|/*  * Enter with input_line_pointer pointing past .stabX and any following  * whitespace.  */
name|goof
operator|=
name|FALSE
expr_stmt|;
comment|/* JF who forgot this?? */
if|if
condition|(
name|what
operator|==
literal|'s'
condition|)
block|{
name|string
operator|=
name|demand_copy_C_string
argument_list|(
operator|&
name|length
argument_list|)
expr_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|==
literal|','
condition|)
name|input_line_pointer
operator|++
expr_stmt|;
else|else
block|{
name|as_warn
argument_list|(
literal|"I need a comma after symbol's name"
argument_list|)
expr_stmt|;
name|goof
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
else|else
name|string
operator|=
literal|""
expr_stmt|;
comment|/*  * Input_line_pointer->after ','.  String -> symbol name.  */
if|if
condition|(
operator|!
name|goof
condition|)
block|{
name|symbolP
operator|=
name|symbol_new
argument_list|(
name|string
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|(
expr|struct
name|frag
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|what
condition|)
block|{
case|case
literal|'d'
case|:
name|symbolP
operator|->
name|sy_name
operator|=
name|NULL
expr_stmt|;
comment|/* .stabd feature. */
name|symbolP
operator|->
name|sy_value
operator|=
name|obstack_next_free
argument_list|(
operator|&
name|frags
argument_list|)
operator|-
name|frag_now
operator|->
name|fr_literal
expr_stmt|;
name|symbolP
operator|->
name|sy_frag
operator|=
name|frag_now
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
name|symbolP
operator|->
name|sy_frag
operator|=
operator|&
name|zero_address_frag
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
name|symbolP
operator|->
name|sy_frag
operator|=
operator|&
name|zero_address_frag
expr_stmt|;
break|break;
default|default:
name|BAD_CASE
argument_list|(
name|what
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|get_absolute_expression_and_terminator
argument_list|(
operator|&
name|longint
argument_list|)
operator|==
literal|','
condition|)
name|symbolP
operator|->
name|sy_type
operator|=
name|saved_type
operator|=
name|longint
expr_stmt|;
else|else
block|{
name|as_warn
argument_list|(
literal|"I want a comma after the n_type expression"
argument_list|)
expr_stmt|;
name|goof
operator|=
name|TRUE
expr_stmt|;
name|input_line_pointer
operator|--
expr_stmt|;
comment|/* Backup over a non-',' char. */
block|}
block|}
if|if
condition|(
operator|!
name|goof
condition|)
block|{
if|if
condition|(
name|get_absolute_expression_and_terminator
argument_list|(
operator|&
name|longint
argument_list|)
operator|==
literal|','
condition|)
name|symbolP
operator|->
name|sy_other
operator|=
name|longint
expr_stmt|;
else|else
block|{
name|as_warn
argument_list|(
literal|"I want a comma after the n_other expression"
argument_list|)
expr_stmt|;
name|goof
operator|=
name|TRUE
expr_stmt|;
name|input_line_pointer
operator|--
expr_stmt|;
comment|/* Backup over a non-',' char. */
block|}
block|}
if|if
condition|(
operator|!
name|goof
condition|)
block|{
name|symbolP
operator|->
name|sy_desc
operator|=
name|get_absolute_expression
argument_list|()
expr_stmt|;
if|if
condition|(
name|what
operator|==
literal|'s'
operator|||
name|what
operator|==
literal|'n'
condition|)
block|{
if|if
condition|(
operator|*
name|input_line_pointer
operator|!=
literal|','
condition|)
block|{
name|as_warn
argument_list|(
literal|"I want a comma after the n_desc expression"
argument_list|)
expr_stmt|;
name|goof
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
name|input_line_pointer
operator|++
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
operator|(
operator|!
name|goof
operator|)
operator|&&
operator|(
name|what
operator|==
literal|'s'
operator|||
name|what
operator|==
literal|'n'
operator|)
condition|)
block|{
name|pseudo_set
argument_list|(
name|symbolP
argument_list|)
expr_stmt|;
name|symbolP
operator|->
name|sy_type
operator|=
name|saved_type
expr_stmt|;
block|}
if|if
condition|(
name|goof
condition|)
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
else|else
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *			pseudo_set()  *  * In:	Pointer to a symbol.  *	Input_line_pointer -> expression.  *  * Out:	Input_line_pointer -> just after any whitespace after expression.  *	Tried to set symbol to value of expression.  *	Will change sy_type, sy_value, sy_frag;  *	May set need_pass_2 == TRUE.  */
end_comment

begin_function
specifier|static
name|void
name|pseudo_set
parameter_list|(
name|symbolP
parameter_list|)
name|symbolS
modifier|*
name|symbolP
decl_stmt|;
block|{
name|expressionS
name|exp
decl_stmt|;
specifier|register
name|segT
name|segment
decl_stmt|;
name|int
name|ext
decl_stmt|;
name|know
argument_list|(
name|symbolP
argument_list|)
expr_stmt|;
comment|/* NULL pointer is logic error. */
name|ext
operator|=
operator|(
name|symbolP
operator|->
name|sy_type
operator|&
name|N_EXT
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|segment
operator|=
name|expression
argument_list|(
operator|&
name|exp
argument_list|)
operator|)
operator|==
name|SEG_NONE
condition|)
block|{
name|as_warn
argument_list|(
literal|"Missing expression: absolute 0 assumed"
argument_list|)
expr_stmt|;
name|exp
operator|.
name|X_seg
operator|=
name|SEG_ABSOLUTE
expr_stmt|;
name|exp
operator|.
name|X_add_number
operator|=
literal|0
expr_stmt|;
block|}
switch|switch
condition|(
name|segment
condition|)
block|{
case|case
name|SEG_BIG
case|:
name|as_warn
argument_list|(
literal|"%s number illegal. Absolute 0 assumed."
argument_list|,
name|exp
operator|.
name|X_add_number
operator|>
literal|0
condition|?
literal|"Bignum"
else|:
literal|"Floating-Point"
argument_list|)
expr_stmt|;
name|symbolP
operator|->
name|sy_type
operator|=
name|N_ABS
operator||
name|ext
expr_stmt|;
name|symbolP
operator|->
name|sy_value
operator|=
literal|0
expr_stmt|;
name|symbolP
operator|->
name|sy_frag
operator|=
operator|&
name|zero_address_frag
expr_stmt|;
break|break;
case|case
name|SEG_NONE
case|:
name|as_warn
argument_list|(
literal|"No expression:  Using absolute 0"
argument_list|)
expr_stmt|;
name|symbolP
operator|->
name|sy_type
operator|=
name|N_ABS
operator||
name|ext
expr_stmt|;
name|symbolP
operator|->
name|sy_value
operator|=
literal|0
expr_stmt|;
name|symbolP
operator|->
name|sy_frag
operator|=
operator|&
name|zero_address_frag
expr_stmt|;
break|break;
case|case
name|SEG_DIFFERENCE
case|:
if|if
condition|(
name|exp
operator|.
name|X_add_symbol
operator|&&
name|exp
operator|.
name|X_subtract_symbol
operator|&&
operator|(
name|exp
operator|.
name|X_add_symbol
operator|->
name|sy_type
operator|&
name|N_TYPE
operator|)
operator|==
operator|(
name|exp
operator|.
name|X_subtract_symbol
operator|->
name|sy_type
operator|&
name|N_TYPE
operator|)
condition|)
block|{
if|if
condition|(
name|exp
operator|.
name|X_add_symbol
operator|->
name|sy_frag
operator|!=
name|exp
operator|.
name|X_subtract_symbol
operator|->
name|sy_frag
condition|)
block|{
name|as_bad
argument_list|(
literal|"Unknown expression: symbols %s and %s are in different frags."
argument_list|,
name|exp
operator|.
name|X_add_symbol
operator|->
name|sy_name
argument_list|,
name|exp
operator|.
name|X_subtract_symbol
operator|->
name|sy_name
argument_list|)
expr_stmt|;
name|need_pass_2
operator|++
expr_stmt|;
block|}
name|exp
operator|.
name|X_add_number
operator|+=
name|exp
operator|.
name|X_add_symbol
operator|->
name|sy_value
operator|-
name|exp
operator|.
name|X_subtract_symbol
operator|->
name|sy_value
expr_stmt|;
block|}
else|else
name|as_warn
argument_list|(
literal|"Complex expression. Absolute segment assumed."
argument_list|)
expr_stmt|;
case|case
name|SEG_ABSOLUTE
case|:
name|symbolP
operator|->
name|sy_type
operator|=
name|N_ABS
operator||
name|ext
expr_stmt|;
name|symbolP
operator|->
name|sy_value
operator|=
name|exp
operator|.
name|X_add_number
expr_stmt|;
name|symbolP
operator|->
name|sy_frag
operator|=
operator|&
name|zero_address_frag
expr_stmt|;
break|break;
case|case
name|SEG_DATA
case|:
case|case
name|SEG_TEXT
case|:
case|case
name|SEG_BSS
case|:
name|symbolP
operator|->
name|sy_type
operator|=
name|seg_N_TYPE
index|[
operator|(
name|int
operator|)
name|segment
index|]
operator||
name|ext
expr_stmt|;
name|symbolP
operator|->
name|sy_value
operator|=
name|exp
operator|.
name|X_add_number
operator|+
name|exp
operator|.
name|X_add_symbol
operator|->
name|sy_value
expr_stmt|;
name|symbolP
operator|->
name|sy_frag
operator|=
name|exp
operator|.
name|X_add_symbol
operator|->
name|sy_frag
expr_stmt|;
break|break;
case|case
name|SEG_PASS1
case|:
comment|/* Not an error. Just try another pass. */
name|symbolP
operator|->
name|sy_forward
operator|=
name|exp
operator|.
name|X_add_symbol
expr_stmt|;
name|as_warn
argument_list|(
literal|"Unknown expression"
argument_list|)
expr_stmt|;
name|know
argument_list|(
name|need_pass_2
operator|==
name|TRUE
argument_list|)
expr_stmt|;
break|break;
case|case
name|SEG_UNKNOWN
case|:
name|symbolP
operator|->
name|sy_forward
operator|=
name|exp
operator|.
name|X_add_symbol
expr_stmt|;
comment|/* as_warn("unknown symbol"); */
comment|/* need_pass_2 = TRUE; */
break|break;
default|default:
name|BAD_CASE
argument_list|(
name|segment
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  * stabs(file), stabf(func) and stabd(line) -- for the purpose of  * source file debugging of assembly files, generate file,  * function and line number stabs, respectively.  * These functions have corresponding functions named  * filestab(), funcstab() and linestab() in input-scrub.c,  * where logical files and logical line numbers are handled.  */
end_comment

begin_include
include|#
directive|include
file|<stab.h>
end_include

begin_macro
name|stabs
argument_list|(
argument|file
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|file
decl_stmt|;
end_decl_stmt

begin_block
block|{
comment|/* .stabs "file",100,0,0,. */
operator|(
name|void
operator|)
name|symbol_new
argument_list|(
name|file
argument_list|,
name|N_SO
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|obstack_next_free
argument_list|(
operator|&
name|frags
argument_list|)
operator|-
name|frag_now
operator|->
name|fr_literal
argument_list|,
name|frag_now
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|stabf
argument_list|(
argument|func
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|func
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|symbolS
modifier|*
name|symbolP
decl_stmt|;
specifier|static
name|int
name|void_undefined
init|=
literal|1
decl_stmt|;
comment|/* crudely filter uninteresting labels: require an initial '_' */
if|if
condition|(
operator|*
name|func
operator|++
operator|!=
literal|'_'
condition|)
return|return;
comment|/* assembly functions are assumed to have void type */
if|if
condition|(
name|void_undefined
condition|)
block|{
comment|/* .stabs "void:t15=15",128,0,0,0 */
operator|(
name|void
operator|)
name|symbol_new
argument_list|(
literal|"void:t1=1"
argument_list|,
name|N_LSYM
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|&
name|zero_address_frag
argument_list|)
expr_stmt|;
name|void_undefined
operator|=
literal|0
expr_stmt|;
block|}
comment|/* .stabs "func:F1",36,0,0,. */
name|symbolP
operator|=
name|symbol_new
argument_list|(
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
name|N_FUN
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|obstack_next_free
argument_list|(
operator|&
name|frags
argument_list|)
operator|-
name|frag_now
operator|->
name|fr_literal
argument_list|,
name|frag_now
argument_list|)
expr_stmt|;
name|obstack_grow
argument_list|(
operator|&
name|notes
argument_list|,
name|func
argument_list|,
name|strlen
argument_list|(
name|func
argument_list|)
argument_list|)
expr_stmt|;
name|obstack_1grow
argument_list|(
operator|&
name|notes
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
name|obstack_1grow
argument_list|(
operator|&
name|notes
argument_list|,
literal|'F'
argument_list|)
expr_stmt|;
name|obstack_1grow
argument_list|(
operator|&
name|notes
argument_list|,
literal|'1'
argument_list|)
expr_stmt|;
name|obstack_1grow
argument_list|(
operator|&
name|notes
argument_list|,
literal|'\0'
argument_list|)
expr_stmt|;
name|symbolP
operator|->
name|sy_name
operator|=
name|obstack_finish
argument_list|(
operator|&
name|notes
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|stabd
argument_list|(
argument|line
argument_list|)
end_macro

begin_decl_stmt
name|unsigned
name|line
decl_stmt|;
end_decl_stmt

begin_block
block|{
comment|/* .stabd 68,0,line */
operator|(
name|void
operator|)
name|symbol_new
argument_list|(
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
name|N_SLINE
argument_list|,
literal|0
argument_list|,
name|line
argument_list|,
name|obstack_next_free
argument_list|(
operator|&
name|frags
argument_list|)
operator|-
name|frag_now
operator|->
name|fr_literal
argument_list|,
name|frag_now
argument_list|)
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/*  *			cons()  *  * CONStruct more frag of .bytes, or .words etc.  * Should need_pass_2 be TRUE then emit no frag(s).  * This understands EXPRESSIONS, as opposed to big_cons().  *  * Bug (?)  *  * This has a split personality. We use expression() to read the  * value. We can detect if the value won't fit in a byte or word.  * But we can't detect if expression() discarded significant digits  * in the case of a long. Not worth the crocks required to fix it.  */
end_comment

begin_function
name|void
name|cons
parameter_list|(
name|nbytes
parameter_list|)
comment|/* worker to do .byte etc statements */
comment|/* clobbers input_line_pointer, checks */
comment|/* end-of-line. */
specifier|register
name|int
name|nbytes
decl_stmt|;
comment|/* 1=.byte, 2=.word, 4=.long */
block|{
specifier|register
name|char
name|c
decl_stmt|;
specifier|register
name|long
name|int
name|mask
decl_stmt|;
comment|/* High-order bits we will left-truncate, */
comment|/* but includes sign bit also. */
specifier|register
name|long
name|int
name|get
decl_stmt|;
comment|/* what we get */
specifier|register
name|long
name|int
name|use
decl_stmt|;
comment|/* get after truncation. */
specifier|register
name|long
name|int
name|unmask
decl_stmt|;
comment|/* what bits we will store */
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|segT
name|segment
decl_stmt|;
name|expressionS
name|exp
decl_stmt|;
ifdef|#
directive|ifdef
name|NS32K
name|void
name|fix_new_ns32k
parameter_list|()
function_decl|;
else|#
directive|else
name|void
name|fix_new
parameter_list|()
function_decl|;
endif|#
directive|endif
comment|/*    * Input_line_pointer -> 1st char after pseudo-op-code and could legally    * be a end-of-line. (Or, less legally an eof - which we cope with.)    */
comment|/* JF<< of>= number of bits in the object is undefined.  In particular      SPARC (Sun 4) has problems */
if|if
condition|(
name|nbytes
operator|>=
expr|sizeof
operator|(
name|long
name|int
operator|)
condition|)
name|mask
operator|=
literal|0
expr_stmt|;
else|else
name|mask
operator|=
operator|~
literal|0
operator|<<
operator|(
name|BITS_PER_CHAR
operator|*
name|nbytes
operator|)
expr_stmt|;
comment|/* Don't store these bits. */
name|unmask
operator|=
operator|~
name|mask
expr_stmt|;
comment|/* Do store these bits. */
ifdef|#
directive|ifdef
name|NEVER
literal|"Do this mod if you want every overflow check to assume SIGNED 2's complement data."
expr_stmt|;
name|mask
operator|=
operator|~
operator|(
name|unmask
operator|>>
literal|1
operator|)
expr_stmt|;
comment|/* Includes sign bit now. */
endif|#
directive|endif
comment|/*    * The following awkward logic is to parse ZERO or more expressions,    * comma seperated. Recall an expression includes its leading&    * trailing blanks. We fake a leading ',' if there is (supposed to    * be) a 1st expression, and keep demanding 1 expression for each ','.    */
if|if
condition|(
name|is_it_end_of_statement
argument_list|()
condition|)
block|{
name|c
operator|=
literal|0
expr_stmt|;
comment|/* Skip loop. */
name|input_line_pointer
operator|++
expr_stmt|;
comment|/* Matches end-of-loop 'correction'. */
block|}
else|else
name|c
operator|=
literal|','
expr_stmt|;
comment|/* Do loop. */
while|while
condition|(
name|c
operator|==
literal|','
condition|)
block|{
name|segment
operator|=
name|expression
argument_list|(
operator|&
name|exp
argument_list|)
expr_stmt|;
comment|/* At least scan over the expression. */
if|if
condition|(
operator|!
name|need_pass_2
condition|)
block|{
comment|/* Still worthwhile making frags. */
comment|/* Don't call this if we are going to junk this pass anyway! */
name|know
argument_list|(
name|segment
operator|!=
name|SEG_PASS1
argument_list|)
expr_stmt|;
if|if
condition|(
name|segment
operator|==
name|SEG_DIFFERENCE
operator|&&
name|exp
operator|.
name|X_add_symbol
operator|==
name|NULL
condition|)
block|{
name|as_warn
argument_list|(
literal|"Subtracting symbol \"%s\"(segment\"%s\") is too hard. Absolute segment assumed."
argument_list|,
name|exp
operator|.
name|X_subtract_symbol
operator|->
name|sy_name
argument_list|,
name|seg_name
index|[
operator|(
name|int
operator|)
name|N_TYPE_seg
index|[
name|exp
operator|.
name|X_subtract_symbol
operator|->
name|sy_type
operator|&
name|N_TYPE
index|]
index|]
argument_list|)
expr_stmt|;
name|segment
operator|=
name|SEG_ABSOLUTE
expr_stmt|;
comment|/* Leave exp . X_add_number alone. */
block|}
name|p
operator|=
name|frag_more
argument_list|(
name|nbytes
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|segment
condition|)
block|{
case|case
name|SEG_BIG
case|:
name|as_warn
argument_list|(
literal|"%s number illegal. Absolute 0 assumed."
argument_list|,
name|exp
operator|.
name|X_add_number
operator|>
literal|0
condition|?
literal|"Bignum"
else|:
literal|"Floating-Point"
argument_list|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|p
argument_list|,
operator|(
name|long
operator|)
literal|0
argument_list|,
name|nbytes
argument_list|)
expr_stmt|;
break|break;
case|case
name|SEG_NONE
case|:
name|as_warn
argument_list|(
literal|"0 assumed for missing expression"
argument_list|)
expr_stmt|;
name|exp
operator|.
name|X_add_number
operator|=
literal|0
expr_stmt|;
name|know
argument_list|(
name|exp
operator|.
name|X_add_symbol
operator|==
name|NULL
argument_list|)
expr_stmt|;
comment|/* fall into SEG_ABSOLUTE */
case|case
name|SEG_ABSOLUTE
case|:
name|get
operator|=
name|exp
operator|.
name|X_add_number
expr_stmt|;
name|use
operator|=
name|get
operator|&
name|unmask
expr_stmt|;
if|if
condition|(
operator|(
name|get
operator|&
name|mask
operator|)
operator|&&
operator|(
name|get
operator|&
name|mask
operator|)
operator|!=
name|mask
condition|)
block|{
comment|/* Leading bits contain both 0s& 1s. */
name|as_warn
argument_list|(
literal|"Value x%x truncated to x%x."
argument_list|,
name|get
argument_list|,
name|use
argument_list|)
expr_stmt|;
block|}
name|md_number_to_chars
argument_list|(
name|p
argument_list|,
name|use
argument_list|,
name|nbytes
argument_list|)
expr_stmt|;
comment|/* put bytes in right order. */
break|break;
case|case
name|SEG_DIFFERENCE
case|:
ifndef|#
directive|ifndef
name|WORKING_DOT_WORD
if|if
condition|(
name|nbytes
operator|==
literal|2
condition|)
block|{
name|struct
name|broken_word
modifier|*
name|x
decl_stmt|;
name|x
operator|=
operator|(
expr|struct
name|broken_word
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|broken_word
argument_list|)
argument_list|)
expr_stmt|;
name|x
operator|->
name|next_broken_word
operator|=
name|broken_words
expr_stmt|;
name|broken_words
operator|=
name|x
expr_stmt|;
name|x
operator|->
name|frag
operator|=
name|frag_now
expr_stmt|;
name|x
operator|->
name|word_goes_here
operator|=
name|p
expr_stmt|;
name|x
operator|->
name|dispfrag
operator|=
literal|0
expr_stmt|;
name|x
operator|->
name|add
operator|=
name|exp
operator|.
name|X_add_symbol
expr_stmt|;
name|x
operator|->
name|sub
operator|=
name|exp
operator|.
name|X_subtract_symbol
expr_stmt|;
name|x
operator|->
name|addnum
operator|=
name|exp
operator|.
name|X_add_number
expr_stmt|;
name|x
operator|->
name|added
operator|=
literal|0
expr_stmt|;
name|new_broken_words
operator|++
expr_stmt|;
break|break;
block|}
comment|/* Else Fall through into. . . */
endif|#
directive|endif
case|case
name|SEG_BSS
case|:
case|case
name|SEG_UNKNOWN
case|:
case|case
name|SEG_TEXT
case|:
case|case
name|SEG_DATA
case|:
if|#
directive|if
name|defined
argument_list|(
name|SPARC
argument_list|)
operator|||
name|defined
argument_list|(
name|I860
argument_list|)
name|fix_new
argument_list|(
name|frag_now
argument_list|,
name|p
operator|-
name|frag_now
operator|->
name|fr_literal
argument_list|,
name|nbytes
argument_list|,
name|exp
operator|.
name|X_add_symbol
argument_list|,
name|exp
operator|.
name|X_subtract_symbol
argument_list|,
name|exp
operator|.
name|X_add_number
argument_list|,
literal|0
argument_list|,
name|RELOC_32
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|NS32K
name|fix_new_ns32k
argument_list|(
name|frag_now
argument_list|,
name|p
operator|-
name|frag_now
operator|->
name|fr_literal
argument_list|,
name|nbytes
argument_list|,
name|exp
operator|.
name|X_add_symbol
argument_list|,
name|exp
operator|.
name|X_subtract_symbol
argument_list|,
name|exp
operator|.
name|X_add_number
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
operator|!
name|defined
argument_list|(
name|SPARC
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|NS32K
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|I860
argument_list|)
name|fix_new
argument_list|(
name|frag_now
argument_list|,
name|p
operator|-
name|frag_now
operator|->
name|fr_literal
argument_list|,
name|nbytes
argument_list|,
name|exp
operator|.
name|X_add_symbol
argument_list|,
name|exp
operator|.
name|X_subtract_symbol
argument_list|,
name|exp
operator|.
name|X_add_number
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
default|default:
name|BAD_CASE
argument_list|(
name|segment
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* switch(segment) */
block|}
comment|/* if(!need_pass_2) */
name|c
operator|=
operator|*
name|input_line_pointer
operator|++
expr_stmt|;
block|}
comment|/* while(c==',') */
name|input_line_pointer
operator|--
expr_stmt|;
comment|/* Put terminator back into stream. */
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* cons() */
end_comment

begin_escape
end_escape

begin_comment
comment|/*  *			big_cons()  *  * CONStruct more frag(s) of .quads, or .octa etc.  * Makes 0 or more new frags.  * If need_pass_2 == TRUE, generate no frag.  * This understands only bignums, not expressions. Cons() understands  * expressions.  *  * Constants recognised are '0...'(octal) '0x...'(hex) '...'(decimal).  *  * This creates objects with struct obstack_control objs, destroying  * any context objs held about a partially completed object. Beware!  *  *  * I think it sucks to have 2 different types of integers, with 2  * routines to read them, store them etc.  * It would be nicer to permit bignums in expressions and only  * complain if the result overflowed. However, due to "efficiency"...  */
end_comment

begin_function
name|void
name|big_cons
parameter_list|(
name|nbytes
parameter_list|)
comment|/* worker to do .quad etc statements */
comment|/* clobbers input_line_pointer, checks */
comment|/* end-of-line. */
specifier|register
name|int
name|nbytes
decl_stmt|;
comment|/* 8=.quad 16=.octa ... */
block|{
specifier|register
name|char
name|c
decl_stmt|;
comment|/* input_line_pointer -> c. */
specifier|register
name|int
name|radix
decl_stmt|;
specifier|register
name|long
name|int
name|length
decl_stmt|;
comment|/* Number of chars in an object. */
specifier|register
name|int
name|digit
decl_stmt|;
comment|/* Value of 1 digit. */
specifier|register
name|int
name|carry
decl_stmt|;
comment|/* For multi-precision arithmetic. */
specifier|register
name|int
name|work
decl_stmt|;
comment|/* For multi-precision arithmetic. */
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
comment|/* For multi-precision arithmetic. */
specifier|extern
name|char
name|hex_value
index|[]
decl_stmt|;
comment|/* In hex_value.c. */
comment|/*    * The following awkward logic is to parse ZERO or more strings,    * comma seperated. Recall an expression includes its leading&    * trailing blanks. We fake a leading ',' if there is (supposed to    * be) a 1st expression, and keep demanding 1 expression for each ','.    */
if|if
condition|(
name|is_it_end_of_statement
argument_list|()
condition|)
block|{
name|c
operator|=
literal|0
expr_stmt|;
comment|/* Skip loop. */
block|}
else|else
block|{
name|c
operator|=
literal|','
expr_stmt|;
comment|/* Do loop. */
operator|--
name|input_line_pointer
expr_stmt|;
block|}
while|while
condition|(
name|c
operator|==
literal|','
condition|)
block|{
operator|++
name|input_line_pointer
expr_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
name|c
operator|=
operator|*
name|input_line_pointer
expr_stmt|;
comment|/* C contains 1st non-blank character of what we hope is a number. */
if|if
condition|(
name|c
operator|==
literal|'0'
condition|)
block|{
name|c
operator|=
operator|*
operator|++
name|input_line_pointer
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'x'
operator|||
name|c
operator|==
literal|'X'
condition|)
block|{
name|c
operator|=
operator|*
operator|++
name|input_line_pointer
expr_stmt|;
name|radix
operator|=
literal|16
expr_stmt|;
block|}
else|else
block|{
name|radix
operator|=
literal|8
expr_stmt|;
block|}
block|}
else|else
block|{
name|radix
operator|=
literal|10
expr_stmt|;
block|}
comment|/*        * This feature (?) is here to stop people worrying about        * mysterious zero constants: which is what they get when        * they completely omit digits.        */
if|if
condition|(
name|hex_value
index|[
name|c
index|]
operator|>=
name|radix
condition|)
block|{
name|as_warn
argument_list|(
literal|"Missing digits. 0 assumed."
argument_list|)
expr_stmt|;
block|}
name|bignum_high
operator|=
name|bignum_low
operator|-
literal|1
expr_stmt|;
comment|/* Start constant with 0 chars. */
for|for
control|(
init|;
operator|(
name|digit
operator|=
name|hex_value
index|[
name|c
index|]
operator|)
operator|<
name|radix
condition|;
name|c
operator|=
operator|*
operator|++
name|input_line_pointer
control|)
block|{
comment|/* Multiply existing number by radix, then add digit. */
name|carry
operator|=
name|digit
expr_stmt|;
for|for
control|(
name|p
operator|=
name|bignum_low
init|;
name|p
operator|<=
name|bignum_high
condition|;
name|p
operator|++
control|)
block|{
name|work
operator|=
operator|(
operator|*
name|p
operator|&
name|MASK_CHAR
operator|)
operator|*
name|radix
operator|+
name|carry
expr_stmt|;
operator|*
name|p
operator|=
name|work
operator|&
name|MASK_CHAR
expr_stmt|;
name|carry
operator|=
name|work
operator|>>
name|BITS_PER_CHAR
expr_stmt|;
block|}
if|if
condition|(
name|carry
condition|)
block|{
name|grow_bignum
argument_list|()
expr_stmt|;
operator|*
name|bignum_high
operator|=
name|carry
operator|&
name|MASK_CHAR
expr_stmt|;
name|know
argument_list|(
operator|(
name|carry
operator|&
operator|~
name|MASK_CHAR
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
name|length
operator|=
name|bignum_high
operator|-
name|bignum_low
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|length
operator|>
name|nbytes
condition|)
block|{
name|as_warn
argument_list|(
literal|"Most significant bits truncated in integer constant."
argument_list|)
expr_stmt|;
block|}
else|else
block|{
specifier|register
name|long
name|int
name|leading_zeroes
decl_stmt|;
for|for
control|(
name|leading_zeroes
operator|=
name|nbytes
operator|-
name|length
init|;
name|leading_zeroes
condition|;
name|leading_zeroes
operator|--
control|)
block|{
name|grow_bignum
argument_list|()
expr_stmt|;
operator|*
name|bignum_high
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|need_pass_2
condition|)
block|{
name|p
operator|=
name|frag_more
argument_list|(
name|nbytes
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|bignum_low
argument_list|,
name|p
argument_list|,
operator|(
name|int
operator|)
name|nbytes
argument_list|)
expr_stmt|;
block|}
comment|/* C contains character after number. */
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
name|c
operator|=
operator|*
name|input_line_pointer
expr_stmt|;
comment|/* C contains 1st non-blank character after number. */
block|}
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* big_cons() */
end_comment

begin_function
specifier|static
name|void
name|grow_bignum
parameter_list|()
comment|/* Extend bignum by 1 char. */
block|{
specifier|register
name|long
name|int
name|length
decl_stmt|;
name|bignum_high
operator|++
expr_stmt|;
if|if
condition|(
name|bignum_high
operator|>=
name|bignum_limit
condition|)
block|{
name|length
operator|=
name|bignum_limit
operator|-
name|bignum_low
expr_stmt|;
name|bignum_low
operator|=
name|xrealloc
argument_list|(
name|bignum_low
argument_list|,
name|length
operator|+
name|length
argument_list|)
expr_stmt|;
name|bignum_high
operator|=
name|bignum_low
operator|+
name|length
expr_stmt|;
name|bignum_limit
operator|=
name|bignum_low
operator|+
name|length
operator|+
name|length
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* grow_bignum(); */
end_comment

begin_escape
end_escape

begin_comment
comment|/*  *			float_cons()  *  * CONStruct some more frag chars of .floats .ffloats etc.  * Makes 0 or more new frags.  * If need_pass_2 == TRUE, no frags are emitted.  * This understands only floating literals, not expressions. Sorry.  *  * A floating constant is defined by atof_generic(), except it is preceded  * by 0d 0f 0g or 0h. After observing the STRANGE way my BSD AS does its  * reading, I decided to be incompatible. This always tries to give you  * rounded bits to the precision of the pseudo-op. Former AS did premature  * truncatation, restored noisy bits instead of trailing 0s AND gave you  * a choice of 2 flavours of noise according to which of 2 floating-point  * scanners you directed AS to use.  *  * In:	input_line_pointer -> whitespace before, or '0' of flonum.  *  */
end_comment

begin_decl_stmt
name|void
comment|/* JF was static, but can't be if VAX.C is goning to use it */
name|float_cons
argument_list|(
name|float_type
argument_list|)
comment|/* Worker to do .float etc statements. */
comment|/* Clobbers input_line-pointer, checks end-of-line. */
decl|register
name|float_type
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 'f':.ffloat ... 'F':.float ... */
end_comment

begin_block
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|char
name|c
decl_stmt|;
name|int
name|length
decl_stmt|;
comment|/* Number of chars in an object. */
specifier|register
name|char
modifier|*
name|err
decl_stmt|;
comment|/* Error from scanning floating literal. */
name|char
name|temp
index|[
name|MAXIMUM_NUMBER_OF_CHARS_FOR_FLOAT
index|]
decl_stmt|;
comment|/*    * The following awkward logic is to parse ZERO or more strings,    * comma seperated. Recall an expression includes its leading&    * trailing blanks. We fake a leading ',' if there is (supposed to    * be) a 1st expression, and keep demanding 1 expression for each ','.    */
if|if
condition|(
name|is_it_end_of_statement
argument_list|()
condition|)
block|{
name|c
operator|=
literal|0
expr_stmt|;
comment|/* Skip loop. */
operator|++
name|input_line_pointer
expr_stmt|;
comment|/* -> past termintor. */
block|}
else|else
block|{
name|c
operator|=
literal|','
expr_stmt|;
comment|/* Do loop. */
block|}
while|while
condition|(
name|c
operator|==
literal|','
condition|)
block|{
comment|/* input_line_pointer -> 1st char of a flonum (we hope!). */
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
comment|/* Skip any 0{letter} that may be present. Don't even check if the        * letter is legal. Someone may invent a "z" format and this routine        * has no use for such information. Lusers beware: you get        * diagnostics if your input is ill-conditioned.        */
if|if
condition|(
name|input_line_pointer
index|[
literal|0
index|]
operator|==
literal|'0'
operator|&&
name|isalpha
argument_list|(
name|input_line_pointer
index|[
literal|1
index|]
argument_list|)
condition|)
name|input_line_pointer
operator|+=
literal|2
expr_stmt|;
name|err
operator|=
name|md_atof
argument_list|(
name|float_type
argument_list|,
name|temp
argument_list|,
operator|&
name|length
argument_list|)
expr_stmt|;
name|know
argument_list|(
name|length
operator|<=
name|MAXIMUM_NUMBER_OF_CHARS_FOR_FLOAT
argument_list|)
expr_stmt|;
name|know
argument_list|(
name|length
operator|>
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|err
condition|)
block|{
name|as_warn
argument_list|(
literal|"Bad floating literal: %s"
argument_list|,
name|err
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
comment|/* Input_line_pointer -> just after end-of-line. */
name|c
operator|=
literal|0
expr_stmt|;
comment|/* Break out of loop. */
block|}
else|else
block|{
if|if
condition|(
operator|!
name|need_pass_2
condition|)
block|{
name|p
operator|=
name|frag_more
argument_list|(
name|length
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|temp
argument_list|,
name|p
argument_list|,
name|length
argument_list|)
expr_stmt|;
block|}
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
name|c
operator|=
operator|*
name|input_line_pointer
operator|++
expr_stmt|;
comment|/* C contains 1st non-white character after number. */
comment|/* input_line_pointer -> just after terminator (c). */
block|}
block|}
operator|--
name|input_line_pointer
expr_stmt|;
comment|/* -> terminator (is not ','). */
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_block

begin_comment
comment|/* float_cons() */
end_comment

begin_escape
end_escape

begin_comment
comment|/*  *			stringer()  *  * We read 0 or more ',' seperated, double-quoted strings.  *  * Caller should have checked need_pass_2 is FALSE because we don't check it.  */
end_comment

begin_function
specifier|static
name|void
name|stringer
parameter_list|(
name|append_zero
parameter_list|)
comment|/* Worker to do .ascii etc statements. */
comment|/* Checks end-of-line. */
specifier|register
name|int
name|append_zero
decl_stmt|;
comment|/* 0: don't append '\0', else 1 */
block|{
comment|/* register char *	p; JF unused */
comment|/* register int		length; JF unused */
comment|/* Length of string we read, excluding */
comment|/* trailing '\0' implied by closing quote. */
comment|/* register char *	where; JF unused */
comment|/* register fragS *	fragP; JF unused */
specifier|register
name|int
name|c
decl_stmt|;
comment|/*    * The following awkward logic is to parse ZERO or more strings,    * comma seperated. Recall a string expression includes spaces    * before the opening '\"' and spaces after the closing '\"'.    * We fake a leading ',' if there is (supposed to be)    * a 1st, expression. We keep demanding expressions for each    * ','.    */
if|if
condition|(
name|is_it_end_of_statement
argument_list|()
condition|)
block|{
name|c
operator|=
literal|0
expr_stmt|;
comment|/* Skip loop. */
operator|++
name|input_line_pointer
expr_stmt|;
comment|/* Compensate for end of loop. */
block|}
else|else
block|{
name|c
operator|=
literal|','
expr_stmt|;
comment|/* Do loop. */
block|}
for|for
control|(
init|;
name|c
operator|==
literal|','
condition|;
name|c
operator|=
operator|*
name|input_line_pointer
operator|++
control|)
block|{
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|==
literal|'\"'
condition|)
block|{
operator|++
name|input_line_pointer
expr_stmt|;
comment|/* -> 1st char of string. */
while|while
condition|(
operator|(
name|c
operator|=
name|next_char_of_string
argument_list|()
operator|)
operator|>=
literal|0
condition|)
block|{
name|FRAG_APPEND_1_CHAR
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|append_zero
condition|)
block|{
name|FRAG_APPEND_1_CHAR
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
name|know
argument_list|(
name|input_line_pointer
index|[
operator|-
literal|1
index|]
operator|==
literal|'\"'
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|as_warn
argument_list|(
literal|"Expected \"-ed string"
argument_list|)
expr_stmt|;
block|}
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
block|}
operator|--
name|input_line_pointer
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* stringer() */
end_comment

begin_escape
end_escape

begin_function
specifier|static
name|int
name|next_char_of_string
parameter_list|()
block|{
specifier|register
name|int
name|c
decl_stmt|;
name|c
operator|=
operator|*
name|input_line_pointer
operator|++
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'\"'
case|:
name|c
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
case|case
literal|'\\'
case|:
switch|switch
condition|(
name|c
operator|=
operator|*
name|input_line_pointer
operator|++
condition|)
block|{
case|case
literal|'b'
case|:
name|c
operator|=
literal|'\b'
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
name|c
operator|=
literal|'\f'
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
name|c
operator|=
literal|'\n'
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
name|c
operator|=
literal|'\r'
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
name|c
operator|=
literal|'\t'
expr_stmt|;
break|break;
case|case
literal|'\\'
case|:
case|case
literal|'"'
case|:
break|break;
comment|/* As itself. */
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
block|{
name|long
name|int
name|number
decl_stmt|;
for|for
control|(
name|number
operator|=
literal|0
init|;
name|isdigit
argument_list|(
name|c
argument_list|)
condition|;
name|c
operator|=
operator|*
name|input_line_pointer
operator|++
control|)
block|{
name|number
operator|=
name|number
operator|*
literal|8
operator|+
name|c
operator|-
literal|'0'
expr_stmt|;
block|}
name|c
operator|=
name|number
expr_stmt|;
block|}
operator|--
name|input_line_pointer
expr_stmt|;
break|break;
case|case
literal|'\n'
case|:
comment|/*	  as_fatal( "Unterminated string - use app!" ); */
comment|/* To be compatible with BSD 4.2 as: give the luser a linefeed!! */
name|c
operator|=
literal|'\n'
expr_stmt|;
break|break;
default|default:
name|as_warn
argument_list|(
literal|"Bad escaped character in string, '?' assumed"
argument_list|)
expr_stmt|;
name|c
operator|=
literal|'?'
expr_stmt|;
break|break;
block|}
break|break;
default|default:
break|break;
block|}
return|return
operator|(
name|c
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|segT
name|get_segmented_expression
parameter_list|(
name|expP
parameter_list|)
specifier|register
name|expressionS
modifier|*
name|expP
decl_stmt|;
block|{
specifier|register
name|segT
name|retval
decl_stmt|;
if|if
condition|(
operator|(
name|retval
operator|=
name|expression
argument_list|(
name|expP
argument_list|)
operator|)
operator|==
name|SEG_PASS1
operator|||
name|retval
operator|==
name|SEG_NONE
operator|||
name|retval
operator|==
name|SEG_BIG
condition|)
block|{
name|as_warn
argument_list|(
literal|"Expected address expression: absolute 0 assumed"
argument_list|)
expr_stmt|;
name|retval
operator|=
name|expP
operator|->
name|X_seg
operator|=
name|SEG_ABSOLUTE
expr_stmt|;
name|expP
operator|->
name|X_add_number
operator|=
literal|0
expr_stmt|;
name|expP
operator|->
name|X_add_symbol
operator|=
name|expP
operator|->
name|X_subtract_symbol
operator|=
literal|0
expr_stmt|;
block|}
return|return
operator|(
name|retval
operator|)
return|;
comment|/* SEG_ ABSOLUTE,UNKNOWN,DATA,TEXT,BSS */
block|}
end_function

begin_function
specifier|static
name|segT
name|get_known_segmented_expression
parameter_list|(
name|expP
parameter_list|)
specifier|register
name|expressionS
modifier|*
name|expP
decl_stmt|;
block|{
specifier|register
name|segT
name|retval
decl_stmt|;
specifier|register
name|char
modifier|*
name|name1
decl_stmt|;
specifier|register
name|char
modifier|*
name|name2
decl_stmt|;
if|if
condition|(
operator|(
name|retval
operator|=
name|get_segmented_expression
argument_list|(
name|expP
argument_list|)
operator|)
operator|==
name|SEG_UNKNOWN
condition|)
block|{
name|name1
operator|=
name|expP
operator|->
name|X_add_symbol
condition|?
name|expP
operator|->
name|X_add_symbol
operator|->
name|sy_name
else|:
literal|""
expr_stmt|;
name|name2
operator|=
name|expP
operator|->
name|X_subtract_symbol
condition|?
name|expP
operator|->
name|X_subtract_symbol
operator|->
name|sy_name
else|:
literal|""
expr_stmt|;
if|if
condition|(
name|name1
operator|&&
name|name2
condition|)
block|{
name|as_warn
argument_list|(
literal|"Symbols \"%s\" \"%s\" are undefined: absolute 0 assumed."
argument_list|,
name|name1
argument_list|,
name|name2
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|as_warn
argument_list|(
literal|"Symbol \"%s\" undefined: absolute 0 assumed."
argument_list|,
name|name1
condition|?
name|name1
else|:
name|name2
argument_list|)
expr_stmt|;
block|}
name|retval
operator|=
name|expP
operator|->
name|X_seg
operator|=
name|SEG_ABSOLUTE
expr_stmt|;
name|expP
operator|->
name|X_add_number
operator|=
literal|0
expr_stmt|;
name|expP
operator|->
name|X_add_symbol
operator|=
name|expP
operator|->
name|X_subtract_symbol
operator|=
name|NULL
expr_stmt|;
block|}
name|know
argument_list|(
name|retval
operator|==
name|SEG_ABSOLUTE
operator|||
name|retval
operator|==
name|SEG_DATA
operator|||
name|retval
operator|==
name|SEG_TEXT
operator|||
name|retval
operator|==
name|SEG_BSS
operator|||
name|retval
operator|==
name|SEG_DIFFERENCE
argument_list|)
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_comment
comment|/* get_known_segmented_expression() */
end_comment

begin_comment
comment|/* static */
end_comment

begin_function
name|long
name|int
comment|/* JF was static, but can't be if the MD pseudos are to use it */
name|get_absolute_expression
parameter_list|()
block|{
name|expressionS
name|exp
decl_stmt|;
specifier|register
name|segT
name|s
decl_stmt|;
if|if
condition|(
operator|(
name|s
operator|=
name|expression
argument_list|(
operator|&
name|exp
argument_list|)
operator|)
operator|!=
name|SEG_ABSOLUTE
condition|)
block|{
if|if
condition|(
name|s
operator|!=
name|SEG_NONE
condition|)
block|{
name|as_warn
argument_list|(
literal|"Bad Absolute Expression, absolute 0 assumed."
argument_list|)
expr_stmt|;
block|}
name|exp
operator|.
name|X_add_number
operator|=
literal|0
expr_stmt|;
block|}
return|return
operator|(
name|exp
operator|.
name|X_add_number
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|char
comment|/* return terminator */
name|get_absolute_expression_and_terminator
parameter_list|(
name|val_pointer
parameter_list|)
name|long
name|int
modifier|*
name|val_pointer
decl_stmt|;
comment|/* return value of expression */
block|{
operator|*
name|val_pointer
operator|=
name|get_absolute_expression
argument_list|()
expr_stmt|;
return|return
operator|(
operator|*
name|input_line_pointer
operator|++
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *			demand_copy_C_string()  *  * Like demand_copy_string, but return NULL if the string contains any '\0's.  * Give a warning if that happens.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|demand_copy_C_string
parameter_list|(
name|len_pointer
parameter_list|)
name|int
modifier|*
name|len_pointer
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
if|if
condition|(
name|s
operator|=
name|demand_copy_string
argument_list|(
name|len_pointer
argument_list|)
condition|)
block|{
specifier|register
name|int
name|len
decl_stmt|;
for|for
control|(
name|len
operator|=
operator|*
name|len_pointer
init|;
name|len
operator|>
literal|0
condition|;
name|len
operator|--
control|)
block|{
if|if
condition|(
operator|*
name|s
operator|==
literal|0
condition|)
block|{
name|s
operator|=
literal|0
expr_stmt|;
name|len
operator|=
literal|1
expr_stmt|;
operator|*
name|len_pointer
operator|=
literal|0
expr_stmt|;
name|as_warn
argument_list|(
literal|"This string may not contain \'\\0\'"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
operator|(
name|s
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *			demand_copy_string()  *  * Demand string, but return a safe (=private) copy of the string.  * Return NULL if we can't read a string here.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|demand_copy_string
parameter_list|(
name|lenP
parameter_list|)
name|int
modifier|*
name|lenP
decl_stmt|;
block|{
specifier|register
name|int
name|c
decl_stmt|;
specifier|register
name|int
name|len
decl_stmt|;
name|char
modifier|*
name|retval
decl_stmt|;
name|len
operator|=
literal|0
expr_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|==
literal|'\"'
condition|)
block|{
name|input_line_pointer
operator|++
expr_stmt|;
comment|/* Skip opening quote. */
while|while
condition|(
operator|(
name|c
operator|=
name|next_char_of_string
argument_list|()
operator|)
operator|>=
literal|0
condition|)
block|{
name|obstack_1grow
argument_list|(
operator|&
name|notes
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|len
operator|++
expr_stmt|;
block|}
comment|/* JF this next line is so demand_copy_C_string will return a null          termanated string. */
name|obstack_1grow
argument_list|(
operator|&
name|notes
argument_list|,
literal|'\0'
argument_list|)
expr_stmt|;
name|retval
operator|=
name|obstack_finish
argument_list|(
operator|&
name|notes
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|as_warn
argument_list|(
literal|"Missing string"
argument_list|)
expr_stmt|;
name|retval
operator|=
name|NULL
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
block|}
operator|*
name|lenP
operator|=
name|len
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *		is_it_end_of_statement()  *  * In:	Input_line_pointer -> next character.  *  * Do:	Skip input_line_pointer over all whitespace.  *  * Out:	TRUE if input_line_pointer -> end-of-line.  */
end_comment

begin_function
specifier|static
name|int
name|is_it_end_of_statement
parameter_list|()
block|{
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
return|return
operator|(
name|is_end_of_line
index|[
operator|*
name|input_line_pointer
index|]
operator|)
return|;
block|}
end_function

begin_function
name|void
name|equals
parameter_list|(
name|sym_name
parameter_list|)
name|char
modifier|*
name|sym_name
decl_stmt|;
block|{
specifier|register
name|struct
name|symbol
modifier|*
name|symbolP
decl_stmt|;
comment|/* symbol we are working with */
name|input_line_pointer
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|==
literal|'='
condition|)
name|input_line_pointer
operator|++
expr_stmt|;
while|while
condition|(
operator|*
name|input_line_pointer
operator|==
literal|' '
operator|||
operator|*
name|input_line_pointer
operator|==
literal|'\t'
condition|)
name|input_line_pointer
operator|++
expr_stmt|;
if|if
condition|(
name|sym_name
index|[
literal|0
index|]
operator|==
literal|'.'
operator|&&
name|sym_name
index|[
literal|1
index|]
operator|==
literal|'\0'
condition|)
block|{
comment|/* Turn '. = mumble' into a .org mumble */
specifier|register
name|segT
name|segment
decl_stmt|;
name|expressionS
name|exp
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|segment
operator|=
name|get_known_segmented_expression
argument_list|(
operator|&
name|exp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|need_pass_2
condition|)
block|{
if|if
condition|(
name|segment
operator|!=
name|now_seg
operator|&&
name|segment
operator|!=
name|SEG_ABSOLUTE
condition|)
name|as_warn
argument_list|(
literal|"Illegal segment \"%s\". Segment \"%s\" assumed."
argument_list|,
name|seg_name
index|[
operator|(
name|int
operator|)
name|segment
index|]
argument_list|,
name|seg_name
index|[
operator|(
name|int
operator|)
name|now_seg
index|]
argument_list|)
expr_stmt|;
name|p
operator|=
name|frag_var
argument_list|(
name|rs_org
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
operator|(
name|relax_substateT
operator|)
literal|0
argument_list|,
name|exp
operator|.
name|X_add_symbol
argument_list|,
name|exp
operator|.
name|X_add_number
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
operator|*
name|p
operator|=
literal|0
expr_stmt|;
block|}
comment|/* if (ok to make frag) */
block|}
else|else
block|{
name|symbolP
operator|=
name|symbol_find_or_make
argument_list|(
name|sym_name
argument_list|)
expr_stmt|;
name|pseudo_set
argument_list|(
name|symbolP
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* end: read.c */
end_comment

end_unit

