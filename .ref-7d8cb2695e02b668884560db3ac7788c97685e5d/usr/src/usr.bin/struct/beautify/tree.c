begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * %sccs.include.proprietary.c%  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)tree.c	5.1 (Berkeley) %G%"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_include
include|#
directive|include
file|"y.tab.h"
end_include

begin_include
include|#
directive|include
file|"b.h"
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_function
name|struct
name|node
modifier|*
name|addroot
parameter_list|(
name|string
parameter_list|,
name|type
parameter_list|,
name|n1
parameter_list|,
name|n2
parameter_list|)
name|char
modifier|*
name|string
decl_stmt|;
name|int
name|type
decl_stmt|;
name|struct
name|node
modifier|*
name|n1
decl_stmt|,
decl|*
name|n2
decl_stmt|;
end_function

begin_block
block|{
name|struct
name|node
modifier|*
name|p
decl_stmt|;
name|p
operator|=
operator|(
expr|struct
name|node
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|p
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|->
name|left
operator|=
name|n1
expr_stmt|;
name|p
operator|->
name|right
operator|=
name|n2
expr_stmt|;
name|p
operator|->
name|op
operator|=
name|type
expr_stmt|;
name|p
operator|->
name|lit
operator|=
name|malloc
argument_list|(
name|slength
argument_list|(
name|string
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|str_copy
argument_list|(
name|string
argument_list|,
name|p
operator|->
name|lit
argument_list|,
name|slength
argument_list|(
name|string
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
block|}
end_block

begin_macro
name|freetree
argument_list|(
argument|tree
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|node
modifier|*
name|tree
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|tree
condition|)
block|{
name|freetree
argument_list|(
name|tree
operator|->
name|left
argument_list|)
expr_stmt|;
name|freetree
argument_list|(
name|tree
operator|->
name|right
argument_list|)
expr_stmt|;
name|freenode
argument_list|(
name|tree
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|freenode
argument_list|(
argument|treenode
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|node
modifier|*
name|treenode
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|free
argument_list|(
name|treenode
operator|->
name|lit
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|treenode
argument_list|)
expr_stmt|;
block|}
end_block

begin_decl_stmt
name|int
name|compop
index|[]
init|=
block|{
literal|'&'
block|,
literal|'|'
block|,
literal|'<'
block|,
literal|'>'
block|,
name|xxeq
block|,
name|xxle
block|,
name|xxne
block|,
name|xxge
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|notop
index|[]
init|=
block|{
literal|'|'
block|,
literal|'&'
block|,
name|xxge
block|,
name|xxle
block|,
name|xxne
block|,
literal|'>'
block|,
name|xxeq
block|,
literal|'<'
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|opstring
index|[]
init|=
block|{
literal|"||"
block|,
literal|"&&"
block|,
literal|">="
block|,
literal|"<="
block|,
literal|"!="
block|,
literal|">"
block|,
literal|"=="
block|,
literal|"<"
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|struct
name|node
modifier|*
name|checkneg
parameter_list|(
name|tree
parameter_list|,
name|neg
parameter_list|)
comment|/* eliminate nots if possible */
name|struct
name|node
modifier|*
name|tree
decl_stmt|;
name|int
name|neg
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|struct
name|node
modifier|*
name|t
decl_stmt|;
if|if
condition|(
operator|!
name|tree
condition|)
return|return
operator|(
literal|0
operator|)
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|tree
operator|->
name|op
operator|==
name|compop
index|[
name|i
index|]
condition|)
break|break;
if|if
condition|(
name|i
operator|>
literal|1
operator|&&
name|i
operator|<
literal|8
operator|&&
name|tree
operator|->
name|left
operator|->
name|op
operator|==
literal|'-'
operator|&&
name|str_eq
argument_list|(
name|tree
operator|->
name|right
operator|->
name|lit
argument_list|,
literal|"0"
argument_list|)
condition|)
block|{
name|t
operator|=
name|tree
operator|->
name|right
expr_stmt|;
name|tree
operator|->
name|right
operator|=
name|tree
operator|->
name|left
operator|->
name|right
expr_stmt|;
name|freenode
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|t
operator|=
name|tree
operator|->
name|left
expr_stmt|;
name|tree
operator|->
name|left
operator|=
name|tree
operator|->
name|left
operator|->
name|left
expr_stmt|;
name|freenode
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|neg
condition|)
block|{
if|if
condition|(
name|tree
operator|->
name|op
operator|==
literal|'!'
condition|)
block|{
name|t
operator|=
name|tree
operator|->
name|left
expr_stmt|;
name|freenode
argument_list|(
name|tree
argument_list|)
expr_stmt|;
return|return
operator|(
name|checkneg
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
operator|)
return|;
block|}
if|if
condition|(
name|i
operator|<
literal|8
condition|)
block|{
name|tree
operator|->
name|op
operator|=
name|notop
index|[
name|i
index|]
expr_stmt|;
name|free
argument_list|(
name|tree
operator|->
name|lit
argument_list|)
expr_stmt|;
name|tree
operator|->
name|lit
operator|=
name|malloc
argument_list|(
name|slength
argument_list|(
name|opstring
index|[
name|i
index|]
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|str_copy
argument_list|(
name|opstring
index|[
name|i
index|]
argument_list|,
name|tree
operator|->
name|lit
argument_list|,
name|slength
argument_list|(
name|opstring
index|[
name|i
index|]
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|tree
operator|->
name|op
operator|==
literal|'&'
operator|||
name|tree
operator|->
name|op
operator|==
literal|'|'
condition|)
block|{
name|tree
operator|->
name|left
operator|=
name|checkneg
argument_list|(
name|tree
operator|->
name|left
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|tree
operator|->
name|right
operator|=
name|checkneg
argument_list|(
name|tree
operator|->
name|right
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|tree
operator|)
return|;
block|}
if|if
condition|(
name|tree
operator|->
name|op
operator|==
name|xxident
operator|&&
name|str_eq
argument_list|(
name|tree
operator|->
name|lit
argument_list|,
literal|".false."
argument_list|)
condition|)
name|str_copy
argument_list|(
literal|".true."
argument_list|,
name|tree
operator|->
name|lit
argument_list|,
name|slength
argument_list|(
literal|".true."
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|tree
operator|->
name|op
operator|==
name|xxident
operator|&&
name|str_eq
argument_list|(
name|tree
operator|->
name|lit
argument_list|,
literal|".true."
argument_list|)
condition|)
block|{
name|free
argument_list|(
name|tree
operator|->
name|lit
argument_list|)
expr_stmt|;
name|tree
operator|->
name|lit
operator|=
name|malloc
argument_list|(
name|slength
argument_list|(
literal|".false."
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|str_copy
argument_list|(
literal|".false."
argument_list|,
name|tree
operator|->
name|lit
argument_list|,
name|slength
argument_list|(
literal|".false."
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tree
operator|=
name|addroot
argument_list|(
literal|"!"
argument_list|,
literal|'!'
argument_list|,
name|tree
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tree
operator|->
name|lit
operator|=
name|malloc
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|str_copy
argument_list|(
literal|"!"
argument_list|,
name|tree
operator|->
name|lit
argument_list|,
name|slength
argument_list|(
literal|"!"
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|tree
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|tree
operator|->
name|op
operator|==
literal|'!'
condition|)
block|{
name|t
operator|=
name|tree
expr_stmt|;
name|tree
operator|=
name|tree
operator|->
name|left
expr_stmt|;
name|freenode
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|checkneg
argument_list|(
name|tree
argument_list|,
literal|1
argument_list|)
operator|)
return|;
block|}
else|else
block|{
name|tree
operator|->
name|left
operator|=
name|checkneg
argument_list|(
name|tree
operator|->
name|left
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tree
operator|->
name|right
operator|=
name|checkneg
argument_list|(
name|tree
operator|->
name|right
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|tree
operator|)
return|;
block|}
block|}
end_function

begin_macro
name|yield
argument_list|(
argument|tree
argument_list|,
argument|fprec
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|node
modifier|*
name|tree
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|fprec
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* fprec is precedence of father of this node */
end_comment

begin_block
block|{
name|int
name|paren
decl_stmt|,
name|p
decl_stmt|;
specifier|static
name|int
name|oplast
decl_stmt|;
comment|/* oplast = 1 iff last char printed was operator */
if|if
condition|(
operator|!
name|tree
condition|)
return|return;
name|p
operator|=
name|prec
argument_list|(
name|tree
operator|->
name|op
argument_list|)
expr_stmt|;
name|paren
operator|=
operator|(
name|p
operator|<
name|fprec
operator|||
operator|(
name|oplast
operator|&&
name|tree
operator|->
name|op
operator|==
name|xxuminus
operator|)
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
if|if
condition|(
name|paren
condition|)
block|{
name|putout
argument_list|(
literal|'('
argument_list|,
literal|"("
argument_list|)
expr_stmt|;
name|oplast
operator|=
literal|0
expr_stmt|;
block|}
switch|switch
condition|(
name|tree
operator|->
name|op
condition|)
block|{
case|case
name|xxuminus
case|:
name|tree
operator|->
name|op
operator|=
literal|'-'
expr_stmt|;
case|case
literal|'!'
case|:
name|putout
argument_list|(
name|tree
operator|->
name|op
argument_list|,
name|tree
operator|->
name|lit
argument_list|)
expr_stmt|;
name|oplast
operator|=
literal|1
expr_stmt|;
name|yield
argument_list|(
name|tree
operator|->
name|left
argument_list|,
name|p
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'&'
case|:
case|case
literal|'|'
case|:
case|case
literal|'<'
case|:
case|case
literal|'>'
case|:
case|case
name|xxeq
case|:
case|case
name|xxle
case|:
case|case
name|xxge
case|:
case|case
literal|'+'
case|:
case|case
literal|'-'
case|:
case|case
literal|'*'
case|:
case|case
literal|'/'
case|:
case|case
literal|'^'
case|:
name|yield
argument_list|(
name|tree
operator|->
name|left
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|putout
argument_list|(
name|tree
operator|->
name|op
argument_list|,
name|tree
operator|->
name|lit
argument_list|)
expr_stmt|;
name|oplast
operator|=
literal|1
expr_stmt|;
name|yield
argument_list|(
name|tree
operator|->
name|right
argument_list|,
name|p
argument_list|)
expr_stmt|;
break|break;
case|case
name|xxidpar
case|:
name|yield
argument_list|(
name|tree
operator|->
name|left
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|putout
argument_list|(
literal|'('
argument_list|,
literal|"("
argument_list|)
expr_stmt|;
name|oplast
operator|=
literal|0
expr_stmt|;
name|yield
argument_list|(
name|tree
operator|->
name|right
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|putout
argument_list|(
literal|'('
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
name|oplast
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
name|yield
argument_list|(
name|tree
operator|->
name|left
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|putout
argument_list|(
name|tree
operator|->
name|op
argument_list|,
name|tree
operator|->
name|lit
argument_list|)
expr_stmt|;
name|oplast
operator|=
literal|0
expr_stmt|;
name|yield
argument_list|(
name|tree
operator|->
name|right
argument_list|,
name|p
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|paren
condition|)
block|{
name|putout
argument_list|(
literal|')'
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
name|oplast
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|puttree
argument_list|(
argument|tree
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|node
modifier|*
name|tree
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|yield
argument_list|(
name|tree
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|freetree
argument_list|(
name|tree
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|prec
argument_list|(
argument|oper
argument_list|)
end_macro

begin_decl_stmt
name|int
name|oper
decl_stmt|;
end_decl_stmt

begin_block
block|{
switch|switch
condition|(
name|oper
condition|)
block|{
case|case
literal|','
case|:
return|return
operator|(
literal|0
operator|)
return|;
case|case
literal|'|'
case|:
return|return
operator|(
literal|1
operator|)
return|;
case|case
literal|'&'
case|:
return|return
operator|(
literal|2
operator|)
return|;
case|case
literal|'!'
case|:
return|return
operator|(
literal|3
operator|)
return|;
case|case
literal|'<'
case|:
case|case
literal|'>'
case|:
case|case
name|xxeq
case|:
case|case
name|xxne
case|:
case|case
name|xxle
case|:
case|case
name|xxge
case|:
return|return
operator|(
literal|4
operator|)
return|;
case|case
literal|'+'
case|:
case|case
literal|'-'
case|:
return|return
operator|(
literal|5
operator|)
return|;
case|case
literal|'*'
case|:
case|case
literal|'/'
case|:
return|return
operator|(
literal|6
operator|)
return|;
case|case
name|xxuminus
case|:
return|return
operator|(
literal|7
operator|)
return|;
case|case
literal|'^'
case|:
return|return
operator|(
literal|8
operator|)
return|;
default|default:
return|return
operator|(
literal|9
operator|)
return|;
block|}
block|}
end_block

begin_macro
name|str_copy
argument_list|(
argument|s
argument_list|,
argument|ptr
argument_list|,
argument|length
argument_list|)
end_macro

begin_comment
comment|/* copy s at ptr, return length of s */
end_comment

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|,
modifier|*
name|ptr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|length
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|length
condition|;
name|i
operator|++
control|)
block|{
name|ptr
index|[
name|i
index|]
operator|=
name|s
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|ptr
index|[
name|i
index|]
operator|==
literal|'\0'
condition|)
return|return
operator|(
name|i
operator|+
literal|1
operator|)
return|;
block|}
name|fprintf
argument_list|(
literal|2
argument_list|,
literal|"string %s too long to be copied by str_copy at address %d\n"
argument_list|,
operator|*
name|s
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|str_eq
argument_list|(
argument|s
argument_list|,
argument|t
argument_list|)
end_macro

begin_decl_stmt
name|char
name|s
index|[]
decl_stmt|,
name|t
index|[]
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|s
index|[
name|j
index|]
operator|==
name|t
index|[
name|j
index|]
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|s
index|[
name|j
index|]
operator|==
literal|'\0'
condition|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_macro
name|slength
argument_list|(
argument|s
argument_list|)
end_macro

begin_comment
comment|/* return number of chars in s, not counting '\0' */
end_comment

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|s
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|s
index|[
name|i
index|]
operator|!=
literal|'\0'
condition|;
name|i
operator|++
control|)
empty_stmt|;
return|return
operator|(
name|i
operator|)
return|;
block|}
end_block

end_unit

