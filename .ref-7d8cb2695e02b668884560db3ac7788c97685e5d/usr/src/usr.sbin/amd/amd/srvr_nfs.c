begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1990 Jan-Simon Pendry  * Copyright (c) 1990 Imperial College of Science, Technology& Medicine  * Copyright (c) 1990 The Regents of the University of California.  * All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * Jan-Simon Pendry at Imperial College, London.  *  * %sccs.include.redist.c%  *  *	@(#)srvr_nfs.c	5.4 (Berkeley) %G%  *  * $Id: srvr_nfs.c,v 5.2.2.1 1992/02/09 15:09:06 jsp beta $  *  */
end_comment

begin_comment
comment|/*  * NFS server modeling  */
end_comment

begin_include
include|#
directive|include
file|"am.h"
end_include

begin_include
include|#
directive|include
file|<netdb.h>
end_include

begin_include
include|#
directive|include
file|<rpc/pmap_prot.h>
end_include

begin_include
include|#
directive|include
file|"mount.h"
end_include

begin_decl_stmt
specifier|extern
name|qelem
name|nfs_srvr_list
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|qelem
name|nfs_srvr_list
init|=
block|{
operator|&
name|nfs_srvr_list
block|,
operator|&
name|nfs_srvr_list
block|}
decl_stmt|;
end_decl_stmt

begin_typedef
typedef|typedef
struct|struct
name|nfs_private
block|{
name|u_short
name|np_mountd
decl_stmt|;
comment|/* Mount daemon port number */
name|char
name|np_mountd_inval
decl_stmt|;
comment|/* Port *may* be invalid */
name|int
name|np_ping
decl_stmt|;
comment|/* Number of failed ping attempts */
name|time_t
name|np_ttl
decl_stmt|;
comment|/* Time when server is thought dead */
name|int
name|np_xid
decl_stmt|;
comment|/* RPC transaction id for pings */
name|int
name|np_error
decl_stmt|;
comment|/* Error during portmap request */
block|}
name|nfs_private
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|int
name|np_xid
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* For NFS pings */
end_comment

begin_define
define|#
directive|define
name|NPXID_ALLOC
parameter_list|()
value|(++np_xid)
end_define

begin_comment
comment|/*#define	NPXID_ALLOC()	((++np_xid&0x0fffffff) == 0 ? npxid_gc() : np_xid)*/
end_comment

begin_comment
comment|/*  * Number of pings allowed to fail before host is declared down  * - three-fifths of the allowed mount time... #define	MAX_ALLOWED_PINGS	((((ALLOWED_MOUNT_TIME + 5 * AM_PINGER - 1) * 3) / 5) / AM_PINGER)  */
end_comment

begin_define
define|#
directive|define
name|MAX_ALLOWED_PINGS
value|(3 +
comment|/* for luck ... */
value|1)
end_define

begin_comment
comment|/*  * How often to ping when starting a new server  */
end_comment

begin_define
define|#
directive|define
name|FAST_NFS_PING
value|3
end_define

begin_if
if|#
directive|if
operator|(
name|FAST_NFS_PING
operator|*
name|MAX_ALLOWED_PINGS
operator|)
operator|>=
name|ALLOWED_MOUNT_TIME
end_if

begin_error
error|#
directive|error
error|: sanity check failed
end_error

begin_comment
comment|/*  you cannot do things this way...  sufficient fast pings must be given the chance to fail  within the allowed mount time  */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* (FAST_NFS_PING * MAX_ALLOWED_PINGS)>= ALLOWED_MOUNT_TIME */
end_comment

begin_decl_stmt
specifier|static
name|int
name|ping_len
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|ping_buf
index|[
sizeof|sizeof
argument_list|(
expr|struct
name|rpc_msg
argument_list|)
operator|+
literal|32
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Flush any cached data  */
end_comment

begin_decl_stmt
name|void
name|flush_srvr_nfs_cache
name|P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|flush_srvr_nfs_cache
parameter_list|()
block|{
name|fserver
modifier|*
name|fs
init|=
literal|0
decl_stmt|;
name|ITER
argument_list|(
argument|fs
argument_list|,
argument|fserver
argument_list|,
argument|&nfs_srvr_list
argument_list|)
block|{
name|nfs_private
modifier|*
name|np
init|=
operator|(
name|nfs_private
operator|*
operator|)
name|fs
operator|->
name|fs_private
decl_stmt|;
if|if
condition|(
name|np
condition|)
block|{
name|np
operator|->
name|np_mountd_inval
operator|=
name|TRUE
expr_stmt|;
name|np
operator|->
name|np_error
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Startup the NFS ping  */
end_comment

begin_function_decl
specifier|static
name|void
name|start_ping
parameter_list|(
name|P_void
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|void
name|start_ping
parameter_list|()
block|{
name|XDR
name|ping_xdr
decl_stmt|;
name|struct
name|rpc_msg
name|ping_msg
decl_stmt|;
name|rpc_msg_init
argument_list|(
operator|&
name|ping_msg
argument_list|,
name|NFS_PROGRAM
argument_list|,
name|NFS_VERSION
argument_list|,
name|NFSPROC_NULL
argument_list|)
expr_stmt|;
comment|/* 	 * Create an XDR endpoint 	 */
name|xdrmem_create
argument_list|(
operator|&
name|ping_xdr
argument_list|,
name|ping_buf
argument_list|,
sizeof|sizeof
argument_list|(
name|ping_buf
argument_list|)
argument_list|,
name|XDR_ENCODE
argument_list|)
expr_stmt|;
comment|/* 	 * Create the NFS ping message 	 */
if|if
condition|(
operator|!
name|xdr_callmsg
argument_list|(
operator|&
name|ping_xdr
argument_list|,
operator|&
name|ping_msg
argument_list|)
condition|)
block|{
name|plog
argument_list|(
name|XLOG_ERROR
argument_list|,
literal|"Couldn't create ping RPC message"
argument_list|)
expr_stmt|;
name|going_down
argument_list|(
literal|3
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Find out how long it is 	 */
name|ping_len
operator|=
name|xdr_getpos
argument_list|(
operator|&
name|ping_xdr
argument_list|)
expr_stmt|;
comment|/* 	 * Destroy the XDR endpoint - we don't need it anymore 	 */
name|xdr_destroy
argument_list|(
operator|&
name|ping_xdr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Called when a portmap reply arrives  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_decl_stmt
specifier|static
name|void
name|got_portmap
name|P
argument_list|(
operator|(
name|voidp
name|pkt
operator|,
name|int
name|len
operator|,
expr|struct
name|sockaddr_in
operator|*
name|sa
operator|,
expr|struct
name|sockaddr_in
operator|*
name|ia
operator|,
name|voidp
name|idv
operator|,
name|int
name|done
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|got_portmap
parameter_list|(
name|pkt
parameter_list|,
name|len
parameter_list|,
name|sa
parameter_list|,
name|ia
parameter_list|,
name|idv
parameter_list|,
name|done
parameter_list|)
name|voidp
name|pkt
decl_stmt|;
name|int
name|len
decl_stmt|;
name|struct
name|sockaddr_in
modifier|*
name|sa
decl_stmt|;
name|struct
name|sockaddr_in
modifier|*
name|ia
decl_stmt|;
name|voidp
name|idv
decl_stmt|;
name|int
name|done
decl_stmt|;
block|{
name|fserver
modifier|*
name|fs2
init|=
operator|(
name|fserver
operator|*
operator|)
name|idv
decl_stmt|;
name|fserver
modifier|*
name|fs
init|=
literal|0
decl_stmt|;
comment|/* 	 * Find which fileserver we are talking about 	 */
name|ITER
argument_list|(
argument|fs
argument_list|,
argument|fserver
argument_list|,
argument|&nfs_srvr_list
argument_list|)
if|if
condition|(
name|fs
operator|==
name|fs2
condition|)
break|break;
if|if
condition|(
name|fs
operator|==
name|fs2
condition|)
block|{
name|u_long
name|port
init|=
literal|0
decl_stmt|;
comment|/* XXX - should be short but protocol is naff */
name|int
name|error
init|=
name|done
condition|?
name|pickup_rpc_reply
argument_list|(
name|pkt
argument_list|,
name|len
argument_list|,
operator|(
name|voidp
operator|)
operator|&
name|port
argument_list|,
name|xdr_u_long
argument_list|)
else|:
operator|-
literal|1
decl_stmt|;
name|nfs_private
modifier|*
name|np
init|=
operator|(
name|nfs_private
operator|*
operator|)
name|fs
operator|->
name|fs_private
decl_stmt|;
if|if
condition|(
operator|!
name|error
operator|&&
name|port
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|dlog
argument_list|(
literal|"got port (%d) for mountd on %s"
argument_list|,
name|port
argument_list|,
name|fs
operator|->
name|fs_host
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
comment|/* 			 * Grab the port number.  Portmap sends back 			 * an unsigned long in native ordering, so it 			 * needs converting to a unsigned short in 			 * network ordering. 			 */
name|np
operator|->
name|np_mountd
operator|=
name|htons
argument_list|(
operator|(
name|u_short
operator|)
name|port
argument_list|)
expr_stmt|;
name|np
operator|->
name|np_mountd_inval
operator|=
name|FALSE
expr_stmt|;
name|np
operator|->
name|np_error
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|dlog
argument_list|(
literal|"Error fetching port for mountd on %s"
argument_list|,
name|fs
operator|->
name|fs_host
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
comment|/* 			 * Almost certainly no mountd running on remote host 			 */
name|np
operator|->
name|np_error
operator|=
name|error
condition|?
name|error
else|:
name|ETIMEDOUT
expr_stmt|;
block|}
if|if
condition|(
name|fs
operator|->
name|fs_flags
operator|&
name|FSF_WANT
condition|)
name|wakeup_srvr
argument_list|(
name|fs
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|done
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|dlog
argument_list|(
literal|"Got portmap for old port request"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|dlog
argument_list|(
literal|"portmap request timed out"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
block|}
block|}
end_function

begin_comment
comment|/*  * Obtain portmap information  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|call_portmap
name|P
argument_list|(
operator|(
name|fserver
operator|*
name|fs
operator|,
name|AUTH
operator|*
name|auth
operator|,
name|unsigned
name|long
name|prog
operator|,
name|unsigned
name|long
name|vers
operator|,
name|unsigned
name|long
name|prot
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|call_portmap
parameter_list|(
name|fs
parameter_list|,
name|auth
parameter_list|,
name|prog
parameter_list|,
name|vers
parameter_list|,
name|prot
parameter_list|)
name|fserver
modifier|*
name|fs
decl_stmt|;
name|AUTH
modifier|*
name|auth
decl_stmt|;
name|unsigned
name|long
name|prog
decl_stmt|,
name|vers
decl_stmt|,
name|prot
decl_stmt|;
block|{
name|struct
name|rpc_msg
name|pmap_msg
decl_stmt|;
name|int
name|len
decl_stmt|;
name|char
name|iobuf
index|[
name|UDPMSGSIZE
index|]
decl_stmt|;
name|int
name|error
decl_stmt|;
name|struct
name|pmap
name|pmap
decl_stmt|;
name|rpc_msg_init
argument_list|(
operator|&
name|pmap_msg
argument_list|,
name|PMAPPROG
argument_list|,
name|PMAPVERS
argument_list|,
operator|(
name|unsigned
name|long
operator|)
literal|0
argument_list|)
expr_stmt|;
name|pmap
operator|.
name|pm_prog
operator|=
name|prog
expr_stmt|;
name|pmap
operator|.
name|pm_vers
operator|=
name|vers
expr_stmt|;
name|pmap
operator|.
name|pm_prot
operator|=
name|prot
expr_stmt|;
name|pmap
operator|.
name|pm_port
operator|=
literal|0
expr_stmt|;
name|len
operator|=
name|make_rpc_packet
argument_list|(
name|iobuf
argument_list|,
sizeof|sizeof
argument_list|(
name|iobuf
argument_list|)
argument_list|,
name|PMAPPROC_GETPORT
argument_list|,
operator|&
name|pmap_msg
argument_list|,
operator|(
name|voidp
operator|)
operator|&
name|pmap
argument_list|,
name|xdr_pmap
argument_list|,
name|auth
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>
literal|0
condition|)
block|{
name|struct
name|sockaddr_in
name|sin
decl_stmt|;
name|bzero
argument_list|(
operator|(
name|voidp
operator|)
operator|&
name|sin
argument_list|,
sizeof|sizeof
argument_list|(
name|sin
argument_list|)
argument_list|)
expr_stmt|;
name|sin
operator|=
operator|*
name|fs
operator|->
name|fs_ip
expr_stmt|;
name|sin
operator|.
name|sin_port
operator|=
name|htons
argument_list|(
name|PMAPPORT
argument_list|)
expr_stmt|;
name|error
operator|=
name|fwd_packet
argument_list|(
name|RPC_XID_PORTMAP
argument_list|,
operator|(
name|voidp
operator|)
name|iobuf
argument_list|,
name|len
argument_list|,
operator|&
name|sin
argument_list|,
operator|&
name|sin
argument_list|,
operator|(
name|voidp
operator|)
name|fs
argument_list|,
name|got_portmap
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
operator|-
name|len
expr_stmt|;
block|}
return|return
name|error
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|void
name|nfs_keepalive
name|P
argument_list|(
operator|(
name|fserver
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|recompute_portmap
name|P
argument_list|(
operator|(
name|fserver
operator|*
name|fs
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|recompute_portmap
parameter_list|(
name|fs
parameter_list|)
name|fserver
modifier|*
name|fs
decl_stmt|;
block|{
name|int
name|error
decl_stmt|;
if|if
condition|(
name|nfs_auth
condition|)
name|error
operator|=
literal|0
expr_stmt|;
else|else
name|error
operator|=
name|make_nfs_auth
argument_list|()
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|nfs_private
modifier|*
name|np
init|=
operator|(
name|nfs_private
operator|*
operator|)
name|fs
operator|->
name|fs_private
decl_stmt|;
name|np
operator|->
name|np_error
operator|=
name|error
expr_stmt|;
block|}
else|else
block|{
name|call_portmap
argument_list|(
name|fs
argument_list|,
name|nfs_auth
argument_list|,
name|MOUNTPROG
argument_list|,
name|MOUNTVERS
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|IPPROTO_UDP
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * This is called when we get a reply to an RPC ping.  * The value of id was taken from the nfs_private  * structure when the ping was transmitted.  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_decl_stmt
specifier|static
name|void
name|nfs_pinged
name|P
argument_list|(
operator|(
name|voidp
name|pkt
operator|,
name|int
name|len
operator|,
expr|struct
name|sockaddr_in
operator|*
name|sp
operator|,
expr|struct
name|sockaddr_in
operator|*
name|tsp
operator|,
name|voidp
name|idv
operator|,
name|int
name|done
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|nfs_pinged
parameter_list|(
name|pkt
parameter_list|,
name|len
parameter_list|,
name|sp
parameter_list|,
name|tsp
parameter_list|,
name|idv
parameter_list|,
name|done
parameter_list|)
name|voidp
name|pkt
decl_stmt|;
name|int
name|len
decl_stmt|;
name|struct
name|sockaddr_in
modifier|*
name|sp
decl_stmt|;
name|struct
name|sockaddr_in
modifier|*
name|tsp
decl_stmt|;
name|voidp
name|idv
decl_stmt|;
name|int
name|done
decl_stmt|;
block|{
name|int
name|xid
init|=
operator|(
name|int
operator|)
name|idv
decl_stmt|;
name|fserver
modifier|*
name|fs
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|int
name|found_map
init|=
literal|0
decl_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
if|if
condition|(
operator|!
name|done
condition|)
return|return;
comment|/* 	 * For each node... 	 */
name|ITER
argument_list|(
argument|fs
argument_list|,
argument|fserver
argument_list|,
argument|&nfs_srvr_list
argument_list|)
block|{
name|nfs_private
modifier|*
name|np
init|=
operator|(
name|nfs_private
operator|*
operator|)
name|fs
operator|->
name|fs_private
decl_stmt|;
if|if
condition|(
name|np
operator|->
name|np_xid
operator|==
name|xid
condition|)
block|{
comment|/* 			 * Reset the ping counter. 			 * Update the keepalive timer. 			 * Log what happened. 			 */
if|if
condition|(
name|fs
operator|->
name|fs_flags
operator|&
name|FSF_DOWN
condition|)
block|{
name|fs
operator|->
name|fs_flags
operator|&=
operator|~
name|FSF_DOWN
expr_stmt|;
if|if
condition|(
name|fs
operator|->
name|fs_flags
operator|&
name|FSF_VALID
condition|)
block|{
name|srvrlog
argument_list|(
name|fs
argument_list|,
literal|"is up"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|np
operator|->
name|np_ping
operator|>
literal|1
condition|)
name|srvrlog
argument_list|(
name|fs
argument_list|,
literal|"ok"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
else|else
name|srvrlog
argument_list|(
name|fs
argument_list|,
literal|"starts up"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|fs
operator|->
name|fs_flags
operator||=
name|FSF_VALID
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|notdef
comment|/* why ??? */
if|if
condition|(
name|fs
operator|->
name|fs_flags
operator|&
name|FSF_WANT
condition|)
name|wakeup_srvr
argument_list|(
name|fs
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* notdef */
name|map_flush_srvr
argument_list|(
name|fs
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|fs
operator|->
name|fs_flags
operator|&
name|FSF_VALID
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|dlog
argument_list|(
literal|"file server %s type nfs is still up"
argument_list|,
name|fs
operator|->
name|fs_host
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
block|}
else|else
block|{
if|if
condition|(
name|np
operator|->
name|np_ping
operator|>
literal|1
condition|)
name|srvrlog
argument_list|(
name|fs
argument_list|,
literal|"ok"
argument_list|)
expr_stmt|;
name|fs
operator|->
name|fs_flags
operator||=
name|FSF_VALID
expr_stmt|;
block|}
block|}
comment|/* 			 * Adjust ping interval 			 */
name|untimeout
argument_list|(
name|fs
operator|->
name|fs_cid
argument_list|)
expr_stmt|;
name|fs
operator|->
name|fs_cid
operator|=
name|timeout
argument_list|(
name|fs
operator|->
name|fs_pinger
argument_list|,
name|nfs_keepalive
argument_list|,
operator|(
name|voidp
operator|)
name|fs
argument_list|)
expr_stmt|;
comment|/* 			 * Update ttl for this server 			 */
name|np
operator|->
name|np_ttl
operator|=
name|clocktime
argument_list|()
operator|+
operator|(
name|MAX_ALLOWED_PINGS
operator|-
literal|1
operator|)
operator|*
name|FAST_NFS_PING
operator|+
name|fs
operator|->
name|fs_pinger
operator|-
literal|1
expr_stmt|;
comment|/* 			 * New RPC xid... 			 */
name|np
operator|->
name|np_xid
operator|=
name|NPXID_ALLOC
argument_list|()
expr_stmt|;
comment|/* 			 * Failed pings is zero... 			 */
name|np
operator|->
name|np_ping
operator|=
literal|0
expr_stmt|;
comment|/* 			 * Recompute portmap information if not known 			 */
if|if
condition|(
name|np
operator|->
name|np_mountd_inval
condition|)
name|recompute_portmap
argument_list|(
name|fs
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|found_map
operator|++
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
break|break;
block|}
block|}
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|found_map
operator|==
literal|0
condition|)
name|dlog
argument_list|(
literal|"Spurious ping packet"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
block|}
end_function

begin_comment
comment|/*  * Called when no ping-reply received  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|nfs_timed_out
name|P
argument_list|(
operator|(
name|fserver
operator|*
name|fs
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|nfs_timed_out
parameter_list|(
name|fs
parameter_list|)
name|fserver
modifier|*
name|fs
decl_stmt|;
block|{
name|nfs_private
modifier|*
name|np
init|=
operator|(
name|nfs_private
operator|*
operator|)
name|fs
operator|->
name|fs_private
decl_stmt|;
comment|/* 	 * Another ping has failed 	 */
name|np
operator|->
name|np_ping
operator|++
expr_stmt|;
comment|/* 	 * Not known to be up any longer 	 */
if|if
condition|(
name|FSRV_ISUP
argument_list|(
name|fs
argument_list|)
condition|)
block|{
name|fs
operator|->
name|fs_flags
operator|&=
operator|~
name|FSF_VALID
expr_stmt|;
if|if
condition|(
name|np
operator|->
name|np_ping
operator|>
literal|1
condition|)
name|srvrlog
argument_list|(
name|fs
argument_list|,
literal|"not responding"
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * If ttl has expired then guess that it is dead 	 */
if|if
condition|(
name|np
operator|->
name|np_ttl
operator|<
name|clocktime
argument_list|()
condition|)
block|{
name|int
name|oflags
init|=
name|fs
operator|->
name|fs_flags
decl_stmt|;
if|if
condition|(
operator|(
name|fs
operator|->
name|fs_flags
operator|&
name|FSF_DOWN
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* 			 * Server was up, but is now down. 			 */
name|srvrlog
argument_list|(
name|fs
argument_list|,
literal|"is down"
argument_list|)
expr_stmt|;
name|fs
operator|->
name|fs_flags
operator||=
name|FSF_DOWN
operator||
name|FSF_VALID
expr_stmt|;
comment|/* 			 * Since the server is down, the portmap 			 * information may now be wrong, so it 			 * must be flushed from the local cache 			 */
name|flush_nfs_fhandle_cache
argument_list|(
name|fs
argument_list|)
expr_stmt|;
name|np
operator|->
name|np_error
operator|=
operator|-
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|notdef
comment|/* 			 * Pretend just one ping has failed now 			 */
name|np
operator|->
name|np_ping
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
comment|/* 			 * Known to be down 			 */
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
operator|(
name|fs
operator|->
name|fs_flags
operator|&
name|FSF_VALID
operator|)
operator|==
literal|0
condition|)
name|srvrlog
argument_list|(
name|fs
argument_list|,
literal|"starts down"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|fs
operator|->
name|fs_flags
operator||=
name|FSF_VALID
expr_stmt|;
block|}
if|if
condition|(
name|oflags
operator|!=
name|fs
operator|->
name|fs_flags
operator|&&
operator|(
name|fs
operator|->
name|fs_flags
operator|&
name|FSF_WANT
operator|)
condition|)
name|wakeup_srvr
argument_list|(
name|fs
argument_list|)
expr_stmt|;
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|np
operator|->
name|np_ping
operator|>
literal|1
condition|)
name|dlog
argument_list|(
literal|"%d pings to %s failed - at most %d allowed"
argument_list|,
name|np
operator|->
name|np_ping
argument_list|,
name|fs
operator|->
name|fs_host
argument_list|,
name|MAX_ALLOWED_PINGS
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
block|}
comment|/* 	 * Run keepalive again 	 */
name|nfs_keepalive
argument_list|(
name|fs
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Keep track of whether a server is alive  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|nfs_keepalive
name|P
argument_list|(
operator|(
name|fserver
operator|*
name|fs
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|nfs_keepalive
parameter_list|(
name|fs
parameter_list|)
name|fserver
modifier|*
name|fs
decl_stmt|;
block|{
name|int
name|error
decl_stmt|;
name|nfs_private
modifier|*
name|np
init|=
operator|(
name|nfs_private
operator|*
operator|)
name|fs
operator|->
name|fs_private
decl_stmt|;
name|int
name|fstimeo
init|=
operator|-
literal|1
decl_stmt|;
comment|/* 	 * Send an NFS ping to this node 	 */
if|if
condition|(
name|ping_len
operator|==
literal|0
condition|)
name|start_ping
argument_list|()
expr_stmt|;
comment|/* 	 * Queue the packet... 	 */
name|error
operator|=
name|fwd_packet
argument_list|(
name|MK_RPC_XID
argument_list|(
name|RPC_XID_NFSPING
argument_list|,
name|np
operator|->
name|np_xid
argument_list|)
argument_list|,
operator|(
name|voidp
operator|)
name|ping_buf
argument_list|,
name|ping_len
argument_list|,
name|fs
operator|->
name|fs_ip
argument_list|,
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|voidp
operator|)
name|np
operator|->
name|np_xid
argument_list|,
name|nfs_pinged
argument_list|)
expr_stmt|;
comment|/* 	 * See if a hard error occured 	 */
switch|switch
condition|(
name|error
condition|)
block|{
case|case
name|ENETDOWN
case|:
case|case
name|ENETUNREACH
case|:
case|case
name|EHOSTDOWN
case|:
case|case
name|EHOSTUNREACH
case|:
name|np
operator|->
name|np_ping
operator|=
name|MAX_ALLOWED_PINGS
expr_stmt|;
comment|/* immediately down */
name|np
operator|->
name|np_ttl
operator|=
operator|(
name|time_t
operator|)
literal|0
expr_stmt|;
comment|/* 		 * This causes an immediate call to nfs_timed_out 		 * whenever the server was thought to be up. 		 * See +++ below. 		 */
name|fstimeo
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|0
case|:
ifdef|#
directive|ifdef
name|DEBUG
name|dlog
argument_list|(
literal|"Sent NFS ping to %s"
argument_list|,
name|fs
operator|->
name|fs_host
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
break|break;
block|}
ifdef|#
directive|ifdef
name|DEBUG
comment|/*dlog("keepalive, ping = %d", np->np_ping);*/
endif|#
directive|endif
comment|/* DEBUG */
comment|/* 	 * Back off the ping interval if we are not getting replies and 	 * the remote system is know to be down. 	 */
switch|switch
condition|(
name|fs
operator|->
name|fs_flags
operator|&
operator|(
name|FSF_DOWN
operator||
name|FSF_VALID
operator|)
condition|)
block|{
case|case
name|FSF_VALID
case|:
comment|/* Up */
if|if
condition|(
name|fstimeo
operator|<
literal|0
condition|)
comment|/* +++ see above */
name|fstimeo
operator|=
name|FAST_NFS_PING
expr_stmt|;
break|break;
case|case
name|FSF_VALID
operator||
name|FSF_DOWN
case|:
comment|/* Down */
name|fstimeo
operator|=
name|fs
operator|->
name|fs_pinger
expr_stmt|;
break|break;
default|default:
comment|/* Unknown */
name|fstimeo
operator|=
name|FAST_NFS_PING
expr_stmt|;
break|break;
block|}
ifdef|#
directive|ifdef
name|DEBUG
name|dlog
argument_list|(
literal|"NFS timeout in %d seconds"
argument_list|,
name|fstimeo
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
name|fs
operator|->
name|fs_cid
operator|=
name|timeout
argument_list|(
name|fstimeo
argument_list|,
name|nfs_timed_out
argument_list|,
operator|(
name|voidp
operator|)
name|fs
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
name|int
name|nfs_srvr_port
name|P
argument_list|(
operator|(
name|fserver
operator|*
name|fs
operator|,
name|u_short
operator|*
name|port
operator|,
name|voidp
name|wchan
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|nfs_srvr_port
parameter_list|(
name|fs
parameter_list|,
name|port
parameter_list|,
name|wchan
parameter_list|)
name|fserver
modifier|*
name|fs
decl_stmt|;
name|u_short
modifier|*
name|port
decl_stmt|;
name|voidp
name|wchan
decl_stmt|;
block|{
name|int
name|error
init|=
operator|-
literal|1
decl_stmt|;
if|if
condition|(
operator|(
name|fs
operator|->
name|fs_flags
operator|&
name|FSF_VALID
operator|)
operator|==
name|FSF_VALID
condition|)
block|{
if|if
condition|(
operator|(
name|fs
operator|->
name|fs_flags
operator|&
name|FSF_DOWN
operator|)
operator|==
literal|0
condition|)
block|{
name|nfs_private
modifier|*
name|np
init|=
operator|(
name|nfs_private
operator|*
operator|)
name|fs
operator|->
name|fs_private
decl_stmt|;
if|if
condition|(
name|np
operator|->
name|np_error
operator|==
literal|0
condition|)
block|{
operator|*
name|port
operator|=
name|np
operator|->
name|np_mountd
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
name|np
operator|->
name|np_error
expr_stmt|;
block|}
comment|/* 			 * Now go get the port mapping again in case it changed. 			 * Note that it is used even if (np_mountd_inval) 			 * is True.  The flag is used simply as an 			 * indication that the mountd may be invalid, not 			 * that it is known to be invalid. 			 */
if|if
condition|(
name|np
operator|->
name|np_mountd_inval
condition|)
name|recompute_portmap
argument_list|(
name|fs
argument_list|)
expr_stmt|;
else|else
name|np
operator|->
name|np_mountd_inval
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
name|EWOULDBLOCK
expr_stmt|;
block|}
block|}
if|if
condition|(
name|error
operator|<
literal|0
operator|&&
name|wchan
operator|&&
operator|!
operator|(
name|fs
operator|->
name|fs_flags
operator|&
name|FSF_WANT
operator|)
condition|)
block|{
comment|/* 		 * If a wait channel is supplied, and no 		 * error has yet occured, then arrange 		 * that a wakeup is done on the wait channel, 		 * whenever a wakeup is done on this fs node. 		 * Wakeup's are done on the fs node whenever 		 * it changes state - thus causing control to 		 * come back here and new, better things to happen. 		 */
name|fs
operator|->
name|fs_flags
operator||=
name|FSF_WANT
expr_stmt|;
name|sched_task
argument_list|(
name|wakeup_task
argument_list|,
name|wchan
argument_list|,
operator|(
name|voidp
operator|)
name|fs
argument_list|)
expr_stmt|;
block|}
return|return
name|error
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|void
name|start_nfs_pings
name|P
argument_list|(
operator|(
name|fserver
operator|*
name|fs
operator|,
name|int
name|pingval
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|start_nfs_pings
parameter_list|(
name|fs
parameter_list|,
name|pingval
parameter_list|)
name|fserver
modifier|*
name|fs
decl_stmt|;
name|int
name|pingval
decl_stmt|;
block|{
if|if
condition|(
operator|!
operator|(
name|fs
operator|->
name|fs_flags
operator|&
name|FSF_PINGING
operator|)
condition|)
block|{
name|fs
operator|->
name|fs_flags
operator||=
name|FSF_PINGING
expr_stmt|;
if|if
condition|(
name|fs
operator|->
name|fs_cid
condition|)
name|untimeout
argument_list|(
name|fs
operator|->
name|fs_cid
argument_list|)
expr_stmt|;
if|if
condition|(
name|pingval
operator|<
literal|0
condition|)
block|{
name|srvrlog
argument_list|(
name|fs
argument_list|,
literal|"wired up"
argument_list|)
expr_stmt|;
name|fs
operator|->
name|fs_flags
operator||=
name|FSF_VALID
expr_stmt|;
name|fs
operator|->
name|fs_flags
operator|&=
operator|~
name|FSF_DOWN
expr_stmt|;
block|}
else|else
block|{
name|nfs_keepalive
argument_list|(
name|fs
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|dlog
argument_list|(
literal|"Already running pings to %s"
argument_list|,
name|fs
operator|->
name|fs_host
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
block|}
block|}
end_function

begin_comment
comment|/*  * Find an nfs server for a host.  */
end_comment

begin_decl_stmt
name|fserver
modifier|*
name|find_nfs_srvr
name|P
argument_list|(
operator|(
name|mntfs
operator|*
name|mf
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
name|fserver
modifier|*
name|find_nfs_srvr
parameter_list|(
name|mf
parameter_list|)
name|mntfs
modifier|*
name|mf
decl_stmt|;
block|{
name|fserver
modifier|*
name|fs
decl_stmt|;
name|struct
name|hostent
modifier|*
name|hp
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|host
init|=
name|mf
operator|->
name|mf_fo
operator|->
name|opt_rhost
decl_stmt|;
name|struct
name|sockaddr_in
modifier|*
name|ip
decl_stmt|;
name|nfs_private
modifier|*
name|np
decl_stmt|;
name|int
name|pingval
decl_stmt|;
comment|/* 	 * Get ping interval from mount options. 	 * Current only used to decide whether pings 	 * are required or not.< 0 = no pings. 	 */
block|{
name|struct
name|mntent
name|mnt
decl_stmt|;
name|mnt
operator|.
name|mnt_opts
operator|=
name|mf
operator|->
name|mf_mopts
expr_stmt|;
name|pingval
operator|=
name|hasmntval
argument_list|(
operator|&
name|mnt
argument_list|,
literal|"ping"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAS_TCP_NFS
comment|/* 	   * Over TCP mount, don't bother to do pings. 	   * This is experimental - maybe you want to 	   * do pings anyway... 	   */
if|if
condition|(
name|pingval
operator|==
literal|0
operator|&&
name|hasmntopt
argument_list|(
operator|&
name|mnt
argument_list|,
literal|"tcp"
argument_list|)
condition|)
name|pingval
operator|=
operator|-
literal|1
expr_stmt|;
endif|#
directive|endif
comment|/* HAS_TCP_NFS */
block|}
comment|/* 	 * lookup host address and canonical name 	 */
name|hp
operator|=
name|gethostbyname
argument_list|(
name|host
argument_list|)
expr_stmt|;
comment|/* 	 * New code from Bob Harris<harris@basil-rathbone.mit.edu> 	 * Use canonical name to keep track of file server 	 * information.  This way aliases do not generate 	 * multiple NFS pingers.  (Except when we're normalizing 	 * hosts.) 	 */
if|if
condition|(
name|hp
operator|&&
operator|!
name|normalize_hosts
condition|)
name|host
operator|=
name|hp
operator|->
name|h_name
expr_stmt|;
name|ITER
argument_list|(
argument|fs
argument_list|,
argument|fserver
argument_list|,
argument|&nfs_srvr_list
argument_list|)
block|{
if|if
condition|(
name|STREQ
argument_list|(
name|host
argument_list|,
name|fs
operator|->
name|fs_host
argument_list|)
condition|)
block|{
name|start_nfs_pings
argument_list|(
name|fs
argument_list|,
name|pingval
argument_list|)
expr_stmt|;
name|fs
operator|->
name|fs_refc
operator|++
expr_stmt|;
return|return
name|fs
return|;
block|}
block|}
comment|/* 	 * Get here if we can't find an entry 	 */
if|if
condition|(
name|hp
condition|)
block|{
switch|switch
condition|(
name|hp
operator|->
name|h_addrtype
condition|)
block|{
case|case
name|AF_INET
case|:
name|ip
operator|=
name|ALLOC
argument_list|(
name|sockaddr_in
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|voidp
operator|)
name|ip
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ip
argument_list|)
argument_list|)
expr_stmt|;
name|ip
operator|->
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|voidp
operator|)
name|hp
operator|->
name|h_addr
argument_list|,
operator|(
name|voidp
operator|)
operator|&
name|ip
operator|->
name|sin_addr
argument_list|,
sizeof|sizeof
argument_list|(
name|ip
operator|->
name|sin_addr
argument_list|)
argument_list|)
expr_stmt|;
name|ip
operator|->
name|sin_port
operator|=
name|htons
argument_list|(
name|NFS_PORT
argument_list|)
expr_stmt|;
break|break;
default|default:
name|ip
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
name|plog
argument_list|(
name|XLOG_USER
argument_list|,
literal|"Unknown host: %s"
argument_list|,
name|host
argument_list|)
expr_stmt|;
name|ip
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 	 * Allocate a new server 	 */
name|fs
operator|=
name|ALLOC
argument_list|(
name|fserver
argument_list|)
expr_stmt|;
name|fs
operator|->
name|fs_refc
operator|=
literal|1
expr_stmt|;
name|fs
operator|->
name|fs_host
operator|=
name|strdup
argument_list|(
name|hp
condition|?
name|hp
operator|->
name|h_name
else|:
literal|"unknown_hostname"
argument_list|)
expr_stmt|;
if|if
condition|(
name|normalize_hosts
condition|)
name|host_normalize
argument_list|(
operator|&
name|fs
operator|->
name|fs_host
argument_list|)
expr_stmt|;
name|fs
operator|->
name|fs_ip
operator|=
name|ip
expr_stmt|;
name|fs
operator|->
name|fs_cid
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ip
condition|)
block|{
name|fs
operator|->
name|fs_flags
operator|=
name|FSF_DOWN
expr_stmt|;
comment|/* Starts off down */
block|}
else|else
block|{
name|fs
operator|->
name|fs_flags
operator|=
name|FSF_ERROR
operator||
name|FSF_VALID
expr_stmt|;
name|mf
operator|->
name|mf_flags
operator||=
name|MFF_ERROR
expr_stmt|;
name|mf
operator|->
name|mf_error
operator|=
name|ENOENT
expr_stmt|;
block|}
name|fs
operator|->
name|fs_type
operator|=
literal|"nfs"
expr_stmt|;
name|fs
operator|->
name|fs_pinger
operator|=
name|AM_PINGER
expr_stmt|;
name|np
operator|=
name|ALLOC
argument_list|(
name|nfs_private
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|voidp
operator|)
name|np
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|np
argument_list|)
argument_list|)
expr_stmt|;
name|np
operator|->
name|np_mountd_inval
operator|=
name|TRUE
expr_stmt|;
name|np
operator|->
name|np_xid
operator|=
name|NPXID_ALLOC
argument_list|()
expr_stmt|;
name|np
operator|->
name|np_error
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* 	 * Initially the server will be deemed dead after 	 * MAX_ALLOWED_PINGS of the fast variety have failed. 	 */
name|np
operator|->
name|np_ttl
operator|=
name|clocktime
argument_list|()
operator|+
name|MAX_ALLOWED_PINGS
operator|*
name|FAST_NFS_PING
operator|-
literal|1
expr_stmt|;
name|fs
operator|->
name|fs_private
operator|=
operator|(
name|voidp
operator|)
name|np
expr_stmt|;
name|fs
operator|->
name|fs_prfree
operator|=
operator|(
name|void
argument_list|(
operator|*
argument_list|)
argument_list|()
operator|)
name|free
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|fs
operator|->
name|fs_flags
operator|&
name|FSF_ERROR
operator|)
condition|)
block|{
comment|/* 		 * Start of keepalive timer 		 */
name|start_nfs_pings
argument_list|(
name|fs
argument_list|,
name|pingval
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Add to list of servers 	 */
name|ins_que
argument_list|(
operator|&
name|fs
operator|->
name|fs_q
argument_list|,
operator|&
name|nfs_srvr_list
argument_list|)
expr_stmt|;
return|return
name|fs
return|;
block|}
end_function

end_unit

