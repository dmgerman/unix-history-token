begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1988 University of Utah.  * Copyright (c) 1992 The Regents of the University of California.  * All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * the Systems Programming Group of the University of Utah Computer  * Science Department, Ralph Campbell, Sony Corp. and Kazumasa Utashiro  * of Software Research Associates, Inc.  *  * %sccs.include.redist.c%  *  * from: Utah $Hdr: trap.c 1.32 91/04/06$  *  *	@(#)trap.c	7.10 (Berkeley) %G%  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/signalvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/syscall.h>
end_include

begin_include
include|#
directive|include
file|<sys/user.h>
end_include

begin_include
include|#
directive|include
file|<sys/buf.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|KTRACE
end_ifdef

begin_include
include|#
directive|include
file|<sys/ktrace.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<net/netisr.h>
end_include

begin_include
include|#
directive|include
file|<machine/trap.h>
end_include

begin_include
include|#
directive|include
file|<machine/psl.h>
end_include

begin_include
include|#
directive|include
file|<machine/reg.h>
end_include

begin_include
include|#
directive|include
file|<machine/cpu.h>
end_include

begin_include
include|#
directive|include
file|<machine/pte.h>
end_include

begin_include
include|#
directive|include
file|<machine/mips_opcode.h>
end_include

begin_include
include|#
directive|include
file|<machine/adrsmap.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_kern.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_page.h>
end_include

begin_include
include|#
directive|include
file|"lp.h"
end_include

begin_include
include|#
directive|include
file|"bm.h"
end_include

begin_include
include|#
directive|include
file|"ms.h"
end_include

begin_include
include|#
directive|include
file|"en.h"
end_include

begin_include
include|#
directive|include
file|<news3400/hbdev/dmac_0448.h>
end_include

begin_include
include|#
directive|include
file|<news3400/sio/scc.h>
end_include

begin_decl_stmt
name|struct
name|proc
modifier|*
name|machFPCurProcPtr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* pointer to last proc to use FP */
end_comment

begin_function_decl
specifier|extern
name|void
name|MachKernGenException
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|MachUserGenException
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|MachKernIntr
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|MachUserIntr
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|MachTLBModException
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|MachTLBMissException
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|unsigned
name|MachEmulateBranch
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
function_decl|(
modifier|*
name|machExceptionTable
index|[]
function_decl|)
parameter_list|()
init|=
block|{
comment|/*  * The kernel exception handlers.  */
name|MachKernIntr
operator|,
comment|/* external interrupt */
function_decl|MachKernGenException
operator|,
comment|/* TLB modification */
function_decl|MachTLBMissException
operator|,
comment|/* TLB miss (load or instr. fetch) */
function_decl|MachTLBMissException
operator|,
comment|/* TLB miss (store) */
function_decl|MachKernGenException
operator|,
comment|/* address error (load or I-fetch) */
function_decl|MachKernGenException
operator|,
comment|/* address error (store) */
function_decl|MachKernGenException
operator|,
comment|/* bus error (I-fetch) */
function_decl|MachKernGenException
operator|,
comment|/* bus error (load or store) */
function_decl|MachKernGenException
operator|,
comment|/* system call */
function_decl|MachKernGenException
operator|,
comment|/* breakpoint */
function_decl|MachKernGenException
operator|,
comment|/* reserved instruction */
function_decl|MachKernGenException
operator|,
comment|/* coprocessor unusable */
function_decl|MachKernGenException
operator|,
comment|/* arithmetic overflow */
function_decl|MachKernGenException
operator|,
comment|/* reserved */
function_decl|MachKernGenException
operator|,
comment|/* reserved */
function_decl|MachKernGenException
operator|,
comment|/* reserved */
comment|/*  * The user exception handlers.  */
function_decl|MachUserIntr
operator|,
function_decl|MachUserGenException
operator|,
function_decl|MachUserGenException
operator|,
function_decl|MachUserGenException
operator|,
function_decl|MachUserGenException
operator|,
function_decl|MachUserGenException
operator|,
function_decl|MachUserGenException
operator|,
function_decl|MachUserGenException
operator|,
function_decl|MachUserGenException
operator|,
function_decl|MachUserGenException
operator|,
function_decl|MachUserGenException
operator|,
function_decl|MachUserGenException
operator|,
function_decl|MachUserGenException
operator|,
function_decl|MachUserGenException
operator|,
function_decl|MachUserGenException
operator|,
function_decl|MachUserGenException
operator|,
end_function_decl

begin_decl_stmt
unit|};
name|char
modifier|*
name|trap_type
index|[]
init|=
block|{
literal|"external interrupt"
block|,
literal|"TLB modification"
block|,
literal|"TLB miss (load or instr. fetch)"
block|,
literal|"TLB miss (store)"
block|,
literal|"address error (load or I-fetch)"
block|,
literal|"address error (store)"
block|,
literal|"bus error (I-fetch)"
block|,
literal|"bus error (load or store)"
block|,
literal|"system call"
block|,
literal|"breakpoint"
block|,
literal|"reserved instruction"
block|,
literal|"coprocessor unusable"
block|,
literal|"arithmetic overflow"
block|,
literal|"reserved 13"
block|,
literal|"reserved 14"
block|,
literal|"reserved 15"
block|, }
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_define
define|#
directive|define
name|TRAPSIZE
value|10
end_define

begin_struct
struct|struct
name|trapdebug
block|{
comment|/* trap history buffer for debugging */
name|u_int
name|status
decl_stmt|;
name|u_int
name|cause
decl_stmt|;
name|u_int
name|vadr
decl_stmt|;
name|u_int
name|pc
decl_stmt|;
name|u_int
name|ra
decl_stmt|;
name|u_int
name|code
decl_stmt|;
block|}
name|trapdebug
index|[
name|TRAPSIZE
index|]
struct|,
modifier|*
name|trp
init|=
name|trapdebug
struct|;
end_struct

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Handle an exception.  * Called from MachKernGenException() or MachUserGenException()  * when a processor trap occurs.  * In the case of a kernel trap, we return the pc where to resume if  * ((struct pcb *)UADDR)->pcb_onfault is set, otherwise, return old pc.  */
end_comment

begin_function
name|unsigned
name|trap
parameter_list|(
name|statusReg
parameter_list|,
name|causeReg
parameter_list|,
name|vadr
parameter_list|,
name|pc
parameter_list|,
name|args
parameter_list|)
name|unsigned
name|statusReg
decl_stmt|;
comment|/* status register at time of the exception */
name|unsigned
name|causeReg
decl_stmt|;
comment|/* cause register at time of exception */
name|unsigned
name|vadr
decl_stmt|;
comment|/* address (if any) the fault occured on */
name|unsigned
name|pc
decl_stmt|;
comment|/* program counter where to continue */
block|{
specifier|register
name|int
name|type
decl_stmt|,
name|i
decl_stmt|;
name|unsigned
name|ucode
init|=
literal|0
decl_stmt|;
specifier|register
name|struct
name|proc
modifier|*
name|p
init|=
name|curproc
decl_stmt|;
name|u_quad_t
name|sticks
decl_stmt|;
name|vm_prot_t
name|ftype
decl_stmt|;
specifier|extern
name|unsigned
name|onfault_table
index|[]
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|trp
operator|->
name|status
operator|=
name|statusReg
expr_stmt|;
name|trp
operator|->
name|cause
operator|=
name|causeReg
expr_stmt|;
name|trp
operator|->
name|vadr
operator|=
name|vadr
expr_stmt|;
name|trp
operator|->
name|pc
operator|=
name|pc
expr_stmt|;
name|trp
operator|->
name|ra
operator|=
operator|!
name|USERMODE
argument_list|(
name|statusReg
argument_list|)
condition|?
operator|(
operator|(
name|int
operator|*
operator|)
operator|&
name|args
operator|)
index|[
literal|19
index|]
else|:
name|p
operator|->
name|p_md
operator|.
name|md_regs
index|[
name|RA
index|]
expr_stmt|;
name|trp
operator|->
name|code
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|++
name|trp
operator|==
operator|&
name|trapdebug
index|[
name|TRAPSIZE
index|]
condition|)
name|trp
operator|=
name|trapdebug
expr_stmt|;
endif|#
directive|endif
name|cnt
operator|.
name|v_trap
operator|++
expr_stmt|;
name|type
operator|=
operator|(
name|causeReg
operator|&
name|MACH_CR_EXC_CODE
operator|)
operator|>>
name|MACH_CR_EXC_CODE_SHIFT
expr_stmt|;
if|if
condition|(
name|USERMODE
argument_list|(
name|statusReg
argument_list|)
condition|)
block|{
name|type
operator||=
name|T_USER
expr_stmt|;
name|sticks
operator|=
name|p
operator|->
name|p_sticks
expr_stmt|;
block|}
comment|/* 	 * Enable hardware interrupts if they were on before. 	 * We only respond to software interrupts when returning to user mode. 	 */
if|if
condition|(
name|statusReg
operator|&
name|MACH_SR_INT_ENA_PREV
condition|)
name|splx
argument_list|(
operator|(
name|statusReg
operator|&
name|MACH_HARD_INT_MASK
operator|)
operator||
name|MACH_SR_INT_ENA_CUR
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|T_TLB_MOD
case|:
comment|/* check for kernel address */
if|if
condition|(
operator|(
name|int
operator|)
name|vadr
operator|<
literal|0
condition|)
block|{
specifier|register
name|pt_entry_t
modifier|*
name|pte
decl_stmt|;
specifier|register
name|unsigned
name|entry
decl_stmt|;
specifier|register
name|vm_offset_t
name|pa
decl_stmt|;
name|pte
operator|=
name|kvtopte
argument_list|(
name|vadr
argument_list|)
expr_stmt|;
name|entry
operator|=
name|pte
operator|->
name|pt_entry
expr_stmt|;
ifdef|#
directive|ifdef
name|DIAGNOSTIC
if|if
condition|(
operator|!
operator|(
name|entry
operator|&
name|PG_V
operator|)
operator|||
operator|(
name|entry
operator|&
name|PG_M
operator|)
condition|)
name|panic
argument_list|(
literal|"trap: ktlbmod: invalid pte"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|entry
operator|&
name|PG_RO
condition|)
block|{
comment|/* write to read only page in the kernel */
name|ftype
operator|=
name|VM_PROT_WRITE
expr_stmt|;
goto|goto
name|kernel_fault
goto|;
block|}
name|entry
operator||=
name|PG_M
expr_stmt|;
name|pte
operator|->
name|pt_entry
operator|=
name|entry
expr_stmt|;
name|vadr
operator|&=
operator|~
name|PGOFSET
expr_stmt|;
name|MachTLBUpdate
argument_list|(
name|vadr
argument_list|,
name|entry
argument_list|)
expr_stmt|;
name|pa
operator|=
name|entry
operator|&
name|PG_FRAME
expr_stmt|;
ifdef|#
directive|ifdef
name|ATTR
name|pmap_attributes
index|[
name|atop
argument_list|(
name|pa
argument_list|)
index|]
operator||=
name|PMAP_ATTR_MOD
expr_stmt|;
else|#
directive|else
if|if
condition|(
operator|!
name|IS_VM_PHYSADDR
argument_list|(
name|pa
argument_list|)
condition|)
name|panic
argument_list|(
literal|"trap: ktlbmod: unmanaged page"
argument_list|)
expr_stmt|;
name|PHYS_TO_VM_PAGE
argument_list|(
name|pa
argument_list|)
operator|->
name|flags
operator|&=
operator|~
name|PG_CLEAN
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|pc
operator|)
return|;
block|}
comment|/* FALLTHROUGH */
case|case
name|T_TLB_MOD
operator|+
name|T_USER
case|:
block|{
specifier|register
name|pt_entry_t
modifier|*
name|pte
decl_stmt|;
specifier|register
name|unsigned
name|entry
decl_stmt|;
specifier|register
name|vm_offset_t
name|pa
decl_stmt|;
name|pmap_t
name|pmap
init|=
operator|&
name|p
operator|->
name|p_vmspace
operator|->
name|vm_pmap
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|pte
operator|=
name|pmap_segmap
argument_list|(
name|pmap
argument_list|,
name|vadr
argument_list|)
operator|)
condition|)
name|panic
argument_list|(
literal|"trap: utlbmod: invalid segmap"
argument_list|)
expr_stmt|;
name|pte
operator|+=
operator|(
name|vadr
operator|>>
name|PGSHIFT
operator|)
operator|&
operator|(
name|NPTEPG
operator|-
literal|1
operator|)
expr_stmt|;
name|entry
operator|=
name|pte
operator|->
name|pt_entry
expr_stmt|;
ifdef|#
directive|ifdef
name|DIAGNOSTIC
if|if
condition|(
operator|!
operator|(
name|entry
operator|&
name|PG_V
operator|)
operator|||
operator|(
name|entry
operator|&
name|PG_M
operator|)
condition|)
name|panic
argument_list|(
literal|"trap: utlbmod: invalid pte"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|entry
operator|&
name|PG_RO
condition|)
block|{
comment|/* write to read only page */
name|ftype
operator|=
name|VM_PROT_WRITE
expr_stmt|;
goto|goto
name|dofault
goto|;
block|}
name|entry
operator||=
name|PG_M
expr_stmt|;
name|pte
operator|->
name|pt_entry
operator|=
name|entry
expr_stmt|;
name|vadr
operator|=
operator|(
name|vadr
operator|&
operator|~
name|PGOFSET
operator|)
operator||
operator|(
name|pmap
operator|->
name|pm_tlbpid
operator|<<
name|VMMACH_TLB_PID_SHIFT
operator|)
expr_stmt|;
name|MachTLBUpdate
argument_list|(
name|vadr
argument_list|,
name|entry
argument_list|)
expr_stmt|;
name|pa
operator|=
name|entry
operator|&
name|PG_FRAME
expr_stmt|;
ifdef|#
directive|ifdef
name|ATTR
name|pmap_attributes
index|[
name|atop
argument_list|(
name|pa
argument_list|)
index|]
operator||=
name|PMAP_ATTR_MOD
expr_stmt|;
else|#
directive|else
if|if
condition|(
operator|!
name|IS_VM_PHYSADDR
argument_list|(
name|pa
argument_list|)
condition|)
name|panic
argument_list|(
literal|"trap: utlbmod: unmanaged page"
argument_list|)
expr_stmt|;
name|PHYS_TO_VM_PAGE
argument_list|(
name|pa
argument_list|)
operator|->
name|flags
operator|&=
operator|~
name|PG_CLEAN
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|USERMODE
argument_list|(
name|statusReg
argument_list|)
condition|)
return|return
operator|(
name|pc
operator|)
return|;
goto|goto
name|out
goto|;
block|}
case|case
name|T_TLB_LD_MISS
case|:
case|case
name|T_TLB_ST_MISS
case|:
name|ftype
operator|=
operator|(
name|type
operator|==
name|T_TLB_ST_MISS
operator|)
condition|?
name|VM_PROT_WRITE
else|:
name|VM_PROT_READ
expr_stmt|;
comment|/* check for kernel address */
if|if
condition|(
operator|(
name|int
operator|)
name|vadr
operator|<
literal|0
condition|)
block|{
specifier|register
name|vm_offset_t
name|va
decl_stmt|;
name|int
name|rv
decl_stmt|;
name|kernel_fault
label|:
name|va
operator|=
name|trunc_page
argument_list|(
operator|(
name|vm_offset_t
operator|)
name|vadr
argument_list|)
expr_stmt|;
name|rv
operator|=
name|vm_fault
argument_list|(
name|kernel_map
argument_list|,
name|va
argument_list|,
name|ftype
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|==
name|KERN_SUCCESS
condition|)
return|return
operator|(
name|pc
operator|)
return|;
if|if
condition|(
name|i
operator|=
operator|(
operator|(
expr|struct
name|pcb
operator|*
operator|)
name|UADDR
operator|)
operator|->
name|pcb_onfault
condition|)
block|{
operator|(
operator|(
expr|struct
name|pcb
operator|*
operator|)
name|UADDR
operator|)
operator|->
name|pcb_onfault
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|onfault_table
index|[
name|i
index|]
operator|)
return|;
block|}
goto|goto
name|err
goto|;
block|}
comment|/* 		 * It is an error for the kernel to access user space except 		 * through the copyin/copyout routines. 		 */
if|if
condition|(
operator|(
name|i
operator|=
operator|(
operator|(
expr|struct
name|pcb
operator|*
operator|)
name|UADDR
operator|)
operator|->
name|pcb_onfault
operator|)
operator|==
literal|0
condition|)
goto|goto
name|err
goto|;
comment|/* check for fuswintr() or suswintr() getting a page fault */
if|if
condition|(
name|i
operator|==
literal|4
condition|)
return|return
operator|(
name|onfault_table
index|[
name|i
index|]
operator|)
return|;
goto|goto
name|dofault
goto|;
case|case
name|T_TLB_LD_MISS
operator|+
name|T_USER
case|:
name|ftype
operator|=
name|VM_PROT_READ
expr_stmt|;
goto|goto
name|dofault
goto|;
case|case
name|T_TLB_ST_MISS
operator|+
name|T_USER
case|:
name|ftype
operator|=
name|VM_PROT_WRITE
expr_stmt|;
name|dofault
label|:
block|{
specifier|register
name|vm_offset_t
name|va
decl_stmt|;
specifier|register
name|struct
name|vmspace
modifier|*
name|vm
decl_stmt|;
specifier|register
name|vm_map_t
name|map
decl_stmt|;
name|int
name|rv
decl_stmt|;
name|vm
operator|=
name|p
operator|->
name|p_vmspace
expr_stmt|;
name|map
operator|=
operator|&
name|vm
operator|->
name|vm_map
expr_stmt|;
name|va
operator|=
name|trunc_page
argument_list|(
operator|(
name|vm_offset_t
operator|)
name|vadr
argument_list|)
expr_stmt|;
name|rv
operator|=
name|vm_fault
argument_list|(
name|map
argument_list|,
name|va
argument_list|,
name|ftype
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
comment|/* 		 * If this was a stack access we keep track of the maximum 		 * accessed stack size.  Also, if vm_fault gets a protection 		 * failure it is due to accessing the stack region outside 		 * the current limit and we need to reflect that as an access 		 * error. 		 */
if|if
condition|(
operator|(
name|caddr_t
operator|)
name|va
operator|>=
name|vm
operator|->
name|vm_maxsaddr
condition|)
block|{
if|if
condition|(
name|rv
operator|==
name|KERN_SUCCESS
condition|)
block|{
name|unsigned
name|nss
decl_stmt|;
name|nss
operator|=
name|clrnd
argument_list|(
name|btoc
argument_list|(
name|USRSTACK
operator|-
operator|(
name|unsigned
operator|)
name|va
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|nss
operator|>
name|vm
operator|->
name|vm_ssize
condition|)
name|vm
operator|->
name|vm_ssize
operator|=
name|nss
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|rv
operator|==
name|KERN_PROTECTION_FAILURE
condition|)
name|rv
operator|=
name|KERN_INVALID_ADDRESS
expr_stmt|;
block|}
if|if
condition|(
name|rv
operator|==
name|KERN_SUCCESS
condition|)
block|{
if|if
condition|(
operator|!
name|USERMODE
argument_list|(
name|statusReg
argument_list|)
condition|)
return|return
operator|(
name|pc
operator|)
return|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
operator|!
name|USERMODE
argument_list|(
name|statusReg
argument_list|)
condition|)
block|{
if|if
condition|(
name|i
operator|=
operator|(
operator|(
expr|struct
name|pcb
operator|*
operator|)
name|UADDR
operator|)
operator|->
name|pcb_onfault
condition|)
block|{
operator|(
operator|(
expr|struct
name|pcb
operator|*
operator|)
name|UADDR
operator|)
operator|->
name|pcb_onfault
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|onfault_table
index|[
name|i
index|]
operator|)
return|;
block|}
goto|goto
name|err
goto|;
block|}
name|ucode
operator|=
name|vadr
expr_stmt|;
name|i
operator|=
operator|(
name|rv
operator|==
name|KERN_PROTECTION_FAILURE
operator|)
condition|?
name|SIGBUS
else|:
name|SIGSEGV
expr_stmt|;
break|break;
block|}
case|case
name|T_ADDR_ERR_LD
operator|+
name|T_USER
case|:
comment|/* misaligned or kseg access */
case|case
name|T_ADDR_ERR_ST
operator|+
name|T_USER
case|:
comment|/* misaligned or kseg access */
case|case
name|T_BUS_ERR_IFETCH
operator|+
name|T_USER
case|:
comment|/* BERR asserted to cpu */
case|case
name|T_BUS_ERR_LD_ST
operator|+
name|T_USER
case|:
comment|/* BERR asserted to cpu */
name|i
operator|=
name|SIGSEGV
expr_stmt|;
break|break;
case|case
name|T_SYSCALL
operator|+
name|T_USER
case|:
block|{
specifier|register
name|int
modifier|*
name|locr0
init|=
name|p
operator|->
name|p_md
operator|.
name|md_regs
decl_stmt|;
specifier|register
name|struct
name|sysent
modifier|*
name|callp
decl_stmt|;
name|unsigned
name|int
name|code
decl_stmt|;
name|int
name|numsys
decl_stmt|;
struct|struct
name|args
block|{
name|int
name|i
index|[
literal|8
index|]
decl_stmt|;
block|}
name|args
struct|;
name|int
name|rval
index|[
literal|2
index|]
decl_stmt|;
name|struct
name|sysent
modifier|*
name|systab
decl_stmt|;
specifier|extern
name|int
name|nsysent
decl_stmt|;
ifdef|#
directive|ifdef
name|COMPAT_NEWSOS
specifier|extern
name|int
name|nnewssys
decl_stmt|;
specifier|extern
name|struct
name|sysent
name|newssys
index|[]
decl_stmt|;
endif|#
directive|endif
name|cnt
operator|.
name|v_syscall
operator|++
expr_stmt|;
comment|/* compute next PC after syscall instruction */
if|if
condition|(
operator|(
name|int
operator|)
name|causeReg
operator|<
literal|0
condition|)
name|locr0
index|[
name|PC
index|]
operator|=
name|MachEmulateBranch
argument_list|(
name|locr0
argument_list|,
name|pc
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|locr0
index|[
name|PC
index|]
operator|+=
literal|4
expr_stmt|;
name|systab
operator|=
name|sysent
expr_stmt|;
name|numsys
operator|=
name|nsysent
expr_stmt|;
name|code
operator|=
name|locr0
index|[
name|V0
index|]
expr_stmt|;
ifdef|#
directive|ifdef
name|COMPAT_NEWSOS
if|if
condition|(
name|code
operator|>=
literal|1000
condition|)
block|{
name|code
operator|-=
literal|1000
expr_stmt|;
name|systab
operator|=
name|newssys
expr_stmt|;
name|numsys
operator|=
name|nnewssys
expr_stmt|;
block|}
endif|#
directive|endif
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|SYS_indir
case|:
comment|/* 			 * Code is first argument, followed by actual args. 			 */
name|code
operator|=
name|locr0
index|[
name|A0
index|]
expr_stmt|;
ifdef|#
directive|ifdef
name|COMPAT_NEWSOS
if|if
condition|(
name|code
operator|>=
literal|1000
condition|)
block|{
name|code
operator|-=
literal|1000
expr_stmt|;
name|systab
operator|=
name|newssys
expr_stmt|;
name|numsys
operator|=
name|nnewssys
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|code
operator|>=
name|numsys
condition|)
name|callp
operator|=
operator|&
name|systab
index|[
name|SYS_indir
index|]
expr_stmt|;
comment|/* (illegal) */
else|else
name|callp
operator|=
operator|&
name|systab
index|[
name|code
index|]
expr_stmt|;
name|i
operator|=
name|callp
operator|->
name|sy_narg
expr_stmt|;
name|args
operator|.
name|i
index|[
literal|0
index|]
operator|=
name|locr0
index|[
name|A1
index|]
expr_stmt|;
name|args
operator|.
name|i
index|[
literal|1
index|]
operator|=
name|locr0
index|[
name|A2
index|]
expr_stmt|;
name|args
operator|.
name|i
index|[
literal|2
index|]
operator|=
name|locr0
index|[
name|A3
index|]
expr_stmt|;
if|if
condition|(
name|i
operator|>
literal|3
condition|)
block|{
name|i
operator|=
name|copyin
argument_list|(
call|(
name|caddr_t
call|)
argument_list|(
name|locr0
index|[
name|SP
index|]
operator|+
literal|4
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|args
operator|.
name|i
index|[
literal|3
index|]
argument_list|,
call|(
name|u_int
call|)
argument_list|(
name|i
operator|-
literal|3
argument_list|)
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
condition|)
block|{
name|locr0
index|[
name|V0
index|]
operator|=
name|i
expr_stmt|;
name|locr0
index|[
name|A3
index|]
operator|=
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|KTRACE
if|if
condition|(
name|KTRPOINT
argument_list|(
name|p
argument_list|,
name|KTR_SYSCALL
argument_list|)
condition|)
name|ktrsyscall
argument_list|(
name|p
operator|->
name|p_tracep
argument_list|,
name|code
argument_list|,
name|callp
operator|->
name|sy_narg
argument_list|,
name|args
operator|.
name|i
argument_list|)
expr_stmt|;
endif|#
directive|endif
goto|goto
name|done
goto|;
block|}
block|}
break|break;
case|case
name|SYS___indir
case|:
comment|/* 			 * Like indir, but code is a quad, so as to maintain 			 * quad alignment for the rest of the arguments. 			 */
name|code
operator|=
name|locr0
index|[
name|A0
operator|+
name|_QUAD_LOWWORD
index|]
expr_stmt|;
if|if
condition|(
name|code
operator|>=
name|numsys
condition|)
name|callp
operator|=
operator|&
name|systab
index|[
name|SYS_indir
index|]
expr_stmt|;
comment|/* (illegal) */
else|else
name|callp
operator|=
operator|&
name|systab
index|[
name|code
index|]
expr_stmt|;
name|i
operator|=
name|callp
operator|->
name|sy_narg
expr_stmt|;
name|args
operator|.
name|i
index|[
literal|0
index|]
operator|=
name|locr0
index|[
name|A2
index|]
expr_stmt|;
name|args
operator|.
name|i
index|[
literal|1
index|]
operator|=
name|locr0
index|[
name|A3
index|]
expr_stmt|;
if|if
condition|(
name|i
operator|>
literal|2
condition|)
block|{
name|i
operator|=
name|copyin
argument_list|(
call|(
name|caddr_t
call|)
argument_list|(
name|locr0
index|[
name|SP
index|]
operator|+
literal|4
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|args
operator|.
name|i
index|[
literal|2
index|]
argument_list|,
call|(
name|u_int
call|)
argument_list|(
name|i
operator|-
literal|2
argument_list|)
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
condition|)
block|{
name|locr0
index|[
name|V0
index|]
operator|=
name|i
expr_stmt|;
name|locr0
index|[
name|A3
index|]
operator|=
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|KTRACE
if|if
condition|(
name|KTRPOINT
argument_list|(
name|p
argument_list|,
name|KTR_SYSCALL
argument_list|)
condition|)
name|ktrsyscall
argument_list|(
name|p
operator|->
name|p_tracep
argument_list|,
name|code
argument_list|,
name|callp
operator|->
name|sy_narg
argument_list|,
name|args
operator|.
name|i
argument_list|)
expr_stmt|;
endif|#
directive|endif
goto|goto
name|done
goto|;
block|}
block|}
break|break;
default|default:
if|if
condition|(
name|code
operator|>=
name|numsys
condition|)
name|callp
operator|=
operator|&
name|systab
index|[
name|SYS_indir
index|]
expr_stmt|;
comment|/* (illegal) */
else|else
name|callp
operator|=
operator|&
name|systab
index|[
name|code
index|]
expr_stmt|;
name|i
operator|=
name|callp
operator|->
name|sy_narg
expr_stmt|;
name|args
operator|.
name|i
index|[
literal|0
index|]
operator|=
name|locr0
index|[
name|A0
index|]
expr_stmt|;
name|args
operator|.
name|i
index|[
literal|1
index|]
operator|=
name|locr0
index|[
name|A1
index|]
expr_stmt|;
name|args
operator|.
name|i
index|[
literal|2
index|]
operator|=
name|locr0
index|[
name|A2
index|]
expr_stmt|;
name|args
operator|.
name|i
index|[
literal|3
index|]
operator|=
name|locr0
index|[
name|A3
index|]
expr_stmt|;
if|if
condition|(
name|i
operator|>
literal|4
condition|)
block|{
name|i
operator|=
name|copyin
argument_list|(
call|(
name|caddr_t
call|)
argument_list|(
name|locr0
index|[
name|SP
index|]
operator|+
literal|4
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|args
operator|.
name|i
index|[
literal|4
index|]
argument_list|,
call|(
name|u_int
call|)
argument_list|(
name|i
operator|-
literal|4
argument_list|)
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
condition|)
block|{
name|locr0
index|[
name|V0
index|]
operator|=
name|i
expr_stmt|;
name|locr0
index|[
name|A3
index|]
operator|=
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|KTRACE
if|if
condition|(
name|KTRPOINT
argument_list|(
name|p
argument_list|,
name|KTR_SYSCALL
argument_list|)
condition|)
name|ktrsyscall
argument_list|(
name|p
operator|->
name|p_tracep
argument_list|,
name|code
argument_list|,
name|callp
operator|->
name|sy_narg
argument_list|,
name|args
operator|.
name|i
argument_list|)
expr_stmt|;
endif|#
directive|endif
goto|goto
name|done
goto|;
block|}
block|}
block|}
ifdef|#
directive|ifdef
name|KTRACE
if|if
condition|(
name|KTRPOINT
argument_list|(
name|p
argument_list|,
name|KTR_SYSCALL
argument_list|)
condition|)
name|ktrsyscall
argument_list|(
name|p
operator|->
name|p_tracep
argument_list|,
name|code
argument_list|,
name|callp
operator|->
name|sy_narg
argument_list|,
name|args
operator|.
name|i
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|rval
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|rval
index|[
literal|1
index|]
operator|=
name|locr0
index|[
name|V1
index|]
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|trp
operator|==
name|trapdebug
condition|)
name|trapdebug
index|[
name|TRAPSIZE
operator|-
literal|1
index|]
operator|.
name|code
operator|=
name|code
expr_stmt|;
else|else
name|trp
index|[
operator|-
literal|1
index|]
operator|.
name|code
operator|=
name|code
expr_stmt|;
endif|#
directive|endif
name|i
operator|=
call|(
modifier|*
name|callp
operator|->
name|sy_call
call|)
argument_list|(
name|p
argument_list|,
operator|&
name|args
argument_list|,
name|rval
argument_list|)
expr_stmt|;
comment|/* 		 * Reinitialize proc pointer `p' as it may be different 		 * if this is a child returning from fork syscall. 		 */
name|p
operator|=
name|curproc
expr_stmt|;
name|locr0
operator|=
name|p
operator|->
name|p_md
operator|.
name|md_regs
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
block|{
name|int
name|s
decl_stmt|;
name|s
operator|=
name|splhigh
argument_list|()
expr_stmt|;
name|trp
operator|->
name|status
operator|=
name|statusReg
expr_stmt|;
name|trp
operator|->
name|cause
operator|=
name|causeReg
expr_stmt|;
name|trp
operator|->
name|vadr
operator|=
name|locr0
index|[
name|SP
index|]
expr_stmt|;
name|trp
operator|->
name|pc
operator|=
name|locr0
index|[
name|PC
index|]
expr_stmt|;
name|trp
operator|->
name|ra
operator|=
name|locr0
index|[
name|RA
index|]
expr_stmt|;
name|trp
operator|->
name|code
operator|=
operator|-
name|code
expr_stmt|;
if|if
condition|(
operator|++
name|trp
operator|==
operator|&
name|trapdebug
index|[
name|TRAPSIZE
index|]
condition|)
name|trp
operator|=
name|trapdebug
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
switch|switch
condition|(
name|i
condition|)
block|{
case|case
literal|0
case|:
name|locr0
index|[
name|V0
index|]
operator|=
name|rval
index|[
literal|0
index|]
expr_stmt|;
name|locr0
index|[
name|V1
index|]
operator|=
name|rval
index|[
literal|1
index|]
expr_stmt|;
name|locr0
index|[
name|A3
index|]
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|ERESTART
case|:
name|locr0
index|[
name|PC
index|]
operator|=
name|pc
expr_stmt|;
break|break;
case|case
name|EJUSTRETURN
case|:
break|break;
comment|/* nothing to do */
default|default:
name|locr0
index|[
name|V0
index|]
operator|=
name|i
expr_stmt|;
name|locr0
index|[
name|A3
index|]
operator|=
literal|1
expr_stmt|;
block|}
name|done
label|:
ifdef|#
directive|ifdef
name|KTRACE
if|if
condition|(
name|KTRPOINT
argument_list|(
name|p
argument_list|,
name|KTR_SYSRET
argument_list|)
condition|)
name|ktrsysret
argument_list|(
name|p
operator|->
name|p_tracep
argument_list|,
name|code
argument_list|,
name|i
argument_list|,
name|rval
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
goto|goto
name|out
goto|;
block|}
case|case
name|T_BREAK
operator|+
name|T_USER
case|:
block|{
specifier|register
name|unsigned
name|va
decl_stmt|,
name|instr
decl_stmt|;
comment|/* compute address of break instruction */
name|va
operator|=
name|pc
expr_stmt|;
if|if
condition|(
operator|(
name|int
operator|)
name|causeReg
operator|<
literal|0
condition|)
name|va
operator|+=
literal|4
expr_stmt|;
comment|/* read break instruction */
name|instr
operator|=
name|fuiword
argument_list|(
operator|(
name|caddr_t
operator|)
name|va
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|KADB
if|if
condition|(
name|instr
operator|==
name|MACH_BREAK_BRKPT
operator|||
name|instr
operator|==
name|MACH_BREAK_SSTEP
condition|)
goto|goto
name|err
goto|;
endif|#
directive|endif
if|if
condition|(
name|p
operator|->
name|p_md
operator|.
name|md_ss_addr
operator|!=
name|va
operator|||
name|instr
operator|!=
name|MACH_BREAK_SSTEP
condition|)
block|{
name|i
operator|=
name|SIGTRAP
expr_stmt|;
break|break;
block|}
comment|/* restore original instruction and clear BP  */
name|i
operator|=
name|suiword
argument_list|(
operator|(
name|caddr_t
operator|)
name|va
argument_list|,
name|p
operator|->
name|p_md
operator|.
name|md_ss_instr
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
block|{
name|vm_offset_t
name|sa
decl_stmt|,
name|ea
decl_stmt|;
name|int
name|rv
decl_stmt|;
name|sa
operator|=
name|trunc_page
argument_list|(
operator|(
name|vm_offset_t
operator|)
name|va
argument_list|)
expr_stmt|;
name|ea
operator|=
name|round_page
argument_list|(
operator|(
name|vm_offset_t
operator|)
name|va
operator|+
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|rv
operator|=
name|vm_map_protect
argument_list|(
operator|&
name|p
operator|->
name|p_vmspace
operator|->
name|vm_map
argument_list|,
name|sa
argument_list|,
name|ea
argument_list|,
name|VM_PROT_DEFAULT
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|==
name|KERN_SUCCESS
condition|)
block|{
name|i
operator|=
name|suiword
argument_list|(
operator|(
name|caddr_t
operator|)
name|va
argument_list|,
name|p
operator|->
name|p_md
operator|.
name|md_ss_instr
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|vm_map_protect
argument_list|(
operator|&
name|p
operator|->
name|p_vmspace
operator|->
name|vm_map
argument_list|,
name|sa
argument_list|,
name|ea
argument_list|,
name|VM_PROT_READ
operator||
name|VM_PROT_EXECUTE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|i
operator|<
literal|0
condition|)
block|{
name|i
operator|=
name|SIGTRAP
expr_stmt|;
break|break;
block|}
name|p
operator|->
name|p_md
operator|.
name|md_ss_addr
operator|=
literal|0
expr_stmt|;
goto|goto
name|out
goto|;
block|}
case|case
name|T_RES_INST
operator|+
name|T_USER
case|:
name|i
operator|=
name|SIGILL
expr_stmt|;
break|break;
case|case
name|T_COP_UNUSABLE
operator|+
name|T_USER
case|:
if|if
condition|(
operator|(
name|causeReg
operator|&
name|MACH_CR_COP_ERR
operator|)
operator|!=
literal|0x10000000
condition|)
block|{
name|i
operator|=
name|SIGILL
expr_stmt|;
comment|/* only FPU instructions allowed */
break|break;
block|}
name|MachSwitchFPState
argument_list|(
name|machFPCurProcPtr
argument_list|,
name|p
operator|->
name|p_md
operator|.
name|md_regs
argument_list|)
expr_stmt|;
name|machFPCurProcPtr
operator|=
name|p
expr_stmt|;
name|p
operator|->
name|p_md
operator|.
name|md_regs
index|[
name|PS
index|]
operator||=
name|MACH_SR_COP_1_BIT
expr_stmt|;
name|p
operator|->
name|p_md
operator|.
name|md_flags
operator||=
name|MDP_FPUSED
expr_stmt|;
goto|goto
name|out
goto|;
case|case
name|T_OVFLOW
operator|+
name|T_USER
case|:
name|i
operator|=
name|SIGFPE
expr_stmt|;
break|break;
case|case
name|T_ADDR_ERR_LD
case|:
comment|/* misaligned access */
case|case
name|T_ADDR_ERR_ST
case|:
comment|/* misaligned access */
case|case
name|T_BUS_ERR_LD_ST
case|:
comment|/* BERR asserted to cpu */
if|if
condition|(
name|i
operator|=
operator|(
operator|(
expr|struct
name|pcb
operator|*
operator|)
name|UADDR
operator|)
operator|->
name|pcb_onfault
condition|)
block|{
operator|(
operator|(
expr|struct
name|pcb
operator|*
operator|)
name|UADDR
operator|)
operator|->
name|pcb_onfault
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|onfault_table
index|[
name|i
index|]
operator|)
return|;
block|}
comment|/* FALLTHROUGH */
default|default:
name|err
label|:
ifdef|#
directive|ifdef
name|KADB
block|{
specifier|extern
name|struct
name|pcb
name|kdbpcb
decl_stmt|;
if|if
condition|(
name|USERMODE
argument_list|(
name|statusReg
argument_list|)
condition|)
name|kdbpcb
operator|=
name|p
operator|->
name|p_addr
operator|->
name|u_pcb
expr_stmt|;
else|else
block|{
name|kdbpcb
operator|.
name|pcb_regs
index|[
name|ZERO
index|]
operator|=
literal|0
expr_stmt|;
name|kdbpcb
operator|.
name|pcb_regs
index|[
name|AST
index|]
operator|=
operator|(
operator|(
name|int
operator|*
operator|)
operator|&
name|args
operator|)
index|[
literal|2
index|]
expr_stmt|;
name|kdbpcb
operator|.
name|pcb_regs
index|[
name|V0
index|]
operator|=
operator|(
operator|(
name|int
operator|*
operator|)
operator|&
name|args
operator|)
index|[
literal|3
index|]
expr_stmt|;
name|kdbpcb
operator|.
name|pcb_regs
index|[
name|V1
index|]
operator|=
operator|(
operator|(
name|int
operator|*
operator|)
operator|&
name|args
operator|)
index|[
literal|4
index|]
expr_stmt|;
name|kdbpcb
operator|.
name|pcb_regs
index|[
name|A0
index|]
operator|=
operator|(
operator|(
name|int
operator|*
operator|)
operator|&
name|args
operator|)
index|[
literal|5
index|]
expr_stmt|;
name|kdbpcb
operator|.
name|pcb_regs
index|[
name|A1
index|]
operator|=
operator|(
operator|(
name|int
operator|*
operator|)
operator|&
name|args
operator|)
index|[
literal|6
index|]
expr_stmt|;
name|kdbpcb
operator|.
name|pcb_regs
index|[
name|A2
index|]
operator|=
operator|(
operator|(
name|int
operator|*
operator|)
operator|&
name|args
operator|)
index|[
literal|7
index|]
expr_stmt|;
name|kdbpcb
operator|.
name|pcb_regs
index|[
name|A3
index|]
operator|=
operator|(
operator|(
name|int
operator|*
operator|)
operator|&
name|args
operator|)
index|[
literal|8
index|]
expr_stmt|;
name|kdbpcb
operator|.
name|pcb_regs
index|[
name|T0
index|]
operator|=
operator|(
operator|(
name|int
operator|*
operator|)
operator|&
name|args
operator|)
index|[
literal|9
index|]
expr_stmt|;
name|kdbpcb
operator|.
name|pcb_regs
index|[
name|T1
index|]
operator|=
operator|(
operator|(
name|int
operator|*
operator|)
operator|&
name|args
operator|)
index|[
literal|10
index|]
expr_stmt|;
name|kdbpcb
operator|.
name|pcb_regs
index|[
name|T2
index|]
operator|=
operator|(
operator|(
name|int
operator|*
operator|)
operator|&
name|args
operator|)
index|[
literal|11
index|]
expr_stmt|;
name|kdbpcb
operator|.
name|pcb_regs
index|[
name|T3
index|]
operator|=
operator|(
operator|(
name|int
operator|*
operator|)
operator|&
name|args
operator|)
index|[
literal|12
index|]
expr_stmt|;
name|kdbpcb
operator|.
name|pcb_regs
index|[
name|T4
index|]
operator|=
operator|(
operator|(
name|int
operator|*
operator|)
operator|&
name|args
operator|)
index|[
literal|13
index|]
expr_stmt|;
name|kdbpcb
operator|.
name|pcb_regs
index|[
name|T5
index|]
operator|=
operator|(
operator|(
name|int
operator|*
operator|)
operator|&
name|args
operator|)
index|[
literal|14
index|]
expr_stmt|;
name|kdbpcb
operator|.
name|pcb_regs
index|[
name|T6
index|]
operator|=
operator|(
operator|(
name|int
operator|*
operator|)
operator|&
name|args
operator|)
index|[
literal|15
index|]
expr_stmt|;
name|kdbpcb
operator|.
name|pcb_regs
index|[
name|T7
index|]
operator|=
operator|(
operator|(
name|int
operator|*
operator|)
operator|&
name|args
operator|)
index|[
literal|16
index|]
expr_stmt|;
name|kdbpcb
operator|.
name|pcb_regs
index|[
name|T8
index|]
operator|=
operator|(
operator|(
name|int
operator|*
operator|)
operator|&
name|args
operator|)
index|[
literal|17
index|]
expr_stmt|;
name|kdbpcb
operator|.
name|pcb_regs
index|[
name|T9
index|]
operator|=
operator|(
operator|(
name|int
operator|*
operator|)
operator|&
name|args
operator|)
index|[
literal|18
index|]
expr_stmt|;
name|kdbpcb
operator|.
name|pcb_regs
index|[
name|RA
index|]
operator|=
operator|(
operator|(
name|int
operator|*
operator|)
operator|&
name|args
operator|)
index|[
literal|19
index|]
expr_stmt|;
name|kdbpcb
operator|.
name|pcb_regs
index|[
name|MULLO
index|]
operator|=
operator|(
operator|(
name|int
operator|*
operator|)
operator|&
name|args
operator|)
index|[
literal|21
index|]
expr_stmt|;
name|kdbpcb
operator|.
name|pcb_regs
index|[
name|MULHI
index|]
operator|=
operator|(
operator|(
name|int
operator|*
operator|)
operator|&
name|args
operator|)
index|[
literal|22
index|]
expr_stmt|;
name|kdbpcb
operator|.
name|pcb_regs
index|[
name|PC
index|]
operator|=
name|pc
expr_stmt|;
name|kdbpcb
operator|.
name|pcb_regs
index|[
name|SR
index|]
operator|=
name|statusReg
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|kdbpcb
operator|.
name|pcb_regs
index|[
name|F0
index|]
argument_list|,
literal|33
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|kdb
argument_list|(
name|causeReg
argument_list|,
name|vadr
argument_list|,
name|p
argument_list|,
operator|!
name|USERMODE
argument_list|(
name|statusReg
argument_list|)
argument_list|)
condition|)
return|return
operator|(
name|kdbpcb
operator|.
name|pcb_regs
index|[
name|PC
index|]
operator|)
return|;
block|}
else|#
directive|else
ifdef|#
directive|ifdef
name|DEBUG
name|printf
argument_list|(
literal|"trap: pid %d %s sig %d adr %x pc %x ra %x\n"
argument_list|,
name|p
operator|->
name|p_pid
argument_list|,
name|p
operator|->
name|p_comm
argument_list|,
name|i
argument_list|,
name|vadr
argument_list|,
name|pc
argument_list|,
name|p
operator|->
name|p_md
operator|.
name|md_regs
index|[
name|RA
index|]
argument_list|)
expr_stmt|;
comment|/* XXX */
name|trapDump
argument_list|(
literal|"trap"
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
name|panic
argument_list|(
literal|"trap"
argument_list|)
expr_stmt|;
block|}
name|trapsignal
argument_list|(
name|p
argument_list|,
name|i
argument_list|,
name|ucode
argument_list|)
expr_stmt|;
name|out
label|:
comment|/* 	 * Note: we should only get here if returning to user mode. 	 */
comment|/* take pending signals */
while|while
condition|(
operator|(
name|i
operator|=
name|CURSIG
argument_list|(
name|p
argument_list|)
operator|)
operator|!=
literal|0
condition|)
name|psig
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|p
operator|->
name|p_pri
operator|=
name|p
operator|->
name|p_usrpri
expr_stmt|;
name|astpending
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|want_resched
condition|)
block|{
name|int
name|s
decl_stmt|;
comment|/* 		 * Since we are curproc, clock will normally just change 		 * our priority without moving us from one queue to another 		 * (since the running process is not on a queue.) 		 * If that happened after we setrq ourselves but before we 		 * swtch()'ed, we might not be on the queue indicated by 		 * our priority. 		 */
name|s
operator|=
name|splstatclock
argument_list|()
expr_stmt|;
name|setrq
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|->
name|p_stats
operator|->
name|p_ru
operator|.
name|ru_nivcsw
operator|++
expr_stmt|;
name|swtch
argument_list|()
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|i
operator|=
name|CURSIG
argument_list|(
name|p
argument_list|)
operator|)
operator|!=
literal|0
condition|)
name|psig
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * If profiling, charge system time to the trapped pc. 	 */
if|if
condition|(
name|p
operator|->
name|p_flag
operator|&
name|SPROFIL
condition|)
block|{
specifier|extern
name|int
name|psratio
decl_stmt|;
name|addupc_task
argument_list|(
name|p
argument_list|,
name|pc
argument_list|,
call|(
name|int
call|)
argument_list|(
name|p
operator|->
name|p_sticks
operator|-
name|sticks
argument_list|)
operator|*
name|psratio
argument_list|)
expr_stmt|;
block|}
name|curpri
operator|=
name|p
operator|->
name|p_pri
expr_stmt|;
return|return
operator|(
name|pc
operator|)
return|;
block|}
end_function

begin_decl_stmt
name|int
name|badaddr_flag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Handle an interrupt.  * Called from MachKernIntr() or MachUserIntr()  * Note: curproc might be NULL.  */
end_comment

begin_macro
name|interrupt
argument_list|(
argument|statusReg
argument_list|,
argument|causeReg
argument_list|,
argument|pc
argument_list|)
end_macro

begin_decl_stmt
name|unsigned
name|statusReg
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* status register at time of the exception */
end_comment

begin_decl_stmt
name|unsigned
name|causeReg
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* cause register at time of exception */
end_comment

begin_decl_stmt
name|unsigned
name|pc
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* program counter where to continue */
end_comment

begin_block
block|{
specifier|register
name|unsigned
name|mask
decl_stmt|;
name|struct
name|clockframe
name|cf
decl_stmt|;
name|int
name|oonfault
init|=
operator|(
operator|(
expr|struct
name|pcb
operator|*
operator|)
name|UADDR
operator|)
operator|->
name|pcb_onfault
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|trp
operator|->
name|status
operator|=
name|statusReg
expr_stmt|;
name|trp
operator|->
name|cause
operator|=
name|causeReg
expr_stmt|;
name|trp
operator|->
name|vadr
operator|=
literal|0
expr_stmt|;
name|trp
operator|->
name|pc
operator|=
name|pc
expr_stmt|;
name|trp
operator|->
name|ra
operator|=
literal|0
expr_stmt|;
name|trp
operator|->
name|code
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|++
name|trp
operator|==
operator|&
name|trapdebug
index|[
name|TRAPSIZE
index|]
condition|)
name|trp
operator|=
name|trapdebug
expr_stmt|;
endif|#
directive|endif
name|mask
operator|=
name|causeReg
operator|&
name|statusReg
expr_stmt|;
comment|/* pending interrupts& enable mask */
if|if
condition|(
name|mask
operator|&
name|MACH_INT_MASK_5
condition|)
block|{
comment|/* level 5 interrupt */
name|splx
argument_list|(
operator|(
name|MACH_SPL_MASK_8
operator|&
operator|~
name|causeReg
operator|)
operator||
name|MACH_SR_INT_ENA_CUR
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"level 5 interrupt: PC %x CR %x SR %x\n"
argument_list|,
name|pc
argument_list|,
name|causeReg
argument_list|,
name|statusReg
argument_list|)
expr_stmt|;
name|causeReg
operator|&=
operator|~
name|MACH_INT_MASK_5
expr_stmt|;
block|}
if|if
condition|(
name|mask
operator|&
name|MACH_INT_MASK_4
condition|)
block|{
comment|/* level 4 interrupt */
comment|/* 		 * asynchronous bus error 		 */
name|splx
argument_list|(
operator|(
name|MACH_SPL_MASK_7
operator|&
operator|~
name|causeReg
operator|)
operator||
name|MACH_SR_INT_ENA_CUR
argument_list|)
expr_stmt|;
operator|*
operator|(
name|char
operator|*
operator|)
name|INTCLR0
operator|=
name|INTCLR0_BERR
expr_stmt|;
name|causeReg
operator|&=
operator|~
name|MACH_INT_MASK_4
expr_stmt|;
define|#
directive|define
name|BADADDR
value|1
if|if
condition|(
name|oonfault
operator|==
name|BADADDR
condition|)
block|{
comment|/* XXX */
name|badaddr_flag
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"level 4 interrupt: PC %x CR %x SR %x\n"
argument_list|,
name|pc
argument_list|,
name|causeReg
argument_list|,
name|statusReg
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|mask
operator|&
name|MACH_INT_MASK_3
condition|)
block|{
comment|/* level 3 interrupt */
comment|/* 		 * fp error 		 */
name|splx
argument_list|(
operator|(
name|MACH_SPL_MASK_6
operator|&
operator|~
name|causeReg
operator|)
operator||
name|MACH_SR_INT_ENA_CUR
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|USERMODE
argument_list|(
name|statusReg
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|trapDump
argument_list|(
literal|"fpintr"
argument_list|)
expr_stmt|;
else|#
directive|else
name|printf
argument_list|(
literal|"FPU interrupt: PC %x CR %x SR %x\n"
argument_list|,
name|pc
argument_list|,
name|causeReg
argument_list|,
name|statusReg
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
name|MachFPInterrupt
argument_list|(
name|statusReg
argument_list|,
name|causeReg
argument_list|,
name|pc
argument_list|)
expr_stmt|;
name|causeReg
operator|&=
operator|~
name|MACH_INT_MASK_3
expr_stmt|;
block|}
if|if
condition|(
name|mask
operator|&
name|MACH_INT_MASK_2
condition|)
block|{
comment|/* level 2 interrupt */
specifier|register
name|int
name|stat
decl_stmt|;
name|splx
argument_list|(
operator|(
name|MACH_SPL_MASK_5
operator|&
operator|~
name|causeReg
operator|)
operator||
name|MACH_SR_INT_ENA_CUR
argument_list|)
expr_stmt|;
name|stat
operator|=
operator|*
operator|(
specifier|volatile
name|u_char
operator|*
operator|)
name|INTST0
expr_stmt|;
if|if
condition|(
name|stat
operator|&
name|INTST0_TIMINT
condition|)
block|{
comment|/* timer */
specifier|static
name|int
name|led_count
init|=
literal|0
decl_stmt|;
operator|*
operator|(
specifier|volatile
name|u_char
operator|*
operator|)
name|INTCLR0
operator|=
name|INTCLR0_TIMINT
expr_stmt|;
name|cf
operator|.
name|pc
operator|=
name|pc
expr_stmt|;
name|cf
operator|.
name|sr
operator|=
name|statusReg
expr_stmt|;
name|hardclock
argument_list|(
operator|&
name|cf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|++
name|led_count
operator|>
name|hz
condition|)
block|{
name|led_count
operator|=
literal|0
expr_stmt|;
operator|*
operator|(
specifier|volatile
name|u_char
operator|*
operator|)
name|DEBUG_PORT
operator|^=
name|DP_LED1
expr_stmt|;
block|}
block|}
if|#
directive|if
name|NBM
operator|>
literal|0
if|if
condition|(
name|stat
operator|&
name|INTST0_KBDINT
condition|)
comment|/* keyboard */
name|kbm_rint
argument_list|(
name|SCC_KEYBOARD
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|NMS
operator|>
literal|0
if|if
condition|(
name|stat
operator|&
name|INTST0_MSINT
condition|)
comment|/* mouse */
name|kbm_rint
argument_list|(
name|SCC_MOUSE
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|causeReg
operator|&=
operator|~
name|MACH_INT_MASK_2
expr_stmt|;
block|}
if|if
condition|(
name|mask
operator|&
name|MACH_INT_MASK_1
condition|)
block|{
comment|/* level 1 interrupt */
name|splx
argument_list|(
operator|(
name|MACH_SPL_MASK_4
operator|&
operator|~
name|causeReg
operator|)
operator||
name|MACH_SR_INT_ENA_CUR
argument_list|)
expr_stmt|;
name|level1_intr
argument_list|()
expr_stmt|;
name|causeReg
operator|&=
operator|~
name|MACH_INT_MASK_1
expr_stmt|;
block|}
if|if
condition|(
name|mask
operator|&
name|MACH_INT_MASK_0
condition|)
block|{
comment|/* level 0 interrupt */
name|splx
argument_list|(
operator|(
name|MACH_SPL_MASK_3
operator|&
operator|~
name|causeReg
operator|)
operator||
name|MACH_SR_INT_ENA_CUR
argument_list|)
expr_stmt|;
name|level0_intr
argument_list|()
expr_stmt|;
name|causeReg
operator|&=
operator|~
name|MACH_INT_MASK_0
expr_stmt|;
block|}
name|splx
argument_list|(
operator|(
name|MACH_SPL_MASK_3
operator|&
operator|~
name|causeReg
operator|)
operator||
name|MACH_SR_INT_ENA_CUR
argument_list|)
expr_stmt|;
if|if
condition|(
name|mask
operator|&
name|MACH_SOFT_INT_MASK_0
condition|)
block|{
name|struct
name|clockframe
name|cf
decl_stmt|;
name|clearsoftclock
argument_list|()
expr_stmt|;
name|cnt
operator|.
name|v_soft
operator|++
expr_stmt|;
name|cf
operator|.
name|pc
operator|=
name|pc
expr_stmt|;
name|cf
operator|.
name|sr
operator|=
name|statusReg
expr_stmt|;
name|softclock
argument_list|()
expr_stmt|;
block|}
comment|/* process network interrupt if we trapped or will very soon */
if|if
condition|(
operator|(
name|mask
operator|&
name|MACH_SOFT_INT_MASK_1
operator|)
operator|||
name|netisr
operator|&&
operator|(
name|statusReg
operator|&
name|MACH_SOFT_INT_MASK_1
operator|)
condition|)
block|{
name|clearsoftnet
argument_list|()
expr_stmt|;
name|cnt
operator|.
name|v_soft
operator|++
expr_stmt|;
ifdef|#
directive|ifdef
name|INET
if|if
condition|(
name|netisr
operator|&
operator|(
literal|1
operator|<<
name|NETISR_ARP
operator|)
condition|)
block|{
name|netisr
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|NETISR_ARP
operator|)
expr_stmt|;
name|arpintr
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|netisr
operator|&
operator|(
literal|1
operator|<<
name|NETISR_IP
operator|)
condition|)
block|{
name|netisr
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|NETISR_IP
operator|)
expr_stmt|;
name|ipintr
argument_list|()
expr_stmt|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|NS
if|if
condition|(
name|netisr
operator|&
operator|(
literal|1
operator|<<
name|NETISR_NS
operator|)
condition|)
block|{
name|netisr
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|NETISR_NS
operator|)
expr_stmt|;
name|nsintr
argument_list|()
expr_stmt|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ISO
if|if
condition|(
name|netisr
operator|&
operator|(
literal|1
operator|<<
name|NETISR_ISO
operator|)
condition|)
block|{
name|netisr
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|NETISR_ISO
operator|)
expr_stmt|;
name|clnlintr
argument_list|()
expr_stmt|;
block|}
endif|#
directive|endif
block|}
comment|/* restore onfault flag */
operator|(
operator|(
expr|struct
name|pcb
operator|*
operator|)
name|UADDR
operator|)
operator|->
name|pcb_onfault
operator|=
name|oonfault
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * This is called from MachUserIntr() if astpending is set.  * This is very similar to the tail of trap().  */
end_comment

begin_macro
name|softintr
argument_list|(
argument|statusReg
argument_list|,
argument|pc
argument_list|)
end_macro

begin_decl_stmt
name|unsigned
name|statusReg
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* status register at time of the exception */
end_comment

begin_decl_stmt
name|unsigned
name|pc
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* program counter where to continue */
end_comment

begin_block
block|{
specifier|register
name|struct
name|proc
modifier|*
name|p
init|=
name|curproc
decl_stmt|;
name|int
name|sig
decl_stmt|;
name|cnt
operator|.
name|v_soft
operator|++
expr_stmt|;
comment|/* take pending signals */
while|while
condition|(
operator|(
name|sig
operator|=
name|CURSIG
argument_list|(
name|p
argument_list|)
operator|)
operator|!=
literal|0
condition|)
name|psig
argument_list|(
name|sig
argument_list|)
expr_stmt|;
name|p
operator|->
name|p_pri
operator|=
name|p
operator|->
name|p_usrpri
expr_stmt|;
name|astpending
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|p_flag
operator|&
name|SOWEUPC
condition|)
block|{
name|p
operator|->
name|p_flag
operator|&=
operator|~
name|SOWEUPC
expr_stmt|;
name|ADDUPROF
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|want_resched
condition|)
block|{
name|int
name|s
decl_stmt|;
comment|/* 		 * Since we are curproc, clock will normally just change 		 * our priority without moving us from one queue to another 		 * (since the running process is not on a queue.) 		 * If that happened after we setrq ourselves but before we 		 * swtch()'ed, we might not be on the queue indicated by 		 * our priority. 		 */
name|s
operator|=
name|splstatclock
argument_list|()
expr_stmt|;
name|setrq
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|->
name|p_stats
operator|->
name|p_ru
operator|.
name|ru_nivcsw
operator|++
expr_stmt|;
name|swtch
argument_list|()
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|sig
operator|=
name|CURSIG
argument_list|(
name|p
argument_list|)
operator|)
operator|!=
literal|0
condition|)
name|psig
argument_list|(
name|sig
argument_list|)
expr_stmt|;
block|}
name|curpri
operator|=
name|p
operator|->
name|p_pri
expr_stmt|;
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_macro
name|trapDump
argument_list|(
argument|msg
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|msg
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|int
name|s
decl_stmt|;
name|s
operator|=
name|splhigh
argument_list|()
expr_stmt|;
name|printf
argument_list|(
literal|"trapDump(%s)\n"
argument_list|,
name|msg
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TRAPSIZE
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|trp
operator|==
name|trapdebug
condition|)
name|trp
operator|=
operator|&
name|trapdebug
index|[
name|TRAPSIZE
operator|-
literal|1
index|]
expr_stmt|;
else|else
name|trp
operator|--
expr_stmt|;
if|if
condition|(
name|trp
operator|->
name|cause
operator|==
literal|0
condition|)
break|break;
name|printf
argument_list|(
literal|"%s: ADR %x PC %x CR %x SR %x\n"
argument_list|,
name|trap_type
index|[
operator|(
name|trp
operator|->
name|cause
operator|&
name|MACH_CR_EXC_CODE
operator|)
operator|>>
name|MACH_CR_EXC_CODE_SHIFT
index|]
argument_list|,
name|trp
operator|->
name|vadr
argument_list|,
name|trp
operator|->
name|pc
argument_list|,
name|trp
operator|->
name|cause
argument_list|,
name|trp
operator|->
name|status
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"   RA %x code %d\n"
argument_list|,
name|trp
operator|->
name|ra
argument_list|,
name|trp
operator|->
name|code
argument_list|)
expr_stmt|;
block|}
name|bzero
argument_list|(
name|trapdebug
argument_list|,
sizeof|sizeof
argument_list|(
name|trapdebug
argument_list|)
argument_list|)
expr_stmt|;
name|trp
operator|=
name|trapdebug
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Return the resulting PC as if the branch was executed.  */
end_comment

begin_function
name|unsigned
name|MachEmulateBranch
parameter_list|(
name|regsPtr
parameter_list|,
name|instPC
parameter_list|,
name|fpcCSR
parameter_list|,
name|allowNonBranch
parameter_list|)
name|unsigned
modifier|*
name|regsPtr
decl_stmt|;
name|unsigned
name|instPC
decl_stmt|;
name|unsigned
name|fpcCSR
decl_stmt|;
name|int
name|allowNonBranch
decl_stmt|;
block|{
name|InstFmt
name|inst
decl_stmt|;
name|unsigned
name|retAddr
decl_stmt|;
name|int
name|condition
decl_stmt|;
specifier|extern
name|unsigned
name|GetBranchDest
parameter_list|()
function_decl|;
if|#
directive|if
literal|0
block|printf("regsPtr=%x PC=%x Inst=%x fpcCsr=%x\n", regsPtr, instPC, 		*(unsigned *)instPC, fpcCSR);
endif|#
directive|endif
name|inst
operator|=
operator|*
operator|(
name|InstFmt
operator|*
operator|)
name|instPC
expr_stmt|;
switch|switch
condition|(
operator|(
name|int
operator|)
name|inst
operator|.
name|JType
operator|.
name|op
condition|)
block|{
case|case
name|OP_SPECIAL
case|:
switch|switch
condition|(
operator|(
name|int
operator|)
name|inst
operator|.
name|RType
operator|.
name|func
condition|)
block|{
case|case
name|OP_JR
case|:
case|case
name|OP_JALR
case|:
name|retAddr
operator|=
name|regsPtr
index|[
name|inst
operator|.
name|RType
operator|.
name|rs
index|]
expr_stmt|;
break|break;
default|default:
if|if
condition|(
operator|!
name|allowNonBranch
condition|)
name|panic
argument_list|(
literal|"MachEmulateBranch: Non-branch"
argument_list|)
expr_stmt|;
name|retAddr
operator|=
name|instPC
operator|+
literal|4
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|OP_BCOND
case|:
switch|switch
condition|(
operator|(
name|int
operator|)
name|inst
operator|.
name|IType
operator|.
name|rt
condition|)
block|{
case|case
name|OP_BLTZ
case|:
case|case
name|OP_BLTZAL
case|:
if|if
condition|(
call|(
name|int
call|)
argument_list|(
name|regsPtr
index|[
name|inst
operator|.
name|RType
operator|.
name|rs
index|]
argument_list|)
operator|<
literal|0
condition|)
name|retAddr
operator|=
name|GetBranchDest
argument_list|(
operator|(
name|InstFmt
operator|*
operator|)
name|instPC
argument_list|)
expr_stmt|;
else|else
name|retAddr
operator|=
name|instPC
operator|+
literal|8
expr_stmt|;
break|break;
case|case
name|OP_BGEZAL
case|:
case|case
name|OP_BGEZ
case|:
if|if
condition|(
call|(
name|int
call|)
argument_list|(
name|regsPtr
index|[
name|inst
operator|.
name|RType
operator|.
name|rs
index|]
argument_list|)
operator|>=
literal|0
condition|)
name|retAddr
operator|=
name|GetBranchDest
argument_list|(
operator|(
name|InstFmt
operator|*
operator|)
name|instPC
argument_list|)
expr_stmt|;
else|else
name|retAddr
operator|=
name|instPC
operator|+
literal|8
expr_stmt|;
break|break;
default|default:
name|panic
argument_list|(
literal|"MachEmulateBranch: Bad branch cond"
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|OP_J
case|:
case|case
name|OP_JAL
case|:
name|retAddr
operator|=
operator|(
name|inst
operator|.
name|JType
operator|.
name|target
operator|<<
literal|2
operator|)
operator||
operator|(
operator|(
name|unsigned
operator|)
name|instPC
operator|&
literal|0xF0000000
operator|)
expr_stmt|;
break|break;
case|case
name|OP_BEQ
case|:
if|if
condition|(
name|regsPtr
index|[
name|inst
operator|.
name|RType
operator|.
name|rs
index|]
operator|==
name|regsPtr
index|[
name|inst
operator|.
name|RType
operator|.
name|rt
index|]
condition|)
name|retAddr
operator|=
name|GetBranchDest
argument_list|(
operator|(
name|InstFmt
operator|*
operator|)
name|instPC
argument_list|)
expr_stmt|;
else|else
name|retAddr
operator|=
name|instPC
operator|+
literal|8
expr_stmt|;
break|break;
case|case
name|OP_BNE
case|:
if|if
condition|(
name|regsPtr
index|[
name|inst
operator|.
name|RType
operator|.
name|rs
index|]
operator|!=
name|regsPtr
index|[
name|inst
operator|.
name|RType
operator|.
name|rt
index|]
condition|)
name|retAddr
operator|=
name|GetBranchDest
argument_list|(
operator|(
name|InstFmt
operator|*
operator|)
name|instPC
argument_list|)
expr_stmt|;
else|else
name|retAddr
operator|=
name|instPC
operator|+
literal|8
expr_stmt|;
break|break;
case|case
name|OP_BLEZ
case|:
if|if
condition|(
call|(
name|int
call|)
argument_list|(
name|regsPtr
index|[
name|inst
operator|.
name|RType
operator|.
name|rs
index|]
argument_list|)
operator|<=
literal|0
condition|)
name|retAddr
operator|=
name|GetBranchDest
argument_list|(
operator|(
name|InstFmt
operator|*
operator|)
name|instPC
argument_list|)
expr_stmt|;
else|else
name|retAddr
operator|=
name|instPC
operator|+
literal|8
expr_stmt|;
break|break;
case|case
name|OP_BGTZ
case|:
if|if
condition|(
call|(
name|int
call|)
argument_list|(
name|regsPtr
index|[
name|inst
operator|.
name|RType
operator|.
name|rs
index|]
argument_list|)
operator|>
literal|0
condition|)
name|retAddr
operator|=
name|GetBranchDest
argument_list|(
operator|(
name|InstFmt
operator|*
operator|)
name|instPC
argument_list|)
expr_stmt|;
else|else
name|retAddr
operator|=
name|instPC
operator|+
literal|8
expr_stmt|;
break|break;
case|case
name|OP_COP1
case|:
switch|switch
condition|(
name|inst
operator|.
name|RType
operator|.
name|rs
condition|)
block|{
case|case
name|OP_BCx
case|:
case|case
name|OP_BCy
case|:
if|if
condition|(
operator|(
name|inst
operator|.
name|RType
operator|.
name|rt
operator|&
name|COPz_BC_TF_MASK
operator|)
operator|==
name|COPz_BC_TRUE
condition|)
name|condition
operator|=
name|fpcCSR
operator|&
name|MACH_FPC_COND_BIT
expr_stmt|;
else|else
name|condition
operator|=
operator|!
operator|(
name|fpcCSR
operator|&
name|MACH_FPC_COND_BIT
operator|)
expr_stmt|;
if|if
condition|(
name|condition
condition|)
name|retAddr
operator|=
name|GetBranchDest
argument_list|(
operator|(
name|InstFmt
operator|*
operator|)
name|instPC
argument_list|)
expr_stmt|;
else|else
name|retAddr
operator|=
name|instPC
operator|+
literal|8
expr_stmt|;
break|break;
default|default:
if|if
condition|(
operator|!
name|allowNonBranch
condition|)
name|panic
argument_list|(
literal|"MachEmulateBranch: Bad coproc branch instruction"
argument_list|)
expr_stmt|;
name|retAddr
operator|=
name|instPC
operator|+
literal|4
expr_stmt|;
block|}
break|break;
default|default:
if|if
condition|(
operator|!
name|allowNonBranch
condition|)
name|panic
argument_list|(
literal|"MachEmulateBranch: Non-branch instruction"
argument_list|)
expr_stmt|;
name|retAddr
operator|=
name|instPC
operator|+
literal|4
expr_stmt|;
block|}
if|#
directive|if
literal|0
block|printf("Target addr=%x\n", retAddr);
endif|#
directive|endif
return|return
operator|(
name|retAddr
operator|)
return|;
block|}
end_function

begin_function
name|unsigned
name|GetBranchDest
parameter_list|(
name|InstPtr
parameter_list|)
name|InstFmt
modifier|*
name|InstPtr
decl_stmt|;
block|{
return|return
operator|(
operator|(
name|unsigned
operator|)
name|InstPtr
operator|+
literal|4
operator|+
operator|(
operator|(
name|short
operator|)
name|InstPtr
operator|->
name|IType
operator|.
name|imm
operator|<<
literal|2
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * This routine is called by procxmt() to single step one instruction.  * We do this by storing a break instruction after the current instruction,  * resuming execution, and then restoring the old instruction.  */
end_comment

begin_expr_stmt
name|cpu_singlestep
argument_list|(
name|p
argument_list|)
specifier|register
expr|struct
name|proc
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|unsigned
name|va
decl_stmt|;
specifier|register
name|int
modifier|*
name|locr0
init|=
name|p
operator|->
name|p_md
operator|.
name|md_regs
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* compute next address after current location */
name|va
operator|=
name|MachEmulateBranch
argument_list|(
name|locr0
argument_list|,
name|locr0
index|[
name|PC
index|]
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|p_md
operator|.
name|md_ss_addr
operator|||
name|p
operator|->
name|p_md
operator|.
name|md_ss_addr
operator|==
name|va
operator|||
operator|!
name|useracc
argument_list|(
operator|(
name|caddr_t
operator|)
name|va
argument_list|,
literal|4
argument_list|,
name|B_READ
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"SS %s (%d): breakpoint already set at %x (va %x)\n"
argument_list|,
name|p
operator|->
name|p_comm
argument_list|,
name|p
operator|->
name|p_pid
argument_list|,
name|p
operator|->
name|p_md
operator|.
name|md_ss_addr
argument_list|,
name|va
argument_list|)
expr_stmt|;
comment|/* XXX */
return|return
operator|(
name|EFAULT
operator|)
return|;
block|}
name|p
operator|->
name|p_md
operator|.
name|md_ss_addr
operator|=
name|va
expr_stmt|;
name|p
operator|->
name|p_md
operator|.
name|md_ss_instr
operator|=
name|fuiword
argument_list|(
operator|(
name|caddr_t
operator|)
name|va
argument_list|)
expr_stmt|;
name|i
operator|=
name|suiword
argument_list|(
operator|(
name|caddr_t
operator|)
name|va
argument_list|,
name|MACH_BREAK_SSTEP
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
block|{
name|vm_offset_t
name|sa
decl_stmt|,
name|ea
decl_stmt|;
name|int
name|rv
decl_stmt|;
name|sa
operator|=
name|trunc_page
argument_list|(
operator|(
name|vm_offset_t
operator|)
name|va
argument_list|)
expr_stmt|;
name|ea
operator|=
name|round_page
argument_list|(
operator|(
name|vm_offset_t
operator|)
name|va
operator|+
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|rv
operator|=
name|vm_map_protect
argument_list|(
operator|&
name|p
operator|->
name|p_vmspace
operator|->
name|vm_map
argument_list|,
name|sa
argument_list|,
name|ea
argument_list|,
name|VM_PROT_DEFAULT
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|==
name|KERN_SUCCESS
condition|)
block|{
name|i
operator|=
name|suiword
argument_list|(
operator|(
name|caddr_t
operator|)
name|va
argument_list|,
name|MACH_BREAK_SSTEP
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|vm_map_protect
argument_list|(
operator|&
name|p
operator|->
name|p_vmspace
operator|->
name|vm_map
argument_list|,
name|sa
argument_list|,
name|ea
argument_list|,
name|VM_PROT_READ
operator||
name|VM_PROT_EXECUTE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|i
operator|<
literal|0
condition|)
return|return
operator|(
name|EFAULT
operator|)
return|;
name|printf
argument_list|(
literal|"SS %s (%d): breakpoint set at %x: %x (pc %x)\n"
argument_list|,
name|p
operator|->
name|p_comm
argument_list|,
name|p
operator|->
name|p_pid
argument_list|,
name|p
operator|->
name|p_md
operator|.
name|md_ss_addr
argument_list|,
name|p
operator|->
name|p_md
operator|.
name|md_ss_instr
argument_list|,
name|locr0
index|[
name|PC
index|]
argument_list|)
expr_stmt|;
comment|/* XXX */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * news3400 - INT0 service routine.  *  * INTST0 bit	4:	dma  *		3:	slot #1  *		2:	slot #3  *		1:	external #1  *		0:	external #3  */
end_comment

begin_define
define|#
directive|define
name|LEVEL0_MASK
define|\
value|(INTST1_DMA|INTST1_SLOT1|INTST1_SLOT3|INTST1_EXT1|INTST1_EXT3)
end_define

begin_macro
name|level0_intr
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|stat
decl_stmt|;
name|stat
operator|=
operator|*
operator|(
specifier|volatile
name|u_char
operator|*
operator|)
name|INTST1
operator|&
name|LEVEL0_MASK
expr_stmt|;
operator|*
operator|(
name|u_char
operator|*
operator|)
name|INTCLR1
operator|=
name|stat
expr_stmt|;
if|if
condition|(
name|stat
operator|&
name|INTST1_DMA
condition|)
name|dma_intr
argument_list|()
expr_stmt|;
if|if
condition|(
name|stat
operator|&
name|INTST1_SLOT1
condition|)
name|exec_hb_intr2
argument_list|()
expr_stmt|;
if|#
directive|if
name|NEN
operator|>
literal|0
if|if
condition|(
name|stat
operator|&
name|INTST1_SLOT3
condition|)
block|{
name|int
name|s
decl_stmt|,
name|t
decl_stmt|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|t
operator|=
name|lance_intr
argument_list|()
expr_stmt|;
operator|(
name|void
operator|)
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|==
literal|0
condition|)
name|exec_hb_intr4
argument_list|()
expr_stmt|;
block|}
endif|#
directive|endif
if|#
directive|if
name|NLE
operator|>
literal|0
if|if
condition|(
name|stat
operator|&
name|INTST1_SLOT3
condition|)
block|{
name|int
name|s
decl_stmt|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|leintr
argument_list|(
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|stat
operator|&
name|INTST1_EXT1
condition|)
name|print_int_stat
argument_list|(
literal|"EXT #1"
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat
operator|&
name|INTST1_EXT3
condition|)
name|print_int_stat
argument_list|(
literal|"EXT #3"
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * news3400 - INT1 service routine.  *  * INTST0 bit	1:	centro fault  *		0:	centro busy  * INTST1 bit	7:	beep  *		6:	scc  *		5:	lance  */
end_comment

begin_define
define|#
directive|define
name|LEVEL1_MASK2
value|(INTST0_CFLT|INTST0_CBSY)
end_define

begin_define
define|#
directive|define
name|LEVEL1_MASK1
value|(INTST1_BEEP|INTST1_SCC|INTST1_LANCE)
end_define

begin_macro
name|level1_intr
argument_list|(
argument|pc
argument_list|)
end_macro

begin_decl_stmt
name|unsigned
name|pc
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|stat
decl_stmt|;
specifier|register
name|u_int
name|saved_inten1
init|=
operator|*
operator|(
name|u_char
operator|*
operator|)
name|INTEN1
decl_stmt|;
operator|*
operator|(
name|u_char
operator|*
operator|)
name|INTEN1
operator|=
literal|0
expr_stmt|;
comment|/* disable intr: beep, lance, scc */
name|stat
operator|=
operator|*
operator|(
specifier|volatile
name|u_char
operator|*
operator|)
name|INTST1
operator|&
name|LEVEL1_MASK1
expr_stmt|;
operator|*
operator|(
name|u_char
operator|*
operator|)
name|INTCLR1
operator|=
name|stat
expr_stmt|;
name|stat
operator|&=
name|saved_inten1
expr_stmt|;
if|if
condition|(
name|stat
operator|&
name|INTST1_BEEP
condition|)
block|{
operator|*
operator|(
specifier|volatile
name|u_char
operator|*
operator|)
name|INTCLR1
operator|=
name|INTCLR1_BEEP
expr_stmt|;
name|print_int_stat
argument_list|(
literal|"BEEP"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|stat
operator|&
name|INTST1_SCC
condition|)
block|{
name|scc_intr
argument_list|()
expr_stmt|;
if|if
condition|(
name|saved_inten1
operator|&
operator|*
operator|(
name|u_char
operator|*
operator|)
name|INTST1
operator|&
name|INTST1_SCC
condition|)
name|scc_intr
argument_list|()
expr_stmt|;
block|}
if|#
directive|if
name|NEN
operator|>
literal|0
if|if
condition|(
name|stat
operator|&
name|INTST1_LANCE
condition|)
name|lance_intr
argument_list|()
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|NLE
operator|>
literal|0
if|if
condition|(
name|stat
operator|&
name|INTST1_LANCE
condition|)
name|leintr
argument_list|(
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|*
operator|(
name|u_char
operator|*
operator|)
name|INTEN1
operator|=
name|saved_inten1
expr_stmt|;
if|#
directive|if
name|NLP
operator|>
literal|0
comment|/* 	 * The PARK2 cannot find centro interrupt correctly. 	 * We must check it by reading the cause register of cpu 	 * while other interrupts are disabled. 	 */
block|{
specifier|register
name|int
name|causereg
decl_stmt|;
name|int
name|s
init|=
name|splhigh
argument_list|()
decl_stmt|;
name|causereg
operator|=
name|get_causereg
argument_list|()
expr_stmt|;
operator|(
name|void
operator|)
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|causereg
operator|&
name|CAUSE_IP4
operator|)
operator|==
literal|0
condition|)
return|return;
block|}
endif|#
directive|endif
name|stat
operator|=
call|(
name|int
call|)
argument_list|(
operator|*
operator|(
name|u_char
operator|*
operator|)
name|INTST0
argument_list|)
operator|&
name|LEVEL1_MASK2
expr_stmt|;
operator|*
operator|(
name|u_char
operator|*
operator|)
name|INTCLR0
operator|=
name|stat
expr_stmt|;
if|if
condition|(
name|stat
operator|&
name|INTST0_CBSY
condition|)
comment|/* centro busy */
if|#
directive|if
name|NLP
operator|>
literal|0
name|lpxint
argument_list|(
literal|0
argument_list|)
expr_stmt|;
else|#
directive|else
name|printf
argument_list|(
literal|"stray intr: CBSY\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_block

begin_comment
comment|/*  * DMA interrupt service routine.  */
end_comment

begin_macro
name|dma_intr
argument_list|()
end_macro

begin_block
block|{
specifier|register
specifier|volatile
name|u_char
modifier|*
name|gsp
init|=
operator|(
name|u_char
operator|*
operator|)
name|DMAC_GSTAT
decl_stmt|;
specifier|register
name|u_int
name|gstat
init|=
operator|*
name|gsp
decl_stmt|;
specifier|register
name|int
name|mrqb
decl_stmt|,
name|i
decl_stmt|;
comment|/* 	 * when DMA intrrupt occurs there remain some untransferred data. 	 * wait data transfer completion. 	 */
name|mrqb
operator|=
operator|(
name|gstat
operator|&
operator|(
name|CH0_INT
operator||
name|CH1_INT
operator||
name|CH2_INT
operator||
name|CH3_INT
operator|)
operator|)
operator|<<
literal|1
expr_stmt|;
if|if
condition|(
name|gstat
operator|&
name|mrqb
condition|)
block|{
comment|/* 		 * SHOULD USE DELAY() 		 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|50
condition|;
name|i
operator|++
control|)
empty_stmt|;
if|if
condition|(
operator|*
name|gsp
operator|&
name|mrqb
condition|)
name|printf
argument_list|(
literal|"dma_intr: MRQ\n"
argument_list|)
expr_stmt|;
block|}
comment|/* SCSI Dispatch */
if|if
condition|(
name|gstat
operator|&
name|CH_INT
argument_list|(
name|CH_SCSI
argument_list|)
condition|)
name|scintr
argument_list|()
expr_stmt|;
include|#
directive|include
file|"fd.h"
if|#
directive|if
name|NFD
operator|>
literal|0
comment|/* FDC Interrupt Dispatch */
if|if
condition|(
name|gstat
operator|&
name|CH_INT
argument_list|(
name|CH_FDC
argument_list|)
condition|)
name|fdc_intr
argument_list|(
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* NFD> 0 */
include|#
directive|include
file|"sb.h"
if|#
directive|if
name|NSB
operator|>
literal|0
comment|/* Audio Interface Dispatch */
name|sbintr
argument_list|(
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* NSB> 0 */
comment|/* Video I/F Dispatch */
if|if
condition|(
name|gstat
operator|&
name|CH_INT
argument_list|(
name|CH_VIDEO
argument_list|)
condition|)
empty_stmt|;
block|}
end_block

begin_comment
comment|/*  * SCC vector interrupt service routine.  */
end_comment

begin_macro
name|scc_intr
argument_list|()
end_macro

begin_block
block|{
name|int
name|vec
decl_stmt|;
specifier|extern
name|int
name|scc_xint
argument_list|()
decl_stmt|,
name|scc_sint
argument_list|()
decl_stmt|,
name|scc_rint
argument_list|()
decl_stmt|,
name|scc_cint
argument_list|()
decl_stmt|;
specifier|static
name|int
function_decl|(
modifier|*
name|func
index|[]
function_decl|)
parameter_list|()
init|=
block|{
name|scc_xint
operator|,
function_decl|scc_sint
operator|,
function_decl|scc_rint
operator|,
function_decl|scc_cint
block|}
end_block

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_expr_stmt
name|vec
operator|=
operator|*
operator|(
specifier|volatile
name|u_char
operator|*
operator|)
name|SCCVECT
expr_stmt|;
end_expr_stmt

begin_expr_stmt
call|(
modifier|*
name|func
index|[
operator|(
name|vec
operator|&
name|SCC_INT_MASK
operator|)
operator|>>
literal|1
index|]
call|)
argument_list|(
name|vec
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
unit|}  print_int_stat
operator|(
name|msg
operator|)
name|char
operator|*
name|msg
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|int
name|s0
init|=
operator|*
operator|(
specifier|volatile
name|u_char
operator|*
operator|)
name|INTST0
decl_stmt|;
name|int
name|s1
init|=
operator|*
operator|(
specifier|volatile
name|u_char
operator|*
operator|)
name|INTST1
decl_stmt|;
if|if
condition|(
name|msg
condition|)
name|printf
argument_list|(
literal|"%s: "
argument_list|,
name|msg
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"intr: "
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"INTST0=0x%x, INTST1=0x%x.\n"
argument_list|,
name|s0
argument_list|,
name|s1
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|traceback
argument_list|()
end_macro

begin_block
block|{
name|u_int
name|pc
decl_stmt|,
name|sp
decl_stmt|;
name|getpcsp
argument_list|(
operator|&
name|pc
argument_list|,
operator|&
name|sp
argument_list|)
expr_stmt|;
name|backtr
argument_list|(
name|pc
argument_list|,
name|sp
argument_list|)
expr_stmt|;
block|}
end_block

begin_define
define|#
directive|define
name|EF_RA
value|92
end_define

begin_comment
comment|/* r31: return address */
end_comment

begin_define
define|#
directive|define
name|KERN_REG_SIZE
value|(18 * 4)
end_define

begin_define
define|#
directive|define
name|STAND_FRAME_SIZE
value|24
end_define

begin_define
define|#
directive|define
name|EF_SIZE
value|STAND_FRAME_SIZE + KERN_REG_SIZE + 12
end_define

begin_decl_stmt
specifier|extern
name|u_int
name|MachKernGenExceptionEnd
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|u_int
name|end
index|[]
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|ENDOFTXT
value|(end + 1)
end_define

begin_define
define|#
directive|define
name|VALID_TEXT
parameter_list|(
name|pc
parameter_list|)
define|\
value|((u_int *)MACH_CODE_START<= (u_int *)MACH_UNCACHED_TO_CACHED(pc)&& \ 	 (u_int *)MACH_UNCACHED_TO_CACHED(pc)<= (u_int *)ENDOFTXT)
end_define

begin_define
define|#
directive|define
name|ExceptionHandler
parameter_list|(
name|x
parameter_list|)
define|\
value|((u_int*)MachKernGenException< (u_int*)MACH_UNCACHED_TO_CACHED(x)&& \ 	 (u_int*)MACH_UNCACHED_TO_CACHED(x)< (u_int*)MachKernGenExceptionEnd)
end_define

begin_expr_stmt
name|backtr
argument_list|(
name|pc
argument_list|,
name|sp
argument_list|)
specifier|register
name|u_int
operator|*
name|pc
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|caddr_t
name|sp
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|fsize
decl_stmt|;
name|u_int
modifier|*
name|getra
parameter_list|()
function_decl|;
specifier|extern
name|int
name|_gp
index|[]
decl_stmt|;
name|printf
argument_list|(
literal|"start trace back pc=%x, sp=%x, pid=%d[%s]\n"
argument_list|,
name|pc
argument_list|,
name|sp
argument_list|,
name|curproc
operator|->
name|p_pid
argument_list|,
name|curproc
operator|->
name|p_comm
argument_list|)
expr_stmt|;
while|while
condition|(
name|VALID_TEXT
argument_list|(
name|pc
argument_list|)
condition|)
block|{
if|if
condition|(
name|sp
operator|>=
operator|(
name|caddr_t
operator|)
name|KERNELSTACK
operator|||
name|sp
operator|<
operator|(
name|caddr_t
operator|)
name|UADDR
condition|)
block|{
name|printf
argument_list|(
literal|"stack exhausted (sp=0x%x)\n"
argument_list|,
name|sp
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|ExceptionHandler
argument_list|(
name|pc
argument_list|)
condition|)
block|{
name|pc
operator|=
operator|(
name|u_int
operator|*
operator|)
operator|(
operator|*
operator|(
operator|(
name|u_int
operator|*
operator|)
operator|&
name|sp
index|[
name|EF_RA
index|]
operator|)
operator|)
expr_stmt|;
name|sp
operator|+=
name|EF_SIZE
expr_stmt|;
name|printf
argument_list|(
literal|"trapped from pc=%x, sp=%x\n"
argument_list|,
name|pc
argument_list|,
name|sp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|pc
operator|=
name|getra
argument_list|(
name|pc
argument_list|,
name|sp
argument_list|,
operator|&
name|fsize
argument_list|)
expr_stmt|;
name|sp
operator|+=
name|fsize
expr_stmt|;
name|printf
argument_list|(
literal|"called from pc=%x, sp=%x\n"
argument_list|,
name|pc
argument_list|,
name|sp
argument_list|)
expr_stmt|;
block|}
block|}
name|printf
argument_list|(
literal|"trace back END. pid=%d[%s]\n"
argument_list|,
name|curproc
operator|->
name|p_pid
argument_list|,
name|curproc
operator|->
name|p_comm
argument_list|)
expr_stmt|;
block|}
end_block

begin_define
define|#
directive|define
name|NPCSTOCK
value|128
end_define

begin_function
name|u_int
modifier|*
name|getra
parameter_list|(
name|pc
parameter_list|,
name|sp
parameter_list|,
name|fsize
parameter_list|)
specifier|register
name|int
modifier|*
name|pc
decl_stmt|;
specifier|register
name|caddr_t
name|sp
decl_stmt|;
name|int
modifier|*
name|fsize
decl_stmt|;
block|{
name|u_int
name|regs
index|[
literal|32
index|]
decl_stmt|;
name|int
modifier|*
name|opcs
index|[
name|NPCSTOCK
index|]
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|,
name|nbpc
init|=
literal|0
decl_stmt|;
name|int
name|printed
init|=
literal|0
decl_stmt|;
name|InstFmt
name|I
decl_stmt|;
operator|*
name|fsize
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|32
condition|;
name|i
operator|++
control|)
name|regs
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
operator|(
name|u_int
operator|*
operator|)
name|MACH_UNCACHED_TO_CACHED
argument_list|(
name|pc
argument_list|)
operator|<
operator|(
name|u_int
operator|*
operator|)
name|ENDOFTXT
condition|;
name|pc
operator|++
control|)
block|{
name|I
operator|.
name|word
operator|=
operator|*
name|pc
expr_stmt|;
switch|switch
condition|(
name|I
operator|.
name|IType
operator|.
name|op
condition|)
block|{
case|case
name|OP_ADDIU
case|:
comment|/* sp += fsize */
if|if
condition|(
name|I
operator|.
name|IType
operator|.
name|rs
operator|==
name|SP
operator|&&
name|I
operator|.
name|IType
operator|.
name|rt
operator|==
name|SP
condition|)
operator|*
name|fsize
operator|=
operator|(
name|u_short
operator|)
name|I
operator|.
name|IType
operator|.
name|imm
expr_stmt|;
break|break;
case|case
name|OP_LW
case|:
if|if
condition|(
name|I
operator|.
name|IType
operator|.
name|rs
operator|!=
name|SP
condition|)
break|break;
name|regs
index|[
name|I
operator|.
name|IType
operator|.
name|rt
index|]
operator|=
operator|*
operator|(
name|u_int
operator|*
operator|)
operator|&
name|sp
index|[
operator|(
name|short
operator|)
name|I
operator|.
name|IType
operator|.
name|imm
index|]
expr_stmt|;
break|break;
case|case
name|OP_BEQ
case|:
if|if
condition|(
name|I
operator|.
name|IType
operator|.
name|rs
operator|!=
name|ZERO
operator|||
name|I
operator|.
name|IType
operator|.
name|rt
operator|!=
name|ZERO
condition|)
break|break;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nbpc
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|pc
operator|==
name|opcs
index|[
name|i
index|]
condition|)
block|{
comment|/* 					 * Brach constructs infinite loop. 					 */
if|if
condition|(
operator|!
name|printed
condition|)
block|{
name|printf
argument_list|(
literal|"branch loop\n"
argument_list|)
expr_stmt|;
name|printed
operator|=
literal|1
expr_stmt|;
block|}
break|break;
block|}
if|if
condition|(
name|i
operator|==
name|nbpc
condition|)
block|{
name|opcs
index|[
name|nbpc
index|]
operator|=
name|pc
expr_stmt|;
name|nbpc
operator|=
name|imin
argument_list|(
name|nbpc
operator|+
literal|1
argument_list|,
name|NPCSTOCK
argument_list|)
expr_stmt|;
name|pc
operator|=
name|pc
operator|+
operator|(
name|short
operator|)
name|I
operator|.
name|IType
operator|.
name|imm
expr_stmt|;
block|}
break|break;
default|default:
break|break;
block|}
name|I
operator|.
name|word
operator|=
operator|*
operator|(
name|pc
operator|-
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|I
operator|.
name|RType
operator|.
name|op
operator|==
name|OP_SPECIAL
operator|&&
name|I
operator|.
name|RType
operator|.
name|func
operator|==
name|OP_JR
condition|)
return|return
operator|(
operator|(
name|int
operator|*
operator|)
name|regs
index|[
name|I
operator|.
name|RType
operator|.
name|rs
index|]
operator|)
return|;
block|}
name|printf
argument_list|(
literal|"pc run out of TEXT\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

end_unit

