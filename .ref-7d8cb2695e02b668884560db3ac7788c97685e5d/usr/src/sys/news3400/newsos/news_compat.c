begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1992 The Regents of the University of California.  * All rights reserved.  *  * This software was developed by the Computer Systems Engineering group  * at Lawrence Berkeley Laboratory under DARPA contract BG 91-66 and  * contributed to Berkeley.  *  *	%sccs.include.redist.c%  *  *	@(#)news_compat.c	7.1 (Berkeley) %G%  *  * from: $Hdr: sun_misc.c,v 1.12 92/07/12 13:26:10 torek Exp $  */
end_comment

begin_comment
comment|/*  * NEWS-OS compatibility module.  *  * NEWS-OS system calls that are implemented differently in BSD are  * handled here.  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<sys/filedesc.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/mman.h>
end_include

begin_include
include|#
directive|include
file|<sys/mount.h>
end_include

begin_include
include|#
directive|include
file|<sys/resource.h>
end_include

begin_include
include|#
directive|include
file|<sys/resourcevar.h>
end_include

begin_include
include|#
directive|include
file|<sys/signal.h>
end_include

begin_include
include|#
directive|include
file|<sys/signalvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/vnode.h>
end_include

begin_include
include|#
directive|include
file|<sys/uio.h>
end_include

begin_include
include|#
directive|include
file|<sys/wait.h>
end_include

begin_include
include|#
directive|include
file|<miscfs/specfs/specdev.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* here is the sun layout (not used directly): */
end_comment

begin_endif
unit|struct sun_dirent { 	long	d_off; 	u_long	d_fileno; 	u_short	d_reclen; 	u_short	d_namlen; 	char	d_name[256]; };
endif|#
directive|endif
end_endif

begin_comment
comment|/* and the BSD layout: */
end_comment

begin_struct
struct|struct
name|bsd_dirent
block|{
name|u_long
name|d_fileno
decl_stmt|;
name|u_short
name|d_reclen
decl_stmt|;
name|u_short
name|d_namlen
decl_stmt|;
name|char
name|d_name
index|[
literal|256
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*  * Read Sun-style directory entries.  We suck them into kernel space so  * that they can be massaged before being copied out to user code.  Like  * SunOS, we squish out `empty' entries.  *  * This is quite ugly, but what do you expect from compatibility code?  */
end_comment

begin_struct
struct|struct
name|sun_getdents_args
block|{
name|int
name|fd
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
name|int
name|nbytes
decl_stmt|;
block|}
struct|;
end_struct

begin_macro
name|sun_getdents
argument_list|(
argument|p
argument_list|,
argument|uap
argument_list|,
argument|retval
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|struct
name|sun_getdents_args
modifier|*
name|uap
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
modifier|*
name|retval
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
specifier|register
name|caddr_t
name|inp
decl_stmt|,
name|buf
decl_stmt|;
comment|/* BSD-format */
specifier|register
name|int
name|len
decl_stmt|,
name|reclen
decl_stmt|;
comment|/* BSD-format */
specifier|register
name|caddr_t
name|outp
decl_stmt|;
comment|/* Sun-format */
specifier|register
name|int
name|resid
decl_stmt|;
comment|/* Sun-format */
name|struct
name|file
modifier|*
name|fp
decl_stmt|;
name|struct
name|uio
name|auio
decl_stmt|;
name|struct
name|iovec
name|aiov
decl_stmt|;
name|off_t
name|off
decl_stmt|;
comment|/* true file offset */
name|long
name|soff
decl_stmt|;
comment|/* Sun file offset */
name|int
name|buflen
decl_stmt|,
name|error
decl_stmt|,
name|eofflag
decl_stmt|;
define|#
directive|define
name|SUN_RECLEN
parameter_list|(
name|reclen
parameter_list|)
value|(reclen + sizeof(long))
if|if
condition|(
operator|(
name|error
operator|=
name|getvnode
argument_list|(
name|p
operator|->
name|p_fd
argument_list|,
name|uap
operator|->
name|fd
argument_list|,
operator|&
name|fp
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
operator|(
name|fp
operator|->
name|f_flag
operator|&
name|FREAD
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
name|EBADF
operator|)
return|;
name|vp
operator|=
operator|(
expr|struct
name|vnode
operator|*
operator|)
name|fp
operator|->
name|f_data
expr_stmt|;
if|if
condition|(
name|vp
operator|->
name|v_type
operator|!=
name|VDIR
condition|)
comment|/* XXX  vnode readdir op should do this */
return|return
operator|(
name|EINVAL
operator|)
return|;
name|buflen
operator|=
name|min
argument_list|(
name|MAXBSIZE
argument_list|,
name|uap
operator|->
name|nbytes
argument_list|)
expr_stmt|;
name|buf
operator|=
name|malloc
argument_list|(
name|buflen
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|VOP_LOCK
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|off
operator|=
name|fp
operator|->
name|f_offset
expr_stmt|;
name|again
label|:
name|aiov
operator|.
name|iov_base
operator|=
name|buf
expr_stmt|;
name|aiov
operator|.
name|iov_len
operator|=
name|buflen
expr_stmt|;
name|auio
operator|.
name|uio_iov
operator|=
operator|&
name|aiov
expr_stmt|;
name|auio
operator|.
name|uio_iovcnt
operator|=
literal|1
expr_stmt|;
name|auio
operator|.
name|uio_rw
operator|=
name|UIO_READ
expr_stmt|;
name|auio
operator|.
name|uio_segflg
operator|=
name|UIO_SYSSPACE
expr_stmt|;
name|auio
operator|.
name|uio_procp
operator|=
name|p
expr_stmt|;
name|auio
operator|.
name|uio_resid
operator|=
name|buflen
expr_stmt|;
name|auio
operator|.
name|uio_offset
operator|=
name|off
expr_stmt|;
comment|/* 	 * First we read into the malloc'ed buffer, then 	 * we massage it into user space, one record at a time. 	 */
if|if
condition|(
name|error
operator|=
name|VOP_READDIR
argument_list|(
name|vp
argument_list|,
operator|&
name|auio
argument_list|,
name|fp
operator|->
name|f_cred
argument_list|,
operator|&
name|eofflag
argument_list|)
condition|)
goto|goto
name|out
goto|;
name|inp
operator|=
name|buf
expr_stmt|;
name|outp
operator|=
name|uap
operator|->
name|buf
expr_stmt|;
name|resid
operator|=
name|uap
operator|->
name|nbytes
expr_stmt|;
if|if
condition|(
operator|(
name|len
operator|=
name|buflen
operator|-
name|auio
operator|.
name|uio_resid
operator|)
operator|==
literal|0
condition|)
goto|goto
name|eof
goto|;
for|for
control|(
init|;
name|len
operator|>
literal|0
condition|;
name|len
operator|-=
name|reclen
control|)
block|{
name|reclen
operator|=
operator|(
operator|(
expr|struct
name|bsd_dirent
operator|*
operator|)
name|inp
operator|)
operator|->
name|d_reclen
expr_stmt|;
if|if
condition|(
name|reclen
operator|&
literal|3
condition|)
name|panic
argument_list|(
literal|"sun_getdents"
argument_list|)
expr_stmt|;
name|off
operator|+=
name|reclen
expr_stmt|;
comment|/* each entry points to next */
if|if
condition|(
operator|(
operator|(
expr|struct
name|bsd_dirent
operator|*
operator|)
name|inp
operator|)
operator|->
name|d_fileno
operator|==
literal|0
condition|)
block|{
name|inp
operator|+=
name|reclen
expr_stmt|;
comment|/* it is a hole; squish it out */
continue|continue;
block|}
if|if
condition|(
name|reclen
operator|>
name|len
operator|||
name|resid
operator|<
name|SUN_RECLEN
argument_list|(
name|reclen
argument_list|)
condition|)
block|{
comment|/* entry too big for buffer, so just stop */
name|outp
operator|++
expr_stmt|;
break|break;
block|}
comment|/* copy out a Sun-shaped dirent */
operator|(
operator|(
expr|struct
name|bsd_dirent
operator|*
operator|)
name|inp
operator|)
operator|->
name|d_reclen
operator|=
name|SUN_RECLEN
argument_list|(
name|reclen
argument_list|)
expr_stmt|;
name|soff
operator|=
name|off
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|copyout
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|soff
argument_list|,
name|outp
argument_list|,
sizeof|sizeof
name|soff
argument_list|)
operator|)
operator|!=
literal|0
operator|||
operator|(
name|error
operator|=
name|copyout
argument_list|(
name|inp
argument_list|,
name|outp
operator|+
sizeof|sizeof
name|soff
argument_list|,
name|reclen
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
comment|/* advance past this real entry */
name|inp
operator|+=
name|reclen
expr_stmt|;
comment|/* advance output past Sun-shaped entry */
name|outp
operator|+=
name|SUN_RECLEN
argument_list|(
name|reclen
argument_list|)
expr_stmt|;
name|resid
operator|-=
name|SUN_RECLEN
argument_list|(
name|reclen
argument_list|)
expr_stmt|;
block|}
comment|/* if we squished out the whole block, try again */
if|if
condition|(
name|outp
operator|==
name|uap
operator|->
name|buf
condition|)
goto|goto
name|again
goto|;
name|fp
operator|->
name|f_offset
operator|=
name|off
expr_stmt|;
comment|/* update the vnode offset */
name|eof
label|:
operator|*
name|retval
operator|=
name|uap
operator|->
name|nbytes
operator|-
name|resid
expr_stmt|;
name|out
label|:
name|VOP_UNLOCK
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buf
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_block

begin_define
define|#
directive|define
name|MAXDOMAINNAME
value|64
end_define

begin_decl_stmt
name|char
name|sun_domainname
index|[
name|MAXDOMAINNAME
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|sun_domainnamelen
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|sun_getdomainname_args
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|namelen
decl_stmt|;
block|}
struct|;
end_struct

begin_macro
name|sun_getdomainname
argument_list|(
argument|p
argument_list|,
argument|uap
argument_list|,
argument|retval
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|sun_getdomainname_args
modifier|*
name|uap
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
modifier|*
name|retval
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|l
init|=
name|min
argument_list|(
name|uap
operator|->
name|namelen
argument_list|,
name|sun_domainnamelen
operator|+
literal|1
argument_list|)
decl_stmt|;
return|return
operator|(
name|copyout
argument_list|(
name|sun_domainname
argument_list|,
name|uap
operator|->
name|name
argument_list|,
name|l
argument_list|)
operator|)
return|;
block|}
end_block

begin_struct
struct|struct
name|sun_setdomainname_args
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|namelen
decl_stmt|;
block|}
struct|;
end_struct

begin_macro
name|sun_setdomainname
argument_list|(
argument|p
argument_list|,
argument|uap
argument_list|,
argument|retval
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|sun_setdomainname_args
modifier|*
name|uap
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
modifier|*
name|retval
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|l
init|=
name|uap
operator|->
name|namelen
decl_stmt|,
name|error
decl_stmt|;
if|if
condition|(
name|l
operator|>=
name|MAXDOMAINNAME
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* ??? ENAMETOOLONG? */
if|if
condition|(
name|error
operator|=
name|suser
argument_list|(
name|p
operator|->
name|p_ucred
argument_list|,
operator|&
name|p
operator|->
name|p_acflag
argument_list|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|error
operator|=
name|copyin
argument_list|(
name|uap
operator|->
name|name
argument_list|,
name|sun_domainname
argument_list|,
name|l
argument_list|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|sun_domainname
index|[
name|l
index|]
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * setenvp system call  */
end_comment

begin_struct
struct|struct
name|news_setenvp_args
block|{
name|char
modifier|*
modifier|*
name|envp
decl_stmt|;
block|}
struct|;
end_struct

begin_macro
name|news_setenvp
argument_list|(
argument|p
argument_list|,
argument|args
argument_list|,
argument|retval
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|news_setenvp_args
modifier|*
name|args
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
modifier|*
name|retval
decl_stmt|;
end_decl_stmt

begin_block
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * sysnews system call  */
end_comment

begin_struct
struct|struct
name|news_sysnews_args
block|{
name|int
name|ctrltype
decl_stmt|;
name|int
name|arg1
decl_stmt|,
name|arg2
decl_stmt|,
name|arg3
decl_stmt|,
name|arg4
decl_stmt|;
block|}
struct|;
end_struct

begin_macro
name|news_sysnews
argument_list|(
argument|p
argument_list|,
argument|args
argument_list|,
argument|retval
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|news_sysnews_args
modifier|*
name|args
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
modifier|*
name|retval
decl_stmt|;
end_decl_stmt

begin_block
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

end_unit

