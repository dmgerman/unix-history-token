begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1991 The Regents of the University of California.  * All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * Ralph Campbell.  *  * %sccs.include.redist.c%  *  *	@(#)kadb.c	7.5 (Berkeley) %G%  */
end_comment

begin_comment
comment|/*  * Define machine dependent primitives for kdb.  */
end_comment

begin_include
include|#
directive|include
file|<kdb/defs.h>
end_include

begin_undef
undef|#
directive|undef
name|SP
end_undef

begin_include
include|#
directive|include
file|<machine/reg.h>
end_include

begin_include
include|#
directive|include
file|<machine/trap.h>
end_include

begin_include
include|#
directive|include
file|<machine/mips_opcode.h>
end_include

begin_decl_stmt
name|REGLIST
name|kdbreglist
index|[]
init|=
block|{
comment|/* register_name, address */
literal|"AT"
block|,
operator|&
name|kdbpcb
operator|.
name|pcb_regs
index|[
name|AST
index|]
block|,
literal|"v0"
block|,
operator|&
name|kdbpcb
operator|.
name|pcb_regs
index|[
name|V0
index|]
block|,
literal|"v1"
block|,
operator|&
name|kdbpcb
operator|.
name|pcb_regs
index|[
name|V1
index|]
block|,
literal|"a0"
block|,
operator|&
name|kdbpcb
operator|.
name|pcb_regs
index|[
name|A0
index|]
block|,
literal|"a1"
block|,
operator|&
name|kdbpcb
operator|.
name|pcb_regs
index|[
name|A1
index|]
block|,
literal|"a2"
block|,
operator|&
name|kdbpcb
operator|.
name|pcb_regs
index|[
name|A2
index|]
block|,
literal|"a3"
block|,
operator|&
name|kdbpcb
operator|.
name|pcb_regs
index|[
name|A3
index|]
block|,
literal|"t0"
block|,
operator|&
name|kdbpcb
operator|.
name|pcb_regs
index|[
name|T0
index|]
block|,
literal|"t1"
block|,
operator|&
name|kdbpcb
operator|.
name|pcb_regs
index|[
name|T1
index|]
block|,
literal|"t2"
block|,
operator|&
name|kdbpcb
operator|.
name|pcb_regs
index|[
name|T2
index|]
block|,
literal|"t3"
block|,
operator|&
name|kdbpcb
operator|.
name|pcb_regs
index|[
name|T3
index|]
block|,
literal|"t4"
block|,
operator|&
name|kdbpcb
operator|.
name|pcb_regs
index|[
name|T4
index|]
block|,
literal|"t5"
block|,
operator|&
name|kdbpcb
operator|.
name|pcb_regs
index|[
name|T5
index|]
block|,
literal|"t6"
block|,
operator|&
name|kdbpcb
operator|.
name|pcb_regs
index|[
name|T6
index|]
block|,
literal|"t7"
block|,
operator|&
name|kdbpcb
operator|.
name|pcb_regs
index|[
name|T7
index|]
block|,
literal|"t8"
block|,
operator|&
name|kdbpcb
operator|.
name|pcb_regs
index|[
name|T8
index|]
block|,
literal|"t9"
block|,
operator|&
name|kdbpcb
operator|.
name|pcb_regs
index|[
name|T9
index|]
block|,
literal|"s0"
block|,
operator|&
name|kdbpcb
operator|.
name|pcb_regs
index|[
name|S0
index|]
block|,
literal|"s1"
block|,
operator|&
name|kdbpcb
operator|.
name|pcb_regs
index|[
name|S1
index|]
block|,
literal|"s2"
block|,
operator|&
name|kdbpcb
operator|.
name|pcb_regs
index|[
name|S2
index|]
block|,
literal|"s3"
block|,
operator|&
name|kdbpcb
operator|.
name|pcb_regs
index|[
name|S3
index|]
block|,
literal|"s4"
block|,
operator|&
name|kdbpcb
operator|.
name|pcb_regs
index|[
name|S4
index|]
block|,
literal|"s5"
block|,
operator|&
name|kdbpcb
operator|.
name|pcb_regs
index|[
name|S5
index|]
block|,
literal|"s6"
block|,
operator|&
name|kdbpcb
operator|.
name|pcb_regs
index|[
name|S6
index|]
block|,
literal|"s7"
block|,
operator|&
name|kdbpcb
operator|.
name|pcb_regs
index|[
name|S7
index|]
block|,
literal|"s8"
block|,
operator|&
name|kdbpcb
operator|.
name|pcb_regs
index|[
name|S8
index|]
block|,
literal|"sp"
block|,
operator|&
name|kdbpcb
operator|.
name|pcb_regs
index|[
name|SP
index|]
block|,
literal|"gp"
block|,
operator|&
name|kdbpcb
operator|.
name|pcb_regs
index|[
name|GP
index|]
block|,
literal|"ra"
block|,
operator|&
name|kdbpcb
operator|.
name|pcb_regs
index|[
name|RA
index|]
block|,
literal|"mullo"
block|,
operator|&
name|kdbpcb
operator|.
name|pcb_regs
index|[
name|MULLO
index|]
block|,
literal|"mulhi"
block|,
operator|&
name|kdbpcb
operator|.
name|pcb_regs
index|[
name|MULHI
index|]
block|,
literal|"SR"
block|,
operator|&
name|kdbpcb
operator|.
name|pcb_regs
index|[
name|SR
index|]
block|,
literal|"pc"
block|,
operator|&
name|kdbpcb
operator|.
name|pcb_regs
index|[
name|PC
index|]
block|,
literal|"f0"
block|,
operator|&
name|kdbpcb
operator|.
name|pcb_regs
index|[
name|F0
index|]
block|,
literal|"f1"
block|,
operator|&
name|kdbpcb
operator|.
name|pcb_regs
index|[
name|F1
index|]
block|,
literal|"f2"
block|,
operator|&
name|kdbpcb
operator|.
name|pcb_regs
index|[
name|F2
index|]
block|,
literal|"f3"
block|,
operator|&
name|kdbpcb
operator|.
name|pcb_regs
index|[
name|F3
index|]
block|,
literal|"f4"
block|,
operator|&
name|kdbpcb
operator|.
name|pcb_regs
index|[
name|F4
index|]
block|,
literal|"f5"
block|,
operator|&
name|kdbpcb
operator|.
name|pcb_regs
index|[
name|F5
index|]
block|,
literal|"f6"
block|,
operator|&
name|kdbpcb
operator|.
name|pcb_regs
index|[
name|F6
index|]
block|,
literal|"f7"
block|,
operator|&
name|kdbpcb
operator|.
name|pcb_regs
index|[
name|F7
index|]
block|,
literal|"f8"
block|,
operator|&
name|kdbpcb
operator|.
name|pcb_regs
index|[
name|F8
index|]
block|,
literal|"f9"
block|,
operator|&
name|kdbpcb
operator|.
name|pcb_regs
index|[
name|F9
index|]
block|,
literal|"f10"
block|,
operator|&
name|kdbpcb
operator|.
name|pcb_regs
index|[
name|F10
index|]
block|,
literal|"f11"
block|,
operator|&
name|kdbpcb
operator|.
name|pcb_regs
index|[
name|F11
index|]
block|,
literal|"f12"
block|,
operator|&
name|kdbpcb
operator|.
name|pcb_regs
index|[
name|F12
index|]
block|,
literal|"f13"
block|,
operator|&
name|kdbpcb
operator|.
name|pcb_regs
index|[
name|F13
index|]
block|,
literal|"f14"
block|,
operator|&
name|kdbpcb
operator|.
name|pcb_regs
index|[
name|F14
index|]
block|,
literal|"f15"
block|,
operator|&
name|kdbpcb
operator|.
name|pcb_regs
index|[
name|F15
index|]
block|,
literal|"f16"
block|,
operator|&
name|kdbpcb
operator|.
name|pcb_regs
index|[
name|F16
index|]
block|,
literal|"f17"
block|,
operator|&
name|kdbpcb
operator|.
name|pcb_regs
index|[
name|F17
index|]
block|,
literal|"f18"
block|,
operator|&
name|kdbpcb
operator|.
name|pcb_regs
index|[
name|F18
index|]
block|,
literal|"f19"
block|,
operator|&
name|kdbpcb
operator|.
name|pcb_regs
index|[
name|F19
index|]
block|,
literal|"f20"
block|,
operator|&
name|kdbpcb
operator|.
name|pcb_regs
index|[
name|F20
index|]
block|,
literal|"f21"
block|,
operator|&
name|kdbpcb
operator|.
name|pcb_regs
index|[
name|F21
index|]
block|,
literal|"f22"
block|,
operator|&
name|kdbpcb
operator|.
name|pcb_regs
index|[
name|F22
index|]
block|,
literal|"f23"
block|,
operator|&
name|kdbpcb
operator|.
name|pcb_regs
index|[
name|F23
index|]
block|,
literal|"f24"
block|,
operator|&
name|kdbpcb
operator|.
name|pcb_regs
index|[
name|F24
index|]
block|,
literal|"f25"
block|,
operator|&
name|kdbpcb
operator|.
name|pcb_regs
index|[
name|F25
index|]
block|,
literal|"f26"
block|,
operator|&
name|kdbpcb
operator|.
name|pcb_regs
index|[
name|F26
index|]
block|,
literal|"f27"
block|,
operator|&
name|kdbpcb
operator|.
name|pcb_regs
index|[
name|F27
index|]
block|,
literal|"f28"
block|,
operator|&
name|kdbpcb
operator|.
name|pcb_regs
index|[
name|F28
index|]
block|,
literal|"f29"
block|,
operator|&
name|kdbpcb
operator|.
name|pcb_regs
index|[
name|F29
index|]
block|,
literal|"f30"
block|,
operator|&
name|kdbpcb
operator|.
name|pcb_regs
index|[
name|F30
index|]
block|,
literal|"f31"
block|,
operator|&
name|kdbpcb
operator|.
name|pcb_regs
index|[
name|F31
index|]
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|op_name
index|[
literal|64
index|]
init|=
block|{
comment|/* 0 */
literal|"spec"
block|,
literal|"bcond"
block|,
literal|"j"
block|,
literal|"jal"
block|,
literal|"beq"
block|,
literal|"bne"
block|,
literal|"blez"
block|,
literal|"bgtz"
block|,
comment|/* 8 */
literal|"addi"
block|,
literal|"addiu"
block|,
literal|"slti"
block|,
literal|"sltiu"
block|,
literal|"andi"
block|,
literal|"ori"
block|,
literal|"xori"
block|,
literal|"lui"
block|,
comment|/*16 */
literal|"cop0"
block|,
literal|"cop1"
block|,
literal|"cop2"
block|,
literal|"cop3"
block|,
literal|"op24"
block|,
literal|"op25"
block|,
literal|"op26"
block|,
literal|"op27"
block|,
comment|/*24 */
literal|"op30"
block|,
literal|"op31"
block|,
literal|"op32"
block|,
literal|"op33"
block|,
literal|"op34"
block|,
literal|"op35"
block|,
literal|"op36"
block|,
literal|"op37"
block|,
comment|/*32 */
literal|"lb"
block|,
literal|"lh"
block|,
literal|"lwl"
block|,
literal|"lw"
block|,
literal|"lbu"
block|,
literal|"lhu"
block|,
literal|"lwr"
block|,
literal|"ld"
block|,
comment|/*40 */
literal|"sb"
block|,
literal|"sh"
block|,
literal|"swl"
block|,
literal|"sw"
block|,
literal|"op54"
block|,
literal|"op55"
block|,
literal|"swr"
block|,
literal|"sd"
block|,
comment|/*48 */
literal|"lwc0"
block|,
literal|"lwc1"
block|,
literal|"lwc2"
block|,
literal|"lwc3"
block|,
literal|"ldc0"
block|,
literal|"ldc1"
block|,
literal|"ldc2"
block|,
literal|"ldc3"
block|,
comment|/*56 */
literal|"swc0"
block|,
literal|"swc1"
block|,
literal|"swc2"
block|,
literal|"swc3"
block|,
literal|"sdc0"
block|,
literal|"sdc1"
block|,
literal|"sdc2"
block|,
literal|"sdc3"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|spec_name
index|[
literal|64
index|]
init|=
block|{
comment|/* 0 */
literal|"sll"
block|,
literal|"spec01"
block|,
literal|"srl"
block|,
literal|"sra"
block|,
literal|"sllv"
block|,
literal|"spec05"
block|,
literal|"srlv"
block|,
literal|"srav"
block|,
comment|/* 8 */
literal|"jr"
block|,
literal|"jalr"
block|,
literal|"spec12"
block|,
literal|"spec13"
block|,
literal|"syscall"
block|,
literal|"break"
block|,
literal|"spec16"
block|,
literal|"tas"
block|,
comment|/*16 */
literal|"mfhi"
block|,
literal|"mthi"
block|,
literal|"mflo"
block|,
literal|"mtlo"
block|,
literal|"spec24"
block|,
literal|"spec25"
block|,
literal|"spec26"
block|,
literal|"spec27"
block|,
comment|/*24 */
literal|"mult"
block|,
literal|"multu"
block|,
literal|"div"
block|,
literal|"divu"
block|,
literal|"spec34"
block|,
literal|"spec35"
block|,
literal|"spec36"
block|,
literal|"spec37"
block|,
comment|/*32 */
literal|"add"
block|,
literal|"addu"
block|,
literal|"sub"
block|,
literal|"subu"
block|,
literal|"and"
block|,
literal|"or"
block|,
literal|"xor"
block|,
literal|"nor"
block|,
comment|/*40 */
literal|"spec50"
block|,
literal|"spec51"
block|,
literal|"slt"
block|,
literal|"sltu"
block|,
literal|"spec54"
block|,
literal|"spec55"
block|,
literal|"spec56"
block|,
literal|"spec57"
block|,
comment|/*48 */
literal|"spec60"
block|,
literal|"spec61"
block|,
literal|"spec62"
block|,
literal|"spec63"
block|,
literal|"spec64"
block|,
literal|"spec65"
block|,
literal|"spec66"
block|,
literal|"spec67"
block|,
comment|/*56 */
literal|"spec70"
block|,
literal|"spec71"
block|,
literal|"spec72"
block|,
literal|"spec73"
block|,
literal|"spec74"
block|,
literal|"spec75"
block|,
literal|"spec76"
block|,
literal|"spec77"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|bcond_name
index|[
literal|32
index|]
init|=
block|{
comment|/* 0 */
literal|"bltz"
block|,
literal|"bgez"
block|,
literal|"?"
block|,
literal|"?"
block|,
literal|"?"
block|,
literal|"?"
block|,
literal|"?"
block|,
literal|"?"
block|,
comment|/* 8 */
literal|"?"
block|,
literal|"?"
block|,
literal|"?"
block|,
literal|"?"
block|,
literal|"?"
block|,
literal|"?"
block|,
literal|"?"
block|,
literal|"?"
block|,
comment|/*16 */
literal|"bltzal"
block|,
literal|"bgezal"
block|,
literal|"?"
block|,
literal|"?"
block|,
literal|"?"
block|,
literal|"?"
block|,
literal|"?"
block|,
literal|"?"
block|,
comment|/*24 */
literal|"?"
block|,
literal|"?"
block|,
literal|"?"
block|,
literal|"?"
block|,
literal|"?"
block|,
literal|"?"
block|,
literal|"?"
block|,
literal|"?"
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|cop1_name
index|[
literal|64
index|]
init|=
block|{
comment|/* 0 */
literal|"fadd"
block|,
literal|"fsub"
block|,
literal|"fmpy"
block|,
literal|"fdiv"
block|,
literal|"fsqrt"
block|,
literal|"fabs"
block|,
literal|"fmov"
block|,
literal|"fneg"
block|,
comment|/* 8 */
literal|"fop08"
block|,
literal|"fop09"
block|,
literal|"fop0a"
block|,
literal|"fop0b"
block|,
literal|"fop0c"
block|,
literal|"fop0d"
block|,
literal|"fop0e"
block|,
literal|"fop0f"
block|,
comment|/*16 */
literal|"fop10"
block|,
literal|"fop11"
block|,
literal|"fop12"
block|,
literal|"fop13"
block|,
literal|"fop14"
block|,
literal|"fop15"
block|,
literal|"fop16"
block|,
literal|"fop17"
block|,
comment|/*24 */
literal|"fop18"
block|,
literal|"fop19"
block|,
literal|"fop1a"
block|,
literal|"fop1b"
block|,
literal|"fop1c"
block|,
literal|"fop1d"
block|,
literal|"fop1e"
block|,
literal|"fop1f"
block|,
comment|/*32 */
literal|"fcvts"
block|,
literal|"fcvtd"
block|,
literal|"fcvte"
block|,
literal|"fop23"
block|,
literal|"fcvtw"
block|,
literal|"fop25"
block|,
literal|"fop26"
block|,
literal|"fop27"
block|,
comment|/*40 */
literal|"fop28"
block|,
literal|"fop29"
block|,
literal|"fop2a"
block|,
literal|"fop2b"
block|,
literal|"fop2c"
block|,
literal|"fop2d"
block|,
literal|"fop2e"
block|,
literal|"fop2f"
block|,
comment|/*48 */
literal|"fcmp.f"
block|,
literal|"fcmp.un"
block|,
literal|"fcmp.eq"
block|,
literal|"fcmp.ueq"
block|,
literal|"fcmp.olt"
block|,
literal|"fcmp.ult"
block|,
literal|"fcmp.ole"
block|,
literal|"fcmp.ule"
block|,
comment|/*56 */
literal|"fcmp.sf"
block|,
literal|"fcmp.ngle"
block|,
literal|"fcmp.seq"
block|,
literal|"fcmp.ngl"
block|,
literal|"fcmp.lt"
block|,
literal|"fcmp.nge"
block|,
literal|"fcmp.le"
block|,
literal|"fcmp.ngt"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|fmt_name
index|[
literal|16
index|]
init|=
block|{
literal|"s"
block|,
literal|"d"
block|,
literal|"e"
block|,
literal|"fmt3"
block|,
literal|"w"
block|,
literal|"fmt5"
block|,
literal|"fmt6"
block|,
literal|"fmt7"
block|,
literal|"fmt8"
block|,
literal|"fmt9"
block|,
literal|"fmta"
block|,
literal|"fmtb"
block|,
literal|"fmtc"
block|,
literal|"fmtd"
block|,
literal|"fmte"
block|,
literal|"fmtf"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|reg_name
index|[
literal|32
index|]
init|=
block|{
literal|"zero"
block|,
literal|"at"
block|,
literal|"v0"
block|,
literal|"v1"
block|,
literal|"a0"
block|,
literal|"a1"
block|,
literal|"a2"
block|,
literal|"a3"
block|,
literal|"t0"
block|,
literal|"t1"
block|,
literal|"t2"
block|,
literal|"t3"
block|,
literal|"t4"
block|,
literal|"t5"
block|,
literal|"t6"
block|,
literal|"t7"
block|,
literal|"s0"
block|,
literal|"s1"
block|,
literal|"s2"
block|,
literal|"s3"
block|,
literal|"s4"
block|,
literal|"s5"
block|,
literal|"s6"
block|,
literal|"s7"
block|,
literal|"t8"
block|,
literal|"t9"
block|,
literal|"k0"
block|,
literal|"k1"
block|,
literal|"gp"
block|,
literal|"sp"
block|,
literal|"s8"
block|,
literal|"ra"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|c0_opname
index|[
literal|64
index|]
init|=
block|{
literal|"c0op00"
block|,
literal|"tlbr"
block|,
literal|"tlbwi"
block|,
literal|"c0op03"
block|,
literal|"c0op04"
block|,
literal|"c0op05"
block|,
literal|"tlbwr"
block|,
literal|"c0op07"
block|,
literal|"tlbp"
block|,
literal|"c0op11"
block|,
literal|"c0op12"
block|,
literal|"c0op13"
block|,
literal|"c0op14"
block|,
literal|"c0op15"
block|,
literal|"c0op16"
block|,
literal|"c0op17"
block|,
literal|"rfe"
block|,
literal|"c0op21"
block|,
literal|"c0op22"
block|,
literal|"c0op23"
block|,
literal|"c0op24"
block|,
literal|"c0op25"
block|,
literal|"c0op26"
block|,
literal|"c0op27"
block|,
literal|"c0op30"
block|,
literal|"c0op31"
block|,
literal|"c0op32"
block|,
literal|"c0op33"
block|,
literal|"c0op34"
block|,
literal|"c0op35"
block|,
literal|"c0op36"
block|,
literal|"c0op37"
block|,
literal|"c0op40"
block|,
literal|"c0op41"
block|,
literal|"c0op42"
block|,
literal|"c0op43"
block|,
literal|"c0op44"
block|,
literal|"c0op45"
block|,
literal|"c0op46"
block|,
literal|"c0op47"
block|,
literal|"c0op50"
block|,
literal|"c0op51"
block|,
literal|"c0op52"
block|,
literal|"c0op53"
block|,
literal|"c0op54"
block|,
literal|"c0op55"
block|,
literal|"c0op56"
block|,
literal|"c0op57"
block|,
literal|"c0op60"
block|,
literal|"c0op61"
block|,
literal|"c0op62"
block|,
literal|"c0op63"
block|,
literal|"c0op64"
block|,
literal|"c0op65"
block|,
literal|"c0op66"
block|,
literal|"c0op67"
block|,
literal|"c0op70"
block|,
literal|"c0op71"
block|,
literal|"c0op72"
block|,
literal|"c0op73"
block|,
literal|"c0op74"
block|,
literal|"c0op75"
block|,
literal|"c0op77"
block|,
literal|"c0op77"
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|c0_reg
index|[
literal|32
index|]
init|=
block|{
literal|"index"
block|,
literal|"random"
block|,
literal|"tlblo"
block|,
literal|"c0r3"
block|,
literal|"context"
block|,
literal|"c0r5"
block|,
literal|"c0r6"
block|,
literal|"c0r7"
block|,
literal|"badvaddr"
block|,
literal|"c0r9"
block|,
literal|"tlbhi"
block|,
literal|"c0r11"
block|,
literal|"sr"
block|,
literal|"cause"
block|,
literal|"epc"
block|,
literal|"c0r15"
block|,
literal|"c0r16"
block|,
literal|"c0r17"
block|,
literal|"c0r18"
block|,
literal|"c0r19"
block|,
literal|"c0r20"
block|,
literal|"c0r21"
block|,
literal|"c0r22"
block|,
literal|"c0r23"
block|,
literal|"c0r24"
block|,
literal|"c0r25"
block|,
literal|"c0r26"
block|,
literal|"c0r27"
block|,
literal|"c0r28"
block|,
literal|"c0r29"
block|,
literal|"c0r30"
block|,
literal|"c0r31"
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Print the cause of the trap to kdb.  */
end_comment

begin_function
name|void
name|kdbprinttrap
parameter_list|(
name|causeReg
parameter_list|,
name|vadr
parameter_list|)
name|unsigned
name|causeReg
decl_stmt|,
name|vadr
decl_stmt|;
block|{
name|int
name|type
decl_stmt|,
name|pc
decl_stmt|;
specifier|extern
name|char
modifier|*
name|trap_type
index|[]
decl_stmt|;
name|type
operator|=
operator|(
name|causeReg
operator|&
name|MACH_CR_EXC_CODE
operator|)
operator|>>
name|MACH_CR_EXC_CODE_SHIFT
expr_stmt|;
comment|/* check to see if we are entering kdb via kdbpanic() */
name|pc
operator|=
name|kdbpcb
operator|.
name|pcb_regs
index|[
name|PC
index|]
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|T_BREAK
operator|&&
name|pc
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|kdbpeek
argument_list|(
name|pc
argument_list|)
operator|==
name|MACH_BREAK_KDB
condition|)
name|kdbpcb
operator|.
name|pcb_regs
index|[
name|PC
index|]
operator|=
name|pc
operator|+
literal|4
expr_stmt|;
block|}
name|kdbprintf
argument_list|(
literal|"trap: %s\n"
argument_list|,
name|trap_type
index|[
name|type
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
name|unsigned
name|kdb_ss_addr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|kdb_ss_instr
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|kdbsetsstep
parameter_list|()
block|{
specifier|register
name|unsigned
name|va
decl_stmt|;
specifier|register
name|int
modifier|*
name|locr0
init|=
name|kdbpcb
operator|.
name|pcb_regs
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* compute next address after current location */
name|va
operator|=
name|MachEmulateBranch
argument_list|(
name|locr0
argument_list|,
name|locr0
index|[
name|PC
index|]
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|kdb_ss_addr
condition|)
block|{
name|kdbprintf
argument_list|(
literal|"kdbsetsstep: breakpoint already set at %x (va %x)\n"
argument_list|,
name|kdb_ss_addr
argument_list|,
name|va
argument_list|)
expr_stmt|;
return|return;
block|}
name|kdb_ss_addr
operator|=
name|va
expr_stmt|;
if|if
condition|(
operator|(
name|int
operator|)
name|va
operator|<
literal|0
condition|)
block|{
comment|/* kernel address */
name|kdb_ss_instr
operator|=
name|kdbpeek
argument_list|(
name|va
argument_list|)
expr_stmt|;
name|kdbpoke
argument_list|(
operator|(
name|caddr_t
operator|)
name|va
argument_list|,
name|MACH_BREAK_SSTEP
argument_list|)
expr_stmt|;
return|return;
block|}
name|kdb_ss_instr
operator|=
name|fuiword
argument_list|(
name|va
argument_list|)
expr_stmt|;
name|i
operator|=
name|suiword
argument_list|(
operator|(
name|caddr_t
operator|)
name|va
argument_list|,
name|MACH_BREAK_SSTEP
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
block|{
specifier|register
name|struct
name|proc
modifier|*
name|p
init|=
name|curproc
decl_stmt|;
name|vm_offset_t
name|sa
decl_stmt|,
name|ea
decl_stmt|;
name|int
name|rv
decl_stmt|;
name|sa
operator|=
name|trunc_page
argument_list|(
operator|(
name|vm_offset_t
operator|)
name|va
argument_list|)
expr_stmt|;
name|ea
operator|=
name|round_page
argument_list|(
operator|(
name|vm_offset_t
operator|)
name|va
operator|+
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|rv
operator|=
name|vm_map_protect
argument_list|(
operator|&
name|p
operator|->
name|p_vmspace
operator|->
name|vm_map
argument_list|,
name|sa
argument_list|,
name|ea
argument_list|,
name|VM_PROT_DEFAULT
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|==
name|KERN_SUCCESS
condition|)
block|{
name|i
operator|=
name|suiword
argument_list|(
operator|(
name|caddr_t
operator|)
name|va
argument_list|,
name|MACH_BREAK_SSTEP
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|vm_map_protect
argument_list|(
operator|&
name|p
operator|->
name|p_vmspace
operator|->
name|vm_map
argument_list|,
name|sa
argument_list|,
name|ea
argument_list|,
name|VM_PROT_READ
operator||
name|VM_PROT_EXECUTE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|i
operator|<
literal|0
condition|)
return|return;
block|}
end_function

begin_function
name|void
name|kdbclrsstep
parameter_list|()
block|{
specifier|register
name|unsigned
name|cr
decl_stmt|,
name|pc
decl_stmt|,
name|va
decl_stmt|;
name|unsigned
name|instr
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* ignore this trap if it is not a break trap */
name|cr
operator|=
name|kdbvar
index|[
name|kdbvarchk
argument_list|(
literal|'t'
argument_list|)
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|cr
operator|&
name|MACH_CR_EXC_CODE
operator|)
operator|!=
operator|(
name|T_BREAK
operator|<<
name|MACH_CR_EXC_CODE_SHIFT
operator|)
condition|)
return|return;
comment|/* fix pc if break instruction is in the delay slot */
name|pc
operator|=
name|kdbpcb
operator|.
name|pcb_regs
index|[
name|PC
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|int
operator|)
name|cr
operator|<
literal|0
condition|)
name|pc
operator|+=
literal|4
expr_stmt|;
comment|/* check to be sure its the one we are expecting */
name|va
operator|=
name|kdb_ss_addr
expr_stmt|;
if|if
condition|(
operator|!
name|va
operator|||
name|va
operator|!=
name|pc
condition|)
return|return;
comment|/* read break instruction */
name|instr
operator|=
name|kdbpeek
argument_list|(
name|va
argument_list|)
expr_stmt|;
if|if
condition|(
name|instr
operator|!=
name|MACH_BREAK_SSTEP
condition|)
return|return;
if|if
condition|(
operator|(
name|int
operator|)
name|va
operator|<
literal|0
condition|)
block|{
comment|/* kernel address */
name|kdbpoke
argument_list|(
operator|(
name|caddr_t
operator|)
name|va
argument_list|,
name|kdb_ss_instr
argument_list|)
expr_stmt|;
name|kdb_ss_addr
operator|=
literal|0
expr_stmt|;
return|return;
block|}
comment|/* restore original instruction and clear BP */
name|i
operator|=
name|suiword
argument_list|(
operator|(
name|caddr_t
operator|)
name|va
argument_list|,
name|kdb_ss_instr
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
block|{
specifier|register
name|struct
name|proc
modifier|*
name|p
init|=
name|curproc
decl_stmt|;
name|vm_offset_t
name|sa
decl_stmt|,
name|ea
decl_stmt|;
name|int
name|rv
decl_stmt|;
name|sa
operator|=
name|trunc_page
argument_list|(
operator|(
name|vm_offset_t
operator|)
name|va
argument_list|)
expr_stmt|;
name|ea
operator|=
name|round_page
argument_list|(
operator|(
name|vm_offset_t
operator|)
name|va
operator|+
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|rv
operator|=
name|vm_map_protect
argument_list|(
operator|&
name|p
operator|->
name|p_vmspace
operator|->
name|vm_map
argument_list|,
name|sa
argument_list|,
name|ea
argument_list|,
name|VM_PROT_DEFAULT
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|==
name|KERN_SUCCESS
condition|)
block|{
name|i
operator|=
name|suiword
argument_list|(
operator|(
name|caddr_t
operator|)
name|va
argument_list|,
name|p
operator|->
name|p_md
operator|.
name|md_ss_instr
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|vm_map_protect
argument_list|(
operator|&
name|p
operator|->
name|p_vmspace
operator|->
name|vm_map
argument_list|,
name|sa
argument_list|,
name|ea
argument_list|,
name|VM_PROT_READ
operator||
name|VM_PROT_EXECUTE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|i
operator|<
literal|0
condition|)
name|kdbprintf
argument_list|(
literal|"can't clear break at %x\n"
argument_list|,
name|va
argument_list|)
expr_stmt|;
name|kdb_ss_addr
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|void
name|kdbreadc
parameter_list|(
name|lp
parameter_list|)
name|char
modifier|*
name|lp
decl_stmt|;
block|{
name|int
name|c
decl_stmt|;
name|c
operator|=
name|cngetc
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\r'
condition|)
name|c
operator|=
literal|'\n'
expr_stmt|;
operator|*
name|lp
operator|=
name|c
expr_stmt|;
block|}
end_function

begin_function
name|void
name|kdbwrite
parameter_list|(
name|lp
parameter_list|,
name|len
parameter_list|)
name|char
modifier|*
name|lp
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
while|while
condition|(
name|len
operator|--
operator|>
literal|0
condition|)
name|cnputc
argument_list|(
operator|*
name|lp
operator|++
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|void
name|kdbprintins
parameter_list|(
name|space
parameter_list|,
name|ins
parameter_list|)
name|int
name|space
decl_stmt|;
name|long
name|ins
decl_stmt|;
block|{
name|InstFmt
name|i
decl_stmt|;
name|i
operator|.
name|word
operator|=
name|ins
expr_stmt|;
switch|switch
condition|(
name|i
operator|.
name|JType
operator|.
name|op
condition|)
block|{
case|case
name|OP_SPECIAL
case|:
if|if
condition|(
name|i
operator|.
name|word
operator|==
literal|0
condition|)
block|{
name|kdbprintf
argument_list|(
literal|"nop"
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|i
operator|.
name|RType
operator|.
name|func
operator|==
name|OP_ADDU
operator|&&
name|i
operator|.
name|RType
operator|.
name|rt
operator|==
literal|0
condition|)
block|{
name|kdbprintf
argument_list|(
literal|"move\t%s,%s"
argument_list|,
name|reg_name
index|[
name|i
operator|.
name|RType
operator|.
name|rd
index|]
argument_list|,
name|reg_name
index|[
name|i
operator|.
name|RType
operator|.
name|rs
index|]
argument_list|)
expr_stmt|;
break|break;
block|}
name|kdbprintf
argument_list|(
literal|"%s"
argument_list|,
name|spec_name
index|[
name|i
operator|.
name|RType
operator|.
name|func
index|]
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|i
operator|.
name|RType
operator|.
name|func
condition|)
block|{
case|case
name|OP_SLL
case|:
case|case
name|OP_SRL
case|:
case|case
name|OP_SRA
case|:
name|kdbprintf
argument_list|(
literal|"\t%s,%s,%d"
argument_list|,
name|reg_name
index|[
name|i
operator|.
name|RType
operator|.
name|rd
index|]
argument_list|,
name|reg_name
index|[
name|i
operator|.
name|RType
operator|.
name|rt
index|]
argument_list|,
name|i
operator|.
name|RType
operator|.
name|shamt
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_SLLV
case|:
case|case
name|OP_SRLV
case|:
case|case
name|OP_SRAV
case|:
name|kdbprintf
argument_list|(
literal|"\t%s,%s,%s"
argument_list|,
name|reg_name
index|[
name|i
operator|.
name|RType
operator|.
name|rd
index|]
argument_list|,
name|reg_name
index|[
name|i
operator|.
name|RType
operator|.
name|rt
index|]
argument_list|,
name|reg_name
index|[
name|i
operator|.
name|RType
operator|.
name|rs
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_MFHI
case|:
case|case
name|OP_MFLO
case|:
name|kdbprintf
argument_list|(
literal|"\t%s"
argument_list|,
name|reg_name
index|[
name|i
operator|.
name|RType
operator|.
name|rd
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_JR
case|:
case|case
name|OP_JALR
case|:
case|case
name|OP_MTLO
case|:
case|case
name|OP_MTHI
case|:
name|kdbprintf
argument_list|(
literal|"\t%s"
argument_list|,
name|reg_name
index|[
name|i
operator|.
name|RType
operator|.
name|rs
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_MULT
case|:
case|case
name|OP_MULTU
case|:
case|case
name|OP_DIV
case|:
case|case
name|OP_DIVU
case|:
name|kdbprintf
argument_list|(
literal|"\t%s,%s"
argument_list|,
name|reg_name
index|[
name|i
operator|.
name|RType
operator|.
name|rs
index|]
argument_list|,
name|reg_name
index|[
name|i
operator|.
name|RType
operator|.
name|rt
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_SYSCALL
case|:
break|break;
case|case
name|OP_BREAK
case|:
name|kdbprintf
argument_list|(
literal|"\t%d"
argument_list|,
operator|(
name|i
operator|.
name|RType
operator|.
name|rs
operator|<<
literal|5
operator|)
operator||
name|i
operator|.
name|RType
operator|.
name|rt
argument_list|)
expr_stmt|;
break|break;
default|default:
name|kdbprintf
argument_list|(
literal|"\t%s,%s,%s"
argument_list|,
name|reg_name
index|[
name|i
operator|.
name|RType
operator|.
name|rd
index|]
argument_list|,
name|reg_name
index|[
name|i
operator|.
name|RType
operator|.
name|rs
index|]
argument_list|,
name|reg_name
index|[
name|i
operator|.
name|RType
operator|.
name|rt
index|]
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
break|break;
case|case
name|OP_BCOND
case|:
name|kdbprintf
argument_list|(
literal|"%s\t%s,"
argument_list|,
name|bcond_name
index|[
name|i
operator|.
name|IType
operator|.
name|rt
index|]
argument_list|,
name|reg_name
index|[
name|i
operator|.
name|IType
operator|.
name|rs
index|]
argument_list|)
expr_stmt|;
goto|goto
name|pr_displ
goto|;
case|case
name|OP_BLEZ
case|:
case|case
name|OP_BGTZ
case|:
name|kdbprintf
argument_list|(
literal|"%s\t%s,"
argument_list|,
name|op_name
index|[
name|i
operator|.
name|IType
operator|.
name|op
index|]
argument_list|,
name|reg_name
index|[
name|i
operator|.
name|IType
operator|.
name|rs
index|]
argument_list|)
expr_stmt|;
goto|goto
name|pr_displ
goto|;
case|case
name|OP_BEQ
case|:
if|if
condition|(
name|i
operator|.
name|IType
operator|.
name|rs
operator|==
literal|0
operator|&&
name|i
operator|.
name|IType
operator|.
name|rt
operator|==
literal|0
condition|)
block|{
name|kdbprintf
argument_list|(
literal|"b\t"
argument_list|)
expr_stmt|;
goto|goto
name|pr_displ
goto|;
block|}
comment|/* FALLTHROUGH */
case|case
name|OP_BNE
case|:
name|kdbprintf
argument_list|(
literal|"%s\t%s,%s,"
argument_list|,
name|op_name
index|[
name|i
operator|.
name|IType
operator|.
name|op
index|]
argument_list|,
name|reg_name
index|[
name|i
operator|.
name|IType
operator|.
name|rs
index|]
argument_list|,
name|reg_name
index|[
name|i
operator|.
name|IType
operator|.
name|rt
index|]
argument_list|)
expr_stmt|;
name|pr_displ
label|:
name|kdbpsymoff
argument_list|(
name|kdbdot
operator|+
literal|4
operator|+
operator|(
operator|(
name|short
operator|)
name|i
operator|.
name|IType
operator|.
name|imm
operator|<<
literal|2
operator|)
argument_list|,
name|ISYM
argument_list|,
literal|""
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_COP0
case|:
switch|switch
condition|(
name|i
operator|.
name|RType
operator|.
name|rs
condition|)
block|{
case|case
name|OP_BCx
case|:
case|case
name|OP_BCy
case|:
name|kdbprintf
argument_list|(
literal|"bc0%c\t"
argument_list|,
literal|"ft"
index|[
name|i
operator|.
name|RType
operator|.
name|rt
operator|&
name|COPz_BC_TF_MASK
index|]
argument_list|)
expr_stmt|;
goto|goto
name|pr_displ
goto|;
case|case
name|OP_MT
case|:
name|kdbprintf
argument_list|(
literal|"mtc0\t%s,%s"
argument_list|,
name|reg_name
index|[
name|i
operator|.
name|RType
operator|.
name|rt
index|]
argument_list|,
name|c0_reg
index|[
name|i
operator|.
name|RType
operator|.
name|rd
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_MF
case|:
name|kdbprintf
argument_list|(
literal|"mfc0\t%s,%s"
argument_list|,
name|reg_name
index|[
name|i
operator|.
name|RType
operator|.
name|rt
index|]
argument_list|,
name|c0_reg
index|[
name|i
operator|.
name|RType
operator|.
name|rd
index|]
argument_list|)
expr_stmt|;
break|break;
default|default:
name|kdbprintf
argument_list|(
literal|"%s"
argument_list|,
name|c0_opname
index|[
name|i
operator|.
name|FRType
operator|.
name|func
index|]
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
break|break;
case|case
name|OP_COP1
case|:
switch|switch
condition|(
name|i
operator|.
name|RType
operator|.
name|rs
condition|)
block|{
case|case
name|OP_BCx
case|:
case|case
name|OP_BCy
case|:
name|kdbprintf
argument_list|(
literal|"bc1%c\t"
argument_list|,
literal|"ft"
index|[
name|i
operator|.
name|RType
operator|.
name|rt
operator|&
name|COPz_BC_TF_MASK
index|]
argument_list|)
expr_stmt|;
goto|goto
name|pr_displ
goto|;
case|case
name|OP_MT
case|:
name|kdbprintf
argument_list|(
literal|"mtc1\t%s,f%d"
argument_list|,
name|reg_name
index|[
name|i
operator|.
name|RType
operator|.
name|rt
index|]
argument_list|,
name|i
operator|.
name|RType
operator|.
name|rd
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_MF
case|:
name|kdbprintf
argument_list|(
literal|"mfc1\t%s,f%d"
argument_list|,
name|reg_name
index|[
name|i
operator|.
name|RType
operator|.
name|rt
index|]
argument_list|,
name|i
operator|.
name|RType
operator|.
name|rd
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_CT
case|:
name|kdbprintf
argument_list|(
literal|"ctc1\t%s,f%d"
argument_list|,
name|reg_name
index|[
name|i
operator|.
name|RType
operator|.
name|rt
index|]
argument_list|,
name|i
operator|.
name|RType
operator|.
name|rd
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_CF
case|:
name|kdbprintf
argument_list|(
literal|"cfc1\t%s,f%d"
argument_list|,
name|reg_name
index|[
name|i
operator|.
name|RType
operator|.
name|rt
index|]
argument_list|,
name|i
operator|.
name|RType
operator|.
name|rd
argument_list|)
expr_stmt|;
break|break;
default|default:
name|kdbprintf
argument_list|(
literal|"%s.%s\tf%d,f%d,f%d"
argument_list|,
name|cop1_name
index|[
name|i
operator|.
name|FRType
operator|.
name|func
index|]
argument_list|,
name|fmt_name
index|[
name|i
operator|.
name|FRType
operator|.
name|fmt
index|]
argument_list|,
name|i
operator|.
name|FRType
operator|.
name|fd
argument_list|,
name|i
operator|.
name|FRType
operator|.
name|fs
argument_list|,
name|i
operator|.
name|FRType
operator|.
name|ft
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
break|break;
case|case
name|OP_J
case|:
case|case
name|OP_JAL
case|:
name|kdbprintf
argument_list|(
literal|"%s\t"
argument_list|,
name|op_name
index|[
name|i
operator|.
name|JType
operator|.
name|op
index|]
argument_list|)
expr_stmt|;
name|kdbpsymoff
argument_list|(
operator|(
name|kdbdot
operator|&
literal|0xF0000000
operator|)
operator||
operator|(
name|i
operator|.
name|JType
operator|.
name|target
operator|<<
literal|2
operator|)
argument_list|,
name|ISYM
argument_list|,
literal|""
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_LWC1
case|:
case|case
name|OP_SWC1
case|:
name|kdbprintf
argument_list|(
literal|"%s\tf%d,"
argument_list|,
name|op_name
index|[
name|i
operator|.
name|IType
operator|.
name|op
index|]
argument_list|,
name|i
operator|.
name|IType
operator|.
name|rt
argument_list|)
expr_stmt|;
goto|goto
name|loadstore
goto|;
case|case
name|OP_LB
case|:
case|case
name|OP_LH
case|:
case|case
name|OP_LW
case|:
case|case
name|OP_LBU
case|:
case|case
name|OP_LHU
case|:
case|case
name|OP_SB
case|:
case|case
name|OP_SH
case|:
case|case
name|OP_SW
case|:
name|kdbprintf
argument_list|(
literal|"%s\t%s,"
argument_list|,
name|op_name
index|[
name|i
operator|.
name|IType
operator|.
name|op
index|]
argument_list|,
name|reg_name
index|[
name|i
operator|.
name|IType
operator|.
name|rt
index|]
argument_list|)
expr_stmt|;
name|loadstore
label|:
name|kdbprintf
argument_list|(
literal|"%d(%s)"
argument_list|,
operator|(
name|short
operator|)
name|i
operator|.
name|IType
operator|.
name|imm
argument_list|,
name|reg_name
index|[
name|i
operator|.
name|IType
operator|.
name|rs
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_ORI
case|:
case|case
name|OP_XORI
case|:
if|if
condition|(
name|i
operator|.
name|IType
operator|.
name|rs
operator|==
literal|0
condition|)
block|{
name|kdbprintf
argument_list|(
literal|"li\t%s,0x%X"
argument_list|,
name|reg_name
index|[
name|i
operator|.
name|IType
operator|.
name|rt
index|]
argument_list|,
name|i
operator|.
name|IType
operator|.
name|imm
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* FALLTHROUGH */
case|case
name|OP_ANDI
case|:
name|kdbprintf
argument_list|(
literal|"%s\t%s,%s,0x%X"
argument_list|,
name|op_name
index|[
name|i
operator|.
name|IType
operator|.
name|op
index|]
argument_list|,
name|reg_name
index|[
name|i
operator|.
name|IType
operator|.
name|rt
index|]
argument_list|,
name|reg_name
index|[
name|i
operator|.
name|IType
operator|.
name|rs
index|]
argument_list|,
name|i
operator|.
name|IType
operator|.
name|imm
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_LUI
case|:
name|kdbprintf
argument_list|(
literal|"%s\t%s,0x%X"
argument_list|,
name|op_name
index|[
name|i
operator|.
name|IType
operator|.
name|op
index|]
argument_list|,
name|reg_name
index|[
name|i
operator|.
name|IType
operator|.
name|rt
index|]
argument_list|,
name|i
operator|.
name|IType
operator|.
name|imm
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_ADDI
case|:
case|case
name|OP_ADDIU
case|:
if|if
condition|(
name|i
operator|.
name|IType
operator|.
name|rs
operator|==
literal|0
condition|)
block|{
name|kdbprintf
argument_list|(
literal|"li\t%s,%D"
argument_list|,
name|reg_name
index|[
name|i
operator|.
name|IType
operator|.
name|rt
index|]
argument_list|,
operator|(
name|short
operator|)
name|i
operator|.
name|IType
operator|.
name|imm
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* FALLTHROUGH */
default|default:
name|kdbprintf
argument_list|(
literal|"%s\t%s,%s,%D"
argument_list|,
name|op_name
index|[
name|i
operator|.
name|IType
operator|.
name|op
index|]
argument_list|,
name|reg_name
index|[
name|i
operator|.
name|IType
operator|.
name|rt
index|]
argument_list|,
name|reg_name
index|[
name|i
operator|.
name|IType
operator|.
name|rs
index|]
argument_list|,
operator|(
name|short
operator|)
name|i
operator|.
name|IType
operator|.
name|imm
argument_list|)
expr_stmt|;
block|}
name|kdbdotinc
operator|=
literal|4
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|MIPS_JR_RA
value|0x03e00008
end_define

begin_comment
comment|/* instruction code for jr ra */
end_comment

begin_comment
comment|/*  * Print a stack backtrace.  */
end_comment

begin_function
name|void
name|kdbstacktrace
parameter_list|(
name|printlocals
parameter_list|)
name|int
name|printlocals
decl_stmt|;
block|{
name|unsigned
name|pc
decl_stmt|,
name|sp
decl_stmt|,
name|ra
decl_stmt|,
name|va
decl_stmt|,
name|subr
decl_stmt|;
name|int
name|a0
decl_stmt|,
name|a1
decl_stmt|,
name|a2
decl_stmt|,
name|a3
decl_stmt|;
name|unsigned
name|instr
decl_stmt|,
name|mask
decl_stmt|;
name|InstFmt
name|i
decl_stmt|;
name|int
name|more
decl_stmt|,
name|stksize
decl_stmt|;
extern|extern MachKernGenException(
block|)
function|;
end_function

begin_extern
extern|extern MachUserGenException(
end_extern

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_extern
extern|extern MachKernIntr(
end_extern

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_extern
extern|extern MachUserIntr(
end_extern

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_extern
extern|extern setsoftclock(
end_extern

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_comment
comment|/* get initial values from the exception frame */
end_comment

begin_expr_stmt
name|sp
operator|=
name|kdbpcb
operator|.
name|pcb_regs
index|[
name|SP
index|]
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|pc
operator|=
name|kdbpcb
operator|.
name|pcb_regs
index|[
name|PC
index|]
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|ra
operator|=
name|kdbpcb
operator|.
name|pcb_regs
index|[
name|RA
index|]
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|a0
operator|=
name|kdbpcb
operator|.
name|pcb_regs
index|[
name|A0
index|]
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|a1
operator|=
name|kdbpcb
operator|.
name|pcb_regs
index|[
name|A1
index|]
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|a2
operator|=
name|kdbpcb
operator|.
name|pcb_regs
index|[
name|A2
index|]
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|a3
operator|=
name|kdbpcb
operator|.
name|pcb_regs
index|[
name|A3
index|]
expr_stmt|;
end_expr_stmt

begin_label
name|loop
label|:
end_label

begin_comment
comment|/* check for current PC in the kernel interrupt handler code */
end_comment

begin_if
if|if
condition|(
name|pc
operator|>=
operator|(
name|unsigned
operator|)
name|MachKernIntr
operator|&&
name|pc
operator|<
operator|(
name|unsigned
operator|)
name|MachUserIntr
condition|)
block|{
comment|/* NOTE: the offsets depend on the code in locore.s */
name|kdbprintf
argument_list|(
literal|"interupt\n"
argument_list|)
expr_stmt|;
name|a0
operator|=
name|kdbchkget
argument_list|(
name|sp
operator|+
literal|36
argument_list|,
name|DSP
argument_list|)
expr_stmt|;
name|a1
operator|=
name|kdbchkget
argument_list|(
name|sp
operator|+
literal|40
argument_list|,
name|DSP
argument_list|)
expr_stmt|;
name|a2
operator|=
name|kdbchkget
argument_list|(
name|sp
operator|+
literal|44
argument_list|,
name|DSP
argument_list|)
expr_stmt|;
name|a3
operator|=
name|kdbchkget
argument_list|(
name|sp
operator|+
literal|48
argument_list|,
name|DSP
argument_list|)
expr_stmt|;
name|pc
operator|=
name|kdbchkget
argument_list|(
name|sp
operator|+
literal|20
argument_list|,
name|DSP
argument_list|)
expr_stmt|;
name|ra
operator|=
name|kdbchkget
argument_list|(
name|sp
operator|+
literal|92
argument_list|,
name|DSP
argument_list|)
expr_stmt|;
name|sp
operator|=
name|kdbchkget
argument_list|(
name|sp
operator|+
literal|100
argument_list|,
name|DSP
argument_list|)
expr_stmt|;
block|}
end_if

begin_comment
comment|/* check for current PC in the exception handler code */
end_comment

begin_if
if|if
condition|(
name|pc
operator|>=
literal|0x80000000
operator|&&
name|pc
operator|<
operator|(
name|unsigned
operator|)
name|setsoftclock
condition|)
block|{
name|ra
operator|=
literal|0
expr_stmt|;
name|subr
operator|=
literal|0
expr_stmt|;
goto|goto
name|done
goto|;
block|}
end_if

begin_comment
comment|/* 	 * Find the beginning of the current subroutine by scanning backwards 	 * from the current PC for the end of the previous subroutine. 	 */
end_comment

begin_expr_stmt
name|va
operator|=
name|pc
operator|-
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
end_expr_stmt

begin_while
while|while
condition|(
operator|(
name|instr
operator|=
name|kdbchkget
argument_list|(
name|va
argument_list|,
name|ISP
argument_list|)
operator|)
operator|!=
name|MIPS_JR_RA
condition|)
name|va
operator|-=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
end_while

begin_expr_stmt
name|va
operator|+=
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* skip back over branch& delay slot */
end_comment

begin_comment
comment|/* skip over nulls which might separate .o files */
end_comment

begin_while
while|while
condition|(
operator|(
name|instr
operator|=
name|kdbchkget
argument_list|(
name|va
argument_list|,
name|ISP
argument_list|)
operator|)
operator|==
literal|0
condition|)
name|va
operator|+=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
end_while

begin_expr_stmt
name|subr
operator|=
name|va
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* scan forwards to find stack size and any saved registers */
end_comment

begin_expr_stmt
name|stksize
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|more
operator|=
literal|3
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|mask
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_for
for|for
control|(
init|;
name|more
condition|;
name|va
operator|+=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|,
name|more
operator|=
operator|(
name|more
operator|==
literal|3
operator|)
condition|?
literal|3
else|:
name|more
operator|-
literal|1
control|)
block|{
comment|/* stop if hit our current position */
if|if
condition|(
name|va
operator|>=
name|pc
condition|)
break|break;
name|instr
operator|=
name|kdbchkget
argument_list|(
name|va
argument_list|,
name|ISP
argument_list|)
expr_stmt|;
name|i
operator|.
name|word
operator|=
name|instr
expr_stmt|;
switch|switch
condition|(
name|i
operator|.
name|JType
operator|.
name|op
condition|)
block|{
case|case
name|OP_SPECIAL
case|:
switch|switch
condition|(
name|i
operator|.
name|RType
operator|.
name|func
condition|)
block|{
case|case
name|OP_JR
case|:
case|case
name|OP_JALR
case|:
name|more
operator|=
literal|2
expr_stmt|;
comment|/* stop after next instruction */
break|break;
case|case
name|OP_SYSCALL
case|:
case|case
name|OP_BREAK
case|:
name|more
operator|=
literal|1
expr_stmt|;
comment|/* stop now */
block|}
empty_stmt|;
break|break;
case|case
name|OP_BCOND
case|:
case|case
name|OP_J
case|:
case|case
name|OP_JAL
case|:
case|case
name|OP_BEQ
case|:
case|case
name|OP_BNE
case|:
case|case
name|OP_BLEZ
case|:
case|case
name|OP_BGTZ
case|:
name|more
operator|=
literal|2
expr_stmt|;
comment|/* stop after next instruction */
break|break;
case|case
name|OP_COP0
case|:
case|case
name|OP_COP1
case|:
case|case
name|OP_COP2
case|:
case|case
name|OP_COP3
case|:
switch|switch
condition|(
name|i
operator|.
name|RType
operator|.
name|rs
condition|)
block|{
case|case
name|OP_BCx
case|:
case|case
name|OP_BCy
case|:
name|more
operator|=
literal|2
expr_stmt|;
comment|/* stop after next instruction */
block|}
empty_stmt|;
break|break;
case|case
name|OP_SW
case|:
comment|/* look for saved registers on the stack */
if|if
condition|(
name|i
operator|.
name|IType
operator|.
name|rs
operator|!=
literal|29
condition|)
break|break;
comment|/* only restore the first one */
if|if
condition|(
name|mask
operator|&
operator|(
literal|1
operator|<<
name|i
operator|.
name|IType
operator|.
name|rt
operator|)
condition|)
break|break;
name|mask
operator||=
literal|1
operator|<<
name|i
operator|.
name|IType
operator|.
name|rt
expr_stmt|;
switch|switch
condition|(
name|i
operator|.
name|IType
operator|.
name|rt
condition|)
block|{
case|case
literal|4
case|:
comment|/* a0 */
name|a0
operator|=
name|kdbchkget
argument_list|(
name|sp
operator|+
operator|(
name|short
operator|)
name|i
operator|.
name|IType
operator|.
name|imm
argument_list|,
name|DSP
argument_list|)
expr_stmt|;
break|break;
case|case
literal|5
case|:
comment|/* a1 */
name|a1
operator|=
name|kdbchkget
argument_list|(
name|sp
operator|+
operator|(
name|short
operator|)
name|i
operator|.
name|IType
operator|.
name|imm
argument_list|,
name|DSP
argument_list|)
expr_stmt|;
break|break;
case|case
literal|6
case|:
comment|/* a2 */
name|a2
operator|=
name|kdbchkget
argument_list|(
name|sp
operator|+
operator|(
name|short
operator|)
name|i
operator|.
name|IType
operator|.
name|imm
argument_list|,
name|DSP
argument_list|)
expr_stmt|;
break|break;
case|case
literal|7
case|:
comment|/* a3 */
name|a3
operator|=
name|kdbchkget
argument_list|(
name|sp
operator|+
operator|(
name|short
operator|)
name|i
operator|.
name|IType
operator|.
name|imm
argument_list|,
name|DSP
argument_list|)
expr_stmt|;
break|break;
case|case
literal|31
case|:
comment|/* ra */
name|ra
operator|=
name|kdbchkget
argument_list|(
name|sp
operator|+
operator|(
name|short
operator|)
name|i
operator|.
name|IType
operator|.
name|imm
argument_list|,
name|DSP
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|OP_ADDI
case|:
case|case
name|OP_ADDIU
case|:
comment|/* look for stack pointer adjustment */
if|if
condition|(
name|i
operator|.
name|IType
operator|.
name|rs
operator|!=
literal|29
operator|&&
name|i
operator|.
name|IType
operator|.
name|rt
operator|!=
literal|29
condition|)
break|break;
name|stksize
operator|=
operator|(
name|short
operator|)
name|i
operator|.
name|IType
operator|.
name|imm
expr_stmt|;
block|}
block|}
end_for

begin_label
name|done
label|:
end_label

begin_if
if|#
directive|if
literal|0
end_if

begin_else
unit|kdbpsymoff((long)pc, ISYM, "");
else|#
directive|else
end_else

begin_expr_stmt
name|kdbprintf
argument_list|(
literal|"%X+%X "
argument_list|,
name|subr
argument_list|,
name|pc
operator|-
name|subr
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* XXX */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_expr_stmt
name|kdbprintf
argument_list|(
literal|"(%X,%X,%X,%X)\n"
argument_list|,
name|a0
argument_list|,
name|a1
argument_list|,
name|a2
argument_list|,
name|a3
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|ra
condition|)
block|{
name|pc
operator|=
name|ra
expr_stmt|;
name|sp
operator|-=
name|stksize
expr_stmt|;
goto|goto
name|loop
goto|;
block|}
end_if

begin_comment
unit|}
comment|/*  * Very simple memory allocator for kdb.  */
end_comment

begin_expr_stmt
unit|char
operator|*
name|kdbmalloc
argument_list|(
argument|size
argument_list|)
name|int
name|size
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|static
name|char
name|buffer
index|[
literal|4096
index|]
decl_stmt|;
specifier|static
name|char
modifier|*
name|bufp
init|=
name|buffer
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
comment|/* round size up to sizeof(int) */
name|size
operator|=
operator|(
name|size
operator|+
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|-
literal|1
operator|)
operator|&
operator|~
operator|(
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|-
literal|1
operator|)
expr_stmt|;
name|p
operator|=
name|bufp
expr_stmt|;
name|bufp
operator|=
name|p
operator|+
name|size
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Machine dependent printing '$'.  * Return zero if modif character not recognized.  */
end_comment

begin_macro
name|kdbprintmachdep
argument_list|(
argument|modif
argument_list|)
end_macro

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
specifier|extern
name|int
name|tlbhi
decl_stmt|,
name|tlblo
decl_stmt|;
switch|switch
condition|(
name|modif
condition|)
block|{
case|case
literal|'p'
case|:
case|case
literal|'P'
case|:
comment|/* print TLB entries */
if|if
condition|(
name|kdbadrflg
condition|)
block|{
name|i
operator|=
name|kdbadrval
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
operator|||
name|i
operator|>
name|VMMACH_NUM_TLB_ENTRIES
condition|)
block|{
specifier|extern
name|char
modifier|*
name|kdbBADMOD
decl_stmt|;
name|kdberror
argument_list|(
name|kdbBADMOD
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|kdbcntflg
operator|==
literal|0
condition|)
name|j
operator|=
name|i
operator|+
literal|1
expr_stmt|;
else|else
block|{
name|j
operator|=
name|i
operator|+
name|kdbcntval
expr_stmt|;
if|if
condition|(
name|j
operator|>
name|VMMACH_NUM_TLB_ENTRIES
condition|)
name|j
operator|=
name|VMMACH_NUM_TLB_ENTRIES
expr_stmt|;
block|}
block|}
else|else
block|{
name|i
operator|=
literal|0
expr_stmt|;
name|j
operator|=
name|VMMACH_NUM_TLB_ENTRIES
expr_stmt|;
block|}
for|for
control|(
init|;
name|i
operator|<
name|j
condition|;
name|i
operator|++
control|)
block|{
name|MachTLBRead
argument_list|(
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|modif
operator|==
literal|'p'
operator|&&
operator|!
operator|(
name|tlblo
operator|&
name|PG_V
operator|)
condition|)
continue|continue;
name|kdbprintf
argument_list|(
literal|"TLB %2d: hi %8X low %8X\n"
argument_list|,
name|i
argument_list|,
name|tlbhi
argument_list|,
name|tlblo
argument_list|)
expr_stmt|;
block|}
name|kdbprintf
argument_list|(
literal|"TLB PID %x\n"
argument_list|,
name|MachTLBGetPID
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
comment|/* find a TLB entry by virtaddr */
case|case
literal|'F'
case|:
comment|/* find a TLB entry by physaddr */
name|j
operator|=
name|kdbdot
operator|&
name|PG_FRAME
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|VMMACH_NUM_TLB_ENTRIES
condition|;
name|i
operator|++
control|)
block|{
name|MachTLBRead
argument_list|(
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|modif
operator|==
literal|'f'
condition|)
block|{
if|if
condition|(
operator|(
name|tlbhi
operator|&
name|PG_FRAME
operator|)
operator|!=
name|j
condition|)
continue|continue;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|tlblo
operator|&
name|PG_FRAME
operator|)
operator|!=
name|j
condition|)
continue|continue;
block|}
name|kdbprintf
argument_list|(
literal|"TLB %2d: hi %8X low %8X\n"
argument_list|,
name|i
argument_list|,
name|tlbhi
argument_list|,
name|tlblo
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

end_unit

