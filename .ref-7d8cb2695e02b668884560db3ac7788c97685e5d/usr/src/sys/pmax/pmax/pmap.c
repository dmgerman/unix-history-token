begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*   * Copyright (c) 1992 The Regents of the University of California.  * All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * the Systems Programming Group of the University of Utah Computer  * Science Department and Ralph Campbell.  *  * %sccs.include.redist.c%  *  *	@(#)pmap.c	7.14 (Berkeley) %G%  */
end_comment

begin_comment
comment|/*  *	Manages physical address maps.  *  *	In addition to hardware address maps, this  *	module is called upon to provide software-use-only  *	maps which may or may not be stored in the same  *	form as hardware maps.  These pseudo-maps are  *	used to store intermediate results from copy  *	operations to and from address spaces.  *  *	Since the information managed by this module is  *	also stored by the logical address mapping module,  *	this module may throw away valid virtual-to-physical  *	mappings at almost any time.  However, invalidations  *	of virtual-to-physical mappings must be done as  *	requested.  *  *	In order to cope with hardware architectures which  *	make virtual-to-physical map invalidates expensive,  *	this module may delay invalidate or reduced protection  *	operations until such time as they are actually  *	necessary.  This module is given full information as  *	to which processors are currently using which maps,  *	and to when physical maps must be made correct.  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/user.h>
end_include

begin_include
include|#
directive|include
file|<sys/buf.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_kern.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_page.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_pageout.h>
end_include

begin_include
include|#
directive|include
file|<machine/machConst.h>
end_include

begin_include
include|#
directive|include
file|<machine/pte.h>
end_include

begin_decl_stmt
specifier|extern
name|vm_page_t
name|vm_page_alloc1
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|vm_page_free1
name|__P
argument_list|(
operator|(
name|vm_page_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * For each vm_page_t, there is a list of all currently valid virtual  * mappings of that page.  An entry is a pv_entry_t, the list is pv_table.  * XXX really should do this as a part of the higher level code.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|pv_entry
block|{
name|struct
name|pv_entry
modifier|*
name|pv_next
decl_stmt|;
comment|/* next pv_entry */
name|struct
name|pmap
modifier|*
name|pv_pmap
decl_stmt|;
comment|/* pmap where mapping lies */
name|vm_offset_t
name|pv_va
decl_stmt|;
comment|/* virtual address for mapping */
block|}
typedef|*
name|pv_entry_t
typedef|;
end_typedef

begin_decl_stmt
name|pv_entry_t
name|pv_table
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* array of entries, one per page */
end_comment

begin_function_decl
specifier|extern
name|void
name|pmap_remove_pv
parameter_list|()
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|pa_index
parameter_list|(
name|pa
parameter_list|)
value|atop((pa) - first_phys_addr)
end_define

begin_define
define|#
directive|define
name|pa_to_pvh
parameter_list|(
name|pa
parameter_list|)
value|(&pv_table[pa_index(pa)])
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_struct
struct|struct
block|{
name|int
name|kernel
decl_stmt|;
comment|/* entering kernel mapping */
name|int
name|user
decl_stmt|;
comment|/* entering user mapping */
name|int
name|ptpneeded
decl_stmt|;
comment|/* needed to allocate a PT page */
name|int
name|pwchange
decl_stmt|;
comment|/* no mapping change, just wiring or protection */
name|int
name|wchange
decl_stmt|;
comment|/* no mapping change, just wiring */
name|int
name|mchange
decl_stmt|;
comment|/* was mapped but mapping to different page */
name|int
name|managed
decl_stmt|;
comment|/* a managed page */
name|int
name|firstpv
decl_stmt|;
comment|/* first mapping for this PA */
name|int
name|secondpv
decl_stmt|;
comment|/* second mapping for this PA */
name|int
name|ci
decl_stmt|;
comment|/* cache inhibited */
name|int
name|unmanaged
decl_stmt|;
comment|/* not a managed page */
name|int
name|flushes
decl_stmt|;
comment|/* cache flushes */
name|int
name|cachehit
decl_stmt|;
comment|/* new entry forced valid entry out */
block|}
name|enter_stats
struct|;
end_struct

begin_struct
struct|struct
block|{
name|int
name|calls
decl_stmt|;
name|int
name|removes
decl_stmt|;
name|int
name|flushes
decl_stmt|;
name|int
name|pidflushes
decl_stmt|;
comment|/* HW pid stolen */
name|int
name|pvfirst
decl_stmt|;
name|int
name|pvsearch
decl_stmt|;
block|}
name|remove_stats
struct|;
end_struct

begin_decl_stmt
name|int
name|pmapdebug
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|PDB_FOLLOW
value|0x0001
end_define

begin_define
define|#
directive|define
name|PDB_INIT
value|0x0002
end_define

begin_define
define|#
directive|define
name|PDB_ENTER
value|0x0004
end_define

begin_define
define|#
directive|define
name|PDB_REMOVE
value|0x0008
end_define

begin_define
define|#
directive|define
name|PDB_CREATE
value|0x0010
end_define

begin_define
define|#
directive|define
name|PDB_PTPAGE
value|0x0020
end_define

begin_define
define|#
directive|define
name|PDB_PVENTRY
value|0x0040
end_define

begin_define
define|#
directive|define
name|PDB_BITS
value|0x0080
end_define

begin_define
define|#
directive|define
name|PDB_COLLECT
value|0x0100
end_define

begin_define
define|#
directive|define
name|PDB_PROTECT
value|0x0200
end_define

begin_define
define|#
directive|define
name|PDB_TLBPID
value|0x0400
end_define

begin_define
define|#
directive|define
name|PDB_PARANOIA
value|0x2000
end_define

begin_define
define|#
directive|define
name|PDB_WIRING
value|0x4000
end_define

begin_define
define|#
directive|define
name|PDB_PVDUMP
value|0x8000
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DEBUG */
end_comment

begin_decl_stmt
name|struct
name|pmap
name|kernel_pmap_store
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|vm_offset_t
name|avail_start
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* PA of first available physical page */
end_comment

begin_decl_stmt
name|vm_offset_t
name|avail_end
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* PA of last available physical page */
end_comment

begin_decl_stmt
name|vm_size_t
name|mem_size
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* memory size in bytes */
end_comment

begin_decl_stmt
name|vm_offset_t
name|virtual_avail
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* VA of first avail page (after kernel bss)*/
end_comment

begin_decl_stmt
name|vm_offset_t
name|virtual_end
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* VA of last avail page (end of kernel AS) */
end_comment

begin_decl_stmt
name|int
name|pmaxpagesperpage
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* PAGE_SIZE / NBPG */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|ATTR
end_ifdef

begin_decl_stmt
name|char
modifier|*
name|pmap_attributes
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* reference and modify bits */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|struct
name|segtab
modifier|*
name|free_segtab
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* free list kept locally */
end_comment

begin_decl_stmt
name|u_int
name|tlbpid_gen
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* TLB PID generation count */
end_comment

begin_decl_stmt
name|int
name|tlbpid_cnt
init|=
literal|2
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* next available TLB PID */
end_comment

begin_decl_stmt
name|pt_entry_t
modifier|*
name|Sysmap
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* kernel pte table */
end_comment

begin_decl_stmt
name|u_int
name|Sysmapsize
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of pte's in Sysmap */
end_comment

begin_comment
comment|/*  *	Bootstrap the system enough to run with virtual memory.  *	firstaddr is the first unused kseg0 address (not page aligned).  */
end_comment

begin_function
name|void
name|pmap_bootstrap
parameter_list|(
name|firstaddr
parameter_list|)
name|vm_offset_t
name|firstaddr
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|vm_offset_t
name|start
init|=
name|firstaddr
decl_stmt|;
specifier|extern
name|int
name|maxmem
decl_stmt|,
name|physmem
decl_stmt|;
define|#
directive|define
name|valloc
parameter_list|(
name|name
parameter_list|,
name|type
parameter_list|,
name|num
parameter_list|)
define|\
value|(name) = (type *)firstaddr; firstaddr = (vm_offset_t)((name)+(num))
comment|/* 	 * Allocate a PTE table for the kernel. 	 * The first '256' comes from PAGER_MAP_SIZE in vm_pager_init(). 	 * This should be kept in sync. 	 * We also reserve space for kmem_alloc_pageable() for vm_fork(). 	 */
name|Sysmapsize
operator|=
operator|(
name|VM_KMEM_SIZE
operator|+
name|VM_MBUF_SIZE
operator|+
name|VM_PHYS_SIZE
operator|+
name|nbuf
operator|*
name|MAXBSIZE
operator|+
literal|16
operator|*
name|NCARGS
operator|)
operator|/
name|NBPG
operator|+
literal|256
operator|+
literal|256
expr_stmt|;
name|valloc
argument_list|(
name|Sysmap
argument_list|,
name|pt_entry_t
argument_list|,
name|Sysmapsize
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ATTR
name|valloc
argument_list|(
name|pmap_attributes
argument_list|,
name|char
argument_list|,
name|physmem
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Allocate memory for pv_table. 	 * This will allocate more entries than we really need. 	 * We could do this in pmap_init when we know the actual 	 * phys_start and phys_end but its better to use kseg0 addresses 	 * rather than kernel virtual addresses mapped through the TLB. 	 */
name|i
operator|=
name|maxmem
operator|-
name|pmax_btop
argument_list|(
name|MACH_CACHED_TO_PHYS
argument_list|(
name|firstaddr
argument_list|)
argument_list|)
expr_stmt|;
name|valloc
argument_list|(
name|pv_table
argument_list|,
expr|struct
name|pv_entry
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|/* 	 * Clear allocated memory. 	 */
name|firstaddr
operator|=
name|pmax_round_page
argument_list|(
name|firstaddr
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|caddr_t
operator|)
name|start
argument_list|,
name|firstaddr
operator|-
name|start
argument_list|)
expr_stmt|;
name|avail_start
operator|=
name|MACH_CACHED_TO_PHYS
argument_list|(
name|firstaddr
argument_list|)
expr_stmt|;
name|avail_end
operator|=
name|pmax_ptob
argument_list|(
name|maxmem
argument_list|)
expr_stmt|;
name|mem_size
operator|=
name|avail_end
operator|-
name|avail_start
expr_stmt|;
name|virtual_avail
operator|=
name|VM_MIN_KERNEL_ADDRESS
expr_stmt|;
name|virtual_end
operator|=
name|VM_MIN_KERNEL_ADDRESS
operator|+
name|Sysmapsize
operator|*
name|NBPG
expr_stmt|;
comment|/* XXX need to decide how to set cnt.v_page_size */
name|pmaxpagesperpage
operator|=
literal|1
expr_stmt|;
name|simple_lock_init
argument_list|(
operator|&
name|kernel_pmap_store
operator|.
name|pm_lock
argument_list|)
expr_stmt|;
name|kernel_pmap_store
operator|.
name|pm_count
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Bootstrap memory allocator. This function allows for early dynamic  * memory allocation until the virtual memory system has been bootstrapped.  * After that point, either kmem_alloc or malloc should be used. This  * function works by stealing pages from the (to be) managed page pool,  * stealing virtual address space, then mapping the pages and zeroing them.  *  * It should be used from pmap_bootstrap till vm_page_startup, afterwards  * it cannot be used, and will generate a panic if tried. Note that this  * memory will never be freed, and in essence it is wired down.  */
end_comment

begin_function
name|void
modifier|*
name|pmap_bootstrap_alloc
parameter_list|(
name|size
parameter_list|)
name|int
name|size
decl_stmt|;
block|{
name|vm_offset_t
name|val
decl_stmt|;
specifier|extern
name|boolean_t
name|vm_page_startup_initialized
decl_stmt|;
if|if
condition|(
name|vm_page_startup_initialized
condition|)
name|panic
argument_list|(
literal|"pmap_bootstrap_alloc: called after startup initialized"
argument_list|)
expr_stmt|;
name|val
operator|=
name|MACH_PHYS_TO_CACHED
argument_list|(
name|avail_start
argument_list|)
expr_stmt|;
name|size
operator|=
name|round_page
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|avail_start
operator|+=
name|size
expr_stmt|;
name|blkclr
argument_list|(
operator|(
name|caddr_t
operator|)
name|val
argument_list|,
name|size
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|void
operator|*
operator|)
name|val
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *	Initialize the pmap module.  *	Called by vm_init, to initialize any structures that the pmap  *	system needs to map virtual memory.  */
end_comment

begin_function
name|void
name|pmap_init
parameter_list|(
name|phys_start
parameter_list|,
name|phys_end
parameter_list|)
name|vm_offset_t
name|phys_start
decl_stmt|,
name|phys_end
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|pmapdebug
operator|&
operator|(
name|PDB_FOLLOW
operator||
name|PDB_INIT
operator|)
condition|)
name|printf
argument_list|(
literal|"pmap_init(%x, %x)\n"
argument_list|,
name|phys_start
argument_list|,
name|phys_end
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  *	Create and return a physical map.  *  *	If the size specified for the map  *	is zero, the map is an actual physical  *	map, and may be referenced by the  *	hardware.  *  *	If the size specified is non-zero,  *	the map will be used in software only, and  *	is bounded by that size.  */
end_comment

begin_function
name|pmap_t
name|pmap_create
parameter_list|(
name|size
parameter_list|)
name|vm_size_t
name|size
decl_stmt|;
block|{
specifier|register
name|pmap_t
name|pmap
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|pmapdebug
operator|&
operator|(
name|PDB_FOLLOW
operator||
name|PDB_CREATE
operator|)
condition|)
name|printf
argument_list|(
literal|"pmap_create(%x)\n"
argument_list|,
name|size
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Software use map does not need a pmap 	 */
if|if
condition|(
name|size
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* XXX: is it ok to wait here? */
name|pmap
operator|=
operator|(
name|pmap_t
operator|)
name|malloc
argument_list|(
sizeof|sizeof
expr|*
name|pmap
argument_list|,
name|M_VMPMAP
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|notifwewait
if|if
condition|(
name|pmap
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"pmap_create: cannot allocate a pmap"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|bzero
argument_list|(
name|pmap
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|pmap
argument_list|)
argument_list|)
expr_stmt|;
name|pmap_pinit
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
return|return
operator|(
name|pmap
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Initialize a preallocated and zeroed pmap structure,  * such as one in a vmspace structure.  */
end_comment

begin_function
name|void
name|pmap_pinit
parameter_list|(
name|pmap
parameter_list|)
specifier|register
name|struct
name|pmap
modifier|*
name|pmap
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|int
name|s
decl_stmt|;
specifier|extern
name|struct
name|vmspace
name|vmspace0
decl_stmt|;
specifier|extern
name|struct
name|user
modifier|*
name|proc0paddr
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|pmapdebug
operator|&
operator|(
name|PDB_FOLLOW
operator||
name|PDB_CREATE
operator|)
condition|)
name|printf
argument_list|(
literal|"pmap_pinit(%x)\n"
argument_list|,
name|pmap
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|simple_lock_init
argument_list|(
operator|&
name|pmap
operator|->
name|pm_lock
argument_list|)
expr_stmt|;
name|pmap
operator|->
name|pm_count
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|free_segtab
condition|)
block|{
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|pmap
operator|->
name|pm_segtab
operator|=
name|free_segtab
expr_stmt|;
name|free_segtab
operator|=
operator|*
operator|(
expr|struct
name|segtab
operator|*
operator|*
operator|)
name|free_segtab
expr_stmt|;
name|pmap
operator|->
name|pm_segtab
operator|->
name|seg_tab
index|[
literal|0
index|]
operator|=
name|NULL
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
else|else
block|{
specifier|register
name|struct
name|segtab
modifier|*
name|stp
decl_stmt|;
name|vm_page_t
name|mem
decl_stmt|;
name|mem
operator|=
name|vm_page_alloc1
argument_list|()
expr_stmt|;
name|pmap_zero_page
argument_list|(
name|VM_PAGE_TO_PHYS
argument_list|(
name|mem
argument_list|)
argument_list|)
expr_stmt|;
name|pmap
operator|->
name|pm_segtab
operator|=
name|stp
operator|=
operator|(
expr|struct
name|segtab
operator|*
operator|)
name|MACH_PHYS_TO_CACHED
argument_list|(
name|VM_PAGE_TO_PHYS
argument_list|(
name|mem
argument_list|)
argument_list|)
expr_stmt|;
name|i
operator|=
name|pmaxpagesperpage
operator|*
operator|(
name|NBPG
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|segtab
argument_list|)
operator|)
expr_stmt|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
while|while
condition|(
operator|--
name|i
operator|!=
literal|0
condition|)
block|{
name|stp
operator|++
expr_stmt|;
operator|*
operator|(
expr|struct
name|segtab
operator|*
operator|*
operator|)
name|stp
operator|=
name|free_segtab
expr_stmt|;
name|free_segtab
operator|=
name|stp
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DIAGNOSTIC
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|PMAP_SEGTABSIZE
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|pmap
operator|->
name|pm_segtab
operator|->
name|seg_tab
index|[
name|i
index|]
operator|!=
literal|0
condition|)
name|panic
argument_list|(
literal|"pmap_pinit: pm_segtab != 0"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|pmap
operator|==
operator|&
name|vmspace0
operator|.
name|vm_pmap
condition|)
block|{
comment|/* 		 * The initial process has already been allocated a TLBPID 		 * in mach_init(). 		 */
name|pmap
operator|->
name|pm_tlbpid
operator|=
literal|1
expr_stmt|;
name|pmap
operator|->
name|pm_tlbgen
operator|=
name|tlbpid_gen
expr_stmt|;
name|proc0paddr
operator|->
name|u_pcb
operator|.
name|pcb_segtab
operator|=
operator|(
name|void
operator|*
operator|)
name|pmap
operator|->
name|pm_segtab
expr_stmt|;
block|}
else|else
block|{
name|pmap
operator|->
name|pm_tlbpid
operator|=
literal|0
expr_stmt|;
name|pmap
operator|->
name|pm_tlbgen
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  *	Retire the given physical map from service.  *	Should only be called if the map contains  *	no valid mappings.  */
end_comment

begin_function
name|void
name|pmap_destroy
parameter_list|(
name|pmap
parameter_list|)
specifier|register
name|pmap_t
name|pmap
decl_stmt|;
block|{
name|int
name|count
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|pmapdebug
operator|&
operator|(
name|PDB_FOLLOW
operator||
name|PDB_CREATE
operator|)
condition|)
name|printf
argument_list|(
literal|"pmap_destroy(%x)\n"
argument_list|,
name|pmap
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|pmap
operator|==
name|NULL
condition|)
return|return;
name|simple_lock
argument_list|(
operator|&
name|pmap
operator|->
name|pm_lock
argument_list|)
expr_stmt|;
name|count
operator|=
operator|--
name|pmap
operator|->
name|pm_count
expr_stmt|;
name|simple_unlock
argument_list|(
operator|&
name|pmap
operator|->
name|pm_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|==
literal|0
condition|)
block|{
name|pmap_release
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|caddr_t
operator|)
name|pmap
argument_list|,
name|M_VMPMAP
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Release any resources held by the given physical map.  * Called when a pmap initialized by pmap_pinit is being released.  * Should only be called if the map contains no valid mappings.  */
end_comment

begin_function
name|void
name|pmap_release
parameter_list|(
name|pmap
parameter_list|)
specifier|register
name|pmap_t
name|pmap
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|pmapdebug
operator|&
operator|(
name|PDB_FOLLOW
operator||
name|PDB_CREATE
operator|)
condition|)
name|printf
argument_list|(
literal|"pmap_release(%x)\n"
argument_list|,
name|pmap
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|pmap
operator|->
name|pm_segtab
condition|)
block|{
specifier|register
name|pt_entry_t
modifier|*
name|pte
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|int
name|s
decl_stmt|;
ifdef|#
directive|ifdef
name|DIAGNOSTIC
specifier|register
name|int
name|j
decl_stmt|;
endif|#
directive|endif
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|PMAP_SEGTABSIZE
condition|;
name|i
operator|++
control|)
block|{
comment|/* get pointer to segment map */
name|pte
operator|=
name|pmap
operator|->
name|pm_segtab
operator|->
name|seg_tab
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|pte
condition|)
continue|continue;
name|vm_page_free1
argument_list|(
name|PHYS_TO_VM_PAGE
argument_list|(
name|MACH_CACHED_TO_PHYS
argument_list|(
name|pte
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DIAGNOSTIC
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|NPTEPG
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|pte
operator|->
name|pt_entry
condition|)
name|panic
argument_list|(
literal|"pmap_release: segmap not empty"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|pmap
operator|->
name|pm_segtab
operator|->
name|seg_tab
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
block|}
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
operator|*
operator|(
expr|struct
name|segtab
operator|*
operator|*
operator|)
name|pmap
operator|->
name|pm_segtab
operator|=
name|free_segtab
expr_stmt|;
name|free_segtab
operator|=
name|pmap
operator|->
name|pm_segtab
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|pmap
operator|->
name|pm_segtab
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  *	Add a reference to the specified pmap.  */
end_comment

begin_function
name|void
name|pmap_reference
parameter_list|(
name|pmap
parameter_list|)
name|pmap_t
name|pmap
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|pmapdebug
operator|&
name|PDB_FOLLOW
condition|)
name|printf
argument_list|(
literal|"pmap_reference(%x)\n"
argument_list|,
name|pmap
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|pmap
operator|!=
name|NULL
condition|)
block|{
name|simple_lock
argument_list|(
operator|&
name|pmap
operator|->
name|pm_lock
argument_list|)
expr_stmt|;
name|pmap
operator|->
name|pm_count
operator|++
expr_stmt|;
name|simple_unlock
argument_list|(
operator|&
name|pmap
operator|->
name|pm_lock
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  *	Remove the given range of addresses from the specified map.  *  *	It is assumed that the start and end are properly  *	rounded to the page size.  */
end_comment

begin_function
name|void
name|pmap_remove
parameter_list|(
name|pmap
parameter_list|,
name|sva
parameter_list|,
name|eva
parameter_list|)
specifier|register
name|pmap_t
name|pmap
decl_stmt|;
name|vm_offset_t
name|sva
decl_stmt|,
name|eva
decl_stmt|;
block|{
specifier|register
name|vm_offset_t
name|nssva
decl_stmt|;
specifier|register
name|pt_entry_t
modifier|*
name|pte
decl_stmt|;
name|unsigned
name|entry
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|pmapdebug
operator|&
operator|(
name|PDB_FOLLOW
operator||
name|PDB_REMOVE
operator||
name|PDB_PROTECT
operator|)
condition|)
name|printf
argument_list|(
literal|"pmap_remove(%x, %x, %x)\n"
argument_list|,
name|pmap
argument_list|,
name|sva
argument_list|,
name|eva
argument_list|)
expr_stmt|;
name|remove_stats
operator|.
name|calls
operator|++
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|pmap
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
operator|!
name|pmap
operator|->
name|pm_segtab
condition|)
block|{
specifier|register
name|pt_entry_t
modifier|*
name|pte
decl_stmt|;
comment|/* remove entries from kernel pmap */
ifdef|#
directive|ifdef
name|DIAGNOSTIC
if|if
condition|(
name|sva
operator|<
name|VM_MIN_KERNEL_ADDRESS
operator|||
name|eva
operator|>
name|virtual_end
condition|)
name|panic
argument_list|(
literal|"pmap_remove: kva not in range"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|pte
operator|=
name|kvtopte
argument_list|(
name|sva
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|sva
operator|<
name|eva
condition|;
name|sva
operator|+=
name|NBPG
operator|,
name|pte
operator|++
control|)
block|{
name|entry
operator|=
name|pte
operator|->
name|pt_entry
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|entry
operator|&
name|PG_V
operator|)
condition|)
continue|continue;
if|if
condition|(
name|entry
operator|&
name|PG_WIRED
condition|)
name|pmap
operator|->
name|pm_stats
operator|.
name|wired_count
operator|--
expr_stmt|;
name|pmap
operator|->
name|pm_stats
operator|.
name|resident_count
operator|--
expr_stmt|;
name|pmap_remove_pv
argument_list|(
name|pmap
argument_list|,
name|sva
argument_list|,
name|entry
operator|&
name|PG_FRAME
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ATTR
name|pmap_attributes
index|[
name|atop
argument_list|(
name|entry
operator|&
name|PG_FRAME
argument_list|)
index|]
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
name|pte
operator|->
name|pt_entry
operator|=
name|PG_NV
expr_stmt|;
comment|/* 			 * Flush the TLB for the given address. 			 */
name|MachTLBFlushAddr
argument_list|(
name|sva
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|remove_stats
operator|.
name|flushes
operator|++
expr_stmt|;
endif|#
directive|endif
block|}
return|return;
block|}
ifdef|#
directive|ifdef
name|DIAGNOSTIC
if|if
condition|(
name|eva
operator|>
name|VM_MAXUSER_ADDRESS
condition|)
name|panic
argument_list|(
literal|"pmap_remove: uva not in range"
argument_list|)
expr_stmt|;
endif|#
directive|endif
while|while
condition|(
name|sva
operator|<
name|eva
condition|)
block|{
name|nssva
operator|=
name|pmax_trunc_seg
argument_list|(
name|sva
argument_list|)
operator|+
name|NBSEG
expr_stmt|;
if|if
condition|(
name|nssva
operator|==
literal|0
operator|||
name|nssva
operator|>
name|eva
condition|)
name|nssva
operator|=
name|eva
expr_stmt|;
comment|/* 		 * If VA belongs to an unallocated segment, 		 * skip to the next segment boundary. 		 */
if|if
condition|(
operator|!
operator|(
name|pte
operator|=
name|pmap_segmap
argument_list|(
name|pmap
argument_list|,
name|sva
argument_list|)
operator|)
condition|)
block|{
name|sva
operator|=
name|nssva
expr_stmt|;
continue|continue;
block|}
comment|/* 		 * Invalidate every valid mapping within this segment. 		 */
name|pte
operator|+=
operator|(
name|sva
operator|>>
name|PGSHIFT
operator|)
operator|&
operator|(
name|NPTEPG
operator|-
literal|1
operator|)
expr_stmt|;
for|for
control|(
init|;
name|sva
operator|<
name|nssva
condition|;
name|sva
operator|+=
name|NBPG
operator|,
name|pte
operator|++
control|)
block|{
name|entry
operator|=
name|pte
operator|->
name|pt_entry
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|entry
operator|&
name|PG_V
operator|)
condition|)
continue|continue;
if|if
condition|(
name|entry
operator|&
name|PG_WIRED
condition|)
name|pmap
operator|->
name|pm_stats
operator|.
name|wired_count
operator|--
expr_stmt|;
name|pmap
operator|->
name|pm_stats
operator|.
name|resident_count
operator|--
expr_stmt|;
name|pmap_remove_pv
argument_list|(
name|pmap
argument_list|,
name|sva
argument_list|,
name|entry
operator|&
name|PG_FRAME
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ATTR
name|pmap_attributes
index|[
name|atop
argument_list|(
name|entry
operator|&
name|PG_FRAME
argument_list|)
index|]
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
name|pte
operator|->
name|pt_entry
operator|=
name|PG_NV
expr_stmt|;
comment|/* 			 * Flush the TLB for the given address. 			 */
if|if
condition|(
name|pmap
operator|->
name|pm_tlbgen
operator|==
name|tlbpid_gen
condition|)
block|{
name|MachTLBFlushAddr
argument_list|(
name|sva
operator||
operator|(
name|pmap
operator|->
name|pm_tlbpid
operator|<<
name|VMMACH_TLB_PID_SHIFT
operator|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|remove_stats
operator|.
name|flushes
operator|++
expr_stmt|;
endif|#
directive|endif
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/*  *	pmap_page_protect:  *  *	Lower the permission for all mappings to a given page.  */
end_comment

begin_function
name|void
name|pmap_page_protect
parameter_list|(
name|pa
parameter_list|,
name|prot
parameter_list|)
name|vm_offset_t
name|pa
decl_stmt|;
name|vm_prot_t
name|prot
decl_stmt|;
block|{
specifier|register
name|pv_entry_t
name|pv
decl_stmt|;
specifier|register
name|vm_offset_t
name|va
decl_stmt|;
name|int
name|s
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
operator|(
name|pmapdebug
operator|&
operator|(
name|PDB_FOLLOW
operator||
name|PDB_PROTECT
operator|)
operator|)
operator|||
name|prot
operator|==
name|VM_PROT_NONE
operator|&&
operator|(
name|pmapdebug
operator|&
name|PDB_REMOVE
operator|)
condition|)
name|printf
argument_list|(
literal|"pmap_page_protect(%x, %x)\n"
argument_list|,
name|pa
argument_list|,
name|prot
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|IS_VM_PHYSADDR
argument_list|(
name|pa
argument_list|)
condition|)
return|return;
switch|switch
condition|(
name|prot
condition|)
block|{
case|case
name|VM_PROT_READ
operator||
name|VM_PROT_WRITE
case|:
case|case
name|VM_PROT_ALL
case|:
break|break;
comment|/* copy_on_write */
case|case
name|VM_PROT_READ
case|:
case|case
name|VM_PROT_READ
operator||
name|VM_PROT_EXECUTE
case|:
name|pv
operator|=
name|pa_to_pvh
argument_list|(
name|pa
argument_list|)
expr_stmt|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
comment|/* 		 * Loop over all current mappings setting/clearing as appropos. 		 */
if|if
condition|(
name|pv
operator|->
name|pv_pmap
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
init|;
name|pv
condition|;
name|pv
operator|=
name|pv
operator|->
name|pv_next
control|)
block|{
specifier|extern
name|vm_offset_t
name|pager_sva
decl_stmt|,
name|pager_eva
decl_stmt|;
name|va
operator|=
name|pv
operator|->
name|pv_va
expr_stmt|;
comment|/* 				 * XXX don't write protect pager mappings 				 */
if|if
condition|(
name|va
operator|>=
name|pager_sva
operator|&&
name|va
operator|<
name|pager_eva
condition|)
continue|continue;
name|pmap_protect
argument_list|(
name|pv
operator|->
name|pv_pmap
argument_list|,
name|va
argument_list|,
name|va
operator|+
name|PAGE_SIZE
argument_list|,
name|prot
argument_list|)
expr_stmt|;
block|}
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
break|break;
comment|/* remove_all */
default|default:
name|pv
operator|=
name|pa_to_pvh
argument_list|(
name|pa
argument_list|)
expr_stmt|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
while|while
condition|(
name|pv
operator|->
name|pv_pmap
operator|!=
name|NULL
condition|)
block|{
name|pmap_remove
argument_list|(
name|pv
operator|->
name|pv_pmap
argument_list|,
name|pv
operator|->
name|pv_va
argument_list|,
name|pv
operator|->
name|pv_va
operator|+
name|PAGE_SIZE
argument_list|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  *	Set the physical protection on the  *	specified range of this map as requested.  */
end_comment

begin_function
name|void
name|pmap_protect
parameter_list|(
name|pmap
parameter_list|,
name|sva
parameter_list|,
name|eva
parameter_list|,
name|prot
parameter_list|)
specifier|register
name|pmap_t
name|pmap
decl_stmt|;
name|vm_offset_t
name|sva
decl_stmt|,
name|eva
decl_stmt|;
name|vm_prot_t
name|prot
decl_stmt|;
block|{
specifier|register
name|vm_offset_t
name|nssva
decl_stmt|;
specifier|register
name|pt_entry_t
modifier|*
name|pte
decl_stmt|;
specifier|register
name|unsigned
name|entry
decl_stmt|;
name|u_int
name|p
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|pmapdebug
operator|&
operator|(
name|PDB_FOLLOW
operator||
name|PDB_PROTECT
operator|)
condition|)
name|printf
argument_list|(
literal|"pmap_protect(%x, %x, %x, %x)\n"
argument_list|,
name|pmap
argument_list|,
name|sva
argument_list|,
name|eva
argument_list|,
name|prot
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|pmap
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
operator|(
name|prot
operator|&
name|VM_PROT_READ
operator|)
operator|==
name|VM_PROT_NONE
condition|)
block|{
name|pmap_remove
argument_list|(
name|pmap
argument_list|,
name|sva
argument_list|,
name|eva
argument_list|)
expr_stmt|;
return|return;
block|}
name|p
operator|=
operator|(
name|prot
operator|&
name|VM_PROT_WRITE
operator|)
condition|?
name|PG_RW
else|:
name|PG_RO
expr_stmt|;
if|if
condition|(
operator|!
name|pmap
operator|->
name|pm_segtab
condition|)
block|{
comment|/* 		 * Change entries in kernel pmap. 		 * This will trap if the page is writeable (in order to set 		 * the dirty bit) even if the dirty bit is already set. The 		 * optimization isn't worth the effort since this code isn't 		 * executed much. The common case is to make a user page 		 * read-only. 		 */
ifdef|#
directive|ifdef
name|DIAGNOSTIC
if|if
condition|(
name|sva
operator|<
name|VM_MIN_KERNEL_ADDRESS
operator|||
name|eva
operator|>
name|virtual_end
condition|)
name|panic
argument_list|(
literal|"pmap_protect: kva not in range"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|pte
operator|=
name|kvtopte
argument_list|(
name|sva
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|sva
operator|<
name|eva
condition|;
name|sva
operator|+=
name|NBPG
operator|,
name|pte
operator|++
control|)
block|{
name|entry
operator|=
name|pte
operator|->
name|pt_entry
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|entry
operator|&
name|PG_V
operator|)
condition|)
continue|continue;
name|entry
operator|=
operator|(
name|entry
operator|&
operator|~
operator|(
name|PG_M
operator||
name|PG_RO
operator|)
operator|)
operator||
name|p
expr_stmt|;
name|pte
operator|->
name|pt_entry
operator|=
name|entry
expr_stmt|;
comment|/* 			 * Update the TLB if the given address is in the cache. 			 */
name|MachTLBUpdate
argument_list|(
name|sva
argument_list|,
name|entry
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
ifdef|#
directive|ifdef
name|DIAGNOSTIC
if|if
condition|(
name|eva
operator|>
name|VM_MAXUSER_ADDRESS
condition|)
name|panic
argument_list|(
literal|"pmap_protect: uva not in range"
argument_list|)
expr_stmt|;
endif|#
directive|endif
while|while
condition|(
name|sva
operator|<
name|eva
condition|)
block|{
name|nssva
operator|=
name|pmax_trunc_seg
argument_list|(
name|sva
argument_list|)
operator|+
name|NBSEG
expr_stmt|;
if|if
condition|(
name|nssva
operator|==
literal|0
operator|||
name|nssva
operator|>
name|eva
condition|)
name|nssva
operator|=
name|eva
expr_stmt|;
comment|/* 		 * If VA belongs to an unallocated segment, 		 * skip to the next segment boundary. 		 */
if|if
condition|(
operator|!
operator|(
name|pte
operator|=
name|pmap_segmap
argument_list|(
name|pmap
argument_list|,
name|sva
argument_list|)
operator|)
condition|)
block|{
name|sva
operator|=
name|nssva
expr_stmt|;
continue|continue;
block|}
comment|/* 		 * Change protection on every valid mapping within this segment. 		 */
name|pte
operator|+=
operator|(
name|sva
operator|>>
name|PGSHIFT
operator|)
operator|&
operator|(
name|NPTEPG
operator|-
literal|1
operator|)
expr_stmt|;
for|for
control|(
init|;
name|sva
operator|<
name|nssva
condition|;
name|sva
operator|+=
name|NBPG
operator|,
name|pte
operator|++
control|)
block|{
name|entry
operator|=
name|pte
operator|->
name|pt_entry
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|entry
operator|&
name|PG_V
operator|)
condition|)
continue|continue;
name|entry
operator|=
operator|(
name|entry
operator|&
operator|~
operator|(
name|PG_M
operator||
name|PG_RO
operator|)
operator|)
operator||
name|p
expr_stmt|;
name|pte
operator|->
name|pt_entry
operator|=
name|entry
expr_stmt|;
comment|/* 			 * Update the TLB if the given address is in the cache. 			 */
if|if
condition|(
name|pmap
operator|->
name|pm_tlbgen
operator|==
name|tlbpid_gen
condition|)
name|MachTLBUpdate
argument_list|(
name|sva
operator||
operator|(
name|pmap
operator|->
name|pm_tlbpid
operator|<<
name|VMMACH_TLB_PID_SHIFT
operator|)
argument_list|,
name|entry
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  *	Insert the given physical page (p) at  *	the specified virtual address (v) in the  *	target physical map with the protection requested.  *  *	If specified, the page will be wired down, meaning  *	that the related pte can not be reclaimed.  *  *	NB:  This is the only routine which MAY NOT lazy-evaluate  *	or lose information.  That is, this routine must actually  *	insert this page into the given map NOW.  */
end_comment

begin_function
name|void
name|pmap_enter
parameter_list|(
name|pmap
parameter_list|,
name|va
parameter_list|,
name|pa
parameter_list|,
name|prot
parameter_list|,
name|wired
parameter_list|)
specifier|register
name|pmap_t
name|pmap
decl_stmt|;
name|vm_offset_t
name|va
decl_stmt|;
specifier|register
name|vm_offset_t
name|pa
decl_stmt|;
name|vm_prot_t
name|prot
decl_stmt|;
name|boolean_t
name|wired
decl_stmt|;
block|{
specifier|register
name|pt_entry_t
modifier|*
name|pte
decl_stmt|;
specifier|register
name|u_int
name|npte
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|vm_page_t
name|mem
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|pmapdebug
operator|&
operator|(
name|PDB_FOLLOW
operator||
name|PDB_ENTER
operator|)
condition|)
name|printf
argument_list|(
literal|"pmap_enter(%x, %x, %x, %x, %x)\n"
argument_list|,
name|pmap
argument_list|,
name|va
argument_list|,
name|pa
argument_list|,
name|prot
argument_list|,
name|wired
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DIAGNOSTIC
if|if
condition|(
operator|!
name|pmap
condition|)
name|panic
argument_list|(
literal|"pmap_enter: pmap"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pmap
operator|->
name|pm_segtab
condition|)
block|{
name|enter_stats
operator|.
name|kernel
operator|++
expr_stmt|;
if|if
condition|(
name|va
operator|<
name|VM_MIN_KERNEL_ADDRESS
operator|||
name|va
operator|>=
name|virtual_end
condition|)
name|panic
argument_list|(
literal|"pmap_enter: kva"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|enter_stats
operator|.
name|user
operator|++
expr_stmt|;
if|if
condition|(
name|va
operator|>=
name|VM_MAXUSER_ADDRESS
condition|)
name|panic
argument_list|(
literal|"pmap_enter: uva"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pa
operator|&
literal|0x80000000
condition|)
name|panic
argument_list|(
literal|"pmap_enter: pa"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|prot
operator|&
name|VM_PROT_READ
operator|)
condition|)
name|panic
argument_list|(
literal|"pmap_enter: prot"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|IS_VM_PHYSADDR
argument_list|(
name|pa
argument_list|)
condition|)
block|{
specifier|register
name|pv_entry_t
name|pv
decl_stmt|,
name|npv
decl_stmt|;
name|int
name|s
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|prot
operator|&
name|VM_PROT_WRITE
operator|)
condition|)
name|npte
operator|=
name|PG_RO
expr_stmt|;
else|else
block|{
specifier|register
name|vm_page_t
name|mem
decl_stmt|;
name|mem
operator|=
name|PHYS_TO_VM_PAGE
argument_list|(
name|pa
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|int
operator|)
name|va
operator|<
literal|0
condition|)
block|{
comment|/* 				 * Don't bother to trap on kernel writes, 				 * just record page as dirty. 				 */
name|npte
operator|=
name|PG_M
expr_stmt|;
name|mem
operator|->
name|flags
operator|&=
operator|~
name|PG_CLEAN
expr_stmt|;
block|}
elseif|else
ifdef|#
directive|ifdef
name|ATTR
if|if
condition|(
operator|(
name|pmap_attributes
index|[
name|atop
argument_list|(
name|pa
argument_list|)
index|]
operator|&
name|PMAP_ATTR_MOD
operator|)
operator|||
operator|!
operator|(
name|mem
operator|->
name|flags
operator|&
name|PG_CLEAN
operator|)
condition|)
else|#
directive|else
if|if
condition|(
operator|!
operator|(
name|mem
operator|->
name|flags
operator|&
name|PG_CLEAN
operator|)
condition|)
endif|#
directive|endif
name|npte
operator|=
name|PG_M
expr_stmt|;
else|else
name|npte
operator|=
literal|0
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DEBUG
name|enter_stats
operator|.
name|managed
operator|++
expr_stmt|;
endif|#
directive|endif
comment|/* 		 * Enter the pmap and virtual address into the 		 * physical to virtual map table. 		 */
name|pv
operator|=
name|pa_to_pvh
argument_list|(
name|pa
argument_list|)
expr_stmt|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|pmapdebug
operator|&
name|PDB_ENTER
condition|)
name|printf
argument_list|(
literal|"pmap_enter: pv %x: was %x/%x/%x\n"
argument_list|,
name|pv
argument_list|,
name|pv
operator|->
name|pv_va
argument_list|,
name|pv
operator|->
name|pv_pmap
argument_list|,
name|pv
operator|->
name|pv_next
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|pv
operator|->
name|pv_pmap
operator|==
name|NULL
condition|)
block|{
comment|/* 			 * No entries yet, use header as the first entry 			 */
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|pmapdebug
operator|&
name|PDB_PVENTRY
condition|)
name|printf
argument_list|(
literal|"pmap_enter: first pv: pmap %x va %x\n"
argument_list|,
name|pmap
argument_list|,
name|va
argument_list|)
expr_stmt|;
name|enter_stats
operator|.
name|firstpv
operator|++
expr_stmt|;
endif|#
directive|endif
name|pv
operator|->
name|pv_va
operator|=
name|va
expr_stmt|;
name|pv
operator|->
name|pv_pmap
operator|=
name|pmap
expr_stmt|;
name|pv
operator|->
name|pv_next
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * There is at least one other VA mapping this page. 			 * Place this entry after the header. 			 * 			 * Note: the entry may already be in the table if 			 * we are only changing the protection bits. 			 */
for|for
control|(
name|npv
operator|=
name|pv
init|;
name|npv
condition|;
name|npv
operator|=
name|npv
operator|->
name|pv_next
control|)
if|if
condition|(
name|pmap
operator|==
name|npv
operator|->
name|pv_pmap
operator|&&
name|va
operator|==
name|npv
operator|->
name|pv_va
condition|)
block|{
ifdef|#
directive|ifdef
name|DIAGNOSTIC
name|unsigned
name|entry
decl_stmt|;
if|if
condition|(
operator|!
name|pmap
operator|->
name|pm_segtab
condition|)
name|entry
operator|=
name|kvtopte
argument_list|(
name|va
argument_list|)
operator|->
name|pt_entry
expr_stmt|;
else|else
block|{
name|pte
operator|=
name|pmap_segmap
argument_list|(
name|pmap
argument_list|,
name|va
argument_list|)
expr_stmt|;
if|if
condition|(
name|pte
condition|)
block|{
name|pte
operator|+=
operator|(
name|va
operator|>>
name|PGSHIFT
operator|)
operator|&
operator|(
name|NPTEPG
operator|-
literal|1
operator|)
expr_stmt|;
name|entry
operator|=
name|pte
operator|->
name|pt_entry
expr_stmt|;
block|}
else|else
name|entry
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|entry
operator|&
name|PG_V
operator|)
operator|||
operator|(
name|entry
operator|&
name|PG_FRAME
operator|)
operator|!=
name|pa
condition|)
name|printf
argument_list|(
literal|"pmap_enter: found va %x pa %x in pv_table but != %x\n"
argument_list|,
name|va
argument_list|,
name|pa
argument_list|,
name|entry
argument_list|)
expr_stmt|;
endif|#
directive|endif
goto|goto
name|fnd
goto|;
block|}
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|pmapdebug
operator|&
name|PDB_PVENTRY
condition|)
name|printf
argument_list|(
literal|"pmap_enter: new pv: pmap %x va %x\n"
argument_list|,
name|pmap
argument_list|,
name|va
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* can this cause us to recurse forever? */
name|npv
operator|=
operator|(
name|pv_entry_t
operator|)
name|malloc
argument_list|(
sizeof|sizeof
expr|*
name|npv
argument_list|,
name|M_VMPVENT
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
name|npv
operator|->
name|pv_va
operator|=
name|va
expr_stmt|;
name|npv
operator|->
name|pv_pmap
operator|=
name|pmap
expr_stmt|;
name|npv
operator|->
name|pv_next
operator|=
name|pv
operator|->
name|pv_next
expr_stmt|;
name|pv
operator|->
name|pv_next
operator|=
name|npv
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
operator|!
name|npv
operator|->
name|pv_next
condition|)
name|enter_stats
operator|.
name|secondpv
operator|++
expr_stmt|;
endif|#
directive|endif
name|fnd
label|:
empty_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * Assumption: if it is not part of our managed memory 		 * then it must be device memory which may be volitile. 		 */
ifdef|#
directive|ifdef
name|DEBUG
name|enter_stats
operator|.
name|unmanaged
operator|++
expr_stmt|;
endif|#
directive|endif
name|npte
operator|=
operator|(
name|prot
operator|&
name|VM_PROT_WRITE
operator|)
condition|?
operator|(
name|PG_M
operator||
name|PG_N
operator|)
else|:
operator|(
name|PG_RO
operator||
name|PG_N
operator|)
expr_stmt|;
block|}
comment|/* 	 * The only time we need to flush the cache is if we 	 * execute from a physical address and then change the data. 	 * This is the best place to do this. 	 * pmap_protect() and pmap_remove() are mostly used to switch 	 * between R/W and R/O pages. 	 * NOTE: we only support cache flush for read only text. 	 */
if|if
condition|(
name|prot
operator|==
operator|(
name|VM_PROT_READ
operator||
name|VM_PROT_EXECUTE
operator|)
condition|)
name|MachFlushICache
argument_list|(
name|MACH_PHYS_TO_CACHED
argument_list|(
name|pa
argument_list|)
argument_list|,
name|PAGE_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pmap
operator|->
name|pm_segtab
condition|)
block|{
comment|/* enter entries into kernel pmap */
name|pte
operator|=
name|kvtopte
argument_list|(
name|va
argument_list|)
expr_stmt|;
name|npte
operator||=
name|pa
operator||
name|PG_V
operator||
name|PG_G
expr_stmt|;
if|if
condition|(
name|wired
condition|)
block|{
name|pmap
operator|->
name|pm_stats
operator|.
name|wired_count
operator|+=
name|pmaxpagesperpage
expr_stmt|;
name|npte
operator||=
name|PG_WIRED
expr_stmt|;
block|}
name|i
operator|=
name|pmaxpagesperpage
expr_stmt|;
do|do
block|{
if|if
condition|(
operator|!
operator|(
name|pte
operator|->
name|pt_entry
operator|&
name|PG_V
operator|)
condition|)
block|{
name|pmap
operator|->
name|pm_stats
operator|.
name|resident_count
operator|++
expr_stmt|;
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|DIAGNOSTIC
if|if
condition|(
name|pte
operator|->
name|pt_entry
operator|&
name|PG_WIRED
condition|)
name|panic
argument_list|(
literal|"pmap_enter: kernel wired"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* 			 * Update the same virtual address entry. 			 */
name|MachTLBUpdate
argument_list|(
name|va
argument_list|,
name|npte
argument_list|)
expr_stmt|;
name|pte
operator|->
name|pt_entry
operator|=
name|npte
expr_stmt|;
name|va
operator|+=
name|NBPG
expr_stmt|;
name|npte
operator|+=
name|NBPG
expr_stmt|;
name|pte
operator|++
expr_stmt|;
block|}
do|while
condition|(
operator|--
name|i
operator|!=
literal|0
condition|)
do|;
return|return;
block|}
if|if
condition|(
operator|!
operator|(
name|pte
operator|=
name|pmap_segmap
argument_list|(
name|pmap
argument_list|,
name|va
argument_list|)
operator|)
condition|)
block|{
name|mem
operator|=
name|vm_page_alloc1
argument_list|()
expr_stmt|;
name|pmap_zero_page
argument_list|(
name|VM_PAGE_TO_PHYS
argument_list|(
name|mem
argument_list|)
argument_list|)
expr_stmt|;
name|pmap_segmap
argument_list|(
name|pmap
argument_list|,
name|va
argument_list|)
operator|=
name|pte
operator|=
operator|(
name|pt_entry_t
operator|*
operator|)
name|MACH_PHYS_TO_CACHED
argument_list|(
name|VM_PAGE_TO_PHYS
argument_list|(
name|mem
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|pte
operator|+=
operator|(
name|va
operator|>>
name|PGSHIFT
operator|)
operator|&
operator|(
name|NPTEPG
operator|-
literal|1
operator|)
expr_stmt|;
comment|/* 	 * Now validate mapping with desired protection/wiring. 	 * Assume uniform modified and referenced status for all 	 * PMAX pages in a MACH page. 	 */
name|npte
operator||=
name|pa
operator||
name|PG_V
expr_stmt|;
if|if
condition|(
name|wired
condition|)
block|{
name|pmap
operator|->
name|pm_stats
operator|.
name|wired_count
operator|+=
name|pmaxpagesperpage
expr_stmt|;
name|npte
operator||=
name|PG_WIRED
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|pmapdebug
operator|&
name|PDB_ENTER
condition|)
block|{
name|printf
argument_list|(
literal|"pmap_enter: new pte %x"
argument_list|,
name|npte
argument_list|)
expr_stmt|;
if|if
condition|(
name|pmap
operator|->
name|pm_tlbgen
operator|==
name|tlbpid_gen
condition|)
name|printf
argument_list|(
literal|" tlbpid %d"
argument_list|,
name|pmap
operator|->
name|pm_tlbpid
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|i
operator|=
name|pmaxpagesperpage
expr_stmt|;
do|do
block|{
name|pte
operator|->
name|pt_entry
operator|=
name|npte
expr_stmt|;
if|if
condition|(
name|pmap
operator|->
name|pm_tlbgen
operator|==
name|tlbpid_gen
condition|)
name|MachTLBUpdate
argument_list|(
name|va
operator||
operator|(
name|pmap
operator|->
name|pm_tlbpid
operator|<<
name|VMMACH_TLB_PID_SHIFT
operator|)
argument_list|,
name|npte
argument_list|)
expr_stmt|;
name|va
operator|+=
name|NBPG
expr_stmt|;
name|npte
operator|+=
name|NBPG
expr_stmt|;
name|pte
operator|++
expr_stmt|;
block|}
do|while
condition|(
operator|--
name|i
operator|!=
literal|0
condition|)
do|;
block|}
end_function

begin_comment
comment|/*  *	Routine:	pmap_change_wiring  *	Function:	Change the wiring attribute for a map/virtual-address  *			pair.  *	In/out conditions:  *			The mapping must already exist in the pmap.  */
end_comment

begin_function
name|void
name|pmap_change_wiring
parameter_list|(
name|pmap
parameter_list|,
name|va
parameter_list|,
name|wired
parameter_list|)
specifier|register
name|pmap_t
name|pmap
decl_stmt|;
name|vm_offset_t
name|va
decl_stmt|;
name|boolean_t
name|wired
decl_stmt|;
block|{
specifier|register
name|pt_entry_t
modifier|*
name|pte
decl_stmt|;
name|u_int
name|p
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|pmapdebug
operator|&
operator|(
name|PDB_FOLLOW
operator||
name|PDB_WIRING
operator|)
condition|)
name|printf
argument_list|(
literal|"pmap_change_wiring(%x, %x, %x)\n"
argument_list|,
name|pmap
argument_list|,
name|va
argument_list|,
name|wired
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|pmap
operator|==
name|NULL
condition|)
return|return;
name|p
operator|=
name|wired
condition|?
name|PG_WIRED
else|:
literal|0
expr_stmt|;
comment|/* 	 * Don't need to flush the TLB since PG_WIRED is only in software. 	 */
if|if
condition|(
operator|!
name|pmap
operator|->
name|pm_segtab
condition|)
block|{
comment|/* change entries in kernel pmap */
ifdef|#
directive|ifdef
name|DIAGNOSTIC
if|if
condition|(
name|va
operator|<
name|VM_MIN_KERNEL_ADDRESS
operator|||
name|va
operator|>=
name|virtual_end
condition|)
name|panic
argument_list|(
literal|"pmap_change_wiring"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|pte
operator|=
name|kvtopte
argument_list|(
name|va
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
operator|(
name|pte
operator|=
name|pmap_segmap
argument_list|(
name|pmap
argument_list|,
name|va
argument_list|)
operator|)
condition|)
return|return;
name|pte
operator|+=
operator|(
name|va
operator|>>
name|PGSHIFT
operator|)
operator|&
operator|(
name|NPTEPG
operator|-
literal|1
operator|)
expr_stmt|;
block|}
name|i
operator|=
name|pmaxpagesperpage
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|pte
operator|->
name|pt_entry
operator|&
name|PG_WIRED
operator|)
operator|&&
name|p
condition|)
name|pmap
operator|->
name|pm_stats
operator|.
name|wired_count
operator|+=
name|i
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|pte
operator|->
name|pt_entry
operator|&
name|PG_WIRED
operator|)
operator|&&
operator|!
name|p
condition|)
name|pmap
operator|->
name|pm_stats
operator|.
name|wired_count
operator|-=
name|i
expr_stmt|;
do|do
block|{
if|if
condition|(
name|pte
operator|->
name|pt_entry
operator|&
name|PG_V
condition|)
name|pte
operator|->
name|pt_entry
operator|=
operator|(
name|pte
operator|->
name|pt_entry
operator|&
operator|~
name|PG_WIRED
operator|)
operator||
name|p
expr_stmt|;
name|pte
operator|++
expr_stmt|;
block|}
do|while
condition|(
operator|--
name|i
operator|!=
literal|0
condition|)
do|;
block|}
end_function

begin_comment
comment|/*  *	Routine:	pmap_extract  *	Function:  *		Extract the physical page address associated  *		with the given map/virtual_address pair.  */
end_comment

begin_function
name|vm_offset_t
name|pmap_extract
parameter_list|(
name|pmap
parameter_list|,
name|va
parameter_list|)
specifier|register
name|pmap_t
name|pmap
decl_stmt|;
name|vm_offset_t
name|va
decl_stmt|;
block|{
specifier|register
name|vm_offset_t
name|pa
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|pmapdebug
operator|&
name|PDB_FOLLOW
condition|)
name|printf
argument_list|(
literal|"pmap_extract(%x, %x) -> "
argument_list|,
name|pmap
argument_list|,
name|va
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|pmap
operator|->
name|pm_segtab
condition|)
block|{
ifdef|#
directive|ifdef
name|DIAGNOSTIC
if|if
condition|(
name|va
operator|<
name|VM_MIN_KERNEL_ADDRESS
operator|||
name|va
operator|>=
name|virtual_end
condition|)
name|panic
argument_list|(
literal|"pmap_extract"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|pa
operator|=
name|kvtopte
argument_list|(
name|va
argument_list|)
operator|->
name|pt_entry
operator|&
name|PG_FRAME
expr_stmt|;
block|}
else|else
block|{
specifier|register
name|pt_entry_t
modifier|*
name|pte
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|pte
operator|=
name|pmap_segmap
argument_list|(
name|pmap
argument_list|,
name|va
argument_list|)
operator|)
condition|)
name|pa
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|pte
operator|+=
operator|(
name|va
operator|>>
name|PGSHIFT
operator|)
operator|&
operator|(
name|NPTEPG
operator|-
literal|1
operator|)
expr_stmt|;
name|pa
operator|=
name|pte
operator|->
name|pt_entry
operator|&
name|PG_FRAME
expr_stmt|;
block|}
block|}
if|if
condition|(
name|pa
condition|)
name|pa
operator||=
name|va
operator|&
name|PGOFSET
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|pmapdebug
operator|&
name|PDB_FOLLOW
condition|)
name|printf
argument_list|(
literal|"pmap_extract: pa %x\n"
argument_list|,
name|pa
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|pa
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *	Copy the range specified by src_addr/len  *	from the source map to the range dst_addr/len  *	in the destination map.  *  *	This routine is only advisory and need not do anything.  */
end_comment

begin_function
name|void
name|pmap_copy
parameter_list|(
name|dst_pmap
parameter_list|,
name|src_pmap
parameter_list|,
name|dst_addr
parameter_list|,
name|len
parameter_list|,
name|src_addr
parameter_list|)
name|pmap_t
name|dst_pmap
decl_stmt|;
name|pmap_t
name|src_pmap
decl_stmt|;
name|vm_offset_t
name|dst_addr
decl_stmt|;
name|vm_size_t
name|len
decl_stmt|;
name|vm_offset_t
name|src_addr
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|pmapdebug
operator|&
name|PDB_FOLLOW
condition|)
name|printf
argument_list|(
literal|"pmap_copy(%x, %x, %x, %x, %x)\n"
argument_list|,
name|dst_pmap
argument_list|,
name|src_pmap
argument_list|,
name|dst_addr
argument_list|,
name|len
argument_list|,
name|src_addr
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  *	Require that all active physical maps contain no  *	incorrect entries NOW.  [This update includes  *	forcing updates of any address map caching.]  *  *	Generally used to insure that a thread about  *	to run will see a semantically correct world.  */
end_comment

begin_function
name|void
name|pmap_update
parameter_list|()
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|pmapdebug
operator|&
name|PDB_FOLLOW
condition|)
name|printf
argument_list|(
literal|"pmap_update()\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  *	Routine:	pmap_collect  *	Function:  *		Garbage collects the physical map system for  *		pages which are no longer used.  *		Success need not be guaranteed -- that is, there  *		may well be pages which are not referenced, but  *		others may be collected.  *	Usage:  *		Called by the pageout daemon when pages are scarce.  */
end_comment

begin_function
name|void
name|pmap_collect
parameter_list|(
name|pmap
parameter_list|)
name|pmap_t
name|pmap
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|pmapdebug
operator|&
name|PDB_FOLLOW
condition|)
name|printf
argument_list|(
literal|"pmap_collect(%x)\n"
argument_list|,
name|pmap
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  *	pmap_zero_page zeros the specified (machine independent)  *	page.  */
end_comment

begin_function
name|void
name|pmap_zero_page
parameter_list|(
name|phys
parameter_list|)
name|vm_offset_t
name|phys
decl_stmt|;
block|{
specifier|register
name|int
modifier|*
name|p
decl_stmt|,
modifier|*
name|end
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|pmapdebug
operator|&
name|PDB_FOLLOW
condition|)
name|printf
argument_list|(
literal|"pmap_zero_page(%x)\n"
argument_list|,
name|phys
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|p
operator|=
operator|(
name|int
operator|*
operator|)
name|MACH_PHYS_TO_CACHED
argument_list|(
name|phys
argument_list|)
expr_stmt|;
name|end
operator|=
name|p
operator|+
name|PAGE_SIZE
operator|/
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
do|do
block|{
name|p
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|p
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|p
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|p
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
name|p
operator|+=
literal|4
expr_stmt|;
block|}
do|while
condition|(
name|p
operator|!=
name|end
condition|)
do|;
block|}
end_function

begin_comment
comment|/*  *	pmap_copy_page copies the specified (machine independent)  *	page.  */
end_comment

begin_function
name|void
name|pmap_copy_page
parameter_list|(
name|src
parameter_list|,
name|dst
parameter_list|)
name|vm_offset_t
name|src
decl_stmt|,
name|dst
decl_stmt|;
block|{
specifier|register
name|int
modifier|*
name|s
decl_stmt|,
modifier|*
name|d
decl_stmt|,
modifier|*
name|end
decl_stmt|;
specifier|register
name|int
name|tmp0
decl_stmt|,
name|tmp1
decl_stmt|,
name|tmp2
decl_stmt|,
name|tmp3
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|pmapdebug
operator|&
name|PDB_FOLLOW
condition|)
name|printf
argument_list|(
literal|"pmap_copy_page(%x, %x)\n"
argument_list|,
name|src
argument_list|,
name|dst
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|s
operator|=
operator|(
name|int
operator|*
operator|)
name|MACH_PHYS_TO_CACHED
argument_list|(
name|src
argument_list|)
expr_stmt|;
name|d
operator|=
operator|(
name|int
operator|*
operator|)
name|MACH_PHYS_TO_CACHED
argument_list|(
name|dst
argument_list|)
expr_stmt|;
name|end
operator|=
name|s
operator|+
name|PAGE_SIZE
operator|/
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
do|do
block|{
name|tmp0
operator|=
name|s
index|[
literal|0
index|]
expr_stmt|;
name|tmp1
operator|=
name|s
index|[
literal|1
index|]
expr_stmt|;
name|tmp2
operator|=
name|s
index|[
literal|2
index|]
expr_stmt|;
name|tmp3
operator|=
name|s
index|[
literal|3
index|]
expr_stmt|;
name|d
index|[
literal|0
index|]
operator|=
name|tmp0
expr_stmt|;
name|d
index|[
literal|1
index|]
operator|=
name|tmp1
expr_stmt|;
name|d
index|[
literal|2
index|]
operator|=
name|tmp2
expr_stmt|;
name|d
index|[
literal|3
index|]
operator|=
name|tmp3
expr_stmt|;
name|s
operator|+=
literal|4
expr_stmt|;
name|d
operator|+=
literal|4
expr_stmt|;
block|}
do|while
condition|(
name|s
operator|!=
name|end
condition|)
do|;
block|}
end_function

begin_comment
comment|/*  *	Routine:	pmap_pageable  *	Function:  *		Make the specified pages (by pmap, offset)  *		pageable (or not) as requested.  *  *		A page which is not pageable may not take  *		a fault; therefore, its page table entry  *		must remain valid for the duration.  *  *		This routine is merely advisory; pmap_enter  *		will specify that these pages are to be wired  *		down (or not) as appropriate.  */
end_comment

begin_function
name|void
name|pmap_pageable
parameter_list|(
name|pmap
parameter_list|,
name|sva
parameter_list|,
name|eva
parameter_list|,
name|pageable
parameter_list|)
name|pmap_t
name|pmap
decl_stmt|;
name|vm_offset_t
name|sva
decl_stmt|,
name|eva
decl_stmt|;
name|boolean_t
name|pageable
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|pmapdebug
operator|&
name|PDB_FOLLOW
condition|)
name|printf
argument_list|(
literal|"pmap_pageable(%x, %x, %x, %x)\n"
argument_list|,
name|pmap
argument_list|,
name|sva
argument_list|,
name|eva
argument_list|,
name|pageable
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  *	Clear the modify bits on the specified physical page.  */
end_comment

begin_function
name|void
name|pmap_clear_modify
parameter_list|(
name|pa
parameter_list|)
name|vm_offset_t
name|pa
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|pmapdebug
operator|&
name|PDB_FOLLOW
condition|)
name|printf
argument_list|(
literal|"pmap_clear_modify(%x)\n"
argument_list|,
name|pa
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ATTR
name|pmap_attributes
index|[
name|atop
argument_list|(
name|pa
argument_list|)
index|]
operator|&=
operator|~
name|PMAP_ATTR_MOD
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  *	pmap_clear_reference:  *  *	Clear the reference bit on the specified physical page.  */
end_comment

begin_function
name|void
name|pmap_clear_reference
parameter_list|(
name|pa
parameter_list|)
name|vm_offset_t
name|pa
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|pmapdebug
operator|&
name|PDB_FOLLOW
condition|)
name|printf
argument_list|(
literal|"pmap_clear_reference(%x)\n"
argument_list|,
name|pa
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ATTR
name|pmap_attributes
index|[
name|atop
argument_list|(
name|pa
argument_list|)
index|]
operator|&=
operator|~
name|PMAP_ATTR_REF
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  *	pmap_is_referenced:  *  *	Return whether or not the specified physical page is referenced  *	by any physical maps.  */
end_comment

begin_function
name|boolean_t
name|pmap_is_referenced
parameter_list|(
name|pa
parameter_list|)
name|vm_offset_t
name|pa
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|ATTR
return|return
operator|(
name|pmap_attributes
index|[
name|atop
argument_list|(
name|pa
argument_list|)
index|]
operator|&
name|PMAP_ATTR_REF
operator|)
return|;
else|#
directive|else
return|return
operator|(
name|FALSE
operator|)
return|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  *	pmap_is_modified:  *  *	Return whether or not the specified physical page is modified  *	by any physical maps.  */
end_comment

begin_function
name|boolean_t
name|pmap_is_modified
parameter_list|(
name|pa
parameter_list|)
name|vm_offset_t
name|pa
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|ATTR
return|return
operator|(
name|pmap_attributes
index|[
name|atop
argument_list|(
name|pa
argument_list|)
index|]
operator|&
name|PMAP_ATTR_MOD
operator|)
return|;
else|#
directive|else
return|return
operator|(
name|FALSE
operator|)
return|;
endif|#
directive|endif
block|}
end_function

begin_function
name|vm_offset_t
name|pmap_phys_address
parameter_list|(
name|ppn
parameter_list|)
name|int
name|ppn
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|pmapdebug
operator|&
name|PDB_FOLLOW
condition|)
name|printf
argument_list|(
literal|"pmap_phys_address(%x)\n"
argument_list|,
name|ppn
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|pmax_ptob
argument_list|(
name|ppn
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Miscellaneous support routines  */
end_comment

begin_comment
comment|/*  * Allocate a hardware PID and return it.  * It takes almost as much or more time to search the TLB for a  * specific PID and flush those entries as it does to flush the entire TLB.  * Therefore, when we allocate a new PID, we just take the next number. When  * we run out of numbers, we flush the TLB, increment the generation count  * and start over. PID zero is reserved for kernel use.  * This is called only by swtch().  */
end_comment

begin_function
name|int
name|pmap_alloc_tlbpid
parameter_list|(
name|p
parameter_list|)
specifier|register
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
block|{
specifier|register
name|pmap_t
name|pmap
decl_stmt|;
specifier|register
name|int
name|id
decl_stmt|;
name|pmap
operator|=
operator|&
name|p
operator|->
name|p_vmspace
operator|->
name|vm_pmap
expr_stmt|;
if|if
condition|(
name|pmap
operator|->
name|pm_tlbgen
operator|!=
name|tlbpid_gen
condition|)
block|{
name|id
operator|=
name|tlbpid_cnt
expr_stmt|;
if|if
condition|(
name|id
operator|==
name|VMMACH_NUM_PIDS
condition|)
block|{
name|MachTLBFlush
argument_list|()
expr_stmt|;
comment|/* reserve tlbpid_gen == 0 to alway mean invalid */
if|if
condition|(
operator|++
name|tlbpid_gen
operator|==
literal|0
condition|)
name|tlbpid_gen
operator|=
literal|1
expr_stmt|;
name|id
operator|=
literal|1
expr_stmt|;
block|}
name|tlbpid_cnt
operator|=
name|id
operator|+
literal|1
expr_stmt|;
name|pmap
operator|->
name|pm_tlbpid
operator|=
name|id
expr_stmt|;
name|pmap
operator|->
name|pm_tlbgen
operator|=
name|tlbpid_gen
expr_stmt|;
block|}
else|else
name|id
operator|=
name|pmap
operator|->
name|pm_tlbpid
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|pmapdebug
operator|&
operator|(
name|PDB_FOLLOW
operator||
name|PDB_TLBPID
operator|)
condition|)
block|{
if|if
condition|(
name|curproc
condition|)
name|printf
argument_list|(
literal|"pmap_alloc_tlbpid: curproc %d '%s' "
argument_list|,
name|curproc
operator|->
name|p_pid
argument_list|,
name|curproc
operator|->
name|p_comm
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"pmap_alloc_tlbpid: curproc<none> "
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"segtab %x tlbpid %d pid %d '%s'\n"
argument_list|,
name|pmap
operator|->
name|pm_segtab
argument_list|,
name|id
argument_list|,
name|p
operator|->
name|p_pid
argument_list|,
name|p
operator|->
name|p_comm
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
return|return
operator|(
name|id
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Remove a physical to virtual address translation.  */
end_comment

begin_function
name|void
name|pmap_remove_pv
parameter_list|(
name|pmap
parameter_list|,
name|va
parameter_list|,
name|pa
parameter_list|)
name|pmap_t
name|pmap
decl_stmt|;
name|vm_offset_t
name|va
decl_stmt|,
name|pa
decl_stmt|;
block|{
specifier|register
name|pv_entry_t
name|pv
decl_stmt|,
name|npv
decl_stmt|;
name|int
name|s
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|pmapdebug
operator|&
operator|(
name|PDB_FOLLOW
operator||
name|PDB_PVENTRY
operator|)
condition|)
name|printf
argument_list|(
literal|"pmap_remove_pv(%x, %x, %x)\n"
argument_list|,
name|pmap
argument_list|,
name|va
argument_list|,
name|pa
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Remove page from the PV table (raise IPL since we 	 * may be called at interrupt time). 	 */
if|if
condition|(
operator|!
name|IS_VM_PHYSADDR
argument_list|(
name|pa
argument_list|)
condition|)
return|return;
name|pv
operator|=
name|pa_to_pvh
argument_list|(
name|pa
argument_list|)
expr_stmt|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
comment|/* 	 * If it is the first entry on the list, it is actually 	 * in the header and we must copy the following entry up 	 * to the header.  Otherwise we must search the list for 	 * the entry.  In either case we free the now unused entry. 	 */
if|if
condition|(
name|pmap
operator|==
name|pv
operator|->
name|pv_pmap
operator|&&
name|va
operator|==
name|pv
operator|->
name|pv_va
condition|)
block|{
name|npv
operator|=
name|pv
operator|->
name|pv_next
expr_stmt|;
if|if
condition|(
name|npv
condition|)
block|{
operator|*
name|pv
operator|=
operator|*
name|npv
expr_stmt|;
name|free
argument_list|(
operator|(
name|caddr_t
operator|)
name|npv
argument_list|,
name|M_VMPVENT
argument_list|)
expr_stmt|;
block|}
else|else
name|pv
operator|->
name|pv_pmap
operator|=
name|NULL
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|remove_stats
operator|.
name|pvfirst
operator|++
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
for|for
control|(
name|npv
operator|=
name|pv
operator|->
name|pv_next
init|;
name|npv
condition|;
name|pv
operator|=
name|npv
operator|,
name|npv
operator|=
name|npv
operator|->
name|pv_next
control|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|remove_stats
operator|.
name|pvsearch
operator|++
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|pmap
operator|==
name|npv
operator|->
name|pv_pmap
operator|&&
name|va
operator|==
name|npv
operator|->
name|pv_va
condition|)
goto|goto
name|fnd
goto|;
block|}
ifdef|#
directive|ifdef
name|DIAGNOSTIC
name|printf
argument_list|(
literal|"pmap_remove_pv(%x, %x, %x) not found\n"
argument_list|,
name|pmap
argument_list|,
name|va
argument_list|,
name|pa
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"pmap_remove_pv"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|fnd
label|:
name|pv
operator|->
name|pv_next
operator|=
name|npv
operator|->
name|pv_next
expr_stmt|;
name|free
argument_list|(
operator|(
name|caddr_t
operator|)
name|npv
argument_list|,
name|M_VMPVENT
argument_list|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *	vm_page_alloc1:  *  *	Allocate and return a memory cell with no associated object.  */
end_comment

begin_function
name|vm_page_t
name|vm_page_alloc1
parameter_list|()
block|{
specifier|register
name|vm_page_t
name|mem
decl_stmt|;
name|int
name|spl
decl_stmt|;
name|spl
operator|=
name|splimp
argument_list|()
expr_stmt|;
comment|/* XXX */
name|simple_lock
argument_list|(
operator|&
name|vm_page_queue_free_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|queue_empty
argument_list|(
operator|&
name|vm_page_queue_free
argument_list|)
condition|)
block|{
name|simple_unlock
argument_list|(
operator|&
name|vm_page_queue_free_lock
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|spl
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|queue_remove_first
argument_list|(
operator|&
name|vm_page_queue_free
argument_list|,
name|mem
argument_list|,
name|vm_page_t
argument_list|,
name|pageq
argument_list|)
expr_stmt|;
name|cnt
operator|.
name|v_free_count
operator|--
expr_stmt|;
name|simple_unlock
argument_list|(
operator|&
name|vm_page_queue_free_lock
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|spl
argument_list|)
expr_stmt|;
name|mem
operator|->
name|flags
operator|=
name|PG_BUSY
operator||
name|PG_CLEAN
operator||
name|PG_FAKE
expr_stmt|;
name|mem
operator|->
name|wire_count
operator|=
literal|0
expr_stmt|;
comment|/* 	 *	Decide if we should poke the pageout daemon. 	 *	We do this if the free count is less than the low 	 *	water mark, or if the free count is less than the high 	 *	water mark (but above the low water mark) and the inactive 	 *	count is less than its target. 	 * 	 *	We don't have the counts locked ... if they change a little, 	 *	it doesn't really matter. 	 */
if|if
condition|(
name|cnt
operator|.
name|v_free_count
operator|<
name|cnt
operator|.
name|v_free_min
operator|||
operator|(
name|cnt
operator|.
name|v_free_count
operator|<
name|cnt
operator|.
name|v_free_target
operator|&&
name|cnt
operator|.
name|v_inactive_count
operator|<
name|cnt
operator|.
name|v_inactive_target
operator|)
condition|)
name|thread_wakeup
argument_list|(
operator|(
name|int
operator|)
operator|&
name|vm_pages_needed
argument_list|)
expr_stmt|;
return|return
operator|(
name|mem
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *	vm_page_free1:  *  *	Returns the given page to the free list,  *	disassociating it with any VM object.  *  *	Object and page must be locked prior to entry.  */
end_comment

begin_function
name|void
name|vm_page_free1
parameter_list|(
name|mem
parameter_list|)
specifier|register
name|vm_page_t
name|mem
decl_stmt|;
block|{
if|if
condition|(
name|mem
operator|->
name|flags
operator|&
name|PG_ACTIVE
condition|)
block|{
name|queue_remove
argument_list|(
operator|&
name|vm_page_queue_active
argument_list|,
name|mem
argument_list|,
name|vm_page_t
argument_list|,
name|pageq
argument_list|)
expr_stmt|;
name|mem
operator|->
name|flags
operator|&=
operator|~
name|PG_ACTIVE
expr_stmt|;
name|cnt
operator|.
name|v_active_count
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|mem
operator|->
name|flags
operator|&
name|PG_INACTIVE
condition|)
block|{
name|queue_remove
argument_list|(
operator|&
name|vm_page_queue_inactive
argument_list|,
name|mem
argument_list|,
name|vm_page_t
argument_list|,
name|pageq
argument_list|)
expr_stmt|;
name|mem
operator|->
name|flags
operator|&=
operator|~
name|PG_INACTIVE
expr_stmt|;
name|cnt
operator|.
name|v_inactive_count
operator|--
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|mem
operator|->
name|flags
operator|&
name|PG_FICTITIOUS
operator|)
condition|)
block|{
name|int
name|spl
decl_stmt|;
name|spl
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|simple_lock
argument_list|(
operator|&
name|vm_page_queue_free_lock
argument_list|)
expr_stmt|;
name|queue_enter
argument_list|(
operator|&
name|vm_page_queue_free
argument_list|,
name|mem
argument_list|,
name|vm_page_t
argument_list|,
name|pageq
argument_list|)
expr_stmt|;
name|cnt
operator|.
name|v_free_count
operator|++
expr_stmt|;
name|simple_unlock
argument_list|(
operator|&
name|vm_page_queue_free_lock
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|spl
argument_list|)
expr_stmt|;
block|}
block|}
end_function

end_unit

