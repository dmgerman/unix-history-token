begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_ifdef
ifdef|#
directive|ifdef
name|RCSIDENT
end_ifdef

begin_decl_stmt
specifier|static
name|char
name|rcsident
index|[]
init|=
literal|"$Header: raw_input.c,v 1.17 85/07/31 09:33:16 walsh Exp $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"../h/param.h"
end_include

begin_include
include|#
directive|include
file|"../h/dir.h"
end_include

begin_include
include|#
directive|include
file|"../h/user.h"
end_include

begin_include
include|#
directive|include
file|"../machine/mtpr.h"
end_include

begin_include
include|#
directive|include
file|"../h/mbuf.h"
end_include

begin_include
include|#
directive|include
file|"../h/socket.h"
end_include

begin_include
include|#
directive|include
file|"../h/socketvar.h"
end_include

begin_include
include|#
directive|include
file|"../net/if.h"
end_include

begin_include
include|#
directive|include
file|"../net/netisr.h"
end_include

begin_include
include|#
directive|include
file|"../net/route.h"
end_include

begin_include
include|#
directive|include
file|"../net/raw_cb.h"
end_include

begin_include
include|#
directive|include
file|"../bbnnet/in.h"
end_include

begin_include
include|#
directive|include
file|"../bbnnet/net.h"
end_include

begin_include
include|#
directive|include
file|"../bbnnet/in_pcb.h"
end_include

begin_include
include|#
directive|include
file|"../bbnnet/in_var.h"
end_include

begin_include
include|#
directive|include
file|"../bbnnet/ip.h"
end_include

begin_include
include|#
directive|include
file|"../bbnnet/fsm.h"
end_include

begin_include
include|#
directive|include
file|"../bbnnet/tcp.h"
end_include

begin_include
include|#
directive|include
file|"../bbnnet/icmp.h"
end_include

begin_include
include|#
directive|include
file|"../bbnnet/udp.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HMP
end_ifdef

begin_include
include|#
directive|include
file|"../bbnnet/hmp.h"
end_include

begin_endif
endif|#
directive|endif
endif|HMP
end_endif

begin_include
include|#
directive|include
file|"../bbnnet/nopcb.h"
end_include

begin_comment
comment|/*  * Sort INET packets for user(s).  To get a packet, socket must match:  *  *    raw_ip_proto  *		domain   (INET)  *		protocol (TCP/UDP/ICMP)  *    raw_ip_dst  *		domain   (INET)  *		address, but not port, if connected(2)  *    raw_ip_src  *		domain   (INET)  *		address, but not port, if bound(2)  *  * Called from ip_input() for packets that were well-formed enough to get  * passed up to TCP/UDP/ICMP.  */
end_comment

begin_decl_stmt
name|struct
name|sockaddr_in
name|raw_ip_dst
init|=
block|{
name|AF_INET
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|sockaddr_in
name|raw_ip_src
init|=
block|{
name|AF_INET
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|sockproto
name|raw_ip_proto
init|=
block|{
name|PF_INET
block|}
decl_stmt|;
end_decl_stmt

begin_macro
name|raw_ip_input
argument_list|(
argument|m
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|ip
modifier|*
name|ip
init|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ip
operator|*
argument_list|)
decl_stmt|;
name|raw_ip_proto
operator|.
name|sp_protocol
operator|=
name|ip
operator|->
name|ip_p
expr_stmt|;
name|raw_ip_dst
operator|.
name|sin_addr
operator|.
name|s_addr
operator|=
name|ip
operator|->
name|ip_dst
operator|.
name|s_addr
expr_stmt|;
name|raw_ip_src
operator|.
name|sin_addr
operator|.
name|s_addr
operator|=
name|ip
operator|->
name|ip_src
operator|.
name|s_addr
expr_stmt|;
name|raw_input
argument_list|(
name|m
argument_list|,
operator|&
name|raw_ip_proto
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|raw_ip_src
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|raw_ip_dst
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Bad ip packets, which are taken care of via calls to ip_log() and netlog().  */
end_comment

begin_decl_stmt
name|struct
name|sockaddr_in
name|netlog_dst
init|=
block|{
name|AF_INET
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|sockaddr_in
name|netlog_src
init|=
block|{
name|AF_INET
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|sockproto
name|netlog_proto
init|=
block|{
name|PF_INET
block|,
name|NETLOG_PROTO
block|}
decl_stmt|;
end_decl_stmt

begin_macro
name|netlog
argument_list|(
argument|m
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|raw_input
argument_list|(
name|m
argument_list|,
operator|&
name|netlog_proto
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|netlog_src
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|netlog_dst
argument_list|)
expr_stmt|;
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|AF_TCPDEBUG
end_ifdef

begin_comment
comment|/* 	 * TCP debugging log 	 * 	 * Though the mbuf contains a copy of the tcpcb, and thus a pointer to the 	 * inpcb, kernel can't do address sorting since this may point within a freed 	 * (and perhaps now recycled) mbuf.  Remember that this logging is done after 	 * state changes (closing). 	 */
end_comment

begin_decl_stmt
name|struct
name|sockaddr_in
name|tcpdebug_dst
init|=
block|{
name|AF_TCPDEBUG
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|sockaddr_in
name|tcpdebug_src
init|=
block|{
name|AF_TCPDEBUG
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|sockproto
name|tcpdebug_proto
init|=
block|{
name|PF_TCPDEBUG
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_macro
name|tcpdebuglog
argument_list|(
argument|m
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|raw_input
argument_list|(
name|m
argument_list|,
operator|&
name|tcpdebug_proto
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|tcpdebug_src
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|tcpdebug_dst
argument_list|)
expr_stmt|;
block|}
end_block

begin_else
else|#
directive|else
end_else

begin_macro
name|tcpdebuglog
argument_list|(
argument|m
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|AF_RDPDEBUG
end_ifdef

begin_decl_stmt
name|struct
name|sockaddr_in
name|rdpdebug_dst
init|=
block|{
name|AF_RDPDEBUG
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|sockaddr_in
name|rdpdebug_src
init|=
block|{
name|AF_RDPDEBUG
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|sockproto
name|rdpdebug_proto
init|=
block|{
name|PF_RDPDEBUG
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_macro
name|rdpdebuglog
argument_list|(
argument|m
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|raw_input
argument_list|(
name|m
argument_list|,
operator|&
name|rdpdebug_proto
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|rdpdebug_src
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|rdpdebug_dst
argument_list|)
expr_stmt|;
block|}
end_block

begin_else
else|#
directive|else
end_else

begin_macro
name|rdpdebuglog
argument_list|(
argument|m
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|struct
name|mbuf
modifier|*
name|m_bpullup
parameter_list|(
name|m0
parameter_list|,
name|len
parameter_list|)
name|struct
name|mbuf
modifier|*
name|m0
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
specifier|register
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|,
modifier|*
name|n
decl_stmt|;
name|unsigned
name|count
decl_stmt|;
name|n
operator|=
name|m0
expr_stmt|;
if|if
condition|(
name|len
operator|>
name|MLEN
condition|)
block|{
name|m_freem
argument_list|(
name|n
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
expr|struct
name|mbuf
operator|*
operator|)
name|NULL
operator|)
return|;
block|}
ifdef|#
directive|ifdef
name|MBUF_DEBUG
name|m
operator|=
name|m_get
argument_list|(
name|M_DONTWAIT
argument_list|,
name|n
operator|->
name|m_type
argument_list|)
expr_stmt|;
else|#
directive|else
name|MGET
argument_list|(
name|m
argument_list|,
name|M_DONTWAIT
argument_list|,
name|n
operator|->
name|m_type
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|m
operator|==
literal|0
condition|)
block|{
name|m_freem
argument_list|(
name|n
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
expr|struct
name|mbuf
operator|*
operator|)
name|NULL
operator|)
return|;
block|}
name|m
operator|->
name|m_len
operator|=
literal|0
expr_stmt|;
name|m
operator|->
name|m_off
operator|=
name|MMAXOFF
operator|-
name|len
expr_stmt|;
comment|/* -- difference from m_pullup -- */
do|do
block|{
name|count
operator|=
name|MIN
argument_list|(
name|len
argument_list|,
name|n
operator|->
name|m_len
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|mtod
argument_list|(
name|n
argument_list|,
name|caddr_t
argument_list|)
argument_list|,
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
operator|+
name|m
operator|->
name|m_len
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|len
operator|-=
name|count
expr_stmt|;
name|m
operator|->
name|m_len
operator|+=
name|count
expr_stmt|;
name|n
operator|->
name|m_off
operator|+=
name|count
expr_stmt|;
name|n
operator|->
name|m_len
operator|-=
name|count
expr_stmt|;
if|if
condition|(
name|n
operator|->
name|m_len
condition|)
break|break;
name|n
operator|=
name|m_free
argument_list|(
name|n
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|n
condition|)
do|;
if|if
condition|(
name|len
condition|)
block|{
operator|(
name|void
operator|)
name|m_free
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|n
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
expr|struct
name|mbuf
operator|*
operator|)
name|NULL
operator|)
return|;
block|}
name|m
operator|->
name|m_next
operator|=
name|n
expr_stmt|;
return|return
operator|(
name|m
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * output function called from net/raw_usrreq  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_macro
name|raw_ip_output
argument_list|(
argument|m0
argument_list|,
argument|so
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|mbuf
modifier|*
name|m0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
specifier|register
name|struct
name|ip
modifier|*
name|ip
decl_stmt|;
specifier|register
name|int
name|len
decl_stmt|;
name|int
name|retval
decl_stmt|;
comment|/*      * verify length of datagram, get IP header at end of mbuf so can      * prepend local net header.      */
name|len
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|m
operator|=
name|m0
init|;
name|m
condition|;
name|m
operator|=
name|m
operator|->
name|m_next
control|)
name|len
operator|+=
name|m
operator|->
name|m_len
expr_stmt|;
if|if
condition|(
name|len
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
condition|)
block|{
name|m_freem
argument_list|(
name|m0
argument_list|)
expr_stmt|;
return|return
operator|(
name|EMSGSIZE
operator|)
return|;
comment|/* ### */
block|}
if|if
condition|(
operator|(
name|m
operator|=
name|m_bpullup
argument_list|(
name|m0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOBUFS
operator|)
return|;
name|ip
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ip
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ntohs
argument_list|(
operator|(
name|u_short
operator|)
name|ip
operator|->
name|ip_len
argument_list|)
operator|!=
name|len
operator|)
operator|||
operator|(
operator|(
name|ip
operator|->
name|ip_hl
operator|<<
name|IP_HLSHIFT
operator|)
operator|>
name|len
operator|)
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|EMSGSIZE
operator|)
return|;
comment|/* ### */
block|}
ifdef|#
directive|ifdef
name|notdef
comment|/* have to be super-user anyway to do this.      * Cronus wants to be able to forward broadcast UDP packets.      */
comment|/*      * verify that addresses are valid      */
if|if
condition|(
name|in_broadcast
argument_list|(
name|ip
operator|->
name|ip_src
argument_list|)
operator|||
operator|(
name|in_iawithaddr
argument_list|(
name|ip
operator|->
name|ip_src
argument_list|,
name|TRUE
argument_list|)
operator|==
literal|0
operator|)
condition|)
else|#
directive|else
if|if
condition|(
name|in_broadcast
argument_list|(
name|ip
operator|->
name|ip_src
argument_list|)
condition|)
endif|#
directive|endif
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|EADDRNOTAVAIL
operator|)
return|;
block|}
name|NOPCB_IPSEND
argument_list|(
name|m
argument_list|,
name|len
argument_list|,
name|TRUE
argument_list|,
name|retval
argument_list|)
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Send out an icmp packet.  Use the user's ICMP header, and our own IP  * header.  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_macro
name|raw_icmp_output
argument_list|(
argument|m0
argument_list|,
argument|so
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|mbuf
modifier|*
name|m0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
specifier|register
name|struct
name|icmp
modifier|*
name|p
decl_stmt|;
specifier|register
name|struct
name|ip
modifier|*
name|ip
decl_stmt|;
specifier|register
name|struct
name|rawcb
modifier|*
name|rcb
decl_stmt|;
name|int
name|len
decl_stmt|;
name|int
name|retval
decl_stmt|;
name|rcb
operator|=
name|sotorawcb
argument_list|(
name|so
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|rcb
operator|->
name|rcb_flags
operator|&
name|RAW_FADDR
operator|)
condition|)
block|{
name|m_freem
argument_list|(
name|m0
argument_list|)
expr_stmt|;
return|return
operator|(
name|EDESTADDRREQ
operator|)
return|;
block|}
comment|/*      * find length of datagram      */
name|len
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|m
operator|=
name|m0
init|;
name|m
condition|;
name|m
operator|=
name|m
operator|->
name|m_next
control|)
name|len
operator|+=
name|m
operator|->
name|m_len
expr_stmt|;
if|if
condition|(
name|len
operator|<
name|ICMPSIZE
condition|)
block|{
name|m_freem
argument_list|(
name|m0
argument_list|)
expr_stmt|;
return|return
operator|(
name|EMSGSIZE
operator|)
return|;
comment|/* ### */
block|}
comment|/*      * Pull up user's ICMP header so we can prepend IP header later.      */
if|if
condition|(
operator|(
name|m
operator|=
name|m_bpullup
argument_list|(
name|m0
argument_list|,
name|ICMPSIZE
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOBUFS
operator|)
return|;
comment|/*      * "Verify" ICMP header.  Accept user's type and code.      */
name|p
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|icmp
operator|*
argument_list|)
expr_stmt|;
comment|/*      * Use our own checksum, though.  It'll be at least as fast as the      * user's and we'll have to use those CPU cycles sometime.      */
name|p
operator|->
name|ic_sum
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|ic_sum
operator|=
name|in_cksum
argument_list|(
name|m
argument_list|,
name|len
argument_list|)
expr_stmt|;
comment|/*      * Fill in IP header and send it      */
name|m
operator|->
name|m_off
operator|-=
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_len
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
expr_stmt|;
name|ip
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ip
operator|*
argument_list|)
expr_stmt|;
name|ip
operator|->
name|ip_p
operator|=
name|IPPROTO_ICMP
expr_stmt|;
name|ip
operator|->
name|ip_tos
operator|=
literal|0
expr_stmt|;
name|ip
operator|->
name|ip_dst
operator|.
name|s_addr
operator|=
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|&
name|rcb
operator|->
name|rcb_faddr
operator|)
operator|->
name|sin_addr
operator|.
name|s_addr
expr_stmt|;
if|if
condition|(
name|rcb
operator|->
name|rcb_flags
operator|&
name|RAW_LADDR
condition|)
block|{
name|ip
operator|->
name|ip_src
operator|.
name|s_addr
operator|=
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|&
name|rcb
operator|->
name|rcb_laddr
operator|)
operator|->
name|sin_addr
operator|.
name|s_addr
expr_stmt|;
block|}
else|else
block|{
comment|/* 	 * We may examine the routing tables twice. 	 * perhaps if this gets used a lot, it can be changed. 	 */
name|struct
name|route
name|r
decl_stmt|;
name|struct
name|rtentry
modifier|*
name|rt
decl_stmt|;
name|bzero
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|r
argument_list|,
sizeof|sizeof
argument_list|(
name|r
argument_list|)
argument_list|)
expr_stmt|;
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|(
operator|&
name|r
operator|.
name|ro_dst
operator|)
operator|)
operator|->
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|(
operator|&
name|r
operator|.
name|ro_dst
operator|)
operator|)
operator|->
name|sin_addr
operator|.
name|s_addr
operator|=
name|ip
operator|->
name|ip_dst
operator|.
name|s_addr
expr_stmt|;
name|rtalloc
argument_list|(
operator|&
name|r
argument_list|)
expr_stmt|;
if|if
condition|(
name|rt
operator|=
name|r
operator|.
name|ro_rt
condition|)
block|{
name|ip
operator|->
name|ip_src
operator|=
name|IA_INADDR
argument_list|(
name|in_iafromif
argument_list|(
name|rt
operator|->
name|rt_ifp
argument_list|)
argument_list|)
expr_stmt|;
name|rtfree
argument_list|(
name|rt
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENETUNREACH
operator|)
return|;
block|}
block|}
name|NOPCB_IPSEND
argument_list|(
name|m
argument_list|,
name|len
argument_list|,
name|FALSE
argument_list|,
name|retval
argument_list|)
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|NSIP
end_ifdef

begin_comment
comment|/*  * Generate IP header and pass packet to ip_output.  * Tack on options user may have setup with control call.  */
end_comment

begin_macro
name|rip_output
argument_list|(
argument|m0
argument_list|,
argument|so
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|mbuf
modifier|*
name|m0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
comment|/*      * get an mbuf for IP header.      */
name|m
operator|=
name|m_get
argument_list|(
name|M_DONTWAIT
argument_list|,
name|MT_HEADER
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
name|m_freem
argument_list|(
name|m0
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
comment|/*      * Fill in IP header as needed.      */
name|m
operator|->
name|m_off
operator|=
name|MMAXOFF
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_next
operator|=
name|m0
expr_stmt|;
block|{
specifier|register
name|struct
name|ip
modifier|*
name|ip
decl_stmt|;
specifier|register
name|struct
name|rawcb
modifier|*
name|rcb
init|=
name|sotorawcb
argument_list|(
name|so
argument_list|)
decl_stmt|;
name|ip
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ip
operator|*
argument_list|)
expr_stmt|;
name|ip
operator|->
name|ip_p
operator|=
name|rcb
operator|->
name|rcb_proto
operator|.
name|sp_protocol
expr_stmt|;
name|ip
operator|->
name|ip_tos
operator|=
literal|0
expr_stmt|;
name|ip
operator|->
name|ip_dst
operator|.
name|s_addr
operator|=
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|&
name|rcb
operator|->
name|rcb_faddr
operator|)
operator|->
name|sin_addr
operator|.
name|s_addr
expr_stmt|;
if|if
condition|(
name|rcb
operator|->
name|rcb_flags
operator|&
name|RAW_LADDR
condition|)
name|ip
operator|->
name|ip_src
operator|.
name|s_addr
operator|=
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|&
name|rcb
operator|->
name|rcb_laddr
operator|)
operator|->
name|sin_addr
operator|.
name|s_addr
expr_stmt|;
else|else
name|ip
operator|->
name|ip_src
operator|.
name|s_addr
operator|=
literal|0
expr_stmt|;
block|}
block|{
specifier|register
name|int
name|retval
decl_stmt|;
specifier|register
name|int
name|len
decl_stmt|;
comment|/*      * Calculate data length      */
name|len
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|m0
condition|)
block|{
name|len
operator|+=
name|m0
operator|->
name|m_len
expr_stmt|;
name|m0
operator|=
name|m0
operator|->
name|m_next
expr_stmt|;
block|}
name|NOPCB_IPSEND
argument_list|(
name|m
argument_list|,
name|len
argument_list|,
name|FALSE
argument_list|,
name|retval
argument_list|)
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
block|}
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * The UDP header is so small and simple, the user should either:  *	1.  go all the way and use a raw IP socket  * or	2.  use send(2) type system calls.  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_macro
name|raw_udp_output
argument_list|(
argument|m0
argument_list|,
argument|so
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|mbuf
modifier|*
name|m0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|m_freem
argument_list|(
name|m0
argument_list|)
expr_stmt|;
return|return
operator|(
name|EOPNOTSUPP
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * TCP requires a lot of state information.  Sure we could try to verify the  * user's header and pass it on to ip, but unless debugging a new version  * in user code with a different protocol number, probably shouldn't ship  * out tcp packets, since we'll get packets in reply that might screw us up.  *  * And how does the sending of a single tcp packet make sense?  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_macro
name|raw_tcp_output
argument_list|(
argument|m0
argument_list|,
argument|so
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|mbuf
modifier|*
name|m0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|m_freem
argument_list|(
name|m0
argument_list|)
expr_stmt|;
return|return
operator|(
name|EOPNOTSUPP
operator|)
return|;
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|RDP
end_ifdef

begin_comment
comment|/*  * ditto TCP for RDP  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_macro
name|raw_rdp_output
argument_list|(
argument|m0
argument_list|,
argument|so
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|mbuf
modifier|*
name|m0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|m_freem
argument_list|(
name|m0
argument_list|)
expr_stmt|;
return|return
operator|(
name|EOPNOTSUPP
operator|)
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * use the user level stuff to send -- much simpler   */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HMP
end_ifdef

begin_comment
comment|/* ARGSUSED */
end_comment

begin_macro
name|raw_hmp_output
argument_list|(
argument|m0
argument_list|,
argument|so
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|mbuf
modifier|*
name|m0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|m_freem
argument_list|(
name|m0
argument_list|)
expr_stmt|;
return|return
operator|(
name|EOPNOTSUPP
operator|)
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

end_unit

