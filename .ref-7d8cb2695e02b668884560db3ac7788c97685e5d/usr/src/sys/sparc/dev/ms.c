begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1992 The Regents of the University of California.  * All rights reserved.  *  * This software was developed by the Computer Systems Engineering group  * at Lawrence Berkeley Laboratory under DARPA contract BG 91-66 and  * contributed to Berkeley.  *  * All advertising materials mentioning features or use of this software  * must display the following acknowledgement:  *	This product includes software developed by the University of  *	California, Lawrence Berkeley Laboratory.  *  * %sccs.include.redist.c%  *  *	@(#)ms.c	7.4 (Berkeley) %G%  *  * from: $Header: ms.c,v 1.5 92/11/26 01:28:47 torek Exp $ (LBL)  */
end_comment

begin_comment
comment|/*  * Mouse driver.  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/syslog.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/tty.h>
end_include

begin_include
include|#
directive|include
file|<sparc/dev/vuid_event.h>
end_include

begin_include
include|#
directive|include
file|<sparc/dev/event_var.h>
end_include

begin_comment
comment|/*  * Mouse state.  A Mouse Systems mouse is a fairly simple device,  * producing five-byte blobs of the form:  *  *	b dx dy dx dy  *  * where b is the button state, encoded as 0x80|(~buttons)---there are  * three buttons (4=left, 2=middle, 1=right)---and dx,dy are X and Y  * delta values, none of which have are in [0x80..0x87].  (This lets  * us sync up with the mouse after an error.)  */
end_comment

begin_struct
struct|struct
name|ms_softc
block|{
name|short
name|ms_byteno
decl_stmt|;
comment|/* input byte number, for decode */
name|char
name|ms_mb
decl_stmt|;
comment|/* mouse button state */
name|char
name|ms_ub
decl_stmt|;
comment|/* user button state */
name|int
name|ms_dx
decl_stmt|;
comment|/* delta-x */
name|int
name|ms_dy
decl_stmt|;
comment|/* delta-y */
name|struct
name|tty
modifier|*
name|ms_mouse
decl_stmt|;
comment|/* downlink for output to mouse */
name|void
argument_list|(
argument|*ms_open
argument_list|)
name|__P
argument_list|(
operator|(
expr|struct
name|tty
operator|*
operator|)
argument_list|)
expr_stmt|;
comment|/* enable dataflow */
name|void
argument_list|(
argument|*ms_close
argument_list|)
name|__P
argument_list|(
operator|(
expr|struct
name|tty
operator|*
operator|)
argument_list|)
expr_stmt|;
comment|/* disable dataflow */
specifier|volatile
name|int
name|ms_ready
decl_stmt|;
comment|/* event queue is ready */
name|struct
name|evvar
name|ms_events
decl_stmt|;
comment|/* event queue state */
block|}
name|ms_softc
struct|;
end_struct

begin_comment
comment|/*  * Attach the mouse serial (down-link) interface.  * Do we need to set it to 1200 baud, 8 bits?  * Test by power cycling and not booting SunOS before BSD?  */
end_comment

begin_decl_stmt
name|void
name|ms_serial
argument_list|(
name|tp
argument_list|,
name|iopen
argument_list|,
name|iclose
argument_list|)
decl|struct
name|tty
modifier|*
name|tp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
argument_list|(
operator|*
name|iopen
argument_list|)
argument_list|()
decl_stmt|,
argument_list|(
operator|*
name|iclose
argument_list|)
argument_list|()
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|ms_softc
operator|.
name|ms_mouse
operator|=
name|tp
expr_stmt|;
name|ms_softc
operator|.
name|ms_open
operator|=
name|iopen
expr_stmt|;
name|ms_softc
operator|.
name|ms_close
operator|=
name|iclose
expr_stmt|;
block|}
end_block

begin_function
name|void
name|ms_rint
parameter_list|(
name|c
parameter_list|)
specifier|register
name|int
name|c
decl_stmt|;
block|{
specifier|register
name|struct
name|firm_event
modifier|*
name|fe
decl_stmt|;
specifier|register
name|struct
name|ms_softc
modifier|*
name|ms
init|=
operator|&
name|ms_softc
decl_stmt|;
specifier|register
name|int
name|mb
decl_stmt|,
name|ub
decl_stmt|,
name|d
decl_stmt|,
name|get
decl_stmt|,
name|put
decl_stmt|,
name|any
decl_stmt|;
specifier|static
specifier|const
name|char
name|to_one
index|[]
init|=
block|{
literal|1
block|,
literal|2
block|,
literal|2
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|}
decl_stmt|;
specifier|static
specifier|const
name|int
name|to_id
index|[]
init|=
block|{
name|MS_RIGHT
block|,
name|MS_MIDDLE
block|,
literal|0
block|,
name|MS_LEFT
block|}
decl_stmt|;
comment|/* 	 * Discard input if not ready.  Drop sync on parity or framing 	 * error; gain sync on button byte. 	 */
if|if
condition|(
name|ms
operator|->
name|ms_ready
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
name|c
operator|&
operator|(
name|TTY_FE
operator||
name|TTY_PE
operator|)
condition|)
block|{
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"mouse input parity or framing error (0x%x)\n"
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|ms
operator|->
name|ms_byteno
operator|=
operator|-
literal|1
expr_stmt|;
return|return;
block|}
if|if
condition|(
call|(
name|unsigned
call|)
argument_list|(
name|c
operator|-
literal|0x80
argument_list|)
operator|<
literal|8
condition|)
comment|/* if in 0x80..0x87 */
name|ms
operator|->
name|ms_byteno
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Run the decode loop, adding to the current information. 	 * We add, rather than replace, deltas, so that if the event queue 	 * fills, we accumulate data for when it opens up again. 	 */
switch|switch
condition|(
name|ms
operator|->
name|ms_byteno
condition|)
block|{
case|case
operator|-
literal|1
case|:
return|return;
case|case
literal|0
case|:
comment|/* buttons */
name|ms
operator|->
name|ms_byteno
operator|=
literal|1
expr_stmt|;
name|ms
operator|->
name|ms_mb
operator|=
operator|(
operator|~
name|c
operator|)
operator|&
literal|0x7
expr_stmt|;
return|return;
case|case
literal|1
case|:
comment|/* first delta-x */
name|ms
operator|->
name|ms_byteno
operator|=
literal|2
expr_stmt|;
name|ms
operator|->
name|ms_dx
operator|+=
operator|(
name|char
operator|)
name|c
expr_stmt|;
return|return;
case|case
literal|2
case|:
comment|/* first delta-y */
name|ms
operator|->
name|ms_byteno
operator|=
literal|3
expr_stmt|;
name|ms
operator|->
name|ms_dy
operator|+=
operator|(
name|char
operator|)
name|c
expr_stmt|;
return|return;
case|case
literal|3
case|:
comment|/* second delta-x */
name|ms
operator|->
name|ms_byteno
operator|=
literal|4
expr_stmt|;
name|ms
operator|->
name|ms_dx
operator|+=
operator|(
name|char
operator|)
name|c
expr_stmt|;
return|return;
case|case
literal|4
case|:
comment|/* second delta-x */
name|ms
operator|->
name|ms_byteno
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* wait for button-byte again */
name|ms
operator|->
name|ms_dy
operator|+=
operator|(
name|char
operator|)
name|c
expr_stmt|;
break|break;
default|default:
name|panic
argument_list|(
literal|"ms_rint"
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
comment|/* 	 * We have at least one event (mouse button, delta-X, or 	 * delta-Y; possibly all three, and possibly three separate 	 * button events).  Deliver these events until we are out 	 * of changes or out of room.  As events get delivered, 	 * mark them `unchanged'. 	 */
name|any
operator|=
literal|0
expr_stmt|;
name|get
operator|=
name|ms
operator|->
name|ms_events
operator|.
name|ev_get
expr_stmt|;
name|put
operator|=
name|ms
operator|->
name|ms_events
operator|.
name|ev_put
expr_stmt|;
name|fe
operator|=
operator|&
name|ms
operator|->
name|ms_events
operator|.
name|ev_q
index|[
name|put
index|]
expr_stmt|;
comment|/* NEXT prepares to put the next event, backing off if necessary */
define|#
directive|define
name|NEXT
define|\
value|if ((++put) % EV_QSIZE == get) { \ 		put--; \ 		goto out; \ 	}
comment|/* ADVANCE completes the `put' of the event */
define|#
directive|define
name|ADVANCE
define|\
value|fe++; \ 	if (put>= EV_QSIZE) { \ 		put = 0; \ 		fe =&ms->ms_events.ev_q[0]; \ 	} \ 	any = 1
name|mb
operator|=
name|ms
operator|->
name|ms_mb
expr_stmt|;
name|ub
operator|=
name|ms
operator|->
name|ms_ub
expr_stmt|;
while|while
condition|(
operator|(
name|d
operator|=
name|mb
operator|^
name|ub
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* 		 * Mouse button change.  Convert up to three changes 		 * to the `first' change, and drop it into the event queue. 		 */
name|NEXT
expr_stmt|;
name|d
operator|=
name|to_one
index|[
name|d
operator|-
literal|1
index|]
expr_stmt|;
comment|/* from 1..7 to {1,2,4} */
name|fe
operator|->
name|id
operator|=
name|to_id
index|[
name|d
operator|-
literal|1
index|]
expr_stmt|;
comment|/* from {1,2,4} to ID */
name|fe
operator|->
name|value
operator|=
name|mb
operator|&
name|d
condition|?
name|VKEY_DOWN
else|:
name|VKEY_UP
expr_stmt|;
name|fe
operator|->
name|time
operator|=
name|time
expr_stmt|;
name|ADVANCE
expr_stmt|;
name|ub
operator|^=
name|d
expr_stmt|;
block|}
if|if
condition|(
name|ms
operator|->
name|ms_dx
condition|)
block|{
name|NEXT
expr_stmt|;
name|fe
operator|->
name|id
operator|=
name|LOC_X_DELTA
expr_stmt|;
name|fe
operator|->
name|value
operator|=
name|ms
operator|->
name|ms_dx
expr_stmt|;
name|fe
operator|->
name|time
operator|=
name|time
expr_stmt|;
name|ADVANCE
expr_stmt|;
name|ms
operator|->
name|ms_dx
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|ms
operator|->
name|ms_dy
condition|)
block|{
name|NEXT
expr_stmt|;
name|fe
operator|->
name|id
operator|=
name|LOC_Y_DELTA
expr_stmt|;
name|fe
operator|->
name|value
operator|=
name|ms
operator|->
name|ms_dy
expr_stmt|;
name|fe
operator|->
name|time
operator|=
name|time
expr_stmt|;
name|ADVANCE
expr_stmt|;
name|ms
operator|->
name|ms_dy
operator|=
literal|0
expr_stmt|;
block|}
name|out
label|:
if|if
condition|(
name|any
condition|)
block|{
name|ms
operator|->
name|ms_ub
operator|=
name|ub
expr_stmt|;
name|ms
operator|->
name|ms_events
operator|.
name|ev_put
operator|=
name|put
expr_stmt|;
name|EV_WAKEUP
argument_list|(
operator|&
name|ms
operator|->
name|ms_events
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int
name|msopen
parameter_list|(
name|dev
parameter_list|,
name|flags
parameter_list|,
name|mode
parameter_list|,
name|p
parameter_list|)
name|dev_t
name|dev
decl_stmt|;
name|int
name|flags
decl_stmt|,
name|mode
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
block|{
name|int
name|s
decl_stmt|,
name|error
decl_stmt|;
if|if
condition|(
name|ms_softc
operator|.
name|ms_events
operator|.
name|ev_io
condition|)
return|return
operator|(
name|EBUSY
operator|)
return|;
name|ms_softc
operator|.
name|ms_events
operator|.
name|ev_io
operator|=
name|p
expr_stmt|;
name|ev_init
argument_list|(
operator|&
name|ms_softc
operator|.
name|ms_events
argument_list|)
expr_stmt|;
comment|/* may cause sleep */
name|ms_softc
operator|.
name|ms_ready
operator|=
literal|1
expr_stmt|;
comment|/* start accepting events */
call|(
modifier|*
name|ms_softc
operator|.
name|ms_open
call|)
argument_list|(
name|ms_softc
operator|.
name|ms_mouse
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|msclose
parameter_list|(
name|dev
parameter_list|,
name|flags
parameter_list|,
name|mode
parameter_list|,
name|p
parameter_list|)
name|dev_t
name|dev
decl_stmt|;
name|int
name|flags
decl_stmt|,
name|mode
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
block|{
name|ms_softc
operator|.
name|ms_ready
operator|=
literal|0
expr_stmt|;
comment|/* stop accepting events */
name|ev_fini
argument_list|(
operator|&
name|ms_softc
operator|.
name|ms_events
argument_list|)
expr_stmt|;
call|(
modifier|*
name|ms_softc
operator|.
name|ms_close
call|)
argument_list|(
name|ms_softc
operator|.
name|ms_mouse
argument_list|)
expr_stmt|;
name|ms_softc
operator|.
name|ms_events
operator|.
name|ev_io
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|msread
parameter_list|(
name|dev
parameter_list|,
name|uio
parameter_list|,
name|flags
parameter_list|)
name|dev_t
name|dev
decl_stmt|;
name|struct
name|uio
modifier|*
name|uio
decl_stmt|;
name|int
name|flags
decl_stmt|;
block|{
return|return
operator|(
name|ev_read
argument_list|(
operator|&
name|ms_softc
operator|.
name|ms_events
argument_list|,
name|uio
argument_list|,
name|flags
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* this routine should not exist, but is convenient to write here for now */
end_comment

begin_function
name|int
name|mswrite
parameter_list|(
name|dev
parameter_list|,
name|uio
parameter_list|,
name|flags
parameter_list|)
name|dev_t
name|dev
decl_stmt|;
name|struct
name|uio
modifier|*
name|uio
decl_stmt|;
name|int
name|flags
decl_stmt|;
block|{
return|return
operator|(
name|EOPNOTSUPP
operator|)
return|;
block|}
end_function

begin_function
name|int
name|msioctl
parameter_list|(
name|dev
parameter_list|,
name|cmd
parameter_list|,
name|data
parameter_list|,
name|flag
parameter_list|,
name|p
parameter_list|)
name|dev_t
name|dev
decl_stmt|;
name|int
name|cmd
decl_stmt|;
specifier|register
name|caddr_t
name|data
decl_stmt|;
name|int
name|flag
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
block|{
name|int
name|s
decl_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|FIONBIO
case|:
comment|/* we will remove this someday (soon???) */
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|FIOASYNC
case|:
name|ms_softc
operator|.
name|ms_events
operator|.
name|ev_async
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|!=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|TIOCSPGRP
case|:
if|if
condition|(
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|!=
name|ms_softc
operator|.
name|ms_events
operator|.
name|ev_io
operator|->
name|p_pgid
condition|)
return|return
operator|(
name|EPERM
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|VUIDGFORMAT
case|:
comment|/* we only do firm_events */
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
name|VUID_FIRM_EVENT
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|VUIDSFORMAT
case|:
if|if
condition|(
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|!=
name|VUID_FIRM_EVENT
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
name|ENOTTY
operator|)
return|;
block|}
end_function

begin_function
name|int
name|msselect
parameter_list|(
name|dev
parameter_list|,
name|rw
parameter_list|,
name|p
parameter_list|)
name|dev_t
name|dev
decl_stmt|;
name|int
name|rw
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
block|{
return|return
operator|(
name|ev_select
argument_list|(
operator|&
name|ms_softc
operator|.
name|ms_events
argument_list|,
name|rw
argument_list|,
name|p
argument_list|)
operator|)
return|;
block|}
end_function

end_unit

