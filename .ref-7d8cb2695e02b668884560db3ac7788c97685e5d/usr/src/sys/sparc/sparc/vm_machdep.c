begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1992 The Regents of the University of California.  * All rights reserved.  *  * This software was developed by the Computer Systems Engineering group  * at Lawrence Berkeley Laboratory under DARPA contract BG 91-66 and  * contributed to Berkeley.  *  * All advertising materials mentioning features or use of this software  * must display the following acknowledgement:  *	This product includes software developed by the University of  *	California, Lawrence Berkeley Laboratory.  *  * %sccs.include.redist.c%  *  *	@(#)vm_machdep.c	7.4 (Berkeley) %G%  *  * from: $Header: vm_machdep.c,v 1.10 92/11/26 03:05:11 torek Exp $ (LBL)  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/user.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/buf.h>
end_include

begin_include
include|#
directive|include
file|<sys/exec.h>
end_include

begin_include
include|#
directive|include
file|<sys/vnode.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_kern.h>
end_include

begin_include
include|#
directive|include
file|<machine/cpu.h>
end_include

begin_include
include|#
directive|include
file|<machine/frame.h>
end_include

begin_comment
comment|/*  * Move pages from one kernel virtual address to another.  */
end_comment

begin_expr_stmt
name|pagemove
argument_list|(
name|from
argument_list|,
name|to
argument_list|,
name|size
argument_list|)
specifier|register
name|caddr_t
name|from
operator|,
name|to
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|size
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|vm_offset_t
name|pa
decl_stmt|;
if|if
condition|(
name|size
operator|&
name|CLOFSET
operator|||
operator|(
name|int
operator|)
name|from
operator|&
name|CLOFSET
operator|||
operator|(
name|int
operator|)
name|to
operator|&
name|CLOFSET
condition|)
name|panic
argument_list|(
literal|"pagemove 1"
argument_list|)
expr_stmt|;
while|while
condition|(
name|size
operator|>
literal|0
condition|)
block|{
name|pa
operator|=
name|pmap_extract
argument_list|(
name|kernel_pmap
argument_list|,
operator|(
name|vm_offset_t
operator|)
name|from
argument_list|)
expr_stmt|;
if|if
condition|(
name|pa
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"pagemove 2"
argument_list|)
expr_stmt|;
name|pmap_remove
argument_list|(
name|kernel_pmap
argument_list|,
operator|(
name|vm_offset_t
operator|)
name|from
argument_list|,
operator|(
name|vm_offset_t
operator|)
name|from
operator|+
name|PAGE_SIZE
argument_list|)
expr_stmt|;
name|pmap_enter
argument_list|(
name|kernel_pmap
argument_list|,
operator|(
name|vm_offset_t
operator|)
name|to
argument_list|,
name|pa
argument_list|,
name|VM_PROT_READ
operator||
name|VM_PROT_WRITE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|from
operator|+=
name|PAGE_SIZE
expr_stmt|;
name|to
operator|+=
name|PAGE_SIZE
expr_stmt|;
name|size
operator|-=
name|PAGE_SIZE
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  * Map an IO request into kernel virtual address space.  *  * ###	pmap_enter distributes this mapping to all contexts ... maybe  *	we should avoid this extra work  *  * THIS IS NOT IDEAL -- WE NEED ONLY VIRTUAL SPACE BUT kmem_alloc_wait  * DOES WORK DESIGNED TO SUPPLY PHYSICAL SPACE ON DEMAND LATER  */
end_comment

begin_expr_stmt
name|vmapbuf
argument_list|(
name|bp
argument_list|)
specifier|register
expr|struct
name|buf
operator|*
name|bp
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|npf
decl_stmt|;
specifier|register
name|caddr_t
name|addr
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|int
name|off
decl_stmt|;
name|vm_offset_t
name|kva
decl_stmt|;
specifier|register
name|vm_offset_t
name|pa
decl_stmt|;
if|if
condition|(
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|B_PHYS
operator|)
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"vmapbuf"
argument_list|)
expr_stmt|;
name|addr
operator|=
name|bp
operator|->
name|b_saveaddr
operator|=
name|bp
operator|->
name|b_un
operator|.
name|b_addr
expr_stmt|;
name|off
operator|=
operator|(
name|int
operator|)
name|addr
operator|&
name|PGOFSET
expr_stmt|;
name|p
operator|=
name|bp
operator|->
name|b_proc
expr_stmt|;
name|npf
operator|=
name|btoc
argument_list|(
name|round_page
argument_list|(
name|bp
operator|->
name|b_bcount
operator|+
name|off
argument_list|)
argument_list|)
expr_stmt|;
name|kva
operator|=
name|kmem_alloc_wait
argument_list|(
name|phys_map
argument_list|,
name|ctob
argument_list|(
name|npf
argument_list|)
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_un
operator|.
name|b_addr
operator|=
call|(
name|caddr_t
call|)
argument_list|(
name|kva
operator|+
name|off
argument_list|)
expr_stmt|;
while|while
condition|(
name|npf
operator|--
condition|)
block|{
name|pa
operator|=
name|pmap_extract
argument_list|(
name|vm_map_pmap
argument_list|(
operator|&
name|p
operator|->
name|p_vmspace
operator|->
name|vm_map
argument_list|)
argument_list|,
operator|(
name|vm_offset_t
operator|)
name|addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|pa
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"vmapbuf: null page frame"
argument_list|)
expr_stmt|;
name|pmap_enter
argument_list|(
name|vm_map_pmap
argument_list|(
name|phys_map
argument_list|)
argument_list|,
name|kva
argument_list|,
name|trunc_page
argument_list|(
name|pa
argument_list|)
operator||
name|PMAP_NC
argument_list|,
name|VM_PROT_READ
operator||
name|VM_PROT_WRITE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|addr
operator|+=
name|PAGE_SIZE
expr_stmt|;
name|kva
operator|+=
name|PAGE_SIZE
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  * Free the io map addresses associated with this IO operation.  */
end_comment

begin_expr_stmt
name|vunmapbuf
argument_list|(
name|bp
argument_list|)
specifier|register
expr|struct
name|buf
operator|*
name|bp
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|vm_offset_t
name|kva
init|=
operator|(
name|vm_offset_t
operator|)
name|bp
operator|->
name|b_un
operator|.
name|b_addr
decl_stmt|;
specifier|register
name|int
name|off
decl_stmt|,
name|npf
decl_stmt|;
if|if
condition|(
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|B_PHYS
operator|)
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"vunmapbuf"
argument_list|)
expr_stmt|;
name|off
operator|=
operator|(
name|int
operator|)
name|kva
operator|&
name|PGOFSET
expr_stmt|;
name|kva
operator|-=
name|off
expr_stmt|;
name|npf
operator|=
name|btoc
argument_list|(
name|round_page
argument_list|(
name|bp
operator|->
name|b_bcount
operator|+
name|off
argument_list|)
argument_list|)
expr_stmt|;
name|kmem_free_wakeup
argument_list|(
name|phys_map
argument_list|,
name|kva
argument_list|,
name|ctob
argument_list|(
name|npf
argument_list|)
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_un
operator|.
name|b_addr
operator|=
name|bp
operator|->
name|b_saveaddr
expr_stmt|;
name|bp
operator|->
name|b_saveaddr
operator|=
name|NULL
expr_stmt|;
name|cache_flush
argument_list|(
name|bp
operator|->
name|b_un
operator|.
name|b_addr
argument_list|,
name|bp
operator|->
name|b_bcount
operator|-
name|bp
operator|->
name|b_resid
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Allocate physical memory space in the dvma virtual address range.  */
end_comment

begin_function
name|caddr_t
name|dvma_malloc
parameter_list|(
name|size
parameter_list|)
name|size_t
name|size
decl_stmt|;
block|{
name|vm_size_t
name|vsize
decl_stmt|;
name|caddr_t
name|va
decl_stmt|;
name|vsize
operator|=
name|round_page
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|va
operator|=
operator|(
name|caddr_t
operator|)
name|kmem_alloc
argument_list|(
name|phys_map
argument_list|,
name|vsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|va
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"dvma_malloc"
argument_list|)
expr_stmt|;
name|kvm_uncache
argument_list|(
name|va
argument_list|,
name|vsize
operator|>>
name|PGSHIFT
argument_list|)
expr_stmt|;
return|return
operator|(
name|va
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * The offset of the topmost frame in the kernel stack.  */
end_comment

begin_define
define|#
directive|define
name|TOPFRAMEOFF
value|(UPAGES*NBPG-sizeof(struct trapframe)-sizeof(struct frame))
end_define

begin_comment
comment|/*  * Finish a fork operation, with process p2 nearly set up.  * Copy and update the kernel stack and pcb, making the child  * ready to run, and marking it so that it can return differently  * than the parent.  Returns 1 in the child process, 0 in the parent.  *  * This function relies on the fact that the pcb is  * the first element in struct user.  */
end_comment

begin_expr_stmt
name|cpu_fork
argument_list|(
name|p1
argument_list|,
name|p2
argument_list|)
specifier|register
expr|struct
name|proc
operator|*
name|p1
operator|,
operator|*
name|p2
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|pcb
modifier|*
name|opcb
init|=
operator|&
name|p1
operator|->
name|p_addr
operator|->
name|u_pcb
decl_stmt|;
specifier|register
name|struct
name|pcb
modifier|*
name|npcb
init|=
operator|&
name|p2
operator|->
name|p_addr
operator|->
name|u_pcb
decl_stmt|;
specifier|register
name|u_int
name|sp
decl_stmt|,
name|topframe
decl_stmt|,
name|off
decl_stmt|,
name|ssize
decl_stmt|;
comment|/* 	 * Save all the registers to p1's stack or, in the case of 	 * user registers and invalid stack pointers, to opcb. 	 * snapshot() also sets the given pcb's pcb_sp and pcb_psr 	 * to the current %sp and %psr, and sets pcb_pc to a stub 	 * which returns 1.  We then copy the whole pcb to p2; 	 * when swtch() selects p2 to run, it will run at the stub, 	 * rather than at the copying code below, and cpu_fork 	 * will return 1. 	 * 	 * Note that the order `*npcb = *opcb, snapshot(npcb)' is wrong, 	 * as user registers might then wind up only in opcb. 	 * We could call save_user_windows first, 	 * but that would only save 3 stores anyway. 	 * 	 * If process p1 has an FPU state, we must copy it.  If it is 	 * the FPU user, we must save the FPU state first. 	 */
name|snapshot
argument_list|(
name|opcb
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
name|opcb
argument_list|,
operator|(
name|caddr_t
operator|)
name|npcb
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|pcb
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p1
operator|->
name|p_md
operator|.
name|md_fpstate
condition|)
block|{
if|if
condition|(
name|p1
operator|==
name|fpproc
condition|)
name|savefpstate
argument_list|(
name|p1
operator|->
name|p_md
operator|.
name|md_fpstate
argument_list|)
expr_stmt|;
name|p2
operator|->
name|p_md
operator|.
name|md_fpstate
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|fpstate
argument_list|)
argument_list|,
name|M_SUBPROC
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|p1
operator|->
name|p_md
operator|.
name|md_fpstate
argument_list|,
name|p2
operator|->
name|p_md
operator|.
name|md_fpstate
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|fpstate
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|p2
operator|->
name|p_md
operator|.
name|md_fpstate
operator|=
name|NULL
expr_stmt|;
comment|/* 	 * Copy the active part of the kernel stack, 	 * then adjust each kernel sp -- the frame pointer 	 * in the top frame is a user sp -- in the child's copy, 	 * including the initial one in the child's pcb. 	 */
name|sp
operator|=
name|npcb
operator|->
name|pcb_sp
expr_stmt|;
comment|/* points to old kernel stack */
name|ssize
operator|=
operator|(
name|u_int
operator|)
name|opcb
operator|+
name|UPAGES
operator|*
name|NBPG
operator|-
name|sp
expr_stmt|;
if|if
condition|(
name|ssize
operator|>=
name|UPAGES
operator|*
name|NBPG
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|pcb
argument_list|)
condition|)
name|panic
argument_list|(
literal|"cpu_fork 1"
argument_list|)
expr_stmt|;
name|off
operator|=
operator|(
name|u_int
operator|)
name|npcb
operator|-
operator|(
name|u_int
operator|)
name|opcb
expr_stmt|;
name|qcopy
argument_list|(
operator|(
name|caddr_t
operator|)
name|sp
argument_list|,
operator|(
name|caddr_t
operator|)
name|sp
operator|+
name|off
argument_list|,
name|ssize
argument_list|)
expr_stmt|;
name|sp
operator|+=
name|off
expr_stmt|;
name|npcb
operator|->
name|pcb_sp
operator|=
name|sp
expr_stmt|;
name|topframe
operator|=
operator|(
name|u_int
operator|)
name|npcb
operator|+
name|TOPFRAMEOFF
expr_stmt|;
while|while
condition|(
name|sp
operator|<
name|topframe
condition|)
name|sp
operator|=
operator|(
operator|(
expr|struct
name|rwindow
operator|*
operator|)
name|sp
operator|)
operator|->
name|rw_in
index|[
literal|6
index|]
operator|+=
name|off
expr_stmt|;
if|if
condition|(
name|sp
operator|!=
name|topframe
condition|)
name|panic
argument_list|(
literal|"cpu_fork 2"
argument_list|)
expr_stmt|;
comment|/* 	 * This might be unnecessary, but it may be possible for the child 	 * to run in ptrace or sendsig before it returns from fork. 	 */
name|p2
operator|->
name|p_md
operator|.
name|md_tf
operator|=
operator|(
expr|struct
name|trapframe
operator|*
operator|)
operator|(
operator|(
name|int
operator|)
name|p1
operator|->
name|p_md
operator|.
name|md_tf
operator|+
name|off
operator|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * cpu_exit is called as the last action during exit.  * We release the address space and machine-dependent resources,  * including the memory for the user structure and kernel stack.  * Since the latter is also the interrupt stack, we release it  * from assembly code after switching to a temporary pcb+stack.  */
end_comment

begin_macro
name|cpu_exit
argument_list|(
argument|p
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|fpstate
modifier|*
name|fs
decl_stmt|;
if|if
condition|(
operator|(
name|fs
operator|=
name|p
operator|->
name|p_md
operator|.
name|md_fpstate
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|p
operator|==
name|fpproc
condition|)
block|{
name|savefpstate
argument_list|(
name|fs
argument_list|)
expr_stmt|;
name|fpproc
operator|=
name|NULL
expr_stmt|;
block|}
name|free
argument_list|(
operator|(
name|void
operator|*
operator|)
name|fs
argument_list|,
name|M_SUBPROC
argument_list|)
expr_stmt|;
block|}
name|vmspace_free
argument_list|(
name|p
operator|->
name|p_vmspace
argument_list|)
expr_stmt|;
name|swtchexit
argument_list|(
name|kernel_map
argument_list|,
name|p
operator|->
name|p_addr
argument_list|,
name|round_page
argument_list|(
name|ctob
argument_list|(
name|UPAGES
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
end_block

begin_comment
comment|/*  * cpu_coredump is called to write a core dump header.  * (should this be defined elsewhere?  machdep.c?)  */
end_comment

begin_function
name|int
name|cpu_coredump
parameter_list|(
name|p
parameter_list|,
name|vp
parameter_list|,
name|cred
parameter_list|)
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
name|struct
name|ucred
modifier|*
name|cred
decl_stmt|;
block|{
specifier|register
name|struct
name|user
modifier|*
name|up
init|=
name|p
operator|->
name|p_addr
decl_stmt|;
name|up
operator|->
name|u_md
operator|.
name|md_tf
operator|=
operator|*
name|p
operator|->
name|p_md
operator|.
name|md_tf
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|p_md
operator|.
name|md_fpstate
condition|)
name|up
operator|->
name|u_md
operator|.
name|md_fpstate
operator|=
operator|*
name|p
operator|->
name|p_md
operator|.
name|md_fpstate
expr_stmt|;
else|else
name|bzero
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|up
operator|->
name|u_md
operator|.
name|md_fpstate
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|fpstate
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|vn_rdwr
argument_list|(
name|UIO_WRITE
argument_list|,
name|vp
argument_list|,
operator|(
name|caddr_t
operator|)
name|up
argument_list|,
name|ctob
argument_list|(
name|UPAGES
argument_list|)
argument_list|,
operator|(
name|off_t
operator|)
literal|0
argument_list|,
name|UIO_SYSSPACE
argument_list|,
name|IO_NODELOCKED
operator||
name|IO_UNIT
argument_list|,
name|cred
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|,
name|p
argument_list|)
operator|)
return|;
block|}
end_function

end_unit

